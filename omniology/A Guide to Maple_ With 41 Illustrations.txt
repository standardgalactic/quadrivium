A 6UIO( TO MAPL( 
www.allitebooks.com

Springer Science+Business Media, LLC 
www.allitebooks.com

lRNI( KAMlRI(H 
A6UID( 
TOMAPL( 
With 411llustrations 
Springer 
www.allitebooks.com

Emic Kamerich 
Katholieke Universiteit Nijmegen 
Toemooiveld 1 
Nijmegen, 6525 ED 
The Netherlands 
emic@sci.kun.nl 
Library of Congress Cataloging-in-Publication Data 
Kamerich, Emic. 
A guide to Maple / Emic Kamerich. 
p. 
cm. 
Inc1udes bibliographical references and index. 
ISBN 978-1-4612-6436-1 
ISBN 978-1-4419-8556-9 (eBook) 
DOI 10.1007/978-1-4419-8556-9 
1. Maple (Computer file). 
2. Mathematics-Data processing. 
1. Title. 
QA76.95.K355 
1998 
510' .285'53-dc21 
98-30559 
Printed on acid-free paper. 
Maple is a registered trademark ofWaterloo Maple, Inc. 
© 1999 Springer Science+Business Media New York 
Originally published by Springer-Verlag New York, Inc. in 1999 
Softcover reprint ofthe hardcover Ist edition 1999 
All rights reserved. This work may not be translated or copied in whole or in part without the written 
permission ofthe publisher(Springer Science+Business Media, LLC), 
except for brief excerpts in connection with reviews or scholarly analysis. U se in connection 
with any form of information storage and retrieval, electronic adaptation, computer software, or by 
similar or dissimilar methodology now known or hereafter developed is forbidden. 
The use of general descriptive names, trade names, trademarks, etc., in this publication, even if the 
former are not especially identified, is not to be taken as a sign that such names, as understood by the 
Trade Marks and Merchandise Marks Act, may accordingly be used freely by anyone. 
Production managed by Anthony K. Guardiola; manufacturing supervised by Nancy Wu. 
Camera-ready copy prepared using the author's TeX files. 
9 8 7 6 5 432 1 
ISBN 978-1-4612-6436-1 
SPIN 10122799 
www.allitebooks.com

Short Reference List 
This list contains only the most basic Maple commands. AH commands ex-
plained in this book can be found in the Catehword Index. 
Elements of commands that must be typed in literally are 
printed in a typewriter font, as in the present line, or 
in a bold font. 
Elements of eommands that stand for Maple expressions to be ehosen by the user 
are printed in an italie font, as in the present line. 
1 special characters 
\!, o, 
%%, 
" 
.. " 
" 
:= 
= 
%1 
%%% 
ti nil 
terminator for commands 
the same, but without printing resuIts to 
the screen 
used in assignments 
used in equations, not in assignments 
abbreviation (in printed resuIts) 
refer to last, second last, and third last re-
suIt in Release V.5 (in command lines) 
refer to last, second last, and third last re-
suIt in releases before V.5 
" a pair of double quotes makes the se-
quence of characters to a string in Re-
lease V.5 
, 
a pair of single back quotes makes the 
sequence of characters to a symbol in 
Release Y.5 and to a string in earlier re-
leases 
, 
a pair of single forward quotes prevents 
evaluation 
used for concatenation of strings or in 
floating point numbers 
range 
* obligatory muItiplication sign 
faculty 
& prefix for special operators such as &* 
postfix, indicating a property of a vari-
able (in printed results) 
www.allitebooks.com

vi 
2 general 
{ 
Short Reference List 
-) in function detinitions, where the ex-
pression after -> is taken literally 
@ composition of functions 
@@ repeated composition of a function 
parentheses as usual in mathematics, 
also for arguments to functions 
] 
list 
} set 
, 
separator in sequences, lists, sets, and 
between arguments of functions 
_ underscore, used for internal names 
$ repeat 
•• for type testing of arguments to proce-
dures 
? 
on-line help 
constants e is entered as exp (1 ) , 7r as P i, i as 1 
eval (expr, 1 ) evaluates expr only one step 
as sume ( expr , prop ) assumes the property prop for the 
-otherwise undetined-variable or ex-
pression expr 
expr mod n ca1culates expr modulo n 
sqrt ( expr) 
square root of expr 
wi th loads package 
readlib reads a procedure from the standard li-
brary 
www.allitebooks.com

3 substitution, subexpressions 
vii 
3 substitution, subexpressions 
s ubs (old=new , expr) 
substitutes new for old in expr. 
If expr is a name referring to a procedure 
or matrix, etc., apply 
5ub5 (old=new, eval (expr)) 
For simultaneous substitution, use a list 
of equations. 
eval (expr, old=new) 
the same, but without replacing formal 
parameters, such as x in diff(f(x),x) 
simplify (expr, equation) 
simplify expr to side relation equation, 
possibly with optional third argument 
[<vars> J, indicating to which variables 
the expression should be reduced 
op ( expr) 
yields the operands of expr; 
cannot be applied to a sequence 
op (n, expr) 
yields the nth operand of expr; 
cannot be applied to a sequence 
select rrom sequence by indexing: if 5015 is a sequence, then 
5015 [2] 
yields the second element of the 
sequence 5015 
subsop (n=exprl , expr2) 
substitutes exprl for the nth operand of 
expr2 
map (proced, expr) 
applies the procedure proced to alI the 
operands of expr (possibly a list or set), 
composing the results according to the 
structure of expr 
map2 (exprl ,proced, expr2) 
applies the procedure procedto exprl as 
the first argument and the operands of 
expr2 as second argument, composing 
the results according to the structure of 
expr2 
coeff (poly, x, n) gives the coefficient of x n in the polyno-
mialpoly 
numer yields the numerator of a quotient 
denom yields the denominator of a quotient 
lhs,rhs yield the left- and right-hand side of an 
equation 
www.allitebooks.com

viii 
Short Reference List 
4 manipulating numbers and formulas 
evalc (expr) 
tries to convert a complex algebraic ex-
pression expr into something of the form 
a + b 1, where a and b are real expres-
sions, supposing that alI names in expr 
refer to real numbers 
con vert ( expr, polar) converts a complex expression expr into 
a polar form of type polar(a, ifJ), to be 
interpreted as ae<l>i 
collect (poly, x) describe poly as a polynomial in x 
expand ( expr) expands powers, multiplications, and 
function calIs in expr 
factor ( expr) factors expr over the rational numbers 
normal ( expr) converts an algebraic expression expr 
into one quotient and applies some ele-
mentary simplification rules 
combine ( expr, option ) acts 
contrary 
to 
expansion 
of 
functions, if the type of combination is 
given as opt ion. 
Possible options: 
exp,ln,power,trig,Psi, 
radical,abs, signum, plus, 
atatsign,conjugate,plot, 
product,range,polylog, 
cmbplus,cmbtms,cmbpwr, 
polylog 
simpli fy (expr, option) simplifies expr, according to the rules of 
the given option. 
Possible options: 
power,commonpow,radical, 
RootOf,polar,infinity,max, 
atsign, atatsign 
collections of functions: trig, 
arctrig, 
or the name of a function such as 
exp, In, Dirac, hypergeom, etc., 
for composition offunctions: atsign, 
for repeated compositions: atatsign 
convert (expr, option) action depends on option; many options 
are available; consult the on-line help 
convert (expr, RootOf ) converts radicals in expr into RootOf 
expressions 
www.allitebooks.com

6 solving equations 
ix 
convert (expr, radical) converts each RootOf expression in 
expr into a radical by choosing one of 
the 
values 
that 
is 
found 
with 
allvalues, ifpossible 
convert (expr, rational) converts aH the floating-point numbers 
occurring in expr, into rational numbers; 
optional third option exact 
testeq (exprl =expr2) executes a numerical test on the given 
equality. Not to be used with radicals 
and RootOf expressions. 
5 graphics and numeric al calculations 
graphics for two-dimensional plots use plot, for 
three-dimensional plots use plot3d. 
Additional procedures in the packages 
plots and DEtools. 
plot ( expr, x=a .. b) plots a graph of an algebraic expression 
expr as a function in x, where x ranges 
from a to b. Many options and varia-
tions possible. 
plot3d( expr,x=a .. b, y=c .. d) the same for three-dimensional plots 
plots [display] ({ 
} ) combine several plots into one pic ture 
evalf (expr, n) approximate aH the real numbers in expr 
by floating-point numbers. Calculations 
are executed to n digits. 
6 solving equations 
Digi ts variable that determines accuracy of 
floating-point calculations when not 
specified explicitly 
sol ve (equa, x) tries to solve equa for the variable x ex-
actly 
solve ({ equal ,equa2},{x,y}) tries to solve the system {equal,equa2} 
for the variables x and y exactly (also 
possible with larger systems) 
www.allitebooks.com

x 
Short Reference List 
f sol ve ( equa, x) tries to find an approximation to one of 
the solutions of equa for x (in case of a 
polynomial: to all solutions), also to be 
used for systems of equations 
fsolve(equa,x,x=a •• b) tries to find one approximation to a so-
lution of equa for x within the segment 
[a,b] 
7 ca1culus 
lhs,rhs yield the left and right-hand side of an 
equation 
alI values (expr) yields all possible values if the RootOf 
expressions contained in expr are solved 
as polynomial equations; it replaces 
equal RootOf expressions on several 
places by the same value if not an option 
independentisadded 
dsol ve solves differential equations: see calcu-
lus 
di f f (f( x) , x) differentiates the expression f( x) in re-
spect to the variable x with result: an ex-
pression 
D(f) 
diff (f(x,y),x,y,y) 
D[1,2,2](f) 
differentiates the function f with result: 
a function 
calculates EixEi;y2 f( x, y) 
calculates the function 
(x, y) ~ EiXEi;y2 f(x, y) 
int( expr,x) 
int (expr,x=a • • b) 
sum( expr, k=a • • b) 
product (expr, k=a • • b) 
infinity 
numerical integration 
J exprdx 
J: exprdx 
L:~ expr 
n~ expr 
is denoted as inf ini ty in Maple 
evalf (lnt (expr,x=a .. b)) calculates a 
numerical approximation to J: expr dx 
without trying to calculate the integral 
symbolically 
www.allitebooks.com

7 calculus 
xi 
series (expr, x=c, n) calculates a series expansion of expr, 
perceived as afunction in x, aroundx=c. 
The order can be determined with the aid 
of the last argument, n in this case, but 
may be lower than this number. The re-
suIt is of type series, usually. 
convert (sr, polynom) converts the expression sr, supposed to 
be of type series, into a (generalized) 
polynomial, omitting the order term 
Order variable that determines the order of se-
ries calculations, when the order is not 
specified otherwise 
Iimi t ( expr, x=a ) tries to calculate limx=a expr; a may 
be infini ty or -infinity; an option 
may be added: left, right, real, or 
complex 
dsol ve tries to solve a differential equation or 
set of differential equations 
differential equation is denoted in terms like 
diff(f(x),x,x)=-f(x) or 
D(D(f)) (x)=-f(x) 
initial conditions are given like 
f (0)=1, 
D(f) (O)=a, etc. 
- > (arrow: combination of "minus" and 
"greater than"), used for construction of 
functions, for instance 
x->x
A 2, 
(x,y)->x*cos(y) 
The expression at the right-hand side of 
the arrow is taken literally. 
For functions of more than one variable, 
parentheses around the parameters are 
obligatory. 
unappIy (expr, vars) constructs a function in vars described 
by the result of evaluating expr 
? ini f cns yields a listing of an mathematical func-
tions known to Maple at start-up 
piecewise yields piecewise-defined expression 

xii 
Short Reference List 
8 linear algebra 
start linear algebra by reading the linalg package: 
with(linalg): 
create matrix or column vector, for example 
matrixC [[1,2,3] [4,5,6]]) 
vector( [1,2,3] ) 
diagonal matrix for example diag(a, b, c) 
evaluate matrix A (or vector) with eval (A) or, 
if it contains assigned names, 
map(eval,A) 
matrix arithmetic requires always evalm, for instance 
evalm(5*A
h 2+B&*C) 
Use &* for multiplying a matrix with a 
matrix or vector, use * for scalar multi-
plications. 
transpose vector or matrix with transpose 
dotprod ( v, w) dot product of v and w 
copy (A) creates a new matri x or vector object in 
memory with the same entries as A 
det (A) determinant of A 
eigenvals, eigenvects calculate eigenvalues and eigenvectors 
of a square matrix 
colspace, rowspace calculate a basis of the linear space 
spanned by columns, or rows, of a ma-
trix 
kernel calculates the kemel of a matrix 
concat, stack glue two matrices together side by side, 
or bottom to top 

How to use this book 
If you have little or no experience with Maple, you are advised to read the first 
five chapters (70 pages) carefully, possibly skipping sections indicated with a star 
before the number. It is advantageous if you can read with Maple running on a 
computer close at hand; try out examples and experiment a little, but don't waste 
time if you get stuck on something. Probably you willlearn about that problem by 
reading ono 
If you already have some experience with Maple, reading the first five chapters 
may help you to use Maple more efficiently and to understand the basic ideas. 
If you have read the first five chapters or already know the basics of Maple well, 
you can proceed with the chapters related to your specific interests. Some of these 
chapters are directed at a mathematical field, others at a symbolic manipulation 
field. Each chapter has a preface, where you can see what you can expect in that 
chapter. At the end of the book you can find appendices on some rather special 
subjects. 
When working with Maple and encountering problems, you can consult this book 
with the aid ofthe contents and the index on catchwords. Each reference to a catch-
word corresponds to a bold printed word or a section heading in the text. It is no 
problem if you have not read preceding parts of the book; the many cross refer-
ences make it easy to find additional information when necessary. Moreover, there 
is an index on error messages, demonstrated and explained in examples in this 
book. 
If you are not a daily user, you might forget Maple commands. The most used com-
mands are summarized in the Short Reference List at the start of the book. There 
is room to write your own extension of that list. 
It is a good habit not to switch off your mind when you switch on the computer, 
even when you are to use such a powerful tool as Maple. In many examples in this 
book you can see how common mathematical sense can help considerably in using 
Maple. 
An essential aspect ofusing computer systems for calculation is the question of re-
liability of calculated results. This aspect is discussed throughout this book where 
relevant, and ways of checking andlor testing are shown. However, even where a 
calculation is said to be reliable, nobody can be sure that unknown bugs will not 
appear. Testing and checking results is a good habit in general, and more so when 
using such a complicated system. 
The present book is based on Maple V Release 5, but differences from releases 3 
and 4 are indicated where relevant. Maple output is printed in the style of output 
generated by Maple versions for windowing systems, such as for MS-Windows, 
Mac, X-terminals and -workstations, up to the choice of fonts and line breaking. 

More on Maple 
You can obtain general information on Maple, additional software (new pack-
ages in the Maple Share Library), demos, and Maple support information from 
the Maple Info Server on http://www.maplesoft.com/home.html. On this same site 
you can find titles of books on using Maple. 
Here you can also download patches for bugs; as is the case with most software, 
new releases tend to have bugs, these are attended to by the development team; 
bug fixes become available from this www-site as patch files. 
A vivid discussion on alI aspects of Maple is going on continuously in the Maple 
User Group on electronic mail, where people ask simple as welI as advanced ques-
tions or bring Maple aspects to debate, and others reply. You can subscribe to this 
group by sending an email messagetomajordomo<Ddaisy.uwaterloo.ca. with 
the message body containing the line: subscribe maple-list [<address>]. 
Acknow ledgments 
First I would like to thank the development team of Maple and the many contrib-
utors of mathematical algorithms and Maple source outside that team for creating 
such a powerful and enjoyable companion in mathematical calculations. 
I would like to thank the Mathematical Institute ofCatholic University Nijmegen, 
which offered me the opportunity for writing this book and the necessary support, 
and the computer department for their kind and patient help. 
For the writing of this book, I owe many thanks to the people whom I could in-
troduce to Maple; by their asking questions and showing me their difficulties they 
have helped me considerably in teaching the use of Maple. Another source of prob-
lems and ideas has been the discussions in the Maple User Group, whose contribu-
tors I would like to thank as welI. I would also like to thank Drs. A. Heck of Com-
puter Algebra Nederland for the productive arguments we of ten had on Maple and 
on teaching its use, and I would like to thank Professor Dr. A.H.M. Levelt of Nij-
megen University for his incentive to write this book. 
I would like to thank Drs. J.M.G. Ingelaat, Professor Dr. A.G.M. Janner at 
Nijmegen University, R.M. Cofless, D. Redfem, B. Barber, and alI the other peo-
ple, who read the book or parts of it and commented it, for their helpful comments. 
AIso I would like to thank 

xvi 
Acknowledgments 
This book has been written in TEX. I would like to thank Dr. V. Eijkhout for in-
troducing me to 1EX and helping me with some problems, and Yunliang Yu, who 
created a powerful Maple package for converting Maple expressions into TEX; 
I have adapted this package for simulating screen output of Maple commands in 
this book. 
At last I would like to thank my friends for encouraging me to write this book. 
Emic Kamerich 
In spite of alI efforts and help, undoubtedly there is room for improvements. So, 
if you have suggestions, corrections, or other remarks conceming this book, I will 
very much welcome your comments at the folIowing address: 
Dr. B.N.P. Kamerich 
Fac. of Math. and Comp. Sci. 
Catholic University Nijmegen 
Toemooiveld 1 
6525 ED Nijmegen 
The Netherlands 
fax: 0031-243652140 
electronic mail: ernic@sci.kun.nl 

Chapter 1 
1.1 
1.2 
1.3 
1.4 
1.5 
1.6 
1.7 
1.8 
1.9 
1.10 
1.11 
1.12 
Chapter 2 
2.1 
2.2 
2.3 
2.4 
2.5 
2.6 
2.7 
2.8 
2.9 
2.10 
2.11 
2.12 
Chapter3 
3.1 
3.2 
3.3 
3.4 
3.5 
3.6 
3.7 
3.8 
3.9 
3.10 
Chapter4 
4.1 
Contents 
Basic elements in the use of Maple ....................... 1 
Meeting MapIe: symbolic ca1culations ..................... 1 
Meeting Maple: numerical ca1culations .................... 5 
Meeting MapIe: symbolic ca1culations again ................ 6 
Spaces and asterisks ..................................... 8 
Terminating commands with semicolons or colons .......... 8 
Names and assignments ................................. 10 
Referring to previous results with the ditto ................. 11 
Referring to previous results with other facilities ........... 13 
Using procedures ....................................... 14 
Procedures that seem to do nothing ....................... 14 
The sign % for abbreviations in output .................... 16 
On-line help ........................................... 17 
Numbers and algebraic operators ...................... 19 
Aigebraic operators ..................................... 19 
Parentheses and precedence rules ......................... 20 
Rational numbers ....................................... 22 
Real constants .......................................... 22 
Complex numbers ...................................... 23 
Radicals ............................................... 24 
Manipulating radicals and complex numbers-an example .. 25 
Floating-point numbers, approximations .................. 26 
Some effects of automatic simplification of 
floating-point numbers .................................. 28 
Calculations with integers ............................... 29 
Integers modulo an integer .............................. 30 
Aigebraic extensions and general rings .................... 31 
Names and evaluation 1: mathematical variables ........ 32 
Assigning names to objects and evaluating names 
to objects .............................................. 32 
Assigning names and expressions to a name ............... 33 
Unassigning ........................................... 35 
Names and properties ................................... 36 
Combinations of characters that can be accepted 
as names .............................................. 37 
Greek letter names ...................................... 38 
Names with an index .................................... 39 
Single back quotes ...................................... 40 
The concepts of name, symbol, and string in Maple ........ 41 
Recursive definitions of names ........................... 41 
Elementary calculus ................................... 43 
Differentiation ......................................... 43 

xviii 
4.2 
4.3 
4.4 
4.5 
4.6 
4.7 
4.8 
4.9 
4.10 
4.11 
4.12 
4.13 
4.14 
4.15 
4.16 
4.17 
4.18 
Chapter5 
5.1 
5.2 
5.3 
5.4 
5.5 
5.6 
5.7 
5.8 
Chapter 6 
6.1 
6.2 
6.3 
6.4 
6.5 
6.6 
6.7 
6.8 
6.9 
6.10 
6.11 
6.12 
Contents 
The derivative at a point ................................. 45 
Some more tools in differential calculus ................... 46 
Antiderivatives ......................................... 46 
Special elements appearing in the results of 
the procedure int ...................................... 47 
Definite integrals ....................................... 50 
Helping Maple to find a definite integral by restricting 
the domain of a parameter ............................... 50 
Helping Maple to find an antiderivative by conversion 
to RootOf .............................................. 51 
Helping Maple to find an antiderivative by substitution ..... 52 
More tools for integration ............................... 53 
Reliability of the calculation of antiderivatives ............. 53 
Definite integrals of discontinuous functions ............... 55 
Definite integrals and branch cuts of functions ............. 56 
Reliability of calculations of definite integrals ............. 56 
Numerical integration ................................... 57 
Numerical approximations to multiple integrals ............ 58 
Definite and indefinite sums and products ................. 60 
Other tools and pedagogical facilities ..................... 62 
Names and evaluation 2: applying procedures ........... 64 
Evaluation of names in arguments of procedures ........... 64 
Options of procedures ................................... 65 
Output and results of procedures ......................... 66 
Assigning side results to arguments of procedures .......... 67 
Names referring to procedures ........................... 67 
The Maple library of procedures ......................... 68 
Asking procedures for additional information with 
infolevel ............................................ 70 
Printing standard procedures from Maple's library ......... 71 
Creating and using mathematical functions ............. 72 
Standard mathematical functions ......................... 72 
Definitions of inverse functions, branch cuts ............... 73 
Denotation of the functions exp, Gamma, and Zeta ......... 74 
Expressions versus functions, creating functions ........... 75 
Creating functions in several arguments ................... 76 
A pitfall in creating mathematical functions ............... 76 
Using existing expressions for creating mathematical 
functions .............................................. 77 
Evaluation of names of procedures ....................... 79 
Derivative functions .................................... 79 
Derivatives of functions of more than one variable ......... 81 
Conversion between diff and D ......................... 82 
Piecewise-defined functions and expressions .............. 82 

Contents 
6.13 
Chapter 7 
7.1 
7.2 
7.3 
7.4 
7.5 
7.6 
7.7 
7.8 
7.9 
7.10 
7.11 
7.12 
7.13 
7.14 
Chapter 8 
8.1 
8.2 
8.3 
8.4 
8.5 
8.6 
8.7 
8.8 
8.9 
8.10 
8.11 
8.12 
8.13 
Chapter9 
9.1 
9.2 
9.3 
9.4 
9.5 
9.6 
Chapter 10 
10.1 
10.2 
10.3 
10.4 
10.5 
xix 
Creating functions by elementary operations on functions ... 85 
Graphics .............................................. 87 
Graphs of real functions in one real parameter ............. 87 
Graphs of real functions in two real parameters ............ 88 
Assigning, manipulating, and printing graphical objects ..... 91 
Vertical asymptotes and discontinuities ................... 92 
Graphs with ranges to infinity ............................ 95 
Logarithmic scalings .................................... 96 
Parameterized curves and surfaces ........................ 97 
Different types of coordinates ............................ 99 
Empty plots caused by complex values .................. 100 
Plotting data .......................................... 100 
Graphs of relations or implicitly defined functions ........ 103 
Combining graphs ..................................... 103 
Maple's movies ....................................... 105 
More tools in graphics ................................. 105 
Taylor or Laurent expansion and limits ................ 107 
Taylor expansion ...................................... 107 
The order of a series expansion ......................... 108 
Estimating the order term .............................. 108 
The subexpression structure of results from series ....... 109 
The leading term ...................................... 110 
Laurent, Puisseux, and generalized truncated 
power series .......................................... 111 
Application of series to integration .................... 112 
Numerical evaluation of a series ......................... 113 
Multivariate Taylor expansion .......................... 113 
Calculating limits ...................................... 114 
Multiple limits ........................................ 116 
Continuity, singularities, and residues .................... 116 
Other facilities for series calculations .................... 116 
Numerical calculations with Maple .................... 117 
Accuracy ............................................. 117 
Speeding up by optimizing ............................. 118 
Speeding up with ftoating-point facilities of the system .... 121 
Some special procedures ............................... 121 
Using Fortran and C in combination with Maple .......... 122 
Data files ............................................. 122 
Manipulating several objects at once .................. 123 
Creation of sequences, sets, and lists ..................... 123 
Selecting elements of sequences, sets, and lists ........... 125 
Applying a procedure to several objects at once ........... 126 
Finding a special element in a set or a list ................ 129 
Finding the minimal or the maximal element ............. 129 

xx 
10.6 
10.7 
Contents 
Selecting the elements that satisfy a special condition ..... 130 
Generating sequences as values of a function or 
an expression ........ ..... ....... ......... ... ... .. . ... 131 
10.8 
Manipulating sequences, sets, and Iists ................... 132 
10.9 
Conversions between sequences, sets, and lists ..... .... .. 133 
10.10 
Tables .. .............................................. 134 
Chapter 11 
11.1 
11.2 
11.3 
11.4 
11.5 
11.6 
11.7 
11.8 
11.9 
11.10 
11.11 
11.12 
11.13 
11.14 
Chapter 12 
12.1 
12.2 
12.3 
12.4 
12.5 
12.6 
12.7 
12.8 
Chapter 13 
13.1 
13.2 
13.3 
13.4 
13.5 
13.6 
13.7 
13.8 
Substitution and subexpressions ....................... 136 
Some examples of substitution .......................... 136 
A substitution that fails ............ . ................... 137 
Subexpressions of polynomials, substitution .............. 138 
Subexpressions of rational expressions, substitution ....... 140 
Subexpressions ofunevaluated function caUs ............. 141 
The procedure eval ................................... 142 
The procedures subs and eval-a survey ............... 143 
More than one substitution at once ...................... 143 
The procedure PDEtools [dchange] for 
changing variables ... . ................................. 144 
Substitution of algebraic subexpressions ................. 145 
Applying side relations ................................. 146 
Finding the structure and subexpressions of 
large expressions ................................ . ..... 147 
Selecting suboperands ...... .... ...... . ... ... . . ........ 148 
Substituting something for one component of 
an expression ......................................... 148 
Manipulating and converting numbers ................ 149 
Real and imaginary parts of a complex number ........... 149 
Argument and absolute value of a complex number ..... . . 150 
The sign of a real or a complex number .......... . ....... 150 
Manipulating products and quotients of radicals .......... 151 
Nested radicals and roots of complex numbers ............ 152 
An example: substituting expressions with 
radicals in polynomials ................................. 153 
Converting ftoating-point numbers to rational numbers .... 155 
Rounding rational numbers to integers ................... 155 
Polynomials and rational expressions .................. 157 
Polynomials and the standard arithmetic operators ..... ... 157 
Division of polynomials with a remainder ................ 158 
The greatest common divisor and the least common 
multiple ....................... .. .. ..... .............. 159 
The resultant of two polynomials .................. ...... 160 
The coefficients of a polynomial .................... .... 161 
Truncating a polynomial above some degree . ............. 163 
Sorting a polynomial ... . ........ . ... ... .... . ..... . ..... 164 
SimpIifying rational expressions ............... ...... . .. 165 

Contents 
13.9 
13.10 
13.11 
Chapter 14 
14.1 
14.2 
14.3 
14.4 
14.5 
14.6 
14.7 
14.8 
14.9 
14.10 
14.11 
14.12 
Chapter 15 
15.1 
15.2 
15.3 
15.4 
15.5 
15.6 
15.7 
15.8 
15.9 
15.10 
15.11 
15.12 
15.13 
15.14 
Chapter 16 
16.1 
16.2 
16.3 
16.4 
16.5 
16.6 
16.7 
xxi 
Numerator and denominator ............................ 166 
More tools ............................................ 167 
Reliability ............................................ 167 
Polynomial equations and factoring polynomials ....... 168 
Solving polynomial equations symbolically .............. 168 
Solving modest systems of polynomial equations ......... 170 
Finding or approximating the elements represented by 
a RootOf expression ................................... 173 
Calculating with RootOf expressions .................... 174 
RootOf expressions versus radicals ..................... 175 
Factoring with the procedure factor .................... 176 
More tools for factoring ................................ 177 
Solving with numerical tools ........................... 178 
Solving complicated systems of polynomial equations 
with Grobner basis .................................... 179 
Algebraic extensions of the rational number field ......... 182 
Polynomial rings modulo ideals ......................... 185 
Polynomials over Z mod p .............................. 185 
Manipulating algebraic expressions ................... 187 
Options for simplify and combine .................... 187 
Simplifications depending on conditions ................. 188 
Sums of exponents, products of powers with equal basis ... 190 
Powers of powers, products of exponents ................ 192 
Powers of products, products of powers with 
equal exponents ....................................... 194 
Radicals .............................................. 195 
Manipulating logarithmic expressions ................... 197 
An example of the use of the option symbolic ............ 200 
Manipulating trigonometric expressions .................. 202 
Manipulating parts of expressions ....................... 206 
An example: converting a complex expression into 
a real expression ...................................... 210 
Verifying identities .................................... 211 
Reliability ............................................ 213 
General advice for manipulating ........................ 213 
Solving equations and inequalities in general ........... 214 
General principles in using Maple for solving 
equations and inequalities .............................. 214 
An example: a trigonometric equation ................... 215 
Another example: an exponential equation ............... 218 
No solutions found .................................... 219 
Inequalities and systems of inequalities .................. 220 
Manipulating equations and sets of equations ............. 221 
Solving equations numerically .......................... 224 
www.allitebooks.com

xxii 
16.8 
16.9 
16.10 
16.11 
16.12 
Contents 
Solving systems of equations numerically ................ 225 
Series of an implicitly defined function .................. 226 
Recurrence relations ................................... 229 
Solving identities, matching patterns ..................... 230 
Other procedures for solving ............................ 231 
Chapter 17 
17.1 
Solving differential equations ......................... 232 
Ordinary differential equations (ODEs): denoting, 
17.2 
17.3 
17.4 
17.5 
17.6 
17.7 
17.8 
17.9 
17.10 
17.11 
Chapter 18 
18.1 
18.2 
18.3 
18.4 
18.5 
18.6 
solving, checking solutions ............................. 232 
Ordinary differential equations with initial conditions ..... 234 
Implicit solutions and checking them .................... 235 
DESol expressions appearing in solutions ................ 237 
Numerical approximations to solutions .................. 237 
Series development of a solution ........................ 239 
Systems of ODEs ...................................... 240 
Helping Maple in solving ODEs ........................ 242 
Symbolic representations of solutions: DESol ............ 243 
Graphic tools for differential equations .................. 245 
More tools ............................................ 246 
Vectors and matrices ................................. 247 
The linear algebra package ............................. 247 
Creating vectors and matrices ........................... 248 
Evaluation of vectors and matrices ...................... 249 
Elements of vectors and matrices ........................ 250 
Matrix and vector arithmetic operators ................... 250 
Manipulating alI the elements of a matrix or 
vector at once ......................................... 252 
18.7 
Processing a matrix that contains floating-point numbers ... 253 
18.8 
Names contained in elements ofmatrices and vectors ...... 254 
18.9 
Determinant, basis, range, kernel, Gaussian elimination .... 255 
18.10 
Systems of linear equations ............................. 256 
18.11 
Characteristic polynomials and eigenvalues .............. 258 
18.12 
Dot product, cross product, norms, and orthogonal systems 
261 
18.13 
Vector calculus ........................................ 262 
18.14 
Creating new vectors and matrices from old ones by 
changing elements ..................................... 263 
18.15 
Creating new matrices from old ones by transposing, 
cutting, and pasting .................................... 265 
18.16 
Alternative ways of creating vectors and matrices ......... 265 
18.17 
Special types of matrices: (anti)symmetric, sparse, 
identity ............................................... 266 
18.18 
Creating more special types ofmatrices .................. 270 
18.19 
Functions yielding vectors and matrices .................. 270 
18.20 
Vectors and matrices modulo an integer .................. 272 
18.21 
Reading a matrix of data from a file ..................... 273 

Contents 
18.22 
AppendixA 
A.I 
A.2 
A.3 
AA 
A.5 
A.6 
A.7 
A.8 
A.9 
A. 10 
A.II 
AppendixB 
B.I 
B.2 
B.3 
BA 
B.5 
B.6 
AppendixC 
C.1 
C.2 
C.3 
CA 
C.5 
AppendixD 
D.1 
D.2 
D.3 
xxiii 
Pedagogic al facilities .................................. 273 
Types, properties, and domains ........................ 274 
Basic types ........................................... 274 
More types ........................................... 275 
Selection on type ...................................... 277 
Properties, the assume faci1ity .......................... 277 
Derived properties ..................................... 278 
Asking for the assumed properties ....................... 278 
Adding properties ..................................... 279 
Combining properties .................................. 279 
Properties and assigning ................................ 280 
Properties and formal parameters ........................ 281 
Domains, the Domains package ......................... 282 
Names and evaIuation 3: some special features ......... 284 
Changing names, alias ............................... 284 
Finding names used .................................... 286 
Indexed names ........................................ 286 
Quotes with table, arrays, vectors, and matrices ........... 287 
Recovering lost procedures ............................. 288 
Exceptions to the rule of automatic fuU evaluation ........ 288 
The user interface for text-only versions ............... 290 
Starting, interrupting, and quitting Maple ................ 290 
Editing commands ..................................... 290 
Pictures .............................................. 291 
Maple system messages ................................ 291 
Saving a session and its results .......................... 291 
Procedures remembering previous results .............. 292 
Remember tables of procedures ......................... 292 
Clearing (parts of) the remember table ................... 294 
An example of side effects of the remember table: 
infolevel ........................................... 294 
Appendix E Control structures .................................... 296 
E.I 
Procedures ............................................ 296 
E.2 
Searching for causes of odd behavior with trace Of 
printlevel ......................................... 298 
E.3 
Using if ... fi for choices ........................... 298 
EA 
Recursion. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 299 
E.5 
Using do ... od for repeating actions .................. 301 
E.6 
An example: checking the results of sol ve by 
substituting ........................................... 304 
Error messages and warnings ...................................... 309 
Catchword index .................................................. 310 

chapter 1 
Basic elements in the use of Maple 
The first three sections of this chapter introduce you to Maple with some basic ex-
amples in solving equations, both numerically and symbolically. At the same rime, 
you see some general aspects of using Maple, such as giving commands and as-
signing values to variables. These are discussed systematically in the subsequent 
sections, where some common users' mistakes are also demonstrated. Moreover, 
these sections show some more basic examples of calcularions and the on-line help 
system of Maple. 
1.1 Meeting Maple: symbolic calculations 
When you start Maple on your computer, you can see the cursor waiting for your 
input at the right of the input prompt, usualIy" > " 
If you see a cursor with a question mark, Maple is in the state of "math input", 
where commands Can be entered with the aid of the mouse and the palettes of sym-
bols. You can change to the usual input from the keyboard by entering Control-J 
or by choosing execut ion group from the Insert menu of the toolbar at the 
top of the window. 
Suppose that we are interested in a function in (positive) x, described by the for-
mula 
16x2 - 24x + 121 
32x2 - 48x + 34 
This fonnula can be entered in Maple at the right of the prompt by typing 
(16*x~2 -
24*x + 121) / 
(32*x~2 - 48*x + 34) 
Please note that the spaces are optional, but can be useful for readability. 
Now we type a semicolon ( ; ) and press the Enter key. (In the state of math input 
the semicolon is omitted.) Then the screen looks like 
> (16*x~2 - 24*x + 121) / 
(32*x~2 - 48*x + 34); 
16x2 - 24x + 121 
32x2 - 48x + 34 
Although the fonnula has to be entered in a simple linear way, Maple presents it in 
the usual, much more readable fashion. IfMaple has been started in a tty (charac-
ters only) system (MS-DOS or Unix for instance), fonnulas are still presented in 
the same style, but there are some restrictions in the presentation of special sym-
bols. AlI screen parts presented in this book are printed in the style of Maple on 
windowing systems (such as Ms Windows), but line breaking may be different and 
the left brackets in the Maple command screen are omitted. 
E. Kamerich, A Guide to Maple
© Springer Science+Business Media New York 1999

2 
1. Basic elements in the use of Maple 
First, let's make a graph. In the next command the percentage sign % is used for 
referring to the previous formula. 
> plot( % , x = O .. 10 ); 
7 
6 
4 
2 
o 
4 
X 
6 
8 
10 
Maple has read the last command as if we had typed 
plot«16*x-2-24*x+121)/(32*x-2-48*x+34),x = O .. 10); 
In Maple the percentage sign % is called the ditto. In releases before Maple V.5, 
the double quote " is used for the ditto. 
It is a good idea to assign the formula to a name, say peak. For this purpose, we 
have to ditto the formula again. That is possible with the twofold ditto, as the for-
mula is the second last result. 
> peak := %% ; 
peak := 16x2 - 24x + 121 
32:z;? - 48x + 34 
From now on, Maple reads peak as that formula. 
Let's suppose that we intend to compare the previous expression with another ex-
pression in x, 
> (476*x+891)/(484*x+53); 
476x + 891 
484x + 53 
and that we want to know the area of the region where the tirst expression exceeds 
the second one. 
Let's assign this second formula to a name as well: 

1.1 Meeting Maple: symbolic calculations 
> fan := '/, ; 
fi II '= 476 x + 891 
a . 
484 x + 53 
3 
In order to compare both, we can plot them together first. Because of the vertical 
asymptote offan, we must restrict the vertical range ofthe plot, say to the range 
0 ... 8. 
> pIot( { peak , falI} , x=0 .. 10 , 0 .. 8 ); 
8 
7 
6 
5 
4 
2 
o 
2 
4 
X 
6 
8 
10 
Braces are used as they are used in mathematics: for denoting a set. The last argu-
ment restricts the range of the second coordinate to [0,8]. 
Our intention is to compute the area between the curves where the value of peak 
is larger than the value of lalt. First, let's tind the x for which both are equal. If 
you are using a windowing version of Maple, you can get approximations to the 
coordinates of the intersection points by pointing with the mouse and clicking, but 
you can also ask Maple to solve the following equation: 
> peak = fan; 
16x2 - 24x + 121 
476 x + 891 
32x2 - 48x + 34 
484x + 53 
> solve( '/, , x ); 
11 
5 
5 
-
--+2V3 ---2V3 
36' 
4 
'4 
As could be guessed from the equation, we obtain three solutions. Generally, 
solving third-degree equations yields much longer results. This is no problem for 
Maple, but this example has been chosen in order to tind a more readable result. 
The present solutions are expressed in an exact way, using rational numbers and 

4 
1. Basic elements in the use of Maple 
square roots. This is typical for a symbolic calculator such as Maple. Approx-
imations are avaiIable as well by applying the procedure evalf ("evaluate to a 
floating-point number"). 
> evalf( [%] ); 
[.3055555556, 2.214101616, -4.714101616] 
Square brackets are used for denoting a list. The solutions are bundled here into 
a list because evalf can approximate only one object, and this object may be an 
expression or a list of expressions, etc., but not a sequence of expressions; a more 
detaiIed explanation is given in section 10.3 on page 127. 
In order to compute the area of the region where the first function exceeds the sec-
ond one, the difference should be integrated from the first to the second solution. A 
solution can be selected from the sequence of solutions by indexing, for instance: 
> %%[1]; 
11 
36 
So the desired integral can be calculated by 
> int( peak-fall , x = %%%[1] .. %%%[2] ); 
19211 -
~~~ V3 + ~ 0 arctan( ( -2 + 2 V3) 0) + 
25376 ln(2) _ 25376 ln(-69 
121 V3) 
14641 
14641 
+ 
+ 
13 
(4) 25376 
50752 
"4 0 arctan 9 0 
+ 14641 ln(113) - 14641 ln(3) 
Again, Maple has calculated this in an exact way. Let's approximate this to 40 
digits: 
> evalf( % , 40 ); 
3.822742863575994928443933759352133657199 
You may have wondered if we could not tell Maple beforehand that we want only 
positive solutions of the equation peak = fali. However, if a symbolic solution 
is a very complicated expression, it may take some clever, complicated, and time-
consuming manipulations in order to see in a symbolic way if this expression is 
really a positive number or not; see Chapter 12, Manipulating and converting num-
bers, and Chapter 15, Manipulating algebraic expressions. Automatic manipula-
tions without the help of a user may even faiI to prove that a number is positive. 
Therefore, the decision is left to the user. Usually, a f1oating-point approximation, 
possibly with a high level of Digi ts, is an effective tool for such a decision, al-
though symbolic manipulation may be necessary if a strict mathematical proof is 
required. 

1.2 Meeting Maple: numeric al calculations 
5 
1.2 Meeting Maple: numeric al calculations 
In the previous section, exact results have been found and these have been approxi-
mated. It is also possible, and of ten necessary, to calculate numeric results directly. 
For instance, in the previous example, Maple had to solve a polynomial equation 
of degree 3. But there is no method for solving alI polynomial equations, although 
Maple always tries to solve a high-degree polynomial equation by special tricks. If 
this is not successful, you may want to revert to numeric al calculations. Here you 
see how the previous problem can be handled by the numerical equation solver of 
Maple, the procedure fsol ve ("ftoating-point solve''). 
> fsolve( peak=fall , x ); 
.3055555556 
We achieve just one solution. The graph indicates that there are two more solu-
tions, one between O and 1 and the other between 2 and 3. We can ask for them by 
specifying these ranges. 
> fsolve( peak=fall , x , x=O .. l ); 
.3055555556 
However, this equation can be handled in a much more elegant way by converting it 
to a polynomial equation as folIows. First we convert peak - lall into one quotient 
with normal: 
> normal(peak-fall); 
13 576 x 3 + 1264 x 2 - 6452 x + 1837 
2 (16x 2 - 24x + 17) (484 x + 53) 
Now let's solve for which x the numerator is zero. 
> numer(%); 
-7488x3 - 16432x2 + 83876 x - 23881 
> fsolve( %=0 , x ); 
-4.714101615, .3055555556, 2.214101615 
Maple uses a specific numerical method for solving polynomial equations, yielding 
alI real solutions at once. All solutions of such a polynomial equation, including 
complex ones, can be found by the command f sol ve ( 
,x, complex) . 
It is easy to obtain solutions with a higher accuracy by changing the value of Digits. 
If we want solutions to 50 digits, we have to set the variable Digi ts to 50. 
> Digits := 50: 
Maple did not print a result on the screen for the last command because the com-
mand ended with a colon ( : ) instead of a semicolon ( ; ). 

6 
1. Basic elements in the use of Maple 
> fsolve( %%% , x ); 
-4.7141016151377545870548926830117447338856105076208, 
.30555555555555555555555555555555555555555555555556, 
2.2141016151377545870548926830117447338856105076208 
Let's reset Digi ts immediately to its usual value. 
> Digits := 10: 
Maple has many powerful numerical algorithms. For instance, we can calculate 
the earlier integral in a numeric al way as weB. A very convenient aspect of using 
Maple is the combination ofboth symbolic and numeric al calculations (and plot-
ting) in the same environment. However, ifyou want to take symbolic results over 
to specialized numerical routines in Fortran or C, Maple offers translators for this 
purpose; see section 9.5 on page 123. 
1.3 Meeting MapIe: symbolic ca1culations again 
Often, numerical methods are not realIy satisfactory, especially when using un-
known parameters. Here is an equation containing a parameter p: 
> 18*p
A 2*x
A 4 + 36*p
A 3*x
A 2 + 36*p*x
A 3 + 72*p
A 2*x 
+ 63*x
A 2 + 27 = 27*p
A 2*x
A 2 + 54*x
A 4 + 
108*p*x
A 2 + 54*p*x + 36*p; 
18 p2 x4 + 36 p3 x2 + 36px3 + 72 p2 x + 63x2 + 27 = 
27 p2 x 2 + 54x4 + 108px2 + 54px + 36p 
As you can see, it is easy to enter large formulas: Maple continues on the next 
line(s) until alI is entered, then you can terminate it with a semicolon. You can 
force a new line by pressing the Enter key; in windowing systems you then get a 
waming: 
Warning. incomplete statement or missing semicolon 
but that is only a reminder. 
Let's assign this equation to a name. In Maple a narne can refer to a number, an 
expression, an equation, a procedure and many other things. 
> eq := % ; 
eq := 18 p2 x 4 + 36 p3 x2 + 36px3 + 72 p2 x + 63x2 + 
27 = 27 p2 x 2 + 54x4 + 108px2 + 54px + 36p 
Let's solve for x. A numerical solver would be useless because p is contained in 
the equation, so we use sol ve. 

1.3 Meeting Maple: symbolic calculations again 
7 
> solve( % , x )j 
1 
1 
1 -2p + 2 J2 p2 - 3 
2 J-8p+6, -2 J-8p+6, 2 
p2 - 3 
' 
1-2p-2J2 p2-3 
2 
p2-3 
It is important to realize that the equation is solved only for a "general" p. Let's 
have a closer look at this aspect by following the steps in this solving process. 
Maple has solved a fourth-degree polynomial equation. Let's have a look at this 
polynomial. First take the difference of the left-hand side and the right-hand side 
of the equation with lhs and rhs: 
> poly := lhs(eq)-rhs(eq)j 
poly := 18 p2 x 4 + 36 p3 x2 + 36px3 + 72 p2 x + 63x2 + 
27 - 27 p2 x2 - 54x4 - 108px2 - 54px - 36p 
The result is assigned to the name poly. Let's write this as a polynomial in x. 
> collect( % , x ); 
(-54 + 18p2) x4+36px3+(63 - 108p - 27 p2 + 36 p3) x2+ 
(72 p2 - 54p) x + 27 - 36p 
For special values of p (viz. V3 and -V3), the coefficient of x4 is zero. Conse-
quently, the general solution given by Maple cannot be applied to the cases where 
p = V3 or p = -V3. 
Names are interpreted as general abstract objects in Maple. 
Substituting special values for names in the result of a command 
does not always yield a correct result 
for the corresponding special mathematical problem. 
This special problem can be solved simply by substituting these special values and 
solving the corresponding special problem separately. So let's substitute p = V3 
in the original equation and solve the resulting equation. 
> subs( p=sqrt(3) , eq ); 
54 x 4 + 108 v'3 x 2 + 36 v'3 x 3 + 216 x + 63 x 2 + 27 = 
81 x2 + 54x4 + 108 v'3x2 + 54 v'3x + 36 v'3 
> solve( % , x ); 
~ /'--6 --8-v'3-3 - ~ /6 - 8 v'3 ~ '3 
2 V 
'2 V 
' 6 V0 

8 
1. Basic elements in the use of Maple 
The third element of this solution is not contained in the solution for general p. The 
same can be done for p = -V3. 
Special cases for special values of parameters 
have to be looked for by the user, possibly with Maple as a tool. 
More on this subject can be found in R.M. Corless and DJ. Jeffrey: Well ... It 
Isn't Quite That Simple, Sigsam Bulletin 26 (1992). 
You have seen enough examples for now. It is time to look more systematically at 
some details. 
1.4 Spaces and asterisks 
Generally, spaces are neglected by Maple. 
* 
q; 
ab+pq 
However, spaces can improve readability; thus the frequent use of spaces in Maple 
commands printed in this book. 
In printing output, Maple represents multiplication by inserting spaces between the 
factors, which might be tempting you to use spaces to denote multiplication in the 
input. This, however, is not accepted by Maple; Maple reports a syntax error, in-
dicating the first offending character by the cursor, in this case the character b: 
> a /b; 
Syntax error, missing operator or ';' 
Because Maple can use names of more than one character, the product of a and b 
cannot be entered as ab either. Maple requires the asterisk (*) for each multipli-
cation. 
1.5 Terminating commands with semicolons or colons 
Each Maple command must be terminated with a semicolon ( ; ) Of with a 
colon ( : ). (This is not true if you have changed the Input Display form Maple 
Notation to Standard Math in the Options menu: then no terminator is expected.) 
Pressing the Enter key makes the present line enter the Maple system, but if no 
terminator is detected at the end of the command, the line is supposed to be in-
complete and it must be continued on the next line. In windowing versions of 
Maple the user gets a waming message incomplete statement or missing 
semicolon. 
It can easily happen that a user forgets the obligatory terminator: 
www.allitebooks.com

1.5 Tenninating commands with semicolons or colons 
> arcsin(1/2) 
> 
Warning, premature end of input 
9 
After that waming, you might be tempted to enter the line again, adding a semi-
colon. But then Maple gets really cross and issues a syntax error; from the first 
command you can see the following on the screen: 
> arcsin(1/2) 
> arcsijn(1/2); 
Syntax error, missing operator or ';' 
In a windowing version you can see a bracket in the left indicating that both lines 
are taken together as one command. The transition to the second line is interpreted 
as a space: arcsin(1/2) arcsin(1/2); . (These brackets are omitted in this 
book, but here such a bracket can help to see what has happened.) 
Maple puts the cursor on the second line, which seems to be a perfect line, but 
entering this again by pressing the Enter key does not work, because both lines are 
still read together. The remedy is simple: 
If you have forgotten the terminating semicolon, 
type this semicolon on the next line and press the Enter key again, 
or move the cursor back to the previous line, 
add the semicolon, and press Eoter. 
For instance, in the previous example: 
> arcsin(1/2) 
> ; 
1 
-7r 
6 
If you are using a Maple version for text-only command screens such as MS-
DOS Maple and Maple for Unix systems, you must be careful about missing 
(semi)colons, and it might be worthwhile to look at Appendix C, The user interface 
for text-only versions. 
It is possible to give more than one command in one line. Here for instance the 
roots of the derivative of an expression are calculated: 
> x
A 3 + 11*x
A 2 - 16*x; diff(%,x); solve( % , x ); 
x 3 + 11 x 2 - 16 x 
3x2 + 22x -16 

10 
1. Basic elements in the use of Maple 
2 
-8, 3 
The results from the commands an that one line are printed an subsequent lines. 
Sometimes it is more efficient if Maple does not print the result of a command ta 
the screen. For instance, after the command ta elaborate (x + f)12 
> expand( (x + y/3)-12 ); 
22 
220 
55 
88 
X 12+4yxll +_y2 X lO+_y3 x9+_y4 X 8+_y5 x7 + 
3 
27 
9 
27 
308 
6 
6 
88 
7 
5 
55 
8 
4 
220 
9 
3 
243 Y x + 243 y x + 729 y x + 19683 y x + 
22 
10 
2 
4 
11 
1 
12 
19683 y 
x + 59049 y 
x + 531441 y 
you might wish ta preserve the result by assigning it ta a name. It is useless ta 
see this formula again, sa we terminate the command with a colon; this prevents 
Maple from printing the result an the screen. 
> pow := % : 
Maple has executed the command and has stored the resulting expression for call-
ing with the ditto. However, you do not see the result because of the colon at the 
end of the command. 
1.6 Names and assignments 
The combination of colon and equal sign ( := ) is used ta assign a Maple abject ta 
aname: 
> y := a*x-2-1; 
y := ax2 - 1 
From now an, in almost any instance where Maple encounters y, it reads this as 
a x2 - 1. A mathematician could say: "y is a formula in the free variables x and 
a." In terms of Maple: "y, x, and a are names, where y is a name that refers to 
an expression, while x and a do not refer ta anything." 
Be careful about capitals in names: Maple distinguishes between lower case and 
upper case: 
> Y - y; 
y - ax2 + 1 
In mathematics, variables usually have one-Ietter names, but in Maple, words can 
be used. In section 3.5 an page 37 you can read more about combinations of char-
acters that Can ar cannot be used as a name. 
A typical mistake is the use of = ar : instead of : = in an assignment. Here is 
an example where both mistakes are shown. 

1.7 Referring to previous results with the ditto 
11 
> xl = 10; 
xl = 10 
> x2 
20; 
20 
> xl + x2; 
xl +x2 
The first line yields an equation. The second line consists of two Maple commands: 
the first asks Maple to evaluate x2, but Maple does not print the result to the screen 
as the command is terminated with a colon. The second command on this line asks 
Maple to yield 20. So both xl and x2 stay unassigned and the last line yields sim-
ply xl + x2. 
1.7 Referring to previous results with the ditto 
As you have seen, it is possible to refer to the previous result with the ditto ( % ). 
In order to refer to results one or two steps earlier, you can use a two- or threefold 
ditto. 
Here is an example. First the antiderivative (indefinite integral) of an expression 
is ca1culated. 
> 1/x/(a*x~2+b*x)~(3/2); 
1 
x (ax2 + bx)(3/2) 
> integrate( % , x ); 
_~ 
1 
+~ a(2ax+b) 
3 b x v'a x2 + b x 
3 ~b3;:-v-'-;=a=x""'2=+======b=x 
> normal( % ); 
2 - b2 + 8 a2 x 2 + 4 a x b 
3 
b3 X v'a x2 + b x 
Now the result of integrate can be checked easily by comparing its derivative 
with the original expression by using the two- and threefold ditto. 
> normale diff(%%,x) -
%%% ); 
o 
In the last line the twofold ditto caUs the second last result, the result of inte-
grate ( % , x ); and the threefold ditto caUs the third last result. the original 
expression. 
One might be tempted to enter something like: 

12 
1. Basic elements in the use of Maple 
> newvar; 
newvar 
> % := 100; 
%:= 100 
If the second command was meant to assign 100 to newvar, it was not successful. 
Maple seems to be willing, but the output of the last command already indicates 
that something else happened: only the ditto is made to refer to 100, not newvar: 
> newvar; 
newvar 
If you are using the ditto, remember that the re suit of a command terminated by 
a colon is put on the ditto stack as well, although the result is not printed on the 
screen. For example, 
> r20: 
> % / r18; 
49 
Some commands do not yield any result as far as the ditto is concemed. For in-
stance, the procedures print and lprint. 
> lprint(x~2/3); 
1/3*x~2 
> %; 
49 
The ditto does not refer to the last command line, but to the last result. Remember 
that more than one command can be given on one line, of ten generating more than 
one result. 
If you are using a windowing version, it is possible to execute any previous com-
mand again by mov ing the cursor to that line and pressing the Enter key. You can 
also change the command by editing before issuing. However, this command will 
use the present values of variables, and dittos will refer to the present history of 
results. If this command yields a result, this is the last result at that moment. A 
ditto in the command next issued will refer to that very result, which may not be 
the result of the command above it in your worksheet. 
It is not possible to refer to earlier results than the third last result with the ditto 
facility. 
If you are used to the double quote as the ditto in earlier releases, you might do 
things such as: 

1.8 Referring to previous results with other facilities 
> a+Pi; 
a+7r 
> (cos(")+1)~2; 
Warning, incomplete string; use II to end the string 
(note that the ditto operator is now % instead of ") 
13 
The best thing you can do is edit the input line, replacing II with %. When you 
follow the advice and enter a double quote, Maple is still not content: 
> II. , 
; unexpected 
This is caused by the parentheses in the start of the input: (cos ( . In a windowing 
version of Maple it will be necessary to enter these extra parentheses; correct the 
input line into: 
> ")); 
Error, cos expects its lst argument, x, to be of type algebraic, 
but received 1)+1)-2;\n" 
After this error, Maple is ready for new input. 
In a text-only version, don't bother about it: Maple reports a syntax error and is 
ready for new input. 
1.8 Referring to previous results with other facilities 
In windowing versions you can select a previous result by pointing to that result 
with the mouse and then pressing Control with the left mouse button Of by triple 
clicking with the left button. Then press Control-C to copy it to the clipboard, put 
the cursor on the correct input line, and press Control-V to paste it there. Don't 
forget to add a terminator. You can edit the expression before pressing the Enter 
key. If the Output Display is in Editable Math Notation (see the Options menu), 
the default at start-up, then you can select syntactically valid portions of an output 
expression by pressing the left mouse button, keeping it pressed, and dragging the 
mouse over that part. 
Some versions of release V.S (MS Windows and Mac) offer a spreadsheet facility. 
If you are experimenting with the input for a ca1culation over several command 
lines, this can be a very comfortable tool: for the ca1culation in one cell you can 
refer to the content of other cells, and changes in one cell will cause reca1culation 
in ali the other cells referring to this cell. 
An old, rather primitive facility is showtime. After the command showt ime () , 
results are stored by assigning them successively to the names 01, 02, etc. (the 
character O, followed by a number). Moreover, for each command, processor time 
and workspace are shown. 

14 
1. Basic elements in the use of Maple 
1.9 U sing procedures 
Let's have a close look at what happens when a procedure is applied. Here is an 
example: 
> form := (10*x~2-15*x)/(2*x~3+2*x-3*x~2-3) + 1; 
f 
lOx2 -15x 
1 
arm:= 
+ 
2 x3 + 2 x - 3 x2 - 3 
> normal(form); 
x2 +5x+l 
x 2 + 1 
What has happened due to the second command is 
- the argument form has been evaluated to the formula to which it refers 
- the procedure normal has converted this formula into one ratio and it has di-
vided out the common factor 2x - 3 from numerator and denominator 
- the result has been printed to the screen 
- and it has been 'stacked up' by Maple so that a ditto in the next command can 
recaB this result. 
By applying normal to form we have not changed the reference of form: 
> form; 
lOx2 -15x 
+ 1 
2 x3 + 2 x - 3 x2 - 3 
The procedure normal could not have changed the value of form because form 
was evaluated (its value was looked up) before normal carne into action. 
This example illustrates the usual action of procedures: the arguments are evalu-
ated first, then the procedure uses the results of these evaluations to calculate the 
next result. 
1.10 Procedures that seem to do nothing 
Sometimes a procedure seems to do nothing: 
> normel(form); 
( 
10x2 - 15x 
) 
normeI 2 x3 + 2 x _ 3 x2 _ 3 + 1 
Here Maple finds an unknown name of a procedure. For our eyes it may seem 
to be a mistyping of normal. Maple does not protest, but prints the unevaluated 
procedure caB on the screen. The idea behind it is the possibility that a procedure 
normeI might be defined later. 

1.10 Procedures that seem to do nothing 
15 
In the next command, the procedure sin is applied to 1; this procedure tries to 
simplify the expression sin(1), but no better expression is found, so the function 
call itself is retumed. 
> sin(l); 
sin(1) 
This is called an unevaluated function caII. Generally, if asked for, Maple can 
supply an approximation in such a case. 
> evalf( % , 30 ); 
.841470984807896506652502321630 
Here we have asked for an approximation of sin(1) to 30 decimals. 
Sometimes, applying a procedure can yield an error message, or an unexpected 
result, possibly just silence. Then you can ask Maple for some elucidation about 
its activities by using infolevel. For instance, if we ask for the exact solutions 
of the equation sin( x2 ) = x3 in x, we cannot expect Maple to find them: 
> sin(x~2)=x~3; 
> solve( % , x ); 
> 
It is clear that there are solutions: O is a solution, but no result or message is printed. 
We can ask for more information: by setting the infolevel for sol ve: 
> infolevel[solveJ := 3: 
> solve( %% , x ); 
solve/rec2: 
solving for linear equation in 
_S03 
solve/rec2: 
solving for linear equation in 
_SOi 
solve/rec/RootOf: 
RootOfs substitution 
_S04 = RootOf(-_S03 A 3+_Z A 2) 
solve/rec2: 
solving for linear equation in 
_S04 
solve: 
Warning: no solutions found 
solve: 
Warning: solutions may have been lost 
Now we can see that Maple gives it a try with the aid of many tricks, but has to 
give up in the end and then wams that solutions may have been lost. 
The value of the infolevel of a procedure can be set to O, 1, 2, 3, 4, or 5. If the 
value is set to 0, then no additiona1 information is given. Generally, the value 1 
gives sufficient information. 
It is a good idea to reset things immediately: 
> infolevel[solveJ := O: 

16 
1. Basic elements in the use of Maple 
1.11 The sign % for abbreviations in output 
For complicated results, Maple can make results more readable by using abbrevi-
ations. For instance, 
> x~3 - a*x - 1; 
x3 - ax-l 
> solve( % , x ); 
1 %1(1/3) + 2 
a 
6 
%1(1/3) , 
1 
a 
1 m(1 
12 %1(1/3)_ %1(1/3) +2 1 v3 (; %1(1/3) - 2 
1 
a 
1 m(1 
12 %1(1/3) -
%W/3) 21 v 3 (; %1(1/3) - 2 
%1 := 108 + 12 J-12a3 + 81 
%1~1/3) ) , 
%1~1/3) ) 
The result of sol ve is a sequence of three numbers. This is printed with the use 
of an abbreviation %1 for a common subexpression. The last line of the output 
describes the meaning of this abbreviation. 
The abbreviation system is standard in releases before V.5 and in text-only ver-
sions of release V.5, but in windowing versions of release V.5 abbreviations are 
used only if you change Output Display from Editable Math Notation (the de-
fault) to Typeset Notation (or one of the other two choices) in the Options menu. 
For improving readability, aII the output in this book is printed in Typeset Notation 
with these abbreviations. 
The present abbreviation can also be called by the user as long as Maple has not 
cleareditout: 
> %1; 
108 + 12 J -12 a3 + 81 
If we ask for the first solution, Maple does not use this abbreviation, because, in 
each case, Maple decides separately which abbreviations are useful, if any. For 
instance, let's ask for the first solution only by taking the first element of the second 
last result: 
> %%[1]; 
1 ( 
)(1/3) 
a 
6" 
108+12J-12a3 +81 
+2 
(1/3) 
(108 + 12y'-12a3 + 81) 

1.12 On-line help 
17 
1.12 On-line help 
Maple offers a simple and comprehensive guide to its facilities by its on-line help. 
The HeI p menu activates a hypercard system (only from Release 4) for a search for 
help on the word at the cursor (possibly the first characters of a word) or a search 
by topic or a search for alI places in the help texts for a word. In a help page you 
can c1ick with the mouse on an underscored word for getting specific information 
on that subject. 
For instance, we can ask for help on substitution. We choose Topi c Search from 
the Help menu. As soon as we have typed one or more letters, we see a list of 
topics, the first letters of which are equal to the letters entered. In this way, we can 
ask for help on the procedure subs. In all versions of Maple, also in text-only (tty) 
versions of Maple, there is another method of getting on-line help: type a question 
mark and then the catchword. 
Now let's suppose that we ask for help on the topic subs. In the following, the 
help text given by Maple is printed in parts with some explanations thereafter: 
First, the purpose of subs and the syntactically correct way to use subs is de-
scribed in a formal way. 
Function: subs - substitute subexpressions into an expression 
Then you can see how subs can be used: 
Calling Sequence: 
subs(x=a,expr) 
subs(sl, ... ,sn,expr) 
up to now, only the first way of using subs has been demonstrated. 
Then you can see what type of parameters can be used. Types will be explained in 
section 11.3 on page 139 and section A.l on page 275. 
Now a description of the action of subs is given: 
Description: 
• The tirst form of the subs command substitutes a for x in the 
expression expr. 
The remaining part of the description is omitted here; these remarks require expla-
nations given later in this book. 
Of ten, the fastest way to get an idea of the use of a command is reading the "Ex-
amples" at the end of the help text. If you had forgotten the way subs should be 
used, the first example might suffice. 
Examples: 
> subs( x=2, x"2+x+ 1 ); 
The remaining examples are left out here. 
This information can be retrieved separately by the command ???subs. 

18 
1. Basic elements in the use of Maple 
At the very end of the help text, Maple refers to related subjects. This can be very 
helpful, for instance, when you do not know the name of a procedure that can do 
the job; if you know a name of a procedure that does something related, you can 
ask for help for the known procedure and look at the end. 
See Also: op, subsop, eval, algsubs, lirnit 
This list of related topics can be retrieved separately by the command 
related(subs). Each ofthe underlined words can be clicked on in order to get 
information about this topic. 
The help system can do more than just explain Maple procedures. For example, 
you can get a description of the changes made in new releases of Maple under the 
topic updates. 
Ifyou want to search the on-line help system systematically 00 a text-only system, 
enter ?index to see the categories available. 
www.allitebooks.com

chapter 2 
Numbers and algebraic operators 
In this chapter, various types of numbers are discussed together with their alge-
braic operators: rational numbers, radicals, special real numbers such as 7r, com-
plex numbers, jloating-point approximations, integers, and Z modulo n. 
Toolsfor manipulating and converting numbers are discussed in Chapter 12, Ma-
nipulating and converting numbers, but the basic ideas for manipulating radicals 
and complex numbers are demonstrated in the present chapter. 
2.1 Algebraic operators 
In Maple, the main algebraic operators for sum, difference, product, quotient, and 
power are entered successively as +, -, *, / and A. Parentheses are entered as usual 
in mathematics: 
> p*(2*a-b)~5/(c+7); 
p (2a - b)5 
c+7 
The results found by Maple are presented in the customary two-dimensional way, 
but a formula must be entered in a linear way. For copy purposes, you can print a 
formula in a linear way with lprint: 
> lprint(%); 
p*(2*a-b)A5/(c+7) 
Maple does not interpret ax as the product of a and x, but as a two-Ietter name ax. 
Each multiplicatian is ta be entered with an asterisk. 
In printing output, multiplications are represented by spaces. However, this meth-
od of notation is not accepted as input. 
It is tempting to make mistakes such as the following: 
> a(b+c); 
a(b + c) 
At first glance, it may not be obvious that the result is not the product of a and b+c. 
Actually, Maple supposes that a is a procedure (maybe a function) that is applied 
E. Kamerich, A Guide to Maple
© Springer Science+Business Media New York 1999

20 
2. Numbers and algebraic operators 
to the surn of b and c. If you are using Maple in a windowing version, you can 
see that a is printed upright, while the other characters are slanted, indicating that 
Maple supposes that a is a function or procedure acting on b + c. 
At first sight, the following result rnight look strange: 
> solve( x-3 = 7(p+q) , X ); 
10 
Maple has interpreted 7 (p+q) as application of the constant function 7 to the pa-
rarneter p+q, with the obvious result 7. This interpretation would have corne out 
by Maple's screen output, ifthe equation had been entered before applying sol ve: 
> x-3 = 7(p+q); solve( % , x ); 
x-3=7 
10 
Any user can rnake rnistakes in typing forrnulas. Advice: 
Before applying a procedure to a formula 
that has to be typed in, 
it is better to enter this formula first, 
check the result printed by Maple, 
and then, if this is correct, apply the procedure. 
In rnathernatics, the dot can be used in denoting rnultiplication, but not so in Maple: 
it is used in floating-point nurnbers and for gluing strings together, i.e., concatena-
tion: 
> toget.her; 
together 
2.2 Parentheses and precedence rules 
Maple respects the standard precedence rules of arithrnetic operations. Please 
check if the following two results are what you expect. 
> 100 - b + 2*3~2; 
118-b 
This is interpreted as 
(100 - b) + (2 * (32)) 

2.2 Parentheses and precedence rules 
> 1 / p*q / r-l ; 
This is interpreted as 
q --1 
pr 
1 
pq -1 
r 
21 
This last example may be another argument for entering a formula tirst, checking 
the result on the screen, and only then applying a procedure. 
Contrary to some other computer languages, Maple conforms to mathematics in 
the handIing of minus a power. For example 
> -3 ~ 4 ; 
-81 
The layoutofthe input in the lastexample niight be misleading, the spaces suggest-
ing a different interpretation. If you want the fourth power of -3, do not forget to 
use parentheses: 
> (-3) 
~ 4 ; 
81 
Sometimes Maple demands more parentheses: 
>3*1-4; 
Syntax error, '-' unexpected 
Correct input is: 
> 3 * (-4); 
The general rule in Maple: 
-12 
Never enter an arithmetic operator side by side with minus: 
they should be separated by a parenthesis. 
Moreover, due to the nonassociativity of the operator 
A 
, Maple demands paren-
theses in the following nad indicates an error with de cursor at the second A: 
> 2 
~ 3 I~ 2; 
Syntax error, 'A' unexpected 
Correct input is: 

22 
2. Numbers and algebraic operators 
> 2 
~ (3 
~ 2); 
512 
2.3 Rational numbers 
When Maple divides two integers, where the second is not 0, it yields a rational 
number after automatic dividing out the gcd of numerator and denominator. 
> 26 / (-8); 
-13 
4 
Approximation by a floating-point number can be obtained by the command 
evalf, as discussed later in this chapter. 
Be careful when entering decimal fractions. For example, let's calculate 1.45/3. 
> 1.45/3 ; 
.4833333333 
Maple has calculated an approximation, as it interprets the floating-point number 
1.45 as an approximation already. If you want to obtain an exact result for dividing 
the rational number 1.45 by 3, enter 145/100 instead of 1.45. 
> 145/100/3; 
29 
60 
See the section Floating-point numbers, approximations of the present chapter for 
more details. 
An important Maple rule is the autosimplification of rational numbers: the op-
erators +, -, *, /, and 
A between rational numbers are activated immediately, with 
one exception: a power with a noninteger exponent is not simplified. 
2.4 Real constants 
Some special mathematical constants are known to Maple: 
-
7r is to be entered as Pi, but is printed as 7r in windowing versions. 
- Catalan:= E:o (~~:i;2. 
- ,:= the Euler constant:= limn -+oo ((E7=1 t) -ln(n)), printed as ,. 
These names are unassigned, but several procedures can handle them, for example, 

2.5 Complex numbers 
> sin(100000000/3*Pi); 
1 
--V3 
2 
23 
In releases before V.4, there is another constant E, denoting the base of the natural 
logarithm, in mathematics generally denoted as e. 
2.5 Complex numbers 
The complex number i is represented in Maple as 1: 
> r2; 
-1 
In fact 1 is an 'alias' for (-1)' (1/2): 
> (-1)~(1/2); 
1 
The alias construction is discussed in section B.I on page 285. There you will 
also see that you can choose another name for A. 
Here are some calculations with complex numbers. 
> (2 + 3*1)*(1 - 1); 
5+1 
> 1/(3-4*1); 
-81 
In other cases you must ask Maple to perform calculations with the procedure evalc 
("evaluate as a complex number"): 
> (1+I)* (x+I) ; 
(1 + 1) (x + 1) 
> evalc(%); 
x -1 + 1(1 + x) 
The procedure evalc tries to convert a complex number into the form a + bl, 
where a and b are real numbers. Be careful: 

24 
2. Numbers and algebraic operators 
The pracedure evalc assumes 
that all names nat referring ta same abject 
are real variables. 
> evalc( exp(a*I) ); 
cos(a) + 1 sin (a) 
This is a correct splitting into a sum of the real and the imaginary component of 
exp( ai) only if a is real. Maple does not expect the user to substitute, for instance, 
2 * 1 fora. 
Numbers of the type a + bA, where a and b are rational, form a special class 
of numbers in Maple; these are called the rational complex numbers. 
2.6 Radicals 
A radical can be generated as a power. For instance, V'5O + if72 is entered as: 
> 50 
~ (1/4) + 72 
~ (1/6); 
50(1/4) + 72(1/6) 
This can be converted to standard form by the procedure simplify: 
> simplify( % , radical ); 
2(1/4) 25(1/4) + V2 9(1/6) 
If the second argument radical is omitted, the same result is found here; but if 
large expressions are ta be handled, it is more prudent to specify the type of sim-
plification in order to avoid unwanted effects. 
A square root can be denoted with the procedure sqrt, too. This has built-in sim-
plification: 
> sqrt(48/25); 
> sqrt(8-sqrt(15)); 
1 
1 
-V30--V2 
2 
2 
For radicals of complex numbers, evalc can be used in order to get the standard 
form: 

2.7 Manipulating radicals and complex numbers-an example 
25 
> (-I)~(1/4)j 
(_ 1)(1/4) 
> evalc(%)j 
The procedure evalc interprets a power of a complex number za by conceiving z 
as I ziei</> with -7f < <p ::; 7f and caIculating Izia eia</>. In particular, it takes the 
principal branch of x -t x 1/ n : 
> (-625)~(1/4)j evalc(%)j 
( _625)(1/4) 
~ 625(1/4) .../2 + ~ 1625(1/4) .../2 
2 
2 
> simplify(%,radical)j 
5 
5 
-.../2+-1.../2 
2 
2 
Automatic simplitication of the nth root is offered by root[n]( 
): 
> root [4] (-625) j 
5 (_1)(1/4) 
Another interpretation of the nth root is available. In caIculations with real num-
bers you want to tind a negative real number for an odd root of a negative number. 
This can be found by surd, for instance, {/ -125: 
> surd(-125,3)j 
-5 
For complex numbers, surd can be used as well, generally not yielding the prin-
cipal value, but a root with nearest argument to that of the original (useful for de-
viations in numeric caIculations). 
2.7 Manipulating radicals and complex numbers-an example 
As an introduction to manipulating radicals and complex numbers, here is an ex-
ample: 
> evalc(I~ (1/4» 
Now let's try to convert the fourth power of this to standard complex form in order 
to get 1 again. 

26 
2. Numbers and algebraic operators 
> % ~ 4; 
This power is not elaborated automatically, so we must tell Maple to do that: 
> expand( % ); 
The last result contains a product of square roots, where 1 is interpreted as a square 
root by Maple as well. These four roots can be combined into the square root of 
just one expression with the procedure combine: 
> combine(%); 
1 
The procedure combine could have been given an option radical in this case in 
order to re strict its actions. 
2.8 Floating-point numbers, approximations 
As shown previously, there is an essential difference between a decimal fraction 
and a floating-point number: 
> sqrt( 13/10 ) , sqrt( 1.3) ; 
1~ V130, 1.140175425 
In the second expres sion, Maple assumes that the user wants an approximation as 
the result, because it considers 1 . 3 as an approximation. 
In any case where Maple encounters 
a ftoating-point approximation in an expression, 
Maple supposes that the user wants an approximation as the result. 
This should be kept in mind, for instance, when a square root expression is wanted 
and not an approximation: 
> 80~0.5, 80~(1/2); 
8.944271910, v'8O 
The general format for a floating-point number is scientific notation, containing a 
factor IOn: 

2.8 Floating-point numbers, approximations 
27 
> 1.234e+50 , 0.98e-7; 
.12341051 , .9810-7 
The standard procedure available for numerical approximation is evalf (evaluate 
to a floating-point number): 
> eva1f( 1n(2) , 20 ); 
.69314718055994530942 
The second argument specifies the number of digits in the ca1culation. When the 
number of digits is not specified, ca1culations with floating-point numbers are ex-
ecuted with a fixed number of digits; the standard number is 10. This default is set 
by the value of the name Digits. The value can be changed by assigning another 
number to Digi ta, with a maximum as high as 500,000 (student version: 100). 
Maple does not daim that alI digits are correct in numerical computations; in this 
respect it acts like most numeric al packages and calculators. But eventualIy, Maple 
has an advantage: it can execute numerical calculations with very large numbers 
of digits. 
Sometimes, evalf yields a relatively small number that can better be neglected. 
For instance, it is possible that you expect a real value in a calculation, but get a 
small imaginary component when you apply evalf. In such cases you can use 
fnormal 
> convert(tan(l),exp); 
> evalf(%); 
> fnorma1(%) 
1 ( (e(I») 2 - 1 ) 
(e(I»)2 + 1 
1.557407725 + .167857278310-9 1 
1.557407725 
For fast numerical calculations, Maple can use fast floating-point procedures 
(double precision) from the C-library on the system. The procedure for this pur-
pose is evalhf: 
> appr := eva1hf( 1n(2) ); 
appr := .6931471805599453 
Here the number of digits cannot be specified; it is determined by the actual system. 

28 
2. Numbers and algebraic operators 
2.9 Some effects of automatic simplification of floating-point 
numbers 
If Maple switches over to approximation automatically, the number of digits it uses 
in calculations is determined by the value of Digi ts. It does not help if you use 
evalf in such a case: 
> evalf( 80~0.5 ,40 ); 
8.944271910 
It is obvious that this does not work. Evaluation, including automatic simplifica-
tion, is applied on the argument before the procedure comes into action. So, Maple 
has approximated the power before evalf comes into action, and then it is too late 
for evalf to get a result to 40 digits. The remedy would be assigning 40 to Dig-
i ts, before this calculation. 
Using floating-point numbers in calculations can generate unexpected results: 
> evalf( Pi , 30 ); 
3.14159265358979323846264338328 
> evalf( Pi , 50 ); 
3.1415926535897932384626433832795028841971693993751 
> % - %% ; 
o 
Maple yields zero for the difference because the last command has been executed 
as a numerical calculation with 10 digits precision. When we set Digi ts to 50, 
we get what we want: 
> Digits := 50: 
> evalf( Pi , 30 ) - evalf( Pi , 50 ); 
.497115802830600624910-30 
More on this subject can be found in Chapter 9, Numerical calculations with 
Maple. 
www.allitebooks.com

2.10 Calculations with integers 
2.10 Ca1culations with integers 
Maple can use very large integers: 
> 7 
A 1000; 
12532566399657183181075548323827342061649850750809861714\ 
63495007520970596317381164324488390543515207631986159\ 
19551594076685828989467263022761790838270854579830015\ 
11124666120398462435892983257161571801470409630566809\ 
75076132736630232268952505413859271584260886844940824\ 
16768617708189592286936039922311125683719215046689156\ 
73835259013724155451018585596454992757549324739113254\ 
85343784979788060849510858742020118363623157274201095\ 
54782988791530088289711844550500230485638413189947132\ 
14224394733419925930073562249293741945365006149030210\ 
51279203144304016368556775491363374813218113496784270\ 
76091437345045399337348611261168055929355402992823192\ 
49119036002703611228318093587277521451746401317827465\ 
71007363215646068382527396011564146284455436631446960\ 
50650160812621814327062666195172701780200286645023823\ 
083185928061371310300829284071141207731280600001 
29 
There is a limit, but a very generous one. Generally, Maple can manage integer 
numbers of more than half a million digits. If Maple foresees that an object cannot 
be handled, ca1culation is stopped: 
> 7 
A 1000000; 
Error. object too large 
For factorial, the operator ! can be used: 
> 5! ; 
120 
Division of an integer by an integer with the operator /, generally, yields a rational 
number. Integer division with remainder can be executed by iquo and irem: 
> iquo( 705 , 7 ), irem( 705 , 7 ); 
100,5 
Both results can be computed at the same time as follows: 

30 
2. Numbers and algebraic operators 
> iquo( 705 , 7 , 't' ); 
100 
> t; 
5 
The mechanism behind this construction is explained in section 5.4 on page 67. 
For more information on calculations with integers and on using Maple in num-
ber theory, consult on-line help about binomial, ifactor, ifactors, iged, 
igedex, ilem, issqr,nextprime,prevprime, ithprime, eombinat,and 
numtheory. 
2.11 Integers modulo an integer 
Calculations modulo an integer can be carried out with mod. The arithmetic oper-
ators +, -, and * can be used in conjunction with mod an integer, and even division, 
if possible, can be carried out with / . 
> 20*x-5 - 12*x - 2 mod 3; 
2x5 + 1 
> 1/2 mod 9; 
5 
Calculation ofpowers in conjunction with mod can be considerably faster with &A. 
See also the on-line help about Power and Powmod. 
> 7 &- 1000000 mod 3; 
1 
These constructions with mod can be applied in cases with variables as welI, for 
instance on polynomials over Z mod n. For univariate and bivariate polynomials 
over the integers modulo a prime p, modp1 and modp2 are available. In section 
18.20 on page 273, matrices with elements in Z mod n are demonstrated. For more 
information on this subject, consult the on-line help about mod and inert. 
For the Chinese remainder algorithm, the procedure ehrem is available. 

2.12 Algebraic extensions and general rings 
31 
2.12 Algebraic extensions and general rings 
Calculations in Maple using algebraic extensions of the rational field are discussed 
in section 14.10 on page 183 and in Chapter 15, Manipulating algebraic expres-
sions. You can also consult the on-line help about evala. 
For the creation of an abstract group or an abstract operator the procedure def ine 
can be used. Moreover, Maple has special packages for peadic numbers padic, 
Gaussian integers Gausslnt and for Galois fields GF (which can also be created 
in Domains), and the procedure Berlekamp. These subjects are beyond the scope 
of this book. 

chapter 3 
Names and evaluation 1: 
mathematical variables 
Maple uses numbers, mathematical variables, algebraic expressions, mathemati-
cal functions, matrices, and many other types of objects. This chapter discusses 
the mechanisms in Maplefor handling names that refer to these objects. 
The Maple commands in this chapter make up an unbroken Maple session, as it is 
the case with each chapter. 
More about names and evaluation can be found in Chapter 5, Names and evalu-
ation 2: applying procedures, and in Appendix B, Names and evaluation 3: some 
special features. 
3.1 Assigning names to objects and evaluating names to objects 
In Maple, a name can be used without a value, emulating an undetermined math-
ematical variable; for instance, X and a in the following expression: 
> 3*r2 + a; 
Please pay attention to the use of upper-case and lower-case letters: both can be 
used in names, and Maple distinguisbes between them. For instance, Maple per-
ceives x and X as different names. 
Any name in Maple can refer to another Maple object. For instance, 
> a := 1000; 
a:= 1000 
We say: "the number 1000 bas been assigned to the name a." 
From now on, generally, Maple reads 1000 for eacb occurrence of a. We say: "the 
name a refers to the number 1000": 
> a
A 2*t - 2*a - 1; 
1000000 t - 2001 
We say: "Maple bas evaluated a 2t 
-
2 a-L" The term evaluation is given 
several meanings in various computer languages. Strictly speaking, Maple evalua-
tion is finding the values of the variables (by the process of searcbing the memory 
E. Kamerich, A Guide to Maple
© Springer Science+Business Media New York 1999

3.2 Assigning names and expressions to a name 
33 
for references of names), and does not imply any ca1culations. In Maple termi-
nology, a ca1culation is called a simplification. Generally, simplifications must be 
requested by the user, but some basic simplifications are executed automatically, 
such as ca1culating the square of 1000 and the combination of -2000 and -1 in 
the last example. So Maple has calculated the result in that example by 
- evaluating a to 1000 
- autosimplification of the resulting expression 
- sorting subexpressions in the resulting expression according to the internal 
order in the Maple memory. 
Evaluation is always followed by this autosimplification and sorting. Therefore, 
this whole process also is called evaluation usually and so we do in this book. 
3.2 Assigning names and expressions to a name 
Now let's see what happens when we assign the first expression to a name. 
> expr := 3*X~2 + a; 
expr := 3X2 + 1000 
What Maple has done is the following: 
- The right-hand side has been evaluated to 3X2 + 1000. 
- This result has been put on the 'stack' for reference by the ditto (%). 
- The left-hand side, the name expr, is made to refer to this expression. 
This last action is represented by Maple's response. If you had assigned something 
to a previously and would have forgotten about that, you would not have expected 
this result. Therefore, you better check the result. Advice: 
When you enter an assignment, check its effect 
by viewing the result that is printed to the screen. 
The name a has been used in assigning a value to expr. But a has been evaluated 
before the assignment. This makes expr refer to something that has nothing to 
do with a. Therefore, if we now change the value of a, the value of expr is not 
affected. 
> a := 777 ; 
a:= 777 
> expr 
3X2 + 1000 
Now let's assign something to X and then ask for expr. 

34 
3. Names and evaluation 1: mathematical variables 
> X := sqrt(7)-1; 
X:= ../7-1 
> expr; 
After one step of evaluation of the name expr, Maple gat 3 X 2 + 1000, but now 
X refers ta something, sa Maple takes another step in evaluating X. The situation 
is shown in the following diagram: 
expr 
+ 
+ 1000 
You can ask Maple ta evaluate exactly one step ar a number of steps by the proce-
dure eval. 
> eval(expr,l); 
3X2 + 1000 
> eval(expr,2); 
The standard in Maple is foII evaluation, with a few exceptions, discussed in Ap-
pendix B, Names and evaluation 3: some specialjeatures. 
It may be dear that changing the value of X changes the result of evaluating expr. 
> X := 5*Pi; 
X:=511" 
> expr; 
7511"2 + 1000 
It is essential ta consider present references of names involved in assignments, be-
cause the resuIt of evaluating the right-hand side is assigned ta the left-hand side. 
You can test whether you understand this mechanism by predicting the results of 
the following commands, then checking your predictions by entering the lines. 

3.3 Unassigning 
35 
tI := 82 -
1 
> s := 10: 
> t2 := (sA2 - 1); 
t2:= 99 
> tl , t2 
99, 99 
> eval(tl,l) , eval(t2,1); 
82 - 1, 99 
> s:= 100: tl , t2 
9999, 99 
3.3 Unassigning 
A name can be unassigned by the aid of siogle forward quotes. 
>a:='a'; 
a:= a 
As usual in assignments, the right-hand side is evaluated first. Evaluating some-
thing between forward quotes prevents Maple from looking in the memory for ref-
erences of the names between these forward quotes; instead of this, Maple peels 
off that pair of forward quotes. Here the right-hand side evaluates to the name a 
and the assignment determines the name a to once again have no reference. The 
command may suggest that a would refer to itself in a recursive way, but this is 
prevented by Maple. See the section Recursive definitions of names at the end of 
this chapter. 
Often, problems arise when the user forgets about an assignment earlier in the ses-
sion, and thinks that a name is unassigned. 
It is wise to uoassigo aH oames 
as sooo as their values become useless. 
Let's act on this advice and unassign X and expr, previously assigned: 

36 
3. Names and evaluation 1: mathematical variables 
> X:='X' : 
expr:='expr' : 
We could have unassigned these names also with the procedure unassign as fol-
lows: 
> unassign('X, expr'); 
Do not forget the single quotes, otherwise the arguments are evaluated before they 
can be unassigned. 
If you want to unassign ali names used, including ali procedures and tables read 
from the library, you can enter restart. This brings the Maple engine nearly to the 
state of start-up, but does not erase your worksheet. 
3.4 Names and properties 
Maple can give a name or an expression a property with the aid of the procedure 
assume: 
> assume( p < O ); 
> assume( x > 1 ); 
Many procedures can use these assumptions: 
> abs( x*p ); 
Maple informs the user that p and x have properties by printing their names with 
a trailing tilde ( '" ). (In windowing versions you can make other choices.) 
Maple can use this property for calculations, for instance in calculating 
limn-+oo xn and limn-+oo ( ~ ) n. 
> limit( x~n , n=infinity )j 
00 
> limit( (l/x)~n , n=infinity ); 
O 
If we had not made such an assumption about x, Maple would have retumed the 
command uoevaIuated. 
However, not ali procedures take such properties into account. For instance, in the 
following command, solve does not take into account that x has been assumed to 
be greater than 10: 
> solve( x~2=400 , x ); 
20, -20 
The assumptions about x can be omitted in the same way as x can be unassigned. 

3.5 Combinations of characters that can be accepted as names 
37 
> x := 'x'; p := 'p'; 
x :=x 
p:=p 
The assume facility is explained in a more comprehensive way in Appendix A, 
Types, properties, and domains. 
3.5 Combinations of characters that can be accepted as names 
Maple accepts almost any combinations oflower-case letters (a, . .. , z), upper-case 
letters (A, ... , Z), digits, and the underscore character ( _ ) as a name, if the first 
character is not a digit. 
However, the following keywords of the Maple language cannot be used as names 
in a simple, direct way. 
and 
by 
el se 
end 
if 
in 
mod 
not 
or 
proc 
stop 
then 
For example, 
> in :1= 5 ; 
Syntax error, ':=' unexpected 
do 
fi 
intersect 
od 
quit 
to 
done 
for 
local 
option 
read 
union 
elif 
from 
minus 
options 
save 
while 
Moreover, many names used by Maple, for instance names of procedures, are pro-
tected; if you try to assign something to such a name, Maple protests. 
> abs := 3; 
Error, attempting to assign to 'abs' which is protected 
This protection Can be removed by the procedure unprotect. 
In practice, there can be more restrictions in the use of combinations of characters 
as names. For example, 
> 1 := 20; 
Error, Illegal use of an object as a name 
This rather mysterious message of Maple arises from the fact that 1 is an alias of 
sqrt ( -1) , so Maple reads the cornrnand as "sqrt ( -1) : =20 ; " and does not ac-
cept this. More about alias can be found in Appendix B, Names and evaluation 
3: some specialjeatures. 
Moreover, a name used in an option should not be assigned. 

38 
3. Names and evaluation 1: mathematical variables 
Although a name can have the underscore ( _ ) as its tirst character, a not very 
advanced user should not use such a name, because Maple uses this category of 
names for internal purposes. For example, the procedure integrate substitutes 
the name ..x for the integration parameter before it tries to calculate a result. Then, 
if Maple tinds a re suit, this ..x is exchanged back for the original parameter. 
A special cIass of names is formed by the environment variables of Maple, 
containing especiaIly Digi ts, Order, printlevel, mod, Normalizer and 
Testzero. Maple prevents an assignment to one of these if it makes no sense. 
For instance, the number of digits in a floating-point approximation should be a 
natural number, so the following command is rejected: 
> Digits := sqrt(101) ; 
Error, invalid assignment to Digits 
Another special cIass of names is formed by the constants: 
> constants; 
false, "f, 00, true, Catalan, FAIL, 7r 
> Pi := 3.14; 
Error, may not assign to a system constant 
The name Pi does not refer to anything else, though the procedure evalf can tind 
floating-point approximations, but it is not possible to assign a value to this name 
because it is contained in the sequence of constants. 
3.6 Greek letter names 
In windowing versions of Maple, the names of the Greek letters are printed as 
Greek letters. 
> phi, Phi; 
Be careful with the name Pi: it is printed by Maple as 7r, exactly in the same way 
as the name pi is printed. But Maple takes Pi as the mathematical constant 7r, 
while pi is a name like other names and can be used as a variable. 
> sin(pi), sin(Pi); 
sin(7r), O 
57r+77r 
In the last result, both terms contain 7r, but the two are different, so the terms cannot 
be combined into 1211". You can see this by applying Iprint: 
www.allitebooks.com

3.7 Names with an index 
39 
> lprint(%); 
5*Pi+1*pi 
More possible causes for confusion of names can be found in Chapter 6, Creating 
and using mathematical functions in the section Denotation of the functions exp, 
Gamma, and Zeta. 
3.7 Names with an index 
A name with an index can be created with square brackets: 
> A[n]; 
In fact, Maple reads A [n] as an element of a table with the name A; see section 
10.10 on page 135. 
Suppose, for instance, that you want to create a truncated power series with unde-
fined coefficients. You can do that as follows: 
> ser := sum( c[i]*xAi , i=O .. 8 ); 
ser := Co + CI x + C2 X2 + C3 x3 + C4 x4 + C5 x 5 + C6 x6 + C7 x7 + Cs xs 
More on this subject can be found in section B.3 on page 287. 
As an alternative you can use 
> ser := sum( 'C.i'*xAi , i=O .. 8 ); 
ser:= cO + c1x + c2x2 + c3x3 + c4x4 + c5x5 + c6x6 + 
c7x7 + c8xs 
The period between the characters a and i is Maple's concatenation operator: it 
evaluates i at its right side and then glues the result to the symbol a at its left side. 
It works, but the result looks less attractive. Moreover, the forward quotes are 
necessary here, because, generally, the arguments to a procedure are evaluated be-
fore they are handed over to the procedure; see Chapter 6, Creating and using 
mathematical functions. So, if we had not used forward quotes, the concatena-
tion would have been executed before the procedure sum could have substituted 
the successive values for i: 
> misser := sum( c.i*xAi , i=O .. 8 }; 
misser := ci + ci x + ci x 2 + ci x 3 + ci x4 + ci x5 + ci x6 + 
ci x7 + cix8 

40 
3. Names and evaluation 1: mathematical variables 
3.8 Single back quotes 
If you want ta use a name that is not acceptable ta Maple, you can make it accept-
able by enclosing it in back quotes. 
For instance, here are names containing spaces, exclamation, and question marks: 
> 'the largest number!!' := 100000000000000000; 
'the largest number!!' := 100000000000000000 
> 'a still larger number?' := 'the largest number!!'+l; 
'a stiU larger number?' := 100000000000000001 
In this way, a keyword can be used, too. 
> ' qui t' : = O; 
'quit' := O 
Making a sequence of characters acceptable as a name is the only effect of a pair 
of back quotes. For instance, 
> t:=10: 'te; 
10 
The pair of back quotes around t here is superfluous, as the name t is acceptable. 
Sa Maple neglects this pair of back quotes. For the same reason, back quotes can-
not change the behavior of an alias. 
> '1' := 3 ; 
Error, Illegal use of an object as a name 
The rale of a pair of back quotes is ta make the command line interpreter accept a 
combination of characters as a whole symbol, a name that can refer ta other objects. 
A pair of back quotes does not prevent evaluation. 
Be careful not ta enter unpaired back quotes. If you do, you will see strange warn-
ings: 
> cos('new var); 
Warning, incomplete quoted name; use' to end the name 
You might think that entering the second back quote could satisfy Maple's syntax 
checker, but that is not sa: 
> '1; 
Synt~x error, ';' unexpected 
Here Maple expects you ta enter the closing parentheses, sa make the correction 
> '); 

3.10 Recursive definitions of names 
41 
cos('new var'); 
) 
Now Maple is kindly waiting for new input. 
3.9 The concepts of name, symbol, and string in Maple 
In many computer languages, such as Pascal and Basic, a string is constructed by 
enc10sing characters between a pair of single or double quotes. In Maple V re-
lease 5, such a string can be constructed by enc10sing it between a pair of double 
quotes. (In previous releases the double quote is used for the ditto). But a name is 
something quite different: a name can refer to something else and a name can act 
as a variable. A pair of single back quotes urges Maple to accept the sequence of 
characters between them as a name. 
Likewise, enc10sing a name between a pair of single forward quotes may resem-
bIe the idea of creating a string in other computer languages, but again, it is quite 
different: these forward quotes preserve the content from looking up its value, as 
the evaluation peels off only this pair of forward quotes. 
> 'a' + "b" 
+ "'c"'; 
a +' b' +" c" 
Forward quotes do not withhold Maple from elementary ca1culations: 
> '6 + «a~2)~3) + 4'; 
3.10 Recursive definitions of names 
There is one more pitfall in assignment. 
> k := k+3; 
Warning, recursive definition of name 
k:= k + 3 
Maple detects a loop in the reference ofk and wams the user. You can see this loop 
by evaluating k only one step. 
> eval(k ,1) ; 
k+3 
If you don't give the command 

42 
3. Names and evaluation 1: mathematical variables 
> k := 'k'; 
k := k 
but let Maple evaluate k, you get a message 
Error, too many levels of recursion 
or Maple crashes. 
In more complicated cases, Maple may not detect such recursive definitions in time 
to warn the user. 
If Maple issues a message such as the above or if Maple crashes, in most cases 
Maple has tried to evaluate a name that refers to itselfby a more or less complicated 
detour. 

chapter4 
Elementary calculus 
This chapter deals with calculating derivatives. antiderivatives (or primitive func-
tions. indefinite integrals) and definite integrals. as well as calculating sums and 
products. Although Maple is very powerful in calculating antiderivatives. some-
times it can be useful to help it a little bit; this chapter pays attention to several 
ways to do so. demonstrated by simple examples. Moreover, reliability and meth-
ods for checking are discussed. 
Calculus is based on the concept offunctions. It is often more convenient to use 
functions than expressions in calculations. In Chapter 6. Creating and using math-
ematical functions. the use offunctions is discussed. especially in connection with 
calculus. 
Applying series approximations ,for instance for antiderivatives. is shown in Chap-
ter 8. Taylor or Laurent expansion and limits. In that chapter limits are dealt with. 
too. 
4.1 Differentiation 
An expression interpreted as a function in one variable can be differentiated with 
the procedure diff. In order to check the correctness of the command before it is 
evaluated, you can enter it between a pair of forward quotes: 
> 'diff( exp(-a*x~2) , x)'; 
~e(-ax2) 
âx 
The name diff is evaluated in the next step, using the ditto, and so the correspond-
ing procedure becomes active: 
> %; 
The second argument for diff must be a name that does not refer to something 
else. 
Higher order and partial differentiation can be obtained by adding more arguments 
to diff. For instance, ta t3) exp( -ax2 ) can be calculated by 
E. Kamerich, A Guide to Maple
© Springer Science+Business Media New York 1999

44 
4. Elementary calculus 
> diff( exp(-a*x
A 2) , x, a); 
_2xe(-ax2 ) + 2ax3 e(-ax 2 ) 
In the same way ~ 
exp( -ax2 ) can be asked for: 
> diff( exp(-a*x A 2) , x, x, x ); 
12 a2 x e( - a x 2 ) _ 8 a3 x 3 e( - a x 2 ) 
This last command can be abbreviated to diff ( exp (-a*x~2) , x$3 ). The 
operator $ is used for generating a sequence of equal objects, for instance. 
> again $ 7; 
again, again, again, again, again, again, again 
Undefined functions can be used as well: 
> diff( cos(f(x» 
, x ); 
- sin(f(x)) (:x f(X)) 
> diff( f(cos(x» 
, x ); 
- DU) (cos(x)) sin(x) 
In the last result D (f) stands for the derivative function of f. The procedure D is 
discussed in section 6.9 on page 79. 
It is not possible to differentiate with respect to an expression such as u(t): 
> diff( exp(u(t» 
, u(t) ); 
Error, wrong number (or type) of parameters in function diff 
Only a name can be accepted as a variable in respect to which an expression is to 
be differentiated. In a case like this, you can first substitute u for u (t), ask for 
differentiation to u, and then back substitute u(t) for u. 
Differentiation is a straightforward algorithm and does not generate reliability 
problems in principle. 

4.2 The derivative at a point 
4.2 The derivative at a point 
There are two ways to find the derivative at a point. 
A. The obvious way is by evaluating the derivative: 
> exp(-x~2+x); 
> diff(%,x); 
> eval(%,x=l); 
-1 
45 
In releases before V.5 eval cannot be used in this way. In this case, substi-
tution with the procedure subs could do the same job. However, there is a 
subtle difference between evaluation at a point and substitution. This can be 
illustrated in the following example: 
> diff( cos(f(x» 
• x ); 
- sin(f(x)) (:x f(X)) 
> subs( x=O , % ); 
- sin(f(O)) diff(f(O), O) 
This looks weird; evaluating it yields an error: 
> %; 
Error, wrong number (or type) of parameters in function diff 
The procedure subs substitutes immediately, but eval knows that x in 
diff (cos (f (x» ,x) must be interpreted as a stiU unknown expression in 
x. As soon as this expression can be calculated, the actual substitution can be 
executed: 
> eval( %% • x=O ); 
- sin(f(O)) 
-
f(x) 
(a )/ 
ax 
{x=o} 
> subs( f=exp , % ); %; 
- sin(l) (aa ex ) / 
x 
{x=o} 
B. The second method uses the procedure D that calculates the derivative of a 
function. For the example at the start of this section, where the derivative of 
the function x H exp( -x2 + x) at x = 1 is calculated, we can use also: 

46 
4. Elementary calculus 
> D( x->exp(-x~2+x) )(a)j 
(-2a+ 1)e(-a2+a) 
The procedure D is discussed in section 6.9 on page 79. 
4.3 Some more tools in differential calculus 
For differentiation of implicitly defined functions you can use the procedure 
implici tdiff, which must be read from the library with readlib (implici t-
diff) before it can be used. In releases before Release 4, you can use series ap-
proximations of solutions of equations; see section 16.9 on page 227. 
There are procedures available for finding extrema: extrema, minimize, and 
maximize. These are not always reliable. 
For calculations in differential geometry, Maple offers a package ditTorms; this 
can handle differential forms with wedge products, exterior derivatives, etc. 
4.4 Antiderivatives 
You can ask for the antiderivative (or primitive, indefinite integral) of an expres-
sion, e.g., 
J 
X2 
dx 
x3 +x2 + x + 1 
with the procedure integrate, which can be abbreviated to int: 
> x~2/(x~3+x~2+x+l)j 
x3 + x2 + x + 1 
> integrate( Y. , x ) 
1 
1 
1 
2 ln(x + 1) + 4: ln(x2 + 1) - 2 arctan(x) 
> int( %% , x )j 
1 
1 
1 
2 ln(x + 1) + 4: ln(x2 + 1) - 2 arctan(x) 
The second argument to int should be a name not referring to something else. 
The second argument cannot be something like x ( t). This is analogous to the 
procedure diff; see section 4.1 on page 43. 
If you want to see an antiderivative as a function and want to apply this function, 
use eval or useintat: 

4.5 Special elements appearing in the results of the procedure int 
47 
> int (f (x) ,x) ; 
1 
f(x) dx 
> eval(%,x=a); 
(1 f(X)dX)I{x=a} 
Of course, this expression is not defined mathematically, only differences are de-
fined in the case in which fis continuous; see section 11.6 on page 143. Essentially 
the same result can be found in one step by the use of the procedure intat, but more 
elegantly and more accessible for manipulation (see the on-line help for intat and 
PDEtools [dchange]). 
4.5 Special elements appearing in the results of the procedure int 
Maple has been equipped with a comprehensive set of mathematical functions, 
several of which are defined as an antiderivative. These can be used for expressing 
other antiderivatives. For instance, 
> 'int(sqrt(1-k~2*sin(x)~2),x)'; 
> %; 
1 
sqrt(l - k2 sin(x)2) dx 
VCOS(X)2 EllipticE(sin(x), csgn(k) k) 
cos(x) 
The re suit contains a standard eIIiptic integral. The on-line help can tell you that 
EllipticE(z,k) is defined as i
z vl- k2 t 2 
-==:-dt 
o 
Jf=t2 
The integration methods used by Maple in the previous cases are more or less the 
same as the usual methods applied in calculations done by hand. When Maple can-
not find results with these, it launches the attack with a laborious but very powerful 
set of Risch algorithms. In order to see what methods are attempted, enter 
> infolevel[int] := 1; 
infolevelint := 1 
This infolevel can be set to 2, 3, 4, or 5 for more details. 
Here is an example of a calculation based on a Risch algorithm with a rather cryptic 
result, which will be explained in the following. 

48 
4. Elementary calculus 
> 'int(1/(x~6+x~3+1),x)'; 
int/indefl: 
first- stage indefinite integrat ion 
int/ratpoly: 
rational function integrat ion 
int/rischnorm: 
enter Risch-Norman integrator 
int/rischnorm: 
exit Risch-Norman integrator 
int/risch: 
enter Risch integrat ion 
int/risch: 
exit Risch integrat ion 
f 
1 
d 
x6 + x3 + 1 X 
> % 
L _R ln(x - 729_R4 ) 
-R=%I 
Before analyzing this result, we reset the infolevel to prevent such additional 
inforrnation: 
> infolevel[int] := O; 
infolevelint := O 
The last result of the procedure int may look mysterious; it should be read as fol-
lows. The expres sion 
RootOf(19683 -26 + 243 _Z3 + 1) 
is the set of alI six complex roots of the equation in _Z: 
19683_Z6 + 243_Z3 + 1 = O 
If these are denoted as ZI ... Z6, then the antiderivative expression found by Maple 
can be written as 
6 L Zi ln(x - 729zi ) 
i=1 
The appearance of this RootOfis caused by the action of sol ve within this Risch 
algorithm. These RootOf expressions are explained in Chapter 14, Polynomial 
equations andJactoring polynomials. 
Maple can make the result more concrete with the aid of allvalues. This procedure 
replaces a RootOf expres sion with alI the roots of the argument of that RootOf. 
In the folIowing, you can see how that can be done. Don't bother to understand the 
details before you have read Chapter 10, Manipulating several objects at once. 
In the following we substitute the list of these roots for the RootOf expression (the 
second subexpression of the second subexpression of resul t), at the same time 
we convert the sum into a sequence and replace the internal name -It with j. 
www.allitebooks.com

4.5 Special elements appearing in the results of the procedure int 
> subs(%l = [allvalues(%l)] , sum=seq, _R=j, result ); 
~ %2(1/3) In (x __ 1_ %2(4/3)) 
18 
144' 
( - 3~ %2(1/3) + 3~ I v'a %2(1/3) ) 
In (x - 729 (_~ %2(1/3) + ~ I v'a %2(1/3)) 4) 
36 
36 
' 
(-~ %2(1/3) _ ~ I v'a %2(1/3)) 
36 
36 
In (x - 729 (_ ~ %2(1/3) _ ~ I v'a %2(1/3)) 4) 
36 
36 
' 
~ %1 (1/3) In (x __ 1_ %1 (4/3)) 
18 
144' 
( - ~ %1 (1/3) - ~ I v'a %1 (1/3)) 
36 
36 
In(x-729 (_~%1(1/3) _ ~Iv'a%1(1/3))4) 
36 
36 
' 
( - 3~ %1(1/3) + 316 I v'a %1 (1/3)) 
In (x - 729 ( - 316 %1 (1/3) + 316 I v'a %1 (1/3)) 4) 
%1 := -36 - 121 v'a 
%2 := -36 + 12 I v'a 
49 
The result is an expression that would evaluate to a sequence of expressions, ob-
tained by substituting six complex numbers for j in j In(x - 729j4). This expres-
sion can be simplified with the tools of Chapter 15, Manipulating algebraic ex-
pressions, but we will not do so. 
Now we can compute the result as the sum of these six expressions. 
> sum(%[i] , i=1. .nops([%]»: 
(Printing the result is suppressed by using the semicolon.) 

50 
4. Elementary calculus 
4.6 Definite integrals 
A definite integral can be requested as in the following example: 
> int( x
A 3 • x = a .. b); 
! b4 _! a4 
4 
4 
Here a.. b is the Maple denotation of the range from a to b. 
> 'int( x
A (-2) • x=-1 .. 1)'; 
> %; 
1
1 
1 
2 dx 
-1 x 
00 
> 'int( exp(-x) • x=O .. infinity)'; 
100 e(-X) dx 
> %; 
1 
4.7 Helping Maple to find a definite integral by restricting 
the domain of a parameter 
In the following example, Maple gets stuck in an undefined limit: 
> 'int( exp(-a
A 2*x) • x=O .. infinity)'; 
1
00 e(-a2 x) dx 
> %; 
Definite integration: Can't determine if the integral is convergent. 
Need to know the sign of --> a-2 
Will now try indefinite integration and then take limits. 
e(-a2 x)_1 
lim ---~--
x-+oo 
a2 
This is because Maple knows nothing about a and only supposes it to be a complex 
number. In a future release Maple may ask questions to the user in such a case, 
sometimes under the control of an option ask, but now we can take the initiative 
and tell that a
A 2 represents a positive number. We can say so with assume. See 
section 3.4 on page 36 or section A.4 on page 278. 

Helping Maple to find an antiderivative 
> assume(a~2, positive)j 
> int( exp(-a~2*x) , x=O .. infinitY)j 
1 
a",,2 
51 
The tilde character ( "" ) that follows the name a in the result means that a has 
properties, in this case, that a is assumed to be positive. 
4.8 Helping Maple to find an antiderivative by conversion 
to RootOf 
In many cases, Maple prefers RootOf expressions above the corresponding radi-
cal expressions. See section 14.4 on page 175. For instance, 
> integrand:=sqrt(x~6+x~3+1)/x~4,xj 
sqrt(x6 + x3 + 1) 
x4 
> int(%,x) j 
_! V x6 + x3 + 1 + f ! 
2 x3 + 1 
dx 
3 
x3 
2 x V x6 + x3 + 1 
This does not yield a desired result. Conversion to RootOf helps Maple out of 
distress: 
> convert( % , RootOf )j 
1 RootOfCZ2 - x6 - x3 - 1) 
-i 
x 3 
+ 
f i 
2x3 + 1 
d 
2" x RootOfCZ2 - x6 - x3 _ 1) x 
The expression RootOf (_Z2 - x6 - x3 - 1) symbolizes a root of the equation in 
_Z: _Z2 - x6 - x3 - 1 = 0, in fact ±vx6 + x3 + 1. 
After the conversion no evaluation is performed, so we have to ask for evaluation 
by entering the converted form: 
> % j 
_! %1 + ! ln(- -2 + 3x3 + 8x9 + 8%lx6 -ln4%lx3 + 2 %1) 
3 x 3 
6 
x3 
%1 := RootOf{_Z2 - x6 - x3 - 1) 
The RootOfs in this result can be translated into radicals by 
> convert( % , radical )j 
_! %1 +! ln(- -2+3X3 +8X9 +8%IX6 -1n4%lx3 +2%1) 
3 x3 
6 
x3 

52 
4. Elementary calculus 
%1 := ";x6 + x3 + 1 
This result should be checked, especially here after the two conversions. That can 
be done in the standard way with diff and normal: 
> normal(diff(%,x)-integrand); 
O 
4.9 Helping Maple to tind an antiderivative by substitution 
Sometimes a mathematician can see pattems not recognized by Maple. This can 
be used to help Maple. For instance: 
> integrand := 1/(x~(1/2) + x~(1/3»; 
. 
d 
1 
mtegran := VX + x{1/3) 
> int(integrand,x); 
-3 X{1/3) - 2 In (x{1/3) - 1) + In (X(2/3) + x{1/3) + 1) -
In(x -
1) + 2VX - 2arctanh(vx) + 6x{1/6) + 
2 ln( X(1/6) - 1) -ln( X{1/3) + X(1/6) + 1)-2 In( X(1/6) + 1)+ 
In (X(1/3) -
X{1/6) + 1) 
The result is not very attractive; if you try numerical evaluation you even tind 
imaginary components (-7ri). You can do better by guiding Maple as follows. 
First use the inert version of the integral, which does not try to calculate some-
thing: 
> Int(integrand,x); J 
1 
d 
VX + X(1/3) 
x 
Now change the variable as you would do it by hand. For this purpose, use 
PDEtools[ dchange]. 
(In releases before Release 5, use student [changevar].) 
> PDEtools[dchange]({x=t~6},%); 
J 
6 
t 5 
dt 
# + (t6 )(1/3) 
In order to let Maple calculate this integral, use value: 

4.11 Reliability of the calculation of antiderivatives 
53 
> value(%); 
~ (t6)(1/6) (4 (t6)(1/3) -6 (t6)(1/6) + 12) _61n((t6)(1/6) + 1) 
Supposing that you want x to be positive, substitute fIX for t: 
> subs(t=x A (1/6),%); 
~ X(1/6) (4 x(1/3) - 6 
x(1/6) + 12) - 6 In (x(1/6) + 1) 
> expand(%); 
2 Vx - 3x(1/3) + 6X(1/6) -
6 In( X(1/6) + 1) 
4.10 More tools for integration 
In the package inttrans you can find procedures for calculation of several inte-
gral transfonns: Laplace, Fourier (complex, real), Hilbert, Mellin, andHankel, and 
their inverses. For numerical calculations, FFf is available. 
Generally, integrals over lines, areas, surfaces, etc. must be converted to nonnal 
integrals, possibly using Maple for the manipulations, before Maple's integration 
can be used. The student package contains a procedure Lineint for calculating 
line integrals along parameterized curves in R2 , which must be used in combina-
tion with the procedure val ue. A quite different concept of line integral can be re-
alized with DEtools [line_int], which computes the solution of a total deriva-
tive. 
4.11 Reliability of the calculation of antiderivatives 
In practice, the antiderivatives produced with the procedure int turn out to be cor-
rect, apart from typical cases such as f xndx, where Maple forgets the possibility 
that n might be 1. 
However, there is a subtle question about continuity and constants. The procedure 
int, applied to a continuous function f, defined on an open, connected part U of 
the real or complex numbers, yields an antiderivative function of f that might con-
tain unnecessary singularities: removable singularities, which sometimes can be 
removed by manipulations, and jumps, where the domain of the antiderivative is 
split into connected parts of U and the antiderivative in two adjacent parts can be 
made to join by adding different constant functions in the connected parts of the 
domain. Therefore, evaluating an antiderivative at the boundaries and subtracting 
the results is nof a reliable method for definite integration and a good reason for 
the fact that Maple does not supply an undetermined constant to antiderivatives. 

54 
4. Elementary calculus 
Getting unnecessary discontinuities in antiderivatives is a fundamental problem in 
today's state-of-the-art symbolic computing. 
Although, generally, Maple is reliable in antiderivation, to be absolutely sure you 
can check the results of int by differentiating. Of ten, a check can be performed 
as in the following example, which you might have encountered already in section 
11.9 on page 145: 
> integrand:=1/(x~(1/2) + x~(1/3)); 
. 
d 
1 
mtegran := vx + xe1/3) 
> intresult:=int(%,x); 
intresult := -3x(1/3) - 2 ln( x e1/ 3) - 1) + 
ln( Xe2/ 3) + x(1/3) + 1) -ln(x - 1) + 2 Vx-
2 arctanh(v'x) +6X(1/6) +2 In (X(1/6) -1) -
In (X e1/ 3) + x(1/6) + 1) - 2 In (x(1/6) + 1) + 
ln( x(1/3) - x(1/6) + 1) 
Maple does not see the pattern a mathematician would, but does tind an antideriva-
tive, which can be checked in the usual way: 
> normal(diff(%,x)-integrand); 
O 
This proves that the result of int is a correct antiderivative. However, the result 
has discontinuities, although the integrand is continuous. If you look at the for-
mula, you can see immediately that a discontinuity arises at x = 1. A calculation 
shows that the imaginary component is - 7r for x E< 0,1 > and 7r for x > 1. You 
can easily see the jump in 1 with Maple: 
> assume(x,RealRange(Open(O),Open(l))); 
> evalc(Im(intresult)); 
-7r 
> assume(x,RealRange(Open(1),2)); 
> evalc(Im(intresult)); 
7r 
You can use numerical and graphical tools as well, but these are not reliable when 
you are operating near a branch cut: if you are taking the logarithm of a negative 
number, you ought to tind 7r as the imaginary component. But if a slight numer-

4.12 Definite integrals of discontinuous functions 
55 
ical deviation causes a logarithm to be taken of a number with a small negative 
imaginary component, you get approximatily -7r. 
The discontinuity at 1 ofthe antiderivative can be removed easily; see section 15.8 
on page 201. 
The standard method of testing the correctness of an antiderivative is: 
- differentiate the found antiderivative 
- subtract this from the original expression and 
- apply normal to this difference and check if this is O. 
Eventually, some extra manipulation may be necessary. See Chapter 15, Manipu-
lating algebraic expressions. 
4.12 Definite integrals of discontinuous functions 
In calculations of definite integrals, Maple looks for the presence of discontinuities 
and asymptotes in the antiderivative and uses the results for the calculation. For 
instance: 
> integrate( 1/x~2 , x=-l .. l )j 
00 
The test of continuity of an antiderivative between the boundaries of a definite in-
tegral can be discarded by adding an option continuous to the procedure int. 
However, if the boundary values of the interval are abstract objects, Maple can-
not test if there are discontinuities between them. In these cases, a result is given 
without any restrictions: 
> integrate( 1/x~2 , x=p .. q )j 
-q+p 
qp 
If this result is evaluated at p=-l and q=l, the result does not equal J~l ~. 
> eval(%,[p=-l,q=l])j 
-2 

56 
4. Elementary calculus 
4.13 Definite integrals and branch cuts of functions 
Here is another rare case, where Maple gets wrong results in calculating a definite 
integral: 
> (-2*sin(x)+I*cos(x»/(2*cos(x)+I*sin(x»; 
-2 sin(x) + 1 cos(x) 
2 cos(x) + 1 sin(x) 
> int( % , x=O .. 2*Pi ); 
o 
This re suIt is not correct. It can be calculated easily by hand, yielding 211'. In fact, it 
is a contour integral for the complex function z f-t ~,yielding 27ri times its residue 
1 in O. (A procedure residue is available.) 
Let's calculate the corresponding antiderivative: 
> int( %% , x ); 
ln(2 cos (x) + 1 sin(x)) 
This antiderivative is correct, which can be checked easily. However, if we ask 
for the integral from O to 211', the antiderivative crosses the branch cut of In at the 
negative part of the real axis, and this causes the wrong result. 
It is not difficult for Maple to approximate this integral by numeric al integration: 
> evalf( Int(%%%,x=O .. 2*Pi) ); 
- .639544833710-13 + 6.2831853071 
> fnormal(%); 
6.283185307 1 
That is a good approximation to 27ri. Using numerical integration, possibly after 
having chosen some values for parameters, is a recommended testing method, al-
though you should be aware of the risks of deviations, for instance with branch 
cuts. 
4.14 Reliability of calculations of definite integrals 
In finding definite integrals, the present release 5 of Maple V seems to be rather re-
liable, apart from rare problems conceming discontinuities and branch cuts, shown 
in the previous two sections. But it may be wise to test results, especially in compli-
cated cases with discontinuities in the integrand or with nonreal ranges. In search 
of a definite integral, Maple generally works as follows: 
- Try to find an antiderivative. 

4.15 Numerical integration 
57 
- Then test this for continuity in the given range. 
- If no discontinuity is found in the given range, try to calculate the definite 
integral by subtracting the right limit of the right boundary from the left limit 
of the left boundary of this antiderivative. In case of discontinuities, try to use 
these by calculating limits. 
In some cases, it can be complicated to test results in an exact way, but of ten it is 
easy to test results in a numeric al way by numeric al integration andJor plotting. 
What can be done to obtain correct results, generally? 
- First have a close look at pattems and properties of expressions in input and 
output that can predict something about the re suIt. 
- Look for discontinuities. 
- Try to check the antiderivative by differentiating and comparing the result 
with the original expression. 
- If possible, test numerically with evalf (lnt ( 
) ), possibly with op-
tions: _CCquad andJor -Dexp. The extra options serve to prevent Maple from 
using symbolic methods near singularities. 
4.15 Numerica! integration 
The following definite integral cannot be calculated exactly. 
> int( exp(x-x~3) , x=O .. l ); 
foI e(x-x 3 ) dx 
A numerical approximation can be found by applying evalf to this result, with the 
number of digits as the second argument. 
> evalf (% , 30 ); 
1.29264345165894609581636207792 
In the following case, Maple could yield an exact result for JOI vx3 - xdx, ex-
pressed in a lengthy and complicated expression containing Legendre functions. 
This could then be approximated with evalf. There is a faster and simpler way 
to achieve an approximation: 

58 
4. Elementary calculus 
> lnt( sqrt(x-x~3) , x = O .. 1 ); 
(Ol 
10 Ix - x 3 dx 
The procedure Int is the inert version of int: it does not execute any calculations, 
but if we ask for an approximation with evalf, numerical integration methods are 
used: 
> evalf( % , 20 ); 
.47925609389423688298 
In cases where the boundaries are definite real numbers and the integrand does not 
contain undetermined variables, you can ask Maple to calculate a numerical ap-
proximation 10 an integral, using lnt and evalf as in the previous example. If the 
boundary numbers are complex, you must choose an integration path and convert 
the integral to an integral over a part of the real numbers, possibly using substitu-
tion. See section 11.9 on page 145. 
In numerical integration, Maple tries to find a result where ali digits apart from the 
last one are signijicant. It is possible to choose between several numerical integra-
tion techniques by adding an option _CCquad, _Dexp or _NCrule. Specific infor-
mation on these options can be obtained with the on-line help for int ,numeric. 
You can speed up numeric integration by using optimize. See section 9.2 on page 
119. 
If Maple detects a discontinuity in between the boundaries of the integration, nu-
merical integration generates an error: (in evalf/int) unable to handle 
singulari ty. 
There is no direct facility to generate a table or interpol ating function for a numer-
ical approximation to an antiderivative on an interval. In order to obtain a graph 
of an antiderivative function, you can think of integration as solving a differential 
equation and use graphical facilities for this field. See section 17.5 on page 238. 
4.16 Numerical approximations to multiple integrals 
Here is an example of a double integral. Maple does not find a closed form but an 
intermediate result: 
> 'int( int(exp(t~3),t=0 .. x) , x=O .. l )'; 
1
1 1" e(t3) dtdx 
> %; 

4.16 Numerical approximations to multiple integrals 
59 
The procedure evalf can handle a multiple integral; however, be careful, do DOt 
apply evalf as follows: 
> evalf( int( int(exp(t~3),t=O .. x) , x=O .. l ) ); 
-.2803536934 - .4855868411 1 
Obviously the result is not correct: the imaginary component makes no sense. In 
fact, the previous result of the symbolic calculation of the double integral is incor-
rect. By applying evalf on int (înt (. .. )) we have caused Maple tirst to eval-
uate this by symbolical calculations and using that incorrect result. So it is wise to 
avoid such a calculation by the aid of the inert version of the integral: 
> Int( Int(exp(t~3),t=0 .. x) , x=O .. l ); 
11 1" e(t3) dtdx 
> evalf(%); 
.5607073869 
Such calculations are rather time-consuming. Taking a series development of the 
inner integral (to sufticient high order) and integrating this from O to 1 is much 
more efticient. See Chapter 8, Taylor or Laurent expansion and limits. Already for 
the present, rather undemanding case, the method below is about 20 times faster. 
> series( exp(t~3) , t=O , 30 ); 
1 + t3 + !t6 + !t9 + 2-t12 + _1_t15 + _1_t18 + _1_t21 + 
2 
6 
24 
120 
720 
5040 
1 
24 
1 
27 
30 
40320t + 362880t + O(t ) 
> convert( % , polynom ); 
1 
1 
1 
1 
1 
1 
l+t3+- t6 +_ t9+_ t 12+_ t15+_ t18 + __ t21 + 
2 
6 
24 
120 
720 
5040 
1 
24 
1 
27 
40320 t + 362880 t 
> int( int( % , t=O .. x ) , x=O .. l ); 
4387950745386281 
7825740931008000 
> evalf( % ); 
.5607073866 
From a rough estimate of the error with the Taylor remainder theorem, this result 
should be accurate to at least three digits. According to this method of estimating 

60 
4. Elementary calculus 
the error, a 10-digit accurate result would require series expansion to order 60. This 
last task can be executed by Maple in no time, but a little experimenting with the 
order shows that order 30 is sufficient for lO-digit accuracy in this case. 
4.17 Definite and indefinite sums and products 
The procedure sum is the discrete variant of int: 
> 'sume 3~(-k) , k=1 .. 10 )'; %; 
> 'sume 3~(-k) , k=l .. N 
3 
2 
10 L 3(-k) 
k=l 
29524 
59049 
)'; %; 
N L 3(- k) 
k=l 
(~rN+1) + ~ 
> 'sume 3~(-k) , k )'; %; L 3(- k) 
k 
-~ (~r 
In the first and second example, the range is indicated with •• (two dots). 
In the last case, we see the discrete sister of the antiderivative; discrete differenti-
ation yields the original expression: 
> eval(%,k=k+l) - % ; 
~ (~) (k+1) + ~ (~) k 
> expand( % ); 
Summing to infinity: 
> 'sume 3~(-k) , k=O .. infinity )'; %; 
00 L 3(- k) 
k=O 
3 
2 

4.17 Definite and indefinite sums and products 
61 
Keep in mind that the arguments of sum are evaluated before the procedure comes 
into action. So the "walking parameter" should not refer to something else: 
> n := 1000; 
n:= 1000 
> sume 2~n, n=1 .. 10 ); 
Error, summation variable previously assigned 
second argument evaluates to 
1000 = 1 .. 10 
You can use forward quotes to prevent early evaluation of the arguments in such 
cases: 
> sume 
'2~n' , 'n'=1..10 ); 
2046 
Sums of less than 1,000 terms are calculated simply by calculating each term and 
adding them, but if there are more terms, Maple tries to find a closed form. 
> sum(1/k,k=1 .. 1000); 
w(1001) + 'Y 
w(x) is defined as d~ ln(r(x)) and'Y is the Euler constant. 
This rule depends on the release, but it cannot be changed by the user unless 
the procedure sum is changed (". .. elif dab < 1000 then ... "). However, 
there is a trick; for instance, 
> sum(cos(x),x=0 .. 7); 
1 + cos(1) + cos(2) + cos(3) + cos(4) + cos(5) + cos(6) + cos(7) 
You can urge Maple to search for a formula by presenting the right boundary of 
the index as an indefinite, and then you can evaluate at N = 7: 
> sume cos(x) , x = O .. N ); 
_! cos(N + 1) _ ! sin(1) sin(N + 1) + ! 
2 
2 
cos(1) - 1 
2 
> eval( % , N=7 ); 
_! cos(8) _ ! sin(1) sin(8) + ! 
2 
2 cos(1) - 1 
2 
The section 4.5 on page 47 shows a construction that yields sums over the set of 
roots of a polynomial, using the RootOf denotation. The sum of the elements of 
a set or list (see section 10.8 on page 133) can be found as follows: 

62 
4. Elementary calculus 
> a_list := [ 2 , 3 , 5 ]; 
alist := [2, 3, 5] 
10 
An inert version of sum is available: Sum. This does no calculations, but can be 
handled with manipulation procedures. It can be activated with value. 
> Sum( x A 2 , x=l .. N ); 
x=l 
> value( % ); 
1 
3 
1 
2 
1 
1 
"3 (N + 1) - 2 (N + 1) + ti N + ti 
In connection to summation, Maple offers the Z-transform with ztrans; sev-
eraI other tools can be found in the package sumtools. Moreover, you can use 
PDEtools [dchange] in the same way as in applying the substitution rule for in-
tegrals. (In releases before Release 5, use student [changevar].) 
Calculation of products is analogous to calculation of sums; use the procedure 
product: 
> product( xAk , k=1 .. 100 ); 
X 5050 
4.18 Other tools and pedagogical facilities 
Many more Maple tools are available for calculus. If you are looking for something 
special, don't forget to look into the share library; see section 5.6 on page 69. 
Mathematical education can profit considerabIy from using MapIe. For teaching 
calculus, a special package, student, is available. Here is an exampIe: integra-
tion by parts. Maple can correctly compute the following antiderivative without 
the manual use of this technique. In fact, we must keep Maple from calculating an 
antiderivative by using the inert form of int: Int. 
> Int( x*cos(x) , x ); J 
x cos(x) dx 

4.18 Other tools and pedagogical facilities 
63 
> student [intparts]( % , x ); 
x sin(x) - ! sin(x) dx 
The application of the procedure value makes Maple calculate the integral by con-
verting the inert Int into the active int. 
> value( % ); 
x sin(x) + cos(x) 
It is advisable not to use the computer early. First, a student should become famil-
iar with the concepts involved, and execute sufficiently calculations for a specific 
type of mathematical action by hand and mind, possibly only with the most ba-
sic methods, until she/he really understands what is happening and the goal of it. 
Then, she/he can learn to execute the same calculations with one or more Maple 
commands and learn to read the output generated by Maple. If a student has not 
done so, he/she might use the facilities by trial and error, not knowing what to do. 
In subsequently solving problems where this action is one of the steps, the student 
can concentrate on choosing which step to take, not being distracted from this task 
by the burden of the detailed calculation within each step. In this way, using Maple 
can enhance abstraction processes in leaming and heuristics in problem solving. 

chapter 5 
Names and evaluation 2: 
applying procedures 
This chapter explains the use of Maple procedures, arguments and output. Ways 
ofusing Maple's library ofprocedures are also explained. This chapter is a sequel 
to Chapter 3, Names and evaluation 1: mathematical variables. 
5.1 Evaluation of names in arguments of procedures 
The following rule is very important for using Maple: 
The arguments given to a procedure are evaluated 
before the procedure comes into action, 
excepting a few special procedures. 
The exceptional procedures can be found at the end of section B.6 on page 289. 
For example: 
> x := 484~(1/2); 
x:= v'484 
> simplify( x ); 
22 
After the second command, tirst x is evaluated, yielding v' 484. This is given to the 
procedure simplify, which yields 22 as the result. This action does not change 
the value of x: 
> x ; 
Obviously, there is no possibility for a procedure such as simplify to change 
the reference of its argument, as the evaluation of it takes place before simplify 
comes into action. 
Here is an example where problems arise because arguments are evaluated tirst: 
> diff( sin(x) , x ); 
E. Kamerich, A Guide to Maple
© Springer Science+Business Media New York 1999

5.2 Options of procedures 
65 
Error, wrong number (or type) of parameters in function diff 
The last command seems to ask Maple to differentiate sin(x) with respect to x, 
but x has been assigned the value v'484. Before diff carne into action, Maple 
evaluated x to vi 484. Therefore, we asked Maple to differentiate sin( v' 484) with 
respect to vi 484 and Maple cannot make sense of this strange command. In order 
to tind out what is happening in such a case, evaluate the arguments: 
> sin(x),xj 
sin ( v'484) , v'484 
General advice: 
If a procedure is behaving in an odd manner, 
first test the values of the names contained in its arguments. 
These troubles would have been prevented if we had unassigned the name x im-
mediately, when its value became obsolete. 
> x := 'x' j 
x :=x 
But people of ten forget to unassign names. 
5.2 Options of procedures 
For each procedure there is a minimum number of arguments, but many proce-
dures can use more arguments. Some of these arguments can be options, deciding 
which type of action is asked for. For instance, the procedure fsol ve tries to tind 
numeric al solutions to an equation or set of equations: 
> fsolve(sin(x)=1/3,x)j 
.3398369095 
Generally, f sol ve tries to tind real solutions and is content with just one solution; 
see section 16.700 page 225. 
> fsolve(sin(x)=2,x)j 
fsolve(sin(x) = 2,x) 
There are no real solutions here, but you can ask for a complex solution by adding 
the option complex: 

66 
5. Names and evaluation 2: applying procedures 
> fsolve(sin(x)=2,x,complex)j 
1.570796327 - 1.3169578971 
When a procedure fails to do what you want, always read the on-line help for this 
procedure. In many cases, adding or changing an option can help. 
5.3 Output and results of procedures 
Generally, execution of a procedure yields a Maple object as a result. There are 
three cases where no result is generated: 
a. If the execution generates an error, the error message is printed to the screen 
and no result is produced. 
b. A few procedures never yield a result. 
For instance, the procedures print and Iprint print their arguments to the 
screen without pushing a result onto the ditto stack: 
> ( 
(5*8*x~2-1) / 
x~3 )j 
40x2 - 1 
x3 
> lprint(expand(%~2»; 
1600/x
A 2-80/x
A 4+1/x
A 6 
> % j 
Because lprint yields no result, it cannot leave a result on the stack of pre-
vious results, so the last ditto yields 40 ~~ -1 as the last result. 
c. Some procedures occasionally yield no result, for instance, sol ve in the case 
where no solution for the equation is found. 
The result of a procedure can be used as input for another procedure by nesting 
them: 
> solve( diff(x~3-x,x) , x )j 
1 
1 
-V3 --V3 
3 
' 
3 
The procedure diff has calculated an expression, and this result has been used 
by sol ve. The result of sol ve has been pushed onto the stack for quoting by the 
ditto (%). 
However, you are well advised to avoid nesting; better look at the result of each 
step and each time use the ditto for reference to the previous result. It is easy, and 
by tracking results often you can prevent mistakes and unwanted results. 

5.5 Narnes referring to procedures 
67 
5.4 Assigning side results to arguments of procedures 
In section 2.10 on page 29, the procedure iquo was introduced with a special 
construction: 
> iquo( 25 , 7 , 't' ); 
3 
> t; 
4 
The integer division of 25 by 7 yields 3 with remainder 4; this remainder is as-
signed to t by iquo. If iquo gets a third argument, Maple tries to assign the re-
mainder of the division to that argument. This is only possible if the argument is 
aname. 
The forward quotes around tin the third argument to iquo make sure that t can-
not be evaluated. Let's see what happens without these forward quotes: 
> iquo(45,13,t); 
Error, wrong number (or type) of parameters in function iquo 
Maple has tried to assign the remainder 6 to the third argument. But the third argu-
ment has been evaluated to 4 before execution of the procedure started, so Maple 
would have to assign 6 to 4 and refuses to do so, reporting that there is something 
wrong with the parameters. 
This premature evaluation of t can be prevented with forward quotes: 
> iquo(45,13,'t'); 
3 
> t; 
6 
Obviously these forward quotes are not necessary if the third argument of iquo 
is an unassigned name, as was the case in the first example of iquo. However, 
in order to avoid problems, it is good practice to use forward quotes for the third 
argument of iquo and generally for arguments of this kind. 
5.5 Names referring to procedures 
Procedures are common objects in Maple. For instance, "normal", "abs", etc. 
are names referring to Maple procedures. Simply typing "abs" does not reveal 
the fact that abs Îs a procedure: 

68 
5. Names and evaluation 2: applying procedures 
> abs; 
abs 
Names of procedures must be dealt with in a special way; they are evaluated only 
on special request: 
> eval(abs) j 
procO opt ion builtin; 64 end 
The result states that the name "abs" is referring to a procedure contained in the 
Maple kernel and supplies the internal number. 
Names of Maple V procedures are protected against assignments from Release 3: 
> abs := sqrt(7) ; 
Error, attempting to assign to 'abs' which is protected 
However, this protection can be made idle by the procedure unprotect: 
> unprotect(abs): 
(In earlier releases this is done by unassigning the name.) Now the name abs can 
take any value: 
> abs: =sqrt (7) j 
abs:= V7 
The name "abs" refers to V7 and the procedure abs has been lost, although only 
for the current Maple session. 
5.6 The Maple library of procedures 
The Maple system contains an enormous number of procedures available for the 
user. In Maple V release 5 more than 600 procedures can be used directIy as we 
have done up to now. A list of these procedures is shown by the command ?in-
dex, function. Only a few of these (the "interior" procedures) are present in the 
computer's working memory at start-up. Most other procedures are automatically 
read from file into the memory when invoked the first time. Some other procedures 
must be loaded explicitly by the user before they can be used with the aid of the 
procedure readIib. For instance, the procedure psqrt can be used for finding the 
square root of a polynomial, if it exists: 
> expand( (3*x-3*y-4 - 2*x*y-6 + 12*x-5*y-2)-2 ); 
-39 x 6 y8 _ 12 x 4 ylO + 72 x 8 y6 + 4 x 2 y12 + 144 x lO y4 
> psqrt( % )j 
psqrt (-39 x 6 y8 _ 12 x 4 ylO + 72 x 8 y6 + 4 x 2 y12 + 144 x lO y4) 

5.6 The Maple library of procedures 
69 
The procedure has done nothing because it is not known to the present Maple ses-
sion and is not loaded automatically. We have to read it from the library: 
> readlib(psqrt); 
proc(p) ... end 
From now on, the procedure psqrt can be used: 
> psqrt(IIIIII); 
For each procedure that is not loaded automatically, the on-line help for that pro-
cedure says so. 
Many other procedures are contained in packages for special fields. For a list 
of these packages; see index, packages. For instance, there is a package or-
thopoly for orthogonal polynomials. For a list of all the procedures in this pack-
age; see ?orthopoly. One of them is the procedure P, which can calculate Leg-
endre polynomials. You can call it as orthopoly [P]: 
> orthopoly[P] (4,x); 
35 
4 
15 
2 
3 
-x --x +-
8 
4 
8 
However, such an indexed call to a procedure in a package can only be used for 
some packages. For alt packages it is possible to load a procedure using with: 
> with(orthopoly,P); 
[P] 
From now on, we can call this procedure directly: 
> P(5,X); 
If you want all the procedures of a package to be loaded at once, you can also use 
with: 
> with(orthopoly); 
[G,H,L,P,T,U] 
Now we can use the other procedures from the package as well. 
A package may contain subpackages. This is the case with the stats package for 
statistics. How such a package can be handled is shown in the on-line help for these 
packages. 
Moreover, contributions of Maple users are gathered in the share Iibrary. The 
way this can be used is explained if one types ?share: 
a. enter wi th (share) ; 

70 
5. Names and evaluation 2: applying procedures 
b. search your tool by choosing your subject from '?share ,contents and read-
ing the contents of ?share,<subject>; 
c. pick up the wanted tools according to their description, generally using 
readshare. 
5.7 Asking procedures for additional information with infolevel 
Several procedures print additional information to the screen about their activities 
if the infolevel of this procedure is set higher than O (maximal 5). 
> infolevel[simplify]:=l: 
> exp(sin(a)~2+cos(a)~2); 
> simplify( % ); 
simplify: 
simplify: 
simplify: 
simplify: 
simplify: 
applying 
applying 
applying 
applying 
applying 
e( sin(a)2+cos(a)2) 
trig 
function to expression 
power 
function to expression 
exp 
function to expression 
commonpow 
fUnction to expression 
power function to expression 
e 
If you have already executed the command before raising the corresponding in-
folevel, and then execute the command again, you may not get this additional in-
formation: 
> simplify( %% ); 
e 
'The remedy is applying forget to the procedure. An explanation of this is given 
in Appendix D, Procedures remembering previous resuLts. 
> readlib(forget)(simplify); 
> simplify( %%% ); 
simplify: 
simplify: 
simplify: 
simplify: 
simplify: 
applying 
applying 
applying 
applying 
applying 
trig 
function to expression 
power 
fUnction to expression 
exp 
fUnction to expres sion 
commonpow 
function to expression 
power fUnction to expression 
e 

5.8 Printing standard procedures from Maple's library 
71 
5.8 Printing standard procedures from Maple's library 
If you want to see how a procedure is programmed in the Maple language, you 
must enable printing of these procedures by the command 
> interface(verboseproc=2); 
Now you can enter commands such as print (exp) and you will see how pro-
cedures are programmed. This book does not discuss programming, but a short 
introduction can be found in Appendix E, Control structures. 

chapter 6 
Creating and using mathematical functions 
The first part of this chapter discusses some aspects of the many mathematical 
junctions contained in Maple. 
Anyexpression containing "indeterminate variables" can be seen as ajunction in 
these variables; junction values can be found by substituting values for the vari-
ables. In practice, this can be rather clumsy. It is of ten more efficient to create 
and use your own junctions. In the second part of the present chapter this subject 
is discussed. 
Moreover, calculation of derivative junctions, creating junctions from existing 
junctions, especially by composition, and piecewise-defined junctions are dis-
cussed. 
Creating your ownfunctions is a start in programming. A juli guide to program-
ming is beyond the scope of this book. A basic step in this direction can be found 
in Appendix E, Control structures. 
6.1 Standard mathematical functions 
Maple knows a considerable number of mathematical functions, such as sin, exp, 
abs, GAMMA, Heaviside, etc. Some of the mathematical functions in Maple are 
less common, like those used specifically for expressing antiderivatives. A concise 
survey ofthe functions available at start-up of Maple is accessible with ?inifcns. 
Several Maple packages for special mathematical fields yield additional mathemat-
ical functions, especially orthopoly, which can generate orthogonal polynomi-
als of several types: Chebyshev, Gegenbauer, Hermite, Jacobi, Laguerre, and 
Legendre polynomials. 
These mathematical functions are implemented in Maple as procedures in the same 
way as other procedures such as expand, diff, etc. Applying a mathematical 
function to an argument brings the simplijication rules programmed in this pro-
cedure into action: 
> sin(100/3*Pi); 
1 
--V3 
2 
(Remember that the mathematical constant 7r is to be entered as Pi, not as pi.) 
E. Kamerich, A Guide to Maple
© Springer Science+Business Media New York 1999

6.2 Definitions of inverse functions, branch cuts 
73 
If a function cannot calculate an exact function value for some argument, it retums 
an unevaluated function caII: 
> sin(l); 
sin(l) 
Generally, an approximation can be asked for by evalf: 
> evalf(%,30); 
.841470984807896506652502321630 
If the argument is a ftoating-point number, Maple approximates automatically, with 
accuracy determined by the value ofDigi ts. See section 2.8 on page 26 and sec-
tion 2.9 on page 28. 
> sin( 1. ); 
.8414709848 
Logarithms with a base different from e are available, but these are automatically 
converted into quotients of naturallogarithms: 
> log[a] (b) ; 
ln(b) 
In (a) 
6.2 Definitions of inverse functions, branch cuts 
For most mathematical functions that are defined as inverses of other functions, 
branches must be chosen. For instance, for the square root, being an inverse 
of the square function, v'9 is defined as 3 and not as -3, and Vi is defined as 
1/2v'2 + 1/2v'2i. Likewise, arccos( -1/2) yields ~11", although there are infinite 
many solutions for the equation cos( x) = -
~. 
The function In has been defined on the complex numbers (except for O) as a right 
inverse of exp, where In (exp (r+ I*t/>)) yields r+ I*t/> if -11" < t/> :::; 11". 
In many cases, the choice of branches is less evident than in the previous cases, 
especially if such a function is to be applied to complex numbers. These choices 
are fixed in Maple and cannot be changed without reprogramming the function. 
In order to find the definitions of the inverse trigonometric functions and the in-
verse hyperbolic functions, use convert ( ... ,In): 
> convert( arcsin(x) , In ); 
-Iln(~+Ix) 

74 
6. Creating and using mathematical functions 
6.3 Denotation of the functions exp, Gamma, and Zeta 
The function exp is printed in windowing versions of Maple as follows: 
> exp(x)j 
e'" 
Do not enter this as 
e'" 
In the last case, you see only the undefined variable e to the power x. In releases 
from V.4 you can see a difference in the e characters: the bold e denotes the base 
of the naturallogarithm, while the slanted e is a variable. 
If you like to use e as the base of the naturallogarithm, you can enter: 
> alias(e=exp(l))j 
I, e 
(See section B.1 on page 285.) 
Other possible causes of confusion are the functions GAMMA and Zeta. The name 
ofthe function GAMMA is printed in the same way as the name Gamma in windowing 
versions of Maple, and the name of the function Zeta is printed as a lower-case 
Greek letter: 
> Gamma, GAMMA, zeta, Zetaj 
r, r, (, ( 
> Gamma(5), GAMMA(5), zeta(O), Zeta(O)j 
-1 
r(5), 24, ((O), 2 
The differences can be made visible with Iprint: 
> lprint(%%): 
Gamma 
GAMMA 
zeta 
Zeta 
The name ehi is not interpreted as a Greek letter, as it is the name of the hyperbolic 
cosine integral. 
In text-only versions of Maple (such as for MS-DOS), this confusion does not ex-
ist, because exp (x) is printed as exp (x) , and Greek letters are not printed on the 
screen. 

6.4 Expressions versus functions, creating functions 
75 
6.4 Expressions versus functions, creating functions 
In Maple, functional relations can be described in two ways: 
A. By an expression. For instance, if temperature is descending with time expo-
nentially, this can be embodied in: 
> Texpr := TO * exp(-a*t); 
Texpr:= TOe(-at) 
The temperature at t=5 can be ca1culated by evaluation at a value (or substi-
tution): 
> eval( Texpr , t=5 ); 
TOe(-5a) 
B. By a function. For instance, in the previous example the temperature can be 
described as a function of the time: 
> t -> TO * exp(-a*t); 
t --+ TOe(-at) 
The previous command is entered with an arrow by using a combination of 
the minus and the greater than sign. In this way we obtain a Maple function, 
which we can assign to a name: 
> Tfunc := %: 
Now the temperature at t=5 can be ca1culated by applying the junction: 
> Tfunc(5); 
TOe(-5a) 
It is important that a user should be well aware of the distinction between an ex-
pression and a function. For example, in succession to the previous example, a user 
could try to tind the moment when temperature descends to 100, in the following 
erroneous ways: 
> solve( Tfunc=100 ); 
100 
Here we have not entered the variable with respect to which the equation should be 
solved, so Maple supposes that this variable is Tfunc and easily tinds the solution 
100. If the variable t is given to sol ve, we get no result: 
> solve( Tfunc=100 , t ); 
The last command asks Maple to tind values of t for which the algebraic expres-
sion Tfunc equals 100, and no solutions are found, so no re suIt is printed on the 
screen. A correct command is: 

76 
6. Creating and using mathematicaI functions 
> solve( Tfunc(t)=100 , t); 
In (100 ~) 
a 
(You might have thought that Maple has interpreted the command sol ve 
(Tfunc=100, t) ; as the odd question: "For which values of t does the function 
Tfunc equal the constant function t f-+ IOD?" This is not the case, as Maple does 
not evaluate the name Tfunc.) 
6.5 Creating functions in several arguments 
Functions in more than one argument can be created in the same way as functions 
in one argument. For instance: 
> saddle:= (x,y) -> 5*x~2 -
3*y~2; 
saddle:= x,y -+ 5x2 - 3y2 
> saddle(4,1); 
77 
The parentheses in the definition are essential: if those parentheses had been omit-
ted in the previous example by writing 
x,y -> 5*x~2 -
3*y~2; 
x, y -+ 5 x2 - 3 y2 
Maple would have interpreted this as the sequence of the name x and the function 
y -> 5*x~2 -
3*y~2. 
Functions to vector spaces are discussed in section 18.19 on page 271. 
6.6 A pitfall in creating mathematical functions 
You might think that the following command could create a mathematical function: 
> w(x) := 5*p~x; 
w(x) := 5px 
Maple accepts this command and it seems that it does the job: 
> w(x); 
5p X 
But it does not: 

6.7 Using existing expressions for creating mathematical functions 
77 
> w(3); 
w(3) 
In mathematics, you would say: for each x in R, f (x) := 5px. Of ten, people are 
less precise in formulating, but Maple takes the definition entered above literalIy: 
we have created a function that renders the value 5 pX if its argument is the name 
x, but to alI other arguments it yields an unevaluated function calI. The correct 
function can be created by: 
> f := x -> 5*p~x ; 
or with the aid ofthe procedure unapply, discussed in the next section or with the 
aid of codegen [makeproc] . 
6.7 Using existing expressions for creating mathematical functions 
An important rule for the arrow function construction is: 
In the creation of a function with the arrow, 
the expression to the right of the arrow is not evaluated. 
It is of ten convenient to use an existing expression for the creation of a function. 
Here is such an expression, created by calculating an antiderivative expression (in-
tegral) of an expression: 
> 85:= int( 8in(x)~5 , x ); 
85 := -~ sin(x)4 cos(x) -
1~ sin(x)2 cos(x) - 185 cos(x) 
If we want to find the antiderivative funetion or primitive function from this 
expression, we can do so by using the arrow and typing this expression to the right 
of the arrow, but it can be done in a much easier way with the procedure unapply: 
> prim := unapply( 85 , x ); 
prim ;= x --+ -~ sin(x)4 cos(x) -
1~ sin(x)2 cos(x) - 185 cos(x) 
First, the arguments of unapply are evaluated; then a function is created. Let's 
test this function: 
> prim(Pi/2), prim(O); 
-8 
0, 15 
You might think this function could be defined by: 

78 
6. Creating and using mathematical functions 
> missprim := x -> s5; 
missprim := x -+ s5 
You see the effects of the special evaluation rule for the arrow construction: s5 
is not evaluated, so the parameter x of the function has no relation to the x in the 
expression that s5 refers to: 
> missprim(O); 
-~ sin(x)4 cos(x) -
1~ sin(x)2 cos(x) - 185 cos(x) 
The function missprim yields s5, no matter what arguments are given to it. 
Functions in more than one argument can be created with unapply as well: 
> s := int( sin(x)~n , x ); 
s:= J 
sin(x)n dx 
> prim2 := unapply( s , n , x ); 
prim2 := n, x -+ J 
sin(x)n dx 
> prim2( 5 , t ); 
-~ sin(t)4 cos(t) -
1~ sin(t)2 cos(t) - 185 cos(t) 
A more powerful procedure to create functions is codegen[makeproc] (available 
in release V.S). Let's use it for the same example: 
> prim3 := codegen[makeproc]( s , [n,x] ); 
proc(n,x) int(sin(xfn,x) end 
Observe the square brackets around the parameter, which are necessary here. The 
result looks a little bit different, but essentially it is the same as prim2. However, 
codegen [makeproc] can handle more, for instance, a ca1culation in two or more 
steps. Here is a simple example: 
> twostep:=codegen[makeproc]([pol=x~2-1, exp(pol)], x); 
proc(x) local pol; pol:= x
A 2 - 1; exp(pol) end 
> twostep(a,b); 
The tirst argument is a list of ca1culation steps (brackets necessary). The interme-
diate result is assigned to pol in the tirst step (but using = instead of : =), then pol 
is used in the second step. The variable pol is "local": it is not accessible outside 
the procedure: 

6.9 Derivative functions 
79 
> pol; 
pol 
In section 9.5 on page 123 and section 18.19 on page 271 you can see a more ad-
vanced use of this procedure. 
6.8 Evaluation of names of procedures 
A mathematical function in Maple has the data type procedure. A name referring 
directly to a procedure is not evaluated to that procedure, unless eval acts on that 
name. See section 5.5 on page 67. 
There is a difference between procedures available from the Maple system and pro-
cedures that are defined by the user: these are printed to the screen with alI details: 
> eval(saddle); 
saddle:= x,y -t 5x2 - 3y2 
> print(s5); 
s5 := -~ sin(x)4 cos(x) -
1~ sin(x)2 cos(x) - 185 cos(x) 
Procedures defined in Maple's library are not printed fulIy: 
> eval(sin); 
proc(x :: algebraic) ... end 
This behavior can be changed by the command interface(verboseproc=2). 
See section 5.8 on page 71. 
6.9 Derivative functions 
Maple can calculate derivative functions with the procedure D: 
> DUn); 
> D(cos); 
> D( x -> exp(a*x) ); 
1 
a-t-a 
-sin 
x -t ae(ax) 
Even the derivatives of some exotic functions are available, for instance the deriva-
tive of the Dirac function, defined as the 'function' on the real numbers that yields 

80 
,6. Creating and using mathematical functions 
zero for any input apart from zero, at which point it has a singularity such that 
J~oo Dirac(t)dt = 1. 
> D(Dirac*sin); 
(a -+ Dirac(l, a)) sin + Diraccos 
The derivative of Dirac is known to Maple as a - > Dirac (1, a) . 
The procedure D can also handle a function created by codegen[makeproc] if 
there are no elements in it that are not amenable to differentiation with D. Let's 
differentiate the procedure twostep from the previous section: 
> D(twostep); 
proc(x) local polx,pol; polx .- 2 * x; pol := x
A 2 -
1; polx * exp(pol) end 
> %(a); 
In some cases, where such a procedure contains difficult elements such as sums, it 
needs some polishing by applying codegen[prep2trans] before D can do its job. 
The procedure D can also handle unknown functions: 
> D( fUf2 ); 
D(f1) f2 + fI D(f2) 
An advantage ofusing functions over using expressions is that calculating function 
values by applying functions is more efficient than substituting in expressions. The 
same is true for calculating derivatives at a point by using derivative functions. 
The easiest way of getting the derivative of tan at ax + b is: 
> (D(tan))(a*x+b); 
1 + tan(ax + b)2 
Do not omit the parentheses around D (tan) . 
The alternative with diff is more lengthy: 
> diff( tan(t) , t ); 
1 + tan(t)2 
> eval( % , t=a*x+b ); 
1 + tan(ax + b)2 
Do not confuse diff and D: 

6.10 Derivatives of functions of more than one variable 
81 
o 
In the last case, Maple differentiates an expression, perceiving cos as a variable, 
independent of x. 
In the next example, Maple interprets a and x as mathematical functions: 
> D( a*x~2 ); 
D(a) x2 + 2a D(x) x 
6.10 Derivatives of functions of more than one variable 
The operator D can also be used for functions of more than one variable. In this case 
you must indicate in respect to which variable the function should be differentiated. 
That can be done with indices. For instance, in order to find the derivative in the 
second argument of a function, apply D[2]: 
> g ;= (x,y) -> cos(x*y) + exp(2*y); 
g:= x,y --+ cos(xy) +e(2y) 
> D[2] (g); 
x,y--+ - sin(xy)x+2e(2 y ) 
Now let's differentiate g in respect to the second and then to the first variable: 
> D [1 ,2] (g) ; 
x, y --+ - cos(x y) y x - sin(x y) 
Maple supposes that partial differentiation operators commute. In most practic al 
cases, the encountered functions have alI their partial derivatives (of any order) 
continuous; then this is nothing to worry about. 
> D[3,1,2] (anyfunc); 
D1,2,3 (anyfunc) 

82 
6. Creating and using mathematical functions 
6.11 Conversion between diff and D 
Conversion between D and diff notation is available: 
> diff( u(t)*v(t) , t); 
(:t U(t)) v(t) + u(t) (:t V(t)) 
> convert( % , D ); 
D(u) (t) v(t) + u(t) D(v) (t) 
> convert( % , diff ); 
(! U(t)) v(t) + u(t) (:t V(t)) 
However, D (f) cannot be converted to diff notation in a direct way because the 
differentiation parameter is lacking: 
> convert( D(g) , diff ); 
D(g) 
6.12 Piecewise-defined functions and expressions 
, 
Functions can be defined piecewise as in the following example: 
> f:=x->piecewise(x<O,-x-2, x<1,x-2, x-3); 
f := x -+ piecewise(x < O, _x2 , x < 1, x 2 , x 3 ) 
What this means can be seen better if we apply this function to x: 
> f(x); 
x<O 
x<1 
otherwise 
As you can see, the five arguments are to be read as follows: 
• if x < O then _x2 
• if that is not the case and if x < 1 then x 2 
• otherwise x 3 
This function can be used as any other function: 

6.12 Piecewise-defined functions and expressions 
83 
> f(-3),f(1/2),f(3); 
1 
-9, 4,27 
From release VA many procedures can handle such piecewise-defined functions or 
expressions, for instance: 
> plot( f(x) , x=-2 .. 2 ); 
> salve( f(x)=5*x-2 , x ); 
5 
1 
5 
1 
-- - - v'33 - - - TI 2 
2 
2 
'2 
2 V l/, 
> diff( f(x) , x ); 
{ul;;noo 
3x2 
> int( f(x) , x=-2 .. 2 ); 
17 
12 
x~O 
x<1 
x=1 
1<x 
It is even possible to create other piecewise expressions by transformations such 
as: 
> simplify(%); 
x 2 < O 
x 2 < 1 
otherwise 

84 
6. Creating and using mathematical functions 
{:: 
X 6 
> piecewise(x<O,f(x),x~4); 
x::; -1 
x::; 1 
l<x 
x<o 
x<1 
otherwise 
x<o 
otherwise 
> simplify(%); 
x::;o 
O<x 
This can be converted into a function with unapply: 
> g:=unapply(%,x); 
> g(4); 
256 
x::;O 
O<x 
Because piecewise expressions can be handled so weB, it can be useful to convert 
expressions and functions containing abs, signum, Heaviside, max, min, etc. 
to piecewise-defined functions with convert( ,piecewise): 
> max(x+l,x~2); 
> int(%,x=-2 .. 2); 
[22 max(x + 1, x2 ) dx 
> convert(%%,piecewise); 
> int(%,x=-2 .. 2); 
x<l_l ;g 
-2 
2 ViJ 
x::;!+!v'5 
!+!v'5<x 
16 
5 
-+-V5 
3 
6 

6.13 Creating functions by elementary operations on functions 
85 
6.13 Creating functions by elementary operations on functions 
The composition oftwo functions can be made with the operator @, for instance, 
> quint := x -> x-5; 
quint := x -+ x5 
> (quint Q sin) (x); 
sin(x)5 
> (sin Q quint) (x); 
The brackets are necessary here, otherwise you can get rubbish: 
> quint Q sin(Pi/3); 
qUint@~ v'a 
> (quint Q sin) (Pi/3); 
For repeated compositions, you can use @@. For instance, you can get the func-
tion x f--t quint (quint (quint (x))) as quinUQ3. For example: 
> (quintQQ3) (x); 
Please pay attention to the differences in printing: 
> (sinQQ2) (x); # This is in fact: sin(sin(x)) 
(sin(2l ) (x) 
# This is in fact: sin(x) * sin(x) 
sin(x)2 
(After the sign # you can add comment in Maple.) 
New functions can be created from existing functions with the elementary arith-
metic operators +, -, *, and / , and with the composition operators Q and QQ: 
> f := (2*quint*sin - 3*cosQquint)/exp; 
f := 2 quint sin - 3 cos@quint 
exp 
> f(x); 
2x5 sin(x) - 3 cos(x5 ) 
eX 

86 
6. Creating and using mathematical functions 
In such a function expression, each name is interpreted as a function, if possible. 
For instance: 
> (a*sin + b*cos) (x)j 
a(x) sin (x) + b(x) cos(x) 
> D( a*sin + b*cos )j 
D(a) sin + a cos + D(b) cos - bsin 
If you want O to consider a and b as constants, you can issue: 
> D(a):=O: D(b):=O: 
> D( a*sin + b*cos )j 
a cos - bsin 

chapter 7 
Graphics 
This chapter gives an overview ofthe most useful graphicalfacilities in Maple. Not 
included are specific loolsfor differential equations, vector fields, ele.; these are 
discussed in Chapter 17, Solving differential equations. 
7.1 Graphs of real functions in one real parameter 
As demonstrated in previous chapters, the graph of a function in one parameter can 
be plotted by the procedure plot. For instance, 
sin( 7l'X3 ) 
f: 
xt-+ 
2 
x 
can be plotted on the range - 2 ... 2 by 
> sin(Pi*x~3)/x~2 ; 
> plot( % , x=-2 .. 2 ); 
It is possible to make some changes to this picture in an interactive way. You can 
bring the cursor into the region of the picture with the arrow keys and use the fa-
cilities of the toolbar at the top of the Maple window; or you can c1ick the right 
E. Kamerich, A Guide to Maple
© Springer Science+Business Media New York 1999

88 
7. Graphics 
button of the mouse with the mouse arrow in that region and use the menu. Then 
you can change "Style", "Axes" and "Projection". For instance, to plot only the 
points of the graphic that are calculated by Maple, without connecting them, you 
can choose the option Point in the Style menu. After clicking on the R in the 
toolbar or on Redraw in the menu, you see the following picture, which can also 
be achieved with the command: 
> plot( %% , x=-2 .. 2 , style=POINT ); 
1.8 
1'. 
1.6 
1.4 
1.2 
1-
,. 
0.8 
0.6 
~ 
0.4 
. ~ 
... 
0.2 
-2.. 
-.1 
...{J.2 
; • 
...{J.4 
~ 
-0.6 
.' 
...{J.S 
-; 
.. 1 
-1.2 
-1.4 
':'1.6 
V-1.8 
You are well advised to experiment a little with the choices offered by the menus. 
AII changes made with graphic window menus can be achieved as well by adding 
options to the command, but with options you have many more facilities available, 
for instance scaling=CONSTRAINED, which causes the scalings of the axes to 
be equal. 
In the next section, using such choices for a three-dimensional plot is demon-
strated. In the following sections, effects of several choices and options are shown, 
but not of ali options, for instance, not of options conceming color. Consult the on-
line help with ?plot, options or ?plot3d, options for a particular option. 
7.2 Graphs of real functions in two real parameters 
The graph of a function in two parameters can be plotted by the procedure plot3d. 
For instance, the function 
10 
(x,y) t-+ 
2 
2 
1 cos(x2 + y2) 
x +y + 
can be plotted in the range x from -3 to 3 and y from -3 to 3 by 

7.2 Gmphs of real functions in two real parameters 
> 10/(x~2+y~2+1)*cos(x~2+y~2); 
cos(x2 + y2) 
10--'-------..:... 
x2 + y2 + 1 
> plot3d( % ,x=-3 .. 3,y=-3 .. 3); 
89 
Let's make some choices from the menu options, using the right mouse button or 
the toolbar. 
- Style: Let's change the style to Patch and contour 
- Color: As the pictures in this book are printed in black and white, the choices 
of this menu are not relevant here. Neither can the possibilities of light ing 
be used here; but this option can elucidate color pictures. 
- Axes: We add a box with coordinates by choosing Boxed from this menu. 
- Projection: Let's choose Medium Perspective instead of the default No 
Perspect i ve. 
It is also possible to change the aspect (the direction of viewing the object) by 
pressing the (left) mouse button, keeping it pressed, and mov ing the mouse. In 
the MS-DOS version, use the cursor keys instead. Then you see a box moving, in-
dicating the final direction of viewing. Moreover, the two spherical angles Theta 
and Phi are printed. The default is e = 45 and cp = 45. In the next picture, this 
is changed to e = 8 and cp = 50. 
There is also an extra facility within the menu bar for changing the dimensions of 
the window. 
As soon as a menu choice is made, the picture disappears from the window, leaving 
a box. The picture is redrawn if you click on the R in the toolbar or click on Redraw 
in the menu. 

90 
7. Graphics 
The result of the previous choices can also be created by a plot command with ap-
propriate additional options. 
> plot3d(%%, x=-3 .. 3,y=-3 .. 3,style=PATCHCONTOUR, 
> 
axes=BOXED,projection=O.1,orientation=[8,50]); 
In practice, experimenting with tl{e menus is much easier than using options as 
additional arguments, but there are options that can do things that cannot be re-
alized by the menus, such as changing the number of points to be calculated by 
the option numpoints= ... , or rendering just a part of the picture by the option 
view= 
. It is possible to set certain options as defaults by using the procedures 
plots[setoptions] and plots[setoptions3d]. 
Here is another method of rendering a graph of a function in two parameters: a 
density plot. Let's apply this to the expression of the previous plotting. 
> plots[densityplot]( %%% , x=-3 .. 3 , y=-3 .. 3 , 
> 
numpoints=2500, style=PATCHNOGRID ); 

7.3 Assigning, manipulating, and printing graphical objects 
91 
7.3 Assigning, manipulating, and printing graphical objects 
Graphical procedures such as plot and plot3d yield special Maple objects. Such 
an object can be called by the ditto (%) and it may be assigned to a name. For 
instance: 
> saddle:=plot3d(2*x
A 2-y
A 3,x=-2 .. 2,y=-2 .. 2, 
> 
axes=BOXED, style=HIDDEN): 
There is a special reason why we have used a colon instead of a semicolon in ter-
minating the command: if we had not done so, the plot data structure would have 
been represented instead of the picture, making a lot of uninteresting data scroll 
over the screen. 
If you want to see the picture, you can use print in this case. In some exceptional 
cases, using print yields the internal data structure; in such a case, you can use 
plots[ display] instead. 
> print( saddle )j 
15 
10 
o 
-5 
-2 
-2 
2 
2 
If you are using plotting in loops or procedures, see also section E.5 on page 302. 
It is easy to send a worksheet to a printer or save it as a PostScript file, both with 
the menu option Print in the toolbar menu File, but if you want to print a sep-
arate picture or export it to a file, set Plot Display to Window in the Options 
menu. Now each picture is rendered in a separate worksheet, which can be printed 
or exported to a file with the Print option in the File menu. There are several 
forrnats available such as PostScript, jpeg, etc. Other facilities for this purpose are 
shown in Appendix C, The user interfacefor text-only versions. 
There are several commands for manipulation of graphical objects, for instance 
plottools [rotate] ; let's use this to rotate the saddle over ~1r around the third 
axis: 

92 
7. Graphics 
> plottools[rotate] (saddle,O,O,Pi/2); 
2 
2 
Other commands for manipulation are: 
• plottools[translate] 
• plottools[rotate] 
• plottools[reflect] 
• plottools [homothety] (scaling the axes to the same ratio) 
• plottools[scale] 
• plottools[project] 
• plottools [transform] (very general, applying your own function) 
• plots [display], which can change options and can do a lot more 
• plottools [stellate] (for polygons). 
With some of them (for instance plottools [transform]) it is also possible to 
change the dimension. 
7.4 Vertical asymptotes and discontinuities 
Here is an expression with two zeroes: 
> Y := x~3 -
6*x~2 + 32; 
Y:=x 3 -6x2 +32 
> plot(Y,x=-3 .. 5); 

7.4 Vertical asymptotes and discontinuities 
93 
Let's ask for the graph of l/Y. 
> plot( l/Y , x=-3 .. 5 , -1 .. 1 ); 
0.8 
0.6 
0.4 
0.2 
-1 
2 X 3 
4 
-0.2 
-0.4 
-0.6 
-0.8 
-1 
This last graph is not correct, as can be seen from the previous graph. Maple has 
calculated some points and connected them without looking for discontinuities. To 
make Maple check on discontinuities or disconnected domains, supply the extra 
option discont=true. 
> plot( l/Y , x=-3 .. 5, -1 .. 1 , discont=true ); 

94 
7. Graphics 
0.8 -
0.6 
0.4 
0.2 
-1 
2 X 3 
-0.2 
-0.4 
-0.6 
-0.8 
-1 
As an alternative, you can revert to plotting only the points that are calculated by 
Maple. Here is an example, first without special options: 
> yl:= 1/sin(x
A 2); 
1 
yl:=--
sin(x2 ) 
> plot( yl , x=-5 .. 5 , -10 .. 10 ); 
10 
8 
~ 
tJ \) 
4 
~ 
~ 
-2 
-4 
-6 
-8 
-10 
Here plot with the option discont=true yields an error due to a bug: 
> plot( yl , x=-5 .. 5 , -10 .. 10 , discont=true ); 
Error. Could not determine discontinuities 

7.5 Graphs with ranges to infinity 
95 
So, let's use the option style=point and at the same time ask Maple to calculate 
a sufficient number of points, say 3,000. 
> plot( y1 , x=-5 .. 5 , -10 .. 10 , 
> 
style=POINT, numpoints=3000 ); 
lOi 
81 
.' 
. . 
.. 
.. . . 
V 
.. . . 
u 
.. 
u u 
u 
V 
~ ~~ ~ 
-2 
~ ~ ~ ~ 
:-
: . .' 
-4 
. 
' 
.. 
: : 
~ 
~ 
. . 
-6 
.. 
-8 
.' 
-10 
7.5 Graphs with ranges to infinity 
Maple offers the facility for plotting on infinite ranges, for instance 
> plot(arctan(x),x=-infinity .. infinity); 
x 
infinity 
This is realized by a transformation of the first coordinate with the following func-
tion: 

96 
x,,{ 1~~ 
-1- ~ 
x 
7.6 Logarithmic scalings 
Log plots and log-log plots are available. 
> 100*x+x~3j 
if 
if 
if 
> plots[logplot]( % , x=O .. 10 )j 
-4 ~ x ~ 4 
x2':4 
x ~-4 
> plots[loglogplot]( %% , x=1 .. 100 )j 
le+06 _ 
le+05 
.leS 
. le4 
1. 
5. 
.le2 
x 
.5e2 
.le3 
7. Graphics 

7.7 Parameterized curves and surfaces 
7.7 Parameterized curves and surfaces 
Here is a graph of a parameterized curve in two dimensions: 
> plot( [sin(3*x),cos(x),x=O .. 2*Pi] ); 
97 
Now an example in three dimensions: the hyperboloid described by the parame-
terizing function 
(t, u) t---+ [cos(t) cosh( u) , sin(t) cosh( u), sinh( u)] 
> plot3d( [cos(t)*cosh(u),sin(t)*cosh(u),sinh(u)] , 
> 
t=O .. 2*Pi,u=-1 .. 1); 
Observe the differences in syntax used in parameterizing; in the two-dimensional 
case the range of the parameter is given as the third element of the list, so the basic 
syntax is: 

98 
7. Graphics 
plot( [ x(t),y(t),range_of_t ] ) 
so it is given within the pair of brackets, but in the three-dimensional case the 
ranges are given outside the list: 
plot3d( [ x(t,u),y(t,u),z(t,u) ] , range_of_t, 
range_oLt ) 
Such a difference between parameterizing in two and three dimensions can also be 
found in analogous cases. 
A curve in three-dimensional space can be drawn by plots[spacecurve]. 
> plots[spacecurve] ([(1+5*arctan(t))*cos(10*t), 
> 
(1+5*arctan(t))*sin(10*t),-t], t=O .. 4, 
> 
numpoints=200); 
We can even blow up this curve to a tube by: 
> plots[tubeplot] ([(1+5*arctan(t))*cos(10*t), 
> 
(1+5*arctan(t))*sin(10*t),-t],t=O .. 4, 
> 
radius=O.07*t,numpoints=200); 

7.8 Different types of coordinates 
99 
7.8 Different types of coordinates 
The second picture in the previous section could have been drawn more easily with 
cylindrical coordinates, like the following: 
> plot3d( [cosh(t),phi,sinh(t)] , t=-1 .. 1 , phi=O .. 2*Pi , 
> 
coords=cylindrical); 
Spherical coordinates can be used in plot3d by using the option coords= 
spherical. 
Maple offers a lot of coordinate systems: see the on-line help. Moreover, you can 
create your own coordinate system with addcoords (which must be read with 
readIi bfirst). 
Here is another example. In two-dimensional space, polar coordinates can be used, 
as in the following example, where the so-called lituus, described by the equation 
r 2 <f> = 1, is drawn. 
> plot([1/sqrt(phi),phi,phi=1 .. 100] ,coords=polar); 
.8 
0.6 

100 
7. Graphics 
7.9 Empty plots caused by complex values 
Sometimes, plotting a graph may not be successful. This may be caused by ap-
proximations that should be real numbers but turn out to contain a small imaginary 
component. 
> convert( tan(x) , exp ); 
1 (( e(I x)) 2 - 1) 
(e(I x))2 + 1 
Obviously, the values of this expression are real for real x, but plot gets into trou-
bIe. 
> plot( % , x=-l .. l ); 
Plotting error, empty plot 
This is caused by the fact that plot uses numerical approximations. For instance, 
> evalf( subs(x=O.5,%%) ); 
.5463024898 + .806035395210-11 1 
Such a complex number is not accepted by the plot procedure. However, it is 
easy to mend this problem: plot the real part of the expression. 
> plot( evalc(Re(%%%)) , x=-l .. l ); 
7.10 Plotting data 
1.6 
1.4 . 
1.2 
0.8 
A set of two- or three-dimensional data can be represented in a graphic. Let's create 
a sequence of pairs of numbers. 

7.1 O Plotting data 
> data:=seq([k-2,k-3-8*k-2+17*k] ,k=O .. 6); 
data := [O, O], [1, 10], [4, 10], [9, 6], [16, 4], [25, 10], [36, 30] 
This sequence can be represented as a continuous graph, in fact, a polyline. 
> plot( [ data] ); 
30 
28 
26 
24 
22 
20 
18 
16 
14 
12 
la 
8 
6 
4 
2 
O~~~~~~~~~~~=V 
4 
8 
12 
16 
20 
24 
28 
32 
36 
or as a set of points, here indicated by small circ1es. 
> plot( [ data] , style=POINT ); 
30 
28 
26 
24 _ 
22 
20 
18 
16 
14 
12 
10 
8 
6 
4 
O~~~~~~=F~~~~=V 
4 
8 
12 
16 
20 
24 
28 
32 
36 
101 
In both cases, the data should be bundled together as one argument by enc10sing 
them within an outer pair of square brackets. 

102 
7. Graphics 
It is also possible to create a smooth curve from these data with the aid of the proce-
dure spline, which creates a piecewise polynomial function from data. This must 
be loaded tirst: 
> readlib(spline); 
proc(X, Y, z, d) ... end 
For spline the data must be structured in a different way: a list of all tirst coor-
dinates and a list of all second coordinates; see Chapter 10, Manipulating several 
objects at once: 
> xdata:=[seq(op(1,data[i]),i=1 .. 7)]; 
xdata := [O, 1, 4, 9, 16, 25, 36] 
> ydata:=[seq(op(2,data[i]),i=1 .. 7)]; 
ydata := [O, 10, 10, 6, 4, 10, 30] 
> plot( spline(xdata,ydata,x) , x=O . . 40 ); 
38 
36 
34 
32 
30 
28 
26 
18 
16 
14 
12 
10 
8 
6 
4 
2 
o 
10 
20 
X 
30 
40 
In a comparable way, a sequence of triads of numbers Can be plotted. However, 
the procedure plot3d cannot be used for this purpose. Use plots [surfdata]. 
For statistical purposes you can use histograms, boxplots, etc.: see the on-line help 
for stats, statplots. 
You can also use plots [matrixplot] and plots [sparsematrixplot]. 

7.l2 Combining graphs 
103 
7.11 Graphs of relations or implicitly defined functions 
A facility for plotting graphs of algebraic relations in two and three dimensions is 
available: 
> plots[implicitplot3d]( 
x~2-z*y~2=1 , 
> 
x=-2 .. 2, y=-1.5 .. 1.5 , z=-l .. l , axes=BOXED , 
> 
style=PATCHCONTOUR, orientation=[85,45] ); 
For the two-dimensional case, use plot-s [implici tplot] . 
Generally, the results of plotting graphs of functions and parameterized curves and 
surfaces have better quality and can be produced faster than graphs of relations. 
In some cases you also can use algcurves [parameterization]. 
7.12 Combining graphs 
If you want to combine graphical objects in one picture, first create each of them 
separately. 
> parabolic ;= plot( x~2 , x=-1.5 .. 1.5 ); 
Remember that an assignment of a graphical object to a name must be terminated 
by a colon in order to keep Maple from printing the internal data structure to the 
screen. 
In the same way we can assign two other plots to names. 
> circle ;= plot( [1/2*cos(phi) , 1/2*sin(phi)+1/2 , 
> 
phi=O .. 2*Pi]); 
> line ;= plot( [1+h,1+2*h,h=-1/2 .. 1/2] ); 

104 
7. Graphics 
Now let's ask Maple to print all three together with the aid of the procedure 
plots[ display ]: 
> plots[display]( {parabolic,circle,line} ); 
-1.4 
-1 
-0.6 -0.2 
0.2 
0.6 
1.4 
Note that Maple chooses the range of the second coordinate, if the user does not 
specify this. Therefore, a circle is rendered as an ellipse, generally. This can be 
rectified by adding the option scaling=CONSTRAlNED: 
> plots[display]( {parabolic,circle,line} , 
> 
scaling=CONSTRAINED ); 
-1.4 
-1 
-0.6 -0.2 
0.2 
0.6 
1.4 
With display it is easy to plot a bundle of graphs in one picture. For instance, 
let's create a sequence of circle graphs without printing them. 

7.14 More tools in graphics 
lO5 
> seq ( plot([n*cos(phi) , n*sin(phi)+n , phi=0 .. 2*Pi]) , 
> 
n=1 .. 10): 
These can be plotted together by 
> plots[display]( [%] ); 
In the same way, display can be used for combining three-dimensional graphics. 
(In earlier releases, use plots [display3d] .) 
7.13 Maple's movies 
It is easy to create a small movie of parameterized graphics in Maple, 
with or without looping, with the procedures plots[animate] and plots 
[animate3d]. If you are interested, try some examples given by Maple in the 
on-line help for these two procedures. Moreover, you can use plots [display] 
to create a movie from a list of plot objects by adding the option insequence= 
true. It is also possible to use html format for creating mov ies to be played with 
software for these formats. 
7.14 More tools in graphics 
The plots and plottools packages contain several procedures not mentioned 
previously for special types of plots, for instance some ready-to-use pictures, such 
as: 
> plottools[icosahedron] ([0,0,0] ,1): 
The result of this command is suppressed by the colon: it is not a pic ture but an 
internal structure for polygons. To get a picture, enter: 

106 
7. Graphics 
> plots[display] (%); 
Special tools aimed at differential equations can be found in the packages plots 
and DEtools. These are discussed in section 17.5 on page 238. 
The packages geometry and geom3d for geometry and the pedagogical package 
student also contain some graphical tools. 

chapter 8 
Taylor or Laurent expansion and limits 
When an exact algebraic computationfails, you can of ten resort to series approx-
imations, using the theory of Taylor and Laurent expansions. Sometimes, a series 
approximation is even sufficient to get exact results,for instance, in calculations of 
limits. This idea is exploited by Maple; therefore, this chapter includes calculation 
oflimits. 
8.1 Taylor expansion 
For the calculation of a Taylor expansion of a function in one variable, the proce-
dure series can be used: 
> (x+l)/(cos(x)+2); 
x+l 
cos (x) + 2 
We have asked for a Taylor approximation centered at x = O. The term O (x5 ) 
indicates a remainder term such that lim"'-to «,,"'55) exists. 
The second argument to series determines the variable in which the expression 
is to be expanded, and the point from which this is to be done: 
> series( exp(x) , x=a , 5 ); 
a 
a ( 
) 
1 a ( 
)2 
1 a ( 
)3 
1 
a ( 
)4 
e +e x - a +"2 e x - a +6 e x - a + 24 e x - a + 
O((x - a)5) 
The last argument to series may seem to ask for a fifth order expansion, but the 
next section explains why that is not true. 
E. Kamerich, A Guide to Maple
© Springer Science+Business Media New York 1999

108 
8. Taylor or Laurent expansion and limits 
8.2 The order of a series expansion 
lf Maple calculates a series expansion of an expression, generally it calculates se-
ries expansions of "elementary" subexpressions tirst and then combines these ex-
pansions. The third argument to series, 5 in the previous examples, determines 
the order of the series expansions of these subexpressions. It is quite possible that 
the series expansion found at the end has lower order than these intermediate re-
sults. So sometimes you must experiment a liUle with the order argument to se-
ries. For instance, 
> sin(x)~4/x~4; 
> series( % , x=O , 5 ); 
The result is not of order 5 but only 2. In this case, order 9 in the calculations is 
necessary for getting a series approximation of order 2: 5: 
> series( %% , x=O ,9); 
2 
1 
1 - _x2 + _x4 + O(x6 ) 
3 
5 
However, series remembers the previous results. So, if we again ask for a series 
expansion of order 5, Maple does not try to calculate it, but it remembers this sixth 
order result and uses it: 
> series( %%% , x=O ,5); 
2 
1 
1 - _x2 + _x4 + O(x6 ) 
3 
5 
If no third argument is supplied to series, the expansion order is taken to be equal 
to the value of the environment variable Order, which is initiaIly 6. 
8.3 Estimating the order tenn 
A rough estimation of the order term can be calculated by using the Taylor Remain-
der Theorem. Let's estimate the remainder for order 6 on the domain [-1 ... 1] in 
the foIlowing series expansion: 
> Y := sin(1+x~2); 
> series( % , x=O ,6); 
sin(l) + cos(l)x2 -
~ sin(l)x4 + O(x6 ) 
First we must take the sixth order derivative: 

8.4 The subexpression structure of results from series 
> diff( Y , x$6 ); 
-64 sin(1 + x 2 ) x 6+480 cos(1 + x 2 ) x4+720 sin(1 + x 2 ) x 2 _ 
120 cos(1 + x 2 ) 
109 
Now we can use the procedure numapprox[infnorm], which estimates numeri-
cally the maximal absolute value of an expression: 
> numapprox[infnorm]( % , x=-l .. l ); 
488.3141273 
So we get a rough estimate of an upper limit of the difference between function 
value and series value on the domain [-1..1] as 4:,9 x6 • 
8.4 The subexpression structure of results from series 
A resuIt from series may look like a polynomial up to the order term, but gener-
ally it has a special data structure within the computer. As a consequence, such a 
result behaves differently from polynomials, generally. Here is an example. Con-
sider the polynomial 
> pn := expand( (1+x)-3 ); 
pn := x 3 + 3 x 2 + 3 x + 1 
If we ask for a series expansion to order 4 of this third-degree polynomial, the order 
term is rightly omitted: 
> sr := series( (1+x)-3, x=O, 4); 
sr := 1 + 3x + 3x2 + O(x3 ) 
The result is printed as if it is a polynomial, but it is a Maple object of a quite dif-
ferent structure; therefore, subtracting sr and pn does not yield O(x3 ) - x 3 : 
> sr - pn; 
The structural difference between pn and sr can be shown with whattype and op: 
> whattype(pn); op(pn); 
+ 
> whattype(sr); op(sr); 
series 
1, O, 3, 1, 3, 2, 1, 3 

110 
8. Taylor or Laurent expansion and limits 
First we see, that pn is just asum. Its summands (the operands of the + operator) 
are shown here with the aid of op. Then we see that sr has the series structure, 
with coefficient 1 to the zeroth-order term, coefficient 3 to the first-order term, co-
efficient 3 to the second-order term and coefficient 1 to the third-order term. The 
expansion variable x can be obtained with op (O, sr) . 
The series structure may be somewhat willful occasionally, but it can prevent some 
manipulations that could be hazardous. For instance, 
> series(cos(x),x=0,5); 
1 
1 
1 - _x2 + _x4 + O(x5 ) 
2 
24 
> subs(x=O,%); 
1 
> subs(x=l,%%); 
Error, invalid substitution in series 
The first substitution is acceptable, but the second cannot generate an exact result 
because of the existence of the order term, so this command is rejected. If the user 
insists on substitution of 1 and wants to discard the order term, the series expansion 
must first be converted to a polynomial: 
> convert( %% , polynom ); 
> subs(x=l , % ); 
1 
2 
1 
4 
l--x +-x 
2 
24 
13 
24 
The ca1culation of a Taylor expansion is based on differentiation, which is reliable 
in Maple in principle. 
8.5 The leading term 
If only the leading term of a series (not vanishing term of minimal degree) is to be 
ca1culated, use the following construction: 
> series( leadterm(cos(x-30+x-50)-1) , x=O , 1000000 ); 
1 60 
-2 X 
The third argument, 1000000, has been chosen absurdly high. There is no objec-
tion to so doing. It does not slow down ca1culations in practice and prevents Maple 

8.6 Laurent, Puisseux, and generalized truncated power series 
111 
from failing; if the order (the third argument) is not high enough, the result is an 
orderterm: 
> series( leadterm(cos(x-30+x-50)-1) , x=O , 10 ); 
+O(x60 ) 
As this procedure has to test coefficients of a series expansion for being zero, this 
procedure is not fully reliable in principle, but generally no reliability problems of 
this type are expected. 
8.6 Laurent, Puisseux, and generalized truncated power series 
The procedure series can do more than Taylor expansion. For instance, 
> sl := series( 1/tan(x-2) , x=O , 11 ); 
1 
1 
s1 := x-2 -
_x2 - _x6 + O(x7) 
3 
45 
Here a Laurent expansion has been calculated. Notice that the third argument (the 
order 11) yields an expansion up to degree 6. As explained earlier in this chapter, 
this is caused by the fact that ser ies calculates a result based on intermediate cal-
culations of series expansions of order 11. In practice, you must experiment with 
the order argument to series. 
This result can be converted to a generalized polynomial, containing terms of neg-
ative integer degree: 
> convert( % , polynom ); 
1 
1 2 
1 
6 
x2 -
3" x -
45 x 
If the limit of a function f to 00 exists, you can ask for a possible Laurent expansion 
in 00: 
> series( arctan(x) , x=infinity , 8 ); 
~ 71' -
~ + ~ ~ - ~ ~ + ~ ~ + O (~) 
2 
x 
3 x 3 
5 x5 
7 x 7 
x 8 
The calculation can be represented by substituting y = 1/x in arctan(x), expand-
ing the result in y = 0+, and substituting y = 1/x in the result. You can use the 
procedure asympt, too. 
Here is a case where no Laurent expansion exists, but where series yields a Puis-
seux expansion: 
> series( sqrt(x-3 + x) , x=O , 5 ); 
Vx + ~ X(5/2) -
~ x(9/2) + O (X(13/2)) 
This is a very special case, as the result of series is not of type series in this 
case, but simply a sum of a polynomial in x and a formal order term. 

112 
8. Taylor or Laurent expansion and limits 
> whattype( % )j op( %% )j 
+ 
This order term can be omitted by substituting O for it: 
> subs( 0=0 , %%% )j 
Vi + ~ X(5/2) -
~ X(9/2) + O( x(13/2)) 
> % 
1 
1 
Vi + - X(5/2) -
- x(9/2) 
2 
8 
The last step evaluates the result of the substitution. This is necessary because, 
after a substitution, the result is presented without automatic evaluation and sim-
plification. 
If the growth of a function is too fast, Maple may use a generalized series: 
> series( x~x , x=O , 2 )j 
1 + ln(x)x + O(x2) 
Here the coefficient of x is -In (1/ x) , not a constant, but its order is lower than 
the order of the monomial that it belongs to, in this case, lower than x. 
8.7 Application of series to integration 
Series can be used when no exact antiderivative (primitive) function can be found. 
For instance, 
> x~4/cos(x)j 
x4 
cos(x) 
> series( % , x=O , 12 ); 
1 
5 
61 
x 4 + _x6 + _x8 + _x10 + O(X12 ) 
2 
24 
720 
> int( % , x )j 
1 5 
1 
7 
5 
9 
61 
11 
13) 
S"X + 14 x + 216 x + 7920 x 
+ O(x 
The approximation of this antiderivative now has the series data type like the 
original expression yielded by series. In order to use it for further computa-
tions, you can apply convert ( 
,polynom) or, as explained in the next section, 
convert ( 
,ratpoly) . 

8.9 Multivariate Taylor expansion 
113 
If you want to use a series expansion for a definite integral, convert that series to 
a polynomial or a rational expression, and then apply int, but, please, remember, 
that you are responsible for neglecting the order term by removing it. This term is 
why Maple refuses to calculate a definite integral of an object of type series. 
Sometimes, series can be applied to an unevaluated integral (or an inert integral), 
but only if expansion in O is asked for; for instance, in a variant of the previous 
example: 
> int( x~4/cos(x) , x ); 
J ~dX 
cos(x) 
> series( % , x=O , 12 ); 
1 5 
1 
7 
5 
9 
61 
11 
13 
5"X + 14x + 216 x + 7920 x + O(x ) 
The use of series in solving equations or differential equations is discussed in sec-
tion 16.10 on page 230 and section 17.6 an page 240. Series expansions of solu-
tions of equations (series approximations to implicitly defined functions) are dis-
cussed in section 16.9 an page 227. 
8.8 Numerical evaluation of a series 
For numeric al evaluation of a series, it can be efficient ta convert it ta a rational 
expression that has the present series as its series approximation (of the given or-
der). This is possible with convert ( 
, ratpoly ). Subsequently applying 
convert ( 
, confrac) can speed up things still more. 
8.9 Multivariate Taylor expansion 
For Taylor expansion of functions of more than one variable, the procedure mtay-
lor is available. This must be read from the miscellaneous library with readlib 
before it can be used: 
> readlib(mtaylor): 
> m:= y - y*x -
x~2 + sin(a*y+b*x); 
m := y -
y x - x 2 + sin( a y + b x) 
> mtaylor(m,{x=O,y=O},2); 
bx+(1+a)y 
> mtaylor(m,{x=O,y=O},3); 
b x + (1 + a) y - y x - x 2 

114 
8. Taylor or Laurent expansion and Iimits 
> mtaylor(m,{x=0,y=0},4); 
2
1 33
1
22
1 22 
bx+{1+a)y-yx-x -fib X -"2 ayb X -"2a y bx-
1 
_ a3 y3 
6 
The result is not oftype series and does not contain an order terrn. In fact, mtay-
lor uses the simple trick of substituting t*x for x, t*y for y, etc., calculating the 
Taylor expansion to t with order equal to the third argument to the caII to mtay-
lor (excIuding the possibility of a Laurent expansion, etc.), and then converting 
the result to a polynomial and substituting 1 for t. This explains the foIIowing 
re suit: 
> mtaylor( (x~3-y~3)/(x~2+y~2) , {x,y} , 10 ); 
x3 _ y3 
x2 +y2 
From the same reason, you may guess the background for the following error mes-
sage with its not very useful advice: 
> mtaylor( x/(x~2+y~2) , {x=O,y=O} , 3 ); 
Error, does not have a taylor expansion, try series() 
A variant with weighted orders of the variables is available with an option to mtay-
lor. 
8.10 Ca1culating limits 
The procedure lirnit can be used for the calculation of limits: 
> limite sin(x)/x , x=O ); 
1 
> limite arctan(x) , x=infinity ); 
1 
"2 7r 
> limite l/x , x=O ); 
undefined 
If it is desirable, you can indicate the direction with a third argument: 
> limite l/x , x=O , left ); 
-00 
The possible directions are left, right, real, and complex. Where the \imit 
point is not 00 or -00 the default is real (bidirectional). 

8.1 O Calculating limits 
115 
As limits are ca1culated with the aid of series, it can be important that series ex-
pansion is executed up to sufficient order. Sometimes, it can help to raise the level 
ofOrder: 
> series(cos(x),x=O,12); 
1
2
1
4
1
6
1
8 
1- 2x + 24x - 720 x + 40320x 
1 
10 
O( 12) 
3628800x + 
x 
> convert(%,polynom); 
1
2
1
4
1
6
1
8 
1--x +-x --x +--x 
2 
24 
720 
40320 
> limit«cos(x)-%)/x~12,x=O); 
1 
10 
3628800 x 
. 
cos( x) - 1 + ~ x2 -
214 x 4 + 7~O x6 -
40~20 x 8 + 362~800 x10 
hm 
x-+O 
X 12 
The procedure limi t has called series, expanding the tirst argument up to the 
standard order of series expansion given by the value of the name Order, and this 
expansion is not sufticient for tinding the limit. So let's raise this order and start 
the ca1culation again: 
> Order:=13; 
Order := 13 
> %%; 
1 
479001600 
In the following case, Maple cannot give a result: 
> limit(exp(-pl*x),x=infinity); 
Iim e(-p1x) 
x-+oo 
The user might intend pl to represent a positive real number, but Maple does not 
know so. You can tell this to Maple by using the procedure assume. See section 
3.4 on page 36 or section A.4 on page 278. 
> assume(pl,positive); 
Now Maple can tind the limit. As the previous command leaves no result on the 
stack, we can use the double quote for repeating the limit command: 
> % ; 
o 
The procedure PDEtools [dchange] can be used for substitutions in limits, al-
tematively using the inert variant Limi t of limi t. (In releases before Release 5, 
use student [changevar] instead of PDEtools [dchange].) 
Generally, ca1culating limits is reliable. 

116 
8. Taylor or Laurent expansion and limits 
8.11 Multiple limits 
Calculation of multiple limits is available in principle: 
> limit( (x~2+y~2)/(x+y+l) , {x=O,y=O} ); 
O 
> limit( (x~2-y~2)/(x~2+y~2) , {x=O,y=O} ); 
undefined 
8.12 Continuity, singularities, and residues 
The procedure iscoDt tries to check if a function is continuous on a given interval. 
It uses some knowledge about standard functions and it depends on solving equa-
tions. So nobody can have a blind faith in the results of this procedure. The same 
holds for the procedure singular that tries to calculate singularities of expres-
sions. If it retums an expression containing _N or _NN, these symbols represent an 
integer or a natural number, respectively. 
The procedure residue tries to compute the residue of a function of one variable 
at a given point. 
8.13 Other facilities for series calculations 
Facilities for working with infinite formal power series are offered by the share-
ware packages PS and FPS and by an old, rather unfriendly package powseries. 
Expansion into Chebyshev polynomials is available as numapprox [che byshev] , 
where the Chebyshev polynomials can be calculated by orthopoly [T] . 

chapter 9 
Numerical calculations with Maple 
Symbolical manipulations are an essential part ofusing Maple, but powerful nu-
merical facilities are available, too. That makes it easy to handle parts of a cal-
culation with symbolical methods, so that the usual rounding problems when ap-
plying numerical procedures can be kept restricted to the remaining parts of the 
calculation. 
This combination of symbolical and numerical facilities makes Maple a very jlex-
ible and efficient tool. However, it may be necessary, for specialized purposes, to 
use other numerical software. Maple offers facilities for using the programming 
languages Fortran and C and the numerical software system Matlab. 
This chapter links up with section 2.8 on page 26 and section 2.9 on page 28 on 
jloating-point numbers. Some special subjects on numerical approximations are 
discussed in connection with matching subjects in other chapters of this book. 
9.1 Accuracy 
The general approximation procedure in Maple is evalf: 
> evalf( sqrt(3) ,50); 
1.7320508075688772935274463415058723669428052538104 
> Int( sin(x~3) , x=0 .. Pi~(1/4) ); evalf( % , 20 ); 
(07r(1/4l 
in 
sin(x3 ) dx 
.53996849568350107601 
Observe the use of Int instead of int in order to prevent Maple from starting sym-
bolical calculation of the integral. The second argument to evalf is the number 
of digits to be used in the calculations, generally, it is not the expected accuracy 
of the result. For instance, in the following case, the last two digits are not correct: 
> evalf((1+sqrt(5))~100,5); 
.100511052 
E. Kamerich, A Guide to Maple
© Springer Science+Business Media New York 1999

118 
9. Numerical calculations with Maple 
In most cases it is easy to find more accurate results simply by increasing the num-
ber of digits: 
> evalf«1+sqrt(5))-100,10); 
.10040690911052 
If no second argument is given to evalf, the value of the name Digits is used in-
stead. The value of Digi ts is 10 at the start-up of Maple. 
If evalf has to handle an expression that contains ftoating-point numbers itself, 
be cautious. For instance, 
> evalf( 0.3 - 100 , 50 ); 
.515377520710-52 
The reason for rounding to 10 digits, instead of 50, is that 0.3100 is caIculated im-
mediately by automatic simplification before the procedure evalf comes into ac-
tion, according to the mIe of evaluation of arguments. Since Digi ts is referring to 
10, this automatic simplification yields a 10-digit result. To get the desired number 
of digits, use 3/10 instead of 0.3: 
> evalf( (3/10)-100 , 50 ); 
.5153775207320113310364611297656212727021075220010010-52 
In more complicated cases, you can convert floating-point elements occurring in 
expressions into rationals with convert( ,rational). See section 12.7 on page 
156. 
The procedure evalf can handle many built-in procedures. More specific infor-
mation is found in this book where the relevant procedures are discussed and in 
section 2.8 on page 26. 
9.2 Speeding up by optimizing 
Suppose that numeric al values of an expression are to be caIculated for many val-
ues of a, x, and y, for instance, for the purpose of numerical integration. Then 
caIculations may be speeded up by manipulating that expression before. Consider 
the expression 
> pO ;= 9*a-3*x-5*exp(y)-2-6*a-3*x-4*exp(y)+ 
> 
a-3*x-3+27*exp(y)-3*a-2*x-4-18*exp(y)-2*a-2*x-3+ 
> 
3*exp(y)*a-2*x-2+27*exp(y)-4*a*x-3-
> 
18*exp(y)-3*a*x-2+3*exp(y)-2*a*x+9*exp(y)-5*x-2-
> 
6*exp(y)-4*x+exp(y)-3-x-l; 

9.2 Speeding up by optimizing 
pO:= 9a3 x 5 (ey)2 _ 6a3 x 4 eY +a3 x 3 + 27 (ey)3 a2 x 4 _ 
18 (ey )2 a2 x 3+3eY a2 x 2+27 (ey )4 ax3 -18 (ey )3 ax2+ 
3 (ey )2 ax + 9 (ey )5 x 2 -
6 (ey )4 x + (ey )3 - x -
1 
The number of multiplications can be reduced with convert( ,horner): 
> pi := convert( % , horner ); 
p1 := -1 + (ey)3 + (-6 (ey)4 - 1 + 9 (ey)5 x) x + 
(( 3 (ey )2 + (-18 (ey )3 + 27 (ey )4 x) x) x+ 
((3eY + (-18 (ey )2 +27 (ey )3 x) x) x 2+ 
(1 + (-6eY + 9 (ey)2 x) x) x 3 a) a) a 
119 
This has reduced the number of multiplications from 76 to 45. However, in the 
last expression eY is to be calculated 11 times and several powers of this are to be 
calculated. It is possible to make a further improvement with the procedure code-
gen[optimize], which yields an efficient sequence of calculations. (In releases be-
fore Map1e V.5, the package codegen is not available, use optimize after the 
command readlib(optimize).) 
> p2 := codegen[optimize]( %% ); 
p2 := t1 = a2 , t2 = t1 a, t3 = x 2 , t4 = t32 , 
t7 = eY, t8 = t72 , t14 = t3x, t16 = t8t7, 
t26 = t82 , t41 = 9 t2 t4 x t8 - 6 t2 t4 t7 + t2 t14 + 
27 t16 t1 t4 - 18 t8 t1 t14 + 3 t7 t1 t3 + 27 t26 a t14 -
18 t16 a t3 + 3 t8 a x + 9 t26 t7 t3 - 6 t26 x + t16 -
x-1 
The result is a sequence of equations, indicating the calculation steps, the last yield-
ing the result. The procedure optimize uses the names ti, t2, t3 ... , supposing 
that these names have not been assigned a value. 
You can make optimize do still more than standard by adding the option try-
hard. 
The easiest way of using this sequence of calculations is by incorporating it into a 
procedure. This can be done with the procedure codegen[makeproc]. (In releases 
before Maple V.5, use 'optimize/makeproc'; don't forget the back quotes.) 
> f2 := codegen[makeproc]( [p2] , [a,x,y] ); 

120 
9. Numerical calculations with Maple 
12 := proc(a, x, y) 
local tl, t2, t41, t8, t4, t3, t7, t14, t16, t26; 
tl := a'2; 
t2 := tl * a; 
t3 := x'2; 
t4 := t3
A 2; 
t7 := exp(y); 
t8:= tT2; 
tl4 := t3 * x; 
tl6 := t8 * t7; 
t26 := t8
A 2; 
t41 := 9 * t2 * t4 * x * t8 - 6 * t2 * t4 * t7 + t2 * 
tl4 + 27 * tl6 * tl * t4 - 18 * t8 * tl * tl4 + 3 * t7 * 
tI * t3 + 27 * t26 * a * t14 - 18 * tl6 * a * t3 + 3 * 
t8 * a * x + 9 * t26 * t7 * t3 - 6 * t26 * x + tl6 - x-
1 
end 
This procedure can now be used as a function that calculates values of the expres-
sion pO quickly: 
> f2( 0.33333 , -1.2345 , 3.1417 ); 
.8831624520108 
Such a procedure can be differentiated with the procedure D. See section 6.9 on 
page 79. Moreover, when the original expres sion contains only one variable, and 
consequently the corresponding procedure has just one argument, this procedure 
can be numerically integrated: 
> evalf(Int(f2(1.35,t,t~3/(t~2+1)),t=0 .. 1)); 
47.00305394 
(In releases before Maple V.5, use 'evalf / int' for the calculation above.) Even 
for the relatively small expression in the present example, this last calculation is 
considerably (about twice) faster than numerical integration of the original expres-
sion pO. 
The facilities discussed here can be quite efficient for more complicated calcula-
tions. The reduction in work can be shown by the procedure cost: 
> codegen[cost] (p1); 
13 additions + 46 multiplications + 11 lunctions 
> codegen[cost] (p2); 

9.4 Some special procedures 
121 
39 multiplications + 10 assignments + functions + 13 additions 
In the last result "functions" is to be read as "1 function call". 
For rational expressions and function calls, efficiency can be improved by 
approximating the expression with a continued fraction, using the procedure 
convert( ,confrac,<var». This procedure calculates a series approximation to 
the given expression with respect to the variable given as a third argument, and 
then converts this into a truncated continued fraction (Pade approximation): 
> convert( exp(t) , confrac , t ); 
t 
The value of Order, or an additional fourth argument, determines the accuracy of 
this approximation. See section 8.2 on page 109. 
After conversion of an expression to a continued fraction, you can apply code-
gen[optimize] as well. 
9.3 Speeding up with ftoating-point facilities of the system 
Maple can use the standard facilities of the system for floating-point calculations 
by the procedure evalhf: 
> evalhf( exp(3) ); 
20.08553692318767 
Generally, this procedure is considerably faster than evalf, but the number of dig-
its is determined by the properties of the computer system, using "double preci-
sion". This procedure is also used in the context of hfarrays. 
9.4 Some special procedures 
The numapprox package contains several approximation procedures, for instance 
infnorm, which estimates the maximum absolute value of a function on an in-
terval, and minimax, which tries to construct an optimal approximation to an ex-
pression by a rational expression. The share library offers more approximation 
procedures; see section 5.6 on page 69. Moreover, Maple contains procedures for 
Fast Fourier Transform (FFT and its inverse iFFT). 

122 
9. Numerical calculations with Maple 
9.5 Using Fortran and C in combination with Maple 
In Maple V.5 you can translate Maple procedures into Fortran or C routines, if the 
original routine does not contain untranslatable parts. Let's translate the procedure 
f2 from the above into C: 
> codegen[C] (f2); 
#include <math.h> 
double f2(a,x,y) 
double a; 
double x; 
double y; 
{ 
do~ble ti; 
double t2; 
double t4i; 
double t8; 
double t4; 
double t3; 
double t7; 
double t14; 
double t16; 
double t26; 
{ 
ti = a*a; 
t2 = ti*a; 
t3 = x*x; 
t4 = t3*t3; 
t7 = exp(y); 
t8 = t7*t7; 
t14 = t3*x; 
t16 = t8*t7; 
t26 = t8*t8; 
t4i = 9.0*t2*t4*x*t8-6.0*t2*t4*t7+t2*t14+27.0*t16*ti*t4-
i8.0*t8*ti*t14+3.0*t7*ti*t3+27.0*t26*a*t14-i8.0*t16*a*t3+ 
3.0*t8*a*x+9.0*t26*t7*t3-6.0*t26*x+t16-x-i.0; 
return(t4i); 
} 
} 
There are several options possible for these commands; for instance the option 
filename = 
causes the output to be appended to the named file. 
In previous re1eases, only a list of equations could be translated by fortran and C. 
9.6 Data files 
For reading in a data file of numbers, you can use the procedure readdata. This 
is discussed in section 18.21 on page 274. For more complicated cases, readline 
and sscanf are available, preferably in combination with anhfarray. For simple 
output to files, you can use wri teto and appendto or wri te and wri teln; for 
hfarrays, use printf. More information about these features can be found in 
the on-line help. 

chapter 10 
Manipulating several objects at once 
In Maple, several mathematical objects can be joined together in a sequence, a set, 
or a Zist. This chapter shows you how to handle these, in which ways they can be 
used, and how you can process several objects at once. 
Besides these three constructions, Maple has tables and arrays. The las! section 
ofthis chapter introduces tables. Arrays are more important in the common inter-
active use of Maple, especially when using matrices and vectors. This subject is 
discussed in Chapter 18, Vectors and matrices. 
10.1 Creation of sequences, sets, and lists 
Maple procedures often yield sequences, for instance, 
> 4*x-6+(16-4*b)*x-5+(12*b-75)*x-4+(63-9*b)*x-3; 
4x6 + (16 - 4b) x 5 + (12b - 75) x 4 + (63 - 9b) x 3 
> sol := solve(%,x); 
3 3 
sol := O, O, O, "2' "2' -7 + b 
Now sol is a sequence of six objects. 
We can also create a sequence in a direct way. For instance, 
> sqA := 111, 2-x, a-3, cos(4), O; 
sqA:= 111, 2x , a3 , cos(4), O 
Now sqA is a sequence of five objects. 
If we create a sequence of five objects by replacing the third element of sqA by the 
sequence sol 
> sqB := 111, 2-x, sol, cos(4), O; 
sqB:= 111, 2x , O, O, O, ~, ~, -7 + b, cos(4), O 
we do not obtain a sequence of five objects, but the elements of sol are merged 
into the sequence and so we find a sequence of 10 objects. If we want to tie the 
elements of sol together as a whole, we can bundle them into a set or a list. 
E. Kamerich, A Guide to Maple
© Springer Science+Business Media New York 1999

124 
10. Manipulating several objects at once 
> setA := {sol}; 
3 
setA := {O, -7 + b, 2 } 
In this example you can see that Maple conforms to the mathematical idea of a set: 
it is useless to denote an element more than once. Moreover, Maple renders the 
elements of a set in an order according to Maple's internal preferences. Here is an 
example: 
> setA :={111, 2-x, a-3, cos(4), O}; 
setA:= { 0,111,2:1:, cos(4), a3 } 
Often, these characteristics of a set are not appropriate. Therefore, Maple has an-
other structure: list. A list can be created by writing down a sequence between 
brackets: 
> listA := [111, 2-x, a-3, cos(4), O]; 
listA:= [ 111,2:1:, a3 , cos(4), O] 
> listB :=[ sol]; 
listB:= [O, 0, o,~,~, -7+b] 
These constructions can be combined as in the following example: 
> 111, 2-x, [sol], cos(4) , O; 
111,2:1:, [O, 0, O,~,~, -7+b], cos(4), ° 
Here the elements of sol are tied together in a list, which is used as one element 
of the sequence containing five elements in all. 
The void sequence (the sequence with no elements) is denoted by NULL, and the 
void list and void set are denoted by [] and { }. 
You can convert a set Of a list to a sequence with op: 
> op(listA); 
111,2:1:, a3 , cos(4), ° 
The procedure op cannot be applied to a sequence: 
> op(%); 
Error, wrong number (or type) of parameters in function op 
The number of elements of a list or set can be ca1culated by nops: 
> nops( [ p, q, r] ); 
3 

10.2 Selecting elements of sequences, sets, and lists 
125 
The number of elements of a sequence can be caIculated by counting the elements 
of the corresponding list: 
> nops( [%%] ); 
5 
The number of elements in a sequence, list, or set can be up to 217 - 2 = 131070. 
If there are more, you get a message: 
> a $ 131071: 
Error, object too large 
10.2 Selecting elements of sequences, sets, and lists 
Selecting from a set or a list is possible by using op: 
> op( 2, setA ); 
111 
> op( 3, listA ); 
You can use a range to obtain a subsequence: 
> op( 2 .. 4, listA); 
2", a3 , cos( 4) 
Indexing can be used for lists and sets as weB: 
> listB[6]; 
-7+b 
It is not possible to change a sequence or set by assigning to an indexed element, 
but it is possible for a list (from rele ase V.4): 
> listA [1] : =10; 
listAI := 10 
> listA; 
[10,2", a3 , cos(4), O] 
Selecting from a sequence is possible by indexing, using square brackets: 

126 
10. Manipulating several objects at once 
> sol [4] ; 
3 
-2 
You can obtain a subsequence by index ing with a range: 
> so1[3 .. 5]; 
Remember: 
3 3 
0, 2' 2 
The procedure op cannot be applied to sequences. 
That is because op tries to convert its argument into a sequence: 
> op ( 1 , sol ); 
Error. wrong number (or type) of parameters in function op 
Searching and selecting special elements from a list or a sequence is discussed in 
sections at the end of this chapter. 
10.3 Applying a procedure to several objects at once 
It is often efficient to process several objects at once. For instance, suppose that a 
parameterized equation has been solved like this: 
> equ := x~4+5*x~3*a-4*x~3*b-6*a~2*x~2-24*a*x~2*b+ 
> 
36*a*x*b+14*a~2*x+16*x*b~2-16*b~2-16*b*a-4*a~2; 
equ := x 4 + 5x3 a - 4x3 b - 6a 2 x 2 - 24ax2 b+36ax b+ 
14a2 x + 16xb2 -16b2 -16ba - 4a2 
> solutions := solve(%,x); 
solutions:= -3a+V9a2 + 4b + 2a, -3a-V9a2 + 4b + 2a, 
1 
1 
~-=------::c------,.--
2 b + 2 a + 2 \1'16 b2 + 8 b a + a2 - 16 b - 8 a, 
2 b + ! a - ! V16 b2 + 8 b a + a2 - 16 b - 8 a 
2 
2 

10.3 Applying a procedure to several objects at once 
127 
Now you may want to substitute values for a and b in this sequence of four expres-
sions and try to do so as follows: 
> subs( a=6 , b = 3 , solutions ); 
Error, wrong number (or type) of parameters in function subs 
The cause of this error is that the name solutions refers to a sequence of four 
expressions. So the arguments (a=6 , b=3 , solutions) are evaluated to a 
sequence of six objects: two equations and four algebraic expressions. But subs 
expects as its arguments one or more equations and at the end just one object to 
which the substitutions have to be applied. 
To substitute in ali the solutions at once, we have to tie them together into a list (or 
a set), in order to give it as one last argument to subs: 
> subs( a=6 , b = 3 , [solutionsJ ); 
[ -18 + v'348, -18 - v'348, 9 + ~ v'228, 9 - ~ v'228 ] 
Many procedures can handle lists and sets, for instance diff, evalf, expand, 
normal, and simplify: 
> simplify( % ); 
[ -18 + 2 V87, -18 - 2 V87, 9 + vf57, 9 - vf57] 
Generally, standard mathematical functions (see Chapter 6, Creating and using 
mathematicalfunctions) cannot be applied to a list or a set: 
> liste := [ 5*a-2*ln(3) , o , ln(b) J; 
listC := [ 5 a2 ln(3), 0, ln(b) ] 
> exp( % ); 
exp ([ 5a2 In(3), 0, ln(b)]) 
The procedure exp cannot use a list as an exponent to e, but it does not protest 
against this input and yields the exp of this list unevaluated, whatever that may 
mean. For such a case, use the procedure map: 
> map( exp , liste ); 
[ e(5a2 In(3)), 1, b] 
The procedure map has applied ln to ali the elements of liste, preserving the list 
structure. Ifthe elements ofthis list should be simplified by simplify, you don't 
need map; simplify can be applied to a list directly: 
> simplify( % ); 

128 
10. Manipulating several objects at once 
The procedure map applies the tirst argument, which should be a procedure, to the 
operands of the second argument: 
> map( x->x~2 , [a,b,c] ); 
[ a2 , b2 , c2 ] 
Note that Maple chooses the order of elements in a set. So if you apply map to a 
set, the order in the result may not correspond to the order in the original set: 
> map( x->x~2 , {b,a,c} ); 
{ a2 , b2 , c2 } 
It is even possible to use map in combination with a sum. Here the procedure is 
applied to the operands of the sum, the terms. The result is the sum of the procedure 
values: 
> map( x->x~2 , a+b+c ); 
a2 + b2 + c2 
Sometimes a procedure expects more than one argument, for instance iquo, which 
calculates the integer quotient of two integers: 
> iquo(6020,6); 
1003 
The procedure map can be used for such procedures, too. As an object for demon-
strating this, we generate the tirst 18 prime numbers, using the procedure seq, ex-
plained in the next section. 
> listD := [ seq( ithprime(i) , i=1 .. 18 ) ]; 
listD := [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 
53, 59, 61] 
The integer quotients of the elements of listD divided by 6 can be calculated in 
two ways: 
> map( n->iquo(n,6) , listD ); 
[0,0,0, 1, 1, 2, 2, 3, 3, 4, 5, 6,6,7,7,8,9, 10) 
> map( iquo , listD ,6); 
[0,0, 0, 1, 1, 2, 2, 3, 3, 4, 5, 6, 6,7, 7,8,9, 10] 
In the last command the procedure map applies iquo to pairs consisting of an ele-
ment of listD and the number 6. You can enter the second argument of the pro-
cedure as the third argument to map. And you may go on with more arguments. 
Now suppose we want to calculate the integer quotients of 6020, dividing this sub-
sequent1y by the elements of listD. Then we cannot use the previously explained 

10.5 Finding the minimal or the maximal element 
129 
facility of map with additional arguments. But map2 can do the job: 
> map2( iquo, 6020 , listD ); 
[3010,2006,1204,860,547,463,354,316,261, 207, 194, 162, 
146, 140, 128, 113, 102, 98] 
The procedure map2 applies iquo to pairs consisting of the number 6020 and an 
element of listD. 
It is also possible to multiply each element of a list with a number (not a symbolic 
number) in a direct way: 
> 2* [a, b , c] ; 
[2a, 2 b, 2c] 
10.4 Finding a special element in a set Of a list 
You can ask if a special object occurs in a set or a list by member: 
> member( 3/2 , listB ); 
true 
You can even ask for the first position where this element occurs, by using a name 
as a third argument. This construction is explained in section 5.4 on page 67 for 
the procedure iquo: 
> member( 3/2 , listB , 'pos' ); 
true 
> pos; 
4 
10.5 Finding the minimal Of the maximal element 
The minimal and maximal elemeuts of a sequence of real numbers, possibly con-
taining symbolic elements, are ca1culated by miu and max: 
> min( sqrt(10) , Pi, 22/7 ); 
In the following case, Maple assumes a to be a real number: 

130 
10. Manipulating several objects at once 
> max( a + 5, a+6 , 2*a+6); 
max(2a + 6,a + 6) 
Here Maple cannot decide fully, but if we indicate that a is a positive number, 
Maple can do the full job: 
> assume(a,positive); 
> max( a + 5, a+6 , 2*a+6); 
2a"-' +6 
1 0.6 Selecting the elements that satisfy a special condition 
You can select the elements of a list or a set that satisfy a test with the procedure 
select. For instance, you can look for all prime numbers between 100,000 and 
100,100 as follows: 
> [ seq( i , i=100000 .. 100100 ) ]: 
> select( isprime , % ); 
[100003,100019,100043,100049,100057,100069] 
The first argument to select must be a test procedure (yielding true or false). 
In the previous case, we have used the procedure isprime, which tests if its ar-
gument is a prime number and yields true or false as the re suit. The second 
argument of select should be a list or a set (or asum or a product). 
You can use a test procedure that uses options, too. For instance, let's select all the 
elements that are of type numeric from a given set: 
> { 3/2 , sqrt(2) , x + 7 , O }; 
{ O, x + 7, ~, V2 } 
> select( type , % , numeric ); 
3 
{O, 2} 
Here the second argument to the procedure type is given as the third argument to 
select. For information about the procedure type, consult the on-line help on 
this subject and section A.1 on page 275. 
The test procedure for select may be constructed with the aid of the arrow. For 
instance, here is a numeric al test function that yields true if and only if the ap-
proximation by evalf of its argument x is a positive number smaller than 1: 

10.7 Generating sequences as values of a function or an expression 
> test := x->type(x,numeric) and x>O and x<l; 
test := x -t false 
131 
The procedure test checks first if its argument is a numeric object; if not, Maple 
recognizes that the result is false and so will not try to check if the argument lies 
in the range -1 . .. 1. 
Now we can select the solutions of an equation that lie in this range: 
> fsolve( 16*x
A 4-60*x
A 3+36*x
A 2+4*x-4 , x ); 
-.3058273664, .4089006016, .6720007242, 2.974926041 
> selecte test, [%] ); 
[.4089006016, .6720007242] 
If you would have a list of numbers that contains complex numbers, you would 
have to select the real ones first: 
> [.5+3*I,.7,-Pi]; 
[.5+3.1, .7, -7r] 
> select(x->(x=evalc(Re(x))),%); 
[.7, -7r] 
In this simple case, we can trust the condition x=evalc. In more complicated 
cases, evalc might yield an imaginary component that equals zero mathemati-
cally (see for instance section 15.11 on page 211). In such a case, you might gam-
bIe with numeric al approximations using fnormal (see section 2.8 on page 26) to 
avoid problems with small imaginary components: 
> select(x->(fnormal(evalf(x))=evalc(Re(evalf(x)))),%): 
The counterpart of select is remove, which is used in the same way, but removes 
elements from a set or a list. 
10.7 Generating sequences as values of a function or an 
expression 
A useful tool for generating sequences from an expression is the procedure seq: 
> seq( n! , n=1 .. 10 ); 
1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800 
The name n gets the inte ger values in the range from 1 to 10, denoted as 1.. 10, 
and n! is calculated each time, yielding a sequence of values. 
Here is an application: let's calculate the function values at the (approximated) 
zeros of the derivative of a function: 

132 
10. Manipulating several objects at once 
> f:=x->x~5-50*x~3-25*x~2+15*x-l; 
f := x --t x 5 - 50 x 3 - 25 x 2 + 15 x - 1 
> fsolve( D(f)(x) , x ); 
-5.291800567, -.5277249269, .1908553686, 5.628670126 
Now we want to see the function values at each of these points: 
> seq ( f (% [n]) , n = 1.. nops ([%]) ); 
2479.193139, -8.570742823, .604836765, -3975.227232 
From rele ase V.4, the counting parameter of seq is a formal parameter, so it is not 
assigned to by seq and it is not important if it is assigned to previously. 
10.8 Manipulating sequences, sets, and lists 
The sum or the product of the elements of a set or a list can be calculated by 
convert ( 
, '+') or convert ( 
, '* ' ) : 
> convert( listA, '+' ); 
10 + 2'" + a",3 + cos( 4) 
For sets, the operators union, intersect, and minus are available: 
> {1,3,5} union {2,3,4}; 
{ 1, 2, 3, 4, 5 } 
> % intersect {3,4,5,6,7}; 
{3, 4, 5} 
> % minus {4,6}; 
{3, 5} 
These operators can also be used as procedures, but then the name should be en-
closed in a pair of back quotes; see section 3.8 on page 40. Using such an operator 
as a procedure can be convenient for handling a sequence of sets. An example can 
be found in section E.6 on page 305. 
Here are two lists: 
> listA; listB; 
[10,2"', a",3, cos(4), O] 
3 3 
[O, O, O, 2' 2' -7+b] 
Let's join them together into one list. This can be done as follows: 

10.9 Conversions between sequences, sets, and lists 
133 
> [ op ( '1.% ) , op ( '1. ) ]; 
[ 10, 2x , a",3, cos(4), 0, 0, 0, 0, ~, ~, -7 + b] 
Exchanging an element of a list for something else is easy with the aid of subsop. 
For instance, the second element of listA can be exchanged for X as follows: 
> listA; 
> subsop( 2=X , '1. ); 
[10, X, a",3, cos(4), O] 
Note that this aetion does not ehange the value oJlistA: 
> listA; 
To change the value of listA, you must assign the new value: 
> listA[2] := X; 
listA2 := X 
The procedure subsop can also be used for omitting an element: 
> subsop( 3=NULL , listA ); 
[10, X, cos(4), O] 
Here subsop has created a new list by exchanging the third element of the previous 
list by the void sequence, which omits the third element effectively. 
10.9 Conversions between sequences, sets, and lists 
In the previous section, you saw how a sequence could be converted into a list or 
a set by enclosing it between brackets ([ ]) for a list or braces ({ }) for a set. For 
the opposite direction, use the procedure op: 
> listA; 
[10, X, a",3, cos(4), O] 
> op( % ); 
10, X, a ...... 3 , cos(4), ° 
> op( setA ); 

134 
10. Manipulating several objects at once 
0,111, 2x , cos(4), a",3 
The procedure op is a general tool that can be applied to any Maple object that is 
not itself a sequence; it yields a sequence of the operands of its argument. 
Conversion between lists and sets is achieved by going through a sequence: 
> listB; 
> { op( % ) }; 
> [ op( % ) ]; 
3 3 
[0,0,0, 2' 2' -7+b) 
3 
{O, -7 + b, 2} 
3 
[O -7+b -) 
, 
, 2 
Observe that the last result is not equal to listB. 
10.10 Tables 
Names with an index are introduced in section B.3 on page 287. 
> P [n] ; 
If you assign something to such a name, you create a table. 
> P[l] :=sqrt(3); 
> P; 
> evalCP); 
table([ 
1 =V3 
)) 
p 
In the second command the procedure eval is used in order to see the value of 
P. For tables, the same evaluation rule is used as for procedures. Therefore, the 
second command renders P; full evaluation is demanded with eval. 
Such a table is very compliant; for instance: 

10.10 Tables 
> P[cos] :=sin; 
PC08 := sin 
> P[i,2,3,4,5] :=much; 
> eval<P); 
table([ 
cos = sin 
1 = /3 
(1,2,3,4,5) = much 
]) 
P 1,2,3,4,5 := much 
135 
You can use tab Ies easily if you like. Maple itself uses many tabIes, such as the 
remember tables for procedures; see section D.I on page 293. 

chapter 11 
Substitution and subexpressions 
Substitution is an important tool in manipulating Maple expressions. It is not re-
strieted to substituting something for a name, but ean be used for many more pur-
poses. There are several general tools for substitution. This ehapter shows the 
possibilities and restrietions ofthe substitution tools in Maple. 
11.1 Some examples of substitution 
The obvious usage of substitution is as in the following example: 
> expr ;= sin( a ); 
expr := sin (a) 
> subs( a 
7, expr ); 
sin(7) 
Remember that the last aetion has not ehanged the value of expr. 
> expr; 
sin (a) 
To change the value of expr to the last result, assign it. 
The procedure subs can do much more. For instance, it is possible to replace a 
number with another expression. 
> subs( 7=a+b , %% ); 
sin(a + b) 
Moreover, you can replace the name of a procedure with the name of another pro-
cedure, as in the following two examples: 
> subs( sin=cos , % ); 
cos(a + b) 
> subs( cos=(x->x+3*x-2) , % ); 
(x -t x + 3x2 ) (a + b) 
You may wonder why Maple does not apply this simple function. The root of it is 
that Maple does not evaluate the resuLtfound by subs automatically. 
E. Kamerich, A Guide to Maple
© Springer Science+Business Media New York 1999

11.2 A substitutioo that fails 
When we offer this result again to Maple, it is evaluated. 
> %; 
11.2 A substitution that fails 
Let's go 00 with the last result and now substitute something for a+b. 
> subs( a+b=7 , % ); 
a + b+ 147 
137 
You may wonder why the first occurrence of a+b is not exchanged for 7, whereas 
the second occurrence is exchanged. The cause is that Maple has not seen the first 
occurrence as a subexpression. 
We can break down an expression into its components, called "operands" in 
Maple, by the procedure op. 
> %%; 
> op( % ); 
a, b, 3 (a + b)2 
Maple interprets this expression as a sum of three terms. This is why Maple does 
not see the sum of the first two terms, a+b, as a subexpression. However, the third 
term contains a component a+b. 
> op( % [3] ); 
3, (a + b)2 
> op( %[2] ); 
a +b, 2 
In the last substitution Maple encountered a+b as a component of a component 
of the third component of the original expression, and substituted 7 only for this 
subexpression. 
In this case, there is an easy trick to exchange all occurrences of a+b for 7: sub-
stitute 7-b for a. 
> subs( a=7-b , a + b + 3 * ( a + b)~2 ); 
154 

138 
11. Substitution and subexpressions 
Remember: 
The procedure subs replaces only subexpressions 
of the given expression, generally. 
The subexpressions of an expression, say 'expr', are expr itself, alI the compo-
nents of expr together with alI the components of these components, alI the com-
ponents of the components of the components, and so ono 
11.3 Subexpressions of polynomials, substitution 
When an expression is to be manipulated, it is of ten important to know how it is 
built from subexpressions. Expression structure can be analyzed with the proce-
dure op. For instance, here is a case where the substitution command fails. 
> pol := x-3 - 5*x-2 + 4*x - 3; 
pol := x 3 - 5 x 2 + 4 x - 3 
> subs( 5=t , pol ); 
In order to tind out why substitution did not work as intended, we analyze the struc-
ture of pol. 
> whattype(pol); 
+ 
> op(pol); 
We can select from this sequence the second element by indexing. 
> % [2] ; 
but we can also pick up the second subexpression by using op in another way. 
> op(2,pol); 
The procedure op gives the nth component of an expres sion with the command 
op(n, 
). 

11.3 Subexpressions of polynomials, substitution 
139 
> whattype(%); 
* 
> op(%%); 
Obviously the number -5 is a subexpression of the original expression, so we can 
substitute 5 for t in pol by 
> subs( -5=-t , pol ); 
x3 - x 2 t + 4 x - 3 
Let's analyze the tirst subexpression of pol. 
> op(l,pol); 
> whattype(%); 
> op(%%); 
x,3 
Here is the full1isting of subexpressions of x3 - 5x2 +4x - 3, achieved by applying 
op several times. 
x, 3, x3 , -5, x, 2, x 2 , -5x2 , 4, x, 4x, -3, x3 - 5x2 + 4x - 3 
By this analysis, you can pic ture 
x3 - 5 x2 + 4 x - 3 
as 
sum( power(x,3) , product( -5, power(x,2» , product(4,x) ,3) 
In fact, Maple stores such a polynomial in a slightly different way intemally. This 
is evident when something is substituted for 1. 
> subs( l=ONE, pol ); 
x3 O N E - 5 x 2 + 4 x - 3 O N E 
Therefore, never substitute something for 1 in a Maple expression. 
The procedure subs behaves in an exotic way in other special cases, for instance, 
> subs( a*b=p , t*a*b - 5*a*b ); 
tab-5p 
Here a*b is not a subexpression according to the results of op, but substitution did 
work in the last term. 

140 
11. Substitution and subexpressions 
Experiment with subs yourself. You might predict the results of the following 
commands, then check them: 
• subs(a=t,-a*x); 
• subs(-a=-t, -a*x); 
• subs(5=t, -5*x); 
• subs(-5=-t,-5*x); 
• subs(5/6=t, 5/6*x); 
• subs(a/b=t,a/b*x); 
In all cases, it is wise to analyze the subexpression structure by repeatedly applying 
the procedure op. 
11.4 Subexpressions of rational expressions, substitution 
Let's try a substitution in a rational expression. 
> (a~2 -
b)/(a~2*c); 
> subs( a~2=t , % ); 
t-b 
a2 c 
This may not be what you expected, so let's analyze the original expression. 
> op( %% ); 
2 
1 
1 
a - b, 2' -
a 
c 
A quotient is taken as just a product, in the same way a difference is taken as a 
sum by Maple. Now let's see how the factors of the denominator of this quotient 
are stored. 
> % [2] ; 
> whattype( % ); 
> op( %% ); 
1 
a2 
a,-2 

11.5 Subexpressions of unevaluated function caUs 
It is useful to know that 
Maple takes quotients as products, 
where each factor ofthe denominator is described 
as a power with a negative exponent. 
However, rational numbers are dealt with differently. 
> op( 5/8 ), whattype( 5/8 ); 
5, 8, fractian 
141 
It is not necessary to remember details on subexpression structure, such as the last 
one. It is sufficient to keep in mind that generally subs can do nothing other than 
substitute something for a subexpression, and that these subexpressions can be 
found with the aid of op. Skip over the next section if you are not interested in 
more details. 
11.5 Subexpressions of unevaluated function caUs 
In the example in the first section of this chapter, sin was replaced with another 
name in the expression sin (a+b). Let's find the operands of this expression. 
> sin(a+b); 
sinea + b) 
> op( % ); 
a+b 
This looks strange: sin is not an operand of this expression, but it can be replaced. 
> subs( sin=cos , %% ); 
cos(a+b) 
However, sin really is an artificial operand: the zero-numbered operand. 
> op( O , %%% ); 
sin 
As such, it is recognized by subs as a subexpression. Here is another example: 

142 
11. Substitution and subexpressions 
> int(f(x},x}; 
J 
f(x)dx 
> op( % }; 
f(x), x 
> op( O , %% }; 
int 
11.6 The procedure eval 
The procedure eval can be used in a similar way as subs (from release V.5), but 
with essential differences. Here are some examples where both do the same: 
> sin(a}; 
> eval( % , a=7 }; 
> eval( % , 7=ln(5) }; 
Observe the difference in syntax: 
subs( x=y , expr ) 
versus 
eval( expr , x=y ) 
sin(a) 
sin(7) 
sin(ln(5)) 
In the following command we see a difference: 
> eval( % , sin=exp ); 
5 
> sUbs(sin=exp, %% ); 
As you could see earlier, after substitution with subs no evaluation takes place, 
but it does after substitution with eval. 
The most important difference can be seen in combination with procedures such 
as int, diff, sum, etc.: 

11.8 More than one substitution at once 
143 
> int(f(x) ,x); 
! f(x) dx 
> eval(%,x=a); 
(! f(x) dX) I{ x=a} 
Although x is a subexpression of int (f (x) ,x), it is not replaced by a, as BubB 
would have done, but eval interprets it as an expression in x that might be calcu-
lated in the future. 
11.7 The procedures subs and eval-a survey 
The main facts on the procedure Bubs are the following: 
- before subs and eval come into action, the arguments are evaluated, as usual 
in procedures 
- usually, subs and eval can only replace subexpressions of an expression; a 
subexpression of an expression is the expression itself, its operands or com-
ponents (to be determined with the aid of the procedure op) or an operand of 
an operand, and so on 
- subs replaces ali occurrences of the given subexpression are replaced in the 
given expression, but eval respects such things as the integration variable in 
an unevaluated call to int 
- after this replacement subs does not evaluate the resulting expression, (only 
elementary automatic simplifications are executed), but eval does 
- subs and eval do not change references (values) of names 
11.8 More than one substitution at once 
It is possible to execute more than one substitution at once. For instance, 
> plin := 2*x - 10*y; 
plin := 2x - lOy 
> subs( x=a , y=b , plin ); 
2a-lOb 
But if you try to switch x and y in the same way, it fails: 

144 
11. Substitution and subexpressions 
> subs(x=y , y=x , plin); 
-8x 
The procedure subs has executed the substitutions successively. It is possible to 
do these two substitutions simultaneously as follows: 
> subs( [x=y,y=x] , plin ); 
2y -lOx 
For eval it is also possible to execute more than one substitution at once, but only 
simultaneously, and square brackets (or braces) are compulsory. 
> eval( plin, [x=y,y=x] ); 
2y-lOx 
11.9 The procedure PDEtools [dchange] for changing variables 
The procedure PDEtools [dchange] is meant to be a general tool for changing 
variables (from release V.5; in earlier releases DEtools [Dchangevar] and stu-
dent [changevar] are predecessors ofthis more powerful procedure). Examples: 
> PDEtools[dchange] (x=t+5,sin(x)-x
A 2); 
sin(t + 5) - (t + 5)2 
The procedure DEtools [dchange] cannot substitute objects for general subex-
pressions, but only for variables; it is meant for such cases as: 
> PDEtools[dchange] (x=t+5,Int(sin(x),x=a .. b)); 
l
b- 5 
a-5 sin(t + 5) dt 
In the following, the command cannot be interpreted uniquely, so Maple issues an 
error: 
> PDEtools[dchange] (x=t+u,Int(sin(x) ,x)); 
Error, Missing a list with the new variables 
We have to indicate, with a third argument, what will be the new variable instead 
ofx: 
> PDEtools[dchange] (x=t+u,Int(sin(x) ,x), [t]); 
f sin(t + u) dt 
Square brackets are compulsory for this argument. 

11.10 Substitution of algebraic subexpressions 
145 
The following looks strange: 
> PDEtools[dchange] (x=t+u,Int(f(x),x),[t]); 
J 
f(t,u) dt 
What has happened is that Maple has changed the meaning of f at the same time. 
The reason forthis is the main object ofPDEtools [dchange]: it is to be used for 
differential equations, where f could be an unknown function to be found. How-
ever, this can be changed with another option: 
> PDEtools[dchange] (x=t+u,Int(f(x),x),[t],known=f); 
J 
f(t + u) dt 
More on this procedure can be found in Chapter 17, Solving differential equations. 
11.10 Substitution of algebraic subexpressions 
The following substitution fails: 
> a
A 2*x*b + a*b
A 3 - 3*a
A 5*b
A 5*c; 
a2 x b + a b3 - 3 a5 b5 c 
> subs(a A 2*b=NEW,%); 
a2 x b + a b3 - 3 a5 b5 c 
The procedure subs cannot do what the user seems to want in the last command 
because a2 b is not a Maple subexpression of the given expression. But it is an 
algebraic subexpression. For substitution of algebraic subexpressions the proce-
dure algsubs can be used. (In previous releases use student [changevar] and 
asubs.) 
> algsubs(a
A 2*b=NEW,%%); 
(-3cNEW 2 + 1) b3 a + x NEW 
The same result can be achieved with a more advanced tool, simplification to side 
relations, explained in the next section. 
You might use a variant of the previously mentioned trick of substituting NEW / a A 2 
for b, but the result may not be desirable: 
> subs( b=NEW/a
A 2 , %%% ); 
xNEW + NE;V3 _ 3 NE~5C 
a 
a 
Here is another example: 

146 
11. Substitution and subexpressions 
> x+y-l; 
x+y-l 
> algsubs( x-l 
A drawback of this procedure is that it must choose what to do in less basic cases, 
sometimes making the use of it complicated (see the on-line help for it). A clearer 
approach can be found in the next section. 
11.11 Applying side relations 
Sometimes, when substitution falls short, you can use simplification to side rela-
tions. For example, let's take the expression 
> a*x~2+b*x~3+c*x~4+d*x~5; 
ax2 + bx3 + cx4 + dx5 
Suppose that you want to substitute p y for x 2 • Substitution with the procedure 
subs only changes the first term. In order to change the others as well you can 
issue 
> simplify( % , {x~2 = p*y}, [x] ); 
apy + Cp2 y2 + (bpy + d p2 y2) X 
The last argument [x] asks for reduction of powers of x. In this case, it could have 
been omitted, in fact. 
Here is another example. Suppose that we have two relations: 
> rels := {x~2 = p*y , y~2 = q}; 
rels := { y2 = q, x 2 = py } 
and that we want to reduce the following expression to these two relations. 
> expand( (x~3+y*x-y)~2 ); 
x6 + 2 x4 y _ 2 x3 y + y2 x 2 _ 2 y2 X + y2 
That can be done with the same trick: 
> simplify( % , rels, [x,y] ); 
q + ( - 2 q - 2 p q) x + (p q + 2 p2 q + p3 q) Y 
In the result you don't see x 2 : this could be eliminated with the relation x 2 = p * 
y and it is eliminated because [x, y] indicates that in the first place x should be 
eliminated as far as possible, and then y. 
If we enter [y, x] as the last argument, we get: 

11.12 Finding the structure and subexpressions of large expressions 
147 
> simplify( %% , rels, [y,x] ); 
q + ( - 2 q - 2 p q) x + (q + 2 p q + p2 q) x2 
Here y is eliminated and x is reduced to maximal degree 2. 
The procedure simplify with side relations is based on the Buchberger algorithm 
in Grăbner basis theory. Essentially, this aims at reduction of degrees of tenns. 
The present method is not restricted to polynomials. For instance, 
> a*exp(y)+a~2*(2*x*y-3*y*z)+x*y*z; 
aeY + a2 (2yx - 3yz) + xyz 
We will convert this into a complicated expression, to be used as an example for 
simplifying to side relations. 
> a:=exp(x)-y~2*z+1; 
> expand(%%): 
> combine(%,exp); 
e(Y+x) -eY y2 z+eY +2 e(2 x) y x- 3e(2 x) y z-4 eX y3 z x+ 
6 eX y3 Z2 + 4 eX y x - 6 eX y z + 2 y5 z2 X _ 3 y5 Z3 -
4 y3 Z x + 6 y3 Z2 + 2 y x - 3 y Z + x y z 
Now let's ask Maple to reduce the previous expression to the relation a = 0, that 
is to say, to eX -
y2 Z + 1 = 0, eliminating eX as far as possible. 
> simplify( % , {a=O} , [exp(x)] ); 
xyz 
More examples can be found in the Chapters 13, 14, and 15. 
11.12 Finding the structure and subexpressions oflarge expressions 
If an expression is too large to readily see what its structure is, use whattype 
in order to see if it is a sum, a product, a power, an unevaluated function call, or 
something else. See section A.l on page 275. The number of operands of an 
expression can be found with nops. With the aid of the procedure bas you can 
find out if one expression is a subexpression of another expression. 
> has( factor(x~1000-1) , x~12 ); 
true 

148 
11. Substitution and subexpressions 
11.13 Selecting suboperands 
Any level of components can be found with op. From release V.4 you can access 
suboperands with op directly. For instance 
> cos(x) + (3 -
5*x*sin(x-t))~2; 
cos(x) + (3 - 5x sin(x - t))2 
> op( [2,1,2,3] , % ); 
sin(x - t) 
The first argument of op may be a list of numbers. Here we select: 
- the second operand of the given expression: 
(3 - 5x sin(x - t))2 
- the first operand of this: 
3 - 5 x sin(x - t) 
- the second operand of this: 
-5 x sin(x - t) 
- the third operand of this: 
sin(x - t) 
11.14 Substituting something for one component of an 
expression 
If an operand of an expression is to be exchanged for something else without 
changing any other component, you can use subsop. For instance, 
> 3*x~2 + 5*x*y~3 -
4*x~2*y~2 + x~6*s*y; 
3 x2 + 5 x y3 - 4 x2 y2 + e x6 s y 
> subsop(3=WHOOPS, % ); 
3x2 + 5xy3 + WHOOPS + ex6 sy 
The previous command asks Maple to exchange the third component for WHOOPS. 
By an index list, you can replace suboperands as weB. The selection is the same 
as with op. For instance, in order to replace in the last term x 6 by a you can issue 
> subsop( [3,2]=a , % ); 
3x2 + 5xy3 + WHOOPS + easy 

chapter 12 
Manipulating and converting numbers 
In Chapter 2, Numbers and algebraic operators, some basic manipulations for 
numbers are discussed: expand, evalc, and simplify( 
,radical). The 
present chapter is a sequel to that chapter, discussing more specialized manipu-
lations. 
12.1 Real and imaginary parts of a complex number 
The procedure evalc converts a complex number to the form a + bI, where a and b 
are real numbers, supposing that alI variables concemed can be assumed to be real 
numbers. The same procedure can be used to take the real and imaginary parts of 
a complex expression separately as follows: 
> a + b*I; 
a+lb 
> evalc( Re(%) ); evalc( Im(%%) ); 
a 
b 
> (-3)~(1/4)*exp(a*I); 
(_3)(1/4) e(I a) 
> evalc( Re(%) ); evalc( Im(%%) ); 
1 
1 
- 3(1/4) V2 cos(a) - - 3(1/4) V2 sin(a) 
2 
2 
~ 3(1/4) V2 cos(a) + ~ 3(1/4) V2 sin(a) 
2 
2 
In the last calculation Maple assumes again that a is real. Remember: 
The procedure evalc assumes alI unassigned names to be real. 
E. Kamerich, A Guide to Maple
© Springer Science+Business Media New York 1999

150 
12. Manipulating and converting numbers 
12.2 Argument and absolute value of a complex number 
The absolute value and the argument of a complex number (=F O) can be searched 
for separately by the procedures abs and argument: 
> abs( I~(5/3) ); 
> argumente I~(5/3) ); 
1 
5 
-7r 
6 
Conversion to polar coordinates is accomplished by convert( ,polar): 
> convert( I~(5/3) , polar ); 
5 
polar(l, (3 7r) 
Conversion to standard complex notation is performed by evalc: 
> evalc( % ); 
1 
1 
--V3+-1 
2 
2 
A number given in standard complex form a+b* 1 can be conjugated by conjugate. 
Do not apply this procedure to objects that are not in this standard form, but then 
apply evalc first. 
> conjugate( evalc(I~(5/3)) ); 
1 
1 
--V3--1 
2 
2 
Ifyou don't apply evalc first, conjugate can go on strike: 
> conjugate( I~(5/3) ); 
conjugate (( -1) (5/6}) 
(In older releases, conjugate without evalc could yield wrong results.) 
12.3 The sign of a real or a complex number 
The procedure signum is the standard Maple test if a real number is positive or 
negative: it yields 1 for a positive number and -1 for a negative number. 
> signum(Pi - sqrt(10)); 
-1 
> signum(sqrt(10) - Pi); 
1 

12.4 Manipulating products and quotients of radicals 
151 
> signum(O); 
o 
Generally, if signum is applied to an expression that might be zero for some special 
values of the indeterminates, Maple ignores that possibility. For instance 
> signum(abs(x)). signum(-abs(x)); 
1, -1 
This looseness can be tightened by assigning a value to the special Maple variable 
--EnvsignumO or with an extra argument. For details on --EnvsignumO, see the 
on-line help to signum. 
The procedure signum can also be applied to complex numbers: signum(x) is de-
fined as 
. 
abs(x) 
slgnum(x) := 
. 
( ) 
conjugate x 
if x "1- O, and it is O if x = O. 
Don't confuse signum with sign: the last is defined as the sign ofthe leading co-
efficient of a polynomial with real coefficients. In some cases the results are the 
same, but in many others not. 
For complex numbers you can also use csgn, yielding 1, if Maple can ascertain 
that it lies in the right half-plane, and -1, if Maple knows that it lies in the left 
half-plane. 
12.4 Manipulating products and quotients of radicals 
Products and quotients of radicals can be combined with the procedure combine: 
> sqrt(10 - sqrt(7)) * sqrt(10 + sqrt(7)); 
VlO -..fi VlO +..fi 
> combine( % ); 
For quotients of radical expressions, you can use the procedure rationalize, which 
tries to remove radicals from the denominator. This procedure must be read from 
the library before it can be used. 

152 
12. Manipulating and converting numbers 
> (1+sqrt(3))/(2+sqrt(3)-sqrt(-5)); 
1 + V3 
2+V3-IV5 
> readlib(rationalize) (%); 
2~ (1 + v'3) (2 + v'3 + I v'5) ( -3 + v'3) 
> evalc(%); 
The last step can also be performed by expand. 
12.5 Nested radicals and roots of complex numbers 
A general tool for nested radicals (roots of expressions containing roots) is 
raduormal, which must be read from the Iibrary before it can be used: 
> readlib(radnormal); 
proc(expr,optsl) ... eud 
> sqrt( sqrt(2)+I*(-sqrt(3)-sqrt(6)) ); 
J 
V2 + I ( - v'3 - -/6) 
> radnormal(%); 
1 
1 
l+-V2--Iv'3V2 
2 
2 
In some special cases, a root of a complex uumber cannot be simplified in this 
way, but can be simplified by conversion to polar and back, where Maple can use 
trigonometric tricks. For example, let's simplify Jl + A. First, we manipu-
latel +A: 
> 1+sqrt(-5); 
> convert( % , polar); 
polar ( -/6, arctan ( v'5) ) 
Now take the square root of it and apply evalc: 
> sqrt(%); 
polar ( -/6, arctan ( v'5) ) 

12.6 An example: substituting expressions with radicals in polynomials 
153 
> evalc(%); 
Sometimes, it is necessary to combine both methods, starting with the last one and 
applying radnormal and/or rationalize afterward. 
The procedure radnormal can also be used with other roots than the square root. 
Here is an example: 
> ( a*(sqrt(2)-1)-3 ); 
> expand(%); 
5aV2-7a 
> root [3] (%) ; 
5aV2-7a 
( 
) (1/3) 
Before radnormal can come into action, the factor a must be isolated. For this 
purpose, we use simplify ( 
, power) twice: 
> simplify(%,power); 
(a (5 V2 _ 7) ) (1/3) 
> simplify(%,power); 
5 V2 - 7 
a(1/3) 
( 
) (1/3) 
Now radnormal can do its job: 
> radnormal(%); 
12.6 An example: substituting expressions with radicals in 
polynomials 
Expressions containing radicals and complex numbers often originate from solving 
polynomial equations. For instance, 

154 
12. Manipulating and converting numbers 
> equa := 2*x~3 -
3*x~2 - 12*x + 5 = O; 
equa := 2 x 3 - 3 x 2 - 12 x + 5 = O 
> solutions := solve( equa , x ); 
solutions := 
1 ( 
) (1/3) 
9 
1 
1 
2 3+ 121J5 
+ 2 
(1/3) + 2' 
(3+ 121 vis) 
- -
3 + 121 J5 
- -
+ - + 
1 ( 
) (1/3) 
9 
1 
1 
4 
4 (3 + 121 vis) (1/3) 
2 
1 
(1 ( 
) (1/3) 
9 
1 
) 
21 v'3 2 3 + 121 J5 
- 2 
(1/3) 
, 
(3+ 121 vis) 
- -
3 + 121 J5 
- -
+ - -
1 ( 
) (1/3) 
9 
1 
1 
4 
4 (3 + 121 vis) (1/3) 
2 
1 
(1 ( 
) (1/3) 
9 
1 
) 
21 v'3 2 3 + 121 J5 
- 2 
(1/3) 
(3+ 121 vis) 
Maple is fully reliable in solving such a polynomial equation, but we will check 
one of the solutions as a demonstration of more complicated manipulations with 
radicals. Let's substitute the first solution: 
> subs( x=solutions[1J , equa ); 
( 
)
3 
1 
(1/3) 
9 
1 
1 
2 2 (3 + 121 J5) 
+ 2 
(1/3) + 2 
(3+ 121 vis) 
)
2 
1 
(1/3) 
9 
1 
1 
3 (2 (3 + 121 J5) 
+ 2 
(1/3) + 2 
(3 + 121 vis) 
( 
) (1/3) 
1 
6 3 + 121 J5 
- 54 
(1/3) -
1 = 
(3 + 121 vis) 
O 
The first step in simplifying this is the same as you probably would do in a cal-
culation by hand: the powers and multiplications must be elaborated; this can be 
achieved with the procedure expand. Do not start with simplify. 
> expand( % ); 
3 
729 
1 
--+31J5+-
=0 
4 
4 3 + 121 vis 
The last expression can be handled weB by normal, by evalc, or by simplify. 

12.8 Rounding rational numbers to integers 
155 
Of these three, the most powerful tool for simplifying natural powers of radical 
expressions is the procedure simplify without options. In many other cases, the 
other two are to be preferred. See Chapter 15, Manipulating algebraic expressions. 
> simplify( % ); 
0=0 
The other two solutions can be checked in the same way. 
More about solving polynomial equations can be found in Chapter 14, Polynomial 
equations andfactoring polynomials. In section E.6 on page 305, you can find how 
you can check aII the candidate solutions at once. 
12.7 Converting ftoating-point numbers to rational numbers 
When an expres sion to be processed contains floating-point numbers, but nu-
merical algorithms should not be used, these numbers must be converted to 
rational numbers first by convert( ,rational) or convert( 
, rational, 
exact). 
> 0.3333333333333333*x - 0.34567; 
.3333333333333333 x - .34567 
> convert( % , rational, exact ); 
3333333333333333 
34567 
10000000000000000 x - 100000 
If the second option exact is omitted, Maple yields rational numbers that approx-
imate the given floating-point numbers, where the accuracy of these approxima-
tions is controlled by the value of Digits, which is 10 initially. 
> convert( %% , rational ); 
1 
14206 
"3 x - 41097 
This procedure can be applied on polynomials as weIl in order to convert floating-
point coefficients. 
12.8 Rounding rational numbers to integers 
Real numbers can be rounded to an integer by several procedures: trunc, round, 
floor, and ceil. The procedure round tries to yield the nearest integer: 
> round(sqrt(5)), round(sqrt(S)), round(-sqrt(S)); 
2,3, -3 
The procedure trunc yields the first integer that is encountered in the direction of 
zero: 

156 
12. Manipulating and converting numbers 
> trunc(sqrt(8», trunc(-sqrt(8»; 
2, - 2 
The procedures f100r and ceil do what their names suggest: 
> floor(sqrt(8», floor(-sqrt(8»; 
2, -3 
> ceil(sqrt(8», ceil(-sqrt(8»; 
3, -2 
Moreover a fractional part can be calculated by frac: 
> frac(37/8) , frac(sqrt(8»; 
5 -
2\1'2-2 
8' 
where frac (x) + trunc (x) = x. 

chapter 13 
Polynomials and rational expressions 
This chapter deals with elementary aspects of handling polynomials: the use of 
arithmetic operations, extracting a coefficient, calculating greatest common divi-
sors and resultants, etc., and also with handling rational expressions. 
13.1 Polynomials and the standard arithmetic operators 
For calculations with polynomials and quotients of polynomials, the arithmetic 
operators +, -, *, / ,and A can be used. Generally, multiplications and exponen-
tiations of polynomials, consisting of more than one term, are not worked out au-
tomatically. For instance, 
> (z-1)/2*z + (y+a)-2; 
1 
2 
2" (z - 1) z + (y + a) 
Maple leaves the choice to the user: you can keep such an expression as it is or 
manipulate it into some other form. Here you can ask to expand the products and 
powers over the sums with the procedure expand: 
> expand( % ); 
1 
1 
-
Z2 __ z + y2 + 2 y a + a2 
2 
2 
When using expand on expressions containing radicals and/or function calls, be-
ware of possibly unwanted side effects. See section 15.6 on page 196 and section 
15.7 on page 198 for restrictions in the use of expand for such cases and the meth-
ods to be used in such a case. 
If one or more fac tors of a product should not be expanded over the other fac tors, 
the fac tors to be kept intact must be given as extra arguments: 
> 10*(a-b)*(c+1)*(x+1)-2; 
10 (a - b) (c + 1) (x + 1)2 
> expand( % , a-b , c+1 ); 
10 (a - b) (c + 1) x 2 + 20 (a - b) (c + 1) x + 10 (a - b) (c + 1) 
The opposite procedure of expand for polynomials is factor, Maple's powerful 
procedure for factorization, which is discussed in section 14.6 on page 177, to-
gether with its variants. 
E. Kamerich, A Guide to Maple
© Springer Science+Business Media New York 1999

158 
13. Polynomials and rational expressions 
Automatic simplification of products and quotients of polynomials is restricted to 
some simple cases; in alI other cases the user is in command: 
> x~3 * 2*x~4 / 
x~5 + 8*(x-1); 
2x2 + 8x - 8 
Maple can handle very large polynomials with up to 65,535 terms, but if it finds 
too many terms in a polynomial, possibly as an intermediate result in a calculation, 
it gives a message that the object is too large, for instance here, where we try to 
calculate the product of two polynomials, each containing 256 terms: 
> expand(sum('x.i',i=1 .. 256)*sum('y.i',i=1 .. 256)): 
Error, object too large 
13.2 Division of polynomials with a remainder 
Division with a remainder is supplied by quo, to be compared with iquo for inte-
gers. Let's divide 3x5 by x 2 - a as polynomials in x: 
> quo( 3*x~5 , x~2-a , x ); 
3xa + 3x3 
The remainder can be found by appending a name as a fourth argument: 
> quo( 3*x~5 , x~2-a , x , 'r1' ); 
3xa + 3x3 
> r1; 
In the first command the forward quotes around r1 are superfluous as r1 is not 
assigned to previously, but generally it is wise to use these forward quotes for an 
argument that is assigned to by the procedure quo, in order to make sure that this 
argument cannot be evaluated before it is used by the procedure. This is explained 
for iquo in section 5.4 on page 67. 
As a demonstration, we calculate the original polynomial from both results: 
> expand(%%*(x~2-a)+r1); 
There is another procedure rem that calculates the remainder of the division and 
assigns the quotient to an optional fourth argument. 

13.3 The greatest common divisor and the least common multiple 
159 
. 13.3 The greatest common divisor and the least common multiple 
The greatest common divisor of two polynomials can be calculated with gcd or 
gcdex. We apply these to the polynomials pl and p2 created here by expand, so 
that you can predict the result immediately: 
> pl := expand( (x-3) * (x-a) * (x~3+l) ); 
p1 := x 5 + x 2 - x 4 a - x a - 3 x 4 - 3 x + 3 x 3 a + 3 a 
> p2 := expand( (x-3)~2 * (2*x-3*a) ); 
p2 := 2 x3 - 3 x 2 a - 12 x 2 + 18 x a + 18 x - 27 a 
> gcd( pl , p2 ); 
x-3 
Here no specification that pl and p2 are to be perceived as polynomials in x is 
expected; gcd can be applied to polynomials in more than one variable. In fact, 
Maple perceives p2 as a polynomial in a and x, not being brainwashed about some 
special quality of the character x. 
You might be tempted to teU Maple that the arguments to gcd are polynomials in 
x, but supplying x as a third argument generates an error: 
> gCd(pl,p2,x); 
Error. The optional 3rd argument given to 'gcd' was x 
This argument to 'gcd' is for returning the cofactor. 
It is not for specifying the variable in which to compute the GCD. 
If assigned. it could create a recursive definition of a name. 
In fact, Maple has no need for the knowledge that you see pl and p2 as polynomi-
als in x. If gcd gets a third and a fourth argument, it tries to assign the cofactors 
p1/gcd(pl,p2) and p2/gcd(pl,p2) to them. 
If Maple would have assigned the cofactor pl/ gcd (pl, p2) to x, this would gen-
erate a recursive referrence; see section 3.10 on page 41. However, Maple sees 
that x is a variable occurring in pl and p2 and prevents the assignment (not before 
release V.4). 
In many applications of the greatest common divisor, its main theorem can be used: 
if Pl and P2 are polynomials and if dis the gcd of these two polynomials, there exist 
polynomials ql and q2 such that qlPl + q2P2 = d. These polynomials ql and q2 
can be calculated with gcdex. Contrary to gcd, gcdex wants to know in which of 
the variables the gcd is to be calculated; in this case, we must give x as the third 
argument to gcdex. The fourth and fifth arguments must be names to which the 
calculated polynomials q 1 and q2 are to be assigned: 
> gcdex(pl, p2, x, 'ql', 'q2')j 
x-3 

160 
> ql; 
~ (224 + 36a + 18a2 + ga3 ) x 
14 a(8a - 24 - 81a3 + 27a4 ) 
13. Polynomials and rational expressions 
1 1344+27a4 +54a3 +108a2 +224a 
28 
a(8a-24-81a3 +27a4 ) 
As ademonstration, we check thatgcd(p1,p2) = q1p1 + q2p2: 
> normale expand( ql * pl + q2 * p2 ) ); 
x-3 
The use of expand and normal for the above type of simplification is discussed 
in section 13.8 on page 166. 
The procedure lem computes the least common multiple of its arguments, where 
these can be any number. 
13.4 The resultant oftwo polynomials 
The resultant of the two polynomials pl and p2 from the previous section is zero, 
as their gcd is not 1. It can be calculated with resultant: 
> resultant( pl , p2 , x ); 
o 
Here is one more example. 
> resultant( pl+l , p2 , x ); 
-81 a5 + 162a4 - 24a2 + 48a - 32 
The bezout matrix can be created with the procedure linalg [bezout] , the dis-
eriminant with discrim. 
Another important concept in calculations with polynomials is the Grobner basis 
together with the Buchberger algorithm for calculating such a basis. This can be 
very helpful, especially in solving systems of polynomial equations. This subject 
is discussed in section 14.9 on page 180. 

13.5 The coefficients of a polynomial 
161 
13.5 The coefficients of a polynomial 
You can ask Maple to describe a polynomial in several variables as a polynomial 
in one of these variables with the aid of 
collect: 
> ,pol := a~2*x~2*y+y~2*a-2*b*x*y-b~2*x~2*y+b*x*y~2+ 
> 
c*y~2+3*x*y~2-6*x*y; 
pol := a2 x2 y + y2 a - 2 b x y - b2 x2 y + b x y2 + c y2 + 3 x y2 - 6 x y 
This is made into a polynomial in x with: 
> collect( % , x ); 
(a2 y _ b2 y) x2 + (b y2 - 2 b y - 6 y + 3 y2) X + y2 a + c y2 
It is also possible to have Maple perceive an expression as a polynomial in two or 
more given variables: 
> collect( pol, [x,y] , distributed ); 
(a2 - b2) y x2 + (3 + b) x y2 + (-2 b - 6) x y + (a + c) y2 
Without the option distributed, the result is a polynomial in x where the coef-
ficients are polynomials in y: 
> collect( pol, [x,y] ); 
(a2 - b2) y x2 + ((3 + b) y2 + (-2 b - 6) y)x + (a + c) y2 
A nice facility within collect is the ability to process the coefficients of the result 
with a procedure or function given as an extra argument, without forward quotes: 
> collect( pol, x , factor ); 
y (a - b) (a + b) x2 + y (y - 2) (3 + b) x + (a + c) y2 
Coefficients of a polynomial can be selected with the procedure coeff. For in-
stance, the coefficient of x 2 in the previous polynomial can be achieved by 
> coeff( pol, x , 2 ); 
The degree of a polynomial can be ca1culated with degree: 
> degree( pol, x ); 
2 
> degree( pol, [x,y] ); 
3 

162 
13. Polynomials and rational expressions 
It is essential for this procedure that the polynomial be given in either collected or 
expanded form. Otherwise, Maple does not accept it, or it might yield incorrect 
resuIts: 
> (x-3)~2 -
x~2; 
> degree( % , x ); 
2 
The correct degree is found if the polynomial is expanded before degree comes 
into action: 
> degree( expand(%%) , x ); 
1 
The same is true for some other procedures, for example tcoeff, which tries to 
compute the coefficient of the lowest-degree monomial: 
> (x-3)~2-9; 
(x - 3)2 - 9 
> tcoeff(%); 
o 
> tcoeff( expand(%%) ); 
-6 
The procedures lcoeff, tcoeff, 
degree, ldegree, content, and norm 
must only be applied to polynomials in expanded or collected form. 
In releases before V.5 the same is true for the procedure coeff. 
• Icoeff: yields the coefficient of the monomial corresponding to the degree of 
the polynomial 
• ldegree: yields the lowest degree 
• tcoeff: yields the trailing coefficient: the coefficient of the monomial corre-
sponding to the lowest degree of the polynomial 
• content: yields the greatest common divisor of the coefficients of a polyno-
mial in one or more variables 

13.6 Truncating a polynomial above some degree 
163 
• norm: the n-nonn of the coefticients of an expanded polynomial p in x can 
be caIculated with norm (p , n, x) 
13.6 Truncating a polynomial above some degree 
Here are three ways for truncating a polynomial above some degree. Consider the 
following polynomial 
> pol := sume 2-(-i)*t-i , i=O .. 18 ); 
1121314151617 
pol := 1 + 2" t+ 4 t + 8" t + 16 t + 32 t + 64 t + 128 t + 
1 
8 
1 
9 
1 
10 
1 
11 
1 
12 
256 t + 512 t + 1024 t + 2048 t + 4096 t + 
1 
13 
1 
14 
1 
15 
1 
16 
8192 t 
+ 16384 t 
+ 32768 t 
+ 65536 t 
+ 
1 
17 
1 
18 
131072 t + 262144 t 
This can be truncated above degree 7 as follows. First, apply series to the order 
8: 
> series( pol, t , 8 ); 
111111 
1 
1 + -t + _t2 + _t3 + _t4 + _t5 + _t6 + -e + O(t8 ) 
2 
4 
8 
16 
32 
64 
128 
Then convert the resuIt into a polynomial: 
> convert(%,polynom); 
1121314151617 
l+-t+-t +-t +-t +-t +-t +-t 
2 
4 
8 
16 
32 
64 
128 
It is also possible to realize the same result with the aid of simplifying according 
to side relations (see section 11.11 on page 147) as follows: 
> simplify( pol, {t-8=O} ); 
1121314151617 
1 + 2" t + 4 t + 8" t + 16 t + 32 t + 64 t + 128 t 
As an alternative, you can apply select. See section 10.6 on page 131. The sec-
ond argument is the polynomial that should be truncated, the tirst argument is a 
procedure that tests each tenn for whether its degree is lower than 8. This yields 
the same result: 
> selecte polyterm->degree(polyterm,t)<8 , pol ); 
1 + ~ t + ~ t2 + ~ t3 + ~ t4 + ~ t5 + ~ t6 + _1_ t7 
2 
4 
8 
16 
32 
64 
128 

164 
13. Polynomials and rational expressions 
13.7 Sorting a polynomial 
When the order is not essential in mathematical sense, results are often printed in 
an order based on the order in which subexpressions are stored in the computer 
memory. This is also the case with polynomials. For instance, 
> pol := a~5*x*y+y~2*a-b~2*x~2*y+b*x*y~2-y*x~2+ 
> 
x~2*y~2-y~2*c+3*x*y~2; 
pol : = a5 x y + y2 a - b2 x2 y + b x y2 - Y x2 + x2 y2 - y2 C + 3 x y2 
The product is printed as y2 a, in a different order than it has been entered. Maple 
takes the printing order according to the order in which expressions are stored in 
the computer memory, and obviously y2 precedes a in the present session. In the 
same way, we can see that the expression y2 a is the second of the components of 
pol in the computer memory order. 
Readability of a polynomial can be improved sometimes by changing the order of 
factors and terms. This is possible with the procedure sort. Let's sort pol as a 
polynomial in x and y: 
> sort( pol, [x,y] ); 
x 2 y2 _ x2 Y _ b2 x2 y + b x y2 + 3 x y2 + a5 x y + a y2 -
C y2 
Or you can apply collect first: 
> collect( pol, [x,y] , distributed ); 
a5 xy + (3 + b)xy2 + x2 y2 + (_b2 -1) x2y + (a - C)y2 
> sort( % , [x,y] ); 
x2 y2 + (_ b2 _ 1) x2 y + (3 + b) x y2 + a5 x y + (a - c) y2 
The procedure sort changes the order of subexpressions in the memory. There-
fore, pol is printed differently from the way it was printed before sort was ap-
plied: 
> pol; 
x2 y2 _ x2 Y _ b2 x2 y + b x y2 + 3 x y2 + a5 x y + a y2 -
C y2 
By applying sort on pol, we have ordered its subexpressions in the memory as 
well: 
> y~2*a; 

13.8 Simplifying rational expressions 
165 
But the execution of sort (pol, [x, y]) does not enforce a standard order for alI 
polynomials in x and y. For instance, 
> y~10*a*x~20 + b*y*x~30j 
ylO a x 20 + b Y x30 
13.8 Simplifying rational expressions 
Rational numbers are simplified automatically by calculating the greatest common 
divisor of numerator and denominator and dividing this out. That is not the case 
with rational expressions: only fac tors that are "seen" by Maple directly are di-
vided out automatically: 
> expand(x*(x-a)~2)j expand(x*(x-a)*(x+a))j 
> %%/%j 
x 3 -
2 x 2 a + x a2 
x 3 - 2 x2 a + x a2 
x 3 - xa2 
The procedure normal divides out the greatest common divisor. Clearly, this pro-
ce dure does not bother about the possibility that such a factor might be zero for 
some set of values for the variables: that is the mathematical responsibility of the 
user. 
It is not a good idea to use simplify for such a job as, generalIy, this procedure tries 
to do more, perhaps unwanted, simplifications, and takes more time: 
> normal( % ) 
j 
-x+a 
x+a 
The same result could have been found with the procedure factor, but factoriza-
tion is much more complicated and time-consuming than calculating the greatest 
common divisor of two polynomials. 
The procedure normal can also convert a sum of quotients into one quotient: 
> 1/(x~2-3*x) - x + 1/(x~2-9)j 
> normale % ) 
1 
1 
----::----x+--
x 2 - 3x 
x 2 - 9 
x 4 -
9 x 2 -
2 x - 3 
(x 2 -9)x 

166 
13. Polynomials and rational expressions 
Here the denominator is a product of polynomials. If you don 't want this, caB nor-
mal with a second argument expanded: 
> normale %% , expanded) j 
- x4 + 9 x2 + 2 x + 3 
x 3 -9x 
The counterpart of normal is expand in this case. It is easy to see what expand 
does with a quotient by looking at the Maple structure of such a quotient: 
> (x~2-b*x*y+c*y~2)/(a-c)j 
> op( % )j 
x 2 - bxy + cy2 
a-c 
Maple perceives the previous expression as the product of two factors: the numer-
ator and (a - c) -1. So expand yields the sum of the products of (a - c) -1 with 
the terms of the first component: 
> expand( %% )j 
x2 
bxy 
cy2 
-----+--
a-c a-c a-c 
In the next example we expand the coefficient -5/8 ofthe quotient over the terms 
of the numerator with combine: 
> -5*(x+y)/(8*(x-2)*(y-l))j combine(%)j 
5 
x+y 
8 (x - 2) (y - 1) 
-l x -l y 
(y - 1) (x - 2) 
13.9 Numerator and denominator 
In the previous section, the procedure op has been used in finding the subexpres-
sions of a quotient. This way of breaking down a quotient is not always efficient. 
Closer to the usual way of looking at quotients are the procedures numer and de-
nom: 
> 5*(x+y)/(8*(x-2)*(y-l))j 
5 
x+y 
8 (x - 2)(y - 1) 
> numere % )j 

13.11 Reliability 
167 
5x +5y 
> denom( %% ); 
8 (x - 2) (y - 1) 
You can use these two procedures when you want to manipulate the denominator 
or the numerator separately. For example: 
> (x~3 -
4*x~2 + 7*x -12)/(x~2 + 7*x + 10); 
x3 - 4 x 2 + 7 x - 12 
x 2 + 7x + 10 
> numer(%) / factor(denom(%)); 
13.10 More tools 
Maple supplies 
x3 - 4x2 + 7 x - 12 
(x + 5) (x + 2) 
• conversion of a rational expression to a truncated continued fraction by the 
procedure convert ( 
, confrac , x) , useful for numeric al calculations; 
• partial fraction decomposition by convert ( 
, parfrac, x) and 
convert ( 
, fullparfrac, x); see also section 9.2 on page 119. 
• calculation of an interpol ating polynomial function, the graph of which 
contains a given sequence of points, with interp. 
13.11 Reliability 
Apart from the fact that sometimes the user must expand or collect a polynomial 
before it can be manipulated, as shown in section 13.5 on page 162, in principle 
there are no reliability problems in calculations on polynomials and quotients of 
rational functions in Maple. 

chapter 14 
Polynomial equations and 
factoring polynomials 
Solving polynomial equations and systems of polynomial equations is a classical 
type of problem. lts study received new impetus from the fact that computers can 
now handle laborious algorithms, usingfactorization, resultants, and the more re-
cent Buchberger algorithm for calculating Grobner bases. Maple is in the front 
line of using these developments. This chapter discusses Maple's powerful tools 
in this field, as well as the related subject of symbolic roots of polynomials. 
When solving equations with parameters, remember that these parameters are in-
terpreted as abstract items; solutions are to be interpreted as "general solutions". 
lf special values for these parameters are substituted, the solution might be no 
longer valid for this case; see for an example section 1.3 on page 6. 
14.1 Solving polynomial equations symbolically 
Maple uses several tricks for solving polynomial equations. Obviously, it knows 
the standard algorithms for tirst-, second-, third-, and fourth-degree polynomials. 
No general algorithms for degrees higher than four can be constructed, yet solve 
can often tind a solution of a polynomial equation of higher degree. Here is an 
example: 
> x~5+x~4+1=O; 
> solve( % , x ); 
1 
1 
1 
1 
1 
1 
--+-1 '3 ----IV3 -- %1{1/3)-2-::-:-"""777= 
2 
2 V.J, 
2 
2 
'6 
%1(1/3)' 
1 
(1/3) 
1 
12 %1 
+ %1(1/3) + 
1 t;:; ( 1 
(J-f (1/3) 
1) 
"2 Iv3 -6 101 
+2 %1(1/3) 
, 
1 
(1/3) 
1 
12 %1 
+ %1(1/3) 
1 
t;:; (1 
(1/3) 
1) 
"2 Iv3 -6 %1 
+2 %1(1/3) 
%1 := 108 + 12 v'69 
E. Kamerich, A Guide to Maple
© Springer Science+Business Media New York 1999

14.1 Solving polynomial equations symbolically 
169 
We obtain five solutions, expressed with the aid of the abbreviation % 1. The pro-
cedure sol ve handles this equation with the aid of factorization of x 5 + x 4 + 1 
over the rational numbers. 
> factor( x~5+x~4+1 ); 
(x2 + x + l) (x3 - x + l) 
Another trick is decornposition of polynornials, available by the procedure corn· 
poly. When Maple solves the equation, 
x6 + 2x4 + 2x3 + x 2 + 2x + 2 = O 
it does so by creating a decomposition of the left-hand side: it finds that the left-
hand side can be described as 1 + t2 , where t = 1 + x + x 3 • 
In spite of alI the tricks of Maple, it is inevitable that solving fails for most high-
degree polynomials. If Maple cannot find an explicit sequence of alI exact solu-
tions, a symbolic representation of the intennediate result emerges, using a special 
Maple construction, RootOf expressions. 
> x~7+11*x~6+12*x~5+10*x~3-11*x~2-41*x~4-13*x+33; 
x7 + llx6 + l2x5 + lOx3 -l1x2 - 4lx4 -l3x + 33 
> solve( % , x ); 
-4 + 3 v'3, -4 - 3 v'3, RootOfLZ5 + 3_Z4 - _Z3 - _Z - 3) 
First, sol ve factors the given polynomial into a product of polynomials with ra-
tional coefficients. Then each factor is dealt with by sol ve. As there are no gen-
eral algorithms for solving a fifth-degree polynomial equation and Maple's special 
tricks are not successful here, Maple yields 
RootOf(_Z~5 + 3*_Z~4 -
_Z~3 -
_Z - 3) 
as a part of the solution. This is a symbolic representation of the set of five roots 
of the equation 
In order to avoid the complicated results of solving irreducible fourth-degree equa-
tions, these solutions are represented with RootOf expressions as weB, unless the 
variable ..EnvExplicit is set to the value true. 
If sol ve handles a polynomial equation, it renders each solution as many times as 
its multiplicity. 
The results of solving polynomial equations found with sol ve are reliable. (In 
releases before V.4, there is an exception: if an equation contains floating-point 
numbers, the set of solutions may be incomplete.) 

170 
14. Polynomial equations and factoring polynomials 
Maple offers the procedures sturmseq and sturm based on the Sturm theorem, 
conceming real roots, and the procedure realroots for calculating isolating in-
tervals of real roots. 
14.2 Solving modest systems of polynomial equations 
Here is an example: calculating the intersection points of two circles. 
> circlel := x~2 + y~2 = 2*x + 8*y + 25; 
circlel := x2 + y2 = 2x + 8y + 25 
> circle2 := x~2 + y~2 = 6*x - 4*y + 40; 
circle2 := x2 + y2 = 6 x - 4 y + 40 
Let's draw graphs in order to "see" the solutions beforehand: 
> plots[implicitplot] (circlel,x=-7 .. 12,y=-10 .. 12): 
> plots[implicitplot](circle2,x=-7 .. 12,y=-10 .. 12): 
> plots[display]( {%,%%}, scaling=CONSTRAINED ); 
2 
A system of equations to be solved should be entered tied together in a set; the 
variables must be entered as a set, too. 
> solve( {circlel,circle2} , {x,y} ); 

14.2 Solving modest systems of polynomial equations 
171 
{Y = ~ RootOf(-55 + 1O_Z2 -146_Z) , 
3 
15 } 
x = 4 RootOf(-55 + 1O_Z2 -146_Z) -"4 
Here the solution is given as a set of two equations with the aid of a RootOf expres-
sion. The use of RootOf is a compact and well-ordered way of representing the 
solution; Maple has no difficu1ty in finding a more explicit solution, but leaves the 
choice to the user. We can substitute al1 possible values for this RootOf expression 
with allvalues. 
> allvalues( % ); 
{ 
73 
1 
69 
3 
} 
Y = 40 + 40 v'5879, x = 40 + 40 v'5879 
, 
{ 
73 
1 
69 
3 
} 
Y = 40 - 40 v'5879, x = 40 - 40 v'5879 
We see a sequence of two sets, each representing a solution. General1y, the pro-
cedure aH values substitutes the same value in each occurrence of that RootOf 
expres sion, so it generates two values here. This behavior of aH values (from 
release V.4) yields al1 solutions, if the equal RootOf expressions are dependent, 
which can be the case mostly. However, it is possible that two equal RootOf ex-
pressions must be handled independently from each other. Obviously, this is the 
case when a system can be split into two subsystems, for instance. Here is an ob-
vious example: 
> {x~2-3*x=20,y~2-3*y=20}; 
{ x2 - 3 x = 20, y2 - 3 y = 20 } 
> eqs:=%: solve(eqs,{x,y}); 
{ x = RootOfCZ2 - 3_Z - 20) , y = RootOfCZ2 - 3_Z - 20) } 
> aHvalues(%); 
{ x = ~ + ~ v'89, y = ~ + ~ v'89 } , 
{ y=~-~v'89 x=~-~v'89} 
22' 
2 
2 
We obtain only two of the four solutions. In this case, we would have to add the op-
tion independent. In more complicated cases, for instance with nested RootOf 
expressions, alI val ues may handle equal RootOf expressions independently. In 
such cases, checking solutions is a must. 
(For earlier releases than V.4, independent treatment ofRootOfs is the default and 
the other behavior can be ordered by the option 'd'.) 
> allvalues(%%,independent); 

172 
14. Polynomial equations and factoring polynomials 
{x = %2, y = %2}, {y = %1, x = %2}, 
{x= %l,y= %2},{y= %l,x= %1} 
3 
1 
%1 := 2 - 2 v'89 
3 
1 
%2 := - + - v'89 
2 
2 
If you are not sure that all values generates alI values, use the option indepen-
dent and check each item. Checking is never a bad habit! In the present case you 
can check each value as folIows: 
> sols:=%: 
> subs(sols[l],eqs); 
{ (~+ ~ v'89 r -~ -~ v'89 = 20 } 
> expand(%); 
{20 = 20} 
and so ono The section E.6 on page 305 shows an example where the work is done 
with more comfort by appIying a Ioop. 
It is wise to check solutions anyhow: solving systems of equations is a com-
plicated process and allvalues might have neglected the equivalence of two 
RootOf expressions. 
If sol ve handIes a set of polynomial equations, it renders each solution as many 
times as its multiplicity (from release V.4). 
Often the mistake of entering in sol ve fewer variables than necessary is made. 
Suppose you are interested only in the possible values of X. Then you might be 
tempted to enter: 
> solve( {circlel,circle2} , x ); 
This does not yield a solution, because the system of equations is satisfied for no 
values of x unless y has a matching value. 
For solving systems of linear equations, the specific facilities described in section 
18.10 on page 257, are useful. 
For stepwise elimination, use eliminate. For instance: 
> eliminate( {circlel,circle2} , x ); 
A contrary procedure is algcurves [parameterization] , which can calculate 
a parameterization for a two-dimensional curve, implicitly defined by an irre-
ducible polynomial in two variables, if the genus of this curve is O (check irre-
ducibility with AFactor and genus with algcurves [genus] ). 

14.3 Finding or approximating the elements represented by a RootOf expression 
173 
14.3 Finding or approximating the elements represented by a 
RootOf expres sion 
In the previous sections you can see that Maple of ten uses a symbolic Rootaf rep-
resentation of the solutions of a polynomial equation instead of the actual sequence 
of solutions. Such a Rootaf expression can be created explicitly by the procedure 
RootOf. 
> 5*x-2 = 30*x + 10 
5x2 = 30x + 10 
> Rl .- Rootaf( % , x ); 
R1 := RootOfCZ2 - 6_Z - 2) 
The default variable for Rootaf is _Z, so, in the last result, Maple omits the second 
argument of Rootaf. Moreover, "= O" is omitted and only the left-hand side of 
the equation is given. 
Here Maple can find the roots in an explicit form. You can ask for them with the 
procedure a1lvalues, described in the previous section, possibly with the option 
independent for handling equal Rootaf expressions within an expression or a 
lisUset of expressions separately. 
> allvalues(Rl); 
3 + /il, 3 - /il 
IfMaple cannot find the sequence of explicit roots exactly, approximations are cal-
culated. 
> Rootaf( x-6 + 6*x-5 + 2 ); 
RootOfCZ6 + 6_Z5 + 2) 
> allvalues( % ); 
-5.999742743, - .8269055711, - .2289757797 -.7744287008 I, 
- .2289757797 +.7744287008 I, .6422999369-.4534117425 I, 
.6422999369 + .4534117425 I 
The procedure evalf can be applied directly to a Rootaf expression, but this pro-
duces an approximation of only one of the implied roots. 
> evalf( Rl ); 
-.3166247904 

174 
14. Polynomial equations and factoring polynomials 
Do not apply evalf to an expression 
containing a RootOf subexpression 
unless you are content with an approximation of 
only one of its values. 
You can get a list of approximations in the following way: apply al! values, then 
apply evalf to the list of the results. For instance, 
> evalf( [ allvalues(Rl) ] ); 
[6.316624790, -.316624790] 
14.4 Calculating with RootOf expressions 
Maple can handle RootOf expressions in algebraic calculations. 
> eq:= x-5-t*x-2+p=O; 
eq := x 5 -
t x 2 + p = O 
> RootOf( % , x ); 
RootOf{_Z5 - t_Z2 + p) 
RootOfCZ5 - t _Z2 + p) 7 
> simplify(%,RootOf); 
RootOfCZ5 - t_Z2 + p)4 t _ RootOfCZ5 _ t_Z2 + p)2 p 
Instead of simplify ( 
, RootOf) we could have used evala, discussed in sec-
tion 14.10 on page 183. A different approach can be found in section 11.11 on page 
147. 
In order to obtain more compact results in such calculations, we can abbreviate this 
RootOf expression with an alias. See section B.I on page 285. 
> alias( RO = RootOf(eq,x) ); 
1, RO 
The result of an alias command is a sequence of all aliases known to Maple at 
that moment. 

14.5 RootOf expressions versus radica1s 
175 
From now on, Maple prints RO instead of RootOf( _Z5 - LZ2 +p) and recognizes 
RO in the input. You should remember its definition, as it is not possible to find the 
internal interpretation of such an alias easily. 
Now we can use RO in calculations such as: 
> simplify( RO~7 ); 
14.5 RootOf expressions versus radicals 
A radical can be converted to a RootOf expression by convert( ,RootOf): 
> 5~(1/3); convert(%,RootOf); 
5(1/3) 
> a~2 -
2~(1/3)*b~(1/6); convert(%,RootOf); 
a2 _ 2(1/3) b(1/6) 
Sometimes it helps Maple if the user applies this conversion. For instance, see 
section 4.8 on page 51, and section 14.10 on page 183. 
Maple prefers ca1culating with RootOf expressions 
above using radicals. 
Conversion the other way is available with convert( ,radical): 
> convert(%,radical); 
a2 _ 2(1/3) b(1/6) 
Observe the difference with allvalues: a RootOf expression is essentially a mul-
tivalued expression; all values can be achieved with alI values, while convert 
( 
,radical) picks up only one, so you might Iose solutions. 
Of ten, RootOf expressions cannot be converted to radicals. 

176 
14. Polynomial equations and factoring polynomials 
> RootOf(x-7+x+2,x); convert(%,radical); 
RootOfLZ7 + _Z + 2) 
RootOfLZ7 + _Z + 2) 
14.6 Factoring with the procedure factor 
Maple has a fast and powerful factorization facility, used frequently in various al-
gorithms. It is called with the procedure factor. 
> (8*x-5-6*x-4-78*x-3+72*x-2+190*x-210)/(x-2-49); 
8x5 - 6x4 - 78x3 + 72x2 + 190x - 210 
> factor( % ); 
x 2 - 49 
2 -'-.( 4_x_-_7 __ 
)....:...( x_2_-_5,:-) ....:....( x_2-:-+_x_-_3-,-) 
(x - 7) (x + 7) 
The resulting factors are irreducible over Q, that is, each ofthem cannot be factored 
into a true product of polynomials of degrees > 1 with coefficients in Q. We can 
factor x 2 - 5 into (x - v'5)(x+ v'5) and x 2 + x - 3 into (x + 1/2 + 1/2V13) (x + 
1/2 - 1/2V13), but both cannot be factored over Q, so the procedure factor 
leaves these polynomials unfactored. 
Here is another example, where factor is surprisingly successful: 
> (a-2 - sqrt(5))-3; 
> expand(%); factor(%); 
a6 - 3 a4 J5 + 15 a2 - 5 J5 
As you can see, factor can use v'5 here. This is because it occurs in the given 
argument. But factor does not introduce 51/ 4 . However, in section 14.10 on page 
183 you wiIl see that we can tell factor to use roots ofpolynomial equations. 
The procedure factor can handle polynomials in more than one variable equally 
well, and does so quickly. 
> 192*c-6*u-4*t-4 + 64*c-4*u-2*t-2 + 168*c-5*u-6*t-2 + 
> 56*c-3*u-4 -
120*c-5*u-5*t-3 - 40*c-3*u-3*t -
> 480*c-4*t-7*u-2 - 160*c-2*t-5 - 420*c-3*t-5*u-4 -

14.7 More tools for factoring 
> 140*c*t~3*u~2 + 588*c~3*t~6*u~3 + 196*c*t~4*u -
> 768*u~6*t~4*c~3 -
256*u~4*t~2*c -
672*u~8*t~2*c~2 -
> 224*u~6 + 480*u~7*t~3*c~2 + 160*u~5*t + 
> 252*t~4*u~5*c~2 + 84*t~2*u~3 -
180*t~5*u~4*c~2 
> -
60*t~3*u~2: 
> factor( % ); 
-4 (8e c + 7u2 - 5ut) (3u 2 e c2 + 1) 
(5ct3 - 3t2 U - 2u2 c3 + 8u4 ) 
Again the resuIting fac tors are irreducible over Q. 
177 
There exists another procedure, factors, that is almost the same as factor, but 
yields the factors in an alternative form. 
14.7 More tools for factoring 
If necessary, Maple can try to factor a polynomial in one variable into a product of 
linear fac tors with the procedure spUt, which must be loaded first with readlib. 
Let's apply this to the denominator of the first example of the previous section: 
> 8*x~5-6*x~4-78*x~3+72*x~2+190*x-210; 
8x5 - 6x4 - 78x3 + 72x2 + 190x - 210 
> readlib(split) ( % , x ); 
8 (x + RoOtOfCZ2 - 5)) (x - RootOfCZ2 + _Z - 3)) 
(x + 1 + RootOfCZ2 + _Z - 3)) 
7 
(x - 4) (x - RootOfCZ2 - 5)) 
As you can see, we obtain five linear fac tors instead of the three factors found with 
factor. However, this procedure spli t is very time-consuming and can only be 
applied to expressions perceived as polynomials in one variable. As in many other 
procedures, spli t can work much more efficient1y with RootOf expressions than 
radicals, so it may be necessary to apply convert ( 
,RootOf) before this pro-
cedure is caUed. 
You might wonder about the factor x + 1 + RootOf <-Z2 + _Z - 3) in the re-
suIt, but keep in mind that aU the occurrences ofRootOf <-Z2 + _Z - 3) should 
be interpreted equaUy; in this case, if Xl is one of the roots of x 2 + x - 3, then the 
otherequals -1 -
Xl, so we get x 2 + x - 3 = (x + 1 + xt}(x - xt}. 
If you don't like reading expressions containing RootOfs, try converting to radi-
caIs with convert( ,radical): 

178 
14. Polynomial equations and factoring polynomials 
> convert( % , radical ); 
8 (x + v'5) (x + ~ - ~ v'13) (x + ~ + ~ v'13) (x - ~) (x - v'5) 
(In releases before V.4, convert ( 
,radical) could not do this job; then you 
could use all values, but you would see the desired result four times.) 
The procedure spli t can handle only polynomials in one variable, but it can use 
indetinite coefticients: 
> x-2 - 2*y-4 - 4*y-2 - 2; 
x2 _ 2 y4 _ 4 y2 - 2 
> split( % , x ); 
(x + RootOfCZ2 - 2 y4 - 4 y2 - 2)) 
(x - RootOfCZ2 - 2 y4 - 4 y2 - 2)) 
Moreover, squarefree factorization is available with the very fast procedure 
convert ( 
,sqrfree) and the procedure sqrfree. In fact, this is used by 
factor for its initial rough work. 
14.8 Solving with numeric al tools 
If you apply fsolve to a polynomial equation, generally you will tind all real roots 
in numerical approximation: 
> expand( (x-2-2*x-5)*(x-2-2*x+5) ); 
x4 - 4 x3 + 4 x2 - 25 
> fsolve( %=0 , x ); 
-1.449489743, 3.449489743 
If you want all complex roots, add the option complex: 
> fsolve( %%=0 , x , complex ); 
-1.449489743, 1. - 2.1, 1. + 2.1,3.449489743 
The roots are rendered according to their multiplicity: 
> fsolve( (x-2-2)-3 , x ); 
-1.414213562, -1.414213562, -1.414213562, 1.414213562, 
1.414213562, 1.414213562 
Generally, fsol ve can tind alI roots, but that is not guaranteed. If not, try the op-
tion fulldigi ts. 

14.9 Solving complicated systems of polynomial equations with Grobner basis 
179 
If you are interested only in real solutions in a restricted range, you can ask for 
these, for instance: 
> fsolve( x-4-x-l , x=O .. 10 ); 
1.220744085 
For systems of polynomial equations, fsol ve tries to tind one solution, not all 
solutions. For instance, let's solve the system ofsection 14.2 on page 171: 
> fsolve( {circlel,circle2} , {x,y} ); 
{ y = 3.741865932, x = 7.475597795 } 
In order to tind the other solution, you can try to help by entering other starting 
values or by entering ranges for the variables; both are demonstrated here: 
> fsolve( {circlel,circle2} , {x=-l,y=-l} ); 
{x = -4.025597795, y = -.09186593167} 
> fsolve( {circlel,circle2} , {x=-10 .. 0,y=-10 .. 0} ); 
{x = -4.025597795, y = -.09186593167} 
14.9 Solving complicated systems of polynomial equations 
with Grobner basis 
For the solution of systems of polynomial equations, Maple provides the proce-
dure Groebner [gsol ve] , which combines factorization with the Buchberger al-
gorithm for calculation of a Grobner base. (In releases before V.5, use grobner 
instead of Groebner.) 
The Buchberger algorithm is a powerful tool, based on the idea of elimination of 
leading terms (terms of highest degree in some interpretation of "highest"). This 
is the same idea as used in tinding the intersection points of two circ\es, where tirst 
the difference of the two equations is calculated in order to get rid of the quadratic 
terms. Additionally, the factorization in Groebner [gsol ve] can bring about a 
splitting into several systems. Here is a simple example, which cannot reveal the 
structure and the power of the Buchberger algorithm, but can c\arify the splitting 
action of factorization and the result. 
If you want to solve the following system of equations in x and y: 
{ x2y2 + 12y = 3x2 + 4y3 } 
x2 + x = y2 
you can try to manipulate this into a more accessible system as follows. First con-
vert the tirst equation into the form" 
= O" and factor the result: 
{:} { (y2 _ 3)(x2 - 4y) = O} {:} 
x2 + x - y2 = O 

180 
14. Polynomial equations and factoring polynomials 
Consequently, the systems splits into two systems: 
{ x2 + ~ ~ y: = O} 
or {x 2 :: : ;; = O } {} 
In the right system, y can be eliminated by setting y = ~2 in the left system, y2 = 3 
can be substituted in the second equation, yielding: 
{} {x2 ::: ~ = O} 
or {x2 + x ~ ~2~)2 = O} {} 
The right system splits into two systems because the second equation has a factor 
x: 
{} { x2 :: 
: ! = O} 
or {x:: ~y} or {x + 1 x~ :3 ;~6 = O } 
This is essentially what you find when you apply Groebner[gsolve] to the system 
at the beginning: 
> x
A 2*y
A 2+12*y=3*x
A 2+4*y
A 3; 
x2 y2 + 12 y = 3 x2 + 4 y3 
> eql:=%%: eq2:= %%: 
In releases before V.5 you can enter 
> grobner[gsolve]( {eql,eq2} , { x,y} ); 
but Groebner [gsol ve] does not accept polynomial equations; they must be con-
verted into polynomials first: 
> map( eq->lhs(eq)-rhs(eq) , {eql,eq2} ); 
{ x2 + x - y2, x2 y2 + 12 y _ 3 x2 _ 4 y3 } 
> Groebner[gsolve]( % , {x,y} ); 
{ [ [y2 _ 3, x2 + x - 3] , plex (x, y), {} ] , 
[[y, xl, plex(x,y), {} l, 
[ [ -16 x - 16 + x3 , 4y - x2 ] , plex(y, x), {x 2 + x - 3, x} ] } 
The result is a set of three lists, each containing 
• a system of equations (without = O) 
• the order of the equation variables used in the ca1culation (useful information 
if you want to try other orders) 
• polynomials that are assumed to be unequal to zero in the solution of that re-
suit system 

14.9 Solving complicated systems of polynomial equations with Grobner basis 
181 
Omitting the second and third elements of the lists we see that the result is a set of 
three systems of equations: 
{ 
y2 - 3 = O } 
or 
{ y = O } 
or 
{ -16x - 16 + x3 = O } 
x 2 + x - 3 = O 
x = O 
4y - x 2 = O 
which is equivalent to the result we found earlier by hand. 
After this simplification of the original system, we can apply sol ve to each of the 
resulting systems of equations. Let's name the result gsys before continuing the 
manipulations. 
> gsys := %: 
The result of Groebner [gsol ve] renders each system of equations as a Zist of 
polynomials, but since sol ve wants a set of equations as its first argument, we 
must convert first. Let's take the third system, and convert this into a set: 
> gsys[3]; 
[ [ -16 x - 16 + x3 , 4 y - x 2 ] , plex(y, x), { x2 + x - 3, x } ] 
> % [1] ; 
[ -16 x - 16 + x3 , 4 y - x2 ] 
> { op(%) }; 
This set can be tackled with sol ve. 
> solve( % , {x,y} ); 
{ x = 2 RootOf( -4_Z - 2 + _Z3) , 
Y = RootOf(-LZ - 2 + 2 3)2} 
This is the third part of the solution, so let's save the result as 
> so13:=%: 
The other systems can be handled the same way. 
> soli := solve( {op(gsys[1] [1])} , {x,y} ): 
> so12 := solve( {op(gsys[2] [1])} , {x,y} ): 
These solutions are joined together to find the solutions of the original system of 
equations. 
> soli, so12, so13; 

182 
14. Polynomial equations and factoring polynomials 
{ Y = RootOf(_Z2 - 3) , x = RootOf(_Z2 + -Z - 3) }, 
{x=O,y=O}, 
{ x = 2 RootOf(-LZ - 2 + _Z3) , 
Y = RootOf( -LZ - 2 + _Z3)2} 
Now we can apply aU values. 
We could have solved this system with solve faster, but with this method more 
complicated systems of polynomial equations can be solved, where of ten the pure 
application of sol ve would take more time, possibly without finding any solution 
at ali, or one less neat. 
You can influence the solving process by passing a list of variables as the second 
parameter in Groebner [gsol ve] , and choosing the order of these. 
The Groebner package contains more tools for systems of equations, especially 
Groebner [sol vable] and Groe bner [fini te], which decide if a given sys-
tem of polynomial equations is algebraically consistent, and if the system has a 
finite number of solutions. 
Maple also uses the same Grobner basis methods for simplifications with side re-
lations. See section 11.l1 on page 147 and section 14.9 on page 180. 
14.10 Aigebraic extensions of the rational number field 
The elementary number field for Maple is the field of the rational numbers. This 
field can be extended with roots of polynomials, but doing so makes many calcu-
lations more complex, so Maple must be coaxed into it. For instance, 
> (x-3 - 5)/(x - 5-(1/3)); 
x 3 - 5 
x -
5(1 / 3) 
The denominator is a factor of the numerator, but normal does not see: 
> normal( % ); 
Even though this expression contains ~, normal does not use this radical for 
simplification of the quotient. To make Maple do that, we must convert the radicals 
to RootOf expressions first. 
> convert( % , RootOf ); 
x - RootOfCZ3 - 5) 

14.10 Algebraic extensions of the rational number field 
We can order simplification in the following way: 
> evala(Normal( % »; 
x 2 + RootOf{_Z3 - 5) x + RootOfCZ3 _ 5)2 
183 
The name of the procedure evala is an abbreviation of "evaluate in an algebraic 
extension field". The procedure Normal is the inert version of normal: it does 
nothing itself, but it tells evala what is to be done. 
The RootOf expression can now be converted into a radical. 
> convert( % , radical ); 
x 2 + 5{1/3) x + 5(2/3) 
The procedure evala can make several types of calculations involving RootOf 
expressions in combination with inert procedures such as Normal, Expand, Fac-
tor, Factors, Quo, Resultant, etc. 
> evala( Expand( (x - RootOf(t-3 - 5*t - 3,t»-3 ) ); 
x3 - 3x2 RootOfCZ3 - 5_Z - 3) + 
3x RootOfCZ3 - 5_Z - 3)2 -
3 - 5 RootOfCZ3 - 5_Z - 3) 
In order to make the above result more readable, we can use alias: 
> alias( RT = RootOf(t-3 - 5*t - 3,t) ); 
1, RO, RT 
The procedure alias reports which names are aliased: the name RO has been used 
earlier in this chapter. The alias construction is discussed in section B.l on page 
285. 
Now we achieve a nicer representation of the previous result. 
> %% ; 
x 3 - 3 x 2 RT + 3 x RT2 - 3 - 5 RT 
We can ask for factorization with evala and the inert factorization procedure Fac-
tor: 
> evala(Factor(%»; 
(x - RT)3 
In the Iast command, Maple profits from the fact that the expression to be factored 
already contains the necessary RootOf expression. If that is not the case, it must 
be added as an extra argument to Factor. 
> evala(Factor(x-3-5»; 

184 
14. Polynomial equations and factoring polynomials 
> evala(Factor( x~3-5 , RootOf(t~3-5,t) )); 
(x - RootOfCZ3 - 5)) 
(x 2 + RootOfCZ3 - 5) x + RootOfCZ3 _ 5)2) 
The algorithm used by Factor can be chosen by the user; consult the on-line help 
about Factor. 
In the on-line help you can find a listing of the inert procedures that can be handled 
with evala. 
In the last case, factor can do the job as well. 
> factor( x~3-5 , RootOf(t~3-5,t)); 
(x - RootOfCZ3 - 5)) 
(x 2 + RootOfCZ3 - 5) x + RootOfCZ3 - 5)2) 
The combination of Factor with evala can do much more, such as managing 
powers ofRootOf expressions, but factor offers another possibility, using a rad-
ical as its second argument. In this case, factor can use ?'5 as the second argu-
ment. 
> factor( x~3-5 , 5~(1/3) ); 
(x - 5(1/3)) (x2 + 5(1/3) x + 5(2/3)) 
The procedure factor calls the procedure evala automatically in such a case, 
and converts resulting RootOfs back into radicals. The second argument must be 
a radical, for instance sqrt (-2) does not work: it is evaluated to 1..;2, which is 
not allowed, but (-2) ~ (1/2) can be used as a second argument. 
If evala has to handle an expression that contains a RootOf expression, it tests if 
it is irreducible: 
> evala( (RootOf(x~4+5*x,x) * RootOf(x~2+3))~4 ); 
Error, reducible RootOf detected. 
Substitutions are 
{RootOf(_Z-4+5*_Z) = O, RootOf(_Z
A 4+5*_Z) = RootOf(_Z-3+5)} 
If you want to solve polynomial equations in an algebraic number field, to be de-
fined by yourself, you can use roots. For instance, let's extend the field of the ra-
tionals with the roots of u2 + u - 1 = O: 
> alias(gs=RootOf(u~2+u-1,u)); 
1, RO, RT, gs 
Now we can solve the equation x 2 = 5 in this field. The procedure roots does 
not accept equations; we must take left-hand side minus right-hand side as the first 
argument: 

14.12 Polynomials over Z mod p 
185 
> roots(x A 2-5,x,gs); 
[[2gs + 1,1], [-1- 2gs, 1]] 
14.11 Polynomial rings modulo ideals 
For calculations with algebraic extensions in the setting of a polynomial ring mod-
ulo the ideal generated by one or more polynomials you can use simplify with 
side relations. This idea is discussed in section 11.11 on page 147. Here is a sim-
ple example that demonstrates the idea in the present context. The same example 
is handled in a different way in section 14.4 on page 175. We use the equality: 
> eq; 
x5 - tx2 + p = O 
We can calculate x 7 modulo the corresponding polynomial as follows: 
> simplify( x A 7 , {eq} , {x} ); 
x 4 t - x 2 P 
We have reduced x7 (first argument) as a polynomial in x (last argument) modulo 
the ideal generated by x 5 -
t x 2 + p (second argument). Much more complicated 
problems containing several variables and several equations can be handled effi-
ciently thanks to the fact that Maple applies Grobner basis methods. For details, 
please consult the on-line help about simplify [siderel] . 
A package Domains is available for more general purposes. See section A.II on 
page 283. 
14.12 Polynomials over Z mod p 
Maple can perform calculations on polynomials with coefficients in Z mod p as 
follows: 
> poly := 20*x
A 7 - 7*x
A 6 + 28*x
A 5 + 5*x - 1; 
poly:= 20x7 -7x6 + 28x5 + 5x-1 
> poly mod 5; 
The last resuIt is not represented intemally in Maple as a polynomial over Z mod 5 
but as a polynomial over Q. So in the following command Maple does not handle 
this resuIt as a polynomial over Z mod 5. 

186 
14. Polynomial equations and factoring polynomials 
> expand( %-2 ); 
9X12 + 18xll + 24x6 + 9xlO + 24x5 + 16 
For each calculation mod 5 we must append mod 5 to the command again. If you 
don't 1ike that, you might prefer to use the Domains package with Zmod; see sec-
tion A. 11 on page 283. 
> expand( %%-2 ) mod 5; 
4X12 + 3xll + 4x6 + 4xlO + 4x5 + 1 
Modulo factorization is possible with Factor. 
> Faetor( % ) mod 5; 
4(x+4)2 (x4 +2x2 +3x+1)2 (X+2)2 
For solving an equation mod p, msolve can be used. 
> msolve( poly = O , 5 ); 
{x=1},{x=3} 
For polynomials, Roots can be used, too, in combination with mod. 
The equivalents of several procedures for manipulating polynomials and rational 
expressions, such as normal and ged, are available as weB. 
> Normal( (x-2 - 3)/(x-3+7) ) mod 11; 
x+5 
x2 + 5x + 3 
> Ged( x-2 - 3 , x-3+7 ) mod 11; 
x+6 
More information can be found in the on-line help about mod. 
Maple can handle algebraic extensions of Z mod p; information about this subject 
can be found in the on-line help to evalgf, the GF package for Galois fields, and 
the Domains package for creating domains, discussed in section A.ll on page 283. 

chapter 15 
Manipulating algebraic expressions 
Manipulation ofnumbers, polynomials, rational expressions, andRootOf expres-
sions is discussed in Chapter 2, Numbers and algebraic operators, in Chapter 13, 
Polynomials and rational expressions, and in Chapter 14, Polynomial equations 
and factoring polynomials. 
This chapter continues discussing manipulation, but extends to more general types 
of algebraic expressions. The usual goal of manipulating algebraic expressions 
is conversion of an expression to a "simple" expression. But what is "simple" 
depends on what you want to do with the expression. Therefore, inverse actions 
are shown for most of the actions discussed. 
Thejirst section on using optionsfor simplify and combine isfollowed by sec-
tions on manipulating powers and radicals, expressions with exp and In, and 
trigonometric expressions. Although there are facilities for using properties of sev-
erai other mathematicalfunctions, we do not try to cover them ali; ifyou have seen 
these cases, you will be able to jind your way yourself. 
Restricting the action of manipulations to a part of an expression is discussed ex-
tensively in a special section. 
If you want to see if an equality is true, you might use other methods than symbolic 
manipulation. These are shown in a special section on this subject. 
Examples are kept as small as possible. For such cases, manipulating by hand is 
much simpler. But the same ideas can be usedfor manipulating very largeformulas 
and then using these tools can pay the efforts. Two sections each give an example 
of manipulating a not so simple expression. 
In the Short Reference List at the start of this book is a survey of the main manip-
ulation tools. 
15.1 Options for simplify and combine 
The general manipulation tools simplify and combine can do many things at 
once, for instance using properties of functions such as exp, In, sin, cos, etc., and/or 
using properties of powers. In many cases it is desirable not to use aH these prop-
erties, but to select the type of transformation wanted. Restricting the action of 
simplify or combine can be done by using options. 
(In releases before VA, combine must be activated with options; without options 
it can do only a few manipulations.) 
Here is an example: 
E. Kamerich, A Guide to Maple
© Springer Science+Business Media New York 1999

188 
15. Manipu1ating a1gebraic expressions 
> testexpr:=exp(sin(x)-4)/exp(cos(x)-2); 
e(sin(x)4) 
testexpr:= ( 
()2) 
e COS X 
For instance, to restrict combine to applying the properties of the function exp, 
use the option exp: 
> combine( testexpr , exp ) ; 
e( sin(x)4-cos(x)2) 
Using the option power yields the same result. But using the options trig or sin 
or cos causes actions to trigonometric functions: 
> combine( testexpr , trig ); 
e(i+! cos(4x)-! cos(2x») 
e(! cos(2x)+!) 
There are many more options available for combine. See the Short Reference List 
at the start of the book for a fulllist of options. 
It is also possible to apply combine without options: 
> combine( testexpr ); 
e( -!+! cos(4x)-cos(2x») 
If you want to polish an expression without special purposes, you can experiment 
with simplify, combine without options and the other tools discussed in this 
chapter (especially expand, normal, factor, and rationalize and see what 
you get. If you are not satisfied with the result, look for pattems in the expression 
and decide what you want to do; then use the right procedure with the right option. 
In many cases, several steps in the right order are necessary. Some of these more 
complicated examples are demonstrated in this chapter. 
To show the specific actions of procedures in combination with options, the rele-
vant option is added in each example of this chapter, although in most of the basic 
examples you would get the same result without that option. In several cases, al-
tematives are shown. 
15.2 Simplifications depending on conditions 
Expected simplifications may not be executed. Here is another example: 
> exp(X)-n*exp(Y); 
(eX)n ey 
Let's try to get en X+Y by applying combine or simplify: 

15.2 Simplifications depending on conditions 
189 
> combine(%); 
> simplify(%); 
No effects! There is a good reason for that: X, Y, and n are to be taken as unknown 
complex numbers. It may not be true that (eX ) n = en x ; for instance, if X = ~1f 
and n = ~, then 
exp(x)n = eXP(~1f)(1/2) = (_i)(1/2) = ~V2(1 - i) 
2 
2 
exp(n X) = exp( ~1f) = ~V2( -1 + i) 
But if X stands for a real number, then (e X ) n = en x. In that case, we must teU 
Maple that X is a real variable; then simplify without option or with the option 
power can do the job: 
> assume(X,real); 
> simplify(%,power); 
The trailing tilde indicates that X has a property; see section 3.4 on page 36, or 
section A.4 on page 278. 
It is possible to make simplify really foolhardy by adding the (euphemistic) op-
tion symbolic: 
> exp(x)~n*exp(y); 
> simplify(%,power,symbolic); 
e(n x+y) 
We could have used simplify(%,symbolic) as well. The option symbolic 
may be used also for combine, but only together with other options. 
If you are trying to simplify some expression without success, you might use the 
option symbolic and, if it yields a nice result, check if this re suIt is equivalent 
to the original expression (see section 15.12 on page 212), or, for instance, if you 
are trying to find an antiderivative, a solution of an equation, or of a differential 
equation, check if the result satisfies. An example can be found in section 15.8 on 
page 201. 
We could also have told Maple that the variables are real: 

190 
15. Manipulating algebraic expressions 
> simplify(%%,power,assume=real); 
e(nx+v) 
This simplification rule can also be applied if the exponent is an integer: 
> assume(n,integer); 
> exp(x)~n*exp(y); 
(exrlr-' eV 
> simplify(%,exp); 
If you are still using release V.3 or earlier, the suggestions above are not valid. 
The improvements of the reliability of expression manipulation from the first re-
lease of Maple V untill the present release V.5 are enormous, now making Maple 
V.5 a superior choice for reliable mathematical calculations. A system of proper-
ties has been built in; many procedures using rules that depend on properties can 
now check properties fast and efficiently and will apply these rules only when it can 
be determined that the necessary conditions are fulfilled. Up to a few marginal ex-
ceptions, mentioned in the last section of this chapter, you can trust the manipula-
tions discussed in this chapter if you are using rele ase V.5. If you are using release 
V.3 or even an earlier release, the best advice is to grade up. 
15.3 Sums of exponents, products of powers with equal basis 
For each complex number z, each a, each b, and each c 
a 
b 
za+b-c = ~ 
Zc 
Manipulation from the left-hand side to the right-hand side is possible with 
expand: 
> z~(a+b-c); 
> expand(%); 
Zc 
However, expand does many things at once. There are facilities for restrict-
ing the action of expand, but it might be easier to use an alternative. You can 
get an only slightly different result with simplify( ,commonpow) (not docu-
mented by Maple); this result can even be converted into the previous result with 
normal( ,expanded): 

15.3 Sums of exponents. products of powers with equa1 basis 
191 
> simplify(%%,commonpow)j 
za zb z{- e) 
> normal(%,expanded); 
The reverse direction can be produced with simplify( ,power) or combine 
( ,power): 
> simplify( % , power ); 
> combine( %% , power ); 
z{a+b-e) 
Halfway back brings us combine( ,cmbpwr): 
> combine( %%% , cmbpwr ); 
za zb z{- e) 
Although the expression exp (x) has the structure of a function caU, not of a power, 
it is printed as eX in windowing versions and it can be handled with some of the 
manipulation tools for powers: simplify( 
,power), combine ( 
,power), 
and expand. For instance, 
> exp(x)*exp(y)/exp(z); 
> simplify(%,power); 
e{X+Y-Z) 
If action is to be restricted to exponential function caUs, try the procedures 
simplify( ,exp) and combine( ,exp): 
> exp(a)*exp(b)+xAa*xAb; simplify(%,exp); 
ea eb + x a x b 

192 
15. Manipulating algebraic expressions 
15.4 Powers of powers, products of exponents 
The identity 
is true 
• if b is an integer, or 
• if z is positive and a is real 
but in many other cases it is not true, for instance, 
(( _1)2)(1/2) i= (_1)(2* 1/2) 
Conversion from the left-hand side to the right-hand side is possible with expand, 
simplify( ,power), and combine( ,power), but only when Maple can see that 
the conversion is correct (from release V.3 for simplify, from release VA for ex-
pand). The following is correct because 5 is an integer: 
> (z~a)~5j simplify(%,power)j 
(za)5 
The following is correct because 7r - 1 is positive: 
> «Pi-l)~(7/4))~(1+I); simplify(%,power)j 
( 
(7/4))(HI) 
(7r-l) 
If we ask the same in a more general case, Maple refuses to perform this type of 
conversion: 
> (z~x)~Yj simplify(%,power)j 
(ZX)Y 
But you can tell Maple that your variables have properties: 
> assume(pos,positive,X,real,n,integer)j 
> (pos~X)~Yj simplify(%,power)j 
(pos""X~)Y 
pos",,(X~Y) 
> (z~x)~nj simplify(%,power)j 
(ZX)7lr-' 

15.4 Powers of powers, products of exponents 
193 
You can also teU Maple not to bother about correctness with the additional option 
symbolic: 
> simplify«z-x)-y,power,symbolic); 
z(x y) 
It is also possible to teU simplify that aU variables are to be taken as positive 
numbers: 
> simplify«z-x)-y,power,assume=positive); 
z(x y) 
Exponential function caUs can be handled with simplify( ,power) as weU: 
> exp(X)-y + exp(a)-n; simplify(%,power); 
(eX~)Y + (ea)flrv 
If action is to be restricted to exponential function 
simplify ( 
, exp) can be used instead of simplify ( 
the case in which the exterior exponent is an integer: 
> exp(X)-b + exp(a)-n; ~implify(%,exp); 
(eX~)b + (ea)flrv 
(eX~)b + e(flrva) 
caUs, the procedure 
, power) , but only for 
Manipulation in the reverse direction is available only for cases such as: 
> z-(5*a); simplify(%,commonpow); 
z(5 a) 
> expand(%%); 
In the last case, expand acts as its own inverse: 
> expand(%); 
For more general cases, you can convert for instance pX b into pX pb, assuming 
that p is a positive number and X is real, as foUows: 

194 
15. Manipulating algebraic expressions 
> p-(X*b); subs( p=pos-(l/X) , % ); 
p(X~b) 
( 
( ....L))(X~b) 
pas'" x_ 
Now we need the assumptions on X and pos: 
> expand( % ); 
Finish by substituting back: 
> subs( pos=p-a , % ); 
Obviously, the user must take responsibility for the correctness of this conversion. 
In order to change e( a b) into (ea) b we can use the method above, but it can be done 
easier by manipulating exp and In: 
> exp(a*b); subs(a=ln(t),%); 
era b) 
e(ln(t) b) 
> expand(%); 
> subs(t=exp(a),%); 
15.5 Powers ofproducts, products ofpowers with equal exponents 
The identity 
is true 
• if x or y is positive or 
• a is an integer 
but not in general. For instance, 
(_1)1/2 (_1)1/2 =1- 11/ 2 
First, let's look at the case where the base of the power is assumed to be positive: 

15.6 Radica1s 
195 
> assume(pos>O); 
The procedure simplify( 
,power) can use this property: 
> (pos*z)~a; simplify(%,power); 
(pas", zt 
In the present release V.5, no general tools are available for conversion of (xy)n 
into xnyn for the case in which n is assumed to be an integer, (and x and y have 
no properties), apart from using the option symbolic. However, if the exponent 
is a concrete integer, automatic simplification does the job immediately: 
> ( x*y ) 
~ 5; 
The reverse is possible with the aid of simplify( ,commonpow) (not docu-
mented): 
> pos~a * z~a; simplify(%,commonpow); 
15.6 Radicals 
simplify(%,commonpow); 
x"""y""" 
(x y)""" 
In cases in which the exponent of a power is a concrete rational number, some con-
versions can be executed by the procedure simplify( ,radical). First, it splits off 
the integer powers in some cases: 
> (x*y)~(22/7); simplify(%,radical); 
(xy)(22/7) 
x3 y3 (xy)(l/7) 
Then it tries to use properties ofthe power operation, for instance here, where pos 
has been previously assumed to be a positive number: 

196 
15. Manipulating algebraic expressions 
> (posA5)A(7/5); simplify(%,radical); 
( 
5) (7/5) 
pOS'" 
Then it tries to combine equal radicals: 
> (a-b)*(z+1)A(1/4)+b*(z+1)A(1/4); simplify(%,radical); 
(a - b) (z + 1)(1/4) + b (z + 1)(1/4) 
(z + 1)(1/4) a 
At last, simplify ( 
, radical) caUs the procedure normal: 
> posA2*(z+1)A(2/5)+(z+1)A(-3/5); simplify(%,radical); 
2 ()(2/5) 
1 
pos'" 
z + 1 
+ 
(3/5) 
(z + 1) 
pos",2 z + pos",2 +1 
(z + 1)(3/5) 
For square roots, you can use simplify( ,sqrt). 
The results obtained with simplify( 
,radical) are quite different from the 
results obtained with simplify( 
,power): 
> «p+l)A(7/4»A(5/3); 
((p + 1)(7/4») (5/3) 
> simplify(%,power); simplify(%%,radical); 
((p+ 1)(7/4»)(5/3) 
(p + 1)(7/4) ((p + 1)(7/4») (2/3) 
For elimination of radicals from the denominator of a quotient the procedure ra-
tionalize is available. 
> (a+b)/(c+sqrt(d»; 
> rationalize(%); 
a+b 
c+ v'd 

15.7 Manipulating logarithmic expressions 
Here is another example of a quotient: 
> (w-2)~(3/2)/(WA2-4*w+4)~(1/4)j 
(w - 2)(3/2) 
(w2 - 4w + 4)(1/4) 
197 
We can try to divide out the common factor from numerator and denominator. Usu-
ally such ajob can be done with normal, but this is a conscientious procedure and 
cannot handle the present expression, as it does not know if w is a real number 
gre ater or less than 2. However, the procedure radsimp is not scrupulous: accord-
ing to its on-line help, it chooses branches according to its own rules: 
> radsimp( % )j 
w-2 
The same result can be found with simplify( 
, symbolic) or with combine 
( 
, radical, symbolic) followed by normal. 
If you want to have control yourself, there are better ways of manipulation. Let's 
help Maple and apply factor: 
> factor(%%)j 
(w - 2)(3/2) 
( 
2) (1/4) 
(w - 2) 
We get a product of two powers with equal basis. The procedure simplify 
, power) refuses to work, unless we tell Maple for instance that w < 2: 
> assume(w<2)j 
> simplify(%,power)j 
-I(w~ -2) 
(In release V.4 a wrong result is rendered: 1 ('l.V'" -2).) 
Manipulating the nth root of a complex number is discussed in section 12.5 on page 
153. 
15.7 Manipulating logarithmic expressions 
If x, y, and zare positive, then ln(x*y / z) = ln(x )+ln(y) -ln(z); it is even correct 
if two of the three variables are positive, but of ten this rule cannot be applied (from 
release V.4). For instance, if x = y = -1 + 1 and z = 1: 
> [ ln(-1+I) + ln(-1+I) , ln( (-1+I)*(-1+I) ) ]j 
[21n(-1 +1), In(-21)] 

198 
15. Manipulating algebraic expressions 
> evalc(%); 
[ln(2) + ~ 1 1T, ln(2) -
~ 1 1T ] 
The procedure simplify( ,In) converts the logarithm of a product or quotient of 
two numbers into a sum of logarithms only if it can decide that one of the two num-
bers is a positive number or that it is a negative number (from release VA). 
> ln(pos*y); simplify(%,ln); 
In (pos '" y) 
ln(pos"') + ln(y) 
> assume(neg,negative); 
> ln(x/neg); simplify(%,ln); 
ln( n:U"') 
-ln(-neg"') +ln(-x) 
The same results can be found with expand; sometimes you also can use 
simplify( ,power). 
For the opposite direction, you can use combine( ,In), 
> ln(pos)+ln(a);combine(%,ln); 
ln(pos"') + ln(a) 
ln(pos'" a) 
> ln(a)-ln(pos);combine(%,ln); 
ln( a) - In (pos "') 
ln(_a ) 
pos'" 
The following transformation can be handled only with the aid of the hazardous 
option symbolic: 
> ln(pos)-ln(a);combine(%,ln,symbolic); 
ln(pos"') -ln(a) 
In(PO;"') 
The rule ln(ab) = bln(a) is only true for some special cases. When Maple can see 
that the exponent b is an integer and that a is positive, then it converts ln(ab) into 

15.7 Manipulating logarithmic expressions 
b In( a) automatically: 
> ln(pos~n); 
n"-' In (pos"-' ) 
199 
In other cases where this transformation from the left to the right is correct, you 
can use simplify( ,In) or expand: 
> ln(pos~X); simplify(",ln); 
In (pos ""'x~) 
The other way around is available only for the case in which b is a concrete number: 
> (2/3)*ln(pos+l)-5*ln(pos+2); 
2 
3" ln(pos""' +1) - 5 ln(pos,,-, +2) 
> combine( % ,In); 
( (pos,,", +1)(2/3») 
In 
5 
(pos"-' +2) 
If you don't like exponents that are not an integer, you can request to avoid these 
with an extra option: 
> combine«2/3)*ln(pos+l)-5*ln(pos+2),ln,integer); 
2 
3" In(pos"-' +1) - 5 ln(pos""' +2) 
The function exp is the left inverse of In; restricted to the real numbers it is the 
right inverse as well. Automatic simplification uses this: 
> exp(ln(x»; 
> assume(X,real): 
> ln(exp(X»; 
x 
For alI complex numbers a, x, y, and z with x, y, and z unequal to O: 
xay 
exp(aln(x) + ln(y) -ln(z)) = - z 
exp(y * In(x)) = x y 
The conversion from the left to the right can be executed with simplify with the 
option power or exp or with combine ( 
, exp): 

200 
15. Manipulating algebraic expressions 
> exp(a*ln(x) + ln(y) - ln(z)); 
e(a ln(x)+ln(y)-ln(z)) 
> simplify(%,exp); 
For all real x: In(exp(x)) = x, but, for instance, In(exp(1+21fi)) = e. Don'tuse 
the manipulations of this chapter for this; it can be found by evalc: 
> ln(exp(1+2*I*Pi)); 
> simplify(%); 
> evalc(%%); 
1 
However, evalc expects ali variables to be real, so it does the same simplification 
as simplify ( 
, In) for the case of undefined arguments: 
> ln(exp(z)); evalc(%); 
z 
Not for ali complex z is this correct, so don't use evalc if your variables are not 
ali real! 
15.8 An example of the use of the option symbolic 
In Chapter 4, Elementary ca/culus we found: 
> integrand:=1/(x-(1/2)+x-(1/3)); 
. 
1 
zntegrand:= y'x + x(1/3) 
> int( % , x ); 
2y'x-2 arctanh(y'x)-ln(x-1)-3x(1/3)-2In(x(1/3) -1)+ 
In (X(2/3) + x(1/3) + 1) + 2 In (x(1/6) - 1) -
In( X(1/3) + x(1/6) + 1) - 2 In (x(1/6) + 1) + 
In (X(1/3) -
X{1/6) + 1) + 6 X(1/6) 

15.8 An example of the use of the option symbolic 
201 
The algorithm used yields a complex expression; if you have in mind an antideriva-
tive on positive numbers, this expression yields a discontinuous function with val-
ues that are not real. Let's try to convert this to a real expression for x positive. 
First, let's make x a positive variable: 
> assume(x,positive); 
Now let's get rid of that arcsin: 
> convert(%,ln); 
2..;x;:: -ln(..;x;:: + 1) + ln(l-..;x;::) -ln(x '" -1) -
3x",{1/3) -2In(x",{1/3) -1)+ln(x",{2/3) +X",{1/3) +1)+ 
21n(x",{1/6) -1) -ln(x",{1/3) +X",{1/6) +1)-
2 In (X",{1/6) +1)+ln(x",{1/3) _X",,{1/6) +1)+6x",{1/6) 
A sum of logs cannot be combined in general; that depends on the arguments. But 
now, we don't care for branch cuts of In; to the contrary, by neglecting them, we 
might change the expression into a continuous one. So, let's use the option sym-
bolic: 
> combine(%,ln,symbolic); 
2..;x;:: - 3X",{1/3) +6X",{1/6) + 
ln((l-..;x;::) (X",{2/3) +X",{1/3) +1) (X",{1/6) -lf 
(x",{1/3) _x",{1/6) +1) / (..;x;:: + 1) (x'" -1) 
(X",{1/3) -1 f (X",{1/3) +X",{1/6) +1) 
(X",{1/6) +lf) 
If we apply radsimp to this expression direct1y, nothing happens: radsimp can-
not reach the argument ofIn. Let's analyze the expression. You can use op to tind 
that out, but we can see it directly. The expression is a sum of four components; 
the fourth component is a function calI, its argument being its sole regular compo-
nent. Now radsimp must act on this subcomponent, so it must reach an operand 
of an operand of ttt. Let's apply it to alI the subcomponents of the components 
of the expression with the aid of a double form of map: 
> map( u->map(radsimp,u) , % ); 
2..;x;:: - 3 X ",(1/3) +6X",{1/6) +ln(-
1 
) 
(x",{1/6) +1)6 
This contains only a constant imaginary component: 
> evalc(%); 

202 
15. Manipulating algebraic expressions 
> evalc(Re(%)); 
2.;x;::;-3x, ... ,,(1/3) +6X",(1/6) -6In(x",(1/6) +1) 
We have used the option symbolic so we cannot be sure that this is a correct an-
tiderivative (apart from this being the same result as in section 4.9 on page 52). So 
let's check it: 
> normal(diff(%,x)-integrand); 
O 
That confirms the correctness. 
It's a good habit to delete an assumption as soon as it becomes superfluous: 
> x:='x'; 
X :=x 
15.9 Manipulating trigonometric expressions 
The procedure simplify( 
, trig) applies the rules 
a. sin2 (cfJ) + cos2 (cfJ) = 1 
b. tan(cfJ) = ~~~~:~ 
to get rid of tan and sin as much as possible. 
> 5*sin(x)-2 + 2*cos(x)-2; simplify(%,trig ); 
5 sin(x)2 + 2 COS(X)2 
-3 COS(x)2 + 5 
> sin(x)-3+cos(x)-3; simplify(%,trig ); 
sin(x)3 + COS(X)3 
COS(X)3 + sin (x) - sin (x) COS(X)2 
> sin(t)+tan(t); simplify(%,trig ); 
sin(t) + tan(t) 
sin(t) (cos(t) + 1) 
cos(t) 
If no sin or cos is present in the expression, no conversion of tan is applied. 

15.9 Manipulating trigonometric expressions 
203 
Ifyou prefer to remove cos as much as possible, apply simplify with side rela-
tions to the relation sin2 (x) + cos2 (x) = 1. See section 11.11 on page 147. 
> simplify( %% , {sin(x)~2+cos(x)~2=1} , [cos(x)] ); 
sin(t) + tan(t) 
The other manipulation procedures have the same inclination to cos. For instance, 
the procedure expand, which can expand arguments of sin, cos, and tan: 
> cos(5*x+y); expand(%); 
cos(5x + y) 
16 cos(y) COS(x)5 - 20 cos(y) COS(X)3 + 5 cos(y) cos(x)-
16 sin(y) sin(x) COS(X)4 + 12 sin(y) sin(x) cos(x)2 -
sin(y) sin (x) 
The reverse direction is handled with combine ( 
, trig) : 
> combine(%,trig); 
cos(5x + y) 
Trigonometric products can also be handled with combine ( 
, trig): 
> sin(x)*sin(y); combine(%,trig); 
sin(y) sin (x) 
1 
1 
2" cos( - y + x) -
2" cos(y + x) 
The procedure combine ( 
, trig) tries to convert powers and products of sin 
and cos function caUs into sums of sin and cos function caUs. It does not handle 
tan function caUs. 
The reverse direction is handled with its counterpart expand, which, however, may 
have unwanted other effects: 
> expand(%); 
sin(y) sin (x) 
The trigonometric functions incorporate some automatic simplifications. For in-
stance, 
> cos(11*Pi/2-x); 
- sin(x) 
sin(x + mr) can be simplified to sin (x) easily when the name n has the property 
of being an integer: 

204 
15. Manipulating algebraic expressions 
> nA2 + sin(a+b+2*n*Pi) + cos(y-2*n*Pi)A3; 
n",2 +sin(a+b+2n'" 1f)+cos(y-2n'" 1f)3 
> expand(%); 
n",2 + sin (a) cos(b) + cos (a) sin(b) + COS(y)3 
(In releases before VA, use side relations.) 
Conversion of sin and cos to tan is available: 
> convert( cos(x) , tan ); 
1- tan(~ X)2 
1 + tan(~ x)2 
Conversion to sincos does not yield the original expression: 
> convert( % , sincos ); 
1 _ (1-cos(x»2 
sin(x)2 
1 + (1-cos(x»2 
sin(x)2 
But simplify( 
, trig) can do the job: 
> simplify( % , trig ); 
cos(x) 
In most cases the procedure convert ( 
, tan) bisects the arguments of sin and 
cos, but unnecessary bisections are avoided if possible: 
> sin(alpha)/cos(alpha)+cos(beta); 
> convert(%,tan); 
sin ( o: ) 
((3) 
--( -) + cos 
cos o: 
1 - tanC 1 (3)2 
tan(o:)+ 
(i(3)2 
1 + tan 2" 
Maple knows that compositions of trigonometric functions with their inverses 
should be handled with care: 
> arcsin(sin(20»; 
20 - 61f 
> arcsin(sin(x»; simplify(%); 
arcsin(sin(x)) 

15.9 Manipulating trigonometric expressions 
205 
arcsin(sin( x)) 
But arcsin is the right inverse of sin. Maple handles this by automatic simplifica-
tion: 
> sin(arcsin(x)); 
x 
Conversions of trigonometric expressions to complex expressions with exp are 
available: 
> convert(arctan(x),expln); 
1 21 (ln(1 - 1 x) -ln(1 + 1 x)) 
> convert(sin(x),expln); 
_! 1 (e(IX) __ 1_) 
2 
e(I x) 
The reverse direction: 
> evalc(%); 
1 . 
1 
sin(x) 
- sm(x) + -
+ 
2 
2 cos (x )2 + sin(x)2 
1 (_! cos (x) + ! 
cos (x) 
) 
2 
2 cos(x)2 + sin(x)2 
> simplify(%,trig); 
sin (x) 
As an aid for substitutions, the procedure trigsubs can show possibilities: 
> readlib(trigsubs); 
proc(s,1) ... end 
> trigsubs( cos(2*x) ); 
[COS(2x), cos(2x), 2 cos(x)2-1, 1-2 sin(x)2, cos(x)2-
. ()2 
1 
1 
l-tan(x)2 1 (2Ix) 
1 (-2IX)] 
SIn x , 
" 
- e 
+ - e 
sec(2x) sec(2x) l+tan(x)2' 2 
2 
The hyperbolic functions can be handled in about the same way as the trigono-
metric functions, using the same option trig, except that trigsubs cannot be 
used. 

206 
15. Manipulating algebraic expressions 
15.10 Manipulating parts of expressions 
Often, a part of a large expression must be manipulated without changing otber 
parts to prevent unwanted, possibly questionable conversions. There are several 
standard tricks for this purpose, demonstrated here in examples where it would be 
easier to do mental calculations and type in the results, but these exercises show 
how to deal with much larger expressions. 
• First, you can use subs for replacing subexpressions with others, or subsop 
for replacing a component. See Chapter Il, Substitution and subexpressions: 
> exp(x+y)+cos(x+y); 
e(Y+x) + cos(y + x) 
Suppose that we want to expand the second term only. We can realize this 
with: 
> subsop(2=expand(op(2,%)),%); 
e(Y+x) + cos(y) cos(x) - sin(y) sin(x) 
• If each of the components of an expression is to be processed but the main 
structure of the expression should be kept, you can use map. See section 10.3 
on page 127. 
> (cos(x+y)-1)-2; map(expand,%); 
(cos(y + x) - 1)2 
(cos(y) cos (x) - sin(y) sin (x) - 1)2 
> (x+l)/(x-2-1) + x/(x-2+3*x); map(normal,%); 
x + 1 
x 
--+-,---
x 2 - 1 
x 2 + 3 x 
1 
1 
--+--
x-l 
x+3 
• The procedure collect can describe an expression as a polynomial in a variable 
or a function caII; moreover, it can process the coefficients at the same time. 
For instance, 
> a-2*cos(x)+a-2*cos(x)-3+(a*cos(x))-2-9*cos(x)-3 
> 
-2*a*cos(x)-2-cos(x); 
a2 cos (x) + a2 COS(X)3 + a2 COS(X)2 -
9 COS(x)3 -
2a COS(X)2 - cos (x) 
You can interpret this expression as a polynomial in cos (x) and factor the 
coefficients with: 
> collect(%,cos(x),factor); 
(a - 3) (a + 3) cos(x)3 + a (a - 2) COS(X)2 + (a - 1) (a + 1) cos(x) 

15.10 Manipulating parts of expressions 
207 
• You can take out a part of an expression in an algebraic way, process the re-
maining expression, then complete the result. In the foUowing example, we 
want to combine the first and the third term into one quotient: 
> (x~2-x-a~2+a)/(x~2-x-x*a+a)+1/sqrt(x+a)-1; 
x 2 - x - a2 + a 
1 
-::------ + 
- 1 
x2 -
X - xa + a 
Jx + a 
> % - op(2,%); 
x 2 -
X - a2 + a 
--;::------ - 1 
x 2 -
X - xa + a 
> normal(%)+op(2,%%); 
a 
1 
--+--=== 
x -1 
Jx + a 
• For conversion of trigonometric and hyperbolic functions into sin and cos, it 
is possible to indicate that only function caUs with special arguments must be 
converted. For instance: 
> tan(x+l)+sec(y-l); 
tan(x + 1) + sec(y - 1) 
> convert(%,sincos,y); 
1 
tan(x + 1) + 
( 
1) 
cos y-
• It is possible to shield subexpressions from the action of expand by entering 
these subexpressions as additional arguments. For instance, 
> (x~a)~n + cos(t+s); 
(xa )""" + cos(t + s) 
> expand( % ); expand( %% , 
(x~a)~n ); 
x(nrva) + cos(t) cos(s) - sin(t) sin(s) 
(xa)nrv + cos(t) cos(s) - sin(t) sin(s) 
• Another trick is offered by the procedure freeze, which can freeze a subex-
pression into a temporary name; after processing you can use thaw. First 
these procedures must be read in from the library by the command 
> readlib(freeze); 
proc(e) ... end 
Here is an example: 
> exp(a+b)+cos(x+y); 
e(aH) + cos(y + x) 

208 
15. Manipulating algebraic expressions 
Let's suppose that cos(x + y) should be expanded, while ea+b should be left 
the same. Then we can use: 
> subsop(l=freeze(op(l,%)),%)j 
jreeze/RO + cos(y + x) 
> expand(%)j 
jreeze/RO + cos(y) cos(x) - sin(y) sin (x) 
> thaw(%)j 
e(a+b) + cos(y) cos(x) - sin(y) sin(x) 
If you want to denote freeze/RO in a command, don't forget to use back 
quotes, otherwise Maple divides freeze by RO: 
> 'freeze/RO' , freeze/RO j 
jreeze 
jreeze/ RO, ~ 
• In the last example, the procedure expandoff can also be used. This proce-
dure must be read in from the library in a specific way: 
> expand( expandoff() )j 
expandoffO 
Now we can handle the previous problem by disabling expand for the func-
tion exp: 
> exp(a+b)+cos(x+Y)j 
> expandoff(exp)j 
> expand(%)j 
e(a+b) + cos(y + x) 
e(a+b) + cos(y) cos(x) - sin(y) sin (x) 
We can reset the expand facility for exp with: 
> expand( expandon() )j 
expandonO 
> expandon(exp)j 
However, the procedure expand has built-in memory, its so-called remem-
ber table, from which it recalls old results. Therefore, after the previous ac-
tion it refuses to expand ln(xt ) as it recalls the result ln(xt ) from the former 
part of the session, but it expands ln(yS) without problems: 

15.10 Manipulating parts of expressions 
209 
> expand(ln(x~t)+ln(y~s)); 
ln(xt ) + ln(yB) 
The remedy is clearing the remember table of expand with forget. See sec-
tion D.2 on page 295. 
> readlib(forget) (expand); 
> expand(ln(x~t)+ln(y~s)); 
ln(xt ) + In(yS) 
• A rather complicated, but powerful and ftexible facility is frontend, which 
can apply a procedure on an expression according to specitications. For in-
stance, 
> (cos(x+l)-1)~2; 
(cos(x + 1) - 1)2 
We can ask to see this as a polynomial in cos (x+l) and apply expand on it 
as follows: 
> frontend( expand , [%] ); 
cos(x + 1)2 - 2 cos(x + 1) + 1 
The function call cos (x+l) has been frozen by frontend, then expand is 
called and the result is thawed. 
A more complicated example is the following: we want to substitute a for x 
in the expression x 2 + x y + cos( x), except for the x in the second term x y. 
This can be done with the substitution trick mentioned earlier in this section, 
but in more complicated cases this trick is less suitable than using frontend: 
> x~2+x*y+cos(x); 
x 2 + xy + cos(x) 
We want to modify the command subs (x=a, %) ; therefore, the tirst argument 
to frontend should be subs and the second should be [x=a, %]: the list of 
arguments to subs. We can tell frontend with an option that expressions 
should be subdivided into subexpressions by splitting sums and powers, but 
not products. This freezes the product x y. Moreover, we want the function 
call cos (x) nof to be frozen. Both requirements can be given together by the 
third argument, the option [{' +' , ,~ '} , {cos (x)}]. But the second argu-
ment to frontend also contains x=a; this is not to be frozen either. We can 
reach this by extending the third argument to [{' +' , , ~ , } , {x=a, cos (x) } 1 
or [{'+', '~', '='},{cos(x)}]: 
> frontend(subs,[x=a,%] ,[{'+','~'},{x=a,cos(x)}]); 
a2 + xy + cos(a) 

210 
15. Manipulating algebraic expressions 
The procedure frontend expects two or three arguments: first the procedure 
that should be applied in a modified way, then a list of its arguments. As an op-
tionallast argument you can give a list of two sets: first the set of type names 
of subexpressions nof to be frozen, second a set of subexpressions nof to be 
frozen. For types, see section A.1 on page 275. 
15.11 An example: converting a complex expres sion into a real 
expression 
Of ten, the result of a computation in Maple is a complex expression There may be 
strong indications that this represents a real number. Here is an example: 
> ti := solve(x-6+2*x-4-4*x-2-7) [1] ; 
1 ..J6V %W/3) ( %1(2/3) + 64 - 4 %1(1/3)) 
ti := 6" 
%1(1/3) 
%1 := 404 + 121 V687 
A test with evalf suggests that this is a real number: 
> evalf(%); 
1.391198165 - .792804972810-10 1 
We want to convert the previous expression into an explicitly real one. 
First, let's simplify the subexpression 
( 404 + 121 V687) (1/3) 
We can extract the basis of this power and then simplify its third root as follows: 
> si := %1; 
sI := 404 + 121 V687 
> evalc(convert(sl-(1/3),polar)); 
512(1/3} cos (~ arctan (1~1 V687) ) + 
1512(1/3} sin (~ arctan C~1 V687) ) 
> s2:=simplify(%); 
s2 := 8 cos (~ arctan C~1 V687) ) + 
81 sin (~ arctan (1~1 V687) ) 

15.12 Verifying identities 
211 
We can substitute the result into the main expression. It is not efficient to issue 
subs (sl=s2~3, tl), because it is not easy to simplify (s2 3)1/3 and (s2 3)-(1/3). 
Therefore, we can issue: 
> t2:=subs( sl~(1/3)=s2 , 
sl~(-1/3)=1/s2 , 
> 
sl~(2/3)=s2~2, tl ); 
~ v'6 ((8 cos(%l) + 81 sin(%l)) ((8 cos(%l) + 81 sin(%1))2 + 
64 - 32 cos(%l) - 321 sin(%l)) ) (1/2) / 
(8 cos(%l) + 81 sin(%l)) 
%1 := ~ arctan (1~1 v'687) 
Now the problem is that a complex part of this expression is contained in the ar-
gument of a square root. Let's see what happens when we square the whole thing 
and simplify with option trig: 
> simplify(%~2,trig); 
~ cos(~ arctan(~ v'687)) - ~ 
3 
3 
101 
3 
The result is a real expression. Because of the result of evalf (t 1) it is clear that 
t 1 equals the square root of this expression. 
15.12 Verifying identities 
Manipulation of expressions can be used to verify identities. For instance, we can 
try to check an antiderivative by verifying that its derivative equals the original 
function. Often this can be done by applying normal to the difference. See section 
4.11 on page 53. But in many cases more manipulation is necessary for verifying 
identities. Sometimes, this proves to be difficult. If the result is numeric, you can 
use evalf to get an indication about it. If it is not, you can ask Maple to execute 
a numeric al test with testeq. 
> testeq( sin(x)/cos(x)=tan(x) ); 
true 
Although this procedure uses numerical tricks, it does not walk into a trap such as 
the following: 
> epsilon:=lO~(-lOO): 
> testeq( sin(x)/cos(x) + epsilon 
tan(x»; 
false 
However, in other cases it does not decide, for instance, 

212 
15. Manipulating algebraic expressions 
> testeq( sin(x+epsilon)~2 + cos(x)~2 = 1 ); 
FAIL 
> testeq( sin(x+epsilon)~2 + cos(x+epsilon)~2 
1); 
FAIL 
Another procedure verify can be used with some more comfort, but it relies on 
testeq. 
If the expression contains radicals, testeq cannot be trusted. This is shown in the 
following example, where a solution of a polynomial equation is tested: 
> pol := x~3+4*x~2+1: 
> solve( pol=O , x ): 
> subs( x=%[2] , pol ): 
> testeq( %=0 ); 
false 
Here symbolic manipulation does the job well: 
> simplify(expand(%%)); 
o 
Moreover, testeq should not be applied to RootOf expressions. It checks equal-
ity of degrees and then uses evalf: 
> testeq(RootOf(_Z~3-1)=RootOf(_Z~3+_Z~2-2)); 
true 
Apart from the cases where the expression contains RootOf or radical subexpres-
sions, testeq is a fast and rather reliable tool. 

15.14 General advice formanipulating 
213 
15.13 Reliability 
The results of the manipulations discussed in this chapter are reliable in release V.s 
and release V.4 (apart from possible bugs: nothing is perfect) with the folIowing 
exceptions: 
• simplifyand combine with the option symbolic use simplification rules 
without checking conditions, as asked by this option; 
• evalc expects alI variables to be real; if that is not the case, you might get 
incorrect results; 
• intentionalIy, radsimp does not respect the standard branch cuts; results must 
be checked. 
In fact, these exceptions are choices of the developers of Maple. In the old release 
V.3 it is more difficult to guarantee reliability; in the following cases conditions are 
not checked: 
- expand in combination with powers, possibly powers ofnonpositive numbers 
with undetermined exponents; moreover, it may convert expressions contain-
ing In in a way that may not be correct if an argument to In is not a real number. 
Remedies: expandoff (In) and/or frontend: see earlier in this chapter 
- combine( ,power) with noninteger powers of nonpositive numbers 
- simplify( ,In) with logarithms of products and powers. Moreover, it may 
convert the composition of In and x ~ eX into the identity function when the 
argument is not a real number and not even an element of R x < -1f, 1f] 
- simplify( ,arctrig) with compositions of arc trigonometric functions and the 
corresponding trigonometric functions, sometimes simplifying these to the 
identity function without checking that the arguments are in the correct range. 
15.14 General advice for manipulating 
In manipulating expressions with Maple, do not apply the general tools blindly. 
Many inexperienced users tend to use simpIify first, and if the result is not satis-
factory, they try to manipulate this result with other procedures. Genera11y, that is 
not a good method. First, think what you would do by hand. Then you may want to 
use more specific tools such as factor, evaIc, or expand. Ifnecessary, analyze 
an expression with op, nops, and whattype, possibly with numboccur. 
If you want to use simplify, remember that simplify without a specific option is 
a very general tool, sometimes yielding the desired result, but of ten making things 
worse or even hopeless by doing too much. Often, normal is a better general tool, 
especially for checking if something equals zero. 

chapter 16 
Solving equations and inequalities in general 
In Chapter 14, Polynomial equations and factoring polynomials, many aspects of 
solving equations and sets of equations with Maple are discussed, but restricted to 
polynomial and rational equations. The present chapter examines more general 
types of equations and also inequalities. 
This vast field is difficult and juli of pitfalls for a symbolic calculator. The present 
chapter shows how the user can coopera te with the system and how common and 
basic mathematics can help considerably. 
Most ofthe examples are basic ones, but the same methods and ideas can be used 
in more complicated cases. 
16.1 General principles in using Maple for solving equations 
and inequalities 
Maple's powerful procedure solve can of ten tind solutions. For polynomial equa-
tions the results are reliable, but in general you cannot be sure, so you better check 
the solutions. 
No one expects an automatic solver to tind aH solutions of every equation, so the 
user must decide if alI solutions have been found, and, if solutions are missing, try 
to help Maple in tinding those missing solutions. 
GeneraHy, there are three tasks left to the user when solving equations with Maple: 
1. The results of sol ve must usualIy be checked by substituting them into 
the equations and applying simplitications, approximations, or the procedure 
testeq. See section 15.12 on page 212. Be careful when the equations con-
tain parameters: Maple interprets them as abstract objects and does not bother 
about special values of these parameters. See section 1.3 on page 6. 
2. Try to discem whether aH solutions have been found or not. Again, be careful 
when your equations contain parameters and you want to substitute values: 
think about special cases. 
3. If sol ve cannot tind aH the solutions on its own, you can think about methods 
to be used by hand, for instance looking for pattems in the equations, guessing 
solutions, possibly substituting variables for subexpressions in order to obtain 
equations that are easier for Maple to handle, such as polynomial ones. (See 
again for instance section 1.3 on page 6.) Then try to execute your plan, using 
Maple as a too1. 
E. Kamerich, A Guide to Maple
© Springer Science+Business Media New York 1999

16.2 An example: a trigonometric equation 
215 
Generally, the procedure sol ve tries to tind an complex solutions. 
There are no facilities to re strict the domain, for instance to positive numbers. But 
there is a procedure isol ve for solving equations over the integers. 
16.2 An example: a trigonometric equation 
Here is an example: 
> eq := 6*sin(x)~3 + 11*sin(x)~2 - 3*sin(x)=2; 
eq:= 6 sin(x)3 + 11 sin(x)2 - 3 sin (x) = 2 
> solve(eq,x); 
~ 11', - arcsin( ~), - arcsin(2) 
As you might guess, Maple has solved this equation in two steps: 
> solve( eq , sin(x) ); 
1 -1 
-
-
-2 
2' 3 ' 
> map(arcsin,[%]); 
[ ~ 11', - arcsin( ~), - arcsin(2) ] 
From the tirst result, you can tind easily all real solutions: t1l' + 2k1l', ~11' + 2k1l', 
- arcsin( ~) + 2k1l' and 11' - arcsin( ~) + 2k1l', for anY integer k. But so can Maple, 
if you ask for that: 
> _EnvAllSolutions:=true; 
_EnvAliSolutions := true 
> solve( eq ); 
1 
2 
1 
1 
611'+311' _Bl"" +2 LZl"", - arcsin(3)+2 arcsin(3) .El"" 
+211' _ZI"" +11' .El"", - arcsin(2) + 2 arcsin(2) _Bl"" 
+211' _ZI"" +11' .El"" 
This rather cryptic answer is to be read as follows: 
• _BI"" is to be understood as a binary: O or 1 
• _ZI"" is to be understood as an integer 
Unfortunately, these variables are not easily accessible. (For programmers: in fact, 
they are local variables of procedures called by sol ve.) For instance, the follow-
ing substitution does not work: 

216 
16. Solving equations and inequalities in general 
> subs ( _21=4, _81=0, [%] ); 
[ 1 
2 
6"1f + 31f -.81,..., +21f _ZI,..." 
-
arcsin(~) + 2 arcsin(~) _El,..., +21f -ZI,..., +1f -.81,..." 
- arcsin(2) + 2 arcsin(2) -.81,..., +21f _ZI", +1f -.81", ] 
Here you can see how to handle this. First, it is practical to name the solution: 
> sinsol:=%%: 
The indeterminates in an expression can always be found with indets: 
> pars:=indets([%]); 
{_El"', _ZI,.,." -.81"" _ZI"" -.81"" _ZI", } 
You can see what these parameters are meant to be: 
> about(pars); 
{_B1, _Z1, _B1, _Z1, _B1, _Zi}: 
is used in the following assumed objects 
[_B1] assumed OrProp(O,l) 
[_B1] assumed OrProp(O,l) 
[_Z1] assumed integer 
[_Bl] assumed OrProp(O,l) 
[_Zi] assumed integer 
[_Z1] assumed integer 
but be careful: don't look for the order in the result of about. This is not neces-
sarily equal to the order of the argument. 
Now we can substitute, for instance: 
> subs(pars[1]=O,pars[2]=3,pars[3]=O,pars[4]=-2, 
> 
pars[5]=1,pars[6]=O,[sinsol]); 
[ 3: 1f, _ arcsin( ~) - 41f, arcsin(2) + 1f ] 
You can tind all real solutions in acertain range, say between -21f and 21f, by look-
ing at the solution and making suitable choices for these parameters. In more com-
plicated cases, you might prefer to leave this work to Maple as in the following. 
We will also pretend not to see that arcsin(2) is not a real number. 
First, we make a sequence of solutions, then we will select the ones that are real and 
lie in the [-21f, 21f]. It is still necessary to choose good ranges for the parameters, 
but that can be done rather roughly: 
> seq(seq(seq(seq(seq(seq( 
> 
subs(pars[1]=k1,pars[2]=k2,pars[3]=k3, 
> 
pars [4] =k4,pars [5]=k5,pars [6]=k6, 
> 
[sinsol] ) , 

16.2 An example: a trigonometric equation 
> 
k1=O .. 1),k2=-2 .. 2),k3=O .. 1),k4=-2 .. 2), 
> 
k5=O .. 1),k6=-2 .. 2): 
This is a sequence of lists. Let's convert it into a set: 
> map(op,{%}); 
{ arcsin(~) + 311', arcsin(~) -11', arcsin(~) + 511', 
1 
arcsin(2) - 311', arcsin("3) - 311', arcsin(2) + 11', 
arcsin(~)+lI', ~11',- arcsin(~), - arcsin(2) +211', 
23 
19 
11 
7 
5 
- arcsin(2) + 411' - -
11' - -
11' - -
11' - - 11' - 11' 
, 
6 
' 
6 
' 
6 
' 
6 '6 ' 
17 
25 
29 
. 
1 
13 
-11' -11' -11' - arcsm(-) - 411' -11' 
6'6'6' 
3 
'6' 
- arcsin(2) - 411', arcsin(2) + 311', 
- arcsin(2) - 211', -
arcsin(~) - 211', arcsin(2) - 11', 
-
arcsin(~) + 211', -
arcsin(~) + 411', - arcsin(2), 
arcsin(2) + 511' } 
217 
To avoid equal elements, we have made a set of alI values. This set contains some 
nonreal elements. Let's select the real elements. 
> select(x->(x=evalc(Re(x))),%): 
In this simple case, we can trust the condition x=evalc, because evalc can handle 
simple arcsin expressions perfectly. In more complicated cases, you could use: 
> select(x->(fnormal(evalf(x))=evalc(Re(evalf(x)))),%): 
Now that alI elements are real, we can remove the elements that are greater than 
211' Of smaller than -211': 
> remove(x->(evalf(x»evalf(2*Pi)),%): 
> remove(x->(evalf(x)<evalf(-2*Pi)),%); 
{ 
. (1) 
. (1) 
1 
. (1) 
11 
7 
arcsm -
-11' arcsm -
+11' -11' - arcsm -
--11' --11' 
3' 
3 
'6' 
3' 6' 6' 
~ 11', - arcsin( ~) + 211' } 
At last, you might want a list of the numeric approximations in ascending order: 
> sort(evalf([op(%)],3),numeric); 
[-5.75, -3.67, -2.80, -.340, .524,2.62,3.48,5.94] 
Now let's test this re suit by a plot: 
> lhs(eq)-rhs(eq); 

218 
16. Solving equations and inequalities in general 
6 sin(x)3 + 11 sin(x)2 - 3 sin (x) - 2 
> plot(%,x=-2*Pi .. 2*Pi)j 
12 
10 
8 
-4 
-2 
-2 
We can see that the zeros match the found solutions. 
So we have checked in two ways that alI solutions have been found: 
a. by calculating the solutions in steps, where sol ve is applied only to a poly-
nomial equation (in sin (x); 
b. by numeric approximation of the solutions and comparing them with a plot. 
16.3 Another example: an exponential equation 
Here is another example: 
> eq := exp(3*x) = «-9*q+27)*exp(2*x)-9*q*exp(x))/ 
> 
(3*exp(2*x)+(3-q)*exp(x)-q-27)j 
eq .= e(3 x) = 
(-9 q + 27) e(2 x) - 9 q eX 
. 
3e(2x)+(3-q)eX -q-27 
> sol := solve(eq,x)j 
1 
sol := ln( -3), ln(3), 1 1f, ln( 3 q) 
We tind a set of four solutions, which can be checked easily by substituting each 
of them into the equation and applying simplify. 

16.4 No solutions found 
219 
> seq(simplify(subs(x=sol[k],lhs(eq)-rhs(eq))),k=1 .. 4); 
0,0,0, ° 
Now the question must be asked if alI solutions have been found. If you are only 
interested in real solutions, you could enter a value for q and try to check with a 
plot if alI real solutions have been found, but that does not ensure that this is the 
case generally. 
The other way is finding the solutions stepwise. That is easy here: you can do the 
same as what you would do by hand: 
> expand(eq); 
( X)2 
( X)2 
x 
(eX )3 = -9~ 
+ 27_e_ 
-9~ 
%1 
%1 
%1 
%1 := 3 (eX )2 + 3ex - qeX -
q - 27 
> solve(%,exp(x)); 
1 
0, -3,3, -1, 3 q 
For no value of x the value of exp(x) can be zero. If we apply ln to the other 
solutions, we find the solutions rendered by sol ve (eq, x). However, sol ve has 
not found all solutions, "forgetting" to add alI integer multiples of 21fi. The fulI 
solution is: 
1 
ln(-3) + 2 k1f 1, In(3) + 2k1f 1, I1f + 2k1f 1, In(3 q) + 2k1f 1 
where k takes alI integer values. 
16.4 No solutions found 
If you present a system of equations to Maple, you must provide all the variables 
for which it is to be solved. For instance: 
> {x+y=3,x-y=5}; 
{ x + y = 3, x - y = 5 } 
> solve( % , x ); 
No solution is found because there is no value for x that makes both equations iden-
tities in y. So no result is printed on the screen. 
If Maple does not find a solution, it retums nothing at alI and keeps silent. How-
ever, by putting 
> infolevel[solve] :=1: 
Maple telIs if no solutions have been found. For instance: 
> solve( cos(x) = ln(x-2) , x ); 

220 
16. Solving equations and inequalities in general 
solve: 
Warning: no solutions found 
solve: 
Warning: solutions may have been lost 
The infolevel can be reset by 
> infolevel[solveJ :=0: 
16.5 Inequalities and systems of inequalities 
The procedure sol ve can handle some types of inequalities, for instance: 
> solve(x~2<9,x); 
RealRange(Open( -3), Open(3)) 
The solution above can be read as the open interval < -3,3 >. 
> solve(x~2>25,x); 
RealRange( - 00, Open( -5)), ReaIRange(Open(5), 00) 
The solution of the last inequality can be read as a union of the open intervals: 
< -00,-5> U < 5,00 >. 
> solve({x~2-x<1,x>-1,x<1},x); 
{ x < 1, RootOf(_Z2 - _Z - 1, -.6180339887) < x } 
> convert(%,radical); 
{ x < 1, ~ - ~ vIS < x } 
Here a different notation is used: ~ -
~ J5 < x AND x < 1. 
The RootOf expression in the first result has a second argument, indicating which 
radical should be chosen: 
> RootOf(_Z~2 -
_Z - 1, -.6180339887); 
RootOf(_Z2 - -Z - 1, -.6180339887) 
> convert(%,radical); 
1 
1 
-- -J5 
2 
2 
If this argument had been omitted, convert ( 
other radical: 
> RootDf CZ~2 -
_Z - 1); 
,radical) would render the 
RootOf(_Z2 - -Z - 1) 
> convert(%,radical); 

16.6 Manipulating equations and sets of equations 
1 
1 
-+-V5 
2 
2 
Don't try to use allvalues in this context, it makes no sense. 
221 
The following type of problem cannot be solved by sol ve (up to rele ase V.5): 
> solve({sin(x)<1/2,x>-3,x<3},x); 
Here is another example: 
> solve(l/x<l,x); 
RealRange( - 00, Open(O)), RealRange(Open(l), 00) 
Using parameters in inequalities is rather restricted. 
Systems of linear inequalities and equalities can be handled as follows: 
> sOlve({x+y<5,x-2*y>-7,y>-10},{x,y}); 
{x < 15, -10 < y, x + Y - 5 < 0, -7 - x + 2y < 0, 
-27 < x, y < 4} 
> solve({x+y=5,x-2*y>-7,y>-10},{x,y}); 
{ -10 < y, x = - y + 5, y < 4} 
For linear programming see the package simplex. 
16.6 Manipulating equations and sets of equations 
There are many possibilities for manipulating equations and systems of equations 
apart from the most obvious tool, substitution. The standard tools are demonstrated 
here. We apply these to the following two equations: 
> x+l=y; eql:=%: 
x+1=y 
> u+(x-l)-2=w; eq2:=%: 
u + (x _1)2 = W 
• Take the left-hand side and right-hand side with Ihs and rhs: 
> lhs(eql); rhs(eql); 
x+1 
y 
• Add or subtract the same element to/from both sides: 

222 
16. Solving equations and inequalities in general 
> lhs (eq2)-%=rhs (eq2)-%; 
u = w - (x _1)2 
The element added to both sides has been entered first, then used by quoting. 
This prevents typographical errors such as: 
> lhs(eq2)-(x-l)~2=rhs(eq2)-(x-l~2); 
u=w-x+1 
• Multiply both sides with the same factor: 
> p*eql; 
p(x+1)=py 
• Apply a function or other procedure to both sides with the aid of map: 
> map(sqrt,eql); 
v'x+I = vy 
• Some procedures can be applied in a direct way: 
> expand(eq2); 
• Add two equations: 
> eql + eq2; 
u + x 2 - 2 x + 1 = w 
x + 1 + u + (x - 1)2 = y + w 
• Divide (or multiply) two equations: 
> lhs(eql)/lhs(eq2)=rhs(eql)/rhs(eq2); 
x + 1 
y 
2--
U + (x -1) 
w 
• Combine two equations by simplification to side relations. See section 11.11 
on page 147, section 14.11 on page 186, and section 15.9 on page 203. For 
instance, we can use eql for simplification of eq2: 
> simplify(eq2,{eql}); 
u + 4 - 4 y + y2 = W 
Here Maple has chosen to eliminate x. If we prefer elimination of y as far as 
possible, then we can add a third argument [y]: 
> simplify(eq2,{eql},[y]); 
u + x 2 - 2 x + 1 = w 
This simplification uses Grobner basis methods for polynomials. However, 
this method is not restricted to polynomials. Here is an example: 

16.6 Manipulating equations and sets of equations 
223 
> exp(x)*exp(y) = exp(x)**2-t; 
eX eY = (eX ) 2 - t 
> exp(x)-l=u*exp(x); 
> simplify(%%,{%},[exp(x)]); 
eY 
t - 2 u t + u2 t - 1 
---= 
-1 + u 
1 - 2 u + u2 
• Sometimes, the procedure isolate can be used, which must be read from the 
library when it is used for the first time in a session: 
> (a-b*cos(x»/(c-d*cos(x»=t-5; 
a-bcos(x) =t-5 
c - d cos(x) 
> readlib(isolate)( % ,cos(x) ); 
a-tc+5c 
cos(x)=- -b+td-5d 
Be careful with this procedure: ifthere is more than one possibility, isolate 
makes a choice from among them. 
> 6*cos(x)-2 - 5*cos(x) - 1 = O; 
6 COS(X)2 - 5 cos (x) - 1 = O 
> isolate(%,cos(x»; 
-1 
cos(x) = 6 
• You might want to assign the solutions to the variables. This can be done eas-
ily with assign: 
> solve({X+2*Y=a,3*X-Y=b},{X,Y}); 
> assign(%); 
> X,Y; 
{ Y=~a-~b x=~a+~b} 
77' 
7 
7 
1 
2 
3 
1 
-a+-b -a--b 
7 
7 ) 7 
7 

224 
16. Solving equations and inequalities in general 
16.7 Solving equations numerically 
For solving equations and sets of equations in a numeric al way, the procedure 
fsolve can be used. When solving a polynomial equation, fsol ve tries to find ap-
proximations to alI real solutions (or, with option complex, alI complex solutions) 
and generaIly succeeds. For more general equations and sets of equations f sol ve 
is content with just one solution. For instance: 
> eq := ln(x)=x-2; 
eq:=ln(x)=x-2 
> plot( {lhs(%),rhs(%)} , x=0.01 .. 10 ); 
6 
4 
o 
-2 
-4 
> fsolve(eq,x); 
.1585943396 
From the graph of In it is clear that there should be a solution between O and 1. We 
can ask for this solution with the aid of an option x=O .. 1: 
> fsolve( eq , x , x = O .. 1 ); 
.1585943396 
There is no solution gre ater than 4, but we can ask for such a solution: 
> fsolve( eq , x, x = 4 .. infinity ); 
fsolve(ln(x) = x - 2, x, x = 4 ... 00) 
If fsol ve cannot find a solution of a nonpolynomial equation, it may keep silent 
or retum the command unevaluated. 
It is possible that a root exists, although f sol ve cannot find one, but that is a very 
rare exception. 

16.8 S01ving systems of equations numerically 
225 
16.8 Solving systems of equations numerically 
Systems of equations can be given to fsol ve in the same way as to sol ve. Here 
is an example that can be solved in an exact way as well. 
> eql := cos(x)*sin(y)~2 + 6*sin(y) = 4*cos(x)j 
eq1 := cos(x) sin(y)2 + 6 sin(y) = 4 cos (x) 
> eq2 . - 2*x+3*y=Pij 
eq2:=2x+3Y=7r 
> fsolve( {eql,eq2} , {x,y} )j 
{ y = -8.936914292, x = 14.97616777} 
Another solution {y=O , x=7r/2} can be seen directly. We can try to find this 
with fsolve by specifying ranges as a third option: 
> fsolve( {eql,eq2} , {x,y} , {x=l .. 3, y=-l .. 1} )j 
{x = 1.571798612, Y = -.0006681900122} 
This is the desired solution, but it is not very accurate. Trying to improve the ac-
curacy by enlarging Digi ts is not always successful: 
> Digits:=20: 
> fsolve({eql,eq2}, {x,y}, {x=1.5 .. 1.6, y=-.l .. O.l})j 
{x = 1.5707967777287823174, Y = -.3006225904654406354610- 6 } 
We get no better result. Let's try to improve the perforrnance by guiding Maple 
step by step, taking advantage of the fact that the second equation is easy. 
> solve(eq2,x)j 
3 
1 
--y+-7r 
2 
2 
There would be no reason to use f sol ve in this first step; it would even be impos-
sible, as f sol ve cannot cope with an unspecified parameter y. 
> subs(x=%,eql)j 
3 
1. 
. 
3 
1 
cos( - -2 Y + - 7r) sm(y)2 + 6 sm(y) = 4 cos( - - y + - 7r) 
2 
2 
2 
> fsolve( % , y , y=-l .. l )j 
o 
More details can be found in the on-line help for fsolve. 

226 
16. Solving equations and inequalities in general 
16.9 Series of an implicitly defined function 
Suppose that we have a parameterized equation in x: Jt (x) = O and a value to such 
that one or more solutions of the equation Jto (x) = O are available: say Jto (xo) = 
O. Then you might be interested in a parameterized extension x( t) of this solution. 
From an implicit function theorem we know that, if Jlo -:f. O and ft (x) depends on x 
and t in a continuous way, then there is a parameterized solution x(t) of ft(x) = O 
for t in a neighborhood of to such that Xto =Xo. 
If the parameter t does not have a special value, it may be impossible to solve ex-
plicitly the equation for x, but you might be interested in a series approximation to 
t -t x(t) in to. For instance: 
> eql:=exp(t*x)=x*exp(x)+exp(t); 
eq1 := e(tx) = xex + et 
It is easy to see that {x = O, t = O} satisties this equation. We can calculate a 
series expansion in t = O of a function t -t x( t) on a neighborhood of O, satisfying 
e(tx) = x eX + et , as follows: 
First we must convert the equation into a series: 
> lhs(eql)-rhs(eql); 
> series( % , x=O , 5 ); 
( 
t) 
(1 2 ) 2 (1 1 3) 3 
1-e +(t-1)x+ "2t -1 x + -"2+6"t 
x + 
(_~ + ~ 
t 4 ) x 4 + O(x5 ) 
6 
24 
The procedure sol ve perceives this series as an equation (appending "=0") and it 
tries to tind a series as a solution. 
> solve(%,x); 
5 2 
43 3 
569 4 
( 5 
-lt - -t - -t - -t + O t ) 
2 
6 
24 
Let's check this result by substituting: 
> convert(%,polynom); 
_ t _ ~ e _ 43 t3 _ 569 t4 
2 
6 
24 
> subs(x=%,eql); 

16.9 Series of an implicitly defined function 
227 
e( (-1/24 t2(24+60t+172 t2+569 t3))) = 
-t--t --t --t e 
2 
6 
24 
+ 
( 
5 2 43 3 569 4) (_t_Qt2_fit3_569 t4) 
2 
6 
24 
This is not an exact identity, but the difference of the left-hand side and the right-
hand one should be of order 5: the orderofthe seriesequation thathas been solved. 
To show this more clearly we can ask for a series expansion of order 6. 
> series( lhs(%)-rhs(%) , t=O , 6 ); 
_ 2579 t5 + O(t6 ) 
30 
The result is of order 5, the same as the order of the original series. Apart from the 
order of the Iasi series expansion there are two Iimiters to the order of the result: 
1. the order of the series to which sol ve is appIied 
2. the value of the variable Order. See section 8.2 on page 109. 
In order to tind a solution series of order n, both Iimiters should be at least n. Here 
is a pitfall: if only the variable Order is raised, the order of the series expansion 
of the equation being high enough, the procedure sol ve yields no better result, 
because it only picks up the resuIt from the remember table of one of its subproce-
dures, when it gets the old arguments. Therefore, in any case, raise both together 
before you ask Maple to solve again. For remember tables, see Appendix D, Pro-
cedures remembering previous results. 
From the series expansion of t ---+ x( t), its derivative in O can be read as the coef-
ticient oft, in this case -1. This can also be calculated with diffimplicit. 
In the previous calculation we have used series expansion of the equation to x, but 
we can use series expansion to t as weIl: 
> series(lhs(eql)-rhs(eql),t=O,5); 
x 
( 
) (1 1 2) 2 (1 3 1) 3 
- xe + x - 1 t + -"2 + "2 x 
t + 6 x - 6 t + 
(214 x 4 -
2~) t 4 + O(t5 ) 
> solve(%,x); 
5 2 
43 3 
569 4 
5 
-t - -t - -t - -t + O(t ) 
2 
6 
24 
The re suit is the same. 
Obviously, this method fails if no zeroth-order solution can be found. For instance, 
Maple cannot solve for x from the equation in the case t = 2: 

228 
16. Solving equations and inequalities in general 
> subs(t=2,eq1); 
> solve(%,x); 
The probIem is transiated into a RootOf expression; Maple finds no solutions. This 
is why the following sol ve command has no resuIt: 
> series( lhs(eql)-rhs(eql) , t=2 , 5 ); 
(e(2X) _ xex - e2) + (e(2X) x - e2) (t - 2) + 
(_~e2 + ~e(2X) x 2 ) (t _ 2)2+(~e(2X) x 3 _ ~e2) (t _ 2)3+ 
(~ e(2 x) x4 _ ~ e2) (t - 2)4 + O((t _ 2)5) 
24 
24 
> solve( % , x ); 
Here is another exampIe, this time with more than one solution: 
> eq2 := x~2*exp(t)=2*t*x+l; 
eq2 := x 2 et = 2 t x + 1 
If we want a series solution for x in a neighborhood of t = O, Maple must solve 
the following equation: 
> subs(t=O,eq2); 
> solve(%,x); 
1, -1 
So we may expect two series solutions. 
> series(lhs(eq2)-rhs(eq2),t=O,5); 
1 
1 
1 
(x 2 -1) + (x2 - 2x) t +"2 x2t2 +"6 x 2t 3 + 24 x 2t4 + O(t5 ) 
> solve(%,x); 
1 
3 2 
13 3 
35 
4 
5 
3 
13 2 
1+"2t-gt -48 t + 128t +O(t),-1+"2t -st + 
61 t3 _ 233 t4 + O(t5 ) 
48 
384 

16.10 Recurrence relations 
229 
16.10 Recurrence relations 
There is a procedure available for solving recurrence re1ations: rsolve. For in-
stance, we can calculate formulas for the generalized Fibonacci sequence a, b, a+b, 
a + 2b, 2a + 3b, ... as follows. Here is the defining equation: 
> fibo := F(n)=F(n-l)+F(n-2); 
fibo := F(n) = F(n - 1) + F(n - 2) 
and the initial values: 
> fibinit := F(l)=a, F(2)=b; 
fibinit := F(1) = a, F(2) = b 
Now we can apply the procedure rsol ve to obtain an explicit formula for the nth 
element of the sequence: 
> rsolve({ fibo , fibinit } , F(n) ); 
1 (2V5-5) (2a+b+V5b) (-2~r 
'5 
1-V5 
1 (5+2V5) (2a+b-V5b) (-2~r 
'5 
1+V5 
Let's test the formula by calculating the fourth element: 
> normale subs(n=4,%) , expanded ); 
a+ 2b 
The same procedure can also try to calculate the generating function of the solu-
tion of a recurrence relation. The necessary option genfunc (t) must be entered 
between forward quotes to avoid c1ashing with a package of the same name. 
> rsolve({ fibo , fibinit }, F(n) , 'genfunc'(t) ); 
- a t - b t2 + a t2 
-1 + t + t 2 
As an example, let's calculate from this result the first seven elements of the se-
quence. These can be found as the coefficients in the series expansion of this result 
up to order 8: 
> series( % , t , 8 ); 
at + bt2 + (a+b)t3 + (a+2b)t4 + (2a+3b)t5 + 
( 5 b + 3 a) t6 + (5 a + 8 b) e + O ( t8 ) 
More tools for linear recurrence relations are available in the package LREtools. 

230 
16. Solving equations and inequalities in general 
16.11 Solving identities, matching pattems 
There are two procedures for solving identities and pattern matching in MapIe: 
sol ve applied to an identity, and match. 
First a simple problem: for which a and b is x + c = x:tba ? 
> eq:=x+c=(x~2+a)/(x+b); 
x 2 +a 
eq := x + c = ---
x+b 
> solve(identity(eq, x),{a,b}); 
{a=-c2,b=-c} 
Let's solve the same probIem with match: 
> match(eq,x,'sol'); 
true 
The result true aftirms that Maple can match both sides of the equation by sub-
stituting suitable values for the variables in the right-hand side. The substitution 
chosen by Maple has been assigned to the third argument: 
> sol; 
The procedure match tries to tind values for the parameters of the right-hand ex-
pression in order to make this identical to the Ieft side. Therefore, we get no result 
if the Ieft-hand side and the right one are exchanged in the present example: 
> rhs(eq)=lhs(eq); 
x 2 +a 
--- =x+c 
x+b 
> match( %, x , 'sol' ); 
false 
Here match tries to tind a value for c such that the left-hand side equals the right-
hand side; this is impossible. 
Apart from this question, there are cases where match is successful and sol ve 
(identi ty ( 
), 
) is not, and other cases where the reverse is true. If you 
don't succeed with one of them, try the other. 

16.12 Other procedures for solving 
231 
16.12 Other procedures for solving 
Differential equations must be solved with the procedure dsol ve, which is dealt 
with in Chapter 17, Solving diJferential equations. 
Systems of linear equations can also be solved with the aid of linear algebra. See 
section 18.10 on page 257. 
A procedure isol ve is available for solving equations in integer variables, and 
a procedure msolve is available for solving equations in variables over Z mod 
m. 

chapter 17 
Solving differential equations 
This chapter introduces the main tools for handling differential equations with ex-
act or approximate methods, andfor graphics in this field. This field is developing 
at a great pace; Maple now offers a lot more tools than the basic ones, demon-
strated in this chapter. 
17.1 Ordinary differential equations (ODEs): 
denoting, solving, checking solutions 
Let's start with one of the most basic differential equations: y" = -y. Both sides 
of the equation are functions. In Maple notation, both must be applied to an argu-
ment, say x: 
> diff( y(x) , x , x ) = -y(x) ; 
82 
8x2 y(x) = - Y(x) 
If y is entered without argument x, the output indicates c1early that something is 
wrong: 
> diff( y , x , x ) = - y; 
0= -y 
A recurring mistake is forgetting the argument only for the undifferentiated func-
tion, like this: 
> diff( y(x) , x , x ) = -y ; 
82 
8x2 Y(x) =-y 
This is not correct: the Ieft-hand side is the second derivative at x, while the right-
hand side is a function, not the value of this function at x. Maple does not accept 
it: 
> dso!ve(%); 
Error, (in ODEtools/info) y(x) and y cannot both appear in the 
given ODE. 
For checking purposes, Iet's assign the given differential equation to a name. 
E. Kamerich, A Guide to Maple
© Springer Science+Business Media New York 1999

Ordinary differential equations (ODEs) 
> deql := %%%; 
82 
deql := 8x2 y(x) = - Y(X) 
Maple can solve this ODE with dsolve: 
> dsolve(%); 
Y(x) = _CI sin(x) + _C2 cos(x) 
233 
In this case, dsol ve can detennine what to tind, but generalIy we must telI that by 
a second argument: 
> dsolve( deql , y(x) ); 
y(x) = _CI sin (x) + _C2 cos(x) 
In fact, Maple tries to tind a function y, but expresses the solution as y( x). That is 
the reason that the second argument should not be y, but y(x). 
The result found by dsol ve contains the expected integration constants: _CI and 
_C2. Names starting with an underscore are used by Maple for special purposes 
and should never be assigned values by the user. 
It is c1ear that this solution is correct and that alI solutions have been found, but 
generally you can't be sure, and then you must check the found solutions and you 
must decide by mathematical arguments if a full set of solutions has been found. 
Solutions can be checked with Maple. In release V.5, you can use odetest: 
> odetest(%,deql); 
o 
The result O proves that the solution is correct. (Sometimes some extra manipula-
tion is necessary to tind O; see also section 15.12 on page 212.) 
In earlier releases, don't use assign in this case, as you could for solutions of sys-
tems of equations; if you want to assign the corresponding function to y, issue 
y: =unapply (rhs (%) , x) ; (see section 6.7 on page 77). We will not assign the 
solution, only substitute it: 
> subs( %% , deql ); 
::2 _CI sin(x) + _C2 cos(x) = - _CI sin(x) - _C2 cos (x) 
> normal( lhs(%)-rhs(%) ); 
o 
Sometimes more manipulation is necessary, but the above demonstrates the stan-
dard tirst try. 

234 
17. Solving differential equations 
17.2 Ordinary differential equations with initial conditions 
Let's solve the same ODE with initial conditions. Suppose that y'(O) = ~. This 
is expressed as D(y) (0)=1/2: take the derivativejimction ofy and apply this to 
1/2. Moreover, let's suppose y(O) = 1. 
> {diff(y(x),x,x) = - y(x) , D(y)(0)=1/2, y(0)=1}; 
1 
82 
{ D(y) (O) = 2' Y(O) = 1, 8x2 y(x) = - Y(x) } 
An ODE with initial conditions is entered as a set of equations. For checking pur-
poses let's assign this set to a name before solving it. 
> deq2 := % 
> dsolve( % , {y(x)} )j 
y(x) = ~ sin (x) + cos(x) 
Checking this solution is a little more complicated as the operator D expects a func-
tion. So we must make a function of the result of dsol ve before substituting. See 
section 6.7 on page 77. 
> unapply( rhs(%%) , x ); 
x -+ ~ sin(x) + cos(x) 
> subs( y=% 
,deq2); 
{ I I  
D(x -+ 2 sin(x) + cos(x)) (O) = 2' 
(x -+ ~ sin(x) + cos (x) ) (O) = 1, 
::2 (x -+ ~ sin(x) + cos(x)) (x) = 
- (x -+ ~ sin(x) + COS(x)) (x) } 
We can check the equations in the system with the same method as previously, with 
the aid ofmap: 
> map( eq -> normal( lhs(eq) - rhs(eq) ) , % )j 
{O} 
You may dislike the use ofD and diff in combination. Altematively, the previous 
system of equations can be denoted by 
> { D(D(y)) (x) = - y(x) , y(0)=1 , D(y) (0)=1/2 }j 
{ D(y) (O) = ~, Y(O) = 1, (D(2») (y) (x) = - Y(x) } 

17.3 Implicit solutions and checking them 
235 
which makes a nicer input line but a less readable output. For detailed information 
about acceptable forms for initial conditions, see the on-line help for dsol ve, Ies. 
17.3 Implicit solutions and checking them 
Here is another example, the differential equation: 
yy' = xy+x-x 
> de3 ;= y(x) * diff(y(x) ,x) = x*y(x)-2 + x - x-3; 
de3 := Y(x) (:x Y(x)) = X Y(X)2 + x - x3 
In order to have an idea of the possible solutions let's plot the direction field of this 
differential equation: 
> DEtools[dfieldplot] (de3, y(x), x=-3 .. 3, y(x)=-3 .. 3); 
Now let's solve it: 
> dsolve( de3 , y(x) ); 
y(x) = J x2 + e(x2 ) _CI, Y(x) = - J x2 + e(x 2 ) _CI 
We find two solutions; obviously, dsol ve has found an implicit solution and then 
solved this equation to y(x). If you preferthe implicit solution, you can try the 
option 'implicit': 
> dsolve( de3 , y(x), 'implicit'); 
Y(X)2 _ x2 - e(x 2 ) _CI = O 

236 
17. So1ving differentia1 equations 
If you want a parametric solution, you can try dsol ve ( 
, , implici t' , 
'parametric' ). (In the present case, that is not successful.) 
Sometimes, dsol ve itself chooses to render an implicit solution. In such a case, 
you can ask for an explicit solution, if possible, with the option 'explicit' . 
In the present example, it is not difficult to see that all local solutions of the dif-
ferential equations are represented in the result, if it is correct. Let's check it. In 
release V.5 you can check the results again with odetest: 
> odetest( % , de3 ); 
o 
For earlier releases, you can check implicit solutions by substituting and using side 
relations (see section 11.11 on page 147) as follows. In the set ofrelations we 
gather the solution and the derivative of the solution, because the ODE contains 
Y(x) and tx Y(x) 
> rels := { %% , diff(%%,x) }; 
rels := {2 Y(x) (! Y(x)) - 2x - 2xe(x2 ) _CI 
O, Y(X)2 - x2 - e(x 2 ) _CI = O } 
Then we can ask Maple to eliminate y(x) and tx y(x) as far as possible by applying 
simplification to the difference between the left-hand side and right-hand side. 
> simpIify( Ihs(de3)-rhs(de3), rels , 
> 
{ y(x) , diff(y(x),x) } ); 
O 
For a second-order ODE, the second derivative of the solution must also be put 
into the second argument set and diff (y (x) , x, x) into the third argument set. 
In order to check a possible solution (dsol) of a lOth-order ODE (deq) in y (x), 
we can try: 
> simpIify( Ihs(deq)-rhs(deq) , 
> 
{ dsol(x) , seq(diff(dsol(x),x$k),k=1 .. 10) }, 
> 
{ y(x) , seq(diff(y(x),x$k),k=l .. 10) } ); 
This method of checking works in many cases, but sometimes additional manipu-
lations may be necessary. 

17.5 Numerica1 approximations to solutions 
237 
17.4 DESol expressions appearing in solutions 
Sometimes, when dsol ve cannot find a solution, it presents an intermediate result 
with the aid of a DESol expression. For example: 
> diff(y(x),x,x,x) + x*diff(y(x) ,x) + (x-1)*y(x) = O; 
(::3 y (x)) + x (:x y (x)) + (x - 1) Y (x) = O 
> dsolve( % , y(x) ); 
y(x) = _CI (6e( - x) + 6 e(- x) x + e( - x) x2 ) + 
(6e(-X) +6e(-X)x+e(-X)x2 ) J 
DESol({ (6+6x+x2 ) 
(::2 _Y(x)) + (-12x - 3x2) (! _Y(x)) + 
(12x + 9x2 + x3 -12) _Y(x)}, {_Y(x)}) dx 
The DESol expression in the last result is a symbolic representation ofthe solutions 
of the differential equation described by the arguments to DESo!. In this case, the 
differential equation is: 
(6+6x+x 2 ) (t:2 _Y(x)) + (-12x-3x2 ) (tx _Y(x)) 
+ (12x + 9x2 + x3 -12) _Y(x) = O 
So the solution found with dsol ve has the structure 
_CI f(x) + g(x) J 
s(x)dx 
where s( x) is a symbolic representation of a solution of the last ODE in _Y. 
The DESol construction is discussed in section 17.9 on page 244. 
In some cases the differential equation cannot be solved by dsol ve, but it can be 
reduced with the aid of transformations. In such a case, an intermediate result may 
be presented containing the word &where. If you want to use or manipulate this, 
consult the on-line help for ODESolStruct. 
17.5 Numerical approximations to solutions 
The field of solving differential equations in an exact symbolic way is developing 
rapidly. With each new release of Maple, new algorithms for solving differential 
equations have been added. But there are limits; often, numeric al approximations 
or series developments must be used. 

238 
17. Solving differential equations 
Consider the differential equation: u'(t) = sin(t * u(t». As can be expected, 
dsol ve cannot solve this in an exact way. The present section applies a numerical 
method to this ODE; the next section applies a series method to the same equation. 
> diff(u(t),t) = sin(t*u(t)); 
:t u(t) = sin(t u(t» 
> deq4 := %: 
Before solving, let's plot the direction field of this ODE with the procedure 
DEtools[dfieldplot]: 
> DEtools[dfieldplot] (deq4, u(t), t=O .. 7, u(t)=O .. 3); 
3 
II~\\/II\\~I//\\-I! 
2.8 
1 I~\ \~I I~\ \~! I~\ \~I 
2.6 . 1 f/ \ \ '-./ / 1 \ \ V /1 ..... \ \-
11/\\\/11--\\\111 ..... \\ 
2.4 
1 1 1'-. \ \ ~I 1 I~ \ \ '-./ / 1 ~ \ 
2.2 
1 1 / ..... \ \ \/1 11'-. \ \ '-.1/ 1/ 
2- 1/1--\\\ ...... 1///\\\\/// 
. I/!/'-.\\\~//!/'-.\\\~I 
1.8 1!!1_\\\\ __ I!lI~\\\\ 
urol~
' 11/1/'-.\\\\--1//1--\\\ 
1.4 II/ II~\ \ \ \ \~I ! / 1 I~\ 
1 2 1 1 1 / 1/ ..... \ \ \ \ \ ...... / 1 / / 1 1 
. II//II/ ..... \\\\\\~/II/ 
1 
//!/II//~'-.\\\\\\'-.~/ 
0.8 /1 1 1 / / / 1 1/-'-. \ \ \ \ \ \ \ 
0.6 /1 1 1 / ! 1 ! ! 1 1/"'-""''-. \ \ \ \ 
//IIIII!/!!IIII//~~ 
0.4 // 
/ 111II II ! ! / / / ! 1 1 1 
0.2 
__ / / / / I1111 II II // // 
Let's solve the equation in a numeric al way with the command: 
> Y := dsolve({deq4,u(O)=2},u(t),numeric); 
Y := proc(rkf45...x) ... end 
This strange result says that a function has been assigned to Y that can calculate 
numerical approximations to function values of the solution. For instance: 
> Y(O); Y(i); Y(3); 
[t = O, u(t) = 2.] 
[t = 1, u(t) = 2.669716221353340] 
[ t = 3, u( t) = 1.297705136840902] 
The function Y yields equations determining points of the numeric al solution found 
with dsolve. 

17.6 Series development of a solution 
239 
By additional arguments, the calculation method can be chosen and values of sev-
erai variables controlling the calculations can be changed; see the on-line help to 
dsol ve ,numeric. 
We can get a graph ofthe solution Y with the procedure odeplot, contained in the 
plots package. 
> plots[odeplot]( Y , [t,u(t)] ,0 .. 7 , labels=[t,u] ); 
2.5 
2 
U 
1.5 
0.5 
o 
2 
3
t
4 
67 
The third argument detennines the range of the first coordinate. 
17.6 Series development of a solution 
Another approach to approximation is a local Taylor series expansion. Let's apply 
this to the same ODE as in the previous section. First, let's set the value of Order 
to 20 to obtain a series expansion of order 20. 
> Order:=20: 
Let's apply dsol ve with option series: 
> dsolve( {deq4,u(0)=2} , u(t) , series ); 
u( ) - 2 
t2 _ ~ 4 _ 109t6 _ 1247 8 
193657 10 
t -
+ 
12t 
360 
20160 t + 1814400t + 
15397183 12 
1302729349 14 
41217747869 16 
239500800 t - 43589145600 t 
- 951035904000 t + 
78476591731 
18 
20 
291016986624000t + O(t ) 
Let's compare this solution with the numeric al solution of the previous section by 
plotting it. 

240 
17. Solving differential equations 
> convert( rhs(%) , polynom ); 
2 
2 
1 
4 
109 6 
1247 
8 
193657 
10 
+ t 
-
12 t 
-
360 t 
20160 t + 1814400 t 
+ 
15397183 
12 
1302729349 
14 
41217747869 
16 
239500800 t - 43589145600 t - 951035904000 t + 
78476591731 
18 
291016986624000 t 
> plot( % , t = O .. 1.3 ); 
2.5 
1.5 
0.5 
o 
0.2 
0.4 
0.6t 
0.8 
1.2 
In this picture we have taken a smaller range for t than previously in the numerical 
approach. From the graph of the direction field of the differential equation, it is 
clear that for t > 1 the series solution is losing relevance, while the numeric al 
solution is a good approximation to the solution on a much wider range. In fact, 
there is a satisfying concordance between the numerical and the series solution for 
t between O and 0.5. 
17.7 Systems of ODEs 
Systems of differential equations are entered as sets. Here is an example, where 
dsol ve can find a solution. 
> deq1 := diff(f(t),t)=f(t)-g(t)-1; 
a 
deql := at f(t) = f(t) - g(t) - 1 
> deq2 := diff(g(t),t)=f(t)-2*t; 
a 
deq2 := at g(t) = f(t) - 2 t 

17.7 Systems ofODEs 
> dsolve( {deql,deq2} , {f(t),g(t)} ); 
{g(t) = ~J3e(!t) Sin(~tJ3) _Cl+_C2e(!t)CoS(~tJ3)-
~ J3 e( ! t) sin ( ~ t J3) _C2 - 1 + 2 t, 
f(t) =_Cle(!t) cos(~tJ3)+~J3eOt)Sin(~tJ3) _Cl-
~J3e(!t) Sin(~tJ3) _C2+2+2t} 
Let's check this solution, first for rele ase V.S: 
> odetest( % , {deql,deq2} ); 
{O} 
For earlier releases: 
> subs( %% , {deql,deq2} ): 
> map( eq -> normal(lhs(eq)-rhs(eq» 
, % ); 
{O} 
241 
IfMaple cannot find an exact solution of a system ofODEs, the system can be pre-
sented to dsol ve ( 
, series). Moreover, if it does not contain undetermined 
constants, then the set together with sufficient initial conditions can be handled 
withdsolve( 
,numeric). 
Integral curves can be plotted with the procedure phaseportrai t contained in 
the package DEtools. The arguments are here: 
• a list of ODEs 
• a list of the function names ("dependent variables") 
• the range of the parameter t 
• a set of initial conditions: lists of the form [t, f(t), g(t)] 
> DEtools[phaseportrait] ([deql,deq2] ,[f,g] ,t=-2 .. 5, 
> 
([0,-2,-2], [0,0,0], [0,2,2], [0,5,5], [0,10,10]}); 

242 
17. Solving differential equations 
60 
-80 
For a system of first-order aDEs with constant coefficients, the exponential of a 
matrix can be calculated with linalg [exponential]. This procedure is demon-
strated in section 18.13 on page 263. 
17.8 HeIping Maple in solving ODEs 
Because piecewise expressions can be handled weB by dsol ve (from release VA), 
it can be useful to convert expressions and functions containing abs, signum, 
Heaviside, max, min, etc. 
to piecewise-detined functions with convert 
, piecewise ) . 
It can sometimes be helpful when integral transforms are applied in order to tind 
a solution or a nicer solution. If you want the Laplace transform to be used, add 
the option method=laplace. Other methods are fourier, fouriersin, and 
fouriercos. These transforms are available separately in the inttrans package. 
You may see a pattern in an ODE that Maple does not, perhaps a solution of its ho-
mogeneous variant. You can use this for manipulating that ODE, possibly resulting 
in an easier ODE that can be solved with dsolve. A special tool for manipulat-
ing differential equations is PDEtools [dchange]. This procedure can convert a 
differential equation by substituting variables. Here is an example: 
> deq := x*diff(y(x),x,x) + (a*x-2-1)*diff(y(x) ,x) + 
> 
b*x-3 = O; 
deq:= x (::2 y(x)) + (ax 2 -1) (:x y(x)) + bx3 = O 

17.9 Symbolic representations of solutions: DESol 
243 
Let's substitute 0 for x and detine z(t) := y( 0). This can be done with the 
procedure PDEtools[dchange]. We must indicate that a and b are constants by 
the third argument. 
> PDEtools[dchange] ({x=sqrt(t),y(x)=z(t)} , deq , {a,b}); 
2t (:tJt) +2Vt (:t22 Z(t)) )+2(at-1)Vt(:t Z(t)) + 
b t(3!2) = O 
This result becomes a nice expression if it is multiplied by sqrt (t) . 
The tirst argument to PDEtools [dchange] is a set of substitution rules, saying 
that the new variable is t, related to x by x=sqrt (t) and that the new function in 
t is t - > z ( t). The last argument says that a and b are constants. 
In earlier releases, PDEtools [dchangevar] is not available. You might try 
DEtools [Dchangevar]. The same result could be generated in V.3 (but not in 
V.4) with: 
> DEtools[Dchangevar] ({x=sqrt(t) ,y(x)=z(t)} , " , {a,b}); 
2t (:tJt) +2Vt (::2 Z(t))) +2(at-1)0 (:t Z(t)) +bt(3!2) =0 
This tool is much more restricted. For instance, the following cannot be done with 
DEtools[Dchangevar]: 
> PDEtools[dchange] ({x=exp(u) ,y(x)=p(u)} ,deq , {a,b} ); 
aa p(u) 
a:::'I
a2 p(u) 
(a (eU )2 - 1) (tu p(u)) 
3 
_ U 
+ U 
+ 
+ b (eU) = O 
eU 
eU 
eU 
17.9 Symbolic representations of solutions: DESol 
Maple V can use symbolic representations of solutions of ODEs with the aid of 
DESol. First, let's use this for a basic standard equation: 
> diff(y(x) ,x) = a*y(x); 
a 
ax Y(x) = a Y(x) 
> DESol( % , y(x) ); 
DESOl( { (:x Y(x)) - a Y(x) } ,{ Y(x)}) 
Such an expression can be manipulated with several procedures. For instance, it 
can be integrated: 

244 
17. Solving differential equations 
> int(%,x); 
DESol({ (-Ix y(x)) - a Y(x)}, {Y(x) }) 
a 
The last result says that the antiderivative of any solution of the present ODE is 
equal to this solution divided by a. In this case an explicit solution is available, by 
which we can affirm the last re suIt. 
> subs( DESol=dsolve , %% ); 
dsolve( { (:x y(X)) - a y(x) } , {y(x)}) 
> %; 
Let's take another easy example, the ODE y" = a y. 
> DESol( diff(y(x),x,x)=a*y(x) , y(x) ); 
DESOI( { (::2 y(x)) - a y(x) }, {y(x)}) 
> des := %: 
Let's differentiate des. 
> diff( des, x ); 
:x DESOl({ (::2 y(X)) -ay(x) },{y(x)}) 
Not very interesting. But ifwe differentiate this again, Maple can use the equation. 
> diff ( % , x ); 
a DESOI( { (::2 y(x)) - a y(x) }, {y(x)}) 
A DESol expression can be a part of an expression. For instance: 
> des~3-1/des -5; 
D ESol ({ (::2 y (x)) - a Y (x) } , { y (x) } ) 3 -
1 
-5 
DESol( { (~ y(x)) - a y(x) }, {Y(x) }) 
This can be integrated as well: 
> int( % , x ); 

17.10 Graphic tools for differential equations 
({ 2 ~ 
W(X)2 
1 -t;s w(x) 
DESol 
-9 :x w(x)(5/3) + 3" :x W(X)(2/3) 
a :x W(X){1/3) } ,{ w(x) }) -
DESol ( { 2 ~ 
;(~:: t 
w~;~; 
Ix :(X)} ,{W(X)}) -5x 
The procedure series can be applied to a DESol expression. 
> series( des, x , 10 ); 
1 
1 
Y(O) + D(Y) (O) x + 2" a Y(0)x2 + "6 a D(Y) (O) x3 + 
1 1 1  
24 a2 Y(0)x4 + 120 a2 D(Y) (O) x5 + 720 a3 Y(0)x6 + 
1 
3 
7 
1 
4 
)8 
5040 a D(Y) (O) x + 40320 a Y(O x + 
1 
-- a4 D(Y) (O) x 9 + O(xlO ) 
362880 
245 
The DESol construction is an analogue to the RootOf construction. If there is no 
derivative, the first is converted to the second construction: 
> DESol( y(x)~2=y(x)-1 , y(x) ); 
RootOf( - _Z + _Z2 + 1) 
A set of initial conditions can be used as a third argument to DESol. 
Sometimes results can be made more readable by using an alias for a DESol ex-
pression; see section B.l on page 285. 
17.10 Graphic tools for differential equations 
The easiest method for plotting solutions is shown in section 17.5 on page 238 
on numerical solutions: apply dsol ve ( 
,numeric) and then plot the so-
lution with plots [odeplotJ. For other purposes, the package DEtools offers 
df ieldplot and phaseportrai t, which are shown earlier in this chapter. 

246 
17. Solving differential equations 
17.11 More tools 
In the present rele ase 5 of Maple V, there is a new package PDEtools for manip-
ulating and solving partial ditTerential equations and for plotting solutions. See 
the on-line help for this package. 
The package linalg contains several procedures for vector calculus, such as 
the procedure linalg [potential], which calculates a function in several vari-
ables, if extant, when its first-order partial derivatives are given; and the procedure 
linalg [vecpotent] , which calculates a vector field, if extant, the curl of which 
is a given three-dimensional vector field. 

chapter 18 
Vectors and matrices 
Maple supplies a special toolkit for linear algebra: the linalg package. For ma-
trices and vectors Maple uses a special data structure. This chapter explains how 
matrices and vectors can be created, changed, and handled. 
18.1 The linear algebra package 
Before we can start ca1culations with vectors and matrices we must load the pack-
age linalg: 
> with(linalg): 
Warning, new definition for norm 
Warning, new definition for trace 
Maple's wamings indicate that the names norm and trace were referring to pro-
cedures, and that loading the linalg package made these names refer to proce-
dures from the package. The "old" procedures can be reinstalled with the aid of 
readli b, for instance with norm: =readl i b ( 'norm' ) . 
Asking for on-line help to the procedures from the linalg package is always pos-
sible in a way like "?linalg [det] " or "?linalg, det", but in most cases it is 
not necessary to use the name of the package; for instance, "?det" can be used as 
well. 
Of ten, Error messages oflinalg procedures are caused by applying them to sin-
gular matrices. The other important cause of error messages is this: if even one of 
the matrix elements contains a floating-point number, many of the procedures of 
this package try to switch to numeric al algorithms. These can be applied only if 
all the elements of the matri x are numeric, and possibly complex. However, if the 
matrix contains indeterminates at the same time, only symbolic procedures can be 
used. In these cases, it might be necessary to convert the ftoating-point numbers 
contained in the matrix to rationals with the aid ofmap, as is shown in section 18.7 
on page 254. The main cases of this question are discussed in this chapter. 
Almost all symbolic algorithms used in this package are based on arithmetic op-
erators and on handling polynomials. As Maple has a thorough command ofthese 
fields, the symbolic algorithms of linalg are reliable, generally. Only the test 
procedure orthogonal uses numeric al testing, which might yield incorrectresults 
in a rare exceptional case. 
E. Kamerich, A Guide to Maple
© Springer Science+Business Media New York 1999

248 
18. Vectors and matrices 
However, keep in mind that alI unassigned names are interpreted as abstract num-
bers. Beware of the effects of substitution of special values for indeterminates, for 
instance causing matrices to be singular. 
18.2 Creating vectors and matrices 
A matrix can be created with the procedure matrix: 
> A := matrix( [[ 5,4,1] , [3,-1,2] , [-3,0,1]] ) 
A- [J3 ~1 ~l 
The argument to matrix is a list of the rows of the matrix, each row being rep-
resented as the list of its elements. For a discussion of lists, see Chapter 10, Ma-
nipulating several objects at once. This list of lists can be derived back from a 
matrix: here for instance, with convert ( A , listlist ). 
A vector can be created with the procedure vector: 
> cv := vector( [x,y,z] ) ; 
cv := [x, y, z] 
The procedure vector has been applied to the Zist of elements of the vector. This 
vector is printed horizontally, but it is interpreted by Maple as a column vector in 
matrix operations. It looks like a list. Compare: 
> [x,y,z] , vector([x,y,z]); 
[x, y, z], [x, y, z] 
The corresponding row vector can be created with transpose: 
> transpose( vector( [x,y,z] ) ); 
transpose([x, y, z]) 
The result is to be read as the transpose of a column vector, thus as a row vector. 
It is also possible to think of a row vector as a matrix with one row: 
> matrix( [[ x,y,z ]] ); 
[x y z] 
This one-by-three matrix is printed in exactly the same way as the column vector 
vector ( [x, y , z]) in windowing versions. However, it is always possible to get 
extended information about a vector or matrix with lprint. For instance, 
> lprint( % ); 

18.3 Evaluation of vectors and matrices 
249 
array(1 .. 1, 1 .. 3,[(1, 1)=x, (1, 2)=y,(1, 3)=z]) 
Vectors and matrices are one- and two-dimensional arrays, and here Maple ex-
plains that this one is an array with two indices, the tirst one ranging from 1 to 
1, the second from 1 to 3; moreover, all its elements are presented. 
Other ways of creating matrices and vectors are discussed later in this chapter. 
18.3 Evaluation of vectors and matrices 
In the previous section, we have assigned a matrix to the name A. If you simply 
type A, you don't see this matrix: 
> A ; 
A 
It is the same as with procedures: a name referring directly to a matrix is not au-
tomatically evaluated further; for full evaluation, use eval: 
> eval( A ) ; 
[ 5 4 1] 
3 
-1 2 
-3 
O 1 
Later in this chapter, you will see that sometimes full evaluation requires a combi-
nation of map and eval: map (eval , A). 
By the same mechanism in Maple the name A at the right-hand side ofthe following 
assignment is evaluated to itself: 
> 8 := A; 
B:=A 
This makes 8 refer directly to A and not to the matrix itself: 
> eval(8, 1) ; 
A 
Automatic evaluation of8 does not yield 8 itself, but the evaluation process reaches 
A, where it stops as this name is referring directly to a matrix: 
> 8; 
A 

250 
18. Vectors and matrices 
The special rule of evaluation demonstrated here is: 
Automatic evaluation stops where it reaches 
a name that refers directly to a matrix or a vector. 
This rule is called the rule of evaluation up to the last name. The same rule applies 
not only to vectors and matrices, but to tables in general and to procedures. 
18.4 Elements of vectors and matrices 
An element of a matri x can be selected with an index, using square brackets: 
> A [2, 1] ; 
3 
An element of the matrix can be changed with an assignment: 
> A[1,2] := -2 ; 
A I ,2 := -2 
More about what happens with such assignments can be found in section 18.8 on 
page 255. The input A [1,2] is printed as Al, 2 in windowing versions, but the 
square brackets are necessary in the input. Do not use as input A12 instead, which 
yields the name A12, nor Al, 2, which yields a sequence of the name Al and the 
number 2. In section B.3 on page 287 some special aspects of so-called indexed 
names are discussed. 
18.5 Matrix and vector arithmetic operators 
For demonstration purposes in this section we use the following vector and matri· 
ces: 
> vc := vector( [x,y] ); 
ve:= [x,y] 
> Ml := matrix( [[a,b], [c,d]] ) ; 
MI:= [~ ~] 
> M2 := matrix( [ [p, q] , [r, s] ] ) ; 
M2:= [~ ~] 
In calculations with matrices and vectors the operators are lazy. For instance the 
sum: 

18.5 Matrix and vector arithmetic operators 
251 
> M1 + M2 
j 
Ml+M2 
is not calculated. You must execute matri x operations with the procedure evalm: 
> evalm( % ) j 
[a+ p b+q] 
c+r d+s 
The product of Mi and M2 is calculated correctly with: 
> evalm( Mi &* M2 )j 
[ap+br aq+bS] 
cp+dr cq+ds 
The product operator between matrices is to be denoted with &*. 
Maple always interprets * as a commutative operator. 
If * is used for a matrix product, the order of the factors is chosen by Maple before 
evalm comes into action, and so would yield a correct result only by chance. 
The product operator between matrices and vectors must be denoted with &* as 
wel1: 
> evalm( Mi &* ve )j 
[ax + by, cx + dy] 
> evalm( transpose(ve) &* Mi )j 
transpose([ax + YC,x b + dy]) 
The product operator between a scalar and a vector or a matrix must be denoted 
with *: 
> evalm( 3 * Mi )j 
[3a 3b] 
3c 3d 
Scalar addition to a matrix may seem odd, but in such cases Maple interprets a 
scalar as a multiple of a suitable unit matrix: 
> evalm(iOOO + Mi) 
[ a + 1000 
b 
] 
c 
d + 1000 
Integer powers of matrices can be entered with ~: 

252 
18. Vectors and matrices 
> evalm( Ml 
~ 3 ); 
[ (a2+bC)a+(ab+bd)C (a2+bC)b+(ab+bd)d] 
(ca+dc)a+ (bc+~)c (ca+dc)b+ (bc+~)d 
> evalm( Ml 
~ (-1) ); 
[ _ad~:C 
ad-bc 
-
a~~bc] 
ad-bc 
The last result can also be calculated with the procedure inverse. 
It is possible to substitute a matrix into a polynomial: 
> x~2 - 5*x + 1; 
x 2 - 5x + 1 
> subs(x=Ml,%); 
M1 2 - 5Ml + 1 
> evalm(%); 
[a2 +bc-5a.+l 
ab+ .• bd~5b 1 
ca 4- d C -
il c 
b c -r- d' - il d 4- 1 
18.6 Manipulating alI the elements of a matri x or vector at once 
All elements of a matrix can be processed at once with the aid of the procedure 
map, discussed in section 10.3 on page 127. For instance, we have the matrix A: 
> eval(A); 
We can square each element of A as follows: 
> map( x -> x~2 , A ); 
[25 4 1] 
9 
1 4 
9 
O 1 
In fact, this is an exception to the general rule that map applies a procedure, the 
first argument to map, to the operands of the second argument; the operands of a 
matrix are not its elements: 

18.7 Processing a matrix that contains ftoating-point numbers 
253 
> op( eval(A) ); 
1 ... 3, 1 ... 3, [2, 3 = 2, 3, 1 = -3, 3, 2 
0, 3, 3 = 
1,1,1 = 5,1,2 = -2,1,3 = 1,2,1 = 3,2,2 
-1 ] 
but here map deviates from its normal rule in order to do what is useful for matrices 
in most cases. 
In the same way, alI the elements of a vector can be processed with the aid of map. 
If a procedure such as simplify is to be applied to alI the elements of a matrix, 
the procedure map can be used, too: 
> matrix([[cos(phi),sin(phi)] ,[-sin(phi),cos(phi)]]); 
[ cos(4)) 
Sin(4))] 
- sin(4)) cos(4)) 
> inverse(%); 
[ 
cos(<p)~~~ln(<p)2 
-
COS(<p)~nJ~ln(<p)21 
sine <p) 
cost <p) 
cost <p )2+sin( <p)2 
cost <p )2+sin( <p)2 
> map( simplify , % , trig ); 
[ COS(4)) 
- Sin(4))] 
sin( 4» 
COS( 4» 
18.7 Processing a matri x that contains floating-point numbers 
Several procedures in the linalg package switch over to numerical algorithms as 
soon as one of the elements of a matrix contains floating-point numbers, possibly 
complex. If the matrix contains indeterminates, this results in an error "matrix 
entries must alI evaluate complex floats". For example: 
> A:=matrix([[ 0.2 , a] ,[ b/3. ,4]]); 
A:= [.33333;3333 b :] 
> rank( % ); 
Error, matrix entries must alI evaluate to complex floats 
In such a case, the floats must be converted to rationals. See section 12.7 on page 
156. See also the previous section for the use ofmap: 

254 
> map( convert , A , rational, exact ); 
> ~ank(%); 
[ 
1. 
al 
5 
3333333333 
10000000000 b 4 
2 
18. Vectors and matrices 
Observe that this result is correct only if a and b are interpreted as abstract items; 
substituting special values for a and b may result in rank equal to 1. 
18.8 Names contained in elements of matrices and vectors 
In substitutions, it is tempting to forget the special rule for evaluation of names 
referring to vectors and matrices. For instance, 
> S := vector([ u-2 , u-l , u+l ]); 
S:= [u2 ,u -1,u + 1] 
> subs(u=10,S); 
S 
This fails because S is not evaluated to the corresponding vector, so the procedure 
subs does not "see" the u contained in this vector. A correct method is: 
> subs(u=10 , eval(S)); 
[100,9,11] 
The result is a new vector object where u is exchanged for 10, as can be read from 
the result printed by Maple. Remember that the substitution has created a new vec-
tor and that S itself has not been changed by this command: 
> eval(S) ; 
[u2 ,u -1,u + 1] 
If we assign a value to u we get the impression that this assignment does not influ-
ence the u in the matrix: 
> u := 100; 
u:= 100 
> eval(S); 
[u2 ,u -1,u + 1] 
This effect is caused by the fact that after the evaluation of a matrix or vector, the 
elements of the matrix are not evaluated. You can ask for this evaluation by apply-
ing eval to each of the elements of the matri x at once with the aid of map: 

18.9 Detenninant, basis, range, kemel, Gaussian elimination 
255 
> map( eval , S ); 
[10000,99,101] 
18.9 Determinant, basis, range, kemel, Gaussian elimination 
Here is a short survey: 
- det calculates the detenninant of a matrix 
- Svd calculates the singular values of a numeric matri x in combination with 
evalf, for example evalf (Svd (A) ) 
- trace calculates the trace of a matrix 
- rank calculates the rank of a matri x 
- basis calculates a basis for the subspace spanned by the vectors in the list or 
set given as argument to basis as a sublistlsubset of the given vectors 
- colspace or range finds a basis for the range of a linear map described by a 
matri x as a left operator on column vectors. This basis is calculated by Gaus-
sian elimination on the columns, resulting in a matrix in triangular form with 
leading entries equal to 1. The columns of this matrix that are not equal to 
zero yield a basis for the range of the given linear map. 
- colspan does almost the same job as colspace, but it can only be used if 
all the items of the matrix are polynomials over the rationals. Generally the 
leading entries of the resulting matrix will not be equal to 1, but colspan has 
the advantage that the elements of the resulting vectors are also polynomials; 
it does not introduce quotients of polynomials. 
- rowspace and rowspan do the same as colspace and colspan, respec-
tively, for rows instead of columns 
- LUdecomp computes the LU decomposition of a square matrix 
- intbasis calculates a basis for the intersection of two linear subspaces 
- sumbasis calculates a basis for the sum of two linear subspaces 
- gausselim and gaussjord apply Gaussian elimination, yielding a matrix 
in row echelon fonn. In the case of gauss j ord the nonzero leading entries 
in the resulting matrix are 1. 
These two procedures can be applied to a matrix containing quotients of poly-
nomials over the rational complex numbers or only complex ftoating-point 
numbers and rational complex numbers. If necessary, ftoating-point numbers 
can be converted into rationals: see section 18.7 on page 254. The procedure 
rref is equal to gaussjord. 
- f f gaus se lim applies fraction-free Gaussian elimination on a matrix of poly-
nomials over the rationals 

256 
18. Vectors and matrices 
- hermi te computes the reduced row echelon form of a matrix of polynomi-
als in one variable with coefficients in the field of quotients of multivariate 
polynomials over the rationals 
- smi th computes the Smith normal form of a matrix of polynomials in one 
variable; ismi th is a variant for calculations with integer matrices 
18.10 Systems of linear equations 
With the aid of Maple's solve procedure, large systems of linear equations can be 
solved in a fast and efficient way. Remember, that Maple conceives of variables 
as abstract items, so if a system contains parameters, and you want to substitute 
values for these parameters in the general solution, the result may not be the correct 
solution of the special problem. Here is an extremely easy example: 
> sys := { a*x+3*y=7 , 6*x+2*a*y=14 }; 
sys:= {ax+3Y = 7, 6x+2ay = 14} 
> solve( sys , {x,y} ); 
{ X=7_1_,y=7_1_} 
a+3 
a+3 
When you look at the result, you can see that it is not correct if a=-3. When you 
look at the system itself, you can see that the result is also not the correct solution 
if a=3. Let's pretend not to see this fact and use the methods from linear algebra. 
First, the homogeneous part of the system must be converted to a matrix by apply-
ing genmatrix: 
> genmatrix( sys, [x,y] ); 
[~ 23a] 
The singular cases can be found by using the determinant: 
> solve( det(%)=O , a ); 
3, -3 
These special cases can be handled by substituting 3 Of -3 for a in the system and 
applying sol ve to these special systems. For instance, 
> subs( a=3 , sys ); 
{3x + 3y = 7, 6x + 6y = 14} 
> solve( % , {x,y} ); 
{ y = y, x = - y + ~ } 

18.10 Systems of linear equations 
257 
The preceding example may show advantages of handling a system of linear equa-
tions in Maple with tools from the linalg package before sol ve is used. It is not 
necessary to use sol ve here; the package contains a special procedure for solving 
matrix equations: Iinsolve: 
> B := matrix([[a,l,l], [l,a,l], [l,l,a]]); 
[ a 1 1] 
B:= 
1 a 1 
1 1 a 
> w := vector([l,l,a~2]); 
w := [1,1, a2J 
The equation B x 
w in vector x can be solved with: 
> linsolve( B , w ); 
a 
a 
a2 + 2a + 2 
[- a+2'- a+2' 
a+2 
J 
Again it can be interesting to look at the cases where a special value of a causes B 
to be singular: 
> solve(det(B)=O,a); 
-2,1,1 
Let's solve B x = w in the case a=1. If we assign 1 to a, we get troubles: Maple 
calculates the solution before it evaluates a because of the special evaluation sys-
tem of matrices and vectors: 
> a:=l: linsolve(B,w); 
Error, division by zero 
Therefore, we substitute 1 for a in B and w: 
> a:='a': 
> subs( a=l , [eval(B),eval(w)] ); 
[[t : t], [1,1, Il] 
We have combined the matrix B and the vector w together in a list in order to apply 
substitution to both at once. The resulting list must be converted to a sequence with 
op, yielding the two arguments to !insol ve: 
> linsolve( op( % ) ); 
[1- -tI - -t2, -h, -t2J 
The result contains two parameters -tI and -t2; the solution is two-dimensional. 
This is the standard way of parameterizing a solution found by linsol ve. There-

258 
18. Vectors and matrices 
fore, it is important to avoid assigning values to -h, -t2, .... 
This same procedure linsol ve can be used for solving equations of the following 
type: given two matrices A, where A is not singular, and B of suitable dimensions, 
for which matrix X is AX = B? 
For optimization problems in linear equations the procedure leastsqrs is 
available: if A is a matrix and w is a vector, then leastsqrs (A, w) yields a vec-
tor x such that A x - w has minimallength, where the length is calculated as the 
square root of the sum of the squares of the coordinates. 
For optimization problems in linear inequalities or linear programming the 
simplex package is available. Consult the on-line help about this package. 
18.11 Characteristic polynomials and eigenvalues 
The procedure charpoly computes the characteristic polynomial of a square ma-
trix: 
> M := matrix([[a,b~2],[25,a]]); 
M:= [2~ ~] 
> charpoly(M,lambda); 
,\ 2 - 2 ,\ a + a2 - 25 b2 
The procedure eigenvals calculates the eigenvalues of a square matrix: 
> eigenvals(M); 
-5b+a,5b+a 
The procedure eigenvects tries to calculate the eigenvectors of a square matrix: 
> eigenvects(M); 
1 
1 
[5b+a, 1, {[-Sb,l]}], [-5b+a, 1, {[-Sb,l]}] 
The result is a sequence of two lists. The first element of each list is an eigenvalue 
of the matrix, followed by its multiplicity and a set of eigenvectors (a basis for 
the corresponding eigenspace). As usual, the variables a and bare considered by 
Maple as abstract items, not as unknown numbers, so the degenerated case where 
b equals zero is not included in the re suIt. 
When necessary, a RootOf expression is used in results of eigenvals and 
eigenvects. This is generally necessary if the dimension is higher than 3: 

18.11 Characteristic polynomials and eigenvalues 
> hilbert(5); 
1 
1 
1 
1 
1 
2 
3" 
4 
5" 
1 
1 
1 
1 
1 
2 
3" 
4 
5" 
6" 
1 
1 
1 
1 
1 
3" 
4 
5" 
6" 
;; 
1 
1 
1 
1 
1 
4 
5" 
6" 
;; 
8 
1 
1 
1 
1 
1 
5" 
6" 
;; 
8 
i) 
> eigenvects(%); 
[ ~ w1 1 { [1124794 w1 _ 37956758 rc12 
31091207'13_ 
5 /0" 
7875 
/0 
15625 
o 
+ 
125 
/0 
4346496 
4 
81859 
5891 
6452734 
15625 %1 - 7875000' 33750 -
4725 
%1+ 
4613227607'12 _ 189683207'13 
176870407'14 
1875 
10 
75 
10 
+ 
625 
10 
, 
18880847 rc1- 4871447884 w12 
5733056 w13_ 
7875 
o 
109375 
/0 
+ 
125 
/0 
80204544 rc 14 _ 2752963 1 2720979364 rc 12_ 
15625 
o 
3937500" 
109375 
o 
2040832 w 1 _ 1847177 _ 641536 w 13 4488422407' 4] }] 
1575 
/0 
3937500 
25 
/0 
+ 
15625 
101 
%1 := RootOf{85349376_Z5 - 762725376_Z4+ 
741667248 _Z3 - 40915248 _Z2 + 61501 _Z - 1) 
259 
Here only one eigenvalue seems to be found, with multiplicity one, but this 
RootOf expres sion has two values that can be found with alI values ( 
, 'd'): 
> allvalues(%); 
[.328792877210-5 , 1, { [-.008047359657, .1521038665, 
-.6597620813, 1, -.4904195315] } ], 
[.0003058980402, 1, {[.2023898935, -1.856745992, 
2.863863673, 1, -2.392881055] } ], 
[.01140749162, 1, { [.6919626481, -2.339027826, 
-.3890937582, 1, 1.82571361~}], 
[.2085342186, 1, { [-1.355862594, .621559, 
.9571437937,1, .966454]}], 
[1.567050691, 1, {[3.029605206, 1.76, 
1.270834794, 1, .83] } ] 

260 
18. Vectors and matrices 
Apart from using aH values, it is not convenient to manipulate the combinations 
of the eigenvalues and eigenvectors yielded by eigenvects as a whole; proce-
dures such as normal, expand, and simplify must be applied separately to an 
eigenvalue, and, with the aid of the procedure map, to a corresponding eigenvector. 
If a matrix contains floating-point numbers, the procedures eigenvals and 
eigenvects switch to numeric al methods automatically. However, these numer-
ical methods fail if the matrix contains indeterminates: 
> M [2 , 1] : = . 11 : 
> eval(M); 
> eigenvects(M); 
[ a 
b2 ] 
.11 
a 
Error, matrix entries must alI evaluate to float 
In this case, all floating-point numbers must be converted to rationals. See section 
18.7 on page 254. 
> map(convert,M,rational); 
> eigenvects(%); 
[a+ 1~ Jilb, 1, { U~ Jilb, 1] }], 
[ a -
IlO Jil b, 1, { [- ~~ Jil b, 1] } ] 
The procedure eigenvects for finding eigenvectors symbolically has restrictions 
on the type of the elements of the matrix: only algebraic expressions, possibly con-
taining names, and RootOf expressions are allowed. Therefore, it fails in the fol-
lowing case: 
> T:=matrix([[9*cos(phi)~2+43*cos(phi)+16, 
> 
50*(cos(phi)+1)~2] ,[-16+8*sin(phi)~2-16*cos(phi), 
> 
31*sin(phi)~2-37*cos(phi)-55]]); 
[ 9 COS(4))2 + 43 cos(4)) + 16 
50 (cos(4» + 1)2 
1 
T:= 
-16 + 8 sin(4))2 - 16 cos(4)) 
31 sin(4))2 - 37 cos(4)) - 55 
> eigenvects(%); 
Error, eigenvects only works for a matrix of rationals, 
rational functions, algebraic numbers, or algebraic 
functions at present 

18.12 Dot product, cross product, nonns, and orthogonal systems 
261 
The procedure eigenvects cannot handle this matrix, as it contains cos and sin. 
Sometimes it is possible to avoid these restrictions by substituting. However, be on 
your guard. For instance, if cos(phi) and sin(phi) are replaced with c and s 
in the present case, then eigenvects finds two eigenvalues with two correspond-
ing eigenvectors. However, both are equal if c and s are replaced with cos (phi) 
and sin (phi). This is correct: T has only one eigenvalue and a one-dimensional 
eigenspace. Obviously, if you apply such a substitution trick, you must watch for 
possible relations between the elements of the matrix that might disappear with the 
substitution, leading to misleading results. A more sensible approach to the present 
problem is toapply convert ( 
,tan) orevenonly simplify ( 
,trig) to the 
matri x with the aid of map: 
> map( simplify , T , trig ); 
[ 9 COS(4))2 + 43 cos(4)) + 16 
50 COS(4))2 + 100 cos(4)) + 50 1 
-8 - 16 cos(4)) - 8 COS(4))2 
-24 - 37 cos(4)) - 31 COS(4))2 
> subs( cos(phi)=c , % ); 
[ 92+43e+16 
-8 -16e - 8e2 
> eigenvects( % ); 
50e2 + 100e + 50 1 
-24 - 37 e - 31 e2 
[ -4 + 3 e - 11 e2 , 2, { [-;} 1]}] 
> subs( c=cos(phi) , % ); 
[-4+3 cos(4)) -11 COS(4))2, 2, {[ ~5 1]}] 
The Jordan matrix of a matrix can be calculated with j ordan, the minimal poly-
nomial with minpoly, and the companion matrix with companion. Examples 
can be found in the on-line help of Maple. 
18.12 Dot product, cross product, norms, and orthogonal systems 
Here is a short survey: 
- dotprod calculates the interior product oftwo vectors in complex space, sup-
posing that each unassigned name occurring in the elements of the vectors 
stands for a real number 
- angle computes the angle between two vectors 
- crossprod calculates the cross product of two three-dimensional vectors 
- norm computes the norm of a vector or matrix according to the norm defi-
nition specijied by the second argument. If no second argument is present, 
the norm of a vector yields the maximum of the absolute values of its el-
ements. For the square root of the sum of the squares of the elements use 
norme 
,frobenius). 

262 
18. Vectors and matrices 
- GramSchmidt computes an orthogonal basis from a given basis 
- QRdecomp computes the QR decomposition of a square matri x 
- orthog tests a matrix for orthogonality, using a clever but numerical test on 
equalities 
18.13 Vector calculus 
The standard differential operators of vector calculus, divergence, Laplacian, gra-
dient, curl, hessian, Jacobian, and Wronskian are available as diverge, grad, 
curl, hessian, jacobian, and Wronskian. Moreover, potential determines 
whether a given vector field is the gradient of an expression; if so, it can assign 
such an expression to a name given as a third argument. The procedure vecpo-
tent determines whether a given three-dimensional vector (or list) of expressions 
is the curl of a vector field; if so, this field can be assigned to a name given as a 
third argument. Here is an example, where we indicate with an option that the co-
ordinates are meant to be spherical: 
> grad(cos(phi)/r,[r,phi,theta],coords=spherical); 
[_ cos( <p) _ sin( <p) o] 
r2
' 
r2
' 
When the option coords=spherical had been omitted, the result is: 
> grad(cos(phi)/r,[r,phi,theta]); 
[_ cos( <p) _ sin( <p) o] 
2' 
, 
r 
r 
Moreover, in release 5 there is a package codegen, which offers the procedures 
GRADIENT, JACOBIAN, and HESSIAN. These are meant to handle procedures, not 
expressions; the output is also a procedure. If you apply such a resulting procedure, 
you might need to apply eval to the values, due to a bug, that might be fixed later. 
These procedures can only work with the standard Cartesian coordinates (in release 
5). 
For differential equations, the exp of a matrix can be important: 
00 
exp(tA) := L (tA)n 
n=O 
This can be calculated with the procedure exponential. Here is an example: 
> M := matrix( [[a + 4, 10], [-2, a - 5]] ); 
M:= [a+4 10] 
-2 a- 5 

18.14 Creating new vectors and matrices from old ones by changing elements 
263 
> exponential( M , t ); 
[5 e(a t) _ 4 e((a-l) t) 
2 e((a-l) t) _ 2 e(a t) 
-10 e((a-l) t) + 10 e(a t) 1 
-4 e(a t) + 5 e((a-l) t) 
As in many other cases, the matrix is not allowed to contain floating-point numbers 
if it also contains symbolic elements, so conversion of the floating-point numbers 
to rationals may be necessary. See section 18.7 on page 254. 
18.14 Creating new vectors and matrices from old ones by changing 
elements 
Suppose you have obtained a matrix, Mi: 
> eval(Mi); 
and you want ta create another matrix, M2, by changing one or more elements of 
Mi, while preserving the value of Mi. The following assignment cannot fulfill these 
demands: 
> M2 := Mi; 
M2:= MI 
The right-hand side Mi is not evaluated further, as you can see in the output of 
Maple, according to the rule of evaluation of matrices up to the last name, sa M2 is 
made to refer to Mi. Changing an element ofM2 changes the corresponding element 
of Mi as well: 
> M2[i,i] := aaa; 
M21,1 := aaa 
> eval(M1); 
That is not what we want. 
Let's reset Mi and then try another way by urging Maple to evaluate fully with the 
procedure eval. 
> M1[i,i] :=a: 
> M2 := eval(Mi); 
M2:= [: !] 

264 
18. Vectors and matrices 
The effect is that M2 refers to a matrix object directly. This can be seen by evalu-
ating M2 just one step: 
> eval(M2, 1) ; 
Let's change an element of M2 and look at the re suIt: 
> M2[1,2] := bbb; 
M21,2 := bbb 
The output of Maple shows that M1 has been changed by changing M2. That is 
because both names are referring to the same matrix object in memory. 
Changing an element of a matrix (or vector) 
does not create a new matrix (or vector) object in the memory, 
but it changes only the existing object. 
However, it is possible to create a new matrix object in the memory as a copy of 
an existing one by using copy. If this object is assigned to the name M2, we tind 
two independent matrix objects: 
> M1[1, 2] : = b: 
> M2 := copy(M1) ; 
M2:=[~!] 
> M2[2,2] := 2222222; 
M22,2 := 2222222 
> eval( M2 ) , eval( M1 ) ; 
[ ~ 222~222]' [~ ! ] 
Instead of copy the procedure evalm could have been used as well, but this is 
much slower than the special procedure copy. 

18.16 Alternative ways of creating vectors and matrices 
265 
18.15 Creating new matrices from old ones by transposing, cutting, 
and pasting 
Here is a short survey of available procedures for transposing matrices, pasting ma-
trices and vectors together, or cutting out parts of matrices. AlI these procedures do 
not change an existing matrix or vector, but create a new one that can be assigned 
to a name for later use. 
- transpose transposes a matrix (or a column vector, yielding a row vector, 
or vice versa) 
- htranspose (Hermitian transpose) transposes a matrix and takes the com-
plex conjugate of the elements 
- concat pastes matrices and/or vectors together side by side (horizontalIy) 
- stackmatrix (older releases: stack) pastes matrices and/or vectors to-
gether bottom to top (verticalIy) 
- delcols deletes columns of a matrix 
- delrows deletes rows of a matrix 
- col extracts a column of a matrix as a vector 
- row extracts a row of a matrix; the re suIt is a column vector 
- submatrix extracts a submatrix from a matrix 
- subvector extracts a vector from a matrix 
- copyinto copies the entries of a matrix as a block into another matrix 
- extend creates a matrix by adding columns and rows to the original matrix 
18.16 Alternative ways of creating vectors and matrices 
It is possible to create a matrix without assigning values to its elements. For instance, 
> X := matrix(3,4); 
X := array (1 ... 3,1 ... 4, [ ]) 
The re suIt is described as an array. In fact, matrices and vectors are special types 
of Maple arrays; the same object X can be created with the command X : = ar-
ray (i .. 
3, i .. 4) ; . 
We can assign values to one Of more elements of this matrix: 
> X[i,i] :=0; 
Xl,l := O 
If we evaluate X, we see: 

266 
> eval(X); 
?1,2 
?2,2 
?3,2 
Printing X yields a slightly nicer picture: 
> print(X); 
18. Vectors and matrices 
? 1,3 '1", 1 
?2,3 
?2,4 
?3,3 
?3,4 
It is possible to create a matrix by using afunction that calculates each element of 
the matrix from its coordinates. For instance, let's create the 8 by 8 matrix where 
the element on position li, il is (; -= ~ ) 21- i if i ;:::: i and O otherwise: 
> matrix( 8 , 8 , (i,j) -> 
> 
if i >= j then binomial(i-1,j-1)*2-(1-i) 
> 
else O fi ) ; 
1 
O 
O 
O 
O 
O 
O 
O 
1 
1 
O 
O 
O 
O 
O 
O 
2" 
2" 
1 
1 
1 
O 
O 
O 
O 
O 
"4 
2" 
"4 
1 
3 
3 
1 
O 
O 
O 
O 
8 
8 
8 
8 
1 
1 
3 
1 
1 
O 
O 
O 
16 
"4 
8 
"4 
16 
1 
5 
5 
5 
5 
1 
O 
O 
32 
32 
16 
16 
32 
32 
1 
3 
15 
5 
15 
3 
1 
O 
64 
32 
64 
16 
64 
32 
64 
1 
7 
21 
35 
35 
21 
7 
1 
128 
128 
128 
128 
128 
128 
128 
128 
There are two procedures for creating random matrices and vectors: randma-
trix and randvector. 
18.17 Special types of matrices: (anti)symmetric, sparse, identity 
Some special types of matrices can be created by the use of index functions and 
the procedure array: 
• A symmetric matrix can be created with: 
> S1 := array( 1 .. 4 , 1 .. 4 , symmetric ); 
SI := array (symmetric, 1 ... 4,1 ... 4, [ )) 

18.17 Special types ofmatrices: (anti)symmetric, sparse, identity 
267 
Observe that the dimensions of an array are entered as ranges, in contrast to 
the procedures matrix and vector which require natural numbers for the 
dimensions. 
We can see that Si is symmetric by printing it: 
> print(Sl); 
811,1 
81 1,2 
81 1,3 
811,4 
811,2 
8lz,2 8lz,3 8lz,4 
8h,3 8lz,3 813,3 
813,4 
811,4 
8lz,4 8b,4 814,4 
If elements are assigned to, symmetry is used, too: 
> Sl[2,3] :=0: Sl[4,1] :=100: 
> print(Sl); 
811,1 
811,2 
811,3 
100 
811,2 
812,2 
O 
812,4 
8h,3 
O 
813,3 
813,4 
100 
8lz,4 813,4 
814,4 
Only the right upper triangle of the matrix is stored in memory; the indices 
are exchanged, if necessary. 
It is also possible to enter the values of the elements in the invocation of ar-
ray. As the elements are assigned row by row from the left, we should enter 
only the elements of the left under triangle of the matrix, so the first element 
of the first row, then the two first elements of the second row, and so on: 
> array( symmetric , 1 .. 4 , 1 .. 4 , 
> 
[ [1] , [2,3] , [4,5,6] , [7,8,9,10] ] ); 
[ ~ ; : ~ 1 
4 5 6 
9 
7 8 9 10 
• An antisymmetric matrix can be created in a comparable way: 
> print( array( antisymmetric , 1 .. 4 , 1 .. 4 ) ); 
array(antisymmetric, 1 ... 4,1 ... 4) 
The elements of such a matrix are to be entered by assignments, possibly us-
ing the repetitional control struCture discussed later in this section. 
• A sparse matrix can be created as follows: 
> Sp := array( 1 .. 6 , 1 .. 6 , sparse ); 
8p := array (sparse, 1 ... 6,1 ... 6, [ ]) 

268 
18. Vectors and matrices 
In a sparse matrix all elements that are not assigned to are zero: 
> Sp[2,2] :=777; 
SP2,2 := 777 
> print(Sp); 
O 
O 
O O O O 
O 777 O O O O 
O 
O 
O O O O 
O 
O 
O O O O 
O 
O 
O O O O 
O 
O 
O O O O 
For sparse arrays, only the elements that are assigned to are stored in memory. 
If huge sparse matrices are to be handled, this feature can avoid unnecessary 
seizure of memory. 
• An identity matrix can be created with: 
> Id := array( 1 .. 4 , 1 .. 4 , identity ); 
Id:= array (identity, 1 ... 4,1 ... 4, [ ]) 
> print(Id); 
[~ n 
~l 
• A diagonal matri x can be created with the index function diagonal, but the 
procedure diag is generally preferable. 
In section 18.16 on page 266 we created a matrix with the command 
> matrix( 8 , 8 , (i,j) -> if i >= j then 
> 
binomial(i-1,j-1)*2~(1-i) else O fi); 
1 
O 
O 
O 
O 
O 
O 
O 
1 
1 
O 
O 
O 
O 
O 
O 
2" 
2" 
1 
1 
1 
O 
O 
O 
O 
O 
4" 
2" 
4: 
1 
3 
3 
1 
O 
O 
O 
O 
8' 
8' 
8' 
8' 
1 
1 
3 
1 
1 
O 
O 
O 
16 
4: 
8' 
4" 
16 
1 
5 
5 
5 
5 
1 
O 
O 
32 
32 
16 
16 
32 
32 
1 
3 
15 
5 
15 
3 
1 
O 
64 
32 
64 
16 
64 
32 
64 
1 
7 
21 
35 
35 
21 
7 
1 
128 
128 
128 
128 
128 
128 
128 
128 

18.17 Special types ofmatrices: (anti)symmetric, sparse, identity 
269 
Such a construction is not available for arrays. However, it is easy to replace this 
with a control structure, repetition. For instance, a sparse matrix with the same 
elements can be created as follows: 
> SB := array( 1 .. 8 , 1 .. 8 , sparse ); 
SB := array (sparse, 1 ... 8,1 . .. 8, [ ]) 
> for i to 8 do 
> 
for j to i do 
> 
SB[i,j] := 
binomial(i-1,j-1)*2~(1-i) 
> 
od 
> 
od: 
> print(SB); 
1 
O 
O 
O 
O 
O 
O 
O 
1 
1 
O 
O 
O 
O 
O 
O 
2" 
2" 
1 
1 
1 
O 
O 
O 
O 
O 
4" 
2" 
4" 
1 
3 
3 
1 
O 
O 
O 
O 
8" 
8" 
8" 
8" 
1 
1 
3 
1 
1 
O 
O 
O 
16 
4" 
8" 
4" 
16 
1 
5 
5 
5 
5 
1 
O 
O 
32 
32 
16 
16 
32 
32 
1 
3 
15 
5 
15 
3 
1 
O 
64 
32 
64 
16 
64 
32 
64 
1 
7 
21 
35 
35 
21 
7 
1 
128 
128 
128 
128 
128 
128 
128 
128 
Do not forget to close a repetition structure with od. More information on this 
structure can be found by entering ?do. 
As an alternative we can use the procedure seq: 
> SB := array( 1. .8 , 1. .8 , sparse , 
> 
[seq( 
> 
[ seq(binomial(i-1,j-1)*2~(1-i),j=1 .. i) ] , 
> 
i=1. .8)]) ; 
1 
O 
O 
O 
O 
O 
O 
O 
1 
1 
O 
O 
O 
O 
O 
O 
2" 
2" 
1 
1 
1 
O 
O 
O 
O 
O 
4" 
2" 
4" 
1 
3 
3 
1 
O 
O 
O 
O 
8" 
8" 
8" 
8" 
SB := 
1 
1 
3 
1 
1 
O 
O 
O 
16 
4" 
ii 
4" 
16 
1 
5 
5 
5 
5 
1 
O 
O 
32 
32 
16 
16 
32 
32 
1 
3 
15 
5 
15 
3 
1 
O 
64 
32 
64 
16 
64 
32 
64 
1 
7 
21 
35 
35 
21 
7 
1 
128 
128 
128 
128 
128 
128 
128 
128 

270 
18. Vectors and matrices 
18.18 Creating more special types of matrices 
There are several procedures for creating matrices of a special type, for instance, 
the procedure diag for creating diagonal matrices and block diagonal matrices: 
> diag(1,4,7); 
[1 O O 1 
O 4 O 
O O 7 
> diag( matrix([[a,b],[c,d]]) , p , q ); 
[a b O O] 
c d O O 
O O P O 
O O O q 
> diag( JordanBlock(lambda,3) , JordanBlock(mu,2) , nu ); 
A 1 O O O O 
O A 1 O O O 
O O A O O O 
O O O J.l 
1 O 
O O O O J.l 
O 
O O O O O v 
The procedure band creates band matrices: 
> band( [1,2,3,4,5] , 8 ) ; 
3 4 5 O O O O O 
2 3 4 5 O O O O 
1 2 3 4 5 O O O 
O 1 2 3 4 5 O O 
O O 1 2 3 4 5 O 
O O O 1 2 3 4 5 
O O O O 1 2 3 4 
O O O O O 1 2 3 
The 
procedures 
blockmatrix, 
hilbert, 
sylvester, 
toeplitz, 
and 
vandermonde can create matrices corresponding to the names of these proce-
dures. 
18.19 Functions yielding vectors and matrices 
A function yielding vectors or matrices can be created with the aid of the arrow 
( -t ) when the dimensions are entered as additional arguments: 

18.19 Functions yielding vectors and matrices 
> vf := t -> vector( 3 , 
[t-l,t+l,t~2] ); 
vl:= t -+ [t -l,t + 1,t2] 
> vf(100); 
[99,101,10000] 
271 
In this example, the tirst argument to vector says that a three-element vector is 
to be created. Here is an example of a function yielding matrices: 
> mi:= phi -> matrix( 2 , 2 , 
> 
[[cos(phi),sin(phi)],[-sin(phi),cos(phi)]]); 
> mi(Pi/6); 
[ cos(rI» 
Sin(rI»] 
m/:= rI>-+ 
- sin ( rI» 
cos( rI» 
[ 1.\1'3 
1.] 
2 -;1 
~ ~ 
Let's suppose that we have found a matrix containing a parameter: 
> Ma := matrix([[a,a~2],[a~3,a~4]]); 
[ a 
a2 ] 
Ma:= a3 a4 
Suppose that we want to create a function with parameter a yielding a matri x ac-
cording to the next expression. We could do so with the arrow construction as in 
the previous example, but then the matrix must be typed in again; suppose that we 
want to avoid that. The usual trick is using the procedure unapply, but this does 
not work here without additional tricks. The easiest way to create a function from 
Ma is as follows: 
) F := t -) subs(a=t,eval(Ma)); 
F:= t -+ subs(a = t,eval(Ma)) 
) F(3); 
The same trick can be used for vectors. 
In release V.5 you can also use codegen[makeproc], but at the moment of release 
it is not very suitable for this purpose; due to a bug the user must add eval for the 
results. 

272 
18. Vectors and matrices 
18.20 Vectors and matrices modulo an integer 
Matrices with elements in Z modulo an integer can be used as in the following 
example: 
> A := matrix([[22,-4,-55] ,[88,33,7777],[333,-8,-1111]]); 
A:= [~~ ;: ;~~] 
333 -8 -1111 
> map('mod',A,5); 
[2 1 O] 
332 
324 
The reason for the use of the back quotes here is that mod is a keyword, which can 
only be used as a name of a procedure by enclosing it between back quotes. The 
resulting matrix contains integers, not elements ofZ mod 5, so each new operation 
is to be combined with 'mod' again. For instance, 
> evalm( %~2 ); 
> map('mod',%,5); 
There are some special linear algebra procedures in connection with mod: 
> Det(A) mod 5; 
O 
> Nullspace(A) mod 5; 
{[4,2,1]} 
The last two steps have called inert procedures, which are activated by mod. The 
other inert procedures for linear algebra that can be activated by mod are Gausse-
lim, Gaussjord, Smith, and Nullspace. 
For calculations with rings, Maple offers the Gauss package, which also can be 
used for calculations on matrices with elements in a ring created by Gauss. 

18.22 Pedagogical facilities 
273 
18.21 Reading a matrix of data from a file 
Suppose that a file is available that contains numerical data in some columns. As-
sume, as an easy example, that the file exa looks like: 
0.1 
2 
3.3 
0.04 5.5 
0.6 
77 
8 
9.99 
10 
1.1 
0.12 
We can read these data into a matrix as follows: 
> matrix( readdata(exa,3) ); 
[
,1 
2. 3.3] 
.04 5.5 
.6 
77. 
8. 
9.99 
10. 1.1 
.12 
The number 3 in this command corresponds to the number of columns to be read. 
More details can be found in the on-line help. 
18.22 Pedagogical facilities 
As explained in section 4.18 on page 62, Maple can be used excellent1y for teaching 
mathematics. This is also the case for linear algebra. The linalg package even 
contains some special procedures for this purpose. For explanations and examples, 
consult the on-line help of Maple: 
- addcol, addrow,mulcol,mulrow,multiply, swapcol, swaprow, and 
pi vot for executing Gauss elimination step by step, where the user must 
choose the steps and can leave the ca1culations to Maple 
- backsub for the last step after Gauss elimination in solving a system of linear 
equations by matrix operations 
- plots [matrixplot] and plots [sparsematrixplot] for visualizing a 
matrix 

appendixA 
Types, properties, and domains 
Types of objects are important in the Maple system. In the interactive use of Maple, 
some knowledge about types can be useful; types of ten appear in error messages. 
When you manipulate a very large Maple ob ject, asking for the basic type of this 
ob ject may help to reveal its structure; components of a special type can be singled 
outfrom an expression, set, or Zist with select or remove. 
Don't get confused by the fact that some other computer languages have typed vari-
ables. In Maple, each name can refer to any other Maple object, whatever the type 
of the object, but the user can teli Maple to assume a special property for a name 
or an expression. Thisfacility can help Maple calculations and is discussed here. 
Mathematics owes much ofits power to abstraction; in algebra especially, many 
theorems and algorithms are not restricted to a special number system, but can be 
usedfor a whole class of groups or rings. The Domains package is a start in the 
direction of generalization to computations in classes of rings. The basic idea of 
this package is demonstrated at the end ofthis appendix. 
A.l Basic types 
Each Maple object has a basic type. This type can be found with the procedure 
whattype. Some of these basic types are discussed in section 11.3 on page 139 
and section 11.4 on page 141. Here are some examples: 
> x,whattype( x ); 
x, symbol 
In releases before V.5, the last result would be string. 
> 5/3, whattype( 5/3 ); 
5 j 
. 
3' ractwn 
> sqrt(5)/3, whattype( sqrt(5)/3 ); 
1 -V5 * 
3 
' 
Observe that a rational number is called a jraction, and that other quotients are 
stored as products. 

A.2 More types 
275 
> sqrt(5), whattype( sqrt(5) ); 
v'5, 
A 
> exp(5), whattype( exp(5) ); 
e5 , functian 
Intemally e5 is an unevaluated function call of the procedure exp, so it has the 
Maple type function. 
> whattype( 5 , sqrt(3) ); 
exprseq 
> M := linalg[matrix]([[1,2],[3,4]]); whattype(M); 
M:= [~ ~] 
symbol 
> whattype( eval(M) ); 
array 
> abc[3], whattype( abc[3] ); 
abc3, indexed 
The last type, indexed, is discussed in section B.3 on page 287. A list of the 28 
basic types in Maple can be found in the on-line help to whattype. For each of 
these types, separate on-line help is available. 
A.2 More types 
Apart from these basic types, many more types are available. These can be used 
in the procedures type and hastype. For instance, 
> type( 5/3 , numeric ); 
true 
> type( 5/3 , polynom ); 
true 
The following two results may make you wonder: 
> type( sqrt(5) , numeric ); 
false 

276 
A. Types, properties, and domains 
> type( sqrt(5) , positive ); 
false 
Remember that v'5 is only a symbolic object to Maple, but Maple can determine 
that v'5 is a positive number, for instance, if the procedure i s or s ignum is applied. 
The name M has been assigned a matrix in the previous section. The procedure 
type is very compliant here: 
> type( M , symbol ); 
true 
> type( M , table ); 
true 
> type( M , matrix ); 
true 
> type( M , array); 
true 
(In releases before V.5, the type string is used instead of symbol; in release V.5 
a new basic type string has been added.) 
A special case is a name referring to a sequence. For instance, 
> sq:=5,sqrt(3); 
sq:= 5, J3 
> type( sq , exprseq ); 
Error, wrong number (or type) of parameters in function type 
Here type reports an error, because it gets three arguments (5, sqrt (3) , 
exprseq) instead of two. The procedure type can handle alI basic types except 
for exprseq: names referring to a sequence can only be handled by whattype. 
> whattype( sq ); 
exprseq 
A list ofthe standard types that can be used with the procedures type and hastype 
can be found in the on-line help about type. More complicated types can be com-
posed from these standard types as structured types; it is even possible to program 
new types. 

AA Properties, the assume facility 
277 
A.3 Selection on type 
AU operands of a special type in a list, set, sum, or product can be singled out with 
the procedures select and remove. See section 10.6 on page 131. 
> 2 + sqrt(3) - sqrt(5)*x + sqrt(7); 
2+V3-V5x+V7 
> select( x->type(x,radical) , % ); 
V3+V7 
> remove( x->type(x,'*') , %% ); 
2+V3+V7 
Observe that the first result is asum and that V5 is not contained in the result as 
this is not one of the four operands of the sum. 
A.4 Properties, the as sume facility 
A property can be given to a name or expres sion with the procedure assume. For 
instance, 
> assume( t > O ); 
From now on, the name t is evaluated as being an undefined positive number. That 
property can be used in calculations: 
> 'limit(exp(t*x),x=infinity), 
> 
limit(exp(-t*x),x=infinity)'; 
Iim e(tx) 
Iim e(-tx) 
, 
x-too 
x-too 
> %; 
00, O 
It is also possible to as sume a property for an expression: 
> assume( r-2-1 >=0 ); 
After evaluation, the names t and r are printed with a tilde, indicating that they 
have some property. 
> t,r; 

278 
A. Types, properties, and domains 
An assumption conceming a name can be removed by unassigning: 
> r:='r': 
> about(r-2-1); 
r-2-1: 
nothing known about this object 
The procedure assume can be used for assuming properties for more than one ex-
pression at the same time, for instance, that ln(a) > 2 and that b is an integer: 
> assume( ln(a»2 , b , integer ); 
This example also shows that there are two forms for assuming something: a re-
lation, such as (In (a) >2), or a pairing of an expression and a property, such as 
(b, integer). 
A.5 Derived properties 
Properties can be derived from a known property with the procedure is: 
> is(t,real); 
true 
> is(t+l,positive); 
true 
> is(exp(t»l); 
true 
> is(t-l,positive); 
false 
The first three results indicate that for each positive number t, this t is real, that 
t + 1 is positive, and that exp(t) is gre ater than 1. The last result indicates that 
there is a positive number t such that t - 1 is not positive. 
A.6 Asking for the assumed properties 
We can ask for the properties of t with the procedure about: 
> about(t); 
Originally t, renamed t-: 
is assumed to be: RealRange(Open(O),infinity) 
The message ~ is assumed to be: 
RealRange(Open(O),infinity) 
means 
t E< 0,00 

A.8 Combining properties 
279 
A. 7 Adding properties 
If you assume something for an expression or variable that has a property, the old 
property is discarded. It is also possible to add a property: if you want to assume 
that t is not only positive, but even a positive integer, then you can use the proce-
dure additionally: 
> additionally(t,integer); 
> about(t); 
Driginally t, renamed t-: 
is assumed to be: AndProp(integer,RealRange(l,infinity)) 
A.8 Combining properties 
In the last example you can see a way in which properties can be combined: with 
AndProp, indicating that t is assumed to be negative and integer. 
There is another way of combining properties: OrProp. We can teU Maple that t 
is positive ar negative with: 
> assume(t,OrProp(positive,negative)); 
Essentially, this is the same as saying that t is a nonzero real number. We can ask 
ift is assumed to be real with the procedure is: 
> is(t,real); 
true 
is(t,Non(O)); 
true 
The method by which Maple can derive this is by applying a table of "par-
ent properties": properties that are weaker than a given property. 
By trac-
ing these tables Maple finds that both RealRange (-infini ty, Open(O)) and 
RealRange(Open(O) ,infinity)) have real as a so-caUed ancestor, so it 
finds that t is a real number. 
A survey of properties can be found by asking help for property. Moreover, 
a user can extend this system by other simple or parametric properties, using 
addproperty. 
Information about properties can also be found with about. For instance, on 
fraction: 
> about(fraction); 

280 
A. Types, properties, and domains 
fraction: 
noninteger rational 
a known property having {rational, Non(O)} as immediate parents 
and {BottomProp} as immediate children. 
mutually exclusive with {O, 1, integer, prime, irrational, 
composite} 
The first line explains the property. The next lines reveal the direct relations to 
other properties: its immediate parents (the next weaker properties), its children 
(the next stronger properties), and the next properties that are incompatible with 
it. 
In this case, the property is also a type, so we can ask on-line help with 
?type,fraction as well. This explanation is more extensive than the one pro-
duced by about. 
A. 9 Properties and assigning 
Assuming a property for a name is like assigning an unidentified object with the 
given property to that name. This can cause some strange effects. That is shown 
in the next examples: 
> assume(t,positive)j 
> T:=tj 
T:= t,,-, 
Now T refers to a UPO, an Unidentified Positive number Object, indicated as trv. 
Observe the result when we give another property to t: 
> assume(t,negative)j 
> about(t)j 
Originally t, renamed t-: 
is assumed to be: RealRange(-infinity,Open(O)) 
By this new assumption, the old property of t has been discarded, so t refers now 
to an Unidentified Negative number Object, again printed as t,,-,. But the name T 
has obtained its value before the second assumption for t, so it still refers to that 
UPO: 
> about(T)j 
Originally t, renamed t-: 
is assumed to be: RealRange(Open(O),infinity) 
So at this moment T and t refer ta different unidentified objects, both of which are 
indicated in the same way as trv. 
Still more embarrassing is the result when we again assume t to be pasi ti ve: 
> assume(t,positive)j 
Now t refers to a new Unidentified Positive number Object, different from the one 
that it referred to previously. This explains the following result: 

A.lO Properties and fonnal parameters 
281 
> T-t; 
Advice: when you want to assign an object with a property to a name, use single 
quotes; for instance: 
> T := , t-3 '; is( T>7) ; 
T:= t - 3 
false 
> assume( t>10 ); is( T>7 ); 
true 
Because of the single quotes, T does not refer to the evaluation result of t-3 but to 
this expression itself; when something is changed in the properties oft, this change 
has an effect for T as well. 
A.IO Properties and formal parameters 
Assumed variables may not work as formal parameters. For instance: 
> assume(n,integer); 
> y:=n~2-1; 
> seq(y,n=1. .5); 
n",2 -1, n",2 -1, n",2 -1, n",2 -1, n",2 -1 
Again the trick with back quotes works: 
> y:='n~2-1'; 
y:= n 2 -
1 
> seq (y ,n=1. .5) ; 
0, 3, 8, 15, 24 

282 
A. Types, properties, and domains 
A.II Domains, the Domains package 
The Domains package is designed for calculations in rings, derived from the inte-
gers or the rationals by some standard steps, for instance taking the ring of poly-
nomials over an already existing ring or the ring of n by n matrices over such a 
ring. 
The Domains package creates representation methods, ring operations, and algo-
rithms such as the Euclidean algorithm for greatest common divisor, if applicable, 
in an automatic and standardized way. The concept ofthis package originates from 
the symbolic computation system Axiom. 
Here is an example: 
> with(Domains); 
----------------------- Domains vers ion 1.0 ----------------------
Initially defined domains are Z and Q the integers and rationals 
Abbreviations, e.g. DUP for DenseUnivariatePolynomial, also made 
finit] 
First, we create the ring of polynomials in X with rational coefficients: 
> QX := DUP( Q , X ): 
The domain QX was created with the Domains-procedure DUP (=DenseUni vari-
atePolynomial), using the field Q, which is known to Domains. Now we can use 
the domain QX. In fact, QX is a table of procedures. This table contains an input 
procedure QX [Input] : 
> p := QX[Input] (4 - 1*r2 + 5*r3); 
p := 4 - 7 X 2 + 5 X 3 
The name p refers to a special internal structure representing the given polynomial 
of the ring represented by QX; this object can be handled by other procedures con-
tained in the table QX. For instance, we can calculate p2 and make q := XlO + p2: 
> QX [' ~ '] (p , 2); 
16 - 56 X 2 + 40 X 3 + 49 X 4 - 70 X 5 + 25 X 6 
> q := QX['+'] ( QX[Input](X~10) ,% ); 
X lO + 16 - 56 X 2 + 40 X 3 + 49 X 4 - 70 X 5 + 25 X 6 
Let's calculate the remainder of the division of q by p: 
> r := QX[Rem] (q , p); 
667828 
38204 X _ 1379399 X2 
390625 + 78125 
390625 

A.II Domains, the Domains package 
283 
To see a survey of the available procedures in the table QX. enter sholl 
(QX,operations). 
To make things more efficient. we can define infix operators for QX. That is possible 
by using names starting with an ampersand (&). For instance. 
> '&QXpr' := QX['*']; 
'&QXpr' := QX[' * 'l 
As the name &QXpr starts with an ampersand. we must surround it with back quotes 
to make Maple accept it as a name. It can be used without back quotes as an infix 
operator: 
> QX[Output](p &QXpr q) ; 
5X13 -7 X 12 +64+4XlO + 125X9 -525X8 + 735 X 7 -
43X6 - 840X5 + 588X4 + 240X3 - 336X2 
There are several other procedures in Domains for the creation of rings. For 
instance. we can create the quotient field of Q[X] by applying the Domains-
command QF on the ring QX created earlier: QF (QX) : 
> R ;= QF(QX): 
> pl := R[Input] (4 - 7*X
A 2 + 5*X
A 3); 
p1:=4-7X2 +5X3 
> R[' 1'] (%,pl); 
1 
> R['I'] (pl,R[Input] (X A 2-8»; 
4-7X2 +5X3 
X2-8 
The results are printed as the usual polynomials, but intemally they have a quite 
different structure. The procedure lprint can reveal that: 
> lprint(q); 
'domains/DenseUnivariatePolynomial/badgeO' (16,0,-56,40 ,49,-70,25,0, 
0,0,0 
The package Domains is available from rele ase 4. In earlier versions of Domains 
(called Gauss), resuIts are not printed in easily readable form automatically, but 
only with the aid of output procedures, for instance: 
> QX[Output] (q); 
X lO + 16 - 56X2 + 40X3 + 49X4 - 70X5 + 25X6 
For more information, consult the on-line help for Domains and Domains. 
example. For the special case of Galois fields, consult the on-line help to the GF 
package. 

appendixB 
Names and evaluation 3: 
some special features 
In Chapters 1, 3, and 5, using names in Maple is discussed. This appendix is a 
supplement to this subject, discussing the alias facility and several aspects of 
names and evaluation. 
B.1 Changing names, alias 
If yau want ta use anather name far an existing MapIe abject, yau can assign this 
abject ta that ather name. Far instance, we can assign the procedure Bessell ta 
the name BI. Let's use eval in arder ta make BI refer directIy ta that procedure. 
> BI := eval(BesselI); 
proc( v :: algebraic, x :: algebraic) ... end 
Naw we can use BI instead af Bessell in the input, but if MapIe prints a resuIt 
cantaining this abject, it uses the standard MapIe name: 
> diff(BI(5,x),x); 
B 
11(4) 
BesselI(5,x) 
esse 
, x - 5 -----'---'---'-
x 
Ta haveMapIe use BI in the autput as weII, appIy the procedure alias: 
> BI:='BI': alias( BI=BesselI ); 
1, EI 
> diff(BI(5,x),x); 
BI(4,x) _ 5 BI(~,x) 
The alias facility is quite different from assigning; it anIy teIIs MapIe ta trans-
late input befare processing it and ta translate autput before printing it. The 
alias command warks accarding ta the syntax alias «username>=<object 
in Maple denotation, without the use of other aliases». The 
result af an alias command is a sequence of aII names currentIY aliased to MapIe 
abjects. Unassigning BI befare the alias cammand is nat necessary here, but 
generaIIy an alias must be made anIy ta unassigned names. 

B.l Changing names, alias 
285 
Entering the command alias (BI (n, x) = Bessell (n, x)) would not be effi-
cient; this would fail in the present example, as Maple would interpret n as the 
name n, not as a variable that could be 5, for instance. 
Another example: we want to use the symbol j instead of 1 for A. You might 
think that it can be done in the following way: 
> alias(j=I); 
j,j 
The result of this command is curious, but more so the effect: 
> j-2 , sqrt(-l); 
The reason is that it is not allowed to use an alias in the right-hand side of an alias 
dec1aration; 1 is an alias for A, so the command alias (j = 1) is against the 
rules. Instead, you must unalias 1 with the command alias (1=1) first, and then 
alias j to A. Both can be combined in one command: 
> alias(I=I,j=sqrt(-l)); 
BI, j 
> expand«a+b*j)*(c+d*j)); 
ac+jad+jbc-bd 
Now let's reset the aliases: 
> alias(BI=BI,j=j,I=sqrt(-l)); 
1 
For more examples of using alias, see Chapter 6, Creating and using mathemat-
icalJunctions, and Chapter 14, Polynomial equations andfactoring polynomials. 
Another way of using your own names is the procedure macro. This works only 
for translating input. It is even possible to use a macro for acalI such as: 
> macro( whoops = 
> 
convert( series( % , x=O , 10 ) , polynom ) ); 
> sin (x) : whoops; 
13
1
5
1
7 
19 
x--x +-x ---x +---x 
6 
120 
5040 
362880 

286 
B. Names and evaluation 3: some special features 
B.2 Finding names used 
It is possible to obtain a sequence of all names that are assigned at that moment 
with the procedure anames: 
> demovar:=13: 
> anamesO: 
The result that would be printed if the command was terminated with a semicolon 
contains a lot of uninteresting names, much more than that one name demovar that 
has been assigned to in the present session: Maple has read in procedures from its 
library and these names are presented here as well. Moreover, many tab les have 
been made. It is, however, possible to obtain all names not referring to a procedure 
or a table with the aid of remove as follows (rele ase V.5): 
> remove (x->whattype (eval (x,2»=symbol, [anames()]); 
[demovar] 
For release VA use 
> remove( x->whattype(eval(x,2»=string,[anames()]); 
[demovar] 
For release V.3, use 
> seleet( x->whattype(eval(x» 
<> proeedure,[anames()] ); 
[demovar] 
It is important that this command is not split into two commands, otherwise eval-
uation throws a spanner in the works. 
If you wish to have this command easily available, make a macro of it and include 
this in your initialization file. 
It is also possible to obtain the assigned names in lexical order with: 
> sort([anames()],lexorder): 
(The output has been suppressed.) 
B.3 Indexed names 
An element of a sequence, a vector, a matrix, or, more generally, an array or a table, 
can be selected by indexing: 
> ve := linalg[veetor] ([1,2,3,5,7,11,13,17,19,23,29,31]); 
ve := [1 2 3 5 7 11 13 17 19 23 29 31 ] 
> vc[7]; 
13 

BA Quotes with table, arrays, vectors, and matrices 
287 
Indexes are always given between square brackets. An index to an unassigned 
name is accepted with the idea that this name might refer to something else in the 
future: 
> xyz[3]; 
This last object is called an indexed name. At this moment xyz is stiU an unas-
signed name: 
> eval(xyz); 
xyz 
But as soon as something is assigned to xyz [3] , the name xyz refers to a table: 
> xyz[3] :=0: eval(xyz); 
table([ 
3=0 
]) 
B.4 Quotes with table, arrays, vectors, and matrices 
Suppose we want to unassign the last five elements of the vector ve. For that 
purpose, we can use the repetitional control structure. See section E.5 on page 
302. Obviously, we cannot apply the command "for i from 8 to 12 do 
ve Ei] : =' ve [i]' od; ", as the last i would not be evaluated. For such purposes 
the procedure evaln can be used instead of the forward quotes: 
> for i from 8 to 12 do ve[i] := evaln(ve[i]) od: 
> print(ve); 
[1 2 3 5 7 11 13 
VC8 
VCg 
VClO 
VCu 
VC12] 
U sing back quotes with tab les, etc. can also be a source of mistakes. For instance, 
> 'some.thing'[l] := 2; 
'some.thing'[I] 
2 
> 'other.thing[l] , := 3; 
'other.thing[I]' := 3 
In the first case, only the name is written between back quotes; in the second case, 
the index is included. Look at the difference: 

288 
> eval('some.thing'); 
table([ 
1=2 
]) 
> eval('other.thing'); 
B. Names and evaluation 3: some special features 
'other.thing' 
Notice that the name some . thing refers to a table, but the name other . thing is 
unassigned; we have assigned 3 to the name other . thing [1] , which is a symbol, 
not an indexed name, because the whole is enclosed in back quotes. 
B.5 Recovering lost procedures 
If you might have lost a procedure from the library, it is possible to get it back, un-
less it is a so-called internal procedure. To see the list of internal procedures, enter 
?index, internal. In other cases, if the procedure is contained in the standard 
library, use readli b and assign the procedure to the name. For instance, in the 
following, we Iose the standard procedure norm: 
> with(linalg,norm): 
Warning, new definition for norm 
[norm] 
We can recover this procedure and assign it to a name by: 
> polynorm := readlib(norm); 
polynorm := proc(p, n, v) ... end 
If the procedure is contained in one of the packages, it can be recovered in the same 
way as it is obtained in other cases with the procedure wi th. 
B.6 Exceptions to the mIe of automatic full evaluation 
If an expression enclosed between a pair of forward quotes is evaluated, no values 
of names are Iooked up by MapIe. Instead, that pair of quotes is peeled of. 
ObviousIy, Ieft-hand sides of assignments are not evaluated. 
In almost alI cases, the arguments to a procedure are evaluated before the procedure 
comes into action. There are a few exceptions to this ruIe: evaln, assigned, 
traperror, parse, and addressof. These procedures take arguments literalIy. 
Moreover, the first argument in eval and the parameter in seq is taken literalIy, 
without evaluation. 

B.6 Exceptions to the rule of automatic fuII evaluation 
289 
For other procedures, evaluating arguments can be precluded with the aid of for-
ward quotes, but you must not use forward quotes for arguments taken literally by 
the procedures mentioned in the above. 
Names of procedures are evaluated to the last name, as explained in section 6.4 
on page 75. However, if the procedure is applied to an argument, it is evaluated, 
unless this is prevented by another cause, mentioned in this section. 
Names of tables, arrays, matrices, and vectors are evaluated to the last name, as 
explained in Chapter 18, Vectors and matrices. If such a name gets an index, it is 
evaluated, unless this is prevented by another cause, mentioned in this section. 
Local variables are specific for programming procedures; these are evaluated only 
one step automatically within the procedure. See section E.5 on page 302. 

appendix C 
The user interface for text-only versions 
Although the user interface for windowing systems offers many facilities, the text-
only inteiface is attractive on its own: it is fast and efficient and uses much less 
memory. This appendix discusses general aspects of this user inteiface. 
C.l Starting, interrupting, and quitting Maple 
You can start text-only Maple by clicking on Command Line Maple from Win-
dows, but you can save more memory by starting from MS-DOS in the direc-
tory bin \ wnt with the command cmaple if Maple has been installed under Win-
dows 95 ar Windows NT, else from the directory win \ win with the command 
dosmaple. 
an the Mac, click on the icon Command Line Maple. 
Under Unix, give the command maple. 
When you start Maple with a command, you can add options. Several of the effects 
ofthese options can also be produced with interface; moreover, this procedure 
offers many other possibilities for changing the user interface, etc. Details can be 
found in the on-line help for maple, interface, and kernelopts. 
You can try to interrupt a process by pressing Control-C, but it may take some time 
before this is intercepted. 
You can end the Maple session with the command qui t, stop, or done. 
C.2 Editing commands 
A very nice feature of this interface is that a history of commands is available for 
reusing. To recall the previous command, press the up-arrow key, press again for 
the command before, etc. You can then change the command in the usual way. 
(The number of commands that is remembered depends on their lengths.) 
If a command is entered without a colon or semicolon, you get a waming (from 
release V.4), and you can enter it on the next line. If you don 't mind getting wamed, 
you can enter a command on more than one line. 
After a syntax error, Maple prints syntax error: 
. .. and indicates with a 1\ 
the offending place. You have to enter the command again, but you may use the 
history facility. 

C.S Saving a session and its results 
291 
C.3 Pictures 
On text-only systems you still can make plots, even 3-dimensional, made by char-
acters. But you can always export pictures to a file and view them with other soft-
ware. Several formats are available. For instance, if you want to create a jpeg file, 
you can enter 
> plotsetup(jpeg); 
Warning, plotoutput file set to plot.jpg 
Maple informs you that from now on the pictures will not be printed to the screen 
but to a file named plot. jpg. If you want to print more than one file, each time 
you may indicate a new name for the file, for instance: 
> plotsetup(jpeg,plotoutput='figure7.jpg'); 
If you want to see pictures on the screen again, enter 
> plotsetup(default); 
In rele ase V.3 the last command should be plotsetup (terminal) . 
C.4 Maple system messages 
In most Maple versions you can see the amount of workspace in memory used 
by Maple, and the computing time from the start of the session at the bot-
tom of the screen. Only in character-based, full scrolling, terminal versions, 
messages on the state are printed on the screen between parts of the session. 
If you want to suppress such messages, enter gc (O) in release V.3 or ker-
nelopts (printbytes=false) in later releases. 
C.S Saving a session and its results 
If you intend to continue your Maple work later on and want to exit Maple or to 
perform other operations that might disturb your present results, you can preserve 
the present state of your Maple session in a file, say 'seeyou. m ' : 
> save 'seeyou.m'; 
The extension . m causes fast and efficient saving in a special Maple format. Omit-
ting this extension yields a readable file. 
If you start Maple later on, you can enter 
> read 'seeyou.m'; 
All variables at the moment of saving in the previous session are restored. 

appendixD 
Procedures remembering previous results 
The remember tables are an essential aspect of the Junctioning of Maple proce-
dures. Effects ofremember tables are shown in Chapter 8 (series), Chapter 14 
(expand), and Chapter 15 (solve). This appendix shows how to handle such re-
member rabies. 
D.I Remember tables of procedures 
For each procedure, individual results can be stored. For instance, 
> sin(1) := h; 
sin(l) := h 
> sin(5*Pi+l); 
-h 
We can even create a procedure in this way: 
> f(3) := 5000; 
f(3) := 5000 
> eval(f); 
procO option remember; 'procname(args)' end 
This cryptic description of f means that the procedure f stores each "calculated" 
result in its remember table, and that the result of applying f is the function name 
f applied to the given arguments, except for the case(s) that the argument is con-
tained in its remember table. This remember table can be obtained as follows: 
> op( 4 , eval(f) )j 
table([3 = 5000 
]) 
Another possibility (from release V.4) is as follows: 
> interface(verboseproc=3)}: 
> print(f): 
procO opt ion remember; 'procname(args), end # (3) = 5000 

D.I Remember tabies of procedures 
Let's calculate some function values of f: 
> f(1),f(t),f(3),f(Pi); 
f(I), f(t), 5000, f(1T) 
293 
The procedure retums the unevaluated function call, unless the argument is 3, in 
which case it yields 5,000. 
For many procedures, the remember table is essential. For instance, here is the 
remember table of sin: 
> op(4,eval(sin)); 
table([ 
1T = O, 
1 
1 
"6 1T = 2' 
311 
10 1T = 4 J5 + 4' 
!1T=!/2-v'2 
8 
2 V 
' 
~ 1T = ~ V2 + v'2, 
1 
1 
3 7f = 2 v'3, 
1 
1 
41T = 2 v'2, 
O = O, 
1 = h, 
1 
21T = 1, 
!1T=!v'2/5-J5 
5 
4 
V 
' 
1 = 1 sinh(I), 
112 1T = ~ v'6 ( 1 - ~ v'3) , 
111 
10 7f = 4 J5 - 4' 
152 1T = ~ v'6 ( 1 + ~ v'3) , 
~7f= ~v'2V5+J5 
]) 
In the table you can find the addition made at the start of this chapter: sin(l) = h. 

294 
D. Procedures remembering previous results 
D.2 Clearing (parts of) the remember table 
An item of a remember table can be removed with fQrget, which must be read from 
the library before it is used: 
> readlib(forget); 
proc(f) ... eud 
To have Maple forget that 1(3) should be 5, enter: 
> forget(f,3); 
> f(3); 
f(3) 
If no arguments are specified, his command removes alI additions to the remember 
table, resetting it to the original state: 
> forget(sin); 
> sin(l),sin(Pi); 
sin(l), O 
Some procedures store alI results automaticalIy. If a procedure is calIed, it looks 
up its present arguments in its remember table first; if it has calculated the same 
thing before, it uses the result from the table instead of calculating it. 
If a procedure calls another procedure, it is possible that results are stored in the 
memory table of that subprocedure. For instance, if Maple encounters the com-
mand int (s in (x) , x), then it translates the parameter x into _x first, it passes 
the translation on to a subprocedure 'int/indef', which tries to calculate the 
integral and stores the result in the memory table ofthat subprocedure, and, at last, 
that result is translated back by the main procedure. 
Although this calculation of an integral makes Maple store a result, it is not always 
easy to find which subprocedure has stored it. However, the procedure forget 
resets the remember tables of the specific subprocedures as well. 
D.3 An example of side effects of the remember table: infolevel 
The memory tables of procedures are essential for the efficiency of some of them, 
especially where procedures are programmed recursively. But sometimes, mem-
ory tables can have unexpected effects. Here is an example: 
> int(exp(sin(x)),x)j J 
eSin(x) dx 
If we want to know what Maple has tried to do, it does not suffice to set iufolevel: 

An example of side effects of the remember table 
295 
> infolevel[int] :=1; 
infolevelint := 1 
> int(exp(sin(x»,x); J 
eSin(x) dx 
We don't get information about the calculation, because Maple did not calculate 
anything at alI: it found an item "exp(sin(x) )=FAIL" in the memory table of 
'int/indef' and immediately retumed the calI to int unevaluated. But when 
the memory table of int and its subprocedures is reset, we get the desired infor-
mation: 
> forget (int) ; 
> int(exp(sin(x»,x); 
int/indef: 
first-stage indefinite integration 
int/indef2: 
second-stage indefinite integration 
int/trigexp: 
case of integrand containing exp and trigs 
int/rischnorm: 
enter Risch-Norman integrator 
int/risch: 
enter Risch integrat ion 
int/risch/algebraicl: 
RootOfs should be algebraic numbers and 
functions 
int/indef: 
first-stage indefinite integration 
int/indef2: 
second-stage indefinite integration 
int/indef2: 
applying derivative-divides 
int/indef: 
first-stage indefinite integration 
int/indef: 
first-stage indefinite integration 
int/indef2: 
second-stage indefinite integration 
int/exp: 
case of integrand containing exp 
int/indef: 
first-stage indefinite integration 
int/indef2: 
second-stage indefinite integration 
int/exp: 
case of integrand containing exp 
int/prpexp: 
case ratpoly*exp(arg) 
int/risch: 
exit Risch integration 
J 
eSin(x) dx 

appendixE 
Control structures 
An extensive guide to programming in Maple is beyond the scope of this book. But 
sometimes it can be convenient to automate a task in order to prevent typing too 
much. For these cases, the present appendix can give you some support. 
In some versions of Maple V.5 you can use a spreadsheet for automated execution 
of a system of commands. Another way of automating tasks in Maple is to write 
the commands in afile, check thisfile with mintfrom outside of Maple (read your 
manual or the on-line help about that wonderful tool mint), and then read the file 
from within Maple with the command read. 
A more elegant way is to write procedures containing the desired commands. This 
has some advantages, especially the possibility of using arguments. Again, it is 
very much advisable to write such a procedure into a file, then check it with mint 
and, after having fixed the possible syntax errors, read the file from within Maple 
with read. 
This appendix discusses the elementary use ofprocedures, choices, and repetitions. 
At the end, an extensive example is shown, concerning checking solutions of a set 
of polynomial equations. 
Ifyou want to know more on programming in Maple, you can read Maple V Pro-
gramming Guide by Monagan, Geddes, Real, Labahn, and Vorkoetter. 
E.l Procedures 
In section 6.4 on page 75, you can read how mathematical functions can be created 
in Maple with the aid of the arrow. In fact, these functions are procedures, meant 
to be printed in the mathematical style. For instance, 
> f 
:= x -> x-2 -
1; 
This is really a procedure: 
> lprint(eval(f)); 
f:= x -+ x 2 -1 
proc(x) options operator, arrow; x 2 - 1 end 
We could have defined f as well with the aid of the procedure proc: 

E.l Procedures 
297 
> f := proc(x) x~2-1 endj 
proc(x) x 2 - 1 end 
This last f ca1culates the same results as the previous one, but it is not printed in 
the mathematical style. 
The construction with proc is more flexible than the construction with the arrow. 
An important advantage is the possibility of inc1uding more than one command. 
As a basic example, here is a procedure that ca1culates a series expansion and then 
converts the result into a polynomial. 
> polseries:=proc( y ,pos ,order) 
> 
series( y , pos , order )j 
> 
convert( % , polynom )j 
> 
endj 
polseries:= proc(y,pos,order) 
series(y,pos, order)j convert(%,polynom) 
end 
> polseries( cos(x) , x=Pi , 5 )j 
1 
2 
1 
4 
-1 + 2" (x - n) - 24 (x - n) 
> polseries( exp(y) , y=l ,4 )j 
1 
2 
1 
3 
e + e (y - 1) + - e (y - 1) + -e (y - 1) 
2 
6 
The last command shows that the y in the argument exp (y) does not interfere with 
the parameter y in the definition of polseries. 
Procedure parameters should not be used as if they are variables that can obtain an-
other value: assignments can cause strange effects. The value of such a procedure 
parameter is known only to the procedure itself. 
The result of executing a procedure is the result of the last executed command. 
For instance, if the last executed command was something like print ( 
) , then 
there would be no result that could be referred to by the ditto or used by another 
procedure, though something would be printed to the screen. 
Observe that the intermediate results are not printed by Maple. That can be 
changed by raising the value of printlevel. See section E.5 on page 302. 

298 
E. Control structures 
E.2 Searching for causes of odd behavior with trace or 
printlevel 
If a procedure yields an unexpected error message, first, check that the arguments 
given to that procedure are correct by evaluating them. If these are not suspect, 
and the Error message mentions problems with a specific procedure, tryapplying 
trace to the offending procedure. This causes Maple to print input and output for 
each caII of this procedure, with intermediate results calculated by that procedure. 
There are several other tools for debugging available; if necessary, look at the on-
line help for debug. 
E.3 Using if .. . fi for choices 
Here is an example of the choice structure: we want to create a function 1 with 
1(0) = a, 1(1) = b, 1(2) = e, and I(x) = O for x f- 0, 1,2. We can write this 
procedure in a file: 
f := proc(x) 
end: 
if x=O then a 
elif x=l then b 
elif x=2 then c 
else O 
fi 
Let's suppose that this file is called "demo1". Now we can use mint to check 
this file for correct syntax by entering mint demo 1. This command should not 
be given from Maple, but from the operating system of the computer. The result 
is: 
Procedure f( x ) on lines 1 to 7 
These names were used as global names: 
a, b, c 
There are no reports on syntax errors, nor cues that something might not be accord-
ing to our plans, so we can start Maple and give the command 
> read demo1; 
Now f is available: 
> f(-l), f(O), f(l), f(2), f(3); 
O,a, b, e,O 
The last command executed after then or else yields the result of the if .. . fi 
structure. This is the last executed command of the procedure as well, so it yields 
the result of the procedure. 
After each occurrence of then and after else, several commands can be given, 
each closed by a colon or semicolon apart from the last one. There is no objection 
to using more (semi)colons, as in: 

EA Recursion 
f := proc(x); 
end: 
if x=O then a; 
elif x=l then bj 
elif x=2 then c; 
else O; 
fi; 
299 
The present example shows a choice from several possibilities. If your choice is 
more restricted, you can omit elif ... and even omit else . ... But in any case, 
the choice structure must be c10sed by the word fi, otherwise you get a syntax 
error. 
The procedure in the previous section requires an argument order. The standard 
procedure ser ies can do without: if that order argument is omitted, it uses the 
value of the name Order. Such a functionality can also be used for modifying the 
procedure polseries created in the first section: 
polseries:=proc( y , pos ) 
if nargs>2 then series( y , pos , args[3]+1 ) 
else series( y , pos ) fi; 
convert( % , polynom ); 
end; 
Here nargs and args are used; within a procedure, nargs is interpreted as the num-
ber of arguments in the present caB. Moreover, args is interpreted as the actual 
sequence of arguments. 
If we read in this procedure, we can use it, as in: 
> polseries( ln(x) , x=Pi , 3 )j 
1 () 
X-7f 
1 (X-7f)2 
1 (X-7f)3 
n 7f + -- - -
+ - -'----;:--'-
7f 
2 
7f2 
3 
7f3 
> polseries( ln(x) , x=Pi ); 
1 () X-7f 
1 (X-7f)2 
1 (X-7f)3 
1 (X-7f)4 
n7f +----
+-
--
+ 
7f 
2 
~ 
3 
~ 
4 
~ 
1 (x -
7f)5 
5 
7f5 
E.4 RecursÎon 
Many mathematical objects are defined recursively. Such a definition can be used 
in a natural way for ca1culations. In Maple, n! is available, but here is a simple 
procedure for it by way of an example: 

300 
E. Control structures 
fac := proc(n) 
it n=O then 1 
elif type(n,posint) then n*fac(n-1) 
else 'procname(args), 
fi 
end; 
After having checked this with mint and having read it in Maple, you can use it. 
For instance, 
> fac(?), fac(O), fac(-sqrt(3)), fac(t); 
5040, 1, fac ( - J3) , fac(t) 
A less trivial example is calculating Hermite polynomials. The orthopoly pack-
age contains a procedure for this purpose. The Hermite polynomials are defined 
by: 
H(n,x) := { 
2~ 
2xH(n -l,x) - 2(n -1) H(n - 2,x) 
This can be programmed as follows: 
H := proc(n: :integer,x) 
if n>1 then 2*x*H(n-1,x)-2*(n-1)*H(n-2,x) 
elif n=1 then 2*x 
else 1 
fi 
end; 
if n = O 
if n = 1 
otherwise 
The first argument n is indicated as an integer by n::integer; the procedure will 
test if it is an integer automatically. 
If this text is read in by Maple, the procedure H can be used, for instance, 
> H(2,x); H(3,x); H(4,t); 
2 x (4 x 2 - 2) - 8 x 
2t (2t (4t2 - 2) - 8t) - 24t2 + 12 
This seems to be fine. However, there are efficiency problems: if you ask for 
H (5, x) , Maple has to calculate H( 4,x) and H(3,x). For the calculation of H (4, x) , 
Maple has to calculate H(3,x) a second time. For instance, if you ask for H (10, x) , 
then H (3, x) is calculated 21 times. We can avoid a procedure to calculate things 
more than once by adding the option remember. Then each result of the proce-
dure is stored in its remember table automatically. See Appendix D, Procedures 
remembering previous results. In fact, the standard procedure in Maple that calcu-
lates Hermite polynomials uses this option remember. Here is the source: 

E.S Using do ... od for repeating actions 
'orthopoly/H' := proc(n,x) 
option remember, 
'Copyright (c) 1991 by the University of Waterloo. 
AII rights reserved.'; 
end: 
if 1 < n then 
expand(2*x*'orthopoly/H'(n-l,x) 
-2*(n-l)*'orthopoly/H'(n-2,x» 
elif n = 1 then 2*x 
else 1 
fi 
301 
Now the procedure stores each Hennite polynomial that it has calculated in its 
memory table. When the procedure is called, it looks first to see if the required 
Hennite polynomial is available in its memory table. 
In fact, when you call orthopoly [H] for calculating a Hennite polynomial, 
Maple does more: it checks the first arguments (it should be an integer ~ O), then 
it calls the previous procedure with a second argument -X, and, at the end, it trans-
lates that _x into the second argument given by the user. 
E.S Using do ... od for repeating actions 
The previous section shows an elegant method for repetition. There is also a spe-
cial structure for this purpose, already shown partially in section 18.17 on page 267 
and in section B.3 on page 287. 
Here is an example: let's suppose that we want to factor x 3 - 1, x 5 - 1, x7 - 1, 
x9 - 1, and xll -
1. 
> for i from 3 by 2 to 11 do factor(x-i-l) od; 
(x - 1) (x2 + x + 1) 
Maple can use defaults if not all elements are given. For instance, the same result 
is obtained with the following command: 
> for i to 5 do factor( x-(2*i+l) - 1 ) od: 
Here i takes the values 1,2,3,4, and 5. 

302 
E. Control structures 
In many cases, such a repetition can also be generated efficiently by applying the 
procedure seq. See section 10.7 on page 132. 
The previous section gives a procedure for calculating Hermite polynomials by re-
cursion. The present construction can be used as well as follows: 
H := proc(n::integer,x) 
local h,i; 
h[O] := 1; 
h[1] := 2*x; 
for i from 2 to n do 
2*x*h[i-1] - 2*(i-1)*h[i-2]; 
h[i] := expand( % ) 
od; 
h[n] 
end: 
The second line declares the names h and i to be local variables. If a name is a local 
variable within a procedure, the values it gets in the execution of that procedure 
play no role outside that execution, so it cannot interfere with the session or with 
execution of other procedures. If we had not declared these as local, Maple would 
have done so automatically, but at the same time it would have issued a waming. 
It is also possible to declare a name as global. If you want to use local variables, 
you are advised to read more on this subject, for instance, on the special one-step 
evaluation rule, in the on-line help, or the book mentioned in the introduction of 
this appendix. 
In the procedure, a table h is used. This is created automatically in the first assign-
ment h [O] : =1. A table resembles a vector, but it has no restrictions in the type 
and the number of indices. 
If you execute a repetition within a repetition interactively, results of the inner rep-
etition are not usually shown on the screen: 
> for i to 2 do 
> 
for j to 3 do 10*i+j od; 
> 
%*100 
> 
od; 
1300 
2300 
This can be changed by the value of printlevel: 
> printlevel := 2: 
> for i to 2 do 
> 
for j to 3 do 10*i+j od; 
> 
%*100 
> 
od; 

E.5 Using do ... od for repeating actions 
303 
11 
12 
13 
1300 
21 
22 
23 
2300 
Generally, ne sting choice and repetition structures prevents output of intermediate 
results unless the value of printlevel is high enough. Output generated by the 
procedure print is not inftuenced by this mechanism, but output from plot and 
plot3d is. Therefore, if you want to plot from inside nested choices and loops, you 
can better use print (plot ( 
)) instead of plot ( 
) . 
If it is not clear in advance how many repetitions are necessary, use 
while 
do 
od 
For instance, if you try to tind the smallest n such that factorization of xn -1 yields 
10 or more factors, you can enter: 
> n:=3: while nops(factor(x~n-1))<10 do n:=n+1 od: 
> n; 
48 
The full repetition structure is: 
for 
from 
by 
to 
where only the do 
od part is mandatory. 
demonstrated in the next section: 
for 
in 
while 
while 
do 
od 
There is a variant of this structure, 
do 
od 

304 
E. Control structures 
E.6 An example: checking the results of sol ve by substituting 
This section shows how candidate solutions for a system of polynomial equations 
can be checked in an automated way. The system of equations in the example is 
chosen to be basic enough to be solved by hand, in order to help you understand 
the results. 
> eql := 3*x-2 + 2*y-2 = 
7*x*y; 
eq 1 : = 3 x2 + 2 y2 = 7 x y 
> eq2 .- x-2 + y-2+2*x = 20; 
eq2 := x2 + y2 + 2x = 20 
> sol := solve( {eql,eq2} , {x,y} ); 
sol:= { x = RootOf(5_Z2 + _Z - 10), 
y = 3 RootOf(5 2
2 + 2 - 10) }, 
{y = ~ RootOf(5_Z2 + 8_Z - 80), 
x = RootOf(5 _Z2 + 8 _Z - 80) } 
Maple's solution consists of a sequence of two sets. It is easy to check these, for 
instance the first one: 
> subs(%[lJ,{eql,eq2}); 
{1O%12 + 2%1 = 20,21 %12 = 21 %12 } 
%1 = RootOf(5 Z2 + Z - 10) 
> map( eq->simplify(lhs(eq)-rhs(eq)),%); 
{O} 
This affirms the first solution. The second can be handled in the same way. 
In fact, each of these two elements of sol represents some explicit solutions. We 
can find these with allvalues. See section 14.2 on page 171. We could use this 
procedure without option (or in release V.3 with the option 'd'), so that alI oc-
currences of the same RootOf are interpreted as the same number, after having 
argued that we would find ali solutions that way. But suppose that we don't trust 
this idea. Then we can use the option 'independent' and check alI candidate 
solutions found. 
Ifwe try to apply allvalues directly to sol, we get a syntax error: it is a sequence 
of two objects, which yields two arguments for aU values. So we must bundle 
them together, in a set (or a list): 

E.6 An example: checking the results of solve by substituting 
305 
> allvalues( {sol} , 'independent' ); 
x = -- + - J26 y = -- + - J26 
{{ 
4 
4 
2 
2 
} 
5 
5 
' 
5 
5 
' 
Y = - -
+ -
V20l x = - - + -
V201 
{ 
3 
3 
1 
1 
}} 
10 
10 
' 
10 
10 
' 
x = -- - - J26 y = -- + - J26 
{{ 
4 
4 
2 
2 
} 
5 
5 
' 
5 
5 
' 
Y = - - + -
V201 x = - - + -
V20l 
{ 
3 
3 
1 
1 
}} 
10 
10 
' 
10 
10 
' 
. .. omitting a part of the output ... 
x = -- - - J26 y = -- - - J26 
{{ 
4 
4 
2 
2 
} 
5 
5 
' 
5 
5 
' 
Y = - - - -
V201 x = - - - -
V201 
{ 
3 
3 
1 
1 
}} 
10 
10 
' 
10 
10 
We have obtained a sequence consisting of sets, each containing two possible so-
lutions. We must make a union of these sets. This can be done as follows by using 
the procedure union. See section 10.8 on page 133. 
> (union ( (%) ; 
x = -- + -
'26 y = -- + - J26 
{{ 
4 
4 
2 
2 
} 
5 
5 y.GO, 
5 
5 
' 
x = -- - - J26 y = -- + - J26 
{ 
4 
4 
2 
2 
} 
5 
5 
' 
5 
5 
' 
x = -- + - J26 y = -- - - J26 
{ 
4 
4 
2 
2 
} 
5 
5 
' 
5 
5 
' 
x = -- - - J26 y = -- - - J26 
{ 
4 
4 
2 
2 
} 
5 
5 
' 
5 
5 
' 
Y = - -
- -
V201 x = - - + -
V20l 
{ 
3 
3 
1 
1 
} 
10 
10 
' 
10 
10 
' 
{ 
3 
3 
1 
1 
} 
Y = - 10 + 10 V20l, x = - 10 - 10 V201 
, 
Y = -- - -
V201 x = -- - -
V201 
{ 
3 
3 
1 
1 
}} 
10 
10 
' 
10 
10 

306 
E. Control structures 
Each of the eight sets of potential solutions can be checked by substitution into the 
set of equations. After application of expand and simplify we must check if the 
result is {O=O}. In section 1.3 on page 6, a solution of a third-degree polynomial 
equation is checked. The same process is executed here in a more advanced way, 
using a do loop and a choice structure in order to handle all solutions. 
First, let's give a name to the set of candidates for solutions: 
> candidates := %: 
Let's create a void sequence to which all the found solutions can be appended: 
> solutions := NULL; 
Now we start a repetition, using the construction 
for 
in 
do 
od 
We take each of the elements of candidates, naming that element "testcand" 
temporarily: 
> for testcand in candidates do 
We substitute testcand in the set of equations and apply expand and simplify 
on each of the two resulting equations. 
> 
map(eq->lhs(eq)-rhs(eq), {eql,eq2}): 
> 
subs( testcand , % ): 
> 
map( expand , % ): 
> 
map( simplify , % ): 
If the result is {O}, then testcand satisfies the system of equations and should be 
appended to the sequence of found solutions: 
> 
if %={O} then solutions:=solutions,testcand fi: 
Now the repetition structure should be terminated: 
> 
od: 
After this last line the loop is executed, but all the commands have been closed 
with a colon, so we do not see any result. We have obtained: 
> solutions; 
{y =-~+~J26 x=-~+~J26} 
5 
5 
' 
5 
5 
' 
{ Y = -~ - ~ J26 x = -~ - ~ J26} 
5 
5 
' 
5 
5 
' 
{ y = - ~ + ~ v'201 x = - ~ + ~ v'201 } 
10 
10 
' 
10 
10 
' 
{ y = - ~ - ~ v'201 x = - ~ - ~ v'201 } 
10 
10 
' 
10 
10 
In fact, this is the same result as yielded by all values without option, but the pre-
vious demonstration may show how you can check solutions of a system of poly-
nomial equations, for instance, in a case where it is not clear if solutions are omitted 
byallvalues. 

E.6 An example: checking the results of sol ve by substituting 
307 
The method for testing candidates for solutions that is shown here can be used for 
sets of polynomial equations if all ofthese equations are reduced to the form poly-
nomial=O. Dur checking method relies fully on the power of simplify. In order 
to minimize the chance that solutions get lost by a failing simplification, an alter-
native check with testeq could be used or added. As always, choosing methods 
and judging results is the task of the user. 

Errar messages and wamings 
';' unexpected .................................................... 13,40 
attempting to assign to 'abs' which is protected ...................... 37,68 
Could not determine discontinuities .................................... 94 
division by zero ..................................................... 257 
does not have a taylor expansion, try seriesO ........................... 114 
eigenvects only works for a matrix of rationals, rational functions, 
algebraic numbers, or algebraic functions at present .................... 260 
Illegal use of an object as a name ................................... 37,40 
invalid assignment to Digits ........................................... 38 
invalid substitution in series .......................................... 110 
matrix entries must alI evaluate to complex ftoats ....................... 253 
matrix entries must alI evaluate to ftoat ................................ 260 
may not assign to a system constant .................................... 38 
Missing a list with the new variables .................................. 144 
object too large ............................................. 29, 125, 158 
optional3rd argument given to 'gcd' was ............................. 159 
reducible RootOf detected. Substitutions are ........................... 184 
summation variable previously assigned ................................ 61 
too many levels of recursion ........................................... 42 
unable to handle singularity ...... , ... ,................................ 58 
Waming, incomplete statement or missing semicolon .................. 6, 40 
wrong number (or type) of parameters in function diff ................ 44, 65 
wrong number (or type) of parameters in function int .................... 65 
wrong number (or type) of parameters in function iquo ................... 67 
wrong number (or type) of parameters in function op ............... 124, 126 
wrong number (or type) of parameters in function subs ....... . .......... 127 
wrong number (or type) of parameters in function type .................. 276 

Catchword Index 
................................................................... 29 
" .............................................................. 2,12,41 
, ............................................................ 35, 39,287 
* ..................................................................... 8 
-) .................................................................. 75 
.................................................................... 20 
.......................................................... 50,60,131 
: .................................................................... 8 
:: ................................................................. 300 
:= .................................................................. 10 
..................................................................... 8 
# .................................................................... 85 
$ .................................................................... 44 
% ...................................•.•.•.................•..• 33,66,91 
& .................................................................. 283 
&* ................................................................. 251 
&where ............................................................ 237 
% .....•.•......•...•..•...•..•.............•............•.•. 2, 11, 12, 16 
_ .................................................................... 38 
, ............................................................... 40,287 
@ •••••.••••••••••••••••••••••••• • •••••••••••••••••••••••••••••••••••• 85 
@@ 
•••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••• 85 
'" .............................................................. 36,277 
'Y ..................................•...•.•.......................... 22 
r-function ........................................................ 74 
7f •••••.•••••••••••••••••••••••••••••••••••••••••••••••••••••••••. 22,38 
( .................................................................... 74 
abbreviation ......................................................... 16 
about .............................................................. 278 
abs ........................................................ 84,150,242 
accuracy ............................................................ 117 
addi tionally ..................................................... 279 
algsubs ........................................................... 145 
alias ................................................... 37,174,183,284 
allvalues ............................................ 48,171,173,175 
allvalues( 
,independent) ..................................... 171 
ampersand .......................................................... 283 
anames ............................................................ 286 
AndProp ........................................................... 279 
antiderivative function ............................................. 46, 77 
antisymmetric matrix ................................................ 267 

312 
Catchword Index 
approximation to an expression by a rational expres sion ................. 121 
args ............................................................... 299 
argument .......................................................... 150 
array ......................................................... 265,266 
arrow ........................................................... 75,270 
assign ........................................................ 223,233 
assignment .................................................... 10,32,91 
assume ................................................. 36,50, 115,277 
asterisk ............................................................... 8 
asympt ............................................................ 111 
autosimplification .................................................... 33 
autosimplification of rational numbers .................................. 22 
back quotes ................................................. 40, 272, 287 
band matrices ....................................................... 270 
bezout matrix ....................................................... 160 
Catalan ............................................................ 22 
ceil ............................................................... 156 
Chebyshev ........................................................... 72 
check sols of ODE .............................................. 233, 236 
codegen[makeproc] .................................... 78,80,119,271 
codegen[optimize] ............................................... 119 
codegen [prep2trans] .............................................. 80 
coeff .............................................................. 161 
coefficients of a polynomial .......................................... 161 
collect ....................................................... 161,206 
colon ............................................................. 8, 10 
column vector ....................................................... 248 
combine ....................................................... 151, 166 
combine ( 
,cmbpwr) .............................................. 191 
combine ( 
,exp) ................................................. 191 
combine ( 
,In) ................................................... 198 
combine ( 
,power) ...................................... 191,192,213 
comment ............................................................ 85 
companion matrix ................................................... 261 
complex ............................................................. 23 
compoly ........................................................... 169 
components ......................................................... 137 
composition of two functions .......................................... 85 
composition, repeated ................................................. 85 
concatenation ........................................................ 39 
conjugate ......................................................... 150 
constants ............................................................ 38 
content ........................................................... 162 
continued fraction ................................................... 167 
continuous .......................................................... 116 

Catchword Index 
313 
control structure. condition ........................................... 298 
control structure. repetition ....................................... 269.301 
convert ( 
, confrac, <var» 
.................................... 121 
convert( 
,horner) .............................................. 119 
convert ( 
, piecewise) ....................................... 84.242 
convert( 
,polar) ............................................... 150 
convert ( 
, radical) ........................................ 175. 177 
convert ( 
, rational) ....................................... 118, 155 
convert ( 
,RootOf) ......................................... 175.182 
copy ............................................................... 264 
cost ............................................................... 120 
crash ................................................................ 42 
csgn ............................................................... 151 
O .........................•....•....•.•.....•................... 79,120 
decimal fractions ..................................................... 22 
decomposition of polynomials ........................................ 169 
degree ............................................................ 161 
denom .............................................................. 166 
denominator ........................................................ 166 
density plot .......................................................... 90 
derivative at a point ................................................... 45 
diag ............................................................... 270 
diagonal matrices .................................................... 270 
diff ........................................................... 43,142 
differential forms ..................................................... 46 
differentiation ................................................... 43. 120 
difforms ........................................................... 46 
Digits ....................................................... 5,27,118 
Dirac ................................................................ 79 
discriminant ........................................................ 160 
ditto ................................................ 11, 12, 14,33,66,91 
domain ............................................................. 215 
Domains ........................................................... 186 
dot .................................................................. 20 
double quote ................................................... 2. 12, 41 
do ... od ............................................................ 301 
dsolve ............................................................ 233 
e .................................................................... 74 
E .................................................................... 23 
elimination ......................................................... 172 
entering fewer variables than necessary in sol ve ....................... 172 
environment variables ................................................. 38 
estimation of the order term .......................................... 108 
eval ..................................................... 34,45,46, 142 
evala .............................................................. 183 

314 
Catchword Index 
evalc .......... . ...................................... 23, 149,200,213 
evalf ... ... . ......... . ... . . . ... . ............................ 27,57, 117 
evalhf ......................................................... 27, 121 
evalm ......................... . .................................... 251 
evaln .. . ........... . ............................................... 287 
evaluation ...................... . ................................ 32, 288 
evaluation at a point ................ . .......... . ... . .. .. ...... ... . 45, 142 
exp . . .......... . .. . .......... . .... . .... . ..... . .. .... ...... . .. .. ... . . 74 
exp of a matrix ... ... ... . ....................... .. ................... 262 
expand ........................ 157,166,190,192,198,199,203,207,213 
expandoff ......................................................... 208 
explicit solution ..................................................... 236 
exponential ..... .. . ... .. . .. .. .. .. .. ..... ...... . .......... ... .. . .. 262 
extrema ....................................... . ..................... 46 
factor ......................... . .............. . .............. . 176, 184 
Factor .......... . ............. . ................................... 186 
factorial ............ . ................ .. ........... .. ............. . ... 29 
factors .......................................................... . 177 
Fast Fourier Transform .......... . .................................... 121 
fast numeric al calculations ............................................. 27 
floating-point number ............................ . ................ 26, 247 
floor ........................ . .. . .......... ... . . . . .............. . .. 156 
fnormal . . . . ... .. ..... . ...... . ..... . ... .. ...... . ... . ............ 27, 131 
for ......................... . .. .. ........... .. . ..... ........ .. .. . .. 301 
forget ....................................... . ................ 209,294 
forward quotes ......................................... 35,39,41,67,287 
frac ... . .. ....... . . . ... . .......... . ................................ 156 
fraction ............ . ..... . ... .... ....... . ................. . ... . . . 141 
freeze ................................... ... . . . .. ........... . ..... 207 
frontend .......... .... ............................................ 209 
fsolve ........................................................ 178,224 
functions in more than one argument ............... . .................... 76 
Galois fields .. . ... . .... . ... . ... . ..... . ... . ....... . ....... . ....... 31, 186 
Gauss ........................ . ... . ............. .. . ... .............. 272 
Gaussian integers ..... ... ...................... ..... .................. 31 
gcd .............................. . ................................. 159 
gcdex . ........... . ............. .... ................................ 159 
Gegenbauer ....... .. ................ . . .. ....... . ............. . .... .. . 72 
genmatrix ...... . . . ... . ...... . ................ .. . .. ......... . ..... . 256 
graphs of functions .. . .. . ............................................. 87 
greatest common divisor ............................................. 159 
Groebner[gsolve] ................................................ 180 
group ........... ... . . ......... . .................................. . .. 31 
has .............. .. .. . . .. .. . ... . ... .. . . ... . ............ . .... .. ..... 147 
Heaviside ....................................................... 84, 242 

Catchword Index 
315 
Hennite ............................................................. 72 
hilbert ........................................................... 270 
hyperbolic functions ................................................. 205 
l .................................................................... 23 
identity ............................................................. 230 
identity matrix ...................................................... 268 
if ... fi ............................................................ 298 
imaginary part of a complex number ................................... 149 
implicit solution ..................................................... 235 
implicitly defined functions ....................................... 46, 103 
indets ............................................................ 216 
index ................................................................ 39 
index functions ...................................................... 266 
indexed name ....................................................... 287 
inert form ............................................................ 62 
inert procedures ..................................................... 272 
infolevel .................................................. 47,70,294 
int ............................................................. 46,142 
lnt .............................................................. 58,62 
intat ............................................................... 47 
integers .............................................................. 29 
integral transfonns ................................................... 242 
integral, definite ...................................................... 50 
integral, indefinite .................................................... 46 
integral, numeric ..................................................... 57 
integrate .......................................................... 46 
interp ............................................................ 167 
interpol ating polynomial function ..................................... 167 
intersect ......................................................... 132 
inttrans ........................................................... 53 
inverse hyperbolic functions ........................................... 73 
inverse trigonometric functions ........................................ 73 
iquo ............................................................ 29,67 
irem ................................................................ 29 
is ................................................................. 278 
iscont ............................................................ 116 
isolate ........................................................... 223 
Jacobi ............................................................... 72 
Jordan matrix ....................................................... 261 
keywords ............................................................ 37 
Laguerre ............................................................. 72 
lcm ................................................................ 160 
lcoeff ............................................................ 162 
ldegree ........................................................... 162 
leading terrn of a series ............................................... 11 O 

316 
Catchword Index 
leadterm .................... . . . .... . ................... ... .. . . .. . . 110 
least common multiple .. . .... . ..... . .. . . ... . ... .. . . .. .... . .. . ........ 160 
Legendre . ............. . ... . . ........ . . ..... . . . .... . .... . . . .. . ...... . 72 
lexical order ......... . ............................ . ........ . ... .. ... 286 
lhs . .. ......... . .. . . . ........................ . .. . ............ .. .... 221 
limit ............ . ............. . ................ . .................. 114 
linalg . . . .. . ...... .... ... . .... ... ... . . .. . . . .. . . ...... .. .... .. ..... 247 
linear programming .. . ...... .. ...... . ..... . .... . . .. . . .... . .... . . . . . .. 258 
linsolve ....... . . .. . . .......... . ........................... . ...... 257 
list ... .. ..................................... ... ............... . .... 124 
In . ... ............. . ......................... . . . .................... 73 
lprint .. .. ... . . .... .... . ... . ......... . ... . . . ............. 12,38,66,74 
macro ....... . .. . . .. . .. . . .. . . . .. . . .. . . .. ... ... . . . . . . . . .... ..... . . . .. 285 
manipulation of graphical objects ............... . .... . .................. 91 
map ............... . ... . ......... .. ............ .. .......... 127, 206, 252 
map2 .. . ............ . ......... .. . . .. . ........ ... .......... . .. . ...... 129 
match .. . ...... . .. . . . ..... . . . ........ .. ........ .. .. . ......... . ...... 230 
max ........ . .... . .. . . . .. .. ...... . .. .. . .. ..... .. .. .. .. . . . . . . 84, 129,242 
maximal element . .... . .... . .... . . .. . .. . . ... . . . ... .. ... . ..... ..... ... 129 
maximum absolute value of a function . ......... . ............... . ...... 121 
member ........... . .............. . ............ . .............. . ..... 129 
min . . . ....................... . ...... .. ........ . ............ 84,129,242 
minimal element . .. ... ..... .. . ... . .. ... . ....... ..... ... . .. . ... . . . ... 129 
minimal polynomial ... . ........... . .. .. ......... . . .. . . ......... ... .. 261 
mint ............................................ . .......... . . . ..... 298 
minus .............. . ............. .. ............ . ................... 132 
mod .......... . ..... . ........ . . ... .. .. ............................... 30 
modulo . .. . . . . . .. . .. . ... . .. .... ... ..... . ... .. .. . . . ... . ..... .... . 30, 272 
msolve .......................... . ........... .. . .. .. .. .. . . . . . . .. ... 186 
mtaylor ......................... . ........... . ..................... 113 
nargs . .............. . .............................................. 299 
nops ............. . ............... .. . . ..... . . ... .. . ....... . .... 124, 147 
norm from standard library .. . ... . . .. . .. . . . .. .... . . . .... . ....... . .... 163 
norm from linalg package ............... . .. ...... . ... . . .. . . .... . . . 261 
normal ........................ . . . .. . .......... . . .. .. 5,55, 165, 182,213 
normal( 
,expanded) ......... . .............................. 166,190 
NULL .. .......... .... . . ........... . . . ....................... . .. . .... 124 
numapprox [infnormJ .. . ... . ................ . ... ... .... ...... . . .. . . 109 
number of elements . .......... . ........ .. ... . .. . . . .. . ... . ... . ... . ... . 124 
number of operands ............. . .. .. ......... . . . ......... . .. . . ..... . 147 
numer . . ........................................ . ............ . .. . ... 166 
numerator ....... . . . . .... ..... . .... . . . .............................. 166 
numerical approximation .... . ...... ... ....... . . . .................... . . 27 
numerical approximation to an antiderivative .. . . . .. . .. .. .. . ... .. . .. .... . 58 
numeric al integration . .. . .. . ...... ....... ....................... .. ... 120 

Catchword Index 
317 
odetest ........................................................... 233 
op ............................................... 109, 124, 133, 137, 138 
operands ........................................................... 137 
operator ..................................................... 19, 31, 283 
optimization problems in linear equations .............................. 258 
optimization problems in linear inequalities ............................ 258 
options .............................................................. 65 
Order ......................................................... 108,115 
order in printing expressions ........................................... 33 
order of a series expansion ........................................... 108 
OrProp ............................................................ 279 
Output Display .................................................... 13, 16 
Pade approximation .................................................. 121 
parameterization .................................................... 172 
parameterized curve .............................................. 97, 103 
parametric solution .................................................. 236 
partial differential equations .......................................... 246 
partial fraction decomposition ........................................ 167 
pattern matching .................................................... 230 
PDEtools [dchange] ............................................ 52, 243 
peadic numbers ....................................................... 31 
percentage sign ........................................................ 2 
Pi ............................................................... 22,38 
piecewise .................................................. 82,84,242 
plot ........................................................... 87,303 
plot options, changing defaults ......................................... 90 
plot3d ......................................................... 88,303 
plots [animate3d] ................................................ 105 
plots [animate] ................................................... 105 
plots[display] ............................................... 91,104 
plots [setoptions3d] .............................................. 90 
plots [setoptions] ................................................ 90 
plots [spacecurve] ................................................ 98 
polar coordinates .................................................... 150 
polynomials ........................................................ 157 
precedence rules ...................................................... 20 
primitive function ................................................. 46, 77 
print ........................................................ 12,66,91 
printlevel ....................................................... 302 
proc ............................................................... 296 
procedure .................................................... 14,79,296 
procedure, print source ................................................ 71 
product ............................................................ 62 
property ......................................................... 36, 277 
protected ............................................................ 37 

318 
Catchword Index 
quo . ..... . ....................... .. ........ ... . . ............... . ... 158 
radical ..... . .. .. ......... .. .. . .. . .... . .... . .. . ... . ...... ...... . . 24, 182 
radnormal . ................. .... .. ...... ... . .. ....... .. .. . ... . ... .. 152 
radsimp .......................... . .............. . ....... . ... . . 197,213 
random matrices and vectors ................................... .. . . ... 266 
range ... ........... . ... . ......... .. ... . ......... . ...... . . 50,60, 87,131 
rational complex numbers .. . . .... .. . . .. . . . . . .. .. . . . . . ... ... .. . ... . . . . . 24 
rational numbers . . ..... .. .. .. . .. .. .. . ...... .. ... .. . .. .... . . ... . ... .. 141 
rationalize ..... .. . .. .......... . . ... ....... .. . . ........ . . . . .. 151,196 
readlib ......................... .. .......................... . ...... 68 
real part of a complex number ....... . .............. . ............. . ... 149 
recurrence relations .. .. ... . .. ....... . ... . . . . ... ..... .. .. .. .. . . .. ... .. 229 
recursive definition . ... . . ...... .. ...... . ............. . ................ 41 
refer . . ................ . ........................... . ........ . ..... 10, 32 
reliability ........... ... ........ 44,53,56,110,111,115,167,169,213,247 
rem . . . . . ........ . . . . ... ..... . .. .. . . .............. . ................. 158 
remember table . . ... . . . ...... . ..... . ............. . ......... . . . . . 208, 292 
remove .. . . .... .. . ...... .. . . . ... ...... ... . . .... . .. ..... . .. 131, 217,277 
residue .. ......... . .. . ........ ... . . . .. ..... . .. .... . . ................ 116 
restart .......................................... . ....... . ... . ..... 36 
resultant ............................ . .......... ... . . ......... .. ..... 160 
rhs . ....... . .... . ... . .. . ..... ... . . . . . . ... . . ... . .. . . .......... . ..... 221 
root of a complex number ... . ... . ... . ..... . ...... .. . . . . . .. . .. . .. . . . .. 152 
RootOf . .................... 48, 169,171,173,174,177,212,220,228,304 
roots ............ . ........................... ..... ........... . ..... 184 
Roots .. . . ........ .. . . ......... . .. . ............ .. .......... .... ..... 186 
root [n] ( 
) .. . ... . .... . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 25 
round . .... . . . ..... ... . ..... .... .. . . ... . . . ...... . ... .... ... . .. .. .... 155 
row vector .......... ... . ... .... .. . . ........ . .... . .. . .. . ... . . .. . ... .. 248 
rsolve . . ......... . ............. . .. . ....... ... .. . ............ . ..... 229 
save session or state ............... .. ................................ 291 
scaling=CONSTRAINED ............ . ........ . .............. . . . . . 88, 104 
select . . ........ .. .... .. ..... . . .... ...... . .. .. ........... . . . .. 130,277 
semicolon .. . .. . . . .. . ....... . ........... . . . .. ... ............ .. ..... .. .. 8 
seq ............... . . . ........... . ............... . ....... . .......... 131 
sequences ......... ... ........................ .. . . . . ................ 123 
series . .. ......................... . . . ............ . .. .. ..... 107, 226, 239 
series structure . ........... . .... . ... . . . .......... .. . . .. . . ... .. . . . .... 110 
set . .. . ... ... . . . . . ... .... ........ . ..... . .... . . ..... ......... . . ... ... 123 
share library ....... . ............ .... . . ........... . ...... . .... . ..... . . 69 
showtime .................................... . ............. ... ...... 13 
side relations .... ..... . . ......... . ............ 146, 163, 185,203,222,236 
sign . . .. . .......... .. ........ .. ..... . ......... .. .. .. ....... . .. 150,151 
signum . . ... .. ... . ... ... . .... .. . .. ... ... . .. ... .. .. . . .. . . . . . 84, 150,242 
simplification ...... . . .. . ....... . ....... . ..... ... .......... . .. . ....... 33 

Catchword Index 
319 
simplify .................................................. 24, 165,213 
simplify( 
,arctrig) ........................................... 213 
simplify( 
,commonpow) .................................... 190,195 
simplify( 
,exp) ................................................ 191 
simplify( 
,ln) ........................................ 198,199,213 
simplify( 
,power) ................................ 191,192,193,198 
simplify( 
,radical) ........................................... 195 
simplify( 
,sqrt) ............................................... 196 
single back quotes .................................................... 40 
single forward quotes .......................................... 35,39,41 
singularity .......................................................... 116 
solve ........................................ 3,6,36,168,214,256,304 
solving equations in integer variables .................................. 231 
solving equations in variables over Z mod m ........................... 231 
solving identities .................................................... 230 
sort ............................................................... 164 
sparse matrix ........................................................ 267 
spline ............................................................ 102 
split .............................................................. 177 
sqrt ................................................................ 24 
square root ........................................................... 24 
squarefree factorization .............................................. 178 
Sturm theorem ...................................................... 170 
subexpression .................................................. 137, 138 
subs ........................................................... 45, 136 
subsop ............................................................ 148 
substitution ...................................................... 45,136 
substitutions simultaneously .......................................... 144 
sum ............................................................. 60,142 
Sum ................................................................. 62 
surd ................................................................ 25 
syl vester ......................................................... 270 
symbolic, option ................................ 189,193,201,202,213 
symmetric matrix .................................................... 266 
TayIor ..................................................... 107,226,239 
tcoeff ............................................................ 162 
testeq ............................................................ 211 
thaw ............................................................... 207 
tilde ............................................................ 36, 277 
toepli tz .......................................................... 270 
trace (from standard library) ........................................ 298 
trace (from linalg package) ....................................... 255 
transpose ......................................................... 248 
trigsubs .......................................................... 205 
trunc .............................................................. 155 

320 
Catchword Index 
type ........................................................... 274,275 
unapply ........................................................ 77,271 
unassign ........................................................... 35 
underscore ........................................................... 38 
unevaluated function caII ........................................... 15,73 
union ......................................................... 132,305 
value ........................................................... 52,63 
vandermonde ...................................................... 270 
verify ............................................................ 212 
very large polynomials ............................................... 158 
void list ............................................................ 124 
void sequence ....................................................... 124 
void set ............................................................. 124 
whattype ..................................................... 109,274 
where .............................................................. 237 
while .............................................................. 303 
with ................................................................ 69 
Z-transform .......................................................... 62 

321 
notes: 

322 
notes: 

323 
notes: 

324 
notes: 

325 
notes: 

