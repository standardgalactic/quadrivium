Функциональное программирование
1
Введение
Программы на традиционных языках программирования, таких как
Си, Паскаль, Java и т.п. состоят их последовательности модификаций
значений некоторого набора переменных, который называется состояни-
ем. Если не рассматривать операции ввода-вывода, а также не учитывать
того факта, что программа может работать непрерывно (т.е. без оста-
новок, как в случае серверных программ), можно сделать следующую
абстракцию. До начала выполнения программы состояние имеет некото-
рое начальное значение σ0, в котором представлены входные значения
программы. После завершения программы состояние имеет новое значе-
ние σ′, включающее в себя то, что можно рассматривать как «результат»
работы программы. Во время исполнения каждая команда изменяет со-
стояние; следовательно, состояние проходит через некоторую конечную
последовательность значений:
σ = σ0 →σ1 →σ2 →· · · →σn = σ′
Состояние модифицируется с помощью команд присваивания, запи-
сываемых в виде v=E или v:=E, где v — переменная, а E — некоторое
выражение. Эти команды следуют одна за другой; операторы, такие как
if и while, позволяют изменить порядок выполнения этих команд в
зависимости от текущего значения состояния. Такой стиль программи-
рования называют императивным или процедурным.
Функциональное программирование представляет парадигму, в корне
отличную от представленной выше модели. Функциональная программа
представляет собой некоторое выражение (в математическом смысле);
выполнение программы означает вычисление значения этого выражения.1
С учетом приведенных выше обозначений, считая что результат работы
1Употребление термина «вычисление» не означает, что программа может опериро-
вать только с числами; результатом вычисления могут оказаться строки, списки и
вообще, любые допустимые в языке структуры данных.
1

императивной программы полностью и однозначно определен ее входом,
можно сказать, что финальное состояние (или любое промежуточное)
представляет собой некоторую функцию (в математическом смысле) от
начального состояния, т.е. σ′ = f(σ). В функционально программиро-
вании используется именно эта точка зрения: программа представляет
собой выражение, соответствующее функции f. Функциональные языки
программирования поддерживают построение таких выражений, предо-
ставляю широкий выбор соответствующих языковых конструкций.
При сравнении функционального и императивного подхода к про-
граммированию можно заметить следующие свойства функциональных
программ:
• Функциональные программы не используют переменные в том смыс-
ле, в котором это слово употребляется в императивном программи-
ровании. В частности в функциональных программах не использу-
ется оператор присваивания.
• Как следствие из предыдущего пункта, в функциональных про-
граммах нет циклов.
• Выполнение последовательности команд в функциональной про-
грамме бессмысленно, поскольку одна команда не может повлиять
на выполнение следующей.
• Функциональные программы используют функции гораздо более
замысловатыми способами. Функции можно передавать в другие
функции в качестве аргументов и возвращать в качестве резуль-
тата, и даже в общем случае проводить вычисления, результатом
которого будет функция.
• Вместо циклов функциональные программы широко используют ре-
курсивные функции.
На первый взгляд функциональный подход к программированию мо-
жет показаться странным, непривычным и мало полезным, однако необ-
ходимо принять во внимание следующие соображения.
Прежде всего, императивный стиль в программировании не является
жестко заданной необходимостью. Многие характеристики императив-
ных языков программирования являются результатом абстрагирования
от низкоуровневых деталей реализации компьютера, от машинных кодов
к языкам ассемблера, а затем к языкам типа Фортрана и т.д. Однако нет
причин полагать, что такие языки отражают наиболее естественный для
2

человека способ сообщить машине о своих намерениях. Возможно, бо-
лее правилен подход, при котором языки программирования рождаются
как абстрактные системы для записи алгоритмов, а затем происходит их
перевод на императивный язык компьютера.
Далее, функциональный подход имеет ряд преимуществ перед импе-
ративным. Прежде всего, функциональные программы более непосред-
ственно соответствуют математическим объектам, и следовательно, поз-
воляют проводить строгие рассуждения. Установить значение импера-
тивной программы, т.е. той функции, вычисление которой она реализует,
может оказаться довольно трудно. Напротив, значение функциональной
программы может быть выведено практически непосредственно.
Например, рассмотрим следующую программу на языке Haskell:
factorial n = if n == 0 then 1 else n * factorial (n - 1)
Практически сразу видно, что эта программа соответствует следующей
частичной функции:
f(n) =
(
n!
n ≥0
⊥
n < 0
(Здесь символ ⊥означает неопределенность функции, поскольку при
отрицательных значениях аргумента программа не завершается.) Однако
для программы на языке Си это соответствие не очевидно:
int f (int n)
{
int x = 1;
while (n > 0)
{
x = x * n;
n = n - 1;
}
return x;
}
Следует также сделать замечание относительно употребления тер-
мина «функция» в таких языках как Си, Java и т.п. В математическом
смысле «функции» языка Си не являются функциями, поскольку:
• Их значение может зависеть не только от аргументов;
• Результатом их выполнения могут быть разнообразные побочные
эффекты (например, изменение значений глобальных переменных)
3

• Два вызова одной и той же функции с одними и теми же аргумен-
тами могут привести к различным результатам.
Вместе с тем функции в функциональных программах действительно
являются функциями в том смысле, в котором это понимается в мате-
матике. Соответственно, те замечания, которые были сделаны выше, к
ним не применимы. Из этого следует, что вычисление любого выраже-
ния не может иметь никаких побочных эффектов, и значит, порядок вы-
числения его подвыражений не оказывает влияния на результат. Таким
образом, функциональные программы легко поддаются распараллелива-
нию, поскольку отдельные компоненты выражений могут вычисляться
одновременно.
2
Основы лямбда-исчисления
Подобно тому, как теория машин Тьюринга является основой импера-
тивных языков программирования, лямбда-исчисление служит базисом
и математическим «фундаментом», на котором основаны все функцио-
нальные языки программирования.
Лямбда-исчисление было изобретено в начале 30-х годов логиком
А. Черчем, который надеялся использовать его в качестве формализма
для обоснования математики. Вскоре были обнаружены проблемы, де-
лающие невозможным его использование в этом качестве (сейчас есть
основания полагать, что это не совсем верно) и лямбда-исчисление оста-
лось как один из способов формализации понятия алгоритма.
В настоящее время лямбда-исчисление является основной из таких
формализаций, применяемой в исследованиях связанных с языками про-
граммирования. Связано это, вероятно, со следующими факторами:
• Это единственная формализация, которая, хотя и с некоторыми
неудобствами, действительно может быть непосредственно исполь-
зована для написания программ.
• Лямбда-исчисление дает простую и естественную модель для таких
важных понятий, как рекурсия и вложенные среды.
• Большинство конструкций традиционных языков программирова-
ния может быть более или менее непосредственно отображено в
конструкции лямбда-исчисления.
• Функциональные языки являются в основном удобной формой син-
таксической записи для конструкций различных вариантов лямбда-
исчисления. Некоторые современные языки (Haskell, Clean) имеют
4

100% соответствие своей семантики с семантикой подразумевае-
мых конструкций лямбда-исчисления.
В математике, когда необходимо говорить о какой-либо функции,
принято давать этой функции некоторое имя и впоследствии исполь-
зовать его, как, например, в следующем утверждении:
Пусть f : R →R определяется следующим выражением:
f(x) =
(
0,
x = 0
x2 sin(1/x2),
x ̸= 0
Тогда f ′(x) не интегрируема на интервале [0, 1].
Многие языки программирования также допускают определение функ-
ций только с присваиванием им некоторых имен. Например, в языке Си
функция всегда должна иметь имя. Это кажется естественным, однако
поскольку в функциональном программировании функции используются
повсеместно, такой подход может привести к серьезным затруднениям.
Представьте себе, что мы должны всегда оперировать с арифметически-
ми выражениями в подобном стиле:
Пусть x = 2 и y = 4. Тогда xx = y.
Лямбда-нотация позволяет определять функции с той же легкостью,
что и другие математические объекты. Лямбда-выражением будем на-
зывать конструкцию вида
λx.E
где E — некоторое выражение, возможно, использующее переменную x.
Пример. λx.x2 представляет собой функцию, возводящую свой аргумент в квадрат.
Использование лямбда-нотации позволяет четко разделить случаи,
когда под выражением вида f(x) мы понимаем саму функцию f и ее зна-
чение в точке x. Кроме того, лямбда-нотация позволяет формализовать
практически все виды математической нотации. Если начать с констант
и переменных и строить выражения только с помощью лямбда-выраже-
ний и применений функции к аргументам, то можно представить очень
сложные математические выражения.
Применение функции f к аргументу x мы будем обозначать как f x,
т.е., в отличие от того, как это принято в математике, не будем исполь-
зовать скобки2. По причинам, которые станут ясны позднее, будем счи-
тать, что применение функции к аргументу ассоциативно влево, т.е. f x y
2Заметим, что и в математике такие выражения, как sin x записываются без скобок.
5

означает (f(x))(y). В качестве сокращения для выражений вида λx.λy.E
будем использовать запись λx y.E (аналогично для большего числа ар-
гументов). Также будем считать, что «область действия» лямбда-выра-
жения простирается вправо насколько возможно, т.е., например, λx.x y
означает λx.(x y), а не (λx.x)y.
На первый взгляд кажется, что нам необходимо ввести специальное
обозначение для функций нескольких аргументов. Однако существует
операция каррирования3, позволяющая записать такие функции в обыч-
ной лямбда-нотации. Идея заключается в том, чтобы использовать вы-
ражения вида λx y.x + y. Такое выражение можно рассматривать как
функцию R →(R →R), т.е. если его применить к одному аргументу,
результатом будет функция, которая затем принимает другой аргумент.
Таким образом:
(λx y.x + y) 1 2 = (λy.1 + y) 2 = 1 + 2.
Переменные в лямбда-выражениях могут быть свободными и связан-
ными. В выражении вида x2 + x переменная x является свободной; его
значение зависит от значения переменной x и в общем случае ее нельзя
переименовать. Однако в таких выражениях как Pn
i=1 i или
R x
0 sin y dy
переменные i и y являются связанными; если вместо i везде использо-
вать обозначение j, значение выражения не изменится.
Следует понимать, что в каком-либо подвыражении переменная мо-
жет быть свободной (как в выражении под интегралом), однако во всем
выражении она связана какой-либо операцией связывания переменной,
такой как операция суммирования. Та часть выражения, которая нахо-
дится «внутри» операции связывания, называется областью видимости
переменной.
В лямбда исчислении выражения λx.E[x] и λy.E[y] считаются экви-
валентными (это называется α-эквивалентностью, и процесс преобразо-
вания между такими парами называют α-преобразованием). Разумеется,
необходимо наложить условие, что y не является свободной переменной
в E[x].
3от фамилии известного логика Хаскелла Карри, в честь которого назван язык
программирования Haskell
6

3
Лямбда-исчисление как формальная систе-
ма
Лямбда-исчисление основано на формальной нотации лямбда-терма,
составляемого из переменных и некоторого фиксированного набора кон-
стант с использованием операции применения функции и лямбда-абстра-
гирования. Сказанное означает, что все лямбда-выражения можно раз-
делить на четыре категории:
1. Переменные: обозначаются произвольными строками, составлен-
ными из букв и цифр.
2. Константы: также обозначаются строками; отличие от переменных
будем определять из контекста.
3. Комбинации:, т.е. применения функции S к аргументу T; и S и T
могут быть произвольными лямбда-термами. Комбинация записы-
вается как S T.
4. Абстракции произвольного лямбда-терма S по переменной x, обо-
значаемые как λx.S.
Таким образом, лямбда-терм определяется рекурсивно и его грамма-
тику можно определить в виде следующей формы Бэкуса-Наура:
Exp = Var | Const | Exp Exp | λ Var . Exp
В соответствие с этой грамматикой лямбда-термы представляются в ви-
де синтаксических деревьев, а не в виде последовательности символов.
Отсюда следует, что соглашения об ассоциативности операции примене-
ния функции, эквивалентность выражений вида λx y.S и λx.λy.S, неод-
нозначность в именах констант и переменных проистекают только из
необходимости представления лямбда-термов в удобном человеку виде,
и не являются частью формальной системы.
3.1
Свободные и связанные переменные
В данном разделе мы формализуем данное ранее интуитивное пред-
ставление о свободных и связанных переменных. Множество свободных
7

переменных FV (S) лямбда-терма S можно определить рекурсивно сле-
дующим образом:
FV (x)
=
{x}
FV (c)
=
∅
FV (S T)
=
FV (S) ∪FV (T)
FV (λx.S)
=
FV (S)\{x}
Аналогично множество связанных переменных BV (S) определяется сле-
дующими формулами:
BV (x)
=
∅
BV (c)
=
∅
BV (S T)
=
BV (S) ∪BV (T)
BV (λx.S)
=
BV (S) ∪{x}
Здесь предполагается, что c — некоторая константа.
Пример.
Для терма S = (λx y.x) (λx.z x) можно показать, что FV (S) = {z} и
BV (S) = {x, y}.
3.2
Подстановки
Интуитивно ясно, что применение терма λx.S как функции к аргу-
менту T дает в результате терм S, в котором все свободные вхождения
переменной x заменены на T. Как ни странно, формализовать это инту-
итивное представление оказывается нелегко.
Будем обозначать операцию подстановки терма S вместо перемен-
ной x в другом терме T как T[x := S]. Также, как и в определение
свободных и связанных переменных, правила подстановки также можно
определить рекурсивно. Трудность состоит в том, что необходимо нало-
жить дополнительные ограничения, позволяющие избегать конфликта в
именах переменных.
x[x := T]
=
T
y[x := T]
=
y, если x ̸= y
c[x := T]
=
c
(S1 S2)[x := T]
=
S1[x := T] S2[x := T]
(λx.S)[x := T]
=
λx.S
(λy.S)[x := T]
=
λy.(S[x := T]), если x ̸= y и x /∈FV (S), либо y /∈FV (T)
(λy.S)[x := T]
=
λz.(S[y := z][x := T]) иначе, где z /∈FV (S) ∪FV (T)
8

3.3
Конверсия
Лямбда-исчисление основано на трех операциях конверсии, которые
позволяют переходить от одного терма к другому, эквивалентному ему.
По сложившейся традиции эти конверсии обозначают греческими бук-
вами α, β и η. Они определяются следующим образом:
• α-конверсия: λx.S
α−→λy.S[x := y] при условии, что y /∈FV (S).
Например, λu.u v
α−→λw.w u.
• β-конверсия: (λx.S) T
β−→S[x := T].
• η-конверсия: λx.T x
η−→T, если x /∈FV (T). Например, λu.v u
η−→v.
Для нас наиболее важна β-конверсия, поскольку она соответству-
ет вычислению значения функции от аргумента. α-конверсия является
вспомогательным механизмом для того, чтобы изменять имена связан-
ных переменных, а η-конверсия интересна в основном при рассмотрении
лямбда-исчисления с точки зрения логики, а не программирования.
3.4
Равенство лямбда-термов
Используя введенные правила конверсии, можно формально опреде-
лить понятие равенства лямбда-термов. Два терма равны, если от одного
из них можно перейти к другому с помощью конечной последователь-
ности конверсий. Определим понятие равенства следующими выраже-
ниями, в которых горизонтальные линии следует понимать как «если
утверждение над чертой выполняется, то выполняется и утверждение
9

под ней»:
S
α−→T или S
β−→T или S
η−→T
S = T
T = T
S = T
T = S
S = T и T = U
S = U
S = T
S U = T U
S = T
U S = U T
S = T
λx.S = λx.T
Следует отличать понятие равенства, определяемое этими формула-
ми, от понятия синтаксической эквивалентности, которую мы будем обо-
значать специальным символом ≡. Например, λx.x ̸≡λy.y, но λx.x =
λy.y. Часто можно рассматривать синтаксическую эквивалентность тер-
мов с точностью до α-конверсий. Такую эквивалентность будем обозна-
чать символом ≡α. Это отношение определяется так же, как равенство
лямбда-термов, за тем исключением, что из всех конверсий допустимы
только α-конверсии. Таким образом, λx.x ≡α λy.y.
3.5
Экстенсиональность
η-конверсия в лямбда-исчислении выражает собой принцип экстен-
сиональности. В общефилософском смысле два свойства называются
экстенсионально эквивалентными, если они принадлежат в точности од-
ним и тем же объектам. В математике, например, принят экстенсиональ-
ный взгляд на множества, т.е. два множества считаются одинаковыми,
если они содержат одни и те же элементы. Аналогично мы говорим, что
две функции равны, если они имеют одну и ту же область определения, и
для любых значений аргумента из этой области определения вычисляют
один и тот же результат.
10

Вследствие наличия η-конверсии определенное нами выше отношение
равенства лямбда-термов экстенсионально. Действительно, если f x и
g x равны для любого x, то в частности f y = g y, где y не является
свободной переменной ни в f, ни в g. Следовательно, по последнему
правилу в определении равенства лямбда-термов, имеем λy.f y = λy.g y.
Теперь, если несколько раз применить η-конверсию, можно получить, что
f = g. И обратно, экстенсиональность дает то, что каждое применение
η-конверсии действительно приводит к равенству, поскольку по правилу
β-конверсии (λx.T x) y = T y для любого y, если x не свободна в T.
3.6
Редукция лямбда-термов
Отношение равенства лямбда-термов, разумеется, симметрично. Хотя
оно хорошо отражает понятие эквивалентности лямбда-термов, с вычис-
лительной точки зрения более интересно будет рассмотреть асимметрич-
ный вариант. Определим отношение редукции (обозначаемое символом
→) следующим образом:
S
α−→T или S
β−→T или S
η−→T
S →T
T →T
S →T и T →U
S →U
S →T
S U →T U
S →T
U S →U T
S →T
λx.S →λx.T
Несмотря на то, что термин «редукция» подразумевает уменьшение
размера лямбда-терма, в действительности это может быть не так, что
11

показывает следующий пример:
(λx.x x x) (λx.x x x)
→
(λx.x x x) (λx.x x x) (λx.x x x)
→
(λx.x x x) (λx.x x x) (λx.x x x) (λx.x x x)
→
. . .
Тем не менее отношение редукции соответствует систематическим по-
пыткам вычислить терм, последовательно вычисляя комбинации f(x),
где f-некоторая лямбда-абстракция. Когда для терма невозможно сде-
лать никакую редукцию, за исключением α-преобразования, будем гово-
рить, что терм находится в нормальной форме.
3.7
Редукционные стратегии
Давайте отвлечемся от теоретических рассуждений и вспомним важ-
ность рассматриваемых вопросов для функционального программирова-
ния. Функциональная программа представляет собой выражение, и вы-
полнение ее означает вычисление этого выражения. Употребляя введен-
ные термины, можно сказать, что мы начинаем с соответствующего тер-
ма и последовательно применяем редукции до тех пор, пока это возмож-
но. Но какую же именно редукцию применять на каждом конкретном
шаге? Отношение редукции не детерминистично, т.е. для некоторого
терма t существует несколько различных ti, таких что t →ti. Иногда
выбор между ними означает выбор между конечной и бесконечной по-
следовательности редукций, т.е. между завершением и зацикливанием
программы. Например, если мы начнем редукцию с самого внутреннего
редекса4 в следующем примере, мы получим бесконечную последова-
тельность редукций:
(λx.y) ((λx.x x x) (λx.x x x))
→
(λx.y) ((λx.x x x) (λx.x x x) (λx.x x x))
→
(λx.y) ((λx.x x x) (λx.x x x) (λx.x x x) (λx.x x x))
→
. . .
Однако если мы начнем с самого внешнего редекса, то мы сразу получим:
(λx.y) ((λx.x x x) (λx.x x x)) →y,
и больше нельзя применить никакую редукцию.
Следующая теорема утверждает, что наблюдение, сделанное в преды-
дущем примере, верно и в более общем смысле.
4От англ. redex (REDucible EXpression)
12

Теорема 1. Если S →T, где T находится в нормальной форме, то
последовательность редукций, начинающаяся с S, и заключающая-
ся в том, что для редукции всегда выбирается самый левый и самый
внешний редекс, гарантированно завершится и приведет терм в нор-
мальную форму.
Понятие «самого левого и самого внешнего» редекса можно опреде-
лить индуктивно: для терма (λx.S) T это будет сам терм; для любого
другого терма S T это будет самый левый и самый внешний редекс в S,
и для абстракции λx.S это будет самый левый самый внешний редекс
в S. В терминах нашего конкретного синтаксиса мы всегда редуцируем
редекс, чей символ λ находится левее всего.
Следующая теорема, известная как теорема Черча–Россера, утвер-
ждает, что если мы начнем с терма T и проведем две произвольные
конечные последовательности редукций, всегда будут существовать еще
две последовательности редукций, которые приведут нас к одному и то-
му же терму (хотя он может и не находиться в нормальной форме).
Теорема 2. Если t →s1 и t →s2, то существует терм u, такой, что
s1 →u и s2 →u.
Эта теорема имеет несколько важных следствий.
Следствие 1. Если t1 = t2, то существует терм u такой, что t1 →u
и t2 →u.
Следствие 2. Если t = t1 и t = t2, где t1 и t2 находятся в нормальной
форме, то t1 ≡α t2, т.е. t1 и t2 равны с точностью до переименования
переменных.
Следовательно, нормальная форма, если она существует, единственна
с точностью до до α-конверсии.
С вычислительной точки зрения это означает следующее. В неко-
тором смысле, стратегия редуцирования самого левого самого внешне-
го редекса (будем называть ее нормализованной стратегией) является
наилучшей, поскольку она приведет к результату, если он достижим с
помощью какой-либо стратегии. С другой стороны, любая завершающа-
яся последовательность редукций всегда приводит к одному и тому же
результату. Более того, никогда не поздно прекратить выполнять редук-
ции по заданной стратегии и вернуться к нормализованной стратегии.
13

4
Комбинаторы
Теория комбинаторов была разработана еще до создания лямбда-
исчисления, однако мы будем рассматривать ее в терминах, введенных
нами ранее. Комбинатором будем называть лямбда-терм, не содержа-
щий свободных переменных. Такой терм является замкнутым; он имеет
фиксированный смысл независимо от значения любых переменных.
В теории комбинаторов установлено, что с помощью несколько базо-
вых комбинаторов и переменных можно выразить любой терм без приме-
нения операции лямбда-абстракции. В частности, замкнутый терм можно
выразить только через эти базовые комбинаторы. Определим эти комби-
наторы следующим образом:
I
=
λx.x
K
=
λx y.x
S
=
λf g x.f x (g x)
I является функцией идентичности, которая оставляет свой аргумент
неизменным. K служит для создания постоянных (константных) функ-
ций: применив его к аргументу a, получим функцию λx.a, которая воз-
вращает a независимо от переданного ей аргумента. Комбинатор S яв-
ляется «разделяющим»: он берет две функции и аргумент и «разделяет»
аргумент между функциями.
Теорема 3. Для любого лямбда-терма t существует терм t′, не со-
держащий лямбда-абстракций и составленный из комбинаторов S,
K, I и переменных, такой что FV (t′) = FV (t) и t′ = t.
Эту теорему можно усилить, поскольку комбинатор I может быть
выражен в терминах S и K. Действительно, для любого A выполняется:
S K A x
=
K x (A x)
=
(λy.x) (A x)
=
x
Применяя η-конверсию, получаем, что I = S K A для любого A. По
причинам, которые станут ясны в дальнейшем, мы будем использовать
A = K. Таким образом, I = S K K, и в дальнейшем символ I можно
исключать из выражений, составленных из комбинаторов.
Хотя мы представили комбинаторы как некоторые лямбда-термы, мож-
но разработать теорию, в которой они являются базовым понятием. Так-
же, как и в лямбда-исчислении, можно начать с формального синтаксиса,
14

вместо лямбда-абстракций содержащего комбинаторы. Вместо правил α,
β и η-конверсии, можно ввести правила конверсии для выражений, со-
держащих комбинаторы, например K x y →x. Как независимая теория,
теория комбинаторов обладает многими аналогиями с лямбда-исчисле-
нием, в частности, для нее выполняется теорема Черча–Россера. Однако
эта теория менее интуитивно понятно, поскольку выражения с комбина-
торами могут быстро становиться сложными и запутанными.
Комбинаторы имеют не только теоретический интерес. Как мы уже
говорили, и как станет ясно из последующих глав, лямбда-исчисление
может рассматриваться как простой функциональный язык программи-
рования, составляющий ядро настоящих языков, таких как ML или
Haskell. Тогда можно сказать, что приведенная выше теорема показыва-
ет, что лямбда-исчисление может быть в некотором смысле «скомпили-
ровано» в «машинный код» комбинаторов. Комбинаторы действительно
используются как метод реализации функциональных языков не только
на уровне программного, но и на уровне аппаратного обеспечения.
5
Лямбда-исчисление как язык программиро-
вания
5.1
Введение
5.2
Представление данных в лямбда-исчислении
Программы предназначены для обработки данных, поэтому необхо-
димо начать с того, чтобы зафиксировать лямбда-выражения, представ-
ляющие данные. Затем мы определим базовые операции на этих данных.
Часто будет возможно показать, как строка s, представляющая некото-
рое описание в читаемом человеком формате может быть закодирована в
виде лямбда-выражения s′. Эта процедура известна как «синтаксический
сахар». Будем записывать такую процедуру как
s ≜s′
Эту запись следует читать как «s = s′ по определению». Можно трак-
товать ее как определение некоторой константы s, обозначающей опера-
цию, которую затем можно использовать в стиле, принятом в лямбда-
исчислении.
15

5.2.1
Булевские значения и условия
Для кодирования значений true и false можно использовать любые
неравные лямбда-термы, но лучше всего определить их следующим об-
разом:
true
≜
λx y.x
false
≜
λx y.y
Используя эти определения, можно легко определить условное выра-
жение (напоминающее конструкцию ?:) языка Си. Заметьте, что это —
условное выражение, а не условная команда (в нашем контексте это
понятие не имеет смысла), следовательно, else-часть обязательна:
if E then E1 else E2 ≜E E1 E2.
Действительно:
if true then E1 else E2
≜
true E1 E2
≜
(λx y.x) E1 E2
≜
E1
и
if false then E1 else E2
≜
true E1 E2
≜
(λx y.y) E1 E2
≜
E2
Теперь легко определить все обычные логические операторы:
not p
≜
if p then false else true
p and q
≜
if p then q else false
p or q
≜
if p then true else q
5.2.2
Пары и кортежи
Упорядоченную пару можно представить следующим образом:
(E1, E2) ≜λf.f E1 E2
Скобки здесь необязательны, но мы будем использовать их для того,
чтобы вызывать аналогии с соответствующей записью для обозначения
16

векторов или комплексных чисел в математике. В действительности за-
пятую можно рассматривать просто как некоторый инфиксный оператор,
как + или −. С учетом данного определения, функции для извлечения
компонентов пары можно записать так:
fst p
≜
p true
snd p
≜
p false
Нетрудно убедиться, что эти определения удовлетворяют требовани-
ям:
fst(p, q)
=
(p, q) true =
=
(λf.f p q) true =
=
true p q =
=
(λx y.x) p q =
=
p
и
snd(p, q)
=
(p, q) false =
=
(λf.f p q) false =
=
false p q =
=
(λx y.y) p q =
=
q
Тройки, четверки и вообще, произвольные n-кортежи можно постро-
ить с помощью пар:
(E1, E2, . . . , En) = (E1, (E2, . . . , En)).
Следует только ввести соглашения, что оператор «запятая» ассоциативен
вправо.
Функции fst и snd можно расширить на случай n-кортежей. Опре-
делим функцию селектора, которая получает i-й компонент кортежа p.
Будем записывать ее как (p)i. Тогда (p)1 = fst p и (p)i = fst(sndi−1 p).
5.2.3
Натуральные числа
Натуральное число n будем представлять в следующем виде:
n ≜λf x.f n x
17

т.е. 0 = λf x.x, 1 = λf x.f x, 2 = λf x.f (f x) и т.д. Таким обра-
зом, числа вводятся индуктивным образом, и употребление символа n
в определении сделано просто для удобства. Введенное представление
называется «цифрами по Черчу». Это не очень эффективное представ-
ление; можно было бы использовать, например, двоичное представление
чисел в виде кортежей, состоящих из значений true и false. Однако сей-
час нас интересует понятие вычислимости «в принципе», и цифры по
Черчу обладают рядом удобных формальных свойств.
Например, легко можно ввести операцию следования (увеличения
на 1):
SUC ≜λn f x.n f (f x)
Действительно:
SUC n
=
(λn f x.n f (f x)) (λf x.f n x) =
=
λf x.(λf x.f n x) f (f x) =
=
λf x.(λx.f n x) (f x) =
=
λf x.f n (f x) =
=
λf x.f n+1 x =
=
n + 1
Также легко ввести функцию проверки числа на 0:
ISZERO n ≜n (λx.false) true
поскольку
ISZERO 0 = (λf x.x) (λx.false)true = true
и
ISZERO n + 1
=
(λf x.f n x)(λx.false)true =
=
(λx.false)n+1 true =
=
(λx.false)((λx.false)n true) =
=
false
Следующие определения вводят сложение и умножение:
m + n
≜
λf x.m f (n f x)
m ∗n
≜
λf x.m (n f) x
18

Действительно:
m + n
=
λf x.m f (n f x) =
=
λf x.(λf x.f m x) f (n f x) =
=
λf x.(λx.f m x) (n f x) =
=
λf x.f m (n f x) =
=
λf x.f m ((λf x.f n x) f x) =
=
λf x.f m ((λx.f n x) x) =
=
λf x.f m (f n x) =
=
λf x.f m+n x
и
m ∗n
=
λf x.m (n f) x =
=
λf x.(λf x.f m x) (n f) x =
=
λf x.(λx.(n f)m x) x =
=
λf x.(n f)m x =
=
λf x.((λf x.f n x) f)m x =
=
λf x.(λx.f n x)m x =
=
λf x.(f n)m x =
=
λf x.f mn x
Эти операции на натуральных числах довольно легко представляют-
ся в лямбда-исчислении, однако выразить функцию «предшествования»
(вычитание 1) оказывается гораздо труднее. Требуется найти лямбда-
выражение PRE, такое, что PRE 0 = 0 и PRE n + 1 = n. Эту задачу
решил Клини в 1935 году. Идея заключается в том, чтобы отбросить од-
но применение f в выражении λf x.f n x. Определим функцию PREFN,
удовлетворяющую следующим условиям:
PREFN f (true, x) = (false, x)
и
PREFN f (false, x) = (false, f x)
Тогда можно заметить, что (PREFN f)n+1 (true, x) = (false, f n x) и
функцию предшествования можно определить без особых трудностей.
Функцию PREFN можно определить, например, так:
PREFN ≜λf p.(false, if fst p then snd p else f(snd p))
Тогда:
PRE n ≜λf x. snd(n (PREFN f) (true, x))
19

5.3
Рекурсивные функции
Возможность определять рекурсивные функции — характерная осо-
бенность функционального программирования. На первый взгляд, ка-
жется, что в лямбда-исчислении нет способа сделать это. Действительно,
важной частью рекурсивного определения является именование функ-
ции, иначе как мы обратимся к ней в правой части определения? Однако
в действительности мы сможем обойтись без этого, хотя, как и в случае
с функцией предшествования, этот факт далеко не очевиден.
Ключевым моментом является существование так называемых ком-
бинаторов неподвижной точки. Замкнутый лямбда-терм Y называет-
ся комбинатором неподвижной точки, если для любого лямбда-терма f
выполняется: f(Y f) = Y f. Таким образом, комбинатор неподвижной
точки по заданному терму f возвращает неподвижную точку f, т.е. терм
x, такой что f(x) = x. Первый такой комбинатор, найденный Карри,
обычно обозначается как Y . Часто его называют «парадоксальным ком-
бинатором». Он определяется следующим образом:
Y ≜λf.(λx.f (x x)) (λx.f (x x))
Нетрудно убедиться, что данное выражение действительно определяет
комбинатор неподвижной точки:
Y f
=
(λf.(λx.f (x x)) (λx.f (x x))) f =
=
(λx.f (x x)) (λx.f (x x)) =
=
f((λx.f (x x)) (λx.f (x x))) =
=
f(Y f)
Хотя с математической точки зрения наши рассуждения верны, с вы-
числительной стороны такое определение вызывает трудности, поскольку
вышеприведенное рассуждение использует лямбда-равенство, а не редук-
ции (в последнем переходе мы использовали обратную β-конверсию).
По этой причине можно предпочесть следующее определение комбина-
тора неподвижной точки, принадлежащее Тьюрингу:
T ≜(λx y.y (x x y)) (λx y.y (x x y))
(Доказательство того, что T f →f(T f) оставляем в качестве упражне-
ния.)
Несмотря на сделанное выше замечание, будем обозначать комбина-
тор неподвижной точки по-прежнему как Y . Покажем, как он может
помочь в определении рекурсивных функций. Рассмотрим в качестве
20

примера функцию факториала. Мы хотим определить функцию fact, та-
кую, что:
fact(n) = if ISZERO n then 1 else n ∗fact(PRE n)
Сперва преобразуем это к следующему эквивалентному виду:
fact = λn.if ISZERO n then 1 else n ∗fact(PRE n)
Это выражение, в свою очередь, эквивалентно
fact = (λf n.if ISZERO n then 1 else n ∗f(PRE n)) fact
Отсюда можно заключить, что fact является неподвижной точкой неко-
торой функции F следующего вида:
F = λf n.if ISZERO n then 1 else n ∗f(PRE n)
Таким образом, fact = Y F.
Похожая техника используется для определения взаимно рекурсив-
ных функций, т.е. набора функций, определения которых взаимно зави-
сят друг от друга. Определение вида
f1
=
F1 f1 . . . fn
f2
=
F2 f1 . . . fn
. . .
=
. . .
fn
=
Fn f1 . . . fn
можно преобразовать, используя кортежи, к одному равенству:
(f1, f2, . . . , fn) = (F1 f1 . . . fn, F2 f1 . . . fn, . . . , Fn f1 . . . fn)
Теперь, если мы запишем t = (f1, f2, . . . , fn), то каждая из функций fi
в правой части равенства может быть представлена через соответству-
ющий селектор: fi = (t)i. Таким образом, уравнение можно записать в
каноническом виде t = F t, что дает решение t = Y F. Отсюда, снова с
помощью селекторов, можно получить отдельные компоненты кортежа t.
5.4
Именованные выражения
Ранее мы представляли возможность записывать безымянные функ-
ции как одно из преимуществ лямбда-исчисления. Было показано, что
рекурсивные функции можно определить, не вводя каких-либо имен. Тем
21

не менее возможность давать имена выражениям часто бывает полез-
на, поскольку позволяет избежать долгих и утомительных повторений.
Простая форма именования может быть введена как еще одна форма
«синтаксического сахара» над чистым лямбда-исчисление:
let x = S in T ≜(λx.T) S
Например:
(let z = 2 + 3 in z + z) = (λz.z + z) (2 + 3) = (2 + 3) + (2 + 3)
Можно связать несколько выражений с переменными в последова-
тельном или параллельном стиле. В первом случае мы просто вкладыва-
ем let-конструкции друг в друга. Во втором мы записываем связывания,
ограничив их символами ‘{’ и ‘}’ и разделяя символом ‘;’:
let {x1 = S1; x2 = S2; . . . ; xn = Sn} in T
Это выражение можно рассматривать как «синтаксический сахар» для:
(λ(x1, . . . , xn).T) (S1, . . . , Sn)
Вместо префиксной формы с let можно ввести постфиксный вариант,
который иногда более читаем:
T where x = S
Например, можно записать ‘y < y2 where y = 1 + x’.
Далее, с помощью let-нотации можно определять функции, введя со-
глашение, что
let f x1 x2 . . . xn = S in T
означает
let f = λx1 x2 . . . xn.S in T
Для определения рекурсивных функций можно ввести соглашение по
использованию комбинатора неподвижной точки, т.е.
let fact n = if ISZERO n then 1 else n ∗fact(PRE n) in S
означает let fact = Y F in S.
22

5.5
На пути к реальному языку программирования
Разработанная нами система «синтаксического сахара» позволяет под-
держивать понимаемый человеком синтаксис для чистого лямбда-исчис-
ления, и с ее помощью можно писать программы на языке, очень на-
поминающем настоящий язык программирования, такой как Haskell или
ML.
Программа представляет собой единственное выражение. Однако, имея
в распоряжении механизм let для связывания подвыражений с имена-
ми, более естественно рассматривать программу как набор определений
вспомогательных функций, за которыми следует само выражение, на-
пример:
let { fact n = if ISZERO n then 1 else n ∗fact(PRE n);
. . .
} in fact 6
(Заметьте, что это уже напоминает реальную программу на языке Haskell,
за тем исключением, что, помимо правил выравнивания, позволяющим
обойтись без символов ‘{’, ‘}’ и ‘;’,в Haskell введено соглашение опускать
конструкцию let в определениях верхнего уровня.)
Эти определения вспомогательных функций можно интерпретировать
как систему уравнений в обычном математическом смысле. Они не зада-
ют нам нам явных указаний, каким именно образом вычислять выраже-
ния. По этой причине функциональное программирование часто объеди-
няют с логическим в класс декларативных методов программирования.
Программа определяет ряд желаемых свойств результата и оставляет
машине найти способ его вычисления.
Тем не менее программа все же должна быть выполнена каким-либо
образом. В действительности выражение-программа вычисляется с по-
мощью «развертывания» всех конструкций до уровня чистого лямбда-
исчисления и последующего применения β-конверсий. Таким образом,
хотя в самой программе нет никакой информации по ее выполнению,
при ее составлении все же подразумевается некоторая стратегия испол-
нения. В некотором смысле понятие декларативности является отраже-
нием только человеческой психологии.
Более того, необходимо ввести некоторое определенное соглашение
по используемым редукционным стратегиям, поскольку известно, что
выбор различных β-редексов может привести к различному поведению
программы в смысле ее завершаемости. Следовательно, нам нужно опре-
делить эту стратегию, чтобы получить реальный язык программирова-
ния. В последующих разделах мы увидим, как различаются по этому
23

критерию различные функциональные языки программирования. Одна-
ко сперва нам нужно ввести понятие типа.
6
Типы
Типы предоставляют возможность различать отдельные виды данных,
такие как булевские значения, натуральные числа и функции. Учет типов
может дать то преимущество, что, например, функция не может быть
применена к аргументам, имеющим «неправильный» тип. Почему у нас
может возникнуть желание ввести типы в лямбда-исчисление и в языки
программирования, основанные на нем? Мотивы этого могут возникнуть
как со стороны логики, так и со стороны программирования.
Изначально лямбда-исчисление задумывалось как способ формализа-
ции всего языка математики. Черч надеялся также включить в лямбда-
исчисление теорию множеств. По заданному множеству S можно опре-
делить его характеристическую функцию χS, такую что:
χS(x) =
(
true,
x ∈S
false,
x /∈S
И наоборот, имея унарный предикат P, можно определить множество
таких x, что P(x) = true. Кажется, естественно определить предикаты
(и, следовательно, множества) в виде произвольных лямбда-выражений.
Однако это приводит к противоречиям.
Рассмотрим знаменитый парадокс Рассела. Определим множество R
как множество тех множеств, которые не содержат сами себя в качестве
элемента:
R = {x|x /∈x}
Тогда мы получаем, что R ∈R ⇔R /∈R, что является, несомненно, про-
тиворечием. В терминах лямбда-исчисления, мы полагаем R = λx.¬(x x)
и обнаруживаем, что R R = ¬(R R). Выражение R R является непо-
движной точкой оператора отрицания.
Парадокс Рассела возникает из-за того, что мы делаем странную да-
же с точки зрения здравого смысла вещь: мы применяем функцию са-
му к себе. Конечно, само по себе применение функции к самой себе
не обязательно приводит к парадоксу: например, функция идентично-
сти λx.x или константная функция λx.y вполне безобидны. Однако, мы,
безусловно, имели бы более ясное представление о функциях, обознача-
емых лямбда-термом, если бы мы точно знали области их определения
и значений и применяли бы их только к аргументам, принадлежащим
24

их областям определения. Таковы были причины, по которым Рассел
изначально предложил ввести понятие типа.
Типы также возникли, вероятно, вначале без всякой связи с приведен-
ными выше рассуждениями, в языках программирования, и поскольку
мы рассматриваем лямбда-исчисление как язык программирования, та-
кая точка зрения не может нас не интересовать. Даже в первых версиях
Фортрана различались целые и вещественные числа. Одной из этого бы-
ла эффективность: зная о типе переменной, можно генерировать более
эффективный код и более эффективно использовать память.
Помимо эффективности, по мере развития программирования, типы
стали цениться за то, что они предоставляют ограниченную форму стати-
ческой проверки программ. Многие ошибки программирования, от про-
стых опечаток до более существенных концептуальных ошибок, влекут
за собой несоответствие типов, и, следовательно, могут быть обнаруже-
ны до запуска программы, на этапе ее компиляции. Более того, типы
часто предоставляют полезную информацию для людей, читающих про-
граммы. Наконец, типы можно использовать для того, чтобы достичь
большей модульности и скрытия данных: они позволяют «искусственно»
отделить некоторые данные от их внутреннего представления.
Вместе с тем некоторые программисты недолюбливают типы. Суще-
ствуют безтиповые языки, как императивные, так и функциональные.
Другие языки (к ним относится и Си) являются слабо типизирован-
ными: компилятор допускает некоторое несоответствие в типах и сам
делает необходимые преобразования. Также существуют языки (напри-
мер, LISP), которые выполняют проверку типов динамически, во время
выполнения программы, а не во время компиляции.
Найти систему типов, которая не позволяет выполнять полезные ста-
тические проверки и в то же время не накладывает на программиста
чересчур жестких ограничений — непростая задача, до конца еще не
решенная. Система типов, использующаяся в таких языках, как Haskell
или ML — важный этап на этом пути, поскольку в ней программисту
предоставляется возможность полиморфизма: одна и та же функция мо-
жет использоваться с различными типами. Это оставляет возможность
статических проверок, предоставляя в то же время некоторые преиму-
щества слабой или динамической типизации. Более того, программист
не обязан указывать никаких типов в Haskell или ML: компьютер может
вывести наиболее общий тип любого выражения и отвергнуть выраже-
ния, не имеющие типа.
25

6.1
Типизированное лямбда-исчисление
Модифицировать лямбда-исчисление так, чтобы ввести в него поня-
тие типа, довольно нетрудно, однако это приводит к важным последстви-
ям. Основная идея заключается в том, чтобы каждый лямбда-терм имел
тип, и терм S можно применить к терму T в комбинации S T, если их
типы правильно соотносятся друг с другом, т.е. S имеет тип функции
σ →τ и T имеет тип σ. Результат, S T, имеет тип τ. Это свойство назы-
вается сильной типизацией. Терм T должен иметь в точности тип σ:
приведение типов не допускается, в отличие от языков типа Си, в кото-
ром некоторая функция, ожидающая аргумент типа double или float,
может принять аргумент типа int и неявно преобразовать его.
Мы будем использовать запись вида T :: σ для утверждения «T имеет
тип σ». Это напоминает использующуюся в математике стандартную за-
пись вида f : σ →τ для функции f из множества σ в множество τ. Типы
можно представлять себе как множества, которым принадлежат соот-
ветствующие объекты, т. е. запись T :: σ можно интерпретировать как
T ∈σ. Однако мы будем рассматривать типизированное лямбда-исчисле-
ние как формальную систему, независящую от подобной интерпретации.
6.1.1
Базовые типы
Прежде всего необходимо точно определить, что такое тип. Мы пред-
полагаем, что у нас имеется некоторый набор базовых типов, таких как
Bool или Integer. Из них можно конструировать составные типы с
помощью конструкторов типов, являющихся, по сути, функциями. Да-
дим следующее индуктивное определение множества TyC типов, осно-
вывающихся на множестве базовых типов C:
σ ∈C
σ ∈TyC
σ ∈TyC, τ ∈TyC
σ →τ ∈TyC
Например, возможными типами могут быть Integer, Bool →Bool,
(Integer →Bool) →Integer →Bool и т. д. Мы предполагаем, что функ-
циональная стрелка →ассоциативна вправо, т. е. σ →τ →ν означает
σ →(τ →ν).
В дальнейшем мы расширим нашу систему типов двумя способа-
ми. Во-первых, мы введем понятие т ´иповых переменных, являющихся
средством для реализации полиморфизма. Во-вторых, мы введем допол-
нительные конструкторы типов, помимо функциональной стрелки.
26

Например, введем конструктор × для типа пары значений. В этом
случае к нашему индуктивному определению необходимо добавить:
σ ∈TyC, τ ∈TyC
σ × τ ∈TyC
Далее, как и в языке Haskell, можно вводить именованные конструкторы
произвольной арности. Мы будем использовать запись Con (α1, . . . , αn)
для применения n-арного конструктора Con к аргументам αi.
Важным свойством типов является то, что σ →τ ̸= σ (В действитель-
ности тип не может совпадать ни с каким своим синтаксически правиль-
ным подвыражением.) Это исключает возможность применения терма к
самому себе.
6.1.2
Типизации по Черчу и Карри
Существуют два основных подхода к определению типизированно-
го лямбда-исчисления. Первый подход, принадлежащий Черчу — явная
типизация. Каждому терму сопоставляется единственный тип. Это озна-
чает, что в процессе конструирования термов, нетипизированные термы,
которые мы использовали ранее, модифицируются с помощью добавле-
ния дополнительной характеристики — типа. Для констант этот тип
задан заранее, но переменные могут иметь любой тип. Правила коррект-
ного формирования термов выглядят тогда следующим образом:
v :: σ
Константа c имеет тип σ
c :: σ
S :: σ →τ, T :: σ
S T :: τ
v :: σ, T :: τ
λv.T :: σ →τ
Однако мы будем использовать для типизации подход Карри, кото-
рый является неявным. Термы могут иметь или не иметь типа, и если
терм имеет тип, то он может быть не единственным. Например, функция
идентичности λx.x может иметь любой тип вида σ →σ. Такой подход
более предпочтителен, поскольку, во-первых, он соответствует использу-
емому в языках типа Haskell и ML понятию полиморфизма, а во-вторых,
позволяет, как и в этих языках, не задавать типы явным образом.
27

В то же самое время, некоторые формальные детали типизации по
Карри несколько сложнее. Мы не определяем понятие типизируемости
само по себе, но по отношению к контексту, т. е. конечному набору
предположений о типах переменных. Мы будем записывать:
? ⊢T :: σ
чтобы обозначить, что «в контексте ? терм T может иметь тип σ». Мы
будем употреблять запись ⊢T :: σ или просто T :: σ, если суждение
о типизации выполняется в пустом контексте. Элементы контекста ?
имеют вид v :: σ, т. е. они представляют собой предположения о типах
переменных, как правило, тех, которые являются компонентами терма.
Будем предполагать, что в ? нет противоречивых предположений.
6.1.3
Формальные правила типизации
Правила типизации вводятся совершенно естественно, следует только
помнить о том, что T :: σ интерпретируется как «T может принадлежать
типу σ».
v :: σ ∈?
? ⊢v :: σ
Константа c имеет тип σ
c :: σ
? ⊢S :: σ →τ, ? ⊢T :: σ
? ⊢S T :: τ
? ∪{v :: σ} ⊢T :: τ
? ⊢λv.T :: σ →τ
Эти правила являются индуктивным определением отношения типизи-
руемости, и терм имеет некоторый тип, если он может быть выведен по
этим правилам. Для примера рассмотрим типизирование функции иден-
тичности λx.x. По правилу для переменных имеем:
{x :: σ} ⊢x :: σ
и отсюда по последнему правилу получаем:
∅⊢λx.x :: σ →σ
Следуя соглашению о пустых контекстах мы пишем просто λx.x :: σ →σ.
Можно показать, что все преобразования лямбда-термов сохраняют
типы, т. е. если некоторый терм T имел тип σ в контексте ?, то после
преобразования его в T ′ он будет иметь тот же самый тип.
28

6.2
Полиморфизм
Система типов по Карри уже дает нам некоторую форму полимор-
физма, в том смысле, что терм может иметь различные типы. Необхо-
димо различать похожие концепции полиморфизма и перегрузки. Оба
этих термина означают, что выражение может иметь несколько типов.
Однако в случае полиморфизма все типы сохраняют некоторое систе-
матическое сходство друг с другом и допустимы все типы, следующие
некоторому образцу. Например, функция идентичности может иметь тип
σ →σ, τ →τ или (σ →σ) →(σ →τ), но все эти типы имеют похожую
структуру. В противоположность этому, при перегрузке функция может
иметь различные типы, не связанные друг с другом структурным сход-
ством. Также возможна ситуация когда функция просто определяется
для некоторого набора типов. Например, функция сложения может иметь
тип int →int →int или float →float →float, но не bool →bool →bool.
6.2.1
let-полиморфизм
К сожалению, наша система типов приводит к некоторым нежелатель-
ным ограничениям на полиморфизм. Например, следующее выражение
совершенно приемлемо:
if (λx.x) true then (λx.x) 1 else 0
Если использовать правила типизации, то можно получить, что это вы-
ражение имеет тип int. Два экземпляра функции идентичности имеют
типы bool →bool и int →int.
Теперь рассмотрим выражение:
let I = λx.x in if I true then I 1 else 0
Согласно нашему определению, это всего лишь другой способ записи
для
(λI.if I true then I 1 else 0) (λx.x)
Однако это выражение не может быть типизировано по нашим прави-
лам. В нем присутствует только один экземпляр функции идентичности,
и он должен иметь единственный тип. Это — серьезный недостаток, по-
скольку мы уже видели, что конструкции с let широко используются в
функциональном программировании.
Один из способов преодолеть это ограничение — добавить еще од-
но правило типизации, в котором let-конструкции рассматривается как
первичная:
? ⊢S :: σ и ? ⊢T[x := S] :: τ
? ⊢let x = S in T :: σ
29

Это правило вводит let-полиморфизм. В нем выражается тот факт,
что при типизации мы рассматриваем связывания по let так, как будто у
нас записаны различные экземпляры этих именованных выражений. До-
полнительная гипотеза ? ⊢S :: σ нужна для того, чтобы гарантировать,
что терм S типизируем, иначе были бы типизируемы такие выражения
как:
let x = λf.f f in 0
6.2.2
Наиболее общие типы
Как уже было сказано, некоторые выражения не имеют типа, напри-
мер, λf.f f или λf.(f true, f 1). Типизируемые выражения обычно имеют
много типов, хотя некоторые, например, true, имеют только один. Также
мы говорили о параметрическом полиморфизме, т. е. все типы выра-
жения могут иметь структурное сходство. В действительности истинно
более сильное утверждение: для каждого типизируемого выражения су-
ществует наиболее общий тип или основной тип, и все возможные
типы выражения являются экземплярами этого наиболее общего типа.
Прежде чем сделать это утверждение строгим, необходимо ввести неко-
торую терминологию.
Прежде всего, расширим нашу нотацию понятием т ´иповых перемен-
ных. Это означает, что типы могут быть сконструированы с помощью
применения конструкторов типа либо к типовым константам, либо к пе-
ременным. Будем использовать буквы α и β для типовых переменных, а σ
и τ — для произвольных типов. Теперь можно определить понятие заме-
ны типовой переменной в некотором типе на другой тип. Это в точности
аналогично подстановке на уровне термов, и мы будем использовать ту
же нотацию. Например:
(σ →bool)[σ := (σ →τ)] = (σ →τ) →bool
Формальное определение гораздо проще, чем для термов, поскольку нам
нет нужды беспокоится о связываниях переменных. В то же время удоб-
но расширить его параллельными подстановками:
αi[α1 := τ1, . . . , αk := τk]
=
τi
β[α1 := τ1, . . . , αk := τk]
=
β, если αi ̸= β для 1 ≤i ≤k
Con (σ1, . . . , σn)[θ]
=
Con (σ1[θ], . . . , σn[θ])
Для простоты, мы рассматриваем типовые константы как 0-арные
конструкторы, т. е. считаем, что int задается как int (). Имея опреде-
ление подстановки, мы можем определить, что тип σ является более
30

общим, чем тип σ′ и записывать этот факт как σ ⪯σ′. Это отношение
выполняется тогда и только тогда, когда существует набор подстановок
θ такой, что σ′ = σθ. Например:
α
⪯
α
α →α
⪯
β →β
α →bool
⪯
(β →β) →bool
β →α
⪯
α →β
α →α
̸⪯
(β →β) →β
Теперь можно сформулировать теорему:
Теорема 4. Каждый типизируемый терм имеет некоторый основной
тип, т. е. если T :: τ, то существует некоторый σ, такой что T :: σ
и для любого σ′, если T :: σ′, то σ ⪯σ′.
Основной тип является единственным с точностью до переименова-
ний типовых переменных. Мы не будем приводить доказательство теоре-
мы: оно не сложно, но довольно длинно. Важно понять, что доказатель-
ство конструктивно: оно дает конкретную процедуру для поиска основ-
ного типа. Эта процедура известна как алгоритм Хиндли–Милнера. Все
реализации языков программирования Haskell, ML и других, включают
в себя вариант этого алгоритма, так что выражения в них могут быть
сопоставлены их основному типу либо отвергнуты как нетипизируемые.
6.3
Сильная нормализация
Вспомним наш пример терма без нормальной формы:
(λx.y) ((λx.x x x) (λx.x x x))
→
(λx.y) ((λx.x x x) (λx.x x x) (λx.x x x))
→
(λx.y) ((λx.x x x) (λx.x x x) (λx.x x x) (λx.x x x))
→
. . .
В типизированном лямбда-исчислении такого не может случиться, по-
скольку существует следующая теорема о сильной нормализации:
Теорема 5. Каждый типизируемый терм имеет нормальную форму
и каждая возможная последовательность редукций, начинающаяся с
типизируемого терма, завершается.
31

На первый взгляд, это хорошо — функциональная программа, соблю-
дающая дисциплину типизации может быть вычислена любым образом,
и она всегда завершится в единственной нормальной форме (единствен-
ность следует из теоремы Черча–Россера, которая выполняется и для
типизированного лямбда-исчисления). Однако возможность писать неза-
вершающиеся программы существенна для полноты по Тьюрингу, так
что мы больше не можем определять все вычислимые функции и даже
все полные функции.
Поскольку все определяемые функции полны, мы не можем делать
произвольные рекурсивные определения. Действительно, обычный ком-
бинатор неподвижной точки должен быть нетипизируем; Y ≜λf.(λx.f (x x)) (λx.f (x x))
не является правильно типизируемым выражением, поскольку он приме-
няет x сам к себе и x связан. Чтобы вернуть полноту по Тьюрингу,
мы просто добавляем способ определения произвольных рекурсивных
функций, которые являются правильно типизированными. Мы вводим
полиморфный оператор рекурсии для всех типов вида:
Rec :: ((σ →τ) →(σ →τ)) →σ →τ
Также вводится дополнительное правило редукции: для любого F ::
(σ →τ) →(σ →τ) имеем
Rec F →F (Rec F)
Теперь будем считать, что рекурсивные определения функций интерпре-
тируются с использованием этих операторов рекурсии.
7
Отложенные вычисления
Мы уже обсуждали, что с теоретической точки зрения, нормальный
порядок редукции выражений наиболее предпочтителен, поскольку если
любая стратегия завершается, завершится и она. Такая стратегия из-
вестна и в традиционных языках программирования (в Алголе 60 ее
называют вызовом по имени, по таким же правилам «вызываются» па-
раметризованные макроопределения в языке Си.) Однако с практической
точки зрения такая стратегия имеет существенные недостатки. Для при-
мера рассмотрим выражение
(λx.x + x + x) (10 + 5)
Нормальная редукция сводит это выражение к следующему:
(10 + 5) + (10 + 5) + (10 + 5)
32

Таким образом, необходимо трижды вычислять значение одного и того
же выражения. На практике это, разумеется, недопустимо. Существуют
два основных решения этой проблемы и они разделяют мир функцио-
нального программирования на два лагеря.
В первом подходе отказываются от нормальной стратегии и вычисля-
ют аргументы функций до того, как передать их значения в функцию.
Это — обычная практика в таких языках, как Си, Паскаль и т. д. Та-
кой подход называют передачей по значению. При этом вычисление
некоторых выражений, завершающееся при нормальной стратегии, мо-
жет привести к бесконечной последовательности редукций. Однако на
практике этих случаев можно легко избежать. Обычно такая стратегия
позволяет получать довольно эффективный машинный код. Также она
предпочтительна в случае гибридных языков, т. е. функциональных язы-
ков, содержащих императивные конструкции (присваивания, циклы и т.
п.) Языки семейства ML придерживаются такого порядка вычислений.
При другом подходе, использующемся в Haskell и некоторых дру-
гих языках, нормальная стратегия редукций сохраняется. Однако при
этом различные возникающие подвыражения разделяются и никогда не
вычисляются более одного раза. Во внутреннем представлении выраже-
ния становятся не деревьями, а направленными ациклическими графами.
Такая дисциплина вызова называется ленивой или вызовом по необхо-
димости, поскольку выражения вычисляются только тогда, когда их
значения действительно необходимы для работы программы.
Например, в языке Haskell можно сделать следующее определение:
bottom = bottom
Согласно этому определению, вычисление выражения bottom никогда
не завершиться. Однако рассмотрим такую функцию:
const1 x = 1
Тогда значение выражения const1 bottom равно 1. Поскольку функ-
ция const1 не нуждается в значении своего аргумента, он не вычисля-
ется. Аналогичная ситуация и со следующим выражением:
const1 (1/0)
Значение этого выражения также равно 1. Деления на 0 не происходит,
поскольку аргумент функции никогда не вычисляется.
Преимуществом такого подхода является то, что он позволяет доби-
ваться большей выразительности при записи функций. Платой за это
является сложность реализации и некоторое снижение эффективности.
33

Действительно, вместо того, чтобы непосредственно вычислить выраже-
ние, приходится сохранять информацию о том, как его вычислять. Разу-
меется, если значение этого выражения не понадобилось в дальнейших
вычислениях, мы получаем некоторую экономию, однако в противном
случае непосредственное вычисление кажется предпочтительным. Опти-
мизирующие компиляторы языка Haskell во многих случаях могут сами
выявить места программы, в которых можно обойтись без отложенных
вычислений.
Конструкторы данных в Haskell также являются функциями (един-
ственное отличие от «настоящих» функций заключается в том, что их
можно использовать в шаблонах при сопоставлении с образцом.) В со-
четании с «ленивым» вызовом это позволяет определять бесконечные
структуры данных. Например, следующее определение задает бесконеч-
ный список единиц:
ones = 1 : ones
Более интересным примером служит бесконечный список целых чисел,
начиная с числа n:
numsFrom n = n : numsFrom (n+1)
Термин «бесконечный» здесь — не преувеличение. Определения, по-
добные приведенным, действительно задают потенциально бесконечные
структуры данных. С ними можно работать так же, как и с конечны-
ми, например, получить (бесконечный) список квадратов натуральных
чисел:
squares = map (^2) (numsFrom 1)
Разумеется, в реальности мы работаем только с конечной частью на-
шего списка, однако использование отложенных вычислений позволяет
отделить генерацию бесконечной структуры данных от выделения ее ко-
нечной части. Для наших примеров конечную часть списка можно выде-
лить, например, с помощью функции take, которая по заданному числу
n и списку возвращает первые n элементов этого списка. Так, значение
выражения
take 5 (numsFrom 1)
равно [1,2,3,4,5], а результатом вычисления
take 5 squares
34

будет [1,4,9,16,25]
Представленный пример дает образец типичной структуры програм-
мы, использующейся в Haskell. Программа представляется в виде кон-
струкции g (f input), где g и f — некоторые функции. Они выпол-
няются вместе строго синхронно. f запускается только тогда, когда g
пытается прочитать некоторый ввод, и выполняется ровно столько, что-
бы предоставить данные, который пытается читать g. После этого f при-
останавливается, и выполняется g, до тех пор, пока вновь не попытается
прочитать следующую группу входных данных. Если g заканчивается,
не прочитав весь вывод f, то f прерывается. f может даже быть не
завершаемой программой, создающей бесконечный вывод, так как она
будет остановлена, как только завершится g. Это позволяет отделить
условия завершения от тела цикла, что является мощным средство мо-
дуляризации.
Этот метод называется "ленивыми вычислениями"так как f выпол-
няется настолько редко, насколько это возможно. Он позволяет осу-
ществить модуляризацию программы как генератора, который создает
большое количество возможных ответов, и селектора, который выбира-
ет подходящие. Некоторые другие системы позволяют программам вы-
полнятся вместе подобным способом, но только функциональные язы-
ки использует ленивые вычисления однородно при каждом обращении
к функции, позволяя модуляризовать таким образом любую часть про-
граммы. Ленивые вычисления, возможно, наиболее мощный инструмент
для модуляризации в наборе функционального программиста.
Мы проиллюстрируем мощь ленивых вычислений, программируя неко-
торые численные алгоритмы. Прежде всего, рассмотрим алгоритм Нью-
тона–Рафсона для вычисления квадратного корня. Этот алгоритм вы-
числяет квадратный корень числа z, начиная с начального приближения
a0. Он уточняет это значение на каждом последующем шаге, используя
правило:
an+1 = (an + z/an)/2
Если приближения сходятся к некоторому пределу a, то a = (a +
z/a)/2 , то есть a · a = z или a = √z.
Фактически сведение к пределу проходит быстро. Программа прово-
дит проверку на точность (eps) и останавливается, когда два последо-
вательных приближения отличаются меньше чем на eps. При импера-
тивном подходе алгоритм обычно программируется следующим образом:
x = a0;
do{
y = x;
35

x = (x + z/x) / 2;
} while (abs(x-y) < eps)
// теперь x = квадратному корню из z
Эта программа неделима на обычных языках. Мы выразим её в бо-
лее модульной форме, используя ленивые вычисления, и затем покажем
некоторые другие применения полученным частям.
Так как алгоритм Ньютона–Рафсона вычисляет последовательность
приближений, естественно представить это в программе явно списком
приближений. Каждое приближение получено из предыдущего функцией
next z x = (x + z/x) / 2
То есть (next z) — функция, отображающая каждое приближение
в следующее. Обозначим эту функцию f, тогда последовательность при-
ближений будет: [a0, f a0, f(f a0), f(f(f a0)),...] . Мы мо-
жем определить функцию, вычисляющую такую последовательность:
iterate f x = x : iterate f (f x)
Тогда список приближений можно вычислить так:
iterate (next z) a0
Здесь iterate — пример функции с «бесконечным» выводом — но
это не проблема, потому что фактически будет вычислено не больше при-
ближений, чем требуется остальным частям программы. Бесконечность
- только потенциальная: это означает, что любое число приближений
можно вычислить, если потребуется, iterate сама по себе не содер-
жит никаких ограничений.
Остаток программы — функция within, которая берет допуск и спи-
сок приближений и, просматривая список, ищет два последовательных
приближения, отличающихся не более чем на данный допуск.
within eps (a:b:rest) =
if abs(a-b) <= eps
then b
else within eps (b : rest)
Собирая части, получаем:
sqrt a0 eps z = within eps (iterate (next z) a0)
36

Теперь, когда мы имеем части программы поиска квадратного корня,
мы можем попробовать объединить их различными способами. Одна из
модификаций, которую мы могли бы пожелать, заключается в исполь-
зовании относительной погрешности вместо абсолютной. Она больше
подходит как для очень малых чисел (когда различие между последо-
вательными приближениями маленькое), так и для очень больших (при
округлении ошибки могут быть намного большими, чем допуск). Необ-
ходимо определить только замену для within:
relative eps (a:b:rest) =
if abs(a-b) <= eps*abs(b)
then b
else relative eps (b:rest)
Теперь можно определить новую версию sqrt
relativesqrt a0 eps z = relative eps (iterate (next z) a0)
Нет необходимости переписывать часть, которая генерирует приближе-
ния.
Мы повторно использовали iterate при генерации последователь-
ности приближений в вычислениях квадратного корня. Конечно же, мож-
но многократно использовать within и relative в любых численных
алгоритмах, которые генерирует последовательность приближений.
Например, запишем алгоритм определения корня функции f методом
касательных. Если начальное приближение равно x0, то следующее при-
ближение вычисляется по формуле x1 = x−f(x)/f ′(x). На языке Haskell
этот алгоритм можно записать следующим образом:
root f diff x0 eps = within eps (iterate (next f diff) x0)
where next f diff x = x - f x / diff x
Для работы этого алгоритма необходимо указать две функции: f, вы-
числяющая значение функции f и diff, вычисляющую значение f ′.
Например, чтобы найти положительный корень функции f(x) = x2 −1 с
начальным приближением 2, запишем следующее выражение:
root f diff 2 0.001 where f x = x^2 - 1
diff x = 2*x
Результатом вычисления этого выражения будет число 1.00000004646115.
В качестве более сложного примера приведем вычисление корня уравне-
ния cos x = x:
root f diff 2 0.001 where f x = cos x - x
diff x = -sin x - 1
Результатом будет число 0.739085133219815.
37

8
Классы типов
Классы типов предоставляют возможность контроля над перегрузкой
типов. Класс типов представляет собой некоторое множество типов язы-
ка, обладающих общими свойствами.
Рассмотрим простой пример: равенство. Существует много типов, для
которых определено отношение равенства, однако для других типов оно
не определено. Например, определение равенства двух функций невоз-
можно с вычислительной точки зрения, однако было бы неплохо прове-
рять на равенство два списка. Рассмотрим определение функции elem,
проверяющей, что элемент входит в список:
x ‘elem‘ [] = False
x ‘elem‘ (y:ys) = x == y || (x ‘elem‘ ys)
Каков тип этой функции. Интуитивно, он должен иметь вид a -> [a] -> Bool.
Однако это подразумевает, что оператор == имеет тип a -> a -> Bool,
хотя мы говорили, что он определен не для всех типов. Более того, даже
если бы он был определен для всех типов, сравнение двух списков силь-
но отличается от сравнения двух чисел. В этом смысле, мы ожидаем,
что оператор == будет перегружен, чтобы выполнять эти (различные)
задачи.
Классы типов решают обе эти проблемы. Они позволяют определять,
какие типы являются экземплярами каких классов, и предоставлять
определения ассоциированных с классом операций, перегруженных для
каждого типа. Например, определим класс, содержащий оператор равен-
ства:
class Eq a where
(==) :: a -> a -> Bool
Здесь Eq — имя определяемого класса, а == — единственная операция,
определенная в классе. Это определение можно прочесть следующим
образом: «тип a является экземпляром класса Eq, если для него суще-
ствует перегруженный оператор ==».
Ограничение, гласящее, что тип a должен принадлежать классу Eq
записывается как Eq a. Таким образом, Eq a выражает ограничение на
тип и называется контекстом. Контексты располагаются перед описа-
ниями типов:
(==) :: (Eq a) => a -> a -> Bool
38

Это означает: «для каждого типа a, принадлежащего классу Eq, опера-
тор == имеет тип a -> a -> Bool». Для функции elem ограничения
запишутся аналогично:
elem :: (Eq a) => a -> [a] -> Bool
Эта запись выражает тот факт, что функция elem определена не для
всех типов, а только для тех, для которых определен оператор равенства.
Как указать, какие типы принадлежат классу Eq и определить функ-
ции сравнения для этих типов? Это делается с помощью определения
принадлежности:
instance Eq Integer where
x == y = x ‘integerEq‘ y
Определение оператора == называется методом. Функция integerEq
сравнивает на равенство два целых числа. В общем случае в правой ча-
сти определения допустимо любое выражение, как и при обычном опре-
делении функции.
При определении принадлежности также можно использовать кон-
текст. Пусть у нас определен рекурсивный тип дерева:
data Tree a = Leaf a | Branch (Tree a) (Tree a)
Тогда можно определить оператор поэлементного сравнения деревьев:
instance (Eq a) => Eq (Tree a) where
Leaf a == Leaf b
=
a == b
(Branch l1 r1) == (Branch l2 r2) = (l1 == l2) && (r1 == r2)
_ = _ = False
В стандартных библиотеках языка определено много классов типов.
В действительности класс Eq несколько больше:
class Eq a where
(==), (/=) :: a -> a -> Bool
x /= y = not (x == y)
В классе определены две операции, для равенства и для неравенства.
Также здесь демонстрируется использование методов по умолчанию, в
данном случае для операции неравенства. Если метод для какого-либо
экземпляра класса пропущен в определении принадлежности, использу-
ется метод, определенный в классе, если он существует.
Haskell также поддерживает нотацию расширения класса. Например,
мы определяем класс Ord, который наследует все операции класса Eq, и
кроме того, определяет новые операторы сравнения и функции минимума
и максимума:
39

class (Eq a) => Ord a where
(<), (<=), (>=), (>) :: a -> a -> Bool
max, min :: a -> a -> a
Будем говорить, что Eq является суперклассом класса Ord (соответ-
ственно, Ord является подклассом Eq).
9
Монады
Понятие монад является одним из важнейших в языке Haskell. По-
нимание этой концепции начнем с ряда примеров.
Одной из простейших монад является тип Maybe. Напомним его
определение:
data Maybe a = Nothing | Just a
Он используется для возврата результата из функций в случае, если
этого результата может и не быть. Например, функция f с сигнатурой
f :: a -> Maybe b
принимает значение типа a и возвращает результат типа b (обернутый
в конструктор Just), либо может не вычислить значения и тогда, как
сигнал об ошибке, вернет значение Nothing.
Типичным примером такого рода функций служат функции для осу-
ществления запроса к базе данных. В случае, если данные, удовлетворя-
ющие критериям запроса, существуют, их следует вернуть; в противном
случае возвращается Nothing.
Рассмотрим базу данных, содержащую информацию об адресах лю-
дей. Она устанавливает соответствие между полным именем человека
и его адресом. Для простоты предположим, что имя и адрес задаются
строками. Тогда базу данных можно описать следующим образом:
type AddressDB = [(String,String)]
Таким образом, база данных представляет собой список пар, первым
компонентом которых будет имя, а вторым — адрес. Тогда функция
getAddress, по заданному имени возвращающая адрес, определяется
так:
getAddress :: AddressDB -> String -> Maybe String
getAddress [] _ = Nothing
getAddress ((name,address):rest) n | n == name = Just address
| otherwise = getAddress rest n
40

Для имен, присутствующих в базе, функция возвращает соответствую-
щий адрес. Если такого имени в базе нет, возвращается Nothing.
Пока все выглядит безобидно; проблемы начинаются, когда необхо-
димо осуществлять последовательность запросов. Предположим, у нас
есть еще одна база данных, содержащая соответствие между адресами
и номерами телефонов:
type PhoneDB = [(String,Integer)]
Далее, пусть имеется функция getPhone, по адресу возвращающая те-
лефон, реализованная также с помощью типа Maybe. Реализация этой
функции полностью аналогична функции getAddress. Как теперь опре-
делить функцию, возвращающую телефон по имени человека?
Каков будет тип возвращаемого значения этой функции? Очевидно,
что у человека может не оказаться телефона, следовательно, функция
должна возвращать значение типа Maybe Integer. Далее, значение
Nothing эта функция может вернуть в следующих случаях:
1. Указанное имя не содержится в базе адресов.
2. Адрес, соответствующий указанному имени, существует, однако он
не содержится в базе телефонов.
Исходя из этих соображений, функцию getPhoneByName можно
определить так:
getPhoneByName :: AddressDB -> PhoneDB -> String -> Integer
getPhoneByName a p n = case (getAddress a n) of
Nothing -> Nothing
Just address -> case (getPhone p address) of
Nothing -> Nothing
Just phone -> Just phone
Разумеется, такой стиль программирования не слишком изящен, кро-
ме того, он провоцирует ошибки. В случае, когда уровень вложенности
запросов возрастает, растет и объем повторяющегося кода. Как быть?
Мудрый программист, всегда стремящийся к повторному использованию
кода, определит вспомогательную функцию, которая отражает исполь-
зующийся в функции getPhoneByName шаблон связывания функций,
возвращающих значение типа Maybe. Назовем эту функцию thenMB (от
англ. then maybe — тогда, возможно):
thenMB :: Maybe a -> (a -> Maybe b) -> Maybe b
thenMB mB f = case mB of
41

Nothing -> Nothing
Just a
-> f a
Рассмотрим эту функцию подробнее. Она принимает два аргумен-
та: значение типа Maybe a и функцию, отображающую значение типа
a в значение типа Maybe b. Если первый аргумент содержит значение
Nothing, второй аргумент игнорируется. Если же первый аргумент со-
держит реальное значение, обернутое в конструктор Just, оно извлека-
ется из него и передается в функцию, являющуюся вторым аргументом.
Вспоминая, что в языке Haskell лямбда-абстракция записывается в виде
\x -> expr, функцию getPhoneByName можно записать так:
getPhoneByName a p n =
(getAddress a n ‘thenMB‘
(\address -> getPhone p address)) ‘thenMB‘ (\phone -> Just ph
Или, опуская скобки и записывая с более наглядным расположением
кода:
getPhoneByName a p n = getAddress a n
‘thenMB‘ \address ->
getPhone p address ‘thenMB‘ \phone
->
Just phone
Эту запись следует читать так, будто результат левого аргумента опера-
тора ‘thenMB‘ «присваивается» имени переменной из лямбда-абстрак-
ции правого аргумента.
Чего мы добились? Мы определили функцию thenMB, комбиниру-
ющую вычисления, которые могут либо вернуть результат, либо отка-
заться его вычислять. Сама функция thenMB не зависит от того, какие
именно вычисления она комбинирует, лишь бы они удовлетворяли ее
сигнатуре. Ее можно использовать не только для нашего примера, но и
для любых других аналогичных задач. Она определяет некоторое пра-
вило комбинирования вычислений в цепочку, заключающееся в том, что
если одно из вычислений не выполнилось, не выполняется и вся цепочка.
Усовершенствуем наш пример. Мы перечисляли случаи, в которых
функция getPhoneByName может не найти телефон. Однако в любом
случае она вернет значение Nothing. В реальности нас может интересо-
вать, почему именно она не нашла телефон. Пусть функции getPhone,
getAddress и getPhoneByName возвращают значение типа Value,
который определим следующим образом:
data Value a = Value a | Error String
42

Значение типа Value a представляет собой либо значение типа a, обер-
нутое в конструктор Value, либо строковое сообщение об ошибке, со-
держащееся в конструкторе Error. Функцию getAddress определим
тогда так:
getAddress :: AddressDB -> String -> Value String
getAddress [] _ = Error "no address"
getAddress ((name,address):rest) n | n == name = Value address
| otherwise = getAddress rest n
В случае ошибки getAddress вернет значение Error "no address".
Аналогично можно определить и функцию getPhone, которая в случае
ошибки вернет значение Error "no phone". Тогда функцию getPhoneByName
можно определить следующим образом:
getPhoneByName :: AddressDB -> PhoneDB -> String -> Value Integer
getPhoneByName a p n = case (getAddress a n) of
Error s -> Error s
Value address -> case (getPhone p address) o
Error s -> Error s
Value phone -> Value phon
Здесь мы видим аналогичную проблему, что и с предыдущим опре-
делением. Для ее решения воспользуемся тем же примем: определим
вспомогательную функцию:
thenV :: Value a -> (a -> Value b) -> Value b
thenV mV f = case mV of
Error s -> Error s
Value v -> f v
С использованием этой функции можно упростить наше определение:
getPhoneByName a p n = getAddress a n
‘thenV‘ \address ->
getPhone p address ‘thenV‘ \phone ->
Value phone
Нельзя не отметить некоторое сходство в функциях thenMB и thenV,
а также в определениях функции getPhoneByName. Забегая вперед,
скажем, что тип Value также представляет собой пример монады.
Наконец, сделаем другое обобщение нашей исходной задачи. До сих
пор мы предполагали, что записи в наших базах данных уникальны,
т. е. каждому человеку соответствует только один адрес, а каждому
адресу только один телефон. Предположим теперь, что это не так, т.
43

е. одному человеку может соответствовать несколько адресов, а одному
адресу — несколько телефонов. Тогда функции getPhone, getAddress
и getPhoneByName должны возвращать списки, и их сигнатуры можно
записать следующим образом:
getAddress
:: AddressDB -> String -> [String]
getPhone
:: PhoneDB -> String -> [Integer]
getPhoneByName :: AddressDB -> PhoneDB -> String -> [Integer]
Предположим, что у нас уже определены функции getPhone и getAddress.
В случае неудачи они возвращают пустые списки, в случае успешного
поиска — списки, состоящие из произвольного количества элементов.
Как, используя эти функции, определить функцию getPhoneByName?
Для каждого адреса, возвращенного функцией getAddress, она долж-
на вызвать функцию getPhone; результаты всех вызовов этой функции
необходимо объединить в один список. Определение, учитывающее эти
особенности:
getPhoneByName a p n =
case (getAddress a n) of
[] -> []
(address:rest) -> getPhone p addresses ++ getPhones p rest
where getPhones _ [] = []
getPhones p (x:xs) = getPhone p x ++ getPhones p xs
Здесь также можно определить вспомогательную функцию:
thenL :: [a] -> (a -> [b]) -> [b]
thenL mL f = case mL of
[] -> []
(x:xs) -> f x ++ getRest xs f
where getRest [] _ = []
getRest (x:xs) f = f x ++ getRest xs f
С использованием комбинатора определение примет вид:
getPhoneByName a p n = getAddress a n
‘thenL‘ \address ->
getPhone p address ‘thenL‘ \phone ->
[phone]
Можно догадаться, что список также является монадой.
Итак, что же такое монада? Монада — это некоторый тип данных,
подразумевающий определенную стратегию комбинирования вычислений
44

значения этого типа. Так, монада Maybe подразумевает такое комбини-
рование вычислений, что «не сработавшее» вычисление заставляет «не
срабатывать» и всю цепочку вычислений. Монада Value подразумевает
при этом, что цепочка вычислений должна вернуть сообщение об ошиб-
ке от «не сработавшего» вычисления. Монада «список» отображает кон-
цепцию вычислений, которые могут вернуть неоднозначный результат, и
цепочка вычислений должна учитывать все возможные результаты.
С другой стороны, монаду можно рассматривать как контейнерный
тип, т. е. как тип, значения которого содержат в себе некоторое количе-
ство элементов другого типа. Особенно ярко это проявляется на примере
списков, однако нетрудно заметить, что типы Maybe и Value также яв-
ляются контейнерными и могут содержать ноль или одно значение типа,
являющегося их параметром.
В стандартной библиотеке языка Haskell определен класс типов, яв-
ляющихся монадами. Определение этого класса приведено ниже:
class Monad m where
return :: a -> m a
(>>=)
:: m a -> (a -> m b) -> m b
(>>)
:: m a -> m b -> m b
fail
:: String -> m a
p >> q
= p >>= \ _ -> q
fail s
= error s
Данное определение говорит о том, что тип m является монадой, если для
него определены указанные функции и операторы. При этом необходимо
определить только функцию return и оператор >>=; для остальных
функций и операторов имеются определения по умолчанию.
Инфиксный оператор >>= является обобщением наших функций thenMB,
thenV и thenL (сравните типы этих функций и оператора). Функция
return предназначена для создания монадического типа из обычного
значения: она «вкладывает» значение в монаду, которая в данном случае
рассматривается как контейнер.
Тип Maybe является монадой; это отражено в следующем коде:
instance Monad Maybe where
(>>=) = thenMB
return a = Just a
Таким образом, функцию getPhoneByName, возвращающую значения
типа Maybe Integer, можно определить следующим образом:
45

getPhoneByName a p n = getAddress a n
>>= \address ->
getPhone p address >>= \phone ->
return phone
Можно дать аналогичные определения для других рассмотренных
монад:
instance Monad Value where
(>>=) = thenV
return a = Value a
instance Monad [ ] where
(>>=) = thenL
return a = [a]
Оператор >> используется для комбинирования вычислений, которые
не зависят друг от друга; это можно видеть из его определения. Функ-
цию fail рассмотрим несколько позднее.
В стандартных библиотеках языка Haskell определено много функций
для работы с монадами. Например, функция sequence принимает в
качестве аргумента список монадических вычислений, последовательно
выполняет их и возвращает список результатов:
sequence :: Monad m => [m a] -> m [a]
sequence [] = return []
sequence (c:cs) = c
>>= \x ->
sequence cs
>>= \xs ->
return (x:xs)
Например, выражение
sequence [getAddress a name1, getAddress a name2]
вернет список из двух элементов, каждый из которых будет содержать
результат выполнения соответствующей функции.
Кроме того, поддержка монад встроена непосредственно в язык Haskell.
Так называемая do-нотация облегчает запись монадических вычислений.
Она позволяет записывать псевдо-императивный код с именованными
переменными. Результат монадического вычисления может быть «при-
своен» переменной с помощью оператора <-. Выражение справа от это-
го оператора должно иметь монадический тип m a. Выражение слева
представляет собой образец, с которым сопоставляется значение внутри
монады. Например, (x:xs) может сопоставиться с Maybe [1,2,3]. В
46

последующих монадических вычислениях можно использовать перемен-
ные, связанные в результате этого сопоставления.
Проще всего показать использование do-нотации на примере. Функ-
ция getPhoneByName запишется таким образом:
getPhoneByName a p n = do address <- getAddress a n
phone <- getPhone p address
return phone
Сравните это определение с определением через оператор >>=. Ключевое
слово do вводит правило выравнивания, заключающееся в том, что пер-
вый символ, появляющийся после этого слова, задает колонку, в которой
должны начинаться последующие строки. Использование символов {, }
и ; позволяет избежать этого правила:
getPhoneByName a p n =
do { address <- getAddress a n;
phone <- getPhone p address; return phone }
Do-нотация имеет простые правила преобразования в стандартную
нотацию:
1. Конструкция вида do {e1; e2} преобразуется в
e1 >> e2
2. Конструкция вида do {x <- e1; e2} преобразуется в e1 >>= \x -> e2
Таким образом, в этой конструкции нет ничего, что выходило бы за
рамки функциональной парадигмы, хотя код, иcпользующий do-нотацию,
зачастую напоминает императивный.
Для того, чтобы тип был монадой, ему мало принадлежать к классу
Monad. Понятие монад пришло из отрасли математики, которая называ-
ется теорией категорий. В ней монадами являются объекты, удовлетво-
ряющие набору аксиом; аналогично, для монад языка Haskell должен вы-
полняться ряд законов. Компилятор языка не проверяет их выполнение
(это практически невозможно сделать автоматически) и их правильность
должна быть гарантирована программистом. Вот эти законы:
1. return x >>= f ≡f x
2. f >>= return ≡f
3. f >>= (\x -> g x >>= h) ≡(f >>= g) >>= h
47

В принципе, первые два закона утверждают, что return является
левой и правой единицей для оператора >>=, а третий закон утверждает,
что оператор >>= обладает свойством ассоциативности. Рассмотрим эти
законы подробнее.
Если мы рассматриваем монады как вычисления, то return x со-
здает тривиальное вычисление, всегда возвращающее значение x. Если
мы связываем его с другим вычислением f, это эквивалентно непосред-
ственному выполнению f на x. Если этот закон выполняется, следующие
две программы должны быть эквивалентны:
law1a = do x <- return a
f x
law1b = do f a
Второй закон гласит, что если мы выполнили некоторое вычисление
f и передали его результат в тривиальное вычисление, которое про-
сто вернет это значение, это будет эквивалентно тому, что мы просто
выполнили это вычисление. Следующие две программы должны быть
эквивалентны:
law2a = do x <- f
return x
law2b = do f
Наконец, третий закон утверждает, что независимо от того, в каком
порядке мы группируем действия (слева направо или справа налево),
результат не должен меняться. Следующие программы должны быть эк-
вивалентны:
law3a = do x <- f
do y <- g x
h y
law3b = do y <- do x <- f
g x
h y
Можно убедиться, что рассмотренные нами монады удовлетворяют этим
законам.
В классе Monad определена функция fail. Она вызывается в том
случае, если при сопоставлении с образцом в do-нотации произошла
48

ошибка. По умолчанию эта функция печатает сообщение и завершает
программу, однако в некоторых монадах ее имеет смысл переопределить.
Например, для монады Maybe ее определяют следующим образом:
fail _ = Nothing
Аналогично для списка:
fail _ = []
Важным видом монад являются монады состояния. В начале наших
лекций мы определяли императивные программы как ряд последователь-
ных изменений состояния программы. В императивных языках это со-
стояние присутствует неявно; в функциональных языках его необходимо
явно передавать в качестве аргумента функции.
Рассмотрим проблему генерации псевдослучайных последовательно-
стей. В компьютере псевдослучайные последовательности генерируются
с помощью рекуррентных соотношений вида xk = f(xk−1), где xk — k-й
элемент последовательности. Примером такого датчика (не очень хоро-
шего), генерирующего вещественные числа в диапазоне от 0 до 1, может
служить соотношение
xk = {11 · xk−1 + π},
где {} — оператор взятия дробной части.
В языке Си можно реализовать функцию без аргументов, при каж-
дом вызове возвращающей новое псевдослучайное число. При этом со-
стояние датчика, представляющее в данное случае предыдущее значе-
ние последовательности, можно хранить в глобальной либо в локальной
статической переменной. В языке Haskell значение функции полностью
определяется ее аргументами и состояние (предыдущее значение после-
довательности) необходимо передавать явно. Таким образом, функция,
вычисляющая площадь куба со случайными сторонами, запишется сле-
дующим образом:
random x = frac (pi * x + 11)
cube x0 = let x1 = random x0
x2 = random x1
x3 = random x2 in
x1 * x2 * x3
49

Здесь в качестве параметра функции cube выступает начальное зна-
чение для генератора, а состояние передается из одного вызова функции
random в другой явно. Здесь легко допустить ошибку, например, как в
следующем коде:
cube x0 = let x1 = random x0
x2 = random x1
x3 = random x1 in
x1 * x2 * x3
В этой программе значения переменных x2 и x3 равны! К счастью,
монады могут помочь и в этом случае.
Прежде всего, сделаем ряд обобщений. В нашем случае состояние
датчика и его возвращаемого значения совпадают. Однако это не обя-
зательно. Во-первых, датчик может учитывать при вычислении очеред-
ного элемента последовательности не только предыдущий элемент, но и
предшествующий ему и т. д. Во-вторых, вообще полезно разделить со-
стояние, передаваемое от одного вызова к другому и возвращаемое зна-
чение, поскольку это позволит рассматривать состояние без привязки к
возвращаемому значению. С учетом этих замечаний сделаем следующие
определения:
data State = ... -- Здесь следует определение типа состояния
type StateT a = State -> (a,State)
random :: StateT Float
Тип StateT определяет значения, являющиеся преобразователями
состояния, т. е. функциями, которые преобразуют заданное состояние
в другое состояние, возвращая при этом некоторое значение. Таким обра-
зом, функция random фактически имеет тип State -> (Float,State),
т. е. по заданному состоянию она возвращает два значения: очередное
псевдослучайное число и новое состояние. Функция cube запишется
таким образом:
cube s0 = let (x1,s1) = random s0
(x2,s2) = random s1
(x3,s3) = random s2 in
x1 * x2 * x3
Тип StateT можно сделать монадой, если сделать следующие опре-
деления:
50

instance Monad StateT where
st >>= f = \s -> let (x,s1) = st s in
f x s1
return a = \s -> (a,s)
Здесь оператор >>= связывает состояния, передавая их из одного вычис-
ления в другое, а функция return возвращает тривиальный преобразо-
ватель состояния: функцию, которая оставляет состояние неизменным и
возвращает указанное значение. Теперь можно применить do-нотацию:
cube :: StateT Float
cube = do x1 <- random
x2 <- random
x3 <- random
return (x1 * x2 * x3)
Монады состояния важны, поскольку они являются основой для опре-
деления операций ввода-вывода в языке Haskell. Ввод-вывод долго был
«камнем преткновения» для функциональных языков. Действительно, в
них постулируется, что результат функции зависит только от ее аргу-
ментов. Однако в этом случае функции не могут производить операций
ввода-вывода. Действительно, пусть у нас есть функция getChar, ко-
торая по заданному дескриптору файла типа FileHandle возвращает
очередной прочитанный из него символ:
getChar :: FileHandle -> Char
Эта функция не возвращает одно и то же значения, будучи вызвана с од-
ним и тем же аргументом. Ее результат зависит не только от аргумента,
но и от состояния файла, которое меняется каждый раз, как вызывается
эта функция.
Одним из решений этой проблемы будет явная передача этого состоя-
ния в функции, осуществляющие ввод-вывод. Таким образом, каждая из
функций ввода-вывода будет принимать дополнительный параметр типа
World, описывающим состояние всего внешнего мира, и возвращать, по-
мимо результата, измененное состояние мира. (Разумеется, в реальности
нам нет необходимости запоминать все состояние внешнего мира, эта пе-
ременная будет фиктивной.) Теперь результат функции зависит только
от ее параметров. Однако необходимо быть уверенным, что состояния
мира используются только один раз: возможность повторно использо-
вать это состояние означало бы, что программа должна запоминать все
предыдущие состояния внешнего окружения, а это совершенно недопу-
стимо, да и не всегда возможно: ведь во внешнее окружение входит в
том числе и человек, вводящий символы с клавиатуры!
51

В некоторых языках (например, Clean) для решения этой пробле-
мы модифицировали систему типов таким образом, что однократность
использования переменных типа World проверяется компилятором. В
языке Haskell эта проблема решена с использованием монад. Опреде-
ляется тип IO a, аналогичный нашему типу StateT, только вместо
типа State используется World. Определение оператора связывания
>>= гарантирует, что это значение не будет использоваться более одно-
го раза. Далее, определяется ряд базовых операций, определенных на
низком уровне, осуществляющих основные операции ввода-вывода: от-
крыть файл, считать символ из файла и т. п. Важным свойством этих
операций является то, что они возвращают значение типа IO. Например,
функция для считывания символа из файла имеет тип
getChar :: FileHandle -> IO Char
Наконец, вся программа на языке Haskell представляет собой функ-
цию main :: IO (), содержащую последовательность операций ввода-
вывода (их называют действиями). Эта функция неявно передает состо-
яние мира в последовательность действий.
Необходимо отметить два важных свойства типа IO. Прежде всего,
это абстрактный тип данных: пользователю недоступны конструкторы
данных этого типа, невозможно извлечь значение из него без исполь-
зования монадических конструкций и т. д. Далее, не существует спо-
соба избавиться от этого типа. Любая функция, использующая значе-
ние, помеченное конструктором IO, должна возвращать значение, также
помеченное этим конструктором. Если функция не содержит в своей
сигнатуре типа IO, значит, она не выполняет никаких операций ввода-
вывода: это гарантируется системой проверки типов. Таким образом, те
части программы, которые выполняют ввод-вывод, явно отделены от чи-
сто функционального ядра.
Использование монад позволяет определить небольшой под-язык в
рамках языка Haskell и программировать на нем практически в импера-
тивном стиле. Предполагается, что опытный программист способен со-
хранять «императивную» часть программы небольшой и четко отделять
ее от функциональной части.
52

