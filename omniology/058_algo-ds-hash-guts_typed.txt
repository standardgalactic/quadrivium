Data	 Â Structures	 Â 
Hash	 Â Tables:	 Â Some	 Â 
Implementa6on	 Â Details	 Â 
Design	 Â and	 Â Analysis	 Â 
of	 Â Algorithms	 Â I	 Â 

Tim	 Â Roughgarden	 Â 
Purpose	 Â :	 Â maintain	 Â a	 Â (possibly	 Â evolving)	 Â set	 Â of	 Â stuï¬€.	 Â 
(transac6ons,	 Â people	 Â +	 Â associated	 Â data,	 Â IP	 Â addresses,	 Â etc.)	 Â 
	 Â 
Insert	 Â :	 Â add	 Â new	 Â record	 Â 
	 Â 
Delete	 Â :	 Â delete	 Â exis6ng	 Â record	 Â 
	 Â 
Lookup	 Â :	 Â check	 Â for	 Â a	 Â par6cular	 Â record	 Â 
	 Â (	 Â a	 Â â€œdic6onaryâ€	 Â )	 Â 
	 Â 
	 Â 
	 Â 
	 Â *	 Â 1.	 Â properly	 Â implemented	 Â 	 Â 	 Â 	 Â 	 Â 2.	 Â non-Â­â€pathological	 Â data	 Â 
Hash	 Â Table:	 Â Supported	 Â Opera6ons	 Â 
Using	 Â a	 Â â€œkeyâ€	 Â 
	 Â 
AMAZING	 Â 
GUARANTEE	 Â 
All	 Â opera6ons	 Â in	 Â 
O(1)	 Â 6me	 Â !	 Â *	 Â 

Tim	 Â Roughgarden	 Â 
NaÃ¯ve	 Â Solu6ons	 Â 
1.â€¯ Array-Â­â€based	 Â 
solu6on	 Â 
[	 Â indexed	 Â by	 Â u]	 Â 
-Â­â€	 Â O(1)	 Â opera6ons	 Â 
but	 Â 
	 Â space	 Â 
2.â€¯ List	 Â â€“based	 Â 
solu6on	 Â 
-Â­â€	 Â  	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â space	 Â but
	 Â 	 Â 	 Â 	 Â 	 Â Lookup	 Â 
High-Â­â€Level	 Â Idea	 Â 
Setup	 Â :	 Â universe	 Â U	 Â [e.g.,	 Â all	 Â IP	 Â addresses,	 Â all	 Â 
names,	 Â all	 Â chessboard	 Â conï¬gura6ons,	 Â etc.	 Â ]	 Â 
[	 Â generally,	 Â REALLY	 Â BIG	 Â ]	 Â 
	 Â 
Goal	 Â :	 Â want	 Â to	 Â maintain	 Â evolving	 Â set	 Â 
[	 Â generally,	 Â of	 Â reasonable	 Â size	 Â ]	 Â 
	 Â 
Solu6on	 Â :	 Â 1.)	 Â pick	 Â n	 Â =	 Â #	 Â of	 Â â€œbucketsâ€	 Â with	 Â 	 Â 
(for	 Â simplicity	 Â assume	 Â |S|	 Â doesnâ€™t	 Â vary	 Â much)	 Â 
2.)	 Â choose	 Â a	 Â hash	 Â func6on	 Â 	 Â 
3.)	 Â use	 Â array	 Â A	 Â of	 Â length	 Â n,	 Â store	 Â x	 Â in	 Â A[h(x)]	 Â 

23	 Â 
57	 Â 
184	 Â 
367	 Â 
Consider	 Â ğ‘›	 Â people	 Â with	 Â random	 Â birthdays	 Â (i.e.,	 Â with	 Â each	 Â day	 Â of	 Â 
the	 Â year	 Â equally	 Â likely).	 Â 	 Â How	 Â large	 Â does	 Â ğ‘›	 Â need	 Â to	 Â be	 Â before	 Â there	 Â 
is	 Â at	 Â least	 Â a	 Â 50%	 Â chance	 Â that	 Â two	 Â people	 Â have	 Â the	 Â same	 Â birthday?	 Â 
50	 Â %	 Â 
	 Â 
99	 Â %	 Â 
	 Â 
99.99â€¦.%	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 
	 Â 	 Â 
100%	 Â 
BIRTHDAY	 Â 
â€œPARADOXâ€	 Â 

Tim	 Â Roughgarden	 Â 
Resolving	 Â Collisions	 Â 
Collision:	 Â dis6nct
	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 	 Â such	 Â that	 Â 
	 Â 
Solu6on	 Â 	 Â #	 Â 1	 Â :	 Â (separate)	 Â chaining	 Â 
-Â­â€â€¯keep	 Â linked	 Â list	 Â in	 Â each	 Â bucket	 Â 
-Â­â€â€¯	 Â given	 Â a	 Â key/object	 Â x,	 Â perform	 Â Insert/Delete/Lookup	 Â in	 Â 	 Â 
the	 Â list	 Â in	 Â A[h(x)]	 Â 
Solu6on	 Â #2	 Â :	 Â open	 Â addressing.	 Â (only	 Â one	 Â object	 Â per	 Â bucket)	 Â 
-Â­â€â€¯Hash	 Â func6on	 Â now	 Â speciï¬es	 Â probe	 Â sequence	 Â h1(x),h2(x),..	 Â 
	 Â (keep	 Â trying	 Â 6ll	 Â ï¬nd	 Â open	 Â slot)	 Â 
-Â­â€	 Â Examples	 Â :	 Â linear	 Â probing	 Â (look	 Â consecu6vely),	 Â double	 Â hashing	 Â 
Bucket	 Â for	 Â x	 Â 
Linked	 Â list	 Â for	 Â x	 Â 
Use	 Â 2	 Â hash	 Â func6ons	 Â 

Tim	 Â Roughgarden	 Â 
What	 Â Makes	 Â a	 Â Good	 Â Hash	 Â Func6on?	 Â 
Note	 Â :	 Â in	 Â hash	 Â table	 Â with	 Â chaining,	 Â Insert	 Â is	 Â 	 Â 
	 Â 
	 Â for	 Â Insert/Delete.	 Â 
	 Â could	 Â be	 Â anywhere	 Â from	 Â m/n	 Â to	 Â m	 Â for	 Â m	 Â objects	 Â 
Point	 Â :	 Â performance	 Â depends	 Â on	 Â the	 Â choice	 Â of	 Â hash	 Â func6on!	 Â 
	 Â (analogous	 Â situa6on	 Â with	 Â open	 Â addressing)	 Â 
	 Â 
Proper6es	 Â of	 Â a	 Â â€œGoodâ€	 Â Hash	 Â func6on	 Â 
1.â€¯ Should	 Â lead	 Â to	 Â good	 Â performance	 Â =>	 Â i.e.,	 Â should	 Â â€œspread	 Â 
data	 Â outâ€	 Â 	 Â (gold	 Â standard	 Â â€“	 Â completely	 Â random	 Â hashing)	 Â 
2.â€¯ Should	 Â be	 Â easy	 Â to	 Â store/	 Â very	 Â fast	 Â to	 Â evaluate.	 Â 
Insert	 Â new	 Â object	 Â x	 Â at	 Â 
front	 Â of	 Â list	 Â in	 Â A[h(x)]	 Â 
All	 Â 
objects	 Â in	 Â 
same	 Â 
bucket	 Â 
Equal-Â­â€length	 Â lists	 Â 

Tim	 Â Roughgarden	 Â 
Example	 Â :	 Â keys	 Â =	 Â phone	 Â numbers	 Â (10-Â­â€digits).	 Â 
	 Â |u|	 Â =	 Â 1010	 Â 
-Â­â€â€¯Terrible	 Â hash	 Â func6on	 Â :	 Â h(x)	 Â =	 Â 1st	 Â 3	 Â digits	 Â of	 Â x	 Â 
	 Â choose	 Â n	 Â =	 Â 103	 Â 
	 Â 
	 Â 
	 Â 
	 Â (i.e.,	 Â area	 Â code)	 Â 
-Â­â€â€¯	 Â mediocre	 Â hash	 Â func6on	 Â :	 Â h(x)	 Â =	 Â last	 Â 3	 Â digits	 Â of	 Â x	 Â 
	 Â [s6ll	 Â vulnerable	 Â to	 Â paterns	 Â in	 Â last	 Â 3	 Â digits	 Â ]	 Â 
	 Â 
Example	 Â :	 Â keys	 Â =	 Â memory	 Â loca6ons.	 Â (will	 Â be	 Â mul6ples	 Â of	 Â a	 Â power	 Â of	 Â 2)	 Â 
	 Â 
-Â­â€â€¯Bad	 Â hash	 Â func6on	 Â :	 Â h(x)	 Â =	 Â x	 Â mod	 Â 1000	 Â 	 Â 	 Â (again	 Â n	 Â =	 Â 103)	 Â 
=>	 Â All	 Â odd	 Â buckets	 Â guaranteed	 Â to	 Â be	 Â empty.	 Â 
Bad	 Â Hash	 Â Func6ons	 Â 

Tim	 Â Roughgarden	 Â 
Quick-Â­â€and-Â­â€Dirty	 Â Hash	 Â Func6ons	 Â 
How	 Â to	 Â choose	 Â n	 Â =	 Â #	 Â of	 Â buckets	 Â 
1.â€¯ Choose	 Â n	 Â to	 Â be	 Â a	 Â prime	 Â (	 Â within	 Â constant	 Â factor	 Â of	 Â #	 Â of	 Â objects	 Â in	 Â 
table)	 Â 
2.â€¯ Not	 Â too	 Â close	 Â to	 Â a	 Â power	 Â of	 Â 2	 Â 
3.â€¯ Not	 Â too	 Â close	 Â to	 Â a	 Â power	 Â of	 Â 10	 Â 
	 Â â€œhash	 Â 
	 Â codeâ€	 Â 
	 Â 
e.g.,	 Â subrou6ne	 Â to	 Â convert	 Â 
strings	 Â to	 Â integers	 Â 
â€œcomparison	 Â 
func6on	 Â â€œ	 Â 
	 Â 	 Â 
	 Â like	 Â the	 Â mod	 Â n	 Â 
	 Â func6on	 Â 

