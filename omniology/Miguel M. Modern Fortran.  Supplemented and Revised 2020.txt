
Modern Fortran
Third edition, supplemented and revised

1. Elements of language
1.1. Free form of writing a program
Consider a program that specifies two real numbers, their sum is calculated and the result is displayed:
​ program p1 ! p 1 - program name
real x, y, z ​ ! We declare 3 variables of real type x = 1.1
​ ! Assigned to the variable x and y values y = 2.2
z = x + y
​ ! Assigning to z the result of adding x and y print *, 'z =', z              ! Displaying the result on the screen
! Output result: z = 3.300000
​ end program p1
​ ! END is a mandatory program termination statement
The given program is called the main one . It is built according to the scheme:
first is the declaration of the types of the variables used, then operators that execute on declared variables some
actions. This scheme is typical and has been reproduced several times in manuals.
The program ends with an END statement, in which the program name is p 1 and simultaneously PROGRAM p 1 can be omitted. In other words, the program
can be ended like this: END PROGRAM or END. Program has the title: PROGRAM program-name . However, such a title can be omitted. In this case ,
program-name cannot be present in the END statement. The program-name must be different from names used within the main program.
The program is written in free form . By default the text file a free-form program has the extension F90. It does not there must be a directive $ NOFREEFORM,
and when compiling it is impossible set the compiler option / 4Nf.
Comment. Hereinafter, compiler options inherent in FPS are indicated. Description of CVF compiler options and correspondence between options compilers FPS
and CVF are described in [1].
In free form, the text of the program is written according to the rules:
the length of a line of text is 132 characters;
operator record can start from any position of the line;
several lines separated by a dot can be placed on one linesemicolon (;) operators;
if a line of text ends with a &, then the next linetreated as a continuation line;
O. V. Barteniev. Modern FORTRAN
the operator can contain up to 7200 characters. Continuation lines in free form cannot be more than 54;
any located between the exclamation mark and the end of the linesymbols are treated as a comment, for example:
real x, y,
&
! 
Start 
line
comment
z, a (5),
&
! Continuation line
r, b (10)
! 
One 
more
continuation line
x = 1.1; y = 2.2; a =
-5.5
! 
Assignment
operators
Comment. In addition to a free program, you can write in a fixed form inherited from Fortran 77 (Appendix 2). Files, containing text in fixed form, by default have
extensions F or FOR. In files with such extensions, you can go and to free form by specifying the $ FREEFORM directive or compiler option / 4Yf [1].
Let us now run the program p 1 using those given in Sec. 1.2 intelligence.
1.2. Console project
The program is considered as a project in FPS and CVF. To start a new the program must first of all create it. There are several types of projects, however, at first
we will work with the console project - a one-window project without graphics.
1.2.1. Creating a project in CVF
Let's start creating a project by launching DS. To do this, after starting Windows 95 or Windows NT, you can perform a chain of actions: start -
Programs - Compaq Visual Fortran - Developer Studio. Let's move on to creating a new CVF console project. To do this, execute the File chain New - select the
Projects tab - Fortarn Console Application - set a name project, for example proj1, - set the project location folder, for example
D: \ FORTRAN \ proj1, - OK. In the window that appears then select the button
Anempty project and click Finish. Then a directory (folder) will be created, whose name is the same as the project name. This folder will contain project files with
extensions DSP, DSW and NCB. Also will be created
 Debug folder. The project itself will be displayed on the FileView tab (Fig. 1.1).
1. Elements of language
Figure: 1.1. Project proj1
Now let's create a file in which the text of the program will be entered, by executing: File - New - select the Files tab - select Fortran Free Format
Source File - activate the Add to project option - set the file name, e.g. myp (extension omit) is OK. The generated file will receive extension F90 and will be
located in D: \ FORTRAN \ proj1.
If the file already exists, then to add it to the project in the window FileView select the Source Files folder and execute: click on the right mouse button - Add Files
to Folder - select the type of files and the necessary files (fig. 1.2) - OK.
Figure: 1.2. Adding files to the project
O. V. Barteniev. Modern FORTRAN
To display the contents of the file on the screen, just hit on it twice with the mouse.
1.2.2. Creating a project in FPS
FPS can be equipped with an earlier version of DS, in which the scheme creating a project and adding a file to it is somewhat different.
After starting DS, execute the chain File - New - Project Workspace -
OK - Console Application - enter project name - set location project on disk - Create. After clicking the Create button, a directory (folder), the name of which is
the same as the name of the project. In this folder project files with MAK and MDP extensions will be placed.
Let's create a new file now by doing File - New - Text File - OK.
Next, type the text of the program in the right window and write it to disk: File -
Save - select the directory on the disk for recording the file - set the file name with an extension, for example myp.f90, - save.
Add the created file to the project: Insert - File Into Project - select file myp.f90 - Add.

1.2.3. Project operations
 To close the project, run: File - Close Workspace.
An existing project is opened as a result of executing the File chain Open Workspace - select the project file - Open. To remove a file from of an open project,
just select this file in the FileView window and press Del.
Now let's compile the project: Build - Compile - and fix it errors found, messages about which you will find in the lower window on the Build tab.
Let's create an executable EXE file: Build - Build. Let's run it for execution: Build - Execute - and get the result. To exit the work
DOS window, in which the results are displayed, press any key, for example Esc or Enter.
You can also compile, build and run the program by using the buttons available in the environment (Compile, Build, GO) or by choosing on the keyboard the
corresponding keyboard shortcuts, information about which located in the DS menu items. Here we note that all three the above steps (compilation, build and run)
will be done
after pressing Ctrl + F5. However, if there are several files in the project, it is more convenient
(from the standpoint of detecting errors) compile files separately, proceeding to processing the next file after eliminating all syntax errors in the current.
1. Elements of language
1.2.4. Source files
In general, files with the source code of the program may have extensions F90, F and FOR. For example, myp.f90, myp.f, myp.for. In the first In this case, the
compiler assumes that the file is written in free form. In two the latter are assumed by default that the original text is written in a fixed form (Appendix 2). We will
use for files the F90 extension and free-form source text.
1.3. Operators
A program written in Fortran is a sequence operators of the programming language. Operators are divided into executable and operators that do not participate in
calculations and are called non-executable .
The statement being executed describes the actions that should be produced by the program.
Non-executable statements describe elements of the program, for example data or software components.
 The most commonly used executable assignment operator, having the form:
variable name = expression
As a result of its execution, the variable is assigned the result some expression . For instance:
real :: d, a = 1.2
! Non-executable declaration
statement
! data type in which the
variable a
! got the initial value 1.2
d = 2.3
! Read: d assign 2.3
a = a + 4.0 * sin (d)
! The value of a will change from
1.2 to 4.182821
print *, a
! Outputs the value of a
end
! End the program with the END
operator
Comment. The assignment operator reads better if before and after the operator sign = put one space each.
All data objects used in the program, for example variables, one should first declare, i.e., explicitly indicate their type and for other properties needed. For these
purposes, there are non-executable type declaration statements, for example:
real x, y
! A non-executable REAL statement
declares two variables
! real x and y
integer k
! Non-executable INTEGER statement
declares a variable
! k of integer type that takes positive
integers
nine
10
O. V. Barteniev. Modern FORTRAN
! and negative value and zero, for example:
k = -55
Non-executable type declaration statements must be located in the program before any executable operator.
1.4. Data objects
The program is processing the data. Data presented in the program as variables and constants . Data objects (variables and constants) differ in names, types, and
other properties. A variable whose name is present in the program is considered existing . An existing variable can be defined and uncertain . The variable
becomes defined after it
will get the value, for example, as a result of assignment or execution input. Constants can be named and literal ( unnamed ).
A named constant is declared with the PARAMETER attribute. Value a named constant cannot be changed by computation.
 Therefore, its name cannot be on the left side of the assignment operator or be an element of an input list.
​ real a, b
​ ! We declare real variables named a and b
! Specifying a named constant n
integer, parameter :: n = 5
! All named constants have a PARAMETER attribute
​ a = 4.5
​ ! Now variable a is defined, assigned to it
! literal constant value 4.5
​ read *, b
​ ! After input, variable b will be defined
Comment. When writing a non-decimal real constants should use a decimal point, for example:
real a

a = 4 ​ ! Do not write like this a = 4.0
​ ! This entry underlines the type of data used and
! does not require additional conversions of data types
The initial value of a variable can be set by the operator type declaration or DATA operator. In the case of setting the initial values  (by assignment) or attributes
declaration statement of type must contain the delimiter ::.
real :: a = 1.2, b, c
! Separator ::
required
real d / 4.5 /
! Separator :: can
be omitted
data b, c / 1.5, 4.8 /
! or: data b / 1.5
/, c / 4.8 /
In the examples above, the variables contain one value.
Such variables are called simple . However, you can specify composite
 1. Elements of language
variables containing more than one value. An example of such the variable is an array . Using the name of a compound variable, you can provide access to multiple
values  at once. For instance:
real a (5)
​ ! We declare a real array a of five elements a (1) = 1.2              ! a (1) - name of the first element of array a a (2) = 1.3              ! Set the value 1.3
to the second element of the array a a (3) = 1.4; a (4) = -4.2; a (5) = 0.0
​ print *, a
​ ! Outputting all elements of array a
! The following output is equivalent to PRINT *, a
print *, a (1), a (2), a (3), a (4), a (5)
end
An array cannot have other arrays as elements.
The array considered in the example is one-dimensional. May be multidimensional (with no more than seven dimensions) arrays are also given. The extent of each
dimension of the array is specified by the lower and upper borders, separated by colons. If the lower bound is one, it can be omitted. In this case, and
separating colon. For example, each of the following ads specifies an array of 10 elements:
real a (-4: 5), b (0: 9), c (1:10), d (10)
The number of dimensions of an array is called its rank . Data object, rank which is equal to zero is called a scalar .
In the course of calculations, the value of a variable can be determined or modified, for example, by input or assignment operators. there is situations in which the
value of a variable may become undefined. A data object such as an array is considered undefined if at least one of its elements is not defined.
To define an array or modify it, you can use array constructor . It can also be applied in declaration statements type, and among executable operators, for
example:
real :: a (5) = (/ 1.1, -2.1, 3.1, -4.5, 5.0 /) real b (5) b = (/ 1.1, -2.01, 3.1, 4.05, 50.0 /)
Data objects differ in type. Possible data types : integer, real, complex, boolean, character and derived type structures. The elements of the array can be objects of
the same type.
O. V. Barteniev. Modern FORTRAN
character (30) :: fn = 'c: \ dig.bin'
! fn is a character variable
real, parameter :: pi = 3.141593
! pi is a real constant
 Examples of declaring data objects of different types:
real :: c = 4.56, b (20)
! c and b are
real variables
complex :: z = (1.4142, 1.4142)
! z - variable of
complex type
eleven
In a program, a compound object can be used entirely, you can also use the part of the composite object called subobject . So, in the case of an array, its
subobject is a separate array element, as well as any part of the array that is called section of the array . For instance:
real a (5)
​ ! We declare a real array a of five elements a = 1.2              ! Assign value 1.2 to all elements of array a a (2) = -4.0              ! Assign the value -4.0
to the second element of the array print *, a (1: 3)              ! Output of the section of the array a - the first three of its elements print *, a (1), a (2), a (3)! This
output is equivalent to the previous one
1.5. Names
Variables, constants, software components have names . Name it is a sequence of Latin letters, numbers, $ or underscores starting with a letter or $. The name
should not contain more than 31 characters. Letter case is not significant. So, the names st, St, sT, ST are the same. You should come up with names reflecting the
meaning of applied variables, constants and others objects of the program.
Examples of names: Cat1 F_Name $ var stlen
The names are divided into global ones , for example the name of the main program or a built-in procedure, and local ones , such as a variable name
or constants.
Allowed to create local names that match global built-in procedure names. But if there is a name in a program unit, e.g. sum , used for local variable name, built-in
the SUM function is not available in this programming unit. Therefore for created objects should come up with names that differ
from the names of built-in procedures. You should also not give the created objects names that match the names of operators and other Fortran objects.
Comment. It is widely used in the formation of names of the so-called Hungarian notation . Accordingly, the name of the object is supplied prefix of lowercase
letters indicating its type (if the object has type). The subsequent part of the name reveals its meaning. And each the part of the name that reflects a separate
semantic component begins with capital letter. For example, the name iVectorSize could be given a named constant holding the size of the vector, and the name
SetInitValues may have a subroutine that initializes variables. AT
1. Elements of language
examples of the manual Hungarian notation (with rare exceptions) is not used.
1.6. Expressions and operations
An expression is a formula by which a value is calculated, for example
2.0 * cos ( x /4.5). An expression consists of operands and zero or more operations. Operations used in expressions are divided into binary and single ( unary +
and -). Two-seat surgery involves two operand, in single - one. For instance:

b + c ​ ! Simple expression with two-place operation -b
​ ! Simple expression with a single operation c              ! Expression without operations
The operands of an expression can be constants, variables and calls functions. The expression can appear on the right side of the operator assignments, in output
statements, in procedure calls and other operators of the language. General view of the expression in which there are double operations:
operand operation operand operation operand ...
The value of each operand of the expression must be specified, and the result must have a mathematical meaning. For example, should not be division by zero.
Comment. A subobject of a compound object is also a variable and, therefore, can be the operand of an expression. For instance:
​ real a (10) = 3.0, b (7) ​ ! Array is a compound variable
​ a = 2.0 * a ​ ! Array as element of expression
! The expression element is a section of the array subobject - its section a (2: 8) b = a (2: 8) / 2.5
Depending on the return type of the expression
are subdivided into arithmetic , logical , symbolic
​ and derived type . For expressions of the first three types in Fortran built-in operations are defined. In
derived expressions
operations should to be given programmer. Built-in arithmetic operations are given in table. 1.1.
 Table 1.1. Built-in arithmetic operations
Actions
Designations
Examples
of
Fortran
recording
Exponentiation
**
3 2
2 ** (1.0 /
3.0)
Multiplication,
division
*, /
a × b; a: b
thirteen
a * b; a / b
O. V. Barteniev. Modern FORTRAN
​ Addition, subtraction +, -
​ a + b; a - b ​ a + b; a - b
​ Unary
​ + and -
​ +2; -5.5
​ +2; -5.5
An example of an arithmetic expression:
real :: a = -1.2
​ a = a * a + 2.2 ** 2
​ ! Returns 6.28
Exponentiation has a limited scope. So,
it is forbidden to raise a negative number to a non-integer power,for example, the expression (-2) ** 3.1 is wrong. Also, you cannot raise zero to a negative or
zero degree.
Operations differ in seniority , or priority . Among arithmetic operations, the operation has the highest priority exponentiation, then multiplication follows with the
same priority and division, the same and lowest priority are addition, subtraction and unary + and -. For example, -3 ** 2 returns -9, not 9.
Expressions without brackets are evaluated from left to right sequentially for operations with the same priority, excluding erection operations to the degree that are
performed from right to left. If you want to change this sequence, the part of the expression to be evaluated
in the first place, it is in parentheses. Sometimes brackets are used for improve the readability of the expression. Between expression element and sign operations
to improve the readability of the expression, you can put one space.
Example:
real :: a, c, d = 1.1
real :: s1 = -1.0, s2 = -2.2, s3 = 3.3
d = (d + 5.17) / 46.2
​ ! The expression in parentheses is evaluated first a = d - (s1 + s2 + s3)              ! or a = d - s 1 - s 2 - s 3 c = 2.0 ** 2.0 ** (1.0 /
3.0)              ! Let's display the order of calculations, c = 2.0 ** (2.0 ** (1.0 / 3.0))              ! placing brackets
Single operation sign must not follow directly after another sign of operation. To avoid this, the subexpression with single operation is enclosed in parentheses. For
instance:
a = 4 / -2
​ ! Error a = 4 / (-2)
​ ! Right
You should always take into account the effect of integer division, in which the fractional division obtained as a result of arithmetic division is discarded part for
example:
​ -5 / 2 ​ Returns -2
 
​ 5/2
​ Returns 2
1. Elements of language
The result of an arithmetic expression can be an integer, real or complex number. Boolean expression result is either .TRUE. - true or .FALSE. - a lie . The result
character expression is a sequence of characters that called a character string .
Examples of logical and symbolic expressions:
real :: a = 4.3, d = -5.0
logical :: fl = .false.
! 
Boolean 
variable
declaration
character (10) :: st, st2 * 3 =
'C6'
! 
Declaring 
symbolic
variables st and st 2
fl = .not. fl .and. a> d
! .TRUE.
st = st2 // '- 97'
! C6 - 97
An expression is constant if it is formed from constants. Expressions of this kind can be used, for example, for declaring arrays or character data:
integer, parameter :: n = 20, m = 3 * n real a (n), d (2 * n), c (m) character (len = n / 2) st
Operands of arithmetic, logical and symbolic expressions there can be matched arrays or their sections. One-dimensional arrays are consistent if they have the
same number of elements.
An array and a scalar are always consistent, i.e. a data object that is not array. For instance:
integer :: a (0: 4) = 3, b (-1: 3) = 7, d (5)
​ d = (a + b) / 2
​ ! Array elements d: 5, 5, 5, 5, 5
In the above example, the addition is performed element by element corresponding elements of arrays a and b , then scalar 2 expands to a one-dimensional array
of five elements, each element of which is
two and by which the previously obtained array of sums is divided element by element, i.e., the operator d = ( a + b ) / 2 is equivalent to the operator

d = (a + b) / (/ 2, 2, 2, 2, 2 /)
Fortran allows you to use in expressions not only built-in, but also the operations specified by the programmer. Such operations are applied, for example, when
working with derived data types for which no built-in operations are defined. Can be specified as double and single operations.
1.7. Assignment
The assignment operator is denoted by the equal sign (=) and written in the form
O. V. Barteniev. Modern FORTRAN
varname = expression
As a result of the assignment, the varname variable gets a new one the value that is returned as a result of evaluating the expression .
The equal sign of the assignment operator is interpreted differently than the sign equality in mathematics. So, in mathematics, the notation k = 2 * k + 1 means
writing an equation whose solution is k = -1, and the equation k = k + 1 has no solution at all. At the same time in the program
integer :: k = 4
k = k + 1 ! After assignment, k is equal to five k = 2 * k + 1 ! After the assignment, k is 11 built-in assignment operator is defined for numeric, logical and
character data types. Use varname for a variable derived type is possible if the expression is of the same type as varname .
If the type of the variable varname is different from the type of the expression, then the result of the expression is converted to type varname . Since in
 as a result of transformations, a loss of accuracy is possible, then it is necessary make sure that this loss does not lead to a serious distortion of the
result, eg:
integer n real x, y
n = 9.0 / 2 ​ ! After the assignment, n is equal to four x = 9.0 / 2              ! After the assignment, x is 4.5 y = n * 5              ! Returns 20 - loss of precision
​ y = x * 5
​ ! Returns 22.5 - calculations without loss of precision
1.8. Simple I / O
When typing data from text view converted to internal. When displaying data from internal representation are converted to external (text) representation. I / O
conversions (I / O) can be specified by descriptors transformations. You can also use I / O in which the conversion are executed according to the default rules.
This kind of conversion is provided by a managed I / O list , which we will mainly use in explanatory
examples. List-driven keyboard input and output statements on the screen look like this:
READ (*, *) input list
! Keyboard input
READ * entry list
! Keyboard input
WRITE (*, *) output list
! Output on display
1. Elements of language
​ PRINT *, output list
​ ! Output on display
Input list - part of an input statement that sets values to be entered.
The output list sets the values  to be output.
The output list can contain arbitrary expressions; list input - only variables.
The last or only asterisk of the above operators means the I / O is list driven. In operators containing two bracketed and comma separated asterisks, the first one
specifies I / O device (keyboard and screen).
 Example:
integer n real a (500)
print *, 'Enter n'
! A message will appear on the
screen: Enter n
read *, n
! Using a cyclic list for I / O
read *, (a (i), i = 1, n)
! You will need to enter n values
from the keyboard
print *, (a (i), i = 1, n) Let's
enter:
! Test output to the screen
3
(After entering the value for n,
press Enter)
1 2 3
(Separate values  with a space)
Output result: 1.00000 2.000000 3.000000
Notes:
As a separator for the values  set when entering values, you can use commas or commas together with spaces, for example:
1, 2, 3
The above PRINT statement contains Russian text. However if do not take special measures, then in the DOS window in which this text sent when working with
console projects, will be displayed at all other symbols:
-thfshЄx n
To avoid such distortions, it is necessary in the program that outputs Russian text in a DOS window, follow the link use TextTransfer
provide access to the TextTransfer module and perform transcoding text using the RuDosWin function in the TextTransfer module, writing instead of
print *, 'Enter n'
O. V. Barteniev. Modern FORTRAN
operator
print *, trim (RuDosWin ('Enter n', .false.))
The text of the TextTransfer module and the rules for its use are given in adj. 1. In the future, however, when using the Russian text in the output operator will not
explicitly call RuDosWin, but will always be implied.
1.8.1. Some input rules
To consider the input rules, we introduce a number of concepts.
Writing a text sequential file - character string, newline terminated.
A file record field is a portion of a record that contains data that can be used by the input operator.
 The file consists of records and ends with a special record "end file " . When entering from the keyboard, if necessary, you can put write end of file by
pressing Ctrl + Z, for example:
integer ios real x

do
! The cycle continues until pressing
Ctrl + Z
print '(1x, a, $)', 'Enter x'
! Prompt display; executed without
promotion
read (*, *, iostat = ios) x
! After Ctrl + Z, the entry "end of file"
will be entered,
if (ios == -1) exit print *,
'x =', x end do
! ios will take value -1 and the loop
will exit
List-driven input follows the following rules:
record fields can be separated by spaces and commas;
if there is a slash (/) between the fields of the record, then the input is stopped;
every input operator (unless the specifier ADVANCE = 'NO' is specified)performs input from the beginning of a new record. For example, when you enter
read *, x, y, z you can get by with one entry, for example:
1.1 2.2 3.3
whereas when typing
read *, x read *, y read *, z you already need 3 entries, for example:
eighteen
19
 Elements of language
1.1
2.2
3.3
And if you create, for example, more input fields in the first line:
1.1 4.4 5.5
2.2
3.3
then fields with symbols 4.4 and 5.5 will be in the latest version of the input ignored and still after entering: x = 1.1, y = 2.2, z = 3.3;
if the number of entries in the input list is greater than the number of record fields, thento enter missing values, the input operator will jump to next entry;
to enter the value of a logical variable, just type T or F.
Input errors occur:
if the number of entries in the input list is greater than the number of readable onesrecord fields (that is, if an attempt is made to read the record "end file "and
outside the file);
if the characters placed on the readable field cannot be givento the type of the corresponding element of the input list.
Example:
read *, k
An input error will follow if, for example, you enter k = 2
Correct entry:
1.8.2. Input from a text file
Keyboard input of even a relatively small amount of data quite a tedious task. If, for example, during the debugging phase you run the program many times, then
the work will go much faster when entering data from a file.
Let it be necessary to define real variables x, y and z by setting them when entering values  1.1, 2.2 and 3.3. Create a.txt file in the same location from where the
program is launched, and add the line to it
Input program from file:
real x, y, z
 open (2, file = 'a.txt')
​ ! 2 - I / O device number 19
20
O. V. Barteniev. Modern FORTRAN
read (2, *) x, y, z ​ ! Input from a.txt file print *, x, y, z​ ! Output on display end
The OPEN statement creates an I / O device in the program and connects it with a.txt file. Further in the READ statement instead of the first asterisk the device
number is used, which ensures the data entry of their file, which is associated with this device. Input rules from a text file and with keyboards are the same, since
the keyboard is inherently standard text file.
1.8.3. Output to printer
A printer, like a keyboard, can be thought of as a file that can be connected to a device created by the OPEN operator. Then the printer output program might
look like this:
real :: x = 1.1, y = 2.2, z
= 3.3
open (3, file = 'prn')
! We connect the printer
to the device 3
write (3, *) x, y, z
! Output to printer
write (*, *) x, y, z
end
! Output on display
1.9. Recommendations for learning Fortran
Learning a programming language besides reading and parsing the material given in the books and manuals includes the implementation numerous, often unrelated
to practical tasks.
Mostly such tasks should be invented by you.
on their own, since setting the problem helps understanding material is as effective as the process of analyzing and solving it.
You should start compiling and executing test tasks starting from the first day of studying the material. Suppose read several s of the 1st chapter. In accordance
with the material you typed and the program is running

program p1 real x, y, z x = 1.1 y = 2.2 z = x + y print *, 'z =', z
end
What additional steps in learning a language can be undertaken? Perhaps the following:
• let's initialize the variables in the declaration statement:
1. Elements of language
real :: x = 1.1, y = 2.2 real z
print *, x, y ​ ! Be sure to review the results or:
real x /1.1/, y /2.2/ real z
​ print *, x, y ​ ! Be sure to review the results
now give the initial values  to the variables with the DATA operator:
real x, y, z
data x / 1.1 /, y / 2.2 /
​ ! or: data x, y / 1.1, 2.2 / print *, x, y
put the expression in the output list and omit the program header:
real :: x = 1.1, y = 2.2
print *, x + y
​ ! In the output list, the expression end
let's write several operators on one line:
x = 1.1; y = 2.2; z = x + y! or: z = x + y;
add an error to the program and see the compiler's reaction:
program p1
real :: x = 1.1, y = 2.2 print *, x + y
​ end program p11 ​ ! Error: name p 11 is not the same as name p 1
The solutions to test problems that you compose should contain a sufficient number of operators for outputting intermediate results,
which will allow you to understand the work of the studied elements of the language, make sure the correctness of calculations or localize the error. Special
carefully observe and check the results of the performed keyboard and from the data input file.
Already at the initial stage of mastering the material, you should not regret time to acquire skills in data entry from a text file.
Data in a text file can be entered from the keyboard into DS in the same way just like in another text editor. In DS to create a new file use the ones given in sec.
1.2.1 and 1.2.2 information. Next enter with keyboard data, separating numbers with one or more spaces, eg:
1.2 -1.5 4.0 10 -3
You can save the data in any existing folder, but on at first it is better to place the file in the folder from which the launching your training programs. It will free you
from the need set the path in the file name in the program. To write a file to disk
O. V. Barteniev. Modern FORTRAN
use File - Save - in the "File name" field set the file name, for example a.txt - save.
Now let's try to enter data from the newly generated file
a.txt to a one-dimensional array ar of 10 elements. For this we must open a.txt file and put items in the input list of the READ statement arrays into which data is
entered, for example: integer, parameter :: n = 10 ! Ar array size
! Entering the first five items from a.txt file read (1, *) ar (1), ar (2), ar (3), ar (4), ar (5)
! Displaying the first five elements of ar to the screen print *, ar (1), ar (2), ar (3), ar (4), ar (5) end
The input list contains 5 array elements. What happens if add another element to it, like ar (6)? If the answer to the question is not obvious, then add, run the
program and explain the nature errors.
The I / O lists used in the example are cumbersome. Easy represent the size of a similar list when typing, for example, several hundreds of array elements. Fortran
has several ways to quest compact I / O lists. For instance:
! The input list contains all the elements of the ar array read (1, *) ar
! A looping input list containing the first five elements of ar read (1, *) (ar (i), i = 1, 5)
! In the input list, a section of the array ar from its first five elements read (1, *) ar (1: 5)
Output lists can be made in the same way.
The most compact is the first input list in the operator READ (1, *) ar , but in our case it doesn't suit us. Why?
Array I / O can be executed in a loop
do i = 1, 5
​ read (1, *) ar (i)
​ ! In the input list, one element of the array ar
end do
This loop is equivalent to a sequence of 5 input statements:
read (1, *) ar (1) ​ ! In the input list, one element of the array ar read (1, *) ar (2) read (1, *) ar (3)
real :: ar (n)
character (50) :: fn = 'a.txt'
! We declare a real array ar
! Set the file name
ar = 0.0
! Now all the elements of ar are zero
open (1, file = fn)
! Connect the file to device 1
1. Elements of language
read (1, *) ar (4) read (1, *) ar (5)
However, such a sequence, although it contains only
5 array elements cannot be entered from the a.txt file we created.
Why?
Outputting ar using a loop
do i = 1, 5
write (1, *) ar (i)
! Output to
file a.txt
write (*, *) ar (i) end do
! 
Output
on display
will be executed successfully. In this case, however, the output data will be placed in a column. Why? By the way, where are the displayed to the record file a.txt?

Now let's add at least five numbers to the a.txt file. If the file is open in DS, then to go to the file data window, you can press Ctrl + F6 or select the window with
the file using the Window menu item. Let be the modified file looks like this:
1.2 -1.5 4.0 10 -3 34.2 -55 79.1
90 100.2 -0.4
Now you can use the operator to enter all elements of the array
read (1, *) ar
By the way, why is it possible to post inputs with one READ statement data on different lines of the file?
Now write a program to output the first nine elements of an array ar on three lines of the screen, 3 array numbers in each line.
Other elements of Fortran should be analyzed in a similar way, combining reading of literature, analysis of examples given in it with the formulation and solution of
educational tasks.
1.10. Program processing
The programmer writes the program in the source code (text).
The program can exist in one or more files, called source files . The source file names have extensions F90, FOR or F, for example koda.f90. Default Fortran
believes that files with the F90 extension are written in free form, and with extensions FOR and F - in fixed.
Next, the program is compiled, as a result of which the original text is converted to object code . During compilation, the correctness of the program is checked
and
O. V. Barteniev. Modern FORTRAN
when syntax errors are detected, the corresponding messages. Object code is a program record in the form that can be handled by hardware. This code contains
precise instructions on what the computer needs to do. Selected program components can be compiled separately. Part components can be written to the library
of object files. A program that converts source code into object code is called compiler or translator . Object Code Files - Object files - have the OBJ extension,
for example koda.obj.
The next stage of processing builds the application. Part object files can be loaded from libraries. Wherein individual components (main program, modules,
subroutines, functions) communicate with each other, resulting in a ready-made for execution the program is an executable file . The extension of such files EXE.
The program that builds is called the linker or a builder . At the stage of generating executable code, they can also errors occur, such as calling a non-existent
subroutine.
In CVF and FPS preparation of source, object and executable codes can be executed in a special environment - Microsoft Developer Studio.
 Moreover, several implementations can be generated from one project.
For example, at the stage of program development, you can work with an implementation, in which there is no optimization of the executable code by its size and
speed of execution (compiler option / Od and option linker / OPT: NOREF). Lack of such optimization improves compilation and linking speed. After finishing
debugging you can create a working project optimized for size and speed execution of the executable file, setting, for example, during compilation the option
/ Oxp, and for linking - / OPT: REF. Other options can be set compiler. So, the / G5 option allows you to generate code, optimally running on an Intel Pentium
processor.
By default, when creating a new project, DS contains two implementations are available: Debug and Release. Debug is activated debug mode. In Release, the
executable code is optimized for size and performance. Below are the default FPS compiler and linker options in Debug and Release implementations when
creating a console project.
Debug implementation Compiler options:
/ Zi / I "Debug /" / c / nologo / Fo "Debug /" /Fd"Debug/koda.pdb " Linker options:
1. Elements of language
kernel32.lib / nologo / subsystem: console / incremental: yes
/pdb:"Debug/koda.pdb "/ debug / machine: I386 /out:"Debug/koda.exe"
Release implementation Compiler options:
/ Ox / I "Release /" / c / nologo / Fo "Release /" Linker options:
kernel32.lib / nologo / subsystem: console / incremental: no /pdb:"Release/koda.pdb "/ machine: I386 /out:"Release/koda.exe"
 Comment. Optimal use of compiler options and the builder are considered in [1].
2. Elements of programming
2.1. Algorithm and program
The program performs a certain sequence of actions on the computer, as a result of which the necessary results should be obtained.
To draw up a program, you first need to understand the essence of the problem, and then already describe the actions, after the execution of which the goals
formulated in the task. In other words, it is necessary to compose algorithm for solving the problem.
Let's look at a simple example. Let's make a table of values functions y = x * sin x on the segment [ a , b ] with step dx . To solve the problem you need to do the
following:
°. Start.
°. Enter the values a and b of the segment boundaries and step dx.
°. Set x - the starting point of calculations, taking x = a .
°. While x ≤ b , execute:
 calculate the value of the function y at the point x : y = x * sin x ; display the values  of x and y ; go to the next point of the segment: x = x + dx .
end of loop 4:
°. The end.
The fourth point of the algorithm provides for repeated execution calculating y for different values  of the argument x . Such a repetitive performing the same type
of actions is called a cycle . Reduced cycle will end when x exceeds b - the right border of the line.
To compile a program that performs the stipulated algorithm of action, it is necessary to translate individual steps of the algorithm into the language programming. If
you literally follow the given algorithm, then we get the program:
read *, a, b, dx
! We carry out the 2nd
step of the algorithm
x = a
! We carry out the 3rd step of
the algorithm
do while (x <= b)
y = x * sin (x)
! We carry out the 4th step of
the algorithm
print *, x, y x = x + dx
! Output of x and y

end do
! End of cycle
end
! Finishing the program
However, although the program is written correctly, work with it almost impossible. Suppose you still run
program for calculations. Then you will have a black screen looking at which you have to guess that you need to enter 3 numbers.
Suppose that you guessed it and, after guessing the order of the input, typed 0,
2. Elements of programming
 1, 0.1. Then after pressing Enter, you will see two columns with numbers and again you have to guess what numbers are located in them. Having
launched this program in a week, of course, you are already nothing remember.
Therefore, we should give the program some other, not properties provided by the original algorithm. So, you need create a dialog for entering data, you need to
explain which objects the displayed values  belong. In other words, you need to create some interface between the user and the program. You also need check if
the data is entered correctly: the left border should be less right, and step dx must be greater than zero (otherwise we can get an infinite loop, for example, if a < b
and dx ≤ 0). Introducing similar verification, we increase the reliability of the program. You can envisage and other events that improve the quality of the program.
In addition to adding such performance characteristics, it is useful to increase and requirements for the design of the program: give the program a name, declare
types of variables used in calculations, give an exhaustive comment. You can write operators, built-in names procedures and other Fortran elements in capital
letters, and the user-entered names are in lowercase. When recording fragments programs, such as the DO WHILE ... END DO control structure, the bump rule
should be used , which is that DO statements WHILE and END DO start at the same position, and located inside
of this construction, the operators are shifted one or two positions to the right along relative to the starting position of the record DO WHILE and END DO.
Another useful rule: after a comma or other separator in the text program should affix the gap , ie. e. do the same as in records of text in the native language. After
a series of additions, we can get program:
program txy
! Program header
real a, b, dx, x, y
! Declaring variable names
and types
real :: dxmin = 1.0e-4
print *, 'Enter the boundaries of the segment and the calculation step'
​ print *, 'Left border:'
​ ! Displaying a hint for the user
print *, 'Calculation step:' read *, dx
read *, a
! Enter the value a from the keyboard
and
print *, 'Right border:'
! press Enter. Also introduced
read *, b
! other data
 if (dx <dxmin) stop 'Error while setting step'
x = a
! We carry out the 3rd step of the
algorithm
do while (x <= b)
! We carry out the 4th step of the
algorithm
y = x * sin (x) print *, 'x =',
x, 'y =', y
! When recording a cycle, we use
the relief rule
27
28
O. V. Barteniev. Modern FORTRAN
x = x + dx
end do
​ end program txy ​ ! End the txy program
Comment. CVF and FPS have a special library of procedures DIALOGM for creating data I / O dialog boxes.
The technology of creating dialogs by means of DIALOGM is considered in [1].
Suppose, however, that after entering a = 0, b = 1 and dx = 0.1. Then for x values , for example, 0.3, 0.4 and 0.5, the result will be displayed:
x = 3.000000E-01 y = 8.865607E-02 x = 4.000000E-01 y = 1.557673E-01 x = 5.000000E-01 y = 2.397128E-01
Each line displayed on the screen is separate in our example recording.
The output is clear, but not very descriptive. Shape it representations can be improved by applying formatted output, i.e. by setting some rules for transforming the
output data. Such rules
are set by transformation descriptors (DP). To withdraw the prisoner in quotes a sequence of characters using descriptor A, and the output we execute the values 
of x on a field with a length of 5 positions, placing after decimal point two digits. For this we need the F5.2 descriptor.
When outputting y, use the F6.4 descriptor. Then the inference operator x and y will take the form:
print '(1x, a, f5.2, a, f6.4)', 'x =', x, 'y =', y
The result for the same values  of x will look clearer:
x = .30 y = .0887 x = .40 y = .1558 x = .50 y = .2397
Note right away that the DP list opens the 1X descriptor, which means specifying one space to precede the displayed text. In FPS for formatted output, this is
necessary because the first character of each the record is not printed and is treated as a carriage control character.
In CVF, this interpretation of the first character is not performed and the descriptor 1X can be omitted.
You can also improve the section of the program intended for data entry. If you run the program, you will find that after
When each prompt is displayed, the cursor moves to the beginning of a new line. In other words, it moves to the beginning of the next record. Such the transition
can be avoided by using when displaying a hint formatted output and apply descriptor A to output the string, and followed by the descriptor $ or \ or the specifier
ADVANCE = 'NO'.
However, the last option is applicable only to the WRITE output statement.
 28
29
2. Elements of programming
Inference done this way is called non-forwarding inference . For instance:
print '(1x, a, $)', 'Left border:' print '(1x, a, \)', 'Left border:'

write (*, '(1x, a)', advance = 'no') 'Left border:'
The considered example allows us to draw at least 3 conclusions.
On the one hand, the developed algorithm:
allows you to understand what data are input, what -the result (i.e., highlight the input and output data);
describes what actions should be performed by the programto achieve the result;
determines the order of performing actions;
sets the moment of completion of calculations.
The basis for the software implementation of the algorithm is control structures, one of which is just used construction DO WHILE ... END DO.
On the other hand, it is obvious that to translate an algorithm into a program
it is necessary to have additional, not related to the algorithm
knowledge. For example: how to declare data types, how to create an acceptable interface between user and program, what is the record, how perform formatted
output, and what are conversion descriptors, etc.
And finally, the last conclusion: the programmer should equally well own both the technique of drawing up algorithms and programming techniques, for the
development of which in modern Fortran, it must be admitted, it is required to do a great job.
2.2. Basic Algorithm Structures
Writing a program in a programming language should be done after algorithm development. Having an algorithm, you know how to solve a problem, and in many
ways you are already defining the contours of the future program. here we
we are talking only about the contours of the program, since the implementation of the algorithm in source code can be executed in several ways.
To write algorithms, linear circuits can be used , block circuits and pseudocode . We will use linear circuits, the first an example of the use of which is given in
section. 2.1. When writing them we will use the relief rule; optional schema elements
will be indicated in square brackets, and the vertical bar sign will be use to mean "or".
Any algorithm can be written using three basic structures :
• block of operators and structures;
 29
30
O. V. Barteniev. Modern FORTRAN
branching;
cycle.
2.2.1. Operators and constructs block
A block of operators and constructions (BOC) is the execution of one or several simple or complex actions. BOK may contain and branches and loops, which are
examples of complex actions. A simple action is, for example, doing an assignment, I / O
data, procedure call. and are used to perform control actions such as loops.Constructs consist of multiple operators
So, the DO ... END DO construction consists of two operators: DO and END DO.
2.2.2. Branching
Branching - choosing one of the possible directions of execution algorithm depending on the value of some conditions. There are four types of branching:
if - then;
if - then - otherwise;• if - then - otherwise - if;
selection by key.
Here we will only consider the first two branches.
In the branches "if - then" and "if - then - otherwise" to record conditions a logical expression (LP) is used, the result of which can be true (I) or false (L). Branches
can be illustrated graphically (Figure 2.1).
​ L
​ AND ​ L
​ Lv
​ Lv
AND
​ BOK 1
​ BOK 2
BOK 1
BOK 2
​ BOK 3 and ​ b
Figure: 2.1. Branches: a - if-then branching; b - branching "if - then - otherwise"
If - then branching works like this:
the LP value is calculated;
if it is true, then BOK 1 is executed ;
 if it is false, then control is transferred to BOK 2 .
thirty
31
2. Elements of programming
Record of branching "if - then" in the linear scheme of the algorithm:
X °. If LP is true, then [execute:]
BOK1
end if [X °].
or, if BOK 1 contains one operator:
X °. If LP is true, then [execute:] operator
In Fortran, such a branch can be written as follows:
IF (ЛВ) THEN
BOK1 END IF
or like this:
IF (ЛВ) operator
Comment. The END IF statement can be written without a space: ENDIF.
If - then - otherwise branching works like this:
the LP value is calculated;
if it is true, then BOK 1 is executed ;

if it is false, then BOC 2 is executed ;
further control is transferred to BOK 3 .
Writing branching "if - then - otherwise" in the linear scheme of the algorithm:
X °. If LP is true, then [execute:]
BOK1
otherwise [execute:]
BOK2
end if [X °].
If - then - otherwise branching entry in Fortran:
IF (ЛВ) THEN BOK1
ELSE
BOK2
END IF
Logical operations and operations are used to write LP relations. Also, the LP may contain arithmetic and symbolic operations. Let's give in table. 2.1 some logical
operations and operations of the relation in descending order of their priority. Note that relation operations can be written in two
forms. Table 2.1 these forms are indicated one below the other. It should also emphasize that the logical equality operation is written if you do not use the form
.EQ., with two equal signs (==). Blank spaces logical and relation operations are not allowed, so, in the case of Greater than or equal to operations erroneous .GE
entries. and> =.
31
32
O. V. Barteniev. Modern FORTRAN
Table 2.1. Some logical and relation operations
Operations
Fortran recording
Types 
of
operations
=, ≠,>, <, ≥, ≤
.EQ.,
==,
.NE., ​ .GT., ​ .LT.,
/ =,
​ >,
​ <,
.GE.,
> =,
.LE.
<=
Relations
NOT (negation) .NOT.
Logical
AND
.AND.
"
OR
.OR.
"
An example of "if - then" branching. Determine which of the three given numbers ma , mb and mc is the smallest.
Algorithm:
°. Start.
°. Find the smallest of three numbers and assign the result to m 3.
°. If ma is equal to m 3, then output the message "Number ma ".
°. If mb is equal to m 3, then output the message "Number mb ".
°. If mc is equal to m 3, then output the message "Number mc ".
°. The end.
 This algorithm allows you to find and display all numbers, values which are equal to the minimum.
program fimin
real :: ma = 5.3, mb = 7.6, mc = 5.3, m3
m3 = min (ma, mb, mc) ! Calculating the minimum if (ma == m3) write (*, *) 'Number ma' if (mb == m3) write (*, *) 'Number mb' if (ma == m3) write (*, *)
'Number mc' write (*, *) 'Minimum is', m3
end program fimin Result:
Ma
Mc number
The minimum is 5.300000
2.2.3. Cycle
Loop - re-execution of the BOK, completed on execution some conditions. A single execution of the BOK cycle is called
iteration . The operators and constructions of the BOK cycle are also called the body cycle .
There are 3 types of cycles:
cycle "with a parameter";
bye cycle;
cycle "before".
32
33
2. Elements of programming
2.2.3.1. Loop "with parameter"
In the cycle "with parameter p" the initial value of the parameter p s is set , the final value of the parameter p e and the step s is a nonzero value, by which the value
of the parameter p changes after the next iterations. The parameter p is also called a loop variable, which has whole type. The parameters p s , p e and step s are
integer expressions.
The cycle "with a parameter" is graphically illustrated in Fig. 2.2.
​ Repeat
​ Exit
p = p s , p e , s
SIDE
Figure: 2.2. Loop with parameter
The "with parameter" loop works like this (case s > 0):
°. Assign: p = p s .
°. If p ≤ p e , then go to item 3 °, otherwise terminate the cycle.
 °. Perform BOK.

°. Assign: p = p + s and go to item 2 ° (repeat).
When s <0, item 2 ° looks like this:
2 °. If p ≥ p e , then go to item 3 °, otherwise terminate the cycle.
Notes:
In the cycle "with a parameter" given in p. 1 ° and 4 ° operators in text programs are not present but will be automatically embedded compiler to object code
when compiling a program.
In a loop "with a parameter" it is forbidden to change values  in the body of the loop the loop variable p . Changing the parameters p s , p e and step s in the body
of the loop is not will affect the execution of the cycle: the cycle will be executed with those values parameters as they had before the start of the first iteration of
the loop.
Recording a cycle "with a parameter" in the linear scheme of the algorithm:
X °. With parameter p = p s , p e , s [execute:]
SIDE
end of loop [with p parameter ] | [X °].
Most often, a "with a parameter" loop is written like this:
DO p = p s , p e [, s ]
SIDE
END DO
33
34
O. V. Barteniev. Modern FORTRAN
If there is no step s, its value is set equal to one.
Comment. The END DO statement can be written without a space: ENDDO.
An example . Calculate the length of a polyline consisting of n segments.
The lengths of the line segments are the sequence a , 4 a , ..., n 2 a .
Let L be the required length of the broken line. Obviously, if initially put L = 0, then, having executed the operator n times
L = L + i 2 * a (i = 1, 2, ..., n),
​ (*) where i is the number of the segment of the polyline, we will get the desired result.
To execute the operator (*) n times, use a loop.
The most suitable for this task is the cycle "with a parameter", in which in the number of the polyline segment is used as a parameter.
Algorithm:
°. Start.
°. Enter the values  for n and a .
°. Take L = 0.0.
​ ! L - the length of the broken line
°. With the parameter i = 1, n , 1 execute:! i - segment number
 L = L + i ** 2 * a end of cycle 4 °.
°. Conclusion L.
°. The end.
program polen integer
i, n
! Software implementation of the algorithm
real a, L write (*, *)
'Enter a and n:' read
(*, *) a, n L = 0.0 do
i = 1, n
L = L + i ** 2 * a end
do
write (*, *) 'L =', L
end program polen
! L - the length of the broken line
Comment. The speed of program execution can be increased if:
remove from the loop the operation of multiplication by the variable a , the value which does not change in the cycle;
replace the operation of squaring i ** 2 with a faster one multiplication operation i * i .
34
35
2. Elements of programming
 Then a fragment of the modified program will be like this:
L = 0.0 do i = 1, n
L = L + i * i end do
write (*, *) 'L =', L * a
2.2.3.2. Bye and before cycles
The "while" cycle is executed as long as some LP is "true".
Moreover, the verification of the truth of the LP is performed before the start of the next iterations. The "before" cycle differs from the "while" cycle in that the
check the truth of the LP is carried out after performing the next iteration.
There is no "before" cycle in Fortran, but it can be implemented in declaring an infinite loop DO ... END DO construct. Graphic the interpretation of the "bye" and
"before" cycles is shown in fig. 2.3.
SIDE
L
Lv
AND
​ AND ​ Lv
SIDE
L

​ and
​ b
Figure: 2.3. Cycles "bye" and "before" : a - cycle "bye"; b - cycle "before"
Comment. When working with the "bye" and "before" cycles, it is necessary to ensure that the LP necessarily sooner or later assumed the meaning of a lie .
Otherwise it will happen looping - "infinite" execution of loop operators.
Writing cycles "bye" and "to" in the linear scheme of the algorithm and in Fortran:
​ Loop "while" :
​ Cycle "before" :
X °. While it is true LP [, execute:]
SIDE
end of cycle X °.
X °. Perform:
SIDE
if LP is false, then exit from the
loop end of cycle X °.
DO WHILE (LV)
SIDE
END DO
DO
SIDE
IF (.NOT. Lv) EXIT
END DO
 35
36
O. V. Barteniev. Modern FORTRAN
2.2.4. Interruption of the cycle. Combining conditions
Exit the loop and transfer control to the first one after the loop the statement to be executed is possible by using the EXIT statement. If needed skip some of the
loop statements and go to the next iteration,
then you need to use the CYCLE statement. In this case, control is transferred
DO or DO WHILE statements. EXIT and CYCLE statements separately not used, but embedded in IF constructs.
An example . Calculate the number of positive and negative elements a one-dimensional array a of n elements, ending the calculations if the number of zero
elements of the array will exceed k .
program pn integer, parameter :: n = 10 integer :: a (n) = (/ 1, -2, 0, 3, -4, 5, -6, 7, 0, 9 /) integer :: k = 3, pos = 0, ze = 0, i, va
do i = 1, n ​ ! i - element number of array a va = a (i) if (va == 0) then
ze = ze + 1​ ! ze - the number of zero elements in the array if (ze> k) then exit              ! Exiting the loop else
cycle ​ ! Go to the beginning of the cycle end if
end if​ ! pos - the number of positive elements in the array if (va> 0) pos = pos + 1
​ end do
​ ! Number of negative elements: n - ze - pos
if (ze> k) stop 'The number of zero elements is more than normal'
write (*, *) 'pos =', pos, 'neg =', n - ze - pos end program pn
Comment. Using the va variablereduces the number calls to the array a and thereby increase the performance of the program.
In this task, to complete the cycle, you can use widely the method of combining conditions used in programming . Cycle must continue as long as two conditions
are true: i ≤ n and ze ≤ k . When violation of one of them, the cycle must be terminated. We use combining conditions in a "bye" loop.
 Algorithm:
°. Start.
°. Set the values n , a and k .
°. To accept:
pos = 0
! pos - the number of positive
elements of array a
ze = 0
! ze is the number of zero elements
of array a
i = 1
4 °. While i ≤ n and ze ≤ k ,
execute:
! i - the current element number of
array a
36
37
2. Elements of programming
va = a ( i )
If va = 0, then ze = ze + 1
otherwise, if va > 0, then pos = pos + 1
end if.
end of cycle 4 °.
°. neg = n - ze - pos
​ ! neg - the number of negative elements in array a
°. Pos and neg output .
°. The end.
program pnw
​ ! Software implementation of the algorithm integer, parameter :: n = 10
integer :: a (n) = (/ 1, -2, 0, 3, -4, 5, -6, 7, 0, 9 /) integer :: k = 3, pos = 0, ze = 0, i, va
i = 1 ​ ! Starting calculations from the first element of the array do while (i <= n .and. ze <= k)
va = a (i) if (va == 0) then if (ze> k) stop 'The number of zero elements is more than normal' write (*, *) 'pos =', pos, 'neg =', n - ze - pos end program pnw
The idea of  combining conditions can be realized using checkbox , for example:
...
logical fl i = 1
! Checkbox is a boolean
variable
fl = i <= n .and. ze <= k
! The initial value of the fl flag
do while (fl)
...
i = i + 1
! As long as fl is true, the loop
is executed
! New checkbox value

fl = i <= n .and. ze <= k end
do
2.3. Top-down programming
The development of algorithms and programs is carried out, as a rule, on a top-down basis.
The essence of this approach is to split the original problem into a number of more simple tasks - fragments and subsequent work with the resulting fragments.
ze = ze + 1
else if (va> 0) then
! ze - number of array elements equal to zero
pos = pos + 1
end if i = i + 1
! pos - the number of positive elements in the
array
end do
! Number of negative elements: n - ze - pos
 37
38
O. V. Barteniev. Modern FORTRAN
When dividing the task into fragments, you must adhere to the following schemes:
analyze the problem and highlight fragments in it;
display the splitting process in the form of a block diagram or a linear diagramand number the fragments in it;
establish links between the selected fragments: for eachof the fragment to determine what data it receives (input data) and
what data is returned (output). Communication between
fragments are called an interface ;
consider further each fragment independently; to develop algorithm for it and write it either as a linear circuit, or in the form of a block diagram. Expose the
fragment if necessary splitting into smaller fragments. Such a breakdown to continue until fragments are received, programming which is not particularly difficult;
arrange the selected fragments in the form of software componentsor BOK.
With this approach, the program can be viewed as a set of fragments that, taking some data, produce result and pass it to the next fragment.
Linear diagrams compiled for fragments are accompanied by header, description of the interface (composition of input and output data).
In Fortran, to implement a fragment, you can use program units: main program , modules , subroutines and functions .
Subroutines and functions are called procedures and can be external , modular and internal .
Modules and external procedures are independent program units that can be accessed from different programs.
​ Detailed
​ consideration
​ problems
​ development              programmatic
components we postpone until Ch. 8. Here we will illustrate the methods top-down programming.
2.3.1. Using functions
A fragment of the algorithm, as a rule, is formatted as a function if as a result of the calculations performed in it, the only one scalar or array.
An example . In which of the three one-dimensional arrays a (1:10), b (1:15) and c (1:20) the first negative element has the lowest value.
 Algorithm:
38
39
2. Elements of programming
°. Enter arrays a , b and c .
°. Find ma - the value of the first negative element in array a .
°. Find mb - the value of the first negative element in array b .
°. Find mc - the value of the first negative element in array c .
! Ma , mb or mc values are zero if in the corresponding array
! no negative elements
°. If ma + mb + mc = 0, then
Display the message: "There are no negative elements in the arrays" otherwise
Parse the values ma , mb and mc and print the name of the array, into which the first negative element has the lowest value.
! The algorithm for this fragment is given in Sec. 2.2.2 end if 5:
°. The end.
Fragments 2 °, 3 ° and 4 ° contain the same solvable for different arrays task. According to the programming method "from above down "we describe the
interface, that is, the input and output data of the fragment, and then the algorithm for its implementation.
Fragment interface 2 ° (3 °, 4 °):
Input data. One-dimensional array and the number of its elements.
Inside the fragment, we use the name d for the array , and for the number of elements array - name n .
Output data. The value of the first negative element of array d or 0 if there are no negative elements in array d . For result use the name md .
Algorithm for finding the first negative element of an array:
1 °. i = 1
! i - element number of
array d
°. md = d ( i )
°. While md ≥ 0 and i < n ,
execute: i = i + 1 md = d ( i
) end of cycle 3 °.
! Cycle preparation
4 °. If md ≥ 0 then md = 0
! 
Return 
zero 
if
negative
5 °. Return.
! item not found
Fragment returns one value ( md ), so it can be implement as a function. In Fortran, the variable to which the the result returned by the function is called the
resultant and its type and name (if no RESULT clause is specified) are the same as name and type functions. In our case, the function will be named md .
program nera
​ ! Writing the given algorithms in Fortran integer, parameter :: na = 10, nb = 15, nc = 20 integer a (na), b (nb), c (nc)
​ integer ma, mb, mc, m3
​ ! Since the md function is styled as
39
40

O. V. Barteniev. Modern FORTRAN
integer md
< Input of arrays a, b, and c
>
! external, then you need to
declare its type
ma = md (a, na)
! Passing input data (array and
number
mb = md (b, nb)
! its elements) into the md
function is executed
mc = md (c, nc)
! through its parameters
if (ma + mb + mc == 0) then
print *, 'Arrays a , b and c have no negative elements'
else
m3 = min (ma, mb, mc) if (ma == m3) print *, 'In array a ' if (mb == m3) print *, 'In array b ' if (mc == m3) print *, 'In array c '
end if end program nera
​ function md (d, n)
​ ! Function header
​ integer md ​ ! Result variable
​ integer n, d (n), i ​ ! The function returns the first negative element
i = 1 ​ ! array d or 0 if there are none md = d (i) do while (md> = 0 .and. i <n)
i = i + 1 md = d (i)
 end do
if (md> 0) md = 0
​ ! or: md = min (md, 0) end function md
2.3.2. Using subroutines
If the algorithm snippet returns more than one scalar and / or array, then such a fragment, as a rule, is formatted as subroutines. Passing Input to Subroutine and
Returns from it the values  are executed through its parameters.
Let's count the number of positive ( pos ), negative ( neg ) and equal to zero ( ze ) elements of the array a from the example of Sec. 2.2.4 in vapeg subroutine . We
must pass the array a to it , and then get from it the sought values  are: pos , neg and ze :
program pns
< Data declaration >
​ ! See program text pn section. 2.2.4 call vapeg (a, n, pos, neg, ze)              ! Calling external vapeg routine if (ze> k) stop 'The number of
zero elements is more than normal' write (*, *) 'pos =', pos, 'neg =', neg end program pns
subroutine vapeg (a, n, pos, neg, ze)
integer :: n, a (n), pos, neg, ze, i, va
​ pos = 0; neg = 0; ze = 0
​ ! Preparing for calculations
40
41
2. Elements of programming
< Calculating pos, neg and ze >
​ ! See sect. 2.2.4 end subroutine vapeg
2.3.3. Using modules
Modules can combine data and procedures that process the data declared in the module. Software a unit containing the USE statement module-name gets access
to module data and procedures without the PRIVATE attribute.
Let's consider an example of using a module to record a fragment algorithm. For this, let us return to the problem of Sec. 2.1. It can be distinguished two snippets:
°. Start.
°. Enter and check the entered values  of the boundaries of the segment a , b and step dx .
°. If the entered data contains no errors, then
Compute y starting from point x = a to point b with step dx and outputting the x and y values .
end if 3 °.
°. The end.
Writing linear schemes of fragments 2 ° and 3 ° is easy to perform given in Sec. 2.1 to the algorithm.
 The 2 ° fragment fits well with the module concept: it contains data and some code that does data processing, part of which will then be used in the
second snippet. Implementation of the third fragment, as before, we will execute in the main program.
module ched
! 
Data 
input 
and
processing module
real a, b, dx
real, private :: dxmin = 1.0e-4
! 
Module 
data
declaration
contains
! 
Next 
comes 
the
modular function
function moched ()
! 
data 
entry 
and
processing
logical moched
! Modular function type
print *, 'Enter the boundaries of the segment and the calculation step' print '(1x, a, $)', 'Left border:' read *, a print '(1x, a, $)', 'Right border:' read *, b
print '(1x, a, $)', 'Calculation step:' read *, dx
moched = .false.
! The resulting moched
variable is
if (dx <dxmin) then
! .FALSE. If there are
data errors
print *, 'Error while setting step'
else if (a> = b) then
print *, 'An error occurred when setting the segment boundaries'
else
​ moched = .true. ​ ! If there are no data errors

41
42
O. V. Barteniev. Modern FORTRAN
end if
end function
end module
program txy
! Main program header
use ched
! Link to the CHED module
real x, y
! 
Main 
program 
data
declaration
if (moched ()) then
! Calling a modular function
x = a
! We perform calculations if
the entered
do while (x <= b)
! data does not contain
errors
y = x * sin (x)
print '(1x, a, f5.2, a, f6.4)', 'x =', x, 'y =', y x = x + dx
end do
end if end program txy
2.4. Program design stages
 The above procedure for creating a program includes the stages drawing up a general scheme for solving the problem, highlighting fragments and their
interfaces (input and output data), development of algorithms for fragments and their subsequent encoding. If we add them now testing and debugging stage, you
get a scheme that is quite suitable for solving simple problems. However, the life cycle of large programs is somewhat wider and consists of stages:
Development of the specification.
Designing the program.
Writing a program in a programming language (coding).
Debugging and testing the program.
Refinement of the program.
Production of the final software product.
Documentation.
Support of the program during operation.
The specification contains the statement of the problem, the analysis of this problem and a detailed description of the actions that the program should perform.
The specification reflects:
composition of input, output and intermediate data;
which input data are correct and which are wrong;
who is the user of the program and what should be the interface;
what errors should be detected and what messages shouldissued to the user;
what restrictions the program has (for example, the placement programelements of the printed circuit board may have a limit on the number placed items);
42
43
 2. Elements of programming
all special situations that require special consideration;
what documentation should be prepared;
prospects for the development of the program.
At the design stage , a program structure is created and for of each fragment, known ones are selected or new ones are developed algorithms . The latter must be
subjected to careful research for their effectiveness, i.e. ability algorithm to obtain the required results, and efficiency - the ability algorithm to obtain the desired
results in a reasonable time.
In parallel with the development of algorithms, issues of organization data , i.e. data of standard types and their methods
representations (scalar or array), and new ones are being developed data structures and defines the range of data used with these structures operations. The
approaches to solving these problems largely depend on the programming language used, which can be, for example, object-oriented or modular. Modern Fortran
supports both procedural and modular concepts programming (Section 8.1).
For each fragment, at this stage, complete specifications according to the above diagram.
Coding after the design of the program and the required specification is a fairly straightforward task. When are the first two stages are not explicitly present, then
implicitly they are taken to the stage coding, with all the ensuing consequences. However, for difficult tasks ignoring the above development stages program is not
valid.
Testing is launching a program or a separate fragment with the purpose of identifying errors in them. Debugging is a localization process and bug fixes. As a result
of testing, it is established
whether the developed fragments correspond or not and consist of them the program formulated in the specifications requirements. Methods testing and debugging
are discussed, for example, in [10].
To test a fragment (program), special
test cases of input for which before the chunk is run
(programs) the expected results are calculated . Running a snippet executed from a specially created auxiliary program, called a driver . If the fragment in turn calls
others
fragments, the performance of which has not yet been verified, then these fragments are replaced with special simple programs that
have the same interface as the replacement fragments and mimic them activity. Such programs are called stubs .
 43
44
O. V. Barteniev. Modern FORTRAN

Testing can start with lower-level fragments. Then we only need drivers, since fragments of a higher levels will call already checked fragments. Such a strategy
testing is called bottom-up . With a downward strategy testing starts with top-level fragments. In this case you only need stubs. Usually when testing is ascending
and top-down strategies are used together.
The work done in the preceding steps is usually provides developers with sufficient material to make conclusions about the performance of the program and
formulate suggestions for improving the program and its individual indicators.
However, all these proposals are not always immediately implemented and the program with certain flaws are published as a software
product . However, if some characteristics seriously impair quality of the program, you will have to fulfill its completion .
Support of the program during operation is aimed at elimination of errors identified by users and adaptation software product to its operating conditions. Besides,
accumulates material necessary for further development and creating a new version of the program.
2.5. Source Code Writing Rules
Programmers tend to develop their own style over time writing source code, allowing them when re-accessing
the program quickly remember what it does and how it works, and whenthe need to quickly make changes to the program. In other words, a programmer knows
how to write well-readable and easily changeable code. In some cases, it is necessary that this code could be easily read and change by other programmers, such
as the maintainers of the program. So, due to what techniques it is possible to write a well-readable and easy mutable code? Here are some of them:
the program item must contain a sufficient comment,allowing to determine its purpose, the composition of the input and output data and actions performed by it.
The comment, however, should not interfere with the reading of Fortran operators;
the comment should clarify the meaning of the data objects used;
all data used in a program unit must be explicitlyannounced. This rule will be easier to fulfill if you enter in program unit statement IMPLICIT NONE;
declaration statements should be grouped by type;
the names used for data objects and procedures mustremind their meaning and indicate the type used. For example name
 44
45
2. Elements of programming
g can be used to denote the acceleration of a free
fall, the name iVectorSize is suitable for specifying the length of the vector. Understood meaning and name pi ;
attributes of data objects should be declared in declaration statementslike this: integer, parameter :: n = 20, m = 10! The dimensions of the matrix a not like this:
integer n, m
​ ! This way is worse parameter (n = 20, m = 10)
setting the dimensions of static arrays is best done in the formnamed constants. In the event of a change in dimension, you will need change only the value of the
corresponding constant:
integer, parameter :: m = 10, n = 20 real a (m, n)
the length of a symbolic named constant is better to set in the form
asterisks, for example:
character (*), parameter :: date = '01 .01.2000 '
when writing control structures, use the rule relief , consisting in the fact that located inside the structure operators are written to the right of those forming this
construction statements such as IF-THEN-ELSE statements. The same rule extends to write definitions of derived types and procedures;
when writing operators and expressions, use spaces,for example, before and after an assignment operator or logical operation. Do not forget to put spaces after
commas, for example in array constructor. However, in long expressions, the spaces between operation signs may be omitted;
when creating nested structures, they should be given names;
FORMAT statements are grouped in one place, usually at the topor at the bottom of a program unit;
program units placed in one file must be separatedempty lines;
program units should be located in the file in alphabeticalthe order of their names;
procedures used once in the program are better designedas internal, following the CONTAINS statement;
an internal function is better than an operator one;
 formal parameter - the array should be formatted as an array,taking shape, or as an array of a given shape; 45
46
O. V. Barteniev. Modern FORTRAN
internal arrays and procedure lines should be formatted asautomatic objects;
do not use the GOTO statement;
do not use memory associations;
refuse to use deprecated and outdated productsFortrana (appendix 2).
Most of the above rules are discussed in the manual and
 illustrated with examples.
46
47
3. Data organization
For each object used within a program unit data type, range of change (in case numeric type), as well as the form of representation: scalar or array. Data should
also be split into mutable - variables - and not subject to change - constants.
In addition to variables and constants, data objects include and functions , since they, like variables and constants, have type and are used as operands of
expressions.
The terms variable and constant apply to scalars, arrays and their subobjects, e.g. array elements, components structures, sections of arrays, substrings.
The purpose of this chapter is to look at Fortran data types, their properties, ways to declare data objects of different types, ways setting the initial values  of
variables and other related organization of these issues. The viewing range is limited scalars. Arrays, as more complex, playing an extremely important The role of
data objects in Fortran is discussed separately.
Comment. When describing Fortran operators, their optional items are enclosed in square brackets. The pipe symbol (|) is used in the description of an operator
to mean "or".
3.1. Data types
Data types are divided into built-in and derived, created by the user (Section 3.9).
Built-in data types:
Integer - INTEGER, BYTE, INTEGER (1), INTEGER (2), INTEGER (4). Real - REAL, REAL (4), REAL (8), DOUBLE PRECISION. Complex -
COMPLEX, COMPLEX (4), COMPLEX (8), DOUBLE COMPLEX.

Logical - LOGICAL, LOGICAL (1), LOGICAL (2), LOGICAL (4). An object
Boolean data type can take values  .TRUE. ( true ) or .FALSE. ( false ).
Character - CHARACTER ( n ), where n is the length of the character string (1 ≤ n ≤ 32767).
In Fortran, each built-in data type is characterized by by the variation parameter (KIND). For numeric data types, this the parameter describes the accuracy and
range of variation. Currently there is only one flavor for a character data type (KIND = 1).
47
48
O. V. Barteniev. Modern FORTRAN
Each built-in data type has a standard, defined default variety. Built-in type with default a flavor is called a standard data type .
Standard data types:
Integer is INTEGER.
Real - REAL.
Complex - COMPLEX.
Logical - LOGICAL.
Character - CHARACTER.
Table 3.1 shows the varieties of the built-in data types. In the graph
"Number of bytes" indicates the number of bytes allocated for the object of the given type. When designating the data type, the entered in the standard was used
Fortran 90 syntax.
 Table 3.1. Varieties of built-in data types
Types
Variety Number byte
Integer type
Note
BYTE
1
1
Same as INTEGER (1)
INTEGER (1)
1
1
INTEGER (2)
2
2
INTEGER (4)
4
4
INTEGER
4
Real type
4
Same as INTEGER (4)
REAL (4)
4
4
REAL
4
4
Same as REAL (4)
REAL (8)
8
8
DOUBLE
PRECISION
8
8
Same as REAL (8)
Complex type
COMPLEX (4)
4
8
4 bytes valid
and the same amount for the
imaginary part
COMPLEX
4
8
Same as COMPLEX (4)
COMPLEX (8)
8
16 8 bytes under valid and the same amount for
the imaginary part
DOUBLE
COMPLEX
8
sixteen Same as COMPLEX (8)
48
49
Appendix 3. Data Organization
Boolean type
LOGICAL (1)
1 1
A byte containing either
0 .FALSE., Or 1 -
.TRUE.
LOGICAL (2)
2 2
First (most significant)
byte 
contains 
the
LOGICAL (1) value,
the second is null
LOGICAL (4)
4 4
The first byte contains
the value
LOGICAL (1), others
are null
LOGICAL
4 4
Character type
Same as LOGICAL (4)
CHARACTER or
CHARACTER (1)
1 1
Single character
CHARACTER ( n )
1 n
n - string length in bytes
Notes:
Each numeric data type contains 0, which is unsigned.
All given in table. 3.1 data types were available in
 Fortran 77. True, the syntax of the type definition was different, for example:
Fortran 90
Fortran 77
INTEGER (1)

INTEGER *
1
INTEGER
INTEGER
COMPLEX (4)
COMPLEX
* 8
COMPLEX (8)
COMPLEX
* 16
In Fortran 90, after describing the built-in data type in brackets the value of the variety parameter is indicated, and in Fortran 77 after asterisks are followed by the
number of bytes allocated for the type. With the aim of continuity can be used when specifying data types syntax Fortran 77.
In addition to built-in types, you can define derived data types. (structures) that are created by combinations of data embedded and earlier introduced derived
types. These types of data are entered by the operator
TYPE ... END TYPE.
Fortran includes a large number of built-in numeric references and transforming functions (Sections 6.11-6.13), allowing to obtain information about the properties
of data of various types. So, the greatest positive number for integer and real types is defined function HUGE, and the smallest positive number of real type is the
TINY function.
49
50
O. V. Barteniev. Modern FORTRAN
3.2. Data Type Declaration Operators
3.2.1. Integer data declaration
The INTEGER operator declares variables, constants, integer functions type. Integer data objects can be specified as INTEGER, IN-
TEGER (1), INTEGER (2) or INTEGER (4). Can be used and accepted in Fortran 77, the syntax is INTEGER * 1, INTEGER * 2, or INTEGER * 4. Recall
that the values  specified in brackets specify a kind of type,
the values  after the asterisk are the number of bytes allocated for the type. Asked the default is a flavor of the standard INTEGER data type can be changed using
the / 4I2 compiler option or the $ IN- directive TEGER: 2.
The syntax for the INTEGER statement is:
INTEGER [[([KIND =] kind-value )] [, attrs ] ::] entity-list kind-value - The value of the kind parameter KIND. As kind-
value , a previously defined named constant can be used.
attrs - one or more attributes describing those represented in the entity-list
 data objects. If at least one attribute is specified, then there must be used separator ::. Possible attributes: ALLOCATABLE, AUNO-
MATIC, DIMENSION ( dim ), EXTERNAL, INTENT, INTRINSIC, OPTIONAL,
PARAMETER, POINTER, PRIVATE, PUBLIC, SAVE, STATIC, TARGET and
VOLATILE (the last attribute is applicable only in CVF). Setting attributes can also be performed by a separate operator, whose name matches the name of the
attribute. Attributes define additional properties data and will be entered as the material is presented. If the attribute is set PARAMETER, then an initializing
expression is needed, for example:
integer (4), parameter :: m = 10, n = 20 entity-list - comma separated list of data object names (variables, constants, as well as external, internal, operator and
built-in functions) containing optional initializers
the values  of the expression variables. In this case, initialization can be
done in two ways:
integer :: a = 2, b = 4
or
! Separator: required
integer a / 2 /, b / 4 /
! Separator :: may
be missing
If the KIND parameter is absent, then the default the variety value is four (if the option is not used compiler / 4I2 or $ INTEGER directive: 2). Parameter value
varieties can be recognized by using the built-in help function KIND (Section 6.10).
Range of change of values  of integer types:
51
Appendix 3. Data Organization
BYTE
same as INTEGER (1)
INTEGER (1)
from -128 to +127
INTEGER (2)
-32.768 to +32.767
INTEGER (4)
from -2,147,483,648 to +2,147,483,647
INTEGER
Example:
same as INTEGER (4)
integer day, hour
! Declaration without attributes
​ integer (2) k / 5 /, limit / 45 / ​ ! Declaration and initialization
​ byte vmin = -1
​ ! Same as INTEGER (1)
! Attribute declarations
 50
integer, allocatable, dimension (:) :: days, hours
integer (kind = 2), target :: kt = 2
integer (2), pointer :: kp
! 
Declaration 
and
initialization
integer (1), dimension (7) :: val =
2
! 
Declaration 
and
initialization
allocate (days (5), hours (24))
! Placing arrays
days = (/ 1, 3, 5, 7, 9 /)
! Generating Array
Values

hours = (/ (i, i = 1, 24) /) day =
days (5) hour = hours (10)
! 
using 
an 
array
constructor
kp => kt
! Attaching a link to a
target
print *, day, hour print *, kt, kp
print *, vmin, val (5), k * limit, kind (val), range (kp) end
Result:
9 10
​ 2
​ 2
​ -1
​ 2225 1
​ 4
Comment. Using Fortran 77 syntax, the first 3 statements can be concatenated by specifying the type size in bytes after the variable name:
integer day * 4, hour * 4, k * 2/5 /, limit * 2/45 /, vmin * 1 / -1 /
The number after the asterisk (*) indicates the number of bytes
assigned to a variable of a given type. This way of declaring data is possible with other built-in types.
An integer value can be used in some cases where boolean is expected (in IF and DO statements and WHILE). Moreover, any nonzero integer is interpreted as
true (.TRUE.), and equal to zero is false (.FALSE.), for example:
integer (4) :: i, a (3) = (/ 1, -1, 0 /) do i = 1, 3
if (a (i)) then write (*, *) 'True'
 51
52
O. V. Barteniev. Modern FORTRAN
else write (*, *) 'False'
end if
end do
Result:
True
True
False
Also, an integer value can be assigned to a boolean variable:
logical fl1, fl2 fl1 = 5; fl2 = 0
​ print *, fl1, fl2
​ ! TF
Comment. Mixing logical and integer values  is unacceptable if use the compiler option / 4Ys or the $ STRICT directive, which all extensions in relation to the
Fortran 90 standard are accepted like mistakes.
3.2.2. Real data declaration
The syntax of the operator for declaring objects of real type is similar to the syntax of the INTEGER statement:
REAL [[([KIND =] kind-value )] [, attrs ] ::] entity-list
The KIND parameter can take values  4 and 8. The first value is used to declare single precision data objects, and
the second is for double precision objects. The variation parameter can be omitted. In this case, the default value is the real type variant parameter is four. Of
course it is possible to use an alternative method of declaring data, for example, instead of REAL (4), you can use REAL * 4. Also double precision real data can
be declared by operator
DOUBLE PRECISION. Real data are presented in a computer in the form floating point numbers.
The flavor parameter can also be a named constant or the return value of the KIND function. So, the announcement REAL (KIND (0.0)) is equivalent to REAL
(4) or REAL (KIND = 4)
(or REAL (8) if the / 4R8 compiler option was specified). Announcement
​ REAL (KIND (0.0_8))
​ equivalent to
​ announcement              REAL (8)              or
REAL (KIND = 8). The default variation of the standard real type can be changed from 4 to 8 as a result using the / 4R8 compiler option or the $ REAL: 8
directive.
The range of values  of real types:
REAL (4) negative numbers: from -3.4028235E + 38 to -1.1754944E-38;
 52
53
Appendix 3. Data Organization
number 0;
positive numbers: from + 1.1754944E-38 to + 3.4028235E + 38; the fractional part can contain up to six decimal places. REAL is the same as REAL (4)
REAL (8) negative numbers: from -1.797693134862316D + 308 to -2.225073858507201D-308; number 0; positive numbers:
from + 2.225073858507201D – 308 to + 1.797693134862316D + 308; the fractional part can contain up to 15 decimal places.
Example 1:
integer (4), parameter :: m = 3, n = 5, low = 4 real (kind = 4) :: d (m, n) = 15.0, hot = 3.4 real (4), pointer :: da (:, :) real (low) d2 (n)
Example 2. An attribute can be specified as an operator.
real (8) :: da
​ ! We declare a reference array da pointer da              ! Now, using operators, let's set the attributes dimension da (:, :) parameter m = 10, n =
20
​ allocate (da (m, n))
​ ! First executable statement
3.2.3. Complex data type declaration
A complex number of type COMPLEX or COMPLEX (4) represents is an ordered pair of single precision real numbers.
Complex number of type COMPLEX (8) (DOUBLE COMPLEX) an ordered pair of double precision real numbers. For instance:
complex (4) :: c, z = (3.0, 4.0)
​ c = z / 2
​ ! (1.50000, 2.00000)
The first component of the pair represents real, and the second represents the imaginary part of the number. Both components of a complex number have the same
the same kind of type.

The syntax for declaring objects of a complex type is:
COMPLEX [([KIND =] kind-value )] [[, attrs ] ::] entity-list
3.2.4. Boolean data declaration
Boolean objects are declared by the operator
LOGICAL [([KIND =] kind-value )] [[, attrs ] ::] entity-list
A variation of the type can take the values  1, 2, and 4 and is the same with a boolean length in bytes. The default
 53
54
O. V. Barteniev. Modern FORTRAN
a kind of standard logical data type LOGICAL can be
change from 4 to 2 by specifying the / 4I2 compiler option or directive $ INTEGER: 2.
Example:
logical, allocatable :: flag1 (:), flag2 (:) logical (2), save :: doit, dont = .false._2 logical switch
! Equivalent declaration using operators instead of attributes logical flag1, flag2 logical (2) :: doit, dont = .false._2 allocatable flag1 (:), flag2 (:) save doit, dont
Boolean values  (variables, expressions) can be used in arithmetic operators and can be assigned to integer variables.
Example:
integer :: a = 2 logical :: fl = .true., g = .false.
write (*, *) a * fl, a * g ​ !
​ 20 end
True, where arithmetic values  are required, for example, in the UNIT specifier of the OPEN statement, the use of booleans unacceptable. Mixing logical and
integer values  is also unacceptable, if the / 4Ys compiler option is used.
3.3. Default rules for data types
In Fortran, it is allowed not to declare integer data objects and real types. In this case, the data type of the object will be set to according to the existing default
rules: data objects,
whose names start with the letters i, j, k, l, m and n or with the letters I, J, K, L, M and N , have a default integer type (INTEGER); other objects are by default
the standard real type (REAL). Note that this rule does not apply to some built-in functions.
distributed by. The default flavor of the data type
can be changed by setting the / 4I2 option to the integer type at compile time, or directive $ INTEGER: 2 and for real type - compiler option / 4R8 or the $
REAL: 8 [1] directive.
 Example:
integer :: x = 5
! Integer variable
y = 2 * x
! y - variable of
type REAL
54
55
Appendix 3. Data Organization
3.4. Change default rules
Changing the default rules for data object types is done by the IMPLICIT statement, which sets for the user-declared name is the default type. Operator syntax:
IMPLICIT NONE
or
IMPLICIT type (letters ) [, type (letters ), ...] type is one of the built-in or derived data types.
letters is a list of single letters or letter ranges. Range of letters
specified by the first and last letter of the range, separated by a dash, for example c - f . The letters and ranges of letters in the list are separated by commas, eg:
implicit integer (4) (a, c - f), character (10) (n)
After such a job, all data objects whose names begin with letters a and A and with letters from the range c - f and C - F , will by default have type INTEGER (4),
and objects whose names begin with the letters n and N , by default will be of type CHARACTER (10).
Specifying the same letter in the operator (directly or via range) is not valid. The range of letters must be specified in alphabetical okay. A dollar sign ($) that can be
used as the first the letter of the name follows the letter Z in the alphabet .
The operator does not change the type of built-in functions.
Explicit assignment of type takes precedence over type, specified by the IMPLICIT statement. The task
IMPLICIT NONE
means that all names used in the program must be entered explicitly (via data type declaration operators). Names not entered lead to a compile-time error. No
others
IMPLICIT statements cannot be specified in a program unit, containing the IMPLICIT NONE statement. It is clear that the IMPLICIT NONE job allows
complete control over the types of all data objects.
Example:
implicit integer (a - b), character (len = 10) (n), type (feg) (c - d) type feg integer e, f real g, h end type
age = 10
! age is a variable of type
INTEGER
name = 'Peter'
! name - a variable of the
CHARACTER (10) type
55
56
O. V. Barteniev. Modern FORTRAN
c% e = 1
! c % e is an integer
component of type feg
$ j = 5.0
! $ j - Variable of type REAL
3.5. Literal constants
Fortran distinguishes between named and literal constants.

Literal constants (hereinafter referred to as simply constants) are used in Fortran expressions and operators. Arithmetic is possible , logical and symbolic literal
constants .
3.5.1. Integer constants
Integer constants in decimal notation - whole numbers (signed or unsigned), for example:
+2 2 -2
A constant can be specified specifying a kind of type, value which is indicated after the value of the constant and the _ symbol, for example:
integer i * 2, j * 1 integer,
parameter :: is = 1
i = -123_2
! Variety of type
KIND = 2
j = + 123_is
! Variety of type
KIND = 1
write (*, *) i, j, kind (123_is) ! -123 123 1
 Can be used earlier to indicate variety a defined named constant (in the example is ) of a standard integer type.
Integer constants in arbitrary radix are defined as follows:
[ sign ] [[ base ] #] constant [_ kind ]
The sign is + or -. For positive constants, the sign can be omitted. The radix can be any integer in the range 2 to 36. If radix omitted but # is specified, integer is
interpreted as a hexadecimal number. If
both base and # are omitted, the integer is interpreted as having base 10. In number systems with bases from 11 to 36, the number with base 10 with values 
greater than nine are represented by letters from A to Z . Letter case is not significant. Constant can be given indicating the type of type.
An example . Represent a decimal constant 12 of type INTEGER (1) in number systems with bases 2, 10 and 16.
​ 2 # 1100_1 ​ 12_1 or 10 # 12_1 # C_1 or 16 # C_1
By default, literal integer constants have the standard whole type.
In addition to the named possibilities, in the DATA operator unsigned integer constants can be represented in binary, octal
56
57
Appendix 3. Data Organization
or hexadecimal form indicating the number system in the form character preceding the value of the constant (respectively B or b , O or o , Z or z for binary, octal
or hexadecimal number systems). The constant itself is framed with apostrophes (') or double quotes. In this case, the constant should be used for initializing an
integer scalar variable.
integer i, j, k
data i / b'110010 '/
​ ! Binary representation of decimal 50 data j / o'62 '/              ! Octal representation of 50 data k / z'32 '/              ! Hexadecimal
representation of number 50
3.5.2. Real constants
Real constants are used to write valid numbers. Real constants single REAL (4) and double REAL (8) Accuracy can be presented in F-form or E-form. Besides
this, double precision real constants can be presented in D-form. Memory occupied by a real constant single precision is 4 bytes, and double precision is 8 bytes.
Real constants in F-form are written as:
[ + ] | - [ whole part ]. [ fractional part ] [_ kind of type ]
 The whole or fractional part in F-form can be omitted, but not both at the same time.
Example:
+2.2 2.2_4 2.0_8 2. -0.02_knd -.02
Comment. knd is a previously defined standard integer constant ( knd = 4 or knd = 8).
The constants in E-form and D-form are:
[+] | - [ mantissa ] E | e [+] | - order [_ kind of type ]
[+] | - [ mantissa ] D | d [+] | - order
Mantissa is an F-form number or an integer.
The order is a single or two-digit positive integer.
Example 1:
​ E- and D-forms of number 18.2 * 10 11
​ : + 18.2E11 18.2e + 11_8 18.2D11
E- and D-forms of the number -0.18 * 10 -5 : -.18E-05 -.18e-5 -.18d-5 Example 2:
real (8) :: a * 4 = + 18.2E11, b = 18.2e + 11_8, c /18.2D11/
! a - single variable, b and c - double precision print *, a, b, c
57
58
O. V. Barteniev. Modern FORTRAN
Result :
1.820000E + 12 1.820000000000000E + 012 1.820000000000000E + 012
The E and D forms are also called exponential forms of the number and are good for representing large and small numbers.
Single precision real constants can represent numbers within the range of values  of the REAL (4) type (Section 3.2.2). Fractional part can contain up to six
decimal places.
Double precision real constants can represent numbers within the range of values  of the REAL (8) type (Section 3.2.2). Fractional part can contain up to 15
decimal places.
3.5.3. Complex constants
Complex constants are used for representation complex numbers and have the form:
​ [ sign ] ( real part [ _variation ],
​ &
imaginary part [ _variation ])
 If a sign is given, then it is applied to both the valid and imaginary part. Setting a common sign when initializing a complex variable in DATA statements
and type declarations is not valid.
The real (imaginary) part is an integer or real constant.

Literal complex constants can be single
COMPLEX (4) and double precision COMPLEX (8). In complex single precision constants, the imaginary and real parts occupy
4 bytes of memory; in double precision complex constants - 8 bytes each. Therefore, a complex single precision constant is 8 bytes
memory, and double - 16. When specifying the components of the complex constant can be used simultaneously for real and imaginary
component of the constant E-, D- and F-form. In case of simultaneous use of single and double precision when specifying complex constants, the compiler will
perform type conversion according to the rank of the types of arithmetic operands: the complex constant will be have double precision, and the single precision
component will converted to double precision form.
Example 1. Number 36.8 - 263.3i as a complex constant:
(36.8, -2.633E2) or
(36.8, -263.3) or
(36.8_4, -2.633E2_4)
58
59
 Appendix 3. Data Organization
Example 2. The D-form of the number 3.8 * 10 -5 - 2.6 * 10 -2 i specifies a complex double precision constant:
(3.8D-5, -2.6D-2)
3.5.4. Boolean constants
Boolean constants are used to write logical values true (.TRUE.) or false (.FALSE.). The absence of at least one framing point in a literal boolean constant is a
bug.
By default, literal boolean constants take up in memory
Computer 4 bytes. A variation of the literal boolean constant type can be specified explicitly, similar to how it is done for literal integer constants. For example:
.true._1 or .false._2. An example of setting named boolean constants:
logical (1), parameter :: fl = .true._1 logical (2) gl parameter (gl = .false.)
3.5.5. Character constants
Character constants are a sequence of one or more
8-bit code characters. Further, the sequence of characters we will call it a string . Character constants can be written with and without a length indicator.
Length - specifier character constants , also called Hollerite constants are of the form:
n H sequence of symbols ,
where n is an unsigned integer constant specifying the number of characters in the string
(its length); H ( h ) is a letter separator between n and a string. The number of characters in a character sequence must be n .
Example:
18hthis is a constant
​ st = 16hthis is a string ​ ! Constant as element of expression
A character constant without a length indicator is a string enclosed by in delimiters, apostrophes, or double quotes. Limiters together with the string are not saved.
If the string must contain a delimiter, then it is either contained in constraints of another kind, or must be specified twice per line.
Example:
'This is a constant' or "This is a constant"
"It's a constant" or 'It''sa constant'
 59
60
O. V. Barteniev. Modern FORTRAN
Comment. Length-specifier character constants refer to deprecated Fortran properties and are not recommended for use.
You can set a SI-string constant. For this, to the standard the Fortran string constant must be added with the Latin letters C or c . As you know, CI strings are
null-terminated, having code 0 in the ASCII table.
An example of a SI constant: 'This is a constant's
In the SI string, characters can be represented in octal or hexadecimal code, which are specified when specifying constants after the backslash. For example, '\
62'c and' \ x32'c specify the character
'2' in octal and hexadecimal codes (ASCII character code '2' equals 50). Also in SI there is a special record of the given in table. 3.2 commonly used control
characters.
Table 3.2. Control characters
Symbol
ASCII code
Value
\ 0
0
Null character (
null )
\ a
7
Signal
\ b
8
Backspace
("backspace")
\ t
nine
Horizontal tab
\ n
ten
New line
Example:
character :: bell = '\ a'c​ ! or '\ 007'c, or' \ x07'c character (20) :: st = '1 \ a \ a \ t1-1 \ n \ r2'c
​ write (*, *) bell
​ ! Sound signal
write (*, *) st
\ v
eleven
Vertical tab
\ f
12
translation
\ r
thirteen
Carriage return
\ "
34
Double quote
\ '
39
Apostrophe
\?
63
Question mark

\\
92
Backslash
\ ooo
Octal constant
\ xhh
Hexadecimal
constant
 60
61
Appendix 3. Data Organization
The output of the string st to the screen will happen like this: in the first position of the initial the line will display the character '1'; then two beeps will sound; Further
after tabulation, the characters '1-1' will be displayed in the line; after this will jump to the first position of the new screen line and the character '2' will be
displayed; followed by trailing spaces and null symbol.
In octal code, the value o ranges from 0 to 7.
In hexadecimal h takes values from 0 to F .
When writing SI strings, double quotes can be used, for example an apostrophe can be given like this: character quo / "\ '" c / ! or like this: '\' '' c
You can also specify a zero-length character constant.
character ch / '' / ​ ! '' - constant of zero length print *, len (ch), len_trim (ch)              ! ten
Since character strings are null- terminated, their
concatenation (union) this character, unless special measures will be inside the resulting string, for example:
character (5) :: st1 = 'ab'c, st2 =' 12'c
character (10) res
res = st1 // st2
! Returns ab \
0 12 \ 0
print *, ichar (res (3: 3)), ichar (res (8:
8))
! 0 0
A long character literal constant, that is, a constant that cannot fit on one line, specified using characters transfer, for example:
​ character (len = 255) :: stlong = 'I am a very, very, very long              &
& the longest in the world symbol constant (indeed very long - &
& longer any constant you know) '
Comment. At the beginning of a continuation line, a hyphen can be omitted.
3.6. Setting named constants
You can protect data from changes in the process of calculations by setting them in the form of named constants. A named constant is a named a data object with
the PARAMETER attribute. Setting the attribute can be execute with a separate operator:
PARAMETER [(] name = const [, name = const ...] [)] or in a type declaration statement:
typespec , PARAMETER [, attrs ] :: name = const [, name = const ] ...
typespec - any data type specification. name - the name of the constant. Cannot be a sub-object name.
 61
62
O. V. Barteniev. Modern FORTRAN
const is a constant expression. The expression can include names
constants previously entered in the same program unit. Permissible constant expression operations - arithmetic and logical. If
the type of the constant expression differs from the type name , then any operations type conversions are done automatically.
attrs - other possible attributes of the constant. The named constant can be an array or an object derived type. In the first case, to set it, one uses an array
constructor, in the second, a derived type constructor.
When using the PARAMETER statement, specifying a named boolean, symbolic and complex constant must be executed after descriptions of its type. The types
of integer and real constants can be set according to existing data type defaults.
Attempts to change the value of a named constant using an operator assignments or READ statements will result in a compilation error.
The named constant name cannot be a derived component data type, array element and associated data object, applied, for example, in the EQUIVALENCE or
COMMON statements. Also named constant cannot appear in spec
format data transmission control. When using a constant in as an actual parameter of the procedure to the corresponding the formal parameter should be set to the
communication type INTENT (IN).
Example 1. Setting named constants in the PARAMETER statement.
character (1) bell
​ parameter (bell = '\ a'C)
​ ! SI string
parameter (g = 9.81, pi = 3.14159)! The enclosing parentheses can be omitted
complex (4) z
! The type is declared
first,
parameter (z = - (12.45,
6.784))
! and then the value is set
write (*, *) bell
! Sound signal
write (*, *) (bell, i = 1,
10)
! Continuous signal
Example 2. Using PARAMETER as an attribute.
program pa
complex (4), parameter :: z = - (12.45, 6.784)
​ integer (2), parameter :: a (5) = (/ 1, 3, 5, 7, 9 /)
​ ! a - array constant
type made ​ ! Specifying the type made character (len = 8) bday character (len = 5) place
end type made
! Setting a pro constant of type made
 type (made), parameter :: pro = made ('08 / 01/90 ',' Mircu ') write (*, '(1x, a10, 2x, a5)') pro end program pa
62

63
Appendix 3. Data Organization
3.7. Setting the initial values  of variables.
DATA operator
Fortran has two options for specifying initial values variables: in the type declaration statements and the DATA operator. Initial values  are assigned to variables at
compile time programs. DATA statement syntax:
​ DATA list of names / list of values / ​ &
[, list of names / list of values /] ...
List of names - a list of variables, their subobjects and cyclic lists. The list items are separated by commas. Item indices arrays and substrings in the list of names
must be integers constant expressions.
List of values - a list of constants and / or repeating constants, separated by commas.
A repeating constant is an element of the form n * val , where n is an integer positive constant (literal or named); * - symbolrepeater. Such an element in the list of
values  means that n in a row located variables in the list of names will result in executing the DATA statement to val .
Example:
real (4) a (6, 7), d, r, eps, cmax
character st * 6, sth * 20, chr
integer (4) m, n logical (1) flag,
yesno
data a / 1, 2, 3, 4, 5, 6, 7, 35 *
0 /,
&
d, r / 4, 6.7 /,
eps /1.0e-8/, cmax /2.4e12/
data st / 'Error!' /, chr / 'Y' /, m,
n / 6, 7 / data sth / 18hHollerith
constant / data flag, yesno
/.true., .false. /
&
With a large number of initialized variables, it follows for to improve the readability of the program, use continuation lines, or multiple DATA statements.
Variables of derived type are initialized with using a derived type constructor in DATA (Section 3.9.2.1), or by initializing their individual components:
type pair real x, y end type
pair
type (pair) pt1, pt2
! 
We 
use 
to
initialize pt 1
data pt1 / pair (1.0, 1.0) /
! 
structure
constructor
63
64
O. V. Barteniev. Modern FORTRAN
data pt2.x, pt2.y / 2.0, 2.0 /
! Initialization of individual
components
print '(1x, 4f5.1)', pt1, pt2
! 1.0 1.0 2.0 2.0
Variables that are explicitly assigned the AUTOMATIC attribute cannot appear in a DATA statement.
The data type of each numeric or logical element in the list of values  is converted to the type specified for corresponding variable in the list of names . For
example, to initialize a real variable you can use an integer literal constant.
The number of values  in each list of values must match the number elements in the corresponding list of names . You can't do it twice in a statement DATA initialize
the same variable.
The elements of a two-dimensional array are initialized by columns, for example:
real a (3, 2)
data a / 1, 2, 3, 4, 5, 6 / ​ ! This entry is equivalent to the following data a (1,1), a (2,1), a (3,1), a (3,2), a (2,2), a (3,2) / 1, 2, 3, 4 , 5, 6 /
 If a character element in the list of values  is shorter than the corresponding variable or array element in the list of names , its the size is increased to the
length of the variable by adding trailing spaces. If the character element is longer corresponding variable, excess characters are truncated.
Formal parameters, variables of unnamed common- blocks and function names cannot appear in a DATA statement. Variables named common blocks may appear
in a DATA statement if it is used in the BLOCK DATA programming unit.
The DATA operator can contain cyclic lists in the list of names :
( dolist , dovar = start , stop [, inc ]) dolist is an array element whose index is the dovar variable . start , stop , inc are integer constant expressions that define
dovar range and step . If the inc expression is missing, then the step is set to one.
When using a circular list, you can do initialization of part of the array. Organization of nested cyclic lists.
Example:
integer (4) a (20), b (5, 30), c (15, 15), row, col integer, parameter :: rma = 10, cma = 5
data (a (i), i = 4, 16, 2) / 4, 6, 8, 10, 12, 14, 16 /
​ & ((b (i, j), j = 1, 12), i = 1, 2) / 24 * -3 /              &
((c (row, col), row = 1, rma), col = 1, cma) / 50 * 10 /
64
65
Appendix 3. Data Organization
When setting the initial values  of variables in declaration statements of type the initial value of the variable follows immediately after the declaration of this variable.
It is also possible, as in the case of the DATA operator, using repeating constants like:
real a (6, 7) / 1, 2, 3, 4, 5, 6, 35 * -1 /,&
d / 4 /, r /6.7/,
&
eps /1.0e-8/, cmax /2.4e12/
character st * 6 / 'Error!' /, chr / 'Y' /, sth * 20 / 18hHollerith constant /

​ integer m / 6 /, n / 7 /
​ ! Wrong entry: integer m, n / 6, 7 /
! or, using the Fortran 90 syntax: character (len = 6) :: st = 'Error!'
​ integer :: m = 6, n = 7 ​ ! Separator: required
To initialize variables in operators, type declarations can use constructors of arrays and structures. Multidimensional array can be constructed from one-
dimensional using the RESHAPE function (section 4.12.4.3), for example:
real (4) :: b (42) = (/ 1, 2, 3, 4, 5, 6, (-1, k = 7, 42) /)
real (4) :: c (6, 7) = reshape ((/ 1, 2, 3, 4, 5, 6 /), shape = (/ 6, 7 /), pad = (/ -1 /))
3.8. Character data
 3.8.1. Declaring character data
Character data types in Fortran can have variables and constants, which we will call strings , as well as arrays and functions. The element of a character array is a
string. Returnable by a symbolic function, the result is also a string.
Character data objects are declared with the CHARACTER statement: CHARACTER [( type-param )] [[ attrs ] ::] vname
type-param - length of vname and value of the flavor parameter; can
have one of the following forms:
([LEN = ] type-param-value );
(KIND = expr );
(KIND = expr , LEN = type-param-value );
([LEN = ] type-param-value , KIND = expr ). type-param-value - can be either an asterisk (*) or an integer
an unsigned constant in the range 1 to 32767, or an integer constant expression evaluated with a value in range from 1 to 32767. Also if the CHARACTER
statement declares formal parameters and placed in the body of the INTERFACE operator or in procedure declaration section, then to set the type-param-value
you can use a non-constant descriptive expression (see Section 5.6). When if the corresponding actual parameter is given, then the formal
65
66
O. V. Barteniev. Modern FORTRAN
the parameter cannot have a SAVE attribute, appear in a DATA statement, or be initialized in a CHARACTER statement. For example, formal parameter st 3
routines the sub :
character (len = 15) :: st = 'example', st2 * 20 / 'example_2' /
...
call sub (st, 15) call sub (st2, 20)
...
end
subroutine sub (st3, n)
integer (4) n
character (len = n) st3
! length of st 3 on first
call
print *, len (st3)
...
end
! equals 15, and for the
second - 20
 If the value of an expression that determines the length of a character element is negative, then the declared character elements will be null length. If
type-param is not specified, then the default length is character data object is assumed to be one.
expr is an integer constant or descriptive expression, specifying a kind of character type. Fortran supports one the value of the flavor parameter (KIND = 1) for
character objects data.
attrs is one or more attributes, separated by commas. If though If only one attribute is specified, the separator :: is required.
The same ones are used as with the INTEGER operator (Section 3.2.1) attributes. If the PARAMETER attribute is set, then it is necessary and an initializing
expression, for example:
character (len = 20), parameter :: st = 'Title' vname - the name of a variable, constant or function (external, internal,
operator, built-in).
By default, a string that is not given an initial value consists of null characters. Therefore, the LEN_TRIM function will return for this line its full length. It is useful to
do string initialization like spaces:
character (30) fn, path / '' /
! path gets the initial
value
write (*, *) len (fn), len (path)
!
​ thirty​ thirty
write (*, *) len_trim (fn), len_trim
(path)
!
​ thirty​ 0
write (*, *) ichar (fn (1: 1)), ichar
(path (5: 5))
!
​ 0
​ 32
If the initial string value contains fewer characters than
its length, the missing characters are filled in with spaces, which
66
 67
Appendix 3. Data Organization
are called final . If the initial value contains more characters than the length of the string, then excess characters are truncated. Symbolic literal SI constants can be
used, Rounding null -symbols, for example:
character (20) :: st = 'C string'c write (*, *) st
As with other data types, the syntax can be used Fortran 77 CHARACTER statement, for example:
character * 15 st1 / 'first' /, st2 / 'second' /
​ ! Strings 15 characters long character * 5 st3, st4 * 10, st5 * 15              ! Strings 5, 10, and 15 characters long
character * 6 ast (10) / 'Nick', 'Rose', 'Mike', 'Violet', 6 * '???' / character err * (*) parameter (err = 'Error!')
Comment. In FPS when initialized using a factor repetition, keep track of the length of the initializing literal
symbolic constant: its length must match the one specified in the operator CHARACTER string length. So, in the operator

character * 6 ast (10) / 'Nick', 'Rose', 'Mike', 'Violet', 6 * '???' / the last five elements of the array will not be initialized. For proper initialization, use a repeating
constant 6 * '??? ', where the character means a space. In CVF such no problem.
3.8.2. Using an asterisk to set the length of a string
Using an asterisk (*) to set the length of a character object data is possible in three cases:
1) when declaring symbolic named constants (objects, having the PARAMETER attribute). In this case, the string length is the number of characters in the
constant, for example:
character (*) st
! or character (len = *) st
! or character (len = *, kind = 1) st
! or character (*, kind = 1) st ! or character (kind = 1, len = *) st parameter (st = 'exam') or
character (len = *), parameter :: st = 'exam'! etc
A symbolic constant - an array can also be declared:
character (len = *), parameter :: ast (3) = (/ 'jan', 'febr', 'march' /) or
 67
68
O. V. Barteniev. Modern FORTRAN
character (len = *), parameter :: ast (3) / 'jan', 'febr', 'march' /
​ print *, len (ast)
​ ! 5 - the length of each element of the array
The length of a character array element is calculated based on the maximum the length of the character literal constants that initialize the array. In our example, this
constant is 'march';
2) an asterisk (*) can be used to specify the length of a character element when declaring formal character parameters. In that
case, the length of the formal parameter is equal to the length of the actual parameter. For instance:
character (len = 15) :: st = 'example', st2 * 20 / 'example_2' /
...
call sub (st) call sub (st2)
...
end
subroutine sub (st3)
character (len = *) st3 ​ ! The length of st 3 is equal to the length of the actual parameter print *, len (st3)
...
end
3) when declaring the length of the returned outer non-recursive the symbolic result function can also be used star. In this case, the actual length of the result is
defined in the CHARACTER statement of the program unit inwhich the function is called. For instance:
integer, parameter :: n =
20 character (len = 4) ::
ins = '+ -'
character (len = n) st,
stfun
! Length returned by stfun function
st = stfun (ins)
! result is n
print *, st
end
function stfun (pm)
! # + - + - + - + - #
character (len = *) pm
! The length of the line pm is equal to the length of
the line ins
! The length of the result returned by a symbolic function is determined by
! in the program unit where this function is called character (len = *) stfun
character (len = len (stfun)) temp! String the temp - example
temp = pm // pm // pm // pm ​ ! automatic data object stfun = '#' // trim (temp) // '#'              ! for such objects cannot be
​ end
​ ! the attributes SAVE and STATIC are set
Symbolic operator or modular functions, array functions, reference functions and recursive functions cannot have a BOM lengths as an asterisk (*).
 68
69
Appendix 3. Data Organization
3.8.3. Automatic lines
Procedures can contain more than just resizing strings from the actual parameter (in the last example it is the line pm ), but also local symbolic variables whose size
is determined by
procedure call. In our example, this is the string temp . Such variables refer to automatic data objects that are created in the moment the procedure is called and
are destroyed upon exiting it. Automatic objects should not be declared with SAVE attributes or STATIC.
3.8.4. Substring highlighting
Consider a 10-character string st with the value "This is a string". Like array elements, string characters are located in memory computer one by one (Fig. 3.1).
Memory cell
​ E
​ t
​ about​ from ​ t
​ R
​ about​ to
​ and
​ st (1: 1) st (2: 2) ​ st (10:10)
Figure: 3.1. Line in computer memory
Each character in the string is numbered. Moreover, the 1st character is numbered 1, the 2nd - number 2, etc. The st ( i : i ) record provides access to the i -th
character of the string.
Example. How many times is the letter 't' in st ?
character (len = 20) :: st = 'This is a string' integer (2) :: k, j k = 0
do j = 1, len_trim (st)

! The LEN_TRIM function
returns
if (st (j: j) == 't') k = k + 1
! the length of the string
without trailing
end do
! gaps
print *, 'k =', k
end
! Will print : k = 2
In Fortran, you can extract any substring from a string : st ([ first ]: [ last ])
first - arithmetic expression of real or integer type,
which defines the first character in the substring. Default value
first is equal to one, and if first is not given, then the substring starts from the first string character.
last - arithmetic expression of real or integer type,
which defines the last character in the substring. Default value
last is equal to the length of the string, and if last is not given, then the substring is terminated the last character of the string st .
 69
70
O. V. Barteniev. Modern FORTRAN
Notes:
If necessary, the fractional part first ( last ) is discarded.
The values first and last must be greater than zero; last cannot exceed line length; first ≤ last .
The st (:) and st entries are equivalent.
4a character array and to a character entry. . The operation of highlighting a substring can also be applied to an elementFor instance:
character st * 20 / 'It''sa string' /
​ ! st - string; arrst - array of strings character (len = 15) arrst (10) / 'It''sa string', 9 * 'One more string' /
write (*, *) st (1: 6)
​ ! or st (: 6) ​ It's a write (*, *) arrst (2) (10: 15)              ! or arrst (2) (10 :) string
3.8.5. Symbolic expressions. Concatenation operation
Fortran contains a single symbolic operation - the operation concatenation (//). The result of the operation is the concatenation of strings the operands of the
symbolic expression. The length of the resulting string is the sum of the lengths of the operand strings.
The operands of a symbolic expression can be:
symbolic constants and variables;
symbolic arrays and their sections;
elements of character arrays;
calls to symbolic functions;
character substrings;
character components of derived types.
Example:
character (len = 12) st1, st2
character (len = 24) st data st1, st2
/ 'first', 'second' /
! 12 character
strings
print *, st1 // '&' // st2
! 
first 
&
second
st = st1 (: len_trim (st1)) // '&' // st2 (: len_trim (st2))
print *, st
st = trim (st1) // '&' // trim (st2)
! first &
second
print *, st
! first &
second
Notes:
In order not to lose some of the characters when concatenating strings, you need to followso that the length of the string to which the result of the concatenation is
assigned is not less than the sum of the lengths of the strings being merged.
 The LEN_TRIM function calculates the length of the string without trailingspaces.
The TRIM function returns a string without trailing spaces.
70
71
Appendix 3. Data Organization
4. To select a line without trailing spaces, use the function TRIM, for example:
st = trim (sb)
In earlier versions, the same was done like this:
st = sb (: len_trim (sb))
3.8.6. Assigning character data
By assignment operator to a variable of symbolic type the result of the symbolic expression is set: symbolic variable = symbolic expression
Character variable - string, substring, character array, character elements of records. The length of a character variable can differ from the length of the string - the
result of the symbolic expression:
character st * 9 / 'Line 1' /, stnew * 14 / 'New line' /, st2 / '2' / st = stnew              ! 'New Stro' st = st2              ! '2              ' st2 = stnew // st              ! 'H'
If the character variable is a substring, then the result is assignments change the characters belonging to the substring:
character st * 20 / 'Line 1' /, stnew * 14 / 'New line' /, st2 / '2' /
st (8 :) = stnew (1: 5)
​ ! 'String New' st (14:14) = st2
​ ! 'Line New 2'
Assignment of character arrays and their sections is possible if they are consistent (section 4.6), for example:
character (1) st (4) / 'a', 'b', 'c', 'd' /, st2 (4)
character (len = 3) res (4)
​ ! A character array of four elements; st2 = st              ! the length of each element in the array is three res = st // st2              ! All
arrays are consistent write (*, *) res              ! aa bb cc dd

3.8.7. Symbolic variables as internal files
In Fortran, character string, substring, and character array are internal files , i.e. files that exist in
RAM of the computer. In the case of a string or substring, this file has only one record, the length of which matches the length of the character variable. In the case
of a character array, the number of entries in the file is the number of its elements. For data transfer when working with strings as with internal files use I / O
operators:
READ ( u , fms ) input list
WRITE ( u , fms ) output list
71
72
O. V. Barteniev. Modern FORTRAN
u - I / O device (see Sections 10.2 and 10.3). When referring to internal
file device number is the name of a symbolic variable, for example a string, substring, or character array.
fms - I / O format specifier, which in the case of I / O controlled
an unnamed list is specified as an asterisk (*).
Using the WRITE operator, you can transfer data of any types. Conversely, the READ statement from a string can be, for example, numeric data (if there are
numeric data fields in the string). Often using the WRITE operator, numeric data is converted to
symbolic, for example the number 123 into the string '123', and also formed strings consisting of a mixture of numeric and character data. For example, for
ensuring the output of messages containing numerical data in graphic mode by means of the OUTGTEXT subroutine or with working with dialog boxes.
Example. Convert given numbers ( a and b ) to character performance. Do also reverse conversion "string number".
integer (2) :: a = 123, a2 real (8) :: b = -4.56
 character (10) sta, stb, ste, st * 50 write (sta, '(A, I3)') 'a =', a
write (stb, '(F8.3)') b
​ ! I / O device number is the same as name write (ste, '(E10.4)') b              ! the line to write data to print *, sta, stb, ste              ! a =
123 -4.560 -.4560E + 01
write (st, '(A, I3, F7.2, E12.5)') 'a & b & b:', a, b, b
print *, st
! a & b & b: 123 -4.56
-.45600E + 01
read (st, '(12X, BZ, I3)') a2
! Read from st the value a
2
print *, a2
! 230
write (st, *) 'a:', a
! List driven output
print *, st
! a: 123
Explanation . When reading from a line (internal file) used transformations: 12X - move 12 characters to the right, I3 - translation sequence of characters '23 'to
number 230. Space is interpreted as 0 thanks to the BZ descriptor.
3.8.8. Built-in functions for handling character data
Fortran contains built-in functions that allow you to operate character data. Built-in functions are divided into elemental ones , reference and converting . Element
function arguments there can be both scalars and arrays. In the latter case, the function returns an array matched to the parameter arrays. Value the element of the
returned array is determined by applying functions to the corresponding element of the argument array. A number of functions,
72
73
Appendix 3. Data Organization
e.g. ICHAR or INDEX, return a standard integer value of type INTEGER, which has a default flavor parameter
KIND = 4. However, if the compiler option / 4I2 or the directive
$ INTEGER: 2, then INTEGER type will be equivalent to INTEGER (2) type and, hence functions of a standard integer type like INDEX, will also return values 
of type INTEGER (2).
IACHAR ( c ) - element function; returns the value of the standard an integer equal to the ASCII code of character c . Parameter type c -
CHARACTER (1).
Explanation . Each character is assigned a whole a positive number called a character code. American standard ASCII data exchange encodes 128 characters,
including control symbols, symbols of numbers, lowercase and uppercase letters of English alphabet, punctuation marks and a number of other commonly used
symbols. The ASCII character codes range from 0 to 127. The first ASCII is character (character with code 0) is the empty ( null ) character - ''. So any SI string
ends with a character. Codes with values  large 127 are used to encode national alphabets. Features:
encodings of the Russian alphabet are considered in Appendix. 1.
 ICHAR ( c ) - element function; returns the value of the standard an integer type equal to the c character code from a supported operating system
symbol table systems. The type of parameter c is CHARACTER (1).
Explanation . In practice, the operating system can support non-ASCII character encoding. Access the system
the symbol table allows the ICHAR function. True, in Windows NT and Windows 95 character sequence 0 to 127 matches
with ASCII sequence. Therefore, only for characters with codes greater than 127 IACHAR and ICHAR may return different values.
Example. Display uppercase letters of the Russian alphabet, the codes of which in the system and ASCII tables do not match.
character (1) caps (32) / 'A', 'B', 'C', 'G', 'D', 'E', 'F', 'Z',
&
'I', 'Y', 'K', 'L', 'M', 'N', 'O', 'P', 'R', 'S', 'T', 'U', 'f', 'X', 'C', 'H',
'W', 'U', 'b', 'Y', 'b', 'E', 'Y', 'I' /
integer :: n = 0
​ ! Number of differences do i = 1, 32
​ !
Compare codes if (iachar (caps (i)) / = ichar (caps (i))) then
print *, '', i, caps (i) n = n + 1
end if
end do
if (n == 0) print *, 'No difference' end
&
73
74
O. V. Barteniev. Modern FORTRAN

ACHAR ( i ) - element function; returns a character like CHARACTER (1) whose code in the ASCII character code table is i (0 ≤ i ≤ 255). Type i is INTEGER
.
CHAR ( i [, kind ]) - element function; just like the ACHAR function, returns a character of type CHARACTER (1), the code of which is in the ASCII table of
character codes is i (0 ≤ i ≤ 255). Type i is INTEGER . In contrast from ACHAR, the CHAR function allows you to set the parameter value varieties of the
character type. True, currently symbolic type only exists with the flavor parameter KIND = 1. Value the result kind parameter matches kind if the parameter is
specified, and is equal to one otherwise.
Example. Display multiple characters of an 8-bit code by printing on a line of 15 characters. Recall that on 8 bits you can set the code for 256 characters with
code numbers from 0 to 255.
do i = 1, 255, 15 ​ ! Print all but null characters write (*, *) ('', char (j), j = i, i + 14) end do
 Comment. The IACHAR, ICHAR, ACHAR, CHAR functions are elemental, that is, their argument can be an array, for example:
integer (4) iabc (5)
character (1) :: ABC (5) = (/ 'A', 'B', 'C', 'D', 'E' /) iabc = ichar (ABC)
print *, iabc
​ ! 65 66 67
​ 68
​ 69 iabc = ichar ((/ 'a', 'b', 'c', 'd', 'e' /))
print *, iabc
​ ! 97 98 99
​ 100 101 end
LGE ( string_a , string_b ) - element function; returns .TRUE. if line string_a longer line string_b or equal to it, otherwise the result functions - .FALSE.
LGT ( string_a , string_b ) - element function; returns .TRUE. if line string_a longer line string_b , otherwise the result of the function - .FALSE.
LLE ( string_a , string_b ) - element function; returns .TRUE. if line string_a less line string_b or equal to it, otherwise the result functions - .FALSE.
LLT ( string_a , string_b ) - element function; returns .TRUE. if line string_a less line string_b , otherwise the result of the function - .FALSE.
Notes:
1. If the compared parameters have different lengths, then when comparing
their length is aligned by complementing a shorter parameterspaces to the right.
74
 75
Appendix 3. Data Organization
The comparison is performed character by character from left to right. Actually compares codes (ASCII) characters.
Parameters of functions LGE, LGT, LLE, LLT can be coordinatedarrays. In this case, the result can be assigned to a logical array consistent with the parameter
arrays.
Example. Remove surnames starting with the letter 'H' from the list or with subsequent letters of the alphabet.
character (len = 20) group (30) / 'Alferov', 'Saltykov', &
'Novikov', 'Vlaznev', 'Nikolaev', 25 * '?' / integer (2) i do i = 1, 30
if (lge (group (i), 'N')) then
​ write (*, *) group (i)
​ ! Saltykov
​ end if​ ! Novikov
end do
​ ! Nikolaev end
For completeness, note that the same result will be obtained and in the case of the usual operation of the relation '≥' - .GE. or> =:
if (group (i)> = 'H') write (*, *) group (i)
LEN ( string ) - help function; returns the length of string .
The result is of the standard integer type. Setting the string value to string not necessary. The string parameter can be a character array. In that If the function
returns the length of the array element.
Example:
character sta (20) * 15, stb * 20
​ write (*, *) len (sta), len (stb) ​ ! 15 20
LEN_TRIM ( string ) - element function; returns the length of the string string without trailing spaces. The result is of the standard integer type.
The string parameter can be a character array.
Example:
ADJUSTL ( string ) - element function; performs left alignment character string: removes all leading spaces and inserts them at the end lines like:
​ print *, adjustl ('banana') // 'nbc'
​ ! banana nbc
character (len = 20) :: stb = 'One more string' character (len = 20) st, st2 / '' /
write (*, *) 'Len_trim_stb =', len_trim (stb)
! Len_trim_stb = 15
write (*, *) len_trim (st), len_trim (st2)
! 20 0
write (*, *) len_trim ('It''sa string')
! thirteen
 75
76
O. V. Barteniev. Modern FORTRAN
ADJUSTR ( string ) - element function; aligns character right-aligned string by removing all trailing spaces and then inserting them at the beginning of the line, for
example:
print *, 'banana' // 'nbc'​ ! banana nbc print *, adjustr ('banana') // 'nbc'              ! banananbc
INDEX ( string , substring [, back ]) - element function; returns the position number at which the first occurrence of substring begins in string . The result is of the
standard integer type. If parameter
back is missing or specified with the value .FALSE., then search is on the left right. If back is .TRUE., Then the search is from right to left,
that is, starting at the end of the line. If substring string is not contained in string string , then the function will return 0. The position number is calculated in any case
from the beginning of the line.
Example:
character (120) sta / 'Snow, snow, snow, snow, snow over the taiga ...' /
​ print *, index (sta, 'snow')
​ ! 7
​ print *, index (sta, 'snow', .true.)
​ ! 25
REPEAT ( string , ncopies ) - transforming function; returns string containing ncopies of repetitions of string string (executes ncopies concatenation string ), such as:
character (10) st
​ st = repeat ('Na', 5)
​ ! NaNaNaNaNa

SCAN ( string, set [, back ]) - element function; returns number position of the first character of the set string found in string . If
the boolean parameter back is missing or specified with the value .FALSE., then the position of the leftmost such character is returned. If back is given with value
.TRUE., then the position of the rightmost such character is returned. The function returns 0 if string contains no string characters set . The result is of the standard
integer type.
Example:
integer array (2)
​ print *, scan ('Fortran', 'tr')
​ ! 3
print *, scan ('Fortran', 'tr', back = .true.)
​ ! five print *, scan ('FORTRAN', 'ora')              ! 0
array = scan ((/ 'fortran', 'visualc' /), (/ 'a', 'a' /))
​ print *, array
​ ! 6 5
​ Comment. ​ When the SCAN function is used with arrays,
the constants included in the array must have the same length. For aligning the length of constants should use spaces, for example:
array = scan ((/ 'fortran', 'masm' /), (/ 'a', 'a' /))
​ print *, array
​ ! 6 2
 76
77
Appendix 3. Data Organization
TRIM ( string ) - transform function; removes trailing spaces of the string , for example:
print *, 'banana' // 'nbc'
! banana nbc
print *, trim ('banana') // 'nbc'
! banananbc
VERIFY ( string , set [, back ]) - element function; returns 0 if every character in string is present in set . Otherwise returns the character position number of string
string that is not in set. The result is of the standard integer type. If the boolean parameter is back is missing or specified with the value .FALSE., then the position
of the left such character. If back is specified with the value .TRUE., Then the position of the rightmost such character, for example:
write (*, *) verify ('banana', 'nbc')
​ ! 2 write (*, *) verify ('banana', 'nbc', .true.)              ! 6 write (*, *) verify ('banana', 'nba')              ! 0
Notes:
Fortran 90 additionally includes functions: IACHAR, ACHAR,ADJUSTL, ADJUSTR, REPEAT and TRIM. All other symbolic features were available in Fortran
77.
Calling built-in functions can be done with keywords(section 8.11.4), for example: print *, verify ('banana', set = 'nbc', back = .true.) ! 6
Parameters of the element functions INDEX, SCAN, VERYFY in addition toscalars can be array and scalar or matched arrays. In that the result can be written to
an integer array, consistent with the parameter array.
Parameter of element functions ADJUSTL and ADJUSTR can alsobe and an array. In this case, the result can be written to a character array matched to the
parameter array.
Example:
character (4), dimension (2) :: st = (/ 'abcd', 'dab' /), ch * 1 / 'a', 'b' / character (7), dimension (2) :: ast = (/ 'abcd', 'dab' /), arst integer (4) p (2) p = index (st, 'a')
print '(2i4)', p
​ ! 12 p = index (st, ch)
print '(2i4)', p
​ ! thirteen print '(i4)', len (st) ​ ! 4 arst = adjustr (ast)
​ print *, arst​ ! abcd dab
 77
78
O. V. Barteniev. Modern FORTRAN
3.8.9. Select words from a line of text
Consider a common problem when working with strings: selection words from a given string. Consider the problem in the following formulation:
print each word of the text file on a separate line, counting that words are separated by one or more spaces. Such the formulation is simplified, since in the general
case delimiters between words can be combinations of punctuation marks and tab characters with spaces.
Let us explain the content of the problem with an example. Let the text file be named 'c: \ a.txt' and contains the text:
Alas, for different fun
I've ruined a lot of life!
Then the result of the program will be a sequence of words:
Alas, on various fun
I
...
The idea behind the word highlighting algorithm is simple: find the start position ( wb ) and the end ( we ) of the word in the string and select the word as a
substring: st ( wb : we ). Repeat this procedure until analyzed. all lines of text.
character (len = 20) words (100)! Array of text words
character (len = 80) st ​ ! Line of text integer j, wb, we, nw, lst
integer, parameter :: unit = 1
​ ! Device number to which open (unit, file = 'c: \ a.txt')              ! the file c: \ a.txt is connected ! Let's write all the words of the
text into the words array
nw = 0
! nw - the number of words in the
text
do while (.not. eof (unit))
! String Loop
read (unit, '(a)') st
! Entering a line of text
write (*, *) st
! Test output
lst = len_trim (st)
! Line length without trailing spaces
wb = 0
! wb - the beginning of the current
word in the line
! Let's look through all characters of the string st one by one .
! If a space is found, then the following cases are possible:
! a) the previous character is different from a space ( wb > 0), therefore,
! transition from the end of a word to the gap between words

 ! and, knowing the beginning ( wb ) and the end ( we ) of the current word, ! we can add a word to the words array .
! We use the addword subroutine for this .
! After adding the word, set wb to zero ( wb = 0);
! b) the previous character is a space - we go to
78
79
Appendix 3. Data Organization
! next character.
! If the current character is different from a space, then the following options are possible:
! a) we are at the beginning of a line or the previous character is
! space ( wb = 0);
! b) the previous character is different from a space ( wb > 0) - execute ! further movement on the current word.
do j = 1, lst​ ! Let's see all the characters of the string if (st (j: j) == '') then
if (wb> 0) call addword (words, st, wb, we, nw)
else if (wb == 0) then ​ ! Start of word detected wb
= j we = j
else
we = we + 1
​ ! Move on the current word end
if
end do
! After looking at the entire line, if the line was not
empty,
! we must add the last word to the words array if
(wb> 0) call addword (words, st, wb, we, nw)
end do close (unit)
write (*, *) 'Number of words in text nw =', nw do j
= 1, nw
write (*, *) words (j)
end do end
subroutine addword (words, st, wb, we, nw)
integer wb, we, nw
character (len = *) words (*) ​ ! Resizing array
character (len = *) st              ! String taking the
length nw = nw + 1 words (nw) = st (wb: we) wb =
0
end
3.9. Derived data types
3.9.1. Derived Data Declaration
Consider table. 3.3, containing examination marks.
Table 3.3. Examination marks of students
​ FULL NAME.
​ Exam 1
​
Exam 2
Exam 3
Exam
4
​ Aleksandrov V.M. 4
​ five
3
4
​ A.K. Vladimirov
​ 3
​ five
...
79
4
2
80
O. V. Barteniev. Modern FORTRAN
When working with a table, a number of tasks may arise: save the table in file; read data from a file; calculate the average grade of students;
find the best (worst) students, etc. At the same time, it is convenient when transferring data to a file and reading them from a file, operate with table rows, having
access to the individual elements of the string. In other words, with this approach, the table row should be an independent variable, consisting of several
changeable components. Such a variable in Fortran is a record.
A record is a variable of a derived ( structured ) data type.
Entries are entered by the TYPE operator or, as in FPS version 1, by the operator
RECORD.
A derived data type ( structure ) is one or more variable declarations (usually of different types) grouped under one name. The structure should be introduced in
the declaration section programs.
In Fortran 90, a derived data type is entered by an operator:
TYPE [, access-spec ] [::] name
 [PRIVATE | SEQUENCE] component decl [ component decl ]
...
END TYPE [ name ]
access-spec - defining a way to access a declared type
attribute (PUBLIC or PRIVATE). The PUBLIC and PRIVATE attributes can be used only when declaring a type in a module (Section 8.7). By the default access
method is PUBLIC (unless the module contains the PRIVATE statement without specifying a list of objects in it). Attribute setting
PUBLIC means the type and its not having the PRIVATE attribute components are available in all software units using
the module in which the derived type is defined. Setting the PRIVATE attribute means that the type and / or its components are available only in the module.
Moreover the type itself can have the PUBLIC attribute, and its components can have PRIVATE.
name - the name of the derived data type (structure); it shouldn't

match the name of another variable or function defined in that the same software component, also it cannot be the same as the name built-in data type, such as
COMPLEX. The structure name is local and therefore the structure as a type must be declared in each program unit in which the variables of the input
type. To reduce the cost of developing a program, it is recommended declare structures in separate modules, referring to them in the text program unit by the USE
operator.
80
81
Appendix 3. Data Organization
component decl - any combination of one or more statements
variable type declarations of the form:
type [[, attribute list ] ::] component list
The optional list of attributes may contain attributes POINTER and / or DIMENSION. Type declaration operators can contain scalars and arrays of built-in and
derived types. Wherein the TYPE and / or RECORD statements included in component decl must refer to previously defined derived types. Fortran 95 allows
statements included in component decl contain initial values variables. They will be the initial values  by default. the respective              components              of
all              objects              of this              type.
All or individual components can be initialized. For instance:
type entry
! 
Entry 
type
declaration
real (4) :: val = 3.0
! 
Val 
component
initialization
integer (4) :: index
! Initialization fails
type (entry), pointer :: next => null ()
end type entry type (entry) :: erray
(10)
! Next component
initialization
print *, erray (5)% val
! 3.000000
 If a derived type declaration contains the SEQUENCE attribute, then its components will be written to memory in the order they are declared in type.
This allows the use of derived type variables in common blocks, EQUIVALENCE statements, and as parameters to procedures.
Notes:
The variables included in the derived type are called itcomponents .
By default, a derived type declared in a module is available inany software unit using a module.
When defining a component of a derived type, there can beonly two attributes are used: POINTER and DIMENSION. Wherein if the component is declared with
the POINTER attribute, then it can refer to an object of any type, including an object of a declared derived type, eg:
type entry
real val integer index
! 
Entry 
type
declaration
type (entry), pointer :: next
end type entry
! Object reference of
type entry
The next standard will allow you to specify in derived typesplaced data objects.
81
82
O. V. Barteniev. Modern FORTRAN
After the introduction of the derived data type, objects (variables or constants) of a new type are declared by the operator: TYPE ( type-name ) [, attrs ] :: vname
type-name is the name of the derived type entered by the TYPE ...
END TYPE. attrs is one or more comma-separated vname attributes . vname - one or more comma-separated variable names
or constants called records . The name present in vname can be an array.
The TYPE statement, like other data declaration statements, precedes executable statements. The operator must be located after the introduction of the type-name
type .
The record is a compound variable. To access the component entry uses a component selector - percent symbol (%) or period (the latter is not possible with the $
STRICT directive): val = vname% cname or val = vname.cname
 where cname is the name of the recording component. If component cname is write, then to access the component cname you need twice apply
component selector: val2 = vname% cname% cname2 where cname2 is the name of the cname recording component . Etc.
Example:
integer, parameter :: n = 20
! We can use n inside
character (n) bname
! derived type declarations
type catalog
! Catalog Description
character (n) name, phone
! Name, phone
integer cat_id end type catalog
! Catalog code
type (catalog) boa
! Record announcement
boa = catalog ('JCP', '234-57-
22', 44)
! Structure constructor
bname = boa% name
! 
Accessing 
the 
recording
component
print *, bname, '', boa% phone
! JCP 234-567-22
Comment. The example shows that the given before the description of the derivative a named constant can be used in a declaration of that type, for example, to
set the length of a character string.
3.9.2. Initialization and Record Assignment
3.9.2.1. Derived type constructor
A variable of a derived type can be defined (assigned values all of its components) by applying a derived type constructor , also called the constructor of the
structure :
82

 83
Appendix 3. Data Organization
type-name ( expression list )
where the list of expressions specifies the value of the components of the variable.
The struct constructor can be used to initialize records in record declaration statements, in the DATA statement, in the assignments, in expressions (if operations are
overloaded) and as an actual parameter of the procedure.
A similar constructor is used to generate constants derived type:
type-name ( list of constant expressions )
Example. Let's form an order structure containing information about buyer's order. Each order can contain up to 10 items of things.
type item_d
! Description of the
ordered item
character (20) descr, color, size
! Name, color, size
integer (2) qty
! number
real (4) price end type
! Price
type order
! Order Description
integer (4) ordnum, cus_id
! 
Order 
number,
customer code
type (item_d) item (10)
! Variable of type
item_d
end type
! Write Specification - Constants
type (order), parameter :: e_ord = order (1, 1, item_d ('d', 'c', 's', 1, 1.0))
​ type (order) cur_ord
​ ! Variable of type order
! Using the structure constructor, add cur _ ord to the order
! 10 identical things
! One of the expressions in the order constructor is the item_d constructor cur_ord = order (1200, 300, item_d ('shorts', 'white', 'S', 1, 35.25))
​ print *, cur_ord% item (1)
​ ! Displaying data on the first item
! To display the color of a thing, you need to apply the component selector twice print *, cur_ord% item (2)% color! Outputting the color of the second item
Notes:
Since a variable of the item_d type is part of the order type , the type item_d must be entered before the description of the order type .
You can define the variable cur_ord by first defining array item (10). Let's do this in a record declaration statement:
type (item_d) :: item (10) = item_d ('shorts', 'white', 'S', 1, 35.25) type (order) cur_ord
cur_ord = order (1200, 300, item)
print *, item (1)
! Displaying data on the
first item
print *, cur_ord% ordnum
! Order number display
 83
84
O. V. Barteniev. Modern FORTRAN
3.9.2.2. Assigning Values  to Record Components
Let's continue working with the cur_ord variable just introduced derived type order :
! Assign a value to an individual record component
​ cur_ord% cus_id = 1300
​ ! Change the buyer's code
! Let's assign a value to the record component - an array element: cur_ord% item (2)% color = 'blue'              ! Change the color of the second item of the order !
Let's assign a value to the entire array - the write component: cur_ord% item% color = 'none'
If the record component is an array, then to define it you can use the array constructor (section 4.6), for example:
type vector
integer n integer vec (10)
end type
​ ! The j -th element of the vec array is assigned the value j * 2 type (vector) :: vt = vector (5, (/ (j * 2, j = 1, 10) /)) print *, vt.n, vt.vec (2)              !
5 4
3.9.2.3. Defined record assignments
You can change the value of a variable of a derived type by assigning its the value of another variable, constant, constructor, or expression of the same type.
However, the scope of inline assignment can be extend by linking to the assignment operator (=) via the IN- block TERFACE ASSIGNMENT modular or
external subroutine, which will be called every time the program encounters a given assignment (Section 8.12.2).
3.9.3. Derived Expressions
Unless special measures are taken, the built-in operations in expressions with records. You cannot, for example, add two records, using the built-in addition
operation. A measure that allows to extend an inline operation to a derived type, is
overloading operations (Section 8.12.2). To specify (overload) an operation a function is created that is linked using an interface block with the specified
operation. This function is called every time the specified operation is encountered, and returns for the subsequent use in an expression the result of this operation.
Example. Let's set the operation of multiplying a number by writing.
module deta
​ ! Define a derived type pair type pair
​ ! in deta module real x, y
end type pair end module
 84
85
Appendix 3. Data Organization
program paw
​ use deta
​ ! Accessing the pair type
​ interface operator (*)
​ ! To the external function setting the operation

function mu (a, b)
​ ! you must explicitly describe the interface use deta type (pair) mu type (pair), intent (in) :: b              ! Link type of master parameters
real, intent (in) :: a              ! function operation must be IN end function
end interface
type (pair) :: pt1 = pair (2.0, 2.0), pt2
​ pt2 = 2.0 * 2.5 * pt1
​ ! The first multiplication operation is built-in,
! the second is overloaded
print *, pt2 ​ ! 10.000000 10.000000 end program paw
​ function mu (a, b)
​ ! The function will be called every time
3.9.4. Recording as a parameter of a procedure
If the record is used as a parameter of the procedure and its type redefined in the procedure by the TYPE ... END TYPE statement, then when it is defined in
both the calling program unit and the procedure needs to set the SEQUENCE attribute. This will ensure the same arrangement of write components in memory.
(Order the placement of components in memory is determined at compile time.) If in the definition of a derived type there are other derivatives types, they must
also have the SEQUENCE attribute.
If a derived type is defined in a module, the SEQUENCE attribute redundant: modules are compiled separately and therefore in each a program unit receiving a
derived type definition
through use- association, the components of such a record will be placed in memory in the same way.
Example:
​ program gopo
​ ! Main program
​ type point
​ ! In the main program and pval functions
sequence
​ ! the same point type is defined real x, y
end type type (point) pt
use deta
! when the first operand of the operation *
type (pair) mu
! there will be an expression of type REAL,
type (pair), intent (in) :: b real, intent (in) :: a mu.x = a * bx mu.y = a * by end
function
! and the second is an expression of type pair
 85
86
O. V. Barteniev. Modern FORTRAN
call pval (pt)
print *, pt
​ ! 1.000000 -2.000000 end program gopo subroutine pval (pt)
type point sequence end typereal x, y
type (point) pt pt.x = 1.0 pt.y = -2.0
end subroutine
Two type definitions in different programming units define the same type, if both have the same name, have the attribute SEQUENCE, their components are not
private and agree in regarding their order, names and attributes. However, more a single description of the derived type in
module followed by a reference to the module in program units, using this type.
The SEQUENCE attribute must also be used when placing entries in the common -block, for example:
program gopo
type 
point
sequence real x, y
end 
type 
type
(point) pt real s, t
common / a / s, pt,
t call pval ()
print '(4f5.1)', s,
pt, t end program
gopo
subroutine pval ()
common / a / s, x,
y, t s = 2.0; t =
-1.0
! 2.0 1.0 -2.0 -1.0
x = 1.0
! x and y define components
y = -2.0 end
subroutine
! pt records of the main program
3.9.5. Recording as a result of a function
 The function result can be of a derived type, for example, external the mu function (Section 3.9.3) returns a value of type pair .
When defining an external function of a derived type, you should describe this type both inside the function and in every calling function software unit. It is best to
define the type in
86
87
Appendix 3. Data Organization
module and then use the use association. When explicitly defined type both in the function and in the program units calling it, you need using the SEQUENCE
attribute. The function itself should be declared in each program unit calling it.
If the derived function is internal , then this type can only be described in a program unit, from which this function is called. In this case, the type of the function is
determined only in the function itself, for example:
module deta type pair
real x, y
end type pair
end module deta program paw2

​ use deta
​ ! Accessing the pair type
type (pair) :: pt1 = pair (2.0, 2.0) type (pair) :: pt2
​ pt2 = mu (2.5, pt1)
​ ! Calling the inner function mu
​ print *, pt2 ​ ! 5.000000 5.000000
contains
​ function mu (a, b)
​ ! Internal function of type pair
​ type (pair) mu
​ ! Function type declaration
type (pair), intent (in) :: b real, intent (in) :: a mu.x = a * bx mu.y = a * by
end function mu
end program paw2
3.9.6. An example of working with derived data
Let's consider an example that illustrates the mechanism for transferring records from program to file and back from file to program. Let the file c: \ exam.dat
contains data about the results of the exam session student group. (To generate the file c: \ exam.dat in the program a random number generator is used.) Each
record of the file is row table 3.3. Display all records of the created file and average marks of students.
module tex
type exam
! Exam structure
character (30) name
! Student
integer (4) m1, m2, m3, m4
end type
! Exam marks
type (exam) stud
! stud is a variable of
type exam
integer :: unit = 2
! Connection device
number
87
88
O. V. Barteniev. Modern FORTRAN
end module tex
​ ! file c: \ exam.dat program aval
use tex
​ ! We include a description of the structure integer (4) :: ns = 20              ! Number of students in a group real (4) :: am = 0.0              ! Average
student grade
! Opening the binary
open (unit, file = 'c: \ exam.dat', form = 'binary')
call testfile (ns)
​ ! We fill the file exam.dat rewind unit
​ ! Go to the beginning of the file
do while (.not. eof (unit))
​ ! File data processing read (unit) stud am = am + stud% m1 + stud% m2 + stud% m3 + stud% m4
write (*, '(1x, a20, 4i4)') stud! Test output
end do close (unit) am = am / float (ns * 4) write (*, *) 'Average group score:', am end
subroutine testfile (ns)
 use tex
​ ! We include a description of the structure integer ns, i integer sv write (*, '(1x, a $)') 'Start random (INTEGER * 4):' read (*, *) sv call
seed (sv) do i = 1, ns
! The student's name is: Name number, for example, Name 01 write (stud% name, '(a, i3.2)') 'Name', i
stud% m1 = rmark ()
! We generate exam grades
stud% m2 = rmark ()
! Score - a random number
from 2 to 5
stud% m3 = rmark () stud% m4 = rmark ()
! The last 4 operators can be replaced with one:
! stud = exam (stud% name, rmark (), rmark (), rmark (), rmark ())
write (unit) stud
end do contains
! Add an entry to the file
integer function rmark ()
real (4) rnd
! Exam score generator
call random (rnd)
! rnd - a random number of REAL (4) type
(0.0 ≤ rnd <1.0)
rmark = nint (8.5 * rnd)
! Rounding
rmark = max (rmark, 2)
! The score cannot be less than two
rmark = min (rmark, 5)
end function
end
Explanations:
! The score cannot be more than five
88
89
Appendix 3. Data Organization
1. In Fortran, a structured variable can be written "entirely" both unformatted (binary) and text file (in earlier versions of Fortran in a text file, the record could only
be saved componentwise). When transferring stud to a text file, you can use, for example, such a formatted output (let the file be connected to device 3):
write (3, '(1x, a30, 4i3)') stud
The task for storing data is a serial binary file exam.dat. The transfer to the file is carried out in the testfile subroutine . Each file record looks like:
Name number Grade 1 Grade 2 Grade 3 Grade 4
The initial value of the number is 01. The line is an internal file; therefore, the easiest way is to get a string like Name number by writing to character variable stud%
name data 'Name', format number

 '( a , i 3.2)', where the number changes from 1 to ns . Each score is formed randomly in the range from 2 to 5 by the rmark function , which, in its
queue, uses a random number generator (0.0 to 1.0) - built-in RANDOM subroutine. Generated sequence of evaluations depends on the initial RANDOM
setting, which is determined by the value of the SEED subroutine parameter.
The $ symbol in the format specification of the WRITE operator (*, '(1 x , a $)') provides non-advancing output, which allows sv value to be entered on the same
line where the message ' Start random (INTEGER * 4):' is displayed .
The loop is exited when the end of the file is reached.
(The EOF function produces .TRUE.).
As a result of the program, the following lines will be displayed on the screen (the sequence of evaluations depends on the value of the sv parameter ):
Name 01 2 4 5 5
...
Name 20 3 5 5 4
To avoid repeating the structure description in the main programand the testfile subroutine , its description is carried out in a separate tex module , which is then
included in the program unit text by the USE statement.
3.9.7. Structures and records
3.9.7.1. Declaring and assigning values
Fortran CVF and FPS inherits one more from the previous versions the ability to declare a derived data type - the STRUC- operator
TURE, which, however, should not be used when writing a new code. Operator syntax:
89
90
O. V. Barteniev. Modern FORTRAN
STRUCTURE / structure name / declaration of structure components
END STRUCTURE
Structure name - the name of the new data type, it must not be the same with the name of another variable or function defined in the same software component;
also it cannot match the name built-in data type, such as COMPLEX.
Declaring structure components is any combination of one or several operators for declaring types of variables or constructs UNION. Type declaration statements
can contain simple variables, arrays, strings and RECORD statements that refer to previously defined structures. Structure members are declared without
attributes.
The structure name is local and therefore the structure as a type must be declared (either explicitly or as a result of the use- association) in each program unit in
which it is necessary to work with variables of the entered type.
 Structures, containing RECORD statement, are called nested . Nested structures can contain components with the same names.
The structure length cannot exceed 64 KB. Packing method structures in memory controlled by the $ PACK directive and the parameter
/ Zp on the compiler command line. The structures are the same if their components are of the same type and are placed in the structure in the same sequence. In
addition, they must have the same packing in the computer memory.
Variables of structured type are declared by the operator RECORD / structure name / [, attrs ] [::] vname
attrs and vname have the same meaning as in the declaration statement
derived type TYPE.
The structure name must be entered before using the RE- operator. CORD. The RECORD statement must precede executable operators of the software
component.
Example:
structure / item_d /
​ ! Description of the ordered item character * 20 descr, color, size! Name, color, size
integer * 2 qty
​ ! number real * 4 price ​ ! Price end structure
91
Appendix 3. Data Organization
end structure
​ record / order / cur_ord ! Variable of type order
cur_ord = order (1200, 300, item_d ('shorts', 'white', 'S', 1, 35.25))
print *, cur_ord.item (1)
​ ! Displaying data on the first item print *, cur_ord.item (2) .color! Outputting the color of the second thing
A record consists of components defined by the STRUCTURE. The write component is accessed by specifying
after the name of a structured variable (record) period or% sign and the name component, for example:
​ c_id = cur_ord.cus_id
​ ! Buyer code
i_color = cur_ord.item.color ​ ! Product color or
structure / order /
! Order Description
integer * 4 ordnum, cus_id
! Order number, customer
code
record / item_d / item (10)
! Variable of type item_d
90
 c_id = cur_ord% cus_id i_color = cur_ord% item% color
Record components do not differ from other variables that have the same type except one: an integer entry cannot be used as a dovar of a DO loop.
When working with text files, you can perform formatted or driven by a list of I / O of both the recording components and the entire recording.
3.9.7.2. Create associations
In a number of tasks, it is necessary to write to a file (or read from a file) consistently identical in size, but different in composition. Fortran has the ability to
perform these actions, working with one and the same structure. For these purposes, a structure should be set in which allowed different groups of data to occupy
the same memory area.
The data group is processed by the MAP operator. And the unification of groups and mapping to the same memory area is specified by the UNION operator.
Operators have the syntax:
MAP
structure member declaration
END MAP
UNION

map block map block [ map-block ...]
END UNION
 There must be at least two map blocks inside the union . Union block can only be inside a STRUCTURE statement. The map block can be only inside
the UNION operator. United map -blocks 91
92
O. V. Barteniev. Modern FORTRAN
must be the same size. An analogue of the containing unions structure, for example in Pascal, is a record with variant fields.
Example:
structure sam
union
map
character * 20 string
end map map
integer * 2 number (10)
end map
end union
end structure
3.9.8. Final remarks
Derived data type (structure) if you don't need to create concatenation, must be entered with the TYPE ... END TYPE statement using then to declare a record
(derived type variable) the operator
TYPE. The recording component, along with simple variables, can be and arrays and other records.
Records, along with strings and arrays, are compound variables. Records with rank 0 are scalars. You can also as with built-in data types, declare array records.
A record is considered undefined if at least one
​ its component.
​ Initialization
​ records,
​ creature              constant records,
assignment of a record to a value is done by means of a constructor structure that allows you to define or change the meaning of all recording components. In
addition, using a component selector, you can change the value of one element of the record. Individual recording components can be used in expressions in the
same way as other built-in objects types.
Records can be assigned the result of an expression of the same type.
The record can be "entirely" written in both binary and text (formatted) file (or read from such files).
A record or an array of records can be used as procedure parameter, but the type to which the record belongs is must be declared in both the calling program unit
and called procedure. When declaring a record-parameter type the SEQUENCE attribute is used. The same attribute is used for placing the entry in the common
block.
You can create a function that results in a record.
Using the INTERFACE OPERATOR, you can overload inline or create a new operation (unary or binary),
 92
93
Appendix 3. Data Organization
whose operands are records. Availability of such an opportunity improves the structure and reduces the program code.
Using the INTERFACE ASSIGNMENT statement, you can specify an assignment in which the components of a variable of a derived type by certain rules are
assigned the result of an expression of a different type.
3.10. Integer pointers
To access the memory occupied by variables, as well as free computer memory in CVF and FPS integer pointers are used.
An integer pointer is a variable containing an address some memory cell and associated with some variable called address variable . An integer pointer has 3
components:
the actual pointer, the associated address variable and the object the destination whose address contains the pointer. The target object can also be the cell
allocated by the MALLOC function. The task the pointer is done in two stages. The pointer is initially linked with an address variable. This is done through the
POINTER statement, having the syntax
POINTER ( pointer , varname ) [( pointer , varname )] ...
Example:
real var
​ pointer (p, var)
​ ! p is a pointer; var - address variable
An integer pointer is always of type INTEGER (4) and should not be declared explicitly. The address variable associated with it (scalar or array) can be of any
type.
The POINTER statement must be located in the declaration section program unit.
At the second stage, the pointer is set to the address of some object or memory location. In the first case, this is done by the LOC function, in the second -
MALLOC. For instance:
real var (5), a (5) pointer (p, var) p = loc (a)
An address variable is linked through a pointer to a memory area, address which is set to a pointer, and has two properties:
values  set in the address variable are placed to the address stored in the pointer and thus are transmitted the destination object;
the data stored at the address contained in the pointer is transferredinto the associated address variable.
 An example of the first property of an address variable: 93
94
O. V. Barteniev. Modern FORTRAN
real (4) a (5) /5*0.0/, var (5), wa
​ pointer (p, var) (p2, wa)
​ ! Let's declare two pointers p and pa and link the first
integer k
​ ! with the address variable var , and the second with wa p = loc (a)              ! Set pointer p to the beginning of array a var (2) = 0.5              ! Sets
also a (2) to 0.5 print '(10f5.1)', a              ! .0 .5 .0 .0 .0
An example of using a pointer with a character data type. Replace in the given string, every odd character starts with the letter b .
character (20) :: st = '1 # 2 # 3 # 4 # 5 # 6 # 7 # 8 # 9 #', ch * 1 pointer (p, ch) integer p0
p0 = loc (st)
​ ! Set p 0 to the address of the beginning of the string st do p = p0, p0 + len_trim (st), 2

ch = 'b'
! Each character in the string
takes 1 byte, so
end do
! use step 2 to navigate the odd
characters
print *, st
end
! b # b # b # b # b # b # b # b
# b #
An example of the second property of an address variable:
real (4) a (5) /1.0, 2.0, 3.0, 4.0, 5.0 /, wa pointer (p, wa)
var = -1.3 print '(10f5.1)', a
! All elements of array a are -1.3
! -1.3 -1.3 -1.3 -1.3 -1.3
p2 = loc (a) do k = 1, 5
! Set pointer p 2 to the beginning of array a
wa = float (k)
! In a ( k ) is set FLOAT value ( k )
p2 = p2 + 4
! Type a is REAL (4), so to go to the next
end do
! to an element of array a, execute p 2 = p 2 +
4
print '(10f5.1)', a
end
! 1.0 2.0 3.0 4.0 5.0
 integer p0 ​ ! The content is passed to the address variable wa p0 = loc (a)              ! the memory area pointed to by p print '(10f5.1)', (wa, p = p0,
p0 + 19, 4)              ! 1.0 2.0 3.0 4.0 5.0 end              ! Pointer p used as loop parameter
Pointer can be used as actual parameter a procedure in which its value can be changed. In general an integer pointer can appear wherever one can integer
variables are used. It should only be remembered that the pointer contains the address of the object, and make sure that after all changes to the pointer value, it
addressed the desired object or element of this object. An attempt to address a protected memory area results in runtime error.
Limitations:
94
95
Appendix 3. Data Organization
An address variable cannot be a formal parameter, a namefunction or element of a common block. The address variable cannot be initialize when it is declared or
in a DATA statement. Pointer not may appear in a type declaration statement and cannot be initialized in a DATA statement.
Operators ALLOCATE and DEALLOCATE cannot be usedwith integer pointers.
The pointer can be placed at the beginning of a fresh memory area, allocated by the MALLOC function. After use, allocated memory can be freed by the built-in
FREE routine.
Example. Form a memory area, entering into a byte at the address p 0 + k natural number k ( k = 0, 127, 1).
byte gk
integer k, size / 127 /, p0
pointer (p, gk)
​ ! The MALLOC function returns the starting address p0 = malloc (size)              ! allocated memory p = p0              ! Set pointer p to the
beginning of the selected
​ do k = 0, size
​ ! memory
​ gk = int (k, kind = 1)
​ ! The value gk is entered into the cell with the address p
​ p = p + 1
​ ! Move to next byte of memory
​ end do
​ ! Memory view
print '(10i3)', (gk, p = p0, p0 + 5)! 1 2 3 4 5 6
call free (p0)
​ ! The FREE subroutine releases the allocated end              ! MALLOC memory function
Integer pointers are CVF and FPS extension over
Fortran 90 and 95 standards, and therefore can be operated with
the absence of the $ STRICT directive or the / 4Ys compiler option. Basically integer pointers are intended to provide access to an arbitrary computer memory
area accessible from the program.
Comment. Fortran integer pointers are similar to SI pointers.
The order of transmission of integer pointers in a SI function and reception SI pointers in the Fortran procedure are considered in [1].
3.11. Links and destinations
Memory for a variable can be allocated at compile time or while the program is running. Variables receiving memory at compile time are called static . Variables,
receiving memory at the stage of program execution are called dynamic .
Links are dynamic variables. Allocating memory for a link is executed either when it is placed with the ALLOCATE statement, or after
95
96
O. V. Barteniev. Modern FORTRAN
attaching it to the posted destination. In the latter case, the link occupies the same memory as the addressee.
3.11.1. Declaring links and addressees
To declare a link (variable with the POINTER attribute) the attribute or operator POINTER is used, which of course should not mix with the integer pointer
declaration operator. Addressee may be:
attached link;
a variable that has the TARGET attribute (declared with the
TARGET or in a statement of the same name);
fresh memory area allocated by the ALLOCATE statement.
References and addressees can be both scalars and arrays of any built-in or derived type.
Example:
! Declaring using attributes
integer (4), pointer :: a, b (:), c (:, :)
! Declaring links
integer (4), target, allocatable :: b2 (:)
! 
Destination
announcement

integer (4), target :: a2
 ! Declaration using the POINTER and TARGET operators integer (4) d, e, d2 / 99 /
pointer d, e​ ! Declaring links target d2
​ ! Destination announcement
3.11.2. Attaching a link to recipients
To attach a link to the addressee, use the => operator. After attaching a link to the addressee, you can refer to the addressee using link name. That is, the link can
be used as a second name (alias) of the addressee.
Example:
integer, pointer :: a, d, e
​ ! Declaring links integer, pointer, dimension (:) :: b
integer, target, allocatable :: b2 (:) ​ ! Announcement of addressees integer, target :: a2, d2 = 99
allocate (b2 (5))
​ ! Allocating memory for the destination array a2 = 7
=> a2
​ ! Attaching a link to a recipient b2 = (/ 1, -1, 1, -1, 1 /)              ! Changing the link results in
=> b2
​ ! change of addressee, and change of addressee b = (/ 2, -2, 2, -2, 2 /)              ! leads to link change print *, b2              ! 2 -2 2 -2 2 b2 = (/ 3,
-3, 3, -3, 3 /)
​ print *, b
​ ! 3 -3 3 -3 3
96
97
Appendix 3. Data Organization
a => d2
! Now reference a is attached to
d 2
d => d2; e => d2
! Several links are attached to
one destination
print *, a, d, e
! 99 99 99
a = 100
! Changing a will cause everyone
to change
! objects associated with a
print *, a, d, e, d2
! 100 100 100 100
deallocate (b2)
! Freeing up memory
nullify (b) end
! Zeroing a link
You cannot attach a link to a recipient that has not received memory, eg:
integer (4), pointer :: b (:)
integer (4), allocatable, target :: b2 (:)
b => b2
​ ! Incorrect link attachment allocate (b2 (5))
​ ! to unplaced addressee b2 = (/ 1, -1, 1, -1, 1 /) print *, b
 If an object has TARGET or POINTER attributes, then in some cases its subobject has the same attributes. So if the TARGET attribute (POINTER)
has the entire array, then the section of the array occupying a contiguous region in memory, and the array element has the attribute TARGET (POINTER), for
example:
integer, target :: a (10) = 3 integer, pointer :: b (:), bi
​ b => a (1: 5)
​ ! Link and addressee are completely identical
! The operator of attaching a link to an irregular section is wrong
! an array with target: b => a (1: 5: 2)
​ bi => b (5) ​ ! Array element also has POINTER attribute
​ print *, b
​ ! 3 3 3 3 3
However, a substring of a string that has the TARGET or POINTER attributes is does not possess these attributes, for example:
character (len = 10), target :: st = '1234567890' character (len = 5), pointer :: ps2
​ ps2 => st (: 5)
​ ! Error
If the addressee is a link, then there is a direct copy links. Therefore, the addressee in the link attachment operator can be arbitrary specified by the index triplet
(Section 4.5) section of the array links. The section specified by the vector index itself cannot be the addressee of the link. For instance:
character (len = 80), pointer :: (:), part (:), line, st * 10 allocate ( (25)) part => part => (5: 15: 3)              ! It would be a mistake if
97
98
O. V. Barteniev. Modern FORTRAN
! had a TARGET attribute
line => (10)
! Array element also has POINTER
attribute
st => (2) (20:29)
! Error: substring does not have
POINTER attribute
If the destination link is not defined or is detached, then it is copied link status. In all other cases, addressees and links become identical (occupy the same memory
area).
Link type, type parameters and rank in the link attachment operator must be the same as that of the addressee. If the reference is an array, then it takes the form of
the addressee. Moreover, the lower bound is always is one, and the top is the extent size of the destination array. For instance:
integer, pointer :: a (:) integer, target :: i, b (10) = (/ (i, i = 1, 10) /)
real, pointer :: c (:), d (:), g (:) real, target :: e (5) logical sta
c => e d => e
! Attaching links c and d to the addressee
sta = associated (c)
! In the first three cases, sta is .TRUE.
sta = associated (c, e)
! in the latter - .FALSE.
 ! The lower bound of the array a is one, the upper one is three a => b (3: 10: 3) print *, (a (i), i = 1, size (a))              ! 3 6 9
This property of links allows you to replace the frequently used link with a link. section and refer to its elements using in each of its dimensions indices from 1 to n ,
where n is the number of section members in the dimension.

The link can be attached during program execution alternately to different addressees. Several links can have one addressee. The fact of attaching a link to the
addressee can be found by by applying the ASSOCIATED help function having the syntax: result = ASSOCIATED ( link [, addressee ])
The destination parameter is optional. If the destination parameter is absent, then the function returns .TRUE. if the link is attached to any addressee. If the target is
specified and has the TARGET attribute, then the function returns .TRUE. if the link is attached to the target.
The function will also return .TRUE. If both the link and the target have an attribute POINTER and attached to the same destination. In all other cases the function
returns .FALSE .. The value returned by the function has standard boolean type.
Example:
sta = associated (c, d) sta = associated (g)
98
 99
Appendix 3. Data Organization
3.11.3. Link initialization. NULL function
The link can be initialized using the NULL function:
real (4), dimension (:), pointer :: pa => null ()
The NULL function gives the link the status "not associated with the target". This status allows, for example, to use the link as the actual parameter before attaching
it to the destination, for example:
program null_test
real (4), dimension (:), pointer :: pa => null () interface
subroutine poas (pa) real (4), dimension (:), pointer :: pa
end subroutine poas
end interface
call poas (pa)
​ ! Parameter - unattached link print *, pa (2)              ! 3.500000
end program null_test subroutine poas (pa)
real (4), dimension (:), pointer :: pa allocate (pa (5)) pa = 3.5
end subroutine poas
The NULL function can be used among executable operators:
pa => null ()
3.11.4. Explicit detach of a link from the addressee
The link can be detached from the target using the NULLIFY operator:
NULLIFY ( pname )
pname is a list of reference variables or structure components, which should be detached from their addressees. All list items must have a POINTER attribute. For
instance:
integer, pointer :: a (:), b, c (:,:, :)
...
nullify (a, b, c)
In addition to detaching from the target, the NULLIFY operator can use to initialize (zero) the link. Is not a mistake unpinning an unattached link.
 The NULLIFY operator does not release the target. In other words, if the destination of the link is the memory allocated by the ALLOCATE
statement, then after unpinning the link, the memory is not released and remains inaccessible if only one link was attached to memory. 99
100
O. V. Barteniev. Modern FORTRAN
Unavailable memory is not formed if pre-memory released by the DEALLOCATE statement. For instance:
integer, pointer :: c (:,:, :)
...
allocate (c (2, 5, 10))
...
deallocate (c) nullify (c)
The same danger of the formation of an inaccessible memory area exists and when reassigning a link to another addressee using the operator link attachments =>.
For example, in the following fragment, inaccessible memory:
integer, pointer :: a (:) integer,
target :: b (5)
...
allocate (a (5))
...
! Reference a is allocated memory
a => b
! The memory allocated earlier for
reference a becomes
...
! unavailable for later use
In the following snippet, the link reassignment is done without losing memory:
allocate (a (5))
...
​ deallocate (a)
​ ! Freeing up memory. Memory available for
​ a => b
​ ! subsequent use
...
Note that after executing the DEALLOCATE statement, the state links becomes undefined and can be defined either in
as a result of joining to another addressee, or as a result of zeroing in the NULLIFY statement.
3.11.5. Self-referenced structures
A derived type component can have a POINTER attribute and at the same time refer to a variable of the same or a different derivative type:
type entry
real val integer index
! 
Entry 
type
declaration

type (entry), pointer :: next
end type entry
! Object reference of
type entry
This property allows you to use links to form coherent lists. Let's take a one-way list as an example,
representing a data structure, each element of which contains two
 100
101
Appendix 3. Data Organization
parts - fields with data and a field with the address of the next data item list. The address used to access the next item
called a pointer . The first element of the list is called the top list . The last element of the list contains a null pointer. A unidirectional list with records of the same
length can be represent in the form of fig. 3.2.
Figure: 3.2. Unidirectional list scheme with records of equal length
We will develop program formation and editing unidirectional list. Let, in addition to the field with the pointer, each the list item contains two more fields, one of
which is ( index ) used to index the elements of the list. Editing
consists of two operations: adding and removing an element from
​ unidirectional
​ list.
​ Scheme
​ adding
​ element              at
The unidirectional list is shown in Fig. 3.3, and offsets are shown in Fig. 3.4.
New item
... ... ...
Figure: 3.3. Scheme for including an element in a unidirectional list
... ... ...
The element to be removed
Figure: 3.4. Scheme for removing an item from a unidirectional list
From the given figures it is easy to write down the algorithms for the formation the list and its modifications.
 101
102
O. V. Barteniev. Modern FORTRAN
Algorithm for forming a list of n elements (formatted as internal subroutine newtree ):
°. Beginning (the list is formed starting from the last element).
°. Zero the address of the last element of the tree list - NULLIFY ( tree ).
°. With the parameter k = 1, n execute:
Allocate memory for the In the field with the address of the top element top. element, enter the address of the element, added at step k - 1, i.e., the address of the
vertex tree . (Thus, every newly added element (except the last item in the list) will point to the previous one.) Move the top of the list to the last added element, by
doing tree => top .
end of cycle 3 °.
°. The end.
Below is the text of a program that allows you to form a list from a given number of elements, view and edit it.
module eni ​ ! Entry description module type entry
real val integer index
type (entry), pointer :: next
​ ! Link that can be attached end type entry              ! to a variable of type entry
end module eni
program one_d_li​ ! Formation, viewing use eni ​ ! and editing the list
type (entry), pointer :: tree, top, current, newtop
 
​ call newtree ()
​ ! The list has been formed; top links
! to the last element of the list
call wali (top)
​ ! List view tree => top ​ ! Move to the top of the list call chava (5)              ! Change the val field of two adjacent ones
​ call wali (top)
​ ! List view
call delem (7)
​ ! Exclude from the list the element with index = 7 call wali (top)              ! List view
tree => top
call insel (700.0, 8)
​ ! Insert element after element with index = 8 call wali (top)              ! List view
contains
subroutine newtree ()
​ ! List creation integer i
nullify (tree)
​ ! We reset the end of the list. At the end of the list ! ASSOCIATED ( tree ) will return .FALSE.
​ do i = 1, 10​ ! List formation cycle
! Place a new list item and add information
! into data fields
102
103
Appendix 3. Data Organization
allocate (top)
! The top link contains
as
top = entry (11.0 * i, i, tree) ! component link tree
tree => top
! Set the list pointer to
end 
do 
end 
subroutine
newtree
! newly added item
subroutine wali (top)
type (entry), pointer :: top
! 
Browse 
the 
list
starting at top
tree => top
! Attach tree link to top
do while (associated (tree)) ! List view loop

print *, tree% val, tree%
index
current => tree% next tree
=> current end do
! Move to next item
read * end subroutine wali
! Waiting for Enter
subroutine delem (ind)
! Removing an item
from the list
integer ind tree => top
do while (associated (tree))
​ if (tree% index == ind) then ​ ! The next element has index = 7
! Attach the element pointer with index = in to the element pointer
! with index = in + 2, thereby eliminating the element with index = in + 1 if (associated (tree% next)) then current => tree% next tree% next => tree% next% next
​ deallocate (current)
​ ! Freeing memory after an exception
end if​ ! item from the list exit
end if
current => tree% next tree => current
end do
end subroutine delem subroutine insel (val, ind)
​ ! Adds an item to the tree list integer ind real val
do while (associated (tree))
if (tree% index == ind) then
allocate (newtop)
newtop = entry (val, ind - 1, tree% next) tree% next => newtop if (tree% index> 1) then
newtop% next => tree% next% next
else
! When pasting after
the last
nullify (newtop% next) end
if
! the element we
reset the link
103
104
O. V. Barteniev. Modern FORTRAN
exit
end if
current => tree% next tree => current
end do
end subroutine insel
subroutine chava (ind)
! Now let's change the value of the
element field
integer ind
do while (associated (tree)) if
(tree% index == ind) then
! list with index = ind and index =
ind - 1
tree% val = 500
! The val field of the list item with
index = ind
tree% next% val = 400 exit
end if
current => tree% next tree
=> current
end do
end subroutine chava end
program one_d_li
! The val field of the list item with
index = ind - 1
Notes :
In general, list items are located in free memory
 Computer in an arbitrary way. Therefore, such lists are sometimes called sparse vectors.
Using references as components of a derived type, you cangenerate circular, bi-directional lists and more complex data structures.
3.11.6. References as procedure parameters
The link can be a formal parameter of a procedure. In this case the actual parameter must also be a reference. The ranks of the actual and formal reference
parameters must match. When calling procedures, the binding state of the actual parameter is passed formal, and, conversely, upon completion of the procedure,
the state the binding of the formal parameter is passed to the actual one. However, with exit, the addressee may become undefined if, for example, in the process
the procedure works the link has been attached to a local variable, not having the SAVE attribute.
In the case of a modular or internal procedure, the compiler knows whether the formal parameter is a reference or not. In the case of external procedure, the
compiler must explicitly indicate that the formal the parameter is a link. This is achieved by specifying an explicit interface. For a formal reference parameter, it is
not allowed to specify the INTENT attribute, which sets the link type of the parameter.
104
105
Appendix 3. Data Organization
Example:
real, pointer, dimension (:) :: a,
a2 interface
subroutine pab (b, b2)
real, pointer :: b (:), b2 (:)

end
end interface
! When calling the procedure, the
binding state is
call pab (a, a2)
! the formal parameter is passed to
the actual
print '(10f5.1)', a
! 1.0 2.03.0 4.05.0
​ print '(10f5.1)', a2
​ ! .0 .0 .0 .0 .0
print *, associated (a), associated (a2)! TT end
subroutine pab (b, b2)
real, pointer, dimension (:) :: b, b2 integer k
real, target, save :: c (5) real, target, automatic :: c2 (5) c = (/ (1.0 * k, k = 1, 5) /) c2 = (/ (1.0 * k, k = 1, 5) /)
 b => c
​ ! After exiting due to lack of c 2 attributes b2 => c2              ! SAVE link destination a 2 will be undefined end subroutine pab
If the actual reference parameter matches the formal parameter that is not a link, then the link-parameter must be attached to the addressee, which will be
associated with the formal parameter.
Example:
integer, pointer :: a (:) integer,
target :: c (5) = 2
a => c
! Destination c of the actual
reference parameter a
call pab (a, size (a))
! associated with a non-link
! formal parameter b of subroutine
pab
print *, a
! 7 7 7 7 7
print *, c end
! 7 7 7 7 7
subroutine pab (b, n) integer n, b (n)
b = b + 5
end subroutine pab
3.11.7. Parameters with the TARGET attribute
The actual procedure parameter can have the TARGET attribute. In this case, the links attached to such a parameter are not are attached to the corresponding
formal parameter, and remain
105
106
O. V. Barteniev. Modern FORTRAN
related to the actual parameter. If the formal parameter has a TARGET attribute, then any link attached to it (if
only it is clearly not detached from the addressee) remains undefined when exit the procedure. To a procedure whose formal parameter has the TARGET attribute,
an explicit interface must be organized. So internal and modular procedures have an interface, acquire it and external procedures after their description in the
interface block, located in the calling software unit (Section 8.11.3).
3.11.8. Links as a result of a function
The function can have the POINTER attribute. In this case, the result function is a link and you can attach another link to it. Such using a function is advisable if, for
example, the size of the result depends on the calculations in the function itself.
When entering a function, the result reference is initially undefined. Inside function, it must be attached to the target or defined via the NULLIFY operator as
detached.
 A reference to a function reference can be made from an expression. In that case, the destination of the result link must be defined and its value will
be used when evaluating the expression. Also function-link can be a referenced structure constructor component.
The topic "links" is closely related to the topic "arrays", so further We will defer the consideration of links to the next chapter.
Example. Get array a from non-negative numbers in array c .
integer, pointer :: a (:)
integer :: c (10) = (/ 1, -2, 2, -2, 3, -2, 4, -2, 5, -2 /)
​ a => emi (c)
​ ! Attaching a link to the function result
​ print *, a
​ ! 1 2 3 4 5
! Using a reference function in an expression
print *, 2 * emi (c)
! 2 4 6 8 10
contains
! The internal procedure
has
function emi (c)
! 
an 
explicitly 
defined
interface
integer, pointer :: emi (:)
! The result of the function
is a link
integer c (:), i, k
! c - an array taking shape
k = count (c> = 0)
! k - number of non-
negative elements
allocate (emi (k)) ​ ! Attaching a link to the addressee emi = pack (c, mask = c> = 0)! We put in the link non-negative end function emi              ! elements of array
c end
Notes:
1. If the function emi is designed as external, then in the calling program you will need a block with an interface to this function, because, firstly, it
 106
107
Appendix 3. Data Organization

returns a link, and secondly, its formal parameter is reshaping array.
2. The built-in functions COUNT and PACK are shown in Sec. 4.12.1 and 4.12.4.2.
 107
108
4. Arrays
An array is a named collection of a finite number of objects of one type. The objects (elements) of the array can be data as basic, and derived types. Using the
PARAMETER attribute, you can set array constant. Unlike simple variables designed for storing individual values, an array is a compound variable.
Objects of symbolic and derived types also belong to composite ones.
Arrays, just like derived objects, provide access to a set of data using one name,
which is called the name of the array . Also the array name is used for providing access to an element or a group of elements (section) of an array.
Arrays can be static or dynamic . Under static arrays at compile time are allocated a given amount of memory, which deals with the array for the entire lifetime of
the program. Memory it is allocated for dynamic arrays during program operation and when need can be changed or released. To dynamic arrays include
referenced arrays, placeable and automatic arrays. The latter can only appear in procedures.
Memory for reference arrays is allocated either as a result of the ALLOCATE statement, or after attaching a link to an already the placed destination object.
Allocated arrays get memory only after the execution of the ALLOCATE statement.
4.1. Array declaration
An array is characterized by the number of dimensions, which may not be more than seven. The number of dimensions of an array is called its rank . Number
elements of an array is called its size . Also the array is characterized by form , which is determined by its rank and length ( extents ) array along each dimension.
Operator
real b (2, 3, 10)
declares an array b of rank 3. The size of the array is 2 * 3 * 10 = 60. Form array - (2, 3, 10).
Each dimension of the array can be specified by the lower and upper border, separated by colons, for example:
real c (4: 5, -1: 1, 0: 9)
The rank, shape and size of arrays b and c are the same. Such arrays are called consistent .
Lower bound followed by colon when declaring an array can be omitted, then the default lower bound is accepted
 108
109
4. Arrays
equal to one. Array declaration is done on type declaration or the DIMENSION, ALLOCATABLE, and POINTER statements. Also an array can be declared in
a COMMON statement. Here are the various ways to declare a static one-dimensional array of an integer type of 10 elements.
You can use the type declaration operator:
​ integer a (10)
​ ! or a (1:10)
Let's set the boundaries as a constant expression (which is recommended):
integer, parameter :: n = 10 integer a (1: n)
We now use the DIMENSION attribute:
integer, dimension (10) :: a
and then the DIMENSION statement:
integer a dimension a (10)
The above static one-dimensional array declarations define an array a of 10 objects (elements) named a (1), a (2), ..., a (10). Layout of array a elements in
computer memory is shown in Fig. 4.1.
Cell
memory
​ a (1) a (2). ... ...
​ a (10)
Figure: 4.1. Arrangement of array elements in computer memory
Record a ( i ) refers us to the i- th element of the array a. Variable i called an index variable or just an index .
A dynamic one-dimensional array can be declared by applying ALLOCATABLE or POINTER statements:
real a, b
allocatable a (:)
! 
Dynamic 
array
dimensions
pointer b (:)
! are given by a
colon (:)
or the ALLOCATABLE or POINTER attributes:
real, allocatable :: a (:) real, pointer :: b (:)
When declaring a static array, can be done its initialization: integer a (10) / 1, 2, 3, 4, 4, 4, 5, 5, 5, 5 / or using a repetition rate:
 109
110
O. V. Barteniev. Modern FORTRAN integer a (10) / 1, 2, 3, 3 * 4, 4 * 5 / or using the DATA operator:
integer a (10)
data a / 1, 2, 3, 3 * 4, 4 * 5 /
or using an array constructor:
integer :: a (10) = (/ 1, 2, 3, 4, 4, 4, 5, 5, 5, 5 /) or using a circular list in the array constructor:
integer :: i, j, a (10) = (/ 1, 2, 3, (4, i = 4, 6), (5, i = 7, 10) /)
In all the above examples, after initializing the array a
a (1) = 1, a (2) = 2, a (3) = 3, a (4) = 4, a (5) = 4, a (6) = 4, a (7) = 5, a (8) = 5, a (9) = 5, a (10) = 5.
During initialization, it is necessary that the number of constants in the list values  was equal to the number of array elements. Using in the operator DATA implicit
loop, you can initialize part of the array.
One operator can declare more than one array. For example, the operator real b (-3: 3) /7*1.0/, g2 (6: 8) ! Array g 2 undefined
declares two one-dimensional arrays - an array b of seven elements with names b (-3), b (-2), ..., b (3) and an array g 2 of three elements named g 2 (6), g 2 (7),
g 2 (8). All elements of array b are equal to 1.0.

Example. Find the sum of the elements of a one-dimensional array.
 real b (-3: 5) /1.1, 2.2, 3.3, 4.4, 5.5, 4 * 7.8 /, s s = 0.0 do k = -3, 5
s = s + b (k)
end do
​ write (*, *) 's =', s
​ ! s = 47.7
! The same task is accomplished using the built-in SUM function: write (*, *) 's =', sum (b)              ! s = 47.7
The declaration of a two-dimensional array is performed in a similar way:
integer b (2, 4)
​ ! Static array of eight elements real, pointer :: c (:, :)              ! Dynamic array reference
The first declaration defines a two-dimensional array b of eight elements named b (1,1), b (2,1), b (1,2), b (2,2), b (1,3), b (2,3), b (1,4 ), b (2,4). The two-
dimensional array b (1: 2, 1: 4) can be represented in the form of a table (Fig.4.2), containing 2 rows and 4 columns.
110
111
4. Arrays
j
​ 1
​ 2
​ 3
​ 4
​ i
​ 1
​ b (1, 1)
​ b (1, 2)
​ b (1,
3)
​ b (1, 4)
​ 2
​ b (2, 1)
​ b (2, 2)
​ b (2, 3)
​
b (2, 4)
Figure: 4.2. Representing a two-dimensional array as a table
Computer memory is one-dimensional, so the elements of two-
dimensional array b are arranged in memory in a line as shown in
Fig. 4.3.
​ 1
​ -1
​ 2
​ -2
​ 3
​ -3
​
4
​ -4
Cell
memory
​ b (1, 1)
​ b (2, 1)
​ b (1, 2)
​ b (2, 2)
​ b (1, 3)              b (2, 3)              b (1, 4)              b (2, 4)
Figure: 4.3. Arrangement of elements of a two-dimensional array in computer memory
The notation b ( i , j ) refers us to the j- th element of the array in its i- th row, where i and j are indices of array b.
In many programming languages, for example, in C, the elements two-dimensional array are located in the computer memory line by line, in Fortran
- by columns, that is, the first index of the array changes faster. In more general case in Fortran for a multidimensional array when placing its elements in the
computer memory, the pattern of change in indices can be display with a nested loop (for example, a three-dimensional array a (2, 4, 6):
do k = 1, 6
do j = 1, 4
​ do i = 1, 2 ​ ! Index i changes fastest
memory allocation of an element named a ( i , j , k ) end do end do
end do
In other words, when placing a multidimensional array in the computer memory the fastest change is the leftmost index of the array, then the next followed by an
index, etc.
This fact should be taken into account during I / O and initialization. multidimensional array. In the case of a two-dimensional array, the enumeration values  will
result in column-wise initialization (matching element the value is shown in fig. 4.3):
integer b (2, 4) / 1, -1, 2, -2, 3, -3, 4, -4 /
String initialization can be done with the DATA statement:
data ((b (i, j), j = 1, 4), i = 1, 2) / 1, -1, 2, -2, 3, -3, 4, -4 /
111
112
O. V. Barteniev. Modern FORTRAN
or in an array constructor with proper use of the RE-
SHAPE:
integer :: b (2, 4) = reshape
((/
&
eleven
2 -2
​ &
3 -3
4 -4 /), shape = (/ 2, 4 /),
order = (/ 2, 1 /))
Example. Find the product of positive elements of a two-dimensional array.
real b (-2: 1, 6: 8) /1.1, 2.2, 3.3, 4.4, 5.5, 7 * -1.1 /, p integer i, j p = 1.0 do j = 6, 8
do i = -2, 1
if (b (i, j)> 0) p = p * b (i, j) end do
end do
​ write (*, *) 'p =', p
​ ! p = 193.2612
! You can use the built-in PRODUCT function to calculate the product:
p = product (b, mask = b> 0.0)
​ write (*, *) 'p =', p
​ ! p = 193.2612
 Comment. The order of placing the elements of a multidimensional array follows take into account when organizing nested loops. So the cycle
do j = 6, 8
do i = -2, 1
if (b (i, j)> 0) p = p * b (i, j)
end do
end do
will run faster than a loop
! We iterate over the elements of the next
column of the array

do i = -2, 1
do j = 6, 8
! Unnatural order of iteration
if (b (i, j)> 0) p = p * b (i, j)
end do end do
! array b
This is due to the fact that in the first case in the inner loop provides a natural and therefore more productive sequence of access to array elements.
The array index can be an integer expression:
real :: b (5, 10) = 5.1 real :: a (5, 5), c (30), r = 7.0
c (int (r) * 2 + 1) = 2.0 ​ ! Array index is an integer expression a (1, 2) = b (int (c (15)), int (sqrt (r)))
​ write (*, *) a (1, 2), b (2, 2)
​ ! 5.100000 5.10000
112
113
4. Arrays
When declaring an array in addition to defining dynamic arrays the ALLOCATABLE and POINTER attributes and the array shape setting attribute
DIMENSION attributes INTENT, OPTIONAL,
PARAMETER, PRIVATE, PUBLIC, SAVE and TARGET.
4.2. Arrays of size zero
An array, just like a string, can be of zero size. Is always, when the lower bound exceeds the corresponding upper bound, array has size 0. For example:
real b2 (0, 15), d (5, 20, 1: -1)
​ print *, size (b2), size (d)
​ ! 0 0
Arrays of size zero are always considered to be defined and when use are subject to normal rules.
4.3. Simultaneous declaration of objects of different shapes
If necessary, you can declare objects with one operator different shapes. So, the operator
real, dimension (10) :: a, b, b2 (15), d (5, 20)
 declares arrays a and b of form (10), array b 2 of form (15) and array d forms (5, 20). That is, the priority when using the DIMEN-
SION possesses an explicit description of the shape of an array.
Operator
integer na, nb, a (10), d (5, 20) declares scalars na and nb and arrays a and d of different shapes.
4.4. Array elements
In this section, we will summarize the concept of an array element. Array can contain elements of built-in and derived data types:
type order ​ ! Order Description integer ordnum, cus_id character (15) item (10)
end type
! Examples of arrays of character and derived type
character (20) st (10) / 10 * 'T-strings' /
​ ! st - array of strings type (order) cord, orders (100)              ! orders - an array of orders
The above descriptions define the arrays st , orders , cord % item and orders ( k )% item ( k is an integer and 0 ≤ k ≤ 100). Array elements are scalars.
Examples of array elements:
st (7), orders (15), cord% item (7), orders (10)% item (8)
113
114
O. V. Barteniev. Modern FORTRAN
One more data object can be retrieved from the character array substring, for example:
print *, st (7) (1: 6)
​ ! T-stri or
character (15) itord
orders = order (2000, 455, (/ ('Item', k = 1, 10) /)) itord = orders (10)% item (8)
​ print *, itord (3: 4)
​ ! em
However, the substring contained in the character array is by convention is not considered an array element.
In general, an array element is a scalar of the form private pointer [% private pointer ...]
where the private pointer is private name [( index list )]
 If a private pointer is an array name, then it must have list of indices, for example orders (10)% item (8). Number of indices in each the list of indices
must be equal to the rank of the array or array - component derived type. Each index must be integer scalar an expression whose value lies within the
corresponding bounds array or component array.
4.5. Section of an array
You can access not only a single element of the array, but also to a certain subset of its elements. Such a subset array elements is called array slicing . The section
of the array can be obtained by applying an index triplet, or vector index , which are substituted instead of one of the array indices.
The index triplet looks like:
[ lower limit ]: [ upper limit ] [: step ]
Each of the parameters of the triplet is an integer expression. The step of changing the indices can be both positive and negative, but cannot be zero. All
parameters of the triplet are optional.
An index triplet specifies a sequence of indexes in which the first element is equal to its lower border, and each subsequent element is greater (less) the previous
one by the step size. The sequence contains all index values  specified by this rule lying between
triplet boundaries. If the lower border is greater than the upper one and the step
 114
115
4. Arrays
is positive or the lower limit is less than the upper one and the step is negative, then the sequence is empty.
Example:
real a (1:10)
a (3: 7: 2) = 3.0
! Triplet defines a section of an array
with elements

! a (3), a (5), a (7), which will get the
value 3.0
a (7: 3: -2) = 3.0
! Elements a (7), a (5), a (3) will get
the value 3.0
In the absence of the lower (upper) border of the triplet, its value
accepted equal meaning bottom (top) boundaries the corresponding extent of the array. So, a (1: 5: 2) and a (: 5: 2) define one and the same the same section of
the array a , consisting of elements a (1), a (3), a (5). Section from elements a (2), a (5), a (8) can be specified as follows: a (2: 10: 3) or a (2 :: 3).
Example:
real a (10), r /4.5/
a (2 :: 3) = 4.0
! Elements a (2), a (5), a (8) will get
the value 4.0
a (7: 9) = 5.0
! Elements a (7), a (8), a (9) will get
5.0
a (:) = 3.0
! All elements of the array will be
set to 3.0
a (:: 3) = 3.0
! Section of elements a (1), a (4), a
(7), a (10)
a (:: int (r / 2)) = 3.0
! Triplex parameter - integer
expression
print *, size (a (4: 3))
! 0 (section of zero size)
! SIZE function returns the size of
an array
The lower border of the triplet cannot be less than the lower border the corresponding extent of the array. So, it is wrong to set the section a (-2: 5: 3) in array a
(1:10). The upper limit of the triplet should be like this so that the last element of the sequence given by the triplet is not exceeded the upper bound of the
corresponding array extent. For instance, in the array a (1:10), the section a (3: 12: 5) is allowed . The upper bound of the triplet must always be present when
using a triplet in the last the dimensions of the array taking over the size (Section 4.9.3).
substitution of the index triplet (however, as well as the vectorIn the case of a multidimensional array, the section can be specified by index) instead of one or more
indexes, for example:
real a (8, 3, 5) a (1: 4: 2, 2: 3, 4) = 4.0
In a given section in the first dimension, the index can take the values  1 and 3, in the second - 2 and 3, and in the third - only 4. Thus, section provides access to
elements a (1, 2, 4), a (1, 3, 4), a (2, 2, 4) and a (2, 3, 4). Since the index is fixed in the third dimension of the section, then the section is a two-dimensional array
with the shape (2, 2).
 115
116
O. V. Barteniev. Modern FORTRAN
Special cases of sections of a two-dimensional array are its rows and columns like:
integer a (5, 8)
a (3, :) = 3
! Section - the third row of the
matrix
a (:, 4) = 7
! Section - the fourth column
of the matrix
Example. Which row of the matrix contains a given number k most often .
integer, parameter :: m = 3, n = 5 integer :: a (m, n), b (m), i, k = 2, km (1)
a = reshape ((/
1, 2, 2, 4, 3,
&
2, 4, 2, 8, 2,
&
-2, 2, 6, 2, 2 /), shape = (/ m, n /), order = (/ 2, 1 /))
do i = 1, m
! We write the number of occurrences
k in string i in
b (i) = count (a (i, :) == k)
! array b . The section a ( i , :) is
end do
! i- th line of the array
km = maxloc (b)
print *, 'Lines with k =', k, 'occur the most times' do i = 1, m
if (b (i) == b (km (1))) print *, 'String', i end do end
Comment. Array b can be formed without using a loop:
​ b = count (a == k, 2)
​ ! The COUNT function is discussed in section. 4.12.1.
The vector index is a one-dimensional integer array, containing the values  of the indices that fall into the section of the original array, eg:
real a (20), b (10,
10)
integer :: vi (3), vj
(2)
! vi , vj - integer arrays;
vi = (/ 1, 5, 7 /)
! used as vector indices
vj = (/ 2, 7 /)
! for specifying sections of arrays a and b
a (vi) = 3.0
! a (1), a (5), a (7) will get 3.0
b (2, vj) = 4.0
! b (2, 2), b (2, 7) - value 4.0
b (vi, vj) = 5.0
! b (1, 2), b (1, 7), b (5, 2), b (5, 7),
! b (7, 2) and b (7, 2) - value 5.0

A vector index, unlike an index triplet, allows you to extract into a section an arbitrary subset of array elements. The values indices must be within the bounds of
the corresponding dimensions of the original array. Index values  in a vector index can be in any order and can be repeated. For instance:
real a (10, 8) / 80 * 3.0 /, b (5) b = a (3, (/ 5, 3, 2, 7, 2 /))
 116
117
4. Arrays
The array b will contain the values  of the elements of the section of the array a : a (3, 5), a (3, 3), a (3, 2), a (3, 7) and again a (3, 5).
Sections with duplicate index values  cannot appear on the right side of the assignment statement and in the input list of the READ statement. For example the
assignment
real a (10)
a (/ 5, 3, 2, 7, 2 /) = (/1.2, 1.3, 1.4, 1.5, -1.6 /) not valid since 1.4 and -1.6 cannot be stored in a (2) at the same time .
The section size is zero if the vector index is zero the size.
Section of an array with a vector index cannot be internal file, the addressee of the link. If the section of an array with a vector index is the actual parameter of the
procedure, then it is considered
as an expression and the corresponding formal parameter must have communication type INTENT (IN). When using the given vector index section as an actual
parameter in the procedure a copy is made of this section, which is addressed by the corresponding formal parameter.
Section of an array (specified by an index triplet or vector subscript) retains most of the properties of the array and maybe in in particular, used as a parameter to
built-in functions for arrays, element and reference functions, and custom procedures.
Example. Find the sum of the positive elements of the main diagonal square matrix.
integer, parameter :: n = 10 integer :: a (n, n) / 100 * 3.0 /, i integer :: b (n * n)
integer :: v (n) = (/ (i + n * (i - 1), i = 1, n) /)
(9, 9) = -1
​ ! v is a vector index containing
= reshape (a, shape = (/ 100 /))
​ ! main diagonal element numbers
! array a ; b ( v ) - section of array b
​ print *, sum (b (v), mask = b (v)> 0)
​ ! 27
Using sections allows you to more efficiently solve problems for which DO-cycles were previously used (Section 7.5).
Example. Change the order of the array elements.
integer :: i, a (10) = (/ (i, i = 1, 10) /) a = a (10: 1: -1)
​ print '(10i3)', a
​ ! 10 9 8 7 6 5 4 3 2 1
 The section, in addition to the cases considered, can be taken from arrays derived types, and also contain arrays - components of structures and
substrings of character arrays. General view of the section of the array: 117
118
O. V. Barteniev. Modern FORTRAN private pointer [% private pointer ...] ... [( substring range )]
where the private pointer is private name [( section index list )]
The number of section indices in each list must equal the rank
array or array - component of the structure. Each section index must be either an index , an index triplet , or a vector index , for example:
real a (8, 5, 5)
​ a (4, 1: 4: 2, (/ 2, 5 /)) = 4.0
​ ! 4 - index; 1: 4: 2 - index triplet;
! (/ 2, 5 /)) - vector index
A non-zero rank private pointer determines the rank and shape of the section. Section size is zero if at least one of the extents of the private pointer is zero.
A substring range can only be present if the last private pointer is of character type and is a scalar or has a list of section indices .
An example of a section consisting of array substrings:
character (len = 20) st (10) / 10 * 'Test String' / print *, st ((/ 1, 3, 10 /)) (5: 8)              ! Str Str Str print *, st (2: 6: 2) (5: 8)              ! Str Str Str
Section of an array whose name ends with the name of the component structure is also a component of the structure .
 An example of sections containing arrays - structure components:
type order
! Order Description:
integer (4) ordnum, cus_id
! 
order 
number,
customer code
character (15) item (10) end type
! order items list
type (order) cord, ords (100) cord% item
(2: 6) = 'dress' ords (5: 7: 2)% item (7) =
'tie' ords (9)% item ((/ 1, 8, 9 /)) =
'blazer' ords (9)% item ((/ 8, 9 /)) (8: 9) =
'20'
! ords - an array of
orders
print *, cord% item (3), ords (5)% item
(7)
! dress tie
print *, ords (9)% item (1), ords (9)% item (8)! blazer blazer 20
A section formed from arrays - structure components cannot contain more than one non-scalar object. So, trying to create a section kind
ords (5: 7: 2)% item ((/ 1, 8, 9 /)) = 'none' will cause a compilation error.
The private name to the right of the private pointer must not have an attribute POINTER. So, you cannot set the section list (1: 15: 2)% ival in this example:
118
119
4. Arrays
type wip
real val
integer, pointer :: ival
end type wip
type (wip) elem, list (20)
allocate (elem% ival)

!
Right
allocate (list (5)% ival)
!
Right
allocate (list (1: 15: 2)% ival)
!
Error
4.6. Assigning arrays
As shown above, an array can be defined by initialization in type declaration statements or in a DATA statement.
Also, the values  of the array elements can be changed by assigning to the array or its section is the result of the expression. The operand of such an expression can
be an array constructor . For instance:
real b (5), pi /3.141593/
integer a (5)
b = tan (pi / 4)
! Assigning the value of an expression to
an entire array
b (3) = -1.0
! Assigning a value to the third element
of an array
write (*, '(7f5.1)') b
! 1.0 1.0 -1.0 1.0 1.0
a = 2 * (/ 1, 2, 3, 4, 5 /)
! Array constructor as an operand of an
expression
write (*, *) a
! 2 4 6 8 10
The array constructor defines a one-dimensional array and looks like: (/ list-of-values /)
Spaces between parentheses and slashes are not allowed .
A value-list can contain a sequence of scalars, implicit loops and arrays of any rank. The values  in the list are split commas and must be of the same type and
variety of type. Each the list value can be the result of an expression.
The implicit loop of an array constructor is:
( expression | implicit loop , dovar = start , stop [, inc ]) dovar is an integer scalar variable (loop parameter).
start , stop , inc are integer constant expressions that define
dovar range and step . If inc is absent, then step is set to one.
Implicit loop adds to list of values
MAX ( stop - start + INT ( inc / inc ), 0) elements. The expression can contain dovar . Organization possible nested implicit loops.
If a multidimensional array appears in the list, then its values  are taken in the order of their placement in the computer memory. The array constructor allows
generate one-dimensional array values. When setting values
119
120
O. V. Barteniev. Modern FORTRAN
multidimensional array should be obtained using the constructor one-dimensional array of required size, and then apply the function
RESHAPE and write the data into the given form. Number of items in the list values must match the size of the array.
Example 1. The elements of the list are arrays and a simple scalar.
integer b (7), c (2, 3), i, j integer a (3) / 3, 2, 1 /
b = (/ a, a, mod (a (1), 2) /)
​ ! The list is one-dimensional array and scalar write (*, '(10i3)') b              ! 3 2 1 3 2 1 1
data ((c (i, j), j = 1, 3), i = 1, 2) / 3 * 1, 3 * 2 /
b = (/ c, -1 /)
​ ! The list contains a two-dimensional array and a scalar write (*, '(10i3)') b              ! 1 2 1 2 1 2 -1
Example 2. List items are implicit loops.
integer a (5), i, k real :: r (7)
real, parameter :: pi = 3.141593 logical fl (10) a = (/ (i, i = 1, 5) /)
​ write (*, *) a
​ ! 1 2 3 4 5
r = (/ (cos (real (k) * pi / 180.0), k = 1, 14, 2) /)
 write (*, '(10f5.1)') r
​ ! 1.0 1.0 1.0 1.0 1.0 1.0 1.0 fl = (/(.true., k = 1, 5), (.false., k = 6, 10) /)
​ write (*, *) fl
​ ! TTTTTFFFFF
Example 3 . Assigning values  to a two-dimensional array.
integer a (5, 2), i, j
​ ! List items in constructor of array b integer b (3, 4)              ! nested implicit loops a = reshape (source = (/ (2 * i, i = 2, 11) /), shape =
(/ 5, 2 /)) b = reshape ((/ ((i * j, i = 1,3), j = 3, 6) /), shape = (/ 3, 4 /)) write (*, '(10i3)') a write (*, '(4i3)') ((b (i, j), j = 1, 4), i = 1, 3)
Result:
​ 4 6
​ 8 10 12 14 16 18 20 22
​ 3 4
​ five
​ 6
6 8 10 12
9 12 15 18
Example 4 . A mixture of implicit list and simple values.
integer a (10), i
a = (/ 4, 7, (2 * i, i = 1, 8) /)
​ write (*, '(10i3)') a
​ ! 4 7 2 4 6 8 10 12 14 16
In addition to using the RESHAPE function in the array constructor, assigning values  to a multidimensional array can also be done, sequentially applying several
array constructors, each time defining a linear section of the array, for example:
120
121
4. Arrays
integer b (2, 3), i, j
b (1, :) = (/ (i, i = 2, 6, 2) /)
​ ! Let's assign values  to the first row b (2, :) = (/ 5, 81, 17 /)              ! Let's assign values  to the second row write (*, '(3i3)') ((b
(i, j), j = 1, 3), i = 1, 2)

Result:
2 4 6
5 81 17
Besides the assignment, the array can be changed when doing
I / O operators (you can output data to an array, since it is internal file (Section 10.3), as well as when using an array in as the actual parameter of the procedure.
4.7. Assignment masking
4.7.1. WHERE operator and clause
In Fortran, you can, using the WHERE operator or clause, perform the assignment only to those array elements whose values satisfy some conditions. For
instance:
integer :: b (5) = (/ 1, -1, 1, -1, 1 /) where (b> 0) b = 2 * b
 
​ print *, b
​ ! 2 -1 2 -1 2
Fortran 77 uses a loop for this
do k = 1, 5
if (b (k) .gt. 0) b (k) = 2 * b (k) end do
The syntax for the WHERE clause is:
WHERE ( boolean expression - array ) array assignment WHERE clause syntax:
WHERE ( boolean expression - array ) array assignment operators
END WHERE
WHERE ( boolean expression - array ) array assignment operators
ELSEWHERE
array assignment operators
END WHERE
Initially, the value of a logical expression - an array - is calculated . Its result is a boolean array called arraymask , under the control of which the selective
assignment of arrays . This selective assignment is called masking the assignment . Since the mask array is formed before
121
122
O. V. Barteniev. Modern FORTRAN
assignments to arrays, then no ones performed in the body WHERE changes over arrays included in boolean expression array are not passed to array-mask.
Arrays present in WHERE must have the same shape.
Attempt to execute in the body of a statement or WHERE clause assigning a scalar or arrays of different shapes will result in an error compilation.
Values  are assigned to those following the WHERE elements arrays for which the corresponding mask array element is
.TRUE. If the value of the array-mask element is .FALSE. and if in WHERE clause is ELSEWHERE, then assignment of array elements following ELSEWHERE,
corresponding in order to the element of the mask array.
Example:
 integer :: a (10) = (/ 1, -1, 1, -1, 1, -1, 1, -1, 1, -1 /) integer :: b (-2: 7) = 0
where (a> b)
b = b + 2
elsewhere b = b - 3 a = a + b
end where
! Arrays a and b of the
same shape
print '(10i3)', a
! 1 -4 1 -4 1 -4 1 -4 1
-4
print '(10i3)', b
end
! 2 -3 2 -3 2 -3 2 -3 2
-3
Element functions present in the WHERE body are evaluated under the control of the array-mask, i.e. at the time of the assignment. For instance,
real :: a (5) = (/1.0, -1.0, 1.0, -1.0, 1 /) where (a> 0) a = log (a)
will not throw an error since the built-in element function natural logarithm calculations will only be called for positive array elements. The next snippet also
syntactically correct:
real :: a (5) = (/1.0, -1.0, 1.0, -1.0, 1.0 /) where (a> 0) a = a / sum (log (a))
but will result in a runtime error since masking is not extends to non-element functions and SUM calculation function the sum of the array elements will be executed
before the statement is executed WHERE. In other words, the above snippet is similar to the following:
real :: a (5) = (/1.0, -1.0, 1.0, -1.0, 1.0 /), s integer k
123
4. Arrays
s = sum (log (a))
! When calculating the amount, an error occurs due
to
do k = 1, 5 if (a (k)> 0) a (k) = a (k) / s end do
! attempts to find the logarithm of a negative number
 122
You cannot transfer control to the body of the WHERE clause, for example, through the GOTO statement.
Fortran 95 has expanded the capabilities of the WHERE construct. Now she may include an ELSEWHERE statement ( boolean expression - array ).
An example . In the vector a, add the number 2 to the positive elements, to negative - number 3, and to equal to zero - number 4.
integer :: a (9) = (/ 1, 2, 3, -1, -2, -3, 0, 0, 0 /) where (a> 0)
a = a + 2
elsewhere (a <0)
a = a + 3
elsewhere a = a + 4 end
where
! This feature is added by the
1995 standard.
print '(10i3)', a
end
! 3 4 5 2 1 0 4 4 4
In addition, in CVF, the WHERE clause can have a name, used in the same way as a name in a DO or IF construct. This CVF capability is an extension over the
standard.

4.7.2. FORALL operator and construct
The FORALL operator and construct, along with slicing arrays and operator and WHERE clause are used to selectively assignment of arrays. FORALL can
replace any assignment
sections or WHERE. But the possibilities of FORALL are wider: the operator and
especially with FORALL you can make assignments
inconsistent arrays, that is, arrays of different shapes. Like WHERE and FORALL sections replace loops with array assignments, for example instead of a loop
do i = 1, 100
d (i, i) = 2 * g (i) end do better use
forall (i = 1: 100) d (i, i) = 2 * g (i)
124
O. V. Barteniev. Modern FORTRAN
Construction syntax:
[ name :] FORALL ( triplet specification
&
[, triplet specification ] ...
[, mask expression ]) operators construction FORALL
END FORALL [ name ]
&
 Operator syntax:
FORALL ( triplet specification
&
[, triplet specification ] ...
[, mask expression ]) assignment operator
123
&
the triplet specification is:
index = triplet
where triplet is a triplet: [ lower bound ]: [ upper bound ]: [ step ].
Each of the parameters of the triplet is an integer expression. The parameter step of changing the indices can be both positive and negative, but cannot be equal to
zero; step if missing, taken equal to one. All parameters of the triplet are optional. In expressions specifying the lower, upper boundaries triplet and its step, there
should be no index references. Evaluation of any expression of a triplet must not affect the result of its other expression.
the index is an integer scalar. Index Scope - Operator
or FORALL. After FORALL completes, the index value undefined.
mask expression - boolean expression - array; with absence
is assumed to be .TRUE .. Contains, as a rule, the names of the indexes, eg:
forall (i = 1: n, i = 1: n, a (i, j) / = 0.0) b (i, j) = 1.0 / a (i, j)
Variable, which in the assignment statement are assigned values, must be an element of the array or its section, and must contain the names of all indexes included
in the triplet specification.
The right side of an assignment operator cannot be of character type.
name is the name of the FORALL construct. statements of the FORALL construct are:
an assignment operator with the properties discussed above;
operator or WHERE clause;
operator or FORALL construct.
The statements present in FORALL are executed for those values indices specified by index triplets, at which the expression the mask is calculated with the value
.TRUE ..
 In a DO loop, statements are executed immediately on each iteration. FORALL works differently: the right-hand side is evaluated initially expressions
for all iterations and only then assignment is performed. Then the same is true for expressions with sections, for example:
integer (4), parameter :: n = 5
integer (4), dimension (n) :: a = 1
! 
Declare 
and
initialize array a
124
125
4. Arrays
integer (4) :: k
do k = 2, n ​ ! Let's do the assignment in a loop a (k) = a (k - 1) + 2
end do
print *, a
​ ! 1 3 5 7 9 a = 1 ​ ! FORALL assignment forall (k = 2: n) a (k) = a (k - 1) + 2
​ print *, a
​ ! 1 3 3 3 3
a = 1 ​ ! Using an expression with slices a (2: n) = a (1: n-1) + 2
​ print *, a
​ ! 1 3 3 3 3
None of the array elements can be changed in FORALL more once.
be clean.Any procedure called in a FORALL mask expression must
Any WHERE construct or clause can be replaced with FORALL, the opposite is not true. An example is the operator
forall (i = 1: n, j = 1: n) h (i, j) = 1.0 / real (i + j)
in which the elements of the expression are mutable indices, which not valid for WHERE.
Example 1: type monarch
integer (4), pointer :: p
end type monarch
type (monarch), dimension (8) :: pattern integer (4), dimension (8), target :: object forall (j = 1: 8) pattern (j)% p => object (1 + ieor (j - 1, 2))
This FORALL statement attaches items with reference numbers 1-8 pattern to elements 3, 4, 1, 2, 7, 8, 5, and 6, respectively, of the target object . The built-in
IEOR function can be used as it, like all built-in procedure is clean.
Example 2 . Using the named construct FORALL.
ex2: forall (i = 3: n + 1, j = 3: n + 1)

(i, j) = c (i, j + 2) + c (i, j - 2) + c (i + 2, j) + c (i - 2, j)
(i, j) = c (i, j)
​ ! Array d is assigned the computed
​ end forall ex2
​ ! in the previous statement, the elements of the array c
Example 3 . FORALL statements that are not replaced with sections or WHERE.
real (4), dimension (100, 100) :: a = 1.0, b = 2.0 real (4), dimension (300) :: c = 3.0 integer (4) :: i, j
forall (i = 1: 100, j = 1: 100) a (i, j) = (i + j) * b (i, j) forall (i = 1: 100) a (i, i) = c (i)
 125
126
O. V. Barteniev. Modern FORTRAN
Note that in the latter case, FORALL provides access to the diagonals of the matrix, which cannot be done using array slices.
​ Example 4 . Vector a is formed from sums of the form              
 xi (,              m = ) ,, 2.1...              n ...
program vec_a integer (4), parameter :: n = 10 integer (4) i ! Initializing array x :
real (4) :: x (n) = (/ (i, i = 1, n) /), a (n) ! Array x after initialization: ! 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 10.0 forall (i = 1: n) a (i) = sum (x (1: i))
​ print '(1x, 10f5.1)', a (1: n)
​ ! 1.0 3.0 6.0 10.0 15.0 21.0 28.0 36.0 45.0 55.0
end program vec_a
Comment. The FORALL operator and construct are introduced by the Fort standard.
wounds 95.
4.8. Dynamic arrays
4.8.1. POINTER and ALLOCATABLE Attributes
When using static arrays in front of the programmer always there is a problem of setting their sizes. In some cases this problem has no satisfactory solution. So, if
the array contains
 positional designations of elements of a printed circuit board or integral circuits, then depending on the complexity of the designed device may an
array of 10 to 1000 or more elements is required. In such case, it is better to use dynamic arrays, the sizes of which can be set and changed while the program is
running. In Fortran there are 3 types of dynamic arrays: reference arrays, allocated arrays and automatic arrays.
Dynamic reference arrays are declared with the POINTER attribute, which can be specified either in a type declaration statement, or through the POINTER
operator. Allocated arrays are declared with the ALLOCATABLE attribute, which is specified either in the declaration statement type, or through the
ALLOCATABLE statement.
Automatic arrays are created in procedures, and their size defined when calling the procedure.
Memory for reference arrays and allocated arrays can be highlighted by the ALLOCATE statement. Recall that the array allocated reference by the ALLOCATE
statement, memory is called the target of the reference. The referenced array also gets memory after attaching it to the already to the addressee having memory
(Section 3.11.2). For instance:
126
127
4. Arrays
real, pointer :: a (:), c (:), d (:) ! One-dimensional reference arrays
integer, allocatable :: b (:, :)              ! Two-dimensional allocable
array real, allocatable, target :: t (:)              ! Allocated destination
array real a3
allocatable a3 (:,:, :)
​ ! ALLOCATABLE statement real, target ::
t2 (20)              ! Static destination array allocate (a (10), a2 (10 *
2), a3 (2, 2, 5), b (5, 10), t (-30: 30))
c => t
​ ! Attaching links to dynamic d => c
​ ! previously
received memory addressees c => t2              ! Attaching a link to a
static destination
4.8.2. ALLOCATE and DEALLOCATE statements
The ALLOCATE statement creates link destinations and arrays,
specified with the ALLOCATABLE attribute. Operator syntax:
ALLOCATE ( var | array ( shape_spec_list )
&
[, var | array ( shape_spec_list )). [, STAT = ierr ]) var - the name of the link being hosted, which can be a component
structures.
array - the name of the referenced array or the array being allocated, which can
be a component of the structure.
shape_spec_list - a list of the form ([ lo :] up [, [ lo :] up ] ...]) specifying the shape
the allocated array. The number of pairs defining the boundaries of the dimension must match the rank of the allocated array or reference array. Lo parameters and
up are integer scalar expressions and define respectively, the lower and upper bounds of the length along
corresponding dimension of the array. If the lo : parameter is omitted, then by By default, the lower bound is assumed to be one. If up < lo , size array is zero.
STAT is a parameter that allows you to check whether the place the array. Any failure if STAT is not specified results in to a runtime error and program halt. The
parameter is indicated in the ALLOCATE statement last.
ierr is an integer status variable that returns 0 if
placement was successful; otherwise the code is returned placement errors like:
integer, allocatable :: b (:, :) integer m / 5 /, n / 10 /, ierr allocate (b (m, n), stat = ierr) if (ierr .ne. 0) then
write (*, *) 'Error allocating array b. Error code: ', ierr stop end if
127
128
O. V. Barteniev. Modern FORTRAN
The cause of the error could be, for example, insufficient memory or attempt to place previously allocated and not released by the operator
DEALLOCATE object.
The ALLOCATE statement allocates memory and shapes the array, or the addressee of the link. To free allocated for the allocated array memory uses the
DEALLOCATE statement. After freeing memory the array being allocated can be re-allocated with new or old size.

Since the order of memory allocation is not regulated, then array shape spec cannot include reference function
array that has an array argument of the same ALLOCATE statement. So, wrong operator allocate (a (10), b (size (a))) ! Wrong
Instead, two operators should be specified:
allocate (a (10))
​ allocate (b (size (a)))
​ ! Right
If the STAT = parameter and the ierr status variable are present is dynamic, then its placement must be performed in another, preceding the ALLOCATE
statement.
 Changing the variables used to set the bounds of the array, after executing the ALLOCATE statement will have no effect on the specified borders.
For instance:
n = 10
allocate (a (n: 2 * n))
! Placing array a (10:20)
n = 15
! The shape of the array a
does not change
The array being placed can have the statuses "not posted", "posted" and "not defined". Attempt to address an array with the status "not allocated" leads to
unpredictable results. To determine if posted an allocated array, the built-in function ALLOCATED is used, returning a standard boolean value equal to .TRUE., if
the array is allocated, and .FALSE. - otherwise. (Recall that for the ASSOCIATED function is used to determine the link status.) For instance:
real, allocatable :: b (:, :) real, pointer :: c (:, :) integer :: m = 5, n = 10 allocate (b (m, n), c (m, n)) if (allocated (b)) b = 2.0 if (associated (c)) c = 3.0
When using a hosted array as local variable of the procedure, before exiting the procedure, execute
128
129
4. Arrays
freeing the memory allocated for it (otherwise the array being allocated will acquire the "undefined" status):
subroutine delo (n)
integer n, ierr
integer, allocatable :: ade (:) allocate (ade (n), stat = ierr) if (ierr / = 0) stop 'Allocation error'
...
deallocate (ade)
end subroutine delo
A module-declared allocable array after placement in the program unit using the module has the status "located" in any other using (after placing the array) this
module software unit. For instance:
module wara
integer n
 integer, allocatable :: work (:, :) end module wara
program two
use wara
call rewo ()
! Allocating memory for the work
array
work = 2
! The work array is located in the
rewo subroutine
print *, work (5, 5) call delo
(4)
! 2
print *, work (5, 5)
end program two subroutine
rewo ()
use wara
print '(1x, a \)', 'Enter n:' read
(*, *) n
allocate (work (n, 2 * n))
end 
subroutine 
rewo
subroutine delo (k)
use wara integer k
! 4
work (5, 5) = k
! You don't need to post work ,
because
end subroutine delo
! it is placed in the rewo subroutine
References have the same property, i.e. if in the last example declare a link in the wara module
integer, pointer :: work (:, :)
then the destination allocated to it in the rewo subroutine will be available in the main program, and in the subroutine delo .
129
130
O. V. Barteniev. Modern FORTRAN
Attempting to place an already allocated array always results in error. However, the attached (previously posted) link can be reposition, with the result that it
attaches to a new one, to the destination created by the ALLOCATE statement, for example:
real, pointer :: a (:)
allocate (a (10))
! Link placement a
allocate (a (20))
! Attaching reference a to another
memory area
However, such re-placement of the link will create unused and unavailable memory. To avoid this, you should link reassignment execute statement
deallocate (a)

The DEALLOCATE statement releases the allocated by the ALLO-
CATE memory and has syntax
DEALLOCATE ( a-list [, STAT = ierr ]) a-list - a list of one or more names of allocated objects
 (arrays, array references, or simple references), separated by commas.
All elements of the list must have been previously placed with the ALLO-
CATE or, in the case of references, must have a created ALLO-
CATE destination. The addressee in the a-list of the link must be the complete object (for example, the target of the DEALLOCATE link being released is not can
be a section, an array element, a substring). Recall that unpinning a link that was not created by the ALLOCATE statement destination is performed by the
NULLIFY operator.
STAT is an optional parameter that allows you to control whether the memory was freed. Any failure if no parameter is given STAT, causes an execution error and
stops the program. Parameter STAT should appear last in a statement.
ierr is an integer variable that returns 0 if memory succeeded
release; otherwise, an error code is returned. If ierr is a dynamic variable, then it cannot be freed using the DEALLOCATE statement.
Trying to free an unplaced object will throw an error execution.
If the DEALLOCATE statement released the array with the TARGET attribute, then the status of the link connected to the array becomes vague and can only be
consulted after
attachments to another object.
Example:
integer, allocatable :: ade (:) real, pointer :: ra, b (:)
​ allocate (ade (10), ra, b (20)) ​ ! Arrays ade and b
 130
131
4. Arrays
​ ...
​ ! and a scalar reference ra
​ deallocate (ade, ra, b) ​ ! Freeing dynamic memory
Notes:
It is good practice to release with the DEALLOCATE statementdedicated heap when no longer needed.
This avoids the accumulation of unused and unavailable memory.
Fortran 95 introduced automatic release of allocated arrays,declared in procedures. It works like this: if upon exiting the user has not explicitly released
procedures with the DEALLOCATE statement the memory occupied by the allocated array, now it will happen automatically. This new property makes the
language more robust. For example, in an FPS that does not support the Fortran 95 standard, following code
program t4 call a ()
call a ()
end 
program 
t4
subroutine 
a 
() 
real,
allocatable :: b (:)
! Second call to FPS will fail
print *, allocated (b)
! FPS on the first call will print F, on
the second - T
allocate (b (10)) end
! CVF in both calls will print F
will result in an error: run-time error F6316 - array already allocated, which will stop the computation. In CVF, both calls end happily.
4.8.3. Automatic arrays
The procedure can specify a local array, the size of which
change on different procedure calls. and local variable length strings (Section 3.8.3), refer toSuch arrays, as well as to automatic objects.
An example . Create a procedure for exchanging the contents of two arrays.
program shos integer, parameter :: n = 5 integer k
 real :: a (n) = (/ (1.0, k = 1, n) /), b (n) = (/ (2.0, k = 1, n) /) interface
subroutine swap (a, b)
! When using reshaping
real a (:), b (:)
end subroutine swap
end interface call swap (a, b)
! 
arrays 
require 
an
explicit interface
131
132
O. V. Barteniev. Modern FORTRAN
write (*, *) b end
subroutine swap (a, b)
real a (:), b (:)
​ ! a and b are arrays taking shape real c (size (a))              ! c - automatic array c = a a = b b = c
end subroutine swap
Comment. If you design swap as an internal subroutine shos program , you do not need to set an interface block to swap , since internal (as well as modular)
procedures have an explicit the specified interface.
Automatic objects include data objects, dimensions which depend on non-const descriptive expressions (Section 5.6) and which are not formal parameters of the
procedure. Such objects cannot have SAVE and STATIC attributes.
Automatic array bounds or automatic text length strings are fixed for the duration of the procedure and do not change when the value of the corresponding
description expression changes.
4.9. Arrays - formal parameters of procedures
In procedures, the form and size of an array - a formal parameter can be determined at the time of the procedure call. There are 3 types arrays - formal
parameters: of a given form, taking shape and size.
4.9.1. Arrays of a given shape
The bounds of dimensions of arrays - formal parameters can be determined by the values  of other parameters passed to the procedure. For instance:
 integer, parameter :: n = 5, m = 10, k = m * n real a (m, n) / k * 1.0 /, b (m, n) / k * 2.0 / call swap (a, b, m, n) write (*, *) b end
subroutine swap (a, b, m, n)

integer m, n real a (m * n), b
(m * n)
! a and b are arrays of a
given shape
real c (size (a)) c = a a = b
! c - automatic array
132
133
4. Arrays
b = c
end subroutine swap
Such arrays - formal parameters are called arrays a given shape . In the example, their shape is specified by formal parameters m and n .
The example shows that the forms of the actual and corresponding its formal parameter - the array may differ. In general
both the lower and upper bounds of the dimension can be calculated. General kind of dimension of such arrays:
[ lower bound ]: [ upper bound ]
Lower and upper bounds are integer descriptive expressions (Section 5.6).
Computed array bounds are fixed at runtime procedures and do not change when the value of the corresponding descriptive expression.
When working with such arrays, it is necessary to ensure that the size array - the formal parameter did not exceed the size the array associated with it - the actual
parameter.
If the actual parameter is a multidimensional array and the corresponding formal parameter is an array of the given forms with the same number of dimensions, then
for correct association it is necessary to indicate the dimensions of the array - the formal parameter such the same as the array - the actual parameter. An
exception may constitute the upper bound of the last dimension of the array that can be less than the corresponding array boundary - the actual parameter.
If an array element is specified as an actual parameter, then the formal parameter is associated with the elements of the parent array starting with this element, and
further in order.
An example . Print the first negative element of each column matrices.
ineger, parameter :: m = 4, n = 5 integer j real :: a (m, n) = 1.0
a (1, 1) = -1.0; a (2, 2) = -2.0; a (3, 3) = -3.0 do j = 1, n
call prifin (a (1, j), m, j)
! All elements are available
in prifin
end do
! column j starting from the
first and all
end
subroutine prifin (b, m, j)
integer m, i, j
! subsequent elements of
matrix a
real b (m)
! Vector b contains all
elements
do i = 1, m
if (b (i) <0) then
! column j of matrix a
 133
134
O. V. Barteniev. Modern FORTRAN
print *, 'Column', j, '. Element ', b (i) return
end if end do print *, 'Column', j, 'no negative items'
end subroutine prifin
4.9.2. Arrays taking shape
Such arrays - formal parameters take the form of y corresponding actual parameter. As a result, the form the actual and formal parameters are the same. (It is
clear that the actual and formal parameters must be of the same rank.) describing the form of the formal parameter, each dimension has the form:
[ lower bound ]:
where the lower bound is an integer descriptive expression that can depend on the data in the procedure or other parameters. If the bottom the border is omitted,
then its default value is one. For instance, when calling
real x (0: 3, 0: 6, 0: 8) interface
subroutine asub (a) real a (:,:, :) end
end interface
...
call asub (x) the corresponding reshaping array is declared like this:
subroutine asub (a) real a (:,:, :)
​ print *, lbound (a, 3), ubound (a, 3) ​ ! 19
Since there is no lower bound in the description of the array a , then after calling the subroutine, the array a (4, 7, 9) will be defined in it . If needed keep the
boundaries consistent, then the array a should be declared like this:
real a (0 :, 0 :, 0 :)
In the interface block, the array a can still be declared:
real a (:,:, :)
Procedures containing as formal parameters arrays that take shape must be explicitly given interface.
If, to work with an array in a procedure, you need to know the values  of its bounds, you can get them using the LBOUND and UBOUND functions (Section
4.12.3.2).
134
135
4. Arrays
An example . Matrices a and b of different shapes are given. Which one is the first the negative element of the last column has the greatest value?
program neg2
interface
! A procedure with formal
parameters

integer function FindNeg (c) ! are the arrays taking
shape,
integer :: c (:, :)
end function FindNeg
end interface
integer a (4, 5), b (-1: 7, -1:
8)
! must have an explicit
interface
integer nga, ngb, ngmax
! nga and ngb - respectively
the last
a = 1; a (3, 5) = -2 b = 2; b
(2, 8) = -3
! 
negative 
elements 
of
matrices a and b
nga = FindNeg (a) ngb =
FindNeg (b)
! Looking for nga and ngb
if (nga == 0) print *, 'In the last column of the matrix and no negative elements' if (ngb == 0) print *, 'There are no negative elements in the last column of matrix b '
ngmax = max (nga, ngb)
! If not all matrices have a negative element in the last column - STOP if (ngmax == 0) stop
 if (nga == ngmax) print *, 'In matrix a' if (ngb == ngmax) print *, 'In matrix b' end
integer function FindNeg (c) ! Returns the first negative
item
integer :: c (:, :) integer cols, i
FindNeg = 0
! the last column of the
matrix c
cols = ubound (c, dim = 2)
do i = lbound (c, 1), ubound
(c, 1)
if (c (i, cols) <0) then
! Last column number in
array c
FindNeg = c (i, cols) return
end if
end do end function FindNeg
! Let's return the found
negative element
Result:
In the matrix a
4.9.3. Arrays taking size
In a resizing array - a formal parameter instead of the upper limit of the last dimension is marked with an asterisk (*).
(In the same way, the length-taking lines are set.) boundaries must be explicitly described. The resizing array can differ in rank and shape from the corresponding
array - the actual parameter. The actual parameter only determines the size of the array formal parameter. For instance:
135
136
O. V. Barteniev. Modern FORTRAN
real x (3, 6, 5), y (4, 10, 5) call asub (x, y)
...
subroutine asub (a, b)
real a (3, 6, *), b (0: *)
​ print *, size (a, 2)​ ! 6
​ print *, lbound (a, 3), lbound (b)
​ ! ten
Resizing arrays have no specific shape.
This can be illustrated with an example:
real x (7) call assume (x)
...
subroutine assume (a)
real a (2, 2, *)
With this organization of data between the arrays x and a is set conformity:
 x (1) = a (1, 1, 1) x (2) = a (2, 1, 1) x (3) = a (1, 2, 1) x (4) = a (2, 2, 1) x (5) = a (1, 1, 2) x (6) = a (2, 1, 2) x (7) = a (1, 2, 2)
i.e. there is no element a (2, 2, 2) in the array a . (The size of the array a is determined the size of the array x and is seven.)
Since resizing arrays have no shape, you cannot access the entire array by passing its name to the procedure. (The exception is procedures that do not require an
array shape, e.g. the built-in function LBOUND.) So, you cannot use only the name of the resizing array as a parameter to the built-in function SIZE, but you can
define the extent along a fixed (i.e., any, except the last) dimension.
You can define cross-sections for the resizing array. However, in in general, it is necessary to ensure that all elements of the section belong to array. So, for the
array a from the last example, you cannot specify the section a (2, 2, 1: 2) because there is no element a (2, 2, 2) in array a .
Care must be taken to ensure that when working with size adapters arrays did not make calls to those not belonging to the array memory cells. So, the next
fragment will be executed by the computer, but will distort the value of the variable d :
program bod
integer b (5) / 5 * 11 /, d / -2 / call testb (b)
136
137
4. Arrays
write (*, *) d end
subroutine testb (b)
! Instead of the expected -2,
we have 15
integer b (*)
! Array taking on the size
b (6) = 15 end
! The address b (6) contains
the variable d

Taking into account the noted shortcomings in the organization of adopting the size arrays (lack of form, possibility of going beyond the boundaries, the
impossibility of using a function as a result), you should use arrays of a given shape as formal parameters or arrays that take shape.
4.10. Using arrays
Fortran allows you to work with arrays and sections of arrays in the same way as as with single data objects:
arrays and their sections can be assigned values;
 arrays (sections of arrays) can be used as operandsin expressions with arithmetic, logical operations and relationship operations. The result of an
expression that contains arrays and / or sections of arrays, assigned to the array (section). AT the result of the assignment is an array (section), each element which
has a value equal to the result of operations on the corresponding elements of the operands:
array | section = expression
arrays and sections can be parameters of built-in elementfunctions (Section 6.1), such as SIN and SQRT. Elemental functions, getting an array (slice) as an
argument, are executed sequentially for all elements of the array (section).
True, there is a limitation: used as operands arrays (sections of arrays) and an array (section), which is assigned the result of the expression must be consistent.
Patterns (sections) are consistent if they have the same shape.
So, arrays a (-1: 6) and b (-1: 6), arrays c (2: 9) and b (-1: 6) are matched . Is always array and scalar are matched.
Example:
integer (2) a (5) / 1, 2, 3, 4, 5 /, a2 (4, 7) / 28 * 5 / integer (2) :: b (5) = (/ 1, 2, -2, 4, 3 /) integer (2) :: ic (5) = 1
character (1) d1 (4) / 'a', 'c', 'e',  'g' / character (1) d2 (4) / 'b', 'd', 'f', 'h' / character (4) d12 (4) real (4) c (2) /2.2, 2.2 /, d (2) /2.2, 3.3 /, cd * 8 (2)
137
 138
O. V. Barteniev. Modern FORTRAN
logical (1) g (3) / .true.,
.false., .true. / logical (1) h
(3) / 3 * .false. /
ic = ic + 2 * (a - b) - 2
! Array assignment
write (*, *) ic
!
​ -1
​ -1
nine
-1
3
a2 (3, 1: 5) = a2 (3, 1: 5) - a ! Consistent array and
section
write (*, *) int (sqrt (real (a *
b ** 2)))!
​ 1
​ 2 3
8
6
write (*, *) exp (real (a / b)) ! 2.718 2.718 3.68e-
01
...
write (*, *) a ** b d12 = d1
// '5' // d2 // '5'
!
​ 1
​ 4
0
256
125
write (*, *) d12
! a5b5c5d5e5f5g5h5
write (*, *) mod (a, b)
!
​ 0
​ 0
1
0
2
write (*, *) sign (a, b)
!
​ 1
​ 2
-3
4
five
write (*, *) dim (a, b)
!
​ 0
​ 0
five
0
2
cd = dprod (c, d)
! 4.840
​ ...
7.26
write (*, *) g .and. .not. h
end
!
​ T
​ F
T
4.11. Array as result of function
An array can also be the result of a function. The interface to
such functions must be specified explicitly. If the function is not
a link, then the boundaries of the array should be descriptive
expressions that calculated when entering the function.
An example . Create a function that returns an array of the first
n positive elements of the array passed to it.
real, allocatable :: ap (:)
real :: a (10) = (/ 1, -1, 2, -2, 3, -3, 4, -4, 5, -5 /) real :: b (10)
= (/ 2, -1, 3, -2, 4, -3, 4, -4, 5, -5 /) integer n / 3 / allocate (ap
(n))
ap = fap (a, n) + fap (b, n)
​ ! Calling the array- like fap
function print '(1x, 10f5.1)', ap              ! 3.0 5.0 7.0 contains
function fap (a, n)
integer :: n, k, i
real :: fap (n)
​ ! The result of the function is an array real,
dimension (:) :: a              ! a - an array taking shape fap = 0 k
= 0
do i = 1, size (a) if (a (i)> 0) then
k = k + 1
fap (k) = a (i)
​ ! Forming the result array if (k == n) exit
end if end do
 138
139
4. Arrays
end function fap
end

Notes:
If you design the fap function as external, then you need to the calling program unit explicitly set the interface:
interface function fap (a, n)
integer n real fap (n) real, dimension (:) :: a
end function fap
end interface
The same problem can be solved without creating a rather cumbersome functionfap , but by calling the built-in PACK function twice (Section 4.12.4.2): ap = pack
(a, a> 0) + pack (b, b> 0)
However, if the length of the arrays returned by the PACK function is less than n , the the elements of the ap array will not be defined, and the result will be
unpredictable.
Array-returning functions are called array-like functions . The example shows that array-like functions can be, like normal functions, they are operands of
expressions. 4.12. Built-in functions for arrays
Fortran has a large number of built-in functions that allow you to:
perform calculations in arrays, for example, find the maximumarray element or sum its elements;
transform arrays, for example, you can get from one-dimensionaltwo-dimensional array;
get reference data about an array (size, shape and valuesboundaries of each dimension).
Any function call for arrays can be performed with key words, which are the names of formal parameters.
A call with keywords is required if the positions of the corresponding the actual and formal parameters do not match.
Parameters of all functions considered in the section can be sections of arrays.
Some functions return the result of a standard integer or logical type. The default value for the flavor parameter for of these types, KIND is four. However, if the
compiler option is given
/ 4I2 or directive $ INTEGER: 2, value of the standard integer and boolean types will be equal to two.
 139
140
O. V. Barteniev. Modern FORTRAN
As before, the optional parameters of the functions are surrounded by square brackets.
4.12.1. Array calculations
ALL ( mask [, dim ]) - returns .TRUE. If all elements of a boolean array mask along the given (optional) dimension dim are true; otherwise, returns .FALSE.
The result of the function is a boolean scalar if mask one-dimensional array or dim parameter omitted (in this case all elements of the mask array are scanned ).
Otherwise the result is a boolean array whose dimension is one less than the dimension mask . The flavors of the result type and mask are the same.
The dim parameter is an integer constant expression (1 ≤ dim ≤ n , where n is the dimension of the mask array ). The dim parameter , if given, means that the
action is performed on all one-dimensional sections that can be set by dimension with number dim . The function calculates the result for each of the sections and
enters into the array one unit of lower rank with extents equal to the extents in other dimensions. So, in two-dimensional array mask (1: 2, 1: 3) in the second
dimension ( dim = 2) you can specify two one-dimensional sections: mask (1, 1: 3) and mask (2, 1: 3). Therefore for storing the result of the function ALL ( a one-
dimensional logical array of two elements.mask , 2) should be used
ANY ( mask [, dim ]) - returns .TRUE. If at least one element boolean array along a given (optional) dimension dim true; otherwise, the function returns .FALSE.
The result of the function and the effect of the dim parameter are determined by the same the same rules as for the ALL function.
COUNT ( mask [, dim ]) - returns the number of elements of the logical mask arrays with the value .TRUE. along a given optional dimension dim . The function
result has the standard whole type. Result rules and the effect of the dim parameter the same as for the ALL function.
For ALL, ANY, COUNT functions:
Example 1:
​ logical ar1 (3), ar2 (2) ​ ! Arrays for storing results
logical mask (2, 3) / .true., .true., .false., .true., .false., .false. /
​ ! The mask array :
​ .true. .false. .false.
 
​ !
​ .true. .true. .false.
ar1 = all (mask,
dim = 1)
! Evaluating Elements in Array Columns
print *, ar1
! TFF
ar2 = all (mask,
dim = 2)
! Evaluating Elements in Array Rows
print *, ar2
! FF
140
141
4. Arrays
print *, any (mask, dim = 1) ​ ! TTF print *, any (mask, dim = 2)              ! TT print *, count (mask, dim = 1)! 2 1 0 print *, count (mask, dim = 2)! 12 end
Example 2 . If at least one element of the second column of the matrix a less than zero, print the number of positive elements of its first strings.
integer a (4, 5)
​ a = 2;
​ ! Array initialization
a (2, 2) = 0 ​ ! Now the second element of the second column is zero a (1, 3) = -1              ! Now the third element of the first line is less than zero if (any (mask =
a (:, 2) == 0)) print *, count (a (1, :)> 0)end              ! 4
MAXLOC ( array [, dim ] [, mask ]) - returns the indices of the maximum array element array or maximal elements for a given dimension dim . The value of each
maximum element satisfies specified (optional) mask conditions . If multiple items contain the maximum value, then the first in their order is taken sequence in array
. MAXLOC result if dim is not specified ,
is written to a one-dimensional array, the size of which is equal to a number dimensions array .
The mask parameter is a boolean array whose form is matches the shape of array . The mask array can be obtained in the result of evaluating a logical expression.
If an array is given, then the function applies only to those elements of the array array , for which mask is .TRUE. If mask is omitted, then the function applies to all
elements of array .
The index values  are taken as if all the lower bounds of the array array are equal to one. If the mask is such that the largest element is not can be found, then the
returned index values  are greater than the upper bound of each dimension of array .

If the dim parameter is specified, then:
the result array has a rank one less than the rank of array , and the form ( d 1 , d 2 , ..., d dim - 1 , d dim + 1 , ..., d n ), where ( d 1 , d 2 , ..., d n ) is the form of
the array array ;
if array has rank equal to one, then MAXLOC ( array , dim [, mask ]) returns the same as MAXLOC ( array [, MASK = mask ]);
otherwise the value of the element ( s 1 , s 2 , ..., s dim - 1 , s dim + 1 , ..., s n ) of the result function MAXLOC ( array , dim [, mask ]) is equal to MAXLOC (
array ( s 1 , s 2 , ..., s dim - 1 , s dim + 1 , ..., s n ), [, MASK = mask ( s 1 , s 2 , ..., s dim - 1 , s dim + 1 , ..., s n )]).
 141
142
O. V. Barteniev. Modern FORTRAN
MINLOC ( array [, dim ] [, mask ]) performs the same actions as MAXLOC, but for the minimum elements of array . The meaning of dim parameters and mask
is the same as for the MAXLOC function. Index values  are taken
as if all the lower bounds of the mask is such that the smallest element cannot be found, thenarray are equal to one. If
the returned index values  exceed the upper bound of each dimensions of array .
Comment. Optional dim parameteradded in MAXLOC functions and MINLOC standard 1995
An example for the MAXLOC and MINLOC functions:
integer ir, maxf (1) integer arra (3, 3) / 7, 9, -1, -2, 5, 0, 3, 6, 9 / integer, allocatable :: ar1 (:)
​ ! Array arra :
​ 7 -2
​ 3
​ !
​ nine ​ five
​ 6
!
​ -1
​ 0
​ nine
ir = size (shape (arra)) ​ ! Rank of array ( ir = 2) allocate
(ar1 (ir))
! Found in an array of array indices most, but less than
seven elements ar1 = maxloc (arra, mask = arra <7)
! The result of the expression mask = arra <7 is an array
mask
! the same shape as arra . The elements of the mask
array have
! the value of .TRUE. if the corresponding element of the
arra is less than seven,
! and .FALSE. - otherwise. Thanks to this mask, the
function
! MAXLOC returns the indices of the maximum but less
than seven element
! Array arra :
​ 7 -2
​ 3 The mask array :
​
.false.
.true.
.true.
!
​ nine ​ five
​ 6
​ .false.
.true.
.true.
!
​ -1
​ 0
​ nine ​ .true.
print *, ar1 ​ ! 2 3
print *, minloc (arra, mask = arra> 0)
​ ! thirteen maxf
= maxloc ((/ 1, 4, 1, 4 /))
.true. .false.
print *, maxf
​ ! 2 (index of the first maximum)
print *, minloc ((/ 1, 4, 1, 4 /)) ! 1 (index of the first minimum) end
Example for MAXLOC function with dim parameter :
integer (4), parameter :: m = 3, n = 5 real (4) :: a (m, n) integer ip (n)
​ a = reshape ((/
​ 3.0, 4.0, 5.0, 6.0, 7.0, &
2.0, 3.0, 4.0, 5.0, 6.0, &
1.0, 2.0, 3.0, 4.0, 5.0 /), shape = (/ m, n /), order = (/ 2, 1 /))
142
143
4. Arrays
ip = maxloc (array = a, mask = a <5, dim = 1)
​ print *, ip
​ ! 1 1 2 3 0
MAXVAL ( array [, dim ] [, mask ]) - returns the maximum an integer value satisfying the optional mask mask , or a real array along the given optional dimension
dim .
The meaning of the dim parameter is explained in the description of the ALL function, and the mask parameter - when describing the MAXLOC function.
The return value is of the same type and kind of type as and the array array . If dim is omitted or array is one-dimensional, then the result of the MAXVAL function
is a scalar, otherwise
the result is an array whose rank is one less than the rank of the array array .
If array size is 0 or all elements of mask array are .FALSE., then the MAXVAL function returns the largest absolute value negative number allowed by the
processor.
MINVAL ( array [, dim ] [, mask ]) - returns the minimum an integer value satisfying the optional mask mask , or a real array along the given optional dimension
dim .
 The meaning of the dim parameter is explained in the description of the ALL function, and the mask parameter - when describing the MAXLOC
function.
The return value is of the same type and kind of type as and the array array . If dim is omitted or array is one-dimensional, then the result of the MINVAL function
is a scalar, otherwise
the result is an array whose rank is one less than the rank of the array array .
If array size is 0 or all elements of mask array are .FALSE., then the MINVAL function returns the largest positive allowed processor number.
An example for the MAXVAL and MINVAL functions:

integer array (2, 3), isha (2), max integer, allocatable :: ar1 (:), ar2 (:) array = reshape ((/ 1, 4, 5, 2, 3, 6 /), (/ 2, 3 /))
! Array array : 1 5 3
​ !
​ 4 2 6
​ isha = shape (array)
​ ! isha = (2 3)
allocate (ar1 (isha (2))) ​ ! isha (2) = 3 - the number of columns in the array allocate (ar2 (isha (1)))              ! isha (1) = 2 - the number of rows in the array max =
maxval (array, mask = array <4)! Returns 3
ar1 = maxval (array, dim = 1)
​ ! Returns (4 5 6) ar2 = maxval (array, dim = 2)              ! Returns (5 6)
print *, minval (array, mask = array> 3)! 4 ( mask keyword is required)
143
144
O. V. Barteniev. Modern FORTRAN
print *, minval (array, dim = 1)
! 1
2 3
print *, minval (array, dim = 2)
! In the next call, all keywords are
omitted
! 12
print *, minval (array, 1, array / = 2)
end
! 1
5 3
PRODUCT ( array [, dim ] [, mask ]) - calculates the product of all elements              integer or real array along optional dimension dim . Elements to be
multiplied can selected by the optional mask mask .
The meaning of the dim parameter is explained in the description of the ALL function, and the mask parameter - when describing the MAXLOC function.
The result returned by the function is of the same type and variety. of the same type as array .
If the array size array is equal to zero or all elements of the array mask are equal to .FALSE., then the result of the function is one.
SUM ( array [, dim ] [, mask ]) - calculates the sum of all elements an integer or real array along an optional dim measurements . The elements to be summed can
be selected optional mask mask .
 The meaning of the dim parameter is explained in the description of the ALL function, and the mask parameter - when describing the MAXLOC
function.
The result returned by the function is of the same type and variety. of the same type as array .
If the array size array is equal to zero or all elements of the array mask are equal to .FALSE., then the result of the function is zero.
Example for PRODUCT and SUM functions:
integer arra (2, 3) / 1, 4, 2, 5, 3,
6 / integer ar1 (3), ar2 (2)
! Array array : 1 2 3
!
​ 4 5 6
ar1 = product (arra, dim = 1)
! 
Product 
by
columns
print *, ar1 ar2 = product (arra,
mask = arra <6, dim = 2)
!
​ 4
​ ten eighteen
print *, ar2
!
​ 6
​ 20
print *, sum (arra, dim = 1)
!
​ five
​ 7
nine
ar2 = sum (arra, mask = arra <6,
dim = 2)
! Summing by lines
print *, ar2
!
​ 6
​ nine
! Product of the sums of the columns of the matrix: (1 + 4) * (2 + 5) * (3 + 6)
print *, product (sum (arra, dim = 1))
​ ! 315 end
144
145
4. Arrays
4.12.2. Multiplication of vectors and matrices
DOT_PRODUCT ( vector_a , vector_b ) - the function returns scalar product of vectors vector_a and vector_b , equal to the sum of products their elements with
equal index values.
vector_a - one-dimensional array of integer, real, complex
or boolean.
vector_b is a one-dimensional array of the same size as vector_a .
Must be boolean if vector_a is boolean. Must be numeric (integer, real or complex) if vector_a array is numeric. In the latter case, the vector_b type can differ
from type vector_a .
The returned number is:
SUM ( vector_a * vector_b ) if vector_a is of integer or real type. The result is integer if both arguments are integer; complex if vector_b is of complex type, and
real in otherwise;
SUM (CONJG ( vector_a ) * vector_b ) if vector_a is of complex type, then the result is also a complex number;
 ANY ( vector_a .AND. Vector_b ), if the arguments are boolean, then the result is also of a boolean type.
If the size of the vectors is zero, then the result is zero.
or .FALSE. in the case of a boolean type.
Example:
print *, dot_product ((/ 1, 2, 3 /), (/ 4, 5, 6 /))! 32
MATMUL ( matrix_a , matrix _ b ) - performs adopted in line algebra rules multiplication of matrices of integer, real, complex and boolean type.
matrix_a - one-dimensional or two-dimensional array of integer, real,
complex or logical type.
matrix_b is an array of boolean type, if matrix_a is a boolean array;

a numeric array if matrix_a is a numeric array. In the latter case, the type matrix _b can be different from type matrix_a .
At least one of the arrays matrix_a and matrix_b must be two-dimensional.
There are 3 possible cases:
matrix_a has the shape ( n , m ) and matrix_b has the shape ( m , k ). Then the result has the form ( n , k ) and the value of the element ( i , j ) is
SUM ( matrix_a ( i, :) * matrix_b (:, j ));
matrix_a has shape ( m ) and matrix_b has shape ( m , k ). Then the result is of the form ( k ) and the value of element ( j ) is
SUM ( matrix_a * matrix_b (:, j ));
145
146
O. V. Barteniev. Modern FORTRAN
• matrix_a has shape ( n , m ) and matrix_b has shape ( m ). Then the result is of the form ( n ) and the value of element ( i ) is SUM ( matrix_a ( i, :) * matrix_b ).
For logical arrays, the ANY function is equivalent to the SUM function, a .AND. is equivalent to the product (*).
Example:
integer a (2, 3), b (3, 2), c (2), d (3), e (2, 2), f (3), g (2) a = reshape ((/ 1, 2, 3, 4, 5, 6 /), (/ 2, 3 /)) b = reshape ((/ 1, 2, 3, 4, 5, 6 /), (/ 3, 2 /))
! Array a : 1 3 5
​ !
​ 2 4 6
! Array b : 1 4
​ !
​ 2 5
 
​ !
​ 3 6
c = (/ 1, 2 /) d
= (/ 1, 2, 3 /)
e = matmul
(a, b)
! Position : 22
49
!
28
64
f = matmul (c,
a)
! Result : 5
eleven
17
g = matmul
(a, d)
! Position : 22
28
⎛ x1 ⎞
⎜ ⎟
⎜ x 2 ⎟ (yy1
A = ⎜ ⎟
...
⎜ ⎟
⎜ ⎟
... y )= xy T ∈ R
nm×
2
​ m
...
It is known from linear algebra that the product of the column vector x by the row vector y T is the matrix
x
⎝ m ⎠
In Fortran, it will be returned by the built-in MATMUL function. True, for to ensure its operability need to convert the vector x in an array of the form (/ m , 1 /),
and the vector y T into an array of the form (/ 1, n /):
integer (4), parameter :: m = 3, n = 5 integer (4) :: i, j
real (4) :: x (m) = (/ 1.0, 2.0, 3.0 /) real (4) :: y (n) = (/ 5.0, 6.0, 7.0, 8.0, 9.0 /) real (4) :: a (m, n) = 0.0
a = matmul (reshape (x, shape = (/ m, 1 /)), reshape (y, shape = (/ 1, n /)))
do i = 1, m ​ ! Outputting the result print '(1x, 10f6.2)', a (i, :)
end do! The same result, but faster, will give a nested loop do j = 1, n
do i = 1, m
a (i, j) = x (i) * y (j) end do end do
 146
147
4. Arrays
Result:
​ 5.00 6.00 7.00 8.00
​ 9.00
10.00 12.00 14.00 16.00 18.00
15.00 18.00 21.00 24.00 27.00
Comment. The considered multiplication of the column vector x by the row vector y T called an external work . The rank of the outer product when x and y real
vectors, not higher than one.
4.12.3. Reference functions for arrays
4.12.3.1. Allocated Array Status
ALLOCATED ( array ) - returns a value of the standard boolean type, equal to .TRUE. if the array being allocated is array (an array having the attribute
ALLOCATABLE) is currently allocated, and .FALSE. - otherwise. The result will be undefined if the status of the posted is not defined.
array. A compilation error will occur if the function parameter is an array that does not have the ALLOCATABLE attribute, or a scalar.
4.12.3.2. Array border, shape and size
The functions of this section provide information about the boundaries of an array of any type. If the parameter is an allocable array, then it must be posted, and if a
link, then it must be attached to the addressee.
The lower boundaries of the array section are considered equal to one, and the upper ones equal to the corresponding extents. Since the result only depends from
the properties of the array, then its value does not have to be certain. In the functions of this subsection (except for the SHAPE function) the dim parameter is an
integer constant expression; 1 ≤ dim ≤ n , where n is the rank array - function argument.
LBOUND ( array [, dim ]) - if the dim parameter is absent, then

returns a one-dimensional array of standard integer type containing the lower bounds of all measurements. The dimension of the result array at the absence of dim
equals the rank of array . If dim is given, then the result is is a scalar equal to the lower bound of the dim dimension of array .
If array is a resizing array, then the dim parameter must be specified and should not specify the last dimension of array .
dim - integer constant expression; 1 ≤ dim ≤ n , where n is the rank
array array .
UBOUND ( array [, dim ]) - Similar to LBOUND, but returns the top borders.
Example:
real array (2: 8, 8:14) integer, allocatable :: lb (:) allocate (lb (size (shape (array))))
148
O. V. Barteniev. Modern FORTRAN lb = lbound (array)
print *, lb
!
2
8
print *, lbound (array, dim = 2)
!
8
print *, lbound (array (2: 6: 2, 10:12)) lb = ubound (array)!
1
1
print *, lb
!
8
fourteen
print *, ubound (array, dim = 2)
!
fourteen
print *, ubound (array (: 6: 2, 10:12)) end
!
3
3
 147
SHAPE ( source ) - Returns a one-dimensional array of a standard integer of type containing the array or scalar form source . Source can have any type and
cannot be a resizing array. The size the result array is equal to the rank of source .
Example:
integer vec (2), array (3:10, -1: 3) vec = shape (array)
​ write (*, *) vec
​ !
​ 8
​ five
SIZE ( array [, dim ]) - returns a standard integer equal to the size Array array , or, if there is a scalar parameter dim ,
the number of elements (extent) along the given dimension dim . If array is
resized array, the dim parameter must be specified.
Example:
real (8) array (3:10, -1: 3) integer i, j
= size (array, dim = 2) ​ ! Returns 5
= size (array)
​ ! Returns 40
4.12.4. Array conversion functions
4.12.4.1. MERGE Element Function of Merging Arrays
MERGE ( tsource , fsource , mask ) - creates a new one according to the specified mask an array of elements of two arrays.
tsource , fsource - arrays of one form, one (any) type and
type parameters from which the elements are taken into the result array. mask - a boolean array of the same shape as the arrays
tsource and fsource . The mask array defines which array the tsource is from or fsource , the next element will be taken into the result array.
The MERGE function returns an array of the same shape and type, as the tsource and fsource arrays . The array-result receives an element of the tsource array if
the corresponding element in the mask array is
.TRUE., Otherwise the result is an element from the array fsource .
Example:
 148
149
4. Arrays
integer tsource (2, 3), fsource (2, 3), ar1 (2, 3) logical mask (2, 3)
tsource = reshape ((/ 1, 4, 2, 5, 3, 6 /), (/ 2, 3 /)) fsource = reshape ((/ 7, 0, 8, -1, 9, -2 /), (/ 2, 3 /)) mask = reshape ((/. true., .false., .false., .true., .true., .false.
/), (/ 2,3 /))
! tsource : 1
​ 2 3
fsource :
7
​ 8
​ 9
mask :
.true. .false. .true.
!
​ 4
​ 5 6
0 -1 -2
.false. .true. .false.
ar1 
= 
merge 
(tsource,
fsource, mask)
! Result : 1
​
8
​ 3
end
!
0
​
five
​ -2
Comment. The tsource or fsource parameter can also be a scalar, which according to the rules of elementality, it will be expanded into an array of the proper form,
eg:
integer tsource (5) / 1, 2, 3, 4, 5 /, fsource / 7 / logical mask (5) / .true., .false., .false., .true., .true. /
print *, merge (tsource, fsource, mask)
​ ! 1 7 7 4 5 end
4.12.4.2. Packing and unpacking arrays
PACK ( array , mask [, vector ]) - packs an array into a one-dimensional array (vector) under the control of the mask array .
array - an array of any type that is packed into a vector. mask is a boolean array of the same shape as array , or simply boolean .TRUE .; mask - sets the
conditions for packing elements array array .
vector - an optional one-dimensional array of the same type
and a kind of type as array . The number of elements in the array is not must be less than the number of elements with a .TRUE value. in array mask .
The function returns a one-dimensional array of the same type and variety of type as array , and same size as vector , if
the last one is given. The value of the first element in the result array is the element
Array array , which corresponds to an element with a value .TRUE.
in mask ; the second element in the result array is an element of the array array , which matches the second element with a .TRUE value. in mask , etc.
e. Elements are viewed in the order of their placement in the computer memory (the leftmost index changes the fastest). If vector is omitted, then the size of the
resulting array is equal to the number of elements with the value
.TRUE. in mask . If mask is a single value

.TRUE., Then the size of the result is equal to the size of array . If vector is specified and has a size greater than the number of elements with a .TRUE value. at
mask , then additional elements of vector are copied without changes in the result.
 149
150
O. V. Barteniev. Modern FORTRAN
Example:
integer array (2, 3), vec1 (2), vec2 (5) logical mask (2, 3)
array = reshape ((/ 7, 0, 0, -5, 0, 0 /), (/ 2, 3 /)) mask = array / = 0
​ ! Array of array : ​ 7 0 0 Array mask :
​ ... true. ... false. ... false.
!
​ 0 -5 0​ .false.
​ .true. ... false. vec1 = pack (array, mask)
vec2 = pack (array, mask = array> 0, vector = (/ 1, 2, 3, 4, 5 /))
print *, vec1
​ ! 7 -5 print *, vec2
​ ! 7 2 3 4 5
end
UNPACK ( vector , mask , field ) - returns an array of the same type and flavors of the type, like the one-dimensional array vector , and the same shape, that the
boolean array mask . The number of vector elements is at least is equal to the number of true elements in mask . The field parameter must be scalar or have the
same form as the mask array , and its type and the type parameters must be the same as vector .
Result element corresponding to i- th true array element mask , counting in the order of its elements, is equal to the i -th element of vector , and all other elements
are equal to the corresponding field elements , if it's an array, or field itself if it's a scalar.
Example:
logical mask (2, 3)
integer vector (3) / 1, 2, 3 /, ar1 (2, 3) mask = reshape ((/ .true., .false., .false., .true., .true., .false. /), (/ 2, 3 /))
! Vector array :
​ 1 2 3 Array mask :
... true. ... false. ...
true.
!
ar1 = unpack (vector, mask, 8)
.false.
​ .true. ...
false.
print *, ar1 (1, :) ​ ! Result :
1
​ 8
​
3
print *, ar1 (2, :) ​ ! end
8
​ 2
​
8
4.12.4.3. Reforming an array
RESHAPE ( source , shape [, pad ] [, order ]) - forms an array of the given mold shape of the elements of the array source . The resulting array has the same type
and kind of type as source .
source - an array of any type, the elements of which are taken in order
their succession to form a new array.
shape - a one-dimensional integer array specifying the shape
result: the i- th element of shape is equal to the size of the i- th dimension of the formed array. If pad is omitted, the overall size of the shape must not be exceed the
size of source .
150
151
4. Arrays
pad is an optional array of the same type as source . If in source
missing elements to form the result, pad elements are added to the resulting array in the order they appear. When need extra pad copies to fill result.
order - an optional one-dimensional array of the same size as
and shape . Rearranges the order of dimensions (which changes the order fill) of the result array. Order values must be one of permutations of the form (1, 2, ..., n
), where n is the size of shape ; order specifies the order changing indices when filling in the result. Fastest changes index order (1), slowest - order ( n ).
Moreover, elements from source are selected in the normal order. Further, if there are not enough elements source followed by copies of the pad elements . The
order parameter allows, in particular, reshape arrays in the order accepted in the SI with their subsequent transfer to the SI function.
Example:
integer ar1 (2, 5) real f (5,3,8), c (8,3,5)
 ar1 = reshape ((/ 1, 2, 3, 4, 5, 6 /), (/ 2, 5 /), (/ 0, 0 /), (/ 2, 1 /)) print *, ar1 (1, :) print *, ar1 (2, :)
​ ! Result :
​ 1 2 3 4 5
​ !
​ 6 0 1 0 1
! Let's change the order adopted in Fortran by the order adopted in SI c = reshape (f, (/ 8, 3, 5 /), order = (/ 3, 2, 1 /))
4.12.4.4. Building an array from copies of the original array
SPREAD ( source , dim , ncopies ) - repeats the source array along the given dimensions in the result array whose rank is one greater than source . source is an
array or scalar of any type.
dim is an integer scalar specifying the dimension along which the
repeated source ; 1 ≤ dim ≤ n +1, where n is the number of measurements in source .
ncopies - number of repetitions of source ; equal to the size of the extent
added dimension.
The function returns an array of the same type and variety of type as and source . If source is a scalar, then the element of the result is source . The result contains
MAX ( ncopies , 0) copies of source .
Example:
integer ar1 (2, 3), ar2 (3, 2)
​ ar1 = spread ((/ 1, 2, 3 /), dim = 1, ncopies = 2)! Result : 1              2              3
​ !
​ 1
​ 2
​ 3
​ ar2 = spread ((/ 1, 2, 3 /), 2, 2)
​ ! Result : 1 ​ 1
151
152

O. V. Barteniev. Modern FORTRAN
​ !
​ 2
​ 2
​ !
​ 3
​ 3
4.12.4.5. Array Shift Functions
CSHIFT ( array , shift [, dim ]) - performs a cyclic shift of the array at the specified optional dim index .
array - an array of any type.
shift - the number of positions (INTEGER) by which array elements are shifted . Can be an integer array with one less rank of rank array . If shift is a scalar, then
the result is cyclic by shifting each one-dimensional section along the dim index by shift positions. If shift is an array, then each of its elements specifies a shift for
corresponding section of array . In this case, the shift form must match array form minus dim . Positive shift executed in the direction of decreasing indices (to the
left in the case of a vector), and conversely, a negative shift is performed in the direction of increasing array index values  (to the right in the case of a vector).
dim - optional parameter (INTEGER) specifying the index, by
to which the shift is performed; 1 < dim < n , where n is the rank of array . If dim is omitted, the shift is performed at the first index.
 The function returns an array in which the cyclic shift is performed elements of the same type and shape as array . If the rank of array is greater units,
then each one-dimensional section is cyclically shifted along the given index dim or the first index if dim is omitted.
Example:
integer array (3, 3), ar1 (3, 3), ar2 (3, 3) data array / 1, 4, 7, 2, 5, 8, 3, 6, 9 /
​ ! Array of array : ​ 1 2 3
​ !
​ 4 5 6
​ !
​ 7 8 9
! Shift each column one position ar1 = cshift (array, 1, dim = 1)
​ ! Result :
​ 4 5 6
​ !
​ 7 8 9
​ !
​ 1 2 3
! Shift in the first row by -1, in the second - by 1 ar2 = cshift (array, shift = (/ - 1, 1, 0 /), dim = 2)
! Result :
3 1
2
!
5 6
4
!
7 8
9
EOSHIFT ( array , shift [, boundary ] [, dim ]) - performs preemptive left or right shift at the given optional dim index and
152
153
4. Arrays
fills in the resulting result with optional edge values shear gaps.
array - an array of any type. shift , dim - have the same meaning as for the CSHIFT function. boundary is an optional parameter of the same type as array . Sets
the values  to fill the resulting shift
omissions. Can be an array of boundary values  whose rank is one less than the rank of array . If boundary is omitted, then given by the default replacements
depend on the array type : integer - 0; real - 0.0; complex - (0.0, 0.0); logical - .FALSE .; character - space.
The function returns an array in which the shifts and replacements are performed.
Example:
integer shift (3)
character (1) array (3, 3), ar1 (3, 3)
array = reshape ((/ 'a', 'd', 'g', 'b', 'e',  'h', 'c', 'f', 'i' /), (/ 3, 3 / ))
​ ! Array of array : ​ abc
!
​ de
​ f !
​ gh
​ i
shift = (/ -1, 1, 0 /) ar1 = eoshift (array, shift, boundary = (/ '*', '?', '#' /), dim = 2)
 
​ ! Result :
​ * ab
​ !
​ e
​ f?
​ !
​ gh
​ i
4.12.4.6. Matrix transpose
TRANSPOSE ( matrix ) - swaps (transposes) columns and rows of a matrix (two-dimensional array) matrix . Type and variety of type the resulting array and
matrix are the same. If matrix is of the form ( k , n ), then the result has the form ( n , k ).
Example:
integer array (2, 3), result (3, 2)
array = reshape ((/ 1, 2, 3, 4, 5, 6 /), (/ 2, 3 /))
​ ! Array of array : ​ 1 3 5
!
​ 2 4 6 result = transpose (array)
​ ! Result :
​ 12
​ !
​ 3 4
​ !
​ 5 6
4.13. Array I / O driven by a list
​ Managed
​ the list
​ I / O
​ used by
​ at
​ work ​ from
sequential text files and standard devices
153
154
O. V. Barteniev. Modern FORTRAN
(keyboard, screen, printer). I / O conversions are performed in according to the types and values  of input and output values.
When entering an array from a file, the following cases are possible:

the number of input data is known;
you need to enter the entire file, but its size is unknown before entering.
In the latter case, it is more correct to enter into a dynamic array.
4.13.1. I / O one-dimensional array
Consider an example of I / O of a one-dimensional static array. integer, parameter :: nmax = 20
integer :: ios, n = 15, i ​ ! We are planning to enter n values character (60) :: fn = 'a.txt' real :: a (nmax) = 0
open (2, file = fn, status = 'old', iostat = ios)
 if (ios / = 0) then ​ ! Stop in case of error print *, 'Can't open file' // trim (fn) stop
end if
if (n> nmax) stop 'Input list size is larger than array size' read (2, *, iostat = ios) (a (i), i = 1, n) if (ios / = 0) then
write (*, *) 'The number of data entered is less than the declared one.'
​ n = i - 1
​ ! n - number of entered values
if (eof (2)) backspace 2 ​ ! Positioning the file in front of end if              ! by writing "end of file" write (2, *, iostat = ios) (a (i), i = 1, n)
​ close (2)
​ ! Close the file
write (*, '(1x, 5f5.2)') a (1: n) ​ ! Test output to the screen end
The composition of the a.txt file (before the execution of the WRITE (2, *, ...) statement:
1.0 2.0 3.0
4.0 5.0
Result displayed on screen:
The number of data entered is less than stated.
1.00 2.00 3.00 4.00 5.00 Explanations:
1. The OPEN statement opens I / O device number 2 and
connects the a.txt file to it. If the connection is successful, the a.txt file open. Further, the program uses the number to access the file devices.
The status = ' old ' parameter means that the file being opened should exist. The ios parameter allows you to pass the code to the program completion of the
OPEN statement. Integer ios variable
 154
155
4. Arrays
equals zero if the file is successfully opened and nonzero if an error occurred.
After connection, the file is positioned at its beginning. A.txt file opens for both reading and writing. File access is sequential.
Input control is performed by the ios parameter : if there are no input errors, then the ios value is zero; if end of file is reached, ios is
-1; ios is greater than zero if other errors occurred. In our example end of file will be reached, but parameter i of the cyclic list the READ statement retains its value
after READ finishes, which will count the number of items entered. True, this way determining the number of items entered will not work if data entry will be
terminated when a slash (/) is found in the a.txt file, since this case ios = 0.
The input statement contains a cyclic list ( a ( i ), i = 1, n ) . it allows you to read the first n randomly allocated fields (if,
of course there was no input error). Input is made from the beginning of the recording, and if the input operator needs to read more fields than are in
the current record, the missing fields will be taken from the following records. Each READ statement (unless no advance input is specified) starts input from the
beginning of a new file record. Therefore, if applied cycle
do i = 1, n
read (2, *, iostat = ios) a (i) end do
we would need to arrange each number in a text file on a separate line, i.e. in a column, which looks very awkward.
With the appearance of sections, the cyclic list ( a ( i ), i = 1, n ) can be
replace with WRITE.
​ a (1: n ) section . In our example, the section is applied in the operator You can also use the operator for input:
​ read (2, *, iostat = ios) a
​ ! or a (1: nmax)
It will try to enter the entire array - transfer the first nmax fields from the file .
However, if the input fields are less than nmax , then with such an input it is no longer possible calculate the number of data entered.
The entire array will be output by the operator
​ write (*, *) a
​ ! Output on display
4. Outputting the array to the a.txt file will result in the file starting from a new line (record) will be passed n elements of array a . Line, starting from which the data
will be transmitted is determined by the rule:
if the file is set on line line , then new data will be added starting from line line + 1. Moreover, since access to the file
 155
156
O. V. Barteniev. Modern FORTRAN
sequential, all data after line line will be
"overwritten" (replaced with newly displayed ones). In general, for list-driven output, each output statement creates one
record, if the length of the created record does not exceed 79 characters. Number fields in the created record is equal to the number of items in the output list. If
more characters are required to place the output elements, then new records are created. As separators between fields, the operator WRITE uses spaces.
5. Operator CLOSE (2) closes the file a.txt - detaches the file from devices 2.
Let us now consider how to enter the entire file or all of its first numeric fields to the allocated array. First you need to calculate how much data you can enter from
a file, then allocate memory for the array, "rewind" file to its beginning and enter data into the array. For instance:
integer, parameter :: nmax = 10000 integer, parameter :: unt = 3 integer :: ios, i, n
character (60) :: fn = 'a.txt'
​ ! We use the file of the previous example real tmp              ! Using tmp to count
​ real, allocatable :: a (:) ​ ! consecutive numbers in the file;
! tmp is of the same type as array a
open (unt, file = fn, status = 'old') read (unt, *, iostat = ios) (tmp, i = 1, nmax) if (ios == 0) stop 'Can't enter whole file'
n = i - 1
! n - number of input
data
allocate (a (n))

! Allocate memory for
array a
rewind unt
! Go to the beginning
of the file
read (unt, *) a
! Input array a
close (unt)
write (*, '(1x, 5f5.2)') a (: n)
deallocate (a)
end
! Close the file
4.13.2. I / O two-dimensional array
Suppose you need to enter data from the b.txt file into a two-dimensional array a (1: 3, 1: 4). Let's enter the data into the b.txt file so that the file line matches one
row of array a (1: 3, 1: 4):
11 12 13 14
21 22 23 24
31 32 33 34
 Then the input of the array line by line can be performed in a loop
do i = 1, 3
read (2, *, iostat = ios) (a (i, j), j = 1,
4) end do
! or a (i, 1:
4)
156
157
4. Arrays
To enter the i- th line of the array, a cyclic list is used again.
In principle, with list driven input of a two dimensional array, one can use and nested looping list:
read (2, *, iostat = ios) ((a (i, j), j = 1, 4), i = 1, 3)
Such an operator will also provide input into array a line by line (parameter j changes faster ). However, the input data is not must be placed in three lines, 4
numbers in each. They can be placed, for example, like this:
11 12 13 14 21 22 23 24 31 32 33 34
in the columns of the array (that is, their order in the file is the same as the order of theirIf the location of the data in the file corresponds to their location placement
in the computer memory), for example:
21 31
22 32
23 33 14 24 34 or like this:
11 21 31 12 22 32 13 23 33 14 24 34
then the input of the entire array can be performed with the operator
read (2, *, iostat = ios) a
The control output of the array to the screen line by line is organized in a loop
do i = 1, 3
​ write (*, *) (a (i, j), j = 1, 4)
​ ! or a (i, 1: 4)
end do
Comment. In the examples we have considered, the files were organized sequential access method, in which only read and data recording. Editing individual
entries in a file becomes possible with a direct access method (Ch. 10).
 157
158
5. Expressions, operations and assignment
This chapter summarizes information about expressions and operations. Operations are used to create expressions, which are then used in Fortran operators.
Fortran operations are divided into built-in and defined programmer (overloaded).
Built-in operations:
arithmetic;
symbolic concatenation operation (concatenation of character strings);
relationship operations;
brain teaser.
Symbolic expressions and the concatenation operation are not discussed in this chapter. considered as detailed in Sec. 3.8.5.
Some arithmetic operations are implemented in Fortran in the form built-in functions such as modulo, truncation, and rounding, bitwise operations, etc.
Consideration of built-in functions completed in the next chapter.
Expressions are classified into scalar and array expressions. The result of an array expression is an array or a slice of it. By at least one of the operands of an array
expression must be an array or a section of an array, for example:
real :: a (5) = (/ (i, i = 1, 5) /)
​ a (3: 5) = a (1: 3) * 2
​ ! Returns (1.0 2.0 2.0 4.0 6.0)
5.1. Arithmetic expressions
The result of an arithmetic expression can be the value of an integer, or real, or complex type or an array (section) of one of these types. The operands of an
arithmetic expression can be:
arithmetic constants;
scalar numeric variables;
numeric arrays and their sections;
calls to functions of integer, real and complex types.
5.1.1. Performing arithmetic operations
Arithmetic operations differ in priority:
​ **
​ Exponentiation (highest priority operation)

*, /
​ multiplication, division; single (unary) + and -;
+, - addition, subtraction.
158
159
5. Expressions, operations and assignment
Comment. In Fortran, unlike SI, unary operations cannot precede the sign of another operation, for example:
k = 12 / -a ​ ! Error k = 12 / (-a)
​ ! Right
Fortran operations, other than exponentiation, are performed on the left to the right according to priority. Exponentiation operations are executed from right to left .
So, the expression -a + b + c will be executed in in the following order: (((-a) + b) + c). And the expression a ** b ** c is calculated like this:
(a ** (b ** c)). Subexpressions enclosed in parentheses are evaluated primarily.
Example:
​ k = 2 * 2 ** 2/2/2 ​ ! 2
! Let's illustrate the sequence of calculations by placing parentheses:
​ k = ((2 * (2 ** 2)) / 2) / 2
​ ! 2
! Let's illustrate the effect of parentheses on the result of an expression k = 2 ** 8/2 + 2              ! 130 k = 2 ** (8/2 + 2)              ! 64 k = 2 ** (8 / (2 +
2))              ! 4
In arithmetic expressions, it is prohibited:
 divide by zero;
raise an operand equal to zero to a negative or zero power;
raise a negative operand to a non-integer power.
Example:
​ a = (-2) ** 2.2
​ ! Error - violation of the last constraint
5.1.2. Integer division
Consider a simple program:
real (4) dp, dn dp = 3/2 dn = -3 / 2
print *, dp, dn
​ ! 1.0 -1.0 end
Programmers observing integer division for the first time will surprised to see 1.0 and -1.0 as the result instead of what they expected
1.5 and -1.5. However, the result has a simple explanation: 3, -3 and 2 are integers numbers and the result of division will also be integers - the integer part of the
number 1.5 and the integer part of the number -1.5, that is, 1 and -1. Then, since the variables dp and dn are of type REAL (4), integers 1 and -1 will be
converted into a standard float type.
159
160
O. V. Barteniev. Modern FORTRAN
To get the expected result from the point of view of ordinary arithmetic, in the program you can write:
dp = 2.0 / 3.0 or dp = 2 / 3.0 or dp = 2.0 / 3
You can also use the explicit conversion functions integer data type to real (Section 6.5) and write, for example,
d = float (2) / float (3) or d = real (2) / real (3)
Some more examples of integer division:
** (-2) returns 0 (integer division);
2.0 ** (-2) returns 0.25 (no integer division);
​ -7/3
​ returns -2;
​ 19/10​ returns 1;
1/4 + 1/4 returns 0.
5.1.3. Rank and types of arithmetic operands
In Fortran it is allowed to use in arithmetic expression operands of different types and varieties of types. In this case, the result is each operation of an expression is
defined according to the following rules:
 if the operands of the arithmetic operation are of the same type,then the result of the operation is of the same type. This rule is good illustrated by
integer division;
if the operands of the operation are of different types, then the result of the operationhas the highest rank operand type.
Rank of types of arithmetic operands (given in descending order):
COMPLEX (8) or DOUBLE COMPLEX - the highest rank;
COMPLEX (4);
REAL (8) or DOUBLE PRECISION;
REAL (4) or REAL;
INTEGER (4) or INTEGER;
INTEGER (2);
INTEGER (1) or BYTE is the lowest rank.
Example:
integer (2) :: a = 1, b = 2
real (4) :: c = 2.5 real (8)
d1, d2
d1 = a / b * c
!
0.0_8
d2 = a / (b * c)
!
0.2_8
When calculating d 2, the multiplication operation is performed initially, but first the number 2 of type INTEGER (2) is converted to type REAL (4). Further
160
161
5. Expressions, operations and assignment

the division operation is performed, and again it is preceded by the transformation types: number 1 of type INTEGER (2) is converted to type REAL (4).
Expression returns 0.2 of type REAL (4), which, however, as a result of the assignment converts to type REAL (8). In this case, the types of the operands of the
expression variables a and b are of course preserved.
In some cases, in expressions, for example, a real type with integer operands to avoid integer division, you should do an explicit data type conversion, for example:
integer :: a = 8, b = 3 real
c
c = 2.0 ** (a / b)
! 4.0
c = 2.0 ** (float (a) / float
(b))
!
6.349604
Built-in math functions with specific names require the exact type of the argument, for example:
real (4) :: a = 4 real (8) ::
b = 4, x
x = dsqrt (a)
! Error: parameter type must
be REAL (8)
x = dsqrt (b)
! Right
 Converting a number to a larger variety of type, for example from REAL (4) to REAL (8) can lead to precision distortion, for example:
real (4) :: a = 1.11
real (8) :: c c = a
print *, a
! 1.110000
print *, c
! 1.110000014305115
At the same time, if you immediately start working with the REAL (8) type, then the accuracy is saved, for example:
real (8) :: c
c = 1.11_8
! or c = 1.11d0
print *, c
! 1.110000000000000
Distortion of the value can also occur when moving to a lower varieties of type, for example:
integer (2) :: k2 = 325
integer (1) :: k1
​ ! -128 <= k 1 <= 127 k1 = k2
print *, k2
​ ! 325 print *, k1
​ ! 69
5.1.4. Rounding errors
It should be borne in mind that arithmetic expressions with real and complex operands are calculated imprecisely, i.e. a rounding error occurs when they are
calculated . In some cases
161
162
O. V. Barteniev. Modern FORTRAN
neglect of such an error leads to the creation of inoperable programs, for example, the next loop is infinite, since x because of a rounding error, it does not accept a
value exactly equal to 1.0.
Example:
real :: x = 0.1
do
print *, x x = x + 0.1
! Endless cycle
if (x == 1.0) exit end do
! EXIT - loop exit
operator
 The normal completion of the cycle can be ensured as follows:
real :: x = 0.1
do
print *, x x = x + 0.1
if (abs (x - 1.0) <1.0e-5) exit ! x is almost 1.0
end do
! ABS ( x - 1.0)
returns | x - 1.0 |
General takeaway from the above example: cannot be compared real numbers for exact equality or inequality, and they should be compared with some precision.
The effect of round-off errors can be reduced by properly shaping the order of calculations. Let, for example, be declared and initialized variables x , y and z : real
(4) :: x = 1.0e + 30, y = -1.0e + 30, z = 5.0
Their sum is 5.0. However, we will find and display their sum like this:
​ print *, x + (y + z)
​ ! 0.000000E + 00 (error)
The result is wrong. The correct sequence is calculations:
​ print *, (x + y) + z
​ ! 5.000000 ​ (right)
5.2. Relational Expressions and Boolean Expressions
A relation expression compares the values  of two arithmetic or symbolic expressions. An arithmetic expression can be compared with a symbolic expression.
Moreover, the arithmetic expression treated as character - a sequence of bytes. The result
relationship expression is .TRUE. or .FALSE ..
The operands of a relation expression can be both scalars and arrays or their sections, for example:
​ (/ 1, 2, 3 /)> (/ 0, 3, 0 /) ​ ! Returns an array (TFT)
Relationship operations can be written in two forms:
​ .LT. or <
​ less;
 162
163
5. Expressions, operations and assignment
.LE. or <= less or equal;

.GT. or> more;
.GE. or> = greater than or equal;
.EQ. or == is equal;
.NE. or / = not equal.
Spaces in the notation of an operation are an error:
a. le. b
​ ! Error. Correct: a .le. b a <= b
​ ! Error. Correct: a <= b
All operations of the relation are binary (binary) and must appear between operands. Left relation operations are performed right.
If in the expression of the relation one operand has a real, and another integer type, then before performing the operation the integer operand converts to real type.
Relation expressions with character operands are compared character by character. Comparison of character codes is actually performed compared strings.
When comparing strings of different lengths, the short string is increased to the length of a larger line by adding trailing spaces, for example 'Expression'> 'Exp1'
evaluates to 'Expression '>' Exp1 '(here the symbol stands for a space).
The operands of a relation expression can also be of complex type.
In this case, only .NE operations can be applied. (/ =) and .EQ. (==).
Boolean expressions result in boolean true -
.TRUE. or false - .FALSE .. Boolean expression operands can be:
logical constants, variables and functions;
arrays of logical and integer type and their sections;
expressions of attitude;
integer constants, variables and functions.
Logical operations:
​ .NOT. logical NOT (negation);
​ .AND.
​ logical AND;
​ .OR. ​ logical OR;
​ .XOR.​ logical exclusive OR;
​ .EQV.​ equivalence;
.NEQV. inequality.
All logical operations, except negation, are binary. Logical operation .NOT. is unary and comes before the operand. Logical operations are performed from left to
right.
 163
164
O. V. Barteniev. Modern FORTRAN
Table 5.1 shows the results of logical operations on logical variables x and y , which take the values true (AND) and false (L).
Table 5.1. Truth table
x
y
x .AND. yx .OR. y
.NOT. x x .XOR.
y
x .EQV. yx .NEQV.
y
AND AND
​ AND ​
AND
L
L
​ AND ​
L
AND L
​ L
​
AND
L
AND
​
L
​ AND
L
AND
​ L
​
AND
AND
AND
​
L
​ AND
L
L
​ L
​
L
AND
L
​ AND ​
L
Boolean operands must be of Boolean type. but
CVF and FPS also accept integer operands. In that
In the case, logical operations are performed bit by bit. If the operands have different varieties of the integer type, then the conversion is performed types - the
lower rank integer operand is converted to an integer highest rank type. Boolean expression with integers operands has the result of an integer , not a boolean
type, for example:
​ write (*, *) 2 # 1000 .or. 2 # 0001 ​ ! 9 (= 1001)
​ write (*, *) 8 .or. 1
​ ! nine
Often boolean expressions with integer operands are used to mask certain categories.
An example of masking the high byte:
integer (2) :: mask = # 00ff
! The mask mask and the number
k are given in
integer (2) :: k = # 5577
! hexadecimal number system
write (*, '(z)') mask .and. k
! 77 (hexadecimal)
Relational and logical operations are performed on the left to the right, that is, if two consecutive operations have equal priority, the left operation is performed
initially.
An example . Evaluate the result of a boolean expression
x / a == 1 .or. b / (a  + b) <1 .and. .not. b == a .or. x / = 6
at x = 6.0, a = 2.0 and b = 3.0.
Having calculated the result of arithmetic and relation operations, we get:
.false. .or. .true. .and. .not. .false. .or. .false.
Next, we perform step by step logical operations taking into account them priority. After doing .not. .false .:
.false. .or. .true. .and. .true. .or. .false.
After executing .true. .and. .true .:
.false. .or. .true. .or. .false.
 164
165

5. Expressions, operations and assignment
The final result : . TRUE .
An example . Write down the condition of a point hitting an area that is the intersection of the ellipse and the triangle formed by the graphs of the functions y = | x |
and y = 2 (Fig.5.1).
​ y
​ if (x ** 2/4 + y ** 2 <1.0 .and. y> abs (x)) then
write (*, *) 'Inside'
​ 1
​ else
​ x
​ write (*, *) 'Outside'
end if
2
Figure: 5.1. Study area
A boolean variable can be assigned an integer value an expression that is interpreted as true if nonzero, and as false if equal to zero. On the other hand, logical
values can be used in arithmetic expressions. In this case .TRUE.
is interpreted as one and .FALSE. - as zero. And as a consequence of this properties, the result of a boolean expression can be assigned a numeric variable.
However, if a boolean variable like g 1 got its value, for example 11, as a result of calculating an integer expression, then with the subsequent use of g 1 in
arithmetic expression, its value will be 11, not one. For instance:
integer :: k = 22, m = 0 logical g1,
g2 g1 = k / 2; g2 = m * k
print *, g1, g2
! TF
print *, 3 * g1, 3 * (. not.g2), 3 **
g2 k = .not. g1 .or. .not. g2
! 33
-3 1
print *, k
! -1
Comment. CVF and FPS properties to mix logical and integer data is an extension with respect to Fortran 90 standard.
5.3. Defined operations
Inline operations (single and double) action can be extended to derived data types for which there is no no built-in operations are defined. Area expansion
mechanism
the action of an operation is called operation overloading . In addition, they can additional operations to be specified.
 Mechanism for overloading and setting a binary operation x op y : 165
166
O. V. Barteniev. Modern FORTRAN
compose a function fop with two required parameters x and y , having the form of an IN connection, which will be called to implement
the specified operation op with the operands x and y and will return the result of the operation;
use the INTERFACE OPERATOR ( op ) to bind the function fop with op operation .
Then the result of the operation x op y will be returned by the function fop ( x , y ) value, i.e. the following operators are equivalent:
z = x op y z = fop (x, y)
The mechanism for setting and overloading a single-seat operations (Section 8.12.2).
An example . Set the operation for calculating the percentage of x of y .
interface operator (.c.)
! 
Linking
operation .c.
real (4) function percent (x, y)
real (4), intent (in) :: x, y
end function percent end interface
! with percent
function
print '(1x, f5.1)', 5.0 .c. 10.0
! 50.0
print '(1x, f5.1)', percent (5.0,
10.0) end
! 50.0
real (4) function percent (x, y)! This function is called when
real (4), intent (in) :: x, y
​ ! performing operation .c. percent = x / y * 100.0
end function percent
Comment. The function that implements the operation can be modular procedure (Section 8.12.2).
The specified operation must always be surrounded by dots. Types operands of the specified operation must strictly correspond to the types parameters of the
function called during the operation. So, in our example attempt to perform operation 5 .c. 10 will result in an error, since the operand types are different from
REAL (4).
When overloading operations, relations, for which there are two forms, overloading applies to both forms operations. For example, if the operation> = is
overloaded, then in the same way will be overloaded and the operation .GE ..
The mechanisms for setting and overloading operations are described in more detail. in sect. 8.12.
166
167
5. Expressions, operations and assignment
5.4. Operation priority
When arithmetic, symbolic, logical and operations relations are present in one expression (such a mixture may be, for example, in a logical expression), the priority
of the operations as follows (given in descending order):
any given or overloaded one-place operation;
arithmetic operations;
symbolic concatenation operation;
relationship operations;
logical operations;
any given or overloaded two-place operation.
Table 5.2 Fortran's built-in operations are in order decreasing priority.
Table 5.2. Precedence for inline operations

​ ** *
​ +
​ //
​ .EQ., ==
​ .NOT. .AND.
​ .OR. ​ .XOR.
​ /
​ -
​ .NE., / =
​ .EQV.
​ .LT., <
​ .NEQV.
 .LE., <= .GT.,>
.GE.,> =
Comment. Each cell of the table contains operations with equal priority.
5.5. Constant expressions
Fortran declaration statements may contain expressions
(for example, when specifying the values  of named constants), but such expressions must be initializing and constant , for example:
integer, parameter :: n = 10, m = n / 2
​ real a (m, n), b (2 * n)
​ ! n / 2 and 2 * n are examples of constant expressions
In general, a constant expression is an expression in which everything the operations are inline, and each simple element is:
constant expression enclosed in brackets;
constant or constant subobject, in which each section indexor the substring boundary is a constant expression;
array constructor, in whose expressions (including boundaries and steps)each simple member is a constant expression, or an implicit loop variable;
167
168
O. V. Barteniev. Modern FORTRAN
a structure constructor whose components are constantexpressions;
call to the built-in element or transform function,all parameters in which are constant expressions;
access to the built-in help function (except for the PRE-
SENT, ASSOCIATED, or ALLOCATED), in which each parameter is
it is either a constant expression or a variable that is returned
reference. Moreover, the boundaries of the variable about which the certificate is issued are should not be implied (case of array or string, resizing) or specified
using the ALLOCATE statement or by attaching a link.
Named constants (objects with the PARAMETER attribute) can only be assigned values  of initializing constants
expressions. The values  of such expressions are evaluated at compile time, and therefore, additional restrictions are imposed on them: • only exponentiation with a
whole exponent is allowed;
arguments and results of inline element functions must bewhole or text type;
of the transformation functions, only REPEAT, RE-
 SHAPE, SELECTED_INT_KIND, SELECTED_REAL_KIND, TRANSFER and TRIM.
Each element of the initialization expression must be defined in the preceding declaration statement or to the left in the same the declaration statement itself.
Example:
character (*), parameter :: st (3) = (/ 'January', 'February', 'March' /) integer, parameter :: n = len_trim (st (2))
5.6. Descriptive expressions
When specifying varieties of types in procedures parameters, boundaries arrays and text lengths of data objects, as well as when setting function results can be
used along with constant scalar, non-const expressions. Such expressions are called descriptive and contain a number of restrictions:
they can only depend on those values  that are defined at the entrance to the procedure;
types and type parameters of variables of a descriptive expression mustdeclared earlier than their use in an expression, except cases when the type of a variable is
determined according to the rules default about data types.
168
169
5. Expressions, operations and assignment
Descriptive expressions can include constructors arrays, derived types and calls to built-in functions. But the latter are limited:
element functions with parameters and the result of an integer ortext type;
the REPEAT, RESHAPE, TRANSFER and TRIM functions with parameterswhole or text type;
help functions, except for the PRESENT, ASSOCIATED functionsand ALLOCATED, provided that the value for which information thrown, does not depend on
memory allocation and link attachment.
In a reference to the reference function, the object under study can be accessible through use -association or by associating through media or can be declared in
the same software component, but required before using it in a reference function. Per item an array declared in a program component can be referenced only after
describing its boundaries.
 Example:
function fun (x, y, lob)
real x
! First, we declare x
real (kind (x)) y, fun
! Now you can use x in a
descriptive
integer lob (2)
! expression
real, dimension (lob (1): max (lob (2), 10)) :: z real wz (lob (2): size (z))
! A variant of the type of the y variable and the resulting variable
! fun , the boundaries of the arrays z and wz are given by descriptive expressions.
5.7. Assignment
An assignment is an operator that results in the variable gets the value of the operator located on the right side expression assignment. The variable that receives the
value of the expression can be either a scalar or an array. As a result of the assignment values  can be received by both objects and their subobjects, for example
array elements, substrings, components of variable derivatives types, sections of arrays. Operator syntax:
var = expr
where var is the name of the variable; expr is an expression.
According to the standard in the case of inline assignment, the types variable var and the expression expr must match:
• the result of an arithmetic expression can be assigned a numeric variable. If the variable and expression have different numeric
169

170
O. V. Barteniev. Modern FORTRAN
types, then the type of the expression result is cast to the type of the variable, to which the result is assigned, for example:
complex :: z = (-2.0, 3.0) integer k k = z * z
​ print *, k
​ ! -five
the result of a logical expression can be assigned to a logicalvariable;
the result of a symbolic expression can only be assignedsymbolic variable;
a variable of a derived type can be assigned the value of an expressionof this type, for example:
type pair
real x, y
 end type pair type (pair) :: p1, p2 = pair (1.0, 2.0) p1 = p2
p2 = pair (-2.0, -5.0)
However, as we have already seen, CVF and FPS have in relation to the language standard: a boolean variable can be assigned the result of an integer expression
and, conversely, a numeric variable you can assign the result to a boolean expression.
You can, however, perform an assignment overload . For example, you can specify an assignment operator where var is numeric and expr is character type. Or set
an assignment in which the variable of a derived type, the result of an expression of a different type is assigned. The assignment overload is done like this:
create a subroutine sub with two optional parameters x and y , moreover, parameter x must have the form of connection OUT, parameter y - IN. As a result of the
work of the subroutine, the value of x is determined ;
using​ operator INTERFACE ASSIGNMENT (=),
​ to tie subroutine sub with the assignment operator. Then the subroutine will be called every time var is
of the same type as x , and
the type of expr is the same as the type of the parameter y , i.e. the assignment x = y
is equivalent to calling call sub ( x , y ).
An example . Assign an integer variable to the sum of character codes strings.
interface assignment (=) subroutine charti (n, ch) integer, intent (out) :: n character (*), intent (in) :: ch
 170
171
5. Expressions, operations and assignment
end subroutine charti
end interface integer k, m
character (80) :: st = 'String to count'
​ k = st (: 10)
​ ! The specified assignment is performed
​ call charti (m, st (: 10)) ​ ! This call is equivalent to m = st (: 10)
print *, k, m
​ ! 890 890 end
subroutine charti (n, ch)
integer, intent (out) :: n character (*), intent (in) :: ch integer i n = 0
do i = 1, len_trim (ch)
n = n + ichar (ch (i: i))
end do
end subroutine charti
Comment. The subroutine implementing the assignment can be modular procedure (Section 8.7).
More details on assignment overloading are discussed.
in sect. 8.12.2.
 171
172
6. Built-in procedures
6.1. Types of built-in procedures
Built-in procedures are divided into 4 types:
elemental procedures . The parameters of such procedures can be as follows scalars as well as consistent arrays. When the parameters are arrays, each element of
the resulting array is equal to the result applying the procedure to the corresponding array elementsparameters. Among the elemental procedures, there is one
subroutine MVBITS. The rest are functions. The resulting array must be consistent with parameter arrays;
help functions provide information about the properties of parameters functions. The result of the reference function is independent of the value parameter, which,
in particular, can be undefined;
transforming functions ;
non-elementary subroutines .
In addition to the built-in CVF and FPS, they have a large number of additional
procedures, a list of which is given in Appendix. 3.
6.2. Handling keywords
Since built-in procedures have an explicit interface, they can be invoked with keywords. For instance:
pi = asin (x = 1.0)
​ ! x is a keyword y = sin (x = pi)
173
! not broken, the use of keywords is optional
6. 
Built-in
procedures
print 1, maxval (array, dim = 1, mask = array <4)
! 1 2 3
print 1, maxval (array, dim = 1) ! The use of keywords is required
! 4 5 6
print 1, maxval (array, mask = array <4, dim = 1)
! 1 2 3
print 1, maxval (array, mask = array <4)
1 format (3i3) end
! 3
Formal names are used as keywords.

parameters. These names appear in the description of each built-in procedures. The need for such calls arises only when working with procedures that have
optional parameters, and in the event that when the natural order of the parameters changes. Sometimes the use of keywords makes the challenge more
descriptive.
An example . MAXVAL ( array [, dim ] [, mask ]) function for finding maximum values  in the array has two optional parameters dim and mask .
integer array (2, 3) array = reshape ((/ 1, 4, 5,
2, 3, 6 /), (/ 2, 3 /))
! Array array : 1 5 3
!
​ 4 2 [1]
! Natural order of parameters. Call without
keywords
print 1, maxval (array, 1, array <4)
! 1 2
3
print 1, maxval (array, 1)
! Keyword call; however since the order of the
parameters
172
! 4 5
6

generic is the function name MAXVAL from the one just given example. In practice, this means that the type of the result of such a function depends on the type of
the required parameter. So, the function can take in as the array parameter, an array of any integer or real type.
The type and value of the MAX- function's result type variation parameter VALs are the same as array parameter . Generic names for built-in functions cannot be
used as actual parameters of procedures (Section 8.18.2).
A number of built-in functions have specific names, and their call can be performed both by the generic and by the specific name.
The call with the generic name and the type parameter type is equivalent to calling with a specific name with the same parameter type.
Example:
real (4) :: x = 3.0
real (8) :: y = 3.0
! LOG - generic name
complex (4) :: z = (3.0,
4.0)
! CLOG - specific name
print *, log (x)
! 1.098612
print *, log (y)
! 1.098612288668110
print *, log (z)
! 
(1.609438,
9.272952E-01)
print *, clog (z)
! 
(1.609438,
9.272952E-01)
Comment. Calling the LOG function with an integer parameter unacceptable, because otherwise it would not be clear in what a valid type (real or complex)
follows automatically convert an integer argument. The same is true for others. mathematical functions.
Specific function names can be used as procedure parameters (see Table 8.3 in Section 8.18.2) with the exception of names indicated in table. 8.4. Specific names
are also used when
it is necessary to make it obvious to the programmer used in the calculations data type.
 173
174
O. V. Barteniev. Modern FORTRAN
The following description of built-in procedures will mention only their generic names. For inquiries regarding their specific names we again refer to table. 8.3 and
8.4 in Sections. 8.18.2.
6.4. Function return value
A number of functions, such as RANGE or INDEX, return a value standard integer type (INTEGER). By default this type equivalent to INTEGER (4). However,
if the option is applied compiler / 4I2 or the $ INTEGER: 2 directive, then the returned function, the result is of type INTEGER (2). This also changes the default
boolean data type, i.e. function a standard boolean type such as ASSOCIATED would be return a result of type LOGICAL (2), not LOGICAL (4).
The same is true for functions that return a value standard real type, which by default is equivalent to
REAL (4). However, if the user specifies the compiler option / 4R8 or directive $ REAL: 8, then the result returned by the function has the type REAL (8).
6.5. Element Data Type Conversion Functions
Operands of different types can be used in Fortran expressions.
During calculations, data types will be converted in accordance with the rank of the operand types. However, an explicit conversion is often required types, for
example to avoid integer division or correctly refer to the function. For such purposes, the functions are used data type conversions. For instance:
integer :: a = 2, b = 3
​ print *, sin (float (a + b))
​ ! -9.589243E-01
AIMAG ( z ) - Returns the imaginary part of the complex argument z .
The result is a real type with the variation parameter the same as like z .
INT ( a [, kind ]) - converts the parameter a in a type of a parameter kinds of kind by clipping the value of a towards zero. A type parameter a - integer, real or
complex. If the parameter a complex type, then the real part is converted to the whole type by clipping towards zero. If the kind parameter is absent, then the
result is of the standard integer type. The kind type is INTEGER.
Similar conversions, but with a fixed result type performed by the following functions:
Function
Parameter types
Result type
INT1 ( a )
Whole, real or complex
INTEGER (1)
174
175
6. Built-in procedures
​ INT2 ( a )
​ "
​ "
​ "
​ "
​ INTEGER (2)
​ INT4 ( a )
​ Whole, real or complex ​ INTEGER (4)
​ HFIX ( a )
​ "
​ "
​ "
​ "
​ INTEGER (2)
​ JFIX ( a )
​ "
​ "
​ "
​ "
​ INTEGER (4)
 IZEXT ( a ), JZEXT ( a ) and ZEXT ( a ) - converts booleans and integers values  to an integer type with a large flavor parameter value. The
conversion is done by adding zeros to the fresh bits result:
​ Functions
​ Parameter types
Result type
IZEXT ( a ) ​ LOGICAL (1), LOGICAL (2), BYTE,
INTEGER (1), INTEGER (2)
INTEGER
(2)
JZEXT ( a ) ​ LOGICAL (1), LOGICAL (2), LOGICAL
(4), and ZEXT ( a )              BYTE, INTEGER (1),
INTEGER (2), INTEGER (4)
INTEGER
(4)

REAL ( a [, kind ]) - converts parameter a to real type with
a kind parameter . Parameter type a - integer, real or
complex. If the kind parameter is absent, then the result is
standard real type. If the parameter a is of complex type,
then the result of a real parameter variations such as kind , if
the kind is given, and with the same type parameter as a if
kind omitted.
DBLE ( a ) and DFLOAT ( a ) - convert integer, real or a
complex parameter a to the real type REAL (8).
CMPLX ( x [, y ] [, kind ]) - converts integers, real or
complex parameters to complex type with variant parameter
kind . If kind is omitted, the result is COMPLEX (4). If y is
given, then x is the real part of the complex result. The
parameter y cannot be given if x is of complex type. If y is
given, then it is imaginary part of a comprehensive result. If
x and y are arrays, then they must be consistent.
Example:
complex z1, z2 complex (8) z3
z1 = cmplx (3)
​ ! Returns 3.0 + 0.0 i z2 = cmplx (3,
4)
​ ! Returns 3.0 + 4.0 i
z3 = cmplx (3, 4, 8)
​ ! Returns a COMPLEX (8) number 3.0d0 +
4.0d0 i
DCMPLX ( x [, y ]) - performs the same transformations as the function
CMPLX, but the result type is always COMPLEX (8). The type of parameters x and y is whole, real or complex.
175
176
O. V. Barteniev. Modern FORTRAN
LOGICAL ( L [, kind ]) - converts a boolean value from one variety to another. The result has the same meaning as L and the parameter variety kind . If kind is
absent, then the type result of LOGICAL.
TRANSFER ( source , mold [, size ]) - converts source data to another type without changing the physical representation of the data, i.e., the values  of individual
the bits of the result and source are the same. Result type and parameters the same as mold .
Let the physical representation of source be a sequence of n bits b 1 b 2 ... b n , and mold takes m bits, then the result is:
when n = m is equal to b 1 b 2 ... b n ;
for n < m - b 1 b 2 ... b n s 1 s 2 ... s m - n , where the bits s i are not defined; for n > m - b 1 b 2 ... b m .
If mold is a scalar and size is omitted, then the result is a scalar.
If the mold array and size are omitted, then the result is a one-dimensional array, the size of which is sufficient to accommodate source . If the size parameter is
given, the result is a one-dimensional array of size .
 Below are the elemental functions for converting a symbol to its integer representation and inverse transform functions, returning a character by its
code. For a description of the functions, see Sect.
3.8.8.
Function
Parameter type
Result type
ICHAR ( c )
CHARACTER (1)
INTEGER (4)
IACHAR ( c )
"
"
CHAR ( i [, kind ])
Whole
CHARACTER
(1)
ACHAR ( i )
"
"
6.6. Elemental numeric functions
ABS ( a ) - absolute value of integer, real or complex argument. If a is of integer type, then the result is also of integer type, otherwise cases, the result will be real.
For a complex argument a = x + yi : ABS ( a ) = SQRT ( x ** 2 + y ** 2).
Example:
complex (4) :: z = (3.0, 4.0)
​ write (*, *) abs (z)
​ ! 5.0 ​ (result type - REAL (4))
AINT ( a [, kind ]) - truncates the real value a towards zero to an integer and outputs the result as a real value, kind of which is the same as kind if
176
177
6. Built-in procedures
it is given, or - otherwise - with a standard variation real type.
ANINT ( a [, kind ]) - returns an integer as a real value the number closest to the value of the real argument a (performs rounding a ). A variation of the result type
is the same as the value argument kind , if given, or otherwise with the standard a kind of real type.
NINT ( a [, kind ]) - returns the integer closest to the value a real argument a (rounds a ). Variety of type of the result matches the value of the argument kind , if
specified, or - in otherwise, with the standard variant of the integer type.
Example:
real :: a (3) = (/ 2.8, -2.8, 1.3 /)
write (*, *) anint (a)
! 
3.000000
-3.000000 1.000000
write (*, *) nint (2.8), nint (2.2)
! 3 2
write (*, *) nint (a (2)), nint (-2.2) ! -3 -2
write (*, *) aint (2.6), aint (-2.6)

! 
2.000000
-2.000000
 CEILING ( a [, kind ]) - Returns smallest integer greater than or equal to the value of the real argument a . A variation of the result type matches the
value of kind , if given, or otherwise case - with a standard variant of the integer type. Optional parameter added by 1995 standard
CONJG ( z ) - Returns the complex number conjugated to the value complex argument z .
Example: print *, conjg ((3.0, 5.6)) ​ ! (3.000000, -5.600000)
DIM ( x, y ) - Returns x - y if x > y , and 0 if x ≤ y . The x and y arguments must be both integer or real.
Example:
​ print *, dim (6, 4), dim (4.0, 6.0)
​ ! 2 0.000000E + 00
DPROD ( x , y ) - Returns double precision product - REAL (8). The x and y arguments must be of the standard float type.
Example:
real :: a = 3.72382, b = 2.39265 write (*, *) a * b, dprod (a, b)
​ ! Result :
​ 8.9097980 ​ 8.90979744044290
FLOOR ( a [, kind ]) - returns the largest integer less than or equal to the value of the real argument a . A variation of the result type matches the value of kind , if
given, or otherwise
177
178
O. V. Barteniev. Modern FORTRAN
 case - with a standard variant of the integer type. Optional parameter added by 1995 standard
Example for CEILING and FLOOR:
integer i, iarray (2)
i = ceiling (8.01)
! Returns
nine
i = ceiling (-8.01)
! Returns
-8
iarray = ceiling ((/ 8.01, -5.6 /))
! Returns (9, -5)
i = floor (8.01)
! Returns
8
i = floor (-8.01)
! Returns
-nine
iarray = floor ((/ 8.01, -5.6 /), kind =
2)
! Returns (8, -6) of type
INTEGER (2)
MOD ( a , p ) - returns the remainder of division of a to p , ie MOD (.. A, p ) = a -
- INT (a / p ) * p . Parameters a and p must be either both integers or both real. If p = 0, then the result is undefined.
Example:
​ write (*, *) mod (5, 3), mod (5.3, 3.0)
​ ! 2 2.300000
MODULO ( a, p ) - Returns a modulo p . Parameters a and p must be either both integers or both real. The result r is such that
a = q * p + r , where q is an integer; | r | < p , and r has the same sign as p. If p = 0, then the result is undefined. For real a and p MODULO ( a, p ) = a -
FLOOR ( a / p ) * p .
Example:
print *, modulo (8, 5)
!
​ 3
(q =
1)
print *, modulo (-8, 5)
!
​ 2
(q =
-2)
print *, modulo (8, -5)
!
​ -2
(q =
-2)
print *, modulo (7.285, 2.35)
! 2.350001E-01
(q =
3)
print *, modulo (7.285, -2.35)
!
​ -2.115
(q =
-4)
SIGN ( a, b ) - returns the absolute value of a multiplied by +1, if b ≥ 0, and - 1 if b <0. Parameters a and b must be either both integer, or both are real.
An example . The SIGN function will return 1.0 if its second argument is ya is greater than or equal to zero, and -1.0 otherwise.
result = sign (1.0, ya)
6.7. Calculating the maximum and minimum
The functions for finding the maximum and minimum are elemental and are applicable to numeric data of real and integer types. Names MAX and MIN are
generic.
AMAX0 ( a 1, a 2, [, a 3, ...]) - returns the maximum of two or more values  of the standard integer type. The result is standard real type.
 178
179
6. Built-in procedures
MAX ( a 1, a 2, [, a 3, ...]) - returns the maximum of two or more integers or real values. Result type and variety match the type of the parameters.
MAX1 ( a 1, a 2, [, a 3, ...]) - returns the maximum of two or more values standard real type. The result is of the standard integer type.
AMIN0 ( a 1, a 2, [, a 3, ...]) - returns the minimum of two or more values standard integer type. The result is of the standard real type.
MIN ( a 1, a 2, [, a 3, ...]) - returns the minimum of two or more integers or real values. Result type and variety match the type of the parameters.
MIN1 ( a 1, a 2, [, a 3, ...]) - returns the minimum of two or more values standard real type. The result is of the standard integer type. In all cases, function
parameters are scalar expressions.
Example:
write (*, *) max1 (5.2, 3.6, 9.7) ! nine
write (*, *) amin0 (5, -3, 9)
!
-3.0
6.8. Mathematical element functions

Fortran contains mathematical functions for calculating the root, logarithms, exponentials and trigonometric functions. Type and parameter the flavors of the result
type are the same as the first argument. AT This section shows the forms of calling functions with generic names.
Specific function names are given in Sec. 8.18.2.
When the parameters of logarithmic and trigonometric functions are complex numbers, the functions return a complex number,
whose argument ϑ is equal to the principal value of the argument of the complex numbers in radians (-π <ϑ ≤ π).
6.8.1. Exponential, logarithmic and square functions root
EXP ( x ) - Returns e x = e ** x for real or complex x .
In case of complex x = ( a, b ), the result is e ** a * (cos ( b ) + i sin ( b )).
LOG ( x ) - Returns the natural logarithm value for real or complex x . In the case of a real argument the value of x must be greater than zero. In the case of a
complex argument x should not be zero. If x is of complex type, then real component of the result is equal to the natural logarithm of the modulus x , imaginary
component - the principal value of the argument x in radians, i.e. if x = ( a, b ),
​ then ​ LOG ( x )
​ =
= (LOG (SQRT ( a ** 2 + b ** 2)), ATAN2 ( a, b )).
LOG10 ( x ) - Returns the decimal logarithm of a real argument.
The x value must be greater than zero.
 179
180
O. V. Barteniev. Modern FORTRAN
SQRT ( x ) - Returns the square root for a real or complex argument x . In the case of a real argument, the value x must be greater than zero. In case of complex
x, the function returns
a number whose modulus is equal to the square root of the modulus x and the angle which is equal to half the angle x . So, if x = (a, b ), then SQRT ( x ) =
​ SQRT ( a ** 2
​ +
​ b ** 2)
​ *
* e - j * 0.5 * atan ( a / b ) .
You can also extract the root by using the exponentiation operation:
SQRT ( x ) = x ** 0.5. However, the SQRT function should be used because SQRT ( x ) is faster than x ** 0.5.
6.8.2. Trigonometric functions
In Fortran, they exist as trigonometric functions in which the argument must be given in radians, for example SIN ( x ), and the function, whose argument is in
degrees, for example SIND ( x ).
Sine and arcsine
SIN ( x ) - Returns the sine of a real or complex argument x , which is interpreted as a value in radians.
x , which is interpreted as a value in degrees.SIND ( x ) - Returns the sine of a real or complex argument
ASIN ( x ) - returns the inverse sine of the real argument x (| x | ≤ 1), expressed in radians in the range -π / 2 ≤ ASIN ( x ) ≤ π / 2.
ASIND ( x ) - returns the inverse sine of the real argument x (| x | ≤ 1), expressed in degrees in the range -90 ≤ ASIN ( x ) ≤ 90.
Cosine and arccosine
COS ( x ) - Returns the cosine of a real or complex argument x , which is interpreted as a value in radians.
COSD ( x ) - Returns the cosine of a real or complex argument x , which is interpreted as a value in degrees.
ACOS ( x ) - returns the inverse cosine of the real argument x (| x | ≤ 1), expressed in radians in the range 0 ≤ ACOS ( x ) ≤ π.
ACOSD ( x ) - returns the inverse cosine of the real argument x (| x | ≤ 1), expressed in degrees in the range 0 ≤ ACOS ( x ) ≤ 180.
Tangent, cotangent and arctangent
TAN ( x ) - Returns the tangent of the real argument x , which interpreted as a value in radians.
TAND ( x ) - Returns the tangent of the real argument x , which interpreted as a value in degrees.
COTAN ( x ) - returns the cotangent of the real argument x ( x ≠ 0), which is interpreted as a value in radians.
 180
181
6. Built-in procedures
ATAN ( x ) - Returns the arctangent of the real argument x , expressed in radians in the range -π / 2 <ATAN ( x ) <π / 2.
ATAND ( x ) - Returns the arctangent of the real argument x , expressed in degrees in the range -90 <ATAN ( x ) <90.
ATAN2 ( y, x ) - Returns the arctangent ( y / x ) expressed in radians in the range -π ≤ ATAN2 ( y , x ) ≤ π. The y and x arguments must be a real type with the
same value of the variation parameter and not can simultaneously equal zero.
ATAN2D ( y, x ) - Returns the arctangent ( y / x ) expressed in degrees in the range -180 ≤ ATAN2D ( y , x ) ≤ 180. The arguments y and x must be a real type
with the same value of the variation parameter and cannot be zero at the same time.
Range of results for ATAN2 and ATAN2D functions:
​ Arguments ​ Result (in glad )
​ Result (in deg. )
​ y > 0 ​ Result> 0
​ Result> 0
y = 0 and x > 0
​ Result = 0 ​ Result = 0 y = 0 and x <0
​ Result = π              Result = 180
​ y <0 ​ Result <0
​ Result <0
x = 0 and y > 0
​ Result = π / 2
​ Result = 90 x = 0 and y <0              Result = -π / 2              Result = -90
Hyperbolic trigonometric functions
SINH ( x ) - hyperbolic sine for expressed in radians a real argument x .
COSH ( x ) - hyperbolic cosine for expressed in radians a real argument x .
TANH ( x ) - hyperbolic tangent for expressed in radians a real argument x .
6.9. Array functions
Built-in array functions allow you to computations in arrays, get reference data about the array, and convert arrays. Built-in array processing functions considered
in Sec. 4.12. In addition to built-in CVF and FPS contain optional SORTQQ routine sorting a one-dimensional array and an integer binary search function
BSEARCHQQ in sorted array. To call them, you need to refer to the module
MSFLIB.
CALL SORTQQ ( adrarray , count , size ) - sorts a one-dimensional array, whose address is adrarray . To calculate the address, use
 181
182
O. V. Barteniev. Modern FORTRAN

LOC function. The array to be sorted must not be of a derived type.
The count parameter has the form of an INOUT connection and, when called, is equal to a number
array elements to be sorted, and at the output - the number is really sorted items. Parameters type adrarray , count - standard whole.
The parameter size is positive constant standard of a of type ( size <32,767), which specifies the type and type of the sorted type array. The following constants
are defined in the msflib.f90 file:
Constant
Array types
SRT $ INTEGER1
INTEGER (1)
SRT $ INTEGER2
INTEGER 
(2) 
or
equivalent
SRT $ INTEGER4
INTEGER 
(4) 
or
equivalent
SRT $ REAL4
REAL (4) or equivalent
SRT $ REAL8
REAL (8) or equivalent
If size is not a named constant given table and is less than 32'767, then it is assumed that a character an array whose element length is size .
To verify that the sort was successful, you should compare the values  of the count parameter before and after sorting. When a positive result they match.
Warning. The address of the array to be sorted must be calculated the LOC function. The count and size parameters must accurately describe array
characteristics. If the SORTQQ subroutine received incorrect parameters, an attempt will be made to sort some memory area. If the memory belongs to the
current process, then sorting will be done, otherwise the operating system will execute memory protection functions and will stop computing.
BSEARCHQQ ( adrkey , adrarray , length , size ) - performs a binary search the value that is contained in the variable located at the address adrkey . The search
is performed in a sorted one-dimensional array, the first element of which has the address adrarray . The function returns the index the element to look for, or 0 if
the element was not found. Result type and parameters adrkey , adrarray , length and size is a standard integer. The elements arrays cannot be derived types.
Parameter length equal to the number array elements. The meaning of the size parameter is explained when considering SORTQQ routines.
The array must be sorted by increasing values  of its elements.
182
183
6. Built-in procedures
Warning. The addresses of the array and element to be sorted must be calculated by the LOC function. The count and size parameters must be exactly describe
the characteristics of the array. In addition, the required element must have the same type and kind of type as an array, in which
search is in progress. These characteristics are set by the size parameter . If the BSEARCHQQ function received invalid parameters, then if the memory belongs
to the current process, an attempt will be made to search in some memory area, otherwise the operating system will execute the functions protect memory and
stop computing.
An example . Find all elements equal to the given value in the array.
To solve the problem, pre-sort the array, and then execute search given that equal elements of the sorted array follow contract.
use msflib
integer (4) a (20000), n, n2, ada, i, k
​ integer (4) :: ke = 234 ​ ! Let's calculate how many times in array a
​ real (4) rv
​ ! there is a number ke
​ n = size (a); n2 = n
​ ! Let's remember the size of the array a
 do i = 1, n ​ ! Fill the array a randomly call random (rv) a (i) = int (rv * 1000.0)
end do
​ ada = loc (a)
​ ! Array address a
call sortqq (ada, n, SRT $ INTEGER4)
​ ! Sorting array a if (n .ne. n2) stop 'Sorting error'
k = bsearchqq (loc (ke), ada, n, SRT $ INTEGER4) if (k == 0) then
print *, 'Element ke =', ke, 'not found' stop
end if
i = k ​ ! Finding all elements equal to ke do while (a (i) == ke .and. i <= n)
print *, 'Element with index i =', i, 'equals ke; ke = ', ke i = i + 1 end do
print *, 'Total items found:', i - k
​ ! 21 end
In fact, the result is incorrect. Indeed, we calculate nke - the number equal ke elements in the loop
nke = 0 do i = 1, size (a)
if (a (i) == ke) nke = nke + 1
end do
​ print *, nke ​ ! 28
183
184
O. V. Barteniev. Modern FORTRAN
It turns out that nke = 28, not 21, as found above. The fact, what BSEARCHQQ generally finds in an ordered vector not the first element equal to the given
number, but one of the following.
To return to the first searched element, in the program after calling BSEARCHQQ need to add code
if (k> 1) then
​ ! If the vector has an element equal to ke , it = k              ! move backward by adjusting
do k = it, 1, -1
​ ! value k - position of the first element equal to ke if (a (k) / = ke) exit end do k = k + 1
end if
6.10. Help functions for any type
ALLOCATED ( array ) - Returns .TRUE. If memory is allocated under the array array , .FALSE. - if not highlighted. The array parameter should have the
ALLOCATABLE attribute. The result will be undefined if the status of array is not defined . The result is standard boolean type.
Example :
 real, allocatable :: a (:)
...
if (.not. allocated (a)) allocate (a (10))

ASSOCIATED ( pointer [, target ]). The pointer parameter must be a link. The binding state of the pointer should not be null. If the targe t parameter is omitted,
the ASSOCIATED function returns .TRUE., if the pointer is attached to any destination. If parameter target is set and has a TARGET attribute, then the result is
.TRUE. if the pointer link is attached to target . If target is given and has an attribute POINTER then the result is .TRUE. If both pointer and target attached to one
addressee. In this case, the binding state of the target should not be undefined. In all other cases, the result is is equal to .FALSE. The result is of a standard
boolean type. When TRUE arrays. is returned if the argument forms match and if link elements in the order they appear are attached to the corresponding elements
on the target.
Example:
real, pointer :: a (:), b (:), c (:)
real, target :: e (10)
a => e b => e
! Link assignment
c => e (1: 10: 2)
! The link is attached to the
section of the array
print *, associated (a, e)
! T
184
185
6. Built-in procedures
print *, associated (a, b)
​ ! T print *, associated (c)
​ ! T print *, associated (c, e)              ! F
print *, associated (c, e (1: 10: 2))! T
PRESENT ( a ) - Determines if an optional formal parameter a when calling the procedure. The PRESENT function can be called only in a procedure with
optional parameters. The function returns .TRUE. If an actual parameter is present in the procedure call, corresponding to the formal parameter a . Otherwise
PRE-
SENT returns .FALSE .. The result is of the standard boolean type.
Example:
call who (1, 2)
! Will print :
a present
!
b present
call who (1)
! Will print :
a present
call who (b = 2)
! Will print :
b present
call who ()
! Will print :
No one
contains
subroutine who (a, b)
 integer (4), optional :: a, b if (present (a)) print *, 'a present' if (present (b)) print *, 'b present'
if (.not. present (a) .and. .not. present (b)) print *, 'No one'
end subroutine who
end
KIND ( x ) - returns a standard integer equal to the parameter value flavors of the x argument .
Example:
real (kind (1e0)), parameter :: one = 1.0 ! Real constant
one
real (kind (1e0)) :: err
! 
and 
single
precision err
6.11. Numeric Reference and Conversion functions
6.11.1. Integer and real data models
Each kind of integer and real type contains a finite lots of numbers. For example, INTEGER (2) represents all integers from the range from -32.768 to +32.767.
Each such set of numbers can be described by the model. Data on the parameters of the model given varieties of type and about the specific characteristics of the
number in the models allow for embedded numeric reference and conversion functions as well as functions IMACH, AMACH and DMACH of the IMSL library.
The binary representation of an integer i is given by the formula
185
186
 O. V. Barteniev. Modern FORTRAN i = )1(- s bbten ... bQ - 1 ,
sign
where s is 0 or 1 (+ or -); b i - binary number (0 or 1); Q - number of digits in whole number based on 2.
Real floating point numbers are represented in CVF and FPS in close accordance with the IEEE standard for floating arithmetic point (ANSI / IEEE Std 754-
1985, IEEE Standard for Binary Floating-Point Arithmetic, 1985). Fortran supports single precision formats type REAL (4), double precision - type REAL (8)
and increased precision, used to perform intermediate operations. For example, in the following code:
​ real (4) :: a, b, c, d, f
​ ! FPS compiler / Op option set
b = 0.0; c = 1.0e30; d = 1.0e30; f = 1.0e-30 a = (b + (c * d)) / 2.0 * f
​ print *, a
​ ! 5.000000E + 29
intermediate computation if / Op, FPS compiler option is specified will perform with increased accuracy. If the compilation option is set / Oxp, providing full
optimization of the computational speed and error checking, warnings will appear at the compilation stage
type (by reason overflow at the result multiplication c * d = 1.0e30 * 1.0e30) warning F4756: overflow in constant arithmetic
and the result of calculations will be machine infinity - 1 # INF ........
Binary representation of a real number x with floating point is given by the formula
​ x = )1(-
​ s bbb210... ​ ... b P - 1 × 2 E ,
​ sign
​ mantissa
where s is 0 or 1 (+ or -); b i - binary number (0 or 1); P - number of digits in the mantissa of the normalized representation of a real number by base 2; E is an
integer, called the ( binary ) order , from the segment
E min ≤ E ≤ E max . Table 6.1 shows the values  of the model parameters real numbers for single, double and high precision.
Table 6.1. IEEE Std 754 Number Model Parameters
​ Parameter ​ Accuracy

​ single
​ double
​ increased
​ Number of bits for sign​ 1
​ 1
​ 1
​ P
​ 24
​ 53
​ 64
​ E max
​ +128 ​ +1024
​ +16384
187
6. Built-in procedures
E min
-125
-1021
-16381
Binary order offset
+126
+1022
+16382
Bits for binary order
8
eleven
fifteen
Number of bits for a number
32
64
80
The standard requires single and double precision numbers
were represented in normalized form, so always b 0
= 1 and,
 186
hence, to represent the mantissa of single precision numbers requires 23 bits, and double requires 52. High precision numbers are not are normalized, so 64 bits
are required for the mantissa. When recording order to it in order to increase the speed of calculations is added offset , so the order is always represented as
positive numbers e . In reality, however, the order E = e is an offset . Format structure double precision floating point numbers is given in fig. 6.1.
​ 1
​ eleven
​ 52
​ Sign ​ Order +
​ Mantissa
bias
Figure: 6.1. IEEE double precision floating point format structure
Notes:
The set of computer representable floating point numberssure. So, for the REAL (4) type, their number is approximately 2 31 .
FPS and CVF contain BitViewer binary viewer
representations of real numbers of single and double precision.
6.11.2. Numeric Reference Functions
These functions give the characteristics of the model that contains function parameter. The function parameter can be either a scalar or array. The parameter value
can be undefined.
DIGITS ( x ) - Returns the number of binary significant digits in the model representations of x (i.e., Q or P ). The x parameter can be integer or real type. The
result is of the standard integer type.
​ Parameter type x​ DIGITS (x)
​ INTEGER (1)
​ 7
​ INTEGER (2)
​ fifteen
​ INTEGER (4)
​ 31
​ REAL (4)
​ 24
 187
188
O. V. Barteniev. Modern FORTRAN
​ REAL (8)
​ 53
1- P
​ EPSILON ( x ) - Returns
​ 2
​ :
​ Parameter type x​ EPSILON (x )
​ REAL (8)
​ 2.22044049250313E-016
​ REAL (4)
​ 1.192093E-07
Comment. The number returned by the function and EPSILON is often called machine precision and denote ε m .
HUGE ( x ) - for integer or real x, returns the largest x value . The type and parameter of the type of the result are the same as for x . Value
- for integer x and (
Parameter type x
HUGE (x
)
INTEGER (1)
127
INTEGER (2)
32,767
​ equally 2 -Q
​ 1
​ 21-
​ - P )2 Emax​ - for real x .
INTEGER (4) 2,147,483,647
REAL (4)
3.402823E + 38
REAL (8)
1.797693134862316E +
308
MAXEXPONENT ( x ) - for real x returns the maximum
order value, i.e. E max . The function result is of the standard integer type.
Parameter type x
MAXEXPONENT
(x )
REAL (4)
128
REAL (8)
1024
MINEXPONENT ( x ) - for real x, returns the minimum order value, i.e. E min . The function result has a standard integer a type.
Parameter type x
MINEXPONENT
(x )
REAL (4)
-125
REAL (8)
-1021
PRECISION ( x ) - for real or complex x returns the number of significant digits following the decimal point used to represent numbers with the same type
parameter as x . Result function has a standard integer type.

​ Parameter type x​ PRECISION (x )
 188
189
6. Built-in procedures
REAL (4) or COMPLEX (4) 6
REAL (8) or COMPLEX (8) 15
RADIX ( x ) - for integer or real x, returns the standard an integer equal to the base of the number system used for representations of numbers. For instance:
​ print *, radix (0.0)
​ ! 2
RANGE ( x ) - for integer, real or complex x returns the equivalent decimal power-law range of x , i.e.
INT (LOG10 ( huge ))
for the whole and
INT (MIN (LOG10 ( huge ), -LOG10 ( tiny )))
for real or complex x , where huge and tiny are the largest and the smallest number in the corresponding flavors of the type. Result functions are of a standard
integer type.
​ Parameter type x​ RANGE (x )
​ INTEGER (1)
​ 2
​ INTEGER (2)
​ 4
​ INTEGER (4)
​ nine
REAL (4) or COMPLEX (4) 37
REAL (8) or COMPLEX (8) 307
TINY ( x ) - for real x, returns the smallest positive the value of x , i.e.              2 E min ... The type and parameter of the type of the result are the same as for x .
Parameter type x
TINY (x )
REAL (4)
1.175494E-38
REAL (8)
2.225073858507201E-
308
6.12. Elementary data retrieval functions
on the components of the representation of real numbers
Functions of this kind return the value associated with components a model representation of the actual value of the argument.
EXPONENT ( x ) - Returns the exponential part (i.e. the order of E ) binary representation of the given real x . Result standard integer type. The result is zero if x
= 0. For example:
real (4) :: r1 = 1.0, r2 = 123456.7 real (8) :: r3 = 1.0d0, r4 = 123456789123456.7
 189
190
O. V. Barteniev. Modern FORTRAN
write (*, *) exponent (r1)
​ !
​ 1 write (*, *) exponent (r2)              !              17 write (*, *) exponent (r3)              !              1 write (*, *) exponent
(r4)              !              47
FRACTION ( x ) - Returns the mantissa - the fractional part of binary
- E representation x , i.e. 2 x ... Type x is real. Type and variety the result types are the same as x .
For instance:
print *, fraction (3.0)
!
0.75
print *, fraction (1024.0)
! 0.5
NEAREST ( x , s ) - returns a real value with the same type parameter, as in x , equal to the machine number closest to x , larger x , if s > 0, and smaller x , if s
<0; s cannot be zero. For instance:
real (4) :: r1 = 3.0 real (8) :: r2 = 3.0_8
! We use the hexadecimal number system for output
write (*, '(1x, z18)') nearest (r1, 2.0)
​ ! 40400001 write (*, '(1x, z18)') nearest (r1, -2.0)              ! 403FFFFF write (*, '(1x, z18)') nearest (r2,
2.0_8)              ! 4008000000000001 write (*, '(1x, z18)') nearest (r2, -2.0_8)              ! 4007FFFFFFFFFFFF
Comment. Floating point numbers between zero and HUGE ( x ) distributed unevenly. In the case of REAL (4), between each adjacent powers of two is about 2
22 floating point numbers. So,
approximately 2 22 numbers are between 2 -125 and 2 -124 and the same number between 2 124 and
2 125 . Simple matching says that floating point numbers are denser near zero.
RRSPACING ( x ) - returns a real value with the same type parameter, like y x , equal to the reciprocal of the relative distances between numbers in binary
representation x , in a region close to to x , i.e.              2 P - 2 E x ...
print *, rrspacing (3.0_4)
!
1.258291e
+ 07
print *, rrspacing (-3.0_4)
!
1.258291e
+ 07
SCALE ( x, i ) - returns a real value with the same parameter like y x , equal to 2 , where i is an integer.x i
​ print *, scale (5.2, 2)
​ ! 20.800000
SET_EXPONENT ( x, i ) - returns a real value with the same a type parameter, like x , equal to              2 Ei-              x , where i is an integer and E =
EXPONENT ( x ).
190
191
6. Built-in procedures
SPACING ( x ) - returns a real value with the same a type parameter, like y x , equal to the absolute distance between numbers in binary representation, in a
region close to x , i.e.              2 EP-              ...

print *, spacing (3.0_4) ​ ! 2.384186e-07 print *, spacing (-3.0_4)              ! 2.384186e-07
6.13. Conversions for the flavor parameter
The following two functions return the minimum parameter value variety that meets the specified criteria. Arguments and function results are scalars. The result type
is standard integer.
SELECT_INT_KIND ( r ) - Returns the value of the flavor parameter an integer that contains all integers in the range -10 r < n <10 r . If there is more than one
suitable variety, the smallest value of the variation parameter. Result is -1 if none of the flavors contains all the numbers in the interval given by argument r .
print *, selected_int_kind (8)
! 4
print *, selected_int_kind (3)
! 2
print *, selected_int_kind (10)
! -1 (no matching
variety)
 SELECTED_REAL_KIND ([ p ] [, r ]) - returns parameter value varieties of the real type, which contains all real numbers of the interval -10 r < x
<10 r , the decimal precision of which is not worse than p . Simultaneous absence of two arguments is not allowed. In the presence of more than one suitable
variety, a variety with smallest decimal precision. The function returns -1 if not available required accuracy. Returns -2 if the required decimal is not available
power range. Returns -3 if both are unavailable. For instance:
kp = 0 do while (selected_real_kind
(p = kp)> 0)
kp = kp + 1
end do kr = 300
do while (selected_real_kind (r = kr)>
0)
kr = kr + 1 end do
print *, selected_real_kind (p = kp),
kp
! -1
sixteen
print *, selected_real_kind (r = kr), kr ! -2
308
print *, selected_real_kind (kp, kr)
end
! -3
6.14. Beat routines
Built-in routines operate on the bits contained in machine representation of integers. The procedures are based on the model
191
192
O. V. Barteniev. Modern FORTRAN
according to which an integer contains s bits with values w k , k = 0, 1, ..., s - 1. Bits are numbered from right to left: the rightmost bit has
number 0, and the leftmost one is s - 1. The value of w k k -th bit can be either zero or one.
6.14.1. BIT_SIZE Reference Function
BIT_SIZE ( i ) - Returns the number of bits needed to represent integers with the same kind of type as the argument. Result has the same type parameter as the
argument.
Type i
BIT_SIZE
(i )
INTEGER (1)
8
INTEGER (2)
sixteen
INTEGER (4)
32
6.14.2. Element functions for working with bits
BTEST ( i , pos ) - Returns a standard boolean value equal to
 .TRUE. If bit pos of integer argument i is 1, and .FALSE. - otherwise. The argument pos must be an integer type and have a value in the range 0 ≤
pos <BIT_SIZE ( i ).
Example:
integer (1) :: iarr (2) = (/ 2 # 10101010, 2 #
11010101 /) logical result (2)
result = btest (iarr, (/ 0, 0 /)) write (*, *) result
!
FT
write (*, *) btest (2 # 0001110001111000, 2)
! F
write (*, *) btest (2 # 0001110001111000, 3)
! T
IAND ( i, j ) - Returns a logical AND between the corresponding bits arguments i and j : sets the k- th bit of the result to 1, if the k- th bit the first and second
parameters are equal to one. Otherwise, the k th bit of result is set to 0. Integer arguments i and j
must have the same type parameters. The same type parameter would be have a result.
IBCHNG ( i, pos ) - Returns an integer result with the same parameter of type like i , and a value that matches i , except for the bit with pos number , the value of
which is replaced by the opposite. Argument pos must be integer and have a value in the range 0 ≤ pos <BIT_SIZE ( i ).
IBCLR ( i, pos ) - Returns an integer result with the same parameter of type like i , and a value that matches i , except for the bit with pos number , which is
zeroed out. The argument pos must be an integer and have a value in the range 0 ≤ pos <BIT_SIZE ( i ).
192
193
6. Built-in procedures
IBITS ( i, pos, len ) - Returns an integer result with the same a type parameter, like i , and a value equal to len bits of i , starting from bit pos ; after shifting this
string of len bits to the right and clearing all freed bits. Pos and len arguments must be integers and have non-negative values  such that pos + len ≤ BIT_SIZE ( i ).
For instance:
​ k = ibits (2 # 1010, 1, 3)
​ ! Returns 2 # 101 = 5
​ print '(b8)', k
​ ! 101

IBSET ( i, pos ) - returns an integer result with the same type parameter, as i , and the same value as i , except for bit pos , in which the unit is set. The argument
pos must be an integer and have a value in the range 0 ≤ pos <BIT_SIZE ( i ).
IEOR ( i, j ) - Returns a logical exclusive OR between the corresponding bits of arguments i and j : sets to the k -th bit result 0 if the k- th bit of the first and
second parameters is equal or one, or zero. Otherwise, in the kth bit of the result the unit is set. Integer arguments i and j must have the same type parameters. The
same type parameter will have the same result.
 IOR ( i, j ) - Returns logical OR between matching bits of arguments i and j : sets the k- th bit of the result to one, if the k- th bit of at least one
parameter is equal to one. Otherwise case, the k- th bit of the result is set to 0. Integer
the arguments i and j must have the same type parameters. The same the type parameter will have a result as well.
Example:
integer (2) :: k = 198
! 198
(= 
2 
#
11000110)
integer (2) :: mask = 129
! 129
(= 
2 
#
10000001)
write (*, *) iand (k, mask)
! 128
(= 
2 
#
10000000)
write (*, *) ieor (k, mask)
!
​ 71 (= 
2 
#
01000111)
write (*, *) ior (k, mask)
! 199
(= 
2 
#
11000111)
ISHA ( i, shift ) - (arithmetic shift) returns integer result with the same type parameter as i and the resulting value
shift the bits of parameter i by shift positions to the left (or by - shift positions right if shift is negative). Released by shear
to the left, the bits are cleared, and when shifted to the right, they are filled with value sign bit. Argument shift must be whole and satisfy inequality | shift | ≤
BIT_SIZE ( i ).
ISHC ( i, shift ) - (cyclic shift) returns an integer result with this the same type parameter as i , and the value resulting from cyclic shift of all bits of parameter i by
shift positions to the left (or by shift positions to the right if shift is negative). Cyclic shift executed without bit loss: preemptive bits from one end
193
194
O. V. Barteniev. Modern FORTRAN
 appear in the same order on the other. Argument shift should be whole, and | shift | ≤ BIT_SIZE ( i ).
ISHFT ( i, shift ) - (logical shift) returns an integer result with this the same type parameter as i , and the value obtained as a result of the shift bits of parameter i by
shift positions to the left (or by - shift positions to the right, if value shift is negative). Clearing bits for both left and and are set to zero at the right shift. Unlike
arithmetic shift, the sign bit is also shifted. Argument shift must be an integer and satisfy inequality | shift | ≤ BIT_SIZE ( i ).
ISHTC ( i, shift [ , size ]) - returns an integer result with the same a type parameter, like i , and the resulting value cyclic shift size of the least significant (right-most)
bits of parameter i (or all bits if size is omitted) shift positions to the left (or - shift positions to the right if shift is negative). Shift and size arguments must be integers,
with 0 < size ≤ BIT_SIZE ( i ); | shift | ≤ size or | shift | ≤ BIT_SIZE ( i ) if size is omitted .
ISHL ( i, shift ) - Performs the same actions as the ISHFT function.
Example:
integer (1) :: k = -64
​ !
​ -64 (= 2 # 11000000) integer (1) :: i = 10              !              10 (= 2 # 00001010) integer (2) :: j = 10              !              10 (=
2 # 0000000000001010)
! ISHA function (right shift)
​ print '(1x, b8.8)', isha (k, -3) ​ !
​ 11111000 (= -8)
! ISHL function (right shift)
​ print '(1x, b8.8)', ishl (k, -3)
​ !
​ 00011000 (= 24)
! ISHC (left shift) function
​ print '(1x, b8.8)', ishc (i, 5)
​ !
​ 01000001 (= 65)
! ISHFT function (ISHA and ISHL functions will give the same result)
​ print '(1x, b8.8)', ishft (i, 5)
​ !
​ 01000000 (= 64)
! ISHFTC function
print '(1x, b8.8)', ishftc (i, 2, 3)
​ !
​ 00001001 (= 9) print '(1x, b8.8)', ishftc (i, -2, 3)!              00001100 (= 12) print '(1x, b16.16)', ishftc (j, 2, 3)!
0000000000001001 (= 9)
NOT ( i ) - (complement) returns an integer result with this same type parameter as i . The result bit is one if
the corresponding bit of the parameter i is zero, and, conversely, the bit of the result is zero if the corresponding bit of parameter i is one. For example, NOT (2 #
1001) returns 2 # 0110.
6.14.3. Element routine MVBITS
CALL MVBITS ( from, frompos, len, to, topos ) - copies from from sequence of len bits starting at bit number frompos , in to starting at bit number topos . The
rest of the bits in to do not change. Countdown positions
 194
195
6. Built-in procedures
is executed starting from the rightmost bit whose number is zero.
The parameters from, frompos, len and topos have integer type and relationship type IN: to an integer parameter with the communication type INOUT. The
parameters should satisfy the conditions: len ≥ 0, frompos + len ≤ BIT_SIZE ( from ), frompos ≥ 0, topos ≥ 0, topos + len ≤ BIT_SIZE ( to ). From and to
parameters must have one kind of type. As from and to, you can use one and the same variable.
Example:
integer (1) :: iso = 13
! 2 # 00001101
integer (1) :: tar = 6
! 2 # 00000110
call mvbits (iso, 2, 2, tar, 0) ! Returns tar =
00000111
6.14.4. An example of using bit functions

Bitwise operations are often used in computer graphics programs. Consider as an example
algorithm used in computer graphics to solve the clipping problem Sutherland - Cohen. The clipping task is to remove elements images that lie outside the specified
boundary (Fig. 6.2). Let's take a task in which the border of the area is a rectangle, which below we will be called the output window . The cutting problem is
solved many times for working with an image for a large number of segments, therefore it is important that the algorithm for solving it had a high speed.
In machine graphics, the monitor screen is mapped to a raster plane, the dimensions of which depend on the capabilities of the video adapter and monitor. The
coordinates on the raster plane are integer. Considering the resolution provided by video adapters, for example 800 * 600 or
1024 * 768 pixels, for coordinates the INTEGER (2) type is used.
In the Sutherland - Cohen algorithm, the relative position of the segment and the window output is defined as follows. The output window breaks by its sides and
their continuation raster plane into 9 regions.
Set for each area a 4-bit code (Fig. 6.2), in which:
one in bit 0 means that the point lies below the output window;
one in bit 1 means that the point lies to the right of the output window;
one in bit 2 means that the point lies above the output window;
one in bit 3 means that point lies to the left of the output window.
Let 1 and 2 be the numbers of the segment vertices; c 1 and c 2 - area codes the location of the first and second vertices, respectively. XL, XR, YB, YT the
coordinates of the bounds of the output window. It's obvious that
the segment is located inside the window if IOR ( c 1, c 2) returns 0;
the segment does not cross the window if IAND ( c 1, c 2)> 0;
the segment can cross the window if IAND ( c 1, c 2) returns 0 and IOR ( c 1, c 2)> 0.
 195
196
O. V. Barteniev. Modern FORTRAN
y
​ 1100 ​ 0100 ​ 0110
YT
0000
0010
YB
0001 ​ 0011
x
​ XL
​ XR
​ and
​ b
Figure: 6.2. Clipping task: a - area codes; b - solution of the cutting problem
To shorten the program code, we first perform all clipping for vertices 1, and then we swap vertices 1 and 2 (we give vertex 2 number 1; vertex 1 - number 2) and
again continue exploring vertex 1.
Algorithm: Interface:
Input data:
XL, XR - x -coordinates of the right and left borders of the output window; YB, YT - y -coordinates of the lower and upper borders of the output window; x 1, y
1 and x 2, y 2 are the coordinates of the segment vertices.
Output data:
x 1, y 1 and x 2, y 2 are the coordinates of the vertices of the truncated segment (or the original,
if the segment entirely belongs to the output window) after solving the problem clipping. If the segment is located outside the output window, we output the
message "Segment outside the window".
Intermediate data:
c 1, c 2 - codes of the areas of location of the first and second vertices of the segment; x 1, y 1 and x 2, y 2 - coordinates of the segment vertices on the cut lines;
fl - true if vertices 1 and 2 are exchanged.
Algorithm:
°. Start.
°. Calculate c1, c2.
°. If the segment can intersect the output window, then go to item 4 °, otherwise go to item 6 ° (all cutoffs for c1 are fulfilled).
°. If c1 is zero, then swap vertices 1 and 2.
°. Find the cutting line that line segment 1 intersects, and move vertex 1 to the point of intersection of the segment and the line clipping; calculate c1 and go to item
3 °.
 196
197
6. Built-in procedures
°. If IOR ( c 1, C2) = 0, then the segment is inside the window; print x 1, y 1, x 2, y 2, otherwise the segment is outside the window.
°. The end.
The program contains two procedures: subroutine swap - exchange variable values  - and the code function , which returns the area code location of the segment
vertex.
program clip
​ ! Clipping program text integer (2) :: XL = 15, XR = 60, YB = 15, YT = 60 integer (2) :: x1 = 10, y1 = 10, x2 = 65, y2 = 65 integer (2) c1,
c2, code
logical :: fl = .false.
c1 = code (x1, y1, XL, XR, YB, YT) c2 = code (x2, y2, XL, XR, YB, YT) do while (iand (c1, c2) == 0 .and. ior (c1, c2)> 0)
if (c1 == 0) then
​ fl = .not. fl ​ ! Swap vertices of a line segment
call swap (x1, x2); call swap (y1, y2); call swap (c1, c2)
end if
if (x1 <XL) then
​ ! Left clipping y1 = y1 + dfloat (y2 - y1) * dfloat (XL - x1) / dfloat (x2 - x1) x1 = XL
else if (y1 <YB) then
​ ! Bottom clipping x1 = x1 + dfloat (x2 - x1) * dfloat (YB - y1) / dfloat (y2 - y1) y1 = YB

else if (x1> XR) then
​ ! Clipping right y1 = y1 + dfloat (y2 - y1) * dfloat (XR - x1) / dfloat (x2 - x1) x1 = XR
else if (y1> YT) then
​ ! Clipping from above x1 = x1 + dfloat (x2 - x1) * dfloat (YT - y1) / dfloat (y2 - y1) y1 = YT
end if
c1 = code (x1, y1, XL, XR, YB, YT)! Vertex 2 code has not changed
end do
if (fl) then
! Swap vertices of a line
segment
call swap (x1, x2)
! Restoring the previous order
call swap (y1, y2) call swap
(c1, c2)
end if if (ior (c1, c2) == 0)
then
! peaks
write (*, 1) x1, y1, x2, y2
! x 1, y 1: 15, 15; x 2, y 2: 60,
60
else write (*, *) 'Segment outside the output window'
end if
 1 format ('x1, y1:', i4, ',', i4, '; x2, y2:', i4, ',', i4) end program clip
197
198
O. V. Barteniev. Modern FORTRAN subroutine swap (a, b)
integer (2) a, b, hold hold = a; a = b; b = hold
end subroutine swap
! Calculation of the area code of the location of the vertex with coordinates x , y function code (x, y, XL, XR, YB, YT) result (vcode)
integer (2) x, y, XL, XR, YB, YT, vcode vcode = 0
if (x <XL) vcode = ior (vcode, 2 # 1000) if (y <YB) vcode = ior (vcode, 2 # 0001) if (x> XR) vcode = ior (vcode, 2 # 0010) if (y> YT) vcode = ior (vcode, 2 #
0100)
end function code
6.15. Symbolic functions
Built-in character functions ADJUSTL, ADJUSTR, LGE, LGT, LLE, LLT, INDEX, LEN_TRIM, REPEAT, SCAN, TRIM, VERIFY allow compare symbolic
expressions, calculate their length, perform search strings for other substrings and perform string conversions. Functions are discussed in section. 3.8.8.
6.16. Memory routines
LOC ( gen ) - built-in function; returns the machine address of the argument gen or the address of the temporary result for the gen argument . The result has
INTEGER type (4).
If gen is an expression, a function call, or constant, then a temporary variable is created containing the result expressions, function call or constant, and the LOC
function returns the address of this temporary variable. In all other cases, the function returns the machine address of the actual parameter.
MALLOC ( i ) - built-in function; allocates a memory area of  size in i bytes. The function returns the starting address of the allocated memory. A type the
argument and function result are INTEGER (4).
CALL FREE ( i ) - built-in subroutine; frees the allocated with the MALLOC function a memory area; i - the starting address of the allocated MALLOC memory
function. The type of the i parameter is INTEGER (4).
Warning. If the memory to be freed was not previously allocated function MALLOC or the memory is freed more than once, then the result is unpredictable and
the execution of the FREE subroutine may seriously damage the memory occupied by the program.
198
199
6. Built-in procedures
Example:
integer (4) addr, size
size = 1024
! Size in bytes
addr = malloc (size)
...
! Allocate memory of
size size
call free (addr) end
! and release her
6.17. Checking end of file status
The built-in EOF ( device ) function returns .TRUE. If file positioned at or after end of file entry,
and .FALSE. - otherwise. (Considered in Section 11.16.)
6.18. Non-member date and time routines
CALL DATE_AND_TIME ([ date ] [, time ] [, zone ] [, values ]) - returns the date and time shown by the built-in system clock. All the procedure parameters
have the form of an OUT link.
date - a text scalar variable with a length of at least eight
characters, containing the date in the first eight characters in the form
 CCYYMMDD, where CC is the century, YY is the year, MM is the month, DD is day.
time is a text scalar variable with a length of at least 10 characters,
containing the time in the first 10 characters in the form HHMMSS.SSS, where HH corresponds to hour, MM to minutes, SS to seconds, SSS to milliseconds.
zone - text scalar variable with a length of at least five characters,
containing the difference between the local time in the first five characters and Universal Time Coordinated (Greenwich Mean Time) in the form of SHHMM,
where S is a sign (+ or -), HH is hours, MM is minutes.
values - a one-dimensional standard integer array of at least
eight, containing a sequence of values: year, month, day, time difference (in minutes) in relation to Greenwich Mean Time, hour of the day, minutes, seconds,
milliseconds. If any value is not available, then the corresponding element of the array is HUGE (0).
character (10) dat, tim, zon
call date_and_time (date = dat, time = tim, zone = zon) print *, dat, tim, '', zon

CALL SYSTEM_CLOCK ([ count ] [, count_rate ] [, count_max ]) returns the current value of the system timer and its characteristics.
All parameters are of the standard integer type. Parameter link type -
OUT.
count - the current value of the system timer or HUGE (0) if it is absence. The value count is incremented by one for each count
199
200
O. V. Barteniev. Modern FORTRAN
timer until it reaches count_max . Then, starting from zero, a new timing cycle is performed.
count_rate - the number of timer counts per second, or 0 if the timer
absent.
count_max - maximum value that count can take
or 0 if there is no timer.
integer cr, cm
call system_clock (count_rate = cr, count_max = cm) write (*, *) cr, cm              ! 1 86399
The DATE_AND_TIME subroutine can be adapted to measure computation time by creating a timer function :
function timer () ​ ! Returns CPU time
real (8) :: timer
​ ! in milliseconds integer (4) ::
ival (8)
call date_and_time (values  = ival)
timer = dble (ival (8)) * 0.001_8 +
&
dble (ival (7)) + dble (ival (6)) * 60.0_8 + dble
(ival (5)) * 3600.0_8
end function timer
&
 An example . The calculation time is measured with the correct and suboptimal organization of nested loops.
program toappr
integer (4), parameter :: n = 1000 real (4), dimension (n, n) :: array1, array2
real (8) :: start_time1, finish_time1! Start and end times of calculations real (8) :: start_time2, finish_time2! respectively, with correct and
! suboptimal organization of nested loops
​ real (8) :: timer
​ ! Function that returns processor time
! in milliseconds; is of type REAL (8)
​ array1 = 1.1; array2 = 1.5
​ ! Initializing Arrays
! Properly organized nested loop provides natural access
! to array elements by columns
start_time1 = timer ()
​ ! Calculation start do j = 1, n ​ ! Correct: the column is set first,
do i = 1, n ​ ! and then the row index changes array1 (i, j) = array1 (i, j) + array2 (i, j) * 3.3 end do
end do
finish_time1 = timer () ​ ! End of calculations array1 = 1.1; array2 = 1.5              ! Reinitializing Arrays
! Suboptimal nested loop organization - unnatural access
! to array elements line by line
start_time2 = timer ()
! Calculation start
do i = 1, n
! You don't need to program that
way. Provide
do j = 1, n
! accessing array elements by
columns
200
201
6. Built-in procedures
array1 (i, j) = array1 (i, j) + array2 (i, j) * 3.3 end do
end do
​ finish_time2 = timer () ​ ! End of calculations
print *, (finish_time1 - start_time1) / (finish_time2 - start_time2)
! Result : 0.629629629613660 end program toappr
6.19. Random numbers
The generation of random numbers is performed by the RAN subroutine. DOM_NUMBER from the values  contained in the seed array. The size and the values 
of this array are returned by the RANDOM_SEED subroutine.
It also allows you to change the seed.
CALL RANDOM_NUMBER ( harvest ) - Returns pseudo-random number harvest or array harvest of such numbers of uniformly distributed interval: 0 ≤ x <1.
Harvest type - standard real. The relationship of the harvest parameter is OUT.
 Starting (seed) point for the random number generator is installed and can be requested by RANDOM_SEED. If RANDOM_SEED is not used, the
seed value is processor dependent.
real x, hav (3) call random_seed () call random_number (x) call random_number (hav)
​ print *, hav ​ ! 5.252978E-01 6.502543E-01 4.247389E-01
CALL RANDOM_SEED ([ size ] [, put ] [, get ]) - changes the starting point
(seed) generator pseudo-random numbers, used subroutine RANDOM_NUMBER.
size - a standard integer in the form of an OUT link equal to the size
n of the seed array to be created by the processor.
put is a standard integer array with the IN link type used
a processor to change the seed.
get - a standard whole array with the OUT connection type, into which

current seed values.
When calling RANDOM_SEED, at most one
parameter. Dimensions put and get should be larger than the size of the array, which is used by the processor to store seed numbers. This the size can be
determined by calling RANDOM_SEED with the size parameter .
In a real implementation, size = 1.
If no parameters were specified when calling RANDOM_SEED, then the processor sets the starting point of the random number generator depending on the
system time.
202
O. V. Barteniev. Modern FORTRAN
Example:
integer sv, k
integer, allocatable :: ap (:), ag (:)
call random_seed (size = sv)
! Reading the size of the seed array
allocate (ap (sv), ag (sv))
! Arranging arrays
call random_seed (get = ag)
! We read the seed value into the ag
array
print *, sv
! 1
print *, (ag (k), k = 1, sv) ap = (/ (100 * k, k = 1, sv) /)
! 1
call random_seed (put = ap)
! Overriding the seed value
 201
Besides the built-in RANDOM_NUMBER subroutine in CVF and FPS there are additional routines for obtaining random numbers RANDOM
and RAN, as well as functions of the PortLib library: DRAND, DRANDM, IRAND, IRANDM, RAN, RAND and RANDOM. They are all interchangeable
because use the same pseudo-random number generation algorithm.
6.20. Built-in routine CPU_TIME
The subroutine CPU_TIME ( time ) returns the processor time time , whose type is REAL (4). Time units - seconds; after decimal point time contains two
significant digits. May be used to estimate the duration of calculations, for example:
real (4) :: start_time, finish_time call cpu_time (start_time) < Calculation > call cpu_time (finish_time)
print *, 'Computation time =', finish_time - start_time
 202
203
7. Control operators and designs
The sequence of program execution is determined by operators and constructs for branching and looping. Together with them jump and loop break statements can
be used. Such operators and constructs are referred to as managers. Their consideration we started in the 2nd chapter, limiting, however, most often used. Now
we will give a complete description of all managers constructions (except for the WHERE and
FORALL). In this case, some of the control operators and structures will be highlighted as deprecated or obsolete, saved in
Fortran for the purpose of continuity with earlier versions.
As before, the optional elements of the statements are enclosed in square brackets. The abbreviations used in the chapter are introduced in Sec. 2.2.
7.1. GOTO unconditional jump statement
It is used to transfer control by label and has the form:
GOTO label
In modern Fortran GOTO, as well as an alternative exit from a subroutine and an additional input (ENTRY) into a procedure, it follows completely replace with
other control structures.
Notes:
1and WHERE.. It is forbidden to go inside the structures DO, IF, SELECT CASE
2. In Fortran, you can also organize a transition by calculation
(computed GOTO) and prescription (assignable GOTO). Description of these operators are given in Appendix. 2.
An example . GOTO is used to organize repeated actions, i.e. a cycle.
integer (1) in 10 continue
print *, 'Please enter a number between 1 and 10:' read *, in if (in> = 1 .and. in <= 10) then
print *, 'Your input is:', in
else
print *, 'Error. Re-enter ' goto 10
 203
204
O. V. Barteniev. Modern FORTRAN
end if
...
A snippet that does the same thing without a GOTO looks like this:
integer (1) in do
print *, 'Please enter a number between 1 and 10:' read *, in if (in> = 1 .and. in <= 10) then
print *, 'Your input is:', in exit
end if
print *, 'Error. Re-enter '
end do
...
7.2. IF operator and constructs
Additionally compared to earlier versions of Fortran an optional construct name has been added to control constructs.
Using named constructs allows you to create well readable programs even with a large nesting depth control structures.
In the operator and constructions given in this section, IF LP must be a scalar, i.e. the operands of the LP must not be arrays or their sections.

7.2.1. Conditional logical IF statement
IF (ЛВ) operator
If the LP is true, then the operator is executed , otherwise control is transferred to the next program operator.
Fortran has one more conditional operator - arithmetic IF. This operator is a deprecated Fortran property. Him the description is given in the appendix. 2.
7.2.2. IF THEN END IF
[ name :]
​ IF (ЛВ) THEN SIDE
END IF [ name ]
BOC is executed if LP is true. If name is present constructions, then it must be in both the first and the last statement constructions, for example:
swap: if (x <y) then
hold = x; x = y; y = hold end if swap
 204
205
7. Control operators and constructions
Comment. If BOK contains one operator, then it is better to use operator
IF (ЛВ) operator
7.2.3. IF THEN ELSE END IF
[ name :] IF (lv) THEN
BOK1
ELSE [ name ]
BOK2
END IF [ name ]
If the LP is true, BOK1 is fulfilled, and BOK2 is fulfilled, if
LP is false. The name of the construction, if specified, must be mandatory be present both before IF and after END IF.
Example:
if (x ** 2 + y ** 2 <r ** 2) then
print *, 'Point inside circle'
else print *, 'Point outside the circle'
end if
7.2.4. IF THEN ELSE IF
[ name :] IF (lv1) THEN
BOK1
ELSE IF (LV2) THEN [ name ]
BOK2
...
[ELSE [ name ]
BOK n ]
END IF [ name ]
If LV1 is true, BOK1 is executed and control is transferred to the next statement after END IF. If LP1 is false, then the control is passed to the next ELSE IF, i.e.,
the value of ЛВ2 is calculated and, if it is true, BOK2 is satisfied. If it is false, then the control is passed to the next ELSE IF, etc. If all LPs are false, then the
BOK n following the final ELSE is executed . If the final
 ELSE is absent, then control is transferred to the IF located behind the END operator. The number of ELSE IF statements in a construction can be
arbitrary. Name in ELSE and ELSE IF can be given if they have IF and END IF statements. Name , if given, in all parts of the structure should be the same.
205
206
O. V. Barteniev. Modern FORTRAN
one END IF. It should be noted that the entire structure is completedIt is clear that such recording is more economical than recording, using separate IF THEN
ELSE END IF constructs, for example:
IF (ЛВ1) THEN
BO1
ELSE
IF (LV2) THEN
BO2
ELSE
BO3
END IF
END IF
IF 
(ЛВ1)
THEN
BO1
ELSE IF (LV2)
THEN BO2
ELSE
BO3
END IF
An example . Find the number of positive, negative and zero array elements.
integer :: a (100), np = 0, ne = 0, nz = 0, ca, i
< Input array a > do i = 1, 100
ca = a (i)
val_3: if (ca> 0) then
​ ! val _3 - the name of the structure np = np + 1
else if (ca <0) then
ne = ne + 1
else val_3 nz = nz + 1
end if val_3
end do
...
Comment. You can calculate the desired values  by applying built-in COUNT function. True, you will have to call it two times:
np = count (a> 0) ne = count (a <0) nz = 100 - np - ne
7.3. SELECT CASE clause

[ name :] SELECT CASE ( test expression )
CASE (SP1) [ name ] [BOK1]
[CASE (SP2) [ name ]
[BOK2]]
...
[CASE DEFAULT [ name ]
[BOK n ]]
END SELECT [ name ]
206
207
7. Control operators and constructions
Test expression - integer, character type CHARACTER (1) or a boolean scalar expression.
SP is a list of constants, the type of which must correspond to the type of test expressions .
The SELECT CASE construct works like this: the test value is calculated expressions . If the received value is in the list SP1, then
BOK1 is in progress; then control is transferred to the next one after END SELECT statement. If the value is not in SP1, then it is checked if there is whether it is
in SP2, and so on. If the value of the test expression is not found in either one list and the CASE DEFAULT statement is present, then
BOK n , and then the statement behind the END SELECT is executed. If the same test expression value is not found in any list and CASE DEFAULT is absent,
then none of BOK i is executed and control is passed to the statement following the END SELECT.
The list of SP constants can contain one value, or from comma-separated constants, or be specified as a range colon-separated values, such as 5:10 or 'I': 'N'.
Left border
 should be smaller than the right. If a range of characters is specified, then the code the first character must be less than the code of the second. If the
left is omitted border, for example: 10, then the SP contains all values  less than or equal to the right border. Conversely, if the upper bound is omitted, for example
5:, then all values  greater than or equal to the lower border. SP can also include a mixture of individual values  and ranges. Separators between the individual
elements of the joint venture are commas, for example:
case (1, 5, 10:15, 33)
You cannot set a range of values  in the SP when the test expression has boolean type. Each value, even if specified in the range values, can appear in only one
joint venture.
SELECT CASE constructs can be nested. Moreover, each the construct must end with its own END SELECT.
You cannot navigate through a GOTO statement or as a result alternative return from a subroutine to a SELECT statement CASE or move from one CASE
section to another. Trying this transition will result in a compilation error.
The name of the structure, if specified, must necessarily have SELECT CASE and END SELECT statements.
An example . Find the number of positive, negative and zero elements of an integer array.
integer :: a (100), np = 0, ne = 0, nz = 0, i
< Input array a > do i = 1, 100
207
208
O. V. Barteniev. Modern FORTRAN
select case (a (i)) case (1 :) np = np + 1
case (: - 1)
ne = ne + 1
case (0)
​ ! or: CASE DEFAULT nz = nz + 1
endselect
end do
...
7.4. DO loops. EXIT and CYCLE statements
Simplest DO Construction
[ name :] DO
SIDE
END DO [ name ]
sets an endless loop. Therefore, the BOK must contain at least one statement, such as EXIT [ name ], to exit this cycle. The construct name , if present, must
appear in operators DO and END DO.
 An example . Find the first negative element of array a (1: 100).
i = 1
first_n: do
​ ! first_n - the name of the DO construct if (a (i) <0 .or. i == 100) exit first_n i = i + 1
end do first_n
if (a (i)> = 0) stop 'There are no negative elements in the array'
print *, a (i) ! First negative element of an array Recommended form of DO-loop with parameter:
[ name :] DO dovar = start , stop [, inc ]
SIDE
END DO [ name ]
dovar - integer, single or double precision
a variable called a loop variable or a loop parameter ; start, stop - integers, real single or double precision
scalar expressions specifying the range of the dovar ; inc - integer, single or double precision scalar
expression. Meaning inc can not be zero. If inc is absent, then it is taken equal to one.
The number of loop iterations is determined by the formula ni = MAX (INT (( stop - start + inc ) / inc ), 0),
208
209
7. Control operators and constructions
where MAX is the function for selecting the largest value, and the function INT returns a value equal to the integer part of a number.
If a DO loop with a parameter does not contain loop exit statements, for example EXIT, then BOC is executed ni times.

After the end of the loop, the value of the loop variable dovar is (case inc > 0):
dovar_ni + inc , if stop ≥ start and the loop contains no exit statements loop, where dovar_ni is the value of the loop variable at the last iteration;
dovar_ni , if stop ≥ start and the cycle is prematurely interrupted, for example an EXIT or GOTO statement, where dovar_ni is the value of the loop variable
dovar when the loop was interrupted;
start if stop < start .
The dovar value is defined similarly for the case inc <0.
The procedure for executing a DO cycle with a parameter is described in Sect. 2.2.3.1. You cannot change the value of a loop variable in the loop body: do k = 1,
10
​ k = k + 2
​ ! Error. Trying to change the value of a loop variable
end do
 The first time the DO statement is executed, dovar = start , stop , inc the values  of the expressions start , stop, and inc are calculated and stored . All
further iterations are performed with these values. Therefore, if stop , start or inc are variables and their values  change in the body of the loop, then this will not
affect the work of the cycle.
Comment. In a DO loop with a single or double precision real parameter may not be correctly calculated due to rounding errors the number of iterations, which
draws attention to the app. 2.
Recommended form of DO WHILE loop:
[ name :] DO WHILE (lv) SIDE
END DO [ name ]
If the DO WHILE loop does not contain loop interrupt statements, then the BOC is executed as long as the true scalar LP.
DO loop, DO loop with parameter and DO WHILE loop can be interrupted by statements GOTO, EXIT and CYCLE, as well as as a result executing a
RETURN statement to return from the procedure. Operator
EXIT [ name ] transfers control from the DO-structure to the first one after the operator to be executed. If name is omitted then EXIT
209
210
O. V. Barteniev. Modern FORTRAN
 ensures exit from the current loop, otherwise EXIT provides an exit from the loop whose name is present in the EXIT statement. Operator
CYCLE [ name ]
transfers control to the beginning of the DO-construct. Moreover, the operators located between CYCLE and the END DO statement of the end of the loop, not
are performed. If the name is omitted, then CYCLE provides a transition to start of the current cycle, otherwise CYCLE provides a transition at the beginning of
the cycle whose name is present in the CYCLE statement.
An example . Calculate the sum of array elements whose values  are greater than five, terminating computations when a zero is encountered.
integer a (100), sa, c, i <
Input array a > sa = 0 do i =
1, 100 c = a (i)
if (c == 0) exit
! Early exit from the
cycle
if (c <= 5) cycle sa = sa + c
end do
print *, sa
! Summation is not
performed
Comment. From the point of view of structured programming, the calculations are best done by applying the union of conditions and abandoning the EXIT and
CYCLE statements:
sa = 0 i = 1
do while (a (i) / = 0 .and. i <= 100)
if (a (i)> 5) sa = sa + a (i) i = i + 1 end do
DO constructs can be nested. Nesting degree unlimited. Nested DO constructs should be named such that will increase their visibility and allow in some cases to
shorten the code.
An example . Find the first negative element in a 3D array.
integer, parameter :: L = 20, m = 10, n = 5 real, dimension (l, m, n) :: a
< input array a > loop1: do i = 1, L loop2: do j = 1, m
loop3: do k = 1, n
if (a (i, j, k) <0.0) exit loop1
​ ! Exiting loop 1 end do loop3
 210
211
7. Control operators and constructions
end do loop2
end do loop1
if (i> L) stop 'The array has no negative elements' print *, a (i, j, k)
end
When working with DO and DO WHILE cycles, remember:
DO-loop variable with parameter dovar cannot be changed operators of this cycle;
it is not allowed to go inside the loop by executinga GOTO statement or alternative return from a subroutine;
transition to the beginning of the DO-construct by means ofa CYCLE statement outside this construct
(an attempt at such a transition can be made when working with named nested DO constructs);
if an IF, SELECT CASE, WHERE or FORALL statement appearsinside a loop, then the corresponding operator END IF, END SELECT, END WHERE or
END FORALL must be inside the same cycle.
Comment. The last three prohibitions are easier to control if when recording a program, the relief rule (Section 2.5).
When writing DO and DO WHILE cycles, labels can be used. Let us illustrate these notation forms by the example of calculating the sum negative elements of
array a (1: 100).
! Option 1; the loop ends with an empty CONTINUE statement sa = 0

do 21, k = 1, 100 ​ ! You can put a comma after the label if (a (k) .lt. 0) sa = sa + a (k)
continue
! Option 2; END DO is used instead of CONTINUE sa = 0 do 22 k = 1, 100
if (a (k) .lt. 0) sa = sa + a (k)
end do
! Option 3; the loop ends with an executable statement sa = 0 do 23 k = 1, 100
if (a (k) .lt. 0) sa = sa + a (k)
! Using the DO loop label [,] WHILE options 4, 5 and 6 have the same
! differences as options 1, 2 and 3
! Option 4 k = 1 sa = 0
212
O. V. Barteniev. Modern FORTRAN
do 24, while (k .le. 100)
if (a (k) .lt. 0) sa = sa + a (k) k = k + 1
! You can put a comma after the label
24 end do
! Option 5 k = 1 sa = 0
do 25 while (k .le. 100)
if (a (k) .lt. 0) sa = sa + a (k) k = k + 1
! The construction ends with an END DO label
25 continue
! The construction ends with a CONTINUE
label.
 211
! Option 6 k = 1 sa = 0 do 26 while (k .le. 100)
if (a (k) .lt. 0) sa = sa + a (k)
! The construct ends with a label executable statement 26 k = k + 1
Notes:
After the label in the DO and DO WHILE clause there can be a comma,which is illustrated by the first and fourth cycles.
The CONTINUE statement is empty, does nothingoperator and can appear anywhere among executable operators.
In the case of nested DO- or DO WHILE-loops, two or more DOor DO WHILE loops can have a common trailing label. True, END DO can only complete one
DO or DO WHILE loop.
7.5. Possible cycle replacements
Fortran 90 allows in problems with arrays, where previously used cycles, use more concise and effective means. To them relate:
built-in functions for working with arrays;
operators and constructions WHERE and FORALL (Section 4.7);
sections of arrays.
Let us illustrate what has been said with examples.
 Example 1 . Find the row of the matrix with the maximum sum of elements.
integer, parameter :: m = 10, n =
20
integer kmax (1) real a (m, n) <
Input matrix a >
! Number of the required
matrix row
kmax = maxloc (sum (a, dim = 2))
print *, kmax
! The function returns an
array
212
213
7. Control operators and constructions
Example 2 . Replace all negative elements in vector b with zeros.
integer, parameter :: n = 100 real b (n) < Vector b input >
​ where (b <0) b = 0
​ ! Replacing negative elements with zeros
Example 3 . Swap the first and last rows in the matrix a .
integer, parameter :: m = 10, n = 20 real, allocatable :: temp (:) real a (m, n)
Example 4 . Form a vector c from negative elements of the matrix a .
integer, parameter :: m = 5, n = 4 integer k
real, allocatable :: c (:) real a (m, n) < Input matrix a >
​ k = count (a <0) ​ ! The number of negative elements in a
if (k == 0) stop 'There are no negative elements in matrix a' allocate (c (k))
​ c = pack (a, a <0)
​ ! Move negative elements a to c
Example 5 . Print a two-dimensional array line by line.
integer, parameter :: m = 5, n = 3
integer i
​ ! Matrix elements are allocated in memory in columns integer a (m, n) / 1, 2, 3, 4, 5,              &
​ 1, 2, 3, 4, 5,
​ &
1, 2, 3, 4, 5 /
do i = 1, m ​ ! We put a section of the array in the output list print '(100i3)', a (i, 1: n) end do
In the last example, instead of the implicit loop ( a ( i , j ), j = 1, n ) in the list output there is a section of the array, which is the same as the implicit loop, specifies a
single line in the array. Likewise a section of the array can be used when typing.
However, replacing cycles with sections is not always possible. This is before only concerns loops in which the result of the iteration depends on the result previous
iteration. So the cycle
< Input matrix a >
allocate (temp (1: n))
! Allocate memory for temp
temp = a (1, 1: n)

! Let's store line 1 in the temp
array
a (1, 1: n) = a (m, 1: n)
! We write in line 1 line m
a (m, 1: n) = temp
! Write to line m from temp
deallocate (temp)
! Freeing up memory
 213
214
O. V. Barteniev. Modern FORTRAN
do i = 2, n
a (i) = a (i - 1) + 5.0 end do
cannot be replaced by assignment
a (2: n) = a (1: n - 1) + 5.0
or design
forall (i = 2: n) a (i) = a (i - 1) + 5.0
7.6. STOP operator
The operator terminates program execution. Has the syntax:
STOP [ message ]
Message - character or integer constant in range from 0 to 99999. If there is no message , then after executing the operator the line is output
STOP - Program terminated.
If the message is a character constant, then:
a message is displayed ;
the program returns 0 to the operating system.
If the message is a number, then:
the sentence Return code number is displayed . For example, if applied statement STOP 0400, after the end of the program will be output Return code 0400
offer;
the program returns to the operating system the last significantan integer byte (values  from 0 to 255) to use a program that checks the status values  of running
processes.
Example:
open (2, file = 'b.txt', status = 'old', iostat = icheck) if (icheck .ne. 0) then
stop 'File access denied.'
end if
7.7. PAUSE operator
The operator temporarily suspends the execution of the program and
Allows the user to execute operating system commands. It has syntax:
PAUSE [ message ]
Message - character or integer constant in range from 0 to 99999. If there is no message , then after executing the operator the line is output
Please enter a blank line (to continue) or a system command.
214
215
7. Control operators and constructions
After executing the PAUSE statement, the following actions are possible:
if the user enters a space, then control is returned to the program;
if the user enters a command, then the command is executed andcontrol returns to the program. The maximum size of the set one command line is 128 bytes;
if the word COMMAND or command is entered, then the user canexecute a sequence of operating system commands. For return to the program, you will need
to enter EXIT (uppercase or lowercase).
Example:
character (30) filename
pause 'Enter DIR or press Enter to return.' read (*, '(a)') filename open (1, file = filename)
Comment. The 1995 standard excludes PAUSE from Fortran.
 However, it is still supported by both CVF and FPS.
215
216
8. Program units
8.1. General concepts
When developing an algorithm, the original problem, as a rule, is split into separate subtasks. The process of isolating subtasks is extremely important. It can be
said without exaggeration that the qualifications of a programmer in is largely determined by its ability to rationally break up the original the task into fragments,
which are subsequently implemented as separate program units. In Fortran 77, the selected fragments were made out, usually in the form of a main program and
external procedures.
Selected chunks must exchange data. In Fortran 77 such an exchange was performed through the parameters of procedures, common -blocks and, in the case of
a function procedure, through its return value. In the BLOCK DATA program unit, variables named common block, you could set initial values.
Fortran 90 and 95, keeping all the capabilities of Fortran 77, additionally allow:
create modules containing global data and modularprocedures;
 create internal procedures located inside the mainprogram, external or modular procedure. These innovations additionally allow:
use different program units declared in the moduleglobal data and the procedures it contains;
use the data declared in the module in all procedures of thismodule;
use the same data object in an internal procedureand in its carrier.
Thus, in Fortran, you can create such software units as: • main program;
modules;
external procedures;

internal procedures;
BLOCK DATA.
In addition to those named in the program unit (except BLOCK
DATA), operator functions can also be defined (Section 8.24).
A module is an independent software unit that can generally contain declarations of data, common -blocks, procedure interfaces, namelist groups, and modular
procedures. All not
216
217
8. Program units
the declared PRIVATE module components are available in others (except BLOCK DATA) program units.
There are two kinds of procedures in Fortran: subroutines and functions .
A subroutine is a named program unit, in the header which has a SUBROUTINE operator. Subroutine call performed by its name in the CALL statement or when
executing given assignment.
A function is a named programming unit that is called is executed by its name from the expression. Its title contains FUNCTION statement. The function contains
the resulting variable, receiving, as a result of the execution of the function, the value, which is then used in an expression containing a function call. Also the
function is also called when the specified operation is performed.
In Fortran, you can define external , internal and modular procedures .
An external procedure is an independent program unit and exists independently of the program units using it. TO any external procedure can be accessed from the
main program and any other procedure.
 Modules and external procedures can be compiled separately from program units using them.
The internal procedure is set in the main program, external or modular procedure. The main program or procedure is called carriers of the internal procedures
contained in them. Refer to an internal procedure can only be inside its carrier. Themselves internal procedures can no longer contain other internal procedures.
A modular procedure is defined in a module and is available if it is not declared PRIVATE, in any program using the module
unit. The module is also a carrier in relation to the one specified in it is a modular procedure, which, in turn, can be a carrier the internal procedure defined in it.
Fortran 90 and 95, unlike Fortran 77, support recursive procedure calls, that is, calls in which the procedure directly or indirectly refers to itself. Recursive header
operator procedures contains the RECURSIVE prefix. 8.2. Using program units in a project
A user-created project can use:
built-in procedures;
plug-in procedures and modules;
procedures and modules created during project development.
217
218
O. V. Barteniev. Modern FORTRAN
 Built-in procedures are part of Fortran and automatically are included in the executable code when referred to in the program text.
Examples of built-in procedures: SIN, ALOG, TRIM.
Plug-in procedures and modules are located in previously created and libraries supplied with Fortran. List and description of such modules and procedures are
given in the appendix. 3.
Also supplied with CVF and FPS are mathematical libraries and libraries of mathematical statistics.
All procedures supplied with CVF and FPS when installed correctly default programs are available to the compiler and linker. To use them in a program unit,
follow the link to a module containing global data and procedure interfaces.
The link is provided by the USE operator.
The user can create his own application libraries and use stored procedures and modules in any of their projects. To access libraries containing object code the
user should give the builder its full name.
The procedures and modules of the project contain fresh solutions and on the initial development stages are stored in the source code . New program units are
usually in different files. If the file
there are several procedures or modules, then the order of their placement arbitrary. However, the module text must be placed before the first existing links to it. In
general, one file can
there are external procedures, modules and the main program. At the same time meaningful splitting of program units into files, their order placement in each of the
files, the correct division of procedures into external, internal and modular greatly facilitates development program and its subsequent maintenance during
operation.
At the subsequent stages of work on the program, some of the debugged procedures and modules can be stored in compiled form (object code), part - included
in libraries containing object program unit code. Unfinished software units are still stored in the source code.
The created procedures and modules implement the allocated
develop algorithm fragments and solve data exchange problems between them. A fragment is implemented as a procedure if it:
represents a typical task, for example, finding the extremum of a function;
represents a standalone task such as data I / O and controlI / O errors.
Also, in the form of procedures, a repeating in the program more once code. Making fragments into procedures improves quality of the program, reduces the time
of its development, debugging and
 218
219
8. Program units
testing. The question of choosing the type of procedure (external, modular or internal) is inextricably linked to the problem of data organization.
Procedures and modules are useful for another reason as well. Often to work on a large project it is necessary to involve a team of programmers.
It is possible to organize the work of the brigade only by instructing each participant implementation of one or another group of procedures and modules. It is clear
that the general structure of the program must first be determined, the fragments are selected, the data with which the fragments are are exchanged, and methods of
data exchange (association of parameters, association through a carrier, use- association, association memory). This preliminary and extremely important work is
called designing the program .
So, procedures and modules:
allow you to reduce the cost of creating a program;
improve the readability of the program and therefore make it easiersubsequent modification;

lead to shortening of the source code;
can be included in libraries and called from any program;
allow you to divide the work on the program between differentprogrammers.
8.3. Working with a project in the DS environment
In CVF and FPS, the program is considered a project. Types of possible projects are given in table. 8.1.
Table 8.1. Project types
Project type
Features:
Console (EXE)
One-window 
main 
project
without graphics
Standard Graphics (EXE)
Single window main project
with graphics
QuickWin Graphics (EXE)
Multi-window main project
with graphics
Windows Application (EXE)
Multi-window main project
with full GUI and Win32 API
functions
Static Library (LIB) Library routines included in EXEfiles
Dynamic library
(DLL)
Library 
routines
connected 
in
progress
The first 4 types require a main program. The last two library projects without a main program.
The project type specifies the type of generated code and some parameters project. For example, it defines the options that the compiler uses,
 219
220
O. V. Barteniev. Modern FORTRAN
the libraries used by the linker set by default
location of output files, project constants, etc. Setting the type
the project is executed when it is created. The procedure for creating a project in CVF and
FPS and some operations with projects are discussed in section. 1.2.
After creating a new project, you can generate two of it modifications: Debug and Release. The first one contains the debug compiler and linker settings. The
second is oriented to get a working EXE file that does not contain debug code. In any of them, you can change the compiler and linker settings. Using the Build -
Configurations chain you can add or remove modification. Each of the modifications can be generated in its own directories. By default, the name of the directory
for modification is the same as modification name, but it can be changed as a result chain execution Build - Settings - General - set directories in fields in the
Output directories area - OK. Generated by default the modification can be changed by running the Build - Set (Active) Default Configuration - configuration
selection - OK.
The project uses files with source codes of programs and resource files storing, for example, dialog boxes. May also be links to modules (USE statement), files
with object code (link specified as a builder option parameter) and dynamically link libraries (as a result of using the attribute
DLLIMPORT). Alternatively, in the source code, you can specify the path to libraries containing called procedures by applying the required
the number of times the $ objcomment lib: " library name " directive . Name specified will be stored in object code and then used by the linker when building the
application.
Modules, if their source code is not contained in the project, are searched the compiler by the name specified in the USE statement. Expansion searched files -
MOD. Search order:
search in the directory containing the project files;
in the directories specified in the / I compiler option in their orderfollowings. When specifying more than one directory in the option, the names directories are
separated by spaces: / I "myfiles /" / I "mylib /";
in directories specified in the INCLUDE environment variable, for examplein the autoexec.bat file.
In addition, a source file can be included in the project, using the INCLUDE line or the $ INCLUDE directive. String (directive) can contain the fully qualified
name of the included file (that is, the name and path to the file). If the full file name is not specified, then the compiler looks for the file in the same the sequence that
applies to the module.
 220
221
8. Program units
When a module (include file) is found, the search stops.
If unsuccessful, an error message is generated.
In the DS environment, directories for finding modules and include files can be set by following the Tools - Options - Show directories for Include files - add the
required directory - OK. Also directories are also specified as a result of executing the (Project) Build - Settings -
Fortran - Preprocessors - enter in the INCLUDE and USE paths field the paths to files - OK. The file path ends with a slash. If there are several
​ paths they are separated by commas, for example: myfiles /, mylib /. compiler options are displayed in the Project Options field.              The given
8.4. Main program
The compiled and linked executable file called an application . Any application contains one main program, which in general has the form:
[PROGRAM program name ]
[ description operators ]
[ executable statements ]
[CONTAINS
internal procedures ]
END [PROGRAM [ program name ]]
The PROGRAM statement is optional. However, if it is present, then the name of the program must also be given - any correct Fortran's formed name. If the
END statement contains a name program , then it must match the name specified in the statement
PROGRAM.

Main program cannot contain MODULE and BLOCK statements
DATA. The description section cannot contain operators and attributes OPTIONAL, INTENT, PUBLIC and PRIVATE. Including an attribute or the SAVE
statement has no effect. SUBROUTINE operators, FUNCTION, RETURN and ENTRY cannot appear among executables operators of the main program, but
can be placed after the operator
CONTAINS.
Application execution always starts with the first executable operator of the main program. END statement if the result is control is transferred to it, completes the
execution applications. The operator can have a label, using which you can jump to END from other executable operators. Normal
 termination of the application can also be performed by the STOP statement, which can appear both in the main program and in the procedure. 221
222
O. V. Barteniev. Modern FORTRAN
8.5. External procedures
Fortran can define two types of procedures: subroutines and functions . A function differs from a subroutine in that it is called from expression and returns the result
which is then used in this expression. The return type determines the type of the function.
When defining an external function, you must declare its type in the section declaring the calling program unit in the same way for other data objects.
The procedure should be formatted as a function , if its result can be write to one variable, otherwise you should apply subroutine .
The structure of the subroutine is:
subroutine header
[ description operators ]
[ executable statements ]
[CONTAINS
internal procedures ]
END [SUBROUTINE [ subroutine name ]] The structure of the function looks similar:
function header
[ description operators ]
[ executable statements ]
[CONTAINS
internal procedures ]
END [FUNCTION [ function name ]]
The function contains the resulting variable, into which the function's return value is set. Fortran 77 name the resulting variable always matches the function name.
Now in in the RESULT clause, you can give the result a different name.
The CONTAINS statement in the procedure plays the same role as in the main program. Execution of the END statement results in the transfer control to the
calling program unit. Also exit from procedures are performed by the RETURN operator.
The subroutine header contains a SUBROUTINE statement, and the header functions - operator FUNCTION. The subroutine call is executed operator
CALL subroutine name ([ list of actual parameters ]) A function call is made from an expression, for example: result = function name ([ list of actual parameters ])
222
223
8. Program units
8.6. Internal procedures
Within the main program, external and modular procedures, you can after the CONTAINS statement, specify internal procedures. They look like:
subroutine header
[ description operators ]
[ executable statements ]
END SUBROUTINE [ subroutine name ] function header
[ description operators ]
[ executable statements ]
END FUNCTION [ function name ]
Unlike external and modular procedures, internal procedures may not contain other internal procedures. Unlike external procedures, internal procedures, as well
as modular, are mandatory contain in the END statement the word FUNCTION in the case of a function or SUB-
ROUTINE in the case of a subroutine. Internal procedure has access to media objects, including the ability to call other internal procedures. Internal procedures
have an explicitly defined interface
 (section 8.11.3), so the type of the inner function must not be declared in its carrier.
8.7. Modules
The module is used to set global data and modular procedures. It looks like:
MODULE module name
[ description section ]
[CONTAINS
modular procedures ]
END [MODULE [ module name ]]
The description section can contain definitions of built-in types data, declarations of data, functions and their attributes, interface blocks and namelist groups. When
declaring data, they can be assigned initial values. Data declaration statements may contain
attributes ALLOCATABLE, AUNOMATIC, DIMENSION ( dim ), EXTERNAL,
INTENT, INTRINSIC, OPTIONAL, PARAMETER, POINTER, PRIVATE, PUBLIC, SAVE, STATIC, TARGET and VOLATILE (last attribute only
applicable in CVF). Each attribute can be set in the operator room form. Also, the description section can include COMMON statements,
DATA, EQUIVALENCE, IMPLICIT, NAMELIST, USE. Description section cannot contain any executable statement.
223
224
O. V. Barteniev. Modern FORTRAN
The modular procedures following the CONTAINS statement must end with END SUBROUTINE [ subroutine name ] or END FUNCTION
[ function name ]. Modular procedures, in turn, after the operator
CONTAINS can contain internal procedures. Module name , if it is followed by END MODULE, must match the name in the module header .

A module in a program unit is accessed by the USE statement that precedes the declaration section of the program units.
Names declared in module description statements are available: • in modular procedures;
in the internal procedures of the module;
in program units using the module (if the names are notdeclared PRIVATE).
Modular treatments are available:
in other modular module procedures;
in the program unit using the module (if they are not declaredPRIVATE).
The internal procedure of a module is only available in the containing modular procedure - the carrier.
 Variables declared in the module description section and modular procedures that are not protected by the PRIVATE attribute are called global
module objects .
A module can be referenced using the USE statement:
in the main program;• in an external procedure;
in another module.
When referring to a module in another module, make sure that the module did not refer to itself either directly or indirectly through other modules.
Comment. One of the uses of modules is the accumulation of interfaces external procedures, including those written in other languages programming. For example,
the DFCOM module supplied with CVF contains the interfaces used with ActiveX procedures. Sami the same procedures are contained in the dfcom.lib library.
Example:
module testmod
! Variables a , b and c are available in smod and smod 2 and in any programming unit,
! containing a USE TESTMOD link
integer, save :: a = 1, b = 1
​ integer, private :: c = 1​ ! Declared PRIVATE variable c
​ contains
​ ! available only in the TESTMOD module
224
225
 8. Program units
subroutine smod (d) integer
d, c2 / 1 / d = 2 b = 1 + c
call smod2 (d) print *,
'smod:', d, b contains
subroutine smod2 (d)
! Smod subroutine 2 available
integer d
print *, 'smod2:', d, b d = d
+ 1
! smod subroutine only
b = b + c2
! c 2 is available in smod 2 thanks to
the association
end subroutine smod2
! via media
end 
subroutine
smod
end 
module
testmod program
prom
use testmod
! Link to the TESTMOD module
print *, 'prom_1:',
a, b
! a and b are available in prom and
osub thanks to
call smod (a) print
*, 'prom_2:', a, b
call osub ()
print *, 'prom_3:',
a, b end program
prom 
subroutine
osub 
() 
use
testmod
print *, 'osub:', a,
b a = 4 b = 4
end 
subroutine
osub Result :
! use -association
prom_1:
​ 1
1
smod2:
​ 2
2
smod:
​ 3
3
prom_2:
​ 3
3
osub: ​ 3
3
prom_3:
​ 4
4
The variables a and b declared in the TESTMOD module are global in the sense that they are visible in any referencing module is a software component. This way
of transferring data called use - association .
Also, the values  of the variables a , b and c declared in the TESTMOD module are known to the modular subroutine smod and its internal subroutine smod 2.
This method of transferring data is called association via

carrier . Through media association, the internal
225
226
 O. V. Barteniev. Modern FORTRAN
smod 2 subroutine, carried by modular smod subroutine , has access to local variable c 2 smod routines .
Also, in the example, the main program is prom , the modular subroutine smod , internal subroutine smod 2 communicate via parameter d . This transfer of data is
called parameter association .
The considered use- association allows you to transfer not only data, but also the status of placed arrays (Section 4.8.2) and links. For instance:
module mod
integer, pointer :: a (:) end module
program tpo use mod
integer, parameter :: m = 4, n
= 5 integer, target :: b (5) = 5
a => b
! Attach a link to the
addressee b
call shost ()
! The link status will be
known in shost
print *, a
end program subroutine shost
()
use mod
integer, target :: c (3) = 3
! 3 3 3
print *, associated (a)
! T
print *, a a => c end
subroutine shost
! 5 5 5 5 5
The source text of the module can be placed in the same file, in which contains and uses its program units. Wherein its text must precede the module references.
Can be placed
module in a separate file, for example the TESTMOD module (one or both with other modules) can be placed in the mofil.f90 file. When compiling this file (the file
must be included in the project) for each its module, a file will be created with the module name and MOD extension.
Thus, a file testmod.mod will be created for the TESTMOD module. When working with compiled module files presence of source texts
modules in the project are optional, but the compiler must know paths to compiled files or to those containing these files libraries.
8.8. USE operator
The module is accessed by using the operator USE. If, for example, the operator is given
 226
227
8. Program units
USE TESTMOD
then the program unit gains access to all non-attribute
PRIVATE data objects declared in the module description section and modular module procedures. Moreover, all the objects of the module are known in the
software unit using it under the names that they have in the module.
At the same time, the USE statement allows:
restrict access to module objects by using the parameter
ONLY;
use other names for the module objects in the program unit.
For example, the TESTMOD module (Section 8.7) can be referenced like this:
use testmod, only: a, smod or like this:
program prom
use testmod, va => a, prosub => smod print *, 'prom_1:', va, b call prosub (va) call osub ()
end program prom
In the first case, in the software using the TESTMOD module unit will only see the variable a of the module and its subroutine smod . In the second case, as a
result of renaming the variable a of the module
TESTMOD will be available in prom under the name va , and modular a smod subroutine named prosub . Module global variable b
will be available under her own name. module and the program unit using it, of course,Interaction mechanism will remain.
Renaming and restricting access using ONLY used mainly to prevent name collisions. For instance, if a program unit uses two modules that have
with the same name global objects, then to prevent conflict by at least one of these objects should be used under the other name. If, for example, the name of the
global module object conflicts with the name of the local object using the program unit module and besides, this module object in this program unit is not applies,
the conflict can be overcome by limiting the ONLY option access to this object.
We now give a general representation of the two forms of the USE statement:
USE module name [, rename list ]
USE module name , ONLY: [ only - list ]
Rename list contains renaming of global objects module. Each item in the list looks like
 227
228
O. V. Barteniev. Modern FORTRAN
local-name => use-name
and means that the object of the module named use-name will be available in the program unit using the module named local-name . AT in general, you can use
several different ones for one use-name local-name , for example: use testmod, prosub => smod, prosub2 => smod
The only-list restricts access to the global objects of the module. The list item can be any global name, including
assignable operator, assignable assignment, generic name, name a derived data type declared in the module. For instance:

module mymod type point
​ ! Declare the derived data type point in the module real (4) :: x, y, z
end type point
end module mymod program t2
Also an only-list can include an element of the form
[ local name =>] use-name
The only-listed module objects cannot have an attribute
PRIVATE. If the ONLY option is specified, then in the using the module a program unit only has access to objects placed in the list only module.
A program unit can contain more than one USE statement for any module, for example:
use testmod, only: va => a, b use testmod, only: prosub => smod
In this case, only-lists are concatenated into one only-list . If though would one USE statement be used without the ONLY option, then using module, all global
objects will be available to a program unit module, and the renames present in the rename lists and only-lists are concatenated into a single list of renames .
Example:
module mymod real :: a = 5.0
end module mymod
use mymod
! The point data type is now available at t 2
type (point) :: pt
! Declaring a variable pt of type point
pt = point (1.0, 2.0, 3.0)
! Give a variable pt of type point initial
values
print *, pt end program t2
! 1.000000 2.000000 3.000000
 228
229
8. Program units
program t3
use mymod, a2 => a
! Now the variable a of the MYMOD module is available in t 3 under the name and a 2 print *, a, a2              ! 0.000000 5.000000
! Variable a can be used in t 3 as local end program t3
All local names used during renaming must differ from each other and from local names using the module program unit. Local program unit names must differ from
the global names of the modules referenced in it. For example, the following code:
module mymod real :: a = 5.0
contains subroutine b (d)
real d d = 4.5
end subroutine b
end module mymod
program t4
use mymod
b = 1.2
! Global name b is already used
in MYMOD
end program t4
! as a subroutine name
will cause a compilation error: Error: This name has already been used as an external subroutine name. [B] b = 1.2. If you add an ad in t 4
real (4) b
then an additional error will occur: Error: The attributes of this name conflict with those made accessible by a USE statement. [B] real (4) b.
The error can be avoided by first removing the use mymod link from t 4 , and second, by doing a rename, for example use mymod , b 2 => b , and, third,
changing the name of the local variable b of the main program t 4, for example on b 3.
The same global module object can be accessed under multiple local names. This is achieved either through its repeated use in the rename list, or, for example, So:
module a real s, t
...
end module a module b
 use a, bs => s
229
230
O. V. Barteniev. Modern FORTRAN
...
end module b
subroutine c
! The variable s of the module a is available to
the subroutine c
use a use b
...
end subroutine c
! under my real name s and name bs
The names of the global objects used by the program unit modules can be duplicated if:
two or more generic interfaces available to a software unit,have the same name, specify the same operation, or specify assignment. In this case, the compiler
considers all generic interfaces as one;
global objects that are not generic interfaces are availablesoftware unit, but are not used in it.
If USE statements are contained in a module, then all selected objects are treated as objects of the module itself. They can be given attributes
PRIVATE or PUBLIC either explicitly or by default. Ask any
other attributes of the selected objects cannot be, but they can be included in one or more namelist groups. However, you cannot set the PUBLIC attribute on an
object the included module, if the object has the PRIVATE attribute in the latter.
An example . Renaming derived type names data.
module geometry​ ! Derived Data Type Definitions type square
real side integer border

end type type circle
real radius integer border
end type
end module program test
! Rename module data type names for local use use geometry, lsquare => square, lcircle => circle
type (lsquare) s1, s2
​ ! Using new names when declaring type (lcircle) c1, c2, c3              ! variables
8.9. The PUBLIC and PRIVATE Attributes
PUBLIC and PRIVATE attributes can only be given to objects module. The PUBLIC attribute indicates that the module object can be available as a result of use -
association in those using the module
230
231
8. Program units
program units. In contrast, if the module object has the attribute PRIVATE, then it can only be used inside a module. The task attributes can be performed as a
separate operator, and with type declaration:
PUBLIC | PRIVATE [[::] module objects ]
type-spec , PUBLIC | PRIVATE [, attributes ] :: module objects
Module objects can include names of variables, constants, procedures, namelist groups, derived types and generic descriptions.
type-spec - an inline or derived type declaration operator
data.
By default, module objects have the PUBLIC attribute. If the operator
PRIVATE is specified without a list of module objects and there are no objects for which the PUBLIC attribute is explicitly set, then the action of the PRIVATE
attribute applies to all objects of the module, even if they are declared before the PRIVATE statement. For instance:
module pupr
​ ! Variables a and b have PRIVATE attribute real a private integer b
 A similar effect is caused by a task without a list of module objects operator PUBLIC. There can be only one operator in a module without a list
module objects (PUBLIC or PRIVATE).
An object cannot be given the PUBLIC attribute if it already has an attribute
PRIVATE.
Generic description, if it does not have a PRIVATE attribute, is PUBLIC even if one or all of its specific names are declared
PRIVATE.
If the namelist group has the PUBLIC attribute, then none of its components cannot have the PRIVATE attribute.
Components of a declared PUBLIC derived type have the attribute PUBLIC, except for components that have the PRIVATE attribute.
Example:
module pupr
type pri
! All pri variables
will be
private integer ix, iy
end type pri type, public ::
pub
real x, y
! have a PRIVATE
attribute
type (pri) epin
! 
This 
pub
component has
end type pub
! 
the 
PRIVATE
attribute
type (pub), public :: ep = pub (3.0, 4.0, pri (3, 3))
231
232
 O. V. Barteniev. Modern FORTRAN
real, public :: a = 3.0, b =
4.0 public :: length
private :: square
! The square subroutine is available
contains real function length
(x, y)
real, intent (inout) :: x, y call
square (x, y) length = sqrt (x
+ y)
end function
subroutine square (x1, y1)
real, intent (inout) :: x1, y1
x1 = x1 * x1 y1 = y1 * y1
end subroutine
end module pupr program
gopu
use pupr
! only in module pupr
print *, length (ep% x, ep% y)! 5.000000
print *, length (a, b)
​ ! 5.000000 end
8.10. Procedure Header Operators
The complete syntax for the subroutine header statement is:
[RECURSIVE] SUBROUTINE subroutine name
&

[([ list of formal parameters ])]
General view of the function header operator:
[ type ] [RECURSIVE] FUNCTION function name
&
([ list of formal parameters ]) [RESULT ( result name )]
8.10.1. General characteristics of procedure header statements
Procedure name ( subroutines and functions ) can be global and external or internal in the host procedure. Procedure name is not
may appear in statements AUTOMATIC, COMMON, EQUIVALENCE,
DATA, INTRINSIC, NAMELIST, SAVE. Subroutine name cannot appear in type declaration statements.
The formal parameter list can contain variable names and formal procedures. In the case of a subroutine, the formal parameter there may also be an asterisk
indicating an alternative return. Formal parameters may be missing if data transfer is in progress through use -association, media association or common -blocks.
The procedure can contain any operators except BLOCK DATA and PROGRAM. Before the CONTAINS statement, the procedure cannot contain
232
233
8. Program units
FUNCTION and SUBROUTINE statements. Internal procedures cannot contain the ENTRY and CONTAINS statements and other internal procedure. Internal
procedures are placed between CON-
TAINS and END of the main program or carrier procedure.
If the procedure is external, then its name is global and should not be the same as another global name, and shouldn't be used for the local name in the calling
program unit.
In the case of an internal procedure, its name is local and its scope actions are limited to the carrier.
If the formal parameter has the OPTIONAL attribute, then when calling the corresponding actual parameter can be omitted. Types formal parameters can be
specified implicitly within the procedure, and explicitly (the latter is preferable). Formal parameter names cannot appear in AUTOMATIC, COMMON, DATA
statements, EQUIVALENCE, INTRINSIC, SAVE or STATIC.
When calling a procedure, the actual parameters passed must be agreed with the corresponding formal ones in order (for except for the cases when calls with
keywords are used), by number (unless the OPTIONAL or
 C), by type and variety of type. The compiler checks for compliance parameters. When a discrepancy is found, as a rule, errors. Full verification of
compliance with factual and formal parameters is executed by the compiler when the interface to procedure. Modular and internal ones have an explicit interface.
procedures.
It is useful to explicitly set the interface to external procedures, and in large in most cases it is simply necessary (Section 8.11.3). If the called procedure is in a
dynamic library
(DLL), then you need to set its interface and use attributes with it
DLLEXPORT or DLLIMPORT [1].
The exit from the procedure is carried out as a result of executing either the END statement, or the RETURN statement. The latter may be placed anywhere
among the executable statements of the procedure.
8.10.2. Resulting variable of the function
The function must contain the resulting variable, in which the result returned by the function is placed.
The resulting variable name is given by the RESULT clause or matches the function name if the clause is omitted. Result name specified by RESULT clause cannot
match function name .
The type of the resulting variable determines the type of the function and can be
set by specifying type in the function header.
233
234
 O. V. Barteniev. Modern FORTRAN
type - declaration of the type and variety of the result type
variable (the result returned by the function). Can be anyone built-in type.
type can be omitted. Then the type of the resulting variable can
be specified explicitly in one of the function declaration statements, in the IMPLICIT or implicitly. The latter is impossible if the operator IMPLICIT NONE or $
DECLARE directive.
If type is specified in the header statement , then the name of the resulting variable must not appear in the function declaration section.
Examples of declaring the resulting variable:
function imax (a, n)
! Resulting variable imax ;
integer a (n)
! its INTEGER type is set
implicitly
...
! Executable Operators
logical function flag (a, n)
! The resulting variable
flag ;
integer a (n)
! its LOGICAL type is
set explicitly
function flag (a, n)
! The resulting variable
flag ;
logical flag
! its LOGICAL type is
set explicitly
function flag (a, n) result (vf) ! The resulting variable vf
;
logical vf
! its LOGICAL type is
set explicitly
If the type of the external function is defined without respecting the default rules data types or IMPLICIT NONE or $ DE-
CLARE, then the type of the function must either be declared in the caller program unit, or there must be an interface to this

functions. For modular and internal functions, this requirement is not spreads because they already have an explicitly given interface.
Example:
logical function flag (a, n) result (vf)
...
vf = ...
​ ! Determine the value of the resulting variable end program fude
If the result of the function is a variable of a derived type, array or reference, then type is omitted and the resulting variable declared in the function declaration
section.
logical flag, fl
...
! We declare the flag function in the calling program
! The type of the declared function is determined by the
type
fl = flag (a, n)
...
end
! result variable
 234
235
8. Program units
The resulting variable is similar to a parameter with the OUT link type. When entering a function, it is not defined, then it receives a value that then used in the
calling program unit.
The resulting variable can be used in expressions function, and as a result of calculations, it should receive a value. The last value of the resulting variable is used in
the expression from which the function is called. Result variable after execution of the function it may not be defined if it is
reference and function call is executed not from an expression (Section 3.11.8). Usually the resulting variable is assigned a value.
But this is optional. For example, in the case of a symbolic function the resulting variable can be defined after execution operator (Section 3.8.7)
WRITE ( result name , format specifier ) expression
The resulting variable can be a scalar or an array any built-in and derived type, it can also be a reference (Section 3.11.8). The result of a function cannot be a
resize array.
As in the case of a subroutine, a function can return data and via parameters passed by reference (parameters with the communication type OUT or
INOUT). However, this way of transferring data can lead to side effects (Section 8.11.6) and therefore cannot be recommended.
An example . Find the sum of the last negative elements of arrays a and b . Find the last negative element in the array.
in the finel function .
program nel
integer :: a (8) = (/ 1, -1, 2, -2, 3, -3, 4, -4 /) integer :: b (10) = (/ 1, 2, 3, 4, 5, -1, -2, -3, -4, -5 /)
​ integer :: finel
​ ! Declaring the function type
print *, finel (a, 8) + finel (b, 10)! Calling a function from an expression
end
function finel (c, n)
! -nine
integer finel
! Declaring the type of the resulting
variable
integer c (n), i
! We use an array of a given shape
finel = 0
! We define the resulting variable on
do i = n, 1, -1
! case if there are no negative ones in
the array
if (c (i) <0) then
finel = c (i)
! elements
return
end if
end do end function
! Return the last negative item
 235
236
O. V. Barteniev. Modern FORTRAN
8.11. Procedure parameters
Data exchange between the procedure and the calling program unit can be executed via procedure parameters.
The parameters used when calling the procedure are called actual .
The parameters used in the procedure are called formal .
An example . Form vector c 1 from elements of vector a that are absent in vector b 1. Then form vector c 2 from the elements of vector a , which are not in the
vector b 2. The formation of the arrays is performed in subroutine fobc .
program part
integer, parameter :: na = 10, nb1 = 5, nb2 = 7 integer :: a (na) = (/ 1, -1, 2, -2, 3, -3, 4, -4, 5, -5 /) integer :: b1 (nb1) = (/ 1, -1, 2, -2, 3 /) integer :: b2 (nb2) = (/
1, -1, 2, -2, 3, -3, 4 /) integer c1 (na), c2 (na), nc1, nc2
The actual parameters are present in the CALL fobc statement . Then as the parameters a , na , bc present in the SUBROUTINE fobc operator and m are formal
.
8.11.1. Correspondence of actual and formal parameters
When calling a procedure between actual and formal parameters set the correspondence (formal parameters associated with the corresponding factual). So, in our
example on the first call of the fobc subroutine to the actual parameter a
call fobc (a, na, b1, nb1, c1, nc1)
! Form an array c 1
call fobc (a, na, b2, nb2, c2, nc2)
! Form an array c 2
write (*, *) c1 (: nc1)
! -3 4 -4 5 -5
write (*, *) c2 (: nc2) end program
subroutine fobc (a, na, b, nb, c, nc)
! -4 5 -5

integer na, nb, a (na), b (nb)
! Input formal parameters
integer c (na), nc integer i, j, va
! Output formal parameters
nc = 0
! The number of elements in the generated
array
loop_a: do i = 1, na
! The DO construct name uses
va = a (i) do j = 1, nb
if (va == b (j)) cycle loop_a
end do nc = nc + 1 c (nc) = va
end do loop_a end subroutine fobc
! CYCLE statement loop_a
 236
237
8. Program units
corresponds to the formal parameter a , to the actual parameter b 1 formal parameter b , etc. Types of corresponding parameters
match. As you can see from the example, the names of the corresponding actual and formal parameters may vary.
In our example, most likely the actual and corresponding formal parameter will address the same memory area. True, this is not true in all cases. So, if the actual
the parameter is a section of the array, then when calling the procedure
the compiler will create a copy of it, which will be addressed by the formal
parameter. When exiting the procedure (if the parameter has the communication form OUT or INOUT) there will be a reverse transfer of data from the copy to
the sectionparameter.
The actual parameters can be expressions, including literal and named constants, simple variables, arrays and their sections, array elements, records, record
elements, strings and substrings as well as procedures and built-in functions; when subroutines, the actual parameter name can also be a label.
Formal parameters can be variables (full objects), procedures and an asterisk (*).
Actual and formal parameters can have attributes like
POINTER or TARGET.
By establishing correspondence between factual and formal parameters, you should adhere to those given in table. 8.2 of the rules.
Table 8.2. Actual and formal parameters
Actual parameter
Formal
parameter
Scalar expression
Scalar
variable
Non-scalar expression (array, array slice ...)
Array
Procedure
Procedure
* Label (only for subroutines)
* (asterisk)
Notes:
If the formal parameter is a link, then the correspondingthe actual parameter must also be a reference.
If the actual parameter is a string, then the formalthe parameter can be a string that takes the length (Section 3.8.2).
If the actual parameter is an array element, thenthe corresponding formal parameter can be an array (Sec.
 4.9.1).
237
238
O. V. Barteniev. Modern FORTRAN
If the actual parameter is an array, then the formalthe parameter can be an array of a given shape, or an a form array, or a resizing array (Section 4.9).
If the actual parameter is an external procedure, then it musthave an EXTERNAL attribute. If the actual parameter is an inline procedure, it must be declared with
the INTRIN attribute SIC.
8.11.2. Parameter link type
Formal parameters are divided into input, output and input / output. An input formal parameter gets its value from the corresponding actual parameter. Day off -
sends his value corresponding to the actual parameter. Input / output communicate in two directions.
In the fobc subroutine (Section 8.11), the formal parameters a , na , b, and nb are input. Parameters c and nc are output, i.e. their values defined in a procedure
and then used in the caller
software unit. This separation of the formal parameters of the example for the entrance / weekend, we performed, based on the program action. In fact, the type of
connection of the formal parameter can be set explicitly using the INTENT attribute, for example:
subroutine fobc (a, na, b, nb, c, nc)
integer, intent (in) na, nb, a (na), b (nb) integer, intent (out) c (na), nc integer i, j, va
The INTENT operator can be used to set the INTENT attribute:
subroutine fobc (a, na, b, nb, c, nc)
integer na, nb, nc, a (na), b (nb), c (na), i, j, va intent (in) na, nb, a, b intent (out) c, nc
The syntax for the INTENT statement is:
INTENT ( spec ) [::] vname
The syntax for the INTENT attribute is: type-spec, INTENT (spec) [, attrs] :: vname spec - a kind of formal parameter link, spec can take one
of three values:
• IN - the formal parameter is input and cannot be changed or become undefined in the procedure. Associated with him the actual parameter can be an expression
such as a constant or a variable;
238
239
8. Program units
OUT - formal parameter is output. Upon entering procedure, such a formal parameter is always undefined and therefore must get the value before using it.
Associated with the actual parameter must be definable, for example variable, substring or record element;
INOUT - the formal parameter can both receive data fromthe actual parameter and pass the data to the caller program unit. As with the OUT link type, the actual
parameter associated with it must be definable (should not be, for example, a constant).

vname - comma-separated names of formal parameters.
type-spec is a specification of any data type.
attrs - a list of other attributes of the formal parameter.
 If the INTENT attribute is not specified, then the way to use the formal parameter defines the actual parameter associated with it. So, a formal
parameter should not be overridden in a procedure if its associated actual parameter expression or constant.
real :: length, x = 3.0, y = 4.0,
r
r = length (3.0, 4.0)
! This call is wrong
r = length (x, y) end
! This call is valid
real function length (x, y)
! The first call is wrong
because
real x, y
! formal parameters x
and y
call square (x, y) length = sqrt
(x + y) end function
! 
overridden 
in
subroutine square
subroutine square (x1, y1)
real, intent (inout) :: x1, y1 x1 = x1 * x1 y1 = y1 * y1
end subroutine
If the formal parameter has the form of a connection IN, then it should not be used as an actual parameter associated with
formal parameter, the connection type of which is OUT or INOUT. So, in in the previous example, the formal parameters x , y of the function length are not must
be of the link type IN.
If a function defines an overloaded operation, then the formal the parameters must have the link type IN. If the subroutine defines given assignment, then its first
formal parameter must have the type of connection OUT or INOUT, and the second - IN. INTENT attribute is not allowed:
• for formal parameters with the POINTER attribute;
239
240
O. V. Barteniev. Modern FORTRAN
• for formal parameters - procedures (formal procedures).
8.11.3. Explicit and Implicit Interfaces
The interface between the procedure and the program calling it unit is considered given if the calling program unit
the name of the procedure, its type (subroutine or function), properties are known functions (if the procedure is a function), names, position and properties formal
parameters.
In Fortran 77, the interface to the called procedure is completely unknown and it is set when called on the list of actual parameters. The interface set up in this way
is called implicit . Such calls can cause a number of errors because the compiler is not always able to check, for example, whether the actual and formal
parameters correspond to them it should be.
Calls to external procedures with an implicit interface are also allowed in modern Fortran. In the case of a function with an implicit interface, its type is and the kind
of type are specified in one of the type declaration statements calling program unit or are set according to with the default rules in force.
 However, formal parameters of procedures and procedure-functions can have additional properties that you should know about the compiler to
correctly organize access to the procedure code. To tell the compiler such information, between the caller there must be an explicit program unit and procedure
interface .
In the case of an internal procedure, the calling program unit and its procedures are compiled as a whole, so the compiler knows everything about any internal
procedure, i.e. between an internal procedure and an explicit interface exists for the calling program unit.
A modular procedure is called either in the module itself or from a program unit where the call is preceded by a USE statement for that module. Therefore, in both
cases, the compiler knows everything about the called procedure and therefore its interface is explicit.
Also, all built-in procedures are known to have an explicit interface.
In the case of an external procedure, an explicit interface. This is done using an interface block of the form:
INTERFACE
interface body
END INTERFACE
The body of an interface contains a description of one or more interfaces procedures. Typically, the procedure interface is an exact copy of the header
240
241
8. Program units
procedure, declarations of its formal parameters, the type of function in the case procedure-function and operator END procedure. However, in the interface
block:
parameter names may differ from the correspondingformal parameters of the procedure;
additional specifications may be added (for example,local variable declarations) except for declarations internal procedures and operators DATA and FORMAT;
you can present the same information using a differentcombinations of declaration statements.
 Example:
subroutine sub1 (i1, i2, r1,
r2)
integer :: i1, i2
real :: r1, r2
! In the declaration section of the
procedure, the attribute
...
end subroutine sub1 program
idem
! OPTIONAL can be omitted. It's
enough
! that it is specified in the interface block
interface
! Sub 1 interface
subroutine sub1 (int1, int2, real1, real2)

integer :: int1, int2 real, optional :: real1, real2
end subroutine sub1
end interface
An interface of external procedures written by in other programming languages, such as assembly or CI.
Availability such interfaces allows create multilingual applications [1].
Specifying an interface means that the procedures referred to in it treated as external. Any built-in procedure with the same name becomes unavailable. Mentioning
the procedure name in the EXTERNAL statement. Simultaneous mention procedure name in interface body and EXTERNAL statement is not valid.
The interface block is placed among the description operators. More convenient assemble the interface blocks in one or more modules in total and connect them
as needed using the USE operator.
An explicit interface is required if:
the procedure has optional formal parameters;
the result of a function-procedure is an array (Section 4.11);
the formal parameter of the procedure is the form-assumingarray (Section 4.9.2), link or its addressee (Section 3.11.8);
241
242
 O. V. Barteniev. Modern FORTRAN
the length of the result of a symbolic function is not a constant and is nottaken over from the calling program unit; • the result of a function-procedure is a link;
the procedure is a dynamic library.
Also interface blocks are used:
when calling a procedure with keywords (Section 8.11.4);
when using a given assignment (Section 8.12.2);
when using specified operations (Section 8.12.2);
when using a generic name in a call (Section 8.12);
for access to external procedures written in other languages  [1].
8.11.4. Key and optional parameters
For some procedure calls, some of the actual parameters may not be used. An example of such a procedure is
built-in function SUM ( array [, dim ] [, mask ]) (Section 4.12.1), which has two optional parameters dim and mask . In this case, the corresponding formal
parameters must be declared with the OPTIONAL attribute. Like other attributes, OPTIONAL can be used in the statement type declarations and as an
independent operator.
Example. Create a function npe ( array , me , sig ) returning:
the sum me of the first positive elements of array , if sig > 0;
the sum me of the first negative elements of array , if sig <0;
the sum me of the first elements of array , if sig = 0 or absent;
the sum of all array elements specified by the sig- sign, if parameter me is missing . program tesop
integer, parameter :: m = 3, n = 10
integer :: a (n) = (/ 1, -1, 2, -2, 3, -3, 4, -4, 5, -5 /)
! You must explicitly set the interface to the procedure
interface
​ ! with optional formal parameters integer function npe (array, me, sig)
integer, intent (in) :: array (:)
243
8. Program units
integer, allocatable :: temp (:)
​ if (.not. present (sig)) then
​ ! Use unassociated
​ sval = 0
​ ! optional formal parameter
​ else
​ ! can only be used as an argument
sval = sig
​ ! PRESENT functions end if
if (present (me)) then
mval = me else mval = size (array)
integer, intent (in), optional :: me, sig
end function npe end interface
print *, npe (a, m, 1)
! 6
print *, npe (a, sig = -1)
! -fifteen
print *, npe (a)
end program tesop
integer function npe (array, me, sig)
integer, intent (in) :: array (:) integer, intent (in), optional :: me, sig integer mval, sval
! 0
242
 end if select case (sval)
case (1 :)
​ ! Size temp may be less mval allocate (temp (min (mval, count (array> 0)))) temp = pack (array, array> 0)
case (: - 1)
allocate (temp (min (mval, count (array <0)))) temp = pack (array, array <0)
case (0)
allocate (temp (mval)) temp = array (1: mval)
endselect
npe = sum (temp)
​ ! Returned result deallocate (temp)
end function npe
OPTIONAL statement syntax:
OPTIONAL [::] vname
The syntax for the OPTIONAL attribute is: type-spec , OPTIONAL [, attrs ] :: vname type-spec is a specification of any data type.
vname - comma-separated names of formal parameters.

The attribute can only be used for formal parameters procedures. The interface of a procedure containing the OPTIONAL attribute must be explicitly described. A
formal parameter with the OPTIONAL attribute may additionally have only DIMENSION, EXTERNAL attributes, INTENT, POINTER and TARGET.
If an optional formal parameter is not specified, then it cannot be assigned a value and cannot be used in an expression. For determining whether a formal
parameter is given or not is used built-in function
PRESENT ( a )
 243
244
O. V. Barteniev. Modern FORTRAN
where a is an optional formal parameter. The function returns .TRUE., if the formal parameter a is associated with the actual parameter , and .FALSE. otherwise.
An optional formal parameter can be used internally procedures as an actual parameter. If so optional parameter is absent, then it is considered as missing and in
next level procedure. Missing parameters can extend to any depth of call. Missing parameter can appear as an actual parameter only as complete an object, not as
its subobject.
Fortran 77 has the location of the corresponding formal and the actual parameters in the parameter list must match, i.e.
the first formal parameter is associated with the first actual parameter, and so on. If the associated formal parameter is determined by the position the actual
parameter in the parameter list, then such an actual the parameter is called positional .
In Fortran, this rule can be violated by using when calling a procedure parameters with keywords. Key words these are the names of the formal parameters
assigned to them in the interface block For example, calls to the npe function are valid :
result = npe (sig = 1, array = a, me = m) result = npe (a, sig = 1, me = m) result = npe (a, sig = 1)
In the first call, all parameters must be preceded by key words. In the second and third - the first parameter is positional, therefore, it can be specified without a
keyword. In the third case, not the second formal parameter is given, therefore, to establish a connection with the formal parameter sig must use a call with a key
word - the name of the formal parameter.
However, positional parameters cannot appear in the list actual parameters after the first appearance of the parameter with the key word. So, the call is wrong
result = npe (array = a, m, 1)
8.11.5. Limitations on actual parameters
The standard sets two limits on actual parameters:
any actions affecting the value andavailability of the actual parameter bypassing the corresponding formal parameter;
if at least part of the actual parameter receives a value fromformal parameter, then in the procedure refer to this actual parameter is possible only through formal
parameter.
 244
245
8. Program units
To illustrate the limitations, consider an example:
integer a (10) / 10 * 2 /, x, xx, y / 2 / common / cb / x, xx character (10) st / '??????????' /
call rest1 (x, xx, a (1: 7), a (4:10))! According to constraint 1 in rest 1
call rest2 (y, st (3: 7))
​ ! you cannot change the value of a (4: 7) print *, x, xx, a (5), y, '', st
Although the example is full of violations, CVF and FPS will not give a single error messages or warnings. However, this does not mean at all that the program will
work correctly. In general, the result is unpredictable. This can be seen, in particular, from the outputted results:
​ CVF: ​ 11 1107558400
​ 7
​ 6 ##########
​ FPS: ​ 11 1107558400
​ five
​ 6 ##########
Likewise, if a variable like xx is available rest 1 procedure through a module and at the same time is associated with a formal parameter xx 2 of this procedure,
then constraint 1 will be violated at trying to change the value of xx in rest procedure 1.
8.11.6. Prohibited side effects
The standard allows not evaluating a part of an expression if the value of this expressions can be defined without it. So, in the example
contains
subroutine rest2 (y2, st2)
integer y2 character (*) st2
y2 = 4
! Right
y = 6
! Limit 2 violated
st2 = '&&&&&'
! Right
st = '##########'
end subroutine rest2
end
subroutine rest1 (x2, xx2, a, a2)
integer x2, xx2, a (*), a2 (*) common / cb / x, xx
! Limit 2 violated
x = 1
! Limit 1 violated
x2 = 11
! Right
xx2 = 3
! Right
xx = 33
! Limit 1 violated
a (1: 3) = 22
! Right
a2 (5: 7) = 44
! Right
a (4: 7) = 5
! Limit 1 violated
a2 (1: 4) = 7 end
! Limit 1 violated
 245
246
O. V. Barteniev. Modern FORTRAN
logical g, flo
real :: x = 5.0, y = 4.0, z =
7.0 g = x> y .or. flo (z)

print *, g, z
! FPS:
T
7.0000
end
! CVF:
T
100.0000
logical function flo (z) z = 100 flo = .true. end function flo
in FPS the call to the boolean function flo will not be executed . AT in accordance with the provisions of the standard, the value of the variable z must after
evaluating the expression, become undefined. While in FPS variable z and will retain its value, and in CVF will change, completely it is obvious that such function
calls should be avoided. Really, if x was 3.0, then after evaluating the expression in FPS we would get a completely different value for z - the number 100.0.
Another example where the standard allows incomplete computation expressions:
character (len = 2) :: stre, st1 = 'd1', st2 = 'd2'
! stfun is a symbolic function. The standard allows not to make a call to stfun ,
! since the length of the result stre is st 1 and it is completely determined by the first
! operand of expression st 1 // stfun ( st 2) stre = st1 // stfun (st2) print *, st2
contains
character (2) function stfun (st2)
character (*) st2 st2 = 'd3' stfun = 'd4'
end function stfun
end
Note, however, that both CVF and FPS call stfun and variable st 2 will get the value 'd3'.
There is another limitation: a function call must not override the value of a variable appearing in the same statement, or to influence the result of another function
called in the same statement. For example, in
d = max (dist (p, q), dist (q, r)) the dist function must not override the q variable .
Such effects can be avoided by programming the procedure as a function only if there is only one output parameter.
246
247
8. Program units
8.12. Overloading and generic interfaces 8.12.1. Overloading procedures
It is sometimes helpful to be able to address multiple procedures using one name. Implement a similar possibility is possible by combining through generic interface
different procedures under one generic name . The names of the merged procedures are called specific . The very mechanism of calling different procedures under
the same name is called overloading . Overload mechanism implemented when developing built-in procedures (see Section 6.3).
Let's build, for example, the function mymax ( arg 1, arg 2), which returns the maximum value of its two parameters. Function parameters should be one of the
following types: INTEGER (4), REAL (4), or
CHARACTER (*). The function's result type is the same as the parameters.
In fact, for each type of parameters, you will have to create your own a function like inmax , remax and chmax and then applying the generic interface, we will
merge the created functions under one generic name.
program getest
​ interface mymax ​ ! Generic interface definition
 function inmax (int1, int2)
​ ! mymax - generic name for functions integer (4) inmax, int1, int2! inmax , remax , chmax
end function inmax
function remax (re1, re2) ! inmax , remax , chmax - specific
real (4) remax, re1, re2
! the names of the functions
combined under
end function remax
! one generic name mymax
function chmax (ch1, ch2)
character (*) ch1, ch2
character (len = max (len (ch1), len (ch2))) chmax
end function chmax
end interface
integer (4) :: ia = 1, ib = 2 real (4) :: ra = -1, rb = -2
character (5) :: cha = 'abcde', chb = 'ABCDE'
​ print *, mymax (ia, ib) ​ !
​ 2
print *, mymax (ra, rb) ​ !
​ -1.000000 print *, mymax (cha, chb)              !              abcde end program getest function inmax (int1, int2)
integer (4) inmax, int1, int2 if (int1> = int2) then
inmax = int1
else inmax = int2
end if end function inmax
247
248
O. V. Barteniev. Modern FORTRAN
function remax (re1, re2)
real (4) remax, re1, re2 if (re1> = re2) then
remax = re1
else remax = re2
end if
end function remax function chmax (cha1, cha2)
character (*) cha1, cha2
character (len = max (len (cha1), len (cha2))) chmax if (lge (cha1, cha2)) then
chmax = cha1
else chmax = cha2 end if
end function chmax

The generic interface can be defined more compactly if the functions are modular procedures. In this case, the interface to them is set explicitly and in the interface
block created for the generic name is inserted operator
 MODULE PROCEDURE list of procedure names
which lists the names of all the modular procedures to be overloaded. For instance:
module gemod
interface mymax
module procedure inmax, remax, chmax
end interface contains function inmax (int1, int2)
...
end function inmax function remax (re1, re2)
...
end function remax function chmax (cha1, cha2)
...
end function chmax
end module gemod program getest
use gemod
print *, chmax ('abcde', 'ABCDE')! The procedure call can be performed by end program getest              ! using her specific name
248
249
8. Program units
Comment. Fortran 95 allows you to complete the interface block with generic name. For instance:
interface mymax ​ ! Generic interface definition module procedure inmax, remax, chmax
​ end interface mymax
​ ! We end the block with the generic name mymax
The same form for specifying the interface can be applied if in module contains only procedures that are merged under the generic name:
program getest
use fuma
​ ! The fuma module contains the functions inmax , remax , interface mymax              ! chmax , but no generic interface module procedure inmax,
remax, chmax
end interface
print *, chmax ('abcde', 'ABCDE')! abcde
end program getest
 Combined procedures can have a different number of parameters. Also under the same name both subroutines and functions can be overloaded.
In the interface block, the generic name can match any the specific name of the procedure for that block.
The generic name can also be the same as another available name, for example through use- association, generic name. Then with this name all the procedures it
covers can be called.
All procedures under the same generic name must differ so much that for each specific call it is possible
unambiguously select one of the combined procedures. For this in each a pair of overloaded procedures at least one must have a mandatory a parameter that
meets two conditions at once:
by its position in the parameter list, it either does not haveanalogue among the formal parameters of another procedure, or matches a parameter of a different type
or kind of type or another rank;
a formal parameter with the same name or is absent in anotherprocedure, or is present, but has a different type or variety type or other grade.
An example of a violation of the second condition:
interface fu12
function f1 (x, i) ! Each of the formal parameters f 1 has
real f1, x
! analogue among the formal parameters of the function
f 2
integer i
! Conversely, each of the formal parameters f 2
end function f1
function f2 (i, x)
! has an analogue among formal parameters f 1
real f2, x integer i
249
250
 O. V. Barteniev. Modern FORTRAN
end function f2
end interface
The CVF compiler receiving such interfaces will issue the message:
Error: The type / rank / keyword signature for this specific procedure matches another specific procedure that shares the same generic-name. [F2] function f2 (i,
x).
8.12.2. Overloading operations and assignments
You can expand the scope of the built-in operation. it is performed using an interface block whose header has view:
INTERFACE OPERATOR ( given by the operation )
All other components of the interface unit are the same as for overloading procedures. The procedure defining the operation must be be a function with one (in the
case of a unary operation) or two parameters that have the link type IN. Function parameters should be mandatory. The result of a function cannot be an assuming
length line.
Such a block associates the specified operation with one or more functions that define the actions performed by this operation. For instance, you can specify the
addition operation of derived type variables. Then in the case of using an operation, depending on the type of its operands, either the built-in addition operation is
performed if the operands are numeric, or the specified operation if the types of the operands are the same as the types formal parameters of the function specified
in the interface block.
The stated mechanism for specifying an operation is called operation overloading .
module tdes

type ire
! Demonstration of overloading the
addition operation
integer a
! Overloading Operations for Derived
Types
real ra
! necessary because they do not exist
end type ire end module tdes ! no built-in operations
module plup
use tdes interface operator (+)
​ ! Specifying the addition operation for the ire type
module procedure funir
end interface contains
function funir (rec1, rec2)
​ ! Parameters of the operation setting function type (ire) funir              ! must have the link type IN type (ire), intent (in) :: rec1, rec2
funir = ire (rec1.a + rec2.a, rec1.ra + rec2.ra)
end function funir end module plup
 250
251
8. Program units
program top
use plup
​ ! The ire type is passed through the plup - tdes modules integer :: ia = 1, ib = -1, ic
type (ire) :: t1 = ire (1, 1.0), t2 = ire (2, 2.0), t3 = ire (3, 3.0), t4
ic = ia + ib
! Inline addition is in progress
t4 = t1 + t2 + t3
! The specified add operation
is performed
print *, ic, t4
end
! 0 6 6.000000
When an inline operation is overloaded, its number cannot be changed operands. So, you cannot specify a unary multiplication operation. Because the relation
operations have two forms, for example (.LE. and <=), then the given for them, the interface extends to each of the forms.
You can enter a new operation in the same way. Input name operations should be framed by dots. For example, to denote operations of addition of variables of
type ire could enter the operation .plus .: interface operator (.plus.)
Then the application of the newly introduced operation can be as follows:
t3 = t1 .plus. t2 .plus. t3
Like a built-in, a newly introduced operation can be propagated to different types of operands.
You can also do assignment overloading . Interface block on assignment overload has a header
INTERFACE ASSIGNMENT (=)
All other components of the interface unit are the same as for overloading procedures. The assignment procedure must must be a subroutine with two formal
parameters, the first of which is OUT or INOUT, and the second is IN. Subroutine parameters must be required. First parameter subroutines as a result of
performing the given assignment will be contain its result, in the second - the value of the right side is passed assignment.
An example . Set an assignment to perform initialization derived data type.
module tic type icha
integer a, b character (10) fi, se
end type icha
end module tic module oves use tic
252
O. V. Barteniev. Modern FORTRAN
interface assignment (=)
! Setting an assignment to initialize a
record
 251
module procedure assir
end interface contains
subroutine assir (rec, k) type (icha), intent (out) :: rec integer, intent (in) :: k integer :: stlen stlen = len (rec% fi)
rec = icha (k, k, repeat (char (k), stlen), repeat (char (k), stlen))
end subroutine assir end module oves
program top
use oves
! The ire type is accessed through the
use association
type (icha) :: t
! via modules oves - tic
t = 35
! 
The 
specified 
assignment 
is
performed
print '(2i4, 2 (1x, a))', t
! 35 35 ########### ##########
end
If two procedures defining one generic operation or assignment, have the same number of required parameters, then for call unambiguity one of them must have at
least one formal parameter, which by its position in the parameter list matches a parameter of another procedure, either of a different type, either a different type of
type, or a different rank. This rule is applies to the case when more than two procedures have one generic operation or specify an assignment.
8.12.3. General view of the INTERFACE operator
The INTERFACE operator is used to explicitly specify an interface to external procedure, generic interface, generic operation and assignment. Its syntax is:
INTERFACE [ generic description ]
[ interface body ]
...
[MODULE PROCEDURE list of procedure names ]

...
END INTERFACE
where generic description is the generic name , or
OPERATOR ( defined operation ) or
ASSIGNMENT (=)
 252
253
8. Program units
interface body - specifies the characteristics of external or formal
procedures and represents in case of function function header
[ description section ]
END [FUNCTION [ function name ]] or in the case of a subroutine
subroutine header
[ description section ]
END [SUBROUTINE [ subroutine name ]]
The MODULE PROCEDURE statement can appear in the interface block only when a generic description is present . Moreover, all procedures list of procedure
names should be available modular procedures. The characteristics of modular procedures should not appear in interface block.
A procedure declared in an interface block has the attribute EXTERNAL. It cannot be declared external via the attribute or an EXTERNAL statement in a
program unit in which there is or available through the use- association interface block with this procedure. For a procedure in a visibility block, only one interface
unit.
Internal, modular and inline procedures have an explicitly defined interface, and their names must not appear in the interface block. An exception is the case when
it is necessary to set a generic name. In this case, the names of the modular procedures are specified by the MODULE operator PROCEDURE. If the name of
the procedure declared in the interface block matches the name of a built-in procedure, then such a built-in procedure becomes unavailable. At the same time,
there must be an external procedure with the same name.
If the name of the interface block procedure is the same as the name a formal parameter of the procedure in which the interface block is specified, then such a
formal parameter is a formal procedure.
Interface body cannot contain ENTRY, DATA, FORMAT, operator function declarations. You can, however, ask an independent ENTRY interface using the name
in the interface body entry point as the name of the procedure.
The BLOCK DATA program unit cannot contain interface block.
8.13. Associating names
 Most of the objects in a Fortran program are local.
These include the names of variables, constants, derived data types, internal and modular procedures, operator functions. The global
253
254
O. V. Barteniev. Modern FORTRAN
are the names of the main program, built-in and external procedures, modules, common -blocks, BLOCK DATA. However, the local object program unit can be
made available in another program unit one using name association: parameter association procedures, use -association and association through the media.
At the time of calling the procedure, between formal and actual parameters establish a connection, or, in other words, formal procedure parameters are associated
with actual ones. Thanks to such communication:
data exchange between software units is carried out;
an alternative return from a subroutine is implemented (Section 8.19);
the name of an external or built-in function is passed to the procedure.
Learn more about the rules for matching formal and actual parameters see sect. 8.11.1.
Module objects become available in a program unit if it contains a USE statement containing the name of the module. Using this operator is equivalent to
redescribing all non-attribute PRIVATE module objects within a program unit with persistence all names (if there are no renames) and properties. (Access to
module objects can be limited by using the option in the USE statement
ONLY.) In this case, it says that the module objects are available through useassociation. Through use- association it can be provided access to the following
module objects:
named data objects;
definitions of derived types;
interface blocks;
modular procedures;
generic interfaces;
namelist -groups.
Use -association transfers both data and status of objects, for example the status of the array being allocated (Section 4.8.2).
When connecting to a software unit, modules must not be duplication of names passed through use- association of names and local names of the program unit
itself. However, available through useassociation names can match if:
there is no use of a duplicate name;
the duplicated name is generic (Section 8.12).
Name conflicts can be avoided by renaming, using the ONLY option and by giving the PRIVATE attribute to topics module objects that are intended only for
internal use in the module.
254
255
8. Program units
All media objects are available in modular and internal procedures these procedures, including the objects available to the carrier through useassociation. This
mechanism for accessing media objects is called association through a carrier . The general rule of thumb is: object name media is considered redescribed with the
same properties in the modular or an internal procedure, provided that there is no other in the procedure an object of the same name, declared locally, or
accessible by use- association, or which is a local formal parameter or the resulting variable.
Example:
real :: x = 1.0, w = 1.0, z = 1.0

call decar (x)
print '(3f5.2)', x, w, z
​ ! 5.0 1.0 5.0 contains
subroutine decar (x)
real x, w
​ ! The local variable w of the decar routine x = 5; w = 5; z = 5              ! closes the local variable w of the media
end subroutine
end
 8.14. Name scope
The scope of a named object is the part a program in which you can refer to this object.
For example, an object declared in an external procedure can be referenced in this procedure. In addition, this object is due to association through the medium is
available in any of its internal procedures. Moreover, the procedure itself may contain fragments in which no reference to this variable is possible. Such fragments
can be type definitions and interface blocks. Here is a fragment of the procedure for the described situation.
subroutine reg ()
integer, parameter :: m = 40, n
= 20
! Area 1
real a (m, n), b (3, 4, 5) type
win
! Area 1
integer n
! Area 2
real a (n)
end type interface
! Area 2
subroutine ones (a, m)
! Area 3
integer m
! Area 3
real a (:,:, :)
! Area 3
end 
subroutine 
ones 
end
interface
! Area 3
type (win) tin (n)
! Area 1
255
256
O. V. Barteniev. Modern FORTRAN
a = real (n)
! Area 1
tin (n) .a = real (m)
! Area 1
print *, a (m, n), tin (n)
.a (1)
! Area 1
call ones (b, n) call two
() contains
! Area 1
subroutine two ()
! Inner subroutine is not scope
integer m
! visibility of media objects, but media
objects
m = n
! n , a , b , win , tin and the interface to
the subroutine
a = real (m)
! ones are reachable in two due to
association
call ones (b, m)
! through the media. Variable m
subroutine
end subroutine two end
subroutine reg
! two closes the carrier constant m
program t2 call reg ()
end program t2
! Driver subroutines reg
subroutine ones (a, m)
integer m
real a (:,:, :) a = real (m)
end subroutine ones
 In this snippet, area 1 is the constant scope m and n . However, the same constants are visible in region 2 of the definition derived type: the REAL a (
n ) declaration uses the constant n from area 1. At the same time, in area 2, you can declare a component named n . In area 3 of the interface block, the constants
m and n , as well as the array a (1: m , 1: n ) are not visible. In other words, used in areas 1, 2 and 3 the names m , n and a refer to different data objects. In this
way, the scope of constants m and n consists of three visibility blocks, separated by area 3. The scope of the array a (1: m , 1: n ) and three-dimensional array b
are two blocks already separated by two areas numbered 2 and 3.
The scope of a named object depends on the kind of its name.
Object names are divided into global , local and operator names .
The names of the main program, modules, built-in and external procedures and common -blocks. These names are known in any program unit, and there cannot
be two global objects with one name. So, there cannot be a common block named sqrt , since it is the name belongs to the built-in function.
If in any block of visibility a local variable sqrt , then the global name of the built-in SQRT function in this block visibility becomes inaccessible.
256
257
8. Program units
If the global name of the built-in procedure is defined in the block visibility with the EXTERNAL attribute, then the built-in procedure also becomes unavailable in
this visibility block, but the entered name interpreted as the global name of an external procedure.
Example:

real :: sqrt, x = 4.0, y
real, external :: sin
! An external sin function must be
defined
sqrt = 5.0
! Local name closes global name
y = sqrt (x)
! Error - Built-in SQRT Function
Not Available
For local names include the names of variables, formal parameters, named constants, derived types, operator functions, internal, modular and formal procedures,
generic descriptions, namelist -groups. The local name visibility blocks are: • definition of a derived type;
interface body, excluding the definitions it containsderived types and bodies of interface blocks;
 program unit, excluding those contained in itdefinitions of derived types, interface blocks and internal procedures.
Local names, if declared in the visibility block, close names of global objects, and the latter become inaccessible in this block of visibility. The exceptions are those
used when calling procedures are keywords, generic descriptions, and common block names . The above showed how the local sqrt name closed the global name
the built-in SQRT function. The same effect will be caused by using an inner function, for example named tan , which will close in a block visibility is the name of
the built-in TAN function, for example:
subroutine dehi
...
y = tan (x) ​ ! The inner function tan will be called contains function tan (x)
...
end function tan
end subroutine dehi
An operator name is scoped to a single operator.
Operator names can appear when defining an operator function, and also in the implicit loops of DATA statements and array constructors. The scope of the formal
parameters of the operator function is the operator for setting this function. Variable scope
an implicit loop, which must be of type integer, is this loop.
257
 258
O. V. Barteniev. Modern FORTRAN
The implicit loop parameters of I / O statements are not operator parameters, but are local and can be of real type. For instance:
real c (100)
z (x, y) = sin (x) * exp (-y)
​ ! We define the operator function z b = 55.0
! The variable b will be used as a loop parameter of the WRITE statement write (*, '(5f7.4)') ((z (a, b), a = 0.0, 1.0, 0.2), b = 0.0, 1.0, 0.2)
k = 55
! k - local variable
c = (/ (float (k), k = 1, 100) /)
! k is an example of an
operator name
print *, b
! 1.20000
print *, k end
! 55
Comment. Use non-integer parameters in an implicit loop, just like and in a DO-cycle with a parameter, it is not recommended (see P.-2.2.4).
The local object name does not cover the common -block name , so these names can be used simultaneously in a visibility block. The common -block name , if
used in a SAVE statement, must be framed by slashes.
For instance:
common / vab / a, b
real vab
! Variable names vab and common -block are the
same
save :: / vab /, vab
! Both the variable and the common block have the
SAVE attribute
The names of local objects in the visibility block can be the same as keywords used in procedure calls. Region
the visibility of keywords is determined by the scope of the interface block to the procedure in which these keywords are described. Scope interface block can be
extended to other software unit as a result of use- association or association through the carrier.
8.15. Scope of labels
Labels are local objects. Main program and each
procedures have their own independent set of labels. Media END operator may have a label. If such a medium has internal procedures, then they split the scope
of this label into two blocks: before the statement CONTAINS and the media END statement.
8.16. Associating memory
Fortran provides the user with another way to exchange data is an association of memory. By applying the COMMON operator, in the program can create a
shared memory area on which you can reference from all program units containing this operator. For instance:
259
program gocom
integer (4) a, b, c
8. Program units
common / vab / a, b, c
! Create a shared numeric memory
area
a = -1
! There are 3 units in this area
call chaco ()
! memory of 4 bytes each
print *, a, b, c
end program gocom subroutine chaco ()
integer (4) ia, ib, ic common / vab / ia, ib, ic
! 1 2 3
print *, ia
ia = 1; ib = 2; ic = 3 end subroutine
! -1
 258

In the above example, the variables a , b and c of the main program and the variables ia , ib and ic chaco subroutines share the same scope memory. Moreover,
the variables a and ia address the same memory unit. This means that after exiting the subroutine, the variable a will receive the value of the variable ia . The same
is true for pairs of variables b and ib , c and ic .
Names of the same order located in different software units of common -blocks can match. They can also vary.
(this can be seen from the example). Moreover, they can differ in rank and form. So, we get the same result by creating, for example, subroutine:
subroutine chaco ()
In this case, already a and abc (1) address the same memory unit.
The same is true for pairs b and abc (2), c and abc (3).
Another example of memory association is the use of the EQUIVA-
LENCE, which explicitly indicates that two or more objects occupy one memory area.
integer :: a (5) = 3, b (5)
equivalence (a, b)
print *, a
! 3 3 3
3 3
print *, b
! 3 3 3
3 3
integer (4) abc, k
common / vab / abc (3)
! Array abc instead of variables a , b and c
print *, abc (1) abc = (/ (k, k = 1, 3) /) end subroutine! -1
 The memory access mechanism considered by examples is called association of memory . This mechanism is used to exchange data. True, in the old
days, with a lack of computational resources, it was often used to save memory. Last thing was carried out by using the EQUIVALENCE operator. However,
such 259
260
O. V. Barteniev. Modern FORTRAN
practice is the cause of many errors and cannot be recommended for use (Appendix 2).
For further consideration of the issue, we need some additional information.
8.16.1. Associated memory types
A unit of memory is understood as an area of  computer memory, allocated for certain data. The size of such a unit depends on type and type parameter. So, a
memory unit for a scalar like
REAL (4) is 4 bytes and a scalar of type COMPLEX (8) takes two units memory of 8 bytes each.
A memory unit can be:
numeric;
text;
unspecified.
numeric memory unit is allocated for a non-reference scalar (i.e.
scalar without POINTER attribute) standard real, integer, or logical type.
A text unit of memory is occupied by a non-reference scalar of the standard a character type of unit length.
For objects of derived type, memory association is applicable only if they have the SEQUENCE attribute. If in the type definition other derived types are used,
they must also have
the SEQUENCE attribute. In this case, objects of the derived type can can be used in COMMON, EQUIVALENCE statements and as procedure parameters.
With a derived type that has the SEQUENCE attribute and does not have reference components at any level, associated:
numeric memory , if the final components of the type refer to standard integer, real, real double precision, complex or logical type;
text memory , if the final components of the type belong to the standard character type.
An unspecified unit of memory is inherent in any other derived types with the SEQUENCE attribute, as well as objects with the POINTER attribute. The size of an
unspecified memory unit of such objects are unique for each type, type parameter and rank.
 nonreferenced array of built-in type or derived type with an attributeSEQUENCE occupies a series of consecutive chunks of memory , one per each
element of the array in the order they appear in the array. Unreferenced a scalar of a derived type with the SEQUENCE attribute that has n finite 260
261
8. Program units
components, occupies n memory chunks , one for each final the component in the order in which it is declared in the derived type.
A sequence of segments and memory units forms a combined piece of memory .
For correct data exchange, objects should be associated with units of memory of the same type.
8.16.2. COMMON operator
The COMMON operator creates a shared memory area - global chunk of memory available in various program units.
COMMON [/ [ cname ] /] list of names [[,] / [ cname ] / list of names ] ...
cname - the general name of the block ( common all -block), which owns
objects of the corresponding list of names . The name can be omitted. Such common - the block is called unnamed . If the first set in
with the COMMON operator, the common block is unnamed, then slashes can be omitted, for example: common a, r, g (40)
The common- block name is global and must be different from any other global name (program unit, other com-
mon- block), but can be the same as the name of the local object, except named constant.
list of names - a list of included in the named or unnamed
common namespace for simple variables, strings, records, arrays and array declarations. When declared in a common -block of an array, the dimensions its
boundaries are set as integer constants or constant expressions. Common block objects can have POINTER and
TARGET. The names in the list are separated by commas. Every name in a program unit can appear in the list of names only once and not may appear in another
list of names of this program unit.
The names of formal parameters cannot appear in the list of names , procedures, entry points, result variable function, allocatable arrays and automatic objects,
named constants
(objects with the PARAMETER attribute). Objects of a derived type can be placed in a common block if they have the SEQUENCE attribute.

The COMMON operator is placed in the declaration section of the program units. In a program unit, you can declare several common areas defined by one or
more COMMON statements.
 The name of any common- block (including the empty name) may appear in the program module description section more than once. Wherein a list
of elements of a particular common- block is treated as
continuation of the list of elements of the previous common- block with the same name.
261
262
O. V. Barteniev. Modern FORTRAN
Example:
common x, y, / com1 / a, b, // z (15) common / com1 / c (22)
The program will be given two common- blocks: unnamed, in which will include variables x , y and an array z , and named - com 1, containing variables a , b and
array c . Of course, for this case it would be better to set common -blocks more clearly:
​ common x, y, z (15)
​ ! Unnamed common -block
common / com1 / a, b, c (22)
Variables of one common block in different program units are associated with the same piece of memory. Placement procedure in RAM of common- block
elements coincides with their order following in the COMMON statement.
The length of the shared area is equal to the number of bytes of memory required for placement of all its elements, including extensions due to EQUIVALENCE
associations (appendix 2). If several different software units refer to one named common -block, then in each of their common -block must have the same length.
Unnamed common block in different programming units can have different lengths. The length of the unnamed common- block is equal to the length of the largest
an unnamed common block that exists in the program .
Fortran maximally compacts the allocation of variables in memory computer. In this case, the variables of the common- block are allocated in memory according
to the following rules:
variables of type BYTE, INTEGER (1), LOGICAL (1) or CHARACTERplaced without space immediately after the previous variable name list . The same is true
for the variables derived type of size 1 byte;
all other simple variables and non-character arrays begin withon the next even byte closest to the previous variable;
character arrays always start at the next free byte;
elements of any array follow one after another without gaps;
all common -blocks begin with a byte whose number is a multiple four.
Comment. Programmers using memory association can improve the performance of programs by correctly allocating variables in the common block. This issue is
discussed in detail in [1].
Due to different alignment principles for character and non-character variables in the computer memory simultaneous use of symbolic variables of odd length and
non-character variables in one common unit may cause problems. So, if such a mixed common -
262
263
8. Program units
a block in another program unit corresponds to a common -block, containing only non-character variables, then no
the bytes of the shared memory area used when associating. To avoid such phenomena, do not mix in one common -block character and non-character data.
Only two can be used with common block variables attributes: ALIAS and C. Does not follow due to the above alignment issues use a common -block to access
CI structures, using instead its a type definition with the EXTERN attribute.
Elements of named common -blocks are initialized in the BLOCK DATA program unit. Variables included in the list common- block names that cannot be
initialized in a DATA statement except when the DATA statement is used in software unit BLOCK DATA. Moreover, the variable common-
A block cannot be initialized in a type declaration statement.
SAVE attribute cannot be given to a separate variable commonblock, but can be assigned to the entire block. The name of the common block is framed by
slashes, for example:
​ save / com1 /
​ ! com 1 - the name of the common block
 An unnamed common -block differs from the named one in the following properties:
after executing the RETURN or END statements in the procedure, objectsnamed common- block become undefined unless common block has no SAVE
attribute. Unnamed com- objects mon blocks always retain their values  after RETURN is executed or END;
named common -block must have the same length in all its using program units. Length of unnamed common- block can be different in different program units;
objects of an unnamed common- block cannot be initialized in the BLOCK DATA program unit.
Comment. In Fortran, all objects (except automatic) by default have the SAVE attribute. Therefore, explicitly setting this attribute a named common -block is
useful when creating portable to other software platforms.
A common block can be declared in a module. Then its description must not appear in the program unit using the module. When working with common- blocks:
all descriptions of this block should be made the same in allsoftware units using it;
263
264
O. V. Barteniev. Modern FORTRAN
• mixing in one common -block of different types of units should be avoided memory (due to alignment issues described above).
program gocom
! 
Permissible 
but 
not
recommended distinction
complex (4) z
! descriptions of a common block
in different
common / vab / z call chaco
()
! program units
print *, z
end program gocom
subroutine chaco ()
real (4) x, y
! (5.000000, -5.000000)
common / vab / x, y

! Real variables x and y instead
of
x = 5.0; y = -5.0 end
subroutine
! complex variable z
Comment. In modern Fortran, common blocks can be completely replaced by modules.
8.16.3. BLOCK DATA program unit
 If necessary, the initial values  of the elements of the named common block can be specified using the BLOCK DATA programming unit. Its general
view:
BLOCK DATA [ data block name ] classifieds section
operators DATA setting the initial values of the elements
​ & general area
END [BLOCK DATA [ data block name ]]
data block name is a global name and cannot be the same
with the local name of the data block variable and with another global name.
Several program units can be defined in a program
BLOCK DATA, which have different names and perform
initialization of elements of different named common -blocks. Moreover, in a program can only be assigned one unnamed program BLOCK DATA unit.
BLOCK DATA may appear in one program unit.
several different named common blocks. The same common a block cannot appear in different BLOCK DATA program units.
Objects with the attribute cannot be initialized to BLOCK DATA
POINTER.
In BLOCK DATA, only the following can be used operators: USE, IMPLICIT, COMMON, DATA, END, DIMENSION,
EQUIVALENCE, POINTER, TARGET, MAP, PARAMETER, RECORD,
264
265
8. Program units
SAVE, STRUCTURE, UNION - and type declaration operators .
The use of executable statements in BLOCK DATA is not allowed.
Type declaration statements present in BLOCK DATA cannot contain attributes ALLOCATABLE, EXTERNAL, INTENT, OPTIONAL, PRIVATE and
PUBLIC.
The data block name can appear in the EXTERNAL statement. it will allow to load the necessary BLOCK from the library when building the program
DATA.
Example:
block data bd2
! This block can immediately
follow
complex z common / vab / z ! by the gocom program of the
previous example
data z /(2.0, 2.0) / end block
data bd2
! Initializing the common -block
object
8.17. Recursive procedures
 Fortran supports recursive calls to external, modular and internal procedures. A procedure is called recursive if it calls itself or calls another
procedure, which, in its
turn, calls the first procedure. In the first case, the recursion is called direct , in the second - indirect .
A procedure is also recursive if it contains an EN-
TRY and refers to any procedure specified by this operator.
The declaration statement of a recursive procedure must be preceded by with the RECURSIVE prefix. Inside the recursive procedure, the interface to this
procedure is explicit.
An example . Design a subst routine that in a given line replaces all occurrences of the substring sub 1 with the substring sub 2. So, if given string 'abc1abc2abc3'
and sub 1 = 'abc' and sub 2 = 'd', then the result should be string 'd1 d2 d3'.
program stgo
character (len = 20) :: st = 'abc1abc2abc3'
call subst (st, 'abc', 'd') ​ ! subst contains forward recursion write (*, *) st              ! d1 d2 d3 end
recursive subroutine subst (st, sub1, sub2)
character (len = *) st, sub1, sub2! The length of each line is determined integer ip              ! length of the corresponding ip = index (st, sub1)              ! actual
parameter if (ip> 0) then
st = st (: ip - 1) // sub2 // st (ip + len (sub1) :)
​ call subst (st, sub1, sub2)
​ ! Recursive subroutine call
266
O. V. Barteniev. Modern FORTRAN
end if
! is executed until
end
! all replacements from sub 1 to sub
2
 265
If the function contains a direct recursion, i.e. directly calls itself, the result must be given a name other than the name functions. This is accomplished by adding to
the function header
RESULT clauses. In the case of indirect recursion, the name of the resulting variable and function name can be the same.
An example . Calculate the factorial of the number n .
program fact
integer n / 5 /, ifact
​ write (*, *) '5! = ', ifact (n)
​ ! five! = 120

end
recursive function ifact (n) result (fav)
​ integer fav ​ ! The declaration statement uses
integer, intent (in) :: n ​ ! not the name of the ifact function , but the name of the result fav if (n <= 1) then
fav = 1
else
fav = n * ifact (n - 1)
​ ! The recursion continues as long as n > 1 end if
end
The type of the result of a recursive function can also be set in its header, eg:
recursive integer function ifact (n) result (fav) or: integer recursive function ifact (n) result (fav)
A recursive procedure must necessarily contain a check, limiting the number of recursive calls.
8.18. Formal procedures
The name of an external, module procedure and built-in function can be
use as the actual parameter of the procedure. In this case the corresponding formal parameter is called a formal procedure .
Formal procedures are used in problems solved for different functions. For example, finding an extremum, a root of an equation, calculating a definite integral, etc.
In such cases, a procedure is created solving a typical problem for a wide class of functions, in which the specific function is passed as an actual parameter.
A name is considered the name of an external procedure if it has with the EXTERNAL attribute. And is treated as the name of a built-in procedure, if has the
INTRINSIC attribute. If this name is used as of the actual procedure parameter, then the corresponding formal
 266
267
8. Program units
the parameter must be the name of the formal procedure. Formal the procedure, if it is a function, must be of the same type and a kind of type as the actual
function. Formal and
the actual procedures must be consistent in number, type and rank parameters used in them.
The EXTERNAL and INTRINSIC attributes can have other uses.
In particular, it is possible to describe with the INTRINSIC attribute all used in block the visibility of built-in procedures to make them obvious application and will
avoid duplication of their names by local data objects.
8.18.1. EXTERNAL attribute
Setting the EXTERNAL attribute can be done as in a separate operator as well as in the type declaration operator. The latter is possible if we we are dealing with
a function procedure.
EXTERNAL name [, name ] ...
type-spec , EXTERNAL [, attrs ] :: name [, name ] ...
type-spec is any type declaration operator.
name is the name of the external procedure. Cannot be a control room name
functions.
External procedure names with the EXTERNAL attribute can be used as parameters of other procedures in that software
the unit in which the attribute is valid. If
the transferred procedure has a generic name, then it should be transferred specific name. Internal procedures are not allowed as parameters.
Also the EXTERNAL attribute is used when replacing the built-in functions to a user-defined function with the same name (Section 8.12.2).
If in some program unit the object name has the EX-
TERNAL and is the same as the name of a built-in procedure, then such a built-in the procedure is not available in this program unit.
You cannot set the EXTERNAL attribute of a function with a TARGET attribute.
A procedure implicitly has the EXTERNAL attribute if it is explicitly an interface is specified. In this case, explicitly setting the EXTERNAL attribute to this
procedure is not allowed. Therefore, in a program unit,
containing an interface to an external procedure, this procedure can be used as an actual parameter. Modular procedure can also be used as an actual parameter.
But
since modular procedures have an explicitly defined interface, their names are not must appear in an EXTERNAL statement.
Example. Write the search function for the root of the equation x = f ( x ) with a given accuracy eps on the segment [ a , b ] by the method of simple iterations.
Initial
 267
268
O. V. Barteniev. Modern FORTRAN
approximation x 0 = ( a + b ) / 2 . Using this function, find on the segment [0, 3] with accuracy eps = 0.0001, the roots of the equations
​ x = 2.1 / (1 arctgx
​ +
​ x + )1
​ (answer: x = 0.5435)
and
​ x = -(e
​ x -
​ e x + 3 /) 7.3
​ (Answer: x = 0.8614).
Algorithm:
°. Start.
°. Set the initial approximation x 0, taking, for example, x 0 = ( a + b ) / 2.
°. Put x = f ( x 0).
°. While | x - x 0 | > eps , execute: x 0 = x x = f ( x 0)
end of cycle 4 °.
°. Take the last value of x as a solution .
°. The end.
Let us illustrate the simple iteration method in Fig. 8.1.
y
y = x
y = f ( x )
x
​ 0
​ a
​ x0
​ b

Figure: 8.1. Simple iteration method
Convergence conditions for the method of simple iterations: | f '( x ) | <1 and f '( x ) <0. The text of the program for finding the roots of the specified functions:
real function fx1 (x)
​ ! Functions with original equations real x
fx1 = 1.0 / (1.2 * atan (x) + sqrt (x + 1.0))
end function fx1 real function fx2 (x)
real x
fx2 = (exp (-x) - sqrt (exp (x)) + 3.7) / 3.0
end function fx2
 ! The procedure for finding the root of the equation x = f ( x ) real function root (fx, a, b, eps)
real :: fx, a, b, eps, x, x0
! fx - formal procedure function
integer :: k, itmax = 100
! itmax - maximum allowable
number of iterations
268
269
8. Program units
x0 = (a + b) /2.0 x = fx (x0) k = 0
do while (abs (x - x0) .gt. eps .and. k <itmax)
k = k + 1 x0 = x x = fx (x0) end do root = x
end function root program firo
! A variant of the description section with an interface block ! real root
! interface
! Defined in the interface
block
! real function fx1 (x)
! procedures have the
attribute
! real x
! EXTERNAL and they
can be used
! end function fx1
! 
as 
parameters 
of
procedures
! real function fx2 (x)
! real x
! end function fx2
! end interface
! Option to set the EXTERNAL attribute in the description statement real, external :: fx1, fx2, root
write (*, *) 'Function root fx1:', root (fx1, 0.0, 2.0, 1.0e-4) write (*, *) 'Function root fx2:', root (fx2, 0.0, 2.0, 1.0e-4)
end program firo
Comment. Stopping criterion used | x n - x n - 1 | ≤ ε in general
1 - q
​ case is erroneous and should be replaced by
​ x n - x n - 1 ≤              ε , where q ≥ | f '( x ) |
q [7].
8.18.2. INTRINSIC Attribute
The INTRINSIC attribute means that the name that has it is the generic or specific name of a built-in procedure. Generic name an inline procedure is not allowed
as an actual parameter, her specific name should be used. So, it is unacceptable
use the generic name of the LOG function as a parameter. Instead of him, for example, when working with type REAL (4), should be described with the attribute
INTRINSIC name ALOG and then apply that specific name as procedure parameter.
 Attribute can be set as a separate operator, and in the type declaration operator. INTRINSIC list of names
type-spec , INTRINSIC [, attrs ] :: list of names
269
270
O. V. Barteniev. Modern FORTRAN
with a list of names - one or more names of built-in procedures (in case
multiple names are separated by commas). Name cannot be at the same have INTRINSIC and EXTERNAL attributes. INTRINSIC attribute cannot have user-
defined procedure names.
Any inline can be declared with the INTRINSIC attribute. procedure, however, as an actual procedure parameter, you can use only specific names given in table.
8.3 functions. Table 8.3 the following symbols are used:
​ Real ​ for REAL (4) and REAL (8);
​ Cmp ​ for COMPLEX (4) and COMPLEX (8);
Cmp (4) for COMPLEX (4); Cmp (8) for COMPLEX (8).
The column "Types of functions" indicates the types that the function has when it is used as the actual parameter of the procedure. This information is relevant when
specific and generic function names match. If a generic name is used in an expression, then the type of the function is determined by the type of its parameters.
Table 8.3. Specific names that are allowed as
actual parameters
Function description Call form with
generic name
Specific cic
names
Types
arguments
Types
functions
The absolute value of
a , multiplied by the
sign b
SIGN ( a , b )
ISIGN
SIGN
DSIGN
Integer
Real
Real (8)
Integer (4)
Real (4)
Real (8)
MAX ( x - y , 0)
DIM ( x , y )
IDIM
DIM
DDIM
Integer
Real
Real (8)
Integer (4)
Real (4)
Real (8)

x * y
DPROD ( x , y
)
DPROD
Real
Real (8)
Truncation
AINT ( a
)
Aint
DINT
Real
Real (8)
Real (4)
Real (8)
Nearest whole
ANINT (
a )
ANINT
DNINT
Real
Real (8)
Real (4)
Real (8)
Closest type number
INTEGER
NINT ( a
)
NINT
IDNINT
Real
Real (8)
Integer (4)
Integer (4)
Absolute value
ABS ( a )
270
IABS
ABS
DABS
CABS
CDABS
Integer
Real
Real (8)
Cmp (4)
Cmp (8)
Integer (4)
Real (4)
Real (8)
Real (4)
Real (8)
 271
8. Program units
Remainder mod p
MOD ( a ,
p )
MOD
AMOD
DMOD
Integer
Real
Real (8)
Integer
(4)
Real (4)
Real (8)
Imaginary part
AIMAG (
z )
AIMAG
IMAG
DIMAG
Cmp
Cmp (4)
Cmp (8)
Real (4)
Real (4)
Real (8)
Complex 
conjugation
CONJG ( z )
CONJG
DCONJG
Cmp (4)
Cmp (8)
Cmp (4)
Cmp (8)
Square root
SQRT ( x
)
SQRT
DSQRT
CSQRT
CDSQRT
Real
Real (8)
Cmp (4)
Cmp (8)
Real (4)
Real (8)
Cmp (4)
Cmp (8)
Exhibitor
EXP ( x )
EXP
DEXP
CEXP
CDEXP
Real
Real (8)
Cmp (4)
Cmp (8)
Real (4)
Real (8)
Cmp (4)
Cmp (8)
Natural 
logarithm 
of
LOG ( x )
ALOG
DLOG
CLOG
CDLOG
Real
Real (8)
Cmp (4)
Cmp (8)
Real (4)
Real (8)
Cmp (4)
Cmp (8)
Decimal logarithm
LOG10 (
x )
ALOG10
DLOG10
Real
Real (8)
Real (4)
Real (8)
Sinus
SIN ( x )
SIN
DSIN
CSIN
Real
Real (8)
Cmp (4)
Real (4)
Real (8)
Cmp (4)
Sine (argument in deg.) SIND ( x )
SIND
DSIND
Real, Cmp
Real (8)
Real (4)
Real (8)
Cosine
COS ( x )
COS
DCOS
CCOS
CDCOS
Real
Real (8)
Cmp (4)
Cmp (8)
Real (4)
Real (8)
Cmp (4)
Cmp (8)
Cosine 
(argument 
in
deg.)
COSD ( x
)
COSD
DCOSD
Real, Cmp
Real (8)
Real (4)
Real (8)
Tangent
TAN ( x )
TAN
DTAN
Real
Real (8)
Real (4)
Real (8)
Tangent (argument in
deg.)
TAND ( x
)
TAND
DTAND
Real
Real (8)
Real (4)
Real (8)
Cotangent
COTAN (
x )
COTAN
DCOTAN
Real
Real (8)
Real (4)
Real (8)
Arcsine
ASIN ( x )
271
ASIN
DASIN
Real
Real (8)
Real (4)
Real (8)
272
O. V. Barteniev. Modern FORTRAN
Arcsine (result in deg.) ASIND ( x )
ASIND
DASIND
Arccosine
ACOS ( x )
ACOS
DACOS
Arccosine (result in
deg.)
ACOSD ( x )
ACOSD
DACOSD
Arctangent
ATAN ( x )
ATAN

DATAN
Arc tangent (result in
deg.)
ATAND ( x )
ATAND
DATAND
Arc tangent ( y / x )
ATAN2 ( y , x ) ATAN2
DATAN2
Arc tangent ( y / x )
(result in deg.)
ATAN2D ( y , x
)
ATAN2D
DATAN2D
Hyperbolic sine SINH
( x )
SINH
DSINH
Hyperbolic 
cosine
COSH ( x )
COSH
DCOSH
Hyperbolic 
tangent
TANH ( x )
TANH
DTANH
Text length
LEN ( string )
LEN
Starting position
INDEX ( s ,
sub )
INDEX
Real
Real (8)
Real
(4)
Real
(8)
Real
Real (8)
Real
(4)
Real
(8)
Real
Real (8)
Real
(4)
Real
(8)
Real
Real (8)
Real
(4)
Real
(8)
Real
Real (8)
Real
(4)
Real
(8)
Real
Real (8)
Real
(4)
Real
(8)
Real
Real (8)
Real
(4)
Real
(8)
Real
Real (8)
Real
(4)
Real
(8)
Real
Real (8)
Real
(4)
Real
(8)
Real
Real (8)
Real
(4)
Real
(8)
Character Integer (4)
"
​ "
As parameters, even after declaring them with the INTRIN attribute-
 SIC, generic built-in procedure names cannot be used, but also the specific names given in table. 8.4 built-in procedures.
Function description
Call form with generic name Specific what names
Types arguments
Types functions
Converting to integer a type
INT ( a )
INT
IFIX
IDINT
Real, Cmp
Real (4)
Real (8)
Integer
Integer (4)
Integer
Converting to real type
REAL ( a )
REAL
Float
Integer
Integer
Real
Real

SNGL
DREAL
Real (8)
Cmp (8)
Real
Real (8)
Imaginary part
AIMAG ( z )
IMAG
Cmp (4)
Real (4)
Integer
Integer
Table 8.4. Specific names not allowed as actual parameters

​ MAX ( a 1, a 2, ...)
​ MAX ( a 1, a 2, ...) MAX0
272
273
8. Program units
​ AMAX1
​ Real ​ Real
​ DMAX1
​ Real (8)
​ Real (8)
​ AMAX0
​ Integer
​ Real
​ MAX1
​ Real ​ Integer
​ MIN ( a 1, a 2, ...)
​ MIN ( a 1, a 2, ...) MIN0              Integer              Integer
​ AMIN1
​ Real ​ Real
​ DMIN1
​ Real (8)
​ Real (8)
​ AMIN0
​ Integer
​ Real
​ MIN1​ Real ​ Integer
An example . Build graphs of functions sin x and cos x on the segment [-π, π].
To work in graphical mode, you need to create a project as QuickWin or Standard Graphics application. To access procedures the graphics library is referenced
to the MSFLIB module.
In graphics mode, the physical coordinate system of the viewport starts at its top left corner. Use
 the windowed coordinate system by placing the origin of the coordinate system at center of the window. The windowed coordinate system allows
graphical construction, operating in real coordinates. Output window dimensions along the x and y axes, set equal to half of the corresponding dimensions video
windows. To determine the latter, we will use the GETWINDOWCONFIG. Purpose of the used graphic procedures can be understood from the comment
placed in the program text. Them a detailed description is given in [1].
use msflib
intrinsic dsin, dcos
​ ! We use specific logical res              ! built-in function names
integer (2) status2, XE, YE
​ ! XE, YE - screen dimensions in pixels real (8) dx              ! We use double precision
logical (2) finv /.true./
​ ! Y- axis is directed from bottom to top real (8), parameter :: pi = 3.14159265 type (windowconfig) wc
! Automatic window configuration
data wc.numxpixels, wc.numypixels, wc.numtextcols, & wc.numtextrows, wc.numcolors, wc.fontsize / 6 * -1 /
wc.title = "Inline Functions as Procedure Parameters" C res = setwindowconfig (wc)
res = getwindowconfig (wc) ! Reading video window parameters
XE = wc.numxpixels
! numxpixels - the number of pixels
along the x- axis
YE = wc.numypixels
! numypixels - the number of pixels
along the y- axis
call axis ()
! Draw coordinate axes
! Set the viewport to XE / 2 * YE / 2 in the center of the video window
call setviewport (XE / 4_2, YE / 4_2, 3_2 * XE / 4_2, 3_2 * YE / 4_2)
! Window Coordinate System (OCS) status2 = setwindow (finv, -pi, -1.0_8, pi, 1.0_8)
274
O. V. Barteniev. Modern FORTRAN
dx = pi / dble (XE / 2)
! X- axis step
call curve (dsin, dx, 10_2)
! Paint the sin x light green
call curve (dcos, dx, 14_2)
contains
! Paint cos x in yellow
subroutine axis ()
type (xycoord) xy
! Draw coordinate axes
status2 = setcolor (15_2)
! Coordinate axes - in
white
 273
call moveto (int2 (XE / 4 - 10), int2 (YE / 2), xy) status2 = lineto (3_2 * XE / 4_2 + 10_2, YE / 2_2)! X axis call moveto (int2 (XE / 2), int2 (YE / 4 - 10), xy)
status2 = lineto (XE / 2_2, 3_2 * YE / 4_2 + 10_2)! Y- axis
end subroutine axis
subroutine curve (fx, dx, color)! Function graph y = fx ( x )
real (8) fx, dx, x, y integer (2)
color
! fx - formal function
status2 = setcolor (color)
! Function plot with
color
do x = -pi, pi, dx
! Changing x in USC
y = fx (x)
! Y value in USC
status2 = setpixel_w (x, y)
end do end subroutine curve
! Plot Point Plot
end
! The result is shown
in Fig. 8.2
Figure: 8.2. Graphs of functions sin x and cos x
8.19. RETURN statement exiting procedure
The procedure is exited as a result of executing
an END statement or a RETURN statement.
An example . Make a function to find the first negative number in an array.
real b (20) /1.1, 1.2, -1.3, 1.4, 16 * 0.0 /, bneg, fineg

bneg = fineg (b, 20)
​ ! Fineg function returns 0 if if (bneg .eq. 0) then              ! there are no negative numbers in the array write (*, *) 'There are no negative
numbers in the array'
else write (*, *) 'First negative number', bneg
end if end
275
function fineg (b, n)
integer i, n real fineg, b (n)
8. Program units
fineg = 0 do i = 1, n
fineg = b (i)
! Return 0 if there are no
negative numbers
if (fineg .lt. 0) return end do end
! Exiting fineg function
In subroutines, the RETURN statement can also be: RETURN tag number
tag number - asterisk number in the list of formal parameters
​ subroutines.
​ Such ​ return              of              subroutines
called
 274
alternative and provides in the calling program unit transfer of control to the operator whose label is the actual parameter and corresponds to a formal parameter -
an asterisk, number which is specified in the RETURN statement.
An example of an alternative return:
integer a (5) / -1, 2, 3, 4, 5 /, n / 5 /
call alre (a, n, * 10, * 20)
​ ! Required before the label * write (*, *) '= 0'              ! On this dataset go to 40              ! will jump to label 20
10 write (*, *) '<0'
go to 40
20 write (*, *) '> 0'
40 end
subroutine alre (a, n, *, *)
integer a (n), sv sv = sum (a)
if (sv .eq. 0) return
! Normal return
if (sv .lt. 0) return 1
! Transfer of control to
label 10
return 2 end
! sv > 0; transfer of control
to label 20
Comment. Alternative return programs have poor structure. You can opt out of an alternative return IF and SELECT CASE constructs.
8.20. Additional input ENTRY operator into the procedure
 RETURN statement allows multiple exit points from the procedure. Along with this, Fortran can organize and 275
276
O. V. Barteniev. Modern FORTRAN
additional entry points to an external or modular procedure. For this uses the ENTRY statement.
​ ENTRY ename [([ list of formal parameters ])]              &
[RESULT ( result name )]
Each entry point defines a separate procedure with its own name ename called the login name . Formal procedure parameters
are defined by the list of formal parameters of the ENTRY operator. Name entry point is global and should not be the same as another a global name. It also
shouldn't be the same as local the names of the procedure in which this entry point exists.
The RESULT clause has the same meaning as in the FUNCTION. The result name cannot be the same as ename . Calling a subroutine using an additional input:
CALL ename [([ list of actual parameters ])] Accessing a function using an auxiliary input: result = ename ([ list of actual parameters ])
In the case of a function, using parentheses even if there is no actual parameters required.
With such a call, the procedure starts from the first the executable statement following the ENTRY statement.
In a subroutine, the ENTRY statement defines an additional a subroutine named ename .
Within a function, the ENTRY statement defines an additional function with the resulting variable the name of the result or ename if the RESULT clause is omitted.
Description of the resulting variable defines the characteristics of the result returned by the function. If characteristics of the result of the function defined by the
ENTRY operator, are the same as at the main entrance, then both resulting variables (even if they have different names) are the same variable. AT otherwise, they
are associated in memory and superimposed on them constraints: all resulting variables must be of the same form memory (text or numeric) must be scalars and
must not have a POINTER attribute. In the case of a text result, the resulting variables must be of the same length.
When working with the ENTRY operator, follow these rules:
inside a subroutine, the input name cannot be the same as the name formal parameter in FUNCTION, SUBROUTINE or EX-
TERNAL;
 within a function, the login name cannot appear in any of the function operators, except for the type declaration operator, as long as the login will not
be specified in the ENTRY statement; 276
277
8. Program units
if ENTRY defines a function of symbolic type, then the names of allentry points must be of character type and have the same length;
the formal parameter of the ENTRY operator cannot appear inthe statement to be executed before the ENTRY statement. but this rule does not apply to a formal
parameter if it
also present in FUNCTION, SUBROUTINE or earlier statements
hosted ENTRY statement;
the ENTRY statement can only appear in an external or modularprocedure;
the ENTRY operator cannot appear inside IF statements (between IFand END IF), SELECT CASE, WHERE, inside DO and DO WHILE loops and in the
interface block;
an entry point with the RECURSIVE prefix cannot be defined. RE-
CURSIVE in the main entrance (in FUNCTION or

SUBROUTINE) means that the procedure specified by the entry point can address yourself.
The interface to an entry-point procedure, if it is required, set in an independent body of the interface block, in whose header must be SUBROUTINE or
FUNCTION (not ENTRY).
The number of additional entries to the procedure is not limited.
An example . Subroutine vsign displays the message '> = 0' if num ≥ 0, and message '<0' if num <0.
 write (*, '(1x, a \)') 'Enter num (INTEGER):! Conclusion without promotion read (*, *) num if (num .ge. 0) then
call vsign
else call negative
end if end
subroutine vsign
write (*, *) '> = 0' return
! Main entrance
entry negative
write (*, *) '<0' return end
! The entry point is
negative
Comment. As with the alternative return, the application additional inputs degrades the structure of the program and therefore does not can be recommended for
use.
277
278
O. V. Barteniev. Modern FORTRAN
8.21. AUTOMATIC attribute
In CVF and FPS, by default, variables are mostly cases are static , that is, memory is always allocated for them and they allocated in memory statically (address of
allocation of static variable does not change during program execution). Variable called automatic if memory for this variable is allocated of necessity. The
placement of automatic variables is done in stack. Examples of automatic objects are declared in
procedure automatic arrays and strings. However, in procedure and module you can make a variable automatic by assigning the AUTO- attribute to it MATIC.
The AUTOMATIC attribute is an extension over the standard
Fortran and can be specified in a separate statement and when declaring type:
AUTOMATIC [ list of variable names ] type-spec , AUTOMATIC [, attributes ] :: list of variable names
Automatic variables cease to exist after executing RETURN or END statements. Thus, their values  at the next procedure call may differ from the ones they
received earlier.
If the AUTOMATIC statement is specified without a list of names , then all variables inside a visibility block, which can have the AUTOMATIC attribute, will be
implicitly declared automatic.
The following cannot appear in the AUTOMATIC statement:
names and objects of common -blocks;
variables with the SAVE attribute;
variables with attributes ALLOCATABLE or EXTERNAL;
formal parameters and procedure names.
A variable that is explicitly assigned the AUTOMATIC attribute cannot be initialized in a DATA statement or in a declaration statement type. Variables implicitly
made automatic and appearing in DATA statement or type declarations initialized in the statement, will receive the SAVE attribute and will be placed in static
memory.
A variable cannot appear in an AUTOMATIC statement for more than once.
Example:
call atav (2, 3) call atav (4, 5) end
subroutine atav (m, n)
​ automatic
​ ! Variables are implicitly declared automatic
278
279
8. Program units
integer :: m, n, a, b = 2
​ print *, 'b =', b
​ ! The variable b is static,
= m ​ ! so stores the resulting value b = n              ! on repeated call
​ end
​ ! Variable a is automatic
Result:
= 2b = 3
8.22. SAVE attribute
A variable existing in a procedure or module will retain its meaning, certainty status, association status (for links) and allocation status (in case of allocable arrays)
after execution
a RETURN or END statement if it has the SAVE attribute. In CVF and FPS all variables (except objects with the ALLOCATABLE or POINTER attribute and
automatic objects) have this attribute by default. therefore variable declaration with SAVE attribute is performed to create programs that are portable to other
platforms or if procedure or module variables implicitly got an attribute
 AUTOMATIC. The SAVE attribute is specified by a separate operator or by type declaration:
SAVE [[::] list of objects ] type-spec , SAVE [, attributes ] :: object list
The list of objects can include the names of variables and common -blocks. The latter are framed with slashes when asked. The same object cannot appear twice
in a SAVE statement.
If the SAVE operator is specified without a list of objects , then all objects program items that can have a SAVE attribute receive this attribute.
Setting the SAVE attribute in the main program has no actions. If a common block is specified in the main program, then it and, therefore, all of its variables have
the SAVE attribute. If common the block is specified only in procedures, then it must be saved in each the procedure using it.
SAVE attribute cannot be set:
variables placed in the common block;
formal parameters of procedures;
the names of procedures and the resulting variable of the function;

automatic arrays and strings (Section 4.8.3);
objects that have been explicitly assigned the AUTOMATIC attribute.
Example:
279
280
O. V. Barteniev. Modern FORTRAN
subroutine shosa ()
real da, a, dum common / bz / da, a, dum (10) real (8), save :: x, y save / bz /
8.23. STATIC attribute
Variables Attributed STATIC (in a Procedure or Module) persist in (static) memory throughout the execution time programs. The attribute is an extension over the
Fortran standard and
equivalent to the previously shown SAVE attribute and the STATIC language attribute
SI. Static variable values  persist after execution
RETURN or END statements. Recall that in CVF and FPS by default variables (except dynamic ones) are located in static memory. For changes to the default
rules use the ALLOCATABLE attributes,
AUTOMATIC and POINTER. The STATIC attribute can be specified in two forms:
STATIC [[::] list of objects ] type-spec , STATIC [, attributes ] :: object list
 The list of objects can include the names of variables and common -blocks.
The names of the latter when they are included in the list of objects of the STATIC statement framed by slashes.
Example:
integer :: ng = -1
do while (ng / = 0)
​ ! The cycle ends at ng = 0 call sub1 (ng, ng + ng) print *, 'Enter integer non zero value to continue or zero to quit' read *, ng
end do contains
subroutine sub1 (iold, inew)
integer, intent (inout) :: iold
integer, static :: n2 integer,
automatic :: n3 integer, intent
(in) :: inew if (iold == -1)
then
n2 = iold
! On each call n 2 = -1
n3 = iold
! The value of n 3 is determined only
when ng = -1
end if
print *, 'new:', inew, 'n2:', n2, 'n3:', n3
end subroutine end
280
281
8. Program units
8.24. VOLATILE attribute
The attribute can only be specified in CVF and is an extension over
Fortran standard. The attribute tells the compiler that the value object is unpredictable. An object with the VOLATILE attribute is not will be optimized during the
compilation process. Like others, the attribute can be given in two forms: VOLATILE list of objects
type-spec , VOLATILE [, attributes ] :: object list
The list of objects can include the names of variables and common -blocks.
The names of the latter when included in the list of objects of the operator VOLATILE are framed with slashes.
 A variable or common -block must be declared VOLATILE if the way they are defined is not obvious to the compiler. For example, if the operating
system allocates the variable in shared memory, so so that it can be used by another program, which can include and change the value of the variable, or in case of
memory association through the EQUIVALENCE statement.
If a composite object (array, derived type) is declared VOLATILE, then each of its elements gets this attribute. Similarly, if common -block is declared
VOLATILE, then each block has this attribute element.
VOLATILE attribute cannot be set to procedure, result functions and namelist -group.
Example:
logical (kind = 1) ipi (4) integer (kind = 4) a, b, c, d, e, ilook integer (kind = 4) p1, p2, p3, p4 common / blk1 / a, b, c volatile / blk1 /, d, e equivalence (ilook, ipi)
equivalence (a, p1) equivalence (p1, p4)
Named common -block blk 1, variables d and e are declared VOLATILE explicitly. Behavior of variables p 1 and p 4 as a result of their association memory
(direct and indirect) with volatile -variable a depends on a .
8.25. Clean procedures
Clean procedures are procedures that have no side effects.
The following program demonstrates an example of a side effect: program side_effect
real (4) :: dist, d, p = 3.0, q = 4.0, r = 5.0
282
O. V. Barteniev. Modern FORTRAN d = max (dist (p, q), dist (q, r))
print *, d
end program side_effect function dist (p, q)
real (4) :: dist, p, q dist = sqrt (p * p + q * q)
! 7.071068
q = dist end function dist
! Changing q is a side
effect
 281

Its essence is that the dist function overrides the value of the q parameter . This means that the second call to the dist function when calculating d , is executed with
q equal to 5.0 instead of the expected initial values q = 4.0. Such effects are prohibited by the standard and must tracked and eliminated by the programmer.
The message that the procedure is clean is provided the PURE keyword used in the procedure header:
​ [ type-spec ] PURE SUBROUTINE | FUNCTION name              &
[RESULT ( resultname )]
or
​ PURE [ type-spec ] SUBROUTINE | FUNCTION name              &
[RESULT ( resultname )]
type-spec - the type of the resulting variable of the function.
name is the name of the procedure.
resultname is the name of the resulting variable of the function.
A clean procedure is characterized by:
the function returns a value and does not change any of its parameters;
the subroutine changes only those parameters that have the link typeINTENT (OUT) and INTENT (INOUT).
By default, the clean ones are:
all built-in functions and built-in MVBITS subroutine;
library procedures of high-speed Fortran used for
parallel computing under Unix.
In pure procedures, all formal parameters, except for formal ones procedures and links must have the form of a link:
for functions - only INTENT (IN);
for subroutines - any: INTENT (IN, or OUT, or INOUT).
No local variables of a pure procedure, including related to internal procedures should not:
have the SAVE attribute;
be initialized in declaration or DATA statements.
 In pure procedures, there are restrictions on use: 282
283
8. Program units
global variables;
formal parameters with communication type INTENT (IN) or withan undeclared type of communication;
objects associated with memory with any globalvariables.
The restrictions are as follows: the listed objects should not be used:
1) in cases where it is possible to change their value. It may happen if the variable is:
the left side of the assignment or link attachment operator (ifthe object is a link);
the actual parameter associated with the formal parameterwith the communication type INTENT (OUT or INOUT) or with the attribute POINTER;
index variable of DO, FORALL or embedded DO-cycle;
variable of the ASSIGN operator;
element of the input list of the READ statement;
the name of the internal file of the WRITE statement;
object of statements ALLOCATE, DEALLOCATE or NULLIFY;
the IOSTAT or SIZE specifier of the I / O or STAT statements
ALLOCATE and DEALLOCATE statements;
2) in creating a link, for example, as a recipient or as element of the right side of the variable assignment operator derived type if it has a referenced component on
any of its levels.
Clean procedures should not contain:
I / O operators to external files or devices;
operators PAUSE and STOP.
Pure procedures are meant to be called when the call other procedures that do not own the PURE keyword are not allowed:
in the FORALL operator or its mask expression;
from another clean procedure.
Also, only a pure procedure can be used as parameter to another clean procedure.
If a pure procedure is used in the above situations, then its the interface must be set explicitly and it must be declared in it with the PURE keyword. Recall that all
built-in procedures are clean and have an explicit interface by default.
Example:
pure function decr (k, m)
real (4) :: decr
284
O. V. Barteniev. Modern FORTRAN
integer (4), intent ( in ) :: k, m
! Formal parameters of a pure function
decr = real (m) / real (k) end function decr
! must have the link type INTENT
(IN)
 283
program pudem
real (4), dimension (5, 5) :: array = 5.0 interface
​ pure function decr (k, m)
​ ! Since the function is used in FORALL,
real (4) :: decr
​ ! then you need to set its interface integer (4), intent (in ) :: k, m
end function decr
end interface
forall (i = 1: 5, j = 1: 5) array (i, j) = decr (i, j)
print '(10f5.1)', array (1, :)
​ ! 1.0 2.0 3.0 4.0 5.0 end program pudem

Comment. Clean procedures introduced by the 1995 standard.
8.26. Elemental procedures
Element user procedures are like inline procedures elemental procedures can have as actual parameters either scalars or arrays. In the latter case, the arrays
should be agreed, that is, have the same shape; the result of the procedure is elementwise processing of arrays - actual parameters.
Here is an example of executing the built-in element function MOD, returning the remainder of the division of the first parameter by the second:
integer (4), dimension (5) :: a = (/ 1, 2, 3, 4, 5 /), b = (/ 1, 2, -2, 4, 3 /), c integer (4) :: d
c = mod (a, b)
! Function parameters
- arrays
print *, c
! 0 0 1 0 2
d = mod (b (4), a (3))
! Function parameters
- scalars
print *, d
! 1
A program unit calling an element function must contain its interface in which the word ELEMENTAL is explicitly specified. The purpose of introducing element
functions is to simplify parallelization computations on multiprocessor machines: a compiler that has information that the function is elemental, performs
parallelization by the rules laid down in it.
 Element functions are pure functions that only have scalar formal parameters that are not references or procedures. View parameter links - INTENT
(IN). The resulting variable element functions are also scalar and cannot be referenced. Elemental the function is supplied with the ELEMENTAL keyword, which
automatically implies the PURE keyword. Elemental functions cannot be equipped with the RECURSIVE keyword. 284
285
8. Program units
If the actual parameters of the element function are arrays, they must be consistent; the result of such a function is the array matched to the parameter arrays.
Example :
elemental integer (4) function find_c (a, b)
integer (4), intent (in) :: a, b ​ ! Do not forget to set the communication type INTENT (IN) if (a> b) then
find_c = a
else if (b <0) then
find_c = abs (b)
else find_c = 0
end if
end function find_c
program etest
interface
​ ! Interface required elemental integer (4) function find_c (a, b)
integer (4), intent (in) :: a, b! Mandatory setting of the communication type INTENT (IN)
end function find_c
end interface
 integer (4), dimension (5) :: a = (/ -1, 2, -3, 4, 5 /), b = (/ 1, 2, -2, 4, 3 /), c integer (4) :: d = 5
c = find_c (a, b)
! Function parameters
- arrays
print *, c
! 0 0 2 0 5
d = find_c (-1, 1)
! Function parameters
- scalars
print *, d end program etest
! 0
Comment. Since element functions are pure, they can be used in the FORALL statement and construct.
Element routines are defined like element functions.
In the body of the procedure, parameters with the communication type OUT and INOUT can be changed.
Example:
elemental subroutine find_c (a, b, c)
integer (4), intent (in) :: a, b integer (4), intent (out) :: c if (a> b) then
c = a
else if (b <0) then
c = abs (b)
else
c = 0
285
286
O. V. Barteniev. Modern FORTRAN
end if
end subroutine find_c program etest2
interface
elemental subroutine find_c (a, b, c)
integer (4), intent (in) :: a, b integer (4), intent (out) :: c
end subroutine
end interface integer (4), dimension (5) :: a = (/ -1, 2, -3, 4, 5 /), b = (/ 1, 2, -2, 4, 3 /), c integer (4) :: d = 5
286
287
8. Program units
call find_c (a, b, c)
! Parameters and Result
- Arrays
print *, c
! 0 0 2 0 5

call find_c (-1, 1, d)
! Parameters and result
are scalars
print *, d end program etest2 ! 0
Comment. Elemental procedures were introduced by the 1995 standard.
8.27. Operator functions
If some expression occurs in a program unit repeatedly, then it can be formatted as an operator function and replaced all occurrences of the expression for this
function. Operator functions are specified So:
function name ([ list of formal parameters ]) = expression
If the formal parameter list contains more than one name, then the names are separated by commas.
Like an inline or external function, an operator function called in an expression. Operator function scope
 is the program unit in which this function is defined. At the same time operator function may be available in other software units due to association
through a carrier or use- association, but cannot be associated via procedure parameters. A type
operator function should be declared explicitly, placing its name in the operator type declarations or in the IMPLICIT statement.
An example . Tabulate the function z = sin y * e - x .
real (8) :: x = -1.0_8, y, z
​ ! We use double precision real (8) :: dx = 0.4_8, dy = 0.3_8 z (x, y) = exp (-x) * sin (y)              ! Setting the operator function z
( x , y ) write (*, '(6h x / y, 20f8.2)') (y, y = -0.6, 0.6, 0.3) do while (x <= 1.0_8)
write (*, '(f6.2 \)') x y =
-0.60_8 do while (y <=
0.6_8)
! Outputting x without
a newline
write (*, '(f8.2 \)') z (x, y) y =
y + dy
end do x = x + dx
! 
Print 
z 
without
newline
write (*, *)
end do end
! New line break
Comment. To output without advancing to a new line, use backslash conversion (\).
287
288
O. V. Barteniev. Modern FORTRAN
8.28. INCLUDE string
In large programs, it is advisable to store the source code in different files. This makes it easier to work on program fragments and on the program as a whole.
Including the source code of one file in the code another can be done with the $ INCLUDE directive or the line INCLUDE, which looks like: INCLUDE '
filename '
filename - name enclosed in apostrophes or double quotes
a text file with the source code of a Fortran program fragment. When If necessary, the file name must contain the path to the file.
The INCLUDE string is not a Fortran statement. She inserts the contents of the text file to the location of the program unit where it is located. This replaces the
INCLUDE line with the inserted text. The compiler considers the contents of the inserted file as part the source program and compiles this part immediately after it
inserts. After compiling the inserted file, the compiler continues compiling the original program unit starting at the statement immediately following the INCLUDE
line.
 The included file may contain other INCLUDE lines, but must not directly or indirectly refer to itself. Such included files are called nested . The
compiler allows you to create nested include files containing up to 10 levels of nesting with any set of INCLUDE lines.
The first line of the included file must not be a line continuation, and its last line must not contain a hyphen. Before the label cannot be set by the operator.
Fortran treats include files as redundant language and can be almost completely and with great effect replaced by modules. Modules not only provide access to
declaration and description operators located in the module and modular procedures placed after the CONTAINS statement, but also allow performing (through
use- association) data exchange between program units using modules.
8.29. Order of operators and directives
Operators and directives in program units must appear in the table. 8.5 ok.
288
Table 8.5. Sequence of statements and directives
$ INTEGER, $ REAL, $ [NO] SRICT, $ OPTIMIZE
$ ATTRIBUTES
BLOCK DATA, FUNCTION, MODULE, PROGRAM, SUBROUTINE
$ [NO] DEBUG
USE operators
$ [NO] DECLARE
IMPLICIT NONE
PARAMETER
$ DEFINE, $ UNDEFINE
IMPLICIT
$ IF, $ IF DEFINED
Derived Type Definitions
$ ELSE, $ ELSEIF, $ END IF
Interface blocks
$ FIXFORMLINESIZE
Type declaration operators
PARAMETER
ENTRY
$ [NO] FREEFORM
Declaration Operators
DATA
FORMAT
$ INCLUDE, $ LINE
Operator functions
$ LINESIZE, $ [NO] LIST
Executable Operators
DATA
$ MESSAGE
CONTAINS
$ OBJCOMMENT, $ PACK
Internal and modular procedures
$ , $ SIZE
END
$ SUBTITLE, $ TITLE
Table 8.6 for different software components, operators are indicated, which may appear in them. The line "Announcements" implies
PARAMETER, IMPLICIT statements, data type declarations and their
attributes.
Table 8.6. Operators of software components

Operators
home program
Module
BLOCK
DATA
External procedure
Modular procedure
Internal procedure
Body
interface
USE
Yes
Yes
Yes
Yes
Yes
Yes
Yes
ENTRY
No
No
No
Yes
Yes
No
No
FORMAT
Yes
No
No
Yes
Yes
Yes
No
ads
Yes
Yes
Yes
Yes
Yes
Yes
Yes
DATA
Definitions derivatives
Yes
Yes
Yes
Yes
Yes
Yes
No
types
Interface
Yes
Yes
Yes
Yes
Yes
Yes
Yes
blocks
Operator
Yes
Yes
No
Yes
Yes
Yes
Yes
functions
Executable
Yes
No
No
Yes
Yes
Yes
No
operators
Yes
No
No
Yes
Yes
Yes
No
CONTAINS
Yes
Yes
No
Yes
Yes
No
No
 289
Program units

289
 290
Formatted input / output
The data in the computer memory is stored in binary form, representing sequence of zeros and ones. With presentation features different types of data in a
computer can be found, for example, in [5]. Integer and Real Data Models Used in Fortran considered in Sec. 6.11.1.
Inputs and outputs often need to be presented differently different from the internal representation. Then the problem arises converting data from input to machine
form (internal) representation and, conversely, from machine representation to external, for example text or graphic.
Fortran standard tools support 4 kinds of I / O data:
formatted;
under the control of the I / O list;• unformatted;
binary.
The first two are for converting text information into the internal representation when entering and, conversely, from internal representation to text on output.
Executable formatted I / O conversions are specified by a list of descriptors transformations. List driven I / O is essentially a kind of format I / O: conversions are
performed by built-in Fortran rules according to types and values
I / O list items. The data transfer control list can be named or unnamed.
In this chapter, we will only consider the first two types of transmission data: formatted and list driven. Unformatted and binary I / O are discussed in Ch. ten.
9.1. Data transformation. FORMAT operator
The translation of data from internal to text representation is set descriptors of transformations (DP). So, to output the real numbers on a field of 8 characters in
length, in which 3 characters are reserved for representation              fractional              parts,              used by              handle F8.3.
The maximum value that can be displayed on a given field is is 9999.999 and the minimum is -999.999. To transform internal integer -to-text representation of 10
characters is applied descriptor I10. To print a character variable in a field of length 25 characters, A25 conversion applies.
 290
291
9. Formatted input / output
Conversion descriptors are contained in the format specification, eg:
real :: a = -345.456 integer :: k = 32789
character (20) :: st = 'Output Line'
write (*, '(1x, f8.3)') a
​ ! -345.456 write (*, '(1x, i10)') k              ! 32789 write (*, '(1x, a25)') st              ! Output line
Comment. The symbol is used to denote a space.
The format specification includes a parenthesized list of DPs. BOM can be set as built into I / O operator a character string, for example:
'(F8.3, I10)' or as a separate FORMAT statement to which the I / O statements are referenced using a label. General view of the operator:
FORMAT label ( list of DPs)
DPs are separated in the DP list by commas. For instance:
write (*, '(1x, f8.3, i10)') a, k ! -345.456
32789
write (*, 1) a, k
1 format (1x, f8.3, i10)
! -345.456
32789
Each of these format specifications contains a 1X DP.
Its presence is necessary for formatted output, however, only in FPD. The fact is that in FPS with formatted output by default, the first position the output line is
intended for setting a control character print device carriage. Possible control symbols carriage are given in table. 9.1.
Table 9.1. Print device carriage control characters
Symbol
Act
Space
Start new line
+
Stay on the same line
(reprint)
0
Skip one line
1
Move to the beginning of
the next
Therefore, the first position of the line of output on the screen and printing device is not displayed.
To avoid generating false carriage control characters FPS has two tools:
 291
292
O. V. Barteniev. Modern FORTRAN
you can always insert at least onea space as the first character in each entry. This is done descriptor 1X or T2;
you can connect an external device by setting in the OPEN statementspecifier CARRIAGECONTROL = 'LIST' (Section 11.4). In this case the first character of
each entry in formatted output will not interpreted as a carriage control character and will output on an external device, for example:
​ write (*, 1) 'abcd'​ ! bcd
open (6, carriagecontrol = 'list')! by default device 6 is the monitor screen
​ write (*, 1) 'abcd'​ ! abcd
1 format (a)
In CVF the default is CARRIAGECONTROL = 'LIST', so
prepend the DP list with descriptor 1X if the default rules are not changed, no need.
Example :
write (*, '(i3)') 123
! CVF:
123
end
! FPS:
23
Comment. DS has the ability to edit the FORMAT statement.
To do this, place the cursor on the FORMAT statement, which contains at least one DP, and then run the Edit - Fortran Format Editor chain.
9.2. Format Specification Programming

The format specification is a character string. Most often the value of this string is given as a literal character constant as it was done in the examples in the previous
section. but in general, a format specification can be a character a variable whose value can change during the calculation.
An example . Program the format to display the title in the center screen. Solve the problem, assuming that the length of the heading is less than the width screen.
Let's introduce the following notation: tl - header length without trailing spaces; sl - screen width (in text mode the screen width is 80
characters). To center the title, you need to move away from the left screen borders n = ( sl - tl ) / 2 characters and then print the title. So, for tl = 60, the format
should be applied
'(11X, A)' or '(T12, A)' and for a 40 character header, the format would be
'(21X, A)' or '(T22, A)'
 292
293
9. Formatted input / output
The text of the program for generating the header output format with length tl :
program t2
character (78) :: title = 'Title Example'
character (20) form
​ ! Output format string integer (1) tl, n, sl / 80 /
​ tl = len_trim (title)
​ ! Length of the header without trailing spaces
n = (sl - tl) / 2
! Formation of the output format ( fmt strings ) with the X descriptor write (form, '(a, i2, a)') '(', n, 'x' // ',' // 'a' // ')'
! or in the case of using the T descriptor
! write (form, '(a, i2, a)') '(' // 't', n + 1, ',' // 'a' // ')'
write (*, form) title
​ ! Header output end program t2
Explanations:
The string is an internal file, when working with whichformatted I / O is used.
The T n descriptor shifts the I / O position n characters to the right.
Notes:
Specifying the format '( n X, A)' or '(T n , A)' is an error, since this case, the descriptor contains an invalid character n for the format , instead of which a literal
positive integer should be used
 unsigned constant. Further, however, we will show that such integer constants can be replaced with an integer enclosed in angle brackets expression
(Section 9.3).
In fact, when outputting to a DOS window, the title containing Russiantext will be output as an unreadable character set. To fix position, you must use the one given
in the appendix. 1 function RuDosWin, belonging to the TextTransfer module, and add to the above code the following changes:
module TextTransfer
! See appendix for the TextTransfer module code. 1
...
end module TextTransfer
program t2
use TextTransfer
character (78) :: title = 'Title Example'
! To display Russian
text
...
! Program code t 2
see above
write (*, form) trim (RuDosWin (title, .false.))
end program t2
! Header output
Further, however, as before, the link to the TextTransfer module will be go down, but always, if Russian text is displayed, it will be understood as well as the
corresponding usage of RuDosWin.
293
294
O. V. Barteniev. Modern FORTRAN
The format can also be specified as a character array, elements which, when executed, I / O are concatenated.
An example . Program the header output format using character array.
character (78) :: title = 'Title Example'
character (1) fmt (12) / '(', '1', 'x', ',', 't', 2 * '', ',', 'a', ')', 2 * '' / integer (1) n, sl / 80 / n = (sl - len_trim (title)) / 2 select case (n)
case (1: 9)
! Convert n to character
write (fmt (6), '(i1)') n
! representation and put
in fmt (6)
case (10 :)
write (fmt (6), '(i1)') n / 10
write (fmt (7), '(i1)') mod (n,
10)
endselect write (*, fmt) title
! or in fmt (6) and fmt
(7) if n > 9
String characters or array elements after the last right brackets of the string - format specifications, ignored. therefore both string and array can contain more
elements than needed to set the format.
When programming the format, remember that the specification format must be fully installed before starting execution I / O operator. During I / O statement
execution, no characters format specifications cannot be changed.
9.3. Expressions in Conversion Descriptors
If in the format string the transform descriptor uses integer constant, then it can be replaced by enclosed in angle brackets (<>) with an integer expression:
integer :: m, k k = 10 do m
= 3, 5 k = k * 10
write (*, '(2x, i <m>)') k
! 100
end do
! 1000

end
!
10000
Integer expression can be any valid expression with the following restrictions:
in the H descriptor, the constant cannot be replaced by an integerexpression;
relation operations in this expression cannot be specified ingraphically, for example, instead of the> sign, use .GT., instead of <= - .LE ..
294
295
9. Formatted input / output
An integer expression specified instead of a constant cannot appear in an assignment statement when programming a string format; so, the snippet is wrong:
integer :: m = 2, k = 5 character (80) s s = '(2x, i <k - m>)'
​ write (*, s) m + k ​ ! Error
But the operators are correct:
integer :: m = 2, k = 5
write (*, '(2x, i <k - m>)') m + k! 7
write (*, 1) m, k
​ ! 2 5 print 1, m, k​ ! 2 5
1 format (<m> x, <m> i <k - m>)! Right
Replacing the constant in the DP with an expression, you need to ensure that expression was an integer and its return value was greater scratch.
An example . Display title in the center of the screen.
character (78) :: title = 'Title Example'
integer (1) :: tl, sl = 80 ​ ! sl - screen width tl = len_trim (title)
 
​ write (*, fmt = 10) title ​ ! Header output
10 format (<(sl - tl) / 2> x, a)
9.4. Formatting in I / O Statements
With formatted I / O, the I / O statements contain a reference to the format. Such a link can be specified in four ways:
as a label pointing to the format operator:
write (*, 10) a, k
or
write (*, fmt = 10) a, k
10 format (1x, f8.3, i10)
Comment. Label, if used to reference the format can be assigned to an integer variable by the ASSIGN statement
(appendix 4), which, however, was removed from Fortran by the 1995 standard:
integer :: label, m = 55 assign 20 to label
​ print label, m
​ ! 55
20 format (1x, i5)
as a symbolic expression built into the I / O operator:
write (*, '(1x, f8.3, i10)') a, k
295
296
O. V. Barteniev. Modern FORTRAN
or
write (*, fmt = '(1x, f8.3, i10)') a, k
as a named I / O list name:
integer :: k = 100, iarray (3) = (/ 41, 42, 43 /) real :: r4 * 4 = 24.0, r8 * 8 = 28.0 namelist / mesh / k, r4, r8, iarray write (*, mesh) or write (*, nml = mesh)
as an asterisk to indicate the use of a controlledunnamed I / O list:
write (*, *) a, k write (*, fmt = *) a, k
9.5. I / O lists
 The input statement for each element of the input list finds in the outer file a data field and reads a value from it into a list item. The output statement
creates in the file one data field for each item of the output list. In case of formatted output, the field size is determined by the format applied.
9.5.1. I / O List Items
I / O list items can be complete data objects of any types (scalars and arrays) and their subobjects, such as components records, array elements, array section,
substring. Between lists
there are differences between input and output: an input list can only contain variables and their subobjects, the output list contains expressions.
Example:
type point
real x, y character (8) st
end type point type (point) p (20), pxy open (1, file = 'a.txt')
​ read (1, '(2f8.2)') pxy.x, pxy.y​ ! Possible entry lists
read (1, '(f8.2 / f8.2 / a)') p (1) .x, p (1) .y, p (1) .st
​ read (1, 20) pxy
​ ! Input list has 3 items
​ read (1, 20) (p (k), k = 1, 20) ​ ! Entry list contains 60 items
20 format (2f8.2, a)
Scalar object of built-in type present in I / O list
(except complex) creates one I / O element. Built-in array (except complex) adds all its items to the I / O list. Order
296
297
9. Formatted input / output
the sequence of array elements in the I / O list is the same as their order location in the computer memory. So, lists are equivalent:
real a (2, 3) / 1.1, 2.2, 3.3, 4.4, 5.5, 6.6 /
write (*, *) a
​ ! There are 6 items in the output list write (*, *) a (1, 1), a (2, 1), a (1, 2), a (2, 2), a (1, 3), a (2, 3)

A complex type scalar creates two I / O elements. When complex array of n elements add 2 * n to the I / O list elements. Scalar components of derived type are
listed I / O in the same order in which they appear in the operator ads of this type.
In case of formatted input, the number of those present in the external file input fields must be at least the number of items in the I / O list. The size the field
occupied by the entered value and its position in the file must be consistent with the input format. For instance:
 integer (2) k, m, a (20), b (10) complex (4) z character (30) art (15) character (30) :: fmt = '(4i4 / 10i3 / 2f8.2 / (a30))' open (1, file = 'a.txt') read
(1, fmt) k, m, a (2), a (4), b, z, art
The input list contains 31 elements: 25 of them give the arrays b and art , 2 the complex variable z and one by one the variables k , m , a (2), a (4). Therefore, at
least 31 values  must be present in the file, from which data entry is performed. The number of lines in the file cannot be less than 18, since the fmt format
specification contains slash conversion (/), which moves the file a pointer to the beginning of a new record. The position and composition of file fields can be, for
example, like this (the symbol is used to indicate a space):
111222333444
11121314151617181920 1111.112222.22 string1
...
string15
Consider the following limitations when compiling the I / O list:
a resizing array cannot appear in the I / O list,but its subobjects (elements and sections) may appear;
the array to be allocated in the I / O list must be
the time of execution the I / O is placed;
all I / O list links by the time the I / O is executed must beattached to recipients. Data transfer is performed between file and the addressee;
 297
298
O. V. Barteniev. Modern FORTRAN
each end component of an object in the I / O listderived type must not have the PRIVATE attribute;
objects of a derived type cannot be present in the I / O list,which have links among the components at any level.
The I / O list can be empty. Then the output creates a record zero length. As you type, it moves to the next record. If if the output list is empty, the format is used,
consisting only of lines, then a record containing this line will be displayed, for example:
write (*, '(1x, "I am a test string")')
9.5.2. Cyclic I / O Lists
The I / O list can also contain a cyclic list that looks like:
( list of loop objects , dovar = start , stop [, inc ]) where each loop object is a variable (in case of input), or an expression
(in case of output), or a new cyclic list; dovar is a variable loop - an integer scalar variable; start , stop , inc - scalar integers expressions. The I / O Operator
Cycle List works the same as DOparameter loop or implicit DATA statement and constructor loop array. Another name for I / O operator cyclic list is implicit I /
O operator cycle .
An example . Conclusion of a horizontal line.
print '(1x, 80a1)', ('_', k = 1, 80)! The output list has 80 items
9.5.3. Example of organizing output
Objective: Tabulate a function of two variables:
z = | x - y | e y / 3 / (1/3 + cos ( x / y ))
when x changes from 1 to 5 in 0.5 steps, and y - from 1.1 to 1.5 in 0.05 steps.
Let's format the result in the form of a table containing the title, values x
vertically and y- values horizontally. In the table cells we display corresponding to the arguments x and y values z (Fig. 9.1).
Relationship z = ABS ( x - y ) * EXP ( y / 3) / (1/3 + cos ( x / y ))
​ x \ y
​ 1.10 ​ 1.15 ​ 1.20 ​ ...
​ 1.50
​ 1.00 ​ z 1.1 ​ z 1.2 ​ z 1.3 ​ ...
​ z 1.9
​ 1.50 ​ z 2.1 ​ z 2.2 ​ z 2,3 ​ ...
​ z 2.9
...
​ 5.00 ​ z 11.1
​ z 11.2
​ z 11.3              ...              z 11.9
Figure: 9.1. Output table project (output form )
 298
299
9. Formatted input / output
It is clear that organizing such a table would require some transformations: offset position of output, formatting output values x , y and z , output character data.
To withdraw, we additionally need to know:
admissible number of characters displayed on one line (in caseconsole-project this number is 80);
range of variation of values  of the function z ;
required precision of representation z (number of decimal places).
Maximum and minimum z- values and accuracy representations z are needed to determine, first, the length of the required to output the z field and, secondly, the
way z is represented (in F- or Eform). In general, these data can be determined only in the computation process.
Let's consider in detail the mechanism of forming the output format of one table rows. Suppose that the maximum and minimum values  of z can be placed on a 7-
character field, with the two right
character, the fields will be located after the decimal point. Such a field set by transformation F7.2. Distance between output fields z set equal to one. Then, when
outputting one field, it follows use format 1X, F7.2. In total, one row of the table will contain
9 fields with z values  are placed . For their output, the format is required
9 (1X, F7.2). Now, when outputting a string of z values, we will indent from
the left border of the screen in 1 character and the subsequent output of the x value in the field
5 characters long, containing two decimal places. We get the format table row output: (2X, F5.2, 9 (1X, F7.2)).
program zxy
real :: x, y, xa = 1.0, xb = 5.0, ya = 1.1, yb = 1.51
real :: z (10)
​ ! Array of z values for a table row real :: dx = 0.5, dy = 0.05              ! X and y step
character (80) :: title = 'Dependency z = ABS (x - y) * EXP (y / 3) / (1/3 + cos (x / y))' integer (1) k, tab

tab = (80 - len_trim (title)) / 2
write (*, '(<tab> x, a)') title
​ ! Display title in the center of the screen write (*, 1) ('_', k = 1.80)              ! Horizontal line output
write (*, '(2x, a, 9f8.2)') 'x \ y', (y, y = ya, yb, dy)
write (*, 1) ('_', k = 1.80)
​ ! Draw a horizontal line again x = xa do while (x <= xb)
k = 0 y = ya
do while (y <= yb)
​ ! Forming an array of z values k = k + 1
z (k) = abs (x - y) * exp (y / 3.0) / (1.0 / 3.0 + cos (x / y)) y = y + dy
 299
300
O. V. Barteniev. Modern FORTRAN
​ end do
​ ! Outputting a table row
write (*, '(2x, f5.2, 9 (1x, f7.2))') x, z (: k) x = x + dx
end do
write (*, 1) ('_', k = 1.80)
1 format (80a1)
​ ! Horizontal line output format end program zxy
Comment. To display z valueson one line in a loop through y, you can use the '\' descriptor, non-forwarding output. In that case, you can do without the
intermediate array z (1:10).
9.6. I / O List and BOM Negotiation format. Repetition rate. Reverse format
Transformation descriptors (DP) are subdivided into:
on data descriptors (DD);
on control descriptors;
to character strings.
Data descriptors such as F8.2 or I6 determine size and shape
I / O fields in which textual representations of data are located. When formatted I / O each element of the I / O list corresponds to a descriptor data. I / O and DD
list items must be consistent in type.
So, you cannot transfer a real number using the I w.m transformation . When entering, the external representations of the data must also be consistent and DD. So,
if the input field contains characters and input from this an integer field, an input error will occur.
If there are more than one item in the I / O list, then each item selects one DD from the list of DPs. The selection rule is as follows: j -th an element of the I / O list
selects the j -th DD (let's call this selection order rule 1 ). In this case, the fields of all elements of the I / O list are located in one entry. This rule works when the
number of DDs is not less than the number items in the I / O list.
Example:
integer k, n, m (9)
read (*, '(I8, I5, I5, I5)') k, n, m (2), m (4)
The variable k will select the I8 descriptor, the rest - I5. The entrance should be
defined record with data (symbol
​ used to refer to space):
123 345 346 347
A sequence of identical DDs can be recorded by using repetition rate - a literal integer given before DD an unsigned constant or an integer in angle brackets
 300
301
9. Formatted input / output
expression. So, the format specification in the input operator of the last example can be written more compactly: read (*, '(I8, 3I5)') k, n, m (2), m (4) ! 3 -
repetition rate The repetition rate can be applied to the DP group as well.
The general view of the recording of a repeating DP group is as follows: n [(] group DP [)]
The parentheses can be omitted if the DP group includes only one
DD. The DP group can include both DD and control descriptors. Using a repetition factor in front of a control descriptor or a string is only possible if the
descriptor is enclosed in brackets. Using the repetition factor separately before control descriptors and strings are not valid.
An example of using the repetition rate for the DP group:
write (*, '(2x, F3.0, 2x, F3.0, 2x, F3.0)') a, b, c write (*, '(3 (2x, F3.0))') a, b, c
Now let's consider the situation when the number of DDs in the format specification fewer items in the I / O list. Let the number of DD be equal to m . Then the
first m elements of the I / O list will select DD according to rule 1. Next, next record (next line of text file), and subsequent m
elements of the I / O list will again select the same DDs, following rule 1, and so continue until the I / O list is exhausted. And when you enter a new record will be
taken from the file, even if not all data was entered last the transferred record. This is true if the I / O statement is not specified.
 specifier ADVANCE = 'NO', providing data transfer without promotion. Let's call this selection order rule 2 .
Example:
integer k, n, m (9) read (*, '(I8, 3I5)') k, n, m (1: 9)
There are 11 items in the input list. Variable k will select DP I8; n , m (1), m (2) - I5; m (3) - I8; m (4), m (5), m (6) - I5; m (7) - I8, m (8), m (9) - I5. In file data
must be defined at least three records, for example:
123 333 444 555 -25
777 888 999 111 222
333 444 555
As a result of input, the variables will receive the values: k - 123, n - 333, m (1) - 444, m (2) - 555, m (3) - 777, m (4) - 888, m (5) - 999, m (6) - 111, m (7) -
333, m (8) - 444, m (9) - 555.
Rule 2 works when one or more DDs are not are enclosed in parentheses.
301
302
O. V. Barteniev. Modern FORTRAN
Parentheses are used, firstly, if you need to apply the repetition factor for the DD sequence, secondly, so that set the I / O format of the I / O list items for which all
DD taking into account the repetition rates.
Example:
integer :: j, k, n, a (10), b (30)

read (*, '(2I8, 5 (I2, I3), 5 (I4, 1X, I1))') k, n, a, (b (j), j = 1.30)
The number of items in the entry list is 42. The number of DDs with repetition rates are 22. The first 22 items in the list will be
entered from the first record of the file using DD according to rule 1. After entering the first 22 elements of the format will be exhausted. For all remaining records
the last fragment enclosed in parentheses will be applied format - 5 (I4, 1X, I1). Formats 2I8 and 5 (I2, I3) are no longer used will be. Format 5 (I4, 1X, I1) will
be applied according to rule 2, so the second and third records must contain at least 10 fields data each.
General rule of using the format when available in the specification the format of the bracketed components is as follows: if the format contains enclosed in brackets
DD, then if it is exhausted, in the file
a new entry will be taken and format control will return to the left parenthesis, corresponding to the penultimate right parenthesis, or to the corresponding the
repetition rate, if any. In the given example to 5 (I4, 1X, I1). This rule is called format reversal .
9.7. Data descriptors
Let's now look at Fortran data descriptors in detail. Full the list of DD is given in table. 9.2.
Table 9.2. Data transformation descriptors
​ Descriptor ​ Argument type
​ External representation
​ I w [. m ]
​ Whole
​ Integer
​ B w [. m ]
​ "
​ Binary representation
​ O w [. m ]
​ "
​ Octal representation
​ Z w [. m ]
​ Any
​ Hexadecimal representation
​ F w.d​ Real ​ Real number in F-form
​ E w.d [E e ]​ "
​ "
​ "in E-form
​ EN w.d [E e ]
​ "
​ "
​ "              "
​ D w.d​ "
​ "
​ "double precision
​ L w
​ Logical
​ T and F, .T and .F, .TRUE. and .FALSE.
302
303
9. Formatted input / output
​ A [ w ]
​ Character
​ Character string
​ G w.d [E e ] Any
​ Depends on data type
The following symbols are used in the table:
w - the length of the field reserved for the representation of the I / O element;
m is the number of leading zeros ( m ≤ w );
d - number of digits after the decimal point ( d < w ).
Comment. Fortran 95 allows you to set the w valueto zero, for example I0 or F0.5. In this case, the field length is determined by the value displayed number. This
property applies to descriptors B, F, I, O, and Z.
If w > 0 and with formatted output, the number of resulting character conversion exceeds w , then the entire field is filled asterisks (*). For instance:
write (*, '(i0)') 123
! 123
write (*, '(i2)') 123
! **
write (*, '(f0.2)') 123.45 ! 123.45
write (*, '(f5.2)') 123.45
end
! *****
General rules for converting numeric data:
 the external representation of an I / O element is a character string;
when typing, a field consisting entirely of spaces alwaysinterpreted as zero. Otherwise the interpretation whitespace is controlled by descriptors BN and BZ;
when entering, the + sign can be omitted;
when entering with descriptors F, E, G and D, the number of digits after the decimal pointdetermined by the position of the decimal point. In its absence the value
of the parameter d ;
when displaying, characters are aligned to the right border of the field and whennecessary are added with leading spaces;
if during output the number of received as a result of transformationcharacters exceeds the length of the field w , then the entire field is filled asterisks;
if the real number contains more digits after the decimalpoints than specified by parameter d , then the rounded up to d digits after the decimal point the value of the
number;
when working with complex numbers, you must usesimultaneously two descriptors of the form F, E, G or D: the first is for real, the second - for the imaginary part
of a complex number;
control descriptors and strings may appear between DDs;
with descriptors F, E, G and D, descriptor k P can be used , where k is the scaling factor (-127 ≤ k ≤ 127). Act
303
304
O. V. Barteniev. Modern FORTRAN
scale factor k , if descriptor k P is given,
to all descriptors F, E, G and D of the list until a new descriptor appears k P;
• when reading with descriptors I, B, O, Z, F, E, G, D or L input field may contain a comma that terminates the field. Moreover, the following the field starts with a
character behind the comma. However, one cannot use commas as separators at the same time
positioning descriptors (T, TL, TR or n X) because they change the positions of characters in the record.
Let us now describe DD.
When using the I w [. m ] when entering the internal representation is converted to a sequence of spaces and numbers (with signed or unsigned) that does not
contain a decimal point or decimal exhibitors. In the output list, the WRITE and PRINT statements can only elements of integer type are present. Otherwise an
execution error occurs.
 If a positive number m is given , then the displayed integer will be padded with m - n leading zeros, where n is the number of significant digits in the
number. The parameter m has no effect on the input .
integer :: k1 = 123, k2
read (*, '(I4)') k2

! Let's enter:
-123
write (*, '(1X, I12, I12.7)') k1, k2 ! 
123
-0000123
B w [. m ], O w [. m ], Z w [. m ] - binary (B), octal (O) and hexadecimal (Z) data descriptors. Data corresponding these descriptors cannot contain a decimal
point or sign (+ and -), but contain spaces or characters of the corresponding number system:
digits 0 and 1 when using descriptor B; digits 0-7 when used descriptor O; digits 0-9 and letters A - F in case of descriptor Z.
Descriptors B and O can only be used with integer input and output data. The Z descriptor can be used
with data of any type. The encoding of numbers in B-, O- and Z-forms depends
​ from the processor (especially              negative),              so              programs,
using descriptors B, O and Z and their corresponding data forms, may not work adequately on other computers.
The w parameter sets the length of the I / O field, and m is the minimum number of output characters ( m ≤ w ). In the absence of m, the minimum number of
output characters is equal to one. If the output is less than w , then it is padded leading spaces. If the output is less than m , then it is complemented leading zeros
up to size m . Binary numbers are easier to read when available leading zeros instead of spaces.
On input, descriptors B, O, and Z convert external binaries, octal and hexadecimal data to internal representation.
304
305
9. Formatted input / output
Each byte of the internal representation corresponds to eight binary characters, three octal and two hexadecimal. For instance:
integer :: k (3) = 255
​ write (*, '(2x, b8, 1x, o3, 1x, z2)') k              ! 11111111 377 FF
Accordingly, a value of type INTEGER (4) will occupy 32 binary ones,
12 octal and 8 hexadecimal characters.
If the w parameter is omitted, then the I / O field length is set to default: 8 * n - for B format, 3 * n - for O format and 2 * n - for format
Z, where n is the value of the I / O element type variant parameter.
The order of displaying characters of elements of a character type is the same as the order of their placement in memory. Bytes of numeric and boolean types are
output in order of importance from left to right (most significant byte displayed first, that is, located to the left of the next in importance bytes).
 The Z descriptor can be applied to character data if line length does not exceed 130 characters. If the string is passed longer, only the first 130
characters will be converted.
Inference using descriptors B, O and Z follows the rules ( n is the value of the type-type parameter):
if w > 8 * n (B), 3 * n (O) or 2 * n (Z), then the characters are aligned along the right margin of the field and leading spaces are added, increasing the field to w
characters;
if w ≤ 8 * n (B), 3 * n (O) or 2 * n (Z), then w right symbols are output ;
if m > 8 * n (B), 3 * n (O) or 2 * n (Z), then the characters are aligned along the right border of the field and leading zeros are added, increasing number of
characters up to m ;
if m <8 * n (B), 3 * n (O) or 2 * n (Z), then the parameter m does not no action.
Input rules (parameter m has no effect):
if w ≥ 8 * n (B), 3 * n (O) or 2 * n (Z), then the right 8 * n (B), 3 * n (O) or
2 * n (Z) characters are taken from the input field;
if w <8 * n (B), 3 * n (O) or 2 * n (Z), then the first w characters are read from the input field. Missing to length 8 * n (B), 3 * n (O) or 2 * n (Z) characters are
replaced with spaces.
Unlike other DDs, when outputting with descriptors B, O or Z values  larger than can be placed in the output field are not displayed
asterisks, and w are right characters. When entering from fields that are not filled on the left
input, the sign bit is ignored.
Example:
character (2) :: st (3) = 'ab' integer (2) :: k (3) = 3035
 305
306
O. V. Barteniev. Modern FORTRAN
write (*, '(1x, z4.4, 1x, z2, 1x, z6)') st write (*, '(1x, z4.4, 1x, z2, 1x, z6)') k write (*, '(1x, b16.16, 1x, b2, 1x, b6)') k write (*, '(1x, o5.5, 1x, o2, 1x, o6)') k
Result:
​ 6162 62
​ 6162
0BDB DB BDB
0000101111011011 11 011011
05733 33 20005733
Trailing spaces in the input field are interpreted as zeros if BLANK = 'ZERO' is specified in the OPEN statement, or descriptor BZ is in effect, for example:
integer (1) :: k1, k2, k3 read (*, '(bn, b8, bz, b8, b8)') k1, k2, k3 write (*, '(1x, 3I5)') k1, k2, k3
Let's introduce (we use the symbol to denote a space):
1 1 1000000 Result:
1 64 64
The F w.d descriptor provides the output of real numbers of a single or double precision. The output is performed on a field of w characters.
One character is reserved for the decimal point. When outputting negative numbers, one more character will be reserved for the sign. Of the remaining w - 1 or w
- 2 characters d characters will be reserved for numbers following decimal point of the number. The remaining characters will be either spaces or digits to the left
of the decimal point. Displayed number when converting to external representation as needed rounded off.
length When w characters, on which you can place integer orentered with the F w.d descriptor , data is transferred from the field
real numbers in F- or E-form (signed or unsigned). If no decimal point, the number of decimal places entered real number will be equal to d . If available in the
external decimal point representation number of decimal places entered the value is determined by the position of the decimal point and may differ from the value d
. Spaces between decimal digits or between decimal point and digits are interpreted as zeros if given descriptor BZ, and ignored if descriptor BN is given or if
both there are no descriptors in the format specifier.

Example 1:
307
9. Formatted input / output
real a, b, c, d, e
! Let's introduce:
read (*, 1) a, b, c, d, e
! 
2340.234.234E2-2.34E-3.
023
write (*, 1) a, b, c, d, e
! 2.34 .23 23.40 -.0023.00023
 306
1 format (2F6.2, F7.2, F10.4, BZ, F7.5)
Example 2 . All elements of array a as a result of entering different representations of the number 1.23 will take the same meaning.
real a (5)
! Input data :
read (*, 1) a
! 
123001.23 
12.3E-11
2300.0123E2
write (*, 1) a
1 format (10F8.4)
! 1.2300 1.2300 1.2300
1.2300 1.2300
Comment. In the last example, it is better to use the output, list driven I / O by specifying in the input stream, for example, like this:
read (*, *) a ! 1.23 1.23 1.23 1.23 1.23 or like this (data fields are comma separated):
read (*, *) a ! 1.23, 1.23, 1.23, 1.23, 1.23 or like this:
​ read (*, *) a ! 5 * 1.23
Consider the mechanism for converting the number -1.23 when outputting to example of descriptor F8.3, i.e. the result of the statement
​ write (*, '(f8.3)') -1.23
​ ! -1.230
The number -1.23 will be located on a field 8 characters long. Because the d = 3, and there are only two digits after the decimal point in the number, then the last
the character will be 0, followed by the characters 3, 2, decimal point, 1 and sign -. The first two characters in the number field will be spaces. True, the first space
will not be displayed on the screen and therefore will be output -1.230.
Applying the scaling descriptor k P produces the following actions:
when entering descriptors k PF w.d mean that after transformation F w.d the entered number will be multiplied by 10 - k ;
when outputting with the k PF w.d format, the output value is first multiplied 10 k , and then output according to the transformation F w.d .
Example:
write (*, '(5PF13.4)')
-1.23
! -123000.0000
write 
(*, 
'(F13.4)')
-1.23
! -1.2300
If the displayed value cannot be placed in the designated field, then the output will be asterisks.
 307
308
O. V. Barteniev. Modern FORTRAN
The real number conversion descriptor E w.d [Ee] requires so that when outputting, the element associated with the descriptor E has single or double precision real
type.
When entered, the input field is identical to the input field of the F descriptor.
Parameter e of descriptor E is ignored on input.
The form of the output field depends on the k P specified by the descriptor scaling factor. With a coefficient equal to zero scaling (default) output field whose length
is equal to w , is: minus sign (in case of negative number),
then a decimal point, then a string of d digits, then a field below the decimal exponent, having one of those shown in table. 9.3 forms.
Table 9.3. Form field for decimal exponent in descriptor E
​ Descriptor ​ Exponent
​ Field shape
exhibitors
​ E w.d​ | p | ≤ 99
​ E, then plus or minus, then
decimal exponent two-digit exponents
​ E w.d​ 99 <| p | ≤ 999
​ Plus or minus, then the exponent
decimal exponent of three digits
​ E w.d E e
​ | p | ≤ 10 e - 1
​ E, then plus or minus, then
decimal exponent exponent of e digits, which can contain leading zeros
Example:
real (8) :: a = 1.23D + 205
real (4) :: b = -.0000123445, c = -.123445
​ write (*, '(E15.8)') a
​ ! .12300000 + 206
write (*, '(1x, 2E12.5)') b, c
​ ! -.12344E-04 -.12344E + 00 write (*, '(1x, 2E14.5E4)') b, c! -.12344E-0004 -.12344E + 0000
Consider the mechanism for converting the number 1.23 when outputting to example of descriptor E11.5, i.e. the result of the statement write (*, '(e11.5)') 1.23 !
.12300E + 01
The number 1.23 will be located on a field with a length of 11 characters. The last
characters in descriptor E are reserved for decimalexponent (E), sign and exponent. When outputting all numbers
are displayed after the decimal point, that is, at the output we get the number
0.123 * 10 1 . Since the descriptor after the decimal point provides
characters ( d = 5), then after outputting .123 two zeros will be appended and then the decimal exponent E + 01 will already follow. Result of transformations
there will be a string .12300E + 01.
 308
309
9. Formatted input / output
Descriptor k P with descriptor E w.d [Ee] works like this:
if the scale factor k is greater - d and k ≤ 0 (-d <k ≤ 0), then the output field contains k leading zeros after the decimal point and d + k significant digits after them;

if 0 < k < d + 2, then the output field contains k significant digits to the left from the decimal point and d - k - 1 digits will be located after decimal point. Other k
values  are invalid, for example:
real :: b = -.0000123445, c = -.123445
write (*, '(1x, 2PE12.5)') b
​ ! -12.3445E-06 write (*, '(1x, -2PE12.5)') c              ! -.00123E + 02
Descriptor EN w . d [E e ] transfers data in engineering format and works the same way as descriptor E, except that when outputting the absolute value of the
non-exponential part is always in range from 1 to 1000. The exponent exponent when working with
The EN descriptor is always a multiple of three. Field form for exponent in the EN descriptor is the same as for the E descriptor, for example:
real :: x = -12345.678, y = 0.456789, z = 7.89123e + 23
​ write (*, 1) x, z
​ ! -12.34568E + 03 789.12300E + 21
format (1x, en13.5, 1x, en13.5)
​ write (*, 2) y, z
​ ! 456.79e-0003 789.12e + 0021
format (1x, en13.2e4, 1x, en13.2e4)
ES descriptor w . d [E e ] provides data transmission in scientific format and works the same as descriptor E, except that
 when outputting, the absolute value of the non-exponential part is always is in the range from 1 to 10. The shape of the field under the exponent when
working with ES is the same as for descriptor E.
real :: x = -12345.678, y = 0.456789, z = 7.89123e + 23
​ write (*, 1) x, z
​ ! -1.23457E + 04 7.89123E + 23
format (1x, es13.5, 1x, es13.5)
​ write (*, 2) y, z
​ ! 4.57E-0001 7.89E + 0023
format (1x, es13.2e4, 1x, es13.2e4)
The elements
​ list
​ output ,
​ associated              from descriptor double precision conversions D w.d , must be of real type single or double precision.
All rules and parameters applicable to descriptor E are also applicable to descriptor D.
The input fields when working with the D descriptor are formed in the same way as and the input fields for descriptor F, with the same values  for the parameters w
and d .
The shape of the output field depends on the scale factor, specified by the descriptor k P. When the coefficient is equal to zero scaling the output field looks like
this: minus sign (in case output a negative number), then a decimal point, then a string of numbers
309
310
O. V. Barteniev. Modern FORTRAN
and finally, a field under the decimal exponent. The last field is formed one of those indicated in the table. 9.4 rules.
Table 9.4. Decimal exponent field form in descriptor D
​ Descriptor Exponent
​ Field shape
exhibitors
​ D w.d​ | p | ≤ 99
​ D, then plus or minus, then exponent
decimal exponent of two digits
​ D w.d​ 99 <| p | ≤ 999
​ Plus or minus, then exponent
decimal exponent of three digits
Scaling when working with the D descriptor is performed according to the same the rules by which it is executed for the E descriptor.
Example:
real (8) :: b = -.0000123445_8
write (*, '(1x, D12.5)') b
! -.12344D-
04
write (*, '(1x, 2PD12.5)') b
!
-12.3445D-
06
write (*, '(1x, -2PD12.5)') b
! -.00123D-
02
When transferring data of a logical type, the descriptor L w is used . If the item associated in the output list with descriptor L is not is a boolean element, an
execution error will occur.
As a result of converting a value of a boolean type, the following will be displayed:
w - 1 spaces followed by T or F.
The input field , like the output field, has a length of w characters and may contain spaces, then an optional decimal point, then T (t) for true or F (f) for false . Any
subsequent
characters in the input field are ignored. Therefore, the input can be set and .TRUE. and .FALSE.
Example:
logical :: fl = .true., yesno = .false.
​ write (*, '(1X, 2L5)') fl, yesno ​ ! TF
Descriptor A [ w ] is used primarily for data I / O character type. If the length w is omitted, then it is taken equal to the length of the B / B element associated with
descriptor A.
The I / O list item can be of any type. If he is not element of character type, then each byte of the internal representation matches the symbol. For example, an
element of type INTEGER (2) matches 2 characters. However, regardless of the data type used each I / O list item must be specified as a sequence characters.
310
311
9. Formatted input / output
When an I / O list item is of type INTEGER, REAL, or LOGICAL, then you can use Hollerites to define character strings symbolic constants. For each type of
data, the possibility remains using built-in operations for this type. So, announced in
INTEGER character strings can be added, multiplied, and so on.
The input line of text is entered character by character followed by converting a character to its binary representation.

If you enter the number of characters the element the k < w , there will be introduced w characters, but only the last k will belong to the input element. If k > w ,
then w characters will be entered , and the remaining characters of the string will be filled with trailing blanks.
Data output using descriptor A is aligned on the right margin of the field, trailing spaces are preserved.
Example:
 integer (4) :: b = '2bcd7', g = 4Ha25f real (8) :: d = '# 456 & 7xz' character (12) :: st1 = 'string 1', st2 = 10hNew string, st3 * 6
write (*, '(4 (1x, A))') b, g + 2, d
! 2bcd c25f #
456 & 7xz
write (*, '(4 (1x, A))') b - g
! - / ._
write (*, '(1x, a14, a5)') st1, st2
! string 1 New s
read (*, '(A3)') st3
! ert - input line (
k > w )
write (*, *) st3, 's'
! ert s
read (*, '(A8)') st3
! ert - input line (
k < w )
write (*, *) st3, 's'
! ts
Explanation . The variable b occupies 4 bytes in the computer memory, therefore from string '2bcd7' only 4 first characters will be set to b .
Generic descriptor G w.d [E e ] can be used with data any built-in type. For integer data, descriptor G w.d has the same effect as descriptor I w . m . For logical
data G w.d acts in the same way as L w . For character data G w.d , as well as A w .
Example:
integer (4) :: k = 355 logical :: fl = .true.
character (10) :: st = 'string'
​ write (*, '(1x, 3g10.5)') k, fl, st              ! 00355 T string
For real data, the G w.d [E e ] descriptor is more flexible than descriptor F because it automatically switches from F to format E depending on the size of the
transmitted data.
When G w.d [E e ] is used as a real descriptor, the input field is equal to w characters and d characters in this field are reserved for the following behind the
decimal point of a number, that is, when you enter G w.d [E e ] works the same as
311
312
O. V. Barteniev. Modern FORTRAN
and the F w.d . When outputting, transform G depending on the value of the output quantity corresponds to either the F- or the E-transformation. Table 9.5, 9.6
the interpretation of the descriptors G and GE at the output is given.
Table 9.5. Interpreting the G w.d descriptor in output
The absolute value of the quantity
Interpretation
x <0.1
Gw.d = Ew.d
0.1 ≤ x <1
Gw.d = F (w - 4) .d, 4
()
1 ≤ x <10
Gw.d = F (w - 4). (D
- 1), 4 ()
10 d-2 ≤ x <10 d-1
Gw.d = F (w - 4) .1, 4
()
10 d-1 ≤ x <10 d
Gw.d = F (w - 4) .0, 4
()
10 d ≤ x
Gw.d = Ew.d
The G w.d [D e ] descriptor is equivalent to the G w.d [E e ] descriptor then except that the output prints D instead of E.
 Table 9.6. Interpreting the G w.d E e descriptor on output
The absolute value of the quantity
Interpretation
x <0.1
Gw.dEe = Ew.d
0.1 ≤ x <1
Gw.dEe = F (w - e - 2)
.d, (e + 2) ()
1 ≤ x <10
Gw.dEe = F (we-2). (D-
1), (e + 2) ()
10 d-2 ≤ x <10 d-1
Gw.dEe = F (w - e - 2)
.1, (e + 2) ()
10 d-1 ≤ x <10 d
Gw.dEe = F (w - e - 2)
.0, (e + 2) ()
10 d ≤ x
Gw.dEe = Ew.d
Example:
real :: b1 = .01234, b2 = 123400, b3 = 123.4
write (*, 1) b1, b2, b3
​ ! -.12340E-01 .12340E + 06 123.40 write (*, 2) b1, b2, b3              ! -.12340E-001 .12340E + 006 123.40
format (1x, 3G12.5)
format (1x, 3G12.5E3)
9.8. Control descriptors
Control descriptors are also called non-repeating
​ transformation descriptors
​ (DP), because before such
descriptors (unless the descriptor is parenthesized) to the format specification cannot specify the repetition rate. Non-repeating DPs serve:
• to control the I / O position (conversions n X, T, TL, TR);
312
313

9. Formatted input / output
entering additional information into the record (transformingapostrophe and Hollerith);
scaling data and others, given in table. 9.7, functions I / O control.
 The DP list uses to separate its individual descriptors comma that can be omitted:
between descriptor P and immediately following descriptors F, E,
EN, ES, D or G, for example: 1X, 2P F9.6;
before or after the apostrophe ('), quotation marks ("), backwardslash (\) or colon (:), for example: 1x, I3, '' B8 \;
before and after a slash, for example: 1x, 2I5, 2  (/ 2F5.2).
Table 9.7. Non-duplicate transformation descriptors
Forms
Name
​ 
Appointment
​
Using
Line
Transformation
apostrophe
Transfers a line of text to a file
​
Output
nH
Transformation
Hollerith
Send n characters to a file
​ "
Q
Transformation poll Returns a number
​ Input unread
write characters
Tn, 
TLn,
TRn
Transformation
positions
Position specification in I / O record
nX
Transformation
positions
​ "
​ "" ""
SP, SS, S Transformation plus
sign
Controlling the output of the plus sign
Output
/
Transformation
slash
Go to the next entry and
​ I / O
end symbols records
\
Transformation
backslash
Continue current recording
​ Output
(for the same purposes you can use $
sign)
:
Interrupt fulfillment
DP actions
When the output list is exhausted
​ "
interrupts execution of DP
kP
Transformation
Sets the value
​ I / O
large-scale exponent in DD F, E, D coefficient and G
​ BN, BZ
​ Interpretation
​ Sets the way              Input
​ spaces
​ interpretation of spaces
 313
314
O. V. Barteniev. Modern FORTRAN
Converting an apostrophe or double quotes does the output enclosed in apostrophes or quotation marks of a string. To output framed with apostrophes and a
string containing apostrophes, you must specify each print apostrophe twice (or enclose the string in double quotes).
Similarly, output of strings containing double quotes is performed. Converting apostrophe and double quotes cannot be used with the READ statement.
Example:
write (*, 1)
1 format (2x, 'Enter the line segment [a, b]:')
! or write (*, '(2x, "Enter the boundaries of the segment [a, b]:")')
! or by applying descriptor A
write (*, '(2x, a)') 'Enter the boundaries of the segment [a, b]:' read (*, *) a, b
Comment. If the format specification of the WRITE statement contains the string is enclosed in apostrophes, then the specification itself must be enclosed in double
quotes; you can do the opposite, for example:
write (*, "(2x, 'Enter the boundaries of the segment [a, b]:')")
Hollerith's transformation. Descriptor n H conveys n characters, including spaces, to file or screen. Number of characters following descriptor n H must be equal
to n . Hollerith's transformation can be used wherever symbolic constants are allowed.
It is customary to call constants defined using the n H descriptor , Hollerite constants .
Example:
write (*, 1)
1 format (2x, 31HEnter the boundaries of the segment [a, b] :)
! or write (*, '(2x, 31HEnter the boundaries of the segment [a, b] :)')
Comment. Fortran 95 removed the Hollerite constants from the standard; despite this, they continue to be supported by CVF.
Poll transformation . Descriptor Q returns the number of uncommitted write characters. I / O list item corresponding to descriptor Q must be integer or boolean.
In the following example, the variable nq corresponds to the Q descriptor , into which, thanks to the Q descriptor, it will be read (after entering five elements of
array kar ) the number of non-transmitted characters of the record Then the nq value will be used when entering the chr array .
 314
315
9. Formatted input / output
integer kar (5), nq character (1) chr (80) read (4, '(5I4, Q, 80A1)') kar, nq, (chr (i), i = 1, min (nq, 80))
The value returned by the Q descriptor can be used not only in the current, but also in the next input statement. To do this, after the survey record must remain in
the current record, i.e., apply input without promotions, for example:
integer k, nq
​ ! The ADVANCE = 'NO' specifier specifies the input character (1) chr (80)              ! no promotion read (*, '(I2, Q)', advance = 'no') k, nq
read (*, '(80A1)') (chr (i), i = 1, min (nq, 80))
Position transformation . The T, TL and TR descriptors specify the position the record to or from which the next character will be passed.

The new position can be specified either to the left or to the right of the current one. it allows you to use the entry more than once when typing. True, not it is
recommended to move in the opposite direction more than 512 bytes (characters).
The T n descriptor specifies an absolute tab: passing the next character will be executed starting from position n (counting positions is executed from the beginning
of the recording).
The TR n descriptor specifies a relative right-hand tab: transfer
the next character will be executed starting from the position located on the n characters to the right of the current position.
The TL n descriptor specifies a relative left tabulation: transfer the next character will be executed starting from the position located
on the n characters to the left of the current position. If specified by the descriptor TL n position is before the first position of the current record, then transmission
the next character will be executed from the first position. If the size write more than the allocated I / O buffer, you cannot perform the left tab to a position
belonging to the previous buffer.
If as a result of applying the positioning descriptor a move to the right of the last transmitted character is performed and the new value is output, then the space
between the end the previous value and the start of the new value will be filled spaces.
The n X descriptor is used to move the I / O position by n characters forward.
Example:
real :: a = 1.23, b = 5.78, c
​ write (*, 1) a, b
​ ! a = 1.230 b = 5.780
1 format (T7, 'a =', f6.3, TR7, 'b =', f6.3)
 315
316
O. V. Barteniev. Modern FORTRAN
read (*, '(20 (f6.2, TL6))') a, b, c! Introduce: 4.67
​ write (*, '(4x, 3f6.2)') a, b, c
​ ! 4.67 4.67 4.67
The + sign in numeric fields is controlled when using the SP, SS, and S descriptors. Using the SP descriptor provides the output of the + sign in numeric fields in
which to output positive numbers. SS descriptor suppresses + sign output
(accepted by default). The S descriptor restores the action descriptor SS.
Example:
real :: a = 1.23, b = 5.78
write (*, '(2f6.2)') a, b
! 
1.23
5.78
write (*, '(sp, 2f6.2)') a, b
! + 1.23 +
5.78
write (*, '(sp, f6.2, s, f6.2))') a, b! +1.23 5.78
Slash transformation. In the current record, a slash (/) indicates the end data to be transferred.
On input, the slash positions the file behind the current record.
When displaying a slash, it provides end-of-record characters and positions the file behind those characters. Before the slash there may be the repetition rate is set.
Example:
integer a (20)
open (9, file = 'a.txt', blank = 'null') read (9, 1) a write (*, 1) a
1 format (7i3 / 5i3 / 8i3)
The composition of the a.txt file :
1 2 3 4 5 6 7 8 9 10
11 12 13 14 15 16 17 18 19 20
-1 -2 -3 -4 -5 -6 -7 -8 -9 -10
When entering format 1 from the first record of the file, 7 numbers will be entered, from the second - 5 and from the third - 8. Go from one record to the next
provided by slash conversion.
Output result in format 1:
1 2 3 4 5 6 7
11 12 13 14 15
-1 -2 -3 -4 -5 -6 -7 -8
Backslash transformation. Default on completion data transfer, the file is positioned after the processed record,
even if not all of the recording data has been transferred. However, if the sequence DP contains a backslash (\), then advancing the file pointer when when the
statement is completed, no output will occur. therefore
 316
317
9. Formatted input / output
the next output statement will continue transferring data to the same record, starting from the position where the file was last left the output operator.
The $ descriptor and the specifier have the same effect.
operator I / O ADVANCE = 'NO', which, however, unlike descriptors \ and $ are applicable as you type. Descriptors $ and \ often are used to organize requests,
for example:
write (*, 1) read (*, *) a, b
1 format (2x, 'Enter the line segment [a, b]:', \)
! or format (2x, 'Enter the boundaries of the segment [a, b]:', $)
After the query is displayed in format 1, it will be possible to enter the boundaries of the segment execute on the same line as the query.
Interrupt execution of a format specification DP action is accomplished by the colon (:) handle . The interruption occurs when the case when the output list is
exhausted.
An example where a colon interrupts the output of explanatory text:
real :: a = 0.59, eps = 1e -5
write (*, 1) a, eps ​ ! Section start .59 Accuracy: .100E-04 write (*, 1) a              ! Section start .59
1 format (1x, 'Start of segment:', f4.2,: 2x, 'Precision:', e9.3)

The scale factor transformation is specified by the handle k P. The descriptor sets the scaling factor for the entire DD sequences F, E, D and G until another is
encountered descriptor k P. Default scale factor conversion
not set. The action of the descriptor k P was described when considering DD F and E. Here we restrict ourselves to an example:
real a (4), b (4), c (4), d (4) open (9, file = 'a.txt') read (9, 1) (a (i), b (i), c (i), d (i), i = 1, 4)
1 format (f10.6, 1p, f10.6, f10.6, -2p, f10.6) write (*, 2) (a (i), b (i), c (i), d (i), i = 1, 4) 2 format (4f11.3)
The composition of the a.txt file :
12340000 12340000 12340000 12340000
​ 12.34​ 12.34​ 12.34​ 12.34
12.34e0 12.34e0 12.34e0 12.34e0
12.34e3 12.34e3 12.34e3 12.34e3 Result :
12.340
1.234
1.234
1234.000
12.340
1.234
1.234
1234.000
317
318
O. V. Barteniev. Modern FORTRAN
​ 12.340
​ 12.340
​ 12.340              12.340
12340.000 12340.000 12340.000 12340.000
Interpretation of spaces in numeric fields is controlled by the BN and BZ DPs.
The BN descriptor ignores whitespace: all distinct whitespace characters and are right justified. So, in the case BN applications of fields -1 .23 and -1.23 are
equivalent.
The BZ descriptor identifies all blanks in the field as zeros. So, in In the case of BZ, the fields 1 .2 3 and 100.203 are equivalent.
Comment. Spaces following E or D when entering real
numbers are always ignored, regardless of the type of descriptor applied interpretation of spaces.
By default, I / O operators initially interpret spaces.
according to the BN descriptor, unless the OPEN statement is specified BLANK specifier = 'NULL' | 'ZERO'.
If the BZ descriptor is given, it will be valid until the BN descriptor will not be found.
9.9. List-driven I / O
 With list driven I / O, all conversions are performed with taking into account the type of I / O list items and the values  of transmitted data in in
accordance with the agreements adopted in Fortran.
List-driven I / O is used when working with text serial devices and cannot be used during operation with unformatted files and with formatted files connected for
direct access.
There are two types of list-driven I / O:
named and unnamed list.
When using an unnamed list, data transfer may run to internal files as well.
9.9.1. Named List Driven I / O
I / O syntax under named list control:
WRITE ( u , [NML =] I / O list name ) READ ( u , [NML =] I / O list name ) u - I / O device (see section 10.2).
the name of the I / O list is specified by the NAMELIST operator .
The NML specifier can be omitted. His presence is mandatory if other WRITE or READ statement specifiers are given, for example
END.
List-driven I / O convenient for debugging and testing programs when you often need to display the names of variables and their values.
318
319
9. Formatted input / output
9.9.1.1. Declaring a named list
The NAMELIST statement of a named I / O list declaration must appear in the program unit declaration section and looks like:
​ NAMELIST / I / O list name / variable list              &
[/ I / O list name / variable list ...]
I / O list name is the name of the variable list. The same list name I / may appear multiple times in the NAMELIST statement. In this case the corresponding
variable lists are treated as one
list. The order of the elements in such a list corresponds to their location in the NAMELIST statement.
list of variables - list of variable names, may contain
variables of a derived type, which, however, should not be components have links. Formal parameters cannot be list items. Also, list items cannot be subobjects.
(sections of arrays, substrings ...). The same name may appear more than than in one list of variables.
The NAMELIST statement assigns a name to a variable list. Further it the name is used in I / O statements. For instance:
integer :: ia = 1, ib = 2
 complex :: z (2) = (/ (2.0, -2.0), (3.5, - 3.5) /)
namelist / ico / ia, ib, z ​ ! Declaring a named list write (*, ico)              ! Displaying the named list on the screen
9.9.1.2. NAMELIST output
When displaying a named list, the result is:
& output_list_name variable name = value | list of values
...
variable name = value | list of values
/
Example:
integer :: k, iar (5) = (/ 41, 42, 43, 44, 45 /) logical :: fl = .true.
real :: r4 * 4 = 24, r8 * 8 = 28 complex (4) :: z4 = (38.0, 0.0) character (10) :: c10 = 'abcdefgh' type pair

character (1) a, b
end type pair type (pair) :: cp = pair ('A', 'B') namelist / mesh / k, fl, r4, r8, z4, c10, cp, iar k = 100 write (*, mesh)
319
320
O. V. Barteniev. Modern FORTRAN
Result :
& MESH
​ K =
​ 100
FL = T
R4 = 24.000000
R8 = 28.000000000000000
​ Z4 = ​ (38.000000,0.000000E + 00)
C10 = abcdefgh
CP = AB
​ IAR =
​ 41 42 43 44 45
/
The example shows that the character data is displayed without framing.
quotes. If necessary, you can output a line with framing quotation marks or apostrophes. For this, a text file (or
serial device, for example a screen) must be opened with DELIM = 'APOSTROPHE' or DELIM = 'QUOTE' which specifies the kind of delimiter character data:
apostrophe (') or quotation marks ("). For NAMELIST output to a file opened, for example with DELIM = 'APOSTROPHE', output character data are delimited
by an apostrophe, and those present in apostrophes are doubled on a line. Has a similar effect
 DELIM specifier = 'QUOTE'. Lack of OPEN statement the DELIM specifier is equivalent to specifying the DELIM specifier = 'NONE'.
Example:
integer :: k = 100 character (10) ::
c10 = 'abcd "efgh' type pair
character (1) a, b
end type pair
type (pair) :: cp = pair ('A', 'B')
namelist / mesh2 / k, c10, cp open
(10, file = 'a.txt', delim = 'quote')
write (10, mesh2)
! Output to file a.txt
open (6, delim = 'quote')
! Changing connection
properties
write (6, mesh2)
! Output on display
Result (the quotes inside the C10 string are doubled):
& MESH2
​ K =
​ 100
C10 = "abcd" "efgh"
CP = "A" "B"
/
320
321
9. Formatted input / output
9.9.1.3. NAMELIST input
Entering a named list is practically the opposite of it conclusion.
When entering a named list, the input operator searches the file for the beginning list, which can be of the form: & list_name or $ list_name . Scroll belonging to the
named list of data ends with a slash (/) or
a dollar sign ($) or an ampersand (&). After dollar signs and ampersands may be followed by the word END. Each input element looks like:
variable_name = value | list of values variable_name (although in NAMELIST only
complete objects) can also be a subobject - a section or array element, substring, record component ...
 Example:
& eli k = 1 /
$ eli k = 1 $
or $ eli k = 1
$ end
& eli k = 1 &
or & eli k = 1
& end
$ eli k = 1 & end or & eli k = 1
$ end
The order in which variable names appear in the file has no values. The number of listed inputs may be less
declared. The names of variables and arrays in the file must match with the corresponding names of the variable list of the NAMELIST statement. Separators
between input data are comma, space,
end-of-line character and tab character. This means that on one line file can contain more than one input element.
Example:
integer :: k, iar (5) logical :: fl real r4 complex z4
character :: c10 * 10, c4 * 4 namelist / mesh / k, fl, r4, z4, c10, c4, iar open (1, file = 'a.txt') read (1, mesh) write (*, *) k, iar, fl write (*, *) r4, z4, '', c10, '', c4
The composition of the a.txt file :
& Mesh K = 100, FL = T, Z4 = (38, 0), C10 = 'abcdefgh' r4 = 24.0, iar = 1, 2, 3, 5, 5, c4 = 'sub'
/
 321

322
O. V. Barteniev. Modern FORTRAN
Result:
100
​ 1
2
​ 3
​ five
five
​ T
24.000000
(38.000000,0.000000E + 00) abcdefgh
sub
Comment. Named input list with data
now, according to the 1995 standard, may contain a comment, next, as in the source code, after the exclamation mark, eg:
The composition of the a.txt file :
& Mesh K = 100, FL = T, Z4 = (38, 0), ! Setting numerical data
C10 = 'abcdefgh' r4 = 24.0, iar = 1, 2, 3,
5, 5 /
! 
The 
value 
of 
a
symbolic variable
If in a list of values (in the example, such a list is used for setting values  of array iar ) before the first comma or between commas there is no value, then it is treated
as null and the value the corresponding entry in the input list is not changed.
To set a logical value in the file, you must specify T or
.TRUE., F or .FALSE. or another value satisfying the L descriptor.
Character data can be specified without a delimiter, but if the string contains spaces, or commas, or slash, or end characters string, then for correct entry it must be
enclosed in quotes or apostrophes. In this case, the delimiters present in the line must be doubled.
Example:
integer :: iar (5) = 100 logical fl character (10) st namelist / mesh2 / iar, fl, st open (1, file = 'a.txt')
read (1, mesh2)
write (*, *) iar, fl, '', st
The composition of the file a.txt (subobjects of the iar array are specified in the file , and elements iar (1) and iar (3) correspond to values):
& Mesh2 st = 'ab d''ef gh' iar (1: 4) =, -2,, -4, iar (5) = 55, fl = .False.
& end
Result:
​ 100
​ -2 100
​ -4
​ 55 F ab d'ef gh
Comment. Duplicate LOV values can be written as a single value, by placing a repetition factor in front of it followed by an asterisk (*). For example, the task:
 322
323
9. Formatted input / output
iar = 3 * 5, 2 * 10 similar to the following:
iar = 5, 5, 5, 10, 10
9.9.2. Unnamed List Driven I / O
In the case of an unnamed list, the I / O statements are:
WRITE ( u , [FMT =] *) [ output list ]
PRINT * [, output list ]
READ ( u , [FMT =] *) [ entry list ] READ * [, entry list ]
u - I / O device (see Sections 10.2 and 10.3);
* - indicates that the I / O will be controlled by the I / O list.
The I / O list is formed according to the same rules that apply to formatted I / O.
9.9.2.1. Unnamed list driven input
For unnamed list-driven input, the following rules apply:
input is performed from sequential text files, internalfiles or from the keyboard;
the input field contains a constant (or repeating constant),whose type must match an element of the input list, for example:
real a, b, c read (*, *) a, b, c
​ write (*, *) a, b, c ​ ! 1.440000 1.440000 1.440000
Let's introduce , for example:
7 * 1.44
when entering numeric values, spaces are always treated asseparators between fields; leading spaces before the first field records are ignored;
end-of-record characters have the same effect as spaces, forexcept when they are located inside a symbolic constants;
it is permissible to use a comma as separators between fieldsinput;
if there is a slash (/) between the input fields, the input stops and allsubsequent elements of the input list do not change their values.
When setting input field constants, you should follow the rules:
single or double precision real constants must be numeric input fields, that is, fields suitable for conversions using the F descriptor;
 323
324
O. V. Barteniev. Modern FORTRAN
complex constants are an ordered pair of real or integer constants separated by comma and enclosed in parentheses;
boolean constants contain the required symbols T (t) or F (f), which can be preceded by an optional period. Further may be followed by optional characters. So,
the characters T, or .t, or tru, or T1, or .t1, or .T44, or .true. can be used for representations of the boolean constant .TRUE .;
character constants are specified by character strings enclosed in apostrophes (') or quotation marks ("). Each delimiter inside character constant must be
represented by two single delimiters, between which there should be no spaces.
The character constants can be continued in the next entry.
In this case, the end-of-record characters do not become part of the character constants, for example:
character (80) st read (*, *) st
​ write (*, *) st
​ ! Line1 - next line and last line
Let's introduce :
'Line1 - next line and last line '

A character constant can also be specified without delimiters, but in this case, the constant cannot include delimiter characters: spaces, commas, end-of-line
characters, slashes. Also impossible place such a constant on several lines;
if the length of the character constant is less than or equal to the length of the inputelement, then all non-entered constant characters will be entered characters will
be filled with spaces. If the length of the character constants greater than the length n of the input element, then the first n characters of the constant;
the definition of a derived type is performed by enumerating valuesfor its components in the order given when declaring derived type.
Input fields contain empty ( null ) values  if:
between two consecutive delimiters of input fields charactersnot specified, for example: 11.1,,, 12.2;
characters are not specified before the first separator in the record;• a duplicate constant with an empty value is specified, for example, 7 * is equivalent to setting
7 input fields with blank values.
 324
325
9. Formatted input / output
If an element of the input list corresponds to a null -field, then the value the element does not change as a result of executing the input statement.
Spaces are treated as part of the delimiter except:
spaces embedded in a delimited character
string;
leading spaces of the first record, unless immediately after themfollowed by a comma or slash (/).
Example:
complex :: z = (1, 2) real :: a = 3.3, b = 2.2 logical :: fl = .true.
character (30) :: st = 'ab' read (*, *) z, a, b, m, n, fl, st write (*, *) z, a, b, '\ n \ r'c, m, n, fl,' ', st
Let's introduce:
, 1.1,,, 3 /
Result:
​ (1.000000,2.000000)
​ 1.100000              2.200000
​ 0
​ 3 T ab
9.9.2.2. Unnamed list driven output
Output under the control of an unnamed list is done like this:
output is carried out in sequential text files,internal files, to the screen or printer;
the length of the record created during the output does not exceed 79 characters. If however, to place the output elements requires a larger number characters,
new records are created. At the end of each entry end-of-record characters are put down: CHAR (13) and CHAR (10);
character data is output without delimiters by default, however after specifying the DELIM = 'QUOTE' qualifier in the OPEN statement, or DELIM =
'APOSTROPHE' the output of the character value is in progress with delimiters: quotes or apostrophes. Moreover, if in there are delimiters to the symbol value,
they will be doubled;
inference of an object of a derived type is performed component-wise in the order in which the components appear in the derived type declaration.
Unnamed list driven output of various data types is performed in accordance with those given in table. 9.8 DP that, as you can see from the table, they differ in
CVF and FPS.
Table 9.8. Conversion descriptors for controlled output unnamed list
​ Data types ​ CVF
​ FPS
325
326
 O. V. Barteniev. Modern FORTRAN
LOGICAL (1),
​ L2
LOGICAL (2),
​ output:
LOGICAL (4)
T for .TRUE.,
F for .FALSE.
L1
outputs: T for .TRUE.,
F for .FALSE.
BYTE,
​ I5
INTEGER (1)
I11
INTEGER (2)
​ I7
I11
INTEGER (4)
​ I12
I11
REAL (4)
​ 1PG15.7E2
F15.6 (1 ≤ val <107)
E15.6E2 ( val <1 or
val ≥ 107)
REAL (8)
​ 1PG24.16E2
E24.15 (1 ≤ val <107)
E24.15E3 ( val <1 or
val ≥ 107)
CHARACTER ( w ) 1X, A w
A w
The following symbols are used in the table:
- space;
val - displayed value;
w - the size of the character string.
Example 1 . Output of a "long" constant:
character :: sub * 10 = '1234567890', st * 150 =
'' do 1, i = 1, 15
1 st = trim (st) // sub write (*, *) st
Example 2 . Comparison of CVF and FPS pins:
character (3) :: st = 'abc'
print *, st
​ ! CVF:
​ abc
! FPS: abc
print '(a3)', st
​ ! CVF: abc

! FPS: bc
The difference in formatted line output is due to the fact that in CVF by default CARRIAGECONTROL is 'LIST' and in FPS it is 'FORTRAN'.
Comment. You can use SI symbols to control the output:
'\ n'c - newline,' \ r'c - carriage return, '\ t'c - tabulation, etc. (Section 3.5.5). For instance:
character (4) year (5) / '1998', '1999', '2000', '2001', '2002' / write (*, *) 3.55, '\ t'c,' pels ',' \ n \ r'c, (year (i), '', i = 1,5)
Result:
3.550000 pels
1998 1999 2000 2001 2002
326
327
10. Fortran files
10.1. External and internal files
Fortran distinguishes between two types of files: external and internal.
External file - a file that exists in an environment external to to the running program.
Internal file - character string (substring) or array.
Internal files are open by default. External files must be opened (connected to the I / O device) by the operator
OPEN.
Fortran files can be organized either sequentially or direct access. For some types of files - both. With internal files use only sequential access. External files can be:
formatted (text, ASCII);
binary (binary);
unformatted .
 Binary and unformatted files contain unformatted records, that is, records created without data conversion. The file cannot contain both formatted
and non-formatted records.
External files can be opened for both exclusive and shared (network) access. You can create a temporary ( scratch ) an external file that will be deleted from the
physical device either after closing it, or when the program ends normally. When shared access external file can be locked (make inaccessible to another process).
10.2. File position
As a result of performing an operation on an external file, it can be:
at the starting point of the file - immediately before the first record;
between adjacent records of the file;
within one record;
at the end point of the file - after the last record before the special end-of-file records;
on the "end of file" record;
after the special entry "end of file".
The fact of moving to the "end of file" is set by the EOF function, which returns .TRUE. if the file is positioned at the end of the file, or followed by .FALSE. -
otherwise.
327
328
O. V. Barteniev. Modern FORTRAN
The file appears after the "end of file" entry, if as a result
When the READ statement was executed, an end-of-file situation occurred. File not must be set after writing end of file before starting
data transmission. To change the situation in files with sequential access uses the operators REWIND or BACKSPACE. 10.3. I / O device
For data transfer, the Fortran file is connected to an I / O device.
The device of the external file is specified by an integer scalar an expression or an asterisk (*). The result it returns is called number of the I / O device whose value
should be in range from 0 to 32767.
The device of the internal file is set by the standard variable character type.
The device is used to link to a file.
In addition to files, physical I / O devices can be connected devices such as keyboard, screen, printer, parallel port.
There are always devices *, 0, 5 and 6 in every Fortran program. Moreover, by default, a keyboard is connected to devices *, 0 and 5 , and for devices *, 0 and
6 - screen . So, in the program
 real :: b = 1.2 write (*, '(F6.2)') b write (0, '(F6.2)') b write (6, '(F6.2)') b end all WRITE statements will print the value of b to the screen.
The external file is connected to the I / O device as a result execution of the OPEN statement. Once connected, both the device and the file are considered open.
Accessing an external file after it open, executed by the number of the device to which it is connected:
all software components referring to the same device, refer to the same file. The analogue of such a number is in SI a pointer to a file, in Pascal, a file variable.
Example:
integer :: k = 2, m = 4
! I / O device - integer scalar expression
open (k * m, file = 'd: \ a.txt') ​ ! File d: \ a.txt is connected to device 8 open (m / k, file = 'd: \ b.txt')              ! File d: \ b.txt is connected to device 2 write (8,
'(i8)') k              ! We write to the file d: \ a.txt write (m - k, '(i2)') m              ! We write to the file d: \ b.txt
close (8)
​ ! Close device 8 and file d: \ a.txt close (k)              ! Close device 2 and file d: \ b.txt
328
329
10. Fortran files
Same I / O device in any software item the program being executed refers to the same file, for example:
program fOpen
integer, parameter :: n = 9
open (n, file = 'a.txt')
! Connecting the a.txt file to
the device 9
write (n, *) 'Test string'
! We form one record in the
a.txt file

call ReadFileData () end
program fOpen
! Reads the first record of the
file a.txt
subroutine ReadFileData ()
! In the subroutine, device 9
refers to
character (30) :: st
! a.txt file
rewind 9
! Go to the beginning of the
a.txt file
read (9, '(a)') st
! We read the first record of
the file a.txt
print *, st end subroutine
ReadFileData
! Test string
 The device cannot be simultaneously connected to more than one file, also the file cannot be connected at the same time to more than one device.
10.4. Internal files
There are two main types of internal files:
a symbolic scalar variable, an element of a symbolic array,a character substring. Each such file has one record, length
which matches the length of the character element that forms the file;
character array. The number of entries in such a file is the same as elements of a character array. File record length is equal to length element of a character array.
Operators are used to transfer data to an internal file
WRITE and READ. In this case, you can use both formatted I / O, so and I / O driven by an unnamed list.
Before executing an I / O statement, internal files are always positioned at the beginning of the file. Internal files after creating them always open for reading and
writing. Internal device file is the name of a string, substring, character array, or element.
Internal files are often used to create lines containing a mixture of character and numeric data (Section 3.8.7), as well as for simple conversions "number - string"
and "string - number", for example:
10.5. External files
External files are characterized by the following concepts.
The record type determines whether the file records are of the same length, or they can be of different lengths, or specifies the way to determine the end of one
recording and starting another.
File access determines the method used when reading and writing data, regardless of their organization. The way the file is organized is not always defines the
method of accessing its records.
real :: a = 234.55 integer kb
character (20) st
write (st, *) a
! 
Number-to-string
conversion
print *, st
! For FPS:
! 234.550000 329
330
O. V. Barteniev. Modern FORTRAN
read (st, '(i8)') kb ! For CVF:
! 
String 
to 
Number
Conversion
read (st, '(i5)') kb
! 
String 
to 
Number
Conversion
print *, kb end
! 23
 CVF supports two types of file organization : sequential and related . In CVF, the organization is specified by the ORGANIZA specifierTION of the
OPEN statement. Files with an associated organization stored on disk, sequential - both on disk and on a magnetic tape. All other peripheral devices such as
terminals or printers are treated by Fortran as serial files organization.
Comment. Files with a related organization will also be called linked files .
A sequentially organized file consists of records arranged in the order of their arrival in the file.
In linked files, the records are of the same length and are stored in this way called cells. Each cell has a number from the range [1, n ], where n is last available cell
number. The cell number is the record number,
calculated relative to the beginning of the file. In CVF to delete an entry the associated file, the DELETE statement is used.
Fortran supports two methods of accessing an external file:
sequential and direct - and 3 file structures: formatted , unformatted and binary . Therefore, you can create files:
formatted sequential;
formatted straight lines;
unformatted sequential;
unformatted straight lines;
binary sequential;
binary straight lines.
 330
331
10. Fortran files
Comment. Files connected for direct access, we will
to shorten, ​ also
​ call
​ straight sequential access -
sequential .
files ,
and for
In sequential files, existing entries can only readable but cannot be edited. Without loss of information new records are added only after the last file write. Attempt
dump a record before this record will result in clipping of subsequent records
- their replacement with the added one. To change a sequential entry file, the following path is possible: read all file records into an array; change the required entry
in it; go to the beginning of the file and write the array to the file.

In direct files, a record is accessed by record number, by specifying which you can read, add, replace or delete an entry. AT this is the main difference between
sequential and direct
files. When you include the REC specifier in data transfer statements and file management, the direct file is positioned after the specified this specifier notation.
For external files it is true:
to provide access, the file must be open (connected todevice I / O);
when opening a file, by default it is positioned on the firstfile write or "end of file" if there are no entries in the file;
the last record of the file is the special “end of file” record.
10.6. Recordings
10.6.1. Post types
A record is a sequence of values  (in the case of non-formatted and binaries) or a sequence of characters (in the case of format files). Record field - a part of a
record containing data which can be used by the input operator. Recording type defines how fields are stored within a record. Record type not saved as a file
attribute. However, application with a record type file, different from the one used when creating the file, may result in in some cases to unpredictable results.
The entry is current if the file is set inside the entry, in otherwise, there is no current record.
If the / fpscomp: ioformat compiler option is omitted, CVF has the following 6 types of records:
fixed length. Such recordings are possible in files and with consistent and with a related organization;
variable length; are only possible in files with serial organization;
 331
332
O. V. Barteniev. Modern FORTRAN
segmented; are only possible in files with serial organization open to non-formatted sequential access. Segmented files are the prerogative of CVF and cannot be
used by other platforms;
streams without separators between records; are only possible in files with a consistent organization;
CR streams; use CR (CHAR (13), carriage return) as separator between records; used in files with consistent organization;
LF streams; use CR and LF (CHAR (10), line feed) as separators between records; applied in files with consistent organization.
10.6.2. Fixed length records
Fixed-length records are shown in Fig. 10.1 structure.
Recording data
<-------------------- Record Length (RECL = recl ) ---------------------- >
Figure: 10.1. Fixed length record structure
Fixed length records have associated files and files with consistent organization, open for direct access. Length record is specified in the OPEN statement by the
RECL specifier.
Example:
type point
real x, y
end type point integer i type (point) :: pt1 = point (1.0, 1.0), pt2 = point (2.0, 2.0), pt3 = point (3.0, 3.0)
​ open (1, file = 'a.txt', organization = 'sequential', access = 'direct',              &
form = 'formatted', recordtype = 'fixed', recl = 20)
write (1, '(2f10.3)', rec = 1) pt1
​ ! We enter 3 records into the file write (1, '(2f10.3)', rec = 2) pt2              ! RECORDTYPE specifier = 'FIXED' write (1,
'(2f10.3)', rec = 3) pt3              ! can be omitted end
Result (composition of the a.txt file):
1.000 1.000 2.000 2.000 3.000 3.000
Comment. The example is valid only for CVF, since in the operator OPEN FPS ORGANIZATION specifier cannot appear.
 332
333
10. Fortran files
10.6.3. Variable length records
Such records can contain an arbitrary number of bytes (not exceeding maximum possible value). Their structure is shown in Fig. 10.2.
Recording data
​ 4
​ <-------------------------- Record Length --------------------- ------>              4
Figure: 10.2. Variable length record structure
Variable length records can only exist in files with consistent organization. Each entry is framed with 4-byte fields containing the length of the record and performing
control functions. The value stored in these fields is returned when using the READ statement with the Q control descriptor (Section 9.8).
The read value can then be used to determine the size
I / O list.
Variable length files are not commonly used in CVF as text files, for which a specifier is usually given
RECORDTYPE = 'STREAM_LF'.
Example:
integer recl
open (2, file = 'a.txt', recordtype = 'variable', form = 'unformatted')
! We enter 3 records into the file
write (2) 123, 555
​ ! Record length 8 bytes write (2) 'Next record'              ! Record length 11 bytes write (2) 1.4e-6              ! Record length 4 bytes
close (2)
! Closed the file to open it for formatted access
! and read the length of the second entry open (2, file = 'a.txt', recordtype = 'variable', form = 'formatted') ! The FORM = 'FORMATTED' specifier can be
omitted
read (2, '(a)')
! Go to the beginning of the
second record
read (2, '(Q)') recl
! We read the number of bytes
in record 2

print *, recl end
! eleven
10.6.4. Segmented records
Segmented records consist of one or more variables lengths of unformatted records in a sequentially organized disk file. There are no such records in FPS; in CVF
the default is unformatted data written to sequentially organized files opened for sequential access, in the form of segmented records. They are useful when working
with long records, in cases where not capabilities (due to virtual memory size limitations) or desires to form one long record. Then she breaks into
333
334
O. V. Barteniev. Modern FORTRAN
segments that form the resulting record. Each segment is a physical record and the resulting record is considered as a single logical one. The latter (in the case of a
disk file) can exceed the maximum allowable record size (2.14 * 10 9 bytes), but each segment should not be larger than this size.
Specifiers are set to access the segmented file
FORM = 'UNFORMATTED' and RECORDTYPE = 'SEGMENTED'. If they
are not specified and a previously created segmented file is opened, then working with it can be accompanied by errors. Structure segmented recording is shown
in Fig. 10.3.
Segment data
​ 2
​ 2
​ <------------------------- Segment length ---------------------- --->
Figure: 10.3. Segmented record structure
The pre-write control information contains 4 bytes.
The first two contain the segment length, the next two contain the identifier segment that takes values: • 1 for the first segment;
2 in the case of the latter;
 3 if there is one segment;
0 for all intermediate (between first and last) segments.
If the segment length is an odd number, then the user data will be incremented by 1 byte containing a space.
10.6.5. Streams
The stream is not grouped into records and does not contain a control information. Stream files are used with CARRIAGECONTROL = 'NONE' and contain
character or binary data. Transferable data chunk and file position are determined by the size of the I / O list. The flow structure is shown in Fig. 10.4.
​ Stream data
​ EOF
Figure: 10.4. Flow
10.6.6. CR streams
CR stream entries are variable length and end with carriage return, which is automatically affixed when you add writing to a file-stream and deleted when it is read.
It is this symbol and allows you to determine the length of the current record. Since CR streams end with CHAR (13), in input entries this character must absent.
The structure of the CR-stream recording is shown in Fig. 10.5.
334
335
10. Fortran files
Recording data
CR
<-------------------------- Record Length ----------
----------- ------>
1
Figure: 10.5. CR stream recording
Example:
integer recl
open (3, file = 'a.txt', recordtype = 'stream_cr')
! We enter 3 records into the file; it is opened as a text (formatted) file
! For list-driven output, the WRITE statement inserts
! a space at the beginning of each entry
write (3, *) 123, 555
​ ! Record length 24 bytes (see Section 9.9.2.2) write (3, *) 'Next record'              ! Record length 13 bytes write (3, *) 1.4e-
6              ! Record length 16 bytes backspace (3)              ! Backtracking one record
​ read (3, '(Q)') recl
​ ! Read the number of bytes in the third record
print *, recl​ ! sixteen end
 Result (composition of the a.txt file):
123 555
Next record
1.4000000E-06
10.6.7. LF streams
LF stream entries are of variable length and terminated with characters carriage returns and newlines that are auto-affixed
when adding a record and removed when reading. These symbols allow determine the length of the current record. Since LF streams terminate characters CHAR
(13) and CHAR (10), in the input records these characters should be absent. LF streams are standard text files.
The structure of the LF stream recording is shown in Fig. 10.6.
​ Recording data
​ CR
​ LF
<-------------------------- Record Length --------------------- ------>              1              1 Figure: 10.6. LF stream recording
Example:
integer recl
open (4, file = 'a.txt', recordtype = 'stream_lf')
! We enter 3 records into the file; it is opened as a text (formatted) file
write (4, '(2i5)') 123,
555
! Record length 10 bytes
write (4, '(a30)') 'Next
record'
! Record length 30 bytes
335

336
O. V. Barteniev. Modern FORTRAN
​ write (4, '(e20.8)') 1.4e-6
​ ! Record length 20 bytes
​ rewind (4) ​ ! Go to the beginning of the file
read (4, '(Q)') recl
​ ! Read the number of bytes in the third record print *, recl              ! ten end
Result (composition of the a.txt file):
123 555
Next record
0.14000000E-05
10.7. Data transfer with and without promotion
The promoted I / O operator always installs the file after the last read or written record (if there were no errors).
 No forwarding I / O operator used in formatted transmission data and specified by the specifier ADVANCE = 'NO' or (on output) descriptors \ and
$, can set the file within the current record. Using such an operator, one can read or write one record using several I / O operators, each of which will be access
part of the record, for example:
character (6) :: st1, st2 open (1,
file = 'a.txt')
write (1, *) 'Test string'
! Conclusion with promotion
rewind 1
! Go to the beginning of the file
read (1, '(a6)', advance = 'no') st1 ! Entering without progress
print *, st1
! Test
read (1, '(a6)', advance = 'no') st2 ! Putting a second word in the
same record
print *, st2
! string
10.8. File position before data transfer
The order in which the file position is set before data transfer depends on the way to access the file.
In the case of sequential access before entering , if there is a current write, file position does not change. Otherwise, the file is set to the beginning next record and
it becomes current. Input prohibited if not the next entry or the next is the "end of entry" entry. Such the situation in a sequential file will occur when the last
operator to access it is the WRITE operator.
Before outputting to a sequential file, if there is a current record, the file position does not change and the current record becomes the last record of the file.
Otherwise, for example, if the file was before record "end of file", a new record is created in which data is transmitted and which becomes the current and last
record file. The file position is set to the beginning of this recording.
336
337
10. Fortran files
With direct access, before transferring data, the file position set to the beginning of the record specified by the operator specifier I / O REC. This entry becomes
current.
10.9. File position after data transfer
When entering without progress , if there was no error situation, or situations "end of file", but there is a situation "end of record", file position is set after the record
just read. If in the operator there were no error situations, "end of file" or "end
write ", then the file position does not change. In the output statement without progress , if there was no error situation, the file position is not changes.
In all other cases, the file is installed after the last a read or written record, so that it becomes previous record.
 10.10. Binary sequential files
When working with binary files, data exchange is performed without them. transformation. When writing to binary, actually the contents of the memory cells are
copied. When reading, on the contrary, the sequence of bytes of the binary is transferred to cells
RAM allocated for input elements. FPS records in a binary file is equal to the number of bytes transferred. Therefore, the execution the BACKSPACE statement
will move back 1 byte.
A sequential binary file is a stream. Between his entries
CVF and FPS do not add characters or fields with control data.
Input from a binary file the value of the variable val occupying in
RAM n bytes, will cause the file to move by n bytes.
If the sequential binary before executing the statement output was on byte b i , then b i and all subsequent bytes as a result outputs will be "overwritten" (replaced
with output).
OPEN statement connecting file to device for binary sequential access, necessarily includes the specifier
FORM = form , where form is a character expression evaluating to a value 'BINARY'.
An example of controlling a binary sequential FPS file:
integer (2) :: ia, ib, d (5) = (/ 1, 2, 3, 4, 5 /), ireal (4) :: a
character (3) ca
338
O. V. Barteniev. Modern FORTRAN rewind 1
read (1) a, a, (ia, i = 1, 5), ca, ca
! We read 24 bytes with one READ
statement
do 2 i = 1, 10
2 backspace 1
! Move back 10 records (bytes)
read (1) ib
! We read from the 15th byte
write (*, *) a, ia, ca, ib rewind 1
! 2.200000 5bbb 4
read (1) a
! The file moved to the 5th byte
write (1) 'ghi'
! Replaced 5th, 6th and 7th bytes;
rewind 1 read (1) a, ca
! all subsequent records are "erased"

write (*, *) a, ca end
! 1.100000ghi (7 bytes of data in the file)
 open (1, file = 'a.dat', form = 'binary')! Opening the binary
write (1) 1.1, 2.2
! We write 8 bytes to the file
write (1) d
! Add 10 bytes to the file
write (1) 'aaa', 'bbb', 'ccc'
! Add 9 more bytes to the
file
337
Notes:
In CVF, when working with binaries, the BACSPACE statement is eitherraises a runtime error, or, like the REWIND statement, positions the file to the beginning,
for example:
character (1) c
open (1, file = 'a.dat', form = 'binary')! Opening the binary
write (1) 'a12', 'b34'
! Add 6 bytes to the file
rewind 1 read (1) c
! Go to the beginning of the
file
print *, 'c =', c
! CVF: c = a
! FPS: c = a
rewind 1
! Go to the beginning of the
file
! The same steps, but with the BACKSPACE statement
write (1) 'a12', 'b34' backspace 1
read (1) c
! Add 6 bytes to
the file
print *, 'c =', c
! CVF: c = a
​ end
​ ! FPS: c = 4
Any external file can be opened as binary (stream),for example to copy data.
10.11. Unformatted sequential files
In unformatted files, as well as in binary files, data is transferred without transformations. However, in a non-formatted file, unlike a binary the record is not a byte,
but a collection of data output to a file in the result of executing the output statement WRITE. Each output statement creates one record. File records can be of
different lengths. Each recording ends with end-of-recording characters.
From an unformatted file, one input operator can read only one entry. An attempt to enter the number of bytes exceeding
 338
339
10. Fortran files
the size of the current record, will result in a runtime error and interruption programs.
Execution of every input statement, even if the number of bytes entered less than the number of bytes of record, will lead to positioning of the file after behind the
read entry.
Adding a new entry when positioning the file after entry r i - 1 will delete entry r i and all subsequent entries (to replace them with the added one).
OPEN statement connecting a file to a device for unformatted sequential access, includes the FORM = specifier form , where form is a character expression
evaluated with the value 'UN-
FORMATTED '.
An example of managing a non-formatted sequential file:
integer (2) :: ia, ib, d (4) = (/ 1, 2, 3, 4 /) real (4) a
​ character (3) ca
​ ! Opening an unformatted file
open (1, file = 'a.dat', form = 'unformatted')
write (1) 1.1, 2.2
! Adding the 1st record
to the file
write (1) d
! Second entry
write (1) 'aaa', 'bbb', 'ccc'
! Third entry
10.12. Text sequential files
The text file contains a symbolic representation of the data of all types. When working with text files, formatted or driven by I / O list. When outputting data from
internal representations are converted to external symbolic representation. When you type , the inverse conversion from the character internal representation
(Section 9.1).
rewind 1
! Go to the beginning of the file
read (1) a, a
! 
We 
keep 
the 
correspondence
between
read (1) ia, ia, ia, ia read (1) ca, ca
! input and output
backspace 1
! Go to the beginning of the 3rd record
backspace 1
read (1) ib, ib
! Go to the beginning of the 2nd record
print *, a, ia, ca, ib rewind 1
! 2.200000 4bbb 2
read (1) a
! Go to the beginning of the 2nd record
write (1) 'ghi' rewind 1
! Replacing 2nd and 3rd entries with ghi
read (1) a, a
! There are 2 entries left in the file:
read (1) ca
! numbers 1.1 and 2.2 and string ghi
print *, a, ca
end
! 2.200000ghi
 339

340
O. V. Barteniev. Modern FORTRAN
When the output at the end of each Fortran record affix two non-displayable characters CHAR (13) - carriage return and CHAR (10) - new line,. That is, the
records are LF streams. In case of withdrawal under list control inserts an output statement at the beginning of each record space (by default the first character of
each format file entry treated as a carriage control character). Text recording sequential file can have different lengths.
The order of changing the position of a text file with sequential access depends on the data transfer method (with or without promotion, sect. 10.6).
With formatted input, the number of readable one operator input from
the current data record is regulated by the format (Section 9.4). of an unformatted file, one input operator, in principle, can be              Unlike read an arbitrary
number of records of a text sequential file.
In the simplest case, opening a text file for sequential formatted access, you can specify only the device in the OPEN statement external file and specifier FILE =
file .
An example of managing a text sequential file. (By default in files opened for sequential access, specifier FORM = 'FORMATTED'.):
integer (2) :: ia, ib, d (4) = (/ 1, 2, 3, 4 /) real (4) a, b character (3) ca 1 format (6f7.2)
format (8i5)
format (7a4)
! Open a sequential text file a.txt and create 3 records in it open (10, file = 'a.txt')
write (10, 1) 1.1, 2.2
​ ! Entry 1 write (10, 2) d              ! 2
​ write (10, 3) 'a', 'bc', 'def'
​ ! and 3
! After executing three output statements, the file will contain 3 entries:
! 1.10 2.20
! 1 2 3 4
! a bc def
rewind 10 read (10, 1) a, b
! Go to 1st record
read (10, 2) ia, ia, ia
! Reading from the
2nd entry
341
10. Fortran files
read (10, *)
! Go to the beginning of the 2nd record
write (10, 3) 'ghij'
! All entries starting from the 2nd are replaced with
ghij
 ! or instead of the last two operators: read (1, *) a, b, ia, ia, ia
read (10, 3) ca, ca
! Reading from the 3rd record
backspace 10
! Go to the beginning of the 3rd
record
backspace 10
! Go to the beginning of the 2nd
record
read (10, 2) ib, ib
! We read in ib the 2nd element of
the 2nd record
write (*, *) a, ia, ca, ib
! 1.100000 3 bc 2
rewind 10
! Go to the beginning of the 1st
record
340
! After executing the last three operators, we have a file:
! 1.10 2.20
! ghij end
10.13. Files linked for direct access
For direct access, you can open binary, unformatted and formatted (text) files. In a file linked for direct
access, all records have the same length, specified when opening file with the RECL specifier. Moreover, in the case of an informal and text files the number of
bytes transmitted by one I / O operator is not must exceed the record length. In case of output, missing bytes records will contain null characters.
It is not necessary to read or write records in numerical order.
Any record can be added to the file connected to the device.
For example, you can write record 3 even if there are no records in the file with
numbers 1 and 2. In this case, however, between the beginning of the file and record 3 there will be space reserved for entries 1 and 2:
open (1, file = 'a.txt', form = 'formatted', access = 'direct', recl = 7, status = 'new') write (1, '(i7)', rec = 3) 12              ! Add record 3
It is forbidden to transfer records using formatting under the control of a list (named and unnamed).
Direct access file can be positioned directly following the entry r i by executing the READ statement in which specifier REC = r i . The entry list for such an
operator may be empty.
Positioning after writing r i in unformatted or binary file: read (2, rec = ri) and in the format file: read (2, '(a)', rec = ri) ! Format descriptor - any
In CVF, you can also use
FIND statement (Section 11.8).
In a directly accessible file, the WRITE statement will the record number specified by the operator REC specifier has been updated WRITE. In FPS, if the REC
specifier in the WRITE statement is missing, then the current record is updated. All subsequent file entries will be saved. If the record specified by the REC
specifier does not exist, then it will be added to the file.
341
342
O. V. Barteniev. Modern FORTRAN
Comment. When working with direct files, the REC specifier can absent only in FPS; for CVF it is required.
In FPS, to remove unnecessary trailing direct file entries, you should move after the last saved record (this
usually done with a READ statement) and then apply the statement
ENDFILE. This method is not applicable in CVF, because it contains ENDFILE only works with sequential files.

OPEN statement connecting file for unformatted direct device access u , must have specifiers:
OPEN ( u , FILE = file , ACCESS = 'direct', RECL = recl ) where recl is an integer expression that returns the length of the file record.
FORM specifier = 'UNFORMATTED' in case of direct file is the default and can be omitted. In the case of formatted and direct access binary FORM specifier is
compulsory:
OPEN ( u , FILE = file , ACCESS = 'direct', FORM = 'formatted', RECL = recl )
OPEN ( u , FILE = file , ACCESS = 'direct', FORM = 'binary', RECL = recl )
 An example for FPS. In a straight a.dat file containing 30 entries, delete records with a number greater than 15.
character (30) :: fn = 'a.dat' character (35) :: st = 'One line' integer :: ios, r = 15, ner, i
! First, let's create a file of 30 records
open (1, file = fn, access = 'direct', form = 'formatted', recl = 35)
​ endfile 1
​ ! In case the file exists
! Install the file before the just added end of file entry rewind 1
write (1, '(a35)') (st, i = 1, 30)
​ ! Now there are 30 entries in the file close (1)
​ open (2, file = fn, access = 'direct', form = 'formatted',              &
recl = 35, status = 'old', iostat = ios)
if (ios .ne. 0) stop 'Cannot open file a.dat'
read (2, '(a)', rec = r, iostat = ios) ​ ! Skip to start of recording 16 if (ios .eq. 0) then
! If we managed to read record r , then we put a mark at the end of the file
​ endfile 2
​ ! In CVF, the ENDFILE operator is used
else
​ ! with sequential files only write (*, *) 'I cannot read the record', r
end if
inquire (2, nextrec = ner)
​ ! ner - next record number print *, ner              ! sixteen rewind 2              ! Execute checkout output
k = 0
342
343
10. Fortran files
do while (.not. eof (2))
k = k + 1
read (2, '(a)', rec = k) st
! Readable record
number
print *, st, k end do end
! Displayed 15
records
Notes:
The code is unacceptable for CVF because the ENDFILE operator is applicable in itonly with files open for sequential access.
When working in CVF with direct access files used inexample cyclic list
write (1, '(a35)') (st, i = 1, 30)
not applicable because in CVF, when writing to a direct file, the WRITE statement must contain the REC specifier. Therefore, the loop is used
do i = 1, 30​ ! Loop is acceptable in both FPS and CVF write (1, '(a35)', rec = i) st end do
 In a file with direct access, CVF, unlike FPS, does not adda newline character after each direct file write. This difference illustrated by example:
character (30) :: fn = 'a.dat' character (8) :: st = 'A record' open (1, file = fn, access = 'direct', form = 'formatted', recl = 9, status = 'new') write (1, '(a8)', rec = 1)
st write (1, '(a8)', rec = 2) st write (1, '(a8)', rec = 3) st
end
The a.dat file contains:
CVF: A record A record A record
FPS: A record A record
A record
To install a direct file following the r entry , you can use a READ statement without an input list: READ (2, '(A)', REC = r ), and in CVF also FIND statement, for
example: FIND (2 ' r ).
When working with text direct files, only formattedI / O. List-driven data transfers are invalid. Also I / O is impossible without advancement.
343
344
O. V. Barteniev. Modern FORTRAN
A file with records transferred to it in direct access mode can be subsequently open as sequential binary (like a stream).
An example . In a file opened for direct access with RECL = 15,
3 entries. The same file is then opened as binary for
 sequential access and data are transferred byte by byte to formatted b.txt file. B.txt file is output after linking it with RECL = 15.
integer (4), parameter :: n = 15 character (1) c character (n) st
integer i
100 format (a <n>)
​ ! or: 100 format (a15)
open (1, file = 'a.txt', access = 'direct', form = 'formatted',
organization = 'relative', recl = n)
! Create 3 records in a direct file write (1, 100, rec = 1) 'First
record' write (1, 100, rec = 2) 'Second record' write (1, 100, rec =
3) 'Last record'
close (1)
​ ! Close the file a.txt
! Source file open (1, file = 'a.txt', form = 'binary')
! Destination file
open (2, file = 'b.txt', form = 'formatted', recordtype = 'fixed', recl
= 1)
&

do while (.not. eof (1)) ​ ! We copy the data character by character
read (1) c              ! Read 1 byte from source
write (2, '(a)') c
​ ! We write 1 byte to the receiver end do close
(1); close (2)              ! Detaching files a.txt and b.txt
! Now open b.txt with RECL = n and read 3 records
open (2, file = 'b.txt', access = 'direct', form = 'formatted', recl = n)
i = 0 ​ ! Readable record number
do while (.not. eof (2)) ​ ! We copy the data character by character
i = i + 1
read (2, 100, rec = i) st
print *, st
​ !
​ First record
end do
​ ! Second record
end
​ !
​ Last record
Differences Between Plain and Direct Binary Files:
any number of bytes can be written to a binary file without reversingattention to the meaning of the RECL specifier (however, the length records are still defined by
the RECL specifier);
more than one input operator can be read from a binary filebytes than specified by the RECL specifier.
344
345
10. Fortran files
The same binary or unformatted file can be opened with different values  of the RECL specifier.
Example:
character (14) ch integer ner open (2, file = 'a.bin', access = 'direct', form = 'binary', recl = 8) write (2, rec = 1) 'C12-', '92'! We write 8 bytes to the file write (2,
rec = 2) 'C16-', '99'! Second binary file entry
! Read 14 bytes from a binary file, i.e. more than specified by RECL read (2, rec = 1) ch inquire (2, nextrec = ner)
print *, ner
! 3
write (*, *) ch
! C12-92 C16-99
end
! Read 14 bytes from an
unformatted file,
! opened with RECL = 8,
you cannot
The given text in FPS may look like this:
 character (14) ch integer ner
open (2, file = 'a.bin', access = 'direct', form = 'binary', recl = 8)
write (2) 'C12-', '92'
! We write 8 bytes to the
file
write (2) 'C16-', '99' rewind
2
! Second binary file entry
read (2) ch inquire (2, nextrec
= ner)
! Reading 14 bytes from a
binary file
print *, ner
! 3
write (*, *) ch end
! C12-92 C16-99
This code is not applicable in CVF because, first, the I / O operators do not contain the REC specifier, and secondly, the REWIND operator is used, which in
CVF is used only with sequential files.
In FPS, a text direct file has the same structure as a text file sequential file in which all records are the same length.
Therefore, a text file with records of equal length can be opened in FPS for both direct and sequential access.
An example . In a text file connected for direct access, each record has a "Last Name, First Name" field. By mistake in some surname begins with a lowercase
letter. Fix a bug in
source file and generate a report as a binary file, containing corrected entries.
integer (4), parameter :: n = 15 type person
character (len = n) lastn, firstn end type person
 345
346
O. V. Barteniev. Modern FORTRAN
type (person) line
integer (4) :: code, dco, cco, ut = 2, ub = 3, ir
100 format (2a15)
open (ut, file = 'a.txt', form = 'formatted', access = 'direct', recl = 2 * n) open (ub, file = 'b.dat', form = 'binary')
! Let's create two records ! Recording without error write (ut, fmt = 100, rec = 1) person ('Blake', 'William')
! Error entry
write (ut, fmt = 100, rec = 2) person ('maugham', 'W. Somerset')
code = ichar ('Z')
! 90 - ASCII code of
character Z
dco = ichar ('z') - code ir = 0
do
! Returns dco = 32
ir = ir + 1
! Current record number
in direct file
read (ut, fmt = 100, rec = ir) line

! or: read (ut, '(3a)', rec =
ir) line
cco = ichar (line.lastn (1: 1)) if (cco> code) then              ! If the first letter of the last name is lowercase, then: line.lastn (1: 1) = char (cco - dco)! • translate a
lowercase letter to uppercase; write (ut, fmt = 100, rec = ir) line! • we fix the error in the source file;
write (ub) line end if
! • writing to a binary file
if (eof (ut)) exit end do
! If the situation is "end of
file"
close (ut)
! Close the direct file
rewind ub do while (.not.
eof (ub))
read (ub) line write (*, *)
line
end do close (ub)
! Test output
end
Result. A.txt file after fixes (CVF case; in FPS case each entry is placed on a separate line):
​ Blake​ William
​ Maugham ​ W. Somerset
Explanation. Lowercase letters in ASCII table appear after uppercase. To get the ASCII code of a capital letter from a known it is enough for the lowercase code
to subtract the lowercase letter dco from the code :
dco = ichar ('z') - ichar ('Z').
10.14. Deleting Records from a Direct Access File
The information given in this section is only applicable in FPS, because
in the discussed mechanism present operator ENDFILE, unused in CVF with direct files.
 346
347
10. Fortran files
Method to remove trailing recordings from direct access FPS file was covered in the previous section.
You can delete unnecessary intermediate entries by using the method adopted in database management systems.
First, it is necessary to be able to mark deleted records (and also remove this mark). For this purpose, the entry can be select a separate, single-byte field by
putting 1 (.TRUE.) into it, if the entry is to be deleted, or 0 (.FALSE.) if not. Further it will be necessary to write a procedure that can work, for example,
according to the following algorithm:
exchange marked for deletion records with records that havelargest numbers;
install the file before the first record marked for deletion andexecute the ENDFILE statement.
The launch of such a procedure should be performed as needed, keeping in mind that deleted records cannot be recovered.
10.15. File type selection
Binary and unformatted files have obvious advantages over
text:
data transfer is faster because there is no loss ofdata transformation;
in text files, due to rounding, losses may occuraccuracy;
programming binary and non-formatted I / O is much easier,than formatted;
binary and non-formatted files are usually smaller,than text files with the same data.
Let us illustrate the last circumstance with an example:
real (4) :: a (20) = 1255.55 open (1, file = 'a.txt')
​ write (1, '(5f8.2)') a
​ ! Text file size 168 bytes
open (2, file = 'a.dat', form = 'binary')
write (2) a ​ ! Binary file size 80 bytes end
The program creates two files. In a text file a.txt for data
160 bytes are used and an additional 8 bytes (2 * 4) will take the end characters records. A total of 4 records will be created in the a.txt file, each record will be
contain 5 fields of 8 characters each. Size of a.dat binary file will be 80 bytes: in total, 20 elements of 4 bytes will be output to the file each. That is, in the case of a
binary file, we have significant savings external memory.
 347
348
O. V. Barteniev. Modern FORTRAN
Text files contain data in readable form and also used to exchange data between programs,
working in various operating systems. An example of this kind exchange files are DXF files of the AutoCAD program.
Selecting a file access method (sequential or direct) is determined by the nature of the tasks being solved. If you need to edit file records, or index a file by one or
more fields
records, or make certain records of a file inaccessible to others processes, then direct access files are used.
 348
349
11. Operations on external files
An external file is accessible from the program if it is firstly opened and, secondly, it is not blocked by another process. The file opens in by connecting it to an I /
O device, which, in turn, created (opened) by the OPEN operator. It is equally possible talk about connecting the device to the file. Between device u and file file
exists-one correspondence: all operators Fortran in any software unit referencing device u get access to file file . The device can be connected as existing and
newly created file. Can't connect one the same file to different devices at the same time, just like you can't connect one device to different files at the same time.
After the file is open, operations are possible with it:
positioning (BACKSPACE, REWIND, ENDFILE, READ, WRITE);
data transmission (READ, WRITE, PRINT and ENDFILE);
change of connection properties (OPEN operator);
polling (INQUIRE and EOF).

The file is closed as a result of the CLOSE statement, or when the program ends normally.
File Controllers and Operators Polling Them are listed in table. 11.1. Detailed descriptions are given in the following sections.
Table 11.1. Operators used when working with files
​ Operator
​ Appointment
Operators , applicable in CVF and FPS BACKSPACE Returns the file one record back
REWIND
Positions the file to the beginning of its first
record
ENDFILE
Writes a special end-of-file entry
OPEN
Creates an I / O device and connects an
external file to it
CLOSE
Detaches a file from an I / O device and
closes that device
READ
Transfers data from a file connected to the
device
I / O to the variables specified in the input
list
WRITE
Passes data from the output list to a file
connected to
I / O device
PRINT
Displays data on the screen (device *)
INQUIRE
Returns the properties of a device or
external file
349
350
O. V. Barteniev. Modern FORTRAN
Function
EOF
Returns .TRUE. If the attached I / O file is
positioned on the end-of-file special entry or
after this entry. Otherwise EOF returns
.FALSE.
Operators , applicable in CVF
ACCEPT
Performs formatted data input or controlled
input keyboard list
TYPE
Synonym for PRINT; all rules for PRINT
carry over to TYPE
REWRITE
Replaces the current record with a new one in
direct access files
FIND
Positions a direct file to the specified entry
DELETE
Removes the specified linked file entry
UNLOCK
Releases a file entry closed for access by a
previous with the READ statement
 The above operators (except PRINT), as well as the EOF function, contain in as one of the specifiers the device to which it is connected file as a
result of the OPEN statement. This specifier is compulsory. At the same time, each of the operators working with files has the optional specifiers discussed in this
chapter.
The expediency of their use is defined as the tasks to be solved, and the requirements for the reliability of the software product.
When describing operators, their optional elements are enclosed in square brackets. Symbol | used to mean "or".
Comment. In CVF, the BACKSPACE, REWIND and ENDFILE statements used only with files opened for sequential access, that is, as provided for by the
Fortran standard. In FPS, these operators can also be used with direct access files.
11.1. BACKSPACE statement
The operator returns the file one record back and has two forms:
BACKSPACE u and
BACKSPACE ([UNIT =] u [, ERR = err ] [, IOSTAT = iostat ]) u - external file device (Section 10.2).
err is the label of the statement being executed. When an I / O error occurs
control is transferred to the operator labeled err .
iostat is an integer variable that takes a value of 0 when
no errors. Otherwise, iostat is equal to the error number.
If there is no connection, an execution error will occur.
350
351
11. Operations on external files
The BACKSPACE statement positions the file exactly one record back, except for those given in table. 11.2 cases.
Table 11.2. Special cases of file positioning by the operator
BACKSPACE
Happening
Result
No prior entry
File position does not change
Previous entry end of file
The file is positioned before
writing "end file "
The file is within one records
The file moves to the beginning
of this entry.

In FPS on files containing output executed under control named list, BACKSPACE treats the list as a set records, the number of which is equal to the number of
elements in the list plus two records: one is the heading of the list, the other is a trailing slash (/).
Example:
 integer :: lunit = 10, ios backspace 5 backspace (5) backspace lunit
backspace (unit = lunit, err = 30, iostat = ios)
Notes:
In CVF, the BACKSPACE operator is used only with files,connected for serial access. In addition, he does not used with list-driven entries like named and
without a name.
If the UNIT = specifier is omitted, then the u parameter must be the first operator parameter. Otherwise, parameters may appear in no particular order. This
remark is true for all cited in this chapter, operators that have the UNIT = specifier.
If the operator parameter is an expression that containsfunction call, this function should not execute I / O or function
EOF. Otherwise, the results are unpredictable. This remark applies to all operators in this chapter.
11.2. REWIND operator
The operator moves the file to the beginning of the first record in the file.
REWIND u
or
351
352
O. V. Barteniev. Modern FORTRAN
REWIND ([UNIT =] u [, ERR = err ] [, IOSTAT = iostat ])
For a description of the u , err, and iostat parameters , see Sect. 11.1.
If not connected, the REWIND statement does not call any action.
Comment. In CVF, the REWIND operator is used only with files, connected for serial access.
11.3. ENDFILE statement
The operator writes a special end-of-file record.
ENDFILE u
or
ENDFILE ([UNIT =] u [, ERR = err ] [, IOSTAT = iostat ])
For a description of the u , err, and iostat parameters , see Sect. 11.1.
If the file is not open, then a runtime error occurs.
After recording "end of file", the file is positioned after behind this entry. Further serial data transmission will become possible only after executing BACKSPACE
or RE-
 WIND. After executing the ENDFILE statement, all records located after a new entry, "end of file" becomes inaccessible. In FPS it is true for both
sequential files and direct files.
For obvious reasons, ENDFILE cannot be used with files open with ACTION | MODE = 'READ'.
Comment. In CVF, the ENDFILE operator is used only with files, connected for serial access.
11.4. OPEN operator
The OPEN statement creates I / O device u and connects to it the external file file . On successful connection, the file is considered open and can be accessed by
other workers with Fortran operator files. The operator can be used for linking a previously opened file to change properties connections. Operator specifiers
marked with an asterisk can apply only to CVF.
OPEN ([UNIT =] u [, ACCESS = access ] [, ACTION = action ]
&
[, ASSOCIATEVARIABLE = asv *] [, BLANK = blank ]
&
[, BLOCKSIZE = blocksize ] [, BUFFERCOUNT = bc *]
&
[, BUFFERD = bf *] [, CARRIAGECONTROL = carriagecontrol ]
[, CONVERT = fm *] [, DEFAULTFILE = def *] [, DELIM = delim ]
&
[, DISPOSE = dis *] [, ERR = err ] [, FILE = file ] [, FORM = form ]
&
352
353
11. Operations on external files
[, IOFOCUS = iofocus ] [, IOSTAT = iostat ] [, MAXREC = mr *]
&
[, MODE = mode ] [, ORGANIZATION = org *] [, PAD = pad ]
&
[, POSITION = position ] [, READONLY *] [, RECL = recl ]
&
[, RECORDTYPE = rtyp *] [, SHARE = share ] [, SHARED *]
&
[, STATUS = status ] [, TITLE = title ] [, USEROPEN = user-
function-name *])
&
u - external file device (Section 10.2) to which the file file .
access - a character expression evaluated with the values  'APPEND',
'DIRECT' or 'SEQUENTIAL' (default) and specifying the way file access (sequential - 'SEQUENTIAL' or direct -
'DIRECT'). The ACCESS = 'APPEND' specifier is used when working with sequential files opened to add data. When
successful execution of the OPEN statement with ACCESS = 'APPEND' file positioned before the end of file entry.
 action is a symbolic expression specifying possible actions with
file and computed with the values  'READ' (the process can only read data from file), 'WRITE' (only data output is possible) or 'READ-
WRITE '(you can read and write data).
If the ACTION specifier is not specified, then the system tries to open read-write file ('READWRITE'). If the attempt is unsuccessful, then the system tries to
open the file again initially read-only ('READ'), then write-only ('WRITE').
The value of the STATUS specifier has no effect on action . asv is an integer variable of the standard integer type called
associated file variable ; updated after every transmission

data when working with direct files and contains the number of the next file recording. Only effective in CVF with READ, WRITE, FIND, DELETE and
REWRITE. For instance:
integer (4) asv
​ ! Associated file variable character (8) :: st = 'A record'
! Let's create a straight file with three records
​ open (1, file = 'c.dat', access = 'direct', form = 'formatted', recl = 9,              &
status = 'new', associatevariable = asv)
write (1, '(a8)', rec = 1) st; write (1, '(a8)', rec = 2) st; write (1, '(a8)', rec = 3) st
​ print *, asv ​ ! 4
read (1, '(a8)', rec = 1) st
​ print *, asv ​ ! 2
blank is a character expression evaluated with the values  'NULL' or
'ZERO'. In case of 'NULL' (set by default) spaces on formatted data entry are ignored (enacted descriptor BN). In case of 'ZERO' spaces in formatted data entry
treated as zeros (BZ descriptor in effect). but
 353
354
O. V. Barteniev. Modern FORTRAN
if both the blank parameter of the OPEN statement and the descriptors are specified BN or BZ in the format specification of the I / O operator, then the format
descriptor overrides the blank parameter .
blocksize is a standard integer type expression specifying the size
internal buffer in bytes.
bc - scalar integer expression specifying the number of buffers,
associated with an I / O device in multi-buffer data transmission. The return value of the expression must be in the range from 1 to 127. One buffer is enabled by
default. Specifier
BLOCKSIZE specifies the size of one buffer. The total number of bytes associated with the given buffers, if, for example, BLOCKSIZE = 2048 and
BUFFERCOUNT = 3, equals 3 * 2048 = 6144. bf is a character expression evaluated with the value 'YES' or 'NO',
determining the nature of data transfer. If bf returns 'NO' then data will be sent to the file after each statement execution WRITE. Otherwise, the data, if the
physical device and file type are pre-accumulated in the internal buffer, which can improve application performance. By
The default buffer size is 8192 bytes, and in the case of FPS, 1024 bytes. General the size of the buffer can be changed by the BLOCKSIZE specifiers and
BUFFERCOUNT. The internal buffer can be increased to place the entire record, and never shrinks.
carriagecontrol
​ - a symbolic expression specifying the way interpretation of the first character of each record in format files.
The expression can be evaluated with the values  'FORTRAN' or 'LIST'. By By default, the u device is connected to an external device, for example to a printer
or monitor, with carriagecontrol = 'FORTRAN'. It means that the first character of the entry is interpreted as a carriage control character printing device and is not
displayed either on the printer or on the screen (Sect.
9.1). External files are connected by default with carriagecontrol = = 'LIST'.
In the case of 'LIST', the first character of the entry is no longer interpreted as the carriage control character is displayed both on the printer and on the screen. If
OPEN also specifies FORM = 'UNFORMATTED' or
FORM = 'BINARY' then the CARRIAGECONTROL specifier is ignored. fm - scalar symbolic expression specifying the kind of representation
numerical unformatted data and calculated with the value 'LITTLE ENDIAN ',' BIG ENDIAN ',' CRAY ',' FDX ',' FGX ',' IBM ',' VAXD ',' VAXG 'or
'NATIVE'. Used to bring data to the appropriate form.
def - a scalar symbolic expression specifying the used
the default is the path to the file being opened. If the trailing slash (/) omitted, it will be added. If the DEFAULTFILE specifier missing, the current working
directory is used.
 354
355
11. Operations on external files
delim is a scalar symbolic expression that specifies the delimiter for
character data at I / O under the control of a named or unnamed list. Expression can be evaluated with values 'APOSTROPHE', 'QUOTE' or 'NONE' (default).
If the limiter is given, then the internal characters of the string that match the delimiter (apostrophe (') or quotation marks (")) are doubled (Section 9.9.1.2). dis -
scalar symbolic expression specifying the status of the file after it
disconnecting from the device. Takes one of the following values:
'KEEP' or 'SAVE' - the file is saved;
'DELETE' - the file is being deleted;
'PRINT' - the file is printed and saved (only forsequential files);
'PRINT / DELETE' - file is printed and deleted (only forsequential files);
'SUBMIT' - splits the process to execute the file;
'SUBMIT / DELETE' - splits the process to execute the file andremoves it after completing operations.
The default is 'DELETE' for scratch files and 'KEEP'
for everyone else. err is the label of the statement being executed. The second form of the specifier is DISP = When an error occursdis . control is transferred to
the operator labeled err .
file - a symbolic expression specifying the name of the file to link
to device number u . If the FILE specifier is not specified, then a temporary, erased after the CLOSE statement or after normal program termination file. In this
case, the a STATUS specifier with a SCRATCH value, for example:
open (1, status = 'scratch', form = 'bynary')
If the file parameter is evaluated with a space value , then the following actions:
the program reads the filename from the list of arguments (if anyavailable) on the command line that starts the program. If the argument is a null string (''), then the
filename will be prompted enter the user. Each subsequent OPEN statement that has space as filename, reads the corresponding argument command line;
if OPEN statements with a space as a file name,more than command line arguments, the program will ask you to enter missing filenames.
If the filename is 'USER' or 'CON', then the output is done to the screen, input - from the keyboard. The file name can refer to other physical devices as well, e.g.
printer (FILE = 'PRN') or first serial port
 355

356
O. V. Barteniev. Modern FORTRAN
(FILE = = 'COM1'). In QuickWin applications, setting FILE = 'USER' allows you to open a child window. Then all I / O operations associated with the device to
which this window is connected are executed on this window.
form is a character expression evaluated with the values' FORMATTED ',' UNFORMATTED 'or' BINARY '. If file access
​ consistent, ​ then ​ by
​ default              is established              the form
'FORMATTED'. If access is direct, then the default is form 'UNFORMATTED'.
iofocus - boolean expression, if true, the child
the QuickWin application window is focused (located on top of other windows) when executing READ, WRITE, and PRINT statements.
It is an extension over the Fortran 90 standard.
iostat is an integer variable that returns 0 if absent
errors, a negative number if an end-of-file situation occurred, or the number of the error that occurred.
mr - scalar expression specifying the maximum number of records,
which can be transferred when working with a direct file during its connection to the device. Converts to whole type. By default, the number of transferred records
is not limited.
mode is a symbolic expression that specifies, like action, possible
file action and computed with 'READ' values  (the process can only read data from file), 'WRITE' (only data output is possible to file) or 'READWRITE' (both
data input and output are possible).
It is an extension over the Fortran standard.
org is a scalar symbolic expression specifying an internal
file organization, computed with the value 'SEQUENTIAL' if a file with a sequential organization is specified (by default), or 'RELATIVE' if a file with a related
organization is specified.
pad is a character expression evaluated with the values  'YES'
(default) or 'NO'. In case of 'YES' if in formatted input more data is required than is contained in the record, then the missing number data is filled in with spaces. If
PAD = 'NO', then when trying formatted input of more data than is contained in the record, an input error occurs. For instance:
character (20) :: st
open (1, file = 'a.txt', pad = 'yes')
read (1, '(a)') st
​ ! We read from a file and display print *, st              ! abcd
​ read *
​ ! We are waiting for pressing Enter
! Change the connection property of the PAD file a.txt open (1, file = 'a.txt', pad = 'no')! Default POSITION = 'ASIS'
​ read (1, '(a)') st
​ ! An input error occurs
A.txt file :
 356
357
11. Operations on external files
abcd efgh
position - a character expression specifying the positioning method
file with sequential access and which should be calculated with the values  'ASIS', 'REWIND' or 'APPEND'. If there is
'REWIND' then the existing file is positioned at the beginning of the file.
In case of 'APPEND' the existing file is positioned directly before writing "end of file". In case of 'ASIS' (set by default) the position of the previously linked file
does not change, while the previously the unconnected file is positioned at its origin.
READONLY - as with ACTION = 'READ', the file connects read-only. However, READONLY prevents deleting a file if the STATUS = 'DELETE' specifier is
present. recl is an integer expression that specifies the length of each record in
bytes. This parameter is specified only in direct access files.
rtyp - scalar symbolic expression specifying the type of file entries
and calculated with one of the following values  (see also Section 10.5):
'FIXED' - records of fixed length;
'VARIABLE' - records of variable length;
'SEGMENTED' - segmented records;
'STREAM' - stream;
'STREAM_LF' - LF_stream;
'STREAM_CR' - CR_stream.
When connecting a file, the defaults apply:
'FIXED' - for linked files and files with sequentialan organization open for direct access;
'STREAM_LF' - for formatted files with sequential organization;
'VARIABLE' - for non-formatted files with sequential organization.
share - a character expression evaluated with the values  'DENYRW',
'DENYWR', 'DENYRD' or 'DENYNONE':
'DENYRW' - (deny-read / write mode) while the file is open in this mode,no other process can open this file for reading, not for recording;
'DENYWR' - (deny-write mode) while the file is open in this mode,no other process can open this file for writing;
'DENYRD' - (deny-read mode) while the file is open in this mode, noanother process cannot open this file for reading;
'DENYNONE' - (deny-none mode) while the file is open in this mode,any other process can open this file for reading, so and for the record.
357
358
O. V. Barteniev. Modern FORTRAN
SHARED - the attached file is opened for a split access in which more than one application can access the file. status is a symbolic expression that can take on
values
'OLD', 'NEW', 'SCRATCH', 'REPLACE' or 'UNKNOWN':
'OLD' - the file must already exist, otherwise there will be
I / O error;

'NEW' - the file should not exist. If it does not exist, then it will be created, otherwise an I / O error will occur;
'SCRATCH' - if the file parameter is omitted in the OPEN statement , then by the default status is 'SCRATCH'. Created by 'SCRATCH'files are temporary and
are destroyed either on closing devices, or at the end of the program;
'REPLACE' - the opened file replaces the existing file with the samename. If no such file exists, a new file is created;
'UNKNOWN' (default) - the process first tries to open the filewith the 'OLD' status, then with the 'NEW' status. If the file exists, then it opens, if not, it is created.
The status value affects only disk files and is ignored when work with devices.
 Example:
character (70) fn write (*, '(a \)') 'Enter file name:' read (*, '(a)') fn
! Opening an unformatted new direct access file
! File fn should be absent on the disc open (7, file = fn, access = 'direct', status = 'new')
Attaching a file to a device asterisk (*) has no actions as this device is permanently associated with the keyboard and screen. However, you can link an external
file to existing by default to devices 0, 5 and 6.
If the OPEN statement uses a device connected previously to another file, then the previously opened file is automatically closes and then another file opens and
connects to the device specified by the u parameter . Cannot be connected at the same time the same file to different devices.
If the file is not open and a READ or WRITE statement is executed, then the program will try to open the file as the OPEN statement does, in which the parameter
FILE = '' is specified.
If the OPEN operator connects the device to a non-existent file, then the file is opened with the properties specified in the statement.
You can use the OPEN operator by specifying a name already attached file with the same device to change properties
358
359
11. Operations on external files
connections specified by the specifiers BLANK, DELIM, PAD, ERR and IOSTAT. In such cases, the POSITION = 'APPEND' specifier is ignored, but the
POSITION = 'REWIND' specifier causes a move to the beginning file.
Example:
integer (4) :: k open (7, file = 'a.txt', blank = 'zero') write (7, '(2i3)') 1, 2 rewind 7
​ read (7, '(i6)') k
​ ! Returns 1002
! Changing the BLANK connection property of the a.txt file open (7, file = 'a.txt', blank = 'null') rewind 7
read (7, '(i6)') k ! Returns 12 end title is a character expression that specifies the name of the child QuickWin window. If the TITLE qualifier is specified in an
application that is not QuickWin, then a runtime error will occur.
 USEROPEN = function name is a specifier that allows you to pass control of external function function name , directly opening the file. The called
function must have the EXTER- attribute
NAL, open the file using the CreateFile function, and return file descriptor generated by CreateFile; used when needed set connection properties not provided by
the OPEN operator.
The main purpose of the qualifier is to use the capabilities of WIN32
API of the CreateFile function, located, by the way, in the kernel32.lib library.
An example . The given code can be used to call a given the USEROPEN function specifier. When executing the OPEN statement the control is passed to the
fileopen function , which calls the Cre-
ateFile. The data required for CreateFile to work is collected in the MTY module, the CreateFile interface is located in fileopen .
character (30) :: st, fn integer (4), external :: fileopen
​ fn = 'a.dat'c
​ ! SI-line terminated null -symbol
open (1, file = 'a.dat', status = 'old', useropen = fileopen, err = 10) write (1, *) 'Test string'
rewind 1
read (1, '(a)') st
! Go to the beginning
of the file
print *, st
! Test string
stop 'OK'
10 print *, 'Error' end
! 
File 
successfully
opened
359
360
O. V. Barteniev. Modern FORTRAN
​ module mty ! Instead of the DFWINTY module
! The file_flag_write_through constant is taken from the dfwinty.f90 file integer, parameter :: file_flag_write_through = # 80000000 type
t_security_attributes              ! Taken from dfwinty.f90 file sequence
integer (4) :: nLength, lpSecurityDescriptor logical (4) :: bInheritHandle
 end type t_security_attributes end module mty
! Possible form of the fileopen function
integer function fileopen (lpFileName, dwDesiredAccess, dwShareMode, &
lpSecurityAttributes, 
dwCreationDisposition, 
dwFlagsAndAttributes,
hTemplateFile, unit)
! dec $ attributes reference :: dwDesiredAccess
! dec $ attributes reference :: dwShareMode
! dec $ attributes reference :: dwCreationDisposition
! dec $ attributes reference :: dwFlagsAndAttributes
! dec $ attributes reference :: unit
use mty
​ ! Instead of USE DFWINTY
! The CreateFile interface is taken from kernel32.f90. However, in the
original lpFileName
! is of type CHARACTER * (*), which is incorrect. Below bug fixed
interface
&
&

integer 
(4) 
function 
CreateFile 
(lpFileName, 
dwDesiredAccess,
dwShareMode,
lpSecurityAttributes, 
dwCreationDisposition, 
dwFlagsAndAttributes,
hTemplateFile)
! dec $ attributes default :: CreateFile
! dec $ attributes stdcall, alias: '_CreateFileA @ 28' :: CreateFile
! dec $ attributes reference :: lpFileName
! dec $ attributes reference :: lpSecurityAttributes
​ use mty
​ ! Instead of USE DFWINTY
integer (4) :: lpFileName
​ ! Correct type declaration integer ::
dwDesiredAccess, 
dwShareMode 
type 
(t_security_attributes)
lpSecurityAttributes 
integer 
:: 
dwCreationDisposition,
dwFlagsAndAttributes, hTemplateFile
end function CreateFile
end interface
integer 
(4) 
:: 
lpFileName, 
dwDesiredAccess, 
dwShareMode,
lpSecurityAttributes, & dwCreationDisposition, dwFlagsAndAttributes,
hTemplateFile, unit
type 
(t_security_attributes), 
pointer 
:: 
null_sec_attr 
!
File_flag_write_through bit flag for CreateFile dwFlagsAndAttributes =
dwFlagsAndAttributes + file_flag_write_through
! Opens a file with CreateFile
&
fileopen = CreateFile (lpFileName, dwDesiredAccess, dwShareMode,
null_sec_attr, 
dwCreationDisposition, 
dwFlagsAndAttributes,
hTemplateFile)
end function fileopen
&
360
361
11. Operations on external files
The first 7 parameters of the function are passed from CVF and correspond to the list of CreateFile parameters. Their values  are taken from the corresponding
OPEN operator:
lpFileName - address of the SI string containing the file name; dwDesiredAccess Desired access;
dwShareMode - type of access (exclusive or shared);
lpSecurityAttributes - always null in Fortran ; passed for reference
on the security_attributes structure ; dwCreationDisposition - the type of actions performed with the file; dwFlagsAndAttributes - file attributes and flags;
hTemplateFile - always null ; passed for the descriptor of the temporary
file of the CreateFile function.
The last parameter is the device specified in the OPEN statement.
11.5. CLOSE statement
 The operator disconnects the file from the I / O device and closes that device.
​ CLOSE ([UNIT =] u [, ERR = err ] [, IOSTAT = iostat ]              &
[, STATUS | DISPOSE | DISP = status ])
For a description of the u , err, and iostat parameters , see Sect. 11.1. status is a character expression evaluated with one of the following
values:
'KEEP' or 'SAVE' - the file is saved;
'DELETE' - the file is being deleted;
'PRINT' - the file is printed and saved (only forsequential files);
'PRINT / DELETE' - file is printed and deleted (only forsequential files);
'SUBMIT' - splits the process to execute the file;
'SUBMIT / DELETE' - splits the process to execute the file andremoves it after completing operations.
The default is 'DELETE' for scratch files and windows QuickWin. For other files, 'KEEP' is valid.
Setting STATUS = 'KEEP' for temporary files raises an error execution. For other types of files, the default status is
'KEEP'.If no file was connected to the device, then no error arises.
Open files do not need to be closed with a CLOSE statement. When when the program ends normally, they close automatically at according to the statuses set for
them. Closing a device (file)
 0 automatically reconnects this device to the keyboard and screen. 361
362
O. V. Barteniev. Modern FORTRAN
Closing devices 5 and 6 reconnects these devices respectively to keyboard and screen. CLOSE (*) statement will throw a compilation error.
Example:
! Close device 7 and delete the attached file from the disk close (7, status = 'delete')
11.6. READ statement
The operator is transferring data from the connected device u file to the variables specified in the input list. In CVF, in the case of direct file READ modifies the
associated file variable specified by in the corresponding OPEN statement. Data transfer is performed until until all input operations have been completed or
situations have arisen end of file or errors. In case of list driven input, input stops when a slash (/) is found in the input field.
When entering from a file or from the keyboard, the operator looks like this:
​ READ ([UNIT =] u [, [[FMT =] fmt ] | [[NML =] nml ]              &
​ [, ADVANCE = advance ] [, END = end ] [, EOR = eor ]              &
[, ERR = err ] [, IOSTAT = iostat ] [, REC = rec ] [, SIZE = size ]) [ iolist ] When working with a keyboard, the operator can be written as follows:

READ * | fmt [, iolist ]
If the UNIT = specifier is omitted, then the u parameter must be the first operator parameter. If the FMT or NML specifiers are omitted, then the fmt or nml
parameters must be the second parameters of the operator. Otherwise, the parameters may appear in no particular order. u - I / O device (Sections 10.2 and
10.3). Device can be set an asterisk (*). In this case, the input will be from the keyboard.
If the device was not attached to the file, then reading will be the actions specified by the operator have been performed:
​ OPEN ( u , FILE = '', STATUS = 'OLD',              &
ACCESS = 'SEQUENTIAL', FORM = form ) where form is evaluated with the values  'FORMATTED' (on formatted input) and 'UNFORMATTED' (if
unformatted). If the file name is included in the command line that launches the program, this name will be used for filename. Otherwise, the program will ask enter
the file name from the keyboard.
fmt - format specifier, which can be either a statement label FORMAT, or a character expression containing the enclosed parentheses list of conversion
descriptors. When controlled the list input uses an asterisk (*) as fmt . Managed list entry is possible only from sequential text files.
For unformatted or binary input, the fmt parameter must be omitted.
 362
363
11. Operations on external files
nml is a named list specifier. When entering a named
of the iolist must be omitted. Driven by named list input can only be done from text files open for sequential access.
advance is a symbolic expression used to specify an advancing
or non-forwarding sequential formatted input and computed with the values  'YES' or 'NO'. 'YES' is the default and
means that a progressing input is given, i.e. after the execution of each of the input statement, the file is positioned after the record from which data transfer was in
progress. With non-advancing I / O (ADVANCE = = 'NO') the file is left immediately after the last transmitted character. end - the label of the executable
statement of the same visibility block, where
READ statement applied. If the END specifier is present, then with
When the end of the file is reached, control is transferred to the executable statement, whose label is end . The external file is installed behind the entry "end file ". If
END is missing and no ERR or IO specifiers are specified STAT, then reading after writing "end of file" will result in an error execution.
eor - the label of the operator of the same visibility block in which the
READ statement. If the qualifier EOR = is given, then it must also be specifier ADVANCE = 'NO' is also set. If the qualifier EOR = is given, execution of the input
statement stops when the end of the record is reached (if there was no other error earlier). If EOR = omitted, then upon reaching the end of the recording, an error
occurs that can be processed with the IOSTAT specifier.
err is the label of the statement being executed. When an error occurs I / O control is transferred to the operator labeled err .
iostat - integer variable, returns 0 if absent
errors; returns -1 if an end-of-file condition has occurred; otherwise case returns the number of the error that occurred. An error condition occurs, for example, if
the end of a record is detected on non-advanced input. rec is an integer expression that returns a positive number,
called the record number . The REC qualifier can only be specified when working with direct access files (otherwise an I / O error will occur). If
REC is set, then before data entry the file is positioned at the beginning of recording with the rec number , which ensures the transfer of data from this record. The
first file record number 1. In FPS, the default rec is
the number of the current file record. And if, when entering from a direct file, the parameter missing, the current file record will be entered. In CVF at work with
direct files, the REC specifier is required.
size - an integer variable of the standard integer type,
returning the number of fields passed when performing formatted input with data. Added as a result of specifier execution
 363
364
O. V. Barteniev. Modern FORTRAN
PAD = 'YES' spaces are not counted. SIZE = specifier can be set only when specifier ADVANCE = 'NO' is set. For instance:
integer i, isv real a (10) open (1, file = 'a.txt') do i = 1, 5
read (1, '(f5.1)', advance = 'no', size = isv) a (i)
end do
print *, isv ​ ! five end
1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 10.0A.txt file :
iolist - an input list containing variables whose values
must be transferred from a file. Input list items can be as objects of any type, including derived and their subobjects.
If an error occurs during input, then the execution of the statement terminates, all elements of the input list become undefined, and file position is unpredictable.
The READ statement can break the execution of some graphical text procedures, such as SETTEXTWINDOW, which changes the current cursor position. To
avoid this, you can graphically mode to perform keyboard input using the GETCHARQQ function, and display the results on the screen using the OUTTEXT
procedure.
11.7. ACCEPT operator
Performs keyboard input.
ACCEPT fmt [, iolist ]
! Formatted input
ACCEPT * [, iolist ]
! List driven input
ACCEPT nml
! Named List Driven
Input
fmt is a format specifier, without the FMT specifier. iolist is an input list. nml is a named list specifier.
Example :
real x integer k
print *, 'Enter real x and integer k'
accept *, x, k
​ ! Let's enter: 123.45 56 print '(f7.2, i5)', x, k              ! 123.45 56 end
 364
365
11. Operations on external files

11.8. FIND statement
the associated file variable number The operator sets the direct file to record rec . Has two forms:rec and writes it to
FIND ([UNIT =] u , REC = rec [, ERR = err ] [, IOSTAT = iostat ]) and
FIND ( u ' rec [, ERR = err ] [, IOSTAT = ios ]) For a description of specifiers, see Sect. 11.6.
11.9. DELETE statement
Removes the rec entry in the linked file.
DELETE ([UNIT =] u [, REC = rec ] [, ERR = err ] [, IOSTAT = iostat ])
For a description of specifiers, see Sect. 11.6.
The operator logically removes the given record from the file, marking it as deleted, and frees this record for entering new data.
When deleting a record, if there is no error situation, the associated the file variable gets the value rec + 1. If the REC specifier not specified, the current record is
deleted.
Example for FIND and DELETE:
integer (4) ios, asv
​ ! asv - associated variable character (8) :: st = 'A record'
! Let's create a straight file with three records
open (1, file = 'c.dat', access = 'direct', form = 'formatted', recl = 9, & status = 'new', associatevariable = asv, organization = 'relative')
write (1, '(a8)', rec = 1) st; write (1, '(a8)', rec = 2) st; write (1, '(a8)', rec = 3) st
find (1, rec = 2)
! or: find (1'2)
print *, asv delete (1, rec =
2)
! 2
print *, asv read (1, rec = 2,
iostat = ios) st if (ios / = 0)
then print *, 'Error' else
! 3
print *, st
end if end
! Will print an
empty line
11.10. UNLOCK operator
Frees a record in a linked file or in a file with sequential organization blocked by the previous READ statement. Has two forms:
UNLOCK u
365
366
O. V. Barteniev. Modern FORTRAN
and
UNLOCK ([UNIT =] u [, ERR = label ] [, IOSTAT = iostat ]) For a description of specifiers, see Sect. 11.6.
If there is no locked record, the statement is ignored.
11.11. WRITE statement
The operator transfers data from the output list to the file connected to device u . In CVF, in the case of a direct file, changes the associated the file variable
specified in the corresponding OPEN statement.
WRITE ([UNIT =] u [, [[FMT =] fmt ] | [[NML =] nml ]
&
[, ADVANCE = advance ] [, ERR = err ]
[, IOSTAT = iostat ] [, REC = rec ]) [ iolist ] u - I / O device
(Sections 10.2 and 10.3). The output will be executed
on the screen if an asterisk (*) is used as the device.
If the device was not attached to the file, then the output will be the
actions specified by the operator have been performed:
&
OPEN ( u , FILE = '', STATUS = 'UNKNOWN',
ACCESS = 'SEQUENTIAL', FORM = form )
&
 where form is evaluated with the values  'FORMATTED' (on formatted input) and 'UNFORMATTED' (if unformatted). If the file name is included in
the command line that launches the program, this name will be used for filename. Otherwise, the program will ask enter the file name from the keyboard.
fmt is a format specifier. For unformatted or binary input
the fmt parameter must be omitted. The output will be driven by the list if an asterisk is used as fmt . List-driven output only possible in sequential text files.
nml is a named list specifier. When outputting a named
of the iolist must be omitted. Driven by named list output can only be done to files opened for sequential access.
advance is a symbolic expression used to specify an advancing
or non-forwarding serial formatted output and
calculated with the values  'YES' or 'NO'. The 'YES' value is set by the default and means that the on-going output is specified, i.e. after the execution of each
output statement is terminated
records and the file is positioned after the given characters. When non-advancing I / O (ADVANCE = 'NO')
are affixed and the file is left after the last output symbol.
366
367
11. Operations on external files
err is the label of the statement being executed. When an error occurs I / O control is transferred to the operator labeled err .
iostat is an integer variable that returns 0 if absent
errors or the number of the error that occurred.
rec is an integer expression that returns a positive number,
called the record number. The rec parameter can only be specified when working with direct access files (otherwise an I / O error will occur).
The rec parameter indicates the record to which data will be transferred when execution of the WRITE statement. In FPS, the default rec is
the number of the current file record. And if, when entering from a direct file, the parameter missing, the current file record will be changed. In CVF when working
with direct files, the presence of the REC specifier is required.
iolist - an output list containing expressions whose results

must be transferred to a file.
 When writing to a sequential file, all records after entered, are deleted (if any) and the file is positioned before writing "end of file". Thus, after output
to sequential file must be applied BACKSPACE or REWIND to execute the READ statement. Obstacles to Operator Use WRITE, however, no.
11.12. PRINT operator
Displays data on the screen (device *).
PRINT * | fmt [, iolist ] where fmt is a format specifier; iolist is an output list. If the asterisk overrides fmt , then the output is controlled by the iolist .
11.13. REWRITE operator
Replaces the current record in the direct access file with a new one. When direct file modifies the associated file variable specified by
in the corresponding OPEN statement. When outputting to a format file, it has view:
​ REWRITE ([UNIT =] u , [FMT =] fmt [, IOSTAT = iostat ]              &
[, ERR = err ]) [ iolist ]
It is used with unformatted files like this:
REWRITE ([UNIT =] u [, IOSTAT = iostat ] [, ERR = err ]) [ iolist ]
The specifiers have the same meaning as in the WRITE statement.
The current record is the record to which the file was installed as a result execution of the preceding READ statement. And with the device u between READ and
REWRITE no other I / O must be executed,
367
368
O. V. Barteniev. Modern FORTRAN
except for INQUIRE. Otherwise, the current record will be uncertain.
The number of characters in the output list and specified by the format specifier must not exceed the record length specified by the RECL specifier
OPEN operator. If the number of transmitted characters is less than the length records, the missing characters are filled in with spaces.
Example:
type person
character (len = 15) lastn, firstn
end type person integer ios 100 format (2a15) open (3, file = 'a.txt', form = 'formatted', access = 'direct', recl = 30)
! Let's create two records
write (3, fmt = 100, rec = 1) person ('Blake', 'William') write (3, fmt = 100, rec = 2) person ('Maugham', 'W. Somerset') read (3, fmt = 100, rec = 1)              !
Record 1 is current
 rewrite (3, 100, iostat = ios) person ('Byron', 'G. Gordon') if (ios / = 0) print *, 'Rewriting error' end
11.14. INQUIRE operator
Returns the properties of a device or external file. File poll operator form:
​ INQUIRE (FILE = file [, ERR = err ] [, IOSTAT = iostat ]              &
[, DEFAULTFILE = def ], slist ) Device polling operator form:
INQUIRE ([UNIT =] u [, ERR = err ] [, IOSTAT = iostat ], slist ) Form of the operator of polling the list of output: INQUIRE (IOLENGTH = iolength ) [ iolist ]
file - a symbolic expression that specifies the file name, information about
which the INQUIRE statement returns.
u - external file device (Section 10.2), about which it is necessary
get information. If UNIT = * is given, then you cannot include the NUMBER specifier.
In the INQUIRE statement, you can specify either the u parameter or the file parameter , but not both at the same time. If the parameter u is given , then polling the
device. If file is specified, the file is polled.
def - a scalar symbolic expression specifying the used
the default is the path to the file being opened. If the trailing slash (/) omitted, it will be added. If the DEFAULTFILE specifier missing, the current working
directory is used.
368
369
11. Operations on external files
 If INQUIRE contains the DEFAULTFILE specifier, then it must also be in the corresponding OPEN statement. DE- qualifier FAULTFILE = def can
be specified in addition to or instead of specifier FILE = file . Both file and def can start with a tilde (~). iolength is a standard integer variable that returns the size
the output list. This form of INQUIRE statement only includes the IOLENGTH = specifier and the iolist output list . All others specifiers must be absent. Iolist list
in all other cases absent. For instance:
real :: r = 1.1, a (100) = 2.2 integer :: iol, kar (50) = 5 character (25) :: st
(25) = 'abcd'
inquire (iolength = iol) r, a, kar, st ​ ! iol - size of the output list print *,
iol              ! 1229
The resulting value can be used, for example, to set the RECL specifier of
the OPEN statement. The data can then be passed to open unformatted
direct access file.
slist - one or more specifiers from the following list:
[, ACCESS = access ] [, ACTION = action ] [, BINARY = binary ]
&
[, BLANK = blank ] [, BLOCKSIZE = blocksize ]
&
[, BUFFERD = bf *] [, CARRIAGECONTROL = carriagecontrol ]
&
[, CONVERT = fm *] [, DELIM = delim ] [, DIRECT = direct ]
&
[, ERR = err ] [, EXIST = exist ] [, FORM = form ]
&
[, FORMATTED = formatted ] [, IOFOCUS = iofocus ]
&
[, IOSTAT = iostat ] [, MODE = mode ] [, NAME = name ]
&
[, NAMED = named ] [, NEXTREC = nextrec ] [, NUMBER = num ]
&
[, OPENED = opened ] [, ORGANIZATION = org *] [, PAD = pad ]
&

[, POSITION = position ] [, READ = read ] [, READWRITE = readwrite ]
&
[, RECL = recl ] [, RECORDTYPE = rtyp *] [, SEQUENTIAL = seq ]
[, SHARE = share ] [, UNFORMATTED = unformatted ] [, WRITE =
write ])
&
Comment. Parameters marked with an asterisk are only applicable in CVF.
access is a symbolic variable. Returns 'APPEND' if given
a device or file is open for adding data. Returns' SEQUENTIAL 'if the device or file is open for serial access, and returns 'DIRECT' if the device or file is open for
direct access.
​ Returns 'UNDEFINED'              at              absence connections.
action is a symbolic variable that returns 'READ' if file
open read-only, or 'WRITE' if the file is open only for write, or 'READWRITE' if the file is connected for both read and for recording. Returns 'UNDEFINED' if
not connected.
 369
370
O. V. Barteniev. Modern FORTRAN
binary is a character variable. Returns 'YES' if file or
the device is recognized as binary, and 'NO' or 'UNKNOWN' otherwise case.
blank is a character variable. Returns 'NULL' if valid
a BN conversion handle, and returns 'ZERO' if in effect descriptor BZ. Returns 'UNDEFINED' if not connected or if the file is not open for formatted I / O.
blocksize is a standard integer variable. Returns the size
I / O buffer in bytes. Returns 0 if there is no connection.
bf is a symbolic variable. Returns 'YES' ('NO') if file or
device is connected and buffering is active (not active), or 'UNKNOWN 'if file or device is not connected.
carriagecontrol - a character variable returning 'FORTRAN',
if the first character of the formatted entry is treated as a control character caret, or 'LIST' if the first character of format files is nothing differs from other notation
characters.
delim is a symbolic variable that returns 'APOSTROPHE' if for
character data with list driven I / O as delimiter an apostrophe (') is used. Returns 'QUOTE' if delimited are quotation marks ("). Returns 'NONE' if no delimiter is
specified.
Returns 'UNDEFINED' if not connected.
direct is a character variable. Returns 'YES' if the polled
the device or file is open for direct access, and returns 'NO' or 'UNKNOWN' otherwise.
err is the label of the statement being executed. When an error occurs
control is transferred to the operator labeled err . exist - boolean variable; returns .TRUE. if polled device or file exists, or .FALSE. - otherwise.
fm is a symbolic variable. Returns one of those listed in
sect. 11.4 for the CONVERT value specifier, or 'UNKNOWN' if file or device is not connected for non-formatted data transfer. form is a character variable.
Returns 'FORMATTED' if
device or file connected for formatted I / O; returns' UN-
FORMATTED 'for unformatted I / O and returns' BINARY' for binary
I / O. Returns 'UNDEFINED' if not connected.
formatted is a character variable. Returns 'YES' if the device
or the file is open for formatted I / O, and 'NO' otherwise.
Returns 'UNKNOWN' if the processor cannot determine which I / O allowed.
iofocus is a standard boolean variable. Returns
.TRUE. If the specified device (QuickWin application window) is in focus, otherwise returns .FALSE .. The parameter can be used with QuickWin applications
only.
 370
371
11. Operations on external files
iostat is a standard integer variable. Returns 0 for
no errors, negative number if the situation "end file ", or the error number that occurred.
mode is a character variable. Returns mode or action values ('READ', 'WRITE' or 'READWRITE') specified for the device (file) operator OPEN. Returns
'UNDEFINED' if not connected. name is a symbolic variable. Returns the name when polling the device
the file connected to it. If the file is not connected to the device or if the linked file has no name, the value of the name variable undefined. When polling a file, name
returns the specified file name.
named is a boolean variable. Returns .TRUE. If the file has
name, and .FALSE. - otherwise.
nextrec is a standard integer variable. Returns the number
next entry in the direct access file. First record number of the file is equal to one.
num is a variable of the standard integer type. When polling a file
returns the number of the device connected to the file. If the file is not a device is connected, the value of the variable num is undefined. When polling the device,
the devices. If UNIT = * is specified, then you cannot include the NUM-num variable returns the number of the polled
BER.
opened - a boolean variable that returns when the device is polled .TRUE. If any file is connected to the device, and .FALSE. otherwise. When polling a file,
returns .TRUE. If the file connected to some device, and .FALSE. - otherwise.
org is a character variable, returns the value 'SEQUENTIAL' if
the file has a sequential organization, 'RELATIVE', if - linked, or 'UNKNOWN' if the processor cannot determine the type of organization file.
pad - a character variable returning 'YES' if the file is open
with PAD = 'YES', and 'NO' otherwise.

position - a character variable returning 'REWIND' if file
positioned at its starting point. Returns 'APPEND' if file located at its endpoint before the end of file entry.
Returns 'ASIS' if the file is connected without changing position.
Returns 'UNDEFINED' if there is no connection or if the file connected for direct access.
read is a character variable returning 'YES' if the file is open
for reading, and 'NO' if data cannot be entered from the file. Returns' UNKNOWN 'if the processor cannot determine if read is allowed from file.
 readwrite is a character variable that returns 'YES' if file open for both reading and writing, and 'NO' if it cannot be done 371
372
O. V. Barteniev. Modern FORTRAN
read or write. Returns 'UNKNOWN' if the processor cannot determine whether the file is allowed to be used for both reading and writing.
recl is a variable of the standard integer type. Returns the length of the entry
(in bytes) of the direct access file. If the file is connected for unformatted data transfer, the number of bytes returned depends on the operating system being used.
rtyp is a symbolic variable. Returns one of the following
in sect. 11.4 for RECORDTYPE specifier values, or 'UNKNOWN', if file or device is not connected.
seq is a character variable. Returns 'YES' if the file is connected for
sequential access, and 'NO' or 'UNKNOWN' otherwise.
share is a symbolic variable. Returns the value of the share status ,
given to the file by the OPEN operator: 'COMPAT', 'DENYRW', 'DENYWR', 'DENYRD' and 'DENYNONE'. When polling a device, if the device the file is not
connected, the value of the share variable is undefined.
unformatted is a symbolic variable. Returns 'YES' if the file is open
for unformatted data transfer, and 'NO' otherwise. Returns
'UNKNOWN' if the processor cannot determine which I / O is allowed.
write is a symbolic variable returning 'YES' if the file is open
for writing, and 'NO' if the file cannot be output. Returns' UNKNOWN 'if the processor cannot determine if the output is valid to the data file.
The INQUIRE operator returns the value of the attributes with which the file was opened. Properties of unopened files cannot be returned operator. If some
attributes are not specified, then the operator returns their default values.
Variables used in the INQUIRE statement can be simple variables, array elements and components are used derived types.
If the UNIT = keyword is omitted when polling the device, then the u parameter must come first. Other parameters can be located in in no particular order, but
must not be repeated.
Example:
character (25) :: st (25) = '' open (1, file = 'a.txt', action = 'write', position = 'append') write (1, *) st rewind 1
inquire (1, name = st (1), action = st (2), blank = st (3), position = st (4))
 print *, (trim (st (i)), '', i = 1, 4)
​ ! a.txt WRITE NULL REWIND 372
373
11. Operations on external files
11.15. EOF function
The function returns .TRUE. If the u- file connected to the device positioned at or after the end-of-file special entry records. Otherwise EOF returns .FALSE.
Function syntax:
flag = EOF ( u ) u - I / O device (Section 10.2).
11.16. Organization of fast input / output
Time spent on I / O will be reduced if you adhere to the following rules:
use non-formatted files instead of formatted files whenever possible.So, output to a file connected to device 10 will be executed much faster than output to a file
that is connected to the device 20:
real (4), dimension (100, 20) :: array = 1.0
open (10, file = 'a.dat', form = 'unformatted')! or form = 'binary' open (20, file = 'a.txt', form = 'formatted')
write (10) array
​ ! A.dat file is accessed write (20, '(20f8.3)') array              ! faster than a.txt file
do I / O of the entire array or the entire string, without using loops;
if, nevertheless, when transferring multidimensional arrays, it is necessaryarrange nested loops, then use natural ordering passing array elements: in the inner loop
must change the leftmost index, while the outermost one is the rightmost one. This will ensure access to the elements of the array in the order of their placement in
memory, which, understandably, will speed up data transfer;
use, if resources allow, for storing intermediateresults in RAM, not external files;
use in case of format I / O when programming formatan integer expression instead of a character string, since in the first case, the format is determined once - at
compilation, and in second - format specification, string form , - is formed in the process program execution:
real (4), dimension (1000) :: array integer (4) :: i character (15) :: form
​ ...
​ ! The value of the variable n is calculated
! This method format jobs better than the formation of the line The form ,
! containing format specification
! < n > is an expression in a transform descriptor print '(1x, <n> f8.3)', (array (i), i = 1, n)
373
374
O. V. Barteniev. Modern FORTRAN
write (form, '(a, i5, a)') '(1x', n, 'f8.3)' ! We form a string of the
form format
print form, (array (i), i = 1, n)
! Output by form format
create conditions for the decomposition used in the I / O statementscyclic lists. For this, the loop variable must be integer, must not be a formal parameter, belong
operator EQUIVALENCE and have the VOLATILE attribute, and the format specification in the case of formatted data transmission should not have integer
expressions in the transform descriptor. An example of a circular list: write (10, '(20f8.3)') (array (i), i = 1, n)              ! Loop list of n elements
Explanation . Typically, each item in the I / O list refers to

I / O procedures of the CVF library. Time spent on these calls significant. In order to reduce them, the implicit loop is replaced the compiler for several (up to
seven) nested DO-loops, using an optimized I / O procedure for output that can transfer in chunks containing several
I / O elements;
to increase the amount of transmitted data with one callto disk, try increasing the BUFFER-
 COUNT statement OPEN, but do not change the value of the specifier BLOCKSIZE of the same operator as it is matched optimal for the device
being used. Impact of BUFFERCOUNT the baud rate must be set experimentally;
do not set the value of the RECL specifier of the OPEN statement to a large value,than the size of the I / O buffer (this size is determined by the specifier
BLOCKSIZE), since the transmission of redundant data is negligible filling the buffer, is inefficient;
select the value of the RECL = recl specifier in such a way that the I / O buffer filled the best. The buffer will be full
completely, if its size is a multiple of recl or, conversely, the RECL value multiple of the buffer size, for example: the buffer size is 8192, and in the OPEN statement
specified the specifier RECL = 1024 or RECL = 16384;
use the optimal record type from the point of view of performance,specified in the OPEN statement by the RECORDTYPE specifier:
for files with sequential organization, the greatestperformance will provide a job of fixed length records
(RECORDTYPE = 'FIXED');
in the case of non-formatted files, sequential organizationuse variable length records (RECORDTYPE = 'VARIABLE');
374
375
11. Operations on external files
 • in formatted files of sequential organization with records variable length, set RECORDTYPE = 'STREAM_LF'.
375
376
12. Constructor of modules for objects ActiveX
12.1. Some information about ActiveX objects
Technology of use in applications, including those written in Fortran, objects created in other applications are called Automation , formerly known as OLE
Automation . Themselves objects created using this technology are called objects ActiveX . The object is accessed using an interface or directly through the virtual
function table. ActiveX objects support the COM multicomponent model.
 The Automation Interface is a group of interrelated functions, providing access to methods and properties of an object, as well as processing events
recognized by the object. A method is an action that can execute the object. A property is a member function that provides access to information about the state of
the object. Most of the properties have two accessor functions - one returns the property value, the second returns it installs. An event is an action recognized by
an object for example, a mouse click or a key press. The event is method called by the object. In general, an object can support multiple interfaces. A pointer to
any of them will return subroutine COMQueryInterface.
The application that accesses ActiveX objects is called
ActiveX client . The ActiveX object itself is an instance of the class, providing its properties, methods and events to the ActiveX client. ActiveX objects are
created by ActiveX components , which either applications or libraries can act. So, the component ActiveX is Microsoft Excel. Typically an ActiveX component
provides many facilities. For example, Excel contains an object with named Application, for initialization and creation of which in Fortran application will need to
execute commands
call COMInitialize (status)
​ ! Initializing COM and Creating an Excel Object call COMCreateObject ("Excel.Application.8", excelapp, status)
Visible property of excelapp object will change command
call $ Application_SetVisible (excelapp, .true.)
In addition to pure objects, an ActiveX component can provide collection objects , which generally consist of various instances of some object. For example,
Excel can provide client ActiveX several "Workbooks", and within each
376
377
Constructor of modules for ActiveX objects
"Workbook" - several "Worksheets". Create a set object
 "Workbook" will be provided by the team
! Get a pointer to the "Workbook" object - Workbooks workbooks = $ Application_GetWorkbooks (excelapp, $ status = status) An instance of this object will
return the call
! Open the specified file. Specify the name of the Excel file as a parameter workbook = Workbooks_Open (workbooks, fname, $ status = status)
12.2. What is a module constructor for?
The procedures for working with ActiveX objects can be divided into two groups:
procedures for managing objects. They apply to all objects of Automation;
procedures that implement objects, their methods and properties, andreacting to events. In general, such procedures are unique (both in name and function) for
each object, its method, property, or event.
The first group procedures are implemented in those supplied with CVF the dfcom.lib and dfauto.lib libraries. To access them in CVF there are required
interfaces. They are needed because these procedures are written on SI. The technology used in FORTRAN for creating interfaces in multilingual applications are
considered in [1].
The second group procedures are described in the accompanying component ActiveX documentation. Therefore, in order to use them, you need to have the
necessary sources of information are at hand. However, before a Fortran programming user who even has necessary information, there are serious problems
associated with providing access to procedures. Which again has to do with the fact that they implemented, as a rule, not in Fortran.
To facilitate access to the second group procedures, with CVF available Designer modules Visual Fortran Module Wizard (hereinafter -
KM), which creates, based on the information available about the objects, modules on Fortran containing descriptions of data used with objects and texts of
procedures of the second group. (For procedures, see
corresponding files. So, all data about Excel objects is in the Excel8.olb library supplied with Excel.)
Next, we will consider the procedures common to all ActiveX objects. Automation control and types used in Automation data. And then - the procedure for
working with CM and analyze an example of its application.
Procedure
Appointment
View
COMAddObject
Reference
Adds a reference to an object
Function type
INTEGER (4)

COMCLSIDFrom
ProgID
Pass the programmatic identifier and returns the
corresponding id class
Subprogramramma
COMCLSIDFrom
String
Pass a string containing an identifier class, and returns the
corresponding class id
Also
COMCreateObject
ByGUID
Pass in a class id and create object instance. Returns a
pointer to object interface
"
COMCreateObject
ByProgID
Pass the programmatic identifier and creates an instance of
an object. Returns pointer to the object's IDispatch
interface
"
COMGetActiveObject
​ Pass in a class id and return              "
 377
378
O. V. Barteniev. Modern FORTRAN
12.3. Automation control procedure interfaces
Procedure interfaces, the names of which are given in table. 12.1, are contained in the dfcom.f90 file. Routines provide initialization ActiveX object, its creation,
activation and release. Control
properties of the object and calling the associated methods is carried out the procedures given in table. 12.2. The interfaces to them are in file dfauto.f90.
Table 12.1. ActiveX control procedures
ByGUID
​ pointer to the currently active interface object moment
COMGetActiveObject
​ Pass the programmatic identifier and              " ByProgID              returns a pointer to the IDispatch interface
the currently active object
​ COMGetFileObject
​ Pass in the filename and return a pointer to              "
IDispatch interface of the Automation object, which can handle the file
379
12. Constructor of modules for ActiveX objects
COMUninitialize ​ Freeing the COM library (latest called COM subroutine)
Table 12.2. Procedures for managing object properties and calls to its methods
Also
​ Procedure ​ Appointment
View
​ AUTOAddArg
​ Pass the parameter name and value and
adds a parameter to the data structure, containing a list of parameters
Subprogramramma
​ AUTOAllocate
​ Places a structure with a list of parameters,
​ InvokeArgs ​ which will be passed to the generic function
AUTOInvoke
Function type
INTEGER (4)
​ AUTODeallocate ​ Frees the memory occupied by the structure
​ InvokeArgs ​ with a list of parameters
Subprogramramma
AUTOGetExceptInfo Requests exception data, s which ended the method
Also
​ AUTOGetProperty
​ Pass in the name or ID of a property and Function
 
​ COMQueryInterface Pass the interface identifier and              "
returns a pointer
​ COMReleaseObject Releases the object              Function
type
INTEGER (4)
​ COMInitialize
​ COM library initialization              Subprogram-
ramma
378

12.4. Object identification
The ActiveX object is identified by the global a globally unique identifier (GUID), defined in the dfwinty.f90 file:
returns the value of a property of an object Automation
type
INTEGER (4)
AUTOGetProperty
ByID
Pass in the ID name of the property and return property value of the Automation object Also
AUTOGetProperty
InvokeArgs
Pass a structure with a list of parameters and returns the value of an object property
Automation
"
AUTOInvoke
Pass the name of the object's method identifier and a structure with a list of parameters
and calls the appropriate method
"
AUTOSetProperty
Pass the name of the property identifier and its value and sets the property value object
of Automation
"
AUTOSetProperty
ByID
Pass the ID-name of the property and its value, and sets the value of an object property
Automation
"
AUTOSetProperty
InvokeArgs
Pass a structure with a list of parameters and sets a given property value object of
Automation
"
 379
380
O. V. Barteniev. Modern FORTRAN
type guid
sequence integer * 4 data1 integer * 2 data2 integer * 2 data3 character * 8 data4
end type guid
COM uses GUIDs to identify classes, interfaces and other characteristics of the object that require unique identifiers. To create an instance of an object, you need
to tell COM about it (object) GUID. Also COM supports programmatic identifier ProgID (programmatic identifier), which looks like:
application_name.object_name.object_version
For example: Excel.Application.8. The ProgID type is CHARACTER (*). Correspondence between programmatic identifier and identifier class is set by the
COMCLSIDFromProgID routine.
12.5. Examples of working with Automation data
Special types of data are associated with Automation, for example various constants, BSTR strings, OLE arrays or variants, and procedures that perform certain
actions with them, for example placing data in memory, changing their values  or transforming types. In CVF, this data is defined in the dfwinty.f90 file, and the
interfaces related procedures - in the oleaut32.f90 file. The actual procedure implemented in the oleaut32.dll file.
For a detailed acquaintance with the types of Automation data, you can recommend, for example, given in sect. 12.2 literature. Here we will give the concepts of
OLE-arrays, BSTR-strings and variants, we will list procedures working with these objects, and we will give a number of examples. Note that the procedures
below are also described in the help file supplied with CVF.
The skills of working with Automation data are needed by a programmer, using COM technology, in particular, in order to provide data exchange between Fortran
and Automation procedures. Wherein you will need to perform type conversion operations, for example go from Fortran line to BSTR line, and data, for example
transfer data from a Fortran array to an OLE array.
12.5.1. OLE arrays
 Arrays associated with the IDispatch dispatch interface, are called OLE arrays . Another name for them is secure arrays . The OLE array contains
information about its rank and shape. For access to the array is used by its descriptor returned by the function 380
381
12. Constructor of modules for ActiveX objects
SafeArrayCreate. Array data is allocated in memory in the same way as
Fortran array data: fastest change is the very first index.
In particular, in the case of a two-dimensional OLE array, its data is located in computer memory column by column.
OLE arrays are associated with those given in table. 12.3 functions. All of them are of type INTEGER (4).
Table 12.3. Functions working with OLE arrays
Function
Appointment
SafeArrayAccessData
Increments the lock count of the
array and returns pointer to array
data
SafeArrayAllocData
Allocates memory for an OLE
array using the handle returned by
SafeArrayAllocDescriptor
SafeArrayAllocDescriptor Allocates memory for an array descriptor
SafeArrayCopy
Copies an array
SafeArrayCopyData
Copies the original array to
another, previously freeing the
contents of the last
SafeArrayCreate
Creates 
a 
new 
array
descriptor
SafeArrayCreateVector
Creates a vector of the
specified size
SafeArrayDestroy
Destroys a handle to an array
SafeArrayDestroyData
Frees the memory occupied
by the array
SafeArrayDestroyDescriptor Releases memory used by an array descriptor
SafeArrayGetDim
Returns the rank of an array

SafeArrayGetElement
Returns an array element
SafeArrayGetElemsize
Returns the size of an array
element in bytes
SafeArrayGetLBound
Returns the lower bound for a
given dimension
SafeArrayGetUBound
Returns the upper bound for a
given dimension
SafeArrayLock
Increases the number of array
locks
SafeArrayPtrOfIndex
Returns a pointer to an array
element
SafeArrayPutElement
Assigns a value to an array
element
SafeArrayRedim
Modifies the right, less significant
border of an array
SafeArrayUnaccessData
Decreases the lock count of the
array and does invalid pointer
returned SafeArrayAccessData
SafeArrayUnlock
Decreases the lock count of an
array
381
382
O. V. Barteniev. Modern FORTRAN
An example . Initially, an OLE array is created that matches the form with Fortran array a , then data from array a is transferred to OLEarray, after which its
contents are displayed on the screen.
program SafeArrayTest
use dfcomty
! Module references DFWINTY
use dfcom implicit none
integer (4) :: result, i, j, value
! Module references OLEAUT32 and
DFWINTY
integer (4) :: a (4, 3)
! Fortran array
type (sa_bounds) :: ab (2) integer
(4) :: indices (2)
! The sa_bounds type is described in the
DFWINTY module
integer (4) :: safeArray
! Setting an array by columns
! OLE array
a = reshape ((/
​ 11, 12, 13, 14,
​ &
​ ! Column 1
21, 22, 23, 24,
​ &
​ ! Column 2
31, 32, 33, 34 /), shape = (/ 4, 3 /))! Column 3
! Forming an OLE array
ab (1)% lbound = 1
​ ! Lower limit on the first dimension ab (1)% extent =
ubound (a, 1)              ! First Dimension
 ab (2)% lbound = 1 ab (2)% extent = ubound (a, 2) ! Create a new array descriptor
! The VT_I4 constant is described in the dfwinty.f90 file
! It means that the OLE array contains 4-byte integers safeArray = SafeArrayCreate (VT_I4, 2, ab (1)) ! For OLE array function interfaces, see oleaut32.f90
​ do j = ab (2)% lbound, ab (2)% extent              ! Transferring data to an OLE array
do i = ab (1)% lbound, ab (1)% extent
indices (1) = i; indices (2) = j
! Transferring data from a Fortran array to an OLE array result = SafeArrayPutElement (safeArray, indices (1), loc (a (i, j))) end do
end do
​ do j = ab (2)% lbound, ab (2)% extent              ! Reading and displaying OLE array data
do i = ab (1)% lbound, ab (1)% extent
indices (1) = i; indices (2) = j
result = SafeArrayGetElement (safeArray, indices (1), loc (value)) write (*, '(i5)', advance = 'no') value! Conclusion without promotion
end do
print *
​ ! New line break end do
result = SafeArrayDestroy (safeArray)! Freeing up memory end program SafeArrayTest
382
383
12. Constructor of modules for ActiveX objects
Comment. Not all interfaces are defined in the OLEAUT32 module functions table. 12.3. However, if necessary, the missing interface you can write it yourself.
An example . Function interface is created in OLE_vector program SafeArrayCreateVector, which is used to generate OLEvector. The elements of the string string
are entered into the vector .
program OLE_vector
use dfwinty​ ! To get the value VT_UI1 use dfcom implicit none
! Let's describe the SafeArrayCreateVector interface, since it is not in the OLEAUT32 module interface
integer (4) function SafeArrayCreateVector (vt, lLbound, cElements) ! dec $ attributes default, stdcall, alias:              &
'_SafeArrayCreateVector @' :: SafeArrayCreateVector
​ ! dec $ attributes value :: vt
​ ! All parameters are passed by value

! dec $ attributes value :: lLbound ! dec $ attributes value :: cElements integer (4), intent (in) :: vt, lLbound, cElements
end function SafeArrayCreateVector
 end interface integer (4) :: safeArray, len, i, indices (1), result character (30) :: string = 'Test string' character (1) :: ch
​ len = len_trim (string) ​ ! Length of string without trailing spaces
! Create a new array descriptor
! The VT_UI1 constant is described in the dfwinty.f90 file ! It means that the OLE array contains characters safeArray = SafeArrayCreateVector (VT_UI1, 1,
len)
do i = 1, len
​ ! Putting data into an OLE vector indices (1) = i result = SafeArrayPutElement (safeArray, indices (1), loc (string (i: i)))
end do
​ do i = 1, len
​ ! Test output
indices (1) = i
​ ! Reading and displaying data from an OLE vector result = SafeArrayGetElement (safeArray, indices (1), loc (ch)) write (*, '(a)', advance =
'no') ch! Conclusion without promotion
end do
print *
​ ! New line break end program OLE_vector
12.5.2. BSTR strings
Strings related to IDis interface types and data structures patch are called BSTR lines . These lines are null terminated character ( null ) and preceded by an integer
storing their length. Inside
383
384
O. V. Barteniev. Modern FORTRAN
strings can also be null characters. In fact, BSTR is pointer to string. Its type in Fortran is INTEGER (4).
The BSTR lines are associated with those shown in Table. 12.4 procedures. All they, in addition to the SysFreeString subroutine, are functions of type INTEGER
(4).
Table 12.4. Procedures for BSTR Strings
​ Function
​ Appointment
​ SysAllocString
​ Places a new line and copies the parameter string into it
 SysAllocStringByteLen Takes an ANSI string and returns BSTR, this string containing
SysAllocStringLen
Places a new line of the specified length and
copies into it the corresponding number of
characters from the parameter string
SysFreeString
(subroutine)
Frees a previously allocated line
SysReAllocString
Changes the placement of the string by
copying the passed data
SysReAllocStringLen
Changes the position of the line by copying
the given number of characters
SysStringByteLen
Returns the length of a string in bytes
SysStringLen
Returns the length of a string
VectorFromBSTR
Returns an OLE vector, each element of
which is the corresponding character of the
BSTR string
BSTRFromVector
Returns a BSTR string, each character of
which is the corresponding element of the
OLE vector
Notes:
The DFCOM module, located in the dfcom.f90 file, contains the functionConvertStringToBSTR converting Fortran string to BSTR, and the
ConvertBSTRToString function, which performs the reverse conversions.
The OLEAUT32 module lacks SysAllocString function interfaces.ByteLen, VectorFromBSTR and BSTRFromVector.
An example . A BSTR string is formed containing the text Test string. Further it is converted to a Fortran string.
program BSTR_example
use dfcom
integer (4) :: bstr, len character (30) :: string = 'Test string', string2 = ''
bstr = ConvertStringToBSTR (string)! We form a BSTR-string with the text Test string ! Convert BSTR string to Fortran string
 384
385
12. Constructor of modules for ActiveX objects
len = ConvertBSTRToString (bstr, string2)
print *, string2
​ ! Test string end program BSTR_example
12.5.3. Options
The derived variant datatype is defined in the dfwinty.f90 file:
type variant
sequence
integer (2) vt
integer (2) reserved1, reserved2, reserved3 record / variant_union / vu
end type variant
The variant_union structure used to form the type variant , looks like:
structure / variant_union /
union map
! 
Taken 
from
dfwinty.f90 file
integer (4) long_val
! VT_I4

end map map
character char_val
end map map
! VT_UI1
integer (2) short_val
end map map
! VT_I2
real (4) float_val end map
map
! VT_R4
real (8) double_val
end map map
! VT_R8
integer (2) bool_val
end map map
! VT_BOOL
integer (4) scode_val end
map
! VT_ERROR
map
real (8) date_val end map
! VT_DATE
map
! ptr_val - integer pointer
integer (4) ptr_val end map
end union end structure
! 
For 
parameters 
passed 
by
reference
 385
386
O. V. Barteniev. Modern FORTRAN
The variant type is widespread in Automation; they, in particular, possesses the vast majority of property and method parameters Automation. Variables of type
variant are called variants .
Variants are designed to store different types of data and allow converting from one type to another. Possible types, used with variants and other Automation
objects are set integer constants defined in the DFWINTY module. Here are some of them:
integer (2), parameter :: vt_empty = 0 ! No value set
integer (2), parameter :: vt_null = 1
! null
integer (2), parameter :: vt_i2 = 2
! INTEGER (2)
integer (2), parameter :: vt_i4 = 3
! INTEGER (4)
integer (2), parameter :: vt_r4 = 4
! REAL (4)
integer (2), parameter :: vt_r8 = 5
! Date - double precision floating point
number integer (2), parameter ::
vt_date = 7
! REAL (8)
integer (2), parameter :: vt_bstr = 8
! Pointer to an object that implements
IDispatch integer (2), parameter ::
vt_dispatch = 9
! BSTR
integer (2), parameter :: vt_error = 10 ! Error code
integer (2), parameter :: vt_bool = 11 ! True (#FFFF) or
False (# 0000)
integer (2), parameter :: vt_variant = 12! Option pointer ! Pointer to an object that implements Iunknown integer (2), parameter :: vt_unknown = 13
integer (2), parameter :: vt_i1 = 16
! INTEGER (1)
integer (2), parameter :: vt_ui1 = 17
! 1 byte unsigned
integer
integer (2), parameter :: vt_ui2 = 18
! 2 bytes unsigned
integer
integer (2), parameter :: vt_ui4 = 19
! 4-byte unsigned
integer
 To manipulate the options are given in table. 12.5 functions and subroutine. Function type - INTEGER (4). Table 12.5. Procedures for options
Function
Appointment
VariantChangeType
Converts a variant to another type
VariantChangeTypeEx
Converts a variant to another type
using locality identifier LCID used
when 
work 
with 
multilingual
applications
VariantClear
Clears the variant (frees the memory
occupied by option)
VariantCopy
Copies variant
VariantCopyInd
Copies a variant by performing a flag
transformation VT_BYREF, providing
transfer by reference, in
BYVAL, which guarantees the transfer
of the option by
386
387
12. Constructor of modules for ActiveX objects

meaning
VariantInit (subroutine) Performs variant initialization
VariantTimeToDosDateTime Converts the time represented as option, in date and time in MSDOS format
VariantTimeToSystemTime Converts the time represented as
options, in the system time view
Comment. The OLEAUT32 module does not contain Variant function interfaces TimeToDosDateTime and VariantTimeToSystemTime.
An example . Two options are created. The first is for storage a BSTR pointer, and the second is for a 4-byte real number. Each variant gets the corresponding
value: first is a pointer to BSTR-
the line "Compak Fortran", the second - the number 6.1. Then the second option converted to type BSTR; both translate to strings Fortran and the result is
displayed.
program variant_example
use dfcomty
use dfcom
​ use TextTransfer ​ ! To display Russian text in a DOS window
integer (4) :: status, length
​ ! See appendix for the TextTransfer module code. 1 character (80) :: char1, char2
type (variant) v1, v2
​ ! The variant type is described in the dfwinty.f90 file call VariantInit (v1)              ! Initialization of variants call VariantInit (v2)
​ v1% vt = VT_BSTR
​ ! Option v 1 stores a BSTR string
! Convert Fortran string to BSTR string
! For the conversion function ConvertStringToBSTR see dfcom.f90 v1% vu% ptr_val = ConvertStringToBSTR ("Compact Fortran")
v2% vt = VT_R4 ​ ! 4-byte real number v2% vu% float_val = 6.1
! For function interfaces that handle variants, see oleaut32.f90
! Converting variant v 2 to BSTR string status = VariantChangeType (v2, v2, 0, VT_BSTR)
! Convert BSTR strings to Fortran strings
! For the conversion function ConvertBSTRToString see dfcom.f90 length = ConvertBSTRToString (v1% vu% ptr_val, char1) length = ConvertBSTRToString
(v2% vu% ptr_val, char2) print *, trim (RuDosWin (trim (char1) // "" // trim (char2), .false.))
status = VariantClear (v1)
​ ! Clearing the option status = VariantClear (v2) end program variant_example
 387
388
O. V. Barteniev. Modern FORTRAN
12.6. Other sources of information
Interaction technology using COM, including and OLE automation, described in detail, except for [14], in the following sources:
How OLE and COM Solve the Problems of Component Software Design / by
K. Brockschmidt // Microsoft Systems Journal. 1996. Vol. 11, No. 5 (May).
R. 63-80.
Inside OLE / Red. by K. Brockschmidt. 2d ed. Redmond; Washington: Microsoft Press, 1995.
OLE 2 Programmer's Reference, Vol. 2. Redmond; Washington: Microsoft
Press, 1994.
Understanding ActiveX and OLE / Red. by D. Chappell. Redmond; Washington: Microsoft Press, 1996.
Win 32 SDK, OLE Programmer's Reference online version.
Win 32 SDK, Automation online version.
http://mspress.microsoft.com/.
12.7. How to use an ActiveX object
To use an ActiveX object in a Fortran program, you must do the following:
find an existing or install a new object in the system. An object can be registered with a special program or as a result of it creation by means of Visual C ++ or
Visual Basic (see, for example, DS documentation)
determine the type of interface that the object has (in generalan object can have multiple interfaces), and used in the object data types. The necessary information
about the object is obtained from related documentation. You can also get them, using the object viewer in DS
Automation, which is called as a result of execution
Chains Tools - OLE / COM Object Viewer;
apply CM and get the code of the module that provides accessto the object;
write a program in Fortran, which contains links to the receivedmodule and calls of procedures necessary to work with the object.
12.8. Using the module constructor
 The CM call is provided by the Tools - Fortran Module Wizard chain. After her execution in the window that appears (Fig.12.1), you must specify
the source, from which the CM will receive data about the object.
388
389
12. Constructor of modules for ActiveX objects
Figure: 12.1. Setting the object type
Such a source can be:
the object itself (Automation Object);
type library containing data about the Automation object
(Type Library Containing Automation Information);
type library containing data about the object's COM interface
(Type Library Containing COM Interface Information);
type library containing data about DLL (Type Library Containing
DLL Information);
DLL library containing data about the object type (DLL ContainingType Information).
Automation Object selection is made when information about an object is provided dynamically during the execution of the application. Such the situation is
relatively rare, since Microsoft

recommends that objects be supplied with a type library. After selection Automation Object will need to enter Application Name, Object Name and Number
version of the object (Figure 12.2), which, however, can be omitted. In such case, the latest version will be used, i.e. the Automation object specified as
application_name.object_name.object_version.
389
390
O. V. Barteniev. Modern FORTRAN
Figure: 12.2. Object identification
Automation Object option can be used with objects, providing a programmatic identifier (ProgID). It is entered into system registry and identifies an executable
that implements an object. Pressing the Generate button will generate the modules allowing the object to be used in a Fortran application.
The name specified without extension in the Module Name field (see Fig.12.1) will be subsequently used for the name of the generated CM file.
 The generated KM files have the F90 extension.
If another source of type information is selected, such as Type Library Containing Automation Information, pressing the Next key will cause the appearance of the
one shown in Fig. 12.3 screen.
Figure: 12.3. Selecting components from type library
390
391
12. Constructor of modules for ActiveX objects
The screen allows you to select a file containing a library of type (button Browse), view the contents of the library (Show button), select by applying left mouse
button required or all (Select All) components.
The Generate button will generate the corresponding modules.
Files containing type libraries can have different extensions,
e.g. OLB (Object Libraries) or OCX (Controls ActiveX).
12.9. An example of calling procedures generated module constructor
The generated KM file contains one or more modules, characterizing the object and, in general, including:
definitions of derived data types and constants foundin the object description section;
procedure interfaces located in the object description section;• subroutines and functions used when working with an object.
Procedures available in modules can be called from Fortran
(if there is a corresponding use- association).
 Let's take an example of using ActiveX objects an application written in Fortran that displays a chart in Excel by data generated in the application.
The project that creates the application is included with the CVF shipped samples and is located in ... \ DF98 \ SAMPLES \ ADVANCED \ COM \
AUTODICE. The composition of the project is shown in Fig. 12.4.
Figure: 12.4. AUTODICE project
The main program found in the autodice.f90 file and the module ADOBJS are written by a programmer. EXCEL97A module received in the result of the use of
CM. For its formation such actions:
shown in fig. 12.1 Source is selected on the screen Type Library Containing Automation Information;
on the next screen (Fig. 12.3) the file c: \ Program Files \ MicrosoftOffice \ Office \ Excel8.olb containing a library with components,
391
392
O. V. Barteniev. Modern FORTRAN
ensuring the functioning of Excel, and selected components
_Application, _Chart. _Workbook, _Worksheet, Axes, Charts, Range, Workbooks, Worksheets, EnumXIAxisGroup, EnaumXIAxisType required for working
with Excel.
The generated module has an impressive volume (about 20'000 lines of source text). Below is its initial part containing global constant declarations and one
_Application component function.
! excel97a.f90
! This module contains the Automation interfaces of the objects defined in
! c: \ Program Files \ Microsoft Office \ Office \ excel8.olb ! Generated by the Fortran Module Wizard on 10/24/98 module excel97a
use dfcomty use dfauto implicit none ! CLSIDs
type (guid), parameter :: CLSID_Global = & guid (# 00020812, # 0000, # 0000, &
char ('c0'x) // char (' 00'x) // char ('00'x) // char (' 00'x) // & char ('00'x) // char (' 00'x) // char ('00'x) // char (' 46'x))
 type (guid), parameter :: CLSID_Worksheet = & guid (# 00020820, # 0000, # 0000, &
char ('c0'x) // char (' 00'x) // char ('00'x) // char (' 00'x) // & char ('00'x) // char (' 00'x) // char ('00'x) // char (' 46'x))
type (guid), parameter :: CLSID_Chart = & guid (# 00020821, # 0000, # 0000, &
char ('c0'x) // char (' 00'x) // char ('00'x) // char (' 00'x) // & char ('00'x) // char (' 00'x) // char ('00'x) // char (' 46'x))
type (guid), parameter :: CLSID_APPLICATION = & guid (# 00024500, # 0000, # 0000, &
char ('c0'x) // char (' 00'x) // char ('00'x) // char (' 00'x) // & char ('00'x) // char (' 00'x) // char ('00'x) // char (' 46'x))
! Enums
! XlAxisGroup
integer, parameter :: xlPrimary = 1 integer, parameter :: xlSecondary = 2
! XlAxisType
integer, parameter :: xlCategory = 1 integer, parameter :: xlSeriesAxis = 3 integer, parameter :: xlValue = 2
! Module Procedures contains
function $ Application__Evaluate ($ object, Name, $ status) ! dec $ attributes dllexport :: $ Application__Evaluate implicit none
393
12. Constructor of modules for ActiveX
objects
integer (4), intent (in) :: $ object ! dec $ attributes value :: $ object type (variant), intent (in) :: Name ! dec $
attributes reference :: Name
! Object Pointer
integer (4), intent (out), optional :: $ status
! Method status
 392

! dec $ attributes reference :: $ status integer (4) $$ status integer (4) invokeargs type (variant), volatile :: $ return type (variant) $ Application__Evaluate
invokeargs = AUTOAllocateInvokeArgs () call AUTOAddArg (invokeargs, '$ return', $ return, .true.) call AUTOAddArg (invokeargs, '$ arg1', Name, .false.)
$$ status = AUTOInvoke ($ object, -5, invokeargs) if (present ($ status)) $ status = $$ status $ Application__Evaluate = $ return call
AUTODeallocateInvokeArgs (invokeargs)
end function $ Application__Evaluate
...
​ ! Other procedures follow. end module excel97a              ! module
Comments on the results of the CM:
KM uses the data types available in the DFCOMTY module (andactually in the DFWINTY module), and procedures in the DFAUTO module. Any generated
EXCEL97A module procedure can be called from the Fortran application being created.
If the type information contains a comment describingmember function, it is placed before the procedure code.
The first parameter of the generated procedures is always named $ object . It is a pointer to the object's interface.
The ATTRIBUTE directive is used to specify an agreement onways of passing parameters. In particular,
! dec $ attributes value :: $ object ensures that the $ object parameter is passed by value, and
! dec $ attributes reference :: Name
indicates that the Name parameter is passed by reference.
Almost every COM member function returns a type completion statusHRESULT corresponding to type INTEGER (4).
The interface of a COM member function is similar to that of a DLL function.However, unlike the latter, the address of the COM member function is unknown.
application builder. Therefore, to call it, you need to get
 393
394
O. V. Barteniev. Modern FORTRAN
a pointer to the object interface; the address of the corresponding member function computed from the value of this pointer.
Let's take a closer look at the example under consideration. For this we choose from modules DFWINTY, DFCOM, OLEAUT32, DFNLS and EXCEL97A
code, necessary for solving the task at hand - Fortran mapping array in the cells of the Excel sheet and build the corresponding chart.
Let's place the data selected from the DFWINTY module in the MYCOMTY module,
the code taken from the DFCOM, OLEAUT32 and DFNLS modules will be placed in the module MYCOM, and the EXCEL97A code is in the EXCEL97B
module. Now the code becomes quite visible and suitable for analysis, which the reader
the commentary in the program will help. In particular, the comment the main program includes the order of work with Excel objects, adhering to which it is
possible to activate objects, set them properties and display the data of the cellCounts array as a histogram.
For the application to work, you must specify the name of the XLS file. AT the example considered in CVF, such a file has the name histo.xls and contains shown
in Fig. 12.5 data.
Figure: 12.5. The composition of the histo.xls file
​ module mycomty ​ ! Contains declarations of all used
! dec $ objcomment lib: "dfcom.lib"! in the data autodice app ,
! dec $ objcomment lib: "oleaut32.lib"! as well as procedures that transform
​ implicit none
​ ! Fortran string to BSTR and back
! The variant_union structure and the variant type are taken from the dfwinty.f90 file structure / variant_union /
union
map
integer (4) long_val
end map map
character char_val
end map map
integer (2) short_val
end map map
real (4) float_val end map map
real (8) double_val end map
 394
395
12. Constructor of modules for ActiveX objects
map
integer (2) bool_val
end map map
integer (4) scode_val
end map map
real (8) date_val end map map
integer (4) ptr_val
​ ! ptr_val - integer pointer end map
end union
end structure type variant sequence
integer (2) vt
integer (2) reserved1, reserved2, reserved3 record / variant_union / vu
end type variant
! Guid type definition borrowed from dfwinty.f90 type guid
sequence integer (4) data1 integer (2) data2, data3 character (8) data4
end type guid
! The constants vt_i 4, vt_bstr , vt_dispatch are defined in the dfwinty.f90 file integer (2), parameter :: vt_i4 = 3, vt_bstr = 8, vt_dispatch = 9 end module mycomty
​ module mycom
​ ! Contains interfaces from DFCOM modules,
! dec $ objcomment lib: "dfcom.lib"! DFAUTO and OLEAUT32 used
! dec $ objcomment lib: "dfauto.lib"! in application autodice procedures,
! dec $ objcomment lib: "oleaut32.lib"! as well as procedures that transform

! dec $ objcomment lib: "dfnls.lib" ​ ! Fortran string to BSTR and back implicit none
! The generic COMCreateObject interface is taken from the DFCOM module (file dfcom.f90) interface COMCreateObject
subroutine COMCreateObjectByProgID (prog_id, idispatch, status)
! dec $ attributes default :: COMCreateObjectByProgID
! dec $ attributes reference :: prog_id
! dec $ attributes reference :: idispatch ! dec $ attributes reference :: status character (*), intent (in) :: prog_id integer (4), intent (out) :: idispatch, status
end subroutine COMCreateObjectByProgID
 395
396
O. V. Barteniev. Modern FORTRAN
subroutine COMCreateObjectByGUID (clsid, clsctx, iid, iinterface, status)
use mycomty
! dec $ attributes default :: COMCreateObjectByGUID
! dec $ attributes reference :: clsid
! dec $ attributes reference :: clsctx
! dec $ attributes reference :: iid
! dec $ attributes reference :: iinterface ! dec $ attributes reference :: status type (guid), intent (in) :: clsid, clsctx, iid integer (4), intent (out) :: iinterface, status end
subroutine COMCreateObjectByGUID
end interface COMCreateObject interface
! COMInitialize and COMUninitialize interfaces are taken from the DFCOM module subroutine COMInitialize (status)
! dec $ attributes default :: COMInitialize ! dec $ attributes reference :: status integer (4), intent (out) :: status
end subroutine COMInitialize subroutine COMUninitialize ()
! dec $ attributes default :: COMUninitialize end subroutine COMUninitialize
! COMReleaseObject interface borrowed from DFCOM module (dfcom.f90 file) integer (4) function COMReleaseObject (iunknown)
! dec $ attributes default :: COMReleaseObject
! dec $ attributes value :: iunknown integer (4), intent (in) :: iunknown
end function COMReleaseObject
! Automation function interfaces are taken from dfauto.f90
! Parameter activation method integer (4) function AUTOAllocateInvokeArgs ()
! dec $ attributes default :: AUTOAllocateInvokeArgs end function AUTOAllocateInvokeArgs integer (4) function AUTOSetPropertyByID (idispatch, memid,
invoke_args)
! dec $ attributes default :: AUTOSetPropertyByID
! dec $ attributes value :: idispatch
! dec $ attributes value :: memid ! dec $ attributes value :: invoke_args
integer (4), intent (in) :: idispatch, memid, invoke_args
end function AUTOSetPropertyByID integer (4) function AUTOGetPropertyByID (idispatch, memid, invoke_args)
! dec $ attributes default :: AUTOGetPropertyByID
! dec $ attributes value :: idispatch
 ! dec $ attributes value :: memid ! dec $ attributes value :: invoke_args integer (4), intent (in) :: idispatch, memid, invoke_args 396
397
12. Constructor of modules for ActiveX objects
end function AUTOGetPropertyByID
end interface
! Part of the generic AUTOSetProperty interface interface AUTOSetProperty
integer (4) function AUTOSetPropertyInteger2Array (idispatch, name, value, type)
! dec $ attributes default :: AUTOSetPropertyInteger2Array
! dec $ attributes value :: idispatch
! dec $ attributes reference :: name
! dec $ attributes reference :: value ! dec $ attributes reference :: type integer (4), intent (in) :: idispatch character (*), intent (in) :: name integer (2), dimension (:),
intent (in) :: value integer (2), intent (in), optional :: type
end function AUTOSetPropertyInteger2Array integer (4) function AUTOSetPropertyInteger4 (idispatch, name, value, type)
! dec $ attributes default :: AUTOSetPropertyInteger4
! dec $ attributes value :: idispatch
! dec $ attributes reference :: name
! dec $ attributes reference :: value ! dec $ attributes reference :: type integer (4), intent (in) :: idispatch, value character (*), intent (in) :: name integer (2), intent (in),
optional :: type
end function AUTOSetPropertyInteger4
end interface AUTOSetProperty
! Generic AUTOInvoke interface interface AUTOInvoke
integer (4) function AUTOInvokeByName (idispatch, name, invoke_args)
! dec $ attributes default :: AUTOInvokeByName
! dec $ attributes value :: idispatch
! dec $ attributes value :: invoke_args ! dec $ attributes reference :: name integer (4), intent (in) :: idispatch, invoke_args character (*), intent (in) :: name
end function AUTOInvokeByName
! Comment. When using AUTOInvokeByID for all calls ! AUTOAddArg is set to "$ ARG nn "
integer (4) function AUTOInvokeByID (idispatch, memid, invoke_args)
! dec $ attributes default :: AUTOInvokeByID
! dec $ attributes value :: idispatch
! dec $ attributes value :: memid ! dec $ attributes value :: invoke_args integer (4), intent (in) :: idispatch, memid, invoke_args
397

398
O. V. Barteniev. Modern FORTRAN
end function AUTOInvokeByID
end interface AUTOInvoke
! Part of the generic AUTOAddArg interface interface AUTOAddArg
subroutine AUTOAddArgInteger4 (invoke_args, name, value, output_arg, type)
! dec $ attributes default :: AUTOAddArgInteger4
! dec $ attributes value :: invoke_args
! dec $ attributes reference :: name
! dec $ attributes reference :: value
! dec $ attributes reference :: output_arg ! dec $ attributes reference :: type integer (4), intent (in) :: invoke_args, value character (*), intent (in) :: name logical (4),
intent (in), optional :: output_arg integer (2), intent (in), optional :: type end subroutine AUTOAddArgInteger4 subroutine AUTOAddArgLogical2 (invoke_args,
name, value, output_arg, type)
! dec $ attributes default :: AUTOAddArgLogical2 integer (4), intent (in) :: invoke_args ! dec $ attributes value :: invoke_args
! dec $ attributes reference :: name
! dec $ attributes reference :: value
 ! dec $ attributes reference :: output_arg ! dec $ attributes reference :: type character (*), intent (in) :: name logical (2), intent (in) :: value
logical (4), intent (in), optional :: output_arg integer (2), intent (in), optional :: type
end subroutine AUTOAddArgLogical2 subroutine AUTOAddArgCharacter (invoke_args, name, value, output_arg, type)
! dec $ attributes default :: AUTOAddArgCharacter
! dec $ attributes value :: invoke_args
! dec $ attributes reference :: name
! dec $ attributes reference :: value
! dec $ attributes reference :: output_arg ! dec $ attributes reference :: type integer (4), intent (in) :: invoke_args character (*), intent (in) :: name, value logical (4),
intent (in), optional :: output_arg integer (2), intent (in), optional :: type
end subroutine AUTOAddArgCharacter subroutine AUTOAddArgVariant (invoke_args, name, value, output_arg)
! dec $ attributes default :: AUTOAddArgVariant
! dec $ attributes value :: invoke_args
! dec $ attributes reference :: name
! dec $ attributes reference :: value
398
399
12. Constructor of modules for ActiveX objects
! dec $ attributes reference :: output_arg use mycomty
integer (4), intent (in) :: invoke_args character (*), intent (in) :: name type (variant), intent (in) :: value logical, intent (in), optional :: output_arg end subroutine
AUTOAddArgVariant
end interface AUTOAddArg
! SysAllocString, SysStringLen, and SysFreeString interfaces
! taken from file oleaut32.f90 interface
integer (4) function SysAllocString (unistr)
! dec $ attributes default, stdcall, alias: '_SysAllocString @' :: SysAllocString integer (2), intent (in) :: unistr (*)
end function SysAllocString integer (4) function SysStringLen (bstr)
! dec $ attributes default, stdcall, alias: '_SysStringLen @' :: SysStringLen
! dec $ attributes value :: bstr integer (4), intent (in) :: bstr
end function SysStringLen subroutine SysFreeString (bstr)
 ! dec $ attributes default, stdcall, alias: '_SysFreeString @' :: SysFreeString
! dec $ attributes value :: bstr integer (4), intent (in) :: bstr
end subroutine SysFreeString
! VariantInit and VariantClear are taken from oleaut32.f90 subroutine VariantInit (pvarg)
! dec $ attributes default, stdcall, alias: '_VariantInit @' :: VariantInit
! dec $ attributes reference :: pvarg
use mycomty
​ ! Instead use dfwinty type (variant), intent (out) :: pvarg
end subroutine VariantInit integer (4) function VariantClear (pvarg)
! dec $ attributes default, stdcall, alias: '_VariantClear @' :: VariantClear
! dec $ attributes reference :: pvarg
use mycomty
​ ! Instead use dfwinty type (variant), intent (out) :: pvarg
end function VariantClear
end interface
! The interface of the MBConvertMBToUnicode and MBConvertMBToUnicode functions is taken
! from the DFNLS module (dfnls.f90 file). They are needed for modular ! the ConvertStringToBSTR and ConvertBSTRToString functions interface
integer (4) function MBConvertMBToUnicode (mbstr, unicodestr, flags)
! dec $ attributes default :: MBConvertMBToUnicode character (*), intent (in) :: mbstr
399
400
O. V. Barteniev. Modern FORTRAN
integer (2), dimension (:), intent (out) :: unicodestr integer (4), intent (in), optional :: flags
end function MBConvertMBToUnicode
integer (4) function MBConvertUnicodeToMB (unicodestr, mbstr, flags)
! dec $ attributes default :: MBConvertUnicodeToMB integer (2), dimension (:), intent (in) :: unicodestr character (*), intent (out) :: mbstr integer (4), optional,
intent (in) :: flags

end function MBConvertUnicodeToMB end interface contains
! Procedures for converting Fortran string to BSTR string and vice versa;
! borrowed from dfcom.f90 file
integer (4) function ConvertStringToBSTR (string)
character (*), intent (in) :: string integer (4) bstr, length
​ integer (2), allocatable :: unistr (:)              ! UNICODE string
 ! The first call to MBConvertMBToUnicode determines the length of the string allocate (unistr (0)) length = MBConvertMBToUnicode (string, unistr)
deallocate (unistr)
if (length <0) then
allocate (unistr (2))
! Special case of
all spaces
unistr (1) = # 20
! One space
unistr (2) = 0
! Null character
else
! The second call to MBConvertMBToUnicode performs the conversion allocate (unistr (length + 1))
length = MBConvertMBToUnicode (string, unistr)
unistr (length + 1) = 0 ​ ! End the string with a null character end if bstr = SysAllocString (unistr)! Place the BSTR line deallocate (unistr)
ConvertStringToBSTR = bstr! Returning the result end function ConvertStringToBSTR integer (4) function ConvertBSTRToString (bstr, string)
integer (4), intent (in) :: bstr character (*), intent (out) :: string integer (4) length length = SysStringLen (bstr)
ConvertBSTRToString = Convert (bstr, length, string) contains
integer (4) function Convert (bstr, length, string)
integer (4), intent (in) :: bstr, length character (*), intent (out) :: string integer (2) :: unistr (length)
400
401
12. Constructor of modules for ActiveX objects
 pointer (p, unistr) p = bstr
Convert = MBConvertUnicodeToMB (unistr, string) end function Convert
end function ConvertBSTRToString
end module mycom module adobjs
implicit none ! Object pointers
integer (4) :: excelapp, workbooks, workbook, worksheets, worksheet, range, charts, chart integer (4) :: cells (12) integer (4) :: categoryAxis, valueAxis integer
(4) :: bstr1, bstr2, bstr3
contains
subroutine initobjects ()
​ ! Sets the initial values  of variables integer (4) i excelapp = 0; workbooks = 0; workbook = 0; worksheets = 0; worksheet = 0
range = 0; charts = 0; chart = 0; categoryAxis = 0; valueAxis = 0; cells = 0 bstr1 = 0; bstr2 = 0; bstr3 = 0
end subroutine initobjects
subroutine releaseobjects () ​ ! Releases the created objects use mycom              ! Instead of use dfcom integer (4) status, i if (range / = 0) status =
COMReleaseObject (range) if (chart / = 0) status = COMReleaseObject (chart) if (charts / = 0) status = COMReleaseObject (charts) if (worksheets / = 0)
status = COMReleaseObject (worksheet) if (worksheet / = 0) status = COMReleaseObject (worksheet) if (workbook / = 0) status = COMReleaseObject
(workbook) if (workbooks / = 0) status = COMReleaseObject (workbooks) do i = 1, 12
if (cells (i) / = 0) status = COMReleaseObject (cells (i))
end do
if (categoryAxis / = 0) status = COMReleaseObject (categoryAxis) if (valueAxis / = 0) status = COMReleaseObject (valueAxis) if (excelapp / = 0) status =
COMReleaseObject (excelapp)
if (bstr1 / = 0) call SysFreeString (bstr1)if (bstr2 / = 0) call SysFreeString (bstr2) if (bstr3 / = 0) call SysFreeString (bstr3)
end subroutine releaseobjects
end module adobjs program ExcelSample
! Replace references to modules DFCOM, DFCOMTY and EXCEL97B use mycom use adobjs use excel97b
 401
402
O. V. Barteniev. Modern FORTRAN
implicit none
integer (4) status, loopCount, roll, maxScale, i, die (2) character (32) :: fname real (4) rnd (2)
integer (2) :: cellCounts (12) ​ ! Array displayed as a chart type (variant) :: vbstr1, vbstr2, vbstr3, vint print *, 'Enter Excel file name' read *, fname
call initobjects () ​ ! Object initialization cellCounts = 0              ! Array initialization
call COMInitialize (status)
​ ! Initializing COM and Creating an Excel Object call COMCreateObject ("Excel.Application.8", excelapp, status) if (excelapp ==
0) stop 'Unable to create Excel object; Aborting ' call $ Application_SetVisible (excelapp, .true.) ! Sequence of operations:
! get a pointer to the "Workbook" object;
! open the fname file and create an instance of the Workbook object;
! get a pointer to the "Worksheet" object;
! set the range of filled table cells;
! fill cells from the selected range with the values  of the cellCounts array ;
! set the range of table cells displayed on the chart;
! get a pointer to the "Chart" object and form this object;
! set chart parameters and call the chart builder;
! set the parameters of the chart axes;
! set the maximum coordinate on the value axis
! form the rendered array cellCounts ;
! Transfer data to Excel and display it in a chart ! Pseudocode:
! workbooks = excelapp.GetWorkbooks ()

! workbook = workbooks.Open (spreadsheet)
! worksheet = workbook.GetActiveSheet
! range = worksheet.GetRange ("A1", "L1")
! range.Select ()
! charts = workbook.GetCharts ()
! chart = charts.Add ()
 402
403
12. Constructor of modules for ActiveX objects
! chart.ChartWizard (gallery = chartType, title = title, categoryTitle = title, valueTitle = title)
! valueAxis = chart.Axes (type = xlValue, axisGroup = xlPrimary)
! valueAxis.MaximumScale (loopcount / 5) ! Similar code in Fortran:
! Get a pointer to the "Workbook" set object - workbooks
workbooks = $ Application_GetWorkbooks (excelapp, $ status = status) call Check_Status (status, "Unable to get workbooks object")
! Create a workbook - an instance of the workbooks object
! Open the specified file. Specify the name of the XLS file as a parameter workbook = Workbooks_Open (workbooks, fname, $ status = status) call
Check_Status (status, "Unable to get Workbook object; see if the file path is correct")
! We get a worksheet - a pointer to the "Worksheet" object worksheet = $ Workbook_GetActiveSheet (workbook, status) call Check_Status (status, "Unable to
get Worksheet object")
call VariantInit (vbstr1) ! Create a new chart call VariantInit (vbstr2)
vbstr1% vt = vt_bstr; bstr1 = ConvertStringToBSTR ("A1"); vbstr1% vu% ptr_val = bstr1 vbstr2% vt = vt_bstr; bstr2 = ConvertStringToBSTR ("L1"); vbstr2%
vu% ptr_val = bstr2 ! Set the range of filled cells in the Excel table - from A1 to L1
range = $ Worksheet_GetRange (worksheet, vbstr1, vbstr2, status) call Check_Status (status, "Unable to get range object") status = VariantClear (vbstr1); bstr1
= 0 status = VariantClear (vbstr2); bstr2 = 0
! Fill cells from the selected range with the values  of the cellCounts array status = AUTOSetProperty (range, "Value", cellCounts) ! Select the range of cells
displayed on the chart call Range_Select (range, status) ! Get a pointer to the "Chart" object
charts = $ Workbook_GetCharts (workbook, $ status = status) call Check_Status (status, "Unable to get charts object") chart = Charts_Add (charts, $ status =
status) call Check_Status (status, "Unable to add chart object")
! We call the diagram builder. Pseudocode:
! chart.ChartWizard (gallery = chartType, title = title, categoryTitle = title, valueTitle = title)
​ call VariantInit (vint)
​ ! Fortran code
! Histogram view - volumetric vertical bars vint% vt = vt_i4; vint% vu% long_val = 11
call VariantInit (vbstr1) ! Variant initialization vbstr1% vt = vt_bstr              ! Stored value type
 403
404
O. V. Barteniev. Modern FORTRAN
bstr1 = ConvertStringToBSTR ("Histogram cellCounts"); vbstr1% vu% ptr_val = bstr1
call VariantInit (vbstr2); vbstr2% vt = vt_bstr bstr2 = ConvertStringToBSTR ("Column"); vbstr2% vu% ptr_val = bstr2 call VariantInit (vbstr3); vbstr3% vt =
vt_bstr bstr3 = ConvertStringToBSTR ("Value"); vbstr3% vu% ptr_val = bstr3
call 
$ 
Chart_ChartWizard
(chart,
&
Gallery = vint,
&! Chart view
Title = vbstr1,
&! Chart title
CategoryTitle = vbstr2,
&! Horizontal axis
title
​ ValueTitle = vbstr3,
​ &! Vertical axis title
$ status = status)
call Check_Status (status, "Unable to invoke ChartWizard") status = VariantClear (vbstr1); bstr1 = 0              ! Clearing options status = VariantClear (vbstr2);
bstr2 = 0 status = VariantClear (vbstr3); bstr3 = 0
call VariantInit (vint)
​ ! Setting the properties of the chart axes vint% vt = vt_i4; vint% vu% long_val = xlValue
valueAxis = $ Chart_Axes (chart, vint, xlPrimary, $ status = status) call Check_Status (status, "Unable to get axis object")
loopcount = 1000
​ ! Random Number Generator Calls maxScale = loopcount / 5              ! Maximum value on the value axis status = AUTOSetProperty
(valueAxis, "MaximumScale", maxScale) call Check_Status (status, "Unable to set axis MaximumScale")
call random_seed ()
​ ! Seeding a random number generator do i = 1, loopcount              ! Forming the displayed array
call random_number (rnd)
​ ! Generating two random numbers die = nint ((rnd * 6) + 0.5) roll = sum (die)
cellCounts (roll) = cellCounts (roll) + 1
end do
! Displaying cellCounts array data in Excel spreadsheet and chart status = AUTOSetProperty (range, "Value", cellCounts) call Check_Status (status, "Unable to
set range value")
call releaseobjects ()
​ ! Freeing objects call COMUninitialize ()
end program ExcelSample subroutine Check_Status (olestatus, errorMsg)
use adobjs integer (4) :: olestatus character (*) :: errorMsg if (olestatus> = 0) return
​ call releaseobjects ()
​ ! Freeing objects
 write (*, '(a, "; OLE error status = 0x", z8.8, "; Aborting")') trim (errorMsg), olestatus stop

[1] .3. Generic and specific names
Many of the built-in procedure names are generic. For instance,

