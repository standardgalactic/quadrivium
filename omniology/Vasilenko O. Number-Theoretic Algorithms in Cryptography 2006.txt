Translations of
MATHEMATICAL
MONOGRAPHS
Volume 232
Number-Theoretic 
Algorithms 
in Cryptography
O. N. Vasilenko
American Mathematical Society

Number-Theoretic
Algorithms 
in Cryptography

Translations of
MATHEMATICAL
MONOGRAPHS
Volume 232
Number -Theoretic
Algorithms 
in Cryptography
O. N. Vasilenko
Translated by
Alex Martsinkovsky
^/'tphtoe mhvv
American Mathematical Society 
vfinfin //f Providence, Rhode Island

EDITORIAL COMMITTEE
AMS Subcommittee
Robert D. MacPherson Grigorii A. Margulis James D. Stasheff (Chair) 
ASL Subcommittee Steffen Lempp (Chair) 
IMS Subcommittee Mark I. Freidlin (Chair)
O. H. BacHJienKO
TEOPETKKO-MKCJIOBblE AJIFOPKTMbl B KPHIITOrPA^KK
MUHMO, MocKBa, 2003
This work was originally published in Russian by MIIHMO under the title 
“TeopeTHKO-uncjiOBBie ajiropnTMBi b KpnnTOrpa(j)nn”©2003. The present 
translation was created under license for the American Mathematical Society 
and is published by permission.
Translated from the Russian by Alex Martsinkovsky
2000 Mathematics Subject Classification. Primary 11T71; Secondary 94A60.
For additional information and updates on this book, visit
www.ams.org/bookpages/mmono-232
Library of Congress Cataloging-in-Publication Data
Vasilenko, O. N. (Oleg Nikolaevich)
[Teoretiko-chislovye algoritmy v kriptografii. English]
Number-theoretic algorithms in cryptography / O. N. Vasilenko ; translated by Alex 
Martsinkovsky.
p. cm. — (Translations of mathematical monographs ; v. 232)
Includes bibliographical references and index.
ISBN-13: 978-0-8218-4090-0 (alk. paper)
ISBN-10: 0-8218-4090-8 (alk. paper)
1. Number theory. 2. Algorithms. 3. Cryptography—Mathematics. I. Title. II. Series.
QA241.V2913 2006
512.7—dc22 
2006047711
Copying and reprinting. Individual readers of this publication, and nonprofit libraries 
acting for them, are permitted to make fair use of the material, such as to copy a chapter for use 
in teaching or research. Permission is granted to quote brief passages from this publication in 
reviews, provided the customary acknowledgment of the source is given.
Republication, systematic copying, or multiple reproduction of any material in this publication 
is permitted only under license from the American Mathematical Society. Requests for such 
permission should be addressed to the Acquisitions Department, American Mathematical Society, 
201 Charles Street, Providence, Rhode Island 02904-2294, USA. Requests can also be made by 
e-mail to reprint-permissionQams.org.
© 2007 by the American Mathematical Society. All rights reserved.
The American Mathematical Society retains all rights 
except those granted to the United States Government. 
Printed in the United States of America.
@ The paper used in this book is acid-free and falls within the guidelines 
established to ensure permanence and durability.
Visit the AMS home page at http: //www. ams. org/
10 9 8 7 6 5 4 3 2 1 
12 11 10 09 08 07

Contents
Preface to the English Edition 
ix
Preface 
xi
Notation 
xiii
Chapter 1. Primality Testing and Construction of Large Primes 
1
1.1. Introduction 
1
1.2. Elementary methods of primality testing 
1
1.3. Primality tests for numbers of a special form 
3
1.4. 
(TV ± l)-methods for primality testing, and construction of large 
primes 
8
1.5. The Konyagin-Pomerance algorithm 
13
1.6. Miller’s algorithm 
15
1.7. Probabilistic primality tests 
19
1.8. Modern methods for primality testing 
23
1.9. Summary. A deterministic polynomial algorithm for primality testing 27
Chapter 2. Factorization of Integers with Exponential Complexity 
35
2.1. Introduction. Fermat’s method 
35
2.2. Pollard’s (P — l)-method 
37
2.3. Pollard’s p-method 
39
2.4. The Sherman-Lehman method 
40
2.5. Lenstra’s algorithm 
42
2.6. The Pollard-Strassen algorithm 
47
2.7. Williams’ (P + l)-method and its generalizations 
48
2.8. Shanks’ methods 
48
2.9. Other methods. Summary 
49
Chapter 3. Factorization of Integers with Subexponential Complexity 
51
3.1. Introduction 
51
3.2. Dixon’s method. Additional strategies 
52
3.3. The Brillhart-Morrison algorithm 
55
3.4. Quadratic sieve 
58
3.5. The methods of Schnorr-Lenstra and Lenstra-Pomerance 
61
3.6. Number field sieves 
62
3.7. Summary 
71
Chapter 4. Application of Elliptic Curves to Primality Testing and 
Factorization of Integers 
73
4.1. Introduction. Elliptic curves and their properties 
73

vi
CONTENTS
4.2. Lenstra’s algorithm for factorization of integers using elliptic curves 75
4.3. Computing the order of the group of points of an elliptic curve over a 
finite field 
78
4.4. Primality testing using elliptic curves 
84
4.5. Summary 
87
Chapter 5. Algorithms for Computing Discrete Logarithm 
91
5.1. Introduction. Deterministic methods 
91
5.2. Pollard’s p-method for the discrete logarithm problem 
93
5.3. The discrete logarithm problem in prime fields 
93
5.4. Discrete logarithm in Galois fields 
96
5.5. Discrete logarithm and the number field sieve 
99
5.6. Fermat quotient and discrete logarithm with composite modulus 
102
5.7. Summary 
113
Chapter 6. Factorization of Polynomials over Finite Fields 
115
6.1. Introduction. A probabilistic algorithm for solving algebraic equations 
in finite fields 
115
6.2. Solving quadratic equations 
118
6.3. The Berlekamp algorithm 
121
6.4. The Cantor-Zassenhaus method 
125
6.5. 
Some other improvements of the Berlekamp algorithm 
127
6.6. A probabilistic algorithm for irreducibility testing of polynomials over 
finite fields 
129
6.7. Summary 
131
Chapter 7. 
Reduced Lattice Bases and Their Applications 
135
7.1. Introduction. Lattices and bases 
135
7.2. LLL-reduced bases and their properties 
136
7.3. An algorithm for constructing an LLL-reduced lattice basis 
138
7.4. The Schnorr-Euchner algorithm and an integral LLL algorithm 
140
7.5. 
Some applications of the LLL algorithm 
143
7.6. The Ferguson-Forcade algorithm 
147
7.7. Summary 
156
Chapter 8. Factorization of Polynomials over the Field of Rational Numbers 
with Polynomial Complexity 
159
8.1. Introduction 
159
8.2. The LLL factorization algorithm: Factorization modulo a prime 
160
8.3. The LLL factorization algorithm: Using lattices 
161
8.4. The LLL factorization algorithm: Lifting the factorization 
165
8.5. The LLL factorization algorithm: A complete description 
167
8.6. A usable factorization algorithm 
168
8.7. Factorization of polynomials using approximations 
169
8.8. Summary 
174
Chapter 9. 
Discrete Fourier Transform and Its Applications 
175
9.1. Introduction. Discrete Fourier transform and its properties 
175
9.2. Computing the discrete Fourier transform 
176
9.3. Discrete Fourier transform and multiplication of polynomials 
177

CONTENTS 
vii
9.4. 
Discrete Fourier transform and polynomial division 
181
9.5. 
Applying the discrete Fourier transform to the Pollard-Strassen
algorithm 
183
9.6. 
Summary 
185
Chapter 10. High-Precision Integer Arithmetic 
187
10.1. Introduction. Addition and multiplication 
187
10.2. Multiplication 
188
10.3. Division 
191
10.4. 
Some algorithms of modular arithmetic 
198
Chapter 11. Solving Systems of Linear Equations over Finite Fields 
203
11.1. Introduction 
203
11.2. 
Solving linear systems in integers 
204
11.3. Gaussian and structured Gaussian elimination 
207
11.4. The Lanczos algorithm 
208
11.5. The Wiedemann algorithm 
211
11.6. Other methods. Summary 
214
Appendix. Facts from Number Theory 
215
Bibliography 
223
References added in the English edition 
233
Index 
241


Preface to the English Edition
The American Mathematical Society has honored me by deciding to translate 
this book into English.
This book is of a theoretical nature and contains descriptions and proofs of cor­
rectness for basic number-theoretic algorithms. It provides an overview of modern 
algorithmic number theory, including the most recent results.
About 150 new items have been added to the bibliography. Mostly, they are 
mentioned for reference purposes, without providing detailed descriptions of their 
results. Many of the added papers can be found in the Cryptology ePrint Archive 
(http://www.iacr.org).
The author is grateful to I. E. Shparlinski for advice and for a number of useful 
comments on the contents of the book. The author also thanks C. Pomerance 
and T. Denny for important and interesting papers that they sent to him in the 
mid-1990s.


Preface
This book deals with algorithmic number theory, a rapidly developing, espe­
cially in the last thirty years, branch of number theory, which has important appli­
cations to cryptography. Its explosive growth in the 1970s was related to the emer­
gence of the Diffie-Hellman and RSA cryptosystems. By some estimates, practically 
the entire world arsenal of asymmetric cryptography is based on number-theoretic 
techniques.
For the needs of cryptography (in terms of practical implementation and se­
curity of cryptographic tools, as well as for the development of methods for their 
breaking) improving the efficiency of the following methods and algorithms becomes 
critically important:
• algorithms for primality testing of integers;
• factorization methods (i.e., methods for factoring integers);
• computations using elliptic curves over finite fields;
• algorithms for computation of the discrete logarithm;
• factorization methods for polynomials over finite fields and over the ratio- 
nals;
• methods for solving linear systems over finite fields;
• algorithms for performing arithmetic operations on large integers;
• algorithms for polynomial arithmetic.
In this book we tried to describe the current state of algorithmic number theory, 
and give sufficiently accurate descriptions of the used algorithms. Some of the more 
complicated algorithms and methods (such as primality testing using trigonometric 
sums or the number field sieves) are only mentioned in the form of general schemes. 
We also tried to provide (in a survey-like manner) many references to the existing 
literature. An interested reader can augment our list of reference by turning to the 
monographs [22, 69], as well as to the Internet sites www.cryptography.ru and 
www.math.uga.edu/"ntheory.
This book is based on the courses in algorithmic number theory that the au­
thor gave at the Mathematics and Mechanics Department of Moscow State Uni­
versity from 1993 to 2001. For a number of years, the author also ran seminars 
on number-theoretic algorithms at MSU and, more recently, the seminar “Number- 
theoretic algorithms in cryptography” at the chair of information security of the 
MSU (jointly with the member of the Cryptography Academy of the Russian Feder­
ation V. M. Sidelnikov). A number of results mentioned in this book were obtained 
by the author jointly with the members of the Laboratory of Mathematical Prob­
lems of Cryptography at MSU.

xii
PREFACE
This is not a book on elementary mathematics. Reading it requires serious 
preparation, say, two or three years of studying typical mathematics courses at a 
university.
We assume that the reader is familiar with number theory, as covered by 
I. M. Vinogradov’s “An introduction to the theory of numbers” (any edition). 
Some parts of the book require familiarity with continued fractions (see, for exam­
ple, [117, 130]). For the convenience of the reader we collected the basic definitions 
and facts in the Appendix. Some sections require the basic facts from the theory of 
finite fields (see, for example, [153]) as well as basic algebraic number theory (see, 
for example, [261]). At some places, deeper facts from algebraic number theory 
are needed; in that case we provide references in the text. Among the textbooks 
on cryptography we recommend [11].
Many algorithms mentioned here use auxiliary algorithms for computing the 
greatest common divisor of integers and for exponentiation. Such algorithms are 
well known and can be found in many texts; see, for example, [118, 57, 22]. 
We mention those algorithms in the Appendix, some of them without a proof of 
correctness.
Whenever we say that an algorithm requires a certain number of arithmetic 
operations, we mean arithmetic operations (addition, subtraction, multiplication, 
and division) with large integers (high-precision arithmetic).
The complexity of an algorithm is the number of arithmetic operations it per­
forms. Normally, the complexity is represented as a function of the length of the 
input, i.e., of the number N of bits required to store the input. If this function is a 
polynomial in TV, one says that the algorithm has a polynomial complexity (poly­
nomial algorithm); if this function is of the form L//[7;c] = e^+^^OogN)1 7> 
where 0 < 7 < 1 and c = const, c > 0, then the complexity estimate for 
the algorithm is said to be subexponential with exponent 7; if the function is 
of the form ecjV, where c = const, then the algorithm has an exponential com­
plexity. For example, let n e N and we want to factor n. The length of the 
input equals N = [log2n] + 1 = O(logn). Then a polynomial factorization al­
gorithm has complexity O((log n)c), a subexponential algorithm has complexity 
e(c+o(i))(iogn)7(iogiogn)1 and an exponential algorithm, complexity O(nc).
We say that a number is B-smooth if all of its prime factors are less than or 
equal to B (here B is a positive number, called the smoothness boundary). An 
integer is said to be B-power-smooth if each of its primary factors (the powers of 
primes) is at most B.
We use the symbol log x to denote the natural logarithm of the positive num­
ber x.
The author is grateful to A. A. Salnikov, V. V. Yashchenko, and D. V. Matyu­
khin for their help during the work on this book, many discussions, and their advice 
leading to numerous improvements of the manuscript.
The author also thanks D. V. Matyukhin for the big job of technical editing of 
the manuscript.

Notation
N 
Z 
Z>o 
R 
R>a 
c 
p 
|S|,#S 
Rea 
Im a 
a | b 
a\b 
pfe||a 
b • a
(a, &),gcd(a, b)
the set of natural numbers;
the ring of integers;
the set of integers greater than or equal to a;
the field of real numbers;
the set of real numbers greater than or equal to a;
the field of complex numbers;
the set of prime numbers;
the number of elements in a set S;
the real part of a;
the imaginary part of a;
a divides i>;
a does not divide &;
pk divides a but pfe+1 does not divide a;
b is divisible by a (with integer quotient);
the largest k G Z>o such that ak | i>;
the greatest common divisor of a and &, where a and b are 
integers or polynomials over a field;
[a, &],lcm (a, b)
[a]
W
{a} 
const
a = b (mod c) 
a b (mod c)
the least common multiple of a and &;
the integer part of a;
the ceiling of a, i.e., the smallest n G Z such that n > a;
the fractional part of a;
a positive constant;
c divides a — b in the given ring (of integers or polynomials);
c does not divide a — &;
'LjpL, GF(p)^p the field of p elements, where p is a prime number;
GF(q) 
Z/nZ 
(Z/nZ)*
(^)n 
ord a
the field of q elements, where q is a power of a prime number;
the residue ring modulo n;
the group of multiplicatively invertible elements of the ring Z/nZ;
the group of multiplicatively invertible elements of a ring E;
the cyclic group of n elements generated by
the order of an element a in a finite group;
xiii

xiv
NOTATION
charK
«>W 
©.ft) 
7r(rr) 
logrr 
0
the characteristic of a field K;
the value of the Euler function on a natural number n;
Legendre and Jacobi symbols;
the Chebyshev function, the number of primes not exceeding x\ 
the natural logarithm of x\
a binomial coefficient, i choose j;
MT 
rankM
Z/(&1, . . . , &n)
nc[iEi,..., Xu ] 
deg/(z)
Res {f{x),g(x)') 
y:=x
e(c+o(i))(iogx)^(iogiogx)1 7, 0(i) —> o for x —> +oo, c and 7 are constants; 
the transpose of a matrix (or vector) M;
the rank of a matrix M\
the linear hull of vectors &i,..., bn\
the orthogonal complement of a linear subspace L in a Euclidean space;
the ring of polynomials in £1,..., xn over a ring K;
the degree of a polynomial f(x)\
the resultant of polynomials f(x) and g(x)\
set y equal to x.

CHAPTER 1
Primality Testing 
and Construction of Large Primes
1.1. Introduction
A natural number p greater than one is said to be prime if it is divisible only 
by 1 and by itself. The fundamental theorem of arithmetic asserts that any natural 
number n greater than 1 can be factored into a product of primes and such a 
factorization is unique up to the order of the factors. The canonical factorization 
of a natural number n is of the form
n = p11 ---pk >
where pi < P2 < • • • < Pk are distinct primes and ai,..., 
6 N.
The problems of primality testing for a natural number and of constructing 
large primes have important applications in cryptography. In this chapter we de­
scribe various algorithms for solving those problems.
1.2. Elementary methods of primality testing
Suppose n e N. How does one check whether n is prime?
The method of trial divisions. If n is composite, then n = ab, where 1 < 
a < b and a < y/n. Thus, for d = 2,3,..., we check whether n is divisible 
by d. If a divisor of n is not found, then n is prime. Otherwise we have a prime 
factor of n, i.e., we have a factorization of n into a product of two numbers. The 
complexity of this method is Ofn1/2) arithmetic operations with integers.
There are modifications of this method. For example, we can check whether n 
is divisible by 2 and by 3, and if not, then we only test the numbers d of the form 
1 + 6J and 5 + 6j, j = 1,2,... . The complexity of this method differs from that of 
the previous method only by the constant in O(-) (see also [284]).
The sieve of Eratosthenes. If we want to make a table of all primes among 
the numbers 2,3,..., TV, then we cross out all the numbers divisible by 2, except 2. 
Then we cross out all the numbers divisible by 3. Then we take the next number 
on the list (i.e., 5) and cross out all the numbers divisible by it, etc. In the end only 
primes will remain. To implement this method on a computer one needs a large 
memory, but for making tables of primes this method is the best.
In [69, Ch. 3] one can find efficient algorithms implementing the sieve of Er­
atosthenes for making tables of primes and computing factor bases.
1

2
1. PRIMALITY TESTING AND CONSTRUCTION OF LARGE PRIMES
Tests based on Fermat’s Little Theorem. For primality testing of num­
bers n of order 1O3°-1O40 the method of trial divisions cannot be used. The next 
test is based on Fermat’s Little Theorem: If n is prime, then, for any a 6 Z, one 
has
an = a (mod n);
if, in addition, (a, n) = 1, then
an-i । (mod n).
Thus for primality testing of n we can choose some number a e Z and verify 
Fermat’s Little Theorem in O(logn) arithmetic operations (using binary exponen­
tiation in the ring Z/nZ). If the conclusion of Fermat’s Little Theorem fails, then 
n is composite. If it holds, then we cannot yet conclude that n is prime because the 
theorem only gives a necessary condition. This test is efficient for detecting large 
composite numbers. For example, for 100-digit numbers n of the form
n = 10"+ 5, 
5 = 1,3,5,7,...,
we ran the test 13n-1 = 1 (mod n), and the first ten numbers satisfying this con­
dition, later turned out to be prime (further primality testing was based on the 
Cohen-Lenstra algorithm; see below).
There are, however, composite numbers n, called Carmichael numbers, such 
that for any a e Z one has an = a (mod n). The smallest such n is 561 = 3-11-17. 
We now show that 561 is a Carmichael number. The congruence a561 = a (mod 561) 
is equivalent to a561 = a (mod 3), a561 = a (mod 11), and a561 = a (mod 17). 
If 3 | a, then a561 = a = 0(mod 3). If 3 j a, then a2 = 1 (mod 3), whence 
a560 = 1 (mod 3) and a561 = a (mod 3). A similar argument works for 11 and 17. 
In [12] it was shown that there are infinitely many Carmichael numbers.
Thus Fermat’s Little Theorem alone is not enough for primality testing.
Definition 1.1. Let n > 1 be an odd natural number, n — 1 = 2s • d, where d 
is odd. The number n is said to be strictly pseudoprime to the base a, a G N, if 
(a,n) = 1 and either ad = 1 (mod n) or ad'2r = —1 (mod n) for some r, 0 < r < s.
As a motivation for this definition, we offer the following argument. If n is 
prime, then Z/nZ is a field, and an-1 = 1 (mod n), i.e., a2S'd = 1 (mod n). Thus 
a2s 1-d = ±l(mod n). If a2* 1,d = — 1 (mod n), then we stop, and if a23 1,d = 
1 (mod n), we again extract a square root until we either reach ad or the square 
root is congruent to —1.
Using empirical approach, the following primality test for odd numbers n, 7 < 
n < 25 • 109, was obtained in [216].
Step 1. Verify that n is pseudoprime to the bases 2, 3, 5, 7. If n is not 
pseudoprime to one of those bases, then it is composite.
Step 2. If n = 3,215,031,751, then n is composite; otherwise it is prime.
Thus the pseudoprimality test is efficient for detecting composite numbers, 
but it is only necessary for the primality of a number. In [264], one can find an 
algorithm containing necessary and sufficient conditions for primality testing of 
numbers n < (67107840)2. Besides pseudoprimality, it also uses some properties of 
Fermat numbers.
Some new results on pseudoprimality testing were obtained in [13]. In particu­
lar, it was shown that there are infinitely many odd composite numbers n for which 

1.3. PRIMALITY TESTS FOR NUMBERS OF A SPECIAL FORM
3
the smallest co(ri) e N such that n is not strictly pseudoprime to base u;(n) satisfies 
the inequality
w(n) > (logn)31°gloglog\
For more on elementary methods of primality testing, see the surveys [284, 262] 
and the monograph [42].
1.3. Primality tests for numbers of a special form
Consider first the numbers n of the form n = 2m + 1, where m e N. If m is 
divisible by a prime p > 2, i.e., m = pm^ m\ > 1, then n = (2mi)p + 1 is divisible 
by 2mi + 1, and is composite. Thus n could be a prime only when m = 2k.
Definition 1.2. The numbers Fk = 22 + 1, k = 0,1,2,..., are called Fermat 
numbers.
It is now known that Fq, Fi, F2, F3, and F4 are prime, and that all the 
consequent Fermat numbers which have been tested for primality, turned out to 
be composite. For example, such a testing is possible for F23471 (it is a record, 
established in 1984 [141]), but at the same time it is not known whether F31 is 
prime or composite ([69]).
For primality testing of Fermat numbers we have the following test.
Theorem 1.3. A number n = Fk, k > 0, is prime if and only if
= —1 (mod n).
PROOF. We begin with the “if” part. Since n — 1 = 22k is a power of 2, the 
order of 3 (mod n) equals n — 1 = 22 . Therefore, (Z/nZ)* contains at least n — 1 
elements, and thus all nonzero elements of Z/nZ are invertible, i.e., n is a prime.
The “only if” part. Note that 22k = 42k 1 = 1 (mod 3). Therefore, n > 3, 
n = 2 (mod 3), n = 1 (mod 4). By the quadratic reciprocity law, (^) = Q|) • 
n —1 3-1 
n —1
(—1) 2 
2 = (|) = (j) = —1; and, by Euler’s criterion, (^) = 3 2 (mod n).
□
The above test requires O(logn) arithmetic operations modulo n, but Fermat 
numbers grow very fast, and the test quickly becomes inefficient.
Next we consider numbers n of the form n = 2m — 1. If m is composite, m = ab, 
1 < a <b, then n = 2ab — 1 is divisible by 2a — 1. Therefore n can be prime only 
when m is prime.
Definition 1.4. Suppose that both p and Mp = 2P — 1 are prime. Then Mp 
is called a Mersenne number.
Using Mersenne numbers one gets all even perfect numbers; they are of the 
form 2P-1 • Mp. The Mersenne numbers are extremely rare; the 39th Mersenne 
number M13466917 was found in 2001. For more on Mersenne numbers see [192, 
Supplements 5.1, 5.2].
For primality testing of Mersenne numbers one uses the following test.
Theorem 1.5. Let q be a prime number, q > 2, and n = 2q — 1. Define a 
sequence Lq, Li, Li,.. ., by
Lo = 4; 
= L2 — 2 (mod ri).
Then n is primeif and only if Lq-2 = 0 (mod ri).

4
1. PRIMALITY TESTING AND CONSTRUCTION OF LARGE PRIMES
The proof of this theorem will be given at the end of this section.
Some results on primality of Fermat numbers were obtained in [264]. We have, 
for example, the following theorem.
Theorem 1.6. Let p be a prime number, p = 3 (mod 4), and Mp = 2P—1 a 
Mersenne number. The Fermat number Fp is prime if and only if
= -1 (mod Fp).
Proof. The proof of the “if” part is similar to that of Theorem 1.3. Now we 
prove the “only if” part. By Fermat’s Little Theorem, 22P-1 = 2 (mod Mp), and 
hence Fp = 2 • 22P-1 + 1 = 5 (mod Mp). Therefore, (Fp, Mp) = 1. Now
(we used Euler’s criterion and the quadratic reciprocity law for the Legendre sym­
bol). Now, Mp = 24k+3 — 1 = 23 — 1 (mod 5) = 2 (mod 5), and (^) = (|) = 
-1. □
Before proving Theorem 1.5, we need to study sequences of Lucas numbers.
Those sequences are also used in the more general N + 1 method for primality 
testing (see the next section).
Definition 1.7. The sequences uq,ui,U2,... and vq,^i,^2, • • •, where uq = 0, 
ui = 1, vq = 2, Vi = 4, and the subsequent terms are obtained by the recurrence 
relation xj+i = 4xj — Xj-i, are called the sequences of Lucas numbers.
Clearly, u% = 4, u$ = 15, V2 = 14.
Lemma 1.8. Vj = Uj+i — Uj-i for j > 1.
PROOF. For j = 1,2 the assertion is obvious. Suppose it is true for all indices 
not exceeding j. For j > 2, we have
Vj+l = 4Vj - Vj-! = 4(uj+! - Uj-i) - (Uj - Uj-2) 
= 4uj+i - Uj - (4uj-i - Uj-2) = Uj+2 - Uj. 
□
Lemma 1.9. u, = 
for j = 0,1,2,... .
PROOF. For j = 0,1 the assertion is obvious. The characteristic equation for 
the recurrence relation is A2 — 4A + 1 = 0 with roots 2 ± y/3. The desired assertion 
is now obvious. 
□
Lemma 1.10. v, = (2 + Vty + (2 - yfity for j = 0,1,2,... .
The proof is similar to the above.
Lemma 1.11. Uj+k = UjUk+i — Uj-iuk whenever j — 1 > 0 and k>0.
Proof. We induct on j + fc = N. If N = 1, then j' = 1, k = 0, and the equality 
ui = UiUi — uqUq is obviously true.
Assuming the assertion is true for j + k < TV, we prove it for TV + 1. Represent 
TV + 1 as TV + 1 = j + (fc + 1). Then TV = j + k, N — 1 = j + (fc — 1),
WjV+l = 
~ ^N-l = 4(UjUk+l — Uj-iUk) — (UjUk — Uj-iUk-l)
= ^(4Ufc+i - Uk) ~ Uj-i(4uk ~ Uk-1) = UjUk+2 ~ ^-iUfc+1, 

1.3. PRIMALITY TESTS FOR NUMBERS OF A SPECIAL FORM
5
giving the desired assertion. The case N + 1 = (j + 1) + k is argued similarly. □
Lemma 1.12. u2n = ^n^n-
This follows from Lemmas 1.9 and 1.10.
Lemma 1.13. v2n = v\-2.
Proof. Indeed,
v2n = (2 + \/3)2n + (2 - x/3)2n, V2 = ((2 + ^)n + (2 - x/3)n)2 = v2n + 2. □
Lemma 1.14. Let p be a prime and e € N. If Uj = 0(mod pe), then uPj = 
0 (mod pe+1).
Proof. Let numbers a and b be such that Uj =pe -b and Uj+i = a. Then, by 
Lemma 1.11,
Uj(2uj+i — 4uj) = Uj(2(4uj — Uj-i) — 
= Uj(4uj — 2uj-x)
= Uj(uj+1 + Uj-i - 2uj-i) = UjUj+1 - Uj-iUj = u2j.
Therefore
u2j = b • pe(2a — 4bpe) = 2aUj (mod pe+1).
By Lemma 1.11,
U2j+1 = «b+i)+j = W>+1 - 
= a2 (mod pe+1).
Suppose that the following relations hold:
A) U(k-i)j = (k- l~)ak~2Uj (modpe+1);
B) U(fc_1)j+1 = afc-1 (mod pe+1).
Then, by Lemma 1.11, for kj = j + (k — l)j, we have 
ukj = u(k-l)j+luj ~ u(k-l)juj — l
= 
— (k — l)ak~2UjUj-i (modpe+1)
= afe-1Uj — (k — l)ak~2Uj(4uj — uj+i) (mod pe+1) 
= 
(mod pe+1).
For kj' + 1 = j' + 1 + (fc — l)j, we have
Ukj+1 = U(A;_1)J+1UJ+1 - u^k-^jUj = ak (modpe+1).
This means that relations A) and B) still hold when k — 1 is replaced by k.
Setting fc — 1 = p, we have
uPj = pap~1Uj (mod pe+1) 
= 0(mod pe+1), 
which yields the desired result. 
□
Lemma 1.15. We have
Uj= V (1 >)2J-2fc_13*:, Vj= V ^2J-2fc+13fc.
3 
+ lJ 
3 
. \2kJ
o<fc<^ 
o<fc<£

6
1. PRIMALITY TESTING AND CONSTRUCTION OF LARGE PRIMES
Proof. By Lemma 1.9, we have
_ 
V'' 
( j ] 2J—^2&+1) • 3fe
2^ 
V2& + 1/
0<Z=2fc+l<> x
The formula for Vj follows from Lemma 1.10.
□
Lemma 1.16. Ifp is an odd prime, then
Up = 3^ (mod p), vp = 2p+1 (mod p) = 4 (mod p).
Proof. Since (^) = 0 (mod p) for 0 < I < p, the result follows from Lemma
1.15. 
□
Lemma 1.17. Let U2 = 0 (mod 2) and U3 = 0 (mod 3). For any prime p, p > 3, 
there is e(p) € {±1} such that
up+e(p) = 0 (mod p). 
P-1 
Proof. By Lemma 1.16, for p > 3 we have up = 3 2 = ±1 (mod p). If 
Up = 1 (mod p), then, by Lemma 1.8,
Up-i = 4up — Up+i = 4 — vp — Up-i (mod p) = —up-i (mod p), 
and therefore e(p) = — 1.
If Up = — 1 (mod p), then
Up+i = 4up - Up-i = -4 + vp - Up+i (mod p) = -up+1 (mod p), 
and therefore e(p) = +1. 
□
Definition 1.18. Let N e N. The rank m(N) of N in the sequence {uj} is 
m(TV) = min {m > 1 | um = 0 (mod TV)} .
If such m does not exist, then m(TV) is not defined.
Lemma 1.19. If m(N) is defined, then Uj = 0(mod TV) if and only if j = 
0 (mod m(TV)).
Proof. Let m = m(TV) and a = um+i (mod TV). It follows easily from the 
recurrence relation that (uy,uj+i) = 1 for any j > 0. Hence (a,um) = 1. By 
Lemma 1.11, for j > 1 we have
= UjUm+i — Uj-iUm = UjUm+i (mod TV) = auj (mod TV).
Thus the terms of the sequence um, um+i, um+2,... are congruent modulo TV 
to the terms of the sequence auo, aui, au2,....
Therefore, um+j is divisible by TV if and only if auj is divisible by TV, which is 
equivalent to saying that TV divides Uj. The desired result follows. 
□
Lemma 1.20. The numbers Lj of Theorem 1.5 satisfy Lj = v2j (mod n).
Proof. Clearly Lq = up If the assertion of the lemma is true for j, then, 
applying Lemma 1.13, we have
= (Lj — 2) (mod n) = v%j — 2 (mod n) = v2j+i (mod n), 
which yields the desired result. 
□

1.3. PRIMALITY TESTS FOR NUMBERS OF A SPECIAL FORM
7
Lemma 1.21. If j > 0, then:
1) (uj'Uj+r) = 1;
gcd(uj,^) < 2.
Proof. The first assertion was verified in the proof of Lemma 1.19. The second 
follows from the first and from the equality 2uj+i = 4uj+Vj, which holds by virtue 
of Lemma 1.8. 
□
Now we can prove Theorem 1.5.
The “if” part. Let Lq-2 = 0(mod n). Then, by Lemma 1.20, v2«-2 = 
0 (mod 2q — 1). By Lemma 1.12,
u29-i = w2?-2v2q-2 = 0 (mod 2q — 1).
In view of Lemma 1.21, Uj and Vj have no common odd prime factors and therefore 
u2q-2 
0 (mod 2q — 1).
Let m = m(2q — 1) be the rank of n = 2q — 1 in the sequence {uj}. The 
number m is defined, and, by Lemma 1.19, m divides 29-1 but does not divide 
2q~2. Hence m = 2q~1 = ^±1.
Assuming that n is composite, we will derive a contradiction. Let n = p^1 • • -pfr 
be the factorization of n into prime factors, and assume that either r > 1 or ei > 1. 
For each j we have pj > 3, because n = (—I)9 — 1 = —2 (mod 3).
Let
t = 1cm (Pi1-1(P1 + £1), • • • 
+ Er))>
with £j = e(pj) G {±1} defined in Lemma 1.17. Then ut = 0 (mod 2q — 1) by 
Lemmas 1.14, 1.17, and 1.19. Therefore, by Lemma 1.19, t is divisible by m =
Let
r
no = n +£j)-
j=l
Since pj > 5, we have
=n(|)r.
J=1
As the numbers Pj + £j are even, we have that t < ^r- Then
m < t < (7) n/2r~1 = 2 • 
• n.
\5/ 
\5/
Since n = 2m — 1 < 2m and 4 • (|)r < 4 • j < 3, we have
Moreover, when r > 3, we have 4 • (|)r < 4 • 
< 1. Therefore, r = 1 or 2.
Since t is divisible by m and m < t < 3m, we also have that either t = m = 29-1 
or t = 2m = 2q. Thus t is a power of 2. The definition of t now shows that 
ei = 1 = er. Furthermore, pi + £i and pr + er are powers of 2, i.e., Pi + £i = 2k 
and P2 + ^2 = 2Z. If n is composite, then r = 2, and therefore
n = 2q — 1 = (2fe ± 1)(2Z =F 1)

8
1. PRIMALITY TESTING AND CONSTRUCTION OF LARGE PRIMES
(ci = -s2 since n = -1 (mod 4)). Thus 2q = 2k+l ± 2l =F 2k. Since each summand 
is divisible by 2max(fc’Z\ we have k = 1. Then n = 2q — 1 = (2k + l)(2fc — 1), contrary 
to the fact that q is odd. This proves the “if” part.
The “only if” part. Let n = 2q — 1 be a prime number. We show that v2g-2 = 
0 (mod n), which, by Lemma 1.20, will imply that Lq-2 = 0 (mod n).
By Lemma 1.13, v2g-i = (v2«-2)2 — 2, hence we need to show that v2g-i =
—2 (mod n). Using the equality
2 ± x/3 =
and Lemma 1.10, we have
Since n is an odd prime, (n2V) = (2fc)!(n+i-2fc)! *s divisible by n for all k, except 
k = 0 and k = Therefore,
2~^~ • v2q_i = 1 + 3 2 (mod n).
and therefore
2 2 f2q-i = 1 + 3 • (—1) = —2 (mod n).
Since n = 2q — 1 = — 1 (mod 8), we have 
n —1 
/2\
2 2 = ( — ) = 1 (mod n). 
\n/
Thus v2g-i = —2 (mod n), which is the desired claim. Theorem 1.5 is proved.
Remark 1.22. Ribenboim’s books [219, 220] describe various records in the 
field of primality testing, including the ones related to Fermat and Mersenne num­
bers, twin primes (primes of the form p and p + 2), and other special primes.
Remark 1.23. It was recently shown in [334] that the Fermat number F24 is 
composite.
1.4. (TV ± l)-methods for primality testing, 
and construction of large primes
In this section we describe methods with which one can test primality of a 
natural number N if one knows the complete or a partial factorization of N — 1 or 
N + 1. For an excellent bibliography on this, see [284]. For more recent results, 
see the bibliography in [22]. We also describe some methods for constructing large 
primes which are widely used in cryptography. For other approaches, see [202, 67, 
247, 169].
First we prove a theorem on (TV — l)-methods of primality testing.

1.4. (N± 1)-METHODS FOR PRIMALITY TESTING 
9
Theorem 1.24. Suppose n e N, n > 1, n is odd, and n — 1 = Hi=i Pi* a 
known factorization of n — 1 into primes. If, for each i = 1,... ,k, there is ai e N 
such that 
n — 1
a™-1 = 1 (mod n), aiPi 1 (mod n), 
then n is a prime.
Proof. Let mi be the order of ai (mod n) in Z/nZ. Then mi | n — 1, 
mi \ (n — l)/pi, and therefore p?* | mi for i = l,...,k. Hence, each bi = 
a{ z Pi (mod ri) is of order p?* in (Z/nZ)*, and b = bi • • • bk (mod n) is of order 
Pi1 ’ ’ 'Pkk = ft — 1 in (Z/nZ)*. Therefore Z/nZ is a field, and n is prime. □
How does one use Theorem 1.24 in practice? Starting with the factorization of 
n — 1, and either running through a = 2,3,..., or choosing a randomly, we find a 
number ai satisfying the assumption of the theorem. If for some a, 1 < a < n, we 
have that an-1 1 (mod n), then n is composite. If we we have found ai,..., Ofc, 
then we have thus shown that n is prime.
Notice that we had in fact used the method of Theorem 1.24 applied to Fermat 
numbers (see Theorem 1.3 of 1.3). We did not have to determine the numbers ai, 
since we knew that a = 3.
A similar method can be applied when we know the complete factorization of 
n + 1.
Theorem 1.25. Let P, Q e Z, and D = P2 — 4Q 7^ 0. Define a sequence of 
Lucas numbers uq,Ui,. .. of the discriminant D by the relations: uq = 0, ui = 1, 
Uj+2 = Puj+1 — Quj for j > 0. Let n be an odd natural number, n > 1, n + 1 = 
n?=i prime factorization, and (B) = —1. If for each i = 1,... ,k there are 
numbers Pi, Qi G Z, D = P2 — 4Qif such that the corresponding Lucas sequence 
,... satisfies the conditions
then n is prime. If there is a Lucas sequence {uj} of the discriminant D such that 
n { un+i, then n is composite.
This theorem belongs to the so-called (TV+l)-methods of primality testing. The 
proof of it, as well as other (TV + l)-methods, are beyond the scope of this book. 
Notice that the simplest case, related to primality testing of Mersenne numbers, 
was considered in 1.3, Theorem 1.5.
Returning to the (TV — l)-methods of primality testing, we want to show how 
one can construct large primes.
Theorem 1.26. Let n G N, n > 1, n is odd, and n — 1 = Fi • Ri, where 
(Fi, Bi) = 1. Suppose Fi = Hj=i Qjj a complete prime. If for any j = 1,. ..,k 
there is aj G N such that
dj-1 = 1 (mod n), (ajn — l,n) = 1, 
then, assuming
Fi > y/n,
the number n is prime.

10
1. PRIMALITY TESTING AND CONSTRUCTION OF LARGE PRIMES
PROOF. Let p be an arbitrary prime factor of n. We show that p > y/n, which 
will imply that n is prime. It follows from a™-1 = 1 (mod n) that a™-1 = 1 (mod p). 
Hence (aj,p) = 1 and the order ej of aj (mod p) in Z/pZ divides n — 1. Moreover, by 
Fermat’s Little Theorem, ej | p— 1. It follows from the assumptions that a™
1 (mod p), and thus q*j | ej. Therefore, q*j | p — 1 and thus Fi = IIj=i I P ~ 1- 
Consequently, p — 1 > Fi and p > Fi > y/n. 
□
Using Theorem 1.26, we can construct large primes. We will construct a se­
quence of primes pi < P2 < P3 < • • • until we obtain a prime of desired magnitude. 
The odd prime pi can be chosen arbitrarily, say, pi = 3. Assume that the prime Pi-i 
has been constructed. Choose a random r, 1 < r < Pi-i — 1. Let r = 2s •£, where t is 
odd. As a candidate for the next prime pi choose n = 2rpi-i +1 = 2s+1pi-i • t + 1. 
Set Fi = 2s+1pi-i and Ri = t. Clearly, (Fi,/?i) = 1. Now Fi > y/ri, because 
n = 2s+1pi-\t + 1 < 2s+2pi-it < 2s+2p2_1 < F2. Therefore, to prove that n is 
prime, we need to find (by trial and error) numbers czi and a2 such that
a™-1 = ag-1 = 1 (mod n), ( ar 2 — 1, n j = ( a^1 ~ n) = 1-
If, during the search, we find a such that either an-1 1 (mod ri) or one of the two 
greatest common divisors with n is a nontrivial divisor of n, then n is composite; 
in that case choose another random r (and another ri). If we can show that n is 
prime, then we set pi = n.
Another way of applying Theorem 1.26 is as follows. We again construct a 
chain of primes. Suppose Pi-i > 3 has already been constructed. Chose at random 
an even number r, 1 < r < pi-i — 3, and set n = Pi-ir + 1. Let Fi = Pi-i, Ri = r, 
and (Fi, Ri) = 1. We need to find a natural number a such that an-1 = 1 (mod ri) 
and (ar — l,n) = 1 (because = r). Indeed, Fi = pi-i > y/n, since
n = Pi-ir + 1 < 
(pt-! - 3) + 1 = pj_i - 3pi_! +1
<Pi-i -3-5 + 1 <Pi-!-
The number a is found the same way as in the previous method.
The next theorem is more efficient for constructing large primes, because it 
does not require computing greatest common divisors.
Theorem 1.27. Let n = 2rg+1, where q is an prime, and r < 2q +1. If there 
is a G N such that
an-i । (mod ri), a2r 1 (mod ri), 
then n is a prime.
Proof. Suppose n is composite, n = pN, where p is a prime and N > 1. Since 
n { a2r — 1, there is a prime factor of n which enters n to a power greater than that 
fora2r —1. We denote it p. Thenz/p(n) > vp(a2r —1), and, for s = vp(a2r —1)+1 > 1, 
we have ps | n and ps { a2r — 1.
Let d be the order of a (mod ps) in Tijp8^. Then d | n — 1 = 2rq, since 
an-i = । (mod ri). Also, d | <p(ps) = ps-1(p — 1). Since a2r / 1 (mod ps), we have 
d { 2r. Hence, q | d and therefore q | ps-1(p — 1). The numbers q and p are distinct, 
because p | n and q | n - 1. Thus q | p - 1. Therefore p = 1 (mod q), and, as p 
and q are odd, we have p = 1 (mod 2q). Moreover, n = 1 (mod 2q). Since n = pN, 
we have N = 1 (mod 2q). As p > 1 and N > 1, we have p > 1 + 2q, N > 1 + 2q,

1.4. (N ± 1)-METHODS FOR PRIMALITY TESTING
11
and therefore n = pN > (1 + 2g)2. But n = 2rq + 1 < 2g(2g + 1) + 1 < (1 + 2g)2, 
which is a contradiction. 
□
Remark 1.28. Theorem 1.27 also gives rise to a method of constructing large 
primes, similar to the ones considered before.
Remark 1.29. If the inequality r < 2g + 1 is replaced by r < 2g + 2, then 
the assertion of Theorem 1.27 that n is prime is not true. One can even give an 
example of a and n for which the assumptions of the theorem still hold but n is 
composite. The next theorem shows how to make an upper bound for r greater.
Theorem 1.30. Let n = 2rq + 1, where q is a prime and r < 4g + 2. Suppose 
there is a number a e N such that
an-i J (mod n), a2r 1 (mod n).
Then either n is a prime, or n = p2, where p = 2q + 1 is a prime and ap-1 = 
1 (mod p2).
Proof. Suppose n is composite, n = pN, where p and N are the same as in 
the proof of Theorem 1.27. We showed that
n = p = N = 1 (mod 2g).
If one of the numbers p and N is strictly greater than 1 + 2g, then it is greater 
than or equal to 1 + 4g, and then n = pN > (1 + 2g)(l + 4g) = 8g2 + 6g + 1. 
By assumption, n < 2g(4g + 2) + 1 = 8g2 + 4g + 1. Therefore, p = N = 1 + 2g 
and n = p2. It remains to show that ap-1 = 1 (mod p2). Indeed, by assumption, 
ap -1 = 1 (mod p2), and, by Euler’s theorem, ap ~p = 1 (mod p2), which yields the 
required congruence. 
□
Remark 1.31. If g is known, then the equality n = (2g + I)2 is easy to ver­
ify. More precisely, having determined a, we can find out whether n is prime or 
composite. The test of Theorem 1.30 is very efficient for constructing large primes, 
since the greater an upper bound for the random number r, the greater the “step” 
for constructing the next prime number.
In Theorems 1.26-1.30, the magnitude of the factored part of n — 1 is of order 
y/n. The next result weakens that order to n1/3 (see [67]).
Theorem 1.32. Let n be an odd number, n > 1, and n — 1 = FiRi, where 
(Fi,Ri) = 1, Fi is even, and the complete prime factorization of Fi is known. 
Suppose that for any prime factor q of Fi there is a number aq € N such that 
a™-1 = 1 (mod n), 
(a^n-1^9 — 1, n) = 1.
Let m e N be such that for each I = 1,2,..., m — 1 we have IFi + 1 { n. If
n < (mFi + 1)(2FX2 + (L - m)Fi + 1),
where Ri = 2F\Li +L,1 < L < 2Fi, then n is a prime if and only if either Ri = L 
or L2 — 8Li is not a perfect square.
For a survey on (TV ± l)-methods of primality testing, see [284, 262].
Primality tests for numbers of the form A • 2s + 1, where A < 2s, have recently 
been studied in [311].

12
1. PRIMALITY TESTING AND CONSTRUCTION OF LARGE PRIMES
A number of results on constructing large primes, based on the (TV — l)-method 
and tests that use trigonometric sums, can be found in [263]. For example, we have 
the following result.
Theorem 1.33. Suppose n G N, n > 1, (30, n) = 1, and i is the imaginary 
unit. Assume, in addition, that:
1) 3(71—1)/2 _ 
(mod n).
2) If n = 1 (mod 8), then there is a number a e N such that a(n-1>/2 = 
—1 (mod ri);
3) ifn = 3,5 (mod 8), then 2^n~1^2 = —1 (mod ri);
4) if n=l (mod 4), then, for i = (—I)1/2 G C,
(2i + l)^"1)/2 • 5(n"1)/4 = C (mod nZ[i]), 
and if n = 3 (mod 4), then
(2i + l)<n+1)/2 • 5(n"3)/4 = C (mod nZ[i]),
where £4 = 1;
5) ifn = 7 (mod 8), then
5(n-1)/2 = —1 (mod n) 
and
(2i + l/n+1)/2 • 5(n"3)/4 = C (mod nZ[i]), 
where £ = i or £ = —i.
Then for any divisor s G N of n, the congruence s = ri (mod 240) holds for 
some j,0 < j < 3.
This theorem can also be used for constructing large primes. In this case, if a 
prime number Pj-i has already been constructed, then the next prime is assumed 
to be of the form n = rpj-i + 1, where r is a random even number with (r,pj-i) = 1 
and such that
r < 5760Qpj-i.
Thus, as an alternative to Theorem 1.32, we have a further improvement on the 
upper bound for the number r of Theorem 1.30.
Finally we remark that there are methods of primality testing combining infor­
mation about factorizations of both TV — 1 and TV +1, as well as using factorizations 
of TV2 + 1, etc. For more, see the surveys [284, 262].
Remark 1.34. Open-key cryptosystems often use the so-called strong primes. 
Such primes p have the property, in particular, that p — 1 and p + 1 have suf­
ficiently large prime factors (for various definitions of strong primes, see [423]). 
Strong primes can be constructed using the (TV ± l)-methods of primality testing; 
construction methods can be found, for example, in [360] and [423]. An efficiency 
comparison of strong primes and random primes can also be found in [423]. For 
generation of natural numbers suitable for use in the RS A cryptosystem, see [393].
We finish this section by describing the concept of primality certificate.
Definition 1.35. A Pratt certificate for an odd prime n is the set {pi,... ,Pfc,a} 
of all the distinct prime factors Pi of n — 1 and a natural number a such that
an-i । (mod ri), a(n~1^Pj 1 (mod n), j = 1,..., k.

1.5. THE KONYAGIN-POMERANCE ALGORITHM
13
If n is prime, then it has a Pratt certificate, even though finding it for a specific n 
may be nontrivial. If a Pratt certificate is known, then it can be used to show that n 
is prime in O(log2n) arithmetic operations.
There are other types of primality certificates; in particular, such a certificate 
can be constructed using elliptic curves. This will be discussed later in Chapter 4.
1.5. The Konyagin-Pomerance algorithm
If n e N and the complete prime factorization of n — 1 or a large part of it 
is known, then one can, in polynomial time, verify whether n is prime or compos­
ite. The best estimate for the complexity is obtained via the Konyagin-Pomerance 
algorithm [124].
Theorem 1.36. Let n e N, n > 1, n is odd, and n — 1 = Hj=i fy3 a 
known prime factorization of n — 1. Then the primality testing of n can be done 
) arithmetic operations.
Theorem 1.37. Let n e N, n > 1, n is odd, and n — 1 = FiRi, where 
i _|_e
(Fi,/?i) = 1, and the prime factorization of F± is known. If Fi > n4n , where e 
is a positive constant, then the primality testing of n can be done in O((log 
arithmetic operations (here c(e) is a positive constant depending on e).
We now give a simpler algorithm which, under the assumptions of Theo­
rem 1.36, determines whether n is prime or composite in O((logn)5) arithmetic 
operations. Henceforth we shall work under the assumptions and notation of the 
previous theorem. We shall assume that n > 5.
Lemma 1.38. Let a, m e N, am = 1 (mod n), and suppose that for any prime q 
dividing m we have (am/g —1, n) = 1. Ifp is a prime andp | n, thenp = 1 (mod m).
PROOF. Clearly, m is the order of a (mod n) in Z/nZ. Let p be a prime 
dividing n, and let k be the order of a (mod p). Then k = m. Indeed, k | m, 
because am = 1 (mod n) implies that am = 1 (mod p). If k < m, then there is a 
prime q, q | m, such that k | m/q. Then = 1 (mod p), i.e., p | (am^q — l,n), 
contrary to the assumption. By Fermat’s Little Theorem, ap-1 = 1 (mod p), and 
therefore, m | p — 1. 
□
An algorithm for primality testing.
Stage 1. Construct a table of all primes not exceeding [log2n] + 1. Let 
F(l) := 1. For each a = 2,3,..., [log2 n] + 1, run Stage 2 until it is shown that n 
is prime or that n is composite.
Stage 2.
Step 1. If a is composite (see the table in Stage 1), then set F(a) := F(a — 1) 
and go to Step 6. If a is prime and aF(a~1^ = 1 (mod n), then set F(a) := F(a — 1) 
and go to Step 6. Else, check the congruence:
fln-i । (mod n).
If it does not hold, then n is composite.
Step 2. Using the prime factorization of n — 1, find the order of a (mod n), 
i.e., the smallest natural number F(a) such that aE^ = 1 (mod n).

14
1. PRIMALITY TESTING AND CONSTRUCTION OF LARGE PRIMES
Step 3. Check the condition
gcdf JJ 
— l),n^ =1.
S|E(a) 
'
q prime
If it does not hold, then n is composite.
Step 4. F(a) := 1cm (F(a — 1), F(a)).
Step 5. If F(a) > -/n, then n is prime.
Step 6. If a < [log2n], then return to the beginning of Stage 2 for the next 
value of a. If a = [log2 n] + 1, then n is composite.
End of algorithm.
Now we show that the above algorithm is correct and estimate its complexity.
The table of primes from Stage 1 can be found using the sieve of Eratosthenes 
in O(log4n) arithmetic operations.
The running value of F(a) is a divisor of n — 1, and therefore Step 1 of Stage 
2 requires O(logn) operations (binary exponentiation).
Step 2 of Stage 2 requires O(log3n) operations when using the following aux­
iliary algorithm (see [57, Ch. 1]).
An algorithm for finding the order of an element.
The input for the algorithm consists of a, n e N, and a known prime factoriza­
tion n— 1 = IlJLi Pj3 of n — 1; the output of the algorithm is the order of a (mod n) 
in Z/nZ.
Step 1. M := n — 1, j := 0.
Step 2. j := j + 1, M := M/p*\ A := aM.
Step 3. (A loop.) For I = 0,1,..., otj check the congruence
A = 1 (mod n).
If true, go to Step 4. Else
M:=MPji A:=APj,
go to the next value of I in the loop.
Step 4. If j < N, go to Step 2; else output M.
End of algorithm.
The correctness of this algorithm for finding the order is obvious. To estimate 
its complexity, notice that
n- 1 > JJpj > 2n,
3 = 1
hence N = O(logn), Pj = O(logn), and aj = O(logn). Thus the outer and the 
inner loops make O(logn) steps, and at each step there are O(logn) arithmetic 
operations. The resulting complexity is thus O(log3 n) operations.
We now return to the algorithm for primality testing. If the gcd in Step 3 of 
Stage 2 is not equal to 1, then n is composite. Indeed, by the definition of F(a), 
none of the numbers aE^a^q — 1 is divisible by n. Hence, if the gcd is greater than 1, 
then one of the numbers aE^q — 1 has a nontrivial divisor d, 1 < d < n, common 
with n. The complexity of Step 3 of Stage 2 is thus O(log2 n) operations.
After Step 4, we have, for all b with 2 < b < a,
6F(a) = 1 (mod n).

1.6. MILLER’S ALGORITHM
15
Now we prove the correctness of Step 5. We have aF^ 1 
1 (mod n), aE^ =
1 (mod n), and for any prime g, q |
gcA(aE(°^q — 1, n) = 1.
We also have aF^ = 1 (mod n). If we show that for any prime p, p | n, the 
congruence p = 1 (mod F(a)) holds, then p > 1 + F(a) > 1 + y/n, which would 
imply that n is a prime. To prove that p = 1 (mod F(a)), we induct on a. Assume 
that p = 1 (mod F(a — 1)). Then, by the lemma, we have p = 1 (mod F(a)), and 
therefore,
p = 1 (mod 1cm (F(a — 1), F(a))) = 1 (mod F(a)), 
proving the desired claim.
Next we consider Step 6 of Stage 2. Assuming that n is a prime number, 
a > [log2 n], and F = F(a) < y/n, we shall derive a contradiction. By construction, 
F(a) | n — 1, because H(a) | n — 1. Set
H = {b e {1,..., n — 1} | bF^ = 1 (mod n)}.
Since n is prime, \H\ = F. Indeed, x71-1 = 1 (mod n) for all x G Z/nZ; also 
n - 1 = F • M,
^n-i _ । _ XF M _ ! _ (XF _ Yj(xF(M-l) -------- 1_ jj,
i.e., exactly F elements of Z/nZ are roots of xF — 1. The set H contains all a-smooth 
numbers not exceeding n — 1, i.e.,
H D Hi = {b | 1 < b < n, all prime factors of b are at most a}.
This follows from the fact that if r is a prime and r < a, then rF^ = 1 (mod n). 
The number n itself is not in Hi, since it is prime and n > a. Thus \H\ > |Hi|.
We now recall the following result about the distribution of primes (see [124]): 
If we set V'O'L fl) = I Hi|, then, for n > 5, 2 < a < n, we have
1 _ log log n 
^(n, a) > n loga .
Thus
1 _ log log n 
1 _ log log n
F > ^(n, fl) > n loga > n 21oglogn =
because a > log2n implies that loga > 2 log log n. The obtained contradiction 
completes our argument.
1.6. Miller’s algorithm
In [170], one finds a deterministic primality testing algorithm which runs in 
^(n1/7) arithmetic operations. That algorithm can be modified so that it would 
require O(log4n) arithmetic operations; in that case, however, for its correctness 
one has to assume the Extended Riemann Hypothesis. This hypothesis says, that if 
x(fl) is a numerical character modulo m, then the zeros of the Dirichlet L-function
fc=l
in the strip 0 < Re s < 1 are all on the line Re s = 1/2.
Let /: N —> R>0 be a function on the natural numbers such that /(n) < n.
Miller’s algorithm Af.
The input consists of an odd number n, n > 1.

16
1. PRIMALITY TESTING AND CONSTRUCTION OF LARGE PRIMES
Step 1. Verify the equality n = ms for some s,m e N, s > 2. If true, then n 
is a composite number and the algorithm terminates.
Step 2. Perform (i)-(iii) for each a < f(n).
(i) Verify the condition a | n.
(ii) Verify the condition an-1 1 (mod n).
(iii) Determine whether, for some k with 1 < k < vz(n — 1),
/ n~~i 
\
1 < gcd(a"^~ — 1 (mod n),nj < n.
If one of the conditions (i)-(iii) holds, then n is composite and the algorithm ter­
minates.
Step 3. If we have reached this step, then n is a prime number.
End of algorithm.
Theorem 1.39. If f(ri) = c • n0133 (where c is a positive constant), then the 
algorithm deterministically verifies the primality of n in O(n1^1') arithmetic opera­
tions. If f(n) = clog2 n, then the algorithm deterministically verifies the primality 
ofn in O(log4 ri) operations, assuming that the Extended Riemann Hypothesis holds.
Remark 1.40. It was shown in [28] that Step 1 can be verified in (logn)1+°(1) 
arithmetic operations.
Following [170], we shall prove the second part of the theorem. We assume 
that /(n) = clog2n for some sufficiently large absolute constant c, and that n is 
not a power, i.e., n =4 ms, m, s e N, s > 1. The value c = 2 was obtained in later 
publications; see [22, Ch. 9] and [69].
Let n be an odd composite number, n > 1, and n = p”1 •••Puu the prime 
factorization of n. This notation will be used everywhere in our argument. Then 
u > 2.
Definition 1.41. The Carmichael function is defined by
A(n) = lcm(p"4-1(pi - 1));
I
a function A'(n) is defined by A'(n) = lcmi(pi — 1).
Lemma 1.42. An odd number n e N satisfies Fermat’s Little Theorem an = 
a (mod ri) for all a e N, (a, ri) = 1, if and only if A(n) | n — 1.
Proof. When (a, ri) = 1, the congruence an = a (mod n) is equivalent to the 
system of congruences
an-1 = 1 (mod pvf), j = 1,..., k.
Since there exists aj e N such that aj (mod p^J) is a primitive root (i.e., it is of order 
“ 1))> and aj = 1 (modpp) for I =4 j, the above system of congruences is 
equivalent to the condition that 3) | n — 1, j = 1,..., u, which is equivalent to 
A(n) | n - 1. 
□
Lemma 1.43. If A'(n) | n — 1, then there are primes p and q such that
1) p\n, p—l\n — l, and for some m > 1, qm | p — 1 and qm | n — 1;
2) if for those p and q the number a is a qth-degree nonresidue modulo p (i.e., 
the equation xq = a (mod p) has no solutions), then an-1 1 (mod ri).

1.6. MILLER’S ALGORITHM
17
PROOF. 1) By assumption, among the numbers pi there is a number p such 
that p — 1 | n — 1. This, in turn, means that there is a prime q and a natural 
number m such that qm | p — 1 and qm | n — 1.
2) If an-1 = 1 (mod n), then an-1 = 1 (mod p). Let & be a primitive root mod­
ulo p, a = binda (modp); then &(n-x)inda = 1 (mod p). Thus p — 1 | (inda)(n — 1). 
Then qm | (inda)(n — 1) and therefore q | inda, contrary to the assumption that a 
is a gth-degree nonresidue. 
□
Definition 1.44. Let N(p,q) be the smallest natural number a such that 
(a,p) = 1 and a is a gth-degree nonresidue modulo p. The number N(p,q) is only 
defined when q | p — 1.
Theorem 1.45 (see [15]). If the Extended Riemann Hypothesis is true, then
N(p,q) = O(log2p).
Corollary 1.46. 
| n—1 and the Extended Riemann Hypothesis is true,
then case (ii) of Step 2 of the above algorithm will show that n is composite. Indeed, 
choose a to be N(p, q) < clog2 p < clog2 n; by Lemma 1.43, an-1 1 (mod n).
As a result, we verified the correctness of Miller’s algorithm and proved the 
theorem in the case A'(n) | n — 1. Henceforth, we shall assume that A'(n) | n — 1.
Definition 1.47. We say that a number n is of type A if there is an index j 
such that
"2(A'(n)) > v2(pj - 1).
Otherwise we say that n is of type B, i.e., in that case, for any j, 1 < j < u, we 
have z/2(A'(n)) = i/2(py - 1)-
Lemma 1.48. Let n be a composite number of type A. Suppose primes p, q 
divide n and
i/2(A'(n)) = p2(p - 1) > "2(4 - 1)-
Suppose also that 1 < a <n and (|) = —1. Then either a or (aA — 1) (mod n) 
has a nontrivial greatest common divisor with n (i.e., that divisor is different from 1 
and n).
Proof. Notice that z/2(A'(n)) > 2, because z/2(g — 1) > 1- Let (a,n) = 1. Since 
q — 1 | we have uA^n^2 = 1 (mod q). Moreover,
flA'(n)/2 (modp).
If ax'(n^2 = 1 (mod p), then (inda) • A'(n)/2 = 0 (mod p — 1), where inda is the 
index of a (mod p) relative to some primitive root in T^pTi. Since z/2(A'(n)) = 
z/2(p — 1), we have that inda is even, and therefore (^) = 1, contrary to the 
assumption. Thus
aA'(n)/2 _ ! (mod aA'(n)/2 
py
Therefore (aA (n^2 — l,n) is divisible by q and is not divisible by p. 
□
Lemma 1.49. Let n be a composite number of type B and suppose that primes p 
and q divide n, p q, and the number a is such that
(
a \
— ) = ~ 1-
p^/

18
1. PRIMALITY TESTING AND CONSTRUCTION OF LARGE PRIMES
Then either a or (aA (n^2 — 1) (mod n) has a nontrivial greatest common divisor 
with n.
Proof. Suppose (a,n) = 1. Without loss of generality, we may assume that 
(^) = —1, and (|) = 1. As n is of type B, we have ^(p—1) = 
1) = ^2(A'(n)).
Similar to the proof of Lemma 1.48, we then have
aA'(n)/2 (mod g), ax'^n^2 = -1 (mod p).
Consequently, gcd((tzA^n^2 — 1) (mod n),n) is divisible by q and is not divisible 
by p. 
□
Now we need to verify the assertions of Lemmas 1.48 and 1.49 without knowing 
A'(n).
Lemma 1.50. Let p be a prime number such that p | n, A'(n) | n — 1, and
, /n — l\
Let a 6 N be such that 1 < a < n and (a, n) = 1. Then
aA'(n)/2 a(n-l)/2fc (mOdp).
Remark 1.51. As A'(n) is even, 1 < k < i/2(n — 1)-
Proof of Lemma 1.50. Since ax>^ = 1 (mod p), we have ax'(n^2 = 
±1 (mod p).
1) Suppose ax (n^2 = 1 (mod p). We have A'(n) | n — 1, and, by the definition 
of fc,
A'(n) | n — 1 
2 I 2fc *
Thus the assertion of the lemma is true in this case.
2) Suppose aA'<n)/2 = —1 (modp). Then
fl(n-l)/2fc = ^A'(n)/2)(n-l)/(A'(n)2fc-1) = (_1)(n-l)/(A'(n)2fc-1) (modp).
By the definition of fc, we also have 
= Thus a^-1)/2* =
—l(modp). 
□
Corollary 1.52. Suppose A'(n) | n—1 andn is of type A. If a e N, 1 < a < n, 
and (^) = — 1, then either (a,n) =4 l,n or, for some k, 1 < k < V2(n — 1),
n —1 
x
— 1) (mod n), nj =4 1, n.
Thus if, in Miller’s algorithm, we reach this value of a, then in part (iii) of Step 
2 we can conclude that n is composite. Clearly, the smallest such a = N(p, 2) = 
O(log2p) < clog2 n (by Theorem 1.45 stated above) is contained among the values 
examined by the algorithm for a sufficiently large c, i.e., the algorithm is correct 
for n of type A.
Corollary 1.53. Suppose A'(n) | n-1 andn is of type B. If a e N, 1 < a < n, 
and (^) = -1, then either (a,ri) l,n, or, for some k, 1 <k < i/2(n - 1),
/ n~~i 
\
gcd( (a~^” — 1) (mod n),n) =4 l,n.

1.7. PROBABILISTIC PRIMALITY TESTS
19
Thus to establish the correctness of Miller’s algorithm for n of type B we need 
an upper bound for
N(pq) = min|a | a e N, ~ 1}-
Theorem 1.54 (see [15]). If the Extended Riemann Hypothesis holds, then 
N(pq) = O(k>g2pq).
Therefore, Miller’s algorithm for n of type B will find a = N(pq) < clog2n, 
and part (iii) of Step 2 will show that n is composite.
This argument finishes the proof of the correctness of Miller’s algorithm and 
the proof of the theorem.
1.7. Probabilistic primality tests
Let n e N be an odd integer, n > 1. A probabilistic primality test runs as 
follows. Pick a random integer a e N, 1 < a < n, and verify certain conditions 
imposed on it. If one of those conditions is not satisfied, then n is composite, 
because for primes those conditions are satisfied. If all of those conditions are 
satisfied, then one cannot yet deduce that n is prime. But we can say that “n is 
a prime number with some probability.” Moreover, one usually provides a lower 
bound for that probability. The more values of a we have tested, the closer that 
probability is to one.
Consider the Solovay-Strassen test [250].
Theorem 1.55. Suppose n is an odd composite number. Then the number of 
integers a, 0 < a < n — 1, such that
1) (a,n) = 1,
2) a<n-1>/2 = (^) (mod n), 
does not exceed n/2.
Corollary 1.56. Ifn is prime, then conditions 1) and 2) above are obviously 
satisfied for all a, 1 < a < n — 1. If n is composite, then, for a random integer a 
from the interval 0 < a < n — 1, the probability that both conditions are satisfied is 
at most 1/2. Thus, if we test the conditions of the theorem for k random integers a 
and cannot deduce that n is composite, then we consider n to be a prime with 
probability at least 1 — l/2k.
Proof of Theorem 1.55. First we show that there is b e N such that (&, n) = 
n —1
1 and b 2 
(£) (mod n). Let n = p^1 • • -p%k be the prime factorization of n.
If n is divisible by a square of a prime number, then there is b e N such that 
n — 1
(6, n) = 1 and &n-1 
1 (mod n), and therefore b 2 
±1 (mod n). Indeed, choose
an index i such that &i > 2. By the Chinese Remainder Theorem, we can find 
b e N such that &(mod p“f) is a primitive root in 
and for j =4 z we have
b = 1 (mod p“J). If &n-1 = 1 (mod n), then &n-1 = 1 (mod p?*) and therefore 
n — 1 • ^(p“9 = Pi^ipi — 1), which is impossible since n — 1 is not divisible by pi.
Suppose now that n is square-free, n = pi • • -pk- Let b e N be such that 
&(mod pi) is a primitive root in Z/piZ, and b = 1 (mod pj) for j > 1. Then 
(&, n) = 1 and
/b\ - (JL\ (JL\ - (JL\ - -i
\nJ xpiJ \pk' xpiJ

20
1. PRIMALITY TESTING AND CONSTRUCTION OF LARGE PRIMES
The congruence b 2 = — 1 (mod n) is equivalent to the congruence b 2 = —1 
n —1
(mod pj) for j = 1,..., k. Since k > 2, we have 1 = b 2 = —1 (mod £2), which is 
impossible.
Thus we can find the desired number b. Fix it and consider the two sets:
{
n —1 
/ CL \ 
'I
a | 1 < a < n — 1, (a, n) = 1, a 2 = j (mod n)|, 
{n —1 
/ n \ 
'j
a | 1 < a < n — 1, (a, n) = 1, a 2 j (mod n)|.
If ai G Wi and 02 G W2, then aiU2 6 W2 because (^f2) = (^)(^)« There­
fore, for each a G W\ the smallest nonnegative residue ba (mod n) belongs to W2. 
Thus | W21 > |FKi|, which implies the assertion of the theorem. 
□
Now we want to consider the more efficient Miller-Rabin test (see [218, 95]).
Theorem 1.57. Let n be an odd composite number. Suppose 31 n and n — 1 = 
2rt, where r > 1 and t is odd. Then the number of integers a, 0 < a < n — 1, such 
that either of = 1 (mod n) or, for some j, 1 < j < r,
a(n-i)/2> = -l(modn)
is at most n/^.
Corollary 1.58. Theorem 1.57, similar to Corollary 1.56, gives rise to a 
probabilistic primality test. More precisely, if for k random values of a, we cannot 
show that n is composite, then we say that n is a prime with probability at least 
l-jr-
Remark 1.59. If n is prime, then Z/nZ is a field and an-1 = 1 (mod n) for all 
a, 1 < a < n — 1. Since the equation x2 = 1 (mod n) has exactly two solutions, ±1, 
in Z/nZ, the congruences of Theorem 1.57 are true for all a, 1 < a < n — 1.
Remark 1.60. As was shown in [173], the Miller-Rabin test is always stronger 
than the Solovay-Strassen test. More precisely, if for a fixed n the number a passes 
the Miller-Rabin test and does not show that n is composite, then it also passes 
the Solovay-Strassen test with the same outcome.
Remark 1.61. It was shown in [265] that an analog of the Miller-Rabin algo­
rithm can be applied for primality testing of principal ideals in cyclotomic fields. 
It was shown in [269] that the above algorithm can be used in some RSA-type 
cryptosystems.
To prove Theorem 1.57 we need a few lemmas. Let S denote the set of numbers 
a (mod n), 1 < a < n, such that either of = 1 (mod n) or a(n-1)/2J = —1 (mod ri) 
for some j, 1 < j < r. Henceforth we shall also assume that n is odd, composite, 
and not divisible by 3.
Lemma 1.62. If there is a prime number p such that p2 | n, then the set
G = |1 + k — (mod n) | k = 0,... ,p — 1}
is a subgroup of (Z/nZ)* of order p.

1.7. PROBABILISTIC PRIMALITY TESTS
21
PROOF. The lemma follows easily from the congruences 
/ kn\ / fc'n\ . 
//7 , "ft, , x
^1 + — J ^1 + 
= 1 + ((fc + k ) (modp)) — (mod ft)
and
fl + —= 1 + (kl (modp)) — (mod ft). 
□
\ p / 
p
Definition 1.63. Let A the set of elements a e (Z/nZ)* satisfying one of the 
following two conditions:
1) an-1 1 (mod ft);
2) ak — 1 (mod n) for any k e Z, and, for some prime p, p | ft, the order of 
a (mod p) equals p — 1.
Lemma 1.64. Let a e A and s e S. Then as $ S, i.e., aS A S = 0.
Proof. If an-1 l(mod ft), then, because sn-1 = 1 (mod ft), we have 
(as)n-1 
1 (mod n), i.e., as & S.
Suppose now that a does not satisfy the first but satisfies the second of the 
two conditions defining A. Then a71-1 = 1 (mod ft) and for any integer k we have 
ak — 1 (mod ft). Now fix a prime number p, p | ft such that the order of a (mod p) 
equals p — 1. Also fix a number i such that
a(n-1)/2t = 1 (mod ft).
Such i do exist; for example, i = 0. Moreover, because p | ft, we have
a(^-i)/2l = । (modp).
By assumption, \ p — 1, and therefore, since p — 1 is even, 0 < i < r. In 
particular, it follows that
a(^-i)/2r _ at i (mod ft).
We shall show that if s e S, then for all j such that 0 < j < i < r, the 
congruence
(1.1) 
5(n-l)/2J _ i (mod n)
holds. If s e S and $<n-1)/2r = 1 (mod ft), then congruence (1.1) holds. Suppose 
now that s e S and for some ji, 0 < ji < r,
If ji > i, then for all j, 0 < j < z, we have
5(^-!)/2j = । (mod ft),
i.e., formula (1.1) is true.
Considering now the case ji < i, we derive a contradiction. Since
5(^-i)/2J1 = (mod n)?
we have
5(^-i)/2J1 = _ i(modp).
Moreover, by assumption, ji <i. Therefore, as was shown above,

22
1. PRIMALITY TESTING AND CONSTRUCTION OF LARGE PRIMES
Now Fermat’s little theorem implies that
5(^-i)/2J1 = । (modp).
This is a contradiction, since 1^—1 (mod p).
Thus formula (1.1) holds. It now follows from (1.1) that 
5(^-i)/2t+1 = (mod n), 
because s e S.
Now choose the largest possible i. As was shown above, i < r and we have 
a(n-i)/2l = । (mod n), 
a(^-i)/2t+1 
±1 (mod n).
(We used the fact that ak 
— 1 (mod ri) for all k e Z.) Then, for all j, 0 < j < i,
we have
(as/n-1)/2J = 1 (mod n), 
but
(as/n-1)/2t+1 = ±a(n-1)/2*+1 
±1 (mod n),
This implies that as £ S. 
□
Lemma 1.65. Let a,be (Z/nZ)*, a =4 b. The sets aS and bS are disjoint if 
and only if the sets ab~1S and S are disjoint.
The proof is obvious.
Corollary 1.66. Let G be a subgroup of (Z/nZ)*. The sets giS and g2S are 
disjoint for all g±ig2 G S, gi g2, if and only if the sets S and gS are disjoint for 
all g e G, g =4 1.
Lemma 1.67. Let n be a composite number divisible by p2, where p is a prime. 
Then
|S| < i|(Z/nZ)*|.
Proof. Let G be the subgroup of (Z/nZ)* from Lemma 1.62. If p | n, then 
p | n — 1, and then for any g e G, g =4 1, we have pn-1 1 (mod ri). Therefore 
g G A and, by Lemma 1.64, the sets S and gS are disjoint. By the corollary 
to Lemma 1.65, the sets gS, g eG, are disjoint. Then |U^gg = 1^1 * 1^1 = 
and p|S| < |(Z/nZ)*| = <p(n), and therefore
|S| < ^ < ||(Z/nZ)*|, 
p 4
since p > 5 by the assumption of the theorem. This completes the proof of Lemma 
1.67. 
□
Lemma 1.68. Let n = P1P2, where pi and P2 are distinct primes. Then n — 1 
is not divisible by one of the two numbers Pi — 1.
The proof follows from the equality
n - 1 = P1P2 - 1 = (Pl - 1)(P2 - 1) + (pi - 1) + (P2 - 1)-
Lemma 1.69. Let n = pip2, where pi ^P2- Then |S| < ip(n)/4.

1.8. MODERN METHODS FOR PRIMALITY TESTING
23
PROOF. By the Chinese Remainder Theorem, there are numbers ui and <22 
such that a>i = 1 (mod P3-i), and ai (mod Pi) is a primitive root modulo pi for 
2 = 1,2. Then ak —1 (mod pz-i) for any k e Z; moreover ak = 1 (mod p^ if and 
only if Pi — 1 | k. This means that e A. It is also clear that tzf1 (mod n) e A. 
Now, for a = aifl2 (mod n), the congruence ak = 1 (mod n) is true if and only 
if ak = 1 (mod pi) for i = 1,2, which is equivalent to the condition pi — 1 | k. 
By Lemma 1.68, we now have an-1 1 (mod n), i.e., a = aia2 £ A. Similarly, 
aia^1 & A.
Consider now the sets S, Sai, Su2, and Sa. By Lemmas 1.64 and 1.65, they 
are disjoint. Moreover, S, Sai, Sfl2, and Sa are contained in (Z/nZ)* and are 
equipotent. Therefore |S| < ||(Z/nZ)*|. 
□
Lemma 1.70. Suppose n is square-free and divisible by three distinct primes pi, 
P2, andps. Then |S| < <^(n)/4.
Proof. As in the proof of Lemma 1.69, there are ai,fl2 £ (Z/nZ)* such that 
ai = 1 (mod ^-) and ai (mod Pi) is a primitive root modulo p*, i = 1,2. Then 
ai = 1 (mod P3) for i = 1,2; aia2 = a = 1 (mod P3), and b = aia^1 = 1 (mod P3). 
Moreover ak — 1 (mod n) for any k e Z (since 1^—1 (mod Ps))- We also have 
ak —1 (mod n) for a = a±a2 and bk —1 (mod n) for b = Therefore 
a±ia2iaib e A (the requirement on the order in the second condition from the 
definition of A is satisfied by the choice of ai and 02). By Lemmas 1.64 and 1.65, 
the sets S, Sai, Su2, Sa are disjoint and equipotent. As in the proof of Lemma 1.69, 
we have |S| < ||(Z/nZ)*| = <p(n)/4. This proves Lemma 1.70. 
□
The proof of Theorem 1.57 can obviously be deduced from Lemmas 1.67, 1.69, 
and 1.70.
In [410] one finds an improvement of the Miller-Rabin algorithm with a better 
estimate on the probability for numbers n = 1 (mod 4). Similar results had earlier 
been obtained by the author for n = 3 (mod 4).
1.8. Modern methods for primality testing
In the beginning of the 1980s, Adleman, Pomerance, and Rumely [3] came up 
with a deterministic algorithm for primality testing. For a given natural number n, 
the algorithm requires O((logn)clogloglogn) arithmetic operations (where c is some 
absolute constant) and decides whether n is composite or prime. For a schematic 
description, see also [262].
Significant theoretical simplifications of the Adleman-Pomerance-Rumely algo­
rithm were obtained by H. Lenstra [144]. He found a deterministic algorithm that 
also required O((logn)clogloglogn) arithmetic operations. An implementation of 
that algorithm allowed to test numbers of the order of magnitude IO100 in several 
minutes.
Remark 1.71. The complexity estimate for the Adleman-Pomerance-Rumely 
and Lenstra algorithms is best possible, i.e., for a prime number n the algorithm re­
quires at least ci(logn)C2 logloglogn operations for some positive constants ci and C2.
We now give a simplified and somewhat modified description of Lenstra’s algo­
rithm so that the reader can see its structure and the needed tools.

24
1. PRIMALITY TESTING AND CONSTRUCTION OF LARGE PRIMES
A description of Lenstra’s algorithm.
The algorithm tests an odd number n e N, n > 1, for primality.
Step 1. Choose distinct primes pi,... ,p& (called the initial prime numbers) 
such that there are odd primes qi,..., qs (called Euclidean primes) satisfying the 
following conditions:
a) qj -1 |pi*--Pfc, 3 =
b) 2gi • • • qs > y/n.
Example 1.72. {p} = {2,3,5,7}, {q} = {3,7,11,31,43,71,211}, 2qi---qs> 
143 • 109 > 1011. Therefore, the sets {Pi}, {qj} can be used for primality testing of 
all numbers n, n < 1022.
Step 2. Check if n = pi or n = qj for some i or j. If yes, then n is prime. 
Else, check if
gcd(pi ---pfegi •••gs,n) = 1.
If this is not true, then n is composite.
Step 3. For each pair p, q such that p | q — 1, find a primitive root cq modulo q 
and numbers a, b e N such that, for p > 2,
ab(a + 6) 
0 (modp),
ap + IP (a + b)p (mod p2).
It is known that such a and b exist, and usually a = b = 1. Next, define a numerical 
character xP,q modulo q of order p:
XP,q: (Z/qZ)* C, Xp,q(x) = ^ndqX,
where £p = e2irt/p, ind9(a;) € Z/(g — 1)Z, and cqdqX = x (mod q). These characters, 
for various p | q — 1 generate the entire group of numerical characters modulo q.
Now compute the Jacobi sum
q-l 
q-l
= -^xp,^rxp^-^b = -'£^indq(x}+bindq(1-x}. 
x=2 
x=2
These calculations can be performed fast because the Euclidean primes q are small 
and the values indg£ can quickly be found by trial and error.
Step 4. For each initial prime p we determine the largest natural number 
A = 7z(p), 1 < h < t = z/p(np-1 — 1), such that for all q with p | q — 1 the following 
congruence holds:
(1-2) 
v(Xp,qFh(n} = (P,q (mod nZ[CP]).
This is the main test in the algorithm. Here £Ptq is a pth root of 1; o/i(n) is 
an explicitly determined (by n) element of the group ring Z[Gal(Q(£p))] of the 
form ah(n) = Y,jah,jVj, where ahj 6 Z>0, (?j € Gal(Q«p)), aj(CP) = <•*, and 
1 < j' < P — 1- Moreover, if
p-2 
l'(Xp.q) = '^ACP, AeZ, 
z=o
then
/ 
\ ah,j p~2
^(xp,9)“h(n) = n(E^) = Es4-
j ' I ' 
1=0

1.8. MODERN METHODS FOR PRIMALITY TESTING
25
where Bi e Z. Since l,£p,... ,CP-2 is a Z-basis of the Z-module Z[£p], we only 
have (p — l)-dimensional vectors with integer coordinates. Congruence (1.2) shows 
that the coordinates of two such vectors are congruent modulo n.
If congruence (1.2) does not hold for some p, q with h = 1 and
p-i
Qi(n) = y? (modp)’
then n is a composite number (the failure of Fermat’s little theorem an-1 = 
1 (mod n) is an analog of this test).
Step 5. For numbers p with h = h(p) < t = t(p) and such that £p>g = 1 for 
all q with p | q — 1, we check the following condition: there is a Euclidean prime q 
such that p | q — 1 and for all j = 0,1,... ,p — 1 the expression for the vector
in the basis 1, £p,..., has a coefficient relatively prime with n.
If this condition is not satisfied, then one can show that we will find a nontrivial 
divisor of n at this step.
Step 6. Now we represent the numbers £P)(? found in Step 4 in the form £P)(? = 
Cpp'9, where uPtq e Z>0. Then for every q we find xq such that for each p, p | q — 1, 
the congruence
-n'ipp(j3)xq = uPtq (modp)
holds. Here
j=l
is an integer depending on p. The numbers xq can be found using the Chinese 
Remainder Theorem.
Next we find v 6 Z, 1 < v < 2gi • • • qSi such that
v = 1 (mod 2), v = Cgq (mod g), 
where q runs through the Euclidean primes.
Step 7. For each j, j = 1,... ,pi • • -pk — 1, we find rj e N such that
rj = vj (mod 2gi • • • gs), 0 < rj < 2gi • • • qSi
and check whether n is divisible by rj. If rj | n for all J, then n is prime.
End of algorithm.
Summary. For a given n one runs certain tests that generalize Fermat’s little 
theorem. If n passes all of them, then the divisors of n belong to a small explicitly 
given set: these are the powers (mod 2gi • • • qs) for some explicitly constructed 
natural number v.
The complexity of the algorithm is O((pi • • *Pfc)const) of arithmetic operations, 
and one can show that, for a given n, there are numbers Pi,... ,p& such that
Pl • • -Pk < (logn)constlogl°slogn.
This yields the above estimate for the complexity.

26
1. PRIMALITY TESTING AND CONSTRUCTION OF LARGE PRIMES
As was shown later, the requirement that the qj — 1 be square-free can be 
removed, which allowed for the use of smaller sets of the numbers Pi. For example, 
there are 27 primes qj such that
q31 | 24 • 32 • 5 • 7,
with rijQj > IO50- With these sets {p;} and {qj} one can test numbers n up to 
IO100.
The above-mentioned improvements of the Adleman-Pomerance-Rumely and 
Lenstra algorithms are due to Cohen and Lenstra [58]. The complexity estimate of 
O((logn)c logloglogn) arithmetic operations for the Cohen-Lenstra algorithm cannot 
be obtained without some open conjectures. However, in practice this algorithm 
turned out to be the most efficient one. With a correct setup, it determines rather 
efficiently whether n is prime or composite. The description and theoretical foun­
dations of the Cohen-Lenstra algorithm are lengthy and beyond the scope of this 
book. The algorithm tests numbers of the order of magnitude 10lo°-1020° in several 
minutes. Notice also that the Cohen-Lenstra algorithm is easily parallelizable over 
several computers, as determined by the numbers of pairs p and q.
In 1986 Goldwasser and Kilian [97] developed an algorithm which allowed for 
primality testing using elliptic curves. That algorithm was substantially improved 
by Atkin and Morain [18]. In [18], one finds the results of testing the Atkin-Morain 
algorithm on numbers of the order of magnitude 1O8O°-1O1000. The primality test 
for one such number required several weeks. A description of the Goldwasser-Kilian 
algorithm will be given in Chapter 4.
All that brought about the question whether the Atkin-Morain algorithm is 
faster than the Cohen-Lenstra algorithm, as well as the question of what size num­
bers can be tested by each of the two algorithms in reasonable time. This was 
investigated by P. Mihailescu (the Cohen-Lenstra algorithm) and F. Morain (the 
Atkin-Morain algorithm); see [168, 167, 182, 181, 178, 179].
Some record values of numbers tested for primality with an optimized version 
of the Cohen-Lenstra algorithm can be found in [167]. That method was used to 
test n = (211279 + l)/3. Using the method based on elliptic curves, the number 
n = (212391 + l)/3 was tested; see [182]. The comparison of the two algorithms, 
given in [167] and [182], shows that the Cohen-Lenstra algorithm is probably much 
faster for numbers of that magnitude. The advantage of the method of elliptic 
curves is that it produces an easily verifiable primality certificate.
Some theoretical improvements of the Cohen-Lenstra algorithm can be found 
in [268]. It was shown there how to apply trigonometric sums of Gauss and Jacobi 
for additive and multiplicative characters in finite fields for verification of several 
conditions in the Cohen-Lenstra algorithm.
Some other improvements of the Cohen-Lenstra algorithm can be found in [33].
Finally, we mention yet another method of primality testing. In 1992, Adle- 
man and Huang [4] came up with a probabilistic algorithm of polynomial com­
plexity based on hyperelliptic curves. This algorithm requires calculations with 
the Jacobians of algebraic curves. The algorithm has not been implemented on the 
computer. A theoretical estimate of its complexity is of order log75 n, where n is the 
number being tested for primality. We should remark that only a limited number 
of specialists in algebraic geometry and algebraic number theory understand the 
description and the justification of the Adleman-Huang algorithm.

1.9. SUMMARY. A DETERMINISTIC POLYNOMIAL ALGORITHM
27
Based on the material of this chapter, we can conclude that fast and efficient 
algorithms for primality testing and for constructing large primes are available.
1.9. Summary. A deterministic polynomial algorithm 
for primality testing
When a major part of this book has already been written, the remarkable 
paper of Agrawal, Kayal, and Saxena [7] appeared. In it one finds a deterministic 
polynomial algorithm for primality testing with complexity of O(log12 n(log log n)c) 
arithmetic operations (n is the number being tested, and c is an absolute constant). 
We now give a description and a justification of that algorithm. The symbol O(t(nf) 
will be used to denote O(t(n) loga n), where a is a positive constant.
The algorithm in question is based on the following theorem.
Theorem 1.73. Let p be an odd natural number, a G Z, and suppose that 
(a,p) = 1. The number p is prime if and only if
(1.3) 
(x — d)p = xp — a (mod p)
(congruence (1.3) means that the coefficients of the two polynomials are congruent 
modulo p).
Proof. Clearly,
p-1 / \
(1.4) 
(x - a)p - (xp - a) = 
(J)xi(-a')p~i + a-ap.
If p is a prime, then (1.3) follows from (1.4), since for 1 < i < p— 1 the number (?) 
is divisible by p.
Suppose now that (1.3) holds, and suppose that p is composite. Then there is 
a prime q and a natural number k such that qk || p and q < p. Obviously, qk does 
not divide
fp\ _ p(p - 1) • • • (p - g + 1)
and therefore the coefficient of xq in (1.4) is not divisible by p, which contra­
dicts (1.3). This finishes the proof of the theorem. 
□
Let P(m) denote the largest prime factor of the natural number m, and let 
or(m) be the order of m(mod r) in the group (Z/rZ)*.
Lemma 1.74. Let p and r be distinct primes.
1) For each t G N, the group GF{ply is cyclic.
2) For each polynomial f(x) G Z[rr], we have
f(x)p = f(xp) (mod p).
3) If h(x) G Z[rr], h(x) | xr — 1, mi, m2 G Z>o, and m = mr (mod r), then 
xm = xmr (mod h(xf).
4) If or(p) is the order o/p(mod r) G (Z/rZ)*, then factors in Z/pZ[rr] 
into distinct irreducible polynomials, of order or (p) each.

28
1. PRIMALITY TESTING AND CONSTRUCTION OF LARGE PRIMES
Proof. The first two assertions are well known.
Suppose m > mr and m = mr + fcr, where k e Z>0. As xkr = 1 (mod xr — 1), 
we have xkr+mr = xmr (mod h{x)), which proves the third assertion.
Set d = or(p) and let h(x) be an irreducible factor of in Z/pZ[rr] with 
deg h(x) = k. Then
= GF(pk), 
(Z/pZ[a:]/(h(a;)))* = (g(x) (mod /i(x)))p»=_i, 
where g(x) e Z/pZ[rr]. Clearly, g(x)pd = g(xpd) (mod h(x)). Since pd = 1 (mod r) 
and h(x) | xr — 1, we have xp = x (mod h(x)'). Then g(x)p = g(x) (mod h(x)) and 
therefore g(x)p -1 = 1 (mod h(xf). This means that pk — 1 | pd — 1, and therefore 
k | d.
Now, xr = 1 (mod h(xf) in Z/pZ[#]. Since xr — 1 has no multiple irreducible 
factors in Z/pZ[rr], we have h(x) =4 x — 1. Therefore, the order of rr(mod h{x')') 
is a prime number r. This, in turn, means that r | pk — 1 = |GF(pfe)*|, i.e., 
pk = 1 (mod r). It now follows from the definition of d that d | k.
It follows from the above argument that k = d, proving the last assertion of 
the lemma. 
□
The next two lemmas contain results about the distribution of primes.
Lemma 1.75. There is a positive constant cq and a natural number no such 
that for all x> no,
#{p I P is prime, p < x, P(p — 1) > ^2/3} > cox . 
— logrr’
For a proof, see [92, 23].
8m 
log2m’
Lemma 1.76. For allm>2 we have 
m / ( \ 
ay~"~ 
fi log2 m
where 7r(m) is the Chebyshev function.
The proof follows from [17].
We can now describe the algorithm for primality testing.
Algorithm.
The input is an odd number n e N, n > 1.
Step 1. If n is of the form ab, where a e N, b E N, b > 2, then the algorithm 
outputs the message that n is composite and terminates. (It was shown in [28] that 
this step can be done in O(logn1+°^^) arithmetic operations.)
Step 2. r := 2.
Step 3. For the current value of r perform Steps 4-8.
Step 4. If r < n and gcd(r, n) > 1, then the algorithm outputs the message 
that n is composite and terminates.
Step 5. If r is a prime number, perform Steps 6-7; else, go to Step 8.
Step 6. Find the largest prime factor q of r — 1. 
r —1
Step 7. If q > 4y/r log2 n and n 9 
1 (mod r), then go to Step 9 with the
current value of r.

1.9. SUMMARY. A DETERMINISTIC POLYNOMIAL ALGORITHM
29
Step 8. r := r + 1. If r > n, then the algorithm outputs the message that n 
is prime, and terminates. Else, return to Step 3.
Step 9. Case 1. If n — 1 < [2y/r log2 n], then for all a with r < a < n — 1, 
verify the condition (a, n) = 1.
Case 2. If n — 1 > [2^/r log2 n], then for all a with 1 < a < [2y/r log2 n], verify 
the condition
(x — a)n = xn — a (mod xr — 1) 
in the ring Z/nZ[rr]. If, for some a, we have that either (a, n) > 1 in the first case 
or that the above congruence modulo xr — 1 does not hold in the second case, then 
n is composite and the algorithm terminates.
Step 10. If the algorithm has reached this step, then n is prime.
End of algorithm.
Theorem 1.77. The algorithm determines whether the number n is prime or 
composite. The considered values of r are at most A log6 n for an absolute con­
stant A.
To prove Theorem 1.77 we need several lemmas.
Lemma 1.78. There are positive absolute constants ci and C2 such that if the 
number n is large enough, then the interval [ci log6 n, C2 log6 n] contains a prime r 
satisfying the following conditions: either r | n or r — 1 has a prime factor q > 
4y/r log2 n such that q | or(n) and n^r-1^9 
1 (mod r).
Proof. Consider the primes r in the interval [ci log6 n; C2 log6 n] such that 
(1-5) 
P(r - 1) > (c2 log® n)2/3,
where c\ and C2 are positive constants to be chosen later. We say that such primes 
are special. The number of special primes is at least the number of primes in the 
interval [1, C2 log6 n] satisfying (1.5) minus the number of all primes in [1, c\ log6 n]. 
It follows from Lemmas 1.75 and 1.76 that the number of special primes is at least
C0C2 log6 n 
8ci log6 n > cqC2 log6 n 8cx log6 n
log2 c2 + 6 log2 log2 n log2 ci + 6 log2 log2 n ~ 7 log2 log2 n 6 log2 log2 n 
log6 n (cqC2 8ci\ log2n
~~~ ■ ■ 
I —---- --  ■■ --- 1 --  C3 -------------------
log2log2n\ 7 
6 / log2log2n
if n is large enough. We assume that ci > 46, C2 > Ci, and C3 > 0. Let x = C2 log6 n 
and
(1.6) 
n = (n - l)(n2 - l)(n3 - 1) • • • (nlsl/3l - 1).
This product has [re1/3] factors, each consisting of at most log2(na;1/3 — 1) < 
rr1/3 log2 n primes. Therefore, II is the product of no more than x2^3 log2 n primes. 
Now,
x2/3 log2 n = c2/3 log2 n < c3 lo^2n 
log2 log2 n 
for all sufficiently large n. Therefore, at least one special prime r does not divide II. 
We show that any such prime satisfies the condition of the lemma. Suppose r | n. 
Then nr~1 = 1 (mod r). It follows from (1.5) that P(r — 1) > r2/3, i.e., r — 1 
has a prime factor q such that q > r2/3. Notice that r2/3 > 4-yFlog2n, because 
r > ci log6 n and ci > 46. Therefore q > 4-^r log2 n and q2 | r — 1. If q | or(n), 

30
1. PRIMALITY TESTING AND CONSTRUCTION OF LARGE PRIMES
then n^r = 1 (mod r), r | n^r ^/q — 1. We show that < [re1/3]. Indeed, 
r — 1 < re1/3#, since we even have a stronger inequality
r < rr1/3r2/3)
which holds by virtue of the inequality r < x = C2 log2 n. It now follows that r | II, 
but this contradicts the choice of r. Thus q | or(n) and n^r-1^9 
1 (mod r). 
□
Remark 1.79. It follows from Lemma 1.78 that if n is sufficiently large, then 
in Step 3 of the algorithm, either n is composite or there is a prime r, r < C2 log2 n, 
such that r — 1 has a prime factor q satisfying the conditions of Step 7.
Lemma 1.80. If the number n is prime, then the algorithm terminates with a 
message that n is prime.
Proof. If n is not too large, then the algorithm can simply examine all values 
of r < n and either, at Step 8 for r = n, output the message that n is prime, or go 
to Step 9 with some value of r; in that case (by Theorem 1.73) the tests of Step 9 
run for all considered values of a, and the algorithm outputs the message that n is 
prime.
Suppose now that n is sufficiently large. Then, by Lemma 1.78, Step 3 of the 
algorithm determines a prime number r such that r < C2 log2 n < n and r — 1 has a 
prime factor q satisfying the conditions of Step 7. In Step 9, the congruence modulo 
xr — 1 is true (by Theorem 1.73) for all considered values of a because
a < 2y/r log2 n < 2y/c2 log2 n < n - 1,
provided n is sufficiently large. Therefore, the algorithm reaches Step 10 and out­
puts the message that n is prime. 
□
Assume now that n is a composite number. Let n = p\ • • • pk be the prime 
factorization of n (with not necessarily distinct factors). Suppose that, running 
through the values of r in Step 3, the algorithm does not determine that n is 
composite, finds primes r and q satisfying the conditions of Steps 6 and 7, and 
goes to Step 9. Since q | or(n) and or(n) | lcmi(or(pi)), there is a prime number p 
dividing n such that q | or(p). Fix that p.
Set I = [2y/rlog2 n] and suppose that I < n — 1. In Step 9, the algorithm 
runs through the values a, 1 < a < I. By Lemma 1.74, 4), there is an irreducible 
polynomial h(x) e Z/pZ[rr] dividing xr — 1 and such that deg/i(rr) = d = or(p) > 2 
(because q divides d). If the congruence modulo xr — 1 of Step 9 holds for some a, 
then
(1.7) 
(x — d)n =xn — a (mod h(xf)
in Z/pZ[rr], i.e., (x — a)n = xn — a in the field (Z/pZ[rr] )/(/&(#)) = GF(pd). Under 
these assumptions and notation we will prove Lemmas 1.81-1.83.
Lemma 1.81. The multiplicative group G C ((Z/pZ[rr])/(/i(rr)))*,
( 1
G = < JJ (x - a)aa (mod A(rr)) | ota e Z>0, a = 1,..., I 
^a=l
generated by the binomials x — a, a = 1,..., I, is cyclic. Moreover, |G| > (d/l)1 if 
the algorithm reaches Step 9 and I < n — 1.

1.9. SUMMARY. A DETERMINISTIC POLYNOMIAL ALGORITHM
31
PROOF. Since deg/i(rr) > 2, the elements x — a (mod are of finite order 
in ((Z/pZ[rr])/(/i(rr)))* and G is a group. Since G is a subgroup of the cyclic group 
GF(pd)*, it is also cyclic.
Now we show that the elements
(i 
1 
1
S = < JJ (x - o)aa (mod h(x)) 
< d - 1 >
^a=l 
a=l 
'
of G are distinct in (Z/pZ[rr])/(/i(rr)) provided the algorithm reaches Step 9 and I < 
n — 1. Step 9 checks the condition of Case 2 and the condition r > q > 4^/r log2 n > 
21. The values of a being examined are distinct modulo p. Indeed, if ai = a2 (mod p) 
and ai < U2, then p < tZ2 — ui < / < r, and in Step 4, for rx = p < r, the algorithm 
would determine that n is composite. Thus, the values a (mod p) are distinct. It fol­
lows that the polynomials nL=i — a)aa Z/pZ[rr] are distinct. Since £^=i — 
d — 1 < deg/i(rr), the elements of S are distinct in (Z/pZ[rr])/(/i(rr)). Since S 
contains (Z+^-1) elements and (Z+^-1) > (f)\ we have |G| > |S| > (d/l)1. 
□
Suppose the algorithm reaches Step 9 and I < n — 1. Since d = or(n)-q and 
q > 4-^r log2 n > 2Z, we have d > 21 and
(1.8) 
|G| > 2l = 2l2v^log2lnl > 22^log2n-1 =n2v^/2.
Let g(x) be a generator of the cyclic group G. Its order is greater than n2y^/2. Set
I^) = {m I m e Z>o, <7(#)m = p(3?m) (mod xr — 1) in the ring Z/pZ[rr]}.
Lemma 1.82. The set Ig^ is closed under multiplication.
Proof. Let mi, m2 G Ig(xy Then
g(a?)mi = g(xmi) (mod xr — 1), g(x)m2 = g(xm2) (mod xr — 1)
in Z/pZ[rr]. Replace x by in the second congruence. Then
^(z™1)™2 = g(xmim2) (mod xrmi - 1),
and therefore
#(zmi)m2 = g(xmim2') (mod xr - 1).
Hence
g(x)m'm2 = (g(x)mi)m2 = (g(xmiY)m2 = g(xmim2) (mod xr - 1),
i.e.,mim26lg(x). 
□
Lemma 1.83. Let og be the order ofg(x) G Z/pZ[z]/(/i(z)) andmi, m2 G Ig(xy 
If mi = m2 (mod r), then mi = m2 (mod og).
Proof. Suppose m2 > mi; then m2 = mi + fcr, where k G Z>o. Since 
g(a?)m2 = g(xm'2') (mod xr — 1) in Z/pZ[rr] and h(x) | xr — 1, we have g(a?)m2 = 
g(xm2) (mod h(xf). Consequently,
g(x)m^g(x)kr = g(xm^kr) = g(xmi) (mod h(x)).
Since mi G Ig(x)> we have g(x)kr = 1 (mod hlxf), i.e., kr = 0(mod og). The 
assertion of the lemma now follows. 
□
Remark 1.84. Lemma 1.83 implies that there are at most r numbers less 
than og in Ig(xy

32
1. PRIMALITY TESTING AND CONSTRUCTION OF LARGE PRIMES
Lemma 1.85. Ifn is composite, then the algorithm terminates and outputs the 
message that n is composite.
Proof. Suppose the algorithm outputs the message that n is prime. This 
cannot happen in Step 8; otherwise, upon verifying the conditions of Step 4 for 
all r < n, the algorithm would produce a factor of n. Thus the algorithm reaches 
Step 10. Hence, Step 9 has been completed. If n— 1 < [2^ log2 n], then, in Step 9, 
there would be a number a, a < n — 1, such that (a, n) > 1, and the algorithm 
would output a message that n is composite. Hence, [2y/r log2 n] < n — 1, and for 
all a, 1 < a < [2y/r log2 n] = I, we have
(1.9) 
(x — a)n = xn — a (mod xr — 1) in Z/pZ[rr].
In the notation of Lemmas 1.82 and 1.83 (where g(x) is still a generator of G), we 
have that
g(x)n = g(xn') (mod xr — 1) in Z/pZ[rr],
because g(x) is a product of the binomials x — a satisfying (1.9). Hence, n e Ig(x)- 
By Lemma 1.74, 2), we have p e Ig(xy moreover, 1 e Ig(x)-
Consider the set E = {nV | 0 < i,j < By Lemma 1.82, E C Ig(xy 
Since |E| = ([v^] + l)2 > r, there are two distinct pairs (ii, Ji) and (22,7’2) such 
that ri^pi1 = nZ2p^2 (mod r). By Lemma 1.83, 
= nZ2p>2 (mod og). Since og
divides pd — 1 = |(Z/pZ[rr]/(/i(rr)))*|, we have p | og and p(mod og) is invertible 
in 'L/og'L. Without loss of generality, we may assume that j2 > ji- Then
(1.10) 
nZ1 = nZ2pP2~^ (mod og).
Since 3 < p < n/3, we have
nZ1 < 
< n^ < n2y^/2,
ni2pi2-ji < n[^\ (^y771 = 
< n2'/?/2.
It now follows from (1.10) and (1.8) that
(1.11) 
nZ1 =ni2pj2~jl.
Since p is a prime factor of n, it follows from (1.11) that the composite number n 
is a power of p. (Indeed, if n has a prime factor s, s =4 p, then (1.11) implies 
that zi = 22- But then ji = j2, contrary to the condition (21,71) =4 (22,7’2)-) But 
the algorithm detects such composite numbers already in Step 1. The obtained 
contradiction proves the lemma. 
□
Now we shall prove Theorem 1.77. The correctness of the algorithm is justified 
by Lemmas 1.80 and 1.85. The inequality r < A log6 n for small values of n can be 
satisfied by a choice of the constant A. For sufficiently large n, by Lemma 1.78, we 
can consider r < c2 log6 n. This finishes the proof of Theorem 1.77.
Next we want to estimate the number of arithmetic operations required by the 
algorithm.
Theorem 1.86. The number of arithmetic operations required by the algorithm 
equals O(log12 n).

1.9. SUMMARY. A DETERMINISTIC POLYNOMIAL ALGORITHM
33
Proof. We assume that n is sufficiently large. By [28], Step 1 of the algo­
rithm requires O((logn)1+°(1)) arithmetic operations. By Lemma 1.78, the num­
ber of values of r considered in Step 3 is at most C2 log6 n. For each r, Step 4 
requires O(logn) arithmetic operations. Steps 5 and 6, using the sieve of Er­
atosthenes, require O(r1/2(logr)const) = <5(log3n). Step 7 requires O(logr) = 
O(loglogn) operations, while Step 8 is trivial. Step 9 (since n is sufficiently large) 
verifies the condition of Case 2. The verification of the congruence
(x — a)n = xn — a (mod xr — 1)
in Z/pZ[rr] requires, using binary exponentiation (see the Appendix) and the fast 
Fourier transform (see Chapter 9), O(logn • rlogn) operations. Therefore, Step 9 
requires O(2y/r\ogn • r log2 n) = <5(log12 n) arithmetic operations. This proves the 
theorem. 
□
Remark 1.87. The verification of the condition of Case 2 in Step 9 can be 
done without the fast Fourier transform. The estimate would still be polynomial, 
although somewhat greater.
Remark 1.88. As was shown in [7], if a certain conjecture about the distribu­
tion of Sophie Germain primes, i.e., pairs of primes q and p = 2q + 1, is true, then 
one has an algorithm for primality testing of complexity O(log6n). If some other 
conjecture is true, one can describe an algorithm for primality testing of complexity 
O(log3n).
Further improvements of the Agrawal-Kayal-Saxena algorithm were suggested 
by H. W. Lenstra, C. Pomerance, and D. Bernstein (see [309, 363]). In particular, 
it became possible to avoid a nontrivial result of E. Fouvry, and also to lower the 
complexity estimate to (5(log6 n) bit operations. Other improvements can be found 
in [310, 319]. In [363], one also finds a description of a randomized algorithm 
with complexity estimate of O((logn)4+°(1)) bit operations. A modification of the 
Indian algorithm which does not use the result of E. Fouvry can also be found in 
the monograph [438].


CHAPTER 2
Factorization of Integers 
with Exponential Complexity
2.1. Introduction. Fermat’s method
In this chapter we consider factorization algorithms for natural numbers n re­
quiring O(nc) arithmetic operations, where c is a constant, 0 < c < 1, as well as 
algorithms requiring O(nC1 logC2 n) arithmetic operations for some constants ci and 
C2- We restrict ourselves to factorizations into a product of two factors: n = ab, 
1 < a < b < n. If an algorithm finds such a factorization in O(/(n)) arith­
metic operations, then the complete prime factorization of n will be determined 
in O(/(n) logn) arithmetic operations, since n is a product of no more than log2 n 
primes.
Before trying to factor an integer, one should make sure that it is indeed com­
posite. For that purpose, it is better to use one of the probabilistic primality tests, 
for example, the Miller-Rabin algorithm from Chapter 1.
The simplest method of trial divisions for factorization of n was described in 
1.2. It requires Ofn1/2) arithmetic operations. Other factorization algorithms of 
complexity Ofn1/2) can be found in Knuth’s book [118, 4.5.4]. Here we describe 
Fermat’s algorithm, which dates back to 1643. It computes the largest factor a of n 
not exceeding n1/2. The algorithm uses addition, subtraction, and multiplication, 
but not division. We remark that if n = pq, where p and q are primes of approx­
imately the same magnitude, then Fermat’s algorithm will quickly factor n. This 
should be taken into account when choosing moduli in the RSA cryptosystem.
Fermat’s algorithm. Let n be a composite number, n = ab, where 1 < a < b, 
and a is the largest possible. Set a = u — v and b = u + v, where u and v are natural 
numbers, u = v = and n = ab = u2 — v2. Fermat’s algorithm tries to 
represent n in the form n = u2 — v2, which yields a factorization n = (u—v)(u+v) = 
ab.
We work with the quantities
rk — xk—yk — n, k = 0,1,2,... .
The initial values are given by (#o,2/o) = ([x/^],^). If = 0, then n = 
— y% =
(#& ~ yk)(xk + yk), and the algorithm terminates. If > 0, then
(#fc+l, ?/fc4-l) *= 
+ l)j
if rfc <0, then
(^fc+i, 2/fc+i) *= 
4~ 1,3/fc);
and
2 
2
rfc+l := xk+l ~ 2/fc+l —
35

36
2. FACTORIZATION OF INTEGERS WITH EXPONENTIAL COMPLEXITY
We want to show that after a finite number of steps the algorithm reaches the 
value rfc = 0, and, for the first such value, Xk~yk = a, where a is the largest integer 
factor of n not exceeding n1/2. If n is a perfect square, then this is obvious by the 
definition of and y$. We now assume that n is not a perfect square.
Consider the function r(rr, y) = x2 —y2 —n. Clearly, if x and y are nonnegative, 
then
r(z, y + 1) < r(z,y) < r(x + 1, y).
Moreover, in Fermat ’s algorithm, the numbers Xk and yk are always nonnegative 
and do not decrease (by construction).
Consider a Cartesian coordinate system in the plane and the corresponding 
lattice of integral points Z2. It partitions the plane into the union of unit squares; 
each square will be labeled by the point (#, y) corresponding to its lower left corner. 
In the square labeled by (x,y) e Z2 we write the sign of r(x,y): plus, minus, or 0 
if r(x,y) = 0. Clearly, if a square contains a minus, then all the squares above it 
also contain a minus; if a square contains a plus, then the same is true for all the 
squares to the right of it.
In Fermat’s algorithm we move from square to square, starting at the one 
labeled (xq, £/o), which contains a minus. The next step is up, if the square contains 
a plus, and to the right, if it contains a minus. The first step is always to the right.
In Fermat’s algorithm the steps cannot all be up—there will always be steps to 
the right. Suppose we have reached a point (#fc,2/fc), where yk > 1. Using induction 
on fc, we show that r(xk,yk — 1) > 0, i.e., the square under (x^yk) contains a plus.
We check the induction base for the value k = I such that the square labeled 
(xi,yi) = (#b 1) is the first square with yi = 1 and (xi-i,yi-i) = (^_i, 0). We have 
come to that square from below, which means that r(^_i,yi-i) = r(xi,yi — l)> 0. 
This establishes the base of the induction.
We have reached the square (x^yk) either from the left or from below. In the 
former case, we increased ?/, and then obviously r(xk,yk — 1) > 0. In the latter 
case, (xk-i,yk-i) = (%k ~ l,yk\ Then, by the induction assumption,
r(xk-i,yk-i - 1) > 0,
and r(xk-i +1,2/fc-i “ 1) > 0, i.e., r(xk, yk~l) > 0, which proves the desired claim.
Notice that u is the smallest natural number such that n = u2 — v2. Indeed, 
n = ab, b = u = 
= |(a + ^); u'(a) = |(1 - ^), and, since a2 < n, we
have u'(a) < 0; as a increases, u = u(a) decreases and attains the smallest value 
for the largest a, a2 < n.
Suppose we have reached a point (xk,yk) with Xk = u for the first time (as 
was shown above, this will eventually happen). If yk = v, then we have the desired 
result, r(xk,yk) = 0, and the algorithm terminates and outputs the pair (a,&) = 
(u — v,u + v).
If yk < v, then r(xk,yk) = u2 - y%- n = u2 - y%- (u2 - t>2) = v2 - y% > 0. In 
that case we move upward, increasing y until yk+j = v, i.e., we find Xk+j = u and 
2/fc+j = v with r(xk+j,yk+j) = 0- The algorithm terminates and outputs the pair 
(a, &) = (u — v,u + v).
It remains to consider the last case yk > v. But this case is impossible, because, 
as was shown above, the square under (xk,yk) contains a plus, i.e., r(u, yk — 1) > 0. 
Hence the same is true for the squares all the way down. But for our square,

2.2. POLLARD’S (P - 1)-METHOD
37
(xk,yk) = (u,yk) and
r(xk,yk) = u2 -yl~n = v2 -yl <0,
i.e., it contains a minus. Therefore, 0 cannot be anywhere in that column. On the 
other hand, it must be there, because n = u2 — v2.
Thus the algorithm reaches the point (rffc, yk) = (^, v) with = 0 and we then 
have a = u — v.
Remark 2.1. An optimized version of Fermat’s method can be found in [161].
2.2. Pollard’s (P - l)-method
This method was first described in [206]; see also [57, Ch. 8]. It is based on the 
following argument. Suppose the number n, which we want to factor, has a prime 
factor p such that p — 1 is B-power-smooth for some B > 0. This means that
< b
for any prime q such that q | p — 1. This implies that p — 1 | 1cm (1,2,..., B). 
Choosing a e N such that (a,n) = 1, we have, by Fermat’s Little Theorem,
aicm(i,2,...,B) = i(modp).
Therefore, gcd(alcm(1,2,,’B) — 1, n) is divisible by p and hence contains a nontrivial 
factor n (the gcd may actually be equal to n).
Stage 1 of Pollard’s (P-l)-method. In Pollard’s (P-l)-method we choose 
an a priori bound B for power smoothness, based on the power of the computer 
and the time we have for our computations. Normally, B x 105-106. Then we 
make a table qi < #2 < • • • < Qk < B of all primes not exceeding B, and for each qi 
we set
Le-. 
gfte)+1>B.
L log qi J
Next we choose a value for a (e.g., a = 2) and, using exponentiation and reduction 
modulo n, compute
P20 = (a91 
— l)(fl91 
92 
— lb--(a91 
920 
— lj(modn)
(the parameter 20 is also chosen a priori). Next we compute gcd(P2o,n). If that 
gcd is trivial, we then multiply P20 by the next product of length 20, i.e., we find
^40 = ^20 * (fl91 
921 -lb--(a91 
940 
— lj(modn),
compute gcd(P4o,n) again, and so forth. Suppose that, for some k > 1, we have
J3(Q1) 
0(«2O(fc-l))
gcd(P20fc, n) > 1. We then return to k -1 and, setting b = aqi 92°(fc-1) 
? begin 

38
2. FACTORIZATION OF INTEGERS WITH EXPONENTIAL COMPLEXITY
computing the greatest common divisors
gcd(&92°(fc-1)+1 — 1 (mod n), n),
z 2 
x
gcd(&92°(fc-1)+1 — 1 (mod n), n),
/ 
1)4-1) 
\
gcdf &920(fc-1)+1 
- 1 (mod n), nJ,
/ 
k -1 )4-1)
gcd( &92°(fc-1)+1 
'g20(fc-1)4-2 _ i (mod n), n
/ n /(920(fc-i)4-j) 
\
, / , H q20(k- 1)4-J 
. / J x \
gcdl^=1 
— l(modn), n 1,
until we find a nontrivial common divisor.
The purpose of computing the products P20, P40, Peo,---, consisting of in­
crements of twenty powers of primes, is to save time on computing the greatest 
common divisor. Notice that, since the number of primes qi need not be divisible 
by 20, the last group may be incomplete.
Stage 2 of Pollard’s (P — l)-method. Suppose now that p | n and p — 1 is 
not a B-power-smooth number, but p — 1 = f • r, where f is a B-power-smooth 
number and r is a prime number, B < r < Bp Assume that at Stage 1 of Pollard’s 
(P — l)-method we computed
b = alcm(l,2,...,B) (mod
Then br = 1 (mod p), and gcd(&r — 1 (mod n), n) will be divisible by p by Fermat’s 
Little Theorem.
Thus, at Stage 2 of Pollard’s (P — l)-method we find all primes ri,...,rjv, 
B < n < f2 < • • • < nv < Bi, and find the differences d; = n — n_i, i = 
2,...,N. Normally these are not large and the number of distinct differences of 
this kind is also not large (with a suitable choice of Bi). Next we tabulate the 
elements bdi (mod n) for all distinct values of di.
We then determine
Xi = bri (mod n), 
compute
Xi = bri (mod ri) = Xi-i • bdi (mod n), i = 2,..., TV, 
and find
gcd(#i - 1 (mod n), n), i = 1,..., TV.
Here it is also possible to set up the computations in groups of twenty, to save the 
number of computations needed to find the greatest common divisors.
Remark 2.2. An estimate of the complexity of Pollard’s (P — l)-method is, 
in the worst case, Ofn1/2 logc n) arithmetic operations. But in some cases the 
algorithm may find a factor of n faster. In all cases, the algorithm quickly finds 
small prime factors of n, because they are power-smooth for a small B.
Remark 2.3. If one of the gcds computed in the algorithm turns out to be n, 
then it makes sense to try another base a, say, a = 3.

2.3. POLLARD’S p-METHOD
39
Remark 2.4. An improvement of Pollard’s (P — l)-method, based on the dis­
crete Fourier transform, can be found in [177].
Summary. In practice, Pollard’s (P — l)-method is used prior to using more 
powerful factorization algorithms in order to determine small prime factors of n.
2.3. Pollard’s p-method
Pollard’s p-method was first described in [207]. It was used to factor the Fermat 
number F$ = 2256 + 1; see [40]. Some improvements of that method can be found 
in [36]; see also [57, 119, 189], and [118, Ch. 4]. Since the p-method is treated in 
many books and papers, we restrict ourselves to a sketchy description of it.
Description of the p-method.
The input is a number n e N which we want to factor.
Step 1. Choose a map
f: Z/nZ —> Z/nZ.
Normally f(x) is a polynomial of degree 2 or higher; for example, f(x) = x2 + 1.
Step 2. Choose a random xq 6 Z/nZ and compute the terms of a recurrence 
sequence #o, #i, #2, • • • using the rule
Xi = f^Xi-i) (mod n).
Step 3. For some indices j and k check the condition
1 < gcd(#j — x^n) < n
until a factor of n is found or the algorithm runs out of time.
End of algorithm.
Remark 2.5. The choice of the indices j and k in Step 3 can be made by one 
of the following methods.
1. For each j, run through all k with k < j\ this requires a long 1. time and a 
large memory.
2. 
Consider the pairs k and 2k, i.e., verify the condition
1 < gcd(aj2fc - xk,n) < n.
3. 
If 2h < j < 2/l+1, where h e N, then set 3. k = 2h - 1.
Remark 2.6. The main idea of the p-method is very simple. While the period 
of the sequence Xi (mod ri) could be of magnitude n, the period of the sequence 
Xi (mod p) for a prime factor p of n is at most p. This means that Xj and Xk could 
be distinct modulo n but coincide modulo p, i.e., p | gcd(x/ — x^n).
Remark 2.7. To determine periods of recurrence sequences, we recommend 
the methods described in [234]. It is those methods that are used in an optimal 
algorithm for choosing the indices j and k in Step 3. For a more detailed description 
of implementation of various choices for j and k, see [189, 57, 119].
Pollard’s p-method has a heuristic complexity estimate of ^(n1/4) arithmetic 
operations. It is very popular and is often used to find small prime factors of a 
composite number n. The above estimate on the complexity can be derived as 
follows.

40
2. FACTORIZATION OF INTEGERS WITH EXPONENTIAL COMPLEXITY
Proposition 2.8. Let S be a fixed set ofr elements, f:S—>S a map, xq e S, 
and Xq, Xi,X2, ... be defined by Xj = f(xj-i). Let A > 0 and I = 1 + [x/2Ar] < r. 
Then, among all pairs (j, xq), the proportion of the pairs (j, Xq) (where f runs 
through all maps from S to S and xq runs through S) such that xq,Xi,X2, ... ,xi 
are pairwise distinct, is at most e~x.
Proof. There is a total of rr • r = rr+1 distinct pairs (/, Xq). The number of 
pairs (/, Xq) such that £0, Xi, rr2, • • •, xi are pairwise distinct is
r(r — 1) • • • (r — I) • rr~l.
The proportion of such pairs is
J=1 
J=1
Since log(l — x) < — x whenever 0 < x < 1, we have
log*=vlog(i -J < - v3- = -^±1) < Ji. < 
= _A;
\ r) 4^r 
2r 2r 2r
j=i 
j=i
which proves the desired claim. 
□
Why do we need the assertion just proved? If n has a small prime factor p, 
then I = l(n) = 1 + [V2An] is of the order of magnitude n1/2, whereas I = l(p) = 
1 + [\/2Ap] is substantially smaller. But the proportion of the pairs (/, Xq (mod n)), 
where f : Z/nZ —> Z/nZ, such that the elements Xq (mod n),... ,^(n) (mod n) 
are distinct is at most e~x times the number of the pairs (/, xq (mod p)), where f : 
Z/pZ —> Z/pZ, such that the elements Xq (mod p),..., x^ (mod p) are distinct. 
Consequently, we have the following result (see [119]).
Theorem 2.9. Let n be an odd composite number, p a prime factor of n, 
p < y/n, f{x) e Z[rr], and Xq e Z. If the pair (J,Xq (mod p)) is not statistically 
rare, then Pollard’s p-method will find p in O(n1^\og3 n) bit operations.
More precisely, there is a constant c such that for any A > 0 the probability of 
not finding a nontrivial factor of n in c- y/Xn1^ • log3 n bit operations will be less 
than e~x.
Another method for estimating the complexity of Pollard’s p-method can be 
found in [57, Ch. 8]. The arguments there are heuristic and appeal to the con­
cept of probability, but there are no other methods to estimate the complexity of 
Pollard’s p-method.
2.4. The Sherman-Lehman method
In [137], one finds a description of the Sherman-Lehman algorithm, which 
deterministically factors n in Oin1/3) arithmetic operations.
The algorithm.
Let n be an odd integer, n > 8.
Step 1. For a = 2,3,..., [n1/3], check the condition a | n. If in this step n is 
not yet factored, go to Step 2.

2.4. THE SHERMAN-LEHMAN METHOD
41
Step 2. If in Step 1 no factor was found and n is composite, then n = pq, 
where p and q are primes and
n1/3 < p < q < n2/3.
For all k = 1,2,..., [n1/3] and all d = 0,1,..., [n1/6/(4v/^)] + 1, check if 
([x/4fcn] + d)2 — 4fcn
is a square of a natural number. If true, then for A = [y/4kn] + d and B = 
\/A2 — 4kn we have
^42 = B2 (mod n).
Check the condition
1 < (^4±B,n) < n.
If true, then n is a product of two factors and the algorithm terminates.
End of algorithm.
If the algorithm did not factor n into a product of two numbers, then n is a 
prime. Let us prove this. We only need to consider the case n = pq, where p and q 
are primes and
n1/3 < p < q < n2/3.
Lemma 2.10. Under the above assumptions, there are natural numbers r and 
s such that
rs < n1/3, \pr — qs\ < n1/3.
Using this lemma, we set, in the algorithm, k = rs < [n1/3]. Then
4kn = 4rspq = (pr + qs)2 — (pr — qs)2.
Therefore,
(pr + qs)2 — 4kn = (pr — qs)2 = B2,
where B = \pr — qs\ < n1/3. Let
d = pr + qs — [V4kn].
Then
n2/3 > (pr + qs)2 - 4kn
= (pr + qs + V4kn)(pr + qs — V4kn) > 2y/4kn(d — 1).
This yields
n2/3 
nl/6
d < —2= + 1 — —7= + L 
4yfcn 
4vfc
Therefore, k and d are within the limits specified in the algorithm. Hence the 
algorithm will find a number A = pr + qs = [y/4kn] +d such that B = \/A2 — 4kn = 
\pr — qs\ is a natural number. Notice that A2 — B2 = 4kn = 0 (mod n). Now, one 
of the two numbers A ± B equals 2pr and has a common factor with n equal to p, 
because n is odd and is not divisible by any number not exceeding n1/3 and r < n1/3. 
Thus, using gcd(^4 ± B, n) we can factor n.

42
2. FACTORIZATION OF INTEGERS WITH EXPONENTIAL COMPLEXITY
Proof of Lemma 2.10. If p = g, i.e., n = p\ then the assertion of the lemma 
holds for r = s = 1. Thus we may assume that p < q.
Develop q/p into a continued fraction and let Pj/qj denote the jth convergent 
of q/p. Then
Po = [q/p\, qo = 1, o < Poqo < n1/3,
because £ < 
= n1/3. Let m be the first index such that
p n1^
PmQm < Tl1/3, Pzn+lQTn+l > 71 
.
It always exists, because for the denominator of the last convergent we have qw = 
p > n1/3. We show that r = pm and s = qm satisfy the requirements of the lemma. 
Clearly, rs < n1/3. From the properties of convergents we have
|£ _ £1 < |£ _ Pm^\ = 1
Is pl Is Qm+1 । SQm+1
First assume that 
In that case
qm+l — P
IS p\ sqm+1
< I P / Q
V #7n+l V
P . P 
Qm+l Qm+l
1 n n1/2
Pm+iqm+1
which yields the desired assertion.
Now assume that ^2+1. > £. Flipping the fractions > £ 
qm+l P 
qm+l P
By the general properties of continued fractions,
> we have 
qm
Therefore
_L<|£_?|<|£_ gm+11 = 1
rq ~ I r q I “ I r pm^ I rpm^ *
1 < \sq — pr\ = rq\
rq 
rpm+i
n
q . / p
Pm+1 \ Qm+l V Prn+l^rn+l
q = / q 
Pm+1 \ Pm+1
<^1 =
ni/6 n •
q
Pm+1
The lemma is proved.
□
Remark 2.11. The Sherman-Lehman algorithm admits an efficient parallel 
implementation on the computer.
2.5. Lenstra’s algorithm
The following result can be found in [145].
Theorem 2.12. Let r, s, and n be natural numbers such that
1 < r < s < n, n1/3 < s, (r, s) = 1.
Then there are no more than eleven factors ri ofn such that ri = r (mod s). There 
is an algorithm that finds all these ri in O(logn) arithmetic operations.

2.5. LENSTRA’S ALGORITHM
43
Corollary 2.13. Using the algorithm of Theorem 2.12, one can obtain a fac­
torization method for n with O(nx/3 log2 n) arithmetic operations. Let s = [n1/3]+l. 
Using the Euclidean algorithm, we represent n in the form n = n^ni, where 
(ni,s) = 1 and n2 is a product of powers of the primes dividing s. We fac­
tor ni and then factor n2 in a similar way by replacing s by s + 1. Now examine 
r = l,2,...,s — 1, and for those r that are relatively prime with s we find, using 
the algorithm of the theorem, the divisors ri of n\, ri = r (mod s). Since n± and s 
are relatively prime, we completely factor ni.
Corollary 2.14. In 1.8, Chapter 1 we described Lenstra’s algorithm for pri- 
mality testing of natural numbers. The estimate of the complexity of that algorithm 
depends on the initial primes px,.. .,pi such that
s = JJ q > n1/2.
q prime 
q-l|pi---pi
Theorem 2.12 allows us to reduce the number of primes px,...,pi and relax this 
inequality to s > n1/3. At the last stage of the algorithm for primality testing we 
need to recover the possible factors of n from the residues (mod s). In practice, 
this makes the algorithm for primality testing faster.
We only give a partial proof of Theorem 2.12. Namely, we completely describe 
the algorithm for finding n = r (mod s) and justify the estimate for the complexity. 
The proof that there are at most 11 such factors is combinatorial and can be found 
in [145].
Remark 2.15. One can show that for any constant a, | > a > there is a 
constant c(a) > 0 such that, when 1 < r < s < n, (r, s) = 1 and s > na, there are 
at most c(a) positive factors of n congruent to r modulo s. However, no polynomial 
algorithm for finding such factors is now known.
The algorithm.
The input consists of numbers r, s,n e N satisfying the assumptions of the 
theorem.
Step 1. Using the generalized Euclidean algorithm, find r* e N such that 
r*r = 1 (mod s). Find r' such that r' = r*n (mod s), 0 < r' < s.
Step 2. For the current value of i = 0,1,2,..., find the numbers a*, bi, Ci such 
that
CLq = s, b0 = 0, Co = 0,
n — Tr1
ax = r'r* (mod s), 0 < ui < s, bx = 1, ci =----------  r* (mod s)
s 
and for i > 2,
a>i = ai—2 qi^i—x, bi = bi—2 qibi—Xi Ci = Ci—2 qiCi—x (mod s).
Here the integers qi are uniquely determined by the conditions
0 < ai < ai-x if i is even,
0 < ai < ai-x if i is odd.
In fact, qi is the remainder of ai-2 divided by fli-i, except when i is odd and 
the remainder is zero. Notice that the ai are monotonically nonincreasing and are 
monotonically decreasing over even indices.

44
2. FACTORIZATION OF INTEGERS WITH EXPONENTIAL COMPLEXITY
Step 3. For the current values of a*, bi, Ci find all integers c such that 
c = Ci (mod s), 
|c| < s 
if i is even,
Tl>
2a>ibi < c < — + (Libi if i is odd. 
s2
There are no more than two such c; for an even i this is obvious, and for an odd i 
this will be proved later.
Step 4. For each c from Step 3 find integer solutions of the system 
xai + ybi = c, 
(xs + r)(ys + r') = n.
If x and y are nonnegative integers, then add xs + r to the list of the sought factors.
Step 5. If ai = 0, then the algorithm terminates. Else, return to Step 2 with 
the next value of i.
End of algorithm.
Remark 2.16. The system of linear equations in Step 4 can be replaced by a 
single quadratic equation. Let
u = di(xs + r), v = bi(ys + r').
Then
uv = naibi, u + v = s(diX + biy) + 
+ b^' = cs + 
+ ^r',
i.e., u and v are the roots of the polynomial
T2 - (cs + dir + bir'yr + dibin.
Those roots must be integers, one of which is divisible by di and the other by bi. 
Since we are working with large numbers, a repeated extraction of the root of the 
discriminant for finding the roots of a polynomial is, in practice, rather computa­
tionally intensive.
Remark 2.17. Let t be the index such that dt = 0. Since di is obtained via 
the Euclidean algorithm applied to dQ = s and ai, ai < s, clearly, t = O(logs). 
Moreover, by the definition of the numbers di, the index t is even.
Lemma 2.18. The numbers di dnd bi hdve the following properties:
(1) di > 0, bi > 0 for odd i, 0 <i < t;
(2) di > 0, bi < 0, (di, bi) =4 (0,0) for even i, 0 <i <t;
(3) bi+idi - di+rfi = (-1)* • s for 0 < i < t.
PROOF. Property (1) for i = 1 and properties (2) and (3) for i = 0 hold by the 
definition of dQ, 6q, ai, and &i. Now we argue by induction.
Property (3) follows from the relation
&i+2Ui+l — ai+2&i+l = (bi — Qi+2&i+l)Ui+l — (di — Qi_|_2ai+l)&i4-l 
= (bi+idi di+]bi).
The inequalities di > 0 for odd i and di > 0 for even i follow from the definition 
of di. The inequality (di, bi) =4 (0,0) follows from property (3). Now we shall prove 
the inequalities for bi.

2.5. LENSTRA’S ALGORITHM
45
If i is odd, then i <t. We now have
= bi—2 Qibi—i 0,
because bi-2 > 0 and bi-i <0 by the induction assumption and the numbers qi are 
nonnegative by definition. More precisely, in this case a stronger inequality holds: 
bi > bi—2.
Suppose i is even, i < t. By the induction assumption, bi-2 < 0, &i-i > 0, 
and qi is an honest quotient, i.e., qi > 1. Then bi = bi-2 — qibi-i < 0, and even 
bi < bi-2- 
□
Lemma 2.19. Let a>i, bi, t be the numbers in the algorithm. Let x,y e R>o and 
y e R>o. Then there is an index i, 0 <i <t, such that either
—ys < xai + ybi < ys if i is even,
or
xy
2ya>ibi < xai +ybi <----- 1- yaibi if i is odd.
y
Proof. If x = y = 0, then the assertion of the lemma is obvious. Assume now
that either x or y is nonzero. By Lemma 2.18,
za0 + yb$ = xs > 0, xat + ybt = ybt < 0,
and therefore there is an index i such that
xai + ybi > 0, :rai+2 + ybi+2 < 0.
If xai + ybi < ys or rrai+2 + ybi+2 > — ys, then there is nothing to prove. If 
xai + ybi > ys and rrai+2 + ?/&i+2 < — ys, then, by Lemma 2.18,
xaj + ybi 
7
>5 — bi+iai ai+ibi > bi+^ai.
Therefore xai + ybi > 7&i+iai, and, since ybi is nonnegative, we have x > ybi+i 
(notice that ai =4 0, since i <f). Moreover, 
+ ybj+2
7
< —s = bi+2ai+i — ai+2bi+i < bi+2ai+i, 
hence xai+2+ybi+2 < ybi+2ai+i, and since zai+2 is nonnegative, ybi+2 < ybi+2ai+i. 
Notice that bi+2 < 0 because rrai+2 + ybi+2 < —ys < 0. We now have y > yai+i.
Prom the established lower bounds for x and y we have
£Ui+i 4~ ybi+i > t2yai+]bi+i,
i.e., the lower inequality of the lemma holds for an odd index i + 1. We also have 
(x - ybi+1)(y - 7ai+i) > 0.
Therefore
xy - yai+1x - ybi+1y + 72&»+iai+i > 0.
Consequently,
7(ai+ia; + bi+1y) < xy + 726i+iai+i, 
which implies the upper inequality for i + 1. 
□

46
2. FACTORIZATION OF INTEGERS WITH EXPONENTIAL COMPLEXITY
Now we prove that the algorithm finds all factors of n congruent to r modulo s. 
Let xs + r be such a factor (we do not know the value of x G Z>o). For some d G N 
we have (xs + r)d = n, hence dr = n (mod s) and d = nr* = r' (mod s). Therefore, 
d = rf + ys, where y G Z>0 as r' < s. This yields
(xs + r)(ys + r') = n.
Then
rr' + s(xr' + yr) = n (mod s2), 
and
, n — rr'f , x 
xr +yr =---------(mod s).
s
Therefore
/ * Ti-rr' , 
, x
xr r + y =---------r (mod s),
s
i.e.,
zai + ybi = ci (mod s).
The congruence rrao + ybo = co (mod s) is also trivially true. Using the recurrence 
formulas, we have
xai + ybi = Ci (mod s), i = 0,..., t.
Now we apply Lemma 2.19 with 7 = 1. There is an index i such that either
Irra* + ybi\ < s if i is even,
or
2a>ibi < xa>i + ybi <xy + a>ibi if i is odd.
Fix that i and set c = xa>i + ybi. Then c = Ci (mod s). The inequality
(xs + r)(ys + rf) 
n
xy -----------2--------- = ~2
s2 
s2
shows that
|c| < s 
if i is even,
n
2aibi < c < —z + dibi if i is odd.
s2
Hence, c is among the values checked in Step 3 of the algorithm. We have already 
remarked earlier that for an even i there will be at most two such values. For an 
odd i the number c is in the interval [2aibi, 
of length ^—ciibi < Since
n/s3 < 1, only one element from the arithmetic progression Ci (mod s) may be in 
that interval. Thus, in Step 3 of the algorithm we reach that value c = xa>i + ybi. 
Solving the system in Step 4, we will find x and ?/, and therefore find the factor 
xs + r.
Now we want to estimate the complexity of the algorithm. Since the a>i are 
computed via the Euclidean algorithm, t = O(logn). Steps 2, 3, 4 can be performed 
in 0(1) arithmetic operations because, according to [14], extraction of the square 
root of an integer has the same complexity as multiplication. Thus we have a 
theoretical complexity estimate of O(logn) arithmetic operations.
A further improvement of Lenstra’s results was obtained in [331].

2.6. THE POLLARD-STRASSEN ALGORITHM
47
2.6. The Pollard-Strassen algorithm
The Pollard-Strassen algorithm was introduced in [206] (see also [252]). It de­
terministically factors n into a product of two numbers in Ofn1/4 log4 n) arithmetic 
operations, i.e., it has the best complexity estimate among deterministic factoriza­
tion algorithms. The algorithm is based on the following theorem.
Theorem 2.20. Let z e N and y = z2. Then for any natural number t the 
smallest prime factor of gcd(t, yl) can be found in O(zlog2 zlog2t) arithmetic op­
erations.
The Pollard-Strassen algorithm.
Let z = [n1/4] + 1, y = z2 > n1/2 and t = n. Using the algorithm of 
Theorem 2.20, find the smallest prime factor of gcd(n,?/!). Since yl is divisible 
by the smallest prime factor p of n (because p < n1/2 < ?/), the algorithm out­
puts exactly this number p. The complexity of the Pollard-Strassen algorithm is 
<9(zlog2 zlog21) = Ofn^log4 n).
Proof of Theorem 2.20. We shall make use of the equality
yl = fr W
When computing
gcd0’ ((>-
the first nontrivial gcd will show that the minimal prime factor of gcd(£, yl) is among 
the numbers
O' - l)z + 1, (j - l)z + 2,... ,jz.
The first number in this set dividing t is the desired minimal prime factor of 
gcd(£, ?/!); to find it, one needs at most z divisions of t into the numbers of the 
given set.
Let f(x) = [JiJo (x ~ *)• Then
Later in Chapter 9, when discussing the discrete Fourier transform, we show that 
the numbers
f(jz) (mod t), j =
can be found in O(zlog2 zlog21) arithmetic operations. Moreover, to find the first 
nontrivial
gcd(t, f(jz) (mod t)), j = 1,..., z, 
one needs zO(log^) = O(zlog^) arithmetic operations. The total complexity esti­
mate is
<9(zlog2 zlog21) +<9(zlog£) + z = O(z log2 z log21), 
which finishes the proof of the theorem. 
□
The Pollard-Strassen algorithm can be used directly for factorization of in­
tegers that are not too large and also an auxiliary algorithm for the additional 
PS-strategy in subexponential factorization algorithms. This will be discussed in 
the next chapter.

48
2. FACTORIZATION OF INTEGERS WITH EXPONENTIAL COMPLEXITY
2.7. Williams’ (P + l)-method and its generalizations
In [282], one finds a factorization method for n e N using sequences of Lucas 
numbers. This method is similar to Pollard’s (P — l)-method but uses a factor­
ization of P + 1. In [21], this method was generalized using arbitrary cyclotomic 
polynomials. The idea of the (P + l)-method can be described as follows.
Consider the sequence of Lucas numbers defined by
U>o = 0, Ui = Uf 
—— PUn Q'U'n—li
where P and Q are fixed integers. Let p be a prime factor of the natural number n 
such that p + 1 is B-power-smooth, i.e.,
k 
p=n^i-1’ 
i=l
where qi are primes and <B. Let the numbers ft G N be such that
q^<B, qPi+1 > B, i=l,...,k.
Set R = IIi=i ! then P + 1 | -R. If the parameter Q for the sequence of Lucas 
numbers is relatively prime with n and
/P2~4Q\ = 
\ p J
(both of these conditions are heuristically satisfied by random choices of P and Q), 
then, by the properties of Lucas numbers,
P I gcd(uH,n).
The rest of the algorithm consists of a fast computation of ur and finding gcdfu#, n).
It was mentioned in [282] that this method is in practice rather slow. As 
was proved in [21], for a generalization of Williams’ (P + l)-method based on 
cyclotomic polynomials, one can, assuming the Extended Riemann Hypothesis, 
prove a probabilistic polynomial estimate for complexity.
2.8. Shanks’ methods
There are two factorization methods for integers, due to D. Shanks, which use 
binary quadratic forms; see [221, 236, 283]. The first works with positive definite 
binary quadratic forms of a given negative discriminant. In the class group, it finds 
an ambig form that yields a factorization of the discriminant. The complexity of 
this method is O(nx/5+e) arithmetic operations, assuming the Extended Riemann 
Hypothesis. The second method, known as SQUFOF, uses the class group of bi­
nary quadratic forms of positive discriminant. This method also finds an ambig 
form giving a factorization of the discriminant. The complexity of SQUFOF is 
Ofn1/4*6) arithmetic operations; the algorithm works with integers not exceed­
ing 2y/n. SQUFOF is regarded as one of the most efficient algorithms among the 
algorithms with exponential complexity.
A detailed description of Shanks’ algorithms is beyond the scope of this book 
as it requires some facts from the theory of binary quadratic forms. For more 
information, see [49] and [57, Ch. 8].

2.9. OTHER METHODS. SUMMARY
49
2.9. Other methods. Summary
For numbers n of a special form one may be able to use special approaches to 
factorization, because the factors of such numbers may also be of a special form.
Theorem 2.21. Let b, k e N, b > 1, and n = bk — 1. If p is a prime number 
dividing n, then one of the following two assertions holds:
1. p | bd — 1 for some d < k, d | k;
2. p = 1 (mod k).
If p> 2 and k is odd, then, in the second case, p = 1 (mod 2k).
Proof. By virtue of Fermat’s Little Theorem, b^-1 = 1 (mod p), and also 
bk = 1 (mod p). Let d = gcd(fc,p — 1); then bd = 1 (mod p). If d < k, then this 
means that the first assertion of the theorem holds. If d = k, then k | p — 1, i.e., 
p = 1 (mod k). 
□
Example 2.22. Let n = 211 — 1. Then the first assertion of the theorem does 
not hold, since 11 is a prime number but d = 1 does not satisfy the first condition 
(21 — 1 = 1). Therefore, p = 1 (mod 22). This quickly yields n = 23 • 89.
A survey of factorization methods of exponential complexity can be found 
in [272]. References to more recent works can be found in the bibliography sections 
of [22, 57]. We remark that new algorithms of exponential complexity appear of­
ten in the published papers. However, the practical importance of such algorithms 
is somewhat limited. The most popular for practical computations are Pollard’s 
(P — l)-method, Pollard’s p-method, and the Pollard-Strassen algorithm. They are 
used together with the subexponential factorization methods described in Chapter 
3 for a precomputation of small prime factors.


CHAPTER 3
Factorization of Integers 
with Subexponential Complexity
3.1. Introduction
In this chapter we consider factorization algorithms for natural numbers n 
requiring Ln[y; c] arithmetic operations, where 7 = j or 7 = | and c is a positive 
constant depending on the algorithm. No algorithms with complexity estimates 
better than the above are known at the present time.
We assume that the number n is composite (this can be quickly checked with 
the aid of the probabilistic algorithms of Chapter 1) and that n is not divisible by 
small primes (all small prime factors can be found by direct testing or by using the 
algorithms of Chapter 2).
The algorithms described here find natural numbers x and y such that rr2 = 
y2 (mod n) and then check the condition
1 < gcd(# ± ?/,n) < n.
If a factor of n is found, then the algorithm terminates; else it constructs the next 
pair rr, y.
Proposition 3.1. Suppose n is an odd composite number which is not a power 
of a prime. For any random pair x, y, 1 < x,y < n — 1, such that
gcd(z,n) = gcd(p,n) = 1,
#2 = y2 (mod n), 
the probability that
1 < gcd(rr ±y,ri) <n
will be at least 1/2.
Proof. Let n = p*1 • • k > 2, be the prime factorization of n. Given 
a pair rr, y satisfying the above conditions, define a number z, 1 < z < n — 1, 
z2 = 1 (mod n) by z = xy~r (mod ri). It suffices to prove that at least half of those 
z also satisfy the condition
1 < gcd(z ± l,n) < n.
It is clear that the condition z2 = 1 (mod ri) is equivalent to the system
z = ±1 (mod pi1).
z = ±1 (mod p£fc),
51

52
3. FACTORIZATION OF INTEGERS WITH SUBEXPONENTIAL COMPLEXITY
where the signs ± are arbitrary. Thus the number of possible values for z is 2fc, 
and gcd(z ± l,n) equals 1 or n only for the values z = ±1 (mod n). Since k > 2, 
our assertion is now obvious. 
□
The construction of the pairs rr, y such that rr2 = y2 (mod ri) will be inefficient 
for factorization of powers of primes p, i.e., n = pa. Such numbers n are rather 
rare. They can be detected as follows. If a e N, p { a, then ap = a (mod p). Thus 
an = a (mod p), and therefore gcd(an — a, n) \p} i.e., gcd(an — a, ri) > 1. Therefore, 
if gcd(an — a, n) = 1 for some randomly chosen a, then n =4 pa. If gcd(an — a, n) > 1 
for several values of a, then we either factor n (if gcd(an — a,n) < n) or assume 
that n is a power of a prime and try to factor it by extracting roots of order 
2,3,5,7,... from n.
In the algorithms considered below, we shall assume in addition that n is not 
a power of a prime.
Everywhere in this chapter, with the exception of the last two sections, we use 
the notation L = L(n) = exp((log n log log n)1/2). We shall also assume that n is 
not divisible by primes p such that p < L(n); this can easily be checked by direct 
testing in O(L(n)) = Ln[|, 1] arithmetic operations.
3.2. Dixon’s method. Additional strategies
Let n e N be a number to factor, L = L(ri) = exp((log n log log n)1/2), and a a 
constant, 0 < a < 1, whose value will be determined later. A factor base is the set 
of primes p in the interval
2 < p < La.
Let k be the number of primes in the factor base, 2 = pi < p2 < • • • < Pk < 
La. The symbol Q(m) will denote the smallest nonnegative residue in the class of 
m2 (mod n).
Following [209], we now describe Dixon’s algorithm.
Dixon’s algorithm.
Step 1. By random testing, search for numbers mi,..., mfc+i such that
1 < mi < n, Q(rm) = p“iJ • • •p£i’fc
for i = 1,..., k + 1. This means that rri- = Q(m.j) (mod n) are smooth num- 
bers, i.e., they factor into products of elements from the factor base. Let Vi = 
(oti'i,..., otitk) e Zfc be the exponent vector corresponding to the factorization of 
Q(mi).
Step 2. Solving the system of linear equations
xiVi H------ 1- rrfc+iUfc+i = 0 (mod 2)
in the vector space (Z/2Z)fc, find a nonzero solution #i,... ,£fc+i e {0,1} (such 
a solution exists because the number of equations is less than the number of un­
knowns).
Step 3. For the found values Xi,..., Xk we have
(mf1 • • • m^1)2 = pp”1 • • -pp=x Xiai'k (mod n).
Setting
x = 
, Y = n 4E?=+11
J=1

3.2. DIXON’S METHOD. ADDITIONAL STRATEGIES
53
(the numbers (^S^1 xiai,j)/2 are integers, by the definition of £*), we have 
X2 = Y2 (mod n).
Next, check the condition
1 <gcd(X ±Y,n) <n.
If true, we have factored n (the probability of that was estimated in 3.1). If not, 
return to Step 1 and search for other values of mi.
End of algorithm.
Remark 3.2. Factorization of the numbers Q(m,i) in Step 1 of Dixon’s algo­
rithm is done by trial divisions by the elements of the factor base.
Remark 3.3. A solution of the system of linear equations in Step 2 of the 
algorithm can be obtained by Gaussian elimination.
Following [209], we now analyze the complexity of Dixon’s algorithm. We ad­
here to the following convention. Instead of Z/const+°(1) we shall simply write Lconst; 
the quantity o(l) will still be present in the final complexity estimate Ln [|; c]. By 
our definition, const • Lconst = Lconst. Also, 7r(Lconst) = Lconst, where 7r(rr) is the 
number of primes smaller than x.
For a randomly chosen m in Step 1, the factorization of Q(m) in the factor 
base will require La arithmetic operations. Indeed, according to our convention, 
the factor base has k = ir(La) = La primes p < La. A prime number p can enter 
the factorization of Q(m) with multiplicity ap < logp Q(m) < log2 n. Therefore, 
the total number of divisions required to factor Q(m) will be at most
Jog log n
La ■ log, n = La • ——— = La ■ L°™ = La 
log 2
(again taking into account our convention).
Suppose we randomly chose m in Step 1 Lb times for some constant b. This 
would result in La+b arithmetic operations needed to factor Q(m). If we have 
found k + 1 values of m*, then in Step 2, solving a system of linear equations in 
fc + l = La-|-l = Z/a unknowns by Gaussian elimination, we will need another L3a 
arithmetic operations. Using results concerning the distribution of primes, it was 
shown in [209] that, for b = a + after Lb selections of m we will find, with 
high probability, ir(La) + l = La = k + l values of mi such that Q(m,i) factors into 
a product of elements of the factor base. Thus the total complexity estimate for 
Dixon’s algorithm is
£max(a+5,3a) __ £max(2a+^ ,3a)
arithmetic operations. The minimum of max(2a + 
3a) on the interval (0; +oo)
is attained and equals 2. As a result, we have an estimate on the complexity of the 
algorithm for a =
L2-Ln[2;2] arithmetic operations.
Summary. If the factor base consists of all primes p < L(n)1/2, and we 
randomly choose L(n)3/2 values of m, then, with high probability, we will find 
a pair x,y e N such that rr2 = y2 (mod n). This requires Ln[|;2] arithmetic 
operations (assuming that, in Step 2 of Dixon’s algorithm, Gaussian elimination is 
used to solve the linear systems).

54
3. FACTORIZATION OF INTEGERS WITH SUBEXPONENTIAL COMPLEXITY
Now we will discuss additional strategies for optimizing Dixon’s algorithm 
(see [209]).
Strategy LP (using large primes). This strategy was introduced in [44]. 
It is customarily used in subexponential factorization algorithms and algorithms 
for computing discrete logarithms in finite prime fields.
The idea behind strategy LP is as follows. Suppose we are factoring Q(m) = 
m2 (mod n); we have divided by all primes p < La, and Q(m) still has an unfactored 
part s, i.e.,
<2(m) = s- n 
p<L“
Clearly, s > La. If, in addition, s < L2(\ then s is a prime (otherwise s would have 
a prime factor not exceeding y/~s < La). Then we add the large prime s to the factor 
base and keep those values of m for which Q(m) is divisible by s. This increases 
the length of the exponent vectors in Step 1. To return to the original length fc, 
we should remove the additional large primes from the factor base. More precisely, 
if our list contains an additional large prime s, and only one Q(m) is divisible by 
it, then we cross out both s and Q(m) from the list. If, for example, there are two 
numbers Q(mi) and Q(mz) divisible by s, then Q(mi) -Q(m2) = (nw)2 (mod n) 
will be divisible by s2. Therefore, the exponent of s will enter the exponent vector to 
an even degree and will not be present in the system of linear equations over Z/2Z.
One can use strategy LP with two, three, etc., additional primes, i.e., search 
for such m e N that m2 = Q(m) (mod n) and
Q(m) = JJ pQp(TO) • 51s2 • • • st, 
p<L“
where $i,..., st are additional large primes not contained in the factor base. In that 
case, to remove the additional primes, one uses graph theory by first constructing a 
graph and then finding the cycles yielding an even power of the products $i,..., st.
Remark 3.4. A theoretical complexity estimate for Dixon’s algorithm with 
strategy LP does not improve and is still Ln[|;2] arithmetic operations.
Strategy PS (application of the Pollard-Strassen algorithm). In 2.6 
we described the Pollard-Strassen algorithm which, for z e N and y = z2, finds the 
smallest prime factor of gcd(£, ?/!) in O(zlog2 zlog2^) arithmetic operations.
In regard to Dixon’s algorithm, we want to find a partial prime factorization 
of Q(m), consisting of the primes p such that p < La. We set z = [La/2] + 1, 
y = z2 x La, y > La and apply the Pollard-Strassen algorithm no more than log2 n 
times with t = Q(m). In the end, we will find a partial factorization of Q(m) into 
primes p < La in O(log n • La/2 log4 n) = La/2 arithmetic operations (in view of our 
convention). Therefore, the complexity estimate for Dixon’s algorithm will be
£max( j+5,3a) arithmetic operations.
Theorem 3.5. The complexity of Dixon’s algorithm with strategy PS is minimal 
when a = and b = a + in that case it is Ln [|; \/3] arithmetic operations.

3.3. THE BRILLHART-MORRISON ALGORITHM
55
Strategy EAS (early abort). Suppose a, c,0 are some fixed constants, 
0 < a, c, 0 < 1. In Dixon’s algorithm we factored Q(m) by trial divisions into 
p < La. In EAS we first run trial divisions of Q(m) into p < Lae, and if the un­
factored part of Q(m) is greater than n1-c, we discard the current m and move to 
the next one. A detailed analysis of strategy EAS can be found in [209].
Theorem 3.6. Dixon’s algorithm with strategy EAS and a = 
, c = 
0 = |
requires Ln [|; arithmetic operations. With this strategy we examine Lb values 
ofm, where
c 1 — c 
b=a+2^ + ^r-
Remark 3.7. One can use EAS with several aborts, i.e., with some increasing 
sequence 0i and decreasing sequence Ci.
Exclusion methods. There are more sophisticated methods than Gaussian 
elimination for solving linear systems over finite fields. We shall discuss them in 
the last chapter. For example, we mention ([66]) an algorithm for solving systems 
of linear equations in k unknowns over the field Z/2Z in O(fc2,495548) arithmetic 
operations.
Theorem 3.8. Dixon’s algorithm with strategies PS, EAS with several aborts, 
and the algorithm for solving linear systems in k unknowns in O(kx) arithmetic 
operations with X < 5/2 have a complexity estimate of Ln[±; arithmetic oper­
ations.
Remark 3.9. Dixon’s algorithm is a very convenient model for obtaining theo­
retical complexity estimates without any heuristic and unproved conjectures. How­
ever, it is not used in practice; instead of a random choice of m, other methods are 
used. We will discuss them in the subsequent sections.
3.3. The Brillhart-Morrison algorithm
In the Brillhart-Morrison algorithm a random choice of m (as in Dixon’s algo­
rithm) is replaced by a deterministic definition of the next value of m, for which 
we seek the factorization of m2 (mod ri) into the product of primes from the factor 
base. The choice of m is made with the aid of continued fractions for y/n. This 
algorithm was described in [44]; it was used to factor the Fermat number F7. This 
factorization method had been the most popular until Pomerance’s quadratic sieve 
algorithm appeared in 1981. We will discuss it in the next section. For more on 
the Brillhart-Morrison algorithm, see also [118, 285].
The algorithm is based on the following theorem.
Theorem 3.10. Let n e N, n > 16, y/n N. Let i = 0,1,2,..., denote 
the convergents of the continued fraction for y/n. Then the least (in absolute value) 
residue of p2 (mod n) equals p2 — nq2 and
\p2i - n<li I < 2v^-

56
3. FACTORIZATION OF INTEGERS WITH SUBEXPONENTIAL COMPLEXITY
Proof. Let x = y/n > 1. It follows from the general properties of continued 
fractions that
h-?i|. |l+?i|
I Qi । I Qi I
< q2. |Pi±l _ ?i| .(x + 
= (x + PLY
Iqt+i qi\ v qi' qi+i' qi'
We also have
,+«<I+I+I?i±l-«l=2I+^_,
Qi 
I Qi+1 Qi । QiQi+1
because and 21 are on different sides of x. Therefore, 
qi+i qi
< 2x(-l + — + —) = 2x(—1 + 
< 0
' qt+i qi+i' v qi+i '
if i > 1 (since qi + 1 < qi+i then). Thus, for i > 1, we have
IPi - nq-1 <2x = 2-Jn <
since n > 16. This means that for i > 1, the assertion of the theorem is true.
For i = 0, pq = [\/n], Qo = 1 and for e = we have
|[Vn]2 - n\ = K^/n - e)2 - n\ = | - 2ey/n + e2| = e{2y/n - e) < 2^/n.
The theorem is proved. 
□
A continued fraction for y/n can easily be found via the following theorem. 
Theorem 3.11. Let a be a quadratic irrationality, a = ^~u, where D e N,
y/D N, v G N, u G Z, and v | D2 —u. Then for any k > 0,
Q = [do, G-i, . . . , Ufc, 
1 ],
where ao^Z, oi,...,afc GN, and Qfc+i is the (k + l)th remainder. Moreover, 
a0 = [a], v0 = v, u0 = u + aov,
and for k>0 we have
j~y u2 
“\/ L) | uk
afc+i = [afc+i], where vk^-i =--------- € Z, vk+i / 0, afc+i =----------- > 1,
vk 
^fc+l
and the numbers uk are defined by
^fc+l — ®fc+l^fc+l Ufa.
Proof. We induct on k. For k = 0, we have 
11 
v
Ol = ----------  = —==------------  = —=----------------
a-a0 ^D~u - uo \D — u-va^
_ Vq _ s/D + uq _ i/D + Uq 
~ VD-u0~ (D- uD/vq Vj.
The number is an integer because
D — Uq D — (u + aov)2 D — u2 
2 
_
--------=--------------------------------------- 2aou - alv G Z
Vq 
V 
V

3.3. THE BRILLHART-MORRISON ALGORITHM
57
by the assumption. It is also clear that =4 0, because D =4 u2.
Suppose the formulas of the theorem are true for the index k + 1. We shall 
show that they are also true for k + 2. By the definition of the (k + 2)th remainder, 
1 
1 
^fc+i
^fc+2 
r=\ । 
/~r\
^fc+l — 
_ Q, y/D + Ufc — Ufc+l^fc+1
Vfc+l
_ 
^fc+1 
_ 
+ Uk+1 _ VD + t&fc+l
VD - uk+1 (D - ul+1)/vk+1 ~ vk+2
By the definition of the partial quotient, ak+2 = [afc+2]- It remains to show 
D—u2
that Vk+2 = Vk^/~ is an integer. The number
D ^fc+i P (^fc+i^fc+i ^fc)
Vk+2 = ----------------  = ---------------------------------------
Vk+1 
Vk+1
is an integer if and only if the number = Vk is; but Vk is an integer by the 
induction assumption. 
□
Corollary 3.12. In view of Theorem 3.11, we can find a continued-fraction 
representation for y/n using only operations with integers and the operation of find­
ing the integer parts of the numbers of the form .
The Brillhart-Morrison algorithm.
Let PilQi denote the convergents of the continued fraction for y/n (not to be 
confused with the elements {pi} of the factor base). The factor base consists of 
Po = — 1 and primes pi, pi < L(n)a = La, where a = const; we only consider those 
primes for which (^-) = +1. The Brillhart-Morrison algorithm works the same way 
as Dixon’s algorithm, but instead of random values for m we take mi = Pi and, by 
Theorem 3.10 the least (in absolute value) residue of m2 (mod n) equals
Q(mi) = P? - nQ?,
with |Q(mi)| < {ly/n. The last inequality demonstrates the main idea of the al­
gorithm: while in Dixon’s method Q(m) < n, in the Brillhart-Morrison method 
|Q(m)| is substantially smaller (at most 2 y/n). Therefore, the probability that 
Q(m) is smooth (i.e., it factors in our factor base) is heuristically significantly 
greater.
Remark 3.13. If p is a prime number from the factor base and p | Q(mi) for 
some index z, then p { Qi, because (Pi, Qi) = 1. Thus Q2n = P2 (mod p), whence 
the condition (^) = +1.
Following [209], we now estimate the complexity of the Brillhart-Morrison al­
gorithm. To this end, some heuristic assumptions will be made. For example, one 
assumes that if this algorithm has constructed 1 + [log2 n] pairs (rr, p) such that 
#2 = y2 (mod n), then for at least one of them,
1 < gcd(rr ± p,n).
Proposition 3.14. If a = l/y/2 and the factor base consists ofp = —1 and all 
the primes p such that
2<p<La, (-) =+l,
\p/

58
3. FACTORIZATION OF INTEGERS WITH SUBEXPONENTIAL COMPLEXITY
then, when computing the Lb convergents (where b = a + ^) one can expect that the 
algorithm will factor n into a product of two numbers with a heuristic complexity 
estimate o/Ln[|;x/2] arithmetic operations.
Proposition 3.15. Under the assumptions of Proposition 3.14, strategy LP 
yields the same complexity estimate (but in practice this strategy must be used).
Proposition 3.16. Strategy PS with a = and b = a + yields a heuristic 
complexity estimate of Ln[±; arithmetic operations.
Proposition 3.17. Strategies PS, EAS withk terminations, and an algorithm 
for solving a system of linear equations in k unknowns over Z/2Z in O(kx) arith­
metic operations with A < 5/2 yield a heuristic complexity estimate of Ln[%; ^|] 
arithmetic operations.
The Brillhart-Morrison method is substantially less efficient than the quadratic 
sieve method, which will be discussed in the next section.
3.4. Quadratic sieve
The quadratic sieve algorithm was introduced by C. Pomerance in the beginning 
of 1981 (see [209, 210, 213]). A number of improvements of this method were later 
suggested in [30, 51, 61, 201, 217, 246, 254]; see also [57].
A heuristic complexity estimate for the optimized quadratic sieve algorithm 
is Ln[|; 1] arithmetic operations. A record value for a number factored by this 
method is a 129-digit RS A number n (see [20]).
We shall now describe Pomerance’s original quadratic sieve algorithm. We are 
still going to construct the relations X2 = Y2 (mod n) and check the inequalities:
1 
< gcd(X ± Y, n) < n.
To this end, consider the polynomial
Q(x) = (x + [x/n])2 - n = H(x)2 (mod n),
where H(x) = x + [\/n]. The values of Q(x) at integer points are obviously squares 
modulo n. The coefficients of Q(x) are not large—of magnitude n1/2. The factor 
base S consists of pq = —1 and all primes pi, pi < B, such that (^) = +1. Next, 
using a sieve, we find values Xi such that
Ai = Q(xi) =
pes
i.e., Q(xi) factors in our factor base. Setting Bi = H(xi), we have a congruence 
B2 = Ai (mod n), and having accumulated sufficiently many such relations we use 
elimination of variables and construct a relation X2 = Y2 (mod n) the same way 
as in Dixon’s algorithm.
Remark 3.18. The equality (^) = +1 for the primes p from the factor base 
follows from the congruence (x + [\/n])2 = n(mod p), which must hold for some 
x € Z.

3.4. QUADRATIC SIEVE
59
The sieve. The values Xi e Z such that the Q(xi) are smooth can be de­
termined as follows. For each prime p from the factor base we find the solu­
tions and of Q(x) = 0 (mod p) (for example, using a probabilistic algorithm; 
see Chapter 6). Then we vary x e Z in a sufficiently large interval [—M, M], M e N, 
form an array indexed by those values of rr, and place a rough approximation of 
log |Q(rr)| in the element indexed by x. Then we run a sieve for each prime p from 
the factor base S: from the elements of the array whose indices lie in the arith­
metic progressions x = (mod p) and x = (mod p) we subtract a rough 
approximation of logp. The reason for doing this is that for the elements x in those 
progressions the value Q(x) is divisible by p, but for the moment we replace the 
division of Q(x) by p by the subtraction log |Q(#)| — logp. After the application of 
the sieve, the element of the array with index x will have the value
log|Q(a;)|- ^2 loSP-
pes,p\Q(x)
In fact we should run the sieve also for the powers pl for some small I. In 
other words, we must find the solutions r^tl\ of Q(x) = 0(mod pz), and 
then subtract logp from the elements with indices x = r[p^ (mod pl) and x = 
T2'1} (mod pl). After the application of the sieve, the element with index x will 
have the value
log|Q(rc)| — Z1°SP-
pes, pMQC®)
After having finished the sieve procedure, we choose the indices x for which 
the corresponding elements are small in absolute value. For those indices, the value 
Q(x) will most likely factor in our factor base. Now we factor Q(x) by trial divisions 
and keep only those x for which Ai = Q(xi) completely factors in our factor base.
Remark 3.19. The purpose of the sieve procedure is to save a large number of 
divisions of large integers. To wit, instead of trying to factor Q(x) in the factor base 
for each x e [—M; M], we first, using addition and subtraction, substantially shrink 
the set of those x for which we factor the numbers Q(x) by trial divisions. The 
resulting savings are significant, which explains why the quadratic sieve method 
outperformed all previous factorization methods.
Remark 3.20. Since every other integer is divisible by 2, each third by 3, 
etc., we can skip, in the sieve procedure, the powers of small primes, for example, 
pk < 100. Instead, after the sieve procedure, we should take not simply the small 
elements of the resulting array, but the elements not exceeding in absolute value 
some bound which takes account of the several values log 2, log 3, log 5, etc., which 
have not been subtracted from log |Q(rr)|.
Remark 3.21. In the quadratic sieve algorithm one must use strategy LP ([57] 
recommends to use LP with two large primes).
Silverman [246] suggested the use, in the quadratic sieve method, of not one 
but several polynomials Q(x) of the form
Q(x) = Ax2 + 2Bx + O',

60
3. FACTORIZATION OF INTEGERS WITH SUBEXPONENTIAL COMPLEXITY
where A G N, B, C G Z, B2 — AC > 0, and n | B2 — AC. We describe this 
modification following [57]. For the polynomial ^4Q(rr) we have
AQ(z) = (Ax + B)2 - (B2 - AC) = (Ax + B)2 (mod n).
To keep the values of Q(x) small, we run a sieve procedure in the interval
centered at — the rr-coordinate of the vertex of the parabola (here M is some 
chosen parameter). Clearly, for x G I we have
q(~)<qw<q(~+m).
The values of Q(x) will be small if
In that case Q(x) G [-<?(-§ + 
+-^)]- Thus
o2 
o2 
/ / B 
\2 
/ B 
\ 
\
+ 
+2B(--r + M)+C)
A2 
A 
k k A 
/ 
kA 
/ 
/
o2
= -AM2 + -r-C.
A
Therefore,
B2 
AM2 « 2— - 2C, 
A
and A « —. Moreover, n | B2 — AC, and if B2 — AC = n, then
lzv |_z B\| B2 - AC n *fa
x£l /i |^k A/l A y/2n/M V 2
This quantity is of magnitude y/n if M is much smaller than y/n.
Thus to choose the polynomials Q(rr), we first choose M (M is much smaller 
than y/n and is usually of the form Lq [|;const]). We then choose a prime num­
ber A,
. v2n 
a*~m’
Then we find B G Z,
B2 = n (mod A)
(for algorithms to solve quadratic equations over finite prime fields, see Chapter 6). 
We then set C = 
, and
Q(x) = Ax2 + 2Bx + C.
Remark 3.22. 1. For technical details, see [246].
2. Cohen [57] does not recommend changing the polynomials too often.
3. The number A can be composite, a product of several primes q such that 
(£) = +1. Then there are several possible values for B, the solutions of the equation 
z2 = n (mod A). Such a choice of A and B simplifies the initialization procedure 
before running the sieve on {log |Q(rr) |} for a given choice of the polynomials.

3.5. THE METHODS OF SCHNORR-LENSTRA AND LENSTRA-POMERANCE
61
Another choice of the polynomials is offered in [217]. First, choose
u(x) = a2x + &, v(x) = a, w(rr) = a2x2 + 2bx + c
and then use the sieve procedure to find Xi 6 [—M\ such that 
uixi)2 = v(xi)2w(xi) (mod n), Tz(iCi)2 =4 v(zi)2w(zi), 
and w(xi) are smooth. Then, using the exclusion procedure, find a set of indices I 
such that IliGZ w(^i) a square. Setting
X = JJ u(xi), Y = 
10(0:4),
iei 
iei y iei
we have the desired relation
X2 = Y2 (mod n).
In [217] we find an approach that, unlike [57], recommends to often change the 
polynomials u(x\ v(x), and w(x). The initialization before the sieve procedure 
on the values {log |w(rr)|} is done by some efficient “pipeline” method. A further 
improvement of the method of [217] can be found in [201].
In [30] one finds an efficient implementation of strategy LP in the quadratic 
sieve method.
A possibility of an efficient parallel version of the quadratic sieve algorithm is 
described in [39].
Summary. The quadratic sieve method with several polynomials is an efficient 
algorithm that is rather easy to implement on the computer. It appears that it is the 
best of the known factorization algorithms for arbitrary numbers n 6 N, n < IO110, 
not counting the factorization using elliptic curves (see Chapter 4), which may, in 
some cases, work faster. However, for numbers n greater than IO110, the number 
field algorithms are faster than the quadratic sieve method. We will discuss those 
algorithms in 3.6. For a comparison between the quadratic sieve method and the 
number field algorithms, see [79, 80, 81], and also [39].
3.5. The methods of Schnorr-Lenstra and Lenstra-Pomerance
In this section we shall briefly describe two subexponential probabilistic fac­
torization algorithms. One is due to Lenstra and Pomerance [149], the other to 
Lenstra and Schnorr; see [57, 229].
The Schnorr-Lenstra algorithm was the first memory-efficient subexponential 
algorithm. It requires a memory of O(logn) bits, whereas for the methods described 
earlier that requirement is subexponential. The complexity of the method is on 
average Ln[|; 1] arithmetic operations; the algorithm is probabilistic. It works 
with binary quadratic forms of negative discriminant and, using random choices, 
searches for an ambig form in the class group of quadratic forms. That form may 
yield the factorization of n; if not, one makes another random choice.
We remark that the Schnorr-Lenstra algorithm has never been widely used 
in practice. Lenstra’s factorization algorithm, which employs elliptic curves (see 
Chapter 4), has the same complexity estimate, also does not require much memory, 
but the group operations on curves run much faster than the operations in the 
class group of quadratic forms. For that reason, Lenstra’s algorithm is much more 
efficient and is widely used in practice.

62
3. FACTORIZATION OF INTEGERS WITH SUBEXPONENTIAL COMPLEXITY
The Lenstra-Pomerance algorithm is also probabilistic and factors n, on aver­
age, in Ln [^; 1] arithmetic operations. That algorithm, like the Schnorr-Lenstra 
algorithm, works with the class group of binary quadratic forms of negative dis­
criminant and also searches for an ambig form. But the complexity estimate for 
the Lenstra-Pomerance algorithm is strict and does not use unproved conjectures 
or heuristic arguments. Moreover, it was shown in [149] that, for some infinite and 
sufficiently dense sequence of natural numbers n, the heuristic arguments used to 
establish the complexity estimate for the Schnorr-Lenstra algorithm are incorrect. 
Thus, strictly speaking, we cannot say that the Schnorr-Lenstra algorithm has the 
above complexity estimate.
We remark that the Lenstra-Pomerance algorithm, like the Schnorr-Lenstra 
algorithm, has never been widely used in practice.
3.6. Number field sieves
A number field sieve for factorization of integers of a special form (special num­
ber field sieve, or SNFS) was first proposed in 1990 in [141]. It was used to factor 
the Fermat number F9 = 2512+1, which has 155 digits (see [142]). Its heuristic com­
plexity estimate is Ln[l/3; c] arithmetic operations with c = (32/9)1/3 = 1.5263... . 
The numbers n to which SNFS is applied are of the form n = re — s, where r G N, 
sei and r and |s| are not large. In [326] one finds a number field sieve for factor­
ization of integers which are not of a special form, with complexity Ln [1/3; 1,902].
1Mips = million instructions per second.
Later that method was generalized and used to factor arbitrary integers. It 
was called the general number field sieve, or GNFS. Its complexity estimate is also 
Ln[l/3; c] for some constant c.
In 2002, a record number factored using SNFS had 227 digits and was of a 
special form; see [253]. Record factorizations for nonspecial RS A numbers n were 
found in 1999: first, for a 140-digit RSA number (see [53]), and later, for a 155-digit 
RSA number (512 bits); see [54]. The factorization of the last number took about 
8,400 mips-years1. The latest advances in integer factorization using the number 
field sieve can be found at www.loria.fr/~zimmerma/records.
In December 2003, a 174-digit RSA number n was factored. That required 
13,200 mips-years.
In May 2005, a 200-digit RSA number n was factored. The corresponding 
system of linear equations was solved by the block Wiedemann algorithm. (See 
www.loria.fr/~zimmerma/records/rsa200.)
In [296] one finds descriptions of experiments of using GNFS for factoring RSA 
numbers with 100 to 150 decimal digits.
For more on the number field sieves and generalizations, see [76, 79, 80, 81, 
139, 142, 143, 186, 187, 188, 214, 215, 290]. According to [39], this is the 
most efficient method for factoring integers n > 10110 (for a comparison of NFS 
with the quadratic sieve, see the end of 3.4); see also the surveys [198] and [196].
In fact, the number field sieve is not an algorithm. It is a computation method, 
consisting of several stages, each handled by several algorithms. A detailed descrip­
tion of SNFS and GNFS is far outside the scope of this book. To give the reader 
an idea about the number field sieve and the needed tools, we will, following [142], 
give a schematic description of the factorization of the Fermat number Fg.

3.6. NUMBER FIELD SIEVES
63
In this section we assume that the reader is familiar with basic algebraic number 
theory as covered, for example, by [251].
Let N = Fg = 2512 + 1. Its prime factor p? = 2424833 was found already in 
1903. Let n = N/p^. This number was factored using SNFS into a product of 
two prime numbers: n = p$$ • pgg. This required about 700 workstations and one 
supercomputer for solving a system of linear equations; the project took several 
months. It was originally assumed (but not verified) that n is not a power of a 
prime; it turned out to be true.
An overview of the SNFS for n.
Stage 1. Building a factor base.
The factor base consists of a set of elements ap e Z/nZ, ap =4 0, where p runs 
through a finite set of indices IRq . All ap are invertible in Z/nZ (otherwise we would 
find a factor of n). Let Zp° denote the set of |IPo|-dimensional vectors:
ZP° = {(vp)pePo | L>p 6 Z}.
Consider the map
f: ZPo (Z/nZ)*, /((vp)pePo) = ]J “p” (mod n)-
pGPo
It is onto if the {ap} generate (Z/nZ)*; this is usually the case, although it is not 
easy to prove.
Stage 2. Finding the relations.
We are looking for vectors v e Ker/, i.e., such v = (fp)pep0 that
JJ app = 1 (mod n).
PGPo
We need to find a sufficiently large set V of such vectors; more precisely, |V| must 
be a little greater than |PqI-
Stage 3. Finding dependencies.
We are looking for a nontrivial linear dependence modulo 2 for the vectors 
v e V; since their number is greater than the dimension, such dependence does 
exist. To find it, we solve the system of linear equations
zivi = (mod 2)>
where V = {'Uy}- This is a large sparse system of linear equations over the field 
Z/2Z. Upon solving it, we find a nonempty subset W C V such that
^2 v = 0 (mod 2).
vew
Then w = | v *s a vecf°r with integer coefficients and 2w 6 Ker /. Therefore, 
if X = f(W) (mod n), then
X2 = /(2W) = 1 (mod n).
We now check the inequality
1 < gcd(X ± l,n) < n.
If it is true, then a factor of n has been found and we stop. Else, return to either 
Stage 2 (to find new relations), or to Stage 1 (to build a new factor base).
End of overview.

64
3. FACTORIZATION OF INTEGERS WITH SUBEXPONENTIAL COMPLEXITY
To factor the number n = F$/pi, consider the number field K = Q(\/2). The 
elements of the field K are of the form (3 = ^i=0Qi(^)Zi where g* G Q, with 
corresponding vectors (qo>Qi,Q2>Q3>Q4) € Q5- Addition of such vectors is done 
componentwise, and multiplication—using the relation (\/2)5 = 2. Let Norm/3 
denote the norm of the algebraic number /3 G K in K. The symbol /3^ will denote 
the element crj (/3), where cq, <72,03,<74, <75 are all the isomorphisms of K in C.
Lemma 3.23. Let 1 < I < 4, a,b G R. Then Norm (a — 
= a5 — 2lb5.
Proof. Since o-j(\/2)1 are roots of x5 — 2Z, we have
Norm (a - 
= &5Norm
5 
=‘sn(K-^w)=»5(g-2-).
J=1
Let Zk denote the ring of algebraic integers of the number field K. One can 
prove that Zk = Z[<\/2]. Fix a smoothness boundary B G R>o (this is a sufficiently 
large number).
Definition 3.24. A number /3 G Zk is said to be B-smooth if Norm/3 G Z is 
a B-smooth number (i.e.,
Norm (3 = ± JJ prp, 
p prime, 
p<B
where rp G Z>o).
Let R be a commutative ring with identity and a ring homomorphism:
-0: Z[a/2]->B, ^(1) = 1.
Then for c = 
€ N we have c5 = V>(2) = 2 G R.
Conversely, if there is c G R such that c5 = 2 G B, then we can define a ring 
homomorphism : Z[v^2] —> R by ^(l) = 1, 
= c-
Example 3.25. For n = F^/p^, set R = Z/nZ and c = 2205 (mod n). Since 
2512 = — 1 (mod n), we have c5 = 21025 = 2 (mod n). Therefore, there is a homo­
morphism : Z[v^5] —> Z/nZ such that </>(l) = 1 and </>(\/2) = 2205 (mod n).
Lemma 3.26. Let p be a prime, p 1 (mod 5). Then there is a unique c in 
Z/pZ such that c5 = 2 (mod p).
Proof. There is a unique k G N such that 5fc = 1 (mod p — 1), 1 < k < p — 1. 
Thus, if f(x) and g(x) are self-maps of Z/pZ such that f(x) = x5, g(x) = xk, then 
/(p(rr)) is the identity map. Therefore, f(x) is onto, whence our assertion. □
Lemma 3.27. If p = 1 (mod 5), then, in Z/pZ, either there is no c such that 
c5 = 2 (mod p) or there are five elements c G Z/pZ such that c5 = 2 (mod p). If 
those elements are denoted cq, ..., C4, then Cj = cq • a 5 , where a is a primitive 
root modulo p.
Now we consider nonzero ideals ® in the Dedekind ring Zk = Z[y/2]. The 
norm of ® is by definition Norm® = |Zk/®|.
The norm is multiplicative, i.e., Norm21® = Norm21 Norm®. One can prove 
that the field K has only one ideal class; in other words, any ideal in Zk is principal.

3.6. NUMBER FIELD SIEVES
65
Let ^3 =4 (0) be a prime ideal in Zk- Then Zk/^3 = GF(pk) for some prime 
number p and natural k.
Definition 3.28. A prime ideal ^3 is said to be of degree one if Zk/^3 = GF(p), 
where p is a prime number.
By Kummer’s theorem, degree-one prime ideals in Zk are of the form ^3 = 
(p, \/2 — c), where p is a prime number, c e Z, f(x) = x5 — 2, and /(c) = 0 (mod p). 
Moreover, under the natural homomorphism Zk —> Zk/^3 = GF(p), ^2 maps to 
\^2 = c (mod p), and c5 = 2 (mod p).
Lemma 3.29. Ifp 1 (mod 5), then there is a unique prime ideal ^3 of norm p 
in the ring Zk- Moreover, for tv e Zk, the equality ^3 = (tv) holds if and only if 
|Norm (tv) | = p.
Proof. By Kummer’s theorem, the prime ideals Zk lying over p are of the form 
Vi = (P)fi(\^))) where the fi(x) e Z[rr] are monic polynomials, fi(x) (modp) are 
irreducible in Z/pZ[rr], and f(x) = JJi JT (rr) (m°d p). Moreover, Norm(^) = 
pdeg fi(x)' Therefore, % is a degree-one prime if and only if fi(x) is a linear poly­
nomial. By Lemma 3.26, f(x) (modp) has a unique linear factor. The uniqueness 
of V now follows.
If V = (7r)> then Norm *}3 = |Norm7r| = p. Conversely, if |Norm7r| = Norm (tv) 
= p, then factoring (tf) into a product of prime ideals and using the multiplicative 
property of the norm and the uniqueness of ^3, we have (tv) = ^3. 
□
Example 3.30. Let p = 2. Then f(x) = x5 — 2 = x5 (mod 2), and (2) = 
(2, \^2)5 = ^35, where ^3 = (^2) is a degree-one prime. Moreover, Z/^3 = Z/2Z.
Example 3.31. Let p = 3 and f(x) = x5 — 2 = x5 + l (mod 3) = (rr + 1) x (rr4 — 
x3 + x2 — x + 1) (mod 3). Then ^3 = (3, \^2 + 1) is a unique degree-one prime of 
norm 3. For tv = 1 + \f2 we have, using Lemma 3.23, that Norm7r = 3. Therefore 
V = (1 +
Definition 3.32. Let p be a prime number and c e Z/pZ such that c5 = 
2 (mod p). We denote by ^P)C: 
Z/pZ the ring homomorphism defined by
*P,C(^) = c.
Lemma 3.33. Let be a degree-one prime in Z[^2] and ^3 = (p, \/2 — c), 
where p is a prime number, and c5 = 2 (mod p). Let tv e Z[v^]. Then V = W if 
and only if |Norm7r| = p and ^P)C(tf) = 0.
Proof. Clearly,
ZK/Ker M>P)C ~ Z/pZ.
Hence Ker M/P)C is a prime ideal of Zk containing p and ^2 — c, and therefore 
Ker M/P)C = 93.
If |Norm7r| = p and ^P)C(tf) = 0, then tv e V and W and V have equal norms. 
Hence (tv) = ^3.
If V = (7r)> then tv G 93, and therefore $PtC(7r) = 0. Now the equality 
|Norm7r| = p is obvious. 
□
Example 3.34. Let tv = 1 + (\/2)2 — 2(\^2)3, Norina = —151, and p = 151, 
a prime number. If c = 116, then c5 = 2 (mod 151). It is not difficult to see that 
^151,116 W = 0 (mod 151). Therefore V = (151, y/2 — 116) = (tv) is a degree-one 
prime of Z^.

66
3. FACTORIZATION OF INTEGERS WITH SUBEXPONENTIAL COMPLEXITY
Corollary 3.35. Using Lemma 3.33, one can find generators of degree-one 
primes in Z^.
Definition 3.36. A number e e Zk is called a unit of K, if 6-1 e Zk-
By Dirichlet’s unit theorem, any unit e of K is of the form 
e = ±4142> 
11^6 2,
where 6i and 62 are fundamental units of K.
Since K has trivial divisor class group, any nonzero prime ideal is of the form 
= (fRp) for some 7np e Z^. Then for any (3 6 Zk \ 0, the factorization
v
implies that
61j7l\p 
,
where e is a unit of K. Moreover, |Norm/3| = |Norm7rqj|m^^.
Example 3.37. Let 0 = -1 + (\/2)4, Norm/3 = 15. Then (/?) = qji<p2, where 
are prime ideals of norms 3 and 5, respectively. Such ideals are unique. 
Moreover, = (1 + v^2) (Example 3.31) and ^J2 = (1 + (v^)2)- Therefore 
—1 + (^2)4 = 6i(l + ^2)(1 + (^2)2), and thus 61 = — 1 + The element 61 is a 
unit of K with Norm 61 = 1.
Example 3.38. Let (3 = 1 + (v^)3. Then, similarly to Example 3.37, we have 
1 + (^2)3 = 62(1 + \/2)2, and 62 = — 1 + (v^)2 — (v^)3 + (v^)4 is another unit of 
K. Notice that Norm62 = 1.
In the number field sieve for factoring n = F^/pi, the authors ( [142]) assumed 
that 61 and 62 found in Examples 3.37 and 3.38 are fundamental units of K. Under 
that assumption, the algorithm produced no contradiction and successfully termi­
nated. We remark that while there were algorithms for constructing fundamental 
units of a number field (see [205]), they were not used.
Let 6 be an arbitrary unit of K. Then e = Cq0^1^2, where 60 = —1, the units 
61,62 were found in Examples 3.37 and 3.38, and Vj e Z. We need to determine ^o, 
Vi, starting with 6. Clearly, vq = 0 if Norm6 > 0, and Vq = 1 if Norm6 < 0. Set
A1 = e(°g2)/5, A2 = e 6 
, A1(A2eC,
and consider the ring homomorphisms
: Z[^2] -> C,
= Xj, j = 1,2. Then for j = 1,2 we have the equalities log |Wj(e)| = 
Vi log |%(ei)| + v2 log (€2)1, and the determinant of ||log 
(e*)l||_, fc=1 2 can
shown to be nonzero. Since Vi, v2 are integers, we can find them by iteration, 
provided we know 6.
We now build a factor base, the first stage of the algorithm. Choose B = 
1294973 as a smoothness boundary for n = F^/pi. Thus we consider all primes 
p < B. For each p we must find c e Z/pZc5 = 2 (mod p) and construct a table 
of pairs (p, c) corresponding to degree-one primes = (p, \/2 — c). To find c one 
can use a probabilistic algorithm for solving f(x) = 0(mod p) (see Chapter 6).

3.6. NUMBER FIELD SIEVES
67
More precisely, if p 1 (mod 5), then c = 2k (mod p), where 5fc = 1 (mod p — 1). 
If p = 1 (mod 5), then we first check the congruence 2^p-1^/5 = 1 (mod p). If it 
does not hold, then the equation c5 = 2 (mod p) cannot be solved. Else, apply the 
probabilistic algorithm for solving x5 — 2 = 0 (mod p).
Having found a set of degree-one primes ^3 = (p, \/2 — c), we need to find mp G 
Zr such that = (mp). This can be done as follows. Consider the set
M=0
n g z, |n| < const >.
Theoretical estimates for the constant in the definition of T can be extracted from 
the results of [31, Ch. 2]. For tv G T compute Norm7r. If Norm7r = p is a prime 
number and p < B, then we examine the degree-one primes dividing p, i.e., 
— c). If such an ideal is unique, then it is generated by tv = mp.
If there are several such then tv generates the ideal for which M/P)C(7r) = 0 
(according to 3.33).
In fact, a little more sophisticated approach was used in [142]: first the numbers 
tv = 
where a = — (v^)3, were examined. Here the Si are relatively prime
integers such that > 0 if = • • • = S4 = 0, and si * 
— 15000.
This resulted in 49,726 generators of the degree-one primes. In all, there were 
99,500 generators of the prime ideals for our table of pairs (p, c) w 
The re­
maining generators were found by a similar examination of the ideals 
of norm
8 Norm (here a = — (v^)3), i.e., by first finding elements tv' of norm 8p and then 
by dividing tt' by a, which resulted in the generators mp.
Now we may assume (replacing, if necessary, mp by — 7np), that NormTnp > 0.
Now consider the homomorphism
</>: Z[^] -> Z/nZ,
</>(l) = 1 (mod n), <fi(y/2) = 2205 (mod n), of Example 3.25. For a = — (v^)3,
</>(a) = -2615 = 2103 (mod n),
because 2512 = — 1 (mod n). The number 2103 is of magnitude n1/5, an observation 
that will be useful to us later. Notice that, for a, b G Z, we have
</>(a + ba) = a + 2103& (mod n).
The factor base IPq we are building will consist of:
1) 99,700 primes p, p < B\ = 1295377;
2) 
60 = —1,^1, Q from Examples 3.37 and 3.38;
3) The generators mp for the 99,500 degree-one primes C Zr, with Normal < 
B2 = 1294973.
For each index p G IPq we set
ap = </>(p) G Z/nZ.
This concludes Stage 1 of the algorithm.
Now we describe Stage 2 of the algorithm—finding the relations. Trivial rela­
tions of the form 6q = 1 and 2 = (v^)5 will not be used. There are 4944 primes p 
in our factor base such that f(x) = x5 — 2 (mod p) is a product of linear factors. 
For those p we have
p=e n
vkp)

68
3. FACTORIZATION OF INTEGERS WITH SUBEXPONENTIAL COMPLEXITY
where 7np are the found generators of the prime ideals and e are units of K. For 
each e we find a representation e = e”1 using iterations (as was described above); 
6o = — 1 is not part of this representation, since p > 0 and all mp are positive by 
construction. Thus
4>(p) = <f>(ei)V14>(e2)V2 J}
W(p)
These relations constitute approximately 2.5% of all the relations constructed in 
Stage 2.
The remaining relations are constructed using various sieves. We examine the 
pairs a, b e Z, b > 0 such that
1) gcd(a,b) = 1;
2) |a + 2103b| = \(/)(a + ba)\ is Bi-smooth, except perhaps for one prime factor 
pi, Bi <pi < 108;
3) |a5 — 8&5| is Ba-smooth, except perhaps for one prime factor p2, B2 < P2 < 
108.
If pi and P2 are not present, then the pair a, b yields a complete relation; 
otherwise the relation is said to be partial. Notice that since Norm (a + ba) = 
a5 — 8b5, the number a + ba is ^-smooth if P2 = 1.
Lemma 3.39. Let a,b e Z, (a,b) = 1. Then any prime ideal 
dividing
a + ba is of degree one. Moreover, if the prime factorization of Norm (a + ba) is of 
the form
m
Norm (a + ba) = JJ q^, 
k=l
then the ideal (a + ba) of Zk factors into prime ideals as follows:
m
(a + ba) = 11^*
fc=l
Here Qk | (qk); for k > 2,
&k = (<qk,V2-2~1(ab-1)2 (modgfc)),
and if qk = 2, then Qk = (v^).
Proof. Let p > 2 be a prime number, a prime ideal such that | (p) 
and | (a + ba). Since (a, b) = 1, we have p\b. Therefore, ab-1 (mod p) e and 
hence
(ab-1 (mod p))2 — a2 = (ab-1 (mod p))2 — 2\/2 e
— (2-1(ab-1)2) (mod p) e
By Lemma 3.23, Norm (a + ba) = a5 — 8b5. As a5 — 8b5 = 0 (mod p), we have 
(2-1(ab-1)2)5 - 2 = 0(mod p).
Let c = 2~1(ab~1)2 (mod p). By Kummer’s theorem, Q = (p, c) is a degree-one 
prime and £1 e ^3. Therefore, £1 = is a degree-one prime.
We have also shown that for each prime number p = qk dividing Norm (a + ba), 
the prime ideal £lk of Zk dividing both a + ba and qk is uniquely determined by 
the formula in Lemma 3.39. Therefore (a + ba) = HaXi &kk- 
□

3.6. NUMBER FIELD SIEVES
69
Corollary 3.40. Lemma 3.39 reduces the factorization of the ideal (a + ba) 
(where (a,b) = 1) into a product of prime ideals to an integer factorization of 
Norm (a + ba) = a5 — 8b5 into a product of primes. More precisely, let
(a + &a)= n
are prime ideals
Norm (a + ba) = ]J(Norm‘P)fe!iI.
V
Let be a prime ideal dividing a+ba and such that Norm^J =p is a prime number.
1) Ifp 1 (mod 5), then, for a given p, the ideal is unique by Lemma 3.29. 
In this case, ky = Z4p((a + ba)) = vp(a5 — 8b5).
2) If p = l (mod 5), then we first need to determine if, for some c in the found 
set, the prime ideal = (p, 
— c) enters the factorization of the ideal (a + ba).
Invoking the map from the proof of Lemma 3.39, we have
c = M>(v/2) (mod p), 
and ifty | (a + ba), then
M/(a + ba) = aMZ(l) + b^(a) = 0 (mod p).
Hence
M/(a) = c3 (mod p) = - (mod p).
b
Therefore 
2
c6 = 2c = f7) (mod p), 
2 
\ b /
showing that c = 2-1 (|) (modp) is uniquely determined by a, b, and p. Then, for 
this c, = (p, 
— c) and vy(a + ba) = vp(a5 — 8b5).
Thus, we can factor the ideal (a + ba) into a product of prime ideals of Z&.
We now return to the task of finding relations in Stage 2 of the algorithm. 
Suppose (a, b) = 1 and the pair a, b yields a complete relation, i.e., |a + 2103&| is Bi- 
smooth and Norm (a + ba) = a5 — 8&5 is B2-smooth. Then we have the following 
relations.
1) a + ba = e fjtp > where e is a unit, are prime ideals, and Norm < B2. 
By the method described above, we find the exponents uy. Then we compute
e = (a + ba)/ JJ
and find the factorization for e:
f _ ^0 Vi V2
e — e0 el e2 •
The exponent Vq is determined by the sign of c, whereas and V2 are found by 
iterations, as was described above.
2) a + 2103& = ± rip<B1 PWpi and we find this factorization using a sieve, which 
will be explained a little later.
We now apply the map </> from Example 3.25. Then
± 
= a + 2103& = </>(a + ba) (mod n)
2
=n n (m°d n)>
i=0 

70
3. FACTORIZATION OF INTEGERS WITH SUBEXPONENTIAL COMPLEXITY
and this is the relation between the elements of the factor base which was con­
structed at Stage 2 of the algorithm.
We considered pairs a, b giving rise to complete relations. If a relation is partial, 
i.e., there are extra primes pi, p2, then, using the exclusion method, we construct 
one complete relation from several partial ones. Here one uses graph theory; we 
skip the details.
Having accumulated sufficiently many such relations, we go to Stage 3 and find 
X e Z, X2 = 1 (mod n), by solving a system of linear equations over Z/2Z. For the 
factorization of n = Fg/p7i structured Gaussian elimination was used for solving 
such a system (see Chapter 11).
We now explain how the pairs a, b e Z, (a, b) = 1, such that a+2103& and a5—8&5 
are Bi- and B2-smooth, respectively, were found. That was done using a sieve 
method similar to the quadratic sieve method of 3.4.
Fix &, 0 < b < 2.5 • 106. Choose an interval [—A; A] (where A depends on 6) 
in which the values of a will lie. We build an array indexed by a e [—A; A], 
a € Z, (a, b) = 1. In the element indexed by a we place a rough approximation 
of log |a + 2103&|. Then for each prime number p, p < Bi, consider the arithmetic 
progression of the indices a such that a + 2103& = 0 (mod p), i.e., a = ao(p) +jp,j 6 
Z. Now subtract a rough approximation of logp from the elements of the array 
indexed by a. A similar sieve is applied for some powers pk of the prime p: in the 
progression a + 2103& = 0 (mod pfe), we subtract logp from the elements of the array 
indexed by a.
After we have run the sieve over all p, our array will contain some resulting 
values. If the element indexed by a is small, then it is likely that a + 2103& is B±- 
smooth. We then factor a + 2103& using trial divisions by p < Bp If a + 2103& 
is Bi-smooth, except perhaps for one prime pi, Bi < pi < 108, then we save the 
pair a, b in some array M.
Remark 3.41. In reality, the sieve method is more sophisticated, but we do not 
want to discuss that. The reader may consult the original paper [142] for further 
details.
Now, for the pairs a, b from M we run a similar sieve to find B2-smooth numbers 
a5 — 8&5 = Norm (a + ba). In the end, we will have a set of pairs a, b giving rise to 
complete or partial relations.
The factorization of n = F$/p7 required 44,106 complete relations and 2,903,999 
partial ones. A total of 700 workstations were used during 5 weeks, which required 
about 340 mips-years. After that, it took another 6 weeks to solve a system of linear 
equations over Z/2Z on a supercomputer. As a result, n factored into a product 
of two numbers. Using the Cohen-Lenstra algorithm (see Chapter 1), it was shown 
that each of the two factors was prime. That completed the factorization of the 
Fermat number F$.
Remark 3.42. It remains to explain how the number field K = Q(v^) was 
chosen for the factorization of n = F$/p7. Following [139], we shall describe the 
choice of the number field for the factorization of n = re — s. Choose a small d e N 
(usually, d = 3,5,7) and set k equal to the least natural number such that kd > e. 
Let t = s • rkd~e; t is not large. Let
f(x) =xd -t, m = rk « n1/d.

3.7. SUMMARY
71
Then f(m) = md — t = rkd — srkd~e = 0 (mod n). If f(x) e Z[rr] is an irreducible 
polynomial, then we set K = Q(a), where a e C, f(a) = 0. Clearly, [K : Q] = d.
The rest of the algorithm takes place in the ring Z[a] C Z^. Recall the ring 
homomorphism </>, </>(l) = 1 (mod n), </>(«) = m (mod n). If Z[a] = Zk and K has 
trivial divisor class group (as was the case for n = F9/P7), the number field sieves 
become more efficient.
This finishes a schematic description of the number field sieves for integer fac­
torization.
In [297] one finds a new approach to the sieve procedure based on efficient 
use of the cash memory. Applying this method and SNFS, the authors factored a 
248-digit number.
New methods for finding polynomials used in the number field sieve can be 
found in [361].
For possible applications of the number field sieve to other computational prob­
lems of algebraic number theory and to the discrete logarithm problem on algebraic 
curves, see [303].
A new, efficient method for extracting the square root of an algebraic number in 
a number field geared toward the number field sieves for factorization was developed 
in [409] and [412]. We remark that in the general number field sieve there is 
one more stage, extraction of the square root, after solving the system of linear 
equations.
In [304] one finds an improvement of the stage that solves the system of linear 
equations in the number field sieve for integer factorization, the so-called circuits 
for integer factorization. A further investigation of that method can be found 
in [395]. It shows that the length of the machine representation of the numbers 
that can be efficiently factored by the NFS can be increased 1.17 times. The authors 
of [395] conclude that the security of the RSA cryptosystem is really based on the 
complexity of the stage in the NFS which finds the relations.
Recently, substantial effort has been made to create usable devices for accel­
erating the sieve stage of the number field sieve. New approaches were suggested 
in [435] (the TWINKLE device; see also [394]) and [436] (the TWIRL device). It 
was shown in [436] that the TWIRL device is a threat to 1024-bit RSA moduli. 
Yet another device for use in the sieve stage was suggested in [357].
In [396] one finds an analysis of the possibility to factor 1024-bit RSA moduli 
using the number field sieve and the TWIRL device.
3.7. Summary
To factor a natural number n, we first, by directly testing p = 2,3,5,7,... 
up to some boundary, identify small prime factors of our number. Then we check 
whether the number we want to factor is composite. For that, it is best to use 
the Miller-Rabin probabilistic test of Chapter 1. If our number is probably prime, 
then we try to prove that, using the Cohen-Lenstra algorithm of Chapter 1. If 
our number is composite, then we can try to find its factorization using Pollard’s 
(P — l)-method and Pollard’s p-method of Chapter 2, as well as Lenstra’s elliptic 
curve method (see Chapter 4). After that, we apply the quadratic sieve method, 
if our number n does not exceed IO110. For larger numbers, we use number field 
sieves.

72
3. FACTORIZATION OF INTEGERS WITH SUBEXPONENTIAL COMPLEXITY
In regard to open-key cryptography, we see that the RSA moduli n which are 
products of two primes are not safe for encoding if n « 2512. By [39], the RSA 
moduli n ~ 21024 will remain safe for at least 15 years since the time [39] was 
written, unless conceptually new factorization algorithms are found or an efficient 
quantum computer is developed.
It was shown in [442] how to obtain information about the unknown prime 
factors of composite natural numbers, using tests with the Gauss trigonometric 
sums for numerical characters.
In [307], one finds an algorithm which, for a given finite subset N of natural 
numbers N and for a given finite set P consisting of odd primes, finds the sets 
Sn = {p € P | n = 0 (mod p)} for all n G N. That algorithm can be used, for 
example, in factorization algorithms with sieves (the quadratic sieve or the number 
field sieve), because it sufficiently quickly recognizes smooth numbers. That paper 
also contains a vast bibliography on integer factorization.
In [305], one finds new, fast algorithms for listing p-smooth numbers not ex­
ceeding x and algorithms for counting such numbers.
We remark that there are cryptographic protocols which can be used to show 
that a given natural number is a prime or that it is a product of two primes, etc. 
See [318, 391, 421].

CHAPTER 4
Application of Elliptic Curves to Primality Testing 
and Factorization of Integers
4.1. Introduction. Elliptic curves and their properties
For more than fifteen years elliptic curves have been widely used in various 
cryptosystems as well as in number-theoretic algorithms for primality testing and 
for factorization of integers. In this chapter we describe some basic properties 
of elliptic curves and their algorithmic applications in number theory. Detailed 
expositions of the theory of elliptic curves can be found in [131, 244, 245]. For 
applications of elliptic curves to cryptography, see the monograph [29] and the 
papers [171, 164, 120, 121, 162].
Let K be a field, char K =4 2,3. An elliptic curve over K is given by an equation 
y2 = x3 + ax + &, where a, b G K, 4a3 + 27b2 =4 0.
It is denoted E or Eajj. If Ki is a field containing K, then the set of points of the 
curve is denoted
Ea,6(Ki) = E(Ki) = {(a:,y) e K,: y2 = x3 + ax + b} U {£»}.
Here O is the “zero point” of the curve or the “point at infinity”. This is a formal 
point which has no coordinates. It becomes an ordinary point only if we switch to 
a projective space. Set x = X/Z and y = Y/Z in the equation of the curve. Then 
Y2Z = X3 + aXZ2 + bZ3 and we have the points (X : Y : Z) in the projective 
space over K (or over Ki D K) satisfying this equation. The points with Z =4 0 
(we may assume that Z = 1) correspond to the points (XfZ,iYlZ') of the affine 
curve Eatb(K) (or Pa,&0Ki))- If Z = 0, then the equation shows that X = 0. Then 
Y =4 0 and we may assume that Y = 1. This point (0 : 1 : 0) in the projective space 
corresponds to the point at infinity O of the affine curve.
On an elliptic curve over K one can define addition ® with respect to which 
the sets Pa,&(Ki), for fields Ki D K, become abelian groups. Addition is defined 
by the following rules.
1. M®O = (x,y), O®O = O.
2- (x,y)® (x,-y) =O.
3. Let P = (21,3/1), Q = (x2,y2) and xi / X2- Consider the “line” through 
P and Q
, \ / s x 3/2 - 3/1 
3/= 3/1 + A(x - o;i), A =---------
£2 
X1
and determine the intersection points of the curve and the line. Those are P, Q and 
E, where R = (£3,3/3), £3 being the third solution of the equation
(3/1 + A(z - £i))2 = £3 + ax + b.
73

74
4. CURVES, PRIMALITY TESTING, AND FACTORIZATION
By Vieta’s theorem,
zi + #2 + z3 = A2, £3 = -£i - x2 + A2.
Then 2/3 = 2/i + A(£3 — 
. We now define the sum P © Q of P and Q to be
P®Q = (z3,-?/3).
4. Let P = (£o,3/i) and Q = (£0,3/2), where y\ =4 — y2. It follows from the 
equation of the curves that 2/1=2/27^ 0- Set yo = yi = y2- Then the double of 
P = (a?o,3/o), i«e., the point 2P = P ® P, is determined via the “tangent”. The 
equation of the curve shows that 2ydy = (3£2 + d) dx. The tangent to the curve 
at P is of the form
। \/ 
\ x 3#o + a
y = yo + A(z - £0), A = —----- .
23/0
Substituting this in the equation of the curve, we have an equation
(3/0 + A(£ - £0))2 = £3 + ax + b
with £0 a root of multiplicity two. By Vieta’s theorem, the third root equals 
£3 = —2£o+A2. Hence p3 = ?/o+A(£3—£o)« We now define 2P = P&P = (£3, — y$).
One can show that, for the addition just defined, the set Eaj,(Ki) is an abelian 
group. If Ki is finite, then it is a finite abelian group.
Theorem 4.1 (Hasse’s theorem). Let p be a prime number, p > 3, and Eaj> 
an elliptic curve over %j/p%j. Then
||K,d(z/pZ)|-(p + i)|<2Vp.
The quantity |Ea)b(Z/pZ)| can be found using the following obvious formula:
I^,4(WI = 1+ E
icGZ/pZ
/£3+fl£ + &\
=P+i+ 22 (—-—)
' \ p /
icGZ/pZ
(here (^) is the Legendre symbol).
Let |Ea)f,(Z/pZ)| =p + l — t. Then, for eachj G N, the quantity |Eoj>(GF(p*))| 
is given by
|Ea.b(GF(p*))|=p* + l-^, 
where tj satisfies the recurrence relation
^7+1 = iitj 
3 — 1, ti = to = 2.
In 4.3 we shall describe algorithms which determine the order of the group of 
points of an elliptic curve over a finite prime field.
Definition 4.2. The j-invariant of an elliptic curve E is
4u3
j = j(E) = 1728 • 4a3 + 27ft2.

4.2. LENSTRA’S ALGORITHM FOR FACTORIZATION OF INTEGERS
75
4.2. Lenstra’s algorithm for factorization of integers 
using elliptic curves
Lenstra’s probabilistic algorithm [147, 146] for factorization of integers using 
elliptic curves has an average complexity estimate of
e((2+o(l))logploglogp)1/2 Iog2 n
arithmetic operations; here p is the minimal prime factor of n. If we replace p 
by n1/2, then we obtain a subexponential complexity estimate of Ln[l/2; 1]. This 
method was later improved in [175]; see also [19, 37, 75, 248], and [57, Ch. 10]. In 
1995 this method was used to factor the Fermat number Fio = 21024 + 1 (see [38]). 
The factorization is of the form
Fio = P8 • P10 • P40 • P252,
where pj denotes a prime number with j digits. The factorization took approxi­
mately 240 mips-years.
Since the above complexity estimate for Lenstra’s algorithm depends on the 
magnitude of the minimal prime factor, this method is well suited for finding small 
prime factors. Another advantage of this method is a modest requirement on com­
puter memory. To derive a complexity estimate for Lenstra’s algorithm one needs 
deep results from the theory of elliptic curves and modular forms. However, the 
algorithm itself is rather easy to describe and is equally easy to implement on 
the computer. A description of Lenstra’s algorithm, besides the references already 
mentioned before, can be found in [119].
To describe Lenstra’s algorithm we will need elliptic curves not over a field, 
but over the ring Z/nZ, where n is an odd composite number not divisible by 3, 
which we want to factor. Consider the triples of numbers (#,?/, z) G (Z/nZ)3 such 
that the ideal generated by £, ?/, and z, coincides with Z/nZ. This happens, for 
example, if gcd(#,n) = 1. The orbit of such a triple (#,?/, z) G (Z/nZ)3 is the set
{(ux^uy^uz) | u e (Z/nZ)*}.
It is denoted (x : y : z). The set of all orbits is denoted IP2(Z/nZ). This is an 
analog of the projective space over a field.
An elliptic curve E = Eaj> over the ring Z/nZ is given by 
y2 = x3 + ax + &,
where a, b G Z/nZ, 6(4a3 + 27&2) G (Z/nZ)*. The set of points of the curve is 
denoted
E = Fa>b(Z/nZ) = {(# : y : z) G IP2(Z/nZ) | y2z = x3 + arrz2 + bz3}.
On this set we shall use the same group operations as over a finite prime field (see 
4.1). More precisely, let
O = (0 : 1 : 0) G IP2(Z/nZ),
Vn = {(z : y : 1) | x, y G Z/nZ} U {£>}.
For P G Vn and any prime number p dividing n, let Pp denote the point of IP2(Z/pZ) 
obtained from P by reduction modulo p. Clearly, Pp = Op if and only if P = O.
The addition of points P, Q G Vn will be done as follows (assume that a is 
given). When computing the sum P © Q, we either find a factor d of n (and then 
our goal of factoring n is reached) or find a point R G Vn such that if p | n,

76
4. CURVES, PRIMALITY TESTING, AND FACTORIZATION
a = a (mod p), and there is b e 'L/pL such that 6(4a3 + 2762) =4 0 in Z/pZ and 
Pp, Qp £ 
then Rp = PP®QP in 
where the sum is computed
by the rules for an elliptic curve over a field, as described in 4.1.
Remark 4.3. If we have a point P = (x : y : 1) and the numbers p and a, 
then y2 = x3 + ax + b (mod n). Therefore b = y2 — x3 — ax (mod n) is uniquely 
determined modulo n. Then the same is true for b = b (mod p). If for each p | n 
the reduced point Qp is on the curve y2 = x3 + ax + b (mod p) over Z/pZ, then we 
can add Pp and Qp on the curve over Z/pZ and compute P (B Q over Z/nZ. If for 
some p the point Qp is not on the curve y2 = x3 + ax + b (mod p), then the points P 
and Q cannot be added.
Addition of ponts P and Q from Vn will be done as follows. If P = (9, then 
R = Q\ if Q = O, then R = P. Now let p, Q =4 (9, P = (xi : 2/1 : 1), and 
Q = (#2 '• V2 • 1)- Using the Euclidean algorithm, we find d = gcd(#i — 
If 1 < d < n, then we have found a factor of n, and the algorithm terminates. If 
d = 1, then Xi X2 (mod n), and Xr X2 (mod p) for any prime p, p | n. Then 
(using the generalized Euclidean algorithm) we find (a? 1 — a^)-1 (mod n). Now set
A = (yi — P2)(#i — ^2)”1 (mod n), v = y± — A^i (mod n), 
x$ = — x\ — X2 + A2 (mod n), 2/3 = — Xx$ — v (mod n) 
and define the sum of P and Q by R = P ® Q = (23 :2/3 : 1).
Notice that in the case d = 1 the sum P (B Q is given by the secant formula 
of 4.1.
Now consider the case d = gcd(#i — X2in) = n. Then Xi = X2 (mod n), and 
addition is done by the tangent formula. Next, we find di = gcd(pi + 2/2, ^)- If 
1 < di < n, then we have found a factor of n, and the algorithm terminates. If 
di = n, i.e., 2/1 = ~y2 (mod n), then we set R = P (B Q = O. If di = 1, then we 
have
Ai = (3^1 + a)(2/i + 2/2)—1 (mod n), v = yr - A^i (mod n), 
X3 = —2xi + A2 (mod n), 2/3 = ~A&3 — v (mod n) 
and we set R = P (B Q = (23 :2/3 •* 1)-
Thus we have defined addition for the points of Vn. Now we want to define 
multiplication of P e Vn by natural numbers k. As a result of this multiplication 
we either find a factor dofn, l<d<n, or obtain a point R e Vn satisfying 
the following condition: if p is a prime number, p | n, a = a (mod p), and if there 
is b e Z/pZ such that 6(4a3 + 2762) =4 0(mod p) and Pp e Ed&(Z/pZ), then 
Rp = kPp in the group E- tfLfpT). Here kPp is computed by the addition law for 
elliptic curves over a field, as described in 4.1.
Remark 4.4. The point R = kP e Vn is found similarly to R = P (B Q € 
Vn. This does not require Lenstra’s binary exponentiation algorithm. Thus we 
do not have to determine the binary representation k = ^2Ji by computing 
kP = 2JiP, preceded by finding the points 2JP. Instead, we consider a factor­
ization k = k\ • • • kt into a product of small natural numbers k^ k± > k2 > - • • > kt. 
It is exactly those numbers k that will be considered in the factorization algorithm. 
We represent the point kP as • • (ktP) • • •)) and find it by successive multi­
plications by ki,i = t,..., 1. Unlike the earlier stage, here we can use the binary 
method.

4.2. LENSTRA’S ALGORITHM FOR FACTORIZATION OF INTEGERS
77
A factorization algorithm with one elliptic curve.
The input of the algorithm consists of a number n to be factored, and param­
eters v,w G N, depending on n. There are also given a,x,y G Z/nZ such that 
P = (x : y : 1) G Vn and 6(4a3 + 27&2) G (Z/nZ)* for b = y2 - x3 - ax (mod n).
The algorithm determines a natural factor d of n, 1 < d < n.
For each r G N, 2 < r < w, we set
e(r) = max{m | m G Z>o, rm < v + 2\/v + 1},
and then
JJ re^r\ 
2<r<w 
r prime
Let P = (x : y : 1) G Vn. Then P belongs to the elliptic curve Eaj over Z/nZ, 
defined by the equation Y2 = X3 + aX + b. We compute the point kP as was 
explained above. If, during the computation, a factor d of n, 1 < d < n, is found, 
then we have factored n and the algorithm terminates. If we have found kP and 
no factor d has been found, then the algorithm terminates and outputs a message 
that factorization failed.
End of algorithm.
Remark 4.5. How does one choose the parameters v, w, a, #, y? The elements 
a, £, y G Z/nZ are chosen at random. Then, for b = y2 — x3 — ax (mod n), we have 
the elliptic curve Ea^ over Z/nZ and a point on it. The parameter w is theoretically 
equal to w = L{p)^+ \ where L(t) = exp vlog t log log £, and p is a minimal 
prime factor of n. Since p is unknown but p < n1/2, we have L(p) < ^(n1/2) = 
exp((v2 °(1)) 0°g n log log > which yields an upper bound
w<L(n)i+°W.
In practice one should try several increasing values of w. The parameter v, which 
estimates the powers of the small primes r entering fc, should also, in practice, be 
chosen empirically, using some increasing sequence of values.
Remark 4.6. In practice, the factorization algorithm, for given n,v, and w, 
runs as follows. Randomly choose the next values a,x,y G Z/nZ and run the 
factorization algorithm with one curve. Repeat until we factor n or the algorithm 
runs out of time.
Remark 4.7. The above-mentioned improvement, due to Montgomery [175], is 
based on simultaneous computation of the inverses for several elements ui (mod n), 
..., ai (mod n) in the ring Z/nZ (see 10.4; [57, Ch. 10]). This allows for working si­
multaneously with several curves. Yet another improvement of Lenstra’s algorithm 
is based on using only projective coordinates. In that case, we do not need division 
modulo n at all. However, Cohen [57, Ch. 10] recommends affine coordinates in 
combination with Montgomery’s modification.
Remark 4.8. Lenstra’s algorithm is similar to Pollard’s (P — l)-method, de­
scribed in Chapter 2. As in the (P — l)-method, a second stage is possible; 
see [57, 175, 39].

78
4. CURVES, PRIMALITY TESTING, AND FACTORIZATION
4.3. Computing the order of the group of points of an elliptic curve 
over a finite field
Computing the order of the group of points of an elliptic curve over a finite 
prime field is important for cryptography and also for primality testing algorithms, 
which will be discussed in the next section.
Let p be a prime number, p > 3, and E = Eaj> the elliptic curve over Z/pZ 
with equation y2 = x3 + ax + b. In 1985, R. Schoof [232] came up with an algo­
rithm of polynomial complexity of O(log8p) bit operations for finding |E(Z/pZ)| 
(see also [233]). Schoof’s algorithm was subsequently improved by Atkin, Elkies, 
Muller, and other authors; see [29, 82, 185, 151, 233]. This allowed one to com­
pute the orders of the groups of points for prime fields whose number of elements 
has several hundred digits; a record value for p is 10499 + 153.
In this section we describe the original version of Schoof’s algorithm from [232]. 
Let Z/pZ be an algebraic closure of Z/pZ. The Frobenius map <p: E(Z/pZ) —> 
E(Z/pZ) is defined by
= 
<p(O) = O.
It is not difficult to see that <p is a homomorphism and an embedding of E(Z/pZ) 
into itself. It is also clear that the points of E(Z/pZ) are fixed under the action 
of <p. Let
|E(Z/pZ)|=p + l-L
By Hasse’s theorem, |t| < 2y/p. The integer t is called the trace of the Frobenius 
map; the map <p is a solution of the equation
<p2 — tip + p = 0.
For each natural number n, let E[n] be the subgroup of E(Z/pZ) consisting of the 
points whose order divides n:
E[n] = {Pe E^Z) | nP = O}.
Theorem 4.9 (see [244]). If n > 1 and p does not divide n, then E[n] is 
isomorphic to 'L/p% x Z/pZ.
___ Example 4.10. Let x±, x2, x$ be three distinct solutions of x3 + ax + b = 0 in 
Z/pZ. Then
E[2] = {(zi,0) : i = 1,2,3} U {O}.
Define polynomials y) 6 Z/pZ[rr, p],n = —1,0,1,2,..., by the following 
relations:
-0-i(z,2/) = -1, -00^)2/) = 0, ^i^y) = 1, 'ip2(x,y) = 2y,
-03 (^, y) = 3a?4 + 6arr2 + 12frr — a2,
^(^j y) = 4y(x6 + 5arr4 + 20frr3 — 5a2 x2 — 4abx — Sb2 — a3);
for n > 3 by
■</>2n(x, y) = V’n(®,3/)(V’n+2(®, 
3/)2 - ^n-2(ar, 
3/)2)/(2?/);
and for n > 2 by
i/>2n+i(x,y) = ■>pn+2(x,y)'ipn(x,y)3 -'ipn+1(x,y)3'ipn_1(x,y'), 
where y2 should always be replaced by x3 + ax + b.

4.3. THE ORDER OF THE GROUP OF POINTS OF AN ELLIPTIC CURVE
79
The polynomials y) are called the division polynomials. Using induction, 
it is not difficult to show that the /n(rr), defined by
^n(x,y)
^nfayj/y
fn(%) —
if n is odd, 
if n is even,
are polynomials in rr, i.e., fn(x) 6 Z/pZ[rr]. Moreover, if n is odd, p { n, then 
deg/n(a:) = (n2 - l)/2.
Theorem 4.11. Let P = (x, y) e E(Z/pZ) \ E[2] and n > 3. Then nP = O if 
and only if fn(x) = 0.
Theorem 4.12. Let P = (x,y) € £?(Z/pZ) \ E[2], n>2, and nP / O. Then 
p_( ^n-l(x,yytn+l(x,y) lfrn+2 fo, 3/)^-! (s» IjY ~^n-2 <X, p)V>ra+l (xC, g/) 2 X 
n V 1pn&yY ’ 
M-nM3 
A
In Schoof’s algorithm, we want to determine t (mod Z) for small primes I. If 
there are sufficiently many such Z, or more precisely, if IIZ > 4^/p, then, having found 
t (mod IIZ) by the Chinese Remainder Theorem, we will have that the value of t 
equals the least (in absolute value) residue in the class of t (mod IIZ). This follows 
from Hasse’s theorem(see 4.1). Then we can determine |E(Z/pZ)| = p + 1 — t.
First, consider the case 1 = 2. By the above example, there is a nonzero point 
P = (#, 0) of order two in E(Z/pZ) if and only if
gcd(rrp — rr, x3 + ax + &) =4 1.
This is equivalent to saying that |E(Z/pZ)| is even, which, because p +1 is even, is 
equivalent to saying that t is even. Thus t = 0 (mod 2) if and only if
gcd(rrp — £, x3 + ax + &) =4 1;
otherwise t = 1 (mod 2).
Henceforth, Z is a fixed (small) prime number, I =4 p. In practice, one should 
consider primes Z of magnitude O(logp).
Consider the group E[l]\ clearly, (^(^[Z]) C E[l]. It is easy to show that ip is an 
isomorphism of E[l]. Let <pi = <p\. Then is a solution of
T2i -i<P(+p = 0.
We now show that if ipi is a solution of
Wl-t'vl+p = s
for some t1 e Z, then t = tf (mod Z). Indeed, subtracting the second equation from 
the first, we have
(t — 
=0 on E[Z],
and therefore t = tf (mod Z), because <pi is an isomorphism.
Now we need to find t, 0 < r < I — 1, such that
Pi ~ T(Pi + p = 0 on E[l].
This would determine t (mod Z). In other words, we need to find r G Z/ZZ such 
that (Pi +p = ripi on E[l]. The case r = 0 is considered separately. If r =4 0, then, 
for
k = p (mod Z), 1 < k < I — 1,

80
4. CURVES, PRIMALITY TESTING, AND FACTORIZATION
we can, by Theorem 4.12 applied to P = (#,?/) G E[l] \ O, rewrite <^2(P) + pP = 
r<pi(P) as
(xp2 yP2} ffi (x - ^k-i(x,y)^k+1(x,y)
tpk+2(x,y')'<l)k-i(x,y')2
4ytMx,y)3 
'
= ( P _ (^r-i(x,yWr+i(x,y)\P
/V>T+2(3:,2/)V>T-i(a:, j/)2 ~ V,r-2(3:,y)V'r+i(3:,j/)2y\ 
\ 
4?/'0t(£)3/)3 
/ /
The symbol (B denotes addition of points on the curve. The latter equality can be 
written as
Hi(x) = 0 (mod/{(#)),
H2(x) = 0 (mod /z(rr)),
where Hi(x\H2(x) G Z/pZ[rr]. Examining now r = 0,1,..., I — 1, we we find the 
actual value of t = r (mod Z). This is the main idea of the algorithm. We shall now 
give more details.
Schoof’s algorithm.
The algorithm determines t (mod Z) for primes Z such that f] Z > 4^/p. Then, 
using the Chinese Remainder Theorem, it finds t. The value t (mod 2) is determined 
as described before. Assume now that Z > 2, Z is a fixed prime number, and Z =4 p.
Stage 1 for the fixed Z. We check if there is a point P = (x,y) G E[l] \ O 
such that
^2(P) = ±kp,
where k =p (mod Z), 1 < k < I — 1. We first check the first coordinate; this means 
the following equality should hold:
„ 
^k-i(x,y)ipk+1(x,y)
^k(x,y')2
When k is even, it becomes
p2 _ _ 
/fc-i(^)/fc+i(rg)
fk(x)2{x3 + ax + by
and when k is odd, it becomes
_ 
fk_1(x)fk+1(x)(x3 + ax+ b)
x x 
fk(x)2
Therefore, by Theorem 4.11, there is a point P = (x,y) G E[l] \ O such that 
(Pl (P) = ±kP if and only if
gcd((o;p2 - x)fk(x)2(x3 + ax + b) + fk_i(x)fk+1(x), fi(x)) / 1
for k even and
gcd((a:p2 - xjfkix)2 + fk_i(x)fk+i(x)(x3 + ax + b), /t (or)) / 1
for k odd. If the corresponding gcd (for k even or odd) equals 1, then r is not 
congruent to 0 modulo Z. Indeed, if r = 0 (mod Z), then
+ k) (P) = 0 for all P G E[l],

4.3. THE ORDER OF THE GROUP OF POINTS OF AN ELLIPTIC CURVE
81
but in our case (when gcd = 1) there are no such points, except O. If the equation 
<p2(P) = ±fcP is not solvable on E[l] \ O, we go to Stage 2 of the algorithm.
Suppose there is a point P e E[l] \ O such that <p2(P) = ±kP = ±pP.
Case 1. If <p2(P) = —pPy then (<p2 +p)P = O. Since (<p2 — tp+p)(JP) = O for 
each point P on the curve, we have (^<pz)(P) = O. As pi is an isomorphism of E[Z], 
we have t = 0 (mod Z). Thus we have found the desired t (mod Z).
Case 2. If <p2(P) = pP, then, using the equation <p2 — tp + p = 0 again, we 
have (2p — tpi)(P) = O. Since 2pP =4 O for P e E[l] \ O, we have t 0 (mod Z) 
and therefore pi(P) = 
• P (here | denotes t-1 (mod Z)). Applying pi again, we
have
pp = ^(P) = ^(P) = 
. p.
Hence
p = 4p2/t2 (mod Z), 
or t2 = 4p (mod Z). In particular, in this case p is a quadratic residue modulo Z.
Next, we solve the equation w2 = p(mod Z) (an algorithm for solving such 
equations is described in Chapter 6; for small Z one can simply use trial and error). 
If w is a solution, then t = ±2w (mod Z), and we only need to determine the correct 
sign.
Using the substitution t = ±2w (mod Z) in the equation for <pz, we have 
<p2 =F 2w<pz + w2 = 0,
i.e., (<pz=Fw)2 = 0 on E[l]. Therefore the linear map pi may have only one eigenvalue, 
±w (mod Z), on E[l] (if r is an eigenvalue, then (r =Fw)2 = 0 (mod Z)). The existence 
of a solution Q G E[l] of (<p=F w)Q = O is verified the same way as for the equation 
<p2(P) = ±AP above. More precisely, let Q = Then, comparing the first 
coordinates in the equality pi(Q) = ±wQ, we must have
X — X-------------------- ;------ —---------- .
'<Pw(x,y)2
Therefore, when w is even, 
p _ 
_ 
/w-l(a:)/w+l(rg)
/wW2(^3 + ax + by 
and if w is odd, 
p fw— i (#)/w+i 
+ ax + &)
x =x------------------ , ( 
.
The existence of Q G E[l] is equivalent to the condition
gcd((a:p - x)fw(x)2(x3 + ax + b) + /w-i(a:)/w+i(a;), //(a:)) / 1 
for w even, and, for w odd, to the condition
gcd((a:p - x)fw(x)2 + fw-i(x)fw+i(x)(x3 + ax + &),/;(a:)) / 1.
If Q does exist (i.e., the corresponding gcd is different from 1), then we need to 
choose the sign of ±w using the second coordinate. If
(sp,pp) = pi(w) = wQ
= ( 
V^-i(a:,3/)V>w+i(3:,3/) VW2(a,^)V^-i(^)2 ~
\ 
i/>w(x,y)2 
’ 
)’

82
4. CURVES, PRIMALITY TESTING, AND FACTORIZATION
then
p = /w+2(a>) • yfw-1 - fw-2(x) ■ yfw+1(x)2
V 
4J/Vw(®)3
if w is even, and
p = /w+2(a:) • y2/3_i - /w-2(x) • j/2/w+i(a;)2 
y 
4y/w(a;)3
if w is odd. As y2 = x3 + ax + &, we have, when w is even, that ^(Q) = wQ if 
gcd(4/w(a:)3(2:3 + ax + bf^~ - _/w+2(z)/w-i(z)2 + fw-2(x)fw+i(x)2, filxty / 1.
Similarly, when w is odd,
gcd(4/w(a:)3(2:3 + ax + bf^ - fw+2(x)fw-i(x)2 + fw-2(x)fw+1(x)2, 
/ 1.
In the case = ~wQ, the second coordinate changes the sign. Then, if w 
is even,
gcd^4/w(a:)3(a;3 + ax + bf^ + fw+2(x)fw-i(x)2 - /^(aO/w+i^)2, fi(xty / 1, 
and, if w is odd,
gcd^4/w(a:)3(a;3 + ax + bfr~ + fw+2(x)fw-i(x)2 - /w-2(a:)/w+i(a:)2, fi(xty / 1.
Assume now that there is no Q e E[l] \ O such that <^(Q) = ±wQ. Moreover, 
we are under the assumptions of Case 2, i.e., there is P e E[l] \ O such that 
</?2(P) = kP. We shall now show that our assumption is impossible. We have 
</?2(P) = (±w)2P. Also, as was shown above, (^=Fw)2P = O. These two conditions 
imply that
w2P =F 2w^(P) + w2P = O,
i.e., 2w2P = ±2w^(P). Since 2w =4 0 (mod Z), we now have <pi(P) = ±wP. On the 
other hand, we have assumed that, for all Q e E[l] \ O (including P), the equality 
<pi(Q) = ±wQ is impossible. This shows that our assumption was false.
Hence, if there is P e E[l] \O such that ip2(P) = kP, then there is Q e E[l] \O 
such that <pi(Q) = ±wQ.
Thus, Stage 1 of the algorithm is implemented as follows. If there is no P € 
E[l] \ O such that <^2(P) = ±fcP, then we go to Stage 2 of the algorithm. If P does 
exist (i.e., the corresponding gcd from the beginning of Stage 1 is different from 1), 
then, if (|) = — 1, we set t = 0 (mod Z) (since Case 2 is impossible). If (^) = +1, 
then we find w e Z such that w2 = p (mod Z) and 0 < w < I. Then we check if +w 
or — w is an eigenvalue of <pi on E[l] (this is done the same way as before). If ±w 
is not an eigenvalue of <pi on E[Z], then t = 0 (mod Z) is the desired value, as was 
explained above.
If ¥>i(Q) = WQ f°r some Q e E[l] \ O, then <^2(Q) = pQ. Then, using the 
relation <^(Q) = ^Q found earlier, we have
2z?
w —— = 0 (mod Z).
Since p = w2 0 (mod Z), it follows that t = 2w (mod Z) is the desired value of t 
modulo Z.

4.3. THE ORDER OF THE GROUP OF POINTS OF AN ELLIPTIC CURVE
83
If <pi(Q) = —wQ for some Q G E[l] \ O, then, similarly,
w + 
= 0 (mod Z),
b
and therefore t = —2w (mod Z).
Thus, if during Stage 1, there is P G E[l] \ O such that ip2 (P) = ±fcP, then we
can find t (mod Z), and for the given Z, Stage 2 will not be needed.
Stage 2 for the fixed Z. Suppose that during Stage 1 no P G E[l] \ O was 
found such that
^(P) = ±fcp = ±pp.
Then the desired value of r = t (mod Z) for which
Q
<Pi +P = r(pi,
would not be equal to zero on E[Z], as was shown above.
Examining each t, 1 < r < we are now seeking a value such that 
(<Pl + P)(P) = ±T<P«(P)
holds identically on E[l\. For P = (#, y) G E[l] \ O, the left-hand side will be, when 
k = p (mod Z), 1 < fc < Z, of the form
(xp2 yp2) © (x - ^-dx,y)^k+1(x,y) 
k ' V il’k&y)2
V>fc+2(a;,j/)V>fc-i(2:,2/)2 - V>fc-2(a;,;/)V>A;+i(a;,p)2\ 
4yMx,y)3 P
where addition ® on the curve is given by the secant formula, since ip2 (P) =4 ±pP 
for all P G E[l] \ O. The right-hand side, i.e., ±t^(P) = ±<^(tP), is of the form
( p _ /<0t-1(^Z/M+1(^>Z/)V
\ V ^T(x,y)2 
)
, /^t+2^) z/M-i fo, y)2 - ^-2^,z/M+iz/)2 V\
\ 
^y^T(x,z/)3 
/ /’
Since (<p2 +p)(P) = ±t<^(P) holds identically on E[Z], we do not need to compute 
the greatest common divisor with /z(rr), but we must check the divisibility by fi(x). 
To write the corresponding formulas, we need to consider four cases, depending on 
the parity of k and r.
For example, let k be even and r odd. Then
/ p2 p2x _ fk-l(x)fk+1(x) fk+2(x)fk-l(x)2 - fk-z(x)fk+l(x)2\
’ 
' 
\ 
fk(x)2{x3+ ax + by 4(a:3 + ax + b)fk(x)3 -y /
= /p ( fr-lW/r+lfr) y . //r+2(^)/T-lW2-/T-2(3:)/r+l(3:)2\P\ 
\ \/r(rr)2(ir3 + arc + &)/’ \ 
4(rr3 + ax + b)fT(x)3 • y ) /
Using the relation y2 = x3 + ax + &, it is not difficult to show that the left-hand 
side of this equality is of the form
(Hi(x) H3(x) 
±1x
\H2(x)’ H4(x) y )’
and the right-hand side is of the form
(H5(x) 
H7(x) 
±1\
\H6(xY H8(x) V P

84
4. CURVES, PRIMALITY TESTING, AND FACTORIZATION
where Hi(£),...,Hg^x) e Z/pZ[rr]. Now, to verify the first coordinate of the 
identity
+P)(P) = ±T<Pl(P)
we need to check that Hi(x)Hq(x) — 
is divisible by fi(x) in Z/pZ[#]. If
this is not the case, then we examine the next r. If this is the case, then we choose 
the sign of r by running a similar check on the second coordinates. More precisely, 
we rewrite the difference
g3(s) 
H^x) ■y±l^ H7(x)
H8(x) ■y±1
as 
where Hg (rr), Hiq (#) e Z/pZ[rr], and then check the divisibility of
Hg(x) by fi(x). The three remaining parity combinations for k and r are considered 
similarly. This concludes Stage 2 for for the fixed I.
Stage 3. Suppose we have found t (mod I) for primes I such that [p > 4^/p. 
By the Chinese Remainder Theorem, we can find t (mod Z); the least (in absolute 
value) residue in this class is the desired t. We then set |F(Z/pZ)| = p + 1 — t.
End of Schoof’s algorithm.
Remark 4.13. For a fixed I > 2, computations with polynomials and rational 
functions should be done modulo fi(x). For example, we do not need to use xp] this 
is a polynomial of high degree, since p is large. Instead we compute xp (mod /z(rr)), 
which is a polynomial of degree at most deg fi(x) — 1 = 
— 1.
Remark 4.14. The most computationally intensive part of Schoof’s algorithm 
is the determination of the high powers rrp, yp, xp , yp modulo fi(x).
Remark 4.15. In [105], one finds an efficient combination of Schoof’s algorithm 
with its various improvements for optimal computation of the order of the group 
of points of an elliptic curve over a finite prime field.
Satoh [424] suggested a new method for computing the order of the group 
of points of an elliptic curve over a finite field. That method was subsequently 
developed by Fouquet, Gaudry, Harley, and other authors; see [347, 348, 439, 
443, 385, 426, 425, 356, 399, 389]. It turned out to be efficient over fields of 
small characteristic. The results for the group of points of an elliptic curve over 
GF(28009) can be found in [347]. This significantly exceeds the previous record 
of Joux and Lercier (see [375]), who computed the order for an elliptic curve over 
GF(21663) using a modification of the Schoof-Elkies-Atkin algorithms.
For constructing elliptic curves over finite fields with a prescribed number of 
points, see [293].
4.4. Primality testing using elliptic curves
In 1986, Goldwasser and Kilian [97] came up with a probabilistic algorithm for 
primality testing which uses elliptic curves.
Theorem 4.16 (see [97]). There is a probabilistic algorithm for primality test­
ing using elliptic curves. For any natural number k, the proportion of k-digit primes 
for which the average running time of the algorithm is polynomial is at least
l-0(2-feC/loglog'e).

4.4. PRIMALITY TESTING USING ELLIPTIC CURVES
85
Remark 4.17. Assuming an unproven conjecture about the distribution of 
primes, the average running time of the Goldwasser-Kilian algorithm will be poly­
nomial for all primes.
Remark 4.18. The algorithm randomly chooses an elliptic curve and tests 
certain conditions. It either correctly determines whether the given number is 
prime or composite, or makes another random choice. The algorithm runs until 
either the primality testing has been accomplished or a specified time is over.
Remark 4.19. Alternating the Goldwasser-Kilian test with the Solovay-Stras- 
sen (or Miller-Rabin) test of Chapter 1, we obtain a probabilistic method for prov­
ing that a given natural number is prime or composite. Its average running time 
will be polynomial for all fc-digit numbers, except perhaps for the aforementioned 
proportion of the fc-digit primes.
Remark 4.20. If the Goldwasser-Kilian algorithm established that the number 
is prime, then it also yields a “primality certificate”. Using that certificate, a second 
primality test for the fc-digit number can be deterministically performed in O(fc3+e) 
bit operations.
Remark 4.21. In [4], one finds an improved estimate of the number of primes 
for which the average running time of the Goldwasser-Kilian algorithm is polyno­
mial. It was shown there that the number of primes not exceeding x for which the 
average running time is not polynomial is at most O(rr15/16).
We describe the Goldwasser-Kilian algorithm for primality testing of an odd 
natural number n not divisible by 3. We consider the elliptic curve En over the 
ring Z/nZ defined by the equation
y2 = x3 + ax + b (mod n), (4a3 + 27b2 n) = 1.
For the set
En(Z/nZ) = {(#, y) | rr, y G Z/nZ, y2 = x3 + ax + b} U {(9}
we use the same addition law that was described in 4.1 for a prime n. Also, for 
q G N and P e Enty/nX), we compute qP by the following recurrence relation:
{2^|P^ if q is even, 
P © (g — 1)P if q is odd.
We also use reduction: if p is a prime number, p | n, and P = (x,y) G En(Z/nZ), 
then
(P)p = (x (mod p), y (mod p)) G Pp(Z/pZ).
Here Ep(Z/pZ) = {(#,?/) | x,y G Z/pZ,y2 = x3 + ax + &(mod p)} U O is an 
honest elliptic curve over Z/pZ, because 4a3 + 27b2 =4 0 (mod p). Clearly, if P, Q G 
En(Z/nZ) and the point P (B Q is defined, then (P (B Q)p = Pp (B Qp.
Description of the Goldwasser-Kilian algorithm.
Step 1. Set po = n and i = 0. Choose k G N such that 2fc-1 < p0 < 2k.
Step 2. Randomly choose A, B G ^/pi^ and verify that D = (4A3+27B2,pi) = 
1. If i = 0 and the given greatest common divisor is in the interval (l;po)> then 
po = n is composite, and the algorithm terminates. If i > 0 and 1 < D < p^ then 
return to Step 1. If i > 0 and D = p^ then return to Step 2 (i.e., choose other 
A,B).

86
4. CURVES, PRIMALITY TESTING, AND FACTORIZATION
Step 3. Assuming that pi is a prime number, for the reduced curve y2 = 
x3+ax+b (mod p^), we seek the quantity |EPi(Z/piZ)| (for example, using Schoof’s 
algorithm of 4.3). If the found value of \Ep. (Z/p;Z)| is odd, then return to Step 2. 
Else, set
q = \EPi^/PiW
and verify the assertion of Hasse’s theorem
|2g-pi-l| < 2^/pl.
If this inequality does not hold for i > 0, then return to Step 1. If it does not hold 
for i = 0, then n = po is composite.
Step 4. Run I rimes the Solovay-Strassen (or Miller-Rabin) test, described in 
Chapter 1, for primality testing of q. If it turns out that q is composite, then return 
to Step 2. The value of I should be chosen in such a way that (|)Z < 1/p3.
Step 5. Choose a random point P = (x,y),P G EPi(fi/ptZ). In other 
words, we randomly choose x G %/pi%, and when (^-+^+6) _ we y = 
(x3 + ax+ by/2 (mod p) and set P = (#, p); otherwise we make another choice of x.
Step 6. Having found P = (#, y) G EPi (Z/ptZ), we verify whether the equality 
2qP = O holds on EPi fa/piZ). If it does not and i > 0, then we return to Step 1. 
If it does not and i = 0, then n is composite. If it does hold, then we set p;+i = q.
Step 7. Verify the inequality
log log k 
q<2*
Here the constant c is taken from the complexity estimate
O((logn)clogloglogn)
for the Adleman-Pomerance-Rumely or Lenstra’s algorithms, which were discussed 
in Chapter 1. If the inequality does not hold, then set i := i + 1 and return to Step 2. 
If it does hold, then deterministically check the primality of q using the Adleman- 
Pomerance-Rumely or Lenstra’s algorithms. If q turns out to be composite, then 
we return to Step 1. Else, the algorithm terminates and outputs the message that n 
is prime.
End of algorithm.
The correctness of the algorithm is based on the following statement.
Proposition 4.22. Let n G N, n > 1, (n, &) = 1, En an elliptic curve over 
Z/nZ, P = (x,y) G En(Z/nZ),P =4 O. Let q be a prime number, q > n1/2 + 
2ft1/4 + 1, and qP = O. Then n is prime.
PROOF. Suppose that n is composite, and let p be a prime factor of n, p < y/n. 
Reducing modulo p, we have a point Mp = (P)p such that
Mp =4 Op, qMp = Op.
By Lagrange’s theorem,
\Ep(Z/pZ-)\ >q> n1/2 + 2nJ/4 + 1 > p + 2y/p + 1.
Therefore
|Ep(Z/pZ)|-(p+l)>2Vp,
contrary to Hasse’s theorem. 
□

4.5. SUMMARY
87
If the Goldwasser-Kilian algorithm is successful, then it constructs a chain 
n = po > pi > - - - > pi,
and the primality of pi would imply the primality of n, as we have just proved. 
Indeed, the next q satisfies the inequality
\2q-pi-l\<2p1i/2, 
which is verified in Step 3. Then the inequality q > p\^2 + 2pV4 + 1 would also 
hold, because, for pi > 5, the inequality
K 2+1 > p,1/!++1
holds. As we have just proved above, the primality of q implies that of pi. Therefore, 
for the above chain, the primality of the last number implies that of the first number, 
i.e., of n.
Remark 4.23. The constructed chain
n = Po > Pi > • • • > Pi
is the primality certificate of n mentioned in Remark 4.20.
The Goldwasser-Kilian algorithm turned out to be impractical because of the 
multiple use of Schoof’s algorithm for computing the orders of the groups of points 
of elliptic curves. Atkin and Morain [18] suggested the use of elliptic curves with 
complex multiplication. For such curves the order of the group of points is found 
by a simple formula. Somewhat more complicated is the construction of the curves 
with complex multiplication. The Atkin-Morain algorithm was implemented on 
a computer and, at the present time, is successfully used for primality testing, 
as are the algorithms of Adleman-Pomerance-Rumely-Lenstra-Cohen, discussed in 
Chapter 1. A comparison of these two methods was done in 1.8; see also [57, Ch. 9]. 
For more on the Atkin-Morain algorithm; see [182].
4.5. Summary
In conclusion, we make additional comments on the algorithms using elliptic 
curves.
As we have seen before, sometimes we need to compute a multiple kP of a 
point P on an elliptic curve (here k e Z). This is also done in many cryptosystems. 
Efficient algorithms for solving this problem can be found in [183, 249] and also 
in [320, 325, 324, 341, 342, 323, 354, 387, 406, 336, 384].
A computation of the order of the group of points of an elliptic curve over 
GP(2l) is described in [165].
Construction of curves with complex multiplication is discussed in [172, 133].
As noted in [105], if a cryptosystem uses elliptic curves with some special prop­
erties (for example, anomalous or supersingular curves), then such a cryptosystem 
is more vulnerable to effective attacks (see [223]).
In [212], it was proved that, using elliptic curves, one can obtain a primality 
certificate for each prime p, which can be verified in O(logp) arithmetic operations. 
However, there is no estimate on the number of such certificates for a fixed p.

88
4. CURVES, PRIMALITY TESTING, AND FACTORIZATION
In [434], the so-called summation polynomials • • • >^n) were introduced. 
Their roots X\,..., xn characterize points (#i, 3/1),..., (rrn, Vn) of the elliptic curve 
such that
(#1 > Vi) © ’ ’ ’ © (#n> Vn) =
Using those summation polynomials, a new method for computing discrete loga­
rithm in the groups of points of elliptic curves over extension fields of small degree 
was developed in [355]. It has a better complexity than the baby-step-giant-step 
method and Pollard’s p-method. It also uses factor bases and the index-calculus 
method on elliptic curves.
The papers [397] and [398] develop a probabilistic algorithm for finding small 
prime factors of integers. It uses Jacobian varieties of curves of genus 2 over finite 
fields, similar to the way elliptic curves are used in H. Lenstra’s algorithm for 
factorization of integers. We have the following
Theorem 4.24. There is a probabilistic algorithm which, for given n>n$ and 
v > 3 requires at most Lv[2/3,co](logn)3 bit operations (nQ,CQ are some absolute 
constants) and finds, with probability at least 1/2, all prime factors p ofn such that 
p <v.
The authors remark that their method is only of theoretical interest. They 
also mention new results about the distribution of smooth numbers in short inter­
vals. Those results are used to estimate the complexity of the algorithm. But the 
algorithm itself is not described in the above papers.
In recent years, much effort has been made to find applications of bilinear maps 
of the points of elliptic curves over finite fields to cryptography. As examples of 
such maps, we mention the Weil pairing and the Tate pairing, as well as their 
modifications. The first results in this direction were obtained by Joux [374]. Over 
a hundred papers in this field have been published since that. For a long time, an 
extensive bibliography list had been maintained at
http://planeta.terra.com.br/informatica/paulobarreto/pblounge.html.
The use of the above maps allows one to construct cryptosystems with new and 
interesting properties, and to implement identity-based cryptosystems, sertificate- 
less public key cryptography, etc.
Theoretical descriptions of the Weil and Tate pairings can be found in [244, 
349, 368, 350]. Methods for efficient computation of those pairings are described 
in [301, 350, 351, 342, 312, 343, 373]. See also [379, 380, 415, 441, 432].
The bibliography of papers describing pairing-based cryptoschemes and their 
analysis is huge. We should mention here the dissertation [350], the survey [340], 
and the papers [315, 316, 367, 417, 440, 402, 392, 445]. See also [405, 321, 
437, 339] and many others.
A number of papers deal with constructions of elliptic curves suitable for ef­
ficient implementation of pairing-based cryptoschemes; see [408, 302, 338, 433, 
317, 416, 337].
See also the survey [388]; it discusses choices for the parameters of elliptic 
curves guaranteeing the security of pairing-based schemes. It also discusses the effi­
ciency of the computation of Weil and Tate pairings for various embedding degrees. 
In [359], one finds a survey of cryptographic primitives based on bilinear maps.
We should also mention two excellent new books, [365] and [313], on elliptic 
curve cryptography.

4.5. SUMMARY
89
In [352], one finds a survey of algorithms for computing discrete logarithms 
on elliptic and hyperelliptic curves, as well as descriptions of some computational 
problems related to pairing-based cryptography. It also contains an excellent bib­
liography on those problems.
For more on elliptic curve cryptography, see also [298] and [322].


CHAPTER 5
Algorithms for Computing Discrete Logarithm
5.1. Introduction. Deterministic methods
Let G be a multiplicative abelian group and a,b e G. The problem of solving 
the equation
ax = b
is called the discrete logarithm problem in G. Its solution x is called a discrete 
logarithm of b to the base a and is denoted loga b if the base a is fixed and if a 
solution exists; loga b G Z/|G|Z if |G| < oo.
The discrete logarithm problem has important application in cryptography. 
Especially important is the case G = GF(qY, where q = p is a prime number, 
and I e. N, and the case when G is the group of points of an elliptic curve over a 
finite field.
Consider the equation
(5.1) 
ax = 6(modp)
on (Z/pZ)*, where p is a prime number. We assume that the order of a (mod p) 
equals p — 1. Then the equation is solvable and the solution x is an element of 
Z/(p — 1)Z. In this section we describe deterministic methods for solving (5.1).
The trial and error method solves equation (5.1) in O(p) arithmetic operations.
The solution loga & of (5.1) is also given by the formula
p-2
loga b = 52(1 - (mod p - 1);
j=l
see [197]. But the complexity of this approach is worse than that of trial and error.
The next algorithm for solving (5.1) has complexity of O(px/2 logp) arithmetic 
operations (see [192, Ch. 6]).
The compatibility algorithm.
Step 1. Set H := [p1/2] + 1.
Step 2. Find c = aH (mod p).
Step 3. Make a table of the values of cu (mod p), 1 < u < U, and sort it.
Step 4. Make a table of the values of b • av (mod p), 0 < v < U, and sort it.
Step 5. Find equal elements in the tables. For such elements, 
cu = b • av (mod p), 
and therefore aHu~v = &(modp).
Step 6. Output x = Hu — v (mod p — 1).
End of algorithm.
We now prove that the algorithm is correct. Any integer x, 0 < x < p — 2, can 
be written in the form x = Hu — v (mod p — 1), where 1 < u < H and 0 < v < H.
91

92
5. ALGORITHMS FOR COMPUTING DISCRETE LOGARITHM
Indeed, the numbers H, H-1, H-2,... ,H-H, 2H, 2H-1,... ,2H-H, 
H2 — 1,..., H2 — H contain the numbers 0,1,... ,p — 2, because H2 > p. This 
implies the correctness of the algorithm. The complexity estimate is also obvious 
because a set of N elements can be sorted in O(TVlogTV) arithmetic operations; 
see [8, Ch. 3].
Remark 5.1. For some improvements of the compatibility algorithm, see [192, 
Ch. 6]. They are all of exponential complexity.
Suppose now that the prime factorization of p — 1 is known:
i=l
Then the solution of (5.1) can be found in o(^2i=i ai(l°gP+ Qi)) arithmetic oper­
ations with the aid of the following algorithm; see [203]. (For an improved version 
of this algorithm, a similar estimate holds with qi replaced by q^2.)
The Pohlig-Hellman algorithm.
Step 1. For each prime g, q | p — 1, make a table of the numbers
rqj = a^p~r^q (mod p), j = 0,..., q — 1.
Step 2. For each prime g, qa || p — 1, find loga b (mod qa). Let
x = loga b (mod qa) = xQ + xiq H------ F Xa-^q0"-1 (mod ga),
where 0 < Xi < q — 1. Then (5.1) implies that
&(p-l)/g = fla:o(p-l)/<7 (mod
Using the table from Step 1, find xq. Then
(ba-^-1^2 = ax^p~^q (mod p).
Using the table, find #i, etc. The value of Xi is found from the congruence 
(ba~x°-xiq-------^-i^-^p-i)/^1 = axi{p-i)/q (mod
Step 3. Having found loga&(mod g“*)> * = 1,...,$, determine loga& 
(mod p — 1) using the Chinese Remainder Theorem.
End of algorithm.
Now we justify the complexity estimate of the algorithm. The set of elements 
a(p-i)/9i (modp) is found in O(logp) arithmetic operations. The set of 
for all Qi, j is determined in Ofai) arithmetic operations. To find the next x^ 
in Step 3 we need to exponentiate (i.e., find aXi~iq' ), find the inverse, multiply, 
exponentiate, and examine the table. The inverse is computed by the generalized 
Euclidean algorithm in O(logp) operations. Putting all this together yields the 
desired complexity estimate for the Pohlig-Hellman algorithm.
Remark 5.2. The polynomial complexity of the Pohlig-Hellman algorithm 
is O((logp)C1) in the case when all prime factors qi of p are at most (logp)C2, 
where ci, C2 are positive constants. This happens, for example, for primes p of the 
form p = 2“ +1 or p = 2Q13Q2 + 1. If p — 1 has a prime factor g, q>pc, where c > 0, 
then the Pohlig-Hellman algorithm will be of exponential complexity.

5.3. THE DISCRETE LOGARITHM PROBLEM IN PRIME FIELDS
93
5.2. Pollard’s p-method for the discrete logarithm problem
In 2.3, we described Pollard’s p-method for factorization of integers. In [208], a 
similar method was given for finding the discrete logarithm modulo a prime p. We 
want to solve the equation ax = b (mod p). To this end, consider three sequences
1, 2, . . . ,
defined as follows:
u0 = v0 = 0, z0 = 1;
Ui + 1 (mod p — 1) 
m+i = 2ui (mod p — 1)
Ui (mod p — 1)
Vi (mod p — 1)
Vi+i = 2vi (mod p — 1)
Vi + 1 (modp — 1)
if 0 < Zi < p/3;
if p/3 < Zi < |p; 
if Ip < Zi < p;
if 0 < Zi < p/3;
if p/3 < Zi < |p; 
if |p < Zi < p;
Zi+i = bUi+1aVi+1 (modp — 1).
Here c (mod p) is understood as the least nonnegative residue in the given class.
Now consider the sets (z^, Ui, v*, Z2i, U2i, ^2i), 2 = 1,2,3,..., and find the index i 
such that Zi = Z2i- This equality implies that
bU2i~Ui = aVi~V2i (modp).
If (uu — Ui'P — 1) = 1, then, for I e Z, l(u,2i — Ui) = 1 (mod p — 1), we have 
b = al^Vi~V2i^ (mod p),
and the desired x equals loga b = l(yi — V2i) (mod p — 1).
For further details and, in particular, methods for finding equal elements 2*, Z2i, 
see [208]. A heuristic complexity estimate for this method is ^(p1/2) operations.
In [275], using an improved version of Pollard’s p-method, a discrete logarithm 
was found modulo a prime with 22 digits.
Another improvement of the above method can be found in [255].
5.3. The discrete logarithm problem in prime fields
In this section we consider algorithms for solving the equation
(5.2) 
ax = b (modp),
where p is a prime number, with heuristic complexity estimate of Lp [|; c] for some 
values of the constant c. We shall assume that a (mod p) is of order p — 1. First 
such algorithm was developed by Adleman in [1]. We shall describe a modification 
of his method.
Adleman’s algorithm.
Stage 1. Construct a factor base that consists of all primes g, q < B = 
econst v'logplog logp
Stage 2. Using trial and error, find natural numbers ri such that
ari = JJ gQi’(modp).
q<B, 
q prime

94
5. ALGORITHMS FOR COMPUTING DISCRETE LOGARITHM
This implies that
(5.3) 
Ti = ^2 Oig loga g (mod p - 1).
q<B, 
q prime
Stage 3. Having found sufficiently many relations (5.3), solve the obtained 
system of linear equations for the unknowns loga g, the discrete logarithms of the 
elements of the factor base.
Stage 4. Using trial and error, find one value of r such that
ar • b = JJ q@g • pi • • -pk (mod p), 
q<B
where pi,... ,p& are primes of “average” magnitude, i.e., B < pi < Bi, where Bi 
is a subexponential boundary and Bi = econst%/iogpiogiogp.
Stage 5. Using computations analogous to those in Stages 2 and 3, find the 
discrete logarithms logap; for the fixed primes pi,... ,pfc of average magnitude from 
Stage 4.
Stage 6. Find the desired loga b:
k
loga b = -r + ^2 Pq loga 9 + 52 log»pi (mod P ~ 
q<B 
i=l
End of algorithm.
Remark 5.3. The idea to use a factor base for finding discrete logarithms had 
been used before, for example, in [279]. Adleman’s algorithm is also described in 
[63, 159, 197]. We should remark, that in practice Adleman’s algorithm is not 
efficient enough.
In 1986, Coppersmith, Odlyzko, and Schroeppel [65] came up with an algo­
rithm for computation of discrete logarithms with heuristic complexity estimate of 
Lp [|; 1] arithmetic operations. In [128], using the method of [65] (the version with 
Gaussian integers), a logarithm was found modulo p of magnitude 1058. In 1997, 
Weber [275] found a logarithm modulo p of magnitude 1085, also using the version 
of the algorithm of [65] with Gaussian integers. He also showed that the method 
of [65] with Gaussian integers is better than the number field sieve for a given 
p of magnitude 1085. In [106], it was shown experimentally that, for p < IO90, 
the method of [65] is better than the number field sieve. However, for p > IO100, 
number field sieves are faster than the Coppersmith-Odlyzko-Schroeppel algorithm, 
which was also shown in [106], We shall say more about number field sieves for 
computation of discrete logarithms, the version of [65] with Gaussian integers, and 
about [275] in 5.5 of this chapter. Now we describe the simplest version of the 
Coppersmith-Odlyzko-Schroeppel algorithm.
The COS algorithm.
Stage 1. Set H = [p1/2] + 1, J = H2 — p > 0. Construct a set
S = {q | q prime, q < L1^2} U{B + c|0<c< L1/2*6},
where L and e are constants, L = Lp [|; 1], 0 < e < 1.
Stage 2. Using a sieve, we are seeking pairs of integers ci, C2 such that 0 < c* < 
i _|_e
L2 , i = 1,2, and the least (in absolute value) residue of (H + ci)(H + cz) (mod p) 

5.3. THE DISCRETE LOGARITHM PROBLEM IN PRIME FIELDS
95
is smooth with boundary L1/2, i.e.,
(ff+ ci)(/T + c2)= 0 Qa<l(ci’C2) (mod p).
q<L1/2, 
q prime
Since J = Ofp1/2), we have
(H + ci)(U + c2) = J + (ci + c2)H + cic2 (mod p).
Moreover, the least (in absolute value) residue in this class equals J + (ci + c2)U + 
cic2 and is of magnitude O(p1/2+e). Therefore the probability that it is smooth is 
higher than that for an arbitrary number on the interval [l,p — 1]. Computing log 
to base a, we have
logjH + ci) +Ioga(ff + C2) = ag(ci,c2)log0 g(modjr-l).
g<L1/2, 
q prime
This is a homogeneous equation in unknowns \oga(H + c) and logag. We may 
also assume that a is L1/2-smooth, a = ]Jq<Li/2q^9, and obtain a nonhomogeneous 
equation
1 = HX log“9 (mod p ~x)-
Stage 3. Having accumulated sufficiently many equations in Stage 2, we can 
solve the obtained system in the ring Z/(p — 1)Z and find loga(U + c) and loga q.
Stage 4. To find a concrete x = loga &, we introduce a new smoothness 
boundary L2. By random trial and error, we find one value w such that
awb= JI q9q JJ ^(modp).
q<L1/2, 
L^2<u<L\
q prime u prime
This congruence contains several new primes u of average magnitude.
Stage 5. Using the methods similar to those in Stages 2 and 3, we compute 
the logarithms of several primes u of average magnitude that appeared in Stage 4.
Stage 6. We can now find the answer
X = loga b = -w + ^2 S<7 loga <7 + Z2 loga U (modP- 1)- 
«<L1/2, 
u
q prime
End of algorithm.
Remark 5.4. The values loga(U + c) appearing in Stage 2 are insignificant. 
They are not needed later for computing the individual loga b. Because of that, they 
should be excluded from the system of linear equations in Stage 3. A technique for 
such exclusion can be found in [72]. The obtained system in the unknowns loga q 
is solved by structural Gaussian elimination, followed by the Lanczos algorithm, as 
in [128], or just by using the Lanczos method, as in [275].
Remark 5.5. We now describe the sieve used in Stage 2. Fix ci. Let q be a 
prime and f a small natural number such that qf divides J + (ci + c2)H + cic2. 
Then
c2 = -(J + ci^(H + ci)-1 (mod q9).

96
5. ALGORITHMS FOR COMPUTING DISCRETE LOGARITHM
This implies that the values C2 for the given g and f belong to an arithmetic 
progression. It is now clear that the sieve can be run similarly to the quadratic 
sieve method described in Chapter 3. We construct an array of L1/2+e elements 
indexed by C2. The initial values of the elements of the array are all 0. Then we 
run through the prime powers qf and, for a fixed qf, add rough approximations 
of logg to the elements with indices C2, C2 = —(J + 
+ ci)-1 (mod qf).
After running the sieve for all q < L1/2 and some small /, the elements of our 
array will be approximately equal to the logarithms of the smooth parts of the 
elements J + (ci + C2)H + C1C2. If the element indexed by C2 is approximately 
log | J + (ci + C2)H + C1C2I, then the number J + (ci + C2)H + C1C2 will probably be 
smooth, and we can factor it by trial divisions by a, a < L1/2. The reason for using 
the sieve similar to the quadratic sieve method for factorization, is a reduction in 
the number of divisions.
Remark 5.6. In [106], we find a computation of discrete logarithm modulo the 
prime p = [1089tt] + 156137, where is prime. It is based on the COS algorithm 
with Gaussian integers. The algorithm required 60 mips-years for finding relations. 
It took about three weeks to solve the system of linear equations. That was done 
by structured Gaussian elimination, followed by the Lanczos algorithm applied to 
a system of smaller size.
5.4. Discrete logarithm in Galois fields
Let p be a fixed prime number, n > 1 a natural number, and q = pn. Let a be 
a generator of the cyclic group GF(g)*. We want to solve the equation
(5.4) 
ax = b
in GF(g). For that we shall use algorithms with factor bases. In the case when p is 
small such an algorithm is described in [119, Ch. 4]. It has a heuristic complexity 
estimate of Lg[|; const] arithmetic operations.
The index-calculus algorithm.
Stage 1. (Precomputation.) GF(g) is isomorphic to GF(p)[p]/(/(p)), where 
/(p) e GF(p)[p] is an irreducible monic polynomial of degree n. Thus the elements 
of GF(g) can be represented as polynomials of degree at most n— 1. Multiplication 
of such polynomials is done modulo In particular, a = a(y) is some polyno­
mial. The element ai = a(9-i)/(p-i) is of order p— 1 and generates GF(p)*. Using 
it, we construct a table of logarithms of “constants”, i.e., of the elements of the 
prime field GF(p) C GF(g). For that, we compute a? = 1, ai,a2,... , fli”2. This 
is an efficient calculation, since we assumed that p is not large.
Stage 2. (Constructing a factor base.) The factor base B C GF(q) consists 
of all irreducible polynomials g of degree at most where t is some parameter, 
t < n (the choice of t is related to the complexity estimate of the algorithm).
Stage 3. (Finding relations.) Randomly choosing m, 1 < m < q — 2, we find 
the values such that
(mod /(j/)),

5.4. DISCRETE LOGARITHM IN GALOIS FIELDS
97
where co 6 GF(p). For factorization we need to use long division for polynomials 
over a finite field. The found relation implies that
m = loga Co + aa(m) loSa 9 (mod q - 1).
flGB
Here we already know loga co, whereas the loga are unknown quantities.
Stage 4. (Finding the logarithms for the elements of the factor base.) Having 
found, in Stage 3, sufficiently many relations (more than |B|), we solve a system of 
linear equations in Z/(g — 1)Z and find loga for g e B.
Stage 5. (Finding a specific logarithm.) In the simplest form of algorithm, we 
seek one value of m such that
b • am = ci JJ g03 (mod /(a:)), 
SGB
where ci e GF(p). This yields the desired value
log0 b = -m + log0 Cl + ^2 loga g (mod q - 1).
ggB
End of algorithm.
In the case when p is large the above algorithm is inefficient. To compute dis­
crete logarithm in GF(p2), ElGamal [77] came up with an algorithm of complexity 
estimate of Lp[|; const] arithmetic operations. He used an embedding
/: GF(p2) ZK
of the field GF(p2) in the ring of algebraic numbers Zk of some imaginary quadratic 
field K with trivial divisor class group.
The triviality of the divisor class group of K means that Zk has unique prime 
factorization and each ideal is principal. Our equation ax = b in GF(p2) will 
then become ax = /3 in Zk, where a = 
(3 = f(b). Now we can use the
standard discrete logarithm computation with factor base, which has already been 
described several times. In this method, the elements of the factor base are primes 
(irreducibles) of Zk with small norm.
Notice that the ElGamal algorithm is, in fact, a precursor of the number field 
sieve.
ElGamal [78] came up with yet another algorithm for computing discrete log­
arithm in GF(pn), where p is a large prime number and n > 2. It also has a 
heuristic subexponential complexity estimate of Lpn [j; const]. It uses a represen­
tation of GF(pn) in the form Zk/^3, where Zk is the ring of algebraic integers of 
the number field K, and is a prime ideal of Zk of norm pn.
Now consider the case p = 2, q = 2n. In 1984, D. Coppersmith [63] came up 
with an algorithm of heuristic complexity estimate of Lq [|; const]. That was the 
first subexponential algorithm with exponent |. Factorization algorithms of such 
complexity estimate appeared only in 1990 (the number field sieve; see Chapter 3).
We shall describe the idea behind the Coppersmith algorithm by an example. 
This algorithm is based on finding a good representation of the field GF(g) as 
GF(2)[rr]/(P(rr)), where the irreducible polynomial P(x) is of the form P(x) = 
xn + Q(x) with degQ(rr) < n2/3. Let n = 127. We can set P(x) = x127 + x + 1, 
which is an irreducible polynomial in GF(2)[rr]. We consider the field GF(2127) = 
GF(2)[rr]/(P(rr)). Let a = a(x) be the generator of the cyclic group GF(2127)*. 
Suppose we have chosen ^4(rr), B(x) e GF(2)[rr] with deg^4(rr) < 10, degB(rr) < 10, 

98
5. ALGORITHMS FOR COMPUTING DISCRETE LOGARITHM
and gcd(A(rr), B(x)) = 1. We consider A(rr) and B(x) as elements of GF(2127). Set­
ting C(x) = x32A(x) + B(rr), we have deg (7(3?) < 42. Consider a polynomial D(x) 
such that
D(x) = C(x)4 * (mod P(rr)), deg2?(rr) < 127.
4 52 ei lo * * * * * * *
Sa 9j(x) = 52 A- loSa 9j(x) (mod 9-1)
3 
3
is a relation for the unknowns loga^(rr), the discrete logarithms of the elements of
the factor base of our field GF(2127). These are homogeneous equations. However,
we may assume that the base a = a(x) in equation (5.4) either is itself an irreducible
polynomial of small degree, or factors into a product of such polynomials:
a = a(x) 
(mod F(rr)).
3
This yields a nonhomogeneous equation
1 = loga a = vj loga 9j(®) (mod q - 1),
3
and we have a nonhomogenous system of linear equations in the unknown quantities 
l°ga <7j(s). From this point on, the Coppersmith algorithm is similar to Adleman’s
algorithm, described in 5.3.
In [257, 258], using an improved version of the Coppersmith algorithm, a 
discrete logarithm was computed in the field GF(2607). It took about 19,000 mips- 
years to find the relations. To solve the system of linear equations, structured 
Gaussian elimination was used, followed by the Wiedemann algorithm for the 
smaller system (see the algorithm of Chapter 11). That part took more than two 
months. The author of [257] also remarks that, at present, the method used does 
not allow one to compute the discrete logarithm in GF(2n) for n > 997.
In [400], one finds a computation of the discrete logarithm in GF(p18) for 
p = 37081 using the algorithm of [362].
Then
D(x) = x128A(x)4 + B(rr)4 (mod P(rr)), 
and, since
z128 = x2 + x (mod P(x)\ 
we have
D(x) = (x2 + x^A^x)4 + B(rr)4 (mod P(x)).
Thus,
C'(z)4 = D(x) (mod P(rr)), degD(z) < 42, degC'(z) < 42.
Because the degrees of C(x) and D(x) are not large, these polynomials factor, 
with high probability, into products of irreducible polynomials of small degrees 
comprising the factor base, i.e.,
cw=n&w6 * * ** (mod P(rr)),
3
VW=(m°d
3
Then the congruence

5.5. DISCRETE LOGARITHM AND THE NUMBER FIELD SIEVE
99
For more on the discrete logarithm problem in GF(pn), see [154, 157]. See 
also [404].
5.5. Discrete logarithm and the number field sieve
In this section we shall discuss number field sieves for computing discrete log­
arithm with prime modulus. Number field sieves for factorization had appeared 
a little earlier (see 3.6). In 1993, based on the ideas behind those algorithms, 
D. Gordon [98] suggested an algorithm for solving the equation
(5.5) 
ax = 6(modp),
where p is a prime number. The heuristic complexity of that algorithm is Lp [|; 32/3] 
arithmetic operations.
Gordon’s method turned out to be impractical. Schirokauer [224] suggested his 
own version of the number field sieve for solving (5.5), of complexity 
Lp[|; (64/9)1/3] arithmetic operations. His algorithm was implemented by We­
ber, and a computation of discrete logarithms with modulus p of magnitude IO40 
can be found in [273]. In [226], this was done for a modulus p of magnitude 1065. 
In [274], Weber did some precomputations related to the discrete logarithm prob­
lem with modulus p of magnitude 10129, as suggested by McCurley. For that p, a 
solution of (5.5) was later found in [277]. However, because that number was of a 
special form, it was possible to use a special number field sieve, which worked faster. 
In 1997, Weber, in his thesis [275], computed discrete logarithms with a modulus p 
of magnitude 1085, which was not of a special form. He used both the number field 
sieve (Schirokauer’s method) and the Coppersmith-Odlyzko-Schroeppel algorithm 
(the version with Gaussian integers). It turned out that the number field sieve is 
slower for the given p (see [276, 275]) than the Coppersmith-Odlyzko-Schroeppel 
algorithm. Later, Joux and Lercier showed that, for p > IO100, number field sieves 
work faster than the Coppersmith-Odlyzko-Schroeppel algorithm; see [106]. In 
January 2001, Joux and Lercier computed discrete logarithms with a modulus p of 
magnitude IO110 (see [107]), and, in April 2001, with a modulus of magnitude 1012° 
(see [108]). In 2005, discrete logarithms were computed with a modulus of magni­
tude 1013° (see NMBRTHRY Archives, June 2005 (19), http://listserv.nodak.edu).
Before we describe number field sieves for solving (5.5), we mention other results 
in this field.
Schirokauer [225] generalized the algorithm of [224] to GF(pn). When q = pn^ 
the complexity estimate is Lg[l/3; (64/9)1/3] arithmetic operations. In fact, this is 
true for a fixed p and n —> oo. According to [225], this estimate also holds when 
logp > n2+e for some e > 0. Semaev [235] obtained some results on the discrete 
logarithm problem in finite nonprime fields.
The ideas of Coppersmith and Schirokauer have been used in [157, 158] for 
computation of discrete logarithms in the prime field GF(p), with the currently 
best complexity estimate of Lp [|; c], where c = (92 + 26\/13)1/3/3 ~ 1.902.
In [98], one finds a version of the number field sieve for numbers of a special 
form. It has complexity Lp[|;c], where c ~ 1.00475. Since c is close to 1, in some 
cases, such an algorithm works faster than algorithms of complexity Lp[|;c], as 
was shown in [277].
See also [195, 129].

100
5. ALGORITHMS FOR COMPUTING DISCRETE LOGARITHM
Now, following [275], we shall give a general description of number field sieves 
for solving (5.5). As a particular case, we shall also describe a version of the 
Coppersmith-Odlyzko-Schroeppel algorithm with Gaussian integers. It is custom­
ary to consider the algorithm of [65] as a separate method, different from the 
number field sieve, since it was proposed earlier and has its own complexity esti­
mate.
In this section we again assume, as in 3.6, that the reader is familiar with 
algebraic number theory as covered by [251].
Description of the algorithm.
Stage 1. At this stage, we reduce equations (5.5) to the equations
= s (mod p), s G S',
where S is a finite set of sufficiently small natural numbers. Roughly speaking, we 
seek one number z G N such that
az • b = JJ Sj (mod p),
3
where the Sj are moderately small primes, say, Sj < Lp[|; const]. Factorization of 
az • b (mod p) can be done by Lenstra’s elliptic curve method (see Chapter 4). Then 
S = {sj and loga b = -z + loga Sj (mod p - 1).
Stage 2. Using some technique, we choose two polynomials pi (rr), g2 (#) G Z[rr], 
degpi(rr) = i = 1,2, having a common root m(mod p). We shall use the 
following notation for j = 1,2:
aj G C is a fixed root of Pj(rr),
hj G N is the leading coefficient of Pj(rr),
Kj = Q(aj),
Oj = Zkj. is the ring of algebraic integers of the field Kj.
Remark 5.7. In the present context, the version of the Coppersmith-Odlyzko- 
Schroeppel algorithm with Gaussian integers can be described as follows.
1) ni = 2, Pi(rr) is an irreducible quadratic polynomial, and Ki is an imaginary 
quadratic field with trivial divisor class group.
2) n2 = 1, and p2(rr) is a linear polynomial Ux + V, [/, V G Z.
Stage 3. (Construction of the factor base.) For j = 1,2 we find factor bases
Fj = {ft I P are prime ideals of Normp < BJ U {hj}.
Here the Bj are some constants depending subexponentially on p.
Stage 4. Using a sieve, we find a set of pairs C = {(c, d)} G Z2 such that for 
i = 1,2 the ideals (hi(c + rfaj) of Oj are smooth relative to the factor base Fj. 
Moreover, C should be large enough, |C| > |Fi| + |F2|.
Stage 5. For each s G S, we shall find special relations. For each prime ideal 
ps G Oi lying over s we find a pair of numbers c, d such that the ideal (hi (c+ad))/pi 
is Fi-smooth and the ideal (h2(c + da2)) is F2-smooth.
Stage 6. For each large prime number q dividing p — 1 (we assume that we 
already know the factorization of p — 1), we do the following.
1. Compute Schirokauer’s additive characters (for the definition, see below) of 
the elements hj(c + daj), j = 1,2, (c,d) G C.

5.5. DISCRETE LOGARITHM AND THE NUMBER FIELD SIEVE
101
2. Find a matrix A with entries in Z/gZ. Its columns consist of the exponent 
vectors from the factorization of hj(c + daj) into prime ideals and of the values of 
the additive characters.
3. By solving the system of linear equations AX = 0(mod g), we determine 
the elements G (9;, i = 1,2, such that = 6%, 6i e O^ i = 1,2.
4. 
Using the ring endomorphisms
(f>j: Z[hjaj] —> Z/pZ, 
= hjm (mod p), j = 1,2,
we pass from the gth powers in the rings Oj to the integers and find fc, I G Z such 
that ak • bl = dq (mod p). This implies that k + lx = 0 (mod g), where x (mod p — 1) 
is a solution of (5.5). From this, we find x (mod g).
Remark 5.8. For the version of [65] with Gaussian integers we do not need to 
compute Schirokauer’s additive characters, because we work in the rings Oi with 
unique factorization and a finite group of units.
Stage 7. In Stage 6 we found x (mod g) for large prime factors q of p — 1. 
Suppose p — 1 is not divisible by a square of a large prime. Then the missing 
values rr(mod ga<1), where the g are small primes, qaq ||p — 1, can be found using 
the Pohlig-Hellman algorithm. Using the Chinese Remainder Theorem, we find the 
desired value x (mod p — 1).
End of algorithm.
We shall now define Schirokauer’s additive characters, mentioned in Stage 6 of 
the algorithm. Let a be an algebraic number, deg a = n, f(x) = anxn H------ I- ao G
Z[rr] the minimal polynomial of a, K = Q(a), and O = Zk the ring of algebraic 
integers of K. We set
r = {7 G O | l] NormK/Q(7)}, 
£ = 1cm {|(O/b)*| | t> are prime ideals of O, b|(Z)}.
Clearly, T is a multiplicative subgroup. Consider the map
A: 
A(7) = 7f-l(modZ2O).
It is not difficult to see that A is a homomorphism of the multiplicative semigroup 
to the additive group of IO/12O. Let
O = Zuq (B • • • (B Ztdn,
where u>i,... ,u>n is a Z-basis of the ring O. Then IO/12O is a linear space over 
Z/ZZ with basis Zcui (mod l2O),..., Zwn (mod Z2(9). Let Q; = la>i (mod l2O) and 
A* (7) = 
where bi G Z/ZZ. Consider the maps A;: T —> Z/ZZ, A(7) =
bi (mod Z). These maps are called Schirokauer’s additive characters. Notice that A 
is uniquely determined by the set Ai,..., An.
It was shown in [224] that, under some assumptions, the equality A(7) = 0 
implies that 7 = <5Z, where 6 G O. This allows us to find the elements 7* = in 
Stage 6 of the algorithm.
Now we briefly describe the sieve used in Stage 4 of the algorithm. The condi­
tion that the ideal (hi(c + d&i)) be smooth in Oi is equivalent to the smoothness 
of the norm NormK/Q(/ii(c + dai)) in the ring of integers. This norm is a homoge­
neous polynomial filc^d), where fi(X, Y) e Z[X, K]. Suppose we want to find the 
values c,d such that fifad) is smooth relative to some boundary B. If we fix d, 

102
5. ALGORITHMS FOR COMPUTING DISCRETE LOGARITHM
a prime number g, and a natural number A, then the values c such that g^|/(c, d) 
will belong to the arithmetic progression
c = d'Vj (mod qh),
where Tj (mod qh) is one of the solutions of the equation /(Z, 1) = 0 (mod qh). It 
is now clear that we can run a sieve similar to the algorithms described in 3.4 and 
3.6. This kind of algorithm is called a linear sieve. There is also a vector sieve 
(when we move not along an arithmetic progression but along some lattice in Z2) 
and a lattice sieve; see [76].
This concludes the description of the number field sieve for computing discrete 
logarithms.
Remark 5.9. Using some improvements of the number field sieve, Adleman [2] 
constructed an algorithm for computing discrete logarithms in finite fields GF(pn), 
with complexity of Lpn [|; const] arithmetic operations. However, this complexity 
estimate does not hold for all pn; see [196]. More precisely, one must have logp < 
ni/2 same method is considered in [376]. See also [377].
Remark 5.10. In [353] there is a discussion of various sieves for algorithms 
for finding the discrete logarithm in finite fields. The authors also offer a sieve 
algorithm of their own. [308] studies the so-called multiple-lattice number field 
sieve.
5.6. Fermat quotient and discrete logarithm with composite modulus
In this section we describe methods for verifying the solvability and finding the 
solution of the discrete logarithm problem in residue rings Z/mZ with composite 
modulus m, as well as in the rings of the form GF(p)[rr]/(/(rr)), where f(x) G 
GF(p)[rr] is a reducible polynomial. Some results in that direction were obtained 
in [222, 267, 266].
Definition 5.11. Let r e N and r = 2a°p“1 • • -p"* be the prime factorization 
of r, 2 < pi < • • • < pt. Define the Carmichael function A(r) by
A(r) = 1cm (</>0(2ao), 
0, • • • > <p(p"‘))>
where is the Euler function, 
= 1> <Po(4) = 2, and </>o(2"°) = 2“0-2
for Qq > 3.
It is easy to see that if a G Z and (a, r) = 1, then ax^ = 1 (mod r).
Definition 5.12. Let r G Z>i, a G Z, (a,r) = 1. The Fermat quotient Q(a,r) 
is defined by
aA(r) - 1 
Q(a,r) =-----------(mod r)
r
(here qA(^~- denotes the result of dividing ax^ — 1 by r in the ring Z).
We shall now mention some properties of the Fermat quotient. For more details, 
see [222, 83, 45, 150].
Lemma 5.13. Let a,b G Z, (a,r) = (&,r) = 1. Then
Q(ab,r) = Q(a,r) + Q(&,r) (mod r).

5.6. FERMAT QUOTIENT AND DISCRETE LOGARITHM
103
Proof. Since 
flA(r) = i r) (mod r2), bx^ = 1 + rQ(&, r) (mod r2),
we have
(a&)A^ = 1 + r(Q(a, r) + Q(&, r)) (mod r2).
This congruence implies the assertion of the lemma. 
□
Remark 5.14. We have shown that the Fermat quotient has the same property 
as the logarithm: it transforms product into sum.
Definition 5.15. Consider Q(r, #) as a function on the set of numbers x G Z 
such that (rr,r) = 1. We shall call m G Z,m =4 0, a period of Q(r, #) if
1) m is divisible by all primes dividing r,
2) Q(a + m,r) = Q(a,r) (mod r) for all a G Z such that 2) (a,r) = 1.
Lemma 5.16. R = ry is a period of Q(r,x).
Proof. Since R = r • we ^ave r I and therefore the first condition 
in the definition of the period is satisfied. Moreover, since —= 0 (mod r), we have 
Q(a + R,r)= + 
1 (mod r) = -—>--- 1 + A(r)aA(r)-1 • — (mod r).
r 
r 
r
Now, 
X(r)R X(r)r2
Therefore, Q(a + R,r) = Q(a, r) (mod r). 
□
Remark 5.17. If m is a period of Q(#,r), then the Fermat quotient is a ho­
momorphism of the multiplicative group (Z/mZ)* into the additive group Z/rZ.
Consider now the discrete logarithm problem ax = &(mod m), where m is 
a period of the Fermat quotient Q(rr,r). It follows from the equalities (a,m) = 
(&, m) = 1 that (a,r) = (&,r) = 1. Because of the periodicity,
Q(&, r) = Q(czx, r) (mod r) = xQ(a, r) (mod r).
If (Q(a,r),r) = 1, then
x = Q(b) rjQfa, r)-1 (mod r).
Thus, we will find #(mod r). But we need to determine x modulo the order of 
a (mod m) in (Z/mZ)*. In some cases this is impossible; see [222]. This is related 
to the so-called A-low numbers. For more on A-low numbers, see also [138].
Example 5.18. Let m = 1600 = 2652, a = 3. Consider the equation 
3* = &(mod 1600).
Set r = 80 = 245; then A(r) = 4, R = 
= 
= 1600 = m. By Lemma 5.16,
m is a period of Q(rr,r). Now,
34 — 1 
Q(3,r) = (mod 80) = 1 (mod r). 
80
Because of the periodicity,
Q(&, r) = Q(3X, r) = xQ(3, r) = x (mod 80) = x (mod A(m)), 

104
5. ALGORITHMS FOR COMPUTING DISCRETE LOGARITHM
since A(m) =80. As the order of 3 (mod m) in (Z/mZ)* divides A(m), we have 
that the solution of 3® = b (mod 1600) is given by the formula
b4 - 1 , 
,
x = -gQ- (mod 80).
The found x should be checked out, since the equation 3X = b (mod m) is solvable 
not for every b e (Z/mZ)*. In our example we use the fact that, for given m and 
r, we have A(m) | r. This is far from being always true.
Using the Fermat quotient, one can lift the solutions of ax = &(mod pa), and 
find the solutions of ax = b (mod pa+1).
Theorem 5.19. Let p be an odd prime number, a e Z>2, m = pa. Let g e 
Z, g (mod m) be a primitive root modulo m, b E Z, (b,p) = 1. Let x = [log&Ja e 
Z/<p(pa)Z be a solution of the equation gx = b (mod m). Then [log6]a is a unique 
modulo <p(pa) solution of the system
(Q^P^^x = QfjLP01-1) (mod pa-1),
1 x = [logb]i (mod p — 1), 
where [log b] i denotes the solution of the equation gy = &(mod p).
Corollary 5.20. It follows from Theorem 5.19 that the discrete logarithm 
problem in the group (Z/paZ)* reduces, when p > 2, to the computation of the 
discrete logarithm in (Z/pZy.
Proof of the theorem. Let r = pa-1. Then 
y»2 
p2ot 2
R = (A(r),r) = (p«-2(p_i))Pa-i) = ?“ = m-
By Lemma 5.16, m is a period of Q(x, r). Therefore the congruence gx = b (mod m) 
implies that xQ(g,r) = Q(b,r) (mod r), i.e., the first equation of the system holds. 
Also, the congruence gx = b (mod m) implies that gx = b (mod p). This means that 
the second equation also holds.
To prove the uniqueness, it suffices to show that Q(P)Pa-1) 
0 (mod p). Since
g (mod pa) is a primitive root, we have pp-1 1 (mod p2). By induction, we now 
have, for u = 1,2,3,..., that
g{p~1)pU = l+pu+1Au, 
where Au G Z, Au 0 (mod p). Let u = a — 2; then g'f<'pa — 1 is divisible 
by p“-1 and is not divisible by pa. Since A(p“-1) = <p(p“-1), the congruence
Q(9>Pal) = 9 
(modp“-1)
p
implies that Q(P)Pa_1) 
0 (mod p). 
□
Theorem 5.21. Let m = 2a, where a e Z>5. Let b e Z be an odd number such 
that
b = (—l)fe°5fel (mod 2a),
where kQ = 0 when b = 1 (mod 4),fc0 = 1 when b = 3 (mod 4), and 0 < fci < 
2a~2 — 1. Let [log&Joi = ki> Then [log^a is a unique modulo 2a~2 solution of the 
equation
zQ(5,2a"2) = Q(b, 2a"2) (mod 2a"2).

5.6. FERMAT QUOTIENT AND DISCRETE LOGARITHM
105
Corollary 5.22. Theorem 5.21 implies that the discrete logarithm problem in 
Z/2aZ* for a > 5 reduces to the computation of
Q(&,2“-2)Q(5,2“-2)-1 (mod 2“-2).
Proof of the theorem. Set r = 2“-2. Then 
r2 
n2a—4
p _ 
' 
_ Z_ not _
(A(r),r) 
(2“-4,2“-2)
is a period of Q(x,r). If b = (—l)fc°5fel (mod 2“), then
Q(b,r) = <2((-l)fe°5/ci,r) = ((~l)fc°5fcl)A(r) ~ 1 = $klX{r} ~ 1 (mod 
r 
r
because A(r) is even by the condition a > 5. Thus,
Q(&,r) = Q(5fel,r) = fciQ(5,r) (mod r).
To prove the uniqueness, it suffices to show that Q(5,r) is odd. As 
r:A(2a-2) _ -I r2“-4 _ -j
0(5,2”-2) a 2 
("“Xi
it suffices to show that 52Q 4 
1 (mod 2a-1) when a > 5. This can easily be
checked by induction on a. This proves Theorem 5.21. 
□
Consider now the equation
(5.6) 
ax = b (mods), (a, s) = (&, s) = 1,
where s e N, s > 1, s is odd, and the prime factorization of s is known: 
k
(5.7) 
s = n^> k^2-
i=l
Suppose also that the prime factorization of qi — 1 is known:
Vi
(5-8) 
= 
i =
3 = 1
We shall study the question of how to verify the solvability of the discrete logarithm 
problem (5.6).
First, we discuss how to solve equation (5.6). Let gi be primitive roots modulo 
i = 1,..., k. They can be found if (5.8) is known. Suppose c^, i = 1,..., fc, 
satisfy
fc» = 9i (mod g“4),
(Cj = 1 (mod g“j) 
for j / i.
Then the Ci (mod s) are of orders </?(g^) = M*, and
(Z/sZ)* = (ci (mod s))mi x • • • x (cfe (mod s))Mfc 
is a decomposition of (Z/sZ)* into a direct product of cyclic groups. Let
fa = c^1 • •(mod s),
1 
= cf1 • • • (mod s).
The numbers A, 0 < A < Mi — 1, can be found by solving the equations g? = 
a (mod g^) (the Bi are found similarly). Using Theorem 5.19, the problem is 
reduced to solving the equations gf = a (mod gj. In other words, to find Ai and 

106
5. ALGORITHMS FOR COMPUTING DISCRETE LOGARITHM
Bi we need to solve the discrete logarithm problem with prime modulus. As we 
have seen before, this is a difficult problem if the modulus is large.
Assume however that we know the numbers Ai and Bi in (5.9). Then (5.6) and 
(5.9) imply that
9^x = g^ (modq“‘), i =
Thus,
(5.10) 
AiX = Bi (mod (pf.qf1)), z = l,...,fc.
If system (5.10) has a solution, then the numbers
(5.11) 
D^gcd^,^4))
divide Bi. If this is the case, then (5.10) implies that
(5.12) 
x = {Ai/D^-1 (BJDi) (modq>(q?)/Di), i = l,...,k.
System (5.12) is solvable if and only if the right-hand sides of the zth and the 
jth equations from (5.12) are congruent modulo gcd(<p(g^i)/Di,^(gjj)/Dj) f°r 
i =4 j. In that case we can find a solution of (5.12). We denote it
(5.13) 
x0 (mod Icm^g^J/Di,... ,<p(q%k)/Dk)).
Lemma 5.23. For the numbers Di defined by (5.11) we have
ord (a (mod s)) = 1cm (<p(q^)/Di,..., <p(q%k)/Dk),
where ord (a (mod $)) denotes the order of the element a (mod s) e (Z/sZ)*.
Proof. Since
orda (mod s) = lcmi=i>.„>fc(ord (a (mod g^)))> 
it suffices to show that
ord (a (mod g“4)) = </?(g“4)/A, i = 1, • • •, k.
By the definition of the numbers Ait we have a = (mod </“*). Let p be a 
prime number, a = VpMq*)) > 1. If vP(Ai) > a, then z/p(ord (a (mod q^))) = 0 
and vp(Di) = a. If/3 = z/p(?U) and 0 < 0 < a, then, clearly, z/p(ord (a (mod q^))) = 
a — 0, and vp(Di) = 0. In all the cases,
z/p(ord (a (mod q^))) = vp^q^)/Di). 
□
Remark 5.24. The numbers Di = gcd(Ai, </?(g^)) can easily be found if we 
know ord (a (mod g^))> even we do not know Ai. This follows from the proof of 
Lemma 5.23. Indeed, let p and a be the same as in the proof of Lemma 5.23 and 
Ei = ord (a (mod g^)). If p | then pa | and therefore z/p(A) = <*• If pe || E^ 
where 1 < e < Vp&fai*)), then z/p(Ai) = ^P(^(g^)) “ e- Therefore z/p(A) = 
^P(^(g^)) “ e- We also remark that Ei can be computed if factorization (5.8) is 
known. For the algorithm computing the order of an element, see 1.5.
Remark 5.25. Lemma 5.23 implies that (5.13) is the desired solution of equa­
tion (5.6) in the case when system (5.12) is solvable.
We have shown how to solve (5.6) when the numbers Ai,..., A&, Bi,..., B^ 
are known. Below we shall prove two theorems giving necessary and sufficient 
conditions for the solvability of (5.6). In those theorems we do not assume that Ai 
and Bi are known.

5.6. FERMAT QUOTIENT AND DISCRETE LOGARITHM
107
Lemma 5.26. Let q be an odd prime number and q — 1 = 11^=1 Pjj the prime 
factorization ofq—1. Let u e N, a,b G (Z/gnZ)*, a 1 (mod qu), and g a primitive 
root modulo qu. Then:
l)lf
n
ord (a (mod quf) = qu~1~l3o 
, where /3j e Z>o,
>=i
then
q00 ft pfj -i 
a = g j=1 (mod qu), 
where 0 < I < <^(gn). Moreover, if u > 1 and /3q < u — 1 or if u = 1, then q | I; if 
j > 0 and /3j < otj, then pj | I.
2) The congruence ax = b (mod qu) is solvable if and only if ord (& (mod quf) 
divides ord (a (mod quf).
Proof. The first assertion is obvious. The second follows from the fact that 
the group (Z/gnZ)* is cyclic. 
□
Now we return to the question of solvability of (5.6). We shall use the notation 
of (5.7), (5.8), (5.9).
Lemma 5.27. Equation (5.6) is solvable if and only if the system of congruences
AiX = Bi (mod g^i-1),
AiX = Bi (modp°?j), j = l,...,Vi, z = l,...,fc.
is solvable.
PROOF. The congruence ax = b (mod s) holds if and only if
CiiX = c?1 (mod q?), i = 1,..., k.
This happens precisely when the system AiX = Bi(mod (pfai*]), i = l,...,fc, is 
solvable. Clearly, this is equivalent to system (5.14) being solvable. 
□
Theorem 5.28. Suppose that, in (5.8), pn = 2 and an = 1 for i = 1,..., k. 
Assume also that the primes qi and Pij for j = 2,... ,Vi, i = 1,..., k, are all 
distinct. Suppose that a 1 (mod g^) and
ord (a (mod g“4)) = g"4”1-^40 JJ , i = l,...,k, 
j=i
where /3iQ < Ui~l ifui > 1, and/3ij < &ij for all j = 1,... ,vi} i = 1,... ,k. Suppose 
also that ord (b (mod g^)) I ord (a (mod g^)) for i = 1, • • •, k. Then equation (5.6) 
is solvable if and only if
^<’1(«4-1)/2 = F(modg“i), i = l,...,k,
where F = 1 or F = —1.
PROOF. We assumed that k > 2 in (5.7). Congruences (5.9) and Lemma 
5.26, 1) imply that
Vi 
j=l
(5.14)

108
5. ALGORITHMS FOR COMPUTING DISCRETE LOGARITHM
where Li e N, (L;, </?(g^)) = 1- Notice also that if Ui = 1, then (3iq = 0. Moreover, 
qi { Li. Let
Vi
ord (t» (mod q?)) = <?“i-1-7i0 J] p°^, j = 1,..., k.
J=1
By assumption, 7^ > (3ij for all j = 1,...,i = 1,..., k. Lemma 5.26 implies 
that
Vi
J=1
where Ni G N. Applying Lemma 5.27, we reduce the solvability of (5.6) to that 
of (5.14). An equation
AiX = Bi (mod g^i-1)
from that system is equivalent to the equation
Vi 
Vi
(5.15) 
• l^x=(m°d
J=1 
J=1
The latter equation is solvable: for Ui = 1 this is obvious, and for Ui > 1 this follows 
from the fact that qi | Li. The equation
(5.16) 
AiX = Bi (mod p“-j), j > 1,
from system (5.14) is also solvable, because vPij (A;) = /3ij < yij < vPij(Bi). Since 
the moduli in equations (5.15) and (5.16) are odd and distinct by assumption, 
system (5.14) is solvable if and only if the subsystem
(5.17) 
AiX = Bi (mod 2), i = l,...,fc,
is. Since an = 1, we have /3n = 0 for i = 1,..., fc, and the numbers Li are odd. 
Thus, Ai = 1 (mod 2), i = l,...,fc. Therefore, (5.17) becomes x = Bi (mod 2), 
i = 1,..., k. Now (5.17) is solvable if and only if
Bi= E (mod 2), i = 1,..., fc,
where E = 0 or E = 1. We have
The assertion of the theorem now follows. 
□
Theorem 5.29. Let q^..., g& be distinct odd primes,
Vi
3=2
where pij are odd primes. Suppose the numbers Pij, for j = 2,... ,Vi, i = 1,... ,k, 
are distinct. Let s = gi • • • qk, a,b G N, (a,s) = (6,s) = 1, t G N, 1 < t < k. 
Suppose that a (mod gj is of order qi — 1 for i = 1,..., t and of order (qi — l)/2 
for i = t + 1,... ,k. Equation (5.6) is solvable if and only if
where (|) is the Legendre symbol.

5.6. FERMAT QUOTIENT AND DISCRETE LOGARITHM
109
PROOF. It follows from (5.9) and from the assumption of the theorem that 
the Ai are relatively prime with ^(gj = qi — 1 for i = 1,..., t, and that, for 
i = t + 1,... , fc, the numbers Ai are even and relatively prime with (g* — l)/2. 
Lemma 5.10 gives rise to the system
{
AiX = Bi (mod 2),
AiX = Bi (modp“/3 ), 
where j = 2,..., ty, i = 1,..., k. This system is solvable if and only if the subsystem 
AiX = Bi (mod 2), i = 1,..., fc,
is. This subsystem is of the form
{x = Bi (mod 2), i = 1,..., t,
Bi = 0 (mod 2), i = t + 1,..., k.
Notice that Bi = 0 (mod 2) if and only if (^-) = 1. The assertion of the theorem is 
now obvious. 
□
Remark 5.30. In Theorems 5.28 and 5.29, the greatest common divisor of g^ —1 
and qj — 1 was 2. This yields necessary and sufficient conditions for the solvability 
of (5.6). If qi — 1 and qj — 1 have a small prime number p > 2 as a common divisor, 
then the solvability of (5.6) can be verified by a Pohlig-Hellman-type algorithm. 
We suggest that the reader give a description of such an algorithm as an exercise.
Fix a prime number p and consider the discrete logarithm problem ax = b in the 
group (Z/pZ[rr]/(F(rr)))* of invertible elements of the quotient ring Z/pZ[rr]/(F(rr)), 
where the polynomial F(rr) G Z/pZ[rr] is reducible.
Fix an irreducible polynomial / = f(x) = xn + An_irrn-1 H------ 1- Ao G Z/pZ[rr]
of degree n > 1. We now state several auxiliary results about the rings Rk = 
Z/pZ[rr]/(/fc(rr)), k = 1,2,3,... . It is well known that Ri = GF(pn) and that 
there is g(x) G Z/pZ[rr], deg <7(2) < n, such that g(x) (mod /) is of order pn - 1 
(see, for example, [153, Ch. 2]). Fix such a g(x).
Lemma 5.31. 1) There is a polynomial gi(rr) (equal to either g(x) or g(x) + 
f(x)) such that deg <71(2) < n and gi(rr)pn-1 1 (mod /2).
2) If h = h(x) G Z/pZ[rr] and f | h, then, for all j > 0, 
= l(mod /pj).
3) If j > 1 and p^1 < k <pi, then the order of any multiplicatively invertible 
element of Rn divides p?(pn — 1), and there is an element of this order.
Proof. Let ^(rr)pn-1 = 1+fl(x)t(x), where t(x) g Z/pZ[rr], f(x) | t(x), I G N. 
If I = 1, then gi(rr) = g(x). If I > 2, then
+ f^y"-1 = g^r-1 + (pn - l)g(rr)pn-2/(rr) + • • •
= 1 - p(a:)pn_2/(a:) +
where ^i(rr) G Z/pZ[rr]. Therefore, gi(x) = g(x) + f(x) satisfies the first con­
dition of the lemma for I > 2. Suppose now /i(rr)pn-1 = 1 + f(x)t(x). Then 
h(x)(pn-1)pJ = 1 + ^(rr)pJ/(rr)pJ, which proves the second assertion. It is easy to 
see that gi(rr) (mod /fc(rr)), where gi(x) was defined above, is of order p*(pn — 1) 
in Rk. The third assertion is now also obvious. 
□

110
5. ALGORITHMS FOR COMPUTING DISCRETE LOGARITHM
Lemma 5.32. Let k > 1. Then \Rk\ = pnk and \R*k\ = pn(fc-i)(pn - 1). If 
p7 -1 < fc < p7 , then Rk is a direct product of cyclic groups
Rk = (Cfc,o)pn-1 x (£fc,l)pzfc,i x x (^ktsk)plk,sk >
1 + fix/-1,1 + xfix/-1,..., 1 + x^fix/-1.
Then Rk = (7?o)pn-i x (771)p x • • • x (pm)p is a direct product decomposition (here tjq 
is some element of order pn — 1 in Rk).
Proof. Clearly, for j = 1,..., M, the elements pj have order p. To prove the 
lemma it suffices to show that the equality
= rffrfc •■■rffl (mod fk),
where 0 < yo, zQ < pn — 1, 0 < yj,Zj < p, j = 1,..., M, implies that yj = Zj for j = 
1,..., M. Indeed, since pj = 1 (mod /(rr)) for j > 1, we have p$Q = Pq° (mod /(#)). 
Thus the order of pq divides (?/o — zo)pk. Therefore yo = zq. Canceling out Pq° and 
reducing modulo f2, we have
»711 • • »?nn = fll1 • • • (mod /2)-
But
■ni1 • • • »7nn = (1 + 3/1 /(^))(1 + V2Xfix)) •••(! + ynxn~1f(x))
= (1 + 0/1 + y2x + • • • + 3/n®n-1)/(®)) (mod /2);
f/11 • • • T)nn = (1 + (zi + z2x + • • • + z^-^fix)) (mod /2).
Therefore, yx = zi,..., yn = zn etc. 
□
where lkii H-------1- lktsk = n(k — 1) and j = lk,i > lk,2 > • • • > lk,sk- In particular,
for 1 < k <p, sk = n(k — 1) and
Rk = (Cfc,o)pn-1 x (Cfc,l)p x • • • X (£fc,n(fc-l))p*
Proof. The elements of Rk \ Rk are polynomials of the form /(#) • (ao + ^1# + 
---- F ^n(fc-i)-i^n^-1^-1)- This proves the claim about |E£|. That Rk is a direct 
product follows from the theorem that a finite abelian group is a direct product of 
cyclic groups and Lemma 5.31. 
□
Lemma 5.33. Let k>2 and £ G Rk- Then £ has a unique representation 
£ = a0(a:) + ar(x)f(x) + • • • + ak--L{.x)fk~l{x) (mod fk(x)\
where ai(x) G Z/pZ[rr] and deg < n. Moreover, £ G Rk if and only if ao(x) =4 0. 
The order of £ is a power of p if and only if ao(x) = 1.
Proof. We shall prove only the last assertion. The sufficiency follows from the 
equality £p = ao(#)p (mod fk). The necessity follows from Lemma 5.32, because 
the number of elements of order a power of p equals pn(fc-1), which is exactly the 
number of elements £ such that ao(^) = 1- 
□
Lemma 5.34. Let 2 < k < p, M = n(k — 1), and t/i, ... ,Pm is the following 
set of elements of order p in Rk:
1 + fix), 1 + xfix),..., 1 + a:n_1/(x);
1 + f(x/> 1 + xfix)2, •••>! + 3:n-1/(a:)2;

5.6. FERMAT QUOTIENT AND DISCRETE LOGARITHM
111
The following lemma is well known.
Lemma 5.35. Let mi,m2 E N and d = (mi, m2). Then (pmi — l,pm2 — 1) = 
pd - 1.
Lemma 5.36. Let k e N, k > 2, h e and suppose that the order of h 
divides p. Consider the function
ap _ 1
QoW = ^- (mod. /fe).
Then Qo(h) is well defined and
Qo(^i^2) = Qo(^i) + $0(^2) (mod fk).
Proof. By Lemma 5.33,
/i = l + ai/H------ F ak-if^1 (mod fk), dega;<n.
By the assumption,
hp = 1 + apfp + ■■■+ 
(mod fkp) = 1 (mod /fc).
Let j > 1 and (j — l)p < k < jp. Then, clearly, ai = • • • = aj-i = 0. Therefore
hp - 1 = 
+ ■■■ + 
(mod fkp) = 1 (mod fkp).
This implies that Qo(ft) is well defined. Now,
hp = 1 + fkQ0(h) (mod f2k\
Therefore
= 1 + fk • (Qo(Ai) + Qo(A2)) (mod f2k).
The lemma is proved. 
□
Theorem 5.37. Let k > 2 and Ai, ^2 £ R^- If order of hi divides pn — 1, 
then the equation hi = h^ is solvable if and only if the order of hi divides the order 
of h2.
PROOF. This follows from Lemma 5.32 and the fact that (Cfc,o)pn-i 3 Ai, h2 is 
a cyclic subgroup. 
□
Theorem 5.38. Let p/2 < k < p and suppose the elements hi, h2 of R^ have 
order p. Let (by Lemma 5.33,)
hi = 1 + ai(x)f(x) + • • • + afc_i(o:)/(a:)/c-1 (mod /*),
/12 = 1 + bi(x)f(x) + • • • + &fc_i(m)/(m)*-1 (mod /*),
where deg a;, degfy < n. If bi(x) =4 0 and the equation hi = hy2 is solvable, 
then yi = (ai(rr)&i(rr)-1)p (mod /(#)).
Proof. By Lemma 5.36, Qo(^i) = yQo(h2) (mod /fe). Since p > k, we have
Qo(Ai) = apfp~k (mod /fe), Q0(M = ^ifp~k (mod /fe).
As 2k — p > 1, this yields ap = yb^ (mod /2fe-p), which implies the assertion of the 
theorem. 
□
Remark 5.39. If the elements hi, h2 have order p, and bi(#) =4 0, then, having 
found y by Theorem 5.38, we can check if hi = ti%.

112
5. ALGORITHMS FOR COMPUTING DISCRETE LOGARITHM
Theorem 5.40. Let p/2 < k < p and hi,hz e R^. Suppose the order of hi 
equals pdi, the order of hz equals pd2, and di \dz | pn — 1. Let (by Lemma 5.23,)
fti”-1 = 1 + «i(2;)/(a:) + • • • + Gfc-i (af)/(ar)fe-1 (mod fk),
= 1 + 
+ • • • + bk-i(x)f(x)k~l (mod /*),
where dega*, degfy < n and &i (re) 0.
1) Suppose there is yo G Z/pZ such that yo = (ai&f x)p (mod /(rr)). If 
h?-1 ee <->, 
then the equation hi = h^ is solvable.
2) If the residue class (ai&f1)p(mod f(xf) does not contain yo E 'L/p'iL or if 
it contains yo E h/ph but h? -1 =4 (h? -1)2/0, then the equation hi = h^ has no 
solutions.
Proof. We shall prove the first assertion. By Lemma 5.32,
hi = 
• • • C(t-D (mod A 712 s • • • eZX’i) (mod n
If di | d2i then there is pi, 0 < yi < pn - 1, such that £$} = (££q)P1 (mod fk). 
Moreover, it follows from our assumptions that
//•uoetii 
A(k-i) \Pn-l _ 
evn(k-i) \{pn-1)3/0 / i fk\
ISfcOSfcl 
^fc,n(fc—1)/ 
= ISfcOSfcl $k,n(k-i)) 
^moa I L
Clearly, a natural number y such that y = yo (mod p) and y = yi (mod pn — 1) is a 
solution of hi = h^-
The proof of the second assertion is similar to that of Theorem 5.38. 
□
Consider now the discrete logarithm problem
P = Qp(modF), (P,F) = (Q,F) = 1,
where P.Q.F E Z/pZ[rr], degF = N > 2, and F is monic. Let
F = F(z) = fi(x) • • • fs(x\ s > 2,
where the fj(x) are distinct monic irreducible polynomials from Z/pZ[rr] with 
deg/j =nj.
Clearly, P = Qy (mod F) if and only if P = Qy (mod /?(#)), j = 1,..., s. Let 
xj be the order of Q (mod fj(xf). The equation P = Qy (mod fj(xf) has a solution 
if and only if the order of P (mod fj (#)) divides xj. In that case there is yj (mod x^) 
such that P = Qyj (mod fj(xf). To verify the solvability of P = Qy (mod F), we 
need to verify the solvability of the system y = yj (mod xj), j = 1,..., s. This 
system has a solution if and only if yi = yj (mod x^-) for all i =4 j, where x^- = 
(xi,xj). If the Mij are small, then yi (mod x^) can be determined by running 
through the congruences
(mod
and checking that yi = yj (mod x^). Thus, we have described an algorithm for 
verifying the solvability of the equation P = Qy (mod F), which will be fast in some 
cases. For example, if p is small and the numbers are relatively prime, then, by 
Lemma 5.35, all the x^ are at most p — 1, and the verification will be fast. Notice 
that to determine the orders of the elements, we need to know the factorizations of 
the numbers pni — 1.

5.7. SUMMARY
113
Remark 5.41. For an arbitrary irreducible polynomial F(x) e Z/pZ[rr], one 
can describe a similar algorithm that would verify the solvability in the case when 
the multiplicities of the irreducible factors of F(x) are small.
5.7. Summary
Among earlier works on the discrete logarithm problem the reader may want 
to consult [102, 291, 103].
We also recommend the surveys [197, 159, 48, 196].
In [5], the reader will find an excellent survey on the complexity of number- 
theoretic algorithms, including the discrete logarithm problem.
Complexity estimates for the discrete logarithm problem are considered in [191, 
190, 211, 155, 242, 243, 123]. In particular, in [123], there is a lower bound on 
the order of a linear recurrence sequence Uj such that loga j = Uj (mod p) for all 
indices j from some interval.
A survey of the algorithms for the discrete logarithm problem in an arbitrary 
group G with complexity OdGl1/2) group operations can be found in [256]. See 
also [184].
The book [99] deals with parallel computation of discrete logarithms.
In [47], one finds a discussion of the discrete logarithm problem in an arbitrary 
finite abelian group G, as well as algorithms for finding the order of an element 
and determining the structure of G. In particular, the following theorem is proved 
there.
Theorem 5.42. There is an algorithm which, for given g,deG, d/1, deter­
mines whether d belongs to the subgroup (g), and if this is the case, finds log^ d. If 
x = |(p)| when d £ (g) and x = log^ d when de (g), then the algorithm performs 
at most 6 |’v/S"| + flog2 multiplications in G. It uses a table of at most 2 |’v/S"| 
pairs (h,r) e G x {1,..., 2y/x}. The total number of calls to the table is at most
In [344], one finds a general algorithm for computation of discrete logarithm 
in a finite group of a known order, provided there is a smoothness concept in it. 
The algorithm is probabilistic; in a number of cases (for example, for the ideal class 
group of an imaginary quadratic field) it has a subexponential complexity.
An estimate for the smallest primitive root a for a prime modulus p is obtained 
in [239]. Assuming the Extended Riemann Hypothesis,
a = O(r4(logr + l)4(logp)2),
where r is the number of distinct prime factors of p — 1.
A survey of properties of primitive roots can be found in [401]; Artin’s conjec­
ture is given an especially detailed treatment.
Various cryptosystems use the pairs of primes q and p, where p = 2q + 1. 
In particular, such pairs are used for testing algorithms for computing discrete 
logarithms with prime modulus p. In such a case, a primitive root modulo p can 
be found using the following theorem; see [55, pp. 168-170].
Theorem 5.43. Letp,q be prime numbers.
1) If q = 4n + 1 and p = 2q + 1, then 2 is a primitive root modulo p.
2) If q = 4n + 3, p = 2q + 1, then —2 is a primitive root modulo p.

114
5. ALGORITHMS FOR COMPUTING DISCRETE LOGARITHM
Proof. The number a is a primitive root modulo p if and only if the equations
x2 = a (mod p), xq = a (mod p)
have no solutions
If q = 4n + 1, then p = 8n + 3. In that case, the equation x2 = 2 (mod p) 
has no solutions, since (2) = —1. Suppose now that rr4n+1 = 2 (mod p) does 
have a solution. Then xSn+2 = 4 (mod 8n + 3), and, by Fermat’s Little Theorem, 
4 = 1 (mod p). Since p > 3, this is impossible.
If q = 4n + 3, then p = 8n + 7. The equation rr2 = —2 (mod p) has no solutions,
because
Suppose the equation rr4n+3 = — 2 (mod p) has a solution. Then x8n+6 = 4 (mod p), 
and we have a contradiction, similar to the previous case. 
□
For security of bits in the discrete logarithm for an arbitrary finite cyclic group, 
see [427, 366].

CHAPTER 6
Factorization of Polynomials over Finite Fields
6.1. Introduction. A probabilistic algorithm for solving algebraic 
equations in finite fields
In this chapter we consider factorization algorithms for polynomials over finite 
fields as well as some methods for solving algebraic equations in finite fields.
Let p > 2 be a prime number, f(x) 6 GF(p)[rr], deg/(rr) = n > 2. Consider 
the following probabilistic algorithm for solving the equation f(x) = 0 in GF(p).
An algorithm for solving f(x) = 0 in GF(p).
Step 1. Compute
g[x) = gc&(J(x),xp -x) e GF(p)[x].
Notice that the roots of f(x) in GF(p) are roots of g(x) of multiplicity 1, and that 
g(x) has no other roots. If deg <7(2) = 0, then f(x) has no roots in GF(p). If 
deg <7(2) = 1, then g(x) = x - a and a is the only root of f(x) in GF(p) (not 
counting multiplicity). If deg <7(2) = p, then all the elements of GF(p) are roots 
of f(x). We now assume that 2 < deg g(x) < p and seek the roots of g(x) in GF(p).
Step 2. Randomly choose an element 6 e GF(p) and compute
d(x) = gcd((z + 
- 1, g(x)j.
Step 3. If d(x) = 1 or d(x) = g(x), then return to Step 2. If degd(rr) = 1, 
d(x) = x — b, then & is a root of /(a?); we enter it in the list of found roots, replace 
<7(2) by g(x)/(x — and return to Step 2. Similarly, when deg d(x) = deg g(x) — 1, 
we find x — b = enter b in the list of roots, replace g(x) by d(rr), and return 
to Step 2. If 2 < degd(rr) < deg <7(2) — 1, then, instead of p(rr), we consider its 
factors d(x) and g(x)/d(x) and apply Steps 2 and 3 to them to find their roots.
End of algorithm.
Theorem 6.1 . If g(x) e GF(p)[rr], 2 < deg <7(2) < p, and g(x) \xp - x, then, 
with a random choice of 6 in Step 2, the inequality 1 < deg d(x) < deg g(x) holds 
with probability at least | 
.
Proof. Let ai, a2 e GF(p), ai =4 a2, g(a>i) = gfaz) = 0- Assume that 6 =4 -ai 
and 6 =4 — a2. Then
p-i 
(fli + 3) 2 — 1 equals 0 or —2 when i = 1,2.
If
(ai + J)^ -l/(a2+5)£ii -1,
115

116
6. FACTORIZATION OF POLYNOMIALS OVER FINITE FIELDS
then exactly one of the numbers ai, a2 is a root of d(x) and therefore 1 < deg d(x) < 
degp(rr). Now assume that 6 / —ai, — a2 and
(ai+5)^ -l = (a2+5)^ -1.
Such 6 are roots of the polynomial (x + ai) 2 — (x + a2) 2 , which is of degree 
— 1. Therefore, if we examine all 6 G GF(p), then for at most 2 + ^=1 -1 = 
elements 6 the polynomial d(x) will not satisfy the inequality 1 < degd(rr) < 
degp(rr). This implies the assertion of the theorem. 
□
Theorem 6.2 
. Under the assumptions of Theorem 6.1, let k be the degree of 
g(x). Then the probability will be 1 — 
+ O(^=), where the constant in O(-)
depends on k.
Lemma 6.3. Let g(x) = H?=i(x ~ 
where the ai e GF(p) are distinct. Let
61,..., be a fixed set consisting of ±1. Consider the 6 such that
(
a, “F S \
------- ) = i = 1,..., k.
P 7
Then the number of such 6 equals N = 
+ O(y/p), where the constant in O(-)
depends on k.
We deduce Theorem 6.2 from the lemma. Let 0 < 6 < p — 1, 5 / —a*, 
i = 1,..., k. Suppose degd(rr) = 0. Then
(ui + 5)^ -1/0, i = l,...,fc.
Therefore,
+ J)*2” = -1, i = 1,..., fc,
i.e., 6i = • • • = 6^ = —1. Consider now the case degd(rr) = k. Then, in a similar 
way, we have
(a* + 5)^” =1, i = 1,..., fc,
and therefore 6i = • • • = 6& = 1. Thus, among all values of 5, the number of 5 such 
that 1 < degd(rr) < k will be, by the lemma, p - k - 2(^- + O(y/pf). This implies 
the assertion of Theorem 6.2.
Proof of the lemma. Let a be a fixed quadratic nonresidue modulo p. Set 
di = a if 6i = — 1 and di = 1 if 6* = 1. Consider the system
yj = d±(x + ai) (modp), 
< ........................................
,y2k = dk(x + ak)(modp),
in unknowns rr, pi,..., yk G Z/pZ. For the sake of brevity, let y(d) = (|). The 
equation y2 = d (mod p) has 1 + y(d) solutions. Therefore the number of solutions 

6.1. SOLVING EQUATIONS IN FINITE FIELDS
117
of the system equals
p-l k
+ x(di(x + ai)))
x=0 i=l
p-l
= 52 
12 x(.di(x + a!))11 ■ ■ ■ x(.dk(x + ak))lk
®=0(i,...,(fc€{0,l}
p-l
=?+ 12 52x(#(aj))>
i=Gi,-A); 1=0 
I/O
where = (di(x + fli))Z1 • • • (dk(% + ^k))lk- We have the inequality (see [153, 
Theorem 5.41])
p-i
52%(sr(®))
x=0
< (deg#(a:) - l)^/p,
which follows from estimates of Weil’s trigonometric sums. This yields
\M-p\ < ^2 (*) (r - 1)a/P,
r=2 ' '
because if deg#(z) = 1, then ^(^(^)) = 0- As
_ m = k\ (r - 1) 
k\ = (k - 1\
1 
r.’(fc-r)! 
(r-l).’(fc-r)! 
\r-V’
we have \M — p\ < fcx/^(2fe-1 — 1).
Suppose 6 satisfies the condition of the lemma. Then 
fife . 
\\ 
/ di(5 + &i)\ 
( 
1
X(di(5 + cbi)) = ------------ ) = — U = 1,
\ p / \pJ
by the definition of di. Therefore each equation y? = di(6 + a*) (mod p) has two 
solutions. Consequently, when x = 5, the system has 2k solutions. Therefore,
M = 2kN + Nu
where TVi is the number of solutions corresponding to those 6 which do not satisfy 
the condition of the lemma. If 5 =4 —a; for i = 1,..., fc, but (^z^i) = —ti for 
some z, then (^kf^dll) = (^-)(—e*) = _and the system has no solutions when 
x = 6. If 5 = —a>i for some z, then, for x = 5, the system has at most 2k solutions. 
Therefore M < k • 2k and
|2fc • N - p\ < \M - p\ + 12kN - M\ < ky/p^-1 - 1) + k • 2k.
This implies the assertion of Lemma 6.3. 
□
We should briefly mention other methods for finding roots of polynomials over 
finite fields. They are described in [153, Ch. 4, §3]. If the finite field GF(q) is 
large but its characteristic p is small, then, for q = pm, one should compute the 
polynomial S(x) = 
and try to find the roots of f(x) by computing either
gcd(/(z), S(z) - c), c G GF(p),

118
6. FACTORIZATION OF POLYNOMIALS OVER FINITE FIELDS
or
gcd(/(z), S(JPx) - c), c G GF(p),
where /3 G GF(q) is such that l,/3,... i/3Tn~1 is a basis of GF(q) as a linear space 
over GF(p). If both the field GF(q) and its characteristic p are large, then for 
f(x) = 
we construct the polynomials
n
fc = 
1.
j=o
Then we find a factorization F(x) = Gi(rr) • • • Gr(x) of F(x) = 
€
GF(p)[rr] in GF(p)[rr] as a product of powers of irreducible polynomials and try to 
find the roots of f(x) by computing gcd(/(rr), Gt(x)\ t = 1,..., r.
This finishes the discussion of methods for computing the roots of arbitrary 
polynomials over GF(g). In the next section we will be solving quadratic equations 
in finite fields.
6.2. Solving quadratic equations
Consider the equation
(6.1) 
x2 = a (modp),
where p > 2 is a prime number. Using the obvious change of variable, an arbitrary 
equation AX2 + BX + C = 0 (mod p) can be reduced to (6.1). If a 0 (mod p), 
then equation (6.1) has a solution if and only if (-) = 1, i.e.,
(6.2) 
^(p-1)/2 = 1 (mod p).
Suppose p = 3 (mod 4), i.e., p = 4fc + 3. Then = 2k + 1, and (6.2) implies 
that a2fc+1 = 1 (mod p). Thus a2fc+2 = a (modp), and we have a solution of (6.1):
x = ±afe+1 (mod p).
Suppose p = 1 (mod 4), p = 4fc + 1. Then = 2fc, and (6.2) becomes
(6.3) 
a2,8* = 1 (modp),
where 2k = 2sti s > 1, and t is odd. To solve (6.1), we need to know some quadratic 
nonresidue N modulo p. For N we must have
-!=(—} = N2k = Nrt (mod p).
Now we extract square roots. It follows from (6.3) that
a2,3 * = ±l(modp).
If a2,8 
= +1 (mod p), we extract the square root again; if a2,8 
= —1 (mod p),
then a2,8 * • N28* = 1 (modp), and we extract the square root of the left-hand side 
of the equation. Continuing this process of extracting square roots and multiplying 
by N28t = —1 (mod p) if, after extracting a square root, —1 (mod p) appears, we 
will eventually have
a* • N21 = 1 (mod p)
for some I G Z>o. Thus (a^+1)/27Vz)2 = a (mod p), and we find x = ±a^+1)/27Vz 
(modp), a solution of (6.1).

6.2. SOLVING QUADRATIC EQUATIONS
119
Remark 6.4. Randomly choosing N from the set {1,2, ...,p — 1}, we find 
a nonresidue with probability An estimate on the magnitude of the smallest 
quadratic residue modulo p was given in 1.6 (assuming the Extended Riemann 
Hypothesis). For some values of p = 1 (mod 4) a nonresidue N is known a priori. 
For example, N = 2 when p = 5 (mod 8).
A somewhat more efficient method for solving (6.1) in the case p = 1 (mod 4) 
is provided by the Shanks-Tonelli algorithm. In it we keep the notation p — 1 = 
4fc = 2s+1 • t = 2C • t and N will be some known quadratic nonresidue modulo p. 
We assume that (^) = +1.
The Shanks-Tonelli algorithm.
Step 1. Compute the following:
y := TV* (mod p), r := e, x := a^*-1^2 (mod p), 
b := ax2 (mod p), x := ax (mod p).
Step 2. If b = 1 (mod p), then x is a solution of (6.1), and the algorithm 
terminates.
Step 3. Find the least m G N such that b2™ = 1 (mod p). Then 1 < m < r — 1.
Step 4. Compute the following:
l\=y2 m ^modp), y := Z2, r := m 
x := xl (mod p), b := by (mod p)
and return to Step 2.
End of algorithm.
We now show that the algorithm is correct. We want to find numbers Ai,..., 
Ae-i equal to 0 or 1 and such that
at. jVt(A1.2+A2.22+...+Ac_1.2e-1) = x (mod py
The numbers Ai,..., Ae_i will be defined by induction. In Step 1
5 = a* (modp), x = a^*+1^2 (mod p), r = e.
In Step 3 we find m such that b2™ = a*'2™ = 1 (mod p), b2™ 1 = a*'2™ 1 = 
—1 (modp), and, by (6.2), m <r — 1 = e — 1. Then we set Ai = • • • = Ae_m_i = 0, 
Ae-m = 1, and have
a2^t . 
x (mod p)>
where j = e — m + 1. In Step 4 we compute
I = 7V*-2r"m"1 = NV23~2, y = TV*'2^”1, r = m = e - j + 1,
x = a^~ • yv*^1+’“+Ae_rn2e m (modp), 
b = a* • 7V*(2A1+-+^-m2e“m) (mod
If b = 1 (mod p), then x is clearly a solution of (6.1). If b 1 (mod p), then the 
algorithm continues.
Suppose that after several runs of Steps 2-4 we have numbers j > 2 and 
Ai,..., Aj-i G {0; 1} such that A^-i = 1 and the following induction assumption 

120
6. FACTORIZATION OF POLYNOMIALS OVER FINITE FIELDS
holds:
a2e-J.tyV-t(Ai2e-j+1+--+Aj_i2e-1) = l(modp),
x = 
2)(modp),
b = at7Vf(A1’2+" +Aj-12J”1) (mod p),
I = 7Vt2J 2} y = Nt23 \ r = e-J + l.
If j = e, then we have determined all Ai,..., Ae_i, and x will be a solution. If 
j < e, but b = 1 (mod p), then x is also a solution and the algorithm terminates. 
If j < e and b 1 (mod p), then during the next run of Steps 2-4 we find the next 
value f and the numbers Aj = Aj+i = • • • = Aj/-i = 0, Ay = 1, such that
fl2e 3 
3 +14----+AJ/_12e x) =i(mo(ip).
Notice that the formulas expressing rr, 6, Z, p, r in terms of /, Ai,..., Ay-i do not 
change. By induction, we have proved the correctness of the Shanks-Tonelli algo­
rithm.
Remark 6.5. The Shanks-Tonelli algorithm is described in [57, Ch. 1]; see 
also [22, Ch. 7]. It is of polynomial complexity, provided we know a nonresidue N.
Remark 6.6. In [232], one finds an algorithm for solving (6.1) with bit­
complexity O(|a| 1/2+e(logp)9). The knowledge of a nonresidue is not assumed. 
For a fixed a e Z, the algorithm is of polynomial complexity in the variable p.
Remark 6.7. [22, Ch. 7] contains a description of Cippola’s probabilistic al­
gorithm for solving x2 = a in a finite field GF(q) with odd q. The algorithm has 
an average running time of O(log3 q) bit operations.
Consider now the equation
(6.4) 
xN = a (modp),
where p is a prime number and N e N, N > 2. If (N,p — 1) = 1, then the solution 
of this equation is of the form x = aM (mod p), where NM = 1 (mod p — 1). Some 
methods for solving (6.4) when (7V,p - 1) > 1 can be found in [281, 6] and [22, 
Ch. 7]. See also [444, 403].
If we want to solve £2 = a (mod n), where n = pg, and p, q are distinct 
primes, then solving this equation will be a difficult problem unless we know the 
factorization of n. A number of cryptosystems is based on this observation; see [16, 
Ch. 3, 4].
If n e N, then to find m = [0i] one can use the following algorithm, described 
in [57, Ch. 1].
Algorithm.
Step 1. x := n.
Step 2. Using integer division and shifts (division by 2), compute
Step 3. If y < x, then set x := y and return to Step 2. Else, x is the desired 
value of [-\/^]-
End of algorithm.

6.3. THE BERLEKAMP ALGORITHM
121
We now show that the algorithm is correct. If t > 0, then
Therefore x > [v^, since the inequality x + 
> 2y/n implies that x + [^] >
[2y/n] > 2[y/n]. Suppose we have y > x in Step 3. We want to show that x = [\/n]. 
Assuming that x > 
+ 1, we come to a contradiction. Indeed,
<0,
because x > y/n and [^] < 
< y/n, i.e., [^] - x < [0i] - [0i] - 1 = -1.
Using this algorithm, one can solve the equation x2 = n, n G N, in integers. 
Before extracting the square root of n, one should check if n is a quadratic residue 
relative to several small moduli; see [57, Ch. 1].
For computing square roots in finite fields, see also [411, 371, 372, 300, 418].
In [306], one finds a survey of algorithms for computing square roots in finite 
fields. The paper also contains an algorithm with a reduced number of multiplica­
tions.
Some issues related to computing square roots in finite abelian groups are 
considered in [335].
6.3. The Berlekamp algorithm
Let p be a prime number and q = pm. In this section we shall describe the 
Berlekamp algorithm (see [27], [153, Ch. 4], and [26]) for factoring a monic poly­
nomial f(x) e. GF(g)[#]. Let deg/(rr) = n > 2, and let
(6.5) 
/(x) = /i(:E)ei---AMefc
be a factorization of /(#), where /i(rr),..., /&(#) are distinct irreducible monic 
polynomials. First we show how finding factorization (6.5) can be reduced to finding 
a factorization of a polynomial
(6.6) 
f(x) = fi^x)- •• fii(x), 1 < zi < i2 < ••• < ii < z,
without repeated irreducible factors. To this end consider
d(x) = gcd(/(a:),/'(a:)).
If f'(x) is the zero polynomial, then f(x) = go(xp), where go(y) G GF(q)[y]. 
Since exponentiation to the power p is an automorphism of GF(g), and since 
(A + B)p = Ap + Bp for all A, B G GF(g)[rr], we have f(x) = ^o(^p) = (<7(#))p, 
and the factorization problem for f(x) reduces to that for g(x), which has a lower 
degree. The coefficients of g(x) can quickly be found from the coefficients of f(x) 
if GF(q) is not too large and m > 1. If q = p (i.e., m = 1), then g(x) = #o(£), 
because ap = a for all a G GF(p).
Suppose now that /'(#) is a nonzero polynomial. Then, obviously,
d(rr) = /1(o;r
where Vi = e* — 1 if p | e*, and Vi = e* if p | e;. Moreover, Vi =4 e; for some i. 
Then the polynomial f(x) = f[x)/d{x') equals the product of those polynomials 
/i(rr),... ,/fc(rr) for which p | e*. If we factor f(x) into a product of irreducible 
polynomials, then, using trial divisions, we can find the exponents e* such that 

122
6. FACTORIZATION OF POLYNOMIALS OVER FINITE FIELDS
p | ei. Now compute /(aO/fL: p\ei The derivative of this polynomial is 
zero. If this polynomial is not a constant, we can represent it in the form £(#)p, as 
described above, and then factor g(x) in a similar way, etc.
Remark 6.8. In [57, Ch. 3, Algorithm 3.4.2], one finds an algorithm which 
represents a monic polynomial f(x) e Z/pZ[rr] in the form f(x) = Hi>i 
where Ai(x) G Z/pZ[rr], the Ai do not have repeated irreducible factors, and 
(A(4 Aj(x)) = 1 when i / j.
Henceforth we shall assume that all the exponents e* in (6.5) equal 1.
Theorem 6.9. Let h(x) G GF(g)[rr], 1 < deg/i(rr) < n, and suppose that 
h(x)q = h(x) (mod f(xf).
Then
(6-7) 
/(®) = J} gcd(/(a:), A(or) - c).
cgGF(q)
Moreover, the right-hand side of this equality is a nontrivial factorization of f(x) 
into relatively prime factors.
Proof. For ci, c2 G GF(g), ci =4 c2, the polynomials h(x) — ci and h(x) — c2 
are relatively prime. Hence the factors in the right-hand side of (6.7) are relatively 
prime. Since deg(/i(rr) — c) < n, we see that if (6.7) holds, then this is a nontrivial 
factorization of f(x) (i.e., (6.7) is a factorization of f(x) into several polynomials 
of smaller degrees). That (6.7) is true follows from the facts that h(x)q — h(x) = 
IIcGGF(q)(^(rr) “ c) = 0(mod /(^)) and the polynomials h(x) — c are relatively 
prime for distinct values of c G GF(q). 
□
Definition 6.10. A polynomial h(x) G GF(g)[rr] such that 1 < deg/i(rr) < n 
and h(x)q = h(x) (mod f(xf) is called an /-factoring polynomial.
It follows from Theorem 6.9 that if we construct an /-factoring polynomial, 
then using it, we can factor /(#) into a product of at least two factors. We shall 
now describe a procedure for constructing such polynomials.
Theorem 6.11. Define a matrix B = \\bij 
1 by the congruences
n—1
xzq = bijXz (mod /(#)), i = 0,..., n - 1. 
J=o
A polynomial h(x) = oq + ai# H------ 1- an_i£n-1 G GF(g)[rr] satisfies the condition
h(x)q = h(x) (mod /(rr)) if and only if
(uo> • • • > ^n—1)F = (&0, • • • , O"n— 1),
i.e., if and only if the vector of its coefficients is a left eigenvector of B with eigen­
value 1.
Proof. The condition h(x)q = h(x) (mod /(#)) is equivalent to the condition
n— 1 
n— 1
^2 
(m°d ft??)-
i=0 
i=0

6.3. THE BERLEKAMP ALGORITHM
123
By the definition of B, we have 
n— 1 n— 1 
n— 1
bijxi = aiX , 
i=0 
j=0 
i=0
and therefore 
n— 1
bij = cbj, j = 0,..., n — 1, 
i=0
which is equivalent to the assertion of the theorem. 
□
The Berlekamp algorithm.
The input of the algorithm consists of a monic polynomial f(x) e GF(g)[rr], 
deg/(rr) = n > 2, which has no repeated irreducible factors. The output is the 
factorization of f(x) into irreducible factors.
Step 1. Compute the matrix B of Theorem 6.11.
Step 2. Find a basis for the solution space of the system of linear equations 
(z0 \ 
... 1=0, 
#n—1/
where B\ = (B — In)T, In is the identity matrix, and the symbol (*)T denotes the 
transpose. Let eq = (1,0,..., 0), 62, • • • , ^k be the found basis.
Remark 6.12. As xzq = 1 (mod f(xf) when i = 0, the first row of B is always 
of the form (1,0,..., 0), and the first column of Bi will consist of zeros. Therefore 
eq = (1,0,..., 0) will always be in the basis of the solution space.
Step 3. When k = 1, the polynomial f(x) is irreducible. In general, k 
equals the number of irreducible factors f(x) in GF(g)[#]. When k > 1, set eq = 
(^2,o> • • • > ^2,n-i) and construct an /-factoring polynomial h2(x) =
Using it together with Theorem 6.9, i.e., computing gcd(/(rr),h2(x) — c) with 
c e GF(q), find a factorization
/(®) = 51 (a:)- • -gi(x),
where gi(x) € GF(g)[rr], I > 2. If I = fc, then the algorithm terminates. If I < fc, 
then set eq = (^3,0, • • •, ^3,n-i) and construct hz(x) = ^Lq1 h^x1. Computing 
gcd(^(rr), h$(x) — c) for the found gi(x), we have a further factorization of f(x), etc. 
The algorithm terminates when we have run through all basis vectors e2> • • • , ^k and 
computed the greatest common divisors of the found factors of f(x) and hi(x) — c, 
c e GF(q) for the corresponding polynomials hi(x).
Remark 6.13. The algorithm terminates when we find a factorization of /(#) 
into k factors, where k = n — rank Bi.
End of algorithm.
Theorem 6.14. The Berlekamp algorithm is correct and finds the complete 
factorization of f(x).
Proof. Since f(x) = /i(&) • • • fk(x) is a product of distinct irreducible monic 
polynomials, the Chinese Remainder Theorem shows that for any set eq,..., Ck E 

124
6. FACTORIZATION OF POLYNOMIALS OVER FINITE FIELDS
GF(q) there exists a unique polynomial h(x) e GF(g)[rr] such that h(x) = Ci 
(mod /i(rr)), i = 1,..., fc, deg/i(rr) < n. Moreover,
h(x)q = cl = Ci = h(x) (mod /i(z)), i = 1,..., fc,
and therefore h(x) is /-factoring. Conversely, for any /-factoring polynomial h(x) 
we have
hq(x) - h(x) = JJ (/&(#) - c) = 0 (mod /(rr)),
ceGF(q)
and therefore for each fi(x) there is c = Ci such that h(x) = Ci (mod fi(x)). Thus, 
we have a one-to-one correspondence between /-factoring polynomials h(x) and the 
sets Ci,..., Cfc G GF(q). By Theorem 6.11, the coefficient vector (/i0,..., of 
h(x) is a solution of system (6.8). Hence the rank of Bi equals n - fc, and the 
solution space is fc-dimensional. Let /ii(rr),..., hk(x) be /-factoring polynomials 
whose coefficient vectors form a basis of the solution space of (6.8). We assume 
that hi(x) = 1. Let /;(#) and fj(x) be irreducible factors of /(rr), i =4 j. We want 
to show that there is an index u, 2 < u < k, and a constant c G GF(q) such that
hu(x) = c(mod /i(rr)), hu(x) c(mod fj(xf).
Assume the opposite, i.e., for all u = 2,..., k and for some cu e GF(q) we have 
hu(x) = cu (mod fi(x) • fj(x)). The same is true for u = 1 because hi(x) = 1 = ci. 
But then, since any /-factoring polynomial h(x) is a linear combination over GF(q) 
of the polynomials /ii(rr),..., /^(rr), we have
h(x) = c(mod /i(rr) • /j(z)),
where c G GF(q) depends on h(x). But there is an /-factoring polynomial h(x) 
such that
h(x) = 0 (mod /;(#)), h(x) = 1 (mod fj(xf).
The obtained contradiction finishes the proof of the theorem and thus shows that 
the Berlekamp algorithm is correct. 
□
Remark 6.15. The complexity of the algorithm is O(n3 + qkn2) arithmetic 
operations (see [70, p. 191]). For this reason, the algorithm will be efficient only for 
relatively small values of q (in particular, because of running through the c e GF(q) 
in Step 3 of the algorithm), i.e., for small fields.
In the subsequent sections, we consider a number of improvements of the 
Berlekamp algorithm, as well as of the factorization methods in the case of large 
fields GF(q).
We also mention two results related to factorization of polynomials in GF(g)[#]. 
The following result in [180] allows one to determine the parity of the number of 
irreducible factors of f(%)-
Theorem 6.16. Letp be a prime number, f(x) G Z/pZ[rr], deg/(rr) = n < p. 
Let D be the discriminant of f(x), w the number of irreducible factors of f(x), and 
suppose p\D. Then (^) = (-l)n-w.
The other result on /-factoring polynomials can be found in [153, Th. 4.3].

6.4. THE CANTOR-ZASSENHAUS METHOD
125
Theorem 6.17. Let f(x) G GF(g)[rr] be a monic polynomial, and f(x) = 
fi(x) * *' fk(x) the factorization of f(x) into distinct irreducible monic polynomials, 
where k>2. Let deg/i(rr) = ni, i = 1,... ,k, and N = 1cm (ni,... , n^). Set
T(x) = x + xq + xq2 H-------1- xqN 1,
and define the polynomials Ti(x) G GF(q)[x\:
Ti(x) = T(rr2) (mod /(#)), degTi(rr) < n, i = 1,2,... .
Then at least one of the polynomials 7i (#),..., Tn_i(rr) is f-factoring.
6.4. The Cantor-Zassenhaus method
Fix a prime number p. Let f(x) G Z/pZ[rr] and suppose f(x) is monic and has 
no repeated irreducible factors. In what follows, we describe an algorithm which, 
for a given d G N, finds the product of all irreducible factors of f(x) of degree d. 
First we need a lemma.
Lemma 6.18. Let g(x) e Z/pZ[rr] be a monic irreducible polynomial.
1. If deg g(x) = d, then g(x) divides xp — x.
2. If g(x) divides xp — x and does not divide xpe — x for any e < d, then 
deg^(rr) = d.
Proof. The first assertion follows from the facts that K = Z/pZ[rr]/(^(rr)) = 
GF(pd) and that xp = x for x = x (mod g(xf) G K. To prove the other assertion, 
let I = deg 0(2) and Ki = GF(pl) = Z/pZ[rr]/(^(rr)). Since xpl = 2 (mod g(xf), 
it follows from the assumption that I > d. On the other hand, for an arbitrary 
polynomial f(x) e Z/pZ[rr], we have
(6.9) 
f(x)pd = f(xpd) = f(x) (mod g(x)).
Since KJ is a cyclic group of order pl — 1 and is generated by f(x) (mod g(xf) for 
some f(x) e Z/pZ[rr], (6.9) implies that pl — 1 | pd — 1, i.e., I < d. Therefore I = d, 
which is the desired claim. 
□
We now apply Lemma 6.18. Consider
Bi(z) =gcd(/(z),zp -x).
Clearly, Bi(rr) consists of all irreducible factors of f(x) of degree one. Replacing 
by /i(rr) = /(z)/Bi(z), we compute
2
B2(z) = gcd(/i(z), xp - x).
B2(rr) consists of all the irreducible factors of f(x) of degree two. We set /2(rr) = 
/i(rr)/B2(rr). Continuing this process, we conclude that
Bd(x) = gcd(/d_i(rr),rrpd - x)
consists of all the irreducible factors of f(x) of degree d. We then set fd(x) = 
fd-i(x)/Bd(x), etc.
Remark 6.19. This algorithm for finding the products of all irreducible factors 
of f(x) of a fixed degree can be applied before we apply the Berlekamp algorithm 
to find the factorization of /(#).

126
6. FACTORIZATION OF POLYNOMIALS OVER FINITE FIELDS
Lemma 6.20. Let g(x) G Z/pZ[rr] be a monic polynomial such that deg g(x) = d, 
all irreducible factors ofg(x) have the same degree, and g(x) has no repeated factors. 
Then g(x) is irreducible if and only if xp = x (mod g(xf) and, for any prime q 
dividing d,
gcd (xpd/Q - x,g(x)^ = 1.
Proof. The necessity is obvious. To prove the sufficiency, assume that g(x) 
is reducible and has an irreducible factor <7i(rr), deg^i(rr) = I < d. Then gi (#) | 
xp — x. Moreover, by assumption, I | d, I = d/k. If k is prime, then we have a 
contradiction with the assumption of the lemma. If k = qr, where r > 2, and q 
is prime, then we also have a contradiction, because gi(x) | xp — x | xp — x = 
xdIq — x. 
□
Henceforth we shall assume that f(x) e Z/pZ[rr], f(x) is square-free, that all of 
its irreducible factors have the same degree d, and that we know that degree. We 
can now describe the Cantor-Zassenhaus method for factorization of f(x) (see [50]). 
We need to consider the cases p = 2 and p > 2.
Theorem 6.21. If p > 2, then for any polynomial T = T(rr) G Z/pZ[rr] we 
have
f(x) = gcd(/(a:),T)gcd(/(a:),T(p<i-1^2 + 1) gcd(/(a;),T’^p<i-1^2 - 1).
Proof. All elements of GF(pd) are roots of the polynomial xpd — x. Let 
T = T(x) G Z/pZ[x]. Then T(x)pd - T(x) = T(xpd') - T(x) is divisible by a/ - x. 
Lemma 6.18 implies that f(x) divides Tp“ - T = T(T^d~^l2 - l)^4"1)/2 + 1). 
Notice that since p > 2, the polynomials T, T^pd~1^2 — 1, and T1^4-1)/2 +1 are 
relatively prime. 
□
Remark 6.22. One can prove that, for a randomly chosen polynomial T G 
Z/pZ[rr] such that degT < 2d — 1, D = gcd(/(rr),T^pd-1)/2 — 1) is nontrivial with 
probability close to 1/2; see [57, Ch. 3, §3.4.4]. The Cantor-Zassenhaus method 
for factoring f(x) consists of randomly selecting T and computing D. If degZ) = 0 
or degZ) = deg/(rr), then we choose another polynomial T; otherwise we factor D 
and f(x)/D using the same method. The found factors of f(x) of degree d are 
irreducible by construction.
Now consider the case p = 2.
Theorem 6.23. Let p = 2 and U(x) = x + x2 + x4 + • • • + x2d 1 G Z/2Z[rr]. 
Then, for any polynomial T = T(rr) G Z/2Z[rr], we have
= gcd(/(ar), U(T)) gcd(/(x), U(T) + 1).
Proof. Since
U(T) = T + T2 + --- + T2d~\
U(T)2 = U(T2) = T2 + T4 + • • • + T2", 
we have
U(T) + 17(T)2 = T2d + T = T2“ - T.
The rest of the argument is similar to the proof of Theorem 6.21. 
□

6.5. SOME OTHER IMPROVEMENTS OF THE BERLEKAMP ALGORITHM
127
As in the case p > 2, one can prove that, for a randomly chosen polyno­
mial T = T(x) with degT < 2d — 1, the greatest common divisor of f(x) and 
t/(T) will be nontrivial with probability close to |. One can also choose T(x) 
among the powers rr, rr3,..., rr2d-1, i.e., for some odd j, 1 < j < 2d — 1, the great­
est common divisor of U(xi) and f(x) will be nontrivial with probability close 
to |. To prove this, assume the opposite, i.e., for any odd j, 1 < j < 2d — 1, 
either U(xi) = 0(mod /(#)) or U(xj = 1 (mod /(#)) (by Theorem 6.23). Theo­
rem 6.23 also implies that U(T2) = U(T)2 = t/(T) (mod /(#)). Thus, for all j, 
1 < j < 2d — 1, we have either C7(rrJ) = 0(mod /(#)) or U(x^) = 1 (mod /(#)). 
Since U(Ti + T2) = U(Ti) + t/(T2), we have that for any polynomial H = H(x) G 
Z/2Z[rr] with degB’(rr) < 2d - 1, one of the congruences U(H) = 0 (mod f(x\) or 
U(H) = 1 (mod /(#)) holds. Since we assume that deg/(rr) > d (if deg/(rr) = d, 
then f(x) is irreducible), f(x) has two distinct irreducible factors /i(a?) and /2(rr), 
with deg/i(rr) = deg/2(rr) = d. Let a be a root of /2(:r) in GF(2d). Since 
/2(rr) is irreducible, GF(2d) = Z/2Z[a]. Since degt/(rr) = 2d-1, there exists 
(3 € GF(2d) with U(J3) 
0. We have /3 = P(ot) for some P(x) e Z/2Z[rr] with
degP(rr) < d — 1. Using the Chinese Remainder Theorem, construct a polyno­
mial T = T(x) G Z/2Z[rr] such that degT(rr) < 2d — 1, T(x) = 0(mod /i(rr)), 
and T(x) = P(x) (mod /2(z)). Then U(T) = U(0) = 0(mod /i(z)) and U(T) = 
t/(P(rr)) 0(mod /2(rr)), because C7(/3) = t/(P(a)) =4 0. But this contradicts the 
fact that either t/(T) = 0(mod /(#)) or t/(T) = 1 (mod /(#)). This shows that, 
for some odd j, 1 < j < 2d — 1, the greatest common divisor of t/(rrJ) and /(#)) 
will be nontrivial.
6.5. Some other improvements of the Berlekamp algorithm
We now return to the Berlekamp algorithm, described in 6.3. Consider the case 
of a prime field Z/pZ.
Let p be large. Running through c G Z/pZ and computing gcd(/(rr), h(x) — c) 
will be time consuming. We want to determine the set M C Z/pZ consisting of 
those c for which gcd(/(rr), h(x) — c) is nontrivial.
The first approach to finding the set M is based on computing the resultant 
Res (/(#), h(x) — c). The definition and properties of the resultant can be found 
in [261]. If f(x) = ^i=QAiXz G Z/pZ[rr], and h(x) = Y^iLoPi^ Z/pZ[rr], then 
Res (/(#), h(x) — c) is the determinant of the (n + m) x (n + m) matrix
(An An-i ... Ao 0 
............. 0
0 An ... Ai Aq 0 
... 
0
d_  
0 
0 
• • • 
^-n An—i ............. Ao
Pm Pm—i • • • Pq ~ c 0 
............. 0
0 Bm ... Bi Bq — c ............. 0
< 0 
0 
.................... Bm ... Bi Bq — cj
This shows that Res (/(rr), h(x) — c) is a polynomial of degree n in c with coefficients 
in Z/pZ. Its roots are exactly those c for which gcd(/(rr), h(x) — c) is nontrivial. 
Thus to construct M, we find the roots of Res (/(#), h(x) — c), viewing it as a 
polynomial in c which belongs to the field Z/pZ. This can be done, for example, 
by the probabilistic algorithm from 6.1.

128
6. FACTORIZATION OF POLYNOMIALS OVER FINITE FIELDS
Another approach to constructing M was suggested by Zassenhaus. Keeping 
the above notation, we assume in addition that f(x) is monic, m < n, and that 
h(x)p = h(x) (mod /(#)). Then
(6.10) 
/(or) = J} gcd(/(a:), h(x) - c).
cEM
Let G(y) = Uc6m(?/ “ c) e Z/pZ[o:].
Theorem 6.24. The polynomial f (#) divides G(Ji(x\). Moreover, G(y) has a 
minimal degree among all polynomials g(y) e Z/pZ[p] \ {0} such that f(x) divides 
5(/i(a;)).
Proof. Let I be the ideal of Z/pZ[p] consisting of polynomials g(y) such 
that f[x) divides g(h(x)). By definition, G(y) e I. Moreover, the ideal I is prin­
cipal, I = (gQ(y\) for some go(y) 6 Z/pZ[p] \ {0}. The definition of M and (6.10) 
show that M' = M. Since go(y) | G(y), we have go(y) = 
“ c) f°r some
subset Mf C M. 
□
We can apply Theorem 6.24 to find M. Let \M\ = k, the number we do not 
know. Then G(y) = 
where bk = 1. Moreover, m is the least natural
number such that the polynomials 1, h(x),..., h(x)k are linearly dependent over 
Z/pZ modulo f(x). Now we find the coefficient vectors of the polynomials
n— 1
h(x)Q (mod /(#)) = 1 =
>=o 
n—1 
h(x) (mod /(rr)) = hijx\..., 
j=o 
n— 1
h(x)1 (mod f(x)) = hijX3,..., 
j=o
and choose the first index k such that the vector (/^o, • • •, ^fc,n-i) is a linear com­
bination over Z/pZ of (/&o,o,..., /io,n-i), • • •, (^fc-i,o, • • •, ^fc-i,n-i)« This yields
k
bjh(xy = 0 (mod /(#)), bk = 1, 
>=o
with the smallest k. Then we set G(p) = 
The set M consists of all the
roots of G(p). We find those roots, for example, by the probabilistic methods from 
6.1.
Yet another method for factoring a square-free monic polynomial f(x) in 
GF(g)[rr] is described in [153, Ch. 4, §2]. It is based on the diagonalization of 
an efficiently computable, via the Berlekamp algorithm, matrix A. However, the 
diagonalization process itself is rather complicated.
In [111], one finds a probabilistic version of the Berlekamp algorithm. On 
average, it allows for factoring a degree-n polynomial in GF(g)[rr] in
O((nlogn + logg)n(logn)2 log log n) arithmetic operations
in the field GF(q). The algorithm uses Wiedemann’s method for solving a system 
of linear equations over finite fields (see Chapter 11). The Kaltofen-Lobo algorithm 

6.6. IRREDUCIBILITY TESTING OF POLYNOMIALS
129
was implemented on the computer. Polynomials of small degrees (say, less than 250) 
are factored faster by the usual Berlekamp algorithm, if the fields are not too large. 
For polynomials of high degrees the Kaltofen-Lobo algorithm turned out to be 
efficient in some cases. For example, for polynomials of degree 10,001 over the field 
Z/127Z it takes about 102.5 hours on the Sun-4 workstation.
6.6. A probabilistic algorithm for irreducibility testing 
of polynomials over finite fields
Let p be a prime number, p > 2, r G N, r > 1, q = pr, and K = GF(g). 
Let / = f(x) be a fixed monic polynomial in K[rr] with n = deg/(rr) > 2. In this 
section we describe a probabilistic algorithm for irreducibility testing of /(#), which 
is similar to the Miller-Rabin algorithm for primality testing of numbers (see 1.7).
Let qn — 1 = 2k-t, where t is odd, and let R = K[rr]/(/) be a ring of qn elements. 
If f(x) is irreducible, then R is a field, \R* | = qn — 1, and for any a G R \ {0} we 
have aqn~r = a2 * = 1. Extracting the square root, we have
(6.11) either a1 = 1 or af'23 = —1 for some j, 0 < j < k.
For the polynomial /(#), let S denote the set of elements a G R such that (6.11) 
holds.
Theorem 6.25. If f(x) is reducible, then
1 an - 1 
|5| < -|7?*| <
Corollary 6.26. Verifying (6.11) for a randomly chosen a G R, we will de­
termine with high probability that f(x) is reducible. If (6.11) holds for I randomly 
chosen elements a G R, then we may assume that f(x) is irreducible with probability 
at least 1 — .
The proof of the theorem breaks into two cases.
Case 1. Suppose there is an irreducible polynomial g = g(x) G K[rr] such that 
g2 | f. Fix it and let G denote the set
G = (1 + 
(mod f(xf) I /i(z) G K[z], deg/i(z) < deg#).
I #(z) 
I 
J
Lemma 6.27. 
(1) G is a subgroup of R*;
(2) for any h G G \ 1 the order of h equals p;
(3) |G| = qm, where m = deg g(x\
Proof. Since
fl + h\—) fl + 
= 1 + (hi + hi) — (mod /),
v 
gi 
g
the first assertion is obvious. If w G G \ 1 and w = 1 + then wp = (1 + h^)p = 
1 + hpf^^-^ = 1 (mod /). The third assertion of the lemma is also obvious. □
Lemma 6.28. If w G G \ 1, then wS f)S = 0.
Proof. By Lemma 6.27, the order of w equals p, whence wqn-1 =4 1. If 
a G S, then aqn_1 = 1, whence (aw)9”-1 =4 1. Therefore, aw £ S and the claim 
follows. 
□

130
6. FACTORIZATION OF POLYNOMIALS OVER FINITE FIELDS
Lemma 6.29. Let a,b,eG, b. Then aSC\bS = 0.
Proof. aS A bS = 0 if and only if S A a~1bS = 0, which is true by virtue of 
Lemma 6.28. 
□
Lemma 6.30. Let m = deg g. Then
i^i < iwr-
Proof. Let w\ = 1, w2,...,wqm be all the elements of G C R*. Then the sets 
wiS,..., wqmS are contained in R* and do not intersect, by Lemma 6.29. Therefore 
|7?*| >qm\S\. 
□
Lemma 6.30 implies, in our case, Theorem 6.25.
Case 2. Suppose f is square-free, i.e., f = 
where fi are distinct
irreducible polynomials in K[rr] and I > 2.
Let di = deg/i, Ri = K[rr]/(/i) = GF(qdi), i = 1,...,Z. By the Chinese 
Remainder Theorem, R is isomorphic to Ri x • • • x Ri. For an element a e B, let 
ai = a (mod fi) e Ri, i = 1,..., I. If m e N, then am = 1 in R if and only if a™ = 1 
in Ri, i = 1,..., I. Therefore
i 
i
#{a e R I am = 1} = ]J#{a 6 Ri | am = 1} = J] gcd(m, qd‘ - 1), 
i=l i=l
because each R* is a cyclic group of order qdi — 1. Moreover, 
i
#{aeR\am = -1} = T[#{aeRi\am = -1} 
i=l
I
= n(#{° e I a2”1 = 1} - #{a e Ri I am = 1}) 
i=l
I
= JJ(gcd(2m, qdi - 1) - gcd(m,gdi - 1)). 
i=l
Therefore S = Si U S2, where 
1 
S1 = {aeR\at = 1}, |5i| = ]J gcd(t, </*< " 1)> 
i=l
S2 = {a € R | at 2k 3 = —1 for some j, 1 < j < k}, 
k i
|S2| = 
" i) -gcd(i2fe-<^ - 1)).
j=i i=i 
Let
qdi - 1 = 2Cibi, i =
where the bi are odd numbers. Clearly, when e e Z>o, 
gcd(2^,2Ci6i) = 2min<e’Ci) gcd(i,M, 
gcd(2e+1£, 2Cibi) - gcd(2% 2Cibi) = gCd^’ lf e < Ci' 
0 
if e > Ci.

6.7. SUMMARY
131
Therefore, when c = min(ci,..., q) and v = min(c, fc), we have
v—1 I 
is2i= 
j=0i=l
Thus,
|S| = |Sx I + |S2| = nscd(^> M11 + E2lj) = n scd(4> M (i + -oFTt) • 
i=l 
' 
j=0 
' i=l
Furthermore,
gcd(gn - l,gdi - 1) = 2min<fe-cd gcd(*A), 
whence
rTardo m - rr 
-1)
11 ® ( ’ *) 11 Om'nCfc’Ci)
i=l 
i=l
Therefore,
ISI < A + 
1*1 
< 6 + 2w-h|g|
1 1 - V 2! - 1 ) 
■ 
21 - 1 ) 2" •
It is not difficult to see that
because v > 1. Since, by assumption, I > 2, we have |S| < \R*|/2. Theorem 6.25 is 
proved.
Remark 6.31. In some situations, the following method (see [69]) is efficient 
for irreducibility testing of polynomials over a finite prime field. Let p be a prime 
number, f(x) e Z/pZ[rr], deg/(rr) = n. The polynomial f(x) is irreducible if and 
only if for any fc, 1 < k < n/2,
Ic 
(6-12) 
gcd(/(z),zp - x) = 1.
Indeed, if f(x) is reducible, then it has an irreducible factor g(x), deg <7(2) = k < 
n/2. All roots of g(x) are in GF(pfe) and therefore are roots of xp — x. Thus, for 
k = deg <7(2), condition (6.12) does not hold. If /(#) is irreducible, then its roots 
will not be roots of xp — x for k < n. Thus the irreducibility test for f(x) is the 
verification of condition (6.12) for all k < n/2.
6.7. Summary
An excellent survey of factorization methods for polynomials over finite fields 
is contained in [153, Ch. 4, Summary]. There is also a survey there of various 
methods of implementation of arithmetic in finite fields, arithmetic of polynomials 
over finite fields, and methods of solving equations in finite fields.
Several algorithms for implementation of polynomial arithmetic over finite fields 
and over the integers, as well as factorization algorithms for polynomials, can be 
found in [57, Ch. 3].

132
6. FACTORIZATION OF POLYNOMIALS OVER FINITE FIELDS
A number of useful facts about factorization of polynomials over finite fields 
and solving algebraic equations in GF(q) are contained in [22, Ch. 7]. This also 
describes a deterministic method for finding an irreducible polynomial over a fi­
nite field (which is of polynomial complexity, assuming the Extended Riemann 
Hypothesis), as well as a method of solving cubic equations in GF(q) in O(log4g) 
bit operations (also assuming the Extended Riemann Hypothesis). This book also 
contains an excellent survey of results on factorization of polynomials and solving 
algebraic equations in finite fields.
A new algorithmic technique geared toward the Cantor-Zassenhaus algorithm 
is developed in [271]. On average, it allows one to factor a polynomial in GF(g)[rr] 
that is a product of distinct irreducible polynomials of the same degree, in
O(n(w+1)/2+o(1) + n1+o(1) log?)
operations in GF(g); here w is the exponent in the complexity estimate for mul­
tiplication of square matrices. A similar result was obtained in [114]: for any /?, 
0 < /3 < 1 there is a probabilistic factorization algorithm for a degree n polynomial 
in GF(g)[rr] requiring on average
0(n(w+i)/2+(i-/?)(w-i)/2 + ni+/?+o(i) log
arithmetic operations in GF(q).
Among the probabilistic factorization algorithms for polynomials we should 
also mention the Ben-Or algorithms; see [24].
A new approach to factorization of polynomials over finite fields was developed 
by Niederreiter; see [193, 91, 194]. From the point of view of complexity, this 
method is close to the original Berlekamp algorithm.
In [241], one finds an efficient factorization algorithm for polynomials in 
GF(g)[rr] of complexity <9(n2,5 + n1+o^^ logg) operations in GF(q) with memory 
requirement of O(n3/2) elements of GF(g). It turned out that for a large q this 
algorithm is in some cases more efficient than all the previous ones.
In [238, 240], new algorithms were suggested for finding irreducible polyno­
mials over finite fields. The issues of complexity of factorization algorithms for 
polynomials over finite fields are considered in [237].
For factorization of polynomials over large algebraic extensions of finite fields, 
see [113].
A survey of the factorization algorithms for polynomials is contained in [109].
For solving a system of algebraic equations, one can use either the Lazard 
algorithm or the methods utilizing Groebner bases; see [136, 152, 68, 135, 134, 
46, 96].
We should also mention [148]. This paper deals with efficient determination of 
an isomorphism between two representations of a finite field and has important ap­
plications to both the discrete logarithm problem and factorization of polynomials 
over finite fields.
D. Coppersmith, in 1996, developed an algorithm for computing relatively small 
solutions of polynomial equations p(x) = 0 (mod TV) with composite modulus N 
(see [328, 327, 329]). More precisely, he proved the following theorem.
Theorem 6.32. Let p(x) e Z[rr] be a monic polynomial with degp(rr) = S > 2. 
Let N be a given natural number (whose factorization may be unknown). Then, 
with complexity depending polynomially on log TV and 6, we can find all integer 

6.7. SUMMARY
133
solutions Xq of the equation
p(x) = 0 (mod TV) 
such that |3?o| < N1/6.
Coppersmith’s algorithm uses LLL-reduced lattice bases (see the next chapter). 
It has important applications in cryptography. For example, in a number of cases 
it allows to break the RSA cryptosystem, provided the encryption exponent is low.
Coppersmith also came up with a generalization of his method to multivariable 
polynomials (see [329]). Further results in this direction were obtained in [370, 
378, 332]. A modified description of Coppersmith’s method convenient for practi­
cal implementation can be found in [370].
We remark that this method also applies to factorization of integers of a special 
form; see [330]. More precisely, in a number of cases one can factor RSA moduli 
TV = pq, where p = Aa2 + Ba + c (the numbers A, B,C are small) and q is of a 
similar form.
A method similar to that of Coppersmith was used in [314] to construct a 
factorization algorithm for numbers of the form TV = pr q. If r ~ logp, the algorithm 
has polynomial complexity.
In [333], a new deterministic polynomial algorithm for factoring RSA moduli 
was developed. It uses Coppersmith’s method and assumes that both the public 
and the secret keys are known. More precisely, we have the following theorem.
Theorem 6.33. Let N = pq, where p, q are prime numbers of the same bit 
length. Let e,d be such that ed = 1 (mod </?(TV)). If ed < N2, then for the given 
e,d,N one can factor N with polynomial complexity.
The paper also contains a similar result in the case when p and q are of different 
bit lengths.
In [346], one finds a detailed analysis of various stages of the factorization 
algorithm for polynomials over finite fields, such as elimination of repeated factors, 
reduction to factors consisting of products of irreducible polynomials of the same 
degree, etc. See also [438].


CHAPTER 7
Reduced Lattice Bases and Their Applications
7.1. Introduction. Lattices and bases
Let Rn be an n-dimensional Euclidean space with scalar product (•,•). Let 
bi,...,bn G Rn be linearly independent vectors. The set
A = A(bi,... ,bn) = Zbi © • • • © Zbn = {zibi H-------F znbn | xlf... ,xn G Z}
is called a lattice in Rn; the vectors bi,...,bn are called a lattice basis. The 
determinant of the lattice d(A.) is the quantity
d(A) = (det || (bi,b,)||i,,=i....n)1/2-
A lattice basis can be chosen in many ways; but since one basis is expressed in 
terms of another using an integer matrix with determinant ±1, d(A) is an invariant 
of the lattice. The determinant satisfies the Hadamard inequality:
n
d(A)<nibi|,
7=1
where |b| is the Euclidean norm of b G Rn. If ei,..., en is an orthonormal basis of 
Rn and b; = bije:b = 1, • • •, then
^(A) = | det \\bij
Remark 7.1. Cassels’ book [52] is an excellent introduction to the geometry of 
numbers. There one can be find various properties of lattices and their applications.
A lattice is a discrete set, i.e., in any bounded subset of Rn there are only 
finitely many points of the lattice.
Recall the Gram-Schmidt orthogonalization process. Let bi,..., bn be linearly 
independent vectors in Rn. Define vectors bj,..., b* by the relations
i—1
bj = bX) b;=bi-i = 2,...,n,
j=l
where
^ = (bf,b;)/(b;,b;),
Then the vectors bj,..., b* are pairwise orthogonal.
When lattices are used in number-theoretic algorithms, an important role is 
played by bases consisting of sufficiently short vectors. Below we shall see several 
examples of such bases.
Fix a lattice A in Rn and consider the set Ga consisting of all of its bases. We 
define the following partial order on Ga : for {ai,..., an}, {bi,..., bn} G Ga,
{ai,.. •, an} < {bi, • • •, bn}
135

136
7. REDUCED LATTICE BASES AND THEIR APPLICATIONS
if there is an index j such that for all z< j we have |a;| = |b*|, but |a? | < |bj |.
Definition 7.2. A minimal element of Ga relative to < is called a Minkowski- 
reduced lattice basis.
Since the norm takes a discrete set of values on the lattice, a Minkowski-reduced 
basis exists. But it need not to be unique. For example, in the lattice Zn, any 
permutation of the unit vectors ex,...,en is a Minkowski-reduced basis.
Consider now another partial order <t- Let a = (a?i,..., £n), b = (3/1,..., yni), 
a,be Rn. We define a <t b if either |a| < |b| or |a| = |b| and there is an index j 
such that Xi = yi when i < j, but Xj > yj (i.e., the first distinct coordinate of the 
smaller vector is bigger). Clearly, any two vectors in Rn are comparable relative to 
<t- We can extend <r to G\\ for {ai,... ,an}, {bi,... ,bn} G Ga,
{ai,...,an} <T {bi,...,bra}
if there is an index j such that a* = b* when i < j, but aj <r bj.
Definition 7.3. A minimal element of Ga relative to <t is called a completely 
reduced basis.
Remark 7.4. It is easy to see that a completely reduced basis exists and is 
unique. An algorithm for computing a completely reduced lattice basis can be 
found in [205, Ch. 3].
Minkowski-reduced and completely reduced bases have important applications 
in computational algebraic number theory; see [205, Ch. 3, 5]. In number-theoretic 
algorithms one often uses Lenstra-Lenstra-Lovasz-reduced (LLL-reduced) bases, 
which will be discussed below.
7.2. LLL-reduced bases and their properties
Definition 7.5. A basis bi,... ,bn of a lattice A C Rn is said to be LLL- 
reduced if the vectors bj,..., b* and the coefficients /iij obtained via the Gram- 
Schmidt orthogonalization process (see 7.1) satisfy the inequalities
(7.1) 
i<j<i<n,
Q
(7.2) 
|b? +Mii-ibr_1|2 > -Ibr-J2.
Remark 7.6. LLL-reduced bases were introduced in [140]. Condition (7.2) 
means that the projection b* + /i^_ib*_1 of b; to L(bi,..., b^)"1 is not very 
small compared to the projection of K — 1 to L(bi,... ,bi-2)±.
We shall now list several important properties of LLL-reduced bases.
Theorem 7.7. Let bi,... ,bn be an LLL-reduced basis of the lattice A C Rn. 
Then:
1. |bj2 < 2l-1|b*|2 for all i,j, 1 < j <i < n;
^(A) < nr=i n < s^-1)/4^);
|bi| < 2<n-1)/4d(A)1/n.
Proof. Because the vectors b* are orthogonal, we have
|b;+^-ib;-ii2 = |b:i2+^-iib;_ii2.

7.2. LLL-REDUCED BASES AND THEIR PROPERTIES
137
Since < 1/4, inequality (7.2) implies that
|b*|2> Jlb^l2.
This implies the inequality
(7.3) 
|b}| <2i-^|b7|2,
which holds for all i > j. As the vectors b* are orthogonal, we have
|bi|2 = |b*|2 + 
< Ibtl2(l + E I2"’')
i<j 
' 
l<7<i 
'
= ib*i2(i+|(2i-i-i)) < 2i-i|bri2.
Therefore |bj2 < 2J_ 1 |bj|2 < 2J-1 • 2l-J|b*|2, which proves the first assertion of 
the theorem.
The first inequality in the second assertion is the Hadamard inequality. The 
second inequality holds, because
n 
n 
t n
nv^n t-1 _____ 
n(n-l)
|bi|<2s-1 2 nib*l = 2 2
i=l 
i=l
Here we used the equalities
d(A) = |det[b1)...,bn]| = |det[bJ,...,b*]|
= |det[bj,... ,b*] • [bj,...,b*]T|1/2 = |det ||(b*,b*)|| |1/2 = n|b*|
i=l
([bi,...,bn] denotes the matrix whose zth row consists of the coordinates of b*).
Finally, the inequality
|bi|2<2i-1|b*|2, i =
implies that
n
|bi|2n < 2n(n-l)/2 JJ |b*|2 = 2^-1)/2d(A)2,
i=l
which proves the last assertion of the theorem. 
□
Theorem 7.8. Let bi,... ,bn be an LLL-reduced basis of the lattice A. Then
for any vector x € A \ 0 we have
|bi|2 < 2n-1|x|2.
Remark 7.9. Theorem 7.8 means that bi is one of the shortest vectors of the 
lattice.
Proof. Let x = ZXi^b; e A \ 0, where n e Z, and x = ZX=irik*, 
where r* e R. If io is the largest index such that n =4 0, then, clearly, rio = rio- 
Therefore (since the vectors b* are orthogonal)
n 
1 
1
M2 = 52(r,-)2|b-|2 > ryb-J2 > |b-012 > 
|bt|2,
i=l
which implies the assertion of the theorem. 
□

138
7. REDUCED LATTICE BASES AND THEIR APPLICATIONS
Theorem 7.10. Let bi,... ,bn be an LLL-reduced basis of the lattice A and 
Xi,...,xt linearly independent vectors in A. Then for all j <t we have
|bj|2 < 2n-1 max(|xi|2,..., |xt|2).
Proof. Let 
n
Xi = 
rjjbj, rij E Z, i = 1,... , t.
j=i
For each z, 1 < i < t, let j(i) be the largest index j such that r^ =4 0. Then, 
similarly to the proof of Theorem 7.8, we have
|xi|2>|b*(i)|2, i = l,...,L
Without loss of generality we may assume that j(l) < j(2) < ••• < j(£). Then 
j(i) > a, i = 1,...,£, because, if there is an index i such that j(i) < i, then 
Xi,..., Xi G L(bi,..., bj(i)), contrary to the linear independence of Xi,..., x^. By 
Theorem 7.7,
|bi|2<2^)-1|b*(i)|2<2”-1|xi|2, 
where the last inequality follows from the definition of j(i). 
□
7.3. An algorithm for constructing an LLL-reduced lattice basis
In this section we shall describe a construction of an LLL-reduced basis for a 
lattice A C Rn. We keep the notation of 7.2.
An algorithm for constructing an LLL-reduced basis.
The input of the algorithm consists of a basis bi,... ,bn of the lattice A. At 
the end of the algorithm, bi,..., bn is an LLL-reduced basis.
We induct on k G {1,2,..., n + 1}. In the beginning k = 2; when k = n + 1, 
the algorithm terminates and outputs an LLL-reduced basis.
For each k the symbol (*)& will denote the inequalities
iMvl < 
l<j<i<k,
|b; 4-Mii-ibJ-il2 > ||b;_i|2, l<i<k.
If k = 2, then conditions (*)2 are satisfied, for i is subject to a vacuous condition 
1 < i < 2. If k = n+1, then (*)n+i means that the basis is reduced (by definition).
Suppose that for some fc, 1 < fc < n + 1, inequalities (*)& hold. We want that 
(*)fc+i also hold. First we make
(7.4) 
|Mfc,fc-i| — 2‘
If (7.4) does hold, then we move on. Otherwise, find the closest to integer r 
and replace b& by
k—2
bfe - rbfc_i = bfc + 
- r)bfc_v
Then the coefficient will be replaced by - r, which would guaran­
tee (7.4). The coefficients pLkj are replaced by i^j — r/Jtk-ij) j = 1,..., A; — 2. All 
other coefficients and vectors b* for i < k and for i > A, as well as the vector b£ 
remain the same. Indeed, b* is the projection of b; to L(bi,..., b;_i)-1-; when b^ 
is replaced by b& — rb^-i, the linear hulls do not change, hence all the b* remain 
(*)fc

7.3. AN ALGORITHM FOR CONSTRUCTING AN LLL-REDUCED LATTICE BASIS 139
unchanged. Because /iij = (bi,bj)/(bj, b*), we have, for i =4 A, that /Jij remain 
unchanged since b* has not changed and none of the bj changes.
We now continue to build (*)fc+i under the assumption that (7.4) holds.
Case 1. Suppose k > 2 and
(7-5) 
m + 
< flbLJ2.
Then we interchange the vectors b& and b^-i. The vectors b^_x and b£ will change. 
The same is true for the coefficients Mfc-iwhere j < k — 1 
or i > k. The other bi,b* and will not change for the same reasons as before, 
i.e., because L(bi,...,bi)1 and the vectors b* remain the same for i =4 A, k — 1.
What happened when we interchanged the vectors b& and b^-i? The vector 
b£ + P'k.k-i^k-i was projection of b& to L(bi,..., bfc-2)-1". Now it is the pro­
jection of the new vector b^-i to L(bi,..., bfc-2)-1". Also, b^_x was the projection 
of bfc-i to L(bi,... ,bfc_2)J". Now it is the projection of the new vector b^ to 
L(bi,... ,bfc_2)±. Inequality (7.5) implies that, under the above change, |b^_1|2 
has decreased at least 3/4 times.
Having interchanged b& and b^-i, we replace k by k — 1 and thus force (*)fc-i.
Case 2. Suppose that either k = 1 or
Q
(7-6) 
Ib^ + M^bJU^-lbJU2.
If k = 1, then we assign the value 2 to k and continue the process, i.e., force (*)2- 
If (7.6) holds and k > 1, then we force the inequalities
(7-7) 
1<J<^-1
(for j = fc — 1, inequalities (7.7) already hold because of (7.4)). Let I be the largest 
index such that \/j,ki\ > j. Then I < k — 2. Let r be the closest integer to We 
now replace b^ by b^ — rbi. Under this change, Hkj is replaced by p>kj —r/j,ij when 
j < Z, and /j>ki is replaced by /j,ki — r. All other and b* remain unchanged. We 
continue the process and decrease I until we reach I = 1. Then conditions (*)fc+i 
will hold.
If conditions (*)n+i hold, then the algorithm terminates, because bi,...,bn 
form a reduced basis; otherwise, we continue the process, i.e., increase k.
End of algorithm.
We now show that the algorithm terminates. Let
di = det||(bj,bz)||i<JiZ<i, i =
It is clear that
di = det(||bj ||i<j<i • ||bj||i<(<i) = (det Hbj lli^^)2
= (det ||bj||i<j<i )2 = det(||b*||i<^<i • ||bri|i<f<i) = ri |btI2.
Since Case 2 requires finitely many operations and increases k by one, we only 
need to show that Case 1 may occur only finitely many times. As we run through 
Case 1 with some value of A, the quantity dk-i decreases by a factor of less than 
3/4, since this is true for |b^_112.

140
7. REDUCED LATTICE BASES AND THEIR APPLICATIONS
At the same time, the di are bounded below by a positive constant depending 
only on the lattice A. More precisely, if m(A) is the square of the length of the 
shortest nonzero vector in A, then
m(A) < (-) d/ , « = l,...,n
(see [52, Ch. 2]). Therefore, for each A, Case 1 may occur only finitely many times. 
This means that the algorithm eventually terminates.
Theorem 7.11 (see [140]). Let A be a lattice in Zn with basis bi,... ,bn such 
that
|bi| < B, z = 1,... ,n,
where B G R, B > 2. Then the algorithm for constructing an LLL-reduced basis 
requires O(n^ log B) arithmetic operations. Moreover, the integers appearing in the 
algorithm, have binary length O(nlogB) bits.
Remark 7.12. In [57, Ch. 2], one finds a flowchart of an algorithm for con­
structing an LLL-reduced basis, which is convenient for implementation.
Remark 7.13. The possibility of changing the constant c = 3/4 in the Lovasz 
condition
Ibt + ^b^l^llb^l2
is considered in [126]. During the run of the algorithm the value of c changes 
from | + e to 0.99.
7.4. The Schnorr-Euchner algorithm and an integral LLL algorithm
In this section we briefly describe modifications of the algorithm for construct­
ing an LLL-reduced basis. They are presented in [227, 71, 228, 204] and in the 
monograph [57].
Let Bi denote
Bi = (b*,b*), i = l,...,n.
One of the modifications of the LLL algorithm was suggested by Schnorr and 
Euchner. It is called the LLL algorithm with deep insertions. It has a worse 
theoretical complexity estimate than the original LLL algorithm, but it often yields 
shorter lattice vectors, which is important for practical applications.
The idea of the LLL algorithm with deep insertions is as follows. Let k > i\ 
insert b^ between b^-i and b* in the reduction process. Since
fc-l 
i—1
bfc = bfc + Vkjbj = b£ + v + Mfcjbj, 
j=i 
j=i
where v = Vkjbj, after the insertion of b^ between b* and b^-i the new 
value of the vector b* will be
fc-i
bi,new = bfc + V = bfc + y^ P^kjbj.
j=i
The new value of the square of the length of b* will be
z 
fc-l 
k—1 
x 
fc-l
Bi,new = (b*k + £>fejb*,b: + 
= B* +
X 
j=i 
j=i 
Z 
j=i

7.4. THE SCHNORR-EUCHNER AND AN INTEGRAL LLL ALGORITHMS
141
If the new value B^new is less than the old one (for example, B^new < |Bi), then 
such a change is sometimes reasonable; if i = k — 1, then it is equivalent to one of 
the steps in the LLL algorithm. However, if i =4 k — 1, then one has to recalculate 
more coefficients than in the original LLL algorithm; this increases the running 
time of the Schnorr-Euchner algorithm. A flowchart of the LLL algorithm with 
deep insertions can be found in [57, Ch. 2, Algorithm 2.6.4].
Another modification of the LLL algorithm is called the integral LLL algo­
rithm^ and is due to de Weger. It can be used when the Gram matrix G = 
||(bi,bj)||ij=i,...,n for the basis bi,...,bn of the lattice A is integral (this hap­
pens, for example, when A is contained in Zn). In that case we have
Theorem 7.14. Let (as in 7.3) do = 1, di = det ||(bj,bf)||jj=i)...)i, i = 
1,... ,n. If the Gram matrix of A is integral, then for all indices i, 1 < i < n, 
and all j <i the following holds:
1. di—iBi G Z and di]j>ij G Z,*
2. di ■ 
PiklJ'mkBk 6 z for all m, j <m<i.
Proof. In 7.3 we saw that
=riibji2=
J=1 
J=1
Therefore di = di-iBi G Z. Let j <i. Consider the vector
J 
i-i
(7.8) 
v=bi-22Mifeb:=b;+ 22
fc=l 
fc=j+l
Clearly, (v, b£) = 0 for k = 1,... ,j. Since L(bi,..., b^) = L(bJ,..., b£), we have
(7.9) 
(v,bfe) = 0, k = l,...,j,
and
3 
(7.10) 
V = bi - 22 Xkbk
k=l
for some ... ,Xk 6 R. Combining (7.8) and (7.9) we have a system of linear 
equations
((bi,bi)\ 
/(bi,bi) ... (bi,bj)\ /xA
(bi,bj)y 
y(bj,bi) ... (bj,bj)y \xj /
Using Cramer’s rule, we have Xk = k = 1,... ,j, where w G Z. Since
3 
3
^fcbfc = ^Zjfcbfc, 
fc=l 
k=l
we also have Xj = Hij, which implies the first assertion of the theorem.
To prove the second assertion, consider the vector v defined by (7.8). Then
3
djN = djbi dj'3?fcbfc.
k=l

142
7. REDUCED LATTICE BASES AND THEIR APPLICATIONS
Moreover, as was proved above, diXk G Z. This means that djV G A, whence 
(djv, bm) G Z for all m = 1,..., n. Then 
/ 
3 
\
dj (bi Mifcbfc, bm J E Z, m = 1,..., n.
' 
k=i 
'
Therefore
/ 3 
\
dj ( ^Zifcbfc, bm J E Z, Tn = 1,..., n. 
'fc=i 
'
Let j < m < i. Then bm = b^ + /■I'mitf and
/ j 
\ 
/ 3 
m—1
dj ( Mifcbfc, bm J = dj ( ^Zifcbfc, bm + Mmjbj 
\fe=i 
' 
'fc=i 
i=i
3 
= dj ’ P>ikP>mkBk 6 Z. 
D
k=l
Corollary 7.15. Under the assumptions of Theorem 7.14, let
Aij — djP>ij G Z when i < An — d^.
For fixed i,j such that j < i, consider the sequence
/<. <. \ dkuk_i AikAjk 
.
u0 = (bi,bj), uk =------- j--------- k = l,...,j -1.
dk-i
Then uk € Z and Uj-i = A^.
Proof. We show that
(7.H)
When k = 0 this is obvious. Suppose (7.11) is true for m < k. Then
fc—1
dfcU-fc—i 
dk AikAjk 
(’ 
. AnAji 1 
\
Uk = --------j----------= dk (bi’“ > > 7^" “ 7^---------- XikXik ’
dfc-i dfc-i dk 
\ 
“ clicLi—i dkdk-i J
which proves (7.11) for k. It follows from (7.11) that 
/ k \
(7.12) 
uk = dk ( (bi, bj) — p,np,jiBi j,
because
AnAji di
11 
— 1 P'ilP'jl ~ BlP'ilP'jl-
didi-i 
di-i

7.5. SOME APPLICATIONS OF THE LLL ALGORITHM
143
Theorem 7.14 and (7.12) imply that Uk G Z. The equality Uj-x = Xij also follows 
from (7.12), because
/ 
\
uj—1 = dj—1 ((bi, bj) — 
j
i=i 
'
= 
((b? + £b* + M>sbj) - £
'' 
t=l 
s=l 
/ 
1=1 
'
( 
J-1 
J-1 
\
= dj-x ( P'ijBj + p,iSp,jSBs — p>u[jjiBi j 
' s=l 
1=1 
'
— dj-i^ij Bj = djp,ij = X^.
□
The integral LLL algorithm works as follows. It uses the integral Gram ma­
trix G rather than the vectors bi,..., bn. The output of the algorithm is an integral 
matrix H expressing the coordinates of an LLL-reduced basis in terms of the co­
ordinates of the original basis of A. Using Theorem 7.14 and Corollary 7.15, all 
computations are done only with integers. A flowchart of the algorithm can be 
found in [57, Ch. 2, Algorithm 2.6.7].
The last modification of the LLL algorithm we mention here is Pohst’s MLLL 
algorithm. It works with vectors bi,... ,bn e Rn spanning the set A = Zbi + 
---- 1- Zbn C Rn. Notice that the vectors bi,..., bn are not assumed to be linearly 
independent. The MLLL algorithm computes the rank of the Z-module A and finds 
an LLL-reduced basis of it. A flowchart of the algorithm can also be found in [57, 
Ch. 2, Algorithm 2.6.8].
7.5. Some applications of the LLL algorithm
One of the possible applications of the LLL algorithm is computation of the 
kernel and image of a linear map of a Euclidean space with an integer matrix. The 
corresponding algorithms are given in [57, §2.7]. In this section we describe other 
applications of the LLL algorithm: calculating an integral linear dependence for 
given real numbers and calculating short vectors in lattices.
Let zi,..., zn be fixed real numbers, zx =4 0. We want to find an integral linear 
dependence
(7.13) 
%x %1 + ’ ’ ’ + 
= 0, 
> • • • > Z,
where not all Xi equal 0. Choose a sufficiently large natural number N and consider 
the quadratic form
(7.14) 
Q(ai,..., an) = Q(a) = a\ + • • • + a2n + N{zxar + • • • + znan)2.
Since Q(a) is positive definite, it gives rise to a scalar product on Rn. To find 
3?i,..., xn satisfying (7.13), we proceed as follows: if the vector (ai,..., an) £ Zn is 
short relative to the norm induced by the quadratic form Q(a), then the quantity 
zxa>x H------\~znan will not be large, and neither will the coefficients of aj with j > 1.
Therefore, if zi,..., zn are linearly dependent, then it is likely that we will find a 
solution of (7.13).
We begin with the standard basis of A C Rn, consisting of the vectors b; = 
(5ii,... ,5m), i = 1,... ,n, where 6ij is Kronecker’s delta. Using the LLL algorithm 

144
7. REDUCED LATTICE BASES AND THEIR APPLICATIONS
from 7.3 (or its modification from 7.4) we find an LLL-reduced basis of A (the scalar 
product in Rn is given by quadratic form (7.14)). When the LLL-reduced basis is 
constructed, one of its short vectors will probably yield a solution of (7.13), as was 
explained before.
Lemma 7.16. I/bi,..., bn is the standard basis ofZn, then during the Gram- 
Schmidt orthogonalization process the following equalities hold:
P'H = %ili = 2,..., n\
P'lj = 0, 
2 < j <c i < n\
b* =bi ——bi, i = 2,...,n.
zi
Moreover, if Bi = |b?|2 are the lengths of the vectors b* in the metric given by 
Q(a), then
Bi = Nzl, Bi = 1 for i = 2,..., n.
Proof. Let [u, v] be the scalar product on Rn induced by Q(a). By definition, 
[u, v] = |(Q(u + v) - Q(u) - Q(v)).
It is now easy to see that the vectors
bj = bi = (1,0,... ,0),
Z' 
f Z' 
\
b* =bi- — bi = (-—,0,...,l,...,0), 
i = 2, ...,n,
Zi 
\ Zi 
/
are orthogonal. Indeed, when i, j > 2 and i =4 j, we have
Q(b* + b*)-Q(b*)-Q(b})
= 1 + 1 + N((-Zi - Zj) + zi + Zj)2
- (1 + N(-Zi + 2i)2) - (1 + N(-zj + zj)2) 
= 0
and, for j > 2, we have
QtbJ + b^-QCbn-QCbJ)
= 1 + N((zi - Zj) + Zj)2 - Nz2 - (1 + N(-Zi + Zi)2) = 0.
The assertion about Bi is also obvious. 
□
Before we describe the algorithm for calculating a linear dependence, we should 
comment on the choice of the natural parameter N in (7.14). The number N is 
chosen heuristically; one can try several different values of N. It is recommended 
in [57, Ch. 2] to choose N from the interval (|; ^) if all the values of Zi are not 
too far from 1 (say, belong to the interval (10-6; 106)) and we know them up to e. 
The number e should also be sufficiently small: if we assume that the solutions Xi 
of (7.13) do not exceed X, then e can be X-3n/2. We should always choose it to 
be less than X~n (here, however, we do not know the value of X and it should also 
be determined heuristically).
A (heuristic) algorithm for calculating a linear dependence.
The input of the algorithm consists of zi,..., zn e R, not all of which are 
zero, and a parameter N e N. The output is a small (in absolute value) linear 

7.5. SOME APPLICATIONS OF THE LLL ALGORITHM
145
combination Xj_zi + • • • + xnzn with small coefficients Xi e Z, not all of which are 
zero.
Step 1. For the standard basis bi,...,bn of Zn find, by Lemma 7.16, an 
orthogonal basis bj,... ,b* and the coefficients
Step 2. Apply the LLL algorithm of 7.3 to the basis bi,...,bn (and also 
to the corresponding orthogonal basis bj,... ,b* and to the coefficients fLij); the 
scalar product in Rn is given by quadratic form (7.14). In the end, we will have an 
LLL-reduced basis A of Zn.
Step 3. The coordinates #i,..., xni of the short vectors from the LLL-reduced 
basis found are probably solutions of (7.13), which can be verified by testing.
End of algorithm.
Remark 7.17. Instead of the standard LLL algorithm, one can use the LLL 
algorithm with deep insertions, described in 7.4, because it often yields shorter 
vectors.
Now we describe an algorithm for calculating all sufficiently short vectors in a 
lattice. More precisely, let A = Zbi H------ 1- Zbn be a lattice in Rn and C a positive
constant; we want to find all vectors b G A such that
(7.15) 
|b|2 < C.
This is a difficult problem; the algorithm described below may, in some cases, have 
a complexity which depends exponentially on the dimension n of the space.
If b G A, then b = #ibi +-----1- xnbn for some #i,... ,rrn G Z. Then (7.15)
becomes
|Q(X)| = 
< C,
where 
n
Q(#i, • • •, #n) = (#ibi + • • • + £nbn, #ibi + • • • + £nbn) = (bj, bj^XiXj
is a positive definite quadratic form. We reduce it to the more convenient form 
n 
z 
n 
\ 2
(7.16) 
Q(x) = Qii f 
Qij'Ej j > Qii > 0*
i=l 
' 
J=i+1 
7
To this end, we rewrite Q(x) as 
n 
d^jX^Xjy where —— (bi,bj), a^j — ciji*
The number an = (bi,bi) is positive. Then 
n 
n n
<2(x) = anxl + 2 aijxixj + ^2^2 aijxixi 
j=2 
i=2 j=2
z 
71 
/ 71 
\ 2\ 
71 
71 
z 71 
x 2
= anH + 2£%jj +
V 
^2an // 
\=2ai1 /
/ n 
\ 2
= an ( 
) “I" Ql (^2, • • • > ^n)>
\ 
all /

146
7. REDUCED LATTICE BASES AND THEIR APPLICATIONS
where
n n 
/ n 
\ 2
Ql (^2> • • • > #n) = 
QijXiXj — ( 
)
J=2j=2 
S=2 11 7
is also positive definite, because, under the obvious change of variables, 
Q(xi, = anyl + Qi (y2, . . •, yn).
We then repeat the above steps for Qi(#2, • • • , xn) and, in the end, we have reduced 
Q(x) to (7.16). Representation (7.16) is called the Cholesky factorization of the 
quadratic form Q(x).
An algorithm for calculating short lattice vectors.
The input of the algorithm consists of a positive definite quadratic form Q(x) = 
Q(£i, ... ,£n) as in (7.16) and a positive constant C. The output consists of all 
vectors x G Zn such that Q(x) < C (from each pair ±x only one vector will be 
chosen).
Step 1. i := n, Ti := O', Vi := 0.
Step 2. z := y/Ti/qu, Li [z - Vi], Xi := f-z - 14] - 1-
Step 3. Xi := Xi + 1. If Xi > then i := i + 1 and return to Step 3. Else, if 
i > 1, set 
n
Ti—i := Ti — Qu(xi + Vf) , i \= i — 1, Vi := Qijxj
and return to Step 2. 
J l+x
Step 4. If (#1,..., xn) = (0,..., 0), then the algorithm terminates. Else, a 
new vector x = (rri,..., xn) is defined together with Q(x) = C — Ti + gn(#i + Vi)2 
and we return to Step 3.
End of algorithm.
We shall show that the algorithm is correct. In fact, in this algorithm we 
showed how to test the values a?i,..., xn. In the beginning, z = n, Tn = O', 
Vn = 0, z = y/c/qnn, Ln = y/c/qnn, and xn = \-y/C/qnn\ - 1. This is the 
smallest possible value of xn G Z such that the vector x = (o?i,..., xn) may satisfy 
the inequality Q(x) < C. Indeed, for x = (#i,... , £n), the inequality Q(x) < O', 
because of (7.16), implies that qnn%n < l^n| < 
and therefore xn < Ln
(this is to identify the end of testing) and xn > \—y/C/qnn]. Then, in Step 3, we 
set Tn_i equal to c - q^n-iX^, and Vn_i equal to gn-i,n^n, and return to Step 2. 
Now we choose, in a similar way, the smallest possible (for the value of xn already 
found) value of rrn-i- Then
qn— l,n— 1 (xn— 1 4“ Vn— 1) < Tn—i, 
whence
I _i_ TZ I I Tn—1 
_
l^n—1 4“ Vn_ i| < a 
— Z.
y qn— l,n— 1
Therefore
xn— 1 — 
— Vn—1"|>
and also xn-i < z — Vn-i, whence xn-i < Ln-i> This implies that if in Step 3 we 
have xn-i > Ln-\^ then we are out of bounds for xn-x (for the given xn). We then 
move to the next value of xn. Now, similar to the above, for the given xn and £n_i, 
we test xn-2- The testing terminates when the (increasing) variable xn reaches 0 
and all other (increasing) variables, when xn = 0, also reach 0. Then from each pair

7.6. THE FERGUSON-FORCADE ALGORITHM
147
±x, we have exactly one vector such that Q(x) < C. Notice that, in Step 3, the 
running value Ti-i := Ti — qu(xi + Vi)2 satisfies the inequality T^-i > 0, because 
the inequalities Xi < Li and Xi > \—z — 141 imply that +14| < y/Ti/qa = z.
Yet another improvement of the given algorithm was suggested by Fincke and 
Pohst. One starts by calculating the Cholesky factorization of the quadratic form 
Q(x) = xTAx, which is equivalent to representing A in the form A = RTR for 
some upper-triangular matrix R. Then one applies the LLL algorithm to the rows 
of R-1. This allows for a substantial decrease in the number of testing the Xi in 
the algorithm; in practice this significantly accelerates it. For further details, see 
[90] and [57, Ch. 2].
Remark 7.18. It is not known whether the problem of calculating a lattice 
vector of shortest length is NP-complete. The NP-completeness of this problem is 
proved for the valuations | • |oo and | • |i of Rn; see [5]. In 1998, M. Ajtai [294] 
proved the NP-hardness of this problem for a randomized version of the algorithm.
7.6. The Ferguson-Forcade algorithm
In this section we describe the Ferguson-Forcade algorithm; see [86] and also 
[85, 88, 89, 87, 41]. This algorithm determines an integral linear dependence of 
a given finite set of real numbers. One such algorithm for solving this problem was 
already described in 7.5.
First we introduce some notation. Fix a number n G N, n > 2. For a real 
n x n matrix A = ||aij|, set |A| = 03X7=1 a^. Clearly, |A + B\ < |A| + |B| and 
|AB| < \A\ • \B\.
Fix a vector x = (a?i,..., xn) G Rn. A vector m G Zn, m =4 0, will be called a 
relation if
(7.17) 
xmT = 0.
We shall assume that all coordinates of x are different from zero. Otherwise a 
relation (7.17) can trivially be found. Let P be the n x n matrix
(7.18) 
P = xxT-In-xTx,
where Ii denotes the identity I x I matrix, I = 1,2,... . Then xP = xxT(xIn — x) = 
0. If y G Rn and yP = 0, then
y(x,x)-(y,x)x = 0,
whence yi = Xi • Therefore, rankP = n — 1.
Consider the n x (n — 1) matrix H whose columns form a basis of (L(x))-1-. 
Clearly, rank H = n — 1 and xH = 0. We want to show how to compute H. Let Vi 
denote the ith row of U, i = 1,..., n; v* G Rn-1. Let Hq = 0 G Rn-1,
(vA
... , i = l,...,n.
vi/
For i > 1 the Hi are i x (n — 1) matrices and Hn = H.
We also set Gq = 1 and consider the i x i matrices
(
(vi,vi) ... 
(vi,Vi)\
 
 
(V£,V1) ... 
(VfjVi)/

148
7. REDUCED LATTICE BASES AND THEIR APPLICATIONS
i = 1,..., n. Since all the coordinates of x are different from zero, the matrices Gi 
are invertible for 1 < i < n. Indeed, since xH = 0, we have #iVi H------ 1- xnvn = 0.
Therefore, vn is a linear combination of vi,..., vn_i, and, since rank# = n — 1, 
we see that Vi,..., vn_i are linearly independent. Therefore, the Gi are the Gram 
matrices for vi,..., v* and are, therefore, nonsingular when i < n. Let
(7.21) 
= 
« = 0,
The Pi are (n — 1) x (n — 1) matrices. Let
(7.22) 
Qi = In_i -
and consider the numbers
(7.23) 
C'(fc)j) = vfeP,Q>_ivT l<j<k<n.
For all other indices j, k we set C(k,j) =0. As a result, we have an array C(H) 
determined by H.
The next algorithm is of an auxiliary nature. It transforms the pair x, H into 
the pair xA-1, AH for some matrix A computed during its run.
Algorithm 1.
Step 0. If there is a coordinate Xi = 0, then the algorithm terminates.
Step 1. Let T =|| Tkj || be the lower-triangular n x n matrix with ones on the 
diagonal, and with Tkj for 1 < j < k < n being the integer closest to the number
C(feJ) v TkiC(i,j) 
i^<k ’
(We shall later show that =4 0, i.e., the Tkj are well defined.) Then the set 
x, H, C(H) is transformed into the set xT-1, TH, C(TH).
Step 2. Let i, 1 < i < n, be such that
2lC'(i,z) = max 2J’C(j,j). 
l<i<n
Let E be the n x n matrix obtained by permuting the zth and the (i + l)th rows 
of H. Then the set x, H, C(H) is transformed into x#-1, EH, C(EH).
Step 3. Let A = ET.
End of algorithm.
Notice that the matrix A obtained in Step 3 is integral and nonsingular. 
The matrix H defined above can be determined as follows. If
/I ... 0 X! \ 
0 ... 1 xn—i 
\0 • • • o xn y
then PX = (#0T). Indeed, the last column of PX equals PxT = 0, as was shown 
above, because P = PT. As X is nonsingular, we have rank# = rankPX = 
rank# = n — 1. Since xP = 0, we have xPX = 0, and therefore # is the desired 
matrix.
Let Ao = In> = x, and = H. This gives rise to a sequence
(7.24) 
x^,H^,Ak, A; = 1,2,... .
If, for some k > 1, we have already constructed x^fc-1\ #<fc-1) and the vector 
x(fc-1) has no zero coordinates, then apply Algorithm 1 to the pair x^fc-1\ #(fc-1\ 

7.6. THE FERGUSON-FORCADE ALGORITHM
149
In Step 3, it will construct a matrix A = Ak. Then we set = x^k ^Ak 1 and 
//■(fc) = AkH^k~^ (in fact, this is the output of Algorithm 1). Let
(7.25) 
Rk = A^1 • • • Ak\
Then
(7.26) 
x® = xRki = RkrH.
Assume in addition that x satisfies
(7.27) 
xxT = 1, 0 < Xi < • • • < xn.
Such a vector is said to be normalized.
Theorem 7.19. Suppose x is normalized and has a relation m of norm M. 
Then, for some k such that
(7.28) 
k < 2n+1nlog(3n3M2),
one of the columns of Rk is a relation.
To prove the theorem, we need some auxiliary results. As before, let Hj, Gj, Pj, 
and Qj be given by (7.19), (7.20), (7.21), and (7.22). Also, assume that rank#? = j 
for 1 < j< n — 1, rank# = n — 1, Vj are the rows of H, and the matrices Gj are 
invertible for j < n — 1. If
(7.29) 
V = L(V1,...,vn),
then dimV = n — 1.
Lemma 7.20. For all j,k, 1 < j,k < n, we have:
1) P? = Pj, Q? = Qjf PjPj = Pjf QjQj = Qj, PjQj = 0, and ifve 
vPj =4 0 (yQj =4 0), then vPjVT > 0 (yQjVT > 0);
2) 
PjPk = Pmin(j,fc); QjQk = Qmax(j,k) > PjQk = Pj ~Pmin(j,k) = Qk~Qmax(j,k) >
3) 
When j < k, we have VPj C VPk, VQj D VQk, Vj = VjPk,PjQk = 0;
4) 
QkPj = PjQk;
5) In-1 = Si<j<n-i(<2j-i - Qj) = Si<j<n-i pjQj-i are orthogonal decom­
positions of the identity matrix In-i;
6) 
rankPjQj_i = 1 and NjQj-i =4 0 for 1 < j < n — 1.
Proof. Since Gj = Gj, we have Pj = Pj, whence Qj = Qj. Now, PjPj = 
H^HjH^HjH^HjH^Hj = Pj; then (7.22) implies that QjQj = Qj. 
Therefore PjQj = Pj — Pj = 0. Finally, vPj =4 0 implies that vPjvT = vPjvT = 
vPjP?vT > 0; similarly, vQj =4 0 implies vQjvT > 0. Thus, the first assertion is 
proved.
Since V = 
we ^ave
k
(7.30) 
VPfe = ^RVj.
J=1
Indeed,
Pk = ^---^)G-k1 kJ.
\vfc/

150
7. REDUCED LATTICE BASES AND THEIR APPLICATIONS
whence, for I < fc,
(vA 
...I = V/.
Vfc/
For I > fc, we have
(vA k
... C
Vfc/ J=1
It follows from (7.30) that, for j < k,
(7.31) 
VPjCVPfc,
Since In_i = Pj + Qy, we have V = VPj + VQj. This factorization is orthogonal, 
because PjQj = 0. Indeed, (uPj, wQj) = (uPjQj, w) = 0. Therefore, whenj < A, 
the inclusion VPj QVPk implies VQj D VQk. It also implies that PjQk = 0 for 
j < k, because if PjQk 0, then there is a vector u such that w = uPjQk 0. 
Therefore, 0 < (w,w) = (uPjQk, uPjQk) = (uPjQki uPJ. But uPjQk e VQk, 
uPj e VPj, and, as was shown above, VPj is orthogonal to VQk. This proves the 
third assertion.
The definitions of Gq and Hq imply that Pq = 0 is the zero matrix and Qq = 
In_i> Also, Pn-i = 
= In-i, because Pn-i is a square matrix and
Gn_i = 
Therefore Qn-i = 0 and
n— 1
(7-32) 
=
We now show that PjPk = Pmin(j,fc)- Let j > k. Then PjPk = (In-i - Qj)Pk = 
Pk — QjPk = Pki because (QjPk)T = QjPk = 0, by the third assertion, already 
proved. The remaining equalities of the second part are proved similarly.
The fourth assertion now follows from the equalities
QkPj = QkPj = (PjQk) = (Pj ~ Pmin(j,k)) = Pj ~ Pmin(jtk) = PjQk-
The equality In_i = PjQj-i follows from (7.32) and the equality Qj-i — 
Qj = PjQj-i-
Next we want to show that the decompositions in part 5) are orthogonal. For 
i j, we have
(Qj-i — Qj)(Qi-i ~ Qi) = Qj-iQi-i ~ QjQj-i ~ Qj-iQi H- QjQi = Mij.
If i < j, then Mij = Qj-i~ Qj — Qj-i + Qj =0. The case i > j is argued similarly. 
This proves the fifth assertion.
Finally, we shall prove the last claim. Because
/ j 
\ 
j
vPjQj-i = 
= ^ai(V((7n_i - Pj-i) = ayv,(/n_i - P>_i)
^=1 
' 
1=1
for v G V, we have rankPjQj-i < 1. In other words, PjQj-i maps the (n — 1)- 
dimensional space V into at most one-dimensional space. But because In-i = 
PjQj-i I133 rank n ~ the rank of each summand equals 1 and vjQj-i =4 0 
for j = 1,..., n — 1. 
□

7.6. THE FERGUSON-FORCADE ALGORITHM
151
Corollary 7.21. 
= VjPjQj-tvJ > 0.
Lemma 7.22. Let B be a real n x n matrix and Bj the j x j matrix formed by 
the first j rows and columns of B, j = 1,..., n. Suppose det Bj =4 0, Hj = BjHj, 
j = 1,... , n, and the matrices Pj, Qj are obtained from (7.21) and (7.22) with Hj 
replaced by Hj. Then Pj = Pj and Qj = Qj.
Proof. By definition,
Pj = H^HiH^Hi = HTBjtBiHjHfBjr'BiHi 
= HfB^B^HiH^-iBfBiHi = P,.
The equality Qj = Qj is now obvious. 
□
In this section, for a real number a, the symbol [[a]] will denote the integer 
closest to a and {{a}} = ot— [[a]]; when a = | + n, n e Z, we set [[a]] = n.
The proof of Lemma 7.20 shows that
k
(7.33) 
Vfc = Vkln—i = OikiViPiQi—i
i=l
for some 6 R, fc = 1,... ,n. Indeed, because ViPi = Vi and 
= v* —
ViPi-i = 
such numbers aki can be found. Moreover, it is clear that
a^k = 1, k = 1,... , n. Consider the numbers C(k,f) = VkPjQj-ivJ from (7.23). 
Then
(7.34) 
akj = 
, 1 < j < k < n.
Indeed, (7.23) and Lemma 7.20 imply that
C(k,i) = 
= (vfc, VfPiQi-i)
= aki(viPiQi—l) viPiQi—l) = GkiCfi, i), 
which proves (7.34).
Now define a sequence Dktj-
(7.35) 
Dktk—i = 
1], fc = 2,..., n,
and, for the pair A, j, where k < n, k — 1 > j > 1, set
(7.36)
UfcJ L)k^ij
Dktj —
For all other values of k and j, n > k,j > 1, set
(7.37) 
Dkj = 0.
The matrix D =|| Dkj ||fcj=i,...,n is lower-triangular, and the matrix
(7.38) 
B = In — D
is invertible and integral. Moreover, 
B-1 = In + D + D2 + --- + Dn~1.
We now set 
(7.39)
H = BH.

152
7. REDUCED LATTICE BASES AND THEIR APPLICATIONS
The rows of H are the vectors v^,
(7.40) 
vfc = vfc - ^2 Dk,jvj-
l<j<k
Using Lemma 7.22 and (7.33), we have (since Pj = Pj and Qj = Qj) orthogonal 
decompositions of the vectors v>, k = 1,..., n:
k
(7.41) 
Vfc = 
akjVjPj Qj -1) Gkj £ R*
J=1
Lemma 7.23. \akj\ < 1/2 for 1 < j < k < n.
Proof. Let j < k. By (7.40) and Lemma 7.20, 4), we have
VkPjQj-1 = VkPjQj-1 = VkPjQj-1 ~ DkjViPjQj-l 
l<i<k
(7 42) 
= akjvjPjQj-l ~ DktiViPjQj-l
= ( akj ~ Dktiaij jVjPjQj-1, 
' j<i<k 
'
where the last two equalities follow from (7.33) and the orthogonal decomposition.
Using (7.40) and Lemma 7.20 again, we have
(7.43) 
VjPjQj-i = VjPjQj-i.
Then
VjPjQj-ivJ = -VjPjQj-ivJ, 
because
= (yjPj'VjQj-i)
= (yjPj,(yj-^D^) = (vjP^VjQj-i).
I <3
It follows from (7.42) and (7.43) that
VkPjQj-iv] = (akj - 52 PkiaijjvjPjQj-ivJ 
' 
j<i<k 
'
= ( fl k j — 
Dki O>ij J Vj Pj Qj-1 v J
' 
j<i<k 
'
= ( 
> DkiO>ij y C'C?) j) •
' j<i<k 
'
Therefore
_ 
n 
_ 
n 
n
Q>kj — _  ~p 75 
~ 
~ J ^ki^ij ~ ^kj-
^3 J^j—lVj 
j<i<k 
j<i<k
The lemma now follows from (7.36) and the equality ajj = 1. 
□

7.6. THE FERGUSON-FORCADE ALGORITHM
153
Fixing now z, 1 < i < n, let Tin be the n x n matrix obtained from H by- 
transposing rows i and i + 1. Set
H = TinH =
Vi+1
and let Hi, Pj, Qj be the matrices given by (7.19), (7.21), and (7.22), where H and 
Hi are replaced by H and respectively. Then
Hi = P7*-1) .
\vi+i J
Let vj, j = 1,..., n, be the rows of Hn, and Tij the j x j matrix formed by the 
first j rows and columns of Tin. If j then is invertible and the computation 
done in the proof of Lemma 7.22 can also be done for Bj = T^. Therefore, 
(7.44) 
Pj = Pj, Qj = Qj) 1 < j < n — 1, j] 
i.
This yields an orthogonal decomposition
n—1 
i—1 
n—1
In-1 = PjQj-1 = PjQj-1 + PiQi-1 + Pi+lQi + PjQj-1- 
j=l 
j=l 
J=i+1
Let (u, w) be the angle between u and w, provided it does not exceed tv.
Lemma 7.24. Let 1 < i < n and 0 = (vi+iQi-i,ViQi-i). Then
ViQi-iv7 = Vi+iQiV^.! CSC2 0, Vi+iQiV^-! = ViQi-iv? sin2 6.
Proof. If v = u + cw, where uwT = 0, then
(vwT)2 = c2(wwT)2, c2wwT = vvT • cos2(v, w), uuT = vvT • sin2(v, w).
Moreover, 0 = (vi+iQi-i, v^Qi-i) = {viQi-i, Vi+iQi-i) = ~0- Let 
u = vi+iQi = Vi+iA+iQi = ViQi, v = Vi+iQi-i = ViQi-i, 
w = ViPiQi-i = ViQi-i = Vi+iQi-i.
Lemma 7.20 implies that uwT = 0. Therefore, since (w, v) = 0, we have the second
assertion with v = u + cw for some c. By Lemma 7.20, we also have
PiQi-1 = Qi-1 ~ Qi)
V - u = vi+i(<2i-i - Qi) = Vi+iPiQi-i = cviQi-! = cw 
for some c e R.
To prove the first assertion, set
u = vi+i<2i = vi+iPi+iQi, v = Vi+iQi-i = ViQi-i = ViPiQ 
w = ViQi-i = ViPiQi-i ± 0.
Again uwT = 0. Since Qi-i — Qi = PiQi-i, we have
vi+i(Qi-i - Qi) = Vi+iPiQi-i = cviPiQi-i = cw 
for some c € R. Since (v, w) = 0, the first assertion now follows.
□

154
7. REDUCED LATTICE BASES AND THEIR APPLICATIONS
Lemma 7.25. If there is an index i, 1 < i < n, such that a^i^ = {{fli+i.i}} 
and
ViQi-iVi > 2vi+iQiv^1, 
then
3viQi_iv? > 4vi+iQi_iv£1.
Proof. Since Qi-i — Qi = PiQi-i, we have 
vi+lQi— 1 = vi+lQi 4“ 
1 >
and the summands in the right-hand side are orthogonal. Hence
Vi+iQi-iv^i = Vi+iQiV^-j + a?+1>iViQi_iv?.
Because 4a?+1 . < 1, it now follows from the assumption that
4vi+iQi_iV^.1 < 2viQi_iv7 + ViQi-iv?. 
□
Next we give some estimates of the quantity 
n— 1
(7-45) 
L(H) = £(2n - 2j + IJvjQj-xvJ.
J=1
Let A(A) be the sum of the diagonal elements of a square matrix A.
Lemma 7.26. Let the matrix B and the numbers a^j be defined by (7.33) and 
(7.38). Then
1) WF) = E”Ji(l + K=i+i a^Q^vf;
2) ifakj = {{aM}} for all k,j, k / j, then 
< L(H);
3) L(H) = L(H), where H = BH.
Proof. It is not difficult to see that VfcvJF = akjvjQj-iVj • Hence
TV 
TV fc 
TV 1 z 
TV 
\
A(HHT) = ^vkvl = 
= $2(1+ $2 akj)vjQj-iv7
k=l 
k=l j=l 
j=l ' 
fc=J-f-l 
'
(we used the fact that a^ = 1 and Qn-i = 0)- Now, if a^ = {{^fcj}} for k =4 j, 
then 1 + J2fc=j+i akj < 1 + t2- This implies the second assertion of the lemma. 
Finally, for H = BH, the proof of Lemma 7.23 implies that
= VjPjQj-ivJ = 
whence the third assertion. 
□
Lemma 7.27. Let i, 1 <i <n — 1, be such that
2iviQi_1vl > 2JvJ<2j_ivJ'
for all j = 1,..., n — 1. Then
L(H) < 2nnviQi_1vT.
Proof. Since
VjQj-i-vJ < 2z~}viQi_iVi , 
we have
L(H) < 2ivfQi_iv7 $2 2W "5^ "l-~' 2i+1nvi<2i_1v?, 
j=i 
because i < n — 1 and n > 2. 
□

7.6. THE FERGUSON-FORCADE ALGORITHM
155
Lemma 7.28. Let i be the same as in Lemma 7.27; consider the matrix Tin 
with permuted rows and the matrix H = TinH. Let a^i = {{ui,i+i}}. Then
Proof. By (7.44) and Lemma 7.24, we have
L(H) - L(H) = (2n -2i + l)(viQi-iv7 - vtQi-iV?")
+ (2n - 2i - iXvi+iQfvJ.! - vi+1QiV?+1)
= (2n - 2i + l)(viQi_iv7 - ViQi-iv?)
+ (2n - 2i - l)(vi<?i_iv?’ sin2 0 - ViQi-iyf sin2 0)
= (2n - 2i + 1 - (2n - 2i - 1) sin2 0XviQi-iv? -
Then L(H) — L(H~) > 2(yiQi_1vf — Vi+iQivJ^). By the choice of i, the second 
condition of Lemma 7.25 holds, which implies, by Lemma 7.27, that
L(H) - L(H) > 2(viQi_1vtT/4) > 
□
Lemma 7.29. In the above notation, 
L(H) < (xxT)2n2.
Proof. Since In_i = Pi-i + Qi-i is an orthogonal decomposition of In-i, and 
because VjPj-ivJ > 0, we have
vjvJ = vjpj-ivJ + 
> vjQ,_1vJ' > 0.
It follows from the definition of the matrix P that
Vj-vJ = (xxT)2 - x?(xxT + x„) < (xxT)2,
for j = 1,..., n — 1. Therefore
L(H) < ^(2n - 2j + l)vjVT < (xxT)2(n2 - 1), 
j=i
which proves the lemma. 
□
Lemma 7.30. Suppose m e Zn \ 0 is a relation. Then for any nondegenerate 
integral n x n matrix A we have:
0 < (xxT)2 < (mmT)|AP|2,
(xraXXT)2 
fmmT^n|2
° < (xxT + (n - 1)) - ( 
)|24/f| ‘
Proof. Since 1 < |AmT|, we have
0 < xxT < |AxxTmT| = |APmT| < \AP\ • |m|.
Now, P = (#0t)A'_1, whence |AP|2 < |AH|2|A'_1|2. Moreover, |X-1|2 = n — 1 + 
xxT/rr2. This implies the second assertion. 
□

156
7. REDUCED LATTICE BASES AND THEIR APPLICATIONS
Now we can prove Theorem 7.19. Since xxT = 1 and 0 < Xi < • • • < xni we 
have xxT < nx2n, whence < n. Set A = R^1 and suppose xmT = 0; recall that 
PX = [#0T]. Then |X-1| < 2n — 1. It follows from Lemmas 7.26 and 7.30 that
|Att|2 < L(Aff),
(7.46) 
1 < 3n(mmT)L(Afl).
Set en = 2n+in- By Lemma 7.28,
< (1 - en)kL(H).
Then, by Lemma 7.29,
L(AH) = 
< (1 - en)fe(xxT)2n2 = (1 - en)kn2.
It now follows from (7.46) that
1 < 3n3(mmT)(l - sn)k.
Since e-t > 1 — t for any t, 0 < t < 1, we have
1 < 3n3(mmT)e"fc£n.
Therefore k < log(3ng(mm )) = 2n+1nlog(3n3M2). This finishes the proof of Theo­
rem 7.19.
Algorithm 2 (computing relations).
The input of the algorithm consists of a normalized vector x G Rn. Algo­
rithm 2 computes, using Algorithm 1, the sequence x^fc\ H^k\ Ak from (7.24) 
and Rk = Af1 • • • A^1, k = 1,2,... . If there is a nonzero vector m € Zn of 
norm M satisfying (7.17), then, for some k satisfying (7.28), one of the columns of 
Rk is a relation.
End of algorithm.
Remark 7.31. Lagarias and Hastad have shown that Algorithm 2 requires 
O(2n2 log M + 20n3) arithmetic operations with real numbers.
7.7. Summary
In this chapter we described some types of reduced lattice bases, concentrating 
mostly on LLL-reduced bases, an algorithm for constructing such bases, and various 
applications thereof. One of the main applications of LLL-reduced bases will be 
given in the next chapter: this is an algorithm for computing an irreducible factor­
ization of polynomials with rational coefficients which has polynomial complexity 
in terms of the length of the input.
We remark that the applications of the LLL algorithm in linear algebra de­
scribed in this chapter are not always efficient enough. As examples, we mention 
the algorithm for calculating an integral linear dependence for real numbers from 
7.5 and the algorithm for computing short lattice vectors from the same section.
Computation of an integral linear dependence for a given set of real numbers 
has important applications in cryptography. In 7.5 and 7.6 we described two such 
algorithms. Yet another algorithm can be found in [101].
The best deterministic algorithm for computing shortest lattice vectors was 
given by Kannan; see [381, 382]. It has a complexity estimate of 2°(nlogn) opera­
tions.

7.7. SUMMARY
157
As we have seen before, the LLL algorithm can find a lattice vector whose length 
exceeds the length of the shortest vector at most 2(n-1)/2 times. Schnorr [428] 
improved that factor to 2°(n(loeloen)2/iogn) (see footnote 3 in [414]).
An efficient algorithm for reduction of a basis can be found in [431].
Recently Schnorr [429] offered a modification of the concept of an LLL-reduced 
basis, called an SLLL-reduced basis, and gave algorithms for its constructions. The 
complexity estimate of Schnorr’s algorithm is better than that of the LLL algorithm.
For more about lattices, see a new book by Schnorr [430].
A probabilistic algorithm for computing shortest vectors of an n-dimensional 
lattice is contained in [295]. It has complexity 2°^ operations (with polynomial 
dependence on the largest length of the machine representation of the coordinates 
of the basis vectors). It also describes a deterministic polynomial algorithm for 
computing a lattice vector of length at most 2nloglogn/logn • as, where as is the 
length of the shortest nonzero lattice vector. We remark that the description of the 
algorithms contains several unknown absolute constants.
There are several algorithms for computing lattice vectors that are sufficiently 
close to a given vector. We mention Babai’s algorithm [299], which has polynomial 
complexity (see also [386]). According to [414], for practical purposes, the best 
method for solving this problem seems to be the embedding method; see [358, 413].
An excellent survey of applications of lattices in cryptography can be found 
in [414]. An exhaustive reference list on this topic is also contained there. An­
other nice survey of applications of lattices in cryptography is contained the recent 
paper [369].
For applications of reduced-basis algorithms to integer factorization, see [422].


CHAPTER 8
Factorization of Polynomials over the Field 
of Rational Numbers with Polynomial Complexity
8.1. Introduction
In this chapter we consider algorithms for computing irreducible factorizations 
of polynomials in Z[rr]. We focus on the LLL factorization algorithm for polynomi­
als, as developed by A. Lenstra, H. Lenstra, and L. Lovasz [140]. It is of polynomial 
complexity in the length of the input. We also mention other efficient factorization 
algorithms.
A polynomial f(x) G Z[rr] is said to be primitive if the greatest common divisor 
of its coefficients is 1.
By the Gauss lemma, irreducible factorization of polynomials in Q[rr] comes 
down to that in Z[rr]. Suppose we want to factor /o(^) € Q[s] into irreducibles in 
Q[rr]. Multiplying /o(^) by a common denominator of the coefficients and moving 
out the greatest common divisor of the new integer coefficients, we reduce our 
problem to the factorization of a primitive polynomial /(#) G Q[rr] into irreducibles 
in Q[z].
Lemma 8.1 (The Gauss Lemma). If f(x)ig(x),h(x) G Z[rr], deg^(rr) > 1, 
deg/i(rr) > 1, g(x) and h(x) are primitive, f(x) = g(x) • h(x), then f(x) is also 
primitive
Proof. Let g(x) = 
h(x) = Y?j=ocixi’ 811(1 A®) = 'Ek=oakxk-
Then
(8.1) 
ak = ^ici> 0<k<n.
i+j=k,
0<j<m
Suppose f(x) is not primitive. Then there is a prime number p, dividing all 
k = 0,..., n. As g(x) is primitive, there is io such that p | bi for all i > io and p { bi0. 
Similarly, there is jo such that p | Cj for all j > jo and p { cJo. Let ko = io + jo- 
Then, by (8.1), p does not divide
ak0 = ^iocjo + 
bicj>
i+j=io+jo» 
either i>io, 
or j>j0
because the first summand in the right-hand side is not divisible by p, whereas the 
second is. 
□
Lemma 8.2. Let f(x) G Z[rr], f(x) is primitive and irreducible in Z[rr]. Then 
f(x) is also irreducible in Q[rr].
159

160
8. FACTORIZATION OF POLYNOMIALS OVER THE RATIONALS
Proof. Suppose f(x) = g(x) • h(x), where g(x), h(x) e Q[rr], deg <7(2) > 1, 
deg/i(rr) > 1. Then, moving out the common denominators of the coefficients of 
g(x) and h(x) and then moving out the greatest common divisors of the new integer 
coefficients, we have a factorization
/(®) = ibiC’OM®).
where A G Z, B G N, (A,B) = 1, gi(2),(x) G Z[rr], and gi(x) and (x) are 
primitive. Hence
(8.2) 
Bf(x)=Ag\{x)h\(x).
This shows that B divides the coefficients of Ag\[x)h\[x). Since gi(x)hx(x) is 
primitive (by the Gauss Lemma) and since (A,B) = 1, we have that B = 1. But 
then (8.2) implies that f(x) is reducible in Z[rr], contrary to the assumption. □
Thus the factorization problem for a polynomial fo G Q[rr] is reduced to finding 
the factorization into irreducibles for a primitive polynomial f(x) G Z[rr]. Let
n
(8.3) 
f(x) = ^aiXi, n = deg/(a:) > 2,
i=0
where a* G Z, i = 0,... , n — 1, an G N, and the greatest common divisor of the 
numbers ao,..., an is 1. These assumptions and notation will be in force in 8.2-8.5.
The norm of a polynomial h(x) = Y^=ohixZ e Qfc] is the quantity |h| =
’ which is the Euclidean length of the coefficient vector of the polynomial.
We shall also be switching between polynomials in Z[rr] and polynomials in 
Z/ZZ[rr], where I is a natural number; for a polynomial h(x) = Y^=o^xZ %*[x]> 
the symbol h(x) (mod /) will denote the polynomial 
(mod l)xz G Z//Z[#].
Accordingly, h(x) (mod /) | g(x) (mod Z) indicates divisibility in the ring Z/ZZ[rr].
We also recall that the ring of polynomials Z[rr] is factorial (see, for example, 
[125, Ch. 9]).
8.2. The LLL factorization algorithm: Factorization modulo a prime
Let the primitive polynomial f(x) be the same as in formula (8.3) of 8.1. 
Suppose we are given a prime number p, a natural number A, and a polynomial 
h(x) G Z[rr] such that
A) the leading coefficient of h(x) is 1;
B) h(x) (modpfe) divides f(x) (modpfe) in Z/pfcZ[rr];
C) h(x) (mod p) is irreducible in Z/pZ[#];
D) (h(x) (mod p))* 1 
2 3 { f(x) (mod p) in Z/pZ[rr].
Lemma 8.3. There is a unique primitive irreducible polynomial ho(x) G Z[rr] 
such that ho(x) divides f(x) in Z[x] and h(x) (mod p) | ho(x) (mod p). For polyno­
mials g(x) G Z[rr] dividing f(x) in Z[rr], the following are equivalent:
1) h(x) (mod p) | g(x) (mod p);
2) h(x) (mod pfe) | g(x) (mod pfe);
3) h0(x) divides g(x) in Z[rr].
PROOF. Property B) implies that h(x) (mod p) divides f(x) (mod p) in 
Z/pZ[#]. If we factor f(x) into irreducibles in Z[rr] (they will also be primitive, 
since f(x) is), then one of them, considered modulo p, is divisible by h(x) (mod p). 
By property D), this irreducible factor of f(x) is unique; it will be denoted h^ix).

8.3. THE LLL FACTORIZATION ALGORITHM: USING LATTICES
161
Now we can prove the equivalence of l)-3). Clearly, the third condition implies 
the first, and the second condition also implies the first.
Next we show that the second condition follows from the first.
Let h(x) (mod p) | g(x) (mod p). Then, by property D),
Zi(a:) (mod p) j (^y) (mod P)-
Since Z/pZ is a field and /i(rr)(modp) is irreducible, h(x) (mod p) and (-^j) 
(modp) are relatively prime in Z/pZ[#]. Hence there are polynomials A(rr),p(rr) G 
Z[rr] such that
A(rr) (mod p) h(x) (mod p) + p(x) (mod p) (mod p) = 1, 
or, equivalently, for some z/(rr) G Z[rr],
X(x)h(x) + 
= 1 - Pv(x)-
Multiplying this equality by (1 + pv(x) H------ pk~1v(x)k~1')g(x\ we have
Ai(z)h(z) +pi(z)/(z) = (1 -pfcz/(z)fc)p(z),
where Ai(rr), pi(rr) G Z[rr]. Therefore
Ai(rr) (mod pfe) h(x) (mod pfe) + pi(rr) (mod pfe) f(x) (mod pk) = g(x) (mod pfe), 
and, by B), h(x) (mod pfe) | g(x) (mod pfe).
Finally, we want to show that the first condition implies the third. Property 
D) implies that h(x) (mod p) { (mod p). Therefore h0(x) I in Since 
Zio(^) is irreducible, Hq^x) | g(x). 
□
In the subsequent sections we show how to choose p,k and h(x) such that 
properties A)-D) would hold. In the end, this will allow us to find the factorization 
of f(x) in Z[rr].
8.3. The LLL factorization algorithm: Using lattices
We assume that flx^p^k and h(x) e Z[x] are the same as in 8.2, and that 
properties A)-D) hold. Let I = degh(x). Then I < n, by properties A) and B) and 
since f(x) primitive; by Lemma 8.3, the equality I = n then means that /(#) is 
irreducible.
Fix a natural parameter m, m > I and consider the set
L = {P(x) e Z[x] | degP < m, h(x) (modpfe) | P(x) (modpfe)}, 
together with a map
#o: L -» Zm+1, $o ( 52 z3x3 ) = (a°’fll’ • • • ’ 
'i=0 
'
Clearly, L = $o(L) C Zm+1 is an additive subgroup of Zm+1. We shall later show 
that L is actually a lattice in Zm+1, i.e., it consists of all integer linear combination 
of some m + 1 linearly independent vectors.

162
8. FACTORIZATION OF POLYNOMIALS OVER THE RATIONALS
Notice that |P(rr)| = |$o(P(£))|, where the left-hand side is the polynomial 
norm defined above (see 8.1) and the right-hand side is the Euclidean norm of 
vectors in
The subgroup L is spanned over Z by the following vectors:
(8.4) 
(0,...,0,pfe)0,...,0) = $o(p/c •?), i = 0,l,...,l- 1,
and
(8.5) 
$o(^(^)^l-Z)> i = m.
Indeed, if P(x) G L, then P(x) (mod pk) = h(x) (mod pfc) • Q(x) (mod pk) for some 
Q(x) e Z[rr]. Hence P(x) = h(x)Q(x) +pk -T(x) for some T(x) G Z[rr], and we may 
assume that degT(rr) < deg/i(rr) = /, because h(x) is monic. Now, if Q(x) =4 0, 
then deg Q(x) = deg P(x) — deg h(x) <m — l. Moreover, all the polynomials of the 
form P(x) = h(x)Q(x) +pkT(x) G Z[rr] and of degree at most m are contained in L. 
It is now clear that vectors (8.4) and (8.5) span L. Their linear independence over Z 
and over Q is also obvious: the matrix whose rows are formed by vectors (8.4) and 
(8.5) is triangular, with pk (/ times) and ones (m — I + 1 times) on the diagonal. 
Therefore L is a lattice with determinant (see 7.1)
(8.6) 
d(L) =pkl.
Lemma 8.4. Let Hq(x) be the polynomial from Lemma 8.3, and let b(x) G L be 
such that
pkl >\f(x)\m-\b(x)\n.
Then Hq(x) divides b(x) in Z[x].
PROOF. Suppose b(x) =4 0 (otherwise the assertion is trivial) and g(x) = 
gcd(/(rr), &(#)) in Z[rr]. By Lemma 8.3, it suffices to show that h(x) (mod p) | 
g(x) (mod p). Assuming that h(x) (mod p) { g(x) (mod p), we have, by property C) 
of 8.2, that
(8.7) 
A3(z)h(z) + p3(x)g(x) = 1 - pv3(x)
for some A3(rr), p3(x), v3(x) G Z[rr]. Let mi = deg&(rr) and m2 = degp(rr). Then 
m > mi > m2 > 0. Consider the set
M = {A/ + p& | A,p G Z[rr],degA < mi — m,degp < n — m2}, 
where f = f(x) and b = b(x). The degrees of the polynomials in M are at most 
n + m\ — m2 — 1.
We want to show that if A/ + pb G M and deg(A/ + pb) < m2, then A = p = 0. 
Indeed, since g(x) = Xf + pb and deg g = m2, we have Xf + pb = 0 and A^ = — 
But gcd(^, |) = 1; therefore £ | p in Z[rr]. Since degp < n — m2 = deg f — degp, 
we have p = 0; but then A = 0.
Consider the map
zn4-7ni —m2 —1 
\
$:M—> Zn+rni 2rn2, 
aiX1) = (am2i am2+i,..., an+mi_m2_i).
' i=o 
'
As was shown before, $ is an injective homomorphism of additive groups. It was 
also shown that the vectors
(8.8) 
^(xz f(x)\ i = 0,1,... ,mi - m2 — 1,
(8.9) 
$(rrJ&(rr)), j = 0,1,... ,n — m2 — 1,

8.3. THE LLL FACTORIZATION ALGORITHM: USING LATTICES
163
(8-11)
are linearly independent over Z and span $(M). Therefore, $(M) is a lattice in 
gn+7ni-27n2 gy Hadamard inequality and by the assumption of the lemma,
d($(M)) < |/(rr)|rni-rn2|&(rr)|n-rn2 < |/r|&|n < pkl.
We want to show that the opposite inequality also holds; the obtained contradiction 
would then prove the lemma. We want to prove the inclusion
(8.10) 
£ M | degz/(z) < m2 + 1} Q pk • Z[z].
Let z/(rr) G M and degz/(rr) < m2 + I. Then G Z[rr]. Multiply (8.7) by 
and by 1 +^3(3?) H------ 1-p*5-1^-1^). We then have
X4(x)h(x) + p4(rr)z/(rr) - e pkZ[x].
Since i/(x) G M and b(x) G L, we see that h(x) (mod pfc) divides z/(rr) (mod pk). 
Then (8.11) implies that
ft(or) (mod pk) | (mod pk).
But 
<m2 + l — m2 = l = deg/i(rr) = deg(/i(rr) (mod pfe)). Therefore,
epkZ[x], whence (8.10).
It is well known that any lattice contained in ZN contains a triangular basis 
(see [52, Ch. 1]). Choose such a basis in $(M) C ^n+mi-2m2_ Its elements will be 
denoted b; = (&ii,... ,&u,0,... ,0), where bij G Z, ba =4 0, i = 1,... ,n + mi — 2m2. 
We also have d(£(M)) = ]j£+mi“2m21^| The preimages £-i(bi) of the vectors 
bi are in M and have degrees i + m2 — 1, i = 1,..., n + mi — 2m2. Then (8.10) 
implies that ba = 0 (mod pk) for i = 1,..., I. Therefore d($(M)) > pkl. 
□
Lemma 8.5. Let hofx) be an irreducible factor of f(x) such that h(x) (mod p) | 
Zio(^) (mod p). Let bi,..., bm+i be a reduced basis of L = $o(L), and suppose that 
(8.12) 
pkl > 2mn/2(n+ l)n/2en2|/|n+’n.
Then the degree of ho (rr) is at most m if and only if
/ <r\kl \ 1/n
(8.13)
PROOF. It follows from (8.13) that |bi|n|f\m < pkl, i.e., the assumptions of 
Lemma 8.4 hold for b(x) = $0(bi) G L. By the definition of L, we have deg&(rr) < 
m. It follows from Lemma 8.4 that | &(#), and therefore deg/io(^) <
Let degho(ir) < m. Then holx) G L. Since divides /(#), we have
(8.14) 
IMz)| < 
len|/(z)|
(for a proof, see [166]; this gives a bound on the coefficients of the divisor in terms 
of the coefficients of the dividend). We now apply Theorem 7.8 to £ = $o(^o(^)) € 
L = <bQ(L). Since £ =4 0 and L G ^m+1, we have
Therefore
|biri/(a?)r < 2mn/2(n + l)ra/2 e71'|/|m+n.
In now follows from (8.12) that
m < pkl,
whence (8.13).
□

164
8. FACTORIZATION OF POLYNOMIALS OVER THE RATIONALS
Lemma 8.6. Under the assumptions and notation of the previous lemma, as­
sume that
(8.15)
t = max< j
/ pkl
N < liTwr) ) -
Then deg= m + 1 — t and
(8.16) 
h0 (x) = gcd ( $o1(bi)>---»V(bt)A ,
\ PT 
/
where r is the largest nonnegative integer such that pT divides all the coefficients of
Proof. Consider the set J = {j | 1 < j < m + 1, |bj < 
0- By
Lemma 8.4, forj e J, we have | $q 1(bJ). Let h\(x) = gcdy6J($Q 1(bJ)); then 
h0(z) I h\(x). We want to show that J = {1,..., t} and that Hq(x) = ±hx(x)/pT, 
where r is from (8.16).
Since deg 1(bJ) < m for j = 1,..., m — 1 and the polynomials 1(bJ ) are 
linearly independent over Z, we have
(8.17) 
|J| < m + 1 - deg hi (z).
Now, |ho(z) • x3r| = |h0(ir)| < y/n + len|/(rr)|, by virtue of (8.14), and, for i = 
0,1,..., m—deg ho(#), the polynomials ho(rr) -x1 are contained in L and are linearly 
independent. By Theorem 7.10,
IM < 2-/2maX{|$o(/ioW)|, IMM*) • x)|,..., |$o(M®) •
= 2’n/2|$o(7io(3:))| = 2”l/2|ft.0Gr)I < 2m/2xAT+Ten|/(a;)|
for j = 1,2,..., m + 1 — deg ho(rr). Therefore, similarly to the proof of the previous 
lemma, we have
(8.18) 
|b,rw)lm<?fcl
for j = 1,...,m + 1 — deg h$(x). This shows that 1,2,..., m + 1 — deg ho(rr) e J. 
Hence, m + 1 — degho(rr) < | J\ < m + 1 — deghi(rr), and therefore deghi(rr) < 
deg h0 (z). As h0(rr) | hi(rr) in Z[rr], we have
(8.19) 
hi(rr) = dh0(rr), where d e Z, d =4 0.
We have shown that | J\ = m + 1 — degho(rr), J = {1,..., m + 1 — degho(rr)}, and 
that t = |J|, i.e., degh0(rr) = m + 1 — t.
Now we want to show that hi(rr) from (8.19) is almost primitive, i.e., the 
greatest common divisor of its coefficients can only be a power of p; this will 
imply (8.16). Assume the opposite, i.e., there is a prime q, q =4 p, such that 
hi(rr)/g e Z[rr]. By the definition of hi(rr), we see that |bi is in Z, because 1 e J. 
Let bi = (&io)---,&i7n) 6 Zm+1. Then bn = qb'u, where e Z, i = 0,... ,m. 
Since bi e Z, we have
(
m 
v
b'^x1 (mod pfe) j. 
i=0 
'
Since q =4 p, this implies that
/ m 
k
h(x) (mod pk) I ( b^x1 (mod pfc) ), 
^i=o

8.4. THE LLL FACTORIZATION ALGORITHM: LIFTING THE FACTORIZATION 165
i.e., (yi0,..., yirn) e L. But this is impossible, because bi is a basis vector for the 
lattice L. 
□
8.4. The LLL factorization algorithm: Lifting the factorization
In this section we show how the congruence
uq(x\vq(x) = w(x) (mod pm\
where p is a prime number, m e N, t60(rr), Vq(x\ w0(rr) e Z[rr], can be transformed 
into a congruence
U2(x)v2(x) = w(x) (mod pmi)
for some explicitly computable polynomials U2(x),V2(x) e Z[rr] and some m\ > m.
In this section, the prime symbol does not indicate the derivative, but some 
other polynomial.
We begin with an arbitrary field K. Suppose g(x)}h{x) e K[rr], deg <7(2) > 
deg/i(rr) > 1, and d(x) = gcd(p(rr),h(x)).
Algorithm 1.
The input of the algorithm consists of u(rr),v(rr) e Z[rr]. The output is a 
representation u(x)g(x) + v(x)h(x) = d(x).
Step 1. Set (?zi,?Z2)^3) := (1,0,g(x)\ (vi,v2,v3) := (0,1,h(x)).
Step 2. If V3 = 0, then output the values u(x) = ui, v(x) = u2, d(x) = U3 and 
stop.
Step 3. Divide with remainder
u3 = qvs + r, deg r < deg v3.
Step 4. Set (^,^2,^3) := (ui,u2,u3) - g(vx, v2, v3), (ui,u2,u3):=(vi, v2, v3), 
(vi,v2,^3) := (^1,^2, ^3) and return to Step 2.
End of algorithm.
It is easy to see that the found polynomials u(rr), v(x), d(x) indeed satisfy the 
equality u(x)g(x) + v(x)h{x') = d(x) = gcd(p(rr), h(x)). This is verified the same 
way as in the usual Euclidean algorithm for integers (see the Appendix). One can 
show (see [118, §4.6.1, Ex. 3]) that degv(rr) < deg <7(2), degu(rr) < deg/i(rr).
Now consider the field K = Z/pZ.
Algorithm 2.
The input of the algorithm consists of a prime number p, a natural number 
j e N, and polynomials a (a), b(x)} c(x)} gj(x), hj(x) £ Z/pZ[rr] such that the 
leading coefficient of hj(x) is invertible in Z/p^Z and a(x)gj(x) + b(x)hj(x) = 1 
in Z/p^Z^]. The output consists of polynomials a'(rr), b'(x) e Z/p^Z such that 
a'(£)<7j(£) + b'(x)hj(x) = c(x) in Z/p^Z^] and dega'(rr) < deg A,/#).
Step 1. As the leading coefficient of hj(x) is invertible, one can do division 
with remainder:
a(x)c(x) = hj(x) • q(x) + r(rr), degr(rr) < deg^(2).
Step 2. Set
a'(2) := r(x), b'(x) := &(rr)c(rr) + gj(x)q(x).
End of algorithm.

166
8. FACTORIZATION OF POLYNOMIALS OVER THE RATIONALS
The correctness of the algorithm follows from the equality 
gj(x)a'(x) + hj(x)bf(x)
= g^x^a^c^x) - hj{x)q{x)) + hj{x){b(x)c(x') + gj(x')q(x)')
= c(x){gj(x)a(x) + hj(x)b(x)) = c(z).
Lemma 8.7. Let p be a prime number, j G N, and t(x) G Z/p2<7Z[ir]. Also, let 
gj(x),hj[x) G Z/p^Z[z] and t(x) = gj[x)hj[x) (modp7). Suppose that the leading 
coefficient ofhj(x) is invertible in Z/p^Z^] and there are polynomials aj(x), bj(x) G 
Z/p*Z[:r] such that aj(x)gj(x) + bj(x)hj(x) = 1 in Z/p^Z^]. Then one can define 
polynomials a2j(x), b2j(x), 92j(%)> 
€ Z/p2jZ[rr] such that
t(x) = 92j{x)h2j(x) (mod p2j),
O’2j(x)g2j(x) + b2j(x)h2j(x) = 1 in Z/p2jZ[o:], 
g2j(x) = gj (modp7'), h2j(x) = hjfx) (modpi), 
deg h2j (a;) = deg hj (x).
Proof. Define a polynomial c,(x) 6 Z/p’Zfa;] by the equality
*(®) - gj(x)hj(x) =p>Cj(x).
Using Algorithm 2, find a'(a:),&'(a:) such that
a'j(x)gj(x) + 
= cj{x) in Z/pJZ[a:], dega'(o:) < deg/i^z).
Let g2j(x) = g,(x) +p3b',j(x) and h2j(x) = hj(x) +pia!j(x), so that g2j{:x), h2j(x) 6 
Z/p2jZ[a;]. Clearly, degh2j(®) = deg/ij(a;), g2j(x) = gj(x) (modp7), and h2j(x) = 
hj(x) (mod p7). Now,
g2j(.x)h2j{x) = 9j(x)hj(x) +p’(a'j(x)gj(x) + b^h^x)) (modp2-7)
= t(x) —p^Cj(x) +picj(x) (modp2j ) = t(x) (modp2<7).
Define the polynomial cij(rr) G Z/p^Z^] by the equality
g2j(x)aj(x) + h2j(x)bj(x) = 1 + p?cij(x) in Z/p2jZ[rr].
Using Algorithm 2, find a"(x), bj(x) such that
0j(z)a"(z) + hj^b'^x) = Clj(x)
in Z/p^Z^]. Let
a2j(z) = aj(x) —pia'jlx) G Z/p2jZ[rr], 
&2j(^) = bj(x) -pjbj(x) G Z/p2jZ[rr].
Then
g2j(x)a2j(x) + M^M*) = 92j(x)aj(x) + h2j(x)bj(x) - pjclj(x) = 1
in Z/p2jZ[rr]. The lemma is proved. 
□
Remark 8.8. We have described a quadratic lifting, i.e., the passage from 
relations modulo p7 to relations modulo p2j. There is also a linear lifting, i.e., the 
passage from relations modulo p7 to relations modulo p7-1-1 (see [9, Ch. 6] and [57, 
Ch. 3]). But if we want to pass from relations modulo p to relations modulo pfe, 
where k is rather large, then it is better to use the quadratic lifting because it will 
be faster.

8.5. THE LLL FACTORIZATION ALGORITHM: A COMPLETE DESCRIPTION
167
8.5. The LLL factorization algorithm: A complete description
We can now give a detailed description of the LLL factorization algorithm for 
polynomials in Z[#].
Algorithm (The LLL factorization).
The input of the algorithm consists of a primitive polynomial /o(^) € Z[rr], 
deg/o = no > 1. The output is the irreducible factorization of /b(rr) in Z[rr].
Step 1. Compute g(x) = gcd(/0(z),/q(z)) e where f^x) is the deriva- 
tive. Let f(x) = If
(8-20) 
/oW = AWai-AWa‘
is the irreducible factorization of /o(^) in Z[rr], then it is also the irreducible factor­
ization of /o(^) in Q[s] (see Lemma 8.2). Hence g(x) = fiixy*1-1 • • • /fc(rr)afc-1_1 is 
a primitive polynomial, and it can be found using the Euclidean algorithm in Q[rr]. 
Then f(x) = fi(x) • • • /&(#) is a polynomial without repeated irreducible factors.
Let n = deg/(rr). Henceforth, we shall assume that n > 2 (/(a?) is irreducible 
for n = 1 and /o(^) = /(^)a, where a = deg/o(^))«
Step 2. Compute the resultant Res (/,/') G Z. We have Res (/,/') =4 0 
(because f and f are relatively prime). For the definition and properties of the 
resultant, see [261].
Step 3. Find the least prime p such that p { Res (/,/'). Then p does not 
divide the leading coefficient of /(#), and f(x) (mod p) G Z/pZ[rr] has no repeated 
irreducible factors. One can prove (see [140]) that
. firn nlogn+(2n-l)log|/|\ 
p < max(Wl,-------------—-------------).
Thus, p can quickly be found by trial and error.
Step 4. Factor f(x) (modp) in Z/pZ[rr] into the product of irreducible monic 
polynomials using the Berlekamp algorithm. Let S be the list of the obtained 
factors. We are going to build a list Si of irreducible factors of f(x) in Z[rr], 
Si := 0. Set F(x) = f(x) and N = deg/(rr). If |S| = 1, then f(x) is irreducible in 
Z[rr] (because it is irreducible in Z/pZ[#]).
Step 5. Take any polynomial hi (rr) G S'; let deghi(:r) = li (we assume that 
| S| >2). Let F(x) = hi (x)gi (x) (mod p). Since hi (x) and gi (x) are relatively prime 
in Z/pZ[rr], we can use Algorithm 1 of 8.4 and find a representation u(x)hi(x) + 
v(x)gi(x) = 1 in Z/pZ[rr], where degu(rr) < degpi(rr) and degv(rr) < deghi(#). 
Find the least natural number k such that
pkl' >2N2/\N+l')N/2eN2\F{x')\2N.
Step 6. Using a method similar to the one from the proof of Lemma 8.7 of 8.4 
(applied several times), find a polynomial hi(x) G Z/pfcZ[rr] such that
hi(rr) (modpfe) | F(x) (modpfe),
deg/ii(rr) = degAi(re), and the leading coefficient of hi(x) is invertible modulo pk. 
Assuming that the coefficients of h(x) G Z/pfeZ[rr] are the smallest nonnegative 
residues of the elements of Z/pfcZ, we may also assume that h(x) G Z[#]. The 
polynomial hi (x) satisfies conditions B), C) and D) of 8.2. Multiplying hi (x) G 
Z/pfeZ[rr] by some a G (Z/pfcZ)*, a = 1 (mod p), we may also assume that hi(x) 
satisfies condition A).

168
8. FACTORIZATION OF POLYNOMIALS OVER THE RATIONALS
Step 7. Running through the values 
we shall perform Step 8 and pass to Step 9 as soon as we find e Z[rr] such 
that holx) | F(x). If no factor is found for any m, then F(x) is irreducible in Z[rr] 
(this follows from Lemma 8.5).
Step 8. For a given m, consider the sets L C Z[rr] and L = C Zm+1 
defined in 8.3. Using the basis
{$0(pkxz) | 0 < i < I - 1} U {#o(hi(z)z*) | 0 < i < m - 1}
of Z, find a reduced basis bi,..., bm+i. If
/ 
\1/N
(8-21) 
lbl। < (|F(a;)|m) ’
then the assumptions of Lemma 8.6 hold. Set
_ gcdW(b1),...,^-1(b.))|
PT
where t and r are from the same lemma. We have found a polynomial h$(x) e Z[rr] 
which is an irreducible factor of F(x). We enter h$(x) in Si and go to Step 9. 
If (8.21) does not hold, then go to the next value of m.
Step 9. Set N := deg(F(rr)//io(^))> F(x) = F(rr)//i0(rr) and remove the 
factors of h$(x) (mod p) (which we found by running through S') from S. If TV > 1 
and |S| > 1, then return to Step 5. If N = 0 or N = 1 or |S| = 1, then F(rr) is 
irreducible (or F(rr) = 1). We then add F(rr) to Si (if N > 0) and go to Step 10.
Step 10. Now Si consists of polynomials /i(s),..., /fc(rr) (see (8.20)). Us­
ing trial divisions, we find the exponents ai,... , Ofc and output the factorization 
fo(x) = Zi(z)ai
End of algorithm.
That the algorithm is correct can easily be seen from the results proved in 
8.2-8.4.
Theorem 8.9 (see [140]). The algorithm factors fo(x) into a product of irre­
ducible polynomials in O(n6 + n5 log |/|) arithmetic operations.
Remark 8.10. See [199] for an expanded description of the LLL factoriza­
tion algorithm for polynomials and for the flowcharts of the auxiliary and main 
algorithms.
8.6. A usable factorization algorithm
It was mentioned in [57, 3.5.5] that although the algorithm described in 8.5 is 
of polynomial complexity in the length of the input, in practice it is rather slow. 
In Chapter 3 of this book we mentioned a factorization algorithm of exponential 
complexity which works much faster than the LLL algorithm. We shall briefly 
describe it here.
A factorization algorithm in Z[rr].
The input of the algorithm consists of a primitive polynomial /o(^) € ^[#]> 
which we want to factor into a product of irreducible polynomials.

8.7. FACTORIZATION OF POLYNOMIALS USING APPROXIMATIONS
169
Step 1. As in the LLL algorithm of 8.5, we reduce the factorization problem for 
/o(^) to that for a primitive polynomial /(#) e Z[rr] without repeated irreducible 
factors.
Step 2. Find the smallest prime number p such that
gcd(/(a:) (mod p), f'(x) (mod p)) = 1
in Z/pZ[#]. Using one of the algorithms described in Chapter 6, we factor f(x) into 
a product of irreducible polynomials in Z/pZ[rr] (this factorization will be square- 
free).
Step 3. If h(x) e Z[rr] and h(x) | /(#), then the maximum of the absolute 
values of the coefficients of h(x) can be bounded by some value B depending on f(x) 
(see [57, Theorem 3.5.1] or (8.14) of 8.3, which follows from [166]). Find that B 
and then find the smallest e e N such that pe > 2Z(/)B, where /(/) is the leading 
coefficient of f(x) (1(f) e N). Let no = deg/(rr). Construct a list Si of irreducible 
factors of /(rr), Si := 0.
Step 4. Using the results of 8.4, find a factorization 
f(x) = l(f)gi(x) • • • gr(x) (mod pe) 
in Z/peZ[rr]. Set d := 1, S := {<?i(x),..., <7r(#)}-
Step 5. Now consider all products
G(x) = 9ii (»)••• 9ij (®) (mod pe).
For each of them, compute a uniquely defined polynomial G(x) e Z[rr] such that:
1) the coefficients of G(x) belong to the interval [— |pe; |pe);
2) G(x) = l(f)G(x) (modpe) if degG(rr) < | deg/(rr), and G(x) = f(x)/G(x) 
(modpe) if degG(rr) > | deg/(rr).
If G(x) divides /(/)/(#), then pull out the greatest common divisor of the coef­
ficients of G(x) and obtain an irreducible primitive polynomial Gi(rr) dividing f(x) 
in Z[rr]. We enter it into the list Si of irreducible factors of /(a?), then delete the 
corresponding g^ (x),..., gi. (x) from S and replace f(x) by f(x)/Gi(x).
Step 6. Set d := d + 1. If d < no/2, then return to Step 5. If d > no/2, then 
the polynomial f(x) obtained in Step 5 will be irreducible, and we add it to Si (if 
it is not constant).
End of algorithm.
Remark 8.11. For further details, see [57, § 3.5.4]. Similar factorization meth­
ods are described in [9, Ch. 6] and [118, §4.6.2].
8.7. 
Factorization of polynomials using approximations
In this section we shall describe two algorithms taken from [140]. One of them 
finds the minimal polynomial of an algebraic number; the other factors polynomials 
into a product of irreducibles in Q[rr] and Z[rr]. Those algorithms also use the LLL- 
reduced lattice bases together with approximations of roots of polynomials.
Recall that a number a e C is said to be algebraic, if it is a root of some 
nonzero polynomial h(x) in Q[rr]. We may assume that h(x) e Z[rr], and h(x) is 
irreducible and primitive. In that case h(x) is called the minimal polynomial of a, 
and its degree is called the degree of a, the roots of h(x) are called the conjugates 
of a, and the maximum of the absolute values of the coefficients of h(x) is called 
the height of a.

170
8. FACTORIZATION OF POLYNOMIALS OVER THE RATIONALS
For polynomials g(x) = 
e Q[rr], we shall use notation
|p(®)|oo = . max |pf|.
2=0,... ,771
The polynomial norm |p(rr) | was defined in 8.1.
In this section we shall make use of lattices of smaller ranks, i.e., the sets 
A = Zbi + • • • + Zbfc C Rn, where k < n and the vectors bi,..., b& are linearly 
independent. For such lattices, reduced bases are defined the same way as in the case 
k = n\ there is also a polynomial algorithm for constructing such bases; see [140]. 
Moreover,
(8.22) 
|vi| < 2^fe-1^2|w|
for all w e A, w =4 0 (see [140]); here Vi is the first vector in a reduced basis of A.
Suppose a is an algebraic number which we know only approximately; d and 
H are known upper bounds of the degree and height of a. Then a sufficiently good 
approximation a of a allows us to find the minimal polynomial h(x) for a.
If a is fixed, then we can find approximations of the powers az. Fix those 
approximations. Given a polynomial g(x) = g = ^i9ixi £ C[#], let
(8.23) 
g& = ]gjaj.
i
Fix n, 1 < n < d, and s e N. Consider the lattice Ls in Rn+3 spanned by the 
rows of the (n + 1) x (n + 3) matrix
/I ... 0 2sRea0 2sIma0 
(8.24) 
...................................................
\0 ... 1 2sRe an 2sIm an
Those rows will be denoted bi,... , bn+i e Rn+3. For the polynomial g = g(x) = 
E”=o 9ixi e zk]>let
71
(8.25) 
g = ^gibi e L3.
i=0
It is easy to see that
/ / 
n 
\2 
/ n 
\ 2 \
|g|2 = 9o + --- + ffn + 22s( (Re ^giaA +(lmJ2&aQ ) = |p(m)|2 + 22s|^|2.
' ' 
2=0 
' 
' 
1=0 
' '
Clearly, (8.25) gives rise to a one-to-one correspondence between polynomials in Z[rr] 
of degree at most n and the vectors of the lattice Ls.
The method for finding the minimal polynomial h(x) for a is based on the 
following idea. Let n = deg/i(rr) = deg a. Then for all polynomials g(x) e Z[rr], 
deg g(x) <n such that g(a) =4 0 we have
(8.26) 
|g|2 > 2n|h|2,
provided the quantities |al — are sufficiently small and s is appropriately chosen. 
We want to find a reduced basis of Ls. Let v be its first vector and v(x) the 
corresponding (under (8.25)) polynomial. Since h e LSi it follows from (8.22) that
|v|2 < 2n|h|2.

8.7. FACTORIZATION OF POLYNOMIALS USING APPROXIMATIONS
171
Then (8.26) implies that v(a) = 0, whence h(x) | v(x). Since degv(rr) < n = 
deg h(x), we have v(x) = h(x) • c, where c 6 Z. Since v is part of a basis of Ls and 
h e Ls, we see that c = ±1 and v(x) = ±h(x) is the desired minimal polynomial.
Now we give a detailed description and a proof of the correctness for this 
method.
Lemma 8.12. Let a, a0,..., an e C, = 1, and |al — aj < e, i = 1,..., n. 
Let f(x) e C[rr], deg/(rr) < n. Then
!/(<*) - fa\ < en|/|oo.
Proof. Indeed,
I/(a) - fa\ =
< |ne/|oo-
The lemma is proved.
□
Lemma 8.13. Let h(x),g(x) e Z[rr] \ {0}, deg/i(rr) = n, and deg g(x) = m. Let 
a e C, |a| < 1, h(a) = 0. Ifh(x) is irreducible and g(a) =4 0, then
|fl(a)| > i|/i(a;)|_m|p(a:)rn+1. 
n
Proof. If m = 0, then the inequality is obvious. Let m > 1. Consider the 
(n+m) x (n+m) matrix M whose zth column consists of the coefficients of xz~1h(x') 
for 1 < z < m, and the coefficients of rrl-rn-1 g(x) for m + 1 < i < n + m. Let 
R = | det Af| = |Res (/i(rr),^(rr))|. Then R =4 0, because h(x) is irreducible and 
g(a) =4 0. For i = 2,..., n + m, add the zth row of M multiplied by £1-1 to the 
first row and expand the determinant of M by the first row. We then have
R = |h(z) (a0 + aiz + • • • + am-1xm~1') + g(x)(cQ + • • • + cn-izn-1)|, 
where a*, Cj are minors of M. For x = a, we have R = |^(a)||cq H------1- cn-ian-1|.
By the Hadamard inequality,
icj < 
i^r1.
Since |a| < 1, we have |cq H------ 1- cn-ian-1| < n|/i(rr)|rn|^(rr)|n-1. The assertion of
the lemma now follows from the inequality R > 1. 
□
Lemma 8.14. Let s e N, a an algebraic number, |a| < 1, h(x) the minimal 
polynomial of a, deg/i(rr) = d > 1, and assume that the height ofh(x) is at most H. 
Let a0,...,ad 6 C, a0 = 1, |^i - az\ < for 1 < i < d. Let g(x) e Z[z], 
deg g(x) < d, g(a) =4 0. Suppose also that
(8.27)
2s > 2d2/2(d+ i)(3d+4)/27/2d.
Then (in the notation of (8.25),)
\h\<(d+l)H, \g\>2d/\d+l)H.
Proof. Clearly, for any polynomial f(x) e C[rr] with deg/(rr) < d, we have 
|/(^)|2 < (d+ l)|/(rr)|^o. Since |/i|2 = |/i(rr)|2+22s|/ia|2> and since, by Lemma 8.12, 
|^a| = 
~ ha\ < 2~sdH, we have
|/i|2 < \h(x)\2 + d2H2 < (d+l)tt2 + d2H2 < (d+1)2#2.

172
8. FACTORIZATION OF POLYNOMIALS OVER THE RATIONALS
Now we can prove the inequality for |<j|. If |p(rr)| > 2d/2(d + 1)U, then the 
desired inequality follows from the inequality |<j|2 = |p(a?)|2 + 22s|^ct|2- Suppose 
that |<7(s)| < 2d/2(d+ 1)H. By Lemma 8.13, we then have
। > 1 1 1 > 1 1 1
IPWI - d ' |/i(a:)|<< ’ |p(a:)|<<-i “ d ' ((d +l)ff2)d/2 ’ (2d/2(d + I)#)**-1
> 2-d(d-l)/2 .
Therefore
lsl>2s|fe|>2s(|P(a)|-|P(a)-fe|)
> 2s(2-rf(£/-1)/2(d+ l)-id > H~2d+1 — 2-sd|p(a;)|0O)
= 2S-^ (d+ l)"idH-2d+1 - d|<7(a;)loo.
Since |j(a:)|oo < |p(a?)| < 2d/2(d + 1)H, we also have
j2 
3 j
\g\ > H • 2d/2(2s“^ (d + l)"*dff"2d - d(d + 1)).
Taking (8.27) into account, we obtain the desired inequality |#| > #-2d/2(d+l). □
Theorem 8.15. Suppose s^hfx^d'h and at e 2-sZ[\/==T], i = 0,...,d, 
satisfy the assumptions of Lemma 8.14, including inequality (8.27). Let n 6 N, 
1 < n < L, and suppose the LLL algorithm for constructing a reduced basis applied 
to vectors bi,...,bn+i, which are the rows of (8.24), yields a reduced basis with 
first vector v = 
Then the following are equivalent:
1) |v| < 2rf/2(d + 1)U;
2) a is a root of v(x) = Y^=ovtxZ'>
3) deg a < n.
Moreover, if deg a = n, then h(x) = ±v(x).
Proof. By (8.22), we have |v| < 2n/2|w| for all w e Ls = Zbi H------ 1- Zbn+i,
w =4 0. Suppose 1) holds. Then Lemma 8.14 implies that v(a) = 0.
Clearly, 2) implies 3). Suppose 3) holds. Then deg/i(rr) < n, and therefore 
h is in Ls. By Lemma 8.14, we have |h| < (d + 1)H. Then (8.22) implies that 
|v| < 2n/2(d+ 1)U, i.e., 3) implies 1).
Finally, let deg a = n. As we have shown, v(a) = 0. Since h(x) is irreducible, 
the Gauss Lemma (see 8.1) implies that h(x) divides v(x) in Z[rr]; v(x) = h(x) • I, 
where I e Z. Hence v = h • I. Since v is an element of a basis of the lattice Ls and 
h e LSi we have I = ±1. 
□
Algorithm 1 (for computation of the minimal polynomial).
The input of the algorithm consists of upper bounds d and H for the degree and 
the height of an algebraic number a, |a| < 1, and an approximation a e Q+\/—IQ, 
|a| < 1, such that |a — a| < 2-s/(4d), where s is the smallest natural number such 
that
2s > 2d2/2(d+ l)(3d+4)/2U2d.
The output consists of the minimal polynomial of a.
Step 1. Find e 2-s(Q + IQ), i = 0,...,d, such that ao = 1, |c? — a;| < 
2-s-2, 1 < i < d. To this end, round off the real and imaginary parts of c? to s 

8.7. FACTORIZATION OF POLYNOMIALS USING APPROXIMATIONS
173
binary places. Then |al — a*| < 2 s, because
|al - a*| < 
- o*| + |o* - aj
1 
1 
9—3 
1 
1
< l« - *1 • E H + 2"S“5 < ~Tj~ -d + 2 s-5 <
J=0
Thus the assumption of Theorem 8.15 holds.
Step 2. (A cycle.) For n = 1,2,..., d, do Steps 3 and 4 until the minimal 
polynomial of a is found.
Step 3. Using the LLL algorithm, find a reduced basis for the lattice Ls = 
Zbo H------ 1- Zbn spanned by the rows of (8.24).
Step 4. If the first vector v of the reduced basis is such that |v| < 2d/2(d+l)#, 
then v(x) = VixZ (w^ere v = 
is a minimal polynomial of a.
End of algorithm.
The correctness of the algorithm follows from Theorem 8.15.
Remark 8.16. The inequality |a| < 1 is not a serious restriction. If |a| > 1 
and a is a root of h(x), then 1/a is a root of xde&h^ -ft(|) and |^| < 1. Moreover, 
if a is an approximation of a with |a — a| < e, where 0 < e < |, and (3 is an 
approximation of 1/a with \(3 — l/a| < e, then
la I la al I al |a|
Since |a| > |a| — |a —a| > |a| — |a|e > |, we have —/3| < 3e, i.e., approximates 
1/a up to 3e.
Theorem 8.17 (see [115]). Let a be an algebraic number, d and H bounds on 
the degree and height of a, and a an approximation of a such that |a — a| < ^d, 
where s is the smallest natural number for which (8.27) holds. Then Algorithm 1 
determines the minimal polynomial of a in O(d5(d+ log#)) arithmetic operations 
with integers of magnitude O(d2(d + log #)) bits.
Next, we consider factorization of polynomials. Let f(x) e Z[rr] be a fixed 
primitive polynomial, deg/(rr) = d > 2, and suppose we want to factor f(x) 
into a product of irreducible polynomials Z[rr]. If h(x) e Z[rr] is a factor of f(x), 
deg/i(rr) = n, then the height of h(x) is at most (nyX)|/(^)| + (j—i)larfl f°r 
j = 1,... ,n — 1, where ad is the leading coefficient of f(x) (see [118, Ex. 4.6.2.20] 
and [57, Theorem 3.5.1]). Assuming that n < d/2 (if f(x) is reducible), we may 
now choose, for the coefficients of the desired polynomial h(x), an upper bound H 
that is needed for Algorithm 1.
Algorithm 2 (factorization of f(x) in Z[rr]).
The input of the algorithm consists of /(rr), d, and H. It successively outputs 
the irreducible factors of f(x) until f(x) is completely factored in Z[rr].
Step 1. If d < 1, then f(x) is irreducible and the algorithm terminates.
Step 2. Find the smallest s e N such that
2s > 2rf2/2(d+ i)(3d+4)/2#2d.
Step 3. Compute (by any method) an approximation a G Q + zQ of some root 
a of f(x) such that |a — a| < (if lal < 1» then if suffices that the inequalities 
|a - a| < V hold)-

174
8. FACTORIZATION OF POLYNOMIALS OVER THE RATIONALS
Step 4. Applying Algorithm 1, find the minimal polynomial h(x) of a.
Step 5. Using trial divisions, find the largest k e N such that h(x)k | f(x) 
and output h(x) and k. This step can be skipped if f(x) is square-free; the square- 
freeness can be achieved as in the algorithm of 8.5.
Step 6. Replace d by d — fcdeg/i(rr) and f(x) by f(x)/h(x)k and return to 
Step 1.
End of algorithm.
The correctness of Algorithm 2 is obvious. Now we estimate its complexity. 
It only remains to choose a method for approximate calculation of the roots of 
polynomials from Z[rr] in Step 3 of Algorithm 2. There are various methods for 
solving this problem, see [25] and [57, Ch. 3]. In particular, there are algorithms 
of polynomial complexity in d, log |/(rr)|, and the number of required bits; see 
[115, 230]. Using such algorithms allows one to find a polynomial complexity 
estimate for Algorithm 2 (see [115, Th. 3.7]).
8.8. Summary
The appearance, in the 1980s, of the LLL algorithm for factorization of poly­
nomials in Z[rr] which depended polynomially on the length of the input, brought 
about a great deal of interest among mathematicians around the world. Up un­
til then, the complexity of the available algorithms for factorization of integers 
had been much worse, as we saw in Chapters 2-4. The LLL-reduced lattice bases 
found applications in many mathematical problems; some of them were described in 
Chapter 7. The method of [140] was further improved by several Russian authors; 
see, for example, [100, 56].
Besides the algorithms for factorization of polynomials in Z[rr] and Q[rr] de­
scribed in this chapter, there are also algorithms for factorization of polynomials 
with coefficients in number fields; see, for example, [57, Ch. 3].
Recently, the LLL-reduced bases have been applied in number field sieves for 
factorization and for the discrete logarithm problem; see, for example, [187]. This 
is mostly related to making an optimal choice of polynomials generating number 
fields.

CHAPTER 9
Discrete Fourier Transform and Its Applications
9.1. Introduction. Discrete Fourier transform and its properties
The discrete Fourier transform has important applications in number theory 
and algebra. It is described in detail in many texts; see, for example, [8, 189]. 
Here, we do not give a complete account. Instead we only describe basic properties 
and some important applications of the discrete Fourier transform. In particular, 
we prove a theorem that is necessary for the Pollard-Strassen algorithm of Chapter 
2; its proof is taken from [260].
We need some notation. Let t e N and n = 2*. Let R be a commutative ring 
with identity 1 containing 2-1, the inverse of 2. Assume also that R contains a 
fixed root of the equation xn + 1 = 0. Let Cn, — Cln-
Lemma 9.1. The root C^n generates a cyclic subgroup of order 2n in the mul­
tiplicative group of invertible elements of R.
Proof. Since = —the multiplicative order of ^2n equals 2f+1 = 2n. □
Definition 9.2. Let (/o, • • •, fn-i) £ Rn be an arbitrary vector.
The discrete Fourier transform of type 1 of this vector is the n-dimensional 
vector (/o,..., /n-i) 6 defined by
n—1
A = 
i = 0,...,n —1.
J=o
The discrete Fourier transform of type 2 is the n-dimensional vector (/i, /a, 
• • •, An-i) € Rn defined by
n—1
/i = Z<2n/y. i = 1,3,... ,2n — 1.
J=o
Remark 9.3. The elements fi are the values of F(x) = fjx^ at 
x = the elements fi are the values of F(x) at * = <2n for odd i.
The next lemma contains inversion formulas for the Fourier transform.
Lemma 9.4. Let n-1 = (2-1)* e R. Then:
(9-1)
>=0
(9-2) 
/i=n-1 £
l<j<2n-l 
j odd
175

176
9. DISCRETE FOURIER TRANSFORM
Proof. Let k e Z. Then = C?Zr fe, where r e Z, 2nr — k > 0. Moreover, 
since the multiplicative order of £n is n, we have
n—1
(9.3) 
=n when I = 0 (mod n),
J=o
n— 1
(9.4) 
= 0 when I 0 (mod n).
j=o
Equality (9.1) holds because
n—1 
n—In—1 
n—1 n— 1
E Acij = E E ac*cv = E E
j=0 
j=0 k=0 
k=0 j=0
as follows from (9.3) and (9.4). Equality (9.2) follows from
E AC? =EA*+l<2n(2fc+1)
l<j<2n—1 
fc=0
j odd
=£ £ /<d!.2t+‘)c(“+,)=£ 
£ e*>i.
fc=0 1=0 
1=0 
k=0
Taking (9.3) and (9.4) into account, we obtain (9.2). 
□
Notice that the computation of the discrete Fourier transform by directly us­
ing (9.1) and (9.2) requires O(n2) additions and multiplications in R. In the next 
section we shall give a method which allows to compute the discrete Fourier trans­
form in O(nlogn) operations. It is called the fast Fourier transform.
9.2. Computing the discrete Fourier transform
In this section we keep the notation and the assumptions from 9.1.
Theorem 9.5. The discrete Fourier transform (/o, • • •, fn-i) can be computed 
in nt additions in R and nt multiplications by the powers of in R.
The discrete Fourier transform (fi,..., fan-i) can be computed in nt additions 
in R and nt multiplications by the powers of C^n wi R.
Given (/0, • • •, Sn-i) or (/i,..., An-i), the vector (/0,..., /n-i) can be com­
puted in nt additions in R, nt multiplications by the powers of &n R> ond n 
multiplications by n-1 e R.
Proof. Let
n—1
= 
+ 52 f^ = F0(x2) + xF1(x2),
j=0 
0<j<n—1 
0<j<n—1
j even 
j odd
where degF0(rr), degFi(rr) < 
= 2*-1. Then
(9.5) 
^(C) = Wn) + C^i(C) i = 0, 
—1.
Let Cn/2 = <£• Then
{C I o < i < n — 1} = {c/2 | 0 < i < - 1}.

9.3. DFT AND MULTIPLICATION OF POLYNOMIALS
177
Now we use induction. Computation of the discrete Fourier transform of type 1, 
i.e., computation of (F(£°),..., F(£™-1)) by (9.5) can be done in n additions in R 
and n multiplications by the powers of (n in R if we already know Fq(£^/2) and 
Fi(^/2), i = 0,..., | — 1. If t = 1 and n = 2 = 2* (this is the basis of the 
induction), then, for computing (/o, /i), we need to determine Fo + £2Fi, where Fq 
and Fi are elements of F, i = 0,1. In other words, when n = 2, we need 2 = nt 
multiplications by the powers of = (2 in R and 2 = nt additions in R.
Assume now that, for all j < t, to compute the discrete Fourier transform 
of type 1 of a 2J-dimensional vector we need 2J • j multiplications by the powers 
C& = (£n)2< 3 in R and 2J • j additions in R. Then, for j = t, the computa­
tion of (/0,...,/n-i) by (9.5) consists of computing F0«^/2) and Fi«*/2) for 
i = 0,..., n — 1, i.e., of computing the Fourier transform for vectors of length n/2 
whose components are the coefficients of F0(rr) and Fi(rr), and an extra n additions 
in R and n multiplications by the powers of £n in R. In view of the induction 
hypothesis, the computation of (/o, • • • > /n-i) requires at most n additions in B, n 
multiplications in.B, plus 2 • 2f-1(£ — 1) additions in R and 2 • 2f-1(£ — 1) multi­
plications by the powers of (n in R. Thus, we need n + n(t — 1) = nt additions in 
R and n + n(t — 1) = nt multiplications by the powers of (n in R. This proves the 
first assertion of the theorem.
The proof of the second assertion is similar; it suffices to replace by ^2n-
The third assertion follows from the first two and Lemma 9.4. 
□
9.3. Discrete Fourier transform and multiplication of polynomials
In this section we show how the discrete Fourier transform can be used for fast 
multiplication of polynomials. We keep the assumptions and the notation of 9.1.
Lemma 9.6. A multiplication in R[x]/(x2t + 1) can be done in n = 2* multi­
plications in R, 3tn additions in R, 3tn multiplications by the powers of C^n wi R, 
and n multiplications by n-1 in R.
Remark 9.7. The lemma does not apply to R = Z or R = Q, because Z and 
Q have no <2n.
Proof. Let F = fixii G = 9tx\ and F, G e B[rr] be rep­
resentatives of some classes in R[x]/(x2t + 1). Let H = ^4=0 ^xZ F[rr] anc^ 
FG = H (mod xn + 1), i.e., H is the product of F and G in the quotient ring; we 
need to compute it.
The Fourier transform of type 2 for vectors (/o> • ••, /n-i) and (#0,..., #n-i) 
yields
fi9i = ^(dn)G(dn) = (dn) =
for odd z, 1 < i < 2n — 1, because <^ + 1 = 0. If we already know all fi and &, then 
all hi can be computed in n multiplications in R. By Theorem 9.5, all fi and fa can 
be computed in 2tn additions in R and 2tn multiplications by the powers of £2n in 
R. By the same theorem, all hi can be computed, if we know hi, in tn additions 
in B, tn multiplications by the powers of £2n in B, and n multiplications by n-1 in 
R. This easily implies the desired result. 
□
Corollary 9.8. Let T be a commutative ring with identity, 2-1 e T, and 
let (4n = £2*4-2 e T, be a root of x2n + 1. If F(x), G(x) e T[x], degF(z) < n, 

178
9. DISCRETE FOURIER TRANSFORM
and degG(rr) < n, then the product F(x) • G(x) e T[rr] can be computed in 2n 
multiplications in T, 6n(t + 1) additions in T, 6n(t + 1) multiplications by the 
powers of ^4n in T, and 2n multiplications by (2-1)*+1 in T.
Proof. By the bounds of the degrees of F(x) and G(rr), the polynomial F(x) • 
G(x) is of degree less than 2n, and is therefore equal to the remainder of F(x) • G(x) 
divided by 22n + 1. Therefore the product of F(x) and G(x) in /?[#] can be found 
in one multiplication in R[x]/(x2n + 1). The assertion of the corollary now follows 
from Lemma 9.1, where n is replaced by 2n and t by t + 1. 
□
Let T be a commutative ring with identity and with 2-1. When speaking of 
addition in T, we also mean subtraction. Henceforth, all constants in the symbols 
O(-) are absolute. The following lemma is fundamental.
Lemma 9.9. Ift>2, then one multiplication in T[x]/(x2t + 1) can be done 
in O{21 • f) multiplications in T and 0(2* • t • log£) additions in T.
Remark 9.10. This result can be applied to the ring of integers Z if T is chosen 
as follows:
T = 
| meZ,A:eZ>o}, T D Z.
In a computer, the elements of T can be represented precisely, say, as pairs (m, k).
Before giving a rather long proof of Lemma 9.9, we deduce from it the following 
important theorem.
Theorem 9.11. The product of two polynomials in T[rr] of degrees at most n 
(n > 3) can be computed in M(ri) = O(nlogn) multiplications in T and A(n) = 
O(nlognloglogn) additions in T.
Proof. Let t e N be such that 2*-1 < 2n < 2*. Clearly, t > 2, and 2n < 
2* < 4n. Therefore multiplication of two polynomials of degrees at most n modulo 
#2 + 1 is the usual multiplication. By Lemma 9.9, we can find their product 
in M(n) = 0(2* • t) = O(n • logn) multiplications in T and A(ri) = 0(2* • Hogtf) = 
0(n • log n log log n) additions in T. 
□
Proof of Lemma 9.9. Let F = F(x) and G = G(x) be polynomials of de­
grees at most 2* — 1, and H = H(x) = 
^i^2, where H = FG (mod rr2< + 1).
We need to find Ho,..., from the coefficients of F and G. Let k be a natural 
parameter, 1 < k < t, to be chosen later. We represent F and G in the form
F= 'F, G= 12
i=0 
i=0
where Qi(x) e T[a;], deg/; (a;) < 2* — 1, and deg&(a:) < 2fe - 1.
The algorithm for computing F • G is as follows.
Step 1. Multiply fi(x)Yi by 
in T[x, y]/(y2‘"fc - 1).
Let H = 
1 M^)^2 be the result.

9.3. DFT AND MULTIPLICATION OF POLYNOMIALS
179
Step 2. Substitute Y = x2 in H and reduce modulo x2 + 1 = Y2 + 1. 
Then
2<-fc —1 
2t~k-1
F(x)-G(x) = ^2 M3?1' 52 9iWx2ki
1=0 
j=0
2t~k — l
= ^2’ hi{x)x2kz (mod (rr2k)2< k + 1).
i=0
Thus, in Step 2 we can find H(x) = HiX\ provided we understand how in 
Step 2 the set {hi(x)} gives rise to the coefficients of Hi under reduction modulo 
x2t + 1.
In Step 1 we multiply
^t — k J. 
^t — k J. 
^t — k J.
Y, MY1- X MYj = £ ^(^(modr^ + l).
1=0 
j=0 
i=0
Here 1 + j < 2f_fc+1 — 2 < 2f_fe+1 — 1. Two cases are possible.
Case 1. If 0 < I +j < 2t-k — 1, then
Yl • Yj = Yl+j (mod Y2t~k + 1).
Case 2. If 2*“fc < I + j < 2 • 2l~k - 2, then
Yl+j = —Yz (mod Y2t~k + 1),
where i = I + j - 2t~k.
Therefore
M) = Y, 
Y 
MMh
l,j 
IJ
l+j=i 
l+j=i+2t~k
where i = 0,..., 2t-k — 1. This implies that deg hi(x) < deg fi(x) = deg gj(x) < 
2fc+i _ 2 < 2fc+1 - 1. Since k < t, we have deg hi < 2* - 1.
Step 2 requires at most 2* additions in T, because if we already know hi(x) =
Sj=Q hijX3, then, after the substitution Y = x2 , we have
2t“fc-l 2fc+1-l
^2 
^2 hijX^z2k (mod x2t + 1).
i=0 j=0
Reduction modulo x2t + 1 will apply to the summands with j + i2k > 2*. For 
j+i2k = r2t+li where 0 < I < 2f, the monomial x^z2k will be replaced by (—l)r-£z, 
i.e., the quantity (—l)r -hij should be added to the coefficient of xl (i.e., one addition 
or subtraction is required). The number of such additions will not be greater than 
the number of the summands, i.e., no greater than 2t-k • 2fe+1 = 2f+1. In fact, for 
0 < i < 2f-fe-1, we have
j + 2k • i < 2fc+1 - 1 + 2*-1 - 2k = 2k + 2*-1 - 1 < 2* - 1,
because k < t—1. Hence, for such z, no reduction is necessary. It remains to consider 
the values of i in the interval 2f-fc-1 < i < 2t-k — 1; there will be at most 2f-fc-1 
such values. Therefore, the number of pairs (2,7) which require reduction in Step 2 

180
9. DISCRETE FOURIER TRANSFORM
will be at most 2* k 1 • 2fc+1 = 2*. We have shown that Step 2 requires at most 2* 
additions in T.
Consider now Step 1. Instead of multiplying in T[rr, Y]/(Y2 
— 1), we can do
it in B[r]/(r2t k + 1), where R = T[rr]/(rr2k+1 + 1). Indeed, because deg/i(rr) < 
2k and deg^(rr) < 2fe, their product in T[z] coincides with their product in 
T[x\/(x2k+1 + 1). The ring R contains £2fc+2 = x (mod z2*'*1 + 1), which is a root 
of X2fc+1 + 1.
Let k = [t/2] > 1. Then
(9.6)
Since 2*_fe+1 < 2fe+2, the ring R contains £2t-fc+i, a power of £2fc+2.
One multiplication by a power of £2t-fc+i in R requires at most 2fe+1 additions 
in T, Indeed, since x = (2k+2 (mod z2k+1 + 1), we have
7? = {uo + fli^2fc+2 + • • • + a2k+1-iC2k+2 1 | Ui € T, i = 0,..., 2fe+1 — 1}.
Multiplication by C2t+k-i = C2l+2 together with the equality C2fe+2 = — 1, yields a 
permutation of the coefficients ao, ai,..., a2k+i_li with some of them changing the 
sign.
We shall now apply Lemma 9.6 to estimate the complexity of one multiplication 
in B[y]/(y2t k +1). We need to perform 2t-k multiplications in 7?, 3 • (t — k) • 2t-k 
additions in R (which makes 3 • (t — k) • 2t-k • 2fc+1 additions in T, because the 
elements of R can be represented as polynomials in T[a?] of degree at most 2fe+1 — 1), 
3-(£—k)'2l~k multiplications by the powers of £2t-fc+i in 7?, and 2*_fe multiplications 
by (2-1)*_fc in R (which again makes 2t-k -2fc+1 = 2*+1 multiplications by (2~1)t~k 
in T). In all, we have 2t-k multiplications in 7?, 6 • (t — k) • 2t+1 additions in T, and 
2*+1 multiplications by (2~1)t~k in T,
We also take account of 2* additions in T in Step 2. Let
(9.7) 
k(t) = k + l = [|1 4-1 >2.
L Z J
Then one multiplication in T,[rr]/(:r2^+1 + 1) requires 2* fc(*)+1 multiplications in 
R = T[x]/(x2k(t) + 1) together with at most 12 • t • 2* additions in T and 2*+1 
multiplications in T,
If t > 3, then k(t) < t. Using the above approach, we reduce multiplication 
in T[x]/(x2t + 1) to that in T[z]/(z2k(<) + 1) and further down until we reach the 
ring T[x]/(x4 + 1), where multiplication is done in any way in 0(1) additions and 
multiplications in T.
Let Mi(2J) and Ai(2J) be the number of multiplications and additions in T, 
respectively, that are necessary for performing one multiplication in T[x]/(x23 + 1) 
by the method described above. Then, for t > 3 we have
(9.8) 
Mi(2*) < 2f-fc^+1Mi(2fc(^) + 2*+1,
(9.9) 
Ai(2*) < 2*-fc(*)+1Ai(2fc(*)) + 12 • r 2*,
where k(t) is given by (9.7). Let
(9.10) 
a(j)=Ai(2>)/2< 7 = 2,3,... .

9.4. DISCRETE FOURIER TRANSFORM AND POLYNOMIAL DIVISION
181
Then a(t) < 2a(k(t)) + 12t Suppose that, for 2 < j < £, we have a(j) < cjlogj 
for some absolute constant c. Then
a(£) < 2ck(t) logfc(^) + 12£ < 2c(^ + 1) log(^ + 
+ 12£ < ctlogt,
provided c is large enough. Thus, Ai (2*) < 2* • ct log t = <9(2* • t log t), which proves 
the second assertion of Lemma 9.9 concerning the number of additions.
We now set
(9-11) 
(3^ = ^!, j = 2,3........
Then /3(t) < 2/3(fc(£)) + 2. Therefore
0(t) < 2(2/W(0)) + 2) + 2 = 22/WW)) + 22 + 2,
etc. Since k(t) < j + 1, we have k(k(t)) < | (j + 1) + 1 = 
+ 1 + | and
fc(fc(... (k(t)) ...))< 
+ 2 for all j > 1. Therefore, for j = [log2 J], we have
j times
/?(*) < 2J • Cl + 2 + 22 + • • • + 2j < 2j ■ Cl + 2j+1 < c2 • t,
where ci and c2 are absolute constants. Thus, Afi(t) = O(t ■ 2t). Lemma 9.9 is now 
proved. 
□
9.4. Discrete Fourier transform and polynomial division
We keep the assumptions and notation of 9.1. The functions M(n) and A(n) 
are the same as in Theorem 9.11.
Theorem 9.12. Let T be a commutative ring with identity and with 2-1. Let 
F(x),G(x) G T[a?], degF(z) < n, degG(z) < n, where n>3, and suppose an ele­
ment ofT is given which is the inverse of the leading coefficient ofG(x). Let F(x) = 
Q(x)G(x) + R(x), where Q(x), R(x) G T[a?], degE(z) < degG(z). Then Q(x) and 
R(x) can be computed in O(nlogn) multiplications in T and O(nlognloglogn) 
additions in T.
PROOF. We may assume that n = degF(z), m = degG(z), and m < n. 
Let F(x) = Y^i=QfixZ and = ^j=^9jx^ We need to find the elements 
Qo, • • •, Qn-m, ro,..., rm_i G T such that
n 
n—m 
m 
m—1
(9.12) 
52 fixi = 52qixi ■ 12 9ixj +12rixi-
2=0 
2=0 
j=0 
2=0
Replacing x by z-1 and multiplying by xn, we transform (9.12) into
n 
n—m 
m
(9.13) 
£ fix^ = 
9jXm-j (mod ^-m+1).
2 = 0 
2=0 
j=0
Let T[[z]] be the ring of formal power series of the form oq + a^x + a2#2 H---- with
coefficients in T, Let H = H(x) G T*[[a?]] be the formal power series which is the 
inverse of G*(x) = giXrn~z. Such H does exist, because the coefficient gm 
is invertible in T, Then, upon determining H (mod xN1) for some M G N and 
multiplying (9.13) by that quantity, we find Q(x) (mod xN1). For P G T[[z]], let 

182
9. DISCRETE FOURIER TRANSFORM
/(P) = £ - G* G TH if I e Th]] is defined. Clearly, f(H) = 0. For P e Th]], 
we set
(9.14) 
$(P) = 2P - P2G* = H - G*(P - P)2 G ThJ.
Suppose that P = H (mod xk) for some k G N. Then (9.14) implies that $(P) = 
P(mod x2k), Given an element P such that P = H (mod xk), we compute 
£(P) (mod x2k) as follows: truncate G* at x2k, multiply by (—P), add 2 and 
truncate again at x2k\ multiply the obtained element 2 + (—P)G* (mod x2k) by P 
and truncate at x2k. We then have
$(P) (mod x2k) = P(2 - PG*) (mod x2k) = H (mod x2k).
In other words, if P = P(mod xk), then $(P) = P(mod x2k), and we can find 
$(P) (mod x2k) by two multiplications of polynomials of degrees less than 2k in 
T[z] and one addition in T (adding 2).
We begin the iteration process with P = g-1 G T, where g = gm is the known 
leading coefficient of G(x). Then P = H (mod x). We now compute $(P) (mod z2), 
£(£(P)) (mod z4),..., £J(P) (mod z2J),..., where & denotes the map $ applied 
j times. Notice that £J(P) = P(mod x23\ and, in particular, S^(P) G Th]] are 
invertible. Let A* (k) and M* (k) be the number of additions and multiplications in 
T required to compute H (mod xk). We have shown that
(9.15)
A*(2k) < A*(fc) + 2A(2fc) + 1,
(9.16) 
M*(2k) < M*(k) + 2M(2fc).
Moreover, A*(l) = M*(l) = 0, because we know g-1 G T. It follows from 9.3 that 
M(n) = O(nlogn), and we may assume that M(n) = 
for n > 1 and
M(l) = Cm, where Gm is an absolute constant. Similarly, we may assume that 
A(n) = Cak log n log log n for n > 4 and A(n) = Ca for n = 1,2,3, where Ca is an 
absolute constant. Then M(x), Ah), and are increasing functions. It 
follows by induction from (9.16) that
(9.17)
M*(2f) <4M(2f).
Also, (9.15) implies that
(9.18)
Indeed,
A*(2f) <6A(2*).
A*(2f) < A*(2f-1) + 2A(2f) + !<•..
< A*(l) + 2(A(2) + A(4) + • • • + A(2*)) + t
, A(2f) A 71(2>) • 2*
2‘ 
A(2‘)
t i 2^(2t)
+ 
2‘ 
A(2t)/2t
t
j=l
the last inequality holds because the numbers A(2J)/2J increase. Therefore 
ot+i _ i
A* (2^ < t + 2A(2‘) • =—— < t + 4A(2‘) < 6A(2‘),
since t < 2A(2t).

9.5. APPLYING THE DFT TO THE POLLARD-STRASSEN ALGORITHM
183
Choose the smallest t G N such that 2* > n — m + 1. Then 2* < 2(n — m), 
provided n > m (when n = m, the computation of //(mod zn-rn+1) is trivial). 
The computation of //(mod zn-rn+1) will require at most A*(2f) additions and 
M*(2t) multiplications in T. It follows from (9.17) and (9.18) that we need at most 
6A(2(n — m)) additions and 4A/(2(n — m)) multiplications in T,
We now compute
H (mod ;rn-m+1) • ( 
(mod *n-m+1)
^2=0
and truncate the series at xn~m^1. By (9.13), we determine qiXn~m~\ In 
other words, we have determined the coefficients of the quotient in (9.12). Next, we 
find the product 
’ (Sj=o 9jx^) using one multiplication of polynomials
of degrees n—m and m in T[a?], and then determine Silo1 using one subtraction 
of polynomials of degrees at most n.
We want to estimate the number of performed additions and multiplications. 
The number of additions was at most
(9.19) 
6A(2(n — m)) + A(n — m) + A(max(m, n — m)) + n.
The number of multiplications was at most
(9.20) 
4A/(2(n — m)) + M(n — m) + A/(max(m, n — m)).
Quantity (9.19) is at most
6A(2n) + A(n) + A(n) + n = O(nlognloglogn), 
and quantity (9.20) is at most 4A/(2n) + 2M(n) = O(n\ogri).
The theorem is proved. 
□
9.5. Applying the discrete Fourier transform 
to the Pollard-Strassen algorithm
In this section we prove a theorem that is necessary for the Pollard-Strassen 
algorithm of 2.6. A proof of this theorem can also be found in [260, 32]. We keep 
the assumptions and notation of 9.1. When speaking of addition in T, we also 
mean subtraction.
Theorem 9.13. Let T be a commutative ring with identity and with 2-1. Sup­
pose we are given xi^,,,^xn G T and a polynomial F(x) G T[z] such that ei­
ther F(x) = 
or F(x) = nti(* “ yih and n = degF(z) > 3. Then
F(xi\... ,F(xn) can be computed in O(nlog2n x log log n) additions in T and 
O(nlog2 n) multiplications in T,
Proof. Let t be the smallest natural number such that n <2*. Let Xi = 0 for 
n < i <2t.
First, we compute the coefficients of the auxiliary polynomials
(9.21) 
Gij(X)= JJ (X-xk), 0<i<t, l<j<2‘-i.
fc=(j-l)-2i + l
For i = 0, we have Gqj(X) = X—xj; j = 1,..., 2*. Suppose that for some i, 0 < i < 
/—I, we have already computed the coefficients of 2*-2 polynomials Gij(X) of degree

184
9. DISCRETE FOURIER TRANSFORM
2\ Now we find the set of 
polynomials Gi+ij(X), j = 1,..., 2f_^+1\
of degree 2l+1 in 
multiplications of two adjacent polynomials Gij(X) of
degree 2\ Therefore, the entire set of polynomials (9.21) can be found in at most 
SiZo 2f_^+1^A(22) additions in T and at most 2t-^+1W(22) multiplications 
in T (the functions A(x) and M(x) are the same as in Theorem 9.11). The function 
A(x)/x is, by definition, increasing, because we do not work with the exact value 
of A(x) but only with an upper bound of the form Ca log (e log log (e, where Ca is a 
constant. Similarly, in place of M we use C^^log#. Then
„ 
z 
z
2=0
t—i— 1
2t-i“1M(2i) < iM(2‘-1).
2=0
The rest of the proof splits into two cases.
Case 1. The polynomial F(x) is of the form 5Z?=o/^2» i«e., the coefficients 
/o, • • •, fn £ T are known. Let Ft)i(z) = F(x) and, for 0 < i < t, 1 < j < 2*-2, let 
Fij(x) be the remainder of Fi+1 jj+ij((e) divided by Gij(x) (as i decreases, the range 
of j increases). Then, for 0 < i < £, 1 < j < 2*-2, and for (j — 1)22 < k < j • 22, we 
have
(9.22) 
F^Xk) = 
if (2j - 2)2i“1 < k < (2j -
(9.23) 
Fi^Xk) = F-^Xk) if (2j — l)2i-1 < fc < 2j2i-1.
This follows from the fact that if Gij(xk) = 0, then the values of the dividend and 
the remainder at Xk coincide. Indeed, if
Fij((e) = H(x) • Gi—it2j—i (#) + Fit2j—1(^)>
then in the proof of (9.22) we use the fact that Gi-i^j-ifak) = 0 for (2j — 2)22-1 < 
k < (2j—1)22-1; a similar argument works for (9.23). Therefore, the computation of 
F(x) = Ftii(x) at (Ei,..., x2t reduces to the computation of Ft-ij^) and Ft-ii2(x) 
at (Ei,...,x2t-i and (E2t-i+i,... ,(E2b respectively. In general, the computation 
of Fij((Efc), where (j —1)22 < k < j -22, reduces to the computation of Fi-i^j-i^fc) 
for (2j — 2)22-1 < k < (2j — 1) • 21-1 and of Fi-it2j(xk) for (2j — 1)22-1 < k < 
2j • 22-1, respectively. We thus proceed downward by the first index until we 
reach Foj((e), where 1 < j < 2*. But FOj((e) are constants; these are the remainders 
of F(z) divided by Goj((e) = x — Xj. In other words, Foj((e) = F(xj) are the 
desired quantities. We want to estimate the number of operations required to 
compute Foj((e). If all the polynomials Gij(x) have already been found, then we 
find the remainders F^-((e). Since deg Fi+ij ((e) < degGi+ij((E) = 22+1, we conclude 
from Theorem 9.12 (which applies because all Gij(x) are monic) that to find the 
remainder Fij ((e) we need
O(2i+1 log2i+1 loglog2i+1) < C'A • A(2i+1)
additions in T and
O(2i+1 log2i+1) < C'M • M(2i+1)
multiplications in T (C'A and C'M are some constants). Therefore to find all poly­
nomials Fij(x) with given Gij(x) we need at most ^ZiZo ’ -^(22+1)2f-2 additions 
in T and 5Z;Zq C'm ’ 
multiplications in T. Similarly to the proof of

9.6. SUMMARY
185
the theorem from the previous section, the number of additions is then bounded 
by C^L4(2f), and the number of multiplications by 
where CUA and
are some constants. Taking into account the complexity estimate for computing all 
polynomials G^(X) established earlier and the inequality 2* < 2n, which implies 
that t = O(logn), we have the desired result in the case considered.
Case 2. Let F(x) be of the form H?=i (x~yi\ Then we have already shown that 
the coefficients of Gtti(x) = Hfc=i = x2t~n Hfc=i(^—can be computed using the 
required number of additions and multiplications in T, After this computation, we 
are under the assumptions of Case 1, for which the theorem is already proved. □
9.6. Summary
The use of the discrete Fourier transform in polynomial arithmetic is justified 
by its practical efficiency. The discrete Fourier transform can also be used in integer 
arithmetic. In particular, it can be used to prove the Schonhage-Strassen theorem: 
The product of two n-bit binary numbers can be computed in O(n log n log log n) bit 
operations. In practice, however, the Schonhage-Strassen algorithm is inefficient, 
although it has the best complexity estimate among the algorithms for integer 
multiplication. The constant in O(-) for the estimate is too big, which makes it 
practical only for numbers with several thousand decimal digits; see [22, 231, 292]. 
In the next chapter we shall describe efficient algorithms for multiplication of large 
integers.


CHAPTER 10
High-Precision Integer Arithmetic
10.1. Introduction. Addition and multiplication
In this chapter we describe basic algorithms for arithmetic operations with large 
numbers, as well as some algorithms in residue rings Z/nZ.
We assume that the numbers are written in base &, where & is a fixed natural 
number, b > 2. A natural number requiring at most n digits in the &-base system 
is denoted ui... un (assuming that some of the leading digits ui,..., Uk may be 
zero). The base b is not always equal to 2; sometimes it corresponds to the size 
of the machine word used to store integers. In that case we work with an array 
containing a large integer.
When working with large integers, it is convenient to store the sign of that 
integer in a separate cell or variable. If, for example, we want to multiply two 
numbers, then the sign of the product is computed separately.
We remark that assembler languages are better suited for implementation of 
high-precision arithmetic.
We begin with addition and subtraction.
Algorithm A (addition of nonnegative integers).
For two nonnegative integers ui... un and ... vn we want to compute their 
sum wo ... wn\ the carry digit wo is always 0 or 1.
Step 1. Set j := n, k := 0 (here j keeps track of the position, and k keeps 
track of the carry digits).
Step 2. Set Wj :=Uj + Vj + k (mod &); Wj is the smallest nonnegative residue 
in the given class;
7 [Uj +Vj + ki 
k'= 1 I, ]■
(Notice that Wj is the current digit, k is the carry, and that always k = 0 or k = 1. 
Moreover, if b = 2 or b is the size of the machine word, then the computation of Wj 
and k does not require division; it suffices to take the corresponding digit (or digits) 
in the representation of Uj +Vj +k.)
Step 3. Set j := j — 1. If j > 0, then go to Step 2; if j = 0, then set wq := k 
and stop.
End of algorithm.
The correctness of the algorithm is obvious.
Algorithm S (subtraction of integers).
Given two n-digit nonnegative integers u = Ui,. ,un > v = Vi,, ,vn > 0, 
compute their difference w = wi... wn = u — v.
Remark 10.1. In general, to verify that u\... un > Vi.. .vni we have to run 
through the digits and compute Uj — Vj, This is a simple check; it allows us to find 
the sign of u — v in the general case.
187

188
10. HIGH-PRECISION INTEGER ARITHMETIC
Step 1. Set j := n, k := 0 (the variable k is a carry from a higher-order digit). 
Step 2. Set Wj :=Uj — Vj + k (mod &), the smallest nonnegative residue in the 
given class;
k:= L f, J-
Step 3. j := j — 1. If j > 0, then go to Step 2; if j = 0, stop.
End of algorithm.
The correctness of the algorithm is clear. For j = n we determine wn = un — vn 
if un > vn and wn = b + un - vn if un < vn, Accordingly, k = 0 and k = -1 are 
the carry from the (n — l)th digit. The rest of the argument is similar.
10.2. Multiplication
Here we describe several methods for multiplication of integers that give rise 
to efficient algorithms.
Algorithm M (column multiplication of nonnegative integers).
For &-base integers u = Ui... un and v = Vi... vm we want to compute their 
product w = uv = wi... wm+n.
Step 1. Set wm+i := 0,..., wm+n := 0, j := m. (The value of j moves from 
lower-order to higher-order digits of v.)
Step 2. If Vj = 0, then set Wj := 0 and go to Step 6. (This step can be skipped. 
But if b is small, for example, b = 2, then Vj equals zero with high probability. In 
that case, Step 2 results in significant savings.)
Step 3. Set i := n, k := 0. (The value of i moves from lower-order to higher- 
order digits of u, and k keeps track of the carry.)
Step 4. Set t := Ui • Vj + w^j + fc, Wi+j := t (mod &), the smallest nonnegative 
residue in the given class; k := [t/b], (As in 10.1, when computing Wi+j and 
fc, sometimes we can skip the division. It is easy to show that 0 < t < b2 and 
0 < k < 6.)
Step 5. i := i — 1. If i > 0, then go to Step 4. If i = 0, set Wj := k. 
Step 6. j := j — 1. If j > 0, then go to Step 2. If j = 0, then stop.
End of algorithm.
The correctness of the algorithm will be proved by induction.
Let j = m. If vm = 0 in Step 2, then the last n + 1 digits of w will be zero. 
If vm > 0, then in Step 4, we in fact determine Uibn~zVjbm~j = UiVjbm+n~(z+^ 
and add it, together with the carry fc, to the digit Wi+j. This yields the actual 
value of the digit w^j and the next carry k. In the end, when j = m, after 
Steps 2-5 we have found wmwm+]_ • • • ujm+n = u • vn. This is the basis of the 
induction.
Assume now that we have run through Steps 2-6 I times and have determined 
the true value of u • (vm-i+1 vm-i+2 
... wm+n- Then,
after Step 6, j = m — Z, we go to Step 2 and compute u • vm-i • bl. Running 
again through the digits un,... ,ui, we determine Uibn~zvm-ibl = UiVjbn+l~z and 
accordingly change the digit at the position n + m — (n + l — i) = i+j. This finishes 
the brief proof of the correctness of Algorithm M.
Now we want to describe a multiplication method due to Comba; see [60, 
59]. We shall call this method the “fast column multiplication”. We want to 
multiply u = Ui... un = ^=1 Uibn~z by v = Vi... vm = Vjbm~j. Assume 
that n > m. In Algorithm M we needed, besides mn multiplications UiVj and 

10.2. MULTIPLICATION
189
some additions, a certain number of calls to the memory. More precisely, the 
elements Vj were read m times, the elements Ui were read mn times (n times for 
each fixed J), the elements vh+j were read mn times and their new values were 
recorded mn times. Thus, we need mn multiplications and about 3mn calls to the 
memory. In Algorithm M we computed uv by the formula
(10.1) 
uv = uvjbm~i.
>=i
There is also another formula:
m+n—2 
z s 
\
(10.2) 
UV = b ( y^n—s+i ) >
s=0 
'i=0 
'
where for I < 0 we set ui = Vi = 0. Indeed,
7n4-n—2 
n— 1
UV — 
b 
Un—iVm—j — 
Un—iVm—s^.ib
s=0 
i=0 i<s<m— 1+i
(10.3)
V 7 
0<j<m-l 
m+n_2
= 
^n—i^m—s+i*
s=0 
s—m+l<i<s
Formula (10.3) is equivalent to (10.2). Indeed, if s — m+1 < 0, i.e., s < m — 1, then 
for i < 0 the quantity un-i equals 0 by definition. If s — m + 1 > 0, i.e., s > m — 1, 
then for 0 < i < s — m + 1 we have i + m — s < 1 and vm_s+i = 0 by definition.
Now we can use (10.2) to multiply u and v.
Algorithm FM (“fast column multiplication”).
Step 1. t := 0.
Step 2. (A loop.) For s from 0 to m + n — 1, do Steps 3 and 4 with Step 1.
Step 3. For i from 0 to s, do t := t + un~i • with Step 1.
Step 4. Set wm+n_s := t (mod &), the smallest nonnegative residue modulo b 
(again, this is not a division but a call to the memory if b = 2 or b is the size of the 
machine word); t := [t/b].
End of algorithm.
The correctness of the algorithm follows from (10.2).
The number of multiplications here is the same as in Algorithm M, because 
each Ui is multiplied by each Vj, only in a different order. But the number of 
memory calls drops: we read Ui and Vj the same number of times as the number of 
multiplications, i.e., 2mn times (mn calls for Ui and mn calls for Vj), We also need 
m + n memory write operations for wm+n_s. In the end, the number of memory 
write operations needed for the “fast column multiplication” is substantially smaller 
than that in Algorithm M, and implementation of Algorithm FM gives a sizable 
saving of time (if the program is written in an assembly language and if b is the 
size of the word in that assembler).
Next we describe Karatsuba’s method for integer multiplication (see [116]). 
Suppose we have two 2n-digit binary numbers:
u = u2n-i •••Uq, v = v2n-i • • • vo-

190
10. HIGH-PRECISION INTEGER ARITHMETIC
Let u = 2nu' + u", v = 2nv' + v,z, where
U = U2n—1 • • • ^71, 
= ^n—1 • • • ^0>
v' = V2n-1 
v" = ^n-1 - - - ^0-
Then
(10.4) 
uv = (22n + 2n)u'v' + 2n(u' - u")(v" - v') + (2n + l)u"v"
Therefore, to multiply two 2 n-digit numbers (10.4) we need three multiplications of 
n-digit numbers and 0(1) additions, subtractions, and shifts of 4n-digit numbers, 
which requires <9(n) bit operations. If T(n) is the number of bit operations required 
for multiplication of two n-digit numbers, then
(10.5) 
T(2n) < 3T(n) + cn,
where c is some absolute constant. It follows by induction from (10.5) that
(10.6) 
T(2fc) < c(3fe - 2fc), k = 1,2,3,... .
Indeed, when k = 1, we have T(2) < c (with an appropriate choice of c). Now, 
if (10.6) holds for fc, then
T(2fc+1) < 3T(2fc) + c2k < 3c(3fc - 2fc) + c2k = c(3fc+1 - 2fc+1).
Since multiplication of two n-digit numbers reduces to that of 2llog2 nl+1-digit num­
bers (the higher-order bits, if necessary, are set equal to zero), it follows from (10.6) 
that
T(n) < T(2[log2nl+1) < c3[log2 nl+1 < ci3log2n = cinlog23.
This is an upper bound on the number of bit operations required for multiplication 
of two n-digit numbers in Karatsuba’s method.
Karatsuba’s method becomes more efficient than the “fast column multiplica­
tion” for sufficiently large numbers. According to various sources, the border line is 
somewhere between the numbers of magnitude 2450 and 2640. Since, in Karatsuba’s 
method, multiplication of 2n-digit numbers reduces to that of n-digit numbers, af­
ter several steps in Karatsuba’s method we reach the numbers for which the “fast 
column multiplication” is more efficient, and using it we finish the multiplication. 
This yields a practical algorithm for integer multiplication.
Remark 10.2. Karatsuba’s algorithm has later been generalized by Toom and 
Cook; see [259, 62]. In particular, one can show that for the Toom-Cook algorithm
T(n) = O(n2v/21°e2niOg2 n).
The Toom-Cook algorithm is described in [118, §4.3.3]. The modular Schonhage 
method can also be found there. The Schonhage-Strassen algorithm, which we 
briefly mentioned in Chapter 9, has a complexity estimate that is even better than 
that of the Toom-Cook algorithm.
In [84] and [278], one finds methods for a parallel high-precision integer mul­
tiplication.

10.3. DIVISION
191
10.3. Division
In this section we describe high-precision division methods for integers.
We begin with an algorithm for dividing a multidigit number by a one-digit 
number.
Algorithm DO (division by a one-digit number).
We need to find the quotient w = wi... wn of a &-base number u = u\... un 
divided by a one-digit number f, 1 < v < &, together with the remainder r = u—vw.
Step 1. r := 0, j := 1.
Step 2. w — j := [rb^]; r := rb + Uj (mod v), the smallest nonnegative 
residue in the given class.
Step 3. j := j + 1. If j < then go to Step 2. If j > n, then output 
w = wi... wn and r.
End of algorithm.
The correctness of Algorithm DO is obvious: this is the usual division.
Now consider a simple division algorithm for multidigit integers; see [163, 
Ch. 14]. Let b be the base of the number system, u = un ... uiUq and v = Vt.. .ViVq 
natural numbers, n > t > 1, v* =4 0 (the case t = 0, i.e., division by a one-digit 
number, is considered in Algorithm DO).
Division algorithm.
The input consists of integers u, v\ the output, of the quotient q = qn-t... go 
and the remainder r = rt... ro, u = qv + r, 0 < r < v.
Step 1. For j from 0 to n — set qj := 0.
Step 2. As long as u > do the following:
gn-t := gn_f + 1, u := u -
(this determines the leading digit of the quotient).
Step 3. For i = n, n — 1,..., t + 1, do items l)-4):
1) if Ui > vti then set qi-t-i := b — 1; else, set
[Uib + Ui-ii
:= I Vt h
2) if qi-t-itytb + vf_i) > Uib2 + Ui-ib + Ui-2i do
Qi—t—1 •= Qi-t-i — 1;
(notice that qi-t-i > 0 always holds);
3) set u := u — qi-t-ibz~t~1v'i
4) if u < 0, then set
u := u + 
qi-t-i := Qi-t-i ~ 1-
Step 4. r := u. Output q and r.
End of algorithm.
We want to show that the algorithm is correct. After Step 1, q = 0. After Step 2 
we have the leading digit qn-t of the quotient; the current value of u is smaller than 
vb71-1. Take the first value of i = n; we need to determine the digit qn-t-i of the 
quotient. If un > Vt (inequality 1) of Step 3), then the largest possible value 
of qn-t-i equals b — 1 (for example, for un = b — 1 and Vt = 1). If un < vti then

192
10. HIGH-PRECISION INTEGER ARITHMETIC
the largest possible value of qn-t-i equals 
1], Indeed,
mi-1 _i_ in, 
+ un-il
unb + un_\b + • • • + Uq < ( -------------- + 1 Jo D,
V L vt J 
/
since a stronger inequality holds:
unbn+• • •+u0 < \ L vt -I /
= 
+Un-11 +Xn-l„t
VL 
J /
The latter is true because
Unbn + un-1bn~1 = (Unb + Un-^b71-1 < 
+ 
+
\L vt J /
and, since both sides of the strict inequality are divisible by bn~1) adding to the left­
hand side the quantity un~2bn~2 +-----1- uo, which is less than bn~1) preserves the
inequality. Thus we have justified the first part of Step 3. Here the quantity qt-t-i 
is not less than the true value of the (i — t — l)th digit of the quotient and not 
greater than b — 1, because for vt > un + 1 we have
runb + un—i j < runb + Un-i ~1   b>-|- 
~ ^1 <
L 
JL Un + 1-1 L Un + 1 J
In the second part of Step 3 we find a more precise value of qt-t-i- Indeed, let
(10.7) 
(Qn-t-i + l)(ytb + Vt-i) > unb2 + un_]b + un-2,
(10.8) 
qn-t-il^tb* + Vt-i) < unb2 + un~ib + un-2>
The first inequality implies that
bn t 1(Qn-t-i + l)(^t^ + Vt-xb* !) > unbn + un_]bn 1 + Un-2>
Since both sides are divisible by bn~2 and un_$bn~3 + • • • + uq < bn~2i we have 
&n-*-1(Qn-t-i + 1) (vt6* + Vt-rb^1) > u,
A fortiori &n-f-1(gn_t_i + 1)d > u\ hence, qn-t-i + 1 is greater than the desired 
digit of the quotient, whereas qn-t-i is smaller.
Suppose that (10.8) holds for the found value of qn-t-i. We shall show that 
qn-t-i is either the true digit of the quotient or is greater than that digit by 1. 
Assume the opposite. Then qn-t-i is greater than the true digit by at least 2, i.e., 
(10.9) 
u < (qn-t-i -
Therefore
unbn + un-ibn 1 + un~2bn 2 < (qn-t-i — l)bn t + • • • + Vq).
Applying (10.8), we have
qn-t-i(vtb+ vt-i)bn 2 < (qn-t-i — l)bn * 1(vtbt + Vt-ib* 1+vt~2bt 2H------ Fdo).
Using the divisibility by bn~2 and the inequalities vt-2bt~2 +-----1- Do < bt-1 and
0 < Qn-t-i < b, we have
qn-t-i(ytb + vt-i)bn~2 < (qn-t-i - 
+ Vt-ib*-1),
which is impossible.

10.3. DIVISION
193
Thus the value of qn-t-i found in he second part of Step 3 either equals the 
true value or is greater than that value by one. This implies the correctness of the 
third and fourth parts of Step 3.
After running Step 3 for i = n we have
u = unbn + • • • + uq < vbn * 1 = bn * 1(vtbt + • • • + Vo).
This implies that un = 0. Therefore we return to the value i = n — 1 in Step 3, etc.
We have justified Step 3 for i = n, For the smaller values of i all arguments 
are repeated verbatim.
The correctness of the algorithm is established.
Now we describe a more sophisticated algorithm for high-precision integer di­
vision, as expounded in [118, Ch. 4]. We only give slightly more detailed proofs 
of the auxiliary assertions compared to [118]. Notice that [118] also contains a 
flowchart of this division algorithm.
Let u = uq ... un and v = Vi... vn be base-& nonnegative integers such that 
> 0 and u/v < b. We need to find the quotient of u divided by v,
(10.10) 
g = [«/«],
0 < q < b — 1. Finding q under the above assumptions will be referred to as the 
principal problem.
Notice that u/v < b if and only if u/b < v, which is equivalent to
(10.11) 
UQ,,,un-i < Vi ,,,vn.
Let
,in 
I a
(10.12) 
q = mm^-----------j, b — 1J.
It is not difficult to compute q; one only needs to find the quotient of the two-digit 
number UQb + u± divided by the one-digit number Vi (see Algorithm DO above).
Theorem 10.3. Under the assumptions of the principal problem, q > q.
Proof. Since q = [u/v] <b—l, the theorem is true for q = b— 1. Let q < b — 1. 
Then q = 
This implies that
(10.13) 
qvi > UQb + ui — Vi + 1.
Indeed, if G Z, then (10.13) holds, because Vi > 1. If is not an 
integer, then 
where k G N, 1 < k < Vi — 1. Then
Uob + u\ k UQb + ui Vi — 1 
q =------------------>-------------------------,
V1 
V1 
V1 
Vi
whence (10.13). Using (10.13), we have
u — qv < u — qvib71-1
< uQbn~2 + -..+un- (uQbn + U1&71-1 - vrf71-1 + b71-1)
= u2bn~2 + -" + un- b71-1 + vU)71-1 < Vib71-1 < v.
Finally, since u > qv and u < (g + l)v, we have the desired inequality q > q, □
Theorem 10.4. If, under the assumptions of the principal problem, vi > \b/2], 
then
q-2<q.

194
10. HIGH-PRECISION INTEGER ARITHMETIC
Proof. By Theorem 10.3, q < q. Therefore, assuming that q < q — 2, we will 
come to a contradiction. Let q > q + 3. By definition,
. < uob + ui _ uobn + Unb71-1 u 
~ -Ui 
Vibn-1 
v — &n-1
Moreover, v > &n-1, because if v = &n-1, then q = [^] = Uob + ui, and by 
assumption, q < b — 1. This implies that q = Uob + u\ = q, contrary to the 
assumption.
Since q is a quotient, q > u/v — 1. Then
u 
v
bn-l
V — &n-1
u
V
u
v — &n-1
Therefore
6n-i
V — &n-1
2,
u 
V 
u v — &n-1 
v > 
&n-1
Since q < b — 1, we have
b — u> q — 3 > g = [u/v] > 2^i — 2.
Therefore ^i < | — 1, ^i < [&/2], contrary to the assumption of the theorem. □
Remark 10.5. We have shown that if > [6/2], then the trial quotient q 
never differs from the true quotient q by more than two.
Now we turn to the normalization problem: under the assumptions of the 
principal problem, how does one satisfy the assumption of Theorem 10.4? It turns 
out that one needs to multiply u and v by 
Notice that the quotient q will
not change and we will have the following theorem.
Theorem 10.6. Under the assumptions of the principal problem, the leading 
digit ofv' = vis at least [b/2], and v1 is still n-digit. Moreover, u' = ^[^I+i] 
is at most (n + 1)-digit.
Proof. First we show that if a, c € N, 1 < a < c, then
(10.14)
The second and the third inequalities in (10.14) are obvious; we shall prove the 
first inequality. We begin with the case a > [c/2]. Then, since c > a + 1, we have 
a[^+i] - a - [f]•
Assume now that 1 < a < [c/2]. Then
a\—1 > a(—- 1) > J - 1 > H - 1.
La + 1J \a+ 1 
/ “ 2 
“ L2J
Here we used the fact that
c \ c i 2ac — 2a2 — 2a — ca — c + 2a + 2
a + 1 
/ a + 1 
2a + 2
_ ac — 2a2 — c + 2 _ (a — l)(c — 2a — 2) >
2a + 2 
2a + 2
because the inequality a < [c/2] < c/2 implies that a + 1 < c/2, c > 2a + 2. This 
proves (10.14).

10.3. DIVISION
195
Now we can prove Theorem 10.6. Set a = v± and c = b in (10.14). Then
(10.15)
b‘
(10.16) 
vi [—1 < (vi + 1) [—^—] < b.
Liy + lJ 
Liy + lJ
Since one of the inequalities (10.16) is strict, (10.15) and (10.16) imply that
(10.17)
But Vi [y^yy] is not yet the leading digit of because of the possible carry from 
the lower digits. But if that carry is strictly less than [yyyy] > then the leading 
digit of v1 will be strictly less than (^i + l)[y^yy], and this number is at most b. 
Therefore v1 is still n-digit. It remains to show that the carry for the lower digits 
of v1 to the nth digit is strictly less than [y^yy].
The carry from the last digit of v1 to the next will be at most
r(6-l) [_^1 _ [/ _ 11 [_^r [_6_[ 
L b Liy + lJj IA b/L^ + lJJ Liy + lJ
because 1 — | < 1. Now we apply induction: suppose that the carry from the 
(j + l)th to the jth digit is strictly less than [y^yy]. Then the carry from the 7 th 
to the (j — l)th digit will be at most
Thus we have proved that vf remains n-digit. It follows from (10.17) that the 
leading digit of v1 will be at least [b/2]. Finally, u' will be at most (n + l)-digit 
because ¥7 = - < b. 
□
V V
Now we describe an algorithm for high-precision integer division based on The­
orems 10.3-10.6.
Algorithm D (division of nonnegative integers).
For &-base numbers u = ui...um+n and v = Vi.. .vni where =4 0, we want 
to find the quotient [yj = Qo • • • Qm and the remainder r = u — qv = ry... rn. Here 
m > 0. If n = 1, then apply Algorithm DO. Henceforth we assume that n > 2.
Step 1. (Normalization.) Set d := [yyyy] ,
UqUi ... um^.n := Ui... 
• d, tq ... Vn *= Vi... vn • d.
(Theorem 10.6 implies that the new value of is greater than or equal to [6/2].)
Step 2. j := 0.
Step 3. (Providing the assumptions of the principal problem.) Set I := 0. If 
uj...uj+n > then assumptions of the principal problem hold; we go to Step 4. 
If ul..Uj+n < b then 
V 
1
Uj ... Uj-j-ji Uj ... Uj-j-ji bv I.— I + 1.

196
10. HIGH-PRECISION INTEGER ARITHMETIC
Again verify the inequality ur--^+n < if it holds, go to Step 4. Else, set once 
more
Uj ,,, Uj+n :— Uj ... Uj+n bv I — Z 4~ 1.
Remark 10.7. We claim that < b after Step 3, i.e., the assumptions of the 
principal problem hold. Since > [d/2], we have v = Vi.. .vn > [b/2]bn~1, We 
also have Uj ... Uj+n < &n+1 — 1. We shall show that
(10.18) 
Uj ... Uj+n < 3bv.
Indeed,
3bv > Zbvib71-1 > 3bn[b/2] > 6n+1 - 1 > Uj ... Uj+n 
because the inequality
3 • 2n[2/2] > 2n+1 — 1
is obvious for b = 2, and for b > 3, either \b/2] = b/2 or \b/2] = | — |, and then
1 + 3bn[b/2] > 1 + 3bn - - I') = 1 + -6n+1 - -bn > bn+1 
2 
2/ 
2 
2 
because |&n+1 > |&n. Thus Uj .. .Uj+n < bv after Step 3.
Remark 10.8. The value of the variable I shows that we subtracted Ibv from 
the original value of Uj ... Uj+n. Later we will need to add lb to the corresponding 
digit of the resulting quotient in Step 9.
Step 4. (Finding q.) In this step we have Uj < Vi, because if Uj > Vi, then 
UjUj+i... Uj+n — b • vi.. .vn> Ujbn - (vibn + v2bn~1 H- 1- vnb)
>bn- (y2bn~r + • • • + vnb) > 0, 
contrary to the assumptions of the principal problem, which do hold.
If Uj = Vi, we have [^b^+1] = [& + 
> &, and we then set q := b — 1.
If Uj < Vi, then 
] < & — 1 because otherwise
v>j b + u j _|_ i 
—--------— > □, Ujb + Uj+i > bviy
^1
which is impossible since
b — 1 > uj+i, b(yi — Uj) > b.
In this case we set
= p^ + ^+i]
Step 5. Verify the inequality
(10.19) 
v2q > (ujb + Uj+i - qvi)b + Uj+2,
If it holds, then q := q — 1. Verify (10.19) again, and if it holds, then set once more 
q:=q-1.
Remark 10.9. Since n > 2, we see that v is at least two-digit, and u = 
uq .. .um+n is at least three-digit; hence the digit Uj+2 is determined.

10.3. DIVISION
197
Remark 10.10. After Step 4, the assumptions of Theorems 10.3 and 10.4 
hold. Therefore, q — 2 < q < g, i.e., q equals either g, or q + 1, or q + 2. Set 
r := Ujb + Uj+i — qvi, which is the parenthesized part of (10.19). We show that if 
(10.20) 
v2q > f& + uj+2,
then g > g. Indeed, we need to show that
Uj ... Uj+n — qv < 0.
We have the following relations: 
(10.21)
Uj ... Uj+n — qv<Uj... Uj+n - qvrbn~r - qv2bn~2
= Uj+2bn~2 H------ 1- Uj+n + Ujbn + Uj+ib71-1 - qVib71-1 - qv2bn~2
= f&n-1 + Uj+2bn~2 H------ 1- Uj+n - qv2bn~2
< rb71-1 + (uj+2 + l)bn~2 - qv2bn~2
= bn~2(fb + Uj+2 + 1 - qv2).
If inequality (10.20) holds, then in (10.21) we have
fb + Uj+2 + 1 — qv2 < fb + u?+2 + 1 — (fb + U7+2) = 1.
Therefore
fb + Uj+2 + 1 - qv2 < 0, 
and (10.21) implies that
Uj ... Uj+n — qv < 0,
i.e., g > g + 1. Therefore, we need to replace g by g — 1, and this will be the best 
approximation to g. This part of Step 5 runs at most two times because g < g + 2, 
by Theorem 10.4.
Remark 10.11. Now, for the current value of g, which satisfies the inequality 
g < q < g + 2, and for f = Ujb + Uj+i — qv^ we have the inequality
(10.22) 
v2q <bf + Uj+2,
We show that in this case g equals either g or g+ 1. Assume the opposite, i.e., 
g = g — 2. Then
Uj ... Uj+n < (q - l)v < g(vi&n-1 + (v2 + l)bn~2) - v 
< qvib71-1 + qv2bn~2 + b71-1 - v
because qbn~2 < &n-1, by the definition of g. Therefore, taking (10.22) into account, 
we have
Uj ... Uj+n < qvib71-1 + (bf + Uj+2)bn~2 + b71-1 - v
(10.23) 
= qvib71-1 + (u,jb2 + Uj+ib + Uj+2 - qvrb)bn~2 + b71-1 - v
< Ujbn + Uj+ibn * + Uj+2bn 2
because b71-1 — v > 0. Formula (10.23) means that Uj ... Uj+n < Uj ... but 
this is impossible.
Thus g equals either g or g + 1.

198
10. HIGH-PRECISION INTEGER ARITHMETIC
Step 6. Find the difference
(10.24) 
Uj ... qvi • • • Vfi
and enter its absolute value in Uj ... Uj+ni and its sign, in the variable 6.
Step 7. qj := q. If difference (10.24) is nonnegative, go to Step 9.
Step 8. Set qj := qj — 1 (because difference (10.24) is nonnegative in this case, 
q = q+ 1), and
Uj ... Uj+n := 
.. .vn — Uj ,,, Uj+n.
Step 9. Add lb from Step 3 to qj.
Remark 10.12. In Step 3 we forced the assumptions of the principal problem 
by subtracting Ibv from the original number Uj ... Uj+n. Therefore, we should add 
lb to the found quotient qj of the new (after Step 3) number Uj... Uj+n divided 
by v. After this the value of qj need no longer be a &-base digit, it may be greater 
than b.
Step 10. In the current value of the number Uj ... Uj+n the digit Uj equals 0 
because it is in fact a remainder of a division by an n-digit number Vi.. .vn. Set 
j ;= j + 1. If j < return to Step 3.
Step 11. The desired quotient of u divided by v equals
q := 
+ qibm 1 H-----+ qm-ib + qm
(here the qj need no longer be &-base digits; see the remarks in Step 9). The 
remainder of u divided by v equals
^m+l • • • ^m+n 
r = r1...rn:=----------- ------------ ,
where d is from Step 1 and um+i... um+n is the value obtained after the last run 
of Step 10.
End of algorithm.
The correctness of the division algorithm has been proved in its description.
Remark 10.13. A description of some algorithms for high-precision arithmetic 
can be found in the monographs [69, Ch. 9] and [163, Ch. 14]. For a survey of 
algorithms of high-precision arithmetic, see [35].
10.4. Some algorithms of modular arithmetic
In this section we describe some algorithms for computations in residue rings 
Z/nZ.
We begin with the Chinese Remainder Theorem. In the Appendix we give the 
statement of this theorem intended for solving the system
(10.25)
x = ai (mod mi), 
< ............................
x = ak (mod m^),
where (m<, mj) = 1 for i =4 j. That form of the theorem is constructive, i.e., it gives 
a method for solving (10.25). In some cases, however, Garner’s algorithm is more 
efficient; see [118, §4.3.2], [94], and [163, Ch. 14]. Unlike the classical Chinese 
Remainder Theorem, it does not require reduction modulo M = mi • • • m^.

10.4. SOME ALGORITHMS OF MODULAR ARITHMETIC
199
Garner’s algorithm.
The input of the algorithm consists of numbers a1}..., a&, mi,...,m,k such 
that (m^, mj) = 1 for i =4 j, and the number M = mi • • • m^. The output is a 
solution x of (10.25), 0 < x < M,
Step 1. For i = 2,..., fc, do 1) and 2):
1) 
:= 1;
2) for j = 1,..., i — 1, do: u := m^ 1 (mod mi) (the inverse can be computed by 
means of the generalized binary algorithm; see the Appendix), Ci := uci (mod mi).
Step 2. u := ai, x := u.
Step 3. For i = 2,...,fc, compute u := (ai — x) Ci (mod mi), the smallest 
nonnegative residue modulo mi;
i— 1
x := x + u JJ mj.
J=i
The obtained value of x is the desired solution.
End of algorithm.
We now show that Garner’s algorithm gives the correct answer and that 0 < 
x < M. We assume that 0 < ai < mi — 1 for i = 1,..., k. Then, by construction,
k 
i—1
0 < x <mi~ 1 + (mi — 1) JJ mj = mi • • • m^ — 1 = M — 1.
i=2 
j=l
Now, Ci = (mi • • -mi-i)-1 (mod m^ for i > 2. Clearly, x = (mod mi). Denote 
by Xi the value of x obtained after Step 3 for the variable value i (2 < i < fc); 
xi = ai. Then
i—1
Xi = Xi-1 + ((a» - Xi-i)Ci (mod mJ) JJ mj, 
■ , >=1 
/ 2— 1 
x
Xi (mod mi) = Xi-^ai — Xi-i) • ( Ci JJ mj I (mod m^ = ai (mod m>i).
' j=i 
/
By construction, the final value of x in the algorithm satisfies the congruences 
x = Xi (mod mi), i = 1,..., k. Therefore Garner’s algorithm is correct.
Now we briefly describe modular multiplication and exponentiation, as ex­
pounded by Montgomery; see [69, Ch. 9], [163, Ch. 14], and [174]. Fix a natural 
number N > 1 and a natural number R such that R > N and (E, TV) = 1. We 
choose R so as to make calculations modulo R easy (for example, R is the size of 
the machine word or a power of two). Let R',N' e Z be such that
0 < R' < TV, RR' - NN' = 1
(/?' and TV' can be found by the generalized Euclidean algorithm; see the Ap­
pendix). For an integer T, 0 < T < RN, we can efficiently find the smallest 
nonnegative residue in the class TR' (mod TV) using the following algorithm (here, 
R' = R-1 (mod TV)).
The REDC algorithm (Montgomery reduction).
Step 1. m := T (mod B), the smallest nonnegative residue.
Step 2. m := mN' (mod E), the smallest nonnegative residue.

200
10. HIGH-PRECISION INTEGER ARITHMETIC
Step 3. t :=
Step 4. If t > TV, then output t — TV; otherwise output t.
End of algorithm.
We now show that the algorithm is correct. Since the value of m obtained in 
Step 2 satisfies the congruence
mN = TN'N = -T (mod R),
the value of t obtained in Step 3 is an integer. Now, tR = T + mN = T (mod TV), 
i.e., t = TR-1 (mod TV). Finally, 0 < T + mN < RN + RN, whence 0 < t < 2TV. 
This shows that the REDC algorithm is correct.
Notice that we consider calculations modulo R (including division by R) to be 
fast. Consequently, the complexity of the REDC algorithm is concentrated mainly 
in two multiplications of integers of absolute value at most R.
There is a similar description of the high-precision Montgomery reduction for 
integers, Montgomery multiplication (i.e., for x,y e Z and TV e N we compute 
xyR~r (mod TV)), and Montgomery exponentiation (i.e., for z, TV, e e N we compute 
xe (mod TV)); see [69, Ch. 9], [163, Ch. 14], and [174]. Montgomery exponentiation 
is efficient and is recommended for practical purposes; see also [34].
Yet another algorithm for an efficient modular exponentiation was given in 
[104]. The authors claim that their algorithm is more efficient than the Montgomery 
algorithm.
Computation of x (mod m) for given x and m is efficiently done by Barrett’s 
algorithm; see [34] and [163, Ch. 14]. In [69, Ch. 9], one finds fast algorithms for 
modular computations with special moduli, for example, for a modulus TV = 2q + c, 
c e Z, q e N, or a Proth modulus, which is of the form TV = k • 2q + c.
A number of methods for exponentiation of elements of finite groups, as well 
as for representations of the exponents, can be found in [163, §§ 14.6, 14.7].
We now briefly mention another algorithm of Montgomery, which for a given 
TV e N and given ai,...,afc 6 Z determines 6i,... 
6 Z such that aibi =
1 (mod TV) for i = l,...,fc. This algorithm is described in [57, Ch. 10]; it can 
also be used in the elliptic curve factorization algorithm for integers; see Chapter 4. 
It allows one to work simultaneously with several curves.
Algorithm.
Step 1. Set ci := ai and, for i = 2,..., fc,
Ci := Ci-i • ai (mod TV).
Step 2. Using the generalized Euclidean algorithm or one of its modifications 
(see the Appendix), find u, d, v such that uck + vN = d = gcd(cfc, TV).
Step 3. For i = fc, k — 1,..., 2 do the following:
1) bi := uci-i (mod TV);
2) output b^
3) u := uai (mod TV).
The obtained value of u is the desired quantity.
End of algorithm.
We now show that the algorithm is correct, provided that (ai,TV) = 1 for 
i = 1,..., fc, i.e., d = 1 in Step 2. Clearly, Ci = ai... ai for i = 1,..., k. Therefore, 
after Step 2, u = (ai... Ufc)-1 (mod TV). Then in Step 3, bk = a^1 (mod TV) for 

10.4. SOME ALGORITHMS OF MODULAR ARITHMETIC
201
i = k, and then u = (ai... afc-i)-1 (mod TV). It is now clear that bi = a^1 (mod TV) 
for alH, 1 < i < k.
A number of algorithms for computations in finite fields and residue rings was 
developed by Wu; see [287, 288, 289, 286]. In particular, [287] contains an 
improvement of the Montgomery methods for multiplication and exponentiation in 
the fields GF(2m), and [289] deals with the Montgomery reduction for moduli of 
a special form, for example, TV = 2n — 2m — 1, 0 < m <


CHAPTER 11
Solving Systems of Linear Equations 
over Finite Fields
11.1. Introduction
In this chapter we consider several algorithms for solving systems of linear 
equations over finite fields. As we saw in Chapters 3 and 5, such systems appear 
in computations of the discrete logarithm using factor bases. In factorization algo­
rithms these are sparse systems over Z/2Z. In the discrete logarithm problem with 
prime modulus p these are linear systems over the residue ring Z/(p — 1)Z, but the 
solution problem for such systems reduces to that for linear systems over a finite 
prime field. Indeed, suppose
N
(11.1) 
djjXj = bj (modp — 1), i =
7=1
is a system to be solved, with unknowns #i,..., x^. If p — 1 = nl=i Qk* the 
prime factorization of p — 1, then, by the Chinese Remainder Theorem, solving 
(11.1) reduces to solving the systems
N
(11-2) 
^aijXj=bj(modq%k), j =
7=1
for k = 1,...,t, that is, to finding Xj (mod q^k\ For a fixed fc, we represent the 
unknown quantities Xj (mod q£k) in the form
(11.3) 
Xj = Xj0 + Xjiqk + ■■■+ Xjiak-1q^k~1 (mod q%k),
where 0 < Xji < qk — 1, I = 0,1,..., 
— 1. Reducing (11.2) modulo g^, we have
a linear system
N
(11.4) 
y^ajjXjo = bj (mod qk), j =
3=1
over the finite prime field Z/g^Z. If we find all XjQ, j = 1,... ,7V, substitute Xj, 
written as (11.3) with unknowns XiQ, in (11.2), and reduce the resulting sys­
tem modulo q% and divide by g^, then we obtain a linear system over Z/g^Z 
in the unknowns Xji, j = 1,... ,2V, and so on. In the end, having determined 
Xj (mod g£fc) for all fc, we find Xj (mod p — 1) using the Chinese Remainder Theo­
rem.
Later in this chapter we consider methods of solving systems of linear equations 
which are most frequently used in modern algorithms for factorization and for 
computation of the discrete logarithm. Moreover, in 11.2 we describe methods for 
solving linear systems in integers.
203

204
11. SOLVING SYSTEMS OF LINEAR EQUATIONS OVER FINITE FIELDS
11.2. Solving linear systems in integers
In this section we consider two algorithms for solving linear equations over the 
integers. In fact, they are generalizations of the Euclidean algorithm.
First, consider the case when the system consists of a single equation
(11-5)
^1*^1 + ’ ’ ’ + ^71*^71 —
where ai,...,an, d e Z. We give an algorithm for finding the integer solutions 
xi,..., xn of (11.5). To this end, construct an (n + 1) x n matrix
(
til . . . Uti\
,1..0
0 ... 
1/
whose first row consists of the coefficients ai,..., an, and the remaining rows form 
the identity matrix. In one run of the algorithm we do the following.
1) In the first row of A, choose a nonzero element ai of smallest 1) absolute 
value.
2) 
Choose an index j =4 i such that aj 0.
3) 
Divide with remainder: aj = qai+r, 0 < r < \ai|.
4) 
Subtract the zth column of A multiplied by q from the J th 4) column.
As a result, we have a new matrix A in which the position previously occupied 
by aj is now occupied by either 0 (if r = 0) or an element which is less than the 
smallest absolute value of the elements in the first row of the original matrix A.
Clearly, after several runs of the algorithm (i.e., several runs of 1)—4)), the 
original matrix A becomes
(H-6)
/ 0 ... 
0 A 0 
... 0\ 
/0 ... A ... 0\
Cn . . . 
— i Cig £l,s+l • • • ^Iti ___
............................  - 
c
\cnl . . . Cn)S—i Cns Cn)S_|_i . . . Cnny y 
]
where A, Cij e Z and A 0. If A { d, then (11.5) has no integer solutions. If A | d, 
then the general integer solution of (11.5) is of the form
(11-7)
X1 \ 
d
. . . I — ^Ci + • • • + ^s-iCs-1 + yCs + Cs+1 + • • • + ^7ic7i, 
Xn /
where ti,..., ts-i, £s+i, • • •, tn run through the integers and Ci,..., cn denote the 
columns of C in (11.6).
We show that (11.7) indeed yields all integer solutions of (11.5). Clearly, after 
a single run of the algorithm (i.e., after running l)-4)) A transforms into ADij, 
where Dij is of size n x n and has ones on the diagonal, — q at the intersection of the 
zth row and jth column, and 0 elsewhere. It is an integer matrix with det Dij = 1; 
therefore the inverse matrix D”1 is also integer. Rewriting (11.5) in a vector form, 
we have
(zA
... I = b.
Xn /

11.2. SOLVING LINEAR SYSTEMS IN INTEGERS
205
Then
(
Xi \
... I = b.
/
Consider new variables
(
yi\ 
Mix
... UD7.1 ... .
Vn / 
\®n/
They satisfy a^yi 4----- V^nVn = b, where (a'p..., a'n) = (ai,..., a^Dij. The values
?/i,..., yn are integers if and only if Xi,..., xn € Z.
After k runs of the algorithm for the indices «i,71,^2,72, • • • we have a 
system of equations in unknowns zi,..., zn\
( zi\ 
(X1\
I ... I =D~1- 
I ... I .
I l ik3k ^1131 | 
1
xn
\%n
If the first row of A is now
(0,..., 0, A, 0,..., 0) = (<2-i,..., cbn)Di1j1 • • • Dikjk,
then the system is of the form
(11.8) 
Azi = b.
If A | &, then it has no solutions, and if A | &, then the general solution of (11.8) is of 
the form (zi,..., zn) = (ti,..., t8_i, |, ts+i,..., £n), where ti,..., tn run through 
the integers. Then
• • • I = -^lji ’ ’ ’ BikJk
Is—1 
b/X
It remains to notice that the matrix C in (11.6) equals Di1j1 • • • Di-k,jk because 
the remaining rows of the original matrix A were subject to the same opera­
tions as the first row, i.e., the identity n x n submatrix of A was multiplied by
> ^232, • • •, Dikjk.
Now consider an arbitrary linear system
allxl + ’ ’ ’ + O'ln^n — &1,
(H-9)
^Tnl^l 4“ * * * 4“ dmn%n 
bmi
where a>ij,bi e Z. We describe an algorithm for finding all integer solutions of (11.9). 
Let A be an m x n matrix, and let B be an (m + n) x (n + 1) matrix whose rows 
under A form the identity n x n matrix:
/ Qu . . . 0>in \ 
4= ...................... , 
B =
1 ... 0 0
^ml • • • ^mn
\0 ... 1 0 / 

206
11. SOLVING SYSTEMS OF LINEAR EQUATIONS OVER FINITE FIELDS
On the first n columns of B we can perform the following operations:
1) interchange two rows;
2) subtract an integer multiple of one row from another row.
We can also interchange any two of the first m rows of B.
Using these operations, we make B partially triangular:
/ un
0
0
0
... 
0
-fc'l \
U21
U22
0
0
... 0
-b'2
Ukl
Uk2
• • • Ukk
0
... 0
~b'k
(11.10)
^fc+1,1
Wfe+1,2
• • • Uk+l,k
0
... 0
~b'k+i
Uml
Um2
• • • Umk
0
... 0
~b'm
Cll
C12
. .. Clk
cl,fc+l
••• Cln
0
\ cnl
cn2
••• Cnk
£n,fc+l
• • • Cnn
0 /
for some k > 1, k < min(m, n), and Un 0,..., Ukk ± 0- (The elements b[, ..., b'm 
form a permutation of &i,..., bm, obtained by permuting the first m rows of B.) To 
transform B into (11.10), we need to make all elements except one in the first row 
of B (without the last element —&i) equal to zero (as in the previous algorithm), 
and then move the column containing that element to the first place. The same 
should be done with the second row of the new matrix (without changing its first 
column), etc.
After a matrix Bi of the form (11.10) is constructed, we transform it into
(11.11) 
B2 =
Uli
0
0
0
.. 0
^21
U22
0
0
.. 0
Ukl
Uk2
Ukk
0
.. 0
Uk+1,1
Ufc+1,2 • •
Uk+ltk
0
. 0
Uml
U-7H2
Umm
0
. 0
Cll
C12
Clfc
cl,fc+l
• fin
£nl
cn2
cnk
£n,fc+l
fnn
For that, we multiply the first k columns of Bi by integers and add them to the last 
column. More precisely, we multiply the first column of B2 by the integer b\Ju\\ 
and add it to the last column, thus making the first entry of the (n + l)th column 
zero. Then, using the second column and U22, we make the second entry of the 
(n + l)th column zero, etc.
If it is impossible to transform (11.10) into (11.11) by the above operations, 
then (11.9) has no integer solutions. If we did find B2 from (11.11), then the general 
integer solution of (11.9) is of the form
fl \ 
/cl,fc+l\ 
/cln
•••1+^1 I ••• H----- + tn-k I • • •
fn / 
\Cn,fc+l / 
\Cnn
where ti,..., tn-k run through the integers.

11.3. GAUSSIAN AND STRUCTURED GAUSSIAN ELIMINATION
207
The correctness of this algorithm for solving (11.9) is established similarly to 
that of the algorithm for solving (11.5); it is left to the reader as an exercise.
11.3 . Gaussian and structured Gaussian elimination
Let K be an arbitrary field. Consider a linear system
n
(11.12) 
^2aijxj=bii i =
over K. It is well known that it can be solved by Gaussian elimination, i.e., by 
making the system triangular. The complexity of this method is 0(mn2) arithmetic 
operations in K. Making the system triangular also allows one to compute the 
determinant of an n x n matrix in O(n3) arithmetic operations, find the inverse, 
and find the kernel and the image of a linear map between finite-dimensional linear 
spaces. Those algorithms are well known; see, for example, [25, 93], and [57, 
Ch. 2].
To solve linear systems appearing in the discrete logarithm problem, a new 
method of structured Gaussian elimination was developed; see [197, 128, 127]. It 
is used when the matrix of the system is sparse. It can be described as follows. The 
columns of the coefficient matrix are broken into two classes: “light” (containing 
few nonzero elements) and “heavy”. The unknowns Xj corresponding to the light 
(resp., heavy) columns are also referred to as light (resp., heavy). The rows of 
the matrix (corresponding to the linear equations) will also be broken into two 
categories: light and heavy parts of the matrix. In the beginning, the light part 
of the matrix consists of the equations containing some unknown that enters only 
one equation (this means that, using that equation, the unknown can be uniquely 
expressed in terms of the remaining unknowns). The column corresponding to such 
an unknown contains only one nonzero element; we declare it light.
Now consider a column which is not light but still has only few nonzero ele­
ments. This column is chosen in such a way that one of the rows containing this 
column’s nonzero elements has zeros in almost all the other columns. Then, sub­
tracting multiples of rows, we can make all the elements of that column except 
for the one corresponding to the chosen row, equal to zero. After that, the given 
column becomes light, and we declare the row corresponding to its nonzero element 
also light. Most of the remaining columns do not become heavier because of the 
choice of the row that was subtracted from other rows. We move this row into the 
light part of the matrix. As a result, we will obtain a few more light rows. However, 
because we subtracted some rows of the matrix, it will have new nonzero elements. 
In other words, the matrix becomes less sparse. We then move some rows into the 
heavy part of the matrix. We choose those rows in such a way that they have the 
largest number of nonzero elements in the most sparse columns. As a result, those 
columns become more sparse in the light part of the matrix. Some of them will 
then be made light (by the above method, i.e., by subtracting rows), and so on.
Eventually, our system will have a subsystem whose matrix is not sparse, and 
whose unknowns are heavy (i.e., the corresponding columns are heavy). Then 
we solve that system (using, for example, Gaussian elimination or the Lanczos 
algorithm). Having found the heavy unknowns, we then find the light unknowns 
from the light part of the matrix.

208
11. SOLVING SYSTEMS OF LINEAR EQUATIONS OVER FINITE FIELDS
This is the idea behind structured Gaussian elimination. The efficiency of its 
implementation depends on the qualifications of the programmer.
Structured Gaussian elimination has been used not only for computing discrete 
logarithm but also in the number field sieve; see [142, 139].
11.4. The Lanczos algorithm
The Lanczos algorithm was introduced in [132]. Later, that algorithm was 
modified and used for solving linear systems appearing in the discrete logarithm 
problem; see [127, 73, 275]. A block version of the Lanczos algorithm, which is 
efficient for solving linear systems over GF(2), can be found in [176]. A parallel 
modification of the Lanczos algorithm is described in [73].
Let K be a field, A an n x n matrix over K, and b 0 an n-dimensional vector. 
We want to solve the linear system
(11.13) 
Ax = b.
Assume in addition that A is symmetric and bTAb 0. Consider a Krylov se­
quence S consisting of the n-dimensional vectors So, si,S2,..., where
(11.14) 
s0 = b, Si = AT) = Asi-i, z = l,2,....
Lemma 11.1. Let m 6 N and suppose that So,..., sTO_i are linearly independent 
over K and So,... ,sm are linearly dependent. Then any element of S is a linear 
combination of s0,..., sm_i.
Proof. Since sm = ajsj^ where otj e K, we have, by (11.14), that 
sm+i = Asm = 13^=0 aJsJ+i + arn-i SjLo ajsj- The rest of the argument is 
clear. 
□
Henceforth the parameter m is defined as in Lemma 11.1. Consider the stan­
dard scalar product (x,y) = 
where x = (sq,... ,zn), y = (3/1,... ,yn).
For vectors x and y, let
(x,y)^ = (x,Ay) = xTAy = (Ax,y) € K;
the expression (x, y)^ will also be called a scalar product of vectors.
We want to make the Krylov sequence orthogonal with respect to the scalar 
product (x, y^A using the Gram-Schmidt process, i.e., to find a sequence of vectors 
wq, wi, W2,... such that
(11.15)
and
(wi,wj)A = 0 when i^j
(11.16)
Wo = So,
Wi = Si - a 10w0, 
< ......................................................................
Wi = Si — OioWQ — ... — Qi’i-iWi-1,
where e K. Moreover, if i > j and (wj, wj)a ± 0, then will be defined by 
(Wi, = (Si, Wj)A - 
= 0.

11.4. THE LANCZOS ALGORITHM
209
The orthogonalization process continues until we reach an index k such that
(11-17)
(wfc,Wfc)A = 0.
Lemma 11.2. During the orthogonalization process, we will have (11.17) for 
some k <m.
Proof. By (11.16), the vectors so,...,Si are expressed in terms of vectors 
w0,..., Wi via a triangular matrix with ones on the diagonal. Therefore, the vectors 
w0,..., w; are linearly independent if and only if s0,..., are linearly independent. 
Suppose we already have vectors wq,..., wm, i.e., (11.17) does not hold for k < 
m. Thus, the vectors wq, ..., wm_i are linearly independent and wq, ..., wm are 
linearly dependent, and therefore wm = ciwi, ci But then, by the 
orthogonality condition, 0 = (wm, w^) = Ci, i = 0,..., m — 1, i.e., wm = 0. 
□
Lemma 11.3. Suppose the orthogonalization process ends with a vector w^. // 
Wfc = 0, then k = m; ifwk 0, then k < m.
Proof. The proof of Lemma 11.2 shows that w& cannot be zero for k < m, 
because s0,... , are linearly dependent. Therefore, if w& = 0, then k = m. If 
k = m, then wm = 0 (see the proof of Lemma 11.2). 
□
We now return to system (11.13). Suppose that its solution is of the form
(11.18)
(11.18) 
x = ^2ciWi, ci e K,
2=0
for some r > 0. Since Ax = cMwi = b, we have
(w£,b)= 
cMwj) =ci(wi,wi)4.
j=o '
If (w^w^Ti 7^ 0, then Ci = (w^, b)/(wi, w^)^. Now we may assume that the 
solution of (11.13) is of the form
Lemma 11.4. Suppose the orthogonalization process ends with k = m, that the 
vectors wq,..., wTO_i are linearly independent, and = 0. Then formula (11.19) 
with r = m — 1 yields a solution of (11.13).
Proof. For the vector x from (11.19), we have
Therefore Ax —b is orthogonal (with respect to the standard scalar product) to the 
vectors wq, ..., wm_i, and is thus orthogonal to the linear space (2 = L(S). Since 
AJ2 C (2, we have
(11.20)
(Aw, Ax — b) = 0 

210
11. SOLVING SYSTEMS OF LINEAR EQUATIONS OVER FINITE FIELDS
for any w G Q. Since b = s0 G (I and Ax G £2, we also have Ax — b = ZXo1
Xi G K. It now follows from (11.20) and the symmetry of A that
z 
m—1 
\ 
m—1
0 = Mwy, ^2 Aiwi) = 52 
j = 0,...,m-l.
' 
2=0 
' 
2=0
Therefore Aq = • • • = Am~i = 0 and Ax = b. 
□
Remark 11.5. If during the orthogonalization process of the Krylov sequence 
we obtain the zero vector, then we find a solution of (11.13).
The Lanczos algorithm is based on a modification of the orthogonalization 
process (11.16). Consider a sequence of vectors Wq, wj,... that satisfy
(11.21)
'w'o = So = b,
W; = Awq - ttlOWg, 
< ................................................
w' = Aw<_x - 
Uijw'-,
(where a'^ G K) and are orthogonal, i.e.,
(11.22)
(yv'i, w'j)A = 0 when i j.
The coefficients a1^ are given by
(11.23)
, = (Aw^pw')^
Uij (w;>w<)a
provided that (w'-jw')^ 
0.
Lemma 11.6. If for some i, the vectors Wi and w- are defined, then w^Wi.
Proof. For i = 0 we have w'o = s0 = wq. Suppose w- = for alH < t and 
assume that wf+i and w£+1 are defined. Then w^+1 = Awf — at+ijwj- 
Since the vectors satisfy (11.16) and = A2b, we have Awt = Af+1b — 
■^(Sz=oQ^wO = 
- 53z=oatzwi f°r some ati e Therefore, w£+1 =
Af+1b — Sz=oQt+izw^ For the vector Wf+i from (11.16), we have a similar 
equality wt+i = Af+1b — 2z=oQi+i^w^ Then, by the induction assumption, 
wj+1 — Wf+i = Aw* (w^ere A € K) is orthogonal to the vectors wq, ..., wt. 
Therefore, 0 = (J3z=o Awb wj)x = A(w>,wj)a = 0 for j = 0, ...,L Since 
(wj,Wj)A 7^ 0, we then have (3j = 0, j = 0,..., I and wj+1 = wt+i. 
□
It follows from (11.21), (11.22), and Lemma 11.6 that if vectors and w' are 
defined, then (11.23) can be written in the form
(Aw-.w,), 
3 (wj,wj)a
Therefore, for j < i — 1, we have
a, = (wi-i.Awj)^ = (Wj-!, wj+i + Y,3=o a'j+1,i^i)a
13 (yvj,v'j)A 
(wj.wjh

11.5. THE WIEDEMANN ALGORITHM
211
For j +1 < i — 1 it now follows that = 0. This means that (11.21) is of the form
A 
(Wi-1, AWi-Jyi 
(Wi-i, Awi-2)A
(11.25) 
Wi = Awi-i - 
- ■)------------ -----------(-wj-2,
(Wi-i, Wi-1)A 
(Wi-2, AWi-2M
i.e., it only has three summands in the right-hand side. Because of that, computing 
by this formula is faster than computing by formulas (11.16).
The Lanczos algorithm works as follows. We compute the sequence of vectors 
w0 = b, wi, w2,..., using (11.21), (11.23), and (11.25) (provided the assumptions 
of Lemma 11.6 hold). If at some point a vector 0 is constructed such that 
(w^w^a = 0, then we will not find the solution of (11.13) by this method. If we 
construct wm = 0, then the solution x is given by (11.19) for r = m — 1. This 
should be checked because we assumed certain conditions.
In algorithms for factorization and for computing discrete logarithm, the ma­
trix A of (11.13) is not symmetric (and not even square). One should then randomly 
choose a diagonal matrix D and consider the system
(11.26) 
AtD2Ax = ATD2b.
Its matrix AT£)2?1 = (ZM)T.D?1 is square and symmetric, and we can apply the 
Lanczos algorithm. If the algorithm fails or the found vector x is not a solution 
of (11.13), then one should choose another matrix D.
A homogeneous system Ax = 0 can be transformed into a nonhomogeneous 
one, provided that xn 0 for a solution vector (a?i,..., xn). Setting then xn = 1, 
we can move the column of the coefficients corresponding to xn to the right-hand 
side and then apply the Lanczos algorithm.
For further details of implementation issues for the Lanczos algorithm, see the 
excellent thesis [73].
11.5. The Wiedemann algorithm
In this section we describe the Wiedemann algorithm [280] for solving a linear 
system
(11.27) 
Ax = b, b^O,
over the finite field K = GF(g). The matrix A is assumed to be sparse; w denotes 
the number of nonzero entries of A. We assume that A is of size n x n and non­
singular; other cases and an algorithm for computing the determinant of a matrix 
can be found in [280]. The Wiedemann algorithms have best complexity estimates 
in the class, and their application allows one to improve complexity estimates of 
other algorithms for solving linear systems. In particular, Algorithm 2 described 
below is deterministic and requires 0(n(w + n log n log log n)) operations in the 
field. We remark that for some time after the publication of [280], the Wiedemann 
algorithms were viewed as impractical and useful only for improving complexity 
estimates. But in recent years, the algorithms were implemented on the computer 
and were used, for example, to factor polynomials over finite fields; see [111]. There 
are now various modifications of those algorithms; in particular, we mention the 
block Wiedemann algorithm; see [64, 74, 110, 112, 160].
We return to the problem of solving system (11.27). The matrix A determines 
a nondegenerate linear map (also denoted A) of Kn. Consider the space S spanned 
by {A2b | i = 0,1,2,... }, and let As = A|s be the restriction of A to S. Denote by 
/(z) e K[z] the minimal polynomial of As, i.e., the nonzero polynomial of smallest 

212
11. SOLVING SYSTEMS OF LINEAR EQUATIONS OVER FINITE FIELDS
degree such that /(As) is the zero map of S. We assume that f(z) is normalized in 
such a way that its constant term equals 1. Notice that if g(z) e K[z], then g(A$) 
is the zero map of S if and only if g(A)b = 0. Moreover, f(z) divides det(zln — A), 
and therefore deg/(z) < n.
Let d = deg/(z) and /(z) = 
where f[i\ K are the coefficients of
/(z). If we can find /(z), then we can find the solution of (11.27): as /(A)b = 0 
and /[0] = 1, we have
d
(11.28) 
x = -^2/[z]Ai"1b.
2=1
Let u be some fixed vector in Kn; the symbol (•, •) will denote the standard bilinear 
map from Kn to K,
n 
((n1,...,t)n),(wl,...,Wn)) = ^ViWi. 
2=1
Since /(A)b = 0, the sequence
(11.29) 
(uM^b), i = 0,1,2,...,
satisfies a linear recurrence relation, whose characteristic polynomial is f(z). Let 
/u(z) be the minimal polynomial for sequence (11.29) (i.e., the characteristic poly­
nomial of the shortest recurrence relation). Then /u | f(z). Indeed, dividing with 
remainder
f(z) = q(z)fu(z) +r(z), degr(z) < deg/u(z), 
and using the equalities
o = (u, /(A)b) = (u,g(A)/u(A)b) + (u,r(A)b), 
(u,/u(A)A>b)=0, j = 0,1,2,...,
and the minimality of /u(z), we have r(z) = 0. Since the constant term of /(z) 
equals 1, we may assume that the constant term of /u also equals 1.
The minimal polynomial /u(z) for sequence (11.29) can be computed using 
the Berlekamp-Massey algorithm (see [27], [153, Ch. 2], and [156]) from its first 
2n terms. This makes the following method for solving (11.27) possible: ran­
domly choose a vector u, construct /u(z), and assuming that f(z) = /u(z), find 
x by (11.28). According to [280], with high probability we will find the solution 
of (11.27).
Consider now another approach to solving (11.27). Let bo = b, and /i(z) = 
/ui (^) for some vector ui. If bi = /i(A)bo is the zero vector, then find x by (11.28) 
(because then /i(z) = /(z)). If bi 0, then we repeat the procedure, i.e., randomly 
choose a vector u2 and construct the minimal polynomial /2(z) = /i^W f°r the 
sequence (u2, A*bi). If b2 = /2(A)bi = 0, then (as will be shown below) /(z) = 
/i(^)/2(^) and we find the solution x by (11.28), otherwise we choose 113, and so 
on.
We want to show that, after k iterations, /i(z) • • • fk(z) divides f(z). Indeed, 
we have already shown that /i(z) | /(z). Now, if fi(z) • • • fk-i(z) divides /(z), 
then, because /&(;?) is the minimal polynomial for the sequence {(life, A2bfc-i)}i = 
{(Ufc, /fc-i(A) • • • A(^)^b)}j and Mzy.{fk_1{z} annihilates it, /fe(z) | MzfiZfl_1{zy 
as was claimed.

11.5. THE WIEDEMANN ALGORITHM
213
It is now clear that if bfc = /fc(A) • • • /i(A)b = 0, then f(x) = /i(^) • • • 
Therefore, once the zero vector b& = /fc(A)bfc_i has been constructed, we can find 
the solution of (11.27) by (11.28).
We now formalize the above argument in Algorithm 1. For an arbitrary poly­
nomial g(z) e K[z], we set g(z) = 9^~9^-,
Algorithm 1.
Step 1. Set bo := b, k := 0, yo := 0, do 0.
Step 2. If bfc = 0, then the solution of (11.27) equals x = —y& and the 
algorithm terminates.
Step 3. Randomly choose a vector Ufc+i 6 Kn, Ufc+i 0.
Step 4. Compute the first 2(n — d&) terms of {(ufc+i, A2bfc)}i=0,i,2,...-
Step 5. Using the Berlekamp-Massey algorithm compute the minimal polyno­
mial /fc+i(z) for the sequence in Step 4 and normalize it so that its constant term 
equals 1.
Step 6. Set yfc+i := yfe + fk+1(A)bk, bfe+i := b0 + Ayfe+i, and dk+1 := 
dfc + deg fk+i(z).
Step 7. Set k := k + 1 and return to Step 2.
End of algorithm.
We now show that the algorithm is correct. Notice that /(z) = 
corresponds to the right-hand side of (11.28) (without the minus sign). When 
k = 0, we choose ui, consider 2n terms of the sequence {(ui, A4b)}i=o,i,... and find 
fi(x) using the Berlekamp-Massey algorithm. Then yi = /i(A)b, bi = bo + Ayi = 
b + A^1^'~1b = /i(A)b, and di = deg/i(z). Now argue by induction. Suppose 
that after k runs of the algorithm we have
(11.30) 
yt=AW ■/,(A)-lb|
(11.31) 
bfc = A(A).../,(4)b.
Then after the (fc + l)th run we have
yfc+i = yk + fk+i(A)bk
= fk(Ay--fa(A)-ib + 
. /1G4)b
/fc+1(A) •••/!(>!)-lu 
A
bk+1 = b + Afk+i(A)---f1(A')-lb = 
/i(A)b
This shows that formulas (11.30) and (11.31) are preserved. The correctness of 
Algorithm 1 now follows from the arguments preceding its description.
We now describe a deterministic algorithm.
Algorithm 2.
Step 1. Compute Alb, i = 0,1,..., 2n — 1.
Step 2. Set k := 0, go(z) := 1.
Step 3. Set Ufc+i := (0,..., 0,1,0,..., 0) (with 1 at the (fc + l)th place).
Step 4. Using the results of Step 1, compute the sequence
(iifc+i, ./Tb), i = 0,1,..., 2n — 1.

214
11. SOLVING SYSTEMS OF LINEAR EQUATIONS OVER FINITE FIELDS
Step 5. Compute the sequence
(ufc+i,^(^)^b), i = 0,..., 2n — 1 — deg gk(z)
(here one can use the discrete Fourier transform; see [280]).
Step 6. Find (using the Berlekamp-Massey algorithm) the minimal polynomial 
/fc+i(z) for the sequence obtained in Step 5 (the constant term of /fc+i(z) equals 1).
Step 7. Set gk^{z) := fk+1{z)gk{z).
Step 8. Set k := k + 1. If deg gk(z) < n and k < n, then go to Step 3.
Step 9. For the polynomial /(z) = gk(z), using the values of Alb found in 
Step 1, find the solution x of (11.27) by formula (11.28).
End of algorithm.
We now show the correctness of Algorithm 2. Notice that Algorithm 2 works 
like Algorithm 1, only the vectors uk are chosen not randomly but by running 
through the unit vectors (0,..., 0,1,0,..., 0). It is easy to see that gk(z) = 
fk(z) • • • /l(^), where fk(z) is the minimal polynomial for the sequence
(ufe, fk-i(A) • • • /l^A^b), i = 0,..., 2n - 1 - deg(/fc-i(z) • • • fi(z)).
Suppose the algorithm terminates for some value of the parameter k. Consider first 
the case k < n and deg^(z) = n. Since deg/(z) < n and gk(z) | f(z), we have 
gk(z) = f(z). Therefore, in Step 9 we indeed find the solution of (11.27).
Now assume that k = n. Since we have run through all unit vectors ui,..., un, 
the vector ^n(A)b is orthogonal to Ui,... , un (which is obvious by construction). 
Therefore, ^n(A)b = 0. Since ^n(z) I /(^) and /(z) is minimal, we have gk(z) = 
f(z). Therefore, in this case Algorithm 2 is also correct.
This finishes the description of the Wiedemann algorithms. Their complexity 
estimates can be found in [280].
11.6. Other methods. Summary
A survey of methods for solving linear systems with applications to factorization 
algorithms and algorithms for computing the discrete logarithm can be found in 
[127]. We mention, in particular, the conjugate gradient method (see [65, 197]), 
which runs, according to [128], about the same time as the Lanczos algorithm. 
Neither of these algorithms is memory-intensive.
Other methods for solving linear systems are based on algorithms for fast matrix 
multiplication, such as the Strassen algorithm and the Coppersmith-Winograd al­
gorithm (see the survey [10]). Konovaltsev [122] developed an algorithm for solving 
a square system of linear equations with n unknowns over GF(q) in O(n3/loggn) 
arithmetic operations. Brillhart [43] gave an algorithm for solving linear systems 
over GF(2), which is essentially a variation of Gaussian elimination; see also [200].
Fore more on solving linear systems in factorization algorithms and algorithms 
for computing discrete logarithm, see the recent surveys [39] and [196].

APPENDIX
Facts from Number Theory
In this Appendix we mention basic definitions and facts from elementary num­
ber theory, which are often used in the book. The proofs of the theorems can be 
found in [270]. We also mention some improved versions of the Euclidean algo­
rithm; for their correctness, see [118, Ch. 4.5.2], [22, Ch. 4], and [57, Ch. 1].
We begin with the Euclidean algorithm. Let a e Z, b e N, and suppose we want 
to find d = gcd(a, b). Divide a by & with remainder: a = qob + ro,0 < tq < b. If 
ro > 0, divide b by tq: b = qirQ + ri, 0 < ri < ro, etc. We then have a sequence 
of equalities with decreasing remainders rj:
(1)
Tj-2 = qjTj-1 +rjt j = 0,1,...,
where r_2 = a, r_i = b. If r& is the last nonzero remainder, then rk-i = 
and d = gcd(a,&) = r&. The Euclidean algorithm is just the computation of 
sequence (1).
Now we represent d = rk in the form d = au + bv, where u, v e Z. We can 
sequentially rewrite r& in (1): first in terms of rk-i and rk-2 from the penultimate 
equality in (1); then, using rk-i = rk-3 — qk-irk-2, we express r^ in terms of rk-2 
and rfc-3, and so on. In the end, we express rk in terms of a and b.
However, the following generalized Euclidean algorithm is more convenient. In 
it, we work with a system of equations 
(2)
In the beginning we set
uia + U2b = U3, 
< via + V2b = ^3, 
t±a + 
= t^.
(ui,u2,u3) := (1,0,a), (vi,v2,v3) := (0,1,6), (tlyt2,t3) := (0,0,0).
In the next run of the algorithm we check whether V3 = 0. If true, then the 
desired values of d, u, v equal U3, ui, U2, respectively. If V3 0, then we divide with 
remainder: U3 = qv3 + r, and set
(*1, t2, <3) := (yi, v2, v3),
(yi,v2,v3) := (ui - gvi,u2 - gv2,u3 - qv3), 
(ui,u2,u3) := (ti,t2,t3).
Since V3 e Z>0 monotonically decreases, the algorithm eventually terminates and 
outputs the correct answer. Notice that the variables ^2,^2,^2 are uniquely deter­
mined by Ui, U3, 
, ^3, ti, ^3, respectively.
Theorem 1 (Lame). The parameter k in (1) satisfies the inequality 
k < 5([log10 6] + !)•
215

216
APPENDIX. FACTS FROM NUMBER THEORY
Corollary 2. Both the Euclidean algorithm and the generalized Euclidean 
algorithm require O(log&) arithmetic operations.
Remark 3. In the Euclidean algorithm one can choose the least (in absolute 
value) remainder: when dividing an integer a' by a natural number we determine 
g', r' e Z such that a! = g'&' + r' and 0 < |r'| < b1 /2. This speeds up the Euclidean 
algorithm.
Now we consider congruences.
Definition 4. Let a, b e Z and m e N. We say that a is congruent to b 
modulo m (and denote this a = &(mod m)), if m | a — &, or, equivalently, a 
and b have the same remainders when divided by m; or, equivalently, a = b + mt, 
where t e Z.
If m is fixed, then Z is the union of the classes 0,1,..., m — 1 of numbers that 
have the remainders 0,l,...,m — 1, respectively, upon division by m. These residue 
classes form Z/mZ, the residue ring modulo m. For a 6 Z, the symbol a (mod m) 
denotes the residue class modulo m containing a. The multiplicatively invertible 
elements of Z/mZ form the multiplicative group (Z/mZ)*. The number a e Z is 
an element of a residue class invertible modulo m if and only if the equation 
(3) 
ax = 1 (mod m)
has a solution. Equation (3) has a solution if and only if (a,m) = 1. The solution 
of (3) can be found using the generalized Euclidean algorithm: we find u,v e Z 
such that au + mv = 1, and then a (mod m)u (mod m) = 1 (mod m), i.e., u = 
a-1 (mod m).
A complete system of residues modulo m is a set of integers ai,..., am pairwise 
noncongruent modulo m. A reduced system of residues modulo m is a set of integers 
where k = |(Z/mZ)*|, pairwise noncongruent modulo m and relatively 
prime with m.
Now we define the Euler function <^(m): if m e N, then ¥>(m) = |(Z/mZ)*|. 
Equivalently, <p(m) equals the number of integers in the set {0,1,..., m — 1} that 
are relatively prime with m. In particular, (/?(1) = 1 and <p(p) = p — 1, where p is 
a prime number. We have the following formula for if m = Hj;=i Pjj the 
prime factorization of m, then <^(m) = mHj=i(l — 1/pj).
Theorem 5 (Euler). Ifta^m) = 1, then
a^™^ = 1 (mod m).
Theorem 6 (Fermat’s Little Theorem). If p is a prime number andp does not 
divide a, then
oP-1 = 1 (mod p).
Theorem 7 (Chinese Remainder Theorem ). Consider the system of congru­
ences
(4)
x = ai (mod mi), 
x = ak (mod mfc),
where 
= 1 for all i j. Let M = 
and Mi = M/rrti, i =
1,..., fc. Find (using the generalized Euclidean algorithm) numbers &i,..., such

APPENDIX. FACTS FROM NUMBER THEORY
217
that Mibi = 1 (mod mi), i = 1,... ,k. Then the general integer solution of (4) is 
of the form
k
x = MiOibi (mod M), 
i=l
i.e., x = 
+ Mt, where tel.
Now consider the group (Z/mZ)*. It is cyclic if and only if m = 1,2,4,pfc, 2pk, 
where p denotes an odd prime number and k G N. A number g G Z such that the 
residue class of g (mod m) is a generator of (Z/mZ)* (when this group is cyclic) is 
called a primitive root modulo m.
Theorem 8. Let p be a prime number, p> 2.
1) Let p — 1 = IIj=i 
prime factorization of p — 1. The number g is
a primitive root modulo p if and only if
(fl,p) = l> 5(p-1)/<6l(modp), j =
2) Let g be a primitive root modulo p, and let g\ be one of the two numbers, g 
or g +p, satisfying xp-1 1 (mod p2). Then gi is a primitive root modulo p2.
3) If g2 is a primitive root modulo p2, then g2 is a primitive root modulo pk for 
all k G N.
Theorem 9. (Z/4Z)* = (3 (mod 4))2- Furthermore, for k > 3, 
(Z/2feZ)* = (-1 (mod 2fc))2 x (5 (mod 2fe))2fc-2
is a decomposition of (fL/2k%)* into a direct product of cyclic groups.
If m = 2a°p“1 • • • p%k is the prime factorization of m, then one can determine 
a complete generating set of the group (Z/mZ)* in terms of the primitive roots 
modulo p?*, i = 1,.. .,k (see [270, Ch.6]).
If g is a primitive root modulo m, a G Z, and (a,m) = 1, then a solution of 
gx = a (mod m) is called the index of a to base g or the discrete logarithm of a to 
base g and is denoted ind^a or log^ a. This quantity is defined modulo <^(m), i.e., 
ind^a G Z/(/?(m)Z.
Let m G Z. A numerical character modulo m is a map x : Z —> C such that:
1) x(n) = 0 if and only if (m,n) > 1;
2) x(n + m) = x(n) f°r all n £ Z;
3) x(nin2) = x(^i)x^2) for all nr,n2 G Z.
In fact, x is a character of (Z/mZ)* naturally extended to the entire Z.
Now consider the Legendre and Jacobi symbols.
Let p > 2 be a prime number, a G Z, and (a,p) = 1. The number a is called a 
quadratic residue modulo p if the equation
(5) 
x2 = a (mod p)
has a solution; otherwise it is called a quadratic nonresidue.
The Legendre symbol (^) (where a G Z) equals +1 if a is a quadratic residue 
modulo p, (^) = —1 if a is a quadratic nonresidue, and(^) = 0 if a = 0 (mod p).

218
APPENDIX. FACTS FROM NUMBER THEORY
The Legendre symbol has the following properties:
1) The Euler criterion: (^) = aO*-1)/2 (modp).
2) Ifa = 6(modp), then (|) = (|).
3) (£) = 1- (^) = (-l)^2-
4) (1F) = (^)-
5) (j) = (—l/p2-1)/8.
6) Gauss law of quadratic reciprocity: If p, q are odd primes, p g, then
\p) 
\q)'
If m e N, m is an odd composite number and m = 
is prime
factorization of m, then the Jacobi symbol (^) of a e Z is defined by 
k
(-)=n(-)
\m/ 
. .Vp?/
j=i J
The Jacobi symbol has the following properties:
1) If a = b(modm), then (£) = (£).
4) (£)=(-ir2-1)/8.
5) If m and n are relatively prime odd natural numbers, then
Using these properties, it is not difficult to construct algorithms for computing 
the Legendre and Jacobi symbols. See, for example, [57, Ch. 1].
Let me N and f(x) € Z[x]. If we want to solve f(x) = 0 (mod m), then, using 
the Chinese Remainder Theorem, we can reduce our problem to solving f(x) = 
0 (mod pa), where p is a prime number and a e N (this is called a reduction). If 
we know a solution a of f(x) = 0(mod pa), then we can construct a solution ai 
of f(x) = 0(mod pa+1) (this is a lifting of a solution). See [270, Ch. 4] about 
reduction and lifting of solutions. The most widely used methods for solving f(x) = 
0 (mod p) were described in Chapter 6 of this book.
Now we mention some definitions and facts from the theory of continued frac­
tions] see for example, [130, 117]. Let n e Z>0, uo € Z, and ai,... ,an e N. An 
n-term continued fraction [ao; ai,..., an] is the rational number
r 
i 
1
[uo; ^1, • • • > ^n] — ^0 H-------- ;--------- i------- •
«1 + a2+l
an
In particular, a 0-term continued fraction [a0; ] = a0 is just an integer.
Theorem 10. Any rational number a 1 can be written asa= [a0; ai,..., an\ 
for some n e Z>o, aQ e Z, and a\,...,an e N. This representation is unique, 
provided an > 1.
Remark 11. The number a = 1 = [1; ] = [0; 1] is represented in two ways, 
and in each representation the last entry equals 1. If a 1, a = [a0; ai,..., an\, 
where an e N and an > 1, then a can also be written as a = [a0; ai,..., an — 1,1].

APPENDIX. FACTS FROM NUMBER THEORY
219
The convergents of a = [ao; ai,..., an] are Pk/qk = [flo; ai, • • •, flfc], fc = 0,1, 
... ,n, where pk E'L, qk € N, (pk,qk) = 1- For convenience, we set p~i = 1 and 
Q-i =0. Then we have
{
Po = ao> Qo = 1,
Pk = O'kPk-l + Pfc-2> qk = Ukqk-l + qk-2 for k > 1, 
which allows for a quick computation of the convergents.
The convergents of a have the following properties:
1)Pkqk-i -Pk-iqk = (-l)*-1. k = 0,1,....
2) PkQk-2 - Pfc-2% = (~l)kak, k = 2,3,... .
3) The even-numbered convergents increase, and the odd-numbered convergents 
decrease.
4) Any even-numbered convergent is less than any odd-numbered convergent.
5) 1 = qo < qi < Q2 < • • • < qn-
6) 
I a — I < —-— < .
7 I Qk । — Qk+lQk ~ Q^
7) |Q_2k| >
7 I Qk I — Qk+2Qk
If a0 e Z and ai, 02, • • • N, then the infinite continued fraction [a0; ui, a2> • • • ] 
is the limit
(6) 
a = [a0;ai,a2)---] = lim [a0;ai,... ,an].
n—>oo
The fractions pn/qn = [ao; ai,..., an] are called the convergents of the infinite 
continued fraction. They have the same properties as the convergents of finite 
continued fractions; in particular, it is easy to see that limit (6) exists.
Theorem 12. Any irrational real number a is uniquely represented as an in­
finite continued fraction a = [uo’> ^i> ^2, • • • ]•
Remark 13. The expansion of a e R into a continued fraction can be obtained 
using the following algorithm. Let a = [a] + {a}. Set a0 = [a], ri = l/{a}, 
a = a0 + 1/ri. Then set h = [rj + 1/-{1riy = 
+ 1/^2, etc. After the (fc + l)th
computation of the integer part and flipping the fractional part, we have
1
a — ao H------ ;-------- 1-------•
ai + •••+—i-F 
ak~1+^
If a = a/b € Q, then this process is equivalent to the Euclidean algorithm for a 
and b. If a e R \ Q, then this process will be infinite.
For some irrational numbers the expansion into a continued fraction is periodic: 
a fraction a = [uo; ai,..., Ufc-i, flfc,..., Ufc+r] is periodic if ak^ .., Ufc+r repeat pe­
riodically. For example, \/5 = [2; 4] = [2; 4,4,4,...].
Theorem 14 (Euler-Lagrange). The number a 6 R\Q expands into a periodic 
continued fraction if and only if a is a quadratic irrationality, i.e., a solution of 
ax2 + bx + c = 0, where a e N, b, c e Z.
Now we describe several modifications of the Euclidean algorithm and of the 
generalized Euclidean algorithm. In those algorithms we aim at reducing divisions, 
because high-precision integer division is costly. Notice that division by 2 is not in 
fact a division but just a shift of the binary representation of a number.

220
APPENDIX. FACTS FROM NUMBER THEORY
The binary algorithm.
The input of the algorithm consists of numbers a, b e N, a > b. The output 
is d = gcd(a, b).
Step 1. Set r equal to the remainder of a divided by b. Then set a := b and 
b := r.
Step 2. If b = 0, then output a and stop. Else, k := 0, and while a and b are 
both even, do the following:
(7)
k := k + 1, 
< a := a/2, 
b:= b/2.
(After this, 2k is entered in gcd(a, &); the remaining part of the gcd will be odd.)
Step 3. Now at least one of the numbers a and b is odd. If a is even, then 
keep setting a := a/2 until a becomes odd. Do the same for b.
Step 4. Now both a and b are odd. Set t := (a — b)/2. If t = 0, then output 
2ka and stop.
Step 5. As long as t is even, do t := t/2.
Step 6. Now t is odd and t 0. If t > 0, then a := t. If t < 0, then b := — t. 
Go to Step 4.
End of algorithm.
Remark 15. An analysis of the complexity of this algorithm can be found 
in [118, Ch. 4.5.2].
Lehmer’s algorithm.
The input consists of u, v e N, u > v (?z, v are high-precision integers). The out­
put is d = gcd(u, v). Auxiliary variables: £, w of high precision, u, u, A, B, O', D, T, q 
of single precision and p-digit. In other words, the length of a number not exceed­
ing p is considered single precision; the numbers are 6-base, b e N.
Step 1. (Initialization.)
1) If v is single precision (in particular, v = 0), apply the Euclidean algorithm 
to u and f, find d, and stop.
2) If the 6-base representation of u requires ki sets of p digits, the representation 
of v requires sets of p digits, and ki > then do one high-precision division 
u = tv + w with remainder, and set u := f, v := w. (Heuristically, after this step u 
and v will be approximately of the same size.)
3) 
Enter the p leading digits of u in u\ then do the same for v and v. Set
A := 1, B := 0, C := 0, D := 1.
Step 2. (A test for termination.) Now u 0, v 0, and u > v. If u 0, 
but u + A = 0otu + B = 0 (this can happen because these variables are single 
precision; for example, if u = b? — 1 and A = 1, then u + A = 0), then go to Step 4. 
Similarly, if v 0, but u + C = 0oru-|-D = 0, then also go to Step 4. Else, find 
g •■= [t+cj] •If g [t+f] >then g°t0 Step 4-

APPENDIX. FACTS FROM NUMBER THEORY
221
Step 3. Do the following:
T := A — qC,
T:=B — qD,
T := u — qv
< A:=C,
B.= D,
£>
II
C:=T,
D :=T,
v := T.
If v = 0, go to Step 4. Else, go to Step 2.
Step 4. If B = 0, then do high-precision division with remainder of u by v: 
u = wv + ti0<t<v — 1. Then set u := f, v := t, and go to Step 1. If B 0, 
then, using high-precision arithmetic, compute
t := Au + Bv> w := Cu + Dv>
and set u:= t, v := w. Go to Step 1.
End of algorithm.
The generalized binary algorithm.
The input of the algorithm consists of a, b e N, a > b. The output consists 
of d = gcd(a, b) e N and u, v e Z such that au + bv = d. The algorithm also uses 
high-precision auxiliary variables 
and Boolean variables /i,/2-
Step 1. (One-time size reduction.) If a < &, then interchange a and b and 
set fi := 1. Else, fi := 0. If b = 0, then output (u, v,d) = (1,0, a) for /i = 0 
and output (uivid) = (0,1, a) for fi = 1, and stop. Else, divide with remainder 
a = bq + r, 0 < r < &, and set a := b and b := r.
Step 2. (Computing powers of two.) If b = 0, then output (u, v,d) = (0, l,a) 
for fi = 0 and output (u, v,d) = (1,0, a) for fi = 1, and stop. Else, k := 0, and 
while a and b are both even, do:
k := k + 1, 
< a := a/2, 
&:= b/2.
Step 3. (Initialization.) If b is even, then interchange a and b and set /2 := 1. 
Else, fz := 0. Also set
u := 1, d := a, := 0, v3 := b.
If a is odd, then ti := 0, t3 := —6, and go to Step 5. Else, ti := (b + l)/2 and 
t3 := a/2.
Step 4. (Removing the extra twos.) If t3 is even, then set
t3 •= ts/2) ti •= ^1/2 for ti even, 
t3 '= tz/2) ti •= (£1 + b)/2 for ti odd,
and return to Step 4.
Step 5. (A loop.) If t3 > 0, then u := ti, d := t3\ else := b — ti, v3 := —13.
Step 6. (Subtraction.) Set
ti := u — Vi, t3 := d — v3.
If ti < 0, then ti := ti + b. If t3 0, then go to Step 4.

222
APPENDIX. FACTS FROM NUMBER THEORY
Step 7. Set v := (d — au)/b and d := 2kd. If /2 = 1, then interchange u and v. 
Set u := u — vq. Output (u, v, d) if fi = 1 and output (v, u, d) if /i = 0.
End of algorithm.
We conclude this Appendix by describing two methods for exponentiation. 
Let G be a multiplicative group, g e G, and n e N. We want to compute 
h = gn EG. Let n = bk2k + &fc-i2fc-1 H------ 1- &i2 + 60 be the binary representation
of n, i.e., bi e {0; 1} and bk = 1.
Method 1. First determine the elements hj = g23, j = 0,1,..., k\ here Hq = g 
and hj+i := hj • hj. Then compute
= JJ hj.
3'- ^ = 1
To find h by this method we need at most 2k + 1 = O(log n) multiplications in G.
Method 2. Compute
hj = 
= 1,2,..., fc + 1.
Initially, hr = g = gbk. If we have already computed hj> then hj+i := hj • hj for 
bk-j = 0, and hj+i := hj -hj - g for bk-j = 1. In the end, hk+i = h = gn. In this 
method we also need O(log n) multiplications in G.
The advantage of the second method over the first can be seen as follows. 
Suppose we want to find 510000 e Z. The powers 52J grow quickly. In the first 
method, we square and then multiply large numbers. In the second method, when 
computing hj+i we multiply large numbers hj • hj and then multiply by g = 5 (if 
bk-j = 1), i.e., by a small number. This cuts the cost substantially.
These methods are called binary exponentiation methods.

Bibliography
[1] Adleman, L. A subexponential algorithm for the discrete logarithm problem with applica­
tions to cryptography. Proc. 20th Ann. IEEE Symp. Found. Comput. Sci. 1979. Pp. 55-60.
[2] Adleman, L. The function field sieve. Proceedings of ANTS-I. 1994. (Leet. Notes in Comput. 
Sci.; V. 877). Pp. 108-121.
[3] Adleman, L., Pomerance, C., Rumely, R.S. On distinguishing prime numbers from com­
posite numbers. Ann. Math. 1983. V. 117. Pp. 173-206.
[4] Adleman, L., Huang, M.-D.A. Primality testing and abelian varieties over finite fields. 1992. 
(Leet. Notes in Math.; V. 1512).
[5] Adleman, L., Me Curley, K. Open problems in number theoretic complexity. Proceedings of 
ANTS-I. 1994. (Leet. Notes in Comput. Sci.; V. 877). Pp. 291-322.
[6] Adleman, L.M., Manders, K., Miller, G.L. On taking roots in finite fields. Proc. 18th Ann. 
Symp. Found. Comput. Sci. 1977. Pp. 175-178.
[7] Agrawal, M., Kayal, N., Saxena, N., PRIMES is in P. Preprint, August 2002. 
http://www.cse.iitk.ac.in/news/primality.pdf
[8] Aho, A.V., Hopcroft, J.E., Ullman, J.D. The design and analysis of computer algorithms. 
Second printing. Addison-Wesley Series in Computer Science and Information Processing. 
Addison-Wesley Publishing Co., Reading, Mass.-London-Amsterdam, 1975.
[9] Akritas, A. Elements of computer algebra with applications. John Wiley & Sons, Inc., New 
York, 1989.
[10] Alexeev, V.B. The complexity of matrix multiplication. A survey. Kiberneticheskii Sbornik 
25 (1988), 189-236. (Russian)
[11] Alferov, A.P., Zubov, A. Yu., Kuzmin, A.S., Cheremushkin, A.V. Foundations of cryptog­
raphy, 2nd ed., Gelios ARV, Moscow, 2002. (Russian)
[12] Alford, W.R., Granville, A., Pomerance, C. There are infinitely many Carmichael numbers. 
Ann. Math. 1994. V. 140. Pp. 703-722.
[13] Alford, W.R., Granville, A., Pomerance, C. On the difficulty of finding reliable witnesses 
(invited talk). Proceedings of ANTS-I. 1994. (Leet. Notes in Comput. Sci.; V. 877). Pp. 1-16.
[14] Alt, H. Square rooting is as difficult as multiplication. Computing. 1979. V. 21. Pp. 221-232.
[15] Ankeny, N. C. The least quadratic nonresidue. Ann. Math. 1952. V. 55. Pp. 65-72.
[16] Anokhin, M.I., Vamovsky, N.P., Sidelnikov, V.M., Yashchenko, V. V. Cryptography in 
banking, MIFI, Moscow, 1997. (Russian)
[17] Apostol, T.M. Introduction to analytic number theory. Springer-Verlag, 1997.
[18] Atkin, A.O.L., Morain, F. Elliptic curves and primality proving. Math. Comp. 1993. 
V. 61 (203). Pp. 29-67.
[19] Atkin, A.O.L., Morain, F. Finding suitable curves for elliptic method of factoring. Math. 
Comp. 1993. V. 60 (201). Pp. 399-405.
[20] Atkins, D., Graff, M., Lenstra, A.K., Leyland, P.C. The magic words are squeamish os- 
sifrage. Advances in cryptology — ASIACRYPT’94 (Wollongong, 1994). 1995. (Lecture 
Notes in Computer Science; V. 917). Pp. 263-277.
[21] Bach, E., Shallit, J. Factoring with cyclotomic polynomials. Math. Comp. 1989. V. 52 (185). 
Pp. 201-219.
[22] Bach, E., Shallit, J. Algorithmic number theory. V. 1. MIT Press, 1996.
[23] Baker, R.C., Harman, G. The Brun-Titchmarsh theorem on average. Proc. Conf, in Honour 
of Heini Halberstam. V. 1. 1996. Pp. 39-103.
[24] Ben-Or, M. Probabilistic algorithms in finite fields. Proc. 22nd Ann. IEEE Symp. Found. 
Comput. Sci. 1981. Pp. 394-398.
223

224
BIBLIOGRAPHY
[25] Berezin, I.S., Zhidkov, N.P. Computing methods. Vol. I. Third revised and augmented 
edition, “Nauka”, Moscow. 1966. (Russian)
[26] Berlekamp, E.R. Factoring polynomials over finite fields. Bell System Tech. J. 1967. V. 46. 
Pp. 1853-1859.
[27] Berlekamp, E.R. Algebraic coding theory. McGraw-Hill Book Co., New York-Toronto, Ont.- 
London. 1968.
[28] Bernstein, D.J. Detecting perfect powers in essentially linear time. Math. Comp. 1998. 
V. 67 (223). Pp. 1253-1283.
[29] Blake, I.F., Seroussi, G., Smart, N.P. Elliptic curves in cryptography. Cambridge University 
Press, 1999.
[30] Boender, H., te Riele, H. J. J. Factoring integers with large prime variations of the quadratic 
sieve. CWI Report NM-R9513. 1995.
[31] Borevich, Z.I., Shafarevich, I.R. Number theory. Pure and Applied Mathematics. Vol. 20. 
Academic Press. New York-London. 1966.
[32] Borodin, A.B., Munro, I. The computational complexity of algebraic and numeric problems. 
American Elsevier. New York. 1975.
[33] Bosma, W., van der Hulst, M.P. Faster primality testing (extended abstract). Advances 
in Cryptology — EuroCrypt’89. Jean-Jacques Quisquater and Joos Vandewalle, editors. 
Springer-Verlag. Berlin. 1989. (Leet. Notes in Comput. Sci.; V. 434). Pp. 652-656.
[34] Bosselaerts, A., Govaerts, R., Vandewalle, J. Comparison of three modular reduction func­
tions. Advances in Cryptology — Crypto’93. Douglas R.Stinson, editor. Berlin: Springer- 
Verlag, 1993. (Leet. Notes in Comput. Sci.; V. 773). Pp. 175-186.
[35] Brassard, G., Monet, S., Zuffelato, D. Algorithmes pour 1’arithmetique des tres grands 
entiers. Techniques and Science Informatique. 1986. V. 5. Pp. 89-102.
[36] Brent, R.P. An improved Monte Carlo factorization algorithm. BIT. 1980. V. 20. Pp. 176- 
184.
[37] Brent, R.P. Some integer factorization algorithms using elliptic curves. Austral. Comput. 
Sci. Comm. 1986. V. 8. Pp. 149-163.
[38] Brent, R.P. Factorization of the tenth Fermat number. Math. Comp. 1999. V. 68. Pp. 429- 
451.
[39] Brent, R.P. Some parallel algorithms for integer factorisation. Leet. Notes in Comput. Sci. 
1999. V. 1685. Pp. 1-22.
[40] Brent, R.P., Pollard, J.M. Factorization of the eighth Fermat number. Math. Comp. 1981. 
V. 36. Pp. 627-630.
[41] Brentjes, A. J. Multidimensional continued fraction algorithms. Amsterdam, 1981. (Mathe­
matical Centre Tracts; V. 145).
[42] Bressoud, D.M. Factorization and primality testing. Springer-Verlag, 1989.
[43] Brillhart, J. A note on finding dependencies over GF(2). Utilitas Math. 1989. V. 36. Pp. 211- 
213.
[44] Brillhart, J., Morrison, M.A. A method of factoring and the factorization of Fy. Math. 
Comp. 1975. V. 29. Pp. 183-205.
[45] Brillhart, J., Tonascia, J., Weinberger, P. On the Fermat quotient. Computers in number 
theory. London, N. Y.: Acad. Press, 1971. Pp. 213-222.
[46] Buchberger, B., Winkler, F. Grobner bases and applications. Cambridge Univ. Press, 1998. 
(London Math. Soc. Lecture Notes Series; V. 251).
[47] Buchmann, J., Jacobson, M.J., Teske, E. On some computational problems in finite abelian 
groups. Math. Comp. 1997. V. 66 (220). Pp. 1663-1687.
[48] Buchmann, J., Weber, D. Discrete logarithms: Recent progress. Proc. Internat. Conf, 
on Coding Theory, Cryptography and Related Areas, Guanajuato. Springer-Verlag, 2000. 
Pp. 42-56.
[49] Buell, D.A. Binary quadratic forms: classical theory and modern computations. Springer- 
Verlag, 1989.
[50] Cantor, D.G., Zassenhaus, H. A new algorithm for factoring polynomials over finite fields. 
Math. Comp. 1981. V. 36. Pp. 587-592.
[51] Caron, T.R., Silverman, R.D. Parallel implementation of the quadratic sieve. J. Supercom­
puting. 1988. V. 1. Pp. 273-290.
[52] Cassels J. W.S. An introduction to the geometry of numbers. Corrected reprint of the 1971 
edition. Classics in Mathematics. Springer-Verlag, Berlin, 1997.

BIBLIOGRAPHY
225
[53] Cavallar, S., Dodson, B., Lenstra, A.K., Leyland, P.C., Lioen, W.M., Montgomery, P.L., 
Murphy, B., te Riele, Zimmerman, P. Factorization of RSA-140 using the number 
field sieve. CWI Report MAS-R9925, September 1999, ASIACRYPT ’99, Leet. Notes in 
Comput. Sci.; V. 1716 (1999). Pp. 195-207.
[54] Cavallar, S., Lioen, W.M., te Riele, Dodson, B., Lenstra, A.K., Montgomery, P.L., 
Murphy, B. et al. Factorization of 512-bit RS A-modulus. CWI Report MAS-R0007, February 
2000, EUROCRYPT 2000, Leet. Notes in Comput. Sci.; V. 1807 (2000). Pp. 1-17.
[55] Chebyshev, P. L, Collected works, V. 1, Number theory. AN SSSR, 1946. (Russian)
[56] Chistov, A.L. An algorithm of polynomial complexity for factoring polynomials, and deter­
mination of the components of a variety in a subexponential time. Theory of the complexity 
of computations, II. Zap. Nauchn. Sem. Leningrad. Otdel. Mat. Inst. Steklov. (LOMI) 137 
(1984), 124-188. English transl. in J. Sov. Math. 34 (1986).
[57] Cohen, H. A course in computational algebraic number theory. Springer-Verlag, 1993.
[58] Cohen, H., Lenstra, H.W. Primality testing and Jacobi sums. Math. Comp. 1984. 
V. 42 (165). Pp. 297-330.
[59] Comba, P.G. Experiments in fast multiplication of integers. Technical Report G320-2158, 
IBM, Cambridge Scientific Center, February 1989.
[60] Comba, P.G. Exponentiation cryptosystems on IBM PC. IBM Systems J. 29 (4) (1990), 
526-538.
[61] Contini, S. Factoring integers with the self initializing quadratic sieve. Master’s thesis. Univ. 
Georgia, 1997.
[62] Cook, S.A. On the minimum computation time of functions. Doctoral thesis. Harvard Uni­
versity, Cambridge, Mass., 1966.
[63] Coppersmith, D. Fast evaluation of discrete logarithms in fields of characteristic two. IEEE 
Trans. Inform. Theory 30 (4) (1984), 587-594.
[64] Coppersmith, D. Solving homogeneous linear equations over GF(2) via block Wiedemann 
algorithm. Math. Comp. 62 (205) (1994), 333-350.
[65] Coppersmith, D., Odlyzko, A., Schroeppel, R. Discrete logarithms in GF(p). Algorithmica. 
1986. V. 1. Pp. 1-15.
[66] Coppersmith, D., Winograd, S. On the asymptotic complexity of matrix multiplication. 
SIAM J. Comput. 1982. V. 11. Pp. 472-492.
[67] Couvreur, C., Quisquater, J. J. An introduction to fast generation of large primes. Philips 
J. Res. 1982. V. 37. Pp. 231-264. Errata in: 1983. V. 38. Pp. 77.
[68] Cox, D., Little, J., O’Shea, D. Ideals, varieties and algorithms. New York: Springer-Verlag, 
1992. (Undergraduate Texts in Mathematics).
[69] Crandall, R., Pomerance, C. Prime numbers: a computational perspective. Springer-Verlag, 
2001.
[70] Davenport, J.H., Siret, Y., Tournier, E. Computer algebra. Systems and algorithms for 
algebraic computation. Second edition. With a preface by Daniel Lazard. Academic Press, 
Ltd., London, 1993.
[71] de Weger, B. Algorithms for Diophantine equations. Dissertation. Centrum voor Wiskunde 
en Informatica, Amsterdam, 1988.
[72] Denny, T., Muller, V. On the reduction of composed relations from the number field sieve. 
Proceedings of ANTS-II. 1996. (Leet. Notes in Comput. Sci.; V. 1122). Pp. 75-90.
[73] Denny, T.F. Losen groBer diinnbesetzter Gleichungssysteme iiber endlichen Primkorpern. 
Dissertation. Universitat des Saarlandes, Saarbriicken, 1997.
[74] Diaz, A., Hitz, M., Kaltofen, E., Lobo, A. Process scheduling in DSC and the large sparse 
linear systems challenge. Leet. Notes in Comput. Sci. 1993. V. 722. Pp. 66-80.
[75] Dixon, B., Lenstra, A.K. Massively parallel elliptic curve factoring. Leet. Notes in Comput. 
Sci. V. 658. 1993. Pp. 183-193.
[76] Dodson, B., Lenstra, A.K. NFS with four large primes: an explosive experiment. Advances 
in Cryptology — Crypto’95. 1995. (Leet. Notes in Comput. Sci.; V. 963). Pp. 372-385.
[77] ElGamal, T. A subexponential-time algorithm for computing discrete logarithms over 
GF(p2). IEEE Trans. Inform. Theory. 1985. V. 31. Pp. 473-481.
[78] ElGamal, T. On computing logarithm over finite fields. Advances in cryptology — 
CRYPTO’85 (Santa Barbara, Calif., 1985). 1986. (Leet. Notes in Comput. Sci.; V. 218). 
Pp. 396-402.

226
BIBLIOGRAPHY
[79] Elkenbracht-Huizing, M. An implementation of the number field sieve. Experimental Math­
ematics. 1996. V. 5. Pp. 231-253.
[80] Elkenbracht-Huizing, M. A multiple polynomial general number field sieve. Proceedings of 
ANTS-II. 1996. (Leet. Notes in Comput. Sci.; V. 1122). Pp. 99-114.
[81] Elkenbracht-Huizing, M. Factoring integers with the number field sieve. Ph.D. thesis. Leiden 
Univ., 1997.
[82] Elkies, N. D. Elliptic and modular curves over finite fields and related computational issues. 
Computational perspectives in number theory: Proc, of a Conf, in Honor of A.O.L. Atkin, 
J.T. Teitelbaum, and D.A. Buell, editors. 1998. (Amer. Math. Soc. Inf. Press; V. 7). Pp. 21- 
76.
[83] Emvall, R., Metsankyla, T. On the p-divisibility of Fermat quotients. Math. Comp. 1997. 
V. 66 (219). Pp. 1353-1365.
[84] Fagin, B.S. Large integers multiplication on massively parallel processors. Proc. Frontiers’90: 
Third Symp. on the Frontiers of Massively Parallel Computation. IEEE Press, 1990. Pp. 38- 
42.
[85] Ferguson, H.R.P. A short proof of the existence of vector Euclidean algorithm. Proc. Amer. 
Math. Soc. 1986. V. 97. Pp. 8-10.
[86] Ferguson, H.R.P. A noninductive GL(n, 2) algorithm that constructs integral linear relations 
for n Z-linearly dependent real numbers. J. Algorithms. 1987. V. 8 (1). Pp. 131-142.
[87] Ferguson, H.R.P., Bailey, D.H., Amo, S. Analysis of integer relation finding algorithm. 
Math. Comp. 1999. V. 68 (225). Pp. 351-369.
[88] Ferguson, H.R.P., Forcade, R. W. Generalization of the Eucledian algorithm for real num­
bers to all dimensions higher than two. Bull. Amer. Math. Soc. (N. S.). 1979. V. 1. Pp. 912- 
914.
[89] Ferguson, H.R.P., Forcade, R. W. Multidimensional Eucledian algorithms. J. Reine Angew. 
Math. 1982. V. 334. Pp. 171-181.
[90] Fincke, U., Pohst, M. Improved methods for calculating vectors of short length in a lattice, 
including acomplexity analysis. Math. Comp. 1985. V. 44. Pp. 463-471.
[91] Fleischmann, P. Connections between the algorithms of Berlekamp and Niederraiter for 
factoring polynomials over Fq. Linear Algebra and Applications. 1993. V. 192. Pp. 101-108.
[92] Fouvry, E. Theoreme de Brun-Titchmarsh: application au theoreme de Fermat. Invent. 
Math. 1985. V. 79. Pp. 383-407.
[93] Gantmacher, F.R. The theory of matrices. Vol. 1. Reprint of the 1959 translation. AMS 
Chelsea Publishing, Providence, RI, 1998.
[94] Gamer, H. The residue number system. IRE Transactions on Electronic Computers. 1959. 
V. 8. Pp. 140-147.
[95] Gashkov, S.B. Simplified justification of the probabilistic Miller-Rabin test for primality. 
Diskret. Mat. 10 (1998), no. 4, 35-38; translation in Discrete Math. Appl. 8 (1998), no. 6, 
545-548.
[96] Gianni, P., Mora, T. Algebraic solution of systems of polynomial equations using Grobner 
bases. Applied algebra, algebraic algorithms and error-correcting codes (Menorca, 1987). 
1989. (Leet. Notes in Comput. Sci.; V. 356). Pp. 247-257.
[97] Goldwasser, S., Kilian, J. Almost all primes can be quickly certified. Proc. 18-th Ann. ACM 
Symp. on Theory of Computing. 1986. Pp. 316-329.
[98] Gordon, D. Discrete logarithms in GF(p) using the number field sieve. SIAM J. Disc. Math. 
1993. V. 6. Pp. 124-138.
[99] Gordon, D.M., McCurley, K.S. Massively parallel computation of discrete logarithms. Ad­
vances in Cryptology — Crypto’92. Ernest F. Brickell, editor. Berlin: Springer-Verlag, 1993. 
(Leet. Notes in Comput. Sci.; V. 740). Pp. 312-323.
[100] Grigor’ev, D. Yu. Factoring polynomials over a finite field and solution of systems of algebraic 
equations. Theory of the complexity of computations, II. Zap. Nauchn. Sem. Leningrad. 
Otdel. Mat. Inst. Steklov. (LOMI) 137 (1984), 20-79. (Russian)
[101] Hastad, J., Just, B., Lagarias, J.C., Schnorr, C.P. Polynomial time algorithms for finding 
integer relations among real numbers. SIAM J. Comput. 1989. V. 18. Pp. 859-881.
[102] Hellman, M.E., Reyneri, J.M. Fast computation of discrete logarithms in GF(q). Advances 
in Cryptology — CRYPTO’82. N. Y.: Plenum Press, 1983. Pp. 3-13.
[103] Herlestam, T., Johannesson, R. On computing logarithms over GF(2P). BIT. 1981. V. 21. 
Pp. 326-336.

BIBLIOGRAPHY
227
[104] Hong, S.M., Oh, S.Y., Yoon, H. New modular multiplication algorithms for fast modular 
exponentiation. Leet. Notes in Comput. Sci. 1996. V. 1070. Pp. 166-177.
[105] Izu, T., Kogure, J., Noro, M., Yokoyama, K. Efficient implementation of Schoof’s algorithm. 
Advances in cryptology — ASIACRYPT’98 (Beijing). 1998. (Leet. Notes in Comput. Sci.; 
V. 1514). Pp. 66-79.
[106] Joux, A., Lercier, R. Improvements to the general number field sieve for discrete logarithms 
in prime fields. Math. Comput. 72 (2003), no. 242, 953-967.
[107] Joux, A., Lercier, R. Discrete logarithms in GF(p). e-mail to the NMBRTHRY mailing list, 
January 2001.
http://listserv.nodak.edu/archives/nmbrthry.html.
[108] Joux, A., Lercier, R. Discrete logarithms in GF(p). e-mail to the NMBRTHRY mailing list, 
April 2001.
http://listserv.nodak.edu/archives/nmbrthry.html.
[109] Kaltofen, E. Polynomial factorization 1987-1991. LATIN’92 (Sao Paulo, 1992). 1992. (Leet. 
Notes in Comput. Sci.; V. 583). Pp. 294-313.
[110] Kaltofen, E. Analysis of Coppersmith’s block Wiedemann algorithm for the parallel solution 
of sparse linear systems. Applied algebra, algebraic algorithms and error-correcting codes 
(San Juan, PR, 1993). 1993. (Leet. Notes in Comput. Sci.; V. 673). Pp. 195-212.
[Ill] Kaltofen, E., Lobo, A. Factoring high-degree polynomials by the black box Berlekamp algo­
rithm. Proceedings of ISSAC’94. ACM Press, 1994. Pp. 90-98.
[112] Kaltofen, E., Sanders, B.D. On Wiedemann’s method of solving sparse linear systems. 
Applied algebra, algebraic algorithms and error-correcting codes (New Orleans, LA, 1991). 
1991. (Leet. Notes in Comput. Sci.; V. 539). Pp. 29-38.
[113] Kaltofen, E., Shoup, V. Fast polynomial factorization over high algebraic extensions of finite 
fields. Proceedings of ISSAC’97. ACM Press, 1997. Pp. 184-188.
[114] Kaltofen, E., Shoup, V. Subquadratic-time factoring of polynomials over finite fields. Math. 
Comp. 1998. V. 67 (223). Pp. 1179-1197.
[115] Kannan, R., Lenstra, A.K., Lovasz, L. Polynomial factorization and nonrandomness of bits 
of algebraic and some transcendental numbers. Math. Comp. 1988. V. 50 (181). Pp. 235-250.
[116] Karatsuba, A.A., Ofman, Yu.P. Multiplication of many-digital numbers by automatic com­
puters. Doklady Akad. Nauk SSSR 145, 293-294, 1962. Translation in Physics-Doklady 7, 
595-596, 1963.
[117] Khinchin, A. Ya. Continued fractions. Dover, 1997.
[118] Knuth D. The art of computer programming, V. 2. Seminumerical Algorithms, Third Edi­
tion, Reading, Massachusetts: Addison-Wesley, 1997.
[119] Koblitz, N. A course in number theory and cryptography. Springer-Verlag, 1987.
[120] Koblitz, N. Elliptic curve cryptosystems. Math. Comp. 1987. V. 48. Pp. 203-209.
[121] Koblitz, N. Algebraic aspects of cryptography. Springer-Verlag, 1998.
[122] Konovaltsev, I. V. On an algorithm for solving systems of linear equations in finite fields. 
Problemy Kibernetiky 19 (1967), 269-274.
[123] Konyagin, S., Lange, T., Shparlinski, I. Linear complexity of discrete logarithm. Designs, 
Codes, Cryptogr., to appear.
[124] Konyagin, S.V., Pomerance, C. On primes recognizable in deterministic polynomial time. 
Algorithms and combinatorics. Springer-Verlag, 1997. (The mathematics of Paul Erdos; 
V. 1). Pp. 176-198.
[125] Kostrikin, A.I. Introduction to algebra. Universitext. Springer-Verlag, New York-Berlin, 
1982.
[126] LaMacchia, B. Basis reduction algorithms and subset sum problems. Thesis. MIT Artificial 
Intelligence Lab., 1991.
[127] LaMacchia, B., Odlyzko, A. Solving large sparse linear systems over finite fields. Advances 
in Cryptology — CRYPTO’90. 1990. (Lecture Notes in Computer Science; V. 537). Pp. 109- 
133.
[128] LaMacchia, B.A., Odlyzko, A.M. Computation of discrete logarithm in prime fields. Des. 
Codes Cryptogr. 1991. V. 1. Pp. 47-62.
[129] Lambert, R. Computational aspects of discrete logarithms. Ph.D thesis. Univ, of Waterloo, 
Dept. Electrical Comp. Eng., 1996.
[130] Lang, S. Introduction to Diophantine approximations. Second edition. Springer-Verlag, New 
York, 1995.

228
BIBLIOGRAPHY
[131] Lang, S. Elliptic functions. With an appendix by J. Tate. Second edition. Graduate Texts 
in Mathematics, 112. Springer-Verlag, New York, 1987.
[132] Lanczos, C. Solution of systems of linear equations by minimized iterations. J. Res. Nat. 
Bur. Standards. 1952. V. 49. Pp. 33-53.
[133] Lay, G.-J., Zimmer, H.G. Constructing elliptic curves with given group order over large 
finite fields. Algorithmic number theory (Ithaca, NY, 1994). 1994. (Leet. Notes in Comput. 
Sci.; V. 877). Pp. 250-263.
[134] Lazard, D. Resolution des systemes d’equations algebriques. Theor. Comput. Sci. 1981. 
V. 15. Pp. 77-110.
[135] Lazard, D. Ideal basis and primary decomposition: case of two variables. J. Symb. Comput. 
1985. V. 1. Pp. 261-270.
[136] Lazard, D. Solving zero-dimensional algebraic systems. J. Symb. Comput. 1992. V. 13. 
Pp. 117-131.
[137] Lehman, R.S. Factoring large integers. Math. Comp. 1974. V. 28. Pp. 637-646.
[138] Lemesh, A.N. On A-low numbers. The 12th international conference “Problems of theoretical 
cybernetics”, Nizhni Novgorod, 1999, Summaries of talks, Part II, p. 135.
[139] Lenstra, A.K., Lenstra, H.W., editors. The development of the number field sieve. 1993. 
(Lecture Notes in Mathematics; V. 1554).
[140] Lenstra, A.K., Lenstra, H.W., Lovdsz, L. Factoring polynomials with rational coefficients. 
Math. Ann. 1982. V. 261. Pp. 515-534.
[141] Lenstra, A.K., Lenstra, H.W., Manasse, M.S., Pollard, J.M. The number field sieve. Proc. 
22nd ACM Symposium on Theory of Computing. 1990. Pp. 564-572.
[142] Lenstra, A.K., Lenstra, H.W., Manasse, M.S., Pollard, J.M. The factorization of the ninth 
Fermat number. Math. Comp. 1993. V. 61 (203). Pp. 319-349.
[143] Lenstra, A.K., Manasse, M.S. Factoring with two large primes. Math. Comp. 1994. V. 63. 
Pp. 785-798.
[144] Lenstra, H.W. Primality testing algorithms (after Adleman, Rumely and Williams). Bour- 
baki Seminar. V. 1980/81. 1981. (Leet. Notes in Math.; V. 901). Pp. 243-257.
[145] Lenstra, H.W. Divisors in residue classes. Math. Comp. 1984. V. 42 (165). Pp. 331-340.
[146] Lenstra, H. W. Elliptic curves and number-theoretic algorithms. International Congress of 
Mathematicians. 1986. Pp. 99-120.
[147] Lenstra, H. W. Factoring integers with elliptic curves. Ann. Math. 1987. V. 126. Pp. 649-673.
[148] Lenstra, H.W. Finding isomorphisms between finite fields. Math. Comp. 1991. V. 56 (193). 
Pp. 329-347.
[149] Lenstra, H. W., Pomerance, C. A rigorous time bound for factoring integers. J. Amer. Math. 
Soc. 1992. V. 5 (3). Pp. 483-516.
p—i i
[150] Lerch, M. Zur Theorie des Fermatischen Quotienten -—= q(a). Math. Ann. 1905.
V. 60. Pp. 471-490. 
P
[151] Lercier, R. Algorithmique des courbes dans les corps finis. These. L’Ecole Poly technique, 
Laboratoire D’Informatique, CNRC, Paris, 1997.
[152] Li, T. Y. Solving polynomial systems. Math. Intelligencer. 1987. V. 9. Pp. 33-39.
[153] Lidl, R., Niederreiter, H. Finite fields. With a foreword by P.M. Cohn. Second edition. Ency­
clopedia of Mathematics and its Applications, 20. Cambridge University Press, Cambridge, 
1997.
[154] Bender, R. Lovom. Rigorous, subexponential algorithms for discrete logarithms in GF(p2). 
SIAM J. Discrete Math., to appear.
[155] Bender, R. Lovom, Pomerance, C. Rigorous discrete logarithm computations in finite fields 
via smooth polynomials. Computational perspectives in number theory (Chicago, 1995). 
Amer. Math. Soc., 1998. (AMS/IS Stud. Adv. Math. V. 7). Pp. 221-232.
[156] Massey, J.L. Shift-register synthesis and BCH decoding. IEEE Trans. Inform. Theory. 1969. 
V. 15. Pp. 122-127.
[157] Matyukhin, D.V. On asymptotic complexity of computing discrete logarithms over GF(p). 
Discrete Math. Appl. 13, No.l, 27-50 (2003); translation from Diskretn. Mat. 15, No.l, 
28-49 (2003)
[158] Matyukhin, D.V., Murashov, N.N. A modification of the number field sieve method for 
the discrete logarithm in the field GF(p). Survey of applied and industrial mathematics, 
7(2):387-389, 2000. (Russian)

BIBLIOGRAPHY
229
[159] McCurley, K.S. The discrete logarithm problem. Cryptology and computational number 
theory (Boulder, CO, 1989). Amer. Math. Soc., 1990. (Proc, of Symp. Appl. Math.; V. 42). 
Pp. 49-74.
[160] McCurley, K.S. Odds and ends from cryptology and computational number theory. Cryp­
tology and computational number theory (Boulder, CO, 1989). Amer. Math. Soc., 1990. 
(Proc, of Symp. Appl. Math.; V. 42). Pp. 145-166.
[161] McKee, J. Speeding Fermat’s factoring method. Math. Comp. 1999. V. 68 (228). Pp. 1729- 
1737.
[162] Menezes, A. Elliptic curve public key cryptosystems. Kluwer Acad. Publ., 1993.
[163] Menezes, A., Van Oorschot, P.C., Vanstone, S.A. Handbook of applied cryptography. CRC 
Press, 1997.
[164] Menezes, A., Qu, M., Vanstone, S. IEEE P1363 Standard, Part 4: Elliptic curve systems, 
1995.
[165] Menezes, A. J., Vanstone, S.A., Zuccherato, R.J. Counting points on elliptic curves over 
F2m. Math. Comp. 1993. V. 60 (201). Pp. 407-420.
[166] Mignotte, M. An inequality about factors of polynomials. Math. Comp. 1974. V. 28. 
Pp. 1153-1157.
[167] Mihailescu, P. Cyclotomic primality proving — recent developments. Proceedings of ANTS- 
III. 1998. (Leet. Notes in Comput. Sci.; V. 1423). Pp. 95-110.
[168] Mihailescu, P. Cyclotomy of rings and primality testing. Ph.D. thesis. Swiss Federal Institute 
of Technology, Zurich, 1998.
[169] Mihailescu, P. Fast generation of provable primes using search in arithmetic progressions. 
Proc. CRYPTO ’94, Leet. Notes in Comput. Sci., V. 939 (1994) 282-293.
[170] Miller, G.L. Riemann’s hypothesis and tests for primality. J. Comput. and Syst. Sci. 1976. 
V. 13. Pp. 300-317.
[171] Miller, V. Use of elliptic curves in cryptography. Advances in cryptology — CRYPTO’85 
(Santa Barbara, Calif., 1985). 1986. (Lecture Notes in Comput. Sci.; V. 218). Pp. 417-426.
[172] Miyaji, A. Elliptic curves over Fp suitable for cryptosystems. Advances in cryptology — 
AUSCRYPT’92 (Gold Coast, 1992). 1993. (Leet. Notes in Comput. Sci.; V. 718). Pp. 479- 
471.
[173] Monier, L. Evaluation and comparison of two efficient probabilistic primality testing algo­
rithms. Theor. Comput. Sci. 1980. V. 12. Pp. 97-108.
[174] Montgomery, P.L. Modular multiplication without trial division. Math. Comp. 1985. 
V. 44 (170). Pp. 519-521.
[175] Montgomery, P.L. Speeding the Pollard and elliptic curve methods of factorization. Math. 
Comp. 1987. V. 48 (177). Pp. 243-264.
[176] Montgomery, P.L. A block Lanczos algorithm for finding dependencies over GF(2). Ad­
vances in Cryptology — EuroCrypt’95. Louis C. Guillou and Jean-Jacques Quisquater, 
editors. Springer-Verlag. Berlin. 1995. (Leet. Notes in Comput. Sci.; V. 921). Pp. 106-120.
[177] Montgomery, P.L., Silverman, R.D. A FFT-extension to the p — 1 factoring algorithm. 
Math. Comp. 1990. V. 54 (190). Pp. 839-854.
[178] Morain, F. Atkin’s test: news from the front. Proc. EUROCRYPT ’89, Leet. Notes in 
Comput. Sci., V. 434 (1989).
[179] Morain, F. Elliptic curves, primality proving and some titanic primes. Preprint.
[180] Morain, F. Solving equations of small degree modulo large primes. J. Arithmetiques, Aster- 
isque, 1989, v.199.
[181] Morain, F. Distributed primality proving and the primality of (23539 + l)/3. Proc. EURO­
CRYPT ’90, Leet. Notes in Comput. Sci., v. 473 (1990).
[182] Morain, F. Primality proving using elliptic curves: an update. Proceedings of ANTS-III. 
1998. (Leet. Notes in Comput. Sci.; V. 1423). Pp. 111-127.
[183] Morain, F., Olivos, J. Speeding up the computations on an elliptic curve using addition­
subtraction chains. Inform. Theor. et Appl. 1990. V. 24. Pp. 531-544.
[184] Mullen, G.L., White, D. A polynomial representation for logarithms in GF(q). Acta Arithm. 
1986. V. 47. Pp. 255-261.
[185] Muller, V. Ein Algorithmus zur Bestimmung der Punktzahl elliptischer Kurveniiber 
endlichen Korpern der Characteristic grossen drei. Ph.D. thesis, Universitat des Saarlan- 
des, 1995.

230
BIBLIOGRAPHY
[186] Murphy, B.A. Modelling the yield of number field sieve polynomials. Proceedings of ANTS- 
III. 1998. (Leet. Notes in Comput. Sci.; V. 1423). Pp. 137-150.
[187] Murphy, B.A. Polynomial selection for the number field sieve integer factorisation algorithm. 
Ph.D. thesis. Australian National University, July 1999.
[188] Murphy, B.A., Brent, R.P. On quadratic polynomials for the number field sieve. Austral. 
Comput. Sci. Comm. 1998. V. 20. Pp. 199-213.
[189] Naudin, P., Quitte, C. Algoritmique algebrique. Masson, 1992.
[190] Nechaev, V.I. The complexity of discrete logarithm. Nauchnye Trudy MGPU 1994. Pp. 
46-49. (Russian)
[191] Nechaev, V.I. Complexity of a determinate algorithm for the discrete logarithm, Mathemat­
ical Notes 55 (1994), 165-172.
[192] Nechaev, V.I. Elements of Cryptography. Basic Protection Information Theory. “Vysshaya 
Shkola”. Moscow. 1999.
[193] Niederreiter, H. A new efficient factorization algorithm for polynomials over small finite 
fields. Appl. Algebra Engrg. Comm. Comput. 1993. V. 4. Pp. 81-87.
[194] Niederreiter, H., Gottfert, R. Factorization of polynomials over finite fields and characteristic 
sequences. J. Symbolic Computation. 1993. V. 16 (5). Pp. 401-412.
[195] Odlyzko, A. Discrete logarithms and smooth polynomials. Contemp. Math. 1994. V. 168. 
Pp. 269-278.
[196] Odlyzko, A. Discrete logarithms: the past and the future. Designs, Codes and Cryptography. 
2000. V. 19. Pp. 129-145.
[197] Odlyzko, A.M. Discrete logarithms in finite fields and their cryptographic significance. Ad­
vances in Cryptology: Proceedings of EuroCrypt’84. Thomas Beth, Norbert Cot, and In- 
gemar Ingemarsson, editors. Berlin: Springer-Verlag, 1984. (Leet. Notes in Comput. Sci.; 
V. 209). Pp. 224-316.
[198] Odlyzko, A.M. The future of integer factorization. CryptoBytes. 1995. V. 1 (2). Pp. 5-12.
[199] Pankrat’ev, E.V. Computer algebra. Factorization of polynomials. MGU Moscow, 1988.
[200] Parkinson, D., Wunderlich, M. A compact algorithm for Gaussian elimination over GF(2) 
implemented on highly parallel computers. Parallel Computing. 1984. V. 1. Pp. 65-73.
[201] Peralta, R. Implementation of the hypercube multiple polynomial sieve. Preprint.
[202] Plaisted, D.A. Fast verification, testing and generation of large primes. Theoret. Comp. Sci. 
1979. V. 9. Pp. 1-16. Errata in: 1981. V. 14. P. 345.
[203] Pohlig, S., Hellman, M. An improved algorithm for computing logarithms over GF(p) and 
its cryptographic significance. IEEE Trans. Inform. Theory. 1978. V. 24. Pp. 106-110.
[204] Pohst, M. A modification of the LLL-reduction algorithm. J. Symb. Comp. 1987. V. 4. 
Pp. 123-128.
[205] Pohst, M., Zassenhaus, H. Algorithmic algebraic number theory. Cambridge University 
Press, 1989.
[206] Pollard, J.M. Theorems on factorization and primality testing. Proc. Cambridge Phil. Soc. 
1974. V. 76. Pp. 521-528.
[207] Pollard, J.M. A Monte Carlo method for factorization. BIT. 1975. V. 15. Pp. 331-334.
[208] Pollard, J.M. Monte Carlo methods for index computation (mod p). Math. Comp. 1978. 
V. 32 (143). Pp. 918-924.
[209] Pomerance, C. Analysis and comparision of some integer factoring algorithms. Computa­
tional methods in number theory. V. 1. H.W. Lenstra and R. Tijdeman, editors. Amsterdam, 
1982. Pp. 89-139.
[210] Pomerance, C. The quadratic sieve factoring algorithm. Advances in cryptology (Paris, 
1984). 1985. (Lecture Notes in Comput. Sci.; V. 209). Pp. 169-183.
[211] Pomerance, C. Fast, rigorous factorization and discrete logarithms. Discrete Algorithms 
and complexity. A. Nozaki, D.S. Johnson, T. Nishizeki, and H.S. Wilf, editors. Acad. Press. 
Mannheim-Orlando. 1987. Pp. 119-144.
[212] Pomerance, C. Very short primality proofs. Math. Comp. 1987. V. 48 (177). Pp. 315-322.
[213] Pomerance, C. Factoring. Proc, of Symp. Appl. Math. 1990. V. 42. Pp. 24-47.
[214] Pomerance, C. The number field sieve. Proc, of Symp. Appl. Math. 1994. V. 48. Pp. 465-480.
[215] Pomerance, C. A tale of two sieves. Notices Amer. Math. Soc. 1996. V. 43. Pp. 1473-1485.
[216] Pomerance, C., Selfridge, J.L., Wagstaff, S.S. The pseudoprimes to 2.5-109. Math. Comp. 
1980. V. 36 (151). Pp. 1003-1026.

BIBLIOGRAPHY
231
[217] Pomerance, C., Smith, J.W., Taler, R. A pipeline architecture for factoring large integers 
with the quadratic sieve algorithm. SIAM J. Comput. 1988. V. 17 (2). Pp. 387-403.
[218] Rabin, M. Probabilistic algorithms for testing primality. J. Number Theory. 1980. V. 12. 
Pp. 128-138.
[219] Ribenboim, P. The book of prime number records. Springer-Verlag, 1988.
[220] Ribenboim, P. The new book of prime number records. Springer-Verlag, 1996.
[221] Riesel, H. Prime numbers and computer methods for factorization. Birkhauser, 1985. (Progr. 
in Math.; V. 57).
[222] Riesel, H. Some soluble cases of the discrete logarithm problem. BIT. 1988. V. 28 (4). 
Pp. 839-851.
[223] Satoh, T., Arabi, K. Fermat quotients and polynomial time discrete log algorithm for anoma­
lous elliptic curves. Comment. Math. Univ. Sancti Pauli. 1998. V. 47. Pp. 81-92.
[224] Schirokauer, O. Discrete logarithms and local units. Phil. Trans. R. Soc. Lond. A. 1993. 
V. 345. Pp. 409-423.
[225] Schirokauer, O. Using number fields to compute discrete logarithms in finite fields. Math. 
Comp. 2000. V. 69. Pp. 1267-1283.
[226] Schirokauer, O., Weber, D., Denny, T. Discrete logarithms: The effectiveness of the index 
calculus method. Proceedings of ANTS-II. 1996. (Leet. Notes in Comput. Sci.; V. 1122). 
Pp. 337-362.
[227] Schnorr, C.P. A more efficient algorithm for lattice basis reduction. J. Algorithms. 1988. 
V. 9. Pp. 47-62.
[228] Schnorr, C.P., Euchner, M. Lattice basis reduction: improved practical algorithms and 
solving subset sum problems. Fundamentals of computation theory (Gosen, 1991). 1991. 
(Leet. Notes in Comput. Sci.; V. 529). Pp. 68-85.
[229] Schnorr, C.P., Lenstra, H. W. A Monte-Carlo factoring algorithm with linear storage. Math. 
Comp. 1984. V. 43. Pp. 289-312.
[230] Schonhage, A. The fundamental theorem of algebra in terms of computational complexity. 
Preliminary report, 1982. Math. Institute Univ. Tubingen.
[231] Schonhage, A., Grotfeld, A.F.W., Vetter, E. Fast algorithms: A multitape Turing machine 
implementation. Bl-Wissenschaftsverlag. Mannheim. 1994.
[232] Schoof, R. Elliptic curves over finite fields and the computation of square roots mod p. Math. 
Comp. 1985. V. 44. Pp. 483-494.
[233] Schoof, R. Counting points on elliptic curves over finite fields. J. Theorie des Nombres des 
Bordeaux. 1995. V. 7. Pp. 219-254.
[234] Sedgewick, R., Szymanski, T.G., Yao, A.C. The complexity of finding cycles in periodic 
functions. SIAM J. Comput. 1982. V. 11 (2). Pp. 376-390.
[235] Semaev, LA. An algorithm for evaluation of discrete logarithms in some nonprime finite 
fields. Math. Comp. 1998. V. 67. Pp. 1679-1689.
[236] Shanks, D. Class number, a theory of factorization and genera. Proc. Symp. Pure Math. 
V. 20. Providence, R.I.: AMS, 1971. Pp. 415-440.
[237] Shoup, V. The deterministic complexity of factoring polynomials over finite fields. Inform. 
Process. Lett. 1990. V. 33 (5). Pp. 261-267.
[238] Shoup, V. New algorithm for finding irreducible polynomials over finite fields. Math. Comp. 
1990. V. 54. Pp. 435-447.
[239] Shoup, V. Searching for primitive roots in finite fields. Math. Comp. 1992. V. 58 (197). 
Pp. 369-380.
[240] Shoup, V. Fast construction of irreducible polynomials over finite fields. J. Symbolic Comput. 
1994. V. 17 (5). Pp. 371-391.
[241] Shoup, V. A new polynomial factorization algorithm and its implementation. J. Symbolic 
Comput. 1995. V. 20. Pp. 364-397.
[242] Shoup, V. Lower bounds for discrete logarithms and related problems. Advances in Cryp­
tology — EuroCrypt’97. Walter Fumy, editor. Berlin: Springer-Verlag, 1997. (Leet. Notes 
in Comput. Sci.; V. 1233). Pp. 256-266.
[243] Shparlinski, I.E. Number theoretic methods in cryptography: Complexity lower bounds. 
Birkhauser, 1999.
[244] Silverman, J.H. The arithmetic of elliptic curves, Springer-Verlag, 1986. (Graduate Texts 
in Mathematics; V. 106).

232
BIBLIOGRAPHY
[245] Silverman, J.H. Advanced topics in the arithmetic of elliptic curves. Springer-Ver lag, 1994. 
(Graduate Texts in Mathematics; V. 151).
[246] Silverman, R.D. The multiple polynomial quadratic sieve. Math. Comp. 1987. V. 48 (177). 
Pp. 329-339.
[247] Silverman, R.D. Fast generation of random strong RS A primes. Preprint. RS A Laboratories, 
1997.
[248] Silverman, R.D., Wagstaff, S.S. A practical analysis of the elliptic curve factoring algorithm. 
Math. Comp. 1993. V. 61. Pp. 445-462.
[249] Solinas, J.A. An improved algorithm for arithmetic on a family of elliptic curves. Advances 
in Cryptology — Crypto’97. Burt Kaliski, editor. Springer-Verlag. Berlin. 1997. (Lecture 
Notes in Computer Science; V. 1294). Pp. 357-371.
[250] Solovay, R., Strassen, V. A fast Monte-Carlo test for primality. SIAM J. Comput. 1977. 
V. 6. Pp. 84-85. Errata in: 1978. V. 7. P. 117.
[251] Stewart, I., Tall, D. Algebraic number theory. Chapman and Hall. London and New York. 
1986.
[252] Strassen, V. Einige Resultate iiber Berechnungskomplexitat. Jahresber. Deutsch. Math.- 
Verein. 1976/77. V. 78. Pp. 1-8.
[253] te Riele, H. 227-digit SNFS factorization.
ftp://ftp.cwi.nl/pub/herman/SNFSgiajits/SNFS-227, January 2002.
[254] te Riele, Lioen, W., Winter, D. Factoring with the quadratic sieve on large vector 
computers. Belgian J. Comp. Appl. Math. 1989. V. 27. Pp. 267-278.
[255] Teske, E. Speeding up Pollard’s rho method for computing discrete logarithms. Proceedings 
of ANTS-III. 1998. (Leet. Notes in Comput. Sci.; V. 1423). Pp. 541-554.
[256] Teske, E. Square root algorithms for the discrete logarithm problem (a survey). Preprint, 
January 2001.
[257] Thome, E. Computation of discrete logarithms in GF(2607). Advances in Cryptology — 
AsiaCrypt’2001. 2001. (Leet. Notes in Comput. Sci.; V. 2248). Pp. 107-124.
[258] Thome, E. Discrete logarithms in GF(2607). e-mail to the NMBRTHRY mailing list, Feb­
ruary 2002.
http://listserv.nodak.edu/archives/nmbrthry.html.
[259] Toom A.L. The complexity of a scheme of functional elements realizing the multiplication 
of integers. Soviet Mathematics Doklady 150 (3) (1963), 714-716.
[260] Turk, J.W.M. Fast arithmetic operations on numbers and polynomials. Computational 
methods in number theory. V. 2. H.W. Lenstra and R. Tijdeman, editors. Amsterdam, 
1982. Pp. 43-54.
[261] Van der Waerden, B.L. Algebra, Vols. 1 and 2. Frederick Ungar Publishing Co. New York. 
1970.
[262] Vasilenko, O.N. Modern methods of primality testing of numbers. A survey. Kiberneticheskii 
Sbornik 25 (1988), 162-188. (Russian)
[263] Vasilenko, O.N. Some algorithms for constructing large prime numbers. Vestnik Moskov. 
Univ. Ser. I Mat. Mekh. 1997, no. 5, 62-64; translation in Moscow Univ. Math. Bull. 52 
(1997), no. 5, 50-51.
[264] Vasilenko, O.N. On some properties of Fermat numbers. Vestnik Moskov. Univ. Ser. I Mat. 
Mekh. 1998, no. 5, 56-58; translation in Moscow Univ. Math. Bull. 53 (1998), no. 5, 36-38 
(1999).
[265] Vasilenko, O.N. On the Miller-Rabin algorithm. Vestnik Moskov. Univ. Ser. I Mat. Mekh. 
2000, no. 2, 41-42, 65; translation in Moscow Univ. Math. Bull. 55 (2000), no. 2, 27-28.
[266] Vasilenko, O.N. On discrete logarithmization in some groups. Vestnik Moskov. Univ. Ser. I 
Mat. Mekh. 2000, no. 5, 53-55, 69; translation in Moscow Univ. Math. Bull. 55 (2000), no. 
5, 32-34 (2001).
[267] Vasilenko, O.N. On the discrete logarithm with composite modulus. IV International con­
ference “Modern problems of number theory and its applications”, Tula, 10-15 September, 
2001. Summaries of talks, pp. 35-36.
[268] Vasilenko, O.N. An application of trigonometric sums to test the primality of numbers. 
Vestnik Moskov. Univ. Ser. I Mat. Mekh. 2001, no. 5, 49-51, 71; translation in Moscow 
Univ. Math. Bull. 56 (2001), no. 5, 28-30 (2002).

REFERENCES ADDED IN THE ENGLISH EDITION
233
[269] Vasilenko, O.N. Application of cyclotomic fields in RS A cryptosystems. IV International 
conference “Modern problems of number theory and its applications”, Tula, 10-15 Septem­
ber, 2001. Summaries of talks, pp. 36-37.
[270] Vinogradov, I.M. An introduction to the theory of numbers. Pergamon Press. London & 
New York. 1955.
[271] von zur Gathen, J., Shoup, V. Computing Frobenius maps and factoring polynomials. Com- 
put. Complexity. 1992. V. 2. Pp. 187-224.
[272] Voorhoeve, M. Factorization algorithms of exponential order. Computational methods in 
number theory. V. 1. H.W. Lenstra and R. Tijdeman, editors. Amsterdam, 1982. Pp. 79-88.
[273] Weber, D. An implementation of the general number field sieve to compute discrete loga­
rithms modp. Advances in Cryptology — EuroCrypt’95. Louis C. Guillou and Jean-Jacques 
Quisquater, editors. Springer-Verlag. Berlin. 1995. (Lecture Notes in Computer Science; 
V. 921). Pp. 95-105.
[274] Weber, D. Computing discrete logarithms with the general number field sieve. Proceedings 
of ANTS-II. 1996. (Leet. Notes in Comput. Sci.; V. 1122). Pp. 391-404.
[275] Weber, D. On the computation of discrete logarithms in finite prime fields. Ph.D. thesis. 
Univ, des Saarlandes, Saarbriicken, 1997.
[276] Weber, D. Computing discrete logarithms with quadratic number rings. Advances in Cryp­
tology — EUROCRYPT’98. Springer-Verlag, 1998. (Leet. Notes in Comput. Sci.; V. 1403). 
Pp. 171-183.
[277] Weber, D., Denny, T. The solution of McCurley’s discrete log challenge. Advances in Cryp­
tology — CRYPTO’98. Springer-Verlag, 1998. (Leet. Notes in Comput. Sci.; V. 1462). 
Pp. 458-471.
[278] Weber, K. An experiment in high-precision arithmetic on shared memory multiprocessors. 
ACM SIGS AM Bull. 1990. V. 24 (2). Pp. 22-44.
[279] Western, A.E., Miller, J.C.P. Tables of indices and primitive roots. Cambridge University 
Press. 1968. (Royal Society Mathematical Tables; V. 9).
[280] Wiedemann, D.H. Solving sparse linear equations over finite fields. IEEE Trans. Inform. 
Theory. 1986. V. 32 (1). Pp. 54-62.
[281] Williams, H.C. Some algorithms for solving xq = TV (mod p). Proc. 3rd South East Conf, 
on Combinatorics, Graph Theory and Computing. 1972. Pp. 451-462.
[282] Williams, H.C. A p+ 1 method of factoring. Math. Comp. 1982. V. 39 (159). Pp. 225-234.
[283] Williams, H.C. Factoring on a computer. Math. Intell. 1984. V. 6 (3). Pp. 29-36.
[284] Williams, H. Testing numbers for primality using computers. Kiberneticheskii Sbornik 23 
(1986), 51-99. (Russian)
[285] Williams, H.C., Wunderlich, M.C. On the parallel generation of the residues for the con­
tinued fraction factoring algorithm. Math. Comp. 1987. V. 48 (177). Pp. 405-423.
[286] Wu, H. Efficient computations in finite fields with cryptographic significance. Ph.D. thesis. 
Univ, of Waterloo, Waterloo, Ontario, Canada, 1998.
[287] Wu, H. Montgomery multiplier and squarer in GF(2n). Technical report, Univ, of Waterloo, 
The Centre for applied cryptographic research, May 2000.
[288] Wu, H. On computation of polynomial modular reduction. Technical report, Univ, of Wa­
terloo, The Centre for applied cryptographic research, June 2000.
[289] Wu, H. On modular reduction. Technical report, Univ, of Waterloo, The Centre for applied 
cryptographic research, June 2000.
[290] Zayer, J. Factorisieren mit dem Number Field Sieve. Ph.D. thesis, Universitat der Saarlan­
des, 1995.
[291] Zierler, N. A conversion algorithm for logarithms on GF(2n). J. Pure and Appl. Algebra. 
1974. V. 4. Pp. 353-356.
[292] Zuras, D. On squaring and multiplying large integers. Proceedings of 11th IEEE Symp. 
Comp. Arith. IEEE Press, 1993. Pp. 260-271.
References added in the English edition
[293] A. Agashe, K. Lauter, and R. Venkatesan. Constructing elliptic curves with a given number 
of points over a finite field. Cryptology ePrint Archive, Report 2001/096.
[294] M. Ajtai. The shortest vector problem in L2 is NP-hard for the randomized reduction. In 
Proc. 30 ACM Symp. on Theory of Comput., ACM, pages 10-19, 1998.

234
BIBLIOGRAPHY
[295] M. Ajtai, R. Kumar, and D. Sivakumar. A sieve algorithm for the shortest lattice vector 
problem. In Proc. 33rd ACM Symp. on Theory of Comput., ACM, pages 601-610, 2001.
[296] K. Aoki, Y. Kudla, T. Shimoyama, and H. Ueda. GNFS factoring statistics of RSA- 
100,110,...,150. Cryptology ePrint Archive, Report 2004/095.
[297] K. Aoki and H. Ueda. Sieving using bucket sort. In Advances in Cryptology — ASI- 
ACRYPT’2004, volume 3329 of Leet. Notes in Comput. Sci., pages 92-102, 2004.
[298] K. Araki, T. Satoh, and S. Muira. Overview of elliptic curve cryptography. In Advances in 
Cryptology — PKC’98, volume 1431 of Leet. Notes in Comput. Sci., pages 29-49, 1998.
[299] L. Babai. On Lovasz lattice reduction and the nearest lattice point problem. Combinatorica, 
6:1-13, 1986.
[300] E. Bach. A note on square roots in finite fields. IEEE Trans. Inf. Theory, 36:1494-1498, 
1990.
[301] P. Barreto, H. Kim, B. Lynn, and M. Scott. Efficient algorithms for pairing-based cryptosys­
tems. In Advances in Cryptology — CRYPTC’2002, volume 2442 of Leet. Notes in Comput. 
Sci., pages 354-368, 2002.
[302] P. Barreto, B. Lynn, and M. Scott. Constructing elliptic curves with prescribed embedding 
degrees. In SCN’2002, volume 2576 of Leet. Notes in Comput. Sci., pages 263-273, 2002.
[303] M. Bauer and S. Hamdy. On class group computations using the number field sieve. In 
Advances in Cryptology — ASIACRYPT’2003, volume 2894 of Leet. Notes in Comput. 
Sci., pages 311-325, 2003.
[304] D. Bernstein. Circuits for integer factorization.
http://cr.yp.to/papers.html.
[305] D. Bernstein. Enumerating and counting smooth integers.
http://cr.yp.to/papers.html.
[306] D. Bernstein. Fast square roots in annoying finite fields.
http://cr.yp.to/papers.html.
[307] D. Bernstein. How to find small factors of integers.
http://cr.yp.to:80/papers/smallfactors.ps.
[308] D. Bernstein. The multiple-lattice number field sieve.
http://cr.yp.to/papers.html.
[309] D. Bernstein. Proving primality after Agraval-Kayal-Saxena.
http://cr.yp.to/primetests.html.
[310] P. Berrizbetia. Sharpening jjprimes is in P’^ for a large family of numbers.
http://lanl.arxiv.org/abs/math.NT/0211334, 2002.
[311] P. Berrizbetia and T. Berry. A generalization of Proth’s theorem. Acta Arithm., 110(2):107- 
115, 2003.
[312] I. Blake, K. Murty, and G. Xu. Refinements of Miller’s algorithm for computing Weil/Tate 
pairing. Cryptology ePrint Archive, Report 2004/065.
[313] I. Blake, G. Seroussi, and N. Smart. Advances in elliptic curve cryptography. Cambridge 
University Press, 2005.
[314] D. Boneh, G. Durfee, and N. Howgrave-Graham. Factoring N = prq for large r. In Advances 
in Cryptology — CRYPTO’99, volume 1666 of Leet. Notes in Comput. Sci., pages 326-337, 
1999.
[315] D. Boneh and M. Franklin. Identity based encryption from the Weil pairing. SIAM J. of 
Computing, 32(3):586-615, 2003.
[316] D. Boneh, B. Lynn, and H. Shacham. Short signatures from the Weil pairing. In Advances 
in Cryptology — ASIACRYPT’2001, volume 2248 of Leet. Notes in Comput. Sci., pages 
514-532, 2001.
[317] F. Brezing and A. Weng. Elliptic curves suitable for pairing based cryptography. Cryptology 
ePrint Archive, Report 2003/143.
[318] J. Camenisch and M. Michels. Proving in zero-knowledge that a number is the product 
of two safe primes. In Advances in Cryptology — EUROCRYPT’99, volume 1592 of Leet. 
Notes in Comput. Sci., pages 107-121, 1999.
[319] Q. Cheng. Primality proving via one round in ECPP and one iteration in AKS. In Advances 
in Cryptology — CRYPTO’2003, volume 2729 of Leet. Notes in Comput. Sci., pages 338- 
348, 2003.

REFERENCES ADDED IN THE ENGLISH EDITION
235
[320] J. Cheon, S. Park, S. Park, and D. Kim. Two efficient algorithms for arithmetic of elliptic 
curves using Frobenius map. In Advances in Cryptology — PKC’98, volume 1431 of Leet. 
Notes in Comput. Sci., pages 195-202, 1998.
[321] S. Chow, L. Hui, and S. Yui. Identity based threshold ring signature. Cryptology ePrint 
Archive, Report 2005/179.
[322] M. Ciet and M. Joye. Elliptic curve cryptosystems in the presence of permanent and transient 
faults. Cryptology ePrint Archive, Report 2003/028.
[323] M. Ciet, M. Joye, K. Lauter, and P. Montgomery. Trading inversions for multiplications in 
elliptic curve cryptography. Cryptology ePrint Archive, Report 2003/257.
[324] M. Ciet, T. Lange, F. Sica, and J.-J. Quisquater. Improved algorithms for efficient arith­
metic on elliptic curves using fast endomorphisms. In Advances in Cryptology — EURO- 
CRYPT’2003, volume 2656 of Leet. Notes in Comput. Sci., pages 388-400, 2003.
[325] H. Cohen, A. Miyaji, and T. Ono. Efficient elliptic curve exponentiation using mixed co­
ordinates. In Advances in Cryptology — ASIACRYPT’98, volume 1514 of Leet. Notes in 
Comput. Sci., pages 51-65, 1998.
[326] D. Coppersmith. Modifications to the number field sieve. J. Cryptology, 6:169-180, 1993.
[327] D. Coppersmith. Finding a small root of a bivariate integer equation; factoring with high 
bits known. In Advances in Cryptology — EUROCRYPT’96, volume 1070 of Leet. Notes in 
Comput. Sei., pages 178-189, 1996.
[328] D. Coppersmith. Finding a small roots of a univariate modular equation. In Advances in 
Cryptology — EUROCRYPT’96, volume 1070 of Leet. Notes in Comput. Sci., pages 155- 
165, 1996.
[329] D. Coppersmith. Small solutions to polynomial equations and low exponent RSA vulnera­
bilities. J. Cryptology, 10(4):223-260, 1997.
[330] D. Coppersmith. Special integer factorization. In Advances in Cryptology — EURO- 
CRYPT’98, volume 1403 of Leet. Notes in Comput. Sei., pages 542-545, 1998.
[331] D. Coppersmith, N. Howgrave-Graham, and S. Nagaraj. Divisors in residue classes, con­
structively, Preprint, Dec. 2, 2004.
[332] J.-S. Coron. Finding small roots of bivariate integer polynomial equations revisited. In Ad­
vances in Cryptology — EUROCRYPT’2004, volume 3027 of Leet. Notes in Comput. Sei., 
pages 492-505, 2004.
[333] J.-S. Coron and A. May. Deterministic polynomial time equivalence of computing the RSA 
secret key and factoring. Cryptology ePrint Archive, Report 2004/208.
[334] R. Crandall, E. Mayer, and J. Papadopoulos. The twenty-fourth Fermat number is compos­
ite. Math. Comput., 72(243):1555-1572, 2003.
[335] I. Damgard and M. Koprowski. Generic lower bounds for root extraction and signature 
schemes in general groups. In Advances in Cryptology — EUROCRYPT’2002, volume 2332 
of Leet. Notes in Comput. Sci., pages 256-271, 2002.
[336] V. Dimitrov, L. Imbert, and P. Mishra. Fast elliptic curve point multiplication using double­
base chains. Cryptology ePrint Archive, Report 2005/069.
[337] P. Duah, S. Cui, and C. Chan. Special polynomial families for generating more suitable 
elliptic curves for pairing-based cryptosystems. Cryptology ePrint Archive, Report 2005/342.
[338] R. Dupont, A. Enge, and F. Morain. Building curves with arbitrary small MOV degree over 
finite prime fields. Cryptology ePrint Archive, Report 2002/094.
[339] R. Dutta and R. Barua. Overview of key agreement protocols. Cryptology ePrint Archive, 
Report 2005/289.
[340] R. Dutta, R. Barua, and P. Sarkar. Pairing-based cryptographic protocols: a survey. Cryp­
tology ePrint Archive, Report 2004/064.
[341] K. Eisentrager, K. Lauter, and P. Montgomery. An efficient procedure to double and add 
points on an elliptic curve. Cryptology ePrint Archive, Report 2002/112.
[342] K. Eisentrager, K. Lauter, and P. Montgomery. Fast elliptic curve arithmetic and improved 
Weil pairing evaluation, volume 2612 of Leet. Notes in Comput. Sci., pages 343-354, 2003.
[343] K. Eisentrager, K. Lauter, and P. Montgomery. Improved Weil and Tate pairings for elliptic 
and hyperelliptic curves. In ANTS — VI, volume 3076 of Leet. Notes in Comput. Sci., pages 
169-183, 2004.
[344] A. Enge and P. Gaudry. A general framework for subexponential discrete logarithm algo­
rithms. Acta Arithmetica, 102(1):83-103, 2002.

236
BIBLIOGRAPHY
[345] P. Fitzpatric and C. Wolf. Direct division in factor rings. Electronic Letters, 38(21): 1253- 
1254, 2002.
[346] P.H. Flajolet, X. Gourdon, and D. Panario. The complete analysis of a polynomial factor­
ization algorithm over finite fields. J. of Algorithms, to appear
[347] M. Fouquet, P. Gaudry, and R. Harley. An extension of Satoh’s algorithm and its imple­
mentation. J. Ramanujan Math. Soc., 15:281-318, 2000.
[348] M. Fouquet, P. Gaudry, and R. Harley. Finding secure curves with the Satoh-FGH algorithm 
and an early-abort strategy. In Advances in Cryptology — EURCCRYPT’2001, volume 2045 
of Leet. Notes in Comput. Sci., pages 14-29, 2001.
[349] G. Frey and H. Ruck. A remark concerning m-divisibility and the discrete logarithm in the 
divisor class group of curves. Math. Comput., 62:865-874, 1994.
[350] M. Gagne. Applications of bilinear maps in cryptography. PhD. Thesis, University of Wa­
terloo, Ontario, Canada, 2002.
[351] S. Galbraith, K. Harrison, and D. Soldera. Implementing the Tate pairing. HP Laboratories 
Bristol, HPL-2002-23.
[352] S. Galbraith and A. Menezes. Algebraic curves and cryptography.
http://www.cacr.math.Waterloo.ca/techreports/2005/corr.2005-03.pdf.
[353] S. Gao and J. Howell. A general polynomial sieve. Preprint, 1999.
[354] J. Garcia and R. Garcia. Parallel algorithms for multiplication on elliptic curves. Cryptology 
ePrint Archive, Report 2002/179.
[355] P. Gaudry. Index calculus for abelian varieties and the elliptic curve discrete logarithm 
problem. Cryptology ePrint Archive, Report 2004/073.
[356] P. Gaudry. A comparison and combination of SST and AGM algorithms for counting points 
of elliptic curves in characteristic 2. In Advances in Cryptology — ASIACRYPT’2002, vol­
ume 2501 of Leet. Notes in Comput. Sci., pages 311-327, 2002.
[357] W. Geiselmann and R. Steinwandt. A dedicated sieving hardware. In Advances in Cryptology 
— PKC’2003, volume 2567 of Leet. Notes in Comput. Sci., pages 254-266, 2003.
[358] O. Goldreich, S. Goldwasser, and S. Halevi. Public-key cryptosystems from lattice reduction 
problems. In Proceedings of CRYPTO’97, volume 1294 of Leet. Notes in Comput. Sci., pages 
112-131, 1997.
[359] M. Gorantla, R. Gangishetti, and A. Saxena. A survey on ID-based cryptographic primitives. 
Cryptology ePrint Archive, Report 2005/094.
[360] J. Gordon. Strong primes are easy to find. In Proceedings of EUROCRYPT’84, volume 209 
of Leet. Notes in Comput. Sci., pages 216-223, 1985.
[361] J. Gower. Rotations and translations of number field sieve polynomials. In Advances in 
Cryptology — ASIACRYPT’2003, volume 2894 of Leet. Notes in Comput. Sci., pages 302- 
310, 2003.
[362] R. Granger and F. Vercauteren. On the discrete logarithm problem on algebraic tori. In 
Advances in Cryptology — CRYPTC’2005, volume 3621 of Leet. Notes in Comput. Sci., 
pages 66-85, 2005.
[363] A. Granville. It is easy to determine whether a given integer is prime. Bull. Amer. Math. 
Soc., 42(l):3-38, 2004.
[364] J. Guajardo, R. Blumel, U. Kreiger, and C. Paar. Efficient implementation of elliptic curve 
cryptosystems on the TIMSP430x33x family of microcontrollers. In Advances in Cryptology 
— PKC’2001, volume 1992 of Leet. Notes in Comput. Sci., pages 365-382, 2001.
[365] D. Hankerson, A. Menezes, and S. Vanstone. Guide to elliptic curve cryptography. Springer- 
Verlag, 2004.
[366] J. Hastad and M. Naslund. The security of all RSA and discrete log bits. Cryptology ePrint 
Archive, Report 1999/019.
[367] F. Hess. Exponent group signature schemes and efficient identity based signature schemes 
based on pairings. Cryptology ePrint Archive, Report 2002/012.
[368] F. Hess. A note on the Tate pairing of curves over finite fields, 2002.
[369] M. Hinek. Lattice attacks in cryptography: a partial overview. Technical Report CACR 
2004-08, 
.
http://cacr.uwaterloo.ca
[370] N. Howgrave-Graham. Finding small roots of univariate modular equations revisited. In 
Cryptography and Coding, volume 1355 of Leet. Notes in Comput. Sci., pages 131-142, 
1997.

REFERENCES ADDED IN THE ENGLISH EDITION
237
[371] T. Itoh. Efficient probabilistic algorithm for solving quadratic equations over finite fields. 
Electronics Letters, 23:869-870, 1987.
[372] T. Itoh. An efficient probabilistic algorithm for solving quadratic equation over finite fields. 
Electronics and Communications in Japan, 72:88-96, 1989.
[373] T. Izu and T. Takagi. Efficient computations of the Tate pairing for the large MOV degrees. 
In Proceedings of ICISC’2002, volume 2587 of Leet. Notes in Comput. Sci., pages 283-297, 
2003.
[374] A. Joux. A one round protocol for tripartite Diffie-Hellman. In Proceedings of ANTS-IV, 
volume 1838 of Leet. Notes in Comput. Sci., pages 385-394, 2000.
[375] A. Joux and R. Lercier. “Chinese and match” an alternative to Atkin’s “Match and sort” 
method used in SEA algorithm. Math. Comput., to appear.
[376] A. Joux and R. Lercier. The function field sieve is quite special. Preprint.
[377] A. Joux and R. Lercier. Improvements to the general number field sieve for discrete loga­
rithms in prime fields. Math. Comput., 72(242):953-967, 2003.
[378] C. Jutla. On finding small solutions of modular multivariate polynomial equations. In Ad­
vances in Cryptology — EUROCRYPT’98, volume 1403 of Leet. Notes in Comput. Sci., 
pages 158-170, 1998.
[379] G. Kang and J. Park. On the relationship between squared pairings and plane pairings. 
Cryptology ePrint Archive, Report 2005/112.
[380] G. Kang and J. Park. Powered Tate pairing computation. Cryptology ePrint Archive, Report 
2005/260.
[381] R. Kannan. Improved algorithms for integer programming and related lattice problems. In 
Proc. 15 ACM Symp. on Theory of Comput., ACM, pages 193-206, 1983.
[382] R. Kannan. Minkowski’s convex body theorem and integer programming. Math. Oper. Res., 
12(3):415-440, 1987.
[383] S. Kawamura, M. Koike, F. Sano, and A. Shimbo. Cox-rower architecture for fast paral­
lel Montgomery multiplication. In Advances in Cryptology — EURCCRYPT’2000, volume 
1807 of Leet. Notes in Comput. Sci., pages 523-538, 2000.
[384] M. Khabbazian, T. Gulliver, and V. Bhargava. Partially fixed point multiplication. Cryp­
tology ePrint Archive, Report 2005/113.
[385] H. Kim, J. Park, J. Cheon, J. Park, J. Kim, and S. Hahn. Fast elliptic curve point counting 
using Gaussian normal basis. In ANTS-V, volume 2369 of Leet. Notes in Comput. Sci., 
pages 292-307, 2002.
[386] P. Klein. Finding the closest lattice vector when it’s unusually close. In Proc, of SODA ’2000, 
ACM-SIAM, 2000.
[387] E. Knudsen. Elliptic scalar multiplication using point halving. In Advances in Cryptology 
— ASIACRYPT’99, volume 1716 of Leet. Notes in Comput. Sci., pages 135-149, 1999.
[388] N. Koblitz and A. Menezes. Pairing-based cryptography at high security level. Cryptology 
ePrint Archive, Report 2005/076.
[389] D. Kohel. The AGM — Xq(N) Heegner point lifting algorithm and elliptic curve point 
counting. In Advances in Cryptology — ASIACRYPT’2003, volume 2894 of Leet. Notes in 
Comput. Sci., pages 124-136, 2003.
[390] K. Kurosa, K. Schmidt-Samoa, and T. Takagi. A complete and explicit security reduction 
algorithm for RSA-based cryptosystems. In Advances in Cryptology — ASIACRYPT’2003, 
volume 2894 of Leet. Notes in Comput. Sci., pages 474-491, 2003.
[391] T. Le, K. Nguyen, and V. Varadharadjan. How to prove that a committed number is prime. 
In Advances in Cryptology — ASIACRYPT’99, volume 1716 of Leet. Notes in Comput. 
Sci., pages 208-218, 1999.
[392] Y.-R. Lee and H.-S. Lee. An authenticated certificateless public key encryption scheme. 
Cryptology ePrint Archive, Report 2004/150.
[393] A. Lenstra. Generating RSA moduli with a predetermined portion. In Advances in Cryptol­
ogy — ASIACRYPT’98, volume 1514 of Leet. Notes in Comput. Sci., pages 1-10, 1998.
[394] A. Lenstra and A. Shamir. Analysis and optimization of the TWINKLE factoring device. 
In Advances in Cryptology — EUROCRYPT’2000, volume 1807 of Leet. Notes in Comput. 
Sci., pages 35-52, 2000.
[395] A. Lenstra, A. Shamir, J. Tomlinson, and E. Tromer. Analysis of Bernstein’s factorization 
circuit. In Advances in Cryptology — ASIACRYPT’2002, volume 2501 of Leet. Notes in 
Comput. Sci., pages 1-26, 2002.

238
BIBLIOGRAPHY
[396] A. Lenstra, E. Tromer, A. Shamir, W. Kortsmith, B. Dodson, J. Hudges, and P. Ley- 
land. Factoring estimates for a 1024-bit RS A modulus. In Advances in Cryptology — ASI- 
ACRYPT’2003, volume 2894 of Leet. Notes in Comput. Sci., pages 55-74, 2003.
[397] H. Lenstra, J. Pila, and C. Pomerance. A hyperelliptic smoothness test. Part 1. Phil. Trans. 
R. Soc. London. A., 345:397-408, 1993.
[398] H. Lenstra, J. Pila, and C. Pomerance. A hyperelliptic smoothness test. Part 2. Proc. London 
Math. Soc. (3), 84:105-146, 2002.
[399] R. Lercier and D. Lubicz. Counting points on elliptic curves over finite fields of small charac­
teristic in quasi quadratic time. In Advances in Cryptology — EURCCRYPT’2003, volume 
2656 of Leet. Notes in Comput. Sci., pages 360-373, 2003.
[400] R. Lercier and F. Vercauteren. Computation of DLOGs in Fpis with p = 37081. Preprint, 
2005
[401] S. Li and C. Pomerance. New aspects of analytic number theory. RIMS Kokyuroku, (1274), 
2002.
[402] B. Libert and J. Quisquater. New identity based signcryption schemes from pairings. Cryp­
tology ePrint Archive, Report 2003/023.
[403] S. Lindhurst. Computing roots in finite fields and groups with a jaunt through sums of 
integers. Ph.D. Thesis, University of Wisconsin at Madison, 1997.
[404] D. Matyukhin. Cyclotomic integers and discrete logarithms in GF(p2). In Probabilistic Meth­
ods in Discrete Mathematics. Proceedings of the Fifth Int. Petrozavodsk Conf., pages 237- 
256, Utrecht-Tokyo, 2002. VSP.
[405] N. McCullagh and P. Barreto. A new two-party identity-based authenticated key agreement. 
Cryptology ePrint Archive, Report 2005/122.
[406] P. Mishra. Scalar multiplication in elliptic curve cryptosystems: pipelining with pre­
computations. Cryptology ePrint Archive, Report 2004/191.
[407] P. Mishra and P. Sarkar. Inversion of several field elements: a new parallel algorithm. Cryp­
tology ePrint Archive, Report 2003/264.
[408] A. Miyaji, M. Nakabayashi, and S. Takano. New explicit conditions of elliptic curve traces 
for FR-reduction. In IEICE Trans. Fundamentals, E84-A(5), pages 1234-1243, 2001.
[409] P. Montgomery. Square roots of products of algebraic numbers. Draft of May 16, 1997.
[410] S. Muller. A provable prime test with very high confidence for n = l(mod 4). In Advances 
in Cryptology — ASIACRYPT’2001, volume 2248 of Leet. Notes in Comput. Sei., pages 
87-106, 2001.
[411] S. Muller. On the computation of square roots in finite fields. Designs, Codes and Crypt., 
31(3):301-312, 2004.
[412] P. Nguyen. A Montgomery-like square-root for the number field sieve. In Proceedings of 
ANTS-III, volume 1423 of Leet. Notes in Comput. Sei., pages 151-168, 1998.
[413] P. Nguyen. Cryptanalysis of the Goldreich-Goldwasser-Halevi cryptosystem from 
CRYPTO’97. In Advances in Cryptology — CRYPTO’99, volume 1666 of Leet. Notes in 
Comput. Sei., pages 288-304, 1999.
[414] P. Nguyen and J. Stern. Lattice reduction in cryptology: an update. In Proceedings of 
ANTS-IV, volume 1838 of Leet. Notes in Comput. Sci., pages 85-112, 2000.
[415] C. bhEigeartaigh. Speeding up pairing computation. Cryptology ePrint Archive, Report 
2005/293.
[416] D. Page, N. Smart, and F. Vercauteren. A comparison of MNT curves and supersingular 
curves. Cryptology ePrint Archive, Report 2004/165.
[417] K. Paterson. ID-based signatures from pairings on elliptic curves. Electronics Letters, 
38:1025-1026, 2002.
[418] R. Peralta. A simple and fast probabilistic algorithm for computing square roots modulo a 
prime number. IEEE Trans. Inf. Theory, 32:846-847, 1986.
[419] E. Popovici and P. Fitzpatrik. Division algorithm over GF(2m). Electronics Letters, 
34(19):1843-1844, 1998.
[420] E. Popovici and P. Fitzpatrik. Algorithm and architecture for a multiplicative Galois field 
processor. IEEE Trans. Inf. Theory, 49:3303-3307, 2003.
[421] G. Poupard and J. Stern. Short proofs of knowledge for factoring. In Advances in Cryptology 
— PKC’2000, volume 1751 of Leet. Notes in Comput. Sci., pages 147-166, 2000.
[422] H. Ritter and C. Rossner. Factoring via strong lattice reduction algorithms. Cryptology 
ePrint Archive, Report 1997/008.

REFERENCES ADDED IN THE ENGLISH EDITION
239
[423] R. Rivest and R. Silverman. Are “strong” primes needed for RSA? Cryptology ePrint 
Archive, Report 2001/007.
[424] T. Satoh. The canonical lift of an ordinary elliptic curve over finite field and its point 
counting. J. Ramanujan Math. Soc., 15:247-270, 2000.
[425] T. Satoh. On p-adic point counting algorithms for elliptic curves over finite fields. In Pro­
ceedings of ANTS-V, volume 2369 of Leet. Notes in Comput. Sci., pages 43-66, 2002.
[426] T. Satoh, B. Skjernaa, and Y. Taguchi. Fast computation of canonical lifts of elliptic curves 
and its application to point counting. Finite Fields Appl., 9(l):89-101, 2003.
[427] C. Schnorr. Security of almost all discrete log bits. Cryptology ePrint Archive, Report 
1998/020.
[428] C. Schnorr. A hierarchy of polynomial lattice basis reduction algorithms. Theor. Comput. 
Sci., 53:201-224, 1987.
[429] C. Schnorr. Fast LLL-type lattice reduction.
http: //www. mi. informatik. uni-frankfurt. de/research/papers. html, 2004.
[430] C. Schnorr. Gittertheorie und Algorithmische Geometric. Leet. Notes Universitat Frankfurt, 
Frankfurt, 
, 2004.
http://www.mi.informatik.uni-frankfurt.de/index.html#teaching
[431] C. Schnorr and H. Horner. Attacking the Chor-Rivest cryptosystem by improved lattice 
reduction. In Proceedings of EUROCRYPT’95, volume 921 of Leet. Notes in Comput. Sci., 
pages 1-12, 1995.
[432] M. Scott. Faster pairings using an elliptic curve with an efficient endomorphism. Cryptology 
ePrint Archive, Report 2005/252.
[433] M. Scott and P. Barreto. Generating more MNT elliptic curves. Cryptology ePrint Archive, 
Report 2004/058.
[434] I. Semaev. Summation polynomials and the discrete logarithm problem on elliptic curves. 
Cryptology ePrint Archive, Report 2004/031.
[435] A. Shamir. Factoring large integers with the TWINKLE device. In Cryptographic Hardware 
and Embedded Systems. First Int. Workshop, CHES’99, volume 1717 of Leet. Notes in 
Comput. Sci., pages 2-12, 1999.
[436] A. Shamir and E. Tromer. Factoring large numbers with the TWIRL device. In Advances 
in Cryptology — CRYPTC’2003, volume 2729 of Leet. Notes in Comput. Sci., pages 1-26, 
2003.
[437] Y. Shi and J. Li. Provable efficient certificateless public key encryption. Cryptology ePrint 
Archive, Report 2005/287.
[438] V. Shoup. A computational introduction to number theory and algebra.
http://www.shoup.net/ntb.
[439] B. Skjernaa. Satoh’s algorithm in characteristic 2. 
 skjernaa/.
http://www.inf.au.dk/
[440] N. Smart. An identity based authenticated key agreement protocol based on the Weil pairing. 
Electronics Letters, 38:630-632, 2002.
[441] N. Smart and F. Vercauteren. On computable isomorphisms in efficient pairing based sys­
tems. Cryptology ePrint Archive, Report 2005/116.
[442] O. Vasilenko. On some properties of integer factorization. Trudy po diskretnoi matematike, 
(7):22-30, 2003.
[443] F. Vercauteren, B. Preneel, and J. Vandewalle. A memory efficient version of Satoh’s algo­
rithm. In Advances in Cryptology — EUROCRYPT’2001, volume 2045 of Leet. Notes in 
Comput. Sci., pages 1-13, 2001.
[444] K. Williams and K. Hardy. A refinement of H.C. Williams’s gth root algorithm. Math. 
Comput., 61:475-483, 1993.
[445] J. Xu, Z. Zang, and D. Feng. ID-based proxy signature using bilinear pairings. Cryptology 
ePrint Archive, Report 2004/206.


Index
B-power-smooth number, xii
B-smooth number, xii
A-low number, 103
/-factoring polynomial, 122
j-invariant, 74
addition on an elliptic curve, 73
algorithm
Adleman-Pomerance-Rumely, 23
generalized Euclidean, 215
Montgomery, 200
Adleman’s, 93
Adleman-Huang, 26
Atkin-Morain, 26
Ben-Or, 132
Berlekamp, 123
Berlekamp-Massey, 212
binary, 220
block Lanczos, 208
Brillhart-Morrison, 55
Cohen-Lenstra, 26
compatibilty, 91
Coppersmith, 97
Coppersmith-Odlyzko-Schroeppel, 94
Coppersmith-Winograd, 214 
deterministic primality testing, 27
Dixon’s, 52
ElGamal, 97
Euclidean, 215
Ferguson-Forcade, 147
Fermat’s, 35
for calculating a linear dependence, 144
for calculating short lattice vectors, 146
for computation of the minimal
polynomial, 172
for constructing an LLL-reduced basis, 
138
for finding the order of an element, 14
for solving f(x) = 0 in GF(p), 115
Garner’s, 199
generalized binary, 221
Goldwasser-Kilian, 26
index-calculus, 96
Lanczos, 208
Lazard, 132
Lehmer’s, 220
Lenstra’s, 43
Lenstra-Pomerance, 62 
number field sieve, 62 
Pohlig-Hellman, 92
Pollard-Strassen, 47 
polynomial, xii 
probabilistic irreducibility testing, 129 
quadratic sieve, 58
Schnorr-Lenstra, 61 
Schonhage-Strassen, 185
Schoof’s, 78
Shanks-Tonelli, 119
Sherman-Lehman, 40
Strassen, 214
Toom-Cook, 190
Wiedemann, 211
basis
completely reduced, 136
Groebner, 132
LLL-reduced, 136
Minkowski-reduced, 136
of a lattice, 135
binary exponentiation methods, 222 
binary quadratic form, 48
canonical factorization of a natural 
number, 1
Carmichael function, 16
Carmichael numbers, 2
Chinese Remainder Theorem, 216
Cholesky factorization, 146
complete system of residues, 216 
complexity
exponential, xii 
of an algorithm, xii 
polynomial, xii 
subexponential, xii
congruence, 216
convergent, 219
degree of an algebraic number, 169
241

242
INDEX
determinant of the lattice, 135
discrete logarithm, 91
problem, 91
discrete set, 135
elliptic curve, 73
Euler criterion, 218 
exponential complexity, xii
Extended Riemann Hypothesis, 15
factor base, 52
fast column multiplication, 189
fast Fourier transform, 176
Fermat quotient, 102 
fraction
n-term continued, 218
continued, 218
infinite continued, 219
periodic, 219
Frobenius map, 78
function
Carmichael, 102
Euler, 216 
fundamental theorem of arithmetic, 1
Gaussian elimination, 207
structured, 207
Gauss lemma, 159
Gram matrix, 141
Gram-Schmidt orthogonalization process, 
135
Hadamard inequality, 135
height of an algebraic number, 169
Jacobi
sum, 24
symbol, 217
Krylov sequence, 208
lattice, 135
law of quadratic reciprocity, 218
Legendre symbol, 217
length of the input, xii 
lifting
linear, 166
quadratic, 166
LLL algorithm
for factorization of polynomials, 167
integral, 141
with deep insertions, 140
method
Cantor-Zassenhaus, 126
Karatsuba’s, 189
of exponentiation, 221
of trial divisions, 1
Shanks’, 48
SQUFOF, 48
Montgomery 
exponentiation, 199 
multiplication, 199 
reduction, 199
normalized vector, 149
norm of a polynomial, 160 
number
B-power-smooth, xii
B-smooth, xii, 64 
algebraic, 169 
conjugate, 169 
Euclidean prime, 24
Fermat, 3 
initial prime, 24 
Lucas, 4 
Mersenne, 3 
Sophie Germain, 33 
strictly pseudoprime, 2 
numerical character, 217
orthogonalization process, 209
Pohst’s MLLL algorithm, 143 
point at infinity, 73
Pollard’s
(P — l)-method, 37
p-method, 39
for the discrete logarithm problem, 93 
polynomial
algorithm, xii 
complexity, xii 
division, 79 
minimal, 169 
primitive, 159
Pratt certificate, 12
prime
ideal, 65
degree one, 65 
number, 1
primitive root, 217
quadratic 
nonresidue, 217 
reciprocity law, 218 
residue, 217
reduced system of residues, 216 
resultant, 127
Schirokauer’s additive character, 101 
sieve, 59
number field, 62
for computing discrete logarithm, 99 
of Eratosthenes, 1
solvability of the discrete logarithm 
problem, 105

INDEX
243
strategy
EAS, 55
LP, 54
PS, 54
subexponential complexity, xii
symbol
Jacobi, 217
Legendre, 217
test
Miller-Rabin, 20
Solovay-Strassen, 19
theorem
Chinese Remainder, 216
Dirichlet’s unit, 66
Euler, 216
Euler-Lagrange, 219
Fermat’s Little, 216
Hasse, 74
Lame, 215
Schonhage-Strassen, 185 
unit of a field, 66
Williams’ (P + l)-method, 48
zero point of the curve, 73


Titles in This Series
233 A. Ya. Helemskii, Lectures and exercises on functional analysis, 2006
232 O. N. Vasilenko, Number-theoretic algorithms in cryptography, 2007
231 Kiyosi Ito, Essentials of stochastic processes, 2006
230 Akira Kono and Dai Tamaki, Generalized cohomology, 2006
229 Yu. N. Lin'kov, Lectures in mathematical statistics, 2005
228 D. Zhelobenko, Principal structures and methods of representation theory, 2006
227 Takahiro Kawai and Yoshitsugu Takei, Algebraic analysis of singular perturbation 
theory, 2005
226 V. M. Manuilov and E. V. Troitsky, Hilbert C*-modules, 2005
225 S. M. Natanzon, Moduli of Riemann surfaces, real algebraic curves, and their 
superanaloges, 2004
224 Ichiro Shigekawa, Stochastic analysis, 2004
223 Masatoshi Noumi, Painleve equations through symmetry, 2004
222 G. G. Magaril-Il’yaev and V. M. Tikhomirov, Convex analysis: Theory and 
applications, 2003
221 Katsuei Kenmotsu, Surfaces with constant mean curvature, 2003
220 I. M. Gelfand, S. G. Gindikin, and M. I. Graev, Selected topics in integral 
geometry, 2003
219 S. V. Kerov, Asymptotic representation theory of the symmetric group and its 
applications to analysis, 2003
218 Kenji Ueno, Algebraic geometry 3: Further study of schemes, 2003
217 Masaki Kashiwara, D-modules and microlocal calculus, 2003
216 G. V. Badalyan, Quasipower series and quasianalytic classes of functions, 2002
215 Tatsuo Kimura, Introduction to prehomogeneous vector spaces, 2003
214 L. S. Grinblat, Algebras of sets and combinatorics, 2002
213 V. N. Sachkov and V. E. Tarakanov, Combinatorics of nonnegative matrices, 2002
212 A. V. Mel'nikov, S. N. Volkov, and M. L. Nechaev, Mathematics of financial 
obligations, 2002
211 Takeo Ohsawa, Analysis of several complex variables, 2002
210 Toshitake Kohno, Conformal field theory and topology, 2002
209 Yasumasa Nishiura, Far-from-equilibrium dynamics, 2002
208 Yukio Matsumoto, An introduction to Morse theory, 2002
207 Ken’ichi Ohshika, Discrete groups, 2002
206 Yuji Shimizu and Kenji Ueno, Advances in moduli theory, 2002
205 Seiki Nishikawa, Variational problems in geometry, 2001
204 A. M. Vinogradov, Cohomological analysis of partial differential equations and 
Secondary Calculus, 2001
203 Te Sun Han and Kingo Kobayashi, Mathematics of information and coding, 2002
202 V. P. Maslov and G. A. Omel'yanov, Geometric asymptotics for nonlinear PDE. I, 
2001
201 Shigeyuki Morita, Geometry of differential forms, 2001
200 V. V. Prasolov and V. M. Tikhomirov, Geometry, 2001
199 Shigeyuki Morita, Geometry of characteristic classes, 2001
198 V. A. Smirnov, Simplicial and operad methods in algebraic topology, 2001
197 Kenji Ueno, Algebraic geometry 2: Sheaves and cohomology, 2001
196 Yu. N. Lin'kov, Asymptotic statistical methods for stochastic processes, 2001
195 Minoru Wakimoto, Infinite-dimensional Lie algebras, 2001

TITLES IN THIS SERIES
194 Valery B. Nevzorov, Records: Mathematical theory, 2001
193 Toshio Nishino, Function theory in several complex variables, 2001
192 Yu. P. Solovyov and E. V. Troitsky, C*-algebras and elliptic operators in differential 
topology, 2001
191 Shun-ichi Amari and Hiroshi Nagaoka, Methods of information geometry, 2000
190 Alexander N. Starkov, Dynamical systems on homogeneous spaces, 2000
189 Mitsuru Ikawa, Hyperbolic partial differential equations and wave phenomena, 2000
188 V. V. Buldygin and Yu. V. Kozachenko, Metric characterization of random variables 
and random processes, 2000
187 A. V. Fursikov, Optimal control of distributed systems. Theory and applications, 2000
186 Kazuya Kato, Nobushige Kurokawa, and Takeshi Saito, Number theory 1: 
Fermat’s dream, 2000
185 Kenji Ueno, Algebraic Geometry 1: From algebraic varieties to schemes, 1999
184 A. V. Mel'nikov, Financial markets, 1999
183 Hajime Sato, Algebraic topology: an intuitive approach, 1999
182 I. S. Krasil'shchik and A. M. Vinogradov, Editors, Symmetries and conservation 
laws for differential equations of mathematical physics, 1999
181 Ya. G. Berkovich and E. M. Zhmud', Characters of finite groups. Part 2, 1999
180 A. A. Milyutin and N. P. Osmolovskii, Calculus of variations and optimal control, 
1998
179 V. E. Voskresenskii, Algebraic groups and their birational invariants, 1998
178 Mitsuo Morimoto, Analytic functionals on the sphere, 1998
177 Satoru Igari, Real analysis—with an introduction to wavelet theory, 1998
176 L. M. Lerman and Ya. L. Umanskiy, Four-dimensional integrable Hamiltonian 
systems with simple singular points (topological aspects), 1998
175 S. K. Godunov, Modern aspects of linear algebra, 1998
174 Ya-Zhe Chen and Lan-Cheng Wu, Second order elliptic equations and elliptic 
systems, 1998
173 Yu. A. Davydov, M. A. Lifshits, and N. V. Smorodina, Local properties of 
distributions of stochastic functionals, 1998
172 Ya. G. Berkovich and E. M. Zhmud', Characters of finite groups. Part 1, 1998
171 E. M. Landis, Second order equations of elliptic and parabolic type, 1998
170 Viktor Prasolov and Yuri Solovyev, Elliptic functions and elliptic integrals, 1997
169 S. K. Godunov, Ordinary differential equations with constant coefficient, 1997
168 Junjiro Noguchi, Introduction to complex analysis, 1998
167 Masaya Yamaguti, Masayoshi Hata, and Jun Kigami, Mathematics of fractals, 1997
166 Kenji Ueno, An introduction to algebraic geometry, 1997
165 V. V. Ishkhanov, B. B. Lur'e, and D. K. Faddeev, The embedding problem in 
Galois theory, 1997
164 E. I. Gordon, Nonstandard methods in commutative harmonic analysis, 1997
163 A. Ya. Dorogovtsev, D. S. Silvestrov, A. V. Skorokhod, and M. I. Yadrenko, 
Probability theory: Collection of problems, 1997
162 M. V. Boldin, G. I. Simonova, and Yu. N. Tyurin, Sign-based methods in linear 
statistical models, 1997
161 Michael Blank, Discreteness and continuity in problems of chaotic dynamics, 1997
For a complete list of titles in this series, visit the 
AMS Bookstore at www.ams.org/bookstore/.

Algorithmic number theory is a rapidly developing 
branch of number theory, which, in addition to its 
mathematical importance, has substantial applica­
tions in computer science and cryptography. Among 
the algorithms used in cryptography, the following 
are especially important:
• algorithms for primality testing;
• factorization algorithms for integers and for poly­
nomials in one variable;
• applications of the theory of elliptic curves;
• algorithms for computation of discrete logarithms;
• algorithms for solving linear equations over finite fields;
• algorithms for performing arithmetic operations on large integers.
The book describes the current state of these and some other algorithms. 
It also contains an extensive bibliography. For this English translation, 
additional references were prepared and commented on by the author.
M For additional information
H and updates on this book, visit
www.ams.org/bookpages/mmono-232
ISBN D-fiElfi-MDlD-fi
AMS on the Web
www.ams.or

