
CATEGORICAL LOGIC 
AND TYPE THEORY 

STUDIES IN LOGIC 
AND 
THE FOUNDATIONS OF MATHEMATICS 
VOLUME 141 
Honorary Editor: 
P. SUPPES 
Editors: 
S. ABRAMSKY, London 
S. ARTEMOV, Moscow 
R.A. SHORE, Ithaca 
A.S. TROELSTRA, Amsterdam 
ELSEVIER 
AMSTERDAM • LAUSANNE • NEW YORK • OXFORD • SHANNON • SINGAPORE • TOKYO 

CATEGORICAL LOGIC 
AND TYPE THEORY 
Bart JACOBS 
Research Fellow of the 
Royal Netherlands Academy of Arts and Sciences 
Computing Science Institute^ 
University of Nijmegen, P.O. Box 9010, 6500 GL Nijmegen, 
The Netherlands 
1999 
ELSEVIER 
AMSTERDAM • LAUSANNE • NEW YORK • OXFORD • SHANNON • SINGAPORE • TOKYO 

ELSEVIER SCIENCE B.V. 
Sara Burgerhartstraat 25 
P.O. Box 211, 1000 AE Amsterdam, The Netherlands 
© 1999 Elsevier Science B.V.. All rights reserved. 
This work and the individual contributions contained in it are protected under copyright by Elsevier Science 
B.V., and the following terms and conditions apply to its use: 
Photocopying 
Single photocopies of single chapters may be made for personal use as allowed by national copyright laws. Permission 
of the publisher and payment of a fee is required for all other photocopying, including multiple or systematic copying, 
copying for advertising or promotional purposes, resale, and all forms of document delivery. Special rates are available 
for educational institutions that wish to make photocopies for non-profit educational classroom use. 
Permissions may be sought directly from Elsevier Science Rights & Permissions Department, PO Box 800, Oxford 
0X5 IDX, UK; phone: (+44) 1865 843830, fax: (+44) 1865 853333, e-mail: permissions@elsevier.co.uk. You may 
also contact Rights & Permissions directly through Elsevier's home page (http://www.elsevier.nl), selecting first 
'Customer Support', then 'General Information', then 'Permissions Query Form'. 
In the USA, users may clear permissions and make payments through the Copyright Clearance Center, Inc., 222 
Rosewood Drive, Danvers, MA 01923, USA; phone: (978) 7508400, fax: (978) 7504744, and in the UK through the 
Copyright Licensing Agency Rapid Clearance Service (CLARCS), 90 Tottenham Court Road, London WIP OLP, 
UK; phone: (+44) 171 436 5931; fax: (+44) 171 436 3986. Other countries may have a local reprographic rights 
agency for payments. 
Derivative Works 
Subscribers may reproduce tables of contents for internal circulation within their institutions. Permission of the 
publisher is required for resale or distribution of such material outside the institution. 
Permission of the publisher is required for all other derivative works, including compilations and translations. 
Electronic Storage or Usage 
Permission of the publisher is required to store or use electronically any material contained in this work, including any 
chapter or part of a chapter. Contact the publisher at the address indicated. 
Except as outlined above, no part of this work may be reproduced, stored in a retrieval system or transmitted in any 
form or by any means, electronic, mechanical, photocopying, recording or otherwise, without prior written 
permission of the publisher. 
Address permissions requests to: Elsevier Science Rights & Permissions Department, at the mail, fax and e-mail 
addresses noted above. 
Notice 
No responsibility is assumed by the Publisher for any injury and/or damage to persons or property as a matter of 
products liability, negligence or otherwise, or from any use or operation of any methods, products, instructions or ideas 
contained in the material herein. Because of rapid advances in the medical sciences, in particular, independent 
verification of diagnoses and drug dosages should be made. 
First edition 1999 
Library of Congress Cataloging in Publication Data 
A catalog record from the Library of Congress has been applied for. 
ISBN: 0 444 50170 3 
@The paper used in this publication meets the requirements of ANSI/NISO Z39.48-1992 
(Permanence of Paper). 
Printed in The Netherlands. 

Preface 
This book has its origins in my PhD thesis, written during the years 1988 -
1991 at the University of Nijmegen, under supervision of Henk Barendregt. 
The thesis concerned categorical semantics of various type theories, using 
fibred categories. The connections with logic were not fully exploited at the 
time. This book is an attempt to give a systematic presentation of both logic 
and type theory from a categorical perspective, using the unifying concept of 
a fibred category. Its intended audience consists of logicians, type theorists, 
category theorists and (theoretical) computer scientists. 
The main part of the book was written while I was employed by NWO, 
the National Science Foundation in The Netherlands. First, during 1992 -
1994 at the Mathematics Department of the University of Utrecht, and later 
during 1994 - 1996 at CWI, Center for Mathematics and Computer Science, in 
Amsterdam. The work was finished in Nijmegen (where it started): currently, I 
am employed at the Computing Science Institute of the University of Nijmegen 
as a Research Fellow of the Royal Netherlands Academy of Arts and Sciences. 
This book could not have been written without the teaching, support, en-
couragement, advice, criticism and help of many. It is a hopeless endeavour 
to list them all. Special thanks go to my friends and (former) colleagues at 
Nijmegen, Cambridge (UK), Utrecht and Amsterdam, but also to many col-
leagues in the field. The close cooperation with Thomas Streicher and Clau-
dio Hermida during the years is much appreciated, and their influence can 
be felt throughout this work. The following persons read portions of the 
manuscript and provided critical feedback, or contributed in some other way: 
Lars Birkedal, Zinovy Diskin, Herman Geuvers, Claudio Hermida, Peter Lietz, 
Jose Meseguer, Jaap van Oosten, Wesley Phoa, Andy Pitts, Thomas Streicher, 

vi 
Preface 
Hendrik Tews and Krzysztof Worytkiewicz. Of course, the responsibility for 
mistakes remains entirely mine. 
The diagrams in this book have been produced with Kristoffer Rose's X<^-pic 
macros, and the proof trees with Paul Taylor's macros. The style files have 
been provided by the publisher. 
Bart Jacobs, 
Nijmegen, August 1998. 

Contents 
Preface 
v 
Contents 
vii 
Preliminaries 
xi 
0. 
Prospectus 
1 
0.1. 
Logic, type theory, and fibred category theory 
1 
0.2. 
The logic and type theory of sets 
11 
1. 
Introduction to fibred category theory 
19 
1.1. 
Fibrations 
20 
1.2. 
Some concrete examples: sets, ct/-sets and PERs 
31 
1.3. 
Some general examples 
40 
1.4. 
Cloven and split 
fibrations 
47 
1.5. 
Change-of-base and composition for 
fibrations 
56 
1.6. 
Fibrations of signatures 
64 
1.7. 
Categories of 
fibrations 
72 
1.8. 
Fibrewise structure and fibred adjunctions 
80 
1.9. 
Fibred products and coproducts 
93 
1.10. 
Indexed categories 
107 
2. 
Simple type theory 
119 
2.1. 
The basic calculus of types and terms 
120 
2.2. 
Functorial semantics 
126 

viii 
Contents 
2.3. 
Exponents, products and coproducts 
133 
2.4. 
Semantics of simple type theories 
146 
2.5. 
Semantics of the untyped lambda calculus as a corollary 
154 
2.6. 
Simple parameters 
157 
3. 
Equational Logic 
169 
3.1. 
Logics 
170 
3.2. 
Specifications and theories in equational logic 
177 
3.3. 
Algebraic specifications 
183 
3.4. 
Fibred equality 
190 
3.5. 
Fibrations for equational logic 
201 
3.6. 
Fibred functorial semantics 
209 
4. 
First order predicate logic 
219 
4.1. 
Signatures, connectives and quantifiers 
221 
4.2. 
Fibrations for first order predicate logic 
232 
4.3. 
Functorial interpretation and internal language 
246 
4.4. 
Subobject fibrations I: regular categories 
256 
4.5. 
Subobject fibrations II: coherent categories and logoses 
265 
4.6. 
Subset types 
272 
4.7. 
Quotient types 
282 
4.8. 
Quotient types, categorically 
290 
4.9. 
A logical characterisation of subobject fibrations 
304 
5. 
Higher order predicate logic 
311 
5.1. 
Higher order signatures 
312 
5.2. 
Generic objects 
321 
5.3. 
Fibrations for higher order logic 
330 
5.4. 
Elementary toposes 
338 
5.5. 
Colimits, powerobjects and well-poweredness in a topos 
346 
5.6. 
Nuclei in a topos 
353 
5.7. 
Separated objects and sheaves in a topos 
360 
5.8. 
A logical description of separated objects and sheaves 
368 
6. 
The effective topos 
373 
6.1. 
Constructing a topos from a higher order fibration 
374 
6.2. 
The effective topos and its subcategories of sets, u;-sets, and PERs . . . . 
385 
6.3. 
Families of PERs and u;-sets over the effective topos 
393 
6.4. 
Natural numbers in the effective topos and some associated principles . . 398 
7. 
Internal category theory 
, . 
407 
7.1. 
Definition and examples of internal categories 
408 
7.2. 
Internal functors and natural transformations 
414 
7.3. 
Externalisation 
421 
7.4. 
Internal diagrams and completeness 
430 

Contents 
ix 
8. 
Polymorphic type theory 
441 
8.1. 
Syntax 
444 
8.2. 
Use of polymorphic type theory 
454 
8.3. 
Naive set theoretic semantics 
463 
8.4. 
Fibrations for polymorphic type theory 
471 
8.5. 
Small polymorphic fibrations 
485 
8.6. 
Logic over polymorphic type theory 
495 
9. 
Advanced fibred category theory 
509 
9.1. 
Opfibrations and fibred spans 
510 
9.2. 
Logical predicates and relations 
518 
9.3. 
Quantification 
535 
9.4. 
Category theory over a 
fibration 
547 
9.5. 
Locally small fibrations 
558 
9.6. 
Definability 
568 
10. First order dependent type theory 
581 
10.1. 
A calculus of dependent types 
584 
10.2. 
Use of dependent types 
594 
10.3. 
A term model 
601 
10.4. 
Display maps and comprehension categories 
609 
10.5. 
Closed comprehension categories 
623 
10.6. 
Domain theoretic models of type dependency 
637 
11. Higher order dependent type theory 
645 
11.1. 
Dependent predicate logic 
648 
11.2. 
Dependent predicate logic, categorically 
653 
11.3. 
Polymorphic dependent type theory 
662 
11.4. 
Strong and very strong sum and equality 
674 
11.5. 
Full higher order dependent type theory 
684 
11.6. 
Full higher order dependent type theory, categorically 
692 
11.7. 
Completeness of the category of PERs in the effective topos 
707 
References 
717 
Notation Index 
735 
Subject Index 
743 

This Page Intentionally Left Blank

Preliminaries 
A brief account will be given of the organisation of this book, of what is 
presupposed, and of some of the notions and notations that will be used. 
Organisation 
of the book 
The contents form a mixture of logic, type theory and category theory. There 
are three Chapters 1, 7 and 9 dealing explicitly with (fibred) category the-
ory. The other chapters have mixed contents. Chapter 1 starts off with an 
introduction to the basic concepts of fibred category theory. This material 
will subsequently be used in the Chapters 2, 3, 4, 5, and 8, respectively on 
simple type theory, equational logic, first and higher order predicate logic 
(over simple type theory) and on polymorphic type theory. Only basic fibred 
category theory is needed here, since there is no type dependency. The first 
few sections (of these chapters) give introductions to the relevant systems of 
logic and type theory. It should be possible to skip the first chapter and start 
reading the beginning of these subsequent Chapters 2, 3, 4, 5, and 8. A return 
to Chapter 1 may then take place on a call-by-need basis. In such a way, the 
reader may oscillate between logical and type theoretical expositions on the 
one hand, and categorical expositions on the other. Towards the end of Chap-
ter 8 on polymorphic type theory some extra material on the effective topos 
(from Chapter 6) and on internal categories (from Chapter 7) is used. 
In the last two Chapters 10 and 11 on first and higher order dependent 
type theory the distinction between logical and type theoretical elements on 
the one side and categorical elements on the other, becomes less pronounced. 

Preliminaries 
Familiarity with fibred category theory (from Chapters 1, 7 and 9) is assumed 
at this stage. 
The essential dependencies between the various chapters are sketched in the 
following diagram. 
1. Introduction to 
fibred category theory 
9. Advanced fibred 
category theory 
10. First order 
dependent type theory 
11. Higher order 
dependent type theory 
Prerequisites 
The reader is assumed to be familiar with the basic notions of category the-
ory, such as adjunctions, (co)limits and Cartesian closed categories (CCCs). 
Familiarity with predicate logic is assumed, and also some nodding acquain-
tance with type theory is presupposed. But this is not essential, for example 
for readers who are mainly interested in categorical aspects. Also, in examples 
of models we shall use some basic notions and results from domain theory and 
recursion theory. 

Preliminaries 
xiii 
We shall be more specific, especially about notational conventions. 
Category 
theory 
Arbitrary categories will be written as A, B, C , . . . in open face. Specific cat-
egories like Sets, P o S e t s and EfF will be written in bold face. (But also 
arbitrary internal categories A, B, C , . . . will be in bold face.) We use capital 
letters for objects, and write X E C to express that X is an object of the cat-
egory C Small, non-capitalised letters are used for morphisms in a category 
(also called maps, or arrows). The homset (or class) C{X,Y) 
is the collection 
of morphisms from X to Y in a category C. The notations / : X —> Y and 
X -^ Y are also used for / G C{X,Y). 
We use special arrows X >^ Y for 
monic maps (also called monos) and X ^^ Y for epic maps (or epis). We 
recall that a category C is called locally small if all its collections C{X,Y) 
of 
homomorphisms are small sets (as opposed to proper classes). And C is called 
small if additionally its collection of objects is a small set. The opposite of a 
category C will be written as C°P . In the context of a fibration we generally 
use letters like I,J,K 
and u^v^w for objects and morphisms of the "base" 
category and letters like X,Y,Z 
and f,g,h 
for objects and morphisms of the 
"total" category. 
The identity morphism on an object X is idx* X -> X, or simply id: X -^ 
X. Composition of morphisms f:X-^Y 
and g:Y -^ Z is usually written as 
g o f: X -^ Z. Sometimes we write gf: X ^ 
Z for this composite, especially 
when / and g are functors. Occasionally we use a double arrow notation 
f,g:X 
=t Y to express that / and g are two parallel morphisms. A natural 
transformation a between functors F, G: A =^ IB is usually written with double 
arrow => as a: F => G, for example, in a diagram: 
A 
This => notation will, more generally, be used for 2-cells in a 2-category. And it 
will sometimes also occur as alternative X =>Y = Y^ 
for an exponent object 
Y^ 
in a Cartesian closed category (CCC). We generally use 1 for a termi-
nal object (also called final object or empty product) in a category. Binary 
Cartesian products are written as X x Y with projections 7r:X x Y -> X, 
7r':X X Y ^ Y and tuples {f,g):Z 
-^ X x Y for / : Z ^ X and ^: Z -> Y. 
As a special case of tupleing, we often write S or S[X) 
for the diagonal 
(id,id):X ^ 
X x X on X, and S or S{I,X) 
for the "parametrised" diag-
onal (id,7r'):/ x X ^ 
(7 x X) x X, which duplicates X, with parameter 7. 

xiv 
Preliminaries 
Associated with the abovementioned exponent object Y^ in a CCC there are 
evaluation and abstraction maps, which will be written as ev: Y^ X X 
-^Y 
and A(/): Z -^ Y^, fov f: Z x X -^ Y, 
An initial object (or empty coproduct) is usually written as 0. For binary 
coproducts we write X-{-Y with coprojections K: X 
-^X-{-Y,K':Y-^X-\-Y 
and cotuples [f,g]: X + Y -^ Z, where f:X -^ Z and g:Y -^ Z. The codiag-
onal V = [id, id]: X + X —> X is an example of a cotuple. 
For functors F:A-^M 
and G: IB -> A in an adjunction {F H G) the homset 
isomorphism M{FX,Y) 
= A{X, GY) is often written as a bijective correspon-
dence between morphisms /: FX —^ Y and g: X —> GY via double lines: 
FX -
X — 
f ^Y 
-^GY 
e.g. for exponents: 
ZxX 
^Y 
^Y"" 
=X =>Y 
9 
In such a situation, transposition is sometimes written as (/: FX —> y) i-^ 
iPiX^ 
GY) and {g:X -^ GY) ^ {g'^'.FX ^ Y), or more ambiguously, as 
f ^-^ f and g ^'g. We reserve the symbols r] for the unit natural transforma-
tion id => GF, and e for the counit natural transformation FG =^ id of an 
adjunction (F H G). We recall that these natural transformations have com-
ponents rix — (id^x)^ and SY — (iday)^- In case both 77 and e are (natural) 
isomorphisms, the categories A and B are called equivalent. This is written as 
A c:^ B. 
For the rest, we generally follow usual categorical notation, e.g. as in 
the standard reference [187]. Another (more recent) reference text is [36]. 
And [186, 19, 61] may be used as introductions. 
Logic 
Logic as presented in this book differs from traditional accounts in three as-
pects. (1) We standardly use many-typed (predicate) logic, in which variables 
occurring in predicates need not be restricted to a single type (or, in more 
traditionally terminology, to a single sort). (2) We do not restrict ourselves to 
logic over simple type theory, but also allow logics over polymorphic and de-
pendent type theories. (3) Contexts of variable declarations will be explicitly 
written at all times. 
Hence a logical entailment 
n-f5 = 7 l - n = 2 
is seen as incomplete, and will be written with explicit variable declaration as 
7z:N|n-|-5=:7f-n=:2. 

Preliminaries 
xv 
The sign '|' is used to separate the type theoretic context n: N from the logical 
context rz 4- 5 = 7. These contexts will also be present in derivation rules. 
The reason for carrying contexts explicitly along comes from their important 
categorical role as indices. 
We use as propositional connectives ± for falsum 
(or absurdity), V for 
disjunction, T for truth, A for conjunction and D for implication. Negation 
-I will be defined as -xp = (p D L. Existential 3 and universal V quantifi-
cation will be written in typed form as 3x:a.ip 
and \/x:a.(p. 
And we simi-
larly use the notation =^a for typed equality (on type a). All these proposi-
tion formers will be used with their standard rules. (But for 3,V and =(j we 
also use the equivalent—but less standard—adjoint rules, see Lemmas 4.1.7 
and 4.1.8.) Higher order logic will be described via a distinguished (con-
stant) type Prop: Type, which enables quantification over propositions, like 
in Va: Prop. (f. 
By default, logic will be constructive logic. Non-constructive, classical logic 
(with the additional double negation rule: -^-^(p entails (p) will not be very im-
portant, since the logic of most of the models that we consider is constructive. 
See [67, 23, 335] for more information on constructive logic. 
Type 
theory 
Mostly, standard type theoretical notation will be used. For example, exponent 
types are written as cr -^ r and (dependent) product types as Hx.a.r. 
The 
associated introduction and elimination operations are lambda-abstraction 
Xx:a.M 
and application M - N, OT simply MN. 
(Sometimes we also use 
"meta-lambda-abstraction" ^x.f{x) 
for the actual function x i—)• f{x), 
not 
in some formal calculus.) We standardly describe besides "limit types" also 
"colimit types" like coproduct (disjoint union) a + r, dependent sum Ex: a. r, 
equality Eq(j(x, x') and quotient a/R. 
There is no established notation for the 
introduction and elimination operations associated with these type formers. 
The notation that we shall use is given in Figure 0.1. The precise rules will 
be given later. For these "colimit" type formers there are typical "commuta-
tion conversions" (involving substitution of elimination terms) and "Frobenius 
properties" (describing commutation with products). We write (e,g. in the 
above table) M[N/x] 
for the result of substituting N for all free occurrences 
of X in M. This applies to terms, types or kinds M, N. In a type theoretic 
context, an equation M = N between terms usually describes convertibility. 
We shall use = to denote syntactic equality (following [13]). 
Familiarity with the propositions-as-types correspondence (between deriv-
ability in logic and inhabitation in type theory) will be convenient, but not 
necessary. For basic information on type theory we refer to [14, 98]. Also the 
standard textbook [13] on the untyped lambda calculus is relevant, since many 

Preliminaries 
<7 + T 
Ea7:<j. T 
Eqa(x,x') 
a/R 
introduction 
KM:(T 
+ T, K'NIO- 
+ r 
(for 
M:a,N:T) 
{M,N):Y.x:a.T 
(iov 
M:(J,NXT[MIX]) 
ra(M):Eq^(M,M) 
(fovMia) 
[M]R:a/R 
(for M: a) 
elimination 
unpack P as [KX in Q.n'y 
in P] 
(for P'. <7 + T,Q(x),R(y): 
p where x: a, y: r) 
unpack P as (x,y) \n Q:p 
(for P: Dor: <7. r, Q(a7, y): p where x: a, y: r) 
Q with a:' = a; via P:p 
(for P:EqCT(a7,2:'), Q(a7):p[a:/a:'] where x, x': a) 
pick X from P in Q: p 
(for P:a/R,Q(x): 
p where xia) 
Fig. 0.1. Introduction and eHmination terms for "coHmit" types 
of the typed notions stem from the untyped setting. 
Order theory 
We briefly mention some of the ordered sets that will be used. A set X = 
{X, <) carrying an "order" relation <C XxX 
which is reflexive and transitive 
is called a preorder. And it is a partially ordered set (or poset, for short) if 
the order is additionally anti-symmetric. A function f: X -^ Y between the 
underlying sets of two preorders or posets X, Y is called monotone if it satisfies 
X < a?' => f{x) < f{x') for all x^x' G X. Posets with monotone functions 
form a category PoSets. A poset is a lattice if it contains a bottom element 
JL G X, a top element T G X, a meet x A y E X and a join x V y E X 
for all elements x,y G X. Such a lattice is a Hey ting algebra (HA) if it 
additionally admits an operation D: X x X —> X with z < x D y if and 
only if z A X < y. Hence a Heyting algebra is a poset bicartesian closed 
category. A Boolean algebra (BA) is a Heyting algebra in which ->-^x < x 
holds, where ->x = x D ±. Heyting algebras and Boolean algebras form models 
of constructive and classical propositional logic (respectively). 
A poset X is called a complete lattice if every subset a C X has a join 
y a G X. Every subset a C X then also has a meet given hy /\a 
= 
\/{x 
I X is a lower bound of a}. A complete Heyting algebra (CHA)—also 
called a frame, or a locale—is a Heyting algebra, which is complete as a poset. 
A poset X is a directed complete partial order (dcpo) if every directed subset 

Preliminaries 
xvii 
a C X has a join \/ a £ X, where a subset a C X is directed if a is non-empty 
and satisfies: for all x,y 
G a there is a 2: E a with x < z and y < z. For 
emphasis we sometimes write \/ 
instead of \/ for a join of a directed subset. 
A function f.X^Y 
between dcpos is (Scott-) continuous if it is monotone 
and preserves suprema of directed subsets. Dcpos with continuous functions 
form a category Dcpo, which is Cartesian closed. Also complete lattices with 
continuous functions from a CCC. For more information, see e.g. [69, 3, 170]. 
Recursion 
theory 
The categories of PERs and of cj-sets (and also the effective topos) will occur 
in many examples. They involve some basic recursion theory. We assume some 
coding (v^n)n6N of the partial recursive functions, and use it to describe what 
is called Kleene application on natural numbers: 
_ / V^n(^) 
if V^n(^) i (2-e. ii (pn{^ 
is defined) 
~ 1^ t 
otherwise {i.e. undefined, otherwise). 
For a partial recursive function / : N " x N —)• N we let £ H^ Ay.f{x,y) 
be 
the partial recursive function s"(e,—):N" -> N that is obtained from the 
"s-m-n-theorem" by writing 
f{x,y) 
= <fe{x,y) 
=fs-ie,x){y)-
Then (Ay. f{x, y)) • z c:^ / ( x , z), where ^ is Kleene equality; it expresses that 
the left hand side is defined if and only if the right hand side is defined, 
and in that case both sides are equal. We further use a recursive bijection 
(—,—):N X N ^=)- N with recursive projection functions p , p ' : N =4 N. See 
e.g. [66, 294, 236] for more information. 

This Page Intentionally Left Blank

Chapter 0 
Prospectus 
This introductory chapter is divided into two parts. It first discusses some 
generalities concerning logic, type theory and category theory, and describes 
some themes that will be developed in this book. It then continues with a 
description of the (standard) logic and type theory of ordinary sets, from the 
perspective of fibred category theory—typical of this book. This description 
focuses on the fundamental adjunctions that govern the various logical and 
type theoretic operations. 
0.1 Logic^ typ^ theory^ and fibred category 
theory 
A logic is always a logic over a type theory. This statement sums up our ap-
proach to logic and type theory, and forms an appropriate starting point. It 
describes a type theory as a "theory of sorts", providing a domain of reason-
ing for a logic. Roughly, types are used to classify values, so that one can 
distinguish between zero as a natural number 0:N and zero as a real number 
0:IR, and between addition -|-:N x N -^ N on natural numbers and addition 
+:]R X M —> M on real numbers. In these examples we use atomic types N 
and M and composite types N x N -> N and M x E —)- M obtained with the 
type constructors x for Cartesian product, and -^ for exponent (or function 
space). The relation ':' as in 0:N, is the inhabitation relation of type theory. 
It expresses that 0 is of type N, i.e. that 0 inhabits N. It is like membership E 
in set theory, except that G is untyped, since everything is a set. But a string 
is something which does not inhabit the type of natural numbers. Hence we 

2 
Chapter 0: Prospectus 
shall have to deal with rules regulating inhabitation, like 
and 
0:N 
succ(n):N 
The first rule is unconditional: it has no premises and simply expresses that 
the term 0 inhabits the type N. The second rule tells that if we know that n 
inhabits N, then we may conclude that succ(n) also inhabits N, where succ(—) 
may be read as successor operation. In this way one can generate terms, like 
succ(succ(0)):N inhabiting the type N. 
In predicate logic one reasons about such terms in a type theory, like in 
Vx:N.3t/:N. 2/> succ(x). 
This gives an example of a proposition. The fact that this expression is a 
proposition may also be seen as an inhabitation statement, so we can write 
(Va:: N. 3y: N.y> 
succ(x)): Prop 
using a type Prop of propositions. In this particular proposition there are 
no free variables, but in predicate logic an arbitrary proposition (p: Prop may 
contain free variables. These variables range over types, like in: 
X > 5: Prop, where x:N 
or 
x> b: Prop, where x:M. 
We usually write these free variables in a "context", which is a sequence of 
variable declarations. In the examples the sequence is a singleton, so we write 
x: N h a: > 5 : Prop 
and 
a:: M h x > 5 : Prop. 
The turnstile symbol h separates the context from the conclusion: we read the 
sequent a?: N h a: > 5: Prop as: in the context where the variable x is of type N, 
the expression x > 5 is a proposition. Well-typedness is of importance, since 
if a: is a string, then the expression x > b does not make sense (unless one has 
a different operation > on strings, and one reads '5' as a string). 
This explains what we mean with: a logic is always a logic over a type 
theory. Underlying a logic there is always a calculus of typed terms that one 
reasons about. But one may ask: what about single-sorted logic (i.e. single-
typed, or untyped, logic) in which variables are thought of as ranging over 
a single domain, so that types do not really play a role? Then one still has 
a type theory, albeit a very primitive one with only one type (namely the 
type of the domain), and no type constructors. In such situations one often 
omits the (sole) type, since it has no role. But formally, it is there. And what 
about propositional logic? It is included as a border case: it can be seen as 
a degenerate predicate logic in which all predicates are closed {i.e. do not 
contain term variables), so one can see propositional logic as a logic over the 
empty type theory. 

Section 
0.1: Logic, type theory, 
and fibred category theory 
3 
We distinguish three basic kinds of type theory: 
• simple type theory (STT); 
• dependent type theory (DTT); 
• polymorphic type theory (PTT). 
In simple 
type theory there are types built up from atomic types (like N, 
M above) using type constructors like exponent —>, Cartesian product x or 
coproduct (disjoint union) -h. Term variables x\ a are used to build up terms, 
using atomic terms and introduction and elimination operations associated 
with the type constructors (like tuples and projections for products x). Types 
in simple type theory may be seen as sets, and (closed) terms inhabiting 
types as elements of these sets. In dependent 
type theory, one allows a term 
variable x\a to occur in another type T[X): Type. This increases the expressive 
power, for example because one can use in DTT the type Matrlx(n,m) of 
n X m matrices (say over some fixed field), for n:N and m:N terms of type 
N. If one thinks of types as sets, this type dependency is like having for each 
element i G / of a set /, another set X{i). 
One usually writes Xj — X{i) 
and 
sees [Xi)i^i 
as an /-indexed family of sets. Thus, in dependent type theory 
one allows type-indexed-types, in analogy with set-indexed-sets. Finally, in 
polymorphic 
type theory, one may use additional type variables a to build up 
types. So type variables a may occur inside a type <T(a), like in the type list(a) 
of lists of type a. This means that one has types, indexed by (or parametrised 
by) the universe Type of all types. In a set theoretic picture this involves a set 
XA — X[A) 
for each set A. One gets indexed collections (X^)^^sets of sets 
XA-
These three type theories are thus distinguished by different forms of in-
dexing of types: no indexing in simple type theory, indexing by term variables 
x'.am 
dependent type theory, and indexing by type variables a\ Type in poly-
morphic type theory. One can also combine dependent and polymorphic type 
theory, into more complicated type theories, for example, into what we call 
polymorphic dependent type theory (PDTT) or full higher order dependent 
type theory (FhoDTT). 
What we have sketched in the beginning of this section is predicate logic over 
simple type theory. We shall call this simple predicate logic (SPL). An obvious 
extension is to consider predicate logic over dependent type theory, so that 
one can reason about terms in a dependent type theory. Another extension is 
logic over polymorphic type theory. This leads to dependent predicate logic 
(DPL) and to polymorphic predicate logic (PPL). If one sees a typed calculus 
as a (rudimentary) programming language, then these logics may be used as 
program logics to reason about programs written in simple, dependent, or 
polymorphic type theory. This describes logic as a "module" that one can 

4 
Chapter 0: Prospectus 
plug onto a type theory. 
This book focuses on such structural aspects of logic and type theory. The 
language and techniques of category theory will be essential. For example, we 
talked about a logic over a type theory. Categorically this will correspond to 
one ("total") category, capturing the logic, being fibred over another ("base") 
category, capturing the type theory. Indeed, we shall make special use of 
tools from fibred category theory. This is a special part of category theory, 
stemming from the work of Grothendieck in algebraic geometry, in which 
(continuous) indexing of categories is studied. As we already mentioned, the 
various forms of type theoretic indexing distinguish varieties of type theory. 
And also, putting a logic on top of some type theory (in order to reason about 
it) will be described by putting a fibration on top of the categorical structure 
corresponding to the type theory. In this way we can put together complicated 
structures in a modular way. 
Fibred category theory is ordinary category theory with respect to a base 
category. Also, one can say, it is ordinary category theory over a base cate-
gory. Such a base category is like a universe. For example, several concepts in 
category theory are defined in terms of sets. One says that a category C has 
arbitrary products if for each set I and each /-indexed collection {Xi)i^j 
of 
objects Xi E C there is a product object Yliei ^^ ^ ^ together with projec-
tion morphisms TTJ: {Yiiei ^i) ~^ ^j^ which are suitably universal. In category 
theory one is not very happy with this privileged position of sets and so the 
question arises: is there a way to make sense of such products with respect to 
an object / of a 'universe' or 'base category' B, more general than the cate-
gory Sets of sets and functions? This kind of generality is needed to interpret 
logical products 'ix:a.(p 
or type theoretic products Ux: a. r when the domain 
of quantification a is not interpreted as a set (but as some ordered set, or 
algebra, for example). 
Another example is local smallness. A category C is locally small if for each 
pair of objects X, F G C the morphisms X -^ Y in C form a set (as opposed 
to a proper class). That is, if one has homsets C{X,Y) 
E Sets as objects in 
the category of sets. Again the question arises whether there is a way of saying 
that C is locally small with respect to an arbitrary universe or base category 
IB and not just with respect to Sets. 
Fibred category theory provides answers to such questions. It tells what it 
means for a category E to be 'fibred over' a base category B. In that case we 
E 
write i , where the arrow E ^ B is a functor which has a certain property 
that makes it into a fibration. And in such a situation one can answer the 
above questions: one can define quantification with respect to objects / G B 
and say when one has appropriate hom-objects Hom(X, Y) G B for X, Y G E. 

Section 
0.1: Logic, type theory, 
and fibred category theory 
5 
The ways of doing this will be explained in this book. And for a category 
Fam(C) 
C there is always a 'family fibration' 
4- 
of set-indexed families in C 
Sets 
The fibred notions of quantification and local smallness, specialised to this 
family fibration, are the ordinary notions described above. Thus, in the family 
fibration 
we have our standard universe (or base category) of sets. 
There are many categorical notions arising naturally in logic and type the-
ory (see the list below). And many arguments in category theory can be 
formulated conveniently using logic and type theory as "internal" language 
(sometimes called the "Mitchell-Benabou" language, in the context of topos 
theory). These fields however, have diff'erent origins: category theory arose in 
the work of Eilenberg and Mac Lane in the 1940s within mathematics, and 
was in the beginning chiefly used in algebra and topology. Later it found ap-
plications in almost all areas of mathematics (and computer science as well, 
more recently). Type theory is also from this century, but came up earlier 
in foundational work by Russell in logic (to avoid paradoxes). Recently, type 
theory has become important in various (notably functional) programming 
languages, and in computer mathematics: many type theories have been used 
during the last two decades as a basis for so-called proof-assist ants. These are 
special computer programs which assist in the verification of mathematical 
statements, expressed in the language of some (typed) logic. The use of types 
in these areas imposes certain restrictions on what can be expressed, but fa-
cilitates the detection of various errors. We think it is in a sense remarkable 
that two such fundamental fields (of category theory and of type theory)— 
with their apparent diff'erences and different origins—are so closely related. 
This close relationship may be beneficial in the use and further development 
of both these fields. 
We shall be especially interested in categorical phenomena arising within 
logic and type theory. Among these we mention the following. 
(i) Every context of variable declarations (in type theory) or of premises 
(in logic) is an index. It is an index for a 'fibre' category which captures the 
logic or type theory that takes place within that context—with the declared 
variables, or under the assumptions. The importance of this categorical role 
of contexts is our motivation for paying more than usual attention to contexts 
in our formulations of type theory and logic. 
(ii) Appropriately typed sequences of terms give rise to morphisms be-
tween contexts. This is the canonical way to produce a category from types 
and terms. These context morphisms induce substitution functors between 
fibre categories. The structural operations of weakening (adding a dummy as-
sumption) and contraction (replacing two assumptions of the same kind by a 
single one) appear as special cases of these substitution functors: weakening 

6 
Chapter 0: Prospectus 
is substitution along a projection TT, and contraction is substitution along a 
diagonal S. These TT and S may be Cartesian projections and diagonals in sim-
ple and polymorphic type theories, or 'dependent' projections and diagonals 
in dependent type theory. 
(iii) The basic operations of logic and type theory can be described as 
adjoints in category theory. Such operations standardly come with an intro-
duction and an elimination operation, which are each other's inverses (via 
the so-called (/?)- and (77)-conversions). Adjoint correspondences capture such 
situations. This may be familiar for the (simple) type theoretic constructors 
1, X, 0, -h and —> (and for their propositional counterparts T, A, _L, V and 
D ) , since these are the operations of bicartesian closed categories (which can 
be described via standard adjunctions). But also existential 3x:a.{—) 
and 
universal Vx: a. (—) quantification in predicate logic over a type cr, dependent 
sum T,x: a. (—) and product Jlx: cr. (—) in dependent type theory over a type 
a, and polymorphic sum E a : Type. (—) and product Ua: Type. (—) in polymor-
phic type theory over the universe Type of types, are characterised as left and 
right adjoints, namely to the weakening functor which adds an extra dummy 
assumption x:a, 
or a: Type. Moreover, equality =a on a type a is charac-
terised as left adjoint to the contraction functor which replaces two variables 
x,y:ahysi 
single one (by substituting x for y). By 'being characterised' we 
mean that the standard logical and type-theoretical rules for these operations 
are (equivalent to) the rules that come out by describing these operations as 
appropriate adjoints. 
The most important adjunctions are: 
existential 3, sum D H weakening 
weakening H universal V, product 11 
equality H contraction 
truth H comprehension (or 'subsets types') 
(but also: equality H comprehension, via a different functor) 
quotients H equality. 
The first four of these adjoints were recognised by Lawvere (and the last two 
are identified in this book). Lawvere first described the quantifiers 3, V as left 
and right adjoints to arbitrary substitution functors. The above picture with 
separate adjoints to weakening and to contraction functors is a refinement, 
since, as we mentioned in (ii), weakening and contraction functors are special 
cases of substitution functors. (These operations of weakening and contraction 
can be suitably organised as a certain comonad; we shall define quantification 
and equality abstractly with respect to such comonads.) 

Section 
0.1: Logic, type theory, 
and fibred category theory 
7 
(iv) As we mentioned above, the characteristic aspect of dependent type 
theory is that types may depend on types, in the sense that term variables 
inhabiting types may occur in other types. And the characteristic aspect of 
polymorphic type theory is that type variables may occur in types. Later we 
shall express this as: types may depend on kinds. These dependencies amount 
to certain forms of indexing. They are described categorically by fibred (or 
indexed) categories. Thus, if one knows the dependencies in a type theory, then 
one knows its underlying categorical structure. The additional type theoretic 
structure may be described via certain adjunctions, as in the previous point. 
(v) Models of logics and type theories are (structure preserving) functors. 
From a specific system in logic or type theory one can syntactically build a 
so-called 'classifying' (fibred) category, using a term model—or generalised 
Lindenbaum-Tarski—construction. A model of this system is then a (fibred) 
functor with this classifying (fibred) category as domain, preserving appropri-
ate structure. We shall make systematic use of this functorial 
semantics. 
It 
was introduced by Lawvere for single-typed simple type theories. And it ex-
tends to other logics and type theories, and thus gives a systematic description 
of models of (often complicated) logics and type theories. 
(vi) If cr =: a{a) is a type (in polymorphic type theory) in which a free type 
variable a occurs, then, under reasonable assumptions about type formation, 
the operation r i-> cr[r/a] of substituting a type r for a, is functorial. This 
functoriality is instrumental in describing the rules of (co-)inductively defined 
data types in terms of (co-)algebras of this functor. And the reasoning princi-
ples (or logic) associated with such data types can also be captured in terms 
of (co-)algebras (but for a different functor, obtained by lifting the original 
functor to the logical world of predicates and relations). 
(vii) A logical framework is a type theory T which is expressive enough so 
that one can formulate other systems S of logic or of type theory inside T. 
Categorically one may then describe (the term model of) S as an internal 
category in (the term model of) T. We briefly discuss dependent type theory 
as a logical framework in Section 10.2, but we refer to [87] for this connection 
with internal categories. 
This is not a book properly on logic or on type theory. Many logical and 
type theoretical calculi are described and some illustrations of their use are 
given, but there is nothing about specific proof-theoretic properties like cut-
elimination, Church-Rosser or strong normalisation. Therefore, see [14]. The 
emphasis here lies on categorical semantics. This is understood as follows. 
Category theory provides means to say what a model of, say predicate logic, 
should look like. It gives a specification, or a hollow structure, which captures 

8 
Chapter 0: Prospectus 
the essentials. A proper model is something else, namely an instance of such a 
structure. We shall describe both these hollow structures, and some instances 
of these. (But we do not investigate the local structure or theories of the 
example models, like for example in [197] or in [13, Chapter 19].) 
So what, then, is the advantage of knowing what the categorical structures 
are, corresponding to certain logics and type theories? Firstly, it enables us to 
easily and quickly recognise that certain mathematical structures are models 
of some logical or type theoretical calculus, without having to write out an 
interpretation in detail. The latter can be given for the 'hollow categorical 
structure', and need not be repeated for the particular instances. One only has 
to check that the particular structure is an instance of the general categorical 
structure. For example, knowing that a particular category (of domains, say) 
is Cartesian closed yields the information that we can interpret simple type 
theory. Secondly, once this is realised, we can turn things around, and start 
using our calculus (suitably incorporating the constants in a signature) to 
reason directly and conveniently about a (concrete or abstract categorical) 
model. This is the logician's view of the mathematician's use of language: 
when reasoning about a particular mathematical structure (say a group G), 
one formally adds the elements a G G as constants a to the language, and 
one uses the resulting "internal" language to reason directly about G. The 
same approach applies to more complex mathematical structures, like a fibred 
category of domains: one then needs a suitable type theoretic language to 
reason about such a complex (indexed) structure. The third advantage is 
that a clear (categorical) semantics provides a certain syntactic hygiene, and 
deepens the understanding of the various logical and type theoretical systems. 
For example, the principle that a (possibly new) operation in logic or type 
theory should correspond to an adjoint gives certain canonical introduction, 
elimination and conversion rules for the constructor. Fourthly, models can 
be used to obtain new results about one's logical or type theoretical system. 
Consistency, conservativity and independence results are often obtained in 
this manner. Finally, and maybe most importantly, models provide meaning to 
one's logical or type theoretical language, resulting in a better understanding 
of the syntax. 
There are so many systems of logic and type theory because there are certain 
"production rules" which generate new systems from given ones. 
(i) There are three basic type theories: simple type theory (STT), depen-
dent type theory (DTT) and polymorphic type theory (PTT). 
(ii) Given a certain type theory, one can construct a logic over this type 
theory with predicates <f{x): Prop containing free variables x inhabiting types. 
This allows us to reason about (terms in) the given type theory. 

Section 
0.1: Logic, type theory, 
and fibred category theory 
9 
(iii) Given a logic (over some type theory), one can construct a new type 
theory (extending the given one) by a propositions-as-types upgrade: one con-
siders the propositions ^^ in the logic as types in the new type theory, and 
derivations in the logic as terms in the new type theory. 
This modularity is reflected categorically in the following three points. 
(i) There are three basic categorical structures: for STT (Cartesian closed 
categories), for D T T (what we call closed comprehension categories) and for 
P T T (certain fibred Cartesian closed categories). 
(ii) Putting a logic on a type theory corresponds to putting a preorder 
fibration 
on top of the structure describing the type theory. For logic one 
uses preorder structures, since in logic one is interested in provability and not 
in explicit proofs (or proof-terms, as in type theory), which are described as 
non-trivial morphisms. 
(iii) Under a propositions-as-types upgrade one replaces a preorder fibra-
tion by an ordinary fibration (with proper fibre categories), thus making room 
for proof-terms as proper morphisms. 
(Both second points are not as unproblematic as they may seem, because one 
may have complicated type theories, say with two syntactic universes of types 
and of kinds, in which there are many ways of putting a logic on top of such 
a type theory: one may wish to reason about types, or about kinds, or about 
both in the same logic. Categorically, there are similarly difi'erent ways in 
which a preorder fibration can be imposed.) 
By the very nature of its contents, this book is rather descriptive. It contains 
few theorems with deep mathematical content. The influence of computer 
science may be felt here, in which much emphasis is put on the description of 
various languages and formalisms. 
Also, it is important to stress that this is not a book properly on fibred 
category theory. And it is not intended as such. It does contain the basic 
concepts and results from fibred category theory, but only as far as they are 
directly useful in logic or type theory (and not in topology, for example). 
Some of these basic results have not been published previously, but have been 
folklore for some time already. They have been discovered and rediscovered by 
various people, and the precise flow of ideas is hard to track in detail. What 
we present in this book is not a detailed historical account, and we therefore 
apologise in advance for any misrepresentation of history. 
We sketch what we see as the main lines. In the development of fibred 
category and categorical logic one can distinguish an initial French period 
starting in the 1960s with Grothendieck's definition of a fibration [i.e. a fibred 
category), published in [107]. It was introduced in order to study descent. The 

10 
Chapter 0: Prospectus 
ensuing theory was further developed by Grothendieck and (among others) 
Giraud [100] and Benabou. The latter's work is more logical and foundational 
in spirit than Grothendieck's (involving for example suitable fibred notions 
of local smallness and definability), and is thus closest to the current work. 
Many of the basic notions and results stem from this period. 
In the late 1960s Lawvere first applied indexed categories in the study of 
logic. Especially, he described quantification and equality in terms of adjoints 
to substitution functors, and showed that also comprehension involves an 
adjunction. This may be seen as the start of categorical logic (explicitly, in his 
influential "Perugia Lecture Notes" and also in [192, 193]). At about the same 
time, the notion of elementary topos was formulated, by Lawvere and Tierney. 
This resulted in renewed attention for indexed (and internal) categories, to 
study phenomena over (and inside) toposes. See for example [173, 169] and 
the references there. 
Then, in the 1980s there is the start of a type theoretic boom, in which 
indexed and fibred categories are used in the semantics of polymorphic and 
dependent type theories, see the basic papers [306, 307, 148] and the series 
of PhD theses [45, 330, 75, 185, 318, 252, 260, 7, 154, 89, 217, 86, 60, 289, 
125, 4, 198, 133]. This book collects much material from this third phase. 
Explicitly, the connection between simple type theory and Cartesian closed 
categories was first established by Lawvere and Lambek. Later, dependent 
type theory was related to locally Cartesian closed categories by Seely, and to 
the more general "display map categories" by Taylor. The relation between 
polymorphic type theory and certain fibred (or indexed, or internal) Cartesian 
closed categories is due to Seely, Lamarche and Moggi. Finally, more compli-
cated systems combining polymorphic and dependent systems (like the calcu-
lus of constructions) were described categorically by Hyland, Pitts, Streicher, 
Ehrhard, Curien, Pavlovic, Jacobs and Dybjer. This led to the (surprising) 
discovery of complete internal categories by Moggi and Hyland (and to the 
subsequent development of 'synthetic' domain theory in abstract universes). 
Interestingly, fibred categories are becoming more and more important in 
various other areas of (theoretical) computer science, precisely because the as-
pects of indexing and substitution (also called renaming, or relabelling) are so 
fundamental. Among these areas we mention (without pretension to be in any 
sense complete): database theory [295, 151, 9], rewriting [12], automata the-
ory [175, 10], abstract environments [279], dataflow networks [310], constraint 
programming [219], concurrency theory [345, 131], program analysis [230, 25], 
abstract domain theory [146] and specification [152, 327, 48, 159]. 
Many topics in the field of categorical logic and type theory are not discussed 
in this book. Sometimes because the available material is too recent (and un-
settled), sometimes because the topic deviates too much from the main line. 

Section 0.2: The logic and type theory of sets 
11 
but mostly simply because of lack of space. Among these topics we mention 
(with a few references): inductively and co-inductively defined types in depen-
dent type theory [70, 71], categorical combinators [63, 290, 116], categorical 
normalisation proofs [147, 238, 5], fixed points [16], rewriting and 2-categorical 
structure [308, 278], modal logic [93], //-calculi [313], synthetic domain the-
ory [144, 331, 264], a fibred Giraud theorem [229], a fibred adjoint functor 
theorem [47, 246], descent theory [168] (especially with its links to Beth de-
finability 
[208]), fibrations in bi-categories [315, 317], 2-fibrations [127], and 
the theory of stacks [100]. 
The choice has been made to present details of interpretation functions for 
simple type theory in full detail in Chapter 2, together with the equivalent 
functorial interpretation. In later chapters interpretations will occur mostly in 
the more convenient functorial form. For detailed information about interpre-
tation functions in polymorphic and (higher order) dependent type theories we 
refer to [319, 61]. As we proceed we will be increasingly blurring the distinction 
between certain type theories and certain fibred categories, thus decreasing 
the need for explicit interpretations 
0,2 The logic and type theory of sets 
We shall now try to make the fibred perspective more concrete by describing 
the (familiar) logic and type theory of ordinary sets in fibred form. Therefore 
we shall use the fibrations of predicates over sets and of families of sets over 
sets, without assuming knowledge of what precisely constitutes a fibration. In 
a well-known situation we thus describe some of the structures that will be 
investigated in more abstract form in the course of this book. We shall write 
Sets for the category of (small) sets and ordinary functions between them. 
Predicates on sets can be organised in a category, that will be called Pred, 
as follows. 
objects 
pairs {I,X) 
where X C / is a subset of a set /; in this 
situation we consider X as a predicate on a type /, and 
write X{i) for i E X to emphasise that an element i £ I 
may be understood as a free variable in X. When / is clear 
from the context, we sometimes write X for the object 
{X C / ) . 
morphisms 
(/, A") -^ (J, Y) are functions u: I -^ J between the under-
lying sets satisfying 
X[i) implies Y[u{i)), 
for each i E /. 
Diagrammatically, this condition on such 
a 
function 

12 
Chapter 
0: 
Prospectus 
u'.I-^J 
amounts to the existence of a necessarily unique 
(dashed) map 
X 
^Y 
Y 
/ 
^ J 
indicating that u restricts appropriately. 
There is an obvious forgetful functor Pred —> Sets sending a predicate to 
its underlying set (or type): [I,X) 
i-> /. This functor is a "fibration". And 
although it plays a crucial role in this situation, we do not give it a name, but 
Pred 
simply write it vertically as 
^ 
to emphasise that it describes predicates as 
Sets 
living over sets. 
For a specific set /, the "fibre" category Pred/ is defined as the subcategory 
of Pred of predicates {X C /) on / and of morphisms that are mapped to 
the identity function on /. This category Pred/ may be identified with the 
poset category (P(/), C) of subsets of/, ordered by inclusion. For a function 
u'.I -^ J there is "substitution" functor u*:P{J) 
-> P{I) in the reverse 
direction, by 
(YCj)^{{i\uii)eY}Cl). 
Clearly we have Y C Y' => u*{Y) C u*(Y'), so that u* is indeed a functor. 
Two special cases of substitution are weakening and contraction. Weakening 
is substitution along a Cartesian projection TT: / x J —> /. It consists of a 
functor 
P(I) - ^ ^ P{I X J) 
sending 
X ^ {{ij) 
\ieX 
and j G J] 
by adding a dummy variable j E J to a, predicate X. Contraction is substitu-
tion along a Cartesian diagonal (J: / —> / x /. It is a functor 
P{I X /) -
^ 
P{I) 
given by 
Y ^ {i e I \ (i, i) E Y}, 
It replaces two variables of type / by a single variable. 
Each fibre category P{I) is a Boolean algebra, with the usual set theoretic 
operations of intersection fl, top element (/ C /), union U, bottom element 
(0 C /), and complement /\(—)• These operations correspond to the propo-
sitional connectives A,T,V,±,-> in (Boolean) logic. They are preserved by 
substitution functors u* between fibre categories. 
The categorical description of the quantifiers 3,V is less standard (than 
the propositional structure of subsets). These quantifiers are given by oper-
ations between the fibres—and not inside the fibres, like the propositional 

Section 0.2: The logic and type theory of sets 
13 
connectives—since they bind free variables in predicates (and thus change the 
underlying types). They turn out to be adjoints to weakening, as expressed 
by the fundamental formula: 
3 H TT* H V. 
In more detail, we define for a predicate Y C / x J, 
3(7) = 
{iei\3jeJ.[i.j)eY] 
v(y) ^ 
{ i G / | V i G J . ( 2 , i ) G y } . 
These assignments Y \-^ 3(y) and Y i-^ V(y) are functorial P{I x J) =t 
P ( / ) . And they are left and right adjoints to the above weakening functor 
TT*: P{I) -^ P(I X J) because there are the following basic adjoint correspon-
dences. 
y C 7 r * ( X ) 
o v e r / x J 
7r*(X) C y 
over / x J 
=======^^^^ 
and 
===^=:==^==^^^ 
3{Y) C X 
over / 
X C V(y) 
over / 
(Where the double line means: if and only if.) 
For a set (or type) /, equality i = i' for elements i, i' G / forms a predicate 
on / X /. Such equality can also be captured categorically, namely as left 
adjoint to the contraction functor S*:P{I 
x I) ^ 
f^i^)- 
One defines for a 
predicate X C I the predicate Eq(X) on / x / by 
Eq(X) = {(i, i')e 
I X I \i = i' and i G X}. 
Then there are adjoint correspondences 
Eq(X) C y 
over I x I 
X C j * ( y ) 
o v e r / 
Notice that the predicate Eq(X) is equality on / for the special case where X 
is the top element /. See also Exercise 0.2.2 below for a description of a right 
adjoint to contraction, in terms of inequality. 
The operations of predicate logic can thus be identified as certain structure 
Pred 
in this fibration 
I 
, namely as structure in and between its fibres. Moreover, 
Sets ' 
-^ 
.
.
. 
it is a property of the fibration that this logical structure exists, since it can 
be characterised in a universal way—via adjoints—and is thus given uniquely 
up-to-isomorphism. The same holds for the other logical and type theoretical 
operations that we identify below. 
Comprehension is the assignment of a set to a predicate, or, as we shall 
say more generally later on, of a type to a predicate. This assignment takes 
a predicate to the set of elements for which the predicate holds. It also has 
a universal property. Therefore we first need the "truth" functor l : S e t s —> 

14 
Chapter 0: Prospectus 
Pred, which assigns to a set / the truth predicate 1(7) = {I C. I) on 7; it is 
the terminal object in the fibre over 7. Comprehension (or subset types, as 
we shall also say) is then given by a functor { —}: Pred -> Sets, namely 
{{Y C J)} = {jeJ\ 
Yij)} = Y. 
Hence { —}:Pred -> Sets is simply {Y C J) \-^ Y. It is right adjoint to 
the truth functor l:Sets —> Pred since there is a bijective correspondence 
between functions u and ^' in a situation: 
1(7) —^ 
(y C J) 
in Pred 
-^ {{Y C J)} 
in Sets 
In essence this correspondence tells us that Y{j) holds if and only if j E {{Y C 
Quotient sets can also be described using the fibration of predicates over 
sets. We first form the category Rel of (binary) relations on sets by pullback: 
Rel 
^ Pred 
J 
Sets 
^ Sets 
7 K ^ 7 X 7 
Via this pullback we restrict ourselves to predicates with underlying sets of 
the form 7 x 7 . Explicitly, the category Rel has 
objects 
pairs (7, 7^) where 7? C 7 x 7 is a (binary) relation on 
7 e Sets. 
morphisms 
(7, R) -^ {J, S) are functions u: I -^ J between the under-
lying sets with the property 
R{i, i') implies S{u[i)^u[i'))^ 
for all i, i' G 7. 
The functor Rel -^ Sets in the diagram is then (7, R) \-^ 7. It will turn out to 
be a fibration by construction. The abovementioned equality predicate yields 
an equality functor Eq: Sets -^ Rel, namely 
J ^ E q ( J ) = { ( i , i ) | i e J } . 
Quotients in set theory can then be described in terms of a left adjoint Q to 
this equality functor Eq: a relation R C I x I is mapped to the quotient set 
7/7?, where R C I x I is the least equivalence relation containing R. Indeed 

Section 
0.2: The logic and type theory of sets 
15 
there is an adjoint correspondence between functions v and u in: 
Q(/, R) = I/^ 
—^ 
J 
in Sets 
R 
^ Eq( J) 
in Rel 
This correspondence can be reformulated as: for each functon u: I -^ J with 
u{i) — u{i') for all i, i' £ I for which R{i,i') holds, there is a unique function 
v: I/R —-> J in a commuting triangle 
quotient 
Finally we mention that predicates over sets give us higher order logic. 
There is a distinguished set 2 = {0,1} of propositions, with special predicate 
({1} C 2) for truth: for every predicate [X C /) on a set /, there is a unique 
function char(X C I): I ^ 2 with 
(X C /) = char(X C /)*({!} C 2). 
This existence of "characteristic morphisms" is what makes the category of 
sets a topos. It allows us to quantify via this set 2 over propositions. 
This completes our first glance at the fibred structure of the logic of sets. In 
the remainder of this section we sketch some of the type theoretic structure of 
sets, again in terms of a fibration, namely in terms of the "family" fibration 
Fam(Sets) 
I 
of set-indexed-sets. It captures the dependent type theory (with 
type-indexed-types) of sets. 
The category Fam(Sets) of families of sets has 
objects 
pairs (/, X) consisting of an index set / and a family X = 
{Xi)i^j of/-indexed sets Xj. 
morphisms 
(/,^) -^ {J,y) are pairs (w,/) consisting of functions 
- ^ J and / = [Xi 
^ y^,(o). ei 
There is a projection functor Fam(Sets) -> Sets sending an indexed family 
to its underlying set index set: (/, X) i-> /. It will turn out to be a fibration. 
Essentially this will mean that there are (appropriate) substitution or rein-
dexing functors: for a function u: I -^ J between index sets, we can map a 

16 
Chapter 0: Prospectus 
family Y = {Yj)j^j over J to a family over / via: 
{Yj)jeJ '—y {Yu{i))iei' 
We shall write u* for this operation. It extends to a functor between "fibre" 
categories: for an arbitrary set K, let Fam(Sets)i<- be the "fibre" subcategory 
of Fam(Sets) of those families {K,X) 
with A' as index set, and with mor-
phisms (idx, /) with the identity on K as underlying function. Then 
w.I^J 
yields a substitution functor t/*: Fam(Sets)j —>• Fam(Sets)/. 
Notice that there is an inclusion functor Pred <^ Fam(Sets) of predicates 
into families, since every predicate [X C /) yields an /-indexed family {Xi)i^i 
with 
''• - \ 0 
oth. 
otherwise. 
It is not hard to see that this yields a full and faithful functor Pred <^ 
Fam(Sets), which commutes with substitution. It is a 'morphism of fibra-
tions'. 
Our aim is to describe the dependent coproduct JJ and product Y\ of fami-
lies of sets as adjoints to weakening functors, in analogy with the situation for 
existential 3 and universal V quantification in the logic of sets. But in this sit-
uation of families of sets we have weakening functors TT* induced not by Carte-
sian projections TT: I x J —^ I, but by "dependent" projections w: {I \ X} —>• /, 
with domain {/ | X} given by the disjoint union: 
{I\X} 
= {{i,x) I 2 G / and X G Xi} 
which generalises the Cartesian product. The weakening functor TT* associated 
with this dependent projection TT: {I \ X} -> / sends a family Y = {Yi)i^i 
over / to a family 7r*{Y) over {/ | X} by vacuously adding an extra index x, 
as in: 
(As we shall see later, the projection TT: {I \ X} -^ I arises in a canonical way, 
since the assignment (/, X) i-^ {/ | X} yields a functor Fam(Sets) -> Sets, 
which is right adjoint to the terminal object functor l:Sets -^ Fam(Sets), 
sending a set J to the J-indexed collection ({*})JGJ of singletons. The counit 
of this adjunction has the projection TT as underlying map. Thus, the operation 
(/,X) H-> {/ I X} is like comprehension for predicates, as described above.) 
The claim is that the dependent coproduct ]J and product f| for set-indexed 
sets are left and right adjoints to the weakening functor TT* . Therefore we have 

Section 0.2: The logic and type theory of sets 
17 
to define coproduct ]J and product W as functors 
u 
Fam(Sets){/ | x) 
-^—TT* 
Fam(Sets)/ 
n 
{I\X) 
acting on an {/ | X}-indexed family Z = (^(i,a;))»g/,reA', and producing an 
/-indexed family. These functors are given by 
]\{Z)i 
= {{x,z) 
\xeXi 
and z € Z(.-,^)} 
Y[{Z)i 
= {<p: Xi ^ Ux€X. Z(i,,) I Vx e Xi.ip(z) 
€ Z(,-,^)}. 
We then get the fundamental relation 
u H TT- H n 
since there are bijective adjoint correspondences between families of functions 
/ and g in: 
/ 
/ 
Z 
^7r*(y) 
o v e r { / | X } 
7r*{Y) 
^Z 
over {/| X } 
^^^==^=^=^=^=^^== 
and 
=
=
=
=
=
=
=
=
=
= 
IJ(^) 
^ Y 
over / 
Y 
^ I K ^ ) 
over / 
Also in this situation, there are adjoints to contraction functors S* (induced 
by dependent 
diagonals), given by equality and inequality. But we do not 
further pursue this matter, and conclude our introduction at this point. What 
we have sketched is that families of sets behave like dependent types, and that 
subsets behave like predicates, yielding a logic over (dependent) type theory. 
We have shown that the basic operations of this logic and of this type theory 
can be described by adjunctions, in a fibred setting. In the course of this book 
we shall (among many other things) be more precise about what it means 
to have such a logic over a type theory and we shall axiomatise all of the 
structure found above, and identify it in many other situations. 
Finally, the next few exercises may help the reader to become more familiar 
with the structure described above. 

18 
Chapter 0: Prospectus 
Exercises 
0.2.1. 
Define a left adjoint F:Fam(Sets) -> Pred to the inclusion functor 
F 
Pred ^ 
7 Fam(Sets) 
Sets 
such that: (1) F makes the triangle commute (so it does not change the 
index set), and (2) F commutes with substitution. 
0.2.2. 
Define for a subset X C / the relation nEq(X) C / x / by 
nEq(X) = {(i, i') I i ^ I or i G X} 
and show that the assignment X H^ nEq(X) is right adjoint to contraction 
J*: P ( / X /) -> P(/). Notice that nEq(X) at the bottom element X = 0 is 
inequality on /. 
0.2.3. 
Show that the equality functor Eq: Sets —> Rel also has a right adjoint. 
0.2.4. 
Check that the operation (/,X) >-> {/ | X} yields a functor Fam(Sets) -^ 
Sets, and show that it is right adjoint to the terminal object functor Sets -^ 
Fam(Sets), mapping a set J to the family of singletons ({*})JGJ. Describe 
the unit and counit of the adjunction explicitly. 

Chapter 1 
Introduction to fibred category theory 
This first proper chapter starts with the basics of fibred category theory; it 
provides the foundation for much of the rest of this book. A fibration, or fibred 
category, is designed to capture collections ( C / ) / ^ ! of categories C/ varying 
over a base category B, generalising for example collections of sets 
{Xi)i^j 
varying over a base, or index, set /. The main categorical examples are the 
indexed collections of categories 
(W/),,„ 
(sub(/)),^^ 
(i///),^„ 
consisting of slice categories B / / over /, posets Sub(/) of subobjects of/, and 
what we call 'simple slice categories' M//I over /. The ordinary slice categories 
will be used for dependent type theory, the posets of subobjects for predicate 
logic, and the simple slice categories for simple type theory (whence the name). 
The slice categories B / / will be used as leading example in the first section 
when we introduce fibrations. The other examples Sub(/) and M//I will be 
introduced soon afterwards, in Section 1.3. 
In all of these cases, a morphism u: I ^ J in the base category B induces a 
substitution functor, commonly written as w*, acting in the reverse direction. 
That is, there are substitution functors: 
- ^ 
B / / 
Sub( J) -
^ 
Sub(/) 
M//J -
^ 
M//I 
Weakening functors and contraction functors arise as special cases of sub-
stitution functors u*, namely (respectively) as TT*, where TT is a projection 
morphism in B, and as J*, where J is a diagonal morphism in B. 
19 

20 
Chapter 1: Introduction to fibred category theory 
These two aspects—indexing and substitution—will be studied systemati-
cally in this first chapter, in terms of fibrations. The notion of'fibred category', 
or 'fibration', is due to Grothendieck [107]. 
This chapter develops the basic theory of fibrations and shows how various 
notions from ordinary category theory—such as adjunctions, products and 
coproducts—make sense for fibred categories as well. In the last section 1.10 
we describe the notion of 'indexed category', a common alternative formu-
lation of variable category, and explain why an indexed category should be 
regarded as simply a particular kind of fibrations (namely as a 'cloven' one). 
Chapter 7 describes internal categories, which also correspond to certain fi-
brations, namely to so-called 'small' fibrations. 
The ten sections which together form this chapter contain the essentially 
standard, first part of the theory of fibrations, geared towards use in categor-
ical logic and type theory. The main notions are: Cartesian morphism, sub-
stitution functor, change-of-base, fibred adjunction, fibred (co)product and 
indexed category. These will be introduced together with many examples. 
Sometimes the theory is further developed in exercises, but mostly, the ex-
ercises of a section serve to familiarise the reader with the new material in 
that section. There is a later chapter (Chapter 9) which continues the study 
of fibrations. 
1.1 
Fibrations 
Basically, a fibration is a categorical structure which captures indexing and 
substitution. Since the formal definition of a fibration is a bit technical—see 
Definition 1.1.3 below—we start with the following introductory observations. 
These focus on the special case of a codomain fibration, and will lead to 
the general definition of fibration towards the end of this section. The exer-
cises contain many elementary results about fibrations, which should help the 
reader to get acquainted with the concepts involved. 
Indexing 
Suppose we wish to consider a family of sets, ranging over some index set /. 
There are two ways of doing so. 
(a) Pointwise (or split) indexing: as a collection (Xf),^/, where each Xi 
is a set. Probably this way is most elementary and comes first to one's mind. 
One can think of this collection as being given by a function (or functor) 
/ -^ Sets, namely i H^ XJ. 

Section 1.1: Fibrations 
21 
Xi 
Xi 
(a) 
(b) 
Fig. 1.1. Pointwise indexing (a) and display indexing (b) of set-indexed-sets 
(b) Display indexing: as a function (p: X —^ I. The sets in the family 
then appear as fibres "over i" 
(f-\i) 
= {x£X 
\ (p{x) = i} 
for each i £ L 
A picture suggesting the difference between these ways of indexing is pre-
sented in Figure 1.1. 
These descriptions are equivalent: given a collection {Xi)i£i as in (a), take 
X to be the disjoint union U^-^/-^i = {(h^) 
| « G / and x £ X,}; it comes 
equipped with a projection function TT: JJ^-^j Xj -> / sending {i,x) »-> i. Up-
to-isomorphism, the fibre 7r~^(i) over i is the original Xi. Conversely, given a 
function <^: X ^ / as in (b), put Xi = (p~^{i). This yields a collection (X,),-^/ 
as in (a), together with an isomorphism U^^/ Xi = X. 
(For the set theoretic purist we remark that the passage from (a) to (b) 
relies on the Axiom of Replacement. Also we should mention that the fibres 
<f~^{i) in (b) are necessarily disjoint, whereas the sets Xi in (a) need not be 
disjoint. But that is not essential at this stage.) 
Although pointwise indexing (a) seems more natural at first, display in-
dexing (b) has the great advantage that it generalises to arbitrary categories, 
since it only involves the notion of a morphism, see Definition 1.1.5 below. 

22 
Chapter 1: Introduction to fibred category theory 
Hence in the sequel we often describe a family of sets as a function (p: X ^ I 
as in (b). We then loosely speak about the fibres Xi — p~^{i) and say that 
X is a family over / and that y? displays the family {Xi). In order to em-
phasise that we think of such a map ^P as a family, we often write it vertically 
as I 
y^ I. A constant family is one of the form I 
i ^ 
15 where TT is the 
Cartesian product projection; often it is written simply as P{X). Notice that 
all fibres of this constant family are (isomorphic to) X. 
/ X \ 
Such families I 
y*^ j of sets give rise to two categories: the slice cate-
gory Sets// and the arrow category Sets"*". The objects of Sets// are the 
/-indexed families, for a fixed set /; the objects of Sets"^ are all the /-indexed 
families, for all possible /. Here are the definitions. 
Sets// 
objects 
families 
morphisms 
are functions f.X 
-^ Y 
making the following diagram commute. 
/ 
^Y 
Notice that / can thus be seen as a collection of functions ff. Xi —> Yi—where 
Xi = <p~^{i) and Yi = ijj~^{i) are the fibres involved (for i G /). Composition 
and identities in Sets// are inherited from Sets. 
Sets 
objects 
families I 
j 
] ^ for arbitrary sets /. 
morphisms 
(«,/) 
are pairs of functions 
u: I-^ J and f:X—^Y 
for which the following 

Section 1.1: Fibrations 
23 
diagram commutes. 
X 
^ 
- ^ y 
^ 
-^ J 
Hence, objects in the arrow category Sets"^ involve an extra function u be-
tween the index sets. Notice that one can now view / as a collection of func-
tions fi'.Xi -^ Yu{i), since for x G (p~^{i), f{x) lands in ip~^{u{i)). Composi-
tion and identities in Sets"^ are component-wise inherited from Sets. 
We further remark that there is a codomain functor cod: Sets^ -> Sets; 
it maps 
[ 
j ^ J K^/ 
and 
{uj)^u. 
Also, for each /, there is a (non-full) inclusion functor Sets// M- Sets^. 
Substitution 
Suppose a family 
over a set J is given. Substitution involves changing 
the index set J. More specifically substitution along a function u: I -^ J 
involves creating a family of sets with the domain / of t/ as new index set and 
with fibres Y^^i) for i E /. Thus the family {Yj)j^j 
is turned into a family 
{Xi)i^i with Xi — yu(f). This family {Xi)i^j can be obtained in the following 
way. Form the puUback of ij) against u\ 
«*(v) 
That is, form the set X 
^ 
(*) 
/ 
7. 
^ J 
{(i,y) E / X y I u{i) — tp{y)} with obvious 
over / 
/ X ' 
projection functions I ^ X -^Y. 
One obtains a new family I 
'Y 
with fibres 
Xi = ^-\i) ^{yeY\ 
rPiy) = uii)} = ^-'("(O) = y„(.)-

24 
Chapter 1: Introduction to fibred category theory 
One normally writes w*(^) for the result 9? of substituting ij) along u. 
1.1.1. Examples. The following four special cases of substitution along a 
map u are worth mentioning separately. 
(i) Suppose u is an element j E J, that is, u is of the form j:l 
—> J 
where 1 = {*} is a one-element (terminal) set. Then u*{'tp) = j*(ip) becomes 
the family I j 
I. It can be identified with the fibre Xj. Thus, substituting 
along a specific element j yields the fibre Xj over this element j . 
(ii) Substitution of an ordinary (non-indexed) set X, described as a family 
fX\ 
[ \ I over a singleton set 1, along the unique map / —> 1 yields the constant 
family I* (X) = I 
| 
I. This is because the pullback of two maps 7 ^ 1 
and X —^ 1 with the terminal object 1 as common codomain, is the Cartesian 
product / X X of their domains. 
(iii) In case w is a projection TT: J x / —)• J, then 7r*{ij;) is V^ x id, since the 
following diagram is a pullback square. 
One obtains as fibre over (j, i) E J x I 
ir*(^r'(j,i) 
= (V X id)-\j,i) 
= {(y,j,i) 
I V(y) = j} = r\3) 
X / 
which shows that there is an extra "dummy" index variable i in the family 
7r*(<^) which plays no role. Later in Section 3.1 (explicitly in Example 3.1.1) we 
shall see that in logical terms, substitution along a projection is weakening 
[i.e. adding an extra assumption). 
(iv) The dual (in some sense) of (iii) is substitution along a diagonal S: J -^ 
J X J. For a family ( r^^ ) the fibre oiS*{iP) over 7 G J is 
which is the family ^(jj/) restricted to j = f. This is contraction: replacing 
two variables j , f by a single one via substituting 
[j/f]. 
Notice that the pair (w,/) in the pullback diagram (*) above is a mor-
phism u*(ip) ^ ^ in the arrow category Sets"^. For a moment let us call this 

Section 1.1: Fihrations 
25 
pair {u,f) the "substitution morphism" (later it will be called a Cartesian 
morphism). This substitution morphism has a universal property: suppose we 
have another morphism, 
in Sets"^ such that v: K —> J factors through u: I -^ J, say via w. K —)• / 
with t? = w o It;, as in 
Then there is a unique morphism 
Z \ [w,h) ( X 
K 
w 
in Sets"^ which is sent to w by the codomain functor cod: Sets 
and for which the composite 
|)(-i'i(f)i!l::a(T 
z \ 
{v,g) 
(Y 
This holds because X was constructed as a pullback: 
9 
Sets, 
The presence of such 'best possible substitution morphisms' u*{'ip) —^ ip 
is the cardinal property of the codomain functor cod:Sets~^ —)- Sets that 

26 
Chapter 1: Introduction to fibred category theory 
makes it a fibration. Definition 1.1.3 below captures this property abstractly 
in purely categorical terms. And in Section 1.4 we shall see how this property 
induces—by choosing substitution morphisms—substitution functors u*. 
We introduce some notation and terminology. Let p: E -> IB be a functor. It 
/ 
E 
\ 
can be seen as a (display) family ( i^ ) of categories: for an object / G B, 
the fibre or fibre category E/ = p~^{I) over / is the category with 
objects 
X eE with pX = L 
morphisms 
X ^ Y in E/ are morphisms /: X —> Y in E for which pf 
is the identity map on / in B. 
An object X G E such that pX — I {i.e. an X G E/) is said to be above 
/; similarly, a morphism / in E with pf = u is said to be above u. This 
E 
terminology is in accordance with our 'vertical' notation 
^P . A morphism 
in E will be called vertical if it is above some identity morphism in B, that 
is, when it is in a fibre category. For X,Y 
£ E and u:pX —> pY in B we 
sometimes write 
E^(X, y ) = {f:X 
-^Y 
i n E | / i s a b o v e w } C E ( x , Y ) . 
>nsidering such a family oj 
gory and E the total category. 
E 
When considering such a family of categories -^P , we call B the base cate-
Sets~^ 
1.1.2. Examples, (i) Consider the codomain functor 
i 
. An object 
above 7 G Sets is a family I 
y^ I over /; a vertical morphism has the form 
Thus the fibre category above / G Sets can be identified with the slice cate-
gory Sets// of families over / and commuting triangles. Notice that the fibre 
Sets/1 (or slice) over a singleton (terminal) set 1 can be identified with the 
base category Sets itself. 
(ii) For a functor p-.E -> B, the fibre category Ej over / G B can be 

Section 1.1: Fibrations 
27 
constructed via a pullback: one has a pullback of categories 
just like 
is a pullback of sets, as described in Example 1.1.1 (i). 
Finally, we come to the definition of 'fibration'. 
1.1.3. Definition. Let p:E —> IB be a functor. 
(i) A morphism /: X —> Y in E is Cartesian over u: I —^ J in M if pf = u 
and every g: Z -^ Y inE for which one has pg = u o w for some w.pZ —> /, 
uniquely determines an h: Z ^ X inlE above w with f o h = g.lm. 
diagram: 
Z 
E 
^Y 
We call /: X -^ y in the total category E Cartesian if it is Cartesian over its 
underlying map pf in B. 
(ii) The functor p: E —> B is a fibration if for every y G E and u: I —^ pY 
in B, there is a Cartesian morphism /: X —>• y in E above u. Sometimes a 
fibration will be called a fibred category or a category (fibred) over B. 
We often say that a Cartesian morphism f:X 
—> Y above u: I -^ pY is a 
terminal or Cartesian lifting of u in a, situation: 
X 
f 
^Y 
(Later, in Section 9.1, we shall describe 'opfibrations' as functors p:E -
which one has 'initial' or 'opcartesian' liftings of maps pX —^ J in B.) 
m 

28 
Chapter 
1: Introduction 
to fibred category 
theory 
The previous two diagrams embody a convention that will be used through-
out: if a diagram is drawn in two parts, one above the other, then "above" in 
the diagram means "above" in the categorical sense described before Exam-
E 
pie 1.1.2. Further, a fibration is written vertically as | and is pronounced as 
'E over B'. Often the name of the functor is omitted if it is clear what 'over' 
means. 
1.1.4. Proposition. Cartesian liftings are unique up-to-isomorphism (in a 
slice): if f and f with cod/ = cod/' are both Cartesian over the same map, 
then there is a unique vertical isomorphism (p.X^X' 
with f'o(p = f, 
D 
(The proof is left as Exercise 1.1.1 (i) below.) 
The reader is now invited to check that with respect to the codomain functor 
cod: Sets^ -^ Sets the Cartesian morphisms in Sets"*" are precisely the 
pullback squares in Sets and that the functor cod is a fibration. 
The following is a mild generalisation of what has been considered above 
for the category of sets. 
1.1.5. Definition. For an arbitrary category B, the arrow category B"^ 
( 
^ 
has families I 
^^ ) as objects; thus maps ^: X -^ / in B are objects of I 
A morphism I 
t 
I "^ I 
t ^ J in B"*" consists of a pair of morphisms 
u: I -^ J, /: X —> y in B such that tp o f = u o cp. 
For an object 7 E B the slice category B / / is the subcategory of B~^ of 
families over / (i.e. with codomain /) and morphisms {u, f) where w = id/. 
Sometimes, a slice category is simply called a slice. 
1.1.6. Proposition. Consider the codomain functor cod: W^ —^M. 
(i) The fibre category over I EM is the slice category B//. 
(ii) Cartesian morphisms in B"^ coincide with pullback squares in B. 
(iii) The functor cod is a fibration if and only if B has pullbacks. In that 
case it called the codomain fibration on B. 
• 
(The proof is also left as an exercise.) 
The notation B"*" for the category of arrows of B comes from the fact that 
B~^ can be seen as the category of functors from • ^ • to B, and natural 
transformations between them. Similarly we write B"^^ for the category of 
functors from • -> • ^ • to B. Notice that B~^"^ is not the same as (B"^ ) . 
Alternatively, one can see B~*" as the comma category (B J, B), see [187]. In 
writing 
i 
we always refer to the codomain fibration on B (and not to the 
domain fibration described in Exercise 1.1.8 below). 

Section 1.1: Fibrations 
29 
We started this section by describing set-indexed families of sets, either as 
X 
(a) pointwise (X,),-^/ 
or as 
(b) display 
| . 
We emphasise that it is important to have both pictures in mind "at the same 
time". There is a great similarity with indexed families of categories; they can 
be presented either as 
(a) (E/)/eB 
or as 
(b) 
J . 
In (b) one gets a picture as given by fibrations, and in (a) as given by so-called 
'indexed categories'. It turns out that there is also a way of switching between 
(a) and (b) for categories, given by the 'Grothendieck construction', which 
is an extension of what we have for sets. The details are in the last section 
of this chapter, together with a short discussion on fibrations versus indexed 
categories. 
For the time being however, we concentrate on (b) for categories, in order 
to become more familiar with fibred categories. But it is good to keep (a) in 
mind. For example, when confronted with a fibration, always ask what the 
fibres are. 
Exercises 1-4 collect some useful facts about Cartesian morphisms and fi-
brations. We will often make use of them. 
Exercises 
1.1.1. 
(i) 
Prove Proposition 1.1.4. 
(ii) Suppose / is Cartesian and g and h are above the same map. Show 
that f o g = f o h implies g = h. 
1.1.2. 
Let p: E -> B be a functor; assume /: X ^ y is in E and put u = pf. Show 
that / is Cartesian if and only if for each Z G E and v:pZ —> pX in B, the 
function 
E. (Z, X) 
^ Eaov[Z, 
Y) 
is an isomorphism. 
1.1.3. 
Consider the total category of a fibration. Show that 
(i) 
every morphism factors as a vertical map followed (diagrammatically) 
by a Cartesian one; 
(ii) a Cartesian map above an isomorphism is an isomorphism. Especially 
a vertical Cartesian map is an isomorphism. 
E 
1.1.4. 
Let 
zP be a fibration. Prove that 
1 
(i) 
all isomorphisms in E are Cartesian; 

30 
Chapter 1: Introduction to fibred category theory 
(ii) if -^ -> is a composable pair of Cartesian morphisms in E, then also 
their composite -^-^ is Cartesian. 
Hence it makes sense to talk about the subcategory Cart(E) M- E having 
all objects from E but only the Cartesian arrows. We write |p| for the 
composite Cart(E) M- E -> B. 
(iii) Let —)• A be a composable pair in E again. Show now that if g and 
g o f are Cartesian, then / is Cartesian as well. 
(iv) Verify that a consequence of (iii) is that the functor |p|: Cart(E) -^ B 
is a fibration. From (ii) in the previous exercise it follows that all fibres 
of IPI are groupoids [i.e. that all maps in the fibres are isomorphisms). 
[This IPI will be called the fibration of objects of p.] 
1.1.5. 
Verify that the following two results—known as the Fullback Lemmas—are 
a consequence of (ii) and (iii) in the previous exercise. Consider 
(i) 
If (A) and (B) are pullback squares, then the outer rectangle is also a 
puUback square. 
(ii) If the outer rectangle and (A) are pullback squares, then (B) is a pull-
back squcire as well. 
1.1.6. 
Consider a functor p: E ^ B. We describe a slightly weaker notion of Carte-
sianness, than the one above. Call a morphism f:X 
-^ y in E weak Carte-
sian if for each g\ Z ^ Y with pf = pg there is a unique vertical h: Z ^ X 
with f o h = g. Show that the functor p is a fibration if and only if both 
(a) every morphism u: I —¥ pY in B has a weak Cartesian lifting f:X 
—)• Y; 
(b) the composition of two weak Cartesian morphisms is again weak Carte-
sian. 
1.1.7. 
Check that the following are (trivial) examples of fibrations 
I X C 
1
1
^ 
|fst 
>|,id 
i 
i 
1 
1 
1={*} 
^ 
where X, / are sets {i.e. discrete categories). 
1.1.8. 
For an arbitrary category B, consider the domain functor dom: B"^ —>• B. 
(i) 
Describe the fibre category above / G B. It is usually called the opslice 
category or simply opslice and written as / \ B . 
(ii) Show that dom is a fibration (without any assumptions about B). 
(iii) Show also that for each / € B the domain functor domj:B// -^ B is a 
fibration. 
1.1.9. 
Assume B is a category with pullbacks. Show that the functor B"^"* —> B"^ 
sending ->-^ to -4 is a fibration..Is the composite B"*""^ —> B"*" —>• B 
also a fibration? 

Section 1.2: Some concrete examples: sets, ixi-sets and PERs 
31 
1.1.10. Show that the object functor Cat —)• Sets is a fibration. Also that the 
forgetful functor Sp -> Sets is a fibration—where Sp is the category of 
topological spaces and continuous functions. 
1.1.11. Let Fid be the category of fields and field homomorphisms; Vect is the 
category of vector spaces: objects are triples (A', V, •) where K is a field of 
scalars, V is an Abelian group of vectors and •: A" x V^ ^ V^ is an action 
of scalar multiplication (which distributes both over scalar and over vector 
addition). A morphism (A', V, •) -^ (L, W^ •) in Vect is a pair (w, / ) where 
u: A" ^ L is a field homomorphism and f-.V^Wa. 
group homomorphism 
such that /(a • x) = u{a) - f{x) for all a G K and x £ V. 
Check that the obvious forgetful functor Vect -^ Fid is a fibration. What 
are the fibres? Which maps are Cartesian? 
1.2 Some concrete examples: sets, cv-sets and PERs 
In this section we shall describe some specific fibred categories which will be 
used as leading examples. They involve firstly families indexed over sets and 
secondly the categories of u;-sets and of partial equivalence relations (PERs). 
The latter will provide important examples of models of various type theo-
ries. Later we shall describe the three categories of sets, a;-sets and PERs as 
(reflective) subcategories of the effective topos EfF. This topos thus provides 
a framework for studying them together. The subsections about u;-sets and 
PERs contain little fibred category theory; they only contain the basic def-
initions and properties of cj-sets and PERs. Fibred aspects will be studied 
later. 
Set-indexed 
families 
Assume C is an arbitrary category. We will describe a category Fam(C) of 
set-indexed families of objects and arrows of C As objects of Fam(C) we take 
collections {Xi)i^j 
where for each element i of the index set /, Xi is an object 
of C Objects of Fam(C) may thus be seen as pairs (/, X) with / a set and X 
a function X: 1 ^ Co—where Co is the collection of objects of C. 
What, then, is a map {Xi)i^j 
-^ (Yj)j^j7 
We take it to consist of a function 
u: I ^ 
J between the index sets together with a collection of morphisms 
fi'.Xi 
—> Yu(i) in C, for i E /• Composition in Fam(C) is done as follows. 
Given two morphisms 

32 
Chapter 1: Introduction to fibred category theory 
involving for i E / and j G J maps in C: 
Thus, for each i E I, "we can form a composite in C 
fi 
9u{i) 
Xi 
>- Yuii) 
^ Zy(u(i))-
So that we obtain a composite morphism [v o w, {gu{i) o fi)i^i) 
in Fam(C) 
from the family {Xi)i^j to the family {Zk)keK' 
There is a projection functor p: Fam(C) -^ Sets which maps families to 
their index sets: 
{Xi)i^i ^ I 
and 
{u,{fi)i^i)^u. 
From what we have seen in the previous section we may expect that such a 
functor from indexed collections to index sets is a fibration. And indeed p is a 
fibration: given a function u: I —^ J and an indexed collection {Yj)j^j 
above 
J we can find a Cartesian lifting in a diagram 
(??i)i€/ 
•- - ^ {yj)jeJ 
J 
The obvious choice is to take ??f = ^^(i). Then as map ---> one can take 
(t/, (idy^.^Jig/), which is above u. The verification of the required universal 
property of this lifting is left to the reader. 
Fam(C) 
1.2.1. Definition. The above 
fibration 
i 
will be called the family fi-
Sets 
"^ 
bration of C. The fibre over / G Sets is the (functor) category C^ of I-
indexed families of objects and arrows in C. 
Recall that the category C is a parameter in this construction. Especially 
we can take C = Sets (like in the Prospectus). The resulting family fibration 
Fam(Sets) 
i 
of set-indexed sets gives a precise description of pointwise indexing 
of families of sets as in (a) in the beginning of the previous section. On the 
Sets"^ 
other hand, the arrow 
fibration 
i 
captures display indexing as con-
sidered under (b). The fact that pointwise indexing of sets is essentially the 
same as display indexing finds its precise categorical formulation in the state-
ment that the categories Fam(Sets) and Sets"^ are equivalent. In fact, the 

Section 1.2: Some concrete examples: sets, uj-sets and PERs 
33 
Fam(Sets) 
S e t s ^ 
fibrations 
I 
and 
i 
are equivalent in a sense appropriate to 
fibred category theory, see Section 1.7. For the time being, we formulate this 
as follows. 
1.2.2. Proposition. There is an equivalence of categories in (the top line 
of) a commuting triangle 
Fam(Sets) 
= 
^ Sets"^ 
/ 
cod 
Sets 
where the functor Fam(Sets) -^ Sets"^ sends 
{Xi)i^j 1-^ the projection I 
j 
] 
^ 
(jj-Sets 
Our next example in this section involves the category cj-Sets of so-called 
omega sets. It combines the set-theoretic with the recursion-theoretic and 
will play an important role in the sequel. An informative source is [143], but 
see also [199] and later sections in this book. 
Recall that we write e • n for Kleene application: e • n is the outcome (pe{n) 
of applying the e-th partial recursive function (pe to n. A code or index for a 
partial recursive function / will be written as Ax. f{x). 
1.2.3. Definition. An u;-set {i.e. an object of the category cj-Sets that we 
are about to describe) is a set X together with for each element x E X di 
non-empty set of natural numbers, written as 
E{x) C N 
One calls E the existence predicate of the u;-set. We then write {X, E)—or 
sometimes (X, Ex)—for the object itself. A morphism /: (X, E) -^ (Y, E) in 
a;-Sets is a function f:X ^Y 
between the underlying sets, for which there 
is a code e G N which tracks / in the sense that 
for x E X and n G Ex{x) one has: e • n is defined and e • n G E'y (/(x)). 
Notice that only the existence of such a code and not the code itself, is part 
of the definition of a morphism. The identity function (X, E) -^ {X, E) is then 
tracked by a code Kx.x for the identity function on N. And for morphisms 
(X, E) -4 (y, E) A {Z, E) in cj-Sets, say with / tracked by e and g by d, the 

34 
Chapter 1: Introduction to fibred category theory 
composite {X, E) —> [Z^ E) is tracked by a code \x. d'[e'x) 
for the function 
X y-^ d' [e • x). This constitutes a category which will be denoted by cj-Sets. 
It comes with an obvious forgetful functor u;-Sets -> Sets which forgets the 
existence predicate. 
In the future, in writing e -n G E{f{x)) as above, we implicitly assume that 
e • 71 is defined. 
1.2.4. Proposition. The category LJ-Sets has finite limits and exponents. 
Proof. The constructions on the underlying sets are as for sets. Some extra 
care is needed to deal with the codes. For example, one has a Cartesian product 
{X, E) X (y, E) = {X X y, E) 
with 
E{x, y) = {(n, m) G N I n G E{x) and m G E{y)} 
where (—, —) is an effective coding of N x N into N. The projections in u;-Sets 
are the projections X f - X x y ^ y 
in Sets tracked by codes for the 
projection functions associated with the effective coding. The exponent is 
given by 
(X, E) =^ (y, E) = {{f eY^ 
\f is tracked by some e G M}, £") 
with 
E{f) = {e G N I e tracks / } . 
D 
a;-Sets~^ 
Since the category a;-Sets has pullbacks, the codomain functor 
i 
is a fibration, see Proposition 1.1.6. This yields display families I . ^ . I of 
ct;-sets indexed by u;-sets, as described in (b) in the beginning of the previous 
section. At the end of Section 1.4 it will be shown how to describe u;-set-
indexed cj-sets pointwise as in (a), and how to get an equivalence result like 
Proposition 1.2.2 for cj-sets. 
Next we describe the relation between sets and c<;-sets as: Sets is a reflective 
subcategory of u;-Sets. Obviously any set X can be turned into an u;-set (X, E) 
with E{x) — N for each x E X. One obtains a functor V: Sets -^ a;-Sets in 
this way, since for a function f.X 
-^Y 
any code of a total recursive function 
can be used to get /: VX -^ Vy in cj-Sets. Thus V is full and faithful. 
This functor V turns out to be right adjoint to the forgetful functor 

Section 1.2: Some concrete examples: sets, uj-sets and PERs 
35 
a;-Sets -> Sets, since there is a bijective correspondence 
/ 
(X, E) 
^ Vy 
in cj-Sets 
X 
^ Y 
in Sets 
/ 
One uses the fact that the code of / in a;-Sets is irrelevant in this case. Thus 
Sets is a reflective subcategory of a;-Sets, in a situation, 
forget 
Sets c 
^ cj-Sets 
with 
forget H V. 
V 
full and faithful 
Later in Section 6.2 we shall see that the categories of Sets and cj-Sets 
can be described as the categories of sheaves and separated objects for the 
double negation nucleus in the eff'ective topos EfF. It explains the reflection 
Sets <t^ cj-Sets. 
Partial equivalence relations 
Next we introduce the category PER of partial equivalence relations (on the 
natural numbers) and show how it forms a reflective subcategory of the above 
category cj-Sets. PERs were first introduced in [302], and have since then been 
used extensively in the semantics of various type theories, see e.g. [143, 41, 
199, 81, 31, 26, 197], or [33] for a recent reference—where categories of PERs 
are identified within exact completions—with many pointers to the literature. 
1.2.5. Definition. A partial equivalence relation (abbreviated as 'PER') 
on N is a subset i? C N x N which, as a relation, is symmetric and transitive. 
For such a PER R one writes 
\R\ = {n G N I nRn} 
for domain 
[n] — [n]R — {m E N I mRn] 
n/R 
= {[n] I n e \R\} 
for quotient 
PER = {RCNxn\Risa 
PER}. 
Notice that a PER R is an equivalence relation on its domain |i^|, so formally 
we should write |i?|/i? instead of N/7? for the quotient. But the latter notation 
is clearer. Every equivalence relation 5 on a subset of N forms a PER S C 
N X N, see Exercise 1.2.5. 

36 
Chapter 
1: Introduction 
to fibred category 
theory 
It is easy to see that PERs are closed under arbitrary intersections. Hence, 
ordered by inclusion, they form a complete lattice with joins 
\J,Si^[^{ReVER\R2[j,Si]. 
A category of PERs is formed with 
objects 
R e PER. 
morphisms 
R -^ S are functions /: N/R -^ N/S between the quotient 
sets, which are tracked (or, have a code). That is, for 
some code e E N, one has 
^ne\R\.f{[n]R) 
= [e-n]s. 
We shall write PER to denote this category. 
1.2.6. Proposition. The category PER has finite limits and exponents. 
Proof. As terminal PER one can take {(0, 0)}, or N x N. For the product of 
R and S one can use the relation 
R X S = {(n, m) | pnRpm and p'nS'p'm} 
where p, p' are the recursive projection functions associated with the effective 
pairmg ( - , - ) : N X N -=> N. The equaliser oi f,g: R^ 
S is R' ^ R where 
R' = {(n,m) e R\ f{[n]) = g{[m])}. 
And the exponent of R, S is 
R^ 
S = {(n, n') I Vm, m' E N. mRm' 
^ 
n • mSn' • m'}. 
D 
Since the category PER has finite limits, we have a codomain fibration 
PER"^ 
4- 
of PER-indexed PERs in display style (like in (b) in the beginning 
PER 
of the previous section). As for sets and for C(;-sets, there is also pointwise 
indexing as in (a) for PERs, see Proposition 1.5.3. 
An important point to note at this stage is that the category PER is a full 
subcategory of the category u;-Sets of c<;-sets introduced earlier in this section. 
The inclusion PER ^-^ cj-Sets is given by 
R^{N/R,e) 
where G is the existence predicate E {[n]) = [n] = {m E N | uRm}. Indeed a 
morphism /: (N//?, E) -> {E/S, E) in u;-Sets is a function /: n/R -^ N/S' for 
which there is a code e E N such that 
V[n] E n/R. \/me[n].e'me 
f{[m]) 

Section 1.2: Some concrete examples: sets, uj-sets and PERs 
37 
But this is equivalent to 
VmG |i^|.[e-m]=:/([m]) 
and this precisely says that / is a morphism i? -> 5 in P E R , tracked by e. 
Thus we have a full and faithful functor P E R ^^ c<;-Sets, which is the identity 
on morphisms. 
One can show that this functor P E R <^-> u;-Sets preserves finite limits 
and exponents. This is left to the reader. What we will describe is a left 
adjoint r(—):u;-Sets -^ P E R to this inclusion, which is obtained by forcing 
the existence sets E[x) C N to be disjoint, see explicitly in Exercise 1.2.9. For 
an a;-set (X, E) with elements x,x' 
G X, put 
x ^ x' ^ 
E{x)C^E{x') 
i^% 
and write ~ for the transitive closure of ^-^ in X . Define 
r(X, E) = {(m, m) \ 3x, x eX.me 
E{x) and m G E{x) 
and x - 
x}. 
There is then a bijective correspondence in 
/ 
r{X,E) 
^R 
in P E R 
(X, E) 
^ {N/R, G) 
in u;-Sets 
given as follows. 
• Assume f:r{X,E) 
-^ R in P E R , say tracked by e. Define a transpose 
r : (X, E) -^ {N/R, G) in u;-Sets by 
f^[x) 
— /([m]), 
where m G E[x) is arbitrary 
(recall E{y) / 0 for each y ^ X) 
and where [m] is the class of m in r(X, E). 
Then e also tracks / ^ in a;-Sets. 
• Conversely, given g: {X,E) 
—> {^/R,E) 
in a;-Sets, say tracked by d, then 
one easily checks that g is constant on ^-equivalence classes, i.e. that: 
X r^ x' ^ 
g{x) — g{x'). 
But then we may define a transpose ^^: r(X, E) -^ Rm 
P E R by 
g^{[m]) 
= g{x), 
where m G E{x). 
This yields a well-defined function, which is tracked in P E R by d. 

38 
Chapter 1: Introduction to fibred category theory 
It is easy to see that the passages f ^ f^ and g ^ g^ are each others inverses. 
Thus, also P E R is a reflective subcategory of cc;-Sets: 
P E R c 
^u;-Sets 
with 
r H N / ( - ) . 
N / ( - ) 
full and faithful 
The relations that we have established between sets, a;-sets and PERs are 
summarised in the following result. 
1.2.7. Proposition. There is a diagram of 
functors, 
Sets 
Lj-Sets 
P E R 
in which the ^^ 's are full and faithful functors 
(preserving finite limits 
and 
exponents), 
with the arrows in opposite direction 
as left adjoint. 
Thus both 
Sets and P E R are reflective subcategories 
of to-Sets. 
• 
Exercises 
1.2.1. 
Prove that a morphism {u,{fi)i^i) 
in Fam(C) is Cartesian if and only if 
each fi is an isomorphism in C. 
1.2.2. 
Consider a map / = {fi'.Xt 
—)• Yi)t£i in the fibre Fam(C)/ = C^ over 
/ G Sets. Prove that / is a mono in this fibre if and only if each fi is a 
mono in C. 
1.2.3. 
For an arbitrairy category B, let B ^ be the category with pointed families 
/ 
X 
\ 
as objects; these are pairs (I 
y 
I, s) where 5 is a section of ip [i.e. a map 
s:I ^ X with if o s = id). A morphism {( 
j ^ I' ^> —^ (( 
/ ^ I' 0 
in Bi^ consists of a pair of morphisms u: I —^ J, f:X 
-^ K in B with 
ip o f = u o Lp and also f o s = t o u. Thus morphisms of pointed families 
preserve the points {i.e. sections) of the families. Prove that 

Section 1,2: Some concrete examples: sets, co-sets and PERs 
39 
(i) 
if the category IB has puUbacks then the functor B ^ -^ B sending 
/ 
X 
\ 
(I 
y 
I , 5) to the index object / is a fibration; 
(ii) for B = Sets, there is an equivalence of categories Fam(Sets») -=^ 
Setsi^ like in Proposition 1.2.2, where Sets» is the category of pointed 
sets: objects are sets containing a distinguished base point, morphisms 
are functions preserving such points. 
1.2.4. 
Check that for a PER R one has R C \R\^, 
1.2.5. 
Let / be a set. A partition of / is a collection Q C P{I) of subsets of / 
satisfying (1) every set in Q is non-empty (2) if a,6 G Q and a fl 6 7^ 0, 
then a = 6 (3) y Q = /. A partial partition of / is a subset Q C P{I) 
satisfying (1) and (2) but not necessarily (3). Show that 
(i) 
there is a bijective correspondence between partitions and equivalence 
relations and between partial partitions and partial equivalence rela-
tions (on /); 
(ii) there is a bijective correspondence between partial equivalence rela-
tions on / and equivalence relations on subsets of /. 
1.2.6. 
Notice that for R G PER, the "global sections" or "global elements" homset 
PER(l,i?) is isomorphic to the quotient M/R. And also that all homsets 
in P E R and in u;-Sets are countable. 
1.2.7. 
(i) 
Prove that for each cj-set {I, E) the slice category u}-Sets/{I, 
E) is 
Cartesian closed, i.e. that a;-Sets is a locally Cartesian closed category 
(LCCC). 
(ii) Show that also P E R is an LCCC. 
1.2.8. 
Show that a map VX -> (N//^, G) in a;-Sets is constant (where X is a set 
and Ris a PER). 
1.2.9. 
(i) 
Prove that the unit r]i^x,E) of the reflection P E R ^ u;-Sets at (X, E) G 
C4;-Sets is an isomorphism if and only if the existence predicate E: X -^ 
PN has disjoint images [i.e. satisfies E[x) n E{y) / 0 => x = y). 
Conclude that P E R is equivalent to the full subcategory of u;-Sets on 
these objects with such disjoint images. These u;-sets are also called 
modest sets (after D. Scott). In this situation the existence predicate 
E\ X ^ P¥\ may equivalently be described via a surjective function 
U -^ X^ where U C N {i.e. via a subquotient of N), see e.g. [143, 
Definition 1.1]. 
(ii) In view of (i), describe the reflector r: a;-Sets -^ P E R as 'forcing 
images to be disjoint', by taking a suitable quotient 
(X -> PN) h-> ( X / - ^ PN). 
1.2.10. 
(i) 
Let Eq(N) = {(n,n) | n G N} C N x N be the 'diagonal' PER. Show 
that it is a natural numbers object (NNO) in PER. Also that the 
resulting u;-set A^ = ( N , G ) with G (n) = {n} is NNO in a;-Sets. 
(ii) Check that the maps Eq(N) -^ Eq(N) in PER, i.e. the maps N ^ N 
in a;-Sets, can be identified with the (total) recursive functions N —)• N. 

40 
Chapter 1: Introduction to fibred category theory 
1.2.11. 
Show that the category u;-Sets has finite colimits. And conclude, from the 
reflection P E R ^ a;-Sets that P E R also has finite colimits. 
1.2.12. Prove that the reflector r:u;-Sets -^ P E R preserves finite products, but 
does not preserve equalisers. 
[Hint. For a counter example, consider in Sets on the two-element set 2 = 
{0,1} the identity and twist maps id, -•: 2 =4 2, with empty set 0 ^^ 2 as 
equaliser. By applying V: Sets -^ a;-Sets we get an equaliser diagram in 
a;-Sets (since V is right adjoint). But it is not preserved by the reflector r, 
since r(V2) is terminal, and r(V0) is initial.] 
1.2.13. 
(i) 
Prove that Fam(—):Cat -> Cat is a (2-)functor. (One has to ignore 
aspects of size here, because categories Fam(C) are not small; for ex-
ample, Fam(l) is isomorphic to Sets.) 
(ii) Show that Fam(C) is the free completion of C with respect to set-
indexed coproducts. This means that Fam(C) has set-indexed coprod-
ucts and that there is a unit C —)• Fam(C) which is universal among 
functors from C to categories D with set-indexed coproducts Oig/ ^»' 
(iii) Prove that a category C has arbitrary coproducts if and only if the 
unit C -> Fam(C) has a left adjoint. 
[The Fam(—) operation forms a so-called 'KZ-doctrine', see [180].] 
1,3 Some general 
examples 
So far we have seen codomain 
fibrations 
i 
for categories B with puUbacks 
JB 
Fam(C) 
(in Proposition 1.1.6), and family 
fibrations 
4- 
(in Definition 1.2.1) for 
arbitrary categories C. In this section we shall introduce 'simple 
fibrations' 
s(B) 
Sub(]B) 
i 
, for categories B with Cartesian products, and 
fibrations 
4- 
and 
B 
B 
Rel(B) 
I 
of subobjects and relations (for categories B with pullbacks). 
B 
Simple 
fibrations 
This first construction will be of central importance in the next chapter on 
simple type theory. Let B be an arbitrary category with Cartesian products 
X. We write s(B) for the category having 
o b j e c t s 
pairs (I^X) 
of objects of B. 
m o r p h i s m s 
{1,^) 
-^ i^^^) 
^^^ pairs of morphisms {u,f) 
in B with 
w : / - > 
J a n d / : / x X - > y . 

Section 1.3: Some general examples 
41 
The composite of (/,X) 
^ ^ 
{J,Y) 
^ ^ 
{K,Z) 
is {v o u, g o {u o 
TTJ)), 
where the second component is obtained as composite 
(UOTTJ) 
g 
I xX 
^ J xY 
^ Z 
And the identity on (/, X) is the pair (id/,7r') with TT' the second projection 
I X X -^ X. There is then an obvious projection functor s{M) —> B given by 
( / , X ) i - > / 
and 
[u,f)y-^u. 
Intuitively, maps / : X ^ y in the fibre s(]B)/ over / E B are /-indexed families 
fi'.X 
-^ y , for i G /, where the objects are kept fixed. Remember the family 
fibration 
from the previous section where we had maps fi'. Xi —y Yi over /. 
The above functor will be written as si:s(B) —>• B and called the simple 
fibration on B. It is a fibration indeed, since for {J,Y) 
E s(B) and u: I -^ J 
in B one finds a Cartesian lifting of w as: 
{I^Y)--'--'-^{J,Y) 
J 
1.3.1. Definition. For a category B with Cartesian products, the simple 
s(]B) 
fibration 
on B is the above projection functor 
i . 
The fibre s(B)/ over / E B will often be written as M//I and called the 
simple slice over /. (Its objects are X E B and its maps X -^Y 
are I x X -^ 
Y in B.) 
Notice that all these simple slices M//I have the same objects, namely the 
objects from B. There is an obvious functor /*:B —)• M//I by X t-)- X and 
/ / x X \ 
/ ! - ) > / o 7^^ There is a similar functor /*: B -^ B / / given by X i-> I 
\^ 
], 
and / H^ id/ X / , as used earlier in Section 1. We write /* for both these 
functors B —)- M//I and B -> B / / . These simple and ordinary slices have much 
in common (see Exercises 1.3.2 - 1.3.4 below, and Corollary 1.10.16). For 
example, if B additionally has a terminal object 1, then for both the simple 
and the ordinary slice there are isomorphisms of categories 
B -^—^ 
B//1 
and 
B -
^ 
B/1 

42 
Chapter 
1: Introduction 
to fibred category 
theory 
It is useful to present an immediate generalisation of this 'simple' construc-
tion. It is based on the following notion from [156]. 
1.3.2. Definition, (i) A CT-structure is a pair (B, T) where B is a cate-
gory with finite products and T is a non-empty collection of objects from B. 
Such a CT-structure will be called non-trivial if there is at least one object 
X ET equipped with an arrow I -^ X from the terminal object to X. 
(ii) A morphism of CT-structures from (B, T) to (A, S) is a finite prod-
uct preserving functor A^ B -> A which satisfies K[T] C S [i.e, X ET implies 
KX E 5). 
This condition of non-triviality for CT-structures usually expresses that 
some domain is non-empty and can be seen as a non-degeneracy condition. 
The ' C and the 'T' in 'CT-structure' stand for 'context' and 'type'. As will be 
explained in the next chapter, in such a CT-structure (B, T) one can view B as 
a category of contexts and T as a collection of types; the inclusion T C Obj B 
can then be seen as identification of a type a with the corresponding singleton 
context (x:a). The two extreme cases are T is Obj B and T is a singleton. 
An example of a CT-structure is B = cj-Sets and T = objects of the form 
VX (where X is a set). 
1.3.3. Definition. Suppose (B, T) is a CT-structure. Let s(T) be the cate-
gory with 
objects 
pairs (/, X) with / G B and X 
£T. 
morphisms 
(I^X) -^ {J^^) ^re pairs {u, f) in B with u\ I ^ J and 
f:I 
xX 
^Y. 
This generalises the earlier definition of s(B) by restricting the second com-
ponent of objects to the types T. 
s(T) 
As before, one obtains a fibration W . It will be called the simple fi-
B 
bration associated with the CT-structure (B, T). 
Notice that the original construction SB:S(B) -^ B is the special case 
ST:S(T) -^ B where T consists of all objects of B. The other extreme is 
where T is a singleton, say T — {Q}. We then omit the curly braces { —} and 
write sn:s(fi) -^ B for the resulting simple fibration. CT-structures with one 
type {i.e. of the form (B, fi)) will be used for the semantics of the untyped 
lambda calculus—because 'untyped' is the same as 'typed with a single type', 
see Section 2.5. 
The generalised "CT" version of a simple fibration involves a restriction to 
a subset of the objects. A similar generalisation exists for codomain fibrations, 
involving a restriction to a subset of the arrows. This leads to the notion of 

Section 1.3: Some general examples 
43 
a display map category and—in a further generalisation—to the notion of a 
comprehension category. The details are in Chapter 10 on dependent type 
theory, especially in Section 10.4. 
Monos and 
subobjects 
In the codomain fibration 
^ 
we took all maps of IB as families. An obvious 
restriction is to consider monic maps X ^-^ I only. In the case IB = Sets, a 
fibre of such a monic (injective) map can have at most one element, so it 
is either empty or a singleton. We write Mono(IB) for the full subcategory 
of IB^ consisting of monic families. If the category IB has pullbacks, then 
Mono(l) 
the (restricted) codomain functor 
i 
is a fibration; it will be called the 
fibration of m o n o s (of B). This functor is a fibration because a pullback 
of a mono along an arbitrary map is a mono again. Notice that the fibres of 
Mono(B) 
this 
fibration 
4- 
are all preordered categories. Such a fibration will be 
called preordered, or a fibred preorder. But notice that the total category 
Mono (IB) itself, is not a preorder. 
The preorder C. of monos, say in the fibre over /, is given as follows. For 
m 
n 
X y-^ I and Y >-^ I one has m E n if and only if there is a (necessarily 
unique, monic) map f: X —^ Y with n o f — m. One can then form the 
"poset reflection" of this preorder C on the monos over /. It yields a poset 
with equivalence classes of monos as elements (where m ^ n li and only if 
both m C n and n C m, if and only if there is an isomorphism i^'.X ^ 
Y 
with n o ip — m). These equivalence classes are called subobjects (of / ) ; the 
resulting poset will be written as Sub(/). 
Usually one does not distinguish notationally between a mono and the corre-
sponding subobject. We write Sub(B) for the category obtained from Mono(B) 
Sub(]B) 
by taking subobjects as objects. One gets the fibration 
i 
of subob-
IB 
jects in B. The fibres Sub(/) are partial orders. For B = Sets the subobject 
Sub(Sets) 
Pred 
fibration 
4- 
was written as 
^ 
in the Prospectus. For a specific set 
Sets 
Sets 
^ 
^ 
/ E Sets, the fibre Sub(/) above / is the (partially ordered) category ( P / , C) 
of subsets of /. 
1.3.4. Remark. At this stage we have already seen the three fibrations that 
s(l) 
will play a crucial role in this book. They are the simple 
fibration 
i 
, the 
B 
B"^ 
Sub(B) 
codomain 
fibration 
i 
and the subobject 
fibration 
4- 
. The last fi-
B 
*^ 
B 
bration will be used to describe the so-called internal (predicate) logic of B; 

44 
Chapter 1: Introduction to fibred category theory 
this will become clear in Chapters 3 and 4. The first two will be used in the 
categorical description of type theories. The simple fibration will be used for 
simple type theory and the codomain fibration for dependent type theory. We 
therefore often jointly refer to these two fibrations as the type theoretic 
fibrations. 
Rela,tions 
A (binary) relation on an object / in a category IB with finite limits is a 
subobject R >-^ I x I. The category Rel(B) has such relations as objects; a 
morphism from Ry^IxI 
to S>-^JxJ 
in Rel(IB) is a map u: I —^ J in M 
giving rise to a commuting diagram 
R 
Y 
I X I 
^S 
-^ J X J 
U X U 
Notice that there is no need to mention the (name of the) top dashed ar-
row, because there can be only one such map. Set-theoretically the diagram 
expresses that iRi' implies u{i)Su{i'). 
The functor Rel(B) -^ M sending a re-
lation R ^^ I X I to its carrier / is then a fibration—again, since monos are 
stable under pullback. 
Often we are interested in special relations. Categorically, a relation 
{ri ^ r2): R >-^ I X I is called 
(i) reflexive if the diagonal Sj = (id, id): / ^-^ / x / factors through R v-» 
I X I, i.e. if there is a riiap 
Ix 
I 
(ii) symmetric if there is a 'swap' map 
R 
Ix I 
^ R 
Y 
.e. if 
i^',^) 
^ I xl 
R 
^ R 
(n,r2) 
I xl 
(iii) transitive if, after forming the pullback T of triples (in which both 

Section 1.3: Some general examples 
45 
the first two and the last two components are related by R) as on the left 
^23 
T 
1 J 
T 
^ R 
\ r\ 
1 
one gets 
T 
\ , \ 
t 
\ 
/ 
/ / 
/ 
{ri,r2) 
ri2 
R 
^ I 
Ix 
I 
r2 
where t = {vi o ri2, ^2 o r23):T —> / x /. It is not hard to see that in Sets 
these definitions coincide with the usual formulations. 
Then, a relation R y-^ / x / is called an equivalence relation if it is 
reflexive, symmetric and transitive. It is a partial equivalence relation 
if it is symmetric and transitive, but not necessarily reflexive. One obtains 
ERel(l) 
Per(l) 
corresponding fibrations 
4- 
and 
i 
Exercises 
s(B) 
1.3.1. 
(i) 
Show that in the total category s(IB) of a simple fibration 
i 
a mor-
B 
phism (u, f):(I,X) 
—^ (-^) ^ ) is Cartesian if cind only if there is an 
isomorphism h: I xX ^ I xY inM such that TT o h = n and TT' o h = f. 
/ / x X \ 
(ii) Show that the assignment (I,X) 
i-^ I*{X) = 1 
j 
] extends to 
a full and faithful functor s(IB) —> B"*". Prove that it maps Cartesian 
morphisms to pullback squares. 
[This functor restricts to a full and faithful functor M//I —)• B//.] 
s(B) 
1.3.2. 
Consider a simple fibration 
4- for a category B with finite products (1, x). 
B 
Prove that 
(i) 
each fibre B / / has finite products, and /*:B -> M//I preserves these 
products; 
(ii) the following are equivalent: 
(a) B is Cartesian closed; 
(b) each fibre M//I is Cartesian closed; 
(c) each functor /*:B -)• M//I has a right adjoint / => (-). 
1.3.3. 
In case a category B has finite limits {i.e. additionally has equalisers with 
respect to the previous exercise), prove that B is Cartesian closed if and 
only if for each / G B, the functor /*:B —)• B / / (to the ordinary slice) 
/ / x X \ 
mapping X to I*{X) = 1 
i ^ 
1» ^^^ a right adjoint 
flj-

46 
Chapter 1: Introduction to fibred category theory 
/ 
X 
\ 
[Hint. One obtains a right adjoint ["[r by mapping a family I 
j ^ 1 to 
the domain of the equaliser e in 
1.3.4. 
Let B be a category with finite products and / an object in B. 
(i) 
Show that the functor / x (—):B -> B forms a comonad on B. 
(ii) Show that the simple shce B / / is the Kleisli category of this comonad 
/ X (—) and that the ordinary shce B / / is its Eilenberg-Moore category. 
1.3.5. 
Let B have finite limits. Prove that a map of families I y ) ~^ I 7 ) ^^ 
a mono in B"^ if and only if both its components I -^ J and X ^ Y are 
monos in B. 
1.3.6. 
A regular mono is a mono that occurs as an equaliser. Write RegSub(B) 
for the full subcategory Sub(B) consisting of (equivalence classes of) regular 
RegSub(B( 
monos. Show that the codomain functor 
4- 
is a fibration. 
1 
1.3.7. 
Let B be a category with finite limits. 
(i) 
Show that if B is a CCC then also B"*" is a CCC and 
^ 
is a functor 
which strictly preserves the CCC-structure. 
(ii) Show that the same holds for Sub(B) instead of B~^. 
/ 
X 
\ 
/ 
^ 
\ 
[Hint. For famihes I 
y 
I and I 
y 
I construct the exponent family 
(p =^ tp over the exponent object / =^ J in B as in the following pullback 
diagram. 
ip =^ il) 
U 
^ (X =^ Y) 
X^tP 
(/ => J) 
- ^ (X^J) 
] 
1.3.8. 
Give a categorical formulation of anti-symmetry of a relation R >-^ I x I. 

Section 1.4- Cloven and split 
fibrations 
47 
1.3.9. 
Verify in detail that the following functors are fibrations. 
Sub(B) 
Rel(B) 
Per(IB) 
ERel(B) 
Y 
Y 
Y 
y 
1.3.10. Define an alternative category of relations R >-^ I x J on two possibly 
different objects in a category B, which is fibred over B x B. 
E 
1.3.11. 
Let -j^P be a fibration. Prove that p is preordered {i.e. all its fibre categories 
are preorders) if and only if above each map pX —>• pY in B there is at 
most one arrow X —> y in E (i.e. if p is faithful). Conclude that in the totcil 
category of a preorder fibration, a vertical morphism is monic. 
1.4 Cloven and split 
fibrations 
The definition of a fibration is of the form "for every x and y there is a z 
such that ...". This does not imply that v^e are given for each pair x,y an 
explicit z, unless we make use of the Axiom of Choice. The differences in 
the way the structure of a fibration may be given will concern us in this 
section. Briefly, a fibration is called cloven if it comes together with a choice 
of Cartesian liftings; and it is called split if it is cloven and the given liftings 
are well-behaved in the sense that they satisfy certain functoriality conditions. 
These fibrations behave more pleasantly, and therefore we prefer to work with 
fibrations 
in split form (if this is possible). Cloven and split fibrations give 
rise to so-called indexed categories B°P —> Cat. These generalise set-valued 
functors (or presheaves) W^ -> Sets. 
E 
We recall that a functor 
^P is a fibration if for every map u: I ^ J in the 
base category B and every object X G E above J in the total category, there 
is a Cartesian lifting • —>• X in E. Assume now we choose for every such u 
and X a specific Cartesian lifting and write it as 
u(X) 
u^{X) 
^X 
(By Proposition 1.1.4 we can only choose up-to vertical isomorphisms.) 
We claim that, having made such choices, every map u: I -^ J in M deter-
mines a functor u* from the fibre Ej over J to the fibre E/ over /. (Note the 
direction!) The recipe for u*:Ej 
-> E/ is as follows. 
• for an object X E E j one has pX = J and so we take w*(X) E E/ to be the 
domain of the previously determined Cartesian lifting u{X):u*{X) 
-^ X; 

48 
Chapter 1: Introduction to fibred category theory 
• for a map f:X ^Y 
in Ej, consider the following diagram in E. 
u*[X) 
—^ 
^X 
Y 
uiY) 
\ 
u-[Y) 
L J 
^ y 
-^ J 
The composite / o u[X):u*[X) 
-> y is above u, since / is vertical. Because 
u{Y) is by definition the terminal lifting of u with codomain Y, there is a 
unique map u*[X) —• u'{Y), call it t/*(/), with u[Y) ou*{f) = f o u(X). 
By uniqueness, u* preserves identities and composition. Thus one obtains a 
functor ti*:Ej —> E/. Such functors u* are known under various names: as 
reindexing functors, substitution functors, relabelling functors, inverse 
image functors or sometimes also as change-of-base or as puUback func-
tors. We mostly use the first two names. 
1.4.1. Convention. An unlabelled arrow u*{X) —>• X in a diagram is always 
a (chosen) Cartesian morphism u{X):u*{X) 
-> X as above. Omitting these 
labels makes diagrams more readable. Choosing an object u*{X) will often be 
called substitution or reindexing (along u). 
1.4.2. Example. Assume B is a category with chosen pullbacks and consider 
the codomain 
fibration 
i 
. Recall that the fibre over / G B can be identi-
B 
fied with the slice B//. A morphism u\ I —^ J induces by the above recipe a 
substitution functor u*:M/J —>- M/I by pullbacks (as described before Exam-
ple 1.1.1). Usually it is called the pullback functor induced by t/. As a special 
case we have /*: B = B/1 —)• B/7 resulting from the unique map !/: / ^ 1 from 
/ to the terminal object 1 G B. It sends an object X G B to the Cartesian 
IxX 
projection ( 
| 
We return to our general fibration -jrP (with chosen liftings). A good ques-
B 
tion is the following: given two composable morphisms 
u 
V 
I 
^ J 
^ K 

Section 1.4'- Cloven and split fibrations 
in B, are the two resulting functors E/c z:^ E/, namely 
^ * ^ Ej ^ ^* 
49 
{v o w)* 
equal? It turns out that in general they are not equal but naturally isomorphic: 
one gets a unique mediating map as in the diagram on the left below. 
u*v*{X) -
I 
^ I 
Y 
(vouYiX) 
v^{X) 
X 
I 
= 
I 
Y 
id 
-^ X 
id*(X) 
-^ X 
-^ J 
-^ K 
id 
This isomorphism u'v*{X) 
^ [v o uY[X) 
arises because Cartesian morphisms 
are closed under composition, so that there are two Cartesian liftings oi v o u 
at X, as indicated. 
There is a similar phenomenon for identities, as in the diagram on the 
right, since identities are Cartesian. Hence, in general the substitution functor 
(id/)* induced by the identity on / G B, is only naturally isomorphic—and 
not equal—to the identity functor on the fibre category E/. 
Sometimes these morphisms t/*t;*(X) -=^ {v o u)*(X) 
and X -=^ id*(X) 
are identities—we then call the fibration split—but often this does not hap-
pen (e.g. in the above pullback example with B = Sets and with canonical 
pullbacks in Sets). 
(The case of identities is not problematic since we can always choose 
(id/)* =idE,.) 
It is not hard to check that the maps determined in the diagrams (for every 
X) yield natural isomorphisms id ==> (id)* and u*v* = ^ [v o u)*. Moreover, 
they satisfy certain coherence conditions, which will be given below. 
Thus, when we work with reindexing functors, lots of (coherent) isomor-
phisms crop up. It is time to sum up the above discussion in a few definitions 
and results. 
1.4.3. Definition, (i) A fibration is called cloven if it comes equipped with 
a cleavage; that is, with a choice of Cartesian liftings. This cleavage then 
induces substitution functors u* between the fibres. 

50 
Chapter 1: Introduction to fibred category theory 
(ii) A split fibration is a cloven fibration for which the induced substitution 
functors are such that the canonical natural transformations are identities: 
id = > (id)* 
and 
u*v* => (v o u)*. 
The cleavage involved is then often called a splitting. 
Fam(C) 
The family fibration 
i 
is an example of a fibration which can be 
equipped with a splitting. In f?Lct the choice of lifting described in the begin-
ning of Section 1.2 makes the fibration split. 
By using a version of the Axiom of Choice of suitable strength in the meta-
theory, one can always provide a fibration with a cleavage. We usually indicate 
explicitly when we do so. Later in Corollary 5.2.5 it will be shown that every 
fibration is equivalent (in a fibred sense) to a split one. The construction used 
there involves the fibred Yoneda Lemma. For some codomain examples, like for 
set-indexed sets in Proposition 1.2.2, and similarly for c<;-sets and PERs below, 
we can give an elementary equivalent split description, see Propositions 1.4.9 
and 1.5.3 below. 
By choosing substitution functors one obtains from a cloven fibration i an 
JB 
assignment / i-> E/ which is almost a functor W^ —)• Cat. It yields a so-called 
'pseudo-functor'. 
1.4.4. Definition, (i) An indexed category —or, to be more precise, a 
B-indexed category—is a pseudo functor ^ : B ° P —> Cat. It consists of 
a mapping which assigns to each object / G B a category ^(/) and to each 
morphism w: / -> J a functor ^(i/): ^(J) -> ^(/); note the reverse direction. 
Such a functor ^(w) is often simply denoted by u* when no confusion arises. 
Additionally, a pseudo functor involves natural isomorphisms 
r]i: id = > (id/)* 
for / E B 
fiu,v • u*v* ==^ [v o u)* 
for / —> J —y K in B 
which satisfy certain coherence conditions: 
for / A J 

Section 1.4' Cloven and split 
fibrations 
51 
-> u*{w o v)* 
^u,vUJ 
r 
J 
U 
J 
V 
J. 
W 
J. 
l^u,wov 
tor 1 —y J —> A —> L 
[v o w)*it;* 
>• [w o V o u)* 
f^vou ,w 
There is a formal similarity with the diagrams for a monad. It is made explicit 
in Exercise 1.10.7. 
(ii) A split indexed category is a functor ^ : W^ -^ Cat; it is an indexed 
category for which the ry's and /i's in (i) are identities. 
What we have said in the beginning of this section can now be summarised 
in the following result. 
E 
1.4.5. Proposition. Let 
j^P be a fibration with a cleavage. The 
assignment 
/ 1-^ E/ 
and 
u \-^ {the substitution 
functor 
u*) 
determines 
a M-indexed category. This indexed category is split whenever 
the 
cleavage of p is a splitting. 
• 
Notice that in this definition of indexed category, the coherent isomorphisms 
r],/j, are part of the structure. 
In fibrations, one does not have such structure, 
but it follows from the universal property of lifting, once a choice of liftings is 
made. For a more detailed discussion on fibrations versus indexed categories, 
see 1.10.4. 
We have seen in Proposition 1.2.2 that the non-split codomain fibration 
S e t s ^ 
Fam(Sets) 
^ ^ 
can equivalently be described as a split family fibration 
i 
Sets 
Sets 
Remember that the codomain fibration captures display indexing with substi-
tution by pullback, whereas the family fibration captures point wise indexing 
with substitution by composition. The latter gives a split fibration. There are 
similar phenomena for a;-sets and for PERs. 
(Later, in Section 1.7 we will see.that the equivalence below is an equivalence 
in a sense appropriate for fibred categories.) 
1.4.6. Definition. Let UFam(u;-Sets) be the category of "uniform families" 
of ct;-Sets. It has: 
o b j e c t s 
omega-sets (/, E) together with for each element i G / an 
cj-set {Xi,Ei). 
We shall often simply write {Xi, Ei)i^(^j^E) 
for such objects. 

52 
Chapter 1: Introduction to fibred category theory 
morphisms 
(^f, ^i)i6(/,£:) ^ 
O^j^ ^j)je{J,E) 
are pairs 
(u,{fi)i^i) 
where u: (/, E) —)• (J, E) is a morphism in a;-Sets between 
the underlying index objects and {fi'.Xi -^ yu{i))i^i is a 
collection of functions between the fibres, which is 'tracked 
uniformly': there is a code e G N such that for every i E I 
and n E E[i) one has that e • n tracks / j . Explicitly, for 
some e G N, we have 
Vi eL^ne 
E{i).yx 
G X,-. Vm G Ei{x). 
en 
me 
Eui^i)(fi{x)). 
We leave it to the reader to verify that one obtains a category. There is a 
first projection functor UFam(a;-Sets) —> u;-Sets—which is a split fibration, 
much in the same way as for Sets. This category UFam(u;-Sets) captures 
cj-sets pointwise indexing u;-sets. It is related to the arrow category c<;-Sets~^, 
capturing display indexing, in the following manner. 
UFam(a;-Sets) 
1.4.7. Proposition. The projection functor 
I 
given by the map-
CJ-Sets 
ping {Xij Ei)i^(^i^E) *~^ [^^E), is a split fibration. Moreover, there is an equiv-
alence of categories in a commuting triangle. 
UFam(a;-Sets) 
= 
^ cj-Sets"^ 
cod 
a;-Sets 
where the functor UFam(a;-Sets) —>• a;-Sets~^ sends 
with the existence predicate E on the disjoint union U^^j Xi given by 
E{i, x) — {(n, m) I n G Ei[%) and m G Ei{x)}. 
UFam(a;-Sets) 
Proof. The functor 
i 
is a fibration because for u:(I,E) 
—^ (J, E) 
in a;-Sets, and a family (Yj, EJ)J^(^J^E) 
over {J,E), 
we can form a fam-
ily u*{{Yj,Ej)j^i^j^E)) 
over {I,E) 
as (Y^(^i),Ei), where Ei{y) = ^^(^(y)-
There is then an associated Cartesian lifting {u,{id)):u*{{Yj, 
EJ)J^(^JE)) 
-^ 
(Yj, Ej)j^(^j^E) over u. This choice of liftings forms a splitting. 
The projection TT is well-defined, since it is tracked by a code for the first 
projection (n,m) •-> n. We get a functor P: UFam(u;-Sets) -^ a;-Sets~^ by 

Section I.4: Cloven and split 
fibrations 
53 
sending a morphism 
to the square 
iUiei^i'E) 
^""^^ ^ iUjeJyj'E) 
iI,E) 
^(J,E) 
where {u, /} is the function (i, x) i-> (u(i), fi{x)), tracked by Az. {e • (p^:), d • 
(pz) • {p'z)), in which e is a code for u and d is a code for the family of 
functions / = {fi)iei' We leave it to the reader to verify that "P is a full and 
faithful functor. 
In the reverse direction, one maps a family 
in a;-Sets~^ to the 
family {Xj^Ei), where for i E I the set Xi is the fibre <f>~^{i) over i E /, 
and Ei{x) — Ex{^)- 
This is evidently functorial, and yields an equivalence 
UFam(u;-Sets) -=-> a;-Sets"^, commuting with the functors to u;-Sets. 
• 
UFam(u;-Sets) 
Notice that in the split 
fibration 
i 
one has substitution by com-
u;-Sets"^ 
position, whereas in 
i 
one has substitution by pullbacks. The former 
is evidently functorial, whereas the latter is only 'pseudo-functorial'. This is 
Fam(Sets) 
Sets"*" 
precisely as for 
i 
and 
^^ 
in Proposition 1.2.2. 
Sets 
Sets 
Recall that there is a full subcategory P E R "—^ a;-Sets of partial equivalence 
relations inside the category of u;-sets. One may thus restrict the indexed ob-
jects in the definition of the category UFam(a;-Sets) to PERs. This yields 
a category UFam(PER) of c<;-set-indexed-PERs, instead of u;-set-indexed-
UFam(PER) 
a;-sets. We get another example of a split 
fibration 
i 
, which will 
CJ-Sets 
play an important role in the sequel. Therefore we spell out its definition in 
detail. 
1.4.8. Definition. Let UFam(PER) be the category with 
objects 
collections (Ri)i^j of PERs i?,- indexed by an a;-set (/, E). 
As above, these are often written as {Ri)i£(j^E)-

54 
Chapter 1: Introduction 
to fibred category 
theory 
morphisms 
{Ri)ie{i,E) 
—^ {Sj)je{J,E) are pairs (u, / ) where u: (/, E) -^ 
(y, E) is a morphism in u;-Sets and / = (/f: Ri —> Su{i))iei 
is a collection of functions between the fibres, which is 
tracked uniformly: there is an e G N such that for every 
2 G / and n G E{i) the code e • n tracks fi in P E R . 
UFam(PER) 
1.4.9. Proposition. The first projection 
I 
rnapping {Ri)i^{^jE) 
^ 
(/, E) is a split fibration. Substitution 
is by composition, 
precisely as above. D 
In the next section we shall see how one can further restrict the index 
objects to P E R <^ u;-Sets via what is called change-of-base. 
We close this section with a simple lemma which turns out to be very useful 
in calculating with fibrations. It is essentially a reformulation of Exercise 1.1.2, 
and tells us that a morphism in a total category corresponds to a morphism 
in the basis together with a vertical map. It enables us to switch smoothly 
between global structure in the total category and local structure in the fibres. 
E 
1.4.10. Lemma. Let -j^P be a fibration. For every cleavage one has an iso-
morphism 
of sets (or classes) 
E(X, y)^ ]J 
^x(x,u'{Y)) 
u:pX-)-pY 
where ]J is disjoint union. The isomorphism 
is natural in X and Y, 
between 
functors 
IE?P x E =1 Sets. 
Proof. Given / : X -> Y in E take u = pf.pX 
-^ pY and f: X -^ u*{Y) to 
be the vertical part of / , i.e. the unique vertical map with u(Y) o f — f. 
Conversely given u:pX -> pY and f'\X 
-^ w*(^) above pX one obtains 
/ =: u{Y) o f: X -^ Y. Naturality is left as exercise. 
• 
Finally, there is a principle of mathematical purity that deserves attention. 
One should not define a property for fibrations in terms of a specific cleavage; 
definitions should be 'cleavage-free' or 'intrinsic'. Sometimes it can be subtle 
that a certain property is intrinsic: consider as example, 
"every substitution functor u* has a left adjoint JJ^" 
This property does not depend on a cleavage: two diff'erent cleavages induce 
naturally isomorphic substitution functors (see Exercise 1.4.3 below); so one 
of them has an adjoint if and only if the other has an adjoint. 
Exercises 
1.4.1. 
Describe weakening functors TT* and contraction functors 6* (both on 
objects and on morphisms) for projections TT: I x J —^ I and diagonals 

Section 
1.4' Cloven and split 
fibrations 
55 
S = (id, n'): I X J -> {I x J) x J in a family fibration, a codomain fibra-
tion, a subobject fibration, and in a simple 
fibration. 
1.4.2. 
Prove that if a map u: I -^ J in the base category of a fibration is an 
isomorphism, then so is a Cartesian lifting u{X):u*{X) 
-^ X, for each X 
above J. 
1.4.3. 
Given a fibration with two cleavages. Show that for each morphism in the 
basis the two induced substitution functors are naturally isomorphic. 
E 
1.4.4. 
Let 
iP be a fibration, and consider the squares (a) in E over (b) in B. 
IB 
h 
P^ 
^ X 
PU 
^ X 
(a) 
Y 
over 
pg\ 
(b) 
V 
^ Y 
pV 
pk 
where h and k are both Cartesian. Prove that (a) is a puUback square in E 
if and only if (b) is a pullback square in B. 
[Notice that as a result, the square defining u* on morphisms in the begin-
ning of this section, is a pullback in the total category.] 
1.4.5. 
Show that any poset fibration (all of whose fibre categories are posets) is 
split. 
1.4.6. 
Assume functors B —)• C ^ A and form the comma category {K X L). Show 
[KiL) 
that the (first) projection functor 
i 
is a split 
fibration. 
IB 
[The second projection is an "opfibration", see Lemma 9.1.6.] 
1.4.7. 
Show that the split indexed category induced by the family 
fibration 
Fam(C) 
i 
sends a set / to the (functor) category C^ of /-indexed families 
of objects and morphisms of C What is the morphism part of this functor? 
1.4.8. 
The following tells that choosing a cleavage is functorial—in a suitable 
sense. Let p: E -> B be a functor. Form the pullback in Cat 
( B ; J 9 ) = E X B B ^ 
^ B ^ 
p*(cod) • 
E 
and define a functor FrE"^ —> E x ^ B"" by (/: X' -^ X) ^ 
{X,pf). 
Prove 
that p is a cloven fibration if and only if F has a 'right-adjoint-right-inverse', 
i.e. a right adjoint with identity FG —^ id as counit. 
[This result may be found in [105], where it is attributed to Chevalley. 
It shows the 'algebraic nature' of the concept of (cloven) 
fibration; 
it is 

56 
Chapter 1: Introduction to fibred category theory 
1.4.9. 
1.4.10. 
comparable to the result that chosen products x may be given by an adjoint 
functor. The result forms the basis for a 2-categoriccd formulation of the 
concept of fibration in [315, 317], see Definition 9.4.1 later on.] 
Check that the natural isomorphisms r/: id ==^ id* cind ^:u*v* ==^ {v o u)* 
in a cloven fibration make the diagrams in Definition 1.4.4 commute. 
Later in Section 1.10 it will be shown that each indexed category gives rise 
to a cloven fibration; the latter is split whenever the indexed category is 
split. Try to find this construction now already. 
[Hint. Have another look at the first part of Section 1.1 and try to generalise 
the disjoint union which is used to go from pointwise to display indexing.] 
1.5 Cha,nge-of-ba.se and composition 
for fibrations 
So far we have seen several examples of fibrations. In this section we introduce 
two basic techniques for constructing new fibrations from old, namely change-
of-base (or pullback) and composition. This will give rise to new examples of 
fibrations, 
but also to a rediscovery of some old ones. 
1.5.1. L e m m a (Change-of-base). Let 
-jrP be a 
fibration 
andK.A 
functor. 
Form the pullback in Cat 
be a 
A X B E 
- ^ E 
K^ip) J 
In this situation, 
the functor 
K* {p) is also a fibration. It is cloven or split in 
case p is cloven or split. 
We should point out that we are using the ordinary pullback of categories 
here: A Xi E has pairs / E A, X G E with KI = pX as objects. So we use 
equalities between objects, instead of isomorphisms. 
Proof. Given an object [J^Y) 
G A XB E (so KJ 
— pY) 
and a morphism 
w: / ^ J in A. Let / : X ^ Y in E be a Cartesian lifting of Ku: KI -^ KJ in 
B. The pair (t/,/) is then A'* (p)-Cartesian over u\ 
XffiE 
{LX)-----^{J,Y) 
K*{p) 
A 
-^ J 
D 

Section 1.5: Change-of-hase and composition for fibrations 
57 
1.5.2. Examples. In general change-of-base is a useful tool for defining (fi-
bred) categories. For example, it can be used to take out a certain part of a 
fibration. 
(i) Let FinSets ^-> Sets be the category of finite sets. Change-of-base 
FinFam(C) 
J 
FinSets ^ 
Fam(C) 
Sets 
FinFam (c) 
yields the fibration 
4- 
of finite families of objects and arrows in C. 
. 
FinSets 
** 
Such a diagram will often be called a change-of-base situation. 
(ii) Let C be a locally small category with terminal object 1. By change-
of-base along the global sections functor F = C(l, —):C —> Sets one obtains 
the so-called scone Sc(C) and the injective scone iSc(C) in 
>• Sub(Sets) 
Sc(C) 
^ J 
' 
^ Sets"^ 
' cod 
and 
iSc(C) 
\ 1 
' 
c 
Sets 
C 
Sets 
The previous lemma yields that the scone and injective scone of C are fibred 
over C. Sometimes the scone Sc(C) is called the Freyd cover of C, see [85] 
or [186]. It can also be described as the comma category (Sets I F). 
Next we show how two specific fibrations that we already know can be re-
constructed via change-of-base. For the first example, recall from the previous 
UFam(PER) 
section the fibration 
i 
of cj-set-indexed-PERs. This fibration can be 
CJ-Sets 
turned into a fibration of PER-indexed PERs by restricting the index objects 
to P E R <^^ u;-Sets via change-of-base. What we get is a split fibration, which 
turns out to be equivalent to the codomain fibration on PERs. 
UFam(PER) 
1.5.3. Proposition. Form the split 
fibration 
i 
PERs in the following 
change-of-base 
situation. 
P E R 
of 
PER-indexed 
U F a m ( P E R ) 
J 
P E R ^— 
UFam(PER) 
-^ a;-Sets 

58 
Chapter 1: Introduction to fibred category theory 
There is then an equivalence of categories in a commuting triangle: 
UFam(PER) 
= 
^ PER"' 
cod 
PER 
relating pointwise and display indexing of PERs. 
Using the same notation UFam(PER) for different total categories here may 
seem confusing, but is rather convenient, and should not lead to problems as 
UFam(PER) 
UFam(PER) 
long as we use the entire fibration, as in 
i 
and 
i 
, i.e. the 
^ 
. 
' 
PER 
U;-Sets . ' 
total category together with the base category; then one can still see the 
difference. 
Proof. One maps a family of PERs {R[n])[n]e^/A indexed by a PER A, to 
the projection w: {A \ R} -^ A, where {A \ R} is the PER 
{A I i?} = {(n, m) I pnApm and p'n/?[p„]p'm} 
and TT is the projection given by [(n, m)] »-> [n]. 
f R \ 
In the reverse direction, one maps a family I 
^^ j in PER~^ to the 
collection R[n] ioT n E \A\ where R[n] is the fibre 
R[n] = {{m,m')eR\^{[m]) 
= [n]}. 
Further details of the equivalence are left to the reader. 
• 
UFam(PER) 
Notice that we have obtained a fibration 
i 
by change-of-base 
PER 
P E R ^ 
which is equivalent to the fibration 
i 
. In such a situation we also say 
PER 
that there is a change-of-base situation 
PER-^ 
^ UFam(PER) 
PER ^ 
^ cj-Sets 
But notice also that this diagram is not a pullback in Cat, in the sense that 
we used before. We shall be similarly sloppy in the next result. 
But first recall (e.g. from [42]) that in a category C with finite limits and 
finite coproducts (0,+) one says that coproducts are universal if in a dia-

Section 1.5: Change-of-base and composition for fibrations 
59 
gram, 
X' 
J 
X 
^ z *-
L 
y 
- * x + y ^ 
(*) 
the left and right squares are pullbacks, then the top row is (also) a coproduct 
diagram (i.e. the induced cotuple X' + Y' -> Z is an isomorphism). And 
coproducts are called disjoint if the coprojections K, K' are monos and form 
a pullback square 
0 
^ y 
J 
X 
-^X^Y 
Below we use the fact that if coproducts are universal, then the initial object 
0 is strict: every map X ^ 0 is an isomorphism, see Exercise 1.5.6. 
Notice that these notions easily extend to coproducts Ujc/ ^i indexed by 
an arbitrary set /. This is what we shall use. 
1.5.4. Proposition. Let C be a category with finite limits and set-indexed 
coproducts Ui^j Xi, which are universal and disjoint. There is then a copower 
functor 
Sets 
u 
c 
by 
/ • l = U.-6/(l) 
where I £ C is the terminal object. This yields an equivalence of categories 
— 
r 
C/L[(^) 
^ C , natural in / E Sets. 
Then we can obtain the family fibration on C in a change-of-base situation, 
cod 
Sets 
— 
>• C 
Fam(C) J 
u 
By this result, we have a correspondence between pointwise indexing (X,),-^/ 
/ 
X 
\ 
of an /-indexed family in C and display indexing I jj\j. 
I, over index objects 

60 
Chapter 1: Introduction to fibred category theory 
LJ(^) — IJie/ ^ ^ ^—assuming that C has a suitably rich coproduct-structure. 
Proof. For a function u: I —^ J one takes II(^)-IJ(^) "^ \1{J) ^^ ^^ ^^^ 
unique map with Y[{u) o KJ = Ku(i)-1 -^ lljeJ ^ ~ LI(*^)-
One can define two functors 
Fj 
Gj 
c/U(^) 
as follows. For a collection X = (X,)^^/ in C^, take 
where TTX is the unique map with TTX O ^i = KI O !X, . In the reverse direction, 
one takes 
G(Jr,) = (^*-
where each Zi (for i £ I) is obtained in a pullback square: 
There is a natural isomorphism FG = id since by universality the maps 
Zi —^Zin 
this diagram yield a cotuple isomorphism U- Zi -=>• Z. In order 
to prove GF = id one applies the definition of G to F((X,),-^/), leading 
to pullbacks of TTX (as above) along /c,-. This gives us the original collection 
(Xi)i^j, since there are pullback squares 
Xi 
J 

Section 1.5: Change-of-base and composition for fibrations 
61 
by the following argument. Assume u: K -> U i e / "^« ^^^"^ TT^ o w = «,- o I^. 
Then for each j ^ I, one can form the pullback square as on the left 
Kj 
J 
^ 
K 
Xi 
-* Uiei 
^i 
which yields 
(for i ^ j) 
SO that we get an isomorphism Kj = 0 (since the initial object 0 is strict). 
Hence K =. U j e / ^^J ~ ^^^^ which yields the required mediating map K -> Xi. 
D 
The second way of constructing new fibrations is simply by composition. 
This shows that repeated indexing is a form of indexing. 
E 
B 
1.5.5. Lemma. Let 
^P and 
{^ be fibrations. 
E 
(i) The composite 
^^ 
^^ then also a fibration, 
in which 
f in E 25 rp-Cartesian 
<=> / is p-Cartesian 
and pf is 
r-Cartesian. 
In case both p and r are cloven (or split), then the composite fibration rp is 
also cloven (or 
split). 
(In such a situation 
one often calls p a fibration over r, see also Sec-
tion 
9.4') 
(ii) For each object I £ A one obtains a functor 
pj from E/ = 
(rp)~^(I) 
to IB/ = r~^(I) 
by restriction. 
All of these pj 's are 
fibrations. 
Proof, (i) Given y G E and u: I —^ rp(Y) 
in A. Let / be an r-Cartesian 
lifting of u and g a p-Cartesian lifting of / ; one obtains that g is rp-Cartesian 
over u: 
P(Y) 
rp(Y) 

62 
Chapter 1: Introduction to fibred category theory 
(ii) Left to the reader. 
D 
1.5.6. Example. Let B be a category with pullbacks, and write 
—> '' • —y 
{n times) 
for the linear order of length n, considered as a category. Consider then the 
sequence of functor categories and generalised codomain functors: 
-^ B"^-^ 
^ B"^ 
^ B 
^ 1 
sending 
/n, fn-l 
fl^\ 
ffn-l 
^ ) 
Then each of these functors is a fibration, and all (finite) composites are 
fibrations. 
The last two exercises 1.5.6 and 1.5.7 below contain some useful facts about 
universal and disjoint coproducts, which are there for future reference. For 
more information, see [42, 51]. There, a category C with coproducts is called 
extensive if the canonical functors C/X xC/Y 
-^ C/(X-\-Y) 
are equivalences. 
This definition does not require C to have pullbacks: it can be shown that the 
relevant pullbacks for universality and disjointness are induced. 
(A comparable property for 'extensive fibrations' may be found in Exer-
cise 9.2.13 (iii)) 
Exercises 
1.5.1. 
See the difference between the (total) categories FinFam(Sets) and 
Fam(FinSets). 
1.5.2. 
Define a split fibration of PER-indexed-a;-sets by change-of-base. 
E 
B 
1.5.3. 
Consider the fibrations J^^ and 
y 
in the'composition'Lemma 1.5.5. 
B 
A 
(i) 
Prove Lemma 1.5.5 (ii). 
(ii) Let f:X 
—^ Y be a morphism in E and write / = pX G B. Show 
that / is p-Cartesian if and only if it can be written as g o h with g 
rp-Cartesian and h pj-Ccirtesian. 
1.5.4. 
Consider the scone construction from Example 1.5.2 (ii), and prove: if C is 
Cartesicin closed, then so is Sc(C), and the functor Sc(C) —^ C preserves 
this structure. 
[This result can also be proved via more advanced fibred techniques, see 
Example 9.2.5 (i).] 
1.5.5. 
Let A be a complete lattice. Check that coproducts Vie/^* ^^ ^ ^^^ ^^" 
verscd if and only if yl is a frame, i.e. satisfies y A (Vjc/ ^t) — Vte/l^ ^ ^O-
And that coproducts are disjoint if and only if A has at most two elements. 

Section 1.6: Change-of-base and composition for fihrations 
63 
1.5.6. 
1.5.7. 
(Cockett, see e.g. [51]) Let B be a distributive category, i.e. a category 
with finite products (1, x) and coproducts (0,+) which are distributive: 
the canonical maps (Z x X) -\- {Z x Y) -^ Z x (X -\- Y) are isomorphisms. 
(Alternatively, universality of coproducts as in diagram (*) on page 59 
holds for the special case where Z -^ X -\- Y is a Cartesian projection 
z X (X + y)-> X + y.) 
(i) 
Use distributivity to show that morphisms of the form 
X 
xX 
AC X i d -^ (x + y) x x 
are split monos. 
(ii) Prove that coprojections X -^ X -\-Y <^ Y are monos. 
[Hint. For f^g.Z^X 
with K o f = K o g^ consider the diagram: 
a/) 
X x X ^ 
K X id 
(x + y) xx 
This slightly simplifies the argument in the proof of [51, Lemma 3.1].] 
(iii) Show that the canonical maps 0 ^ 0 x Z are isomorphisms. (Hence 
a distributive category is characterised by: functors ( —) x Z preserve 
finite coproducts.) 
[Hint. Notice that the codiagonal V = [id, id]: (0 x Z) + (0 x Z) ^ 0 x Z 
is an isomorphism. Hence the two coprojections K^K'.OXZ 
=4 (Ox 
Z) -|- (0 X Z) are equal, and so ciny two maps 0 x Z =1 y are equal.] 
(iv) Conclude from (iii) that 0 is a strict initial object: every map Z —)• 0 
is an isomorphism. 
Prove that in a category IB with disjoint and universal coproducts, diagrams 
of the form 
/ 
-^ J 
I-\-K 
u -\- V 
K 
t 
-^ 
J-\-L 
V 
u -{- u 
I 
V 
are pullback squares. Show also that the coproduct functor -f:B x 
preserves puUbacks. 

64 
Chapter 1: Introduction to fibred category theory 
1.6 Fibrations of signatures 
Signatures will be used in this book as the basic structures that generate a 
logic or a type theory. They contain the basic types and function symbols 
(possibly also predicate symbols) which are used to build a logic or type 
theory on. The aim of this section is twofold: first to define signatures and 
organise them in suitable (fibred) categories. It turns out that these categories 
of signatures can be introduced most conveniently by change-of-base. The 
second aim is to use signatures, together with categories of models, to illustrate 
the organisational power of fibrations. 
In universal algebra and traditional logic one uses 'sort' for what we prefer 
to call 'type'. A typical signature consists of a set of basic types, say {N, B,...}, 
together with a set of typed function symbols, containing for example 
+ 
succ 
A 
= 
IM,N -
N —^ 
B,B-
N,N-
- ^ • N 
>N 
- > B 
—^B 
A signature is called single-typed if it has only one basic type and many-
typed otherwise. Many-typed signatures are of fundamental importance for 
algebraic data types and specifications, see e.g. [77]. Here (and in the next 
chapter) we investigate 'pure' signatures without equations. The latter are 
included in Chapter 3 on equational logic. And in Chapter 4 on first order logic 
we shall have signatures with (many-typed) predicate symbols. Signatures 
underlying higher order logic in Chapter 5 have a distinguished type Prop for 
propositions. 
Alternative, older names for 'many-typed' are 'many-sorted' and 'heteroge-
neous' (as used for example in [34]), which are in contrast with 'single-sorted' 
and 'homogeneous'. Mathematical interest has been focussed mainly on single-
typed signatures, but the more general many-typed signatures are standard 
in computer science. 
Formally, a many-typed signature E is a pair (T, T) where T is a set 
of (basic) types and !F:T^ x T -^ Sets is a mapping which assigns to every 
sequence of types (cri,..., cr„) G T^ and (Tn+i G T a set T{{(TI, ..., cr„), (Tn+i) 
of function symbols taking inputs of type (Ji,..., cr„ and yielding an output 
of type (Jn+i- In order to simplify the notation, we shall write for a signature 
s = (r,j-), 

Section 1.6: Fibrations of signatures 
65 
for the underlying set of types, and 
F:(Ji, . . .,an —> o'n-\-i 
if 
F £ T{{(TI, . . ., cr„), cr^_|.i). 
(Notice that these sets T[a) for a G T^ x T need not be disjoint, so we may 
have overloading of function symbols, like in: 
H-:N,N—>N 
and 
+: R, R —> R. 
See also Exercise 1.6.3 below.) 
A morphism I] —> S' of many-typed signatures consists of a function 
u\\Ti\ —> |E'| between the underlying sets of types together with a family 
of functions (/«) between sets of function symbols such that 
F : ( 7 1 , . . . , CTn 
>Crn-\-l => / a ( F ) : i / ( ( 7 i ) , . . . , i i ( ( 7 n ) 
> 
u[(Tn^\) 
where the subscript a is ((0^1,..., cr„), cr„_|_i). Thus one obtains a category 
Sign together with a forgetful functor Sign -^ Sets sending a signature S to 
its underlying set of types |E|. It is a split fibration because for a signature E 
and a function u:S ^ |E| one can form a many-typed signature over 5 with 
function symbols, 
F:(Ti,...,cr„—XTn+i 
^ 
F:u(ai),...,u{an)—y 
u{an+i) in E. 
This is captured all at once in the following definition of the category of 
signatures. (We hope the reader will appreciate its conciseness.) 
1.6.1. Definition. The category Sign of many-typed signatures is de-
fined in the change-of-base situation 
Sign 
>• Fam(Sets) 
J 
Sets 
>• Sets 
T^T" 
X T 
where T^ is the free monoid of finite sequences on T (the "Kleene star"). As an 
Sign 
immediate consequence of Lemma 1.5.1 we get that 
4- 
is a split fibration. 
Often we simply use 'signature' for 'many-typed signature'. 
1.6.2. Convention. A morphism 0: E —)• E' of signatures consists of a pair 
(K, (/)) as describe above. We usually write <}> both for u and for all of the 
/'s. Thus we get 
F: (Ti,..., o-„ —> (Tn^i in E 
^ 
(l){F):(l){ai),...,(t>(an)—^Ho-n+i) 
in E'. 
This is notationally rather convenient and not likely to cause much confusion. 

66 
Chapter 1: Introduction to fibred category theory 
Terms 
The description below of the terms associated with a signature is as in univer-
sal algebra: it is based on indexed sets of term variables. In the next chapter 
we shall give a more type theoretic description (which will be used in the 
subsequent remainder of the book), based on a fixed infinite set of term vari-
ables {vo,vi,...] 
which are linked to a type in a context containing type 
declarations of the form Vi'. ai. 
Suppose E is a signature with T = |E| as underlying set of types. A 
T-indexed collection of sets X — {Xa)o£T can be seen as providing a set of 
variables X^ for every type a ET. One can form a new T-indexed collection 
(Terms, (X))^^^ 
where TermSr(X) is the set of terms of type r. These collections are defined 
as follows. 
• Xr CTermSr(X); 
• if F: n , . . . , r„ —> Tn+i in E and Mi G Terms^j (X),.,., Mn E Termsr^ (X) 
then F(Mi,...,M„) E Termsr^^,(X). 
Hence a term is a (well-typed) string consisting of variables x G U<7GT ^^ ^^^ 
function symbols F from E. There are associated notions of free variable 
and substitution: 
FV(x) = 
{x} 
FV(F(Mi,...,M„)) = FV(Mi)U-..UFV(Mn) 
and for y £ Xr and N G TermSr(X), 
r A r / 1 
( N 
if X = y 
^f^/^] = { X else 
F{Mi,...,M„)[N/y] 
= 
F{Mi[N/y],...,Mn[N/y]). 
In a similar way one defines simultaneous substitution M[N/y\. 
Notice that 
the dependence on the signature E is left implicit in the above definition of 
terms. 
(Set theoretic) semantics 
Let E be a signature, once again with T = |E| as its underlying set of types. A 
model or algebra for E consists of a T-indexed collection {Aa)(7eT of carrier 
sets together with a collection of suitably typed functions: for each function 
symbol F:cri,..., cr„ —y (Tn+i in E, an actual function [lF]]:yl<7i x- • xAa^ -^ 
Aa^^i between the corresponding carrier sets. 

Section 1.6: Fibrations of signatures 
67 
Thus a model consists of a pair ({A(j)aeTj I-!)-
1.6.3. Example. An obvious way to model a signature containing one func-
tion symbol 
if:B,N,N —>N 
for an if-conditional on the natural numbers, is to use carriers 
A^ = {0,1} 
AN = N, 
the set of natural numbers 
and a function 
[[if]]: AB X AN X AN —> AN 
(h 
) 
( n ii b — I 
\ m otherwise. 
Of course, one can more generally interpret 'If in a distributive category 
(with natural numbers object N and B = 1 -h 1, see Section 2.6), but here we 
restrict ourselves to set theoretic models. 
Such a model ({Aa)aeT, I-]]) for S can be used to interpret E-terms: sup-
pose we have a collection of variable sets X = (X(j)aeT together with a 
valuation 
{pa:Xa -^A^)^^^. 
Such a valuation consists of functions assigning values in the model to the 
variables. Then there is an interpretation consisting of functions 
given by 
I ^ L 
= 
Pr(^) 
for X e 
Xr 
For readability's sake we have omitted the superscripts r in [[ — ]]^. One obtains 
a bijective correspondence between valuations and interpretations: 
[Xa 
^Aa) (76T 
(Terms, (X) r " ^ ^ r ) . GT 
For a valuation [p^'-Xa -^ Aa) together with elements x E X^j and a ^ A^ 
one defines a new valuation p{x i-> a) by 
a 
if y = x 
p(. ^ a}{y) = { «^^^ 2.^ 

68 
Chapter 
1: Introduction 
to fibred category 
theory 
A term M G TermSr(X) contains only finitely many variables, say xi G 
Xay^,... ,Xn £ X(j^. Such a term thus induces a function 
Aa, X • • • X Aa^ 
^ Ar 
by 
In the expression on the right hand side, the valuation p does not play a role 
anymore. Interpreting a term as such a map (without valuations) gives a more 
categorical description. 
1.6.4. Definition. The category S-Mo del of (set theoretic) models of many-
typed signatures has 
objects 
(E, {Aa), H-J) where {{Aa), [[-]]) is a model for E. 
morphisms 
(0, (H,)): (E, (A,), 14) - ^ (E', « ) , ^.f) 
consist of 
• a morphism of signatures 0: E —)- E' 
• a IE [-indexed collection of functions 
Ha'. Ao 
>• ^'^0(<7) 
such that for each function symbol 
F : CTi,. .., cr„ —> cr„_|_i in E 
the following diagram commutes. 
Hai 
X • • • X Har, 
Aa^X" 
xAa^ 
^ A'^^^^^ 
X • • • X 
A. 
r 
^ 
> 4' 
^O^n + 1 
^n + l ) 
v 
Such set theoretic models of many-typed signatures and their morphisms 
are studied in some detail in [34]. 
There are a projection functors 
S-Model 
^ Sign 
^ Sets 
(E,(A,),[[_1) I 
- E 
I 
- | E | . 
They will play a role below; but first we describe syntactically constructed 
models. 

Section 
1.6: Fihrations 
of signatures 
69 
1.6.5. Example. Let E be a signature with T = |E| as set of basic types, 
and let X — {Xa)aeT be a collection of typed variables. The sets of terms 
TermSr (X) (for r ^T) form carriers for the so-called term model of E, with 
variables from X. A function symbol F: r i , . . . , r„ —y rn_|_i has an interpre-
tation as a function 
Terms^-j {X) x • • • x Terms^^ (X) 
>• TermSj^.^! {X) 
described by 
The term model on the empty collection of variables (0)(7ET is usually called 
the initial model of E. It is initial object in the fibre category over E of the 
fibration described in (i) below. 
S-Model 
1.6.6. Lemma, (i) The functor 
} 
sending a model to its underlying 
signature is a split fibration. The fibre over E G Sign is the category of models 
with signature E. 
S-Model 
(ii) The functor 
^ 
which sends a model to its underlying set of types 
is a split fibration. The fibre over T G Sets is the category of models of 
signatures with T as set of types. 
(iii) For every set of types T, the fibre category (models of signatures over 
T) is fibred over the category (signatures over T). 
Proof, (i) Given a model (E', (^4'), [[-]]') and a signature morphism (/>: E ^ 
E' one obtains a model {{Aa), J-]]) over E by putting 
A^^:MA'^^^^ 
and 
[[Fl1^'[[0(F)r. 
Sign 
(ii) -h (iii) Directly by Lemma 1.5.5, using that 
4- is a split fibration. • 
This lemma exhibits a general pattern which can be described roughly as 
follows. Given a notion V and another notion Q{a) involving a parameter a 
of type V, then, in general, the category of Q(a)'s is fibred over the cate-
gory of "P's, provided the Q(a)'s are suitably closed under substitution along 
morphisms of P's. To put it more concisely as a slogan: 
if Q's depend on "P's then Q's are fibred over V's 
In the above lemma, we have models—involving signatures and thus sets of 
types—fibred over signatures and thus fibred over sets. A similar example is 
given by the vector spaces which involve fields and are fibred over fields, see 
Exercise 1.1.11. 

70 
Chapter 1: Introduction to fibred category theory 
However, this slogan is not entirely correct since the Q's can also be 'op-
fibred' over the P's, which happens in case substitution acts covariantly (see 
Section 9.1). 
But the point is that fibrations have a great organisational strength. They 
provide appropriate ways of layering mathematical structures, by making ex-
plicit what depends on what. This is the reason which makes elementary 
lemmas like the above one important. 
In later chapters, this aspect will be crucial in modelling logics and type 
theories: for a type theory with, say, propositions depending on types (in a 
sense to be made precise in Section 11.5) the underlying structure involves a 
category of propositions fibred over a category of types. 
Single-typed 
signatures 
1.6.7. Definition, (i) We recall that a signature S is called single-typed 
if its underlying set of types |E| is a singleton. 
(ii) The category SignsT of single-typed signatures is defined by the 
change-of-base situation 
SignsT 
^ Sign 
J 
1 
^ Sets 
1 
where 1 is the (one-object one-arrow) terminal category and the functor 1 : 1 ^ 
Sets points to a singleton set. 
(iii) The category S-ModelsT of (set-theoretic) models for single-typed 
signatures arises in the change-of-base situation 
S-ModelsT 
^ S-Model 
J 
SignsT 
^ Sign 
where the functor SignsT -^ Sign comes from (ii). Thus also models of 
single-typed signatures are fibred over their underlying signatures. 
As we mentioned earlier, many mathematical texts on signatures are re-
stricted to the single-typed case. A signature for a monoid acting on a set is 
then not described by function symbols 
m:M,M—>M, 
e : ( ) ^ M , 
a:M,X—^X 

Section 1.6: Fibrations of signatures 
71 
but by a collection of function symbols 
a^: X —> X 
one for each element z in the carrier A M of M. Such a single-typed description 
is not only artificial but it also involves a mixture of syntax and semantics 
(namely M and -AM). Such practices which have arisen in mathematics are 
not necessarily well-fitted for applications in computer science. 
Exercises 
1.6.1. 
Write down a (single-typed) signature for groups and also a (many-typed) 
signature for vector spaces. 
1.6.2. 
A many-typed signature is called finite if it has only finitely many types and 
function symbols. Define the subcategory of FinSign ^^ Sign consisting 
of finite signatures by change-of-base. 
1.6.3. 
Many-typed signatures are sometimes defined (like in [343] or in [282, 2.2.1]) 
as objects of the category Sign' which arises in the following change-of-base 
situation. 
Sign' 
^ Sets"" 
cod 
Sets 
^ Sets 
Ty^T'' 
xT 
(i) 
Describe the category Sign' in elementary terms. 
(ii) Show that the categories Sign and Sign' are equivalent. 
(iii) One often prefers Sign to Sign' because signatures in Sign allow over-
loading of function symbols: for example the use of -f both for addition 
of integers and for addition of reals. Explain. 
Sign 
[Another advantage of Sign is that 
l 
is a split fibration.] 
1.6.4. 
Describe the category S-ModelsT of models of single-typed signatures in 
detail. 
1.6.5. 
The category Sign captures signatures of functions. A signature of 
predicates consists of a set of types T together with predicate symbols 
/?: (Ti,..., (Tn where each CTJ is a type (element of T). Define an appropriate 
category of such signatures of predicates by change-of-base. Define also a 
category with both function and predicate symbols by change-of-base. 
[Such a category will be introduced in Definition 4.1.1.] 
1.6.6. 
Let E be a signature and T = |I]| its set of types. We write S-Model(E) 
S-Model 
for the fibre category over E of the 
fibration 
} 
. This is the category 
of E-models. 

72 
Chapter 1: Introduction to fibred category theory 
(i) 
Show that the assignment 
X = (Xo-)cr6T H- (Termsr(X)j^^^ 
extends to a functor from the category Fam(Sets)T = Sets^ of 
T-indexed famihes of sets to S-Model (D). 
(ii) Assume (^O-)O-GT, I-I) is a E-model. Verify that an interpretation 
[[_]]p:Termsr(A') ^ >lr is a morphism of E-models. 
1.6.7. 
Let ((^<T), I - l ) be a E-model cind p a valuation {X<j -^ Aa)-
(i) 
Show that 
lM[iV/:r]]p = IMlp(,^I^I^). 
(ii) Let ((5<T),[[-]) be another E-model and {Ha'.Aa -^ Ba) be a mor-
phism of E-models [i.e. a morphism in the fibre of S-Model over E). 
Show that 
1,7 Categories of fibrations 
In this section we shall introduce and study "fibred functors" as appro-
priate morphisms between fibred categories (preserving the relevant struc-
ture). Also we shall describe "fibred natural transformations" between such 
fibred functors—just like ordinary natural transformations are morphisms be-
tween morphisms of ordinary categories (i.e. functors). We shall describe four 
(2-)categories of fibrations according to the following table. 
split 
not necessarily split 
1 over a fixed basis B 
Fib,pHt(B) 
1 
Fib(B) 
over arbitrary bases 
Fibgpiit 
Fib 
By laying down what appropriate morphisms of fibrations are, we can use 
categorical language to talk about fibrations as objects. This enables us to ex-
press some elementary facts about fibrations. Also, we say what fibred natural 
transformations (2-cells) are. Then we can apply various 2-categorical notions 
in the context of fibrations, like equivalence, and adjointness; the latter is 
studied in the next section. 
We start with the category named Fib, because it is most general among 
the categories in the table: it contains the other three as subcategories. 

Section 1.7: Categories of fihrations 
73 
1.7.1. Definition, (i) A m o r p h i s m ( 
VP \ -^ 
sists of a pair of functors /i': B —> A and iJ: E ^ D such that the diagram 
t^ 1 of fibrations con-
commutes and H sends Cartesian morphisms in E to Cartesian morphisms in 
D. Such a functor H will be called fibred. This yields a category which will 
be written as Fib. 
(ii) The subcategory Fibgpiit ^^ Fib has split fibrations as objects and 
morphisms {K, H) as above where H preserves the splitting on-1he-nose (that 
is, up-to-equality and not up-to-isomorphism). 
Notice that in (i) we require the square to commute on-the-nose, not up-
to-isomorphism. As it stands, the notion of morphism of fibrations is easy to 
work with and does what we want. For a more abstract approach, see [317]. 
Here is a first result that we can now express. 
1.7.2. Lemma. The 
functors 
Fib 
Cat 
and 
Fibgpiit 
Cat 
sending a (split) fibration 
to its base category are fibrations themselves. 
Rein-
dexing is done by change-of-base, 
see Lemma 
1.5.1. 
• 
1.7.3. Definition, (i) For a fixed category B, the category Fib(B) of fibra-
tions with B as base category is defined to be the fibre over B of the above 
Fib 
fibration 
i 
. It thus has fibrations with basis B as objects. A morphism 
E 
' 
1 
ID) 
\ 
-^ \ 
ji^ j in Fib(B) is then determined by a functor i J : E 
making the triangle 
H 
E 
^ D 

74 
Chapter 1: Introduction to fibred category theory 
commute and preserving Cartesian morphisms. We call such a functor a fibred 
functor (as before) or a functor over B. 
(ii) Similarly the category Fibspiit(B) is defined to be the fibre over IB of 
Fib^piit 
the fibration 
I 
. Morphisms in Fibspiit(B) are fibred functors H as in 
the triangle, which preserve the splitting on-the-nose. They will be called split 
functors. 
(iii) If i/:E —>• D is a fibred or split functor as in (i) or (ii), then for each 
object / G B one obtains by restriction a functor E/ —^ D/ between the fibres 
over /; it will be written as Hj. 
Often the name 'Cartesian functor' is used for what is called a 'fibred func-
tor' here. This predicate 'Cartesian' is not very appropriate, because such 
functors are not Cartesian morphisms for some fibration. 
Notice that the category Fib(l) of fibrations on the terminal category 1 
can be identified with the category Cat of categories. 
1.7.4. Lemma. The categories Fib(B) and Fibspiit(B) have finite products; 
these are preserved by change-of-base. 
1 
Proof. The identity functor i is terminal object, and the Cartesian product 
of two fibrations 
tP and 
j-^ on B is defined in: 
B 
B 
E X B D 
^ D 
p*(g) 
pxq 
E 
^ B 
P 
This yields a fibration p x ^ by Lemmas L5.1 and L5.5 (since it is obtained 
by change-of-base and composition). 
• 
The next two lemmas give examples of morphisms of fibrations. 
1.7.5. Lemma. Let A and B be categories with puUbacks and let K:A -^ B 
be a pullback preserving functor. There are then extensions of K to morphisms 
/ Sub(A) \ 
/ Sub(B) \ 
f 
^'^ \ 
f 
^~' \ 
between the corresponding subobject and codomain fibrations. 

Section 1.7: Categories of 
fibrations 
75 
Proof. The functor K preserves monos, since m: X -> / is a mono if and 
only if the following diagram is a pullback. 
X -
id 
1 
X -
id ^ X 
T 
^ I 
m 
Thus one can define a functor Sub(A) -^ Sub(IB) by 
/ 
m 
\ 
/ 
Km 
\ 
[X> 
^ I) 
I 
^[KX> 
^KI). 
It preserves Cartesian morphisms because K preserves pullbacks. 
The extension to codomain fibrations is obvious. 
D 
1.7.6. Lemma. Let K: (A, 5) —>• (IB, T) be a morphism 
of CT-structures 
(see 
Definition 
1.3.2). One obtains an extension 
of I{ to a morphism 
between the 
s(5) 
s(T) 
corresponding 
simple fibrations 
i 
—^ i 
which preserves 
the splitting 
on-
the-nose. 
Proof. By definition K preserves finite products, so let ^ij:I\I 
x AV 
^ 
I\[I 
X J) be the inverse of the canonical map {K-K^J-C-K'). 
One can define a 
functor s(/i):s(5) -^ s(T) on objects by {I^X) 
\-^ {I{I,I{X) 
and on arrows 
{uJ):(I,X) 
-^ (J, y)—where w: / ^ 
J and / : / x X -> Y—hy 
{uj) 
^ 
{I{u, I{f o 7/,x)- The splitting is preserved since 
s{I<){u, TT') = {K{u), K{w') 07) = {K{u), TT'). 
D 
As special case, a finite product preserving functor A ^ IB induces a mor-
s(A) 
s(B) 
phism 
i 
^ 
4- between the corresponding simple fibrations. 
A 
B 
2-categorical 
structure 
It turns out that the homsets 
F i b ( p , q) 
and 
Fib(B)(p, q) 
(and their split versions) are categories themselves. One thus gets 2-categories 
of fibrations. This extra structure enables us to express various 2-categorical 
notions—like adjunctions, equivalences or (co)monads—for fibred categories. 
In general, these notions will be quite different in F i b and in Fib(B), see [125-
127] for an investigation. We shall not make deep use of the 2-categorical 

76 
Chapter 1: Introduction to fibred category theory 
aspects. And we usually spell out the details of the 2-categorical notions that 
we use for fibrations. But we do find it convenient to have the language of 
2-categories at hand. 
1.7.7. Definition. Assume [K,H) 
and {L,G) are morphisms 
( f ^ j 
in Fib (i.e. 1-cells) as below. A 2-cell {K,H) 
^ 
{L,G) in Fib 
consists of a pair of natural transformations a: K => L and r: H ^ G in a, 
diagram: 
H ^ 
G 
K 
L 
E 
A 
such that T is above cr; that is, for X G E, the component TX is above the 
component Cpx - This may be expressed as: the two 2-cells qH => qG and 
Kp => Lp in the diagram are equal. One obtains that Fib is a 2-category, 
with identities and composition of 2-cells inherited from Cat. 
The 2-cells in the category Fibgpiit are as in Fib. And a 2-cell in Fib(B) 
or Fibgpiit (B) is given by a diagram 
in which every component of r is vertical. Such a 2-cell in Fib(B) or 
Fibspiit(B) is often called a vertical or fibred natural transformation. 
Since 'equivalence' is a 2-categorical notion we have that two fibrations 
E 
P 
•j<P and 
-jrQ with the same basis B are equivalent (formally: equivalent 
in Fib(B), or over B) if there are fibred functors F:E -> D and G:D ^ E 
with vertical natural isomorphisms GF =. id^ and FG = idp. Several of the 
equivalences between total categories that we have seen before (see Proposi-
tions 1.2.2, 1.4.7, 1.5.3 and Exercise 1.2.3) are actually/i6rec/ equivalences. 

Section 1.7: Categories of fibrations 
1.7.8. Proposition. There are fibred equivalences 
over Sets; 
Fam(Sets) — = - ^ Sets"^ 
Fam(Sets») 
~ > S e t s ; 
77 
Sets 
and over u-Sets 
and P E R ; 
Sets 
UFam(u;-Sets) 
-^ a;-Sets 
UFam(PER) 
^ P E R " 
a;-Sets 
P E R 
n 
are split, because they involve 
Noti(^e that all the fibrations on the left of 
pointwise indexing. 
We mention two lemmas involving fibred 2-cells. The first one is easy. 
1.7.9. Lemma. Let / i : A -^ IB 6e a functor. 
Change-of-base 
along K 
yields 
a 2-functor 
/i*:Fib(B) -^ Fib(A). 
It restricts to Fibspiit(B) -^ Fibspiit(A). 
D 
The second lemma is more involved and may be skipped at first reading. 
The essential point about fibrations is that (single) morphisms in the base 
category can be lifted. By the universal property of such liftings one can also 
lift a natural transformation. This is the content of the next result. Since a 
natural transformation consists of a family of arrows, one needs to lift many 
maps at the same time, and so we require a cleavage. 
1.7.10. Lemraia. Assume 
that two functors 
K^L.A 
are given with a 
natural transformation 
a: K => L between them. Let 
^P be a cloven 
fibration; 
then there is a lifting a: K'{cr) 
A X K E 
/i*(p) 
L in a diagram, 

78 
Chapter 1: Introduction to fibred category theory 
where (a) is the functor which sends {I,X) 
to {I,a*j{X)), 
The pair {o-,W) is a 
2'Cell in Fib from {K^I{'{a)) 
to (L,L'). All components of the lifted natural 
transformation '& are Cartesian. 
This lifting of cr to a^ enjoys a certain universal property, which will not be 
made explicit here. But the reader may consult [171] (or also [252, II, 1.7]). 
In [171] such lifting of natural transformations is described as lifting of 2-cells 
in a 2-category, and used to give a definition of when a 1-cell E ^ B is a, 
fibration (in this 2-category). This yields an alternative to the (2-categorical) 
definition based on Exercise 1.4.8. 
(Later in Exercise 9.3.8 we shall relate (families of) adjoints to reindex-
ing functors CTJIEL/ —> E^/ between fibres to adjoints to the above functor 
(a): A x / ^ E ^ A x ^ E between total categories.) 
Proof. The component of o" at {I,X) E Ax^, E is obtained from the cleavage, 
as: 
A f / 
^l{X) 
. 
i^)(i.x) 
= {l<'{<^){I>^) = K'iLaUX)) 
= aUX) 
X = 
L'(I,X)) 
using that X G E is above the codomain of aj: I{I —^ LI = pX in B. This 
a" is a natural transformation since for a morphism (w, / ) : (/, X) —>• (J, Y) in 
A XL E—where u: I -^ J in A and /: X ^- Y in E with pf — Lu—one has a 
naturality square in B: 
KI 
(^i 
KJ 
-^ LI = pX 
Lu = pf 
^ LJ = pY 
o-j 
And above this diagram in E: 
a}{X) 
K'{a){uJ) 
= Ku 
" ^ 
i^){i,x) 
^}{y) 
^ X 
i^){J,Y) 
where the dashed arrow is the unique one above Ku making the square com-
mute (because (o^)(j,y) is Cartesian). Thus, basically, a" is a natural transfor-
mation by definition of (a). 
D 

Section 1.7: Categories of 
fihrations 
79 
Exercises 
1.7.1. 
Show that the categories Fib and Fibgpiit both have finite products. 
E 
ED 
1.7.2. 
Let 
^P and 
^^ be fibrations and / / : E -> D a functor with qH = p. 
1
1 
. 
(i) 
Assume H is full and faithful; prove that H reflects Cartesianness, 
i.e. that Hf is Cartesian imphes that / is Cartesian. 
[Hint. Use Exercise 1.1.2] 
(ii) Assume now that // is a fibred functor, i.e. that it preserves Carte-
sianness. Show that 
//: E ^ D is full <^ every Hi: E/ -> D/ is full. 
And that the same holds for 'faithful' instead of 'full'. 
1.7.3. 
Let 2 be the two-element poset category {±,T} with ± < T. Describe an 
Fam(2) 
Sub(Sets) 
isomorphism of 
fibrations 
i 
= 
I 
in Fib(Sets). 
Sets 
Sets 
/Fam(C 
1.7.4. 
Verify that the assignment C i-^ I 
i 
I extends to a (2-)functor 
\ 
Sets 
' 
Cat -^ Fibspiit(Sets). 
1.7.5. 
Check that the assignment / H^ I 
>|,dom/ j yiel^Js ^ functor 
Fibspiit(B) which preserves finite products. 
1.7.6. 
Let A, B be categories with finite products and let A': A —)• B be a functor 
s(A) 
s(l) 
preserving these. Lemma 1.7.6 yields a map (A', s(A")): i 
^ 
i 
be-
A 
1 
tween the associated simple fibrations. Show that the functor s(A"):s(A) —> 
s(B) between the total categories, restricted to a fibre A / / —>• M//KI, pre-
serves finite products (see also Exercise 1.3.2). 
1.7.7. 
(See [105, Theorem 3.9].) Notice that (as a special case of Exercise 1.4.6), 
(liF) 
for every functor F: A —>• B, the projection functor 
4- 
from the comma 
1 
category to B is a split fibration. Prove that the assignment 
A 
(T) 
yields a functor C a t / B -^ Fit>spiit(B), which is left adjoint to the inclu-
sion (in the reverse direction). Describe concretely how each functor factors 
through a split fibration. 
1.7.8. 
Verify that (a) in Lemma 1.7.10 is a fibred functor L*{p) -^ 
K*{p). 
E 
1.7.9. 
Let •^P be a fibration. A fibred monad on p is a monad on p in the 
1 
2-category Fib(B). It is thus given by a fibred functor T: E ^ E together 
with vertical unit r/: id(C =^ T and vertical multiplication ^:T^ => T, satis-
fying {J. o Trj = '\d = iJ. o riT and ^ o T^j, = ^ o ^T as usual. 

80 
Chapter 1: Introduction to fibred category theory 
(i) 
Show that the (ordinary) Kleisli category lEV is fibred over B. 
(ii) Show also that the Eilenberg-Moore category of algebras E^ of the 
monad T is fibred over B. (Note that every algebra is automatically 
vertical.) 
E T 
E ^ 
[These 
fibrations 
i 
and 
^ 
are the Kleisli- and Eilenberg-Moore-
objects in the 2-category Fib(B) (see [314] for what this means). The con-
structions in Fib are quite diff'erent, see [129].] 
1.8 Fibrewise structure and fibred adjunctions 
In ordinary categories one can describe binary products x or coproducts + in 
familiar ways, for example in terms of their universal properties. The question 
arises whether such structure also makes sense for fibred categories, and if 
so, what does it mean. One answer here will be: products x in every fibre, 
preserved by reindexing functors u* between these fibres. This gives "fibrewise 
structure". It will be our first concern in this section. 
In a next step one notices that (chosen) products x for ordinary categories 
can equivalently be described in terms of ordinary adjunctions; that is, in 
terms of adjunctions in the 2-category Cat of categories. It turns out that such 
fibrewise structure can similarly be described in terms of suitable adjunctions 
between fibrations. Formally, such "fibred" adjunctions are adjunctions in a 
2-category of fibrations Fib(B) over a fixed base category B. This will be our 
second concern. 
(There is also an alternative answer which is of a global nature and will 
be of less interest here. It involves structure defined by adjunctions in the 
2-category Fib of fibrations over arbitrary bases. See for example Exer-
cises 1.8.10 and 1.8.11. In the latter one finds how adjunctions in Fib reduce 
to adjunctions over a fixed basis.) 
1.8.1. Definition. Let <C> be some categorical property or structure (for ex-
ample some limit or colimit or exponent) 
(i) We say a fibration has fibred <0>'s (or also, fibrewise O's) if all fibre 
categories have O's and reindexing functors preserve <0>'s. A split fibration has 
split fibred O's if all fibres have (chosen) O's and the reindexing functors 
induced by the splitting preserve O's on-the-nose. 
(The predicate 'fibred' is sometimes omitted, when it is clear that we talk 
about fibred categories.) 
f ^ \ 
(K L) f 
^ 
\ 
(ii) A morphism ( 
^P j 
—^ 
( 
j - ^ 1 of fibrations with O's preserves 
(fibred) O's if for each object / E B the functor L/:E/ —^^KI 
preserves O's. 

Section 1.8: Fihrewise structure and fibred adjunctions 
81 
For the split version, one requires preservation on-the-nose. 
The following notion deserves explicit attention because of its frequent use. 
1.8.2. Definition. A (split) fibred CCC or Cartesian closed 
fibration 
is a fibration with (split) fibred finite products and exponents. 
1.8.3. Examples, (i) Usually, ordinary categorical structure exists in a cat-
egory C if and only if the corresponding fibred structure exists in the family 
Fam(C) 
fibration 
i 
. For example: 
Sets 
Fam(C) 
C is a CCC (with chosen structure) -O* 
i 
is a split fibred CCC. 
The implication (=>) follows from a pointwise construction: e.g. the Cartesian 
product of families {Xj)j^j 
and {Yj)j^j 
in the fibre over J is {Xj x 
Yj)j^j. 
Reindexing preserves this structure on-the-nose: for u: I —^ J in Sets we get: 
= {Xu{i) X Yu(,))i6/ 
- 
(Xu{ij)i&I 
X {Yu(i))i^I 
= 
u'{(Xj)jej)xn'{{Yj)j^j). 
The implication (<=) in the reverse direction follows from the fact that the 
category C is isomorphic to the fibre Fam(C)i above the terminal object 1— 
which is a CCC, by assumption. 
(ii) Exercise 1.3.1 almost contains the result that for a category B with 
s(B) 
finite products, the simple fibration i 
has split finite products. The only 
B 
requirement that should still be verified is that reindexing functors preserve 
the fibrewise structure. This is easy. Moreover, this result can be extended to: 
s(B) 
i 
is a split fibred CCC if and only if B is a CCC. 
(iii) For a category B with finite limits, the codomain 
fibration 
^ 
on 
B always has fibred finite limits. The same holds for the subobject fibra-
Sub(B) 
tion 
i 
on B. And for a finite limit preserving functor F:A -> B be-
B 
tween categories A, B with finite limits, the induced morphisms of fibrations 
A"^ 
B"^ 
Sub(A) 
Sub(B) 
4- 
-^ 
i 
and 
i 
-> 
i 
(see Proposition 1.7.5) preserve fibred 
finite limits. 
(iv) A category B with finite limits is a locally Cartesian closed cate-
gory (LCCC)—i.e. all its slice categories B / / are Cartesian closed—if and 

82 
Chapter 1: Introduction to fibred category theory 
only if the codomain 
fibration 
^ 
is a fibred CCC. The (if)-part of the 
IB 
statement is obvious by definition of LCCC. For (only if), it remains to verify 
that the reindexing functors (given by pullback) preserve the exponents in 
the fibres (often called local exponentials). This will be postponed until 
Exercise 1.9.4 (iii). 
(v) Recall from Section 1.2 that the categories PER and u;-Sets have 
finite limits and are Cartesian closed. By a pointwise construction (as in (i) 
above) this structure lifts to split fibrewise finite limits and exponents for the 
UFam(u;-Sets) 
UFam(PER) 
UFam(PER) 
fibrations 
i 
, 
i 
and 
i 
of cj-sets and PERs over 
CJ-Sets 
U;-Sets 
P E R 
u;-sets, and of PERs over PERs. 
The following result is often useful. 
1.8.4. Lemma. Let ^ be as in Definition 1.8.1. If a (split) fibration p has 
(split) fibred (^'s, then so has a fibration K*{p) obtained by change-of-base. 
Moreover, the associated morphism of fibrations K*{p) -^ p preserves ^^s. 
Proof. Suppose p has fibred ^'s. The fibre of K*(p) above / is isomorphic 
to the fibre of p above KI. Hence K*{p) has <)'s in its fibre categories. They 
are preserved under reindexing, since the reindexing functors of K*{p) are 
obtained from those of p. 
• 
1.8.5. Example. The category Sets has all (small) limits and colimits. 
Fam(Sets) 
Hence by Example 1.8.3 (i) the family 
fibration 
i 
of set-indexed sets 
has these limits and colimits in split form. Recall from Definition 1.6.1 that the 
Sign 
fibration 
4- 
of many-typed signatures is obtained by change-of-base from 
Sets 
this family fibration. Hence the fibration of signatures has split limits and 
Sign 
Fam(Sets) 
colimits. Moreover, the morphism of fibrations i 
—)• 
4- 
preserves 
Sets 
Sets 
these. 
Adjunctions between fibred categories 
We begin the study of fibred adjunctions with an example. Recall that an 
ordinary category C has a terminal object if and only if the unique functor 
C —• 1 from C to the terminal category 1 has a right adjoint (written as 
1:1 -> C). The situation is similar for fibred categories. Consider for example 
a codomain 
fibration 
i 
. Every fibre B/J has a terminal object, namely 
IB 
f J\ 
the identity family IJ = I 
j 
] • The assignment J H-> 1J then extends to 
a functor 1: B —>• B"^ . It has the following properties. 

Section 1.8: Fibrewise structure and fibred adjunctions 
83 
(i) This functor 1 can be described as a fibred functor idi —)• cod as in 
where the identity functor id© is the terminal object in the category Fib(B) 
of fibrations over IB. 
(ii) The functor 1 is right adjoint to the unique morphism cod —-• id© in 
Fib(IB): there are obvious adjoint correspondences 
m 
^ J 
inB 
Moreover, the unit and counit of this adjunction are vertical in the above 
triangle. 
These two points establish that the fibred terminal object functor 1:B —y 
B"^ obtained by taking fibrewise terminal objects, is a 'fibred right adjoint' to 
the functor cod —^ idi—^just like in the case of ordinary categories a terminal 
object in C is given by a right adjoint to the functor C —-• 1. 
Below we present the general formulation of the notion of fibred adjunction. 
Formally, it is an adjunction in a 2-category of fibrations over a fixed base 
category. 
E 
B 
1.8.6. Definition, (i) Let 
j-P and 
^^ be fibrations with the same base 
category B. A fibred adjunction over B is given by fibred functors F, G in 
together with vertical natural transformations rj: idE => GF and e: FG => idp 
satisfying the usual triangular identities Ge o r]G — id and e F o FT/ = id. This 

84 
Chapter 1: Introduction to fibred category theory 
is an adjunction in the 2-category Fib(B); it obviously involves an ordinary 
adjunction [F -\G). 
(ii) A split fibred adjunction over IB is an adjunction in the 2-category 
Fibspiit(B); it consists a fibred adjunction as above in which the fibrations 
p and q are split and also the functors F and G are split [i.e. preserve the 
splitting). 
Notice that verticality of the unit 77 of an adjunction [F H G) between fibred 
functors as above implies verticality of the counit, and vice-versa. 
1.8.7. Examples, (i) Every ordinary adjunction [F H G) in: 
lifts to 
cC 
a split fibred adjunction (F 
Fam(C) 
'^ 
F 
1 
G 
'am(F) H 
Fam(F) 
H^IZ 
'^^ 
Fam(G)) over 
2^ Fam(D) 
Sets in: 
Sets 
by a pointwise construction. Essentially this follows from the 2-functoriality 
of Fam(—) in Exercise 1.7.4. 
(ii) In a similar way, the reflection 
P E R C 
^ cj-Sets 
from Proposition 1.2.7 lifts to a fibred reflection 
UFam(PER) c 
^ UFam(a;-Sets) 
cj-Sets 
again by a pointwise construction. 
(But this lifting over a;-Sets is less trivial than over Sets in the previous 
example, since one needs to check that the (pointwise defined) units and 
counits have uniform realisers.) 

Section 1.8: Fihrewise structure and fibred adjunctions 
85 
The earlier example involving fibred terminal objects for a codomain fibra-
tion can now be described for arbitrary fibrations. 
E 
1.8.8. L e m m a . A 
fibration 
-^P has a fibred terminal 
object if and only if 
the unique morphism from p to the terminal object in Fib(B) has a fibred right 
adjoint, say I, in 
I -
Proof. Assume that each fibre category E/ has a terminal object 17, and 
that these terminal objects are preserved by reindexing functors: for u: I ^ 
J 
in B one has u*{lJ) 
---> 1/ over /. Then one gets a functor 1:B ^ E, since a 
morphism u: I ^ 
J in M can be mapped to the composite II = u*{lJ) 
^ 
IJ 
over u. Thus p o I = id®. Moreover, 1 is a fibred functor in the above diagram, 
since each map Iw is Cartesian by construction. Further, there are adjoint 
correspondences 
pX — ^ 
J 
in B 
X 
^ I J 
i n E 
/ 
given by w M- (X —> IpX —)• I J ) and / i-^ pf. The resulting unit is the unique 
map \: X —^ IpX 
(which is p-vertical) and counit is the identity plJ 
^ 
J 
(which is id]B-vertical). 
Conversely, if the above functor p: p —^ id^ has a fibred right adjoint 1: B ^ 
E, then for each object / E B the object 1/ is terminal in the fibre E/ over 
/: the counit component Sj is idi-vertical and therefore an identity pll ^- I. 
Hence the transpose of a map f:X 
—>• 1/ is pf.pX 
—)• /, so that there is 
precisely one vertical map X -^ 
II. 
Further, reindexing functors preserve these fibred terminal objects: a map 
u: J ^ 
I in M is id^-Cartesian over itself; hence IwAJ 
-^ 1/ is j9-Cartesian 
over u, since 1 is by assumption a fibred functor. But by definition, also the 
lifting u{ll):u*{ll) 
-> 1/ is Cartesian over u. This yields an isomorphism 
u*{ll) 
-=^-> U , since Cartesian liftings are unique, up-to-isomorphism. 
n 
Having seen this lemma, one expects that in general the structure induced 
by a fibred adjunction is induced fibrewise and is preserved under reindex-
ing. The following result states that this is indeed the case. The preservation 

86 
Chapter 1: Introduction to fibred category theory 
is expressed by a so-called 'Beck-Chevalley condition', which may be a bit 
puzzling at first sight. We elaborate later on. 
(We should emphasise that not all fibrewise structure comes from fibred ad-
junctions. For example, a fibration may have fibrewise a monoidal structure.) 
E 
ID) 
1.8.9. Lemma. Let 
^ 
and 
^ 
he fibrations and let i7:E ^ D 6e a fibred 
functor. This functor H has a fibred left (resp. right) adjoint if and only if 
both 
(a) For each object I £ M the functor Hj.lEj —> D/ restricted to the fibres 
over I has a left (resp. right) adjoint /i (/). 
(b) The Beck-Che valley condition holds, i.e. for every map u: I -^ J inM 
and for every pair of reindexing functors 
^ 
u* 
^ 
^ 
u"^ 
^ 
Ej 
^ E/ 
D J 
^ D/ 
the canonical natural transformation 
A'(/)t/# =^ u^'KiJ) 
{resp. u*K{J) =:^ 
K{I)u'^) 
is an isomorphism. 
The lemma describes global adjunctions K H H (or H H A") in terms of 
local adjunctions K(I) H Hj (or Hi H A^(/)) which are suitably preserved by 
reindexing functors. In the local left adjoint situation: 
^ E / 
K{J)\-\\Hj 
K{I)U\HJ 
^ D / 
U^ 
the canonical map K[I)u^ 
=> u*K{J) arises as the transpose of 
u^in) 
^ 
w# 
^ t/# Hj K{J) 
^ HI U* 
K{J) 

Section 1.8: Fibrewise structure and fibred adjunctions 
87 
Alternatively, it may be described as the following (pasting) composite. 
K(J) 
Proof. First, in case /\ :D ^ E is a fibred left or right adjoint to H, then one 
obtains adjunctions between the fibres since the unit and counit of a fibred 
adjunction are vertical. For a morphism u: I -^ J in M and an object y G O 
over J G B, we get two Cartesian liftings of i< at y in a situation: 
I<(^^{y)) 
K{u{Y)) 
KY 
u*{KY) 
ii{I<Y) 
(*) 
J 
An appropriate diagram chase shows that this map K(u'^{Y)) 
-=^^ u*{KY) 
is 
the canonical isomorphism induced by the adjunction. 
Conversely, assume local adjunctions satisfying Beck-Che valley. We shall do 
the left adjoint case. We claim that for each object Z G D, say above I EM, 
the (vertical) unit component rjz'Z 
—> H{K{I){Z)) 
is a (global) universal 
map from Z to H. Indeed, for a morphism f:Z 
-^ HY 
in D, say above 
w: / -^ J in B, write / = H{u{Y)) 
o f:Z 
^ H{u*{Y)) 
-^ HY. By the local 
adjunctions K{I) 
H Hj we get a unique vertical map f":K{I){Z) 
-^ 
u'^iY) 
with H{f") 
or]z = f . Then / ^ = u{Y) o f":K{I){Z) 
^ y is the required 
unique map with H[f^) 
o rjz — f in: 
H{K{I){Z)) 
K{I)(Z) 
I 
y 
u*{Y) -
r 
u(Y) 
^ Y 

88 
Chapter 1: Introduction to fibred category theory 
The assignment Z i-> K[pZ)[Z) 
now extends to a functor / \ : D -> E, which 
is left adjoint to H (see e.g. [187, IV, 1, Theorem 2]). What remains is to 
show that K is a fibred functor. This follows because, by universality of ry, the 
triangle of the above diagram (*) commutes. 
• 
There is a similar result for split fibred adjunctions. 
1.8.10. Lemma. Let ( 
^ 
1 —y ( 
^ 
\ be a split functor 
between 
split 
fibrations. 
Then H has a split fibred left/right 
adjoint if and only if one has 
like in the previous lemma, (a) and the Beck-Chevalley 
condition 
(b), but this 
time with the canonical map being an identity. 
• 
1.8.11. Excurs on the Beck-Che valley condition. The above 
lemmas 
express that a (split) fibred adjunction corresponds to fibre wise adjunctions, 
involving adjunctions between fibres and reindexing functors preserving this 
structure. The latter is formulated by a Beck-Che valley condition, which re-
quires a certain natural transformation to be an isomorphism. We shall have 
a closer look at this condition via an example. 
Let C be an ordinary category with Cartesian products, given by a right 
adjoint x : C x C -^ C in Cat to the diagonal A : C -> C x C. The unit r}z 
is usually described as the diagonal {\Az,\dz)'.Z 
-^ Z x Z and the counit 
^(x,y) as the pair (TT, TT'): (X X Y, X X Y ) —> (X, Y) of projections in C x C. 
If D is another category with Cartesian products then one says that a functor 
F : C ^ 
D preserves these products if the pair F['KX,Y), 
F{'K'XY) 
forms a 
Cartesian product diagram in D. Put a bit difi'erently, one requires that the 
canonical map 
(F(7rx,y),F(7r^,y)) 
, . 
F{X X Y) 
^ FX X FY 
^ ' 
is an isomorphism. It arises as transpose of the pair 
(F(7rx,y),F(7r^_y)) 
(F(X 
X Y), F{X X y ) ) 
^ {FX, 
FY) 
in D X D. That is, of 
(F X F)(£(x,y)) 
{F X F){X 
xY,X 
xY) 
^ (F x 
F){X,Y) 
which is a specific case of the above general description of canonical map. We 
have thus shown that the canonical map formulation as used in the Beck-
Chevalley condition corresponds to the usual formulation of preservation for 

Section 1.8: Fibrewise structure and fibred adjunctions 
89 
Cartesian products. The correspondence is a general phenomenon, which is 
described in more detail in Exercise 1.8.7 below. 
In the above Lemma 1.8.10, dealing with split fibred adjunctions and ad-
junctions between fibres, it is required that the canonical map is the identity. 
In the example of Cartesian products, the requirement that the map (*) is the 
identity contains much more information than merely F{X xY) = FX x FY: 
it implies that [F x F){ex,Y) — ^'px FY -> where e' is the counit of the adjunc-
tion associated with the Cartesian products on D. It also implies F(T]Z) — fl'pz^ 
since 
irz 
= {^FZ,FZ,7rFz,Fz) o 
{F{idz),F(idz)) 
= 
(F(7rz,z),FK^^))oF(idz,idz) 
= 
F{idz,idz) 
= 
Firjz)-
Thus, the requirement that the canonical map (*) is an identity morphism 
leads to a so-called "map of adjunctions" (see [187]), namely from the ad-
junction (A H x) on C to the adjunction (AH x) on D, as in the following 
diagram. 
C 
/ \ 
C x C 
F X F 
A H 
- ^ D x D 
Conversely one easily establishes that if this diagram forms a map of ad-
junctions, then the canonical map (*) is an identity. Again, this holds more 
generally, as made explicit by the next lemma below. The proof is easy and 
left to the reader. 
1.8.12. Lemma. Let 
E 
H 
1 
be a split functor between split 
fibrations p and q. Then H has a split fibred left/right adjoint if and only if 
both 
(a) For each object I E M the functor 
Hj:¥.j 
over I has a left (resp. right) adjoint K{I)' 
D/ restricted to the fibres 

90 
Chapter 1: Introduction to fibred category theory 
(b) for every map u: I —^ J inM, the pair of reindexing functors 
i/*: Ej —^'Ej, 
w^:Dj ^ D / induced by the splitting, forms a map of adjunctions 
in 
Hjl 
A'(J) 
Hjl 
\K(I) 
In the sequel we shall often describe a specific fibred adjunction by a col-
lection of fibrewise adjunctions and leave verification of the Beck-Chevalley 
condition as an exercise. It usually follows in a straightforward way when the 
adjunctions between the fibres are defined in a suitably uniform manner. 
Since a fibred adjunction involves ordinary adjunctions between fibre cate-
gories it is immediate that a fibred right adjoint preserves fibred limits, and 
that a fibred left adjoint preserves fibred colimits (see e.g. [187, V, 5, Theo-
rem 1]). There are also fibred versions of the adjoint functor theorems, but 
we shall not need them and we refer the interested reader to [47] and [246]. 
They involve suitable fibred notions of generators and well-poweredness. 
Exercises 
1.8.1. 
Explain in detail what a 'fibred LCCC is. 
1.8.2. 
Let (B, T) be a non-trivial CT-structure. Prove that the associated simple 
s(T) 
fibration 
i 
has a fibred terminal object if and only if the collection of 
B 
types T contains a terminal object (in B). 
1.8.3. 
(i) 
Prove that a category with Cartesian products has distributive coprod-
ucts (see Exercise 1.5.6) if cind only if its simple fibration has fibred 
(distributive) coproducts. 
(ii) And similarly, that a category with puUbacks has (finite) universcil 
coproducts if and only if its codomain fibration has fibred (universal) 
coproducts. 
E 
1.8.4. 
Show in detail (as in Lemma 1.8.8) that a fibration -j^P has fibred Carte-
B 
si an products x if cind only if the diagonal A:p —)• p x p in Fib(B) has a 
fibred right adjoint. 
E 
P 
1.8.5. 
Consider fibrations -^P and -^^ together with a (not necessarily fibred) 
functor F: E -> D with right adjoint G such that (a) qF = p and pG = g, 
and (b) the unit and counit of the adjunction (F -\ G) are vertical. Prove 
that G is then a fibred functor. 

Section 1.8: Fibrewise structure and fibred adjunctions 
91 
[Hint. For a short proof, use Exercise 1.1.2, but see also [344, Lemma 4.5].] 
1.8.6. 
Let SignVar be the category of 'signatures with variables' obtained in the 
following change-of-base situation, 
SignVar 
^ Fam(Sets) 
Sign 
>- Sets 
i-i 
Thus an object of SignVar is a many-typed signature Z) together with a 
IE[-indexed collection X = (X<T)«r6|i;| °f sets (of variables). Show that the 
term model assignment 
(E,X)h->(Termsr(X)) 
described in Example 1.6.5 extends to a left adjoint to the forgetful functor 
S-Model -^ SignVar which sends a model (E, (ACT), I-l) to (E, (ACT)) in 
SignVar 
S-Model 
Sign 
Check that it is not a fibred adjunction (as noted by Meseguer). 
1.8.7. 
Consider two adjunctions in the following (non-commuting) diagram. 
K 
c 
^c 
F\-i]G 
F' 
HlG' 
D 
^ID/ 
Following [157] we say that a pseudo-map of adjunctions from (F H G) 
to {F' H G') consists of a pair of functors K: C -^ C , L:D -^ D/ together 
with natural isomorphisms ip: F'K ^ 
LF and ip: G'L ^ 
KG satisfying 
ipF 0 G'if 0 T]'K = Krf and Le o (pG o F'xf) = e'L, where r/, e and r/', e' are 
the unit and counit of the adjunctions [F -\ G) and [F' H G'). 
[A map of adjunctions, as defined in [187], has (^ = id and ^ = id. But 
see also loc. cit. Exercise IV 7 4, where there is a weaker notion (due to 
Kelly—with natural transformation ip and ^~^ as above, except that they 
need not be isomorphisms.] 
(i) 
These isomorphisms (/? and ^ turn out to determine each other: given 
an isomorphism F'K 
= LF, show that one ol^tciins a pseudo-map 

92 
Chapter 1: Introduction to fibred category theory 
of adjunctions if and only if the canonical map KG => G'L is an 
isomorphism. The latter is obtained by transposing F'KG = LFG => 
L. 
(ii) Formulate and prove a dual version of (i). 
(iii) Show that a result like Lemma 1.8.12 can be obtained for arbitrary 
(non-split) fibrations with 'map of adjunctions' in (b) replaced by 
'pseudo-map of adjunctions'. 
E 
1.8.8. 
Let JI be a category (thought of as index) and 
j^P be a fibration. 
(i) 
Show that the composition functor (p o — ):E —)• tf between functor 
categories is a fibration. 
Let (^: B -^ ff be the diagonal functor which maps / G B to the constant 
functor J -^ B that maps everything to / {i.e. the exponentiad transpose of 
the projection B x J -^ B). Form the exponent fibration p by change-of-
base, 
B xm E^ 
P' 
> 
J 
1 
^ E J 
\ 
(po 
' 
(ii) Describe the resulting fibred diagonal functor A:p —)• p over B. 
(iii) Show that the fibration p has fibred limits (resp. colimits) of shape J 
if cind only if this A has a fibred right (resp. left) adjoint, 
(iv) Give a similar analysis for split (co)limits. 
1.8.9. 
Exponents in an ordinary category can be described in terms of adjunctions 
involving a parameter, see [187]. This approach does not generalise readily 
to fibred categories. We sketch an alternative approach, as taken in [157]. 
Let C be a category with Cartesian products, say described by the functor 
x: C X C —> C. Write |C| for the discrete category underlying C, of objects 
only. We extend the Cartesian products to a functor prod: |C| x C —)• |C| x C 
by {X,X')y^{X,X 
x X'). 
(i) 
Check that the category C has (chosen) exponents if and only if this 
functor prod has a right adjoint. 
E 
(ii) Show that for a fibration -j^P with Cartesian products, one can define 
IB 
in a similcir way a fibred functor prod: |p| x p —> \p\ xp, where \p\ is the 
object fibration associated with p, as introduced in Exercise 1.1.4. 
(iii) Prove now that such a fibration p has fibred exponents if and only if 
this functor prod has a fibred right adjoint. 
E 
(iv) Assume next that 
j ^ is a split fibration with split Cartesian prod-
ucts. Write Split (E) for the subcategory of E with cirrows obtained from 

Section 1.9: Fibred products and coproducts 
93 
Split (E) 
the splitting and 
J'IIPII for the resulting split fibration. Show that p 
B 
has split exponents if and only if the spht functor prod: ||p|| xp —)• ||p|| xp 
has a split fibred right adjoint. 
[For a split fibration p, ||p|| (instead of |p|) is the appropriate fibration 
of objects of p.] 
1.8.10. Definition 1.8.6 describes adjunctions in the 2-category Fib(]B) for a fixed 
base category B. One can also consider adjunctions in the 2-category Fib 
of fibrations over arbitrary bases. 
(i) 
Describe such adjunctions in Fib in detail. 
(ii) Recall from Exercise 1.7.1 that the category Fib has Cartesian prod-
ucts. Show that a fibration p has fibred Cartesian products plus 
Cartesian products in its base category if and only if the diagonal 
A:p —)• p X p in Fib has a right adjoint in Fib, i.e. if p has Cartesian 
products in Fib. 
1.8.11. 
In this exercise we relate adjunctions in Fib( —) and adjunctions in Fib, 
E 
following [125-127]. Consider a fibration ^P and a functor F: A -)- B. 
(i) 
Show that a (ordinary) right adjoint G: B —)• A to F induces a right 
adjoint in Fib to F*{p) -^ p. 
[Hint. For X G E above / G B, consider the pair {GI,e*{X)) 
in the 
total category Ax]^ E of F*(p), where e is the counit of the adjunction 
(F H G).] 
ED 
(ii) Assume now that F has a right adjoint G. Let 
j ^ also be a fibra-
tion and let F':D —)• E form together with F: A —)• B a morphism 
(F, F'): q ^ p in Fib. Show that there is a right adjoint (G, G'):p —>• q 
in Fib to (F, F') if and only if there is a right adjoint in Fib(A) to the 
induced functor q -> F*{p). 
1.9 Fibred products and 
coproducts 
In the previous section we have studied structure inside the fibres of a fi-
bration. Now^ we move to structure between the fibres, given by adjoints to 
(certain) substitution functors. It will be described as fibred products Yl and 
coproducts ]J. 
Two forms of such quantification Yl^U ^^'' ^^ discussed in this section: 
the first one is "simple" quantification along Cartesian projections in a base 
category, and the second one is quantification along arbitrary morphisms (in 
a sense to be made precise). These two forms of quantification will turn out 
to be instances of a general notion, to be described in Section 9.3. For the 
moment we are satisfied with elementary descriptions. 

94 
Chapter 1: Introduction to fibred category theory 
Recall that an ordinary category C has set-indexed products if for every set 
/ and every /-indexed collection {Yi)i^j of objects in C, there is a product 
object Yliei ^' ^^ ^' ^^^ differently, if each diagonal A/: C ^ C^ has a right 
adjoint Ylj (using the Axiom of Choice). We can express this also in terms of 
Fam(C) 
the family 
fibration 
4- 
on C The category C^ is isomorphic to the fibre 
Fam(C)/ over / and the diagonal A/ is the composite 
It 
C ^ Fam(C)i — ^ Fam(C)/ ^ C^ 
where 1} is the reindexing functor associated with the unique map !/: / —->• 1. 
Thus, set-indexed products in C can be described in terms of right adjoints to 
Fam(C) 
certain reindexing functors of the family fibration 
i 
on C. It is precisely 
E 
this aspect which is generalised in the present section: in a fibration 
^P the 
objects and morphism in the total category E are understood as indexed by 
B. Thus right adjoints to reindexing functors !J (for / G B) will yield suitably 
generalised products of an /-indexed collection X G E/ in the fibre over /. In 
this way one defines quantification with respect to an arbitrary base category 
B—and not just with respect to Sets. This leads to a truly general theory of 
quantification, which finds applications later on in describing V, 3 in logic and 
n, E in type theory. 
Actually, it will be more appropriate to describe quantification in terms 
of adjoints to reindexing functors TT* induced by Cartesian projections 
TT: I X J -> /, instead of just to !}. The latter then appear via projections 
TT: 1 X / —-> 1. Such a description involves quantification with a parameter. 
E 
1.9.1. Definition. Let B be a category with Cartesian products x and j^P 
be a fibration. We say that p has simple products (resp. simple coprod-
ucts) if both 
• for every pair of objects /, J G B, every "weakening functor" 
E/ 
^ E / x j 
induced by the Cartesian projection TTJJ:! 
X J -^ I, has a right adjoint 
0(7,J) (resp. a left adjoint IJ(/,j)); 
• the Beck-Che valley condition holds: for every u: K -^ I inM and J G B, in 

Section 1.9: Fibred products and coproducts 
95 
the diagram 
E/ 
^ EK 
'-., ( ) 
'- {) 
E/xJ 
^ E K X J 
{u X id)* 
the canonical natural transformation 
^* Il{i,j) 
=^ UiK,j) 
(^ X id)* 
(resp. U(K,J) (^ X id)* = > ^* LJ(/,J) ) 
is an isomorphism. 
Later, in Section 9.3, this form of quantification will be described in terms 
of simple fibrations. That is why we call this 'simple' quantification. As in the 
previous section, the Beck-Chevalley condition guarantees that the induced 
structure is preserved by reindexing functors (and hence that it is essentially 
the same in all fibres). This Beck-Chevalley condition is not a formality: it 
may fail, see Exercise 1.9.10 below. Recall from Example 1.1.1 (iii) that we 
call functors of the form TT* 'weakening functors' because they add a dummy 
variable. 
One can formulate appropriate versions of quantification (in Definition 1.9.1 
above and also in Definition 1.9.4 below) for split fibrations. The canonical 
isomorphism mentioned in the Beck-Chevalley condition is then required to 
be an identity (for the adjoints to the reindexing functors induced by the 
splitting). 
The next result shows that the above simple quantification gives us what 
we expect in the situation of the standard fibration over sets. 
1.9.2. Lemma. For an arbitrary category C one has: 
Fam(C) 
the family 
fibration 
i 
has (split) simple 
products/coproducts 
^ 
C has set-indexed 
products/coproducts. 
Proof. We shall do the case of products. 
(<=) For sets /, J one defines a product functor J^/^ jxi Fajn(C)/xj 
-> 
Fam(C)/ by 
Then one obtains the following isomorphisms, establishing an adjunction 

96 
Chapter 1: Introduction to fibred category theory 
^I,J ~^ U{I,J)' 
Fam(C)/x J {n}j{{Xi)i^i), 
{Y(^i,j))(i,j)eixj) 
= Fam(C)/xj((Xi)(ij)g/xj, 
{y{i,j)){i,j)eixj) 
= 
n 
c(x,, y(,-,-)) 
(i,j)eixJ 
- n n c(^n Y^ij)) 
i€l 
jeJ 
S 
Fam(C)/((X,)ig/, 
n(/,j)((>'(ij))(i,i)€/xj)). 
Beck-Chevalley holds, by an easy calculation. 
(=>) Let 1 be a one-element, terminal set. For each set /, the diagonal 
functor A/: C —> C^ is the composite, 
C ^ Fam(C)i 
^ Fam(C)ix/ = C ^ 
Since this weakening functor TT^ J has a right adjoint Y[(i /)? ^ilso the diagonal 
A/ has a right adjoint. Thus C has /-indexed products, for each set /. 
• 
1.9.3. Proposition. Let IB 6e a category with finite products. 
s(B) 
(i) The simple 
fihration 
4- 
on B always has simple 
coproducts. 
(ii) And it has simple products if and only ifM is Cartesian 
closed. 
Proof, (i) For a projection n: I x J —^ I we can define a coproduct functor 
U(/..) 
s(B)/x J = M//(I X J) 
^ M//I = s(M)i 
between the corresponding simple slices hy X >-> J x X, since: 
! / / ( / X J){x, 
n*(Y)) 
S ! ( ( / X J) X X, 
Y) 
S l ( / x (JxX), 
y) 
(ii) If the category IB is Cartesian closed, we can define a product functor 
Y[^jjyM//{I 
X J) -> M//I by X ^ J ^ X. This yields simple products. And 
conversely, if the simple fibration has simple products, then B is Cartesian 
closed by Exercise 1.3.2 (ii), because each functor /*:B -^ M//I has a right 
adjoint (since it can be written as composite B = B / 1 - ^ W/^)- 
^ 

Section 1.9: Fibred products and coproducts 
97 
We turn to the second "non-simple" form of quantification; it does not deal 
with quantification solely along Cartesian projections, but along all morphisms 
in a base category. 
E 
1.9.4. Definition. Let B be a category with pullbacks and 
a fibration 
on M. One says that p has products (resp. coproducts) if both 
for every morphism w: 7 ^ J in IB, every substitution functor u*:Ej -^ E/ 
has a right adjoint Ylu (resp. a left adjoint U^); 
the Beck-Chevalley condition holds: for every pullback in IB of the form 
• 
• 
u 
the canonical natural transformation 
* * n . ^ n . ^* 
(resp. U . r * = : > . * U J 
is an isomorphism. 
It is easy to see that this second form of quantification is really an extension 
of the earlier 'simple' one. If one has quantification along all morphisms, then 
in particular along Cartesian projections; and the Beck-Chevalley condition 
holds since for every u: K ^f- I and J ^ B the following diagram is a pullback. 
t/ X id 
K X J 
>- I X J 
J 
-^ / 
We emphasise that the simple form of quantification is described in terms 
of adjoints to weakening functors TT* (induced by Cartesian projections TT) 
and the subsequent one in terms of adjoints to arbitrary substitution functors 
u*. The latter is the formulation first identified by Lawvere in [192]. For the 
quantifiers V, 3 in logic and 11, E in simple or polymorphic type theory, it 
suffices to have quantification along projections. But in dependent type theory 
the above Cartesian projections will have to be generalised in a suitable way 
to 'dependent' projections, see Section 10.3. 
Equality can be captured in terms of (left) adjoints to contraction functors 
S* induced by diagonals J, see Chapter 3. 

98 
Chapter 1: Introduction to fibred category theory 
It is probably worth noting the following. Adjoints are determined up-to-
isomorphism, so the left and right adjoints ]J-^ and ]^j^ to an identity substi-
tution function id* = id are themselves (naturally) isomorphic to the identity: 
]J.^ = id = Ylid' ^^^ composable maps v.uin 
the base category, there is an 
isomoporphism {v o u)* = t/* o v*, see Section 1.4. It leads to isomorphisms 
Uvou -Uv 
'>Uu and n^oti -Uv 
""Uu since adjunctions can be composed, 
see [187, Chapter IV, 6 8]. 
Our first example of this second form of quantification again involves fam-
ily fibrations. It extends Lemma 1.9.2. Notice the explicit use of equality in 
the definition of Yiu in the proof. It returns in more abstract form in Exam-
ple 4.3.7. 
1.9.5. Lemma. Let C be an arbitrary category. Then: 
Fam(C) 
the family 
fibration 
I 
has (split) products/coproducts 
<=> C has set-indexed 
products/coproducts. 
Proof. The interesting part is the implication (<:=). For u: I ^ 
J m Sets 
define product and coproduct functors flw Uw* ^ani(Q/ ^ Fam(C)j by 
UFam(PER) 
1.9.6. Lemmia. The 
fibration 
i 
of PERs over uj-sets has both prod-
CJ-Sets 
ucts and coproducts (along all maps in cj-Sets^. 
Proof. This follows in fact from the fibred reflection UFam(PER) 
^ 
UFam(u;-Sets) c:^ cj-Sets"*' over u;-Sets in Proposition 1.8.7 (ii), using the 
reflection lemma 9.3.9 later on. Here we give the explicit formulas: for a mor-
phism u\ {I,E) -^ {J, E) in cj-Sets and a family R = {Ri)ie{l,E) over {I,E) 
we get a product and coproduct over (J, E) by 
lUR)j 
= {{n,n')\'iieLu{i)=j 
^ 
ym,m' e E{i).n - ruRiu' - m'} 
where r is the left adjoint to the inclusion PER M- c<;-Sets, and E is the 
existence predicate on the disjoint union U^^/n-j N/iZ,- given by E{i, [n]R^) = 
{(n, n') \ne 
E(i) and n' E Mil J . 
D 
The following result is often quite useful. The proof is left as an exercise. 
1.9.7. Lemma. Consider a fibration for which each reindexing functor has 
both a left JJ and a right Y\ adjoint. Then Beck-Chevalley holds for coproducts 
W if and only if it holds for products f|. 
D 

Section 
1.9: Fibred products 
and 
coproducts 
99 
The next result for codomain fibrations is the analogue of Proposition 1.9.3 
for simple fibrations. The third point is due to Freyd [83]. 
1.9.8. Proposition. For a category B with finite limits, the codomain fibra-
tion 
i 
on M has 
1 
(i) coproducts U^; they are given by composition; 
(ii) simple products Y\(i j) if cind only ifM is Cartesian closed; 
(iii) products Y[u if and only ifM is locally Cartesian closed. 
Proof, (i) For u: I ^ J one defines a coproduct functor Uu* W-^ ~^ W*^ ^y 
(X A 
/) H^ (X ""A^ j ) 
and 
fipl^jp] 
^ f{u oip)^{uo 
V^) J . 
The adjunction (JJ^ H u*) then follows from the bijective correspondence 
between maps /: ]J^ (p -^ ip over J and g:(p -^ ^*(V^) over / in: 
Beck-Chevalley follows from the Fullback Lemma (see Exercise 1.1.5). 
(ii) The proof is essentially as in Exercise 1.3.3, except that we have to deal 
with an extra parameter object. In case B is Cartesian closed we can form a 
/ X \ 
simple product of a family I r ^ 
1 over I x J along a projection TT: I x J -^ I 
as the family 
I J over /, in the pullback diagram: 
Ylii,j)M 
J 
^ 
j=^[lxj) 
A(id/xj) 
Informally, P consists of the pairs (i,/) with <p{f{j)) = (i^j), for all j . 

100 
Chapter 1: Introduction to fibred category theory 
Conversely, if the codomain fibration has simple products, then in particular 
each functor /*:B -> IB// has a right adjoint. Hence B is Cartesian closed by 
Exercise 1.3.3. 
(iii) If B has finite limits, then each slice B// has finite products. Hence 
B is an LCCC O 
each slice B// is Cartesian closed 
<^ for each object w: J ^ / in B//, the functor 
w*:B// —>(B//)/t/ =:B/J 
has a right adjoint f|^ (see Exercise 1.3.3) 
<^ the codomain 
fibration 
^ 
has products W^. 
This last step is justified by the fact that Beck-Chevalley always holds by the 
previous lemma. 
• 
For an explicit formulation of the Cartesian products and exponents in the 
slices B / / in terms of ]J and f^, see Exercise 1.9.2 below. 
1.9.9. Corollary. If a category M with finite limits is Cartesian closed/locally 
Sub(l) 
Cartesian closed, then its subobject fibration I 
has simple/ordinary prod-
ucts Yl-
Proof. Since right adjoints f| preserve monos, they restrict to functors be-
tween (posets of) subobjects. 
• 
The following result tells how simple and ordinary products are related. It 
shows that ordinary products are simple products relativised to all slices of 
the base category. This is sometimes called localisation, see e.g. [246]. 
E 
1.9.10. Theorem. Let 
-^P be a fibration on a base category B with pull-
backs. For each object / G B, write I* {p) for the fibration obtained by change-
of-base in 
M/I x i E 
^ E 
J 
r{p)=dom}{p) 
dom/ 
Then p has (ordinary) products Ylu ^f ^^^ ^^h ^f ^^^^ fibration I* (p) has 
simple products Yl{v,w)' 
A similar result holds for coproducts ]J. 

Section 
1.9: Fibred products 
and 
coproducts 
101 
Proof. Assume p has products Yiu ^long an arbitrary morphism u in B. Let 
v: K -^ I and w: L -^ I he objects of the slice M/I and consider their pullback 
K XT L 
TTl 
^ L 
TTO 
V X W 
^ I 
A simple product Y[(y w) ^l^ng the Cartesian projection TTQ: v x w —> v in M/I 
is then given by 
As a result of the Beck-Chevalley condition for products in p one gets in /* (p) 
that for u: J -^ K, 
where AQ is the first projection {v o u) x w ^ 
(v o u) in M/I. This is the 
appropriate formulation of Beck-Chevalley for simple products. 
Conversely, assume that each fibration /*(p) has simple products. Then 
for a map u: J ^ 
I in M, the fibration P {p) has a product Yl^ along the 
'projection' \u = u:u —-> id/ in M/I. Beck-Chevalley also holds: for v: K -^ I 
consider the following pullback square in 
v' — \y X id 
V X U 
^ U 
v^{u) J 
I — 
= u 
id. 
It yields i;* Hu - X\v*{u) ^'* ^^ required. 
D 
1.9.11. Definition. A fibration is called complete if it has products Y\u 
and fibred finite limits. Dually, a fibration is cocomplete if it has coproducts 
W^ and fibred finite colimits. 
The codomain fibration associated with a locally Cartesian closed cate-
gory is thus complete. And fibrations that we know to be equivalent to 
Fam(Sets) 
UFam(U;-Sets) 
codomain fibrations of LCCCs are complete, like 
i 
, 
i 
and 
Sets 
CJ-Sets 
UFam(PER) 
UFam(PER) 
i 
. Also 
i 
is complete, see Lemma 1.9.6. And the family 
P E R 
CJ-Sets 
fibration of a complete category is complete. 

102 
Chapter 1: Introduction to fibred category theory 
Ordinary categories are complete in case they have arbitrary products and 
equalisers. Above we have required all finite limits instead of just equalisers. 
Under certain technical assumptions, it is possible to obtain fibred finite prod-
ucts from products Yl^ and fibred equalisers, so that we get all fibred finite 
limits, see Exercise 9.5.11. But in general it is more convenient to require 
explicitly the presence of all fibred finite limits. 
In Section 7.4 it will be shown how every small diagram in a complete 
fibration has a limit. The diflficulty in getting such a result lies in saying what 
a small diagram in a fibred category is. 
The following technical result will be used frequently in the categorical de-
scription of logics and type theories. It deals with distribution of coproducts 
]J over Cartesian products x in the fibres. It is a generalisation of the distri-
bution of V over A in a frame, see Exercise 1.9.6. In logic it corresponds to the 
equivalence of 3x: a. {(fAip{x)) and (f A 3x: a. V^(ar), if x does not occur free in 
(f. It also occurs as an equivalence between z/x. (P || 7r*{Q)) and {i/x. P)\\Q in 
process theory, where u is restriction and || is parallel composition, see [219]. 
E 
1.9.12. Lemma (Frobenius). Let 
iP be a fibred CCC. 
(i) Suppose p has simple coproducts. For each pair of objects /, J G B in 
the basis and each pair of objects Y GlKj, Z GlKjxj in appropriate fibres, the 
canonical morphism 
Uii.j)i^lj(Y) 
X Z) 
^ Y X 
Uii,j)iZ) 
is an isomorphism. 
(ii) Suppose now p has coproducts. Then for each u\ I ^ J tnM, Y E¥.J 
and Z E^i, 
the canonical morphism 
U„(«*WxZ) 
^YxUJZ) 
is an isomorphism. 
Proof. We do only (i). First of all, the Frobenius map is obtained as transpose 
of the composite 
n}^j(Y) X Z 
"^""l^ 
, ^*JY) 
X 7r}^j(U^ij^(Z)) 
^},Ay 
X 
Uii,j)iz)). 

Section 1.9: Fibred products and coproducts 
103 
It is an isomorphism by Yoneda: 
Uii,j)(^*i,jiy) 
X z) — ^ 
w 
IT} AY) X Z 
^ 
7r},(W) 
- ^lAY) 
^ ^},jm 
= 7T*jAY => W) 
U(i,j)(Z) 
^Y 
^W 
Y X Uii,j)(Z) 
W 
• 
Notice that the Frobenius map is an isomorphism because reindexing func-
tors preserve exponents. Even if there are no fibred exponents around, the 
Frobenius map can still be an isomorphism. In that case we shall speak of 
(simple) coproducts with the Frobenius property, or briefly, of (sim-
ple) coproducts satisfying Frobenius. 
Finally we should also say what it means for a morphism of fibrations to 
preserve the above (simple) products and coproducts. 
/ E X 
,^^. 
f ^ 
\ 
1.9.13. Definition. Let ( 
^P 1 —^ 
( 
j - ^ 1 be a morphism of fibra-
tions. 
(i) Assume that p and q have simple products (resp. coproducts). Then 
(/\, L):p -^ q preserves simple products (resp. coproducts) if both 
• K:M -^ A preserves binary products, say with 7 / j as inverse of the canon-
ical map K{I X J) -> KI x KJ] 
• for each pair I, J EM, in 
TT 
E/ 
^ OKI 
^KI,KJ 
^K(/xJ) 
^^KIxKJ) 
the canonical natural transformation 
^ ii{I,J) 
= ^ Y[{KI,KJ) 
7/,J ^ 
(resp. U{KI,KJ) 7/*,j H=> H U(/,j) ] 
is an isomorphism. 

104 
Chapter 1: Introduction to fibred category theory 
(ii) Assume now that p and q have products (resp. coproducts). The map 
{K,L):p 
-> q preserves products (resp. coproducts) if both 
• K:M -^ A preserves pullbacks; 
• for every w: / -^ J in IB, the canonical natural transformation, 
HUu^ 
UKU H 
(resp. ]1KU H =^ 
H W^ ) 
is an isomorphism. 
This notion occurs in the following useful lemma on quantification and 
change-of-base. 
E 
1.9.14. L e m m a . Let 
^P he a fibration and K:A -> IB a finite limit (prod-
uct) preserving functor. 
Then 
p has (simple) 
products/coproducts 
=> /i * [p] has (simple) 
products/coproducts. 
Moreover, 
the morphism 
of fibrations K*{p) —> q preserves 
these. 
• 
Fam(Sets) 
1.9.15. Example. By Lemma L9.5 the family fibration 
i 
has both 
Sign 
products and coproducts. Hence also the fibration 
i 
of many-typed signa-
Sets 
tures has products and coproducts, because it is obtained by change-of-base, 
see Definition L6.1, and because the functor T i-> 7^ x T preserves pullbacks. 
Sign 
Fam(Sets) 
The morphism of fibrations 
i 
-^ 
I 
then preserves these induced 
Sets 
Sets 
products and coproducts. 
Exercises 
1.9.1. 
Fill in the details of the proof of Lemma 1.9.5 and pay special attention to 
the Beck-Che valley condition. 
1.9.2. 
Assume IB is a category whose codomain fibration 
4- 
is complete. By 
]B 
Proposition 1.9.8 (iii) we know that B is then locally Cartesian closed. Show 
that for objects ip, tp in the slice B / / , the Cartesian product and exponent 
are given by the formulas: 
^><^ = u^'p*w 
^^^ 
^ ^ ^ = ^c^^*(^)• 
l.9.3. 
Conclude from Propositions 1.9.3 (ii) and 1.9.8 (iii) that (finite) coproducts 
are automatically distributive in a CCC, and universal in an LCCC. 
1.9.4. 
(i) 
(Lawvere [193], p.6) Show that Lemma 1.9.12 (ii) can be strengthened 
in the following way. Consider a fibration with fibred finite products 

Section 
1.9: Fibred products 
and coproducts 
105 
and coproducts ]J^, in which each fibre category has exponents. Then: 
the Frobenius property holds 
4^ 
reindexing functors preserve exponents. 
(ii) Assume B has finite limits; show that the codomain 
fibration 
i 
has coproducts satisfying the Frobenius property. 
(iii) Conclude from (i) and (ii) that if B is locally Cartesian closed {i.e. every 
slice is Cartesian closed), then the codomain fibration on B is Cartesian 
closed. This fills the gap in Example 1.8.3 (iv). 
E 
1.9.5. 
Let a 
fibration 
-^P have coproducts ] J . Prove that for a mono m: I' >—^ I 
in B the coproduct functor J J ^ ^ E / / -^ E/ is full and faithful. 
[Hint. Write the mono in a puUback square, and use Beck-Che valley.] 
1.9.6. 
Let C be a category with finite products and set-indexed coproducts. The 
Fam(C) 
family 
fibration 
4- 
then has fibred finite products and (simple) coprod-
Sets 
ucts. Show that the Frobenius property holds if and only if the coproducts 
in C are distributive {i.e. if functors X x ( —): C -> C preserve coproducts: 
the canonical maps ]J^(A' x Yt) —)• X x (]J^^t) are isomorphisms). 
Fam(A) 
[Especially, for every frame A the family 
fibration 
i 
has fibred finite 
products and coproducts satisfying Frobenius.] 
E 
1.9.7. 
Let 
i-P be a fibred CCC with simple products and coproducts. 
M 
(i) 
Show that for X G E/x j and y G E/ there is an isomorphism over / 
(U,/,.)^)=^^ = n(/,,)(-^^^*m) 
[Recall from logic the equivalence of ((3x: a. (p) 3 ?/>) and (VJ;: a. {ip 3 
xp)) if X is not free in ip.] 
(ii) Formulate and prove a similar result for non-simple coproducts JJ 
and products Y[ • 
1.9.8. 
Let B be an LCCC. Describe the associated coproduct ] J and product J][ 
along morphisms in B as fibred functors in a situation: 
1.9.9. 
Let B be an LCCC. Show that complete distributivity (or the Axiom of 

106 
Chapter 1: Introduction to fibred category theory 
Choice, see Exercise 10.2.1) holds: the canonical map 
is an isomorphism—where u' is the pullback of u along ]~Iu('^) ^^^ ^ ^^ *'^^ 
counit of the adjunction ( w * H n )^t<^. 
1.9.10. Let Dcpo be the category of directed complete partial orders (dcpos) and 
(Scott-)continuous functions. A subset ^ of a dcpo X is Scott-closed if A 
is a lower set closed under directed joins. (This means that A is closed in 
the Scott topology on X.) 
(i) 
Define a fibration of Scott-closed subsets (ordered by inclusion) over 
Dcpo. 
(ii) Show that a left adjoint W>^ y^ along a projection T::X xY 
-> X 
exists and is given by 
Ay^{xeX 
\3y£Y.{x,y)eA} 
where (•) is Scott-closure, 
(iii) Show that in case Beck-Che valley would hold, one would get 
^^LI(x,y)(^) ^ 
3yGy.(x,y)G>l 
i.e. that {x ^ X \3y ^Y. (x^y) G A} is already Scott-closed. 
[Hint. Consider the pullback oi n: X x Y —^ X and x:l —^ X.] 
(iv) Check that the latter is not the case: consider X = N U {oo} with the 
usual total order of N plus a top element, and Y = N U {oo} with 
discrete order. Take A = {{x,y) G N x N | a ; <i^ y} C X x Y , where 
<I^ is the usual order on N. 
[This gives an example where one has left adjoints to 7r*'s but no Beck-
Chevalley. This example (or counter example) is due to Pitts (see also [61, 
Chapter 1, Exercise (7)].] 
1.9.11. 
In Exercise 1.2.13 one finds that a category C has set-indexed coproducts 
if and only if the unit C -^ Fam(C) has a left adjoint. We describe an 
analogue of this result (due to Benabou) for fibred categories. 
E 
Let 
^P be a fibration, where IB has puUbacks. Define the fibration Fam(p) 
to be the composite cod o dom*(p) in 
^ 
Famp(E) 
^ E 
Fam(p) 
dom*(p) 
dom 
P 
cod 
and define r/p:E -^ Famp(E) = 1 " ^ X]B E by X H^ (idpx, X). 

Section 1.10: Indexed categories 
107 
(i) Show that rjp is a fibred functor p —>• Fam(p). 
(ii) Prove that p has coproducts if and only if rip has a fibred left adjoint. 
1.10 Indexed 
categories 
We recall from the first section 1.1 that there are two ways of describ-
ing /-indexed families of sets: (a) pointwise indexing via indexed collections 
{Xi)i^j, or (b) display indexing via functions ( ^ ) • The collection in (a) may 
be described as a functor from the discrete category / to Sets. Equivalently 
as a functor / ° P —> Sets. It has been shown that (a) and (b) are essentially 
the same for sets. 
The reader may already have noticed that similar descriptions exist for 
indexing of categories: one has (a) indexed categories W^ -^ Cat and (b) 
E 
fibrations 
jrP ^ giving pointwise and display indexing for categories. Propo-
JB 
sition 1.4.5 describes how to go from (b) to (a)—for a cloven fibration—by 
mapping an object / of the base category B to the fibre category E/ over 
/. In this section one finds the so-called 'Grothendieck construction' which 
establishes a passage in the reverse direction from (a) to (b). It occurs in 
Grothendieck's original paper [107] on fibred categories. 
A discussion on fibrations versus indexed categories is included. 
1.10.1. Definition (Grothendieck construction). Let ^ : B ° P -^ Cat be an 
indexed category. The Grothendieck completion f^i"^) 
(or simply J ^ ) of 
^ is the category with 
objects 
(/, X) where / G B and X G ^(/). 
morphisms 
{^,X) -^ {J^^) ^r^ pairs (w,/) with u: I -^ J in B and 
f:X 
^ u*{Y) = ^(t/)(y) in ^(/). 
Composition and identities in /^(^) involve the isomorphisms r} and /i from 
Definition 1.4.4. The identity (/,X) -^ {I,X) in / ^ is the pair (id,7//(X)), 
where /// is the natural isomorphism id^(/) -=> (id/)*. And composition in J ^ 
of 
(I,X) 
^ 
'-^ 
(J,Y) 
> (K,Z) 
i.e. of 
I -
X 
^ J 
u*{Y) 
and 
J 
Y 
-* K 

108 
Chapter 1: Introduction to fibred category theory 
is defined as 
u 
V 
I 
^ J 
^ K 
X 
- — t/*(y) — - - - u^v'{Z) 
= — - {v o uY{Z) 
J 
u*{g) 
f^u,v{Z) 
The required equalities for identity and composition follow from the coher-
ence diagrams in Definition 1.4.4. In fact, these coherence conditions capture 
precisely what is required for J ^ to be a category. 
1.10.2. Proposition, (i) The first projection 
I 
is a cloven fibration. It is 
split whenever the indexed category ^ is split. 
(ii) Turning a cloven fibration first into an indexed category (as in Proposi-
tion 1.4-5) and then again into a fibration yields a fibration which is equivalent 
to the original one. 
(iii) Also, turning an indexed category first into a fibration and then into an 
indexed category yields a result which is "essentially the same" as the original. 
Proof, (i) For u: I ^ J in M and Y £'^{J) 
there is a cleavage 
(if, id) 
{i,u^{Y)) 
- ( j , y ) 
-^ J 
(ii) Easy. 
(iii) In order to make the statement precise one first has to introduce a 
notion of equivalence for indexed categories. We leave this to the meticulous 
reader. Below one does find the appropriate notions for split indexed cate-
gories. 
D 
Fam(C) 
1.10.3. Examples, (i) The family 
fibration 
i 
arises by applying the 
Grothendieck construction to the split indexed category Sets^^ -^ Cat given 
b y / H - > C ^ 
(ii) The previous example can be extended to categories in the following 
way. For a fixed category C one obtains a split indexed category Cat"^P -> Cat 
by A H^ [the functor category C^]. The resulting split fibration will be written 
Fam(C) 
as 
i 
and called the family fibration over Cat. 
Cat 
"^ 

Section 1.10: Indexed categories 
109 
(iii) For a category B with finite products, one gets a split indexed category 
IB°P -> Cat by mapping / G B to the simple slice category M//1. The resulting 
s(B) 
fibration is the simple fibration 
i 
on B. 
(iv) For a category B with explicitly given pullbacks, the assignment / H-> 
B / / extends to an (in general non-split) indexed category W^ —> Cat. Its 
B~^ 
associated fibration is the cloven codomain 
fibration 
i 
Later on in this section, these latter two type theoretic fibrations will reap-
pear in connection with indeterminates. 
1.10.4. Discussion. We have seen that the two ways (a) (= pointwise) and 
(b) (= display) of indexing sets (and the associated pictures) as described in 
Section 1.1 extend to categories: indexed categories correspond to pointwise 
indexing (a) and (cloven) fibrations to display indexing (b). In the following 
comparison of these two forms of indexing (for categories), we shall discuss 
one conceptual diff'erence and a number of technical diff'erences. 
(i) The notion of indexed category involves some explicit 
structure 
(namely reindexing functors and mediating isomorphisms id -=>• id* and 
u* o v"" ^ 
[v o uY in Definition 1.4.4), which is left implicit in 
fibrations. 
So an indexed category has a structure 
where a fibration has a property. 
The 
defining property of a fibration determines such structure once a choice of 
cleavage has been made, see Section 1.7. In general in category theory one 
prefers properties to structures. 
We mention the following two disadvantages of working with explicit rein-
dexing functors and mediating isomorphisms. 
(a) It means that one has to check every time explicitly whether a property 
is intrinsic 
or not, i.e. whether or not it depends on the specific structure. For 
instance, in the indexed category / i-> B / / in Example 1.10.3 (iv) above, each 
reindexing functor (given by pullback) has a left adjoint (by composition). 
This property does not just hold for the given indexed category arising from 
the explicitly given pullbacks, but for all such indexed categories arising from 
all possible choices of pullbacks. In fibred category theory one leaves this 
structure implicit, which enables a natural and intrinsic formulation of this 
property of the codomain 
fibration 
i 
, see Proposition 1.9.8 (i). 
(b) Dealing explicitly with the mediating isomorphisms rj: id •=>• id* and 
p.: (t/* o tJ*) -^ (i; o uY (and the associated coherence conditions) is cumber-
some. Of course one can ignore them, but that means pretending there is no 
problem. This is dangerous, because coherence conditions may fail. 
(ii) In Section 1.6 we saw that fibrations are closed under composition. 
Of course a similar result can be formulated for indexed categories (try it!). 

110 
Chapter 
1: Introduction 
to fibred category 
theory 
but it lacks the smoothness and clarity that one has with fibrations. Thus 
simple and clarifying results like Lemma 1.6.6 fall outside the direct scope of 
indexed categories. Later we shall make crucial use of this closedness under 
composition in the categorical description of logics and type theories which 
involve different levels of indexing, see Sections 8.6, 9.4, 8.6, 11.2 and 11.3. 
(iii) This last point is related to another advantage of fibrations over 
indexed categories, namely that the notion of fibration makes sense in a 
2-category, see e.g. [317, 171]. This is like display indexing of families, which 
makes sense in any category. 
(iv) Some constructions are easier for indexed categories. Change-of-base is 
slightly simpler (for indexed categories) because it is done by composition (see 
Proposition 1.10.6 below). Considerably more elementary is the construction 
which yields the opposite: for an indexed category ^ one takes the opposite of 
the fibre categories ^(/). Probably the easiest way to understand the opposite 
of a fibration is: first turn it into an indexed category, take the opposite fibre-
wise and turn the result back into a fibration. An explicit fibred construction 
is described in Definition 1.10.11 below. 
(v) The categorical semantics of simple and polymorphic lambda calculi 
can easily be described in terms of indexed categories, as in [307, 156, 61]. 
But, if one wishes to use indexed categories also for the semantics of type 
dependency, one ends up describing the relevant structure in terms of the 
associated Grothendieck completions. In general, if one uses the Grothendieck 
completion all the time, one might as well use fibrations from the beginning. 
Finally one sometimes hears that indexed categories are more elementary 
and easier to understand and use than fibrations. We disagree at this point. 
Properly explained and exemplified, fibrations give a clearer picture of index-
ing and are more convenient to use. Eventually, of course, one tends to think of 
indexed categories and (cloven) fibrations interchangeably. But, and here we 
quote Benabou [29, p. 31, in (v)]: "An indexed category is just a presentation 
of a fibred category". 
On a more practical note, we shall often use split indexed categories—in 
particular, as a means to introduce a split fibration—but hardly ever non-split 
ones. In those situations we prefer to use fibrations. In line with this approach 
we will describe 1- and 2-cells for split indexed categories only. 
1.10.5. Definition. A morphism of split indexed categories from 
^:IBPP -^ Cat to ^: A°P -> Cat is a pair (/i, a) where K\M -^ A is a functor 
and a : ^ => ^ / \ ^ P is a natural transformation. Notice that the components 
of a are functors a/: ^(/) ~> ^(KI). 
This determines a category ICat. 
ICat 
1.10.6. Proposition. The functor 
i 
, which sends an indexed category to 
its base, is a split fibration. The fibre above a category M will be denoted by 

Section 1.10: Indexed categories 
111 
ICat(IB); it contains split indexed categories with base B and natural trans-
formations between them. 
Proof. For an indexed category ^:IB^P -^ Cat and an arbitrary functor 
A^:A->B, put /i*(^) = \[r o/i°P:A°P ^ Cat and ¥ ( ^ ) = (A^ (id^(K/))/6A) 
inlCat. 
• 
1.10.7. Theorem (Grothendieck). The Grothendteck construction from Def-
inition 1.10.1 gives an equivalence of fibrations: 
ICat 
= 
^ Fibspiit 
Cat 
Proof. The Grothendieck construction determines the object part of a func-
tor ^:ICat -^ Fibspiit. For a morphism {K,a):{^:W^ 
-^ Cat) 
—y 
(<l>: A°P -> Cat) in ICat, one defines G(K,a) = [K,ja), 
where / a : / ^ ^ 
^ 
/^ $ is layed down by (/, X) i-> (/i/, oci{X)) and (i/, /) >-^ (/i w, ai{f))—with 
/ the domain of u. 
In the reverse direction there is a functor X: Fibgpiit -^ ICat; it maps a split 
E 
fibration 
-j^P to the functor X(p):W^ —> Cat which maps / H^ E/ and u >-^ 
I/*, as described in Proposition 1.4.5. Clearly, for a morphism ( -^P 1 —^ 
f f^ ) in Fibspiit, one takes I{K,H) 
= {K, (i//)/eA), where HjiEj 
-^]D>KI 
is the restriction to the fibres. Naturality in I is obtained from the fact that 
H preserves the splitting on-the-nose. The required fibred equivalence follows 
readily. 
• 
Notice that the above result gives a categorical version of the equivalence 
Fam(Sets) -^ Sets"^ in Proposition 1.2.2 involving set-indexed families of 
sets. 
Next we mention 2-cells for split indexed categories. In order not to com-
plicate matters too much, we restrict ourselves to a fixed base category IB 
(and so we allow only /\ = id:IB —> B as functor between base categories in 
Definition 1.10.5). 
1.10.8. Definition. Let ^ and ^ be split indexed categories W^ =t Cat 
and Qf,/?:^ =^ <l> natural transformations (i.e. 1-cells in ICat(B)). A 2-cell 
cr: a => /? in ICat(B) is defined to be a modification (see e.g. [176]), i.e. a 
family aj.aj 
=> fSj of natural transformations such that for each w: / -> J in 

112 
Chapter 1: Introduction to fibred category theory 
B one has 
In a diagram: 
The proof of the following result is left to the interested reader. 
1.10.9. Proposition. The fibred equivalence ICat -^ Fibgpiit in Theo-
rem 1.10.7 gives rise to an equivalence 
ICat(B) 
= 
^ Fibspiit(IB) 
of 2-categories, for each category B. 
D 
As we already mentioned in the discussion in 1.10.4, there is considerable 
difference between taking opposites for (split) indexed categories and for fi-
brations. We shall briefly describe both constructions. 
1.10.10. Definition. For a split indexed category ^ : B ° P —> Cat with basis 
B, define the opposite split indexed category ^ ° P as the "fibrewise opposite" 
^op.jgpp ^ c a t given by 
/ ^ ^(/)^P 
and 
(/ A j) H^ UiJY"^ - ^ ^{lyA . 
This definition of opposite for indexed categories is nice and simple. In 
contrast, the opposite for fibred categories is rather involved. The opposite 
p°P of a fibration p should mean: fibrewise the opposite. The requirement 
that such a construction be intrinsic makes the definition below somewhat 
complicated. For split fibrations it is much simpler (see Exercise 1.10.9), since 
it is essentially as for split indexed categories. 
Recall that an arrow in the total category of a fibration factors as a vertical 
morphism followed by a Cartesian one. The intuition behind the definition of 
the opposite is that all vertical maps in such composites are reversed. 

Section 1.10: Indexed categories 
113 
1.10.11. Definition (Benabou [281). Let 
\:P be a fibration. A new fibra-
Ml 
JE(OP) 
tion (with the same basis) written as 
;^^''^ will be described which is fibre-
wise the opposite of p. Let 
CV = {(/i, /2) I /i is Cartesian, /2 is vertical and dom(/i) — dom(/2)}. 
An equivalence relation is defined on the collection CV by 
{fij2)^ 
{91,92) 
<^ there is a vertical h with 91 o h = fi and g2 o h = f2, ss in 
The equivalence class of (/i, /2) will be written as [/i, /2]. 
The total category E^^P^ of p^^ has A" G E as objects. Its morphisms X -^ Y 
are equivalence classes [/i,/2] of maps /i,/2 as in: 
X 
-^Y 
Composition is described by the following diagram 
in which the horizontal dashed arrow is a Cartesian lifting, and the vertical 
dashed arrow is induced. The functor p^PiE^^^^ —)• B is then defined by A i-)-
pX and [/i,/2]^p(/i). 
The proof of the following result is left to the reader. 
E 
1.10.12. Lemma. Let 
jrP be a fibration. One has that 

114 
Chapter 1: Introduction to fibred category theory 
JE(OP) 
(i) the functor 
^ 
is a fibration; and a morphism 
[/i,/2] in E^^^^ is 
Cartesian if and only if the vertical map /2 is an 
isomorphism; 
(ii) this fibration p^^ is the fibrewise opposite of p, that is, for each object 
/ E B there is an isomorphism 
of fibre categories 
(E(^P))^^(E/)''^, 
natural 
ml; 
(iii) there is an isomorphism 
of fibrations (p°P)°P =p overM. 
• 
In ordinary category theory, a category C has limits of shape J if and only 
if the opposite category C ° P has colimits of shape JJ. Similar results exist for 
fibred categories, because the opposite of a fibration is taken 
fibrewise. 
1.10.13. Lemma. For a fibration p one has: 
p has fibred limits of shape JJ <;^ p^^ has fibred colimits of shape Jf 
p has simple products 
<^ p°^ has simple 
coproducts; 
p has products 
<^ p°P has coproducts. 
• 
We close this section with an investigation of adjoining indeterminates 
(or adding elements) to a category. It gives rise to indexed categories, and 
shows in particular how the type theoretic simple and codomain 
fibrations 
arise from the same pattern. 
Let IB be a category with terminal object 1 and let / be an object of B. One 
can form a new category M[x : /]—or M[x: 1 -> /] in the notation of [186]—by 
adding an indeterminate x of type / as follows. Consider the underlying graph 
of B and add an extra edge x: 1 —> / , where ar is a new symbol. Let M[x : /] be 
the free category with terminal object 1, generated by this extended graph, 
incorporating the terminal object 1 G B and the equations that hold in B. It 
comes equipped with an inclusion r^/: B —> M[x : /] which preserves the termi-
nal object. This functor together with x: 1 -> / in B[l : /] is universal in the 
following way. For any terminal object preserving functor F : B —)• C together 
with a morphism a: 1 ^ FI in C, there is an (up-to-unique-isomorphism) 
unique terminal object preserving functor F\ M[x : /] -> C such that Fx — a 
in 
Below we are particularly interested in the case where the category B has 
finite products or finite limits. This structure can then be extended to M[x : /] 
and the universal property holds for functors preserving such structure. 

Section 1.10: Indexed categories 
115 
1.10.14. Proposition. The assignment 
I \-^ M[x : /] extends to an indexed 
category W^ -> Cat. 
Proof. For w: / -> J in B one obtains a functor i/*: B[i/ : J] -^ M[x : /] by the 
universal property applied to 
X J u 
J 
ii^L^.ij 
n 
In the particular cases where the category ® has finite products or finite 
limits, there are simpler ways to describe the category M[x : / ] . The following 
can be found in [186]: (i) in Section I, 7 and (ii) in Exercise 2 in II, 16. 
1.10.15. Proposition, (i) In case IB has finite products, IB[x : /] is equivalent 
to the simple slice category M//1. 
(ii) In case B has finite limits, M[x : /] is equivalent 
to the ordinary 
slice 
category B / / . 
Proof. It is not hard to verify that the functors /*: B -^ M//I and /*: B ^ : 
satisfy the appropriate universal properties. 
• 
1.10.16. Corollary. Applying 
the Grothendieck 
construction 
to the indexed 
category I i-)- M[x : /] from Proposition 
1.10.14 
yields 
s(IB) 
(i) the simple 
fibration 
I 
in case B has finite products; 
(ii) the codomain 
fibration 
^ 
in case B has finite limits. 
D 
The 'type theoretic' simple and codomain 
fibrations 
thus arise by the 
same procedure of adjoining indeterminates. For more information, see [125] 
or [129]. There one finds a description of adding indeterminates to fibred cat-
egories. 
Exercises 
UFam(u;-Sets) 
1.10.1. 
(i) 
Give the split indexed category yielding the 
fibration 
i 
CJ-Sets 
from Section 1.2 upon application of the Grothendieck construction. 
S-Model 
(ii) Do the same for the 
fibration 
} 
from Section 1.6. 
^ ^ 
Sign 

116 
Chapter 1: Introduction to fibred category theory 
1.10.2. (i) 
Show that the Grothendieck construction applied to a (representable) 
functor B( —, /):IB^^ -> Cat—which is a split indexed category with 
1 / / 
discrete fibre categories—yields the domain 
fibration 
4.dom/ 
B 
E 
In hne with this result, one calls a 
fibration 
^ 
representable if it is 
equivalent (as a fibration) to dom/ for some / G IB. 
(ii) Show that a presheaf H: W^ —>• Sets is representable (in the ordinary 
sense) if and only if the associated Grothendieck fibration is repre-
sentable (as a fibration). 
[Representability will be further investigated in Section 5.2.] 
1.10.3. 
Show that the category ICat(B) of indexed categories with basis B has 
finite products. 
1.10.4. Show that a (split) indexed category ^:I^P -^ Cat and a functor A': A -^ 
B give rise to a pullback diagram of categories: 
J (^ o K) 
^ /^ 
K 
1.10.5. Say that a split indexed category ^: W^P -^ Cat has (indexed) Cartesian 
products X if the diagonal A: ^ -)• ^ x ^ in ICat(B) has a right adjoint 
in the 2-category ICat(B). 
(i) 
Describe what this means concretely. 
(ii) Verify that ^ has indexed Cartesian products if and only if its associ-
ated Grothendieck fibration has spht fibred Cartesian products. 
1.10.6. For two 
fibrations 
^ 
and 
^ 
over B we write Fib(B)(p, g) for the 
hom-category of fibred functors p -^ q over B and vertical natural transfor-
mations between them. For / G B consider the assignment 
/ i-> Fib(B)(dom7 x p, q). 
(i) 
Show that it extends to a split indexed category B°^ -^ Cat. 
(ii) Write p =f^ q for the resulting spht fibration. Show that there is an 
equivalence of categories 
Fib(B) ( r X p, g) ~ Fib(B) ( r, p =^ g). 
(iii) Now assume that the above p, q are split fibrations and consider the 
split fibration (for which we also write p =^ q) resulting from the in-
dexed category, 
/ i-> Fibgpiit(B)(dom/ x p, q). 

Section 1.10: Indexed categories 
117 
of split fibred functors. Show that one now gets an isomorphism of 
hom-categories, 
Fibsplit(IB)(r X p, g) S Fibsp,u(IB)(r, p =^ q). 
[Thus p =^ q behaves like an exponent, see also [36, 11, Lemma 8.4.4]. Its 
definition can be understood in terms of the Fibred Yoneda Lemma 5.2.4. 
If p and q are presheaves {i.e. discrete fibrations), then p =^ g is the usual 
exponent of presheaves (see Example 5.4.2).] 
1.10.7. (i) 
Check that one gets a category f^ as described in Definition 1.10.1 
in case rj and /u are natural transformations satisfying the coherence 
conditions (but are not necessarily isomorphisms as in Definition 1.4.4), 
but that the result need not be fibred over B. 
(ii) Show that a monad (T, r/, fj) on a category A corresponds to a "pseudo-
functor" A: 1*^*^ -^ Cat, without the requirement that the maps rf and 
fj are isomorphisms. 
(iii) Show that in the situation of (ii), the Grothendieck construction as 
in (i) corresponds to taking the Kleisli category of the monad (T, r],fA). 
Inv(l) 
1.10.8. Let B be a category with finite limits. We write 
4- 
for the opposite 
1 
M 
of the codomain 
fibration 
^ 
. The category Inv(B) is sometimes called 
the inverse arrow category of B. 
Inv(]B) 
(i) 
Describe the 
fibration 
i 
in detail. 
(ii) Show that its fibre above the terminal object is (isomorphic to) W^. 
1.10.9. Let p be a split fibration. Show that the opposite fibration p^^ can also be 
obtained by turning p first into a split indexed category, taking the opposite 
of all fibres and changing it back into a fibration. 
1.10.10. Let p be a Cartesian closed fibration. Describe the (fibred) exponents via 
a fibred functor =^:p^P x p -^ p. 
s(C) 
1.10.11. Let C be a category with pullbacks; consider the simple 
fibration 
s^sc . 
There is a functor { —}:s(C) —> C given by {I,X) 
\-> I x X and (w,/) i-> 
{u o 77, / ) . Form the fibration q by change-of-base 
Sub(Q 
and let r be the fibration \S£ o q^^j 
: DC —)• C Describe the total cate-
gory DC in detail. 
[It is the dialectica category of de Paiva [243].] 

118 
Chapter 
1: Introduction 
to fibred category 
theory 
This Page Intentionally Left Blank

Chapter 2 
Simple type theory 
In this chapter we introduce the first and most elementary type theory, namely 
simple type theory (STT), which goes back to Church [49]. Here we use the 
terminology simply typed for type theories without type variables and poly-
morphically 
typed for type theories which do have such type variables. Chap-
ter 8 is devoted to these polymorphic type theories (PTTs). Although there 
are no type variables a: Type in STT, term variables v.cr inhabiting types 
cr:Type do exist. But these are allowed to occur only in terms—and not in 
types, like in dependent type theories (DTTs) (see Chapter 10). 
In the present chapter we give categorical semantics of simple type theory, 
both in (traditional) terms of ordinary categories, and also in terms of fibred 
categories. We begin with the syntax of calculi of types and terms, starting 
from a many-typed signature as defined in Section 1.6. From now on, terms 
will be described systematically in contexts. These are finite sequences of 
variable declarations vi'.ai, describing the types ai of free variables vi. The 
rules for term formation will guarantee that variables only appear free in a 
term, if they occur in the context of the term. This calculus types and terms 
gives in a canonical way rise to a category, which is commonly called its 
classifying category. A model of a calculus can conveniently be described in 
terms of a suitable structure preserving functor from its classifying category 
into some other 'receiving' category. This is the essence of Lawvere's functorial 
semantics. In Section 2.2 it will first be described for ordinary categories. Later 
on, this functorial semantics will also be used for fibred categories. 
STT is commonly studied with the following constructors for the formation 
of new types: exponents -^ (or function spaces), finite products (1, x) and fi-
119 

120 
Chapter 2: Simple type theory 
nite coproducts (0, +) (or disjoint unions). Models of calculi with (->, 1, x) are 
easily described in terms of Cartesian closed categories, see e.g. [186, 63, 61]. 
Additional coproduct types (0, +) can be described with categories having ad-
ditionally finite coproducts. Under the propositions-as-types perspective, the 
study of these type formers (-^, 1, x, 0, -f) amounts to the study of the proof 
theory of the propositional connectives ( D , T , A , ± , V ) . It turns out that the 
minimal calculus, with exponent types only, is most difficult to capture cate-
gorically. This is because categorical exponents are not described in isolation, 
but require (binary) products. 
Using fibred categories one can resolve this difficulty. In a fibred description 
of a type theory (or of a logic), contexts form objects of a base category. The 
fibre above such a context contains what happens in that context. This view 
is fundamental. For simple type theory it suffices to consider simple 
fibrations 
(introduced in Section 1.3), since types do not contain any (term or type) 
variables and hence do not depend on a context. It will turn out that exponent 
types -^ can then be described by right adjoints to weakening functors TT*, 
i.e. by what were called simple products in Section 1.9. This will be done 
in Section 2.4. Additionally, Cartesian product types x are captured as left 
adjoints to these weakening functors TT*. This description of-^ and x is in fact 
a special case of 11 and E in a situation where 11 becomes —> and E becomes 
X because there is no type dependency (see also Example 10.1.2 later on). 
Historically, Church's untyped A-calculus came before his simple type theory. 
In this untyped A-calculus there is no typing discipline and each term may 
be applied to every other term (including itself, which gives self-application, 
like in the term Xx.xx). 
But the untyped A-calculus may be understood as 
a simply typed A-calculus with only one type, say Q, with Q ^ 
Q = Q. 
Specialising the fibred description of exponents to this particular case with 
one type, naturally gives us a notion of model for the untyped A-calculus. This 
will be done in Section 2.5. In our fibred approach we thus get (the semantics 
of) untyped A-calculi as a special case of (the semantics of) simply typed 
calculi. It comes almost for free. 
In the final section 2.6 of this chapter one can find how simple 
fibrations 
may also be used to give a suitable description of data types with (simple) 
parameters. 
2.1 The basic calculus of types and terms 
Starting from a many-typed signature we will define various simply typed 
calculi: in this section we introduce the basic calculus which gives a detailed 
description of the terms associated with a signature. Later, in Section 2.3 we 

Section 
2.1: The basic calculus of types and terms 
121 
will define the calculus Al by adding exponent types via a type construc-
tor ->, and extensions of this Al with finite product types (1, x) and finite 
coproduct types (0,4-). With all these calculi one associates in a canonical 
way a classifying category: it is obtained as a term model (or generalised 
Lindenbaum-Tarski) construction. It will play a crucial role in the Lawvere's 
functorial semantics in the next section. 
Let E be a many-typed signature with T = |E| as its underlying set of 
types. We assume a denumerably infinite set Var = {vi, V2T . • •}, elements of 
which will be called (term) variables. A context T is then a finite sequence 
of variable declarations written as 
r = 
{vi:ai,...,Vn:o'n)-
By convention, we list the variables in a context starting with vi. We can 
concatenate contexts F = (^i: cri,..., i;„: cr„) and A = {VI'TI, ... ^Vn'-Tm) as 
r , A = {vi'-CTi,. 
. .,Vn:(Tn,Vn^l-Ti, 
. . . , 
Vn-{.m'Tm)-
This precise use of variables Vi has two advantages: it prevents name clashes of 
variables and is fairly close to a categorical description. There is nothing deep 
to it since variables are merely placeholders. The extra book-keeping which it 
requires is bearable. And in situations where it does not matter which of the 
variables Vi is being used, we freely use met a-variables x, y, z,... Especially in 
later chapters we shall use mostly these meta-variables, but for the moment 
it is better to be precise. 
Terms are thus described with respect to a fixed collection of variables, 
which receive their types in contexts. And not, as in universal algebra (see 
Section 1.6), with respect to various collections {Xa)aeT of sets X^ of variables 
which are already typed. 
In type theory one uses the notation 
r \- M:T 
to express that M is a term of type r in context F. In such a situation one 
sometimes says that M inhabits r, or just that r is inhabited (by M, in 
context F). A typical example of such an inhabitation sequent is 
n:N,m:N h plus(times(m, n), m): N. 
Such a typing sequent can be obtained by successive applications of the 
following basic rules. 
identity 
vi'.a h vi'.a 

122 
Chapter 2: Simple type theory 
(for F i e r i , . . . , cr„ —y an+i in S) 
function symbol 
r h M i : ( 7 i 
••• 
r \- Mn'.CTn 
r 
h F ( M i , . . . , M „ ) : ( 7 n + i 
Plus the following structural rules: 
weakening 
vi:ai,...,Vn:(Tn 
h M:T 
contraction 
T,Vn:(T,Vn 
+ i:0- h M l T 
T.Vn'.O- h M[Vn/Vn 
+ l]'r 
exchange 
r,'i;2:crj, i;j_|_i:<7f_|.i, A h M: r 
These last three rules allow us to add an extra variable declaration, to replace 
two variables of the same type by a single one and to permute assumptions. 
Often, these structural rules are not listed explicitly. But here we empha-
sise them, because weakening and contraction play an important role in the 
categorical description of type constructors. (Also it is good to be explicitly 
aware of such rules, because their use may be restricted, as in linear logic, 
see [97, 98].) 
We thus have rules for deriving inhabitation sequents F h M:a. 
Formally 
we say that such a sequent is derivable if there is a derivation tree consisting 
of the above rules, with the sequent F h M: (j as conclusion. In that case we 
sometimes write 
• F h 
M:a 
for: F h M: cr is derivable. 
As an example, consider a signature with two function symbols: 
plus: N , N ^ N , 
if:B,N,N^N. 
Then one can derive an inhabitation statement 
vi: B, t'2- N I" if(i^i,^2,pius(t'2,f2))- N. 

Section 2.1: The basic calculus of types and terms 
123 
Formally, this is done as follows. 
(Wj 
t;i:B h t ; i : B 
i;i:N,t;2:N l-t;i:N 
?;i: B,i;2: N f - i ; i : B 
?;i: N, i»2: N h t;2: N 
i;i:N h t;i:N 
i;i:N h t^iiN 
t;i: N h plus(i'i, vi): N 
i^i:N,i;2:N h plus(i;i, f i ) : N 
^ 
(E) 
f i : N , f 2 : N h plus(i;2, ^2): N 
t^i: B,t;2: N h if( 1^1,1^2, plus(?;2,1^2)): N 
The annotations (W) and (E) indicate applications of the Weakening and 
Exchange rules. In similar fashion, one can write a derivation tree for 
t;i:N,t;2:N,V3: B,?;4: N.v^: B h 
\i(v^,p\us{vi,V4),V2):\^. 
Intuitively, this may be clear, but the formal derivation is involved. In Exer-
cise 2.1.1 below, we present some extra (derivable) rules which make it easier 
to form such terms. 
This calculus of types and terms may be called the term calculus of a 
signature E. 
Substitution M[N/vn] 
of a term N for a variable Vn in M is best defined 
on 'raw' terms (i.e. not necessarily well-typed terms), as 
TAT/ 
1 
I ^ 
if m = n 
Vm[N/Vn\ 
= 
Vm else 
F(Mi,...,M„)[7VK] = 
F{Mi[N/vnl....Mn[N/vn]). 
As a derived rule one then has 
substitution 
T.Vn'.o- h M:T 
r h 
N:a 
r \- 
M[N/vn]:T 
This rule expresses that if the term A^ and variable Vn have the same type, 
then performing substitution [N/vn] transforms well-typed terms into well-
typed terms. The rule is consequence of a much more general substitution 
result, which is presented as Exercise 2.1.2. 
It is useful to emphasise once again the difference between the above term 
calculus and the sets of terms TermSr(X) of type r, built upon a T-indexed 
collection of sets of variables X = {Xa)aeTi 
as described in Section 1.6. The 
main difference lies in the fact that in the latter approach the sets of variables 
{Xa)aeT 
form a parameter. This is usual in universal algebra. In the type 
theoretic approach in this section (and in the rest of this book) we fix in 
advance the set from which variables can be taken. 

124 
Chapter 2: Simple type theory 
There is a way to switch for individual terms between these descriptions. 
If r = {vi'.ai,..., 
Vn:(Tn) and T h M: r in type theory are given, then one 
can form sets X^ = {v E Var \ v.a occurs in F}. This yields a collection 
X = {Xa)aeT of term variables and the term M can now be described as a 
term M G Terms7.(X). In particular, in a E-algebra {Aa, [[ — 1) as described 
in Section 1.6 the term M yields a function 
lrhM:rI = 
Aa,X'-'X 
Aa^ 
^ Ar 
as described before Definition 1.6.4. 
Conversely, assume an arbitrary collection X = {Xa)aeT of term variables 
and a term M in Terms,-(X), as in the alternative description. We know that 
M is formed in a finite number of steps and can thus contain only a finite 
number of variables Xj G Xa,, say, with I < i < n. Replacing these Xi G X^, 
by Vi'.ai, one gets a term t;i: cri,..., i;^: cr„ h M[v/x]: r as in type theory. 
We close this section by showing how contexts and appropriately typed (se-
quences of) terms form a category. The intuition behind terms-as-morphisms 
is the following. A term in context vi: cri,..., i;„: cr„ h M: r may be seen as an 
operation which maps inputs a,: ai on the left of the turnstile h to an output 
M[alv\: T on the right, via substitution. Thus one expects such a term to form 
a morphism 
M 
ai 
X ' ' ' X (Tn 
>- T 
in a suitable category, so that, roughly, h becomes —>-. This is formalised in 
the next definition. Morphisms will not be individual terms, but sequences of 
terms. Such sequences are often called context morphisms. 
2.1.1. Definition. The above term calculus on a signature E will serve as a 
basis for the classifying category (or term model) C^(E) of E. Its objects 
are contexts T of variable declarations. And its morphisms T —> A—where 
A = {vi'.Ti,.. .^ Vm''Tm)—are m-tuples (Mi,..., Mm) of terms for which we 
can derive T h Mj-.Ti, for each 1 < i < m. 
The identity on an object T = (t;i: (Ji,..., Vn'-CTn) in C£(E) is the n-tuple of 
variables 
{vi,...,Vn) 
-^r 
And the composite of context morphisms 
(Mi,...,M^) 
{Ni,...,Nk) 
^ A 
^ e 

Section 2.1: The basic calculus of types and terms 
125 
is the /?-tuple ( L i , . . . , Lk) defined by simultaneous substitution: 
Li = 
Ni[Mi/vu...,Mm/Vm]-
It is then almost immediate that identities are identities indeed. Associa-
tivity requires a suitable substitution lemma, see Exercise 2.1.3 below. 
We notice that the construction of a classifying category of a type theory is 
like the construction of the Lindenbaum algebra of a (propositional) logic. In 
the first case a turnstile h in type theory becomes an arrow -^ in a category, 
and in the second case a turnstile h in logic becomes an inequality < in a 
preorder (or poset). Under a propositions-as-types reading, the preorder that 
one obtains is the underlying preorder of the classifying category. 
2.1.2. Proposition. The classifying 
category (X{T>) of a signature 
E has fi-
nite 
products. 
Proof. The empty context 0 is terminal object, since for any context F there is 
precisely one morphism F —• 0, namely the empty sequence (). The Cartesian 
product of contexts F = {vi'.ci,... 
^Vn'-o-n) and A = {VI'.TI, ... ,Vm'-Tm) is 
their concatenation F, A with projection morphisms: 
F ^ 
(F,A) 
^ A 
D 
Exercises 
2.1.1. 
Prove that the following 'extended' structural rules are derivable. 
F, Vn'- (T, A, Vn-^m: P, © \- M'. T 
(i) 
(ii) 
r , t;„: p, A, Vn+m-- (T, 0 h 
M[Vn/v„+m 
r,Vn:o;A 
\- M:T 
F, A, Vn+m:cr I- M[Vn-\-m/Vn,Vn/Vn-\-l,- 
- . , Vn+m-l / Vn-^m]: T 
F, Vn'- Cr, A, Vn-\-m'-(T, G h M'.T 
("i) 
T,Vn:(T,A,e 
\-
M[Vn/Vn-{-m 
/t^n+m+1, . . . , Vn-\-m-\-k-l/Vn-\-m-\-k]''T 
F,F 
I - M : T 
(iv) 
F h M[vi/Vn-\-l 
, . . . , Vn/V2n]: T 
2.1.2. 
Derive the following substitution rule. 
F,t;„:(T,A h M: r 
B \- N.a 
F , e , A \- 
M*[N^/vn]:r 

126 
Chapter 2: Simple type theory 
where, assuming A to be of length m and 0 of length A:, 
M * 
= 
M[Vn-\-k/Vn-\-l,.",Vn-\-k-\-m-l/Vn-\-m] 
N* 
= 
N[Vn/vi,.,.,Vn-\.k-l/vk]. 
2.1.3. 
(i) 
Prove the following substitution lemma (see also [13], 2.1.16) for 
'raw' terms. 
M[N/vn][L/vm] 
= M[N[L/vm]/vn], 
if Vm is not free in M. 
(The sign = is used for syntactical identification, as opposed to con-
version later on.) 
(ii) Show that—as a result—composition in classifying categories CC(T>) is 
associative. 
2.2 Functorial 
semantics 
In Section 1.6 we have seen the notion of model (or algebra) for a many-
typed signature E. It consists of a collection of sets Aa for types cr in S, 
and of an actual function [[FJ: A(j^ x • • • x A(j^ —> ^an^i 
f^^ each function 
symbol F : cri,..., o"n —> o-n-\-i in S. Below we shall re-describe, following 
Lawvere [191], such a model as a finite product preserving functor (^(E) -^ 
Sets from the classifying category of E to sets. This alternative formulation 
of model of a signature 
admits generalisation to model functors C^(E) —)• IB 
into receiving categories IB other than Sets. 
S-Model 
But first we re-describe set-theoretic models. Recall the 
fibration 
^1-
Sign 
of set theoretic models of many-typed signatures over their signatures from 
Section 1.6. The fibre category of E-models will be written as S-Model(E). 
2.2.1. Theorem. For each many-typed 
signature 
E, there is an 
equivalence 
of 
categories 
S-Model(E) ~ F P C a t ( « ( E ) , Sets) 
where the right hand side denotes the horn-category 
of finite product 
preserving 
functors 
and natural transformations 
between 
them. 
Thus, set-theoretic E-models correspond to finite product preserving func-
tors from the classifying category of E to Sets and morphisms of E-models to 
natural transformations between the corresponding functors. Above, F P C a t 
stands for the 2-category which has categories with finite products as objects 
and functors preserving such structure as morphisms; 2-cells are ordinary nat-
ural transformations. 
Proof. For the passage S-Model(E) —^ FPCat(ff(E), Sets), let [Aa)oeT 
be a E-model, where T = |E| is the set of types underlying E. One defines an 

Section 
2.2: Functorial 
semantics 
127 
associated model functor A:Cl{Ti) -^ Sets by 
( M l , . . . , M „ ^ ) : r - > A i-> A(ai,.. 
.,an 
= 
( [ [ r i - M i : r i ] ] , . . . , l r h M „ : r „ l ) , 
where |[ F h Mf: TJ ]] is the interpretation of the term T h M^-: r^ as a function 
Aaj^ X • • • X ^4(7^ -> Ar, (as we described before Definition 2.1.1). 
As an example we show that A:Ci(T,) -^ Sets preserves identities. 
^ ( i d r ) = 
A{vi,...,Vn) 
- 
; ^ ( a i , . . . , a n ) . ( a i , . . . , a „ ) 
= id>i(r)-
From Exercise 1.6.7 (i) it follows that A preserves composition. It is almost 
immediate that A preserves finite products. But note that products are not 
preserved on-the-nose, 
due to an implicit use of bracketing in A^^ x • • • x Aa^ • 
A morphism of S-models [Ha'.Aa 
—> Ba)^^rp 
induces a natural trans-
formation A => B between the corresponding functors, with component at 
T = {vi:ai,.. 
,i;n:crn) given by 
%{ai,. ..,an)- 
{Ha,(ai),. 
..,Ha^{an)) 
= Ha, X • • • X Ha^-
Naturality follows from Exercise 1.6.7 (ii). 
In the reverse direction, a finite product preserving functor A4:Ct{T>) —> 
Sets determines a set-theoretic model of E with carrier sets 
and interpretation of E-function symbol F : cri,. .., (j„ —y cr^+i, 
IF}"^:^^ 
M{F{vi,...,Vn):(vi:(Ti,...,Vn:(Tn) 
^ 
(vi:CTn + l)) 
O (p, 
where (f is the isomorphism in 
= 
Mai 
X • • • X 
Man 
making [[F]| a well-typed function. A natural transformation a:M 
=> Af 
between functors M,Af:Ci{T>) 
=t Sets determines a morphism of models, 
with functions 
given by 
^a e Ma-0t{vi:c7){(J')' 
O 

128 
Chapter 2: Simple type theory 
The next definition embodies a crucial step in functorial semantics; it gen-
eralises models of a signature in Sets to an arbitrary category with finite 
products. The previous theorem suggests to define such models simply as fi-
nite product preserving functors with the classifying category of the signature 
as domain. 
2.2.2. Definition. Let S be a many-typed signature and B a category with 
finite products. A model of E in IB consists of a functor 
ff (E) 
— 
^ B 
preserving finite products. A morphism between two such E-models 
MjJ\f:(X{T,) 
=4 B in B is then a natural transformation M 
=> Af. 
Hence the category of E-models in B is defined to be the hom-category 
FPCat(«(E), B ) . 
More explicitly, a model of a signature E in a category B is given by an 
object 
I ^ B E B 
for every type cr G |E| and a morphism 
l F l : [ [ ( T i l x . . . x [ [ ^ n I - ^ [ [ ( T , + i l 
inB, 
for every function symbol F: (Ji,..., cr„ —>• cr„_^i in E. The force of the above 
definition lies in the fact that it tells us what a model of a signature is in an 
arbitrary category with finite products. It is completely general. For example, 
a continuous E-algebra is defined in [101] as a E-algebra whose carriers 
are directed complete partial orders (dcpos) (posets with joins of directed 
subsets) and whose interpretations of function symbols are continuous func-
tions (preserving these joins). Thus, such a continuous E-algebra is a model 
ff (E) -^ Dcpo of E in the category Dcpo of dcpos and continuous functions. 
Another example (involving partial functions) may be found in Exercise 2.2.1 
below. 
2.2.3. Example. Among all the models a signature E can have there is one 
very special: it is simply the identity functor Ci(E) —> ff(E). This model of E 
in (^(E) is called the generic model of E. It is the categorical version of the 
term model constructed in Example 1.6.5 in the style of universal algebra. 
In a category of models FPCat(«(E), B) —like in any category—one may 
have initial and terminal objects. These are initial or terminal models of E in 
B. They play a distinguished role in the semantics of data types. 
The following two results gives a clearer picture of what such categorical 
models are. 

Section 2.2: Functorial semantics 
129 
2.2.4. Lemma, (i) There is a forgetful functor 
Sign(-) 
FPCat 
^ Sign 
given as follows. For a category B G FPCat the underlying signature 
Sign(IB) ofM has objects from B as types and function symbols given by 
F:Xi,...,Xn-^Xn-^i 
tn Sign(B) 
V> F is a morphism Xi x - - - x Xn -^ Xn+i in B. 
(ii) In the reverse direction, taking classifying categories yields a functor 
« ( - ) : Sign—^ FPCat. 
For a morphism of signatures (j):T, -^ E' in Sign one obtains a functor 
CC(<I)):CE(Y1) —> C^(E') by replacing every H-type and function symbol by its 
image under (j). For a term M we shall often write <j)M for Cl{(t)){M). 
Proof, (i) For a morphism K:K ^ B in FPCat—i.e. for a finite prod-
uct preserving functor—one has a signature morphism Sign(A^): Sign(A) -^ 
Sign(B) which sends X G A to KX G B and a map XiX .. .x Xn ^ -^n+i in 
A to the composite KXi x ... x KXn ^ K{Xi x ... x Xn) -> KXnJf-i in B. 
(ii) Easy. 
D 
(Here, we should allow signatures with classes (as opposed to sets) of types 
and function symbols if we wish to define Sign(B) for a non-small category 
B—with finite products.) 
2.2.5. Theorem. For a signature S and a category B with finite products, 
there is a bijective correspondence (up-to-isomorphism) between morphisms of 
signatures </> and models M as in 
E 
^ Sign(B) 
a{E) 
M 
We do not obtain a precise correspondence (but only "up-to-isomorphism") 
between the </> and M in the theorem because first translating a model M into 
a morphism of signatures (J)M and then back into a model M(pj^ does not pre-
cisely return M, because M preserves finite products only up-to-isomorphism. 
Thus, in a suitable 2-categorical sense, the functor Ci(—) is left adjoint to the 
forgetful functor Sign(—): FPCat -> Sign, and ff(S) is the free category 
with finite products generated by the signature E. 
Proof. The proof is essentially a reformulation of the proof of Theorem 2.2.1 
with the receiving category Sets replaced by the category B. For a morphism 

130 
Chapter 
2: Simple 
type 
theory 
of signatures 0: E -> Sign(B), one defines a model M: Cf(E) ^ B by 
( M i , . . . , M ^ ) : r - ^ A 
^ 
{M{T 
h Mi: n ) , . . . , A^(r 
h M ^ : r ^ ) ) 
where A — i^i: n , . . . , f^: r^. This operation M{—) 
is a mapping which in-
terprets a term T h M: r in context F = vi'.a,.. 
..Vn'-CTn as a morphism in 
1: 
A^(r \- M:T) 
cj>{a,) X • . • X 0(c7„) = A^(r) 
^ ^ ( t ; i : r) = (/>(r) 
It is defined by induction on the derivation of F h M: r as: 
• identity. 
M{vi:o' 
h vi'.a) 
= id: ({){a) -> (f>{(T). 
• function symbol. For F : r i , . . . , r ^ —> Tn+i, 
A ^ ( r h F ( M i , . . . , M „ ) : r „ + i ) 
= <P(F)o{M{T 
\-Mv.n),...,M(T\-M,n:rm))-
• weakening. Suppose F h M: r. Then 
A^(F,t;n:(T h M : r ) = X ( F 
h M : r ) o 7 r . 
• contraction. Suppose F, Vn'- cr, fn+i^ cr h M: r. Then 
A^(F,i;„:cr h 
M[vn/vn+i]'r) 
— M{V,Vn'.(T,Vn^i'.o' 
h M: T) o (id, 7r'). 
• exchange. Suppose F, Vi'. ai, Vi^i: crf+i, F' h M: r. Then 
A^(F, Vi:(Ti+i,Vi+i:ai, 
T' h M[t;i/^i+i, t;i+i/t;f]: r) 
= M{T,Vi: 
crf,t'2_|_i:crj_|_i,F' h M: r) o id x (TT', TT) X id. 
Further details are left to the reader in Exercise 2.2.2 below. 
In the reverse direction, given a model M:Ci{T>) -^ M one obtains a mor-
phism of signatures E —)- Sign(B) by o" i-^ M{vi:a) 
and F ^ 
M{F) 
o 9?, 
where 9? is a mediating isomorphism, like in the proof of Theorem 2.2.1. 
• 
Notice in the above proof the importance of projections 
w: I x J 
-^ 
I for the interpretation of weakening and of [parametrised) 
diagonals 
S = (id, TT'): / X J ^ (/ X J) X J for contraction. 
2.2.6. Definition. The adjunction Ci{—) H Sign(—) in the previous theorem 
gives rise to a monad T — Sign(C^(—)) on the category Sign of signatures. 
The resulting Kleisli category—written as Signtr—will be called the cate-
gory of signatures and translations. Thus a translation (/):E -> E' is 

Section 2.2: Functorial semantics 
131 
understood as a mapping of types to contexts and of function symbols to 
terms (instead of: types to types and function symbols to function symbols, 
as in the category Sign). Formally, such a translation 0 is a morphism of 
signatures S -^ Sign(ff(E')). 
The category Signtr is in fact more useful than Sign: translations occur 
more naturally than morphisms of signatures, as the following examples illus-
trate. 
2.2.7. Examples, (i) The classic example of a translation of signatures in-
volves two (single-typed) signatures for groups, see [212], Definitions 1.1 
and 1.2. For reasons of clarity we provide the following two signatures with 
equations; but they do not play a role at this stage. 
(1) Let El be the signature with one type G and three function symbols 
m : G , G — > G , 
e: 0 — > G, 
i : G — y G 
giving a multiplication, unit and inverse operation. The equations are the 
familiar ones for groups: 
i;i:G 
h m(e,i;i) =G ^1 
t^i:G h m{\{vi),vi) 
=Q e 
t;i:G h m{vi,e) 
=QVi 
i;i:G 
h m(vi,\{vi)) 
-Q e 
i;i:G,i;2:G,i;3:G 
h m(i;i, m(i;2, ^3)) =G nn(m(t;i, t;2), 1^3)-
Such equations will be studied systematically in the next chapter. 
(2) Less standard is the following signature E2 for groups. It has again one 
type G but only two function symbols, 
d:G,G—>G 
and 
a: () —>G 
satisfying a single equation 
Vi: G, V2: G, 1^3: G h 
d{d{6{v3,d{vi,6{vi,vi))),d(v3,di{v2,di(vi,vi)))),vi) 
=Q V^. 
Notice that the second function symbol (or constant) a does not occur in this 
equation; its sole role is to ensure that groups have at least one element. (It 
is not present in [212], so that groups may be empty there.) 
There is a translation 
S2 —> Ei which maps the type G to itself, and the 
function symbol d to the Ei-term 
t;i:G,i;2*G \- 
rc\(\[vi),V2)\G 
and a to an arbitrary term in G, e.g. e. This is a translation—and not a 
morphism of signatures—because the function symbol d of E2 is mapped to 
a term of Ei—and not to a function symbol of Ei. For more details, see 
Exercise 2.2.3 below. 

132 
Chapter 2: Simple type theory 
(ii) Boolean logic can be described by the (functionally complete) pair of 
connectives 
-.: B —>S 
and 
A: B, B —>B 
of negation and conjunction. Alternatively, negation and implication can be 
used: 
-.:B—>B 
and 
D: B, B—>B 
Or also the Sheffer stroke 
|:B,B—^B. 
The standard definitions 
i;i 3 i;2 = -i[vi 
A ->V2) 
a n d 
i^i|i^2 = "'('^1 A 1^2) 
yield translations from the last two signatures into the first one. 
Exercises 
2.2.1. 
(i) 
Let Sets, be the category of pointed sets as described in Exercise 1.2.3. 
It can be seen as the category of sets and partial functions. Show that 
Sets, has finite products, 
(ii) Let D be a signature. Define a partial S-algebra (or model) to be 
a finite product preserving functor (^(E) —> Sets.. Describe such a 
partial algebra in detail. 
2.2.2. 
Consider the interpretation A4 associated with a morphism of signatures 
</>: E —)• Sign(IB) in the proof of Theorem 2.2.5. 
(i) 
Let r = (ui: (Ji,..., Vn- cTn) be a context with a term F h M: r such 
that the variable Vk in T does not occur (free) in M. Prove that 
M{r 
\-M:(7) 
= M{r^ 
h M ^ (T) O (TTI , . . . , TTk-l, ITk+l , . . . , TTn), 
where 
-nk 
1 
= 
Vi'.ai, 
. . . ,Vk-i:0'k,Vk:(Tk-\-l," 
"iVn-l'-O-n 
M^ 
= 
M[vk/Vk+l,...,Vn-l/Vnl 
and TTt is the obvious projection map M{ai) 
x • • • x M{(Tn) —)• M{art). 
(ii) Next, for T = i;i: cri,..., t;„: (Tn, consider a term T \- N:T, and a 
context morphism M: A -^ F. Prove that 
M{A 
h N[M/v\: r) = M{r 
h TV: r) o 
{M{A 
h M i : a i ) , . . . , A i ( A hMni^n)). 
(iii) Conclude from (i) and (ii) that M. preserves identities and composition. 
2.2.3. 
(i) 
Check that the translation in Example 2.2.7 (i) of d as m(i(t;i), ^2) 
satisfies the equation for d. 
(ii) Find cilso a translation of signatures Ei -> E2. 

Section 2.3: Exponents, products and coproducts 
133 
2.2.4. 
2.2.5. 
(iii) In (ii) of the same example, define a translation from the first signature 
with -I and A into the last one with the Sheffer stroke |. 
We describe a category of categorical models of signatures. Let 
C-Model be the category with 
objects 
morphisms 
(D, A, M) where M'.CE^E) -> A is a finite product pre-
serving functor. 
(E,A, At) -> {i:',A',M') 
consist of a triple {(t>J<,a) 
where (/>: H -> EMs a morphism of signatures, K: A -> 
A' is a finite product preserving functor and a is a nat-
ural transformation KM. ^ M'Cli^cj)) in 
a[ct>) 
M 
a 
M' 
A 
K 
^ A' 
C-Model 
(i) 
Show that the projection 
} 
is a fibration. 
(ii) Verify that this fibration has fibred finite products. 
C-Model 
fin Section 9.1 it will be shown that the 
fibration 
} 
comes from a 
. 
^^^^ 
canonical construction as one leg of a fibred span. There is also a projection 
C-Model 
functor 
„T>i>. 
' which is an 'opfibration', since reindexing works in the 
other direction.] 
Let M:a{T>) ^ B be a E-model. For terms T \- N, N': a write 
M\=N 
=a N' 
for 
M{N) = M{N') 
where on the right hand side, N and N' are treated as morphisms T n^ 
(7 in Ci{Ti). Let </>: S ^ 
E' be a morphism of signatures. Show that the 
'satisfaction lemma' 
M\=(t>N =^a <t>N' <^ cf>*{M) \=N 
=aN' 
boils down to a tautology—where <j)*(A4) is the outcome of reindexing along 
(f), see (i) in the previous exercise. 
[This property is fundamental in the definition of an institution [152].] 
2.3 Exponents, 
products and 
coproducts 
In this section we discuss three simply typed A-calculi, which will be written as 
Al, Alx and Al(x,-i-)- The calculus Al has exponent (or arrow) types cr -> r; 
Alx additionally has finite product types l,a x r which allow one to form 

134 
Chapter 2: Simple type theory 
finite tuples of terms (including the empty tuple); and in Al(x,+) one has 
finite coproduct types 0, cr + r. With these one can form finite cotuples. These 
calculi are built on top of a many-typed signature. A brief discussion of the 
propositions-as-types analogy is included. 
(We shall not discuss the rewriting properties of these type theories. We 
refer to [186] for proofs of Church-Rosser and strong normalisation for type 
theories with -^ and x—building on ideas of Tait and de Vrijer. A singleton 
type is included in [64].) 
At this stage we begin to be more sloppy in the use of variables: instead 
of the formally numbered variables {i^n | ^ G N} we now start using meta-
variables u,v^w,x,y, 
z. This is more convenient for human beings (as opposed 
to computers). We shall require that no two variables occurring in a context 
r are equal. In particular, in writing an extended context F, x: a it is assumed 
that X does not occur in F. 
Al-caicuii 
Let E be a many-typed signature with T = |E| as its underlying set of types. 
Let Ti be the least set containing T, which is formally closed under -^, i.e.T 
C 
Ti and cr, r E Ti => (cr ^ r) G Ti. We now call elements of Ti types, and if 
we wish to stress that cr £ Ti actually is a member of T, then we call it an 
a t o m i c or basic type. In order to spare on parentheses one usually writes 
CTi ^ 
(72 —)-•••—)• Cr„_i ^ 
CTn 
for 
(Ti ^ 
(0-2-^ 
> {(Tn-l 
-^ 
O-n)-- 
•)• 
Instead of extending T to Ti we can also say that there are the following 
two type formation rules. 
(fbrcTGT) 
HcTiType 
h r : T y p e 
^^•Type 
h ( T ^ r : T y p e 
Notice that in these type formation statements of the form h a:Jype 
we 
have an empty context because types in STT are not allowed to contain any 
variables. This will be different in calculi with polymorphic or dependent 
types. 
The simply t y p e d A-calculus A1(E) built on top of E has all the rules 
of the term calculus of E—described in Section 2.1—plus the following intro-
duction and elimination rules for abstraction and application. 
T,v:a\-M:T 
T\-M:a-^T 
T\-N:a 
T h \v:a.M:a^T 
F h MN: r 

Section 2.3: Exponents, products and coproducts 
135 
Intuitively one thinks of the abstraction term Xv.a.M 
as the function a H^ 
M[a/v], 
so that cr —)- r is the type of functions taking inputs of type a and 
returning an output of type r. The term former Xv:a. (—) binds the variable 
V. The application term MN 
(sometimes written as M • A^) describes the 
application of a function M:a 
^ 
r to a,n argument N:a. 
Notice that this 
application is required to be well-typed in an obvious sense. 
This explains the associated two conversions 
T,v:a\-M:T 
T\-N:a 
T h M i c r - ^ r 
r h {Xv: a. M)N 
= M[N/v]: 
r 
T \- Xv:a. Mv = M: a-^ 
r 
where in the latter case it is assumed that v is not free in M. The first of 
these rules describes what is called (/?)-conversion, and the second describes 
(7/)-conversion. This (/?) is evaluation of a function on an argument, and {rj) 
is extensionality of functions. Here we have written these conversions as rules, 
with all types explicitly present. Often they are simply written as 
{Xv:cT.M)N 
= M[N/v] 
and 
Xv.a.Mv 
= M 
like in: 
(At;:N.plus(t;,3))4 = plus(4,3). 
Substitution is extended to these new abstraction and application terms by 
{Xv:(T.M)[L/w] 
= 
Xv:a.{M[L/w]) 
{MN)[L/w] 
= 
{M[L/w]){N[L/w]) 
under the (usual) proviso that v is not free in L (to avoid that a variable which 
is free in L becomes bound after substitution; this can always be avoided 
by a change of name of the bound variable v in Xv.a.M). 
We write = to 
indicate that this involves a syntactic identification. One further extends the 
conversion relation = to become an equivalence relation which is compatible 
with abstraction and application in the sense that 
T,v:a 
\- M = M'-.r 
r \- Xv.a.M 
= Xv. a. M'\ a -^ r 
T \- M ^ M':a-^T 
T h N z=, N':a 
r 
b MN 
^M'N':T 
see [13]. The first of these rules is often called the (^)-rule. 
Thus, A1(E) extends the signature E with means for introducing functions 
and applying them to arguments. This calculus gives rise to a syntactically 
constructed category Cfl(E), called the Al-classifying category of E. Its 
objects are contexts 
V = [vi\ai,.. 
..Vn'.cTn) 
with 
C T J E T I . 

136 
Chapter 2: Simple type theory 
Note that the Al-classifying category has arrow types occurring in its objects. 
A morphism F -^ A in ffl(E), where A = [VI'.TI, ... ^Vm'-Tm), is an m-tuple 
of equivalence classes (with respect to conversion =) of terms 
{[Mil...,[Mm]) 
with 
r l-Miin in A1(E). 
Thus a second difference between the Al-classifying category (XI(E) and the 
classifying category Cl[Ti) described Section 2.1, is that in the former one takes 
equivalence classes of terms—instead of terms themselves—as constituents of 
context morphisms. 
2.3.1. Proposition. The \l-classifying 
category (X1{T,) of a signature E has 
finite products. If T — |E| is the underlying set of types of T^, then (X1(E) 
together with the set of types T\ (obtained by closing the set of basic types T 
under —^) is a CT-structure (see Definition 1.3.2); it is non-trivial if and only 
ifT is non-empty. 
Proof. Finite products in Cfl(E) are as in Cf(E): the empty context is ter-
minal and concatenation of contexts yields Cartesian products. The inclusion 
Ti <^ Obj(Xl(E) involves identification of a type a with the corresponding 
singleton context (i;i: cr). 
D 
The identification used in the proof is very handy. We shall freely make use 
of it and consider a type a as an object of a classifying category by identifying 
it with the singleton context 
(vi:a). 
The above proposition describes the context structure in Al-classifying cat-
egories in terms of finite products. An appropriate categorical description of 
the structure induced by the exponent types or -> r may be found in the next 
section. It uses that the pair (C^(E),Ti) is a CT-structure. 
Propositions as types 
Let T be a non-empty set, elements of which will be seen as propositional 
constants. And let Ti be the formal closure of T under —>, as above. The 
elements of Ti may be seen as propositions of minimal intuitionistic logic 
(MIL, for short), since they are built up from constants using only -> (or D) 
for implication. For cri,..., cr„, r G Ti we can write 
if T is derivable from assumptions cri,.. .,cr„ in minimal intuitionistic logic. 
The (non-structural) rules of MIL are ^-introduction and -^-elimination. 
Let A now be a collection of such sequents cri,..., cr„ h r, which we regard 
as axioms (with aj^r ET). That is, for each sequent 5 E ^ , we have a rule 

Section 2.3: Exponents, products and coproducts 
137 
expressing that S is derivable without further ado. We wish to consider which 
other sequents are derivable, assuming these axioms in A. For example, if ^ 
contains the sequent (p \- tp, then we can derive ip —> X ^ ^ —^ X ^^ follows. 
V ^ - > X h V ^ ^ X 
^ ^ X 
^^i^ -^x ^ i^ -^x 
^A^x^'^ 
^ ->x ^ ^^x 
Let E ^ be the signature constructed from a set A of axioms in the following 
way. Take the set T of atomic propositions as atomic types in E^, and choose 
for every sequent cri,..., (Xn h r in ^ a new function symbol F : cri,..., cr„ —y 
T. Think of F as an atomic proof-object for the axiom. 
If we assume in the above example a function symbol F'.(p —)• ip cor-
responding to the axiom (f> \- tp, then there is a A-term which codes the 
derivation, namely 
v:tp ^ 
X f" ^^' 
^' v{Fw): 
<^ —>• X-
More generally, one can prove that 
ci 5 • • •) CTn ^MiL T is derivable from A 
<^ there is a term M with viiai,... 
,Vn'-CTn h M: r in Al(E^). 
This gives an example of what is known as the paradigm of propositions-
as-types or better as propositions-as-types and proofs-as-terms. This 
perspective was first brought forward clearly in Howard [140], but goes back 
to Curry and Feys [65]. The above bi-implication ^ 
depends on the fact 
that derivations in MIL correspond directly to Al-terms. In particular, the 
introduction and elimination rules for implication in logic have the same form 
as the introduction and implication rules for exponents in type theory. 
As a result, provability 
in logic corresponds to inhabitation 
in type theory. A 
term M:a -^ r may be seen as a proof of the proposition cr -> r: M transforms 
each proof N:a 
of cr into a proof MN'.r 
of r. This is the so-called Brouwer-
Heyting-Kolmogorov interpretation of the ^-connective in constructive logic, 
see [140, 335]. This interpretation extends to finite conjunctions (T,A) and 
disjunctions (±, V), which, by including proofs, may be read as finite products 
(1, x) and coproducts (0, -f). Later in Section 8.1 we shall see how the quan-
tifiers V, 3 in predicate logic correspond to product Y\ and sum ]J of types 
over kinds in polymorphic type theory. 
The analogy between derivations and terms goes even further: the (/?)- and 
(r/)-conversions for Al-terms correspond to certain identifications on deriva-

138 
Chapter 2: Simple type theory 
tions, namely to: 
/ 
a \- T 
h (7 -> r 
a \- a 
a \- T 
: 
\ 
\- a 
a \- T 
h (7 -> r 
^ 
h ( 7 - ^ r 
/ 
Via (/?)-conversion one can thus remove an introduction step which is imme-
diately followed by an elimination step. And [r}) does the same for elimination 
immediately followed by introduction. For more details, see [280, 140]. 
(We have been overloading the arrow -^ by using it both for exponent 
types a ^ 
T and for implication propositions (f ^ 
il^. This is convenient in 
explaining the idea of propositions-as-types. But from now on we shall be 
using D instead of -> for implication in logic.) 
From the way the Al-classifying category (XI(E) was constructed, we im-
mediately get another correspondence: 
ci 5 • • • 5 cTn ^MiL ^ is derivable from A 
^ 
there is a morphism cri x • • • x cr„ 
r i n f f l ( E ^ ) . 
where we identify a with the singleton context {VI'.CT) in Cil{T>) as discussed 
after Proposition 2.3.1. Here we have an elementary example of propositions-
as-objects and proofs-as-morphisms. This basic correspondence forms the 
heart of categorical logic, as often emphasised by Lawvere and Lambek. 
XIX-calculi 
Let E be a many-typed signature. The calculus Alx(E) will be introduced as 
A1(E) extended with finite product types. This new calculus Alx(E) has all 
the rules of A1(E) plus the following type formation rules. 
her: Type 
l-r:Type 
h 1: Type 
\- a X T: Type 
We use 1 as a new symbol (not occurring in |E|) for singleton (or unit) type 
(empty product). Additionally, there are in Alx(E) the following associated 

Section 2.3: Exponents, products and coproducts 
139 
introduction and elimination rules for tupleing and projecting. 
r h M : ( 7 
r h7V:r 
^ 0-1 
r h {M,N):ax 
r 
r h P:a XT 
r h P:ax 
r 
T \-7rP:a 
T h TT'P: r 
Formally it would be better to give insert appropriate indices, as in 
TVCT^TP^ '^a T^^ t)ut that would make the notation rather heavy. 
Associated with these introduction and elimination rules there are the follow-
ing conversions. 
r h M : l 
r h M:cr 
T \- 
N:T 
T \- M = {):! 
r h 7r(M, 
N)^M:a 
r (- M:a 
r h N:T 
V [- 
P:aXT 
r h 7r'(M, N) = N:T 
T h (TTP, TT'P) = 
P:axT 
Substitution is extended to the new terms by 
0[L/v] 
= 0 
{M,N)[L/v] 
= 
{M[L/v],N[L/v]} 
{wP)[L/v] 
= 7r{P[L/v]) 
{ir'P)[L/v] 
= 
7r'(P[L/v]). 
We continue to write = for the compatible equivalence relation generated by 
the above conversions plus the (/?)- and (77)-conversions of Al. 
The advantage of having finite product types around is that one no longer 
needs to distinguish between contexts and types. Terms with multiple vari-
ables 
vi'.ai,.. 
.,Vn:(Tn ^ M:T 
correspond bijectively to terms with a single variable 
vi:ai 
X • • - X an \- N:T 
where the product type cri x • • • x cr„ is the singleton type 1 if n = 0. 
We thus define the Alx-classifying category 
fflx(S) 
of E with 
objects 
types a, built up form atomic types and (1, x, -^). 
morphisms 
a -^ r are equivalence classes (with respect to conversion) 
[M] of terms vi:a 
\- 
M:T. 
The identity on a is the equivalence class of the term vi'.a 
\- vi:a 
and com-
position involves substitution. 
2.3.2. Proposition. The Xl^-classifying 
category Cilx{^) 
of a signature 
E 
is Cartesian 
closed. 

140 
Chapter 2: Simple type theory 
Proof. It is easy to see that the type 1 is terminal and that the product 
type (J X r is a Cartesian product of a and r in fflx(S). This holds, almost 
by definition of 1, x. It will be shown that the exponent type a -^ r is the 
exponent object in 
Cilxi^)-
Assume an arrow p x a —^ r in (XIx{^), say given by a term 
z:p X a \- 
M:T. 
Then one can form the abstraction term 
x:p \- Xy: a. M[{x, y)/z]:a -> r 
which supports the following definition of categorical abstraction. 
A([M]) = [Xy:a.M[{x,y)/z]]: 
p-^ 
{a ^ 
r). 
Remember that the outer square braces [—] denote the equivalence class with 
respect to conversion and that the inner ones are part of the notation for 
substitution. In a similar way, the term 
w: (a -^ T) X a h {7rw){7r'w): r 
gives rise to the evaluation morphism 
ev := [ (7rw)(7r'w) ] : (cr —>• r) x cr —y r 
The categorical (/?)- and (77)-conversions follow from the syntactical ones: first, 
for z: p X a, 
ev o A([M]) X id = [ {7rw)('K'w)[{{\y: a. M[{x, y)/z])[7Tz/x],7r'z)/w] ] 
= 
[{Xy:a.M[{7rz,y)/z])(7r'z)] 
= 
[M[{nz,7r^z)/z]] 
= [M] 
and 
A(ev o [A^] X id) = 
[Xy:a.(7rw)(7r'w)[{N,y)/w]] 
= 
[Xy.a.Ny] 
= [N]. 
D 
Al(x,-I-)-caicuii 
In a next step we form on top of a signature E a calculus Al(x,-i-)(5]) which has 
exponent and finite product types as in Alx(E), but additionally Al(x,4-)(5^) 
has finite coproduct types (also called disjoint union types). This means that 
there are additional type formation rules: 
h 0". Type 
h r: Type 
^ 0- "TyP^ 
h(7 + r:Type 

Section 2.3: Exponents, products and coproducts 
141 
where 0 is a new symbol for the empty type (or, empty coproduct). There 
are the following introduction and elimination rules for these coproduct types 
(0,+). 
r \- M:(T 
r h 
N:T 
r I- KM\a^T 
r h 
K'N:(T^T 
r i - P : c r + r 
T,x\a^Q:p 
T,y:T\-R:p 
r h unpack P a s [KX \n Q,Ky\n 
R]:p 
^'^'^ ^ {)'P 
Thus, instead of projections TT, TT' for products, we now have coprojections «:, K' 
for coproducts. The variables x m Q and y in R become bound in the "un-
pack" or "case" term unpack P as [KX in Q, Ac'y In 7^]. It can be understood as 
follows. Look at P:a -\- r; if P is in cr, then do Q with P for a:; else if P is in 
r, do R with P for y. This explains the conversions: 
T\-M:a 
T,x:a\-Q:p 
T,y:T\-R:p 
r h unpack KM as [KX in Q^n'y in R\ — Q[M/x\.p 
T^N'.T 
T,X'.(TY-Q:P 
T,y:T\-R:p 
r h unpack K^N as [KX in Q,K'y in /?] = R[N/y]:p 
r h P:(j-hr 
r,^:(j + r h R: p 
r h unpack P as [KX in i?[(«:x)/^], «:'i/ in R[{K'y)/z]] = P[P/z]:/? 
r,^:0 h M:p 
r,z:0 h M = {}:p 
The latter rule tells that in a context in which the empty type 0 is inhabited, 
each term M must be convertible to the empty cotuple {}. 
The following commutation result is often useful in calculations. 
2.3.3. Lemma. In the above calculus with coproduct types + one has the 
following comLmutation conversion. 
T\-P:a-\-T 
T,x:(ThQ:p 
T,y:ThR:p 
T,z:phL:p 
r h L[(unpack P as [KX in Q.K'y in Pi\)/z\ 
— unpack P as [KX in L[Q/z\,K'y in L[R/z\]\p 
It tells that cotupleing (or unpacking) commutes with substitution. 

142 
Chapter 2: Simple type theory 
Proof. Because 
L[(unpack P as [KX in Q,K'y in 
R])/z] 
=: L[(unpack w as [KX in Q.^'y 
in 
R\)lz\[P/w] 
— unpack P as\KX 
in L[(unpack KX as [KX in Q,K'y in i?])/2:], 
/^'t/ in L[(unpack K^y as [«:a: in Q.K'y in i?])/^:]] 
= unpack P as [KX in ^[Q/^:], K'?/ '" ^[^/'^]]- 
^ 
Such a commutation conversion is typical for "colimit" types, like +, E, 
quotients and equality (which are described categorically by left adjoints). We 
use it for example in the proof of the next result, establishing distributivity 
of X over + in type theory. Essentially, this follows from the presence of the 
"parameter" context F in the above +-elimination rule. The second point 
gives a type theoretic version of the argument sketched in Exercise 1.5.6 (i) 
and (ii). 
2.3.4. P r o p o s i t i o n , (i) Type theoretic 
coproducts + are automatically 
dis-
tributive: 
the canonical 
term 
u: {a X T) -\- [a X p) h P{u) 
= 
unpack u as [KX in {nx, Ac(7r'x)), K^y in (Try, K'{7r^y))] : a x [r -\- p) 
is invertihle—without 
assuming 
exponent 
types. 
(ii) Type theoretic 
coprojections 
K,K' are automatically 
"injective": 
the 
rules 
T \- KM ^KM':a-\-T 
, 
T \-KN 
= 
KN':a-{-r 
an d 
T \- M = M':a 
T \- N = 
N':T 
are derivable, where — denotes 
conversion. 
Proof, (i) We have to produce a term "in the reverse direction": 
v: a X {T -i- p) \- Q{v): {a x r) -{• {a x p) 
with conversions P[Q{v)/u] 
= v and Q[P{u)/v] 
— u. First we notice that 
there is a term 
x\a,w\T-{- 
p h unpack w as [Ky in K{X^ y), K' z in K'{X, Z)] \ [a X T) -\- [a X p). 
Hence if we have a variable v.ax 
(r + /?), then we can substitute [7r^;/x] and 
[-K'V/W] in this term, so that we can define 
Q{v) — unpack 'K'V as [Ky in K{7rv^y),K^z in K'{7rv,z)]. 
Using the commutation conversions from the previous lemma, we show that 

Section 2.3: Exponents, products and coproducts 
143 
these terms P and Q are each other's inverses: 
P[Q{v)/u] 
= unpack TT'V as [ ny in 
P[K,{7rv,y)/u], 
K'z in P\K'i^-Kv, 
z)jv\\ 
— unpack -K'V as \Ky in {TTV^ ny)^ K'z in {'KV^K.'Z)] 
— 
{TVV^TT'V) 
— 
V. 
Q[P[u)lv] 
— unpack w as [ KO^ in Q^^'KX^ 
K.[TT'x))/v\, 
K'y in Q[{T^y,K,'{T^'y))lv]] 
— unpack u as [K.X in K{7rx,7r'x), K'y in «:'(7r?/, Tr'y)] 
= unpack u as [KX in KX, n'y in AC'T/] 
= 
u. 
(ii) For a variable tt;: ((j + r) x cr we define a term 
L(w) = unpack TTW as [KX in (a?, Tr'ti;), K'^/ in {K'W, TT'W)] : cr X a. 
Then for x^ z:a we get a conversion 
L[{KX^ Z)/W] = unpack KX as [/ex in (x, z), hc'y in (z, z)] = {x, z). 
Hence we reason as follows. For terms F h M, M ' : cr, 
KM = K M ' => ( K M , M) = {nM', M) 
:=> {M, M) 
= L [ ( K M , M ) / H = L[{KM\ 
M)IW\ 
= (M', 
M) 
^ 
Mr=7r(M,M> = 7r(M',M) = M ' . 
D 
We also describe classifying categories C^l(x,+)(^) involving type theoretic 
exponents, finite products and coproducts. The definition is as for C^lx(S) 
above: types—but this time also with finite coproducts—are objects and mor-
phisms cr —> r are equivalence classes [M] of terms vi'.cr h M: r—where 
the 
conversion relation of course includes the above conversions for finite coprod-
ucts. 
2.3.5. P r o p o s i t i o n . Categories 
ffl(x,+)(S) 
are Cartesian 
closed and have 
finite 
coproducts. 
Such a Cartesian closed category with finite coproducts is sometimes called 
a bicartesian closed category (BiCCC). 
Proof. Cartesian closure is obtained as in the proof of Proposition 2.3.2. We 
concentrate on finite coproducts. 
The empty type 0 is initial object in C^l(x,+)(^)5 since for every type cr 
we have a term z:0 h {}:cr. And if there is another term z:^ h M:cr, then 
z:0 h M = {}:(7, so that [M] ^ [{}]: 0 - ^ cr in 
ffl(x,+)(S). 

144 
Chapter 2: Simple type theory 
The coproduct type a+r is also the coproduct object: there are coprojection 
maps a -^ {a + T) <— T given by terms 
x:a \-K,x:a-\-T 
and 
y.T V-tz'y.a-\-r 
And for each pair of morphisms a ^ p, r -^ p, say described by 
x:ahQ:p 
and 
y.rhR'.p 
we have a cotuple a -\- r -^ p given by the unpack term 
z:a -\- T h unpack z as [KX in Q, hc'y in R]: p. 
• 
With this proposition in mind, the above Lemma 2.3.3 can be understood 
as saying that for f:a -^ p, g:T -^ p and h: p -^ p one has h o [f^g] = [h o 
f,ho 
g]—where the square braces [—, —] are used for (categorical) cotupleing. 
Distributive 
signatures 
In this section we have seen various ways of forming new types starting from 
a set of atomic types. Signatures as first introduced in Definition 1.6.1 involve 
function symbols F: cri,..., cr^ —> (Jn+i where each aj is an atomic type. This 
restriction to atomic types cr,- is not really practical. For example, a signature 
for natural numbers with zero, addition and predecessor may be given by an 
atomic type N and function symbols 
0 : 1 — ^ N , 
plus:Nx N — > N , 
pred:N—>1 + N 
involving the derived (non-atomic) type NxN and l + N. Here, the construction 
1 + (—) is used to deal with partial operations: the predecessor pred yields an 
outcome in 1 if applied to zero, and in N otherwise. Similarly one can describe 
a subtraction function symbol min: N x N —> 1 -f- N via coproducts. 
In order to get this kind of expressiveness, one needs to have functions sym-
bols F: (Ti,..., CT„ —y o-n+i, where the (TJ may be formed from atomic types 
using finite products and coproducts. This leads to what we call distributive 
signatures, see [160]; they are called distributive graphs in [342]. Notice that 
in the presence of finite product types (1, x) we may restrict ourselves to 
function symbols F: a —> r with precisely one input type. This leads to the 
following description, which is much like Definition 1.6.1. 
2.3.6. Definition. For a set T (of atomic types) let us write T for the closure 
of T under finite products (1, x) and coproducts (0, +). A category DistrSign 
of distributive signatures is defined by the following change-of-base situa-

Section 2.3: Exponents, products and coproducts 
145 
tion. 
D i s t r S i g n 
>- Fam(Sets) 
J 
I 
Y 
Sets 
————^ 
Sets 
T i - > T X T 
There are special kinds of distributive signatures which are useful to de-
scribe inductively and co-inductively defined types. These will be called 
H a g i n o s i g n a t u r e s , after [111, 110, 112]. They occur in two forms, namely 
the inductive form and the dual co-inductive form. Here we only give the 
description of these Hagino signatures. They will be further investigated in 
Section 2.6 in STT, and also in Section 8.2 in P T T . 
2.3.7. Definition. Let T be a set (of atomic types) and X a fresh symbol 
which is not in T. It serves as a type variable. A H a g i n o s i g n a t u r e is a 
distributive signature with one single function symbol, which is either of the 
form 
constr 
destr 
cr 
^ X 
or 
X 
>- o-
where cr is a "Hagino" type in the closure T U {X} of T U {X} under finite 
products and coproducts. Sometimes we shall write (T{X) for cr to emphasise 
the possible occurrence of X in cr. 
In case this cr(X) is of the form o'i{X) -[-••• + cr„(X) the constructor constr 
may be understood as an n-tuple of function symbols constrj (X): CTJ —> X. 
Dually, if (T[X) is of the form (T\{X) 
X • • X cr„(X) the destructor destr cor-
responds to an n-tuple destrfiX —> ai[X). 
Examples of Hagino signatures are 
l-\- X —> X 
for natural numbers 
1 -h a X X —y X 
for finite lists of type a 
X —> a X X 
for streams (or infinite lists) of type a. 
In the first case the constructor is understood as the cotuple [0, S]: 1 -hX ^ 
X 
of zero and successor. And for the finite lists one has a constructor nil: \ -^ X 
for the empty list and a constructor cons: ax X -^ X which turns an element 
of type a together with a list into a new list. In the third example one has 
two destructors: one for the head and one for the tail of an infinite list. 
As another example, one can use these Hagino signatures to describe the 
connectives in propositional logic, for example with (cotupled) constructors: 
[T,A,±,V,D] 
1 -h (X X X) -h 1 + (X X X) -f (X X X) 
^ X 

146 
Chapter 2: Simple type theory 
The idea behind a Hagino signature of the form o- -^ X is that X is the free 
type generated by the constructor. Later in Section 2.6 it will be described as 
a suitably initial fixed point o'{X) -=)• X of an associated polynomial functor 
X ^ 
a{X) 
where we have written the occurrences of X in cr explicitly. And in the dual 
case X —^ a one thinks of X as the cofree type generated by the destructor. It 
corresponds to a fixed point X -^ cr(X), which is terminal in a suitable sense. 
Finally, there is no need to restrict oneself to the finite product and coprod-
uct type constructors in defining a category of signatures. One can also use 
exponent types; this leads to so-called higher type signatures, see e.g. [275]. 
Exercises 
2.3.1. 
Let Zl be a signature. Define finite product preserving functors 
am — ^ cii{T.) — ^ cei^(E) — ^ m(x,+)(i:). 
2.3.2. 
(i) 
Give a proof of the above propositions-as-types bi-implication relating 
provability in MIL and inhabitation in Al. 
(ii) Formulate and prove similar results for Alx and Al(x,+). 
2.3.3. 
Give the precise correspondence in Alx between terms vi: ai,... 
,Vn-o'n \-
M: T in contexts of arbitrary length and terms vi:{ai x - - - x an) \- N:T in 
contexts of length one. 
2.3.4. 
Give a concrete description of the category DistrSign of distributive sig-
natures. 
2.3.5. 
Consider the following alternative description of a classifying category, say 
CEl',^ ,x(E), with prime '. Objects are types a as in (^l(x,+)(E)) but as 
morphisms cr —> r we now take equivalence classes [M] of closed terms 
h M:(T —)• T. Show that one gets a category CflJj<^)(E) in this way and 
that it is isomorphic to the category Cfl(x,+)(^) described above. 
2A Semantics of simple type theories 
In the previous section we introduced firstly Al-calculi with exponent types, 
and secondly the (slightly) more complicated calculi Alx and Al(x,+), which 
are obtained by adding finite product and coproduct types. The (categorical) 
semantics of such calculi will be described in reverse order. The Alx-calculi 
have a straightforward (functorial) interpretation in Cartesian closed cate-
gories, as described e.g. in [186, 63, 61]. The finite product and exponent 
types in the calculus can be interpreted simply as finite product and expo-
nent objects in a Cartesian closed category. Similarly, Al(x,-i-)-calculi can be 

Section 2.4' Semantics of simple type theories 
147 
interpreted in bicartesian closed categories (which additionally have finite co-
products). 
The semantics of Al-calculi—with exponent types only—is more subtle, 
since there is no identification of contexts and types involved. As a result 
there is no straightforward way to describe exponent types cr —)-(—) as right 
adjoints to product type functors ax (—). Whereas there are no finite products 
of types in Al, one does have finite products of contexts 
(given by concate-
nation). Especially there are context projections n:{T,v:a) 
—)• T, inducing 
weakening functors TT*, which add an extra dummy variable v: a. It turns out 
that exponent types cr —)• (—) can be captured categorically as right adjoints 
to such a weakening functors TT* in simple fibrations. This approach does not 
rely on product types a x r. Actually, these product types a x {—) can be 
captured dually as left adjoints to these 7r*'s. This view on exponents and 
products in the simple type theory comes from [156]. 
Unravelling the structure induced by right adjoints to 7r*'s leads to an el-
ementary formulation in Lemma 2.4.7 of what a 'Al-category' is. It will be 
useful in the next section on the untyped A-calculus. 
But, as promised, we start with the calculi Alx and Al(x,-i-)- Let CCC 
denote the category of Cartesian closed categories and functors preserving 
this structure. Similarly, let B i C C C ^-> CCC be the subcategory of Carte-
sian closed categories with finite coproducts, and functors preserving all this 
structure. Recall from Propositions 2.3.2 and 2.3.5 that the classifying cate-
gories C^lx(S) and ffl(x,+) are objects of CCC and B i C C C respectively. 
2.4.1. Definition. Let E be a signature. A model for the calculus Al^ (S) 
in a Cartesian closed category A is a functor 
M 
m x ( S ) 
^ A 
in C C C . 
Similarly, a model of Al(x,+)(^) in a bicartesian closed category A is a functor 
M 
m ( x , + ) ( S ) 
>• A 
in B i C C C . 
We have a closer look at what a model is in the bicartesian closed category 
Sets of sets and ordinary functions. Suppose [ —]]:C^l(x,+)(^) -^ Sets is such 
a model. It involves 
• a model of the signature E in Sets. Formally it is obtained by pre-
composition with the inclusion functor (X(E) M- Cfl(x,+)(E) described in 
Exercise 2.3.1. 
• a one-element, terminal set [[ 1]] = {*} and the empty set [[Oj = 0. 
• binary products [[o-x r ] = [[o"]] x [[r] and coproducts [[cr-fr]] = [[cr]]-|-[[r]] 

148 
Chapter 2: Simple type theory 
of sets (where the coproduct + of set is given by disjoint union). 
• function spaces [cr -^ r ] ^ [[r]]!'''. 
But Definition 2.4.1 covers models in any bicartesian closed category—and 
not just in Sets. The last three points are then modified according to the 
particular BiCCC-structure of the category involved. 
There are results (similar to Theorem 2.2.5) for Alx and Al(x,-i-) which give 
a correspondence between functorial models and morphisms of signatures. 
We merely state these results here and leave the proof to the meticulous 
reader. Recall that for a category B with finite products there is an associated 
signature Sign(B), see Lemma 2.2.4. 
2.4.2. Theorem. Let E 6e a many-typed signature. 
(i) For a Cartesian closed category B there is a bijective correspondence 
(up-to-isomorphism) 
between morphisms of signatures and models in 
<f> 
E 
5- Sign(B) 
in Sign 
aix{E) 
^ B 
2n CCC 
M 
(ii) Similarly, for a Cartesian closed category C with finite coproducts there 
is a correspondence 
S 
>- Sign(C) 
in Sign 
m(x,+)(S) 
>• C 
in BiCCC 
^ 
We turn to Al-calculi. Their categorical semantics will be described in terms 
s(T) 
of a simple fibration 
i 
associated with a CT-structure (B, T). We recall 
from Section 1.3 that the latter consists of a category B (of contexts) with 
finite products and a collection (of types) T C Obj B. Such a CT-structure is 
non-trivial if there is a type X E T and an arrow \ ^ X from the terminal 
object 1 G B to X. 
First we describe how simple quantification, as described in Section 1.9, 
extends to these CT-structures, yielding quantification over types [i.e. over 
objects in T). 
E 
2.4.3. Definition. Let (B, T) be a CT-structure and 
^ 
a fibration. We say 
that p has simple T-products if for each / G B and X £T, every weakening 
functor 7T} -^'.Ej -^ E/xx induced by the projection TT/^X-^ X X —>- / has a 
right adjoint Y[(i x)—P'^^ ^ Beck-Che valley condition as in Definition 1.9.1. 

Section 2.4' Semantics of simple type theories 
149 
Similarly one defines simple T-coproducts 
in terms of adjunctions 
So in defining products and coproducts with respect to a CT-structure 
(E, T) we restrict the projections T T / X - ^ X X 
-^ / along which one has 
quantification, to those with X 
£ T, the set of types. Thus we quantify 
over types only, and not over all contexts. The simple products and coprod-
ucts as described in Definition 1.9.1 come out as special case, namely where 
T — Obj B. The other extreme, where T is a singleton, will also be of im-
portance, namely for the untyped A-calculus and also for the second order 
polymorphic A-calculus A2. 
We have prepared the grounds for a categorical description of exponent 
types —)-, without assuming Cartesian product types x. Notice that we do 
assume Cartesian products in our base categories, but these correspond to 
context concatenation. For convenience, we restrict ourselves to the split case. 
2.4.4. Definition ([156]). (i) A Al-category is a non-trivial CT-structure 
s(T) 
(B, T) 
for which the associated simple fibration 
4- 
has split simple 
IB 
T-products. 
(ii) A morphism of Al-categories from (B, T) to (B',T') consists of a 
morphism of CT-structures /i:(B, T) -> (B',T') whose extension to a mor-
s(T) 
S(T') 
phismof fibrations 
i 
-^ 
^, 
(see Lemma 1.7.6) preserves simple products. 
The content of this definition is that the exponent types of a Al-calculus 
are simple products (with respect to the set of types). Before going on, let us 
check that this works for syntactically constructed classifying categories. 
2.4.5. Example. Let S be a signature with non-empty underlying set T — 
|D| of atomic types. The latter ensures that the associated CT-structure 
(C^l(E),Ti) is non-trivial, see Proposition 2.3.1. Consider the resulting fi-
bration 
i 
. For each context F G Cfl(E) and type cr G Ti, the projection 
morphism TT: F x cr ^ F in C^l(E) gives rise to the weakening functor between 
the fibres: 
given by 
s(Ti)r 
^ s(Ti)rxcr 
(F,/>) ^ 
(Fxc7,p) 
{Vxpi—ip2) 
^ 
( F X CTXpi - ^ / ? 2 ) . 

150 
Chapter 
2: Simple 
type 
theory 
i.e. by 
f 
(l-/>:Type) 1-^ (hpiType) 
\{T,z:pi 
h M:p2) 
^ 
{T,x:a, 
z: pi \- M: P2). 
This TT* adds an extra hypothesis of type a. We should define a right adjoint 
n(r,a) 
s(Ti)rxa 
^ s(Ti)r 
in the reverse direction. It naturally suggests itself as 
(r X (7, r) ^-^ (r, (7 -> r) 
i.e. as 
( h r: Type) 1-^ ( h cr -^ r: Type). 
We then have to establish a bijective correspondence 
[M] 
7r*{T,p) = ( r X <T,p) 
^ ( r X <r, r) 
(r,p) — f T ^ ( r , < T ^ r) = n ( r , . ) ( r x <T,r) 
between terms M, A^ in 
T,z:p 
\- N:a -^ T 
It is given by abstraction and application: 
M y-^ Xx-.cr.M 
and 
N ^ 
Nx. 
The fact that these operations are each others inverse corresponds precisely 
to the (/?)- and (7;)-conversions described in the previous section. We conclude 
that (C^l(E),Ti) is a Al-category. 
In view of this example, and in analogy with Definition 2.2.2, the following 
definition describes functorial semantics for Al. 
2.4.6. Definition. Let E be a signature with 5 = |E| as set of atomic types. 
A Al-model is a morphism of Al-categories M\ ((X1(E), Si) —> (IB, T). 
Next we give a more amenable description of Al-categories. 
2.4.7. Lemma. Let (B, T) he a non-trivial 
CT-structure. 
The following 
two 
statements 
are 
equivalent. 
(i) The pair (B, T) forms a 
Xl-category. 
(ii) The collection T C Obj B is closed under exponents. 
That is, for types 
X,Y 
E T there is an exponent type X => Y E T together with an 
evaluation 
morphism 
ew: {X =^ Y) x X -^ Y such that for each object / G B and map 

Section 2.4-' Semantics of simple type theories 
151 
f: I X X -^ Y inM there is a unique abstraction map A(/): I —^ X => Y with 
ev o A(/) X id = /. 
Proof, (ii) => (i). For I £ M and X G T we can define a product functor 
!!(/x)*^(^)^x^ ~^ ^(^)^ by y 1-^ X => y. Then we get correspondences in 
the fibres: 
^/ xi^) 
— ^ 
^ Y 
over I x X 
{I xX)xZ 
^ y 
IX z — ^ X =^y 
in B 
in IB 
^U(TX)i^) 
over/ 
i{I,X) 
This describes (simple product) adjunctions 7r*j -^ -\ Y[(j x)-
(i) => (ii). For types X,Y 
£ T, we consider Y as an object (1 x X,y) of 
the fibre over 1 x X and thus we can take 
^^>'='n(i,x)(ner. 
Notice that for an object / € IB, reindexing along !/: / —^ 1 in B yields 
X^Y 
= 
\}{X^Y) 
= !}(n(i,x)W) 
= n(/,x)(('/><id)*(y)) by Beck-Chevalley 
- nii,x)iy)-
The counit (at Y) of the adjunction "TJ x "^ Y[(i x) ^^ ^ morphism 
Uii,x)iy)— 
- y 
in the fibre over I x X. For / = 1, it forms a map in B 
(ix^)xn(i,x)(n—-—-y 
Hence we can define an evaluation map 
evx.y = {{X ^Y)xX 
J 
^ {I x X) x (X ^ Y) -^-^ 
y ) 
The definition of abstraction is a bit tricky. Since (B, T) is by assumption 
non-trivial, we may assume an object Z £ T with an arrow ZQII -^ Z. 

152 
Chapter 2: Simple type theory 
For a map /: / x X -> Y in B (with / G B and X, Y G T) one has 
f o7r:{I X X) X Z -^ Y in B and thus / o 7r:7r}j^{Z) -> Y in the fibre 
over I X X. Taking the transpose across the adjunction T^} x ~^ Ylii x) 
yields a morphism (/ o ny-.Z 
-^ Il(i x)0^) 
^^ ^(^)^- ^^ noticed above, 
X =>Y = U{i,x)0') 
^^^ ^hus {f o Try: i X Z -> X ^ Y inM. Hence we take 
(id, zoo!) 
ifony 
A(/) 1^^ (/ 
/ X z 
x^y) 
(The auxiliary type Z is first used to introduce a dummy variable which is 
later removed by substituting ZQ.) 
The validity of the categorical (/?)- and (77)-equations follows from com-
putations in the fibres. We shall do (jS) and write • for composition in the 
fibres. 
ev o A(/) X id 
= 4''""^ "> ((^7r0,7r) o A ( / ) x i d 
= 4''^^ o (!j X id) X id o (id, A(/) o TT) 
= (!/xid)*(4'^^) o (id,A(/)o7r) 
= 4^'^) o (id, A(/) o TT) 
= 4 ' ^ ^ ^ ( i d ' n ( / , x ) ( / ^ ^ ) ^ (^'^z'^^) ^ (id, 2:00!) o TT) 
= 4 ' ^ ^ o (TT, ll{i,x)if 
o TT) o TT X id) o (TT, 7/^^'^^ o TT X id) 
o (id, ZQ O !) 
= ( / O ' T ) • 4^;'^(z) • ^*i,xiVz'^^) 
° (id,2o o!) 
— (/ o TT) • id o (id, ZQ O !) 
— f o TV o (id, 20 o!) 
= /• 
° 
2.4.8. Corollary (Proposition 1.9.3 (ii)). A category B with finite products 
s(l) 
25 Cartesian closed if and only if the simple fibration i 
on B has simple 
products (I.e. forms a W-category). 
Proof. Take T = Obj B in Lemma 2.4.7. 
• 
The semantics of Alx-calculi can thus be seen as a special case of Al-calculi 

Section 2.4- Semantics of simple type theories 
153 
(where the collection of types T contains all objects). The other extreme where 
T is a singleton describes the semantics of the untyped A-calculus; this will 
be the subject of the next section. 
We close this section with an example of a Al-category, involving Scott-
closed subsets as types. 
2.4.9. Example. Let D be a directed complete partial order (dcpo). Non-
empty closed subsets X C D (with respect to the Scott topology) are often 
called ideals.. They are the non-empty directed lower sets X, satisfying (i) 
X / 0, or equivalently, ± G X, (ii) x < y ^ X 
=> x ^ X^ and (iii) directed 
a C. X 
=> y^ a £ X. We show that ideals can be used (as types) to model 
simply typed calculi with exponents (provided one has an interpretation of 
the signature). Therefore, we form a base category M with finite sequences 
{Xi,..., 
Xn) of such ideals Xi as objects. These sequences may be understood 
as contexts. A morphism ( X i , . . . , X „ ) —> (Yi,.. 
.,Ym) 
in M is given by a 
sequence (/i,. •., /m) of continuous functions fj: D^ ^ D satisfying fj[X] 
C 
Yj. That is, for all xi G Xi, one has fj{x) 
G Yj. The empty sequence is then 
terminal object in B and concatenation of sequences yields Cartesian products 
inB. 
Now let us assume that D is reflexive, i.e. that it isomorphic to its own space 
of continuous functions [D -^ D], via continuous maps F\D -^[D 
-^ D] and 
G:[D ^ 
D] ^ 
D satisfying F o G = id and G o F = id. An example of 
such a dcpo is D. Scott's JDQO, see [301, 13]; it forms a model of the untyped 
A-calculus, as will be explained in the next section. In a standard way one 
forms an exponent of ideals X^Y 
C D by 
X => y = {z G DI Vx G X. F{z)[x) G y}. 
One easily verifies that X => y is an ideal again. 
Let T C Obj B be the collection of ideals [i.e. of sequences of length one). 
One obtains a CT-structure (B, T). We claim that it is a Al-category. Using 
the above Lemma 2.4.7 this is readily established: one has an evaluation map 
%xy.F{x){y) 
ev = {{X => Y, X) 
^ 
Y) 
And for / : (Z, X) -^ Y one takes as abstraction map 
A{f) = (Z 
{X => Y)) 
Exercises 
2.4.1. 
Verify that the Beck-Che valley condition in Example 2.4.5 corresponds pre-

154 
Chapter 2: Simple type theory 
cisely to the proper distribution of substitution over abstraction and appli-
cation (as described in the previous section). 
2.4.2. 
Check the (r7)-conversion A(ev o ^ x id) = g in the proof of Lemma 2.4.7. 
2.4.3. 
Extend Lemma 2.4.7 to morphisms, in the sense that a morphism of 
Al-categories corresponds to a morphism of CT-structures which preserves 
the relevant exponents. 
2.4.4. 
Show that the inclusion functor Cil{E) M- (^lx(2) extends to a morphism 
of Al-categories. Conclude that every Alx(I^)-model is a Al(E)-model. 
2.4.5. 
Consider a model M of a. propositional logic £ in a certain poset (X, <), for 
example in a Heyting algebra. Show that such an M can also be understood 
as a functorial model M: LA(£) -> X, from the Lindenbaum algebra LA(£) 
of propositions (modulo (f ^ xp '^ ip \- ip and t/^ h (/?) into X. Check 
that interpretation of the logical connectives T,A,D etc. corresponds to 
preservation of this structure by M. 
2.4.6. 
Let (B, T) be a Al-category. Define T to be the smallest collection contain-
ing T which satisfies 
1 G f 
and 
X,Y ef 
=^ X xY 
ef. 
Hence T is obtained by closing T under finite products. Let T also denote 
the full subcategory of B with objects in this collection. 
(i) 
Show that T is Cartesian closed. 
(ii) Show that—as a result—Al-classifying categories Ci^l(E) are Cartesian 
closed. Describe an exponent {vi: (TI^V2:(T2) => {vi: TI, t?2: T2, t^s: TS) ex-
plicitly. 
2.4.7. 
Let (B, T) be a CT-structure. Show that the associated simple fibration 
<T) 
i 
has simple T-coproducts ]J if and only if the collection of types T is 
closed under biuciry products x. Hence binary product types are described 
by left adjoints to weakening functors. 
[Detciils of the proof may be found in [156].] 
2.4.8. 
Formulate and prove a result like Theorem 2.4.2 for Al-categories. 
2.5 Semantics of the untyped lambda calculus as a corollary 
As a general point v^e observe that untyped can be identified v^ith typed in a 
universe with only one type. In the untyped A-calculus (see [13]) one can build 
terms from variables v via application MN and abstraction Xv,M^ without 
any type restrictions (because there are no types). We can see this untyped 
A-calculus as a (typed) Al-calculus with a single type Q satisfying Q == Q —> Q. 
Every untyped term M{v) can then be typed as t;i: Q, ...,!;„• ^ h M:Q. 
The notions and results developed for the simply typed A-calculus in the 
previous section are based on CT-structures. Specialising to such structures 
with only one type {i.e. to the single-typed case) yields appropriate notions for 

Section 2.5: Semantics of the untyped lambda calculus as a corollary 
155 
the untyped A-calculus. This constitutes a precise mathematical elaboration of 
the point of view—stressed by D. Scott—that the untyped A-calculus should 
be seen as a special case of the (simply) typed one. The notion of 'A-category' 
that we arrive at through this analysis, is in fact a mild generalisation of an 
early notion of Obtulowicz, see [233, 235]. More information on the semantics 
of the untyped A-calculus can be found in [301, 303, 304, 221, 181, 13, 186, 
63, 156, 158, 274]. 
2.5.1. Definition. A A-category is a category B with finite products con-
taining a distinguished object Q G B, such that the (single-typed) CT-struc-
ture (B, {^}) 
is a Al-category, i.e. such that simple 
fibration 
4- 
has simple 
IB 
Q-products. 
The following is then a special case of Lemma 2.4.7. 
2.5.2. Lemma. Let M be a category with finite products and let Q £ M be a 
non-empty 
object (I.e. with non-empty 
hom-set 
B ( 1 , Q ) / The pair (B, 1}) is 
then a X-category if and only if there is a map app: Q x ^ -^ ^ such that for 
each f: I X Q ^ Q there is precisely one A(/): / —)• Q with app o A(/) x id == / . 
Proof. Lemma 2.4.7 requires the singleton set {Q} of types to be closed under 
exponents. This is the case if and only if Q itself is the exponent Q => Q. The 
result follows easily by reading app for ev and A(/) for A(/) in the formulation 
of Lemma 2.4.7. 
• 
2.5.3. Examples, (i) Consider a signature with one atomic type Q and no 
function symbols. Identify the exponent type Q -^ Q with Q. In the resulting 
Al-calculus on this signature we can provide every untyped term M(v) 
with 
a typing i;r. Q , . . . , t;„: Q h M:Q. 
The classifying Al-category can then be 
described as follows. 
o b j e c t s 
n G N. 
morphisms 
n ^ 
m are m-tuples ( [ M i ] , . . . , [M^]) of/^ry-equivalence 
classes of untyped A-terms Mi with free variables among 
Vi,...,Vn. 
The object 0 is then terminal and n-f-m is the Cartesian product of the objects 
n and m. The object 1 plays the role of fi in the above lemma: there is an 
application map 
/ 
[^1^2] 
. 
app = ( 2 
^ 1 ) 
And for each morphism [M]: n -h 1 —>• 1 there is an associated abstraction map 
[XVn-^l.M] 
A([M]) = (n 
1) 

156 
Chapter 2: Simple type theory 
satisfying the required properties. 
The result is a categorical version of what is called the closed term model 
in [13]. It is the (pure) A-classifying category; 'pure', because there are no 
function symbols involved. 
(ii) Let D be a dcpo which is "reflexive", 
i.e. which is isomorphic to 
the dcpo of its own continuous endofunctions, i.e. D = [D —^ D]^ say via 
continuous F:D ^ [D -^ D] and G:[D -^ D] -^ D with F o G = id and 
G o F = id, as in Example 2.4.9. The first example of such a D is D. Scott's 
Doo, see [301, 13]. It will be described as a Al-category. A base category D 
is formed with n G N as objects; the object n is the context consisting of 
n variables. Morphism n —^ m are sequences (/i,..., /m) where each fi is a 
continuous function D^ -^ D. Composition in D is done in the obvious way 
and identities are sequences of projections. The object 0 G ED is terminal and 
n -h m is a Cartesian product of n, m. As distinguished object ("fi") we take 
1 G O. Notice that 1 is a non-empty object since the set D is non-empty: it 
contains, for example, the identity combinator I = G{idD). 
One has app: 1 -[- 1 -> 1 as a continuous function D x D ^ D described by 
(x, y) H^ F{x){y). For /: n -h 1 ^ 1 in D one takes X(f){x) = G{%y. /(f, t/)), 
which yields a morphism n —^ 1. Then 
(appo A(/) X id)(x,z) = F{G{^y.f(x,y)))iz) 
= f(x,z). 
It is easy to see that A(/) is unique in satisfying this equation. 
(iii) The previous example can be generalised in the following sense. Let B 
be a Cartesian closed category containing an (extensional) reflexive object 
Q. This means that there is an isomorphism fi = (fi => fi), say via maps 
F: fi -> (fi => fi) and G: (fi =^ fi) -> fi with F o G = id and G o F = id. 
Then we can define application and abstraction operations, namely: 
/ 
ev o F X id 
x 
app = (^fi X 
fi 
^ fij 
And for /: / X fi -> fi there is: 
x(f) = (i 
n) 
One obtains a A-category as described in Lemma 2.5.2. 
The notion of a CCC with reflexive object was used by D. Scott as a cat-
egorical model of the untyped A-calculus. The above notion of A-category is 
more economical in the sense that it does not require all exponents in the am-
bient category, but only the relevant one, namely fi =^ fi. But a A-category 

Section 2.6: Simple parameters 
157 
can be described as a reflexive object in a richer (presheaf) environment, see 
Exercise 2.5.1 below. 
Obtulowicz [233, 235] introduced what he called a Church algebraic 
theory. 
It is a A-category (B, Cl) in which the collection of objects of B is of the form 
{Q^ I n E N}—as in Examples (i) and (ii) above. In fact, Obtuiowicz defined 
a non-extensional version, as in Exercise 2.5.2 below. 
Exercises 
2.5.1. 
Let B be a category with finite products and Q G B be a non-empty object. 
Show that (B, Q) is a A-category if and only if the associated represent able 
presheaf B( —, Q):B°^ —>• Sets is a reflexive object in the (Cartesian closed) 
("topos") category Sets 
of presheaves. 
[Familiarity with the Cartesian closed structure of Sets 
is assumed here; 
see Example 5.4.2. Especially with the fact that the Yoneda embedding 
X H-)- B( —, X) preserves exponents.] 
2.5.2. 
The formulation below is based on [156] and uses 
semi-adjunctions 
from [119]. These provide general categorical means to describe non-
extensionality. 
A non-extensional A-category is given by a non-trivial CT-structure 
(B, Q) such that the associated simple 
fibration 
4- 
has 'semi-products'; 
that is, every TT* Q has a right semi-adjoint and for every u: I —> J in M the 
pair {u*,{u x id)*) forms a morphism of semi-adjunctions. See [119] for the 
details of these 'semi' notions. 
(i) 
Show that a (non-trivial) CT-structure (B, Q) is a non-extensional 
A-category if and only if there is an application map app: Q x Q —> Q 
such that for each f: I x Q -^ Q there is a (not necessarily luiique) 
abstraction map A(/): / —>• Q subject to the equations 
app o A(/) X id = / 
and 
A(/ o ^f x id) = A(/) o g. 
(ii) Let D be a dcpo such that the continuous endofunctions [D —>• D] form 
a retract of D, say via F: D ^ [D -^ D] and G:[D ^ D] ^ D with 
F o G = id, but not necessarily G o F = id. An example of such a dcpo 
is Pu;, see [13]. Show that the construction in Example 2.5.3 (ii) applied 
to such a dcpo yields an example of a non-extensional A-category. 
2,6 Simple 
parameters 
In the preceding two sections we have been using simple fibrations for the 
semantics of simple type theory. Here we show how these simple fibrations can 
also be used to systematically describe data types with simple parameters. 
We shall first briefly describe finite coproducts with simple parameters, next 

158 
Chapter 2: Simple type theory 
natural numbers with simple parameters, and finally arbitrary inductively 
defined data types (as given by Hagino signatures) with simple parameters. 
For the latter we shall make essential use of so-called strong functors. This 
approach comes from [160], where it is presented in terms of simple slice 
categories (instead of simple fibrations). 
Recall that for a category IB with finite products there is a simple fibration 
s(l) 
4- on B, with fibred finite products. The fibre over / G IB is written as M//I 
and is called the simple slice over /. Its objects are X G IB, and its morphisms 
X ^ y are maps / x X -> Y in B. 
Distributive 
coproducts 
A coproduct object X + Y comes, by definition, equipped with (natural) 
bijective correspondences 
X 
^ Z 
Y 
^ Z 
X + Y 
^ Z 
Say we have coproducts with simple parameters if for each parameter 
object / G B there are bijective correspondences 
IxX 
^Z 
IxY 
^Z 
Ix{X 
+ Y) 
^Z 
natural in X^Y, Z. Then we have the following result. 
2.6.1. Proposition. Le^ B be a category with binary products x and coprod-
ucts + . The following statements are then equivalent, 
(i) B has coproducts with simple parameters (as described above). 
s(]B) 
(ii) The simple fibration 
i 
onM has fibred coproducts. 
(iii) B has distributive coproducts: the canonical maps 
(I xX) + {I X Y) 
^ / X (X + y) 
are isomorphisms. 
Proof, (i) ^ (ii). Almost immediate: the correspondence (*) above precisely 
says that each simple slice M//I {i.e. fibre over I) has coproducts. Preservation 
by reindexing functors is obvious. And (ii) <^ (iii) is Exercise 1.8.3 (i). 
• 
This correspondence between data types (coproducts in this case) with 
simple parameters and a fibred version of such data types in a simple fibration 
will be elaborated further. 

Section 2.6: Simple parameters 
159 
Natural 
numbers 
Recall that in a category with finite products a natural numbers object 
(NNO) consists of a zero and successor diagram 
0 
S 
1 
^ N 
^ N 
which is initial in the sense that for an arbitrary diagram of the form 1 -^ 
X A x 
there is a unique h: N —^ X making the following diagram commute. 
0 
^ A^ 
^ N 
I 
I 
\ h 
\h 
Y 
Y 
1 
^ X 
^ X 
X 
g 
In functional notation, this is written as: 
hO = x 
and 
h{Sn)=g{hn). 
Recall that in Sets this mediating map h: N —> X is obtained by iteration 
as: 
h(n)=gi^(x) 
where 
| ^(n+i)(^) = 
K / " ^ W ) 
We say that 1 —y N —> N is an N N O with simple parameters if for 
each parameter object / and pair of maps / : / x 1 —> X and g: I x X -^ 
X, 
there is a unique h: I x N —> X making the following diagram commute. 
id X 0 
id X S 
/ X 1 
^ I X N 
^ I X N 
I 
I 
I (7r,/i) 
I (7r,/i) 
Y 
Y 
/ X 1 
^ I X X 
^ I 
xX 
(TT^X) 
{7r,g) 
where we have written / : / x 1 —> X instead of f: I -^ X for purely formal 
reasons. In functional notation we now have equations: 
h(i^O) = fi 
and 
/i (i, Sn) = ^ (i,/i(i, n)). 
They emphasise that such an NNO involves an extra parameter i. By taking 
the terminal object 1 as parameter object one sees that an NNO with simple 
parameters is an ordinary NNO. The reverse direction can be obtained in 
Cartesian closed categories. Below we give alternative descriptions of such 

160 
Chapter 2: Simple type theory 
NNOs with simple parameters: they are fibred NNOs in simple fibrations. 
Therefore we need the following/z6rew;25e notion. It is in fact a special case of 
Definition 1.8.1. 
2.6.2. Definition. A fibration with a fibred terminal object has a fibred 
natural numbers object if each fibre has an NNO and reindexing functors 
preserve NNOs (i.e. if 0,S form an NNO, then so do w*(0), w*(S)). 
2.6.3. Proposition. For a category B with finite products, the following 
statements are equivalent. 
(i) IB has an NNO with simple parameters. 
(ii) IB has an NNO 0,S and for each I e M, the functor /*:IB -> M//I 
applied to 0, S yields an NNO /*(0), /*(S) in the simple slice M//I over I. 
s(B) 
(iii) The simple fibration 
I 
onM has a fibred NNO. 
Proof, (i) ^ (ii). By definition of NNO with simple parameters. 
(ii) ^ (iii). Each fibre M//I has an NNO /*(0),r(S). These are preserved 
under reindexing, since for w: / —> J in B one has u* o J* = /*. 
(iii) => (ii). Assume the simple fibration on B has a fibred NNO. Then B has 
an NNO 0, S, since B is isomorphic to the simple slice B/1 over 1. Moreover, 
the pair /*(0),/*(S) is an NNO in B / / , since reindexing functors preserves 
NNOs. 
• 
Hagino signatures and strong functors 
Recall from Definition 2.3.7 that a Hagino signatureinvolves a set S of atomic 
types, a type variable X and either a constructor function symbol constr: a —^ 
X (in the inductive case) or a destructor function symbol destriX —>• a (in 
the co-inductive case), where a- is a type in the closure 5 U {X} of the set 
5U {X} under finite products (1, x) and finite coproducts (0, +). A model of 
the set (or subsignature) 5 in a category B consists of a functor A: S -^ B, 
i.e. of a collection (^1^)5^5 of objects Ag G B. Such a model assigns values 
in B to the atomic types s £ S. The category of models of 5 in B is the 
functor category B*^, in which a morphism /: {As)ses —> {Bs)ses consists of 
a collection f — [fs'-Ag ^ Bs)ses of morphisms in B. 
Models of a Hagino signature can be described conveniently in terms of 
associated polynomial functors. This will be done first. 
2.6.4. Definition. Each model ^: 5 -> B of a set of atomic types 5 in a 
distributive category B together with a type a £ S U {X} determines a poly-

Section 2.6: Simple parameters 
161 
nomial functor T(yl)a: B -> B which follows the structure of a: 
( the constant functor Ag 
if a = s E S 
the identity functor 
ii a = X 
the constant functor 0 
if cr = 0 
the constant functor 1 
if cr = 1 
T{A), 1^' { 
Y ^ T{A),, (y) + T(A),, (y) if (7 = (71 + (72 
, y ^ T{A),, (y) X T(A)a, (y) ii(T = 
a,xa2. 
For an arbitrary encdofunctor T: B —> B an algebra (or T-algebra) consists 
of a "carrier" object y G B together with a morphism (p:T{Y) -^ Y. Dually, 
a co-algebra is a pair {Z, ip) consisting of a carrier object Z an(d a map 
ip: Z -^ T{Z) pointing in the reverse direction. In both the algebraic and in the 
co-algebraic case one can understand the functor T as describing a signature of 
operations. For instance, iiT{X) 
- l + X x X + X , then a T-algebra T(y) -> Y 
consists of a carrier Y on which we have three operations 1 — > y , y x y - > y 
and Y -^ Y. Every group G carries such a T-algebra structure T(G) -^ G 
consisting of the cotuple of unit, multiplication and inverse operations. Co-
algebras Z -^ T(Z) generally describe "dynamical systems" (in an abstract 
sense), where Z is the state space, and the map Z -^ T{Z) is the dynamics, or 
transition function, acting on the state space (see e.g. [167]). Typical examples 
arise from automata: if E is a finite alphabet, then the functor T{X) == (1 -h 
X)^ is polynomial. A co-algebra Z -^ T{Z) may be described as a transition 
function Z x T, -^ 1 -\- Z which yields for every state z E Z and input symbol 
a E ^ either an outcome in 1, if the computation is unsuccessful, or a new 
state in Z. It is a certain automaton. 
One forms a category Alg(T) with T-algebras as objects and as morphisms 
^ 
{T{Y) — - y) 
V^ 
(T(Z) — - z) 
maps h:Y —> Z in the underlying category B between the carriers for which 
the following diagram commutes. 
T(Y) 
f 
T(h) 
T{Z) 
v-
Dually, there is a category CoAlg(T) of co-algebras and similar, struc-
ture preserving morphisms between carriers. In these categories of alge-

162 
Chapter 2: Simple type theory 
bras and coalgebras one can study initial and terminal objects. An ini-
tial algebraindexSInitial!- algebra for a functor T:B —> B is a terminal co-
algebraindexSTerminall-coalgebra for T^^ilPP -> IB^P. Notice that an initial 
algebra of the functor X i-^ 1 + X is a natural numbers object. In terms of 
these (co-)algebras one can describe many more data types than just natural 
numbers. 
But first we mention the following basic result. 
2.6.5. Lemma (Lambek). An initial T-algebra 
(f:T(Y) 
-^ Y is an 
isomor-
phism. 
Thus initial algebras are fixed points T(Y) 
•=>• F of functors. By duality, 
a similar result holds for terminal co-algebras. In Exercise 2.6.4 below, we 
sketch the standard construction of such fixed points, generalising Tarski's 
fixed point construction in posets. 
Proof. Considering the T-algebra T{(p):T'^{Y) 
-^ T{Y). 
One obtains by ini-
tiality an algebra map / : (f —^ T{(f), 
i.e. a morphism f:Y 
-^ T(Y) 
in B with 
f o (f — T((f) o T{f). 
But then, </? o / is an algebra map (p —^ (p and must be 
the identity. Thus also f o (p = T{<f) o T{f) 
= T{(p o f) = T(id) = id. 
D 
2.6.6. Definition. Consider a type (T{X) built with finite product and co-
products from 5 U {X} 
and a model S:A 
^ 
B of the atomic types in a 
distributive category B. A (initial) modeln B of an inductive Hagino signa-
ture 
, ^^, 
constr 
<T{X) 
^ X 
is an (initial) T(yl)a-algebra, written for convenience with the same name, as: 
^T-,/ A \ / ^^\ 
constr 
T{A)a{X) 
^X 
A (terminal) model of a co-inductive Hagino signature destriX -^ (^{X) 
is a (terminal) co-algebra destrrX -^ T{A)a{X) 
of the associated functor. 
Hagino signatures cr -> X or X —> cr are often used in programming lan-
guages to define a new type X recursively. The inductive case, say of the 
form (cTi -f- • • • H- cTn) -^ X occurs in the functional programming language 
ML [224, 251] with syntax 
datatype X = Ci of cri | • • • | (7n of (7„ 
where C i , . . . , Cn are constructors. Categorically, one combines these d 
into 
a single constructor constr = [ C i , . . . , C„]: (CTI -f 
f- cr„) —> X via a cotuple. 
Describing constr as initial algebra of the functor associated with the type 
((Ji H 
h (7„)(X) provides appropriate elimination rules for such data types, 

Section 2.6: Simple parameters 
163 
which are used to define operations on them. Initiality tells us that it is the 
freely generated structure, and hence how it behaves with respect to arbitrary 
such structures. Co-algebras can be used to describe infinite data structures 
(and more generally, dynamical systems [167]), for example in object-oriented 
languages, see [283, 162, 164]. Terminal co-algebras are minimal realisations, 
in which all behaviourally indistinguishable (bisimilar) states are identified, 
see also [298]. 
In the programming language CHARITY, see [52], one can define both these 
initial and terminal types. Thus one can define for example a type of trees of 
finite depth with nodes having infinitely many branches. 
These recursively defined types with initial or terminal characterisations 
occur already in [6], but were first investigated systematically from a type 
theoretic perspective by Hagino [111, 110, 112]. 
The above is standard theory. Here we show how we can use simple fibra-
tions in order to get appropriate versions with parameters of such data types. 
The approach comes from [160], but there, the language of fibred categories 
is not used. What we need first is the notion of a strong functor. 
2.6.7. Definition. Let B be a category with finite products. A functor 
T:B ^ B is called strong is it comes equipped with a strength natural 
transformation st with components stjx-^ 
x TX -^ T[I x X) making the 
following two diagrams commute. 
IxTX 
-
i 
T{I X X) 
Ix(J 
X TX) —^ ^^^ > I xT{J 
X X) 
^ T(I X (J X X)) 
(/ X J) X TX 
^ T{(I 
xJ)xX) 
2.6.8. Examples, (i) Every functor T: Sets -^ Sets is strong with strength 
I xTX 
-^T{Ix 
X) given by 
(f,a) ^T{%x 
eX.{i,x)){a). 
For example, for a set A, let list(74) (or A*) be the set of finite sequences 
of elements of A. The assignment A ^-^ list(A) forms a functor on Sets with 
strength / x list(^) -> list(/ x A) given by 
(i,(ai,...,an)) ^ ((2,ai),...,(i,an)). 

164 
Chapter 2: Simple type theory 
(ii) On a distributive category B, identity functors and constant functors 
are strong. Moreover, if T, S'lB -> B are strong, then so are 
Y ^ T{Y) X S{Y) 
and 
Y ^ T(Y) + 5(7). 
Hence every polynomial functor T{A)a''M -> B in Definition 2.6.4 is strong. 
The following basic result, due to Plotkin, gives an alternative description 
of strong functors in terms of simple fibrations. 
2.6.9. Proposition. Let M be a category with finite products. There is a hi-
jective correspondence 
strong functors B 
>• B 
s(B) 
^ s(B) 
split functors 
\^ 
y 
B 
Given this correspondence, we shall write T//I: M//I -^ M//I for the endo-
functor on the simple slice over /, associated with a strong functor T: B —> B. 
Proof. Let (T, st) be a strong functor on B. We define a split functor 
T:s(B) ->s(B) by 
(/, X) ^ (/, T{X)) 
and 
{u, f) ^ (u, T{f) o st). 
Conversely, let R: s(B) —> s(B) be a split endofunctor on 
i . It leads by 
restriction to functors RjiM/fl —> M//I on the fibres. Hence we get a functor 
R on B, via the functor Ri over the terminal object 1: 
_ 
= 
Ri 
= 
R={M 
^ B//1 
^ B//1 
^ B ) 
It satisfies I* o R = Rj o P and hence in particular for X G B, R{X) = 
Ri{X). 
A strength map st: / x R{X) -> R{I x X) is obtained as follows. The 
identity map IxX-^IxX 
in W forms a morphism / -^ / x X in B//I. Thus 
by applying the functor Rj one obtains a morphism Ri(X) 
-^ Rj{I x X) in 
M//L It corresponds to a map / x ^{X) -^ 'R(I x X) in B. 
We leave it to the reader to verify that T — T and R—R. 
• 
The following definition contains a compact reformulation of a notion used 
by Cockett and Spencer [52, 53] in their description of initial models of Hagino 
signatures with parameters. 
2.6.10. Definition. An algebra i^.TX ^ X for a strong functor T: B -^ B is 
called initial with simple parameters if for each object / G B, the functor 

Section 2.6: Simple parameters 
165 
/*: B -^ M//I maps <f to an initial algebra /* {(f) for the functor T//I: M//I -^ 
M//I on the simple slice category over /. 
Notice that this really is a fibrewise definition: it essentially says that in 
s(B) 
each fibre M//1 of the simple fibration 
i 
the associated functor T//I: M//I -^ 
M//1 has an initial algebra (f^ = ^*{^)i 
^^^ ^hat these initial algebras are 
preserved under reindexing. Since the category IB can be identified with the 
fibre M//1 over 1, it suffices to have an algebra there, which is preserved by 
each reindexing functor /*:B ^ M//1 associated with the map / ^ 
1 (as in 
Proposition 2.6.3). 
If we spell out initiality with simple parameters of (f: T{X) 
-> X as de-
scribed above, then we come to the formulation used by Cockett and Spencer. 
It says that for each parameter object / G B and for each "algebra with pa-
rameter" ip: I X T{Y) -^ y in B, there is a unique map h: I x X —-> Y making 
the following diagram commute. 
(7r,st) 
id X Th 
I X T{X) 
^ I xT{I 
X X) 
^ / X T{Y) 
id X (p\ 
-0 
^ 
h 
^ 
I xX 
^Y 
The reader may wish to check that an algebra of the functor X >-^ I -\- X 
which is initial with simple parameters, is an NNO with simple parameters, 
as explicitly described in the beginning of this section. 
We have only sketched the basics of the theory of (co-)inductively defined 
types, with emphasis on simple parameters. If one replaces the simple fibration 
by the codomain fibration, then one gets a theory with dependent param-
eters. For example, one can say that an NNO with dependent parameters 
0, S in a category B is an NNO 0,5 in B such that for each parameter object 
/ E B, the functor /*:B ^ B / / (to the ordinary slice category) maps 0, S to 
an NNO /*(0),/*(S) in B / / . This can alternatively be described as a fibred 
NNO for the codomain fibration on B. In this dependent setting there is the 
following analogue of Proposition 2.6.9. It stems from unpublished work of 
Pare, see also [172, Proposition 3]. 
2.6.11. Proposition. Let M be a category with finite limits. There is a bijec-

166 
Chapter 2: Simple type theory 
live correspondence (up-to-isomorphism) 
between 
strong, pullback preserving functors IB -
IB-
fibred, fibred pullback preserving functors 
X 
y 
Proof. Assuming a strong, pullback preserving functor T: B —)• IB, we define 
a functor T: W^ —> IB"*" by sending a family I 
y^ I to the composite ( 
| 
in the following diagram. 
It is not hard to see that because T preserves pullbacks, this T is a fibred 
functor, which preserves fibred pullbacks. 
Conversely, given a fibred functor R: W^ -> B^ preserving fibred pullbacks, 
we get a pullback preserving functor 
R={]1 
B/1 
Ri 
on IB. Because i? is a fibred functor, the Cartesian morphism in W^ on the 
left below, is sent to the Cartesian morphism on the right. 
/ IxX 
-
/ — 
^X\ 
i 
- 1 
/ 
R 
/ / X R(X) 
J 
'i 
i 
\ 
- 1 
/ 
As a result, the functor R:W^ -> B~^ restricts to a split functor /?':s(B) —> 
s(B), since the full subcategory s(B) <^ B~^ consists of Cartesian projections. 
By Proposition 2.6.9, the restriction of R' to the fibre over 1 is then strong. 
But this is R, as described above. 
• 
A diff'erent extension of the basic theory, to be elaborated in Section 9.2, 
goes as follows. Given a polynomial functor T: B ^ B on the base category of a 

Section 2.6: Simple parameters 
167 
E 
fibration i , then, under suitable assumptions, one can lift T: B -> B to a fibred 
functor Pred(T):E ^ E on the total category of the fibration. It turns out 
that algebras of this lifted functor Pred(T) capture the induction principles 
which are needed to reason about the (initial) data type associated with T. 
And dually, co-algebras of Pred(T) may be used to reason about (terminal) 
E 
co-algebras of T. This approach exploits a fibration ^ as providing a logic of 
predicates in E to reason about types in the base category B. This view on 
fibrations 
will be developed in the next three chapters. 
Exercises 
2.6.1. 
Consider a distributive category and define ri= 1 -\- - - • -\- 1 (n times). 
(i) 
Prove that ri + m = n -\- m and nx rn = n x m. 
(ii) Show that 2^ carries the structure of a Boolean algebra. 
[Hint. Use 2 x 2 ^ 2 + 2 to define conjunction A: 2 x 2 ^ 2 via the 
cotuple of cotuples [[«,«], [«,«']]: 1 + 2^ ^ !•] 
(iii) Define a choice operation if:2^xX x Y ^ X 
-^Y. 
[For more such programming in distributive categories, see [341, 52, 53].] 
2.6.2. 
Show that in a poset category with finite products (T, A) and finite coprod-
ucts (±, V), distributivity of A over V implies distributivity of V over A and 
vice-versa. In that case one has a distributive lattice. Note that this corre-
spondence between distributivities does not hold for arbitrary categories. 
2.6.3. 
Show that the assignment A i-)- T[A)CT in Definition 2.6.4 extends to a 
functor B^ ->B®. 
2.6.4. 
Show that the initial algebra of an endofunctor T: B —> B can be constructed 
from the colimit X of the u;-chain, 
f 
T(!) 
T^(!) 
0 — ^ T(0) 
^ T'(0) 
^ T^(0) 
^ 
^ X 
in case this colimit exists in B and is preserved by T—where 0 G B is initial 
object. This is as in [309]. 
Prove that, dually a terminal co-algebra can be constructed as limit Y of 
the u;-chain, 
! 
T(!) 
T^{\) 
1 ^— 
T(l) ^ 
T'(l) < 
T\l) 
^ 
^ 
Y 
provided T preserves such u;-limits, 
2.6.5. 
Prove that, on a distributive category B, the assignments Y \-^ 
T{Y)xS(Y) 
and Y \-^ T[Y) -\- S{Y) are strong functors B ^ B, assuming that both S 
and T are strong functors (as claimed in Example 2.6.8 (ii)). 
2.6.6. 
Following [50] we say that a category B with finite products has list objects 

168 
Chapter 2: Simple type theory 
if for each ^ G IB there is an object list(A) equipped with a pair of maps 
nil: 1 —> \\st{A) 
and 
cons:^ x list(^) —> \\st{A) 
such that for each X £ M which comes together with maps x: 1 —y X 
and g: A X X —> X, there is a unique morphism h:\\st{A) —-)• X with 
h o nW = X and h o cons = g oid x h. 
(i) 
Formulate appropriate fibrewise list objects and list objects with simple 
parameters such that a result like Proposition 2.6.3 can be obtained, 
(ii) Show that a list object on A is an initial algebra of the functor X \-^ 
l-\-(A 
xX). 
(iii) Check that the formulation with simple parameters from (i) coincides 
with the one in Definition 2.6.10. 
2.6.7. 
Show that in a Cartesian closed category an initial algebra is always initial 
with simple parameters 
2.6.8. 
Define what a terminal co-algebra with simple parameters is. Show that 
each terminal co-algebra is automatically terminal with simple parameters. 
2.6.9. 
Consider a comonad G: C —> C and a functor T: C -^ C with a natural 
transformation a: GT =^ TG. 
(i) 
Say what it means that (T, a) forms a map of comonads G ^ 
G, 
i.e. that a commutes appropriately with the comonads counit e and 
comultiplication S. 
(ii) Assume that C has Cartesian products x. Prove that a natural trans-
formation st: (x o T X id) ^ (To 
x) makes the functor T strong if 
and only if for each object / G C, the induced natural transformation 
st^:T(—) X I =^ T{(—) X I) forms a map of comonads. 
[Recall from Exercise 1.3.4 that the functor (—) x /: C -^ C carries a 
comonad structure.] 
2.6.10. Let IB be a category with finite products. A strong monad on IB is given by 
a 4-tuple (T, r/, /j, st), where (T, r/, fj) is a monad on IB and (T, st) is a strong 
functor. Additionally, the following two diagrams are required to commute. 
st 
^(st) 
/ X X ^^^-^ 
IxTX 
IxT'X-^ 
T{I X TX) —^T'ilx 
X) 
-^T{{I 
xX) 
id X T] 
^ / X 
^ \ ^ i ^ 
) 
T{I 
TX 
st 
KX) 
I X' 
id X ^ 
/ x 
r^x 
f 
TX 
st 
(i) 
Show that the (finite) lists and powerset operations X ^ list(X) and 
X »-> P{X) are strong monads on Sets. 
(ii) Show in line with Proposition 2.6.9 that there is a bijective correspon-
dence between strong monads on IB and split monads on the simple 
8(1) 
fibration 
i 
(see Exercise 1.7.9). 

Chapter 3 
Equational Logic 
At this point we start the categorical investigation of logic. This chapter will 
be about a logic of equations between terms in simple type theory (STT). 
First order logic with more general predicates on terms (than equations) may 
be found in the next chapter. And the subsequent chapter 5 deals with higher 
order logic, in which there is a special type Prop of propositions. This leads to 
higher order quantification. All these logics are many-typed logics with types 
(and terms) as in STT. Or, as we like to put it, these are "simple" logics 
(fibred) over STT. Later we shall also see logic over polymorphic type theory 
(PTT) and over dependent type theory (DTT). These have greater expressive 
power at the level of types. 
But for the moment we restrict ourselves to equational logic over simple 
types. There, one has equations between terms as propositions. Propositions 
form a new syntactic universe (besides types). They are the entities that one 
reasons about, and occur in the relation h of logical entailment. We start this 
series of chapters on logic (3, 4, 5) with a few remarks on logics in general and 
with an explanation of the (logical) terminology and notation that we shall be 
using in the rest of this book. Starting from these generalities we can already 
construct a fibration from a logic as a term model (or classifying fibration), 
capturing the essential context structure of the logic. The subsequent sections 
in this chapter contain an exposition of the traditional approach to the se-
mantics of non-conditional equational logic in terms of categories with finite 
products, and also an exposition of the fibred approach. The latter makes use 
of Lawvere's description of equality via left adjoints to contraction functors. 
This fibred approach presents equality as an "internal" notion, in the logic 
169 

170 
Chapter 3: Equational Logic 
of a fibration. It is very general and close to syntax. And it fits nicely into a 
uniform categorical description of logics. This fibred line will be pursued in 
subsequent chapters. 
E 
The way in which a fibred category ^ provides us with means to reason 
about what happens in the base category B, is described in Section 3.5. In 
particular, in Definition 3.5.3, validity of equations in a fibration (admitting 
equality) is introduced. This shows how E gives us a logic over B. We will 
show how choosing diff'erent fibred categories on the same base category gives 
different logics (with diff'erent notions of equality) to reason about this base 
category, see Examples 3.5.4 and 3.5.5. In the subsequent and final section 3.6 
the functorial semantics from the previous chapter is extended from ordinary 
categories to fibred categories. It enables us to capture models of logics as 
certain structure preserving morphisms of fibrations. 
3.1 Logics 
A logic is a formal system for reasoning. There are various such systems, with 
variation determined by, for example: 
• what to reason about; this determines the form of the atomic propositions; 
• which means to use; this determines the logical connectives used to build 
compound propositions; 
• which rules to follow; for example whether to follow the constructive or 
classical rules for negation. 
In this chapter we study many-typed equational logic. It has equations 
between terms from STT as atomic propositions, and so it may be called 
simple equational logic (in contrast to polymorphic or dependent equational 
logic, for example). Our (categorical) account of equational logic does not 
involve any connectives. These can be added later and studied separately, see 
the next chapter. In order to describe a (not necessarily equational) logic over 
STT, we start with a (many-typed) signature, containing the atomic types and 
function symbols, that will generate an underlying simply typed calculus (as 
in the previous chapter). In predicate logic the signature may contain atomic 
predicate symbols, but in equational logic one restricts oneself to equations 
as (atomic) propositions. In general, a signature together with a collection 
of propositions (serving as axioms) will be called a specification. And a 
specification in which the collection of axioms is closed under derivability will 
be called a theory. 

Section 3.1: Logics 
171 
Usually, a statement in a logic is written as 
where 9?i,...,<y?n and ^jj are propositions. Such a sequent expresses that ip 
follows (as conclusion) from the assumptions 9?i,.. .,<^„. These propositions 
(fi,... 
,(fny'^ 
may contain (free) variables of certain types. The context in 
which these variables are declared is left implicit in the above formulation. 
Contexts are very important in a categorical description of logic—since they 
are indices—and therefore we prefer to use statements of the form 
T \<fi,...(pn 
\- ^P 
in which the context T containing all the free variables of ^ i , . . . , 9?^ and ip, 
is written explicitly. The sign '|' is used as a separator and has no logical 
meaning. Its role is to separate the t y p e c o n t e x t F from the proposition 
context (fi,.. 
.^ipn, much like '|' in the standard notation {i £ I \ <f{i)} for 
comprehension separates the set-theoretical from the logical. In [186] the type 
context r is written as a subscript of the turnstile \f. It leads to sequents of 
the form <^i,.. .<^n ^f ^ ' ^^^ ^^^^ notation is not very convenient when we 
deal with rules (like for V or 3) that change the type context F. So we put the 
type context F at the beginning of the sequent. 
As an example, in equational logic one can have a sequent 
vi: N,V2: N | i^i = N 3,1/2 + vi =^ 
b \- V2 = N 2. 
with type context I'll N, 1/2: N, proposition context vi =|\| 3,V2 -{• vi = N ^ and 
conclusion V2 =|\| 2. Such a sequent involves ingredients (such as N,-|-,3,5,2 
in this case) which come from an underlying signature as in STT, describing 
the basic types and function symbols that we use. This signature determines 
which terms (like V2 + ^'i above) can be formed, and hence also which equa-
tions (between terms) can be used. Additionally, we may wish to have certain 
equations as axioms in equational logic. For example, the monoid equations in 
reasoning about monoids. An equational specification consists of a signature 
E together with a set A (for axioms) of equations between E-terms. A precise 
definition will be given in the next section. Later on, in predicate logic, we will 
use slightly different specifications, consisting of a triple ( E , n , ^ ) , where E is 
a signature, 11 is an additional set of typed predicate symbols P : crj,..., cr„, 
and ^ is a set of axioms. 
Context 
rules 
In Figure 3.1 we list the context rules which will be used in all of the logics 
that we consider. We write F for a type context of the form a^i: cri,..., x„: (7„ 

172 
Chapter 3: Equational Logic 
axiom 
r | 0 hV (if (r I e h V) e ^ 
cut 
riei-y. 
r|e',¥ji-v 
r|e,0' hv 
contraction for propositions 
r | e , y , y hv> 
r | 0 , y . h v 
weakening for types 
r |0 h v^ 
T,x:a\Q 
\- ip 
exchange for types 
T,x:ai,y:ai^i,T' 
\Q \- ip 
Fig. 3.1. Context rules in logic 
identity 
r h xP: Prop 
weakening for propositions 
r I 0 h V^ 
T h(p: Prop 
r | e , ^ h v ^ 
exchange for propositions 
r|e,y.,x,e^i-V' 
r|e,x,^,e'HV 
contraction for types 
r, x: (J, ?/: (7 I 6 h V^ 
T,x:(T\e[x/y] 
\-xP[x/y] 
substitution 
A , r , A ' | e[M/x] 
hi;[M/x] 
in which (term) variables Xi are declared of type cr,, and 0 for a proposition 
context consisting of a sequence (fi,.,., 
(frn of propositions. In combined con-
texts r I 0 we ensure that all the free variables occurring in (the propositions 
in) the proposition context 0 are declared in F. Further, sometimes we apply 
substitution Q[M/v] to proposition contexts. It means substitution <p[M/v] 
applied to all the propositions (f in Q. 
In the "axiom" rule in Figure 3.1 it is assumed that there is a given set of 
axioms A. If there is no such set specified, the rule does not apply. 
Notice that the "identity" rule starts from the assumption T \- ip: Prop 
that ^ is a well-formed proposition in type context F. How such statements 
are obtained depends on the specific logic that we are using. For example, in 
equational logic one only has equational propositions F h V^: Prop with tp of 
the form M —a M', where M, M' are terms of type cr in context F. 
As in STT, in concatenated contexts F, A we always assume that the vari-

Section 
3.1: Logics 
173 
ables in F and A are distinct. Especially, in writing V^X:(T it is implicitly 
assumed that the variable x does not occur in F. 
We sometimes write 
• F | 0 
h ^ 
to express that the sequent F | 0 h <^ is derivable. This means that there 
is a derivation tree regulated by the above rules (and possibly some extra 
rules specific to the logic) with F | 0 h <^ as conclusion. Notice that in the 
formalism that we use all assumptions are explicitly present at every stage of 
the derivation in the type and proposition contexts. 
The following rule is in general not valid. 
strengthening 
V,x\a\ 
0 h V' 
F | 0 h V^ 
[x not free in 0 , V^) 
The problem lies in the fact that (the interpretation of) the type a may 
be empty. The (then absurd) assumption x:a that a is inhabited may lead 
to conclusions, which can not be obtained without the assumption x.a. 
See 
Exercise 3.1.3 for more details. 
Fibrations 
of contexts 
in logic 
The above rules suffice to describe the basic categorical structure in a logic 
over a simple type theory. Let (S, D) be a specification for some system of 
logic, where E is a many-typed signature and • is something extra, deter-
mined by the specific logic; it may consist of collections of additional atomic 
symbols and/or axioms. For example, for equational logic, • will be a set 
of equations which serve as axioms. And in predicate logic it will consist of 
predicate symbols plus axioms. Given E and • we can start forming sequents. 
The categorical way to understand these sequents is as follows. 
index object in 
the base category 
inequality < in the 
fibre over the index 
A type context F = {xi: cri,..., a:„: cr„) is thus an index for a logic describing 
what happens in this context. This is a basic theme. 
We can formalise this view. The specific logic that we have gives rise to a 

174 
Chapter 3: Equational Logic 
fibration of contexts: 
£(S,D) 
I 
with the classifying category C^(E) of the signature E as basis. This fibration 
has the following properties. 
(a) The fibre over a type context T G Ci{T,) contains the logic in context F: 
its objects are sequents of the form F | 0; a morphism (F | 0) ^ (F | 0') 
exists if each proposition ip in 0' is derivable from 0 in type context F, i.e. if 
• F I 0 h V^ for each i; in 0'. 
(b) The fibration is a fibred preorder, i.e. all fibre categories are preorders. 
This is typical for iogical'fibrations (in contrast to 'type theoretic' fibrations), 
because in logic one does not distinguish between difi'erent proofs of the same 
proposition: there are no explicit proof-objects or proof-terms, which can serve 
as (proper) morphisms. 
(c) The base category ff(E) has finite products; as we have seen in the pre-
vious chapter, these are given by concatenation of type contexts. 
(d) The fibration has fibred finite products; this structure is obtained from 
concatenation of proposition contexts. 
We proceed to describe the total category £(E, • ) in detail. 
objects 
pairs F | 0 consisting of a type context F and a propo-
sitions context 0, such that all free (term) variables in 
propositions in 0 are declared in F. 
morphisms 
(F | 0) -> (F' | 0') are context morphisms M:F -^ F' in 
Ci{Ti) such that for each proposition V^ in 0' one can derive 
F I 0 h i;[M/v] 
where [M/v\ is simultaneous substitution for the variables 
Vi declared in F'. 
Identities in £(E, • ) are identities in (X(E), by the identity rule. Also com-
position is inherited from C^(E): for morphisms in £(E, • ) , 
(r 10) - ^ (r 10') - ^ (r" 10") 
let L = iV o M be the composite in the base category Cf(E)—which means 
Li = Ni[M/v\. 
This map L is also a morphism (F | 0) -> (F" | 0") in 
the total category £(E, • ) . This follows from a combination of the cut and 

Section 3.1: Logics 
175 
substitution rule: for each proposition ip in 0'' one can derive 
r' I 0' h xl;[N/w\ 
(with w declared in T") and thus by substituting M one can also derive 
V\Q'[Mlv\ 
b^[L/w]. 
But for each (p in 0' 
r 10 h ip[M/v\ 
is derivable, which yields, by repeated application of the cut and contraction 
(for propositions) rules, that 
r I 0 h i;[L/xS\. 
is derivable. This makes L a morphism in £(11, D). 
The projection functor 
i 
given as (F | 0) i-> F is a split fibration. 
C6(S) 
The fibre over F G C^(D) indeed contains the logic in F, as stated in (a)+(b) 
above. As to (d), the terminal object in the fibre over type context F is F | 0 
(F with empty proposition context) and the Cartesian product of F | 0 and 
F I 0' is F I 0 , 0 ' (F with concatenated proposition contexts). 
3.1.1. Example. Consider type contexts 
(F = xi:(7i,...,x„:(7„) 
and 
A = (yi: n , . . . , y^: r^) 
together with a context morphism M: F -^ A, so that F h MJ: TJ. The (cat-
egorical) substitution functor (M)* associated with M is a functor from the 
fibre over A to the fibre over F. It maps a proposition context 0 in type 
context A to a proposition context in context F by performing substitution 
[M/y\ in syntax: 
(A I e) ^ (r I e[M/y\). 
There are two special cases of this general description of substitution which 
should be singled out, namely weakening and contraction (see also Exam-
ple 1.1.1). 
(i) Let us write 
for the context morphism (a^i,..., x„) consisting of the variables in F. Then 
we get an associated substitution functor n* which performs weakening. It 
acts as follows. 
{T\e)^{T,x:a\e). 

176 
Chapter 3: Equational Logic 
That is, it adds a dummy variable declaration (or assumption) x:a.\n 
syntax 
this is not an explicit operation, since there is no notation for weakening. 
Only when one moves to a categorical level, it becomes an explicit operation. 
It makes things more cumbersome, but it better brings forward the structural 
aspects. For example, in the next chapter on predicate logic we shall see how 
one can capture existential 3 and universal V quantification as left and right 
adjoints to these weakening functors TT* . 
(Pavlovic [256] proposes explicit notation in syntax for weakening: given a 
proposition F h <^: Prop, he writes T^x:a h v^(^): Prop for ip with this dummy 
variable x added by weakening.) 
(ii) Now write 
{T,X\(T) 
^ 
[T,x\a,y:a) 
for the diagonal context morphism ( x i , . . . , a?„, ar, ic). The associated substitu-
tion functor 6* performs contraction: 
{V,x:(T,y:cr\Q)^{T,x'.a\Q[xly\). 
It replaces two variables x,y of the same type by a single variable occurring 
in both places via substitution [x/y] of x for y. This is an operation which 
can be described explicitly in syntax. Later in this chapter we shall capture 
equality via left adjoints to such contraction functors S*. 
Exercises 
3.1.1. 
Prove that a morphism M: (F | 0 ) -> (F' | 0') in^£(E, D) is Cartesian if 
and only if for each (^ in 0 one can derive F | S'[M/v\ 
h ip. 
£(S,a) 
3.1.2. 
Verify in detail that the 
fibration 
4- 
has fibred finite products. Show 
that the total category £(E, • ) also has finite products: 0 | 0 is terminal 
object and the Cartesian product of F | 0 and F' | 0 ' is F, F' | 0 , 0 ' . 
3.1.3. 
Check that the following is an example showing that the strengthening rule 
is not valid. Consider in Sets two functions f,g:X n^ Y. Since Sets is a 
distributive category, we have X x 0 = 0, so that /o7r = 5fO7r:Xx0-> Y. 
This means that we have validity of 
x:X,z:0\(i 
\- f{x) =Y g{x), 
with z: 0 not occurring on the right of |. But evidently, me may not conclude 
x:X\(i 
\-f{x)=Yg{x) 
since / and g are arbitrary functions. 

Section 3.2: Specifications and theories in equational logic 
177 
3.2 Specifications 
and theories in equational 
logic 
The present section deals with the syntactic aspects of equational logic over 
simple type theory (STT). We investigate the rules which are specific for rea-
soning with equations between terms (in STT). The main result in this section 
is the reformulation (in Lemma 3.2.3) of the standard rules of equational logic 
in a single 'mate' rule (after Lawvere). It prepares the ground for a categorical 
description of equality in terms of left adjoints to contraction functors S* in 
Section 3.4. 
First we have to make precise what kind of atomic propositions may be 
used in equational logic. These will be equations of the form M —a M\ for 
terms M, M' of the same type cr in STT. Formally: 
Equational proposition formation 
T V- M:a 
F hM'i^r 
V V- M ^a M':Prop 
The type subscript a in =a is used to emphasise that we are dealing with 
equality of terms of the same type a. But more importantly, to distinguish 
propositional equality M —a M' from conversion M — M', as we have seen 
in the previous chapter, which comes with the type formers ^ , x, 1,-f, 0 in 
STT. These should not be confused: conversion = belongs to type theory, 
whereas propositional equality —o is part of logic. Sometimes we call con-
version external equality and propositional equality internal equality. The 
latter because —a can only be established within formal logic. This is in line 
with categorical terminology. 
Internal equality contains external equality via the following rule. 
From external to internal equality 
YVM:(T 
FI-M':<T 
YVM^M'.cr 
T h M =^ M' 
It says that convertible terms are (propositionally) equal in logic. As a con-
sequence, in logic, terms are considered up-to-conversion. One may also pos-
tulate a rule in the reverse direction (so that internal and external equality 
become the same, in what is sometimes called "extensional" logic), but we 
shall not do so in general. 
In equational logic we shall only use atomic propositions M —a M' and no 
compound propositions with connectives, like A, V, D. The reason is that we 
wish to study equality in isolation. The sequents in our logic thus have the 
following form. 

178 
Chapter 3: Equational Logic 
3.2.1. Definition. Let S be a signature. 
(i) A E-equation is a sequent of the form 
r I M l = ^ , M ( , . . . , Mn - a . M'^ h M „ + i =a^^, 
M'^^^ 
where for each i, both Mi and M/ are E-terms of type ai in context F, so that 
Mi —a^ M[ is a well-formed proposition. 
Such an equation will be called non-conditional or algebraic if n = 0, 
that is, if its proposition context is empty. We then write the sequent as 
r I 0 h M =,, M' 
or simply as 
T h M =^ M'. 
(ii) An equational specification is a pair (E,7/) where E is a signature 
and % (for Horn) is a collection of E-equations. An algebraic specification 
is a pair (E,>1) where ^ is a collection of algebraic equations. 
Notice, by the way, that the notation Y \- M —a M' in this definition was 
already used in the earlier rule that described internal equality resulting from 
external equality. 
3.2.2. Examples, (i) In Example 2.2.7 (i) one finds two algebraic specifica-
tions for groups: Ei with five axioms and E2 with one axiom. 
(ii) The classical example in algebra of a conditional specification is of a 
torsion free group, i.e. of a group G without elements with finite period, 
except its unit. This specification has infinitely many conditional axioms, one 
for each n G N: 
n times 
where • is the multiplication of the group G, and e: G its unit. 
(iii) Assume a signature in which for a type cr one also has a type Per 
intended as type of finite subsets oicr. For a cardinality operation card: Per -^ 
N one may expect a conditional equation 
x\ cr, y\ Pa \ elem (x, y) = B ^ ^ ^^^^ (^^^ (^j V)) —N ^^^^ iu) + 1 
where ff: B is the boolean constant 'false' and elem and add are the obvious 
set theoretic operations. 
Next we describe the typical rules of equational logic—besides the standard 
context rules from the previous section. They will also be used in any of the 
later logics with equality. We start with substitution; one puts 
(N =r N')[M/x] = {N[M/x] =r 
N'[M/x]) 
where = means syntactic identification. Categorically, this distribution of sub-
stitution over equations will be captured—as always—by a Beck-Chevalley 

Section 
3.2: Specifications 
and theories 
in equational 
logic 
179 
condition, see Definition 3.4.1. The corresponding substitution rule is 
substitution 
A, r, A' I N[M/x] =f N'[M/J] 
h L[M/x] ^p L'[M/x] 
which we explicitly mention as a special case of the substitution rule in the 
previous section. The vector notation iV —f N' is a shorthand for a sequence 
of assumptions A^i = TIN[, .. .,Nk = r/jiV^. 
The next four rules are the basic rules of equational logic. 
reflexivity 
symmetry 
T \- M:a 
T | 6 h M =^ M' 
T\e 
\- M =^ M 
r | e h 
M ' = ^ M 
transitivity 
r 1 0 h M =^ M' 
T\e 
\-M' =a M" 
r I 0 h M =^ M'' 
replacement 
T\e 
\- M =a M' 
T,x:a\- 
N:T 
r I 0 h N[M/x] =r 
N[M'/x] 
The next lemma gives a more concise formulation of these rules, and paves 
the way for Lawvere's categorical account of equality—which is in Section 3.4. 
It describes equality via left adjoints to contraction functors. Remember that 
the latter replace two variables x,y:a of the same type by a single one, using 
substitution [x/y], see Example 3.1.1 (ii). 
3.2.3. Lemma. Consider for terms T, x: cr^y.cr h TV, N': r the following rule. 
Lawvere equality 
V,x:a\Q 
\-N[xly\=r 
N'[xly\ 
- (=-mate) 
T,x:a,y:a\e,x=a 
y \- N =r N' 
Under the assumption of the substitution rule, the above four basic rules of 
equational logic are equivalent to this equality rule of Lawvere. 
The double line indicates that the rule may be applied in both directions. 
Note that it is implicit in the notation that the variable y does not occur in 

180 
Chapter 3: Equational Logic 
the proposition context 0. 
Proof. Assume Lawvere's rule. Reflexivity follows by applying it upwards: 
x\a,y\a\x 
=cj y ^ X'=^G y 
x\a\% V- {x[x/y] -a y{xly\) = [x -a x) 
We can immediately use reflexivity to obtain symmetry in: 
X\(T\^V 
{x-ax)^ 
{y\xly\ -^ 
x{xly\) 
x\a,y:a\x 
-a y \- y^a X 
And transitivity is got by taking: 
x\(T,y\a\x=a 
y ^ {x -a y) = {^^[y/z] =a z[y/z]) 
x: a,y:a,z:a\x=a 
y, y=a z \- x-a 
z 
which is an instantiation of Lawvere's rule with Y — {x'.u) and Q — [x —a y\ 
Finally, in order to derive replacement, assume 
r I 0 h M =^ M' 
and 
T, x\ (T\- 
N:T. 
Let A^' = N[y/x]. Then, 
T,x:a\-N:T 
• 
(refl) 
V,x:a\Q^N[x/y]=rN'[x/y] 
^ 
(=-mate) 
T,x:a,y:a\Q,x=^y)rN=rN' 
(subst) 
T\Q,M 
=a M' \- N[M/x] =r 
N'[M'/y] 
T\Q\- 
M =a M' 
T\Q,M 
=a M' V- N[M/x] =r N[M'/x] 
(cut) 
r I 0 h N[Mlx] =r 
N[M'lx] 
In the reverse direction, assume the four basic rules (plus substitution), and 
consider two terms F, a:: cr, t/: cr h N^N'\T. 
Lawvere's rule downwards is then 
obtained as follows. First one deduces 
V,x:a,y\a\Q,x 
=o y ^ X "=0 y 
T, x: cr, y\ a,z:a \- N[z/x]: r 
(repl) 
F, x:a,y:(T\Q,x=:ay\- 
N[zlx][x/z] 
=r 
N[zlx][y/z] 
= {N =r 
N[y/x]). 
Similarly one gets 
r,x:(r,y:(T\e,x=„y)- N' =r 
N'[x/y]. 

Section 3.2: Specifications and theories in equational logic 
181 
But then, using the assumption N[xly\ 
=r N'[x/y\, 
we are done by symmetry 
and transitivity. 
And Lawvere's rule in upward direction is deduced as follows. 
r , x: cr h x: cr 
T ^x'.cr^y.a 
\Q^x —o y \~ N =r N' 
(subst) 
T,x:a\e 
\- x=:a X 
T,x:a\e,x=a 
X \- N[x/y] 
=r 
N'[x/y] 
(cut) 
T,x:a\e 
h N[x/y] 
=r N'[x/y] 
D 
The above formulation of Lawvere's rule can be strengthened a bit, so that 
the variable y is allowed to occur in the proposition context 0 . This will be 
relevant later in connection with the Frobenius property. 
3.2.4. L e m m a . The above equality rule of Lawvere is equivalent 
to the fol-
lowing 
rule. 
Lawvere equality with Frobenius 
r, a;: <7 I Q[x/y] 
h N[xly] 
= , N'[xly] 
^ 
— 
(=-mate) 
T,x:a,y:a\(d,x=a 
y^ 
N ^j 
N' 
Proof. This extended equality rule in upward direction follows simply by 
substituting [x/y] and using reflexivity (which follows from the earlier Lawvere 
rule). Downwards, it suffices to prove for terms T,x:a,y:a 
h L,L'\ p that the 
following sequent is derivable. 
r, x\ (7, y: cr I L[x/y] -p L'{xly\,x 
-^ y V L-p 
L'. 
Since then one can apply the cut rule to all equations L =p L' \n Q. One 
derives this sequent via an immediate application of Lawvere's rule: 
V,x:a\ 
L[x/y] -p L'{xly\ 
h L{xly\ 
-p 
L\xly\ 
r , x\ (J,y\(T\ L\xjy\ 
-p l!{xly\, 
x-ayVL-pL' 
D 
3.2.5. Definition, (i) An equational specification (S,?{) will be called a 
theory if its set of equations H is closed under derivability. This means that if 
there is a derivation of an equation £' = (F, 6 \- M =a M') from assumptions 
El,..., 
En ^ H, then E must be in 7/. The rules which can be used in such 
a derivation are the context rules of the previous section plus the above four 
basic rules of equational logic (or, equivalently plus Lawvere's equality rule). 
Similarly, an algebraic specification ( D , ^ ) is called a theory if the set A of 
algebraic (non-conditional) equations is closed under derivability—where the 
same rules as above may be used, but with empty proposition context 0 . 

182 
Chapter 3: Equational Logic 
(ii) Every equational specification (D,?/) gives rise to a theory by closing 
% under derivability: one takes % to be the least collection satisfying 
• ncU] 
_ 
_ 
• if equation E is derivable from Ei^.. 
.^En EfL, then E 
EH. 
We write 77i(E,?{) = {^,Ti) for the theory associated with (E,7{). Some-
times we write E ETh{Il,7i) 
instead oi E 
E%. 
Similarly there is a theory 77i(E,^) associated with an algebraic specifica-
tion ( E , ^ ) . 
3.2.6. Definition, (i) The category EqSpec has 
objects 
equational specifications (E,?/). 
morphisms 
(E,?^) -^ (E',?/') are morphisms (j)\Ti -^ Yi' of signatures 
such that 
Een 
^ (j>EeTh{T.',n'), 
where ^E is obtained from E by applying (j) to all types 
and terms in E. 
Such a morphism 4^ in EqSpec will be called a m o r p h i s m of equational 
specifications. 
(ii) In the same vain there is a subcategory AlgSpec ^-> EqSpec, ob-
jects of which are algebraic specifications; its morphisms are morphisms of 
signatures which map non-conditional equations to derivable non-conditional 
equations (using only the rules with empty proposition context). 
Exercises 
3.2.1. 
Show that the following rule is derivable (or: admissible) in equational logic. 
rI e hM =er M' 
r,x:a\e \-N =r N' 
r I 0 h N[M/x] =r 
N'[M'/x] 
3.2.2. 
Consider the first equational signature for groups in Examples 2.2.7 (i). 
Give a formal derivation of the following basic result about groups. 
x: G, y: G I- i(m(i:, y)) =Q m(i(t/), \{x)). 
3.2.3. 
Check that the projections 
EqSpec 
i 
Sign 
and 
AlgSpec 
i 
Sign 
are spht fibrations. 
[Recall the discussion after Lemma 1.6.6 about the organisational power of 
fibrations.] 

Section 3.3: Algebraic specifications 
183 
3.3 Algebraic 
specifications 
In Section 2.2 we have described the semantics of a many-typed signature D in 
terms of finite product preserving functors M:Ci{T^) -> IB, where Ci{T,) is the 
classifying category of D. In this section we investigate how to model algebraic 
equations in a similar fashion, using ordinary categories. In the subsequent 
three sections of this chapter we use fibred categories to model arbitrary, 
conditional equations in a systematic manner. 
Suppose we have a model M'.CiCE) ^ B of E in a category B and two terms 
r h A^, A^': cr in the term calculus of E. An algebraic E-equation 
T \- N =a N' 
is said to be valid (or to hold) in M if the two resulting maps 
M{N) 
M{T) HT 
^ - ^ ( ^ ) 
M(N') 
are equal in B. Thus, an equation holds under an interpretation, if the two 
terms are interpreted as equal maps. 
For a set A of algebraic equations, we write A^ |= ^ if all equations in A 
are valid in 
M. 
3.3.1. Example. Consider the first specification of groups as in Exam-
ple 2.2.7 with one type G and three function symbols m: G, G —> G, e: () —> 
G, i: G —> G and the familiar equations: 
i;i:G 
(- m(e,t;i)-G 1^1 
t^i:G h m{\{vi),vi) 
-Q e 
t'i:G 
h m(t;i,e) =G t^i 
t;i:G 
h m(i;i, i(t;i)) =:G e 
i;i:G,i;2:G,i;3:G 
h m(i;i, m(i;2, V3)) = G ^(nn(vi, ^2), ^^s). 
A model M of this specification in a category B with finite products, then 
consists of an object G = A^(G) G B together with maps, 
m = M(m) 
e = MM 
i = M{'\) 
GxG 
^G 
1 
^G 
G 
^G 
such that the above equations hold. This means explicitly that, for example, 
m o (e o!, id) = m o (id, e o!) = idcr. 
In a similar way one can describe the other three equations above as equations 

184 
Chapter 3: Equational Logic 
in B. One gets precisely the diagrams of an internal group in B: 
id X e 
e X id 
G x 1 
^ GxG 
^ 
1 X G 
G 
(id,i) 
(2,id) 
G 
^Gx 
G ^ 
G 
G 
GxGxG 
m X id 
GxG 
id X m 
^GxG 
m 
^ G 
We briefly mention validity of equations with conditions. This can be ex-
pressed in case the receiving category B additionally has equalisers. We write 
Eq(w, v) for the (monic) equaliser map oi u^v in 
Eq{u,v) 
r> 
^i 
Whenever convenient, we also use Eq(u,v) 
for the corresponding subobject. 
Recall that for a category B with finite limits, the posets Sub(/) of subobjects 
of an object / E B have finite products {i.e. intersections). These will be 
denoted by A and T. 
Let E" be a conditional E-equation, 
r I M l =,, 
Mi 
...,Mn=a^M;,hN=r 
N' 
We say that E holds in a model M:Ci{Y^) -> B, or that M validates E, in 
case the intersection of the equalisers of the assumptions is contained in the 
equaliser of the conclusion: 
Eq{M{Mi),M{M[)) 
A " • AEq{M{Mn)M{M;,)) 
< 
Eq{M{N),M{N')) 
where < is the order of the poset Sub(A^(r)). 
Since M preserves finite products, the left hand side is isomorphic to a 
single equaliser, namely to the equaliser of the two context morphisms 
M{Mu...,Mn) 
M{T)z::z 
I 
X(M(,...,M;;) 
M{ai 
X '" X an) 

Section 3.3: Algebraic specifications 
185 
Notice that this definition restricts to the earlier one for non-conditional 
equations—since for n = 0 the empty meet is T (and T < Eq(i/, v) '^ u = v). 
We call a rule 
sound if validity of the sequent S\ implies validity of the sequent 52. At this 
stage we only know what it means for an equational sequent V \ M =$ M' h 
A^ —r N' to be valid, but in the next chapter we shall see validity for more 
general sequents. 
3.3.2. Lemma (Soundness). Let (S,^) he an algebraic specification and let 
M:Cl(Ti) -^ M be a model of A. Then every (algebraic) equation derivable 
from A holds in M. Thus M is a model of the theory of (E,^). 
Proof. One shows that all derivation rules are sound. Reflexivity, symmetry 
and transitivity are obvious. For replacement assume validity of F \- M —a 
M'] then for each term F,x:cr h N:T we get validity of F h N[M/x\ — 
N[M' 
lx]\Tixom. 
M[N[M/x\) 
= M{N)o 
{id,M{M)) 
by Exercise 2.2.2 
= 
M{N)o{id,M[M')) 
= 
M{N[M'/x]). 
In a similar way one obtains soundness of the substitution rule (using Exer-
cise 2.2.2 again). 
• 
We next describe classifying categories for algebraic specifications. They be-
have like classifying categories for signatures—and are constructed as suitable 
quotients of these. 
3.3.3. Definition. Let {Tt^A) be an algebraic specification. We say that 
S-terms F \- N, N':a are equivalent modulo A if the equation T \- N =a 
N^ is derivable using the equations from A as axioms. We define a classifying 
category Ct{T^,A) with 
objects 
contexts F. 
morphisms 
F ^ 
A are sequences (|Mi|,..., |Mn|) of equivalence 
classes (modulo A) of terms M: F ^ A in the classifying 
category a{E) of S. 
(Notice the following subtlety of notation: we use \M\ for the equivalence 
class of M modulo propositional (or internal) equality, where we used [M] for 
the equivalence class modulo conversion (or external equality) in the previous 
chapter.) 

186 
Chapter 3: Equational Logic 
Thus the classifying category ff (S, A) of an algebraic specification (S, A) is 
obtained by making certain identifications (induced by the axioms A) in the 
classifying category C^(II) of the signature E. As a result, there is a canonical 
quotient functor a{E) 
-^ ff(E, A). 
With this definition of classifying category of an algebraic specification 
{T>,A), we can understand a model of ( S , ^ ) in a category B functorially, 
namely as a finite product preserving functor Ci{T>,A) -^ M. This is the con-
tent of the following result. 
3.3.4. Theorem. A classifying 
category Ct{T,,A) 
has finite products. 
More-
over, there is a bijective correspondence 
between 
M 
a{T.,A) 
^ B 
z n F P C a t 
« ( D ) 
^ B 
in F P C a t with N h^ A. 
N 
Proof. The finite product structure in Cl[T^,A) is given by concatenation of 
contexts as in Cl[Yi). For a functor M'.CI[YJ, 
^ ) ^ B in F P C a t one obtains a 
functor M as composite C^(E) -^ ff (E, ^ ) -> B satisfying M^ 
A because for 
every equation F \- N —a N' m A, the terms N and N' are equivalent modulo 
A^ and thus give rise to the same morphism in 
ff(E,^). 
This is because the 
functor Cl{Ti) -^ Cl{T^^A) maps context morphisms M to their equivalence 
classes \M\. 
In the reverse direction, for a model M: C^(E) -> B of E with M \=^ A one has 
by soundness that if N^N' 
are equivalent modulo A, then J\f[N) 
— 
M{N'\ 
Thus M restricts to a well-defined functor ff(E, ^ ) -> B. 
D 
By this result, we can take a model of an algebraic specification ( E , ^ ) in 
a category B (with finite products) to be a finite product preserving functor 
« ( E , ^ ) - > B . 
3.3.5. Corollary (Completeness). Let (E,yl) be an algebraic 
specification. 
An (algebraic) equation is derivable from A if and only if it holds in all models 
0/(1], yl). 
Proof. The (only-if) follows from the soundness Lemma 3.3.2. For (if), there 
is the 'generic' model id:(X{T,,A) 
-^ Ci{T,,A) of ( E , ^ ) in its own classifying 
category. If an equation holds in all models, then it certainly holds in this 
particular model. Then, by the previous result, it holds in C^(E) -^ C^(E,^). 
But this latter model validates precisely the equations which are derivable 
from A. 
• 
In Lemma 2.2.4 we saw how every category with finite products induces a 
many-typed signature. Below we show that it actually induces an algebraic 

Section 3.3: Algebraic specifications 
187 
specification: the equations that one gets are precisely those that hold in the 
category. 
3.3.6. Definition. Let B be a category with finite products and let Sign(B) 
be its associated signature (as in Lemma 2.2.4). Then one can form terms 
V \- M'.X 
and equations V \- M = x M' using this signature. Recall from 
Theorem 2.2.5 that there is a model 5: ff(Sign(IB)) -> 1 of the signature of B 
in itself. 
We write >t(B) for the set of non-conditional Sign(B)-equations which hold 
in e (as described in the beginning of this section). The pair (Sign(B),^(B)) 
is the algebraic specification associated with B. By the previous theorem we 
get a model C^(Sign(B),^(B)) -> B, which we also denote by e. 
3.3.7. Example. The underlying signature Sign(B) of a category B with fi-
nite products has function symbols 
pair 
proj 
proj' 
XuX2 
^XixX2 
X1XX2 
^Xi 
X1XX2 
^X2 
which arise from the following maps in B, see Definition 2.2.5 (i). 
^(pair) 
^(proj) 
e{\>xo\') 
XuX2 
^ Xi X X2 
Xx X X2 
^ Xi 
Xi X X2 
^ X2 
= id 
= ^ 
= TT' 
These function symbols come equipped with equations in ^(B), 
x\Xi,y\X2 
\- proj (pair (x, y)) =Xi ^ 
x:Xi,y:X2 
H proj'(pair (x, y)) =^2 2/ 
z:XixX2 
V- pair (proj (z), proj'(2:)) =XixX2 ^ 
Similarly, there is an 'empty tuple' function symbol in Sign(B) 
Q 
^ I 
vvith equation 
F h M =1 (). 
Combining these we obtain an isomorphism of context objects in the classify-
ing category «(Sign(B),.4(B)), namely 
(xi:Xi,...,Xn.Xn) 
= [z:Xi 
x 
-"XXn). 
The latter isomorphism will be used in the proof of the next result. It states 
that every category with finite products can be understood as a classifying 
category, namely of its own algebraic specification. Hence one can identify 
(following Lawvere) and algebraic theory with a category with finite products. 
3.3.8. Theorem. A category B with finite products is equivalent to the clas-
sifying ca^e^fory (^(Sign(B),^(B)) of its own theory of algebraic 
equations. 

188 
Chapter 3: Equational Logic 
Proof. One can define a functor ^:B —>• C^(Sign(B),v4(B)) by mapping an 
object to the associated singleton context: X y-^ [x\X). 
Then 
{eoe){X) 
= 
e{x:X) 
= 
X. 
{9oe){xi:Xu...,Xn:Xn) 
= 0{X, x • • - x X^) 
= {z:Xi 
X •" X Xn) 
^ 
(xi:Xu...,Xn:Xn). 
• 
This is a useful result; it shows that instead of the diagrammatic categor-
ical language one can use a type theoretic "internal" language to establish 
certain results in a category B with finite products. Explicitly, if we wish to 
prove that two arrows in B that we can describe as terms are equal, then it 
suffices to prove the equality between these terms in the equational logic with 
specification (Sign(B),>l(B)) associated with B. The weakness of this result 
however, lies in the fact that the terms that occur in our equational logic are 
of very simple form. For example, if we have a group object in B—as described 
in Example 3.3.1—then we can use the language of types and terms and the 
associated equational logic to prove things about such an object (living in 
an arbitrary universe B). This is what is usually done in mathematics (form 
a logician's point of view): one uses a suitable internal language to reason 
directly in a particular structure—but usually with a language which is more 
expressive than the one we consider so far. 
Also, one can understand every finite product preserving functor F : B ^ 
C 
as a functorial model of the specification (Sign(B),^(B)) of B in the category 
C. Thus F : B -> C is a model of (the theory of) B in C. 
Similar correspondences between certain kinds of categories and certain 
kinds of theories have been established. Most famous is the correspondence 
between categories with finite limits and "essentially algebraic" theories 
(see [83]). In these essentially algebraic theories one has (hierarchies of) par-
tial operations, with the domain of an operation described by the extension of 
a finite conjunction of equations involving operations which are lower in the 
hierarchy. 
Exercises 
3.3.1. 
Check in detail that the equations in Example 3.3.1 lead to the diagrams 
describing an internal group. 
3.3.2. 
The following is bcised on Exercise 1.2.3. 
(i) 
Show that the category Sets, of pointed sets (or of sets and pcirticd 
functions) has finite limits. 

Section 
3.3: Algebraic 
specifications 
189 
(ii) Let E be a many-sorted signature and M'.Ci{T?) -> Sets* be a finite 
product preserving functor [i.e. a partial E-algebra). Find out what it 
means for a conditional E-equation to hold in M.; pay special attention 
to undefinedness. 
3.3.3. 
Consider a category B with finite products. Show that the following 
Sign(IB)-equations hold. 
(i) 
For an object X G . 
x:X 
\- i d x ( ^ ) = x 
x. 
(ii) For composable maps 
m ]n> 
x:Xh{gof){x)=zg(y)[f{x)ly\. 
3.3.4. 
Let (E, A) be an equational signature. For a category B with finite products, 
let M o d ( ( E , A)^ B ) be the category of models of (E, ^ ) in B consisting of fi-
nite product preserving functors Cl(Yi^A) 
—¥ B and natural transformations 
between them. 
(i) 
Show that each functor K:M —> A in F P C a t induces a functor 
M o d ( ( E , ^ ) , B ) 
^ Mod((E,>4),A) 
by composition with 
K. 
(ii) Show also that each morphism </>: (E',,4') —)• ( E , ^ ) of algebraic speci-
fications induces a functor 
M o d ( ( E , ^ ) , B ) 
^ M o d ( ( E ' , ^ ' ) . I S ) . 
[Thus morphisms of receiving categories and of algebraic specifications act 
in opposite directions on models. This gives rise to a "fibred span", see 
Definition 9.1.5.] 
3.3.5. 
Let ( E , ^ ) and ( E ' , ^ ' ) be algebraic specifications and consider a functor 
a{i:,A) 
-^ a{Y.',A') 
in F P C a t . Explain how (the categorical notion of) 
faithfulness of this functor corresponds to (the logical notion of) conser-
vativity: if an equation holds after translation, then it must already hold 
before the translation. 
3.3.6. 
For an algebraic specification (E,^4), let ( ^ l x ( E , ^ ) be the (Cartesian 
closed) category formed as follows. Its types are obtained by closing the 
atomic types in E under 1, x, ->. And its morphisms |M|: (T —)• r are equiv-
alence classes | M | of terms x:(j V- M: r, where two terms are equivalent if 
one can prove from the axioms in A that they are (propositionally) equal. 
(In this case the conversions associated with 1, x, —)• are included in the in-
ternal equahty, via the rule (from external to internal equality), described 
in the beginning of the previous section.) 
(i) 
Check that C ^ l x ( E , ^ ) is a CCC, and that for an arbitrary CCC C 

190 
Chapter 3: Equational Logic 
there is a bijective correspondence 
m^iE.A) 
^ C 
i n C C C 
(E, A) 
>• (Sign(Q, AiQ) 
in AlgSpec 
(ii) Let B be a category with finite products, and C be a Cartesian closed 
category. Establish a correspondence 
C^lx(Sign(B), AiM)) 
^ C 
in CCC 
B 
^ C 
in FPCat 
[A standard gluing argument shows that the resulting functor B -^ 
C^lx(Sign(B),^(B)) is full and faithful, see e.g. [183, Annexe C\ or [61, 
4.10]. This means that adding exponents to an algebraic theory does not in-
troduce new terms between old types, or new equations between old terms.] 
3.4 Fibred 
equality 
We start with a categorical description of equality in terms of adjunctions; to 
be more precise, in terms of left adjoints to contraction functors S*. It was 
first put forward by Lawvere in [193]. This approach captures the mate rule 
for equality in Lemma 3.2.3 categorically. The present section contains the 
technical prerequisites, and the next section shows how this fibred equality is 
used for the semantics of conditional equations. The goal is the fundamental 
Definition 3.5.3 of validity of an equation in a 
fibration. 
In a (base) category with Cartesian products x we shall write for objects 
/ , J 
S = S{I,J) 
= {id, n') 
^^ 
^^ 
^ 
I X J 
^ {I X J) X J 
for the 'parametrised' diagonal which duplicates J, with parameter /. It is 
used to interpret contraction for types, see for example in the proof of Theo-
rem 2.2.5 (iii). Notice that such a diagonal is a split mono: it is a section of 
the two projections 
( / x j ) x j = 4 / x j . 
E 
3.4.1. Definition. Let 
j^P be a fibration on a base category B with Carte-
sian products. 
(i) This p is said to have (simple) equality if both 
• for every pair /, J G B, each contraction functor(J(/, J)* has a left adjoint 
Eq/,J = 
Us(i,J) 
E/xj 
' 
^ E ( / x J ) x J -

Section 
3.4-' Fibred equality 
191 
• the Beck-Chevalley condition holds: for each map u: K ^ I in M (between 
the parameter objects) the canonical natural transformation 
Eqx,j(w X id)* => ({u x id) x id)*Eq/,j 
is an isomorphism. 
(ii) If p is a fibration with fibred finite products x, then we say that p has 
equality with the Probenius property (or briefly, equality satisfying 
Frobenius) if it has equality as described above in such a way that for all 
objects X E E(/xj)xJ ^nd Y E E / x j , the canonical map 
Eqjj{S*(X) 
X Y) 
^ X X 
Eqj,j(Y) 
is an isomorphism. 
The canonical Beck-Chevalley map is obtained in the standard way by trans-
posing the composite 
{u X id*(7/) 
{u X id)* 
^ {u X id)*J/,jEq/,j = S*j^ j{{u x id) x id)*Eq/,j 
With this notion of equality we will be able to define validity of an equation 
between morphisms (terms) in a base category, see Definition 3.5.3 in the 
next section. In this section we concentrate on the technicalities of such fibred 
equality. 
Note that the above definition speaks of simple equality. This is to distin-
guish it from other forms of equality, to be described later in Section 9.3. The 
name 'simple' refers to an involvement of simple fibrations, see Exercise 3.4.1 
below. In this and the next few chapters we shall only use simple equality and 
therefore we can safely omit the word 'simple' for the time being. 
Above, we only consider left adjoints to the contraction functors S*. In 
presence of fibred exponents, these left adjoints induce right adjoints to S*, 
see Exercise 3.4.2. 
E 
3.4.2. Notation. Let 
^P be a fibration with equality as described before. 
Assume p has a terminal object functor 1:B -^ E, see Lemma 1.8.8. For 
parallel maps K, i;: / =t J in B we write 
Eq(u,v) 
1^' ((id,«),t;)'(Eq/,j(l)) € E/ 

192 
Chapter 3: Equational Logic 
in a situation: 
Eq(i/,i;) 
^ Eq/,j(l) 
((id,ti),t;) 
, , 
,, 
, 
8 
^ 
^ 
I 
^ {I X J)x 
J ^ 
I X J 
where 1 = 1(7 x J) is the terminal object in the fibre over I x J. This yields an 
equality predicate Eq(w, v) in the fibre over the domain I of the maps u^v. One 
thinks of the predicate Eq{u, v) at i G / as expressing the truth of ^(i) =j 
v{i) 
in what may be called the "internal logic of the fibration", i, e. in the logic 
which is based on what holds in this fibration, see the next chapter. We thus 
say that u,v: I :=t J are internally equal if there is a "proof 1 -> Eq(w, v) 
over /. This need not be the same as external equality oiu^v: I =t J, which 
simply means equality u — voiu^vd^s 
morphisms of the base category. Below, 
in Lemma 3.4.5 we shall formally prove that internal equality is reflexive, so 
that external equality implies internal equality. The converse need not be 
the case—see the next section for examples. In case internal equality in a 
fibration 
does imply external equality we will say that the fibration has very 
strong equality. The logic then often called extensional. This terminology 
using strength is borrowed from type theory where "strong" and "very strong" 
forms of equality exist, see Section 11.4 later on. 
Substitution in such equality predicates Eq(t/, v) is done by composition: 
^ 
(((id,^/),t;)ot^)*Eq(l) 
= [{w X id) X id) o ((id, uo w),v o w;))*Eq(l) 
= ((id, u o w), V o w)* {{w X id) x id)*Eq(l) 
= ((id, uo w),v o w)*Eq{w 
x id)*(l)) 
by Beck-Chevalley 
^ 
{{id,uow),vowyEq{l) 
= Eq{u o w,v o w). 
As a special case of Frobenius one obtains for the projection morphism 
w: (I X J) X J ^ I X J that 
Eq/,j(X X y ) ^ Eq/,j((J*7r*(X) x Y) ^ 7r*(X) x E q / , j ( y ) . 
And so in particular for y = 1 we get 
Eqi,j{X)^7r*(X)xEqi,j(l). 
This latter isomorphism is often useful. Informally it says that 
Eq(^)(.j,j') = X(ij) A (j = j / ) . 

Section 3.4'- Fibred equality 
193 
We continue with a basic observation. 
3.4.3. Lemma. A fibration with coproducts U^ (satisfying Frobenius) has 
equality Eq (satisfying Frobenius). 
E 
Proof. Suppose 
jrP has coproducts. Since every reindexing functor u* has a 
left adjoint JJ^, we especially have left adjoints (]J^ H J*) to contraction func-
tors S*. Beck-Chevalley holds, since for u: K -> / the following is a pullback 
diagram in B. 
K X J -
w X id 
S{K, 
J)=S 
{K xJ)x 
J 
•^ I X J 
Y 
\8^6{I,J) 
{u X id) X id 
•^^ {I xJ)x 
J 
In case p has fibred finite products and the coproducts of p satisfy the Frobe-
nius property, then Frobenius obviously holds for equality as well. 
• 
3.4.4. Examiples. (i) By the previous result (plus Proposition 1.9.8 and 
Lemma 1.9.7), each codomain 
fibration 
I 
has equality satisfying Frobe-
nius. For parallel arrows i/, f: / =1 J in B one has, following 3.4.2, an equality 
predicate, 
Eq{u, v) = ((id, u), vriUsi^)) 
= ((id,«), «)*(<J) 
in a pullback situation: 
Eq{u,v) 
K — 
^ I X J 
Y 
{{id,u),v) 
\S = 5{I,J) 
{IxJ)xJ 
It is easily established that Eq{u, v) is then the equaliser of u and v: this is in 
fact the standard way to get equalisers via pullbacks and products. Thus the 
notation Eq(K, v) for the equaliser of u^v (as used for example in the previous 
section) coincides with the notation introduced in 3.4.2 above. 
Sub(l) 
(ii) The situation for a subobject 
fibration 
I 
is similar: since monos 
are closed under composition and the diagonal S = (id, TT') is monic, each 
pullback functor S* has a left adjoint by composition. Hence equality comes 
for free in subobject fibrations. It is easily verified that Frobenius holds. 

194 
Chapter 3: Equational Logic 
(iii) Suppose C is a category with initial object 0. The family fibration 
Fam(C) 
i 
then has equality: for a family X = {^{i,j))(i,j)eixJ 
of C-objects over 
I X J one defines a family over (/ x J) x J by 
We get a bijective correspondence 
(Eq(X)(,jj/)) 
^ 
jyjiJJ')) 
i^iij)) 
^ (^(ijJ)) = ^*(^(»JJO) 
In case the category C additionally has finite products in such a way that 
functors Z x (—):C -> C preserve the initial object (which simply means 
0 —> Z x 0 is an isomorphism), then the family fibration has finite products 
as well (by Example 1.8.3 (i)) and equality satisfies the Frobenius property: 
for a family Y = (^(ijj')) over (/ x J) x J, 
0 
otherwise 
Eq(J*(y)xX)(,-,-,.) = j 
(Y X EafXl) 
= i ^^'^'''^ "" ^^'^'^ 
'^^ " ^' 
V 
"^"^ ^HiJJ') 
I V(ijjO X 0 ^ 0 otherwise. 
The Frobenius property is thus a distributivity condition (like in Exer-
cise 1.9.6). 
Notice that for functions u^v.I^ 
J the family Eq(w, v) over / (see 3.4.2) 
is given by 
(i) = v[i) 
E^("'^)' = \Oelse: 
(where 1, 0 are terminal and initial object in C). 
(iv) Let (D,?/) be an equational specification, consisting of a signature D 
and a set % of possibly conditional equations between E-terms. In the first 
section of this chapter we outlined a general construction which produces a 
term model fibration that captures the logic involved. We claim that this fibra-
/:(E,^) 
tion 
4- 
thus associated with this equational specification (X),?^) admits 
equality satisfying Frobenius. For contexts r , r ' E C^(S) we must exhibit a 
left adjoint to J*, where 5 is the parametrised diagonal r , r ' -^ r , r ' , r ' in 
the base category ff(S). For convenience we suppose F' to be [x: a) of length 
one. We then define an equality functor, using propositional equality =^ from 

Section 3.4' Fibred equality 
195 
equational logic: 
Eq(r, x:a\e) 
=^ (F, x: a,y:a\e,x 
= , y). 
The required adjunction boils down to a bijective correspondence 
T,x:a,y:a 
\Q,x =a y ^ Q' 
T,x:(T\e 
h0'[x/y] = J*(0') 
which is (essentially) Lawvere's equality rule as described in Lemma 3.2.3. 
The Frobenius property holds because 
Eq{{T,x:a\e[x/y])x{T,x:a\&)) 
- 
Eq{T,x:a\e[x/yl&) 
= {T,x:a,y:(T\e[x/y],&,x 
=a y) 
= {T,x:a,y:a 
\ e , 0 ' , x = ^ y) 
= (r, x: cr, y: (T I 0) X (F, x: cr, y: cr | 0', x -^ y) 
= (F, x: cr, I/: cr I 0) X Eq(F, x: a \ Q') 
where the isomorphism = follows from Lawvere's extended equality rule in 
Lemma 3.2.4. The Frobenius property is thus a result of the parametrised 
formulation of this rule involving a proposition context 0. 
One easily verifies that for parallel context morphisms M,N:T 
=t A in 
Ci{Ti) equality is given by the proposition context 
Eq{M,N) 
= (F I M =^ N). 
Hence these morphisms M, TV in the base category are internally equal in the 
fibration if one can prove (using the axioms from 7i) that 
F | 0 hM,-=,, Ni. 
for each i. Hence by using a different set of axioms ?/' one gets a different 
fibration 
i 
on the same base category, in which other internal equalities 
hold. This gives us a different logic to reason about morphisms in the base 
category C^(E), i-e. about E-terms. 
This concludes the series of examples. 
The following lemma gives some standard combinators for equality. 
E 
3.4.5. Lemma. Let 
-^P be a fibration with fibred finite products and equal-
ity satisfying Frobenius. Then, for parallel morphisms u,v^w:I 
^ 
J and 

196 
Chapter 3: Equational Logic 
t: I X J -^ K inM there are the following vertical combinators in E. 
1 
^ Eq(w, u) 
Eq{u,v) 
Eq(u,v) X Eq{v,w) 
Eq{u,v) 
sym 
trans 
-^ Eq{v,u) 
-^ Eq{u, w) 
repi 
subst 
Eq{t o (id, w),/ o (id, v)) 
u*{X) X Eq{u,v) 
These are preserved under reindexing and make some ^obvious' diagrams com-
mute, e.g., 
1 xEq(^,i;) 
w*(X) X 1 
refl X id I 
^ ^ \ ^ 
id x refl 
Eq{u,u) X Eq{u,v) 
>- Eq[u,v) 
'"*(X) x Eq{u,u) 
trans 
subst 
u*{X) 
Proof. By reindexing the unit r/: 1 -> (J*Eq(l) above I x J along (id, u):I 
^ 
I X J ^ one obtains the reflexivity combinator refl as composite 
(id,i/)*(r/) 
1 ^ (id,i/)*(l) ^ 
—^ 
(id,i/)*(J*Eq(l) ^ ((id,iu),ti)*Eq(l) = 
Eq{u,u). 
Let 7 be the parametrised twist map (Trxid, TT' O TT): {IXJ)XJ 
^ 
{IxJ)xJ 
which exchanges the first and second J. Then 
Eq{u,v) 
= ((id,t/),t;)*Eq(l) 
- 
((id,t/),t;)*7*Eq(l) 
- 
((id,i;),w)*Eq(l) 
= 
Eq{v,u) 
This yields the symmetry combinator sym. The transitivity combinator trans 
arises as follows. Consider above {I x J) x J the first projection 
Eq(l) X 1 
^ Eq(l) ^ S*{7r x id)*Eq(l). 
By transposing across (Eq H 5*) and using that I = {TT x id)*(l) on the left 

Section 
3.4'- Fibred equality 
197 
hand side, one obtains 
Eq(Eq(l)x(7rxidr(l)) 
= 7r*Eq(l) X Eq((7r X id)*(l)) 
by Frobenius 
^ 7r*Eq(l) X ((TT X id) x id)*Eq(l) by Beck-Chevalley. 
Thus we have a map 
7r*Eq(l) X ((TT X id) X id)*Eq(l) 
^ (TT X id)*Eq(l) 
above ((/ x J) x J) x J. By reindexing along the 4-tuple (((id, u),v), w): I -^ 
{{I X J) X J) X J one gets the required transitivity combinator. 
For the replacement combinator repi, assume a map t: I x J —>• /i in B, and 
consider above I x J the composite 
refl 
1 
>• Eq{t, t) — Eq{t o n o S,t o n x id o 5) 
^ 5*{Eq{to7r,to7r 
x id)) 
It yields a morphism above (7 x J) x J by transposition: 
Eq(l) 
>• Eq{t o TT,/ o TT x id) 
Hence by reindexing along {{id,u),v): I -^ (I x J) x J one obtains the re-
quired map 
Eq{u, v) 
>- Eq{t o (id, u),t o (id, v)) 
Finally for the substitution combinator subst notice that 7r'*(X) 
= 
(5*7r'*(X), so we have over I x J a, projection map 
7r'*(X) X 1 
>-J*7r'*(X) 
By transposing and using Frobenius we get 
7r*7r'*(X) X Eq(l) 
>- 
7T'*{X) 
The subst combinator arises by reindexing along {{id,u),v). 
• 
The next result gives an application of these combinators; the proof requires 
some elementary, but non-trivial, categorical manipulations. The result states 
that two tuples are equal in the internal logic of a fibration if and only if their 
components are equal. It also occurs in Lawvere's paper [193] (as the second 
corollary on page 10), but some stronger form of Beck-Chevalley is used there. 
See Exercise 3.4.7 below. 
For convenience, we present the result for fibred preorders. 

198 
Chapter 3: Equational Logic 
3.4.6. Proposition. Consider a fibred preorder with fibred finite products and 
equality satisfying 
Frobenius. 
Then there is a vertical 
isomorphism 
Eq{{ui,U2),{vi,V2)) 
= Eq(i/i,t'i) A Eq(w2,'^^2). 
Proof. Assume the morphisms wi, t^i, W25 ^2 in the base category are given as 
follows. 
Ui 
U2 
Vi 
V2 
The (<)-part of the result is easy, since by applying the above replacement 
combinator one obtains 
Eq{{ui,U2),{vi,V2)) 
< Eq{n o 7T' o {id,{ui,U2)), 
TT o 7T' o 
{id,{vi,V2))) 
= 
Eq{ui,vi) 
and similarly for Eq(w2, ^2)-
The (>)-part requires more work. Our first aim is to prove 
Eq(wi o TT, i;i o TT) < Eq{ui x id, vi x id). 
(*) 
Consider therefore the diagram 
(/ X K) X J 
^ (/ X K) X (J X A') 
((/ X K) X J) X J 
^ ((/ X K) X {J X K)) X (J X K) 
which commutes for the "obvious" maps 
a = 
(TT, (TT', TT' O TT)) 
/J 
= 
(^(^7T O TT, (TT' O TT, TT' O TT O T T ) ) , 
(TT', TT' O TT O T T ) ) . 
The terminal object 1 above {I x K) x J comes together with a morphism 
a-(7?) 
l S a * ( l ) 
< 
a*5*Eq{l)^S*0*Eq{l) 
which yields by transposition 
Eq(l) < /?*Eq(l) 
above ((/ x K) 
xJ)xJ. 
Reindexing along ((id, wi o TT), vi o TT): / x K —)• ((/ x K) x J) x J yields the 
required map (*). 

Section 3,4- Fibred equality 
199 
Using the inequality (*) we get: 
Eq{ui,vi) 
^ 
(id,i;2)*7r*Eq(iii,i;i) 
= (id, V2)*Eq{ui o TT, tJi o TT) 
< (id, i;2)*Eq('Wi x id, t;! x id) 
= 
Eq{{ui,V2),{vi,V2)). 
Further, from replacement we obtain 
Eq(ii2,^2) < Eq(t/i X id o (id,i/2), wi X id o (id,i;2)) 
= 
Eq{{ui,U2),{ui,V2)). 
But then 
Eq(?ii,i;i) A Eq(ii2,^2) - 
Eq(w2, ^2) A Eq(wi,-t;!) 
< Eq((wi, 1/2), (^^1, ^^2)) A Eq{{ui,V2), 
(i^i, ^^2)) 
< 
Eq((t/i,i/2),(vi,t^2)), 
the latter by transitivity. 
• 
For future use, we mention at the end of this section what it means for a 
morphism of fibrations to preserve equality Eq. 
E 
E' 
3.4.7. Definition. Let 
^P —^ 
v 
be a morphism of fibrations. We say 
® 
. 
® . 
. 
. 
. 
that (/i, L) preserves equality (or, is a morphism of 
fibrations 
with 
equality) if A^:B ^ B' preserves finite products and for each pair of objects 
/, J E B, the canonical natural transformation 
^^[KI,KJ) 
7I* L=^-f;L 
Eq(/, J) 
is an isomorphism—where ji. KIxKJ 
^ K{IxJ) 
and 72: {KIxKJ)xKJ 
^ 
K{{I X J) X J) are the canonical isomorphisms. 
Exercises 
3.4.1. 
Let B be a category with finite products. 
(i) 
Extend the assignment (/, J) 1-^ S{I, J) = (id, TT'): I X J -^ {I X J) X J 
to a functor S: s(B) -^ B"^ . 
(ii) Show that S sends Cartesian morphisms (for the simple fibration on B) 
to puUback squares in B {i.e. Cartesian morphisms for the codomain 
functor on B). 
E 
3.4.2. 
Assume 
-^P is a fibred CCC with equality. 
B 
(i) 
Show that the Frobenius property for equality holds automatically. 

200 
Chapter 3: Equational Logic 
(ii) By definition, each contraction functor S{I, J)* has a left adjoint ]J^. 
Show that it also has a right adjoint J^^, given by 
(E/X7 3X)^ 
(Eq/,41) => 7r*(X) e % x j ) x 7 ) . 
[Notice that equality = is left adjoint U^ at 1 and inequality 7^ is right 
adjoint f^^ at 0.] 
3.4.3. 
Verify that the Beck-Che valley condition for the fibration 
i 
in Ex-
ample 3.4.4 regulates the proper distribution of substitution over equations. 
Describe the isomorphism = which was used in proving the Frobenius prop-
erty. 
3.4.4. 
Describe how the canonical natural transformations in Definitions 3.4.1 
and 3.4.7 are obtained. 
3.4.5. 
Consider the projections TT' 0 TT, TT': (/ X J) X J zit J in the base category of 
a fibration with equality. Show that 
Eq(7r'o7r,7r')^Eq(l). 
E 
E' 
3.4.6. 
Let 
IP'^' 
¥ b e a morphism between fibrations p and D with fibred 
terminal object and equality. 
(i) 
Assume (K, L) preserves the terminal object and equality. Verify that 
for parallel arrows u,v in B the canonical vertical map 
Eq\Ku, 
Kv) 
^ L{Eci{u, v)) 
(*) 
is an isomorphism 
(ii) Assume that p and p also have fibred finite products and that (A", L) 
preserves all of these. Assume additionally that Frobenius holds both 
for p and for p'. Show that if the maps (*) in (i) are isomorphisms (for 
all parallel ti,t^), then {K,L) preserves equality. 
[Hint. Use the previous exercise.] 
3.4.7. 
The point of this exercise is to check the details of Lawvere's proof 
E 
(from [193]) of Proposition 3.4.6 for a fibration j^P with coproducts ]J^, 
satisfying Frobenius. By Lemma 3.4.3 this fibration then has equality sat-
isfying Frobenius. Check that 
(i) 
LJ..id('^'(^0 X '^'*(^2)) ^ T ' U „ ( X I ) X 7:"(X2). 
(i") U.Sii,jxK)i^) 
- Us{i,j)i^) 
X Us(i,K)W' 
using that there is a puUback 

Section 3.5: Fihrations for equational logic 
201 
square 
/ X ( J X K) 
^ (/ X J ) X (/ X K) 
Y 
I 
Y 
\s 
((/ X (J X K)) X (J X A') 
^ ((/ X J) X J) X ((/ X K) x /C) 
in which the horizontal arrows are the obvious maps, 
(iv) And finally, that Eq((wi, W2), (^i, ^2)) — Eq(wi, ui) A Eq(?i2, ^2). 
3.5 Fihrations for equational logic 
In this section we give meaning to equations in fibrations with equality, as 
described in the previous section. This fibred approach has as main advantages 
that it is very general and flexible and that it scales up smoothly to other 
logics. We start with the definition of validity of a (conditional) equation in 
a fibration. Then we show how difl'erent fibrations on the same base category 
can capture diflferent notions of equality for arrows in this base category. This 
is what we mean by the flexibility of the fibred approach: using diflferent logics 
to reason about one (base) category can be done by putting diflferent 
fibrations 
on this same base category. 
3.5.1. Definition. An Eq-fibration is a fibration which 
(i) is a fibred preorder (i.e. all its fibre categories are preorders); 
(ii) has fibred finite products (T, A) and finite products (1, x) in its base 
category; 
(iii) has equality Eq satisfying Frobenius. 
We impose the restriction to fibred preorders in (i) because we limit our 
attention in this chapter to models of logics, interpreting provability and not 
proofs (like in type theories). 
3.5.2. Examples, (i) An important example of an Eq-fibration is the syn-
tactically constructed 
fibration 
i 
associated with an equational specifi-
-^ 
C6(E) 
^ 
^ 
cation (E,?{), see Example 3.4.4 (iv). It will be called the classifying Eq-
fibration 
of(E,?/). 
Sub(l) 
(ii) For each category B with finite limits, the 
fibration 
i 
ofsubobjects 
of B is an Eq-fibration, see Example 3.4.4 (ii). 
(iii) Let X be a poset (or a preorder) with finite meets and a bottom 
Fam(X) 
element. The family 
fibration 
i 
is then an Eq-fibration, see Exam-
Sets 
pie 3.4.4 (iii). 

202 
Chapter 3: Equational Logic 
In the beginning of Section 3.3 we briefly described what it means for a 
conditional equation to hold in a category with finite limits. Below we show 
that validity of equations can be described more generally in Eq-fibrations, 
with the special case of subobject fibrations capturing this earlier mentioned 
situation. 
3.5.3. Definition (Validity in Eq-fibrations). Consider a situation 
E 
r 
ff (E) 
— 
^ M 
where p is an Eq-fibration and A^ is a model of the signature D in the base 
category B. We say that a E-equation 
holds in M or is validated by M with respect to p if 
Eq{M{Mi),M{M[)) 
A"'AEq{M{Mn)M{M^)) 
<Eq{M{N),M{N')) 
in the preorder fibre category above the interpretation A^(r) of the type 
context r in IB. Often we simply say that such an equation holds in A4 without 
reference to the fibration p if the latter is understood from the context. 
E 
Thus it becomes clear that a fibred category i on IB provides us with a 
logic to reason about what happens in IB. This shows how fibred (preorder) 
categories play a role in logic. We will expand on this point shortly, but first, 
we notice that for a model A^:C^(E) ^ B in a category B with finite limits 
one has a situation 
Sub(B) 
M 
«(E) 
in which an equation holds in M. as defined above with respect to the sub-
object fibration if and only if it holds in M as described in the beginning of 
Section 3.3 (after Example 3.3.1). Thus we can conclude that the previous 
fibred definition does not lead to ambiguity and that its notion of validation 
of equations extends the earlier one for ordinary categories. 
In Example 3.4.4 (iv) we saw how difi'erent equational specifications (E,?{) 
and (E,?/') give rise to different 
fibrations 
i 
and 
i 
to reason 
about the same base category. Next we give two mathematical examples of 

Section 3.5: Fihrations for equational logic 
203 
this phenomenon: we show how different notions of equality—for continuous 
functions between dcpos, and for relations (as morphisms) between sets—can 
be captured by different fibrations on the base category Dcpo of dcpos and 
continuous functions, and on the base category REL of sets and relations. 
These different notions of equality really require different fibrations because 
equality is determined by its defining adjunction (Eq H (J*), and is thus directly 
linked to the fibrations reindexing operation (—)*. 
Recall from 3.4.2 that two parallel arrows u^v in the base category of an 
Eq-fibration are internally equal if an inequality T < Eq(w, v) holds over their 
domain. External equality simply means u = v. 
3.5.4. Extended example. The category of directed complete partial or-
ders (dcpos) and (Scott-) continuous {i.e. directed suprema V preserving) 
functions will be written as Dcpo. The singleton dcpo forms a terminal ob-
ject, and the Cartesian product of the underlying sets of two dcpos, with 
componentwise order, yields the product in Dcpo. A subset A C X of a, dcpo 
X is called admissible if it is closed under directed suprema: for each directed 
a C X with a C A one has V' a £ A. A category ASub(Dcpo) is formed with 
such admissible subsets as objects. We consider these as certain predicates 
on dcpos. A morphism {AC X) -^ {B C Y) in ASub(Dcpo) is a continuous 
function f:X 
-> Y with the property that x E: A implies f{x) G B, for all 
X £ X. This means that there is a commuting diagram (in Sets or in Dcpo) 
A 
^ B 
X 
^Y 
ASub(Dcpo) 
There is an obvious forgetful functor 
4- 
, namely {A C X) ^-^ X 
Dcpo 
sending a predicate to its carrier (type). It is a split fibration, with reindexing 
B CY along f:X -^Y 
given by 
r{B) = 
{xeX\f(x)eB}. 
In particular we have for a diagonal S = S{X,Y) 
= (id,7r'):X x Y -^ {X x 
Y) xY and for an admissible subset B C {X xY) 
xY 
that 
6^B) = {{x,y) \ {x,y,y) e B} C X 
xY. 
A left adjoint Eq to this S* is then defined by 
Eq{A) = {(x, y, y')\y 
= y' and (x, y)£A\C{XxY)x 
Y. 
Notice that this is an admissible subset again. Hence the usual definitions for 
sets work in this case as well. For parallel arrows f.g.X 
=^ Y in Dcpo the 

204 
Chapter 3: Equational Logic 
corresponding equality on X is 
Eq{f,g) = 
{x€X\fix)==g{x)]. 
Since the terminal object over X G Dcpo is (X C X) we get 
/, g are internally equal <^ X C Eq(/, g) 
^ 
yxeX.f{x)=g{x) 
^ 
f = 
g:X-^Y 
O f^g are externally equal. 
We now put a different logic on Dcpo by taking different subsets as predi-
cates. Call a subset A C X down closed ii y < x and x E A implies y E A. 
These down closed subsets are organised in a category DSub(Dcpo) as be-
fore: a morphism {A C X) -^ {B C Y) is a continuous function f:X 
-^ Y 
DSub(Dcpo) 
with f(x) E B for all x E A. Again we get a split fibration 
I 
by 
Dcpo 
{A C X) ^ XJ with reindexing as above. The earlier definition of equality 
does not yield a down closed subset, so we now define for A C X x y, 
Eq{A) = {{x, y, y)\3z 
eY.y 
< z and y < z and {x, z) G A). 
We then get bijective correspondences 
Eq(^) C B 
over {X 
xY)xY 
AC(J*(B) 
o v e r X x Y 
as follows. 
• Assuming Eq(yl) C B we have for {x, y) E A that {x, y, y) G Eq(74) C B, so 
that [x,y) 
eS*(B). 
• And assuming A C S*{B), we get for (x,y,y') 
G Eq(74), say with y,y' < z 
where [x^ z) G A, that (x, z, z) G B. Since B is down closed and (x, y, y') < 
(ar, z, z) we have [x, y, y') G B. 
For f,g:Xz=tY 
in Dcpo we now get 
Eq(/, g) = {xeX\3zeY. 
f{x) < z and g{x) < z} 
so that 
f,g are internally equal <=> X C Eq(/,^) 
^ 
"ix eX.Bz 
e Y. f{x) < z and g{x) < z. 
DSub(Dcpo) 
This fibration 
4- 
thus captures a different loeic to reason about 
Dcpo: in the logic incorporated by this fibration two morphisms 
f.g-.Xzz^Y 
are equal if and only f{x),g{x) 
have an upper bound in Y, for each x £ X. 

Section 3.5: Fibrations for equational logic 
205 
We describe a similar phenomenon for relations. 
3.5.5. Extended example. We write REL for the category of sets and re-
lations. Objects are sets /, and morphisms / -> J are relations R C I x J. 
Often one uses the notation R: / —f-)- J to indicate that i? is a relation from 
I to J. The identity I —H^ I is then the diagonal relation (or equality) on /, 
and the composite of R: I —f-)- J and S: J —M- K is the relational composite: 
SoR=:{{i,k) 
\3jeJ.R{iJ) 
andS'(i,Ar)}C/x K. 
A relation R: / —H- J can be understood as a multifunction I -^ J. That 
is, as a function / -^ PJ, given by i i-> Ri = {j £ J \ i?(i, j)}, which may 
have many outputs. Under this view one considers the category REL as the 
Kleisli category of the powerset monad P on Sets. 
The terminal object in REL is the empty set 0, and the Cartesian product 
of sets /, J is the disjoint union / + J , with graphs of the coprojections K: I -^ 
I -\- J and K'\ J -^ I -\- J as projections: 
TT = {(z,i) I 2: = Ki) 
and 
TT' = {[^^j] \ ^ — ^'2^-
The tuple of two maps R : K —h^ / and S : K —1-> J is the relation, 
(i^, S) — {(i, z) I (z = Ki and R{i,j)) 
or {z — Ki and 
S{i,j)}. 
Thus REL has finite products. Actually, it also has finite coproducts, given 
by these same formulas 0 and I -\- J (on objects). 
There may be difi'erent notions of equality for multifunctions R,S: I ^ 
PJ. 
For example, there is the extensional view that such multifunctions are equal 
if and only if they yield the same output sets for each input. But one may 
also consider two multifunctions i?, S as equal if for each input i the output 
sets Ri and Si have elements in common {i.e. are not disjoint). 
The point of this example is to show that these different notions of equality 
live in different fibrations on top of the category REL of sets and relations. 
These give us different ways to reason about relations. The two fibrations 
incorporating the two abovementioned notions of equality, will be written as 
PredREL 
EPredREL 
^ 
and 
i 
, where the latter fibration gives the extensional 
REL 
REL 
' 
^ 
view that relations R,S: I ^ J are equal (in the logic of the fibration) if and 
only if the subsets R, S C I x J are equal. 
We start with the 'non-extensional' example. The total category PredREL 
is a category of relations with predicates. It has 
objects 
pairs (/, X) where / is a set and X C PI is a set of subsets 
of/. 
morphisms 
(X C PI) -^ {Y C PJ) are relations R C I x J from 
I to J satisfying: for each non-empty a E X, there is a 
non-empty b C[j-^^ Ri with b EY. 

206 
Chapter 3: Equational Logic 
Identities and composites in PredREL are as in the category REL of rela-
PredREL 
tions. This gives us a forgetful functor 
i 
by (/, X) »-> /. In the fibre 
over / G REL we define a preordering: 
{
for each non-empty a G X, 
there is a non-empty 6 C a with h ^Y. 
In this preorder the predicate PI C PI is top element T. 
PredREL 
The functor 
^ 
is a fibration, since for a relation R : / —h^ J and a 
REL 
' 
predicate Y C PJ on J, we can substitute along R by 
ii*(y) = {a C / I 36 C y Ri. 6 ^ 0 and 6 E Y). 
In particular, for the diagonal S : J —!-)• J -h J we get 
S*(Y) = {a C J I 36 C K{a) U «:'(a). 6 7^ 0 and 6 G Y}. 
where K{a) — {tzj | j E a}. For a predicate X C PJ on J, we define an 
equality predicate Eq(X) C P[J -f- J) as 
Eq(X) 
= {c C J -h J I K-^c) 
U K'-1(C) E X 
and 
Vj e J.Kj e c <^ K'J E C}. 
Then we get a bijective correspondence, 
Eq(X) - ^ Y 
over J -f- J 
X—>(J*(y) 
over J 
which is given as follows. 
• Assume Eq(X) —> Y, and let a E X be non-empty. Then K{a) U «;'(a) E 
Eq(X), so there is a non-empty 6 C /c(a) U /c'(a) with 6 E Y. But then 
ae5^{Y), 
• In the reverse direction, assume X —)• <J*(y), and let c E Eq(X) be non-
empty. Then K~^[C) U K'~^(C) E X is non-empty, so there is a non-empty 
a C K~^(c) U K'~^(C) with a E ^*(y). The latter yields a non-empty 6 C 
K{a) U K'{a) with 6 E Y. But then 6 C c, since for z £ b, either z = KJ or 
z — K'J with j E a C /c~^(c) U /c'~^(c); in both cases we get z E c since 
Vj e J-Kj ec ^ /c'j E c. 
Notice that—for reasons of simplicity—we define equality without parameters. 

Section 3.5: Fibrations for equational logic 
207 
Now we are in a position to compute the equality predicate Eq{R, S) for 
two parallel maps R^ S: I ^ J in the base category REL as 
Eq(R,S) 
=. 
{R,S)*Eq{T) 
= {R, sy{bcj 
+ j \ Vj eJ.Kjeb ^ K'J e 6} 
= {a C / I 36 C Uga(^' S)i.b ^ 0 and Vj eJ.KJeb 
^ 
K'J € b]. 
where T = (PI C PI) is the top element over /. Our claim is then the follow-
PredREL 
ing. Two maps R,S.I^ 
J are equal in the logic of the 
fibration 
i 
, 
that is, there is a map T < Eq{R,S) 
over /, if and only if for each i £ I 
there is a j G J for which R{i,j) and 5(f, j) both hold. The latter can also be 
expressed as: Ri 0 Si 7^ 0, for each i G /. This is the second view of equality 
of multifunctions mentioned above (which is thus captured by the fibration). 
To support the claim, assume T < Eq(i?, S) over /. Then for each i E /, 
we have {i} G 1 = PY, so there is a non-empty a C {i} with a G Eq{R,S). 
Thus a must be {i}, which yields that there is a non-empty 6 C {R,S)i with 
b G Eq(l). Let z £ b; li z = KJ, then also K'J G b and vice-versa, so we may 
assume a pair {KJ,K,'J} 
C {R,S)i. This yields both R{ijj) and 
S{i,j). 
In the reverse direction, if for each i G / there is a j G J with R{i,j) 
and 
5(z, j), then for each non-empty a G PI, say with i G a, we can find a j G J 
with R{i,j) and S{i,j). 
Then {i} C Eq(R,S), 
since 6 = {KJ,K'J} 
G {R, S)i is 
non-empty and is in Eq(T). This means T < 
Eq(R,S). 
EPredREL 
We turn to the second 
fibration 
J- 
, which gives us a logic incor-
porating the 'extensional' equality. We shall be a bit more sketchy and leave 
details to the reader. The total category EPredREL has 
objects 
pairs (/, X) where / is a set and X C PI. 
morphisms 
{X C PI) -^ {Y C PJ) are relations R C I x J such that 
for each a G X we have jj^g^ Ri 
£Y. 
Identities and composites are inherited from REL, so that we get a forgetful 
EPredREL 
functor 
^ 
.In the fibre over / we define X —> Y if and only if 
X CY. 
Reindexing of Y C PJ along R:I -^J 
is given by R*{Y) = {a C 
I I Uzga ^i}- In particular S*(Y) = {a \ /c(a) UK'(a) G Y}. Equality Eq(X) is 
defined as before. We then get for R,S: I ^ J that 
Eq{R,S) = {aCI\^jeJ.{3iea.R{iJ)) 
^ 
{3i e 
a.S{iJ))}. 
The maps R, S are equal in the logic of this second fibration on REL if 
and only if T = PI C Eq(i?, S) if and only if for each i G / one has Vj G 
J.R{i^j) 
O 
^(i, j), if and only if R and S are 'extensionally equal'. This 

208 
Chapter 3: Equational Logic 
concludes the example. 
In Example 3.3.1 we saw what it means to have validity of the defining 
equations of a group in a category. At this stage we recognise this as external 
equality. We can also describe internal equality of these equations in a fibra-
tion. This will give us the notion of an "internal group in a fibration". It is a 
fibration with in its base category an object carrying the operations of a group 
(multiplication, unit, inverse) which internally satisfy the group equations. 
We conclude with the following two lemmas which together yield familiar 
soundness and completeness results for equational logic in Eq-fibrations. 
3.5.6. Lemma (Soundness). Let (E,?/) be an equational specification. In 
case a model M:C£{Ti) -^ IB validates all equations in % (with respect to 
some Eq-fibration with base M), then it validates all equations in the theory of 
Proof. By Lemma 3.4.5, which gives the appropriate combinators for the 
soundness of the rules specific to equational logic. As the reader may verify, 
all the context rules from Section 3.1 are sound, so we are done. 
D 
We should be more explicit about what is going on in this proof with respect 
to substitution: syntactic substitution [L/z] in a proposition M —a M' is 
interpreted by categorical substitution (or reindexing) in a fibration. This is 
because 
Eq(i/ o w^v o vj) — tt;*Eq(w, v) 
as already mentioned in 3.4.2. Notice that composition u o w^v o w ov^ the 
left hand side is substitution in terms, whereas w;* on the right hand side is 
substitution in propositions. Syntactically this equation is 
{M\Llz\ =, M'[L/z]) = (M =<, 
M')[L/z]. 
The weakening and contraction rules are handled as special cases of substitu-
tion, see Example 3.1.1. 
3.5.7. Lemma (Completeness). For an equational specification (E,?{), con-
sider the situation: 
«(E) 
^ ff(E) 
This generic model of S validates precisely the equations in the theory of 
As a result, an equation is derivable from an equational specification (E, ?/) 
if and only if it holds in all (fibred) models of (E,?{). 

Section 3.6: Fibred functorial semantics 
209 
Exercises 
DSub(Dcpo) 
PredREL 
3.5.1. 
Check that internal equality in the 
fibrations 
i 
and 
i 
^ 
*^ 
Dcpo 
REL 
is not transitive. Conclude that the Frobenius property does not hold. 
[Hint. Inspect the construction of the transitivity combinator in the proof 
of Lemma 3.4.5.] 
DSub(Dcpo) 
3.5.2. 
Prove that in the 
fibration 
i 
internal and external equality co-
Dcpo 
incide onY£ 
Dcpo if and only if the order on Y is discrete. 
3.5.3. 
Let Sp be the category of topological spaces and continuous functions. 
ClSub(Sp) 
(i) 
Define a poset 
fibration 
4- 
of closed subsets [A C X) over 
Sp 
topological spaces X. 
(ii) Show that a contraction functor S* associated with a diagonal S\X x 
Y —^ X xY 
xY m Sp has a left adjoint Eq, given on a closed subset 
ACXxYhy 
Eq(A) = {{x, y,y')eXxY 
xY\[x,y)eA3ndy 
= y'}. 
(iii) Prove that equality on y G Sp is very strong [i.e. that internal equahty 
and external equality on Y coincide) in this fibration of closed subsets 
if and only if y is a Hausdorff space. 
3,6 Fibred functorial semantics 
In this section v^e start by describing appropriate morphisms between Eq-fib-
rations preserving the relevant structure. These allov^^ us to describe func-
torial models of an equational specification in a fibration as morphisms of 
Eq-fibrations with the classifying fibration of the specification as domain. We 
also associate an equational specification with an Eq-fibration so that an ad-
joint correspondence between morphisms of Eq-fibrations and morphisms of 
equational specifications can be established (see Proposition 3.6.5). 
In the last part of this section we show how every Eq-fibration gives rise 
to a (quotient) Eq-fibration in which internal and external equality are forced 
to be equal. This quotient enjoys a universal property, which is described in 
terms of morphisms of Eq-fibrations. 
3.6.1. Definition. A morphism (or map) of Eq-fibrations p ^ 
g is a mor-
phism of fibrations p ^ 
q which preserves the structure of Eq-fibrations: it 
preserves finite products in the base category, finite products in the fibre cat-
egories and equality Eq. 
In this way we obtain a subcategory EqFib ^> Fib of Eq-fibrations. We 
may see EqFib as a 2-category, by letting the inclusion be full and faithful 

210 
Chapter 3: Equational Logic 
on 2-cells. Thus, 2-cells between maps of Eq-fibrations are the same as 2-cells 
between these maps as maps of fibrations. 
If we have a morphism of Eq-fibrations in a situation 
H 
K 
then it is obvious that A^:B -^ A preserves external equality: u = v in M 
implies Ku = Kv in A. But K also preserves internal equality, since 
w, V are internally equal => T < Eq(i/, v) 
=> T ^ H{T) < H{Eq{u,v)) 
^Eq{KuJ<v) 
(see Exercise 3.4.6) 
=> Ku, Kv are internally equal. 
As an example, every finite limit preserving functor B —>• A between cate-
Sub(B) 
Sub(A) 
gories B, A with finite limits induces a map of Eq-fibrations 
i 
—> 
i 
B 
A 
between the corresponding subobject fibrations. This map between fibrations 
is described in Lemma 1.7.5. 
E 
3.6.2. Definition. Let (E,?/) be an equational specification and 
-jrP an 
Eq-fibration. A model of (E,?/) in p is a morphism of Eq-fibrations: 
a(S) 
E \ 
ip] 
1 J 
This fibred functorial definition of model will be justified by the following 
result. 
E 
3.6.3. Theorem. Let (E,?/) be an equational specification and let -^P be 
an Eq-fibration. Every model M in B 
E 
C^(E) 
— 
validates the equations in % (with respect to p) if and only if it extends to a 

Section 
3.6: Fibred functorial 
semantics 
211 
(up-tO'isomorphism unique) morphism of Eq-fibrations: 
M' 
C[T.,n) 
— 
^ E 
P 
a{T.) 
M 
A model of equations can thus be identified functorially as a morphism of 
Eq-fibrations. This extends functorial semantics from ordinary categories (see 
Sections 2.2 and 3.3) to fibred categories. 
Proof. Suppose M validates the equations in % with respect to p. We can 
then define a functor M': £(E, ?/) ^ E by 
( r | M i = : , , M ( , . . . , M , = , ^ M ; ; ) ^ 
Eq(A^(Mi),X(M{)) A ... A Eq(;W(Mn),X(M;;)). 
By soundness (Lemma 3.5.6) M' extends to a functor. The resulting pair 
[M^M^) preserves equality by Exercise 3.4.6. 
Conversely, given the above extension M'^ for terms F \- N^ N':a we have 
M\T 
I N =^ N') = M'{Eq{N, N')) ^ 
Eq{M(N),M{N')). 
This shows that M' is determined up-to-isomorphism by M. Further, because 
M' is a functor preserving fibred finite products, we obtain 
T \ N =a N' ^ M =r M' 
is derivable (from U) 
^ 
Eq(7Vi,Ar{)A...AEq(7V^,7V;;) 
<Eq(M,M') 
in£(E,'H) 
<M'{Eq{M,M')) 
inE 
^ 
Eq{M{N,),M{N[)) 
A • • • 
AEq{M(Nm),M(N:,,)) 
<Eq{M{M),M{M')) 
z:> T\N 
=^ N' b M =r M' 
holds in p. 
Hence A4 validates the theory of the equational specification (E,?{), and thus 
certainly its subset 71 of axioms. 
D 
In Section 3.3 we have defined for an (ordinary) category with finite prod-
ucts an associated theory of non-conditional equations. Similarly, for an 
Eq-fibration we will define a theory of conditional equations. Then, a model 

212 
Chapter 3: Equational Logic 
as above in Definition 3.6.2, can alternatively be described as a morphism of 
equational specifications using this induced theory. 
E 
3.6.4. Definition. Let 
]rP be an Eq-fibration. The underlying signature 
Sign(B) of B comes naturally equipped with a set of equations %{p), namely: 
r I M l = , , Ml', ...,Mn=ar.M'^bN=r 
N' 
is in 7i{p), if and only if 
Eq(eMueM[) 
A " • AEq{eMn,eM^) 
< 
Eq(eN,sN') 
holds in the fibre over sT—where e is the model ff(Sign(IB)) -^ B of the 
signature of B in B itself. Thus H{p) contains all Sign(B)-equations which 
hold in 
E 
P 
ff(Sign(B)) 
E 
3.6.5. Proposition. Let (S,?/) be an equational signature and 
^P an 
B 
Eq-fibration. There is a bijective correspondence 
(up-to-isomorphism) 
£(E,^)\ 
{M,M) 
/ f 
\ 
; 
^ 
{P 
in EqFib 
(E,?/) 
^ (Sign(B),?{(/?)) 
m EqSpec 
which makes the classifying 
fibration 
i 
the free Eq-fibratton generated 
Proof. Remember from Theorem 2.2.5 the bijective correspondence 
M 
a(S) 
> E 
in FPCat 
<^ 
Sign(B) 
in Sign 
It is then easy to see that A4 validates the equations in 7i with respect to 
p if and only if (p extends to a morphism of equational signatures (H,?/) —^ 
(Sign(B),?/(p)). This because M and <f) are related via e: for a term N one 
hasM{N)=e{(i>N). 
D 

Section 3.6: Fibred functorial semantics 
213 
The above result gives rise to a model 
c{sign{m),nip)) \ 
/ E 
C£(Sign(l)) 
J 
^ V ® 
of the theory of an Eq-fibration p in p itself. One can ask whether it is in 
general an equivalence, i.e. whether our equational logic is rich enough to re-
construct an Eq-fibration from its signature—as in the case of non-conditional 
equations for categories with finite products, see Theorem 3.3.8. The answer 
here is no, because an Eq-fibration may have many more 'predicates' (objects 
in the total category), than just equations Eq{u, v)—which are the only propo-
sitions that we have in equational logic. In the next chapter on (first order) 
predicate logic we describe how these extra predicates can be incorporated in 
logic. 
3.6.6. Remark. The notion of morphism between Eq-fibrations introduced 
in Definition 3.6.1 is in a sense the obvious one. But there is a reasonable alter-
native. One may wish to consider the functors between the base categories up-
to internal equality: call two morphisms of Eq-fibrations (/i, H), {K\ H')\p 
=t 
E 
D) 
q between Eq-fibrations 
^ 
and 
j - ^ equivalent if 
• i7 = ^ ' : E ^ D and on objects K - K'\ Obj B -^ Obj A; 
• Ku and K'u are internally equal in g, for each morphism u in B. 
Equivalence classes of such morphisms then yield an alternative notion of map 
between Eq-fibrations. Its usefulness may be illustrated via the following two 
very simple algebraic specifications. 
• El has one type ^ , one function symbol a: () —> Q and no equations; so 
the set Hi of equations in this specification is empty. 
• E2 also has one type Q, but two function symbols 6: () —> Q, c: () —> Q 
with a singleton set of equations H2 containing 0 | 0 h 6 —^ c. 
One would expect these specifications to be (logically) equivalent (in an infor-
mal sense). Certainly, the signature E2 has two function symbols, but they are 
required to be (internally) equal in the logic of (^2,7/2)- The classifying cat-
egories ff(Ei) and Cl{Y^2) of the signatures—without the equations—are not 
equivalent, simply because E2 has more function symbols. Hence the classify-
inff Eq-fibrations 
i 
and 
i 
are not equivalent with the notion of 
morphism in Definition 3.6.1. But we do have an equivalence of Eq-fibrations 
if we use the adapted notion of morphism that we just described, since it takes 
internal equality into account. 

214 
Chapter 3: Equational Logic 
We have seen that putting an Eq-fibration 
on a base category B allows 
US to consider certain parallel morphisms in B as (internally) equal. This gives 
the possibility to identify these morphisms in B in a quotient category. Doing 
so actually leads to a quotient fibration p -^ p/Eq in which internal and 
external equality are forced to coincide. We shall use the following notation 
for p -^ p/Eq. 
3.6.7. Definition. For an Eq-fibration 
^P we define two categories B/Eq 
and E/Eq as follows. 
B/Eq 
objects 
morphisms 
E/Eq 
objects 
morphisms 
/ G B . 
[u]: I —^ J are equivalence classes [u] of morphisms 
I/: / —> J in B, where w, i/': / =4 J in B are equivalent 
if they are internally equal, i.e. if T < Eq(w, if') holds 
in the fibre E/. 
X eE. 
[f]'-X -> Y are equivalence classes of maps /: X -> 
Y in E, with f,f:X 
=4 Y equivalent li pf,pf 
are 
equivalent in B. 
These categories B/Eq and E/Eq are quotients of B and E via obvious functors 
7/i:B-^B/Eq and ?7E:E-»E/Eq. 
Finally, the functor p/Eq: E/Eq -^ B/Eq is defined by X ^ 
pX and 
{[f]:X-^Y)^{\pf]:pX-^pY). 
E/Eq 
3.6.8. Proposition, (i) The functor 
J'P/Eq introduced above is an Eq-fib-
B/Eq 
ration in which internal and external equality coincide. 
(ii) The pair of functors rj = (771,//E) forms a morphism of Eq-fibrations 
rj'.p ^^ p/Eq, which is universal in the following sense: every map of Eq-fib-
rations p -^ q to an Eq-fibration q in which internal and external equality 

Section 3.6: Fibred functorial semantics 
215 
coincide factors 
via a unique map of Eq-fibrations 
p/Eq —^ q as: 
1 
Before we give the proof, we recall that Eq-fibrations—like all preorder 
fibrations—are 
faithful, as functors, see Exercise 1.3.11. And in these preorders 
we have vertical isomorphisms u*{X) 
= ^*(-^) for internally equal parallel 
maps ii, V, since by the substitution combinator from Lemma 3.4.5 we get: 
u*{X) ^ u*(X) AT ^u^'iX) 
AEq{u,v) 
< 
v*(X). 
The inequality t<*(X) > v* {X) is obtained by symmetry. 
Proof, (i) We first show that p/Eq 
is a 
fibration. 
For an object Y 
E 
Obj (E/Eq) — Obj (E) and a morphism [u]: I -> pY in B/Eq, we choose a 
representative u: I -^ pY in B, and a Cartesian lifting u{Y):u*{Y) 
^ Y of 
u in E. It gives a morphism [w(y)]: u*{Y) -> Y in E/Eq over [u]: I -^ pY in 
B/Eq. We claim that it is a p/Eq-Cartesian lifting: for a map [f]'. X -^ Y in 
E/Eq with [/] = [u] o [v] in B/Eq, so that T < Eq(p/, w o v), we obtain a 
mediating map X -^ u*{y) 
in E as composite: 
X < {Pfy{y) 
= (^ o vy{Y) 
^ v*u*{Y) 
^ 7i*(y) 
It yields the required mediating map in E/Eq. 
We notice that the fibre category of p/Eq over / G B/Eq is the same as the 
fibre category of p over / G B. Hence p/Eq has fibred finite products (T, A) 
and equality Eq as in p. By construction: 
[u], [v]: I ^ J in B/Eq are internally equal in p/Eq 
<=> T < 
Eq{u,v) 
^ 
[u], [v] are externally equal. 
(ii) Assume 
| ^ is an Eq-fibration in which internal and external equality 
coincide, and (/\:B -> A,/f: E —)• D) is a morphism of Eq-fibrations p —> ^. 

216 
Chapter 3: Equational Logic 
We define two functors A", H in 
by 
/ ^ KI 
H = 
X ^ HI 
[X^Y) 
^ 
(HX-^HY) 
(I^j) 
^ 
(iJl^ 
J) 
These functors K,H 
are well-defined, since 
u^u' 
in M => T < Eq{u, u') in E 
=> T < Eq{Ku, Ku') in D 
=> /i'w = /it/'. 
The last implication holds because internal and external equality coincide in 
q. Similarly: 
/ - / ' in E => T < Eq{pf,pf) in E 
^ 
T< Eq{Kpf, Kpf) 
= Eq{qHf, qHf) 
in D 
=> qHf 
= 
qHf 
^ 
Hf = Hf 
(see Exercise 1.3.11). 
Since p/Eq inherits its Eq-fibration structure from p, this pair {K, H) forms 
a morphism of Eq-fibrations. 
• 
Exercises 
3.6.1. 
Show that for an Eq-fibration p, the result K*{p) of change-of-base along 
a finite product preserving functor K is again an Eq-fibration and that the 
morphism A *(p) —^ p involved forms a morphism of Eq-fibrations. 
E 
3.6.2. 
Let 
iP be an Eq-fibration, and let Eq(E) M- E be the full subcategory 
of those X G E for which there is a vertical isomorphism X = Eq(w, v), for 
Eq(E) ^ 
certain maps u^vipX 
nt • in B. Prove that 
i 
is also an Eq-fibration, 
B 
and that the inclusion 
Eq(E) C 
^ E 
\ 
/ 

Section 3.6: Fibred functorial semantics 
217 
is a morphism of Eq-fibrations. 
[Remember Proposition 3.4.6 and Exercise 3.4.5.] 
3.6.3. 
Consider the category B/Eq in Definition 3.6.7 and show in detail that 
(i) 
its composition can be defined from composition in B via representa-
tives; 
(ii) it has finite products. 

218 
Chapter 3: Equational Logic 
This Page Intentionally Left Blank

Chapter 4 
First order predicate logic 
Equational logic, as studied in the previous chapter, is not very expressive. 
It allows us to formulate statements like x:N | x -\- 2 =^ 5 \- x =^ 3, but 
not much more. In the present chapter we will study (first order) predicate 
logic (over simple type theory), in which we can formulate more interesting 
statements like x,y:Q\ 
x <q y \- 3z:Q. x < Q Z A Z < Q y. This requires more 
general atomic propositions x <q y than just equations x =Q y. And further, 
it requires additional logical operations like A, 3. 
In this chapter we consider first order predicate logic where one can quan-
tify over types cr, in propositions of the form \/x:a.ip and 3x: a. (p. In the next 
chapter we study higher order predicate logic in which one can additionally 
quantify over propositions and predicates, like in Va: Prop, (p and 3a: Prop. (p. 
What we consider here is simple predicate logic (SPL),indexSSimple!- predi-
cate logic or predicate logic over simple type theory, in contrast to dependent 
predicate logic (over dependent type theory) or polymorphic predicate logic 
(over polymorphic type theory), see Sections 8.6 and 11.1. This means that the 
types in our simple predicate logic are types from simple type theory, which 
do not contain (term or type) variables: they are built up from constants, us-
ing type constructors like +, x, ^ as studied in Chapter 2. In standard texts 
on mathematical logic it is common to consider only single-typed (or single-
sorted, in more traditional terminology) predicate logic with only one type, 
but in computer science, many-typed logic is more natural. 
The categorical models that we shall use to describe predicate logics are 
certain kinds of preordered fibrations. The preorderedness makes these fibra-
tions so-called proof-irrelevance models in which provability, and not proof, 
219 

220 
Chapter 4- First order predicate logic 
is captured: (p \- ip in predicate logic means that there is a proof of tp which 
assumes (p. This makes the turnstile h a preorder relation. In contrast, formal 
(type theoretic) systems with explicitly proof-terms x:<f \- P:tp—providing 
an actual proof of 'ip, assuming a proof x:(f oi (p—lead to non-preordered 
models with proof-terms as arrows (p —^ ip. 
The operations in predicate logic are described categorically via adjunctions 
in these fibrations for predicate logics. Existential 3 and universal V quantifi-
cation form left and right adjoints to weakening functors, equality =(j forms 
left adjoints to contraction functors, subset types {x:cr|<^} form a right ad-
joint to a truth predicate functor, and quotient types a/R form a left adjoint 
to an equality relation functor. Equivalently, one can describe subset types by 
a right adjoint to this equality relation functor. The adjunctions for 3,V, =c7 
are between fibre categories, whereas the adjunctions for {x:cr|<^} and a/R 
are between the total and base category of a fibration. The introductory Sec-
tion 0.2 gives a brief presentation of these adjunctions for the familiar logic 
of predicates on sets. 
Lawvere may be seen as the first to use fibred (or indexed) categories in 
logic, for example in [193]. Some of the details involved are elaborated in [305]. 
Fibred categories for predicate logic are used subsequently for example in [62, 
209, 210, 336]. Since the 1970s much of categorical logic has been done in 
direct contact with topos theory. As a result, logic is often described in terms 
of subobject fibrations, see for example [211] and [85]. Here we use general 
fibred categories for predicate logic, and subobject fibrations occur as special 
instances. The advantages of this more general approach are that it provides 
• more flexibility: a base category B may carry different logics, and not just 
its subobject logic, see Examples 3.5.4 and 3.5.5 where we have two different 
logics on the category B = Rel of relations given by two different fibrations. 
• natural, unified presentations of examples as they come from realisability, 
frames (complete Heyting algebras), Kripke models, or cylindric algebras, 
see Section 4.2. 
• a framework in which all the logical operations can be studied separately. In 
subobject fibrations much structure comes for granted, like equality, unique 
existence 3! or subset types, see Section 4.9. 
• a presentation which scales up from logic to type theory in a direct manner. 
This chapter starts with appropriate signatures for predicate logic, contain-
ing not only typed function symbols F: cri,..., cr„ —y o-n-^i but also typed 
predicate symbols P: cri,..., cr„. With these one can form besides equations 
M —a M' also other atomic propositions P(Mi,..., M^), for example for 
reasoning with inequalities M <a M'. Next, in Section 4.2 we describe fibra-
tions for first order logic—and for the subsystems of what is called regular 

Section ^.i; Signatures, connectives and quantifiers 
221 
and coherent logic. The main novelty is that the quantifiers 3 and V are left 
and right adjoints to weakening functors. A series of examples of such fibra-
tions is included. Especially we shall elaborate classifying fibrations (or term 
models) built up from syntax. Predicate logic is rich enough to reconstruct 
the fibration we use from the classifying fibration of its own signature. The 
logic thus associated with a fibration will be called its internal language, or 
internal logic. This language facilitates dealing with fibrations of predicate 
logic, because it allows one to replace categorical calculation by logical reason-
ing. The internal language will be described and used in Section 4.3. Then, 
in Sections 4.4 and 4.5 we concentrate on subobject fibrations. Among the 
fibred categories used to model predicate logics, subobject fibrations are very 
special (for example because of their role in topos theory) and will therefore 
they be investigated separately. The subsequent three sections will be about 
subset types and quotient types. With these fundamental mathematical con-
structions we can form new types of the form {a:: cr | <y?}, where cr is a type and 
(f> a proposition, and of the form a/R, where i^ is a binary relation on a. Both 
subset types and quotient types can be described categorically by adjoints. 
We conclude this chapter with a characterisation of subobject fibrations. They 
are fibrations for predicate logic in which one has: very strong equality, full 
subset types, and unique choice 3!. 
4.1 Signatures^ connectives and 
quantifiers 
Up-to-now we have studied (typed) terms and equations between them in 
equational logic. These equations are the only kind of propositions that we 
have seen so far. Our next step is also to allow predicates as atomic proposi-
tions and form derived propositions using logical connectives, like implication 
D or existential quantification 3. In this section we describe the syntactic 
aspects of these extensions. It will involve signatures which not only have 
function symbols but also predicate symbols, and specifications, which are 
signatures together with a collection of axioms. After these preliminaries on 
how to form the atomic propositions, we describe the (standard) rules of first 
order predicate logic. In the end we reformulate the rules for typed equal-
ity =^, universal Vx:cr. (—) and existential 3x:a. (—) quantification as 'mate' 
rules. These essentially exhibit these logical operations as adjoints. 
In equational logic one only has equations 
M =a M' 
for terms M and M' of the same type cr, as (atomic) propositions. In this 

222 
Chapter 4' First order predicate logic 
chapter we will also allow atomic propositions 
P(Mi,...,Mn) 
where P: (TI, ..., (T„ is a predicate symbol and Mi'.ai,..., 
Mn'.o-n are ap-
propriately typed terms. To allow such predicate symbols, we have to extend 
our notion of signature. 
We say that a signature with predicates is a pair (5],n) where E is a 
many-typed signature and 11 is a function IDI"^ -> Sets, which yields for each 
sequence cri,..., cr^ of types a set n((7i,..., cr„) of predicate symbols of this 
type. We shall write 
P:^i,...,cr„ 
for 
P G n((7i,..., ^„). 
A morphism (f): (E, 11) —> (E', 11') of such signatures with predicates consists of 
three mappings, sending types to types, function symbols to function symbols, 
and predicate symbols to predicate symbols, in such a way that arities are 
preserved. Following Convention 1.6.2, we shall use the symbol (j) for all three 
mappings. This yields the following requirements. 
F:cri,...,(Tn 
>(Tn-\-l => (/)(P): 0((7i), . . . , (/)((T„) 
y(j){an^i) 
As a result, we get a category, which is written as SignPred. Using change-
of-base, it can be obtained simply as follows (see also Definition 1.6.1). 
4.1.1. Definition. The category SignPred of signatures with predicates 
arises in the following change-of-base situation. 
SignPred 
>• Fam(Sets) 
J 
I 
Sets 
^ Sets 
(In the first section of the next chapter on higher order logic we use many-
typed signatures containing a distinguished type Prop of propositions. In such 
signatures there is no need for predicate symbols P: CTI, ..., cr„, since they can 
be described as function symbols P: cri,..., cr„ —y Prop.) 
One can view a signature with predicates as a first order specification— 
without axioms yet; these will be added in Definition 4.1.3 below. 
4.1.2. Example. In a signature containing a type N of natural numbers to-
gether with a type NList of finite lists of these, one may have function and 
predicate symbols 
insert: N —> NList, 
IsEmpty: NList, 
Occurs?: N, NList 

Section ^ . i ; Signatures, connectives and quantifiers 
223 
where the latter predicate tells of a natural number n and a list i whether or 
not n occurs in i. One expects as an axiom 
n: N I 0 h Occurs? (n, insert (n)). 
Let (D,n) be a signature with predicates. The associated atomic propo-
sitions have the form 
M=aM' 
and 
P ( M i , . . . , M „ ) 
where M, M' are of the same type cr, and P : <7i,..., cr^ is a predicate symbol 
with appropriately typed terms M^: ai. A bit formally, using a new syntactic 
category (or universe) Prop, we can write these as formation rules: 
atomic equation proposition 
r \- M:a 
r \- 
M':a 
T \- {M ^a M'):Prop 
atomic predicate proposition 
r h M i l d i 
••• 
r h 
Mn:(Tn 
(for P:cri,...,cr„) 
r 
h P ( M i , . . . , M „ ) : P r o p 
Substitution over these atomic propositions takes the form 
(M =a M')[N/x] 
= {M[N/x]) 
=a 
{M'[N/x]) 
P{Mi,...,Mn)[N/x] 
= 
P(Mi[N/xl...,Mn[N/x]). 
The following connectives or logical operations may be used in first 
order logic to construct new propositions. 
± 
falsum, 
absurdity, the universally false proposition; 
T 
truth, the universally true proposition; 
-^(p 
negation: not (p; 
(f Alp 
conjunction: ip and xp; 
(py ip 
disjunction: (p or ip; 
(p D 'ip implication: if (p then ip; 
\fx:a.(p 
universal quantification over type a: for all x in cr, p; 
3x:o-.p 
existential quantification over type a: for some x in a, (p. 
In the last two cases the term variable x becomes bound in the quantified 
propositions \/x\cr.p 
and 3x\a.^. 
Formally, one can write all of these as for-
mation rules. For example, 
F h ^: Prop 
F h ^: Prop 
F, a:: cr h (p: Prop 
F h (^ A -0: Prop 
F h 3a:: a. p: Prop 

224 
Chapter 4- First order predicate logic 
but that is a bit cumbersome, really. Then, given propositions 
ri-<^i:Prop, 
• • 
rhv?n:Prop, 
T h V': Prop 
we can form a sequent, 
which is read as: assuming term variable declarations x:a in F, then the 
proposition ip follows as conclusion from propositions v^i, • •., v^n- The latter 
sequence ^ i , . . . , <^„ will be called the proposition context; we often abbreviate 
it as 6, S, like in the previous section. Recall that F is called the type context. 
For completeness, we list the natural deduction rules of predicate logic in 
Figure 4.1 (apart from the context rules, as already described in section 3.1). 
These rules have all of the assumptions explicit at every stage, in type and 
proposition contexts F and 0. 
Recall that a sequent F | 0 \- ip is derivable if there is a derivation tree 
regulated by these rules, with F | 0 h (p 3,s conclusion. The sequents at the 
top of this tree may be axioms. We sometimes write 
• F | 0 hv^ 
to express that the sequent F | 0 h ^ is derivable. For example, one has 
for propositions F h (p,ip,x- Prop in type context F, as shown by the following 
derivation. 
T\(p 
h (f 
T \i; h 7p 
T\<p,iP \-ip 
F | ^ , ^ hiP 
F | ( v p A V ^ ) D X ^ - ( v ^ A ^ ) D X 
T \ <f,ip h (f Aip 
F I V?, (yp A 10) D X, V^ h (y? A V^) D X 
F | y?, (9? A V^) D x^ V^ I" ^ A V^ 
T \(f,{(pAip) 
D X,i^ 
^X 
F|v^,(^A^) D x 
^i^DX 
The reader may notice that negation (-1) does not occur among these rules. 
The reason is that negation is defined as 
-^(p = (f D J-. 
Classical logic is then obtained by adding the rule 
reductio ad absurdum 
T\e 
hip 

Section 4-^- Signatures, connectives and quantifiers 
225 
r |e hT 
T\e \->p 
r | e i - ^ 
r | 0 \-<pAip 
r | e 
hfAxfj 
r | e hV 
r | e 1-V 
r |e i-v?v^ 
r\e,^\-rp 
T\e 
\-^Dip 
T,x:a\e 
h V 
ri 
r 
r | e , ± h V 
r | e i-ypAV' 
r |e hv:. 
r |e h^ 
r |e 1-<^vv 
|e,^hx 
r|e,vi-
r, |0,v?vv Hx 
\e i-fDxp 
r | e h 
r | 0 hV 
T \- M:a 
T\e 
\-^x:a. 
X 
f 
• i> 
r | 0 hVx:cr.v^ 
r |0 h v^[M/x] 
(x not free in 0 ) 
TV-M:a 
T | 0 h V^[M/x] 
T | 0 h 3x: o-. x/^ 
T, a^: cr | S, V^ h X 
r | 0 l-3x:cr.V^ 
r I 0 , 2 
h x 
(x not free in S, x) 
r h M = M': 0- 
r I 0 h M =:a M ' 
V\QV-M'^aM" 
T\Q 
^ M =a M' 
T \ e h M =a M" 
r|0i-M=^M' 
r|0[-M=aM' 
r | 0 h V^[M/X] 
(this rule will be called replacement) 
Fig. 4.1. Rules for (many-typed) first order predicate logic 

226 
Chapter 4- First order predicate logic 
This rule says that if it is absurd to assume that (f is false, then (f must be 
true. It is an indirect, non-constructive principle of reasoning. One can show 
that it is equivalent to the excluded middle ^ V->v? axiom, also called tertium 
non datur, see Exercise 4.1.3. This rule will not be assumed, unless stated 
explicitly. 
As another abbreviation, we shall use 
def 
for logical equivalence. 
The following rule in this list, 
Tie 
\- M =^ M' 
deserves some special attention. It tells us first of all that convertible terms 
(M = M': cr) in the underlying type theory give rise to derivable equality 
propositions (M =a M') in the logic. Thus propositional equality includes 
conversion, or in different terminology, internal equality includes external 
equality. The converse may also be required as a rule, but that is not done 
here. Because conversion in type theory is reflexive, this rule tells us in par-
ticular that logical equality =<j is reflexive. (Symmetry and transitivity of ^a 
are given by explicit rules.) And in case one considers an elementary term cal-
culus without basic conversions [e.g. because there are no type constructors 
like -^, X or -|-), then one may still consider M = M:cr as part of a trivial 
conversion relation, guaranteeing the presence of a reflexivity rule. 
Since term variables x.a may occur in propositions <^, the question arises 
how propositions ^[M/x] and ip[M'/x] for convertible terms M = M'\ cr are 
related. It turns out that they are equivalent—i.e. that <y?[M/ar]li:^[M'/ar] 
is derivable: the conversion M — M':a leads to a proposition M —a M' 
by the above rule, which can be used to derive (f[M/x] from (p[M'/x] by 
the replacement rule, and thus to derive (p[M/x] D (p[M'/x]. The reverse 
implication is obtained similarly. 
Substitution over these propositions is done in the familiar way, i.e., 
J[Llz] 
= T 
{v>M')[L/z] 
= 
(^[L/z])A(rP[L/z]) 
l[L/z] 
= 1 
(^Vi;)[L/z] 
= 
{^[L/z])V{i;[L/z]) 
(^ D rl;)[L/z] = i^[L/z]) D ii>[L/z]) 
{yx:a.tp)[L/z] 
= VXKT. (V'[L/z]) 
{3x:a.ip)[L/z] 
= 
3x:a.{ij[L/z]) 

Section 4-1' Signatures, connectives and quantifiers 
227 
where in the latter two cases it is assumed that the variable x is different 
from z and does not occur free in L. By renaming of bound variables, this can 
always be assured. 
In what we call (full) first order logic all of the above connectives and 
quantifiers can be used. We mention two interesting subsystems explicitly: 
regular logic 
only has 
=, A, T, 3 
coherent logic 
only has 
= : , A , T , V , ± , 3 . 
The expressions 'regular' and 'coherent' will also be used for propositions 
in these logics (which may contain only the above symbols as connectives). 
We note that classical coherent logic—with a negation operation (f i-^ ->(f> 
behaving as in the reductio ad ahsurdum rule—is the same as classical (full) 
first order logic, since in classical coherent logic D and V are definable. So a 
restriction to coherent logic is only meaningful in a constructive setting. 
4.1.3. Definition, (i) A first order specification is a triple 
( E , n , ^ ) 
where ( S , n ) is a signature with predicates and ^ is a collection of axioms; 
the latter are sequents in the language of (S, 11). 
(ii) A regular (or coherent) specification has regular (or coherent) propo-
sitions as axioms. 
4.1.4. Definition, (i) A first order specification ( E , n , ^ ) is a first order 
theory if the collection A of axioms is closed under derivability. Every such 
specification evidently determines a theory lli{T>, 11, A) which can be obtained 
by closing A under derivability. 
(ii) A morphisHi of first order specifications ( S , n , ^ ) -^ 
{Y,',11',A') 
is a morphism </>: (E, 11) -^ (E', 11') of signatures with predicates such that for 
each sequent 
r | e \-x 
in A, one has that the sequent obtained by (/)-translation 
0(r) I <^(e) h 0(x) 
is in 7 7 i ( E ' , n ' , ^ ' ) . This yields a category FoSpec. 
Similar definitions can be given for regular and coherent signatures. 
4.1.5. Remark. Earlier we have been careful in distinguishing equality in 
internal (propositional, in the logic of a fibration) and external (in the base 
category) form. Axioms, as described in the previous definition, can only cap-
ture internal equations. If we wish to have external equations in our logic, 
then we have to add these explicitly as an additional set of (algebraic) equa-
tions, like in Definition 3.2.5 (i). In general, we shall not do so, except when 
reconstructing a fibration from its internal logic, see Section 4.3 (notably in 

228 
Chapter 4- First order predicate logic 
Definition 4.3.5). A morphism preserving the structure of such extended spec-
ifications is a morphism as in (ii) above, which is additionally a morphism of 
algebraic specifications, as in Definition 3.2.6. 
In the remainder of this section, we shall reformulate the rules for =,3 
and V in Figure 4.1 in order to make them more amenable to a categorical 
description in the next section. First we take a closer look at the last four rules 
on equality in Figure 4.1. We show that replacement rule from equational logic, 
denoted as (EL-R) for convenience, and the replacement rule from predicate 
logic, written as (PL-R), are of equal strength. This shows that there is no 
omission in the list of rules in Figure 4.1. 
4.1.6. Lemma. The replacement rule from equational logic (see Section 3.2), 
F i e h M = ^ M' 
V.x'.ah 
N:T 
— 
; 
(EL-R) 
F I e h N[Mlx] =r 
N[M'/x] 
is a consequence of the replacement rule from predicate logic 
T\Q 
b M =a M' 
F | e h ip[M/x] 
: 
(PL-R) 
F I e h ip[M'lx] 
as given in Figure 4'F In the reverse direction, the rule (PL-R) restricted to 
equations follows from the rule EL-R. Here we assume reflexivity, 
symmetry 
and transitivity of equality in the background. 
Proof. Assume the rule (PL-R) and let (p be the equation N[M/x] —j N. 
Notice that the variable x occurs free in (p, only in N on the right hand side. 
By reflexivity one has 
F I e h p[Mlx] 
and thus by (EL-R) 
F I 0 h p>[M'lx] 
i.e. 
F | e \- N[M/x]=r 
N[M'/x]. 
In the reverse direction, assume (EL-R). Let (p be an equation A^ =r N'. 
Then, the assumption 
F I e f- N[M/x] =r N'[M/x] 
together with the two conclusions of (EL-R), applied to N and to TV', 
F I 0 h N[M/x] ^r N[M'/x] 
and 
F | 0 h N'[M/x] =r 
N'[M'/x] 
yield by symmetry and transitivity the required result: 
F I 0 h N[M'/x] =r N'[M'/x]. 
D 

Section 4-1- Signatures, connectives and quantifiers 
229 
We continue with an adaptation of Lemma 3.2.3 to first order logic. It en-
ables us to use Lawvere's description of equality as left adjoints to contraction 
functors also in predicate logic; it will be used in the next section. 
4.1.7. Lemma. The last four rules in Figure 4-1 about equality are of the 
same strength as the (double) 
rule 
Lawvere equality 
T,x:a\e 
^ 
^[x/y] 
— (Eq-mate) 
V,x\(T,y\a\Q,x 
-a y ^ '^ 
involving a proposition 
^p in type context 
T,x:a,y:a. 
The extended "Frobenius" version of this result (involving a proposition 
context of the form Q[x/y] instead of 6 above the lines), as in Lemma 3.2.4 
is left to the reader in Exercise 4.1.6. 
Proof. Let us split this rule of Lawvere's in (Eq-TD), for top-down, and (Eq-
BU), for bottom-up. Assuming this rule, we obtain reflexivity, symmetry and 
transitivity as in the proof of Lemma 3.2.3. The replacement rule is obtained 
as follows. For a proposition ip with free variables declared in T,x:a, 
put 
(p' = (p[y/x]. Then 
T,x:a\e,ip 
\- 
p'[x/y] 
(Eq-iDj 
T,x\a,y:a\e,(p,x 
=a y ^ p' 
, 
^ ^ 
(subst) 
F I e h p[M/x] 
F I e , <p[M/x],M 
=a M' h 
p[M'lx] 
(cut) 
F I 0 I- M =^ M ' 
F I 0 , M =^ M ' h 
p[M'lx] 
(cut) 
F I 0 h 
ip[M'/x] 
In the reverse direction, assuming these last four equality rules from Fig-
ure 4.1, one obtains (Eq-BU) simply by substituting x for y and using re-
flexivity 
(as in the proof of Lemma 3.2.3). We shall derive (Eq-TD) from 
replacement. 
T,x:a\Q 
h 
p[x/y\ 
F, ar: (7, y: (7 I 0 , X =cT y \- x :=a y 
r, x\(T,y\a\Q,x=a 
y ^ 
^[^ly] 
F, x\a,y:a\Q,x=^ 
y ^ ^[y/y] 
U 
The next result paves the way for a categorical characterisation of existential 
and universal quantification in terms of left and right adjoints to weakening 
functors adding a dummy assumption to the type context, see Example 3.1.1. 

230 
Chapter 4- First order predicate logic 
4.1.8. Lemma. The rules for existential 3 and universal V quantification in 
Figure 4-^ (^^^ equivalently be described as the following two (double) rules. 
V\Q,3x:a.i)h 
if 
T | 6, ^ h V^: cr. V^ 
: (3-mate) 
: (V-mate) 
These rules express that 3 is left adjoint and V is right adjoint to weakening 
(r h X- Prop) y^ (r, x\a\- 
X' Prop). 
Proof. We shall do the case of 3, since V is much simpler. The rules in the 
proposition follow from the rules for 3 in Figure 4.1, since 
V^x'.a \- x\(T 
V.x'.cr \ip \- V^[x/x] 
F | 6, 3x: cip h (f 
T,x:a \ tp h 3x: a.tp 
T,x:a \ 0, 3x: a.ip b- (p 
T,x:a \Q,xp \- (f 
and 
F I 3x: a.ip \- 3x: a.tp 
TjX:a\Q,ij;\-(p 
T\e,3x:a.^p[-<p 
Conversely, assuming the above (3-mate) rule, we can derive the two rules 
for 3 in Figure 4.1. 
F I 0, 3x: (T.tp \- 3x: a. ip 
(3-mate) 
F h M: (7 
T,x:a\e,ip 
h3x:a.7p 
(subst) 
F I 0 h iP[M/x] 
F I 0, JP[M/X] 
\-3x:a.xP 
F | 0 
\-3x:a.jp 
and 
T,x:a\ E,i} h x 
F I 0 h 3x: a.ip 
T | H, 3a:: cr. -0 h x 
(3-mate) 
F | 0 , H , ^ h x 
• 
We close this section by examining a subtle point in many-typed predicate 
logic which is related to "empty types". We recall from Section 3.1 that the 
rule 
strengthening 
T,x:a\(fu..,,ipn 
H V^ 
(it X not tree m (fi,... 
,(fn,V) 

Section 4-^' Signatures, connectives and quantifiers 
231 
will not be assumed. It may fail in models where the interpretation of a is 
empty, see Exercise 3.1.3. This rule can be used without harm in single-typed 
logic because there, one has the common requirement that the interpretation 
of the single type is non-empty. This point often leads to confusion. For ex-
ample in [102, 11.8], one finds the following reasoning against the rule Modus 
Ponens (or, D-elimination): for a variable x\a both 
[^x —a x) D {3x\ a. X —(J x) 
and 
x —a x 
hold if the interpretation of cr is empty; but then 
3x: (T.x —a X 
does not hold. If we recast this line of thought in our notation with explicit 
type contexts of term variables, it becomes clear that there is an illegal use of 
the above strengthening rule involved, and that there is nothing wrong with 
implication. 
x:cF \- x:(T 
x\ a \ X —(J X \- X =a X 
x\(T \ X —(J X h 3x\ (T.x —a X 
x: (T \- x: CF 
- (refl) 
x: (J I 0 h (x = ^ a:) D {3x: a.x —^ x) 
x: a \ il^ \- x —, 
x: a \ ^ h 3x: a, x —^ x 
^ ,^ , -, 
(strengthening!) 
0 I 0 \- 3x:a.x 
=a X 
This point is also stressed in [186, top of p. 131]. 

232 
Chapter 4- First order predicate logic 
Exercises 
4.1.1. 
Consider the rules for the connectives A of conjunction and V of disjunction. 
Show that A and V distribute over each other, i.e, that the following two 
equivalences are derivable. 
r I 0 h v? A (0 V x)DC(v? A 0) V ((^ A x) 
r I 0 h (^ V (0 A x)3C(v:> V ^ ) A (v? V x). 
See also Exercise 2.6.2. 
4.1.2. 
In the same vain, assume x does not occur free in cp; derive 
(i) 
r I 0 h 3x: a. (ip A ip)jc{^ A {3x: a. ip)); 
(ii) r I 0 h V:r: 0-. (V^ D ^)J0{(3x: 
a. ^) D c^). 
[Related to (ii) is Exercise 1.9.7.] 
4.1.3. 
Show that the reductio ad absurdum rule is equivalent to the excluded 
middle (or tertium non datur) rule: 
r h (/?: Prop 
r 10 h V? V -IV? 
4.1.4. 
Assume a proposition x:a \- ip: Prop. Is it possible to derive 
0 |0 h (ixia.ip) 
D {3x:a.ip) 
? 
4.1.5. 
Prove Lemma 4.1.8 for V. 
4.1.6. 
Give a strengthened, "Frobenius" version of the rule in Lemma 4.1.7 in 
which the variable y is also allowed to occur in the proposition context 0 
(as in Lemma 3.2.4). 
4.1.7. 
A ring is called local if it has a unique maximal ideal. Show that a ring R 
is local if and only if it satisfies the (coherent!) proposition 
x: H I 0 h {{3y: /?. :r • y = 1) V (3y: R. {1 - x) - y = 1)). 
[This is the standard example of a notion definable in coherent logic] 
4.2 Fibrations for first order predicate logic 
In the previous section the syntax of first order predicate logic was given— 
and of the subsystems of regular logic (with = , A , T , 3 ) and coherent logic 
(with ==, A, T , 3 , V, ± ) . In this section we shall define appropriate 
fibrations 
to captures such logics categorically. Further, we shall describe several stan-
dard examples of such fibred categories. These include the topological model 
by Tarski, the realisability model by Kleene, and so-called Kripke models. 
UFam(PN) 
Among these, the 'realisability'fibration 
i 
incorporating Kleene's re-
alisability interpretation of constructive logic will play an important role in 

Section 4-2: Fibrations for first order predicate logic 
233 
the sequel (in the construction of the effective topos). Also subobject fibra-
tions form important examples, but since they are rather special, they will be 
investigated separately in the later Sections 4.4, 4.5 and 4.9. 
The categorical structure used for the connectives and quantifiers can be 
read off almost immediately from their rules—by keeping in mind the syn-
tactic 
fibrations 
^ 
from Section 3.1 (built on top of a signature with 
predicates (S,n) with set of axioms A): the connectives T, A, ±, V, D corre-
spond to fibred finite products (T,A), coproducts (J-,V) and exponents D. 
Equality = is described by fibred equality as in Section 3.4 (that is, by left 
adjoints to contraction functors S*, using Lemma 4.1.7), and the quantifiers 
3,V are described by simple coproducts and products (i.e. by left and right 
adjoints to weakening functors TT* as in Lemma 4.1.8) from Section 1.9. We 
thus come to the following definitions. 
4.2.1. Definition, (i) A regular fibration is an Eq-fibration with simple 
E 
coproducts satisfying Frobenius. That is, 
iP is a regular fibration if 
JB 
• p is a fibred preorder with finite products in its base category B; 
• p has fibred finite products (for T, A); 
• p has fibred equality (Eq/j H rf(/, J)*) satisfying Frobenius (for =); 
• p has simple coproducts (]J(/ j \ H TT} J) satisfying Frobenius (for 3). 
(ii) A coherent fibration is a regular fibration which has fibred finite 
coproducts (-L, V) which are fibrewise distributive, i.e. X A {Y \/ Z) = {X A 
Y) V {X A Z) in each fibre. Thus each fibre is a (preorder) distributive lattice. 
(iii) A first order fibration is a coherent fibration which is a fibred CCC 
and has simple products W^^j jy 
We recall from Definition 3.5.1 that Eq-fibrations are preordered. Hence 
also regular, coherent and first order fibrations have preordered fibre cate-
gories. For a non-preordered version of a regular fibration, see [256]. There 
are obvious "split" versions of the above notions of regular / coherent / first 
order fibration, in which all of the relevant structure is split. 
The rest of this section will be devoted to examples of the above kind of 
fibred categories. Details of interpreting predicate logics in such fibrations may 
be found in the next section, but it may be useful to have in mind when reading 
the examples below that objects / of the base category are to be thought of 
as type contexts (or as types), and objects X of the total category above 
/ as predicates in context /. Validity of this predicate X corresponds to the 
presence of an inequality T(/) < X (over /), where T(/) is the terminal object 
in the fibre over /. This view will be formalised in the 'internal language' of 

234 
Chapter 4- First order predicate logic 
such a fibration towards the end of the next section. 
4.2.2. S y n t a c t i c e x a m p l e s . Let us fix a signature with predicates ( E , n ) , 
as introduced in (or before) Definition 4.1.1. 
(i) Consider (X),n) with regular logic and assume a collection A of (reg-
£(E,n,>t) 
ular) axioms. One can construct a (preorder) classifying 
fibration 
4-
as in Section 3.1. The objects of the total category £ ( E , n , ^ ) are type-
plus-proposition contexts (F | ^ i , . . . , (/?„). In the sequel we usually assume 
finite conjunctions T,A in our logic and so we may conveniently assume 
this sequence of ^'s in (F | <^i,...,^n) to be of length one. A morphism 
(F h (p\ Prop) -^ (A h ^: Prop) is then a context morphism M: F -> A for 
which one can derive F | </? h xp(M), using the sequents in A as axioms. 
It is easy to see that the rules for T, A induce fibred finite products for 
4- 
. As before, in Example 3.4.4 (iv), this fibration has equality satisfy-
ing Frobenius by the rules for = (as formulated suitably in Lemma 4.1.7). Sim-
ilarly, for simple coproducts we have to show that for contexts F, F' G ff(S), 
the reindexing functor TT* induced by the projection TT: ( F , F ' ) -^ F has a left 
adjoint. For convenience we assume T' tohe x:a of length one. This weakening 
functor TT* then sends 
F h ^: Prop 
to 
F, x: cr h (p: Prop 
by adding an extra hypothesis. Its left adjoint sends 
F, x: cr h V': Prop 
to 
F h 3x: cr. ^: Prop. 
The adjunction 3x:a. (—) H TT* requires a bijective correspondence 
F I 3x: a.tp \- (p 
(3-mate) 
T^x:a 
\ tp h (fi 
which follows from the reformulation of the 3-rules in Lemma 4.1.8. By Ex-
ercise 4.1.2 (i) these coproducts satisfy Frobenius. In the general case where 
F' = (xi: CTi,..., Xn'.o-n) need not be of length one, a left adjoint to TT* associ-
ated with the projection TT: ( F , F ' ) -> F sends a proposition F, F' h ip: Prop to 
F h 3xi: tTi. • • -Bx^: cr„. ip: Prop. We conclude that the rules of regular logic 
c{E,n,A) 
make 
i 
into a regular 
fibration. 
C£(E) 
^ 
(ii) If one further adds finite disjunctions (-L,V) to the logic, then the fi-
c{E,n,A) 
bration 
i 
has fibred finite coproducts. These are distributive over con-
a(E) 
^ 
junctions by Exercise 4.1.1. Thus coherent logic leads to coherent classifying 
fibrations. 

Section 4-2' Fibrations for first order predicate logic 
235 
(iii) It will probably not come as a surprise anymore that full first order 
logic (obtained by adding D and V) makes the syntactic fibration a first or-
der fibration. Implication yields fibred exponents and universal quantification 
induces right adjoints to the weakening functors TT* mentioned in (i), which 
send 
T,x:a 
\- tp'.Prop 
to 
T 
\-\/x:a.ip:Prop. 
The adjunction TT* H Va^icr. (—) involves the bijective correspondence 
r I 9? h Vo?: a. ip 
(V-mate) 
T^x'.cr \ (f \- ip 
which follows from the reformulation of the V-rules in Lemma 4.1.8. 
4.2.3. Set theoretic example. Let ( S , n ) be a signature with predicates. 
A (set theoretic) m o d e l of (D,n)—or, a (D, n)-algebra—consists of 
(a) a collection {Aa)aem 
^^ 'carrier' sets, indexed by the underlying set 
|E| of types of the signature; 
(b) for each function symbol F : cri,..., cr^ —> ^n-f i in ^ a function 
IF} 
, 
A(j^ X • • • X AQ^ 
>• A(j^^^ 
(c) for each predicate symbol P : cri,..., cr„ in 11 a subset 
J P J C — ^ A , , X •••X A^„. 
Note that (a)-|-(b) constitute a E-algebra as described in Section 1.6. 
For such an algebra {[Aa), I —I, [[ — II) we construct a first order 
fibration. 
Let A be the base category with 
objects 
sequences (CTI, . . . , or„) of types <TJ E | E | . 
morphisms 
(cri,. . ., cr„) -^ ( r i , . . . , r^) are m-tuples ( / i , . . . , /m) of 
functions fi: A^^ x • • • x A^^ -> Ar,. 
We leave it to the reader to verify that A is a category with finite products. 
An indexed category A^^ —> Cat is obtained by 
(cTi,..., cr„) h-> the power poset (^(^4^^ x • • • x Aa^)^ C) 
/ = (/i) • • • 5 /m) •-> the functor /* sending 
Y^{x\{h{x),...Jm{x))eY}. 
Applying the Grothendieck construction to this indexed category yields a 
split fibration over A. The total category of this fibration has as objects 
pairs consisting of a sequence (cr^,..., cr„) of types together with a predicate 
X C Aaj^ X • • • X Aa^ on the associated product of carriers. And morphisms 

236 
Chapter 4' First order predicate logic 
((o-i,...,cr„),X) -^ ( ( r i , . . . , r ^ ) , y ) consist of an m-tuple of ( / i , . . . , / ^ ) of 
functions ff.Aa^ 
x • • • x Aa^ —)• ^r, satisfying {fi{x),..., 
fm{x)) 
G Y for all 
We claim that this is a first order fibration. The fibre categories P ( ^ a i x 
• • • X Aa^) are Boolean algebras. Hence we have T, A, ± , V and D (and also 
reductio ad ahsurdum as in classical logic). Quantification along the projection 
7r:((Ti,...,a-n,cr„+i) -> (cri,..., (Jn) is given by 
X I—)- {£ E A^i X • • • X yl^^ I for some y G Acr^+j, (x, y) G X } 
X M^ 
{f G v4^i X • • • X yia J 
for all y G A^^+i, (?, y) G X } . 
And equality along (J: (cri,..., o-^, o-„+i) -> ((TI, . . . , (7n, cr„+i, cr„+i) is 
X i-> {(£, 2/, z) I (f, 2/) G X and y = z}. 
4.2.4. Kripke m o d e l example. For a signature with predicates 
( S , n ) 
there is a category Alg(E, 11) of (E, n)-algebras (as in the previous example). 
Morphisms H:{[A,),l-% 
[[-1) -^ ((^a), I " ! , I " ! ) in A l g ( E , n ) are col-
lections of functions H — [Ha'-Aa -^ 5^)<7e|s| between the carrier sets which 
commute with the interpretations of function symbols F\ cri,... ,(Tn —> cTn+i 
and predicate symbols P: 
A<7j X • • • X A.Q 
Ha^ X '" 
X Ha 
H<Jn + l 
Ba, 
X . . . X Ba^ 
IP¥ 
Aai 
X . . . X Acr^ 
Ha,X"'X 
Ha„ 
iPf 
Ba, X . . . X Ba^ 
A Kripke model for (E, 11) consists of an index poset I = (I, <) together 
with a functor 
I 
—-Aig(s,n) 
It involves for each element i G I a (E, ll)-algebra 
/c(i) = ((x;(f).),ii-i(i),i-i(i)) 

Section 
4•2' Fibrations 
for first order predicate 
logic 
237 
and for each pair i, j G I with i < j ^ morphism JC{ij) of (E, n)-algebras. The 
latter consists of a collection oiK[ij) 
= {lC{ij)a''IC{i)a -^ I^U)^) of functions 
commuting with the interpretations of function and predicate symbols, like 
the iJa's above. One thinks of the elements of! as stages in (branching) time 
and of the algebra IC{i) as the state of knowledge at stage i G I. 
In order to construct a first order fibration from such a /C we need some 
notation: for a sequence (cri,..., cr„) of types (from E), there is a functor 
/C(cri,.. .,cr„):E -^ Sets given by 
f 
i ^ 
IC{i)ar X ••• X IC{i)ar. 
\ i < j 
^ 
K.{ij)a, 
X • • • X IC{ij)a^-
Application of the morphism part of this functor will be abbreviated as follows. 
For i, j G I with i < j and :? G /C(cri,..., cr„)(i) we write 
(Sy 
for 
(A:(ij)aJ;ri),...,A:(ij%Jarn)) G A:((TI, ..., cr„)(i). 
A collection of subsets [Xi C /C(o-i,..., an){i))-^j is called monotone if 
i < j and x G Xi 
implies 
[xY G Xj. 
Notice that for a predicate symbol P: cri,..., cr„ in 11, the interpretations of 
P in the /C(i)'s, 
IPW) 
^ ^ ( 0 ^ 1 X ••• X IC{i)ar, = /C(cri,...,cr„)(i) 
form such a monotone collection, because the /C(ij)'s, for i < j , are morphisms 
of (E,n)-algebras. 
In [182] Kripke showed how to interpret intuitionistic (or constructive) pred-
icate logic in such an I-indexed collection /C:I —)• Alg(E,ll) of models of 
classical first order logic. A proposition T h (p: Prop—say with type context 
r = xi: CTi,..., ;r„: cr^—is interpreted as a monotone collection of subsets 
[[r h VP: PropKO C /C(o-i,..., an){i) 
for i G L 
The main clauses of Kripke's interpretation are: 
[ [ r h ^ V V ^ : P r o p ] ] ( i ) 
= 
[ [ r h ( ^ : P r o p ] ] ( 2 ) U [ [ r h V^:PropI](i) 
IT \-^At'Propl{i) 
= [[r hv:?:Prop]](i)n[[r h V^:Prop]l(i) 
IT \- <pDjp: Prop]l(i) =^ {x \ for all j > i, (Sy G [[T h ^: Prop]](j) 
implies {xY G [[r h V^: Prop]](j)} 
[[r h 3^:cr.-0: Prop]](i) = {x | for some t/G/C(0a5 
(£,y)G[[r,y:tr h^:Prop]l(i)} 
IT h yy.a.i;: Prop]](z) = {x \ for all j > i and y G IC{j)a, 
{{xy,y)elT,y:ahiP:Propl{j)}. 

238 
Chapter 4- First order predicate logic 
Notice that knowledge whether a proposition involving D or V holds at stage 
i, involves knowledge about future stages j > i. Indeed, these connectives have 
far-reaching consequences. 
We shall construct a first order fibration (from /C) in which these clauses 
hold. As base category IB we take 
objects 
sequences of types (cri,..., cr„). 
morphisms 
(cri,..., an) -> (TI ,..., r^) are natural transformations a 
between the corresponding functors, as in: 
Sets 
/C(ri,...,r^) 
It is easy to verify that B is a category with finite products. For each sequence 
((Ji,..., cr„) G B there is a poset fibre category with 
objects 
monotone collections (Xf C IC{ai,..., cr„)(2))^. j . 
morphisms 
{Xi)i^i —)• {Yi)i^i exist if and only if Xf C Yj for each i G I. 
Every morphism a: (cri,..., cr„) -> (ri,..., r^) in B determines a reindexing 
functor Of* between the fibres, by pointwise inverse image: 
{Xi C/C(ri,...,r^)(i)).^jh-> ({y G/C(cri,...,(7n)(0 | ai{y) e 
Xi}).^^. 
By naturality of a, this new collection is monotone again. Our claim is that 
the result is a first order fibration. 
Each fibre category—say over (cri,..., cr„)—is a Hey ting algebra with struc-
ture 
±{i) = 0 
T(i) = IC{<Ti,...,(T„)(i) 
(XVY){i) 
= 
X{i)UY(i) 
(X AY)(i) 
= 
X(i)nY{i) 
(XDY)(i) 
= {x £lC(au...,<rn)ii)\ioT 
all 
j>i, 
(xy € Xj implies {xY 
£Yj}. 
We check that X D Y is an exponent, i.e. that there is a bijective corre-
spondence 
(ZAX){i) 
C y(i) 
for all i € I 
Z(i) C {X DY)(i) 
for all «G II 
For the implication downwards, assume x £ Z(i) and for some j > i, (xy G 
X{j). Then by monotony of Z, (Sy G Z{j) and thus {Sy € Z{j)r\X{j) 
C 

Section 4-^' Fihrations for first order predicate logic 
239 
Y{j). Hence x e {X D Y){i). Upwards, assume x G Z{i)nX{i). 
Then x G Z{i) 
and thus x E {X D Y){i). Since i > i and {xY — x £ X[i) one obtains 
X G y{i) as required. 
Quantification along a projection TT: (cri,..., cr„, (7„_|-i) —> ((TI, ..., (T„) takes 
the following form. 
lj(y)(i) - 
{fG/c(t7i,...,(7n)(oi 
for some t/ G 1C{i)a^^^, (^, y) G Y{i)] 
Y[[Y)[i) 
= 
{xe^au.•.,<Tn){i)\ 
for all j > i and y G /C0%,^,, ((^^, 2/) G y(i)}. 
Equality is left as an exercise below. 
4.2.5. Order theoretic examples. Let ^ be a frame, i.e. a poset with 
finite meets and infinite joins such that these joins distribute over meets: 
(Vi ^i) A 6 = Vf(^« A 6). A frame is sometimes called a complete Heyt-
ing algebra or a locale. The prime examples of such a structure are posets 
{0{X), C) of open subsets of a topological space X. For such a frame A, the 
Fam(A) 
family 
fibration 
i 
is a coherent fibration: the finite meets and joins in 
Sets 
A induce fibred finite products and coproducts; arbitrary joins \/ in A induce 
simple coproducts, which satisfy Frobenius by the above distribution, see Ex-
ercise 1.9.4. Finally, the bottom element leads to equality satisfying Frobenius, 
see Example 3.4.4 (iii). 
Finite meets and infinite joins form the essential structure of frames: mor-
phisms of frames preserve these by definition. But in a frame one can define 
infinite meets by 
A a, = \/{b I b is lower bound of («»)} = \/{b \ Vi. b < a,} 
and implication by 
a D 6 = \J{c I a Ac < 6}. 
Fam(A) 
Thus 
i 
is actually a first order fibration. 
Sets 
-^ 
The special case where A is the frame 0{X) of opens of a topological space 
X captures Tarski's [328] interpretation of (constructive) first order logic in 
the opens of a topological space X, formulated in the 1930s. We mention the 
main points. For opens {U{i,j)){ij)£ixJ ^^^ has 
coproduct: 
M C^(ij) j 
and product: 
I Int(M [^(fj)) 
V^-^ 
/ iei 
V 
^^-^ 
/ ia 

240 
Chapter 4- First order predicate logic 
where Int(—) is the interior operation. (If J = 0 we take this intersection to 
heX.) 
For /-indexed collections (Ui)i^j and {Vi)i^i one has as implication over /, 
the /-indexed implication in the Heyting algebra 0{X): 
(Ui)ia D iVi)ia = (lnt((X - Ui) U Vi)).^j. 
For more information, see [335, Chapter 9] or [281]. 
4.2.6. Realisability example. Under constructive reading, a proof of a 
proposition consists of a method of establishing it. In 1945 Kleene [178] 
gave the so-called realisability interpretation of constructive logic (see 
also [333, 23, 335]), in which such a proof is understood as a code of a partial 
recursive function. Kleene introduced a relation nr(f, to be read as 'n G N 
realises proposition <p\ That is, n is a code for a partial recursive function 
m ^ n m which is a method for establishing (p. Kleene stipulated, 
nr(ipAip) 
O- n is (recursive) pair (ni,n2) with nir(p and n2rip 
/ 
V /\ 
• / 
• 
\ 
• / 
\ 
-.1 ( n2rip 
if ni = 0 
nr[ip\/%)) ^ 
n is (recursive) pair (n 1,712> with < 
, .^ 
^^ 
^ ^ 
^ 
/ r- 
\ 
7 / 
j^ n2rip if ni = 1 
nv{(p D il)) ^ 
for each m with mr^ one has [n • m)rij;. 
See e.g. [335, 23] for more information on realisability. In order to deal with 
first order logic, we shall describe a set-indexed version of this interpretation. 
We write PN for the powerset of N. For an arbitrary set /, consider the set 
of functions (PN)^ from / to PN. Elements of (PN)^ are also called non-
standard predicates on /. Such a predicate X G (PN)^ is called valid 
if 
Thus X is valid if there is a single natural number which is member of all 
Xi's. 
In line with Kleene's stipulations, put for X,Y E (PN)^, 
(X AY){i) 
= {(n,m) I nGX(i) and mGy(i)} 
(XyY){i) 
= 
{{0,n)\neX(i)}[j{{l,m)\meY(i)} 
{XDY){i) 
= {n I for each m G X ( i ) , n - m G y ( 0 } . 
The latter gives rise to a preorder on (PN)^ by 
X<Y 
^ 
m X ( z ) D y ( i ) j # 0 . 

Section 4-2: Fibrations for first order predicate logic 
241 
Notice that this ordering is not pointwise but uniform: a single code must 
be member of every X{i) D Y{i). For more information on this ordering, see 
Exercise 4.2.5. 
There is a bottom element ± = J^i G /. 0 and a top element T = J^i G /. N 
in {PNy. In this way (PN, <) becomes a Heyting pre-algebra (or a preorder 
bicartesian closed category). 
The quantifiers are described as follows. For a predicate X G (PN)^^*^ one 
takes 
Uii,j)ixm = u xiij), 
n(/,j) WW = n ^(*'-?') 
where we understand the latter intersection to be N in case J is empty. 
The assignment / y-^ (PN)^ extends to a functor (or split indexed category) 
Sets^P -^ Cat with reindexing by pre-composition. The fibration resulting 
from this indexed category (via the Grothendieck construction) will be writ-
UFam(PN) 
ten as 
4- 
in which the letter 'U' in 'UFam' emphasises the uniform 
Sets 
character of vertical maps. This will be called the realisability fibration. In 
Example 5.3.4 in the next chapter it will be shown how, more generally, one 
can construct a similar fibration from a 'partial combinatory algebra' (like the 
Kleene structure (N, •) used here). 
UFam(PN) 
We claim that 
i 
is a first order fibration. In fact all the relevant 
Sets 
structure, except equality, has already been described above. Equality is given 
as follows. For X G (PN)^^"^ put. 
E,(x),.„,/,=(f-^)';i= 
4.2.7. Recursive enumerability example. Recall that a relation X C N" 
is recursively enumerable ('r.e.') if and only if there is a partial recursive func-
tion /:N^ —^ N such that x £ X ^ 
f{x) I (i.e. f(x) is defined precisely on 
X E: X); also that such r.e. relations on N" are closed under intersection Pi and 
union U. Hence r.e. relations on N" ordered by inclusion form a distributive 
lattice (with bottom 0 and top N"). Further, for an r.e. relation Y C N""*"^ 
the set 
{;? G N" I for some y G N, (£, y) G Y} 
is r.e. again. All this suggests there is a coherent fibration (with T,A,±,V 
and 3, =) involved. 
We first form a base category P R of partial recursive functions: objects are 
n G N and morphisms m ^ n are n-tuples {fi, • •., fn) of partial recursive 
functions /,:N"^ —^ M. Composition is done in the obvious way. One has that 
0 G P R is terminal and that n -\- m is the product of n and m. 

242 
Chapter 4- First order predicate logic 
The next step is to define an indexed category P R ° P -> Cat. We assign 
to n the poset of r.e. relations on M", ordered by inclusion. Reindexing along 
(/i 5 • • • 5 /n)- ?^ -^ ^ in P R is done by substitution: 
X C N" H^ {y G N^ I ( / i ( ^ , . . . , fniy)) eX}C 
N - . 
Obviously, the relation on the right hand side is r.e. again. The resulting 
RE 
fibration will be written as 
-f- . The above ingredients yield fibred finite 
products and coproducts and simple coproducts. Equality is given as follows. 
For X C N"+^ put, 
Eq(X) = {{x,y,z) 
G N"+-+^ | (?, y) G X and y = z}. 
RE 
Since the base category P R of this fibration ^ 
is an 'algebraic theory' (this 
means that the objects are of the form 1" for n G N) one obtains a structure 
in which one can interpret single-typed coherent logic: the object n in the base 
category stands for the type context in which n term variables (of this single 
type) are declared. 
We close this section by sketching how so-called cylindric algebras give 
rise to (single-typed, classical) first order fibrations. These cylindric algebras 
have been introduced by Tarski (see [121]) as algebraisations of predicate 
logic. They essentially consist of a Boolean algebra with distinguished opera-
tions (the Cn and dn,m below) for existential quantification and equality. This 
Boolean algebra is to be thought of as the collection of all propositions (with 
free term variables). What is lacking in this approach is the presence of sepa-
rate structures for each type context (which is such a prominent aspect of the 
indexed/fibred approach). We will briefly discuss a way to construct a first 
order fibration from a cylindric algebra. 
4.2.8. Cylindric algebra example. A cylindric algebra ("of dimension 
u;") consists of a Boolean algebra A = {A, ±, T, A, V) together with cylindri-
fication operations Cn^A-^A 
and diagonal elements dn,m ^ A, for n, m G N, 
satisfying the following seven postulates. 
(i) Cn± = L; 
(ii) X < CnX\ 
(iii) Cn{x ACnV) 
= CnX A CnV, 
(IVj CnCfnX = Cfn^^n^] 
(v) rf„,n == T; 
(vi) dn,k = Cm(dn,m^dm,k), for Ti ^i m,k\ 
(vii) Cn{dn,m A x) A Cn(dn,m A -^x) = _L, for Tl ^ 171. 
The intuition that one should keep in mind is that c„x is the proposition 
3vn.x{vn) 
and that dn,m is the proposition Vn = Vm, assuming we have a 
countable collection (vn) of term variables (corresponding to dimension u). 

Section 4-2: Fibrations for first order predicate logic 
, 
243 
An arbitrary set U gives rise to a cylindric algebra P(U^) 
consisting of 
subsets a of functions <^:N -> U, with obvious Boolean algebra structure, and 
with cylindrification and diagonalisation operations: 
^n(a) = [JxeuM^/^] 
k 
^ « } . 
dn,m = W £ U^ \ ^(u) = (p{m)} 
where (f[x/n] is the function which is x on n, and (p{m) on m ^ n. See [121] 
for more information. 
In order to turn a cylindric algebra A as above into a fibration, we first 
need a base category B. We take 
o b j e c t s 
natural numbers n G N. For such an object n E B we write 
[n] for the finite set { 0 , 1 , . . . , n — 1} of numbers below n 
(so that [0] = 0). 
morphisms 
n ^ m are functions [m] -^ [n]. Identities and composites 
are as for functions, except that the order is reversed. 
This category B has finite products: 0 G B is terminal object, and n + m G B 
is the Cartesian product of n , m G B: the projections TT: n-h m -^ n and 
TT': 77 -f- m —> m are given on i G [n] — { 0 , . . . , n — 1} and j G [m] = { 0 , . . . , m — 
1} by 7r(i) = i and 7r'(j) = n -h j ; and the pairing of /:/?—> n and 
g:k—^m 
as a function {f,g)' 
[n -\- m] —)- [k] is {f,g){i)'is 
given by: f(i) 
if i < n, and 
g{i — n) otherwise. Notice that a diagonal J: n -h m ^ (n + m) -h m in B, as a 
function S: [n + 2m] -^ [n -f m] is defined as: S{i) is i if i < n + m, and i — m 
otherwise. 
The next step is put an appropriate indexed category A:W^ 
-> Cat on B 
with Boolean algebras as fibres. To this end we identify sub-Boolean algebras 
A{n) ^^ A^ meant as fibres, as follows. 
A{n) = {x E: A\ Vm > n. CmX = x}. 
(We thus only consider the "finitary" part of the cylindric algebra A.) It 
follows from the above postulates that the Boolean algebra structure from A 
restricts to A{n). The main difficulty is to construct for a morphism 
f.n^m 
in B a substitution functor /*: A[m) -^ A{n). One can do this by first defining 
p-. A-^ 
Aon A^ and by subsequently checking that /* restricts appropriately. 
In the theory of cylindric algebras there are substitution operators s\: A —>• ^4, 
for Ar, ^ G N, defined as 
k ^ _ } ^ 
ifAr=^ 
Ck{dk,i A x) 
otherwise 
Sf X 
It may be understood as "substitution of variable vi for Vk^\ These functions 
s^ will be used to describe categorical substitution /*, but they cannot be 
used directly, because we need simultaneous substitution, in which unintended 

244 
Chapter 4- First order predicate logic 
overwrites should be avoided. The standard trick to avoid such clashes is to 
use a "parking area": let k = max{n,m}; the area above k can safely be used 
for parking, so that for i < m 
4(,)X = x[f{i)/i] = x[k+i/i][f{i)/k + i] = s;+;4+i^-
In this way we can define for x E A 
J \^)-^f(0) 
^f{m-l)^k" 
-Sfc+m-l^-
(Any k > max{n,m} yields the same outcome.) The verifications that /* 
restricts to A{m) -> A{n) and preserves the Boolean algebra structure, and 
additionally, that the assignment f ^ f* preserves identities and composition, 
are quite involved. We are especially interested in the cases where / is a 
projection Trin + m ^ n o r a diagonal 8:n-\- m -^ n -\- 2m. In that case one 
can calculate that 
7r'(x) = x 
and 
5*(x) = s^^"^ • • • slX'rT--,'x. 
Left adjoints JJ/^ ^x and Eq(„^^) to these TT* and 8* are obtained as: 
LI(n,m)(^) 
~ 
<^n • • - C n + m - l ^ 
Eq(n,m)(^) 
— ^ A c/n^„+^ A • • • A C?n+m-l,n+2m-l. 
(A right adjoint to TT* is then induced because we are in a Boolean situation.) 
We check the adjunction correspondence LJ(„^)(a:) < y ^ 
2^ < 7r*(y), for 
y E A{n) and z E A{n + 2m): if LJ(„ ,„)(ic) < y, then x < Cn " -Cn+m-ix 
= 
U{n,m){^) 
<y = ^*iy)' 
For the converse, if ^ < ir* {y) = y, then LI(n,m)(^) = 
Cn ' • 'Cn+m-i^ 
< Cn " ' Cn+m-iy = 2/, siuce y E A{n), SO Cn+iy = y. 
Exercises 
4.2.1. 
Check that the coproducts in Example 4.2.2 satisfy Beck-Che valley. 
4.2.2. 
In the same Example 4.2.2 check that the weakening functor TT* associated 
with a (general) projection n: (F, T') -> F, with F' not necessarily of length 
one, has both a left and a right adjoint. 
4.2.3. 
Consider the fibration constructed in Example 4.2.4 from a Kripke model 
/C:I-> Alg(E,n). 
(i) 
Prove that ]J(y) and f | ( ^ ) ^re monotone collections (for Y mono-
tone), 
(ii) Establish the bijective correspondence 
TT*{X){i) C Y{i) 
for all i £l 
X{i) C U{Y){i) 
for all i E I 
which produces the adjunction required for simple products. 

Section 4-3: Fibrations for first order predicate logic 
245 
(iii) Define equality. 
(iv) Check that each (E, n)-algebra forms a Kripke model 1 —)• Alg(E,II) 
and that the fibration associated with this Kripke model (as in Exam-
ple 4.2.4) is the same as the fibration associated with the algebra (as 
in Example 4.2.3). 
4.2.4. 
Consider a fibration with simple coproducts satisfying Frobenius. Prove 
that for objects X over IxJ and Y over / x K there is a vertical isomorphism 
Uu,J.K) 
((id X T-)(X) X (id X ;r')-(V-)) - U , ; , . , ( ^ ) x U,.,A-,(n 
over /. Explain the logical meaning of this isomorphism. 
4.2.5. 
This exercise shows that the order in the fibres (PN)^ of the realisability 
UFam(PN) 
fibration 
i 
is not the pointwise order. We consider 1 = 2 = {0,1}. 
Fix an arbitrary subset yl C N, and consider the following two predicates 
X,Y:2z^ 
PN. 
^ . . 
/ N\A 
if n = 0 
^ . . 
/ {0} if n = 0 
(i) 
Check that X(0) < 7(0) and X(l) < y(l), so that X is pointwise less 
than y. 
(ii) Prove that ifX<Y, 
say via e G {X{0) D Y{0)) H (X(l) D Y{1)), then 
e yields a decision code for A. But ^4 C N is arbitrary, so we may take 
A to be the halting set. 
4.2.6. 
Check that for a proposition ^ in predicate logic, the result (^[ve/vk] of 
substituting a term variable vi for a diff'erent variable Vk is logically equiv-
alent to the proposition 3vk. {vk = ViA<^). This a logical justification of the 
definition of the substitution operation 5^ in Example 4.2.8. 
4.2.7. 
In which of the examples in this section does one have classical logic? That 
is, -i-iX < A", where negation "•( —) is (—) D ±, so that each fibre is a 
Boolean algebra. 
E 
4.2.8. 
A coherent (or first order) fibration -jrP will be called Boolean if for each 
A G E above / G B there is a complement X' above / with verticcil 
isomorphisms X A X' = ± and A V A' = T. In that case, each fibre is a 
Boolean pre-algebra, see e.g. Example 4.2.3. 
(i) 
Show that such a complement X' is unique up-to-isomorphism. 
Suppose now p is Boolean and choose for each A G E such a complement 
and write it as -iX. 
(ii) Show that -> forms a functor Ej^ -^ E/, which commutes with substi-
tution. 
(iii) Prove that a Boolean coherent fibration is already a (Boolean) first 
order fibration. 

246 
Chapter 4- First order predicate logic 
4.3 Functorial interpretation 
and internal 
language 
In the previous section we introduced appropriate fibrations for predicate logic 
and listed a series of examples. Here we turn to the (functorial) interpretation 
of predicate logics (as described in Section 4.1) in such fibrations. It leads to 
the concept of the internal language, which gives us a convenient means to 
reason directly in such fibrations, as will be shown in several examples. 
We start with validity in a fibration, as first described in Definition 3.5.3 
for equations. Here it will be extended to arbitrary predicates. Let therefore 
(E,n) be a signature with predicates. Consider a situation 
E 
P 
ff(E) 
— 
where p is a preorder fibration with finite products both fibrewise and in its 
base category, and where A^ is a (functorial) model of S in B. A model of 
E 
(S,n) in 
jrP consists of such a model A^ of E in the base category B of p 
together with for each predicate symbol P: cri,..., (T„ in H, a predicate object 
J\f(P)eE 
above M{xi:ai,... 
,Xn:(Tn) = M{(TI) 
x • - - x M{an) 
£M. 
Such a model of (E, H) in p can be identified with a morphism in the category 
Fib of fibrations, 
£(E,n) 
^ E 
P 
ff(E) 
M 
£(s,n) 
where 
4- 
is the syntactically constructed classifying fibration from Sec-
tion 3.1, which has only predicates from H as (basic) propositions. This is 
because the only rules that can be used in this restricted logic are the context 
rules from Section 3.1 (which are unaffected by the presence of the atomic 
predicates in H). And these context rules are sound, as we already saw in 
Lemma 3.5.6. Like in Example 4.2.2 we shall use finite conjunctions (T,A) 
and logical contexts of length one in this classifying fibration. 
Assume now that p is a regular fibration. Then one can extend the above 
interpretation Af to propositions with =, T, A, 3. In a straightforward way one 

Section 4-3: Functorial interpretation and internal language 
247 
puts 
A^(r f - M = ^ M':Prop) = 
Eq{M{M),M{M')) 
(where Eq is as in 3.4.2) 
7V(r h T: Prop) = 
T 
Af{T \- ipA^j: Prop) = J\f{T h <f: Prop) A ^f{T h jp: Prop) 
M{T h3x:a.^:Prop) 
= U(>i(r),>t(a)) (-^(r, ^: ^ ^ V^: Prop)) 
where ]J/j jx is the coproduct functor E/xj —> E/, left adjoint to the weak-
ening functor TT} J . 
We say that a sequent F | ^ h ^ holds or is valid in the above model 
(A^,^')if 
A^(r h (f: Prop) < Af{T h Jp: Prop) 
in the fibre above M(T). And that a predicate T \- (p: Prop holds or is valid 
in case the sequent F | T h ^ holds (i.e. in case T < Af{T h (f: Prop) over 
MiT)). 
As we have seen in Lemma 4.1.8, the rules for 3 can be cast in 'mate' form: 
T \e,3x:a.(p[- 
xp 
T,x:a \Q,(p \- tp 
We shall write x for the finite conjunction of the propositions in 0. Soundness 
of this (double) rule then follows from the adjointness (U H TT*) with indices 
wM(F) and M{a), together with the Frobenius condition: 
F I x, 3x: a.ip \- ip is valid 
<^ M{T h X A {3x: a. (f): Prop) < Af(T h V^: Prop) 
<> J\f{T h x: Prop) A JJ A/'(r, x:a h ip: Prop) < A'(F h iP: Prop) 
O 
U (7r*7V(F h x: Prop) A 7V(F, ^: <7 h v?: Prop)) < J\f{T h V^: Prop) 
<^ A/'(F, x: cr h x: Prop) A ^ ( F , x:a \- (p: Prop) < 7r*A/'(F h V^: Prop) 
<J=> 
JV(F, J^: 0- h X A V:): Prop) < A/'(F, x:a \-jp: Prop) 
<:> F, x: (T I X A V? h V^ is valid. 
E 
The fact that the rules for 3 hold in such a model 
^P can alternatively be 
expressed by: the morphism {M^J\f) of fibrations (in the previous diagram) 
preserves simple coproducts ]J, where the coproducts in the classifying fibra-
tion arise as in Example 4.2.2. 
Thus, given a set A of regular axioms for (E, 11), we can say that the above 
model satisfies A if all sequents in A are validated. In that case one obtains 

248 
Chapter 4- First order predicate logic 
a morphism of fibrations 
£(E,n,^) 
^E 
«(E) 
M 
where the classifying fibration on the left captures the logic with axioms from 
A, The total category >C(E,n,^) contains the propositions V \- (p: Prop that 
can be formed from equations M —a M' and from atomic predicates from 11. 
The fibred preorder structure (F h 9?: Prop) < (F h V^: Prop) in i:(E,n,^) 
over r E C^(E) is given by derivability of the sequence Y \ Lp V i^) from the 
axioms in A. 
In case this fibration p is coherent (i.e. additionally has distributive fibred 
coproducts), then one can interpret finite disjunctions as 
M{Y h 1 : Prop) =: 
1 
A'(r V pyi)'. 
Prop) = A/'(r h p-. Prop) V A/'(r h V^: Prop). 
And if p is a first order fibration, then one can interpret the remaining 
logical operations of implication and universal quantification as 
7V(r h V? D V^: Prop) = A^lF h p-. Prop) D A/'(r h V': Prop) 
M{Y V^x:<T.t^?xo^) 
= 
n(>t(r),>t(a))(-^(r,^:^HV^:Prop)). 
Validity of the rules involved is left as an exercise below. 
We see that the main aspect of Lawvere's functorial semantics can be used 
also for the interpretation of predicate logic: namely that interpretation is 
preservation of the relevant structure. 
We proceed along (by now) fairly predictable lines: firstly we say formally 
what a morphism of regular / coherent / first order fibrations is; this enables us 
to say what a (functorial) model of a predicate logic is. Secondly, we describe 
the signature with predicates (plus the axioms) associated with a regular 
/ coherent / first order fibration; then a bijective correspondence between 
models and morphisms of specifications can be given. 
4.3.1. Definition. A morphism of regular fibrations is a morphism of 
Eq-fibrations which preserves simple coproducts \J. A morphism of coher-
ent fibrations additionally preserves fibred finite coproducts (i-,V) and a 
morphism of first order fibrations is a morphism of coherent fibrations 
which also preserves fibred exponents D and simple products [][. 
The appropriate 2-cells are as for (Eq-)fibrations, see Definition 3.6.1 (ii). 

Section 4-3: Functorial interpretation and internal language 
249 
4.3.2. Definition. A model of a regular / coherent / first order spec-
E 
ification (E, 11, ^ ) consists of a regular / coherent / first order fibration 
\P 
together with a morphism 
a(E) 
J 
\ 1 
of regular / coherent / first order fibrations. 
Recall from Remark 4.1.5 that a specification in predicate logic may be ex-
tended with external equations, so that it becomes a four-tuple (S, 11, Ai^Ae), 
where Ai is the set of internal axioms (as used so far), and Ae are the addi-
tional external equations. In this extended case one should describe a functo-
rial model as a structure preserving morphism 
£(i;,n,^,) 
(i) 
involving a quotient base category C^(E) -^ Cl(ll,Ae) incorporating the addi-
tional identifications. 
The following two lemmas form the basis for soundness and completeness 
results. 
4.3.3. Lemma (Soundness). Let (11,11,^) he a regular/ coherent /first 
or-
der signature. Every [Ti^lV)-sequent which is derivable from A in regular / 
coherent /first 
order logic, holds in a model o / ( E , n , ^ ) . 
• 
4.3.4. Lemma (Completeness). Let (E,n,^) he a regular / coherent 
/first 
order signature. A [Ti^H)-sequent is derivable from A in regular / coherent / 
first order logic if and only if it holds in the generic model; 
£(s,n,>i)\ 
— 
/z:(s,n,>i)\ 
i 
^ 
>^ 
° 
E 
4.3.5. Definition, (i) Let 
^P be a (regular) fibration. The many-typed 
signature Sign(IB)—containing objects / E B as types and morphisms u: Ii x 
-' X In -^ J in M dis function symbols—can be extended to a signature with 
predicates (Sign(IB), n(/))) where 
X : / i , . . . , / n is in n(p) 
if and only if 
X eEj^x 
xin-
There is an obvious functorial model of the signature with predicates of the 

250 
Chapter 4- First order predicate logic 
fibration p in p itself: 
/:(Sign(i,n(p)) 
C^(Sign(B)) 
- ^ E 
(ii) The collection A{p) of axioms of p contains the (Sign(B),II(p))-
sequents of the form 
i: I I X(i) h Y(i) 
where X,Y eE satisfy 
X <Y 
inEj. 
The model in (i) can be extended to a morphism of fibrations 
£(Sign(B,n(p)M(p)) 
CX(Sign(B)M(B)) 
- ^ E 
by interpreting the specification of p in p itself—where ^(B) is the collection 
of (external) equations which hold in the base category B, as described in 
Definition 3.3.6. A fibration thus gives rise to an extended specification as in 
Remark 4.1.5. 
4.3.6. Theorem. Let (T^,Il,Ai,Ae) 
be a regular signature and -^P a regular 
fibration. There is a bijective correspondence between 
regular models I 
4-
iP 
maps of regular specifications (E, II, AijAe) —>- (Sign(B), n(p),^(p),^(B)) 
The 'counit^ regular model in (ii) in the previous definition is an equivalence. 
Similar results hold for coherent and first order fibrations. 
Proof. The correspondence follows from a by now standard argument. In 

Section 4-3: Functorial interpretation and internal language 
251 
order to obtain the equivalence, we have to define functors 9 and 0' in: 
E 
^ £(Sign(B,n(/>),^(p)) 
B 
^ «(Sign(l)) 
0 
The functor 9' maps a predicate X G E/ to the predicate i: / h X(i): Prop in 
the internal language of p. It is a functor since a map X < y in E/ yields an 
axiom i\ I \ X{i) h Y[i) in A{p). 
The functor 9 maps / G B to the context ar: /. It is easy to see that e o 9 — \A. 
Using the operations from Example 3.3.7 one obtains that there are maps 
[9 o e) 4=^ id, the composites of which are equal to identities in the classifying 
category C^(E,v4). Here we crucially need the equations from B as external 
equations in the logic. 
• 
Internal language 
The starting point in the remainder of this section is our last Theorem 4.3.6. 
It tells us that a regular / coherent / first order fibration can be reconstructed 
from its specification, i.e. from its signature with predicates plus its axioms. 
Therefore we can conveniently use the logical language associated with this 
specification in order to reason in such fibred categories. Below, we present 
several examples of this approach, but many more examples occur in the 
course of this book, where the internal language of a (preorder) fibration will 
be used frequently. 
E 
For a fibration j^P we shall call the predicate logic built on top of its 
signature with predicates (Sign(B), n(p)) the internal language of p. And 
the internal logic of p is the logic which starts from the specification 
(Sign(B),n(p),^(p)) of p. This logic incorporates everything that holds in 
p (via its axioms). 
In this internal language, an object / G B is a type and an object X G E 
above / G B is a proposition in context i:/, i.e. a predicate on /. Therefore 
we often write such an X as 
i: I \- X: Prop or as 
i: I h X{i): Prop or as 
i: I h X,: Prop. 
In the latter two cases we have made the dependence on / explicit in X{i) 
and Xj. This is convenient notation. Also for example, when X G E/xj is a 

252 
Chapter 4- First order predicate logic 
predicate on a product type, we can write this as 
i:IJ:J 
f- X(jj):Prop 
And if we have X,Y E E/, then, 
ill \ Xi h Yi 
is derivable in the internal logic of p 
if and only if X <Y over /. 
The result of reindexing a predicate Y = {j: J \- YJ: Prop) E Ej in p over J 
along a morphism (or term) u: I ^ J in the basis will be written as 
w*(y) = (i:/hy„(..):Prop). 
As a special case we could write weakening of X E E/ by adding a dummy 
assumption j:J as i:I,j:J 
h X;r(f j)-P''0P- This is would be different from 
ordinary predicate logic, where weakening is not an explicit operation—but 
see the explicit notation of [256], as mentioned in Example 3.1.1 (ii). 
We will use =/, T, A, i., V, D, 3, V with obvious meaning in the underlying 
fibration. The internal language (or logic) has the advantage that it is easy 
to manipulate, in contrast to categorical calculations, which are often more 
complicated. This will be illustrated in the next series of examples. 
E 
4.3.7. Examples (Quantification), (i) Let 
-jrP be a regular fibration. By 
definition, each weakening functor TT* induced by a Cartesian projection TT 
then has a left adjoint. We shall show in the internal language of p that in 
fact each functor u* has a left adjoint ]J^. Later in Section 9.1 we shall see 
that this makes p an 'opfibration'. 
Assume an arbitrary map u: I —^ J inM] the functor ]J^ is defined as 
X = (i: / h Xi: Prop) H—> {j: J h 3i: /. {u{i) =j j A Xi): Prop). 
The adjunction (]J^ H u*) follows from the following derivation. 
j:J\3i:L{u{i)=jAXi) 
\-Yj 
i:IJ:J\u(i)=j,XiTY~ 
Notice that the Beck-Che valley condition need not hold: it is an external 
condition involving pullbacks in the base category. These are not required to 
exist and—in case they happen to be there—they need not be expressible in 
the internal language. See Exercise 4.9.2 for some more relevant details. 
E 
(ii) Assume now that 
j-P is a first order fibration. One can now show that 
. 
. 
® 
. 
. 
•. 
each reindexing functor has a right adjoint as well. For u: I ^ J in M define 

Section 4-3: Functorial interpretation and internal language 
253 
n.(^) by 
X = {i: I h Xi-. Prop) ^-> {j: J \ Vi: /. (u{i) =j j D Xi): Prop). 
Then 
j:J\Yj 
hyi:L{u{i)=jDXi) 
i: I, j : J \Yj h u(i) - j D Xi 
i:IJ:J 
I yj,u{i) = j h Xi 
i: I I Yu{i) \- Xi 
Notice that the formulas for ]J^ and f|^ are the familiar set-theoretic ones, 
as used for example in Lemma 1.9.5. 
Next we show how one can conveniently describe in the internal language 
a category of relations associated with a regular fibration. 
4.3.8. Example (Relations).. Recall from Example 3.5.5 that the category 
Rel of sets and relations has sets as objects and relations i^ C / x J as 
morphisms / -> J. One usually writes R:I 
—+-> J for R C I x J in this 
setting. Identity morphisms and composition in Rel can be expressed using 
the connectives =, A,3 of regular logic, see the beginning of Example 3.5.5. 
This leads us to the following construction. 
E 
For a regular fibration -^P let ReKp) be the category with 
objects 
/ G B. 
morphisms 
/ —1-> J are equivalence classes of objects R £ ]K above 
I X J. 
The equivalence relation is the one induced by the preorder of entailment in 
the fibres {i.e. equivalence in the internal logic). Often we shall write R: / —h^ 
J in the internal language as a predicate 
i:IJ:J 
\- R{i J): Prop. 
The identity / —h^ / is then given by (internal) equality on /: 
i: /, i': I h i ~j i'\ Prop. 
And composition oi R: I —h> J and S : J —M- K by the 'composite' relation: 
i: /, k: K h 3j: J. R{iJ) A S(j, k): Prop. 
One easily checks that Rel(p) is a category; for associativity of composition 
of 
/ —K J -+^ K -4-^ L 

254 
Chapter 4- First order predicate logic 
one can reason informally: 
{{T o S) o R){iJ) 
^ 
3j:J.R{iJ) 
A 3k: K.[S{j,k) 
AT{k,i)] 
^ 
3k:K.[3j:J.R{iJ) 
A S{j,k)] A T{kJ) 
<^ 
{To{SoR)){iJ), 
One can similarly describe the subcategory FRel(p) M- Rel(p) of functional 
relations. This category FRel(p) has objects / of the base category as objects. 
A morphism / —)• J in FRel(p) is a morphism R: / -H-> J in Rel(p) which 
is internally single-valued and total, 
as expressed by the following two 
sequents. 
i: I,j: J,j': J | R(i,j),R(i,j') 
h j =j f, 
f: 7 | 0 h 3;: J. 
R(iJ). 
It is easy to check that identities and composition from Rel(p) can be used in 
FRel(p), so that we get an inclusion functor FRel(7>) *^ Rel(p). 
The expressiveness of first order predicate logic allows us to formulate var-
ious mathematical notions in a very general situation where one has a fibred 
category i which allows us to reason about IB in the logic of this fibration. 
As an easy example we mention the following. 
E 
4.3.9. Definition. Consider a regular fibration jrP . A morphism u: I —> J 
in the base category B is called internally injective if the following sequent 
in the internal language of p holds in p. 
i: /, i': 7 | u(i) ~j u{i') h i =j i'. 
Similarly, u is internally surjective if 
i : J | 0 
b3i:Lj^ju{i) 
holds. 
Notice that 'internal injectivity' and 'internal surjectivity' are relative no-
tions in the sense that they are not intrinsic to the base category, but depend 
on the fibration that one puts on top of the base category (to get a certain 
logic). 
It is not hard to see that if internal and external equality coincide in a 
fibration, then 'internally injective' means 'monic in the base category'. This is 
more subtle with internal surjectivity, due to the occurrence of the existential 
Fam(A) 
quantifier 3. Consider for example a family 
fibration 
i 
for a frame A. 
For a set / and an /-indexed collection X — {Xi)i^i of objects Xi G A over /, 
the proposition 3i: I. X holds in this fibration if and only if the join Vie/ "^* ^^ 

Section 4-3: Functorial interpretation and internal language 
255 
the top element T in A. But this need not mean "external existence", i.e. that 
there is an actual element X,Q in this collection X for which Xj^ = T. We 
can conclude that internal existence {3i: I. Xj holds) need not imply external 
existence [Xj^ holds for some specific io:l 
—> I). 
Conversely, external existence trivially implies internal existence. We return 
to this delicate matter of existence at the end of Section 4.5 in connection with 
the Axiom of Choice, especially in Exercises 4.5.4 and 4.5.5. 
Exercises 
4.3.1. 
(i) 
Prove the soundness of the 'traditional' rules for 3 as in Figure 4.1 in 
a regular fibration. 
(ii) Verify that the rules for implication D and universal quantification V 
are sound with respect to the interpretation described above. 
4.3.2. 
Give a purely categorical proof of the inequality 
lJ,.,x)Odx«r(x)<u„.,)^ 
for u: K ^ J and X over I x J. That is, of the entailment 
i:I\ 3k:K.X(i,u(k) 
\-3j: J. 
X{i,j). 
4.3.3. 
Show that the reductio ad ahsurdum rule of classical logic (see Section 4.1) 
is sound in a Boolean coherent fibration, as defined in Exercise 4.2.8. 
4.3.4. 
Investigate internal injectivity / surjectivity in the fibrations 
DSub(Dcpo) 
(i) 
i 
of down closed subsets on dcpos, in Example 3.5.4; 
PredRel 
(ii) 
4- 
in Example 3.5.5. 
4.3.5. 
Consider an Eq-fibration on a distributive base category. Prove that 
the coproduct coprojections n^n' are internally 
injective, see Proposi-
tion 2.3.4 (ii). 
E 
4.3.6. 
In an Eq-fibration 
j^P there are left adjoints ]_I^/j) = Eq/ to contraction 
functors S{I)*, where S{I) = (id,id):/ -^ / x / is the (unparametrised) 
diagonal on /. Prove that the implication 
u is mono in B =^ u is internally injective 
holds if and only if these ]_I^fj\'s satisfy the Beck-Che valley condition with 
respect to puUback squares of the form 
/ > 
^ J 
y j 
Y 
S{J) 
5(1) 
I X I > 
>• J X J 

256 
Chapter 4- First order predicate logic 
4.3.7. 
Give a purely categorical argument to show that a reindexing functor of a 
regular fibration has a left adjoint, as in Example 4.3.7 (i). 
E 
4.3.8. 
For a regular fibration ^ , describe a sequence of functors 
B 
^ FRel(p) 
^ Rel(p) 
mapping a morphism / —)• J in IB to its graph relation / —H- J. 
4A Subobject fibreitions I: regular categories 
This section is entirely devoted to examples of regular fibrations v^hich arise 
Sub(B) 
from subobject 
fibrations 
4- 
. We shall find conditions on a category B 
ensuring that subobjects in B form such a regular fibration. A category will 
then be called a regular. In the next section v^e concentrate on the case v^here 
the subobject fibration is a coherent or first order fibration. All the material 
in this (and the next) section is standard (early sources are [17] and [284]), 
but usually it is not presented in terms of fibrations. For a slightly different 
approach to regular categories, in v^hich not all finite limits are assumed to 
exist, see [36, II, Chapter 2]. 
Subobject fibrations have received much attention because they incorporate 
the logic of toposes, see Section 5.4 later on. These fibrations are in fact rather 
special. For example, they always support very strong equality and full subsets 
(or comprehension). Later, in Section 4.9 we will give a precise characterisation 
of subobject fibrations in terms of logical structure. Part of this structure 
is given by the following result, which can be interpreted as saying that in 
subobject fibrations one always has unique choice (3!), see Proposition 4.9.2. 
Sub(B) 
4.4.1. O b s e r v a t i o n . Each subobject 
fibration 
i 
admits quantification 
B 
along monos: if m: X >^ / is a mono, then composition with m forms a left 
adjoint ] J ^ to reindexing m* along m. Moreover, these ][J's satisfy a Beck-
Chevalley condition: for every pullback square 
n 
1 -=* 
^ J 
1 J 1 
Y 
Y 
A ^ 
> i 
m 
the canonical natural transformation ]J^ v* => u* U^ 
is an isomorphism. 
Further, these coproducts satisfy the Frobenius property: there is a (canon-

Section 4-4- Subobject fibrations I: regular categories 
257 
ical) isomorphism lJm("^*(^) ^ ^) ^ '^ ^ LJm(^)- Both Beck-Chevalley and 
Frobenius follow from the Fullback Lemma (see Exercise 1.1.5). 
Later in Section 10.5, we develop tools to give an alternative formulation of 
this result; then we shall say that the 'comprehension category Sub (IB) <^ B~^ 
has (very strong) coproducts'. 
The following definitions are standard. 
4.4.2. Definition, (i) A category has images if every morphism has an im-
age factorisation; that is, every morphism u: I -^ J factors as 
Im(K) 
where m(w) is the least mono through which u factors: for an arbitrary fac-
torisation I -^ K y^ J of u, there is a necessarily unique map Im(ii) —> K 
making the diagram below commute. 
(ii) A category with images has stable images if its images are stable 
under pullback: if the diagram on the left below is a pullback, then so is the 
one on the right, 
Im(t;) 
>• Im(w) 
Y 
V 
w -^ J 
The map Im(t;) —• lm{u) is uniquely determined by the universal property 
of the image factorisation oi v, since v factors through w*{in{u)). 
(iii) A regular category is a category which has finite limits and stable 
images. 

258 
Chapter 4' First order predicate logic 
4.4.3. Example. In the category of sets the image of a function u: I -^ J 
exists and is given by the subset 
{j eJ \3ieLu{i) 
=j} 
^ 
^ J 
It may be clear that this is the least mono (injection) through which u: I -^ J 
factors. 
Note that there is an existential quantifier involved. It is made explicit in 
the next result. It shows that regular categories can be characterised in various 
ways. Of most interest to us is the equivalence of (i) and (v) below. 
4.4.4. Theorem. Let M he a category with finite limits. The following points 
are equivalent. 
(i) The category B is regular. 
(ii) The inclusion functor Sub(IB) <^ B"^ (obtained by choosing represen-
tatives) has a fibred left adjoint. 
Sub(]B) 
(iii) The subobject fibration 
I 
has coproducts ]J^ H u* satisfying Frobe-
nius. 
Sub(l) 
(iv) The fibration 
i 
has simple coproducts U(j j) "I ^ / j 
satisfying 
Frobenius. 
Sub(]B) 
(v) The subobject fibration 
i 
is regular. 
Sub(l) 
We recall that for B = Sets, the subobject 
fibration 
i 
is the fibration 
IE 
Pred 
4- 
of predicates over sets as described in Section 0.2 in the Introduction. 
Sets 
^ 
Sub(B) 
Proof. The equivalence (iv) <^ (v) is obvious, because the 
fibration 
i 
IB 
already has fibred finite products and equality satisfying Frobenius. Further, 
(iii) => (iv) is immediate. We shall do (i) <:> (iii) and (iv) => (iii) and leave 
the equivalence of (ii) to the other points as an exercise. 
(i) => (iii). For a morphism tt: / -> J in B and a mono m\X >-^ I one defines 
a coproduct by 
]J^(m) = (lm(w o m) > 
^ j ) 
Notice that Uy(?^) is simply w o m if w is a mono (as in Observation 4.4.1). 
There is then a bijective correspondence 
m < u*{n) 

Section 4-4' Suhohject fihrations I: regular categories 
259 
establishing an adjunction (]J[^ H u*)^ as follows. 
• if m < u*{n), then u o m factors through n and thus IJ^(?^), being the 
least mono for which this holds, satisfies IJ^(m) < n. 
• if Uu(^) ^ ^' then, using that w o r n factors—by definition of image— 
through ]J^(m), one obtains m < ^«*(Uu(^)); hence m < w*(IIu(^)) ^ 
ii*(n). 
The stability of the image factorisation ensures that the Beck-Chevalley condi-
tion holds. For Frobenius, consider for u: I -^ J, m £ Sub(/) and n G Sub( J) 
the following pullback squares. 
^ y / — 
X^ 
u*{n) 
^ I 
Y 
-^ J 
Then 
by definition of A 
by Beck-Chevalley 
= UnUu'(«*W)'M 
= U.U„.(n)(«*("))*M 
(iii) ^ (i). Given a morphism u: I —^ J^ define the image of u as: 
m{u) = [lm{u) > 
^ J) 
Using the unit rj in the diagram: 
V 
-^ K 
Y 
Im(w) 
id/ 
«*(U„(id/)) 
mH = lI„(id/) 
J 
one obtains that u factors through m(u). If also u = n o f with n monic, 
then id/ < u*{n) and thus, by transposition, m(u) — Uu(id/) < "• Stability 
follows from the Beck-Chevalley condition: 
w*(m(u)) = «;*(UJT)) - U..(„)(T) = m{w*{u)). 
(iv) => (iii). Coproducts along an arbitrary map u\ I -^ J are obtained by 
writing t/ = TT o (li, id): 7 ^-» J xl -^ J ^s composite of a mono and a Cartesian 

260 
Chapter 4- First order predicate logic 
projection. Since we have coproducts along projections (by assumptions) and 
along monos (by Observation 4.4.1) we are done by composition of adjoints. 
Beck-Chevalley follows from a similar argument. 
D 
Image factorisation in regular categories gives rise to a class of maps which 
are called 'covers'. The best way to think about these is as surjections, see 
explicitly in Lemma 4.4.7 below. 
4.4.5. Definition. In a regular category, a morphism u: I -> J is called a 
cover if its monic part m{u): lm{u) ^-» J is an isomorphism. One often writes 
u: I -> J to indicate that w is a cover. 
In Example 4.4.3, the covers in Sets are precisely the surjective functions. 
The next lemma lists a series of results about these covers; it includes four 
alternative characterisations: in (i), (iii), (vii) and (viii). 
4.4.6. Lemma. In a regular category the following 
holds. 
(i) A morphism 
u is a cover if and only ifu is extremal;/or each 
factori-
sation u = m o u' one has: m is a mono implies that m is an 
isomorphism. 
(ii) A monic cover is an 
isomorphism. 
(iii) A morphism 
u is a cover if and only if the map U^^(T) -> T is an 
isomorphism, 
where ]J^ is the induced left adjoint to u*, see (iii) in 
Theo-
rem 4'4-4' 
(iv) Every isomorphism 
is a cover. Covers are closed under composition: 
if 
u,v are (composable) 
covers, then v o u is a cover. Also, if v o u and u are 
covers, then v is a cover. 
(v) Covers are stable under 
pullhack. 
(vi) Every map factorises 
as a cover followed by a mono. 
(vii) A morphism 
u is a cover if and only if u is orthogonal to all monos. 
The latter means that in a commuting 
square 
u 
>• 
/ 
/ 
/ 
A 
> 
>" 
there is a unique diagonal as indicated, 
making everything 
in sight 
commute. 
(viii) A morphism 
u is cover if and only if u is regular 
epimorphism. 
From (vii) one can conclude that the factorisation in (vi) is essentially 
unique (in an obvious sense). This yields that the collections (Monos) and 
(Covers) form a factorisation system (see [18]) in a regular category. 
Most of the results in this lemma are easy to prove, except the implication 
(=>) in (viii) which tells that covers are regular epis [i.e. epis which occur as 

Section 4-4' Subohject fibrations I: regular categories 
261 
coequalisers). This is a folklore result. The proof that we present is essentially 
as in [169, Theorem 1.52]. 
Proof, (i) The implication (<=) is obvious by definition of 'cover'. In the 
reverse direction, assume a cover u: I -> J is written as w = m o w', where m 
is a mono. Then the image m(i/) of u must satisfy m{u) < m. But since m{u) 
is an isomorphism by assumption, we get that m is an isomorphism as well, 
(ii) Write u = u o id and apply (=>) in (i). 
(iii) Notice that for a morphism u one has 
UJT) = U„(id) = m(«oid)=:m(«). 
Hence w is a cover if and only if m(i/): Im(w) -^ id is an isomorphism (in the 
slice category), i.e. if and only if U^(T) —)• T is an isomorphism. 
(iv) If u is an isomorphism, then one can take as monic part m(i/) = u. 
And [{ u,v are covers, then so is i;: 
U.ou(T) = U.(Uu(T)) = U . ( T ) S T 
SO we are done by (iii). Similarly, if v o u and u are covers, then 
TSU.oJT)-U.(Uu(T))sU.(T). 
(v) Consider a pullback square 
v^u) 
J 
Then 
U..(u)(T) = U..(„)K-(T)) 
- 
«*(IJ„(T)) 
by Beck-Chevalley 
S T. 
Hence v* (u) is a cover again by (iii). 
m(u) 
lm(u) 
^ 
J. We 
(vi) Every morphism u: I ^ J can be written as / 
show that u' is a cover using (i). Assume u' = n o u", where n is a mono. 
Then u — (m(w) o n) o u" and thus m[u) < m{u) o n, since m(w) is the least 
mono through which u factorises. But then n must be an isomorphism. 

262 
Chapter 4- First order predicate logic 
(vii) First, assume that u is cover in a commuting square 
Then u factors through the mono g*{m). Hence by (i), g*{m) is an isomor-
phism. This yields the required diagonal J —-^ Z. 
Conversely, if w: / ^ J is orthogonal to all monos, and u can be written as 
u — n o f with n a mono. Then we get a commuting square 
This yields a fill-in s\ J —^ Y with s o u — f and n o 5 = id. So n is a split 
mono and thus an isomorphism. 
(viii) It is easy to see that regular epis are covers: suppose u\ I -^ J is 
coequaliser of /, ^: K nt / and can be factorised diS u — m o u' where m is a 
mono. Then u' o f z=z u' o g so there is a unique n with n o u — u'. Hence 
monou 
— mou' 
= u, which yields m o n = id by the fact that u is epi. 
Thus m is an isomorphism and w is a cover by (i). 
For the converse we first prove that a cover u: I-> J is an epi: suppose 
f,g:J 
=^ K are given with f o u = g o u. Then u factorises through the 
(monic) equaliser of / and g. Hence this equaliser must be an isomorphism 
by (i).Thus/ = ^. 
We come to the proof that such a cover t/: / -i> J is a regular epi. We form the 
kernel pair TTI, 7r2: /? =^ /, by taking the pullback of w against itself, and intend 
to show that u is the coequaliser of this pair 7ri,7r2. Assume therefore that 
v: I —^ K also satisfies v o TTI r= i? O 7r2. We factorise the tuple (w, t;): / —>• J x K 
as 
(/ 
^ / X A') = (/ 
w 
m 
t>W> 
^ J X K) 
and intend to show that TT o m: VF —> J is an isomorphism; then we are done 
since it yields that a = TT' o m o [n o m)~^: J -^ K is the (unique) required 
mediating map with a o u = v (since {w o m)~^ o u = w). 
Firstly, TT o m is a cover since both w and {TT o m) o w = u are covers, using 
(iv). In order to see that TT o m is monic, assume j^g.Z -z^W are given with 

Section 4-4' Subobject fihrations I: regular categories 
263 
TTomof 
— TTomog. 
Form the pullback square 
Z' 
>Z 
if. 9') J 
if, 9) 
I xl 
>W X W 
W X W 
Both id X It; and w xid can be obtained from w by pullback along a Cartesian 
projection. Hence they are covers by (v) and thus w x w = {idx w) o (w x id) 
as well. But then also /i is a cover and in particular an epimorphism. One has 
u o f 
r= TT o {u^v) o f 
— 
TT O m O W O f 
= 
T T o m o / o / i 
= 7romogoh 
by assumption about /, g 
= uo g'. 
Hence there is a unique k\ Z' -^ R with TTI o k = f and 7T2 o k — g'. Then 
{TT' o m o f) o h = n' o m o 7T o w X w o {f ^ g') 
= 
IT' o {u^v) o f 
— 
V O TTi O k 
— V o 1:2 o k 
by assumption about v 
— TT' o {u, v) o g' 
— {TT' o m o g) o h. 
But then TT' o m o f — TT' o m o g^ since h is an epi. Hence in o f = m o g and 
thus f = g, since m is a mono. By (ii) we conclude that TT o m is isomorphism 
and so we are done. 
D 
The attention in this section has been focussed on monos and covers in 
regular categories. It is therefore appropriate to close with the following result, 
which tells that monos and covers are the internal injections and surjections in 
subobject fibrations (see Definition 4.3.9). Some more information on monos 
and covers is given in the exercises. 
Sub(l) 
4.4.7. Lemma. With respect to a subobject fibration 
I 
of a regular cat-
M 
egory M, a morphism 
in B is internally 
injective if and only if it is monic 
in 
M, and it is internally 
surjective 
if and only if it is a cover in M. 
Proof. Consider a morphism u: I -^ J in M. The first part of the statement 
that u is internally injective if and only if it is a mono in B follows from 

264 
Chapter 4- First order predicate logic 
the fact that internal and external equality coincide in subobject fibrations. 
Explicitly, the proposition stating that u is internally injective amounts to 
Eq{u o TT, i/ o TT') < Eq(7r, TT') 
over I x I, 
Since equality in subobject fibrations is given by equalisers (see Examples 3.4.4 
(i) and (ii)), this reduces to the statement that the equaliser ofuoir 
and u o n' 
factors through the diagonal S = (id, i d ) : / ^-^ I x I. One easily verifies that 
the latter holds if and only if i/ is a mono in B. 
In the same vain, the statement 'u is internally surjective' unravels to 
. 
Eq(7r, uo TT') 
^ 
. 
id J < Image oi [• > 
>• J x I 
>• J ) . 
But since the equaliser Eq(7r, u o TT') of TT and u o n' is (w, id): I ^^ J x I, this 
amounts to 
id J < Image of w, 
which says that w is a cover. 
• 
Exercises 
4.4.1. 
Show that images in the category of sets (as described in Example 4.4.3) 
are stable. 
4.4.2. 
A split epi is morphism u which has a section {i.e. for which there is an s 
with w o 5 = id). 
(i) 
Check that a split epi is an epi. 
(ii) Show that in a regular category, a split epi is a cover. 
4.4.3. 
Show that for a subobject fibration, the internal description of ]J 
in Ex-
ample 4.3.7 (i) coincides with the description in the proof of Theorem 4.4.4 
in terms of images. 
4.4.4. 
In a regular category, consider maps 
e 
u 
m 
K 
>I 
^ J> 
^ L 
and show that there are the following equalities of subobjects. 
(i) 
lm(w) ^-> J is Im(u o e) ^^ J; 
m 
(ii) Im(ti) >-^ J ^^ L \s Im(m o u) >—^ L. 
e
m 
4.4.5. 
Let I -i> I ^^ J be the factorisation of w:/ —)• J in a regular category. 
Form the kernel pairs 
TTo 
Ao 
/ 
>• J 
and 
L 
7^1 
Ai 
K 
I 
^ > J 
and 
L 
/ — ^ - > r 

Section 4-5: Suhobject fibrations II: coherent categories and logoses 
265 
and show that the tuples (TTCTTI) and (Ao,Ai) are the same, as subobjects 
of / X /. 
4.4.6. 
Let / be an object in a regular category. Show that /-i> 1 {i.e. the unique 
map / —> 1 is a cover) if and only i f / x / = t / ^ l i s a coequaliser diagram. 
4.4.7. 
Let IB be a regular category with an object / G B. Show that the following 
statements are equivalent. 
(i) 
7 ^ 1 ; 
(ii) The functor /*:B -> B / / reflects isomorphisms; 
(iii) The functor /*:B —> B / / is conservative {i.e. reflects isomorphisms 
and is faithful). 
4.4.8. 
Let B be a category with finite limits and coequalisers. Show that B is 
regular if and only if regular epimorphisms in B are stable under puUback. 
(Sometimes one finds (for example in [18]) this latter formulation as defi-
nition of regular category—in presence of coequalisers.) 
[Hint. For a map I ^ J consider its kernel pair R ^ I and their coequaliser 
I -^ J'. One gets a mono J' ^^ J which is the image of u.] 
4.4.9. 
Establish that the category Sp of topological spaces and continuous func-
tions IS not regular. 
[Hint. Use the previous exercise, or see [36, 11, Counterexample 2.4.5].] 
E 
4.4.10. 
In Example 4.3.8 we have associated with a regular 
fibration 
^^ two 
categories Rel(p) and FRel(p) of types and (functional) relations in p. Here 
we define a slightly different category FRelP(p) of predicates and functional 
relations. It has 
objects 
objects X G E. 
morphisms 
X —H- y, say with X over / and Y over J, are (equiv-
alence classes of) relations R ^^i^j 
which satisfy 
i:I,3:J\R{i,j) 
h X . AY,, 
z : / , j : J , / : J | H ( z , j ) , i ? ( z , / ) h j = y / , 
i:I\X^ 
h3j:J.R{i,j). 
Verify that FRelP(p) is a regular category. This is like the construction of 
a regular category from a regular theory, like for example in [211, Chap-
ter 8, 2]. 
4.5 Subobject fibrations II: coherent categories and logoses 
We continue our investigation of subobject fibrations. In particular we investi-
Sub(]B) 
gate when a subobject 
fibration 
i 
is a coherent fibration {i.e. has fibred 
distributive coproducts -L,V) and when it is a first order fibration {i.e. addi-
tionally has implication D and universal quantification V). In the first case we 

266 
Chapter 4' First order predicate 
logic 
call M a coherent category, and in the second case a logos. In [85] a coherent 
category is called a pre-logos, and in [211] it is called a logical category. 
4.5.1. Definition. A coherent category is a regular category with 
• binary joins V in each subobject poset Sub(/), which are preserved by pull-
back functors w*:Sub(J) -^ Sub(/); 
• a strict initial object 0. 
Recall that strictness means that each arrow X —> 0 is an isomorphism. 
The way in which these joins V are usually obtained is as follows. 
4.5.2. Lemma. In a regular category with universal coproducts -h; the sub-
object fibre Sub(/) over I has joins V of subobjects X ^^ I and Y >-^ I, by 
taking the image of the cotuple, as in 
x + y 
>xyY 
These V 's are stable under pullback. 
• 
4.5.3. Theorem. A regular category M is coherent if and only if its subobject 
Sub(l) 
fibration 
i 
is coherent. 
Proof. Assume B is a coherent category. We have to show that the subobject 
Sub(l) 
fibration 
4- 
has a fibred initial object and that its joins V are distributive. 
B 
We begin with the latter: one has 
n A (mi V 7772) — ]J„ n*{mi V 7712) 
by definition of A 
= lJn^*K)Vn*(m2) 
— Un ^*(^i) V ]J^ n*{m2) since ]J„ is left adjoint 
= (n A mi) V (n A m2). 
Further, for / G B, let ±/ be the unique vertical map 0 ^^ /; it is a mono, 
since for maps f,g: K ^ 0, both / and g are isomorphism with f~^ = g~^ by 
initiality. Thus f — g. For each mono m:X ^^ I one obviously has JLJ < m 
in the poset Sub(/) of subobjects on /. And for u: I —^ J, in the pullback 

Section 4-5: Subobject fibrations II: coherent categories and logoses 
267 
diagram, 
«*(-Lj) 
the map u' is an isomorphism by strictness. By initiality one gets that the 
composite 0 •=)' 0' —> / is ± / , so that i/*(±j) ^ ± / over /. Thus the subobject 
fibration on IB has a fibred initial object. 
In the other direction, we follow the argument in [85, 1.61] to show that if 
Sub(l) 
i 
is a coherent fibration, then B has a strict initial object (and is thus a 
coherent category). Let 0 be the domain of the bottom element J_i: 0 >-^ 1 in 
Sub(l). For an object / G B, consider the pullback diagram. 
u 
0' H 
T 
T 
1 
!/ 
- ^ 0 
\ 
> 
/ 
l i 
' 
-» 
1 
> J 
Assume there is an arrow / : / —)• 0; we show that / is necessarily an isomor-
phism. The above pullback yields a map / ' : / - > 0' with Lj o f — id/ = T/. 
But then ± / = T/ in Sub(/). Applying this same argument to / o TT: / x / 
^ 
/ —> 0 yields ± / x / = (J/ = T / x / , where Sj is the diagonal (id, id): I ^^ I x I. 
Hence Sj is an isomorphism and so TT = T T ' I / X / —)• /. The unique arrow 
!/:/—> 1 is then monic and so an object of Sub(l). Hence ± i < !/ which 
yields an inverse for / : / —> 0. 
In particular, h in the above diagram is an isomorphism. We obtain a map 
0 —> 0' —> /. It is the only map 0 - ^ 7 , since given two such maps, their 
equaliser has codomain 0 and is thus an isomorphism. 
• 
Next we look at first order subobject 
fibrations. 
4.5.4. Definition. A logos is a coherent category for which each pullback 
functor w*:Sub(J) -^ Sub(/) has a right adjoint 
f|^. 
4.5.5. Theorem. A category B with finite limits is a logos if and only if its 
Sub(l) 
subobject 
fibration 
i 
is a first order 
fibration. 
Proof. Assume B is a logos. We first notice that the subobject 
fibration 
Sub(ffi) 
I 
has products: there are adjunctions [u* H Yl^) and Beck-Chevalley 

268 
Chapter 4' First order predicate logic 
holds for these products, because it already holds for coproducts ]J^ (see 
Lemma 1.9.7). In particular, this fibration has simple products. It also has 
fibred exponents: for mi,m2 G Sub(/) put, 
mi Dm2 =^ n m i ^ i ( ^ 2 ) . 
Then, for a subobject mi:X>^I 
with domain X, 
Sub(/)(n, mi 31712) = Sub(X)(m*(n), m*(m2)) 
= Sub(/)(U^^m*H, m2) 
^ 
Sub(/)(mi A n, 1712). 
The latter by definition of A. Exponents are preserved under reindexing by 
Beck-Che valley for Y[-
The reverse implication follows from the construction of JJ^ in a first order 
fibration, as described in Example 4.3.7 (ii). 
• 
We conclude this section with examples of logoses, involving in particular 
the categories of sets and of PERs. Logic in Ct;-Sets will be described later in 
Section 5.3 (especially in Proposition 5.3.9) in terms of its re^fw/arsubobjects. 
There one also finds a description of regular subobjects in the category PER, 
giving rise to classical logic. 
4.5.6. Example, (i) The category Sets of sets and functions is a logos. We 
have already seen that it is a regular category. Its posets of subobjects Sub(/), 
Sub(Sets) 
Pred 
occurring as fibre categories of the 
fibration 
i 
= 
i 
can be iden-
^ 
^ 
Sets 
Sets ' 
tified with the powersets (P/, C). These posets are Boolean algebras, so we 
certainly have distributive joins (namely 0 and U) making Sets into a coherent 
category. Further, there are products f7:Sub(/ x J) —> Sub(/) by 
(xcixj)^ 
{{i I Vi e J. {ij) ex}c /). 
In the next chapter we shall see that, more generally, every topos is a logos. 
(ii) The category PER of partial equivalence relations is also a logos (as 
shown in [143]). Recall from Section 1.2 that PER has finite limits. It is not 
hard to see that a morphism /: i? -^ 5 is a mono in PER if and only if the 
function /:N/i?-> N/S between the underlying quotient sets is injective. 
For a morphism f: R ^ S we define the image as the PER, 
Im(/) = {(n,n') € \R\ x \R\ \ / ( H « ) = 
f{[n']n)}, 
together with the monomorphism, 
m(/) 
Im(/)> 
^S, 
Wim(/) I—^ f([n\R). 

Section 4-5: Subohject fihrations II: coherent categories and logoses 
269 
This is indeed a mono, because the underlying function is injective by con-
struction: 
m ( / ) ( W i n , ( ; ) ) : = m ( / ) ( [ n V ( / ) ) ^ 
/ ( W H ) = / ( K ] H ) 
^ 
Wlm(/) = K]lm(/). 
There is then a morphism f \ R -^ Ini(/) by [n\R \-^ Mim(/)- It obviously 
satisfies m ( / ) o f — f. It is not hard to see that this image Im(/) ^-^ 5 is 
appropriately minimal, and stable under puUback. Thus we get that P E R is a 
regular category. A characterisation of covers in P E R is given in Exercise 4.5.2 
below. 
One can conclude that P E R is a coherent category from the fact that it 
has universal finite coproducts (0,+), using Lemma 4.5.2. The initial object 
0 is the empty PER 0 C N x N, which has quotient set N / 0 = 0. And the 
coproduct of PERs R, S is 
R+S= 
{((0, n), (0, m)) | nRm} U {((1, n), (1, m)) | nSm}. 
Finally, P E R is a logos, because it is locally Cartesian closed, see Exer-
cise 1.2.7. The product functors J | ^ : P E R / i ? —>• P E R / 5 between slices re-
strict to product functors ny:Sub(i?) -> Sub(5), because right adjoints pre-
serve monos. 
(iii) In Example 4.2.5 we have seen how a frame (or complete Heyting al-
Fam(yl) 
gebra) A gives rise to a first order 
fibration 
I 
. It turns out that first 
order logic is also present at a diflferent level: the total category Fam(yl) of 
this fibration is itself a logos. We sketch the main points. 
A terminal object in Fam(74) is the family (T)*gi consisting of the top 
element T G ^ over a singleton (terminal) set 1 = {*}. The pullback of 
morphisms u: (xi)i^j 
—> {zk)keK 
and v: {yj)j^j 
—> {zk)k^K 
consist of the 
family (xj A yj){i,j)eixKJ 
over the pullback / x ^ J in Sets of w:/ -^ K 
and v: J ^ K, with obvious pullback projections. A morphism u: {xi)i^j 
-^ 
(yj)jeJ 
is monic in Fam(74) if and only if the underlying function u: I —^ J 
is injective. A subobject of a family {xi)i^j 
may thus be identified with a 
"subfamily" {x'i)i^v ioi V C I with x^- < Xi, for all 
ieV. 
For an arbitrary such map u in Fam(yl), we can first factorise w: / -> J in 
Sets as u'\I->J' 
— {j ^ J \ 3i G Lu{i) 
— j] followed by m(u): J' >-^ J. 
This factorisation can be lifted to Fam(74) as: 
m{u) 
> 
^ 
{yj)jeJ 
jeJ' 

270 
Chapter 4- First order predicate logic 
It is easy to verify that this factorisation in Fam(A) is appropriately minimal 
and stable under pullback. This shows that Fam(A) is a regular category. It 
is coherent since the empty family is a strict initial object, and since for an 
arbitrary family {xi)i£j E Fam(^), the join of two "subfamilies" {yi)i£UCi 
and (zi)i^vci 
is a family over U UV C I given by: 
(vi 
iueu\v 
{{yi)V{zi))(i)=\ 
Zi 
iiieV\U 
[ Vi V Zi if 2 E f/ n K 
These joins are distributive and stable. Finally, we have to produce a right 
adjoint W^ to pullback u^ along a morphism u\[xi)i^i 
—)- {yj)j£j- Notice 
that 
' " ^ ( ( ^ j ) j G V C j ) = 
{'Wu{i))ieu*{V)CI' 
The required right adjoint is then given by: 
Ylu{iyi)ieuci) 
= I 
A 
^* 
where Vt,([/) = {j e J \ Vi E /. u{i) = j =f^ i e U}. 
The second example above, showing that subobjects in PER form a first 
order fibration, leads to the following associated result, showing that also 
regular subobjects in PER from a first order fibration—but with classical 
logic. It is based on a (folklore) correspondence between regular subobjects in 
PER and subsets of quotients. 
4.5.7. Proposition, (i) For a PER R there is a bijective (order preserving) 
correspondence between 
(a) subsets A C N/R of the quotient of R; 
(b) subsets B C \R\ of the domain of R which are saturated; if n £ B 
and uRn' then n' E B; 
(c) regular subobjects R' ^^ R of R. 
RegSub(PER) 
(ii) The 
fibration 
4- 
is a first order fibration with classical logic. 
Proof, (i) The equivalence (a) <^ (b) is easy, so we concentrate on (b) ^ (c). 
For two parallel morphisms f,g:R 
=^ S in PER, one can describe their 
equaliser by restricting attention to the saturated subset B C \R\ given by 
B = {n E \R\ \ f{[n]R) = p(Mii)}- And conversely, given a saturated subset 
BC |/^|, define a PER 5 by 
S = {{{i,n), {j,n^)) I i,i E {0,1} and nRn' and n E B} 
U{(0, n), (0, n')) I uRn' and n ^ B} U {(1, n), (1, n')) | uRn' and n ^ B} 

Section 4-5: Suhobject fibrations II: coherent categories and logoses 
271 
Then there are morphisms f^giRzit 
S defined by 
fiinU) 
- [(0, n)]s 
and 
g{[n]R) = [(1, n)]s. 
It is not hard to see that the set B C |i^| can be recovered from the equaliser 
subobject R' >-^ R resulting from these 
f,g. 
(ii) Using (a) in (i), the set-theoretic operations of (classical) first order 
logic can be used for this fibration of regular subobjects. 
• 
Exercises 
4.5.1. 
Prove in a regular category with universal coproducts: if X ^^ / and Y >-^ I 
are disjoint {i.e. X AY = ±), then XvY 
= 
X-\-Y. 
4.5.2. 
(From [143]) Show that a map f:R-^Sm 
PER is a cover if and only if 
3eef^yne\S\.f{[e-n]R) 
= [n]s. 
[Notice that such an e need not give us a morphism 5 —)• /?, since we do 
not know that nSm 
=> e • nRe • m.] 
4.5.3. 
The following combined formulation of D and V comes from [211]. Show that 
in a category with finite limits, one has implication in subobject posets and 
right adjoints ]~J to pullback functor w* if and only if: for each u: I ^ J 
and for each pair of subobjects m: X >-^ I and n:Y ^-^ I there is a largest 
subobject k: Z y^ J with u*{k) A m < n. 
4.5.4. 
One can say that the Axiom of Choice (AC) holds in a regular category 
if and only if every cover c: I —> J splits {i.e. has a section s: J —^ I with 
c o s = id). 
(i) 
Check that this formulation in Sets is equivalent to (one of) the usual 
formulations of (AC), 
(ii) Verify that (AC) holds in a regular category if and only if the covers 
are precisely the split epis (see Exercise 4.4.2). 
(iii) Prove that if (AC) holds, then internal and external existence coincide 
in the subobject fibration. This means that for a subobject X ^-> I x J, 
the proposition 
i:I 
\-3j:J.X{i,j):Prop 
holds if and only if there is a map s: I —^ J such that 
i:I hX(i,5(i)):Prop 
holds. 
4.5.5. 
In a first order fibration with exponents in its base category, we say that 
the internal Axiom of Choice (lAC) holds if the following proposition 
holds. 
/: J I "/ is internally surjective" h "/ has a section" 
(i) 
Describe explicitly the predicates "/ is internally surjective" and "/ 
has a section". 

272 
Chapter 4' First order predicate logic 
(ii) Consider a logos IB with exponents. Show that (lAC) holds (in the 
associated subobject fibration) if and only if for each object K the 
exponent functor (—) ^rlB ^ B preserves covers. 
[A proof making use of Kripke-Joyal semantics can be found in [188, 
Chapter VI].] 
4,6 Subset types 
Most of the structure of fibrations that v^e considered so far was structure 
in fibres (like A,V) or between fibres (like U ' D ) - ^^ ^^^ ^^^^ three sections 
we shall study subset types and quotient types. These are new in the sense 
that they involve structure between a total category and a base category of a 
fibration, 
given by adjoints. 
In this section we will give the syntax and categorical semantics of subset 
types (or also called subsets). This involves the operation which maps a propo-
sition [xia 
\- (p: Prop) to a type {x:a\ip}: 
Type. The intended meaning of the 
latter is the subtype of a consisting of those terms M:cr for which 
(f[M/x] 
holds. The categorical description that we give below, will turn out to be a 
special case of a general form of comprehension (see Section 10.4). 
Subset types involve a new type formation rule, namely: 
Each proposition (x: a \- <p: Prop) gives rise to a type {x: cr | ^ } . 
Formally we write this as a rule, 
formation 
x:a 
\- (p: Prop 
h {x:cr| ^}:Type 
It comes with introduction and elimination rules for terms of this newly formed 
type: 
introduction 
x:a\-ip:Prop 
T h M:a 
T \ 
91-(p[M/x] 
r 
\-\{M):{x:a\ip} 
elimination 
T \- N:{x:a\(p} 
T,x:a 
\ e,(p \- ^p 
with 
r h o{N): a 
r , y: {x: a\^}\ 
e[o{y)/x] 
h 
i^[o{y)/x] 
The associated conversions are 
o(i(M)) = M 
and 
\{o{N)) = N. 

Section 4•6' Subset types 
273 
The letters 'i' and 'o' stand for 'in' and 'out'. It is more appropriate to write 
i(^(M) and o^(N) 
with the proposition (p explicit as a subscript, but we often 
find this notation too cumbersome. In mathematical practice these i's and o's 
are usually omitted altogether. 
We say we have full s u b s e t t y p e s if we also have the converse of the last 
rule: 
full s u b s e t t y p e s 
r, y: {x: (T\(p}\ e[o{y)/x] 
h 
i;[o{y)/x] 
T,X:(T\ 
e,(p 
\- ^ 
This is a useful additional rule. Consider for example two propositions 
x\a 
h </?,^:Prop. With this rule we can conclude that {x:o-|<^} is included 
in {x: cr I V^} if and only if </? implies if). In one way this obvious; we give a 
derivation of the other way, to indicate where fullness is used: 
y\{x\a\^] 
\-\^[o^{y)):{x:a\i)] 
y:{x:a\ip] 
| 0 h ^[o^(y)/x] . ^^ 
^ 
• 
(lull subset types) 
X\(T \ (p \- IJJ 
As this example suggests, fullness of subset types corresponds to fullness of 
an associated functor. This will be made explicit in Definition 4.6.1 below. 
Notice that in the above type formation rule, we have a subset type {a:: cr | v?} 
in which x is the only variable which may occur in (p. We could have stated a 
more general formation rule with type context F, 
r , x : cr h (p\ Prop 
r h {x: cr| 9?}: Type 
But that leads to type dependency: one gets a type {a:: cr | (^} which may contain 
variables y. r of types r declared in F. In the present chapter we only consider 
"simple" predicate logic (SPL) over simple type theory, in which we wish to 
exclude this type dependency. We postpone such subset types with contexts 
to what will be called "dependent" predicate logic (DPL) in Section 11.1. But 
we would like to stress here that the extended formation rule is quite natural, 
for example in forming the subset type 
n: N, m: N h m < n: Prop 
n: N h {m: N | m < n}: Type 
of natural numbers less than n. This is clearly a type in which a term variable 
n occurs. One could say this more strongly: the restricted formation rule 
without type context is the more unnatural version. 

274 
Chapter 4- First order predicate logic 
E 
Categorically, a logic is described by a preorder fibration 
-j^P where we 
standardly assume that the base category B has finite products and that the 
fibration p has fibred finite products. Objects / G B are seen as types and 
objects X G E as propositions. One thus expects that subset types involve a 
functor {—}:E ^ B which maps a proposition Y = {j: J \Yj) G E to a type 
{j- J lYj} G B. One further expects there to be a monic 'projection' morphism 
{j:J\Yj}> 
^J 
making {j: J \Yj} a subtype of J. Our use of the word 'projection' here comes 
from the more general treatment of comprehension in Section 10.4. Sometimes 
we call the object (or type) {Y} = {j: J \ Yj} the extent of Y. 
The natural requirement is that an element k: J is in {j: J \Yj} if and only 
if Yk holds. In arrow-theoretic language: 
a morphism u: I —^ J factors through Try: {y} >-^ J 
if and only if 
(*) 
the proposition {i: I h Yu(i): Prop) holds (i.e. T < u*(Y)). 
All this structure comes about by the requirement that the functor { —}:E —> 
B is right adjoint to the terminal object functor T: B -^ E. This is (a preorder 
version of) what is called a D-category in [74, 75]. It is a simplification of 
a structure used by Lawvere to capture comprehension, see Exercise 4.6.7. 
Later in Section 10.4 these notions will be studied more systematically under 
the name 'comprehension category with unit'. 
E 
4.6.1. Definition. A preorder fibration 
^P with terminal object functor 
IB 
T:B ^ E is said to have subsets (or subset types) if this functor T has a 
right adjoint. 
We usually write {—}:E —)• B for such a right adjoint. For X G E, the 
counit SX' T{X} —> X induces a morphism p(ex)'' {X} —> P^ in B. We write 
TTx = p{sx) for this map and call it a (subset) projection. 
The assignment X ^-^ TTX extends to a (faithful) functor E —^ B"^. We say 
that the fibration p has full subset types if this functor 7r(_):E —> B"^ is 
full (and faithful). 
Notice that having subset types is a property of a fibration, because it is 
expressed by an adjunction. Later, in Theorem 4.8.3 we shall see an equivalent 
description of subset types in terms of a right adjoint to an equality functor. 
The next lemma gives several useful results involving subset types. In par-
ticular, in (ii) it is shown that the earlier expected property (*) of subset types 
is captured by the above definition. 

Section 4-6: Subset types 
275 
E 
4.6.2. Lemma. Let 
^P be a preorder fibration with subset types as described 
above. 
(i) Each projection morphism TT^: {X] -^ pX in B is monic. 
(ii) For each map u: I —)• J in M and object y G E over J, there is a 
bijective correspondence 
T < u*(Y) 
over I 
U —> TTy 
m 
This says that u: I ^ J factors through Try if and only i/T < t/*(y) as in (*) 
above. 
(iii) The assignment X i-> TTX extends to a functor P-.E -^ IB"^ which 
maps Cartesian morphisms to pullback squares. This functor restricts fo E -^ 
Sub(B) by (i). 
(iv) The functor V in (iii) preserves all fibred limits. 
Proof, (i) Suppose that parallel maps v^w.K z:^ {X} are given with nx o 
V — TTx o w. The transposes v^,w^:T 
z=^ X then satisfy 
p[v^) — p{ex o T{v)) — TTx o v = TTx ^ w = p{w^). 
But then v^ — w^, because we have a fibred preorder (see Exercise 1.3.11). 
Hence v — w. 
(ii) For a vertical map /: T -> u'^iY) over /, one obtains a map 
u{Y) o /: T —)• y in E over u and, by transposition, a map: 
f ^{u[Y) 
of] o 7)1:1-^{Y} 
i n l . 
This / is a map i/ —>• Try in the slice category B/J, since 
TTy o f 
- 
P[SY O T{U{Y) 
O /} O Trjj) 
= p(w(y) o /) o pisj^j) o Trjj) 
= u. 
Conversely, given v: I -> {¥} satisfying ny o v — u, then by transposition 
one obtains a map T -^ y over u, by an argument as in (i). Thus one gets a 
vertical morphism v:T -^ ^*(^) over /. These operations f ^ f and v ^ v 
are each others inverses. 

276 
Chapter 4' First order predicate logic 
(iii) For a morphism /: X -^ Y in E, there is a commuting diagram in B, 
{X} 
^ - ^ ^ {Y} 
Y 
Y 
TTx 
pX 
pf 
TTy 
pY 
smce 
T^Y o {/} = p{eY o T{/}) = p{f o ex) =pf oTTx. 
In case / is Cartesian in E, this diagram is a pullback in IB: if maps u: I -^ pX 
and v: I -^ {Y} are given with pf o u = Try o v, then i; is a morphism 
{pf o u) ^ TTy in M/pY. Hence one obtains by (ii) a morphism in 
EJ{T, {pfouriY)) S E,(T, u*ipfyiY)) 
=. E/(T, U*{X)J 
because / is Cartesian 
^ M/pX{u, 
TTx). 
This resulting map in M/pX{u, TTX) is the required mediating map. 
(iv) We write V for the functor X i->- TTX , and shall show that V preserves 
fibred finite products (which is of most interest at this stage). 
Since T is a full and faithful functor, the unit rjj: I -^ {T/} is an isomor-
phism. Thus 7r(T/) — id/ in B//, which shows that V preserves fibred terminal 
objects. 
For X, Y over J, we have for an arbitrary map w: / -> J in B, 
M/j{u,V{XxY)) 
^ EI{T, u*{X xY)) 
= 
E / ( T , U*{X) 
XU*{Y)) 
= E / ( T , U*{X)) 
X E / ( T , i/*(y)) 
^ M/pX{u, VX) X MlpX(u, VY). 
D 
It is now easy to see that having (full) subset types in a fibration (as in 
Definition 4.6.1) gives us validity of the rules of (full) subset types as described 
in the beginning of this section: for a term u: I -^ J and a proposition Y = 
{j:J \- yj:Prop) above J, a morphism T < u*{Y) over / induces by (ii) a 
map 
/ 
^ {Y} 
with 
TTy o i(w) = u. 

Section 4-6: Subset types 
277 
This gives validity of the introduction rule. As to elimination, for a term 
v: I ^ 
{Y} we put o(i;) — Try o v: I -^ J. Further, assume we have an 
entailment, 
i:I,j:J\X(i,j)AY{j) 
\-Z{i,j), 
that is, an inequality above I x J, 
X NY' <Z 
where 
Y' = TT'*(Y). 
Then we have to show 
i:I,k:{j:J\Yj]\X(i,o{k)) 
h 
Z(i,o(k)), 
which translates into 
(idx ITY)*(X) 
< (id 
XTTY)*(Z). 
This is equivalent to 
^Y'{X) < T^*Y'(Z) above {Y'}, 
Since both diagrams below are pullbacks. 
I X {7} 
^ 
{Y] 
{7r-(y)} = {Y'] 
{Y] 
id X TTy Y J 
Y 
TTy 
TTy/ YJ 
Try 
/ x J 
^J 
IxJ 
^J 
TT' 
TT' 
The latter in equality 7ry/(X) < 7ry,(Z) follows from X A Y' < Z by applying 
TTy, to X < Z and using T < 7ry/(y'), which is the vertical part of the counit 
eyr.T 
=:T{Y'}-^Y\ 
If we additionally assume that the fibration has full subset types, then the 
corresponding full subset rule is valid. Therefore we have to establish the 
converse 
7T^>(X) <7r^>(Z) ^ 
X/\Y'<Z 
of what we just proved. This is done as follows. 
7ry/(X) <7rl.,{Z) 
^ 
there is a (unique) map 7ry,(X) —->> Z over Try/ 

278 
Chapter 4- First order predicate logic 
=> there is a (unique) map —^ in 
{X} ^ 
< {^hi^)} 
-{Z} 
Y 
L_ Y 
Y 
y 
Y 
I 
IxJ 
^ 
< {¥'} > 
^ 
IxJ 
TTy/ 
TTy/ 
=> Tr^xAY') — TTx A TTy/ < TT^ 
with =. from (iv) in Lemma 4.6.2 
=> X l\Y' <Z 
because the projection functor E -^ IB"*" is full. 
Notice that the square on the left is a pullback because the projection functor 
maps Cartesian morphism to pullback squares (as in (iii) in the lemma). 
Sub(B) 
4.6.3. Examples, (i) Every subobject 
fibration 
4- 
has full subset types. 
The associated functor {—}:Sub(B) -^ B takes a representation (m\X ^-> J) 
of a subobject to its domain X G B. There is an obvious correspondence 
in Su 
-^ X = {m} 
establishing that { —} is right adjoint to the terminal object functor / H^ 
id/. The resulting projection functor Sub(B) —>• B~*" sends a subobject to a 
representative. It is then a full and faithful (fibred) functor. Hence subobject 
fibrations always have full subset types. 
Fam(X) 
(ii) For each poset X with top element T, the family 
fibration 
^ 
comes equipped with a subset functor given by 
{x^)j^j •-> {i G J I x^ = T}. 
It singles out the indices of elements that 'are true'. In general, this does not 
lead to a full functor Fam(X) -^ Sets~^. 
(iii) Consider a predicate logic with (full) subset types, built on top 
£(S,n,-4) 
of a specification (I),n,^). The associated classifying 
fibration 
i 
then has (full) subset types in a categorical sense. One defines a functor 
{-}:i:(E,n,v4) -^ «(E) by {x\(j V ^P: Prop) ^ 
({x:(j| ^}:Type). The re-
quired adjunction T H {—} boils down to a correspondence between terms M 

and A^ in: 
Section 4-^-' Subset types 
279 
M 
{y: r h T : Prop) 
>• {x: a \- (f: Prop) 
;^ {x: a\ (f} 
N 
I.e. between M and N in: 
y.T \- M{y):(T 
with 
y:T \T 
h (p[M/x] 
y:r 
\- N: {x: a\ (p) 
This correspondence is given by 
MH->i(M) 
and 
N^o{N). 
(To make this work, we must have equivalence classes (under conversion) 
of terms as morphisms in the base category Ci{T,). Also we are assuming 
finite products of types here, so that we may restrict ourselves to singleton 
type contexts—which may be identified with types—as object of this base 
category.) 
One gets a functor C(T,,A) 
-^ Ci{T>)^ which maps a proposition {x:a 
h 
ip: Prop) to the term o{z): {z: {x: a \ <^}) —)• [x: cr). It is full if and only if it is 
fibrewise full. The latter means that for a term z\ {x: a\(f} 
\- M\ {y: r \ V^} with 
o^(M) = o^p{z)^ we have an entailment x:a \ (f \- tp (which is a morphism 
over {X:(T). 
Since M = i^(0(^(z)), this follows from an argument as in the 
beginning of this section, using the full subset rule. 
(iv) Next we describe an example of subset types involving 'metric predi-
cates'. It is an adaptation of a construction in [177] (which is based on [194]). 
For a metric space X we conveniently write X for the underlying set and 
X{—,—) 
for the metric involved. That is, for the function X{—,—): X x X -> 
[0, oo] satisfying for x^y.z 
G X ^ 
X{x,y) 
= 0 <:> x = y, 
X(x, y) = X[y, x), 
X(x, y) + X{y, z) < X{x, 
z). 
For convenience we have included oo in the range [0, oo] of the distance func-
tion; one can also take [0,1] C M as range. 
A function f: X -^Y 
between the underlying sets of two such metric spaces 
in called n o n - e x p a n s i v e if Y{f{x),f{x')) 
< X{x,x') 
for all x,x^ G X. We 
write M S for the resulting category of metric spaces and non-expansive func-
tions. 
A m e t r i c p r e d i c a t e on a metric space X is a non-expansive map (p: X 
^ 
[0,oc] where [0,oo] has the obvious metric. One can show that these metric 
predicates on X form a metric space with distance between (p,tp: X =t [0, oo] 

280 
Chapter 4' First order predicate logic 
given by 
sup \<p{x) — i^lx)]. 
xex 
They can be ordered by 
(f Q i^ <^ ^x E X. ip{x) < (p{x). 
Note the inversion. This yields a poset MF{X). One thinks of such a metric 
predicate (p as absolutely true in x if (p{x) = 0 and as almost true in x if (p{x) 
is very small. Thus (p Q ip if and only if ip is everywhere more true than (p. 
The assignment X ^ MF(X) extends to a split indexed category MS^^^ —> 
MP 
Cat by composition; hence to a split fibration, which will be written as Jj . 
It has a terminal object functor T: MS -^ M P which sends a metric space X 
to the top metric predicate 
Tx = 
^xeX.O 
in the poset MP(X) of metric predicates on X. We also have a subset functor 
{ - } : M P - > M S by 
(x - ^ [0, GO] j ^ {x e X \ (p(x) = 0}, 
with metric as in X. 
It singles out the points where the predicate is absolutely true. The adjunction 
(T H {—}) is then easily established. 
One does not get full subset types. 
4.6.4. Remark. Subset types are often used in implicit, hidden form. For 
example, one often conveniently writes 
{i > 0) A ip{i - 1) 
where i ranges over natural numbers N, and ^ is a predicate on N. Formally, 
i:N h 'ip{i): Prop. The proposition tp{i — 1) only makes sense if i > 0 holds, 
so we cannot interpret (i > 0) A xp{i — 1) as a predicate on natural numbers. 
In fact, 'ip'{i) = ip{i — 1) is a predicate on the extent {ic:N|ar > 0} of the 
predicate (f{i) — (i > 0). Then we can correctly write the above conjunction 
as: 
= {i > 0) A 3j: {x:n\x>0}. 
(o(j) =N ^ A ^(o(i) - 1)) 
so that it becomes a predicate on the natural numbers. Of course, this is 
rather cumbersome, especially because it is clear that we should take \{i) as 
instantiation of j . 
Notice, by the way, that by using Frobenius we obtain: (p A JJ^ (V^') = 
LITT (^i^(^) A V^') — U^ (^')- I^ P62] a new connective (p andalso ip' (with its 
own rules) is introduced for 9? A ]J^ (t/^'). 

Section 4-6: Subset types 
281 
We conclude this section with an example of how subset types can be used 
to get a factorisation of maps in base categories of regular fibrations. This 
gives a more abstract description of the factorisation that we have seen for 
regular subobject fibrations in Section 4.4. 
E 
4.6.5. E x a m p l e . Let 
jrP be a regular fibration with subset types. An arbi-
B 
trary map u: I ^ J in the base category B can then be written as composite 
where ]J^ is the left adjoint to the reindexing functor u* associated with u, 
as in Example 4.3.7 (i). And the morphism u' is then obtained from the unit 
of the adjunction (]J^ H w*) at the terminal object T G E/ over /, 
T<«*IJ„(T), 
which yields a map u':u -^ TTJT ^J. in the slice IB/J, by Lemma 4.6.2 (ii). 
Further, this factorisation has the following universal property: for each 
object X G EJ and morphism v: I ^ 
{X} 
in B with u = TTX o v, there is a 
unique map /:!!«("'") ""^ ^ ^^ ^J ^^^^ 
This map / is obtained as follows. By the correspondence in Lemma 4.6.2 (ii), 
the map v, considered as a morphism i/ -^ TT^ in B/J, gives rise to a vertical 
map T -^ w*(-^) pver /, and thus by transposition to the required / : IJ^^(T) —^ 
X over J. Because this / is vertical one gets TTX O {/} = TTTT /yx. Hence 
{/} o u' = V holds because TTX' {X} ^ J is a monomorphism. 
This is precisely the universal property of the image factorisation in Defi-
nition 4.4.2 (i), when considered in the associated subobject 
fibration. 
Exercises 
4.6.1. 
Describe the resulting projection functor Fam(X) -^ Sets"^ in Exam-
ple 4.6.3 (ii) and show that in general it need not be full. Do the same 
in Example 4.6.3 (iv). 
4.6.2. 
(i) 
Check that the category MS in Example 4.6.3 (iv) has finite limits. 

282 
Chapter 4' First order predicate logic 
MP 
(ii) Show that the fibration 4- has simple products and coproducts. 
Fam(X) 
4.6.3. 
Consider the regular family 
fibration 
i 
associated with a (non-
. Sets 
^ 
^ 
trivial) frame X. Prove that the factorisation of a function u: I -^ J as 
in Example 4.6.5 is the usual factorisation of w as a surjection followed by 
an injection. 
4.6.4. 
Show that a projection {X} ^^ / i s an isomorphism if and only if T < X. 
4.6.5. 
Prove that the 'monic part' {]J[^(T} >—> J of K: / -> J in Example 4.6.5 is 
an isomorphism if and only if u is internally surjective. 
4.6.6. 
Show that a fibration with equality and subset types has equalisers "in the 
internal logic": for parallel maps u,v: I ^ J in the base category we have 
a diagram 
TT 
^ 
^ 
{Eq(ii, v)} > 
>• I 
^ J 
with T < Eq(w o ;r, i; o TT). 
V 
And for each w:K —)• / with T < Eq(u o w,v o w) there is a unique 
w: K —)• {Eq(w, v)} with n ow = w. 
Conclude that if internal and external equality coincide, then the base cat-
egory has (ordinary) equalisers. 
E 
4.6.7. 
Let 
-^P be a regular fibration with subset types. 
(i) 
Extend the operation u \-^ LI^,(T) to a functor 5:B"*" -^ E. 
(ii) Show that the projection functor X i-> TTX is right adjoint to this 
functor S. 
[Lawvere [193] originally described comprehension (or subset types) by re-
quiring such a right adjoint to S; the approach above with a right adjoint 
to a terminal object functor is somewhat simpler.] 
E 
4.6.8. 
Let 
^P be a fibration with subset types and let V:1E —^ B~* be the induced 
IB 
projection functor. 
(i) 
Show that V preserves any kind of fibred limit as defined in Exer-
cise 1.8.8. 
(ii) Suppose that p has products Y[,> prove that V preserves these. 
4.7 Quotient types 
In the previous section we have presented subset types via a right adjoint 
to a truth predicate functor. In an almost dual fashion we shall now present 
quotient types via a left adjoint to an equality relation functor. It shows again 
the role played by adjunctions in capturing the essentials of the structures 
used in logic and mathematics. We split the material on quotients in two 
parts: in this section we describe the syntax and use of quotient types in 

Section 4-7: Quotient types 
283 
(simple) predicate logic. And in the next section we present the categorical 
description of quotients, involving an appropriate adjunction. In higher order 
logic quotient types become more powerful and behave better; this will be 
shown later in Section 5.1. For more information on quotient types, see [132, 
135, 133, 21]. 
We start with the syntax of quotient types (also called quotients, for short). 
We assume we are in a predicate logic over simple type theory, with at least 
propositional (or internal) equality M —a M': Prop, for terms M,M' 
of the 
same type a (as in Section 3.2). The following rule tells us how to obtain a 
quotient type. 
formation 
x: (T^y.a h i?(x, y)\ Prop 
h a/R\ Type 
Thus, given a type a with a (binary) relation R on cr, we can form the quotient 
type a/R. 
Notice that we do not require that R is an equivalence relation. 
Set theoretically, one can think of a/R 
as the quotient by the equivalence 
relation generated by R. This can be made more precise in higher order logic, 
see Lemma 5.1.8 (but see also Exercise 4.7.3 below). Associated with the 
formation rule, we have introduction and elimination rules for quotient types. 
introduction 
V\-M:a 
VY-M:a 
V 
\-M'.CT 
with 
r h [M]R: a/R 
r I R{M, M') h [M]R 
=,,R 
{M'\R 
This yields the equivalence class \M\R associated with an inhabitant M of cr. 
Often we write [M] for \M\R if the relation R is understood. The associated 
equality rule tells that if terms are related by R, then their classes are equal. 
We thus get the "canonical" map [—]/?: cr —> a-jR. 
elimination 
Y,X\(JV 
N\T 
r, x\ (T,y\(j\ 
R{x, 
y) 
h N{x) 
=r 
N[y) 
r, a: a/R 
\~ pick x from a in N[x): 
r 
The intuition is as follows: by assumption, the term N{x) is constant on equiv-
alence classes of R. Hence we may define a new term pick x from a in 
N{x), 
which, given a class a: a/R, 
picks an element x from the class a, and uses it 
in N{x). 
The outcome does not depend on which x we pick. Notice that the 
variable x thus becomes bound in the elimination term pick x from a in 
N(x). 
By a-conversion, this term is then the same as pick y from a in 
N{y). 

284 
Chapter 4- First order predicate logic 
The associated conversions are 
(/?) 
pick X from [M]R in N = 
N[M/x] 
[T]) 
pick X from Q in N[[x]R/a] 
= 
N[Q/a]. 
In the (7/)-conversion it is assumed—as usual—that the variable x does not 
occur free in N. In the calculations below, (r/) turns out to be very useful, 
especially in 'expansion' form: from right to left. An alternative formulation 
of (//) involving a commutation rule is presented in Exercise 4.7.1. 
For completeness we should also mention the behaviour of the new terms 
under substitution: 
[M]n[P/z] 
= 
[M[P/Z]]R 
(pick X from Q in N)[P/z] 
= pick x from Q[P/z] in N[P/z]. 
The latter if x does not occur free in P. And also the compatibility rules: 
M = M' => [M]R = 
[M']R 
N = N' and Q = Q' => pick x from Q \n N =z pick x from Q' in N'. 
where in the latter case it is implicitly understood that both N and A''' are 
constant on equivalence classes We recall that in these rules the equality 
symbol = without subscript refers to conversion, whereas =r with subscript 
refers to propositional equality (of type r). 
In the special case where the relation R that we started from is an equiva-
lence relation (provable in the logic), then we can require an additional rule, 
which is a converse of the equation in the introduction rule. This extra rule can 
be described categorically by the requirement that a certain functor associ-
ated with quotients is full (as will be explained in the next section). Therefore, 
it makes sense to speak of full quotients, in case this additional rule is added 
(in analogy with full subset types in the previous section). In category theory 
one usually calls these quotients effective. 
effective or full quotients 
r \- M:a 
r |-M':cr 
(i? is an equivalence relation) 
r|[M]fl=,/fl[M']flhfi(M,M') 
Thus, effectiveness says that inhabitants of a which have the same /i-classes 
must be related by R. 
In the above description of quotients we have restricted the relation R = 
R{x,y) on a in such a way that it contains only the variables x,y:a. 
If we 
drop this restriction, we get a formation rule 
r,x:cr,t/:(T h 
R{x,y):Prop 
r h a/R: Type 

Section 4-7: Quotient types 
285 
involving a context F of term variables. This leads to type dependency: the 
newly formed quotient type a/R may contain term variables z in R declared 
in r. A typical example is the group Zn of integers modulo n, obtained as 
quotient type Z/nZ, for n:N. 
This is very much like what we have seen for subset types in the previous 
section. The natural setting in which to use subset and quotient types is what 
we shall later call "dependent predicate logic" in Section 11.1. But for the 
moment we restrict ourselves to quotient types without type context T in the 
formation rule, so that we remain within simple predicate logic. 
Propositional equality =a is essential in formulating the above rules for quo-
tient types. But the presence of these quotients also has an effect on equality, 
as the following result (from [133, 3.2.7]) shows. 
4.7.1. Lemma. In the presence of quotient types, propositional equality on 
function types is extensional: one can derive 
f:a -^T,g:a 
-^T\ 
VX: cr. fx -^ gx ^ f -a^r 
9-
(The categorical counterpart of this result states that quotients satisfy a 
"Frobenius property" (as in Exercise 4.7.6) if and only if the equality functor 
Eq preserves exponents, see Section 9.2.) 
Proof. Consider the following relation ^ on the arrow type cr —> r, 
f:a 
-^ T^g:a -^ T \- f ^ g — ^x: a. fx —r gx : Prop. 
def 
Form the associated quotient type a ^ r — (cr —> r ) / ~ , with canonical map 
[—]: (cr —> r) ^ (cr => r). There is a term P in the reverse direction, obtained 
via 
x:cr, f:a -^ T h fx: r 
x: a, f: a -^ r, g: a ^ r \ f ^ g \- fx =T gx 
x: a, a: [a => r) h pick / from a in fx: r 
a: (cr => r) h P[a) — \x: a. pick / from a in fx: a —^ r 
Obviously, for /: cr -> r, 
P([f]) = Xx:<T.fx = f, 
by first using (/?) for quotients, and then (rf) for ->. Thus if / ~ ^, then 
[/] =:(j^r [g], and so / =a-^T 9' This completes the proof. Notice by the way, 
that one also has that [-P(a)] = a, so that we have an isomorphism of types 
{a ^T)^{(T^T). 
D 
4.7.2. Notation. Assume we have a relation i? on a type cr, and a relation 
5 on a type r. Then we conveniently write 
pick X, y from a, h in N{x, y) 

286 
Chapter 4' First order predicate logic 
for 
pick X from a in (pick y from h in N[x^ y)) 
whenever the latter expression makes sense. This is the case when we can 
derive the following equations. 
r, x: (7, y, y': r \ S[y, y') h N{x, y) =, N{x, y') 
r, X, x'\ (T,y'.T\ R{x, x') h N{x, y) =p N{x', y). 
Via the first of these equations we can form the term pick y from b in N{x, y). 
By substituting x' for x we also get pick y from 6 in N(x'^ y). We now obtain 
the required multiple pick term via the following derivation. 
r, x, x': (7, t/: r I R[x, x') h N{x, y) ^ , N[x', y) 
V,x,x':(T,h:TlS\R{x,x') 
h 
pick y from 6 in N[x, y) =p pick y from 6 in N{x', y) 
r, a: (T/R^ b: r/S h pick x from a in (pick y from 6 in N{x, y)): p 
The first step follows from Exercise 4.7.5. 
The remainder of this section is devoted to an elementary example of the 
use of quotients in (simple) predicate logic. It involves the construction of the 
integers from the natural numbers, as a free Abelian group. 
4.7.3. Example. Recall that the set of integers Z can be constructed from 
the natural numbers N by considering a pair of natural numbers {n^m) as 
representation for the integer m — n. Then one identifies two pairs (ni, mi) and 
(n2,m2) of naturals if mi—ni = m2 —n2. Or equivalently, if niH-m2 = n2+mi. 
Thus one introduces Z as a quotient of N x N. One can then define addition 
+ :Z X Z —>• Z, zero 0 G Z and minus — :Z —> Z via representatives. For 
example, one takes for a G Z, 
—a = [m,n] 
if 
a = [n,m]. 
This construction of Z form N can be described in a slightly more abstract 
way as the formation of the free Abelian group on a commutative monoid via 
a quotient. Indeed, (Z, 0, +, — (•)) is the free Abelian group on (N, 0, +). 
In our predicate logic over simple type theory we now assume that we have 
a commutative monoid (N, 0, +), consisting of a type N: Type with constants 
0, -h in 
h 0: N 
and 
x:N,y:N 
\- x-\-y:N 
satisfying the commutative monoid equations 
0 + jr =N a^, 
x-^y=^y-\-x, 
x + {y + z) =^ {x-}-y) + z, 

Section J^.l: Quotient types 
287 
for x,y,z:N. 
We think of these as (internal) equalities which come with the 
data type (N, +, 0). One may read N as natural numbers, but all we need are 
these commutative monoid equations. 
We then consider the relation ~ on N x N, 
t / : N x N , i ; : N x N \- u ^ v := {TTU + TT'V =|\| TT'U + nv): 
Prop 
which corresponds to the identification of pairs ( n i , m i ) , (n2,m2) via rii + 
1712 = 7^2 H- mi above. We write 
Z = (N X N ) / - 
and 
[x,y] for [{x,y)] 
in 
N x^ 
^ Z. 
Of course we think of Z as the type of integers. 
The next step is to provide Z with an Abelian group structure 0, + and 
inverse —. This is done, as in the set-theoretic construction, via representa-
tives. And the syntax we have allows us to reason conveniently with these 
representatives inside pick . . . terms. 
The neutral element is easily obtained as 
0 t^ [0,0]:Z. 
The inverse operation — (•) is 
—a — pick w from a in [K'W^ -KW] : Z, 
which is very much like the set-theoretic minus — (•) mentioned above. Notice 
that this term is well-defined because from u ^ v one derives {n'u,7vu) 
~ 
{TT'V, TTV). 
Finally, addition -h on Z is then 
a-\-b 
= pick w, V from a, 6 in [TTU -f- wv, TT'U -\- -n'v] 
= 
pick u from a in (pick v from b in [TTU -\- TTV, TT'U -{- TT'V]). 
This operation is well-defined, since we can derive 
wi, ^2- N X N,t;: N X N I wi ^ 1/2 ^ 
(TTI/I -h TTt;, n'ui 
-\- TT'V) ^ (7ri/2 + TTV, 7T'U2 + TT'V) 
w: N X N,i'i,i;2: N x N | i;i ~ 1^2 h 
{TTU -h TTVi, TT'U 4- 7r'i;i) ^ {TTU -f TTVO^ n'u -{• 'K'V2)-

288 
Chapter 4- First order predicate logic 
Then 0 is neutral element, since we can compute: 
a -h 0 = pick u from a in (pick v from [0, 0] in [TTI/ + i^v, -K'U + TT'I;]) 
— pick u from a in [TTW -I- 0, TT'W + 0] 
= pick u from a in [TTW, TT'W] 
= pick u from a in [w] 
= 
a. 
We leave it to the reader to verify that (Z, +, 0, —) is an Abelian group. There-
fore one needs the conversions in Exercises 4.7.1 and 4.7.4 below. We do show 
that Z has the appropriate universal property making it the free Abelian group 
on N. First, we have an extension map c: N -^ Z by c[x) — [0,2^]. This is a 
monoid homomorphism, since by definition c(0) = [0, 0] = 0, and 
c(x) -h c[y) — pick w, v from [0, x\, [0, y] in [KU + nv, n'u + n'v] 
= 
c{x-\-y). 
Further, if we are given an arbitrary Abelian group (G, •, 1, (•)~^) together 
with a monoid homomorphism M:H 
-
phism M:Z ^ G with M o c = M in, 
G, then there is a unique homomor-
Therefore, write 
N{u) 
^ M{'K'U) 
• M(7rw)-^ : G, 
for w : N x N 
To see that the term 
M[a) 
— pick u from a in N{u): 
G, 
for a : Z 
is well-defined we need to derive 
w , i ; : N x N | w ^ t ; h N{u) -Q 
N{V) 
But this follows because G is an Abelian group: if u ^ v, then by definition 
TTu + Tv'v =|sj TT'U + TTv. Heuce M{7ru) • M(7r'v) =G M(7ru -\- TT'V) —Q M['K'U -|-
TTv) =G M{7r^u) • M{7rv), and so N{u) —Q M{'K'U) 
• M(7rw)"^ =G M{'K'V) 
• 

Section J^.l: Quotient types 
289 
M{7rv)~^ -G N{v). Then indeed, 
(M o c){x) 
— 
pick u from [0,x] in N{u) 
= 
N({0,x)) 
= 
M(x)»M{0)-^ 
=G M ( x ) » l - i 
=G 
M{x). 
We leave it to the reader to verify that M is a homomorphism. And if another 
term (-homomorphism) P:Z -^ G satisfies P{c{x)) 
—G M{X), then N{u) 
= 
M{7^'u)^M{7^u)-'^ 
=G P{c{7^'u))^P{c{7Tu))-^ 
=G P ( [ 0 , 7r'w])*P(-[0, TTU]) = G 
P([0, TT'U] + [TTU, 0]) =G ^([TTt/, TT'W]) = G ^ ( M ) - Hence 
M{a) = pick 1/ from a in A''(?i) = pick u from a in P ( M ) = -P(a). 
This concludes the example. 
The first two of the exercises below give conversions which are quite useful 
in computations with quotient types. 
Exercises 
4.7.1. 
Prove that in the presence of (/3)-conversion for quotients, the (r7)-con-
version is equivalent to the combination of 
P[(pick X from Q in N)/z] 
= pick x from Q in P[N/z] 
pick X from Q in [X]R = Q. 
The first of these is a 'commutation' conversion, and is comparable to the 
conversion in Lemma 2.3.3 for coproduct types +. 
4.7.2. 
Prove that the term 
x:a \- [x]=^:a/=o-
is invertible. 
4.7.3. 
(i) 
Let R, S be two relations on the same type a. Show how an entailment 
a:, x': a \ R{x, x') h S(x, x') gives rise to a term a: a/R h M(a): 
a/S. 
(ii) For a relations R on a, define the reflexive and symmetric closure of R 
as two relations on cr given (respectively) by 
R^{x, x') =^ R{x, x') V (x =a x'), 
R^{x, x') =^ R{x, x') V R{x\ x). 
Show that taking S = R^ and S = R^ in (i) leads in both cases to 
invertible terms. 
4.7.4. 
Prove the following derived conversions. 
(i) 
In case a term T \- N:T that we apply elimination to, does not contain 
a variable x of type cr, then we get in context T,a: cr/R a conversion, 
pick X from a \n N = N. 

290 
Chapter 4- First order predicate logic 
(ii) And in case we have two variables F, x,y: a h N{x, y): r and equalities 
r, x: (T, y, y': a \ R{y, y') h N{x, y) =r N{x, y') 
r, X, x': (T, y: <T I R{x, x) h N{x, y) =r N{x\ y) 
then in context F, a: alR we have a conversion, 
pick a7,y from a,a in A'^(i:,y) = pick a: from a in A/^(a:,i:). 
4.7.5. 
Derive the following replacement rule for internal equality = T . 
T,x:(T\e\- 
N 
=rN' 
{x not in 0) 
F, a: (TIR \ 0 h (pick x from a in N) =T (pick a; from a in A/^') 
where both A^ and N' are assumed to be constant on equivalence classes. 
It is used to justify the multiple pick's in Notation 4.7.2. 
4.7.6. 
Let types a, p and a relation x^y-.o- h R{x^ y): Prop be given. Form a new 
relation p*{R) on p x (T by 
u: p X a^v: p X a h p*{R)(u, v) = {TTU =p nv) A R{n'u, n'v): Prop. 
Prove that the canonical map 
(p X <T)/P'{R) 
^ p X 
(a/R) 
given by 
a: {p X a)/p*{R) 
h P{a) = pick u from a in (TTW, [;r'^i]i^): p x 
{(T/R) 
is invertible. 
[This is shows that a "Frobenius distributivity" for quotient types is inher-
ent in the syntax that we use (with explicitly contexts F in the elimination 
rule). It is like for other 'colimits' such as -|- and 3.] 
4.7.7. 
Consider a predicate logic with a commutative monoid N of natural numbers 
as in Example 4.7.3, and with Z as the Abelian group of integers constructed 
from N, as in the example. 
(i) 
Give a formal description of the construction of the rationals Q as 
quotient of Z X N, where the pair (n,m) represents the rational :^^^' 
(ii) Assume now that one also has exponent types -> and subset types. Try 
to formalise the construction of the Cauchy reals (see for Example [335, 
Chapter V]). 
4,8 Quotient types, categorically 
In this section v^e describe quotient types (in simple predicate logic) in cate-
gorical terms. These quotients, like subsets, involve an adjunction between a 
base category and a total category of a fibration. But w^here subsets involve a 

Section 4-^: Quotient types, categorically 
291 
right adjoint to a truth predicate functor, quotients involve a left adjoint to 
an equality (relation) functor. Interestingly, it turns out that subsets can also 
be described in terms of a right adjoint to this equality functor. 
E 
We recall from Definition 3.5.1 that an Eq-fibration 
j^P is a fibred pre-
order which has fibred finite products and finite products in its base category, 
and also has equality satisfying the Frobenius property. Below we describe 
quotients only for such preordered fibrations, but the main definition 4.8.1 
applies to non-preordered fibrations as well. We shall write Eq/ for the left 
adjoint of the diagonal S{I) — (id, id): / -^ / x / in B. 
E 
Rel(E) 
For such a fibration j^P we form the 
fibration 
4- 
of binary predicates 
IB 
B 
(or relations) in p by the following change-of-base situation. 
Rel(E) 
^ E 
J 
ly^ 
I X I 
A fibre Rel(E)/ is then the same as the fibre E/x/ of relations on / G B. Note 
however, that in the notation Rel(E) the dependence on the fibration p is left 
implicit. 
There is then an "equality relation" functor 
Eq 
B 
^Rel(E) 
by 
/ I 
^ Eq(/) = Eq/(T), 
where T = T(/) is the terminal object in the fibre E/. A morphism u: I -^ J 
in B is mapped to the composite 
Eq(/) = Eq,(T(/)) 
(u X ur(Eqj(T(J))) 
Eqj(T(J)) = Eq(J) 
where the first part of this map is obtained by transposing the following 
composite across the adjunction Eq/ -\ S{I)*. 
T(/) ^ i/*(T(J)) " ^ - ^ u^5{jyEqj{T{J)) 
^ S{iy{u 
x i/)*Eqj(T(J)) 
It may be clear that the functor Eq is a section of the fibration of relations. 
For a morphism u: I ^ J we write 
Kev{u) =^ {u X t/)*(Eq(J)) G Rel(E)/x/ 
for the kernel relation u{i) = u{i^) on / x /. This operation u H^ Ker(ii) can 

292 
Chapter 4' First order predicate logic 
be extended to a functor W^ -^ Rel(E) commuting with the domain functor 
(or fibration) dom:E~^ -^ B, see Exercise 4.8.8. 
We can now state our main notion (in this section). 
E 
4.8.1. Definition. Let 
iP be a fibration as above. We say that p has quo-
IB 
tients or quotient types if the equality functor Eq: B -^ Rel(E) has a left 
adjoint. 
This left adjoint maps a binary relation R G Rel(E)/ = E/x/ to the quotient 
object I/R G B. The unit TJR is a map R -^ Eq{I/R) in Rel(E). Its underlying 
map in B will be written as CR: I -^ I/R. It is the "canonical quotient map" 
associated with the quotient. 
The next result is the analogue for quotients of Lemma 4.6.2 for subset 
types. 
E 
4.8.2. Lemma. Consider a fibration jrP with quotients, as above. 
(i) The canonical maps CR: I ^ I/R are epis in the base category. 
(ii) For each morphism u: I -^ J in M and for each relation i? G E/x/ on 
I, there is a bijective correspondence 
R < Ker(w) 
m Rel(E)/ 
CR —-^ u 
m 
where /\B is the 'opslice' category of maps with domain I and commuting 
triangles. 
(iii) The assignment R\-^ CR extends to a '^canonical quotient map" functor 
C in 
C 
Rel(E) 
^ B-' 
X 
>^dom 
B 
which maps 'opcartesian' morphisms in Rel(E) to pushout squares in B. 
(An 'opcartesian' map is for an 'opfibration' what a Cartesian map is for a 
fibration, as we shall see in Section 9.1. In this situation a morphism f: R -^ S 
in Rel(E) over w: / -> J is opcartesian if and only if 5 < 
Yluxui^)-) 
Proof, (i) Consider a situation 

Section 4-^' Quotient types, categorically 
293 
where u o CR = v o CR = w. The transposes u^ — Eq(t/) o rfR and v^ — 
Eq(t;) o r]R are maps R =t Eq(J) which are both above u o CR — v o CR. 
Rel(E) 
^ 
E 
But then u^ = v^, because 
i 
, like ^ , is a preordered fibration (see 
Exercise 1.3.11). Hence u — v. 
(ii) Assume we have an inequality R < Ker(i/) = [u x u)*{Eq{J)) 
over 
/. There is then a unique map f:R -^ Eq(J) in Rel(E) over u: I -^ J . By 
transposing it we get a morphism / ^ : I/R -^ J in B, satisfying f^ o CR — u. 
Conversely, assume we have a morphism v: I/R -> J in B with v o CR = u. 
The transpose v"^: R -^ Eq(J) is then above t/, by an argument as in (i). This 
yields the required inequality R < Ker(i/) = (w x u)*{Eq{J)) 
over / . 
(iii) For a morphism / : / ? - > 5 in Rel(E) over u: I ^ J we have to find a 
map I/R —^ J/S in a commuting square, 
I/R 
^ J/S 
CR 
'cs 
-^ J 
This requires a map CR —> (cs o u) in the opslice / \ B . By combining the 
inequality R < {u x w)*(5) with S < {cs x C5)*(Eq(J/5) we obtain the 
following inequality. 
R < 
(uxuYiS) 
< {uxuYics 
xc5)*(Eq(J/5) 
^ 
{{csou)x{csou)y{Eq{J/S) 
= Ker(c5 o u). 
Then we get the required map by (ii). 
If our map f : R ^ S i s 
opcartesian over u—i.e. if 5 < Uuxu(^)—^^^^ 
the above square becomes a pushout in B: assume maps v: I/R -^ K and 
w: J ^ K in B with v o CR = w o u. Then ^' is a morphism CR -^ (w o u) in 
This yields R < Ker(it; o w), by (ii). Now 
S < Uuxui^) 
because / is opcartesian 
< U^><y(w X u)*{w X wy{Eq{K)) 
because R < Ker(it; o u) 
< (wxwr(Eq{K)) 
b y l J . x . ^ ( ^ x ^ ) * 
= Ker(ti;). 
Hence we get the required mediating map cs —^ w in J \ B by (ii). 
• 
Notice that the canonical maps {X} >-^ I for subset types are monos, 
whereas the canonical maps / -^ I/R for quotient types are epis. But there 

294 
Chapter 4' First order predicate logic 
is a deeper duality between subset types and quotient types, as we will show 
next. Recall that we have introduced subset types via a right adjoint to truth, 
and quotient types via a left adjoint to equality. It turns out that subset types 
can equivalently be described by a right adjoint to equality. 
E 
4.8.3. Theorem. Let 
jrP be an Eq-fibration. The induced equality functor 
Eq:B -4- Rel(E) then has a right adjoint if and only if p admits subset types. 
This result, and its proof below, also hold for non-preordered fibrations. 
Proof. Assume the fibration p has subset types, via a right adjoint { —}: E -^ 
B to the truth predicate functor T. For a relation R ElEjxi on I we have the 
following (natural) isomorphisms. 
Rel(E)(Eq(J), fi) = 
U 
Ejxj(Eq(J), (i/x w)*(i^)), see Lemma 1.4.10 
u:J^I 
= 
I I 
E J ( T ( J ) , 
S*{uxuy{R)) 
U.J-^I 
- 
U 
E J ( T ( J ) , u^S^iR)) 
^ 
E ( T ( J ) , J*(i?)) 
- 
B ( J , 
{6^[R)]). 
Hence R ^ {8*{R)] is right adjoint to Eq:B ^ Rel(E). 
Conversely, assume that the equality functor Eq has a right adjoint 
/\:Rel(E) -^ B. For an object X G E over / G B, put {X] = /i(7r*(X)), 
where TT is the first projection I x I -^ I. Then X i-> {X} is right adjoint to 
truth T: 
E ( T ( J ) , X) ^ 
I I 
E J ( T ( J ) , w*(X)), 
by Lemmal.4.10 
^ 
I I 
E J ( T ( J ) , u*S'7r*{X)) 
u.J-^I 
^ 
] J 
E J ( T ( J ) , (J-(«x«r;r*(X)) 
^ 
] J Ejxj(Eq(J), («x«)-7r*(X)) 
K.J—f/ 
S Rel(E)(Eq(J), 7r*(X)) 
^ l ( j , A'U*(X))) 
= B ( J , 
{X}). 
a 

Section 4-^- Quotient types, categorically 
295 
We consider the following two additional requirements for quotients in a 
fibration. 
E 
4.8.4. Definition. Let 
^P be a fibration with quotients as above. 
m> 
(i) We say that the quotients satisfy the Frobenius property in case the 
following holds. If for a relation R on I and an object J G B we form the 
relation 
r{R) 
=^ (TT X 7r)*(Eq(J)) x (TT' X TT')* {R) 
on J X / 
then the canonical map 
(J X I)/r{R) 
^ J X 
{I/R) 
is an isomorphism. 
(ii) And if p is a preorder fibration, then we say that quotients are efi'ective 
or full if for each equivalence relation R on I (in the logic of the fibration p), 
the unit map rjR: R ^ Eq{I/R) 
is Cartesian over CR: I ^^ I/R 
in the 
fibration 
Rel(E) 
i 
of relations. 
The canonical map in (i) is obtained by transposing the following composite 
r{R) 
zr: (TT X 7r)*(Eq(J)) X (TT' X 7r'y(R) 
id X (TT' X 7r'y{T]) 
(TT X 7r)*(Eq(J)) x (TT' X 7v'y{Eq{I/R)) 
^ Eq(J x 
{I/R)) 
accross the quotient-adjunction. The latter isomorphism comes from the fact 
that Eq is a right adjoint and must thus preserve products. In the total cat-
egory Rel(E) these products are given by the formula on the left of =, as we 
shall see in more detail in Section 9.2. 
We briefly discuss the interpretation of the quotient type syntax from the 
E 
previous section in a fibration -j^P with quotients satisfying the Frobenius 
property. The latter is used—as always—to get an appropriate elimination 
rule with contexts. 
A relation i^ on a type / G B is an object /? G E/x/ — Rel(E)/. We can form 
the associated quotient type I/R 
G IB with its canonical map CR = [—]R: I -^ 
I/R 
satisfying R < {CR X CR)*{Eq(I/R)). 
This gives us for each i: I a class 
[i]R:I/R, 
together with an entailment i,i':I 
\ R[i,i') 
h [i]R —I/R [i']R' This 
yields validity of the formation and introduction rules. 
For the elimination rule, assume we have a term, 
u 
j : J, i: I h i/(j, i): K 
as a map in B 
J x I 
>• K, 

296 
Chapter 4- First order predicate logic 
which is constant on elements related by R: 
j : J, i, i': I \ R{i, i') h u{j, i) -K u{j, i'). 
The latter yields an entailment 
i , / : J,i,i':/ I J*(/?)((i,f),(/,0) h u[j,i) ^K 
u{j\i'), 
since J*{R)((j, i), (/, i')) = U ^J f) ^ R{h i')- We thus get a map J*{R) -> 
Eq(A') in Rel(E) over u. Transposition across the quotient adjunction yields 
a map (J x I)/J*{R) 
-> K, and so by Frobenius we get our required map 
J X (I/R) ^ ^ 
(J X I)/r{R) 
^ A^ 
which may be read as 
j : J, a: I/R h pick i from a in u(j, i): K. 
We leave validity of the quotient conversions as exercise to the reader. 
What are traditionally called 'effective' quotients in category theory may 
also be called 'full' quotients, because of the following result, and because of 
the analogy with 'full' subset types. 
E 
4.8.5. Proposition. Let 
j ^ he a (preorder) fibration with quotients. We 
write ERel(E) M- Rel(E) for the full subcategory of equivalence relations (in 
the logic ofp). The quotients in p are then effective (or full) if and only if the 
'^canonical quotient map'' functor C: ERel(E) -> B"*" is full (and faithful). 
Proof. Assume quotients in p are effective, and consider a commuting square 
in B of the form: 
CiR) = CR\ 
\cs=CiS) 
where R, S are equivalence relations. We must show R < {u x w)*(5) to get 
fullness of C. This is done as follows. 
R ^ 
[CR X CRyEq{I/R) 
by effectiveness 
< {CR X cnYiv 
xvYEqiJ/S) 
^ {uxuYics 
xc5)*Eq(J/5) 
= [u X u)*{S) 
by effectiveness again. 
Conversely, we need to show that a unit map rjs: S -^ Eq( J/5) is Cartesian 
in Rel(E), for S E Ejxj an equivalence relation. That is, we need to show 

Section 4-^- Quotient types, categorically 
297 
that Ker(c5) = [cs x cs)*Eq{J/S) 
< S. Since Ker(c5) is (also) an equivalence 
relation, it suffices by fullness of the functor C to produce a map CKer(cs) ~^ <^s 
in J\IB. But this follows from Ker(c5) < Ker(c5), using Lemma 4.8.2 (ii). 
• 
We continue this section with several examples of fibrations with quotients, 
starting with subobject 
fibrations. 
4.8.6. Proposition. Consider a category IB with finite limits. 
Sub(l) 
(i) / / B has coequalisers, then the subobject 
fibration 
i 
onM has quo-
IB 
tients. 
These are effective if and only if each equivalence relation R >-^ I x I 
in B is effective, i.e. is a kernel pair R'=X I of some map I -^ J in B. 
(ii) In case B is a regular category the converse 
of (i) also holds: B has 
Sub(l) 
coequalisers if and only if 
i 
has 
quotients. 
(iii) And in the situation 
of (ii), the coequalisers 
in B are preserved 
by 
functors 
J x (—):B -> B i/ and only if the Frobenius property holds for the 
Sub(]B) 
quotients 
in 
I 
A regular category with coequalisers, as in (ii), is often called an exact 
category, see e.g. [36, II, 2.6]. 
Proof, (i) Assume B has coequalisers. For a relation (ro, ri): /? ^^ / x I on 
/, we find a quotient object I/R 
by forming the coequaliser 
R ^ ^ ^ / — ^ 
I/R 
This assignment R M- I/R 
yields a left adjoint to the equality functor since 
there is a bijective correspondence between morphisms u and v in: 
(^o,ri)j 
R 
^ J 
I* 
U X U 
^ 
I X I 
>- J X J 
I/R 
^ J 
' 
v 
In case R is an equivalence relation, then its quotient is effective—according 

298 
Chapter 4' First order predicate logic 
to Definition 4.8.4 (ii)—if and only if there is a pullback diagram 
R — 
YJ 
(^o,n) 
Y 
Ix I -
CR X CR 
I/R 
Y 
s 
I 
{I/R) X (I/R) 
This diagram expresses that R is the kernel of its own coequaliser CR. But 
that is equivalent so saying that R is the coequaliser of some map / —> J in 
B. 
(ii) If B is a regular category then quotients for the subobject fibration on 
B induce coequalisers in B. Given a parallel pair of maps u,v: K z=t I inM, we 
first factorise 
[K 
^ I X I) = [K 
and then take the quotient of the relation R 
CR 
->R> 
^ I X I) 
>-^ I X L 
^ I/R 
The unit map TJR: R —^ Eq(I/R) 
consists of a square 
R 
Y 
(^o,n> 
Ix I 
-^ 
I/R 
Y 
& 
CR X CR 
{I/R) X (I/R) 
This gives us CR o ro = CR o ri, and thus CR o u — CR o v. If also w: I -^ J 
satisfies w o u = w o v, then, because e is an epi, we get w o ro = w o ri. The 
latter tells us that we have a map R —^ Eq(J) in the category of relations over 
w: I —^ J. By transposition we then get the required mediating map I/R -> J. 
This shows that CR is the coequaliser of u,v inM. 
(iii) The main point is that for a relation (ro, ri): R ^^ I x I on I and an 
object J G B the relation J*{R) on J x / in Definition 4.8.4 (i) is the subobject 
(J X ro, J X ri) 
J xR > 
>- (J X /) X (J X /) 
Thus, assuming that B has coequalisers that are preserved by functors J x 
(—), we obtain: if CR: I —> I/R is the quotient of R—i.e. the coequaliser of 
To, ri: i? =4 /—then J x CR is the coequaliser oi J x ro, J x ri: J x R zzt J x I. 
Thus we get (J x I)/r{R) 
-^ 
J x 
(I/R). 

Section 4-^: Quotient types, categorically 
299 
Conversely, if the quotients in the subobject fibration satisfy Frobenius, then 
coequalisers in M are preserved by functors J x (—). This is because the above 
factorisation of the tuple {u, v) in (ii) yields a factorisation of {J x u, J x v), 
Jxe 
( J x r o , J x r i ) 
J X K 
>J X R > 
^ [J X I) X {J X I) 
In this diagram J x e is still a cover because covers are stable under pullback, 
and the relation J x R is J* (R). This shows that as coequaliser of J x u and 
J X V one can take the quotient J x CR\ J x I -^ J x {I/R) of J*(R). Thus 
J X (—) preserves coequalisers. 
• 
In the next series of examples it will be shown that family fibrations (for 
a poset) always have quotients, that the classifying fibration of a predicate 
logic with quotient types has quotients in the categorical sense, and that a 
fibration of "admissible" subsets of complete lattices also has quotients. The 
latter order theoretic construction follows [174, Chapter I]. 
4.8.7. Examples, (i) Recall from Example 3.4.4 (iii) that if X is a poset 
Fam(X) 
with bottom A. and top T elements, then the family fibration 
i 
has 
.
.
. 
Sets 
equality. For a family x — {'^{ij)){i,j)eixJ 
over / x J, it is given by 
M-hjj') = { l^^'^"^ I 
otherwise. 
Then for a function u: I ^ J, the kernel relation Ker(w) on / is given by 
T ifu{i) 
^u{i') 
/ T \fu{i) - u{ 
Ker(t.)(,,.) = I ^ otherwise. 
For a relation r = (^(j ,/))f^i/^/ on / in the family fibration on X, consider the 
set theoretic relation R = {(i, i') \ r(^i^i/^ ^ L} C I x I. Let R C I x I he the 
least equivalence relation containing R. Then we get a quotient I/r — I/R 
in Sets, which serves as quotient in the fibred sense. It comes with canonical 
map Cr — [—]'-1 —^ I/R. The adjunction boils down to r < Ker(i/) <^ Cy 
factors through w, as in Lemma 4.8.2 (ii). 
(ii) We can form a classifying fibration of a (simple) predicate logic with 
quotient types using the fibration 
I 
associated with the logic on the 
signature with predicates (S],n) (plus axioms A) as described in Section 3.1. 
We can then form the category Rel(>C(E, H,^)) of relations in this logic via 
the change of base situation preceding Definition 4.8.1. This category has 
relations {x^x'-.a h R{x,x'):Prop) 
as objects. And a morphism [x^x'\a 
h 

300 
Chapter 4' First order predicate logic 
R{x,x^):Prop) 
-^ {y,y''.T 
h S{y,y'): 
Prop) in R e l ( £ ( E , n , ^ ) ) is a morphism 
M : cr ^ r in the base category (X(E) for which one can derive 
x,x':a\ 
R{x,x') 
h 
S{M{x),M{x')), 
The equality relation functor Eq:C^(E) —> Rel(£(E,n,>l)) is then given by 
the assignment r \-^ [y^y'\T 
\- y —r y'\ Prop). 
Quotient types as described in the previous section determine a left adjoint 
to this functor Eq. It maps a relation [x.x'-.a 
h R{x^ x'): Type) to the quotient 
object a/R 
in the base category (X(E). The adjunction involves a bijective 
correspondence between (equivalence classes of) terms M and N in: 
M 
{x,x':a 
h R{x,x')\?xop) 
^ (y,y''T 
\- y =r 2/': Prop) 
a/R 
^T 
N 
That is, between terms M and N in: 
x:a 
\- M:T 
with / x, x'\ a \ R(x, x') h M[x) 
-j 
M{x') 
V.(TIR 
h 
N:T 
This correspondence is precisely given by 
M{x) H-> pick X from a in M{x) 
and 
^ ( « ) ^-> ^ [ W i ? / a ] . 
The (/?)- and (77)-conversions precisely state that these operations are each 
others inverses. And Exercise 4.7.6 tells that the Frobenius property auto-
matically holds. Thus the quotient types in the logic induce quotients for the 
fibration 
associated with the logic. 
(iii) Let CL be the category of complete lattices (posets with joins of all 
subsets) and with functions preserving all these joins between them. It is 
well-known that requiring the existence of joins of all subsets is equivalent to 
requiring the existence of meets of all supsets. A morphism f:X 
-^Y 
in CL 
always has a right adjoint f^:Y 
-^ X (between poset categories), given as 
f*{y) 
= V { ^ ^ ^ 
I / ( ^ ) < 2/}- I^ is easy to see that (g o f)^ = f* o g^ and 
that (/*)* = / . (Using these right adjoints one can show that CL is a self-dual 
category.) The category CL has finite products in the obvious manner: one 
uses finite products of the underlying sets, with componentwise ordering. 
Let us a call a subset A C X oi a, complete lattice X a d m i s s i b l e if A is 
closed under (all) joins in X. Such subsets can be organised in a 
fibration 
ASub(CL) 
i 
in which the total category ASub(CL) has such admissible subsets 
{A C X) as objects. A morphism {A C X) -^ {B C Y) in ASub(CL) is then a 
morphism f:X-^Yin 
CL between the underlying carrier sets which satisfies: 

Section 4-^' Quotient types, categorically 
301 
X £ A^ 
f{x) £ B^ior a\\ X £ X. This fibration has a terminal object functor 
T: CL —> ASub(CL) sending a complete lattice X to the admissible subset 
{X C X). It has (full) subsets, via a functor {-}: ASub(CL) -> CL which 
maps an admissible subset {A C X) to A, considered as a complete lattice in 
itself. Our aim is to show that this fibration also has quotients. 
ARel(CL) 
We therefore first consider the 
fibration 
i 
of admissible relations, 
CL 
' 
obtained by change-of-base along X y-^ X x X (as described in the beginning 
of this section). There is an equality functor Eq: CL -^ ARel(CL), mapping 
a complete lattice Y to the admissible subset {{{y,y) \ y E Y} C Y x Y). 
So far, these constructions are all straightforward. The quotient adjoint (to 
equality) is less standard. It maps an admissible subset {R C X x X) to the 
complete lattice 
X/R 
={xeX 
\ V(2/, y')eR.y<x 
iff y' 
<x]. 
It is easy to see that X/R^ with order as on X, is closed under all meets. 
Therefore it is a complete lattice. The inclusion function i: X/R -^ X has a 
left adjoint CR:X -^ X/R, given by 
CR{X) = 
/\{zeX/R\x<z}. 
Since CR is a left adjoint, it preserve joins and is a morphism X —> X/R in 
CL (with {CR)^ = i). Obviously, R[x,x') 
=> CR[X) — CR[X'), 
SO that CR is a 
map of relations R -^ Eq(X/i?). The quotient adjunction requires a bijective 
correspondence between morphisms / and g in: 
{RCX 
xX) 
^ Eq(y) 
in ARel(CL) 
X/R 
^ y 
in CL 
9 
For f:[R<ZXxX)^ 
Eq(y) one takes J = f o i: X/R -^ Y. And conversely, 
given g:X/R 
^ y, one takes 'g = g o CR: {R C X x X) -^ Eq(y). Then it 
is easy to see that 'g — gocRoi 
— g, because CR o i — id. But showing 
that f — f o i o CR — f IS harder. First we notice that fi,[y) is in 
X/R, 
for y EY. 
Indeed, for a pair {x,x') 
E: R we have f{x) — f[x'), 
and thus 
^ < f*{y) ^ 
/(^) < y "^ /(^') < y O ^' < f*{y)' 
But this means that 
^(c/i(/•(!/))) = f*{y)' Then we are done, since 
/ = (/*)* = (i O CRO / * ) * = (/*)* O {CR)^ o U - f o i o 
CR. 
This completes the example. 
In Example 4.6.5 we have seen how subset types give rise to a certain 
factorisation of maps in the base category. One also gets a factorisation from 

302 
Chapter 4- First order predicate logic 
quotients, as we will show next. In higher order logic this factorisation has a 
slightly different universal property, see Example 5.1.9 (i) and Exercise 5.1.6. 
E 
4.8.8. Example. Assume 
^P is a fibration with quotients. For a morphism 
JB 
u: I -^ J in the base category B we can form the kernel relation Kev{u) 
= 
{u X w)*(Eq(J)) on /, and its quotient //Ker(w) G B. It gives a factorisation, 
( / 
^ J) = [I 
>^ //Ker(ti) 
^ j ) 
where the map w':cKer(u) —^ ^ in the opslice category / \ B comes by 
Lemma 4.8.2 (ii) from the inequality Ker(w) < Ker(w). 
This factorisation is universal in the following sense. Given an arbitrary 
relation i^ G E/x/ on 7 and a morphism v: I/R 
-^ J in B with v o CR = u, 
there is a unique map of relations / : R —> Ker(i/) over / such that 
This mediating map arises as follows. The morphism v: CR -^ u in the opslice 
/ \ B gives rise to an inequality f:R< 
Ker(w) over /. By applying the quotient 
functor we get a morphism / / / : I/R 
-> //Ker(w) in B which commutes with 
the quotient maps. Finally, u' o / / / = v holds because CR is an epi. 
Exercises 
4.8.1. 
Assume a fibration with quotients. Prove that for a relation R on I, the 
canonical map OR: I -^ I/R is an isomorphism if and only if R < Eq(/) 
over /. (A special case is / ^ //Eq(/), see Exercise 4.7.2.) 
4.8.2. 
Prove that the 'epic part' CKer(u)'7 —» //Ker(?i) of it: / ^ 
J in Exam-
ple 4.8.8 is an isomorphism if and only if u is internally injective. 
4.8.3. 
Check that quotients in a predicate logic are effective if and only if the 
quotients in the associated fibration—as in Example 4.8.7 (ii)—are effective 
in the categorical sense. Describe fullness of the canonical map functor in 
Definition 4.8.5 type theoretically. 
[Hint. Remember Exercise 3.1.1.] 
4.8.4. 
Show that a relation R >-^ 7 x / is the kernel pair /? =4 7 of its own 
coequaliser if and only if it is the kernel of some map 7 -> J. 

Section 4-9' Quotient types, categorically 
303 
E 
4.8.5. 
Let 
j^P be a regular fibration with quotients. For parallel maps w, v: K =t 
/ in B, form the relation JR = ] J / 
V ( T ) G I E / X / and its quotient 
u 
K """^^ / -
^ 
IIR 
Show that this forms a coequaliser diagram in the internal logic: one has 
T ^ Eq(cH 0 U^CR o t;), and \i w\ I -^ J satisfies T < Eq(ti; o u^w o v)^ 
then there is a unique map w: I/R —^ J with w o CR = w. 
Notice that Proposition 4.8.6 (ii) is a special case of this construction— 
which is dual to the one for subsets in Exercise 4.6.6. And also that co-
equalisers in Sets are obtained in this way. 
4.8.6. 
Let RRel(E) ^^ Rel(E) be the full subcategory of reflexive relations in an 
E 
Eq-fibration 
j^P , where /? G E/x/ is reflexive if and only if T < S{I)*{R), 
if and only if Eq(/) < R. 
(i) 
Show that the composite RRel(E) M- Rel(E) -> B is a fibration. 
(ii) Prove that / ^ 
Eq(J) yields a functor B -> RRel(E) which is left 
adjoint to the fibration RRel(E) -> B. 
[Thus, equality on / is the least reflexive relation on /.] 
(iii) Check that 5 i-^ 5 V Eq(/) for 5 G Ejx J yields a fibred left adjoint to 
the inclusion RRel(E) ^ Rel(E). 
4.8.7. 
Notice that the restriction to preorder fibrations in Definition 4.8.1 is un-
necessary, and that the definition of quotients applies to arbitrary fibrations 
with equcJity. In particular it applies to codomain fibrations. Prove that a 
category B with finite limits has coequalisers if and only if its codomain 
fibration 
i 
has quotients. 
[Note that the category Rel(B"^) in this situation is the category B ^ of 
parallel arrows in B.] 
E 
4.8.8. 
Let 
^P be a fibration with equality. Describe the kernel operation Ker(—) 
1 
. 
as a functor in a commuting diagram, 
^^"^ 
Rel(E) 
And prove that p has quotients if and only if this functor Ker has a left 
adjoint, with vertical imit and counit. This could be used as a definition 
of quotients, dual to Lawvere's definition of subset types as described in 
Exercise 4.6.7. 

304 
Chapter 4- First order predicate logic 
4,9 A logical characterisation 
of subobject 
fibrations 
In this chapter on (first order, simple) predicate logic we have seen various fi-
brations capturing various systems of predicate logic. Among these fibrations, 
subobject fibrations have received special attention in Sections 4.4 and 4.5. 
They will play an important role in later chapters, notably in topos theory. In 
this final section we ask ourselves: when is a fibration (equivalent to) a sub-
object fibration? Such a fibration should certainly have the logical operations 
that come for free in subobject fibrations, namely full subtypes and so-called 
very strong equality. Recall that this means that internal and external equality 
coincide, see Notation 3.4.2. There is a third logical operation that is available 
in subobject fibrations, namely unique choice 3!. And the combination of these 
three: full subset types, very strong equality and unique choice, characterise 
subobject fibrations, as will be shown in the present section. 
We start with unique choice. 
E 
4.9.1. Definition. Let 
^P be an Eq-fibration with subset types. 
IB 
(i) A relation R ElEjxj is called single-valued if it satisfies 
i:I,j,j':J\R{i,j)AR(i,j') 
\-j=jj'. 
Or, more categorically, if above I x {J x J) there is an inequality 
(id X 7r)*(i^) A (id X 7r')*(i^) < 7r'*(Eq(J)). 
(ii) The fibration p has unique choice 3! if for each single-valued relation 
R G E/xJ, the coproduct [J/^ j)(^) ^ ^i exists, and the canonical map —• 
in the following diagram 
{R} 
{IJ(/,j)(^)} 
V 
^Ua..)(^) 
I X J 
^ / 
is an isomorphism. 
The canonical map n o TTR -^ TTIT 
/^X in the slice category IB// comes 
by Lemma 4.6.2 (ii) from applying the reindexing functor 7r|^ to the unit map 
77: ii -> TT* U(i,j)iR)- 
This yields T < (TT o TTRY 
U(i,j)iR)' 
The idea behind this definition is that if for i G / there is a unique j £ J 
with R{iJ)j 
then the canonical (projection) map 
{(ij) I R(i,j)} 
{i I 3j.R(i,j)) 

Section 4-d' ^ logical characterisation of subobject fibrations 
305 
is an isomorphism. 
4.9.2. Proposition. Subobject fibrations have unique 
choice. 
Proof. Let B be a category with finite limits, and let {ro,ri): R >—^ I x I he 
a relation on / which is single-valued. The latter means (id x 7T)*{R) A (id x 
7r^y{R) factors through 7r'*{S{J)) = id x J, in a situation, 
/ 
^ I 
xJ 
t = {roo So,{ri o so,ri o si)) 
I x{J 
xJ) 
where S is obtained in the puUback diagram. 
id X ^ 
We will show that the map ro: i^ -> / is a mono in B. Assume therefore parallel 
maps u,v: K =4 R with ro o u = ro o v. There is then a unique map w: K —^ S 
with SQ o w — u and si o w = v. But then ri o u = ri o v, SiS witnessed by 
the following computation. 
ri o u = ri o So o It; 
= 
7T o 7T' o t o w 
= 
TTOTT^oidxSofoW 
= 
TT' o TT' o id X S o f o w 
= 
'K' o TT' ot o w 
— ri o Si o w 
= ri o V. 
Now we have an equation (ro, ri) o u — (ro, ri) o v, so that we may conclude 
u = V. 
We can thus take the coproduct in the usual way by composition: 
IJ(/ j ) ( ^ ) — ^ ^ (^Oj ^i) =^ ro: R y-^ /, so that the unique map —> in Defini-
tion 4.9.1 (ii) is the identity. 
• 
In the formulation of unique choice we have made use of subset types. In a 
similar manner we can express very strong equality in a fibration via subset 

306 
Chapter 4- First order predicate logic 
types. Recall that equality is very strong if external equality u = v: I —^ J 
and internal equality T < Eq{u,v) coincide—for two parallel maps in the 
base category. 
E 
4.9.3. Proposition. Let 
-jrP be an Eq-fibration with subset types. This fibra-
tion has very strong equality if and only if for each object / G B the canonical 
morphism K in the triangle 
{Eq(/)} 
IxJ 
is an isomorphism. 
(This morphism K is obtained by Lemma 4-6.2 (ii) from the unit map T < 
<J(/rEq(/)=<J(/)*Eq/(T).; 
This result may be read as: equality is very strong if and only if diagonals 
occur as (subset) projections. 
Proof. Assume that the above map «;:/—> {Eq(/)} is an isomorphism in B. 
Then for parallel morphisms u,v: K :=t I there are equivalences: 
u, V are internally equal 
<^ T < Eq(u,v) = (w,i;)*Eq(/) 
0> {u, v) factors through 7rEq(/) by Lemma 4.6.2 (ii) 
^ 
(u^v) factors through S{I) 
by the isomorphism K 
<^ 
u = V 
<=> u,v are externally equal. 
Conversely, assume that internal and external equality coincide. As candi-
date for the required inverse for K we have n o 7rEq(/): {Eq(/)} —>• /, since 
(TT O 7rEq(/)) o K = TT o S{I) = id. 
Further, we have above {Eq(/)}, 
T < 7r;^q(/)Eq(/) 
by Lemma 4.6.2 (ii) 
~ 7rj^Q//\Eq(7r, TT') 
see Exercise 3.4.5 
=. Eq(7r o 7rEq(/), TT' O 7rEq(/)) see Notation 3.4.2. 
This tells us that the maps TT O 7rEq(/) and TT' O 7rEq(/) are internally equal. 

Section 4-9: A logical characterisation of suhobject fibrations 
307 
Hence they are also externally equal, by assumption. But then, 
^Eq{I) 
O K O (TT O 7rEq(/)) 
= 
S{I) 
O TT O 7rEq(/) 
= 
(TT O 7rEq(/), TT O 7rEq(/)) 
= 
(TT O 7rEq(/), TT' O 7rEq(/)) 
= 
7rEq(/), 
SO that we can conclude K o (TT o 7rEq(/)) = id, since the subset projection 
^Eq(/) is a mono. Hence K is an isomorphism. 
• 
Given this characterisation, it is immediate that subobject fibrations have 
very strong equality, because their equality predicate Eq(/) is simply the di-
agonal on /. 
We now come to the main result in this section. 
E 
4.9.4. Theorem. Let 
^P be an Eq-fibration. 
This fibration is 
(equivalent 
to) the subobject fibration 
on its base category B if and only if 
• equality in p is very 
strong; 
• p has full subset 
types; 
• p has unique 
choice. 
Proof. It may be clear that a subobject fibration satisfies the above three 
properties: it has very strong equality as we just noted, it has full subset types 
by Example 4.6.3 (i), and unique choice by Proposition 4.9.3. 
E 
Conversely, let 
-j^P be an Eq-fibration satisfying the above three properties. 
We first note that by Exercise 4.6.6—using that equality is very strong—the 
base category B has finite limits, so that it makes sense to talk about the 
subobject fibration on B. Full subset types give us a full and faithful fibred 
functor 
7r(_) 
E 
^ Sut 
P 
M 
We show that it is a fibred equivalence. We can define in the reverse direction 
a functor S: Sub(B) -> E by 
( j - ^ ^ / ) 
^Uii,j){Gm)eEj, 
where Gm is the 'graph relation' of m: 
Gm = Eq{7r, m o TT') = (TT, m o 7r')*Eq(/) € E/x j . 

308 
Chapter 4- First order predicate logic 
This relation is single-valued because m is a mono and equality is very strong: 
Gm(«, j) A Gmih / ) 
=> i = m{j) A i = 
m{f) 
Hence the coproduct S{m) 
= Uu j){Gm) 
G E/ exists by unique choice. Its 
subset projection is the original mono m, since there are isomorphisms in 
'. 
7rs{m) — TT o TTG^ 
by definition of unique choice 
=. TT o (TT, m o 7r')*(7rEq(/)) because 7r(_) is a fibred functor 
= TT o (TT, m o 7r')*((J(/)) 
since equality is very strong 
= TT o (m, id) 
because of the pullback square, 
(m,id) 
m 
J 
^ I 
Y 
I 
Y 
5{I) 
(TT, m o TT') 
Ix 
J 
^ Ix 
I 
= m. 
We thus get 7r(_) o 5 = id. But then also S o 7r(_) = id, since 7r(_) is a full 
and faithful functor. 
• 
In similar fashion we can characterise regular subobject fibrations. 
E 
4.9.5. Theorem. An Eq-fibration 
^P is (equivalent to) the regular subobject 
fibration 
on its base category B if and only if 
• equality in p is very 
strong; 
• p has full subset 
types; 
• every predicate is an equation: for every X E Ej there are maps u,v: I =^ J 
in M with X = Eq(w, v). 
Proof. We concentrate on the (if)-part of the statement. As in Exercise 4.6.6, 
the base category B has finite limits. And from the way equalisers are con-
structed in B, we conclude that each projection TTX- {X} 
^-» / (for X E E/) 
is a regular mono, using that X is an equation. We construct a functor 
7^:RegSub(B) —> E as follows. Let m: K >-^ I he equaliser of u,v:I 
zzt J-
Put then Tl{m) = Eq{u,v) 
E E/. Then 7rn{m) = rn. But also 7^(7^x) = 
X, 
because X is an equation. 
• 
Exercises 
E 
4.9.1. 
Let 
iP be an Eq-fibration with subset types. Say that one has unique 
m> 
choice on J E B if for every single-valued relation R E E/ x j from / to 

Section 4-9: A logical characterisation of suhobject 
fibrations 
309 
J, one has unique choice as in Definition 4.9.1 (ii). And say that equality 
on J is very strong if one has a canonical isomorphism S{J) ^ 
^Eq(j) 
like in Proposition 4.9.3. Prove that unique choice on J implies very strong 
equality on J. 
4.9.2. 
Let 
^P be an Eq-fibration with very strong equality and full subset 
IB 
types. 
(i) 
Express the induced pullbacks in B in the internal language of the 
fibration, see Exercise 4.6.6. 
(ii) Assume now that p is also regular, i.e. additionally has simple co-
products Y[(j J)- Prove that the induced coproduct functors ]J^ from 
Example 4.3.7 (i) satisfy the Beck-Che valley condition. 
[Hint. The usual set theoretic argument may be carried out internally.] 
(iii) Prove also that if p is a first order fibration then the induced products 
Yl 
also satisfy the Beck-Che valley condition. 

310 
Chapter 4-' First order predicate logic 
This Page Intentionally Left Blank

Chapter 5 
Higher order predicate logic 
Moving from equational logic to first order predicate logic leads to a clear 
increase of expressive power. But certain concepts cannot be expressed in 
first order predicate logic because they require "higher order" quantification 
over subsets (or predicates). A typical example in algebra is the concept of 
a Noetherian ring: it is a ring R in which every ideal I C R has a finite 
basis [i.e. is finitely generated). This cannot be expressed in first order pred-
icate logic, because it requires higher order quantification. By the latter we 
mean quantification over propositions (inhabitants of Prop) and over predi-
cates (inhabitants of cr -^ Prop, where (T is a type). In contrast, in first order 
predicate logic one only quantifies over inhabitants of types. So the easiest 
way to introduce higher order quantification is to make Prop a type, i.e. to 
introduce a 'higher order' axiom h Prop: Type. This approach will be followed. 
Propositions xi'.ai^... 
^Xn'.o'n l~ V^* Prop are then terms of type Prop: Type. 
Quantification 3,V over types can take the particular form \fa:Prop.(p 
and 
3a: Prop, (p of quantification over propositions, since Prop is a type. This forms 
the essential aspect of higher order logic. 
The resulting formal system will be referred to as higher order simple pred-
icate logic, or higher order logic for short. The qualification 'simple' refers to 
the fact that the underlying type theory is simple (like in the previous chap-
ter), and not polymorphic or dependent. Tool support for higher order logic 
is provided by the HOL system [104] (and also by a special configuration of 
the ISABELLE system [250]). The PVS system [242, 241] is a tool for depen-
dent higher order predicate logic, see Section 11.1. These tools are used for 
machine-assisted verifications in higher order logic. 
311 

312 
Chapter 5: Higher order predicate logic 
This chapter contains the syntax of higher order logic in its first section. 
The second section is on generic objects. These are the categorical counter-
parts of the earlier mentioned distinguished type Prop, which relates predicates 
x:a \- (f: Prop on a type a and "classifying" terms a —> Prop. For split fibra-
tions this correspondence can be described in a straightforward manner, but 
for arbitrary fibrations there are some complications to be investigated. This 
will involve a version of the Yoneda Lemma which is suitable for fibred cat-
egories. The third section gives the appropriate fibred structures to capture 
higher order logic. Examples include realisability triposes, which generalise 
the realisability fibration from the previous chapter, and the regular subob-
ject fibration over u;-sets (but not over PERs). In the same section we first 
encounter the notion of a topos: it is a category for which its subobject fibra-
tion is such a 'higher order fibration'. This is a distinctly logical definition. 
The remainder of this chapter will be devoted to the (standard) theory of 
these toposes. In Section 5.4 we present the ordinary 'elementary' definition 
of a topos, and show that it is equivalent to the 'logical' one. Further, we 
describe nuclei (or Lawvere-Tierney topologies) in toposes. Such a nucleus j 
gives rise to an associated higher order fibration of j-closed subobjects. Also, 
for a nucleus one can define separated objects and sheaves in a topos. Espe-
cially the double negation nucleus -«-» is of logical importance. Its categories 
of separated objects and of sheaves come with classical logic (via their regular 
and ordinary subobjects). 
The expositions on toposes form a preparation for the special example of 
the 'effective topos' EfF in the next chapter. 
5.1 Higher order 
signatures 
We start our description of higher order predicate logic (over simple type 
theory) by identifying an appropriate notion of signature for such logic—like 
we did for equational logic and for first order predicate logic. For higher order 
predicate logic, signatures are actually simpler than for first order predicate 
logic: higher order signatures will contain a distinguished type Prop, making 
it no longer necessary to describe function symbols and predicate symbols 
separately: predicate symbols can be identified with function symbols with 
codomain Prop. 
In a logical setting, we shall always write Prop for this distinguished type 
and we view inhabitants of Prop as propositions. A variable of type Prop is 
therefore a proposition variable, for which we shall use letters a, y^, 7,... from 
the beginning of the Greek alphabet. These proposition variables may occur 
in propositions—because, in general, variables inhabiting types may occur in 

Section 5.1: Higher order signatures 
313 
propositions. 
A higher order signature E consists first of all of an underlying set T = |E| 
of atomic types containing a special type Prop. Thus, |I]| can be understood 
as a pointed set. Further, E contains function symbols F : (Ji,..., cr^ —)• Cn+i 
as in ordinary signatures. A morphism (^: E -^ E' of higher order signa-
tures consists of a function (;z^: |E| —)• |E'| between the underlying sets of 
atomic types with (/)(Prop) = Prop (making (j) a morphism in the category 
Sets» of pointed sets), and of a collection of functions (also written as (j)) 
mapping function symbols F : cri,..., (7„ —)• cFn-\.i in E to function sym-
bols (j){F):(j){ai),...,({){an),—> 
(f){an-\.i) in E'. There are no explicit predi-
cate symbols in a higher order signature, like in a signature with predicates 
(see Definition 4.1.1). Instead, function symbols F : cri,..., cr„ —y Prop are 
understood as predicate symbols. 
We recapitulate in concise fibred terminology. 
5.1.1. Definition. The category HoSign of higher order signatures is 
defined in the following change-of-base situation, 
HoSign 
>• Fam(Sets) 
Sets» 
>- Sets 
T^T" 
X T 
where Sets» is the category of pointed sets (see Exercise 1.2.3 for the defini-
tion). Implicitly, in the base functor Sets^ -^ Sets there is a coercion turning 
a pointed set into an ordinary set. 
A higher order signature forms the basis for a logic, much like in the pre-
vious two chapters. What is new is that terms T \- (p\ Prop will be taken 
as propositions. They can be built up inductively from atomic propositions 
M —(J M' and P[M\^..., 
M„), where P is a function (or predicate) symbol 
cri,...,cr„ — \ Prop. Thus, in higher order logic, propositions are not some 
external entities but live as terms inside the type theory. Notice that Prop is 
itself a (atomic) type. Explicitly, via an axiom: 
h Prop: Type 
In what we call higher order logic (on top of a higher order signature E) 
we shall use finite product and exponent types (as in the calculus Alx(E) in 
Section 2.3), and connectives and quantifiers as in first order predicate logic. 
Thus we have in particular constants T, ± : Prop for true and false. 

314 
Chapter 5: Higher order predicate logic 
Since Prop is now a type, we may quantify over it as in 
Va: Prop, {a D a) 
or in 
Va: Prop. 3P: a -^ Prop. 3x: a. Px. 
This gives typical propositions in a higher order logic. 
For propositions ipi,... ,ipn,ip in context F we continue to use sequents 
T \ ipi,.. .,(fri l~ V^ as regulated by the rules for first order predicate logic in 
Figure 4.1. But there is a crucial difference: in higher order logic, propositions 
are special terms (with type Prop), which leads to the question of how logical 
equivalence IC (for propositions) is related to (internal) equality ==Prop ^^ ^he 
type Prop of propositions (for terms of type Prop). The following rule equates 
them (for predicates). 
extensionality (of entailment) 
F h P, Q: cr -> Prop 
T,x:a\ 
0, Px \- Qx 
T,x:a\ 
6 , Qx h Px 
F I 6 h P =,^Prop Q 
See also [91, Definition 2.2.9]. We shall not standardly assume this rule in 
higher order logic, and shall mention explicitly when it is used. 
5.1.2. Example. An important consequence of this extensionality of entail-
ment rule is that a proposition a: Prop is derivable if and only if the equality 
(a =Prop T) is derivable. In one direction this is easy via Lawvere's equality 
rule (see Lemma 3.2.3): 
0 I 0 h a[T/a] 
a: Prop | a =prop T h a 
For the converse one uses the above extensionality of entailment rule with 
cr = 1, so that 1 -^ Prop =. Prop. We then get 
a: Prop h a, T: Prop 
a: Prop | a, a h T 
a: Prop | a, T h a 
a: Prop \ a h a =prop T 
Let us summarise. 
5.1.3. Definition. Let E be a higher order signature. It gives rise to a higher 
order logic with 
• for types: finite product 1, x and exponent types —>; 
• for propositions: finite conjunctions T, A and disjunctions ±, V, equality =a, 
for a: Type, and existential and universal quantification 3x: a. (—), Vx: a. (—) 

Section 5.1: Higher order signatures 
315 
over types a (including the important special case were a is Prop), satisfying 
the rules in Figure 4.1. 
We will say that this higher order logic on S has extensional entailment 
if it includes the above "extensionality of entailment" rule. 
A higher order specification consists of a higher order signature E to-
gether with a collection A of sequents in the higher order logic associated with 
E; these are taken as axioms. Such a higher order specification determines a 
higher order theory, by closing A under derivability. 
Notice that we do not standardly include subset types {x: cr | <^} or quotient 
types a/R in higher order logic. Neither the requirement that equality is very 
strong. All this may be added separately. Recall that we call a logic extensional 
if its equality is very strong [i.e. if its internal and external equality coincide); 
this is not related to the above extensionality of entailement rule. 
5.1.4. Example. Higher order logic as formulated above contains consider-
able redundancy. For example, one can define 
± — Va:Prop. a 
T = ± D ± 
(pW ip — Va: Prop, {(f D ot) D {{tp D (y) D ct) 
(p Alp — Va: Prop, ((f D {'fp D a)) D a) 
3x:a.(p 
— Va: Prop. (Vx: (7. (^ D a)) D a. 
And for terms M, N.a^ 
(M ^a N) = \JP:a-^ Prop. PM D PN 
The latter definition yields what is commonly called Leibniz equality; it 
says that terms are equal if they have the same properties. Thus implication 
D and universal quantification V are the essential connectives. 
5.1.5. Lemma. The above definitions yield connectives that satisfy the rules 
in Figure 4-^-
Proof. We shall do 3 and =^7 and leave the remaining connectives as an 
exercise below. The introduction rule for 3 is obtained as follows. 
r h M: a 
r, a: Prop | 0, Vx: a. [p D a) h Va:: a. {(p D a) 
F, a: Prop | 6, Vx: a. (^ D a) h (p[M/x] Da 
F | 6 h ip[M/x] 
F, a: Prop | 0, \/x: a. {(p D a) 
ha 
F, a: Prop | 0 h {^x: a. {(p D a)) D a 
F I 0 h Va: Prop. (Vx: a. {<p D a)) D a = 3x: a. (p 

316 
Chapter 5: Higher order predicate logic 
and the elimination rule (with x not in 0, V^) as 
T,x:a\ e,(p h ^p 
rhV^:Prop 
T \e \-3x:a.ip 
T,X:(T \ Q \- (f D ip 
r I 0 h {ix: a.{(pDilj))DjP 
T | 0 h ^x: a. [ip D V^) 
r | 0 h^ 
We turn to Leibniz equality. The reflexivity, transitivity and replacement 
rules for equality are easily established. For symmetry, assume (M =a N) — 
\/P:(T -> Prop.PM D PN. In order to get [N =a M), assume P:a -^ Prop 
with PN. Take 
P' = Xx: a. Px D PM: a -> Prop. 
Then, instantiating the assumption M -a N with P' yields P'M D P'N. 
Since P'M we get P'N = {PN D PM), and PM follows, as required. 
D 
Power types 
In higher order logic we can write 
Pa — a -^ Prop: Type 
for the cr-powerset type. We can think of terms in Pa either as predicates on 
cr, or as subsets of a. Such a type allows us to quantify over predicates, as 
in Va: Pa. a =pa CL- It comes equipped with a typed membership relation Ga 
described by 
x: cr, a: Pa h ar G^ a = a • a:: Prop. 
There is then the familiar (typed) inclusion relation C^^ on Per, as: 
def 
a: Pa, b: Pa h a C^ 6 = Vx: a. {x Ga «) D (^ ^a b): Prop. 
For a proposition x:a,y:T 
h (p{x, y): Prop it makes sense to write 
x:a \- {yerl 
ip{x, y)} = Xy: r. (f{x, y): Pr. 
So that we get a subset term. Note that this is different from subset types 
as described in Section 4.6, since there, {y- r \ (p{x, y)} was a type. Notice the 
difference in notation between the term {x E a \ ip} and the type 
{x:a\ip}.By 
construction, the terms <f{x,y) and z ET {y E T \ (p{x,y)} are (/?)-convertible, 
so that we may replace one by the other. In particular, they are logically 
equivalent. 
We mention some elementary results concerning these constructs. 

Section 5.1: Higher order signatures 
317 
5.1.6. L e m m a . Assume 
we are in higher order logic with extensional 
entail-
ment. 
(i) Write for x\ a, 
{x]a - Xz'.a. [x -a 
z):Pa, 
for the singleton predicate associated with x. 
Then, 
x: o;y:a\ 
{x}a -Pa 
{y]a H x =^ y. 
(ii) The inclusion 
relation C^j is (internally) 
a partial order on the power-
type 
Pa: 
a: Per, 6: Pa \ a C^j b,b C^ a \- a —Pa b. 
Proof, (i) If {x}cj —P(j {y]a^ then we have equalities of propositions 
T =Prop (^ =<7 x) =prop {x]a 
' X =prop {y}a 
' X =Prop {v =a 
x). 
Hence we get x =(j y, by Example 5.1.2. 
(ii) Assume a C^ b and b C^ a. Then a,b:Pa 
— a ^ 
Prop satisfy the 
premises of the extensionality of entailment rule, so that a —Pa b. 
• 
The singleton map { —}a*cr -^ Pa described in (i) will play an important 
role in the rest of this chapter. Above one sees that it is internally injective. 
This result thus holds in all models of higher order logic with extensional 
entailment. 
Quotient 
types in higher order logic 
What we call higher order logic does not include quotient types. But of course 
one can additionally require these quotient types. It turns out that within 
higher order predicate logic, quotient types behave much better than within 
first order predicate logic. For example, we have the following result from [133, 
Proposition 5.1.10]. 
5.1.7. L e m m a . In higher order logic with extensional 
entailment, 
quotients 
are automatically 
effective: for an equivalence relation R on a type a, one can 
derive: 
x: a,y:a\ 
[X]R ^^/R 
[y]R ^ R{x, y). 
Proof. If we have a relation x:a,y:a 
h R{x,y): 
Prop which is provably an 
equivalence relation, then by transitivity and symmetry, we can form the pick-
term 
x: a,y:a 
\- R{x, y): Prop 
x: a, y: a,z:a\ 
R{y, z) h R{x, y) =prop R{x, z) 
x: a, a: a/R 
h pick w from a in R{x, w): Prop 

318 
Chapter 5: Higher order predicate logic 
Hence by using reflexivity, we get, 
x: (T,y\(T\ [X\R -a/R [y\R h T ^p^op R{x, x) 
— 
pick w from [X\R in R{x,w) 
=Prop pick w from [y]R in R(x,w) 
R{x,y). 
• 
When we first introduced quotient types in Section 4.7, we explained that 
the quotient a/R by an arbitrary relation R should be understood as the 
quotient by the equivalence relation R generated by R. This can be made 
precise in higher order logic. 
5.1.8. Lemma. For an arbitrary relation x'.a^y.a 
h R{x,y):Prop 
one can 
form in higher order logic the least equivalence relation R containing R as 
x:a,y:(T \- R{x,y) 
= VS*: cr x cr ^ Prop. 
(Equiv(5) A Incl(i?, S)) D S{x, y): Prop. 
In this expression we use the abbreviations, 
Equiv(5) = "ix'.a. S{x,x) 
Ayx,y:a.S{x,y) 
D S{y^x) 
A Va?, y, z: a. S(x, y) A S[y, z) D 5(x, z) 
def 
lnc\(R,S) 
= 
yx,y:a.R{x,y)DS{x,y). 
The relation R then yields the same quotient type as the equivalence relation 
R that it generates, in the sense that there is an isomorphism of types, 
a/R ^ 
a/^. 
Proof. The isomorphism is given by the two terms 
a: a/R h P{a) = pick x from a in [x]-^: a/R 
— 
def 
6: a/R h Q{b) = pick y from 6 in [y]R : a/R, 
where Q is well-defined because R(x,y) 
implies [X]R =a/R [VIR^ since the 
latter is an equivalence relation containing R. Then for b: a/R, 
P[Q(b)/a] 
— pick y from 6 in ^[[y]ii/a] 
by commutation from Exercise 4.7.1 
= pick y from b in (pick x from [y]/e in [x]-^ 
= pick y from 6 in [y]-^ 
= b. 
In a similar manner one obtains a conversion Q[P{a)/b] = a, 
• 

Section 5.1: Higher order signatures 
319 
We conclude this section with two examples of the use of quotient types in 
higher order logic with extensional entailment. The first example involves the 
standard factorisation of terms as a surjection followed by an injection. And 
the second example describes the Abelian quotient of an arbitrary group. 
5.1.9. Examples. Assume we have quotient types in higher order logic with 
extensional entailment. 
(i) We first notice that for a relation R on cr, the canonical map [—]: ^ -^ 
a/R is always surjective (in the logic). Consider therefore the proposition, 
a:a/R\-ip{a) 
= 3x: cr. a =^//^ [x]: Prop. 
Obviously, y: cr | 0 l~ <^([y]) =Prop "''? ^^^ ^hus for a: cr/R, 
(p(^a) — pick y from a in '^{[y]) =Prop P'^k y from a in T = T. 
Thus 3x: cr. a —a/R [x] holds for a: a/R. 
This result can be used to factor an arbitrary term x:cr h M[X):T 
as a 
surjection followed by an injection: 
. 
M 
X 
/ 
[-] 
M 
X 
ya 
^ T) - ya 
^ cr/A > 
^ r) 
In this diagram, K is the kernel relation, 
def 
x:a,y\a 
\- K{x,y) 
= (M{x) =r M{y)): Prop 
and M{a) = pick x from a in M{x) for a:a/K. 
Then obviously M([a:]) = 
M(x). Moreover, this term M is (internally) injective: one can derive 
a: cr//i, 6: a/K \ 'M{a) -r Jdib) h a -a/K ^• 
as follows. 
M[a) -r M[h) - 
pick x,2/from a,6 in M([x]) =:^ M([?/]) 
= pick x^ y from a, h in M[x) —j M{y) 
= pick X, y from a, 6 in A (x, y) 
= pick X, y from a, 6 in [x] =a/K [v] 
- 
« -a/K 
^• 
This factorisation is the one from Example 4.8.8. Its universal property is 
described in Exercise 5.1.6 below. This factorisation is also familiar from topos 
theory: it is almost literally as in the proof of [169, Theorem 1.52] (describing 
the factorisation of an arbitrary map in a topos as an epi followed by a mono). 

320 
Chapter 5: Higher order predicate logic 
(ii) Let G:Type be a type which (internally) carries a group structure 
(0, +, —(•))• Consider the following relation ^ on G, 
u,v:Ghu^v 
=^ \tR:GxG^ 
Prop. (Equiv(i?) A Cong{R) 
A Mx, y: G. R{x -\-y,y-{-x)) 
D R{u, v) : Prop 
where the predicates Equiv(/i) and Cong(i^) express that R is an equivalence 
relation, and is a congruence. The latter is described by 
Cong(i?) = yxi,X2,yi,y2'G.R{xi,X2) 
A R{yi,y2) 
D R{xi - yi,X2 -2/2). 
It is then easy to see that if we have Equiv(i?) A Cong(i?) then i?(0,0), and 
R{x^ y) D R{—x, —y). Also, with some elementary reasoning one obtains that 
Equiv(^) ACong(^), where ^ is the relation on G defined above. 
def 
We now put G = G/^, with canonical map x:G h [a:]:G. Then we can 
define for a,b:G, 
6 =' [0] 
a 4- 6 = pick u, v from a, 6 in [u + v] 
def 
— a 
pick u from a in [—u] 
so that we get group operations on G via representatives. This yields an 
Abelian group structure, as may be verified by the interested reader. The 
canonical map [—]:G -^ G is a universal group homomorphism: for any ho-
momorphism M.G^H 
into an Abelian group H, we get a unique homo-
morphism M in 
[-] 
G: 
^G 
I 
^ 
I M 
M ^ \ 
Y 
H, Abelian 
def 
One puts M{a) = pick u from a in M{u). This is well-defined because one 
can form the kernel relation x,y:G 
h K{x,y) 
— [M{x) =H ^(2/))-P''op 
and show that it is a congruence and an equivalence relation. It also satisfies 
K{x-{-y, y-\-x), since M{x+y) =H M{x)^M{y} 
-H M{y)^M{x) 
=H M{y-{-x), 
because the group operation • of H is commutative. Thus ii u ^ v, then 
K{u,v) and so M{u) —H M[V). 

Section 5.2: Generic objects 
321 
Exercises 
5.1.1. 
Use the extensionality of entailment rule to derive in higher order logic, 
a: Prop, /3: Prop | a D / 3 , / 3 D a l - a =prop /3. 
5.1.2. 
Check that the connectives ±,V,T,A as defined in Example 5.1.4 satisfy 
the rules in Figure 4.1. 
5.1.3. 
For a proposition x:a^y:r 
h (p{x^y):Prop in higher order logic with ex-
tensional entailment, show that Wy: T.ip(x,y) is logically equivalent to the 
equation {y e T \ ip{x, y)} =Pr {y G r | T}. 
5.1.4. 
Prove that in higher order logic with quotient types there are conversions, 
pick X from a in T = T 
pick X from a \n {ip A ip) = (pick x from a in ip) A (pick x from a in t/^). 
Conclude that in higher order logic with extensional entailment the pick-
operation preserves entailment h. 
5.1.5. 
Define in higher order logic an order < on Prop by 
def 
a: Prop, f3: Prop \-a < (3 = a D f3: Prop, 
and show that (Prop, <) is (internally) a Hey ting pre-algebra. 
5.1.6. 
Consider the factorisation M = M o [—j/c^cr —> r from Example 5.1.9 
(i), and show that it is universal in the following sense. If we can write 
M = Q o P, where Q: p -> r is internally injective, then there is a unique 
term (up-to-conversion) P: a/K 
—)• p with conversions P o [~]K = P and 
Q o P = M. 
5.1.7. 
Let R he a relation on a and S a reflexive relation on cr/R. Prove that 
in higher order logic with extensionality of entailment and with quotient 
types, the quotient a/R/S 
is isomorphic to the type (j/T, where T is the 
relation T{x, x') = S{[X]R^ [^']R) 
on a. 
5.2 Generic 
objects 
Higher order signatures as described in the previous section involve a special 
atomic type Prop, v^hich is such that predicates on a correspond to "charac-
teristic" terms a -^ Prop. Categorically, such a correspondence is described 
in terms of so-called 'generic objects'. These can be defined easily for split 
fibrations, 
but for arbitrary fibrations there are some complications. In order 
to describe these matters properly, we need a fibred Yoneda lemma. But we 
shall start with the easy case of split 
fibrations. 

322 
Chapter 5: Higher order predicate logic 
E 
5.2.1. Definition. A split fibration jrP has a split generic object if there 
is an object fi G IB together with a collection of isomorphisms 
Oi 
B(/, Q) 
^ Obj E/ 
natural in /; that is, 9j{u o v) = v*{Oi{u)) for v: J —> I. 
It may be clear that the above Q E B plays the role of Prop, and that 9 
identifies terms / —> fi with predicates X G E/ on /. The following result 
gives a slightly different formulation of the same notion. 
E 
5.2.2. Lemma. A split fibration -^P has a split generic object if and only 
if there is an object T G E with the property that 
MX e^.3\u:pX 
-^pT.u*{T) 
= X. 
E 
Proof. Assume 
jrP has a split generic object {^,0) as described in the 
above definition. Take T — ^n(idn) ^ I^- Then for X G E/ we have that 
ej^{X)\I 
-^^ 
= pT satisfies 
e-[\xy[T) = ej\xY{ea(id^)) = ej{id^o6j\x)) = x. 
And it is easy to see that 9J^{X) is unique in satisfying this property: if 
X = u*(T) = ei[u), then u = 
ej\X). 
In the reverse direction, assume T G E as in the lemma, and write Q. = pT G 
B. For / G B and u: I ^ ^, let Oi(u) = u*{T). It is then clearly a bijection. 
And Oi{u ov) = {uo vy{T) = v*{u*{T)) = v*{Oi{u)), for v:J-^L 
D 
5.2.3. Examples, (i) Let C be a category with a small collection Q = Obj C 
of objects. Then Cl G Sets forms a split generic object for the family fibration 
Fam(C) 
4- 
. The set of functions / ^ Q is actually equal to the collection of 
objects of the fibre Fam(C)/ over /. 
In [252] a (split) fibration is called 'globally small' if it has a (split) generic 
object. This family example provides a justification for this terminology. The 
smallness aspect will become more apparent in Proposition 5.2.7 below. Later, 
in section 9.5 a fibration is called 'locally small' if its fibred homsets are small 
(in a suitable sense). 
(ii) A special case of (i) is C = 2 = {±,T} with ± < T. The family 
Fam(2) 
Sub(Sets) 
fibration 
I 
is then isomorphic to the subobiect 
fibration 
i 
on 
Sets 
.
.
. 
Sets 
Sets, see Exercise L7.3. The generic object is the set {_L, T} in Sets, together 
with the isomorphism between subsets of / and 'characteristic' functions / -> 
{-L,T}. 

Section 5.2: Generic objects 
323 
£(s,n,>i) 
(iii) Consider a split classifying fibration 
i 
constructed syntactically 
(see Section 3.1) from a higher order specification ( E , n , ^ ) . Such a fibration 
also has a split generic object, namely the type Prop G C^(D). For an object 
(or type) cr G C^(5]), the morphisms M\a 
-> Prop in Cl[Ti) are by definition 
the terms x\a 
\- M: Prop, and thus the propositions in context cr, i.e. the 
objects over a E ff(D). 
(iv) Let B be a distributive category. Write Q == 1 + 1 G B. Then Q forms 
a boolean algebra, see Exercise 2.6.1. Each homset B(/, Q) is then partially 
ordered b y ^ < V ^ 
<^ (p /\\l) — ip. Hence the assignment / H-> B(/,fi) yields 
an indexed category B^P -^ Cat. The resulting split fibration has Q as split 
generic object by construction. 
These generic objects can be described on a more abstract level in terms 
of a fibred Yoneda lemma. This result—and also the subsequent corollary— 
may be found in [27]. We recall from Exercise 1.10.2 that the Grothendieck 
construction applied to the represent able functor B(—,/):B^P —)• C a t yields 
B// 
the domain fibration 
>ldom/ 
These fibrations dom/ play the role of repre-
sentable objects in fibred category theory. 
E 
5.2.4. L e m m a (Fibred Yoneda). (i) For a cloven 
fibration 
^"P and an ob-
B 
ject / E B there is an equivalence of categories 
E/ c:^ Horn(^dom/, pj 
between the fibre category 
over I and the hovfi-category 
of 
fibred 
functors 
M/I -^ E over B and vertical natural transformations 
between 
them. 
The equivalence is natural in I in the sense that for each morphism w: I ^ 
J 
in M, the 
diagram 
E j 
^ Hom(^dom/, p) 
E/ 
>• Hom(domj, p) 
commutes 
up-to-unique-isomorphism. 
(ii) In case p is a split fibration, the equivalence 
in (i) is an 
isomorphism 
and the naturality 
diagram commutes 
on-the-nose. 

324 
Chapter 5: Higher order predicate logic 
Proof, (i) Each object X E E/ gives rise to a functor Fx'-^/I 
-^ E by 
u I-)- u''[X) on objects, and on morphisms by, 
/ 
J 
^ K 
\ 
( 
Fxw 
^ 
u*(X) 
^v*iY) 
I 
\ 
X 
J 
where Fx{<f>) is the unique arrow in E above (p satisfying v{X) o Fx(<j>) = 
u{X). 
In the reverse direction, every fibred functor G:M/I -^ E over B gives an 
object G(id/) G E/. These operations X \-^ Fx and G H^ G{idj) constitute 
an equivalence, since 
Fxiidj) 
- 
id}(X) 
^ 
X. 
FGi.dr){^) = U*G{idi) 
= G{u*{idj)) 
since G is a fibred functor 
= Gin). 
Naturality in / holds, because for w: I ^ J, one has 
F^*iX){u) = 
u*w*(X) 
^ 
{wouy{X) 
= Fx{w o u) 
= FxiUJ^))-
(ii) Obvious, since in the split case, all the above isomorphisms are identi-
ties. 
D 
5.2.5. Corollary. Every fibration is equivalent to a split fibration. 
E 
Proof. For a fibration -^P , define a split indexed category on B by 
IB 
/ i-> Hom(dom/, p) 
and 
(/ - ^ j ) H-> ( - o ]J^ ). 
The resulting split fibration (obtained by the Grothendieck construction) is 
by the previous lemma equivalent to p. 
D 
This result may be used to transform fibred models of certain type theories 
into equivalent split models, see e.g. [134]. 

Section 5.2: Generic objects 
325 
E 
5.2.6. Definition. A fibration 
j^P is representable if it is equivalent to a 
domain fibration 
^domn for some object f2 E B. 
E 
The fibred Yoneda lemma tells us that if a (cloven) fibration 
-j^P is rep-
resentable, say with an equivalence p '2:^ dom^ for Q G B, then there is 
an object T G E above Q yielding a functor B/Q - ^ E by u ^-^ 
u*{T). 
Further, this means that in the reverse direction there is a fibred functor 
^ : E -^ B/Q together with vertical natural isomorphisms (p:id ^ //( —)*(T) 
and tp:id ^ 
i/(( —)*(T)). But since the fibration domn has discrete fibre 
categories tp must be the identity and thus H{u*(T)) 
= u in B/Q. 
E 
Split(E) 
For a split fibration 
-^P there is a split 
fibration of objects 
^HIPII 
where Split(E) is the subcategory of E with all objects from E, but with 
Cartesian maps coming from the splitting only, see also Exercise 1.8.9. Next 
we will show how a split generic object for p exists if and only if this fibration 
of objects IIPII is representable. 
E 
5.2.7. Proposition. A split fibration 
j^P has a split generic object if and 
Split (E) 
only if the associated fibration 
of objects 
IS 
representable. 
Split (E) 
Proof. Assume that the split fibration of objects 
i\\P\\ is representable, 
say via /f:Split(E) -> B/Q together with isomorphisms (fx-^ 
-^ 
HX*{T) 
as described above. Then ipx = id, since ||p|| has discrete fibre categories. 
Thus we obtain isomorphisms Obj E/ = Split(E)/ ^ (B/Q)/ = B(/, Q), which 
commute (on-the-nose) with reindexing. 
Conversely, given Q with the isomorphisms 0j as in Definition 5.2.1. The 
object T — ^n(idn) G E^ induces a fibred functor M/Q -^ Split(E) by u \-^ 
u*{T) 
= Oi{u), which is an obvious isomorphism. This shows that ||p|| is 
representable. 
• 
Next we turn to generic objects for non-split fibrations. This is a subtle 
matter: an equality like in Lemma 5.2.2 has to be replaced by an isomorphism. 
There are several alternatives. 
E 
5.2.8. Definition. Consider a fibration 
^P and an object T in the total 
category E. We call T a 
(i) weak generic object if 
MX G E. 3 / : X -^T.f 
is Cartesian, 

326 
Chapter 
5: Higher order predicate 
logic 
or, equivalently, 
VX G E. 3u:pX -> pT. 3 / : u*{T) -^ X. / is a vertical isomorphism, 
(ii) generic object if 
yX e E. 3\u:pX -> pT. 3 / : X ^T. 
/ i s Cartesian over u 
or, equivalently, 
VX E E. 3\u:pX -> pT. 3 / : u*{T) -> X. / is a vertical isomorphism, 
(iii) and a strong generic object if 
VX G E. 3!/: X -> T. / is Cartesian 
or, equivalently, 
VX G E. 3!w:/>X -^ pT. 3!/: u*(T) -> X. / is a vertical isomorphism. 
5.2.9. Lemma. Generic and strong generic objects are determined up-to-
isomorphism (but not the weak ones). 
In a preorder fibration, there is no difference between a generic object and 
a strong generic object. 
Proof. Exercise. 
• 
For these generic objects we seek a reformulation of the above notions in 
terms of representable fibrations. This will be achieved for (ordinary) generic 
objects, so that they form the most natural notion among the above three 
options (weak, ordinary, and strong). 
E 
Recall {e.g. from Exercise 1.1.4) that for every fibration 
-^P there is a 
Cart(E) 
fibration of objects 
i\P\ where Cart(E) is the subcategory of E with all 
objects but Cartesian morphisms only. 
E 
5.2.10. Proposition. A fibration ^P has a generic object if and only if the 
Cart(E) 
associated fibration of objects 
is representable. 
Proof. Assume p has a generic object T G E, say with Q = pT G B, satisfying 
the description in Definition 5.2.8 (ii). We intend to show that the fibration 
Cart(E) 
MP\ is equivalent to domn (and thus representable). One defines a functor 
IB 
ii/:Cart(E) —> B/Q by mapping X to the unique arrow ux'-pX -^ Vt with 

Section 5.2: Generic objects 
327 
u*[T) = X, vertically. For a Cartesian morphism /: X —> Y we get uy o pf — 
ux, by uniqueness, since 
{uYopfriT) s (pfru*y(T) - {pfr(Y) - x, 
the latter because / is Cartesian. By definition we have (—)*(T) o H '= id. We 
get iJ(t/*(T)) = 1/ by uniqueness, since by definition H{u*{T)y{T) 
^ w*(T). 
Conversely, assume the fibration \p\ is represent able, say via i/:Cart(E) -> 
B/Q with isomorphisms v^x*-^ -^ HX*{T) 
natural in X G E, where 
HX.pX 
-^ Q. For any u:pX 
-> Q which also satisfies u*(T) = X ver-
tically, we get a vertical isomorphism H{u*{T)) = HX in B/Q, and thus 
u = H{u*(T)) = HX. 
D 
Mono(Sets) 
5.2.11. Examples, (i) Consider the (non-split) fibration 
4- 
of 
monos (injections) in Sets. The inclusion 
T = ( l = { T } C { ± , T } = 2) 
is a (strong) generic object for this fibration: for every injection rn: X >-^ I 
there is a unique map Xm* / —)• 2 for which there is a pullback square, 
X 
^ 1 
J 
V 
This map Xm is then determined by Xm{i) = T <^ 3x ^ X. m{x) — i. 
(ii) A weak generic object often arises in the following situation. Let B be 
a category with finite limits and aiA —> J5 be an arbitrary morphism. Write 
V for the collection of morphism of the form u*{a) which are obtained from a 
by pullback along some u. We write V^ for the full subcategory of B"^ with 
objects in V. Then the codomain functor 
4- 
is a fibration with a as weak 
IB 
generic object. 
E 
5.2.12. Remark. Suppose 
j^P is a fibration with a generic object, say given 
by T G E^. Fibred structure for p then induces structure on Q which captures 
the fibred structure on objects. For example, if p has fibred Cartesian products 
X, then one obtains a map &: fi x ft —> Q such that for parallel maps u,v:I 
^ 
ft there is an isomorphism: 
t/*(T) 
xv%T)^{ko{u,v)Y{T). 
Thus the map & describes the object part of fibred Cartesian products—since 
every object X is isomorphic to i/*(T) for a unique u. 

328 
Chapter 5: Higher order predicate logic 
This map & comes about as follows. The object part of the Cartesian prod-
uct functor on E works also on Cart(E) and hence—by Proposition 5.2.10—on 
B/Q. It leads to a natural transformation with components 
B ( / , QXQ) 
^ B ( / , 
^ ) 
and thus by the Yoneda lemma to a map &: Q x Q —> Q. 
In a similar way fibred exponents yield a map =>: Q x ^ ^ ^ . And if B is 
Cartesian closed, simple coproducts and products lead to collections of maps 
(for every / G B), 
3/ 
V/ 
Q^ 
^ Q 
and 
Q^ 
^ Q 
A similar phenomenon occurs for split fibrations with split generic objects. 
We conclude this section with morphisms and generic objects. 
5.2.13. Definition. Let ( 
Ip j ^ ^ ^ 
Y 
] be a morphism between 
fibrations p and p', each with a (weak, strong) generic objects, say T E 
^ 
and T' G lE^/. We say that [K, L) preserves these generic objects if the 
induced Cartesian map LT —> T' is an isomorphism. 
A bit stronger, (A', L) preserves these generic objects on-the-nose if this 
map LT —> T" is an identity. 
Preservation on-the-nose is most appropriate for split generic objects. 
/ E X 
(j^^ L) / 
Y M 
5.2.14. Lemma. Suppose 
( 
^ 
1 
—^ 
I 
y^ j is a morphism 
of split 
fibrations 
with split generic objects. If{K, L) preserves these on-the-nose, 
then 
the following 
diagram 
commutes. 
Obj El 
^ Obj TSj^j 
B(/,fi) 
^ ^ ( A V , ^ ' ) 
Proof. Exercise. 
• 

Section 5.2: Generic objects 
329 
Exercises 
5.2.1. 
(From [81, Section 2] Define a PER E = {(n, n) \ n-0 ],^ n - 0^}. 
(i) 
Prove that for a PER /?, there is a bijective correspondence between 
maps /? -^ E in PER (or in u;-Sets) and subsets ^ C |i?| which are 
saturated(2.e. which satisfy: n ^ A and nRn' imply n G A) and for 
which there is a r.e. subset J5 C N with A = \R\n B. These subsets 
are called "natural subobjects" of R. 
NatSub(PER) 
(ii) Define a fibration 
4- 
of natural subobjects, with split 
PER, 
generic object using E G PER. 
5.2.2. 
Recall the natural numbers object N = (Eq(N) C N x N) in PER from 
Exercise 1.2.10. 
(i) 
Conclude from the previous exercise that maps E ^ N in PER can be 
identified with r.e. subsets of N. 
(ii) Check that maps R —)• 2 {= 1 + 1) can be identified with recursive 
subsets of N. 
E 
5.2.3. 
Consider a fibration 
-^P and a functor F: A —>• IB with a right adjoint, and 
the resulting fibration F*(p) obtained by change-of-base along F. 
(i) 
Assume first that p is split and has a split generic object. Show that 
F*{p) also has a split generic object, 
(ii) Assume next that p has a generic object, and show that F*{p) also has 
a generic object. 
E 
5.2.4. 
Let 
^P be a split fibration on a base category with Cartesian products. 
(i) 
Show that for an object / G B, the (split) exponent fibration dom/ =4^ p 
from Exercise 1.10.6 is isomorphic to the fibration obtained from p by 
change-of-base along / x ( —): IB —)• B. 
(ii) Conclude that p has spht simple products/coproducts if and only if 
each diagonal functor p —)• (dom/ ^ p) has a spht fibred right/left 
adjoint. 
5.2.5. 
Recall the category MS of metric spaces and non-expansive functions from 
Example 4.6.3 (iv), see also Exercise 4.6.2. A subset A C X of a metric 
space X is closedf each limit point of A is contained in A. 
(i) 
Check that these closed subsets are stable under pullback. Organise 
them in a (poset) fibration over MS. 
(ii) Show that for a closed subset A C X there is a characteristic metric 
predicate XA'X -^ [0, oo] forming a pullback diagram, 
A 
^ 1 
Y 
I 
Y 
0 
X 
^ [0, oo] 
XA 

330 
Chapter 5: Higher order predicate logic 
[Hint, Define XA{X) = inf{X(x, y) \ y e A}.] 
ClSub(MS) 
(iii) Conclude that the 
fibration 
i 
of closed subsets has a weak 
^ ^ 
^ 
^ 
MS 
generic object. 
(iv) Use this to show that the regular subobjects {i.e. those subobjects 
which have an equaliser as underlying mono) in MS are precisely the 
closed subsets. 
5.2.6. 
Prove Lemma 5.2.14. 
5.2.7. 
Show how the maps 3/ and V/ come about in Remark 5.2.12. 
E 
5.2.8. 
Consider a (split) fibration 
-^P with a (split) generic object Q on a Carte-
IB 
sian closed base category B. Prove that for a morphism u: / —)• J in B the 
following diagram commutes. 
EKXJ 
>• B(A^ X J, Q ) — ^ ^ B ( / C Q-^) 
(id X uY 
Q" 
o -
EA'X/ 
>• M{K X /, Q ) 
^ B ( / C , Q^) 
5.3 Fibrations for higher order logic 
In this section we define appropriate 'higher order' fibrations as models of 
higher order logic. Several examples are given as instances of a general "tripos" 
construction. But most importantly, a topos is defined as a category B for 
Sub(l) 
which its subobject fibration 
4- 
is such a higher order fibration. This will 
B 
turn out to be a powerful notion. It can be defined in various other and more 
elementary ways (as will be shown in the next two sections), but the approach 
via higher order fibrations is appropriate from a purely logical perspective. 
Towards the end of this section we also describe the higher order fibrations 
resulting from regular subobjects in the categories of u;-sets and of PERs. 
Definition 5.1.3 in the first section of this chapter describes higher order 
logic. The aspects which are not captured in first order fibrations (as described 
in the previous chapter) are the presence of a type Prop of propositions and 
of exponent types. 
5.3.1. Definition. A higher order fibration is a first order fibration with 
• a generic object; 
• a Cartesian closed base category. 

Section 5.3: Fibrations for higher order logic 
331 
Such a higher order fibration will be called split if the fibration is split and 
all of its fibred structure (including the generic object) is split. 
5.3.2. Examples. For a frame (or, a complete Heyting algebra) 
X, the 
Fam(X) 
family fibration 
i 
is a split higher order fibration. It is a first order 
Sets 
fibration as described in Example 4.2.5 and has the underlying set X G Sets 
as split generic object by Examples 5.2.3 (i) and (ii). Obviously, the base 
category Sets is Cartesian closed. 
UFam(PN) 
In a similar way, the realisability fibration 
4- 
from Example 4.2.6 is 
Sets 
a split higher order fibration. Its split generic object is the set PN G Sets. 
We need not say much about the interpretation of higher order logic in 
higher order fibrations, since we have already seen how to interpret simply 
typed A-calculus in Cartesian closed categories, and predicate logic in (pre-
order) fibrations. But there is something to say about the extensionality of 
entailment rule 
r \- P,Q:a^ 
Prop 
T,x:a\ 0, Px h Qx 
T,x:a\ 
6, Qx h Px 
r I 6 h p =,^p,op Q 
Fam(X) 
since it may fail. In a family fibration 
i 
of a frame X, the assumptions 
Sets 
of this rule applied to predicates P,Q\ J zz^ X^ in Sets express that 
PUm 
< Qm^ 
and 
Q(i)(i) < P(j)ii), 
for all j E J and i G /—where < is the order on X. Hence we may conclude 
that P = Q, 3,8 required (since internal and external equality coincides). 
UFam(PN) 
In the realisability fibration 
i 
the same assumptions for P, Q: J =1 
Sets 
{PNY 
yield that 
n 
^o')(o 3 Q{j){i) 1^0, I n ^w(o ^ pum I / 0-
^{j,i)eJxi 
/ 
\u,i)eJxi 
/ 
This means that there are realisers inhabiting P{j){i) D Q{j){i) and Q(j){i) D 
P{j){i), for all j , i. But this is not enough to conclude P — Q: take for example 
P zrz %j e J.%1 G /. {0} and Q = \j 
e J.%i G /-{l}- In this realisability 
example the truth of a proposition (^ C PN means 9:? 7^ 0, which is not the 
same as (^ = T, since T — PN. Hence, this realisability fibration is not a 
model of higher order logic with extensional entailment. 
These examples both form instances of what is called a tripos in [145, 267]. 
Mostly, these triposes are considered with Sets as base category. We recall 

332 
Chapter 5: Higher order predicate logic 
that in a higher order fibration we require 'simple' quantification ]J, fl along 
Cartesian projections. By the constructions in Examples 4.3.7 (i) and (ii) we 
then get quantification ]J^, JJ^ along arbitrary maps u in the base category, 
but Beck-Chevalley need not hold for these. This Beck-Chevalley condition is 
required explicitly for triposes, although it is not needed to model higher order 
simple predicate logic (but it does lead to a model of higher order dependent 
predicate logic, as in Proposition 11.2.2 (ii)). 
, 
E 
5.3.3. Definition (See [145, 267]). A tripos is a higher order fibration cl-
over Sets for which the induced products f]^ and coproducts JJ^ along an 
arbitrary function u satisfy the Beck-Chevalley condition. 
(By Lemma 1.9.7 it suffices that Beck-Chevalley holds either for products 
or for coproducts.) 
These triposes are mostly used as an intermediate step in the construction 
of certain toposes (see Section 6.1). But [267] is a study of "tripos theory" on 
its own. 
5.3.4. Example (Triposes built from partial combinatory algebras). A par-
tial combinatory algebra (PCA) consists of a set A together with a partial 
application function -: A x A —^ A and two elements K, S ^ A such that 
Kxl, 
Sx]., 
Sxyl 
and 
Kxyc::^x, 
Sxyz'2:^ xz{yz), 
where P^ means that P is defined and where Kleene equality P c:i Q means 
that P is defined if and only if Q is defined, and in that case they are equal. 
As above, we often omit the application dot •. The element / = SKK 
G A 
satisfies la = a, for all a E ^. Examples of PC As include the natural numbers 
N with Kleene application • and all models of the untyped A-calculus, see [32] 
for more information. 
For such a PCA [A, •) one can prove combinatory completeness: for every 
polynomial term M(xi,..., x„) built from variables a^i,..., x„, constants cfor 
c G v4, and application •, there is an element a E A such that for all elements 
6i,. ..,6n E v4, 
a6i--.6n-[[M]l(6i,...,6„), 
where [[MJ is the function A^ ^ A obtained by interpreting the polynomial 
M. One uses Schonfinkels abstraction rules: 
Xx.x = 1= 
SKK 
\x. M - KM 
if X is not free in M 
Xx.MN 
= 
S{Xx.M)(Xx.N). 
Then one takes a = Xxi - - -Xn-M to get combinatory completeness. 

Section 
5.3: Fihrations 
for higher order logic 
333 
In this way one can define pairing in PCAs as in the untyped A-calculus: 
def 
a, 6) = \z. zab := 
S(SI{Ka)){Kb) 
with projections 
def 
^ 
nc — cK 
and 
7T'C^=C{KI). 
Then n{a, h) — a and 7r'(a, b) — b. 
UFam(PA) 
In [145] it is shown how each such PCA A gives rise to a tripos 
4-
Sets 
As predicates on a set / one takes functions (p: I -^ PA. These are pre-ordered 
by the relation h, given as: 
^ ^V^ ^ (f]^{i)Dm] 
/0 
where for subsets X,Y C A, 
X DY = {f eA\^aeX.f'ai 
a n d / . a e y } . 
Notice the uniformity: for (f \- ^p to hold, there must be a single "realiser' 
a ^ A with a G (p{i) D ip{i) for all i E /. 
There are the usual propositional connectives for these predicates on /: 
T/ = %ie 
LA 
(f Atj; = Xi e I. {{a, b) \a e (f{i) and 6 G i^[i)) 
pWiP = MeL 
{{K, a)\ae 
^{i)} U {{KI, b) \ b e i^{i)} 
^ D ^ = Me L(p{i) D i^[i). 
We show that V is join and leave the other cases as exercises. We have (p h 
9? V V^, since 
and similarly ^ \- ip y ip. Next suppose we have <p ^ x ^-nd ^ H x? say via 
realisers 
fef] 
^{i) D x(0 
and 
gef] 
^(i) D x(0-
i£l 
iel 
Then 
h - Xz. (/,^)(7r.)(7r'z) G Qlv^ V V^)(i) D x{i)-
Indeed, if {K, a) £ {(pV ^)(i), with a G ^(i), then 
/i(ii:, a) = (/, g)Ka = 7r(/, ^)a - fa E x(0 

334 
Chapter 5: Higher order predicate logic 
and similarly h{KI, b) = gb E xlO-
For a predicate (f: I x J ^ PA, we define an equality predicate Eq(<^) by 
Then it can be shown that Eq(9?) \- i/j <^ ip \- S{I,J)*{ip). 
This yields 
equality. Finally, for a function w: / —> J in Sets and a predicate (p: I -^ PA, 
we put 
n.(v^) = 
^jeJ.f]{u{i)^jj)D^{i) 
UuM 
= 
^jeJ.[j{u{i)=jj)A^{i) 
where 
(u(i) =j j) = Eq{u o TT, 7r')ii,j) = | ^ ^If^ 
= ^ 
(In case 7 = 0, the above intersection over / equals A.) Then one easily 
checks that xp h flul^) O {i^ ^ u) \- (p and ]J^(<^) \- ip <=> (f h [ip o u). 
Beck-Chevalley holds for these products and coproducts. 
It may be clear that if we apply this construction to the PC A (N, •) with • 
UFam(PN) 
for Kleene application, then we get the realisability tripos 
i 
which 
was first introduced in Example 4.2.6. But the construction also yields 'realis-
ability triposes' starting from models of the untyped A-calculus, like {Doo, •) or 
{Pto, •); the latter (and especially the resulting topos) is investigated in [261] 
within 'synthetic domain theory'. 
There are variations on the above construction: in [147] the starting point is 
a 'right-absorptive C-PCA' which serves as a bases for a tripos using modified 
realisability. The resulting topos (as in Section 6.1) is used to give generic 
proofs of strong normalisation for various typed A-calculi. In [239, Chapter IV] 
a tripos is constructed which captures another version of realisability, namely 
Lifschitz' realisability—and the resulting topos is studied. 
Next we turn to an important class of examples of higher order fibrations. 
5.3.5. Definition. A topos is a category IB with finite limits such that its 
Sub(l) 
subobject 
fibration 
i 
is a (split) higher order fibration. 
The subobject fibration of a topos thus has a generic object. In this situation 
with a poset fibration it does not matter whether we call this generic object 
'split' or not. The same applies for the rest of the higher order structure. 
Such a generic object corresponds to a 'subobject classifier', which gives 
a correspondence between subobjects and characteristic maps, as in Exam-

Section 5.3: Fibrations for higher order logic 
335 
pie 5.2.3 (ii). This will be made explicit in the next result. It forms the core 
of a more elementary description of toposes in the next section. 
Sub(B) 
5.3.6. Lemma. A subobject 
fibration 
I 
has a (split) generic 
object if 
and only if M has a subobject classifier. The latter is a (monic) 
map 
true: I ^ 
Vt such for each mono m: X >-^ I there is a unique 
^character-
istic' or 'classifying' 
morphism 
char(m): / —)• Q forming 
a pullback 
diagram, 
X 
— 
-^ 1 
char(m) 
true 
- ^ Q 
Sub(l) 
Proof. By Lemma 5.2.2 the 
fibration 
i 
has a split generic object if 
and only if there is a subobject true: fio ^-^ ^ such that for each subobject 
m: X ^^ I there is a unique map char(m): I ^ 
Q with char(m)*(true) = m, 
as subobjects. The latter means that there is a pullback diagram, 
X 
m y j 
^ 0 
Y 
true 
char(m) 
- ^ Q 
Thus if IB has a subobject classifier true: 1 ^ 
^2 as in the lemma, then the 
subobject fibration obviously has a split generic object. The converse holds if 
we can show that for the above mono true: QQ ^^ ^ the object CIQ is terminal. 
This will be done: for each object / G B, the identity mono I y-^ I yields a 
unique map / = char(id): / —> Q and a pullback diagram as on the left below. 
Thus we have at least one map / ' : / —>• QQ. If also g: I -> QQ, then we get a 
pullback as on the right, since true is a mono. 
id 
/ 
yj 
r 
Y 
true 
/ 
-^fi 
true 
true o g 
But then by uniqueness / = true o g. Hence g = f, 
since true o g — f = 
true o / ' and true is monic. 
• 

336 
Chapter 5: Higher order predicate logic 
The above notion of subobject classifier was first formulated by Lawvere 
and Tierney in 1969 in their axiomatisation of set theory and sheaf theory. 
Here we treat a subobject classifier as an instance of a generic object. More 
about toposes may be found in the next few sections. At this stage we only 
mention that the category of sets is a topos. The subobject classifier is the 
generic object 1 ^ 2 described in Example 5.2.3 (ii). 
In toposes the extensionality of entailment rule from Section 5.1 comes for 
free. 
5.3.7. Lemma. The subobject fibration of a topos is a model of higher order 
logic with extensional 
entailment. 
Proof. Assume IB is a topos, and let f,g: J nt ^^ be predicates satisfying the 
assumptions of the extensionality of entailment rule. This means that 
(ev o / X id)*(true) = (ev o ^ x id)*(true), 
as subobjects of J x /. But then, by uniqueness, one gets ev o / x id = ev o 
g X id, and thus f = g. 
Q 
We mention two further examples of a higher order fibration, involving the 
fibration of regular subobjects (see Exercise 1.3.6) in the categories of a;-sets 
RegSub(l) 
and of PERs. It is left to the reader to check that a split 
fibration 
4-
of regular subobjects in a category IB with finite limits has a (split) generic 
object if and only if the category B has a regular subobject classifier: a 
regular mono true: 1 >-^ Q such that for any regular mono m: T >-^ I there is 
a unique classifying map / —> Q which yields m as pullback of true. 
5.3.8. Lemma. Consider the category u;-Sets of uj-sets described in Sec-
tion 1.2. Recall that it comes with a left adjoint V: Sets -> a;-Sets to the 
forgetful functor (/, E) »-> /. 
(i) Regular subobjects of an object {I,E) G cj-Sets correspond to subsets 
X C I, with existence predicate inherited from 
{I,E). 
RegSub(a;-Sets) 
(ii) The fibration 
i 
of regular subobjects in u;-Sets has V2 G 
u;-Sets as (split) generic object—where 2 = {±, T}. 
Proof, (i) Given an object (/, E) G cj-Sets and a subset X C I of its carrier 
set, consider its characteristic function / -^ 2 and the function 7 -> 2 which is 
constantly T G 2. These form a pair of parallel maps (/, E) =| V2 in u;-Sets, 
the equaliser of which is given by the inclusion {X, E \ X) >-^ (7, E). 
Conversely, if m: (X, Ex) ^^ (7, Ej) is equaliser of /, g: (7, Ej) izj (J, Ej), 
then X' = {i ^ I \ f{i) = g{i)} C 7 comes with an inclusion (X', Ej \ X') ^^ 
{I,Ej) 
which equalises f^g. Therefore it must be isomorphic to m. 

Section 5.3: Fihrations for higher order logic 
337 
(ii) For (/, E) G cj-Sets, there are isomorphisms between the sets of 
(a) regular subobjects of (/, E) 
(b) subsets X C I 
(c) functions / -^ 2 in Sets 
(d) morphisms (/, E) —)- V2 in cj-Sets 
Thus V2 E a;-Sets is a split generic object for the fibration of regular subob-
jects. 
• 
5.3.9. Proposition. The regular subobjects in u;-Sets give rise to a split 
RegSub(C<;-Sets) 
higher order 
fibration 
i 
. Its logic is classical. 
u;-Sets 
Proof. The generic object comes from the previous lemma. Fibred finite 
conjunctions and disjunctions are given by finite intersections and unions. 
The exponent X ^ 
Y oi X,Y 
C I for {I,E) 
E cj-Sets is given by 
X ^Y 
= {I-X)[JY. 
Thus the negation ^X oi X is its complement 
{I-X). 
Quantification along a projection n: (/, E) x (J, E) —^ (/, E) in a;-Sets are 
also given by the set theoretic formulas: 
product: 
{X C I x J) ^ 
{i E / | Vj G J. {ij) G X} 
coproduct: 
{X C I x J) ^ 
{i G / | Bj G </. {ij) EX}. 
D 
This will turn out to be an instance of a more general result: the regular 
subobject fibration of a category of separated objects in a topos is a higher 
order fibration with classical logic, see Corollary 5.7.12. This general result 
applies, since cj-Sets will turn out to be the category of regular objects in the 
eff'ective topos EfF, see Section 6.2. 
The situation for regular subobjects in the category P E R is difi'erent. 
5.3.10. Proposition. Regular subobjects in the category P E R form a first 
order fibration, but not a higher order fibration. 
RegSub(PER) 
Proof. The first order structure of the 
fibration 
i 
is described 
PER 
in Proposition 4.5.7. Here we show that it does not have a generic object, 
following an argument due to Streicher. Suppose, towards a contradiction, 
that Q G P E R is a generic object. Then for R G P E R there should be 
isomorphisms 
PER(i?, Q) ^ 
RegSub(i^) 
^ P{N/R) 
by Proposition 4.5.7 (i). 
The homset PER(i?, fi), like any homset in PER, is countable. But the 
powerset P{N/R) can be uncountable, for example if ii is the natural numbers 
object A^ = (Eq(N) C N x N) with quotient E/N ^ N. 
D 

338 
Chapter 5: Higher order predicate logic 
We conclude by noting that these fibrations of regular subobjects in u;-Sets 
and in P E R arise in the following change-of-base situations. 
RegSub(PER) 
^ RegSub(a;-Sets) 
^ Sub(Sets) = F r e d 
J 
J 
P E R ^ 
^ u;-Sets ^ 
^ Sets 
Exercises 
5.3.1. 
Verify that N with Kleene application • is a PCA. 
5.3.2. 
Check some more details in the realisability tripos construction in Exam-
ple 5.3.4, especicJly, 
(i) 
that the connectives T, ±, A, D in the fibre have the required properties; 
(ii) that fl^,]J[^ are right and left adjoint to substitution u*; 
(iii) that Beck-Che valley holds for these products and coproducts. 
5.3.3. 
Show that the category of finite sets is a topos. 
E 
5.3.4. 
Let 
^P be a higher order fibration, say with generic object T ^lE^. For 
IB 
parallel morphisms w, f: / =^ Q put u < v if and only if u*{T) < v*{T) in 
the fibre over /. 
(i) 
Show that each homset ]B(/, U) is a Heyting pre-algebra. 
[Hint. Use Remark 5.2.12.] 
(ii) Show that Q is internally complete and cocomplete in the following 
sense. For each pair of objects /, J G B, the functor (between preorders) 
$(/, Q ) 
^ B ( / X J, 
Q) 
has both a right and a left adjoint, 
(iii) Assume that the equaliser exists of A, TT: Q x Q iz^ Q and write it as 
< ^^ Q X Q—where A is the induced conjunction map on Q as in 
Remark 5.2.12. Prove that for u,v:I 
=4 ^ one has u < i; as above if 
and only if (u^v): I —^ Q x Q factors through < ^-^ Q x Q. 
5.3.5. 
Prove that a category B with finite limits has a regular subobject classifier 
RegSub(B) 
if and only if its regular subobject 
fibration 
i 
has a (split) generic 
IB 
object. 
5.4 Elementary 
toposes 
In the previous section we introduced toposes as categories whose subobject 
fibrations 
are higher order fibrations. This gives a distinctly logical description 

Section 5.4: Elementary 
toposes 
339 
of toposes. It turns out that there are more elementary formulations of this 
notion. The first alternative formulation will be given below. We will show that 
it is equivalent to the previous definition. This involves some basic (logical) 
constructions in toposes. Two other alternatives will be discussed in the next 
section 
There is much more to say about toposes than the few logical aspects that 
we touch upon below, and in the next four sections. Here, we merely collect 
some useful facts for the readers convenience, mainly as a preparation for 
the effective topos EfF, to be introduced in the next chapter. Not all details 
are given; more information may be found in the extensive literature, see 
e.g. [188, 169, 18, 24, 218] and the references given there. 
5.4.1. Definition, (i) An (elementary) topos is a category IB which has 
• finite limits; 
• exponents (so that B is Cartesian closed); 
• a subobject classifier true: 1 ^-» fi. Thus for each mono m: X >-> /, there is 
a unique characteristic map char(m): I -^ Q with m = char(m)*(true), as 
in. 
m 
X 
— 
-^ 1 
Y 
true 
char(m) 
-^Q 
(ii) A logical morphism between two toposes B, B' is a functor F : B —)• W 
which preserves finite limits, exponents and the subobject classifier. The latter 
means that the canonical map FQ —^ Q' is an isomorphism in 
F(true 
F ( l ) = 
FQ 
true' 
-^Q^ 
Su 
We can immediately see (by Lemma 5.3.6) that if a subobject fibration 
i 
is a higher order fibration—so that B is a topos as defined in the 
previous section—then B is an elementary topos. Our aim in this section is 
to prove that the converse also holds, i.e. that the elementary description 
coincides with the logical description. 

340 
Chapter 5: Higher order predicate logic 
5.4.2. Example. As we have already seen in the previous section, the cate-
gory Sets is a topos with subobject classifier 
true = %x. 1 
f^ .-, 
1 > 
^ {0,1} = 2 
More generally, for each locally small category C, the category C = Sets^°^ 
of presheaves C^^ -> Sets and natural transformations between them, is a 
topos. Finite limits are computed pointwise as in Sets. The exponents and 
subobject classifier are obtained via the Yoneda Lemma, as will be sketched. 
For presheaves F, G: C?P =t Sets, the exponent F => G: C°P ^ Sets should 
satisfy 
{F^G)[X) 
^ C(C(-,X), F^G) 
by Yoneda 
^ C(C(-,X) X F, G) 
because F ^ G \s exponent. 
Therefore, one simply defines, 
(F => G)(X) t^ C(C(-,X) X F, G ) . 
The verification that this indeed yields exponents in C is a bit involved, but 
in essence straightforward. 
A subobject S >-> C(—,X) of a representable presheaf C(—,X) can be 
identified with a sieve on X G C. That is, with a set S of arrows with 
codomain X {i.e. S C Obj C/X) which is "down closed": 
^—^ 
inC I ^ 
/ O ^ G 5 
fesj 
Thus an appropriate presheaf Q: C°P -> Sets should satisfy 
Q(X) ^ C(C(-,X), Q ) 
by Yoneda 
= Sub(^C(—,X)j 
because Q classifies subobjects 
= {5 I 5 is a sieve on X}. 
Hence one simply puts 
Q(X) = {5 I 5 is a sieve on X}. 
And for a morphism f:X 
-^ Y in C there is a map fi(/):Q(X) —> ^{Y) 
defined by 
(F, sieve on Y) y-^ {g:Y ^ X \ f o g 
eT}. 
The generic subobject true: 1 -^ fi is then given by maximal sieves: 
truex(*) = i X = {/ G ArrC I cod(/) = X}. 

Section 5.4: Elementary toposes 
341 
We leave it as an exercise to verify all remaining details. 
5.4.3. Notation. In a topos, we write PI for the power object Q^. It comes 
equipped with a membership predicate E/ >—^ PI x /; it is the subobject 
corresponding to the evaluation map ev: PI x / -4- ^2 as ev*(true). For maps 
x: J ^ I and a: J -^ PI we can then write 
X Ej a <=> (a, x) factors through E/ >-^ PI x /. 
Also there is a singleton map {}:/—)• PI, obtained in the following way. 
The diagonal morphism S{I) = (id, i d ) : / ^^ I x I on I has a characteristic 
map char(^(/)):/ x I ^ 
Q. The exponential transpose of the latter is the 
singleton map: 
A(char(J(/)) 
{ } =^ ( / 
^ Q^ = 
PI) 
Next, consider this singleton map in the mono ({ }, id): / ^-> PI x /, and its 
characteristic map PI x / —> Q. Exponentiation yields a morphism s: PI 
-^ 
PL 
Informally, s{a) — {x \ [x] — a]. We form the lift object J_/ via the 
equaliser: 
s 
U> 
^ PI^ 
^ PI 
id 
In Sets, the power exponent 2^ is the ordinary powerset PI of /. And LI 
is the lift of /: the pointed set LI = {0} U {{i} \ i e 1} C PI obtained from 
/ by adding a base point. Partial functions J -^ I between sets correspond 
to total functions J -^ LI. This will be generalised to arbitrary toposes. But 
first we need an elementary result. 
5.4.4. Lemma, (i) The singleton 
map {}:/—>• PI is monic. 
(ii) The singleton 
map { } factors 
through LI ^-^ PI, i.e. it restricts to a 
map {}: I ^ LI, 
which is a mono again by (i). 
As a result of this lemma, x is the only element of {x} = { } o x, see 
Exercise 5.4.3 below. 
Proof, (i) Assume parallel maps u,v:J 
z4 I with {} o u = {} o v. Then 
one gets char(^(/)) o w x id = char(^(X)) o v x id = w, say. Consider the 
corresponding subobject w;*(true) in, 

342 
Chapter 5: Higher order predicate logic 
I/;* (true) 
true 
Both {u,id):I 
>-^ J x / and {v/id):I 
^^ J x / are obtained by pullback of 
true along w—since 
(w,id) = {ux id)*((J(/)) 
and 
(t;,id) = {v x id)*(J(/)). 
Hence (w, id) = {v, id), as subobjects of J x /, and so u = v. 
(ii) We have to show that 5 o { } = { }, where s: PI -^ PI is as introduced 
in Notation 5.4.3. We compute: 
so{} 
= A(char(({ }, id) o { } x id) ^ A(char((J(/)) = { } 
where the equality (*) comes from the fact that the left square (**) below is 
a pullback by (i). 
S(I) 
I X I>-
I 
({},id> 
t 
-^ PI X I 
-^ 1 
Y 
true 
Q 
{ } X id 
char({ },id) 
Categorically, a partial map / —^ J is (an equivalence class of) a span 
m 
I 
^ 
^X 
-^ J 
It tells that u is defined on a subset X of /. Two such spans I <—< X -^ J 
n 
y 
and / ^-^ y —)• J are equivalent if there is a necessarily unique isomorphism 
(p:X ^Y 
with n o (f — m and v o ip — u. ksiov 
subobjects, one usually does 
not distinguish notationally between such a span and its equivalence class. 
5.4.5. Proposition. The singleton 
map { } : J ^^ -LJ is a partial m a p 
classifier; for each partial map I ^-< X -^ J, there is a unique 
morphism 

Section 5.4: Elementary toposes 
343 
v: I ^ LJ forming 
a pullback 
square, 
X 
Proof. Given I ^^ X —> J^ consider the 'graph' mono {m,u):X 
^^ I x J, 
its characteristic map / x J -> Q, and the resulting exponential transpose 
I -^Q-^ = PJ. The latter factors through I J >-> PJ. 
D 
5.4.6. Corollary. The assignment 
I \-^ 1.1 is functorial, 
and the 
singleton 
maps {}:/—> ± 7 are components 
of a natural transformation 
id => _L. 
Proof. For a map u: I ^ J, there is a partial map ± 7 ^< I ^ J and thus a 
unique morphism J-u: ± 7 —> ± J, in a pullback square 
D 
Such classification of partial maps is an important first step in the axioma-
tisation of domain theory, see e.g. [144, 81, 259], and also [296]. 
Next we are going to show that every topos is locally Cartesian closed 
{i.e. that all of its slice categories are Cartesian closed). In Sets, the expo-
nent in the slice Sets/7 of two 7-indexed families {Xi)i^j 
and (Yi)i^j 
is the 
pointwise exponent (function space) (Xf => Yi)i^i. 
It can alternatively be de-
scribed in terms of suitable partial maps f:X 
^Y, 
namely those / with for 
all X Ei Xi, f{x) 
is defined and f{x) E Yi. This will be used below. 
5.4.7. Proposition. A topos is a locally Cartesian 
closed category 
(LCCC). 
A logical morphism 
preserves 
the 
LCCC-structure. 
Proof. A topos IB has finite limits by definition, so that each slice category 
B/7 has finite limits. We only have to show that IB/7 is Cartesian closed. 
/ 
X 
\ 
( 
^ 
\ 
Assume therefore families I 
y^ 
I and I 
i 
1 • ^ ^ ^hen have a partial 
map I X X ^ I, namely 
{(f, id) 
(p 
I X X ^ 
<X 
^ 7 

344 
Chapter 5: Higher order predicate logic 
Let it be classified by ^: / x X —> ±7. We define the exponent family (f ^ tp 
to be 
W 
(f => i) J 
A(^) 
{Li>)^ = A(±V o ev) 
t 
For an arbitrary family 
Z 
we have to establish a bijective correspon-
dence between maps f'-X >^ ^ ~^ i^ ^^^ 9'X~^{f=^i^) 
^^ W^- ^^ arises as 
follows. 
• Given f: Z Xj X ^ Y , 
consider the partial map Z x X 
^^Y, 
Z X X ^ 
<Z 
XjX 
f -^Y 
It induces a map f:Z 
xX 
^ 1.Y, and hence A(/): Z -^ {±Y)^. 
The latter, 
together with x- ^ —^ ^ yields a mediating map Z —> W with respect to 
the above pullback. It is the map we want. 
• Conversely, given g: Z —^ W, one obtains the appropriate map Z XjX 
—> Y 
in. 
Z XTX> 
^ Z X 
X 
g 
xid 
X id 
X X V ? 
These exponents in the slices are preserved by logical morphisms, because 
they are defined in terms of the topos structure as in Definition 5.4.1. 
D 
This result has important consequences for the codomain and subobject 
fibrations of a topos. 
5.4.8. Corollary. / / B is a topos, then its codomain 
fibration 
^ 
is fibre-
wise a topos: each fibre M/I is a topos and reindexing functors 
u* are logical 
morphisms 
(they preserve the topos 
structure). 

Section 5.4- Elementary toposes 
345 
Proof. Each slice has finite limits and exponents; the latter by the previ-
ous result. And if true: 1 ^^ Q is subobject classifier in B, then the map 
/*(true) = id X true: I x 1 ^ / x Q i s a morphism between families, 
r ( t r u e ) 
/ ^ > < ^ \ 
f f )-/*(«) 
which is a subobject classifier in B / / . The proof uses that a map between 
families in B / / is a mono in B / / if and only if it is a mono in B. 
Obviously, pullback functors preserve all this structure. 
• 
Sub(B) 
5.4.9. Corollary. / / B 25 a topos, then its subobject fibration 
i 
is a 
higher order 
fibration. 
A category B is thus a topos as in Definition 5.4.1 in this section if and only 
if B is a topos as defined in the previous section. 
Proof. Because a topos B is locally Cartesian closed, each pullback func-
tor u*:M/J 
-^ B / / has a right adjoint f ] ^ , by Proposition 1.9.8 (iii). These 
functors fl^ restrict to functors flu-S^t)(/) -^ Sub(J), because right adjoints 
preserves monos. With these products we can define implication D as in the 
proof of Theorem 4.5.5. Thus, in the subobject fibration of a topos, we already 
have r^, V, D, A, T and =. The latter three always exist in subobject 
fibrations. 
The missing logical operations -L, V,3 are then definable, using Q,V and D, 
as in Example 5.1.4. Thus we have a higher order subobject 
fibration. 
D 
Exercises 
5.4.1. 
Use characteristic maps to show that each mono in a topos is a regular 
mono. Conclude that a map in a topos which is both a mono and an epi is an 
isomorphism. Categories with this property are sometimes called balanced. 
5.4.2. 
Check that the constructions described in Example 5.4.2 indeed yield a 
topos of presheaves Sets 
. Describe the subobject classifier true: 1 —)• Q 
for C is (a) a monoid, (b) 2 = (• -^ •), (c) N = ( • ^ • - > • - ) • • • •), and 
(d) an arbitrary poset, 
5.4.3. 
Show that for 'generalised elements' x,y: J ^ I in a topos, one has 
^ ^i {y} ^ X = y 
where {y} = { } o y: J -> PI. 
5.4.4. 
Show that 
(i) 
{}:1 ^ H i s true:l >-^ Q; 
(ii) LI >-^ PI is a split mono. 

346 
Chapter 5: Higher order predicate logic 
5.4.5. 
(From [169, 1.45]) For an object / in a topos, consider / as family over 
1, and form the product Iltrue^^) °^^^ ^ along true: 1 -)• Q. Notice that 
( j 1 can be obtained as puUback true* ( A 1, where / ^ 0 is true o !. 
There is thus a unit map / -> ntrue(^)' Prove that it gives an alternative 
description of the partial map classifier { } : / - > ±7. 
5.4.6. 
In the subobject fibration of a topos there are implication D operations in 
the fibres. It induces a map 3:17 x Q —)• fi, like in Remark 5.2.12. Prove 
that this map D is the classifying map of the order < ^-> Q x Q, obtained 
as equaliser of A, TT: Q x Q z^ Q. 
5.4.7. 
Verify that a logical morphism preserves images. More generally, that a log-
ical morphism between toposes yields a morphism preserving the structure 
of the corresponding higher order subobject fibrations. 
5.5 CoUmits, powerobjects and well-poweredness in a topos 
In this section we mention some further results on toposes, which are of less 
importance for the main line of this book. They involve two more alternative 
formulations of the notion of topos: one involving powerobjects PI = Q^, 
and one involving well-poweredness of the associated codomain fibration (in 
a fibred sense). Also we show that every topos has finite colimits. The proof 
involves some special properties of subobject 
fibrations. 
We start with powerobjects. 
5.5.1. Theorem. A category B is a topos if and only if it has both 
• finite 
limits; 
• power objects;/or each object I there is a power object PI together 
with 
a ''membership^' 
relation £i >-^ PI x / which is universal 
in the 
following 
sense: for each relation R >-^ J x I there is a unique 
''relation 
classifier^' 
r: J —^ PI forming 
a pullback 
square, 
R 
^ G / 
Y 
I 
Y 
J X / 
^ 
PIxI 
r X id 
One thinks of r: J -> PI as j ^ {i £ I \ R{j, 
i)}. 
Proof. If B is a topos, then one takes PI 
= fi^ and G/ as classifier of 
evaluation, as in Notation 5.4.3. Every relation R >-^ J x /, as a mono, 
has a classifying map c h a r ( i ? ) : J x / 
-> Q and thus we obtain a map 

Section 5.5: Colimits, powerobjects and well-poweredness in a topos 
347 
fi^ = PI by abstraction. The outer rectangle below 
r = A(char(i?)): J 
is a pullback: 
R 
V 
J X I 
r X id 
PIx 
I 
• * 
1 
V 
true 
char(i?) 
so that we can conclude from the Pullback Lemma that the rectangle on the 
left is a pullback. 
In the reverse direction, if one has powerobjects, then the relation Gi : 1 ^-^ 
P l x l = P l i s a s u b o b j e c t classifier. Further, exponents J^ can be constructed 
as suitable subobjects J^ y-^ P{I x J) of relations which are both single-valued 
and total. For the details, see e.g. [188, IV, 2]. 
• 
This result gives the most economical formulation of 'topos'; it is due to 
Kock. It is remarkable that the above two requirements suffice to give us all 
of the structure of higher order logic. 
We also like to mention that taking powerobjects is functorial (and yields 
a monad, see Exercise 5.5.2 below). 
5.5.2. P r o p o s i t i o n . For a topos M, the assignment 
I H-> PI 
extends 
to a 
functor B —> B. The singleton 
maps {}/:/—> PI are components 
of a natural 
transformation 
idi => P. 
Proof. For a morphism u: I -^ J, consider the image Uidxw(^/) ^~^ ^^ ^ ^ 
of the composite 
E/ > 
^ PI 
xl 
\dx 
u 
-^ PI X J 
By the previous result, there is a unique classifying map P{u): PI -^ PJ in a 
pullback square 
Y J 
PIx 
J 
Y 
^ 
PJ X J 
P{u) X id 
We get P(u) o { } / = {}J o w: / -^ P J , because both maps classify the 

348 
Chapter 5: Higher order predicate logic 
same relation, namely the graph (id, u): / ^^ / x J of u, in: 
u 
I — 
(id, u) 
IxJ 
^ J — 
"J 
u X id 
S{I) 
-^JxJ 
{ } J X id 
V 
-^ PJx J 
and 
/ — 
(id, u) 
IxJ-
-* IJidx«(€/) 
J 
-*€j 
-^ PI 
xJ 
-* 
PJxJ 
{ }/ X id 
P(u) X id 
where in the latter case the square on the left is a pullback by Beck-Chevalley: 
( { } / x i d r a , , j G / ) 
- 
U.dx.(({}/xidr(E/)) 
^ (id,w). 
D 
We turn to finite colimits in a topos. Remarkably, they come for free. To 
see this we need the following auxiliary result. 
5.5.3. Lemma. Since a topos is a coherent category, it has a strict initial ob-
ject 0, see Theorem 4-5.3. Write false: 1 —^ Q for the classifying map obtained 
in 
0 
^ 1 
y j 
true 
-^fi 
false 
For an arbitrary object I, put 0/ = A (false o TT): 1 ^^ PI. Then 0/ and the 
singleton map { }/: / ^^ PI are disjoint: there is a pullback square 
0:=— 
M 
-^ 1 
Y 
/ > -
ih 
^ 
PI 
Proof. Exercise. 
D 

Section 
5.5: Colimits, 
powerobjects 
and well-poweredness 
in a topos 
349 
5.5.4. Proposition. Each topos has finite colimits; 
they are preserved 
by 
pullback functors 
(i.e. they are universal^. 
Moreover, these colimits are preserved by logical morphisms 
between 
toposes. 
Proof. We already know that a topos has an initial object 0. For objects /, J 
consider the subobjects 
({ }/, 0j): I^PIxPJ 
and 
(0/, { ]j): I y-^ PI x PJ. 
By the previous lemma, these are disjoint. Hence their join IV J >-^ PI x PJ 
is / -f J ^-> P / X PJ by Exercise 4.5.1. 
(More informally, one constructs the coproduct / + J as the set 
{{a, b) G PI X PJ I (a is a singleton and b is empty) 
or [a is empty and 6 is a singleton)}. 
See also [186, 11,5, Exercise 2].) 
In order to show that a topos has coequalisers, we use Proposition 4.8.6 (ii), 
and construct for a relation {ro,ri):R 
^^ I x / a quotient object I/R. 
Let 
{fo,ri): 
R ^^ I X I he the least equivalence relation containing R; it may be 
obtained as in Lemma 5.1.8. Write r = A(char(i^)): / —>- PI for the relation 
classifier of R, and factor this map as 
We must show that maps I/R 
—> J are in bijective correspondence with maps 
of relations R —^ Eq( J), i.e. with maps u: I —> J satisfying u o ro = u o n. 
For i, z', j G / with R{i, i') one has a logical equivalence 
R{iJ)JOR{i'J) 
because R is symmetric and transitive. More categorically, one has an equality 
of subobjects, 
(ro X idy(R) 
= (Fi x idy(R) 
over 
RxL 
As a result, char(i?) o FQ x id = char(i?) o Fi x id, and so r o FQ = r o Fi. 
This gives us c o FQ = c o Fi, because r = m o c and m is a mono. We also 
get c o ro = c o ri, since R < R. Hence a morphism v: I/R 
—^ J gives rise to 
a morphism u — v o c: I -^ J with u o r^ — u o ri. 
And if we have a morphism u:I 
^ 
J with u o r^ — u o ri^ then 
R < [u X uY[5[J)) 
— Ker(i/). Since this kernel Ker(w) is an equivalence 
relation containing ii, we get R < Ker(w). The required mediating map 
I/R 
^ J is now obtained from the fact that covers are orthogonal to monos. 

350 
Chapter 5: Higher order predicate logic 
see Lemma 4.4.6 (vii), in a diagram: 
/ 
>I/R 
/ 
I m 
/ 
/ 
PI 
j> 
^ pj 
{}j 
The outer rectangle commutes, as may be concluded from the following com-
putation. 
{Piu)or){i) = 
P{u){{i'jI\Rii,i')}) 
= Mi') \R{i,i')} 
= {u{i)} 
by reflexivity of R 
Colimits in a topos are preserved by pullback functors u*, because each u* 
has a right adjoint f|^. And since these colimits are described in terms of the 
logical structure of a topos, they are preserved by logical morphisms between 
toposes. 
• 
In this proof we rely on logical tools. There is a more categorical argument 
due to' Pare: by using Beck's Theorem one can show that for a topos B, the 
opposite category W^ is monadic over IB. Thus W^ inherits limits from B, 
i.e. B inherits colimits. Details may be found in [188, 169, 18]. This proof has 
the advantage that it directly applies to non-finite colimits as well; they exist 
in a topos as soon as the corresponding limits exist. 
Notice that since colimits are stable under pullback, epimorphisms are pre-
served by pullback functors (since the fact that a map is an epi can be ex-
pressed in a pushout diagram). One can further show that coproducts are 
disjoint, but the argument is non-trivial, see e.g. [188, IV,6, Corollary 5]. 
5.5.5. Corollary. The epis in a topos are precisely the covers (I.e. the regular 
epimorphisms). 
Proof. Images can be constructed as in Exercise 4.4.8 and in Exam-
ple 5.1.9 (i). Explicitly, given a map u: I -^ J one forms the coequaliser 

Section 5.5: Colimits, powerobjects and well-poweredness in a topos 
351 
/ -» J ' of i/'s kernel pair I Xj I ^ I, as in, 
Ixjl 
^ 
^ 
/ 
"^ 
^ J 
— 
X . " 
J' 
Then J' -^ J is internally injective, as proved in Example 5.1.9 (i). In a 
subobject fibration this means that it is monic. In case u is an epi itself, then 
so is J' ^^ J. Hence the latter is an isomorphism (see Exercise 5.4.1). Thus 
every epi is a regular epi and hence a cover, see Lemma 4.4.6 (viii). 
D 
We turn to another characterisation of toposes, in terms of well-powered-
ness. An (ordinary) category C is called well-powered if for each object 
X E C the collection of subobjects of X is a small set (as opposed to a 
proper class). In a fibred definition of this concept the reference to small sets 
is eliminated and replaced by a reference to objects of a base category of a 
fibration. 
E 
For a fibration 
^P we say that a map in E is vertically monic if it is 
IB 
vertical, say in the fibre over /, and is a mono in this fibre category E/. We say 
that substitution functors preserve monos if for each morphism w: / —> J in 
IB and vertical mono m: X' ^^ X over J, one has that u* (m): u* {X') -^ 
u*{X) 
is vertically monic over /. In case substitution functors preserve fibred pull-
backs or have left adjoints, then they preserve monos. A vertical subobject 
is a subobject in a fibre category which comes from a vertical mono. Below 
we shall write VSub/(X) for the collection of vertical subobjects of an object 
X over /. 
E 
5.5.6. Definition. A fibration -j^P is said to be well-powered if both 
• substitution functors preserve monos; 
• for each X G E, say over / G B, the functor 
(]B//)op 
^ Sets 
given by 
( j - ^ 
/ ) 
H ^ VSubj(i/*(X)) 
is represent able. 
The latter means that for each X G E there is a map SX: Sub(X) —> / in 
IB together with a vertical mono s: X' >-^ tSX*(X) which is universal: for each 
u: J -^ I with a vertical mono m:Y 
^-^ ^*(^) over J, there is a unique map 

352 
Chapter 5: Higher order predicate logic 
v: J ^ Sub(X) in B with SX o v = u such that there is a commuting diagram 
Y 
^ X' 
Y 
Y 
m 
\ s 
u*{X) 
^SX*{X) 
where u*{X) —> SX*{X) 
is the unique Cartesian arrow over v with u*{X) —> 
SX*{X) 
^ X is u*{X) -^ X, so that Y —^ X' is uniquely determined. All 
this says is that there are isomorphisms 
M/l{u, 
Sx) 
^ VSubj(i/*(X)), 
natural in u: J ^ 
I. 
5.5.7. T h e o r e m (See also [246, 4.2.1]). A category B with finite limits is a 
topos if and only if its codomain 
fibration 
^ 
is 
well-powered. 
Proof. If the codomain fibration on B is well-powered, then for each object 
/ E B we have can view / has a constant family over the terminal object 
1 G B. We take as powerobject 
The isomorphism characterising well-poweredness gives us 
B ( J , P ( / ) ) S ] B / I ( ( ^ | ) , 
5 ( ^ | ) ) s V S u b j ( J ' ( / ) ) S S u b ( J x / ) . 
This shows that P(I) indeed behaves like a powerobject. 
Conversely, assume B is a topos. Since every slice category 
it carries a power object functor P/I:M/I 
—)• B / / . For a family 
a map u: J ^ I we then get isomorphisms 
M/l{u, 
P/I{^)) 
= Sub(w x / ^) ^ YSuhj{u*((p)). 
D 
Exercises 
5.5.1. 
Describe an 'undefined' element J./: 1 —)• LI. And prove that ±0 = 1. 
5.5.2. 
(i) Check that the assignment u H-> P{U) in Proposition 5.5.2 preserves 
identities and composites, 
(ii) Extend P to a monad on B with singleton maps { } as unit. 
[It can then be shown that algebras of this monad are the (internally) 
complete lattices in B, see [169, after Proposition 5.36].] 

Section 5.6: Nuclei in a topos 
353 
(iii) Extend also ± to a monad and show that the maps ±7 ^-> PI form a 
morphism of monads L >-^ P. 
[Algebras for this J_ monad are investigated in [179].] 
(iv) Define the non-empty power object P^ I >^ PI by the following 
puUback diagram, 
P + / 
{} = true 
and show that P^ also forms a submonad of P. 
5.5.3. 
Let B be a topos. For every object / G B we have a slice topos B / / , and 
thus a power object functor P/I:M/I 
-^ M/I. 
(i) 
Show that these fibrewise functors combine into one single fibred power 
object functor B"" ^ B"". 
(ii) Check that in the case where B = Sets, this fibred functor is given by 
(X.).e/ ^ (PX.).€/-
5.5.4. 
Prove in purely categorical terms that the rectangle in the proof of Propo-
sition 5.5.4 commutes. 
5.5.5. 
Consider an ordinary category C, recall Exercise 1.2.2, and prove that 
Fam(C) 
(i) 
substitution functors of the family 
fibration 
i 
always preserve 
vertical monos; 
Fam(C) 
(ii) the category C is well-powered if and only if its family 
fibration 
4-
Sets 
is well-powered. 
5,6 Nuclei in a topos 
In this section we describe nuclei (also called Lawvere-Tierney topologies) in 
a topos and study the associated closed and dense subobjects in some detail. 
We show in particular that the fibration of closed subobjects is a higher order 
fibration, just like the fibration of ordinary subobjects in the underlying topos. 
Thus we can do higher order logic with closed subobjects. For the special case 
of the double negation nucleus ->->, the logic of this fibration of -«-i-closed 
subobjects is classical: the entailment ->-i(f h (^ is (forced to be) valid. 
We start with the standard definition of a nucleus in a topos as a morphism 
j : Q -^ Q satisfying some special properties. An alternative, more logical, 
approach is possible in which a nucleus is introduced as an operation ^ \-^lp 

354 
Chapter 5: Higher order predicate logic 
on propositions, see Exercise 5.6.6 (and also [339]). This operation may also 
be studied as an operation of modal logic, see [103]. 
The conjunction operation A: fi x Q -> f} in the next definition arises as in 
Remark 5.2.12. 
5.6.1. Definition. In a topos, a nucleus (or Lawvere-Tierney topology) 
is a map j: Q —> fi making the following three diagrams commute. 
fi 
Q 
J X J 
Q X Q 
>- Q X Q 
fi 
true 
V true 
A 
A 
Q 
-^Q 
5.6.2. Example (Double negation). The example of a nucleus that we will 
be most interested in is the double negation nucleus -i-i: f2 -> Q in a topos. 
The negation map -•: 1^ -^ Q. is the unique map giving rise to a pullback 
square, 
1 
^ 1 
false J 
true 
Q 
- ^ Q 
see Exercise 5.6.1—where false: 1 —> Q is the characteristic map of 0 >-^ 1. 
Since Q is an (internal) Heyting algebra (see Exercise 5.1.5), we have. 
1 ^ 
- 
- i - . ^ ^ , 
-"true = true. 
^[<p^'^l)) 
i(p A -^-^^p 
which yields that -<-• is a nucleus. The difficult case is to deduce -^-^{(p A ip) 
from -i-i(^ and ->->ip. We shall give a derivation in propositional logic. 
^ h 9? 
^ h ^ 
(p,ip \- (p Alp 
-'(V? A ip) I—"(v? A ip) 
<f,jp,^((pAi;) 
h _L 
^, 
—I 
ijj, ~>{(p A tp) 
-.-.<^,-.(V? A V^) 
-i</?,-i(<^ A tp) 
h 
-i-,(p^ 
-.-
1 
i(p 
hi. 
—ijp 
-.^,-.(v?A rP) 
—t—itp 
h i 
h 
-i-iip 
h 
—i—ttp 
—}—\(p 
-up, -i-it/^ I—i-i(^ A ip) 

Section 
5.6: Nuclei in a topos 
355 
5.6.3. Example (Grothendieck topologies). A nucleus j on a presheaf topos 
C = Sets^ 
corresponds to a Grothendieck topology on C The latter 
consists of a mapping J that assigns to every object X G C a collection 
J{X) 
of sieves on X, such that the following three conditions are satisfied. 
Identity. The maximal sieve ^X 
— {f \ cod(f) 
= A"} is in 
J{X). 
Stability. If a sieve S is in J{X) 
and / : Y ^ A is an arbitrary map, then 
the sieve r{S) 
= {g: Z -^ Y \ f o g e S} is in J ( y ) . 
Transitivity. If 5 E J ( A ) , then also R G J ( A ) , for a sieve R with f*(R) 
G 
J{Y) 
for each / : Y ^ A in 5. 
Such a pair {C^J) 
is also called a site, in case C is a small category. The 
elements of J{X) 
are covers or covering families. Details of the correspon-
dence between j and J may be found in [188]. 
Often one describes such a Grothendieck topology via a basis, i.e, via col-
lections /C(A) of families of maps with codomain A, such that the induced 
collections of sieves 
J{X)^{lR={fog\feR})^^^^^^ 
form a Grothendieck topology. One says that J is generated by /C. The families 
R G AT (A) are also called covers of A. 
As particular examples of sites we mention the following, 
(i) Each frame A, considered as a poset category, carries the sup topol-
ogy, with as covers of x E A the down sets S C Ix with \/S 
— x. The frame 
distributivity ensures that we get a topology. 
This applies in particular to the case where A is the frame 0{X) 
of opens of 
a topological space A. In terms of bases, we get that a collection S = 
(Ui)i£i 
of opens Ui covers U G 0{X) 
if [j-^j Ui = U. 
(ii) For a regular category C there is what is called the regular epi topol-
ogy ? given by the following basis. The covers of an object A G C are singleton 
sets {¥ ->X} 
of covers {i.e. regular epis, see Lemma 4.4.6) with codomain 
A. The associated sieves are sets with elements of the form ^ - o . 
5.6.4. Notation. For a subobject m: X y-^ I one writes rn: X ^^ I for the 
closure obtained as pullback 
A 
^ 1 
Y 
I 
Y 
m 
true 
- ^ f i —-^ 
Q 
char(m) 
A subobject A ^^ / is called closed if A = A and dense if A = /. We write 

356 
Chapter 5: Higher order predicate logic 
ClSubj(/) ^ Sub(/) and ClSubj(B) ^ Sub(B) for the full subcategories of 
closed subobjects (on / E B and in B). 
5.6.5. Lemma, (i) Closure commutes with pullbacks: if the diagram on the 
left below is a pullback, then so is the one on the right. 
X 
Y 
X 
Y 
-^ J 
^Y 
Y 
-^ J 
Briefly, u*{n) — u*{n). Especially, if n is closed or dense, then so is u*{n). 
(ii) For a subobjects X >^ I and Y y-^ I one has. 
X<X, 
X = X, 
XAY 
= XAY, 
X <Y =f^ X 
<Y. 
Proof, (i) Because 
chsiTyu*{n)j — char(n) o u 
= j o char(77) o u 
= j o char(w*(n)j 
— char(^w*(n) j . 
(ii) Easy, using the diagrams in Definition 5.6.1. 
The following equaliser will be important. 
id 
Q; 
- ^ Q 
Q 
As a result, X ^-^ / is closed if and only if char(m): / ^ Q factors through 
fij ^-> fi. In particular, we can write true: 1 ^-^ fij. 
For an object /, write S{I):I 
^^ I x I for the closure of the diagonal 
S{I) = (id, id): / ^-» / x /. It yields a map / x / -> ftj, and hence by exponential 
transpose the j-singleton map 
{ } j 
5.6.6. Proposition. Let y.Q -^ Q be a nucleus in a topos B. Since closed 
ClSubj(l) 
subobjects are closed under pullback, we get a split fibration 
I 
of closed 

Section 5.6: Nuclei in a topos 
357 
subobjects. It is a higher order fibration with extensional 
entailment, 
in which: 
• T, A; D and W are as for ordinary 
subobjects. 
• ±j = X, X VjY =: X\JY, 
Uj(X) = U ( ^ ) ^rid Eqj(X) = Eq(X), and thus 
-njX = X D X. 
• true: 1 >-» Qj is a (split) generic 
object. 
Hence closure (—) defines a fibred functor 
Suh{M) -> ClSubj(B) overM 
which 
preserves 
all this structure, 
except the generic 
object. 
Notice by the way that these fibrations of closed subobjects have full subset 
types. 
Proof. By (ii) in the previous lemma, closed subobjects are closed under 
finite meets. And if X >-> /, Y ^^ / are closed, then so is X D Y: 
{X 
DY)<{X 
DY) 
^ 
{X 
DY)AX 
<Y 
^ 
{X DY) 
AX 
< Y since X is closed 
<^ {X DY) 
AX 
<Y 
since Y is closed. 
The latter obviously holds since it is evaluation (or the counit). Similarly for 
a closed subobject X ^^ I x J, 
^ 
TT* n ( ^ ) < ^ 
by Lemma 5.6.5 (i) 
O 
7T* Yl(X) 
< X 
since X is closed. 
And the latter holds (it is the counit again). 
As for coproducts, one obviously has ± < X, for closed X. And for closed 
subobjects X, Y, Z in the same fibre, 
X < y a n d X < Z 
<^ XWY 
< Z 
^ xvy = xvjy<z. 
Similarly for simple coproducts ]J and equality Eq. Finally, t r u e : 1 >^ Qj 
is split generic object because the characteristic maps of closed subobjects 
factor through Qj. And extensionality of entailment follows like in toposes, 
using this generic object as in Lemma 5.3.7. 
• 
This result allows us to do higher order logic with closed subobjects. For 
ClSubj(l) 
example, a map u: I -^ J in the base category of a fibration 
i 
of closed 
subobjects is internally injective (with respect to this fibration) in case one 
has in the internal language, 
i: /, i^: I \ u{i) —j u{i') h i = / i' 

358 
Chapter 5: Higher order predicate logic 
see Definition 4.3.9. Spelled out in categorical language, this means that 
{uxuy{S{J)) 
<S{I) 
or equivalently, 
Ker(i/) = {ux uy{S{J)) 
< J{I) 
But this means that S{I) =t / is the kernel pair oi u: I ^ J. Equivalently, 
that the inclusion map S{I) ^-» Ker(w) is dense. A map u with this property 
is sometimes called almost monic. And an arbitrary map u is called almost 
epic if it is internally surjective in the fibration of closed subobjects. This 
means that in w's epi-mono factorisation the mono-part is dense. Finally, a 
map is called bidense if it is both internally injective and surjective in this 
logic, see [169, Definition 3.41]. 
We finish with the following two results about such fibrations of closed 
subobjects. 
m 
5.6.7. Lemma. If X ^^ I is a dense mono in a topos M with nucleus j , 
ClSubj(l) 
then the associated reindexing functor m* for the fibration 
i 
of closed 
subobjects is an isomorphism: 
ClSubj(/) 
"^ 
^ ClSubj(X) 
n 
Proof. The inverse of m* maps a closed subobject Y >-^ X io m o n. Indeed, 
m* (m o n) — m* (m o n) 
= n 
since m is a mono 
= n. 
k 
And, the other way round, for a closed Z >-^ I, 
m o m*(k) = m A k 
— m A k 
— k 
since m is dense 
— k. 
D 
5.6.8. Lemma. For j = -i-i the double negation nucleus, the logic of the 
ClSubj(B) 
fibration 
i 
of closed subobjects is classical: one has -i-iX — X. 

Section 5.6: Nuclei in a topos 
359 
Proof. Since 
-ij^jX 
= (X D _L) D ± see the description of ^j in Proposition 5.6.6 
= {X D 1.) D J- since ± = -i-i± = ± for this nucleus 
= 
-.-^X 
= X 
because X is -i-i-closed. 
• 
Exercises 
5.6.1. 
Recall that negation ->(/? is defined in predicate logic as v? D _L. Show that 
-i:!} ^ Q as defined in Example 5.6.2 coincides with ( —) D ±:Q -> Q, 
where ( —) 3 _L = D o (id,± o !):Q -^ Q is obtained from the induced 
structure D:Q x Q ^ Q and ±: 1 -^ Q as in Remark 5.2.12. 
5.6.2. 
Consider the following commuting square of monos, 
k 
X> 
^ Y 
and prove 
(i) 
A: is dense =^ n" = m; 
(ii) n is closed and rn = n {= n) =^ k is dense; 
(iii) A;, n are dense =^ m = n o k is dense. 
[Hint. Write the triangle as a pullback.] 
5.6.3. 
Let j : Q -> Q be a nucleus in a topos B. 
(i) 
Show that for each object / G B, the map /*(j):/*(n) -^ /*(Q) is a 
nucleus in the slice topos B / / . 
f X ' \ ^ / X \ 
(ii) Check that a mono I i 
j ^""^ I i 
) is closed / dense in B / / if and 
only if X ^^ X is closed / dense in B. 
5.6.4. 
Consider in a topos with a nucleus an arbitrary map w: / —>• J with an 
arbitrary subobject X ;—> / on its domain. Prove that 
as (closed) subobjects of J. 
5.6.5. 
Say a map u: I -^ J has dense image if its image \m(u) ;—> J is dense. 
Show that M = (closed monos) and £ = (maps with dense image) form a 
factorisation system on a topos (see e.g. [18] for the definition). 
E 
5.6.6. 
Let 
^l-^ be a preorder fibration with fibred finite products (T, A). Define 
a nucleus on p to be a fibred "closure" monad T: E —)• E which preserves 

360 
Chapter 5: Higher order predicate logic 
fibred finite products. 
(i) 
Show that for a topos B, a nucleus jrQ ^ Q as in Definition 5.6.1, 
corresponds to a nucleus T = (—) on the associated subobject fibration. 
(ii) For a frame A, a nucleus on ^ is a map j:A 
-> A satisfying x < 
j{x), i(i(^)) < Ji^), and j{x Ay) = j(x) A j{y), see [170, 11,2]. Show 
that there is a correspondence between nuclei on A and nuclei on the 
F3.m(A) 
corresponding (regular) family fibration 
4-
(iii) Let T be a nucleus on a regular fibration 
'^P . Show that the fi-
bred category p 
of algebras (see Exercise 1.7.9; the fibred category 
of "closed" predicates) is again a regular fibration. Also that the map 
p -^ p^ preserves this structure. 
5,7 Separated objects and sheaves in a topos 
In this section we present some basic results about separated objects and 
sheaves in a topos with a nucleus, and describe (fibred) sheafification and 
separated reflection. We will later use these constructions in the special case 
of the effective topos EfF, to be introduced in the next chapter: the categories 
of sets and of u;-sets can be characterised as the categories of sheaves and of 
separated objects in EfF, for the double negation nucleus -"-i. 
5.7.1. Definition. Consider a topos B with nucleus j . An extension of a 
partial map I ^^ X ^ 
J is a. morphism v: I -^ J with v o m = u. We call 
(m, u) a dense partial m a p in case the mono m is dense. 
An object J G B is called a separated object if each dense partial map 
/ —^ J has at most one extension I ^ 
J. And J is a sheaf if there exists 
precisely one extension (again, for each such dense I ^ 
J). 
We write Sepj(B) and Shj(B) for the full categories of separated objects and 
of sheaves. There are then obvious inclusion functors Shj(B) M- Sepj(B) ^> B. 
In a diagram, J is a separated object / sheaf if there is at most / precisely 
one dashed arrow: 
u 
X 
^ J 
Y 
. ^ 
dense m 
Put differently, for dense X >-^ I, the function "pre-compose with m" 
/ 
X 
- 
o m 
/ 
X 
B(/, J) 
^B(X, J) 

Section 5.7: Separated objects and sheaves in a topos 
361 
is injective / bijective if and only if J is a separated object / sheaf. 
The above notion of sheaf is an abstraction of the notion of sheaf on a 
site. As we mentioned in Example 5.6.3, a nucleus on a topos C = Sets^°^ 
of presheaves corresponds to a Grothendieck topology J on C. Expressed in 
terms of J", a presheaf P: C^"^ -^ Sets is a sheaf if and only if the following 
holds. Assume that S covers X G C and that elements aj E P{y), for (/• Y —^ 
X) G 5, form a "matching" family: for f:Y-^XinS 
and arbitrary g: Z -^Y 
one has Ci{jog) — P{g){af). 
Then there is a unique element a G P{X) such 
that aj = P(/)(a), for all / G 5. 
It is useful to notice the following. 
5.7.2. Lemma, (i) If J is a separated object and Y >-^ J is a mono, then Y 
is separated. 
(ii) If J IS a sheaf then a mono Y ^^ J is closed if and only ifY is a sheaf. 
Proof. The first point is obvious, so we only do the second. Assume J is a 
sheaf and n: Y ^^ J is closed, and consider a dense partial map I ^-< X -^ Y. 
Then we get a unique extension v in 
X 
V 
dense m 
Y 
/ 
^ J 
V 
using that J is a sheaf. But then m < v* [n) and so 
id = m < V*(n) — v*{n) — v'^{n), 
which shows that v factors through n. This yields the required extension 
I -^ Y. It is unique by (i). Hence y is a sheaf. 
Conversely, if y is a sheaf, consider the closure n oi n:Y ^-^ J on the left, 
y > -
k 
_ 
— ^ y 
J 
dense k 
t:J 
We get i as indicated on the right, with ^ o Ar = id, because y is a sheaf. But 
then, since J is also a sheaf, we get n o i =n. Hence n < n, so n is closed. • 
5.7.3. Lemma. Consider a nucleus j in a topos M. 
(i) An object J £ M is separated if and only if the diagonal S{J) — 
(id, id): J ^^ J x J on J is closed. The latter means that internal and ex-

362 
Chapter 5: Higher order predicate logic 
ternal equality on J coincide 
in the fibration of closed subobjects, 
i.e. that 
equality on J is very strong in this 
fibration. 
(ii) The categories Sepj(B) and Shj(IB) are closed under finite limits in M. 
(iii) If J £ M is a separated object / sheaf then so is each exponent 
J^ = 
(/ ^ J) G 1. 
(iv) Qj 25 a sheaf Hence each object Pj{I) = l^j is also a sheaf 
(v) The ysingleton 
map { }J: / ^ Pj(/) = Oj is internally 
injective 
in the 
fibration of y closed subobjects (or, almost monic): its kernel pair is the closure 
of the diagonal 
S{I). 
Proof, (i) If J is separated, then TT O S{J) = TT' O S{J). Hence S{J) factors 
through the equaliser S{J) of TT, TT': J x J =^ J. Thus S{J) is closed. 
fTl 
n 
Conversely, given a dense partial map I ^^ X -^ J with two extensions 
v,w: I ^ J, then m < {v, w)*(S(J)), 
so that 
id, =fn<{v, 
wY{S {J)) = {v,wr{S(J)) 
= 
{v,wr{S{J)). 
Hence {v,w) factors through (J(J), and thus v = w. 
(ii) + (iii) Left as exercises (or see e.g. [188, V,2 Lemma 1]). 
(iv) We must show that for dense m:X 
>-^ I, the "pre-compose with m" 
function — o m:B(/, Qj) -^ M{X, Qj) is an isomorphism. But since t r u e : 1 -^ 
fij is split generic object for the fibration of closed subobjects we can describe 
this operation — o m also as composite, 
I B ( / , Qj) ^ ClSubj(/) 
^ 
^ ClSubj(X) ^ B ( X , 
Qj) 
in which m* is an isomorphism by Lemma 5.6.7. 
(v) The map { } J : / -^ 
^j(-^) is the singleton map as defined 
in 
Lemma 5.1.6 (ii), for the higher order fibration of closed subobjects. In the 
same lemma it is shown that this map is internally injective. The argument 
may be carried out in (the internal language of) the fibration of j-closed sub-
objects. 
• 
Ordinary singleton maps {}: I ^ P{I) = Q^ are internally injective for the 
fibration of ordinary subobjects, and j-singleton maps { }J: / —> Pj(/) = Q | are 
internally injective for the fibration of j-closed subobjects. We need to know 
that j-singleton maps form a natural transformation, like ordinary singleton 
maps, see Proposition 5.5.2. The proof goes analogously. 
5.7.4. Lemma. Given a nucleus j in a topos M, the assignment 
I \-^ Pj{I) = 
fij extends to a functor 
IB —> IB, and the ysingleton 
maps { }j form a natural 
transformation 
idi => Pj- 
D 

Section 5.7: Separated objects and sheaves in a topos 
363 
The j-singleton maps can be used to characterise separated objects and 
sheaves. 
5.7.5. Lemma. Consider a topos B with nucleus j and an arbitrary object 
/ E B. Then 
(i) / is a separated object if and only if the y singleton map {}y I -^ P'^{^) 
on I is a mono in B; 
(ii) / is a sheaf if and only if {}f I -^ -^j(^) ^^ ^ closed mono. 
Proof, (i) The (if)-part follows from the first and last point of the previous 
lemma: if / is a separated object then the diagonal S{I) on / is closed, so that 
the kernel of { )j is contained in S(I) = S{I)- This makes { }j a mono. The 
(only if)-part follows directly from Lemma 5.7.2 (i). 
(ii) By Lemma 5.7.2 (ii), using (i) and the fact that Pj(/) is a sheaf. 
• 
This result suggests how to obtain a separated object or sheaf from an 
arbitrary object, simply by taking the monic or closed monic parts of the 
corresponding j-singleton map { }j. This will lead to left adjoints to the cor-
responding inclusion functors. 
5.7.6. Definition. In a topos B with nucleus j , write for an object / G B, 
(/ — W ) = (/^^s(/)>^P,(7)) 
for the epi-mono factorisation of the j-singleton map { }j. And write 
a(/) tf TiT) 
for the closure of s(/) >-^ Pj(I). 
We notice that s(/) is the image {a:Pj(/) \3i:I.a 
=Pj(/) {Oj} of the sin-
Sub(l) 
gleton map { }j in the fibration 
i 
of ordinary subobjects in B, and that 
a(/) is the image {a: Pj{I) \ 32: /. a —p^{i) {^j} of the j-singleton map { }j in 
ClSubj(B) 
the fibration 
4- 
of j-closed subobjects in B—where we use that Pj{I) 
is separated. It is almost immediate—using Lemma 5.7.4—that the assign-
ments / i-> s(/) and / 1-^ a(/) are functorial, using the universal properties of 
epi-mono factorisations. 
5.7.7. Theorem. The assignment I i-)- s(/) is left adjoint to the inclusion 
Sepj(B) M^ B. And I ^ a(/) is left adjoint to Shj(B) ^ B. 
The functor a(—) is called sheafification. And s(—) is separated reflec-
tion. A proof of this result using internal languages is described in [337]. 
Proof. We first consider separated reflection. For a map u: I —^ J in M with a 
separated object J as codomain we have to produce a unique map v: s(/) —)• J 

364 
Chapter 5: Higher order predicate logic 
with V o ej — u. But this follows from functoriality of s and the fact that 
{ }J: J -> Pj{J) is a mono by Lemma 5.7.5 (i)—so that its epi-part ej is an 
isomorphism. 
The argument for sheafification is similar. 
• 
Later in this section we shall make use of the following two standards facts 
about sheafification. A proof of the first result occurs in almost any text on 
topos theory. Exercise 5.7.5 below elaborates on a proof of the second result. 
5.7.8. Lemma. The sheafification functor a preserves finite limits. 
• 
5.7.9. Lemma. A morphism f is bidense (I.e. both internally injective and 
surjective in the logic of closed subobjects) if and only if 8i{f) is an isomor-
phism. 
• 
5.7.10. Remarks, (i) The above adjunction Shj(B) t^ B forms an example 
of a geometric morphism. This is a second notion of morphism between 
toposes, the first one being 'logical morphism', see Definition 5.4.1. In general, 
a geometric morphism F: A ^ B between toposes A, B consists of a pair of 
adjoint functors 
/ 
F* 
\ 
with F* finite limit preserving. 
\ 
^* 
/ 
One calls F* the 'inverse image' and F* is 'direct image' part of F. These 
geometric morphisms play a more important role in topos theory than logical 
morphisms. They satisfy a factorisation property and are used, for example, 
in functorial semantics for geometric logic, see e.g. [188, Chapters VII and X]. 
(ii) If B is a topos with nucleus j , then (by Exercise 5.6.3) each slice 
topos B / / has a nucleus /*(j). Hence one can define what families ( | 1 
of /*(j)-separated objects and families of /*(j)-sheaves are. This is to be un-
derstood fibrewise: each Xj is a j-separated object or a j-sheaf. In this way 
FSepj(l) 
FShj(B) 
one gets 
fibrations 
i 
and 
4- 
of such families. 
Also, one can define separated reflection and sheafification in M/I. This gives 
rise to fibred functors FsrB"^ -^ FSepj(B) and FaiB"^ -> FShj(B), which are 
fibred left adjoints to the respective inclusions. Everything is fibred because 
separated reflection s and sheafification a are defined by constructions that 
are preserved by pullback functors. We shall return to this point towards the 
end of this section. 
We are now in a position to give a more refined version of Lemma 5.7.2. 

Section 5.7; Separated objects and sheaves in a topos 
365 
5.7.11. Lemma. Consider a mono X >-^ I in a topos B with nucleus j . 
(i) // / 25 a sheaf, then 
X ^-^ I is closed <^ X >^ I is a mono in Shj(B). 
(ii) And if I is a separated object, 
then 
X ^^ I is closed O" X ^^ I is a regular mono in Sepj(B). 
Thus (i) and (ii) say that there are change-of-base 
situations, 
Sub(Shj(B)) 
^RegSub(Sepj(B)) 
^ ClSubj(B) 
J 
J 
Y 
Shj(B) C 
^Sepj(B) 
^ 
Proof, (i) The implication (=>) follows from Lemma 5.7.2 (ii). Conversely, 
by the reflection Shj (B) (^ B, a mono in Shj (B) is also a mono in B. It is then 
closed because / is a sheaf, see Lemma 5.7.2 (ii) again. 
(ii) If m: X ^-^ / is closed, then X is separated by Lemma 5.7.2 (i). It is 
an equaliser in Sepj(B), namely of char(m), true o !:/ i4 Qj. In the reverse 
direction, assume m.X 
;—> / is an equaliser in Sepj(B), say of u^v.I 
=4 K-
Since X ^^ X is dense and K is separated, the two maps u om,v 
orn:X 
z:^ K 
must be equal. But then m <m^ since m is an equaliser, and so m is closed. 
D 
Sub(Shj(B)) 
RegSub(Sepj(l)) 
5.7.12. Corollary. Both 
the fibrations 
i 
and 
i 
of 
'^ 
^ 
Shj(l) 
Sepj(B) 
-^ 
subobjects in a category of ysheaves, 
and of regular subobjects in a category of 
y separated objects are higher order fibrations. 
In particular, 
Shj(B) 25 a topos. 
And in case j 25 the double negation nucleus -«-', both these fibrations 
are 
models of classical logic. 
Proof. By Proposition 5.6.6 and Lemma 5.6.8. 
• 
Thus, by forming the category Shj(B) of j-sheaves in a topos B, we get 
a new topos. It can be characterised in a universal way: for example, every 
geometric morphism F : A ^ 
B whose inverse image part F* sends bidense 
maps to isomorphisms, factors through Shj(B) <^-> B (see [169, Theorem 3.47]; 
similar such universal properties are described there). The passage from B 
to Shj(B) can thus be understood as forcing "j-isomorphisms" (i.e. bidense 
maps) to be actual isomorphisms. An important special case of this Shj(—) 
construction is the ' 'Grothendieck" topos Sh(C, ^7) "-^ Sets^""" of sheaves on 
a site (C, J'). It plays a central role in [188]. 

366 
Chapter 5: Higher order predicate logic 
We conclude this section with an explicit description of fibred sheafification, 
as mentioned in Remark 5.7.10 (ii). This requires the following auxiliary result. 
5.7.13. Lemma. Consider in a topos with a nucleus two morphisms m: X -^ 
X' and u'.X -^ J with common domain, where m is bidense and J is a sheaf. 
Then there is a unique morphism v: X' -^ J with v o m = u. 
Proof. Simply take v = (^j)~^ ^ a(w) o a(m)~^ o r/^s using Lemma 5.7.9 
(where r] is the unit of the sheafification adjunction). 
D 
This lemma applies in particular when m is itself a unit component rjj. The 
next result occurs (without proof) in [150] (before Lemma 6.5). It gives an 
explicit description of fibred sheafification. 
5.7.14. Proposition. Consider a topos B with a nucleus j , and for an ar-
bitrary object I £ M the slice topos M/I with the induced nucleus /*(j); see 
Exercise 5.6.3. Sheafification Fs in this slice category can be described as the 
f ^ \ 
( ^' '\ 
mapping which sends a family I 
y*^ j ^o the family I 
y^ 
I obtained in 
the following pullback diagram. 
Proof. It is not hard to see that the family <p' is a sheaf in 
/
z
\
/
y
\ 
/ z 
dense mono I 
i ^ I ^^ I 
r 
] ^^^ ^ morphism I 
y^ 
Because m is a dense mono Z ^-^ Y in IB, we get a unique g:Y -^ ^{^) 
with 
g o m = 6 o f. Then a(^) o g = rjj o tjj because a(/) is a sheaf. The required 
map Y -^ X' is then obtained as mediating map for the pullback. 
What remains to show is that the family (p' is universal. Assume therefore a 
morphism I 
j ^ ) ^ I 
j ^ 1 to a sheaf ip in M/I. Let us write rj^: X ^ 
X' 
for the unique map—obtained from the above pullback—with (f' o rj^^ =z ip 
and 0 o T]i^ = rjX' We claim that Si{r]ip) is an isomorphism. This follows from 
the fact that sheafification a preserves pullbacks (as stated in Lemma 5.7.8): 
applying a to the pullback p' -> a(y?) in the proposition yields a new pullback. 
As a result, a(^) is an isomorphism, since Si{r]j) is an isomorphism. But then 
8L{T](P) = SL{9)~^ O 8L{r]x) must be an isomorphism as well. Hence T]^p is bidense 

Section 5.8: Separated objects and sheaves in a topos 
367 
in B, by Lemma 5.7.9, and also in B//—since epi-mono factorisations and 
closures in B// are the same as in B. Therefore Lemma 5.7.13 applies (in 
); it yields the required map (p' -^ il). 
D 
Exercises 
5.7.1. 
Show that an object / in a topos with a nucleus is separated if and only if 
the unit r//: / —>• a(/) of the adjunction Shj(B) ^ B is a mono. 
5.7.2. 
Show that the inclusion Shj(B) M- Sepj(B) also has a left adjoint. 
5.7.3. 
Prove that if X is a sheaf and / is a separated object, then any mono 
X >-^ I IS automatically closed. 
5.7.4. 
Show that J is a sheaf if and only if LJ is a sheaf and {}'- J ^-^ 1-J is 
closed. 
5.7.5. 
Consider a topos with a nucleus j . The aim of this exercise is to get a proof 
of Lemma 5.7.9 (following [169, 3.42 and 3.43]). 
(i) 
Prove that if a mono m: X ^ X' is dense, then a(m):a(X) ^ 
a(X') 
is an isomorphism. 
(ii) Prove also the converse of (i): if a(m) is an isomorphism for a mono 
m, then m is dense. 
[Hint. Notice first that if a(m) is an isomorphism, then for any map 
u: X -^ J to a sheaf J there is a unique v: X' -^ J with v o m = u^ 
like in Lemma 5.7.13. Apply this to the case J = Qj. It yields a unique 
map v:X' -^ Qj with g o m = true o !x. This v then classifies both 
the identity X' ^^ X' and m's closure rn: X >—» X'.] 
(iii) Conclude from (i) and (ii) that if w: / -^ 
J is intemcdly injec-
tive/surjective {i.e. almost monic/epic) if and only if a(u):a(/) -^ a(J) 
is monic/epic. And also that u is bidense if and only if SL{U) is an 
isomorphism—as stated in Lemma 5.7.9. 
5.7.6. 
Let B be a topos with nucleus j . 
fX\, 
^, 
(i) 
Assume that I y 1 is an /*(j)-separated object. Show that for each 
Iback u* I 
the same for sheaves. 
(ii) Prove also that if I ^ I is a J*(j)-separated object/sheaf, then the 
product Yiu \ 
7 ) ^^ ^^ /*(j)-separated object/sheaf, for u: J —^ I. 
5.7.7. 
Assume a topos B with a nucleus. Use the characterisation of sheafification 
on shces B / / from Proposition 5.7.14 to show that sheafification on families 
leads to a fibred functor Fs on B~^ (with respect to the codomain fibration). 
map u: J —^ I the puUback u* { ^ ] in B/J is J*(j)-separated. Prove 

368 
Chapter 5: Higher order predicate logic 
5.8 A logical description of separated objects and sheaves 
We conclude this chapter with a logical description of separated objects and 
sheaves in terms very strong equality and unique choice. Recall from Exer-
E 
cise 4.9.1 that for a fibration ^ with equality and subset types we say that 
equality on J G B is very strong if internal and external equality on J 
coincide, or—in terms of subset types—if the canonical map J -^ {Eq(J)} is 
an isomorphism. And unique choice on J G B holds if for each single-valued 
relation R G E/x j the canonical map {R} -^ {U(^)} is an isomorphism. The 
ClSubj(l) 
main result below is that with respect to the fibration 
i 
of j-closed 
M 
subobjects, (a) an object J G B is separated if and only if equality on J is 
very strong, and (b) J G B is a sheaf if and only if unique choice holds on J. 
It gives us a purely logical characterisation of separated objects and sheaves. 
It may be used in more general situations like in Exercise 5.6.6 where one has 
a notion of nucleus suitably generalised to fibrations. 
Recall from Section 4.9 that what characterises subobject fibrations is: full 
subset types, very strong equality, and unique choice. The first of these points 
is present in fibrations of j-closed subobjects; the second point is by (a) above 
obtained by restricting to separated objects, and the third one comes by (b) by 
a further restriction to sheaves. Thus, by restriction to sheaves, the fibration 
of closed subobjects becomes a subobject fibration (on these sheaves). And 
since we already know (from Proposition 5.6.6) that such a fibration of closed 
subobjects is a higher order fibration, we obtain an alternative road to the 
result that a category of sheaves in topos is itself a topos, see Lemma 5.7.11. 
To obtain the main result, we prepare the grounds in the lemma below. 
As already stated, we consider the logic of closed subobjects with respect to 
some nucleus j on a topos B. That is, we work in the internal language of the 
ClSubj(l) 
higher order fibration 
4- 
. A functional relation R: / —1-> J herein is a 
predicate i: I,j: J h R{i,j): Prop satisfying: 
{R is single valued) 
i: I J: J,f: J \ R{iJ),R{i,f) 
h j =j f 
{R is total) 
i: / I T h 3j: J. R{i,j). 
ClSubj(B) 
See Example 4.3.8. In 
4- 
this means that the relation (ro, ri): i^ ^-»/x J 
is a closed subobject satisfying 
The tuple (ri o TTQ^TI o TTI): R' >-^ J x J factors through S{J), where jR' is 

Section 
5.8: A logical description 
of separated 
objects and sheaves 
369 
obtained as kernel (equaliser): 
(7ro,7ri) 
R'> 
^ R 
• the image of VQ: R ^ I is dense. 
See the description of equality and existence in Proposition 5.6.6. It turns out 
ClSubj(B) 
that there is a close connection between these functional relations in 
4-
B 
and dense partial maps in IB. This correspondence is the basis for the alter-
native logical description of separated objects and sheaves below. 
5.8.1. Lemma. Consider the logic of closed suhohjects, as above. 
m 
u 
(i) If I ^-< X -^ J is a dense partial map, then the closure of its ordinary 
graph (m, u): X y-^ I x J is a functional relation I —f-^ J. 
(ii) Consider a map v: I -^ J and a dense partial map (m, u): I -^ J. If v 
is an extension of [m, u), then the closures (id, v) and (m, u) of the (ordinary) 
graphs are equal. And if J is separated, the converse also holds. 
(iii) If R: I —H- J is a single-valued relation (ro, ri): i? ^^ / x J, then 
(a) ro: R -^ I is a mono if J is separated; 
(b) ro is closed, if J is a sheaf. 
Proof, (i) Notice that the graph {m, u) is described in the internal language 
Sub(l) 
of the 
fibration 
4- 
of ordinary subobjects as the proposition 
B 
i: /, j : J h 3x: X. m[x) =j i A u{x) —j j : Prop. 
Thus the closure {m,u) is described by the same expression, call it 
G{i,j), 
ClSubj(B) 
but this time in the internal language of the fibration 
4- 
of closed 
B 
subobjects. We reason informally in this language to show that this graph G 
is functional. 
• If G{i,j) and G{i,f), 
say with x, x' such that m(x) =/ i A u{x) =j j and 
m(x') —J i A u{x') =j / , then m{x) —j i —j m[x'). Hence x —x x' since 
m is internally injective, by Exercise 4.3.6. So j =j u{x) —j u{x') —j j ' . 
• For i: I we have 3x: X. m{x) —j i since m is dense. Take such an x and put 
j = u{x). Then 
G{iJ). 
(ii) If V extends (m,w), then we get (m^u) = (id,t;) by applying Exer-

370 
Chapter 5: Higher order predicate logic 
cise 5.6.2 (i) to the triangle of monos 
m 
X> 
^ I 
(m^u) 
IxJ 
(id,t;) 
For the converse, assume J is separated and (id, v) = (m, u). Write (m, u) = 
(ro, ri): R^^ I x J. There are then dense monos n: X ^^ R and k: I ^^ R, so 
we can form their puUback, as in. 
^'"'"^^ (ro.Vi) /<'^'^> 
Since dense maps are closed under pullback, this k' is dense. Thus we can 
conclude that v o m = u—and thus that v extends (m, u)—from the fact that 
J is separated, and the calculation, 
V o m o k' = V o TQ o n o k' 
= V o ro o k o n' 
= V o n' 
= ri o k o n' 
= ri o n o k' 
= u o k'. 
(iii) For a single-valued relation (ro,ri): R y^ I x J, where J is separated, 
we first establish that TQ is a mono. Assume therefore u^v.K 
i4 R with 
VQ o u = VQ o V. Then there is a (unique) w:K —>• R' with TTQ o it; = t/ 
and 'Ki o w — v^ where TTQ^TTIIR' Z^ R is the kernel pair of VQ: R —^ /, as 
described before the lemma. We get that (ri o w,ri o v) factors through 
(ri o 7ro,ri o TTI), and hence through S{J) = S{J). Then ri o u = ri o v and 
so (ro,ri) o u = (ro,ri) o v. Hence u = v so that we may conclude: VQ is a 
mono. 

Section 5.8: A logical description of separated objects and sheaves 
371 
Next we assume that J is a sheaf, and show that the closure TQ. R >-^ I 
of VQ: R >-^ I is VQ. By pulling the closed mono true: 1 ^^ Qj back along the 
evaluation map ev: Qj^ x J —> Qj, we get a closed mono Ej >-^ Q^ x J. Hence 
the object Ej is a sheaf. This yields a map v in 
(char(i?) o ro,ri) 
dense k 
R 
where we use that the closed relation R >-^ I x J has a relation classifier 
char(i?): / -> fij^ as in the square below. We write w for the composite R —> 
Gj >-^ ^y X J in the diagram. Then TV o w = char(i?) o TQ: R -^ Q^, because 
Q^ is separated. We then get a map 
R — 
Y 
/ 
V 
>-e j > 
^ Q / x J 
char(i?) X id 
^ 
which shows that ro < TQ, and so that TQ is closed. 
^Q{ 
X J 
D 
5.8.2. Theorem. Let j be a nucleus in a topos B. 
(i) An object J EM is separated if and only if equality on J is very 
strong 
ClSubj(l) 
in the fibration 
i 
of yclosed 
subobjects in B. 
IK 
(ii) And J EM is a sheaf if and only if unique choice holds on J, in this 
same fibration 
of closed 
subobjects. 
Proof, (i) By Proposition 5.6.6, internal equality on J is the closed subobject 
Eq(J) = 8{J) on J X J. It coincides with the diagonal S(J) on J if and only 
if J is separated, by Lemma 5.7.3 (i). 
(ii) Assume J is a sheaf, and (ro^ri): R >-^ / x J is a single-valued relation 

372 
Chapter 5: Higher order predicate logic 
in the fibration of closed subobjects. Then 
LJj(^) = LI(^) 
by Proposition 5.6.6 
— Im(7r o (ro,ri)) see Theorem 4.4.4 
^0 
^0 
because ro is a mono, 
see Lemma 5.8.1 (iii) (a) 
since ro is closed, by (b). 
Hence the canonical map {R} —)• {Uj(^)} is the identity, which is certainly 
an isomorphism. 
Conversely, assume unique choice holds on J. From Exercise 4.9.1 we know 
that equality on J is then very strong, so that J is a separated object. Let 
/ ^-^ X —> J be a dense partial map. Then R = (m, u) is a functional relation 
/ —H- J, by Lemma 5.8.1 (i). The coproduct Uj(^) — ^j''J-R{hJ) 
is T 
because R is total. Hence we get two isomorphisms in the diagram 
R 
Y 
iUiiR)} 
(m, u) 
Ix 
J 
so that there is a t;: 7 —> J with 
^ 
I 
^ 
R 
(id,t;> \ 
/ 
(^rn,u) 
I X J 
But then v extends {m,u) 
by Lemma 5.8.1 (ii). 
• 
Exercises 
5.8.1. 
Prove that in a topos B with nucleus j , 
(i) an object J G B is separated if and only if each functional relation 
ClSubj(ffi) 
R: / —H- J in 
4- 
is the graph (in this fibration) of at most one 
map I ^ 
J. 
(ii) And that J is a sheaf if and only if there is a unique such map, for 
each functional relation R. 

Chapter 6 
The effective topos 
This chapter concentrates on one particular topos, namely the effective topos 
EfF. It can be seen as a topos in which the ordinary set theoretic world is 
combined with the recursion theoretic world. For example, there is a full and 
faithful functor Sets —)• EfF. But also the endomorphisms N -^ N on the 
natural numbers object A^ in EfF can be identified with the total recursive 
functions N ^ N. 
We shall be mostly interested in this topos as a universe for modelling var-
ious type theories. Therefore our view and description of EfF is rather limited 
in scope. For example, we only sketch in the last section of this chapter how 
one can do mathematics inside EfF, and suggest that this is "recursive math-
ematics". For a more elaborate account we refer to the last part of Hyland's 
original paper [142] on the effective topos. Another interesting aspect of EfF, 
namely the combination of higher types and effectivity, see [296] is ignored. 
For the role of EfF in the analysis of (higher order) Kleene realisability, we 
refer to [239, 240]. And Turing degrees within EfF may be found in [258]. Here 
we simply use EfF as a "forum" or "universe" in which we can discuss sets, 
u;-sets and PERs. Especially, the (internal) category of PERs inside cj-Sets 
and EfF—complete in the first case, and nearly so in the second—will interest 
us. In this chapter we shall describe families of PERs and of u;-sets over EfF 
in a concrete fashion. These will be used later to model type theories. 
Our presentation of the effective topos is the "logical one", based on the 
UFam(PN) 
higher order predicate logic of the realisability 
fibration 
i 
, as used by 
Hyland. There are alternative ways to introduce EfF, namely as completion 
with colimits of certain categories. For example, in [41] EfF is obtained by 
373 

374 
Chapter 6: The effective topos 
adding quotients to the category u;-Sets of cj-sets (or 'assemblies', as they are 
called there). And in [292] EfF results from a two-step completion of Sets, 
by first adding recursively indexed coproducts and then quotients of (pseudo) 
equivalence relations. 
The material in this chapter is entirely standard, except the indexing of 
UFam(a;-Sets) 
(jj-sets by objects of EfF via the split 
fibration 
4- 
instead of via the 
FSep(Eff) 
non-split fibration 
i 
of (-i-i-)separated families in Section 6.3. Later, 
Eff _ 
in Section 11.7, the relation between these fibrations will be described: the 
last one is the so-called "stack completion" of the former. 
6,1 Constructing 
a topos from a higher order fibration 
In Example 4.3.8 we have associated with a regular fibration p the categories 
Rel(p) of types (objects of the base category) with ordinary relations and 
FRel(p) of types with functional relations. In this section we shall describe a 
similar construction, which yields for a higher order fibration p an associated 
topos Set(j9). Objects of Set (p) are types / with an (abstract) equality relation 
«; morphisms are suitable functional relations (in the logic of p) between the 
types. This construction includes the topos of sets with a Heyting-valued 
equality of Four man & Scott [80] and the effective topos EfFof Hyland [142]. 
The latter is of most concern to us and will be further investigated in the next 
three sections of this chapter. 
The construction of the topos Set(p) will be described in purely logical 
terms; that is, in the internal language of the fibration p. As such, it may 
be found in [145], except that there, one starts from a 'tripos' instead from 
the slightly more general notion of 'higher order fibration' that we use, see 
Example 5.3.4. A more detailed investigation may be found in [267]. 
Although we are essentially only interested in the special case where the 
UFam(PN) 
fibration p is the realisability fibration 
i 
from Section 4.2, we do 
Sets 
present the construction of the topos at a more general level. We do so, because 
all the time we reason in the internal language, and nothing particular of this 
realisability fibration is used. 
E 
6.1.1. Definition. Let -j^P be a regular fibration. Write Set(p) for the cat-
egory with 
objects 
pairs (/, «/) where / G B is an object of the base category 
and ^j G E/x/ is an 'equality' predicate on /. The latter 

Section 6.1: Constructing a topos from a higher order 
fihration 
375 
is required to be symmetric and transitive in the logic of 
p. This means that validity in p is required of: 
11,12-1 I i\ « / 12 ^ h « / h 
n, ^2, h' I I i\ « / h.h 
« / ^3 l~ h « / ^'3. 
objects 
(^5~/) ~^ {Jj^j) 
ar^ equivalence classes of relations F G 
E/xj from / to J, which are 
• extensional: 
11,12'hh^h'J 
I n « / «2,ii « J J2,F{iiJi) 
h F{i2,J2) 
• strict: 
i: /, j : J I F{i, j) h (i « / i) A (j « j j) 
• single-valued: 
i:IJij2'J 
I F{iJi),F{ij2) 
^ ji ^J h 
• total: 
i:/ I i ^i i h 
3j:J.F{iJ). 
The equivalence relation on these relations F is logical equivalence (in the 
internal language) as described by isomorphisms in the fibre. For convenience, 
we usually write representatives F instead of equivalence classes [F]. 
Sometimes we also omit the subscript and write ^ for «/. And we write 
\h ^l h\ for ii « / 22 Notice that the abstract equality « / is not required 
to be reflexive. We write Ej{i), or E{i), for \i « / i\. Thus Ej{—) is a unary 
"existence" predicate on /, defined categorically by Ej{—) = (id, id)*(?^/) G 
E/. 
The identity morphism on an object (/ «/) of Set(p) is the (equivalence 
class of the) relation « / itself: 
ii,i2'.I 
^" n « / 12- Prop. 
F 
G 
And composition of (/, «/) —> (J, « j ) —>• (/\, «/<:) in Set(p) is the compos-
ite relation G o F, given as: 
i: /, /?: A^ h 3j: J. F(2, j) A G(i, fc): Prop. 
Some elementary verifications in the internal language demonstrate that these 
identities and composites are again extensional, strict, single-valued and total. 
Notice that all the logical machinery from p that we need in order to define 
Set(p) is 3, =:, A, T, as in a regular logic. 

376 
Chapter 6: The effective topos 
The following are the main examples. 
6.1.2. Examples, (i) If fi is a complete Heyting algebra [i.e. a frame), then 
Fam(n) 
the above Set(—) construction applied to the regular family fibration 
i 
of set-indexed families of elements of fi described in Example 4.2.5, yields 
the category Q-set of Heyting valued sets as introduced in [80]. Objects of 
Q-set are sets / together with a 1]-valued equality predicate ^j: I x I ^ Q. 
satisfying (in Q) 
\h ~/ ^2! < h'2 « / n | 
In «/«2| A |i2 «/23! < 
Ih^iisl 
for all elements 2*1,22,23 E /. Morphisms (/,«/) -^ {J^^j) 
in Q-set are 
fi-valued functions F: 7 x J —> Q which are extensional, strict, single-valued 
and total. The latter means for example, that for each i G /, 
E{i) = \i^ji\< 
y 
F{ij). 
jeJ 
(This category ^^-set should not be confused with the category a;-Sets of 
a;-sets (7, E) with E: I ^ PN from Section 1.2.) 
UFam(PN) 
(ii) The same construction applied to the realisability fibration 
4-
from Example 4.2.6 produces the effective topos Eff from [142]. Objects of 
EfF are sets 7 together with a PN-valued equality predicate «/: 7 x 7 -^ PN 
satisfying 
P I 
(in « / i 2 | D |22«/ nl) ^ 0 
f] 
(in « / 22| A |22 « / isl D In « / 23I) ^ 0 
ii,i2,i3€il 
where A and D are the operations PN x PN =4 PN described in Example 4.2.6. 
A morphism (7,«/) -> (J, ~j) in EfF is then an equivalence class of a 
relation F\I x J -^ PN which is extensional, strict, single-valued and total. 
Explicitly, this means that there are realisers 
ni E 
pj 
(|n «/22|A|ii ?^ji2| AP(n,ii) D P(i2,i2)) 
"2 € 
f l 
(F{^,j):iE,{i)^EJ{3)) 

Section 6.1: Constructing a topos from a higher order 
fibration 
377 
ns e 
f l 
(F{iJi) 
A F(i,J2) 
D |ii « J 
h\) 
i€l,juJ2€J 
n, e 
f]{Eii)D[jF(i,j)). 
i£i 
jeJ 
Thus, for example, for i E I and m E £^(i) one has that 714 • m is an element 
of F{i,j), 
for some j G J-
Similar realisability examples arise by applying the Set(—) construction to 
triposes, as constructed in Example 5.3.4, starting from a partial combinatory 
algebra. This yields many more such examples, see for instance [239, 261, 264]. 
Sub(l) 
(iii) If we start from a topos B, we have a higher order fibration 
i 
of 
IB 
subobjects. Also here we can apply the Set(—) construction, which will yield 
a new topos. 
Our aim in this section is to show that these categories of the form Set(p) 
are toposes, in case p is a higher order fibration. The following is the first step. 
E 
6.1.3. Proposition. For 
-j^P a higher order fibration, the category 
Set(p) 
m> 
has finite limits and is Cartesian 
closed. 
Proof. As terminal object in Set(p) one takes the terminal object 1 G B with 
the truth predicate 
x: l,x': 1 \- \x ^i x'\ = T: Prop 
as equality. We shall write 1 = ( l , « i ) G Set(p) for this object. A morphism 
F: (I,^) 
—> 1 in Set(p) is (an equivalence class of) a predicate F G E/xi = E/ 
satisfying 
21,22:/ I F(ii),ii 
^ 2*2 h F{i2) 
i: I I F(2*) h E{i) 
i:I I E(i) 
\-3x:l.F{i) 
so that F{i) is logically equivalent to E{i). There is thus a unique such map 
The Cartesian product of (/, ^j) and (J, ^j) 
is the object / x J G B together 
with equality predicate 
z,w: I X J h \7rz ^j 7rw\ A {TT^Z « J 7r'w\: Prop. 
The projection maps (/, ?^) <— (/ x J, ^) 
-^ (J, ^) 
are then given by the 
predicates 
\ z:I X J,i: I \- \7rz ^j i\ A Ej{7r'z): Prop 
1 z:I X J J: J h ITT'Z ^J j \ A Ej{7rz): Prop. 

378 
Chapter 6: The effective topos 
And tupleing of two maps F: {K, «) -^ {I,«) and G: [K, «) -> (J, ^) involves 
the predicate 
k: K, z:Ix 
J \- F{k, irz) A G{k, TT'Z): Prop. 
For parallel maps F, G, an equaliser, 
F 
(/,«) > 
(/, «) ' ^ 
^ 
(J, «) 
G 
is obtained by taking as new equality predicate ^ on /, 
21,22:/ h In «22| =^|n «22| A3i: J.F(2i,j) AG(i2,i):Prop. 
This predicate ^ is also the equaliser map ^: (/, ^) ^^ (/,«) of F, G. 
Finally, in order to form the exponent of objects (/, «), (J, «) E Set(p), we 
take P{I X J) = fi(^^'^) as underlying object with existence predicate 
def 
/: P(I X J) \- E{f) = "/ is extensional and strict 
and single-valued and total" : Prop. 
That is, 
E{f) = Vii,i2:/.Vji,J2:«/. In ^ / ^'2! A \ji « j J2I A/(ii,ii) D f(12,32) 
A 
yi:Lyj:JJ(iJ)DEj{i)AEj{j) 
A ^r-L^h,h'J-f[h3i)^f[h32) 
D lii « J i2| 
A 
W.LEj{i)D3j:JJ{iJ). 
The equality relation on the object P[IxJ) 
underlying the exponent (/, «) => 
(J,«) is then 
f,g: P{I X J) h 1/ « 5| t^ ^ ( / ) A E(g)h^i: 
I.^j: J. f{i,j)J09{i,j): 
Prop. 
The evaluation map Ev: ((/, w) => (J, w)) x (/,«) ->^ (J, w) is given by 
/ : P ( / x J),i:7,i: J hEv(/,i,i) t V ( i , i ) A £ ( / ) : P r o p . 
And for a morphism H: {K,«) x (/,«) —>• (J, «), we get an abstraction map 
k:K,f:Ix 
J b AiH){k, f) =^ £'(Ar) A £^(/) A 
Vf G /. Vi 6 J. /f (/, i, j)3:/(i, i): Prop. 
D 
As a first step towards understanding (the logic of) subobjects in Set(p), 
there is the following quite useful result. 

Section 6.1: Constructing a topos from a higher order 
fibration 
379 
6.1.4. Lemma. A morphism F : ( / , « ) —>• (J, ~) in Set(p) is a monomor-
phism if and only if the following entailment holds in p: 
ii,i2:/,j: J | F(iiJ),F(i2j) 
H ii « / 22-
Proof. Assume validity of the above statement, and assume that two mor-
phisms G,H:(K,^) 
=t (/, ~) in Set(p) are given with F o G = F o H, 
i.e. with 
k: K, i: J I 0 h [3i: L F{i, j) A G{k, i)]jo[3i: L F{i, j) A H(k, i)]. 
We need to show that G{k^i) implies H{k,i). 
Assume therefore 
G{k,i)] 
then Ej{i), so F{i,j) for some j:J. We then have 3i: I. F{i,j) A G{k,i), so 
F(i',j) A H{k, i') for some i': /. But then F{i,j) A F{i',j), 
and so i « / f by 
the assumption. Hence 
H{k,i). 
Conversely, the pullback of F against itself is the object (/ x /, ^) where 
z, w: I X I \- \z ^ w\ = \z «/x/ w\ A 3j: J.F{7rzJ) A F{'K'Z,J)\ 
Prop. 
In case F is a mono in Set(p), this predicate must be equivalent to JTTZ « / 
7rit;| A ITT'Z ^J TT'WI A \'KZ « 7r'z|, see Exercise 6.1.2. We then get the statement 
as in the lemma. 
• 
In order to get a better handle on subobjects in Set(p), one uses so-called 
strict predicates. 
E 
6.1.5. Definition. Let 
^P be a higher order fibration. 
(i) For an object (/,«) G Set(p), a strict predicate on (/,«) is a predi-
cate A G E/ which satisfies in p 
21,22:/ I A[ii),ii 
« / 2*2 \- A{i2) 
and 
i\ I \ A[i) h Ei[i). 
(ii) We form a category SPred(p) of Hi-equivalence classes of strict pred-
icates, by stipulating that a morphism from a strict predicate A on (/,«) to 
a strict predicate B on (J, ?^) consists of a map F: (/,«) -> (J, ~) in Set(p) 
for which we have in p 
i:I\A{i) 
\-3j:J.F{iJ)AB{j). 
This category SPred(p) comes with an obvious forgetful functor SPred(p) -> 
Set(/>). As usual, we do not distinguish notationally between a strict predicate 
and its equivalence class. 
E 
6.1.6. Proposition. Assume 
jj^P is a higher order fibration. 
SPred(p) 
(i) The above functor 
i 
is a poset fibration. The order in the fibre 
Set(p) 
over (/,«) 25 the order inherited from p^s fibre over I: for strict predicates 

380 
Chapter 6: The effective topos 
A,B on (/,«) one has 
A<Bin 
SPred(p) over (/,«) 
^ 
i: I \ A{i) h B{i) in p. 
(This may look confusing^ since < on the left is a partial order, whereas h on 
the right is a preorder; but we should have written the equivalence classes of 
A,B on the left.) 
(ii) Strict predicates on (/,«) correspond to subobjects o/(/,«) in Set(p) 
in the sense that there is an isomorphism of fibred categories, 
Sub(Set(p)) 
= 
^ SPred(p) 
Set(p) 
SPred(p) 
(iii) The 
fibration 
i 
of strict predicates is a higher order fibration. 
Jf for the time being, we mark its connectives with a tilde'^, then expressed 
in terms of the connectives of p (which are written in ordinary fashion), we 
have 
• propositional connectives in the fibre over (/, ^) are L = 1.,W = \/,T = Ej, 
A = A and ADB 
= Ei A{AD 
B). 
• For a strict predicate A over (/, «) x (J, «), 
3j:J.A{iJ) 
= 3j:J.E(j)AA{iJ) 
= 
3j:J.A(iJ) 
y : J. A(i, j) = E{i) A Vi: J. E{j) D A{i, j) 
E^q{A){iJ,f) 
= 
A(iJ)A\j^jf\. 
• The object Q E M in the basis of p with logical equivalence DC as equality 
^Q, carries a (split) generic object, namely the strict predicate 
a: Prop h true(a) = \a «n T|: Prop. 
Thus, in the logic of strict predicates in p—or subobjects of Set(p)—the 
operations T, D, V and Eq are only slightly different from those of p. 
Proof, (i) For a morphism F: (/, «) —>- (J, ^) in Set(p) and a strict predicate 
B on (J,«), one gets a strict predicate on (/, ^) by 
i: I \-F*{B)(i) 
"M 3j: J. F(i, j) A B(j): Prop. 
For strict predicates A, B on (/,«) one has A < B over (/,«) if and only if 
i:I\A{i) 
l-3i':/. | i « / i ' | A B ( i ' ) . 
But the predicate on the right of the turnstile h is clearly equivalent to B{i). 

Section 6.1: Constructing a topos from a higher order fihration 
381 
(ii) For a strict predicate A on ( / , « ) one forms a new object (/, « ^ ) by 
def 
21,22:/ H |2i ^A «2| = ^(«'l) A |2i « / 2211 Prop 
It gives rise to an obvious mono in Set(p), 
And conversely, given a mono M : (X, '^x) 
^-^ (-^J ^ ) c>ne forms a strict predi-
cate AM on (/, ?5:i) by 
i'.I ^ 
AM{i)^^^x:X.M{x,i):?xop. 
Then, starting from a strict predicate A, we get 
A^^{i) 
= 
3 2 ' : / . | 2 ' « ^ 2 | 
= 
3 2 ' : / . ^ ( 2 ' ) A | 2 ' ' ? ^ / 2 | 
- 
A[i). 
And in order to show that M and W ^ M S'^^ ""is® ^o ^-^e same subobject of 
( / , « ) we define maps G, 7/ in 
G 
(^,«x) 
(/,« ^ M J 
by G{x,i) 
= M(x,2) = H{i,x). 
It is easy to see that G and H form an 
isomorphism between M and « A M -
For a morphism F: ( / , « ) -^ ('/j^) from A to B in SPred(p) one gets a 
commuting square 
\ 
F ' 
( ^ , « B ) 
( J , « ) 
by putting 
i: I,j: J h F'(i,j) 
"5^' F ( i , i ) A Aii) A 5 ( i ) : Prop. 
Remaining details are left to the reader. 
def 

382 
Chapter 6: The effective topos 
(iii) It is easily verified that the prepositional connectives are as described 
above. The existential and universal quantification have this form since weak-
ening along the projection TT: (/,«) x (J,«) -^ (/,«) is given by 
7r*(B){iJ) 
= 
3i':L7r{i,i'J)AB{i') 
= 
3i':L\i^i'\AE{j)AB{i') 
- 
E{j)AB(i). 
For equality, consider the parametrised diagonal 
(/,«) X (J,«) 
z.^liiZ 
^ ((/,«i) X (J,^)) 
X (J,«) 
Then for a strict predicate B one has 
S*iB)(i,j)^B(i,j,j), 
SO that putting Eq(i, j , / ) = ^(2,i) A \j « j / | yields the required adjunction 
Finally, for each strict predicate A on (/,«) we get a characteristic map 
char(A): (/,«) -^ (Q,«) in Set(p) by 
def 
i: /, a: Prop h char(A)(i, a) = E'(i) A \A{i) «n a|: Prop. 
Then 
char(74)*(true)(2) = 3a: Prop. char(74)(i, a) A true(a) 
= Ba: Prop. \A{i) ^ci «| A E{i) A \a ^Q, T | 
^ E(i) A \A{i) ^n T| 
- 
A{i), 
We still have to show that char(^) is unique with this property. So assume 
F: (/,«) -^ (fi,«) also satisfies F*(true) ^ A, then 
A{i) ^ F*(true)(i) = 3a: Prop. F(i, a) A \a «n T| ^ F(2, T), 
so that 
(*) 
char(A)(i, a) ^ £"(0 A |^(0 «n a| = ^ ( 0 A \F{i, T) «n ct| ^ F(i, a) 
where the last isomorphism (*) arises as follows. Given F{i,a), one has E(i) 
by definition; also one has F(i, T) «n <^) since: from F(i, T) we get a «n T by 
single-valuedness; this yields a. Conversely, given a, we get a «n T, and thus 
F(i, T) from F(i, a). For the reverse of (*), assume E(i)A\F(i, T) «n <^|- From 
£•(2) we get F(z, /?) for some /3. But then, as we have just shown, F(i, T) «n /?• 
This yields a «n F{i, T) «n Z^, and thus F(i, a). 
• 

Section 6.1: Constructing a topos from a higher order 
fibration 
383 
6.1.7. Corollary. If p is a higher order fibration, then Set(p) is a topos. 
Proof. The isomorphism of fibred categories in the previous proposition 
Sub(Set(p)) 
makes the subobject fibration 
i 
a higher order fibration, and it hence 
Set(p) 
makes Set(p) a topos, see Corollary 5.4.9. 
D 
6.1.8. Examples, (i) If fi is a complete Heyting algebra, then we get Four-
man and Scott's category fi-set as a result of applying the Set(—) construc-
Fam(ri) 
tion to the higher order family fibration 
i 
. The object Q, with ordinary 
equality forms a subobject classifier with truth map true: 1 -^ Q given by 
truelx Gt] — \ 
^ ' ^ 
[ ± otherwise. 
It can be shown that this category Q-set is equivalent to the category of 
sheaves on Q—with "sup" topology as in Example 5.6.3 (i), see [80] or [36, 
III, 2.8 and 2.9] for details. This result is due to Higgs. 
(ii) Our main example is Hyland's effective topos Eff arising from ap-
UFam(PN) 
plying the above construction to the realisability fibration 
i 
. Its sub-
object classifier true: 1 -^ Q has codomain Q — PN with equality given by 
where a, (3 C N. Thus a and /S are identified if and only if there are codes 
n,m £M with 
"ik E <y-n ' k G l3 
and 
^k E f^.m • k E a. 
This effective topos Eff—or als called realisability topos—will be further in-
vestigated in the remainder of this chapter. 
We conclude this section with a characterisation of epis and quotients. 
6.1.9. Lemma. A morphism F: (/,«) —> {J,^) is an epimorphism in Set(p) 
if and only if in the logic of the fibration p it is the case that 
j:J\E{j) 
\-3i:I.Fii,j). 
Proof. Since Set{p) is a topos, F is an epi if and only if it is a cover, and the 
latter if and only if it is an internal epi in the logic of the subobject fibration 
of Set(p), see Lemma 4.4.7. If we use the equivalence between subobjects and 
strict predicates from Proposition 6.L6 (ii), and express 'internal surjectiv-
ity' in terms of strict predicates, we get j:J \ E{j) h 3z:/.F(i,j), see also 
Exercise 6.1.3. 
• 

384 
Chapter 6: The effective topos 
6.1.10. L e m m a . Let (/,~) be an object ofSet{p). 
Call a strict relation R = 
{i,i':I 
h i^(i, i'): Prop) almost an equivalence relation on ( / , « ) if R is 
symmetric 
and transitive 
and satisfies i: I \ E(i) h R(i, i). 
In that case R is obviously an equality predicate on I, and it forms an epi 
i ? : ( / , « ) -^ {I,R) in Set(p). 
Moreover, 
every quotient (/, ^) -^ (J, « ) is of this form (/, « ) -^ (/, R) for 
such an almost equivalence relation 
R. 
Proof. The first part of the lemma is easy. For the last part, assume an epi 
def 
F:{I,^) 
-^ (J, « ) . We get a strict predicate R{i,i') 
— 3j: J. F{iJ) 
AF{i'J), 
which is almost an equivalence relation on (7,«). The logical characterisation 
of F as epi in the previous lemma yields that (7,«) -^ ( J , « ) is the same 
quotient as (7,?^) -^ (7,7^). 
O 
Exercises 
6.1.1. 
In order to check that two representing elements F^G of maps (7,«) = | 
(J^^) in Set(p) are equivalent, show that it suffices to have F < G (in the 
fibre over I x J). 
6.1.2. 
Prove that an object (7,?^) G Set(p) is isomorphic to the object (7 x 7,^) 
with equality 
z,w: I X I \- \z ^ w\ = \i:z ^j 7rw\ A\Tr z ^i n w\ A {nz P:^ TT Z\: Prop. 
6.1.3. 
Let F:(7,«) -> (J, ~) be a morphism in Set(p). Check that its graph 
(id,F):(7,«) >-^ (7,~) x (J, ~), considered as a strict predicate, is simply 
i:I,j:J 
\- F{i,j): Prop. 
6.1.4. 
For F: (7,«) -> (J, ^) in Set(p), prove that the resulting substitution func-
tor F*: SPred(p)(jg-) -> SPred(p)(/«) has both a left and a right adjoint 
given on B = {j: J h B{j): Prop) by 
i: I h 3F{B){i) = 3j: J. F(z, j) A B{j): Prop 
def 
ill 
I - V F ( B ) ( 0 = F ( O A V J : J.F(2,j) D BO): Prop. 
6.1.5. 
Describe singleton maps {}: (7,«) -^ P(7,?^) in Set(p). 
E 
6.1.6. 
Let 
iP be a higher order fibration. Define a functor Eq:B —)• Set(p) by 
B 
equipping an object 7 G B with internal equality (7,Eq(7)). Show that one 
can recover p from Set(p) via the change-of-base situation, 
E 
^ Sub(Set(p)) 
— 
^ Set(p) 
Eq 

Section 
6.2: The effective 
topos and its subcategories 
of sets, uj-sets, 
and PERs 
385 
6.2 The effective topos a.nd its subcategories 
of sets, uj-sets, and 
PERs 
We now start the investigation of the effective topos EfF, arising as a special 
case of the construction described in the previous section. We focus on how the 
categories of sets, of u;-sets and of PERs are related to EfF (following [142]). 
In particular, we will describe how the double negation nucleus -i-i on Eff 
has Sets as its category of sheaves and a;-Sets as its category of separated 
objects. In the next section we shall deal with families of u;-sets and of PERs 
indexed by objects of EfF. 
We start by identifying global elements in EfF. 
6.2.1. Lemma, (i) For an object ( / , « ) G EfF, the set T{I,^) 
of global ele-
ments 1 -^ (/, ^) can be described as the quotient 
set 
r ( / , « ) = {iel\ 
E(i) i^ 0 } / - 
where 
i ~ f' <^ \i ^i'\^ 
0. 
(ii) For a map F: (/, ^) -)• (J, ^) in EfF we get a function 
TF: T{I, ^) 
-^ 
r ( J , « ) by 
W ^ { i e J | F ( i , i ) ^ 0 } . 
This describes the global elements 
(or sections) functor 
T: EfF-> Sets. 
Notice that ^ is a partial equivalence relation on /, and so an equivalence 
relation on the subset of / for which i ~ i (that is E{i) ^ 0), see Exercise 1.2.5. 
ProoF. (i) A morphism G: 1 -^ (/, ?^) in EfF is a function G\ I ^ 
P N with 
G(io) ^ 0 for some to £ F Then E{io) / 0 and we have an equivalence, 
z : / | T 
\-G{i)3Z\i^iol 
so that G may be identified with the class [io]. Conversely, given such a class, 
we get a (unique) map 1 -> ( / , « ) in EfF by this logical equivalence DC. 
(ii) Assume an equivalence class [i] E T{I,^); 
then E{i) 
^ 
0, and so 
F{i,jo) 
^ 0 for some jo E J. Hence E{jo) ^ 0 and we have an equivalence 
F(i, j ) i c | i « io| like above. 
D 
6.2.2. Proposition. There is a functor 
V: Sets -^ EfF which maps a set J 
to the object {J,=) 
with 
\ J - J \ - U i ^ I J - J ) - I 0 
otherwise. 
This functor V is full and faithful and has the global sections functor T: Eff -^ 
Sets as left 
adjoint. 

386 
Chapter 6: The effective topos 
Because F preserves finite limits, we have a geometric morphism Sets -> 
EfF. It is what is called an "inclusion of toposes", since the direct image part 
V is full and faithful. 
Proof. For a function /: J —>• K one gets a morphism V/: V J -^ VK in EfF 
by the predicate 
l v / M J - « ; - I 0 otherwise. 
We establish a bijective correspondence 
r(/,«) 
^ J 
in Sets 
(/,«) - — ^ VJ 
in Eff 
G 
in the following manner. Assuming a function f:T{I,^) 
-> J, there is a 
predicate /: / x J -> PN given by 
j^..^^(E{i) 
i f E ( i ) # 0 a n d / ( [ i ] ) = j 
0 
otherwise 
which yields a map (/,«) -> V J in EfF. And conversely, given a map G as 
above, one gets a function F(/,«) —> J by the following recipe. For a class 
[i] e r ( / , « ) one has £"(2) / 0, and so G(i,j) / 0 for some j E J. But this j 
is unique, since the equality of V J is actual equality on J. 
Notice that the counit e: FVJ ^ J is thus given by [j] = {j} »->• j . Hence 
it is an isomorphism, and, as a result, V: Sets —> EfF is full and faithful. For 
future reference, the unit rj: (/,«) —> VF(/,«) is given by the predicate 
Etafi U']) = I ^(') '^ ^^ = f*"^' '•'• '^ I* ^ '"I ^ ^ 
'^ ' '• -"^ 
[ 0 
otherwise. 
D 
If we replace Sets by a;-Sets then we have a similar result. 
6.2.3. Proposition. There is an inclusion functor X:UJ-Sets —^ Eff which 
maps an uj-set (J, E) to the object (J, =E) with 
'•^ ^ -^ ' 
\ 0 
otherwise. 
This functor X is full and faithful and has a left adjoint s, which maps an 
object (/, «) G Eff to the set F(/, «) of global elements of {I,«) with existence 
predicate 
Em = u E{i'). 
'•'en 

Section 6.2: The effective topos and its subcategories of sets, uj-sets, and PERs 387 
The notation s for this left adjoint is in accordance with the notation s for 
separated reflection in Section 5.7, because that is what this functor will turn 
out to be. 
Proof. We seek correspondences 
s(/,?^) 
>• {J,E) 
in cj-Sets 
( / , « ) — ^ I ( J , ^ ) = (J,=£) 
inEff 
G 
They are essentially as in the proof of the previous proposition, except that 
we have to be more careful about codes. 
• Starting from a morphism /: s(/, ^) -^ {J,Ej) in a;-Sets, we have by defi-
nition a function /: r ( / , « ) -^ J for which there is a code e satisfying: for 
each m G E[[i]) — Ui/Gm ^^(0 ^^ ^^iNe e m E Ej(f{[i])). 
We get a predi-
cate / as in the previous proof. The code e is then used for the validity of 
strictness and single-valuedness: 
i:I,j:J\niJ) 
h 
E(i)AE(j) 
r-I,Jj'--J\7{i,J)J{i,f) 
\- \J=JJ'\-
• Conversely, for a map G:{I,^) 
—> (J, =E) in EfF we may assume codes 
ni G 
f]{E{i)D\jGii,j)) 
iei 
jeJ 
n2 e 
n 
{G{iJ)DE{i)AE{j)) 
{ij)eixJ 
For each [i] E r ( / , « ) there is a unique j E J with G{i,j) 7^ 0. A code for 
the resulting function r ( / , « ) —> J is obtained as follows: if m E ^([2]) = 
Ui/Gh] ^/(O) s^y '^ ^ ^i{^') ^^^ ^' ^i^h \i ~ i'\^ 
0; then the unique j E J 
with G{i,j) / 0 also satisfies G[i',j) ^ 0. Using the above codes ni, 712 we 
get ni • m E G[i'^j)^ and so the second component of n2 • [ni • m) is in 
Ej[j). 
Again, the counit of the adjunction is an isomorphism, so that the functor 
cj-Sets -^ EfF is full and faithful. 
D 
It is easy to see that the functor V: Sets -^ EfF factors through the embed-
ding cj-Sets -^ EfF via the functor Sets -^ a;-Sets from Section 1.2. If we also 

388 
Chapter 
6: The effective 
topos 
involve the inclusion PER -^ u;-Sets, then we get a summarising diagram 
Sets 
cj-Sets c 
^ Eff 
PER 
in which all arrows <^ from left to right are full and faithful functors, and the 
arrows in opposite direction are their left adjoints. Thus, these adjoints t:^ 
are reflections. In this diagram, the categories Sets and EfF are toposes, but 
a;-Sets is not a topos, see Exercise 6.2.5 below. 
The images of these functors <^ in EfF can also be described intrinsically. 
Therefore we need the following notions. 
6.2.4. Definition, (i) An object (/,«) G Eff will be called canonically 
separated if both 
\i ^j i'\ ^ 0 n> i = i' 
and 
Ei(i) ^ 0 
for all i,i' E /. Or equivalently, if 
SO that » / is completely determined by its existence map Ej: I —^ PN. 
(ii) And (/, «) is canonically a sheaf if both 
If ^j i'\ ^ 0 r:> i = i' 
and 
P I E{i) / 0. 
i€l 
Such a canonical sheaf (/,«) is thus certainly canonically separated. 
(iii) Finally, (/, ^) G Eff is called modest (or a modest set, or also an 
effective object) if it is canonically separated and satisfies 
^ / ( i ) n ^ / ( i ' ) ^ 0 => i = i'. 
Often we say that an object is canonically separated, a sheaf or modest if it 
is isomorphic to an object which is canonically separated, a sheaf or modest. 
6.2.5. Proposition, (i) The category uj-Sets is equivalent to the full subcat-
egory of Eff on the canonically separated objects. 
(ii) And Sets is equivalent to the full subcategory of canonical sheaves. 
(iii) Finally, PER is equivalent to the full subcategory on the modest sets. 
Proof. The canonically separated objects (/,«/) are determined by their 
existence predicates Ej.I 
-^ PN, which satisfy Ej{i) ^ 0. These correspond 

Section 6.2: The effective topos and its subcategories of sets, uj-sets, and PERs 389 
to u;-sets. And the Ej: I -^ PN with disjoint images {i.e. the modest sets) 
correspond to PERs, see Exercise 1.2.9. And if Hfc/ ^ ^ ( 0 7^ ^^ then we may 
as well assume Ej{i) = N. But such objects correspond to sets. 
• 
The double negation nucleus in EfF 
In the remainder of this section, the notions of 'closed', 'dense', 'separated 
object' and 'sheaf will refer to the double negation nucleus -i-i on the effective 
topos EfF. We first notice that for a E ^ — P N one has 
^ a = ( a D ± ) = { n i V m G a . n . m G 0 } = | 0 
^ ^ j ^ ^ ^ ^ . ^ ^ 
And thus 
f I w 
cA^ f N if a ^ 0 
-.-.a =. {n I Vm G -^a. n • m G 0} = I 0 otherwise. 
Thus ->-ia simply tells whether a is empty or not; it forgets about all the 
realisers (elements of a). 
A subobject of (/, «) in EfF can by Proposition 6.1.6 (ii) be identified with a 
UFam(PN) 
strict predicate A: I -^ PN on / G Sets in the realisability fibration 
i 
Sets 
Its double negation is given by the predicate 
--A(i) = E{i) A {{E{i) A (A{i) D A.)) D ±) 
E{i) ifA{i) 7^0 
I 
otherwise. 
Such a predicate A is thus closed if 
And A is dense if for each i G / 
E{i) ^ 0 ^ 
A{i) i^ 0. 
The latter is of course different from 'A holds', which is 
m^w^^wj ^0-
(This validity requires a uniform realiser.) 
We start with two basic lemmas. 

390 
Chapter 6: The effective topos 
6.2.6. Lemma. Closed subobjects of (/,«) E EfF can be identified with or-
dinary subsets o / r ( / , « ) G Sets. More formally, there is a change-of-base 
situation, 
ClSub(Eff) 
^ Sub(Sets) 
Eff 
^ Sets 
r 
Proof. Closed strict predicates A on (/,«) are turned into subsets by 
^^{[i]Gr(/,«)M(i)^0}. 
And conversely, given a subset 5 C r(/, ^) one gets a closed strict predicate 
1^(0 
if£(i)^0and[f]e5 
^ ^ 
[ 0 
otherwise. 
D 
6.2.7. Lemima. (i) Consider a canonical subobject {I,^A) 
^^ {^^^) ^n EfF 
given by a strict predicate A on (/,«). Then 
(/, «) is canonically separated/modest 
=> {I,^A) 
is canonically 
separated/modest. 
(ii) // R is almost an equivalence relation on (/, ^) which is closed, then 
(I, R) in the quotient (/, «) -^ (/, R) is canonically separated. And it is modest 
if (/,«) 25. Vice-versa, if (/, R) is canonically separated, then R is closed. 
Proof, (i) Consider the subset I' = {i £ I \ A{i) ^ 0} of /, with equality 
\i «j/ i'\ = A{i) A \i ^i i'\, which was written as ^A earlier. Then (/, «^) is 
equal (as a subobject) to (/',«//). Hence it is canonically separated/modest 
if (/,«) is. 
(ii) Assume R: I x I —> PN is a closed and almost an equivalence rela-
tion on (/,«). Closedness means that R[i,i') is E{i) A E[i') if R[i,i') 
/ 0 
and 0 otherwise. One can then show that (/, R) is equal (as a quotient) to 
(r(/,«),P) where 
Hnl 
M 
= |J^^(''i''*2) I A ^ [n] and z'2 E N ) . 
And if (/,«) is modest, then r ( / , « ) = /, so that E{ii) DE{i2) i^ 0 implies 
E{i\) n ^(2*2) 7^ 0 and thus i\ — 2*2. Finally, if (/, fl) is canonically separated, 
then, if R{i^i') ^ 0 we get 2 = 2'. Hence closedness follows from reflexivity 
2 : / | ^ ( 2 ) 1-^(2,2). 
• 
Our next aim is to show that the (-i-i-)sheaves in EfF are sets and that the 
(-1-1-)separated objects are u-sets. The first can be established by a three-line 

Section 
6.2: The effective 
topos and its subcategories 
of sets, LO-sets, and PERs 
391 
topos-theoretic argument using the geometric inclusion Sets <^-> EfF, see [142]: 
there must be a nucleus j on EfF with Sets 2:^ Shj(EfF); since V: Sets -^ EfF 
preserves the initial object, one gets j < -i-i. But since Sets is Boolean, one 
must also have j > -"-t. 
Because we have not seen all the topos theory used in this argument, we 
give a direct proof, based on the theory in Sections 5.7 and 5.8. 
6.2.8. Theorem. The category of sheaves of the double negation nucleus -«-> 
on the effective topos EfF is equivalent to Sets. And the category of separated 
objects is equivalent to u;-Sets. 
ProoF. We use the 'logical' characterisations of separated objects and sheaves 
in Theorem 5.8.2. For separated objects, to prove the result, it suffices to show 
that 
(J, ^) if canonically separated <^ 
C\ (-"-"Ij ~ j i'| D \j ^j f\) / 0. 
where the right hand side expresses that internal and external equality on 
(J, ?^) coincide (in the fibration of closed subobjects). 
For the implication (=>) assume 
m G --IJ ~ j ; I - I 0 
otherwise. 
Then m G E{j) A E{j') and \j « j j ' | ^ 0. The latter yields j = / , because 
(J,«) is canonically separated. Hence the first projection pm is in E(j) — 
For the implication (^), assume e is a code in the non-empty set on the 
right. We show that the unit r]\ (J,«) -> Vr(J, ^) is a mono. Since VT{J, ^) 
is separated. Lemma 6.2.7 (i) yields that (J,«) is isomorphic to a canonically 
separated object, as required. By Lemma 6.1.4, the unit rj is monic if and only 
if we have validity of the following entailment. 
ii,i2: J,[i3]:r(J,«) I Eta(ii,[i3]),Eta(i2,[i3]) H |ji w J2I. 
(See the end of the proof of Proposition 6.2.2 where the predicate Eta 
is described explicitly.) If we have elements mi G Eta(ji,[j3]) and m2 G 
Eta(J2, [is]), then mi G E{ji) and |ji ^ js] ^ 0 and also m2 G ^(^2) and 
\J2 « jsl ?^ 0- Then |ji ?^ ^2! 7^ 0, so that the pair (mi,m2) is in ->-i|ii « J2I, 
and so we may conclude that e • (mi, m2) is in \ji ^ J2\-
Now we come to sheaves. Let (J,«) be canonically a sheaf. In order to 
prove that (J, ?^) is a sheaf, we use Theorem 5.8.2 (ii). (An alternative is 
in Exercise 6.2.6 below.) We thus have to show that unique choice holds on 
(J,«) in the fibration of closed subobjects. Following Definition 4.9.1, let 

392 
Chapter 6: The effective topos 
R: I X J -^ P N be a closed single-valued strict relation on (7, ^) x (J, « ) . We 
have to show that the canonical map F is an isomorphism in 
{IxJ,^n) 
- - - - ( / , « ) 
Y 
Y 
(/,«)x(J,«) 
- ( / , « ) 
where ^ is the equality of the coproduct 3n{R) 
= ""^[Jj^j 
R{~^j)' 
The 
canonical map F is given by 
F ( i , j , 0 = 
\i^i'\AR{iJ)=G{i,i'J). 
We use Lemmas 6.1.4 and 6.1.9 to show that F is both a mono and an epi, 
and thus an isomorphism in EfF. Since the relation R is single-valued, F is a 
mono. In order to show that F is an epi, we need to find a realiser in 
C]\i^i\D[JR(i,j), 
iei 
j€J 
f]\E{i)D[jR{iJ) 
iG/with [JR{iJ)^ib 
\ . 
jeJ 
J 
We use codes k E f]j^j 
E{j), and e e f]{ij)eixJ~'~'^i'^^^) 
^ ^ihj)- 
Assum-
ing m G E{i) where [jj^j 
R{hj) 
^ 0, we get R(i,j) 
^ 0 for some j E J. Then 
(pm, k) G E{i) A E(j), 
so that e • (pm, k) G R{i,j). 
And this for all i G /, as 
required. 
Conversely, if ( J , « ) is a sheaf, then we already know that the unit map 
T]: ( J , « ) -> V r ( J , « ) is a mono. It is easily seen to be dense. But it is closed 
by Exercise 5.7.3 since ( J , « ) is a sheaf, so this unit is an isomorphism. 
• 
Exercises 
6.2.1. 
Verify that the global sections functor F i E f F ^ Sets satisfies 
/ 
true 
\ 
/ 
1 
\ 
r ( i — ^ Q ) = 
{i—^{0,1}). 
6.2.2. 
Give direct proofs that the functors Sets -> Eff and a;-Sets -> EfF are 
full and faithful (without using the adjunctions like in Propositions 6.2.2 
and 6.2.3). Check also that FrEfF^ Sets preserves finite limits. 
6.2.3. 
Prove that the separated reflection functor s: EfF-> a;-Sets preserves finite 
products. (It does not preserve finite limits.) 

Section 6.3: Families of PERs and u)-sets over the effective topos 
393 
6.2.4. 
Show that an object (/, «) 6 Eif is a modest set if and only if it is canoni-
cally separated and satisfies: \i ^i i'\ = Ei{i)r\Ei(i') 
for each pair i, i' G /. 
6.2.5. 
The point of this exercise is to show that the category a;-Sets of a;-sets is 
not a topos. We use the a;-set (N,E) with E{n) = {n}, which is a natural 
numbers object in a;-Sets, see Exercise 1.2.10. 
(i) 
Let /: (/, E) -^ (J, E) be a morphism in a;-Sets. Show that / is monic 
in u;-Sets if and only if / is injective (between the underlying sets /, J). 
And similarly that / is epic in a;-Sets if and only if / is surjective. 
(ii) Let yl C N be an arbitrary subset. We define an u;-set (NjE^i) by 
1 {{^^^)} 
otherwise. 
There is then an obvious morphism of u;-sets 2:(N,E'^) -^ 
(N,JE), 
which is tracked by a code for the second projection {m,n) \-^ n. By (i) 
this map i is both a mono and an epi. If u;-Sets were a topos, then i 
should be an isomorphism, see Exercise 5.4.1. Verify that a code for an 
inverse of i yields a decision code for A. But A is an arbitrary set... 
6.2.6. 
Here is an alternative proof that objects of the form VX are (->-<-)sheaves 
in EfF; it involves less hacking with realisers than above. First show that 
for a dense mono {I,^A) 
^-^ (^J^)? given by a strict predicate A: I ^ PN 
on (/, ^) one gets r(I,'^A) 
= T{I,^) 
in Sets. Deduce now that any dense 
partial map (I,^) 
^-< (I^^A) 
—>• VX has a (unique) extension (/, J^) —)• 
VX, using the reflection (F H V). 
6.2.7. 
Notice that the fact that the regular subobjects in C4;-Sets yield a higher 
order fibration with classical logic (as stated in Proposition 5.3.9) is a con-
sequence of Theorem 6.2.8 and Corollary 5.7.12. 
6.2.8. 
Prove the fact, used in the proof of Theorem 6.2.8, that if (J, «) is separated, 
then the mono r/: (J, ?:i) ^^ VF( J, ?^) is dense. 
6.3 Families of PERs and co-sets over the effective 
topos 
Later on v^e shall be using the effective topos EfF as a universe for models 
of type theories, in v^hich types are interpreted as PERs (in polymorphic 
type theories, see Chapter 8), and kinds as cj-sets (in polymorphic/dependent 
dependent type theories, see Chapter 11). In order to do so we need to consider 
PERs and u;-sets suitably indexed by objects of EfF. This is the subject of the 
UFam(PER) 
UFam(u;-Sets) 
present section. We shall define split fibrations 
i 
and 
i 
, 
^ 
Eff 
Eff 
UFam(PER) 
UFam(u;-Sets) 
v^hich are very much like the fibrations 
i 
and 
i 
of cj-set-
CJ-Sets 
, 
C<;-Sets 
indexed-PERs and cj-set-indexed-cj-sets, that we introduced in Section 1.2. 
Although we use each of the names U F a m ( P E R ) and UFam(cc;-Sets) twice 
(over c<;-Sets and over EfF), we refer in each case to two different categories: the 

394 
Chapter 6: The effective topos 
total categories UFam(PER) and UFam(a;-Sets) will be different, whether 
we consider them over a;-Sets or over Eff. But as long as we present them 
together with their base categories, confusion is not likely to occur. 
(In the next chapter we shall see that PERs form an "internal category" in 
UFam(PER) 
UFam(PER) 
u;-Sets and also in EfF, and that the 
fibrations 
i 
and 
i 
a;-Sets 
Eff 
are the "externalisations" of these internal categories.) 
We start with PERs indexed by objects of EfF. This is as in [143]. 
6.3.1. Definition. For an object (/,«) G EfF, consider the following "fibre" 
category. 
objects 
r(/, «)-indexed families (-R[i])[i]er(/,«) of PERs. 
morphisms 
f:{R[i]) 
—)- {S[i]) are r(/, «)-indexed collections / = 
(/[i])[i]€r(/,«) of maps / [ , ] : % -> ^ 
in PER which 
are uniformly (or, effectively) tracked: for some code 
eGN, 
Vi e L^me E(i), e • m tracks /[,] in PER. 
A morphism F\ (J,«) -> (/,«) in EfF induces a reindexing functor F* by 
{R\i]) H-> {RT{F){\J])) 
^^^ 
(/[»•]) "^ (/r(F)(L?])). 
Application of the Grothendieck construction yields a split fibration, which 
UFam(PER) 
will be written as 
i 
Eff 
This indexing of PERs by objects (/, 9^) G EfF is clearly similar to the in-
dexing of PERs by objects (/, E) G a;-Sets, as in Definition 1.4.8. This will be 
made precise in the proposition below. But first we introduce a similar index-
UFam(u;-Sets) 
ing of a;-sets over EfF via global sections. This yields a fibration 
4-
Eff 
where the total category UFam(a;-Sets) has, in the fibre over (/,«) G EfF: 
objects 
r(/, ?^)-indexed families (Xfj]) of cj-sets 
morphisms 
(-^[i]) —^ (^[«]) ^^^ r(/, «)-indexed collections {f[i]) of 
maps f[i]'-X[i^ -^ yjj] in cj-Sets which are uniformly 
tracked: for some code e G N one has Vi G /.Vm G 
E(i).e • m tracks /[jj in cj-Sets. 
Reindexing F* is above, for PERs. 
In the next result we relate indexing over EfF and indexing over ct;-Sets, 
both of PERs and of a;-sets 

Section 6.3: Families of PERs and oj-sets over the effective topos 
395 
6.3.2. Proposition. Indexing of PERs and of uj-sets over EfF and over 
u;-Sets can he related in the following manner. 
(i) There are change-of-base situations, 
UFam(PER) 
^ UFam(PER) 
UFam(a;-Sets) 
^ UFam(a;-Sets) 
J 
J 
Eff 
-^ u;-Sets 
EfF 
-^ u;-Sets 
where s: EfF —> a;-Sets is the separated reflection functor, as introduced in 
Proposition 6.2.3. 
(ii) Similarly, we have change-of-base situations. 
UFam(PER) 
J 
u;-Sets ^ 
UFam(PER) 
UFam(a;-Sets) 
^ UFam(u;-Sets) 
-^EfF 
u;-Sets ^ 
-^EfF 
(iii) The reflection P E R ^ a;-Sets lifts to a fibred reflection over EfF, in 
a diagram: 
UFam(PER) c 
^ UFam(u;-Sets) 
EfF 
ProoF. (i) By definition of indexing over EfF. 
(ii) Because if (/, «) G EfF comes from anu;-set (/, E), we have r(/, «) = /, 
so indexing over (/, «) E EfF takes the form of indexing over (/, E) G u;-Sets. 
(iii) By a pointwise construction. 
• 
In the previous section we saw that cj-sets can be identified within EfF as 
the (-'-'-) separated objects. So an alternative approach to cj-sets indexed by 
objects (/,«) G EfF would be to consider families I ^ ^ . I in EfF which 
are separated in the slice topos EfF/(/, ^). We recall from Exercises 5.7.1 and 
(X,«) 
Proposition 5.7.14 that such a family | 
J^^ 
) in EfF/(/, ^) is separated if 

396 
Chapter 6: The effective topos 
and only if the mediating map r]^ is a mono in: 
(X,«) 
(*) 
a,«) 
»?(/,«) •^vr(/,«) 
The underlying reason is that the sheafification functor a: EfF-> EfF is VF, 
/(X,«)\ 
f * \ 
and that sheafification in the slice EfF/(/,«) of 
, ^^ ^ 
is 
,^^ . , see 
Proposition 5.7.14. 
The full subcategory of EfT^ of (-<-'-)separated families is then written as 
FSep(Eir) 
FSep(Eff). The codomain functor is a 
fibration 
i 
Eff 
We first show that, when we restrict ourselves to cj-sets as indices, we indeed 
get families of u;-sets in this way. 
6.3.3. Proposition. // (/, ^) G Eff is a separated object, then a family 
^^ 
j is separated if and only if the object (X, ^) is separated. This 
means that there is a change-of-base situation, 
UFam(a;-Sets) -^ w-Sets"^ 
a;-Sets ^ 
FSep(Eff) 
^EfF 
Proof. If (/,?^) is separated, then the unit r](^i^<^y. (/,«) -^ VF(7,«) in the 
above diagram (*) is a mono. Hence the map • —> VF(X, ^) as well, because 
it is obtained by pullback. Thus we have: the family 
^^ 
I is separated 
<^ the map //(^ is a mono <^ the unit ^(x,w) is a mono <=> ( ^ J ~ ) is 
separated. 
D 
UFam(a;-Sets) 
FSep(Efr) 
The relation between the 
fibrations 
i 
and 
4- 
is rather 
Eff 
Eff 
subtle, and involves the manner in which the indexed u;-sets are given to us. 

Section 6.3: Families of PERs and uj-sets over the effective topos 
397 
The full story appears in Section 11.7 where it will be shown that the latter 
fibration is the 'stack completion' of the former. At this stage we merely note 
the following result, which will be crucial in modelling type dependency with 
indexed c<;-sets. 
6.3.4. Proposition. There is a full and faithful fibred functor over EfF 
UFam(u;-Sets) 
^ FSep(Eff) 
{i,x)^{i\x')\ 
= 
Eff 
As a result, we have full and faithful fibred functors (over EfFj^ 
UFam(PER) 
^ UFam(a;-Sets) 
^ FSep(Efr) 
^ Eff"' 
Proof. For a family X = (-^[i])[2]Gr(/,«) of a;-sets in UFam(a;-Sets) over 
(/,«) G EfF, form the set 
{X} = {(i, x)\i 
e I with Ej{i) / 0, and x G X[,]} 
with equality 
^i'\A 
E[x) if [{\ = [i'] and x = x' 
otherwise. 
Then E{i, x) = E[i) A E{x) ^ 0 for all (i, x) E {X]. Further, the set of global 
sections of this object is the disjoint union 
r({x},^)- 
]J x^y 
[^•]er(/,«) 
We can define a projection map T^X'- {{^]^ ^) ^ {h ^) in EfF by 
7Tx{{i.x),i')^ 
\i^ii'\AE{x). 
We claim this yields a separated family over (/,«). Consider therefore the 
following pullback diagram. 
d^},^) ^ - ^ ^ ^ ^ _ ^({X},«) 

398 
Chapter 6: The effective topos 
The map rjx herein is described by 
rlx{{^ux,)A^2A^3.^2))) 
= y^ 
otherwise 
which is a mono by Lemma 6.1.4. Hence the family I 
r ^^ 
I i^ separated. 
For a morphism (F, / ) : {X[i]) -> [Yu]) in UFam(a;-Sets), where F: (7, «) -^ 
(J, ^) is a map in EfF between the underlying index sets and / is a (uniformly 
tracked) family of maps /[i]*-^[i] —> ^r(F)([2]) in cj-Sets, we get a morphism 
{F,/}:{X}-^{y}inEffby 
such that TTy o {F, /} =: F o TTx. We leave it to the reader to verify that this 
yields a full and faithful fibred functor. 
• 
Exercises 
6.3.1. 
Show that the following diagram commutes, combining the functors from 
Propositions 6.3.3 and 6.3.4. 
u;-Sets-" 
^ FSep(Efr) 
UFam(u;-Sets) 
^ UFam(u;-Sets) 
-Sets ^ 
^ Eff 
6.4 Natural numbers in the effective topos and some 
associated 
principles 
In the final section of this chapter, we outline some aspects of the effective 
topos as a mathematical universe. In particular, we mention the natural num-
bers object N in Eff. It appears that Eff is the world of 'recursive mathemat-
ics': maps N ^ N in Eff can be identified with total recursive functions. This 
may even be internalised to give a stronger statement. We mention some of the 
principles that hold in Eff, like Markov's Principle, the Axiom of Countable 
Choice and Troelstra's Uniformity Principle. And in the end we investigate an 

Section 6.4-' Natural numbers in the effective topos and some associated principles 399 
alternative description of PERs (or modest sets) as subquotients of N. This 
description also applies to families of PERs (over separated objects). 
The material in this section comes from [142]. More information may be 
found there, and also in, for example, [297, 262, 218]. 
6.4.1. Proposition. The object N = (N, E) with E{n) — {n] and \n^ m\ — 
E(n)C\E[m) 
is natural numbers object in EfF. It is a modest set, by definition. 
Proof. The zero map 0:1 ^ A^ in EfF comes from the zero element 0 G N = 
r(N, E) in Sets as |- = 0|: 1 -> (N, E), or as predicate 
^ ^ ~~ 1^ 0 
otherwise. 
And the successor morphism S: N -^ N is the predicate 
^(n,m)-<^^ 
oth- = m + 1 
otherwise. 
Consider a diagram 1 —^ (L^) 
—^ (^5~)' where io E / is some element 
with E{io) ^ 0 (see Lemma 6.2.1). Write F ( " ) = F O • • • O F (n times), so 
that FW(ii,i2) = \ii « i2\ and F("+^)(ii,i2) = Bza:/. F(")(ii, 23) A ^(23,22), 
and define a morphism G: (N, F) —)• (/, «) by 
G(n,i) = F(n)AF(")(2o,i). 
It is easy to see that G is then a mediating map: G o 0 = [io] and G o 
S = F o G. Uniqueness of G is a bit more involved. Assume H also satisfies 
H o 0 = [io] and H oS = F o H, then we may assume codes 
a e f]G(0,i)DH(0,i) 
c G p | G ( n + l , i ) D l[JG{n,i') 
A 
F{i',i)\ 
i 
n,i 
\ i' 
/ 
b € f]G{n,i)D 
E(n) 
d G f| j | J / / ( n , 0 A F(i',f) J D F ( n + l , i ) . 
n,f 
n,i 
\ i' 
/ 
The following serves as motivation. Assume that we already have what we 
have to produce, namely a realiser e in E{n) D (G(n, i) D H{n^ 2)), for all n, i. 
Then e • n is in G(ri, i) D H{n,i), and this e • n can be used to construct a code 
in G{n -f- l,i) D i/(n -h 1,2). If m G G{n + 1,2*), then cm 
— (mi,m2} where 
mi G G(n, 2') and m2 G F(2', 2) for some i' G /. But then (e-n) -mi G i^(ri, 2'). 
So if we write 7713 = ((e • n) • mi,m2), then 
m3 G i/(n, 2') A F(2', 2) C [J H[n, i') A F(2', 2), 
i' 
so that d • m3 G //^(n + 1,2). And this for every 2 G /. 

400 
Chapter 6: The effective topos 
This tells us how to obtain such a code e by primitive recursion on n, as 
e • 0 = a 
and 
e - [n-\- \) — Am. d - {{e - n) • p(c • m), p'(c • m)). 
Finally, if we put 
e' = 
Ak.{e-{b'k))-k 
then e' G Hn,! ^l'^' 0 ^ ^ ( " J 0^ making G, if equal maps (N, E) -> (/, «). • 
In Brouwer's intuitionism, the real numbers M are understood in such a 
way that all functions M —> M are continuous, see [335, 4.12]. Classically this 
is not true of course, but there are toposes in which this does hold, see [188, 
VI, 9]. In a similar manner, all functions N -^ N in the effective topos EfF 
are recursive. This suggests that in EfF we are in the world of "recursive 
mathematics", where all functions are computable. 
In this way, toposes provide a rich supply of universes for various kinds of 
mathematics. 
6.4.2. Theorem. Morphisms F:(N,£') -> (N,£') in Eff can be identified 
with (total) recursive functions /:N —> N. 
Proof. Since the natural numbers object A^ = {^yE) is separated, and the 
embedding a;-Sets -> EfF is full and faithful, we have that a morphism 
F: (N, E) -^ (N, E) in EfF corresponds uniquely to a morphism /: (N, E) -^ 
(N,E') in w-Sets, where E{n) = {n}, see Exercise 1.2.10. But the latter has 
a code e E N satisfying f{n) —en. 
Thus / is a total recursive function. 
Translating this back to F in EfF, we can write F as 
{n} if m = e • n 
a 
^ ( ^ , n ) ^ / i ^ > ifm = e-
^ ' 
^ 
[ 0 
otherwise 
We would like to have an internal version of this result telling that for each 
/: N^ there is an e: A/" with f(n) — enm 
the internal language of EfF. Then 
one can properly say that Church's Thesis holds. But therefore we need to 
know what Kleene application e • n is in EfF. It turns out to be the same as 
in Sets, but this requires the following result about the exponent object N^ 
in EfF, and Markov's Principle. 
6.4.3. Lemma. The exponent N^ in Eff may he described as the canonically 
separated object (TR, E) where 
TR = {total recursive functions /:N —> N} 
E{f) 
- 
{e E N I e 25 a code for / } . 
Proof. Essentially this is because separated objects form an exponential 
ideal. Thus the exponent N^ in Eff is the same as in a;-Sets. 
D 

Section 6.4: Natural numbers in the effective topos and some associated principles 401 
In an arbitrary topos IB we have the object 2 == 1 -h 1 with cotuple 
[false, true]: 2 -^ ^. This map is a mono, by Exercise 4.5.1, since false, true 
are by definition disjoint. So one can identify the subobject 2 ^^ Q as the set 
{a: Q I a V -"a} of decidable propositions. It is not hard to show that a sub-
object X ^^ / is decidable [i.e. X V -iX = /) if and only if its characteristic 
map / -^ Q factors through 2 >-^ Q. By exponentiation we get that 
2^ = {^: n^ I Vi: /. f3{i) V -n/?(f)} ^ Q^ 
is the object of decidable predicates. 
6.4.4. Proposition. In Eff Markov^s Principle holds: one has 
V^: 2^. --i(3n: N. /?(n)) D 3n: N. p{n). 
Recall that in constructive logic, the premise ->-i{3n: N. I3(n) is logically 
equivalent to -tin: N.^l3{n). 
Markov's Principle says that if for a decidable 
predicate f3 on N we know that it is impossible that /? fails for all natural 
numbers, then /? must hold for some number n. This n can for example be 
obtained by testing /?(0), /?(!), /?(2),..., /?(n) until a candidate n is found. But 
there is of course no bound for this search. Therefore, the status of Markov's 
Principle within constructive mathematics is not uncontroversial. But since 
this search for the candidate n can be done via minimahsation in a computable 
way, Markov's Principle holds in Eff. 
Proof. It is convenient to identify 2^ with {/: N^ \ Vn: N. f{n) = 0 V f{n) = 
1}, so that we can use Lemma 6.4.3. For a total recursive function / E TR, 
let 
Af = 3n: N. {E{n) A \f{n) « 1|) C N. 
We have to produce an inhabitant of 
f] 
E{f)D{-^-^AfDAj). 
/GTR 
Recall from Section 6.2 that -'-^Af is either 0 of N, so a realiser for it will not 
contain any useful information. For / G TR and e G E{f), we know that e 
is a code for /. If m G "•"•^z, then there is an n G N with f{n) = 1. Thus 
minimahsation fin. (e-n = I) is defined and gives us a least such n. Therefore, 
e' = Am. fin. (e • n = 1) takes ~^~~^Af to Af. 
In the other case when -^-^Aj = 0, then e' vacuously takes -^-*Af to Aj. 
Hence Ae. Am. ^n. (e • n = 1) is a realiser for Markov's Principle. 
• 
6.4.5. Example. Recall Kleene's Normal Form Theorem {e.g. from [236, 
Theorem II. 1.2] or [66, 5, Corollary 1.4]): the basic predicates of recursion 
theory, 
e-nf, 
e ' n I, 
e - n = m 

402 
Chapter 6: The effective topos 
are definable in first order arithmetic via the T-predicate and output function 
[/, as 
e - n f <=> 
-^3x:N.T{e,n,x) 
e-ni 
<^ 
3x:N.T{e,n,x) 
6 71 = 171 <^ 3x: TV. T(e,n,x) A t/(x) = m 
The predicates T and U{—) = (—) are primitive recursive. Hence they are 
decidable, and so -•-•-closed. But then also the above predicates e • n t, e • n | 
and en = m are -•-•-closed, by Markov's Principle. Hence their interpretation 
is as in Sets. (They are 'almost negative formulas', see [142] for a complete 
account.) 
We can formulate and prove Church's Thesis inside EfF: 
V/: N^. 3e: TV. Vn: N. f{n) 
^e-n. 
Again we use Lemma 6.4.3. We have to produce a realiser in 
n 
E{f) D ( U E{e) A n E{n) D \f(n) « e • n| ) 
/6TR 
\e6N 
n6N 
/ 
But one can simply take Ae. (e, e). 
Markov's principle is one of the corner stones of the Russian school of 
constructive mathematics, founded by Markov. 
We turn to the Uniformity Principle. 
6.4.6. Definition. A type (or object) U is said to be uniform (with respect 
to N) if 
Va: Q^^^. (Vi/: U, 3n: N. a{u, n)) D (3n: N. Vix: U. a{u, n)). 
6.4.7. Proposition. In Eff* the powerobject PN = Q^ is uniform. 
D 
We refer to [142] for the proof. This principle can be understood as follows: 
PN is a very amorphous collection since predicates on N can be described 
in very many ways. Thus if we have assigned a natural number n to each 
predicate u: PN, then the only conceivable way of so doing would be to pick 
the same n for every u. See also [335, 4.9]. Uniformity may be used to prove 
the existence of products of PERs over PERs in EfF, see [297], so that one 
can interpret second order products in polymorphic type theory. 
PERs as subquotients of N 
In the remainder of this section we will use the natural numbers object 
AT = (N, £') in EfF to give an alternative description of (families of) PERs. Re-
call from Exercise 1.2.5 that PERs may be described as equivalence relations 

Section 6.4'- Natural numbers in the effective topos and some associated principles 403 
on subsets of N, i.e. as quotients of subsets of N. The latter are also called 
'subquotients' of N. This alternative description can also be given inside EfF. 
6.4.8. Proposition. The category PER of partial equivalence relations is 
equivalent to the full subcategory o/EfF on the separated ^subquotients' {X, E) 
of N = (NjE"). That is to those separated {X^E) occurring in a diagram 
(One may equivalently require the mono to be closed.) 
Recall from Lemma 6.2.7 (ii) that the quotient (Y, «) -^ (X, E) with (X, E) 
separated may be described via a closed, almost equivalence relation R on 
(y,«). 
Proof. Given a PER i? C N x N, we obtain such a subquotient, 
{n/R,G) ^Z- {\R\,») JU 
(N,E) 
where the (closed) mono M is obtained from the inclusion \R\ = {n \ uRn} C 
N. Thus M(n, m) = {n} D {m}. And the epi P: (|ii|,«) -^ (N/fi, G) is then 
given by P(n, [m]) = {n} D [m]. 
And if we have a subquotient 
then {X, E) is modest (and hence comes from a PER): if n G E(xi) fl E{x2) 
for xi, 2^2 G X, then, using appropriate codes a, 6, c, d we get: 
a-n G P(2/i,a:i) nP(?/2,a!2) 
for some yi, 2/2 G y 
6.(a-n) G 
E{yi)nE{y2) 
c ' {b ' {a ' n)) G M(i/i, mi) fl M(2/2 5 ?^2) for certain mi, m2 G N 
d-(c-(6-(a-n))) G ^(mi) H £;(m2). 
But since A^ = {^,E) 
is modest, the latter implies mi == m2. Reasoning 
backwards we get \yi « ^2! since M is a mono, \xi « X2\ and thus xi = X2, 
since (X, E") is separated. 
D 
This result has an extension to families of PERs, provided we restrict our-
selves to a separated index object. 
6.4.9. Proposition. For a separated index object (/, E) G Eff, the fibre cate-
gory l]¥dim{P'EiIl) (^j E) of (I, E)'indexed families of PERs is equivalent to the 
full subcategory of the slice category EfF/(/, E) on the separated subquotients 
of the constant family (/, 
Ey{N). 

404 
Chapter 6: The effective topos 
Proof. First notice that r ( / , E) = I. So assume an /-indexed family of PERs 
Rz= {Ri)i£j 
and form the diagram 
{{R}, 
2 ) -
^ 
{\\R\\,«) -
^ 
(/, E)x(m, 
E) 
(I,E) 
where M is a (closed) mono determined by the subset ||i?|| = {{h^) 
\ i G 
/ and nRiu} 
C / x N = T({I,E) 
x {N,^)) 
and ({/?}, ^ ) is as defined in 
the proof of Proposition 6.3.4, resulting from the inclusion UFam(PER) ^-> 
UFam(cc;-Sets) ^ 
EfT^. The morphism P: {\\R\\,^) 
-^ {{R},^) 
is given by 
p((i,n),(i',K]) = |z«i'|n({n}nK]). 
It is an epi by Lemma 6.1.9. 
And if we have such a diagram 
(X,«) 
^
^ 
(Y,«) 
J ^ 
(I, E) X (N, E) 
{I,E) 
where P is an epi, M is a mono and <^ is a separated family, then (X,«) 
must 
be separated by Proposition 6.3.3 so that we can identify 
with an 
(^'^) 
/ 
(/, E')-indexed family (X,-, E',)ig/ in 
i 
. The same argument as in 
UFam(a;-Sets) 
i 
u;-Sets 
the previous proof, applied fibrewise, yields that each (X,-, Ei) is modest. 
• 
Exercises 
6.4.1. 
Prove that a decidable predicate (v^ V -K/?) is -i-i-closed (""""V^ D <^). 
6.4.2. 
Consider for a subset A C N, the canonical subobject (N,^^) ^-^ (N,E) in 
Eff arising from y4:N -> PN as a strict predicate: 
i {(".0)} if n 
€A 
iA. 
Show that A is decidable in recursion theoretic sense if and only if A— 
i.e. (Nj-E^) >-^ (N,£^)—is decidable in topos theoretic sense. 
6.4.3. 
(i) 
Prove that if IJ is iiniform and IJ -^V^ 
then V is uniform. 

Section 6.4-' Natural numbers in the effective topos and some associated principles 40S 
(ii) Let (U,^) 
e EfFbe such that f)^^^ E{u) ^ 0. Prove that {U,^) is 
uniform, 
(iii) Conclude that every quotient of a sheaf is uniform in Eff. It can be 
shown that every uniform object is in fact a quotient of a sheaf. 
6.4.4. 
Prove that the following Axiom of Countable Choice holds in EfF: 
Va: Q^^^. (Vn: A^. 3m: N. a{n, m)) D (3/: N^.^n: 
N. a(n, 
f{n))). 

406 
Chapter 6: The effective topos 
This Page Intentionally Left Blank

Chapter 7 
Internal category theory 
So far, indexing has been described mainly in terms of fibred categories, but in 
Section 1.10 also (briefly) in terms of indexed categories. In this chapter a third 
formalism for indexing will be presented, namely internal categories. These 
are categories described internally in another "ambient" category, using the 
diagrammatic language of category theory to express the familiar constituents 
of a category. An internal category is thus like an internal group: it is obtained 
by interpreting the defining requirements of a category in some more general 
universe than the category Sets. One can also describe functors and natural 
transformations internally. And one can say when an internal category is, for 
example, Cartesian closed. 
Below we describe the basic (standard) ingredients of internal category 
theory. Our emphasis is on the relation between internal and fibred categories. 
It turns out that with an internal category one canonically associates a (split) 
fibration, which is called the externalisation of the internal category. Many 
concepts in internal category theory can also be expressed externally using 
fibred category theory. One of the more important results is that if a fibration 
is complete (in a fibred sense: it has fibred finite limits and products [u* H Yl^) 
satisfying Beck-Chevalley), then every "internal diagram" has a limit. Such 
a diagram can be understood as a functor from an internal category to the 
fibration. We thus have a fibred version of a familiar result in ordinary category 
theory: if a category has equalisers and arbitrary products, then every small 
diagram has a limit. 
Partial equivalence relations (PERs) form an example of an internal cate-
gory in the category of cj-sets, and also in the efi'ective topos. Externalisation 
407 

408 
Chapter 7: Internal category theory 
gives the (already defined) fibrations of PERs indexed by u;-sets, and of PERs 
indexed by objects in the effective topos. 
The role of internal categories in the semantics of (higher order) type the-
ories was first emphasised by Moggi and Hyland [143]. It will be investigated 
in the next chapter (and also in Chapter 11). 
7.1 Definition and examples of internal categories 
As we have seen in Section 3.3 the concept of a group (and of other alge-
braic structures) can be expressed in diagrammatic language, and can thus 
be described in arbitrary categories (with finite products). The idea is that a 
group in a category—i.e. an 'internal group'—is an object G equipped with 
morphisms 
m
e 
i 
GxG 
^G 
1 
^G 
G 
^G 
for multiplication m, neutral element e and inverse i. These are required to 
make some diagrams commute, expressing the fact that m is associative, e is a 
neutral element for m and that i provides an inverse for m, see Example 3.3.1. 
Clearly a group in the category Sets of sets and functions is just a group in 
the original sense. But an internal group in the category Sp of topological 
spaces and continuous functions is what is called a topological group. And an 
internal group in the category P o S e t s may be called an ordered group. 
An obvious question is whether one can also describe categories diagram-
matically. This involves describing one category inside another. It gives us 
extra generality, comparable to the generality provided by the description of 
a group as an internal group in a category, as in the examples just mentioned. 
For the description of internal categories we shall need more than just finite 
products in the 'ambient' category: we also need equalisers to form objects of 
composable arrows. 
7.1.1. Definition. Let B be a category with finite limits. An internal cat-
egory C in B consists of the following data. First there are two objects 
CQ,CI 
G B which should be understood as the object CQ of objects of C 
and the object Ci of arrows of C. These come equipped with morphisms in B 
ii 
X 
C\ 
Ci 
and 
Co 
>• Ci 

Section 7.1: Definition and examples of internal categories 
409 
representing the operations of domain 9o, codomain di and identity (on an 
object) in C. These should make the following diagram commute. 
Co 
C o - T — C i 
do 
di 
^Co 
Further, a composition morphism m is required. Therefore, we need the fol-
lowing two pullback diagrams. 
T i 
C2 = Ci XCoCi 
^Ci 
J 
To 
do 
Ci 
di 
Co 
C3 = Ci X Co Ci X Co Ci 
J 
Co 
di O TTi 
Ci 
Co 
They yield the objects C2 and C3 of composable tuples and triples of arrows in 
C. The composition morphism of C is then a morphism m: C2 —)• Ci satisfying 
Ci 
Co 
TTO 
C2 
Ci 
TTl 
Cl 
5l 
Si 
Co 
to get the domain and codomain of the composites right. Further, there are 
the familiar categorical equations, 
i X id 
id X i 
Co X Co Cl 
^ C2 -< 
Cl X Co Co 
Cl 
id X m 
C*3 
>• C2 
m X id 
m 
Co 
m 
Cl 
An internal category C is thus a 6-tuple (Co, Ci, 5o, 3i, i, m) as described. 
Usually we refer to C by writing the graph C = (Ci —^ Co) of domain 
and codomain maps only. We often call the category B in which C lives the 
ambient category of C. 
In the internal language of the ambient category M—i.e. in the internal lan-
Sub(]B) 
guage of the subobject 
fibration 
i 
on B—one can express commutativity 

410 
Chapter 7: Internal category theory 
of these diagrams via the familiar equations describing ordinary categories. 
Therefore we make use of the fact that subobject fibrations always have very 
strong equality and full subset types. For instance, 
C2 = {{f,9y-CixC,\di(f) 
= do(g)} 
Cs = 
{{{f,9),h):C2xCi\dii9)=dom. 
Commutativity of one of the above diagrams may then be expresses equation-
ally as 
{f,9y-C2 19 \- do{m{f,g)) =c, 
do(f). 
Or, equivalently, using that we have full subset types, as 
f:Cu9:Ci 
\ d^(f) =c„ do{9) H doim(f,g)) 
=c„ 
doif). 
Similarly we have an equation, 
x:Co,f:Ci 
I X =c„ doif) ^ rn(i(x),f) 
=c. /• 
Thus, in the internal language of the ambient category we can reason with 
internal categories as if they were ordinary categories. Indeed, an internal 
category C in IB is an ordinary category within the world of B, just like an 
internal group in B is an ordinary group seen from the perspective of B. 
Notice, by the way, that in order to formulate what an internal category 
is, we only need the pullbacks C2 and C3 of composable tuples and triples. 
Hence the requirement that the base category has all pullbacks is really too 
strong. But in order to use the internal language of B we need more pullbacks 
to express substitution. 
Notice also that (variables for) internal categories are written in boldface: C, 
instead of C for ordinary categories. Sometimes one calls an internal category 
a small category (in some base category). This terminology comes from the 
first of the following examples. 
7.1.2. Examples, (i) An ordinary category C is by definition small if its 
collections of objects and of morphism are sets (as opposed to proper classes). 
Thus, C is small if and only if C is an internal category in Sets, with 
Co = ObjC 
and 
Ci = ]J 
C{X,Y) 
X,Ye€ 
and with obvious domain and codomain maps Ci —^ Co from the disjoint 
union Ci of all homsets to Co. 
(ii) Every object / in a category B forms a (discrete) internal category / 
with / both as object of objects and as object of morphisms. The domain and 
codomain maps / =1 / are identities, and so are the maps for identities and 
composition. 

Section 7.1: Definition and examples of internal categories 
411 
In general, an internal category C is called d i s c r e t e if its morphism of 
identities i: Co -> Ci is an isomorphism. 
(iii) Here are some finite internal categories. A terminal object 1 yields a 
discrete internal category I with one object and one arrow. It is terminal 
among internal categories (in a fixed base category), as will become clear in 
the next section, once internal functors have been introduced. 
An internal category 2 with two objects and only two (identity) arrows is 
the discrete category 2 = 1 -f 1. 
An internal category (• -^ ) can be constructed with 1 + 1 as object of 
objects and 1 + 1 + 1 as object of morphisms. Domain and codomain maps 
(1 + 1 + 1) =4 (1 + 1) are obtained by making appropriate case distinctions. 
Similarly one gets an internal category (• n^ •) with 1 + 1 as object of objects 
and 1 + 1 + 1 + 1 as object as morphisms. 
(To make these examples work, we have to assume that the coproducts + 
are disjoint and universal.) 
These are first, in a sense degenerate, examples of internal categories. Next 
we describe how PERs form an internal category in u;-Sets and also in EfF. 
7.1.3. E x a m p l e (Internal categories of PERs). Recall the full subcategory 
P E R <^ u;-Sets of partial equivalence relations from Section 1.2. This cate-
gory P E R is small, so it is internal in Sets. 
More interestingly, PERs also form an internal category in u;-Sets with as 
object of objects 
P E R o = V P E R 
where V is the inclusion functor Sets —)• a;-Sets described in Section 1.2. Thus 
PERo is the set PER of PERs with trivial existence predicate E{R) = N. As 
object of morphisms P E R i one uses a disjoint union as underlying set in 
PERi = I Y[ ^/(R^S), E\ 
\R,SePER 
J 
where the sets N/(i? => S) are quotients by the exponent PERs R ^ 
S = 
{{n,n') 
I ym,m'mRm' 
=^ n • mSn' 
• m'}, and where E is the existence 
predicate on the disjoint union given by 
E(R, 5, [n]R^s) = {men\m{R=> 
S)n} = [nU^s-
There are then obvious projection morphisms P E R i =1 PERo forming do-
main and codomain maps. And the identity morphism PERo -^ P E R i maps 
a per R to (R, R, [An.n]). 
The description of the internal composition map 
is left to the reader. Some more details may be found in [143, 8] or [199, 
Section 8]. 

412 
Chapter 
7: Internal 
category 
theory 
The inclusion functor a;-Sets <^ EfF is right adjoint, and thus preserves 
finite limits. This means that the diagram (PERi —^ P E R Q ) is also an 
internal category in EfF. 
We close this section with two general constructions that yield internal 
categories, starting from a single map. 
7.1.4. Examples. Let a: A -^ B he a.n arbitrary, but fixed morphism in 
a category B with finite limits. We describe how to construct two internal 
categories in B from a. In the first one, the object of objects will be the 
domain A and in the second case it will be the codomain B^. 
(i) Form the kernel pair of a: A -^ B by pullback of a against itself. This 
yields two morphisms do, di in 
AXB A 
do 
A 
di 
-* A 
and also 
AXB 
AXB 
A 
J 
Tl 
-^ AXB 
A 
do 
-* B 
AXB A 
di 
There is then a (unique) diagonal V.A-^AXBA 
with 5o o i = id = 5i o i. 
Also, there is a unique mediating m:AxBAxBA-^AxBA 
with do o m = 
do o TTo and 5i o m = 5i o TTI. In one single graph: 
AXB 
A XB A 
AXB 
A 
B 
It is not hard to verify that one gets an internal category this way. Informally, 
the objects are elements x £ A and a morphism x —^ y exists if and only if 
a(x) = a{y). The identity i maps x E A to the pair {x, x) and the composition 
of (x, y, z) is simply {x,z). 
What one gets is an internal groupoid, which plays an important role in 
descent theory, see e.g. [168] for a recent reference with pointers to the litera-
ture. If one continues forming pullbacks AXB - - -XBA one obtains a simplicial 
object in B, see [169, Remark 2.13]. 
(ii) For the second construction we need an exponent in a slice category of 
B, and so we now assume that B is locally Cartesian closed. This construction 
may be found in [169, Example 2.38] or [268, 3.2]. The resulting internal 
category is called the full internal category 
associated with a:A —^ B 
and is written as FullB(a), or just Full(a) if the base category B is clear 
from the context. The reason for this terminology may become clear from 
^ An early source for these constructions is Lawvere's "Perugia Lecture Notes" 
(1972/1973). 

Section 7.1: Definition and examples of internal categories 
413 
Example 7.3.4 (ii). Later this construction will be described for an arbitrary 
"locally small" fibration, see Theorem 9.5.5. 
We start the construction of the internal category Full(a) by forming the 
families 7r*(a), 7r'*(a) in the slice category M/{B x B) by pullback, and writing 
((9o,5i) for the exponent 7r*(a) => 7r'*(a) in M/{B x B), say with domain 
Bi. This yields a pair of parallel maps [Bi 
) B) with B as object of 
objects. Informally, the morphisms between objects x,y £ B are all maps 
a~^{x) -^ ci~^(y) in B between the fibres oi a: A —^ B over x and y. 
In order to describe internal identity and composition maps we need the 
following correspondence (*), between maps in appropriate slice categories: 
{u,v) 
^ (5o,5i) 
(*) 
u*{a) 
>- v*{a) 
It arises from 
LI(u,.)H = {u,v) 
^(go,ai) = 7r*{a) ^ 7r'*(a) 
id 
^(i/,t;)*(7r*(a)=>7r'*(a)) ^ 
u*{a)^v*(a) 
u*{a) 
^ ^*(^) 
The morphism of identities i: (id, id) -^ (9o, 9i) then arises by applying this 
correspondence (*) to the identity map id*(a) —>• id*(a). And the composition 
morphism m: {do o 7ro,5i o TTI) -^ (5o,9i), with 7ro,7ri as in Definition 7.1.1, 
is obtained as follows. By applying (*) downwards to the identity (9o,5i) —> 
(^o,5i) we get a morpism 55(a) -^ dl{a). We can apply both TTQ and TTJ and 
then compose, as in: 
{do o 7ro)*(a) 
^ {do o 7ri)*(a) ^ (5i o no)*{a) 
^ (5i o 7ri)*(a) 
This yields, by (*) upwards, the required internal composition map. 
In [87] this last construction plays a special role in a categorical character-
ization of the definition of a type theory within a logical framework (see also 
Section 10.2) as an internal category in an ambient category corresponding 
• u 
• 
to the framework. This internal category arises from a family ( ^ 
I where 
U is the universe of the type theory, elements of which name types of the 
framework. 
Exercises 
7.1.1. 
Prove formally using the rules for full subset types that one can derive (i) 

414 
Chapter 7: Internal category theory 
from (ii) ctnd vice-versa. 
(i) 
a:C2 I 0 h do{m{a)) =c„ 
doiMa)); 
(ii) f:Cug:C, 
\d,(f) 
=Co d^{9) H 5o(m(i{/,p))) =c„ 9o(/), 
where o(—) and i(—) the "out" and "in" operation associated with subset 
types, as in Section 4.6. 
7.1.2. 
Describe in diagrammatic language when an internal category is an internal 
groupoid [i.e. a category in which every morphism is an isomorphism). Show 
that each interned group G yields a groupoid internal category (G —) 1). 
7.1.3. 
Describe the internal composition morphism for the internal category P E R 
in a;-Sets in Example 7.1.3. 
7.1.4. 
Consider a preorder in a category: a relation R ^^ Ax A which is reflexive 
and transitive (see Section 1.3). Show that it forms a (preorder) interned 
category in which the pair (^o,^i) is a mono. (In fact, this mono-condition 
defines internal preorders.) 
7.1.5. 
Prove that the category Full]ft(a) in Example 7.1.4 (ii) is an internal preorder 
in IB if and only if the map a: A —^ B \s 3. mono in B. 
7.1.6. 
The following example of an internal category is in the overlap of the con-
structions in Example 7.1.4 (i) and (ii). Let B be a category with finite 
products, cind let A be an object in B. 
(i) 
Describe the interned category resulting from applying construction in 
Example 7.1.4 (i) to the imique map ^ -> 1 from A to the terminal 
object 1 G B. 
(ii) Do the same for the construction in (ii) starting from the identity 
A -^ A. Notice that one gets the same internal category. 
[This particular internal category has a universal property, see Exer-
cise 7.2.6 (ii).] 
7.1.7. 
Give a definition of an internal 2-category. 
7.1.8. 
Notice that an interned category in an ambient category B consists of several 
maps in B satisfying certain equations in the logic of the subobject fibration 
Sub(B) 
i 
on B. See if the latter equational aspect can be generalised to a 
B 
(preorder) fibration ^ , by using the internal equality of the fibration, so 
that one gets a notion of "category with respect to a fibration". What 
logiccd structure should the fibration have, so that one can express such a 
notion? 
7.2 Internal functors and natural transformations 
Just like categories can be described inside an ambient (or base) category, 
also functors and natural transformations can be described internally. The de-
scriptions are the ones familiar for ordinary categories. They can be expressed 
either in diagrammatic language, or in the internal language of the subobject 

Section 7.2: Internal functors and natural 
transformations 
415 
fibration on the base category B. In this way we get a (2-)category cat(B) 
of internal categories and internal functors (and internal natural transforma-
tions), in a fixed base category B. It allows us in particular to say what an 
internal adjunction is. And in terms of these adjunctions we can define familiar 
structure, like products x, in internal categories. This will be the subject of 
the present section. In the subsequent section we shall see that these internal 
notions correspond to fibred notions for the "externalisation" of the internal 
category; the latter is a fibration which is (canonically) associated with the 
internal category. 
7.2.1. Definition. Assume two internal categories C = (Ci 
D = (Di 
^ Do) in an ambient category B. 
(i) An internal functor F : C -> D is given by two morphisms 
^ 0 
^ 
, 
^ 
^1 
Co) and 
Co 
-^ Do 
and 
Ci 
-* A 
(in B) mapping objects and arrows of C to objects and arrows of D, in such 
a way that domains, codomains, identities and compositions are preserved. 
That is, such that the following four diagrams commute. 
Fi X Fi 
Ci xco Ci 
^ Di XDO Di 
Ci 
Fi 
^ D , 
It is easy to see that one obtains a category in this way, with composition in 
the obvious way. We shall write cat(B) for the resulting category of internal 
categories in B and internal functors between them. 
(ii) An internal natural transformation a between two internal func-
tors F, G: C =t D consists of a single map a: Co -> Di yielding for each object 

416 
Chapter 7: Internal category theory 
in C a morphism in D such that the following diagrams commute. 
Fo 
Do * 
do 
Co 
Di 
Go 
di 
^ Do 
Di XDO 
DI 
Ci 
Di 
Di XDO 
DI 
In the internal language of (the subobject fibration on the) base or ambient 
category M we can express commutativity of, for example, the last diagram in 
(ii), as 
f:Ct\</>\-m{aido{f),G,{f)) 
=c. 
m(F^(f),a(d,{f)). 
Or, in more readable form, as 
f:Cux:Co,y:Co 
\ x =Co do{f),y=Co 
di{f) 
h G i ( / ) o a, =c, ay o F i ( / ) . 
7.2.2. Proposition. Assume B is a category with finite limits. Then the cat-
egory cat(IB) of internal 
categories 
in B also has finite limits. 
And if M is 
additionally 
Cartesian 
closed, then so is cat(B). 
Proof. One can either prove this purely categorically, or by making use of 
the internal language of B. We shall sketch the first approach for finite limits 
of internal categories, and the second one for exponents. 
The discrete internal category 1 on the terminal object 1 G B is terminal in 
cat(B). And the Cartesian product of 
/ 
5n 
\ 
/ 
On 
\ 
c = 
do 
Ci 
Co 
and 
D 
Jo 
DI 
'^^DO 
IS 
/ 
C x D = 
Ci 
xDi 
5o X 5o 
\ 
" 
^ Co X Do 
\ 
di X di 
I 
with similar componentwise maps for composition and identities. 
The equaliser Eq(F, G) of two internal functors F, G: C =4 D is obtained 
from equalisers in B, 
Eq(F,G)o 
Fo 
F\ 
> 
^ Co 
Do 
and 
Eq(F, G)i > 
^ Ci 
Di 
Go 
Gi 

Section 7.2: Internal functors and natural transformations 
417 
Using the universal properties of these equalisers we get domain and codomain 
maps (Eq(F,G)i z=4 Eq(F,G)o), 
and also maps for identities and composi-
tion. 
In case the base category B is Cartesian closed, then we may use V in 
the logic of subobjects in B, by Corollary 1.9.9. For the internal functor 
category D*^ = ((D^)i = 4 (D^)o) we define 
(D^)o = {(Fo, Fi): Df° x Df' \ "FQ, F I form an internal functor C -^ D"}, 
where the latter predicate may be written out as 
"Fo, Fi form an internal functor C -> D" 
^ 
V/:Ci.5o(Fi(/)) =c„ Fo(do{f))Adx(F^if)) 
=c„ 
Fo(di(f)) 
A\fx:Co.Fiii(x))=c,i(Foix)) 
AW,9y-C2.F^{m{f,9)) 
=c. m{F^{f), 
Fi(g)). 
Similarly we take 
(D^)i = {(F,G,a): (D^)o x (D^)o x Df° | "a is an internal 
natural transformation from F to G"}. 
• 
For cat(B) to be a 2-category, we need to know about the interaction be-
tween internal functors and internal natural transformations. Consider there-
fore the diagram of internal functors 
with an internal natural transformation a as indicated. One gets two new 
internal natural transformations: 
TJ 
Co — ^ Co -^-^ 
Di 
yields 
And similarly: 
IT 
Co -
^ 
Di 
^ D[ 
yields 

418 
Chapter 7: Internal category theory 
All this permits us to say what an internal adjunction is: it is given by 
two internal functors 
F 
c ""^^"D 
G 
together with two internal natural transformations 
and 
satisfying the familiar triangular identities: 
Ge o r]G = id 
and 
eF o Frj = id. 
Of course, this is just and adjunction {F H G) in the 2-category cat(B). 
By combining these internal adjunctions with the finite products that we 
have for internal categories, we can describe structure like products or equalis-
ers inside internal categories. Let C be an internal category in a base category 
B. One says that C has an internal terminal object if the unique internal 
functor !: C -^ i from C to the terminal internal category 1 in B, has an in-
ternal right adjoint, say t : i - > C. The internal counit natural transformation 
(! o t) ^ id]^ is then the identity. The unit rj: idc => (t o !) consists of a map 
7/: Co —> Ci with (among other things), 
do o T] = id 
di o rj = t o I 
CQ 
>- Co 
and 
Co 
^ Co 
This T] thus maps an internal object X in C to an arrow X —>• t in C. It is 
of course the unique internal map from X to t. This uniqueness follows from 
naturality and the triangular identities. But it may also be expressed in more 
elementary terms, see Exercise 7.2.4 below. 
In a similar way, the usual external definition of Cartesian products x can 
be internalised readily. One says that C has internal Cartesian products 
if the internal diagonal functor A: C -^ C x C has an internal right adjoint. 
Equalisers are a bit more involved. We first have to construct the inter-
nal category C ^ of parallel arrows in C, together with an internal diagonal 
functor A: C —^ C ^ sending 
id 
x^ 
I X — r x 
id 

Section 1.2: Internal functors and natural transformations 
419 
We then say that C has internal equalisers if this diagonal A: C —> C ^ 
has an internal right adjoint. One can form C ^ as the category of internal 
functors from (• nl •) to C—where (• =4 •) is as in Example 7.1.2 (iii). But one 
can also build C ^ using the internal language of B. For example, the object 
of objects C ^ is obtained as equaliser, 
do X di 
Cf 
> 
^ Ci X Ci _ ^ 
_ ^ Co X Co 
{do o 7r',5i o TT) 
i.e. as interpretation 
C ? = {if,gy.Ci 
X Ci\do(f) 
=Co do(g)Ad^(f) 
=c„ 
di(g)}. 
For internal exponents we use the approach of Exercise 1.8.9. Therefore 
assume C has internal Cartesian products x. Write |Co| = Cg, for the discrete 
internal category with objects as in C. There is an obvious internal inclusion 
functor D: |Co| —> C. Thus we can define an extended internal product functor 
prod = (^, X o (D X id)) 
|Co| X C 
^ |Co| X C 
and say that C has internal exponents if this functor has an internal right 
adjoint exp. This exp then yields a functor C ° P X C ^ C as usual. Here, the 
internal category C^P is obtained from C by interchanging the domain and 
codomain maps, and by adapting the map for composition accordingly. An 
internal Cartesian closed category is then, as one expects, an internal cate-
gory with internal terminal object, internal Cartesian products, and internal 
exponents. 
Finally, one can say that C has internal simple products (or coprod-
ucts) if for each object / E B, the diagonal functor C —>• C - has an internal 
right (or left) adjoint—where C - is the internal functor category from the 
discrete internal category / to C. 
In the next section we shall see how this internal structure may also be 
described "externally" via the "externalisation" of an internal category. 
Earlier in this—and in the previous—section we used the internal language 
of the ambient category to describe internal categories, functors and natural 
transformations. We should warn that this does not extend smoothly to in-
ternal structure: for an internal category C in B, having an internal terminal 
as above is not the same as validity of the statement: 
3t:Co.yx:Co.3\f:Ci.do{f) 
=Co X Adiif) 
=Cot 

420 
Chapter 7: Internal category theory 
(in the internal language of the subobject fibration on IB) since internal ex-
istence is not the same as external existence, see the last few paragraphs of 
Section 4.3. Similarly, internal Cartesian products via explicit internal func-
tors as above is stronger than the validity of the statement describing the 
existence of a pair x^xxy-^yof 
projection maps, for all x,y:Co. 
Unless 
of course, the Axiom of Choice holds in the ambient category IB. But recall 
that also for ordinary categories there is a difference between, say, Cartesian 
products as given functorially by an adjunction, and Cartesian products as 
given by the existence of universal diagrams X <r- X xY 
-^Y 
for each pair of 
objects X,Y, 
To get from these diagrams to an adjunction one has to choose 
projection maps for each such pair X,Y. 
There one uses the Axiom of Choice 
in the met a-language, which is relatively harmless. In internal category theory 
however, this meta-language is the internal language of the ambient category, 
in which the Axiom of Choice may fail. 
Exercises 
7.2.1. 
Write out in the internal language the predicate "a is an internal natural 
transformation from F to G" in the proof of Proposition 7.2.2. Give a 
purely categorical description of the object (D )o—e.g. as intersection of 
four equalisers. 
7.2.2. 
Verify that aH and Ka (as described after the proof of Proposition 7.2.2) 
are internal natural transformations. 
7.2.3. 
Verify that the internal category P E R = (PERi = 4 PERo) in u;-Sets 
(and also in Eff) has Cartesian products x, via an appropriate internal 
adjunction. 
7.2.4. 
Show that an internal category C has an internal terminal object (as defined 
above) if and only if there are maps 
Co 
and 
Co 
- ^ C i 
with 
Co 
- ^ C , 
do 
Co 
2ind 
7.2.5. 
Let PreOrd(B) ^^ cat(]B) be the full subcategory of internal preorders in 
IB, i.e. of internal categories (Ci 
^ Co) for which the tuple {do,di):Ci 
-¥ 
Co X Co is a mono. Prove that this inclusion functor PreOrd(B) M- cat(B) 
hcis a left adjoint, in case IB is a regular category. 

Section 7.3: 
Externalisation 
421 
7.2.6. 
Consider the "underlying object" functor f/:cat(B) -^ B given by (Ci =z| 
Co) H-> Co. 
(i) 
Show that the assignment / H^ (the discrete internal category / on /) 
extends to a functor B —>• cat(B), which is left adjoint to U. 
(ii) Prove that U also has a right adjoint, which maps / G B to the "indis-
crete" internal category (/ x / 
^ /) with Cartesian projections as 
domain and codomain maps (see Exercise 7.1.6). 
(iii) And prove that if B has (reflexive) coequalisers, then the discrete cat-
egory functor / M- / has a left adjoint Ho, which maps C G cat(B) to 
the codomain of the coequahser 
Ci 
do 
di 
Co 
no(c) 
7.3 
Externalisation 
Just like indexed categories in Section 1.10 correspond to certain fibrations 
(namely to cloven ones), internal categories also correspond to certain fibra-
tions, namely to so-called small 
fibrations. 
This correspondence really is a 
tautology by the way we define small fibrations below, as coming from an in-
ternal category. But there is an alternative characterisation of small 
fibrations 
in terms of so-called "local smallness" and generic objects, see Corollary 9.5.6 
later on. 
We shall start by describing how an internal category gives rise to a (split) 
fibration. 
The construction is known as 
externalisation. 
7.3.1. Definition (Externalisation). Let C = [Ci —^ Co) be an internal 
category in B. For each object / G B form a category C^ with 
objects 
morphisms 
maps X:I 
-> Co in B. We think of these as /-indexed 
collections {Xi)i^j 
of objects of Xf G C. 
Y 
{I^Co) 
(/ -^ Co) are maps f: I ^ Ci with 
Co 
an 
Ci 
di 
Co 
This morphism f:X 
-^ Y can be seen as an /-indexed 
family / — {fi'.Xi 
-> Yi)i^j 
of maps in C. 

422 
Chapter 7: Internal category theory 
The identity in C^ on X: I -^ Co is the composite map 
I 
^ Co 
^ Ci 
where i is the map of internal identities in C. And composition of morphisms 
(1,9) 
X ^Y AzinC^ 
is 
-^ Ci xc„ Ci 
m 
Ci 
In a next step we notice that the assignment 
extends to a split indexed category W^ -> Cat. A morphism u: I -^ J in M 
yields a functor u'^ = — o u: C*^ —^ C^ by composition. Hence we get a split 
fibration on B; it is written as 
FamiB(C) 
IPC 
B 
or as 
Famig(C) 
i 
1 
or simply as 
Fam(C) 
; 
1 
The total category Fami(C) thus has maps (/ —)• Co) in B as objects. And 
V 
V 
. 
. 
. 
a morphism (/ —^ Co) —> (J —>• Co) in Fam]B(C) is a pair of maps u: I —^ J 
and /: / -^ Ci in B with 
Fam(C) 
We explicitly describe the splitting of 
4- 
. For a map w: / -> J in B and 
an object y: J —> Co in Fam(C) over J, one gets an object Y o u: I —^ Co 
over /, together with a splitting map in Fam(C) 
/You 
\ 
(l 
Co) 
(w,i oY o u) u^ 
Co) 
The following holds by construction, and is worth mentioning explicitly. 
Fam(C) 
7.3.2. Lemma. The externalisation 
i 
of an internal category C = 
(Ci —^ Co) in B is a split fibration with a split generic object (Co -^ Co) G 
Fam(C) above Co G B. 
D 

Section 1.3: Externalisation 
423 
As mentioned, an ordinary category is small if and only if it is an internal 
category in the standard universe of sets. This terminology is extended to 
fibred categories: smallness can now be defined with respect to an arbitrary 
base category. 
7.3.3. Definition. A fibration is called small if it is equivalent to the exter-
nalisation of an internal category in its base category. 
7.3.4. Examples, (i) A small category C is, as we have seen, an internal cat-
Fam(C) 
egory in Sets. Its externalisation is the familiar family fibration 
I 
. Thus 
using the Fam notation above is justified. But note that we write Fami(C) 
or Fam(C) with boldface C, in case C is an internal category in B. 
(ii) Consider the externalisation of a full internal category Full(a) asso-
ciated with a morphism a: A ^ B in a. category B, as described in Exam-
ple 7.1.4 (ii). We claim that morphisms 
(/ 
^ B) 
>• {j 
^ B) 
in the total category Fam(Full(a)) can be identified with morphisms 
X*{a) 
^ Y*{a) 
in IB~^. Indeed, using the correspondence (*) in Example 7.1.4 (ii) we get: 
X 
^ Y 
in Fam(Full(a)) over u 
{X,Y o u) 
^ (5o,(9i) 
in M/B x B 
= 
(*) 
X*(a) 
^t/*y*(a) 
in 
X*(a) 
^ Y*{a) 
in B"^ over u 
In this way we obtain a full and faithful fibred functor Famf Full(a)) —> B"*". 
In particular, the fibre over / G B of the externalisation Fam(Full(a)) may be 
identified with the category with 
objects 
maps {X: I —^ B). 
morphisms 
f:X -^Y 
are morphisms in B//: 
/ 
• 
>
• 
' 
X*(a)\ 
/Y*{a) 

424 
Chapter 7: Internal category theory 
With composition and identities as in M/I. This greatly simplifies matters. 
The situation in this last example deserves an explicit name. 
7.3.5. Definition. An internal category C in B for which there is a full and 
faithful fibred functor Fam(C) —)• IB"^ (over B) will be called a full internal 
(sub)category in B. 
In a locally Cartesian closed base category, these full internal categories are 
the ones of the form Full(a) for some morphism a. This is the content of the 
next result. 
7.3.6. Proposition. Let C = (Ci —^ Co) be a full internal category in a 
locally Cartesian closed category M, say via a full and faithful fibred functor 
V: Fam(C) —> B~^ . Then C is isomorphic to an internal category of the form 
Full(a), namely for a = V{Co 4 Co) G B/Co-
Proof. By Yoneda: for a family {X, y): / —> Co x Co we have: 
M/Co X Co((X,y), TT^a) => 7r'*(a)) 
^ B/Co X Co{{X,Y) 
X 7r*(a), 7r'*(a)) 
^ B/Co X Co(lJ(;^y)(X,y)*7r*(a), 7r'*(a)) by definition of x 
- B//((X,y)*7r*(a), (X,y)*^'*(a)) 
since U(x,y) ^ 
i^^^y 
^ M/l{x*(V{id)), 
y*(^(id))) 
^ M/l{v{X), 
V{Y)) 
-P is a fibred functor 
^ Fam(C)/(x, Y) 
V is full and faithful 
^ B/Co xCo((X,y), 
{do,di)). 
Hence (5o, 5i) =. 7r*(a) => 7r'*(a), as families over Co x Co- 
D 
PERs in cj-Sets and in Eff" form such a full internal category. In fact, the 
externalisations are familiar fibrations that we introduced earlier. 
7.3.7. Proposition, (i) The internal category PER = (PERi = 4 PERQ) 
UFam(PER) 
in LO'Sets has as externalisation the 
fibration 
i 
of PERs overuj-sets 
from Definition 1.4-8. It is a full internal category in u;-Sets via the composite 
of the full and faithful fibred functors 
UFam(PER) 
^ UFam(u;-Sets) -^-^ 
cj-Sets"^ 
Lj-Sets 

Section 7.3: Externalisation 
425 
obtained from Example 1.8.7 (ii) and Proposition 1.4-7. 
UFam(PER) 
(ii) And PER in EfF has as externalisation the 
fibration 
i 
from 
Eff 
Definition 6.3.1. It is also a full internal category in EfF via the composite 
UFam(PER) 
^ UFam(u;-Sets) 
^ FSep(EfF) ^—^ EflT 
Eff 
from Propositions 6.3.2 and 6.3.4- 
'-' 
There is more to say about externalisation; it is functorial in the following 
sense. 
7.3.8. Proposition (Externalisation, continued). Fix a base category M. The 
assignment, 
( Fam(C) \ 
C h-^ ( 
i 
) 
extends to a (2-)functor 
cat(B) — ^ Fibspiit(B) 
which is ''locally full and faithful", i.e. full and faithful both on 1-cells and 
on 2-cells. Moreover, it preserves finite products, and also exponents (where 
exponents of split fibrations are as described in Exercise 1.10.6). 
Proof. Most of this is straightforward formal manipulation. For example, 
an internal functor F — {FQ,FI):C 
-^ D yields a (split) fibred functor 
Fam(C) -^ Fam(D), call it Fam(F), by 
/ 
X 
X 
. Fo o X 
. 
. 
/ 
. 
Fi o / 
(/ 
^Co) ^ ^ ( / 
- i ^ o ) , 
(/ 
^Ci) 
^-^{l 
- A ) 
And an internal natural transformation a: F => G between internal functors 
F,G:C 
=^ D yields a vertical natural transformation Fam(F) => Fam(G) 
between the induced fibred functors, with components 
/ 
X 
\ 
/ a o X 
\ 
[I 
- C o ) 
^ ^ { l 
- i ^ i ) 
Every split fibred functor H: Fam(C) —> Fam(D) arises in this a way: such 
an H gives rise to a pair of maps 
HO = H{CO ^CO):CO 
^ Do, 
HI = H{CI 
^ 
Ci):Ci 
^ 
A 
forming an internal functor C -> D, whose externalisation is H again. And 
these HQ, HI are unique in doing so. 

426 
Chapter 7: Internal category theory 
Similarly, every vertical natural transformation a:Fam(F) => Fam(G) 
comes from a unique internal natural transformation. Notice that for each 
object X:I -^ Co in Fam(C) one can describe a^ as a map I -^ Di forming 
a morphism in Fam(D), 
. 
FQ o X 
. 
ax 
. Go o X 
. 
[I 
^ i^o) 
^ (/ 
Do) 
Hence by taking the object X to be id: Co -^ Co we get a (unique) map 
a = aid^ :Co —^ Di whose externalisation is the natural transformation a. 
Therefore we must show that ax = a o X. But this follows from naturality 
of a, if we consider the morphism 
/ 
X 
X 
( ^ ' 0 
/ 
id 
X 
(/ 
^ Co) 
^ (Co 
^ Co) 
in Fam(C). 
Finally, showing that externalisation preserves finite products and expo-
nents is a matter of writing out definitions. 
• 
This technical result has some important consequences. 
7.3.9. Corollary. An internal category C in M is internally Cartesian closed 
Fam(C) 
if and only if its externalisation 
i 
is a split Cartesian closed fibration. 
Proof. Because externalisation preserves and reflects 1- and 2-cells, and pre-
serves finite products of internal categories. We shall illustrate the details for 
Cartesian products x. 
C has internal Cartesian products 
f there is a 1-cell 
prod 
C X C 
^ C 
<:=> < in cat(IB) with 2-cells 
T] 
s 
id = = > prodA 
and 
Aprod 
> id 
[ in cat(B) satisfying the triangular identities 

Section 7.3: 
Externalisation 
427 
( there is a 1-cell 
<=> < 
Fam(C) 
i 
1 
/ Fam(CXC) 
\ 
1 
in Fibspiit(B) with 2-cells 
V 
id 
> prod A 
and 
Fam(C) 
i 
prod 
Aprod 
=>id 
I in Fibspiit(B) satisfying the triangular identities 
/ Fam(C) \ 
"^ 
[ 
^ 
I has split Cartesian products. 
Fam(C) 
i 
There is also the following result. 
7.3.10. CoroUarye An internal category C in a Cartesian 
closed category B 
Fam(C) 
has internal simple (co)products 
if and only if its externalisation 
i 
has 
split simple 
(co)products. 
Proof. One can reason as before, using Exercises 7.3.3 and 5.2.4: 
C has internal simple products 
[ for each object / G B, the internal diagonal functor 
C 
^ C ^ 
^ 
< 
^ 
\ 
has an internal right adjoint 
[ for each / G B, the fibred diagonal functor 
Fam(C) 
i 
1 
1 / / 
i 
1 
Fam(C) 
i 
1 
l^ has a split fibred right adjoint 
/ Fam(C) \ 
<:^ I 
4- 
I has split simple products. 
But one can also simply unravel the definitions. Briefly, internal right ad-
joints n^: C - -^ C give right adjoints Fam(C)jx/ -> Fam(C)j to weakening 
TT* by 
A(x) 
n^ 
Co) ^—^ [j 
^ Cl 
^ Co) 
( J x / 
^ 
And conversely, right adjoints Fam(C)jx/ -^ Fam(C)j yield maps Cf -> Ci 
for i = 0,1, by considering for J = Cf their action at evaluation Cj x I -^ 
d. 
D 
7.3.11. Example. We can now conclude that the internal category P E R in 
(j-Sets is internally Cartesian closed and has all internal simple products and 

428 
Chapter 7: Internal category theory 
coproducts over a;-sets (see Example 1.8.3 (v) and Lemma 1.9.6). But P E R 
in cj-Sets also has internal equalisers, by a similar argument, so it has all 
internal finite limits. 
Similarly, P E R is internally Cartesian closed in EfF, via the (first) change-
of-base situation in Proposition 6.3.2 (i) and the fact that separated reflection 
preserves finite products (see Exercise 6.2.3). 
Thus, internal and external structure are closely related. These matters will 
be further investigated in the next section. If there is a choice, we prefer to 
describe structure externally using fibred terminology, for two reasons. 
• Doing internal category theory diagrammatically is rather cumbersome. 
• Using the internal language makes it more convenient, but has its limi-
tations, due to the difference between internal and external existence, as 
mentioned at the end of the previous section. And it is this external exis-
tence that we want in modelling logics and type theories. 
We close this section by noting that under certain size restrictions, a split 
fibration can also be internalised in the topos of presheaves on its base cate-
gory. 
E 
7.3.12. Proposition (Internalisation). Let 
j-P be a split fibration which is 
'fibrewise small' (I.e. all its fibre categories are small), on a base category 
B which is locally small. Then there is an internal category P in the topos 
M = Sets® 
of presheaves ofM, and a change-of-base situation, 
E 
^ 
^ Fam(P) 
(where J^rB -> IB is the Yoneda embedding I ^ B( —, I)) in which both y and 
% are full and faithful functors. 
Thus we can reconstruct the fibration p with base category B from the asso-
ciated internal category P in B. 
Proof. We have to define suitable presheaves Po,Pi:W^ 
=1 Sets forming 
objects of objects and of arrows of P = (Pi iz^ Po) in B. Firstly, PQ sends 
/H^ObjE/ 

Section 7.3: Externalisation 
429 
and secondly, Pi is given by disjoint unions of maps in the fibres of p, as in 
/ ^ ]l Ej{x, Y). 
X,YeET 
In order to get a commuting diagram, the functor 7i has to send an object 
X G E, say above / G B, to a natural transformation 
y(i)=M(-,i) 
=^Po 
Its component at K is defined as 
w 
(K-^I) 
^^W*(X) 
For a morphism / : X -^ y in E, say above u: I ^ J in M, a suitable natural 
transformation 
is required. Here one first determines the vertical part f^:X -> u*{Y) of / 
(with u{Y) o / ' = / ) . Then one can take for ? / / at K 
{K-^^I) 
I 
^{w*{X),w*u^{Y),w*{f)) 
• 
Exercises 
Sub(Sets) 
7.3.1. 
Show that the subobject fibration 
4- 
is the externahsation of (• —)• •) 
Sets 
^ 
^ 
in Sets, i.e. of the poset category {0,1} (with 0 < 1). More generally, show 
Sub(B) 
that for a topos B the subobject fibration 
4- 
is the externalisation of 
IB 
the internal poset (Q, <) as in Exercises 5.3.4. 
7.3.2. 
Elaborate out the details of the construction Full]ft(a) in Example 7.1.4 (ii) 
in case B = Sets, and describe the resulting full and faithful fibred functor 
from the externalisation of this (small) category to Sets"*". 
Fam(/) 
7.3.3. 
Show that for an object / G B the externalisation 
i 
of the discrete 
1 / / 
internal category / G cat(B) on / is the domain fibration 
i . Conclude 
that C G cat(B) has internal exponents if and only if its externalisation 
has split fibred exponents (like in the proof of Corollary 7.3.9, using the exp 
functor mentioned towards the end of the previous section). 
7.3.4. 
Consider a full internal category Full (a) built on top of a morphism a: A ^ 
S in a locally Cartesian closed category B, as in Example 7.1.4 (ii). Show 
that it has internal Cartesian products and exponents which are preserved 
by the associated functor Fam(Full(a) j —> B~*" if and only if there are maps 

430 
Chapter 7: Internal category theory 
prod,exp:5 x B : 
B for which one has puUback diagrams: 
^ 
A 
• — 
7r*(a) X 7r'*(a) 
Bx 
B 
J 
prod 
-^ B 
7r*(a)=^7r'*(a) 
Bx 
B 
J 
exp 
^ 
A 
-^ B 
where x and =^ are Cartesian product and exponent in the slice over 
BxB. 
[These elementary formulations occur in [268]. There one can also find a 
similar formulation for simple products (using a single puUback square as 
above).] 
7.3.5. 
Definition 7.3.5 says that C = (Ci —\ Co) is full internal category in B if 
there is a fibred full and faithful functor Fam(C) —>• B"*". A good candidate 
for such a functor is the (internal) global sections functor F. Assume C has 
an internal terminal object t:l —^ Co. Define for X: I —^ Co in Fam(C) a 
family T{X) over / as puUback: 
,.j— 
' 
r 
^ C{t 
^ c 
• 1 1 — 
r 
^0 
^ C i 
>- Co X Co 
X 
(to!, id) 
(i) 
Describe F: Fam(C) —)• Sets"*" for C a small category with terminal 
object t £ C 
(ii) Show that X ^ F(X) yields a fibred functor Fam(C) -^ B"'. 
(iii) Check that the functors UFam(PER) -^ o^-Sets"" and UFam(PER) 
—>• EfT^ in Proposition 7.3.7 are such global sections functors. 
[This definition of F occurs explicitly in [143, 0.1]. Its "external" version 
as in (i) will be investigated later in Section 10.4, see especially Exam-
ple 10.4.8 (iii) and Exercise 10.4.4.] 
7.4 Interna,! diagrams and completeness 
The aim in this section is to give a fibred version of a familiar result: if a 
category A has equalisers and arbitrary products then each diagram (functor) 
C ^ A from a small category C, has a limit in A. Here we replace A by a fibred 
category and the small category C by a internal category in the basis. Then 
the result also holds in a fibred setting. This is part of the folklore of fibred 
category theory, see also [36, II, 8.5]. The only ingredient of this result which 
still has to be explained is the notion of a functor from an internal category 
to a fibred category. These are called "internal diagrams", and will occupy us 

Section 7.4- Internal diagrams and completeness 
431 
first. (They also play an important role in descent theory, see e,g. [88] for a 
survey.) 
There are several alternative formulations available for these internal dia-
grams, see Remark 7.4.2 below. The most satisfying formulation from a fibred 
perspective is mentioned there as (i). But we choose to start with a different 
formulation, because this one is more common in the literature, and because 
it will be used in computing limits (in the proof of Lemma 7.4.8). 
7.4.1. Definition. Let -^P be a fibration and C an internal category in IB. 
An internal diagram of type C in p is a pair {U,fi) where U G Eco is 
an object of the total category above the object Co of objects of C, and n is 
a vertical morphism OQIU) —> dl(U) in E, called the action of the internal 
diagram, satisfying: 
m*d*o(U)^irod'o{U) 
m*{n) 
<dl{U) 
m'dliU) 
— - T^ldKU) 
This definition may be found, for instance, in [189, Section 5]. It is in fact 
most familiar for the case where the above fibration p is a codomain fibration. 
An internal diagram can then be described as a family I ^ 
1 together with 
an action morphism // in a commuting diagram 
U xco Cx 
- * [ / 
f 
di 
-^Co 

432 
Chapter 7: Internal category theory 
satisfying the equations 
(id,i 0(f) 
id X Li 
U z 
^ ^ x^o Ci 
C2 xco U = Ci xco Ci xco U 
^ Ci xco U 
m X id 
U 
CiXoU 
^U 
see e.g. [169, Definition 2.14], [36,1, Definition 8.21] (where these internal dia-
grams in codomain fibrations are called internal base-valued functors) or [188, 
V,7] (where they are called category actions). In the even more familiar case 
Sets"^ 
of sets, an internal diagram in the codomain 
fibration 
i 
can be iden-
' 
° 
Sets 
/ ^ 
\ 
tified with a presheaf C -^ Sets. Indeed the family 
J^^ ] yields a functor 
\Co J 
C ^ S e t s b y Xh->C/x = V^"M^) and {f:X -^Y)^XueUx-^{u,f). 
And 
conversely, such a functor D:C —^ Sets gives an internal diagram with family 
Uxeco ^ ( ^ ) ^ ^0 ^^^ ^^^^^^ (^'«' /) ^ (^' ^(/)(«))' foJ* f--X -^Y 
in C. 
7.4.2. Remark. There are alternative descriptions of internal diagrams. We 
briefly mention three of these below, without going into all the details. 
E 
(i) First of all, an internal diagramof type C in -^P is nothing but a fibred 
IB 
functor Fam(C) -^ E from the externalisation of C to p. Indeed, given an 
internal diagram {U^fi) as defined above, one obtains a functor Fam(C) —>• E 
by 
And conversely, given a fibred functor F: Fam(C) -^ E one takes as carrier 
object U = F(idco) in Eco • Further, the identity on Ci is a morphism ^o —^ di 
in Fam(C). And F{di) = i^(idc„ o di) ^ d*(F(idc,)) 
= d*(U) since F is a 
fibred functor. Therefore we get an action morphism // as composite 
F(idcJ 
duu) s Fido) — 
> F{d,) ^ di(u). 
It is not hard to verify that these passages from internal diagrams to fibred 
functors and vice-versa, are each others inverses. 
These fibred functors Fam(C) -^ E are sometimes easier to handle than the 
internal diagrams {U^fi). For example, with this fibred functor formulation, it 
is almost immediate that internal functors G: D —)• C take internal diagrams 
of type C to internal diagrams of type D, simply by pre-composition with the 

Section 7.4- Internal diagrams and completeness 
433 
external functor Fam(G). And by post-composition one transforms internal 
diagrams in one fibration into internal diagrams in another fibration. Also, this 
correspondence extends to appropriate morphisms, see Exercise 7.4.3 below. 
As an example, we see that an internal category of the form Full® (a) comes 
equipped with a canonical internal diagram, namely the functor Fulli(a) -^ 
M~^ described in Example 7.1.4 (ii). 
(ii) There is however a second alternative description of internal diagrams, 
which is closer to the original description in Dehntion 7.4.1. The correspon-
dence occurs for codomain fibrations in [169, Proposition 2.21] and in [188, V, 
7, Theorem 2]. It is mentioned in full generality in [30], but is independently 
due to Beck. 
E 
For a fibration 
^P with coproducts ]J^ and an internal category C in B, 
consider the functor 
It is a monad, and its algebras T{U) —^ U are precisely the internal diagrams 
di{u)-^ di[u). 
We only sketch how to get a unit and multiplication for this monad, and 
leave further details to the meticulous reader. A unit idE^ => T is obtained 
as composite 
and a multiplication T^ => T as composite, 
(BC) 
T' = Ua,doUaJo 
= 
Ua^U.^^od'o 
= Ua.onAdo o Ttor 
= 
Ua^orr^idoomy 
Ua £dX 
S 
Ua. Um m* as 
' 
: Ua, ^o* = T. 
(Where 'BC stands for Beck-Chevalley.) 
(iii) If the fibration additionally has products {u* H Ylu) ^^en the above 
monad T = JJ^ SQ has a right adjoint Yl^ 5*. By the Eilenberg-Moore The-
orem (see e.g. [188, V, 8, Theorems 1 and 2] or [36, II, Proposition 4.4.6]) 
this right adjoint is a comonad and its category of co-algebras is isomorphic 
to the category of T-algebras. Hence internal diagrams can also be described 
as CO-algebras of fl^ 5*. 

434 
Chapter 7: Internal category theory 
What we are most interested in are internal diagrams that are parametrised 
by an object / of the base category. 
7.4.3. Definition. Consider an internal category C in the base category of 
E 
a fibration -^P. Let / be an object in B. An /-parametrised internal 
diagram of type C in p is an internal diagram of type / x C in p, where / 
is the discrete internal category associated with /, see Example 7.1.2 (ii). 
More concretely, it is given by an object U G E/xCo together with a vertical 
action morphism /i: (id x 9o)*(f/) —^ (id x 5i)*([/) over I x Ci, making some 
diagrams commute (as in Definition 7.4.1). 
E 
7.4.4. Lemma. Let 
jrP be a fibration and C be an internal category in M, 
Fam(C) 
with externalization 
^Pc . For an object / G B the following are essentially 
the same. 
(i) I-parametrised internal diagrams (of type C in p); 
(ii) fibred functors F in 
^ E 
(iii) objects of the fibre over I of the 'exponent' fibration pc ^ P, described 
in Exercise 1.10.6. 
Proof. The correspondence between (i) and (ii) is obtained essentially as in 
Remark 7.4.2 (i): given an /-parametrised internal diagram (f7,//) as above 
one gets a fibred functor B// Xi Fam(C) —)• E by 
And conversely, given a fibred functor F as above, one takes 
/xCo 
U 
In order to define the action /i, we notice that for i = 0,1, there is are isomor-

Section 7.4: Internal diagrams and completeness 
435 
/xCo 
And also that we have a morphism inM/I 
XB Fam(C), 
(id/xCi,7r') 
^{idxdiYiU) 
IxCi 
/ 
Co 
IxCi 
/ 
Co 
Hence, by applying F and using the appropriate isomorphisms, we obtain a 
vertical action morphism fi: (id x doYiU) —^ (id x 5i)*(t/) over I x Ci. 
The correspondence between (ii) and (iii) is immediate from the description 
of the exponent fibration in Exercise 1.10.6. 
• 
In a next step, these parametrised internal diagrams can be organised in a 
fibred category. 
E 
7.4.5. Definition. Consider a fibration j^P with an internal category C in 
IB. We form a category Er with 
objects 
morphisms 
triples (/, U, ^) where {U, n) is an /-parametrised internal 
diagram of type C in p. 
(/, U, jj) —>• (J, V, v) are tuples {w, f) where w: I —^ J is a, 
morphism in B and f:U-^VisBi 
morphism in E above 
w X id: I X Co —>• J x Co for which there is a commuting 
diagram, 
(id X doTiU) 
^ (id X (9o)*(\^) 
(idx5i)*((7) 
(idx5i)*(7) 
in which the dashed arrows are the unique ones above 
ii; X id: / X Ci ^ J X Ci, induced hy f:U -^ V. 
Notice that in the notation E^ the role of the fibration p is left implicit. In 
the literature one sometimes finds for an internal category C in B the notation 
B^ for the fibre over 1 of the category of diagrams (B"^)^ in the codomain 
fibration on B. 

436 
Chapter 7: Internal category theory 
E 
7.4.6. Lemma. Let 
j^P and C be as in the previous 
definition. 
(i) The category E^ of internal diagrams is fibred over B via the 
projection 
(I,U,fi)^L 
(ii) There is a fibred diagonal functor 
A : E -> E^ which maps an object 
X E E, say over / G B, to the object TT*{X) G E/XCO together with the action 
(id X ao)*7r*(X) — ^ ^ 7r*(X) —=-^ (id x ai)*(X). 
Proof, (i) For a morphism w: I -^ J in IB and an object (J,V,iy) 
in E^ 
above J, take for U the reindexed object [w x id)*(l^) G E/xCo ? ^ind for /i the 
following composite over / x Ci. 
(idx5o)*(C/) 
1 
(it; X id)*(z/) 
(u; X id)*(id X 5o)*(l^) 
^ (u; x id)*(id x ai)*(VO 
( i d x 5 i ) * ( [ / ) . 
(ii) Easy. 
• 
We are finally in a position to say what limits with respect to internal 
categories are. We shall do this in two stages (as in Section 1.9, see especially 
Theorem 1.9.10) by first describing 'simple' limits, and taking ordinary limits 
to be simple limits relativised to all slices of the base category. 
7.4.7. Definition. Consider an internal category C in the base category of 
E 
a 
fibration 
iP . 
(i) We say that this fibration p has simple limits of t y p e C if the fibred 
diagonal functor A : E —> E^ has a fibred right adjoint. 
(ii) And we say that p has all small limits in case for each object / G B 
and for every internal category C in B / / , the localisation fibration /* (p) in 
M/I 
X i E 
^ E 
J 
P 
dom/ 
has simple limits of type C. 

Section 7.4-' Internal diagrams and completeness 
437 
Note that for split fibrations one can also have split (simple) limits. These 
involve split adjunctions in the above definition. Here one uses that for a split 
fibration, 
the fibration of diagrams is also split. 
The main technical work is in the following result. 
E 
7.4.8. Lemma. Assume 
j^P is a fibration with fibred equalisers and simple 
products Y[(j J) (ie. products along Cartesian projections 
TT: I x J ^ I). 
Then 
p has simple limits of type C, for every internal category C in B. 
Proof. For an /-parametrised diagram consisting of an object U G E/xCo 
with action p: (id x doY{U) 
—> (id x 5i)*(f/), we have to construct an appro-
priate limit object L = lim(/, U,p) E^i 
• Therefore consider the following two 
maps (for i — 0,1). 
^},c.nii,co)iu) 
(id xdiYie) 
I-
(id X diriTic, n(i,co)(u) —^— 
^ (id X diYiu) 
They give rise to two (vertical) maps 
^lc.nii,Co)(U) 
^ 
{id X 
d.nU), 
the first one by taking 2 = 0 and composing with the action p, and the second 
one directly for i = 1. By transposing these two, we get maps 
n(i,co)(u)^^nii.cjidxdir(u) 
and so we can construct L y-^ Y[(i c )(^) ^^ ^^^ equaliser of these (in the fibre 
over / ) . This yields an appropriate limit: for X E E/ transposition yields a 
correspondence 
X 
^ n(/,Co)(^) equalising n(/,Co)(^) =^ Uii,c,)(^<^ x ^i)*(^) 
^/,Co(^) 
^ ^ 
forming a map of diagrams A{X) 
-^ 
{U,p) 
It may be interesting to note that the construction in this proof is essentially 
the one used for ordinary categories, see [187, Diagram (1) on p. 109]. 
Finally, the main result can now be obtained without much difficulty. 
7.4.9. Theorem. A fibration with products Yl^ cine? fibred equalisers has all 
small 
limits. 

438 
Chapter 7: Internal category theory 
Proof. For a fibration p as in the theorem, each fibration /*(/>) has simple 
products, by Theorem 1.9.10. Hence we are done by the previous lemma. 
• 
We close this section by noting that for small fibrations p a converse of 
this theorem can be established. Indeed, assume a fibration p — pj^ arising 
Fam(D) 
as externalization 
4- 
of an internal category D in B, which has all small 
.® 
. 
. 
limits. In particular, it has simple limits, so each diagonal functor 
Fam(D) \ 
A 
/ Fam(D)^ 
i 
^ 
^ 
M 
J 
\ 
1 
has a (split) fibred right adjoint. Using Lemma 7.4.4 this means that each 
fibred diagonal functor 
PD 
^ (pc => Pu) 
has a (split) fibred right adjoint. But this corresponds to the statement that 
each internal diagonal functor 
A 
D 
^ D ^ 
has an internal right adjoint. This yields that D has 
an internal terminal object: take C = 0 
internal binary products: 
take C = 2 = (• •) 
internal equalisers: 
take C = (• ^ •) 
Fam(D) 
In order to show that the 
fibration 
^PD also has products Hu^ i^ suflfices 
by Theorem 1.9.10 to show that each fibration 
/Fam(r(D))\ 
'•(PD)=( 
.J, j 
has simple products. Therefore it suffices to show that for each object (or 
family) u G B// the diagonal functor 
r ( D ) 
— ^ 
(/*(D))^ 
has an internal right adjoint—where u is the discrete category associated with 
Fam(D) 
the object u in B//. But this holds because 
i 
has all small limits. Thus 
we have the following result. 

Section 7.^; Internal diagrams and completeness 
439 
Fam(D) 
7.4.10. T h e o r e m . A small fibration 
i 
has all small limits if and only 
M 
if it is a complete fibration. 
D 
There is a standard result (due to Freyd, see Fact 8.3.3 later on) saying 
that there are no (ordinary) categories which are both small and complete. 
In contrast, fibred categories which are both small and complete do exist: 
(the externalisation of) P E R in cj-Sets is an example, see Lemma 1.9.6 and 
Example 1.8.3 (v). It will provide a model for various typed calculi later on. 
For a small complete category C in a universe B there are various pleasant 
properties which are lacking for ordinary categories. For example, complete-
ness automatically yields cocompleteness, see [143, 255], which in Sets only 
holds for posets. In what is called "synthetic domain theory" one tries to ex-
ploit such properties to obtain a smooth theory of domains within universes 
other than Sets (especially toposes), see for example [144, 331, 260]. In these 
more general universes one treats domains and continuous functions simply as 
sets and ordinary functions (following ideas of D. Scott). This should make it 
easier to describe models of term (or program) languages with various kinds 
of fixed points. 
Exercises 
7.4.1. 
Describe the fibred functor Fam(C) -^ Sets"*" corresponding to a presheaf 
Sets"^ 
C -^ Sets, considered as an internal diagram in 
^ 
Sets 
7.4.2. 
Consider an internal category C in a base category B with finite limits. De-
s(l) 
scribe an internal diagram of type C in the simple fibration i 
on B, and 
IB 
compare it with an internal diagram in the codomain 
fibration 
i 
on 
B. Check that if C is an internal monoid [i.e. if Co is terminal object), then 
there is no diff'erence between diagrams of type C in the simple fibration 
and in the codomain fibration. 
E 
7.4.3. 
Consider internal diagrams {U^pt) and (V, t/) of type C in a fibration 
B 
as described in Definition 7.4.1. A morphism f:(U,p) 
—)• (V,/3) of such 
internal diagrams (as defined in [189]) is a vertical map f:U-^V 
making 
the following diagram commute. 
d'oiu) 
^ d'o(V) 
^1 ( / ; 

440 
Chapter 7: Internal category theory 
Notice that such morphisms of internal diagrams are in fact morphisms in 
the fibre over the terminal object 1 G B of the category E 
of internal 
diagrams as above. 
Show that the resulting category of internal diagrams is equivalent to the 
category of fibred functors Fam(C) -> E and vertical natural transforma-
tions between them. 
7.4.4. 
Show that a fibration p has simple limits of type C if and only if the diagonal 
functor A:p -^ (pc ^ p) has a fibred right adjoint. This diagonal maps an 
object X G E, say over / G B, to the functor A{X):M/I 
x^ Fam(C) -^ E 
given by 
/' 
vv;^' |^.*(x)GE,,. 
7.4.5. 
Check that if -^ has fibred (finite) limits, then so has a fibration -^ of 
internal diagrams. 
7.4.6. 
Let C be an internal category in B. 
/ 
Ci 
\ 
(i) 
Prove that the family I 
iiOo^Ol) 
I carries a "Hom" action for 
I 
CQXCO 
I 
a diagram of type C^^ x C in 
^j; 
IB 
(ii) Show that the resulting fibred "Yoneda" functor 
Fam(C) 
^ ( B ^ ) ^ ^ ^ 
is full and faithful. 

Chapter 8 
Polymorphic type theory 
Types in simple type theory (STT) are built up from atomic types using type 
constructors like —>, x, 1 or + , 0 , as described in Chapter 2. In polymorphic 
type theory (PTT) one may also use type variables a, /?, 7 . . . to build types. 
This is the main innovation in PTT; it gives rise to an extra level of indexing: 
not only by term variables (as in STT) but also by type variables. This forms 
the topic of the present chapter. 
We distinguish three versions of polymorphic type theory, called first order 
P T T A-)-, second order P T T A2, and higher order P T T XLO, We informally 
describe the differences: in first o r d e r p o l y m o r p h i c t y p e t h e o r y A—>• there 
is an identity function 
Xx: a. x: a —> a 
where a is a type variable. It yields by substituting a specific type a for a, 
the identity function 
Xx: cr. x: cr —>• cr 
on a. In second o r d e r p o l y m o r p h i c t y p e t h e o r y (denoted by A2) one 
may abstract type variables, as in: 
/ = Xa: Type. Xx: a. x : Ua: Type, (a -> a). 
We then get the identity on a type a by application (and /?-reduction): 
la 
— Xx: a. x:(T -^ a. 
Similarly, one can have a polymorphic conditional term, 
if: Ha: Type, (bool x a x a) —> a 
441 

442 
Chapter 8: Polymorphic type theory 
which can be instantiated to a specific type a by application ifcr. Notice 
that such polymorphic product IlaiType. cr(Qf) is impredicative: it involves 
quantification over all types, and in particular over the product type itself. 
This impredicativity makes second (and higher) order PTT very powerful, but 
it introduces various (semantical) complications. 
There is one further system, namely higher order polymorphic type 
theory Xuj in which one can form finite products and exponents of 'kinds' 
like Type (and quantify over all of these). Then one can form terms like 
Aa:Type -> Type. A/?: Type, a/? —> /?: (Type —)• Type) -> (Type -> Type). 
Such polymorphic type theories were first introduced by Girard in [95] for 
proof theoretic purposes, and independently by Reynolds in [285] with motiva-
tion stemming from computer science. In computing it is not practical to have, 
for example, a sorting algorithm for natural numbers and also one for strings 
efc, but instead, one would like to have an algorithm which is parametric, in 
the sense of Strachey: it should work uniformly for an arbitrary type with an 
arbitrary (linear) order on it. One turns such a parametric algorithm into a 
specific one (which works on natural numbers or strings) by suitably instan-
tiating it—by substitution or application, as for the identity cr —)• cr above, 
see [44, 228] for more details. This parametricity puts a certain uniformity 
restriction on the indexing by type variables a in terms (M(a):cr(a))^.j 
. 
The functional programming language ML (see [224, 223]) is loosely based 
on the first order polymorphic lambda calculus A-^ (and so is the type theory 
of the proof assistant ISABELLE [250]). But there are some subtle difi'erences, 
as will be explained in Section 8.2. There is also a higher order functional 
programming language QUEST, see [43] and the references there for more in-
formation, which is based on Xu). 
The names A-> 'lambda-arrow', A2 'lambda-two' and Au; 'lambda-omega' 
come from Barendregt [14]. However, the calculi as described there are not 
precisely as we use them: here they are described on top of a so-called 'poly-
morphic signature'. Further, we standardly consider them with finite product 
types (and kinds for Au;) and with sums E. Equality however, is an additional 
feature. In contrast, only the 'minimal' systems (with only -^ and 11) are 
considered in [14]. 
Our treatment of the syntax of polymorphic type theory will concentrate on 
the essentials, and, for example, Curch-Rosser (CR) and Strong Normalisa-
tion (SN) properties will not form part of it. Actually, CR is straightforward, 
but SN is non-trivial for (minimal versions of) second and higher order poly-
morphic type theory. CN was first proved by Girard in [94], using so-called 
candidats de reducibilite (also called saturated sets, see [300]). Girard's proof 
can be simplified by erasing types, see [325, 225]. It is presented via a (modi-

Section 8.0: Polymorphic type theory 
443 
fied) realisability interpretation in [147]. 
The fibred categories needed to model polymorphic type theories are essen-
tially as for (higher order) predicate logics, except that the fibres need not be 
preordered (as in Chapters 3, 4, 5). This extra structure is used to accommo-
date for terms inhabiting types, or, under a propositions-as-types reading, for 
proof-objects inhabiting propositions. These proof-objects give rise to non-
trivial morphisms in the fibres, by considering proofs rather than provability. 
In the language of internal categories one can say that for P T T we do not use 
internal preorders (as for predicate logics), but proper internal categories. 
The chapter starts with the syntactic aspects of polymorphic type theo-
ries: in the first section we describe how specific calculi can be defined on 
top of a polymorphic signature—giving atomic types and kinds with function 
symbols—and we establish their relation to predicate logics, via propositions-
as-types. The subsequent section is about actual use of especially the second 
order polymorphic calculus in encoding inductively and co-inductively defined 
types, and data-types with encapsulation. The semantic study starts in the 
third Section 8.3 with a naive set theoretic approach. It turns out to work 
only for first order polymorphic type theory, but it is illuminating as a start-
ing point, because it gives a clear picture of the double forms of indexing in 
PTT—via term variables and via type variables. Also, it will be used to explain 
the famous negative result of Reynolds [287, 288], stating that there are no 
set-theoretic models of (impredicative) polymorphic products Ha: Type. cr(a). 
We analyse this result along the lines of Pitts [269], and see that in higher 
order logic there cannot be an embedding Prop ^-^ cr of propositions into a 
type cr of a polymorphic calculus. This rules out set-theoretic models—except 
trivial ones, since in a set theoretic model Prop is {0,1}. But we shall see 
that for PERs R in a;-Sets and in EfF there are indeed no such inclusions 
Prop ^ 
R—iov 
Prop ^ V2 in u;-Sets and Prop = P N in EfF. In the fourth 
section we present the general definitions of fibred categories corresponding to 
the three versions A ^ , A2 and Aa; of P T T . Attention is devoted in particular to 
examples involving PERs indexed over sets, over a;-sets, and over objects of the 
effective topos EfF. But also to a PER model which is relationally parametric 
(in the sense of [286]). In the fifth section we concentrate on two constructions 
to turn fibred categories for P T T into internal categories for PTT. And in the 
last and sixth section we describe how one can have "logic over PTT" in a 
way similar to how predicate logic is a "logic over STT". We will use such a 
logic in a categorical description of relational parametricity (as in [204, 293]). 
This relational parametricity was originally introduced by Reynolds in an at-
tempt to circumvent the abovementioned problems with set theoretic models 
of second order PTT. The hope was that restriction to a certain class of "para-
metric" functions would allow the existence of set theoretic models—^just like 

444 
Chapter 8: Polymorphic type theory 
there are no set theoretic models X = X^ 
of the untyped A-calculus (for car-
dinality reasons), but restriction to continuous functions does yield examples 
of solutions X. This plan was later abandoned by Reynolds. But relational 
parametricity survived as a notion because it turned out to be important as 
a criterion for "good models", in which various syntactically definable opera-
tions satisfy the appropriate universal properties, and in which polymorphic 
maps are automatically "natural", see [340, 11, 273, 118] (or Exercises 8.4.5 
and 8.4.6 below). But see also [237] for other applications of parametricity. 
The literature on (the semantics of) polymorphic type theory is extensive. 
We mention [38, 226] for set theoretic notions of model, and [307, 268, 56, 37] 
for category theoretic (indexed and internal) notions. An easy going introduc-
tion to the indexed models is [61]. Translations between the set theoretic and 
the indexed notions may be found in [220, 155], and between the indexed and 
internal notions in [268, 8]. References about parametricity in models (besides 
the above ones) may be found in Remark 8.6.4 (v). 
8.1 Syntax 
In simple type theory (STT) we used an infinite set of term variables 
Var — {i^i,t'2,^^3, • • •}• 
In polymorphic type theory (PTT) we will additionally use an infinite set of 
type variables 
TypeVar = { a i , a 2 , a 3 , . . . } . 
Just like we sometimes used a?,y, z , . . . for term variables, we shall be using 
a, /?, 7 , . . . for type variables. 
In STT there are types o-:Type and terms M: a inhabiting such types, but 
in P T T the situation is more complicated: there are types criType and terms 
M: a inhabiting types, but also what are often called kinds A\ Kind and terms 
M : A inhabiting these kinds. This gives a picture with two simple type theories 
(with Type and with Kind), but on different levels. However, these levels are 
connected, since the types cr:Type occur as terms of the distinguished kind 
Type: Kind. This is like in higher order logic where propositions (p\ Prop are 
terms of the type Prop: Type. Indeed, there is a close correspondence between 
these polymorphic type theories and higher order predicate logics. It will be 
described as a propositions-as-types analogy below, in which inhabitants of 
types will appear as proofs of the corresponding propositions. In the type 
theories A-^ and A2 the only (atomic) kind is Type, but in Aa; one may have 
more kinds (and form finite products and exponents of these). Thus A ^ and 
A2 are 'single-kinded', whereas Aa; is 'many-kinded'. 

Section 8.1: Syntax 
445 
As in simple type theory, a specific polymorphic calculus is built on top 
of a suitable signature—called "polymorphic" signature in this context— 
describing the atomic ingredients of the calculus. Although these polymorphic 
signatures are the appropriate starting point for a completely formal presen-
tation, we postpone their definition and introduce the rules of P T T first. It 
is better, we think, first to get acquainted with the systems, since these poly-
morphic signatures are somewhat complicated (two-level) structures. 
First we are going to set up a calculus of kinds, types and terms. We shall 
write 
H = (ai:v4i,...,a„:yln) 
and 
V - [xi:ai,... 
,Xm'(Tm) 
for kind context H and type context F. A well-formed term M: r with free 
type variables a i : y l i , . . . , a„: Afi and free term variables xi'.ci^..., 
Xfji'. Cm 
takes the form 
ai\ Ai, .. ., an: An \ xi: (Ti,.. ., Xm- (^m I- M : r 
where the sign '|' works as a separator between the kind context and the type 
context—^just as in predicate logic, where it separates the type context and 
the proposition context there, see Section 3.1. In such a sequent it is assumed 
that the ai and r are well-formed types in kind context ai\ Ai^... 
,an'^ An, 
which we shall write in explicit form as 
ai\Ai,...,an:An 
f- cr,:Type. 
We sometimes write cr(a) instead of a in order to see the free type variables 
a in a type a explicit. Similarly, we also write M ( a , x) to make both the type 
and term variables a and x explicit in a term M. 
Here are two examples of terms: 
a: Type | / : a —> a, x: a h f{f{x)): 
a 
(3: Type | x: /? h If3x: /?, 
where in the latter case / is the polymorphic identity Aa: Type. Ax: a. a: : 
Ha: Type, (a —> a). 
Substitution of terms inhabiting kinds for variables of appropriate kinds 
will provide indexed categorical structure. This will be described in more 
detail later, and at this stage we only suggest how this works. Suppose for 
a kind context ^ = (ofi: Ai,..., 
ctn- -^n 
) we have terms inhabiting the kinds 
B i , . . . , 5 ^ in S, say 
H h cTi: JBI, 
• • • 
E \- am'- Bm• 
Then we can transfer types and terms in kind context (/?i: 5 i , . . . , firn • ^m) to 
types and terms in context S by substituting cri,..., cr^ for / ? i , . . . , /?^. This 
is done by 
r(^) H^ T[al^] 
and 
M(/?, x) ^ M[cr/0, 
x]. 

446 
Chapter 8: Polymorphic type theory 
We have prepared the grounds so that we can describe the rules of the three 
polymorphic type theories A—)-, A2 and ACJ. For the first two systems, A ^ and 
A2, we require Type to be the sole kind, so that there are no rules for kind 
formation except the axiom 
h Type: Kind. 
This is the type theoretic analogue of the higher order axiom h Prop: Type in 
higher order predicate logic. Categorically, the PTT axiom h Type: Kind will 
be captured by a generic object, which gives a correspondence between types 
a\A 
\- cr:Type over A: Kind and "classifying" maps a: A -^ Type between 
kinds. 
First order polymorphic type theory A—> 
In the system A-^ of first order PTT we use finite product types (1, x) and 
exponent types -^ in every kind context S = (ai:Type,..., a„:Type). The 
rules for these type constructors are 
S h cr: Type 
H h r: Type 
E! h cr: Type 
E! h r: Type 
S h i : Type 
S h cr x r: Type 
E h a -^ r: Type 
plus the rules for finite tuples and projections, and abstraction and applica-
tion terms. These are as in STT, see Section 2.3, except that the extra kind 
contexts are written. For example, the rules for abstraction and application 
are (essentially) the STT-rules: 
E\T,x:a 
h M:T 
E\T 
h M:a-^T 
E:|rf-Ar:cr 
E\T 
\- Xx:a.M:a~^r 
E\T 
h MN: r 
with conversions as in STT. Basically, A—> is Alx with type variables. 
Second order polymorphic type theory A2 
Our second system A2 of PTT has new type constructors: products 11 and 
sums S for forming (second order) product types Ha: Type, a and sum types 
Ea:Type.<7, which bind the type variable ct:Type in a. These products and 
sums thus have formation rules: 
E, a: Type h a: Type 
S, a: Type h a: Type 
E h Ha: Type, cr: Type 
E h Ea: Type, cr: Type 
Associated with these new types there are rules for introducing new terms: 
they allow us to abstract over types via polymorphic functions Aa:Type. M, 
and to form polymorphic tuples (r, M) where r is a type and M is a term 

Section 8.1: Syntax 
447 
of type a[T/a\. 
The use of these new terms is illustrated in the next section. 
Here we merely present the rules. The introduction rules for H and E are: 
H, a: Type | T h M:cr 
(a not in F) 
[a not in T, p) 
S I r h \a\ Type. M: Ha: Type, a 
H h r: Type 
S | T h M: cr[r/a] 
S I r h (r,M):Ea:Type.cr 
An the elimination rules are: 
S I r h M : n a : T y p e . cr 
H h r:Type 
S I r h 
Mr:a[T/a\ 
S h /?: Type 
E, a: Type | F, x: cr \- N: p 
H I F, z: E a : Type, cr h unpack z as (a, a?) in N: p 
In the term unpack 2: as (o:, x) in TV in the latter rule, the type and term vari-
able a and x m N become bound. They are linked, as a tuple, to z in A^. 
Possible alternatives for this "unpack" notation use "let" and "where" as in: 
let (a, x) :— z in iV, 
Awhere (a, x) :~ z 
The associated conversions are 
(Aa: Type. M ) r = M[T/a\ 
{(3) 
Aa: Type. M a = M 
[T]) 
unpack ( r , M ) as (c^,ar) in A = N[r/a,M/x] 
(/?) 
unpack M as (a,x) in iV[(a,x)/2:] = N[M/z] 
(77) 
To be more precise, with explicit contexts, types and restrictions, these con-
versions read as follows. 
E, a\ Type | F h M\ cr 
H h r: Type 
(a not in F) 
E: I F h (Aa: Type. M ) r = M[r/a\. 
a[T/a] 
E I F h M:na:Type.cr 
E I F h Aa: Type. M a = M: Ha: Type, cr 
E h r: Type 
E | F h M: (T[r/a] 
E, a: Type \T,x\a 
[- N:p 
E I F h (unpack {T,M) 
as {a,x) 
in N) - 
N[T/a,M/x]:p 
E I F h M : S a : Type, cr 
E | F, z: Ea: Type, a \- N\p 
E I F h (unpack M as {a,x) 
in 7V[(a, ar)/z]) = 
N[M/z\:p 
( a ^ F , / > ) 

448 
Chapter 8: Polymorphic type theory 
Higher order polymorphic type theory Xuj 
In our final system XLJ the requirement that Type is the only kind is dropped: in 
XUJ one can have more atomic kinds A: Kind than just Type. Additionally, there 
are rules for forming finite products and exponents of kinds. Thus one can form 
1: Kind, A x B: Kind and A-^ B: Kind, for A, B: Kind, regulated by the STT-
rules for (1, X, —>•) as in Section 2.3. The calculus XUJ has all features of A2 with 
(higher order) polymorphic products and sums Ua: A. a and Ea: A. a over all 
kinds A\ Kind (and not just over Type: Kind). Since this gives us conversions 
for inhabitants of kinds A: Kind, we have in particular conversions for types 
a: Type. This calls for a rule which tells that type-inhabitation is stable under 
conversion: 
conversion 
r l-M:cr 
r h cr = r: Type 
r h M : r 
This rule forms part of higher order polymorphic type theory XUJ. 
We summarise the type and kind constructors in the following table. 
P T T 
A-> 
A2 
Aa; 
1 
kinds 
Type 
Type 
Type, 
\,AxB,A-^B 
types 
1, 0- X r, (7 —> r 
1, (7 X r, cr —)• r, 
Ila: Type, cr, Da: Type, a 
1, (7 X r, cr ^ r, 
lia.A.a, 
T^a:A.a 
As we mentioned in the beginning, the proper starting point for a specific 
polymorphic calculus is a polymorphic signature, containing basic kinds and 
types together with function symbols for these. Such a polymorphic signature 
consists of two connected levels of ordinary signatures. It involves a combina-
tion of the higher order signatures used in higher order logic, and the ordinary 
signatures used in simple type theory. 
Here is an example of what we may wish to specify in a polymorphic sig-
nature for a first or second order calculus. Remember that there are no kinds 
other than Type (for first and second order), so there are only function symbols 
in a kind signature: 
List: Type —> Type, 
Tree: Type, Type —> Type. 

Section 8.1: Syntax 
449 
These may come with function symbols in type signatures: 
nil: 0 —> List(a), 
cons: a, List(a) —> List(a). 
involving a type variable a: Type. And for trees one may wish to have function 
symbols 
nil: 0 —> Tree(a,/?), 
node: a, Tree(a,/?), Tree(a,/?),/? —> Tree(a,/?). 
involving two type variables a, j3: Type. In general, one may have such a signa-
ture of function symbols between types for every sequence a of type variables, 
i.e. for every kind context. Here is the general notion to capture such struc-
tures. 
8.1.1. Definition, (i) A p o l y m o r p h i c s i g n a t u r e consists of 
(1) a higher order signature E; we call the elements of the underlying 
set K — |E| (atomic) k i n d s and write Type for the base point in |E|, see 
Definition 5.1.1. 
(2) a collection of signatures {Tia)aeK* where for each sequence of kinds 
a — {Ai,...,An) 
E /i"^, the underlying set |Ea| of types of the signature 
Efl is the set of E-terms a i : A i , . . . , a„: An \~ cr: Type that can be built with 
the kind signature from (1). Elements of this set |Ea| will therefore be called 
t y p e s with free type variables ai: Ai,... 
,an-An-
In such a polymorphic signature (E, (Ea)) we shall refer to E as the k i n d 
s i g n a t u r e and to E^ as the t y p e s i g n a t u r e over a G lEl"*". 
(ii) For the first and second order polymorphic calculi A ^ and A2 one 
restricts oneself to polymorphic signatures (E, (Ea)) where the kind signature 
E is single-typed—or better, single-kinded; that is, the underlying set |E| is 
{Type}. The type signatures are then of the form (E„)nGN (as in the above 
example). 
A specific polymorphic calculus may now be written as A<)(iS) where ()• is 
—>, 2 or cj, and 5 = (E, (E^)) is an appropriate polymorphic signature. 
Equality 
in polymorphic 
type 
theory 
One can also extend these polymorphic A-calculi with equality 
t y p e s 
Eq^(cr, r): Type for cr, r: yl where A: Kind. Inhabitation of such a type Eq^((j, r) 
is intended to mean that a and r are equal terms of kind A. This is like inter-
nal equality in equational logic or in predicate logic. Such equality types only 
really make sense for the higher order calculus Au;, because only Au; involves 
a non-trivial subcalculus of terms for kinds. However, equality types can also 
be added to the calculi A ^ and A2—in which case the only kind is Type. We 

450 
Chapter 8: Polymorphic type theory 
shall write A—>=, A2= and Aa;= for the calculi A—>, A2 and Xuj extended with 
the following rules for equality types. 
H h c r : ^ 
Z \- T\A 
Z V- (T\A 
E h Eq^i {(T,T): Type 
S | 0 h r^i (cr): Eq^ (cr, a) 
2, a: A,f3:A\- 
p: Type 
E,a:A\ 
T[a/f3] h N: p[a/f3] 
E, a: A, 13: A \ T, 2:: Eq^(a,/?) h N with (3 = a y\3 z: p 
with (/?)- and (77)-conversions: 
E,a:A\T[a/f3] 
hN:p[a//3] 
E,a:A\ 
T[a/(3] h (TV with a = a via r^(a)) = 
N:p[a/(3] 
E, a: A, (3: Ah p: Type 
S, a: A,(3:A\ 
T, z: Eq(a, /?) h L: p 
E,a:A,(3:A\ 
r,z:Eq(a,/?) h (L[a//?, u ( a ) / z ) ] with (3 = a \/\a z) = L: p 
In the above introduction rule there is a proof-term r = r^ (a-) for reflexivity 
of equality on A, for cr: 74. Often we omit the A and cr when they clear from the 
context. In the next lemma we show that similar proof-terms for symmetry, 
transitivity and replacement are definable. 
8.1.2. L e m m a . There are 
proof-terms 
a,f3:A\x:EqA{a,^) 
h s(x):Eq^(/?,a) 
a,/?,7:yl |x:EqA(a,/?),y:Eq^(/?,7) 
h t(x, y): Eq^(a,7) 
S I r,ar:Eq^(cr,r),y:/?[cr/a] h rep{x,y): 
p[T/a] 
yielding combinators for symmetry, 
transitivity 
and replacement for the poly-
morphic equality type Eq. Moreover, 
types indexed by equal type variables are 
equal: there is a 
proof-term 
a,(3: A \ x:Eq^(a,/?) h \{x):Eqjy^Ma/y], 
p[(3/j]). 
Proof. A proof-term for symmetry is obtained in: 
a,p:A 
hEq^(a,/?):Type 
a : A | 0 h r^(a): Eq^(/?, a)[a//?] 
a: A, (3: A \ X:EC\A{(^,P) 
^~ ^A{OC) with ^ - a via z: Eq^(/?, c^) 
And for transitivity in: 
Qf,/?,7:A h Eq^(a,7):Type 
a,f3:A\x:EqA{ci,(3) 
h :r: Eq^(a,7)[/?/7] 
a,/?,7: A I a::Eq^(a,/?),2/:Eq^(/?,7) \- x with 7 = / ? via t/:EqA(Qf,7) 

Section 8.1: Syntax 
451 
For replacement, consider the following instantiation of the elimination rule. 
E,a,(3:A 
h p[^/a]: Type 
E,a:A\x:p 
\- x: 
p[(3/a][a/p] 
E, a, (3: A \ x: p, y: Eq^(a,/?) h x with /? = a via y: p[l3/a] 
By substituting 
[a/a^r/jS] 
we obtain a term rep{x,y) 
= 
a^ with r 
= 
a via y: p[T/a] 
as required. Finally, to see that equal index variables yield 
equal indexed types, consider for E,j:A 
h p: Type the following instance of 
the equality elimination rule. 
S,a: A I 0 h rTypeW/7]):EqType(/>[c^/7],/>[/^/7])K/^] 
E,a:A,f3:A 
\ 
x:EqA{ct,p) 
I- nype{pW/l]) 
with P = a\/\a x: Eqjy^^ipla/'y], 
p[f3/-f]) 
n 
Propositions 
as types 
In the beginning of the section we spoke of a formal similarity between pred-
icate logic (as in Chapter 4) and polymorphic type theory. This takes the 
form of a propositions-as-types correspondence, like in Section 2.3 between 
propositional logic and simple type theory: 
predicate logic 
polymorphic type theory 
propositions 
as 
types 
types 
as 
kinds 
Indeed, one can view a type a in predicate logic as a kind a in polymor-
phic type theory and a proposition (^ as a type (p. Under this translation 
the propositional connectives T , A , D become the type constructors 1, x , ^ , 
and the quantifiers Vx: a. (p, 3x:a.(p become the polymorphic product and sum 
Ha: a. (p. Da: a. (p. At the level of kinds we take Prop = Type, Type = Kind, and 
the type constructors 1, x, -^ in predicate logic become the kind constructors 
1, X, ^ in polymorphic type theory. Then one can prove that 
Xi\ai,...,Xn'an 
I V ? l , . . . , V ^ m J" V^ 
is derivable in higher order predicate logic 
(*) 
if and only if 
there is a term a i : 5 i , . . .a^i^n | zi: <^i,..., Zm'-^m H M: ^ in XUJ— 
This establishes a typical propositions-as-types relation between provability 
in logic and inhabitation in type theory. 

452 
Chapter 8: Polymorphic type theory 
For example, consider the proposition 
{3x\ a.(p Alp) D [3x: a. (p) A {3x: a. ip) 
together with its translation into type theory: 
[T^x'.a.ip X -0) ^ [T,x:a.(p) 
x 
{T>x:d.ip). 
Obviously, the proposition is derivable: take an x:a with (p Atp. Then this 
same x can be used to establish (p, and also to establish ip. This proof outline 
is recognisable in the following term, inhabiting the translated proposition: 
Xz: (Ear: ?. <^ A -0). unpack z as {x, y) in ((a:. Try), (x, TT'?/)). 
A few remarks are in order about the details of the propositions-as-types 
correspondence (*). 
(1) One can prove the correspondence by annotating the rules for predicate 
logic in Figure 4.1 with appropriate proof-terms. For example, the deduction 
step in logic 
Xi\(Ti,...,Xn-<Tn^y'r\ipi,...,(prn 
^ ^ 
^ 
[y not m (p) 
Xi: (Ti, . . . ,Xn\ (Tn \ ^1, • - ' ,^m 
\-\fy:T.tp 
becomes in type theory 
f3:T \ zi:^i,...,Zm:^m 
\-Miip 
ai:ai,. 
. .an-.o-n \ zi'.pi,.. 
.,Zm''Pm 
I- XP:T.M:Uf3:T.jp 
- "iy.T.^l) 
Since we have not standardly included rules for finite coproduct types (+, 0) in 
our polymorphic calculi, we have to restrict ourselves to the fragment of higher 
order predicate logic without disjunctions. Of course, such finite coproduct 
types can be added in P T T as well, following the description in Section 2.3. 
Lemma 8.1.2 gives proof-terms for the equality rules of predicate logic in 
Figure 4.1. In P T T we do not have the extensionality of entailment rule 
(see Section 5.1). So the above propositions-as-types correspondence involves 
higher order predicate logic without extensionality of entailment. 
(2) A higher order predicate logic is built on top of a higher order signature 
plus a number of axioms. Due to the way that we have defined polymorphic 
signatures, these axioms can be translated into a polymorphic signature only 
if they involve solely predicates and no connectives. For each such an axiom 
x:a\Pi{x),...,Pm[x) 
\-Pm+i{x) 
one postulates a function symbol 
F: Pi,.. 
.,Pm —> Pm+i 
in the type signature over ( ? i , . . . , ?n)- This function symbol serves as 'atomic 
proof term' for the axiom. 

Section 8.1: Syntax 
453 
In order to accommodate for all axioms—and not just these restricted 
ones—we should adapt the notion of polymorphic signature in such a way 
that it can also have function symbols between composite kinds and types 
involving ^ , x, 1 and 11, E, ->, x , 1, Eq. 
(3) There is a border case of this propositions-as-types correspondence 
which should be mentioned separately. Propositional logic can be seen as a 
degenerated form of predicate logic in which all predicates are closed [i.e. do 
not contain free term variables and are thus merely propositions). This means 
that higher order logic without atomic predicate symbols (and without equa-
tions) is higher order propositional logic. If one further restricts oneself in logic 
to second order quantification only {i.e. of the form Va: Prop, (p) then one can 
get a correspondence between derivability in this logic and inhabitation in 
"pure" second order polymorphic calculus A2(0) on the empty signature. This 
correspondence occurs in [14]. 
Exercises 
8.1.1. 
Show that in A2 one can assign the type Ua: Type. (11/3: Type. /3) ->• cr to the 
self-application term 
Xx.xx. 
8.1.2. 
Write down how substitution, both in type variables and in term variables, 
distributes properly over the type constructors n,I],Eq. 
8.1.3. 
Prove the 'mate' versions of the rules for U and E. That is, assume a is 
not in r, p below and establish bijective correspondences between terms M 
and A^ in 
E,a:A\r 
\- M:(T 
E,a: A\r,x:a 
\- M: p 
E\r 
\- N:Ua:A.a 
E\ T,z:Ea:A.(T 
h TV: p 
This shows that Ha: A.— and Ea:.4. — are right and left adjoints to the 
weakening functor which adds an extra variable aiAtoE. 
h p: Type. 
8.1.4. 
Formulate and derive a similar mate version for equality. 
8.1.5. 
(i) 
In A2 (and in Aa;) a sum type Eci is definable in terms of 11 and -^: 
for E, a: Type h a: Type, put 
def 
EdO'-Type. cr = 11/3: Type. (Ha: Type. <T—)•/3)->/3 
Establish that there are introduction and elimination rules for E^^ as 
for E, but that only the (/3)-conversion rule holds, 
(ii) Show that likewise finite product and coproduct types are definable: 
Id 
= Ha: Type, (a-> a) 
Od = 
na:Type.a 
cr Xd T = 
na:Type. (or ^ r —>• a) —)• a 
def 
(T-^^T 
= Ila:Type.{(T-^ 
a)-^ 
{T ^ a)-^ 
a 

454 
Chapter 8: Polymorphic type theory 
[These definitions are the type theoretic versions of the ones we already 
saw in higher order logic, see Example 5.1.5. If one is interested in 
(/3)-conversions only, these translations show that it is sufficient to re-
strict oneself to versions of A2 and Au; with only -^ and 11, as is done 
for example in [14]. But the (r7)-conversion does not hold, since the 
type EdCtiType. cr contains "junk": e.g. for (T = a it contains the term 
A/9: Type. A/: Ila: Type, (a -^ fi). f{l3 -> l3){Xx:j3. x), which is not (convert-
ible to) a pair.] 
8.1.6. 
Along the same fines, describe the rules for Leibniz equafity in Aa;, see 
Example 5.1.5. (Here one needs the conversion rule of Xto. And the "non-
Frobenius" version of equality—with type contexts T instead of T[a//3] 
in the elimination rule—is obtained. But using arrow types one gets the 
Frobenius version, as above.) 
8.1.7. 
Show that the (77)-conversion unpack M as {a,x) in N[{a,x)/z] 
= N[M/z] 
for the polymorphic sum E is equivalent to the combination of the following 
two conversions, called (commutation) and [r]'). 
L[(unpack M as (a,x) in N)/z] 
= unpack M as {a,x) in L[N/z] 
unpack {a,x) as {a,x) in M = 
M. 
[Non-extensional polymorphic sums (as described by 'semi-adjunctions', 
see [155]) satisfy the commutation conversion, but not [r]'). The above 
definable sums E^ in Exercise 8.1.5 are even weaker: they do not satisfy 
(commutation).] 
8.1.8. 
Consider the proof-terms in Lemma 8.1.2. Show that there are conversions: 
a: A,P:A\ 
z: Eq^(a, f3) h t{z, rA{fi)) = z: Eq(a, f3) 
a: A,/3:A\ 
z: Eq^(a, /9) h t(r^(a), z) = z: Eq(a, /3). 
8.1.9. 
Prove the propositions-as-types correspondence relating provability in 
higher order logic and inhabitation in higher order polymorphic A-calculus 
\uj= (under the restrictions as mentioned in (1), (2) above). 
8.1.10. 
In Section 2.3 it was shown how (/9)- and (r7)-conversions correspond un-
der the propositions-as-types reading to certain identifications on deriva-
tions. 
(i) 
Write down similar identifications involving polymorphic product 11 
and sum E. 
(ii) Do the same for equality Eq. 
8.1.11. Define an appropriate notion of 'morphism of polymorphic signatures'. 
8.2 Use of polymorphic type theory 
In this section we briefly discuss three aspects of the use of polymorphic type 
theory, namely: 
• the polymorphic type system of the functional programming language ML; 

Section 8.2: Use of polymorphic type theory 
455 
• encoding of inductively and co-inductively defined types in second order 
polymorphic type theory A2; 
• encoding of abstract types and of classes (as in object-oriented program-
ming) in A2, by encapsulation via sum types S. 
ML-style 
polymorphism 
As already mentioned briefly in the introduction to this chapter, the type 
system of the functional programming language ML is loosely based on first 
order polymorphic type theory X^, 
see [223, 224, 251, 108, 228]. But there 
are certain difl'erences between the type systems. 
(1) ML is a calculus which is implicitly—and not explicitly—typed (like 
the calculi in this book). In the terminology of [14], ML has typing a la Curry, 
whereas here we consider typing a la Church. This means that ML-terms are 
essentially untyped terms, to which one can assign types 'on the outside'. 
These types however, are not part of the syntax of terms. This diff'erence will 
not be emphasised here. 
(2) In ML one distinguishes types and type schemes. 
The types are our 
A—)--types (if we forget about inductively defined types for a moment), and 
the type schemes are of the form 
lid: Type, a 
where cr is a type and a is a sequence of type variables. Hence one does have 
Il-quantifiers inside these type schemes, but only on the outside. There is an 
instantiation rule as in A2: if a term M is of type scheme Ha: Type, a, then M 
has type cr[r/a] for every type r. Notice that one can instantiate with types, 
but not with type schemes, because that would lead to quantifiers inside. This 
is called "ML-style polymorphism". 
The crucial diff'erence in the way that types and type schemes are used is 
that term variables of types may be bound by A whereas variables of type 
schemes may be bound by let only. We consider two examples. First, assume 
a polymorphic term lenillaiType. (Ilst(a) -> N) which gives the length of a 
list. Then one can derive the type 
list(/?) ^ list(7) ^ N 
for the (untyped) term 
\x.Xy.\i\en{x) 
< 100 then \en{y) else 100 
Notice that one needs to instantiate the type of len twice for this type assign-
ment: once with /? and once with 7. The above mechanism with 11's on the 
outside takes care of this. And the abstractions Xx and Xy are over types: in 

456 
Chapter 8: Polymorphic type theory 
the first case, x has type list(/?) and in the second case, y is of type list(7). 
But note that if we wish to A-abstract len in this term as in 
\f.\x.\y.\i 
{fx) < 100 then {fy) else 100, 
then we cannot use a Il-type for / . However, for this term we can derive the 
(less general) type 
(a -^ N) -> a -> a ^ N. 
Or, by abstracting a, 
riofiType. (a ^ N) -^ a ^ a -> N. 
Secondly, one makes essential use of type schemes in typing the term 
let / = Xx. X in / / . 
One can type / with the type scheme Da: Type, {a ^ 
a). The first / in the 
self-application / / can then be instantiated with [{a -^ o-)/a] and the second 
one with [cr/a]. 
This use of let is characteristic of what is sometimes called "ML-style" or 
"let" polymorphism. It is quite successful because there are algorithms which 
produce appropriate ML-types for untyped terms, see e.g. [222, 68]. A semantic 
study of ML (in realisability toposes) can be found in [265, 198]. 
Encoding 
of inductively 
and co-inductively 
defined data 
types 
The standard encoding of the natural numbers N in the untyped A-calculus 
uses the so-called Church numerals, see [13]. These encoded numerals are the 
terms c^ = Xfx. f^^^x for n E N. In A2 all these terms can be typed with type 
Nat = Ua: Type, {a —^ a) —^ a ^ 
a. 
It turns out that Nat comes with zero and successor terms 
zero = Xa:Jype. Xf:a 
^ a. Xx:a.x 
: Nat 
SUGG = Az: Nat. AarType. A/: a - > a. Ax: Q;./(2:a/a:): Nat ^ 
Nat 
which form a "weak" natural numbers object (NNO): for terms P:a 
and 
Q'.cr —^ a there is a (not necessarily unique) mediating term M: Nat —> a 
with Mzero = P and M o succ = succ o P , i.e. A2:: Nat. M(SUGG z) 
= 
A2::Nat.P(M2:). Just take M - Xz.Hai. z aQ P. This weak NNO property 
is the essence of the encoding of the natural numbers. 
Below we show how to encode more general inductive (and co-inductive) 
types in A2. Such types are given by appropriate signatures, introduced in 
Definition 2.3.7 as 'Hagino signatures': they consist of a single type (T{X) in-
volving a distinguished type variable X, built with finite product and coprod-
uct types, together with either a constructor Gonstr: cr{X) —> X or a destructor 

Section 
8.2: Use of polymorphic 
type theory 
457 
destr:X —> (T{X). 
Their models are described in terms of initial algebras (for 
constructors) and terminal co-algebras (for destructors), see Section 2.6. Here 
it will be shown that such models always exist in second order polymorphic 
type theory A2, but that they are only "weakly" initial and "weakly" termi-
nal. This means that given any other (co-)algebra there is always a mediating 
map, but it need not be unique. We shall describe the basics of this encoding, 
but we do not consider advanced topics like iteration of data types (as in 
CHARITY [53] and also [124]). 
We first have to extend polymorphic type theory with finite coproduct types 
(+, 0). Let us write A-^_(_, A2+, XUJJ^ for the calculi A-^, A2, Au; extended with 
coproducts (0,-|-) in each kind context, i.e. with formation rules 
E h (J: Type 
S h r: Type 
h 0: Type 
S h cr -j- r: Type 
and with introduction, elimination and conversion rules as in Section 2.3—but 
extended with kind contexts. In second and higher order type theory one can 
also use the encoded weak finite coproducts described in Exercise 8.1.5. 
A Hagino type (T{X) as above occurs in a polymorphic calculus as a type 
S, X: Type h cr: Type 
where the kind context H contains the type variables a in cr which are different 
from X. We assume that such a Hagino type is formed from constants and 
type variables using finite product and coproduct types. A constructor is then 
a term 
H, X\ Type \ x:a V- constr: X 
or 
S | 0 h constr: YIX: Type, [a -^ 
X). 
Dually, a destructor is a term 
S, X: Type \x:X 
V- destr: a 
or 
H | 0 h destr: YiX: Type. (X ^ cr). 
Before we can describe algebras and co-algebras in A2 we have to explain 
where the underlying functors come from. They arise by substitution in types. 
8.2.1. Lemma. For each kind context S (in A2 or Xuj), let C(S) be the cat-
egory of types and terms in context 5 ; object o/C(S) are types E h r: Type 
and^ since we have exponent 
types around, morphisms 
r ^ 
p may be de-
scribed as equivalence classes [M] of terms S | 0 h M : r ^ /?. Each 
Hagino 
type S,X:Type h a.Jype 
then induces an endofunctor 
a[—/X]: C^E) -> C{E) 
by 
(H h r : T y p e ) ^ ( H h < T [ r / X ] : T y p e ) . 
The proof proceeds by induction on the structure of the type cr. At this stage 
we are mostly interested in the cases where a is built with finite products x 

458 
Chapter 8: Polymorphic type theory 
and coproducts + only. The result can be extended easily to include -^,11, E 
as type formers, see Exercise 8.2.5 below, but some care with positive and 
negative occurrences is needed for arrow types. 
Proof. We need to describe the action of (T[—/X] on morphisms. Therefore 
we distinguish the following cases. 
• If cr ^ X, then cr[—/X] is simply the identity functor. 
• If cr ^ a occurring in E, then (T[—/X] is the functor which is constantly a. 
• Similarly 0[—/X] is constantly 0 and 1[—/X] is constantly 1. 
• Suppose cr = cTi X (72 and [M] is a morphism r -> /? in C(Ei). By in-
duction hypothesis we have morphisms (T\[M/X]: a\[T/X] -^ a\[p/X\ and 
(T2[M/X]\ a2[TIX] —> a2[p/X]. We need to define a morphism 
{CTIX(T2)[T/X] 
= ai[T/X]xa2[T/X] 
-^ 
ai[p/X]xa2[p/X] 
= 
{aixa2)[p/X] 
We take: 
Xz:ai[T/X] 
X a2[T/X]. {(TI[M/X] 
• (TTZ), a2[M/X] • (TT'Z)). 
• Similarly, for a = ai -\- a2 and [M]: r ^ p we take 
((71 4- (T2)[M/X] = Xz:a,[T/X] 
+ 
(T2[T/X]. 
unpack z as [KX in K{(TI[M/X] 
• x), K'y in K,'[a2[M/X] • y)]. 
D 
The category C(E!) that we use in this lemma will turn out to be the fibre 
category above kind context E! in the fibration associated with this polymor-
phic calculus, see Example 8.4.2 later on in this chapter. 
The basis for the next result is [196, 35]. There it is shown how certain 
many-typed signatures can be expressed in A2 in a (weakly) free way. This 
result is reformulated in [346] in terms of existence of weakly initial algebras 
of "polynomial" functors (T[—/X]. The dual version involving co-algebras ap-
pears there as well; it is independently due to Hasegawa. A more general 
approach involving "expressible" functors may be found in [288]. 
8.2.2. Theorem. Let S, X: Type h a: Type he a Hagino type. In second order 
polymorphic type theory, the induced functor o-[—/X] has both a weakly initial 
algebra and a weakly terminal co-algebra. 
Proof. A weakly initial algebra constr: a[To/X] -^ TQ is obtained as follows. 
Put 
To = UX:Jype.{a^X) 
^X 
constr = Xx:a[To/X]. \X-.Type. Xy:a—^ X. y{a[{Xz:To. 
zXy)/X]x) 
where in the second case we use the action of the functor a[—/X] on mor-
phisms, as defined in the previous lemma. This constructor is well-typed, since 

Section 
8.2: Use of polymorphic 
type theory 
459 
the term \Z:TQ. zXy is of type TQ -^ X, so that a[(Xz: TQ. zXy)/X] 
is of type 
(T[TQ/X] -^ 
cr. 
If we have an arbitrary algebra a[T/X] —)• r, given by a term M: a[T/X] —> 
r, then we obtain a mediating morphism M = XX'.TQ. XTM: TQ -> r. It is an 
algebra morphism, since 
M o constr = Xx:a[To/X]. constr x r M 
= Xx:a[To/X], M {a[{Xz:To. 
ZTM)/X]X) 
= Xx:a[To/X]. M 
{a[M/X]x) 
= 
Moa[M/X]. 
Similarly, there is a weakly terminal co-algebra destr: ri —> a[ri/X], where 
n = EX: Type. X x {X -> o"). 
Before we define the associated term destr, we introduce for an arbitrary term 
N: T -^ cr[r/X] a term N:T ^ TI by 
N = 
XX:T.{T,{X,N)). 
This will actually be the mediating map. The construction — is also used in 
the following definition of the weakly terminal co-algebra destr: ri —)• a[Ti/X]. 
destr = Ay: Ti. unpack yas{X,z) 
in 
a[7r'z/X]{{7v'z){7rz)). 
It forms a morphism of co-algebras: 
destr o AT = Xx: r. destr{N x) 
= Ax: r. unpack (r, (x,7V)) as {X,z) in a[7T^z/X]({7r'Z){7TZ)) 
= 
Xx:T.a[N/X](Nx) 
= a[N/X] o N. 
D 
We notice that the encoding of weakly initial algebras only uses the type 
constructors 11 and —)-. But also the encoding of weakly terminal co-algebras 
can be done entirely in terms of 11 and —)-, since the sum E in the definition 
Ti = EX: Type. X x (X —)• cr) can be replaced by the definable sum Ed from 
Exercise 8.1.5. This yields a diff'erent formulation for ri as: 
n = Ila: Type. (IIX: Type. (X -> cr) -> X -^ a) -> a. 
Let us apply this Theorem 8.2.2 to our earlier example of the Church nu-
merals, with type Nat = nQf:Type. [a —^ a) —^ a —^ a. Categorically one sees 
a natural numbers object as an initial algebra of the functor X H-> l-fX. Tak-
ing the corresponding type cr(X) = 1 -|- X yields, according to the definition 

460 
Chapter 8: Polymorphic type theory 
of To in the proof, 
liX: Type. ((1 + X) ^ X) -> X) 
Or equivalently, the type of the Church numerals: 
nX: Type. [X ^ X)-^ 
X -^ X 
using the isomorphisms, 
(1 + X) -> X ^ (1 -> X) X (X -> X) ^ X X (X ^ X) = (X -> X) X X 
and Currying. Hence the general approach of the theorem gives an a posteriori 
justification for the type of the Church numerals. 
We consider another, co-algebraic, example of this encoding. For a type 
stream (a) of streams (or infinite sequences of elements) of type a we seek a 
pair of destructors (head, tail): stream(a) -^ axstream(a) as (weakly) terminal 
co-algebra for the type cr(X) = a x X. The definition of TI in the above proof 
yields 
stream(a) = EX: Type. X x (X ^ a x X). 
The associated head and tail operations are given by 
head = Ay: stream(a). unpack y as (a, a:) in 7r((7r'x)(7rar)) 
tail = A2/:stream(a). unpack ?/as (a, a?) in 7r'((7r'x)(7rar)). 
For terms P:a -^ a and Q.a -^ a we then get a mediating term M:cr -> 
stream(a) by 
M = Xx:a.{x,Xy:o:{Py,Qy)). 
. 
It is easy to see that head o M = P and tail o M — M o Q. An application of 
this encoding of streams to a formulation of the sieve of Erastosthenes occurs 
in [195]. 
In [118, 273, 11] it is shown how under certain "parametricity" conditions 
the weakly initial algebras and weakly terminal co-algebras in Theorem 8.2.2 
become truly initial and terminal (see also Exercise 8.4.5). This also works 
if there are enough equalisers around, see [288]. It is desirable to have the 
additional uniqueness of true initiality / terminality because it yields reason-
ing properties for these (co-)inductively defined data types. Weak initiality / 
terminality only gives definition principles, see [167]. 
Encapsulation via sum types 
Let us consider a signature given by a finite number of atomic types Ofi,..., a„ 
and a finite number of function symbols F: ai —> 'TI, ..., F^: am —> Tm, 

Section 8.2: Use of polymorphic type theory 
461 
where the cr's and r's are built from the a's using finite products and coprod-
ucts (say). The n -h m-tuple 
( a i , . . . , a „ , F i , . . 
.,Fm) 
can then be seen as a term of the (second order) polymorphic sum type 
SaiiType. ••-Dan: Type, (cri -> n ) x ••• x (cr^ -> r ^ ) . 
This type thus captures the structure of the signature that we started from. 
An arbitrary term ( p i , . . . , /?„, M i , . . . , Mm) inhabiting this type can be seen 
as an instantiation (or model) of the signature. 
To be more specific, the signature of monoids contains a unit function sym-
bol e: 1 —> a and a multiplication m:a x a —> a. It gives rise to a type 
// = Ea: Type, a x ((a x a) -^ a). 
As a specific instantiation we can take the triple 
{a -^ (7, \x: a. x, Xy: (a -^ a) x {cr -^ a). Xx: a. 7r^y{{7Ty)x)) 
describing the monoid of terms cr -^ cr for an arbitrary type a. Notice that at 
present we have no means for expressing equalities like m{x,e) 
— x. Therefore 
one needs a logic over polymorphic type theory, just like the logic of equations 
and predicates in Chapters 3 and 4 is a logic over simply type theory. Elements 
of such a logic will be described in Section 8.6. 
We thus see that a signature (a collection of types and function symbols) can 
be represented as a single sum type, in which the atomic types ai are hidden. 
In this setting one often speaks of an a b s t r a c t t y p e instead of a signature, 
following [227]. Abstractness refers to a presentation without reference to any 
particular implementation. The following syntax is used. 
abstype a with a^ii cri,..., jr^: cr„ Is M in N : p 
(*) 
involving types and terms 
E], a: Type h (jf: Type 
E\T 
\- M: S a : Type, (cri x • • • x an) 
E I T,xi:ai,...,Xn:(Tn 
^ 
N:p 
with the restriction that the type variable a is not free in 
T,p. 
In the syntax that we use for S-elimination, the abstype-term (*) would be 
written as 
unpack M as (a, {xi,..., 
Xn)) in A^. 
The idea is thus that M is a specific representation of the abstract types 
Ea: Type, (cri x • • • x cr„) which is bound to the free variables a, ^ i , . . . , x„ in 

462 
Chapter 8: Polymorphic type theory 
N. As an example consider the type fi = Ea:Type.a x ((a x a) —^ a) we 
used earlier for the monoid function symbols. The operation which takes a 
monoid and replaces its multiplication {x,y) ^-^ x • y by [x,y) 
>-^ x'^ - y^ can 
be described as the following term of type n —^ ji. 
Xz: 11. abstype a with e\a,m:a 
x a -^ a 
is z in {a,e,\z\a 
x 
a.m[m['Kz)['Kz))[m{'K'Z)['K'z))). 
There is a related encoding of classes of objects in object-oriented program-
ming using sum types E, see e.g. [266, 138, 1] (and the collection [109]). If one 
understands methods and attributes (object-oriented operations) as an "em-
bedded" part of objects, then it is natural to encode an object as consisting of 
three parts: its (hidden) state space X, its current state as an element of X, 
and its operations as a co-algebra X -^ (^[^)^ where a describes the interface 
of the object. These data are collected into the type 
EX:Type.X x ( X - > ( J ( X ) ) 
of the class of "objects with interface cr". Here, like for abstract types above, 
the state space X is encapsulated via type variable binding in sums. 
Interestingly, objects with interface cr(X) may be interpreted as inhabitants 
of the carrier ri of the (weakly) terminal co-algebra of the associated functor 
cr[—/X] as in the proof of Theorem 8.2.2—provided X occurs positively. This 
connection between co-algebras and object-orientation is further elaborated 
in [283, 138, 162, 164]. 
Exercises 
8.2.1. 
Define addition and multiplication terms of type Nat —> Nat —>• Nat for 
the Church numerals with type Nat = IlaiType. (a —)• a) —>• a —)• a, via 
suitable mediating algebra maps Add(a:), Mult(a;): Nat =^ Nat, using weak 
initiality. 
8.2.2. 
Give the encoding in A2 of 
(i) 
Boolecins (with constructors true: 1 —)• bool and false: 1 —)• bool); 
(ii) finite lists of type a; 
(iii) binary trees of type a of finite depth; 
(iv) binary trees of type a of infinite depth; 
(v) finitely branching trees of type a which are of infinite depth. 
[For the last three examples, see e.g. [124].] 
8.2.3. 
Consider the formulation of the Ccirrier of the weakly terminal co-cilgebra 
T\ in terms of II and ^ , 
n = Ila: Type. (IIX: Type. (X -> o-) -> X -> a) ^ a. 
as mentioned after the proof of Theorem 8.2.2. Define for this formulation 

Section 8.3: Naive set theoretic semantics 
463 
an associated destructor destr: n -^ (T[TI/X], and show that it is weakly 
terminal. 
8.2.4. 
Define the product of (the signatures of) two monoids as a term fi x ^ ^ ^ 
using the above abstype notation. 
8.2.5. 
One defines the sets PV(cr) and NV(<T) of positively and negatively oc-
curring variables in a type cr as follows. 
PV(a) = {a} 
NV(a) = {a} 
PV((7 
XT) 
= PV(^) 
U PV(r) 
NV(^ 
X r) 
= NV((T) U N V ( T ) 
PV((T + r) = PV(cr) U PV(r) 
NV(^ + T") = NY(a) U NV(T) 
PV((T ^ r) = NV(^) U P V ( T ) 
NV((T -> T) = PV(^) U N V ( T ) 
PV(na: Type. ^) = PV((T) - {a} 
NV(na: Type, a) = NV((T) - {a} 
PV(Ea: Type, (T) = PV(^) - {a} 
NV(i;a: Type, a) = NV(cr) - {a} 
Extend Lemma 8.2.1 in the following way. Let E!,X:Type h aiJype be a 
type with a free type variable X. U X occurs only positively in cr, then 
cr[—/X] extends to a covariant functor C(E]) —)• C(E!); and it extends to a 
contravariant functor C(E1)°^ -^ ^C^) ^^ case X occurs only negatively. 
8.3 Naive set theoretic semantics 
As v^e have seen in Chapter 2 on simple type theory, set theoretic semantics 
of types and terms involves interpreting a type r as a set J r ]] and a closed 
term M of type r as an element [[M]] G [[r]]. If M is not closed, say with 
free term variables xi: cri,..., a:„: cr„, then it gets interpreted as a function 
l M l l : I < T i ] ] x - - - x | [ c r „ ] ] - > [ [ r l . 
In polymorphic type theory there are type variables a, which introduce an 
extra level of indexing. In this section we write out the corresponding (naive) 
set theoretic semantics. This works fine for first order polymorphic type theory 
A-^. The type theories A2 and Au; however, involve (among other things) 
second and higher order polymorphic products 11. As shown by Reynolds 
in [287], see also [288], these cannot be interpreted in this naive set theoretic 
way. So one may ask: why consider this set theoretic semantics? First of all, 
the negative result in itself is significant. And in order to explain it, we have 
to describe the set theoretic interpretation to some extent. The result shows 
that we have to look for other categories than Sets in order to model second 
and higher order polymorphism. Secondly, there are indeed other universes— 
like the category u;-Sets of cj-sets, or the effective topos EfF—in which these 
polymorphic type theories can be interpreted. Moreover, this can essentially 
be done in a naive way, i.e. using the set theoretic formulations, but applied 
to the full internal category of PERs in a;-Sets and in EfF. 

464 
Chapter 8: Polymorphic type theory 
We begin by considering what a set theoretic model of a polymorphic sig-
nature (E, (Da)) should be. A model of a higher order signature in predicate 
logic is a model of that signature in such a way that the type Prop of propo-
sitions gets interpreted as the set (of sets) 2 = {O,1}=={0,{0}}, where 0 = 0 
stands for 'false' and 1 = {0} for 'true'. In higher order (predicate) logic it 
is enough to have this true/false distinction, but in polymorphic type theory 
there is more structure (given by terms in types, or, by proofs in propositions, 
using the propositions-as-types analogy). Thus we let the interpretation of the 
kind Type be an arbitrary set of sets W, so that functions between the sets in 
U can serve as interpretations of terms. 
A set theoretic model of a polymorphic signature (E, (Ea)) consists of 
• a set theoretic model of the kind signature E, where the interpretation 
[[Type]] of Type is a set of sets U. Each type 
ai:Ai,...,Qfn:^n ^- o-iType 
i.e. each type in the type context over {A\^.. .,An)^ is then interpreted as 
a function 
[[yli]lx..-x[[>l„l 
^U 
It thus forms a collection of sets [I<T]](a) G ZY for a ^ I ^ i 1 x • • • x I^n I-
• for each function symbol F'.a\,...^am 
—> CTm+i in the type signature 
^(^i,...,^n> ^^^^ ^diid context (^41,... j^n), a collection of functions 
[[cri]](a) X •.. X l(Tmi[a) 
^ [[^^+i]](a) 
for a G I ^ i l X ••• x [[A„]]. Put a bit differently, F is interpreted as a 
function [[FJ in the big 'dependent' product 
IF^ e 
n 
([I^il(«) X • • • X I^ml(a) => [[(T^+il(a)), 
aelAilx-xlAn} 
where => is function space. 
8.3.1. Remarks, (i) For convenience we may assume that the set li is closed 
under finite products of sets, see Exercise 8.3.1 below. This allows us to restrict 
ourselves for the interpretation of terms to sets of the form 
which makes things more manageable. One sees how the 'double indexing' by 
type variables a G [[AJ and by term variables x G [[crl](«) takes place. 

Section 8,3: Naive set theoretic semantics 
465 
(ii) Let us provide some categorical clarity about what we are doing: we 
consider the full subcategory l(_ ^-> Sets with U as set of objects. This U_ 
is a small category, and hence an internal category in Sets. A type a: A \-
cr(a):Type gets interpreted as a map |[a-]]:[[yl| -^ U, i.e. as an object in 
the fibre over [[ yl ]] in the externalisation of this internal category l{_. And a 
function symbol F:cr(a) —> r(a) becomes a morphism [[crj -> [[r] in this 
fibre over [[A]). 
(One can also describe U_ as coming from a family in Sets, see Exer-
cise 8.3.5 (iv) below.) 
(iii) We will assign meanings [[cr]] and [[MJ to all types S h criType and 
terms E\T 
\- M:a (and not just to the atomic ones in the signature). In writ-
ing [[cr]] and [[Mj we ignore these kind and type contexts E and F. It would 
be better to carry them along, but that is notationally rather cumbersome 
(see Exercise 8.3.3). 
We continue with the naive set theoretic semantics of the polymorphic cal-
culi A^, A2 and Au;, on top of a model of a polymorphic signature as above. 
(1) For A ^ one assumes that the set U is closed under exponents (function 
spaces), I.e. that it satisfies 
X,Y 
eU => Y^ 
eU. 
By an argument similar to the one in Exercise 8.3.1 one may extend ZY to a 
set which is closed in such a way. 
The exponent type cr —)• r of types cr, r interpreted as functions 
IT} 
is then given by pointwise function spaces: 
Aa.l[rl(a)I"K«) 
Abstraction is done as follows. Assume we have a term a:A\x:p,y:a\- 
M: r, 
which is interpreted as |M]] G na€[-4] (l/'K") ^ II"'K''') =^ II'"K'^))' ^^^^ 
we get 
l\y:(T.Mi 
"M 
%a.%x.%y.lMi{a){x,y) 

466 
Chapter 8: Polymorphic type theory 
For application assume terms a\ A \ x: p \- M:a -^ r and a: A \ x: p \- N:a. 
These are interpreted as dependent functions [ M J G IlaEMl (I/^K^) 
^ 
la -^ rlia)) 
and [[TV]] G UaelA} (IPII(«) => H^IW). then one takes 
IMNI 
"M 
%a.%x.lMl(a){x)(lNl{a){x)) 
e 
n 
{M{a)^lrl{a)). 
aelA] 
(2) For A2 one would naively assume that U is closed under exponents and 
also under dependent products over itself, in order to interpret quantification 
of the from Ua: Type, a for a: Type. That is, one additionally assumes that 
FeU^ 
=> 
UFeU 
where IIF is the set 
UF = {f-M -> \Jxeu ^ W I ^ ^ e U. f{X) € 
F{X)}. 
Below it will be shown that this assumption cannot be true, but for the time 
being, we simply continue. 
For a type a: A, /?: Type h a: Type, interpreted by 
lAlxU 
^U 
one puts 
[[n/?:Type.(r]|1l' 
I^I 
^ 
^ 
^U 
Second order abstraction goes as follows. Take a term a: A, (3: Type \ x:a \-
M: T, where /3 does not occur in (T. This M is interpreted as a function |[M]] € 
U(a,b)€lAixU (II'^I(«) ^ I^I(a,*)). so that we can put 
I A/?: Type. M I %^ 
Xa.Ax.Ab.lM}(a,b){x) 
e 
n 
(l^]l(a)^ln/?:Type.rI(a)). 
Notice in particular that by the restriction in the Il-introduction rule on the 
occurrence of/?, the interpretation of [['''JKa) G U does not depend on 6 G W. 
For application of terms to types, assume a: A \ x:a V TV: 11/?:Type, r and 
a-.AV p:Type, interpreted as I TV] G Flaer^l ( I ' ^ I H => IH/?: Type, r 1(a)) 

Section 8.3: Naive set theoretic semantics 
467 
and HPI: I^lJ ->• U. Then one takes 
iNpl 
<i' 
Aa.%xjNl(a)(x)iM(a)) 
e 
n 
(l'^]l(«)=^Irb//?]I(a)). 
The set theoretic interpretation of sums E is left as an exercise below. 
(3) For Xuj one naively assumes that U is closed under all dependent products 
(and not just over itself): 
F ^U^ 
^ 
Uj{F)eU 
for any set /. The dependent product 11/ is given by 
Uj(F) = {f:I^ 
U e / ^ ( 0 I ^^' e I- m 
e F{i)}. 
Thus UF in (2) is Ilu{F). One can then extend the quantification to all kinds: 
for a: A, p. B h a: Type, one puts 
Ul— 
^ 
^u 
%a.niBi{^b.lal{a,b)) 
The rest is as before. 
In the remainder of this section we show (and analyse) the impossibility of 
having a set of sets li closed under exponents and products as in (2) above. 
Notice that we have assumed these exponents and products in U to be the 
same as in the ambient category Sets. The argument we use is very much like 
in the proof of the following famous result. 
8.3.2. Fact (Freyd [82, Chapter 3, Exercise D]). There are no small com-
plete categories except preorders. 
Proof. Let C be a category with a small collection Co of objects and small 
collections of hom-sets. Form the set Ci as disjoint union of arrows in C: 
Ci=U 
1[C{X,Y). 
Xe€Y£€ 
Assume we have two different parallel arrows f :^ g: X zit Y in C Every 
subset A C Ci gives rise to an arrow h{A):X 
—)• Ylc 0^) ^^^^ component 
h{A)a for a £ Ci equal to / if a G A, and equal to g else. The assignment 
A 1-^ h{A) is clearly injective. This gives a composite of injections P{Ci) = 
2^1 <^ ^ ^ ^ r i c 0^)) ^^ ^ 1 ' which is impossible, since a powerset P{Ci) 
cannot be embedded into Ci. 
• 

468 
Chapter 8: Polymorphic type theory 
Roughly the same argument as used in this proof can be applied to the set 
theoretic models that we consider above. 
8.3.3. Fact (After Reynolds [287]). There are no sets of sets U closed under 
exponents and dependent product over itself—as in (2) above—except trivial 
ones (for which every set X G W has at most one element). 
Proof. Assume towards a contradiction that some set X ^U has two different 
elements x, y G X. Form the sets 
D = UzeuX^ 
eU 
and 
V = Y[ Z =: {{Z, z)\Z 
eU Siudze 
Z). 
There is an obvious injection D ^^V, 
namely / i-^ [Uzeu^^,/)- 
And for 
every subset A C V there is an element in h{A) 
G D, with components 
h{A){Z){z) 
equal to ar G X if {Z, z) ^ A and to y E X else. It is clear that 
A H^ h{A) is injective, so we have a sequence of injections P{V) = 2^ ^-^ D ^^ 
V. Again this is impossible. 
D 
It is useful to analyse the logical aspects of this negative result. The contra-
dictions above come from the impossibility of having an injection 2^ ^-^ A in 
(classical) set theory. But in a topos 2^ is the object of decidable subobjects 
of A, which may very well be embedded into A. The corresponding negative 
result in a topos is the following. We explicitly formulate it in higher order 
logic, so that it applies to other models of higher order logic than toposes. 
In particular we wish to use it for the (classical) higher order logic of regular 
subobjects in u;-Sets. 
8.3.4. P r o p o s i t i o n . An injection 
Pa 
>-^ cr cannot 
exist in higher 
order 
logic—where 
Pa is the powertype 
of a: Type defined as exponent 
type Pa = 
a —> Prop. 
Proof. We reason informally using an argument due to van Oosten. Assume 
m: Pa ^^ cr, and form terms a: Pa and e: cr by 
a = {x'.al'ib: 
Pa.x 
Eia b Z) X ^a i^{b)} 
and 
e = m{a). 
It is then clear that e ^a <^' But according to the definition of a we do get 
e Ga «. Indeed, for every 6: Pa with e Ga 6, the equation e =^ m{b) does not 
hold: by injectivity of m it leads to a —pa b and so to e G^ a. Hence e is both 
in a and not in a. 
• 
8.3.5. Fact (Higher order logic version of Fact 8.3.3). For a set of sets U 
which is closed under exponents and dependent products over itself, there 
is no set X G W with an injection Prop >-^ X m higher order logic with 
extensional entailment. 

Section 8.3: Naive set theoretic semantics 
469 
It may be clear that the previous negative result (Fact 8.3.3) is a special 
case, since in classical set theory [i.e. in the higher order subobject fibration 
on Sets) Prop is 2 = {0, 1}: if there cannot be an injection {0, 1} ^^ X, then 
X cannot have more than one element. The use of a set of sets U here is rather 
informal. A more precise version may be obtained by doing Exercise 8.3.6. This 
more general Fact 8.3.5 is a special case of the main theorem in [269]. The 
proof used there is more complicated than the one below, and uses expressible 
functors (as in [288]). 
Proof. We can give virtually the same proof as before (with the same D and 
V) starting from m: Prop ^^ X £U. 
One now defines P{V) >—> J9 by 
{ACV)^XZ 
^ U. \z e Z. m{{Z, z) E A). 
This yields an injection by extensionality. Hence we get P{V) ^-> D ^-^ V, 
which is impossible by Proposition 8.3.4. 
• 
8.3.6. R e m a r k s , (i) As we shall see in the next section there are indeed 
models of higher order logic containing a "set" which is suitably closed under 
exponents and products (as in the ambient category) to allow interpretation 
of second and higher order polymorphic type theory. These examples involve 
the internal category of PERs in cj-Sets and in Eff. It is instructive to see 
why there is no injection Prop ^^ R for R a PER in these cases. 
(a) In the classical higher order predicate logic of regular subobjects in 
cj-Sets (see Proposition 5.3.9) Prop is V2. As one easily checks, every map 
V2 -^ (^/R, 
G) for R a PER is constant: if e realises such a map / , then since 
0 G ^V2(0) n ^V2(l), we get e • 0 E /(O) Pi / ( I ) . Hence /(O) = / ( I ) and / is 
constant. Thus there is certainly no mono V2 -^ (N/i^, E ) . 
(b) By essentially the same argument one shows that every map Prop = 
(PN, JO) -^ (N//?, E) in EfF is constant. This is left to the reader. 
These considerations show that Fact 8.3.5 does not obstruct suitable com-
pleteness of PERs in cj-Sets and in EfF. What it also suggests is to investigate 
the collection of those objects X for which all maps Prop -^ X are constant, as 
a possible candidate for a suitably complete set of sets U. Such objects X are 
called 'orthogonal to Prop'. This aspect of orthogonality of PER models was 
much emphasised by Freyd (see also [41, 150]). It will be further investigated 
in Section 11.7. 
(ii) It has been argued (see notably Pitts [268]) that the impossibility of 
having a suitably complete model of polymorphism in Sets is due to the 
classical logic that we have for sets. The above arguments show that it is not 
the classical nature of the logic (since u;-Sets with regular subobjects also has 
classical logic, see Proposition 5.3.9) that is to blame, but rather the nature 
of the type Prop of propositions (as described in Fact 8.3.5) which obstructs 

470 
Chapter 8: Polymorphic type theory 
the existence of such models. Shortly after [268] Pitts expressed this adapted 
analysis in [269]. 
In the end one may think that our approach is too naive in the sense that we 
have required products IIF E U for all F eU^, 
whereas for the interpretation 
of A2 one only needs products of certain F E U^, namely of those F that come 
from the interpretation of types. The original result of Reynolds in [287] is 
that this situation already cannot occur. The above Fact 8.3.3 is a diluted 
version of Reynolds' result. Also in the sense that it involves products with 
Exercises 
8.3.1. 
Let U he a. set of sets. Put 
Uo = UU {1}, 
where 1 = {0} 
Un^l 
= 
UnU{XxY\X,YeUn} 
^oo 
= 
U n e N ^"• 
Show that Uoo is the least set containing U which is closed under finite 
products. 
8.3.2. 
Check the validity of the conversions for -> and 11 in (1) and (2) above. 
8.3.3. 
Rewrite the above interpretations as JE! h o-iTypel and JS | F h Mia J 
with explicit contexts (for a few crucial cases). Describe the interpretation 
of the weakening and contraction rules using this notation. 
8.3.4. 
Let W be a set of sets closed under dependent sums: 
FeW 
^ 
Ei{F)eu 
where S/(F) = {{i^x) \ i £ I and x E F{i)}. Interpret the S-types of Xu. 
8.3.5. 
Let U he a, set of sets closed under finite products. One can consider U has 
a full subcategory U_ «-^ Sets. Notice that ^ is a small category, and is thus 
internal in Sets. 
(i) 
Show that in assumption (1) for the interpretation of A->, ZY is assumed 
to be Cartesian closed, with exponents as in Sets. 
(ii) Show that the dependent product 11/ and the dependent sum E/ form 
(internal) right and left adjoints to the diagonal functor U -^ U . 
(iii) Verify that in the specicJ case where ^ = 2 = {0, {0}} (which is used 
for logic), U is Cartesian closed and has right and left adjoints II/, E/. 
(iv) Let V = ]J;^cty^ = {(^?^) I ^ 
^ U 3iid X E X} with obvious 
projection I ^ I. Describe the full interned category resulting from 
this family as in Example 7.1.4 (ii) and notice that this gives another 
way to describe IL 
8.3.6. 
Consider in higher order logic an internal category C = {C\ 
] Co)—given 
by types Co, Ci: Type with suitable terms—which is internally Cartesian 

Section 8.4' Fibrations for polymorphic type theory 
471 
closed and has an internal right adjoint to the diagonal C —> C^°. Show 
that there cannot be an object X: Co with an injection Prop ^^ C(1,X) = 
{ / : ^ i | ^ o ( / ) = C o l A a i ( / ) = e o X } . 
8.4 Fibrations for polymorphic type theory 
The double indexing in polymorphic type theory—by type variables and by 
term variables, or, by kind contexts S and by type contexts F—asks for a fibred 
description. After all, indexing is what fibred categories are all about. The aim 
in this section is to define appropriate fibred categories for polymorphic type 
theories, and to provide several examples. Prominent among these are models 
of PERs, suitably indexed over Sets, over cj-Sets and over EfF. 
As we already mentioned, the set of sets U used in the previous section 
corresponds to a full internal subcategory in Sets, and hence by externalisa-
tion to a small fibration over Sets. The next definition captures the essential 
fibred aspects used so far. 
8.4.1. Definition. A polymorphic fibration is a fibration with a generic 
object, with fibred finite products and with finite products in its base category. 
It will be called split whenever all this structure is split. 
Such a polymorphic fibration captures the structure of contexts in polymor-
phic type theory, just like categories with finite products capture the structure 
of contexts in simple type theory. One thinks of the objects / of the base cat-
egory as kinds, and of objects X of the fibre over / as types in kind context 
/, which we can write as X = {i: I h Xj-rType). The generic object involves 
an object Type in the base category and a correspondence between types 
i: I h Xi.Type 
over / and classifying morphisms of kinds / —> Type in the 
basis. 
(As an aside, we mention that a fibration with fibred finite products and 
finite products in its base category is an object with finite products in the 
2-category Fib of fibrations over arbitrary bases. See Exercise 1.8.10 for de-
tails. Hence, fibred categories with finite products capture the context struc-
ture of polymorphic type theory, just like ordinary categories with finite prod-
ucts capture the context structure of simple type theory.) 
8.4.2. Example. Let (E, (Ea)) be a polymorphic signature. It forms the 
starting point for a syntactically constructed (split) polymorphic 
fibration 
a(E,(Sa)) 
4- 
. The base category Ci{T>) is the classifying category of the (higher 
order) signature E, as described in Chapter 2. Objects are kind contexts E = 
ai: Ai,..., 
an'An. 
Morphisms E' —)• S are sequences of terms ( M i , . . . , Mn) 

472 
Chapter 8: Polymorphic type theory 
with 'E' h Mi'.Ai. For a kind A we often write A G C^(S) for the singleton 
context {a: A) G (X(E). Especially we have Type G (X[T.). Products in (^(S) 
are given by concatenation of kind contexts. 
There is a split indexed category on ff(S); the functor (X(E)°P -> Cat 
assigns to a kind context S, the category of types and terms in context 
objects 
types E! h criType in context El. 
morphisms 
cr —>• r are terms N — N[x) with 'E\x\a 
h N[x): r. 
The morphism part of this functor ff(5])°P -> Cat is described by substi-
tution in type variables, as described in the beginning of Section 8.1. The 
C^(S,(Sa)) 
Grothendieck construction then yields a split 
fibration 
i 
. It has 
•" 
^ 
a(E) 
Type G C^(S) as split generic object—since objects over 5 are morphisms 
S —)• Type in the base, by construction. The fibration has (split) fibred fi-
nite products because we assume finite products of types (in all polymorphic 
calculi). 
(We have used terms for morphisms, but what we really mean in this exam-
ple are equivalence classes (under conversion) of terms. But explicitly writing 
these classes is cumbersome.) 
E 
An arbitrary split polymorphic fibration ^ 
can serve as a categorical 
model of a polymorphic signature (E, (E^)) in the following manner. 
• Such a model is given first of all by a model of E in B, which interprets 
Type as the generic object Q G B. We conveniently describe this model as a 
finite product preserving functor M'.Cl{Ti) -^ IB with A^(Type) = Q. Each 
type El h cr:Type then gets interpreted as a morphism wM(E) —> Q. Hence 
it corresponds to an object Xa above A^(E). 
• Secondly such a model of (E, (Ea)) involves for each function symbol 
Fio-i,. ..,(Tm —> (Tm-^i in a type context T.{Ai,...,Ar,) over (^i,..., ^n), a 
morphism X^i x- • -xXa^ -> -^<7„,+i in the fibre over M[a\: A\^... 
^ an'. An)-
It is not hard to see that such a model corresponds to a morphism of fibrations 
«(S,(Sa)) 
^ E 
Cf(S) 
^ 1 
M 
which preserves the structure of split polymorphic fibrations. This gives an-
other instance of functorial semantics—as used earlier for simple type theory 

Section 8.4-' Fibrations for polymorphic type theory 
473 
and logic—where interpretations are structure preserving functors. 
By putting some further structure on polymorphic fibrations we get appro-
priate fibred categories for first, second and higher order polymorphic calculi 
A—>, A2, XLJ. This structure is as in the fibrations used for predicates logics, 
but is now used in a situation with proper (non-preordered) fibre categories. 
In A ^ there are exponent types a -^ r, which are modelled as fibred expo-
nents. In A2 one additionally has polymorphic products and sums Ua: Type, a 
and T,a: Type, a over Type. These are modelled categorically by quantification 
along Cartesian projections TT: / x fi -> /, where Q interprets Type. This was 
called "simple 
fi-products/coproducts" 
in Section 2.4 for the CT-structure 
with Q as sole type. In XLJ there is quantification over all kinds (and not just 
over Type), which is modelled by quantification along all Cartesian projections 
TT: / X J —)• /. This was called "simple products/coproducts" in Section 1.9. 
Further, the exponent kinds require the base category to be Cartesian closed. 
All this will be summarised in (point (i) in) the following definition. It is 
by now quite standard; early work in this direction was done by Seely [307], 
Lamarche [185] and Pitts [268]. 
8.4.3. Definition, (i) A polymorphic fibration with Q. in the base as generic 
object, will be called 
(a) a A—)'-fibration if it has fibred exponents; 
(b) a A2-fibration if it has fibred exponents and also simple Q-products 
and coproducts; 
(c) a Acj-fibration if it has fibred exponents, simple products and coprod-
ucts, and exponents in its base category. 
(ii) A A-^= / A2=: / Au;=-fibration is a A—)- / A2 / Acj-fibration with (sim-
ple) equality. (The Frobenius condition holds automatically in the presence of 
fibred exponents, see Lemma 1.9.12 (i).) 
8.4.4. Definition. Let <> be ^ , 2 , a; or —)-=:, 2 = ,a;=. 
(i) A A<)-fibration will be called split if all of its structure is split. In 
particular, its underlying polymorphic fibration is then split. A A<C>-fibration 
is called small if the fibration is small. 
(ii) A morphism of (split) A<C>-fibrations is a morphism of the underlying 
(split) fibrations which preserves all of the structure (on-the-nose). 
The functorial interpretation as described after Example 8.4.2 for poly-
morphic fibrations extends in a rather straightforward to A—)--, A2- and 
Acj-fibrations. The interpretation of Ua.A.a 
and T,a:A.a 
is much like the 
interpretation of ^x'.cr.ip and 3X'.(T.(^ from predicate logic in Section 4.3, ex-
cept that the extra structure of terms has to be taken into account. (See the 
'mate' correspondences in Lemma 4.1.8 and Exercise 8.1.3.) 

474 
Chapter 8: Polymorphic type theory 
The interpretation of equality is also like in equational logic and in predicate 
logic. For objects /, J in the base category, the contraction functor J* induced 
by the diagonal 6 — (id, TT'): / x J -> (/ x J) x J has a left adjoint Eq(/j), 
see Definition 3.4.1. We then have an equality type Eqj = Eq(/j)(l) over 
(/ X J) X J; it may be written as 
i:/,i: J , / : J hEqj(i,/):Type 
where i is a parameter. The unit of the equality adjunction yields the reflex-
ivity term 
v.I,y.J\ 
0 I- rj(j):Eqj(j,i) 
= r ( E q j ) ( j ) . 
For elimination, assume we have a term 
f:/,j:J |:c:X(ijj) f-M:y(ijj). 
This is a map <J*(X) -^ (J*(y) over / x J. By transposition and Frobenius we 
get a composite 
X X Eqj = X X Eq(,,j)(l) S Eq(/,j)(<J*(X) X 1) S Eq(/,j)(<5*(X)) — ^ y 
which is the required elimination term in 
i:IJ:J,f:J 
\ x: X(ijj>),y:Eqj{j,f) 
h M with / = j via 2/: ^(ijj')-
In the remainder of this section we describe various examples of polymorphic 
fibrations. Later, at the end of Section 11.3 there is an example of a model 
with only exponent types -> plus polymorphic products and sums 11, E, but 
without Cartesian product types l,x. The categorical description of fewer 
type formers requires more sophisticated fibred category theory—in the form 
of extra levels of indexing, like in Section 2.4 where we used simple fibrations 
(instead of ordinary categories) to describe models of simple type theory with 
exponents but without Cartesian products. 
PER-examples 
Next we describe three examples of Au;=-fibrations where types are interpreted 
as PERs, indexed over Sets, over cj-Sets and over EfF. The three fibrations 
consist of "uniform families of PERs" and can be organised in change-of-base 
situations: 
UFam(PER) 
^ UFam(PER) 
^ UFam(PER) 
J 
J 
Sets ^ 
^ a;-Sets ^ 
^ Eff 

Section 8.4- Fihrations for polymorphic type theory 
475 
In this diagram we have used the name UFam(PER) for three different cat-
egories. One could write them as UFamsets(PER), UFamu;-Sets(PER) and 
UFamEff(PER), but that involves rather heavy notation. And confusion is 
not likely as long as we use these total categories together with their base 
UFam(PER) 
UFama;.Set» (PER) 
category, as in 
i 
, instead of 
i 
Recall from Proposition 7.3.7 that the two fibrations of PERs over a;-Sets 
and over EfF are small. But the fibration of PERs over Sets is not small, as 
will be shown in Example 9.5.3 later on. 
An efficient way to establish that these three fibrations of PERs are 
UFam(PER) 
Ac<;=-fibrations is first to show that the fibration 
i 
on the right 
Eff 
is such a Aa;=-fibration and then to appeal to these change-of-base situations. 
But computations over cj-Sets are easier than over EfF so we prefer to start 
with the fibration of PERs over u;-sets in the middle. Then we can still appeal 
to change-of-base since the fibration of PERs over EfF can be obtained via 
change-of-base along the separated reflection functor, see Proposition 6.3.2 (i). 
UFam(PER) 
8.4.5. Proposition (Moggi and Hyland [143]). The 
fibration 
i 
of 
CJ-Sets 
PERs over uj-sets is a small split XLJ=-fibration. 
ProoF. Since the fibration is obtained by externalisation it is by definition 
small and split, and has a split generic object. It has a split fibred CCC-
structure, inherited pointwise from PER. It has simple products, coproducts 
and equality by Lemma 1.9.6. We give the formulas explicitly: the product Y[ 
along a projection TT: (/, E) x (J, E) -^ (/, E) in a;-Sets is given on a family 
R = {Rij)i^jj^j 
of PERs over (/, E) x (J, E) by 
Yl{R)i = {{n,n') I Vj G J.\/m,m' 
G E{j).n - mRiju' 
• m'}. 
And the coproduct JJ along this same projection is: 
where E{j, [n]) = E{j) A [n] = {(Ar,m) | k G E(j) and m G [n]}, and where 
r:cc;-Sets —>• PER is the left adjoint to the inclusion PER M- cj-Sets. Equal-
ity along a diagonal S: (/, E) x (J, E) -> ((/, E) x J, E)) x (J, E) on a family 
R = {Rij) over (/, E) x (J, E) is 
Eq{R)ijj^ 
= } ^ ^ ' ' ' elsl"^ 
• 
UFam(PER) 
We turn to families of PERs over sets. We define the fibration 
i 
of these as the one obtained by change-of-base from the fibration 

476 
Chapter 8: Polymorphic type theory 
over u;-sets along the inclusion V: Sets M- c«;-Sets. The fibre category over 
/ G Sets thus consists of 
objects 
/-indexed families R = {Ri)i^j of PERs i?,. 
morphisms 
i? —> 5 are families / = {fi)iei of morphisms of PERs 
fi'.Ri —> Si which have a common realiser: there is a single 
code e E N such that e tracks every fi. 
UFam(PER) 
8.4.6. Corollary (After [94]). The 
fibration 
i 
of PERs over sets 
is a split \(jj—-fibration. 
Proof. This follows from the change-of-base situation 
UFam(PER) 
^ UFam(PER) 
J 
Y 
Sets ^ 
• 
^ u;-Sets 
since the inclusion Sets ^> a;-Sets preserves finite products. Explicitly, for 
a family R — {Rij)i^ij^j 
over I x J^ the product and coproduct along 
TT: / X J -> / are, respectively, 
Y[{R)i = PI Rij 
and 
UWi = V ^^^' 
jeJ 
jeJ 
where the intersection f] is the maximal PER N x N in case J is empty, and 
where Y is the join in the poset (PER, C) of PERs. 
• 
We shall see later in Example 9.5.3 that this fibration of PERs over Sets 
is not small. Hence the non-existence results in the previous section do not 
apply in this case. 
Our last PER-example involves indexing over the eff'ective topos EfF. 
UFam(PER) 
8.4.7. Corollary. The 
fibration 
i 
of PERs over Ef^ is a small split 
\uj—-fibration. 
Proof. This follows from the change-of-base situation 
UFam(PER) 
^ UFam(PER) 
J 
t 
s 
^ 
Eff 
^ cj-Sets 
from Proposition 6.3.2 (i), because the separated reflection functor s:Eff —> 
a;-Sets preserves finite products (see Exercise 6.2.3). 
• 

Section 8.4-' Fibrations for polymorphic type theory 
477 
These PER-examples may be called "parametric in the sense of Strachey", 
since a term inhabiting a polymorphic product Da: Type. cr(a) has a single 
underlying code—which may be seen as an untyped program—that computes 
each instantiation of the type variable a. The term thus behaves uniformly 
for each type. 
Next we describe an alternative PER-model, which is parametric in the 
sense of Reynolds. 
A relationally 
parametric 
PER-exampIe 
Below we present a different PER-model of second order polymorphic type 
theory A2. It is different from the earlier ones (over Sets, cj-Sets and EfF) 
in the sense that it may be called relationally parametric in the sense of 
Reynolds [286]. What we present is a categorical version of the concrete in-
terpretation described in [11]. Noteworthy is that the two properties known 
as "identity extension" (for types) and "abstraction" (for terms) which are 
explicitly proved for the interpretation of [11] are incorporated here as as con-
ditions in the categorical model. Towards the end of the next section we give a 
further analysis of the parametricity in this model, along the lines of [204, 293]. 
Recall from Proposition 4.5.7 that a regular subobject of a PER R (in the 
category of PERs) may be identified with a subset A C N/R 
of i^'s quotient 
set. A (regular) relation on a pair R^ S of PERs may then be described as 
a subset of N/R 
x N / 5 . Especially, there is an equality relation Eq(i^) C 
N/R 
X n/R 
given as Eq(i?) — {([?^]/?, [^]-R) I ^ ^ l-^D- The main idea in the 
model of [11] is to interpret a type as a pair of maps, one mapping PERs to 
PERs (as in the earlier PER-models) and one mapping relations to relations, 
in an appropriate manner. This is formalised in the following definition, giving 
the intended base category of a A2-fibration of parametric families of PERs. 
8.4.8. Definition. Let P P E R be the category with natural numbers n G N 
as objects. We first define morphisms / : n —>• 1 with codomain 1. These are 
pairs / — {P, f^) of functions 
F 
PER" 
^ PER 
and 
f^^ 
n 
inH^/Rix^/Si) 
p{N/r(R)xn/r{s)) 
ll<i<n 
satisfying the identity extension condition: for each n-tuple of PERs R G 

478 
Chapter 8: Polymorphic type theory 
PER" one has 
Eq[r(R))=r^^(Eq{Ri]^ 
as subsets of N//P(fi) x N/fP{R). We use the superscripts (-)^ and (-)'' for 
the components acting on pers and on TTelations. 
More generally, morphisms n -> m in PPER are m-tuples (/i, •. •, /m) of 
morphisms /,: n -^ 1. 
It is not hard to see that we get a category in this way. For 1 < i < n there 
are projection morphisms proj(i) = (proj(i)^, proj(2y): n —> 1 by 
proi{iY{R) = Ri 
and 
pro]{i)''^^{A) = A. 
These clearly satisfy "identity extension". The identity morphism n —^ n is 
then the n-tuple (proj(l),..., proj(n)). Composition of (/i,..., fm)- n —^ m 
and (5^1,.. .,gk)''rn —> /? is the Ar-tuple (/ii,... ,hk):n —^ k, where 
hU^) = ^f(/f(^),...,/^(^)) 
(^iUsi^l = U)(7,v((/[U5(^1..--.(/;;zU5(^l). 
where Ui = ff{R) 
and Vi = 
ff{S), 
By construction, this category PPER has finite products: 0 G PPER is 
terminal object, and n + m is the Cartesian product of n, m G PPER. In a 
next step we define a fibration over PPER with maps n —> 1 as objects over 
n. In this way the object 1 G PPER becomes generic object of the fibration. 
PFam(PER) 
8.4.9. Definition. The split fibration 
4- 
of parametric families of 
PERs is defined as arising from applying the Grothendieck construction to the 
indexed category P P E R ^ P —)• Cat which has as fibre category of n G PPER: 
objects 
maps f = {P.D'.n-^ 
1 in PPER. 
morphisms 
a: f -^ g are families of morphisms 
fP{R) 
^gP{R) 
^ ^ 
between PERs, which: 
• are tracked by a single code: some e G N tracks every 
a^ in PER: 
V^ G PER^ Va G |/^(^)|. a^([a]^p(^)) - [e • a]^,^^). 

Section 
8.4-' Fibrations 
for polymorphic 
type theory 
479 
• satisfy the abstraction condition: for n-tuples R, S £ 
PER" of PERs and relations Ai C N/RixN/Si 
on them, 
if 
(H, W) e r^j{A) c n/fP{R) x n/r{S) 
then 
{a^([a]),ag{[b])) = {[e • a], [e • b]) 6 
g^giA) 
CE/gP(R)xN/gP{S). 
(Where we have omitted subscripts of equivalence classes 
[—] to increase the readability.) 
Reindexing is done simply by composition. 
PFam(PER) 
8.4.10. Proposition (After [11])- The above 
fibration 
i 
of para-
PPER. 
metric families of PERs is a split X2-fibration. 
PFam(PER) 
Proof. By construction, the 
fibration 
4- 
has a split generic object 
PPER. 
1 G PPER. We show that it is a split fibred CCC, and that it has split 
simple 1-products. In the fibre over n G PPER there is a terminal object 
In:?^ -^ 1 by l^(^) = N X N, which is pointwise the terminal PER. This 
function 1^ on PERs determines its associated function IJ^ on relations by the 
identity extension condition. The Cartesian product of objects f^g.n^ 
1 is 
f X g:n —> 1 with 
(fxg)P{R) 
= 
fPiR)xgP(R) 
= {{a,b) I (pa,p6) G / P ( ^ ) and (p'a,p'6) G ^^l^)}, 
which is the pointwise product of PERs; and with action on relations: 
{fx9)l§{A) 
= 
{([{a,b)],[{a',b')])\{[a],[a^)efy(A) 
^nd{[b],[b'])eglg{A)}. 
The exponent oi f,g:n zzt I is f ^ g:n -^ 1 with 
if^gYiR) 
= 
F(R)=>9''iR) 
= {{a, a') I V(6, b') G fP{R). (a • 6, a' • 6') € gP{R)}. 
This is the pointwise exponent of PERs. On relations we take 
if^gy^giA) 
= {([a],[a'])|V([6],[6'])G/^^-(i). 
i[a-b],[a'-b'])eg'-^g{A)}. 

480 
Chapter 8: Polymorphic type theory 
We leave it to the reader to verify that these products fxg and exponents / => 
g satisfy "identity extension", and that the associated (pointwise) projection, 
tupleing, evaluation and abstraction operations satisfy "abstraction". 
For products Y[ we define for an object /: n + 1 —>• 1 over n + 1 an object 
J^(/): n —^ 1 over n by 
n(/)''(^) = {{a,a')\yU,V 
ePER.'iB 
CN/U 
xN/V. 
a e \F{R, U)\ and a' € \fP(R, V)\ and 
YiifYR,si^) = {(Hn(/)^(fi)'f'''5n(/)''(5)i 
W, V G PER.VB C E/U x N/V. 
We need to prove "identity extension" for this product HI/)' ^'^- ^^ need to 
show that for R G PER" 
{{[a], [a]) I a G i n ( / r ( ^ ) l } = n ( / ) ^ , ^ ( E ^ ) . 
(C) If a G I n(/)^(^)h then for each relation B C N/U x N/V on PERs 
U^Vwe have ([a], [a]) G /[^ ^^ (^^)(Eq(i^.| B) by definition of n ( / F ( ^ ) . 
(D) If the pair of classes {[a], [a']) is in the relation on the right hand side, 
then, as special case, for each U G PER we have 
( H J a l ) G /[^,^),(^_t;)(Eq(^-Eq(f/)) = 
Eqif(R,U)), 
the latter by identity extension for /. Thus [a] = [a'], and the pair ([a], [a']) 
of equal classes is in the equality relation on the left hand side. 
The adjoint correspondences between maps g —> Ylif) ^^^^ ^ ^^^ maps 
^*(^) ~^ f over n -\- 1 are as usual. 
D 
Relational parametricity in the sense of Reynolds [286] means the following. 
Consider a term M: Ua: Type. a{a) inhabiting a polymorphic product type. A 
reasonable condition to expect of such an M is that it acts uniformly on types 
in the sense that it maps related types to related types. Specifically, if we 
have a relation r C r x p between types r and />, then the terms Mr: cr[r/a] 
and Mp: cr[/>/a] should be in the relation a[r/a] C cr[r/a] x a[p/a]. The latter 
relation cr[r/a] is defined by induction on the structure of cr, using appropriate 
operations on relations (discussed as operations on "logical relations" on a 
category Rel(E) in Section 9.2, see Example 9.2.5 (ii)). 

Section 8.4-' Fibrations for polymorphic type theory 
481 
PFam(PER) 
But this is precisely what happens in the fibration 
i 
of para-
metric families of PERs, since a type's interpretation carries this action on 
relations along: if cr(a) is an object / = (/^, / ^ ) : 1 —> 1 over 1, then for a term 
[n] G N / n ( / ) ^ inhabiting the polymorphic product H I / ) - ^ ~^ 1' ^^ have by 
definition of H I / ) ' for types U,V e PER with a relation B C N/U x N/V, 
instantiation at U and at V, 
[n]fp{U) e n/r{U) 
and 
[n]j,^v^ E N / / ^ ( y ) 
yields two terms which are related by fuyiB) 
C n/fP{U) 
x 
N/fP{V), 
i.e. which satisfy (M/p(c/)5 M/p(V)) ^ fu vi^)- 
The latter is the type's action 
on the relation B. Hence Reynolds' parametricity holds by construction in 
this model of parametric families of PERs. 
Towards the end of the next section we give a more formal description of 
the parametricity in this model. Consequences of parametricity may be found 
in Exercises 8.4.5 and 8.4.6. 
Other 
examples 
8.4.11. Preorder models. Any (split) higher order fibration is a (split) 
Aa;=-fibration. In this way one gets preorder models (where all fibre categories 
are preorders) in which all structure of terms M:a'm 
types a is destroyed. In a 
propositions-as-types view these are 'proof-irrelevant' or 'truth-value' models. 
In particular, examples include, 
(1) the subobject fibration of a topos; 
(2) the fibration of regular subobjects of cj-Sets. 
Fam(n) 
(3) the family 
fibration 
4- 
for Q a frame [i.e. a complete Hey ting 
algebra). 
UFam(PN) 
(4) the realisability 
fibration 
X 
. In fact, any realisability 
fibration 
Sets 
UFam(A) 
i 
coming from a PCA A, as in Example 5.3.4. 
Sets 
8.4.12. Term models. Let (S, (Sa)) be a polymorphic signature. The poly-
C£(S,(Sa)) 
morphic 
fibration 
4- 
described in Example 8.4.2 can be upgraded to a 
X—^/\2/Xu) 
fibration 
by incorporating the structure of these type theories— 
and taking appropriate equivalence classes of terms as morphisms. For the 
categorical products f| and coproducts JJ one uses the mate formulations of 
V and 3 in Exercise 8.1.3. We shall describe equality in some detail. The left 
adjoint to the diagonal S: A x B -)- {A x B) x B m Cf(E) is given by 
{a:A,f3:B 
\- a'.Jype) 
^ {a:AJ: 
B, fi': B \-a x EqB(/^,/30-Type). 

482 
Chapter 8: Polymorphic type theory 
The required adjunction involves a correspondence between 
(equivalence 
classes of) terms M and N in 
a:AJ:B,(i':B\x:(T,y:EciB[P.P') 
y-M:T 
=====^=====================^^ 
(Eq-mate) 
a:A,/3:B\x:a 
h AT: r[/?//?'] 
It is given by 
M •-> M[p/(3', XB{P)ly] 
and 
N ^ N with /?' = /? via y. 
A model of one of these type theories in a specific fibration can then con-
veniently be described as a morphism of suitable fibrations with this syntac-
tically constructed "classifying fibration" as domain and the specific fibration 
as codomain. This functorial semantics is as described in more detail in earlier 
chapters for simple type theory, equational logic and (higher order) predicate 
logic. 
8.4.13. D o m a i n theoretic models. There are models of the second order 
A-calculus A2 (with at least polymorphic products) which use Scott domains 
(see [57] or [108, 61]) or coherence spaces (see [96] or [98]) or algebraic complete 
lattices (see [56] or [61]). The constructions are somewhat similar, in the sense 
that they rely on embedding-projections (in order to circumvent problems 
with contravariance of exponent types). We shall describe these embedding-
projections in Section 10.6 for a model of dependent type theory. In [277] 
a model of A2 is obtained as a solution of a big domain equation capturing 
BMM-models as described in set theoretic terms in [38]. 
Fam(Clos) 
Towards the end of Section 10.6 there is also the 
fibration 
4- 
of 
Clos 
closures indexed by closures (as originally described in [302]). It is a small 
Aa;-fibration (see also Exercise 10.6.3 there). 
Exercises 
8.4.1. 
Be very naive (as in the previous section) and assume a set of sets U closed 
under products and sums Ilf, E/, with U_ M- Sets as associated full subcat-
Fam(iY) 
egory. Show that 
i 
is a Acj-fibration. What does it taike to interpret 
Sets 
equality types as well? 
8.4.2. 
(i) 
Give the precise interpretation for 11 and D in a Aa;-fibration and es-
tablish the validity of the cissociated conversions, 
(ii) Do the same for equcdity in a Au;=-fibration (using the interpretation 
as described after Definition 8.4.4). 
(iii) Check that the interpretation for II in the Aa;-fibration in the previous 
exercise, coincides with the set theoretic interpretation given in the 
last section. 

Section 8.4'- Fibrations for polymorphic type theory 
483 
8.4.3. 
Since P E R is a small category, it is internal in Sets. Check that the fibra-
UFam(PER) 
tion 
i 
of families of PERs over sets is not the externcdisation of 
CJ-Sets 
this internal category. 
8.4.4. 
Define two parallel maps u,v: I =t J in the base category of a (not nec-
essarily preordered) fibration with equality Eq to be internally equal if 
there is a vertical map 1(7) -^ Eq(t(, v) from the terminal object 1(7) over 
7 to the object Eq(w, v) as in Notation 3.4.2. Check that in the above three 
PER-models internal and external equality coincide. 
PFam(PER) 
8.4.5. 
(i) Consider the 
fibration 
i 
of parametric families of PERs. The 
^ ^ 
P P E R 
^ 
definable coproducts -hd from Exercise 8.1.5, is given in this situation 
on objects f^g.n i4 1 over n as 
(/+d3r(H) 
= {{a,a')|Vt/,V€PER.VSCN/t/xN/V. 
a e lifiR) 
-^U)x 
{gP{R) ^ U) ^ U\ 
and a' € !(/"(«) ^ V) x (gP{R) =^ V) ^ V\ 
and ([a],[a']) € (Eq(r(R)) 
^ B) x (Eqig^iR)) 
^ B) ^ 
B}. 
Prove that -hd is the ordinary (fibred) coproduct using parametricity. 
[Hint, Use graph relations of appropriate maps, and prove first that 
[K, K'] = id: / -f d 5 -> / +d 9'] 
(ii) Show also that the definable product Xd from Exercise 8.1.5 is the 
ordinary product in this fibration. 
[In parametric models the second order definable operations in Exer-
cise 8.1.5 have the appropriate (non-weak) universal properties; similarly, 
the weakly initial algebras and weakly terminal co-algebras from Theo-
rem 8.2.2 become properly initial/terminal, see [118, 273, 11]. In the ordi-
nary PER-model of uniform families the weakly initial algebras are shown 
to be initial in [149].] 
8.4.6. 
Let !E!,X:Type h cr(X):Type be a type built up with finite products and 
coproducts, as in Lemma 8.2.1, and consider its interpretation [[cr(X)]|: n-f-
PFam(PER) 
1 -^ 1 as object over n -\- 1 in the 
fibration 
i 
of parametric 
PPER 
families of PERs. 
(i) 
Describe the corresponding endofunctor between fibres 
I^[-/X]l:PFam(PER)n —> PFam(PER)n 
following Lemma 8.2.1. 
(ii) For a morphism y:g-^hin 
the fibre PFam(PER)n define the graph 
relation Q{j) C g x h SLS 
Qit)n = {(W.TA(W)) I« € Ig'iR)} Q H ^ f l ) x N/h^{R). 

484 
Chapter 8: Polymorphic type theory 
Prove by induction on the structure of a that 
(iii) Assume now two types E;,X:Type h (7i(X), cr2(X): Type as above. 
Show that every inhabitant (3 of [HX: Type. cri(X) -> (T2(X)]| satis-
fies the following naturality condition: for each 'yig ^ h the following 
diagram commutes 
a,[g/X] 
^<T2[g/X] 
^ib/X] 
(T2b/X] 
CTi[h/X] 
^ a2[h/X] 
when interpreted in the fibration of parametric families of PERs. 
[Such naturality properties stemming from parametricity are described 
in [340]. More generally, "dinaturality" conditions (which arise from nega-
tive occurrences of X) may be found in [11].] 
8.4.7. 
Let C be a CCC. We form the category NP(C)—where 'N' stands for neg-
ative and 'P' for positive—as follows. Objects are natural numbers n G N. 
Morphisms (Fi,..., Fm)'- n —^ m are given by functors Ft'. (C°^)" x C" -> 
C. Especially, we have projections proj^in —)• 1 described by {X,Y) 
^ Yt 
and {f,g) 
^ 
g^. Given F:n ^ 
1, i.e. F:(C°P)" x C" -^ C, we write 
^tw.^(^p^n X C" ^ 
C P for the 'twisted' version of F obtained as the 
composite of 
( C ? P ) " X C " ^ (([;opop)n ^ (([X^p^n ^ ((([;op^n ^ Qi ^op 
^ 
^p 
Now one can define composition in NP(C) by ( d , . . . , G^) o (Fi,..., Fm) = 
{Hi,..., 
Hk), where H^ = G^ o {FI"^ ,..., F^, Fi,..., 
Fm). Notice that 
idn = (proji,..., projn). In this way one obtains a category NP(C). It has 
finite products: 0 is terminal and n -{- m is the products of n and m. For 
arrows F,G:n —)• 1, we put 
FxG 
= prodo(F,G): (C^P)" x Q" 
_ ^ C x C — > C 
F^G 
= exp o (F^^, G): (C^P)" X e 
—> C ^ x C —> C 
Next we define an indexed category ^: NP(C)°P —)• Cat by giving the fibre 
categories ^(n) morphisms F: n -^ 1 in NP(C) as objects. Morphisms F —)• 
G in ^{n) are families a = {(^x))^e€,^ °^ arrows a^:F{X,X) 
-^ 
G{X,X) 
in C There is no dinaturality requirement for such families. Show that 
applying the Grothendieck construction to ^:NP(C)°P -> Cat yields a 
(split) A—)-category. 
[This construction comes from [154, Section 3.3]; it is based on [11]. Also 
in [154] one finds how a restriction on the above F's and cr's yields the free 

Section 8.5: Small polymorphic 
fibrations 
485 
A-^-fibration generated by C And in [99] it is shown that the interpreta-
tions of terms in this model are dinatural transformations.] 
8.5 Small polymorphic fibrations 
We recall that a polymorphic A ^ - , A2- or Au;-fibration is called small if it 
arises via externalisation from an internal category in its base category. In 
this section we shall investigate how a polymorphic fibration can be turned 
into a small one. We describe two ways of doing so. The first internalisation 
is based on the "standard construction" as described in Proposition 7.3.12: 
a fibration i (which is split and satisfies suitable size conditions) yields an 
internal category in the topos of presheaves B = Sets® 
. This standard con-
struction is applied to polymorphic fibrations (actually indexed categories) 
in [8]. The second construction is from [268]. It yields for a polymorphic fibra-
tion I a full internal category in the total category E. Moreover, if we move 
this internal category via the Yoneda embedding to the topos of presheaves 
E = Sets^ 
then we again have a full internal category, but this time in a 
topos. Below we shall show that this second step (the move from E to E) is in 
fact an application of the standard construction. What is emphasised in [268] 
is that his construction turns a polymorphic fibration into a small one in a 
suitably rich ambient category (a topos) where the induced internal category 
has its Cartesian closed structure and products as in this ambient category. 
This facilitates reasoning about such structures. 
We shall assume in this section that all polymorphic fibrations (with all 
their structure) are split. Further, we shall write Cartesian closed structure in 
fibres of a fibration with symbols T, A, 3 for finite products and exponents. 
This is not to suggest that we have preordered fibres, but in order to be 
able to use different notation for the induced structure (see below) on the 
total category of the fibration. Such structure in total categories is studied 
systematically in Section 9.2. 
We start with the standard construction for internalisation (as in Propo-
sition 7.3.12). It is repeated in (i) below. The second additional point comes 
from [8]. 
E 
8.5.1. Theorem. Let 
^P be a split fibration 
where the base category B is 
locally small and all fibre categories E/ are small. 
(i) [Internalisation as in Proposition 7.3.12] There is an internal 
category 

486 
Chapter 8: Polymorphic type theory 
P m B = Sets® 
with a change-of-base situation: 
' j 
E 
^ 
^ Fam(P) 
where y (for Yoneda) and % are full and faithful functors. 
E 
Fam(P) 
(ii) // ^P is a A-^- or X2-fibration, then so is the externalisation 
i 
, 
^ 
1 
and the morphism of fibrations {y,7i) in (i) preserves this structure. 
(The abovementioned size conditions can be ignored if one is willing to 
replace Sets by a suitably larger category of classes.) 
Proof, (i) The presheaves PQ and Pi of objects and of morphisms of the 
internal category P = (Pi —\ PQ) in B are, on objects, respectively, 
/H^ObjE/ 
and 
/ H^ 
U 
E / ( x , y ) . 
x,yeE7 
See the proof of Proposition 7.3.12 for further details. 
Fam(P) 
(ii) The fibred Cartesian closed structure of 
i 
is defined pointwise 
B 
^ 
using the structure in the fibres of p. For example, in the fibre over P G B 
the product of objects a, (3: P =^ PQ is given by [a x P)i{a) — a/(a) x Pi{a), 
where / E B and a G P(/). 
Next we notice that the split generic object 1} G B of p—with isomorphisms 
B(/, 1}) = Obj E/—makes the presheaf PQ of objects represent able. Hence we 
can identify the exponent presheaf PQ ° at / G B as 
Po^°(/) ^ B{y{I) 
X y{Q), y{Q)) 
see exponents in Example 5.4.2 
because y preserves products 
^ B ( / X Q, 
fi) 
since y is full and faithful 
= ObjE/xn 
because Q is split generic object. 
Hence the object parts of the required internal product and coproduct functors 
rio' IJo- ^0 ° ^ ^0 ^^^ t>^ described via functions Obj E/xn =^ Obj E/ sending 
X H^ ri/l^) ^^^ ^ ^ 11/(^)' where H/'LJ/ ^^^ ^^^ right and left adjoint 
to the weakening functor TT* induced b y 7 r : / x Q - > Q . 
D 
Notice that we explicitly use representability of the object presheaf in order 
to obtain polymorphic products and coproducts. The argument extends to 

Section 8.5: Small polymorphic fihrations 
487 
arbitrary representable presheaves (see Exercise 8.5.1 below), but it is not clear 
how to obtain quantification with respect to non-representable presheaves, so 
that the result can be extended to Acj-fibrations. 
We turn to the internalisation of [268]. We shall present it in different 
form, using "simple fibrations over a fibration". 
These generalise "simple 
fibrations over categories" as in Section 1.3, see Exercise 8.5.3. But first, we 
need the following result, which shows how fibred ("local") finite products and 
exponents induce ("global") finite products and exponents in total categories. 
A more complete account of the interaction between local and global structure 
occurs in Section 9.2 in the next chapter, and in [125, 127]. 
E 
8.5.2. L e m m a , (i) Let 
jrP be a fibration 
with finite products 
(1, x) in its 
base category, and fibred finite products (T, A) in its fibre categories. 
The total 
category E then has finite products: 
• the terminal 
object T E Ei in the fibre over the terminal 
object 1 E M is 
terminal 
in E 
• the Cartesian product in IE of X G E/ and Y E Ej is the object X x Y == 
7r*(X) A 7r'*(y) in the fibre over / x J E B. 
(ii) If p additionally 
has fibred exponents 
D and simple products 
Y[(i j)> 
then the category E is Cartesian 
closed. The exponent of X E E/ and Y E E j 
is the object 
in the fibre over / => J E B, where TT and ev in this expression 
are the 
projection 
and evaluation 
maps ( 7 = > J ) <—(/=> J) x I ^ 
J. 
Proof, (i) Reasoning in the total category E will be reduced to reasoning in 
fibre categories by Lemma 1.4.10. For Z E E over K E B one has in E, 
E(Z, X XY) 
^ 
U 
^^ (^' ^*(^ ^ ^)) 
u.K-^IxJ 
^ 
H 
EK {Z, (TT O uYiX) A (TT' O uYiY)) 
u:K-)-IxJ 
s 
n 
]J 
EK(z,v*{x)^w*iY)) 
= 
]1^K(Z,V*{X)) 
X \[ 
¥.K(Z,W*{Y)) 
v:K-yI 
w:K-yJ 
s E{Z, X) X E(Z, 
Y). 

488 
Chapter 8: Polymorphic type theory 
(ii) We similarly compute, again for ^ G E above K G IB, 
E(Z, X 
^Y) 
S 
] J 
EK{z,u*Uii^j,i)i^*(X)Dev'{Y))) 
S 
J J 
E;, (Z, Y\iK,i){^ X id)*(7r'*(X) D ev*(y))) 
u:iC-^.(/=>J) 
S 
JJ 
EK (^, 0(^^,7)C'^"!^) D (ev o « X id)*(Y))) 
= 
n 
EKx/(7r*(^), ^'*(X)Dt;*(y)) 
= 
U 
%x/(7r*(^)A^'*(X), ^;*(y)) 
^ 
E ( Z X X , y ) . 
D 
Notice that, by construction, the functor p:E ^ IB strictly preserves these 
finite products and exponents in E. 
E 
8.5.3. Definition. Let 
^ 
be a fibration with fibred Cartesian products A. 
We write Sp(E) for the category with 
objects 
pairs X, X' G E in the same fibre. 
morphisms 
(X, X') -^ (y, Y') are pairs of morphisms f: X ^ Y and 
f':X 
/\X' 
-^ Y' in E over the same map in IB, i.e. with 
p ( / ) = p ( / ' ) -
There is then a projection functor Sp(E) —>• E, namely {X^X') 
H-> X, which 
will be written as Sp. It will turn out to be a fibration, which we call the 
simple fibration on p. 
The identity morphism on [X,X') 
G Sp(E) is the pair (id, TT') consisting of 
the identity X -^ X together with the (horizontal) projection X /\ X' -^ X'. 
The composite of 
ix,x') ^^'^'^ . (y,r) 
^''''^ . iz,z') 
is given by the pair of maps 
X — ^ y — ^ z, 
X AX' 
^ y A y — ^ 
z 
where the map (/ o TT, f) arises as follows. Write u — p{f) = p{f) 
in B and 
consider the vertical parts X AX' -^ ^*(^) of / o TT and X AX' ^ u*{Y') of 

Section 8.5: Small polymorphic 
fibrations 
489 
/'. Tupleing these in the fibre yields a map X /\ X' -> u*{Y) A u*{Y'). And 
using that substitution preserves products A, we get (/ o n, /') as composite 
X AX' 
I 
u*{Y)Au*{Y') 
= \ 
u*{Y A Y') 
^ Y AY' 
It is by construction the unique map over u with TT o (/ o TT, /') = / o ;r and 
7r'o{fon,f') 
= f'. 
Notice that applying the definition to the trivial fibration ^ yields the 
s(l) 
simple fibration i 
on B from Section 1.3, for IB with Cartesian products. 
We thus have a (fibred) generalisation of our earlier "simple" construction for 
(ordinary) categories. 
E 
8.5.4. Lemma. Let 
^P be a fibration with fibred finite products (T, A). 
Sp{E) 
(i) The above functor 
^^p is a fibration with fibred finite products. It is 
split (with split products) if p is split (with split products). 
(ii) The original fibration p can be recovered from the simple fibration Sp 
via change-of'base along the terminal object functor T as in: 
Sp(E) 
(iii) 
i 
is a (split) fibred CCC if and only if ^ is a (split) fibred CCC. 
(iv) There is a full and faithful fibred functor Sp (E) -^ E"*" given by 
( XAX' 
\ 
{X,X^)^{ 
^^ j . 
It preserves the above fibred CCC-structure. 
Proof, (i) Reindexing along a morphism /: X —> y in E above u: I -^ J in 
B takes the form 
iY,Y')^{X,u*{Y')) 

490 
Chapter 8: Polymorphic type theory 
with as Cartesian lifting (X, u'iY')) 
-> (7, Y') the pair /: X -> Y and u[Y') o 
'K'-.X 
^u^{Y')^u*{Y')-^Y', 
In the fibre of Sp (E) over X G E one has as terminal object and Cartesian 
product: 
(X, T[pX)) 
and 
(X, X') A (X, X") = (X, X' A X"). 
(ii) For / G B the objects in Sp(E) over T(/) G E are the objects in E 
over /. And for u: I -)- J in B the morphisms in Sp(E) over T{u) are the 
maps T(/) A X -> y in E over w, which can be identified with the morphisms 
X -^ y in E over u. 
(iii) Given fibred exponents D in p, one defines fibred exponents in Sp(E) 
by 
(X,X')D(X,X") = ( ^ , X ' D X ' ' ) . 
The converse is easy by the change-of-base situation in (ii). 
(iv) Easy. 
• 
E 
8.5.5. Theorem, (i) // ^P is a split X—^'fibration, then the simple fibration 
Sp(E) 
^^p on p is a full small X—^-fibration: there is a full internal category C in 
E whose externalisation is this simple fibration. 
Sp(E) 
IE 
(ii) And 
i 
is a split A2- (or XLO-) fibration if and only if 4- is a split 
A2- (or X(jj-) fibration. 
Proof, (i) Let ^2 G B be split generic object for p with natural isomorphisms 
^/:B(/,fi) ^ ObjE/. Write T = 6>n(id) G Eo and Co = TQ G lEn for the 
terminal object in the fibre above fi. We are going to form the full internal 
category Full(a) in E that comes from the (vertical) map in E 
as in Example 7.1.4 (ii). Therefore we need the following two observations. 
(a) For each morphism /: X —>• TQ in E, say over w: / —> fi in B, we have 
a pullback square in E, 
u(T) o TT' 
X A u*{T) 
^ T 
J 
X 
^ T Q 

Section 8.5: Small polymorphic 
fibrations 
491 
This is not hard to check. 
(b) The exponent n*(a) => T^'*(a) in the sHce category E/TQ x Tfi exists, 
namely as the (vertical) projection 
(TQxTfi)A(7r'(T)D7r'*(T)) 
TfixTQ 
(It is used as pair {do,di):Ci 
—> Co x Co in the Full(—)-construction in Ex-
ample 7.1.4 (ii).) Indeed, for a family {f,g):X 
—>• T12 x TQ in E we have 
E/TfixTO((/,5)x7r*(a), 
n"(a)) 
^ E/x({f,griT*{a), 
{f,grn'*{a)) 
since {f,g) x 7r*(a) S 
U{f,g}{f'9r^*(a) 
/XA(pfriT) 
XA(pgr(T) 
= WX 
^'^ 
, 
^'^ 
1 
by (a) 
- lE^x{XA(pfnT), 
ipgriT)) 
S ^,x{x, 
{pf,pgr{7^*{T)Dir'*(T))) 
^ E(p;,p,)(x, 7r*(T)D7r'*(T)) 
/ 
(Tf2xTQ)A(7r*(T)D7r'*(T))\ 
^ E/rn.Tn \^if,g), 
^^i-^^ 
j . 
The latter projection thus behaves as exponent in the slice. 
Hence we have enough structure to form the full internal category Full(a). 
The object of its externalisation Fam(Full(a)) over X ElE are the maps X -^ 
Co = TQ in E. Because the terminal object functor T is right adjoint to p, 
these objects correspond to maps pX -^ Q in B, and hence to objects in Fpx — 
Sp{E)x because fi is generic object. Similarly, morphisms of Fam(Full(a)) over 
X correspond to morphisms of Sp (E) over X. 
(ii) Products Y[ and coproducts JJ for the simple fibration along the pro-
jections X X y —> X in E are obtained via the products Y[ and coproducts ]J 
along the projections pX x pY -^ pX in B and via products and exponents 
in the fibres: 
n(x,YMxY,Z) 
= (X,n(px.py)('^'*(>')3^)) 
Uix.vM xY,Z) = 
{X,Ui,x,pY)i^'*iy)^Z)). 

492 
Chapter 8: Polymorphic type theory 
Then 
S,{¥)X>.Y(^*{X,W), 
{XXY,Z)) 
= 
¥^X^PY({XXY)M:'[W), 
Z) 
= EpXxpYi7^*{X)A7r'*(Y)Mr*{W), 
z) 
= EpXxpY{7r*(XAW), 
IT"(Y)DZ) 
S 
F,x{XAW,UipX,pY)i^'*(Y)DZ)) 
= 
Sp{E)x{{X,W),Uix.YMxy'Z)). 
And similarly for ]J/jj^ y)- Exponents in E exist by Lemma 8.5.2 (ii). 
• 
The full internal category C in this theorem has its fibred CCC-structure 
and products Y[ as in its ambient category E. The next step is to form a full in-
ternal category in a richer ambient category, namely in the topos E = Sets^°^ 
of presheaves on the total category E of our fibration. In principle there are 
two constructions: apply the standard construction from Theorem 8.5.1 to the 
simple 
fibration 
i 
, or apply the Full(—) construction in E to the image 
y{a) of the Yoneda functor 3^ applied the map a = ( _f 
) which gives the 
earlier full internal category C in E. It turns out that these two constructions 
coincide. The outcome is the main result of [268]. There, only the second con-
structions is described, and it is not explicit that there is an application of the 
standard construction involved via the mediating role played by the simple 
fibration in the previous theorem. 
In the proof below we need the following technicality. 
8.5.6. Lemma. Yoneda functors y:C ^ Sets^°^ preserve finite limits and 
exponents in slice categories. 
• 
Preservation of finite limits is standard (and easy). For the proof that also 
exponents in slices are preserved we refer to [268]. 
E 
8.5.7. Theorem (Pitts [268]). Every split X-)- (or X2-) fibration iP gives 
rise to a full internal category P in the topos of presheaves E = Sets^ , 
whose externalisation is again a A ^ - (or \2-) fibration with its structure as 
in the ambient category E. Moreover, there is a change-of-base situation 
E 
^ Fam(P) 
I J 
I 
P\ 
^ 
T 
y 
I 
B 
^ E 
^ E 

Section 8.5: Small polymorphic 
fihrations 
493 
so that the fibration p can be recovered from the internal category P in E. 
(There are also some size restrictions in this theorem, analogous to those 
in Theorem 8.5.1.) 
Proof. We show that the full internal category D = {Di 
^ DQ) in E arising 
from the family 
is the same as the outcome P = (Pi —] PQ) of applying the standard con-
struction from Theorem 8.5.1 to the simple fibration Sp. For X G E we have, 
according to the definition of the object PQ of objects of P in the proof of 
Theorem 8.5.1 (i): 
PoiX) 
= Objs(E)x 
= ObjEpx 
s m{px, n) 
S E{X, 
TQ) 
= 
y{Tn){x) 
= 
Do(X). 
And 
Pi(X) = 
Jl 
s(E)x {Y,Z) 
Y,Zes(E)x 
a 
J J 
Epx{XAu*(T),v*(T)) 
S 
] J 
E(„,„)(X, 7r*(T)D7r'*(T)) 
u,v:pX^ft 
^ E{X, 
( T O X TQ) A (7r*(T) D 7r'*(r))) 
= ^^(domainof 7r*(a) =>7r'*(a))(X) 
S (domain of 7r'3^(a) ^ 7T'*y{a)){X) 
by Lemma 8.5.6 
= Di(X). 
D 
Recall that in a polymorphic fibration we require the presence of a generic 
object, but such an object need not come from an internal category—uniform 
families of PERs over Sets in Corollary 8.4.6 form an example where this is 
not the case. Having a small polymorphic fibration gives something extra, and 
this 'something' will be characterised later as: for a A->-fibration p there are 

494 
Chapter 8: Polymorphic type theory 
equivalences 
9 5 6 
p is small 
<=> 
p is "locally small" 
•<==> p is a "comprehension category with unit" 
The latter structures are used for dependent type theory. Thus, in such small 
polymorphic fibrations there is more structure than strictly needed for mod-
elling polymorphic type theory. 
Exercises 
E 
8.5.1. 
Consider the intemcJisation P in B of a 
fibration 
jP 
as in Theo-
rem 8.5.1 (i). Let i? C B be the collection of representable presheaves 
B( —, /). Extend the description of (co)products fj, ]J[ in the proof of The-
orem 8.5.1 (ii) in the following way: p has simple (co)products '^ the ex-
ternaJisation of P has simple (co)products with respect to the CT-structure 
(B, R). (What the latter means is in Definition 2.4.3.) 
8.5.2. 
Prove that the induced product functor x:E x E -^ E in Lemma 8.5.2 (i) 
is a fibred functor (over x:B x B ^ B). 
8.5.3. 
(i) 
Let B be a category with Cartesian products x. Show that the functor 
{X, X') H> (X, X X X') forms a comonad B x B -> B x B, and that its 
s(l) 
Kleisli category is the total category s(B) of the simple fibration 4-
IB 
onB. 
E 
(ii) Let 
^P be a fibration with fibred Cartesian products A. Prove that 
B 
the assignment {X,X') 
M- {X,X 
A X') now yields a fibred comonad 
p X p ^ p X p (over B), and that its (fibred) Kleisli category (see 
Sp(E) 
Exercise 1.7.9) is the total category Sp(E) of the simple fibration 4-
on p. 
8.5.4. 
Consider the full internal category C from Theorem 8.5.5 in the total cat-
E 
egory E of a A ->-fibration 
-jrP . 
(i) 
Show that the object C2 of composable tuples of morphisms of C can 
be described as 
C2 = (TQ xTQx 
TQ) A (;r*(T) D n*{T)) A (7r'*(T) D n"*{T)). 
(ii) Give a similar description of the object C3 of composable triples in C. 
8.5.5. 
Prove that the functor Sp(E) —^ E"^ from Lemma 8.5.4 (iv) also preserves 
simple products f|. 

Section 8.6: Logic over polymorphic type theory 
495 
8.6 Logic over polymorphic 
type 
theory 
In the three chapters 3, 4 and 5 on equational logic, and on first and higher 
order predicate logic, we have considered logics in which one can reason about 
terms in simple type theory (STT). Semantically this involved putting a (pre-
order) fibration •[ on the base category B incorporating the simple type the-
ory. An obvious next step at this stage is to consider logics over polymorphic 
type theory (PTT). Semantically, this will again involve putting a (preorder) 
fibration on top of a model of PTT, but it turns out that there are several 
ways of doing so, depending on whether one wishes to reason about terms 
inhabiting kinds vliKind, or about terms inhabiting types cr: Type (or even 
about both at the same time). In this section we briefly discuss some aspects 
of "logic over PTT". Such a logic may be called polymorphic predicate 
logic (PPL), in contrast to simple predicate logic SPL, as studied so far. The 
approach in this section is sketchy because 
• PPL is not so very well-known in the literature, but there are exceptions, 
like [273, 326, 120]; 
• some of the relevant techniques—like fibrations over a fibration, and general 
forms of quantification—will be developed only in the next chapter. 
Towards the end of this section we will describe how PPL may be used 
to give an abstract formulation (following [204, 293]) of what makes a 
A2-fibration relationally parametric. 
Logic of kinds 
E 
To start, consider a polymorphic A—>-, A2- or Acj-fibration i . The objects of 
IB 
the base category B are considered as kinds A\ Kind, and the objects of the 
total category E over A as types (jiType in context A, written formally as 
a: A \- a(a): Type. 
We first investigate what it means to put a logic on B, say via a (preorder) 
fibration i . This would add a new syntactic category Prop, with inhabitants 
IB 
a: A \~ (p{a): Prop depending on kinds A: Kind. These propositions are objects 
in D over A: Kind in B. They allow us to reason about inhabitants of kinds, 
and especially, since Type: Kind, about types. 
For example, one may have a logic of subtyping propositions (like in [263, 
161]) in this way, with propositions 
a: Type, (3: Type h a <: /?: Prop 
as objects of the category D. With these, one can consider entailments between 

496 
Chapter 8: Polymorphic type theory 
propositions, like 
a, a',/?,/?': Type | a <:a\(5<:(i' 
h a'-^/? <: a->/?' 
expressing the usual contra- and co-variance of exponent types with respect 
to the subtyping <: relation. Semantically, such entailments h are to be con-
p 
sidered as morphisms < in a fibre of ;^ , see Exercise 8.6.1 below for a PER 
IB 
model of such a logic of subtyping. 
To mention a concrete example, consider the fibrations over a;-Sets 
RegSub(a;-Sets) 
UFam(PER) 
u;-Sets 
The (higher order) fibration of regular subobject in cj-Sets on the left hand 
side gives us a powerful (classical) logic to reason about a;-sets, as kinds for 
U F a m ( P E R ) 
the Acj-fibration 
i 
of a;-set-indexed families of PERs on the right 
.CJ-Sets 
hand side. In this situation we have a logic of kinds. 
Logic of types 
E 
We return to the general situation with a polymorphic fibration i and 
0) 
consider—as alternative—what it means to put a (preorder) fibration 4- on 
top of the total category E of types. Again we may see this as adding a new 
syntactic category Prop of propositions, but this time inhabitants <^: Prop de-
pend both on (variables in) kinds and on (variables in) types, as in 
ai:Ai,...,an:An\xi:ai,...,Xm''0'm 
^ (p{a,x): Prop. 
These propositions should be considered as objects of D. And we may have 
entailments 
ai:Ai,...,a„:A„ | XI:(TI, ... ^Xm-o-m \(fi,...,(fk 
^ i^ 
in which we have to deal with three separate contexts: for kinds, types and 
propositions, corresponding to objects in the three categories B f- E f- D 
that we have. These entailments are morphisms < in a fibre of P (over E). 
For such a logic of types one expects the usual propositional connectives 
±, V, T, A, D. Interestingly, one can have quantification Sx'.a.if and Vx: cr. <^ 
over types, but also quantification 3a: A. (p and "ia'.A.ip over kinds—with 
the restriction that in first and second order PTT A = Type is the only 

Section 8.6: Logic over polymorphic type theory 
497 
kind. For the latter form of quantification over kinds one has to impose the 
restriction that the variable a cannot occur free in the types on which ^ 
depends. Formally in a formation rule: 
ai\ Ai,... 
,an\ An,a: A\ xi'.ai,... 
,Xm''(Tm h v?: Prop 
(a not free in a) 
Q;i:Ai,...,a„:yl„ | xi: (TI, ..., x^: cr^ h Va: A. v?: Prop 
P 
E 
Let us see what these logical operations mean in fibrations ^ and ^ of 
propositions-over-types, and of types-over-kinds. To illustrate this, we first 
syntactically construct a term model example of such a fibration. Let IK the 
category with kinds A: Kind as objects, and with terms a: A \- M{a):B 
as 
morphisms A -^ B. Next, let T over IK be the category with types a: A h 
a{a):Type as objects (over A), and with terms a: A \ x:a{a) h 
N(a,x):T{a) 
as morphisms cr -> r over A. Finally, let F over T be the category of 
propositions a: A \ x:a{a) 
h (p{a,x):Prop as objects, and with entailments 
a: A I x:a{a) 
\ (p{a,x) h ip{a,x) as morphisms (p -^ ip [or (f < ^J) over 
f 
T 
a. Then we have forgetful functors i and i which are split fibrations. For 
convenience we assume finite products (1, x) for kinds and for types. In this 
situation: 
• The propositional connectives _L,V,T,A,D correspond to fibred preorder 
r 
BiCCC structure for the fibration ^ of propositions over types. Applying 
these connectives to propositions does not change the contexts of types and 
kinds in which the propositions live. 
• Quantification 3y: r. (f and Vy: r. (f over types changes the type context by 
binding the variable y.r, but it leaves the kind context a: A unchanged. 
These quantifiers 3y: r. (—) and Vy: r. (—) are thus left and right adjoints to 
the weakening functors induced by the Cartesian projection morphism 
(a: A \- a X T: Type) 
^ (a: Aha: 
Type) 
between types, given by the (vertical) projection term 
a:A\z:aXT 
h nz: a 
or by 
a: ^ | x: cr,y:T h x: a. 
Explicitly, we then have "mate" correspondences 
a:A\x:a,y:T\ 
V^(a, x) h ip{a, x, y) 
a\A\x:(T\ 
^(a, x) h Vy: r. <^(a, x, y) 
a: A\x:a,y\T\ 
p{ot, x, y) h '0(a, x) 
a: A\x\a 
\ 3y: r. (f{a, x, y) h ^(a, x) 

498 
Chapter 8: Polymorphic type theory 
These correspondences are as in (simple) predicate logic over STT, except 
that they involve an extra level of indexing given by variables a: Am kinds. 
Categorically, this quantification over types in polymorphic predicate logic 
(PPL) is given by simple coproducts and products, as in first order predicate 
logic, but the relevant adjunctions are vertical with respect to the fibration 
T 
^1- of types over kinds, since the kind contexts are not affected. This will be 
K. 
made precise in Section 9.4. 
• Quantification 3/3: B. (p and V/?: B. (f over kinds B: Kind is more subtle. The 
f 
first thought is probably that it means that the composite fibration 4- of 
propositions over kinds has simple coproducts and products. This would 
give a functor 
(a: A, /?: J9 I x: a{a, /?) h v?(a, /?, x)\ Prop) 
^{a\A\ 
x:a{a,/3) h 3(3: B.(p{a, l3,x): Prop) 
which ignores the abovementioned restriction on the occurrence in type 
contexts of the variable jS that becomes bound. 
What really happens is that the projection morphism in K between kinds 
TT 
A X B 
>• A 
described as 
a: A^^.B 
\-a:A 
lifts to a Cartesian morphism TT in T, namely 
7r*(a:yl h cr(a):Type) 
>- (^a: A h o-(a):Type) 
{a:A,p:B 
h cr(a):Type) 
{a:A,P:B) 
^ 
[a:A) 
Then 3/?: B. [—) and V/?: B. (—) are left and right adjoint to the weakening 
_ . 
. 
^ 
. 
. 
. 
. 
_ 
. 
functor TT* induced in ^ by this lifted projection functor TT. This functor 
TT* maps 
(a: A I x\ cr(a) h V^(a, x): Prop) !-)• (a: A, /?: 5 | x: cr(a) h il;[a, x): Prop) 
by adding a dummy assumption /?: B. Quantification 3/?: B.[—) 
and 
V/?: B.{—) over kinds is then characterised by the "mate" rules 
a:A^^:B 
\ x:(T{a) \ <^(a,/3, ar) h ip{a,x) 
a:A\x: 
a{a) \ 3/3: B. (p{a, l3, x) h ^(a, x) 

Section 
8.6: Logic over polymorphic 
type theory 
499 
a: A^ f3: B \ x: cr(a) | '0(Qf, x) h ^(a, j3^ x) 
a: A\ x: cr[a) \ ^^[ci^ x) h V/?: B. (p[a^ /?, x) 
In this case we have "lifted simple" coproducts and products. A precise 
categorical description will follow in Section 9.3, involving an appropriate 
associated Beck-Chevalley condition (which regulates the proper distribu-
tion of substitution over 3/?: B. (p and V/?: B.(p). 
Of course, one can do a further step and generalise these preorder fibrations 
4; and i of propositions over types to proper, non-preordered fibrations. This 
naturally to type theories like AHOL [91, 154], or XLJL [276]. 
8.6.1. Example. Recall from Proposition 4.5.7 that one can do classical logic 
with PERs, using regular subobjects as predicates. And also that such a reg-
ular subobject of a PER R can be identified with a subset A C N/R of its 
quotient set. We organise these regular subobjects of (individual) PERs into 
families of subobjects of families of PERs over c<;-sets so that we get a model 
of a "logic over types" in PTT. Therefore we form a fibration 
UFamRegSub(PER) 
I 
UFam(PER) 
with as fibre over an (/, E')-indexed collection {Ri)i£i of PERs Ri: 
objects 
families of subsets [Ai C N/Ri). 
j . 
morphisms 
[Ai C N/Ri)-^j 
—> {Bi C M/Ri)-^j 
exist if and only if 
for each i E I there is an inclusion Aj C Bi. This fibre 
category is thus a poset. 
For a morphism (w,/): (i?,)jg/ —)• {Sj)j^j 
in UFam(PER) between families 
of PERs—i.e. for a morphism of u;-sets u:{I,E) 
—)• (J,E) and a uniformly 
tracked family / = [fi'-Ri —>• Su{i))i^i of morphisms of PERs—we get a 
substitution functor (i/,/)* which maps 
{Bj C m/Sj).^j 
^ 
{{[n]R, I fi{[n]n.) € 5„(,)} C N/i?,),g/-
We now have two fibrations 
UFamRegSub(PER) 
\ 
UFam(PER) 
\ 
u;-Sets 

500 
Chapter 8: Polymorphic type theory 
RegSub(PER) 
incorporating the fibration 
i 
, see Exercise 8.6.2. Each fibre of 
PER. 
UFamRegSub(PER) 
^ 
is a Boolean algebra, so that we have classical proposi-
UFam(PER) 
& 
' 
^ 
^ 
tional logic in this situation. Moreover, this fibration has simple products, 
along the vertical projections R x S -^ R over (/, E)—consisting of (uni-
formly tracked) families of PER-projections n = {ni: Ri x Si -> Ri)i^j. For 
[Bi C f^/Ri X N/Si)- 
J we use set-theoretic quantification to get products 
and coproducts along these projections: 
'is{B)i 
= {[n]R,\yme\Si\.{[n]R^,[m\s,) 
e Bi} C N/R^ 
3s{B)i 
= {[n]R,\3me\Sil([n]R^,[m]s^) 
e Bi} C N/i?,-. 
In a similar way we have "lifted simple" products and coproducts: for a 
projection map TT: (/, E) x (J, E) —>• (/, E) in the base category u;-Sets of 
kinds, we have a lifting TT in UFam(PER) at ii = (Ri)i^j over (/, E), which 
in its turn acts on predicates on R as 
r ((A- c N/i?.-),-e/) = (^.- ^ ^/Ri\a,j€J 
" (^' ^ ^/^')ia 
/ 
\ 
TT = (TT, id) 
{I, E) X (J, E) 
^ (/, E) 
It acts as weakening of kinds on predicates. Products and coproducts (of 
propositions over kinds) along this map TT are again essentially set-theoretic: 
for a predicate (^f j Cf^/Ri). 
j . j one takes 
V(j,E)(5) = n^^-'i ^ ^l^i 
^^^ 
3(j,j5)(5) - [JBi^j C 
n/Ri 
jeJ 
jeJ 
(where the intersection f] is fi/Ri if J =: 0). 
PFam(PER) 
In Section 8.4 we have seen the A2-fibration 
i 
of parametric fam-
P P E R 
^ 
ilies of PERs, and we have argued informally that it is relationally parametric 
in the sense of Reynolds. We now investigate whether we can express this 
parametricity more formally in a suitable logic over this fibration. This line 
of thought is followed in [273] where a logical system is formulated to express 
parametricity. In essence, the key requirement there is that equality should 
preserve polymorphic products. In [204, 293] there is a slightly more general 

Section 
8.6: Logic over polymorphic 
type 
theory 
501 
requirement involving a reflexive graphs • <—- • preserving appropriate struc-
ture, in which the arrow • i— • need not be the equality functor (as in [273]). 
We are going to explicitly construct such a reflexive graph for the fibration of 
parametric families of PERs. 
In fact we shall be slightly more general than [204, 293] in the sense that 
we formulate parametricity for A2-fibrations with respect to a "logic of types" 
over polymorphic type theory. In the approach below, this logic is a parameter, 
whereas in [204, 293] the standard logic of subobjects in a category is taken. 
We shall be using the logic of regular subobjects of PERs, as in the above 
example. 
E 
8.6.2. Definition (After [204, 293]). Let 
{P be a A2-fibration, provided 
with a logic over types, given by a preorder 
fibration 
^^ . We say that p 
is a relationally p a r a m e t r i c A2-fibration if there is another A2-fibration 
F 
jj^ and a "reflexive graph" of A2-fibrations: 
V. 
; r 
E 
iP 
where P Q ^ J = id = P i oX 
Vi 
in such a way that that the fibre category Fi over the terminal object in C is 
P 
the category of relations in the preorder fibration -j; on the fibre category Ei 
over the terminal object in 
change-of-base situation: 
Formally, this requirement is expressed by the 
El x E i 
PFam(PER) 
8.6.3. Proposition. The \2-fibration 
i 
of parametric families of 
PERs from Proposition 8.4-10 is relationally parametric (as formulated in the 
previous definition). 
PFamRegSub(PER) 
RFam(PER) 
Proof. We construct 
fibrations 
i 
and 
i 
Kivine; us 
PFam(PER) 
R P E R 
^ 
^ 
a logic over parametric families of PERs, and a A2-fibration in a reflexive 

502 
Chapter 8: Polymorphic type theory 
graph of A2-fibrations: 
RFam(PER) T ^ 
^ ^ PFam(PER) 
R P E R ^ 
PPER 
PFamRegSub(PER) 
The "logical" 
fibration 
i 
has in its total category: 
^ 
PFam(PER) 
^ 
^ 
objects 
pairs {A,f:n 
—^ 1) where / = {f^,f^) 
is a morphism in 
PPER—z.e. an object of PFam(PER) over n E PPER— 
and A is a family of predicates on / of the form: 
luorphisms 
{A,f:n 
—>• 1) —>• {B,g:m -> 1) are morphisms (h,a).f 
-^ 
g in UFam(PER) satisfying for R 6 PER" 
[a] eA^C 
N/fP(R) 
^ 
The fibre category PFam(PER)i over the terminal object 1 E PPER is 
the category PER of PERs. Thus the fibre category RFam(PER)i over the 
terminal object 1 G RPER must be the category RegRel(PER) of regular 
relations A C N/R x N/R\ 
obtained in the change-of-base situation: 
RegRel(PER) 
J 
PER X PER 
RegSub(PER) 
J 
-^PER ^ 
PFamRegSub(PER) 
—^ PFam(PER) 
RFam(PER) 
as required in Definition 8.6.2. Since the fibration 
i 
must be a 
R P E R . 
A2-fibration we know that the morphisms 1 -^ Q to the generic object fi in 
RPER must be regular relations on PERs. We thus define a category RPER 
with mappings between relations as morphisms. 
objects 
pairs of maps (n —> p 
codomain p G PPER. 
J' n') in PPER with common 

Section 8.6: Logic over polymorphic type theory 
503 
morphisms 
(n —> p <— n') —-> (m —> q <— m') are triples 
{h,h',(f) of sequences where 
h: n —> m 
and 
h': n 
m 
are morphisms in PPER, and where (f — [(pi,..., ^q) is a sequence of func-
tions (^j in the function space 
n 
n p(N//i'(^)xN//f(5))| 
=^ P(M/(5,- o h){R) X n/{g'^ o h')(S)). 
We leave it to the reader that this category has finite products: (0 -> 0 f- 0) 
is terminal object, and the product of (rz —>• p ^ n') and {m ^ q <r- m') 
is [n -^ m -^ p -\- q ^ n' •]- m'). As generic object we shall take the pair of 
identities (1 -)- 1 ^ 1). 
There are obvious projection functors PPER i— RPER —> PPER, 
namely nf-i(n -^ p 
H^ n'. But there is also a functor PPER —> 
RPER, namely 
{
/ i d 
id 
\ 
n H-> [n ^ n ^ n) 
\h: n ^ mj i-> [(/i, ^, h'^): (n ^ n I- n) —)• (m ^ m f- m)j 
where for j < n 
h'je n 
Yl 
P{n/RixN/Si) 
l<i<n 
P{N/hP.{R) X N/M(5)) 
as in Definition 8.4.8. We thus already have a reflexive graph RPER i—-
PPER between base categories. It is easy to see that these functors preserve 
finite products (and also the generic object). 
RFam(PER) 
r 
-, 
We turn to the 
fibration 
i 
. The objects over (n ^ p I- n^) 
R P E R 
are the morphisms [n -^ p i^ n') ^ 
(l 4 
1 1^ l) in PPER. These 
consist of triples {h:n -^ \,h':n' 
—)- 1,^), where for sequences R E PER", 
S e PER"' of PERs and Ai C N/ff{R) 
x N//;^(5) of relations, we have a 
relation <f^si^) 
^ ^/h^{^) 
x N//i'^(5). Morphisms [h.h^ip) -^ (Ar, Ar',^) in 
this fibre are pairs of maps 
a\ h 
k over n 
and 
':h' 
k' over n 

504 
Chapter 8: Polymorphic type theory 
in UFam(PER) for which we have for all R € PER", 5 € PER"' and 
Ai C niP(R) 
X N//;P(5) 
{oc^{[a]),a'.{[h])) G V^^^-li) C N//^^^) x N / F P ( 5 ) . 
Substitution along a morphism in R P E R is done by composition. It is not 
hard to see that these fibre categories are Cartesian closed (by seeing the 
objects as "logical relations", essentially using the constructions for the fi-
bred CCC-structure in the proof of Proposition 8.4.10), and that substitution 
functors preserve this CCC-structure. 
Products n ^^^ most interesting. Consider an object (/i,/i',^) over 
(n —> p i— 71 ) X (1 —> 1 i— Ij = (n -h 1 —> p-\- 1 <— n -h Ij 
so that ^^R^u),{sy)i^^ 
^) ^ N / / I P ( ^ , ^) xN//i'^(5, V) is a relation for R,U e 
P E R " + \ 5, F E PER"'+i and Ai C f^/ff{R, 
U) x N//;^(5, V), B C n/U x 
N/F. We have to produce an object V(/i, h', (p) over (n -> p f- n'). We define 
V(/i,h',<p) = iUihy.n -^ l,n{h'yn' 
^ 1,V(^)) 
where OC^)' HC^O ^^^ ^^ defined in the proof of Proposition 8.4.10, and V(v?) 
is 
W, V e PER. V5 C N/U X N/K 
RFam(PER) 
We leave it to the interested reader to check that this makes 
i 
R P E R 
a (split) A2-fibration. It remains to show that we have a reflexive graph 
RFam(PER) f=^ PFam(PER) over R P E R ^ 
P P E R preserving the 
A2-structure. There are obvious functors PFam(PER) i— RFam(PER) —y 
PFam(PER) namely h^\{h,h',(p) 
H-> h. And there is also a functor 
PFam(PER) —> RFam(PER) which maps 
I [f:n^l] 
^ 
[{fjjr):^n^n'}^n)-^{l^l^l)] 
[ 
a H^ (a, a). 
This functor is well-defined by the abstraction condition for morphisms in 
PFam(PER). It is not hard to check that it preserves the A2-structure as 
described in the proof of Proposition 8.4.10. 
• 

Section 
8.6: Logic over polymorphic 
type theory 
505 
RFam(PER) 
8.6.4. Remarks, (i) The A2-fibration 
i 
of relations on PERs de-
^ ^ 
RPER 
scribed in the above proof looks quite complicated, and possibly even ad hoc. 
But it follows in essence from a general construction in [293]. This construction 
applies to (suitably complete) small A2-fibrations, and yields an associated 
parametric A2-fibration. 
RFam(PER) 
(ii) The structure that makes 
i 
a A2-fibration may be called 
RPER 
.
.
. 
the "logical relations A2-structure". It is explicitly described in logical terms 
in [340, 273]. 
(iii) Earlier in this section we have put a fibration on top of the base cate-
gory of a polymorphic fibration to get a "logic on kinds", and we have put a 
fibration on top of the total category of a polymorphic fibration to obtain a 
"logic on types". The latter will turn out to be a fibration in the 2-category 
Fib(IB) of fibrations on the (fixed) base category B of the polymorphic fibra-
tion. What happens in the previous proof is that we have a logic of relations 
both on kinds and on types. Categorically it involves putting a fibration on 
PFam(PER) 
top of (the product with itself of the) polymorphic fibration 
i 
in 
PPER 
the 2-category Fib of fibrations over arbitrary bases, as in: 
RFam(PER) 
^ R P E R 
f PFam(PER) x PFam(PER) 
^ P P E R x P P E R 
Details about fibrations in 2-categories Fib(IB) and Fib of fibrations will be 
given in Section 9.4. 
(iv) It is not clear in what sense the functor PFam(PER) —>• RFam(PER) 
used in the proof may be seen as an equality functor (as used in [273]) within 
the logic given by the structure in (iii). 
(v) Essentially, all that we have done is describe one relationally parametric 
(PER-) model of second order PTT (in fibred form). We do not claim to have 
covered a substantial part of the theory on parametricity, and refer to the 
literature [286, 340, 11, 149, 117, 204, 84, 273, 2, 118, 291, 26, 326] for more 
information and further references. 

506 
Chapter 8: Polymorphic type theory 
Exercises 
8.6.1. 
(From [161]) Let PER<: be the category of "indexed PERs and inclusions". 
It has 
objects 
triples (/, R, R') where / = (/, E) is an a;-set and /?, R' 
are /-indexed PERs. Hence we may describe such an 
object as a pair of parallel maps /?, R': (/, E) =4 VPER 
in a;-Sets. (Thus VPERx VPER is split generic object.) 
morphisms 
{I,R, R') -> (J, 5, 5') are morphisms u:{I,E) 
—^ {J,E) 
of a;-sets for which one has for all i E / 
Ri C Ri =>- 5it(,) C 5y(,). 
(i) 
Check that the functor PER<: ->• a;-Sets given by (/, R, R') M- / is a 
fibration, with posets as fibre categories. 
(ii) Show that there is a full cind faithful fibred functor PER<: -> 
RegSub(a;-Sets) over u;-Sets. Hence this category of PERs with sub-
typings gives us a "sublogic" of the logic of regular subobjects of u;-sets. 
UFam(PER) 
In combination with the 
fibration 
i 
we get a logic of kinds, 
(J-Sets 
as above. 
PER<: 
(iii) Prove that the 
fibration 
i 
of sub typings has fibred finite meets. 
CJ-Sets 
8.6.2. 
Check that there are change-of-base situations: 
RegSub(PER) 
^ UFamRegSub(PER) 
PER 
^ UFam(PER) 
-^ u;-Sets 
8.6.3. 
Check that the V's and 3's (over types and over kinds) in Example 8.6.1 
are right and left adjoints to appropriate weakening functors. 
8.6.4. 
Investigate equality Eqs(/3,/3'): Prop for inhabitants fi^fi'.B of B: Kind in 
the (term model of the) logic over types in PTT, in terms of left adjoints 
to lifted diagonals 8. See also what this means in the model of famihes of 
regular subobjects of PERs in Example 8.6.1. 
8.6.5. 
Check that the morphism of split fibrations 
/ PFam(PER) \ 
/ RFam(PER) \ 
V 
PPER 
/ 
V 
RPER 
) 
in the proof of Proposition 8.6.3 preserves polymorphic products ]^. 

Section 8.6: Logic over polymorphic type theory 
507 
8.6.6. 
Describe inside a;-Sets an internal category RegSub(PER) of regular sub-
objects in the internal category PER in u;-Sets. Define an "internal fibra-
tion" RegSub(PER) ->• P E R in a;-Sets and show that the situation 
UFamRegSub(PER) 
^ UFam(PER) 
a;-Sets 
cirises by externalisation. 

508 
Chapter 8: Polymorphic type theory 
This Page Intentionally Left Blank

Chapter 9 
Advanced fibred category theory 
This is the second chapter in this book—after Chapter 1—in which fibred 
category theory is studied on its own, and not in relation to a specific logic or 
type theory. This chapter collects some miscellaneous topics in fibred category 
theory, which are of a more advanced nature. Most of these will re-appear in 
the subsequent last two chapters on (first and higher order) dependent type 
theory. The notions and results that will be of greatest importance in the 
sequel are in Section 9.3 on quantification. 
We start this chapter with opfibrations, which are suitable duals of fibra-
tions; they involve an "initial lifting" property, as opposed to a "terminal lift-
ing" property defining fibrations. These are then used in the second section to 
describe categorical structure in total categories of fibrations. This structure 
is often used for so-called "logical" predicates and relations. It gives rise to 
a categorical description of induction and co-induction principles associated 
with inductively and co-inductively defined data types. The third section gives 
a general notion of quantification along a certain class of maps in a base cate-
gory, presented either via a "weakening and contraction comonad", or equiv-
alently, via a "comprehension category". This general notion of quantification 
encompasses all forms that we have seen so far. The fourth section 9.4 deals 
with another generalisation: a fibration involves objects in a total category 
which are indexed by objects in a base category. Logically, propositions in a 
total category are indexed by types, to reason about the type theory of the 
base category. One can go a step further and investigate multiple levels of in-
dexing. We already saw examples in Section 8.6 where we had propositions to 
reason about types, which in turn were indexed by kinds in polymorphic type 
509 

510 
Chapter 9: Advanced fibred category theory 
theory. Such double levels of indexing are captured categorically by having 
one fibration being fibred over another fibration. This can basically happen 
in two ways, depending on whether one keeps the base category fixed or not. 
In the last two Sections 9.5 and 9.6 we describe Benabou's notions of 'locally 
smair and 'definable' fibration. They involve representation in the base cate-
gory of: homsets in the total category (for locally small fibrations), and best 
approximations of an object in the total category, with respect to a certain 
property (for definable fibrations). One of the main results is that small fibra-
tions (coming as externalisations of internal categories) can be characterised 
as fibrations which are both locally small and globally small (where the lat-
ter means that the fibration has a generic object). And this will imply that 
"definable subfibrations" of a small fibration are again small fibrations. 
9.1 Opfibrations 
and fibred spans 
We recall that what determines a fibration is a "terminal lifting" property 
for morphisms in the base category. There is a dual notion of opfibration 
for which one has an "initial lifting" property instead: a functor p:E -> B 
is an opfibration if p, considered as functor p: EPP —> W^ between opposite 
categories, is a fibration. That is, if each morphismpX -^ / in B has a lifting 
X —)• • in E, which is initial in a suitable sense. One then says that E is 
opfibred over B. Sometimes opfibrations are called cofibrations. 
In this section these opfibrations will be investigated. Most examples of 
opfibrations are straightforward dualisations of examples of fibrations. In fi-
brations one can choose reindexing functors u*, and similarly in opfibrations 
one can choose opreindexing functors u\. One can think of u* as restriction, 
and of u\ as extension, see the examples after the proof of Proposition 9.1.4 
below. If a fibration is also an opfibration then there are adjunctions u\ -\ u*. 
Lemma 9.1.2 below states that these adjunctions characterise such fibrations 
which are also opfibrations (called bifibrations). We further describe categories 
which are fibred over one category and opfibred over another. Such structures 
will be called fibred spans; they give rise to interesting examples. However, 
they form a side topic. 
The following is a direct dualisation of Definition 1.1.3, which introduces 
fibrations. 
9.1.1. Definition. Let p:E —)- B be a functor. 
(i) A morphism f:X 
^ Y in E over u — pf:I 
^ J in B is called op-
cartesian over u if it is Cartesian over u for p: EP^ —^ W^. That is, if each 
morphism g:X —^ Z iuE with pg = v o u in M, uniquely determines a map 

Section 9.1: Opfihrations and fibred spans 
511 
h:Y —^ Z over v with /i o / = ^, as in: 
E 
p(^) 
—you 
(ii) The functor p: E -^ B is an opfibration if p: E°P -> IB°P is a fibration. 
Equivalently, if above each morphism pX —)• J in B there is an opcartesian 
map X ^ y in E. 
An opfibration p: E —>• B will be called cloven or split whenever p: EPP —> 
W^ is a cloven or split fibration. 
(iii) A bifibration is a functor which is at the same time a fibration and 
an opfibration. 
Earlier we wrote u*{X) —> X for a Cartesian lifting of a morphism u: I ^ 
pX. Similarly, we shall write X -^ u\{X) or X —> U^^(X) for an opcartesian 
lifting oiu'.pX -^ J in a base category. The assignment X i-> u\{X) extends to 
a functor, which may be called opreindexing, extension or sum functor— 
because it will turn out to be a left adjoint to substitution w*, see Lemma 9.1.2 
below. 
(The notation u^ (or Y\^) is often used for a right adjoint to a functor u*.) 
We present two easy examples of opfibrations; they are obvious dualisations 
of the type theoretic 'codomain' and 'simple' fibrations to 'domain' and 'sim-
ple' opfibrations. First, the domain functor domiB"*" —> B is an opfibration 
if and only if the category B has pushouts. Pushouts in B are precisely the 
opcartesian morphism in B"*". The fibre above / G B is the opslice /\B. 
Secondly, for a category B with binary coproducts + there is a simple 
so(l) 
opfibration 
i 
where the total category so(B) has 
objects 
pairs [I,X) of objects in B. 
morphisms 
{h^) 
-^ [J^^) ^^^ pairs of morphisms u: I -^ J and 
/: X -> J -f y in B. 
The first projection so(B) ^ B is then a split opfibration. One obtains an 
opcartesian lifting starting from (/,X) E so(B) over the domain of u: I -^ J 

512 
Chapter 9: Advanced fibred category theory 
in IB: 
/ 
^ J 
by taking ?? = {Ji^) 
and ? = {u,f^'), where K': X —^ J -\-X in the second 
coprojection. The fibre over / G B will be called the simple opslice category 
and will be written as I\M. 
The following result is quite useful. 
9.1.2. Lemma. A fibration is a bifibration (I.e. additionally is an opfibration) 
if and only if each reindexing functor u* has a left adjoint (written as u\ or 
UJ-
Notice that the Beck-Che valley condition is not required for these ]J^'s 
in the lemma. But the result implies that every fibration with coproducts 
{i.e. with adjunctions ]J^ H u* satisfying Beck-Che valley) is a bifibration. 
Codomain fibrations are thus bifibrations (see Proposition 1.9.8 (i)). 
E 
Proof. Let 
^P be a fibration. For a morphism w:/ -> J in B and objects 
X G E/ and y G Ej consider the chain: 
Ey(iJ„w, y) ^ E,(x, u-(Y)) s E„(x, y) s E^dj^w. y) 
where the isomorphism = in the middle comes from the fact that p is a fibra-
tion. Then: 
* 
left adjoints ]J^ exist <^ isomorphisms = exist 
<:> isomorphisms = exist 
<=> p is an opfibration. 
• 
The next result is similar to Lemma 1.9.5 for family fibrations over sets. 
9.1.3. Lemma. Let C be a fixed category. The assignment 
A H-> (the functor category C^) 
extends to a functor Cat^P —> Cat. The resulting split fibration will be written 
Fam(C) 
as 
i 
. Then 
Cat 
Fam(C) 
C is cocomplete <^ 
i 
is an opfibration. 

Section 9.1: Opfibrations and fibred spans 
513 
Proof. For a functor U:A^B 
the reindexing functor [/*: C? -^ C^ is given 
by pre-composition with U, that is, by U* — (—) o U. A left adjoint is thus 
given by left Kan extension. If C is cocomplete, then one can use the pointwise 
formula, see e.g, [187]. 
Fam(€) 
Conversely, if 
I 
is an opfibration, then, by the previous lemma, every 
Cat 
functor F E C^ has a colimit 0^(F) in the fibre over the terminal category 
1—which is isomorphic to C. 
• 
There is a similar result (due to Lawvere) which is of relevance in the se-
mantics of parametrised specifications. This will be explained after the proof. 
9.1.4. Proposition. LetM be a cocomplete category with finite products, such 
that functors I x ( —):B -> B preserve colimits. There is an indexed category 
AlgSpec^P -^ Cat given by 
(S,^) ^ (the category FPCat(«(S;,^), B ) of models of{i:,A) 
m M\ . 
Model(B) 
The resulting 
fibration 
i 
is a bifibration. 
AlgSpec 
Recall from Section 3.3 that these categories of (functorial) models of alge-
braic specifications contain finite product preserving functors as objects, with 
natural transformations between them. 
Proof. For a morphism (/): (D,^) -^ {T,',A') of algebraic specifications and a 
model M:a{E, 
A) -^ B one obtains a functor (/)i{M):Ci{'E',A') -^ B with the 
required universal property by pointwise left Kan extension. Some detailed 
computations—using that the functors / x (—):B —)• B preserve colimits— 
prove that this functor (j)\{M) preserves finite products. 
• 
This result gives for a morphism <j): (E,^) -^ {T>',A') of algebraic specifi-
cations and models Al:ff(S,^) -^ B and M:a{J:\A') 
-> B of (E,^) and 
{H',A') in B, a bijective correspondence between natural transformations 
(f>,{M) => M 
If </>: (E,^) -^ (E',^') is an inclusion then <{>'^{N') is restriction and (t>\{M) is 
extension: (f)]{A4) yields an interpretation of all the extra types and function 
symbols in (E',^'). Moreover, the above correspondence tells us that it is the 
best possible extension. For more information, see [152] (and [160]) and the 
references mentioned there. 
In [344] there is a similar bifibration of labelled transition systems over 
pointed sets of labels: reindexing u* is restriction along a relabelling map, 
and opreindexing i/r is extension. 

514 
Chapter 9: Advanced fibred category theory 
There are many more examples of bifibrations. The classical example in 
algebra is given by modules over rings. For a homomorphism of rings f: R —^ S 
there is a reindexing functor /*: Mods -> Modi? from modules over S to 
modules over R (much like in Exercise 1.1.11 for vector spaces). It has a left 
adjoint f\: ModR —^ Mods, called "extension of the base", see e.g. [190, XVI, 4] 
or [36, II, 4.7]. It plays an important role in descent theory for modules. 
Fibred spans 
The notion to be introduced next is due to Benabou. It can be under-
stood as follows. Indexed categories 1^^ -^ Cat are categorical generalisa-
tions of presheaves W^ -> Sets. Similarly, one can generalise profunctors 
A°P X B -^ Sets to A°P X B -> Cat. And the fibred versions of the latter are 
described as what we call fibred spans. This correspondence is made explicit 
in Proposition 9.1.8. 
9.1.5. Definition, (i) A fibred span consists of a diagram 
E 
where p is a fibration and q is an opfibration and these fibred structures are 
compatible in the following way. 
(a) Every morphism / —> pX in A has a p-Cartesian lifting • —>• X in E 
which is g-vertical. Also, every gY -^ J in B has an opcartesian lifting Y ^ • 
in E which is p-vertical. 
(b) Consider a commuting diagram in E 
h 
where f,g are g-vertical and ft,Ar are p-vertical. Then 
/i, k are p-Cartesian 
- . 
^ . 
, => a IS g-opcartesian. 
/ IS g-opcartesian J 
Or, equivalently, 
/, 0 are g-opcartesian 1 
, • 
^ 
, . 
^ 
X • 
> => n IS p-Cartesian. 
k IS p-Cartesian J 

Section 
9.1: Opfihrations 
and fibred spans 
515 
(ii) A fibred span will be called split if both the fibration p and the op-
fibration q are split, and the compatibility conditions (a)-h(b) hold for the 
morphisms given by the splitting and opsplitting. 
It is easy to see that the notion of fibred span comprises both fibrations, 
E 
E 
namely as fibred spans ^ ^ and opfibrations, as fibred spans ^ \ . For this 
B 
1 
1 
IB 
reason, Street [317] calls these fibred spans fibrations. What we call fibrations 
and opfibrations then appear as special cases. 
The next result gives rise to many more examples of fibred spans. One half 
of it appeared as Exercise 1.4.6. 
F 
G 
9.1.6. Lemma. Consider two functors A —> C <— B with common 
codomain C. The comma category (FIG) 
together with the associated pro-
jection functors to A and B forms a split fibred span 
A 
B 
Proof. Let ^\ FX -> GY be an object of (F | G). It is sent to: 
( F X ^ GY^ 
PF 
PG 
X 
Y 
For morphisms u: I —> X in A and v:Y -^ J inM there are Cartesian liftings 
(on the left) and opcartesian liftings (on the right): 
F{u) 
FI 
^ FX 
ip o F[u) 
GY 
G(id) 
9 
I 
F(id) 
FX 
^ FX 
GY 
i;i(v?) ^ 
G{v) o (f 
G(v) 
^GJ 
-^ X 
Y 
-^ J 
a 
Fibred spans often arise in situations where one has a category E in which 
morphisms X —^ Y consist of two maps X t^ Y \n some other category B. 

516 
Chapter 
9: Advanced fibred category 
theory 
E 
One then obtains fibred spans of the form j ^ \op- This is quite common for 
models of linear logic, see the first example below, and Exercise 9.1.6. 
9.1.7. Examples, (i) Let K be an arbitrary set. Consider the identity func-
tor Id: Sets -^ Sets and the exponent functor (—) =^ A^: Sets^P —>- Sets. The 
resulting comma category (Id I (—) => K) is the category Game^ of Lafont 
and Streicher [184]. It is thus fibred over Sets and opfibred over Sets°P in the 
fibred span 
Game/<: 
Sets 
Sets°P 
(ii) Vickers [338] defines a category of what he calls topological systems, 
which form a common generalisation of topological spaces and locales. We 
write LOG = Frm^P for the category which has locales (or frames, or complete 
Heyting algebras) as objects. A morphism f:A-^Bm 
LOG is a morphism 
of frames f:B—>Am 
the reverse direction. It preserves arbitrary joins and 
finite meets. 
An object of this category TS of topological systems is a triple {A, X, [=), 
where A is a locale, X a set and \=C X x A 3i relation satisfying 
X \=z y^^jtti 
<^ 
X \= ai for some i E I 
X \= ai A •'' A Gn <^ X \= ai for all i. 
Equivalently, [=:: is a morphism of locales VX -^ A. 
A morphism {A,X, |=) -^ {B,Y, |=) is a pair {f,g) where 
f:A^Bissi 
morphism of locales and g:X -^Y 
is sm ordinary function, satisfying 
X h m 
« 9(^) N b. 
The resulting category TS of topological systems can thus be understood as 
the comma category obtained from the powerset functor V: Sets -> LOG and 
the identity LOG -> LOG. Thus we have a fibred span 
TS 
X 
\ 
Sets 
LOG 
In Section 1.10 we have seen a "Grothendieck" correspondence between 
cloven fibrations on B and pseudo functors W^ -^ Cat. This correspondence 
• 
extends to fibred spans ^ ^ 
and suitable pseudo functors A^^ x IB -^ Cat. 
The latter can be understood as "Cat-valued distributors". In order not to 
complicate matters, we shall restrict ourselves to the split case. 

Section 9.1: Opfihrations and fibred spans 
517 
E 
9.1.8. Proposition (See [316]). Every split fibred span ^ ^ 
determines 
a 
functor 
A°P x B —)• Cat. Conversely 
there is a generalised 
Grothendieck 
con-
struction 
which yields for every such functor 
a split fibred span of the form 
^ ^ . These constructions 
are mutually 
inverse. 
E 
Proof. Given a split fibred span ^^ ^^ 
one defines a functor <^: A°P X B ^ 
Cat as follows. For / G A and / ' E B, take ^ ( / , /') to be the category with 
objects 
X eE 
with pX ^ I and qX = T. 
morphisms 
/ : X —)• Y are maps / : X —> Y in E with pf — id and 
qf = id. 
For a morphism (u,u'):(I, 
I') —> (J, J') in A°P X M one obtains a functor 
$(w, u'): $ ( / , /') -^ $ ( J , J') by 
j X 
^ 
u*(u',(X)) 
=u',{u*{X)) 
\ 
/ 
>^ 
u'(u',(f))=u',{u*(f)). 
In the reverse direction, given such a ^ : A ° P X B —> Cat, let J ^ be the 
category with 
objects 
(/, /', X) where X E ^ ( / , / ' ) . 
morphisms 
(/, /', X) ^ (J, J', Y) are triples u: I -^ J in A, u'\ V -^ J' 
in B and / : ^(id/, t/')(X) ^ ^(t/, idj/)(y) in ^ ( / , J'). 
/ ^ 
. 
There are obvious projection functors 
»/ \ 
forming a fibred span. 
• 
The above result finds application in the (functorial) semantics of logics 
and type theories. Reindexing along a morphism of signatures (or specifica-
tions) in syntax works contravariantly on models, whereas reindexing along 
a morphism of models works covariantly. It is precisely this aspect that 
Goguen and Burstall [152] seek to capture in the notion of institution. Here 
we shall describe these phenomena via fibred spans. Algebraic specifications 
form again the paradigmatic example: there is a 'canonical' model functor 
AlgSpec^P X F P C a t -> Cat given by 
( ( E , ^ ) , B ) ^ ^ F P C a t ( « ( E , ^ ) , B ) . 
A morphism ((/>, F) in AlgSpec^P x F P C a t is sent to the functor 
M^-^F 
oMoa[(t>). 
The total category of the resulting fibred span is the category of categorical 
models described earlier in Exercise 2.2.4, in case A — 0—that is, if the 
specification consists only of a signature E without axioms. 

518 
Chapter 9: Advanced fibred category theory 
Exercises 
9.1.1. 
(i) 
Establish a Grothendieck correspondence between functors IB -> Cat 
and split opfibrations on B. 
(ii) Prove that the composite of two opfibrations is an opfibration again. 
9.1.2. 
What are the opcartesian morphism for a codomain functor? 
9.1.3. 
Consider a category B with finite coproducts (0, +). 
(i) 
Show that the simple opslice 0\^B over the initial object 0 G B is 
isomorphic to B. 
(ii) Describe the opreindexing functor I\:M = 0\^B -> I\M resulting from 
0 - > / . 
(iii) Define a full and faithful functor I\M -^ / \ B from the simple to the 
ordinary opslice category in a commuting diagram: 
E 
E 
9.1.4. 
Note that if /^ ^ 
is a fibred span, then so is 
„ >^ ^ „„ . 
{FIG) 
9.1.5. 
(i) 
Verify that the fibred span 
"^ ^ 
in Lemma 9.1.6 can be obtained 
as instance of the generalised Grothendieck construction in Proposi-
tion 9.1.8, applied to a functor A*^'^ x B —)• Cat with discrete categories 
as fibres, 
(ii) Check that the Grothendieck constructions for fibrations and for op-
fibrations are also special cases of this generalised Grothendieck con-
struction. 
GC 
9.1.6. 
Describe the dialectica category GC from [244] in a fibred span ^ 
\nop-
9.2 Logical predicates and relations 
Consider a coherent predicate logic over a (simple) type theory with finite 
products (1, x) and coproducts (0,+) and exponents —^ for types. Propo-
sitions are v^ritten as (X:(T h 9?: Prop), where x:a is the only possible free 
variable in the proposition (p. Thus one can view <^ as a predicate on a. A 
category of such predicates can be formed by stipulating that a morphism 
{x:a 
h ip: Prop) -> (y: r h ip: Prop) is given by the equivalence class (under 
conversion) of a term M with 
x:a 
\- M:T 
and 
x:a \ (p 
\-ip[M/y]. 

Section 9.2: Logical predicates and relations 
519 
This gives us a category of predicates; it is essentially the total category of a 
logic as described in Section 3.1. A reasonable question to ask is how to obtain 
finite products and coproducts and exponents in such a (total) category of 
predicates. Finite products are easy; they are given by the formulas, 
1 = 
(x: 1 h T: Prop) 
{x: a \- (p: Prop) x {y.r 
\- ip: Prop) 
= 
[z: a X T \- (p['Kz/x\ A ^[K'z/y\: 
Prop). 
These finite products of predicates thus sit over the finite products of their 
underlying types. Finite coproducts are slightly more complicated: 
0 = 
(ar:0 h ±:Prop) 
{x\ a \- if. Prop) + (y: r h ^: Prop) 
= 
[z: a -{- T \- {3x: a, z — KX /\(p) V (By: r. 2: = K^y A -0): Prop). 
And exponents are given by 
(x: a \- (p: Prop) z=^ [y.r \ V^: Prop) 
= [f'.<j-^T\- 
\fx: a. [if D ^p[(fx)/y]): 
Prop). 
Predicates with this BiCCC-structure are often referred to as "logical pred-
icates". Similar formulas apply for relations, and in this context one talks 
about "logical relations". They can be used in the analysis of properties of 
type theories (like strong normalisation), see e.g. [311, 228] and the references 
there for more information. In this section we describe the categorical aspects 
of the above formulas: they can be described as products, coproducts and 
exponents in total categories of fibrations. Parts of these descriptions already 
occurred in Section 8.5. 
The issue in this section is the interaction between local structure (in fi-
bre categories) and total structure (in total categories), and the use in logic 
of the global structure. The first result states that if a base category has a 
certain type of limit, then these limits exist fibrewise if and only if they ex-
ist in the total category (and are preserved by the functor). The same holds 
for colimits if one works with a fibration that is additionally an opfibration 
(i.e. with a bifibration). We discuss these (folklore) results in some detail. A 
further analysis of this interaction between local and global structure may be 
found in [125-127] (along the lines of Exercise 1.8.11). The global structure 
is used towards the end of this section in a uniform description of the (logi-
cal) induction principles associated with (co-)inductively defined data types, 
following [128, 130]. See also [124]. 
Although the abovementioned motivation comes from logic, there is noth-
ing in this section that holds only for preorder fibrations. But we shall use 

520 
Chapter 9: Advanced fibred category theory 
logical notation like T, A, _L, V, D for products, coproducts and exponents in 
fibre categories—as in Section 8.5. This allows us to distinguish this fibre-
wise structure from such structure in total categories. But it is not meant to 
suggest that fibres are preorders. 
The next result holds for arbitrary limits, but for simplicity we only consider 
finite products. The general case is left as Exercises 9.2.3 and 9.2.4. 
E 
9.2.1. Proposition. Consider a fihration ^ 
with finite products in its base 
category B. Then p has finite products in Fib(B) if and only if p has finite 
products in Fib. That is, p has fibred finite products (I.e. finite products in 
each fibre category, preserved by reindexing) 
if and only if the total 
category 
E has finite products via fibred functors, 
and the functor p strictly 
preserves 
these 
products. 
Explicitly, 
given fibred finite products (T, A) one can define in E; 
1 = T G E I 
and 
X x 7 = 7r*(X) A 7r'*(y) G E / x j 
where X E E/ and F E E j . Conversely, 
given finite products (1, x) m E one 
takes in the fibre over I, 
T r r : ! ; ( l ) G E / 
and 
X A Y = (J|(X x y ) G E/, 
where !/: / —> 1 and Sj = (id, id): / —)• / x / . 
Proof. Lemma 8.5.2 (i) states already that 1 G E and x as defined above are 
finite products in E. And p preserves them by construction. For the fibration 
p to have finite products in Fib we need to check that the induced product 
functor X: E X E ^ E over x: IB x B ^ B is fibred. This follows easily: 
{u X vy{X xY) 
^ {ux i;)*7r*(X) A {u x i;)*7r'*(y) 
^ 
7r*'w*(X) A7r'*i;*(y) 
= t/*(X) 
xv*{Y). 
Conversely we show that X AY — Sj{X xY) 
G E/ is the binary product 
of X and Y in the fibre over /: 
E/(Z, X AY) =¥^{Z, 
X XY) 
^ E / ( Z , X) XEI{Z, 
Y). 
The latter because p strictly preserves the binary products. These products A 
in the fibres are preserved by reindexing functors: for t/: J ^ /, 
i / * ( X A y ) = u*S^X 
xY) 
^ S^u xuy{X 
xY) 
=. S*(u*{X) 
X u*{Y)) 
because x is a fibred functor 
= u*{X)Au*{Y). 
D 

Section 9.2: Logical predicates and relations 
521 
For coproducts the situation is slightly more complicated, and some ad-
ditional assumptions are needed to get a smooth correspondences between 
fibrewise and global structure as for products. We shall use opreindexing, as 
conveniently described via adjunctions \[^ H i/* in Lemma 9.1.2. Part of the 
next result occurs as [105, Corollary 4.3]. As before, we only do the finite case. 
E 
9.2.2. P r o p o s i t i o n . Let 
^L> he a bifibration 
with finite coproducts 
in its 
base category M. 
(i) Every fibre category has finite coproducts (±, V) if and only if the total 
category E has finite coproducts (0, +) and p strictly preserves 
these. 
The formulas 
are the following. 
Given (±,V); one takes in E; 
0 = 1 E Eo 
and 
^ + Y = U J X ) V U.'{y) 
^ ^i+J 
where X G E/ and Y ElEj. 
Conversely, 
given (0,+) one defines over L: 
1 ^ U , ^ ( 0 ) 
and 
X v y = U v . ( ^ ^ + ^ ) ' 
where !/:0 —> / and Vj = [id,id]:/+ L ^ 
L. 
(ii) Under the additional 
assumptions 
that the category M is 
extensive 
(I.e. that its coproducts are disjoint and universal, 
see Section 
1.5), and that 
the coproducts ]J^ satisfy Beck-Chevalley, 
one obtains the following 
strength-
ening: p has finite coproducts in Fib(B) if and only if p has finite coproducts 
in Fib. 
An alternative formulation of the coproduct + in the total category E in 
terms of products Yl instead of coproducts ]J occurs in Exercise 9.5.9. 
Proof, (i) We do the binary case only. Consider X + Y G E/_j_j as defined 
above. For Z G E above / i , we have: 
u:I+J-^K 
u:I+J^K 
= 
II ^i+j{UuoAx)^UuoAy)^z) 
= II 
II E/(U.W, ^) X Ej{UJY),z) 
v.I-^K 
w.J^K 
= U Ej(UAnz) 
X II 
Ej(UJY),z) 
v:I-yK 
w:J-*K 
^ E{X, Z) X E(y, z). 
Conversely, we simply have, 
El (x V y, z) s Ev, (x + y, z)^ E/ {X, Z) X E/ (y, z) 

522 
Chapter 9: Advanced fibred category theory 
because p preserves coproducts. 
(ii) In one direction we have to show that +:E x E —>• E is fibred over 
+:B X IB -> IB. This follows from the isomorphisms: 
- 
L I K ^ * ( ^ ) V 1 J K ' ^ * ( ^ ) by Beck-Chevalley, 
using Exercise 1.5.7 
= 
u^{X)-{-v*{Y). 
And in the other direction, assuming that this global functor + is fibred, we 
have to show that the induced coproducts V in the fibres are preserved under 
reindexing: 
u*{XVY) 
= u*Uvi^ 
+ y) 
= Uvi^ + ^Yi^ 
+ Y) by Beck-Chevalley 
— IJv(^*(^) "^ ^*(^)) because + is a fibred functor 
= ti*(x) vw*(y). 
D 
In a next step also local and global distributivity can be related. Therefore 
we use the additional assumption that Frobenius holds. 
E 
9.2.3. Proposition. Let 
j^P be a fibration with coproducts ]J^ satisfying 
Beck-Chevalley and Frobenius. Assume B 25 a distributive category. Then, p is 
a distributive fibred category if and only if the total category E is a distributive 
category and p strictly preserves this structure. 
Proof. First we assume that all fibre categories are distributive. We consider 
arbitrary objects Z G Ex, X G E/ and Y G Ej, and write <f for the inverse 
of the canonical map [id x K, id x /c']: (A' x /) + {K x J) -^ K x (/ -f J) in B. 
We can prove distributivity in E as follows. 
ZxiX 
+ Y) = 
7r*(Z)An"iUAX)^U.'iY)) 
= 
'r'(Z)A(U,ax«('^'*W)vU,dx.'('r'*(y))) 
by Beck-Chevalley 
by distributivity 
= Uidx«('^*(^)A7r"(X)) VU„,,,(7r*(Z)A7r"(y)) 
by Frobenius 

Section 9.2: Logical predicates and relations 
523 
- U^U,dx«(^x^)vU^U,dx«'(^xy) 
because <f> is an isomorphism 
= {Z xX)-h{Z 
xY). 
In the reverse direction, assuming distributivity in E, distributivity in the 
fibres follows from the following computation. 
ZAiXWY) 
= ZAUvi^ 
+ y) 
= LIv(^*(^) A (X + y)) 
by Frobenius 
= Uv S*^*(^*{Z) 
X X + V*(Z) X y) 
by distributivity 
= L[v^V*('^xid + V x i d ) * ( Z x X + Z x y ) 
- LJv(^ + ^)*(^x^ + ^ x ^ ) 
= Llv(^*(^xx) + J*(zxy)) 
rr {Z AX)y{ZAY). 
D 
We notice that the proof requires only coproducts (]J^ H /c*) along copro-
jections, satisfying Beck-Chevalley and Frobenius. So the assumptions in the 
proposition can actually be weakened. 
Finally, we consider the relation between exponents in fibre categories and 
in total categories. 
E 
9.2.4. Proposition. Let -j^P be a fibration with a Cartesian closed base cat-
egory M and with simple products TT* H f][^. If the fibre categories are Cartesian 
closed, then so is the total category and this global CCC-structure is strictly 
preserved by p. For X G E/ and y G Ej one defines 
X^Y 
= n.K*(X) D ev*(y)) G Ei^j. 
If there are additionally right adjoints S* H JJ^ to contraction functors, then 
the converse also holds: exponents D in fibres can be obtained from exponents 
in E via the formula 
XDY^A(idr(x^Us(y)) 
where A{id): I ^ {I => (I X I)). 
Proof. The first part of the statement is Lemma 8.5.2 (ii). For the second 

524 
Chapter 9: Advanced fibred category theory 
part we note that in the fibre over / € E we have 
E / ( Z A X , y ) = E/(^*(ZxX), y ) 
s E/x/(zxx, nan) 
^ EA(,d)(^, x=>nan) 
We discuss some examples and consequences of these results. 
E 
9.2.5. Examples, (i) If 
j ^ ^ is a bifibration with fibred finite products and 
coproducts over a base category IB with finite products and coproducts, then 
the total category E has finite products and coproducts, and p preserves them. 
This result is a consequence of Propositions 9.2.1 and 9.2.2 above. It applies 
in particular when p is the classifying fibration of a coherent predicate logic 
with T, A, -L, V, = and 3 as described in the beginning of this section. This is 
a bifibration by Example 4.3.7 (i) together with Lemma 9.1.2. The resulting 
finite products and coproducts in the total category of predicates as described 
in Propositions 9.2.1 and 9.2.2 are the "logical predicate" products and co-
products as in the beginning of the section. 
We mention two similar applications. If IB is a coherent category with dis-
tributive coproducts, then its category of subobjects Sub(B) is a distributive 
category. And if IB is Cartesian closed, then the associated scone Sc(B) is also 
Cartesian closed, and the functor (or fibration) Sc(IB) -^ IB preserves the CCC 
structure, see Example 1.5.2 (ii) and Exercise 1.5.4. 
E 
Rel(E) 
(ii) Suppose 
p^ is a fibration as before, and form the 
fibration 
4- 
of 
binary relations in p via the change-of-base situation 
Rel(E) 
^ E 
Rel(E) 
like in Section 4.8. It is easy to see that 
i 
is also a bifibration with 
B 
fibred finite products and coproducts, so that we may conclude that the total 
category Rel(E) of relations has finite products and coproducts, and that they 
are preserved by Rel(E) -^ B. If we apply this to a classifying fibration of a 

Section 
9.2: Logical predicates 
and relations 
525 
coherent logic, we get, for example, as global product of relations: 
[x, x': a h R{x, x'): Prop) x (y, y': r | S{y, y'): Prop) 
= {z, z':aXT 
\- R{7rz, nz') A S{7r'z, 'K'Z'): Prop) 
This is the "logical relations" product, see e.g. [125, 228]. 
E 
For a fibration ^P as above, we can define an equality functor Eq:B —> 
IB 
Rel(E) by / H-)- JJ^ (T/)—essentially as in the beginning of Section 4.8. For a 
morphism i/:/ ^ J in B we obtain Eq(i/):Eq(/) —> Eq(J) using that T/ -> 
Eq(/) is opcartesian. Notice that the statement "Eq:B -^ Rel(E) preserves 
products x" means that equality on a product is componentwise equality. 
This preservation of products is proved explicitly in Proposition 3.4.6). 
If our fibration p is a fibred CCC on a CCC B and has simple products, 
Rel(E) 
then the same holds for 
4- . Hence the global category Rel(E) of relations 
is Cartesian closed. The exponent of relations R on I and 5 on J is given by 
the formula 
R=^S 
= Yln ^*((^' X ^T{R) 
^ (ev X ev)*(5)) 
where a is the isomorphism 
( ( / => J) X (/ ^ 
J)) X (/ X / ) - ^ ^ 
( ( / => J) X / ) X ( ( / ^ J) X / ) 
In the special case when R is the equality relation Eq(/) on / one can simplify 
the right hand side to 
Eq(/) ::^ S = Yl^{ey o TT X id,ey o TT' X id)*(5). 
This says informally that maps f,g:I^ 
J are in the relation Eq(/) => S if and 
only if for all i £ I the pair f{i),g{i) 
is in the relation S. Thus we can say that 
equality on maps in B is pointwise if the equality functor Eq:B —> Rel(E) 
preserves exponents. 
If the fibration p admits quotients—i.e. if the equality functor Eq has a 
left adjoint (see Definition 4.8.1)—then one can prove: equality on maps in 
p is pointwise if and only if p's quotients satisfy Frobenius. The argument is 
standard, like in the proof of Lemma 1.9.12. 
(iii) Still in the same situation, we assume now that the terminal object 
functor T:B —> E preserves coproducts +. This happens for example when 
T has a right adjoint, giving comprehension in the logic of p. Explicitly, this 
preservation means that for objects /, J G B the canonical map 
LI«(T/) V U«'(TJ) 
T(/ + J) 

526 
Chapter 9: Advanced fibred category theory 
is an isomorphism. Logically, this amounts to validity of the axiom (scheme): 
z: cr -f- r I T h (3x: a. z —o-\.r f^x) V {3y: r. z —O-\-T 
^'VY 
It is not hard to see that this is equivalent to the following rule: for a term 
r h M: <7 + r and propositions F [- (p^ip: Prop 
T,x:a\ 
(p,M =a+T KX \- tp 
T,y:T 
\(p,M 
=a-\-T i^'y l~ i^ 
This rule is more convenient than the axiom, and has the advantage that it 
does not involve existential quantification 3 so that it can be formulated within 
(conditional) equational logic. It gives a fibred formulation of universality 
for coproducts in a base category, see Exercise 9.2.9 below. 
(Disjointness 
of coproducts + simply means that the coprojections are 
internally injective: x^x'.a 
\ KX =a+T f^^' \~ x —a x'^ and similarly for /c', 
together with: x\a,y\T 
\ KX —O^T K-'y I" ^, expressing that anything (or 
equivalently: falsum L) follows from equality of KX, n'y.) 
Sign 
(iv) Finally, some concrete examples: the fibration i 
of signatures over 
Fam(Sets) 
sets is obtained by chane^e-of-base from 
4- 
see Definition 1.6.1. It thus 
. 
. 
Sets 
has all fibred colimits. Hence the total category Sign is cocomplete. The 
same argument occurs in [327, Example 1]. Actually, Proposition 9.2.2 only 
gives finite coproducts, but, as mentioned, the result also holds for arbitrary 
colimits, see Exercise 9.2.4 (ii) below. This cocompleteness of the category 
of signatures is instrumental in the theory of specifications. It lets us define 
instantiation and put together parametrised signatures via pushouts and other 
colimits, see [327, 152] for details. 
T 
Winskel [344] defines a bifibration 
i 
of labelled transition systems over 
pointed sets. Local products and coproducts of transition systems are defined 
over a particular pointed set of labels. And in terms of these, also global 
products and coproducts of transition systems, following the constructions in 
this section. 
Similar constructions appear in the theory of deliverables, see [40, 217]. 
Reasoning principles via global structure 
We describe how the induction (and co-induction) principles associated with 
data types given as initial algebras (and terminal co-algebras) of Hagino sig-
natures can be described in a uniform and concise way using global structure 
in total categories of fibrations. This follows [125, 128, 130]. We concentrate 
on induction, and mention co-induction in Exercise 9.2.10 below (but see 

Section 9.2: Logical predicates and relations 
527 
also [270, 299, 79]). The approach that we describe here leads to "mixed 
induction/co-induction" proof principles in [130], and to proof principles for 
iterated data types in [124]. Here we concentrate on the basic ideas: we first 
give a formulation of the induction principle in a fibred setting, and then show 
that in logics with comprehension this principle holds automatically. 
Let B be a category with finite products (1, x) and coproducts (0,+). We 
think of IB as a model of a simple type theory. Assume T: B —>^ B is a polynomial 
functor built up from constant functors X \-^ C^ the identity functor X >-> X, 
and constructors x, +. We can think of T as the functor which is canonically 
associated with a type (T{X) in a Hagino signature, see Definition 2.6.4. We 
E 
assume we have a fibration 
]rP giving us a logic to reason about B. We further 
assume this p to be a bifibration with fibred finite products and coproducts. 
The total category E of predicates then has finite products and coproducts. 
This enables us to lift the functor T:B -> B to a functor Pred(T):E ^ E in 
a commuting diagram 
Pred(T) 
E 
^ E 
by induction on the structure of T. We replace the identity functor, the prod-
uct X and the coproduct -f on B occurring in T by the identity functor, 
product and coproduct on E. And we replace the constants C G B occurring 
in T by the constant T[C) in Pred(T)—where T(C) is the terminal object in 
the fibre over C. (In terms of Definition 2.6.4: we replace the model A\S -^M 
of the constants in B by the model T o A: 5 ^ E.) 
This lifting of T to Pred(T) is an important step. It brings us from the 
world of data types (in the form of algebras and co-algebras of the func-
tor T) to the world of logic about such data types (in the form of alge-
bras and CO-algebras of the lifted functor Pred(T)). Essentially, an algebra 
/:Pred(T)(X) -> X of this lifted functor Pred(T) consists of an underlying 
T-algebra u = pf: T{pX) = p(Pred(T)(X)) -> pX, together with a proof that 
the predicate X is closed under the operations of the T-algebra u. Dually, a 
co-algebra g:Y ^ Pred(T)(y) consists of a T-co-algebra v = pg.pY -> T{pY) 
together with a proof that Y is closed under the operations (or transitions) of 
V. Such predicates Y are called invariants in [164]: once they hold in a state x, 
they continue to hold no matter which of the operations in the co-algebra v are 
applied to x. Here we concentrate on Pred(T)-algebras. They incorporate the 
assumptions of induction arguments for data types whose form is determined 

528 
Chapter 
9: Advanced fibred category 
theory 
by the functor T. 
First we need a further assumption, namely that the terminal object functor 
T:IB —> E preserves finite coproducts—e.g. because it has a right adjoint, 
describing comprehension in the logic of p—then one gets a canonical (vertical) 
isomorphism 
T o T =^=^ Pred(T) o T 
by induction on the structure of T. Here one uses that T preserves finite 
products because it is right adjoint to p (see Lemma 1.8.8). 
E 
9.2.6. Definition. Consider a bifibration -j^P with a polynomial functor 
T:B -> IB as above. An initial algebra a:T(K) ^ K of this functor is called 
inductive if the resulting isomorphism in E 
Pred(T)(TA') - ^ ^ TT{K) 
^ 
^ TA^ 
is initial algebra of the lifted functor Pred(T): E —> E. Inductive initial algebras 
in a fibration p come equipped with an associated induction proof principle 
in the logic of p. 
We give an illustration of this notion of inductive initial algebra. Consider 
Sub(Sets) 
the standard 
fibration 
i 
of predicates (subsets) over sets capturing 
the classical logic of sets, with polynomial functor T{X) = 1 + X. This func-
tor T: Sets —> Sets has the cotuple [0, S]: 1 + N -=>• N of zero and successor 
on the natural numbers N as initial algebra. The associated lifted functor 
Pred(T): Sub(Sets) -> Sub(Sets) send a predicate {Y C J) to the predi-
cate (1 -h y C 1 + J). An algebra of this functor thus consists of a map 
(1 -h y C J) —>• (y C J) in Sub(Sets). It consists of a pair of maps 
u:J-,j 
^^^^^f^^^s 
[yeY^u{y)eY^ 
Clearly the truth predicate TN = (N C N) carries the algebra [0, S]: (1 -f N C 
1 -h N) -> (N C N). Inductiveness of this initial T-algebra [0, S]: 1 + N ^ N 
means that this Pred(T)-algebra [0, S]: (l-f N C 1 -f N) -> (N C N) is again 
initial. When we spell this out we get: for a Pred(T)-algebra [j, w]: (1 -f y C 

Section 9.2: Logical predicates and relations 
529 
J) ^ (y C J) as above there is a unique map of Pred(T)-algebras: 
(1+ N C 1 + N) - -' -'^-^- ^ (1 + y C 1 + J) 
[0,S] 
[i>"] 
(N C N) 
^ 
^{YCJ) 
This means that the unique mediating map v:N —-> J with v o 0 — j and 
i ; o S = w o i ' i s a map of predicates (N C N) ^ (Y C J). Hence for all 
n G N we have v(n) G Y. This is the conclusion of the induction principle. 
It is obtained by initiality of the algebra Pred(T)(TN) -% TN on the truth 
predicate TN on N. 
(We have given the "unary" induction principle for predicates; there is 
also an equivalent "binary" version for (congruence) relations, see Exer-
cise 9.2.11 (iii).) 
The following result shows that in a fibration with comprehension (giving 
us a logic with subset types) every initial algebra is automatically inductive. 
Hence one can use induction as a reasoning principle in such a logic. We 
give a concrete proof below, but a more abstract proof using a "transfer of 
adjunction" lemma occurs in [128, 130]. 
E 
9.2.7. Proposition. Let 
-^P be a btfibration with 
• finite products and coproducts in its base category IB; 
• fibred finite products and coproducts; 
• comprehension, given by a right adjoint { —}:E -^M to the terminal object 
functor T-M-^W.. 
An initial algebra a:T{K) 
^ K of a polynomial functor TiB ^ B 25 then 
automatically inductive. 
Proof. Write (p for the natural isomorphism Pred(T) o T = > T o T. We 
have to show initiality of the Pred(T)-algebra Ta o <^;^: Pred(T)(T/\) -^ 
TT{K) 
^ 
TK. Assume a Pred(T)-algebra /:Pred(T)(X) -> X in E, say 
over 6: T(/) ^ / in B. Let u: K --^ / in B be the unique mediating T-algebra 
map in B with 6 o T{u) = u o a. Write 
/ 
^ih 
FTed{T){ex) 
f 
. 
g ^ ( T T { X } ^ 
Pred(T)(T{X}) 
Pred(T)(X) —^ 
x) 
It gives us a transpose g^ — {^} o T/T^^X})-^({-^}) -^ i^}? which is an 
algebra on the extent {X} of X. An easy calculation shows that the (com-

530 
Chapter 9: Advanced fibred category theory 
prehension) projection nx'-iX} 
—>• / is a homomorphism of algebras from 
{g^'iTdX}) 
-> {X}) 
to {b:T{I) 
-> / ) . Hence we also get a unique mediating 
algebra map v: K —> {X} 
in: 
with TTx ^ V = u hy initiality. Transposing this map v: K —^ {X} in IB back to 
¥. as v^ = ex ^ ~^v: TK -> X gives us the required (unique) mediating map 
of Pred(T)-algebras: 
t;^ o Ta o (p^ = ^x o T(t; o a) o (fx 
= ex o T(5f^ o T(v)) o (pK 
= g o TT{v) 
o (pK 
- 
f o Pred(T)(£x) o Pred(T)(Ti;) o v?"^ o pK 
- 
/ o P r e d ( i ; ^ ) . 
D 
The above approach to the logic of (co-)inductive data types is essentially 
syntax-driven: the types of the operations of a data type determine a functor 
T, and thereby its lifting Pred(T), in terms of which the proof principles are 
formulated. This approach—and its extension to more complicated (co-)data 
types—has been implemented in a (front-end) tool for formal reasoning about 
such data types, see [123, 122]. 
Exercises 
9.2.1. 
Describe the biceirtesian closed structure in the following total categories 
(of obvious fibrations) according to the formulas given in this section. 
(i) 
The category of subsets Sub(Sets). 
(ii) The category of set-indexed sets Fam(Sets). 
9.2.2. 
Give the "logiccil relations" coproduct in the term model (of coherent pred-
icate logic). 
E 
9.2.3. 
Consider a fibration ^^ with equalisers in its bcise category. Show that B 
IB 
has fibred equcilisers if and only if E has equalisers and p strictly preserves 
them. 

Section 9.2: Logical predicates and relations 
531 
9.2.4. 
(i) 
Extend Proposition 9.2.1 to arbitrary limits in the following way. Let I 
be some index category and assume the base category B of a fibration 
E 
•j^P has limits of shape I. Show that p has fibred limits of shape I (as 
defined in Exercise 1.8.8) if and only if the total category E has limits 
of shape I and p strictly preserves them. 
[Hint. Use Exercise 1.8.11 (ii).] 
(ii) Do the same for Proposition 9.2.2 (for a bifibration). 
9.2.5. 
Conclude from Proposition 9.2.3 that if a category B has puUbacks and 
disjoint and universal coproducts (0, +), then its category of arrows B"*" is 
distributive. 
9.2.6. 
Prove that the exponent Eq(/) =J> 5 in a category of relations is isomorphic 
to n^(ev o TT X id,ev o TT' X id)*(5), as claimed above. 
9.2.7. 
Prove that for a topos B 
(i) 
the comprehension functor { —}:Sub(B) -> B—which is right adjoint 
to truth and gives subset types—preserves finite coproducts; 
(ii) the quotient functor Q: ERel(B) -> B which takes the quotient of 
equivalence relations preserves finite products. 
ERel(]B) 
[The 
fibration 
4- 
is described at the end of Section 1.3. The sec-
1 
ond point may also be proved type theoretically using Exercise 5.1.7.] 
E 
9.2.8. 
Assume that 
is a fibred CCC with simple products which also 
M 
has coproducts JJ 
-\ u* satisfying Beck-Che valley (and Frobenius by 
Lemma 1.9.12 (i)). Prove that the global exponent =J> from Proposition 9.2.4 
forms a fibred functor in the situation: 
E^P X E 
— 
^ E 
px p 
That is: {u => t;)*(X => Y) ^ L[„(^) => v*{Y). 
9.2.9. 
Let B be a category with finite limits and disjoint coproducts -f. Show that 
these coproducts -|- are universal if and only if the type theoretic rule 
T,x:(T \ip,M =a+r Kx h tp 
F, y: T | (/?, M =^+r n'y h tp 
T\ip \-tP 
Sub(B) 
is valid in the subobject 
fibration 
i 
on B. Conclude that in a coherent 
B 
category B with disjoint coproducts -f, one gets universality for free. 
E 
9.2.10. 
(From [130]) We consider a fibration {P as in Example 9.2.5 (ii). 
B 
(i) 
Prove that if the terminal object functor T:B —> E preserves finite 
coproducts, then so does the equality functor Eq:B —^ Rel(E). 

532 
Chapter 9: Advanced fibred category theory 
We now assume that this equality functor Eq preserves finite coproducts 
and products; the latter e.g, because it has a right adjoint giving quotients 
in the logic of the fibration. Since Rel(E) has finite products and coproducts 
we can lift a polynomial functor T: IB -> B to Rel(T): Rel(E) -> Rel(E) by 
induction on T, whereby we replace a constant C G B occurring in T by the 
constant Eq((7) G Rel(E). By construction we have Rel(T) o Eq = Eq o T. 
A co-algebra of this lifted functor Rel(T) can be identified with bisimulation 
relation, forming an assumption of a co-induction argument. 
Define a terminal co-algebra c: K ^ T{K) to be co-inductive if the re-
sulting map 
Eq(c) 
^ 
Eq(A') 
^ Eq{TK) 
^ Rel(T)(Eq(A^)) 
is terminal Rel(T)-co-algebra. This means that the terminal co-algebra 
comes with a co-induction proof principle in this fibration. 
Sub(Sets) 
(ii) Investigate what this means for the 
fibration 
i 
and the 
Sets 
"stream" functor T( —) = C x (—). 
(iii) Prove that if p has quotients (i.e. if Eq has a left adjoint), then every 
terminal co-algebra is automatically co-inductive. This gives the dual 
of Proposition 9.2.7. 
E 
9.2.11. 
(From [1301) Let 
iP be a fibration with fibred finite products and coprod-
ucts on a distributive base category B. Assume that p is a bifibration with 
coproducts Y[^ -\ u* satisfying Beck-Che valley and Frobenius, and that 
truth T:B —)• E preserves finite coproducts and equality Eq: B —>• Rel(E) 
preserves finite products. (For convenience one may assume that p is a fibred 
preorder.) 
First relate the "Pred" and "Rel" liftings of a polynomicd functor T: B -^ B 
in the following way. 
(i) 
Prove, by induction on T, that there are vertical (natural) isomor-
phisms 
S*Re\{T){R) ^ 
FTed{T){S*{R)). 
(ii) Prove similarly that 
U , P r e d ( r ) ( X ) ^ R e l ( T ) ( U , ( X ) ) . 
These isomorphisms actucdly determine a pseudo map of adjunctions 
(^i -• U<5,) -> i^ni) 
H 1J.5^(,))' see Exercise 1.8.7. 
(iii) Prove that for an initial T-algebra a:T[K) 
-^ K the following three 
points are equivalent: 
• a is inductive {i.e. the canonical map Pred(T)(TAT) -^ TA' is initial 
Pred (T)-algebra); 

Section 
9.2: Logical predicates 
and relations 
533 
• the canonical map Rel(T)(Eq(A")) 
-^ 
Eq(A') is initial Rel(T)-
algebra; 
• every congruence on a is reflexive, i.e. for every Rel(T)-algebra R G 
E/v'xK on a we have Eq(A') < R. 
[The latter formulation gives the so-called binary induction principle, 
which is formulated in terms of congruence relations being reflexive. 
See also [299].] 
E 
9.2.12. 
Let 
^P 
be a 
fibration 
with fibred pullbacks and pullbacks in its base 
category B. By Proposition 9.2.1 and Exercise 9.2.3 we know that the total 
category E also has pullbacks and that p strictly preserves them. 
(i) 
Describe these pullbacks in E in detail. 
Assume now that p has coproducts, via adjunctions (]J 
Hi/*) satisfying 
Beck-Che valley. Following Benabou, these coproducts are called disjoint if 
for each map u: I -^ J in B and opcartesian morphism t^(X): X —> ]J[ 
(X) 
in E over u, the diagonal S: X -^ X XTT , . X of the pullback of 
ulX) 
against itself, is opcartesian again (over the diagonal in B). And these co-
products of p are called universal if for each pullback square in E of the 
form 
one has: g is opcartesian implies f*{g) 
is opcartesian. 
(ii) Check that a category C has set-indexed disjoint / universal coprod-
Fam(C) 
ucts if and only if its family 
fibration 
i 
has disjoint / universal 
Sets 
coproducts (see Lemma 1.9.5). 
(iii) Verify that for a category B with finite limits, the codomain 
fibration 
^ 
always has universal and disjoint coproducts. 
IB 
(iv) Show that it suffices for universality to restrict the requirement to 
vertical / , as above. 
E 
9.2.13. 
Consider a 
fibration 
^ ^ with disjoint and universal coproducts ] J 
as 
in the previous exercise. In the following we establish a fibred version of 
Proposition 1.5.4, involving change-of-base of a codomain fibration along a 
copower functor. 
(i) 
Prove that if maps f,g:Y^Xm]E 
above the same map in B satisfy 
u(X) 0 f = u(X) og:Y-^ 
JJJ-'^). then f = g. 

534 
Chapter 9: Advanced fibred category theory 
(ii) Consider vertical maps f,g in a. commuting square in E of the form: 
h 
X 
niY) 
-^ Z 
\9 
f 
Uu(n 
Show that this square is a puUback in E if and only if the canonical 
map ]J[^(-^) -> ^ is an isomorphism. This shows that for u: I —^ J the 
canonical functor E j / y -> E j / JJ^C^) is an equivalence, 
(iii) Prove the converse of (ii): if for each map w: / -> J in IB and object 
y € E/ the canonical functor E / / y ^ E j / JJ (Y) is an equivalence, 
then coproducts ]J 
are disjoint and universal. 
[A fibration with this property may be called extensive. ] 
(iv) Consider for a map u: I —^ J in B and for objects X G Ej and y G E/ 
the following diagram in E 
u(X) X u(Y) 
u'{x) X y 
^-^ X X u j n 
ujy) 
niY) 
(The Cartesian products are in the fibres, and the two projections are 
vertical.) Prove that this diagram is a puUback, and conclude from (ii) 
that the Frobenius property automatically holds. 
(v) Define for each / G B an object ]J(/) in the fibre Ei over the terminal 
object 1 G B by 
where T:B —>• E is the terminal object functor. Extend ]J to a functor 
B —>• El and show that it preserves finite hmits. 
(vi) Check that the whole fibration p can be recovered from its fibre cate-
gory El over 1 G B via the following change-of-base situation. 
E 
ET 
cod 
U 
- * E i 

Section 9.3: Quantification 
535 
9.3 Quantification 
Earlier we have seen various forms of qimntification: along Cartesian pro-
jection morphisms TT: I x J -> / i n Definition 1.9.1, along arbitrary mor-
phisms u: I -> J in Definition 1.9.4, along Cartesian diagonal morphisms 
S{I, J) = (id, TT'): / X J -> (/ X J) X J in Definition 3.4.1 and also along the 
Cartesian projection maps TT: I x X ^ I induced by a CT-structure, see Def-
inition 2.4.3, and along monomorphisms m: X ^^ / in Observation 4.4.1. In 
this section we shall introduce a general description of quantification which 
captures all of the above examples (and many more). This will enable us to 
establish some results for all these forms of quantification at once. The gen-
eral theme is that products and coproducts f|, ]J are right and left adjoints 
to weakening functors, and that equality Eq is left adjoint to contraction 
functors. (With fibred exponents one then gets right adjoints to contraction 
functors for free, see Exercise 3.4.2.) 
Weakening introduces an extra dummy variable x'.a^ and contraction re-
places two variables x^y.a 
of the same type by a single one (by substituting 
[x/y\). 
Indeed, categorically, weakening and contraction are special cases of 
substitution, see explicitly in Example 3.1.1. These operations of weakening 
and contraction carry the structure of a comonad (VF, £:,(J), where the counit 
Ex' WX 
-^ X corresponds to weakening, and the comultiplication (also called 
diagonal) 8x '• WX —f W^X 
to contraction. Intuitively, the comonad equations 
S o eW = id and S o We — id correspond to the fact that first weakening and 
then contracting is the identity, in two forms: 
{T,x:(T \- M\T) 
H^ (r,x:cr, y:cr h M : r ) i-> {T, x: a \- M[x / y]\ r) 
{V,x:a 
\- M:T) 
I-> {V,y\a,x\a 
\- M\T) 
\-^ (T,y\a 
\- 
M[y/x]\T) 
For the second one we need a-conversion (change of variables). 
Below we shall describe quantification f|, JJ, Eq with respect to an ab-
stract "weakening and contraction comonad" [W,e,S). 
Since weakening and 
contraction are operations which—by their nature—change the context, this 
comonad will be on the total category of a fibration. Product and coproduct 
are then right and left adjoints to the weakening functors induced by e and 
equality is left adjoint to the contraction functor induced by 6. This sums up 
the basic framework. 
It turns out that a "weakening and contraction comonad" on the total cat-
egory of a fibration corresponds to certain structure in the base category, in 
terms of which we can also describe quantification. Part of this correspondence 
was noted by Hermida. The latter structure will be called a "coniprehension 
category" (following [154, 157]). It is somewhat more elementary than a weak-
ening and contraction comonad. It will be fundamental for type dependency 

536 
Chapter 9: Advanced fibred category theory 
in the next chapter. Therefore, in the sequel we shall mostly be using these 
comprehension categories—instead of weakening and contraction comonads. 
But we start with comonads. 
E 
9.3.1. Definition. Let 
j^P be a fibration. A weakening and contrac-
tion comonad on p consists of a comonad {W,6,S) on the total category E, 
satisfying: 
(1) Each counit component Sx' WX —>• X is Cartesian. 
(2) For each Cartesian morphism /: X ^ Y in E, the naturality square, 
is a pullback in the total category E. 
The first of these conditions says that weakening is a special case of substi-
tution (see also Example 3.1.1), and the second one is a stability condition. As 
a consequence of this second condition the functor W preserves Cartesianness. 
But note that W is not a fibred functor p —^ p since we do not necessarily 
have p o W = p. And note also that the counit e and comultiplication S need 
not be vertical. 
If we apply the second condition with f — sx we get a pullback square 
W{ex) 
W^X 
^ WX 
J 
WX 
ex 
ex 
-^ X 
This shows that the diagonal Sx- WX -> W^X is completely determined as 
the unique mediating map for the cone WX f^— WX -^ 
WX, with respect 
to this pullback. It is not hard to see that these Sx^s are also Cartesian. In 
fact, if we only have a pair (M^, £:) satisfying (1) and (2) above and define Sx 
in this way we get a natural transformation satisfying the comonad equations. 
Hence the above definition contains some redundancy. But we like to keep it 
as it stands in order to stress that weakening and contraction form a comonad. 
Two standard examples are as follows. For a category B with finite prod-
ucts there is a weakening and contraction comonad on the associated simple 

Section 9.3: Quantification 
537 
fibration 
i 
with functor VFisf 
- > s 
given by 
(/,X) ^{I 
xX,X) 
and (Cartesian) counit 
(7 X X , X ) 
(/,X) 
The (induced) comultiplication is 
% , x ) = ( ( i d , 7 r ' ) , ^ ' ) 
(/ X X,X) 
^ ((/ X X) X 
X,X) 
For a category IB with finite limits there is a weakening and contraction 
comonad on the associated codomain fibration 
i 
maps 
The functor B"^ 
( 
XxjX 
We turn to quantification with respect to a weakening and contraction 
comonad. 
9.3.2. Definition. Let W 
= 
[W^e^6) 
be a weakening and contraction 
E 
P 
comonad on 
and let 
^^ be another fibration with base B. 
1 
B 
(i) This fibration q is said to have 14^-products if for each object X G E 
there is a right adjoint 
to the "weakening functor" p{sxy'-^pX 
—> ^pwx ^ together with a Beck-
Chevalley condition: for each Cartesian map / : X ^ 
Y in E, the canonical 
natural transformation 
{pWfY 
B>pWY 
n. 
^ 
{pfY 
n. 
^pY 
is an isomorphism. 
(ii) Similarly, q has jy-coproducts if there are left adjoints W^ H p[exY ^ 
and the canonical natural transformation U x ( ^ ^ / ) * ^ 
[pfY U y ^^ ^^ i^^" 
morphism, for each Cartesian map f\X-^Y 
in E. 

538 
Chapter 9: Advanced fibred category theory 
(iii) Finally, q has W^-equality if there are left adjoints Eqx H piSxY 
to 
the "contraction functors" p{Sx)*j and for each Cartesian map f:X 
-^Y 
in 
E, the canonical natural transformation 
Eqx 
(pWfY 
^ 
ipW'f) 2n* 
B>pWY 
Eqy 
J^pW^Y 
is an isomorphism. 
9.3.3. Definition. If the fibration q above has fibred Cartesian products 
X, then we say that q has W^-coproducts satisfying Probenius if it has 
ly-coproducts Y[j^ such that the canonical maps 
^ZxUxiY) 
UxiPi^xr{Z)xY) 
are isomorphisms. 
Similarly, for M^-equality satisfying Frobenius, one requires the canon-
ical maps 
Eqx 
{p(SxnZ)xY) 
ZxEqx(Y) 
to be isomorphisms. 
We can thus define quantification with respect to a weakening and contrac-
tion comonad in terms of the induced structure p(€x) and p{Sx) in the base 
category. It is not hard to see that quantification with respect to the weaken-
ing and contraction comonads described before Definition 9.3.2 gives simple 
and ordinary quantification. These weakening and contraction comonads are 
somewhat unpractical to work with, since what one is really interested in are 
these induced maps p{ex)'pWX 
—> pX and p{5x)-pWX 
-^ pW^X 
in the 
base category. It turns out that such a comonad can be recovered from this 
induced structure, if it is suitably described as a "comprehension category". 
This structure is much easier to use. Moreover, it will be of fundamental im-
portance in the categorical description of type dependency in the next chapter. 
Therefore we shall from now on mostly use these comprehension categories. 
(The aspect of 'comprehension' will be explained in the next chapter, see 
especially Corollary 10.4.6.) 

Section 9.3: Quantification 
539 
9.3.4. Theorem. Weakening and contraction comonads on a fibration jrP 
are in one-one-correspondence with functors V'.IE —^ W^ satisfying 
(1) cod o :P = p: E ^ B; 
(2) for each Cartesian map f in E, the induced square V{f) in B is a 
pullhack. 
Such a functor V will be called a comprehension category (on p). We 
shall often write {—} = dom o 'PrE —)• B. Thus V is a natural transformation 
Proof. Assume a comprehension category 'PiE 
functor P y : E ^ E b y 
W{X)=VX^X) 
with (Cartesian) counit 
B-^ on 
IP. Define a 
sx = {wx 
VX{X) 
X) 
A morphism / : X —> y jn E is mapped to the unique map Wf:VX*{X) 
—^ 
VY^Y) 
above {/} with VY{Y) oWf = f o VX{X). 
This makes s a natural 
transformation. 
Conversely, if a weakening and contraction comonad {W,s,S) is given, we 
get a functor :P: E -> B"^ by 
X ^ 
pWX 
\ 
ip{ex) I 
pX 
) 
and 
f ^ 
(pf^pWf). 
Then cod o V = p hy construction. Condition (2) in the theorem holds if 
and only if condition (2) in Definition 9.3.1 holds, since for a Cartesian map 
/: X —> y in E the diagram on the left below is a pullback in E if and only if 
the diagram on the right is a pullback in B, by Exercise 1.4.4. 
WX 
ex 
X 
Wf 
-^WY 
above 
/ 
- * y 
{X} 
vx 
Y 
pX-
{/} 
pf 
\VY 
Y 
•pY 
Finally, if we start from a comprehension category P, turn it into a comonad, 
with ex = VX{X)^ and then into a comprehension category again, we get back 

540 
Chapter 9: Advanced fibred category theory 
the original one: p[ex) — p{T^^{X)) 
— VX. And if we start with a weaken-
ing and contraction comonad, we get back a comonad which is (vertically) 
isomorphic to the original one. 
D 
By this result we have a notion of quantification with respect to an arbitrary 
comprehension category. This is the form which will be used mostly. Therefore, 
we make it explicit. An alternative formulation in terms of fibred adjunctions 
occurs in Exercise 9.3.8. 
9.3.5. Definition. Consider a comprehension category "PiE -^ IB"*" and a 
fibration 
m a situation 
We say that q has P-products / -coproducts / -equality if q has products / 
coproducts / equality with respect to the weakening and contraction comonad 
associated with V. Explicitly, this means the following. 
(i) The fibration q has P-products (resp. coproducts) if there is for each 
object X G E an adjunction 
VX*^Y[^ 
(resp. L I x ^ ^ ^ * W ) 
plus a Beck-Chevalley condition: for each Cartesian map f.X^Y 
in E, the 
canonical natural transformation 
(P/)* XIY =^ Ux {/}* 
(resp. Ux {fV 
=> (Pfr 
Uy) 
is an isomorphism. 
(ii) And q has P-equality if for each X G E there is an adjunction 
Eqx H S'x 
where Sx is the unique mediating diagonal (id, id): {X} -^ {VX*{X)} 
in 
VX 

Section 9.3: Quantification 
541 
where TT = V{VX''[X)) 
and TT' = {PX{X)] 
are the pullback projections. 
Additionally there is a Beck-Chevalley requirement: for each Cartesian map 
/ : X —> y in E, the canonical natural transformation 
Eqx {/}* =^ {f'Y 
Eqy 
should be an isomorphism—where / ' is the unique morphism in E over {/} 
m, 
7^X*(X) 
^VY''{Y) 
^ 
f 
X 
^Y 
This lemma provides us with various examples of quantification. We con-
sider the most important ones explicitly. 
9.3.6. Examples, (i) The weakening and contraction comonad on a simple 
s(IB) 
fibration 
i 
described earlier in this section corresponds to a comprehension 
category s(IB) -^ B"^ mapping 
/ 
IxX 
(as described in Exercise 1.3.1). It is now much easier to see that simple 
products and coproducts (along Cartesian projections) is quantification with 
respect to this "simple" comprehension category s(B) —)• IB~^. 
The diagonals 6{I, J) of this simple comprehension category are the mor-
phisms 
J(/,J):=(id,7r') 
IxJ 
^ {I xj)x 
J 
That is, the Cartesian diagonals S{I, J) as used in Definition 3.4.1 for defining 
simple equality. 
And if we have a CT-structure (B, T) where T C Obj B then we have a simi-
lar comprehension category s(T) -^ B~^ on the simple 
fibration 
4- 
mapping 
a pair / G B and X E T to the Cartesian projection I x X ^ 
I. Products 
and coproducts with respect to this comprehension category are what we have 
called "simple T-products" and "simple T-coproducts" in Definition 2.4.3. 
(ii) Next we consider the earlier weakening and contraction comonad on the 
codomain 
fibration 
I 
of a category B with finite limits. The corresponding 

542 
Chapter 9: Advanced fibred category theory 
comprehension category B"*" -> B"^ is simply the identity functor. Products 
and coproducts with respect to this comprehension category are products and 
coproducts along all morphisms in B, as in Definition 1.9.4. The diagonal on 
a family ( | 
I is the mediating map X —> X X/ X. 
(iii) The inclusion Sub(B) ~> B"*" for a category B with finite limits is a 
comprehension category on the subobject fibration on B. Products and co-
products with respect to this comprehension category Sub(B) -> B"^ involves 
products Yl^ and coproducts JJ^ along all monomorphisms m in the base 
category B. 
In due course, we shall see many more examples of quantification with re-
spect to a comprehension category. In the remainder of this section we describe 
some basic notions and results associated with the general form of quantifica-
tion with respect to a comprehension category. We start by making explicit 
what preservation of products, coproducts and equality means in this general 
setting. 
9.3.7. Definition. Let 
-j^ —> ^^ be a fibred functor (over B). Suppose 
that the fibrations q and r have products (resp. coproducts or equality) with 
respect to some comprehension category "PiE ^ B~^. We say that H pre-
serves P-products (resp. coproducts or equality) if for each appropriate pair 
of objects X E E, ^ G D, the canonical map 
(resp. UxiHA) 
^ HUxi^) 
«' 
^cix(HA) 
^ 
HEqx(A)) 
is an isomorphism. 
There is the following situation, which is as for ordinary categories. The 
proof is easy and left to the reader. 
9.3.8. Lemma. Fibred right adjoints preserve products fj (with respect to 
some comprehension category). Fibred left adjoints preserve coproducts ]J and 
equality Eq. 
• 
A standard categorical result is that a reflection A ^ B induces products 
and coproducts (like x and -h) in A if they exist in B. (By a 'reflection' 
we mean an adjunction {F H G) with an isomorphism FG ^ id as counit; 
or equivalently, with a full and faithful functor G as right adjoint.) In Ex-
ercise 9.3.9 below one finds the fibred analogue applying to fibred products 

Section 9.3: Quantification 
543 
like X and plus -h. Here we mention the version applying to products H? 
coproducts W and equality Eq with respect to a comprehension category. 
9.3.9. Lemma. Consider a fibred reflection {F H G) and a comprehension 
category V in the following situation. 
Then, if the fibration r has products / coproducts / equality with respect to the 
comprehension category P i E -> B~^, then so has the fibration q. Moreover, 
the right adjoint G preserves the induced products. 
Proof. The case of coproducts is easy: for objects X G E and yl G O above 
{X}, define 
3x{A) = 
F]\^(GA) 
where W^ is the assumed left adjoint to VX*:Cpx 
-^ ^{X} - Then we get 
coproduct correspondences: 
3x{A):=FUx{GA) 
^B 
UxiGA) 
^GB 
GA 
^ VX*{GB) 
^ G('PX*(J5)) 
VX''[B) 
the latter, because G is a full and faithful functor. Thus we have adjunctions 
{3x H VX*). Equality is transferred to q in the same manner. 
For products, we define, as for coproducts, 
'ix{A) = 
FX\^{GA). 
We first show that the unit 
XlxiGA) 
GFYl^iGA) 
= G^x{A) 
is an isomorphism. Its inverse is obtained by transposing the composite 
S 
GF{e) 
VX*{GFY[x{GA))) 
^GFVX'YlxiGA)) 
^GFGA^GA 

544 
Chapter 
9: Advanced fibred category 
theory 
Then there are product correspondences: 
B 
^^x{A) 
GB 
G^x{A) = Y[x{GA) 
G{VX* (5)) 2 VX* (GB) 
^ GA 
VX*{B) 
-* A 
D 
9.3.10. Lemma. Let 
^P and 
i1 be two fibrations on the same basis 
P X I B E 
(with q cloven). Form the 
fibration 
^^ \P) by change-of-base. A com-
prehension category "PiE ^ W^ on p can then be lifted to a comprehension 
category q*{V) on q*{p), in a diagram: 
p*(9) 
by assigning to A ElD) and X G E above the same object in B the map 
VX{A) 
q*{V){A,X) 
= {VX*{A) 
^A) 
in D above VX. 
Proof. For amorphism (/,5^): (^,-^) -^ i^^^) 
i n D x i E we get a commuting 
square in D 
/ 
/' 
^ 
VX*(A) 
^VY*(B) 
\ 
f 
\ 
\ 
A 
-B 
j 
where / ' is the unique map above {^} making the square commute. This yields 
a comprehension category since if the map (/, g) is Cartesian in D x^ E, then 
g is Cartesian in E, so that the underlying square V{g) in B is a pullback. 
Hence the above square q*{V){f,g) is a pullback in D by Exercise 1.4.4. 
• 
<l'(V)(f,9) = 
above 
T^id) 

Section 9.3: Quantification 
545 
In the "logic of types" in polymorphic predicate logic (over polymorphic 
type theory) in Section 8.6 we have been somewhat vague about the precise 
categorical formulation of quantification Ma: A.(p and 3a: A. (f oi propositions 
E 
over kinds. In the categorical set-up we used one fibration 
\P over types 
IB 
P 
over kinds, and another (preorder) fibration 
J;^ of propositions over types. 
IE 
We suggested that this form of quantification involved quantification along 
the liftings in E of the Cartesian projections in B. At this stage we have the 
D) 
technical means to be more precise: what one needs is that the fibration i has 
products and coproducts with respect to the simple comprehension category 
5B = (s(B) -^ B~^) lifted along p. That is, q should have p*(5i)-products and 
coproducts. 
Exercises 
9.3.1. 
(i) Show that a weakening and contraction comonad on the total category 
E of a fibration, restricts to a comonad on the subcategory Cart(E) «—)• 
E with Cartesian maps only. 
(ii) Assume we have a functor W on the total category of a fibration to-
gether with a natural transformation e.W =^ id satisfying conditions 
(1) and (2) in Definition 9.3.1. Prove that there is a unique natural 
transformation S:W ^ W^ making (W^e^S) a (weakening and con-
traction) comonad. 
P 
9.3.2. 
Let j^^ be a fibred CCC which has coproducts or equality with respect to 
IB 
a comprehension category "P: E ^ B~^. Show that the Frobenius property 
is automatically satisfied. 
9.3.3. 
Give explicit descriptions of all canonical maps in this section: in Defini-
tions 9.3.2, 9.3.3 and 9.3.7. 
9.3.4. 
Prove Lemma 9.3.8. 
9.3.5. 
Investigate what the Beck-Che valley condition says about substitution in 
products WaiA.if and coproducts 3a: A. (p of propositions over kinds in 
P 
T 
the term model j^ over i (as described in Section 8.6), assuming that 
these V and 3 are described categorically wrt. a lifted simple comprehension 
category, as mentioned after the proof of Lemma 9.3.10. 
n 
9.3.6. 
Let 
^9 be a fibration and "P: E —>• B"^ a comprehension category on p. 
IB 
Show that q has T'-coproducts if and only if both: 
• for each X G E and A £ ]D> above {X}, there is an opcartesian map 
A-^]J^(A) 
above VX; 

546 
Chapter 9: Advanced fibred category theory 
• for each Cartesian map /: X —>• K in E and each commuting diagram 
9 
in D, above the puUback square V{f) in B, one has: 
s is opcartesicin over VY "j 
g is Cartesian over {/} 
> =J> r is opcartesian over VX. 
h is Cartesicin over pf 
J 
Give a similar reformulation for equality in terms of opcartesicin maps. 
9.3.7. 
Genercilise Exercise 3.4.2 (ii) to arbitrary comprehension categories: show 
that if a fibred CCC q has P-equality then each T'-contraction functor (also) 
has a right adjoint in q. 
P 
9.3.8. 
Consider a comprehension category VilK —^ B~^ and a fibration j^Q 
w 
as in Definition 9.3.5. The natural transformation V: {—} => p gives by 
Lemma 1.7.10 rise to a fibred functor {V):p*{q) —>• {—}*{q)' It turns out 
that quantification with respect to V can be described in terms of adjoints 
to (P), as in [74, Definition 7]. 
(i) 
Prove that the fibration q has products (resp. coproducts) with respect 
to V if and only if {V) has a fibred right (resp. left) adjoint. 
(ii) Formulate and prove a similcir result for equality. 
9.3.9. 
Let G: A -> B be a full and fciithful functor, which has a left adjoint F (so 
that we have a reflection). Recall the following basic results. 
(a) If B has coproducts +, then so has A, given by XvY 
= F{GX + GY). 
(b) If B has products x, then so has A—given hy X^Y 
= F{GXx 
GY)— 
and G preserves them. 
[The proof of (a) is straightforward, but (b) is slightly more complicated; 
one first shows that the unit r;: GX x GY —> G{X A Y) is an isomorphism. 
Its inverse is {G{ex) o GF(7r),G(£y) o GF(7r')).] 
(i) 
Extend the above results to other limits. 
E 
0 
(ii) Extend it also to fibred reflections: assume 
fibrations 
jP and 
z^ 
and a full and fciithful fibred functor G: E -> D, which hcis a fibred left 
adjoint F. Show that if q has fibred (co)products (like x cind +), then 
so has p. And that G preserves the products. 

Section 9,4- Category theory over a fibration 
9.4 Category theory over a fibration 
547 
Up to now we have mostly been studying a single level of indexing, given by 
one category being fibred over another. Typical are situations with a logic fi-
bred over a simple type theory—as in logics of equations or of predicates—or 
with a calculus of types fibred over a calculus of kinds—as in polymorphic cal-
culi. But in order to study a "logic of types" over a polymorphic calculus, one 
has propositions fibred over types and types fibred over kinds, as described in 
Section 8.6. Such double levels of indexing will be investigated systematically 
in this section. Technically, this will involve fibrations, not in the 2-category 
Cat of categories, but in the 2-categories Fib(B) and Fib of fibrations over 
a fixed basis B, and over arbitrary bases (see Section 1.7). We shall use the 
2-categorical formulation of the notion of fibration from Street [315, 317], 
based on Chevalley's result in Exercise 1.4.8. This gives a suitably abstract 
reformulation of when a functor p:E ^ B is a cloven fibration, in terms of 
the existence of a right adjoint to a canonical functor (E 4 E) —)- (B | p) 
between comma categories. Since adjunctions can be formulated in arbitrary 
2-categories, we only need suitable comma-objects. 
Recall, e.g. from [36, 1.6.1-1.6.3], that the universal property of a comina 
object (/ ; g) of two 1-cells A-^ 
C i^- B in a 2-category can be formulated 
as follows. There are projection maps A <— (/ 4- g) —> B together with a 
2-cell 
{fig) 
which are universal: for any object D with 1-cells A i— D —> B and a 2-cell 
7: [f o a) =^ {g o b) there is a unique 1-cell d\ D —> (/ I g) with 
htod= 
a, 
snd o d—b, 
ad = 7. 
A special case is the arrow objecton an object C; it is written as 
C ^ = (C ; C) = (idc i idc). 

548 
Chapter 
9: Advanced fibred category 
theory 
It is characterised by the correspondence between 
1-cells A 
^ C^ 
2-cells A 
\^ 
C 
Thus, the arrow category C^ on a category C is the arrow-object in the 
2-category Cat of categories. And the comma category (F I G) of functors 
F 
G 
. 
A —y C <— B is the comma object in Cat. Recall that this comma category 
(F i G) has 
objects 
triples {X, ^, Y) where X G A, y G B and 99: FX ^ GY 
inC. 
morphisms 
(X, ip, Y) -> [X',(p\ Y') are pairs of maps /: X -^ X' in A 
and ^: y ^ y in B with if' o Ff = Gg o <f. 
9.4.1. Definition (Following [315, 317]). Consider a 1-cell p: E ^ 
B in di 
2-category, and assume that the comma objects E^ = (E I E) = (id^; I id^;) 
and {B I p) = (id^ | p) exist. There is then a unique mediating 1-cell 
p: E^ —-)• [B \. p), in the following situation. 
(For the obvious 2-cell p o fst => snd o p: E^ ^ 
B.) 
We say that p is a (cloven) fibration in this 2-category if the induced map 
p has a right-adjoint-right-inverse; that is, if p has a right adjoint p such that 
the counit of the adjunction (p H p) is the identity 2-cell. 
For an ordinary functor p:E ^ B the induced functor p:E^ -^ {M I p) 
sends (/: X -^ y) »-> (pX,/, X). And p is a fibration in Cat (according to 
this definition) if and only if p is a cloven fibration, see Exercise 1.4.8. 
We split this section in two, by first considering fibrations in a 2-category 
Fib(B) and then in Fib. 

Section 9.4-' Category theory over a fihration 
549 
Fibrations 
over fibrations 
with a fixed base 
category 
We first observe the following. 
9.4.2. Lemma. The 2-category Fib(IB) of fibrations over a fixed base category 
B has comma objects: for two maps of fibrations p —> r i— q in a 
situation 
G 
V(FiG) 
The total category of their comma 
fibration 
i 
is the full 
subcategory 
V ( F ; G) ^ 
^ {F i G) 
of the ordinary comma category, on the vertical maps (^: FX —> GY m C. It 
IS fibred over M via the functor 
{(p: FX -^ GY) i-^ pX = qY. 
E 
In particular, 
for a fibration -^P the arrow object p~^ in Fib(B) exists. 
We 
V(E) 
write it as 
i 
where V(E) ^-> E"^ is the full subcategory on the vertical 
maps. 
Sometimes 
we write Vp(E) instead o/V(E)^ in order to have the 
dependence 
on p 
explicit. 
Proof. The category V ( F J, G) is fibred over B since for an object (ip: FX -> 
GY) 
G V ( F I G) and a map u: I -^ pX in B we have a lifting given by 
combining the liftings u{X):u''{X) 
-^ X in E and u(Y):u*{Y) 
-> Y in D in 
a diagram: 
F(u(X)) 
I 
I 
u^p) 
\ 
\<P 
Y 
G{u{Y)) 
\ 
G{u'{Y)) 
^ GY 
pX 
There is then an obvious vertical natural transformation 
V(FiG) 
4 

550 
Chapter 9: Advanced fibred category theory 
with the required universal property. 
D 
We can now characterise fibrations in a 2-category Fib (IB) of fibrations over 
a fixed base category B. 
P 
E 
9.4.3. Proposition. Consider 
two 
fibrations 
Ul and 
iP 
over M, and a 
morphism 
r:q -^ p of fibrations, as in: 
- ^ E 
The following 
statements 
are then 
equivalent: 
(i) r: q —^ p is a fibration in Fib(B), i.e. the induced fibred functor 
r in 
V(D) 
V(idp; r) 
has a fibred right-adjoint-right-inverse 
(in Fib(IB)^; 
(ii) r is itself a cloven 
fibration; 
(iii) r is ^fibrewise a cloven fibration": for each object I EM the 
functor 
q-Hn=^i 
ri 
-^Ei=p-'il) 
obtained 
by restricting 
r to the fibres over I, is a cloven fibration, and for 
each morphism 
u: J —^ I in M and p-reindexing 
functor 
w*:E/ —>• Ej 
there 
is a q-reindexing 
functor 
u ^ : D / -> D j forming 
a morphism 
of fibrations (in 
Fib;. 
D/ 
^ D j 
/ / one of these conditions 
holds, then one calls r a fibration over p. 
Proof, (i) => (ii) Assume the functor r has a fibred right adjoint r, and that 
the counit f r => id is the identity. For an object A ElD and a map 
f:X-^rA 
in E, we first write / as a vertical map g:X 
-^ r{u'^{A)) 
followed by the 

Section 
9.4-' Category 
theory over a 
fibration 
551 
Cartesian map r{u{A)) as below. This g is then an object (X,^,w^(A)) G 
V(idp 4 r), so we can apply the right adjoint r. This yields a vertical map 
r{g):A' -^ u'^(A), as in: 
u'^iA) 
X 
-^ rA 
E 
9 r^iu^iA)) 
{u{A)) 
It is not hard to see that the resulting composite A' —^ A is an r-Cartesian 
lifting of /. 
(ii) => (iii) The fact that all the r/'s are fibrations is already stated in 
Lemma 1.5.5 (ii). One obtains a morphism of fibrations as in the square in (iii) 
above, since for each reindexing functor t/*:E/ -^ Ej one can choose w* as 
follows: for A e Bj with rj(A) = X G E/, take i/#(A) to be the domain of 
the r-Miting of u{X): u* {X) -^ X, like in the proof of Lemma 1.5.5 (i). 
(iii) => (i) One defines a right adjoint r as follows. For a vertical map (p: X ^ 
rA, say over / G B, take r{(f) to be the r/-Cartesian lifting ^(A): f>*{A) -> A 
in D. Commutativity of the diagram in (iii) ensures that r is a fibred functor. 
D 
We mention some examples of fibrations over a fibration (in Fib(]B)). Recall 
from Definition 8.5.3 (and Lemma 8.5.4) the simple fibration over a fibra-
E 
tion: for a fibration 
jrP with fibred finite products, one obtains a fibration 
Sp(E) 
^^p on top of p. Notice that for each object / G B, the fibrewise fibration 
Sp(E)/ ^ 
^ 
_ 
_ 
s(E/) 
i 
is the (ordinary) simple fibration 
i 
on the fibre category E/. 
E 
If 
-^P is a fibration with fibred finite limits, then the codomain functor 
V(E) —)• E is also a fibration over p. It will be called the codomain fibration 
V(E)j 
^ 
E / - ' 
over p (in Fib(B)). The fibre fibration 
i 
is the codomain fibration 
i 
on the fibre category E/. See Exercise 9.4.2 below for some more details. 
These two examples generalise the simple and codomain fibrations over 
categories to simple and codomain fibrations over fibrations: one recovers the 
ordinary simple and codomain fibrations "fibrewise". 

552 
Chapter 
9: Advanced fibred category 
theory 
The "logic over types" in polymorphic predicate logic (PPL) as described 
in the beginning of Section 8.6 is described by a preorder fibration (giving us 
a logic) over a polymorphic fibration. In this same section we have described 
p 
a term model example of a fibration i of propositions over types, which is a 
T 
fibration over a fibration I of types over kinds. 
^ 
. 
As another example of such a fibration for PPL we mentioned the logic of 
UFamRegSub(PER) 
ree^ular subobjects of families of PERs in 
i 
over families of 
^ 
*^ 
UFam(PER) 
UFam(PER) 
PERs in 
4- 
, as defined in Example 8.6.1. 
CJ-Sets 
Along the lines of the previous example, we can form for a category B 
FamSub(IB) 
with finite limits, the fibration 
^_^ 
giving us the logic of subobjects on 
families in B via the change-of-base situation: 
FamSu 
J 
Sub(B) 
dom 
Such fibrations will be used later in a "logic over dependent type theory", see 
Section 11.2. 
Fibrations over fibrations over arbitrary base categories 
As a first step towards the description of fibrations in the 2-category Fib we 
start by identifying comma objects in Fib. 
9.4.4. Lemma. The 2-category Fib of fibrations over arbitrary base cate-
{P H\ 
IC K\ 
gories has comma objects. For two maps of fibrations q —^ r f-^ 
p m a 
diagram 
H 
K 
E 

Section 9.4' Category theory over a fibration 
553 
there is a comma fibration 
in Fib, 
({F,H)l{G,K)) 
((Hi 
K) 
\ 
I 
(FIG) 
where {H I K) and {F I G) are the ordinary comma categories in Cat, and 
where the functor 
[H \. K) -> (F j, G) sends 
^ 
[^) 
(HA 
^ KX) 
^ 
[FQA 
= rHA 
^ rKX 
= 
GpX) 
In particular, 
for a fibration 
i-P the arrow object p~^ exists in Fib, and 
can be identified 
as 
^^ 
Notice that we have overloaded the notation p~^ by using it both for the 
V(E) 
E-^ 
arrow fibration 
i 
in Fib(B) and for the arrow fibration -^ .in Fib. When-
. 
®. 
. 
.
.
. 
.® 
ever confusion is likely, we shall mention explicitly in which 2-category the 
arrow construction (—)'^ lives. 
Proof. We only show that the functor 
i 
is a fibration, since it is easy 
^ 
(FIG) 
' 
-^ 
to check that it has the appropriate universal property (as comma object in 
Fib). Consider an object {HA -^ KX) 
in the total category {H I K), and a 
morphism (ti, v): a —> ^{^) ^^ the base category [F I G) in a. diagram: 
F{I) 
a 
Y 
G{J) 
F{u) 
G{v) 
F{qA) = 
r{HA) 
r((p) 
-^ G{pX) 
= 
r{KX) 
We first take Cartesian maps u{A):u*{A) 
—> ^ in D over u: I -^ qA in A, 
and v{X): v* {X) -> X in E over v: J ^ pX in B. Then we let {u, vy{(p) 
be 
the unique mediating map H{u*{A)) 
—^ K{v*{X)) 
over a with K{v{X)) 
o 
{u,v)*{ip) 
— <f o H{u{A)). 
This gives a Cartesian morphism {u,v)*{(f) 
-^ (p 
in {H i K) over (w, v) m{F 
iG). 
• 

554 
Chapter 9: Advanced fibred category theory 
9.4.5. Proposition. Consider two fibrations iQ and 
iP and a morphism 
{K, H):q—^p of fibrations: 
D 
H 
• * E 
K 
The following are then equivalent: 
(i) {K,H):q 
—^pisa 
fibration 
(over a fibration^ in Fib, i.e. the 
induced fibred functor {K, H) = {K ,H) in 
IT* 
H 
K 
(EIH) 
(pi{K,H)) 
IK) 
has a fibred right-adjoint-right-inverse 
(in Fib^; 
(ii) both H and K are cloven fibrations, and {p, q) is a map of fibrations 
H —)• K which strictly preserves the cleavage. 
Proof. Because:^i/ and K are cloven fibrations if and only if Jhe induced 
functors H and K both have a right-adjoint-right inverse, say H and K re-
spectively. And: commutation of the diagram q~^ o H = K o [p \^ {K, H)) 
means that the cleavage is preserved. Finally, H is automatically a fibred 
functor by Exercise 9.4.4. 
• 
E 
We can also describe codomain and simple fibrations in Fib. Let 
jrP be 
a fibration with pullbacks in Fib. This means that the base category B has 
(chosen) pullbacks and that the total category E has (chosen) pullbacks, which 
are strictly preserved by the functor p. (Equivalent to the existence of pull-
backs in E is the existence of fibred pullbacks in p, see Proposition 9.2.1.) We 
then have two codomain 
fibrations 
i 
and 
i 
on E and on IB forming 

Section 9.4' Category theory over a fihration 
555 
a fibration -J-, over i in: 
Er^ 
E 
(cod, cod) 
This describes the codomain 
fibration 
i 
on » in Fib. 
p 
There is also a simple fibration in Fib 
^P with Cartesian products in Fib 
(see [129]). The latter means that IB and E have Cartesian products and that 
p strictly preserves them. These Cartesian products in E may be described 
via fibred Cartesian products A in p—like in Proposition 9.2.1. We form a 
S(E) 
fibration 
I 
over p, by stipulating that the new total category S(E) has 
s(B) 
objects 
triples {X,I,X') 
where X,X' 
e E and / G B satisfy 
p(X') =pX 
xl. 
morphisms 
(X, /, X') —>• (Y, J, Y') are triples of maps /: X —>• Y in E, 
u:pX X I ^ J inM and /': 7r*(X) A X' -^ Y' in E over 
(pf o 7r,u):pX X I ^ pY X J. 
One gets a commuting diagram 
S(E) 
E 
- ^ s 
{XJ,X')^ 
by 
p 
X H 
^{pXJ) 
—^pX 
S(E) 
E 
^ 
^ 
^ 
s(p) 
ffivine: us a fibration 
>!- over ^l- . It is the simple fibration 
4- on p in Fib. 
^ 
^ 
s(l) 
1 
^ 
P 
For an object X G E over / G B, the "fibre fibration" 
i 
is used in [129] as 
s(l)j 
the fibration resulting from p by adjoining an indeterminate of a "predicate" 
X t o p (in Fib). 

556 
Chapter 9: Advanced fibred category theory 
Here is a different example. For a category 
be the category of deliverables in B. It has 
with finite limits, let Del(]B) 
objects 
pairs of subobjects X y-^ I and U >-^ I x A. 
morphisms 
{X ^^ I,U >-^ I x A) —> {Y ^^ J,V >-^ J x B) are pairs 
of maps u\ I —^ J and v: I x A ^ 
B for which there are 
(necessarily unique) dashed maps: 
X 
Y 
V 
and 
U 
Y 
I 
xA 
{U O TT, v) 
^ V 
Y 
J X B 
Following the terminology of [217] one calls u a "first order deliverable" and 
V a "second order deliverable". These u and v can be seen as programs, and 
the dashed arrows indicate that they satisfy certain specifications—given as 
predicates. Such deliverables are used in a combined development of a program 
together with a proof that it satisfies a specification, see [217]. 
Del(l) 
Sub(l) 
One now gets a fibration 
^ 
over the subobject fibration 
4- 
in: 
^ 
s(B) 
*^ 
IB 
Del(B) 
Su 
^ s 
by 
{X ^ I,U ^ I xA) 
I 
^ (/, A) 
(X - /) h 
We mention one last example: in Remark 8.6.4 (iv) we have a fibration 
RFam(PER) 
i 
over 
R P E R 
PFam(PER)^ 
PPER^ 
. It gives the fibration of relations over the (prod-
uct with itself of) fibration of parametric families of PERs. 
Doubtlessly, many more examples of fibrations in Fib may be found in the 
literature. It is not clear at this stage, precisely what kind of logics one can 
describe with these fibrations over a fibration in Fib. Logics over polymor-
phic type theory, like in [273, 326], to reason with parametricity are likely 
candidates. The last of the above examples suggests such a link. 

Section 9.4-' Category theory over a fibration 
557 
Exercises 
9.4.1. 
Consider the fibred functors F^G in Lemma 9.4.2. Prove for a morphism 
( / , ^ ) : ( X , ^ , y ) - ^ ( X ^ c ^ ^ y O t h a t 
{
f:X 
-^ X' is Cartesian in E 
and 
g:Y ^Y' 
is Cartesian in D. 
9.4.2. 
Let 
-^P be a fibration with fibred finite limits, and consider its arrow 
V(E) 
fibration 
i 
in Fib(B). 
IB 
(i) 
Prove that the codomain functor V(IE) —> E is a fibration. Show that 
it has fibred finite limits again. 
(ii) Check that there is a change-of-base situation 
E 
V(E) 
- ^ E 
where 1:B -^ E is the terminal object functor, 
(iii) Notice that for a category A with finite limits, the ordinary codomain 
A-^ 
^ 
^ 
_ 
V(A) 
A 
fibration 
I 
is the codomain 
fibration 
i 
over ^ . 
A 
^ 
A 
_ 
1 
(iv) Describe the arrow fibration over an arrow fibration. 
E 
9.4.3. 
Let 
IP be a fibration with fibred finite products. Call a subset T C Obj E 
closed under substitution if for every Cartesian map f: X -^ Y in IE with 
Y £ T also X £ T. Such a collection T forms a fibred CT-structure. 
Sp(T) 
Define an associated (generalised) simple 
fibration 
4- 
over p. 
9.4.4. 
Consider adjunctions (F H G,r],e) and (F' H G',rf',e') 
in a situation 
G' 
E 
F' 
G 
•^ 
A 
where qoF' 
= Fop^poG' 
= Goq and r}', e sit over ry, e. Prove that the 
pair (C, G') is then automatically a morphism of fibrations q ^ p {i.e. that 
G' is a fibred functor). 
[Notice that Exercise 1.8.5 is a special case.] 

558 
Chapter 9: Advanced fibred category theory 
9.4.5. 
(i) 
Define composition in the category S(E) in the construction of the 
simple fibration in Fib, and show that S(E) is fibred over s(]B) and 
over E, in such a way that liftings are preserved appropriately. 
Del(B) 
(ii) Check also that the 
fibration 
4- 
of deliverables is fibred over the 
^ ^ 
s(IB) 
Sub(B) 
subobject 
fibration 
4-
9.5 Locally small fibrations 
Recall that an ordinary category C is called locally small if for each pair of 
objects X , y E C the collection C{X,Y) 
of morphisms X -^ Y in C is a 
set^ as opposed to a proper class. That is, each collection C(X,Y) 
is an ob-
ject of the category Sets of sets and functions. From a fibred perspective, 
this dependence of the notion of local smallness on the universe of sets is an 
unnatural restriction. In fibred category theory one looks for a more general 
formulation which applies to arbitrary universes (or base categories). This is 
the same generalisation that led us in Section 1.9 from set-indexed products 
and coproducts to products and coproducts with respect to (objects and ar-
rows in) an arbitrary universe (given as base category of a fibration). In this 
section we shall investigate the fibred version of the notion of local smallness. 
It will turn out to have a close connection to comprehension. 
E 
In a 
fibration 
jrP, the base category IB provides a universe for the total 
category E. Local smallness for fibrations will involve a representation of hom-
sets in E as objects of B. The situation in ordinary category theory is captured 
Fam(C) 
as a special case via the family 
fibration 
i 
. Notice that, if C is locally 
small, then for every pair of objects X = {Xi)i^j 
and Y = {Yi)i^j in the total 
category Fam(C) over a set / we can form the disjoint union of all homsets 
C(Xi,Yi). 
It comes equipped with a projection function TTQ to /: 
Hom,(x,y) 1^' (IIc(Xi, y,)) 
—^i 
It forms a morphism in the base category Sets. There is then an obvious 
vertical map in Fam(C) over HomjiX.Y), 
namely 
rrJlX) -
^ 
KiY) 
given by 
(7ri)(,,^) = (X.- J
u 
Y^) 
This pair (TTOJTTI) satisfies a universal property: for any function u: J ^ 
I 

Section 9.5: Locally small 
fibrations 
559 
with a morphism f:u*{X) 
-> u*{Y) in Fam(C), there is a unique function 
v: J —> Homj(X,y) with TTQ o v = u and t;*(7ri) = f. Clearly this function v 
sends an element j ^ J to the pair (ti(i),/j) G UJG/^(^*'^*)* 
We have described the homsets of C using a language that makes sense for 
any fibred category. This formulation will be used in the definition of local 
smallness for fibrations below, in the form of a representability condition. The 
definition comes from Benabou [27, 29] (see also [36, II, 8.6]), just like almost 
all of the results in this section. 
The definition below makes use of a particular cleavage in a fibration, but 
it does not depend on the cleavage. Lemma 9.5.4 gives an intrinsic (cleavage-
free) reformulation. It is however less intuitive. Exercise 9.5.2 below contains 
another alternative formulation. 
E 
9.5.1. Definition. A fibration 
jrP is called locally small if for each pair of 
objects X, y G E in the same fibre, say over / E B, the functor from (B//)^^ 
to Sets—or to some suitably larger universe than Sets—given by 
{j-^^l) 
^—^Ej(t/*(X), i/*(y)) 
is represent able. 
In that case we write 
TTO 
UomjlX.Y) 
^ / 
for the representing arrow in B, which comes equipped with a vertical mor-
phism "of arrows" in E over Hom/(X,y), written as 
n*o{X) 
-7rS(y) 
It is such that for each map w: J —>• / in B together with a vertical morphism 
/: u*{X) —^ '^*{y) in E over J G B there is a unique mapf: J —^ 
RomjiX.Y) 
in B making the following two diagrams commute: 
where the dashed arrows are the (unique, Cartesian) mediating maps over v. 
Sometimes the subscript / in Homj(X, Y) is omitted if it is clear from the 
context in which fibre X, Y live. The intuition is that the fibre over i G / of 

560 
Chapter 9: Advanced fibred category theory 
/Hom,(X,y)\ 
the family I 
-y^ 
I in B// is the homset of vertical maps Xi -> Yf in 
E. 
We consider some examples. We have already seen that if a category C 
is locally small in the ordinary sense, then the associated family fibration 
Fam(C) 
i 
is locally small in the fibred sense. The converse is also true, since 
Sets 
one can consider objects X,Y 
of C as objects of Fam(C) over a one-element 
(terminal) set 1. The resulting set Horrid(X,y) is then the homset 
C{X,Y), 
since elements 1 —> Hom^fX, Y) correspond to maps X -^ y in C. 
Fam(c) 
The externalisation 
i 
of an internal (small) category C in an ambient 
category B yields a similar example of a locally small fibration. For objects 
X , y : / =4 Co in the fibre of Fam(C) over /, one forms a representing family 
Hom(X,y)\ 
1^0 
I via the pullback: 
J 
Hom(X, Y) 
^ Ci 
To 
{do,dr) 
-^ Co X Co 
For each w: J —)• / in B with vertical /: u*{X) —)• u*{Y) in Fam(C) over J, we 
have / as a morphism /: J —> Ci in B satisfying (9o,5i) o f = {X,Y) 
o u. 
This yields the required unique map v: J —-> Hom(X, Y) as mediating map 
for the above pullback. 
Finally, for an arbitrary category B with finite limits, the associated 
codomain 
fibration 
i 
is locally small if and only if the category B is lo-
cally Cartesianlosed: for a morphism u: J —> / in B and for families (p^tp G B/7 
over /, we have isomorphisms 
M/l{u*(^), 
«* W ) ^ B//( U . «*(^), i') = B//(« X V?, V). 
Hence the left hand side has a representing object if and only if the right hand 
side has one. That is, the codomain fibration is locally small if and only if all 
slices are Cartesian closed. 
In order to produce a non-example, we use the following easy result. It 
gives a relation between local smallness and comprehension (or subset types), 
as described in Section 4.6. The proof is not hard, but is postponed until Sec-

Section 
9.5: Locally small 
fibrations 
561 
tion 10.4 where we shall have more to say about comprehension (see especially 
Proposition 10.4.10). 
E 
9.5.2. Lemma. Let 
^P be a fibred CCC. Then p is locally small if and only 
the fibred terminal object functor 1:B -> E has a right adjoint. This right ad-
joint is then written as { — ] since it provides the fibration with comprehension 
(also called subset types, if p is a preorder 
fibration). 
• 
UFam(PER) 
9.5.3. Example. In Example 7.1.3 we saw that the 
fibration 
i 
. 
. 
. 
u;-Sets 
of cj-set-indexed PERs is small; hence it is locally small. But the fibration 
UFam(PER) 
i 
of (ordinary) set-indexed PERs, introduced as an example of a 
Acj-fibration in Corollary 8.4.6, is not small. We will show here that this 
fibration is not locally small, and hence certainly not small. We assume to-
wards a contradiction that the fibration is locally small, and thus—by the 
previous lemma—has a right adjoint { —} to the terminal object functor 
l:Sets->UFam(PER). 
Call a PER S non-empty if its domain l^l = {n G N | nSn} is non-empty, 
and write PER^0 ^> PER for the set of non-empty PERs. Consider the 
family of PERs X = {R)RePER^^ in UFam(PER), and the resulting set {X} 
with projection TTX' {X} -^ PER^0. For every non-empty PER S we have S 
as a map S:l -^ PER^0 in Sets, together with a morphism /(5): 1(1) -^ 
S*(X) = S over 1 in UFam(PER). Namely, f{S) ^ [ns]s. where ns G |5| 
is a chosen inhabitant of the domain of S. By the adjunction, f{S) gives a 
map v[S)\ 1 —> {X} with TTX ^ ^{S) — S. Collecting these v{S)^s together 
yields a function v: PER^0 —> {X}, with TTX o v = id. Transposing v gives a 
vertical map /: 1(PER^0) -^ X in UFam(PER) over Sets. It must have—as 
any other morphism in this category—a realiser, say e, which works for all 
indices. Thus, for every non-empty PER S, fs = [e]s where e G l^l. This leads 
to the absurd conclusion that there is an element e which is in the domain of 
every non-empty PER S. 
Next we give an intrinsic alternative formulation of local smallness. 
E 
9.5.4. Lemma. A fibration jrP is locally small if and only if for each pair 
of objects X, y G E in the same fibre, we can find a span X 4- A —>> Y in 
E with f Cartesian over p[g), which is universal in the following sense. For 
h 
k 
• 
each span X ^ B -^ Y with h Cartesian over p{k), there is a unique map 

562 
Chapter 9: Advanced fibred category theory 
(p: B —> A in E making the following diagram commute. 
B 
^ A 
(Such a mediating map (p is Cartesian, since f and f o (p = h are Cartesian.) 
E 
Proof. Suppose 
-jrP is a locally small fibration. For X, Y G E/, the required 
universal span X <— 7ro(X) -> Y is: 
X -^ M^) 
t 
MY) 
- * y 
Conversely, assume for X,Y 
€ E/ there is a universal span 
as in the lemma. Write TTQ: Romj{XjY) 
—>• / for p{f) = p{g) in B and TTI for 
the vertical part of 7ro(X) •=>• A —> Y. This pair TTQ and TTI is universal as 
described in Definition 9.5.1. 
Q 
Earlier in Example 7.1.4 (ii) we have seen how a full internal category Full(a) 
can be constructed from a morphism ai^l ^ 5 in a locally Cartesian closed 
category B. Below we shall describe a generalisation of this construction— 
due to Penon [257]—which may be performed in a locally small fibration. 
This gives rise to an important corollary, stating that a fibration is small if 
and only if it is locally small and has a generic object. 
9.5.5. Theorem. Let 
jrP be a locally small fibration. Then every object 
J7 G E induces an internal category ¥ull{U) in the base category B (provided 
there are enough pullbacks in B to say what this means). This internal category 

Section 9.5: Locally small 
fibrations 
563 
Full(6^) is "full in p": it comes equipped with a full and faithful fibred fund or: 
Fam(Full(t/)) 
^ E 
Proof. For ?7 6 E, write UQ = pU E IB for the intended object of objects 
of Full([/). Let us write (5o,5i):[/i -^ UQ x UQ for the representing arrow 
of the two objects 7r*{U) and 7r'*([/) in the fibre above UQ X UQ- It comes 
equipped with an arrow (the TTI), which we now write as pL\dl{U) -^ dl{U). 
By construction we have for X, F: / =4 ^o natural isomorphisms 
B/(/7ox^o)((X,y), ((9o,ai)) 
^ 
E7(X*(C/), Y^iU)) 
Internal identities and composition in Full(t/) are borrowed from p via this 
isomorphism^ (likefor the earlier "Full(—)" construction in Example 7.1.4 (ii) 
for locally Cartesian closed categories): the morphism of internal identities 
i: (id, id) —)• (5o, 5i) in IB/(L^o x UQ) is obtained by applying ^"^ to the identity 
map id*(^) -^ id*(f/). For internal composition, consider the pullback of 
composable maps: 
C/2 = C/i xt;„ [/i 
^ C/i 
J 
^0 
do 
Ui 
UQ 
where we have written ^0,^1 for the pullback projections. What we need is 
a composition map m: {do o ^0,5i o ^j) —> (5o, 5i) in M/{Uo x Uo)- It is con-
structed as follows. By applying both ^Q and ^J to ^: 5o(J7) —^ dl(U), we get 
a composite: 
(aoo6)*(f/) 
^S(A«) I 
^i*(/^) I 
Y 
(aio6r(f/) 

564 
Chapter 9: Advanced fibred category theory 
The composition map m: U2 —^ U\ is then obtained by applying ^~^ to this 
composite map [do o ^o)*(^) —> {di o ^1 )*([/). 
The morphism^: 55(f7) -> dl{U) is by construction the action of an internal 
diagram of type Full(f7) in p. It corresponds, following Remark 7.4.2 (i), to a 
fibred functor Fam(Full(C/)) -> E, given by 
{l^^Uo) 
^—X*(C/) 
This yields a full and faithful functor: we may restrict ourselves to a fibre (see 
Exercise 1.7.2), and there we have: 
Fam(Full([/))/(/4/7o, I ^ Uo) = M/{Uo xUo){{X,Y), 
{do,di)) 
^ Ej{x*{U), 
y*(U)). 
D 
It is not hard to see that the construction of the full internal category 
Full(a) starting from a morphism a in a locally Cartesian closed category 
B in Example 7.1.4 (ii), and of the associated full and faithful fibred functor 
Fam(Full(a)) -> IB~^ in Example 7.3.4 (ii), are special cases of the construction 
in the above proof, when applied to a as an object in the total category IB"* 
of the (locally small) codomain fibration on B. 
Recall that an ordinary category is small if and only if it has a small collec-
tion of objects and also a small collection of morphisms. The above theorem 
yields a similar description for fibred categories. 
9.5.6. Corollary. A fibration is small if and only if it is locally small and 
has a generic object. 
Proof. We have already seen that a small fibration is locally small and has a 
generic object, so we concentrate on the (if)-part. Let a locally small fibration 
E 
^P have T G Ea as generic object. By the previous result we can form an 
internal category Full(T) in B, for which there is a full and faithful functor 
Fam(Full(T)) 
^ E 
sending 
(/ ^ ^ 
Q) I 
^ u*{T) 
This functor is an equivalence because each object X G E is of the form u*{T) 
for a unique morphism w.pX —> fi, since T is generic object. 
• 
This corollary comes from [27]. In somewhat different formulation, it also 
occurs in [246, II, Theorem 3.11.1] for indexed categories. 
We close this section with a fibred version of a familiar homset description 
of ordinary products and coproducts: if a category C has Cartesian products 
X, then there are the (natural) isomorphisms in Sets between homsets: 
c(z, X XY)^ 
C(Z, X) X c(z, y). 

Section 9.5: Locally small fibrations 
565 
Similar isomorphisms exist for coproducts +, and for arbitrary limits and 
colimits. The next result gives a fibred analogue, for locally small fibrations. 
E 
9.5.7. Lemma. Let 
^P be a locally small fibrations with products JJ^ ^^^ 
coproducts ]J^ on a locally Cartesian closed base category B. Then, for a map 
u\L-^J, 
there are isomorphisms in B/J; 
^n. 
n. 
'Hom(l/*(X),y) 
'Hom(y,l/*(X))^ 
Notice that Y\u, U^^ on the left hand side of the isomorphisms = are the product 
and coproduct in p, and W^ on the right hand side is the product of the locally 
Cartesian closed category B (see Proposition 1.9.8). 
Proof. We shall do the first one. For a family 
the following pullback square. 
V^' = i/*(V^) 
We get the required isomorphism by Yoneda: 
/ / 
K,\ 
/ H o m ( X , n j y ) ) \ \ 
s E^(v'*(x), r(n„(n) 
= ¥.K{r{x),Y[u'r{y)) 
2 ¥.i(u"r{x), v"(y)) 
Hom(u»(X),y) 
/Hom(u*(X),y) 
u\ 
I 
K 
over J in B, consider 
by local smallness 
by Beck-Che valley 
by local smallness 
because ^' = u*{ip). 
D 

566 
Chapter 9: Advanced fibred category theory 
Exercises 
E 
9.5.1. 
Let 
^P be a locally small fibration. Prove that for an epimorphism u: J -^ 
B 
/ in B the reindexing functor ti*:E/ -)• Ej is faithful. 
E 
9.5.2. 
Let 
jrP be a cloven fibration with finite limits in its base category. Show 
that p is locally small if and only if for each pair of objects X^Y £ E—not 
necessarily in the same fibre!—the functor M/{pX x pY)^^ —> Sets given 
by 
(/ - ^ 
pX X PY) 
^ - ^ E/ ((TT O uy{X), 
(TT' 0 
uy{Y)) 
is represent able. 
[This formulation occurs in [169, A2].] 
Fam(C) 
9.5.3. 
Consider Theorem 9.5.5 for a family 
fibration 
i 
of a loccilly small 
Sets 
fibration C Show that for a family U = {Xa)aeA 
€ Fam(C) of objects 
Xa G C one gets a small category Full(t/) with A as set of objects, and 
cirrows a —^ (3 given by morphisms Xa —> X^ in C. 
s(T) 
9.5.4. 
Let (B, T) be a Al-category. Show that the associated simple 
fibration 
i 
is locally small. 
E 
9.5.5. 
Let 
^V be a fibration and F: A -> B be a functor with a right adjoint, 
where A is a category with puUbacks. Consider the fibration F*{p) obtained 
by change-of-base along F. 
(i) 
Prove that if p is locally small, then so is F*{p). 
(ii) Conclude that if p is small then F*{p) is also small. 
[Hint. Remember Exercise 5.2.3.] 
E 
9.5.6. 
Let 
j^P be a locally small fibration. 
/ H o m ( X , y ) \ 
(i) 
Show that the assignment {X, Y) \-^ \ 
-I- 
I —for X, Y in the 
V 
p ^ / 
same fibre—extends to a functor H (for Hom) in 
E(°P) 
X B E 
which maps Cartesian morphisms to puUback squares. This gives a 
comprehension category 7i on the product fibration p^^ x p. 
(ii) Define the associated exponential transpose 3^:p -> cod^ 
of 7i:p^^ x 
p —> cod, see Exercise 1.10.6, and show that ^ is a full and faithful 

Section 9.5: Locally small 
fibrations 
567 
functor. 
[This generalises Exercise 7.4.6.] 
E 
9.5.7. 
Let 
-^P be a locally small fibration on a base category B with finite limits. 
IB 
Show that each fibre category Ej is enriched over the slice category B//, 
with respect to its Cartesian structure. 
E 
9.5.8. 
(Benabou) Consider a locally small 
fibration 
-j^P . The aim is to obtain 
(canonical) equivalences 
Ei) -^-^ 
1 
and 
E/+J —=-^ Ei X Ej 
(*) 
(i) 
Show that every object in E over an initial object in B is initial in E. 
Conclude that if B has an initial object 0, then for all X,Y 
^Eo one 
gets X = y in Eo. And that if E has at least one object, then Eo ~ 1. 
Assume now that the base category B has binary coproducts +. 
(ii) Prove that the functor 
E/+J 
^ E/ X E J 
is full and faithfuU. 
(iii) Show that this functor is an equivalence if one additionally assumes 
that p has coproducts ]J and fibred coproducts V, and that the co-
products -h in B are disjoint. 
9.5.9. 
Assume a locally small fibration with fibred finite products and coproducts 
A,V and with products and coproducts ]~I,]J- Assume additionally that 
the base category has disjoint coproducts +. Show that the coproduct -f in 
the total category 
as described in Proposition 9.2.2,, can alternatively be described in terms 
of products as: 
x + Y = UA^)^UAy)-
9.5.10. 
Consider a locally small fibration with fibred coproducts V and coproducts 
Y[^ over a distributive base category. Prove that for an object X over 
/ X (J 4- K) there is an isomorphism 
Explain the logical significance of this isomorphism. 
E 
9.5.11. 
(Benabou) Assume a fibration j-P with products J][^. The point of this 
exercise is to show that if one has equivalences (*) as in Exercise 9.5.8, 
then p automatically has fibred finite products (1, x). [This shows that 
under suitable additional assumptions in Definition 1.9.11 of completeness 

568 
Chapter 9: Advanced fibred category theory 
for fibrations, it is enough to require products Y[ ^^^ fibred equalisers^ 
instead of products Y[ ^^d fibred finite limits.] 
(i) Let * G Eo; show that the objects 1(/) = Y[\ (*) ^ ^^ provide the 
fibration p with fibred terminal objects. 
(ii) For X, y G E/, let Z G E/+/ be such that K*{Z) ^ X and K'*{Z) ^ Y. 
Show that Y\^ {^) is Cartesian product of X,Y in E/, where V/ = 
[id,id]:/ + / — ) • / is the codiagonal. (For preservation under reindex-
ing one has to assume that the coproducts + in B are disjoint and 
universal.) 
E 
9.5.12. (See [88]) Call a fibration -j^P a geometric fibration if 
IB 
(a) the base category B is a topos, and the fibration p is "fibrewise a 
topos": each fibre is a topos and each reindexing functor is logical; 
(b) the fibration p has coproducts | J which are disjoint and universal (see 
Exercises 9.2.12 and 9.2.13); 
(c) the fibration p is locally small, or equivalently, by Lemma 9.5.2, p has 
comprehension, via a right adjoint {—}:E ^ B to the terminal object 
functor 1. 
E 
Prove that geometric fibrations i on a topos B correspond to geometric 
morphisms F: A —)• B with codomain B. 
E 
[Hint. Given ^ , consider the coproduct functor ]J:B —^ Ei from Exer-
cise 9.2.13 as inverse image part. And given F: A —> B, define a fibration 
A/F 
I 
by pulling the codomain fibration on A back along F*:B —> A.] 
Prove also that the geometric morphism F: A —>• B is an inclusion of toposes 
[i.e. the direct image part F*: A -^ B is full and faithful) if and only if the 
A/F 
fibration 
l 
has full comprehension {i.e. the induced functor A/F —>• B"^ 
IB 
is full and faithful). 
9.6 Definability 
Subset types {i:I\Xi} 
(v^ith X a predicate on /) in the logic of a preorder 
fibration are described in Section 4.6 via a functor {—} from the total category 
to the base category of the fibration, which is right adjoint to the truth (or ter-
minal object) functor T. The idea is that { —} singles out those instantiations 
i: I for v^hich Xi holds. There is a notion of "definability" for fibrations which 
gives more general means for singling out certain instantiations of objects in 
a total category and representing them in the base category. This allows us to 
consider in an arbitrary base category (and not just in Sets) the (universal) 
subobject V ^^ I of those indices i: V for which Xi satisfies some property P 

Section 9.6: Definability 
569 
on the objects of the total category. The notion of definability and the asso-
ciated results in this section are due to Benabou, see e.g. [29] or [36, II, 8.7]. 
Type theoretic use of definability can be found in [263], where "powerkinds" 
are described as objects in a base category of kinds, associated with a col-
lection of inclusion maps between types in a total category of a polymorphic 
fibration. 
We start with a formulation of definability which is intrinsic, and we later 
give an alternative formulation involving a cleavage. 
E 
9.6.1. Definition. Let 
^P be a fibration and P C Obj E be a collection of 
objects (or predicates) in the total category. 
(i) We call P closed under substitution if for each Cartesian map Y -^ 
X with its codomain X in P, also the domain Y is in P. This is a minimal 
condition to make P a sensible collection of predicates. Notice that such a 
collection P is closed under isomorphism: if X G P and X = Y, then Y E P. 
(ii) The collection P is definable if it is closed under substitution and 
satisfies: for each object X G E there is an object X' ^ P and a Cartesian 
morphism ix'-^' 
-^ ^ which is universal in the following sense. For each 
Cartesian map /: Y —> X with its domain Y in P, there is a unique (necessarily 
Cartesian) map f: Y —-)• X' with ix ^ f — f • 
The idea is to think of X' G P in this definition as the best approximation 
of X G E by an element of P, as suggested in the following picture. 
Informally, if X = (Xf)^^/, then one may think of X' as the family 
(Xf)i^ljg/ I Xj^P] obtained by suitably restricting X, see Lemma 9.6.4 be-
low. In more abstract form, this is made explicit in the next reformulation of 
definability. 
E 
9.6.2. Lemma. Let 
^P he a cloven fibration with a collection of objects 
P C ObjE which is closed under substitution. Then P is definable if and only 
if for each object X G E above / G IB the functor W^ —> Sets given by 
J^{u:J^I\u*(X) 
eP} 

570 
Chapter 9: Advanced fibred category theory 
is representable. 
Explicitly, this represent ability means that there is a representing morphism 
inM 
Ox 
[xeP]—^/, 
with e)^[x)eP 
such that each u: J -¥ I with u*{X) G P factors in a unique way through Ox-
(This map 6x must then be a monomorphism.) 
Proof. Assume the collection P is definable as described in the above def-
inition. Choose for each object X G E a universal Cartesian morphism 
ix'X' 
-> X and write ex:{X 
e P} -> pX for p{ix) in B. There is then 
a vertical isomorphism 0'^{X) = X' E: P. For a morphism u: J -^ pX with 
w*(X) G P there is a Cartesian morphism u{X):u*{X) 
-^ X in E whose do-
main is in P. Because ix is the best approximation of X in P, there is a unique 
map f:u*{X) 
—> X' with ix o f = u(X). Then pf: J -^ {X £ P} satisfies 
Ox ^ pf = Pi'^x ^ f) = p{^{X)) — u. If there is another map w: J ^ {X G P} 
satisfying 6x o w = u^ then we get a unique morphism g: u*{X) -> X' over w 
with ix o g = u{X), because ix is Cartesian. But then f — g^ by uniqueness, 
and thus w = pg = pf. 
Conversely, assume that representing morphisms 9x as in the lemma exist. 
Write X' = 0*x(X) G P and ix = J^{X):e*x{X) 
-> X for the associated 
Cartesian lifting. For a Cartesian morphism f:Y-^X 
with y G P we get a 
unique map v:pY —^ {X G P} with 9x o v = pf. But then there must be a 
(unique) mediating f':Y ^ X' over v with ix ^ f — f • And if also g.Y -^ X' 
satisfies ix o g = /, then pg.pY —> {X G P} satisfies Ox ^ pg = pf- Hence 
pg = V = pf, and thus g = f. 
D 
The following two results describe what definability means in familiar situ-
ations. 
E 
9.6.3. Lemma. Let 
jrP be a preorder fibration with a terminal object (or 
truth) functor T: B -> E. We write Truth C Obj E for the collection of predi-
cates which are true, i.e. Truth = {X G E | T < X vertically}. Then Truth is 
definable if and only if the fibration p has subset types (that is, if and only if 
the termiritsil object functor T has a right adjoint {—}:E -> B^. 
Proof. Assume Truth = {X G E | T < X vertically} is definable. Then there 
is a right adjoint X ^ {X e Truth} to T:B ^ E since 
E ( T ( J ) , X) ^ { w i J ^ p X |T(J) < w*(X) over J} 
= { l i i J ^ p X |t/*(X) GTruth} 
^ B ( J , { X G Truth}). 

Section 9.6: Definability 
571 
Conversely, if such a right adjoint { —} to T exists, then the associated 
subset projections TTX''{X} 
H^ pX form representing arrows for the functors 
in the previous lemma: for a map u: J —^ pX in B we get by Lemma 4.6.2 (ii): 
u*(X) e Truth O T < u*{X) over J <^ t/ —^ TTX in M/pX. 
D 
Next we show that for family fibrations (which incorporate the world of 
ordinary categories), definable collections correspond simply to subsets of ob-
jects. 
9.6.4. Lemma. There is bijective correspondence between definable collec-
Fam(C) 
tions for a family 
fibration 
i 
and collections of objects in C. 
Sets 
Proof. Let P C Obj Fam(C) be a definable collection. Because P is closed 
under substitution, if a family Y — (Vi)ie/ is in P, then each of the indexed 
objects Yj = j*{Y) is in P, for j G /. But the converse is also true: if each 
Yj =z j*{Y) G P, then Y G P. To see this, consider the best approximation 
y 
-> y with y 
G P . since Y' -> y is Cartesian, we may write y ' = 
{yv{k))keK for 21 function v: K —^ I. Since for each j E I there is a Cartesian 
map Yj —> y over j:l —>- I with Yj E P there must be by definability of P 
a unique map w{j):l 
-^ K with v{w{j)) — j . These w;(j)'s combine into a 
function w: I -^ /i, which is inverse of v. Hence Y = Y', and so y G P. 
Thus we consider the collection Pi = {X G C | X G P in the fibre over 1} 
of objects in C Then one easily shows that an arbitrary family X = {Xi)iqi 
is represented by the inclusion 
{iei\XiePi} 
^———^i 
Clearly, 0'^{X) is in P, because for each j E {i £ I \ Xi £ P} we have 
0'^{X)j = Xj E P by construction. And indeed, for a function u: J —^ I, if 
u*{X) = {Xu{j))j£j is in P, then each object Xu{j) is in Pi, so that u factors 
trough 0x:{iel\ 
Xi e Pi} ^ 
L 
Conversely, given a collection Q C Obj C, let 
Q = {{Yi)iej e Fam(C) | Vf e LYi E Q} 
be the closure of Q under substitution. Then Q is definable, since for an 
arbitrary collection X — (X,),^/, take the subset V = {i E I \ Xi E Q} '^ I 
and the subfamily X' — (X,)j^//. Then X' -> X is Cartesian over the inclusion 
/' ' ^ /, and is the best approximation of X in Q. 
As we have seen in the beginning of the proof, for a definable collection 
P C Obj Fam(C) we have IjPi) = {{Yi)i^i \ Mi E LYi E Pi] = P- And for a 
collection Q C Obj C we have (Q)^ = Q. 
D 

572 
Chapter 9: Advanced fibred category theory 
Fam(Sets) 
Consider for example the family 
fibration 
i 
of set-indexed sets. Let 
Fin C Obj Fam(Sets) be the collection of those families (X,),^/ for which 
each set Xi is finite. This collection is definable, since it comes from the 
subcoUection of Obj Sets consisting of finite sets: given an arbitrary family 
[Xi)i^i^ there is an inclusion 
{f G / I Xi is finite} ^ 
^ / 
serving as representing function. 
Fam(FinSets) 
Next consider the family 
fibration 
i 
of set-indexed collections 
•^ 
Sets 
of finite sets. We look at bounded families of these. More precisely, families 
which have a common bound: let 
CB = {[Xi)i^i e Fam(FinSets) | 3m e N. Vi G /. 
Xi has less than m elements}. 
We claim that CB is not definable—but it is closed under substitution. Take 
as counterexample the family^ = (M)n6N of finite sets [n] — {0,l,...,n —1}, 
which is clearly not an element of the collection CB. If CB is definable, then 
there is a subset {A G CB} ^-^ N such that each function w: J -> N satisfies: 
u*(A) = {W{j)])j^j 
is in CB if and only if u factors through {A G CB} ^-> N. 
For each n G N, considered as map n: 1 —> N, we have n*{A) = [n] G CB. 
Hence n E {A £ CB}. This shows that the identity function id:N -^ N factors 
through {A G CB} ^ N. But we do not have id*{A) = A e CB. Thus CB is 
not definable. 
Here is a another illustration, involving PERs. It is adapted from [262]. 
9.6.5. Example. A partial equivalence relation R C N x N will be called 
decidable if there is a "decision code" e G N such that for all n,m Ef^ 
, 
. 
f 1 if nRm 
<"-'">= \ 0 othe 
otherwise. 
We write DPER for the set of decidable PERs. We will show that the notion 
UFam(PER) 
of decidability is definable in the 
fibration 
i 
of a;-set-indexed PERs 
CJ-Sets 
UFam(PER) 
but not in the 
fibration 
i 
of set-indexed PERs. We begin with the 
Sets 
^ 
latter. 
Call a set-indexed family {Ri)i£i of PERs decidable if there is a single 
decision code which works for each Ri. Consider the collection of decidable 
UFam(PER) 
families of PERs in the 
fibration 
I 
. This collection is not definable. 
Sets 
Otherwise, there is a for each family R = (Ri)iei ^ subset I' '-^ I such that 

Section 9.6: Definability 
573 
every function u: J -^ I satisfies: u*{R) — {Ru(j))j£j 
is a decidable family 
if and only if u factors through r ^^ I. Consider in particular the family 
D — (5)5gDPER, say represented by an inclusion {D} "-^ PER. Then there 
is an inclusion DPER ^^ {D]^ since for each R G DPER, the family (over 
\) R — R*[D)^ consisting only of i?, is itself a decidable family, which is 
obtained by reindexing D along R'A ^ PER in Sets. Thus, D = {S)seDPER 
is a decidable family. But clearly no single decision code can work for all 
decidable PERs. 
For cj-set-indexed families of PERs we can do better. Call such a family 
R — {Ri)i£(^j^E) of PERs over an cj-set (/, E) decidable if there is a "uniform" 
code e G N such that 
Vi £ I.^n ^ ^(0- e • 71 is a decision code for Ri. 
The crucial difference with the earlier indexing over sets is that the decision 
code for the PER Rj now depends on (a code of) the index i G /. This enables 
U F a m ( P E R ) 
US to show that the set of decidable families in the fibration 
i 
is 
CJ-Sets 
definable: for an arbitrary family of PERs {Ri)i^(i^E) consider the subset 
OR 
r = {ie I \Ri isei decidable PER} ^ 
^ / 
with existence predicate 
E'{i) = {(n, m) I n G E{i) and m is a decision code for Ri] 
A code for the first projection tracks OR. And 0'^{R) — {Ri)i£(if^E') is a 
decidable family, since for each i G /' and k G E^i) the second projection p'k 
is by construction a decision code for Ri. 
For a morphism u: (J, E) -> (/, E) in cj-Sets, say tracked by d, such that 
u*{R) — (Ru{j))je{J,E) is a decidable family, say with decision code e, we 
have that u factors as u:{J,E) 
-^ (f, E') through OR, tracked by the code 
Ax. {d • x,e • x). 
The notion of definability can be formulated in much greater generality. 
E 
Therefore we need the exponent fibration p^ of a fibration 
-^P with an ar-
bitrary category C, as described in Exercise 1.8.8. Its objects in the fibre 
over / are functors C -> E/. Reindexing along w: J -^ / in B is done by 
post-composition with u*:Ej -^ Ej. 
E 
9.6.6. Definition. Let 
^P be a fibration and C an arbitrary category. A 
IB 
collection of functors C -^ E (factoring through some fibre) is definable if it 
is definable with respect to the exponent fibration p^. 

574 
Chapter 9: Advanced fibred category theory 
(This involves the requirement that the collection must be closed under 
substitution with respect to this fibration p^.) 
This definition generalises the earlier one, since a collection P C Obj E of 
objects of the total category is definable as in Definition 9.6.1 if and only 
if, considered as a collection of functors {X:l 
—> ^xeP 
from the terminal 
category 1 to E, it is definable as above in Definition 9.6.6. 
Now we can also talk about definability of collections of vertical morphisms: 
E 
a collection V C Arr E of vertical maps of a fibration iP is definable if it is 
B 
definable when considered as a collection of functors (• -^ •) —)- E. Explicitly, 
this means that for each vertical map f:X'-^X 
above / E B, there is a mono 
{/ G V^} ^^ / in B such that for each morphism u: J —^ I one has u*{f) G V 
if and only if u factors through {f EV} >-^ I. 
(Notice that this is not really an extension since it is the same as definability 
V(E) 
with respect to the arrow fibration p"^ = 
i 
in Fib(B).) 
As a special case, consider the collection 
viso = {/ I / is vertical and Cartesian} 
= {/ I / is a vertical isomorphism} C Obj V(E). 
One says that isomorphisms are definable if this collection vIso of vertical 
isomorphisms is definable. 
Similarly, one can say that equality of vertical maps is definable if the 
collection of functors (• i=t •) -> E given by 
{F: (. ^ •) ^ E/ I / G B and Fa = Fb} 
b 
is definable. This means that for each parallel pair f,f':X 
=:t Y of maps in 
the fibre over / G B, there is a mono {f =: f] >-^ I such that each u: J —^ I 
satisfies: u*{f) — u*{f') if and only if u factors through {/ = /'} ^^ /. 
Sometimes the expression "definable subfibration" is used. What this means 
E 
is the following. First, a subfibration of a fibration -^P consists of a subcat-
egory D <^ E with the property that for each X G ID and Cartesian morphism 
/: y —> X in E one has that / is already a map in D. This implies that the 
inclusion D M- E is a fibred functor. If this inclusion is full, one calls the 
subfibration full. Such a subfibration D is definable if both its collections 
of objects and of vertical morphisms are definable. For a full subfibration this 
simply means definability of objects. 
We list some results (due to Benabou) related to definability of isomor-
phisms. 

Section 9.6: Definability 
575 
E 
9.6.7. Lemma. Let 
^"P he a locally small fibration with finite limits in its 
base category. Then isomorphisms are definable in p. 
Proof. Recall from Exercise 9.5.7 that each fibre category E/ is enriched over 
the slice B//. For objects X, Y E E/ we can combine composition maps c into 
a morphism in IB 
Hom(X, Y) xi Hom(y, X) -
^ 
Hom(X, X) x/ HomfY, Y) 
There is also a morphism 
HomiX, Y) xj Hom(y, X) —^ 
1 -
^ 
Hom(X, X) Xj HomfY Y) 
obtained from identity maps. Taking the equaliser in B yields a mono 
vIso(X, Y) ^ - ^ Hom(X, Y) Xj HomfY X) 
The construction is such that for each u: J -^ I with an isomorphism u*{X) -=)• 
u*{Y) there is a unique morphism v: J -> vIso(X, Y) with 
u={j 
—^ 
vIso(X, Y) — ^ Hom(X, Y) X/ Hom(Y, X) 
^ / ) 
For a morphism f:X 
—)• Y over /, let f: I -^ Hom(X, Y) be the corre-
sponding section of the canonical projection TTQ: Hom(X, Y) -^ /. The required 
representing map 9f is obtained by pullback in 
{/ G viso} 
^ vIso(X, Y) 
J 
Hom(X,Y) 
/ 
Then 9Uf):9UX) 
-> OUY) is an isomorphism, with inverse resulting from 
the map 
TT' o e o / ' 
{/ G vIso} 
^ HomfY X) 

576 
Chapter 9: Advanced fibred category theory 
Finally, if we have a morphism w: J -> / in B for which u'^(f):u*{X) 
-> 
u*(Y) 
is an isomorphism, then we get a morphism v: J ^ 
vIso(X,y) as described 
above. This map, together with u: J —^ I satisfies 7 r o e o i ; = : / o t / , so that 
we get our required mediating map J —^ {/ G viso} using the pullback. 
• 
Definability of isomorphisms is important because it implies definability of 
some other classes. 
E 
9.6.8. Lemma. Let 
-jrP be a fibration with fibred finite limits and 
definable 
isomorphisms. 
Then 
(i) Equality 
is definable. 
(ii) The collection {X G E | X is terminal 
object in its fibre} is 
definable. 
(iii) Among the vertical diagrams X <— Z —^Y the ones where Z is product 
of X and Y in the fibre, are definable. 
(iv) Monomorphisms 
are definable. 
Proof, (i) For parallel maps f,f':Xz=tYin 
the fibre over / G IB, let e: X ' >-^ 
X be their equaliser in E/. The morphism 9e:{e G vIso} ^^ / then represents 
equality of /, / ' : a map u: J -^ I satisfies u*(f) 
= u*{f') 
if and only if u*{e) 
is an isomorphism, and the latter if and only if u factors through ^e-
(ii) For X G E over /, consider the morphism Ox-ii^-x-^ 
-^ 1-^) ^ vIso} >-^ 
/. It is the required representing arrow: a map u: J ^ 
I satisfies tf*(X) is 
terminal over J if and only if \u*{x) is an isomorphism if and only if u factors 
through Ox-
(iii) Similarly, for a vertical diagram X ^ Z ^Y 
consider the representing 
morphism for the induced tuple Z ^ X 
xY. 
(iv) One uses that a vertical f:Y—^X'\s 
monic if and only if the diagram 
is a pullback. Thus one considers the representing arrow for the induced di-
agonal Y -^ X Xy X. 
• 
Along the same lines we get that families of separated objects or sheaves are 
definable in a topos B with nucleus j . Recall therefore from Remark 5.7.10 (ii) 
the description of the full subfibrations FSepj(B) ^ B"^ and FShj(B) ^ B"^, 
with respective fibred left adjoints Fs and Fa. 

Section 9.6: Definability 
577 
9.6.9. Proposition. Let M he a topos with nucleus j . Then the full 
subfi-
brations 
FSepj(B) M- B~^ and FShj(B) ^-> B ^ of the codommn 
fibration, 
consisting 
of families 
of separated objects and of families 
of sheaves, are both 
definable. 
Proof. For a family I 
Y 
1 consider the vertical unit r]^:(p-^ 
^8(99) as a 
map in the slice category M/I. Since the codomain fibration of a topos is locally 
small (because a topos is locally Cartesian closed) isomorphisms are definable. 
Hence we take, as before, a representing morphism {r]ip E viso} ^^ /. Then, 
for a map u: J —^ I: 
u*(ip) is separated in B / J <=> lu*{<^) is an isomorphism 
^ 
w*(7/(^) is an isomorphism 
<^ u factors through {rj^^ E vIso} ^-> /. 
For sheaves one similarly uses the unit <^ —> ¥ai[(^). 
D 
We close this section by showing that the properties of being globally, re-
spectively locally small, are inherited by subfibrations with definable collec-
tions of objects respectively arrows. Global smallness means that there is a 
generic object. This implies that definable subfibrations of small fibrations are 
also small. 
E 
9.6.10. Theorem. Let 
p^ be a fibration. 
(i) Assume p is globally small, i.e. has a generic object. Consider a defin-
able collection of objects, given as a full subcategory D ^)- E. Then the induced 
subfibration D ^^ E —)- B a/50 has a generic 
object. 
(ii) Assume 
now that p is locally small; 
then a definable 
collection 
of 
vertical 
maps, given as a subcategory D ^-^ E gives rise to a 
subfibration 
D ^-)' E -> B which is locally small 
again. 
Proof, (i) Let T G E over Q G B be the generic object of p. This means that 
for every X G E there is a unique u:pX 
-^ Q with u*(T) 
= X, vertically. 
Consider the representing arrow 9: {T eB} 
y-^ Q, and write V = 0* {T) G D 
. 
^ 
over {T E^}. 
This is the generic object for the subfibration 4- . For an object 
Y EB 
there is a unique arrow v:pY 
-> Q with v*(T) 
= Y £ ]D). Hence v 
factors through 6>, say as i; = (9 o w. Then w*{V) 
^ Y, and w:pY -^ {T 
eB} 
is the only map with this property. 
(ii) If p is locally small, then we have for each pair of objects X,Y 
G O / 
in the same fibre, a map TTniHomfX, Y) —> / in B together with a verti-
cal morphism 7ri:7ro(X) -^ 7rJ(y) in E, satisfying a universal property as in 

578 
Chapter 9: Advanced fibred category theory 
Lemma 9.5.4. Since vertical maps in D are definable, we get an appropriate 
representing morphism 9: {TTI G V ( D ) } ^-> Hom(X, y ) , such that ^*(7ri) is the 
best approximation of TTI in V(D). Put AQ = TTQ o 9: {TTI G V ( D ) } -> /, and let 
Ai: Ao(X) —> Ao(y) be the unique vertical map (isomorphic to ^*(7ri)) in 
AS(X) 
^nliX) 
I 
I 
A i I 
TTi 
Y 
Y 
K{y) 
^<{y) 
where the horizontal arrows are the unique Cartesian ones over ^: {TTI G 
V(D)} ^^ H o m ( X , y ) . This pair (Ao,Ai) satisfies the appropriate universal 
property in D, making D ^ B locally small. 
D 
E 
9.6.11. Corollary. // 
]rP is a small fibration, and ]D '^-^ ¥. forms a definable 
subfibration 
(I.e. both the objects and vertical arrows o/D are definable), 
then 
B 
i is also a small 
fibration. 
Proof. Because a fibration is small if and only if it is both globally and locally 
small, see Corollary 9.5.6. 
• 
This result shows that the notion of 'definable subfibration' satisfies a rea-
sonable criterion for the concept of a 'part' of a fibration; namely that a part 
of a small fibration should itself be small. 
Exercises 
9.6.1. 
Recall from Lemma 4.4.6 (i) that a cover c: I—> J is a morphism which 
factors through a mono J' ^^ J only if this mono is an isomorphism. 
Similarly, a family of morphisms {caila ->• J)aeA is a collective cover if 
every mono J' >^ Xthrough which each Ca factors is an isomorphism. 
(i) 
Assume a collective cover {ca: la -> J)aeA' Prove that for a definable 
collection P and an object X above J 
X eP 
<^ V a G A . < ( X ) G P . 
(ii) Show that Lemma 9.6.4 is a consequence of this observation. 
Fam(C) 
9.6.2. 
Prove that definable subfibrations of a family 
fibration 
4- 
correspond 
Sets 
to subcategories of C. 
9.6.3. 
Let E be a category with puUbacks, which is fibred over a category B. Prove 
that if Pi, P2 C Obj E are definable collections, then their intersection 
Pi n P2 C Obj E is also definable. 

Section 9.6: Definability 
579 
9.6.4. 
Call a family of PERs R = {Rt)te{i,E) over an a;-set (/,£") bounded if 
there is a code e G N such that 
Vz € /.Vn G E{i).ym 
G \R^\.m < e n. 
Show that the collection of such bounded families is definable in the fibra-
UFam(PER) 
tion 
i 
of PERs over cj-sets. 
u;-Sets 
9.6.5. 
Prove that subfunctors of a presheaf G: C°P -^ Sets correspond to full 
/ ^ 
subfibrations D ^-)- J G of the Grothendieck completion 
4- of G. (A sub-
functor of G may be identified with a natural transformation a:G =^ Q, 
where Q: C°P —)• Sets is the subobject classifier in the topos Sets 
of 
presheaves from Example 5.4.2.) Describe in terms of a subfunctor when 
the associated full subfibration is definable. 
E 
9.6.6. 
Let 
-jrP be a fibration with a definable collection P C Obj El Show that 
f{xeP]\ 
the assignment X i-> I 
i 
I extends to a functor Cart(E) —)• B""^, and 
that all squares in its image are puUbacks in B. 

580 
Chapter 9: Advanced fibred category theory 
This Page Intentionally Left Blank

Chapter 10 
First order dependent type theory 
In simple type theory (STT), types a.Jype 
are built from atomic types (con-
stants) using type constructors like —>, x or -h. The distinguishing aspect of 
polymorphic type theory (PTT) is that one may additionally have type vari-
ables a: Type occurring in types and terms. This introduces an extra level of 
indexing, described syntactically by an extra context. In this chapter we study 
another variation on STT. In dependent type theory (DTT), a term variable 
x: a may occur in another type r(x):Type. Typical examples are the types 
n:N h Nat(n):Type 
and 
n: N h NatList(n): Type 
of natural numbers from 1 to n, and of lists of natural numbers of length 
n. Clearly, they contain a term variable n: N. Notice that such types do not 
exist in simple or polymorphic type theory. We thus have examples of "types 
depending on types". This is like "sets depending on sets", for example in an 
/-indexed collection X = (Xi)i^j, 
written formally as 
i: I h Xi'.Set 
where 
I-7: Set. 
Indeed, set-indexed-sets form obvious models of dependent type theory—a-s 
Fam(Sets) 
formalised by the family 
fibration 
4-
Sets 
Dependent types are widely used in mathematical practice. For example, 
as an n-fold Cartesian product X " , where n:N is a parameter. Or in algebra 
as a set (or type) of n x m matrices, say with entries from the reals. The 
following is a typical example in computer science. In the description of hard-
ware, bit vectors play an important role. They are finite sequences of bits 
(which can be represented as booleans true, false). In the description of digital 
581 

582 
Chapter 
10: First order dependent 
type 
theory 
systems one usually deals with types of bit vectors of a specific length, for 
example, as types of input or output signals. This leads to dependent types 
bvec(n) = bool":Type, depending on n: N. See also [114] for more such exam-
ples in hardware. These dependent types are so common that often one is not 
explicitly aware of using them. They are very convenient in expressing various 
results and arguments, see also Section 10.2 below. 
Dependent types were first studied systematically in the AUTOMATH project 
in the late 1960s at Eindhoven University in the research group headed by 
de Bruijn, see [231] for an overview. The aim of the project was to formalise 
mathematical arguments and to have them checked by a computer. For exam-
ple. Landau's entire Grundlagen book was checked in this way (which brought 
forward a few minor bugs). But since this project was not so well publicised 
and the AUTOMATH notation was somewhat confusing and unstable, it did not 
get the attention right from the beginning that it deserved. 
Later in the 1970s, Martin-L6f proposed comparable calculi of dependent 
types, see e.g. [213-215]. His aim was not so much mechanical checking of 
mathematical arguments, but more the formulation of a foundational lan-
guage for constructive mathematics. The original calculus contained a type 
of all types (Type: Type). As Girard showed in his thesis [94], this leads to 
inconsistency; the result is known as Girard's paradox, see Exercise 11.5.3 in 
the next chapter. Subsequently, the system was adapted, see e.g. [215, 232]. 
Nowadays one often uses the name "Martin-L6f type theory" for a variety of 
(first order) dependent type theories. Although these theories were originally 
developed for foundational reasons, they have also been used as a basis for 
proof tools (like NUPRL [78], ALF [207], VERITAS [113] and also pvs [242, 241],) 
which are employed for the verification of mathematical theories and of soft-
ware and hardware systems in computer science. 
In the next chapter we consider two kinds of extensions of DTT: logical 
extensions, leading to dependently typed predicate logic to reason about terms 
and types in DTT, and type theoretic extensions, combining type dependency 
and polymorphism (forming the basis of proof tools like LEGO or COQ). There 
we study (higher order) dependent type theories with two syntactic categories 
(or universes) like Type and Prop, or Kind and Type. In this chapter we restrict 
ourselves to only a single universe Type. 
Categorically, a dependent type n: N h NatList(n):Type, as described in 
the beginning of this section, is understood as a family of types, indexed by 
term variables n:N. Hence we could write NatList = (NatList(n))^.|yj, using 
a notation as for set-indexed-sets. More categorically, such a family of types 
NatList 
can be described as a morphism I 
j: 
1, such that NatList(n) appears as 
fibre over n: N. This leads to the view that dependent types are objects of 

Section 10.0: First order dependent type theory 
583 
slice categories—in the example of a slice C/N, for some category C Or, a 
bit more formally, dependent types appear as objects of the total category 
C"*" of a codomain fibration 
I 
. Along these lines a categorical description 
of dependent type theory was first given in terms of locally Cartesian closed 
categories by Seely [306]. The categorical products Yl ^nd coproducts ]J of 
the associated codomain fibrations correspond to the dependent products 11 
and S of dependent type theory. 
This all works well, but codomain 
fibrations 
4- 
suffer from the same 
Sub(C) 
defect that subobject 
fibrations 
i 
do: there are a number of features 
built-in that we would like to study in isolation. As we saw in Chapter 4, sub-
object fibrations always have subset types, unique existence and (very strong) 
equality. Similarly in codomain fibrations, one always has dependent (strong) 
coproducts and (strong) equality. Therefore we shall be working with certain 
generalisations of codomain fibrations. The obvious approach (as initiated 
in [329]) is to consider not all morphisms in as families of types, but only 
a restricted subclass of them. These are then called "display maps". They 
form a subfibration of the codomain fibration. In terms of these display maps, 
all the syntactic features can be described separately, see Section 10.3 below. 
We shall pursue this approach, but use "comprehension categories", instead 
of "display map categories". These comprehension categories are 
fibrations 
with certain additional structure. They have been used for a general notion 
of quantification in Section 9.3. They have certain technical advantages over 
display map categories, but there is no essential difference. 
(Many other categorical notions have been proposed to capture type de-
pendency: contextual categories [45, 319], categories with attributes [45] (see 
also [230, 271, 72]), D-categories [74, 62], higher level indexed categories [234], 
comprehensive fibrations [252]. There are no great differences between these 
notions, see [157] for a comparison between some of them.) 
In this chapter we introduce calculi with dependent types and describe them 
categorically. The first two sections will be devoted to the (essentials of the) 
syntax and use of such calculi. Subsequently in the third section we start the 
categorical investigations. We first organise the syntactic material of an ar-
bitrary dependently typed calculus in a term model. This brings forward the 
importance of a distinguished class of morphisms, called "display maps" or 
"(dependent) projections". In the term model they will be the context projec-
tions TT: (r, a^: cr) ^ r for a type T \- a: Type in context F (containing the free 
term variables in a). Appropriate categorical descriptions of these projections 
will be given in Section 10.4, first in terms of display map categories, and then 
in terms of comprehension categories. Fibrations with a right adjoint to the 

584 
Chapter 10: First order dependent type theory 
terminal object functor (like in Section 4.6 describing subset types for pre-
order fibrations) will be called fibrations with comprehension. They give rise 
to important examples of comprehension categories. In Section 10.5 we iden-
tify the notion of a "closed" comprehension category (CCompC). It describes 
models of D T T with unit type 1, dependent product 11 and strong dependent 
sum E. The last two Sections 10.5 and 10.6 contain many examples of these 
CCompCs. 
10A A calculus of dependent 
types 
Our first aim is to describe the syntax of a calculus of dependent types, see 
also [215, 334, 232, 137]. This is a subtle matter, since terms may occur in 
types. Thus, types cannot be introduced separately, and a big simultaneous 
recursion is required. The basic (new) type forming operations are 
Ux: a. T{X) 
the dependent product of T{X) where x ranges over a 
Yix: a. T{X) 
the dependent sum of T{X) where x ranges over a 
EqcT(x, x') 
the type of cr-equality for x, x' ranging over cr. 
Notice that term variables x,x' 
occur explicitly in the latter equality type 
Eq^(a?,x'). The intuition is that this type is inhabited if and only if 
X^X'.CF 
are equal. Sometimes, these equality types are called identity types. We recall 
that the dependent product and sum of a family (X,),^/ of sets are given by 
ni G /.Xi = {f:i-^ 
U^/ ^i I Vi e L f{i) e Xi} 
Ei G /. Xi 
- 
{(i, x) \i e I and x G Xi}. 
This gives an intuition for these dependent product and sum: Ilx:a.T{x) 
is 
the collection of functions / such that for each a: a one has fa:T[a/x]. 
And 
T,x: a. T{X) is the set of pairs (a, 6) with a: a and 6: T[a/x]. Notice the substi-
tution [a/x] in type r, which is typical for DTT. As we shall see formally in 
Example 10.1.2 and Exercise 10.1.1 below, dependent products 11 generalise 
exponents -^ and dependent sums E generalise Cartesian products x. For 
elements x^x' £ I one may think of the associated equality type as 
r 
/ 
/\ 
/ {*} ii X - x' 
E q . K x ) = | J ^ 
otherwise. 
The calculus we are about to set up has contexts of variable declarations 
T = xi'.ai,.. 
.,Xn:o-n 
satisfying the condition that each type crf+i is well-formed in the preceding 

Section 
10.1: A calculus of dependent 
types 
585 
context Xi'.ai, .. . ,Xi:ai, 
which we write as: 
xi'.ai,. 
.. ^Xi'.ai h crf_j.i: Type. 
As a consequence, each term variable y which is free in crf+i must already have 
been declared in the part of F preceding CTJ+I: it must be one oi xi,.. 
.,Xi. 
So in particular, cri is a closed type; it does not contain any term variables. 
Thus a well-formed context is 
n:N,^:NatList(n) 
but 
n: N, z: Matrix(n, m) 
is not well-formed (since m is not declared). 
Sequents have one of the following four forms. 
(1) r her: Type 
(2) T h 
M:a 
(3) r h M = TV: 0- 
(4) r h (7 = r: Type. 
The first (1) of these is type formation as we have seen in other calculi. Like-
wise for inhabitation in (2) and equality (conversion) of terms in (3). Equality 
of types in (4) arises because terms may occur in types and so conversions 
may take place inside types. The main rule associated with equality of types 
is the following 
conversion 
r h M:cr 
r h cr = r: Type 
r h M:T 
We shall not pay much attention to this equality of types, because we take 
the categorically motivated extensional view that types are equal if they are 
inhabited by the same terms. Instead we concentrate on rules for sequents of 
the form (1), (2) and (3). We let J stand for an arbitrary expression which 
may occur on the right of a turnstile h. 
First there are the following five basic rules of DTT. 
projection 
substitution 
F her: Type 
T \-M:CT 
T,x:a,A\-J 
T,x:a\- 
x:cT 
F, A[M/x] 
h 
J[M/x] 
contraction 
weakening 
T,x:a,y:(T,A\- 
J 
F her: Type 
F h J 
T,x:a,A[x/y] 
h J[x/y] 
T,x:a 
h J 

586 
Chapter 10: First order dependent type theory 
exchange 
r,a::cr,t/:r,A h J 
T,y:T,x:(T,A 
h J 
(if X not free in r) 
For convenience we assume a singleton (or unit) type (as in Section 2.3), 
with rules 
r f-M:l 
^1-Type 
h ( ) : l 
y \-M = {):! 
Binary product types a x r come for free if one has sum types E, see Exam-
ple 10.1.2. And finite coproduct types (0,+) will be considered separately at 
the end of this section. 
Then there are the formation rules for dependent product 11, sum E and 
equality Eq. 
T,x:a 
h r: Type 
T^xia h r: Type 
r \- Ux'.a.T-.Type 
T h Ex: o-. rrType 
r h cr: Type 
r,x:a,x':a\- 
Eqa{x,x'):Jype 
These type constructors change the context, and will be described categor-
ically via adjunctions between fibre categories. The variable x:a becomes 
bound in Ux.a.r 
and Ex:cr. r. Hence substitution in these types takes the 
following form. 
(Ux:a.T)[L/z] 
= 
Ux:a[L/z].T[L/z] 
(Ex:(7.r)[L/z] = 
^x:a[L/z].T[L/z] 
Eq^{x, x')[L/z] 
= 
Eq^[L/z]{x[L/zlx'[L/z]). 
where in the first two cases it is assumed that the variable z is different from 
the (bound) variable x] otherwise the substitution has no effect. Also, x should 
not be free in L. 
There are associated introduction and elimination rules: 
T,x:(T \- M:r 
T \-M.Ux.a.r 
T 
\-N:a 
r h Ax: (7. M: Ux: a.r 
T h MN: 
T[N/X] 
r h cr: Type 
F, x: cr h r: Type 
F, x: (T,y:T h (x, y): Ex: cr. r 
T \-p'.Type 
T,x:a,y:T 
\-Q: p 
F,z:Ex:cr. r h (unpack z as {x,y) in Q): p 
(weak) 

Section 10.1: A calculus of dependent types 
587 
r h cr: Type 
r, x\ cr, x'\ 0", A \- p: Type 
T, x\ a, A[x/x] 
h Q: p[x/x'] 
(weak) 
T,x: cr, x':a, z: EqcT(x,x'), A h (Q with x' = x via z):^ 
These rules involve abstraction and application for dependent products II, 
pairing (or packing) and unpacking for dependent sum E and a reflexiv-
ity combinator r = r<j(x) for equality, together with an associated elim-
ination rule. The variables x^y are bound in the sum elimination term 
unpack z as {x,y) in Q. Substituting in these terms is done in the obvious 
way. The elimination rules for sums and equality are labelled "weak", because 
also "strong" versions exist; they will be described later in this section. 
Notice the explicit occurrence of a parameter context A in the equality 
elimination rule. It is sometimes forgotten, but plays a crucial role. (Categori-
cally, it involves a Frobenius property.) In presence of product types 11 this A 
may be omitted, since the rules with A's are derivable. For sums it comes for 
free, even without II's, see Exercise 10.1.8 (i). In the following such parameter 
contexts are used explicitly. 
10.1.1. Example. If we assume terms 
FhMio-, 
T\-M':(T 
with 
F h P: Eq^(M, M') 
and a type 
T,x:a 
h piType 
with inhabitant 
F h Q:p[M/x] 
then we can also find an inhabitant of the type p[M'/x] in context F. This is 
replacement, see also Lemma 8.1.2. One obtains such an inhabitant from the 
rules 
F,:r:cr h /?: Type 
F, x: cr, y: plx/x'] h y: p[x'/x][x/x'] 
F, x:cr, x'rcr, z: Eqcr(x, x'),y: p h {y with x' = x via z): p[x^/x] 
Then by substituting [M/x, M'/x\ 
P/z] we get, 
T,y:p[M/x] 
h y with M' = M via 
P:p[M'/x] 
and so we are done by further substituting [Q/y]. This yields the required 
inhabitant 
T \-Q with M' = M via 
P:p[M'/x], 
and concludes the example. 

588 
Chapter 10: First order dependent type theory 
The conversions associated with products, sums and equality are presented 
below. The (/?)-conversions are the ones mentioned first, followed by the as-
sociated (?7)-con versions. 
{\x:a.M)N 
= 
M[N/x] 
Xx'.a.Mx 
= M 
unpack (M, AT) as {x,y) in Q - 
Q[M/x,N/y] 
unpack P as {x,y) \n Q[{x,y)/z] 
- 
Q[Plz\ 
Q with X = a: via r — Q 
Q[x/x'j r/z] with x' — x y\a z == Q. 
With the usual proviso that in the (7/)-conversion for products the variable x 
is not allowed to occur free in M. 
10.1.2. Example. For types F h cr, r: Type in the same context, with a term 
variable x: a which does not occur in r, we write 
def v-( 
1 
<d^f TT 
aXT 
= LiX'.a.T 
and 
cr ^ r = llx: cr.r. 
(in which r is used as a type in context V^x:a via weakening). It is then almost 
immediate that -^ satisfies all the rules which are required for exponent types, 
see Section 2.3. For x we have to do some work. For a term P:a x r write 
TTP = unpack P as (x^y) in x 
and 
IT'P — unpack P as {x,y) in y. 
Notice that the second projection TT'P can be defined because the variable x 
does not occur in r. It is easy to see that with these definitions one obtains 
(/?)-conversions 7r{M, N) — M and 7r'(M, N) = N, but also the (r/)-conversion 
holds: 
(7rP,7r'P) = {7rz,7v'z)[P/z] 
= unpack P as {x,y) in {nz,7r^z)[{x,y)/z] 
= unpack P as {x,y)\n 
{7r{x,y),7r'{x,y)) 
= unpack P as {x,y) in {x,y) 
1 p. 
These dependent product H and sum E thus generalise the exponent —)• and 
binary product x. Since we assume a unit type 1, we get the type constructors 
of Alx calculi (and of Cartesian closed categories), in every context F. 
Strong sums and strong equality 
As already mentioned, the above elimination rules for sums and equality are 
the so-called weak ones. 
The strong versions are obtained by allowing the 

Section 10.1: A calculus of dependent types 
589 
type p with respect to which one eliminates, to depend on an extra variable— 
of type YiX'.cr.T or Eqa(a^,x'). This leads to the following strong versions of 
the elimination rules. 
r, z: T.x\ a.T \- p: Type 
T, x: a,y:T 
\- Q: p[{x, y)/z] 
; 
(strong) 
T,z:Ylx:a.T 
h (unpack z as {x^y) in Q): p 
T,x:a,x':a, 
z:Eqa{x,x^) 
h/?: Type 
T,x:a 
h Q: p[x/x^ ^r/z] 
r, x: cr, x': cr, z: Eq^(a:, x') h [Q with x^ = x via z): p 
(strong) 
The conversions remain the same. Notice that there is no parameter context 
anymore in the strong elimination rule for equality. The rule with such a con-
text is derivable, using the result below. It gives alternative formulations of 
these strong rules, which are probably more familiar. But the above formu-
lations with additional free variable (the z in p) are more appropriate since 
they scale up to calculi with more universes than just Type, see Section 11.4 
in the next chapter. 
The first point below comes from [215], and the second one from [322]. 
10.1.3. Proposition. The strong elimination 
rules for sum and equality can 
equivalently 
he formulated 
in the following 
way. 
(i) 
r \- P:i:x:a.T 
T h 
P:T.X:CT.T 
r h7rP:(7 
r 
hTT'P:T[KP/x] 
with conversions 
7r(M, A^) = M, 7T'{M, N) - N and {TTP, TT'P) = P. 
(ii) 
r h P : Eq,(M, M') 
T h P : Eq^(M, M') 
T h M = M':a 
T h P = r: Eq^(M, M') 
Proof, (i) Assuming the above strong sum elimination rule, we get the pro-
jection rules as in Example 10.1.2 for binary products x; the approach can 
be extended to sums, since the second E-projection can be defined with the 
strong elimination rule: 
r, z: T>x: cr 
\- r[7r2:/x]: Type 
F, x: CT,y:T h y: T[7rz/x][{x, 
y)/z] 
T, z:T>x:a.T 
h n'z = unpack z as {x,y) 
in y:T[7Tz/x] 
In the reverse direction, one simply puts 
unpack P as {x,y) 
\n Q — Q[KP/X, 
Tr'P/y]. 

590 
Chapter 10: First order dependent type theory 
(ii) Assume the strong equality elimination rule as formulated above. For 
variables x^x'.a and z\ YJC{a{^^ ^') we have 
X — x\xlx\ 
xjz\ with x' = X via z 
— x'[x/x'^ r/z] with x' = x via z 
^ 
I 
— 
X . 
and so by substituting [M/x,M'/x',P/z] 
we get the conversion M = M':a. 
Likewise, we have 
z — z[x/x'^ r/z] with x' = x via z 
= r[x/x', r/z] with x' = x via z 
= 
r. 
So by substituting [M/x,M'/x',P/z], 
we obtain P = r:Eqa(M, M') as re-
quired. 
In the reverse direction, for a term T,x:a h Q: p[x/x', r/z] we can put 
r, x: cr, x': cr, z: Eq^(x, x') h {Q with x' — x via z) = Q: p 
since if z: Eqa{x, x'), then x — X'.CT and z = r: Eqcr(a?, x') by the assumption. 
The conversions associated for 'with = via' hold since 
Q with X — X M\d^ r — {Q with x' = x via ^)[ic/a:', r/z] 
= Q with x^ = X via z 
by the conversions x = x' and z = r 
= Q-
And similarly 
Q[x/x', r/z] with x' = x via z = Q with x' — x via z 
= Q. 
• 
Equality types in dependent type theory form a non-trivial subject, because 
there are many possible (combinations of) rules. We have chosen to present 
the above "weak" and "strong" versions, with both (/?)- and (7/)-conversions 
since these come out most naturally from a categorical perspective. The two 
strong equality elimination rules obtained in the previous proposition have 
some disadvantages from a type theoretic perspective, because they make 
conversion between terms depend on inhabitation of types. This leads to un-
decidability of conversion, see [133, 3.2.2]. DTT with strong equality is often 
called extensional DTT. Since the (77)-conversion for equality types is crucial 
in proving the above result, it is often dropped. See for example [232, Chap-
ter 8] where "extensional equality" is what we call "strong equality", and 

Section 10.1: A calculus of dependent types 
591 
"intensional equality" is "strong equality without the (7/)-conversion". See 
also [139, 133, 136] for more information and results, in particular about "se-
toids", which yield a model with extensional equality inside dependent type 
theory with intensional equality. 
The strong equality types (with (77)-conversion) do have the following syn-
tactic advantage. Consider a type F h criType, and another type V^x.a h 
r:Type parametrised by cr. If we have inhabitation of a strong equality type 
Eq<7(M, M') for terms M, M': cr, then we may conclude (by the above propo-
sition) that the types T[MIX\ 
and T[M'/x] 
are equal. This is problematic 
otherwise, see [322, 133] for detailed investigations. 
10.1.4. Convention. Unless stated otherwise, E and Eq will refer to the 
strong versions of sum and equality. These are most natural (and unproblem-
atic) from a semantic perspective, see e.g. Theorem 10.5.10 (i), where they 
are linked to equalisers. 
Weak and strong coproduct 
types -f-
The rules for finite coproduct types (0,-f) as given in Section 2.3 extend in 
a straightforward way from simple type theory to dependent type theory. 
They give us finite coproducts in every context F. We shall call these weak 
coproducts. One can also define strong coproducts in DTT, analogous to 
strong sum and equality. The difference between weak and strong coproducts 
-h lies in their elimination rules. In the weak case there is a direct extension 
of the rule used in simple type theory: for types F h cr, r:Type in the same 
context, one can form the coproduct type F h cr-|-r: Type in this context, with 
first and second coprojection terms F,a?:cr h KX:O--\-T 
and F, t/: r h K^y: a-\-T. 
The weak elimination rule takes the form 
Fh/?:Type 
T,x:(T\-Q:p 
T,y:T\-R:p 
; 
; 
(weak) 
F, z: cr -f- r h unpack z as [KX in Q, K^y in R]: p 
An extended rule with a parameter context is derivable from this one, see 
Exercise 10.1.8 (ii) below. In the strong 
-[-elimination rule one allows this 
type p to depend on a variable z'.a -\- r. Additionally we put in parameter 
contexts, but they may be omitted in the presence of H-types. 
F, z: 0- -h r, A h p: Type 
F, x\ cr, 1^[KXIZ] 
h Q: P[KX/Z] 
F , y: r, /^[K'y/z] 
h R: p[K'y/z] 
(strong) 
F, 2:: cr -f- r, A h unpack z as [KX in Q, n'y in /?]:/> 
These strong coproducts are called disjoint union types in [215] (but the 
parameter context A is omitted there). The strong coproducts are more nat-

592 
Chapter 10: First order dependent type theory 
ural in DTT than the weak ones. They give rise to appropriate distribution 
isomorphisms, see Exercise 10.1.7 below. 
We close this subsection on coproducts + with the following observation. 
We have formulated the elimination rules for coproduct -h and sum E to that 
we can form new terms by "unpacking". In DTT one can in principle also 
formulate similar rules to form new types by unpacking, like in 
r,ir:cr h ^iiType 
F, 2/: T h z/: Type 
r, z: cr + r h unpack z as [KX in //, K'y in i/]: Type 
Together with appropriate conversions for this newly formed type. A similar 
rule may be formulated for (weak) sums. We shall not investigate the effect 
of such type definition rules. 
The diligent reader may have noticed that we did not start this section 
with "dependent signatures", just like we began descriptions of simple and 
polymorphic calculi with appropriate signatures. The reason is that signatures 
for the latter two calculi have elementary algebraic descriptions. In dependent 
type theory one cannot separate types and terms, and the whole calculus has 
to be defined in one big recursion. Hence a signature has to be introduced at 
the same time as the entire calculus, for example by describing some constants 
in context, of the form 
r h C: Type 
and 
A h F : 
C[M/x\ 
where x are the variables declared in V and M is an appropriately typed 
sequence of terms. 
We will gloss over these (non-trivial) matters. The usual way to be precise 
here is to first introduce pre-contexts, pre-types and pre-terms by induction, 
and then to single out from these the well-formed contexts, types and terms 
using rules as above, see [45, 46, 319, 137, 271] for more details. Dependent 
signatures introduce appropriate pre-types and pre-terms in this approach. 
Church-Rosser and strong normalisation proofs for dependent type theory 
may be found in [231, 115]. 
Exercises 
10.1.1. 
Consider the set-theoretic sum and product Ezi/.X, and Hi.I.Xi 
as de-
scribed in the beginning of this section. 
(i) 
Show that if the Xi do not depend on i G /, i.e. Xx = X for some set 
X, then 
E i : / . X , ^ / x X 
and 
Ylv.I.Xx^X^. 
(ii) And if / is finite, say / = { 1 , . . . , n}, then 
Ei: /. X, ^ Xi + .. + Xn 
and 
Hi: /. X, ^ Xi x • • • x Xn. 

Section 10.1: A calculus of dependent types 
593 
10.1.2. 
Construct proof-terms for symmetry and transitivity of equality types. 
10.1.3. 
Formulate explicitly how substitution distributes over the various term 
forming constructs in this section. 
10.1.4. 
Derive the "commutation conversion" for (weak) sum types: 
/^[(unpack P as {x,y) in Q)lz] = unpack P as {x,y) in R[Q/z]. 
def 
10.1.5. 
Show that the definition unpack P as {x,y) in Q = Q[nP/x,7r'P/y] 
in the 
proof of Proposition 10.1.3 (i) satisfies the required conversions. 
10.1.6. 
Call two types T h (j, r: Type in the same context isomorphic, and write 
this as r h o" = T, if there are terms r,x:a 
\- P:r and T^yir \- Q: a with 
conversions T^xia h Q[P/y] = x: cr and F, y: r h P[Q/x] = y: r. Use weak 
sums to prove for types F h (J:Type, T^xia h r: Type and T^zi'Exicr.T 
h 
p: Type that there are isomorphisms: 
(i) 
F h Y,z: {T>x: a. r). p = So:: cr. Ey: r. p[{x, y)/z] 
(ii) Uz: (Ex: a. r). p ^ Ux: a. Uy: r. p[{x, y)Iz]. 
And for F h ^:Type 
(iii) F h {Ux: a.r -^ fj)^ 
(EJ:: a. r) -> A^. 
10.1.7. 
(See also [73]) Prove similarly for types F h cr, r: Type and T,z:a 
-\- r h 
p: Type that 
(i) 
F h T,z: or -\- T. p= Ea:: cr. p[(«;a;)/2] + Ey: r. /5[(«'y)/'2r] 
(ii) F \-Uz:a-{-r,p^ 
Ux: cr. /9[(ACX)/2] X Uy: r. p[(K'y)/^] 
where + is strong coproduct and E is weak sum. (The parameter context 
in the strong coproduct elimination rule is needed.) 
10.1.8. 
(i) 
Prove that the following extended weak sum elimination rule with pa-
rameter context A is derivable from the rule given above (without 
parameter). 
F, A \- p: Type 
F, x: a, y: r, A \- Q: p 
(weak) 
F, z: TiX: cr.r, A h (unpack z as (a;, y) in Q): p 
[Categorically this will mean that the Frobenius property comes for 
free in a full comprehension category with coproducts, see Exer-
cise 10.5.4 (ii).] 
(ii) Prove similarly that the following extended weak coproduct elimination 
rule is derivable. 
F,Ahp:Type 
r,x:(T, A \- Q: p 
F, y: r, A h H: p 
r,z:(T -\- T, A h unpack z as [KX in Q, n'y in R]: p 
[See Exercise 10.4.8.] 
10.1.9. 
Assume a unit type and strong sum types. 
(i) 
Show that there is a bijective correspondence between types 
xi:(T,..,,Xn:(Tn 
i" T: Type 
in contexts of length n, and types 
z: {Jlxi :cr. • • • Ea7n-i: ^n-i • (Tn) ^~ P' Type 

594 
Chapter 10: First order dependent type theory 
in context of length 1, where llxi'.a. • • • Ea^n-i: <Tn-i. <Tn is 1 in case 
(ii) Give a similar correspondence between terms 
X l : <T, . . . , Xn'. (Tn J" M: 
T 
and 
Z: (Hxi: 
<T. ' ' ' YiXn-V' 
O'n-l- O'n) I" ^'- p. 
(iii) Conclude that in the presence of a unit type and strong sum types, we 
may (for convenience) assume that contexts have length one. 
[Hence 1 and strong E play the same role in dependent type theory as 1 
and X in simple type theory, see Exercise 2.3.3.] 
10,2 Use of dependent types 
This section contains some illustrations of the use of dependent type theory. 
Especially it contains expositions of the propositions-as-types correspondence: 
once a la Howard and once d la de Bruijn. 
Our first example is intended to show the expressiveness and usefulness of 
a calculus with dependent types. It is taken from [114], and mentioned also 
in [165]. It involves the representation of a type date: Type whose inhabitants 
describe a particular year, month and day. On first thought one may view date 
as a Cartesian product N x N x N involving the type N of natural numbers, 
where the first component represents the year, the second the month and the 
third the day. This can obviously be done in a far more precise way, since the 
number of months in a year does not exceed 12 and the number of days in a 
month does not exceed 31. So a second try is N x Nat(12) x Nat(31), where for 
n: N, Nat(n) is the type of natural numbers from 1 to n. This is already much 
better. But not every month has 31 days; even worse, the length of the month 
of February depends on the year. So the best representation gives dates as 
"dependent tuples" with their type given by sums: 
date = Et/: N. Em: Nat(12). Nat(length of month m in year y) 
where the term length of nnonth m in year y' is defined by cases in an obvi-
ous way. A typical term of type date is (1993, (7,15)). With this type date, 
correctness of a date representation becomes a well-typedness issue. 
This example illustrates an important point: using dependent types may 
lead to a precise and concise typing discipline. This is convenient in various 
applications. 

Section 
10.2: Use of dependent 
types 
595 
Proposi tions- as- types 
The general idea of a propositions-as-types correspondence is that propositions 
in some logical system can be seen as (or translated into) types in a type 
theory, in such a way that derivable propositions give rise to inhabited types. 
Sometimes, one also has that if the translated proposition is inhabited, then 
the original proposition is derivable. This latter property may be seen as a 
form of completeness, see e.g. [91] for details. 
We have already seen that connectives T, A, D in propositional logic corre-
spond to type formers 1, x, —)• in simple type theory. Universal and existential 
quantifiers V, 3 in predicate logic can be translated as polymorphic prod-
uct and sum fl' LI ^^ polymorphic type theory, see Section 8.1: the types in 
predicate logic become kinds, and the propositions become types under this 
translation. It turns out that one can translate predicate logic also into de-
pendent type theory whereby both types and propositions in predicate logic 
become types in dependent type theory. Hence inside DTT the distinction be-
tween (proper) types and propositions is blurred. This has some advantages 
because it yields a formal system in which one can do both type theory (in 
the proper sense) and logic. This gives for example the possibility to develop 
a program together with a proof that it satisfies a specification (described 
by some logical formula) within the same formalism, see [232]. But blurring 
the distinction between types and propositions also creates confusion. It is for 
this reason that the type theories of the proof tools LEGO and COQ (which 
are based on higher order dependent type theory) make a careful distinction 
between propositions and types. 
Once we agree to see types within DTT sometimes as proper types and 
sometimes as propositions, we may view an inhabitant M:T of a type r as a 
proof-term, or as a proof (of r). The term calculus in dependent type theory 
yields that 
a proof P: Hx: cr. r in a product is a function P = Xx:a. Px which gives 
for each element M:cr of the domain type a of quantification, a proof 
PM: T[M/X] showing that the proposition r is true for this element M. 
And 
A proof F: Ex: cr. r in a (strong) sum is a pair P = (TTP, TT'P) consisting 
of an element nP: a of the domain type of quantification together with a 
proof TT'P: TITVP/X] showing that the proposition r is true for this element 
TTP. 
Here one sees cr as a proper type and r as a proposition. Since —)• and x are 
special instances of H and S, see Example 10.1.2, we get as special cases: 
A proof P: (T —>. r in an exponent is a function that transforms each proof 

596 
Chapter 10: First order dependent type theory 
M:aoi 
the proposition a into a proof PM: r of the proposition r. 
And 
A proof P'.cr X r in a Cartesian product is a pair consisting of a proof 
TTP: a of the proposition a together with a proof TT'P: r of the proposition 
r. 
In these last two cases one sees both a and r as propositions. What we have 
here may be understood as the so-called B r o u w e r - H e y t i n g - K o l m o g o r o v 
interpretation of the connectives of constructive logic, see the introduction 
to [335]. The proof-terms that one uses correspond to constructive reasonings. 
For example, consider the proposition 
3x: a. {f> Alp) D {3x: a. (p) A {3x\ a. ip). 
How does one see that it holds? Assume we have bXi x\a for which both (f 
and ^ hold. Then we certainly have an a:: cr for which (p holds and also there 
is an x\a for which ip holds. Just take this same x twice. 
In the notation of dependent type theory, one writes the proposition as 
TiX: (7. {(f X tp) -^ {T>x: a. (p) x (Ex: a. \p). 
The inhabitant of this type corresponding to the proof that we just sketched 
is the term 
Xz: Ex: a. {(p x ip). {{nz, 7T(7T^Z)), (TTZ, 7r'(7r'2:))). 
One sees that a proof z:T>x:a.{(pxtp) 
is decomposed into an element TTZ: a 
for which we have a proof TT'Z = (7r(7r'z), 7r'(7r'2:)) showing that p x tp holds of 
TTZ. These components are put together again to form proofs of ^x:a.(f 
and 
of Ex: a.tp. 
(Notice that we can get a different proof-term if we take E as weak sum, 
namely 
Xz: Ex: a. ((f x tp). unpack z as (x, w) in ((x, TTW)^ (X, TT'W)). 
Essentially this is the proof-term that arose when we translated the above 
proposition into polymorphic type theory in Section 8.1—where we only have 
weak sums.) 
We do a more complicated example (taken from [215]). The Axiom of Choice 
can be formulated in predicate logic and can thus be translated into dependent 
type theory. It yields the type 
IIx: a. Ey: r. </?(x, y) —)• E / : (fix: a. r ) . Ex: a. ^(x, / x ) . 
We are going to prove the Axiom of Choice in D T T by deriving a term ac 
which inhabits this type. Here we use the strong sum E. We shall reason 

Section 
10.2: Use of dependent 
types 
597 
informally: assume a variable 
z: Ha:: a. Tly: r. (p{x, y). 
Then for each x:a yje get 
zx\ Dt/: r. (^[x, y) 
so that we have first and second projections 
7:[zx):(T 
and 
TT'{ZX)\I^{X,'K{ZX)). 
Thus if we put / = \ x . 'K[ZX), 
then we get 
TT'[zx):ip[x,fx). 
Hence we take 
ac — \z. {\x. 7:{zx), \x. 7r'{zx)) 
where we have omitted the types of the abstracted variables in order to in-
crease readability. 
Our next example is taken from [323], again within the "types-and-
propositions-as-types" perspective. In predicate logic one formalises inferences 
like the following: 'All men are mortal; Socrates is a man; hence Socrates is 
mortal.' But not everything can be formulated in predicate logic. A famous 
elusive phrase is the so-called donkey sentence 
(due to Geach): 
Every man who owns a donkey beats it. 
The problem in formalising this sentence lies in 'it' referring back to the 
donkey. One might wish to try 
V(i: Donkey. Vm: Man. Owns(m, d) D Beats(m, d). 
But the quantification here is over all donkeys instead of over men owning a 
donkey. This problem can be solved in dependent type theory in the following 
elegant way. 
Urn: Man. Ux: {T>d: Donkey. Owns(m, d)). Beats(m, TTX). 
Or, alternatively, as: 
Ux: (Em: Man. T,d: Donkey. Owns(m, d)). Beats(7ra:r, 7T{7r^x)). 
What is the (subtle) difference between these formalisations? For more infor-
mation and a discussion, see [324]. But see also Exercise 10.2.4 below. 
Dependent 
type theory as a logical 
framework 
In [91] a distinction is made between the propositions-as-types perspective 
d la Howard and a la de Brmjn. 
The first is what we have considered so 

598 
Chapter 10: First order dependent type theory 
far—above, but also in simple and polymorphic type theory. The latter a 
la de Bruijn works differently: types are not used as propositions directly, 
but as a means to formulate a logic. In this way one gets what is called a 
logical framework: a system in which various logics and type theories can be 
formulated. This was first done systematically in the AUTOMATH project, and 
later further developed, for example, in the Edinburgh Logical Framework 
ELF, see [115] for the basics and [89] for further details, and also in Martin-
Lof's Logical Framework, see [232, Part IV]. Logical frameworks form the 
basis for proof tools like ISABELLE [250] and ALF [207]. 
The way dependent type theory can be used as a logical framework will be 
explained by way of example. One starts by postulating a constant 
f-Q:Type 
which one thinks of as representing propositions; it comes with a 'lifting op-
eration' T(-) 
a:Q hT(a):Type 
which maps a proposition to the type of its proofs. One can then describe 
implication as a constant, 
a:Q,l3:Q \- a D f3:Q 
or as 
l-D:Q-^r2-^Q 
together with two constants for introduction and elimination: 
a:Q,/?:Q h ImplJntro: (T(a)-^ T(/?)) -^ T(a D/?) 
a:Q,l3:Q 
h mpLeWm:T{a D f3) ^ T(a) ^ T{f3). 
These constants encode the introduction and elimination rules of implication. 
The first implJntro transforms a function / from proofs of a to proofs of /?, 
into a proof implJntro/ of a D /^. And if g:T{a D /?) is a proof of a D /? 
and x: T{a) is a proof of a, then impLelim^ x yields a proof of /?. It is Modus 
Ponens. 
In order to do (single-typed) predicate logic we assume a constant 
h D: Type 
which serves as domain over which the term variables of the logic range. Of 
course, there may be more such constants, giving rise to many-typed predicate 
logic. Notice that the variables which are used for the logic that we are encod-
ing, are the variables of the framework {i.e. of the dependent type theory in 
which we are working). This is convenient in implementations: the mechanism 
for handling variables can be described once and for all for the framework (see 
e.g. [250]). 
Universal quantification is now described via a formation constant 

Section 10.2: Use of dependent types 
599 
with introduction and elimination constants: 
a:D-^Q 
h 
a\\:\nUo'.(I{x'.D.T{ax))-^T{^D{oc)) 
a:D^Q 
h aW.eWm: Ti'^o {a))-^ 
(Ux: D.T {a x)). 
Notice that in this approach one does have a clear distinction between propo-
sitions (inhabitants of Q) and types (in the usual sense). 
Similarly one describes other connectives. Also for negation one can postu-
late a constant 
a: fi h double_neg: T(-n-.a) -> T{a) 
where -la = a D 1. and ± : fi is a constant for falsum. 
This gives us classical 
logic. As an example, we can now construct a proof-term 
a: fi, /?: Q, z: T[-^(3 D - a ) h L{z):T{a 
D /?). 
Therefore, we will need double negation, since the corresponding entailment 
->/? D -•» \- a D P does not hold constructively. We assume variables 
x:T{a) 
and y: T{-*/3). Then we can form a term 
M{x, y, z) = impLelim (impLellm z y) x: T(J_) 
and also 
N{x, z) = implJntro (Ay: T(-.^). M(x, y, 2)): T(-.-./?). 
Hence we get our required proof-term 
L{z) = implJntro {Xx: r ( a ) . double_neg N{x, z)):T{a 
D /?). 
A categorical analysis of such logical framework encodings in terms of in-
ternal categories is presented in [87]. There, a framework ATT is presented 
in which every universe U.Type 
of an encoded system comes with a "lift-
ing" operation tu'-U ^ 
Type. The associated context projection morphism 
{x: U, y'-tu{x)) 
—> {x: U) in the category of contexts of the framework (as will 
be explained in the next section) then gives rise to an internal category as in 
Example 7.1.4 (ii). It captures the ([/-part of) the system that is encoded as 
an internal category in the ambient category of the framework. 
Encapsulation 
and specification 
in dependent 
type 
theory 
In Section 8.2 we discussed encapsulation in polymorphic type theory via sum 
types of the form: 
Eai:Type. • • •Ean:Type. (cri ^ n ) x • • • x (o"^ -^ r ^ ) . 
Such types capture certain operations with types cr,- -^ Ti, containing type 
variables a. In dependent type theory one can also use sum types for encap-

600 
Chapter 10: First order dependent type theory 
sulation: this typically takes the form: 
A x i o m ( / i , . . . , / ^ ) 
where the fi are operations (programs) cr, -^ TI satisfying a certain axiom 
(or specification) Axlom(/):Type. Inhabitants of Axiom(/) are seen as proofs 
of the axiom). For example, for a given type cr:Type, the type of monoid 
structures on a is: 
Mon(cr) = Em: a ^ a -^ a. Ee: cr. 
(liar: cr. Eqcr(mxe,a^) x Eq(x(mea:, a:)) 
X (llx, t/, z\ (J. Eq^(mx(m2/2:), ifn{mxy)z)) 
. 
An inhabitant a: Mon(cr) can be identified with a tuple (m, (e, {p,q))) 
where 
p proves that e:a is a neutral element for m:a 
-> a -^ cr, and gf proves 
associativity of m. 
Higher order dependent type theories (as will be discussed in the next chap-
ter) enable us to combine the encapsulation of P T T with the encapsulation 
of DTT, so that, for example, we can collect all monoids as: 
Ea:Type. Mon(Q;) 
(This will be an inhabitant of Kind.) Also, the higher order structure can 
be used for modularisation and structured specification, see [201, 202], and 
also [205, 232, 217]. This use of sum types in dependent type theory also forms 
the basis for program extraction (via sum projections), see [247, 249] for more 
information and further references. 
Exercises 
10.2.1. We have constructed a proof term for the Axiom of Choice, namely 
h ac: {Hx: a. Ey: r. <p(a;, y)) —)• (E/: Ylx: a. r. Ilx: a. (p{x, fx)) 
Show that in the reverse direction there is a 'canonical' term 
h ca: (E/: Ux: cr. r. Ux: a. ip{x, fx)) -^ {Ux: a. Ey: r. ip{x^ y)) 
which is the inverse of ac, i.e. which satisfies ca(ac z) = z and ac(ca w) = w 
(as in Exercise 10.1.6). This gives us complete distributivity, see Exer-
cise 1.9.9. 
10.2.2. Give the proof of -i/3 D ->a h a D /3 in ordinary (classical) logic corre-
sponding to the proof-term L described above. 
10.2.3. 
(i) 
Formulate appropriate formation, introduction and elimination con-
stants for conjunction A and for existential quantification 3D (using 
dependent type theory as a logical framework). 

Section 10.3: A term model 
601 
(ii) Give proof terms inhabiting the types 
T(VD(a))^T(-i3D(-a)) 
and 
T(-I3D(-CV))-> T(Vz?(a)) 
where we have written -la for (the formally correct) A:r: D.-<{ax). 
10.2.4. 
Show that the two types given above for the donkey sentence are isomorphic 
(in the sense of Exercise 10.1.6). 
10.2.5. 
Define a type Gr(<j) of group structures on a type a—in analogy with the 
type Mon((7) of monoid structures, as described above. Describe a "forget-
ful" term Gr(cr) -> Mon(cr). 
10,3 A term model 
This section starts the categorical investigation of type dependency. It does not 
yet present an abstract categorical notion of w^hat constitutes a model of type 
dependency, but it contains a rather detailed investigation of the term model 
construction. It will bring forward the importance of a distinguished class of 
morphisms, called "display maps" (after Taylor [329, 330]) or "(dependent) 
projections", in a category of contexts. In the next section we capture this 
situation abstractly by the notion of "display map category", which forms a 
particular instance of a "comprehension category". 
In previous chapters we saw how one could construct certain categories 
of contexts from the syntax of various logics, but also from the syntax of 
simply or polymorphically typed calculi. These term model constructions are 
interesting since they show us some of the underlying categorical structure. 
Term models can also be formed for dependently typed calculi, but things are 
slightly more complicated. First of all, since terms can occur in types, one 
may have conversions between types. But then one may also have conversions 
between contexts (componentwise). In a term model, one should therefore not 
consider contexts F as objects, but equivalences [F] of contexts (under conver-
sion). We shall leave these square braces [—] implicit for contexts, types and 
terms, and consider syntax up-to-conversion. This keeps notation manageable. 
Also, we shall consider types and terms in contexts up to a-conversion. This 
allows us to assume that whenever we are dealing with two (or more) contexts, 
their sets of variables are disjoint. 
We now consider some arbitrary, but fixed, dependently typed calculus and 
form a category of contexts C from this syntactic material. This category C 
has 
o b j e c t s 
(equivalence classes of) contexts F 
m o r p h i s m s 
F -^ A, say with A of the form (a^i: cri,..., a?„: cr„) where 
the variables ici,.. .,iPj-i may occur free in the type Ci, 

602 
Chapter 10: First order dependent type theory 
are n-tuples (Mi,..., Mn) of (equivalence classes of) terms 
Mi typed as: 
r l-Mi:cTf[Mi/a?i,...,Mi_i/a?i.i]. 
Such a sequence of terms M: F —> A will often be called a 
context morphism. 
Notice the explicit substitutions in types. This is typical for DTT, as opposed 
to STT and PTT. These substitutions are performed simultaneously. 
For a context F = (a^i: cri,..., a?„: cr„), the identity map F ^ F is the n-tuple 
of variables (a?i,..., x„). The composite of morphisms 
(Mi,...,M„) 
{Ni,...,Nm) 
F 
^ A 
^ e 
say with contexts and types 
A = (xi:cri,...,Xn:cr„) 
and 
F h M,: cr^Mi/a^i,..., Mi_i/xi_i] 
© = (yi:n,...,ym:Tm) 
and 
A h NJ: Ti[Ni/yi,.,., 
Nj-i/yj^i], 
is the m-tuple (Li,..., Lm)'^ F —> 0 with components 
Lj = Nj[M/x\ = Nj[Mi/xi,..., 
M„/xn]. 
These are well-typed: 
F h Lj:Tj[Ni/yi,..., 
Nj.i/yj^i][M/x] 
= Tj[Li/yu . • •,Lj-i/y^-i]. 
By using appropriate substitution lemmas one can establish associativity of 
composition. This is a non-trivial matter. Already in STT it required consider-
able work to get associativity, see the exercises of Section 2.1. Here we choose 
to gloss over these details, and we refer to [332, 271] for more information. 
Remember that categories of contexts in STT and PTT always have fi-
nite products. The empty context is a terminal object, and concatenation of 
contexts yields binary products. These are the basic operations for contexts, 
corresponding to simple categorical structure. An important question is what 
structure is induced in the above category C by these operations on contexts 
in DTT. It is easy to see that the empty context again yields a terminal object. 
But concatenation of contexts in DTT does not yield Cartesian products, but 
rather "dependent sums". Consider the case of a context {x:a,y:T) 
of two 
types, where crucially x may occur in r. A context morphism T -^ {x:a,y: r) 
does not correspond to two morphisms T -^ {x'.a) and F —^ {y: r), but to two 
morphisms M:F -> (x:cr) and N:T -^ {y:T[M/x]). This dependent pairing 
property can be described via the existence of certain puUbacks in the cat-
egory C. More precisely, puUbacks along certain "projection" maps in C, of 

Section 10.3: A term model 
603 
the form 
(r,^:/>) 
-^ r 
Explicitly, for F of the form {xi'.ai,..., 
Xn'-o-n) this map TT: (F, Z: p) -^ T is 
the n-tuple (a^i,..., a:„) of variables in F. Such maps will be called display 
maps, or simply projections. They are "dependent" projections, because all 
the variables x\^., .,Xn declared in F may occur free in the type p that is 
projected away. 
It turns out that the collection of these display maps in C is closed under 
pullback (see the lemma below). This gives us the abovementioned corre-
spondence between context morphisms [M,N)'.T 
-> [x-.a^yw) and pairs of 
morphisms M: F -^ {x\ a) and A'': F -^ {y: r[M/a:]), in a situation: 
(M,7V) 
(F,y:r[M/x]) 
M 
{x:a,y:T) 
{x:a) 
The role of Cartesian products in simple and polymorphic type theory is 
taken over by (certain) pullbacks in dependent type theory. 
10.3.1. Lemma. The above display maps in the category C of contexts are 
stable under pullback in the following sense. For an arbitrary context mor-
phism M: F -^ A and a display map TT: (A, y: r) —> A on A, there is a display 
map on F in a pullback square of the following form. 
{V,z:r[M/x\) 
i^,y-r) 
-^ A 
(*) 
M 
Proof. Assume A is of the form {XIKTI,.. 
.,Xn-crn) so that the terms M,- are 
typed as: 
r h M,: (r,[Mi/xi,..., M,_i/x,_i]. 
Then we have as top morphism (r,z:T[M/x\) 
—>• (A,2/:r) in the above dia-

604 
Chapter 10: First order dependent type theory 
gram the sequence of terms 
( M i , . . . , M „ , z ) 
(r, z: T[M/X\) 
^ (A, y: r) 
This certainly makes the diagram commute. If we have another context 0 and 
context morphisms 
0 
^ r 
0 
^ (A, y: r) 
with M o N = TT o L then for each i < n there is a conversion 
0 h Mi[N/x] 
= Li:ai[Li/xi,..., 
Li_i/xi_i]. 
Thus we get as unique mediating map 0 —^ (T, z: T[M/X\), 
the m + 1-tuple 
(7Vi,...,iV^,L„+i). 
D 
Notice that for this result does not require any of the type constructors 1,11, 
weak E or strong E of dependent type theory—as introduced in Section 10.1. 
The lemma describes some basic categorical structure induced by context 
concatenation (actually extension with a single type only) and substitution. 
The type constructors correspond to certain additional categorical properties 
of the above class of display maps in C. This will be described next. 
But first we need some notation. We write V for the collection of display 
maps 7r:{T,x:(T) ^ 
F in C induced by types T h criType in context. Often 
we shall write these maps simply as {T,x:a) 
-^ F, leaving the projection 
TT implicit. By the previous lemma, these maps in V form a split fibration 
over the category C of contexts. This (codomain) fibration will be written as 
4; 
, where V~^ ^--> C ^ is the full subcategory with display maps as objects. 
This inclusion actually forms a "comprehension category" (see the description 
in Theorem 9.3.4). 
Notice that substitution TT* along a display map 7r:(F,a::cr) —> F in this 
fibration is weakening, since it moves a type F h r: Type to a bigger context 
T,x:a 
h r: Type in the pullback square 
(F, x: a, y: r) 
^ (F, y: r) 
(T,x:a) 
^ F 
The next two propositions describe the correspondence between type theo-
retical and categorical structure (for unit and dependent product and sums). 

Section 10.3: A term model 
605 
10.3.2. Proposition. A unit type l:Type in our calculus corresponds to a 
terminal object functor 1: C ^ V~^ for the associated 
fibration 
^ 
of dis-
play maps. The domain functor V~^ -^ C is then right adjoint to 1. 
Recall that a right adjoint to a terminal object functor was used in Sec-
tion 4.6 to describe subset types { —} for a preorder fibration. It plays a similar 
role of "comprehension" here, as formalised by the notion of comprehension 
category with unit in the next section. 
Proof. Assume a unit type h liType with (sole) inhabitant h (): 1. Define a 
functor l i C ^ P - ' by 
Then for an arbitrary display map ( 
^ 
) on F there is precisely one mor-
(V,x:a\ 
(T,z:l\ 
phism I 
^ 
) ^ I 
r 
) ^^^^ ^' ^^^^^^y (^' 0) where v is the sequence 
of variables declared in F. 
/ A , y : r \ 
Further, for display maps I 
j- 
I there is a bijective correspondence 
inX>-
F 
^ (A,y:r) 
in C 
which establishes that the domain functor dom: V~^ —>• C mapping a display 
map I 
j- 
I to its domain context (A, y: r) is right adjoint to the terminal 
object functor. 
Conversely, assume that the fibration 
I 
comes with a (split) termi-
nal object functor 1:C —> V^. 
Write h l:Type for the domain of the func-
tor 1 applied to the empty context 0. Take an arbitrary closed inhabited 
type, say h cro:Type with inhabitant h Mo'.ao, consider the unique mor-
/x:ao\ 
p 
/ 
z:l\ 
phism ( 
^ 
1 —y ( ^ I in the fibre over the empty context 0, and write 
0 = P[Mo/x]: 1. This is the sole inhabitant of 1: Type, since if F h A^: 1, then 

606 
Chapter 10: First order dependent type theory 
we get two morphisms over T 
-(T)='KT)-^(^^)=^' 
(v,N) 
where both N and P are considered as terms in context (r,x:cro) via weak-
ening, and where v is the sequence of variables in F. These maps are equal, 
because IF is terminal, and so we get a conversion F,x:cro h P = 
N:l. 
Because x does not occur in N we obtain: 
F h 0 = P[Mo/x] = N[Mo/x] = N:1. 
D 
(In the last part of the proof we have used the assumption that our de-
pendently typed calculus is non-trivial in the sense that there is at least one 
inhabited closed type.) 
10.3.3. Proposition, (i) Dependent products TL in the calculus correspond 
to the fibration i 
of display maps having products fj along display maps 
7r:(F,x:(T)-^F in C 
(This means: right adjoints JJ ^o weakening functors TT* together with 
a Beck-Chevalley 
condition: for a pullback square of the form 
(*) in 
Lemma 10.3.1 the induced canonical natural transformation is an identity—in 
this split case.) 
(ii) Weak dependent sums S correspond to left adjoints ]J along display 
maps satisfying Beck-Chevalley. 
(iii) And strong dependent sums H correspond to weak dependent sums for 
which the canonical map K in the diagram 
(F, x: (J, y: r) 
>• (F, z: T,x: a. r) 
(r,x:a) 
- r 
is an isomorphism. This map K has the dependent tuple term T,x:a,y:T 
h 
(x, y): TtX'.CT as last component. 
Notice that the products and coproducts in (i) and (ii) are products and 
coproducts in the fibration 
^ 
of display maps, with respect to its own 
comprehension category X>"^ «^ C"*", as described in Definition 9.3.5. This 
more abstract formulation will be used later on. Interestingly, the dependent 

Section 10.3: A term model 
607 
product Ha:?: a. (—) and sum Ex: a. (—), being right and left adjoint to weaken-
ing TT*, fit in the same pattern as the polymorphic product Ha: A.[—) and sum 
Ea: A. (—) in Chapter 8, and as universal Vx: cr. (—) and existential 3x\cr. (—) 
quantification in Chapter 4. 
Proof, (i) Assume dependent products 11 and define for a type F h cr: Type 
quantification along a display map TT: (F, :r: cr) —> F by 
fV,x:a,y\T\ 
j-j f 
V,z'I{x:a.T\ 
\ ri- ) ^ \ 
r 
)• 
Then one gets an adjoint correspondence between maps over F and over 
(F,x:cr) in 
V,w:p\ 
{v, M) 
/ V.z'Iix'.a. T\ 
f T,x:a,y:T' 
where n* is the "weakening" pullback functor induced by the projection 
7r:(F,x:cr) -> F along which we quantify, and where v is the sequence of 
variables declared in F. The bijection is obtained by sending a term T,w: p h 
def 
M:Ilx:a,T 
to T,w: p,x:o- 
\- M = Mx.r; 
and T,X:(T,W: p \- N:T 
with x 
not occurring free in p (by weakening) to T,w:p \- N = Xx:a. 
N:IIX:(T.T. 
The equations M — M and N — N are the (/?)- and (77)-conversions for H. 
Beck-Chevalley follows from the appropriate distribution of substitution over 
n's. 
In the reverse direction, assume that (categorical) products f| along dis-
play maps exist, satisfying Beck-Chevalley. For a type F, x: cr h r: Type, write 
Hx: cr. T for the type in context F for which 
where Y\ is quantification along 7r:(F,a::cr) -> F. The adjunction (TT* H Y\) 
gives a bijective correspondence between terms V^w.p 
h MiHxicr. r and 
V,w:p^x'.a 
h N:T. It yields abstraction and application operations for 11 
in the calculus, with an extra assumption w: p. One obtains the rules product 
rules from Section 10.1 by using for p any inhabited closed type. 

608 
Chapter 
10: First order dependent 
type 
theory 
(ii) Similarly. One obtaines a coproduct functor from sum types by 
m ' 
which captures quantification along TT: (F, x: cr) ^ F in a correspondence 
F,x:(j,t/:r\ 
( T,z\i:x:a.T\ 
{v,M) 
T,x:a 
I 
fV,x:a,y\r\ 
{v,x,N) 
/T,x:a,w:p\ 
\ 
T,x:a 
J 
^ \^ 
T,x:a 
J 
~^ 
between terms F, z: Da?: cr. r h M:p and F,x:cr, t/:r h N:p. The transpose 
operations correspond to "packing" via tupling (—,—) and "unpacking". 
(iii) An inverse morphism {T, z:T,x:a.T) 
—^ {T,x:(T,y:T) 
to the pairing mor-
phism K — [v, {x, y)) must have two terms 
T, z:T,x:a.T 
\-ht{z):a 
and 
T, z'.J^xicr.r 
\-sn6{z):T[ist{z)/x], 
as last two components. The fact that fst and snd form an inverse to K deter-
mines equations 
ht{{x, y)) = X, 
snd((;r, y)) = y, 
(fst(2:), snd(2:)) = z. 
Hence, if K has an inverse then we have first and second projections for S, 
making this sum strong. The converse is trivial. 
• 
As we have seen, the projections 7r:(F,a::cr) —>• F along which we quan-
tify in dependent type theory are not Cartesian projections (like in predicate 
logic and in polymorphic type theory) but are more general "dependent" pro-
jections. In Exercise 10.3.3 below we mention how equality (types) in D T T 
correspond (in the term model) to left adjoints to contractions functors S* 
induced by "dependent" diagonals S:(T^x:a) 
—^ (T^x-.a^x'-.a). 
This follows 
the abstract pattern of equality with respect to a comprehension category 
(see Definition 9.3.5), which also underlies equality (and quantification) in 
predicate logic and in polymorphic type theory, via "simple" comprehension 
categories. This fundamental role of comprehension categories will be further 
investigated in the next two sections. 
Exercises 
10.3.1. Estabhsh an isomorphism in the category of contexts TT: (F, Z: 1) -^ F, where 
h 1: Type is a unit type. As a result, the singleton context (2:: 1) is isomorphic 
to the terminal, empty context 0. 

Section 10.4- Display maps and comprehension categories 
609 
10.3.2. Describe explicitly so-called "mate" rules (see e.g. Lemma 4.1.8 and Exer-
cise 8.1.3) for dependent products 11 and sums E, as used implicitly in the 
proofs of Proposition 10.3.3 (i) and (ii). 
10.3.3. For a type T h crrType write J:(r,a::cr) —)• {r,x:a,x':a) 
for the context 
morphism in the category C of contexts given by the sequence of terms 
(y, x,a:), where y is the sequence of variables declared in context F. 
(i) 
Verify that S is the unique mediating map for the pullback of the dis-
play map 7r:(F,a;:cr) —> F against itself. Hence this is a diagonal as 
associated with the comprehension category V^ 
'-)• C~^ in Defini-
tion 9.3.5 (ii). 
(ii) Check that the associated pullback functor S* performs contraction. 
Assume now that we have finite product types (1, x) in our calculus—the 
latter for example because we have dependent sums E. 
(iii) Show that weak equality types corresponds to left adjoints to these 
contraction functors S* plus Beck-Cevalley, as formulated in Defini-
tion 9.3.5 (ii). 
(iv) Prove that strong equality types correspond to left adjoints as in (iii), 
satisfying the additional property that the canonical map H, in 
(T^x'.cr) 
>• {r,x:(T, x'lcr, 
z:Fjq(j(x,x')) 
{r,x: cr, x': cr) 
is an isomorphism. 
(Note the similarity with the formulations of 'strong equality' in Propo-
sitions 10.3.3 (iii) and 4.9.3.) 
10,4 Display maps and comprehension 
categories 
In the previous section we have defined a (term model) category of contexts 
in dependent type theory, and v^e have seen how a distinguished class of 
"projection" or "display" maps 7T:(T,x:a) 
—> F in this category allowed us 
to describe the type constructors 1, H, E, Eq categorically. In this section we 
shall describe the notion of a "display map category" following [329, 330, 148], 
which captures this situation abstractly. In a next generalisation step, we shall 
describe the relevant context structure in terms of comprehension categories— 
which were used earlier in Section 9.3 to give a general notion of quantification. 
Display map categories form instances of such comprehension categories. We 
close this section with the notion of "comprehension category with unit"; 
essentially it is a fibration with subset types—as given by a right adjoint to 

610 
Chapter 10: First order dependent type theory 
the terminal object functor for preordered fibrations in Section 4.6—except 
that the preorderedness restriction is lifted. 
10.4.1. Definition. A display map category (or a category with dis-
play maps) is a pair (B, X>) where B is a category with a terminal object 1, 
and V C ArrB is a collection of morphisms in B, called display maps or 
projections which is closed under pullback: for each family I 
y 
\ ^ V 
and each morphism w: J —>• / in B, a pullback square 
U'{ip) 
exists in B, and for every such pullback square one has that w*(<^) G T>. 
We write V^ for the full subcategory of the arrow category B~^ with display 
maps as objects, and 
-^ 
for the associated codomain fibration. The fibre 
over / G B will be written as V/1 using a slice notation. 
For such a display map category (B, X>) we formulate the following addi-
tional conditions. 
(unit) All isomorphisms in B are in V. 
(product) For each display map <^: X —> /, the pullback functor ip*:V/I -> 
V/X has a right adjoint Y\m ^nd a Beck-Chevalley condition holds: for a 
pullback square as above, the canonical natural transformation i/* f][ => 
n«*((p) ^'* ^^ ^^ isomorphism. 
(weak sum) For each display map <y?, the pullback functor ^* has a left 
adjoint ]J plus Beck-Chevalley. 
(strong sum) Display maps are closed under composition. This implies 
(weak sum). 
(weak equality) For each display map (p:X ^ I, write S{<f) = (id,id):X 
-> X X / X for the mediating diagonal of the pullback of (p against itself. 
The requirement is then that each S{(p)*:V/(X 
Xj X) -^ V/X has a left 
adjoint Eq^^, plus a Beck-Chevalley condition (see Exercise 10.4.2 below for 
the details). 
(strong equality) Each such diagonal S{(f) is a display map. The condition 
(weak equality) can then be proved. 
A display map category is called a relatively Cartesian closed category 
(RCCC, for short) if it satisfies (unit), (product) and (strong sum). 

Section 10.4- Display maps and comprehension categories 
611 
Notice that the class V in this definition is required to be closed under all 
puUbacks—and not under particular chosen ones. As a result, the class V is 
closed under (vertical) isomorphisms. One could have relaxed the condition so 
that V is required to be closed under certain chosen pullbacks only, but these 
pullbacks should then be such that they compose, in order to get appropriate 
substitution properties—and afibration. But requiring particular pullbacks to 
compose is not so natural, and such matters are better handled by using fibra-
tions from the start, as is done with comprehension categories. Notice by the 
way that in the term model C in the previous section we do have distinguished 
pullbacks, which compose, see Lemma 10.3.1. In the comprehension category 
version of the term model (see below) this happens because we have a split 
fibration, and this splitting induces the particular pullbacks of projections. 
fT,x:a\ 
By closing the class of context projection maps I 
^ 
I under vertical 
isomorphisms we do get a (term model) display map category. The role of the 
above conditions on display map categories can be seen in Proposition 10.3.3 
and Exercise 10.3.3. Following [329, 330], display map categories with such 
conditions have been used in many places, see e.g. [148, 272, 320, 185]. 
We notice that the strong versions of dependent sum and equality have 
much easier formulations than the weak ones. This will be different for com-
prehension categories, see Definitions 10.5.1 and 10.5.2 in the next section. 
Finally, we note the following similarity. The general categorical description 
of simple type theories was given in Section 2.4 in terms of CT-structures. The 
latter are pairs (E, T) where B is a category (of contexts) with finite products 
and T C Obj B is a collection of types, considered as singleton contexts. For 
dependently typed calculi, we do not use a subcollection T C Obj B of objects, 
but a subcollection V C ArrB = Obj (B"^) of morphisms. More formally, we 
do not use subfibrations of simple fibrations, but subfibrations of codomain 
fibrations. Hence CT-structures and display map categories form similar gen-
eralisations of these type theoretic (simple and codomain) fibrations. 
(Display map categories are clearly more general than CT-structures, since 
every CT-structure (B, T) gives rise to an associated collection of display maps 
/ / x X \ 
given by constant families r(X) 
= I 
j ^ 1 for / G B and X G T.) 
Comprehension categories 
The above notion of display map category is not entirely satisfactory, because 
it does not give a central position to types, but instead to the projections 
induced by types. Therefore, we shall be using certain presentations of display 

612 
Chapter 10: First order dependent type theory 
map categories, called 'comprehension categories' in [155, 157]. These were 
used earlier in Section 9.3 to give a general form of quantification along certain 
"projection maps". These projection maps will play the role of the display 
maps above. This double role of comprehension categories—providing both 
domains of quantification and context structure for type dependency—will 
turn out to be very convenient (see e,g. in Definition 10.5.1 in the next section). 
We consider again the syntactically constructed category C of contexts from 
the previous section for explaining the intuition behind the use of comprehen-
sion categories for modelling type dependency. We already have a category 
C of contexts, see the beginning of Section 10.3. But one can also form a 
category T of types, as follows. 
o b j e c t s 
types F h cr:Type in context. 
m o r p h i s m s 
(F h crrType) -> (A h r:Type) are pairs (M,7V) with 
M: F -^ A a context morphism in C and N a term 
F,x:cr \- 
N:r[M/v\ 
where v is the sequence of variables declared in A. 
The obvious projection functor i mapping a type F h cr: Type to its under-
lying context F is then a split fibration. Cartesian (split) morphisms are of 
the form [M^x) 
where x is a variable. This fibration actually comes about 
by applying the Grothendieck construction to the functor (C°P —> C a t which 
assigns to a context F the category Tp of types and terms in context F; it 
has types F h criType as objects and terms F,x:cr h N:T 
as morphisms 
(F h cr:Type) -> (F h r:Type). 
The projection morphisms TT: (F,x:cr) -^ F in the category C of contexts 
now arise in the following way. There is a functor V from the category T 
of types to the arrow category C~^, which maps a type F h cr: Type to its 
corresponding projection morphisms TT: (F, ar: cr) -> F in C Here one sees how 
the types are taken as primitive, and the associated projections as induced by a 
functor acting on types. A morphism (M, A^): (F h cr: Type) -> (A h r:Type) 
in the category T of types is sent by V to the following commuting square in 
the category C of contexts. 
(r,x:(T) 
( M l O TT, . . . , M „ O TT, TV) 
^ (A,j/:r) 
( M i , . . . , M „ ) 
-^ A 

Section 10.4'- Display maps and comprehension categories 
613 
The functor V:T -^ C^ that we construct in this way satisfies the following 
four properties. 
(1) The composite c o d o P i T 
-> C of P with the codomain functor 
T 
cod:C^ -^ C is a fibration, namely the fibration i of dependent types 
over their contexts. 
(2) The functor V sends Cartesian morphisms in T to pullback squares in C. 
This is how the pullback squares in Lemma 10.3.1 arise. 
(3) The functor V is full and faithful. 
(4) The base category C has a terminal object (namely the empty context). 
Points (1) and (4) are obvious. As for (2), a Cartesian morphism (M, x) in T 
is sent to a pullback square (*) as described in Lemma 10.3.1. And (3) is left 
as an exercise below. 
We conclude that this functor V:T ^ C"*" gives a presentation of the class of 
display maps TT: (F, x: cr) -> F in C, that we described directly in the previous 
section. The pullbacks in Lemma 10.3.1 arise by applying V to split mor-
phisms in T. We can now see that these pullbacks compose (in C~^) precisely 
because split morphisms compose in T. This structure in C is thus induced 
by the structure in T via the functor V. Since P is a full and faithful functor, 
everything that we want for these display maps (like the various conditions 
in Definition 10.4.1) can be described for the fibration ^ . For convenience 
. . 
.^ 
we repeat (from Theorem 9.3.4) the two conditions defining a comprehension 
category. 
10.4.2. Definition. A comprehension category is a functor of the form 
' P i E ^ B - ' for which 
(i) the composite cod o P: E -^ B"^ ^ B is a fibration; 
E 
(ii) if/ is a Cartesian morphism in E with respect to this fibration i , then 
V{f) is a pullback square in B. 
Such a comprehension category V will be called full if'P is a full and faithful 
functor E —> B~^. And it is called split (or cloven) whenever the fibration 
cod o "P: E ^ B is split (or cloven). 
This definition captures the above points (1) and (2). Points (3) and (4) are 
not part of the definition, since they are not relevant for the use of compre-
hension categories in quantification. In models of type theories however, full 
and faithfulness and a terminal object in the basis will always be there. 
We thus see that the above constructions yield a "term model" full compre-
hension category T -^ C"*". And for every display map category (B, P), where 
D is a class of maps in B closed under pullback, the inclusion V^ <^ B~^ is 
an instance of a full comprehension category. 

614 
Chapter 10: First order dependent type theory 
We recall from Section 9.3 some important examples of (full) comprehension 
categories. 
(i) The identity functor W^ —^ B~^ for a category IB with pullbacks forms 
the identity comprehension category. This example arises from the display 
map category (IB, V) where V contains all morphisms from B. 
(ii) The simple comprehension category 
s(IB) -^ E"^ for a category IB 
with Cartesian products x. It maps an object (/, X) G s(B) to the Cartesian 
IxX 
projection ( 
j 
1. In this example there is no real type dependency. 
(iii) The subobject comprehension category Sub(B) —> B~^ for a category 
B with pullbacks. It takes a subobject to a representing arrow in B. 
(iv) Recall from Definition 7.3.5 that a full internal category C in a base 
category B has a full and faithful fibred functor Fam(C) -^ B"*" over B. Hence 
C is full if and only if its externalisation is part of a full comprehension 
category. 
But there are many more examples, see e.g. Exercise 9.5.6. 
10.4.3. Notation and terminology. Let 7^:E -> B~*^ be a comprehension 
category, and write p — cod o "PiE ^ B for the fibration involved. For an 
object X G E in the total category, the corresponding morphism VX 
in B 
will be called a projection or a display map. We therefore often write 'KX 
for VX 
when this functor V is understood from the context. An induced 
reindexing functor TT^ = VX"" will be called a weakening functor. 
We write { —} = dom o P : E —> B for the second functor E —>• B induced by 
V—again 
whenever V is understood from the context. Thus for a morphism 
/ : X ^ y in E we get in B a commuting diagram written as 
This square is a pullback in case / is Cartesian. Besides weakening func-
tors TT^, there are also contraction functors ^\ 
induced by the diagonal 
^X' {-^} -^ {^x(^)} obtained in the pullback of TTX against itself (as special 
case of the lemma below). 
Often we use the corresponding small Roman letters p — cod o V for the 
fibration involved. Thus we write q for the fibration cod o Q when Q is a 
comprehension category. 

Section 10.4' Display maps and comprehension categories 
615 
A section of a projection nx—that 
is a morphism s:pX 
-^ {X} with TTX O 
s = id—may be called a term (of t y p e 
X). 
It is worthwhile to formulate the following abstract version of Lemma 10.3.1 
explicitly. 
10.4.4. Lemma. Let 7^:E ^ 
B~*" be a comprehension 
category. 
Its 
projec-
tions are stable under pullback in the following 
sense. For each object X 
EE 
and morphism 
u: I -^ pX = (cod oV){X) 
in M there is a projection 
with 
codomain I and a pullback of the 
form: 
{u{X)] 
Tw*(X) J 
Wx 
pX 
Proof. Since p = cod o "piE -^ B is a fibration, we can choose a Cartesian 
morphism u{X): u*{X) —>• X over u. It is mapped by V to the above pullback 
square in B. 
• 
This result allows us to describe substitution in terms. Consider a morphism 
u: J -^ I in the basis B of a comprehension category 'PiE —> B"^, and a 
term s: / —> {X] 
of type X G E/. Then we can define a term w^(s) of type 
w*(X) G Ej as the unique mediating map w^(s): J —^ {w*(X)} for the above 
pullback, with rru*(x) ^ u'^(s) = idj and {u{X)} 
o 1/^(5) = s o u. 
As a result of the lemma, projections of a comprehension category thus give 
rise to a display map category. 
10.4.5. Corollary. For a comprehension 
category V:]E —)• B"^, write [V] C 
Arr B for the image of V closed under vertical isomorphisms. 
That is, [V] is 
smallest class containing 
all projections 
VX 
and satisfying: 
ip = rjj in B / / and 
(f E [V] implies ip ^ [V]. Then (B, [V]) is a display map category. 
• 
And the pullback in the above lemma enables a form of dependent tupleing. 
10.4.6. Corollary. For a comprehension 
category P i E —> B"*" we have an 
isomorphism 
B ( / , {X}) ^ 
] J 
{s\sisatermoftypeu*(X)}. 
D 
u:I-^pX 
In type theoretic formulation, the functor {—} = dom o 'P of a compre-
hension category V sends a type F h cr: Type to the corresponding extended 
context {T,x:a). 
It is precisely this operation which is difficult in dependent 

616 
Chapter 
10: First order dependent 
type 
theory 
type theory, since one cannot use Cartesian products F x cr as in simple of 
polymorphic type theory (where one has no type dependency). A form of 
disjoint union U^^p -(^[v) is needed in DTT—as in the above corollary. 
Comprehension categories with unit 
The following definition gives rise to an important class of examples of com-
prehension categories. 
E 
10.4.7. Definition (See [74, 62]). A fibration ^P with a terminal object 
functor 1: B —>• E is said to admit comprehension if this functor 1 has a right 
adjoint, which we commonly write as { —}:E —> B. We then have adjunctions 
p H H { - } . 
In this situation we get a functor E —> B^ by X i-^ p{^x), where Sx is the 
counit 1{X} —^ X of the adjunction (1 H { —}) at X. This functor is actually 
a comprehension category, see below. In such a situation, we shall call this 
functor a comprehension category with unit. And we shall say that p 
admits full comprehension if this induced comprehension category is full 
(i.e. if E —> B^ is a full and faithful functor). 
A "fibration with subset types" as introduced in Definition 4.6.1 is thus sim-
ply a preorder fibration with comprehension. Many of the properties which 
hold for such fibrations with subset types also hold for fibrations with com-
prehension. But there is one important exception: the fact that the induced 
projections 7rx:{X} —>• pX are monos for fibrations with subset types cru-
cially depends on preorderedness, see the proof of Lemma 4.6.2 (i). 
We check that the functor E —)• B~^ as in the definition is a comprehension 
category indeed. Therefore we need to show that for a Cartesian morphism 
/: X —> y in E, the naturality square 
(.) ^
^ 
in 
TTX 
=P{ex) 
Try 
-piey) 
pX 
^pY 
Pf 
is a pullback in the base category B. If morphisms u: I -^ pX and v: I —^ {Y} 
are given with pf o u = iry o v, then the transpose v^ = ey ^ Iv'-H —^ Y 
satisfies 
p{v^) — p{ey) O pl{v) — TTy O V — pf O U. 

Section 10.4'- Display maps and comprehension categories 
617 
Since / is Cartesian, we get a unique map g:\I 
-> X in E over u with 
f o g — v^. But then, taking the transpose g^ — {g] o rji'.I ^ {^}^ yields 
the required mediating morphism: 
TTx o g^ -TTX o {g] or]j = p{g) o TTU o T]I =z u o p{eii) o pl{rji) - u 
and 
{/} ^ g^ - {f ^ 9} <^ VI = {^''} orji = v'''' = V. 
Uniqueness is left to the reader. 
We recall that a terminal object functor 1 is full and faithful, because the 
counit pi => id of the adjunction {p H 1) is the identity, see Lemma 1.8.8. 
Therefore, the unit components / -^ {1-^} of the adjunction (1 H { —}) are 
isomorphisms. 
Notice that being a comprehension category with unit is a property of a 
fibration; namely that it has a fibred terminal object and that the resulting 
(terminal object) functor has a right adjoint. In contrast, an arbitrary compre-
hension category 7^:E ^ B~^ provides the underlying fibration p = cod o V 
with certain structure. Therefore we may say that a fibration 'is' a compre-
hension category with unit. 
This description of comprehension via a right adjoint to the terminal ob-
ject functor is a simplification of the description originally proposed by Law-
vere [193], see also Exercise 4.6.7. A slightly different notion of comprehension 
is proposed by Pavlovic [252]. See [157] for a comparison of these notions. 
10.4.8. Examples, (i) For a category IB with finite products (x, 1), the sim-
ple comprehension category s(B) —)• B~^ is a comprehension category with 
s(B) 
unit. The underlying simple fibration 
i 
has a terminal object functor 
B —> s(B), namely / H-> (/, 1). This functor has a right adjoint, given by 
(/, X) i-> / X X. The resulting projection TT^/x) (as in the above definition) 
is the Cartesian projection ir: I x X -^ I. 
(ii) For a category B with pullbacks, the identity functor B~^ -^ B~*" is 
a comprehension category with unit, since there are the following two basic 
adjunctions 
cod H 
H) dom 
where the up-going arrow in the middle is the terminal object functor / i-^ id/ 
for the underlying codomain fibration. 

618 
Chapter 10: First order dependent type theory 
(iii) Let C be a category with terminal object 1 G C, and small hom-
Fam(C) 
sets C(1,X). The family fibration 
i 
then has a terminal object functor 
1: Sets -^ Fam(C) by J i-> (1)JGJ- And 1 has a right adjoint by disjoint union: 
{Xi)iei^\lc{l, 
Xi) ={{i,x) 
| i G / a n d x : l - > X i } . 
This will be called the family comprehension category Fam(C) —> Sets"^. 
It is rarely full, see Exercise 10.4.4 (ii). Notice that the special case where 
C = Sets yields the equivalence Fam(Sets) ^ Sets"*" from Proposition 1.2.2. 
(iv) For a calculus of dependent types with a unit type 1: Type we form the 
T 
term model fibration ^ of dependent types F h cr:Type over their contexts F, 
as described earlier in this section. This fibration then has a fibred terminal 
object F h 1: Type in the fibre over context F. The associated functor 1: C —>• T 
has a right adjoint, which maps a type F h cr: Type to the extended context 
(F, x: cr). We have an adjoint correspondence 
(F h l:Type) 
^ (A h r:Type) 
in T 
F 
^ (A,y:r) 
in C 
amounting to an (obvious) correspondence between 
context morphisms M: F 
^ A with a term F, x: 1 h N: 
T[M/V\ 
context morphisms (P, Q): F 
>- (A, y: r) 
The functor T —)• C"^ induced by this adjunction maps a type F h cr: Type 
to the associated projection 7r:{T,x:a) —)• F. (But these projections can of 
course be described directly, without using the unit type.) 
(v) As already mentioned, every fibration with subset types is a compre-
hension category with unit. Notice that the latter is full if and only if the 
fibration has full subset types (as defined in Section 4.6). In particular, ev-
Sub(l) 
ery subobject 
fibration 
i 
forms a full comprehension category with unit 
Sub(B) -> W^. 
It is not the case that a comprehension category with a fibred terminal 
object for its underlying fibration is automatically a comprehension category 
Fam(Sets^) 
with unit. As counter example, consider the family 
fibration 
i 
of set-
Sets 
indexed-pointed sets. This fibration has a terminal object functor 1: Sets -^ 
Fam(Sets^) since the category Sets^ has a terminal object {•}—which, at 

Section 10.4- Display maps and comprehension categories 
619 
the same time, is initial object. The fibration also carries a comprehension 
category structure Fam(Sets») -> Sets"*", namely 
{Xi)iei ^ I 
} 
I 
In this situation we do not have that the functor {Xi)i^i i-^ Ufe/ ^* ^^ right 
adjoint to the terminal object functor, since morphisms (l)jeJ ~^ {Xi)iei 
in Fam(Sets^) correspond simply to functions J ^ I, and not to functions 
J^Ui^jXi. 
Fam(Sets^) 
(But the fibration 
i 
has a fibred monoidal structure given point-
wise by the monoidal structure on pointed sets Sets» (with"smash" product 
as tensor and 2 — {0,1} as neutral element). The comprehension functor 
{Xi)i(^i H-> Wi^i ^i ^^ ^ right adjoint, namely to the neutral element functor 
2:Sets-^Fam(Sets^).) 
The inclusion Fib '—^ Cat"*" forms a comprehension category on the fi-
bration of fibrations over their base categories (see Lemma 1.7.2). The latter 
does admit comprehension, given by a right adjoint ( ^ ) ""^ Cart(E) to the 
terminal object functor, but this gives a different comprehension structure. 
Fam(Cat) 
A similar fibration 
i 
of Cat-valued presheaves is shown not to admit 
Cat 
^ 
comprehension in [106]. (But Sets-valued presheaves do admit comprehen-
sion, see Exercise 10.5.1.) 
Next we reformulate the main points of Lemma 4.6.2, adapted to the present 
setting. The proofs are as in Section 4.6. 
E 
10.4.9. Lemma. Let 
^ 
he a fibration with comprehension. 
(i) Fix an object J G B; for maps u\ I ^ J in B and objects Y E E over 
J, there is an isomorphism 
E / ( l / , t/*(y)) ^ B / j ( w , Try). 
Moreover, these isomorphisms are natural in u and Y—when both sides are 
seen as functors (B/J)°P X E J =t Sets.; 
(ii) The induced functor E —> B"^ preserves all fibred limits. It also pre-
serves products W-
As a result of (i), terms of type X G E/, which were defined as sections 
of the projection nx'-i^} 
—)- / in Notation 10.4.3 above, can be identified 
in a fibration admitting comprehension with the global sections 1(7) -^ X 
in the fibre over /. This description of terms as maps in fibres is often more 

620 
Chapter 10: First order dependent type theory 
convenient. 
Proof. We only prove the last statement about preservation of products f^, 
say with respect to a comprehension category Q:D -> B~^. For A G O, we 
have a projection QA in B, say with domain and codomain QA\ J —^ K. For 
a morphism u: I —^ K we can form a pullback square 
u' = QAUu) 
L = domQ(u*{A)) 
^ domQA = J 
Q{u*{A)) 
QA 
-^ codQ^ = K 
u 
The assumed right adjoint ]~[A ^^ 2 ^ * ^^ ^ satisfies, by (i): 
^ E/ ( l / , n«*(A) ^'*(^)) 
by Beck-Chevalley 
- 
E L ( Q K ( A ) ) * ( 1 / ) , t/'*(X)) 
Hence the projection TTT-T /^X in M/K behaves like a product O Q ^ I I ^ ^ ) ^^ ^^^ 
arrow fibration on B. 
• 
Finally we have the following alternative "representability" description of 
comprehension categories with unit. 
E 
10.4.10. Proposition. Let 
^ 
be a fibration with fibred terminal object. 
Then p admits comprehension if and only if fibred global sections are repre-
sentable; that is, if for each X G E, say above I £M, the functor 
(IB//)op 
^ Sets 
given by 
(j — ^ /) I 
^ Ej (l J, 
u*(X)) 
is representable. 
Proof, (only if) For X G E/, the projection TTX'- {X} —^ I is a. representing 
arrow, since for u: J —^ I one has B//(w,7rx) — Ej(lJ, w*(X)), by (i) in the 
previous result. 

Section 10.4- Display maps and comprehension categories 
621 
(if) Choose for each object X G E a representing arrow wx and write {X} 
for its domain. Then 
E ( I J , X) 
^ 
H 
^J{^^^ 
^ * ( ^ ) ) 
by Lemmal.4.10 
s B(J, {X]). 
So the terminal object functor 1:B -^ E has a right adjoint { —}. 
• 
This result provides a link with local smallness for fibrations (which was 
already announced as Lemma 9.5.2). 
E 
10.4.11. Corollary. Let 
^P he a fibred CCC. Then p is a 
comprehension 
category with unit if and only if p is locally 
small. 
Proof. Since each fibre is a CCC, vertical morphisms X -^Y 
correspond to 
global sections 1 ^ (X => Y). So the former are representable if and only if 
the latter are. 
• 
Exercises 
10.4.1. Let (B, T>) be a display map category. Prove that if there is a family 
( j 1 G X> which is inhabited {i.e. for which there is a map 1 -> X), 
then a terminal object functor IB —>• T>~*^ is automatically left adjoint to the 
domain functor X>"*'—)• B. 
10.4.2. 
Consider a display map category (B, V) which satisfies the (strong equality) 
condition in Definition 10.4.1 and in which the collection V is closed un-
der Cartesian products (in slices B//). Show that the associated fibration 
admits equality with respect to the comprehension category V~^ M- B ^ , 
as described in Definition 9.3.5. Give an explicit formulation of the Beck-
Chevalley condition (from this definition) for equality in display map cate-
gories. 
10.4.3. 
Verify that the term model comprehension category "P: T —> C~^ is full. 
10.4.4. (i) Show in detail that one gets a "family" comprehension category with 
unit Fam(C) -^ Sets"*" in Example 10.4.8 (iii). 
Fam(C) 
(ii) Prove that 
i 
is a full comprehension category if and only if the 
global sections functor C(l, —): C -^ Sets is full and faithful. 
10.4.5. Verify that the functor r:Fam(C) -^ B~^ in Exercise 7.3.5 forms a com-
prehension category with unit. (It gives an internal version of the family 
example described above.) 

622 
Chapter 10: First order dependent type theory 
10.4.6. A category with families according to [72] (see also [137]) consists of a 
category C with a terminal object together with 
(a) a functor F = (Ty,Te):C°P —)• Fam(Sets); for an object / G C we 
write F{I) = (Te(/,o'))^ rp .^., and for a morphism u: J -> / in C 
we write F{u) as consisting of functions Ty(w):Ty(/) —>• Ty(J) and 
Te(w):Te(/,(T) -> Te{J,Ty{u){<T)), for each a e Ty(/); 
(b) for each / 
G C and a G Ty(/) a comprehension: an object 
I ' a £ C together with a morphism P{(T): I - cr -> / and an element 
Va G Te(/ • (7, Ty(p((T))(o')) such that: for each w: J -> / in C and 
t G Te(J, Ty(w)((T)) there is a unique morphism (u^t): J -^ I - a with 
p{cr) o {u, t) = u and Te((u, t)){V(x) = t. 
Define for such a functor F a category F with 
objects 
pairs (/, cr) with / G C and (T G Ty(/). 
morphisms 
(/?cr) -^ C-^?'^) ^re pairs (w,t) where w: / -> J is a 
morphism in C and t is an element of Te(/ • (T, Ty(u o 
P{<r))[r)). 
Define a split full comprehension category F -^ C~^. 
E 
10.4.7. Let 
^^ be a fibration with comprehension. We write r} and e for the unit 
and counit of the adjunction (1 H {—}). Recall that the projection TTX is 
defined as p(£x). 
(i) 
Show that the projection TTU: {1/} —)• I is the inverse of the unit com-
ponent rfi. 
(ii) For X G E above /, prove that 
{!x} = r?7o;rx:{X} 
^ {1/} 
where \x is the unique map X -^ \I over /. 
(iii) Prove that if \x''X 
—> 1/ is a mono in E, then the projection 
TTx: {X} -> / is a mono in B. 
E 
10.4.8. Let 
-i-P be a fibration with fibred finite products and full comprehen-
sion. 
(i) 
Prove that for X^Y^Z G E in the same fibre, say over / G B, there is 
a bijective correspondence 
X xY 
^ Z 
over / 
^x{y) 
^^x{Z) 
over{X} 
natural in Y,Z. 
(ii) Conclude that in such a situation, fibred colimits are automatically 
distributive, i.e. preserved by functors X x (—). 
10.4.9. 
Consider two contexts F = [xi: 
) and A = (yi: n , . . . , ym: Trrx) 
in DTT together with a context morphism 5 = (Mi,..., Mm)'- F —>• A. It 
yields a substitution functor 5*: T A —> Tr in the reverse direction. Assume 

Section 10.5: Closed comprehension categories 
623 
weak sum and weak equality types. Then one can define for a type T h 
p: Type 
Eqri(yi,Mi) X ••• X Eqr^(ym,Mm) X p 
which yields a type in context A. 
(i) 
Prove that ]J^ is left adjoint to 5*. 
(ii) Assume dependent products fl. Show that one can also define a right 
adjoint to s* by 
( E q r i ( y i , M i ) X ..• xEcirm{ym,Mm)) 
"^ /O-
10.4.10. Let P : E —>• B"^ be a comprehension category. Write E^ for the full image 
of P, i.e. for the category with 
objects 
X G E. 
morphisms 
X -^ Y in E^ are morphisms VX -)• VY in B"*". 
Define a full comprehension category P ^ : E^ -> B"*". (It is the full comple-
tion of V and called the 'heart of P ' by Ehrhard.) 
E 
10.4.11. Let 
^P be a fibration with (full) comprehension and let F: A —)• B be a 
functor with a right adjoint, where A is a category with puUbacks. Prove 
that the fibration F*(p), obtained by change-of-base along F, also admits 
(full) comprehension. 
[See also Exercise 9.5.5.] 
10.5 Closed comprehension 
categories 
From a semantical perspective, the most natural combination of type construc-
tors in dependent type theory is: unit type 1, dependent product 11, and strong 
sum E. In the present section we introduce a categorical structure which com-
bines these operations, and call it a "closed comprehension category". (Such a 
notion has also been identified in terms of display maps as a "relatively Carte-
sian closed category", (RCCC) see [329, 148], or Definition 10.4.1.) There are 
many instances of these closed comprehension categories, some of which will 
be presented in this section. The next section is devoted to two domain the-
oretic examples. There are many more examples, e.g. in [148] (based on "lim 
theories", forming categorical generalisations of domain theoretic examples), 
in [185] (generalisations Girard's qualitative domains), in [132, 133] (with so-
called setoids), and in [137] (a presheaf model for proving a conservativity 
result). 
What we have not defined yet is what it means for a comprehension cate-
gory to have (dependent) products and coproducts. We take this to mean: the 

624 
Chapter 10: First order dependent type theory 
underlying fibration has products and coproducts with respect to the (projec-
tions of the) comprehension category itself. (Recall from Definition 9.3.5 that 
one can define quantification in a fibration with respect to a comprehension 
category.) Here we make convenient use of the double role of comprehension 
categories: in quantification and in modelling type dependency. 
10.5.1. Definition. Let P i E ^ IB"*" be a comprehension category. We say 
E 
that V admits products if its underlying fibration ^P —where p = cod o 
V—admits products with respect to the comprehension category V:'E—^ M"^ ; 
that is, if p has products n^ H Ylx ^long 'P's projections TTX = VX (plus a 
Beck-Che valley condition), see Definition 9.3.5. 
E 
Similarly we say that V admits weak coproducts if the fibration ^ has 
coproducts with respect to V\ this involves adjunctions W^ H TT^ plus Beck-
Chevalley. 
^ 
. 
. 
And V admits weak equality if ^^ has equality with respect to V. This 
IB 
involves left adjoints Eqx H S*x along its own diagonals, again with Beck-
Chevalley. 
Next we should say what strong coproduct and equality are. 
10.5.2. Definition. Let V:^—^ B"^ be a comprehension category. 
(i) We say that V admits strong coproducts if it has coproducts as 
above in such a way that the canonical maps K are isomorphisms in diagrams 
of the form: 
{Y) 
TT 
{X) 
lUxW} 
pX 
(ii) Similarly, V admits strong equality if there are canonical isomor-
phisms: 
{y} 
{X} 
- {Eqx(y)} 
{^*x{X)) 
The canonical maps {Y] -> {1IA:(^)} ^n^ i^) 
-^ {EqA-(y)} in this def-
inition arise by applying the functor {—} = dom o P to the (opcartesian) 

Section 10.5: Closed comprehension categories 
625 
composites 
y 
Y 
^*x UxiY) 
IJx(^) 
S*x^^xiY) 
Eqx(Y) 
Finally we come to the main notion of this section. 
10.5.3. Definition. A closed comprehension category (CCompC) is a 
full comprehension category with unit, which admits products and strong 
coproducts, and which has a terminal object in its base category. It will be 
called split if all of its fibred structure is split. 
The easiest model of type-indexed-types in dependent type theory uses set-
Fam(Sets) 
indexed-sets, as formalised by the family fibration 
i 
. This fibration 
is a (split) CCompC: it has full comprehension plus products and coproducts 
along all morphisms in the base category, so certainly along projections TTX-
Explicitly, for a family X = {Xi)i^j over / and a family Y = O^a)^,^]] 
x 
over {X} = Ui^j Xi we have the standard formulas: 
YlxiY)i 
= {/: Xi ^ U.ex. Yn.r) I Va: € Xi.fix) 
e Y(i,.)} 
Ux(y)i 
= 
{{x,y)\xeXie.ndyeYi}. 
(Interestingly, no equality is needed to define these adjoints along dependent 
projections, whereas one does need equality for adjoints to arbitrary substi-
tution functors u*, see the proof of Lemma 1.9.5. These dependent products 
and coproducts are natural extensions of the simple products and coproducts 
along Cartesian projections, see Lemma 1.9.2) 
The above coproduct ]J is strong, since there is a (canonical) isomorphism 
iUxiy)} 
= 
{{i,{x,y))\i€I,xeXi^,ndyeY^i,,)] 
= {{{h x), y)\iel,x 
€ Xi and y € ^(i.x)} 
= {{a, 2/) I Q € Uiei ^i ^nd y G Ya} 
= {Y}-
Instead of modelling dependent types as set-indexed-sets, one can also take 
objects of a category indexed by themselves, as formalised by a codomain 
fibration. The latter is a (non-split) CCompC if and only if the underlying 
category is locally Cartesian closed, see Theorem 10.5.5 (ii) below. 
As mentioned after Lemma 10.4.9, terms of type X G E/ in a com-
E 
prehension category with unit 
can be identified with vertical maps 
B 

626 
Chapter 10: First order dependent type theory 
1(/) -^ X. We sketch the interpretation of the introduction and elimina-
tion rules for 11 and E in a CCompC as above. For Il-introduction, assume 
a term I,x:X 
h f:Y, 
given as a vertical map 7r^(l(/)) = ^{X} 
-> Y. 
Its transpose yields the abstraction map Xx{f)''l{I) 
-^ YlxO^)- ^^^ ^^^ 
H-elimination, we assume terms ^: 1(/) —^ YlxO^) ^^^ h:l{I) 
—> X. Then 
we get a transpose TT^(!(/)) ^ Y of /, and also a transpose h^:I -> {X} 
of h across (1 H {—}). These can be combined into an application term 
gh: 1(7) - {h^rn'^m) 
-> (/i^)*(y) = Y(h). 
For sum-introduction, assume maps /: 1(7) -> X and g: 1(7) —^ (/^)*(y). 
By using the unit of the adjunction (JJ;^ H TT^) at Y we get a tu-
pie term (/,ff):l(/) ^ 
( r ) ' ( y ) ^ 
( D ' ^ ^ f U x l ^ ) = Uxl^'); And for 
(strong) E-elimination, assume an object Z E E over {IJx(^)} ^i^h a term 
7, x: X, y: Y \- h: Z{{x, y)). This h can be identified with a map h: {Y} —> {Z} 
in B with TTZ o h = K: {Y} •=>• {Uxl^)}- Hence h o K~^ is a, section of TT^, 
and thus yields a term 1 ( U A ' ( ^ ) ) —^ Z, as required. Further details are left 
to the reader. More elaborate studies of the categorical interpretation of (first 
and higher order) dependent type theory may be found in [319, 134]. 
Notice that we do not include equality in the definition of a CCompC. We 
shall have more to say about equality towards the end of this section. 
First a basic result. 
10.5.4. Proposition. 7/'P:E -^ B"*" is a closed comprehension category, 
then its underlying fibration p = cod o V:'E —^ M is Cartesian closed. The 
fibred Cartesian product and exponent are given by: 
XxY 
= Ux{^xiy)) 
«"rf 
X^Y 
= 
Ylx{^x{y))-
In particular, the underlying fibration of a CCompC is locally small, see 
Corollary 10.4.11. Hence it is small if and only if it has a generic object, by 
Corollary 9.5.6. See Exercise 10.6.3 for an example of a small CCompC. 
Proof. In the fibre over 7 G B one has: 
Ei{z, 
X XY) 
^ B/7(7rz, TTTT ^* (y)) 
by fullness 
,^z, Unxi'^^xi^)'^) 
^^^^^ U '^ strong 
,7rz, Unx ^*X{^Y)) 
by Lemma 10.4.4 
TTj^ , TTx X Try ) 
^TTz, TTx) X B/7(7rz, Try) 
^ E/(z, x) xE/(z, y). 

Section 10.5: Closed comprehension categories 
627 
(Actually, it can be shown that the object X xY = Uxi'^xO^)) 
^^ ^ product 
without assuming that the coproduct ]J is strong, see Exercise 10.5.4 (ii).) 
For fibred exponents we have adjoint correspondences: 
Z 
^nx^x(Y) 
= X^Y 
• 
The above categorical descriptions of the binary product x and the ex-
ponent ^ 
coincide with the syntactic definitions a x r = T,x:a.T and 
a ^ T = Ux: a. r, for x not free in r, given in Example 10.1.2. By a standard 
argument (as in the proof of Lemma 1.9.12) one can show that in presence 
of these fibred exponents =>, the coproduct ]J and equality Eq in a CCompC 
automatically satisfy the Frobenius property. 
Next we consider the three main (general) examples of comprehension cate-
gories. The first two involve what we have called the 'type theoretic' fibrations 
and the third one the 'logic' fibration. 
10.5.5. Theorem. Let A be a category with finite products and B a category 
s(A) 
l"^ 
with finite limits. The simple fibration I , the codomain fibration 4- 
and 
Sub(l) 
the subobject 
fibration 
i 
are all fibrations admitting full comprehension 
with strong coproducts. Moreover: 
s(A) 
(i) 
i 
is a CCompC if and only if A is a CCC; 
(ii) 
^ 
is a CCompC if and only ifM is a LCCC; 
Sub(l) 
(iii) 
i 
is a CCompC if and only if it is a fibred CCC. 
The three points of this result bring a number of different notions under a 
single heading. In particular, points (i) and (ii) show that finite products and 
exponents are related like finite limits and local exponentials (exponents in 
slices). 
Proof. In the previous section we have already seen that all three fibrations 
admit full comprehension. The codomain and subobject fibrations have strong 
sums, simply by composition. A coproduct functor U^j J^^, left adjoint to 7r| ;^, 
for the simple fibration 
i 
along the projection TT/x- / x X —> / is given by 

628 
Chapter 10: First order dependent type theory 
(/ X X, y) »-^ ( ^ j ^ X y)' These coproducts are strong since 
= Ix(X 
xY) 
^ 
(IxX)xY 
= 
{{IxX,Y)}. 
(i) In case A is Cartesian closed we get a product functor fir/ x) ^^^ng 
7T:I X X -^ I by {I X X,Y) 
\-^ {I,X =>Y). Then, writing the fibre s(A)/ as 
the simple slice A//, we get 
= A{I xz, X =>Y) 
^ A{(I xX) X Z, 
Y) 
= 
A//{IXX){Z,Y) 
= s(A)/xx(7r*(/,Z), ( / x X , y ) ) . 
In the reverse direction, we have, by the previous proposition, that if the 
simple comprehension category s(A) —>• A"*" is closed, then the underlying 
simple fibration i 
is Cartesian closed. In particular, the fibre s(A)i = 
A 
_ 
A/1 = A over the terminal object 1 is Cartesian closed. 
(ii) By Proposition 1.9.8, since the induced comprehension category is the 
identity functor B"*" —>- B"^ , which has all maps in B as projections. 
(iii) The (only if)-part follows from the previous proposition. For the con-
verse, assume subobjects m:X >-^ I and n:Y >-^ X. The product subobject 
riml^) ^^ ^ "^^y ^^ defined as m D (m o n), where D is the exponent in the 
fibre over /. For a mono k: Z ^^ X, we get appropriate correspondences: 
^ < rimW = mD 
{mon) 
m o m*{k) = m Ak < 
{mon) 
m*{k) < n 
The latter holds because m is monic. 
• 
10.5.6. Term model. Assume a dependent calculus with unit type liType 
and with dependent products 11 and strong sums E. In Example 10.4.8 we 
described how the structure of contexts in DTT leads to a full comprehension 
T 
category with unit i given by types (F h a: Type) G T over their contexts 
F G C Here we show that the type theoretic products II and strong sums E 
make this fibration into a closed comprehension category. 

Section 10.5: Closed comprehension categories 
629 
For a type F h cr: Type we have to produce products and strong coproducts 
along the associated projection map TT: (F, x: cr) —> F in C. Essentially this is 
already done in Proposition 10.3.3, but here we give a reformulation in terms 
of comprehension categories: this means that these product and coproduct 
functors do not act on the projections {i.e. display maps) induced by types, 
but on the types themselves. Explicitly, these functors are given by 
product f|: 
( F , x: cr h r: Type) H-> ( F h Ha::: cr. r: Type) 
coproduct J j : 
( F , ar: cr h r: Type) H-> ( F h E X : cr. r: Type). 
The mate correspondences for dependent product D and sum E (see Exer-
cise 10.3.2) show that these assignments yield right and left adjoints to weak-
ening TT*. The categorial requirement of strong coproducts is satisfied, since 
the canonical pairing morphism 
(F, x\ cr, y\ r) 
>• (F, z: Ex: cr. T) 
is an isomorphism. Its inverse is the sequence (v.irz^n'z), 
which uses first 
and second projections 7rz:cr and W'Z'.TITTZ/X], 
typical for strong sums see 
Proposition 10.1.3 (i). In this way we get a term model closed comprehension 
category. 
One can extend this example with equality, and show that the type theoretic 
formulations used in Section 10.1 lead to the appropriate categorical structure. 
Assume therefore equality types Eq in the calculus. For a type F h or; Type 
there is a diagonal morphism J:(F,x:cr) —^ (F, x: cr, x': cr) in C, by (iT, x,x), 
and an associated contraction functor S*, which maps 
( F , x: cr, x': cr h r: Type) 
to 
( F , x: cr h r[x/x']: Type). 
This functor S* has a left adjoint, namely 
(F,x:cr h p: Type) i-> ( F , X : cr, x': a h Eqc7(x,x') x p:Type). 
The adjunction requires a bijective correspondence between terms P and Q 
in 
F, x: cr, x': a, z: Eq^(x, x') x p \- P:T 
- (Eq-mate) 
F, x: a,w: p h Q: r[x/x'] 
It is given by 
P H^ 
P[x/x',{r,w)/z] 
Q ^ 
Q[7r'z/w] with x' = x via TTZ. 
This equality is strong in the syntactic sense if and only if it is strong in 
the categorical sense (as in Definition 10.5.2). This can be seen as follows. In 

630 
Chapter 10: First order dependent type theory 
the category C of contexts there is the canonical map 
( r , x: a, w: p) 
^ (F, x: cr, x': a, z: Eqa{x, x') x p) 
An inverse of K should be a sequence p, = {M, P^Q) of terms for which there 
are conversions—in context F, x: cr, x^: a, z: Eq<7(a?, x') x p—of the form: 
Mi — Vi^ 
P = X = x', 
r = TTz, 
Q — TT'Z. 
Hence the presence of such an isomorphism p leads to the strong equality 
conversions as in Proposition 10.1.3 (ii). And conversely, these conversions 
tell us how to define an inverse p if equality is very strong. 
In the presence of fibred equalisers—or equivalently, strong equality types, 
see Theorem 10.5.10 below—products fj in a CCompC can be obtained from 
exponents and strong coproducts JJ, following a standard formula (used earlier 
for LCCCs). This is the content of the following result. We only sketch the 
proof, since the details are not so interesting. 
E 
10.5.7. Proposition. Let 
jrP a fibration with fibred finite limits, full com-
prehension, 
strong coproducts and a terminal 
object in its base category. 
Then 
p is a fibred CCC if and only if it is a CCompC 
(actually 
a CCompC 
with 
strong equality, by Theorem 10.5.10 
below). 
Proof. We shall show how to define products Y\ from exponents =>. For 
objets X G E over / E B and Y E E over {X}, form H x l ^ ) ^^ domain of the 
equaliser 
A(7r') 
{X ^ 
fst) 
where fst:]J^(y) -> X is the first projection, obtained as unique map with 
{fst} = Try o K-^: { I J ^ ( y ) } ^ {Y] -^ {X], 
using fullness. 
D 
Notice that the formula for the product H x l ^ ) ^^ ^^^^ proof is used for the 
family example immediately after Definition 10.5.3, and also in the proof of 
Theorem 10.5.5 (iii). 
We continue with examples of CCompCs. 
10.5.8. P E R s and o m e g a - s e t s . We have mentioned set-indexed-sets as a 
model of type dependency. Of course we can also take u;-set-indexed-u;-sets 

Section 10.5: Closed comprehension categories 
631 
and PER-indexed-PERs as denotations of dependent types since the cate-
gories u;-Sets and P E R of cj-sets and PERs are locally Cartesian closed. 
Interestingly, there are equivalences of fibrations 
UFam(a;-Sets) 
a;-Sets^ 
UFam(PER) 
PER~^ 
4
-
^
4
- 
and 
i 
c:i 
i 
(jJ-SGts 
u;-Sets 
P E R 
PER 
(see Propositions 1.4.7 and 1.5.3) and we obtain split CCompCs on the left. 
Further instances of split CCompCs are the fibrations 
UFam(PER) 
UFam(PER) 
UFam(a;-Sets) 
i 
i 
i 
u;-Sets 
Eff 
Eff 
We shall sketch some details of the first and third example. 
UFam(PER) 
The 
fibration 
i 
of PERs over u;-sets admits full comprehension, 
CJ-Sets 
with right adjoint to the terminal object functor given by 
R = {Ri)ieii,E) ^-^ {R} = lJi€/^/^^' ^'^^ ^(^'' Nii.) = E{i) A [n]R^. 
For a second collection of PERs S — {Sa)a£{R} we have product and coprod-
uct 
f^^(5)i = {(Ar, /?') I Vn,^ n'. nRin' implies k • nSi^i^[rn])^'' ^'} 
LIi?(5')i = {((n,m),(n',m')) I n/^fTz'and mS'(i,[n])m'}. 
These are special cases of the formulas for quantification along arbitrary maps 
in the proof of Lemma 1.9.6. This coproduct is strong since 
{Ufl(5)} = 
{(i,[^])h"€/andfce|Ufl(5)i|} 
= {{i,[{m,n)]) I i € /, n € \Ri\ and m G [^(i,[„])]} 
- 
{((«') N)> M ) h' € /, n G \Ri\ and m G !%,[«]) 1} 
= {5}. 
UFam(a;-Sets) 
We turn to the 
fibration 
i 
, as introduced in Section 6.3. The 
Eff 
' 
functor { —}:UFam(u;-Sets) -^ EfF, right adjoint to the terminal object func-
tor, is described in the first few lines of the proof of Proposition 6.3.3. For a 
family of cj-sets X = (-^[i])[i]6r(/,«) over (/,«) and a family Y = (Ya) over 
r{X} = Urji^rr/ w) ^[«]' ^^ have a (strong) coproduct 
LJx(^)w = {{^^y)\^ 
^ ^[i] and y G >^([z],ar)}. 
Products Yl are obtained by the previous proposition. It applies since the 
UFam(C<;-Sets) 
fibration 
I 
has fibred finite limits and exponents by a pointwise 
Eff 
construction. 

632 
Chapter 10: First order dependent type theory 
10.5.9. Topos models. Let B be a topos. By Proposition 5.4.7 IB is locally 
Cartesian closed, so the codomain fibration on B is a (non-split) CCompC 
by Theorem 10.5.5 (ii). And by point (iii) in the same result, the subobject 
fibration on B is a (split poset) CCompC. What we will show next is that the 
:r(i) 
codomain fibration on B is equivalent to a split fibration 
i 
, and that the 
latter fibration is a split CCompC. In the codomain fibration one has display 
indexing and substitution by pullback, whereas in the new split fibration one 
has pointwise indexing and substitution by composition. The construction 
comes from [154], and generalises the idea of inclusions followed by projections 
as display maps, as used in [46] in a set-theoretic setting. 
The total category ^(B) of our split fibration arises as follows. 
objects 
triples (/, X, </?) where <^: / x X -^ Q is a map in B. For each 
such object we choose a corresponding mono m<^: {<^} ^^ 
/ X X, and write ir^ = TT o m^^: {ip} —> /. 
morphisms 
{I x X ^ Q) -^ {J x Y -^ Q) are morphisms iv^p —^ n^ in 
B"^ . They consist of a pair of maps u: I -^ J and /: {(p} -^ 
{xp} 
w i t h TT^ O f = U O TTip. 
By construction there is a full and faithful functor ^(B) -^ B"*". Post-
composition with the codomain functor yields a fibration ^(B) —>• B, which 
sends an object {I xX —> Q) to /. It is a split fibration since for such an object 
(f over / and a morphism u: J —^ I one gets a reindexed object u*{(p) — (p o 
u X id over J by composition. The idea is to think o f < y : ? : / x X ^ r ^ a s a 
family of /-indexed sets {Xi)i^i, given as Xi = {x E: X \ (p(i, x) = true}. The 
functor ^(B) -> B"^ given by y? H^ TTJ^ is a fibred equivalence: in the reverse 
/ y 
\ 
direction a family I 
^^ J is sent to the characteristic map J x Y -^ Q of 
the mono (^,id}:y y-^ J xY. 
A (split) terminal object functor 1:B -^ ^(B) 
is obtained by J H^ (true o TT': J x 1 ^ fi); it is left adjoint to <^ »-)• {(p}. 
We turn to dependent coproduct and product. Assume therefore objects 
(f:IxX—^Q 
over / and rp: {(f}xY 
-^ Q over {p}. We have to produce objects 
LI(p(^) ^^^ 0(^1 V^) ^^^^ ^- "^^^ coproduct U x ( ^ ) ^^ obtained as characteristic 
map in 
mw; 
m^n X id 
^ 
{xP} > 
^ {^} X Y > 
^ (I xX)xY 
-^I 
x{X 
xY) 
true 
^ 
1> 
^fi 

Section 10.5: Closed comprehension categories 
633 
Then, by construction the projection TTTT ^.^ of this coproduct equals TT^^ o TT^, 
so that we have a strong coproduct. 
For the product HC^JIV^) ^^ ^^^^ form the maps (p, xp, using the partial map 
classifier in B (see Proposition 5.4.5): 
m^p 
rn^ 
m^ x rjy 
W) > 
^ / X X 
{V^} > 
^ {if] X Y > 
^ (/ X X) X LY 
J 
J 
' 
Y 
I 7p 
Y 
W} ^zr^ M^} 
W > 
Mi^} 
'lip 
vip 
Together with auxiliary maps 
a = 
(TT X id, ev o TT' X id): {I x {X => A.Y)) x X —^ {I x X) x lY 
f3 = A(±(7r' om^)oip)o7r: 
I x{X ^ ±Y) —> {X ^ 
1.X) 
7 = A(±(7r' om^o7r^)o^oa): 
I X {X => JLY) —> (X ^ 
IX). 
Finally, one obtains the product object Hc^lV^)- ^ x (X => 1.Y) ^ ^ as char-
acteristic map of the equaliser {n(n(V^)} >^ / x (X => LY) of/?, 7. It yields a 
split version of the usual dependent product in LCCCs. 
We conclude this section with a characterisation of strong equality in CCom-
pCs in terms of fibred equalisers. It shows that strong equality is quite natural, 
from a categorical perspective. 
10.5.10. Theorem, (i) A CCompC has strong equality if and only if its un-
derlying fibration has fibred equalisers. 
(ii) And in this situation, the fibration is a fibred LCCC. 
With this result it is easy to see that the CCompCs in Example 10.5.8 of 
families of PERs and of u;-sets have strong equality, because the underlying 
fibrations have fibred equalisers, obtained pointwise from equalisers in the 
categories of PERs and of u;-sets. 
The link between locally Cartesian closed categories and dependent type 
theory with unit, product and strong sum and equality was uncovered in [306]. 
There, only empty contexts are used, whereas here, LCCC-structure is ob-
tained in every context (and hence in fibred form). 
E 
Proof, (i) Let 
;;^^ be a CCompC. Assume it has strong equality. For parallel 
maps f,g:X 
=4 Y in a fibre, say over / G B, consider the mediating map 
{{f}A9})'{^} 
-> UYO')} 
in B for the pullback of wy against itself. Put 
Eif^g) - ({/}, {^})*(Eqy(1)) G E{x} and Eq(/,^) = Ux ^iLg) 
E E/, with 

634 
Chapter 10: First order dependent type theory 
first projection fst: U^ E{f,g) -^ X. We claim this is the equaliser of / and 
^ in E/. Consider therefore the diagram 
• J 
{X} 
{{f),{9)) 
{T^(y)} 
{Eqy(l)} 
In this situation it follows that {/} o {fst} = {g} o {fst}, and so / o fst = 
g o fst. If also h: Z -^ X in Ej satisfies foh 
— goh 
— k, say, then the 
maps {/i}: {Z] -^ {X] and {k}\ {Z} -> {Y} induce a unique mediating map 
{Z} —-> iUx^if^d)} 
^^ ^^^ diagram, and thus a mediating map Z —^ 
W^ E{f,g) in E/ by fullness. 
In the reverse direction we assume fibred equalisers, and write for an object 
X eE, 
X' = 7r3^(X) G E{x} and ex:l{X} 
-^ X' for the vertical part of 
the counit component Sx'-^i^] 
-^ -^- Similarly, we write X'^ — 7r^,(X') 
and 6x' for the vertical part of Sx' • It is not hard to see that the transpose 
{X] -^ {X'] of Ox is the diagonal 8x-
Let E{X) E E be the domain of the following equaliser in the fibre over 
{X']. 
E(X) 
— I 
> • 1{X'} 
Ox' 
X" 
^\\\{XY) 
""^'(^^^ 
With some eff'ort one can show that there is an isomorphism 
{E[X)-\ 
- — ^ - 
{X} 
{X'} 
SO that diagonals occur as projections. Then we can define an equality functor 
Eqx:E{x} ~> E{X'} by Eqx{y) 
= '^*x'0^) ^ ^i^)- 
We get the appropriate 

Section 10.5: Closed comprehension categories 
635 
adjoint correspondences: 
Eqx {Y) = w*(Y)xZ 
^Z 
E(X) 
^7r*{Y)^Z 
Sx S TrE(X) 
>• ^iT'{Y)zi.Z 
-^S'^{7r*{Y)^Z)^Y^S*^(Z) 
Y 
^S*^(Z) 
And this equality is strong since we have isomorphisms in B / { X } : 
=. TTy O Sx • 
(ii) The LCCC-structure is obtained from equivalences ( E / ) / X ^ 
^X] 
for X G E/j which arise as follows. In one direction, an object Y E E|x} is 
mapped to the first projection fst: ]Jj^ (Y) —> X. This yields a full and faithful 
f Z \ 
functor. In the other direction, one maps a vertical family I 
:j;^ I to the 
domain D{(p) of the following equaliser. 
D(^) ^-^ ^x(^) d z m ^ ""^(^^ 
° 
Oxo\ 
Exercises 
Fam(Sets) 
10.5.1. 
Show that the 
fibration 
i 
of presheaves (see Example 1.10.3 (ii)) 
is a closed comprehension category with strong equcdity. 
[Comprehension for this fibration is described in [193]. For every functor 
F: A -)• B in the base category the reindexing functor F* hcis both a left 
and a right adjoint (by left cind right Kan extension), but Beck-Che valley 
does not hold in general. It does hold cJong the dependent projections and 
diagonals.] 
10.5.2. Describe the interpretation of the weak sum elimination rule, in a full com-
prehension category with unit and coproducts. 

636 
Chapter 10: First order dependent type theory 
10.5.3. Assume a category C with terminal object 1 and arbitrary coproducts 
(i) 
Show that if the global sections functor C(l, —):C —> Sets preserves 
coproducts then the family comprehension category Fam(C) —^ Sets"^ 
has strong coproducts. 
(ii) Suppose that coproducts in C are disjoint and universal. Prove that 
the functor C(l, —): C —^ Sets preserves coproducts if and only if the 
terminal object 1 is indecomposable {i.e. if 1 = ]J-gj Xi then l = Xi 
for some i £ I). 
10.5.4. Let P r E —)• ]B~* be a comprehension category with unit and coproducts 
{i.e. with the underlying fibration p = cod o V having P-coproducts). 
(i) 
Show that if p admits full comprehension, then it has fibred finite 
products—with X xY = I J x ( ^ ^ ( ^ ) ) ^^ ^^ Proposition 10.5.4. 
(ii) Use (i) to show that Frobenius holds automatically for ]J, in case 
comprehension is full. 
(iii) Prove that p admits full comprehension if and only if the canonical 
maps Ux(^'f^^) ~^ ^ ^^^ isomorphisms. That is, if and only if the 
counit components ex'-1{^} 
—^ X are opcartesian. 
(iv) Show that the following statements are equivcdent. 
(a) The coproducts JJ are strong. 
(b) The functors K*:E|TT .^.^ —)• lE{y} induced by the canonical 
maps K: {Y} -^ {LIx(^)) ^ ^ ^^^ ^^^ faithful. 
(c) The maps IK: 1{Y} -> l{IJx(^)} ^^^ opcartesian. 
10.5.5. 
(From [154]) For a closed comprehension category V\^ -^ B~^, form the 
fibration {~}*(p) by change-of-base in: 
Famp(E) 
^ E 
{-Yip) 
p 
E 
{-} 
(i) 
Prove that {—}*(p) is again a CCompC, with as projections the vertical 
maps fst: Ujj^ (V') -^ X. It may be seen as a CCompC over p. 
(ii) Conclude from (the proof of) Theorem 10.5.10 (ii) that the induced 
functor Fam7?(E) -)- V(E) is an equivcdence if P : E ^ B"^ hcis strong 
equality. 
10.5.6. Consider a comprehension category 'P:E -> B"*" whose underlying fibration 
has fibred coproducts +• We call these strong fibred coproducts if for 
each pair of objects X^Y 
€ E in the same fibre, the induced tuple of 
reindexing fimctors 

Section 10.6: Domain theoretic models of type dependency 
637 
is full and faithful. 
(i) 
Investigate what this means in the term model comprehension category 
(ii) Prove that for a codomciin 
fibration 
^ 
the following statements 
are equivalent. 
(a) The category B has universal coproducts +. 
B~^ 
(b) The 
fibration 
^ 
has fibred coproducts +. 
B 
(c) The identity comprehension category B~^ -^ IB"*" has strong fibred 
coproducts +. 
Hence fibred coproducts -h are automatically strong in a codomain 
fibration. 
(iii) Assume strong coproducts -(-, and give categorical proofs of the iso-
morphisms 
LJx+y(^) = I J x M ' ( ^ ) + L J r K r ( ^ ) 
from Exercise 10.1.7. 
10.6 Domain theoretic models of type dependency 
In this section we describe two domain theoretic examples of closed compre-
hension categories (forming models of DTT with 1, Y[ ^-nd strong ]J, see the 
previous section). The first example is based on directed complete partial or-
ders (dcpos), and the second one on closures (in Pa;). In the first example, a 
type-indexed-type will be a family of dcpos continuously 
indexed by an index 
dcpo. Such a family will be understood as a functor from the index dcpo to a 
category of dcpos which preserves filtered colimits^. We simply use dcpos to 
construct a model, but one can also work with Scott domains, see [57, 245] 
(and Exercise 10.6.2). 
In the second example, a type-indexed-type will be a closure-indexed-
closure. The latter will simply be a morphism in the category of closures 
from the index closure to a distinguished object fi, which may be understood 
as the closure of all closure—or as the type of all types. It is a model of higher 
order dependent type theory and forms a bridge between this chapter and the 
next one. This model is based on [302, 15]. 
^ The idea of using such continuous functors, together with dependent product and co-
product as defined below, goes back to Plotkin's "Pisa Notes" (1978). Here we only put 
these ideas in the present categorical framework. 

638 
Chapter 10: First order dependent type theory 
In both these examples the detailed verifications that everything works 
appropriately are quite lengthy, and for the most part left to the reader. More 
information about domain theoretic models may be found in [329, 330, 148, 
57, 245, 61]. 
We start with some order-theoretic preliminaries. Recall that a directed 
complete partial order is a poset in which every directed subset has a join. 
Categorically, this means that the poset, as a category, has filtered colimits. 
A function between dcpos is called (Scott-)continuous if it is monotone and 
preserves directed joins. This yields a category, for which we write Dcpo. It 
is Cartesian closed, with singleton poset as terminal object, product of the 
underlying sets with componentwise order as Cartesian product, and with 
set of continuous functions with pointwise order as exponent. We shall use a 
second category of dcpos, namely Dcpo^^. It has as objects dcpos, and as 
morphisms f.A-^B 
pairs / = (/^,/^) of continuous functions f^:A —)• B 
d^xid P'.B -^ A which satisfy p o ^ = id and ^ o fP < id. One calls /^ an 
embedding, and /^ a projection. 
Let (j): A —>^ Dcpo^^ be a functor with a dcpo A as domain. For an in-
equality fli < 02 in A, we write the corresponding morphism (f>{ai) -^ ^(02) 
in Dcpo^^ as an embedding and projection pair: 
(j){ai < 02)^: 0(ai) -^ 0(^2) 
and 
(j){ai < 02)^: 0(02) -> (t>{^i)-
Such a functor (j): A —^ Dcpo^^ will be called continuous if it preserves 
filtered colimits. A classical result in this area, see e.g. [3], is that continuity 
of (f) amounts to the following requirement: every directed join a = Vie/ ^* ^^ 
A yields a directed join 
( V ^(^' ^ ^y"" ^(^» ^^y] = i^ 
in the dcpo of continuous functions (j){a) -> <^(a). We shall work as if this 
condition defines continuity for (j). 
10.6.1. Definition. Consider the following functor Dcpo^'^ —> Cat. Its fibre 
category over A G Dcpo has 
objects 
continuous functors (j):A^ 
Dcpo^^ with A as domain. 
morphisms 
{A —> Dcpo^^) —> {A —^ Dcpo^^) are families 
/ = ( < / , ( a ) - ^ - * ( a ) ) ^ ^ ^ 
of continuous functions /a, satisfying the following two 

Section 10.6: Domain theoretic models of type dependency 
639 
requirements. 
(1) If oi < 02 in A, then 
<j){ai < a2Y o fa^ o (t){ai < 02)^ < fa^-
(2) li a =: Vie/ ^*" ^^ ^ directed join in A, then fa can be 
written as a directed join: 
/a = V ^(^*' - ^y"" •''«' "^ ^(^*' - ^)^-
2 6 / 
The identity on an object <f): A ^ Dcpo^^ over A E Dcpo is the collection 
of identity functions on 0(a), for a E A. This is an appropriate morphism by 
the continuity condition for (j). And composition of </> ^ V^ ^ % is given by 
the collection {ga o fa)aeA- Thus we get a category (over A). 
Reindexing is done by composition: for a continuous function w: J5 ^ ^ in 
Dcpo we get a substitution functor by 
0 K-> 0 o ti 
and 
{fa)aeA ^ ifn{b))beB-
The resulting split fibration of continuous families of dcpos over dcpos will be 
CFam(Dcpo) 
written as 
i 
Dcpo 
CFam(Dcpo) 
10.6.2. Lemma. The 
fibration 
i 
has a (split) terminal object 
Dcpo 
functor l:Dcpo —> CFam(Dcpo) with 1{B): B -^ Dcpo^^ sending every 
element b E: B to a singleton poset. This functor 1 has a right adjoint { — } , 
which maps a continuous functor </>: A ^ Dcpo^^ to the "Grothendieck com-
pletion" 
{(j)] = {(a, x) \ a E A and x E <f>(ci)} 
with order 
(ai,xi) < (02,^2) ^ ^1 < 02 in A and ({){ai < a2y{xi) < X2 in 0(02). 
The resulting functor CFdiin(Dcpo) -^ Dcpo"^ mapping (f) over A to the first 
CFam(Dcpo) 
projection TT^J,: {(f)] —>• A is full and faithful, so that the 
fibration 
I 
^ 
Dcpo 
admits full comprehension. 
Proof. It is easy to see that l:Dcpo -> CFam(Dcpo) is a terminal object 
functor, so we concentrate on its right adjoint. For (f):A -^ Dcpo^^ the set 
{(f)} — {{a,x) \ a E A and x G <t>(^)] is a dcpo, since for a directed collection 
(a,-, Xj) in {0} one can compute the join as: 
\/i{ai,Xi) = (a, \/i(f){ai < a)^(xi)), 
where a = y^ai. 

640 
Chapter 10: First order dependent type theory 
The first projection function TT^: {0} —> A is clearly continuous. For a mor-
phism f:(j) -^ ip over A we get a function {/}'{(!>} -> {V^} by {a,x) \-^ 
(«5 fa{^))- This {/} is continuous function: for a directed collection (a,, Xi)i^j 
in {0}, the join is (a, x) where a = Vie/ ^*' ^^^ ^ ~ Vie/ ^(^« ^ ^)^(^t) ^i^<^ 
so we have 
{f}{a,x) 
= (a,Mx)) 
y (a,V,g/M- < ar/a.(a;,)) = V,e/i/}(«''^') 
where the equation (*) holds because 
fa{x) = \J(i>{aj < aYfa^(j){aj < ay{x) 
jei 
iei 
= \j<t>{0'i < aYfaM^i 
< ciy(f)(ai < ay{xi) 
iei 
= V(/>(ai < 
ayfa,(xi). 
where the two joins over / can be combined into a single join, because they 
are directed joins. 
The resulting functor CFam(Dcpo)^ -^ Dcpo/A between fibres is ob-
viously faithful. And it is full because if we have a continuous function 
u: {<{)} -> {t/j} with TT^ o u = TT^, then there is a morphism f:<f)—^jp over 
A with fa{x) = 7T'u{a,x). Then obviously {/} = u. We leave it to the reader 
to verify that this collection / = [fa)aeA is indeed a morphism (j) ^ tp over 
A. 
• 
CFam(Dcpo) 
10.6.3. Lemma. The comprehension category with unit 
i 
admits 
Dcpo 
strong coproducts. For a family (/>: A -^ Dcpo^^ over A, and another family 
ip: {(f)} —^ Dcpo^^ over {(f)}, we get a coproduct Yl^W-^ ~^ Dcpo^^ by 
a ^ {V^(a, - ) } - {{x, y)\x 
e 0(a) and y G i){a, x)}, 
ordered by 
(^i^yi) < (^2,2/2) <=> xi <X2 andip{{a,xi) 
<(a,X2)y{yi) 
<y2' 
Proof. For ai < 02 in ^ we have to define a pair of continuous functions 
Li4v)(«i < a^r 

Section 10.6: Domain theoretic models of type dependency 
641 
They are given by 
11^^(01 <a2r(x,y) 
= {Hai < a2Y(x), V(ai,</'(ai < a2y(x)) < 
(a2,x)Y(y)) 
LJ^(V')(ai<a2r(x,2/) 
= {<t>{ax < a2)P(x), V((ai,^) < (a2,0(ai < 
a2r(x))P(y)). 
By some lengthy computations one verifies that these functions form an 
embedding-projection pair and make a i-> LI^(V^)(a) a continuous functor. 
For a continuous functor x-^ ^ Dcpo^^ over A, there is a bijective cor-
respondence between vertical morphisms: 
UM) 
^ X over A 
xH 
^ 7r*(x) 
over {(/>} 
which is described as follows. Starting with a family / = {fa)aeA over A one 
gets a family / over {<;/>} by 
And in the reverse direction, starting with g — [9{a,x)){a,x)e{(l>] one takes 
9a{^^y) = 9{a,x){y)' 
These operations produce appropriate new families and are obviously each 
others inverses. It remains to show that these coproducts are strong. But it is 
not hard to see that the canonical map 
W 
^ {Ll0(V^)} 
given by 
((a, x), y) ^ (a, (x, y)) 
is an (order) isomorphism. 
D 
CFam(Dcpo) 
10.6.4. Lemma. The comprehension category 
i 
admits products: 
for families <j): A -^ Dcpo^^ and ip: {(f)} —> Dcpo^^^ there is a product family 
n^(V^):^^DcpoEP ^y 
a H-^ {h: (j){a) —)• UA'tp){ci) \ h is continuous and TT o h — id}, 
ordered pointwise. 
Proof. The action of the product n<^(V^) on a morphism a\ < 02 in ^4 is 

642 
Chapter 10: First order dependent type theory 
given by the following embedding-projection pair. 
n0W(ai<a2rw 
= %ze 0(a2).(z, V^((ai,(^(ai < asFW) < {a2,z)Y{ir'h{cl>{ai < a2K(z)))) 
= %xe (f>{ai).{x,i;{{ai,x) 
< {a2,(f>{^i < a2)Mx)K(7r'fc(0(ai < 
a2Y{x)))). 
This functor Hd!)!"") '^ right adjoint to the weakening functor 7rJ,(—), by the 
adjoint correspondence 
X 
^ YlcpW 
over A 
7r^(^) ——^ 'tp over {0} 
described as follows. Given a family / = {fa) over A, define fta,x){y) — 
^^fa{y){x) e i)[a, x). And conversely, given a family g = {9(a,x)) over {</>} one 
puts g^{y) =%x.{x,g(^a,x){y)) eUcf>W^^'>- 
° 
By collecting the above lemmas we get the main result. 
CFam(Dcpo) 
10.6.5. Theorem. The 
fibration 
i 
of "dcpos continuously indexed 
Dcpo 
by dcpos" is a closed comprehension category. 
• 
Closures indexed by closures 
In the remainder of this section we sketch how the so-called closure model 
from [302, 15] fits in a categorical framework of closed comprehension cate-
gories. Let (Pu;,C) be the complete lattice of subsets of the set of natural 
numbers LJ (= N ) . The set of (Scott-)continuous functions [Pa; —> PUJ] comes 
equipped with continuous maps F: PLJ —^ [Pu —> PUJ] and G: [PLJ -^ PUJ] -> 
PUJ for application and abstraction, satisfying F o G = id and G o F > id. 
This makes it a (non-extensional, additive) model of the untyped A-calculus, 
see [13]. As usual, we write x -yfor F{x){y) and \x ... for G{%x ...). Further, 
we use that there is a continuous surjective pairing [—,—]: PUJ X PUJ —)• PUJ 
with continuous projections TT, TT'. 
A closure is an element a G PUJ satisfying a o a = a > I, where a o a = 
Xx.a- {a- x) and I = Xx.x. Closures form a category Clos by the stipulating 
that a morphism u:a —^ b between closures is an element u G PUJ satisfying 
b o u o a = u {or equivalently, b o u = u and u o a = u). One easily verifies that 
Clos is a Cartesian closed category (see [302]), with terminal object 1 = Xx.uj, 
product a X b = Xx. [a • TTX, b • TT'X] and exponent a => b = Ax. b o x o a. For 

Section 10.6: Domain theoretic models of type dependency 
643 
a G Clos we write Im(a) — {a-x \x ^ P^}] then Im(a) — {x Q. Puj \ a-x = x} 
and Im(a => 6) = Clos(a, 6). 
A crucial result is the existence of a closure Q with Im(Q) = Obj Clos, so 
that a G PLO is a closure if and only iiQ-a 
= a (see [15, Theorem 1.12], where 
this result is attributed to Martin-L6f, Hancock and D. Scott independently). 
Fam(Clos) 
This gives us the possibility to define a split fibration 
I 
of 'closure-
indexed closures'. Objects of the total category Fam(Clos) are arrows X: a -> 
Q. in Clos. An arrow {X: a -> Q) —> (y: 6 —> fi) is a pair {u, a) with 
w.a-^h 
a morphism in the base category Clos and a G Pu) is an 'a-indexed family of 
morphisms'. The latter means that a o a — a and a - z: X - z -^ Y • [u • z) is 
a morphism in Clos (for each z G Pu)). Here we use that X • z is an element 
of Im(fi) = Obj Clos. The functor Fam(Clos) -> Clos sending {X\a -^ Q) 
to a is then a split fibration. It has a fibred terminal object via a functor 
1: Clos -^ Fam(Clos) by 
a i-> \\xy.(jj\ 
a ^ 
Q). 
A right adjoint { —}: Fam(Clos) —>• Clos to 1 is described by 
(X: a - ^ Q ) 1-^ \z. 
[a • TTZ, X • T^Z - TT'Z]. 
It is not hard to check that we get a fibration with full comprehension. It 
further has products and strong coproducts (along the induced projections 
-Kx'- {X] —>• a): for an object X:a -^Q. over a G Clos and an object Y: {X] -^ 
Q over {X} one defines coproduct and product objects U x ( ^ ) ' I l x l ^ ) ' ^ ^ 
Q over a by 
Wxi^) 
= )^ZV.[X 'Z'-KV.Y 
-[a-Z^X 
-Z^TTVI-I^'v] 
]\x{y) 
= Xzvw.Y 
-[a-z^X 
'Z'w]'{v'{X 
'Z 
-w)). 
This yields a (split) closed comprehension category. 
Exercises 
10.6.1. 
(i) 
For continuous functors (t>,tp: A ^ Dcpo 
, show that the product and 
exponent in the fibre over A, which are by Proposition 10.5.4 described 
by the formulas 
<t>x^ = LJ«('r;(t/')) 
and 
4> ^ ^ = n^('^;(^)) 
are point wise the Cartesian product and exponent of Dcpo. 
(ii) Check that Beck-CheVcJley holds for the dependent coproducts J7^(^) 
and products ]J^(t/') in Lemmas 10.6.3 cind 10.6.4. 
10.6.2. A Scott-domain is a bounded complete algebraic dcpo. Write SD <—> Dcpo 
for the full subcategory of Scott-domains (and Scott-continuous functions). 

644 
Chapter 10: First order dependent type theory 
For a Scott-domain A a functor 0: ^4 -> SD 
will be called continuous if 
it is continuous as a family of dcpos, i.e. if it satisfies the condition men-
tioned in the beginning of this section. Such a functor <l> may be seen as 
a continuous family of Scott-domains, indexed by a Scott-domain. Prove 
that the CFam( —) fibration for Scott-domains also yields a closed com-
prehension category, essentially by checking that for a continuous family 
(t>:A^ SD^P 
(i) the Grothendieck completion {(f)} is again a Scott-domain; 
(ii) the dcpo n<i.(^)(^) ^^ Lemma 10.6.4 is also a Scott-domain, for 
xp: {</>} -> SD 
a continuous family over ^. 
Fam(Clos) 
10.6.3. (i) Show that the 
fibration 
i 
of closure-indexed-closures has a 
split generic object (and thus that it is a small fibration). 
(ii) Explain that, as a result of (i), one has a model in which the axiom 
h Type: Type holds. 
[A dependent calculus with such a type of all types is inconsistent in the 
sense that every type is inhabited. This follows from Girard's paradox, 
see Exercise 11.5.3.] 
(iii) Show that it is a Aa;-fibration. (As such, it is described in [307].) 
(iv) Consider the category Clos with objects 
17o = Q 
Qi — Xx. [Q • (TTIX), Q ' (7r2a;), Q • (7r2a7) o TTSX O Q • (nix)] 
where we have used [-,-,-] for the 3-tuple with projections 7ri,7r2,7r3. 
Show that we get an internal category (Qi —^ Qo) in Clos and that 
its externaJisation is the above fibration of closure-indexed-closures. 

Chapter 11 
Higher order dependent type theory 
In this final chapter several lines come together: the various logics and type 
theories that we have so far studied in isolation, are now combined into sev-
eral powerful higher order dependent type theories. These type theories will be 
introduced as suitable combinations of earlier type theories. And correspond-
ingly, their categorical semantics will be described via suitable combinations 
of structures—notably fibrations and comprehension categories—that we used 
earlier for the component type theories. We focus mostly on these modular as-
pects of higher order dependent type theory, and, accordingly, we leave many 
of the details of the syntax implicit. On the categorical side, the double role 
of comprehension categories—on the one hand as domains of quantification, 
see Section 9.3, and on the other as models of dependent type theory, see 
Section 10.4—is crucial in achieving this modularity. 
We will consider three systems of higher order dependent type theory. 
• Higher order predicate logic over dependent 
type theory; often, it will be 
called dependent predicate logic, with DPL as abbreviation. 
• Polymorphic dependent type theory (PDTT); this may be seen as a 
propositions-as-types extension of DPL. 
• Full higher order dependent type theory (FhoDTT), which, in a more drastic 
manner, is also a propositions-as-types extension of DPL. 
We start this chapter with higher order dependent predicate logic (DPL). 
It may be contrasted with ordinary or simple (first or higher order) predicate 
logic, which is predicate logic over simple type theory (abbreviated as SPL, 
see Chapter 4), and also with polymorphic predicate logic PPL (discussed in 
645 

646 
Chapter 11: Higher order dependent type theory 
Section 8.6). Characteristic for DPL is that for a type cr, 
( predicates <>p[x)\ Prop 
term variables x\ a may occur both in < 
and in 
[ types r(a:): Type. 
We will consider the higher order version of DPL, with the axiom Prop: Type, 
but of course, one may also choose to use a first order logic over dependent type 
theory. This dependent predicate logic is quite natural and expressive, as will 
be argued below. It forms the basis for the proof assistant PVS see [242, 241]. 
The other two systems PDTT and FhoDTT of higher order dependent type 
theory are obtained by extending this logic over dependent type theory to a 
type theory over dependent type theory, in the propositions-as-types manner, 
by introducing explicit proof-objects (or terms) in type theory for derivations 
in logic. Instead of 'propositions over types' as in logic we shall talk about 
'types over kinds' in type theory. In this situation we assume (like in the logic) 
that for a kind ^4: Kind, we may have 
( types cr(a): Type 
variables a: A occurring in < 
and in 
I kinds J5(a): Kind, 
so that we have both types and kinds depending on kinds. We then consider 
two possible extensions: one may additionally have 
(1) types depending on types: variables x:a, for cr:Type, occurring in types 
r(x):Type; 
(2) kinds depending on types: variables x:a^ for (7:Type, occurring in kinds 
A[x):K\n6. 
In the first case one gets what we call polymorphic dependent type 
theory (PDTT). Its basis is formed by sequents of kinds A and types a of 
the form 
ai\Ai, ...,an'.An 
\ iCi:o-i,.. .,Xm''(^m l~ cr^+i:Type 
like in polymorphic type theory, with the addition that both kind and type 
contexts contain dependent kinds and types: kinds A,+i may contain vari-
ables a i , . . . , af in kinds and types (TJ^\ may contain variables a i , . . . , a„ 
ranging over kinds (as in polymorphic 'simple' type theory), and also vari-
ables a?i,..., ajj ranging over types. Hence, polymorphic dependent type the-
ory adds both "kind dependency" and "type dependency" to polymorphic 
simple type theory. 
In the second case with kinds additionally depending on types one looses 
the possibility to separate kind and type contexts, so that one gets sequents 

Section 11.1: Higher order dependent type theory 
647 
of the form 
xi\Ci,.. 
.,Xn'-Cn 
H D: Kind/Type 
where Ci: Kind/Type, i.e. where Ci is either a type or a kind. This yields 
systems like the Calculus of Constructions of Coquand and Huet [58]. Type 
theories like in (1), which capture dependent type theory over dependent 
kind theory have been proposed as HML by Moggi [230] and as the theory of 
predicates by Pavlovic [252, 253]. Moggi precludes kinds depending on types in 
HML, because he wishes to use HML as a rudimentary programming language 
with a compile-time part of kinds which is independent of a run-time part 
of types. The motivation of Pavlovic comes from logic: he thinks of types as 
propositions and of kinds as sets and does not want sets to depend on proofs 
[i.e. on inhabitants of propositions). Both arguments make good sense and 
form the basis for sensible type theories. 
In this chapter we will be increasingly blurring the distinction between type 
theory and category theory, assuming that the reader is sufficiently prepared 
by the previous chapters. Also, we shall be rather sketchy in describing par-
ticular type theories, mainly because we see them as modular composites of 
other systems that we described earlier in greater detail. Here we mostly put 
emphasis on the way in which these components are put together. The "de-
pendency relation" between syntactic categories (like Type and Kind) will be 
of crucial importance in such combinations, see the beginning of Section 11.5. 
This chapter starts with an introduction to (the syntax of) dependent predi-
cate logic. This syntactical material is immediately organised in a term model. 
It suggests the underlying categorical structure, which will be elaborated in 
Section 11.2. The dependent version of polymorphic type theory is studied 
in Section 11.3. It prompts a detailed investigation of both syntactical and 
categorical aspects of different sum types and equality types. We identify 
weak, strong and very strong versions of these sum and equality types, by 
distinguishing between certain dependencies in the elimination rules. These 
dependencies in type theory are related to indexing in category theory. They 
are described systematically in the beginning of Section 11.5. The remainder 
of this section is devoted to the syntax of full higher order dependent type 
theory (FhoDTT). In the subsequent Section 11.6 we describe various models 
of this FhoDTT, including different PER-models. And the final Section 11.7 
will elaborate on the special model consisting of PERs in the effective topos 
EfF. It focuses on the (weak) completeness of the fibrations of families of 
PERs and of u;-sets over EfF. The "stack completions" of these fibrations will 
be identified as complete fibrations (of separated families and of separated 
families orthogonal to V2 G EfF respectively). 

648 
Chapter 11: Higher order dependent type theory 
11.1 Dependent predicate logic 
In this section we will first introduce (higher order) predicate logic over de-
pendent type theory, or dependent predicate logic (DPL), for short, together 
with some motivating examples (mostly involving subset and quotient types). 
Then we sketch the syntax for such a logic. We put special emphasis on the 
organisation of (type and proposition) contexts in this logic, since this is what 
determines the underlying fibred structure. Towards the end of this section we 
shall describe a term model of DPL. Its categorical structure will be further 
investigated in the next section. 
As already mentioned in the introduction to this chapter, the key ingredient 
of dependent predicate logic is that term variables x:a in a: Type may occur 
both in propositions (p{x): Prop (as in ordinary, or simple, predicate logic SPL), 
and in types r(a:):Type (as in dependent type theory DTT). This means that 
we have formation sequents in DPL of the form: 
xi'.CTi,.. ..Xn'.cTn H Ti Type 
and 
xi'.ai,... 
,Xn'.(Tn I-V?: Prop 
in which the term variables x: a may occur both in r and in (p. But there are 
also entailment sequents of the form: 
Xi:(Ti,...,Xn:(Tn 
\ (fi, 
. , . , (frn 
^ i^ 
expressing that the proposition ip follows from the premises (fi,.. -j^Pm, in 
the (dependent) type context of term variables x: a. As before, we call (p 
the proposition context. In this sequent it is understood the (fi and 'tp are 
propositions in context x: a. 
In the higher order version of dependent predicate logic we shall be using 
an axiom h Prop: Type. As a result, we can also have proposition variables 
a: Prop occurring in types and propositions—and we may also (impredica-
tively) quantify over these, like in 3a: Prop. (p{a) and Va: Prop. (p{a). 
One of the key advantages of dependent (over simple) predicate logic is that 
it allows us to make full use of subset types and quotient types—introduced 
in simple predicate logic in the earlier sections 4.6 and 4.7. For example, in 
forming (dependent!) types 
p: N, n: N \- n < p: Prop 
def 
p:N h Nat(p) = {n: N | n < p}:Type 
of natural numbers below p. Similarly, with quotients one can form the de-
pendent type (or group) Z/pZ of integers modulo p, in: 
p: Z,x:Z,y:Z 
\- x ^p y = 3z: Z.{x - y) — z -p: Prop 
p:Z \-Z/pZ 
= 
Z/^p'.Jype 

Section 11.1: Dependent predicate logic 
649 
What happens here is that subset types {n: N | n < p] ^> N and quotient 
types Z -^ ~^lv^ ^r^ formed which depend on a term variable p. This is 
because p is occurring free in the propositions which give rise to these subsets 
and quotients. The natural setting for these features is a logic over dependent 
types. 
In such a logic one also has convenient ways of expressing results like 
p\ N , / : Nat(p) -> Nat(p) | injective(/) h surjective(/) 
saying (in essence) that every injective endofunction on a finite set is surjec-
tive. A similar example is the following standard result in topology. 
n\ N, a: P(R'^) | compact(a) h closed(a) A bounded(a). 
Another argument supporting the naturality of this dependent predicate 
logic is that it actually is an expressive version of the internal language of 
a topos. There are various ways to describe such a language. In most topos 
theoretic texts it is presented as a higher order predicate logic over simple type 
theory (see e.g, [186]). Phoa [262] describes this internal language explicitly 
as a logic over dependent 
type theory. Of course, this extended language can 
be translated back into the logic over simple type theory, but its advantage 
lies in its additional flexibility and expressiveness (see the examples above). 
Such dependent predicate logic also occurs in [165] and in [242, 241]. 
The basis for the syntax of DPL is formed by the rules for dependent type 
theory in Section 10.1. So we shall use dependent product types 
Ux.a.r, 
strong dependent sum types Ex: a. r and a unit type 1. We exclude the equality 
type Eqa(iP, x')^ because equality will be dealt with at the propositional level. 
There is a special type Prop: Type of propositions, such that propositions occur 
as inhabitants of Prop. This gives us higher order logic. As already mentioned, 
in DPL there are entailment sequents of the following form. 
dependent type 
context 
Xi\ai,...,Xn'-crn 
I ^ i , . . . , V ^ m ^- '0 
ordinary 
proposition context 
We shall often abbreviate such type contexts as F = (xi: CTI, . . . , Xn'. cr„) and 
proposition contexts as 0 = [<^\,.. ..(prn)- The logical rules for dependent 
predicate logic (DPL) have the same form as for simple predicate logic (SPL) 
in Figure 4.1 (on page 225), except that the type contexts F are to be un-
derstood as contexts in dependent type theory. For example, for the universal 

650 
Chapter 11: Higher order dependent type theory 
quantifier V we have the formation rule 
T,x:a 
h (p: Prop 
r h ^x:a.(f: Prop 
with introduction and elimination rules 
T,x:a\e\-(p 
. 
T\-M:a 
T | 0 h Vx: (T. v? 
{x not in 0) 
T\Q 
[-"^xia.ip 
r | 0 
h(p[M/x] 
So the additional type dependency in DPL has no influence on the form of 
the rules: we can use the same logical rules in simple and dependent predicate 
logic. But notice that in DPL we cannot form 
r, x: cr, A h (p: Prop 
r, A h Wx:cr.(p: Prop 
unless X does not occur free in A: then we can exchange x: a and A (according 
to the exchange rule in dependent type theory, so that the earlier mentioned 
formation rule can be used). This complication is due to the fact that in 
dependent type theory the order of the variable declarations in a type context 
is important—whereas in simple type theory it is not. 
As already mentioned, the axiom h Prop: Type provides us with higher order 
logic in which one can quantify over propositions and over predicates, like in 
the (closed) propositions 
Va: Prop. a D a 
and 
\/a: Prop.^p.a—^ 
Prop.3x:a.px. 
And like in higher order predicate logic over simple type theory, there is an 
"extensionality of entailment" rule: 
r h P, Q: (7 -> Prop 
T,X:(T\ 0, Px \-Qx 
T,X:(T\ 0, Qx h Px 
r I 0 h P -,_Prop Q 
The main novelty in dependent predicate logic is that subset and quotient 
types can be exploited in full generality. This makes DPL (instead of SPL) 
the natural logic for these type constructors. They now have formation rules 
r, a?: cr h (p{x): Prop 
F, x: c^y.a h R[x^ y): Prop 
r \- {x:a\ <y9(a?)}:Type 
T h a/R:Type 
in which we can have a proper type context F—which was required to be 
empty in Section 4.6 in order to stay within simple type theory. The associated 
introduction and elimination rules are formally as in Section 4.6, but one 
should read the type contexts as containing dependent types. 
As an example, for an integer p: Z we shall describe the quotient group 
Z/pZ of integers modulo p in some detail. Here we assume that Z is the ring 

Section 11.1: Dependent predicate logic 
651 
of integers with function symbols (0, +, —, 1, •) for addition and multiplication, 
satisfying the usual equations. 
One forms the quotient Z/pZ from the (equivalence) relation ^p on Z defined 
as 
p\ Z, x,y:Z \- X ^p y = 3z: Z.{x - y) =z z -p: Prop. 
So that we can form the dependent type 
p:Z H Z/pZ = Z/~p:Type. 
It comes equipped with the canonical map 
p:Z,x:Z 
(- [x]p:Z/pZ. 
Now we can put 
p:Z\-Op 
=' [0]p:Z/pZ. 
for a (new) neutral element. Inverse —p and addition -\-p operations on Z/pZ 
can be defined via representatives: 
p: Z, a: Z/pZ \- —pa = pick x from a in [—x]: Z/pZ 
def 
p: Z, a, b: Z/pZ \- a-\-p b — pick x, y from a, 6 in [x + y] : Z/pZ. 
In this way the type Z/pZ of integers modulo p becomes an Abelian group. 
In the remainder of this section we show how the context structure of depen-
dent predicate logic gives rise to a term model constellation of (split) fibred 
categories 
F 
T 
^ C^ 
c '°'^ 
where 
• C is the category of (dependent) type contexts F, as introduced in Sec-
tion 10.3. 
• T is the category of dependent-types-in-context F h cr:Type, fibred over 
C via (F h criType) i-)- F. This gives a closed comprehension category 
T -> C"^ , see Example 10.5.6. 
• F is the category of propositions-in-dependent-type-contexts F h ^: Prop. 
A morphism (F h ip: Prop) ^ (A h ^: Prop) in this category consists of a 
context morphism M: F ^ A in C for which one can derive T \ (p \- 'ip{M) 
in DPL. This category P is then fibred over C via (F h (f: Prop) ^ F. 
We see that since both propositions and types depend on {i.e. are indexed 
f 
T 
by) types, we get two fibrations ^ and i of categories of propositions and 

652 
Chapter 11: Higher order dependent type theory 
of types over contexts of types. These fibrations are related in the following 
way. 
r 
_ 
(1) The fibration i of propositions has products and coproducts with re-
spect to the comprehension category T —>• C~^ of types (see Section 9.3 for 
what this means precisely). Notice that this involves quantification along 
dependent projections 'K:{V,X:(T) 
-> F. But the pattern is the same as in 
simple predicate logic, where the fibration of propositions admits quantifi-
cation with respect to the simple comprehension category of types (with 
Cartesian projections only). 
r 
(2) The fibration 4; of propositions has a (split) generic object (a: Prop h 
a: Prop) G IP over the singleton context (a: Prop) E C And the latter is the 
domain of the projection (a: Prop) —> () in C induced by the closed type 
(h Prop: Type) G T. 
We shall elaborate on the categorical aspects of quantification (V and 3) of 
propositions over dependent types in DPL, described via quantification in 
terms of comprehension categories (as mentioned in (1)). For each depen-
dent type (F h criType) G T over F G C we have a dependent projec-
tion 'K:{T,x:a) -> F. This map in the base category C induces a weaken-
ing functor 7r*:Tr —> ^{v,x:a) acting on types, and also a weakening functor 
TT*: Pr ^ IP(r,a::<7) actiug on propositions. The latter will be of interest here; it 
maps 
( F h <^: Prop) ^ ( F , x:a V- if: Prop) 
by adding a dummy variable x: cr. In DPL (like in SPL) the rules for existential 
3x: cr. (—) and universal Va:: cr. (—) quantification can be reformulated as 'mate' 
rules (see Lemma 4.1.8): 
F I (^ h Vx: a.il) 
F I 3x: a.ip h (f 
T,x:a\(p\-ip 
T,x:(T \ ip \-(f 
where (p below the lines is really 7r*{(p). This shows that we have adjunctions 
3x:(T.(-)H7r* HVx:(7.(-) 
The Beck-Chevalley condition holds because substitution [L/—] of terms L in 
propositions Vx: cr. ^ and Sx'.a.tp commutes appropriately with V and 3, as in 
r 
Section 4.1. Thus the fibration i has products and coproducts with respect 
to the comprehension category T -^ C"*". 
The structure of these two fibrations of types and of propositions over con-
texts will be studied more systematically in the next section. 

Section 11.2: Dependent predicate logic, categorically 
653 
Exercises 
11.1.1. 
(i) 
Consider the quotient group Z/pZ described above, and prove that 
there are conversions: 
p: Z, a: Z/pZ h a = pick x from a\v\[x-\- p\p : Z/pZ 
p: Z, a: Z/pZ h a = pick x from a in [a: — p]p : Z/pZ. 
(ii) And derive: 
p: Z, a: Z/pZ | T h 3a;: Z. a = [a;]p. 
11.1.2. Describe equality propositions F, a:: (T, a;': <T h X =cr :r': Prop, for T \- cr: Type 
in DPL (with rules as in SPL) as equality for the (term model) fibration 
^ 
. . 
. 
i of propositions with respect to the comprehension category T —)• C~^ of 
types. 
11.2 Dependent predicate logic^ 
categorically 
In this section we describe a fibred categorical structure capturing dependent 
predicate logic, essentially by suitably combining the components of this logic. 
We then proceed to describe dependent subset types and quotient types in 
this setting. 
We have seen in Chapters 4 and 10 that 
(1) Predicate logic over simple type theory (SPL) is described by a preorder 
fibration 
D 
| . 
IB 
where IB is the category of type contexts (or just types, considered as sin-
gleton contexts, if we use finite products of types). 
(2) Dependent type theory (DTT) is captured by a (closed) comprehension 
category 
V 
E 
^ B - ^ 
where B is the category of (dependent) type contexts. 
Combining these we get a structure for dependent predicate logic (DPL). 

654 
Chapter 11: Higher order dependent type theory 
It looks as follows, 
V 
D 
E 
^B"^ 
p 
where 
\^ is a preorder fibration and P : E -^ B~^ is a comprehension 
category. The type formers E , n , l and proposition formers 3,V, = and 
T,A,±,V, D of DPL are then incorporated by imposing the following ad-
ditional conditions on this structure: 
(1) 'P is a closed comprehension category; 
(2) g is a fibred bicartesian closed preorder fibration. 
(3) q has P-products V, P-coproducts 3 and P-equality Eq. 
For the higher order axiom h Prop: Type of DPL we further impose: 
(4) for higher order: there is a closed type fi G Ei in the fibre over the 
terminal object 1 G B, such that the fibration q of propositions has a generic 
object T G D above {Q} = dom('PQ). 
11.2.1. Definition. We shall call a structure i with E -^ B"^ as above, sat-
isfying requirements (1) - (4) a DPL-structure, with 'DPL' for 'dependent 
predicate logic'. 
IP 
It may be clear that the term model of DPL consisting of a fibration i and 
a comprehension category T —>• C^ as discussed at the end of the previous 
section, is an instance of such a DPL-structure. 
Our main examples of higher order fibrations: 
Fam(A) 
Sub(B) 
UFam(PN) 
i 
for A a frame, 
4- 
for B a topos, 
i 
Sets 
B 
Sets 
are in fact DPL-structures of the form, 
Fam(^) 
Fam(Sets) - ^ Sets"' 
Sub(B) 
^(B) - ^ B"^ 
UFam(PN) 
Fam(Sets) - = ^ Sets 
where we have chosen to present the comprehension categories in split form 
:F(B) 
(with 
i 
the split presentation of the codomain fibration of a topos B, see 
B 

Section 
11.2: Dependent 
predicate 
logic, categorically 
655 
Example 10.5.9). These examples all arise (essentially) from the second point 
in the following result. 
11.2.2. Proposition. Let i he a higher order fibration. 
B 
(i) It forms part of a "simple" DPL-structure 
(B; 
1 ^^cod 
1 
(ii) // the base category M is a locally Cartesian closed category and the in-
duced adjoints ]J^ -\ u* -^ Yiu ^^ ^ (^^^ Example J^.S.l) satisfy Beck-Chevalley, 
then we have a DPL-structure 
^M-" 
Proof, (i) Since the projections and diagonals of the simple comprehension 
category s(]B) -^ B"^ are the Cartesian projections and diagonals, the higher 
order fibration has by definition quantification with respect to this compre-
hension category. The generic object condition holds, since the fibre over 1 E B 
of the simple fibration is isomorphic to B. 
. 
p 
(ii) Validity of the Beck-Chevalley condition ensures that the fibration i 
IB 
has products and coproducts with respect to the identity comprehension cat-
egory B-" -> B"' (see also Example 9.3.6). 
D 
This result tells us how to obtain DPL-structures from higher order fibra-
tions. There is also a way to extract a higher order fibration from a DPL-struc-
ture, see Exercise 11.2.4 below. 
In the remainder of this section we define what it means for a DPL-structure 
to admit (dependent) subset and quotient types. These definitions are impor-
tant in the light of our claim that DPL is the natural logic for subset and 
quotient types, where these type constructors can be used in full generality 
(see the example of the quotient group Z/pZ of integers modulo p in the pre-
vious section). As examples of DPL-structures with dependent subset and 
quotient types we shall only discuss term models and topos models. 
11.2.3. Definition. Consider a DPL-structure 
V 
D 
E 
^ B-^ 
^ ^ 
I ^ c o d 

656 
Chapter 11: Higher order dependent type theory 
as introduced above. Then we can form the diagram 
Fam'p(D) 
^ D 
Fam'p(g) 
T 
E 
{-} ^ d o m o - p 
where Fam'p(g) is defined as the composite Fam'p(D) -^ E ^ B. The (fibred) 
terminal object functor T:E —>• Fam7>(D) is induced by the terminal object 
functor TiB -^ D to g, namely as X H^ (X, T{X}). In this situation, we say 
the DPL-structure has (dependent) subset types if there is a fibred right 
adjoint { —} to T in the situation: 
{-} 
E 
T 
Fam'p(D) 
Fam7>(g) 
Such an adjoint induces a fibred projection functor Fam7>(D) —>• V(E) over 
E, like in Definition 4.6.1^where V(E) ^^ E"*" is the full subcategory of 
vertical maps. We shall say that we have full dependent subset types if this 
functor is full and faithful. 
(In the diagrams above we use the "Fam" notation because of the analogy 
with the construction in Exercise 1.9.11.) 
The above right adjoint {—} has to be a fibred one over p, because the type 
context r remains the same in the formation rule for dependent subset types: 
F, ar: cr h (p: Prop 
F h {x:cr| <^}:Type 
The sequent above the line yields an object (o-, (/?) G E XiD = Fam'p(D) over 
F G 1. And also {x\(T\(p] e^ has to live above F G B. 
r 
We briefly describe this fibred subset adjunction in the term model ^ with 
V:T -^ CT^ from the previous section. Notice that the auxiliary category 
Fam'p(P)has: 
objects 
pairs consisting of a dependent type F h cr: Type and a 
predicate V^x.a h (p: Prop on a. 

Section 11.2: Dependent predicate logic, categorically 
657 
morphisms 
from (F h o": Type, F, x: cr h ^: Prop) to (A h r:Type, 
A,y:r h V-Pi'op) consist of a morphism M:F —>• A of 
contexts together with a term F, x: cr h A'': r such that one 
can derive 
The terminal object functor T —> Famp(P) is then given by 
( F h (T: Type) ^ 
( F , X: CT h T : Prop). 
A right adjoint to this functor T in the fibre over F involves a bijective corre-
spondence between terms M and N in: 
( F , x:a ^T: Prop) 
^ ( F , yir 
h ip: Prop) 
(F h a: Type) -
^ 
( F h {y: r | ^ } : Type) 
That is, in: 
T,x:a\-M:T 
with 
F, x: cr | T h ^^[M/t/] 
T,x:a 
h 
N:{y:T\ip} 
The correspondence is given by 
M h-> i(M) 
TV K^ o(7V), 
using the 'i' for 4n' and 'o' for 'out' as in the introduction and elimination 
rules for subset types in simple predicate logic (in Section 4.6). 
11.2.4. Proposition. For a topos B, the associated DPL-structure 
Sub(B) 
W^ 
cod 
always has full dependent subset types. (For convenience we state this result 
for the the non-split presentation of this model.) 

658 
Chapter 11: Higher order dependent type theory 
Proof. Consider the situation 
SubFam(B) 
J 
T 
B^ 
cod 
-^ Su 
dom 
The category SubFam(B) thus has subobjects Y ^^ X —> I of families 
X —> I as objects. The terminal object functor W^ -^ SubFam(B) maps 
(z—^ i) 
\-^{z>^z—^/). 
And it has a right adjoint over /, by composition: 
/ i d 
i^ ^ 
if, 9) 
{y ^ X - ^ l ) 
since in a commuting diagram: 
. 
(pom 
. 
(y 
- / ) 
z -
id 
-^Y 
— ^ X 
I 
the map / is determined as composite mo g. 
The associated projection functor SubFam(B) —>• V(B~*') = W^~* is 
{y 
X 
') 
Y^^X 
\ 
/ 
I 
It is obviously full and faithful. 
D 
We turn to quotient types in DPL. Recall that for a comprehension category 
P: E -> B-^ we usually write {-}: E -> B for dom o ?>. Let us write here {{-}} 

Section 11.2: Dependent predicate logic, categorically 
659 
for cod o <J:E —> B, where S[X) is the diagonal map used in Definition 9.3.5 
to define equality. Thus {{ —}} maps an object X G E to 
{{X]] = 
{VX*{X)] 
J 
{X] 
vx 
{X] 
vx 
( 
pX 
Type theoretically, {{ —}} maps a dependent type T h (T:Type to the context 
(r, x: a, x': a) that extends F with two variables of type a. 
11.2.5. Definition. For a DPL-structure 
E 
/I 
cod 
consider the category of relations, obtained by change-of-base in: 
. 
RFam^(D) 
^ D 
RFam'p(^) 
Eq 
E 
{{-}}zz:C0d0(J 
where RFam'p(^) is the composite RFam'p(D) ^ E —)- B. The (fibred) equality 
object functor Eq:E -> RFamp(D) is induced by the equality Eq in q (with 
respect to V), namely as X h-> (X, Eq(l{X})). We say the DPL-structure has 
(dependent) quotient types if there is a fibred left adjoint Q to Eq in the 
situation: 
Q 
RFam7>(D) 
RFam'p(g) 
Eq 
E 
Such an adjoint induces a "canonical quotient map" functor RFam-p(D) —>• 
V(E) commuting with the domain functor dom: V(E) -^ E, as in Proposi-
tion 4.8.5. We shall say that we have full (or effective) dependent quotient 

660 
Chapter 11: Higher order dependent type theory 
types if this functor is full and faithful, when restricted to equivalence rela-
tions. 
p 
In the type theoretic example with i and V:T -^ C"*" as in the previous 
section, the category RFamp(P) has 
objects 
dependent types F h cr: Type together with a relation 
r, x: cr^ x': a h R[x^ x'): Prop on cr. 
morphisms 
from (F, x: cr, ar'rcr h R[x^x')'.Prop) 
to (A,2/:r, y':r h 
S{y,y'): Prop) consist of a morphism M:T —> A of con-
texts together with a term T,x:a 
h N:T such that one 
can derive 
F, x: a, x': a \ R(x, x') h S{M, N{x), 
N{x')). 
The equality functor T —> RFam'p(F) sends a type F h r: Type to the equality 
relation T,y:T,y':T 
\- y =7. y': Prop on r. Quotient types in dependent predi-
cate logic provide a left adjoint, since they induce a bijective correspondence 
(over F) between terms N and M in 
N 
(F, X: cr, x': a h R{x, x'): Prop) 
^ (F, y: T,y': r \- y =r y'- Prop) 
(F h ^/i^:Type) -
^ 
( F h riType) 
I.e. m 
Y,x\a 
\- N\T 
with 
F, x\ a, x'\ c \ R{x, x') h N(x) =r N{x') 
T,a:a/R 
h M:r 
This correspondence is given by 
N{x) H^ (pick X from a in N{x)) 
and 
M(a) H^ M[[a:]i?/a]. 
11.2.6. Proposition. Every topos—as a DPL-structure—has full dependent 
quotient types. 
Proof. Let B be our topos. Consider the relevant change-of-base situation 
^ Sub(IB) 
- RelFam(B) 
B-^ — 
cod 
{{-}} 

Section 11.2: Dependent predicate logic, categorically 
661 
where the functor {{ —}} maps a family X -^ / to the domain X Xj X of its 
kernel pair X Xj X :=t X. An object of RelFam(IB) is then a family (p: X -^ I 
together with a mono {ro,ri): R ^-^ X XjX 
with (p o VQ =^ (p o ri. The equality 
functor B"*" -^ RelFam(B) sends a family y -> / to the (vertical) diagonal 
Yy^YxjYonY-^I. 
For a relation {ro,ri):R 
>-^ X Xj X over p: X -^ I 
we can form the coequaliser c: X -^ X/R 
in 
so that we get a new family ^/R 
over /. There is then a bijective correspon-
dence (over / ) : 
[R^^^ 
X Xj X over X ^ 
I) 
^ ( y : 
i^ 
Y XjY 
over Y -^ 
l) 
{x/R 
/) 
^ 
(V 
— / ) 
since there is a map f:X-^Y 
satisfying ip o f — (p with g: R —• Y in the 
diagram below on the left, if and only if there is a map h: X/R 
^ y in the 
diagram on the right: 
R 
(^o,ri)I 
^ 
f xi f 
X XI X 
^ y 
xjY 
Y 
R 
ro 
n 
X -
^ 
X/R 
-
^ 
Y 
Fullness is left as an exercise below. 
D 
Exercises 
11.2.1. 
Prove that dependent subset projections are monos, and similarly that 
dependent quotient maps are epis—in analogy with Lemmas 4.6.2 (i) 
and 4.8.2 (ii). 
11.2.2. Consider DPL with dependent subset and quotient types. Give explicit 

662 
Chapter 11: Higher order dependent type theory 
descriptions in the term model 4- with V:T ^ C"*" of: 
(i) 
the subset functor Fam7:>(P) —^ T 
(ii) the quotient functor RFam7?(F) -)• T 
and show that these are fibred functors. 
11.2.3. 
(i) 
Prove that the assignment ((/?, R) i-)- ip/R defined in the proof of Propo-
sition 11.2.6 yields a fibred functor RelFam(B) -> B"^ . 
[Remember that puUback functors preserve colimits in a topos.] 
(ii) Prove fullness of dependent quotient types in this situation, 
(iii) Formulate a Frobenius property for dependent quotient types, and 
show that it holds automatically in topos models. Explain also why. 
P 
11.2.4. 
Consider a DPL-structure 
x^ with "PiE -^ IB"*" as described in the be-
B 
ginning of this section, and form by change-of-base: 
F 
{-} = dom o V 
where Ei is the fibre category over the terminal object 1 G B. 
(i) 
Show that 
-j- is a higher order fibration. 
(ii) Check that if the DPL-structure has dependent (full) subset / quotient 
F 
types, then J 
has simple (full) subset / quotient types. 
El 
11,3 Polymorphic 
dependent 
type 
theory 
Simple type theory is a 'propositions-as-types' extension of (constructive) 
propositional logic, via a Curry-Howard correspondence between inhabitation 
in type theory and derivability in logic, see Section 2.3. Models of propositional 
logic are Hey ting algebras, which are poset (or preorder) Cartesian closed cat-
egories (CCCs). And these CCCs are models of simple type theory. Similarly, 
there are certain fibred categories for simple (higher order) predicate logic 
(SPL), which are preorder versions of the fibred categories for polymorphic 
type theory (PTT), see Section 8.1. The additional structure in the fibres of 
polymorphic type theory corresponds to derivations in predicate logic. An ob-
vious next step is then to consider similar propositions-as-types extensions of 
dependent predicate logic (DPL), as described in the previous two sections. 
Then one looks for DPL-structures like in Definition 11.2.1, where the fibred 
preorders for propositional logic are replaced by proper fibre categories. The 
type theory obtained by extending dependent predicate logic in such a fashion 

Section 11.3: Polymorphic dependent type theory 
663 
will be called p o l y m o r p h i c d e p e n d e n t t y p e t h e o r y (PDTT). The system 
HML of [230] and the calculus/theory of predicates of [252, 253] are of this 
kind. In this section we sketch the syntax of this polymorphic dependent type 
theory, and investigate its categorical semantics. Of special interest will be 
the description of quantification and generic objects via change-of-base. 
Actually, in moving from DPL to D P T T we do not only replace a fibred 
preorder by a proper fibration, but by a comprehension category, so that we 
get a dependent 
type theory. 
The syntax of P D T T will be very much like the syntax of PTT: we replace 
the logic of Prop's over Type's in SPL and DPL by a type theory with Type's 
over Kind's in P T T and PDTT—so that one can really read propositions as 
types in comparing logics and type theories. An additional advantage of using 
different syntactic universes Type and Kind in type theory is that it makes it 
still possible at some later stages to add an extra logical level by adding a level 
of Prop's. Thus we will have kinds and types in this polymorphic dependent 
type theory, written as: 
h A: Kind 
and 
h (7:Type 
both in appropriate contexts. In P D T T it is allowed that variables a: A in-
habiting kinds occur both in kinds and in types, but variables x: a inhabiting 
types can only occur in types. (This restriction will disappear in Section 11.5.) 
As a result, in PDTT—like in PTT—one can (still) separate contexts, 
dependent kind 
context 
ai: Ai, ..., an: An \ Xjiai,.. 
.^Xm^cTm^ >" M:am+i 
dependent 
type context 
into a kind context followed by a type context. We often write these sequents 
as E] I r h M:a'm-\-i' Notice that in kind Ai the variables Ofi,.. . , a i _ i may 
occur. And in type aj one may have free variables a i , . . . , a^, ^ i , . . . , Xj_i. 
Since we have both "kind-dependency" and "type-dependency", there are 
two ways of extending contexts (via comprehension): 
E h 5 : Kind 
yields an extended kind context 
E,0: B 
E\T 
\- cr:Type 
yields an extended type context 
E | T,x:cr. 
And indeed, the corresponding categorical structures will involve two compre-
hension categories: one for kinds and one for types. 
(One can also consider type theories with such dependency only at the level 
of kinds, or only at the level of types, but we skip these intermediate versions. 

664 
Chapter 11: Higher order dependent type theory 
They are captured by the categorical structures below in which one of the 
comprehension categories is "simple", see towards the end of this section.) 
The features that we consider for these polymorphic dependent calculi are 
the following ones. 
(1) Dependent product Ila: A. B and strong sum Ea: A. B of kinds over kinds, 
plus a singleton kind h 1: Kind. 
(2) Dependent product Yix: a. r and strong sum Ex: cr. r of types over types, 
together with a singleton type h liType. 
(3) Polymorphic product Ha: A. a and sum Ea: A.a oi types over kinds. 
(4) A higher order axiom h Type: Kind together with the stipulation that the 
types in empty context: 
H I 0 h cr: Type 
are the terms 
'E \- cr: Type 
in this kind Type. 
Notice that the three products and sums 11, E in (1), (2) and (3) are all 
different; they describe quantification of kinds over kinds, of types over types, 
and of types over kinds. In syntax it is custom to write the same symbols D, E 
for these three cases, but categorically, these three forms of quantification are 
captured by three completely different adjunctions. 
The rules for dependent products and sums of kinds over kinds and of 
types over types in (1) and (2) are as in dependent type (or kind) theory, see 
Section 10.1. The rules for polymorphic quantification of types over kinds are 
as in polymorphic type theory (see Section 8.1), except that the kind and type 
contexts are now 'dependent'. But this does not affect the form of the rules. 
What it means to have strong polymorphic sums E a : A.a oi types over kinds 
will be explained in the next section. 
We turn to a categorical description of polymorphic dependent type the-
ory (PDTT). Recall from the previous section that we describe dependent 
predicate logic via a "DPL-structure" of the form 
V 
D 
E 
^B~^ 
^ ^ I ^cod 
We now wish to extend the (preorder) propositional part ^ to a full type 
D 
theory. Not just by allowing that 
i is non-preordered (so that we get a 
simple type theory), but we wish to allow dependent types here. Thus D must 

Section 11.3: Polymorphic dependent type theory 
665 
be replaced by a (closed) comprehension category D —> A~^ in a situation: 
Q 
D ^ 
^ A"^ 
jcod 
/I 
A 
E 
^ B"' 
(*) 
cod 
where the structure of D —> A"*" is vertical with respect to the fibration 
^ . 
Type theoretically, this functor r describes the category A of kind-and-type-
contexts H | F fibred over the category IB of kind contexts S. The objects 
of D are then the types-in-context S | F h cr: Type and the objects of E are 
the kinds-in-context H h ^: Kind. The two projection functors V and Q map 
a kind to its associated projection between kind contexts, and a type to its 
projection between type contexts. In detail: 
(Hf-A:Kind) ^ 
( ( H , a : A ) - ^ S ) 
(H IF her: Type) S , 
((H | F, :r: ^) ^ 
(E | F)). 
There are the following four non-trivial points to be clarified about a struc-
ture (*) as above. 
(1) What does it mean that Q:D ^ A"^ is a closed comprehension category 
"over r" (i.e. that it is vertical with respect to r)? 
(2) How does one capture polymorphic quantification X\OL\A.(T and Y^a.A.cT 
of types over kinds in such a situation? The problem is that one cannot 
simply require that q has quantification with respect to V (as described in 
Section 9.3), since q and V have different base categories. 
(3) What is the (categorical) role of the higher order axiom h Type: Kind? 
(4) What does it mean in such a situation that polymorphic sums are strong? 
An answer to this last question will be postponed until the next section— 
where it will be shown in Proposition 11.4.3 that the polymorphic sums in 
PDTT are automatically strong. 
We shall address the questions (l)-(3). 
(1) As mentioned above, from a type theoretic perspective, a Q-projection is 
a context projection (S | F,a^:cr) -> (S | F) for a type S | F h cr:Type. 
This projection is between different type contexts in the same kind con-
text H. That is, it may be seen as a vertical projection (F,x:(r) -> F in 
the fibre of A over the kind context S G B. What we thus mean by re-

666 
Chapter 11: Higher order dependent type theory 
quiring that Q:D -> A~^ is a comprehension category over r is that the 
Q-projections are r-vertical. Equivalently, Q:D ^ A"*" restricts to a func-
tor Q:D —> V(A)—where V(A) ^-> A"^ is the full subcategory of vertical 
maps. This comprehension category Q is then "closed over r" if it is closed 
in the usual sense (see Section 10.5). 
(In case Q is a comprehension category with unit, then this verticality of the 
Q-projections is equivalent to verticality of the counit of the comprehension 
adjunction (1 H { —}), see Exercise 11.3.1 below.) 
(2) For the polymorphic sum EaiA.cr and product Yia.A.o' of types over 
kinds one additionally requires the following. Since r: A -^ B is a fibration, 
one can transform the comprehension category 'PiE —)• IB^ with basis B 
by change-of-base (as in Lemma 9.3.10) into a lifted comprehension cat-
egory r*('P): A Xi E —> A~^ with basis A. Then we simply say that the 
P 
fibration 
j-^ of types has coproducts / products with respect to this lifted 
comprehension category r*{V). 
We check in some detail that this captures the rules of polymorphic sum 
and product in a term model: 
T 
^ TCr^ 
TC 
K 
^ KC^ 
IKC 
where IKC and TC are categories of kind-contexts 2 (and context mor-
phisms), and of kind-and-type-contexts S | F respectively. A morphism 
(S I F) -> (S' I F') in TC consists of two sequences of context morphisms 
M: S -> S' (in IKC) and N\V -^ F'(M) (in kind context S). Then K is the 
category of kinds-in-context H h A: Kind fibred over their contexts, with 
projection functor IK -^ KC"*" sending a kind-in-context S h A: Kind to 
the projection TT: (!E,a: A) -> S in IKC. And T is the category of types-in-
kind-and-type-context S | F h cr: Type fibred over their (kind plus type) 
contexts. It comes with a projection functor T -> TC^ which sends a type 
IE! I F h criType to the vertical projection TT: ( S | F,ar:cr) -> (S | F) in TC 
over S G KC. 
The lifted comprehension category TC x^^IK —> TC"*" in this situation is: 
( 5 | F , H h A: Kind) 
/ ( S , a : A | F ) \ 
JTfJ 
I, 
(HIT) ; 

Section 11.3: Polymorphic dependent type theory 
667 
(See Lemma 9.3.10.) The associated weakening functor is: 
T(E: I r) 
>- T(E:,a:A | r) 
(S I r h riType) 
I 
^ (S, a: A | T h r: Type). 
Left and right adjoints to TTJ* thus involve correspondences 
S I r , z : E a : ^ . < 7 h M : r 
S I T h 
M:Iia:A.T 
'E,a:A\V,x\a 
\- N:T 
E,a\A\T 
Y- N:T 
These are given by the standard introduction and elimination terms for 
polymorphic quantification: for S by 
M{z) H^ M[(a, x)/z] 
and 
N{a, x) y-^ unpack z as (a, x) in N 
and for H by 
M ^ Ma 
and 
N \-^ 
\a\A.N. 
(3) What remains to be clarified is the role of the higher order axiom 
h Type: Kind. In the type theory, terms H h cr:Type inhabiting this kind 
Type are the same as types H | 0 h cr:Type in the empty type context, 
[i.e. in the fibre of T over the terminal object IS in the fibre over S). What 
one needs is a generic object for these types in empty type context. 
In general, we consider the structure (*) as above, and form the 
fibration 
l*(g) of types in empty type context by change-of-base along the terminal 
object functor 1:B ^ A, 
L 
A . 
L 
1*(^) 
Then we can require that there is an object Q G E in the fibre over the 
terminal object 1 G B, such that this fibration l*(g) has a generic object 
over {fi} = dom('Pfi) E B. 
The pattern to describe generic objects in such multi-indexed structures is 
thus as for quantification (in the previous point): we first make the base 
categories match via change-of-base. Then we apply standard definitions. 
11.3.1. Definition. A structure (*) on page 665 (with two comprehen-
A 
sion categories E —>• B~^, D —)• A"^ and a 
fibration 
i ) will be called a 
P D T T - s t r u c t u r e if it satisfies the requirements as explained in the above 
points (1) - (3). 

668 
Chapter 11: Higher order dependent type theory 
We leave it to the reader to describe a term model PDTT-structure in 
further detail. More examples are obtained via the following auxiliary result. 
E 
11.3.2. Lemma. Let 
^ 
be a fibration with fibred Cartesian products x, 
and let Q:D -^ B"*" be a comprehension category. This Q can be lifted along 
p so that we get the following situation. 
Sp(E) 
D X B E 
Then: 
(i) Ifp has Q-products (resp. Q-coproducts satisfying Frobenius), then the 
simple fibration Sp on p has p"" [Q)-products (resp. p* {Q)-coproducts satisfying 
Frobenius). 
(ii) If p is the fibration underlying a comprehension category P i E -^ B"^, 
Fam7>(E) 
and we form the fibration 
\'{-)*{p) by pullback of p along { — } — 
dom o "PiE —)• B (like in Exercise 10.5.5), we similarly get: if p has Q-
products/coproducts, then { —}*(p) has p*[Q)-products/coproducts. 
Proof, (i) We only do the case of coproducts. Assume therefore that p has 
coproducts (]J^ H TT^) along the projections TT^ = Q(^)) satisfying Frobenius. 
For objects A E O and X G E with qA — pX we get a projection map 
p*{Q)[A, X) — WA{X) in E, see Lemma 9.3.10. It induces a weakening functor 
s,(E)x — 
— - s,(E).. (X) 
by 
Y ^ 
;r^(y). 
Hence we have in the reverse direction Z H^ LI^l^)? with: 
Sp(E);^(X)(^, (WJ(X))*(Y)) = ¥^A)(^\{X)xZ, 
n\{Y)) 

Section 11.3: Polymorphic dependent type theory 
669 
(ii) For ^ G P and X G E, write 7 = 1{A,X)-{T^\[X)] 
^ {7r^(^)} for the 
mediating isomorphism between the following two pullback diagrams—both 
arising as in Lemma 10.4.4. 
qA^pX 
We now have a weakening functor for { —}*(p) induced by p*[Q)[A,X) 
be-
tween fibre categories: 
Fam^(E)x = E{x} 
^ ^ ^ ; ( ^ ) } = Fam7>(E);r;^(x) 
namely Y M- {7r4'(X)}*(y). It has left and right adjoints by 
Z ^ ]l.'^(A)il*{Z)) 
and 
Z ^ 
Y{.',(A)il*iZ)) 
where ]J and Y\ are the assumed (Q-) coproducts and products of p. 
• 
E 
11.3.3. Proposition, (i) A higher order fibration -^P gives rise to a "sim-
ple'' PDTT-structure 
as on the left below, 
E 
(ii) // -j^P is a fibred LCCC on a base category that is an LCCC, with 
additionally a generic object and coproducts and products along arbitrary maps 
in B; then we get a PDTT-structure 
as on the right. 
Sp(E) -^ V(E) 
V(E) ^ 
V(E) 
E 
s(B) - ^ 1 ^ 
E 
]g-f _ ^ ]g-f 
\ 
\ y 
\ 
I y 
p ^ 
y X 
p ^ 
^ x^ 
B 
B 
Proof, (i) The two simple comprehension categories s(B) -> B""^ and 
Sp(E) -^ V(E) <^ E"*" are closed because of the CCC-structure in the ba-
sis, and in the fibres. And since p admits simple quantification, the simple 
fibration Sp on p admits quantification with respect to the lifted (along p) 

670 
Chapter 11: Higher order dependent type theory 
simple comprehension category on B. This follows from (i) in the previous 
lemma. 
(ii) The LCCC-structure in the basis and in the fibres yields two closed 
comprehension categories, and the third form of quantification results from (ii) 
in the above lemma; it applies by Exercise 10.5.5 (ii). 
• 
The first point is a (type theoretic) analogue of Proposition 11.2.2 allowing 
us to transform A{x;-fibrations into "simple" PDTT-structures (Exercise 11.3.2 
below presents the reverse construction). The second point applies especially 
UFam(PER) 
to the 
fibration 
i 
of PERs over cj-sets—which is a fibred LCCC by 
CJ-Sets 
UFam(PER) 
Theorem 10.5.10. It does not apply to the 
fibration 
i 
of PERs over 
EfT 
the effective topos, since this fibration does not have coproducts and products 
along all maps, see Section 11.7. 
A minimal example 
In the remainder of this section we shall further elaborate on the description 
of Aa;-fibrations as special kind of PDTT-structures (as in (i) in the previous 
result). In particular, we focus on the use of "CT-structures" to describe 
models without all the type and kind formers. Recall from Section 2.4 that 
simple comprehension categories of the form s(T) -> M~^, for T C Obj B 
a CT-structure, can be used to describe models of simple type theory with 
exponent types —)• but without assuming Cartesian product types x. Below 
we shall make similar use of these CT-structures to describe an ideal model— 
extending Example 2.4.9—for a version of second order polymorphic type 
theory with exponent -> and polymorphic product and sum 11, E as only type 
constructors. The underlying categorical structure is as for PDTT-structures, 
but not all the operations are present. We present this ideal model as another 
example in which quantification and a generic object are described in PDTT-
style via change-of-base. 
More information on ideal models may be obtained from [206, 216, 155]. 
The construction below is based on [206]. 
11.3.4. Example. Let D be a reflexive dcpo D = [D -^ D] as in Exam-
ple 2.4.9, and write ID for the set of ideals I C D. Ordered by inclusion, this 
set forms a complete lattice, because ideals are closed under arbitrary inter-
E 
sections. Our aim is to construct a fibration -j^P together with two simple 

Section 11.3: Polymorphic dependent type theory 
671 
comprehension categories: 
Hm -^ v(E) 
E 
s(l)-^]B-^ 
B 
Sp(T) 
where the fibration of types 
i 
arising from T C Obj E admits 
• exponent types, in the sense that the simple comprehension category 
Sp (T) -^ E~^ has products with respect to itself. 
• polymorphic products and coproducts with respect to the lifted comprehen-
sion category s(l) —> IB~^, where 1 G Obj B yields a singleton CT-structure. 
• a split generic object living over 1 G B for the fibration obtained by change-
Sp(T) 
of-base of 
i 
along the terminal object functor 1:B ^ E of p. 
JE 
In this ideal model we thus have many of the properties of a (simple) PDTT-
structure. 
The base category B has: 
objects 
natural numbers n G N. 
morphisms 
n —^ m are m-tuples u = (wi, • . .Um) of functions Ui'.X^ —>• 
ID-
In this standard construction we get 0 G B as terminal object, and n -h m G B 
as Cartesian product of n,m G B. The object 1 G B gives rise to a simple 
comprehension category s(l) -^ B^ with maps TT: n -f- 1 -^ n as projections, 
see Definition 1.3.3. 
E 
On top of B we construct a split fibration 
^ 
with as fibre E^i over n G B 
the category with 
objects 
sequences (Xi,.. .,Xk) of maps X^: n —> 1 in B; these are 
in fact maps rz -> Ar in B. 
morphisms 
(Xi,..., Xk) -> (Yi,..., Y^) are ^-tuples (/i,..., ft) of 
continuous functions fj: D'^ —> D satisfying 
V/GlB.VariGXi(/). • • • Vx/, G X/,(/). 
/ , ( x i , . . . , ^ , ) G y j ( / ) . 
Reindexing is done by pre-composition, and fibred finite products are obtained 

672 
Chapter 11: Higher order dependent type theory 
by concatenation. The terminal object functor 1:IB —> E sends n G B to the 
empty sequence n ^ 0 over n. 
We choose the "set of types" T C Obj E to be the set of singleton sequences 
X'.n -> 1 in B. Clearly it is closed under substitution, so it gives rise to a 
simple fibration 
i 
over p, as in Exercise 9.4.3. By change-of-base along 
the terminal object functor 1:B -^ E we single out the maps X:n —> 1, for 
which the identity map 1 ^ 1 is a split generic object. 
We have a simple comprehension category Sp(T) -^ E~^ over p (see Exer-
cise 9.4.3) with projections 
(
{Xi,...,Xk,X) 
This simple fibration over p has products along these projections, since for an 
object Y G Sp(T) over {Xi,..., 
X/j, X) we can define 
Wxiym = {yeD\yxe x{i).yxe 
Y(I)} 
over {Xi,.. 
.,Xk). Then one easily checks the correspondences 
7r*(Z) 
^ y 
over(Xi,...,Xfc,X) 
Z 
^Y[x{y) 
over(Xi,...,Xfe) 
which are pointwise as in Example 2.4.9. These simple products O x l ^ ) ^^^" 
respond to exponents X -^Y 
oi types. 
Sp(T) 
The simple fibration 
i 
over p also has polymorphic products and 
coproducts with respect to the p-lifting of s(l) -> B ^ : for a projection 
TT: n + 1 -^ n in B and an object {Xi,..., 
X^) G E over n we have a lift-
ing in E, 
(Xi O TT, . . . ,X;, O TT) 
^ (Xi, . . . ,X/,) 
Then, for an object Y G Sp(T) over (Xi o TT, ..., X/c o TT) G E over n -|- 1 G B, 
we define 

Section 11.3: Polymorphic dependent type theory 
673 
Then there are simply identities between: 
_ 
g 
^ 
f 
TT*(Z) 
^ Y 
over TT*(X) 
Y 
^ TT*(Z) 
over 
n*{X) 
, * Z 
over X 
The product correspondence is obvious, so we check the case of coproducts. 
For convenience we write boldface I for the sequence / . 
/ : y — > r ( Z ) 
over;r*(X) 
^ 
V J , J G l S + ' . V x € X ( l 5 . V j / G y ( / , J ) . / ( f , 2 / ) € Z ( / ) 
^ 
VJ € I S . Vf G X ( J 5 . U j e x , >-(/, J) C {y I / ( ^ , y) € Z(J)} 
<> VJ £ I B . Vf € X(75. V j e i o ^ ( ^ ' '^) C {y I / ( ^ , 2/) € Z(J)} 
since {t/ | / ( x , ?/) E ^ ( ^ ) } is an ideal 
o 
yjei1>.WeX(i].^ye\/j^j^Y(i,j).fix,y)eZ(i) 
<^ fU„(y)-^Z 
overX. 
This concludes our brief investigation of polymorphic dependent type the-
ory. In the next section we will investigate strength of sums E (and of equality 
Eq) in such type theories. There we will see that the weak polymorphic sums 
that we have used in P D T T behave like strong ones—because of the presence 
of strong sums of types over types (see Proposition 11.4.3 in particular). 
Exercises 
A 
11.3.1. 
Consider a fibration jr'^ and a comprehension category with unit Q:D -^ 
A"^—given by a right adjoint { —} to the terminal object functor 1 of the 
underlying fibration q = cod o Q:D -> A. Show that the following are 
equivalent. 
(i) 
The functor Q:D -> A"*" restricts to vertical maps in D -)' V(A) ^^ 
A ^ . 
(ii) The counit of the comprehension adjunction (1 H {—}) is vertical, 
(iii) The adjunction (1 H { —}) is a fibred one in a situation: 

674 
Chapter 11: Higher order dependent type theory 
F 
11.3.2. 
Consider a PDTT-structure (*) as on page 665, and form the fibration i 
by change-of-base in: 
where Ei is the fibre category over the terminal object 1 G B. 
F 
(i) 
Prove that ^ is a Au;-fibration. 
^ ^ 
El 
(ii) Check that first transforming a Au;-fibration into a simple PDTT-struc-
ture (as in Proposition 11.3.3 (i)), and then turning it back into a 
Au;-fibration returns the original fibration. 
11A Strong and very strong sum and 
equality 
In the previous section we described polymorphic dependent type theory 
(PDTT) in which types are indexed both by kinds and by types, and kinds 
only by kinds, and in which all three forms of quantification exist: dependent 
products and sums of kinds over kinds, of types over types and polymorphic 
products and sums of types over kinds. Strong sums Ha.A.B 
of kinds over 
kinds and TiXia.r 
of types over types are as in Section 10.1 with first and 
second projections TT, TT'. What was left unexplained was the precise nature of 
strong versions of polymorphic sums Da: A. cr of types over kinds. It turns out 
that in general there are two versions, which we shall call 'strong' and 'very 
strong'. These will be discussed in the present section, together with similar 
'strong' and 'very strong' versions of equality types. This material is based on 
joint work with Streicher. 
We shall thus distinguish 'weak', 'strong' and 'very strong' sums E a : A.a 
oi 
types over kinds. The differences between these three versions involve certain 
dependencies in the elimination rules (such dependencies will be described 
more systematically in the next section). The formation and introduction 
rules are the same in all three cases, namely: 
E\- A: Kind 
E,a:A\- 
a: Type 
E\- M:A 
E\T 
h N: 
a[M/a] 
E h Ea: A. a: Type 
S | T h (M, N): E a : A. a: Type 
The only requirement so far on the ambient type theory is that variables 
a: ^4 in kinds may occur in types cr(a): Type. The weak elimination rule is as 

Section 11.4'- Strong and very strong sum and equality 
675 
follows. 
E:i-p:Type 
E,a: A\T,x:a 
\- Q: p 
— 
; 
(weak) 
E I T, z:T>a: A.a 
h (unpack z as {a,x) 
in Q): p 
This is the elimination rule for polymorphic sums of types over kinds as used 
earlier in Section 8.1 in (simple) polymorphic type theory. 
Stronger versions of this rule are obtained by allowing extra freedom at the 
position "/>: Type" in the first assumption of this rule. For s t r o n g sums one 
allows the above type p: Type to contain a variable z of the sum type Da: A. B. 
For these kind of strong sums one thus needs a type theory in which types 
may depend on types, like in polymorphic dependent 
type theory (but not in 
polymorphic simple type theory). The strong elimination rule then takes the 
following form. 
H I F, z: Ea: A.a 
^ p: Type 
E,a:A\T,x:a 
h Q: p[{a, 
x)/z] 
— 
; 
(strong) 
E! I F, z: Ea: A. cr h (unpack z as {a,x) 
in Q): p 
In a next step, the "very strong" sums allow elimination with respect to 
types p:Type as above, and additionally with respect to kinds />: Kind. And 
in both cases the term variable z:Tla:A.a 
may occur in p. We have not 
yet seen type theories where kinds may depend on (be indexed by) types, 
but we shall encounter them explicitly in the next section. One of the most 
important aspects of such calculi is that one can no longer separate kind and 
type contexts: there are contexts F = [xi'.Ci, 
... ,Xn'.Cn) 
where each d 
is 
either a kind or a type (in the preceding context). We write this as 
xiiCi, 
. . ., x,_i: Ci-i 
h d: Kind/Type. 
The very s t r o n g sum elimination rule has the following form. 
F, z: Sx: A,a 
\-C: Type/Kind 
F, a: A,x:a 
\- Q: C[{a, x)/z] 
. ^^^^ 
. 
F, z: Ea: A.a 
\- (unpack z as (a, x) in Q):C 
^ ^^^^^^ ' 
In all three cases the conversion rules are the same: 
unpack (M, iV) as {a,x) 
\n Q = Q[M/a,N/x] 
(/?) 
unpack P as {a,x) 
in Q[{a,x)/z] 
= Q[P/z] 
[r]). 
These conversions are the same as for sums in polymorphic and in depen-
dent type theory (so that one can derive the commutation conversion as in 
Exercise 10.1.4). 
11.4.1. R e m a r k . The above rules are presented for two syntactic categories 
Kind and Type. But we wish to include in our expositions the possibility that 
they coincide, i.e. that Kind = Type. Then there is no distinction anymore be-
tween strong and very strong sums; and these are then the same as the strong 

676 
Chapter 11: Higher order dependent type theory 
sums we described in dependent type theory in Section 10.1. The distinction 
strong/very strong is thus only of interest in situations where Kind and Type 
are different syntactic universes. 
In Proposition 10.1.3 (i) we saw that the strong sums (of types over types) 
in dependent type theory can equivalently be described with a first and second 
projection map. The same result, with the same proof, can be obtained in the 
present more general setting for very strong sums. 
11.4.2. Proposition. The very strong sum-elimination rule can equivalently 
be formulated with first and second projection rules: 
r f-P:Ea:^.cT 
T h 
P:Ea:A,a 
T hnP-.A 
r 
\-7r'P:a[7rP/a] 
with conversions 7r(M, A^) = M, 7r'(M, N) = N and (TTP, TT'P) = P, 
• 
We emphasise that such a result cannot be obtained for strong sums, be-
cause for the first projection nP = unpack P as {a,x) in a one needs elimi-
nation with respect to kinds. 
The next result (from [166]) is somewhat surprising. 
11.4.3. Proposition. In the presence of strong dependent sums Ex.r.p 
of 
types over types, polymorphic sums T,a:A.a of types over kinds are automat-
ically strong. 
Proof. We shall use first and second projections TT, TT' for the dependent sums 
of types over types. Assume a type and term: 
S I r, z: Ea: A,a \- p: Type 
E,a:A\T,x:a 
h Q: p[{a, x)/z]. 
Using the "weak" unpack-terms and the projections TT, TT' we produce a 
"strong" unpack-term 
S I r, z: Ea: A.a \- unpack z as (a, x) \n Q : p. 
as follows. Consider the combined sum-type 
S | r h p ' "^^ Ez:{Ea: A.a). p: Type 
together with the term 
E,a:A\T,x:ahQ' 
=^ ((a,:r),Q):/>'. 
The weak elimination rule then gives a term 
S I r, z: Ea: A.a h unpack z as (a, x) in Q': /?'. 
Hence we can put as our required term 
unpack z as {a,x) \n Q = 7r'(unpack z as {a,x) in Q'). 

Section 11,4' Strong and very strong sum and equality 
677 
It is of type />, since 
7r(unpack z as {a,x) in Q') 
= unpack 7r(unpack (/?, y) as (a,x) in Q') as {l3,y) in z 
= unpack 7rQ'[f3/a,y/x] 
as (/?, y) in z 
=: unpack (/?,?/) as (/?, y) in z 
This result tells us for example that in polymorphic dependent type theory 
in the previous section, the polymorphic sum Ha: A. a of types over kinds 
is automatically strong. Thus we were not negligent in not mentioning the 
requirement that polymorphic sums in P D T T are strong, because this holds 
automatically. And if we wish to use a polymorphic dependent calculus with 
weak sums Ea: ^ . cr of types over kinds, then we are forced to use also weak 
sums of types over types. (Remember that very strong polymorphic sums 
cannot be used in P D T T because kinds do not depend on types.) 
We turn to the categorical description of strong and very strong sums. We 
formulate these notions first in a situation of two comprehension categories 
with the same base category, where one describes dependent kinds and the 
other dependent types. This will later enable us to say what strong polymor-
phic sums are in a PDTT-structure via lifting of comprehension categories. 
Recall from Definition 10.5.2 that the categorical formulation of strength for 
coproducts involves canonical maps K: {¥} -^ {LJx(^)}- These will be used 
again in the present situation. Briefly, coproducts are strong when these maps 
are orthogonal (to the kind-projections), and very strong when they are iso-
morphisms. This orthogonality requirement comes from [148]. 
Q 
V 
11.4.4. Definition. Take two comprehension categories D —y M~^ <— E on 
the same base category B. 
(i) We say that Q has s t r o n g "P-coproducts if, first of all, the underlying 
fibration q — cod o Q:D —> B has P-coproducts in the ordinary sense; that 
is, if for all objects X G E, the weakening functors 'P(X)* = TT^ between the 
fibres of q have left adjoints ] J ^ satisfying Beck-Chevalley. And second, if the 
induced canonical maps K = f^{x,A)' {^} 
~^ illxi^)} 
^^^ orthogonal to all 
Q-projections. This means: for every object B ElD and commuting rectangle 
inB, 
{A} 
-jUx(^)} 
I 
w ^ 
\ 
u \ 
^ "^ 
\ V 
Y 
^ - " 
t 
{B} 
^ qB 
QB^TTB 

678 
Chapter 11: Higher order dependent type theory 
there is a unique 'diagonal-fill-in' if; making the two triangles commute: w o 
K, = u and QB o w — v. (Note that { —} in this diagram is dom o Q.) 
(ii) And we say that Q has very strong P-coproducts in case q has 
"P-coproducts in such a way that all these canonical maps AC: [A] -^ {LJx(^)} 
in B are isomorphisms. 
Recall that the canonical map AC: {^1} -^ {lJx(^)} arises by applying { —} — 
dom o Q:D —> IB to the (opcartesian) composite 
Ux(^) 
Further, notice that when the comprehension categories V and Q happen 
to coincide [i.e. when Kind = Type), there is no difference between strong and 
very strong coproducts. The inverse of /c required for the implication (strong) 
=> (very strong) is obtained in the following diagram. 
{A] 
{A} 
{]lxiA)] 
T^A 
qA 
By uniqueness of fill-in maps, this morphism {Uxl^)) "^ {^} ^^ then also 
right-sided inverse of K. This observation is in line with our earlier remark 
that in dependent type theory there is no difference between strong and very 
strong sums (of types over types). 
Since projections are closed under pullback, there is the following reformu-
lation of orthogonality—which is sometimes more convenient. The proof is 
easy and left to the reader. 
11.4.5. Lemma. The canonical map K:{A] —>• {Ux(^)} ^^ ^^^ above defi-
nition is orthogonal to all Q-projections if and only if: for every object JB G O 
over {Ux(^)} ^ ® ^^^ morphism u: {A} —> {B} in a commuting 
(outer) 
diagram 
{A} 
^{UxiA)} 
{B} 
TTB 
{UxiA)}=qB 

Section 11.4'- Strong and very strong sum and equality 
679 
there is a unique u\ { U x ( ^ ) } —'*' {^} ^^^^ TT^ o S = id and u o K — u. 
• 
The above description of strong and very strong coproducts applies to a 
situation with two comprehension categories with the same base categories. 
This will be the case in the next section, but the two comprehension cate-
gories used for PDTT-structures in the previous section have different 
base 
categories (connected via a fibration, see the diagram below). In such a sit-
uation we can still say when coproducts are strong by suitably lifting the 
comprehension category of kinds (as we did to define polymorphic quantifica-
tion). 
11.4.6. Definition. Consider two comprehension categories V, Q and a fi-
bration r in the following diagram. 
Q 
D 
^ A-' 
E 
^ 
Then we say that Q has s t r o n g c o p r o d u c t s with respect to V in case Q has 
strong coproducts with respect to the lifted comprehension category 
r*{V). 
All PDTT-structures have strong (polymorphic) coproducts of this kind by 
virtue of Proposition 11.4.3. Below we describe the orthogonality condition 
in a term model, and we leave it as an exercise to the reader to check that 
polymorphic coproducts are strong in the ideal model from Example 11.3.4. 
11.4.7. Example. We elaborate the details of strong polymorphic sums 
T,a:A.a 
in a term model of P D T T (as described in the previous section) 
in relation to the above orthogonality condition. A lifted projection associ-
ated with a kind E h ^ : Kind in the category T C of type-and-kind-contexts 
at S I r is: 
(S,a:^ I r) 
'—^ 
(- I r) 
of variables /^ in S and v in F. For a type E,a:A\T 
h cnType we assume 
that we can form the polymorphic sum S | F h T,a: A.c.Jype. 
It is strong 
according to Lemma 11.4.5 if for each type 
S I F, z: Ea: A.a 
\- p: Type 
with term 
E^a: A\T,x:a 
\- Q: p[{a, 
x)/z] 

680 
Chapter 11: Higher order dependent type theory 
in a commuting (outer) diagram 
(2, a:A\V, 
x: a) 
^ (S | T, z: Ea: A. a) 
(/?,(?, (a, x),Q)) 
i/^,(^,^,Q) 
( H I r , z: Ea: A. a, y: p) 
^ ( 5 | T, ^: Ea: A. a) 
7r={^,{v,z)) 
there is a unique cHagonal as indicated. This means that there is a term 
S I r , z: E a : ^ . or \- Q. p subject to the conversion Q[(a, x)/z] — Q. But then 
Q = Q[z/z] = unpack z as {a,x) 
in Q[{a,x)/z] 
= unpack z as (a^x) in Q. 
Hence we have the strong elimination rule as formulated in the beginning of 
this section. 
Strong and very strong equality 
types 
In the remainder of this section we have a brief look at strong and very strong 
versions of equality types. Since like sums, equality also involves left adjoints— 
not to weakening functors TT* but to contraction functors S*—a similar analysis 
applies. 
For clarity, we are discussing "polymorphic" equality types over kinds here, 
with standard formation and introduction rules 
E h A: Kind 
E h A: Kind 
E,a:A,0:A 
h Eq^(a, ;^):Type 
E : , a : ^ | 0 h r^(a): Eq^(a, a) 
where we usually write r for ryi(Q;) when confusion is unlikely. 
One distinguishes three equality elimination rules, much like for sums: weak, 
strong and very strong ones. The difference lies again in the dependencies that 
one may have. The weak equality elimination rule is as follows. 
H, a: A, /?: Aba: 
Type 
E,a:A\ 
T[a/f3] h Q: a[a/l3] 
(weak) 
E,a:A,l3:A\ 
T, ^: Eq^(a,/?) h {Q with /? = a via 
z):a 
It is as in Section 8.1 for simple polymorphic type theory. If one uses a type 
theory where types may depend on types (like in a polymorphic dependent 
type theory), then the type E,a:A,P: 
A \ T h a.Jype 
in the first premise 
above, is allowed to contain an additional term variable z: Eq^(a,/?), so that 
one can formulate the s t r o n g elimination rule as: 
E,a:A,/3:A\T,z:EqA{a,(3) 
ho-: Type 
E,a: A\T[a/l3] 
\-Q:a[a/f3,r/z] 
E,a:A,/3:A 
\ T, z: Eq^(a,/?) h (Q with /? = a via z):a 
(strong) 

Section 11.4- Strong and very strong sum and equality 
681 
Finally in the very strong equality elimination rule one allows elimination 
not only with respect to types a as above, but also with respect to kinds. 
This only makes sense in type theories where kinds may depend on types, 
i.e. where kinds may contain term variables (inhabiting types). And in such 
a type theory one cannot separate kind and type contexts anymore, so that 
the very s t r o n g elimination rule takes the following form. 
r, a: A, /?: A, z: Ecu (c^, /^) ^ C: Type/Kind 
T,a:A\- 
Q: C[a/f3, r/z] 
(very 
T,a:A,f3:A,z:EqA{a,(3) 
h {Q with /? rr a via z):C 
strong) 
In all three cases the conversions are the same, namely: 
Q with a — a via r = Q 
(/^) 
Q[a/f3, r/z] with /? = a via P = Q[P/z] 
(r?). 
The next two results are analogues of Propositions 11.4.2 and 11.4.3 for 
(strong) sums. 
11.4.8. Proposition. The very strong equality-elimination 
rule can equiva-
lently he formulated 
by the following 
two rules. 
S h P : E q ^ ( M , 7 V ) 
H h P : E q ^ ( M , 7 V ) 
-E^M^N'.A 
E h P = r:Eq^(M,7V) 
D 
The proof of this result is the same as in dependent type theory (see Propo-
sition 10.1.3 (ii)). It tells us that equality is very strong if and only if inter-
nal equality (inhabitation of Eq^(M, A'')) and external equality (conversion 
M = N:A) 
are the same. In models of higher order dependent type theories 
very strong polymorphic equality occurs most frequently. But the version of 
polymorphic sum that one most often finds is the strong sum. This is because 
the very strong sums lead to "Girard's paradox" in the presence of the higher 
order axiom h Type: Kind, see Exercise 11.5.3 in the next section. 
11.4.9. Proposition. Consider 
a type theory where types depend both on 
kinds and on types. In presence of strong dependent 
sums of types over types, 
polymorphic 
equality Eq^(a,/?):Type for A: Kind is automatically 
strong. 
Proof. We proceed exactly as in the proof of Proposition 11.4.3. Assume a 
type Z,a:A,P:A 
\ P, z: Eq^(a,/?) h cr:Type with a term E,a:A 
\ T[a//3] h 
Q: (T[a/(3, r/z] and write 
'E,a:A,(3:A\V 
h (J' =^ Sz: E q ^ ( a , ^ ) . o-: Type 
E,a:A\V[a/(3] 
h Q' ""M {r,Q): 
cT'[a/(3]. 
Then we get by weak equality elimination, the term 
E.a-.A.^'.A 
I r , z : E q A ( a , ^ ) h (Q with /? = a via 
z):a'. 

682 
Chapter 
11: Higher order dependent 
type 
theory 
The strong elimination term that we seek is now obtained via second projec-
tion: 
Q with l3 = a via_ z = 7r'((5' with /? = a via z). 
This term is of the required type cr, since 
7r((3' with /? =: a via z) 
= 7r(Q' with /? = a via z)[a//?, r/z] with /? = a via z 
= 7r((r, Q[a/(3, r/z]) with a = a via r) with (3 = a \/\a z 
= r with P = a y\a z 
— z[a/(3, r/z] with /? = a via z 
= z. 
D 
What is still lacking is a categorical description of strong and very strong 
equality. This follows the same pattern as for strong and very strong sums in 
Definition 11.4.4. 
11.4.10. Definition. Assume two comprehension categories D —> M~^ <— 
E on the same basis. 
(i) We say that Q has strong "P-equality if the underlying fibration 
q ~ cod o Q:P -> IB has P-equality (via adjunctions Eqx H S^ plus Beck-
Chevalley, where Sx is the "P-diagonal associated with X G E) in such a way 
that the induced canonical maps K = «(x,A)- {^} ~^ {Eqx(^)} are orthogo-
nal to all Q-projections. This means: for every object B £]D and commuting 
rectangle in B, 
{A} 
^ 
^{Eqx{A)} 
{B} 
^ qB 
QB = 7rB 
there is a unique diagonal making everything in sight commute. 
(ii) And we say that Q has very strong "P-equality in case q has P-equality 
in such a way that all these canonical maps {^4} -^ {Eqx(74)} in B are 
isomorphisms. 
This description of very strong equality captures the one used earlier in 
Proposition 4.9.3 in predicate logic as a special case. In Exercise 11.4.5 below 
it will turn out to be sufficient to have the Q-projection of "equality at 1" iso-
morphic to a 'P-diagonal to get very strong equality (in the presence of fibred 
CCC-structure). The essence of very strong equality is then that 7^-diagonals 
occur as Q-projections, as in the triangle below. This is often useful, see the 
examples in the subsequent Exercise 11.4.6. 

Section 11.4: Strong and very strong sum and equality 
683 
Exercises 
11.4.1. 
(i) 
Show that the elimination term unpack z as^ {a, x) \r\ Q constructed in 
the proof of Proposition 11.4.3 comes with the appropriate conversions, 
(ii) Do the same for the term Q with (3 = a vm z in the proof of Proposi-
tion 11.4.9. 
11.4.2. Show that if a simple comprehension category s(T) —> B~^ has coproducts 
with respect to a comprehension category P: E —>• IB"*", then these coprod-
ucts are automatically strong. 
[The underlying reason is that in simple comprehension categories there is 
no real type dependency so there is no difference between weak and strong 
sums. ] 
Conclude that the polymorphic coproducts ]J 
in the ideal model from 
Example 11.3.4 are strong. 
11.4.3. Assume in Definition 11.4.10 that the comprehension categories V and Q 
are the same. Prove (categorically) that there is then no difference between 
strong and very strong equality. 
11.4.4. 
Investigate the categorical description of strong equahty in the term model 
of a polymorphic dependent calculus (like for sums in Example 11.4.7). 
11.4.5. Let D —y B"*" i— E be comprehension categories, v/here Q is full and has 
a unit 1:B ^ D. Recall (e.g. from Section 3.4) that we are often mostly 
interested in "equality at 1". This is the subject of the present exercise: we 
say Q has pre-equality with respect to V if for every object X G E there 
is an opcartesian map X: 1{X} -> Eq(X) in D above the ('P-)diagonal Sx, 
together with a Beck-Che valley condition (in the style of Exercise 9.3.6). 
Assume for each X G E there is an object Eq(X) € O over 
{V{Xy{X)} 
with a map ipx in a commuting triangle 
{X} 
^ {Eq(X)} 
{V(xnx)} 
(i) 
Show that if ipx is orthogonal to all Q-projections, then its transpose 
1{X} 
—> Eq(X) is opcartesian over Sx, so that Q has strong pre-
equality. 
(ii) Prove that if each ipx is an isomorphism, then Q has very strong pre-
equality. 
(iii) Assume additionally that q = cod o Q is a fibred CCC. Prove that the 
definition 
Eqx(A) = Eq(X) X 
V{V(Xr{X)y{A) 
yields that Q has (ordinary) very strong equahty. 
11.4.6. 
(i) 
Conclude from (ii) in the previous exercise that the comprehension 
categories of subobjects and of regular subobjects have very strong 

684 
Chapter 11: Higher order dependent type theory 
pre-equality with respect to every comprehension category, 
(ii) And conclude also that the comprehension category UFam(PER) —^ 
a;-Sets"* of PERs over a;-sets has very strong equality with respect to 
UFam(u;-Sets) •% a;-Sets"^. Check that the same holds over EfF. 
11.5 Full higher order dependent type theory 
We come to the last type theory that will be discussed in this book. It is in a 
sense an extension of polymorphic dependent type theory (PDTT): it allows 
kinds to "depend on" types: kinds A(x): Kind may contain a variable x: a in-
habiting a type a: Type (which is forbidden in PDTT, see the previous section). 
Since this new type theory allows all possible dependencies between Type and 
Kind—in a sense to be made precise below—we shall call it full h i g h e r o r d e r 
d e p e n d e n t t y p e t h e o r y , abbreviated as FhoDTT. It is based on the Calcu-
lus of Constructions of [58], and can be seen as another combination (besides 
PDTT) of polymorphic and dependent type theory. Extensions of FhoDTT 
have been implemented in the proof tools COQ and LEGO, see the end of this 
section. 
We start below by discussing some of the syntactic aspects of FhoDTT, and 
devote the next section to the categorical semantics of FhoDTT. For proof 
theoretic investigations we refer to [55, 92, 90, 22]. We first introduce a general 
notion of "dependency" in type theory, so that we can clearly characterise the 
type theory of FhoDTT among the many type theories that we have seen so 
far. These type dependencies actually form the basis for the classification of 
type theories in this book, see also [154, 163]. Basically, they determine the 
(indexed) categorical structures underlying the various type theories. In the 
second half of this section we describe and investigate FhoDTT in some detail. 
We put particular emphasis on a reflection between types and kinds, which 
results from the presence of sums E and unit types and kinds 1. 
Dependencies 
in type 
theory 
Remember from Section 11.3 that in polymorphic dependent type theory 
(PDTT) there are types depending both on kinds and on types, and kinds 
depending only on kinds. In the new type theory FhoDTT there are all four 
(combinatorially possible) dependencies between types and kinds. These ob-
servations prompt a more detailed investigation of such dependencies. 
We will formulate these dependencies abstractly. Consider therefore two 
syntactic categories (or "universes", or "sorts") si,S2 in a specific type 

Section 11.5: Full higher order dependent type theory 
685 
theory—for example, si = Kind, S2 — Type. We then say that 
52 depends on si, 
which will be written as 
S2 )^ si, 
if there are derivable sequents 
TV-A'.si 
and 
T,x\ A ^ B{x)\S2 
in this type theory, with x: A (actually) occurring free in B[x). This means 
that there are "s2-types" B{x):s2 containing variables x:A inhabiting an 
"-Si-type" A:si. Put differently, 52 >- si means that we may have 
si-indexed S2's 
as in the example 
yB{x):s2) 
. for 
A:si. 
This last formulation is easiest to remember, so we repeat it explicitly. 
11.5.1. Definition. In a type theory with universes si,S2 we put 
S2 >• si <^ there are (well-formed) expressions A: si, B{x): S2 
forming an indexed collection 
where x is actually free in B. And in that case we say: S2 depends on 5i, or: 
S2 is indexed by si. 
For example, in polymorphic type theory PTT there are types depending 
on kinds {i.e. Type >- Kind), typically in: 
((^^^)-"^yP^)a:Type:Kind-
This dependency Type >- Kind is characteristic of PTT. And in dependent 
type theory there are term variables occurring in types (amounting to Type y 
Type), as in the example of the type NatList(n) of lists (of natural numbers) 
of length n: 
(NatList(n):Type)„^^-ryp^. 
The dependency Type y Type is typical for DTT. Figure 11.1 gives an overview 
of the dependencies that we have seen so far. 
The first three type theories STT, PTT and DTT in this table can be seen as 
basic building blocks. The last two PDTT and FhoDTT are combinations. As 
is apparent in this table, the additional dependence in FhoDTT with respect 
to PDTT is the dependence of kinds on types. Under a propositions-as-types 
reading this becomes the dependence of types (or sets) on propositions. One 
can think of examples here—e.g. the set steps(p) of derivation steps in a proof 
p: a of proposition a—but the naturality of this dependency is debatable (see 
also [230, 252, 253] for further discussion). 

686 
Chapter 11: Higher order dependent type theory 
name 
Simple 
Type Theory 
Dependent 
Type Theory 
Polymorphic 
Type Theory 
Polymorphic Dependent 
Type Theory 
Full higher order 
Dependent 
Type Theory 
abbreviation 
STT 
DTT 
PTT 
PDTT 
FhoDTT 
universes 
Type 
Type 
Type, Kind 
Type, Kind 
Type, Kind 
dependencies 
— 
Type >- Type 
Type >• Kind 
Type >- Kind 
Type >- Type 
Kind >^ Kind 
Type >- Kind 
Kind >- Type 
Type y Type 
Kind y Kind 
Fig. 11.1. Dependencies in various type theories 
Taking dependencies as a starting point in the classification of type theories 
comes from [154, 163]. There, a collection of universes carrying a transitive 
relation >- of dependency is called a setting. The setting of a type theory 
determines the basic categorical structure of the type theory: 52 >- si means 
that 52 is fibred over si, since the S2-types may be indexed by 5i-terms, as 
in i^B{x)\S2)^.j^.^ . This correspondence between dependency in type theories 
and indexing in category theory is the basis for all the categorical structures 
that we describe. 
The view taken in this book is that a logic is always a logic over some type 
theory. We have explicitly studied predicate logic over STT in chapter 4, over 
PTT in Section 8.6 and also over DTT in Section 11.1. One can go a step 
further and consider logics over PDTT and over FhoDTT. Categorically this 
involves putting a suitable (preorder) fibration on top of a PDTT-/FhoDTT-
structure. The above table can thus be extended with various logics. They can 
be described with an additional sort Prop, with typical dependency Prop >-
Type. It arises from predicates ^{x): Prop which are indexed by types <j:Type, 
as in: 
(^(^)-P^°P).:.:Type-

Section 11.5: Full higher order dependent type theory 
687 
We conclude this excursion on dependencies with a review of the differ-
ent settings in which the various sum and equality types (weak, strong, very 
strong) from the previous section are described. In a type theory with two 
sorts s\, S2 with dependency S2 >- si it makes sense to consider products, 
sums and equality "52 over si", with the following formation rules. 
V^C:si 
V,x:C^D:s2 
T h C: 5i 
V,x:C\-D:s2 
r 
hIix:C.D:s2 
r 
\-T.x:C.D:s2 
r l-C:5i 
r, X, x\ C h Eqc(^, x): S2 
Sometimes we refer to these as (si, S2)-products/sums/equality, when we wish 
to explicitly mention the relevant sorts. 
The setting in which it makes sense to consider weak/strong/very strong 
(si, S2) sum or equality types is summarised in the following table. 
(51, S2)-sum/equality 
weak 
strong 
very strong 
required 
dependency 
S2 y si 
S2 y 
si 
S2 y S2 
S2 y Si 
S2 y S2 
Si y 52 
It can be explained as follows. The weak elimination rule for (si,S2)-sums 
is: 
T \- B:s2 
T,x:C,y:D 
^ Q: B 
T,z:'^x:C.D 
h Q: B 
In the strong elimination rule one allows the variable z: Ex: C. D, inhabiting 
the sum TiX.C.D of sort 52, to occur free in B\S2- This requires "s2-type 
dependency" S2 )- 52. In the very strong rule one additionally allows B to be 
of sort si. Since B may contain a variable y: D, where D is of sort 52, this 
requires the dependency si y S2. The same analysis applies to equality types. 
We see that the language of dependencies makes it easier to explain the 
differences between the various forms of sum and equality types. Also, in 
combination with Figure 11.1, it is now easy to see in which type theories 
it makes sense to consider, for example, strong (Kind,Type)-sums. Similarly, 
this language can be used in the description of constants, see [163] for more 
details. 

688 
Chapter 11: Higher order dependent type theory 
Syntactical aspects of full higher order dependent type theory 
In the remainder of this section we concentrate on a single type theory, namely 
on full higher order dependent type theory (FhoDTT). The starting point 
in the description of FhoDTT is the stipulation that there are two sorts 
Type, Kind and all (four) dependencies Type >- Kind, Kind y Type, Type y Type 
and Kind y Kind between them. As a result, one cannot separate kind and 
type contexts, like in polymorphic dependent type theory: since variables in-
habiting types may occur in kinds and variables inhabiting kinds may occur 
in types, a context is a sequence of variable declarations for types and for 
kinds. There are then sequents of the form 
xi'.Ci,.. 
.^Xn'.Cn f-D:Type/Kind 
where xi'.Ci,..., 
Xj-.d h d-j-i: Type/Kind for each i < n. The type and kind 
forming operations that we use in FhoDTT are 
higher order axiom 
h Type: Kind 
units for type and kind 
h IT: Type and 
h IK' Kind 
with (sole) inhabitants 
h QT- IT and 
h QK'- ^K 
products 
UxiC.D 
for C, D: Type/Kind, 
strong sums 
T,x:C.D for C: Kind, D: Type, 
very strong sums 
Tix: C. D for C: Type, D: Type; C: Type, D: Kind; 
C: Kind, D: Kind. 
So formally we have four different products and four different sums: types over 
types (Type, Type), kinds over types (Type, Kind), kinds over kinds (Kind, Kind) 
and types over kinds (Kind,Type). The first three sums are very strong, and 
the last one is only strong. (Recall, that there is actually no difference between 
strong and very strong for (Type,Type)-sums and (Kind, Kind-sums.) 
In principle, these (Kind,Type)-sums can be very strong as well (since we 
have the dependency Kind y Type in FhoDTT needed for the very strong 
elimination rule to make sense). But having very strong (Kind,Type)-sums 
has some detrimental effects. We will see below (in Corollary 11.5.4) that it 
results in an equivalence of types and kinds. This effectively gives us a type 
theory with a type of all types (Type: Type), and in such a type theory every 
type is inhabited. The result is known as "Girard's paradox". The original 
source is [95]; but many variations exist, see e.g. [54, 272, 153, 141] (and 
Exercise 11.5.3 below). The fact that all types are inhabited does not trivialise 
the type theory, but it makes it unusable in a propositions-as-types scenario, 
because it then means that each proposition has a proof. 
It makes sense to consider "weak FhoDTT" with weak (Kind,Type)-sums, 

Section 
11.5: Full higher order dependent 
type theory 
689 
instead of strong ones, as required above. Proposition 11.4.3 then forces the 
(Type, Type)-sums to be weak as well. Extensional PERs (ExPERs) over a;-sets 
in Example 11.6.7 in the next section form a model of weak FhoDTT (but 
not of ordinary FhoDTT). 
We shall see that the sums (and units) in FhoDTT give rise to a "reflection" 
Type <^ Kind between types and kinds. In order to make this categorically 
precise we have to use a term model of FhoDTT, consisting of two fibrations 
of types and of kinds, both over the same base category of (type and kind) 
contexts. This base category C consists of contexts F = (xi: Ci,..., Xn'-Cn) in 
FhoDTT—with C,:Type or CiiKind—and context morphisms (sequences of 
terms) between them. A category T of types over C has types-in-context F h 
a: Type as objects over F G C A morphism (F h a\ Type) ^ (A h r: Type) 
in T consists of a context morphism M: F -^ A in C together with a term 
V.x.cr h N:T[M). 
There is a (full split) comprehension category T —)• C~^ 
mapping a type F h cr: Type to the associated projection 7r:(F,x:cT) —> F. 
Similarly there is a category K of kinds-in-context F h ^: Kind as objects 
over F G C. And the (full split) comprehension category K —>• C~^ sends a 
kind V \- A\ Kind to its context projection TT: (F,a: A) —^ F. This leads to a 
situation: 
T ' 
K- 
^ ^ 
It will turn out that the very strong (Type, Kind)-sums and the (weak) 
(Kind, Type)-sums of (weak) FhoDTT yield a fibred reflection T ^ IK between 
types and kinds. This is the content of the next two propositions. 
11.5.2. Proposition, (i) In the presence of a unit kind l/^-iKind and weak 
(Type, Kind)-5wm5 one can define a fibred functor X\T -^ K from types to 
kinds by 
(F h(T:Type)H^(F h Ear: cr. 1/^: Kind). 
(ii) // (Type, Kind)-5wm5 are very strong, then this functor X:T —^ K is 
full and faithful and commutes up-to-isomorphism with the type- and kind-
projection functors: 
Proof, (i) Notice that for a (vertical) morphism T.x.a 
h M:T from (F h 

690 
Chapter 11: Higher order dependent type theory 
a: Type) to (F h r: Type) in T we can define X(M) as the term 
r, z: TiX: a. IK H unpack z as {x, w) in {M{x),w): T>y: r. 1^. 
(ii) If our (Type, Kind)-sums are very strong, then the canonical map 
(r, x: a) 
> (r, z: Ex: a. IK) 
is invertible with as inverse {v, TTZ). One now easily concludes that X: T —)• IK 
is full and faithful: 
Tr((T, r) ^ C / r ( 7 r „ TT.) ^ C/r(7rj(,), 7rj(,)) ^ Kr(x(cr), X(r)), 
using that the comprehension categories of types and of kinds are full. 
D 
The reverse of (ii) also holds (under an extra assumption), see Exer-
cise 11.5.1 below. 
11.5.3. Proposition. In the presence of very strong (Type, K\ndi)-sums and 
weak (Kind,Type) sums there is a fibred reflection 
T C 
where X is the full and faithful functor resulting from (ii) in the previous 
proposition, and its left adjoint TZ is obtained from (i). 
Proof. What we need for F h A: Kind and F h cr: Type is an adjointness 
correspondence between terms M and N in 
F,z:Ea:A.lT V- M{z):a 
V,a\A 
f- 
N\T.X\(T.\K 
It is given by 
M ^ 
M(a) = (M[(a,()T)A],(M 
N !->• N[z) — unpack z as (a,x} in 7rN{a). 

Section 
11.5: Full higher order dependent 
type theory 
691 
Then: 
^ 
M{z) 
= unpack z as {a, x) \n M[{a, 
{)T)/Z] 
= unpack z as {a,x) in 
M[{a,x)/z] 
= M. 
N{a) = (unpack (a, ()T) as {a,x) in 7rA^(a), ()/^) 
= 
{7rN{a),{)K) 
= (7riV(a),7r'7V(a)) 
= iV(a). 
D 
11.5.4. Corollary. In FhoDTT with very strong (Kind, Type) sums there is 
an equivalence T c::^K of types of kinds. 
Proof. With very strong (Kind,Type)-sums the left adjoint 1Z:K ^T 
in the 
previous proposition is also full and faithful, so that we get an equivalence 
T - ^ K, as stated. 
D 
Polymorphic dependent type theory FhoDTT as sketched in this section 
was first formulated by Coquand and Huet [58] as the Calculus of Construc-
tions, see also [14]. It was introduced as an expressive combination of poly-
morphic and dependent type theory. Actual representation and verification 
in the Calculus of Constructions turned out to be problematic (notably be-
cause of problems with inductively defined types, see [321]). This gave rise to 
two extensions, with additional universes for separating logic from data. Both 
these extensions have been implemented in proof tools. 
(i) The Calculus of Inductive Definitions [59, 248] forms the basis for the 
proof tool COQ [20]. The emphasis in the use of COQ lies on program ab-
straction, via a duplication of the structure of the Calculus of Constructions 
(separating programming and logic). There is a facility for extracting exe-
cutable ML programs from suitable terms, see [249, 31]. (See also [276] for a 
comparably duplicated version of second order polymorphic type theory, for 
similar purposes.) 
(ii) The Extended Calculus of Constructions (ECC) adds to the Calculus of 
Constructions an infinite hierarchy of kinds (Kindj),-^i^ with inclusions Type C 
Kindo C Kindi C • • •, see [201, 202]. There is an uj-set based semantics, using 
an infinite sequence of inaccessible cardinals to interpret the Kind,, see [200]. 
This hierarchy of kinds facilitates the formalisation of abstract mathematics. 
The LEGO system is a proof-assist ant based on ECC, extended with inductive 
types, see [203]. 

692 
Chapter 11: Higher order dependent type theory 
Exercises 
11.5.1. 
Assume that the (Type, Kind)-sums in Proposition 11.5.2 (i) are strong. 
Show then that if the induced functor X: T -)• K is full and fciithful, then 
the (Type, Kincl)-sums are very strong. 
11.5.2. 
Consider the full and faithful functor J: T —)• K from types to kinds, arising 
from very strong (Type, Kind)-sums in Proposition 11.5.2 (ii). Prove that 
one has strong (Type, Type)-sums if and only if "J preserves sums", in the 
sense that for T \- cr: Type and T^x.a 
h r: Type the canoniccil term P in: 
r, z: Ea:I{a).I{T)[77a/x] 
h P: I(Ea;: a, r) 
is invertible. 
11.5.3. We sketch a version of Girard's paradox in FhoDTT with very strong 
(Kind,Type)-sums, mimicking Mirimanoff's paradox (see [153] for details) 
about the non-existence of a set Q of well-founded sets (problem: is Q itself 
well-founded?). Type theoretically, one tcikes Q to be 
Q = Ea:Type. E <:a -^ a -^ Type. WF(a, <), 
where WF(a, <) is the type 
lip: a —)• Type. (TiX.a.px 
x Hx.a. \px -^ Ey:a. {py x y < x)]) -> ±. 
where _L = (Ha: Type, a): Type. The inhabitants of Q are thus triples 
(cr, (<a,9a)) consisting of a type a with an ordering <Q, and a proof-term 
Qa witnessing that <a on a is well-founded. The next step is to define an or-
dering <a on Q. Informally, one says that (a, (<«, ga)) is below {/3, (</3, ^/3)) 
if there is an order preserving function ct -> /9, which stays below a certain 
point in /3. 
<n = Xu:Q.\v:Q.Ef:a 
-^ f3.Ez:f3. 
unpack u,v as {(a, {<a,ga)), (/3, (</3,g/3)),) in 
[Hxia. Uy: a.x <a y -^ foo </3 fy) x [llx: a. fx <i3 z). 
(i) 
Check that in order to define u <ci v: Type for u, v: Q we need 
sum-elimination with respect to Type: Kind—and thus very strong 
(Kind, Type)-sums. 
(ii) Construct: 
(1) a proof-term gn:WF(Q,<Q); 
(2) a proof-term r: Q <n fi, where Q = (Q, (KCI^QCI))' ^; 
(3) a proof-term s: 1. inhabiting falsum^ using (1) and (2). 
1L6 Full higher order dependent type theory, categorically 
In this section we describe appropriate fibred categories for full higher or-
der dependent type theory (FhoDTT), and consider some examples. First of 

Section 
11.6: Full higher order dependent 
type theory, 
categorically 
693 
all, we present two 'degenerate' examples: one—resulting from an arbitrary 
topos—in which the fibration of types is a poset. Then there are no terms 
(or proof-objects) between types, and the model is 'logical' instead of 'type 
theoretic', in the sense that provability is modelled, and not proofs (under 
a propositions-as-types reading). The other degenerate example involves the 
fibration of closure-indexed-closures, as described at the end of Section 10.6. 
It is a model for the axiom h Type: Type, and so we can turn it into a model 
of polymorphic dependent type theory with Type = Kind. In this situation, 
Girard's paradox (Exercise 11.5.3) applies, so that every type is inhabitated. 
This can also be seen as a form of (logical) degeneracy. 
Next we present three realisability examples, involving PERs over a;-Sets, 
PERs over EfF, and 'extensional PERs' over ct;-Sets. The latter is a model 
of weak-FhoDTT, in which the types are closed under weak dependent sums 
E, but not under strong ones, see [320]. We conclude with some generalities 
about "FhoDTT-structures". 
As we already emphasised in the previous section, the main difference be-
tween full higher order dependent type theory (FhoDTT) and polymorphic 
dependent type theory (PDTT) is that in FhoDTT kinds may depend on 
types (i.e. Kind >- Type, in the notation from the previous section). As a re-
sult, one cannot separate kind- and type-contexts in FhoDTT, like in PDTT. 
This has consequences for the corresponding categorical structure: one does 
not have two base categories of contexts like in PDTT (namely B and A in 
the diagram (*) on page 665), but a single base category of (kind- and type-) 
contexts (like in the base category C in the term model described before 
Proposition 11.5.2 in the previous section). Moreover, there will be a (fibred) 
reflection Type t^ Kind between types and kinds resulting from the sums in 
FhoDTT (see Proposition 11.5.3). Thus we shall combine a comprehension 
category E —>- W^ for kinds with a reflection D (t:^ E of types in kinds, like in: 
The functor D f~ E from kinds to types is the left adjoint to the inclusion, 
as in Proposition 11.5.3. Actually taking this reflection E ±:; D as primitive 
greatly simplifies matters, since it induces much of the structure on types (see 
Lemma 9.3.9, Exercise 9.3.9 and the table below). 

694 
Chapter 11: Higher order dependent type theory 
11.6.1. Definition. A structure 
is called a weak F h o D T T - s t r u c t u r e if 
• 'PiE ^ B"^ is a closed comprehension category (of kinds); 
• q = cod o "P o X is a fibration (of types), and D ^ E is a fibred reflection; 
• there is an object fi G E over the terminal object 1 G B, such that the 
fibration 
q has a generic object over {Q} — AOWLP{Q) 
G B . 
In such a situation the composite Q — VX:'D -> B"^ is a comprehension 
category, which, by the reflection, has a unit 7^1: B ^ P—where 1:B —)• E 
is the unit of P . Further, the required four forms of coproduct—kinds/types 
over kinds/types—exist in such a structure, according to the following table. 
coproducts 
(very) strong (Kind, Kind) 
strong (Type, Kind) 
weak (Kind,Type) 
weak (Type, Type) 
1 
are present because 
P is a CCompC 
Q-projections are "P-projections 
of the reflection D <t^ E 
of the reflection and because 
1 
Q-projections are 7^-project ions 
A similar table applies to products Yl instead of coproducts ]J. The last two 
coproducts (of types over kinds and over types) need not be strong, as will be 
shown in Example 11.6.7 below. Therefore we have the following addition. 
11.6.2. Definition. A (strong) F h o D T T - s t r u c t u r e is a weak FhoDTT-
structure as above where the comprehension category Q = P Z i D -^ B"^ of 
types is closed. 
(This amounts to the requirement that Q has strong Q-coproducts, or, 
equivalently by Proposition 11.4.3, that Q has strong P-coproducts.) 
Since the situation with strong sums is most common, we often omit 'strong' 
and just say 'FhoDTT-structure' for 'strong FhoDTT-structure'. Also, we 

Section 11.6: Full higher order dependent type theory, categorically 
695 
shall call a (weak or strong) FhoDTT-structure split if all of its structure is 
split. Below we follow our usual preference for presenting examples in split 
form. 
11.6.3. Example (Toposes). Let B be a topos. Then B is a regular category, 
so that there is a fibred reflection Sub(B) t^ B~^, as in Theorem 4.4.4. The 
reflector B~^ —> Sub(B) sends an arbitrary morphism to its monic part, us-
ing the epi-mono factorisation in a topos. And since monos are closed under 
composition, Sub(B) —>• B~^ is a closed comprehension category. We thus get 
a FhoDTT-structure of the form: 
Sub(B) 
Recall from Example 10.5.9 that the codomain 
fibration 
^ 
of a topos 
:F(I) 
B is equivalent to the split fibration i 
of families / x X ^ Q in B (with 
reindexing given by composition, instead of by pullback). We may thus present 
the above structure also in split form as 
Sub(B) c 
^ ^ ( B ) 
These structures are degenerate models of FhoDTT, since the subobject fv-
Sub(B) 
bration 
i 
for types is a poset. Thus all structure of terms between types 
is destroyed. 
11.6.4. Example (Closures). Recall from the last part of Section 10.6 the 
Fam(Clos) 
closed comprehension category 
4- 
of closure-indexed-closures. It ad-
Clos 
mits a type of all types (i.e. Type:Type): there is the universal closure 
Q G Clos with the set of closures as image. Formally, the family id^: ^^ -> ^ 
Fam(Clos) 
over fi is split generic object for 
i 
: for every family X:a -^ fi in 
Clos 
Fam(Clos) over a E Clos there is a unique map a —"*• ft in the base category 
Clos, namely X itself, which yields X — X*(idn). And we can see ft as the 
domain of a family ft: 1 -> ft in Fam(Clos) over the terminal object 1 G Clos, 

696 
Chapter 11: Higher order dependent type theory 
so that {Q} ^ Q. All told, we have a FhoDTT-structure 
Fam(Clos) =
= 
Fam(Clos) 
^ Clos"^ 
Clos 
in which the fibrations of types and of kinds are the same: this is a degenerate 
model with Type = Kind. 
We turn our attention to realisability models of FhoDTT. We discuss suc-
cessively: PERs over a;-Sets, PERs over EfF and ExPERs over u;-Sets. The 
first two of these examples are obtained by combining various results on PERs 
from previous sections. 
11.6.5. Example (PERs over a;-Sets). To start with, recall from Exam-
ple 1.8.7 (ii) that the reflection P E R ^ 
u;-Sets lifts to a fibred reflec-
tion UFam(PER) ±; UFam(a;-Sets) over u;-Sets. This gives us a FhoDTT-
structure 
UFam(PER) c 
^ UFam(u;-Sets) 
>^ u;-Sets 
c<;-Sets 
in which kinds are u;-set-indexed families of cj-sets, and types are u;-set indexed 
families of PERs. Since the fibration of PERs over u;-sets (on the left) is the 
externalisation of the internal category P E R in cj-Sets, it has a split generic 
object, given by the set of PERs, considered as object P E R Q in cj-Sets. 
And this object comes from a family over 1 in UFam(cc;-Sets). Finally, in 
Example 10.5.8 we saw that UFam(PER) —> a;-Sets~^ is a closed comprehen-
sion category. In particular, there are strong (Type,Type)-sums in the above 
FhoDTT-structure. 
11.6.6. Example (PERs over EfF). The reflection PER t^ cj-Sets that we 
used in the previous example, also lifts to a reflection over the eff'ective topos 
EfF, see Proposition 6.3.2 (iii). Hence we get a similar FhoDTT-structure over 
EfF. 
^ 
UFam(PER) c 
^ UFam(cj-Sets) 
^ EfT^ 
EfF 

Section 11.6: Full higher order dependent type theory, categorically 
697 
11.6.7. Example (ExPERs over u;-Sets). This example involves the (reflec-
tive) subcategory ExPER t:^ PER of so-called 'extensional PERs', intro-
duced in [81]. Streicher [320] shows that in this "submodel" example one does 
not have strong (Type, Type)-sums: it is a weak FhoDTT-structure. 
We start with some preliminary definitions and results on extensional PERs. 
The definition of extensionality for PERs makes crucial use of the special PER 
Nx_ (but see Exercise 11.6.1 below for an alternative definition): 
NL = {(n,n') |n.O::^n'.0}. 
where c^ means that either both sides are undefined, or both sides are defined 
and are equal. It is clear that N]_ is a PER. Its quotient set N/A/^i is the union 
{[Kx. t]} U {[Kx. n\\ne 
N}; it can be identified with the set J_N = 1 -h N of 
natural numbers with additional bottom element. 
We now define a PER R to be extensional if the canonical map 
R 
^ A^l^-^^ 
mapping 
x i—> %a: N^. Ci[x) 
is a regular mono in cj-Sets. (Recall from Lemma 5.3.8 (i) that regular sub-
objects in a;-Sets correspond to subsets of the carrier sets, with inherited 
existence predicate.) It follows that if i? G PER is extensional, then two ele-
ments X, y G N/i^ are equal if and only if a{x) — a[y) for each a\ R—^ N±_ in 
cj-Sets. It is easy to see that Nj_ itself is extensional. 
We write ExPER ^-> PER for the full subcategory of extensional PERs. 
It is easy to construct a left adjoint to this inclusion: for an arbitrary PER S 
take the regular image in u;-Sets of the canonical map S —> Nj_ -^ as 
7/5 
regular mono 
5. 
S 
^ 5' > 
^ N[^^^ 
Then, by the equivalence between (i) and (ii) in Exercise 11.6.1, S' is an 
ExPER. And every map f:S 
-^ i^ to an ExPER R, factors uniquely as 
/ : 5' —• R with f o rjs = f using the diagonal-fill-in: 
S 
^ 
S' 
/ 
I reg. mono 
I' 
reg. mono 
x 
reg. mono 

698 
Chapter 11: Higher order dependent type theory 
The ExPER model of polymorphic dependent type theory is easy to 
describe. The reflection ExPER 
±^ PER lifts to a fibred reflection 
UFam(ExPER) <^ UFam(PER) over u;-Sets. We thus get a weak FhoDTT-
structure 
UFam(ExPER) c 
^ UFam(PER) 
^ a;-Sets-
cod 
a;-Sets 
since the fibred reflection transports all the required structure from the closed 
comprehension category of PERs over u;-sets, to the fibration of ExPERs over 
cj-sets. In particular, this fibration of ExPERs is a fibred CCC, and so the 
category ExPER (the fibre over 1 G u;-Sets) is a CCC. 
In this example we have kinds as families of PERs over u;-sets. But since 
there is also a fibred reflection UFam(PER) t^ UFam(a;-Sets) over a;-Sets, 
we have by composition of fibred reflections, another example 
UFam(ExPER) c 
^ UFam(a;-Sets) 
^ cj-Sets" 
cod 
a;-Sets 
in which we have kinds as c<;-set indexed families of Cc;-sets. 
We now come to Streicher's counter example, showing that in this last situ-
ation one does not have strong (Type, Type)-coproducts [i.e. sums). Consider 
therefore the exponent ExPER N^, where N is the PER of natural numbers. 
Over this object, define the family 5/ G E x P E R given for / G N^ by 
r TVx 
ifVx./(x) = l 
•^ ~ [ N X N else. 
where N x N is the terminal ExPER with singleton quotient set {N}. We 
describe the coproduct of ExPERs over an ExPER as an a;-set: 
= {{%x. 1, z) I ^ G 1 + N} U {(/, N) I /: N -^ N part, rec, / ^ %x. 1} 
see Exercise 11.6.2. The carrier set of X can also be split into a union 
X ^ Xi U X2 
of sets of partial recursive functions: 
Xi = {^:N-^N partial recursive I Vx GN.5f(:rH-1) = 1} 
X2 = {^fiN —^ N partial recursive | ^(0) t and 
3x en. (g{x -\-1) ^ 1 ov g(x -{-1) t)}-

Section 
11.6: Full higher order dependent 
type theory, 
categorically 
699 
The value at 0 of ^f G Xi is thus used to give the value in the fibre Sf over 
the function f{x) = g{x-\-l). In the second case this value at 0 must be fixed, 
and divergence is chosen. The existence predicate E on this coproduct X is: 
e e E(g) <^ e • 0 ^ ^(0) and Vx G N. e • (ar + 1) 2:^ g{x + 1) = 1, 
for g e Xi; 
e e E{g) ^ 
Vx E N. e • (x + 1) ~ ^(x + 1), 
for g e X2. 
The outcome e • 0 at 0 of a realiser e E: E{g) for g E X2 is irrelevant since any 
two realisers of g (differing solely at 0) will be identified when X is considered 
as a PER. Thus, any code n G N for a partial recursive function is a realiser 
for some function hn in X, namely for 
ifVx.e.(x + l) = 1 
/^n = <(... f t 
i f y - 0 
^^^^^^.^^ 
Notice that if ni and 712 are codes for the same partial recursive function, 
then they realise the same function in X. 
UFam(ExPER) 
If the fibration 
i 
of ExPERs over u;-sets has strong coproducts, 
CJ-Sets 
then by Exercise 11.5.2 this coproduct u;-set (X, E) must be an ExPER. This 
requires for gi,g2 G X that gi = g2 if (^{gi) = ct{g2) for all morphisms 
a: X —^ N± in u;-Sets. It turns out that this property fails, by the fact that the 
effective operations are continuous. This is the Myhill-Shepherdson Theorem 
from recursion theory, see e.g. [236, II.4]. 
Consider the following two functions in X. 
gi{x) = 1 
and 
g2(x) = < ^ t if X =: 0 
else. 
Then both gi and ^2 are in Xi, but obviously gi / ^2- We show that a{gi) = 
a{g2) for each a: X -^ N_i in Cc;-Sets. This means that X is not (isomorphic 
to) an ExPER. 
Assume a: X —^ Nj_ in c«;-Sets is given, say tracked by rf G N. Let < be a 
primitive recursive function—obtained via the s-m-n Theorem—such that for 
each n,x G N, 
<Pt{n)(x) = 
d'n'0. 
We can now define an effective operation F by 

700 
Chapter 11: Higher order dependent type theory 
since t is "extensional": 
(fm — V^n2 =^ ^ij ^^2 are codes of the same function in X 
^ 
d • niN±d 712 
^ rf- ni • 0 :^ c? • 722 • 0 
Assume now a{gi) ^ a{g2) and thus ^(^fi) 7^ F{g2), say F{gi){k) 
^ 
F{g2){k). Without loss of generality, assume that F{gi){k) is defined, and 
has value £. By the Myhill-Shepherdson Theorem all effective operations are 
continuous, so there is a finite approximation hi C gi with F(h){k) = £ for 
all h D hi. We distinguish two cases: 
• If hi{0) tj then also hi C g2, so that F(g2){k) = I, This is impossible. 
• If /ii(0) I, one must have /ii(0) = 1. We take another finite function /i2, 
which acts like hi, except on 0, where it is undefined. Any two realisers m,-
for hi (with z = 1,2), are codes for the same function in X2, so drrii C:^ c/m2. 
But then F(hi) — F(h2), and since /i2 approximates ^2? we must have 
F{g2){k) = ^ by monotonicity of F. Hence also this second case leads to a 
contradiction. 
Thus we have shown that the coproduct X of ExPERs over an ExPER is 
not an ExPER. We may conclude that these ExPERs form a weak FhoDTT-
structure. 
11.6.8. Remark. Recall from Lemma 9.3.9 that products Yl and coproducts 
]J are "transported along a reflector". This ExPER example shows that strong 
coproducts are not transported: there is a fibred reflection UFam(ExPER) ±1; 
UFam(a;-Sets) and the fibration of u;-Sets has strong coproducts, but the 
fibration of ExPERs does not. 
These are the examples of FhoDTT-structures that we describe here. We 
should also mention the model (without sums) of Lamarche [185], which is 
an adaptation of the ^coherent domain' model of polymorphic type theory 
from [96]. Also there are the examples of Hyland and Pitts [148] involving 
particular kinds of Grothendieck toposes, namely ^algebraic' toposes (presheaf 
toposes on small categories with finite limits) and 'algebraic-localic' toposes 
(presheaf toposes on meet semi-lattices). The first of these examples is de-
generate in the sense that it is a model with Type =: Kind—and thus with 
Type: Type, using that there is an algebraic topos ^encoding' all algebraic 
toposes. And in the second case one uses algebraic localic toposes for types, 
and algebraic toposes for kinds. One then still has a kind of all kinds. Varia-
tions of the above model of PERs over a;-sets are used in [320, 321] for various 

Section 11.6: Full higher order dependent type theory, categorically 
701 
independence results in FhoDTT. See also [312] for similar use of models based 
on combinatory algebras. 
We conclude this section with some general points worth noticing about 
FhoDTT-structures. 
11.6.9. Theorem. Let B T=± E -^ M-^ be a weak FhoDTT-structures, 
as in 
Definition 11.6.1. Write Q — VX:B -^ W^ for the comprehension category of 
types, and q — cod o Q:D ^ B for the associated fibration. Then 
(i) q is a fibred CCC, and thus a locally small fibration; 
(ii) q is a 'full" small fibration: it is the externalisation of a full internal 
category C in B; fullness is automatic because Q is a full and faithful (fibred) 
functor Fam(C) = D -^ B"'. 
Proof, (i) Cartesian closure follows as in Proposition 10.5.4, except that we 
have to remember that also the weak (Type, Type)-sums yield fibred Cartesian 
products, see Exercise 10.5.4 (i). 
Since gf is a thus a fibred CCC with comprehension, it is locally small by 
Corollary 10.4.11. 
(ii) Let ^ G O be the generic object of q over Co = {^} G B. We then get 
an internal category C = Full(t/) in B, as in Theorem 9.5.5, with a full and 
faithful fibred functor Full(t/) -^ D, provided the relevant pullbacks exist in 
the base category B to form the objects of composable tuples and triples. And 
this functor Full(t/') ^ D is an equivalence like in Corollary 9.5.6 because q 
has a generic object. 
The existence of the relevant pullbacks follows because one can always form 
pullbacks along the V- and Q-projections. For example, the Cartesian product 
Co X Co E B is formed as the puUback 
Co X Co 
^ Co 
J 
TT 
Co 
^ 1 
VQ 
so that the Cartesian projections TT and TT' are P-projections. The pair 
(5o, 5i): Ci —)• Co X Co of domain and codomain maps of C is then the Q-pro-
jection 
Q(7r*(C/)^7r'* ([/)). 
This can be seen by combining the description of (5o,5i) in the proof of 
Theorem 9.5.5 with the description of representing arrows via exponents => 
underlying Corollary 10.4.11. Since 5o = TT o (5o, 5i) is a composite of P- and 

702 
Chapter 11: Higher order dependent type theory 
Q-projections, the pullback u*{do) exists in B for any map u: I -^ Co- This 
allows us to form the pullbacks C2 and C3 in B of composable tuples and 
triples (as in Definition 7.1.1). 
• 
This result emphasises the role of internal categories in (weak) FhoDTT-
structures. In the special case where the fibration of kinds is a codomain 
fibration, the reflector from kinds to types makes this internal category com-
plete. In eff'ect, completeness is equivalent to existence of such a reflector. This 
result, due to [143, 76], will be presented next. It gives a particularly easy de-
scription of certain models of FhoDTT, like the PER and ExPER models over 
u;-sets. Such a structure is sometimes studied as a type theoretic generalisa-
tion of a topos, in which the (internal) preorder structure of the object Q of 
propositions in a topos is replaced by a proper internal category of types, see 
e.g. [76, 255]. 
11.6.10. Theorem. LetM be a locally Cartesian closed category, containing a 
full internal category C, with full and faithful fibred functor 1: Fam(C) -> B"^ . 
Then: X has a fibred left adjoint if and only if C is a small complete category 
in B and X is continuous. 
Under these equivalent conditions there is a weak FhoDTT-structure 
of the 
following form. 
Fam(C) c_2. 
Since the codomain fibration of an LCCC is complete, the existence of a 
reflection obviously makes the internal category complete, so the interesting 
part of the statement concerns the construction of the reflector, assuming 
completeness. This may be done (like in [143]) via an application of a (fi-
bred) adjoint functor theorem (see [47, 246]). But with the products JJ one 
can define a coproduct, like in Exercise 8.1.5, yielding a weak left adjoint. 
What remains to be done then, is to make this into a real adjoint via a stan-
dard construction with equalisers (as used for example in the proof of [187, 
V, 6, Theorem 1] to turn a weak initial object into a real initial object). 
See [254] for a general analysis of the adjoint functor theorem in terms of such 
definable coproducts. 
We shall present this construction in a type theoretic formulation, using 
some ad hoc notation for the inclusion X of types into kinds, and for equalisers 
of (parallel) terms between types. The inclusion X yields for a type F h 
a: Type a kind F h X{a): Kind in the same context. By fullness it comes with 

Section 11.6: Full higher order dependent type theory, categorically 
703 
introduction and elimination rules: 
r h M:a 
r \- 
N:I{T) 
r \-\{M):I{a) 
r 
\-O{N):T 
with 'i' and 'o' for 'in' and 'out'. The associated conversions are simply 
o(i(M)) = M 
and 
i(o(7V)) = N. 
For types F h cr, r: Type in the same context, and "parallel" terms T,x:a 
h 
Mi,M2'T 
we shall use an "equaliser type" F h E(Mi, M2): Type, together 
with a term F, z: E(Mi, M2) H CMI.MS- ^ satisfying 
F,2::E(Mi,M2) f- Mi[eMi,M2/^] = A^2[eMi.M2/^]-^• 
Further, we translate the familiar universal property of equalisers into this 
type theoretic language as follows. For each term F,A h A^icr satisfying 
F, A h Mi[N/x] = M2[N/x]:a, there is a unique term F, A h iV: E(Mi, M2) 
satisfying F, A h eM,,M2[N/^] - 
^'^' 
Proof. For a kind T \- A: Kind we construct a type F h lZ{A):Type^ such 
that for a type F h aiType we get a bijective correspondence between terms 
M and A^ in: 
T,a:A 
h M:2(cr) 
— 
f *) 
F,x:7^(A) h iV:(7 
yielding the required adjunction IZ -\ X. We construct 1Z{A) by first con-
structing a weak left adjoint 7Zyv{A), together with two equaliser types. We 
put 
F f- 7^w(A) =^ n^: Type. {Ua: A. f3)-^ f3 : Type 
F h P =^ Aa: A. \(3: Type. A^: (Ha: yl. /?). ^ • a : Da: A. n^[A) 
F, /: 7ew(A) -> 7^w(^) H P' "i^ Aa: A.f 
{P-a): 
Yia: A. ny,{A). 
By weakening we can also put P in the same context as P', so that we can 
form their equaliser; for convenience we use the following abbreviations. 
def 
T \- E — E[P, P'): Type 
with canonical term: 
dpf 
T,z:E 
\- e ~ ep^p> : 7^w(v4) -> 7^w(^) 
satisfying: 
F,z:£' h P = A a : y l . e ( P a ) : na:^.7ew(^). 
We also consider the following two terms with the intended reflector 'R{A) as 

704 
Chapter 11: Higher order dependent type theory 
their equaliser. 
r, y: n^{A) 
h Q =^ XziE.y.E-^ 
Tly^iA) 
T,y:ny,(A) 
h Q' =^ \z:E.e 
• y: E-^ Tly,{A) 
def 
r h lt{A) — E{Q,Q'): 
Type 
with canonical term: 
def 
V^x:lZ{A) \- c — eq^Q' : 7^w(^) 
satisfying: 
^,ar:7^(A) h Az:£;.c= XziE.ec: 
E 
^ny,(A). 
Notice that in this situation we have a conversion 
T,a:A\-Q[{P-a)/y] 
= 
Xz.E.Pa 
= Xz:E.e'{P 
a) 
= 
Q'[{P^a)/y]:E^n^{A) 
so that we get a unique term 
T,a:A 
l-P:7^(A) 
with 
T,a:A 
h c[P/x] = P • a:7^w(A). 
We claim that there is then a correspondence (*) as in the beginning of 
the proof: given terms T,a:A 
h M:X{cr) and T,x:lZ(A) 
\- N:a we define as 
transposes: 
r, x:n{A) 
h M^ 1^^ c . ^ • (Aa: A. o(M)) : a 
T,a:A\- 
7V^ =^ \{N['P/X]) 
: l{a). 
Then it is easy to see that 
M^^ = 
\{c['P/x]'a'{Xa:A.o{M))) 
= \{P 
'a-a'{Xa:A.o{M))) 
= 
\{{Xa:A.o{M))'a) 
= i(o(M)) 
= M. 
It is more complicated to show A^^^ = N. We form the equaliser 
T \- D = E{N, A/^^^): Type 
with canonical term: 
T,w: D \- d = ejv.iv^^ • T^{A) 
satisfying: 
T,w:D \- N[d/x] = 
N''^[d/x]. 
Now it is easy to show that N'^^lP/x] 
= N[P/x], so that there is a unique 
term 
_ 
_ 
r,a:v4 hP:J9 
with 
T,a:A 
\-dlP/w] = T: 
n{A). 

Section 11.6: Full higher order dependent type theory, categorically 
705 
We abbreviate 
r h L =^ \y: lly,[A).c[d/x][{y 
• D • (Aa: A. T))/w]: 7^w(^) -> 7ew(A) 
and check that 
P'[Llf] 
= 
Xa:A.L(P'a) 
= Xa: A. c[d/x][{P a-D- 
(Aa: A. V))/w] 
= Aa: ^4. c[d/x][P/w] 
by definition of P 
rr 
Xa-.A.ciP/x] 
= 
Xa.A.Pa 
= P 
= P[L/fl 
We thus get a unique term T hT:E 
with T h e[L/z] = L:n^{A) 
-^ Hy^iA), 
because e is the equaliser term of P, P\ For d' = d[{c • Z) • {Xa: A. P))/w] we 
have 
_ 
c[d'/x] = 
c[d/x][(c'D'{Xa:A.P))/w] 
= 
L'C 
= 
e[L/z]-c 
= (Az:E'.e-c) • L 
= (Az:E.c) -L 
== c. 
Hence there are two terms T,x:lZ{A) 
h x,d':lZ(A) 
with c[d^/x] = c[x/x]. By 
uniqueness—with respect to the equaliser ^{A)—they 
must be equal: d' = x. 
But then we can finally conclude that A'' = N^^ since 
TV = 
N[d'/x] 
= 
N[d/x][{c-D-{Xa:Ay))/w] 
= N''''[d/x][{c- D • 
{Xa:A,f))/w] 
= N'^'^ld/x] 
- 
N""^. 
D 
We have described some of the essential aspects of categorical structures 
for full higher order dependent type theory. In the next, final section we shall 
further investigate one particular example of such a structure, namely PERs 
over Eff from Example 11.6.6. 

706 
Chapter 11: Higher order dependent type theory 
Exercises 
11.6.1. 
Prove that for a PER R the following statements are equivalent: 
(i) 
R is extensional: the Ccinonical map R -^ (Ni.)^^^-^^ ) is a regular 
mono in a;-Sets; 
(ii) there is an u;-set A = (A,E) 
with a regular mono R ^-> {N±.)'^ in 
a;-Sets; 
(iii) R is extensional in the sense of [81]: there is a "base" B C N such that 
for all n G \R\ and m € N 
nRm 
^ 
n,m are "co-extensioncJ mod B" 
^ 
yk e B.n 
k c::^ m- k. 
11.6.2. Recall Exercise 1.2.10 and check that the homset of maps N -^ Nj_ in 
a;-Sets can be identified with the set of partial recursive functions N —^ N. 
T 
11.6.3. 
Show that one can obtain a Acj-fibration r from a FhoDTT-structure D <=^ 
E -^ B"^, by forming the fibration r via change-of-base in: 
¥ 
J 
I 
q = cod o "P o J 
{ —} = dom 0 V 
(Where Ei is the fibre over the terminal object 1 G IB.) 
11.6.4. 
(i) 
Show that every FhoDTT-structure D i=^ E —> B~^ can be transformed 
into a PDTT-structure, by taking 
FamQ(D) 
where FamQ(D) is the "lifted" closed comprehension category over 
q = cod 0 Q, obtained as in Exercise 10.5.5 from Q = VX. 
[Hint. Remember Lemma 11.3.2 (ii).] 
(ii) Show that turning a FhoDTT-structure first into a PDTT-structure 
(as above) and then into a Aa;-fibration (as in Exercise 11.3.2) yields 
the same result as turning the FhoDTT-structure directly into a 
Aa;-fibration (as in the previous exercise). 
[In [166] one can find how a Aa;-fibration can be turned into a FhoDTT-
structure. The construction is based on an idea from [230], and is rather 
complicated; therefore it will not be reproduced here.] 

Section 11.7: Completeness of the category of PERs in the effective topos 
707 
11.7 Completeness 
of the category of PERs in the effective 
topos 
In this final section we shall have a closer look at the sense in which the 
internal category of PERs in the effective topos EfF is complete. It turns 
out not to be complete in the usual sense (see Definition 1.9.11) since the 
Beck-Chevalley condition does not hold for the product functors YIF^ right 
adjoint to reindexing F* along an arbitrary map F in EfF. A (non-trivial) 
counterexample may be found in [150, Proposition 7.5]. It forms the starting 
point for further investigations, leading to the characterisation that PERs in 
Eff are "weakly" complete. In this section we sketch some of the basic results 
in this direction: we assemble material from [143, 150, 41] to show that the 
fibrations of PERs and of cj-sets over EfF are "weakly complete", by describing 
their "stack completions" as the complete fibrations respectively of separated 
families, and of separated families which are orthogonal to V2 G EfF. The 
idea to describe the (weak) completeness of PERs via orthogonality is due to 
Freyd, see also Remark 8.3.6 (i) (b). 
From a type theoretic perspective, this failure of Beck-Chevalley means 
that PERs in EfF do not form a FhoDTT-structure like in Theorem 11.6.10 
(a complete internal category in an LCCC). Hence we do not get a model 
of full higher order dependent type theory (FhoDTT) with types as families 
of PERs and kinds as families of objects of EfF, both indexed over EfF. But 
PERs in EfF are complete enough to form a model of FhoDTT with kinds 
interpreted as (families of) cj-sets (as we have seen in Example 11.6.6). Then 
one only requires adjoints to certain weakening functors, induced by (gener-
alised) projections given by kinds. Hence PERs in EfF can be used to give a 
model of FhoDTT. 
The investigations below involve 'stacks'. These can be understood as gen-
eralisations of sheaves, which may have arbitrary categories as fibres, and 
not just discrete categories, i.e. sets. Thus stacks generalise sheaves like in-
dexed categories generalise presheaves. In most general form, a stack consists 
of a "continuously" indexed category, over a base category equipped with a 
Grothendieck topology. See [100] or [168] for more information and references. 
Here we only need stacks with respect to the regular epi topology, as in Exam-
ple 5.6.3 (ii). (Recall that in a topos every epi is regular, see Corollary 5.5.5.) 
Moreover, we restrict ourselves to full subfibrations of a codomain fibration 
I 
for B a topos. Such a full subfibration can be identified with a collection 
V C ArrIB of "display maps" of B, which is closed under pullback: if a family 
(p is in T>, then each pullback u*{(p) of (p is again in V. As before, we write 
^"^ 
i 
for the associated fibration of families in V. 

708 
Chapter 11: Higher order dependent type theory 
11.7.1. Definition. Consider a full subfibration 
^ 
of the codomain fi-
B 
bration 
^ 
of a topos B, given by a collection of display maps V C Arr B. 
IB 
(i) This subfibration is called a stack (with respect to the regular epi 
topology on B) if for each pullback square 
u 
with u: J -^ I 3i (regular) epi, one has 
(ii) The stack completion of the subfibration induced by V is given by 
the collection V of display maps containing those families I 
^^ 1 for which 
there is an epi u: J -^ I in M with u*((p) G T>. 
11.7.2. Definition (See [39, 150]). A full subfibration 
^ 
^f 
i 
is 
called weakly complete if its stack completion 
I 
is a complete fibration. 
The difference between weak completeness and ordinary completeness is 
that in the weak case it is true in the internal language that limits exist, 
whereas for ordinary completeness these limits are given to us by external 
functors. It is like for ordinary categories where one may have binary products 
X given 'weakly' as 
for every pair X, Y of objects there is a product diagram X <^ X xY —^Y 
and 'ordinarily' as 
there is a right adjoint x to the diagonal functor. 
One needs the Axiom of Choice in the meta-theory to establish the equiva-
lence of these two descriptions. But within the universe given by a (subobject 
fibration of a) topos, this axiom may fail. 
We can be more explicit if the display maps in V come from an internal 
category C == (Ci —^ Co) in B. For objects X^Y: I zit Co over /, existence of 

Section 11.7: Completeness of the category of PERs in the effective topos 
709 
their Cartesian product in the internal language is 
r S{i) = 3P: Co. BTT: P -^ X,-. BTT': P -^ Yi.T[i, 
P, TT, TT') 
\/i:LS[i) 
where 
< 
with 
[ T(i, P, TT, TT') = '%• A- P ^ 1^- is a product diagram" 
If Vi: /. 5(2) holds we get a situation 
T 
V 
/ X (Co X Ci X Ci) 
- ^ 5 
Y 
-^ I 
where T ^> 5 ^-> / is the image factorisation of the composite T >-^ I x (Co x 
Ci X Ci) -^ /. We thus get an epi e:T -^ / such that e*(X) and e* (Y) have a 
(canonically given) product. This is in essence what is expressed by the above 
definition of weak completeness. 
UFam(a;-Sets) 
Our first aim is to show that the fibration 
i 
of a;-Sets over 
Eff 
. 
, 
EfF is weakly complete, by showing that its stack completion is the fibration 
FSep(Eff) 
i 
of separated families for the double negation nucleus on EfF. The lat-
Eff 
ter is always a stack, which is complete as a fibration. This can be established 
in greater generality. 
11.7.3. Lemma. LetM be a topos. A full 
suhfihration 
is definable is a stack. 
FSepj 
As a result, for a nucleus j in B the fibrations 
i 
families 
of separated objects 
and sheaves are 
stacks. 
of 
i 
which 
1 
FSh: 
and 
of 
Proof. Assume a pullback square 
in which u is an epi and V^ is in P . Since V is definable, there is a mono 
m.I' 
>-^ I with <^' — m*{(p) G V. By the universal property of <p' we get a 

710 
Chapter 
11: Higher 
order dependent 
type 
theory 
unique map v: J ^ V such that 
y 
1 1 
Y 
- -^ X' 
^ X 
9' 
> 
J 
' 
> 
^ 
t 
is 
Y 
^ X 
i, \ 
J 
f 
^ ^ 
( 
J 
^ Jf > 
^ / 
J 
^ J 
V 
m 
u 
This makes m an epi, and hence an isomorphism. Thus <^ is in P . 
The second part of the lemma follows because the fibrations of families 
of separated objects and of families of sheaves are definable, see Proposi-
tion 9.6.9. 
• 
FSepj(B) 
11.7.4. Lemma. A fibration 
i 
of y separated families in a toposM, is 
always complete. 
Proof. It is easy to see that separated families are closed under finite limits. 
Closure under products ]~J follows from Exercise 5.7.6 (ii). 
• 
Before we can analyse the situation in EfF, we need the following result; it 
says that every object in EfF has a separated cover. 
11.7.5. Lemma. For every object (/,«) G EfF there is an uj-set {I\ E) G 
cj-Sets with an epi {!' ,E) -^ (/,«) in EfF. 
ProoF. Take 
/' = {(i, n) I i G / and n G E[i) - \i ^ i\} 
with existence predicate E{i,n) = {rz}, and thus as equality 
,,. 
. 
../ 
/., 
(in) 
if i = i'and n 
\M^(^,n)\=^l 
otherwise. 
There is then an epi P: (/', E) -» (/, «) with P(i, n, i') - \i ^^'\^ 
{n}. 
D 
Notice that taking such separated covers is not functorial. 
UFam(u;-Sets) 
11.7.6. Theorem. The fibration 
i 
considered as a full subfibra-
Eff 
Eff"^ 
tion of the codomain fibration 
I 
(via Proposition 6.3.4), has the fibration 
FSep(Eff) 
4- 
of double negation separated families as its stack completion. Hence 
families of uj-sets over Fiff form a weakly complete fibration. 
ProoF. Every (/, «)-indexed family (X[,], E[i])[i]^r{i «) of cj-sets yields a sep-
arated family I 
. ^ x 
I as in Proposition 6.3.4. And since separated fam-

Section 11.7: Completeness of the category of PERs in the effective topos 
711 
ilies form a stack, they also contain the stack completion of such families 
Conversely, assume I 
^^ 
I is a separated family. There is by the pre-
vious lemma an cj-set (/', E) together with an epi P: (/', E) -^ (/, «). Taking 
the puUback along P yields another separated family, call it ip', over an a;-set. 
UFam(C<;-3ets) 
By Proposition 6.3.3, this family (f' corresponds to a family in 
4-
Eff 
Hence the original family (p is in the stack completion of this fibration. 
• 
UFam(PER) 
We turn to the completeness of the 
fibration 
i 
of families of PERs 
. 
. 
. 
Eff 
over EfF. To make things easier we first investigate the non-fibred situation. 
Below, a special role is played by the two-element set 2 = {0,1} G Sets and 
by its image V2 G EfF. We shall be especially interested in objects in Eff 
'orthogonal' to V2 (and in families of these). 
11.7.7. Definition. Let A he a, fixed object in an arbitrary Cartesian closed 
category B. One calls an object X G B orthogonal to A if every map A -^ X 
is constant. More precisely, if the canonical map X ^ {A => X)—obtained 
as 
exponential transpose of the projection X x A -^ X—is an isomorphism. 
X\ 
(X 
This concept extends to families: ( | 
1 is orthogonal to A G B if ( | 
1 is 
orthogonal to /*(^) = 1 
| ^ 1 in the slice category B//. 
Orthogonality is related to uniformity: recall that an object U is uniform 
with respect to A^ if every total relation R C U x N is constant: for some 
n: N, R{u, n) for all u:U. Such an object U is then clearly orthogonal to A^. 
The next result relates objects orthogonal to V2 and modest sets (or PERs) 
in EfF. It shows a certain formal resemblance with connectivity in topological 
spaces. We refer to the discussion in Remark 8.3.6 for the reason why this 
result yields suflBcient completeness for polymorphic (simple and dependent) 
type theories. Instead of V2 one can also use the subobject classifier fi G EfF, 
see [150, Proposition 6.1]. 
11.7.8. Proposition (Freyd). Consider an uj-set {I,E) G EfF. Then 
{I,E) 
IS a modest set if and only if it is orthogonal to V2 G EfF. 
ProoF. Suppose {I,E) is modest and let /: V2 -^ {^,E) be tracked by e. 
Write 2*0 = /(O) and ii = /(I). Since 0 G N = £'v2(0) 0 £'v2(l), we get 
e 'Q E Ej{io) n Ej{ii). Thus io = ii and / is constant. 

712 
Chapter 11: Higher order dependent type theory 
Conversely, assume {I^E) is orthogonal to V2, and let io,ii G / be given 
with n E Ei{iQ)nEi{ii). 
There is then a morphism /: V2 -> (/, E) by /(O) -
2*0 and /(I) = z'l, which is tracked by Xx. n. But since / must be constant, we 
get io = ii. 
D 
We would like to extend this result to families of PERs. But first we state 
the completeness of a full subfibration of orthogonal families. 
11.7.9. Lemma. Let M be a topos with a nucleus j and a fixed object A G 
IB. We write Orth(A) <^ B"*" for the full subcategory of families that are 
orthogonal to A and SepOrthj(74) <^ Orth(A) for the full subcategory of j -
separated orthogonal families. 
(i) The codomain functors Orth(74) —)• B and SepOrthj(74) —)• B are fibra-
tzons. 
Orth(A) 
SepOrthj(^) 
(ii) These 
fibrations 
i 
and 
i 
are complete. 
(iii) And they are both definable—and hence stacks by Lemma 11.7.3. 
Often, the subscript j in SepOrthj(A) will be ommitted if the nucleus j is 
clear from the context. 
Proof, (i) For a family I 
|*^ I orthogonal to ^ G B and a morphism u: J —^ 
/, the pullback u*((p) is again orthogonal to A, since: if (p =. I* (A) => (p then 
w*(v?) ^ u*{r{A) ^ ^ ) ^ u*r{A) => u*{<f) ^ r(A) => w*(^) 
making u*{(p) orthogonal to J* {A) in 
Since separated families are closed under pullback, the codomain functor 
SepOrthj(A) —> B is also a fibration. 
(ii) By Lemma 11.7.4 it suffices to prove that the fibration of orthogonal 
families is complete. Fibrewise (finite) completeness is easy: a map /: I* (A) -^ 
<p — lirrii ipi is determined by the composites /* (^4) —> (p - ^ (pi, which must 
be constant. 
So what remains is closure under products f]^. Assume u: I -^ J m M 
/ X \ 
and a family I 
j ^ J. Maps J* {A) -^ Hul^) 
in B// then correspond by 
transposition to maps r{A) 
^ u*J*[A) -^ v^ in B//, which are constant. 
Hence the former are constant. 
(iii) For a family (p in B//, write (p for the canonical map (p —>• (/* [A) =>• (p) 
and form the mono {^ G viso} ^> /, using that (vertical) isomorphisms are 
definable—since the codomain fibration on B is locally small, see Lemma 9.6.7. 
For a morphism w: J -> / we get: w*(<^) is orthogonal to A if and only u 

Section 11.7: Completeness of the category of PERs in the effective topos 
713 
factors through {(f £ viso} y-^ I. This shows that orthogonality is definable. 
The families which are both orthogonal and separated are then also definable, 
see Exercise 9.6.3. 
D 
UFam(PER) 
11.7.10. Theorem. The fibration 
I 
considered as a full 
subfibra-
Eff 
Eff"^ 
SepOrth(V2) 
tion of the codomain fibration 
J 
has the fibration 
i 
of sepa-
Eff 
Eff 
rated families 
that are orthogonal to V2 E EfF as its stack completion. 
Hence 
families of PERs over EfF form a weakly complete 
fibration. 
Proof. In essence we reproduce the argument underlying Proposition 11.7.8 
for families of PERs. In one direction, an (/, «)-indexed family R = 
/({m,^)\ 
(i^[i], £^[,])[j]^r(/,«) of PERs gives rise to a separated family I 
/r 
f 
I via 
Proposition 6.3.4 with 
{R} = {(i, [n]) \ i e l with E{i) ^ 0 and [n] G N / % } 
and 
\ii, M) - a', [n'])\ = {1^'" ^"1 ^ f"^ 2 ™. ^"' "^t^^"' 
This family is then orthogonal to V2: consider a morphism F in a commuting 
triangle 
( / , « ) X V2 
^ {{R},^) 
There are then codes a,b,c,d,e 
G N such that for each i G / with n G E{i) 
we have 
a n 
E F(i,0,io, [no]) n F ( i , l,ii,[ni]) 
for certain io, ii G / and [no] G N/Z^fij, [ni] G N/R[i^] 
b-n 
e 
F(fo,[no])nF(ii,[ni]). 
This yields a first projection p(6 • n) G E{io) H F(2i), so that [io] = [ii], and 
a second projection p'(6 • n) G [no] fl [ni], so that noii[io]ni. We also have 
b-n 
e 7r/?(io,[no],io) n7rH(n,[ni],ii) 
c - n 
G [TTRO 
F){i,0,io)n{7rRoF){i,l,ii) 
d • n G |i « io| n |i « i i | 
e -n G |(io,no) « ( n , n i ) | . 

714 
Chapter 11: Higher order dependent type theory 
This shows that F is constant. 
Conversely, assume 
fj 
^ I ^^ ^ separated family orthogonal to V2. 
There is by Lemma 11.7.5 an a;-set (/', E) together with an epi P\ (/', E) -^ 
(/,«). Taking the pullback along P yields a family I . / ^ . I which is sep-
\\^ ^E) J 
arated and orthogonal to V2 over an cj-set. By Proposition 6.3.3, this family 
ip corresponds to a family of a;-sets (y(j^„), £'(,• ,^)), indexed by (i, n) G /' (as 
described in the proof of Lemma 11.7.5). Thus for each (z, n) G /' we have an 
(outer) pullback square 
(y(i,„),^(,-„)) 
^ {Y,E) 
^ (X,«) 
{i,n) 
J 
{r,E) 
— ^ { L , 
f 
showing that (YJf „), £'(j^„)) is orthogonal to V2. But since we already know 
that it is separated, it is a modest set by Proposition 11.7.8 (and hence comes 
from a PER). Hence ip is isomorphic to a family of PERs over (/', E). Thus 
UFam(PER) 
the family (p that we started from is in the stack completion of 
i 
Eff 
^ 
In conclusion, there is a diagram of categories and functors over Eff, 
SepOrth(V2) 
.JET 
UFam(PER) 
FSep(Eff) C 
^ Eff^ 
UFam(u;-Sets) 
where 'sc' stands for 'stack completion'. 
Exercises 
11.7.1. Let X> be a collection of display maps (closed under pullback) in a topos B, 
with V as its stack completion. Show that for u: / —)• J in B the pullback 
functor u*:M/J -^ B// restricts to u*:V/J -^ V/L 

Completeness of the category of PERs in the effective topos 
715 
11.7.2. Let B be a topos with nucleus j and object A £ M. Prove that the fibra-
tions associated with the following collections of morphisms in B are closed 
comprehension categories, 
(i) 
Separated families, 
(ii) Families of sheaves, 
(iii) Families orthogonal to A. 
(iv) Separated families orthogonal to A. 
[Essentially, one only needs to show that these collections are closed under 
composition.] 

716 
Higher order dependent type theory 
This Page Intentionally Left Blank

References 
[l] M. Abadi and L. Cardelli. A Theory of Objects. Monographs in Comp. Sci. Springer, 
1996. 
[2] M. Abadi, L. Cardelli, and P.-L. Curien. Formal parametric polymorphism. 
Theor. 
Comp. Sci., 121:9-58, 1993. 
[3] S. Abramsky and A. Jung. Domain theory. In S. Abramsky, Dov M. Gabbai, and 
T.S.E. Maibaum, editors. Handbook of Logic in Computer Science, volume 3, pages 
1-168. Oxford Univ. Press, 1994. 
[4] Th. Altenkirch. Constructions, 
Inductive 
Types and Strong Normalization. 
PhD 
thesis, Univ. Edinburgh, 1993. Techn. rep. LFCS-93-279. 
[5] Th. Altenkirch, M. Hofmann, and Th. Streicher. Categorical reconstruction of a re-
duction free normalization proof. In D.H. Pitt, D.E. Rydeheard, and P.T. Johnstone, 
editors. Category Theory and Computer Science, number 953 in Lect. Notes Comp. 
Sci., pages 182-199. Springer, BerHn, 1995. 
[6] M.A. Arbib and E.G. Manes. Parametrized data types do not need highly constrained 
parameters. Inf. & Contr., 52:139-158, 1982. 
[7] A. Asperti. Categorical Topics in Computer Science. PhD thesis, Univ. Pisa, 1985. 
Techn. Rep. 7/90. 
[8] A. Asperti and S. Martini. Categorical models of polymorphism. Inf. & Comp., 
99:1-79, 1992. 
[9] K. Baclawski, D. Simovici, and W. White. A categorical approach to database se-
mantics. Math. Struct, in Comp. Sci., 4:147-183, 1994. 
[10] E.S. Bainbridge. A unified minimal realization theory with duality. PhD thesis, Univ. 
Michigan, Ann Arbor, 1972. Techn. rep. 140, Dep. of Comp. and Comm. Sci. 
[11] E.S. Bainbridge, P.J. Freyd, A. Scedrov, and P.J. Scott. Functorial polymorphism. 
Theor. Comp. Sci., 70(l):35-64, 1990. Corrigendum in Theor. Comp. Sci. 71(3):431, 
1990. 
[12] R. Banach. Term graph rewriting and garbage collection using opfibrations. Theor. 
Comp. Sci., 131(l):29-94, 1994. 
[13] H.P. Barendregt. The Lambda Calculus. Its Syntax and Semantics. 
North-Holland, 
Amsterdam, 2"*^ rev. edition, 1984. 
717 

718 
References 
[14] H.P. Barendregt. Lambda calculi with types. In S. Abramsky, Dov M. Gabbai, and 
T.S.E. Maibaum, editors, Handbook of Logic in Computer Science, volume 2, pages 
117-309. Oxford Univ. Press, 1992. 
[15] H.P. Barendregt and A. Rezus. Semantics for classical AUTOMATH and related 
systems. Inf & Contr,, 59:127-147, 1983. 
[16] M. Barr. Fixed points in cartesian closed categories. Theor. Comp. Sci., 70:65-72, 
1990. 
[17] M. Barr, P.A. Grillet, and D.H. van Osdol. Exact Categories and Categories of 
Sheaves. Number 236 in Lect. Notes Math. Springer, Berlin, 1971. 
[18] M. Barr and Ch. Wells. Toposes, Triples and Theories. Springer, Berlin, 1985. 
[19] M. Barr and Ch. Wells. Category Theory for Computing Science. Prentice Hall, 1990. 
[20] B. Barras, S. Boutin, C. Cornes, J. Courant, J.-Chr. Filliatre, E. Gimenez, H. Her-
belin, G. Huet, C. Muiioz, C. Murthy, C. Parent, C. Paulin-Mohring, A. SaVbi, and 
B. Werner. The Coq Proof Assistant User's Guide Version 6.1. Technical Report 203, 
INRIA Rocquencourt, France, May 1997. 
[21] G. Barthe. Extensions of pure type systems. In M. Dezani-Ciancaglini and G. Plotkin, 
editors. Typed Lambda Calculi and Applications, 
number 902 in Lect. Notes Comp. 
Sci., pages 16-31. Springer, Berlin, 1995. 
[22] G. Barthe. 
The relevance of proof-irrelevance. 
In K. Larsen, S. Skyum, and 
G. Winskel, editors. International 
Colloquium on Automata, 
Languages and Pro-
gramming, number 1443 in Lect. Notes Comp. Sci., pages 755-768. Springer, Berlin, 
1998. 
[23] M.J. Beeson. Foundations 
of Constructive 
Mathem,atics. 
Springer, Berlin, 1985. 
[24] J.L. Bell. Toposes and Local Set Theories. An Introduction. 
Number 14 in Logic 
Guides. Oxford Science Publ., 1984. 
[25] G. Belle and E. Moggi. Typed intermediate languages for shape analysis. In Ph. 
de Groote and J.R. Hindley, editors. Typed Lambda Calculi and Applications, 
number 
1210 in Lect. Notes Comp. Sci., pages 11-29. Springer, Berlin, 1997. 
[26] R. Belluci, M. Abadi, and P.-L. Curien. A model for formal parametric polymorphism: 
Per interpretation for system V. In M. Dezani-Ciancaglini and G. Plotkin, editors. 
Typed Lambda Calculi and Applications, number 902 in Lect. Notes Comp. Sci., pages 
32-46. Springer, Berlin, 1995. 
[27] J. Benabou. 
Fibrations petites et localement petites. 
C. R. Acad. Sc. 
Paris, 
281:A897-A900, 1975. 
[28] J. Benabou. Theories relatives a un corpus. C. R. Acad. Sc. Paris, 281:A831-A834, 
1975. 
[29] J. Benabou. Fibered categories and the foundations of naive category theory. Journ. 
Symb. Logic, 50(l):10-37, 1985. 
[30] J. Benabou and J. Roubaud., Monades et descente. C. R. Acad. Sc. Paris, 270:A96-
A98, 1970. 
[31] S. Berardi. An application of PER models to program extraction. Math. Struct, 
in 
Comp. Sci., pages 309-331, 1993. 
[32] I. Bethke. Notes on Partial Combinatory 
Algebras. PhD thesis, Univ. Amsterdam, 
1988. 
[33] L. Birkedal, A. Carboni, G. Rosolini, and D.S. Scott. Type theory via exact categories. 
extended abstract. In Logic in Computer Science, pages 188-198. IEEE, Computer 
Science Press, 1998. 
[34] G. Birkhoff and J.D. Lipson. Heterogenuous algebras. Journ. Combinatorial 
Theory, 
8:115-133, 1970. 

References 
719 
[35] C. Bohm and A. Berarducci. Automatic synthesis of typed A-programs on term 
algebras. Theor. Comp. Set., 39:135-154, 1985. 
[36] F. Borceux. Handbook of Categorical Algebra, volume 50, 51 and 52 of Encyclopedia 
of Mathematics. 
Cambridge Univ. Press, 1994. 
[37] V. Breazu-Tannen and Th. Coquand. Extensional models for polymorphism. Theor. 
Comp. Sci., 59:85-114, 1988. 
[38] K.B. Bruce, A.R. Meyer, and J.C. Mitchell. The semantics of second-order lambda 
calculus. Inf & Comp., 85:76-134, 1990. 
[39] M. Bunge and R. Pare. Stacks and equivalence of indexed categories. Cah. de Top. 
et Geom. Diff., XX:404-436, 1979. 
[40] R. Burstall and J. McKinna. Deliverables: an approach to program development in 
the calculus of constructions. In G. Huet and G. Plotkin, editors. Logical 
Frameworks, 
pages 113-121. Cambridge Univ. Press, 1991. 
[41] A. Carboni, P.J. Freyd, and A. Scedrov. A categorical approach to realizability and 
polymorphic types. In M. Main, A. Melton, M. Mislove, and D. Schmidt, editors. 
Mathematical Foundations of Programming Language Semantics, number 298 in Lect. 
Notes Comp. Sci., pages 23-42. Springer, Berlin, 1988. 
[42] A. Carboni, S. Lack, and R.F.C. Walters. Introduction to extensive and distributive 
categories. Journ. Pure & AppL Algebra, 84(2):145-158, 1993. 
[43] L. Cardelli and G. Longo. A semantic basis for Quest. Journ. Funct. Progr., 1:417-
458, 1991. 
[44] L. Cardelli and P. Wegner. On understanding types, data abstraction and polymor-
phism. ACM Comp. Surv., 4:471-522, 1985. 
[45] J. Cartmell. Generalized algebraic theories and contextual categories. 
PhD thesis, 
Univ. Oxford, 1978. 
[46] J. Cartmell. Generalised algebraic theories and contextual categories. Ann. Pure & 
Appl. Logic, 32:209-243, 1986. 
[47] J. Celeyrette. Categories internes et fibrations. PhD thesis, Univ. Paris-Nord, 1975. 
[48] M. Cerioli and J. Meseguer. May I borrow your logic? (transporting logical structures 
along maps). Theor. Comp. Sci., 173:311-347,1997. 
[49] A. Church. A formulation of the simple theory of types. Journ. Sym.b. Logic, 5:56-68, 
1940. 
[50] J.R.B. Cockett. List-arithmetic distributive categories: locoi. Journ. Pure & Appl. 
Algebra, 66:1-29, 1990. 
[51] J.R.B. Cockett. Introduction to distributive categories. Math. Struct, in Comp. 
Sci., 
3:277-307, 1993. 
[52] J.R.B. Cockett and D. Spencer. Strong categorical datatypes I. In R.A.G. Seely, 
editor, Category Theory 1991, number 13 in CMS Conference Proceedings, pages 
141-169, 1992. 
[53] J.R.B. Cockett and D. Spencer. Strong categorical datatypes II: A term logic for 
categorical programming. Theor. Comp. Sci., 139:69-113, 1995. 
[54] Th. Coquand. An analysis of Girard's paradox. In Logic in Computer Science, pages 
227-236. IEEE, Computer Science Press, 1986. 
[55] Th. Coquand. Metamathematical investigations of a calculus of constructions. In 
P. Odifreddi, editor. Logic and computer 
science, pages 91-122. Academic Press, 
London, 1990. The APIC series, vol. 31. 
[56] Th. Coquand and Th. Ehrhard. An equational presentation of higher order logic. In 
D.H. Pitt, A. Poigne, and D.E. Rydeheard, editors. Category and Computer 
Science, 
number 283 in Lect. Notes Comp. Sci., pages 40-56. Springer, Berlin, 1987. 

720 
References 
[57] Th. Coquand, C. Gunter, and G. Winskel. Domain theoretic models of polymorphism. 
Inf, & Comp., 81:123-167, 1989. 
[58] Th. Coquand and G. Huet. The calculus of constructions. Inf. & Comp., 76(2/3):95-
120, 1988. 
[59] Th. Coquand and Ch. Paulin. 
Inductively defined types. In P. Martin-L6f and 
G. Mints, editors, COLOG 88 International 
conference on computer logic, number 
417 in Lect. Notes Comp. Sci., pages 50-66. Springer, Berlin, 1988. 
[60] R.L. Crole. Programming 
metalogics with a fixpoint type. PhD thesis, Univ. Cam-
bridge, 1992. Comp. Lab. Techn. Rep. 247. 
[61] R.L. Crole. Categories for Types. Cambridge Mathematical Textbooks. Cambridge 
Univ. Press, 1993. 
[62] P.-L. Curien. Alpha-conversion, conditions on variables and categorical logic. Studia 
Logica, XLVIII 3:319-360, 1989. 
[63] P.-L. Curien. Categorical Comhinators, 
Sequantial Algorithms 
and Functional 
Pro-
grannming. Progress in Theor. Comp. Sci. Birkhauser, Boston, 1993. 
[64] P.-L. Curien and R. di Cosmo. A confluent reduction for the lambda-calculus with 
surjective pairing and terminal object. Journ. Funct. Progr., 6(2):299-327, 1996. 
[65] H.B. Curry and R. Keys. Combinatory 
Logic. North-Holland, Amsterdam, 1958. 
[66] N.J. Cutland. Computability. 
Cambridge Univ. Press, 1980. 
[67] D. van Dalen. Logic and structure. Springer, Berlin, 2"*^ edition, 1983. 
[68] L. Damas and R. Milner. Principal type-schemes for functional programs. In Princi-
ples of Programming 
Languages. ACM Press, 1982. 
[69] B.A. Davey and H.A. Priestley. Introduction 
to Lattices and Order. Math. Textbooks. 
Cambridge Univ. Press, 1990. 
[70] P. Dybjer. Inductive sets and families in Martin-L6f's type theory and their set-
theoretic semantics. In G. Huet and G. Plotkin, editors. Logical Frameworks, pages 
280-306. Cambridge Univ. Press, 1991. 
[71] P. Dybjer. Inductive families. Formal Aspects of Comp., 6:440-465, 1994. 
[72] P. Dybjer. Internal type theory. In S. Berardi and M. Coppo, editors, Types for Proofs 
and Programs, number 1158 in Lect. Notes Comp. Sci., pages 120-134. Springer, 
Berlin, 1996. 
[73] P. Dybjer. Representing inductively defined sets by wellorderings in Martin-Lof's 
type theory. Theor. Comp. Sci., 179:329-335, 1997. 
[74] Th. Ehrhard. A categorical semantics of constructions. In Logic in Computer 
Science, 
pages 264-273. IEEE, Computer Science Press, 1988. 
[75] Th. Ehrhard. 
line semantique 
categorique des types dependants: 
Application 
au 
Calcul des Constructions. 
PhD thesis, Universite Paris VII, 1988. 
[76] Th. Ehrhard. Dictoses. In D.H. Pitt, A. Poigne, and D.E. Rydeheard, editors, Cat-
egory Theory and Computer Science, number 389 in Lect. Notes Comp. Sci., pages 
213-223. Springer, Berlin, 1989. 
[77] H. Ehrig and B. Mahr. Fundamentals 
of Algebraic Specification I: Equations 
and 
Initial Semantics. 
Number 6 in EATCS Monographs. Springer, Berlin, 1985. 
[78] R.L. Constable et al. Implementing 
Mathematics 
with the Nuprl Proof 
Development 
System. Prentice Hall, 1986. 
[79] M.P. Fiore. A coinduction principle for recursive data types based on bisimulation. 
Inf. & Comp., 127(2):186-198, 1996. 
[80] M.P. Fourman and D.S. Scott. Sheaves and logic. In M.P. Fourman and C.J. Mul-
vey D.S. Scott, editors. Applications 
of Sheaves, number 753 in Lect. Notes Math., 
pages 302-401. Springer, Berlin, 1979. 

References 
721 
[81] P. Freyd, Ph. Mulry, G. Rosolini, and D. Scott. Extensional PERs. Inj. & Comp., 
98(2):211-227, 1992. 
[82] P.J. Freyd, editor. Abelian Categories: An Introduction 
to the Theory of Functors. 
Harper and Row, New York, 1964. 
[83] P.J. Freyd. Aspects of topoi. BulL Austr. Math. Soc, 7:1-76 and 467-480, 1972. 
[84] P.J. Freyd. Structural polymorphism. Theor. Comp. Sci., 115:107-129, 1993. 
[85] P.J. Freyd and A. Scedrov. Categories, Allegories. 
Number 39 in Math. Library. 
North-Holland, Amsterdam, 1990. 
[86] Y. Fu. Topics in Type Theory. 
PhD thesis, Univ. Manchester, 1992. Techn. rep. 
92-11-1. 
[87] Y. Fu. Categorical properties of logical frameworks. Math. Struct, in Comp. 
Sci., 
7:1-47, 1997. 
[88] J.R. Funk. Descent for Cocomplete Categories. PhD thesis, McGill Univ. Montreal, 
1990. 
[89] Ph. Gardner. Representing 
Logics in Type Theory. 
PhD thesis, Univ. Edinburgh, 
1992. Tech. Rep. 93-92. 
[90] J.H. Geuvers. The Church-Rosser property for /3?7-reduction in typed lambda calculi. 
In Logic in Computer Science, pages 453-460. IEEE, Computer Science Press, 1992. 
[91] J.H. Geuvers. Logics and Type Systems. 
PhD thesis, Univ. Nijmegen, 1993. 
[92] J.H. Geuvers and M.-J. Nederhof. A modular proof of strong normalization for the 
calculus of constructions. Journ. Funct. Progr., 1(2):155-189, 1991. 
[93] S. Ghilardi and G.C. Meloni. Modal and tense predicate logic: models in presheaves 
and categorical conceptualization. In F. Borceux, editor, Categorical Algebra and its 
Applications, 
number 1348 in Lect. Notes Math., pages 130-142. Springer, Berlin, 
1988. 
[94] J.-Y. Girard. Une extension de I'interpretation de Godel a I'analyse et son appli-
cation a I'elimination des coupures dans I'analyse et la theorie des types. In J.E. 
Fenstad, editor. Proceedings of the 2nd Scandinavian 
Logic Symposium, 
pages 63-92, 
Amsterdam, 1971. North-Holland. 
[95] J.-Y. Girard. Interpretation 
fonctionelle 
et elimination 
des coupures dans Varith-
metique d'ordre superieur. PhD thesis, Universite Paris VII, 1972. 
[96] J.-Y. Girard. The system F of variable types, 15 years later. Theor. Comp. 
Sci., 
45:159-192, 1986. 
[97] J.-Y. Girard. Linear logic. Theor. Comp. Sci., 50:1-102, 1987. 
[98] J.-Y. Girard. Proofs and types. Number 7 in Tracts in Theor. Comp. Sci. Cambridge 
Univ. Press, 1989. 
[99] J.-Y. Girard, A. Scedrov, and P.J. Scott. Normal forms and cut-free proofs as nat-
ural transformations. In Y.N. Moschovakis, editor, Logic from Computer 
Science, 
number 21 in Math. Sci. Research Inst. Publ., pages 217-241. Springer, 1992. 
[100] J. Giraud. Cohomologie non abelienne. Springer, Berlin, 1971. 
[101] J.A. Goguen, J. Thatcher, and E. Wagner. An initial algebra approach to the spec-
ification, correctness and implementation of abstract data types. In R. Yeh, editor. 
Current Trends in Programm,ing Methodology, pages 80-149. Prentice Hall, 1978. 
[102] R. Goldblatt. Topoi. The Categorial Analysis of Logic. North-Holland, Amsterdam, 
2"^ rev. edition, 1984. 
[103] R. Goldblatt. Mathematics 
of Modality. CSLI Lecture Notes 43, Stanford, 1993. 
[104] M.J.C. Gordon and T.F. Melham. Introduction 
to HOL: A theorem proing 
environ-
ment for higher order logic. Cambridge Univ. Press, 1993. 
[105] J.W. Gray. Fibred and cofibred categories. In Proc. Conf. on Categorical Algebra. 

722 
References 
LaJolla 1965, pages 21-83. Springer, Berlin, 1966. 
106] J.W. Gray. The categorical comprehension scheme. In P. Hilton, editor. Category 
Theory, Homology Theory and their Applications III, number 99 in Lect. Notes Math., 
pages 242-312. Springer, Berlin, 1969. 
107] A. Grothendieck. Categories fibrees et descente (Expose VI). In A. Grothendieck, 
editor, Revetement 
Etales et Groupe Fondamental 
(SGA 1), number 224 in Lect. 
Notes Math., pages 145-194. Springer, Berlin, 1970. 
108] C.A. Gunter. Semantics 
of Programm,ing Languages. Structures and Techniques. The 
MIT Press, Cambridge, MA, 1992. 
109] C.A. Gunter and J.C. Mitchell, editors. Theoretical Aspects of Object-Oriented 
Pro-
gramming. 
Types, Semantics 
and Language Design. The MIT Press, Cambridge, MA, 
1994. 
llOl T. Hagino. A categorical programming language. PhD thesis, Univ. Edinburgh, 1987. 
Techn. Rep. 87/38. 
Ill] T. Hagino. A typed lambda calculus with categorical type constructors. In D.H. Pitt, 
A Poigne, and D.E. Rydeheard, editors, Category and Computer Science, number 
283 in Lect. Notes Comp. Sci., pages 140-157. Springer, Berlin, 1987. 
112] T. Hagino. Codatatypes in ML. Journ. Symb. Computation, 
8:629-650,1989. 
113] K. Hanna, N. Daeche, and G. Howells. Implementation of the Veritas design logic. 
In V. Stavridou, T.F. Melham, and R.T. Boute, editors. Theorem Provers in Circuit 
Design, IFIP Transactions A, pages 77-94. North Holland, 1992. 
114] K. Hanna, N. Daeche, and M. Longley. Specification and verification using dependent 
types. In Trans, on Softw. Eng. 9, number 16, pages 949-964, 1990. 
115] R. Harper, F. Honsell, and G.D. Plotkin. A framework for defining logics. 
Journ. 
ACM, 40(1):143-184, 1992. 
116] M. Hasegawa. Decomposing typed lambda calculus into a couple of categorical pro-
gramming languages. In D.H. Pitt, D.E. Rydeheard, and P.T. Johnstone, editors, 
Category Theory and Computer 
Science, number 953 in Lect. Notes Comp. Sci., 
pages 200-219. Springer, Berlin, 1995. 
117] R. Hasegawa. Parametricity of extensionally collapsed models of polymorphism and 
their categorical properties. In T. Ito and A.R. Meyer, editors, Theoretical Aspects of 
Computer Software, number 526 in Lect. Notes Comp. Sci., pages 495-512. Springer, 
Berlin, 1991. 
118] R. Hasegawa. Categorical data types in parametric polymorphism. Math. Struct, 
in 
Comp. Sci., 4:71-109, 1994. 
119] S. Hayashi. 
Adjunction of semifunctors: categorical structures in nonextensional 
lambda calculus. Theor. Comp. 5ci., 41:95-104, 1985. 
120] S. Hayashi. Logic of refinement types. In H. Barendregt and T. Nipkow, editors. 
Types for Proofs and Programs, number 806 in Lect. Notes Comp. Sci., pages 108-
126. Springer, Berlin, 1994. 
121] L. Henkin, J.D. Monk, and A. Tarski. Cylindric Algebras. North-Holland, Amsterdam, 
1971/1985. 2 volumes. 
122] U. Hensel. Proof Principles for Categorical Datatypes. PhD thesis, Univ. of Dresden, 
Germany, 1998. 
123] U. Hensel, M. Huisman, B. Jacobs, and H. Tews. Reasoning about classes in object-
oriented languages: Logical models and tools. In Ch. Hankin, editor, European 
Sym-
posium, on Programming, 
number 1381 in Lect. Notes Comp. Sci., pages 105-121. 
Springer, Berlin, 1998. 
[124] U. Hensel and B. Jacobs. Proof principles for datatypes with iterated recursion. In 

References 
723 
E. Moggi and G, Rosolini, editors, Category Theory and Computer Science, number 
1290 in Lect. Notes Comp. Sci., pages 220-241. Springer, Berlin, 1997. 
[125] C. Hermida. Fibrations, 
Logical Predicates and Indeterminates. 
PhD thesis, Univ. 
Edinburgh, 1993. Techn. rep. LFCS-93-277. Also available as Aarhus Univ. DAIMI 
Techn. rep. PB-462. 
[126] C. Hermida. On fibred adjunctions and completeness for fibred categories. In H. Ehrig 
and F. Orejas, editors. Recent Trends in Data Type Specification, number 785 in Lect. 
Notes Comp. Sci., pages 235-251. Springer, Berlin, 1994. 
[127] C. Hermida. Some properties of Fib as a fibred 2-category. Journ. Pure & AppL 
Algebra, 1998, to appear. 
[128] C. Hermida and B. Jacobs. An algebraic view of structural induction. In L. Pacholski 
and J. Tiuryn, editors, Computer 
Science Logic 1994, number 933 in Lect. Notes 
Comp. Sci., pages 412-426. Springer, Berlin, 1995. 
[129] C. Hermida and B. Jacobs. Fibrations with indeterminates: Contextual and functional 
completeness for polymorphic lambda calculi. Math. Struct, in Comp. Sci., 5:501-
531, 1995. 
[130] C. Hermida and B. Jacobs. Structural induction and coinduction in a 
fibrational 
setting. Inf. & Comp., 1998, to appear. 
[131] C. Hermida and J. Power. Fibrational control structures. In I. Lee and S.A. Molka, 
editors, Concur^95: Concurrency 
Theory, number 962 in Lect. Notes Comp. Sci., 
pages 117-129. Springer, Berlin, 1995. 
[132] M. Hofmann. Elimination of extensionality and quotient types in Martin-L6f type 
theory. In H. Barendregt and T. Nipkow, editors. Types for Proofs and Programs, 
number 806 in Lect. Notes Comp. Sci., pages 166-190. Springer, Berlin, 1994. 
[133] M. Hofmann. Extensional 
concepts in intensional 
type theory. 
PhD thesis, Univ. 
Edinburgh, 1995. Techn. rep. LFCS-95-327. 
[134] M. Hofmann. On the interpretation of type theory in locally cartesian closed cate-
gories. In L. Pacholski and J. Tiuryn, editors. Computer Science Logic 1994, number 
933 in Lect. Notes Comp. Sci., pages 427-441. Springer, Berlin, 1995. 
[135] M. Hofmann. 
A simple model for quotient types. In M. Dezani-Ciancaglini and 
G. Plotkin, editors. Typed Lambda Calculi and Applications, 
number 902 in Lect. 
Notes Comp. Sci., pages 216-234. Springer, Berlin, 1995. 
[136] M. Hofmann. Conservativity of equality reflection over intensional type theory. In 
S. Berardi and M. Coppo, editors. Types for Proofs and Programs, number 1158 in 
Lect. Notes Comp. Sci., pages 153-164. Springer, Berlin, 1996. 
[137] M. Hofmann. Syntax and semantics of dependent types. In P. Dybjer and A. Pitts, 
editors. Semantics 
of Logics of Computation, 
pages 79-130. Cambridge Univ. Press, 
1997. 
[138] M. Hofmann and B.C. Pierce. A unifying type-theoretic framework for objects. Journ. 
Funct. Progr., 5(4):593-635, 1995. 
[139] M. Hofmann and Th. Streicher. A groupoid model refutes uniqueness of identity 
proofs. In Logic in Computer Science, pages 208-212. IEEE, Computer Science Press, 
1994. 
[140] W.A. Howard. The formulae-as-types notion of construction. In J.R. Hindley and 
J.P. Seldin, editors, To H.B Curry: Essays on Combinatory 
Logic, Lambda 
Calculus 
and Formalism, pages 479-490. Academic Press, New York and London, 1980. 
[141] A.J.C. Hurkens. A simplification of Girard's paradox. In M. Dezani-Ciancaglini and 
G. Plotkin, editors, Typed Lambda Calculi and Applications, 
number 902 in Lect. 
Notes Comp. Sci., pages 266-278. Springer, Berlin, 1995. 

724 
References 
[142] J.M.E. Hyland. The effective topos. In A.S. Troelstra and D. van Dalen, editors, The 
L.E.J. Brouwer centenary symposium, 
pages 165-216. North-Holland, Amsterdam, 
1982. 
[143] J.M.E. Hyland. A small complete category. Ann. Pure & Appl. Logic, 40:135-165, 
1988. 
[144] J.M.E. Hyland. First steps in synthetic domain theory. In A. Carboni, M.C. Pedicchio, 
and G. Rosolini, editors, Como Conference on Category Theory, number 1488 in Lect. 
Notes Math., pages 131-156. Springer, Berlin, 1991. 
[145] J.M.E. Hyland, P.T. Johnstone, and A.M. Pitts. Tripos theory. Math. Proc. Cam-
bridge Phil. Soc, 88:205-232, 1980. 
[146] J.M.E. Hyland and E. Moggi. The 5-replete construction. In D.H. Pitt, D.E. Ryde-
heard, and P.T. Johnstone, editors. Category Theory and Computer Science, number 
953 in Lect. Notes Comp. Sci., pages 96-116. Springer, Berlin, 1995. 
[147] J.M.E. Hyland and C.-H.L. Ong. Modified realizability toposes and strong normal-
ization proofs. In M. Bezem and J.F. Groote, editors. Typed Lambda Calculi and 
Applications, 
number 664 in Lect. Notes Comp. Sci., pages 179-194. Springer, Berlin, 
1993. 
[148] J .M.E. Hyland and A.M. Pitts. The theory of constructions: categorical semantics and 
topos-theoretic models. In J. Gray and A. Scedrov, editors, Categories in 
Computer 
Science and Logic, number 92 in AMS Contemp. Math., pages 137-199, Providence, 
1989. 
[149] J.M.E. Hyland, E.P. Robinson, and G. Rosolini. Algebraic types in PER models. In 
M. Main, A. Melton, M; Mislove, and D. Schmidt, editors. Mathematical 
Foundations 
of Programm,ing Language Semantics, number 442 in Lect. Notes Comp. Sci., pages 
333-350. Springer, Berlin, 1990. 
[150] J.M.E. Hyland, E.P. Robinson, and G. Rosolini. The discrete objects in the effective 
topos. Proc. London Math. Soc, 60:1-36, 1990. 
[151] A. Islam and W. Phoa. 
Categorical models of relational databases I: fibrational 
formulation, schema integration. In M. Hagiya and J.C. Mitchell, editors, Theoretical 
Aspects of Computer Science, number 789 in Lect. Notes Comp. Sci., pages 618-641. 
Springer, Berlin, 1994. 
[152] J.A Goguen and R. Burstall. Institutions: Abstract model theory for specification 
and programming. Journ. ACM, 39(1):95-146, 1992. 
[153] B. Jacobs. The inconsistency of higher order extensions of Martin-L6f's type theory. 
Journ. Phil. Logic, 18:399-422, 1989. 
[154] B. Jacobs. Categorical Type Theory. PhD thesis, Univ. Nijmegen, 1991. 
[155] B. Jacobs. Semantics of the second order lambda calculus. Math. Struct, in Comp. 
Sci., l(3):327-360, 1991. 
[156] B. Jacobs. Simply typed and untyped lambda calculus revisited. In M.P. Fourman, 
P.T. Johnstone, and A.M. Pitts, editors. Applications 
of Categories in 
Computer 
Science, number 177 in LMS, pages 119-142. Cambridge Univ. Press, 1992. 
[157] B. Jacobs. Comprehension categories and the semantics of type dependency. Theor. 
Comp. Sci., 107:169-207, 1993. 
[158] B. Jacobs. Semantics of lambda-I and of other substructure lambda calculi. 
In 
M. Bezem and J.F. Groote, editors, Typed Lambda Calculi and Applications, 
number 
664 in Lect. Notes Comp. Sci., pages 195-208. Springer, Berlin, 1993. 
[159] B. Jacobs. Mongruences and cofree coalgebras. In V.S. Alagar and M. Nivat, editors. 
Algebraic Methodology and Software Technology, number 936 in Lect. Notes Comp. 
Sci., pages 245-260. Springer, Berlin, 1995. 

References 
725 
[160] B. Jacobs. Parameters and parametrization in specification using distributive cate-
gories. Fund. Informaticae, 
24(3):209-250, 1995. 
[161] B. Jacobs. 
Subtypes and bounded quantification from a fibred perspective. 
In 
S. Brookes, M. Main, A. Melton, and M. Mislove, editors. Mathematical 
Founda-
tions of Program Semantics, number 1 in Elect. Notes in Theor. Comp. Sci. Elsevier, 
Amsterdam, 1995. 
[162] B. Jacobs. 
Objects and classes, co-algebraically. 
In B. Freitag, C.B. Jones, 
C. Lengauer, and H.-J. Schek, editors. Object-Orientation 
with Parallelism and Per-
sistence, pages 83-103. Kluwer Acad. Publ., 1996. 
[163] B. Jacobs. On cubism. Journ. Fund. Progr., 6:379-391, 1996. 
[164] B. Jacobs. Invariants, bisimulations and the correctness of coalgebraic refinements. 
In M. Johnson, editor, Algebraic Methodology and Software Technology, number 1349 
in Lect. Notes Comp. Sci., pages 276-291. Springer, Berlin, 1997. 
[165] B. Jacobs and T. Melham. Translating dependent type theory into higher order 
logic. In M. Bezem and J.F. Groote, editors. Typed Lambda Calculi and 
Applications, 
number 664 in Lect. Notes Comp. Sci., pages 209-229. Springer, Berlin, 1993. 
[166] B. Jacobs, E. Moggi, and Th. Streicher. Relating models of impredicative type theo-
ries. In D.H. Pitt et al., editor, Category and Computer Science, number 530 in Lect. 
Notes Comp. Sci., pages 197-218. Springer, Berlin, 1991. 
[167] B. Jacobs and J. Rutten. A tutorial on (co)algebras and (co)induction. 
EATCS 
Bulletin, 62:222-259, 1997. 
[168] G. Janelidze and W. Tholen. Facets of descent, I. Appl. Categorical Struct., 2:245-
281, 1994. 
[169] P.T. Johnstone. Topos Theory. Academic Press, London, 1977. 
[170] P.T. Johnstone. Stone Spaces. Number 3 in Cambridge Studies in Advanced Mathe-
matics. Cambridge Univ. Press, 1982. 
[171] P.T. Johnstone. Fibrations and partial products in a 2-category. Appl. 
Categorical 
Struct., 1:141-179, 1993. 
[172] P.T. Johnstone. Cartesian monads on a topos. Journ. Pure & Appl. Algebra, 116:199-
220, 1997. 
[173] P.T. Johnstone and R. Pare, editors. Indexed 
Categories and their 
Applications. 
Number 661 in Lect. Notes Math. Springer, Berlin, 1978. 
[174] A. Joyal and M. Tierney. An extension of the Galois theory of Grothendieck. Memoirs 
of the AMS, 51(309-4), 1984. 
[175] S. Kasangian, G.M. Kelly, and F. Rossi. Cofibrations and the realization of non-
deterministic automata. Cah. de Top. et Geom. Diff., XXIV:23-46, 1983. 
[176] G.M. Kelly and R. Street. Review of the elements of 2-categories. In G.M. Kelly, 
editor, Proc. Sydney Category Theory Seminar 1972/1973, number 420 in Lect. Notes 
Math., pages 75-103. Springer, Berlin, 1974. 
[177] R.E. Kent. The metric closure powerspace construction. In M. Main, A. Melton, 
M. Mislove, and D. Schmidt, editors, Mathematical 
Foundations 
of Progranfiming 
Language Semantics, number 442 in Lect. Notes Comp. Sci., pages 173-199. Springer, 
Berlin, 1990. 
[178] S.C. Kleene. On the interpretation of intuitionistic number theory. Journ. 
Symb. 
Logic, 10:109-124, 1945. 
[179] A. Kock. Algebras for the partial map classifier monad. In A. Carboni, M.C. Pedic-
chio, and G. Rosolini, editors, Como Conference on Category Theory, number 1488 
in Lect. Notes Math., pages 262-278. Springer, Berlin, 1991. 
[180] A. Kock. Monads for which structures are adjoint to units. Journ. Pure & Appl. 

726 
References 
Algebra, 104:41-59, 1995. 
[181] K. Koymans. Models of the Lambda Calculus. PhD thesis, Univ. Utrecht, 1984. Also 
available as: CWI Tracts 9, Amsterdam. 
[182] S.A. Kripke. Semantical analysis of intuitionistic logic. In J. Crossley and M.A.E. 
Dummett, editors, Formal Systems and Recursive Functions, pages 92-130, Amster-
dam, 1965. North-Holland. 
[183] Y. Lafont. Logiques, Categories et Machines. PhD thesis, Univ. Paris VII, 1988. 
[184] Y. Lafont and Th. Streicher. Game semantics for linear logic. In Logic in 
Computer 
Science, pages 43-50. IEEE, Computer Science Press, 1991. 
[185] F. Lamarche. Modelling Polymorphism 
with Categories. PhD thesis, McGill Univ., 
Montreal, 1991. 
[186] J. Lambek and P.J. Scott. Introduction 
to higher order Categorical Logic. Number 7 
in Cambridge Studies in Advanced Mathematics. Cambridge Univ. Press, 1986. 
[187] S. Mac Lane. Categories for the Working Mathematician. 
Springer, Berlin, 1971. 
[188] S. Mac Lane and I. Moerdijk. Sheaves in Geometry and Logic. A First 
Introduction 
to Topos Theory. Springer, New York, 1992. 
[189] S. Mac Lane and R. Pare. Coherence for bicategories and indexed categories. Journ. 
Pure & AppL Algebra, 37:59-80, 1985. 
[190] S. Lang. Algebra. Addison Wesley, 2"^ rev. edition, 1984. 
[191] F.W. Lawvere. Functorial semantics. Proc. Nat. Acad. Sci. USA, 50:869-872, 1963. 
[192] F.W. Lawvere. Ajointness in foundations. Dialectica, 23:281-296, 1969. 
[193] F.W. Lawvere. Equality in hyperdoctrines and comprehension scheme as an adjoint 
functor. In A. Heller, editor, Applications 
of Categorical Algebra, pages 1-14, Provi-
dence, 1970. AMS. 
[194] F.W. Lawvere. Metric spaces, generalized logic, and closed categories. 
Seminario 
Matematico 
e Fisico. Rendiconti 
di Milano, 43:135-166, 1973. 
[195] F. Leclerc and Ch. Paulin-Mohring. Programming with streams in Coq. A case study: 
the sieve of Eratosthenes. In H. Barendregt and T. Nipkow, editors, Types for Proofs 
and Programs, number806 in Lect. Notes Comp. Sci., pages 191-212. Springer, Berlin, 
1994. 
[196] D. Leivant. Reasoning about functional programs and complexity classes associated 
with type discipline. In Found. Comp. Sci., pages 460-469. IEEE, 1983. 
[197] R. Loader. Equational theories for inductive types. Ann. Pure & Appl. Logic, 84:175-
217, 1997. 
[198] J.R. Longley. Realizability Toposes and Language Semantics. 
PhD thesis, Edinburgh 
Univ., 1994. 
[199] G. Longo and E. Moggi. Constructive natural deduction and its 'u;-set' interpretation. 
Math. Struct, in Comp. Sci., l(2):215-254, 1991. 
[200] Z. Luo. ECC the Extended Calculus of Constructions. In Logic in Computer 
Science, 
pages 386-395. IEEE, Computer Science Press, 1989. 
[201] Z. Luo. Program specification and data refinement in type theory. Math. Struct, 
in 
Comp. Sci., 3(3):333-363, 1993. 
[202] Z. Luo. Computation 
and Reasoning. A Type Theory for Computer Science. Claren-
don Press, Oxford, 1994. 
[203] Z. Luo and R. Pollack. LEGO proof development system: User's manual. Techn. rep. 
LFCS-92-211, Univ. Edinburgh, 1992. 
[204] Q. Ma and J. Reynolds. Types, abstraction, and parametric polymorphism. Part 2. In 
M. Mislove S. Brookes, M. Main and D. Schmidt, editors. Mathematical 
Foundations 
of Program Semantics, 
number 598 in Lect. Notes Comp. Sci., pages 1-40. Springer, 

References 
727 
Berlin, 1992. 
[205] D.B. MacQueen. Using dependent types to express modular structure. In 
Principles 
of Programming 
Languages, pages 277-286. ACM Press, 1986. 
[206] D.B. MacQueen, R. Sethi, and G. Plotkin. An ideal model for recursive types. Inf. 
& Contr., 71:95-130, 1986. 
[207] L. Magnusson and B. Nordstrom. The ALF proof editor and its proof engine. In 
H. Barendregt and T. Nipkow, editors. Types for Proofs and Programs, number 806 
in Lect. Notes Comp. Sci., pages 213-237. Springer, Berlin, 1994. 
[208] M. Makkai. Duality and definability in first order logic. Memoirs 
of the 
AMS, 
105(Number 503(4)), 1993. 
[209] M. Makkai. The fibrational formulation of intuitionistic predicate logic I: completeness 
according to Godel, Kripke, and Lauchli. Part 1. Notre Dame Journ. Formal Log., 
34(3):334-377, 1993. 
[210] M. Makkai. The fibrational formulation of intuitionistic predicate logic I: completeness 
according to Godel, Kripke, and Lauchli. Part 2. Notre Dame Journ. Formal Log., 
34(4):471-499, 1993. 
[211] M. Makkai and G.E. Reyes. First Order Categorical Logic. Number 611 in Lect. 
Notes Math. Springer, Berlin, 1977. 
[212] E.G. Manes. Algebraic Theories. Springer, Berlin, 1974. 
[213] P. Martin-Lof. 
An intuitionistic theory of types: predicative part. 
In H.E. Rose 
and J.C. Shepherson, editors. Logic Colloquium '73, pages 73-118, Amsterdam, 1975. 
North-Holland. 
[214] P. Martin-Lof. Constructive mathematics and computer programming. In L.C. Co-
hen, J. Los, , H. Pfeiffer, and K.P. Podewski, editors. Logic, Methodology 
and the 
Philosophy of Science VI, pages 153-179. North Holland, 1982. 
[215] P. Martin-Lof. Intuitionistic 
Type Theory. Bibliopolis, Napoli, 1984. 
[216] S. Martini. 
An interval model for second order lambda calculus. In D.H. Pitt, 
A. Poigne, and D. Rydeheard, editors. Category Theory and Computer Science, num-
ber 283 in Lect. Notes Comp. Sci., pages 219-237. Springer, Berlin, 1987. 
[217] J.H. McKinna. Deliverables: a Categorical Approach to Program Development 
in 
Type Theory. PhD thesis, Univ. Edinburgh, 1992. Techn. rep. LFCS-92-247. 
[218] C. McLarty. 
Elementary 
Categories, 
Elementary 
Toposes. 
Number 21 in Logic 
Guides. Oxford Science Publ., 1992. 
[219] N.P. Mendler, P. Panangaden, P.J. Scott, and R.A.G. Seely. A logical view of con-
current constraint programming. Nordic Journ. Comput., 2:181-220, 1995. 
[220] J. Meseguer. Relating models of polymorphism. In Principles of Programnning Lan-
guages, pages 228-241. ACM Press, 1989. 
[221] A.R. Meyer. What is a model of the lambda calculus? Inf. & Contr., 52:87-122, 
1982. 
[222] R. Milner. A theory of type polymorphism in programming. Journ. 
Comp. 
Softw. 
Syst., 17:348-375, 1978. 
[223] R. Milner and M. Tofte. Commentary 
on Standard ML. The MIT Press, Cambridge, 
MA, 1990. 
[224] R. Milner, M. Tofte, and R. Harper. The Definition of Standard ML. The MIT Press, 
Cambridge, MA, 1991. 
[225] J.C. Mitchell. A type-inference approach ro reduction properties and semantics of 
polymorphic expressions (summary). In ACM Conf. on LISP and Funct. 
Progr., 
pages 308-319. ACM Press, 1986. 
[226] J.C. Mitchell and E. Moggi. Kripke style models for typed lambda calculus. 
Ann. 

728 
References 
Pure & Appl. Logic, 51(l/2):99-124, 1991. 
[227] J.C. Mitchell and G.D. Plotkin. Abstract types have existential type. ACM 
Trans, 
on Progr. Lang, and Systems, 10(3):470-502, 1988. 
[228] John C. Mitchell. Foundations 
of Programming 
Languages. The MIT Press, Cam-
bridge, MA, 1996. 
[229] J.L. Moens. Caracterisation 
des topos de faisceaux sur un site interne a un topos. 
PhD thesis, Univ. Cath. de Louvain-la-Neuve, 1982. 
[230] E. Moggi. A category-theoretic account of program modules. Math. Struct, in Comp. 
Sci., 1(1):103-139, 1991. 
[231] R.P. Nederpelt, J.H. Geuvers, and R.C. de Vrijer, editors. Selected papers on Au-
tomath, Amsterdam, 1994. North-Holland. 
[232] B. Nordstrom, K. Peterson, and J.M. Smith. Programming 
in Martin-Lof's 
Type 
Theory: an introduction. 
Number 7 in Logic Guides. Oxford Science Publ., 1990. 
[233] A. Obtulowicz. Functorial semantics of type-free X-prj calculus. In Karpinsky, editor, 
Fundamentals 
of Computation 
Theory, number 56 in Lect. Notes Comp. Sci., pages 
302-307. Springer, Berlin, 1977. 
[234] A. Obtulowicz. Categorical and algebraic aspects of Martin-L6f type theory. Studia 
Logica, XLVIII 3:299-317, 1989. 
[235] A. Obtulowicz and A. Wiweger. Categorical, functorial and algebraic aspects of the 
type-free lambda calculus. In Univ. Algebra and Appl., number 9 in Banach Center 
Publ., pages 399-422, Warsaw, 1982. 
[236] P. Odifreddi. Classical Recursion 
Theory. North-Holland, Amsterdam, 1989. 
[237] P.W. O'Hearn and R.D. Tennent. Relational parametricity and local variables (pre-
liminary report). In Principles 
of Programming 
Languages, pages 171-184. ACM 
Press, 1992. 
[238] C.-H.L. Ong and E. Ritter. A generic strong normalization argument: application 
to the calculus of constructions. In E. Borger, Y. Gurevich, and K. Meinke, editors. 
Computer Science Logic 1993, number 832 in Lect. Notes Comp. Sci., pages 261-279. 
Springer, Berlin, 1994. 
[239] J. van Oosten. Exercises in Realizability. 
PhD thesis, Univ. Amsterdam, 1991. 
[240] J. van Oosten. Axiomatizing higher order Kleene realizability. Ann. Pure & Appl. 
Logic, 70:87-111, 1994. 
[241] S. Owre, S. Rajan, J.M. Rushby, N. Shankar, and M. Srivas. PVS: Combining speci-
fication, proof checking, and model checking. In R. Alur and T.A. Henzinger, editors. 
Computer Aided Verification, number 1102 in Lect. Notes Comp. Sci., pages 411-414. 
Springer, Berlin, 1996. 
[242] S. Owre, J.M. Rushby, N. Shankar, and F. von Henke. Formal verification for fault-
tolerant architectures: Prolegomena to the design of PVS. IEEE Trans, on Softw. 
Eng., 21(2):107-125, 1995. 
[243] V.C.V de Paiva. The dialectica categories. In J. Gray and A. Scedrov, editors. 
Categories in Computer Science and Logic, number 92 in AMS Contemp. Math., 
pages 47-62, Providence, 1989. 
[244] V.C.V. de Paiva. A dialectica-like model of linear logic. In D.H. Pitt, A. Poigne, 
and D.E. Rydeheard, editors. Category Theory and Computer Science, number 389 
in Lect. Notes Comp. Sci., pages 341-356. Springer, Berlin, 1989. 
[245] E. Palmgren and V. Stoltenberg-Hansen. Domain interpretations of Martin-Lof's 
partial type theory. Ann. Pure & Appl. Logic, 48:135-196, 1990. 
[246] R. Pare and D. Schumacher. Abstract families and the adjoint functor theorems. 
In P.T. Johnstone and R. Pare, editors. Indexed Categories and their 
Applications, 

References 
729 
number 661 in Lect. Notes Math., pages 1-125. Springer, Berlin, 1978. 
[247] Ch. Paulin-Mohring. Extraction 
des Programmes 
dans le Calcul des 
Constructions. 
PhD thesis, Universite Paris VII, 1989. 
[248] Ch. PauHn-Mohring. Inductive definitions in the system Coq. Rules and properties. In 
M. Bezem and J.F. Groote, editors. Typed Lambda Calculi and Applications, 
number 
664 in Lect. Notes Comp. Sci., pages 328-345. Springer, Berlin, 1993. 
[249] Ch. Paulin-Mohring and B. Werner. Synthesis of ML programs in the system Coq. 
Journ. Symb. Computation, 
5-6:607-640, 1993. 
[250] L.C. Paulson. Isabelle: A Generic Theorem Prover. 
Number 828 in Lect. Notes 
Comp. Sci. Springer, Berlin, 1994. 
[251] L.C. Paulson. ML for the Working Computer Scientist. 
Cambridge Univ. Press, 2^ 
rev. edition, 1996. 
[252] D. Pavlovic. Predicates and Fibrations. 
PhD thesis, Univ. Utrecht, 1990. 
[253] D. Pavlovic. Constructions and predicates. In D.H. Pitt et al., editor, Category and 
Computer Science, number 530 in Lect. Notes Comp. Sci., pages 173-196. Springer, 
Berlin, 1991. 
[254] D. Pavlovic. A logical view of the adjoint functor theorem. In R.A.G. Seely, editor. 
Category Theory 1991, number 13 in CMS Conference Proceedings, pages 361-366, 
1992. 
[255] D. Pavlovic. On completeness and cocompleteness in and around small categories. 
Ann. Pure & Appl. Logic, 74:121-152, 1995. 
[256] D. Pavlovic. Maps II: chasing proofs in the Lambek-Lawvere logic. Journ. of the 
IGPL, 4(2):159-194, 1996. 
[257] J. Penon. Algebre de categories — categories localement internes. C. R. Acad. Sc. 
Paris, 278:A1577-A1580, 1974. 
[258] W.K.-S. Phoa. Relative computability in the effective topos. Math. Proc. Cambridge 
Phil. Soc, 106:419-422, 1989. 
[259] W.K.-S. Phoa. 
Effective domains and intrinsic structure. In Logic in 
Computer 
Science, pages 366-377. IEEE, Computer Science Press, 1990. 
[260] W.K.-S. Phoa. Domain 
Theory in Realizability 
Toposes. 
PhD thesis, Univ. Cam-
bridge, 1991. Extended version is available as Edinburgh Techn. Rep. CST-82-91. 
[261] W.K.-S. Phoa. Building domains from graph models. Math. Struct, in Comp. 
Sci., 
2:277-299, 1992. 
[262] W.K.-S. Phoa. An introduction to fibrations, topos theory, the effective topos and 
modest sets. Technical Report LFCS-92-208, Edinburgh Univ., 1992. 
[263] W.K.-S. Phoa. Using fibrations to understand subtypes. In M.P. Fourman, P.T. 
Johnstone, and A.M. Pitts, editors, Applications 
of Categories in Computer 
Science, 
number 177 in LMS, pages 239-257. Cambridge Univ. Press, 1992. 
[264] W.K.-S. Phoa. From term models to domains. Inf & Comp., 109:211-255, 1994. 
[265] W.K.-S. Phoa and M. Fourman. A proposed semantics for pure ML. In W. Kuich, 
editor. International 
Colloquium on Automata, 
Languages and Programming, number 
623 in Lect. Notes Comp. Sci., pages 533-544. Springer, Berlin, 1992. 
[266] B.C. Pierce and D.N. Turner. Simple type theoretic foundation for object-oriented 
programming. Journ. Funct. Progr., 4(2):207-247, 1994. 
[267] A.M. Pitts. The Theory of Triposes. PhD thesis, Univ. Cambridge, 1981. 
[268] A.M Pitts. Polymorphism is set theoretic, constructively. In D.H. Pitt, A. Poigne, 
and D.E. Rydeheard, editors. Category and Connputer Science, number 283 in Lect. 
Notes Comp. Sci., pages 12-39. Springer, Berlin, 1987. 
[269] A.M. Pitts. Non-trivial power types can't be subtypes of polymorphic types. In Logic 

730 
References 
in Computer Science, pages 6-13. IEEE, Computer Science Press, 1989. 
[270] A.M. Pitts. A co-induction principle for recursively defined domains. Theor. 
Comp. 
Sci., 124(2):195-219, 1994. 
[271] A.M. Pitts. Categorical logic. In S. Abramsky, Dov M. Gabbai, and T.S.E. Maibaum, 
editors. Handbook of Logic in Computer Science, volume 6. Oxford Univ. Press, to 
appear. 
[272] A.M. Pitts and P. Taylor. A note on Russell's paradox in locally cartesian closed 
categories. Studia Logica, XLVIII 3:377-387, 1989. 
[273] G. Plotkin and M. Abadi. A logic for parametric polymorphism. In M. Bezem and 
J.F. Groote, editors. Typed Lambda Calculi and Applications, 
number 664 in Lect. 
Notes Comp. Sci., pages 361-375. Springer, Berlin, 1993. 
[274] G.D. Plotkin. Set-theoretical and other elementary models of the A-calculus. Theor. 
Comp. Sci., 121:351-409, 1993. 
[275] A. Poigne. On specifications, theories, and models with higher types. Inf. & Comp., 
68:1-46, 1986. 
[276] E. Poll. A Programming 
Logic based on Type Theory. 
PhD thesis, Techn. Univ. 
Eindhoven, 1994. 
[277] E. Poll, C. Hemerik, and H.M.M. Ten Eikelder. CPO-models for second order lambda 
calculus with recursive types and subtyping. Inf. Theor. et AppL, 27(3):221-260, 
1993. 
[278] A.J. Power. An abstract formulation for rewriting systems. In D.H. Pitt, A. Poigne, 
and D.E. Rydeheard, editors. Category Theory and Computer Science, number 389 
in Lect. Notes Comp. Sci., pages 300-312. Springer, Berlin, 1989. 
[279] J. Power and H. Thielecke. Environments, continuation semantics and indexed cate-
gories. In M. Abadi and T. Ito, editors, Theoretical Aspects of Computer 
Software, 
number 1281 in Lect. Notes Comp. Sci., pages 391-414. Springer, Berlin, 1997. 
[280] D. Prawitz. Natural Deduction. Almqvist and Wiksell, Uppsala, 1965. 
[281] H. Rasiowa and R. Sikorsky. The Mathematics 
of Metam,athematics. 
PWN, Warsaw, 
1963. 
[282] H. Reichel. 
Initial 
Computability, 
Algebraic Specifications, 
and Partial 
Algebras. 
Number 2 in Monographs in Comp. Sci. Oxford Univ. Press, 1987. 
[283] H. Reichel. An approach to object semantics based on terminal co-algebras. Math. 
Struct, in Comp. Sci., 5:129-152, 1995. 
[284] G.R. Reyes. From sheaves to logic. In A. Daigneault, editor. Studies in Algebraic 
Logic, number 9 in MAA Studies in Math., pages 143-204, 1974. 
[285] J.C. Reynolds. Towards a theory of type structure. In Programming 
Symposium, 
number 19 in Lect. Notes Comp. Sci., pages 408-425. Springer, Berlin, 1974. 
[286] J.C. Reynolds. Types, abstraction and parametric polymorphism. In R.E. A. Mason, 
editor. Information 
Processing 83, pages 513-523. IFIP, Elsevier Sci. Publ. (North-
Holland), 1983. 
[287] J.C. Reynolds. Polymorphism is not set-theoretic. In G. Kahn, D.B. MacQueen, and 
G.D. Plotkin, editors. Semantics 
of Data Types, number 173 in Lect. Notes Comp. 
Sci., pages 145-156. Springer, Berlin, 1984. 
[288] J.C. Reynolds and G.D. Plotkin. On functors expressible in the polymorphic typed 
lambda calculus. Inf. & Comp., 105:1-29, 1993. 
[289] E. Ritter. Categorical abstract machines for higher order typed lambda calculi. PhD 
thesis, Univ. Cambridge, 1993. Comp. Lab. Techn. Rep. 297. 
[290] E. Ritter. Categorical abstract machines for higher-order lambda calculi. 
Theor. 
Comp. Sci., 136(1):125-162, 1994. 

References 
731 
[291] E.P. Robinson. Parametricity as isomorphism. Theor. Comp. Sci,, 136:163-181,1994. 
[292] E.P. Robinson and G. Rosolini. Colimit completions and the effective topos. Journ. 
Symb. Logic, 55:678-699, 1990. 
[293] E.P. Robinson and G. RosoHni. Reflexive graphs and parametric polymorphism. In 
Logic in Computer Science, pages 364-371. IEEE, Computer Science Press, 1994. 
[294] H. Rogers. Theory of Recursive Functions 
and Effecitve 
Computability. 
MIT Press, 
Cambridge, MA, 1967. 
[295] R. Rosebrugh and R.J. Wood. Relational databases and indexed categories. In R.A.G. 
Seely, editor. Category Theory 1991, number 13 in CMS Conference Proceedings, 
pages 391-407, 1992. 
[296] G. Rosolini. Continuity 
and effectiveness 
in topoi. PhD thesis, Univ. Oxford, 1986. 
[297] G. Rosolini. About modest sets. Int. Journ. Found. Comp. Sci., 1:341-353, 1990. 
[298] J. Rutten and D. Turi. On the foundations of final semantics: non-standard sets, met-
ric spaces and partial orders. In J.W. de Bakker, W.P. de Roever, and G. Rozenberg, 
editors. Semantics: Foundations 
and Applications, 
number 666 in Lect. Notes Comp. 
Sci., pages 477-530. Springer, Berlin, 1993. 
[299] J. Rutten and D. Turi. Initial algebra and final coalgebra semantics for concurrency. 
In J.W. de Bakker, W.P. de Roever, and G. Rozenberg, editors, A Decade of Con-
currency, number 803 in Lect. Notes Comp. Sci., pages 530-582. Springer, Berlin, 
1994. 
[300] A. Scedrov. A guide to polymorphic types. In P. Odifreddi, editor. Logic and computer 
science, pages 387-420. Academic Press, London, 1990. The APIC series, vol. 31. 
[301] D.S. Scott. Continuous lattices. In F.W. Lawvere, editor, Toposes, Algebraic Ge-
ometry and Logic, number 274 in Lect. Notes Math., pages 97-136. Springer, Berlin, 
1972. 
[302] D.S. Scott. Data types as lattices. SIAM Journ. Comput., 3:523-587, 1976. 
[303] D.S. Scott. Lambda calculus: some models some philosophy. In J. Barwise, H.J. 
Keisler, and K. Kunen, editors. The Kleene Symposium, 
pages 223-266, Amsterdam, 
1980. North-Holland. 
[304] D.S. Scott. Relating theories of the A-calculus. In J.R. Hindley and J.P. Seldin, editors. 
To H.B. Curry: Essays on Combinatory 
Logic, Lambda Calculus and Formalism,, 
pages 403-450, New York and London, 1980. Academic Press. 
[305] R.A.G Seely. Hyperdoctrines, natural deduction and the Beck condition. Zeits. 
Math. 
Log. Grundl. Math., 29:33-48, 1983. 
[306] R.A.G. Seely. Locally cartesian closed categories and type theories. Math. 
Proc. 
Cambridge Phil. Soc, 95:33-48, 1984. 
[307] R.A.G. Seely. Categorical semantics for higher order polymorphic lambda calculus. 
Journ. Symb. Logic, 52:969-989, 1987. 
[308] R.A.G. Seely. Modelling computations—a 2-categorical approach. In Logic in Com-
puter Science, pages 65-71. IEEE, Computer Science Press, 1987. 
[309] M.B. Smyth and G.D. Plotkin. The category theoretic solution of recursive domain 
equations. SIAM Journ. Comput., 11:761-783,1982. 
[310] E.W. Stark. Dataflow networks are fibrations. In D.H. Pitt et al., editor. Category and 
Computer Science, number 530 in Lect. Notes Comp. Sci., pages 261-281. Springer, 
Berlin, 1991. 
[311] R. Statman. Logical relations and the typed lambda calculus. Inf. & Contr., 65:85-97, 
1985. 
[312] M. Stefanova and H. Geuvers. A simple model construction for the calculus of con-
structions. In S. Berardi and M. Coppo, editors. Types for Proofs and 
Programs, 

732 
References 
number 1158 in Lect. Notes Comp. Sci., pages 249-264. Springer, Berlin, 1996. 
[313] C. Stirling. Modal and temporal logics. In S. Abramsky, Dov M. Gabbai, and T.S.E. 
Maibaum, editors, Handbook of Logic in Computer Science, volume 2, pages 477-563. 
Oxford Univ. Press, 1992. 
[314] R. Street. The formal theory of monads. Journ. Pure & AppL Algebra, 2:149-169, 
1972. 
[315] R. Street. Fibrations and Yoneda's lemma in a 2-category. In G.M. Kelly, editor, 
Proc, Sydney Category Theory Seminar 1972/1973, number 420 in Lect. Notes Math., 
pages 104-133. Springer, Berlin, 1974. 
[316] R. Street. Cosmoi of internal categories. Trans. Am. Math. Soc, 258(2):271-317, 
1980. 
[317] R. Street. Fibrations in bicategories. Cah. de Top. et Geom. Diff., XXI-2:111-160, 
1980. 
[318] Th. Streicher. Correctness and Completeness 
of a Categorical Semantics 
of the Cal-
culus of Constructions. 
PhD thesis, Univ. Passau, 1989. Techn. Rep. MIP - 8913. 
[319] Th. Streicher. Semantics 
of Type Theory. Correctness, 
Completeness 
and Indepen-
dence results. Progress in Theor. Comp. Sci. Birkhauser, Boston, 1991. 
[320] Th. Streicher. Dependence and independence results for (impredicative) calculi of 
dependent types. Math. Struct, in Comp. Sci., 2(l):29-54, 1992. 
[321] Th. Streicher. Independence of the induction principle and the axiom of choice in the 
pure calculus of constructions. Theor. Comp. Sci., 103(l):395-408, 1992. 
[322] Th. Streicher. Investigations into intensional type theory. Habil. Thesis, Ludwig 
Maximilian Univ. Miinchen, 1993. 
[323] G. Sundholm. Proof theory and meaning. In D. Gabbay and F. Guenthner, editors. 
Handbook of Philosophical Logic, volume 3, pages 471-506, Dordrecht, 1984. Reidel. 
[324] G. Sundholm. Constructive generalized quantifiers. Synthese, 79:1-12, 1989. 
[325] W.W. Tait. A realizability interpretation of the theory of species. In Logic Collo-
quium. Symposium 
on Logic held at Boston 1972 - 1973, number 453 in Lect. Notes 
Math., pages 240-251. Springer, BerHn, 1975. 
[326] I. Takeuti. An axiomatic system of parametricity. In Ph. de Groote and J.R. Hindley, 
editors. Typed Lambda Calculi and Applications, 
number 1210 in Lect. Notes Comp. 
Sci., pages 354-372. Springer, Berlin, 1997. 
[327] A. Tarlecki, R.M. Burstall, and J.A. Goguen. Some fundamental algebraic tools for 
the semantics of computation: Part 3. Indexed categories. Theor. Comp. 5cz., 91:239-
264, 1991. 
[328] A. Tarski. Der Aussagenkalkiil und die Topologie. Fundam. Math., 31:103—134,1938. 
[329] P. Taylor. Internal completeness of categories of domains. In D.H. Pitt, S. Abramsky, 
A. Poigne, and D.E. Rydeheard, editors, Category Theory and Computer 
Program-
ming, number 240 in Lect. Notes Comp. Sci., pages 449-465. Springer, Berlin, 1985. 
[330] P. Taylor. 
Recursive 
domains, 
indexed category theory and polymorphism. 
PhD 
thesis, Univ. Cambridge, 1986. 
[331] P. Taylor. The fixed point property in synthetic domain theory. In Logic in 
Computer 
Science, pages 152-371. IEEE, Computer Science Press, 1991. 
[332] P. Taylor. Practical Foundations. 
Cambridge Univ. Press, 1998, to appear. 
[333] A.S. Troelstra. 
Metamathematical 
Investigation 
of Intuitionistic 
Arithmetic 
and 
Analysis. 
Number 344 in Lect. Notes Math. Springer, Berlin, 1973. 
[334] A.S. Troelstra. On the syntax of Martin-Lofs type theories. 
Theor. Comp. 
Sci., 
51:1-26, 1987. 
[335] A.S. Troelstra and D. van Dalen. Constructivism 
in Mathematics. 
An 
Introduction. 

References 
733 
North-Holland, Amsterdam, 1988. 2 volumes. 
[336] D. Cubric. On the semantics of the universal quantifier. Ann. Pure & AppL Logic, 
87:209-239, 1997. 
[337] B. Veit. A proof of the associated sheaf theorem by means of categorical logic. Journ. 
Symh. Logic, 46:45-55, 1981. 
[338] S. Vickers. Topology Via Logic. Number 5 in Tracts in Theor. Comp. Sci. Cambridge 
Univ. Press, 1989. 
[339] F.-J. de Vries. Type Theoretical Topics in Topos Theory. PhD thesis, Univ. Utrecht, 
1989. 
[340] Ph. Wadler. Theorems for free! In Fund. Progr. & Comp. Architecture, 
pages 347-
359. ACM Press, 1989. 
[341] R.F.C. Walters. Categories and Computer Science. 
Carslaw Publications, Sydney, 
1991. Also available as: Cambridge Computer Science Text 28, 1992. 
[342] R.F.C. Walters. An imperative language based on distributive categories. 
Math. 
Struct, in Comp. Sci., 2:249-256, 1992. 
[343] W. Wechler. 
Universal Algebra for Computer 
Scientists. 
Number 25 in EATCS 
Monographs. Springer, Berlin, 1992. 
[344] G. Winskel. A compositional proof system on a category of labelled transition systems. 
Inf 
& Comp., 87:2-57, 1990. 
[345] G. Winskel and M. Nielsen. Models for concurrency. In S. Abramsky, Dov M. Gabbai, 
and T.S.E. Maibaum, editors, Handbook of Logic in Computer 
Science, volume 4, 
pages 1-148. Oxford Univ. Press, 1995. 
[346] G.C. Wraith. A note on categorical datatypes. In D.H. Pitt, A. Poigne, and D.E. 
Rydeheard, editors. Category Theory and Computer Science, number 389 in Lect. 
Notes Comp. Sci., pages 118-127. Springer, Berlin, 1989. 

734 
References 
This Page Intentionally Left Blank

Notation Index 
( —)^ (transposition), xiv 
( —)^ (transposition), xiv 
(A' 4- L) (comma category of functors 
K,L), 
55 
(/ 4- g) (commaobject of l-cells f,g), 547 
0 (empty type), 140 
0 (initial object), xiv 
1 (singleton type), 138 
1 (terminal object), xiii 
: (in Mia; inhabitation in type theory), 
1 
: (in fiX^Y 
in category theory), xiii 
=cr (prepositional equality on type a), 
177 
Co (object of objects of an internal cate-
gory), 408 
Ci (object of morphisms of an internal 
category), 408 
E (existence predicate of an u/-set), 33 
E (existence predicate of an object of 
Set(p)), 375 
FQ (object part of an internal functor F), 
415 
Fi (morphism part of an internal functor 
F),415 
Hj (restriction of a fibred functor H to 
the fibre over / ) , 74 
I/R (quotient of an object / by a relation 
Ron 
I), 292 
) (opslice category of IB over / ) , 30 
7*(j) (induced nucleus in the slice cat-
egory over /, of a topos with 
nucleus j), 359 
I*(p) (localisation of a fibration p at 7), 
100 
r (in /*:IB-> B / / ) , 41 
7* (in7*:IB->B/7), 41 
MN (application 
term 
for 
exponent 
types), 134 
MN 
(application term for dependent 
product types), 586 
M[N/x] 
(substitution of TV for x in M), 
XV, 66 
M[I\/x\ 
(simultaneous substitution of Is 
for £ in M), 66 
Mr 
(application term for second order 
product types), 447 
F(7) (power object Q^ in a topos), 341 
F(7) (powerset of a set 7), 12 
F:(7) (j-power object fi/ in a topos with 
nucleus j), 362 
T / 7 (functor T acting on simple slice cat-
egory over 7), 164 
T* (free monoid, or Kleene star, on a set 
T), 65 
X -\- Y (coproduct of objects X and Y), 
xiv 
X E C (X IS Sin object of C), xiii 
X —¥ Y (map / from X to Y), xiii 
X X Y (Cartesian product of objects X 
735 

736 
Notation 
Index 
and Y), xiii 
[^]R 
(introduction term for quotient 
types), 283 
[f,g] (binary cotuple of maps / , g), xiv 
Alg(T) (category of algebras of a functor 
T), 161 
Alg(E,n) (category of (E, n)-algebras), 
236 
AlgSpec (category of algebraic equa-
tional specifications), 182 
B i C C C (category of bicartesian closed 
categories), 147 
C C C (category of Cartesian closed cat-
egories), 147 
CFam(Dcpo) (category of dcpo-indexed-
dcpos), 639 
C-Model (category of categorical mod-
els of signatures), 133 
Ci(T,) (classifying category of a signature 
E), 124 
Ci(E,A) 
(classifying category of an al-
gebraic specification ( E , ^ ) ) , 
185 
C^l(E) (Al-classifying category of a sig-
nature E), 135 
C^l(x,+)(^) ('^(x,+)(^)"^l^ssifying cate-
gory of a signature E), 143 
C^lx(E) (Al x-classifying category of a 
signature E), 139 
CoAlg(T) (category of co-algebras of a 
functor T), 161 
Efr (effective topos), 376 
Eq(ix, v) (equaliser map of w, v), 184 
Eq(u, v) (predicate of equality of u, v in 
a fibration), 191 
EqSpec (category of equational specifi-
cations), 182 
Eq^(cr, r) 
(equality type for kind A 
in higher order polymorphic 
type theory), 450 
E>q(T(x,x') (equality type for type a in 
dependent type theory), 586 
F P C a t (category of categories with fi-
nite products), 126 
Fam(Sets) (category of set-indexed sets), 
15 
Fam(Clos) (category of closure-indexed 
closures), 643 
Fam(C) (category of B-indexed families 
in internal category C), 422 
Fam((C) (category of category-indexed 
families in a category C), 512 
Fam((C) (category of set-indexed families 
in an (ordinary) category C), 
31 
Fam(p) (family fibration of a fibration p), 
106 
Fib(]B) (category of fibrations with basis 
B), 72 
Fib (category of fibrations), 72, 73 
Fibgpij^(IB) (category of split fibrations 
with basis B), 72 
Fibgpij^ (category of split fibrations), 
72, 73 
FoSpec (category of first order specifi-
cations), 227 
r(7,w) (set of global elements of an ob-
ject (/,«) in Eff), 385 
F (global sections functor Eff —>- Sets), 
385 
r (global sections functor C -)• Sets), 57 
HoSign (category of higher order signa-
tures), 313 
ICat(B) (category of indexed categories 
overB), 111 
ICat (category of indexed categories), 
110 
A (abstraction for Kleene application), 
xvii 
A (abstraction in a CCC), xiv 
N / K (quotient of a PER R), 35 
Q-set (category of Heyting valued sets, 
for a CHA fi), 376 
Q (codomain of a subobject classifier in 
a topos), 335 
Hj (codomain of the j-closed subobject 
classifier, in a topos with nu-
cleus j), 356 
P E R (category of PERs), 36 
n(p) (collection of predicates of a fibra-
tion p), 249 
=» (2-cell), xiii 
=>> (exponent), xiii 
S-Model(E) (category of set-theoretic 
models of a signature E), 126 
S-Model (category of set-theoretic mod-

Notation 
Index 
737 
els of signatures), 68 
S-Modelg'p 
(category of set-theoretic 
models of single-typed signa-
tures), 70 
Sets (category of sets), 11 
Sets* (category of pointed sets), 39 
SignPred (category of signatures with 
predicates), 222 
Sign (category of (many-typed) signa-
tures), 65 
SigngT (category of single-typed signa-
tures), 70 
Th{Ti,l-C) (equational logic theory with 
signature (^,n)), 
182 
UFam(PN) (total category of the realis-
ability fibration), 241 
UFam(PER) (category of uniform Eff-
indexed families of PERs), 394 
UFam(PER) (category of uniform cj-set-
indexed families of PERs), 53 
UFam(PER) (category of uniform PER-
indexed families of PERs), 57 
UFam(u;-Sets) (category of uniform EfF-
indexed families of u;-sets), 
394 
UFam(u;-Sets) (category of uniform ui-
set-indexed families of c^-sets), 
51 
Homj(X,Y) 
(hom-objectin the base cat-
egory of a locally small fibra-
tion), 559 
!=ii (abstract equality predicate), 374 
\J 
(directed join), xvii 
• (derivabihty), 122, 173, 224 
CL (category of complete lattices), 300 
Clos (category of closures), 642 
C 
(category of /-indexed objects and 
maps in an internal category 
C), 421 
Dcpo (category of dcpos), xvii 
D c p o ^ ^ (category of dcpos with embed-
ding-pro jection pairs as mor-
phisms), 638 
DistrSign (category of distributive sig-
natures), 144 
EqFib (category of Eq-fibrations), 209 
E x P E R (category of extensionalPERs), 
697 
Fa (fibred sheafification functor), 364 
FinSets (category of finite sets), 57 
Fs (fibred separated reflection functor), 
364 
M S (category of metric spaces), 279 
P P E R (category of PERs and paramet-
ric maps), 477 
PoSets (category of posets), xvi 
Pred (category of predicates on sets), 11 
REL (category of sets and relations), 
205 
Rel (category of relations over sets), 14 
a(/) (sheafification of an object / ) , 363 
cat (IB) (category of internal categories in 
B), 415 
j (nucleus in a topos), 354 
p , p ' (recursive projections), xvii 
r (left adjoint cj-Sets —y PER to inclu-
sion), 37 
s(/) (separated reflection of an object / ) , 
363 
t r u e (subobject classifier in a topos), 335 
LI (lift of an object / in a topos), 341 
L (bottom element), xvi 
J_ (falsum), 223 
unpack P as [nx In Q^n'y In R] (cotuple 
term for coproduct types), 141 
IB/7 (slice category of IB over / ) , 28 
IB// (simple slice of IB over / ) , 41 
IB"*" (category of arrows in IB), 28 
B ^ (category of pointed families in B), 
38 
C(X, Y) (maps in C from X to K), xiii 
C(S) (category of types and terms in 
kind context S), 457 
E ^ 
(category of internal diagrams of 
type C in a fibration with to-
tal category E), 435 
(total category of an opposite 
fibration 
with total category 
E), 113 
E/ (fibre category over an object / in 
a fibration with total category 
E), 26 
%,(X,Y) 
(homset of maps X -)• K in E 
over ti), 26 
• (Kleene application), xvii 
• (application for terms), xv 

738 
Notation 
Index 
U (coproduct), 94, 97 
-> (cover), 260 
H (adjunction), xiv 
—» (epic map), xiii 
= (syntactic equality), xv 
7} (unit of an adjunction), xiv 
3! (unique choice), 304 
3 (existential quantification), 223 
V (universal quantification), 223 
N with /3 = a via z (elimination term for 
polymorphic equality types), 
450 
Q with x' = X via z (elimination term 
for dependent equality types), 
587 
E (existence predicate on the quotient of 
a PER), 36 
£j 
(membership predicate at / in a 
topos), 341 
Gcr (membership of type a, in higher or-
der logic), 316 
K.M (first coprojection term for coprod-
uct types), 141 
K (first coprojection of a (binary) coprod-
uct), xiv 
K'N 
(second coprojection term for co-
product types), 141 
K' (second coprojection of a (binary) co-
product), xiv 
Al(I]) (simply typed A-calculus with —>^-
types on a signature E), 134 
Al (X,+) (S) (simply typed A-calculus with 
1, X, —>-,0,-j—types on a signa-
ture E), 140 
Alx(E) (simply typed A-calculus with 
1,X,—>-types on a signature 
E), 138 
A2 (second order polymorphic type the-
ory), 441, 446 
A2= (second order polymorphic type the-
ory with equality types), 450 
A (abstraction operation in (typed) A-
calculus), XV 
A (abstraction operation in a A-category), 
155 
Au; (higher order polymorphic type the-
ory), 442, 448 
Au;= (higher order polymorphic type the-
ory with equality types), 450 
A-> (first order polymorphic type the-
ory), 441, 446 
A—>•= (first order polymorphic type the-
ory with equality types), 450 
Aa: Type. M (abstraction term for second 
order product types), 446 
Xv: a. M (abstraction term for exponent 
types), 134 
Xx: a. M (abstraction term for dependent 
product types), 586 
DC (logical equivalence), 226 
[[-Jp (interpretation function based on 
valuation p), 67 
f:X 
-^Y 
(map / from X to Y), xiii 
^ (meta lambda abstraction), xv 
;—>• (monic map), xiii 
V (codiagonal [id, id] for a coproduct -}-), 
xiv 
V (inclusion functor Sets -> EfT), 385 
V (inclusion functor Sets —> u;-Sets), 34 
-• (negation), 223 
-»-• (double negation nucleus), 354 
i 
(codomain fibration 
associated 
with a display map category 
(]B,P)),610 
u(X) 
(chosen Cartesian map over u at 
^ ) , 4 7 
W (lifting of natural transformation <j), 
_ 
'^'^ 
m: X '—> I (closure of m: X >—> / in a 
topos with a nucleus), 355 
do (domain map of an internal category), 
408 
di (codomain map of an internal cate-
gory), 408 
TTP (first projection term for Cartesian 
product types), 139 
Tv'P (second projection term for Carte-
sian product types), 139 
TT' (second projection of a (binary) Carte-
sian product), xiii 
TT (first projection of a (binary) Cartesian 
product), xiii 
TT (projection in a comprehension cate-
gory), 614 
TT (subset projection), 274 
TTo (canonical projection for a hom-object 
in the base category of a lo-

Notation 
Index 
739 
cally small fibration), 559 
TTi (map "of arrows" for a hom-object, in 
the total category of a locally 
small fibration), 559 
pick X from a in AT (elimination term for 
quotient types), 283 
Yl (product), 94, 97 
Ha: A. a (higher order polymorphic prod-
uct type), 448 
Ila: Type, a (second order product type), 
446 
Tlx'.a.T (dependent product type), 586 
Prop (type of propositions), 313 
^ (in X 4^ y ) , xiii 
^ ( i n f:X 
- ^ y ) , xiii 
—>• (in a —> r), xv 
—^ (partial map), 342 
^ 
(parallel maps), xiii 
Cart(IE) (category with Cartesian maps 
in the total category E of a 
fibration), 30 
ClSubj(/) (poset of j-closed subobjects 
of an object / ) , 356 
ClSubj(IB) (category of j-closed subob-
jects in a category IB), 356 
Del(]B) (category of deliverables in IB), 
556 
ERel(]B) (category of equivalence rela-
tions in IB), 45 
ERel(]E) (category of equivalence rela-
tions in the total category E 
of a preorder fibration), 296 
FRelP(p) 
(category of predicates and 
functional relations in a fibra-
tion p), 265 
FRel(p) (category of types and func-
tional relations in a fibration 
p), 254 
FSepj(IB) (category of j-separated fami-
lies inB), 364 
FShj (IB) (category of families of j-sheaves 
inB), 364 
FV(M) (set of free variables in a term 
M), 66 
FamSub(B) (category of subobjects on 
families in B), 552 
FinFam(C) (category of families in C in-
dexed by finite sets), 57 
Full(l/) (internal category in the base 
category of a locally small fi-
bration, induced by an object 
U in the total category), 563 
Full]g(a) (full internal category in B as-
sociated with a map a), 412 
Im(ii) (image (object) of u), 257 
Ker(u) (kernel of a map n, in a fibration), 
291 
Mono(B) (category of monos in B), 43 
Orth(yl) (category of families orthogonal 
to an object A), 712 
Orthj(^) (category of j-separated fam-
ilies orthogonal to an object 
A), 712 
PER (set of PERs), 35 
PFam(PER) (category of PER-indexed 
parametric families of PERs), 
478 
Per(B) (category of partial equivalence 
relations in B), 45 
Pred(T) (lifting of a polynomial functor 
T from types to predicates), 
527 
RegSub(B) (category of regular subob-
jects in B), 46 
Rel(B) (category of relations in B), 44 
Rel(E) (category of relations in the total 
category E of a fibration), 291 
Rel(p) (category of types and relations in 
a fibration p), 253 
SPred(p) (category of strict predicates on 
types with equality, in a fibra-
tion p), 379 
Sep;(B) (category of j-separated objects 
in B), 360 
Set(p) (category of sets with equality 
predicate in a fibration p), 374 
Shj(B) (category of j-sheaves in B), 360 
Sign(B) (signature of a category B), 129 
Split(IE) 
(category with maps from a 
splitting in the total category 
E of a fibration), 92 
Sub(7) (poset of subobjects of an object 
/ ) , 4 3 
Sub(B) (category of subobjects in a cat-
egory B), 43 
S(E) (total category of a simple fibration 

740 
Notation Index 
in Fib, on fibration with total 
category E), 555 
Termsr(X) (set of terms of type r with 
free variables in X), 66 
VSuhj(X) 
(collection of vertical subob-
jects of X over / in a fibra-
tion), 351 
V(IE) (category of vertical maps in the 
total category E of a fibra-
tion), 549 
app (evaluation map in a A-category), 
155 
char(77i) (characteristic map of a mono m 
in a topos), 335 
domj (domain fibration at / ) , 30 
ev (evaluation map in a CCC), xiv 
m(it) (monic part of u), 257 
so(IB) (total category of the simple opfi-
bration on IB), 511 
st (strength natural transformation), 163 
s(T) (total category of a simple fibration 
for a CT-structure with T as 
collection of types), 42 
s(IB) (total category of simple 
fibration 
onB), 40 
Sp(E) (total category of the simple fibra-
tion over the fibration p), 488 
i(M) (introduction term for subset type), 
272 
o(N) (elimination term for subset type), 
272 
Tj^ (reflexivity term for equality on a kind 
A in polymorphic type the-
ory), 450 
Tcr (reflexivity term for equality on a type 
<7 in dependent type theory), 
587 
{x:a \ (p} (subset type), 272 
a -\- T (coproduct type), 140 
a/R (quotient type), 283 
a[—/X] (functor associated with Hagino 
type <T(X), 
via substitution 
for type variable X), 457 
a -^ T (exponent type), 134 
a X T (product type), 138 
:^ (Kleene equality), xvii 
C:^ (equivalence of categories), xiv 
>- (dependency relation), 685 
Ea: A. a (higher order polymorphic sum 
type), 448 
Ea:Type.<7 (second order polymorphic 
sum type), 446 
Ea;: a. r (dependent sum type), 586 
D (implication), 223 
9x (canonical map for an object X wrt. a 
definable collection), 570 
T (top element), xvi 
T (truth), 223 
( —, —) (recursive tupling), xvii 
{M,N) 
(tuple term for Cartesian prod-
uct types), 139 
(a) 
(functor associated with lifting of 
natural transformation a), 77 
{T,M) 
(tuple term for second order sum 
types), 446 
(fid) (binary tuple of maps / , g), xiii 
(x^y) 
(tuple term for dependent sum 
types), 586 
0 (empty tuple term for singleton type), 
139 
Type (kind of types, in polymorphic type 
theory), 446 
7 (discrete internal category on an object 
/), 410 
unpack z as {a^x) in N (elimination term 
for second order sum types), 
447 
unpack z as {x,y) in Q (elimination term 
for dependent sum types), 586 
€ (counit of an adjunction), xiv 
c/pn (nth partial recursive function), xvii 
h (logical entailment), 2, 121 
V (disjunction), 223 
V (join, least upper bound), xvi 
u;-Sets (category of u;-sets), 33 
A (conjunction), 223 
A (meet, greatest lower bound), xvi 
C (category Sets^ 
of presheaves on 
Q , 340 
{ —} (domain functor of a comprehension 
category), 539 
{ —} (subset type functor in a 
fibration), 
274 
{X E P} (extension-object for an object 
X wrt. a definable collection 
P), 570 

Notation Index 
741 
{ }j (j-singleton map, in a topos with nu-
cleus j), 356 
{} (empty cotuple term for empty type), 
141 
IIPII (fibration of objects, for a split fibra-
tion p), 93 
Cfi (in Cfiil —^ I/R', canonical quotient 
map), 292 
i (map of identities of an internal cate-
gory), 408 
p/Eq (quotient of an Eq-fibration p by 
internal equality), 214 
p~^(I) 
(fibre category of p over / ) , 26 
p°P (opposite of a fibration p), 113 
u* (substitution functor along u, in a fi-
bration), 47 
u* (substitution functor along u, in an 
indexed category), 50 
U] (extension functor along u, in an opfi-
bration), 511 
>l(IB) (collection of algebraic equations 
in a category IB), 187 
A{p) (collection of axioms of a fibration 
p), 250 
V/I 
(full subcategory of the slice IB/7 of 
display maps with codomain 
7, in a display map category 
(B,2))),610 
T(M) (category of families in a topos B), 
632 
'H(p) (collection of equations that hold in 
an Eq-fibration p), 212 
£(E, • ) (total category of the fibration 
of contexts of a logic with sig-
nature (S,n)), 174 
£(S, 1-C) (total category of the classifying 
Eq-fibration of (E,?/)), 194 
A^ \= A (validity in A4 of equations in 
A), 183 
\R\ (domain of a PER R), 35 
I (separation of contexts), xv, 171 
IS I (set of types of a signature E), 64 
|p| (fibration of objects, for a fibration p), 
30 

742 
Notation Index 
This Page Intentionally Left Blank

Subject Index 
Above, 26, 28 
Abstraction condition, 479 
Action 
- of an internal diagram, 431, 564 
monoid - , 7 0 
Adjunction, xiv 
- in Fib, 93 
- in Fib(B), 84 
fibred -, 83 
split -, 84 
internal -, 418 
map of -s, 89 
pseudo -, 91 
semi- -, 157, 454 
Admissible subset 
- of a complete lattice, 300 
- of a directed complete partial or-
der, 203 
ALF, 582,598 
Algebra, 7 
- of a functor, 161 
- of a monad, 80, 433 
- of a signature, 66 
- of a signature with predicates, 235 
Boolean -, xvi, 167, 242 
cylindric -, 242 
Heyting -, xvi 
partial -, 132, 189 
Almost 
- epic, 358 
- equivalence relation, 384, 390 
- monic, 358 
Ambient category, 409 
Arrow 
- category, 28 
- fibration 
- in Fib, 555 
- in Fib(B), 551 
- object 
- in Fib, 553 
- in Fib(B), 549 
AUTOMATH, 582, 598 
Axiom of Choice, 47, 50, 106, 708 
- in a fibration, 271 
- in a regular category, 271 
- in dependent type theory, 596, 
600 
countable -, 405 
Axiom rule, 172 
BA, see Boolean algebra 
Balanced category, 345 
Beck-Chevalley condition, 86, 88, 94, 97, 
191 
Bicartesian closed category, 143 
BiCCC, see Bicartesian closed category 
Bidense morphism, 358, 365 
Bifibration, 511, 512, 521 
Bisimulation, 532 
Boolean algebra, xvi, 167, 242 
Bounded 
743 

744 
Subject Index 
- family of finite sets, 572 
- family of partial equivalence rela-
tions, 579 
Brouwer-Heyting-Kolmogorov interpreta-
tion, 137, 596 
Calculus 
A — , XV 
Al- -, 134 
Alx- -, 138 
Al(^,+)--, 140 
A2- -, 446 
Ao;- -, 448 
A^--, 446 
- of constructions, 647, 684 
extended -, 691 
- of inductive definitions, 691 
- of predicates, 663 
Canonical quotient map, 292 
Carrier 
- of a CO-algebra 
- of a functor, 161 
- of an algebra 
- of a functor, 161 
- of a signature, 66 
Cartesian 
- closed 
- category, xii 
-fibration,81, 426 
- internal category, 419 
locally -, 39, 81, 343, 564, 583, 
627, 702 
relatively -, 610, 623 
- functor, 74 
- lifting, 27 
- morphism, 27 
weak -, 30 
- product, xiii 
- in a fibration (in Fib), 93, 471, 
520 
- in a fibration (in Fib(IB)), 520 
- type, 138 
internal -, 418, 429 
Category 
A- -, 155 
non-extensional-, 157 
Al- -, 149, 566 
- (fibred) over, 27 
- with families, 622 
ambient -, 409 
arrow -, 28 
base -, 26 
classifying -
Al- -, 135 
Alx- -, 139 
- of a signature, 124 
- of an algebraic specification, 
185 
coherent -, 266 
comma-, 55, 57, 79, 515, 548 
complete -, 102 
comprehension -, 539, 583, 613 
- over a fibration, 666 
- with unit, 616 
closed -, 625, 715 
family-, 618,635, 636 
full -, 613 
identity -, 614, 627, 637 
regular subobject -, 683 
simple -, 614, 627 
subobject -, 614, 683 
D- -, 274 
display map -, 610 
distributive -, 63, 323, 522 
Eilenberg-Moore -, 46 
fibred -, 80 
exact -, 297 
extensive -, 62 
fibre -, 26 
fibred -, 27 
indexed -, 50 
opposite -, 112 
split -, 51 
internal -, 7, 10, 408 
Cartesian closed -, 419, 426 
discrete-, 411, 429, 434 
finite-, 
411 
full -, 412, 423, 424, 429, 470, 
490, 492, 564, 614, 701, 702 
full - in a fibration, 563 
indiscrete -, 421 
preorder -, 414 
KleisH -, 46, 80, 117, 130, 205, 494 
fibred -, 80, 494 
locally small -, xiii, 4, 428, 558 
logical -, 266 
opposite -, xiii 
opslice -, 30, 292, 511, 518 

Subject Index 
745 
simple-, 512, 518 
receiving -, 119 
regular -, 257 
slice -, 19, 28 
simple-, 19, 41, 165 
small -, xiii, 410, 423, 430 
total -, 26 
well-powered -, 351 
Cauchy reals, 290 
CCC, see Cartesian closed category 
CCompC, see Closed comprehension cat-
egory 
CHA, see Complete Heyting algebra 
Change-of-base, 56 
- functor, 48 
- situation, 57 
Characteristic morphism, 15, 335 
CHARITY, 163, 457 
Church numeral, 456, 459 
Church's Thesis, 402 
Church-Rosser property, 7 
- for dependent type theory, 592 
- for polymorphic type theory, 442 
- for simple type theory, 134 
Classical logic, xvi, 224, 270, 337, 358, 
365 
Classifying 
- Eq-fibration, 201 
- category 
Al- -, 135 
Alx- -, 139 
- of a signature, 124 
- of an algebraic specification, 
185 
- 
fibration 
- in polymorphic type theory, 
482 
- in predicate logic, 234, 278, 
299, 323 
- morphism, 335 
Cleavage, 49 
Closed 
j - -, for a nucleus j , 355 
-.-.- -, in Eff, 389 
- comprehension category, 625, 715 
- in a topological space, 209 
- in the Scott topology, 153 
down -, 204 
Closure, 355, 642 
fibration of -s, 643, 695 
internal category of -s, 644 
Cloven 
- fibration, 49 
- opfibration, 511 
Co-algebra, 7 
- of a comonad, 433 
- of a functor, 161 
Co-induction, 526 
- assumption, as co-algebra, 532 
- proof principle, in a fibration, 532 
Cocomplete fibration, 101 
Code, 33 
Codiagonal, xiv 
Codomain fibration, 28, 193, 431, 439, 
551, 560,617, 627 
Coequaliser in a fibration, 303 
Cofibration, 510 
Coherence conditions, 50 
Coherent 
- category, 266 
- fibration, 233, 234, 239, 241, 266 
- logic, 227 
- specification, 227 
Comma 
- category, 55, 57, 79, 515, 548 
- 
fibration 
- in Fib, 553 
- in Fib(B), 549 
- object, 547 
- in Fib, 552 
- i n Fib(IB), 549 
Commutation conversion 
- for coproduct types, 141 
- for quotient types, 289 
- for sum types, 454 
- for weak dependent sum types, 
593 
Comonad, 46, 168, 433, 494, 535 
fibred -, 494 
weakening and contraction -, 536 
Complete 
- Heyting algebra, xvi, 239, 269, 
331, 376 
- category, 102 
small -, 439, 467 
- distributivity, 105 
- fibration, 101 
small -, 439 

746 
Subject 
Index 
- lattice, xvi, 300 
Completeness 
- of algebraic equational logic, in a 
category, 186 
- of equational logic, in a fibration, 
208 
- of predicate logic, in a 
fibration, 
249 
Comprehension, 13, 274 
- category, 539, 583, 613 
- from a full internal category, 
614 
- lifted along a fibration, 544 
- over a fibration, 666 
- with unit, 616 
closed -, 625, 715 
family -, 618, 635, 636 
full -, 613 
hom-set -, 566 
identity -, 614, 627, 637 
regular subobject -, 683 
simple -, 614, 627 
subobject -, 614, 683 
- in a fibration, 616 
Congruence, 533 
Conjunction, 223 
Connective, 223 
Conservative functor, 265 
Constructive logic, xvi, 237 
Constructor, 160, 162, 456 
Context, 2, 121 
- rules, 171 
kind -, 445 
proposition-, 171, 172, 224 
type-, 171, 224, 445 
Contraction, 24, 175, 176 
- functor, 176, 190 
- wrt. a comprehension category, 
614 
- wrt. a weakening and contrac-
tion comonad, 538 
- rule 
- for propositions, 172 
- for types, 172 
- in dependent type theory, 585 
- in simple type theory, 122 
Conversion, 135, 177 
- rule in dependent type theory, 585 
- rule in higher order type theory, 
448 
Coproduct, xiv 
- in a comprehension category 
strong -, 624 
weak -, 624 
- in a fibration, 97 
- in Fib, 521 
- in Fib(B), 521 
- type, 140 
- in polymorphic type theory, 
457 
definable -, 453, 483 
disjoint -, 526 
strong -, 591 
universal -, 526 
weak -, 591 
- with simple parameters, 158 
- wrt. a comprehension category, 
540 
strong -, 677 
very strong -, 678 
- wrt. a weakening and contraction 
comonad, 537 
disjoint -, 59 
- in a fibration, 533 
distributive-, 63, 90, 158 
- and Frobenius, 105 
simple T- -, in a fibration, 149, 541 
simple -
- in a fibration, 94, 427, 541 
- in an internal category, 419, 
427 
universal -, 58, 266, 637 
- in a fibration, 533 
Coprojection 
- morphism, xiv 
- term, 141 
COQ, 582, 595, 684, 691 
Cotuple, xiv 
Cover, 260, 350, 355 
collective -, 578 
Freyd -, 57 
CT-structure, 42, 153, 494, 541, 611, 670 
fibred -, 557 
Cut rule, 172 
Cylindric algebra, 242 
Cylindrification operation, 242 

Subject Index 
747 
D-category, 274 
Data type, 7, 162, 456 
proof principles for-s, 526, 532, 533 
dcpo, see Directed complete partial order 
Decidable 
- partial equivalence relation, 572 
family of -s over Sets, 572 
family of -s over u;-Sets, 573 
- proposition, 401 
Definability 
- of equality, 574 
- of functors, 573 
- of isomorphisms, 574 
- of vertical morphisms, 574 
Definable 
- Cartesian product type 
- in polymorphic type theory, 
453, 483 
- collection, 569, 709 
- coproduct type 
- in polymorphic type theory, 
453, 483 
- subfibration, 574 
- sum type 
- in polymorphic type theory, 
453, 459 
Deliverable, 526, 556 
Dense 
j - -, for a nucleus j , 355 
-.-.- -, in Efr, 389 
- image, 359 
- partial map, 360 
Dependency, 7, 684 
Dependent 
- parameters, 165 
- predicate logic, 3, 645, 648 
- type theory, 3, 581, 584 
Derivability, 122 
- in predicate logic, 224 
Descent theory, 9, 412, 431, 514 
Destructor, 160, 456 
Diagonal, xiii 
- element, 242 
parametrised -, xiii, 130, 190 
Diagram 
internal-, 431, 564 
parametrised -, 434 
Dialectica category, 117, 518 
Dinatural transformation, 484, 485 
Directed 
- complete partial order, xvi, 128, 
153, 203, 637 
continuously indexed -, 637 
reflexive-, 153, 156, 670 
- subset, xvii 
Disjoint 
- coproduct 
- in a fibration, 533 
- type, 526 
- union type, 591 
Disjunction, 223 
Display 
- indexing, 21, 29, 32, 51, 58, 59, 
107, 109 
- map, 583, 603, 708 
- category, 610 
- in a comprehension category, 
614 
Distributive 
- category, 63, 323, 522 
fibred -, 522 
- coproduct, 63, 90, 105, 158 
- lattice, 167, 233 
Distributivity 
complete -, 106, 600 
Domain 
- fibration, 30, 325, 429 
- opfibration, 511 
Domain theoretic model 
- of polymorphic type theory, 482 
- of simple type theory, 153 
- of the untyped A-calculus, 156 
Donkey sentence, 597, 601 
Double negation 
- nucleus, 354 
- in Eff, 389 
- rule, XV 
DPL, see Dependent predicate logic 
DPL-structure, 654 
DTT, see Dependent type theory 
ECC, see Calculus of constructions, ex-
tended 
Effective 
- object, 388 
- operation, 699 
- quotient type, 284 
- topos, 376, 383 

748 
Subject Index 
Eilenberg-Moore category, 46 
fibred -, 80 
ELF, 598 
Embedding between dcpos, 638 
Encapsulation, 460 
Epi, xiii 
regular-, 261, 350, 355 
split -, 264 
Eq-fibration, 201 
classifying -, 201 
Equaliser 
- in a fibration, 282 
internal -,419 
Equality 
- combinators, 196 
- functor, 291 
- in a comprehension category 
strong -, 624, 633 
weak -, 624 
- in a fibration, 190 
- type 
dependent -, 586 
polymorphic -, 449 
strong -, 589, 590, 680 
very strong -, 681 
weak -, 588, 680 
- wrt. a comprehension category, 
540 
strong -, 682 
very strong -, 682 
- wrt. a weakening and contraction 
comonad, 538 
componentwise -, 525 
external-, 177, 192, 226, 227 
intensional -, 591 
internal -, 177, 192, 226, 227 
Lawvere rule for -
- in equational logic, 179, 195 
- in predicate logic, 229 
Lawvere rule with Frobenius for -
- in equational logic, 181, 195 
- in predicate logic, 232 
Leibniz -, 315, 454 
pointwise -, 525 
propositional -, 177, 226 
simple -
- in a fibration, 541 
very strong -, 371, 410 
Equation, 178 
algebraic -, 178 
non-conditional -, 178 
Exact category, 297 
Exchange rule 
- for propositions, 172 
- for types, 172 
- in dependent type theory, 586 
- in simple type theory, 122 
Excluded middle, 226, 232 
Existence predicate, 33, 375 
Existential quantification, 223 
Exponent 
- object, xiii 
- of a fibration with a category, 92, 
573 
- of fibrations, 117 
- type, XV 
fibred -, 92 
internal -, 419, 429 
Extension, 511, 513, 514 
- functor, 510 
Kan -, 513, 635 
Extensional 
- dependent type theory, 590 
- entailment 
- in higher order logic, 315, 452, 
650 
- rule, 314 
- logic, 177, 192 
- partial equivalence relation, 697 
- propositional equality, 285 
- relation, 375 
Extensive 
- category, 62 
- fibration, 534 
Extent of a predicate, 274 
External 
- equality, 177, 192 
- existence, 255 
Externalisation, 421, 422, 425, 465, 486, 
560 
Extremal morphism, 260 
Factorisation 
- in higher order logic, 319 
- system, 260, 359 
- via quotients, in a fibration, 302 
- via subsets, in a fibration, 281 
image -, 257 

Subject Index 
749 
Falsum, 223 
Family 
- comprehension category 
- over Cat, 635 
- over Sets, 618, 636 
- fibration 
- of a fibration, 106 
- over Cat, 108, 635 
- over Sets, 32, 95, 98, 105, 108, 
194, 201, 239, 278, 299, 322, 
331, 353, 360, 376, 571, 618, 
625 
- of sets, 20 
- of sheaves, 364, 709 
category with -ies, 622 
constant -, 22 
separated -, 364, 577, 709 
FhoDTT, see Full higher order depen-
dent type theory 
FhoDTT-structure, 694 
weak -, 694 
Fibration, 4, 27 
A2- -, 473 
relationally parametric -, 501 
A2=- -, 473 
Au;- -, 473, 644, 706 
Au;=- -, 473 
A ^ - -, 473 
\^=- 
-, 473 
- in a 2-category 
- following Johnstone, 78 
- following Street, 56, 548 
- of contexts in logic, 174 
- of monos, 43 
- of objects, 30, 326 
split -, 93, 325 
- of relations in a fibration, 291, 524 
- over a fibration, 61 
- in Fib, 505, 554 
- i n Fib(B), 550 
- with comprehension, 616 
- with subset types, 274, 618 
arrow -
- in Fib, 555 
-inFib(IB), 551 
classifying -
- in polymorphic type theory, 
482 
- in predicate logic, 234, 278, 
299, 323 
cloven -, 49 
cocomplete-, 101 
codomain -, 28, 193, 431, 439, 551, 
560, 617, 627 
coherent -, 233, 234, 239, 241, 266 
complete -, 101 
small -, 439 
domain -, 30, 325, 429 
Eq- -, 201 
classifying -, 201 
exponent -
- with a category, 92 
- with another fibration, 117 
extensive -, 534 
family -
- of a fibration, 106 
- over Cat, 108, 635 
- over Sets, 32, 95, 98, 105, 108, 
194, 201, 239, 278, 299, 322, 
331, 353, 360, 376, 571, 618, 
625 
fibre -, 551, 555 
first order-, 233, 236, 238, 239, 241, 
267, 270 
geometric -, 568 
higher order -, 330 
locally small -, 559, 575, 577, 621, 
626, 701 
morphism of -s, 73 
opposite -, 113 
polymorphic -, 471 
poset -, 55 
realisability-, 241, 245, 331, 376 
regular -, 233, 234, 246, 374 
representable-, 116, 325 
simple-, 41, 439, 627 
- over a fibration, 487, 488, 551, 
555 
small -, 423, 438, 564, 578 
split -, 50 
sub -, 574, 583 
definable -, 574 
subobject -, 43, 193, 201, 202, 266, 
267, 278, 297, 307, 334, 409, 
429, 627 
regular -, 309 
type theoretic -, 44, 611, 627 

750 
Subject Index 
well-powered -, 351 
Fibre, 26 
- fibration, 551, 555 
Fibred 
- CT-structure, 557 
- Yoneda Lemma, 323 
- category, 27 
- comonad, 494 
- functor, 73, 74 
- global section, 619, 620 
- locally Cartesian closed category, 
633, 669 
- monad, 79, 359 
- preorder, 174, 201 
- reflection, 543, 546 
- sheafification, 366 
- span,514 
- strong coproduct, 636 
- structure, 80 
Fibrewise 
- fibration, 550 
- structure, 80 
- topos, 568 
Final, see Terminal 
First order 
- fibration, 233, 236, 238, 239, 241, 
267, 270 
- predicate logic, 221 
Formation rule 
- for propositions 
- in equational logic, 177 
- in predicate logic, 223 
- for types 
- in dependent type theory, 586 
- in polymorphic type theory, 
446 
- in simple type theory, 134 
Frame, xvi, 239, 269, 282, 331, 360, 376 
Freyd cover, 57 
Frobenius property, xv, 103 
- and distributive coproducts, 105 
- for coproducts, 102, 105 
- wrt. a weakening and contrac-
tion comonad, 538 
- for equality, 191, 199 
- wrt. a weakening and contrac-
tion comonad, 538 
- for quotients 
- in a fibration, 295 
- in type theory, 290 
for simple coproducts, 102 
Full 
- higher order dependent type the-
ory, 3, 645, 684, 688 
weak -, 688 
- internal (sub)category, 412, 423, 
424, 429, 470, 490, 492, 564, 
614, 701, 702 
- quotient type, 284 
- subset type, 273 
Functor 
- over IB, 74 
conservative -, 265 
fibred -, 74 
internal -,415 
polynomial-, 161, 527 
representable-, 351 
split -, 74 
strong -, 163 
Functorial semantics, 7, 517 
- for equational logic 
- in a fibration, 211 
- for polymorphic type theory, 472, 
482 
- for predicate logic, 248 
- for simple type theory 
- in a category, 126, 148 
- in a fibration, 150 
Generic 
- model 
- of a signature, 128 
- of a specification in predicate 
logic, 249 
- of an equational specification, 
186,208 
- object, 326, 564, 577 
split -, 322, 422 
strong -, 326 
weak -, 325 
Geometric 
- fibration, 568 
- logic, 364 
- morphism, 364, 365, 386, 568 
Girard's paradox, 582, 644, 681, 688, 692 
Global 
- element, 39, 385 
- functor, 385 

Subject Index 
751 
- section, 39 
- functor, 57, 430, 621, 636 
fibred -, 619, 620 
- smallness, 577 
Grothendieck 
- completion, 107 
- construction, 29, 107, 111 
generalised-, 517 
- topology, 355, 361, 707 
- topos, 365, 700 
Group, 31, 131, 161, 320, 601 
Abelian -, 286, 651 
internal -, 408 
- in a fibration, 208 
quotient -, 286, 650 
topological -, 408 
torsion free -, 178 
Groupoid, 30 
internal -, 412, 414 
HA, see Heyting Algebra 
Hagino 
- signature, 145, 456, 527 
- type, 145, 457 
Heyting algebra, xvi 
complete -, xvi, 239, 269, 331, 376 
Higher order 
- fibration, 330, 357, 365 
- logic, 314, 650 
- signature, 313 
full - dependent type theory, 3, 645, 
684, 688 
weak -, 688 
HML, 647, 663 
HOL, 311 
Ideal 
- in a dcpo, 153, 670 
- in a ring, 232, 311 
Identity 
- comprehension category, 627, 637 
- extension condition, 477 
- rule, 172 
- type, 584 
Image, 257 
- factorisation, 257 
stable -, 257 
Implication, 223 
Impredicativity, 442 
Indecomposable object, 636 
Indeterminate, 114, 555 
Indexed category, 50 
opposite -,112 
split -, 51 
Induction, 526 
- assumption, as algebra, 527 
- proof principle 
- in a fibration, 528 
- in terms of relations, 533 
Inequality, 13, 18 
Inhabitation, 121 
Initial 
- algebra, 162 
- with simple parameters, 164, 
168 
construction of-s, 167 
inductive -, 528, 529, 532 
- object, xiv 
strict -, 59, 63, 266 
Institution, 133, 517 
Intensional equality, 591 
Internal 
- Cartesian 
- closed category, 419, 426 
- product, 418, 429 
- adjunction, 418 
- category, 7, 10, 408 
discrete-, 411, 429, 434 
finite-, 
411 
full -, 412, 423, 424, 429, 470, 
490, 492, 564, 614, 701, 702 
full - in a fibration, 563 
indiscrete -, 421 
preorder -, 414 
- diagram, 431, 564 
parametrised -, 434 
- equaliser, 419 
- equality, 177, 192 
- existence, 255, 420 
- exponent, 419, 429 
- functor, 415 
- category, 417 
- group, 184, 408 
- in a fibration, 208 
- groupoid, 412, 414 
- injectivity, 254 
- language, 5, 8, 188, 251, 374, 409 
- of a topos, 649 

752 
Subject Index 
- logic, 192, 251 
- monoid, 439 
- natural transformation, 415 
- simple coproduct, 419 
- simple product, 419, 430 
- surjectivity, 254 
- terminal object, 418, 420, 430 
Internalisation, 428, 485 
Intrinsic property, 54, 109 
Intuitionism, 400 
Invariant, 527 
Inverse image functor, 48 
ISABELLE, 311, 442, 598 
Kind 
- context, 445 
- in full higher order dependent 
type theory, 688 
- in polymorphic dependent type 
theory, 663 
- in polymorphic type theory, 444 
Kleene 
- Normal Form Theorem, 401 
- application, xvii, 332, 334 
- in EfF, 400 
- equality, xvii 
- realisability, 240 
- star, 65 
Kleisli category, 46, 80, 117, 130, 205, 494 
fibred -, 80 
Kripke model, 236 
KZ-doctrine, 40 
Lattice, xvi 
complete -, xvi, 300 
internally -, 352 
distributive -, 167, 233 
Lawvere-Tierney topology, 354 
LCCC, see Locally Cartesian closed cat-
egory 
LEGO, 582, 595, 684, 691 
Leibniz equality, 315, 454 
Lift object, 341 
Lindenbaum algebra, 125, 154 
Local 
- exponential, 82 
- ring, 232 
Locale, xvi, 239, 516 
Localisation, 100 
Locally 
- Cartesian closed category, 39, 81, 
343, 560, 564, 583, 627, 702 
fibred -, 90, 633, 669 
- small 
- category, xiii, 428, 558 
- fibration, 559, 575, 577, 621, 
626, 701 
Logical 
- category, 266 
- framework, 7, 597 
- and internal categories, 7, 599 
Edinburgh -, 598 
Martin-L6f-, 598 
- morphism, 339 
- predicate, 518 
- relation, 505, 518, 519 
Logos, 267 
pre—, 266 
Markov's Principle, 401 
Martin-L6f type theory, 582 
Mate rule 
- for equality 
- in equational logic, 179, 181 
- in predicate logic, 229 
- for existential quantification, in 
predicate logic, 230, 234, 247 
- for product types, in polymorphic 
type theory, 453 
- for sum types, in polymorphic 
type theory, 453 
- for universal quantification, in 
predicate logic, 230, 235 
Membership, 316 
- predicate, 341 
- relation, 346 
Metric 
- predicate, 279, 329 
- space, 279, 329 
ML, 442, 455, 691 
-style polymorphism, 455 
Model 
A l - - , 150 
- of a signature, 66, 128 
- of a signature with predicates 
- in a fibration, 246 
set-theoretic -, 235 
- of a specification 

Subject 
Index 
753 
- in equational logic, 210 
- in predicate logic, 249 
generic -, 128 
- of an equational specification, 
186, 208 
Modest 
- object in EfF, 388 
- set, 39, 388 
Modification, 111 
Module, 514 
Monad, 117, 130, 205, 352, 433 
fibred -, 79, 359 
strong -, 168 
Mono, xiii 
fibration of -s, 43 
regular -, 345 
vertical -, 351 
Monoid, 70, 461, 600, 601 
commutative -, 286 
free -, 65 
internal -, 439 
Monoidal structure, 86, 619 
Monotone function, xvi 
Multifunction, 205 
Myhill-Shepherdson Theorem, 699 
Natural numbers object, 159 
- in EfF, 399, 402 
- in PER, 39 
- in cj-Sets, 39 
- with simple parameters, 159 
fibred -, 160 
weak -, 456 
Natural transformation, xiii 
fibred -, 76 
internal -,415 
vertical -, 76 
Negation, 223, 224 
- in a topos, 354 
Negative occurrence, 463 
NNO, see Natural numbers object 
Nucleus 
- in a topos, 354 
- on a fibration, 359 
- on a frame, 360 
double negation -, 354, 358 
- in Eff, 389 
NUPRL, 582 
Omega set, 33, 336 
fibration of -s 
- over EfF, 394, 631, 696, 710 
- over cj-Sets, 51, 631, 696 
On-the-nose, 73 
Opcartesian morphism, 292, 510 
- and coproducts, 545 
- and equality, 546 
Opfibration, 252, 511 
cloven -, 511 
simple -, 511 
split -, 511 
Opposite 
- category, xiii 
- fibration, 113 
- indexed category, 112 
Opreindexing, 511 
Opslice (category), 30, 292, 511, 518 
simple-, 512, 518 
Orthogonality 
- to a collection of morphisms, 260, 
677, 682 
- to an object, 469, 711 
Overloading, 71 
Parameter 
dependent -s, 165 
simple -s, 157 
Parametricity 
- and (di)naturality conditions, 484 
- and definable (co)products, 483 
- and weakly intial algebras / ter-
minal co-algebras, 483 
- in the sense of Reynolds, 443, 477, 
500 
- in the sense of Strachey, 442, 477 
relational -, 501 
Parametrised 
- diagonal, xiii, 130, 190 
- internal diagram, 434 
Partial 
- combinatory algebra, 332 
- function, 341 
- map, 342 
- classifier, 342, 633 
dense -, 360 
extension of -, 360 
Partial equivalence relation, 35, 268, 270, 
329, 337, 394, 402 

754 
Subject Index 
category of -s, 36 
- with parametric maps, 477 
decidable -, 572 
extensional -, 697 
fibration of -s 
- over Eff, 394, 425, 476, 631, 
684, 696,713 
- over PER, 631 
-over Sets, 475, 561,572 
- over PPER, 479 
- over u;-Sets, 53, 98, 424, 475, 
572, 631,670, 684,696 
internal category of -s 
- in Eff, 412, 428 
- i n Sets, 411 
- i n u;-Sets, 411, 427, 439 
PC A, see Partial combinatory algebra 
PDTT, see Polymorphic dependent type 
theory 
PDTT-structure, 667, 706 
PER, see Partial equivalence relation 
Pointed 
- family, 38 
- set, 39, 132, 188, 313, 341 
Pointwise 
- equality, 525 
- indexing, 20, 29, 32, 58, 59, 107, 
109 
Polymorphic 
- dependent type theory, 3, 645, 663 
- fibration, 471 
- predicate logic, 3, 495, 545, 552 
- signature, 449, 464, 472 
- type theory, 3, 441 
first order -, 441, 446 
higher order -, 442, 448 
logic over -, 495 
second order -, 441, 446 
Poset, xvi 
Positive occurrence, 463 
Power 
- object, 341, 346 
non-empty -, 353 
- type, 316 
PPL, see Polymorphic predicate logic 
Pre-equality, 683 
Preorder, xvi 
fibred -, 43, 174, 201 
Presheaf, 157, 432, 514, 619, 635 
- topos, 157, 340, 428, 485 
Product 
- in a comprehension category, 624 
- in a fibration, 97 
- type 
dependent-, 586 
higher order -, 448 
second order -, 446 
- wrt. a comprehension category, 
540 
- wrt. a weakening and contraction 
comonad, 537 
simple T- -, in a fibration, 148, 541 
simple -
- in a fibration, 94, 427, 437, 541 
- in an internal category, 419, 
427 
internal -, 430 
Profunctor, 514 
Projection 
- between dcpos, 638 
- in a comprehension category, 614 
- morphism, xiii 
- rule in dependent type theory, 585 
- term, 139 
dependent-,603 
subset -, 274 
Proposition 
- as object, 138 
- as type, 136, 137, 451 
- a la Howard, 597 
- a la de Bruijn, 
597 
- context, 171, 172, 224 
Pseudo 
- functor, 50 
- map of adjunctions, 91 
PTT, see Polymorphic type theory 
Pullback 
- functor, 48 
- lemma, 30 
PVS, 311, 582, 646 
QUEST, 442 
Quotient type, 14 
- in a DPL-structure, 659 
- in a fibration, 292 
effective -, 295, 296 
full -, 295, 296 
- in dependent predicate logic, 650 

Subject Index 
755 
- in simple predicate logic, 283 
effective -, 284 
full -, 284 
r.e., see Recursive enumerability 
RCCC, see Relatively Cartesian closed 
category 
Realisability 
- fibration, 241, 245, 331, 376 
- interpretation, 240 
- topos, 383, 456 
- tripos, 334 
Kleene -, 240 
higher order -, 373 
Lifschitz' -, 334 
modified -, 334, 443 
Recursive 
- enumerability, 241, 329 
- function 
partial -, xvii 
- mathematics, 400 
- subset, 329 
Reductio ad absurdum, 224, 232 
Reflection, 542, 546 
- between types and kinds, 690 
fibred -, 543, 546 
separated -, 363, 387 
Reflexive 
- closure, 289 
- coequaliser, 421 
- congruence relation, 533 
- dcpo, 153, 156, 670 
- graph,501 
- object, 156 
- in a presheaf topos, 157 
- relation, 44 
category of -s, 303 
Reflexivity 
- combinator, 196 
- rule in equational logic, 179 
Regular 
- category, 257, 297 
-epi, 261, 350, 355 
- topology, 707 
- fibration, 233, 234, 246, 374 
- logic, 227 
- mono, 46, 345 
- specification, 227 
- subobject, 46 
- classifier, 336 
- in a category of sheaves, 365 
- of a PER, 270, 337, 499 
- of a family of PERs, 499, 552 
- of a metric space, 330 
- of an a;-set, 336, 496, 697 
Reindexing, 48 
- functor, 48 
Relabelling functor, 48 
Relation, 205 
- classifier, 346 
- in a fibration, 253, 291, 524 
equivalence -, 45 
almost -, 384, 390 
effective -, 297 
partial -, 45 
extensional -, 375 
functional -, 368 
- in a fibration, 254, 265 
induction in terms of -s, 533 
logical -, 505, 518, 519 
reflexive -, 44, 303 
least - , 303 
single-valued-, 254, 304, 368, 375 
strict -, 375 
symmetric -, 44 
total -, 254, 368, 375 
transitive -, 44 
Relatively Cartesian closed category, 610, 
623 
Replacement 
- combinator, 197 
- in dependent type theory, 587 
- in polymorphic type theory, 
450 
- rule 
- in equational logic, 179 
- in predicate logic, 225 
Representable 
- fibration, 116, 325 
- functor, 351 
- presheaf, 116, 157 
Ring, 311, 650 
local -, 232 
module over a -, 514 
Saturated subset, 270, 329 
Scone, 57, 524 
Scott 

756 
Subject 
Index 
- closed, 106, 153 
- continuous, xvii 
- domain, 482, 643 
- topology, 153 
Separated 
- family, 364, 577, 709 
-1-.- -, in Eff, 396, 709 
- object, 360, 363, 371 
-.-.- -, in Eff, 390 
- reflection, 363, 387 
canonically -, 388 
Setoid, 591,623 
Setting, 686 
Sheaf, 360, 363, 371, 707 
-1-.- -, in Eff, 390 
- on a site, 361, 383 
canonically a -, 388 
family of-ves, 364, 577, 709 
Sheafification, 363 
fibred -, 366 
Sieve, 340, 355 
Signature, 64, 460 
- with predicates, 222 
fibration of -, 222 
distributive-, 144 
fibration of-s, 65, 104, 526 
Hagino-, 145, 456, 527 
heterogeneous -, 64 
higher order -, 313 
fibration of -s, 313 
homogeneous -, 64 
many-sorted -, 64 
many-typed -, 64 
polymorphic-, 449, 464, 472 
single-sorted -, 64 
single-typed -, 64, 70 
underlying -, 129 
Simple 
- T-coproduct, 149 
- T-product, 148 
- comprehension category, 614, 627 
- coproduct 
- in a fibration, 94, 427 
- in an internal category, 419, 
427 
- equality, 190 
-fibration, 41, 439, 627 
- in Fib, 555 
- in Fib(B), 551 
- over a fibration, 487, 488, 551, 
555 
- limits of type C, 436 
- opfibration, 511 
- opslice category, 512 
- parameters, 157 
- predicate logic, 3, 495 
- product 
- in a fibration, 94, 427, 437 
- in an internal category, 419, 
427,430 
- slice category, 19, 41, 165 
- type theory, 3, 119 
Simplicial object, 412 
Single-valued relation, 254, 304, 368, 375 
Singleton 
j - -, 356, 363 
- map, 341 
- predicate, 317 
- type, 138, 586 
Site, 355 
Slice (category), 19, 28 
simple -, 165 
Small 
- category, xiii, 410, 423, 430 
- complete category, 439, 467, 702 
- complete fibration, 439 
- fibration, 423, 438, 564, 578 
- limit, in a fibration, 436 
Sort, 1, 64 
Soundness 
- of a rule, 185 
- of algebraic equational logic 
- in a category, 185 
- of equational logic 
- in a fibration, 208 
- of predicate logic 
- in a fibration, 249 
Span,342, 561 
fibred -, 133, 189, 514 
Specification, 170 
algebraic-, 178, 513, 517 
equational -, 178 
first order -, 227 
higher order -, 315 
SPL, see Simple predicate logic 
Split 
- epi, 264 
- fibration, 50, 324 

Subject 
Index 
757 
- fibred adjunction, 84 
- functor, 74 
- generic object, 322, 422 
- indexed category, 51 
- opfibration, 511 
Splitting, 50 
Stack, 708 
- completion, 708 
- of families of u;-sets over Eff, 
710 
- of families of PERs over Eff, 
713 
Strength, 163 
Strengthening rule in logic, 173, 230 
Strict 
- initial object, 59, 63, 266 
- predicate, 379 
- relation, 375 
Strong 
- coproduct 
- in a comprehension category, 
624 
- wrt. a comprehension category, 
677 
fibred -, 636 
- coproduct type 
- in dependent type theory, 591 
- equality 
- in a comprehension category, 
624, 633 
- wrt. a comprehension category, 
682 
- equality type, 680 
- in dependent type theory, 589, 
590 
- functor, 163 
- generic object, 326 
- monad, 168 
- normalisation, 7, 334 
- for dependent type theory, 592 
- for polymorphic type theory, 
442 
- for simple type theory, 134 
- sum type, 675 
- in dependent type theory, 589 
STT, see Simple type theory 
Subfibration, 574, 583 
definable -, 574 
Subfunctor, 579 
Subobject, 19 
- classifier, 335 
- comprehension category, 614, 627, 
683 
- fibration, 43, 193, 201, 202, 266, 
267, 278, 297, 307, 334, 409, 
429, 627 
- in a category of sheaves, 365 
- on a family, 552 
closed -, 355 
dense -, 355 
regular -
- comprehension category, 683 
- fibration, 309 
vertical -, 351 
Subquotient, 39 
separated -, in Eff, 403 
Subset 
- term, 316 
- type 
- in a DPL-structure, 656 
- in a fibration, 274, 570 
- in dependent predicate logic, 
650 
- in simple predicate logic, 272 
full - in a fibration, 274, 410 
full - in simple predicate logic, 
273 
Substitution, 48 
- combinator, 197 
- functor, 12, 48 
- in category theory, 23 
- in type theory, xv, 123 
- lemma, 126 
- rule 
- in dependent type theory, 585 
- in equational logic, 179 
- in logic, 172 
- in simple type theory, 123, 125 
simultaneous-, 66, 125 
Subtyping, 495, 506 
Sum type 
definable -, 453, 459 
dependent-, 586 
higher order -, 448 
second order -, 446 
strong -, 675 
- in dependent type theory, 589 
very strong -, 675 

758 
Subject 
Index 
weak -, 674 
- in dependent type theory, 588 
Symmetry 
- combinator, 196 
- in polymorphic type theory, 
450 
- rule in equational logic, 179 
Term 
- as in universal algebra, 66 
- in a comprehension category, 615 
- model, 7 
- of a dependent type theory, 601 
- of a logic over polymorphic 
type theory, 497 
- of a polymorphic type theory, 
471, 481 
- of a signature, 69 
- of a simple type theory, 124 
- of dependent predicate logic, 
651,656 
- of dependent type theory, 628 
- of full higher order dependent 
type theory, 689 
- of polymorphic dependent type 
theory, 666 
- of the untyped A-calculus, 156 
Terminal 
- co-algebra 
- with simple parameters, 168 
co-inductive -, 532 
construction of -s, 167 
- object, xiii 
fibred -, 85 
indecomposable -, 636 
internal -, 418, 420, 430 
Tertium non datur, 226, 232 
Theory, 170 
- in equational logic, 181 
- of predicates, 647, 663 
first order -, 227 
Topological 
- group, 408 
- space, 209, 239, 265, 408,516 
Hausdorff -, 209 
- system, 516 
Topology 
Grothendieck -, 355 
Lawvere-Tierney -, 354 
regular epi -, 355, 707 
sup -, 355, 383 
Topos, 334, 429 
- as a DPL-structure, 654 
- as a FhoDTT-structure, 695 
- as a closed comprehension cate-
gory, 632 
- of sheaves, 365 
effective -, 376, 383 
elementary -, 339 
fibrewise -, 568 
Grothendieck -, 365, 700 
presheaf-, 157, 340, 428, 485 
realisability -, 383 
Total 
- category, 26 
Cartesian product in -, 520 
coproduct in -, 521, 567 
exponent in -, 523 
structure in -, 487 
- relation, 254, 368, 375 
Track, 33 
uniform -, 52, 54, 394 
Transition system, 513, 526 
Transitivity 
- combinator, 197 
- in polymorphic type theory, 
450 
- rule in equational logic, 179 
Tripos, 332, 374, 377 
realisability -, 334 
Truth, 223 
Tuple 
- morphism, xiii 
- term, 139 
Type, 1 
(co-)inductively defined -, 145 
- in second order polymorphic 
type theory, 456 
- context, 171, 224, 445 
- scheme, 455 
abstract -,461 
atomic -, 134 
basic -, 134 
Cartesian product -, 138 
definable -, 453, 483 
coproduct -, 140 
definable -, 453, 483 
disjoint -, 526 

Subject Index 
759 
distributive -, 142 
in polymorphic type theory, 457 
strong -, 591 
universal -, 526 
weak -, 591 
d a t a - , 7, 162, 456 
proof principles for -s, 526, 532, 
533 
disjoint union -, 591 
empty -, 141 
equality -
dependent-,586 
strong -, 589, 590, 680 
very strong -, 681 
weak -, 588, 680 
exponent-, xv 
Hagino -, 145, 457 
identity -, 584 
power -, 316 
product -
dependent-,586 
higher order -, 448 
second order -, 446 
quotient -, 283 
- in dependent predicate logic, 
650 
- in simple predicate logic, 283 
singleton -, 138, 586 
subset -
- in dependent predicate logic, 
650 
- in simple predicate logic, 272 
sum -
definable -, 453, 459 
dependent-,586 
higher order -, 448 
second order -, 446 
strong -, 589, 675 
very strong -, 675 
weak -, 588, 674 
unit -, 138, 586 
Uniformity Principle, 402 
Unique choice, 304, 371, 391 
Universal 
- colimits in a topos, 349 
- coproduct, 58, 90, 266, 637 
- in a fibration, 533 
- type, 526 
- quantification, 223 
Validity 
- of a conditional equation 
- in a category, 184 
- in a fibration, 202 
- of a predicate, 247 
- of a sequent, 247 
- of an algebraic equation, 183 
Valuation, 67 
VERITAS, 582 
Vertical 
- mono, 351 
- morphism, 26 
- subobject, 351 
Very strong 
- coproduct 
- wrt. a comprehension category, 
678 
- equality, 209, 306, 362, 371, 410 
- wrt. a comprehension category, 
682 
- equality type, 681 
- sum type, 675 
Weak 
- FhoDTT-structure, 694 
- completeness, for a fibration, 708 
- 
coproduct type, in dependent 
type theory, 591 
- coproduct, in a comprehension 
category, 624 
- equality type, 680 
- in dependent type theory, 588 
- equality, in a comprehension cat-
egory, 624 
- full higher order dependent type 
theory, 688 
- generic object, 325 
- initial algebra, 457, 458 
- natural numbers object, 456 
- sum type, 674 
- in dependent type theory, 588 
- terminal co-algebra, 457, 458 
Weakening, 24, 175, 230, 604 
- functor, 176 
- wrt, a comprehension category, 
614 

760 
Subject Index 
- wrt. a weakening and contrac- 
Well-powered 
tion comonad, 537 
- category, 351 
- rule 
- fibration, 351 
- for propositions, 172 
- for types, 172 
Yoneda 
- in dependent type theory, 585 
- Lemma 
- in simple type theory, 122 
fibred -, 323 
notation for -,176 
- functor, 428 
fibred -, 440 

