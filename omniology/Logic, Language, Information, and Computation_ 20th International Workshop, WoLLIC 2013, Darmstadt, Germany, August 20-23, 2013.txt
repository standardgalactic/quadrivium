Leonid Libkin
Ulrich Kohlenbach
Ruy de Queiroz (Eds.)
 123
LNCS 8071
Logic, Language,
Information,
and Computation
20th International Workshop, WoLLIC 2013
Darmstadt, Germany, August 2013
Proceedings
www.allitebooks.com

Lecture Notes in Computer Science
8071
Commenced Publication in 1973
Founding and Former Series Editors:
Gerhard Goos, Juris Hartmanis, and Jan van Leeuwen
Editorial Board
David Hutchison, UK
Josef Kittler, UK
Alfred Kobsa, USA
John C. Mitchell, USA
Oscar Nierstrasz, Switzerland
Bernhard Steffen, Germany
Demetri Terzopoulos, USA
Gerhard Weikum, Germany
Takeo Kanade, USA
Jon M. Kleinberg, USA
Friedemann Mattern, Switzerland
Moni Naor, Israel
C. Pandu Rangan, India
Madhu Sudan, USA
Doug Tygar, USA
FoLLI Publications on Logic, Language and Information
Subline of Lectures Notes in Computer Science
Subline Editors-in-Chief
Valentin Goranko, Technical University, Lynbgy, Denmark
Erich Grädel, RWTH Aachen University, Germany
Michael Moortgat, Utrecht University, The Netherlands
Subline Area Editors
Nick Bezhanishvili, Imperial College London, UK
Anuj Dawar, University of Cambridge, UK
Philippe de Groote, Inria-Lorraine, Nancy, France
Gerhard Jäger, University of Tübingen, Germany
Fenrong Liu, Tsinghua University, Beijing, China
Eric Pacuit, Tilburg University, The Netherlands
Ruy de Queiroz, Universidade Federal de Pernambuco, Brazil
Ram Ramanujam, Institute of Mathematical Sciences, Chennai, India
www.allitebooks.com

Leonid Libkin Ulrich Kohlenbach
Ruy de Queiroz (Eds.)
Logic, Language,
Information,
and Computation
20th International Workshop, WoLLIC 2013
Darmstadt, Germany, August 20-23, 2013
Proceedings
1 3
www.allitebooks.com

Volume Editors
Leonid Libkin
University of Edinburgh
School of Informatics
EH8 9AB Edinburgh, UK
E-mail: libkin@inf.ed.ac.uk
Ulrich Kohlenbach
TU Darmstadt
Fachbereich Mathematik
Schlossgartenstrasse 7
64289 Darmstadt, Germany
E-mail: kohlenbach@mathematik.tu-darmstadt.de
Ruy de Queiroz
Universidade Federal de Pernambuco (UFPE)
Centro de Informática
Av. Jornalista Anibal Fernandes, s/n
Cidade Universitária
50.740-560 Recife, PE, Brazil
E-mail: ruy@cin.ufpe.br
ISSN 0302-9743
e-ISSN 1611-3349
ISBN 978-3-642-39991-6
e-ISBN 978-3-642-39992-3
DOI 10.1007/978-3-642-39992-3
Springer Heidelberg Dordrecht London New York
Library of Congress Control Number: 2013943913
CR Subject Classiﬁcation (1998): F.4, I.2.3, F.3, I.1
LNCS Sublibrary: SL 1 – Theoretical Computer Science and General Issues
© Springer-Verlag Berlin Heidelberg 2013
This work is subject to copyright. All rights are reserved by the Publisher, whether the whole or part of
the material is concerned, speciﬁcally the rights of translation, reprinting, reuse of illustrations, recitation,
broadcasting, reproduction on microﬁlms or in any other physical way, and transmission or information
storage and retrieval, electronic adaptation, computer software, or by similar or dissimilar methodology
now known or hereafter developed. Exempted from this legal reservation are brief excerpts in connection
with reviews or scholarly analysis or material supplied speciﬁcally for the purpose of being entered and
executedonacomputersystem,forexclusiveusebythepurchaserofthework.Duplicationofthispublication
or parts thereof is permitted only under the provisions of the Copyright Law of the Publisher’s location,
in its current version, and permission for use must always be obtained from Springer. Permissions for use
may be obtained through RightsLink at the Copyright Clearance Center. Violations are liable to prosecution
under the respective Copyright Law.
The use of general descriptive names, registered names, trademarks, service marks, etc. in this publication
does not imply, even in the absence of a speciﬁc statement, that such names are exempt from the relevant
protective laws and regulations and therefore free for general use.
While the advice and information in this book are believed to be true and accurate at the date of publication,
neither the authors nor the editors nor the publisher can accept any legal responsibility for any errors or
omissions that may be made. The publisher makes no warranty, express or implied, with respect to the
material contained herein.
Typesetting: Camera-ready by author, data conversion by Scientiﬁc Publishing Services, Chennai, India
Printed on acid-free paper
Springer is part of Springer Science+Business Media (www.springer.com)
www.allitebooks.com

Preface
This volume contains the papers of the 20th Workshop on Logic, Language,
Information and Computation (WoLLIC 2013), which was held during August
20–23, 2013, at Fachbereich Mathematik, Technische Universit¨at Darmstadt,
Germany.
The WoLLIC series of workshops series started in 1994 with the aim of fos-
tering interdisciplinary research in pure and applied logic. The idea is to have a
forum which is large enough for dialogues between logic and the sciences relating
to information and computation, and yet small enough for eﬀective interactions
among participants.
WoLLIC 2013 received 30 submissions, from which 17 were accepted for pre-
sentation at the workshop and for inclusion in the proceedings. Each submitted
paper was reviewed by at least three members of the Program Committee, who
were assisted by 33 external reviewers. We would like to thank the members of
the Program Committee and the external reviewers for their review work, as
well as Andrei Voronkov for his EasyChair system that made the review process
and the preparation of this volume easy and smooth.
In addition to the contributed papers, the WoLLIC program contained in-
vited lectures by Natasha Alechina (University of Nottingham), Steve Awodey
(Carnegie Mellon University), Mikolaj Bojanczyk (Warsaw University), Wim
Martens (Universit¨at Bayreuth), Catuscia Palamidessi (INRIA Saclay and LIX),
and Thomas Schwentick (TU Dortmund).
We would like to thank the entire local Organizing Committee (Martin Otto,
Thomas Streicher, and Martin Ziegler from TU Darmstadt and Anjolina G.
de Oliveira from Universidade Federal de Pernambuco) for making WoLLIC
2013 a success. Last, but not least, we acknowledge the ﬁnancial support of
Technische Universit¨at Darmstadt (Fachbereich Mathematik), and the Deutsche
Vereinigung f¨ur Mathematische Logik und f¨ur Grundlagenforschung der Exak-
ten Wissenschaften (DVMLG), as well as the scientiﬁc sponsorship of the follow-
ing organizations: Technische Universit¨at Darmstadt (Fachbereich Mathematik),
Universidade Federal de Pernambuco, Brazil, Interest Group in Pure and Ap-
plied Logics (IGPL), Association for Logic, Language and Information (FoLLI),
Association for Symbolic Logic (ASL), European Association for Theoretical
Computer Science (EATCS), European Association for Computer Science Logic
(EACSL), Sociedade Brasileira de Computa¸c˜ao (SBC), and Sociedade Brasileira
de L´ogica (SBL).
May 2013
Leonid Libkin
Ulrich Kohlenbach
Ruy de Queiroz
www.allitebooks.com

Organization
Program Chair
Leonid Libkin
University of Edinburgh, UK
Program Committee
Albert Atserias
UPC Barcelona, Spain
Alexandru Baltag
University of Amsterdam, The Netherlands
St´ephanie Delaune
ENS, CNRS, France
Amy Felty
University of Ottawa, Canada
Santiago Figueira
University of Buenos Aires, Argentina
Am´elie Gheerbrant
University of Edinburgh, UK
Radha Jagadeesan
DePaul University, USA
Delia Kesner
University of Paris-Diderot, France
Benoit Larose
Concordia University, Canada
Fenrong Liu
Tsinghua University, China
Jerzy Marcinkowski
Wroclaw University, Poland
Peter O’Hearn
UCL, UK
Joel Ouaknine
Oxford University, UK
Gerald Penn
University of Toronto, Canada
Gabriele Puppis
CNRS/LaBRI - University of Bordeaux, France
R. Ramanujam
The Institute of Mathematical Sciences, India
Peter Selinger
Dalhousie University, Canada
Szymon Toru´nczyk
Warsaw University, Poland
Anna Zamansky
University of Haifa, Israel
Steering Committee
Samson Abramksy
Johan van Benthem
Anuj Dawar
Joe Halpern
Wilfrid Hodges
Daniel Leivant
Angus Macintyre
Grigori Mints
Luke Ong
Hiroakira Ono
Ruy de Queiroz
www.allitebooks.com

VIII
Organization
Additional Reviewers
Arieli, Ofer
Banerjee, Mohua
Baumann, Ringo
Berwanger, Dietmar
Bonelli, Eduardo
Boshuck, William
Brotherston, James
Bucheli, Samuel
Dapoigny, Richard
Dawar, Anuj
Demri, St´ephane
Durand, Arnaud
Fitting, Melvin
Galliani, Pietro
Gor´ın, Daniel
Hermant, Olivier
Krishnaswami, Neelakantan
Markey, Nicolas
Maubert, Bastien
Oliva, Paulo
Regnier, Laurent
Renne, Bryan
Sack, Joshua
Salvati, Sylvain
Sirangelo, Cristina
Spendier, Lara
Steedman, Mark
Valiron, Benoˆıt
van Den Berg, Benno
Waller, Emmanuel
Wansing, Heinrich
Yu, Junhua
Zawadowski, Marek
www.allitebooks.com

Table of Contents
Logic and Agent Programming Languages . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
Natasha Alechina
Natural Models of Homotopy Type Theory (Abstract) . . . . . . . . . . . . . . . .
11
Steve Awodey
Modelling Inﬁnite Structures with Atoms . . . . . . . . . . . . . . . . . . . . . . . . . . .
13
Mikolaj Boja´nczyk
Counting in SPARQL Property Paths: Perspectives from Theory and
Practice . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
29
Wim Martens
Quantitative Approaches to Information Protection . . . . . . . . . . . . . . . . . .
31
Catuscia Palamidessi
Perspectives of Dynamic Complexity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
33
Thomas Schwentick
Linear Time Proof Veriﬁcation on N-Graphs: A Graph Theoretic
Approach . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
34
La´ıs Andrade, Ruan Carvalho, Anjolina de Oliveira, and
Ruy de Queiroz
First Order Extensions of Residue Classes and Uniform Circuit
Complexity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
49
Argimiro Arratia and Carlos E. Ortiz
Quantum Probabilistic Dyadic Second-Order Logic . . . . . . . . . . . . . . . . . . .
64
Alexandru Baltag, Jort M. Bergfeld, Kohei Kishida, Joshua Sack,
Sonja J.L. Smets, and Shengyang Zhong
Structural Extensions of Display Calculi: A General Recipe. . . . . . . . . . . .
81
Agata Ciabattoni and Revantha Ramanayake
The Same, Similar, or Just Completely Diﬀerent? Equivalence for
Argumentation in Light of Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
96
Sjur Kristoﬀer Dyrkolbotn
Boolean Dependence Logic and Partially-Ordered Connectives . . . . . . . . .
111
Johannes Ebbing, Lauri Hella, Peter Lohmann, and Jonni Virtema
Extended Modal Dependence Logic EMDL . . . . . . . . . . . . . . . . . . . . . . . . . .
126
Johannes Ebbing, Lauri Hella, Arne Meier, Julian-Steﬀen M¨uller,
Jonni Virtema, and Heribert Vollmer
www.allitebooks.com

X
Table of Contents
Dependence Logic with Generalized Quantiﬁers: Axiomatizations . . . . . .
138
Fredrik Engstr¨om, Juha Kontinen, and Jouko V¨a¨an¨anen
Continuous Truth II: Reﬂections . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
153
Michael P. Fourman
A Simple Separation Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
168
Andreas Herzig
Independence in Database Relations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
179
Juha Kontinen, Sebastian Link, and Jouko V¨a¨an¨anen
Substructural Logic of Proofs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
194
Hidenori Kurokawa and Hirohiko Kushida
Full Lambek Hyperdoctrine: Categorical Semantics for First-Order
Substructural Logics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
211
Yoshihiro Maruyama
A Finite Model Property for G¨odel Modal Logics . . . . . . . . . . . . . . . . . . . .
226
Xavier Caicedo, George Metcalfe, Ricardo Rodr´ıguez, and
Jonas Rogger
Model Checking for Modal Dependence Logic: An Approach through
Post’s Lattice . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
238
Julian-Steﬀen M¨uller and Heribert Vollmer
Ockhamist Propositional Dynamic Logic: A Natural Link between PDL
and CTL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
251
Philippe Balbiani and Emiliano Lorini
Information, Awareness and Substructural Logics . . . . . . . . . . . . . . . . . . . .
266
Igor Sedl´ar
Author Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
283
www.allitebooks.com

Logic and Agent Programming Languages
Natasha Alechina
School of Computer Science
University of Nottingham
nza@cs.nott.ac.uk
Abstract. Agent programming languages based on the Belief, Desire
and Intentions (BDI) framework present some interesting challenges for
logicians. While BDI logics have been studied extensively, problems re-
lated to belief update and analysis of plans in BDI agent programming
languages have received less attention.
1
Introduction
This paper describes work in progress and proposes some possible research ques-
tions. It ﬁrst introduces main ideas of agent programming languages and then
describes some interesting open problems in agent programming language de-
sign that relate to logic, database theory and reasoning about actions. The pa-
per is targeted mainly at logicians and not at agent programming languages
researchers, and presents agent programming languages in a somewhat simpli-
ﬁed way, abstracting away from many subtle diﬀerences between them. The aim
of the paper is to encourage more logicians to investigate open problems in this
area. Most of the questions discussed in this paper arose in discussions with
agent programming languages researchers: Brian Logan, Koen Hindriks, Mehdi
Dastani and Rafael Bordini.
2
Agent Programming Languages
There are many deﬁnitions of ‘agent’ in the literature [1]. Key ideas include:
autonomy: an agent operates without the direct intervention of humans or
other agents
situatedness: an agent interacts with its environment (which may contain
other agents)
reactivity: an agent responds in a timely fashion to changes in its environment
proactivity: an agent exhibits goal-directed behaviour
Arguably the dominant agent programming paradigm is the Belief, Desire and
Intentions (BDI) model [2]. The BDI model is based on the work of Michael
Bratman [3], and views an agent as a computational system whose behaviour can
be usefully characterised in terms of propositional attitudes such as beliefs and
goals, and which is programmed in an agent programming language that makes
L. Libkin, U. Kohlenbach, and R. de Queiroz (Eds.): WoLLIC 2013, LNCS 8071, pp. 1–10, 2013.
c
⃝Springer-Verlag Berlin Heidelberg 2013
www.allitebooks.com

2
N. Alechina
explicit use of propositional attitudes. BDI agent programming languages are
designed to facilitate the implementation of BDI agents. A BDI agent program-
ming language has programming constructs corresponding to beliefs, desires and
intentions. An agent architecture or interpreter enforces relationships between
the agent’s beliefs, desires and intentions, and causes the agent to choose actions
to achieve its goals based on its beliefs. One of the ﬁrst BDI agent programming
languages was the Procedural Reasoning System (PRS) [4]. Example applica-
tions of PRS include space shuttle fault diagnosis, controlling a mobile robot,
air traﬃc control, business process control etc. PRS was very inﬂuential, with
many derivatives (e.g., PRS-CL, PRS-Lite, dMARS), and modern BDI agent
programming languages such as AgentSpeak(L) [5], CAN [6], SPARK [7], Jason
[8], 2APL [9], and Goal [10] are based on similar ideas.
The basic idea of a BDI agent programming language is that the agent’s state
contains beliefs (about the agent’s environment), goals (states the agent desires
to bring about), and plans (sequences of actions the agent intends to carry out).
Beliefs are typically represented as facts and Horn clause rules. For example, an
agent may have the following beliefs about the world:
Location(home)
Seaside(x) ←NextT o(sea, x)
Goals or desires are usually conjunctions of literals describing desired states of
aﬀairs the agent would like to achieve. For example:
Location(x) ∧Seaside(x)
is a goal to be at the seaside (x implicitly existentially quantiﬁed; any seaside
would do).
Finally, agents have a set of plans (intentions) they have adopted and are
in the process of executing. In most BDI languages plans look like imperative
programs (sequential composition, if tests and while loops) which may contain
variables in actions and tests. For example:
if (Location(x) ∧Seaside(y) ∧CheapFlight(x, y)) buyT icket(x, y); go(x, y)
This means: ﬁnd some substitution for x and y which satisﬁes
Location(x) ∧Seaside(y) ∧CheapFlight(x, y)
and then execute a sequence of actions
buyT icket(x, y); go(x, y)
for those values of x and y. The sets of beliefs, goals and plans are referred to
as the agent’s belief base, goal base and plan base.
The agent operates in a cycle:
belief update. The agent checks what is happening in the environment and
updates its belief base accordingly.

Logic and Agent Programming Languages
3
intention adoption. The agent decides, using its current beliefs and goals,
which new plans to adopt (if any), and adds them to its plan base.
intention execution. The agent decides which actions (forming part of current
intentions) to execute, and executes them.
3
Brieﬂy: BDI Logics
The development of ﬁrst agent programming languages was accompanied by
the development of BDI logics, which formalise logical relationships between
beliefs, desires and intentions. See, for example, [11, 12], and subsequent work,
for example, [13, 14].
The logics study questions such as relationships between beliefs and goals,
when a rational agent should adopt and drop intentions, should logical conse-
quences of intentions be intended, etc. These are deep questions, and the rational
properties of the relationship between, for example, beliefs and goals proposed
by diﬀerent authors are sometimes completely the opposite of each other. For
example, Cohen and Levesque [12] gave a standard possible world semantics for
BEL and GOAL modalities, requiring that goal-accessible (desirable) worlds are
a subset of belief-accessible worlds. This makes sense because of all the worlds
the agent considers possible, only some are desirable, and it does not make sense
to have desirable states which are not considered possible. This property corre-
sponds to the axiom:
BEL φ →GOAL φ
On the other hand, Rao and Georgeﬀ[11] have a more complex semantics where
possible worlds are trees (branching histories) and for each belief-accessible his-
tory, there is a goal-accessible sub-history inside it, intutitively representing those
courses of events which the agent ﬁnds desirable. Achievement goals are ex-
pressed by existential temporal formulas (there is a future state satisfying the
goal), which are preserved under extensions. This means that for an existential
temporal formula φ, the following axiom holds:
GOAL φ →BEL φ
Finally, in modern agent programming languages, achievement goals correspond
to state properties (describing a desirable state). Since it does not make sense
for the agent to intend what it already believes is achieved, the following axiom
holds:
GOAL φ →¬BEL φ
There are clearly problems associated with deﬁning beliefs and goals as standard
modalities, similar to logical omniscience in standard epistemic logics, and it is
possible to deﬁne BDI logics which do not have this problem: see, for example, [15].
There is a lot of interesting work on BDI logics, but this paper focusses on
other aspects of agent programming languages where logical reasoning is in-
volved: the belief update phase and the intention adoption phase of the BDI
agent execution cycle.

4
N. Alechina
4
Belief Update
In a typical modern BDI agent programming language, the set of beliefs is essen-
tially a deductive database. It consists of ground atoms (facts, EDB) and Horn
clause rules, which deﬁne a diﬀerent set of predicates (IDB). However, there are
extensions of programming languages such as Jason which include ontologies and
other sources of deﬁnitions in the belief base [16], and people would really like
agents to be able to do some temporal reasoning [17].
4.1
Standard Belief Update
Let us use the term ‘standard belief update’ to refer to belief update for the
case when the agent’s belief base is a deductive database, and an update is
represented as two sets of ground atoms A+ and A−(an add list and a delete
list). A+ are the facts which have become true, and A−are the facts which have
become false. The idea of course is that A+∩A−= ∅. Then the result of updating
a belief base S with (A+, A−) is S′ = (S ∪A+) \ A−. There is nothing else to do
to ensure the belief base is consistent, since the sets of EDB and IDB predicates
are disjoint and hence ‘false’ facts can not be derived from the update.
Usually, at this stage, those elements of the goal base which have become true
(derivable from the belief base) are removed from the goal base. (The reason for
this is that in case of declarative achievement goals, there is no point trying to
achieve them if they are already true.)
4.2
Standard Belief Update in the Presence of Query Caching
The intention adoption and intention execution stages may involve evaluating
queries against the agent’s belief base (and possibly goal base). If the results
of queries are cached (remembered for further use), the belief update problem
becomes less trivial (since it involves updating the cache).
First we discuss the queries which need to be evaluated and why it is a good
idea to cache them.
The intention adoption phase requires checking which plans are applicable
given the agent’s beliefs and possibly given its goals. A typical approach is to
have ‘plan adoption rules’ of the form
φ ←ψ | π
which mean ‘if query φ succeeds against the goal base, and, extending the same
substitution, query ψ succeeds against the belief base, then adopt the plan π
with the resulting substitution’. Queries are usually built from literals (where ¬
is interpreted as negation as failure, and any variables in its scope should also
appear in the query in a positive literal) using disjunctions and conjunctions.
For example:
On(x, y) ←Block(x) ∧Block(y) ∧¬(x = y) ∧Clear(x) ∧Clear(y) | stack(x, y)

Logic and Agent Programming Languages
5
The intention execution phase may require evaluating belief tests, as in the
previous example
if (Location(x) ∧Seaside(y) ∧CheapFlight(x, y)) buyT icket(x, y); go(x, y)
However, studying existing programs in various agent programming languages
suggests that the agents repeatedly evaluate the same queries in the same cycle
and across diﬀerent cycles [18], so it does make sense to cache complex derived
formulas.
Assume that in addition to the belief base S, we also have a set of cached
query results C. Each element of C is a pair (φ, θ) where φ is a query and θ is
a substitution which currently makes φ true. Depending on the agent program-
ming language, a query may return a set of answers (substitutions) or a single
substitution.
In the presence of caching, the belief update problem becomes more involved
than in the standard case, since we need to decide how to update C given S
and (A+, A−). (The result of updating S with (A+, A−) is deﬁned as before:
S′ = (S ∪A+) \ A−.) In fact we have two problems:
invalidation of cached beliefs. Given a change of belief base from S to S′,
which of the cached beliefs should be removed from C?
maintaining a complete cache. Given a change of belief base from S to S′,
are there are any new elements which need to be added to C? (In other
words, when does it make sense to re-evaluate a query to get new answers?)
The second problem occurs when we want to cache all answers to a query.
Invalidation of Cached Beliefs. The problem of invalidating cached beliefs
can be solved using well known AI reason maintenance techniques [19]. We can
keep track of which facts in S were used in deriving a particular element of C,
and store them together with the element of C whose truth depends on them.
In line with AI reason-maintenance terminology, let us call a set of literals used
to derive a certain element (φ, θ) of C an environment for (φ, θ), and the set of
all environments for (φ, θ) a label for (φ, θ). There may be several environments
in one label, for example if S contains
P(x) ←Q1(x), R(x)
P(x) ←Q2(x), R(x)
and Q1(a), Q2(a) and R(a) are all in S, then (P(x), x/a) has a label with two
environments, {Q1(a), R(a)} and {Q2(a), R(a)}. Let us say that an environment
is ‘destroyed’ if one of its elements is no longer in S. For example, if Q1(a) is
no longer in S, then {Q1(a), R(a)} is destroyed. Destroyed environments are
removed from the label. If some element of C has an empty label, it should be
removed from C, because all old ways of deriving it have disappeared from S.
This works in a straightforward way if φ is an atomic query, and it is easy
to see how to generalise this to conjunctions and disjunctions of atomic queries.

6
N. Alechina
Negations are more of a problem, since we have negation as failure which is not
stored as an explicit element of S. If we cache queries with negations, or if rules
can have negative literals in the body, we need to store negative literals in the
environments. For example, let S be
P(x) ←Q1(x), R(x)
P(x) ←Q2(x), R(x)
Q1(a), Q2(a), R(a), R(b)
and let φ be R(x) ∧¬P(x). Given S, we have
(R(x) ∧¬P(x), x/b) ∈C
and the only environment in its label is {R(b), ¬Q1(b), ¬Q2(b)}. An environment
containing both positive and negative literals is destroyed by an update (A+, A−)
if either one of its positive literals is in A−, or for some negative literal ¬L,
L ∈A+. Clearly, this cache update operation is much less computationally
expensive than a call to the inference engine. Building and maintaining labels
of cache elements in the case of only positive environments not more expensive
that a call to an inference agent to derive them in the ﬁrst place. In the case of
environments with negative elements, eﬃcient environment computation appears
to be an open problem (it is obviously do-able, but can it be done as eﬃciently
as computing positive environments?).
Maintaining a Complete Cache. The second problem (maintaining a com-
plete cache) makes sense if we want the cache to always contain all answers to a
query.
The question then is, given a set of cached queries and an update, which new
substitutions should be added? Clearly, this question can be solved in a straight-
forward way by re-deriving all the queries, but we are looking for an eﬃcient way
of at least detecting when a new call to an inference engine is required (and ide-
ally, just reducing this to a pattern matching problem on S, A+ and A−). In other
words, we need to maintain a relationship between literals and complex queries
such that if new literals of a certain form are added or removed, then a new substi-
tution should be added to a query. It is likely that to solve this problem eﬃciently
one would need to be able to compute something like a RETE or TREAT network
[20, 21] but not for Horn clause rules but for arbitrary boolean combinations of
literals and with negative literals as possible tokens.
Open problems. Here are some open problems related to cache update:
eﬃcient standard update in the presence of a cache: how to
compute
and maintain environments with negative literals, how to eﬃciently main-
tain a complete cache when the agent’s beliefs correspond to a deductive
database
extensions to the standard case: how to update the cache if an update can
contain disjunctions of literals; for which fragments of description logics and
temporal logic cache update problems can be solved eﬃciently

Logic and Agent Programming Languages
7
5
Maintaining the Plan Base
In general the agent’s plan base will contain several plans. These plans may be
executed simultaneously, e.g., in a round robin fashion or an arbitrarily inter-
leaved order. For example, the agent may be stacking blocks on several tables at
the same time, using several robotic arms or moving from table to table. In some
cases, making progress on several tasks at the same time is a good idea, while
in other cases plans may interfere in unfortunate ways. The latter problem is
intuitively clear, but how do we deﬁne a ‘rational plan base’? There are several
aspects to this notion, some to do with whether it makes sense to have several
plans for the same goal (usually not) and others to do with how much work an
agent can rationally commit to (considered at the end of this section). First, let
us clarify the notion of ‘interfering plans’.
One approach, see for example [22], considers it a bad idea to adopt plans for
conﬂicting (logically inconsistent) goals, for example a goal to be in Amsterdam
and a goal to be in Paris. A plan which involves achieving one of them will prevent
achievement of another. Whether goals conﬂict is reasonably straightforward to
check.
Another meaning of interfering plans [23–25] is that executing steps of one plan
is undoing or making impossible executing steps of another plan, even if the goals
of the two plans are consistent. For example, it is consistent to have two goals
Clean(room1) and Clean(room2) (where room1 and room2 are diﬀerent rooms
in diﬀerent directions from the agent), but most obvious plans for doing this would
involve going to room 1 and going in the opposite direction to room 2.
Consider a blocks world environment [26]. Plans which involve manipulat-
ing blocks on the same table may interfere in both senses. Two goals may be
inconsistent, for example On(a, b) and On(b, a).
An example of a situation where the goals are consistent but the plans may
interfere is as follows. Suppose we have blocks a, b, c, d and e, and a and e are
red and the rest are green. Suppose the ﬁrst goal is to have a red block on top
of two green blocks where the bottom block is on the table, and the second goal
is to have a green block on top of a red block which is on the table. Both goals
are achievable separately and even together, for example we can have
On(a, b) ∧On(b, c) ∧OnT able(c)
satisfying the ﬁrst goal, and
On(d, e) ∧OnT able(e)
satisfying the second goal. However suppose the following plans are adopted to
achieve them (for example in the state where the agent believes that all blocks
are on the table and clear):
if (OnT able(x) ∧Green(x) ∧Green(y)) stack(y, x); if (Red(z))stack(z, y)
for the ﬁrst goal and
if (OnT able(x) ∧Red(x) ∧Green(y))stack(y, x)

8
N. Alechina
If both plans generate the same substitution for picking a red block (a) then one
of them will become unexecutable, given the obvious pre- and postconditions of
the stack action (stack(x, y) is executable if x and y do not have anything on
top of them, and result in On(x, y) which means that x is on top of y).
Before formulating the problems related to checking for interference of plans,
we need some deﬁnitions.
A schedule (of a set of actions) is an assignment of actions to processors (e.g.
robotic arms) together with a linear order of each set of actions assigned to the
same processor. For example, a schedule for two robotic arms could be:
arm1 : stack(b, c) ≺stack(a, b)
arm2 : stack(b, a)
where ≺is the linear order (temporal precedence) relation.
Two actions interfere (or one of them clobbers another) if executing one of
them makes execution of another impossible; in other words, the eﬀect of the
ﬁrst action makes precondition of the second action false. In the schedule above,
stack(b, a) interferes with stack(a, b) since the precondition of stack(a, b) requires
that a has nothing on top of it, and the eﬀect of stack(b, a) is that it does.
Open problems. There are a number of problems relating to the interference
of plans, including:
plan interference: given a set of plans P and a set of pre- and postconditions
of actions in those plans, do these plans interfere?
interference-free schedule: given a set of plans P and a set of pre- and post-
conditions of actions in those plans, return a schedule (if one exists) of actions
of plans in P where action do not interfere
schedule interference: given a set of plans P, a set of pre- and postconditions
of actions in those plans, and a schedule of actions in the plans, check whether
actions in the schedule interfere
Clearly, these problems relate to planning and scheduling and can be solved using
existing methods; however it would be good to ﬁnd more eﬃcient solutions which
are tailored to plans in agent programming languages. One approach would be to
investigate special scheduling algorithms which make use of logical checks before
the plans are adopted to make scheduling an easier problem. It may also be possible
to come up with a weaker notion of an acceptable (‘almost free from interference’)
set of plans, for which the scheduling problem can be solved in polynomial time.
There are other aspects to deciding whether a set of plans the agent is commit-
ted to is ‘rational’, apart from interference of plans. For example, the goals the
agent is trying to achieve may have deadlines. Given the time required to execute
its plans, the agent may not be able to achieve all its goals, and will waste time
and energy executing plans which are certain not to achieve their goal in time. Re-
lated problems have been investigated in [27–29]. In [29], we proposed an eﬃcient
scheduling algorithm which did not return the optimal schedule (which is com-
putationally expensive) but a schedule satisfying reasonable ‘rationality criteria’.

Logic and Agent Programming Languages
9
The same algorithm was used in a plan adoption algorithm for an agent which
decides whether to commit to a set of obligations (which also have deadlines) in
[30]. However, in this area much work remains to be done, trying to ﬁnd a balance
between computationally eﬃcient and ideally rational criteria for plan schedules.
References
1. Wooldridge, M., Jennings, N.R.: Intelligent agents: Theory and practice. Knowl-
edge Engineering Review 10(2), 115–152 (1995)
2. Georgeﬀ, M., Pell, B., Pollack, M., Tambe, M., Wooldridge, M.: The Belief-Desire-
Intention model of agency. In: M¨uller, J.P., Rao, A.S., Singh, M.P. (eds.) ATAL
1998. LNCS (LNAI), vol. 1555, pp. 1–10. Springer, Heidelberg (1999)
3. Bratman, M.: Intention, Plans, and Practical Reason. Harvard University Press
(1987)
4. Georgeﬀ, M.P., Lansky, A.L.: Reactive reasoning and planning. In: Proceedings of the
Sixth National Conference on Artiﬁcial Intelligence, AAAI 1987, pp. 677–682 (1987)
5. Rao, A.S.: Agentspeak(l): Bdi agents speak out in a logical computable language.
In: Van de Velde, W., Perram, J. (eds.) MAAMAW 1996. LNCS, vol. 1038, pp.
42–55. Springer, Heidelberg (1996)
6. Winikoﬀ, M., Padgham, L., Harland, J., Thangarajah, J.: Declarative & procedural
goals in intelligent agent systems. In: Fensel, D., Giunchiglia, F., McGuinness,
D.L., Williams, M.A. (eds.) Proceedings of the Eighth International Conference
on Principles of Knowledge Representation and Reasoning (KR 2002), Toulouse,
France, pp. 470–481. Morgan Kaufmann (April 2002)
7. Morley, D., Myers, K.: The SPARK agent framework. In: Proceedings of the Third
International Joint Conference on Autonomous Agents and Multiagent Systems
(AAMAS 2004), pp. 714–721. IEEE Computer Society, Washington, DC (2004)
8. Bordini, R.H., Hubner, J.F., Wooldridge, M.: Programming Multi-Agent Systems
in AgentSpeak using Jason. Wiley (2007)
9. Dastani, M.: 2APL: A practical agent programming language. Journal of Au-
tonomous Agents and Multi-Agent Systems 16(3), 214–248 (2008)
10. Hindriks, K.V.: Programming rational agents in goal. In: El Fallah Seghrouchni, A.,
Dix, J., Dastani, M., Bordini, R.H. (eds.) Multi-Agent Programming: Languages,
Tools and Applications, pp. 119–157. Springer US (2009)
11. Rao, A.S., Georgeﬀ, M.P.: Modeling rational agents within a BDI-architecture. In:
Proceedings of the Second International Conference on Principles of Knowledge
Representation and Reasoning (KR 1991), pp. 473–484 (1991)
12. Cohen, P.R., Levesque, H.J.: Intention is choice with committment. Artiﬁcial In-
telligence 42(2-3), 213–261 (1990)
13. Wooldridge, M.: Reasoning about Rational Agents. MIT Press (2000)
14. Meyer, J.J.C., van der Hoek, W., van Linder, B.: A logical approach to the dy-
namics of commitments. Artif. Intell. 113(1-2), 1–40 (1999)
15. Alechina, N., Logan, B.: A logic of situated resource-bounded agents. Journal of
Logic, Language and Information 18(1), 79–95 (2009)
16. Mascardi, V., Ancona, D., Bordini, R.H., Ricci, A.: Cool-agentspeak: Enhancing
agentspeak-dl agents with plan exchange and ontology services. In: Boissier, O.,
Bradshaw, J., Cao, L., Fischer, K., Hacid, M.S. (eds.) Proceedings of the 2011
IEEE/WIC/ACM International Conference on Intelligent Agent Technology, IAT
2011, Campus Scientiﬁque de la Doua, Lyon, France, August 22-27, pp. 109–116.
IEEE Computer Society (2011)

10
N. Alechina
17. Bulling, N., Hindriks, K.V.: Taming the complexity of linear time BDI logics. In:
Sonenberg, L., Stone, P., Tumer, K., Yolum, P. (eds.) 10th International Conference
on Autonomous Agents and Multiagent Systems (AAMAS 2011), Taipei, Taiwan,
May 2-6, vol. 1-3, pp. 275–282. IFAAMAS (2011)
18. Alechina, N., Behrens, T., Dastani, M., Hindriks, K.V., Hubner, J., Logan, B.,
Nguyen, H., van Zee, M.: Multi-cycle query caching in agent programming. In:
Proceedings of the Twenty-Seventh AAAI Conferernce on Artiﬁcial Intelligence
(AAAI 2013), Bellevue, Washington. AAAI, AAAI Press (to appear, July 2013)
19. Doyle, J.: A truth maintenance system. Artiﬁcial Intelligence 12(3), 231–272 (1979)
20. Forgy, C.: Rete: A fast algorithm for the many pattern/many object pattern match
problem. Artiﬁcial Intelligence 19(1), 17–37 (1982)
21. Miranker, D.P.: TREAT: A better match algorithm for AI production systems.
In: Proceedings of the Sixth National Conference on Artiﬁcial Intelligence (AAAI
1987), pp. 42–47. AAAI Press (1987)
22. van Riemsdijk, M.B., Dastani, M., Meyer, J.J.C.: Goals in conﬂict: semantic foun-
dations of goals in agent programming. Autonomous Agents and Multi-Agent Sys-
tems 18(3), 471–500 (2009)
23. Thangarajah, J., Padgham, L.: Computationally eﬀective reasoning about goal
interactions. J. Autom. Reasoning 47(1), 17–56 (2011)
24. Thangarajah, J., Sardi˜na, S., Padgham, L.: Measuring plan coverage and overlap
for agent reasoning. In: van der Hoek, W., Padgham, L., Conitzer, V., Winikoﬀ, M.
(eds.) International Conference on Autonomous Agents and Multiagent Systems,
AAMAS 2012, Valencia, Spain, June 4-8, 3 vols., pp. 1049–1056. IFAAMAS (2012)
25. Shapiro, S., Sardi˜na, S., Thangarajah, J., Cavedon, L., Padgham, L.: Revising con-
ﬂicting intention sets in BDI agents. In: van der Hoek, W., Padgham, L., Conitzer,
V., Winikoﬀ, M. (eds.) International Conference on Autonomous Agents and Mul-
tiagent Systems, AAMAS 2012, Valencia, Spain, June 4-8, 3 vols., pp. 1081–1088.
IFAAMAS (2012)
26. Russell, S.J., Norvig, P.: Artiﬁcial Intelligence - A Modern Approach (3rd internat.
edn.). Pearson Education (2010)
27. Bordini, R.H., Bazzan, A.L.C., de Oliveira Jannone, R., Basso, D.M., Vicari,
R.M., Lesser, V.R.: AgentSpeak(XL): eﬃcient intention selection in BDI agents
via decision-theoretic task scheduling. In: Proceedings of the First International
Joint Conference on Autonomous Agents & Multiagent Systems, AAMAS 2002,
Bologna, Italy, July 15-19, pp. 1294–1302. ACM (2002)
28. Thangarajah, J., Padgham, L.: An empirical evaluation of reasoning about resource
conﬂicts. In: Proceedings of the Third International Conference on Autonomous
Agents and Multiagent Systems, vol. 3, pp. 1298–1299 (2004)
29. Vikhorev, K., Alechina, N., Logan, B.: Agent programming with priorities and
deadlines. In: Turner, K., Yolum, P., Sonenberg, L., Stone, P. (eds.) Proceedings
of the Tenth International Conference on Autonomous Agents and Multiagent
Systems (AAMAS 2011), Taipei, Taiwan, pp. 397–404 (May 2011)
30. Alechina, N., Dastani, M., Logan, B.: Programming norm-aware agents. In:
Conitzer, V., Winikoﬀ, M., Padgham, L., van der Hoek, W. (eds.) Proceedings
of the 11th International Conference on Autonomous Agents and Multiagent Sys-
tems (AAMAS 2012), Valencia, Spain, vol. 2, pp. 1057–1064. IFAAMAS (June
2012)

Natural Models of Homotopy Type Theory
(Abstract)
Steve Awodey
Carnegie Mellon University
Homotopy type theory is an interpretation of constructive Martin-L¨of type the-
ory into abstract homotopy theory. It allows type theory to be used as a formal
calculus for reasoning about homotopy theory, as well as more general mathe-
matics such as can be formulated in category theory or set theory, under this
new homotopical interpretation. Because constructive type theory has been im-
plemented in computational proof assistants like Coq, it also facilitates the use
of those tools in homotopy theory, category theory, set theory, and other ﬁelds of
mathematics. This is the idea behind the new Univalent Foundations Program,
which has recently been the object of quite intense investigation [4].
One thing missing from homotopy type theory, however, has been a notion of
model that is both faithful to the precise formalism of type theory and yet general
and ﬂexible enough to be a practical tool. Past attempts have relied either on
highly structured categories corresponding closely to the syntax of type theory,
such as the categories with families of Dybjer [3], which are, however, somewhat
impractical to work with semantically, or more natural and ﬂexible categorical
models based on homotopical algebra, as is done in [1,2], which however must
be equipped with unnatural coherence conditions.
In the present work, I will present a new approach which, hopefully, combines
the best of each of these two strategies. It is based on the observation that a cat-
egory with families is the same thing as a representable natural transformation
in the sense of Grothendieck. Ideas from Voevodsky [5] and Lumsdaine-Warren
are also used.
Acknowledgments. The author would like to thank the Institute for Advanced
Study, where this research was conducted. Support was provided by the Air Force
Oﬃce of Scientiﬁc Research through award FA9550-11-1-0143 and by the Na-
tional Science Foundation through award DMS-1001191. This material is based
in part upon work supported by the AFOSR and the NSF under the above
awards. Any opinions, ﬁndings, and conclusions or recommendations expressed
in this material are those of the author and do not necessarily reﬂect the views
of the AFOSR or the NSF.
References
1. Awodey, S., Warren, M.A.: Homotopy theoretic models of identity types. Math.
Proc. Camb. Phil. Soc. 146, 45–55 (2009)
2. van den Berg, B., Garner, R.: Topological and Simplicial Models of Identity Types.
ACM Transactions on Computational Logic 13(1) (2012)
L. Libkin, U. Kohlenbach, and R. de Queiroz (Eds.): WoLLIC 2013, LNCS 8071, pp. 11–12, 2013.
c
⃝Springer-Verlag Berlin Heidelberg 2013
www.allitebooks.com

12
S. Awodey
3. Dybjer, P.: Internal Type Theory. In: Berardi, S., Coppo, M. (eds.) TYPES 1995.
LNCS, vol. 1158, pp. 120–134. Springer, Heidelberg (1996)
4. Homotopy Type Theory: Univalent Foundations of Mathematics, The Univalent
Foundations Program, Institute for Advanced Study (2013),
http://homotopytypetheory.org/book
5. Kapulkin, C., LeFanu Lumsdaine, P., Voevodsky, V.: The Simplicial Model of Uni-
valent Foundations (in preparation, 2013)

Modelling Inﬁnite Structures with Atoms
Mikolaj Boja´nczyk⋆
University of Warsaw
Abstract. The topic is a variant of ﬁrst-order logic deﬁned in the frame-
work of sets with atoms, which allows formulas to use orbit-ﬁnite boolean
operations. The main contribution is a notion of model for this logic,
which admits the compactness theorem.
1
Introduction
This paper studies a variant of ﬁrst-order logic in sets with atoms (also known as
nominal sets, also known as Fraenkel-Mostowski sets, also known as permutation
models). The logic was introduced in [3], its intention is to describe properties
of objects such as data words, data trees, or data graphs. The focus of [3] was
the study of ﬁnite models, i.e. the logic made most sense for ﬁnite data words,
ﬁnite data trees, and ﬁnite data graphs. When studying inﬁnite objects, such
as inﬁnite data words, the approach from [3] runs against diﬃculties, e.g. the
compactness theorem does not hold. The goal of this paper is a more thorough
model-theoretic study of that logic, with a focus on the problems with inﬁnite
structures. This paper proposes a diﬀerent semantics of ﬁrst-order logic than
the one in [3], which admits compactness, and has a sound and complete proof
system.
Apart from the technical results on the logic, this paper discusses how to
model and how not to model objects that talk about inﬁnitely many atoms, while
respecting the ﬁnite support constraint in the deﬁnition of sets with atoms. The
running example in this paper is inﬁnite data words: how can they be modelled
using sets with atoms, and how logics can be used to express their properties.
2
Sets with Atoms
Sets with atoms were introduced in set theory by Fraenkel in 1922 and rediscov-
ered for the computer science community, by Gabbay and Pitts [5]. Sets with
atoms are now widely studied in the semantics community, under the name of
nominal sets, see the book [9]. This paper is part of a research programme which
studies a notion of ﬁniteness which only makes sense in sets with atoms, called
“orbit-ﬁniteness”. The research programme is to see what happens to discrete
mathematics when sets are replaced by sets with atoms, and ﬁniteness is replaces
by orbit-ﬁniteness. Two examples of this research programme include the study
of ﬁnite automata in [2], and the study of programming languages [4].
⋆Author supported by ERC Starting Grant “Sosna”.
L. Libkin, U. Kohlenbach, and R. de Queiroz (Eds.): WoLLIC 2013, LNCS 8071, pp. 13–28, 2013.
c
⃝Springer-Verlag Berlin Heidelberg 2013

14
M. Boja´nczyk
What are sets with atoms? Sets with atoms are an extended notion of a set –
such sets are allowed to contain “atoms”. The existence of atoms is postulated
as an axiom. The key role in the theory is played by automorphisms of atoms.
For instance, if a, b, c, d are atoms, and the atoms have no structure except for
equality, then the sets
{a, {a, b, c}, {a, c}}
{b, {b, c, d}, {b, d}}
are equal up to automorphisms of atoms. If the atoms are real numbers, equipped
with the successor relation x = y + 1 and linear order x < y, then the sets
{−1, 0, 0.3}
{5.2, 6.2, 6.32}
are equal up to automorphism of the atoms, but the sets
{0, 2}
{5.3, 8.3}
are not.
The formal deﬁnition is parametrized by a notion of atoms, which is given
as a relational structure, and induces a notion of automorphism. (One can also
consider atoms with function symbols, but we do not do this here.) A set with
atoms is any set that can contain atoms or other sets with atoms, in a well-
founded way1. The key notion is the notion of a legal set of atoms, deﬁned
below. Suppose that X is a set with atoms. If π is an automorphism of atoms,
then π can be applied to X, by renaming all atoms that appear in X, and appear
in elements of X, and so on. We say that a set S of atoms is a support of the
set X if X is invariant under every automorphism of atoms which is the identity
on S. (For instance, the set of all atoms is supported by the empty set, because
every automorphism maps the set to itself.) A set with atoms is called legal if it
has some ﬁnite support, each of its elements has some ﬁnite support, and so on
recursively.
Orbit-ﬁniteness. Sets with atoms are a good abstraction for some inﬁnite systems
because they have a more relaxed notion of ﬁniteness, which requires ﬁnitely
many elements, but only up to automorphisms of atoms. More precisely, we say
that a set with atoms X is orbit-ﬁnite if it is included in a union of ﬁnitely many
single-orbit sets. A single orbit set is obtained from an element x (which may
itself be a set) by applying all possible atom automorphisms.
Consider for example sets with atoms where the atoms have no structure, and
therefore automorphisms are arbitrary permutations. The set of atoms itself is
orbit-ﬁnite, actually has only one orbit, because every atom can be mapped to
every other atom by a permutation. Likewise, the set of pairs of atoms has two
elements up to permutation, namely (a, a) and (a, b) for a ̸= b. The set of triples
of atoms has ﬁve orbits: all coordinates are equal, all coordinates are distinct,
and three orbits where exactly two coordinates are equal.
1 Formally speaking, sets with atoms are deﬁned by induction on their rank, which is
an ordinal number. Sets of a given rank can contain atoms and sets of lower rank.

Modelling Inﬁnite Structures with Atoms
15
Homogeneous structure. A structure is called homogeneous if every ﬁnite partial
automorphism (i.e. an isomorphism between two ﬁnite substructures) can be
extended to a full automorphism. Examples of homogeneous structures include:
the natural numbers with only equality (we call this the equality atoms), and
the ordered rational numbers (we call this the total order atoms). We assume
in this paper that the atom structure is a countable homogeneous relational
structure over a ﬁnite relational vocabulary. This guarantees that the notion of
orbit-ﬁniteness is relatively well behaved, e.g. orbit-ﬁnite sets are closed under
ﬁnite Cartesian products and ﬁnitely-supported subsets.
3
First-Order Logic and Flat Models
The topic of this paper is a study of ﬁrst-order logic in sets with atoms. In this
section, we take a ﬁrst attempt at deﬁning ﬁrst-order logic and the models that
it will be evaluated in. Later in the paper, we will present more sophisticated
versions of both the logic and the models.
We are interested mainly in legal sets with atoms, and therefore we adopt
the convention that, unless otherwise stated, all sets with atoms are implicitly
assumed to be legal, such as in the following deﬁnition. The deﬁnition of vo-
cabulary is the same as usual, only sets are required to be sets with atoms. A
vocabulary is any set with atoms Σ, whose elements are called predicates, to-
gether with a ﬁnitely supported arity function, which maps predicates of Σ to
their arities, which are natural numbers. We will write Σn for the set of n-ary
predicates, i.e. the inverse image of n under the arity function. In this paper, we
only study countable vocabularies.
Running example. [A vocabulary for describing data words] In a running ex-
ample, we will talk about inﬁnite data words. The idea is to model an ω-word
(i.e. positions are the natural numbers) where each position is labelled by an
atom. The vocabulary for this will contain one binary predicate x < y (which
will be used to order the positions), and one unary predicate a(x) for every atom
a ∈A (which will be used to determine the labels of the positions). Observe that
this vocabulary is inﬁnite, but orbit-ﬁnite. The predicate x < y is a singleton
orbit, while all the predicates a(x) are in the same orbit.
□
3.1
Flat Models and Stand First-Order Logic
Flat models. A ﬂat model is obtained by taking the standard deﬁnition of a
model and interpreting it in sets with atoms. As we shall later see, this notion
of model does not behave as well as the standard notion of model.
A ﬂat model A over a vocabulary Σ consists of
– A set with atoms A called the universe of the model.
– For every predicate R ∈Σ, an interpretation RA ⊆Aarity(n).
A ﬂat model is a special case of a set with atoms (it is a pair of a set and
a set of interpretations functions). In this special case, legality means: a) the

16
M. Boja´nczyk
universe should be ﬁnitely supported; b) for every R, the set RA should be
ﬁnitely supported; and c) the function R →RA must also be ﬁnitely supported,
as a function from the vocabulary to sets of tuples of elements in the universe.
However, legal ﬂat models turn out to be so weak that we will consider possibly
illegal ﬂat models in some constructions. That is why, for ﬂat models, we make
an exception to the convention that every object is implicitly legal, and explicitly
write “legal ﬂat model” or “possibly illegal ﬂat model”.
Running example. [Legal ﬂat model describe only data words with ﬁnitely many
atoms] Consider an inﬁnite word over the alphabet of the atoms
w = a1a2 · · · ∈Aω.
Such a word is a function from natural numbers to atoms. In this case, legality
means that only ﬁnitely many diﬀerent atoms can appear in the word.
Based on the word w, we can deﬁne a ﬂat model, denoted by w, as follows.
The universe is the natural numbers, with < is interpreted as the usual order
on natural numbers. For every atom a ∈A, the interpretation aw is the set of
positions in w that have label a. It is not diﬃcult to see that w is a ﬂat model,
which is legal as long as w was legal.
What would happen if we tried to deﬁne w for a word w with inﬁnitely many
diﬀerent atoms? For instance, what about a word that is an enumeration of
all atoms (i.e. every atom appears on exactly one position)? For such a word,
every individual predicate interpretation aw is a ﬁnitely supported set, namely
it contains one natural number (the number of the atom a in the enumeration).
What is wrong is that the function
a ∈A
→
aw ⊆N
is not ﬁnitely supported.
□
First-order logic. To express properties of ﬂat models, we can use standard ﬁrst-
order logic. Formulas can be built out of the predicates in the vocabulary, using
standard logical operations ∨, ∧, ¬, ∃and ∀. Semantics in ﬂat models are deﬁned
in the standard way, by induction on the structure of formulas. This deﬁnition
ignores the additional structure of ﬂat models and vocabularies, namely the
possibility of acting on both by using atom automorphisms.
Running example. [First-order deﬁnable properties of data words] Suppose taht
a is an atom, and consider the formula
∀x∃y
x < y ∧a(x).
When evaluated in a structure of the form w, as deﬁned in Example 3.1, the
formula says that the atom a appears inﬁnitely often.
□
A single formula of ﬁrst-order logic can only use only ﬁnitely many predicates
from the vocabulary. Therefore, as far as using a single formula of the logic is
concerned, it makes little sense to have a ﬂat model specify the interpretations of

Modelling Inﬁnite Structures with Atoms
17
all predicates in an inﬁnite vocabulary. The inﬁnite vocabulary does make sense
when we consider an inﬁnite set of formulas, as we will do in the Section 3.2, or
when we consider a variant of ﬁrst order-logic that admits orbit-ﬁnite boolean
operations, as we will do starting with Section 4.
3.2
Compactness Fails in Legal Flat Models
We have already identiﬁed one problem with legal ﬂat models: they can only
model data words with ﬁnitely many distinct atoms, which means they are in-
suﬃcient to model interesting data words. Here we identify another, related,
problem: the compactness theorem fails.
Running example. [Compactness Fails for Legal Flat Models.] Let ϕ< be a for-
mula which says that < is a linear order. Let Γ be the following set of formulas:
{ϕ<}
∪
{∃x a(x)}a∈A
∪
{∀x a(x) ⇒¬b(x)}a̸=b∈A.
When seen as an inﬁnite conjunction of formulas, the set Γ says that every atom
appears exactly once as a label of a position. Observe that Γ is inﬁnite, but orbit-
ﬁnite (three orbits). We will show that every ﬁnite subset of Γ is satisﬁable in a
legal ﬂat model, but Γ itself is not, and therefore compactness fails for legal ﬂat
models.
Every ﬁnite subset Δ ⊆Γ is satisﬁable in a ﬁnite linear order where the
positions are labelled by the atoms that appear in Δ.
To prove that the whole set Γ has no legal ﬂat model, imagine for the sake of
contradiction that it does have a legal ﬂat model A. Suppose that S is a ﬁnite
support of the model. Based on the model, we deﬁne a relation <A on atoms as
follows: a <A b if there are elements x, y in the universe of the model A such
that
x ∈aA
y ∈bA
x <A y.
The function A →<A is a ∅-supported function from legal ﬂat models to relations
on the atoms, and therefore if A is ﬁnitely supported then also <A is ﬁnitely
supported. By the properties axiomatised in Γ, the relation <A must be a linear
order on atoms. But a ﬁnitely supported linear order on the (equality) atoms
does not exist. Indeed, if S were the support of such an order, then for atoms
a, b ̸∈S, the automorphism π which swaps a with b ﬁxes all atoms in S, and
witnesses
a <A b
iﬀ
b = π(a) <A a = π(b).
This proves that Γ has no legal ﬂat model.
Observe that the reasoning above is speciﬁc to the equality atoms (because we
assumed that there is some automorphism that ﬁxes S and swaps atoms a and
b). Indeed, the set Γ does have a legal ﬂat model when the total order atoms
are used. The universe is the atoms, ordered by their built-in order, and the
interpretation says that each atom is labelled by itself,
aA = {a},

18
M. Boja´nczyk
which is an ∅-supported interpretation. The model we have just described is
not a data word because the positions are densely ordered. If we extended the
formula ϕ< to also say that every position has a successor, then we would have
an example for failure of compactness in the total order atoms, because the total
order atoms cannot be ordered in a ﬁnitely supported way so that every atom
has a successor.
□
The failure of compactness is actually related to the weak modelling power of
legal ﬂat models. Indeed, as illustrated in the example, the compactness theorem
would imply that some legal ﬂat model represents a data word where all positions
have diﬀerent data values.
The statement of the compactness theorem, for which we presented a coun-
terexample above, would be: “if every ﬁnite subset of Γ has a legal ﬂat model,
then also Γ has a legal ﬂat model.” One could imagine a weaker form the theo-
rem, with a stronger assumption: “if every orbit-ﬁnite subset of Γ has a legal ﬂat
model, then also Γ has a legal ﬂat model.” The counterexample above no longer
works, because the set Γ, which has no legal ﬂat models, is already orbit-ﬁnite
itself. The weaker statement is also false.
Running example. [Orbit-ﬁnite compactness also fails for legal ﬂat models.] Let
ϕsucc be a formula which says that every element has a <-successor:
∀x∃y

x < y ∧∀z (z ≤x ∨z ≥y)

.
For n ∈N, deﬁne succn(x, y) to be the formula which says that y is the n-fold
successor of y. For every n ∈N, deﬁne Γn to be the set of formulas, which says
that positions at distance n have diﬀerent labels:
{∀x∀y succn(x, y) ⇒¬(a(x) ∧a(y))}a∈A.
Deﬁne Γ to be ϕ<, ϕsucc, together with the union of all Γn. We claim that every
orbit-ﬁnite subset of Γ has a legal ﬂat model, but Γ itself has no legal ﬂat model.
For an orbit-ﬁnite subset Δ ⊆Γ, let n be the biggest number such that
Γn ∩Δ ̸= ∅.
We deﬁne the model for Δ to be the ultimately periodic data word, which uses
n + 1 atoms a1, . . . , an+1 in a periodic arrangement.
To prove that Γ itself has no legal ﬂat model, use a reasoning similar to the
one in the previous example. Choose some element x1 of the universe, and let
a1 be its (unique) label. By following successors, we get inﬁnitely many distinct
atoms a2, a3, . . . together with a linear order.
□
4
First-Order Logic with Orbit-Finite Boolean
Operations
This section, presents another variant of ﬁrst-order logic, which was introduced
in [3]. The motivation behind this logic is two-fold. First, the logic is more
expressive. Second, it is a natural variant of ﬁrst-order logic consistent with
the paradigm of replacing “ﬁnite” by “orbit-ﬁnite”. The central question of this
paper is ﬁnding the right semantics for this richer logic.

Modelling Inﬁnite Structures with Atoms
19
Deﬁnition of the logic. Since the vocabulary is a set with atoms, it makes sense to
apply atom automorphisms to predicates in the vocabulary, and therefore also to
formulas built out of these predicates. Therefore it makes sense to say that a set
of formulas is orbit-ﬁnite. Suppose that we extend ﬁrst-order logic, as deﬁned
previously, by allowing the boolean connectives (disjunction and conjunction)
to take range over a (legal) orbit-ﬁnite set of formulas. Call the resulting logic
ﬁrst-order logic with orbit-ﬁnite boolean operations.
Observe that ﬁrst-order logic with orbit-ﬁnite boolean operations can be seen
as a fragment of Lω1ω. Recall that Lω1ω is a variant of ﬁrst-order logic which
allows boolean operations ranging over countable sets of formulas. Since the
atoms are assumed to be countable, orbit-ﬁnite sets are also countable, and
therefore our logic is a special case of Lω1ω. One of the diﬀerences is that Lω1ω
has uncountably many formulas, while there are only countably many formulas
of ﬁrst-order logic with orbit-ﬁnite boolean operations (under the assumption
that the vocabulary is countable).
Example 1. Suppose that the vocabulary has one unary predicate a(x) for every
atom a, as in the running example. We write a formula with one free variable
x, which holds in positions that satisfy at most one unary predicate of the form
a(x).
For an atom a, consider the set of formulas
Γa
def
= {¬b(x) : b ̸= a}.
This set is legal (supported by a), and also orbit-ﬁnite (it is included in the
single-orbit set {a(x) : a ∈A}). Therefore, we are allowed to form a new formula
by taking the disjunction over Γa. We adopt a notational convention where this
formula is denoted by
ϕa
def
=

b∈A−{a}
¬b(x).
Generally speaking, the notational convention says that if I is an orbit-ﬁnite set
and i →ϕi is a ﬁnitely supported function from I to already deﬁned formulas,
then 
i∈I ϕi denotes the formula {ϕi : i ∈I}.
To the formula ϕa, we can also apply an atom automorphism, by applying the
automorphism to every conjunct in parallel. It is not diﬃcult to see that if an
atom automorphism maps the atom a to the atom a′, then it maps the formula
ϕa to the formula ϕa′. It follows that the set
Γ
def
= {ϕa : a ∈A}
is itself orbit-ﬁnite, namely it is one orbit under the action of automorphisms.
Therefore, we are allowed to form a new formula by taking the disjunction over
this set. This formula, according to our notational convention, is denoted by

a∈A

b∈A−{a}
¬b(x).
It says that position x satisﬁes at most one predicate of the form a(x).

20
M. Boja´nczyk
Semantics. As mentioned above, the central question of this paper is about the
“right” semantics of ﬁrst-order logic with orbit-ﬁnite boolean operations.
One idea for the semantics is to use ﬂat models. A formula of ﬁrst-order logic
with orbit-ﬁnite boolean operations can be evaluated in a ﬂat model, be it legal
or not. The deﬁnition is standard, and can be seen as a special case of logics
with inﬁnitary boolean operations: 
i∈I ϕi is true in a ﬂat model (under an
appropriate evaluation of the free variables) if and only if ϕi is true for some i;
likewise for .
Running example. Recall the set of formulas Γ from Example 3.2, which said
that the universe is totally ordered, every atom a labels some position, and every
position is labelled by at most one atom. In the example, we showed that there
is no legal ﬂat model which satisﬁes all formulas from Γ. Since Γ is orbit-ﬁnite,
its conjunction  Γ is a well-formed formula of ﬁrst-order logic with orbit-ﬁnite
boolean operations. This formula is not satisﬁed in any legal ﬂat model. On the
other hand, the formula can be satisﬁed in illegal ﬂat models, e.g. a model of
the form w where w is an enumeration of all atoms.
□
So far, we have two candidates for the semantics: satisﬁability in legal ﬂat mod-
els, and satisﬁability in possibly illegal ﬂat models. The ﬁrst deﬁnition fails the
compactness theorem, while the second deﬁnition uses notions that are not al-
lowed in sets with atoms (as we shall later see, the second deﬁnition does admit
the compactness theorem). The rest of this paper presents arguments in favour
of the second deﬁnition. Section 5, presents a proof system which is sound and
complete for the second deﬁnition. Section 6 deﬁnes stratiﬁed models, which are
legal objects that satisfy the same formulas as possibly illegal ﬂat models.
Diﬀerences with [3]. The syntax of ﬁrst-order logic with orbit-ﬁnite boolean
operations and its semantics are the same as in [3], except that [3] made the
following restrictions, which are lifted in this paper:
– In [3], all elements in the universe of a relational structure are required to
have empty support, which means that if x is an element of the universe and
π is an atom automorphism, then π(x) = x.
– In [3], there is a ﬁnite partition Σ = Σ1 ∪· · · ∪Σn of the vocabulary vocab-
ulary. For every block Σi all predicates in Σi have the same arity, call it ni,
and a given ni-tuple can satisfy at most one predicate from Σi.
5
A Proof System
Consider sequent calculus, with the only diﬀerence being that the rules for
Boolean operations are adapted to cover the orbit-ﬁnite arity of the operations.
The rule for introducing ∨becomes
Γ ⊢ϕi, Δ
for some i ∈I
Γ ⊢
i∈I ϕi, Δ
(introduce ∨),

Modelling Inﬁnite Structures with Atoms
21
while the rule for eliminating ∨requires an orbit-ﬁnite set of premises
Γ, ϕi ⊢ψ, Δ
for all i ∈I
Γ, 
i∈I ⊢ψ, Δ
(eliminate ∨).
A proof is deﬁned to be a well-founded tree2, where nodes are labelled by se-
quents. Every node and its children must be consistent with one of the proof
rules in the standard way, with one subtle diﬀerence to be described later. The
tree together with the labelling by sequents must be ﬁnitely supported, i.e. a
legal set with atoms. Note that the requirement on the proof tree being ﬁnitely
supported implies that if a node in the proof tree has an orbit-ﬁnite set of chil-
dren proving diﬀerent sequents, then the dependence of the sub-proof on the
sequent must be ﬁnitely supported.
The subtle diﬀerence in the deﬁnition of proofs concerns the proof rules that
require their premise to be true for “some i ∈I”, namely the proof rules “in-
troduce ∨” and “eliminate ∧”. As opposed to the standard sequent calculus, a
proof in our system is allowed to have some redundancy, by proving the premise
for more than one i ∈I. In other words, a more exact wording for the “introduce
∨” rule would be
Γ ⊢ϕi
for all i in a nonempty subset of I
Γ ⊢
i∈I ϕi
(introduce ∨).
The need for redundancy is illustrated in the following example.
Example 2. Consider the total order atoms. This example is essentially in propo-
sitional logic, since all predicates have arity zero. The vocabulary has one zero-
ary predicate Pa,b for every pair of distinct atoms a < b; the vocabulary has one
orbit. We prove the following sequent

a∈A

b∈A,b>a
Pa,b
⊢

a∈A

b∈A,b>a
Pa,b.
(1)
We use the rule for introducing ∧, which means that the root of the proof tree
for (1) has one child per atom a ∈A, containing a proof of the sequent

a∈A

b∈A,b>a
Pa,b
⊢

b∈A,b>a
Pa,b.
(2)
Since the proof for (1) must be legal, the proof (2) must depend on a in a ﬁnitely
supported way. (More precisely, the function that maps a to the proof of (2) must
be a ﬁnitely supported function from atoms to proofs). This is why we can not
choose, for every a, some unique b ̸= a, because this can not be done in a ﬁnitely
2 Without orbit-ﬁnite boolean operations, one can also use proofs which are sequences
of sequents, such that each sequent follows from earlier sequents via proof rules.
Such proofs will not work with orbit-ﬁnite operations, since in some cases they
would require imposing a linear order on the atoms.
www.allitebooks.com

22
M. Boja´nczyk
supported way. (This is why we use total order atoms. In the equality atoms,
there is a ﬁnitely supported, but not emptily supported, function that maps
every atom to some other atom. Namely, choose two atoms b1, b2, and then that
maps b1 to b2 and all other atoms to b1.) Therefore, the proof of (2) will have
one child per b > a, containing a proof of

a∈A

b>a
Pa,b
⊢
Pa,b.
(3)
In particular, the proof for (2) has inﬁnitely many child sub-proofs (although
one orbit of them), even though just one would be enough.
The deﬁnition of a proof requires the tree to be well-founded; but there might be
paths of unbounded length since the tree is not ﬁnitely branching (only orbit-
ﬁnitely branching). One can show that if a sequent has a proof, then it has
a proof with an orbit-ﬁnite set of nodes, and depth bounded by some natural
number.
Completeness and compactness. The following theorem shows that the proof
system is sound and complete with respect to semantics in (possibly illegal) ﬂat
models.
Theorem 1 (Completeness). Let Γ be a ﬁnitely supported set of sentences
of ﬁrst-order logic with orbit-ﬁnite boolean operations, and ϕ a single sentence.
There is a proof of Γ ⊢ϕ if and only if ϕ is satisﬁed in every (possibly illegal)
ﬂat model which satisﬁes all sentences from Γ.
The theorem can be proved using the Henkin constant saturation method, to
be found in logic textbooks, e.g. [1]. Below we show that the logic also has
compactness. Note the diﬀerence with Lω1ω, which has completeness (under
the assumption that Γ is countable), but does not have compactness (even for
countable Γ), see [8].
Corollary 1 (Compactness). Let Γ be a ﬁnitely supported set of sentences of
ﬁrst-order logic with orbit-ﬁnite boolean operations. If every orbit-ﬁnite subset
of Γ is satisﬁed by a (possibly illegal) ﬂat model, then also Γ is satisﬁed by a
(possibly illegal) ﬂat model.
Proof (sketch). Toward a contradiction, assume that Γ is not satisﬁed by any
(possibly illegal) ﬂat model. Then, by the right-to-left implication in Theorem 1,
there is a proof of Γ ⊢⊥. As remarked before, this proof can be chosen so that it
is orbit-ﬁnite, and therefore only uses an orbit-ﬁnite number of premises from Γ.
By the left-to-right implication in Theorem 1, these premises cannot be satisﬁed
in any (possibly illegal) ﬂat model, a contradiction with the assumption.
Example 3. In Corollary 1, the assumption is that all orbit-ﬁnite subsets of Γ
are satisﬁed by (possibly illegal) ﬂat models. The statement is no longer true
when this assumption is weakened to ﬁnite subsets. Consider a set Γ of formulas
which has one formula Pa for every atom, and also the formula 
a∈A ¬Pa. Every
ﬁnite subset of Γ is satisﬁed by a ﬂat model, even a legal one. The whole set is
not satisﬁed in any (possibly illegal) ﬂat model.

Modelling Inﬁnite Structures with Atoms
23
6
Stratiﬁed Models
As we have seen in Theorem 1, the “natural” proof system coincides with the
semantics in possibly illegal ﬂat models3. In this section, we present an alterna-
tive semantics, which only uses legal sets with atoms, and which is equivalent to
the semantics in possibly illegal ﬂat models, and therefore is equivalent to the
proof system4.
The general idea is to present a possibly illegal ﬂat model by giving a set of
ﬁnitely supported local versions of the model. A local version does not contain
full information about the model, but it does have suﬃcient information to
evaluate formulas with a given support. When one needs to evaluate formulas
with a bigger support, then a more precise local view can be taken. The local
views need to be consistent with each other; our notion of consistency is modelled
using a variant of directed sets, as presented below.
6.1
Ultimately Directed Sets
Suppose that V is a partially ordered legal set with atoms, which means that
both the underlying set and the partial order are legal sets with atoms. If S is
a set of atoms, then we say that v ∈V is S-greater than w ∈V if π(v) ≥w
holds for some automorphism π that ﬁxes S. We say that V is S-directed if for
every two elements of v1, v2 ∈V , some element of v ∈V is S-greater than both
of them. This deﬁnition is illustrated below:
The bigger S becomes, the more diﬃcult it is to be S-directed, because of the
requirements on π1 and π2. The standard notion of directed set is recovered in
the limit, when S is the set of all atoms.
Deﬁne V |≥v to be V restricted to elements that are greater or equal to v. A
set V is called ultimately directed if for every v ∈V and every ﬁnite set of atoms
S, there is some w ≥v such that V |≥w is S-directed.
Example 4. Consider the equality atoms. The set A∗with the preﬁx ordering is
not ∅-directed, because the words aab and abb cannot be extended to words in the
same orbit. If we restrict A∗to words where each letter appears exactly once, call
this set A(∗), then the set becomes ∅-directed; it even has a stronger property:
3 The dual approach would be to ﬁnd a proof system that coincides with the semantics
in legal ﬂat models. It seems that this is the approach taken in [6], although for a
diﬀerent (and intuitionistic) logic, so the exact connection is not clear to the author.
4 Another idea would be to somehow relax, but not completely lift, the ﬁnite support
condition in the deﬁnition of sets with atoms so that some interesting illegal ﬂat
models become legal. Such an approach is pursued in [7].

24
M. Boja´nczyk
every two elements are comparable up to atom automorphisms. Furthermore,
if a1 · · · an is a ﬁnite word in A(∗), then A(∗)|≥a1···an is {a1, . . . , an}-directed. It
follows that A(∗) is ultimately directed.
Example 5. This example generalises the previous one to arbitrary atom struc-
tures, e.g. the total order atoms. Choose some non-repeating enumeration of the
atoms a1a2 · · · . We claim that
V = {π(a1 · · · an) : n ∈N, π is an atom automorphism.},
equipped with the preﬁx order, is ultimately directed. (Although the enumera-
tion of atoms is not a legal object, the set V that it yields is.) It is not diﬃcult
to see that for every b1 · · · bn ∈V , the set V |≥b1···bn is S-directed if and only if
S ⊆{b1, . . . , bn}. This implies that V itself is ultimately directed.
Actually, we did not even use the property that a1a2 · · · was an enumeration
of all atoms, it could even have been an enumeration of some inﬁnite subset of
the atoms. However, when the enumeration does use all the atoms, it has the
following property: for every v ∈V and every ﬁnite set of atoms S, there is some
node w ≥v such w supports all the atoms in S (i.e. an automorphism of the
atoms that ﬁxes w must also ﬁx all atoms in S). This additional property will
be useful in some constructions.
A disadvantage of the previous example was that it required some enumeration
of the atoms, which is an illegal object. This can be avoided by using a hack
called a fake atom structure. A fake atom structure is deﬁned to be an isomorphic
copy of the atom structure, but where all elements of the universe have empty
support. In particular, even inﬁnite subsets of fake atom structure are legal.
Example 6. Consider the equality atoms. Recall the standard set-theoretic en-
coding of natural numbers, where for instance 2 is encoded by {∅, {∅}}. Each
natural number is built without using atoms, and therefore the relational struc-
ture (N, =) is an example of a fake atom structure for the equality atoms: it is
constructed inside legal sets with atoms, does not use atoms, but is isomorphic to
the atom structure (a countable set of abstract atoms with equality only). Note
that any isomorphism of this fake atom structure with the real atom structure
would itself be an illegal object, since it would in particular induce an order on
the atoms.
Example 7. Choose some fake atom structure, and let V be the set of isomor-
phisms between ﬁnite substructures of the fake atoms, and ﬁnite substructures of
the atoms, ordered by extension. One can think of a partial isomorphism f ∈V
as a ﬁnite tuple of atoms, indexed by ﬁnitely many many elements from the
universe of the fake atom structure.
Claim. For every f ∈V with range S, V |≥f is S-directed.
The claim implies that V is ultimately directed. This is because for every ﬁnite
set of atoms S, every element of V can be extended so that its range includes S.

Modelling Inﬁnite Structures with Atoms
25
6.2
Stratiﬁed Models
We now propose our deﬁnition of models which will turn out to be equivalent
to (possibly illegal) ﬂat models. Let S be a ﬁnite set of atoms. An S-stratiﬁed
model over a vocabulary Σ consists of
– The frame. An partially ordered set with atoms V which is called the frame.
The frame must be countable, S-directed and ultimately directed, and have
a least element called the root. Elements of the frame are called nodes.
– The local models. A labelling which maps each node v of the frame to
a legal ﬂat model A(v), called the local model in v, whose vocabulary is a
subset of Σ. This labelling must satisfy the following conditions:
1. The labelling function v →A(v) is weakly S-supported, which means
that it can be extended to some S-supported function.
2. If w ≥v, then the local model in w extends the local model in v in
the following sense. The universe of A(v) is a subset of the universe of
A(w), and the interpretation of A(v) is obtained from the interpretation
of A(w) by restricting to the vocabulary and universe of A(v).
3. For every predicate R in Σ there is a node w ≥v such that R is in the
vocabulary of the local model in w.
If v is a node in the frame of an S-stratiﬁed model A, then the submodel in
node v, denoted by A|≥v, is deﬁned by restricting the frame to nodes greater
or equal to v, and keeping the same labelling by local models. Submodels of an
S-stratiﬁed model are also S-stratiﬁed.
Semantics in stratiﬁed models. We now deﬁne the semantics of ﬁrst-order logic
with orbit-ﬁnite boolean operations in stratiﬁed models. Suppose that A is an
S-stratiﬁed model and ϕ is an S-supported formula. If ϕ has free variables, then
we also need a valuation ν, which maps the free variables of the formula to S-
supported elements in the universe of the local model in the root of A. Given
these ingredients, we can deﬁne the truth value, which is denoted by a triple
turnstile
A, ν
ϕ.
We underline that the above is only deﬁned when both the formula ϕ and the
valuation ν are supported by the parameter S such that A is an S-stratiﬁed
model. The deﬁnition is by induction on the structure of ϕ.
– For a predicate formula, deﬁne
A, ν
R(x1, . . . , xn)
(4)
to be true if there is some node w in the frame such that the local model
in w has R in its vocabulary and R(x1, . . . , xn) holds in that local model,
under the valuation ν. Using the assumptions that the frame is S-directed,
and that the labelling by local models is weakly S-supported, one can show
that this deﬁnition does not depend on the choice of v, i.e. if it R(x1, . . . , xn)
holds in some local model whose vocabulary contains R, then it holds in all
local models whose vocabulary contains R.

26
M. Boja´nczyk
– Negation is deﬁned in the standard way.
– For an orbit-ﬁnite disjunction, deﬁne
A, ν

i∈I
ϕi
to be true if there is some ﬁnite set of atoms T ⊇S, a submodel B of A that
is T -stratiﬁed, and some i ∈I such that ϕi is T -supported and
B, ν
ϕi.
The deﬁnition for conjunction is obtained by using De Morgan’s law.
– For a existential quantiﬁcation, we deﬁne
A, ν
∃x.ϕ(x)
to be true if there is some ﬁnite set of atoms T ⊇S, a submodel B of A that
is T -stratiﬁed, and some T -supported element a in the universe of the local
model in the root of B such that
B, ν[x →a]
ϕ(x)
The deﬁnition for ∀is obtained by using De Morgan’s law.
Running example.[A stratiﬁed model describing a data word] We will describe
a ∅-stratiﬁed model, call it A, that describes a data word (for equality atoms)
where all letters are diﬀerent. The frame is non-repeating sequences of atoms,
which was shown in Example 4 to be ultimately directed. In a node a0 · · · an of
the frame, the local model looks as follows. The universe is always the natural
numbers, regardless of the node (the universe is not built using atoms, i.e. all of
its elements have empty support). The vocabulary contains the order predicate
<, regardless of the node, which is interpreted in the standard way. Furthermore,
the vocabulary contains the predicates a0(x), . . . , an(x), which are interpreted so
that predicate ai(x) holds exactly in position i, and nowhere else. In particular,
each local model has only ﬁnitely many positions satisfying the unary predicates.
Recall the property “< is a linear order and every atom appears in exactly
one position”, which was studied previously in the running example, and which
is expressed by the sentence
ϕ<
∧

a∈A
∃x a(x)
∧

a̸=b∈A
∀x a(x) ⇒¬b(x).
This property was false in all legal ﬂat models, but it is true in the stratiﬁed
model A we have just described. To illustrate the semantics, we show that
A

a∈A
∃x a(x).

Modelling Inﬁnite Structures with Atoms
27
(There are no free variables, so there is no valuation.) Recall that
is not
deﬁned for any choice of model and formula: the formula needs to be supported
by a set S such that the model is S-stratiﬁed. In this case, the formula has
empty support and the model is ∅-stratiﬁed, so
is deﬁned. By unravelling the
semantics of , we need to show that for every atom a ∈A, and every node
a1 · · · an in the model, if the submodel A|≥a0···an is S-stratiﬁed for some S ∋a,
then that submodel satisﬁes ∃x a(x). It is not diﬃcult to see that the submodel
in node a0 · · · an is S-stratiﬁed for some S ∋a if and only if a ∈{a0 · · · an}. Such
submodels satisfy ∃x a(x). Observe that even when a is ﬁxed, then the position
x that satisﬁes a(x) will depend on the choice of the node a0 · · · an. For instance,
if the node is chosen to be abc then x will be the position zero, and if the node
is chosen to be cba then x will be position two.
□
Running example.[An “isomorphic” model] Choose some bijection f of the nat-
ural numbers. Consider a ∅-stratiﬁed model that is deﬁned the same way as in
the previous example, with the diﬀerence that in node a0 · · · an, the predicate
ai(x) holds exactly in position f(i). One can show that this model satisﬁes the
same sentences as the previous one.
□
Stratiﬁed models are equivalent to (possibly illegal) ﬂat models. The following
theorem shows stratiﬁed models are equivalent to (possibly illegal) ﬂat models
that (possibly illegal) ﬂat models, at least when restricted to uniformly supported
sets of sentences. A set is called uniformly supported if there is some support S
that supports all elements of the set. Every ﬁnite set of sentences is uniformly
supported.
Theorem 2. Let Γ be a uniformly ﬁnitely supported set of sentences of ﬁrst-
order logic with orbit-ﬁnite boolean operations. Then Γ has a (possibly illegal)
ﬂat model if and only if it has a stratiﬁed model.
The following proposition shows the left-to-right implication in Theorem 2.
Proposition 1. Let S be a ﬁnite support.
1. For every (possibly illegal) ﬂat model there is an S-stratiﬁed model which
satisﬁes the same S-supported sentences.
2. For every S-stratiﬁed model there is a (possibly illegal) ﬂat model which
satisﬁes the same S-supported sentences.
In the proof of the ﬁrst item in the proposition, we construct a stratiﬁed model
satisfying the following properties: all local models have the same universe; all
elements of this universe have empty support; the frame is obtained from Exam-
ple 7. Therefore, Theorem 2 would still be true under a deﬁnition of stratiﬁed
model that would require these properties.
Acknowledgement. I would like to thank Nathana¨el Fijalkow, Bartosz Klin,
Sawomir Lasota, and especially Szymon Toru´nczyk for inspiring discussions.

28
M. Boja´nczyk
References
1. Adamowicz, Z., Zbierski, P.: Logic of Mathematics: A Modern Course of Classical
Logic. Pure and Applied Mathematics: A Wiley Series of Texts, Monographs and
Tracts. Wiley (2011)
2. Bojanczyk, M., Klin, B., Lasota, S.: Automata with group actions. In: LICS, pp.
355–364 (2011)
3. Boja´nczyk, M., Place, T.: Toward model theory with data values. In: Czumaj,
A., Mehlhorn, K., Pitts, A., Wattenhofer, R. (eds.) ICALP 2012, Part II. LNCS,
vol. 7392, pp. 116–127. Springer, Heidelberg (2012)
4. Bojanczyk, M., Torunczyk, S.: Imperative programming in sets with atoms. In:
D’Souza, D., Kavitha, T., Radhakrishnan, J. (eds.) FSTTCS. LIPIcs, vol. 18, pp.
4–15. Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik (2012)
5. Gabbay, M.J., Pitts, A.M.: A new approach to abstract syntax with variable binding.
Formal Asp. Comput. 13(3-5), 341–363 (2002)
6. Gabbay, M.J.: Fresh logic: proof-theory and semantics for fm and nominal tech-
niques. J. Applied Logic 5(2), 356–387 (2007)
7. Gabbay, M.J.: Finite and inﬁnite support in nominal algebra and logic: nominal
completeness theorems for free. J. Symb. Log. 77(3), 828–852 (2012)
8. Lopez-Escobar, E.G.K.: An interpolation theorem for denumerably long formulas.
Fundam. Math. 57, 253–272 (1965)
9. Pitts, A.M.: Nominal Sets: Names and Symmetry in Computer Science. Cambridge
Tracts in Theoretical Computer Science, vol. 57. Cambridge University Press (2013)

Counting in SPARQL Property Paths:
Perspectives from Theory and Practice
Wim Martens
Institute for Computer Science, University of Bayreuth
wim.martens@uni-bayreuth.de
Abstract. RDF and SPARQL are becoming increasingly popular and
are bringing many new and interesting research challenges. During the
development of these standards, the World Wide Web Consortium (W3C)
does not necessarily always have all the cards on the table in order to
make perfectly informed design decisions and therefore it partly relies on
input from the research community. This is a very interesting situation
for researchers since it can give the opportunity to immediately have re-
search results incorporated into practice. In this talk I will discuss some
experiences from our interaction with the W3C concerning the seman-
tics of property paths in SPARQL. Property paths are a relatively new
feature in SPARQL 1.1 and essentially correspond to regular expressions
that should be evaluated over RDF graphs.
The popularity of the Resource Description Framework (RDF) [5] and the
SPARQL Protocol and RDF Query Language (SPARQL) [3] is posing new chal-
lenges for computer science researchers. In brief, the RDF data model stores data
as triples of the form (x, p, y) where, intuitively, x corresponds to a subject, y to
an object, and p to a predicate that denotes a relationship between x and y. As
such, a collection of RDF triples can be seen as a graph in which the nodes are
the subjects and objects of triples in the collection and there is an edge labelled p
from node x to node y if and only if there is a triple (x, p, y) in the collection [4].
The SPARQL query language [3] represents a serious eﬀort by the World
Wide Web Consortium in its quest for a query language for RDF that bears
a good tradeoﬀbetween coverage of use cases, ease-of-use, desirable features,
expressivity, and complexity. However, at the moment where design decisions
need to be made, the designers of SPARQL do not necessarily have all the cards
on the table, e.g., regarding tradeoﬀs between expressiveness and complexity.
Therefore, there are many aspects of the SPARQL language for which the World
Wide Web Consortium relies on input from the research community in order to
make well-informed decisions.
This situation can be win-win scenario for researchers and developers of
the language. The World Wide Web Consortium is open for comments and
input from the research community, which can in turn inﬂuence the further
development of the standard. We will discuss this interaction between theory
and practice with a focus on our own experience with some aspects of the
SPARQL 1.1 recommendation, more precisely, aspects of SPARQL property
L. Libkin, U. Kohlenbach, and R. de Queiroz (Eds.): WoLLIC 2013, LNCS 8071, pp. 29–30, 2013.
c
⃝Springer-Verlag Berlin Heidelberg 2013

30
W. Martens
paths [1,6]. SPARQL property paths essentially correspond to regular expres-
sions that should be evaluated against paths in an RDF graph. As such, there
is a very close connection between navigational queries on graph databases (see
[2] for a recent overview) and current developments in the SPARQL language.
The word “counting” will be used with two diﬀerent meanings. The ﬁrst refers
to the multiset semantics that property paths currently have. The second refers
to counting operators that can make property paths exponentially more succinct.
We discuss recent ﬁndings regarding the impact of counting on the complexity
of evaluating property paths and how the development of SPARQL reacted to
these.
References
1. Arenas, M., Conca, S., P´erez, J.: Counting beyond a yottabyte, or how SPARQL
1.1 property paths will prevent adoption of the standard. In: World Wide Web
Conference (WWW), pp. 629–638 (2012)
2. Barcelo, P.: Querying graph databases. In: Symposium on Principles of Database
Systems (PODS), Invited tutorial (to appear, 2013)
3. Harris, S., Seaborne, A., Prud’hommeaux, E.: SPARQL 1.1 query language. Tech-
nical report, W3C (January 2012),
http://www.w3.org/TR/2012/WD-sparql11-query-20120105/
4. Hayes, P., McBride, B.: RDF semantics. Technical report, W3C (February 2004),
http://www.w3.org/TR/2004/REC-rdf-mt-20040210/
5. Klyne, G., Carroll, J.J., McBride, B.: RDF 1.1 concepts and abstract syntax. Tech-
nical report, W3C (January 2013),
http://www.w3.org/TR/2013/WD-rdf11-concepts-20130115/
6. Losemann, K., Martens, W.: The complexity of evaluating path expressions in
SPARQL. In: Symposium on Principles of Database Systems (PODS), pp. 101–112
(2012)

Quantitative Approaches
to Information Protection
Catuscia Palamidessi
INRIA and Ecole Polytechnique, France
Abstract. Secure information ﬂow is the problem of ensuring that the
information made publicly available by a computational system does
not leak information that should be kept secret. Since it is practically
impossible to avoid leakage entirely, in recent years there has been a
growing interest in considering the quantitative aspects of information
ﬂow, in order to measure and compare the amount of leakage.
In this talk, we revise the main recent approaches which have been
proposed to quantify and reason about leakage, the information-theoretic
approaches based on Shannon entropy and on R´enyi min-entropy, and a
novel one based on decision theory. Furthermore, we study the relation
with diﬀerential privacy, a notion which has been proposed to cope with
the problem of statistical disclosure control in the area of databases.
Finally, we consider a generalization of diﬀerential privacy, which can be
naturally applied to protect sensitive information also in domains other
than databases.
The talk is based on the papers [1,2,3].
References
1. Alvim, M.S., Andr´es, M.E., Chatzikokolakis, K., Palamidessi, C.: On the relation
between Diﬀerential Privacy and Quantitative Information Flow. In: Aceto, L.,
Henzinger, M., Sgall, J. (eds.) ICALP 2011, Part II. LNCS, vol. 6756, pp. 60–76.
Springer, Heidelberg (2011)
2. Alvim, M.S., Chatzikokolakis, K., Palamidessi, C., Smith, G.: Measuring information
leakage using generalized gain functions. In: Proceedings of the 25th IEEE Computer
Security Foundations Symposium (CSF), pp. 265–279 (2012)
3. Chatzikokolakis, K., Andr´es, M.E., Bordenabe, N.E., Palamidessi, C.: Broadening
the scope of Diﬀerential Privacy using metrics. In: Proc. of PETS. IEEE (to appear,
2013), Technical report available at: http://hal.inria.fr/hal-00767210
4. Chatzikokolakis, K., Palamidessi, C., Panangaden, P.: Anonymity protocols as noisy
channels. Information and Computation 206(2-4), 378–401 (2008)
5. Clark, D., Hunt, S., Malacaria, P.: Quantiﬁed interference for a while language. In:
Proceedings of the Second Workshop on Quantitative Aspects of Programming Lan-
guages (QAPL 2004). Electronic Notes in Theoretical Computer Science, vol. 112,
pp. 149–166. Elsevier Science B.V. (2005)
6. Dwork, C.: Diﬀerential privacy. In: Bugliesi, M., Preneel, B., Sassone, V., Wegener,
I. (eds.) ICALP 2006. LNCS, vol. 4052, pp. 1–12. Springer, Heidelberg (2006)
7. Dwork, C., Kenthapadi, K., McSherry, F., Mironov, I., Naor, M.: Our data, our-
selves: Privacy via distributed noise generation. In: Vaudenay, S. (ed.) EURO-
CRYPT 2006. LNCS, vol. 4004, pp. 486–503. Springer, Heidelberg (2006)
L. Libkin, U. Kohlenbach, and R. de Queiroz (Eds.): WoLLIC 2013, LNCS 8071, pp. 31–32, 2013.
c
⃝Springer-Verlag Berlin Heidelberg 2013
www.allitebooks.com

32
C. Palamidessi
8. K¨opf, B., Basin, D.A.: An information-theoretic model for adaptive side-channel
attacks. In: Ning, P., De Capitani di Vimercati, S., Syverson, P.F. (eds.) Proceedings
of the 2007 ACM Conference on Computer and Communications Security (CCS
2007), pp. 286–296. ACM (2007)
9. Smith, G.: On the foundations of quantitative information ﬂow. In: de Alfaro, L.
(ed.) FOSSACS 2009. LNCS, vol. 5504, pp. 288–302. Springer, Heidelberg (2009)

Perspectives of Dynamic Complexity
Thomas Schwentick⋆
Technische Universit¨at Dortmund
Abstract. Many current data processing scenarios deal with about large
collections of permanently changing data. In this context, it is often out-
right impossible to compute the answer for a query from scratch. Rather
some auxiliary data needs to be stored that helps answering queries
quickly, but also requires to be maintained incrementally. This incremen-
tal maintenance scenario can be studied in various ways, e.g., from the
perspective of dynamic algorithms with the goal to reduce (re-) computa-
tion time. Other options are to study the scenario from the perspective of
low-level parallel computational complexity [3] or parallelizable database
queries [1]. As the “lowest” complexity class AC0 (with a suitable uni-
fomity condition) and the core of the standard database query language
SQL both coincide with ﬁrst-order predicate logic, one naturally arrives
at the question which queries can be answered/maintained dynamically
with ﬁrst-order predicate logic (DynFO).
The most intensily studied query in this dynamic setting is the reach-
ability query on graphs, arguably the “simplest recursive” query. It has
been shown that it can be maintained in DynFO on undirected [3] or
acyclic directed graphs [1]. However, whether it can be maintained on
general directed graphs is considered the main open question of the ﬁeld.
Actually, it turned out that showing that a given query can not be
maintained in DynFO is a very challenging problem, for which currently
no methods are available. Furthermore, even though AC0 is a small com-
plexity class in the static setting, ﬁrst-order logic is already quite pow-
erful in the dynamic world. These two observations have recently led to
the study of fragments of DynFO, e.g., by restricting or forbidding quan-
tiﬁcation, with the idea to start developing inexpressibility tools there.
A surprising result found along these lines is that on strings, quantiﬁer
free predicate logic can exactly maintain the regular languages [2]. The
talk will give an introduction into dynamic complexity, survey some of
its most important results, and report about recent work on fragments
of DynFO.
References
1. Dong, G., Su, J.: Incremental and decremental evaluation of transitive closure by
ﬁrst-order queries. Inf. Comput. 120(1), 101–106 (1995)
2. Gelade, W., Marquardt, M., Schwentick, T.: The dynamic complexity of formal
languages. ACM Trans. Comput. Log. 13(3), 19 (2012)
3. Patnaik, S., Immerman, N.: Dyn-fo: A parallel, dynamic complexity class. J. Com-
put. Syst. Sci. 55(2), 199–209 (1997)
⋆This work was supported by the DFG Grant SCHW678/36-1.
L. Libkin, U. Kohlenbach, and R. de Queiroz (Eds.): WoLLIC 2013, LNCS 8071, p. 33, 2013.
c
⃝Springer-Verlag Berlin Heidelberg 2013

Linear Time Proof Veriﬁcation on N-Graphs:
A Graph Theoretic Approach
La´ıs Andrade, Ruan Carvalho, Anjolina de Oliveira, and Ruy de Queiroz
Centro de Inform´atica, Universidade Federal de Pernambuco,
50740-560 Recife, Pernambuco, Brazil
{lsa,rvbc,ago,ruy}@cin.ufpe.br
Abstract. This paper presents a linear time algorithm for proof veriﬁca-
tion on N-Graphs. This system, introduced by de Oliveira, incorporates
the geometrical techniques from the theory of proof-nets to present a
multiple-conclusion calculus for classical propositional logic. The sound-
ness criterion is based on the one given by Danos and Regnier for Linear
Logic. We use a DFS-like search to check the validity of the cycles in a
proof graph, and some properties from trees to check the connectivity
of every switching (a concept similar to D-R graph). Since the sound-
ness criterion in proof graphs is analogous to Danos-Regnier’s procedure,
the algorithm can also be extended to check proofs in the multiplicative
linear logic without units (MLL−) with linear time complexity.
Keywords: automatic proof-checking, natural deduction, classical logic,
linear logic, MLL−, N-Graphs, graph theory, dfs.
1
Introduction
The pioneering work of R. Statman in his doctoral thesis Structural Complexity
of Proofs [15] showed that extracting structural properties of proofs in natural
deduction (ND) using appropriate geometric intuitions oﬀers itself as a very
promising approach to the study of formal proofs. However, the lack of symmetry
in ND presents a challenge for such a kind of study. The obvious alternative, of
course, is to look at multiple-conclusion calculi. One already has in the literature
diﬀerent approaches involving such calculi, such as, for example, Kneale’s tables
of development [9] (studied in depth by Shoesmith & Smiley [14]) and Ungar’s
multiple-conclusion ND [16]. More recently, the development of a proof system
based on “natural deduction graphs”, N-Graphs for short, developed by A. de
Oliveira [11,12], has brought an interesting ingredient, namely the combination
of the intuitive appeal of Natural Deduction with the structural tools and the
built-in symmetry of Sequent Calculus.
We are here concerned with the proof-checking in the N-Graphs system. In
particular, we present a linear time algorithm for proof veriﬁcation on N-Graphs.
Unlike regular tree like formalisms such as sequent calculus or ND, N-Graphs, as
proof-nets for linear logic, have a notion of correction based on a global criterion
L. Libkin, U. Kohlenbach, and R. de Queiroz (Eds.): WoLLIC 2013, LNCS 8071, pp. 34–48, 2013.
c
⃝Springer-Verlag Berlin Heidelberg 2013

Linear Time Proof Veriﬁcation on N-Graphs
35
expressed in terms of acyclicity and connectedness of a class of subgraphs [6].
For this reason, checking their correctness is not a trivial task.
The proposed algorithm can also be applied to check proofs in MLL−with
linear time complexity. Although linear algorithms already exist for checking
MLL−proof nets [7,10], our approach seems to be simpler than both. We use a
Depth-First-Search-like procedure to check the validity of the cycles in a proof
graph, and some properties from trees to check the connectivity of every switch-
ing (a concept similar to D-R graph).
2
N-Graphs
N-Graphs is a multiple conclusion proof system for the propositional classical
calculus where proofs are built in the form of directed graphs (“digraphs”). Pro-
posed by de Oliveira [11,12], it is a symmetric natural deduction (ND) calculus
with the presence of structural rules, similar to the sequent calculus.
The system incorporates ideas from diﬀerent works. The derivations are based
on symmetric ND systems deﬁned by Kneale [9] and Ungar [16]. The implication
connective (“→”) is handled by a special edge that captures the discharge of
assumptions, similarly to Statman’s approach. Furthermore, it adopts the notion
of optical graphs from Carbone and embodies the geometrical techniques coming
from the theory of proof-nets [6] to deﬁne soundness criteria.
Several studies have been developed on N-Graphs since its ﬁrst publication in
2001, like Alves’ development on the geometric perspective and cycle treatment
towards the normalization of the system [1] and Cruz’s deﬁnition of intuitionistic
N-Graphs [5]. A normalization algorithm was presented for classical N-Graphs
[3], along with the subformula and separation properties [2]. This work aims at
a systematic analysis of the soundness criteria, based on the pure structure of
the graph.
2.1
Proof-Graphs
Proofs are represented by digraphs. The vertices are labeled with formula-
occurrences and some receive special names [11,12]:
Deﬁnition 1. (i) A branch point in a digraph is a vertex with at least three
edges attached to it. (ii) A focussing ( defocussing) branch point is a vertex in a
digraph with two edges oriented towards (resp. away from) it.
The edges in a proof-graph deﬁne links, which represent the atomic steps in a
derivation. There are three kinds of links, as shown in Fig. 1: focussing, defo-
cussing and simple links.
Deﬁnition 2. (i) A focussing link is a set {(u1, v), (u2, v)} in a digraph in which
v is a focussing branch point, as illustrated by Fig. 1. The vertices u1 and u2
are called premises of the link and v is the conclusion. (ii) A defocussing link is
a set {(u, v1), (u, v2)} in a digraph in which u is a defocussing branch point, as

36
L. Andrade et al.
Fig. 1. Links in a proof-graph
illustrated by Fig. 1. The vertices v1 and v2 are called conclusions of the link and
u is the premise. (iii) A simple link is an edge (u, v) in a digraph which neither
belongs to focussing nor to a defocussing link, as illustrated by Fig. 1. Vertex u
is called premise of the link and v is conclusion.
Deﬁnition 3 (proof-graph). A proof-graph is a connected digraph deﬁned as
follows:
1. each vertex is labeled with a formula-occurrence;
2. there are two kinds of edges ( “solid” and “meta”) and the second one are
labeled with an “m” ((u, v)m);
3. there are three kinds of links ( simple, focussing and defocussing), divided
into logic (Fig. 2) and structural (Fig. 3) ones;
4. each vertex is labeled with a conclusion of a unique link and is a premise of
at most one link.
A logical link represents a derivation in ND (⊤−link acts as the law of the ex-
cluded middle). A structural link expresses the application of a structural rule as
it is done in sequent calculus: it enables weakening a proof, duplicating premises
Fig. 2. Logical links

Linear Time Proof Veriﬁcation on N-Graphs
37
Fig. 3. Structural links
(expansion link) and grouping conclusions in equivalence classes (contraction
link).
There is no link to emulate the interchange rule because the order of the
premises is not important for the application of derivation rules. The axioms are
represented by proof graphs with one vertex and no edges.
The focussing and defocussing links may also be classiﬁed according to their
semantic:
Deﬁnition 4. (i) The links ∧−I, ⊥−link, →−E, ⊤−focussing weak and ex-
pansion are called conjunctive. (ii) The links ∨−E, ⊤−link, ⊥−defocussing weak
and contraction are called disjunctive.
Other relevant concepts for a given proof-graph G:
1. the solid indegree (outdegree) of a vertex v is the number of solid edges ori-
ented towards (away from) it. The meta indegree and outdegree are deﬁned
analogously;
2. the set of vertices with indegree equal to zero is the set of premises of G
(PREMISS(G));
3. the set of vertices with outdegree equal to zero is the set of conclusions of G
(CONC(G));
4. the set of vertices with solid indegree equal to zero and meta indegree equal
to one is the set of canceled hypothesis of G (HY POT (G)).
2.2
Inadequacy
In a multiple conclusion calculus we have rules with more than one conclusion
(∨−elimination) as well as rules with more than one premise (∧−introduction).
This allows the existence of cycles and makes soundness diﬃcult to prove. In the
tables of development, Kneale avoids this problem stating that formulas which
are already connected must not be connected again in any way [9]. However,

38
L. Andrade et al.
without the presence of cycles a new problem arises: some tautologies cannot be
proved [16], and so the system becomes incomplete.
Shoesmith & Smiley [14] and Ungar [16] solved the inadequacy by deﬁning
operations on derivations. With them, the links no longer correspond to a de-
ductive step. Sometimes they refer to a combination of derivations. A simpler
approach is the one used by the theory of proof-nets. It allows every link to rep-
resent a single deductive step, since it represents a logical relationship between
formulas. The characterization of which proof-structures are correct is based on
a geometrical concept, and so the cycles are permitted in a controlled way.
As a multiple conclusion calculus, N-Graphs also faced the inadequacy pro-
blem. The proposed solution [11,12] adopts some ideas from Shoesmith & Smiley
and Ungar for classical logic and the simplicity of Danos & Regnier’s solution for
MLL−. The main idea is to distinguish a link that represents a logical derivation
from the one that deals with the proof structure. The second kind of links is
represented by contraction and expansion links. A proof may contain cycles 1,
which shall be controlled by these two structural links.
Expansion and Contraction Links. A cycle in Kneale’s tables of devel-
opment occurs when a conjunction is made on terms generated by the same
disjunction (Fig. 4). A valid cycle happens when a disjunction yields the same
formula twice and they are contracted to a single occurrence. The latter is similar
to the ∨−elimination rule in ND.
To handle cycles de Oliveira proposes grouping conclusions into equivalence
classes using the contraction link. In the sequent calculus it is done by right
contractions. Though this link is focussing, its semantics is disjunctive. In Fig. 4,
at the rightmost proof-graph, the cycle involving A∨A is opened by a disjunctive
link and closed by another one (contraction) and therefore is valid.
Fig. 4. Proof-graphs for A ∨A ⊢A ∧A: an inadequate on the left and a sound one on
the right
In order to group assumptions similarly to single conclusion calculi we use
the expansion link. For example, to allow the conjunction of a formula with
itself (A ∧A), we need two instances of A, which are joined by an expansion. It
corresponds to left contraction in the sequent calculus and allow us to complete
the proof of A ∨A ⊢A ∧A. As the contraction link, the semantic of expansion is
1 Sometimes we talk about “cycles” when in fact “semicycles” are meant (i.e. the
direction of edges is not relevant).

Linear Time Proof Veriﬁcation on N-Graphs
39
contrary to its geometry (conjunctive defocussing). Thus the cycle that includes
A ∧A in Fig. 4 is valid because it is opened by a conjunctive link (expansion)
and closed by another one.
Meta-Edge and the Scope of the Hypothesis. Besides expansion and con-
traction links there is the →−I link. In the Kneale’s tables of development there
is no rule for discarding premises. Both Ungar and Gentzen systems are formu-
lated in such a way that when the →connective is introduced, it may eliminate
an arbitrary number of premises (including zero). In N-Graphs this introduction
is made in a more controlled way, which also complicates the task of identifying
inadequate proof-graphs. For example, the ﬁrst proof in Fig. 5 is not correct,
but the second one is.
Fig. 5. Meta edge: an invalid application on the left for ⊢A →(A ∨B) and a sound
one on the right for ⊢(A ∨B) →A, B
2.3
Soundness Criteria
Similar to Danos-Regnier criterion [6], we deﬁne the following subgraphs associ-
ated to a proof-graph.
Deﬁnition 5. Given a proof-graph G, (i) a switching graph S(G) associated
with G is a spanning subgraph2of G in which the following edges are removed: one
of the two edges of every expansion link, one of the two edges of every contraction
link and all meta edges; (ii) a switching expansion Se(G) associated with G is
a spanning subgraph of G in which one of the two edges of every expansion link
and all meta edges are removed. (iii) We say that the meta-condition holds for
G iﬀfor every meta-edge (u, v)m of a defocussing link →−I {(u, w), (u, v)m}
in G, there is a path or semipath from v to u without passing through (u, w) in
every switching expansion Se(G) and the solid indegree of v is equal to zero.
Deﬁnition 6 (N-Graph derivation). A proof-graph G is a N-Graph derivation
(or N-Graph for short) iﬀthe meta-condition holds for G and every switching
graph associated with G is acyclic and connected.
2 A spanning subgraph is a subgraph G1 of G containing all the vertices of G.

40
L. Andrade et al.
The soundness and completeness of the system were proved through a mapping
between N-Graphs and LK [11,12]:
Theorem 1 (map to N-Graph). Given a derivation Π of A1, . . . , An ⊢B1, . . . ,
Bm in the classical sequent calculus, it is possible to build a corresponding N-
Graph NG(Π) whose elements of PREMIS(NG(Π)) and CONC(NG(Π)) are
in one-to-one correspondence with the occurrences of formulas A1, . . . , An and
B1, . . . , Bm, respectively.
Theorem 2 (sequentialization). Given a N-Graph derivation G, there is a se-
quent calculus derivation SC(G) of A1, . . . , An ⊢B1, . . . , Bm in the classical se-
quent calculus whose occurrences of formulas A1, . . . , An and B1, . . . , Bm are in
one-to-one correspondence with the elements of PREMIS(G) and CONC(G),
respectively.
Analysis of the Fragment ∧, ∨and ¬. If a proof-graph does not have
any →−I link, then meta-condition holds for it. In the next section we deﬁne a
method to check soundness of derivations in the {∨, ∧, ¬} fragment of N-Graphs,
where the meta-condition is already satisﬁed.
3
Veriﬁcation of Proof-Graphs
Given a proof-graph with no meta edge, the goal of the veriﬁcation algorithm
is to check if every switching graph associated with it is acyclic and connected.
Danos–Regnier’s soundness criterion veriﬁes the same, but on proof-structures
instead. The algorithm presented here is based on the types of cycles that may
exist in a proof-graph.
We propose a validation mechanism over a given cycle that determines if
there is a switching where it appears. If no such cycle is found in a proof-graph,
then every associated switching is acyclic. On a second step, we use a relation
between the number of edges and vertices in the switching graphs to conﬁrm its
connectivity. This relationship was already found for D-R graphs [7].
3.1
Cycle Analysis
A valid cycle in a proof-graph is the one that is not present in any switching
graph associated with it. The only way a cycle may “disappear” from a graph
is by removing one of its edges. The edges which may be not present in a given
switching are the contraction, expansion and meta edges. They are the key for
the identiﬁcation of valid cycles and here will be denoted volatile edges.
The volatile edges from a single expansion/contraction link have a strong
semantic connection while working with switchings. If one of then is present in
a given switching graph S(G), the other one is not. Because of this connection,
two edges from the same link will be denoted conjugated edges:

Linear Time Proof Veriﬁcation on N-Graphs
41
Deﬁnition 7 (conjugated edge). Let e1 and e2 be two edges from an expansion
or contraction link in a proof-graph G. The conjugated edge of e1 is ˆe1 = e2,
and vice versa, and e ∈S(G) ⇐⇒ˆe /∈S(G) for all switching S(G).
Let c be a cycle in a proof-graph G. EV (c) is deﬁned as the set of volatile edges
of c. The cycles in a proof-graph may be classiﬁed into the following types (also
illustrated in Fig. 6):
1. cycles with no volatile edge;
2. cycles c with a non-empty set of volatile edges EV (c) = {e1, . . . , en}, n > 0,
where ∀ei ∈EV (c) →ˆei /∈EV (c);
3. cycles c with a non-empty set of volatile edges EV (c) = {e1, . . . , en}, n > 0,
where ∃ei ∈EV (c) →ˆei ∈EV (c);
Fig. 6. Cycles in a proof-graph
Analyzing each of these cases separately, it may be noticed that the cycles of
type 1 are always invalid ones, since there is no volatile edge within it and so it
is present in every switching graph associated with G.
The cycles of type 2 may not be present in some switchings of G. However,
when none of the volatile edges within the cycle is a meta edge, there will be at
least one switching where EV (c) ⊆S(G), which means there will be switchings
where c appears. Therefore, the cycles of type 2 are always invalid in proof-graphs
with no meta-edge.
The last type of cycles is the most interesting, because it represents only valid
cycles. More than that, it deﬁnes all valid cycles when the proof-graph has no
meta edge. When a cycle c contains at least one pair of conjugated edges, there
is no switching where c may be present, because one edge from the pair must be
out of a given switching S(G), for every switching of G.
So we have the following lemma:
Lemma 1 (valid cycle). Let G be a proof-graph, and G′ a spanning subgraph
of G without all meta edges. A cycle c in G′ has at least one expansion or
contraction link iﬀc is not present in any switching S(G) associated to G.
www.allitebooks.com

42
L. Andrade et al.
Proof.
1. If a cycle c in G′ has at least one expansion or contraction link, then c is
not present in any switching S(G).
Let l be an expansion or contraction link in c. Let S(G) be a switching
associated to G. S(G) must eliminate one of the edges from l, wherefore c
will no longer be a cycle in S(G).
2. If c is not present in any switching graph S(G) associated to G, then c has
at least one expansion or contraction link.
Proof by contrapositive. Suppose there is a cycle c where ∀ei ∈EV (c) →
ˆei /∈EV (c). Then there is a switching S(G) such that ∀ei ∈EV (c) | ei ∈
S(G). Therefore, c is present in S(G).
⊓⊔
Corollary 1 (acyclicity). Let G be a proof-graph and G′ a spanning subgraph of
G without meta edges. Every cycle in G′ has at least one expansion or contraction
link iﬀevery switching graph S(G) associated to G is acyclic.
3.2
Connectivity Analysis
A tree is an acyclic and connected graph. Another way to deﬁne the soundness
criterion is to say that every switching graph associated to the proof-graph is
a tree. By deﬁnition, a tree with n vertices has exactly n −1 edges [8]. We
may extend this tree’s property to deﬁne another lemma for proof-graphs, now
concerning its connectivity:
Lemma 2 (connectivity). Let G be a proof-graph such that all switching graph
S(G) associated to G is acyclic. Then every switching S(G) is a tree iﬀthe
following formula is valid:
|E(G)| −|LE(G)| −|LC(G)| −|EM(G)| = |V (G)| −1 ,
(1)
where E(G) is the set of edges of G, LE(G) and LC(G) are the set of expansion
and contraction links of G, respectively, EM(G) is the set of all meta edges of G,
and V (G) is the set vertices of G.
Proof.
In every switching associated to G, all meta edges are eliminated, as
well as one edge from every expansion and contraction link. So every switching
has exactly |E(G)| −|LE(G)| −|LC(G)| −|EM(G)| edges. If a switching S(G) is
acyclic, then it is a tree iﬀthe number of edges is equal to the number of vertices
minus one, i.e., |E(G)| −|LE(G)| −|LC(G)| −|EM(G)| = |V (G)| −1.
⊓⊔
3.3
The Algorithm
The algorithm proposed here uses the lemmas above and is divided in two proce-
dures. The ﬁrst procedure is a variation of Depth First Search (DFS for short).
The idea is to ﬁnd a spanning tree of the proof-graph, and whenever a cycle is
delimited by a back edge in the search, this cycle must be validated according
to Corollary
1. The second procedure is the application of the formula from
Lemma 2 to a given proof-graph.

Linear Time Proof Veriﬁcation on N-Graphs
43
To validate the cycles eﬃciently, it is necessary to keep track of the volatile
edges visited so far by the search. Therewith, it is possible to identify the ex-
pansion/contraction links within the cycle. The original DFS algorithm deﬁnes
three states for the nodes: not visited (white), discovered (gray) and ﬁnished
(black) [4]. That is useful to prove some properties about the search. In this
algorithm the state of the edges are also important, since it is necessary to know
which edges belong to a given cycle. So we extend the concept of state to edges:
a discovered edge is the one traversed by the search in one way; a ﬁnished edge
is the one traversed both ways in the recursion; and a not visited edge is the one
not traversed yet.
Likewise, the timestamps d[v] and f[v] [4] are also extended to mark the step
when an edge is discovered and ﬁnished. In order to do that, new stamps δ[n]
and ζ[n] are deﬁned, where n may be a vertex or an edge of the graph. For n as
a vertex, δ[n] = d[n] and ζ[n] = f[n]. When n is an edge, δ[n] is set when the
edge is traversed for the ﬁrst time in the recursion, and ζ[n] when the edge is
traversed back while returning from the recursion.
Crossing an edge in the traversal is still an instantaneous event, as it is in the
original search. The timestamp set in δ[e], for a given edge e = (u, v), is given
by max(δ[u], δ[v]), and the timestamp set in ζ[e] is given by min(ζ[u], ζ[v]). The
following ordering is deﬁned over δ and ζ (the intuition may be seen in Fig. 7):
Deﬁnition 8.
Given two elements, vertex or edge, of a graph G(V, E), u and
v, the relation ≺is deﬁned as follows:
1. If u and v are both vertices or both edges, δ[u] ≺δ[v] ⇐⇒δ[u] < δ[v] and
ζ[u] ≺ζ[v] ⇐⇒ζ[u] < ζ[v];
2. If u is an edge and v is a vertex, δ[u] ≺δ[v] ⇐⇒δ[u] ≤δ[v] and ζ[u] ≺
ζ[v] ⇐⇒ζ[u] ≤ζ[v].
The property d[v] < f[v] is still valid while using δ and ζ. It may be seen
more clearly when noticing that the values of δ[e] and ζ[e] for an edge e =
(u, v) comes from the last node visited white passing through the edge. The
ordering given above ensures that when the edge e is traversed from v to-
wards u, u will be discovered after e, and will be ﬁnished before it. There-
fore, the parenthesis property [4] is also true for δ and ζ. In other words,
δ[u] ≺δ[e] ≺δ[v] ≺ζ[v] ≺ζ[e] ≺ζ[u].
After all this extensions, we present an algorithm which validates a cycle once
it is found in the DFS. The algorithm keeps track of the values of δ and ζ for all
vertices and edges, and an auxiliary stack of links. A link is activated when one
of its volatile edges is traversed, and is inserted into the stack when the second
one is traversed while it is still activated. While returning from the recursion,
this link is removed from the stack if it was inserted at this step, or deactivated
if it was only activated. When a back edge is identiﬁed, the cycle is considered
invalid only if the stack is empty or if min(δ[e1], δ[e2]) < δ[u], where e1 and e2
are the two edges from the link at the top of the stack. The pseudocode of this
procedure is in Appendix.

44
L. Andrade et al.
Fig. 7. Ordering induced by δ and ζ. The following is true for an edge u = (v, w):
δ[v] ≺δ[u] ≺δ[w] < ζ[w] ≺ζ[u] ≺ζ[v].
Soundness. When a back edge to a discovered node v is found by the search, we
have the following scenarios for an arbitrary volatile edge e of the proof-graph:
1. e was not visited: in this case the expansion/contraction link which contains
this edge was not inserted into the stack, and so is not in the cycle;
2. e was ﬁnished: its expansion/contraction link was deactivated or removed
from the stack while this edge was ﬁnished. In both cases, the link that
contains this edge may not be in the stack, and so is not in the cycle;
3. e was discovered and ˆe was not visited: the link l = {e, ˆe} is active, but not
yet in the stack and consequently not in the cycle;
4. e was discovered and ˆe was ﬁnished: by the parenthesis property we know
that ˆe has activated and deactivated the link before it could be put into the
stack. The link is not in the cycle in this case;
5. e was discovered, and also was ˆe: in this case the link l = {e, ˆe} was added
into the stack. This link is not inside the cycle only if min(δ[e], δ[ˆe]) ≺δ[v].
The last item deﬁnes the case where a link is in the stack at the moment of a
cycle veriﬁcation. The links in the stack are the ones that may be in the tree
path between the current node and the node v to where the back edge returns,
i.e., in the cycle just found. The top of the stack is the last added link, and so
the closest to the current node among those on the stack. If the top one is not
in the cycle, by the parenthesis property, no other link in the stack may be in
this cycle. To prove the algorithm does such an analysis we have the following
lemmas:

Linear Time Proof Veriﬁcation on N-Graphs
45
Lemma 3. If an expansion or contraction link l = {e, ˆe} is in the stack when a
node v is visited, then v is a descendant3 of e and ˆe.
Proof.
If the link l is inside the stack, the second edge was visited while the ﬁrst
one was discovered but not ﬁnished. In other words, δ[e1] ≺δ[e2] ≺δ[v], where
e1 is the ﬁrst discovered edge and e2 the second. With the parenthesis property we
have the ﬁnal conﬁguration δ[e1] ≺δ[e2] ≺δ[v] < ζ[v] ≺ζ[e2] ≺ζ[e1].
⊓⊔
Lemma 4. If an expansion or contraction link l = {e, ˆe} is in the stack when a
node u is discovered, then a back edge (u, v) to an already discovered node v where
δ[v] ≺min(δ[e], δ[ˆe]) or δ[v] = min(δ[e], δ[ˆe]) deﬁnes a cycle that contains l.
Proof.
The link l is in the stack when u is discovered. By Lemma 3 u is a
descendant of e and ˆe. When a back edge (u, v) is found, a cycle is deﬁned by
the path in the tree from v to u plus the back edge. As there is only one path
in the tree between u and v, we have three cases illustrated in Fig. 8:
1. v
is
a
descendant
of
both
edges
of
l
and
so
min(δ[e1],
δ[e2]) ≺max(δ[e1], δ[e2]) ≺δ[v]; In this case no edge from l is inside the
cycle;
2. e2 is a descendant of v and e1 is not. Thus, min(δ[e1], δ[e2]) ≺δ[v] ≺
max(δ[e1], δ[e2]). In this case the path from v to u in the tree passes through
e2, which is the only descendant of v. The link is again not in the cycle;
3. both edges of l are descendants of v and then δ[v] ≺min(δ[e1], δ[e2]) ≺
max(δ[e1], δ[e2]). In this case the path in the tree from v to u passes through
e1 and e2, or only through e1 and the back edge is e2. In both cases the cycle
contains the link l.
⊓⊔
Fig. 8. Illustration of cases where a link l is in the stack when a back edge if found
Since the DFS algorithm ﬁnds all cycles in a connected graph, and lemmas 3
and 4 prove that the veriﬁcation is corresponding to the one given by Lemma 1,
the proposed algorithm is correct.
3 A node v is descendant of an edge e iﬀδ[e] ≺δ[v] ≺ζ[v] ≺ζ[e].

46
L. Andrade et al.
Complexity. The core of the algorithm is a depth ﬁrst search, which has linear
time complexity over the number of edges of the graph. The additional cost
ﬁnding expansion/contraction links from a given volatile edge may be reduced
to a constant time operation, if the implementation keeps in each edge a pointer
to its link. In the same way, the δ information for edges and vertices may be kept
in the edge and vertex itself, reducing the cost of accessing it while validating
the cycle to O(1). The stack used to store the active expansion and contraction
links is maintained by the recursive search. The reading on the stack is restricted
to its top, witch keeps the cycle validation cost to O(1).
The linearity of the algorithm over the number of edges may be extended to
the number of vertices, since the graphs we are dealing with are proof-graphs.
Each vertex in a proof-graph may be premise and conclusion of at most one link,
and all possible links deﬁned in Fig. 1 have no more than two edges on a single
vertex. Hence, the number of edges in a proof-graph is limited by 4|V |.
4
Danos–Regnier and Extension to MLL−
There are only two kinds of links in the MLL−fragment of proof-nets: times (⊗)
and par (℘). The former operator is the multiplicative and, and thus conjunctive.
The second is the multiplicative or, and so disjunctive. Although they have dif-
ferent semantic, their geometry is the same: they are both focussing links with
two premises and one conclusion. In this context, a switching graph may be seen
as concept similar to D-R graph, deﬁned as follows:
Deﬁnition 9 (D-R graph). Given a proof-structure P deﬁned in terms of
graphs, a D-R associated with P is a spanning subgraph of P in which one
of the two edges of every par link is removed.
Danos–Regnier technique is independent of the logic involved and relies on the
structure of the rules [13]. A link l must be switchable iﬀits formulas were already
connected before. This occurs when the geometry is contrary to the semantic of
the link (i.e. when link is conjunctive defocussing or disjunctive focussing). So
the concepts of D-R graph and switching are the same in the context of linear
logic.
In Table 1 we see that the times rule applies to two distinct proofs. Thus we
must not remove (A, A⊗B) and (B, A⊗B) edges in a D-R graph in order to keep
it connected. However, the other three rules are applied to only one previous
proof, and keeping the two edges of these links would create a cycle.
Table 1. Times, par, left and right contraction rules
⊢A, Γ ⊢B, Δ
⊢A ⊗B, Γ, Δ
⊢A, B, Γ
⊢A℘B, Γ
Γ, A, A ⊢Δ
Γ, A ⊢Δ
Γ ⊢A, A, Δ
Γ ⊢A, Δ

Linear Time Proof Veriﬁcation on N-Graphs
47
In a general way, the proposed algorithm veriﬁes if a switchable link is present
in all cycles of a graph. It is immediate that it can be applied to MLL−, where
par is the only switchable link. So what we propose here is another linear al-
gorithm for checking proof-nets. The ﬁrst one was proposed by Guerrini and
uses uniﬁcation for the veriﬁcation [7]. Murawski & Ong also use union-ﬁnd for
giving a linear algorithm for verifying Lamarche’s essential nets and proof-nets
[10]. Our approach, with a DFS-like procedure to validate Lemma 1, seems to
be relatively simpler.
References
1. Alves, G.V., de Oliveira, A.G., de Queiroz, R.J.G.B.: Towards normalization for
proof-graphs. In: Logic Colloquium, Bulletin of Symbolic Logic, Torino, United
States of America, vol. 11, pp. 302–303 (2005)
2. Alves, G.V., de Oliveira, A.G., de Queiroz, R.J.G.B.: Transformations via Geo-
metric Perspective Techniques Augmented with Cycles Normalization. In: Ono,
H., Kanazawa, M., de Queiroz, R. (eds.) WoLLIC 2009. LNCS, vol. 5514, pp. 84–
98. Springer, Heidelberg (2009)
3. Alves, G.V., de Oliveira, A.G., de Queiroz, R.J.G.B.: Proof-graphs: a thorough
cycle treatment, normalization and subformula property. Fundamenta Informati-
cae 106, 119–147 (2011)
4. Cormen, T.H., Leiserson, C.E., Rivest, R.L., Stein, C.: Introduction to Algorithms,
2nd edn. MIT Press, Cambridge (2001)
5. Cruz, M.Q., de Oliveira, A.G., de Queiroz, R.J.G.B., de Paiva, V.: Intuitionistic
N-graphs. Logic Journal of the IGPL (Print) (accepted for publication, 2013)
6. Danos, V., Regnier, L.: The Structure of Multiplicatives. Archive for Mathematical
Logic 28, 181–203 (1989)
7. Guerrini, S.: A Linear Algorithm for MLL Proof Net Correctness and Sequential-
ization. Theoretical Computer Science 412(20), 1958–1978 (2011)
8. Harary, F.: Graph Theory. Addison-Wesley Publishing Company (1972)
9. Kneale, W.: The Province of Logic. Contemporary British Philosophy (1958)
10. Murawski, A.S., Ong, C.-H.L.: Dominator Trees and Fast Veriﬁcation of Proof
Nets. In: LICS 2000: Proceedings of the 15th Annual IEEE Symposium on Logic
in Computer Science, pp. 181–191. IEEE Computer Society (2000)
11. de Oliveira, A.G.: Proofs from a Geometric Perspective. PhD Thesis, Universidade
Federal de Pernambuco (2001)
12. de Oliveira, A.G., de Queiroz, R.J.G.B.: Geometry of Deduction via Graphs of
Proof. In: de Queiroz, R. (ed.) Logic for Concurrency and Synchronisation, pp.
3–88. Kluwer (2003)
13. Robinson, E.: Proof Nets for Classical Logic. Journal of Logic and Computation 13,
777–797 (2003)
14. Shoesmith, D.J., Smiley, T.J.: Multiple-Conclusion Logic. Cambridge University
Press, London (1978)
15. Statman, R.: Structural Complexity of Proofs. PhD thesis, Stanford (1974)
16. Ungar, A.M.: Normalization, Cut-elimination and the Theory of Proofs. CSLI Lec-
ture Notes, vol. 28. Center for the Study of Language and Information (1992)

48
L. Andrade et al.
Appendix: The Algorithm
Here we present the pseudocode of the algorithm deﬁned in Section 3.
Cycle validation algorithm
procedure visite_node (v,timestamp)
{Assuming v belongs to a proof-graph and the existence of a global flag valid_proof};
declare
BOOLEAN activated;
begin
v.color := GREY;
v.delta = timestamp; timestamp := timestamp+1;
for all edge e=(u,v) incident to v
if e.color = WHITE then
e.color = GREY; e.delta := timestamp;
l := e.link; { retrieving the link that contains this edge };
activated := FALSE;
if e.volatile then
if l.active then { l is active iff its another edge is active }
stack_push(l);
activated := TRUE;
else
l.active := TRUE;
if u.color = WHITE then
visite_node(u,timestamp);
else { found a back edge };
if stack_empty() then
valid_proof = FALSE;
else
l := stack_top();
if min(l.e1.delta,l.e2.delta) < u.delta then { Scenario 5 }
valid_proof := FALSE;
if e.volatile then
if activated then
l.active := FALSE;
else
stack_pop();
e.color = BLACK;
end loop;
v.color := BLACK;
timestamp = timestamp+1;
end.

First Order Extensions of Residue Classes
and Uniform Circuit Complexity
Argimiro Arratia1,⋆and Carlos E. Ortiz2
1 LSI, Universitat Polit`ecnica de Catalunya, Barcelona, Spain
arratia@lsi.upc.edu
2 Arcadia University, Glenside, PA 19038-3295, U.S.A.
ortiz@arcadia.edu
Abstract. The ﬁrst order logic Ring(0, +, ∗, <) for ﬁnite residue class
rings with order is presented, and extensions of this logic with generalized
quantiﬁers are given. It is shown that this logic and its extensions cap-
ture DLOGT IME-uniform circuit complexity classes ranging from AC0
to T C0. Separability results are obtained for the hierarchy of these logics
when order is not present, and for Ring(0, +, ∗, <) from the unordered
version. These separations are obtained using tools from class ﬁeld the-
ory, adapting notions as the spectra of polynomials over ﬁnite ﬁelds to
sets of sentences in this logic of ﬁnite rings, and studying asymptotic
measures of these sets such as their relative densities. This framework of
ﬁnite rings with order provides new algebraic tools and a novel perspec-
tive for descriptive complexity.
1
Introduction
We study the ﬁrst order logic for ﬁnite residue class rings, denoted Ring(0, +, ∗),
and extensions of this logic with built-in order < (denoted by Ring(0, +, ∗, <)),
and generalized quantiﬁers (modular quantiﬁers ∃r,q, and majority M, denoted
respectively by Ring(0, +, ∗, <)+MOD(q) and Ring(0, +, ∗, <)+M). The struc-
tures for these logics are the ﬁnite residue classes Zm (m positive integer) with
modular addition and multiplication. We show that the expressive power of this
logic, in the presence of built-in order, coincides with the ﬁrst order logic for the
standard ﬁnite models with arithmetic operations as considered in [6,8]. There-
fore, from the descriptive complexity perspective, the computational complexity
classes that can be described with these algebraic models are the DLOGT IME-
uniform circuit complexity classes, consisting of circuits of constant depth and
polynomial size for which a description can be eﬃciently computed from the size
of their inputs [8].
The perspective of ﬁnite residue class rings as instances of problems in these
circuit complexity classes allow us to use the extensive algebraic machinery
proper of ﬁnite rings and ﬁelds of integer polynomials, algebraic number the-
ory and, in general, tools from class ﬁeld theory to study expressibility problems
⋆Research supported by MICINN project TIN2011-27479-C04-03 (BASMATI), Gen.
Cat. 2009-SRG-1428 (LARCA) and MTM2012-36917-C03-03 (SINGACOM)
L. Libkin, U. Kohlenbach, and R. de Queiroz (Eds.): WoLLIC 2013, LNCS 8071, pp. 49–63, 2013.
c
⃝Springer-Verlag Berlin Heidelberg 2013

50
A. Arratia and C.E. Ortiz
in these logics. More speciﬁcally, we use the notion of the prime spectrum of a
sentence, deﬁned as the collection of primes p such that the sentence holds in
Zp. Using classical results of Ax and Lagarias [1,2,10] on the nature of these
sets of primes for sentences in Ring(0, +, ∗), we separate Ring(0, +, ∗) from
Ring(0, +, ∗) + MOD(q) (for every natural q > 1). Moreover, we use a much
studied asymptotic measure associated with inﬁnite sets of primes, the so-called
natural density, together with a result of Friedlander and Iwaniec [7] on the na-
tural density of the set of prime values of polynomials, to separate Ring(0, +, ∗)
from Ring(0, +, ∗, <). The previous results suggest that the notion of density
of prime spectra may be useful to separate subclasses of Ring(0, +, ∗, <) + M.
To further that aim, we study the behavior of the density of the spectra of sen-
tences in Ring(0, +, ∗, <) + MOD(q) and prove that there exist sentences in
this extended ring logic whose prime spectrum has no natural density.
2
Preliminaries
We are interested in the uniform version of the circuit complexity classes ranging
from AC0 to T C0. Recall that AC0 is the class of languages accepted by polyno-
mial size, constant depth circuits with NOT gates and unbounded fan-in AND
and OR gates. Extending AC0 circuits with unbounded MODq gates, for a ﬁxed
integer q > 1, one obtains the class ACC(q). For each integer q > 1, a MODq
gate reads its boolean input and returns a 1 if the sum of the input bits is divisi-
ble by q (i.e. the sum is equal to 0 mod q); otherwise it returns 0. Joining together
all the ACC(q) classes we get the class ACC, that is, ACC =

q>1
ACC(q). On
the other hand, extending AC0 circuits with unbounded MAJ gates one obtains
the class T C0. A MAJ (or majority) gate returns a 1 if the sum of n bits given
as input is greater or equal to n/2; otherwise it returns a 0. The languages de-
cided with the use of MODq gates can be decided by using MAJ gates instead.
This fact, together with all given deﬁnitions of these circuit classes, give us for
all q > 1 (cf. [4],[8])
AC0 ⊆ACC(q) ⊆ACC ⊆T C0
A circuit family is uniform if a description of each circuit can be computed ef-
ﬁciently from the size of the input; otherwise it is non-uniform. The uniformity
condition is crucial to relate time and space complexity with size and depth, the
measures for circuit complexity, since it can be shown that in the non uniform
setting there are sets with trivial circuit complexity that are not recursive (see
[5]). However, many important lower bounds are only known for the non uni-
form classes (see the survey [4]), and the challenge is to translate these to the
uniform setting or ﬁnd new methods that work for showing lower bounds within
uniform circuits.
Our approach to circuit complexity is through ﬁnite model theory, and as a
consequence we are working with circuit classes that are DLOGTIME-uniform,
for as it has been shown in [3], the languages in DLOGTIME-uniform circuit

Finite Rings and Circuit Complexity
51
classes AC0 to T C0 are deﬁnable in ﬁrst order logic with built-in arithmetic
predicates and some generalized quantiﬁers. This works as follows. Consider
ﬁrst the basic logic FO(≤, ⊕, ⊗), which is ﬁrst order logic with built-in order
relation ≤, and two ternary predicates ⊕and ⊗. In a ﬁnite model for this logic,
denoted here as Am (m is the cardinality of the model, and its universe is
|Am| = {0, 1, . . ., m −1}), the interpretation of ≤on Am is as a total ordering
on |Am|, and the interpretations of ⊕and ⊗are as truncated addition and
multiplication (e.g. any pair of elements that add up -or multiplies- to a quantity
greater than m is not a deﬁned triple). Consider further the following generalized
quantiﬁers:
(G1) Modular quantiﬁers, ∃(r,q), which for integers r and q, with 0 ≤r < q, and
ﬁrst order formula φ(x), the quantiﬁed formula ∃(r,q)xφ(x) holds in Am if
and only if the number of values for x that makes φ(x) true is equal to r
modulo q.
(G2) Majority quantiﬁer, M, which for ﬁrst order formula φ(x, z) with one free
variable z, (Mz)φ(a, z) holds in Am if and only if φ(a, z) is true for more
than half of the possible values for z.
Let FO(≤, ⊕, ⊗) + MOD(q), for a ﬁxed integer q > 1, be the logic FO(≤, ⊕, ⊗)
extended with modular quantiﬁers with moduli q; that is, the set of ﬁrst order
formulas as before plus the quantiﬁers ∃(r,q) with 0 ≤r < q.
Let FO(≤, ⊕, ⊗)+MOD =

q>1
(FO(≤, ⊕, ⊗)+MOD(q)), and FO(≤, ⊕, ⊗)+M
the logic extended with the majority quantiﬁer M. Barrington et al proved
Theorem 1 ([3]). The languages in DLOGTIME-uniform class C are exactly
those deﬁnable in the logic L, where C is AC0, ACC(q), ACC or T C0, and L is
FO(≤, ⊕, ⊗), FO(≤, ⊕, ⊗)+MOD(q), FO(≤, ⊕, ⊗)+MOD or FO(≤, ⊕, ⊗)+M,
respectively.
⊓⊔
3
The Logic of Finite Residue Class Rings and Uniform
Circuit Complexity Classes
In this section we deﬁne the ﬁrst order logic for ﬁnite residue class rings, and
extensions with modular and majority quantiﬁers. We use Z to denote the inte-
gers, R for the reals and P to denote the set of prime numbers. For integers a
and b, b ≡d a denotes that b is congruent to a modulo d, and (a, b) stands for the
greatest common divisor of a, b. For each m ∈Z, m > 0, we denote by Zm the
ﬁnite residue class ring of m elements. Zm, as an algebraic structure, consists
of a set of elements {0, 1, . . ., m −1}, and two binary functions + and ∗which
corresponds to addition and multiplication modulo m, respectively.
Deﬁnition 1. By Ring(0, +, ∗) we denote the logic of ﬁnite residue class rings.
This is the collection of ﬁrst order formulas over the set of built-in predicates
{0, +, ∗}, where 0 is a constant symbol, and + and ∗are binary function symbols.
The models of Ring are the ﬁnite residue class rings Zm, and in each Zm, the 0
www.allitebooks.com

52
A. Arratia and C.E. Ortiz
is always interpreted as the 0-th residue class (mod m), and + and ∗are addition
and multiplication modulo m.
By Ring(0, +, ∗, <) we denote the logic Ring(0, +, ∗) further extended with
an additional (built-in) order relation <. In this extension each ﬁnite ring Zm
is endowed with an order of its residue classes, given by the natural ordering of
the representatives of each class from {0, 1, . . ., m −1}. Also, in this case, the
constant 0 represents the ﬁrst element in this order.
We can further extend Ring(0, +, ∗) or Ring(0, +, ∗, <) with modular quantiﬁers
and the majority quantiﬁer.
Deﬁnition 2. For every integer q > 0, we denote by Ring(0, +, ∗) + MOD(q)
and Ring(0, +, ∗, <) + MOD(q) the extensions of the logics Ring(0, +, ∗) and
Ring(0, +, ∗, <) obtained by the additional requirement that these logics be closed
for the quantiﬁers ∃(r,q)x, for every r = 0, 1, . . . , q −1. These quantiﬁers are in-
terpreted in Zm as in (G1). We deﬁne Ring(0, +, ∗) + MOD = Ring(0, +, ∗) +
	
q>0 MOD(q) and Ring(0, +, ∗, <)+MOD = Ring(0, +, ∗, <)+	
q>0 MOD(q).
Finally, we denote by Ring(0, +, ∗)+MOD+M and Ring(0, +, ∗<)+MOD+M
the extensions of the logic Ring(0, +, ∗) + MOD and Ring(0, +, ∗, <) + MOD
obtained by the additional requirement that these logics be closed for the majority
quantiﬁer Mz, interpreted in Zm as in (G2).
Our ﬁrst theorem states that in the presence of a built-in order relation it is
logically indistinct to work with the standard ﬁnite models Am or with the ﬁnite
residue class rings Zm. The proof of this fact is long and technically involved; so
we state this important result below and postpone the technical details and full
proof to the Appendix.
Theorem 2. For every formula φ(x1, . . . , xk) of FO(≤, ⊕, ⊗), there exists a
formula Φ(x1, . . . , xk) of Ring(0, +, ∗, <) such that for every ﬁnite structure Am
and integers a1, . . . , ak < m,
Am |= φ(a1, . . . , ak) if and only if Zm |= Φ(a1, . . . , ak).
Conversely, for every formula φ(x1, . . . , xk) of Ring(0, +, ∗, <), there exists
a formula Φ(x1, . . . , xk) of FO(≤, ⊕, ⊗) such that for every ﬁnite structure Zm
and integers a1, . . . , ak < m,
Zm |= φ(a1, . . . , ak) if and only if Am |= Φ(a1, . . . , ak).
⊓⊔
The result also applies to the respective extensions of the logics with modular
quantiﬁers and the majority quantiﬁer.
Remark 1. Deﬁnability (or expressibility) in the logic of ﬁnite rings is given
in terms of the ﬁnite residue structures Zm. That is, whenever we say that a
property of integers P(x) is deﬁnable in Ring(0, +, ∗, <), or any fragment L
thereof, we mean that there exists a sentence ϕ of L such that for every natural
m, P(m) holds in Z ⇐⇒Zm |= ϕ.
For a given circuit class C, we say that it is deﬁnable in the ring logic L if
every property P(x) decidable in C is deﬁnable in L and, for every sentence ϕ
in L, the set of natural numbers m such that Zm |= ϕ, is decidable in C.
⊓⊔

Finite Rings and Circuit Complexity
53
As a consequence of the logical equivalence in Theorem 2, any separation result
proved for fragments of Ring(0, +, ∗, <) + MOD + M can be translated into
a corresponding separation result in fragments of FO(≤, ⊕, ⊗) + MOD + M,
with the respective implications to circuit complexity. More speciﬁcally, from
Theorem 2 and Theorem 1 we have the following deﬁnability of uniform circuit
classes in ring logics.
Theorem 3. 1) DLOGTIME-uniform AC0 is deﬁnable by Ring(0, +, ∗, <).
2) DLOGTIME-uniform ACC(q) is deﬁnable by Ring(0, +, ∗, <) + MOD(q),
for every natural q.
3) DLOGTIME-uniform ACC is deﬁnable by Ring(0, +, ∗, <) + MOD.
4) DLOGTIME-uniform T C0 is deﬁnable by Ring(0, +, ∗, <) + MOD+ M.
⊓⊔
4
The Prime Spectrum of a Sentence
In this section we separate the expressive power of Ring(0, +, ∗) from that of
Ring(0, +, ∗) + MOD(d) for every natural d > 1.
Deﬁnition 3. The prime spectrum of a sentence σ of Ring(0, +, ∗, <)+MOD+
M is deﬁned as the set of primes Sp(σ) = {p ∈P : Zp |= σ}.
The set Sp(σ) was introduced by James Ax in connection with his proof of de-
cidability of the theory of ﬁnite ﬁelds [2]. In particular, Ax proved the following:
Theorem 4 (J. Ax [2]). The spectrum Sp(σ) of any sentence σ of Ring(0, +, ∗)
is, up to ﬁnitely many exceptions, a Boolean combination of sets of the form
Sp(∃t(f(t) = 0)), where f(t) ∈Z[t] is a polynomial with integer coeﬃcients.
⊓⊔
Therefore to characterize the spectra of sentences of Ring(0, +, ∗) it is suﬃcient
to analyze the spectra of sentences of the form ∃x(f(x) = 0) for polynomials
f ∈Z[x]. Given a polynomial f(x) ∈Z[x], we will indistinctly denote by Sp(f)
or Sp(∃x(f(x) = 0)) the spectrum of the sentence ∃x(f(x) = 0). A basic result
of Schur states that every non constant polynomial has an inﬁnite number of
prime divisors; that is, Sp(f) is inﬁnite for any f ∈Z[x] \ Z (see [9, Thm. 1] for
an elementary proof of this fact). If f is irreducible then the same can be said
about the complement of Sp(f), namely,
Sp(f)c := Sp(∀x(f(x) ̸= 0)) = {p ∈P : Zp ̸|= ∃x(f(x) = 0)}
Thus, we have the following properties of spectra of the form Sp(f).
Theorem 5. (1) For any f ∈Z[x] \ Z, Sp(f) is inﬁnite.
(2) If, additionally, f is irreducible, then Sp(f)c is inﬁnite.
⊓⊔
This theorem justiﬁes to consider two spectra as equal if they coincide in all but
a ﬁnite number of primes, and we denote this by Sp(f) =∗Sp(g).
Let S denote any system of polynomial congruences such as:
(S) :
f1(x1, . . . , xn) ≡p 0, . . . , fm(x1, . . . , xn) ≡p 0

54
A. Arratia and C.E. Ortiz
with each fi ∈Z[x1, . . . , xn]. Let Σ(S) be the set consisting of all p ∈P for
which S is solvable. Let B be the Boolean algebra of subsets of P generated by
all the sets Σ(S), and let Bk be the Boolean algebra generated by sets Σ(S),
where the polynomials in S are restricted to have at most k variables, i.e.,
f1(x1, . . . , xk) ≡p 0, . . . , fm(x1, . . . , xk) ≡p 0
(1)
The Boolean algebra B corresponds to the collection of spectra of sentences in
Ring(0, +, ∗) which, by Theorem 4, collapses to its ﬁrst level B1. Lagarias in
[10] considered this algebra B and gave a characterization of the sets of integer
congruences {p ∈P : p ≡d a}, for given positive integers d and a, that are in B.
Theorem 6 ([10, Theorem 1.4]). For any pair of integers a and d, the set
{p ∈P : p ≡d a} is in the Boolean algebra B if and only if a is of order 1 or 2
in Zd (i.e. a ≡d 1 or a2 ≡d 1), or (a, d) > 1.
⊓⊔
Rephrasing this theorem in terms of spectra of sentences we obtain:
Theorem 7. For any pair of positive integers a and d, with 1 < a < d, the set
{p ∈P : p ≡d a} is the spectrum of a sentence in Ring(0, +, ∗) if and only if
a2 ≡d 1 or (a, d) > 1.
⊓⊔
We use this theorem to separate Ring(0, +, ∗) from Ring(0, +, ∗)+MOD(d) for
d an arbitrary positive integer.
Remark 2. In Ring(0, +, ∗) + MOD(d) we have that ∀a < d,
Sp

∃a,d(x = x)

=∗{p ∈P : p ≡d a}.
Therefore, by Theorem 7, if we can ﬁnd for every d an 1 < a < d that is relatively
prime to d, and such that a2 ̸≡d 1, then we have a set of primes deﬁnable in
Ring(0, +, ∗) + MOD(d) that is not deﬁnable in Ring(0, +, ∗). Note ﬁrst that
if there exists a < p with a2 ̸≡p 1 then for every α, a2 ̸≡pα 1. Also note that
for every prime p > 3 we have that 22 = 4 ̸≡p 1. Hence, for any prime p > 3
and any α there exist a < p such that (a, p) = 1 and a2 ̸≡pα 1. Consider
now an arbitrary integer d and its prime decomposition: d = pα1
1 pα2
2 . . . pαn
n . If
one of the pi is greater than 3 then there exists a < pi such that (a, pi) = 1
and a2 ̸≡p1 1. Recall that Zd ∼= Zpα1
1
× Zpα2
2
× . . . Zpαn
n . Because of this ring
isomorphism, we will identify the elements of Zd with the corresponding tuples
in Zpα1
1
× Zpα2
2
× . . . Zpαn
n . Then the element (1, . . . , a, . . . , 1), with a in the i-th
coordinate and 1 everywhere else, is relatively prime to d. The only elements that
are not relatively prime to d are the ones of the form (a1, a2, . . . , an) where for
some i, ai = 0 or ai = pβ
i with 1 < β < αi. Also note that (1, . . . , a, . . . , 1)2 ̸≡d
(1, . . . , 1, . . . , 1). Looking now at powers of 3 and 2, note that 32 ≡24 9 ̸≡24 1,
and that 22 ≡32 4 ̸≡32 1 so we can repeat the above argument. Hence, for any
d such that there is a prime > 3 that divides d, or 32 or 24 divides d, we have
that there exists a < d such that (a, d) = 1 and a2 ̸≡d 1. Hence, for such a d,
{p ∈P : p ≡d a} is not expressible in Ring(0, +, ∗).
We summarize these remarks in the following propositions.

Finite Rings and Circuit Complexity
55
Proposition 1. For every natural number d ̸= 2α3β, 0 ≤α ≤3, 0 ≤β ≤1 and
d > 1, there exists a < d with (a, d) = 1 and a2 ̸≡d 1.
⊓⊔
Proposition 2. For every natural number d ̸= 2, 3, 4, 6, 8, 12, 24 there exists
a < d such that there is no sentence θ ∈Ring(0, +, ∗) equivalent to ∃a,d(x = x).
Hence, in terms of expressive power, for every d ̸= 2, 3, 4, 6, 8, 12, 24,
Ring(0, +, ∗) ⊊Ring(0, +, ∗) + MOD(d).
⊓⊔
The problem with d = 2, 3, 4, 6, 8, 12, 24 is that for each one of these d, ∀a ∈Zd,
either a and d are not relatively prime, or a2 ≡d 1. Hence for such integers we
can not use the canonical counterexample above to separate Ring(0, +, ∗) from
Ring(0, +, ∗)+MOD(d). However, we have obtained the desired inexpressibility
for these integers through direct combinatorial, yet convoluted, arguments. We
omit the details due to space restrictions, and just point out the general plan of
the proof. For each one of the integer values of d listed above, the key idea is
to express in Ring(0, +, ∗) + MOD(d) a property of the form {p : p ≡dγ c}, for
some c < dγ such that c2 ̸≡dγ 1 for some integer γ. Then, from Theorem 7 we
can conclude that this property is not expressible in Ring(0, +, ∗).
Theorem 8. For all integer d ̸= 1, Ring(0, +, ∗) ⊊Ring(0, +, ∗) + MOD(d).
5
The Density of the Prime Spectrum of a Sentence
In this section we prove that the expressive power of Ring(0, +, ∗) is diﬀerent
from the expressive power of Ring(0, +, ∗, <). A way of discerning inﬁnite sets
of primes is to compare their relative sizes. Given S ⊂P, the natural density of
S is deﬁned as δ(S) = lim
t→∞
|{p ∈S : p < t}|
|{p ∈P : p < t}|, whenever this limit exists. Note
that if S is ﬁnite then δ(S) = 0; and if S and T are two sets of primes such that
S =∗T then δ(S) = δ(T ).
The following observation will be helpful for computing the natural density.
By the Prime Number Theorem, the number of primes less than t is asymptotic
to t/ ln t. Therefore,
δ(S) = lim
t→∞
|{p ∈S : p < t}|
|{p ∈P : p < t}| = lim
t→∞

ln t
t

· |{p ∈S : p < t}|
(2)
We will also need the following well known theorem on the density of spectra of
irreducible polynomials (cf. [11, §5]).
Theorem 9 (Weak C˘ebotarev Theorem). If f(x) is an irreducible polyno-
mial in Z[x] of degree n, then δ(Sp(f)) = 1/n.
⊓⊔
From this theorem it follows that every element of the Boolean algebra B1 has
rational density, and it is 0 if and only if the set is ﬁnite. Together with Ax’s
result (Theorem 4) we obtain:
Theorem 10. The spectrum of any sentence in Ring(0, +, ∗) has rational den-
sity, and this density is 0 if and only if the spectrum is ﬁnite.
⊓⊔

56
A. Arratia and C.E. Ortiz
We are going to prove that this is not the case for the spectra of sentences in
Ring(0, +, ∗, <). More speciﬁcally, there exists sentences σ ∈Ring(0, +, ∗, <)
such that the density of Sp(σ) is zero, but the cardinality of Sp(σ) is inﬁnite.
An outstanding result by Friedlander and Iwaniec in [7] states that the poly-
nomial f(x, y) = x2 + y4 has inﬁnitely many prime values. More speciﬁcally,
Theorem 11 ([7]). There are inﬁnitely many primes p of the form p = a2 +b4,
for integers a and b, and the number of these primes p < t is O(t3/4).
⊓⊔
Using this result and (2) we obtain that the density of the set of primes
FI := {p ∈P : p = a2 + b4, a, b ∈Z}
is of order lim
t→∞
ln t
t1/4 = 0. By Theorem 10 the set FI cannot be the spectrum of
a sentence in Ring(0, +, ∗). It remains to show that the set FI is deﬁnable in
Ring(0, +, ∗, <). We can in fact show a stronger result.
Theorem 12. Consider a polynomial in Z[x, y] of the form f(x, y) = h(x) +
g(y), with n the degree of h and d the degree of g. Assume that n, d ≥1 and
that the leading coeﬃcients of h(x) and g(x) are positive. Then there exists a
sentence φf ∈Ring(0, +, ∗, <) such that for almost every natural m:
Zm |= φf if and only if “m is prime and there exists naturals a, c < m such
that f(a, c) = m”.
Proof Sketch. The ith derivative of h(x) is a polynomial of degree n −i with
positive leading coeﬃcient, hence eventually increasing. Then, for some M, the
functions g, h, and the derivatives h(1), h(2), . . . , h(n) are strictly increasing and
positive in [M, +∞), and for every x > M, h(x) > h(1)(x)+ h(2)(x)
2!
+. . .+ h(n)(x)
n!
.
Fix m > M + 1. Then, for every pair of integers b + 1, c ∈(M, m), if Z |=
h(b) + g(c) < m ≤h(b + 1) + g(c) then h(b + 1) + g(c) −m < h(b) + g(c) < m. It
follows that for every M < c < m the smallest value M < b + 1 < m for which
Z |= h(b + 1) + g(c) ≥m can be characterized as the smallest value b > M such
that Zm |= h(b + 1) + g(c) < h(b) + g(c). This last statement is expressible in
Ring(0, +, ∗, <) by a formula ψ(b, c). Putting together the previous observations
we obtain that for every m > M:
Zm |= ∃b, c(ψ(b, c)∧f(b+1, c) = 0) iﬀZ |= ∃b, c(b, c < m−1∧f(b+1, c) = m).⊓⊔
As a corollary of this theorem we obtain:
Theorem 13. Ring(0, +, ∗) is properly contained in Ring(0, +, ∗, <).
⊓⊔
6
On the Existence of Spectra without Density
The results of the previous section suggest that the notion of density may be
useful for separating fragments of Ring(0, +, ∗, <) + MOD + M. Therefore we
study the behavior of the spectra for sentences in Ring(0, +, ∗, <) + MOD. We
ﬁrst show that the addition of order to Ring(0, +, ∗) enriches so much this logic
that we can code the modular semantics of Ring(0, +, ∗, <) within itself.

Finite Rings and Circuit Complexity
57
Theorem 14 (Coding Theorem). For all ϕ(x) in Ring(0, +, ∗, <) there ex-
ists a formula T RANϕ(x, y) in Ring(0, +, ∗, <) such that for every natural m,
for any b < m and any tuple a < b < m, Zb |= ϕ(a) ⇐⇒Zm |= T RANϕ(a, b).
Proof. The proof is by induction in formulas, and is given in the Appendix.
⊓⊔
Remark 3. A similar theorem holds for any fragment of Ring(0, +, ∗, <)+MOD+
M that contains Ring(0, +, ∗, <).
⊓⊔
Remark 4. In the rest of the section, when describing the spectrum of a sentence
as Sp(σ) = {pn}n∈ω we assume that p1 < p2 < . . . < pn < . . ..
⊓⊔
The second ingredient is to focus on sentences in Ring(0, +, ∗, <) that are “thin”
in the following sense.
Deﬁnition 4. A sentence θ in Ring(0, +, ∗, <)+MOD+M has a thin spectrum
if |Sp(θ)| = ω and there exists a real number r ≥2 such that when listing the
elements of Sp(θ) as p1 < p2 < . . . < pn < . . ., we have that for almost all
natural numbers n, rpn < pn+1.
Essentially the spectrum of a sentence is “thin” if the distance between consec-
utive primes in the spectrum increases exponentially.
Example 1. For every q prime, let FIRST PRIMEq be the property that says:
The cardinality of the structure is a prime number p and, if qk < p < qk+1
for some positive integer k, then there is no prime h such that qk < h < p.
Since Ring(0, +, ∗, <) = FO(≤, ⊕, ⊗) it is easy to see that the property “x is a
power of y” (i.e., the usual exponentiation in Z) is deﬁnable in Ring(0, +, ∗, <).
It follows that FIRST PRIMEq is deﬁnable in Ring(0, +, ∗, <). On the other
hand, one can see that for q > 6, FIRST PRIMEq has thin spectrum.
⊓⊔
Deﬁnition 5. For a positive integer x, π(x) = |{q ∈P : q ≤x}|. By extension,
for a given sentence σ, we deﬁne πσ(x) = |{q ∈P : q ≤x ∧Zq |= σ}|.
Using the fact that the function F(x) =
x
ln(x) is strictly increasing in R, observe
that if the spectrum of a sentence θ is thin, with Sp(θ) = {pn}n∈ω, then for
almost all natural numbers n we have that

pn+1
ln(pn+1)

>

pn
ln(pn)
 ⎛
⎝
r
(1 +
ln(r)
ln(pn))
⎞
⎠> 2

pn
ln(pn)

.
These inequalities, together with the Prime Number Theorem, give us a charac-
terization of thin spectra in terms of the numbers π(pn):
Proposition 3. For a sentence θ with thin spectrum Sp(θ) = {pn}n∈ω we have
that, for almost all natural numbers n, 2π(pn) < π(pn+1).
⊓⊔

58
A. Arratia and C.E. Ortiz
Our main interest on sentences with thin spectrum is that, in the modular logics
Ring(0, +, ∗, <)+MOD(q) (q natural number), they generate sentences without
natural density. We begin by looking at the logic Ring(0, +, ∗, <) + MOD(2).
Consider the sentence PRIME in Ring(0, +, ∗) which says that the size of ﬁnite
ring model is prime (it is enough to say that every element has a multiplicative
inverse). By Theorem 14 and Remark 3 for every sentence θ in Ring(0, +, ∗, <)
+MOD, we have that T RANθ is the coding of θ in the residue classes.
Theorem 15. If θ is a sentence in Ring(0, +, ∗, <) + MOD(2) with thin spec-
trum then the spectrum of the sentence
ψ := PRIME ∧∃0,2x (T RANθ(x) ∧T RANP RIME(x))
has no density. Note also that ψ is a sentence in Ring(0, +, ∗, <) + MOD(2).
The sentence ψ above essentially says: “The size of the model is a prime q and
the number of primes p < q such that Zp |= θ is even”. This sentence has no
density because the increasing sequence of all primes alternates between intervals
of exponential length where any prime in it satisﬁes ψ, followed by intervals of
exponential length where no prime in it satisﬁes ψ. Thus the lim sup of the
density of ψ is strictly greater than 1/2 but the lim inf is strictly less than 1/2.
The full proof of this theorem is in the Appendix. Since Example 1 gives us a
thin sentence in Ring(0, +, ∗, <) we then have
Corollary 1. There exist sentences in Ring(0, +, ∗, <)+MOD(2) whose prime
spectrum has no density.
⊓⊔
The previous result can be generalized to Ring(0, +, ∗, <)+ MOD(q), for every
integer q > 1; hence showing that in these logics we have sentences whose prime
spectrum have no density.
7
Final Comments
We have established the separation of subclasses of Ring(0, +, ∗, <) + MOD
using results from number theory and the notions of prime spectra of sentences
and their natural density. Given the fact that separation of Ring(0, +, ∗, <) from
Ring(0, +, ∗, <) + MOD(2) will yield that
DLOGT IME-uniform AC0 ̸= DLOGT IME-uniform ACC(2),
and that similar separations for fragments of the logic Ring(0, +, ∗, <)+MOD+
M will yield separations for DLOGT IME uniform classes such as T C0 and
ACC, we believe that it is relevant to understand the prime spectra of sentences
in Ring(0, +, ∗, <) + MOD + M. Of particular interest to us are the following
questions:
– Does every spectrum in Ring(0, +, ∗, <) has a density? If that is the case,
then this would separate this logic from Ring(0, +, ∗, <)+MOD(2) because
of Theorem 15.

Finite Rings and Circuit Complexity
59
– What can be said of the spectrum of a sentence in Ring(0, +, ∗) + MOD(n)
for n positive integer? The goal here is to separate Ring(0, +, ∗)+ MOD(n)
from Ring(0, +, ∗) + MOD(m), for m ̸= n positive integers.
– What can be said of the spectrum of a sentence in Ring(0, +, ∗, <)+M? We
expect these sets to be much more “wild” that the spectra of sentences in
Ring(0, +, ∗, <) because of the expressive power of the majority quantiﬁer.
Thus we believe that a diﬀerent concept from natural density should be used
to study these spectra.
Acknowledgements. The authors gratefully acknowledge the fruitful com-
ments of the three anonymous reviewers that lead to an improvement of the
original manuscript.
References
1. Ax, J.: Solving diophantine problems modulo every prime. Ann. of Math. 85(2),
161–183 (1967)
2. Ax, J.: The elementary theory of ﬁnite ﬁelds. Ann. of Math. 88(2), 239–271 (1968)
3. Barrington, D., Immerman, N., Straubing, H.: On uniformity within NC1. J. Com-
puter and Syst. Sci. 41, 274–306 (1990)
4. Boppana, R., Sipser, M.: The complexity of ﬁnite functions. In: van Leeuwen, J.
(ed.) Handbook of Theoretical Computer Science. Algorithms and Complexity,
vol. A, pp. 757–804. Elsevier (1990)
5. Borodin, A.: On relating time and space to size and depth. SIAM J. Comput. 6(4),
733–744 (1977)
6. Ebbinghaus, H.D., Flum, J.: Finite Model Theory. Springer (1995)
7. Friedlander, J., Iwaniec, H.: Using a parity-sensitive sieve to count prime values of
a polynomial. Proc. Natl. Acad. Sci. USA 94, 1054–1058 (1997)
8. Immerman, N.: Descriptive Complexity. Springer (1998)
9. Gerst, I., Brillhart, J.: On the prime divisors of polynomials. American Math.
Monthly 78(3), 250–266 (1971)
10. Lagarias, J.C.: Sets of primes determined by systems of polynomial congruences.
Illinois J. Math. 27(2), 224–239 (1983)
11. Wyman, B.F.: What is a Reciprocity Law? American Math. Monthly 79(6), 571–
586 (1972)
Appendix
We now proceed to prove that the expressive power of FO(≤, ⊕, ⊗) is contained
in the expressive power of Ring(0, +, ∗, <). Recall that the built-in predicates of
FO(≤, ⊕, ⊗) are an ordering relation and two ternary relations: ⊕(x, y, z) and
⊗(x, y, z), interpreted in ﬁnite models Am as truncated natural addition and
multiplication. We have to see how to interpret these predicates in the arithmetic
of residue classes.
Lemma 1. There exists ﬁrst order formulas ADD(x, y, z) and PROD(x, y, z)
of Ring(0, +, ∗, <) such that for every structure Am of FO(≤, ⊕, ⊗), for every
a, b, c < m, Am |= ⊕(a, b, c) if and only if Zm |= ADD(a, b, c), and
Am |= ⊗(a, b, c) if and only if Zm |= PROD(a, b, c).

60
A. Arratia and C.E. Ortiz
Proof. Note that in any model Am, for any three elements a, b, c ∈Am, Am |=
⊕(a, b, c) if and only if Zm |= a+ b = c and for every 0 < y ≤b, Zm |= a+ y ̸= 0.
Note now that for any two elements d ≤e < m, if Z |= e + d ≥m then
the reminder of dividing e + d by m is actually less than e, i.e Zm |= e + d < e.
Thanks to this observation we have that for any three elements a, b, c ∈Am with
a, b ̸= 0, Am |= ⊗(a, b, c) if and only if Zm |= a ∗b = c and Zm |= a < a ∗2 <
a ∗3 < . . . < a ∗b. It follows that the desired formulas are the following:
ADD(x, y, z) := (x + y = z ∧∀r < x(y + r ̸= 0))
PROD(x, y, z) := (x = y = z = 0) ∨((x ̸= 0 ∧y ̸= 0) ∧
(x ∗y = z) ∧∀r < y(x ∗r ≤x ∗r + r))
□
The rest of this section is devoted to prove that the expressive power of Ring(0,
+, ∗, <) is contained in the expressive power of FO(≤, ⊕, ⊗).
We begin by showing how to simulate the modular addition in FO(≤, ⊕, ⊗).
Suppose we are in Zm, and let a, b < m. If a+ b = c < m then the sum (mod m)
of a and b coincides with the natural addition, that is, Am |= ⊕(a, b, c). However,
if a + b ≥m then a + b = m + c, with c < m, and a + b ≡m c. In this case
note that a + w = m and b = w + c, for some w < m. Thus, we can describe
in FO(≤, ⊕, ⊗) the statement Zm |= a + b = c, whenever a + b ≥m, by a ﬁrst
order expression that says that for some w, a + w = m (the cardinality of the
model), and b = w + c, the latter being a natural sum (i.e. in Am). We formalise
this idea below.
Lemma 2. There exists a formula SUM(x, y, z) of FO(≤, ⊕, ⊗) such that for
every model Zm of Ring(0, +, ∗, <), for every a, b, c < m,
Zm |= a + b = c ⇐⇒Am |= SUM(a, b, c)
Proof. Consider the following formula in FO(≤, ⊕, ⊗) of free variables x and y
COMP(x, y) := (∀u < y∃w(⊕(x, u, w))) ∧∀w(¬ ⊕(x, y, w))
that says that y is the ﬁrst element of the model such that ∀z¬⊕(x, y, z). Then,
for a, b < m, Am |= COMP(a, b) ⇐⇒a + b ≡m 0, and we have
SUM(x, y, z) := ⊕(x, y, z) ∨∃w(COMP(x, w) ∧⊕(w, z, y)).
⊓⊔
Next we show how to simulate the modular multiplication in FO(≤, ⊕, ⊗). Let us
ﬁrst explain the intuition behind. Our goal is to show that the modular operation
ab ≡m c can be described by formulas of FO(≤, ⊕, ⊗). To achieve this goal we
shall show that we can decompose a and b in the following form: pick the least
u < m such that u2 > m, and write a = k1u + t1 and b = k2u + t2, for some
k1, k2, t1, t2 < u. Note that u does not depend on a or b, but the decomposition
above does depend on u. Then ab can be decomposed as
ab ≡m (k1u + t1)(k2u + t2) ≡m (k1k2)u2 + (k1t2)u + (k2t1)u + t1t2
Since k1k2, k1t2, k2t1, k2t1 < m (by the way we chose u), these products are all
describable in FO(≤, ⊕, ⊗). Finally, we show that for any h < m, the products hu

Finite Rings and Circuit Complexity
61
and hu2 are deﬁnable in FO(≤, ⊕, ⊗). The key in this last step is to decompose
u as (u −1) + 1, and decompose u2 ≡m su + t, for s = 0, 1 and t < u. This last
expression follows by the characteristics of u. Then use these decompositions of u
and u2 to decompose further (k1k2)u2 +(k1t2)u+(k2t1)u+t1t2 into summands
so that each will be expressible in FO(≤, ⊕, ⊗), and then invoking Lemma 2,
we get that this sum, and hence the modular product ab ≡m c, is expressible in
FO(≤, ⊕, ⊗). We now present the formal details.
Lemma 3. Let m be a positive integer. Let u be the smallest positive integer
such that u < m and u2 > m. Then:
1. u is deﬁnable in FO(≤, ⊕, ⊗).
2. There exists s ∈{0, 1} and w < u such that u2 ≡m su + w. Furthermore the
statement u2 ≡m su + w is deﬁnable in FO(≤, ⊕, ⊗).
3. For every a, b < m, there exists k1, k2, t1, t2 < u, such that a ≡m k1u+t1 and
b ≡m k2u+t2. Furthermore, the statements a ≡m k1u+t1 and b ≡m k2u+t2
are deﬁnable in FO(≤, ⊕, ⊗).
Proof.
1. Consider the following formula of FO(≤, ⊕, ⊗) in the variable u:
ROOT (u) := ∀t < u∃w(⊗(t, t, w)) ∧∀w(¬ ⊗(u, u, w))
(3)
Then, for an element u in Am, Am |= ROOT (u) if and only if u is the
smallest element of Am such that u2 > m.
2. Since (u −1)2 < m < u2, then if we divide u2 by m we get u2 = km + r, for
some k < m and some r < u2 −(u −1)2 = 2u −1 < 2u. Hence, r = su + w
with s ∈{0, 1} and w < u. Note ﬁnally that u2 ≡m su + w with s ∈{0, 1}
and w < u if and only if (u−1)u+(1−s)u ≡m w. Since the result of each one
of these products is less that m, and we proved that addition modulo m is
deﬁnable in FO(≤, ⊕, ⊗), we can conclude that the statement u2 ≡m su + w
with s ∈{0, 1} and w < u is deﬁnable in FO(≤, ⊕, ⊗).
3. If a, b < u then a = 0u + a and b = 0u + b. If a or b ≥u then the expressions
follow by simple division by u (which is deﬁnable in FO(≤, ⊕, ⊗)) and by
using the fact after division k1, k2, t1, t2 are less than u so that that the
products k1u, k2u are directly deﬁnable using ⊗. The expresibility of these
formulas in FO(≤, ⊕, ⊗) is left to the reader.
⊓⊔
Lemma 4. Let m and u be as in the previous lemma. For every a, c < m, the
modular relations au ≡m c and au2 ≡m c are expressible in FO(≤, ⊕, ⊗).
Proof. We have that au ≡m c if and only if
∃u∃k1, t1 (k1 < u ∧t1 < u ∧ROOT (u) ∧a ≡m k1u + t1 ∧c ≡m (k1u + t1)u) iﬀ
∃u∃k1, t1

k1 < u ∧t1 < u ∧ROOT (u) ∧a ≡m k1u + t1 ∧c ≡m k1u2 + t1u

iﬀ
∃u∃k1, t1(k1 < u ∧t1 < u ∧ROOT (u) ∧a ≡m k1u + t1 ∧
∃s, u, w(s = 0 ∨s = 1 ∧w < u ∧u2 ≡m su + w ∧c ≡m k1(su + w) + t1u))
iﬀ
∃u∃k1, t1(k1 < u ∧t1 < u ∧ROOT (u) ∧a ≡m k1u + t1 ∧
∃s, u, w(s = 0 ∨s = 1 ∧w < u ∧u2 ≡m su + w ∧c ≡m k1su + k1w + t1u))
www.allitebooks.com

62
A. Arratia and C.E. Ortiz
From the above equivalence and from Lemmas 2 and 3 we can conclude that
au ≡m c is expressible in FO(≤, ⊕, ⊗). Analogously, note that
au2 ≡m c iﬀ∃k1, t1(k1 < u ∧t1 < u ∧ROOT (u) ∧
a ≡m k1u + t1 ∧(k1u + t1)u2 ≡m c).
As in the previous case, note also that
c ≡m (k1u + t1)u2 iﬀ∃s, u, w(s = 0 ∨s = 1 ∧w < u
∧u2 ≡m su + w ∧c ≡m (k1u + t1)(su + w))
and this last statement is equivalent to
∃s, u, w(s = 0∨s = 1∧w < u∧u2 ≡m su+w ∧c ≡m k1su2 +t1su+k1wu+t1w)
which in turn, replacing u2, is equivalent to
∃s, u, w(s = 0∨s = 1∧w < u∧u2 ≡m su+w∧c ≡m k1s(su+w)+t1su+k1wu+t1w)
From Lemmas 2 and 3 we conclude from this expression that the relation au2 ≡m
c is also deﬁnable in FO(≤, ⊕, ⊗).
⊓⊔
We can now show that the modular product is deﬁnable in FO(≤, ⊕, ⊗).
Theorem 16. For every a, b, c < m, the modular product ab ≡m c is deﬁnable
in FO(≤, ⊕, ⊗), i.e., there exists a formula PROD(x, y, z) of FO(≤, ⊕, ⊗) such
that for every model Zm of Ring(0, +, ∗, <), for every a, b, c < m,
Zm |= a ∗b = c ⇐⇒Am |= PROD(a, b, c)
Proof. ab ≡m c if, and only if, for the smallest u < m, for which u2 > m, there
exists k1, t1, k2, t2 < u such that a ≡m k1u + t1 and b ≡m k2u + t2, and
c ≡m (k1u + t1)(k2u + t2) ≡m (k1k2)u2 + (k1t2)u + (t1k2)u + t1t2
By Lemma 4, the relations (k1k2)u2 ≡m x, (k1t2)u ≡m y and (t1k2)u ≡m z are
all deﬁnable in FO(≤, ⊕, ⊗); u is deﬁnable and also the relations a ≡m k1u + t1
and b ≡m k2u+t2 are deﬁnable in FO(≤, ⊕, ⊗). Using Lemma 2 we can obtain a
deﬁnition for the relation ab ≡m c in FO(≤, ⊕, ⊗) with a, b, c as parameters.
⊓⊔
Proof of the Atomic Case for the Coding Theorem (Theorem 14).
Case: Modular congruence. Fix an arbitrary natural m and three elements x, y,
z < m. We need to code the statement x ≡y z into Zm. First consider the formula
in Ring(0, +, ∗, <): DIV (x, y, z, w) := (⊗(y, z, t) ∧⊕(t, w, x) ∧0 ≤w ∧w < z,
which expresses the Euclidean division of x by y with quotient z and remainder
w (Recall that FO(≤, ⊕, ⊗) = Ring(0, +, ∗, <), hence the relations ⊕and ⊗are
deﬁnable in Ring(0, +, ∗, <)). Then the formula
MOD(x, y, z) := ∃s, w, r(DIV (x, y, s, r) ∧DIV (z, y, w, r)).

Finite Rings and Circuit Complexity
63
that says that the remainders of dividing x by y, and z by y are the same, is
such that for every natural m, for every a, d < c < m,
Zc |= a = d ⇐⇒Zm |= MOD(a, c, d).
Case: Modular addition and multiplication. Fix an arbitrary natural m and three
elements x, y, z, w < m. We need to code the statements x+w ≡y z and xy ≡y z
into Zm. This is accomplished by the formulas: MOD(x + w, y, z) and
MOD(x ∗w, y, z). More precisely, we have that for every a, b, d < c < m,
Zc |= a + b = d ⇐⇒Zm |= MOD(a + b, c, d)
and Zc |= a ∗b = d ⇐⇒Zm |= MOD(a ∗b, c, d).
Case: Linear order. Fix an arbitrary natural number m, and three integers
x, y, z < m. We need to code the statement: Zy |= x < z. This is accomplished
by the following formula:
ORD(x, y, z) := ∃a, b(a < b < y ∧MOD(a, y, x) ∧MOD(b, y, z))
which says that a ≡y x and b ≡y z and a < b < y. More precisely, we have that
for every natural m, for every naturals a, c < b < m,
Zb |= a < c ⇐⇒Zm |= ORD(a, b, c).
This completes the proof of the atomic case for the Coding Theorem. Next
the conjunction, negation and existential expressions follow directly from the
appropriate constructions. Assuming the T RAN process has been deﬁned for
formulas ϕ(x), ψ(x), θ(x, z) we deﬁne:
– T RANψ∧ϕ(x, y) := T RANψ(x, y) ∧T RANϕ(x, y).
– T RAN¬ψ(x, y) := ¬T RANψ(x, y).
– T RAN∃zθ(x, y) := ∃z < yT RANθ(x, z, y).
⊓⊔
Proof of Theorem 15
A ring model Zm satisfy ψ if and only if m is prime and the number of primes
q < m such that Zq |= θ is even. Let p1 < p2 < . . . < pn < . . . be the primes
in Sp(θ), then Zm |= ψ if and only m = p, for some prime p, and there exists
an integer j such that p2j < p ≤p2j+1. Likewise, Zm |= ¬ψ if and only if m is
not a prime, or if it is a prime, say p, then there exists an integer j such that
p2j−1 < p ≤p2j. Observe that
πψ(p2k) = πψ(p2k−1) + |{p ∈P : p2k−1 < p ≤p2k ∧Zp |= ψ}|
and since no prime p, such that p2k−1 < p ≤p2k, can generate a model Zp of
ψ, we have that |{p ∈P : p2k−1 < p ≤p2k ∧Zp |= ψ}| = 0, and in consequence,
πψ(p2k) = πψ(p2k−1). Using that Sp(θ) is thin we have that for all integer k,
πψ(p2k)
π(p2k)
=

πψ(p2k−1)
π(p2k)

for almost all k
−−−−−−−−−−−−→< 1
2
πψ(p2k+1)
π(p2k+1) ≥
π(p2k+1) −πψ(p2k)
π(p2k+1)
=

1 −πψ(p2k)
π(p2k+1)

for almost all k
−−−−−−−−−−−−→> 1
2
We then have that limn→∞
πψ(n)
π(n) does not exists.
⊓⊔

Quantum Probabilistic Dyadic Second-Order
Logic⋆
Alexandru Baltag, Jort M. Bergfeld, Kohei Kishida, Joshua Sack,
Sonja J.L. Smets, and Shengyang Zhong
Institute for Logic, Language and Computation, Universiteit van Amsterdam
Science Park 107, 1098XG Amsterdam, The Netherlands
Abstract. We propose an expressive but decidable logic for reasoning
about quantum systems. The logic is endowed with tensor operators to
capture properties of composite systems, and with probabilistic predica-
tion formulas P ≥r(s), saying that a quantum system in state s will yield
the answer ‘yes’ (i.e. it will collapse to a state satisfying property P) with
a probability at least r whenever a binary measurement of property P is
performed. Besides ﬁrst-order quantiﬁers ranging over quantum states,
we have two second-order quantiﬁers, one ranging over quantum-testable
properties, the other over quantum “actions”. We use this formalism to
express the correctness of some quantum programs. We prove decidabil-
ity, via translation into the ﬁrst-order logic of real numbers.
1
Introduction
This paper introduces a powerful new logic for reasoning about quantum com-
putation. Our Quantum Probabilistic Dyadic Second-Order Logic (QPDSOL)
is expressive enough to capture superpositions, entanglements, measurements,
quantum-logical gates and probabilistic features; it can express the correctness
of a wide range of complex quantum protocols and algorithms; but at the same
time it is logically tractable, in the sense of being decidable.
It is well-known that “classical” First-Order Logic is undecidable, and more-
over that “classical” Second-Order Logic, as well as its monadic and dyadic
fragments1 are not even axiomatizable. By moving to the quantum world, it is
natural to extend the range of ﬁrst-order quantiﬁers to quantum “states” (i.e.
superpositions of classical states), while at the same time it is natural to restrict
the range of monadic second-order quantiﬁers to quantum-testable properties
(closed linear subspaces of the state space), and to similarly restrict the range
of dyadic second-order quantiﬁers to quantum “actions” (linear maps between
⋆The research of J. Bergfeld, K. Kishida and J. Sack has been funded by VIDI grant
639.072.904 of the NWO. The research of S. Smets is funded by the VIDI grant
639.072.904 of the NWO and by the FP7/2007-2013/ERC Grant agreement no.
283963. The research of S. Zhong has been funded by China Scholarship Council.
1 Monadic Second-Order Logic is the fragment allowing quantiﬁcation only over unary
predicates, while the Dyadic fragment allows quantiﬁcation only over unary and
binary predicates.
L. Libkin, U. Kohlenbach, and R. de Queiroz (Eds.): WoLLIC 2013, LNCS 8071, pp. 64–80, 2013.
c
⃝Springer-Verlag Berlin Heidelberg 2013

Quantum Probabilistic Dyadic Second-Order Logic
65
state spaces). Indeed, it is widely accepted in the literature on Quantum Logic
and on Foundations of Quantum Mechanics that quantum-testable properties are
the only experimentally meaningful properties of a quantum system: any other
(non-testable, non-linear) properties have no physical/experimental meaning in
a quantum setting. Similarly, it is widely accepted in quantum computation that
all meaningful quantum programs are obtainable by composing quantum gates
(unitary maps) and quantum tests (measurements), and thus are quantum “ac-
tions” in the above sense.2 So restricting the interpretations of the unary and
binary predicates as above is a natural thing to do in a quantum setting: it
only restricts the second-order quantiﬁers to properties/actions that are physi-
cally meaningful. The resulting logic is indeed the natural “quantum analogue”
of classical (dyadic) second-order logic!
Surprisingly, this quantum analogue turns out to be much more tractable
than its classical counterpart: the above well-justiﬁed and natural restrictions of
range are enough to restore full decidability, even after the addition of “exotic”
features such as probabilistic predication and tensors!
In a sense, this is not as surprising as it may ﬁrst appear. Our semantics for
second-order logic is “non-standard”: not all sets of states (whose existence is
guaranteed by the standard axioms of Set Theory) are accepted as “predicates”.
The second-order quantiﬁers are thus restricted to a limited range of predicates.
Such non-standard variations of second-order logic have been studied before.
Henkin’s weak semantics for second-order logic [11] involves a restriction on the
range of the second-order quantiﬁers (to some model-dependent class of admis-
sible predicates), that restores the axiomatizability of the logic. Some variants of
monadic second-order logic (for very restricted models) are even decidable [14].
But these classical results are conceptually very diﬀerent from ours: none of
these weaker logics can be considered to be a genuine and natural variant of
second-order logic. In particular, Henkin’s semantics (restricting second-order
quantiﬁers to some arbitrary collections of subsets of the state space) is not a
independently-justiﬁable restriction. It does not even provide a unique, canon-
ical way to restrict the quantiﬁers (but a model-dependent one). In contrast,
our restriction of quantiﬁers to quantum-testable properties (and quantum-
performable operations) is natural, canonical (providing a unique collection for
each dimension) and amply justiﬁed on independent grounds by a whole body of
literature in Quantum Logic, Foundations of Quantum Mechanics and Quantum
Computation.
2 The converse is not obvious, and may even fail in practice. But from a theoretical
perspective, one can argue that the converse is true in a sense: for any quantum
action (linear map) f between systems H and H′ there exists an entangled state
sf in H ⊗H′ with the property that, if a local measurement performed on the H-
subsystem of (a system in state) sf yields state x, then after that a local measurement
on the H′-subsystem will yield the result f(x). In this way, any such action f can be
physically computed, in principle: ﬁrst, prepare a large number of entangled states
sf; then perform local measurements on the H-subsystem until one of them yields
the desired input value x; and then perform a measurement on the H′-subsystem,
yielding the output-value f(x).

66
A. Baltag et al.
Indeed, seen from the perspective of the quantum world, our “non-standard”
semantics looks like the “true” semantics of second-order logic: it only eliminates
the predicates that are “physically meaningless”. Moreover, while in a sense being
a restriction of the classical (standard) semantics, in a diﬀerent sense this can
be thought of as an extension of the classical semantics! Indeed, one can argue
that, if we restrict ourselves to classical states (i.e. n-long tuples of bits |0⟩or
|1⟩, for any dimension n) then all the standard predicates of such classical states
are realized as quantum-testable predicates (and hence fall within the range of
our second-order quantiﬁers): for every set A ⊆{|0⟩, |1⟩}n, there exists a unique
quantum-testable predicate (linear subspace3) PA ⊆H⊗n
2
such that a classical n-
state s ∈{|0⟩, |1⟩}n satisﬁes PA iﬀit belongs to the set A. So, insofar as classical
states are concerned, our range restriction for second-order quantiﬁers is not a
restriction at all: their range really includes (quantum counterparts of) every set
of classical states. It is only when we look at non-classical (superposed) states
that we see that the quantiﬁer range is restricted (though in a natural way).
In conclusion, regardless of whether one considers it as a natural restriction of
the classical semantics for (predicates of) quantum states, or as a huge extension
of the classical semantics for (predicates of) classical states, we can still safely
claim that our logic really is the correct quantum (and probabilistic) counterpart
of the classical (dyadic) second-order logic.
As a consequence, we think that our decidability result is a signiﬁcant contri-
bution to the logical understanding of quantum mechanics: it shows in essence
that, whereas the natural formulation of (dyadic) second-order logic in the clas-
sical world is undecidable, the natural formulation of (dyadic) second-order logic
for the quantum world is decidable.
The fundamental reason for this tractability is the one severe constraint put by
quantum mechanics on the “meaningful” properties and actions: linearity.4 Once
again, this does not really restrict the predicates/actions as far as classical states
are concerned (since any two classical states of the same space are orthogonal
to each other, a classical state cannot be written as a linear combination of
other classical states). But linearity does constrain the behavior of “meaningful”
predicates/actions on superposed states. And, in the end, linearity allows the
reduction of all the “meaningful” second-order objects (predicates/actions) to
their underlying linear expressions: matrices of (complex) numbers.
So this natural (and physically-imposed) linearity constraint reduces thus our
quantum version of second-order logic to the ﬁrst-order theory of complex num-
bers. And now, a classical result comes to our help: while ﬁrst-order logic is in
general undecidable (and the ﬁrst-order theories of many useful structures, such
as the ring of natural numbers, are not even axiomatizable), the ﬁrst-order the-
ory of complex numbers is decidable. This was pointed out by Alfred Tarski [17]
as a corollary to the analogue result for the ﬁeld of real numbers (proved in the
same paper by quantiﬁer-elimination).
3 In fact, this is the linear subspace PA generated by A.
4 For unary predicates: having a linear subspace (not an arbitrary subset) as their
extension; for actions: being induced by a linear map.

Quantum Probabilistic Dyadic Second-Order Logic
67
Our decidability proof makes essential use of Tarski’s decidability result, as
well as of the ﬁnite dimensionality; it translates eﬀectively the probabilistic
dyadic second-order logic of ﬁnite-dimensional quantum systems into the decid-
able ﬁrst-order theory of reals. This proof method is inspired by the one given
by Dunn et al. in [10], where the traditional (propositional) quantum logic of
any ﬁnite-dimensional Hilbert space was proved to be decidable. However, the
result in [10] required that we ﬁrst ﬁx a particular Hilbert space (model of a
quantum system) of a ﬁnite dimension, so as to translate the logic of the space
into the ﬁnitary language of reals, thus limiting the scope of application by ﬁxing
a ﬁnite dimension (and hence the number of quantum bits or qubits) throughout
the discourse. In contrast, our logic overcomes this limitation by using types and
tensors in the language, thus accommodating an unbounded number of qubits,
while preserving the logical tractability.
Our results in this paper can be seen as part of a wider on-going eﬀort to-
wards bridging the gap between traditional quantum logic and the theory of
quantum computation. On the one hand, traditional quantum logic (as origi-
nated in [7]) has focused on axiomatics and logical properties of the lattice of
closed linear subspaces of an inﬁnite-dimensional Hilbert space, with the goal
being “to discover the logical structure one may hope to ﬁnd in physical theories
which, like QM, do not conform to classical logic” [7]. Quantum computation,
on the other hand, concerns encoding and describing computations on the basis
of quantum systems, and involves quantum ingredients such as superposition
and entanglement, in order to perform certain tasks much faster than classical
computers. The underlying theoretical framework for quantum computation is
given by ﬁnite-dimensional Hilbert spaces. Among the few treatments of such
ﬁnite-dimensional quantum logics and their decidability are the work of [8,10].
Another contrast between quantum logic and quantum computation lies in the
treatment of “quantum entanglement”. In traditional quantum logic, entangle-
ment has been viewed as a problem-child, posing diﬃculties to the lattice-theoretic
setting [2,15] (though naturally treatable in a category-theoretical setting [1,16]).
In quantum computing, however, entanglement is viewed as a computational re-
source, that allows us to go beyond the world of classical computing. Among the
papers that address this part of the gap between quantum logic and quantum
computation are [3,8], and [9, Chapter 17]. Our work strengthens the connection
further. The logic we propose in the following sections—dyadic second-order quan-
tum logic—is ﬁt to deal with multi-partite systems that exhibit quantum entangle-
ment. Equipped with an explicitly typed language, with types for states,
predicates, and actions, with tensor operators connecting them, as well as with
probabilistic predication, our logic allows us to capture all the essential computa-
tional properties of composite quantum systems, and in particular it can encode
the correctness of a wide range of quantum algorithms.
The design of dyadic second-order quantum logic in this paper builds further
on the earlier work of Baltag and Smets on propositional dynamic quantum
logics [5,6]. It is well known that standard Propositional Dynamic Logic (PDL),
as well as its fragment called the Hoare Logic, plays an important role in classical

68
A. Baltag et al.
computing and programming. In particular, PDL and Hoare Logic are among
the main logical formalisms used for classical program veriﬁcation. The quantum
version of PDL extends the area of applicability to the veriﬁcation of quantum
programs and quantum protocols. In [6], a quantum dynamic logic was designed
that was expressive enough to prove the correctness of basic non-probabilistic
quantum protocols such as teleportation and quantum secret sharing. The work
of [4] used the tools of [10] to prove the decidability of such a propositional
dynamic quantum logical system. While these results are important, note that
the logic in [4] was unable yet to capture the correctness of any probabilistic
quantum protocols. In this paper, we overcome this limitation and equip our logic
with a probabilistic predication operator, indicating that a state of a quantum
system will collapse to a state having property P with probability at least r
whenever a measurement of property P is performed. This operator allows us to
express the correctness of those quantum algorithms (such as quantum search)
that make essential use of quantum probabilities.
A remark is in order regarding the fact that each given program in our syntax,
and so each given sentence, uses only a given number of qubits (and thus it refers
to a Hilbert space with a given ﬁnite number of dimensions). We would like to
stress that our result is much more signiﬁcant than, say, the decidability of
checking the correctness of a classical circuit of a given size applied to a problem
of given input size. This is because we do not ﬁx the size of the input, but only
the dimension. This point is important, since for a given ﬁxed dimension (greater
than 1) there are inﬁnitely (in fact uncountably) many non-equivalent quantum
states of that dimension (while typically there are only ﬁnitely many inputs
of a given size). Hence, the algorithm for deciding satisﬁability (on states of
a space of given dimension) cannot simply proceed by exhaustive search over
a ﬁnite domain (as in the case of models of bounded size). The correctness
statements presented in this paper really capture the correctness of a program
for uncountably many non-equivalent inputs!5
2
Preliminaries
According to quantum theory (see e.g. [12]), any quantum system can be de-
scribed by a Hilbert space H of appropriate dimension. Similar to the tradition
of [13], we identify (pure) states of the system with the “rays” in H (i.e. the one-
dimensional linear subspaces of H) and the “impossible state” (zero-dimensional
subspace, which we include as it allows us to discuss only total functions with-
out loss of generality). Given a vector |ψ⟩∈H, we will write 
|ψ⟩for the state
generated by |ψ⟩. Given a state space H of some quantum system, we write ΣH
5 Moreover, these correctness statements, even when translated back into the arith-
metic of real numbers, do not boil down to simple equations involving addition and
multiplication of speciﬁc real numbers and/or matrices. Instead, they reduce to com-
plex ﬁrst-order statements in the theory of real numbers, that involve in an essential
way quantiﬁcation over uncountably many objects. It just happens that (due to
Tarski’s theorem) this theory is still decidable!

Quantum Probabilistic Dyadic Second-Order Logic
69
for the set of all states, i.e. the set of all one-dimensional linear subspaces of H
and 
0H (where 0H is the zero vector).
Any change of the state of a quantum system can be described by a linear
map on H. There are two important kinds of linear maps: unitary operators
and projectors. A unitary operator U is such that both U †U and UU † are the
identity operator, where (·)† is the adjoint operation on linear maps. In quantum
computation, unitary operators are the counterpart of logical gates in classical
computation. An operator A is a projector, if it is bounded, idempotent, i.e.
AA = A, and self-adjoint, i.e A† = A. Projectors are essential in describing
quantum measurements, which are the only way we extract information from
a quantum system. In this paper, our level of abstraction allows us to consider
not only linear maps on a Hilbert space but also those between diﬀerent Hilbert
spaces. Every linear map A : H →H′ from a quantum system H to a possibly
diﬀerent system H′ naturally induces a unique function (also denoted by A) from
the set of states ΣH to the set of set of states ΣH′, given by A( 
|ψ⟩) := 
A(|ψ⟩)
for every |ψ⟩∈H. An action is any such function A : H →H′ induced on state
spaces by some linear map A : ΣH →ΣH′. We can also deﬁne composition,
tensor product and adjoint of actions in a natural way via composition, tensor
product and adjoint of linear maps which induce the actions6. We will use the
same symbols for operations on actions as those for linear maps.
In this paper, a property of a quantum system with state space H is just a
subset of ΣH. However, according to quantum theory, not any subset of ΣH
represents a property of the system that can be tested. A property is testable
iﬀit corresponds to a closed linear subspace W of H in such a way that the
states in the property are exactly those generated by vectors in W. Since this
correspondence is one-to-one and natural, we will always use the same sym-
bol to denote a testable property and its corresponding closed linear subspace.
Moreover, according to linear algebra, closed linear subspaces lie in one-to-one
correspondence with projectors in the following sense:
1. For every projector A on H, ran(A) (the range of A) is a closed linear
subspace of H, and for every vector |ψ⟩∈H, |ψ⟩∈ran(A) iﬀA(|ψ⟩) = |ψ⟩.
2. For every closed linear subspace W of H, there is a unique projector on
H, called the projector onto W and denoted by ?H(W), such that for every
vector |ψ⟩∈H, |ψ⟩∈W iﬀ?H(W)(|ψ⟩) = |ψ⟩.
The state space of a qubit, the unit of quantum information, is of dimension
2. Given a ﬁxed orthonormal basis {|0⟩, |1⟩} of the state space of a qubit, the
two states generated by |0⟩and |1⟩, respectively, correspond to the values 0 and
1 of a classical bit. Given several qubits indexed by elements in a ﬁnite set I,
they form a compound quantum system, and the state space for I is the tensor
product 
i∈I Hi of the state space Hi for each qubit i ∈I. A standard way of
obtaining an orthonormal basis of this state space is to take tensor products of
vectors in the ﬁxed orthonormal bases of each Hi. It is easy to see that there
6 Note that diﬀerent linear maps could induce the same action, but the operations on
actions are still well-deﬁned according to linear algebra.

70
A. Baltag et al.
are 2|I| vectors in this basis, and we will index them by elements in I2, the set
of all functions from I to 2 = {0, 1}, in such a way that |f⟩= ⊗i∈I |f(i)⟩i, for
each f ∈I2. We call a state of a compound system classical if it is generated by
a vector in this basis. Moreover, we write |0⟩I for ⊗i∈I |0⟩i.
It is well known that an n-dimensional Hilbert space is isomorphic to Cn. In
this case, every linear subspace is closed and every operator is bounded. More-
over, every state can be represented by n complex numbers if we pick a vector in
the state as its representative. Every property, identiﬁed with its corresponding
projector, can be represented by an n × n matrix of complex numbers. Every
linear map from an n-dimensional Hilbert space to an m-dimensional one can
be represented by an m × n matrix of complex numbers.
In this paper, for generality, we assume that we are supplied with countably
inﬁnitely many qubits indexed by elements in ω, the set of all natural numbers,
which we take to be non-negative integers. We further assume that an orthonor-
mal basis has been ﬁxed for each qubit, and we obtain an orthonormal basis for
compound systems consisting of a ﬁnite number of qubits by applying the tensor
product in the way just described. Finally, we use Pﬁn(ω) to denote the set of
all ﬁnite, non-empty subsets of ω. For each τ ∈Pﬁn(ω), by τ-system we mean
the quantum system consisting of qubits indexed by elements of τ. Whenever
Hτ, the state space of the τ-system, appears as a superscript or subscript in a
symbol, we simply write τ; for example, we write simply Στ for ΣHτ .
Moreover, for each τ, ρ ∈Pﬁn(ω) s.t. τ ⊆ρ, we know from linear algebra that
Hτ can be canonically embedded into Hρ, by “padding” all the vectors with |0⟩’s
for all the extra dimensions. Hence in this paper we write Θτ→ρ : Hτ →Hρ for
this canonical embedding
Θτ→ρ = 
f∈τ2(|f⟩⊗|0⟩ρ\τ) ⟨f|.
We also write Θρ→τ : Hρ →Hτ for the canonical projection that reverses the
above embedding:
Θρ→τ = 
f∈τ 2 |f⟩(⟨f| ⊗⟨0|ρ\τ).
Using the canonical embeddings and projections, one can generalize projectors
to arbitrary dimensions: For every space Hτ and every closed linear subspace
Wρ of some other space Hρ, we can deﬁne the generalized projector of Hτ onto
Wρ, denoted by ?τ(Wρ), by putting:
?τ(Wρ) = Θρ∪τ→ρ ◦

?ρ(Wρ) ⊗|0⟩τ\ρ ⟨0|τ\ρ

◦Θτ→ρ∪τ
This is a linear map that takes a vector in Hτ and “projects” it onto Wρ.
Physically, this action corresponds to a successful measurement of a ρ-property
performed on a τ-system.
We introduce some notation. Given a binary relation R and a set A ⊆
dom(R) = {x | ∃y. (x, y) ∈R}, let R[A]
def
= {b | ∃a ∈A. (a, b) ∈R} be the
direct image of A under R. Given a set B ⊆ran(R) = {y | ∃x. (x, y) ∈R}, we
let [R]B
def
= {a | ∀b. (a, b) ∈R ⇒b ∈B} be the so-called weakest precondition of

Quantum Probabilistic Dyadic Second-Order Logic
71
B under R. Note that when R is a function instead of a relation in general, [R]B
is sometimes called the inverse image of B under R. In general, given two sets
A and B, we write AB for the set of functions from A to B. Given a positive
number N, let N = {0, 1, . . ., N −1}. Given a linear map T , let T be its matrix
representation under the ﬁxed bases.
3
Quantum Probabilistic Dyadic Second-Order Logic
Syntax of QPDSOL. Our language consists of terms (for quantum states),
predicates symbols (for quantum testable properties), and function symbols (for
actions). The language is typed: each of these symbols comes with a type, which
is an element of Pﬁn(ω), indicating the underlying set of qubits involved in that
state, property or action. E.g. terms of type τ refer to the possible (pure) states
of the τ-system; predicate symbols of type τ are unary predicates referring to
quantum-testable properties of the τ-system; function symbols of type τ →ρ
are dyadic predicates (restricted to functions) referring to actions. As the types
range over all of Pﬁn(ω), the entire domain of discourse involves inﬁnitely many
qubits; but each formula involves only ﬁnitely many types, each involving only
ﬁnitely many qubits, so that a formula can only talk about ﬁnitely many qubits.
For each pair of elements τ, ρ ∈Pﬁn(ω), we include in the language a countable
set of state variables xτ of type τ, a countable set of state constants cτ of type
τ, a countable set of predicate variables pτ of type τ, a countable set of predicate
constants Tτ of type τ, a countable set of action variables aτ→ρ of type τ →ρ,
and a countable set of action constants Cτ→ρ of type τ →ρ. It is assumed that
these sets are pairwise disjoint, and that each of them is indexed by elements in
ω without repetition.
Deﬁnition 3.1. For any τ, ρ ∈Pﬁn(ω), we deﬁne by (triple) mutual recursion
the following sets of syntactic expressions: the set Termτ of terms of type τ
tτ ::= xτ | cτ | tτ1 ⊗tτ2 | αρ→τ(tρ)
(where τ1, τ2 ∈Pﬁn(ω) are such that τ1 ∪τ2 = τ, τ1 ∩τ2 = ∅), the set Pτ of
(unary) predicate symbols of type τ
Pτ ::= pτ | Tτ | tτ | ∼Pτ | Pτ ∩Pτ | Pτ1 ⊗Pτ2 | αρ→τ[Pρ] | [ατ→ρ]Pρ
(where τ1, τ2 ∈Pﬁn(ω) are such that τ1 ∪τ2 = τ, τ1 ∩τ2 = ∅), and the set Aτ→ρ
of function symbols of type τ →ρ
ατ→ρ ::= aτ→ρ | Cτ→ρ|?τPρ | α†
ρ→τ | ατ→μ; αμ→ρ | ατ1→ρ1 ⊗ατ2→ρ2
(where μ, τ1, ρ1, τ2, ρ2 ∈Pﬁn(ω) are such that τ1 ∪τ2 = τ, ρ1 ∪ρ2 = ρ and
τ1 ∩τ2 = ρ1 ∩ρ2 = ∅).
We write Term for the set 	
τ∈Pfin(ω) Termτ of all terms, P for the set
	
τ∈Pfin(ω) Pτ of all predicate symbols, and A for the set 	
τ,ρ∈Pfin(ω) Aτ→ρ of
all function symbols. When τ = ρ, we simply write Pρ? for the function symbol
?τPρ.

72
A. Baltag et al.
Deﬁnition 3.2. We now deﬁne by induction the set L of formulas of our logic:
ϕ ::= P ≥r
τ
(tτ) | ¬ϕ | ϕ ∧ϕ | ∀xτϕ | ∀pτϕ | ∀aρ→τϕ
where τ ∈Pﬁn(ω), tτ ∈T ermτ, Pτ ∈Pτ and r ∈[0, 1] is a deﬁnable real number
(described below before Deﬁnition 3.3).
The intended meaning of our basic formula P ≥r
τ
(tτ) is that a quantum system
in state tτ will yield the answer ‘yes’ (i.e. it will collapse to a state satisfying
property Pτ) with a probability at least r whenever a binary measurement of
property Pτ is performed. The rest of our logical formulas are built from such
basic formulas using standard Boolean connectives, as well as three types of
quantiﬁers: ﬁrst-order quantiﬁers ∀xτ ranging over quantum states, second-order
quantiﬁers ∀pτ over quantum (testable) predicates, and second-order quantiﬁers
∀aτ→ρ ranging over quantum actions.
The notions of free variables, bound variables, etc. are deﬁned in the standard
way. As usual, a formula ϕ ∈L is called closed if it has no free (state, predicate
or action) variables. A pure formula is a closed formula containing no (state,
predicate or action) constants.
Semantics of QPDSOL. Following standard practice, we introduce the notion
of frame (also known as structure in the semantics of ﬁrst-order logic), by which
we mean a structure that ﬁxes the (state, predicate and action) constants. Then,
given a frame, we deﬁne a model on it (also known as an interpretation in
the semantics of ﬁrst-order logic), which can determine the denotation of each
remaining term, predicate symbol and function symbol. Finally, we deﬁne the
satisfaction relation.
Recall that we say that a real number r is deﬁnable if there is a formula
φ(x) in the ﬁrst-order language of (R, +, ·, 0, 1) such that (R, +, ·, 0, 1) |= φ[r] ∧
∀x(φ(x) →x = r). We also say that a complex number z is simple if z = a + bi
for deﬁnable real numbers a and b. Extending the terminology, we say that a
state of the τ-system, a testable property of the τ-system and an action from
the τ-system to ρ-system are deﬁnable if they can be represented under the ﬁxed
basis respectively by a 2|τ|-tuple (with the state identiﬁed with the representative
of it), a 2|τ| × 2|τ|-matrix (with the closed linear subspace identiﬁed with the
corresponding projector), and a 2|ρ|×2|τ|-matrix (with the action identiﬁed with
a linear map that induces it) of simple complex numbers.
Deﬁnition 3.3. An H-valuation is a function V deﬁned on a subset of P ∪A∪
Term and satisfying the following conditions:
– V (tτ) ∈Στ if tτ ∈Termτ;
– V (Pτ) is a testable property of τ-system, if Pτ ∈Pτ;
– V (ατ→ρ) is an action from Στ to Σρ if ατ→ρ ∈Aτ→ρ.
Deﬁnition 3.4. A frame F is an H-valuation whose domain is the set of all
(state, predicate and action) constants and whose values are all deﬁnable.
Actually, for the decidability result to hold, a frame must be a computable
function in some sense. We neglect this technicality here.

Quantum Probabilistic Dyadic Second-Order Logic
73
Deﬁnition 3.5. A model M on a frame F is an H-valuation whose domain is
P ∪A ∪Term, that extends F and that satisﬁes the following, for any terms
tτ, tτ1, tτ2, function symbols ατ→ρ, βρ→μ, ατ1→ρ1, ατ2→ρ2, and predicate symbols
Pτ, Qτ, Pρ, Pτ1, Qτ2 such that τ1 ∩τ2 = ∅and ρ1 ∩ρ2 = ∅:
M(tτ1 ⊗tτ2)
= M(tτ1) ⊗M(tτ2)
M(ατ→ρ(tτ))
= M(ατ→ρ)(M(tτ))
M(ατ→ρ; βρ→μ)
= M(βρ→μ) ◦M(ατ→ρ)
M(α†
τ→ρ)
= (M(ατ→ρ))†
M(ατ1→ρ1 ⊗ατ2→ρ2) = M(ατ1→ρ1) ⊗M(ατ2→ρ2)
M(?τPρ)
= ?τ(M(Pρ))
M(∼Pτ)
= ∼M(Pτ)
M(Pτ ∩Qτ)
= M(Pτ) ∩M(Qτ)
M(Pτ1 ⊗Qτ2)
= M(Pτ1) ⊗M(Qτ2)
M(ατ→ρ[Pτ])
= M(ατ→ρ)[M(Pτ)]
M([ατ→ρ]Pρ)
= [M(ατ→ρ)]M(Pρ)
To interpret quantiﬁers, for each (state, predicate, or action) variable v we in-
troduce an equivalence relation ∼v among models on the same frame such that
M ∼v M′ iﬀM(v′) = M′(v′) for all variables v′ except possibly v.
Deﬁnition 3.6. The satisfaction relation between a model M and a formula is
deﬁned recursively, where v is any (state, predicate, or action) variable,
M |= P ≥r
τ
(tτ) ⇐⇒| ⟨ψ| ?τ(M(Pτ)) |ψ⟩|2 ≥r∥|ψ⟩∥2∥?τ(M(Pτ)) |ψ⟩∥2,
for any vector |ψ⟩∈M(tτ)
M |= ¬ϕ
⇐⇒M ̸|= ϕ,
M |= ϕ ∧ψ
⇐⇒M |= ϕ and M |= ψ,
M |= ∀vϕ
⇐⇒M′ |= ϕ, for all M′ ∼v M.
Obviously, other Boolean connectives such as ∨, →and ↔can be deﬁned in the
usual manner. Existential quantiﬁers over states, predicates and actions can also
be deﬁned in the usual manner. Moreover, this logic is at least as expressive as
the ﬁrst-order language of the lattice L(C2n), which is discussed in [10].
Now we introduce some useful abbreviations:
P ≤r
τ
(tτ)
def
= (∼P)≥(1−r)
τ
(tτ)
P =r
τ
(tτ)
def
= P ≥r
τ
(tτ) ∧P ≤r
τ
(tτ)
P <r
τ
(tτ)
def
= ¬P ≥r
τ
(tτ)
P >r
τ
(tτ)
def
= ¬P ≤r
τ
(tτ)
sτ ⊥tτ
def
= s≤0
τ (tτ)
sτ .= tτ
def
=

s=1
τ (tτ) ∧¬(sτ ⊥tτ)

∨

(sτ ⊥sτ) ∧(tτ ⊥tτ)

Essentially, the meaning of P ≤r
τ
(tτ) (or respectively P =r
τ
(tτ), P <r
τ
(tτ), P >r
τ
(tτ))
is that a quantum system in state tτ will yield the answer ‘yes’ (i.e. it will
collapse to a state satisfying property Pτ) with a probability ≤r (or respectively
= r, < r, > r) whenever a binary measurement of property Pτ is performed.
Moreover, M |= sτ ⊥tτ iﬀsτ and tτ denote two orthogonal states. (Note that

74
A. Baltag et al.
the impossible state 
0τ is the only state that is orthogonal to itself.) Finally,
we have M |= sτ .= tτ iﬀsτ and tτ refer to the same state: the ﬁrst disjunct
ensures that sτ and tτ are equal but neither denotes 
0τ (note that s=1
τ (tτ) and
sτ ⊥tτ are together satisﬁable where either sτ or tτ is interpreted by 
0τ), while
the second disjunct ensures that both sτ and tτ denote 
0τ.
We now deﬁne the notion of validity.
Deﬁnition 3.7. A formula ϕ of L is said to be valid in a frame F, written
F |= ϕ, if M |= ϕ for every model M on F. A formula ϕ of L is said to be valid,
written |= ϕ, if F |= ϕ for every frame F.
As in classical predicate logic, we have
Lemma 3.8. For every closed formula ϕ in L and every frame F, F |= ϕ iﬀ
there is a model M on F such that M |= ϕ. For every pure formula ϕ in L, |= ϕ
iﬀthere is a frame F such that F |= ϕ.
4
Examples
Here we show how our language can be used to express many properties of quan-
tum algorithms. We start with introducing some notation that will be commonly
used in the following examples.
First, for each qubit i, we introduce state constants 0i and 1i to denote the
state generated by |0⟩i and |1⟩i, respectively.
We furthermore have the following action constants for a single qubit i, and
for some, we provide the matrix representation (in the ﬁxed bases) of linear maps
which are usually used to induce the actions interpreting these constants:
– Ii interpreted as the identity action,
– Hi the action induced by the Hadamard gate with matrix
1
√
2
1
1
1 −1

– Xi the action induced by the Pauli X gate
0 1
1 0

– Zi the action induced by the Pauli Z gate

1
0
0 −1

We furthermore have an action symbol CNOT ij (i ̸= j) for the controlled-NOT
action with control qubit i and target qubit j usually induced by a linear map
with the matrix
⎡
⎢⎢⎣
1 0 0 0
0 1 0 0
0 0 0 1
0 0 1 0
⎤
⎥⎥⎦
For any distinct i and j, we also deﬁne an abbreviation for an action that inter-
changes the states of qubits i and j:
FP ij
def
= CNOT ij; CNOT ji; CNOT ij

Quantum Probabilistic Dyadic Second-Order Logic
75
We introduce an abbreviation CS τ(tτ) for the formula saying that a state tτ is
a classical state:
CS τ(tτ)
def
= ∃{xi |i ∈τ}

tτ .= ⊗i∈τxi ∧

i∈τ
(xi .= 0i ∨xi .= 1i)

,
where ∃{xi |i ∈τ} means a sequence of existential quantiﬁers on state variables
of type i ∈τ. Similarly, we introduce an abbreviation Unit(ατ→τ) for the formula
saying that the variable ατ→τ denotes (an action induced by) a unitary operator
on a τ-system:
Unit(ατ→τ)
def
= ∀xτ(ατ→τ; α†
τ→τ(xτ) .= xτ).
Next, we write H⊗τ for ⊗i∈τHi and I⊗τ for ⊗i∈τIi. Finally, we recursively
introduce an abbreviation αn
τ→τ for the action obtained by iterating the action
ατ→τ for n times:
α0
τ→τ = I⊗τ (the identity map on τ-system)
αn+1
τ→τ = αn
τ→τ; ατ→τ (for n ≥1)
4.1
Quantum Teleportation
In quantum teleportation, Alice and Bob, who are separated by a long distance,
share a pair of qubits in Bell state
1
√
2(|0⟩2 |0⟩3 + |1⟩2 |1⟩3) (qubit 2 being with
Alice, and 3 being with Bob). Alice would like to let Bob have a qubit whose
state is the same as the state q of her qubit 1 (which we represent as a state
variable of type {1}). She ﬁrst interacts the qubit with her end of the Bell state.
Deﬁne
PRE(q)
def
= (CNOT 12; (H1 ⊗I2)) ⊗I3

q ⊗

CNOT 23; (H2 ⊗I3)(02 ⊗03)

.
She then measures her qubits 1 and 2, and depending on the result sends Bob
instructions as to any further operation that must be performed on his qubit 3.
The standard frame for Teleportation is the frame that interprets as intended
all the constants occurring in the Teleportation protocol: the constants 0i and
1i for each i ∈{1, 2, 3} as well as I2, I3, H1, H2 CNOT 12, CNOT 23 and FP13.
The correctness of the Teleportation protocol is equivalent to the validity in
its standard frame of the formula
∀q

(q ⊗02 ⊗03) .= (01? ⊗02? ⊗I3); (FP 13 ⊗I2)(PRE(q))
∧(q ⊗12 ⊗03) .= (01? ⊗12? ⊗I3); (I1 ⊗I2 ⊗X3); (FP13 ⊗I2)(PRE(q))
∧(q ⊗02 ⊗13) .= (11? ⊗02? ⊗I3); (I1 ⊗I2 ⊗Z3); (FP13 ⊗I2)(PRE(q))
∧(q ⊗12 ⊗13) .= (11? ⊗12? ⊗I3); (I1 ⊗I2 ⊗(X3; Z3)); (FP 13 ⊗I2)(PRE(q))


76
A. Baltag et al.
4.2
Quantum Search Algorithm
In the search problem, we are given a unitary operator O, which is usually called
an oracle, acting on N + 1 qubits (we assume them to be indexed by elements in
N + 1), such that there is a classical state |f0⟩with the property that, for each
classical state |f⟩and b ∈2,
O(|f⟩⊗|b⟩N) =
|f⟩⊗|1 −b⟩N , if f = f0,
|f⟩⊗|b⟩N ,
if f ∈N2 \ {f0}
(1)
The aim of the algorithm is to ﬁnd out the classical state |f0⟩.
To formalize the correctness of this algorithm, we use an action variable O of
type N + 1 →N + 1 to denote the oracle. Moreover, we assume that we have an
action constant PSN of type N →N for the action induced by the conditional
phase shift gate on the ﬁrst N qubits, whose matrix under the ﬁxed basis is the
following:

Z
O2×(N−2)
O(N−2)×2
−I(N−2)×(N−2)

Here O2×(N−2) is the 2 by N −2 matrix of only 0 entries, and similarly for
O(N−2)×2, and I(N−2)×(N−2) is the N −2 by N −2 identity matrix.
As before, the standard frame for the (N +1)-qubit quantum search algorithm
is the one that interprets as intended all the above constants, as well as all the
constants 0i and 1i. For convenience, we make the following abbreviation
OracleN+1(O)
def
= Unit(O) ∧∃xN
 
CS N(xN) ∧∀yN

CS N(yN)
→(xN .= yN →O(yN⊗0N+1) .= yN⊗1N+1 ∧O(yN ⊗1N+1) .= yN⊗0N+1)
∧(xN ⊥yN →O(yN⊗0N+1) .= yN⊗0N+1 ∧O(yN⊗1N+1) .= yN⊗1N+1)
!
for the formula saying that O is an action induced by an oracle acting on the
(N + 1)-system satisfying Eq.(1).
The correctness of (N + 1)-qubit Quantum Search Algorithm (with N > 2) is
equivalent to the validity in its standard frame of the following formula:
∀O∀xN
"
OracleN+1(O) ∧CS N(xN)
∧O(xN⊗0N) .= xN⊗1N ∧O(xN⊗1N) .= xN⊗0N →(xN⊗HN(1N))>0.5

H⊗(N+1); (O; ((H⊗N; PSN; H⊗N)⊗IN))K(0N⊗1N)
#
,
where K is the largest natural number less than π
4
√
2N.
4.3
Deutsch-Josza Algorithm
In the Deutsch-Josza problem, we are given a unitary operator O (usually called
an oracle) acting on N + 1 qubits (we assume them to be indexed by elements
in N + 1), which is known to satisfy one of the following properties:

Quantum Probabilistic Dyadic Second-Order Logic
77
(i) The oracle is constant (having the same value for all inputs): there is i ∈
{0, 1} s.t. O(|f⟩⊗|b⟩N) = |f⟩⊗|b ⊕i⟩N for all b ∈2 and classical state |f⟩,
with f ∈N2;
(ii) The oracle is balanced (equal to 1 for exactly half of all the possible inputs,
and 0 for the other half): there is X ⊆N2 s.t. |X| = 2N−1 and O(|f⟩⊗|b⟩N)
is |f⟩⊗|1 −b⟩N if f ∈X, and is |f⟩⊗|b⟩N, otherwise, for all b ∈2.
The goal of the algorithm is to determine which of the two properties holds for
O.
To formalize the correctness of this algorithm, we use an action variable O of
type N + 1 →N + 1 to denote the oracle. For convenience, we introduce some
abbreviations: ﬁrst, let us denote by ConOra(O) the formula
Unit(O) ∧
 
∀xN

CS N(xN) →O(xN⊗0N+1) .= xN⊗0N+1 ∧O(xN⊗1N+1) .= xN⊗1N+1

∨∀xN

CS N(xN) →O(xN⊗0N+1) .= xN⊗1N+1 ∧O(xN⊗1N+1) .= xN⊗0N+1
!
saying that O is an action induced by a constant oracle; second, we denote by
BalOra(O) the formula (where k = 2N−1)
Unit(O) ∧∃x1
N...∃xk
N
 
k
i=1
CS N(xi
N)

∧
 
1≤i<j≤k
xi
N ⊥xj
N

∧∀yN

CS N(yN) →
(
k
i=1
yN .= xi
N →O(yN⊗0N+1) .= yN⊗1N+1 ∧O(yN⊗1N+1) .= yN⊗0N+1)
∧(
k
i=1
yN ⊥xi
N →O(yN⊗0N+1) .= yN⊗0N+1 ∧O(yN⊗1N+1) .= yN⊗1N+1))
!
saying that O is an action induced by a balanced oracle.
Finally, the correctness of the (N + 1)-qubit Deutsch-Jozsa algorithm (for any
natural number N) is equivalent to the assertion that the following formula is
valid in its standard frame:
∀O
"
ConOra(O) ∨BalOra(O) →
 
ConOra(O) ↔H⊗(N+1); O; H⊗(N+1)(0N ⊗1N) .= 0N ⊗1N

∧

BalOra(O) ↔H⊗(N+1); O; H⊗(N+1)(0N ⊗1N) ⊥0N ⊗1N
 !#
5
Decidability
The set of validities of QPDSOL on any given frame is decidable. Using the
same proof strategy, the validity problem for pure formulas over (the class of)
all frames is also decidable. In this section, we sketch the proofs of these results.

78
A. Baltag et al.
The basic technique for proving these decidability results is a generalization
and extension of the method used in [10]: We express validity of formulas of L
without free variables in a given frame F via truth of ﬁrst-order sentences of
(R, +, ·, 0, 1); then the decidability of our logic follows from Tarski’s theorem in
[17] which states that the ﬁrst-order theory of (R, +, ·, 0, 1) is decidable. This
idea is unfolded into several technical steps.
In the ﬁrst step, we need to deal with intersection of testable properties. For
a function symbol of the form (Pτ ∩Qτ)?, it is well known that calculating
the matrix of the corresponding projector typically involves a process of taking
limits and hence can not be expressed in the ﬁrst-order theory of (R, +, ·, 0, 1).
The key to solving this is the observation that complex predicate symbols, i.e.
those built with ∩, ⊗, ∼and other operations, can be recursively eliminated from
our language with the help of quantiﬁers (over states). Let L∗be the result of
this translation. Its formulas consist of those built as follows (where constraints
on the types are those given in Deﬁnition 3.1 and 3.2, but with the additional
requirement that for each singleton τ = {i}, there exists a constant 0τ that
denotes 
|0⟩i, so as to facilitate the translation of generalized projectors):
tτ ::= xτ | cτ | xτ1 ⊗xτ2 | αρ→τ(xρ)
Pτ ::= pτ | Tτ
ατ→ρ ::= aτ→ρ | Cτ→ρ | a†
ρ→τ | aτ1→ρ1 ⊗a′
τ2→ρ2 | Pτ?
ϕ ::=x<r
τ (tτ) | x=r
τ (tτ) | ¬ϕ | ϕ ∧ϕ | ∀xτϕ | ∀pτϕ | ∀aρ→τϕ
With the possible exception of the constants 0τ, we have that L∗⊆L, and the
semantics of L∗is the same as for L. One can deﬁne a function ∇: L →L∗by
recursion (and hence it is computable) s.t. M |= ϕ ⇔M |= ∇(ϕ) for every model
M. To illustrate why this is the case and how it helps to solve the problem, we
exhibit one case in its deﬁnition:
∇(x=r
τ ((Pτ ∩Qτ)?(tτ))) =∃yτ∃zτ

∇(tτ .= yτ ⊕zτ) ∧y=0
τ (zτ) ∧x=r
τ (yτ)
∧∀uτ

∇(P =1
τ
(uτ)) ∧∇(Q=1
τ (uτ)) →z=0
τ (uτ)
 
where xτ is a state variable, tτ is a term and tτ
.= yτ ⊕zτ is deﬁned to be
∀vτ(v=0
τ (yτ) ∧v=0
τ (zτ) →v=0
τ (tτ)), which means that tτ “lies on the plane gen-
erated by” yτ and zτ.
In the second step, we deﬁne for each frame F, a function TRF : L∗→LC,
where LC is the ﬁrst-order language of (C, +, ·, ·, ≺, C), where · is the conjugate
operator, ≺is a binary relation between complex numbers such that a+bi ≺c+di
iﬀa < c, and the last component C is the set of numbers named by a constant.
Towards this aim, we ﬁrst formalize in LC the matrix representation of the
interpretation in F of terms, predicate symbols and function symbols. This is
possible because every term, predicate symbol and function symbol involves only
ﬁnitely many qubits indicated by its type. In fact, one can deﬁne by recursion
a computable function F♮from the set of terms, predicate symbols and function
symbols that can occur in formulas in L∗to the set of ﬁnite sets of terms in

Quantum Probabilistic Dyadic Second-Order Logic
79
LC. For the base case, we deﬁne F♯(xτ), F♯(pτ) and F♯(aτ→ρ) to be the sets of
variables indexed by τ2, τ2 ×τ 2 and ρ2 ×τ 2 in such a way that diﬀerent state,
predicate or action variables are mapped to disjoint sets of variables. Moreover,
F♯(cτ), F♯(Tτ) and F♯(Cτ→ρ) are indexed in a similar way but they are sets of
constants. Care must be taken to ensure that the constants are deﬁned according
to the interpretation in F. For complex symbols built with operations, we can
mimic the manipulation of vectors and matrices. For example, assume that we
have deﬁned F♮(xτ) to be the set of variables {x[f] | f ∈τ 2} and F♮(yρ) to
be {y[g] | g ∈ρ 2} respectively, then we can mimic the Kronecker product of
matrices and deﬁne F♮(xτ ⊗yρ) to be the set of terms {x ⊗y[h] | h ∈τ∪ρ 2} s.t.
x ⊗y[h] = x[h↾τ] ·C y[h↾ρ], where ·C is the symbol for multiplication in LC. Using
the function F♮, we proceed to deﬁne TRF in such a way that given a model M on
the frame F, M |= ϕ iﬀ(C, +, ·, ·, ≺, C) |=M TRF(ϕ), for every ϕ ∈L∗. Here the
subscript in “|=M” is an interpretation (added to the structure (C, +, ·, ·, ≺, C))
of the free variables in TRF(ϕ) according to the model M. In deﬁning TRF as
such, care is taken in order to verify that quantiﬁcation over (ﬁnitely many)
variables in F♯(xτ), F♯(pτ) or F♯(aτ→ρ) in the input formula really corresponds
to quantiﬁcation of xτ, pτ or aτ→ρ in the translated formula.
In the third step, we focus on the behaviour of TRF on the set of closed
formulas. Since the deﬁnition of frames ensures that the matrix representation
of the interpretation of constant symbols only has simple complex numbers as
entries, the translation TRF(ϕ) of a closed formula ϕ of L∗in a given frame F
is actually a ﬁrst-order sentence of (C, +, ·, ·, ≺, S), where S is the set of simple
complex numbers (see page 72). A consequence of this is that pure formulas
of L are translated via TRF into ﬁrst-order sentences of (C, +, ·, ·, ≺), because
there are no constants in a pure formula. Therefore, by Lemma 3.8 and the
property of TRF by deﬁnition, we know that on a given frame F, F |= ϕ iﬀ
(C, +, ·, ·, ≺, S) |= TRF ◦∇(ϕ), for every closed formula ϕ ∈L.
The ﬁnal step is to reduce the ﬁrst-order theory of (C, +, ·, ·, ≺, S) to the ﬁrst-
order theory of the reals. This is a simple translation, where each simple complex
number is mapped to a pair of deﬁnable real numbers, and addition and multi-
plication are mapped according to complex arithmetic. Thus the decidability of
our logic follows from these reductions and Tarksi’s theorem. To summarize, we
have the following decidability result.
Theorem 5.1. The set {ϕ ∈L | ϕ is closed and F |= ϕ} is decidable, for any
given frame F. Moreover, the set {ϕ ∈L | ϕ is pure and |= ϕ} is decidable.
6
Conclusions
This paper extends decidability results from [10] and [4] to a language that is
much more versatile in its ability to express quantum algorithms and their cor-
rectness. Our techniques can be applied to a wider range of quantum logics,
giving a general recipe for showing decidability as long as deﬁnability of the
sentences and operators can be done along the lines presented in this paper.

80
A. Baltag et al.
In addition we have described how to express the correctness of Quantum Tele-
portation, the Quantum Search algorithm and the Deutsch-Josza algorithm;
however this is not an exhaustive list of algorithms whose correctness can be
expressed in our language. The Fourier transform can easily be expressed in our
language and this may lead to a wealth of further examples, notably those involv-
ing the hidden subgroup problem, such as order-ﬁnding and factoring; however
we leave these for future work. Other future tasks involve ﬁnding a complete
axiomatization and determining the complexity of the decision procedure.
References
1. Abramsky, S., Coecke, B.: A categorical semantics of quantum protocols. In: Pro-
ceedings of the 19th IEEE Conference on Logic in Computer Science (LiCS 2004),
pp. 415–425. IEEE Press (2004)
2. Aerts, D.: Description of compound physical systems and logical interaction of
physical systems. In: Beltrametti, E., van Fraassen, B. (eds.) Current Issues on
Quantum Logic, pp. 381–405. Kluwer Academic (1981)
3. Baltag, A., Bergfeld, J., Kishida, K., Sack, J., Smets, S., Zhong, S.: PLQP &
company: Decidable logics for quantum algorithms. Submitted to the International
Journal of Theoretical Physics (2013)
4. Baltag, A., Bergfeld, J., Kishida, K., Sack, J., Smets, S., Zhong, S.: A Decidable
Dynamic Logic for Quantum Reasoning. In: EPTCS (2012) (in print)
5. Baltag, A., Smets, S.: Complete Axiomatizations for Quantum Actions. Interna-
tional Journal of Theoretical Physics 44(12), 2267–2282 (2005)
6. Baltag, A., Smets, S.: LQP: The Dynamic Logic of Quantum Information. Math-
ematical Structures in Computer Science 16(3), 491–525 (2006)
7. Birkhoﬀ, G., von Neumann, J.: The Logic of Quantum Mechanics. The Annals of
Mathematics 37, 823–843 (1936)
8. Chadha, R., Mateus, P., Sernadas, A., Sernadas, C.: Extending classical logic for
reasoning about quantum systems. In: Engesser, K., Gabbay, D.M., Lehmann, D.
(eds.) Handbook of Quantum Logic and Quantum Structures: Quantum Logic, pp.
325–371. Elsevier (2009)
9. Dalla Chiara, M.L., Giuntini, R., Greechie, R.: Reasoning in quantum theory: sharp
and unsharp quantum logics. Trends in logic, vol. 22. Kluwer Acadamic Press,
Dordrecht (2004)
10. Dunn, J.M., Hagge, T.J., Moss, L.S., Wang, Z.: Quantum Logic as Motivated by
Quantum Computing. The Journal of Symbolic Logic 70(2), 353–359 (2005)
11. Henkin, L.: Completeness in the Theory of Types. The Journal of Symbolic
Logic 15, 81–91 (1950)
12. Nielsen, M.A., Chuang, I.L.: Quantum Computation and Quantum Information.
Cambridge University Press (2000)
13. Piron, C.: Foundations of Quantum Physics. W.A. Benjamin Inc. (1976)
14. Rabin, M.: Decidability of second order theories and automata on inﬁnite trees.
Transactions of the American Mathematical Society, 1–35 (1969)
15. Randall, C., Foulis, D.: Tensor products of quantum logics do not exist. Notices
Amer. Math. Soc. 26(6) (1979)
16. Selinger, P.: Towards a quantum programming language. Mathematical Structures
in Computer Science 14, 527–586 (2004)
17. Tarski, A.: A Decision Method for Elementary Algebra and Geometry. RAND
Corporation, Santa Monica (1948)

Structural Extensions of Display Calculi:
A General Recipe
Agata Ciabattoni and Revantha Ramanayake
Vienna University of Technology
{agata,revantha}@logic.at
Abstract. We present a systematic procedure for constructing cut-free display
calculi for axiomatic extensions of a logic via structural rule extensions. The sufﬁ-
cient conditions for the procedure are given in terms of (purely syntactic) abstract
properties of the display calculus and thus the method applies to large classes of
calculi and logics. As a case study, we present cut-free calculi for extensions of
well-known logics including Bi-intuitionistic and tense logic.
1
Introduction
Driven by the rising demand of researchers and practitioners, the last decades have wit-
nessed a tremendous growth in research on logics different from classical logic and also
the deﬁnition of many new logics. The usefulness of these logics and the key to their
application often lies in the existence of analytic calculi, that is, calculi in which proofs
proceed by stepwise decomposition of the formulae to be proved. Indeed, analytic cal-
culi have been widely applied to establish fundamental properties of the logics and are
themselves the focus of much research.
Since its introduction by Gentzen [8], the sequent calculus has been the favourite
framework for deﬁning analytic calculi. However, this framework is not powerful
enough to formalise all interesting logics. For this reason a huge range of extensions
of the sequent calculus have been introduced, in many cases for the sole purpose of
obtaining analytic calculi for particular logics. General and well-known formalisms in-
clude hypersequents [1], bunched calculi [13], labelled deductive systems [7,16] and
the calculus of structures [12]. Since the construction of an analytic calculus is often
tailored to the speciﬁc logic under consideration, a large numbers of papers in the liter-
ature deal with this topic and yet many interesting logics still lack an analytic calculus.
The display calculus [2] is a powerful and semantic-independent formalism that can be
used to capture a variety of different logics ranging from resource-oriented logics [4] to
substructural [9] and temporal logics [14]. The beauty of the display calculus lies in a
general cut-elimination theorem for all calculi obeying eight easily veriﬁable syntactic
conditions [2,17]; this makes the display calculus a good candidate for capturing large
classes of logics in a uniﬁed way, irrespective of their semantics or connectives.
Nonclassical logics are often introduced by adding properties — expressed as Hilbert
axioms — to known systems. Systematic procedures to automate the construction of
new analytic calculi from such Hilbert axioms are highly desirable. In this direction
e.g. [5,6,16,14,15,11] introduce methods to extract rules out of suitable Hilbert axioms.
L. Libkin, U. Kohlenbach, and R. de Queiroz (Eds.): WoLLIC 2013, LNCS 8071, pp. 81–95, 2013.
c⃝Springer-Verlag Berlin Heidelberg 2013

82
A. Ciabattoni and R. Ramanayake
More precisely [5,6] generate sequent and hypersequent rules, [11] nested sequent rules,
[15] sequent rules for certain modal axioms, and [16] labelled rules; ﬁnally [14] trans-
forms suitable modal and tense axioms (called primitive tense axioms) into structural
rules for the display calculus. [14] also provides a characterisation as it is shown that
each such rule added to the base system is equivalent to the extension of the logic by
primitive tense axioms.
All the above results start with a speciﬁc logic and introduce calculi for (some of) its
axiomatic extensions, e.g., Full Lambek calculus with exchange FLe for [5,6], or the
tense logic Kt for [14,11]. This paper proposes instead a recipe that utilises the more
common Hilbert axioms to construct analytic calculi1. In particular, given a suitable
base calculus for a logic, we identify a hierarchy of axiom classes — computed as a
function of the invertible (logical) introduction rules of the base calculus — and show
how to translate axioms from suitable classes into equivalent structural rules. More in-
vertible rules in the base calculus lead to larger sets of axioms in each suitable class, and
then to the construction of cut-free calculi for more logics. In the case of intermediate
logics, for example, we capture more logics than the hypersequent calculi in [5].
The emphasis is not to deﬁne such calculi for speciﬁc families of logics but to pro-
vide a methodology to construct them in a uniform and systematic way starting from a
display calculus satisfying general conditions. Since the conditions are given in terms
of (purely syntactic) abstract properties of the display calculus, the method applies to
large classes of calculi and logics. As a case study, we present analytic calculi for ax-
iomatic extensions of propositional (Bi-)intuitionistic logic, bunched, modal and tense
logics. This allows for the automated introduction of (inﬁnitely many) analytic display
calculi for logics.
2
Display Calculi in a Nutshell
Given a language L, we write ForL to denote the formulae of L. We identify a logic
with the set of theorems in its Hilbert calculus.
Belnap’s Display Calculus [2] — introduced under the name Display Logic — gener-
alises Gentzen’s sequent calculus by supplementing the structural connective (comma)
with new structural connectives. A (display) sequent X ⊢Y is a tuple (X, Y ) where X
and Y are structures which are built from formulae and structure constants using the
structural connectives of the calculus. Structure X (resp. Y ) is called the antecedent
(succedent) of the sequent. A display calculus consists of initial sequents and rules and
includes the cut-rule. The rules of the calculus are usually presented as rule schemata.
Concrete instances of a rule are obtained by substitution of a formula (resp. structure)
for each schematic formula (structure) variable. Following standard practice, we do not
explicitly distinguish between a rule and a rule schema. A derivation in the display cal-
culus is deﬁned in the usual way. In this paper we use A, B, C, D, . . . (possibly with
subscripts) to denote formulae and X, Y, U, V, . . . to denote structures.
A structural rule in the display calculus is constructed from structure variables us-
ing structural connectives and structure constants. The logical rules usually introduce
1 In the direction of general results, [10] shows how to extract display calculi starting from the
algebraic Gaggle-theoretic semantics of a logic.

Structural Extensions of Display Calculi: A General Recipe
83
exactly one logical connective, as the primary connective in a formula that is the whole
of the antecedent or succedent of the conclusion. The cut-rule has the following form,
where X, Y are structures and A is a formula:
X ⊢A
A ⊢Y
cut
X ⊢Y
The calculus obtained by the addition of structural rules is a structural rule extension.
A rule is admissible in C if the conclusion is derivable when the premises are derivable.
A rule is invertible in C if the premises are derivable when the conclusion is derivable.
Deﬁnition 1 (equivalent rules). Let R0 and R1 be sets of rules. We say that R0
and R1 are equivalent wrt C if each rule in Ri is admissible in C + R1−i for i = 0, 1.
By viewing a sequent X ⊢Y as the zero-premise rule with conclusion X ⊢Y , we can
deﬁne in the obvious way what it means for two sequents to be equivalent, and for a
sequent to be equivalent to a rule.
Let Z be a structure. Any structure that occurs in Z is called a substructure of Z.
Trivially, Z is a substructure of itself. The deﬁning feature of a display calculus is that
it satisﬁes the display property.
Deﬁnition 2 (display property; a-part, s-part). Let Z be an occurrence of a substruc-
ture occurring in a sequent X ⊢Y . Using the invertible structural rules (the ‘display
rules’) a sequent of the form Z ⊢U or U ⊢Z can be derived for suitable U. In the
former (resp. latter) case, the occurrence Z is said to be displayed as an a-part (s-part)
structure.
Since a formula is itself a structure, the display property applies to a formula occurring
in a sequent but not to its proper subformulae.
A calculus is said to be cut-eliminable if it is possible to eliminate all occurrences of
the cut-rule from a given derivation in order to obtain a cut-free derivation of the same
sequent. A display calculus has the subformula property if every formula that occurs in
a cut-free derivation appears as a subformula of the ﬁnal sequent. An important feature
of the display calculus are Belnap’s conditions C1–C8 on the rules of the calculus.
(C1) Each (schematic) formula variable occurring in a premise of a rule ρ ̸= cut is a
subformula of some formula in the conclusion of ρ.
(C2) Congruent parameters is a relation between parameters of the identical structure
variable occurring in the premise and conclusion sequents of a rule.
(C3) Each parameter is congruent to at most one structure variable in the conclusion.
Ie. no two structure variables in the conclusion are congruent to each other.
(C4) Congruent parameters are all either a-part or s-part structures.
(C5) A formula variable in the conclusion of a rule ρ is either the entire antecedent
or the entire succedent. This formula is called a principal formula of ρ.
(C6/7) Each rule is closed under simultaneous substitution of arbitrary structures for
congruent parameters.
(C8) If there are rules ρ and σ with respective conclusions X ⊢A and A ⊢Y with
formula A principal in both inferences (in the sense of C5) and if cut is applied
to yield X ⊢Y , then either X ⊢Y is identical to either X ⊢A or A ⊢Y ; or it is
possible to pass from the premises of ρ and σ to X ⊢Y by means of inferences
falling under cut where the cut-formula always is a proper subformula of A.

84
A. Ciabattoni and R. Ramanayake
Belnap’s general cut-elimination theorem states that C2–C8 constitute sufﬁcient con-
ditions for a calculus to be cut-eliminable and C1 is the subformula property. Only
condition C8 is non-trivial to check. However, C8 is not relevant for structural rules.
This further motivates the interest in structural rule extensions of the display calculus.
Deﬁnition 3. Let C be a display calculus and let L be a logic in the language L. We
say that C is a calculus for L to mean that for every A ∈ForL: C derives A iff A ∈L.
Given a display calculus C, we denote by LC the language determined by the connec-
tives introduced by its logical rules. We do not exclude the possibility that a display
calculus C for a logic in the language L derives B for some B ̸∈ForL. This can occur
only when the subset relation L ⊂LC is strict.
3
The Recipe
Suppose that C is a display calculus for a logic L in the language L satisfying C1–C8.
We show how to deﬁne structural rules r1, . . . , rm so that C + {r1, . . . , rm} is a cut-
eliminable calculus for the axiomatic extension L + {A1, . . . , An} (Ai ∈ForL). Our
method is constructive and works whenever the base calculus C is ‘expressive enough’
(i.e., it is amenable), and the axioms Ai have a certain syntactic form.
Deﬁnition 4 (amenable calculus). Let C be a display calculus satisfying C1–C8. As-
sume that we have two functions l and r mapping structures into ForLC such that
l(A) = r(A) = A when A ∈ForLC, and for an arbitrary structure X
(i) X ⊢l(X) and r(X) ⊢X are derivable in C.
(ii) X ⊢Y derivable implies l(X) ⊢r(Y ) is derivable C.
Let there be a structure constant I, and let the following rules be admissible in C for
arbitrary structures X, Y such that the premise and conclusion are well-deﬁned in C.
I ⊢X
lI
Y ⊢X
X ⊢I
rI
X ⊢Y
Let there be binary logical connectives ∨, ∧∈LC such that · ∈{∨, ∧} is associative
in C — A · (B · C) ⊢(A · B) · C and (A · B) · C ⊢A · (B · C) are derivable — and
commutative in C — A · B ⊢B · A is derivable. Also, for A, B ∈ForLC:
(a)∨A ⊢X and B ⊢X implies ∨(A, B) ⊢X
(b)∨X ⊢A implies X ⊢∨(A, B) for any formula B.
(a)∧X ⊢A and X ⊢B implies X ⊢∧(A, B)
(b)∧A ⊢X implies ∧(A, B) ⊢X for any formula B.
A display calculus satisfying the above conditions is said to be amenable.
Requiring that lI and rI are admissible in C is weaker than requiring that C contains
weakening rules. Indeed, the rules lI and rI are admissible in the bi-Lambek calcu-
lus [9]. The function l (resp. r) ‘interprets’ the structural connectives in the antecedent

Structural Extensions of Display Calculi: A General Recipe
85
(resp. succedent). Above, we use the notation ∧and ∨to reﬂect that in a classical cal-
culus, the connectives conjunction and disjunction satisfy the respective properties.
Our recipe abstracts and reformulates for display calculi the procedure in [5,6],
deﬁned for (hyper)sequent calculi and substructural logics. To transform axioms into
structural rules we use: (1) the invertible logical rules of C and (2) the display calculus
formulation, below, of the so-called Ackermann’s lemma that allows a formula in a rule
to switch sides of the sequent moving from conclusion to premises.
Lemma 1. The following rules are pairwise equivalent in an amenable calculus where
A ∈ForL, S is a set of sequents and Z(̸=X) is a structure variable not in S.
S
ρ1
X ⊢A
S
A ⊢Z ρ2
X ⊢Z
S
δ1
A ⊢X
S
Z ⊢A δ2
Z ⊢X
Proof. Suppose that we have concrete derivations of the premises S ∪{A ⊢Z} of ρ2.
Applying ρ1 to S we get X ⊢A. Applying cut with A ⊢Z we get X ⊢Z and thus it
follows that ρ2 is admissible in a calculus containing ρ1.
Now suppose we have concrete derivations of the premises S of ρ1. Observe that
r(A) ⊢A is derivable. Applying ρ2 to S ∪{r(A) ⊢A} we get X ⊢A as required. The
proof that δ1 and δ2 are equivalent is analogous.
We now give an abstract description of the axioms that we can handle. The description
is based on the invertible rules of the chosen display calculus C and is inspired by the
classiﬁcation in [5] of formulae of FLe. We identify three classes of formulae in the
language of L from which the logical connectives can be removed using the invertible
rules of C at various levels. The class I0 consists of formulae with no logical connective
(so there is no need for the invertible rules). Logical connectives in formulae in I1 can
be eliminated by repeatedly applying the invertible rules starting with sequents (thus
obtaining sets of sequents). Logical connectives in formulae in I2 can be eliminated
by repeatedly applying the invertible rules to formulae, sequents and to the premises of
rules obtained via Lemma 1 (thus obtaining sets of structural rules).
Deﬁnition 5 (inv). The function inv takes a sequent X ⊢Y and applies all the in-
vertible logical rules in C that are possible and returns the (necessarily ﬁnite) set
{Xi ⊢Yi}i∈Ω of sequents for some index set Ω.
Deﬁnition 6 (soluble). A formula A ∈ForL is a-soluble (resp. s-soluble) if the se-
quents in inv(A ⊢) (resp. inv(⊢A)) do not contain any logical connectives.
Deﬁnition 7. Let C be an amenable calculus for L. The classes I0, I1, I2 of formulae
of ForL are deﬁned in the following way: A ∈ForL with inv( ⊢A) = {Ui ⊢Vi}i∈Ω
for some ﬁnite Ω belongs to
I0 if A contains no logical connectives
I1 if each a-part formula in Ui ⊢Vi is a-soluble and each s-part formula in Ui ⊢Vi is
s-soluble
I2 if each a-part formula in Ui ⊢Vi is s-soluble and each s-part formula in Ui ⊢Vi is
a-soluble

86
A. Ciabattoni and R. Ramanayake
A propositional variable is both a-soluble and s-soluble so I0 ⊆I1 and I0 ⊆I2. Note
that every a-part (resp. s-part) formula B occurring in a sequent in inv( ⊢A) that is a-
soluble (s-soluble) must be a propositional variable and thus B is s-soluble (a-soluble)
in that sequent. It follows that I1 ⊆I2.
Remark 1. The above classes are a function of the invertible rules of the base calculus.
In particular, these coincide with the classes in the hierarchy of [5] that can be handled
by structural sequent rules, when the base calculus has the same invertible rules. More
invertible rules lead to larger classes of formulae in I1 and I2 (see Section 4.2).
Henceforth a rule whose conclusion is constructed from structure variables and struc-
ture constants using structural connectives, and whose premises might additionally con-
tain propostional variables will be called a semi-structural rule.
Proposition 1. Let C be an amenable calculus for L. Suppose A ∈ForL with
inv(⊢A) = {Ui ⊢Vi}i∈Ω. If A ∈I2 then there are equivalent semi-structural rules
{ρi}i∈Ω so that C + {ρi}i∈Ω is a cut-eliminable calculus for L + A.
Proof. Clearly ⊢A is equivalent to {Ui ⊢Vi}i∈Ω in C. We show how to construct
a semi-structural rule equivalent to each Ui ⊢Vi. Suppose that Ui ⊢Vi consists of
a-part formulae C1, . . . , Cn and s-part formulae D1, . . . , Dm. Starting with Ui ⊢Vi,
display each Ci (as Ci ⊢Wi for suitable Wi) and apply Lemma 1 in turn, to obtain an
equivalent rule of the form below left. Start with this rule and display in the conclusion
each Di (as Wn+i ⊢Di for suitable Wn+i) and apply Lemma 1 in turn, to obtain an
equivalent rule of the form below right:
Z1 ⊢C1
. . .
Zn ⊢Cn
Zn ⊢Wn
Z1 ⊢C1 . . . Zn ⊢Cn
D1 ⊢Zn+1 . . . Dm ⊢Zn+m
Wn+m ⊢Zn+m
Observe that Wn+m ⊢Zn+m is constructed only from structure variables and structure
constants using structural connectives. Since A ∈I2, every Ci (resp. Di) formula is s-
soluble (a-soluble) and so the following is a semi-structural rule equivalent to Ui ⊢Vi:
inv(Z1 ⊢C1) . . . inv(Zn ⊢Cn)
inv(D1 ⊢Zn+1) . . . inv(Dm ⊢Zn+m) ρi
Wn+m ⊢Zn+m
By inspection it may be veriﬁed that ρi satisﬁes Belnap’s conditions with the possi-
ble exception of C1 and C4 since the same propositional variable might appear in the
premises as an a-part and s-part formula. However, since no propositional variable oc-
curs in the conclusion of ρi, cut-elimination for C+{ρi}i∈Ω proceeds without difﬁculty.
Notice that the calculus C + {ρi}i∈Ω in the above result has cut-elimination but not in
general the subformula property. If we restrict our attention to a subclass of I2 satis-
fying the additional condition of acyclicity then the propositional variables appearing
in each ρi can be suitably removed. In this way we obtain structural rules satisfying
C1–C8 so the resulting calculus is cut-eliminable and has the subformula property.
Deﬁnition 8 (proper structural rules; extensions). A proper structural rule (exten-
sion) is a structural rule (extension) that satisﬁes C1–C8.

Structural Extensions of Display Calculi: A General Recipe
87
Our transformation of semi-structural rules into proper structural rules mirrors the
‘completion’ procedure in [6] and amounts to applying the cut-rule in all possible ways
to the premises of the former rules. Below we present formally the transformation.
A (possibly empty) set S of sequents is said to respect multiplicities wrt p for some
propositional variable p if it can be written in one of the forms below:
{p ⊢U | p ̸∈U} ∪{V ⊢p | every p in V ⊢p is s-part} ∪{S | p ̸∈S}
(1)
{U ⊢p | p ̸∈U} ∪{p ⊢V | every p in p ⊢V is a-part} ∪{S | p ̸∈S}
(2)
An alternative deﬁnition is that (i) no S ∈S contains both an a-part and s-part occur-
rence of p — eg. p ⊢p cannot be in S, and (ii) there do not exist S1, S2 ∈S such that S1
contains multiple a-part occurrences of p and S2 contains multiple s-part occurrences
of p. Eg. if both occurrences of p in p ⊗p ⊢X (resp. Y ⊢p ⊗p) are a-part (s-part) for
a structural connective ⊗, then it cannot be that p ⊗p ⊢X ∈S and Y ⊢p ⊗p ∈S.
Let S be a set of sequents respecting multiplicities wrt p. If it is not the case that p ⊢
U ∈S and V ⊢p ∈S (upto display equivalence) then deﬁne Sp as {S ∈S | p ̸∈S}.
Otherwise, depending on the form of S as (1) or (2), deﬁne respectively Sp as follows:
{S | S is a subst. instance of V ⊢p ∈S s.t. each occ. p →U for some p ⊢U ∈S} ∪{S | p ̸∈S}
{S | S is a subst. instance of p ⊢V ∈S s.t. each occ. p →U for some U ⊢p ∈S} ∪{S | p ̸∈S}
In the above, notice that distinct occurrences of p in V ⊢p (resp. p ⊢V ) may be
substituted for distinct Ui so long as p ⊢Ui (Ui ⊢p) is in S. Also observe that the
substitution instance S contains no occurrence of p since p ̸∈U.
Intuitively, if S contains sequents of the form p ⊢U and V ⊢p then Sp is obtained
by (i) applying the cut-rule in all possible ways on p (using the sequents in S as the
premises) and then keeping only those conclusion sequents of the cut-rule that do not
contain p, and (ii) retaining {S ∈S | p ̸∈S}.
Lemma 2. If S respects multiplicities wrt p, then p does not occur in Sp.
Proof. Follows immediately from the form of S and the deﬁnition of Sp.
Let V(S) be the set of propositional variables occurring in a set S of sequents.
Deﬁnition 9. A ﬁnite set S of sequents is acyclic if V(S) = ∅or for every p ∈V(S):
(i) S respects multiplicities wrt p, and (ii) Sp is acyclic.
Deﬁnition 10. Suppose that A ∈I2 and let {ρi}i∈Ω be the equivalent semi-structural
rules obtained using Prop. 1. We say that A is acyclic if the set of premises of each rule
in {ρi}i∈Ω is acyclic.
Remark 2. Every axiom in I1 is acyclic. This follows from the observation that for
every A ∈I1, the premise of each semi-structural rule obtained using Prop. 1 has the
form p ⊢L or L ⊢p where L is a schematic structure variable.
Lemma 3. Let S be an acyclic set of sequents and p ∈V(S). Then the semi-structural
rule ρ with premises S and the semi-structural rule ρp with premises Sp are equivalent
w.r.t. an amenable calculus C.

88
A. Ciabattoni and R. Ramanayake
Proof. Let S be an acyclic set of sequents. Suppose that S does not contain sequents of
the form p ⊢U and V ⊢p. Then S has one of the following forms
{V1 ⊢p, . . . , Vn+1 ⊢p} ∪{S | p ̸∈S}
{p ⊢V1, . . . , p ⊢Vn+1} ∪{S | p ̸∈S}
and Sp is {S ∈S | p ̸∈S}. Suppose the case above left (the other case is similar).
One direction is immediate, and to show that ρp is admissible in C + ρ it is enough to
apply ρ using the derivable sequents {r(I) ⊢Vi[p →r(I)]}1≤i≤n+1 — obtained from
the derivation of r(I) ⊢I using the rule rI — for the missing premises.
Now suppose that S contains sequents of the form p ⊢U and V ⊢p. Clearly ρ is
admissible in C + ρp — it sufﬁces to apply the cut-rule to concrete premises of ρ and
then apply ρp. For the other direction, assume, to ﬁx ideas that the premises S of ρ have
the form (1) (the other case is similar, use (a)∨and (b)∨instead of (a)∧and (b)∧), i.e.,
{p ⊢Ui | p ̸∈Ui; 1 ≤i ≤n} ∪{V ⊢p | every p in V ⊢p is s-part} ∪{S | p ̸∈S}
Then the premises Sp of ρp have the following form:
{S | S is a subst. instance of V ⊢p ∈S s.t. each occ. p →Ui for some 1 ≤i ≤n) } ∪{S | p ̸∈S}
Suppose that we are given concrete instances of the premises of ρp. Repeatedly using
(a)∧and the display rules, obtain the set S∗
p:
{S | S is a subst. instance of V ⊢p ∈S s.t. each occ. p →∧1≤i≤nr(Ui) }∪{S | p ̸∈S}
Making use of (b)∧, derive the set {∧1≤i≤nr(Vi) ⊢Vi} of sequents. By inspection, this
set together with S∗
p yield concrete instances of the premises of ρ (in particular, p has
been instantiated with ∧1≤i≤nr(Vi)). Applying ρ to these and noting that ρ and ρp have
the same conclusion, we have that ρp is admissible in C + ρ.
Theorem 2. Let C be an amenable calculus for L and suppose that A ∈I2 is acyclic.
Then there is a proper structural rule extension for L + A.
Proof. Let {ρi}i∈Ω be the semi-structural rules computed from A in Prop. 1. No-
tice that each ρi might violate (only) Belnap’s conditions C1 and C4 due to the
presence of propositional variables in the set S of sequents that are its premises.
Let V(S) = {p1, p2, . . . , pn} be such variables and
ρ′
i be the rule with premises
((. . . (Sp1)p2 . . .)pn−1)pn. By inspection of the construction of ρ′
i from ρ follows that ρ′
i
is a proper structural rule (in particular, observe that any structure variable that appears
only as an a-part (resp. s-part) structure in every sequent in S has the same property in
((. . . (Sp1)p2 . . .)pn−1)pn). Since A is acyclic, so is S and hence, by (repeteadly apply-
ing) Lemma 2 it follows that ρ′
i is equivalent to ρi.
By repeating this process to all {ρi}i∈Ω we obtain a new set of rules {ρ′
i}i∈Ω such
that C + {ρ′
i}i∈Ω is a proper structural rule extension of L + A.
4
Case Studies
We apply the recipe in Section 3 to obtain many existing results uniformly, and to show
that new calculi can be deﬁned in an automated way. When dealing with a concrete

Structural Extensions of Display Calculi: A General Recipe
89
base calculus we can provide an explicit description (grammar-like) of the class I2 of
axioms that can be transformed into equivalent structural rules to obtain cut-eliminable
display calculi. We present this grammar for the case of intermediate logics to compare
our results with those in [5].
4.1
Bi-intuitionistic Logic
Bi-intuitionistic logic (also known as Heyting-Brouwer logic) is the logic which results
when the dual →d of implication (alias coimplication) is added to the language of in-
tuitionistic logic. Here we show how to construct cut-free display calculi for inﬁnitely
many axiomatic extensions of this logic in a uniform way.
The language LHB of Heyting-Brouwer logic HB is obtained from the language LIp
of intuitionistic propositional logic Ip by the addition of →d. To simplify the language,
we abbreviate ¬p := p →⊥and ¬dp := ⊤→d p. Wansing [18] give a proper display
calculus δHB for HB. Our presentation here differs in that we use the invertible forms
for ∧r and ∨l. Equivalence with the original rules can be shown using the structural
rules of contraction and weakening in δHB.
The set of structures Str(LHB) generated from LHB has the following grammar:
X ::= A ∈ForLHB | I | (X ◦X) | (X • X)
The initial sequents of δHB are of the form p ⊢p for any propositional variable p,
and I ⊢⊤and ⊥⊢I. Now we present the structural rules. In the ﬁrst row, below, we
use a double line to separate the premises from the conclusion to indicate that a rule
is invertible and also ‘combine’ two rules into a single one for the sake of brevity. The
ﬁrst two columns (counting from the left) in the ﬁrst row are the display rules of δHB.
Y ⊢X ◦Z
X ◦Y ⊢Z
X ⊢Y ◦Z
X • Y ⊢Z
X ⊢Y • Z
X • Z ⊢Y
I ◦X ⊢Y
X ⊢Y
X ◦I ⊢Y
X ⊢Y • I
X ⊢Y
X ⊢I • Y
X ⊢Y
X ⊢Y • Z
X ⊢Y
X ◦Z ⊢Y
X ⊢Y • Z
X ⊢Z • Y
X ◦Z ⊢Y
Z ◦X ⊢Y
X ⊢Y • Y
X ⊢Y
X ◦X ⊢Y
X ⊢Y
X ⊢(Y • Z) • U
X ⊢Y • (Z • U)
(X ◦Y ) ◦Z ⊢U
X ◦(Y ◦Z) ⊢U
The logical rules of δHB are given below:
I ⊢X
⊤l
⊤⊢X
X ⊢I
⊥r
X ⊢⊥
A ◦B ⊢X
∧l
A ∧B ⊢X
X ⊢A
X ⊢B
∧r
X ⊢A ∧B
A ⊢X
B ⊢X
∨l
A ∨B ⊢X
X ⊢A • B
∨r
X ⊢A ∨B
X ⊢A
Y ⊢B
→l
A →B ⊢X ◦Y
X ⊢A ◦B
→r
X ⊢A →B
B • A ⊢X
→d l
B →d A ⊢X
X ⊢B
Y ⊢A →d r
X • Y ⊢B →d A

90
A. Ciabattoni and R. Ramanayake
Deﬁne the functions l and r from Str(LHB) into ForLHB:
l(A) = A
r(A) = A
l(I) = ⊤
r(I) = ⊥
l(X ◦Y ) = l(X) ∧l(Y )
r(X ◦Y ) = l(X) →r(Y )
l(X • Y ) = l(X) →d l(Y )
r(X • Y ) = r(X) ∨r(Y )
It is easy to check that δHB is amenable. (Note that ∧and ∨are associative and com-
mutative connectives in δHB). We have the following result.
Proposition 3. Every logical rule except →l and →dr is invertible.
Theorem 4. Let A be any (acyclic) axiom within I2. Then there is a (proper) structural
rule extension of δHB for HB + A.
The following examples contain analytic display calculi for two axiomatic extensions
of HB introduced in [19].
Example 1. Let A1 be the axiom (p →q) ∨(q →p). Then inv(⊢A1) is the sequent
⊢(p ◦q) • (q ◦p). Since each formula in that sequent is a propositional variable, it is
a,s-soluble. Thus A1 ∈I1. From Prop. 1 we obtain the equivalent semi-structural rule
(below left). The set S of premises of this rule can be written {X ⊢p}∪{p ⊢V }∪{Z ⊢
q, q ⊢Y }. Then Sp = {X ⊢V, Z ⊢q, q ⊢Y }. Hence Spq = {X ⊢V, Z ⊢Y }. So S
is acyclic and is equivalent to the proper structural rule below right:
X ⊢p
q ⊢Y
Z ⊢q
p ⊢V
ρ1
I ⊢(X ◦Y ) • (Z ◦V )
X ⊢V
Z ⊢Y
ρ′
1
I ⊢(X ◦Y ) • (Z ◦V )
Thus δHB + ρ′
1 is a cut-eliminable display calculus for HB + A1 with subformula
property. In practice, ρ′
1 can be obtained from ρ1 on sight, by applying the cut-rule to
the premises in ‘all possible ways’.
Example 2. Let A2 be ¬((p →d q) ∧(q →d p)). A2 ∈I1. Applying our recipe we get
the equivalent rule ρ2 such that δHB + ρ2 is a proper display calculus for HB + A2.
X ⊢Z
U ⊢Y
ρ2
(X • Y ) ◦(U • Z) ⊢I
4.2
Intuitionistic Logic
We discuss intermediate logics and compare our algorithm for display logic with the
algorithm in [5] that works for hypersequent calculus – a simple generalization of
Gentzen calculus [1] whose basic objects are multisets of sequents.
The calculus δHB−obtained by deleting the logical rules for →d is a display calculus
for Ip — soundness of HB−relies on the fact that Ip is a conservative extension of
HB, and completeness follows from cut-elimination for HB. Observe that in δHB−—
unlike in Gentzen’s calculus LJ — the ∨r rule is also invertible. Following the idea of

Structural Extensions of Display Calculi: A General Recipe
91
the classiﬁcation in [5], which is sketched below for the connectives of Ip (= FLe with
weakening and contraction), we can deﬁne I2 axioms for Ip and δHB−as follows
I0 ::= prop. variables
In+1 ::= ⊥| ⊤| In →In+1 | In+1 ∧In+1 | In+1 ∨In+1
The class I2 is larger than the class of axioms that can be captured by structural hy-
persequent rules over LJ (see [5]). The latter consists of all axioms within the class P3
deﬁned by the following grammar: N0, P0 contains the set of atomic formulae, and
Pn+1 ::= ⊥| ⊤| Nn | Pn+1 ∧Pn+1 | Pn+1 ∨Pn+1
Nn+1 ::= ⊥| ⊤| Pn | Pn+1 →Nn+1 | Nn+1 ∧Nn+1
(the classes Pn and Nn stand for axioms with leading positive and negative connective,
i.e. having left (resp. right) logical rule invertible). It is easy to see that P3 ⊆I2.
By applying our recipe and making use of the weakening, commutativity and con-
traction rules in δHB−we can show the following:
Proposition 5. There is a proper structural rule extension of δHB−for Ip + A, for any
set A of axioms in P3.
Proof. By [5, Lemma 3.4] any P3 formula can be written as a conjunction of formulae
(∗) ∨1≤i≤N (αi
1 ∧. . . ∧αi
ni →βi) where each βi has the form qi
1 ∨. . . ∨qi
mi (qi
j is a
conjunction of propositional variables or ⊥). Hence inv(I ⊢A) consists of sequents of
the following form, where qi
j is some propositional variable occurring in qi
j.
I ⊢

(α1
1 ◦. . . ◦α1
n1) ◦(q1
1 • . . . • q1
m1)

•. . .•

(αN
1 ◦. . . ◦αN
nN) ◦(qN
1 • . . . • qN
mN)

Note that each αi
j is an a-part formula and each qi
j is an s-part formula. Now, fol-
lowing Prop. 1 we apply Lemma 1 and obtain that A is equivalent to the following
semi-structural rule, where Li
j is a structure variable (corresponding to αi
j) and Qi
j is a
structure variable (corresponding to qi
j).
{inv(Li
j ⊢αi
j)}1≤i≤N;1≤j≤ni
{qi
j ⊢Qi
j}1≤i≤N;1≤j≤mi
ρ′
I ⊢

(L1
1 ◦. . . ◦L1
n1) ◦(Q1
1 • . . . • Q1
m1)

• . . . •

(LN
1 ◦. . . ◦LN
nN ) ◦(QN
1 • . . . • QN
mN )

where the structure variables L1
1, . . . , LN
nN, Q1
1, . . . , QN
mN
are distinct. By [5,
Lemma 3.4], each αi
j in (∗) has the form ∧1≤k≤aj (U i
jk →vi
jk) where U i
jk is ⊤or
a conjunction of propositional variables. Hence each set inv(Li
j ⊢αi
j) consists of se-
quents of the form
Li
j ⊢(ui
j1 ◦. . . ◦ui
jai
j) ◦vi
j
Observe that each propositional variable ui
jk is an a-part formula and each proposi-
tional variable vi
j is an s-part formula. Since the calculus has contraction on ◦in the an-
tecedent, we may assume without loss of generality that the ui
jk are distinct for ﬁxed i.
If some ui
jk = vi
j then the sequent is derivable as follows by repeated use of the weak-
ening, commutativity and display rules for ◦:

92
A. Ciabattoni and R. Ramanayake
vi
j ⊢vi
j
(ui
j1 ◦. . . ◦ui
jaij) ⊢vi
j
Li
j ◦(ui
j1 ◦. . . ◦ui
jaij) ⊢vi
j
Li
j ⊢(ui
j1 ◦. . . ◦ui
jaij) ◦vi
j
Thus we can delete those premises of ρ′ such that ui
jk = vi
j to obtain an equivalent
rule ρ. The premises S of ρ have the following form:
{U ⊢p | p ̸∈U} ∪{p ⊢V | p ̸∈V } ∪{S | p ̸∈S}
Let S′
p be the set {U ⊢V | p ̸∈U, p ̸∈V } ∪{S | p ̸∈S}. Arguing as in Lemma 3
we can show that ρ is equivalent to the rule ρ′
p obtained by replacing the premises S
with S′
p. While S′
p does not contain p, it may contain a sequent with (i) multiple a-part
occurrences of some propositional variable or, (ii) an a-part and s-part occurrence of the
same propositional variable. Obtain the rule ρp from ρ′
p by contracting multiplicities
and deleting sequents witnessing (ii). Denote the premises of ρp by Sp. Repeat for all
propositional variables in S to obtain ultimately an equivalent proper structural rule.
Hence we can get proper structural rule extensions of δHB−for all intermediate logics
that can be formalized by hypersequent calculi using the algorithm in [5]. But we can
do more. Consider the axioms (Bdk) (k ≥1), deﬁning intermediate logics semanti-
cally characterized by Kripke models of depth ≤k, belong to the classes P2k in the
classiﬁcation in [5]; these axioms are recursively deﬁned as follows:
(Bd1)
p1 ∨¬p1
(Bdi+1)
pi+1 ∨(pi+1 →(Bdi))
For k ≥2, no axiom within P3 is known to be equivalent, yet these all belong to I1.
Example 3. The proper structural rule equivalent to the axiom (Bd2) is
Y ⊢X
V ⊢U
ρ
I ⊢X • (Y ◦(U • (V ◦I)))
In contrast no equivalent hypersequent structural rule is known.
Although our algorithm is inspired by that in [5], the key point is that the expressive
power of the display calculus permits a base calculus for Ip in which the ∨r rule is
also invertible, leading to cut-eliminable structural rule extensions for more logics (see
Remark 1). This justiﬁes the use of the more complex machinery of the display calculus.
Example 4. δHB−+ρ′
1 (cf. Example 1) is a cut-free calculus for Ip+A1 (= G¨odel logic)
with subformula property. Classical propositional logic Cp is obtained as Ip + p ∨¬p.
Since p ∨¬p ∈I1 we can deﬁne a proper structural rule extension of δHB−for Cp.
4.3
Bunched Logics
Bunched logics [13] provide a powerful framework to reason about resources. They
are obtained by combining an additive propositional logic with a multiplicative linear

Structural Extensions of Display Calculi: A General Recipe
93
logic [4]. The combination led to the deﬁnition of four systems: BI, BBI (Boolean BI),
dMBI (de Morgan BI) and CBI (classical BI). Brotherston [4] obtains display calculi
for these logics by freely combining a calculus DLIL (resp. DLCL) for intutionistic
(classical) propositional logic with a calculus DLLM (resp. DLdMM) for multiplicative
intuitionistic linear logic (multiplicative classical linear logic).
Using the calculus δHB−for intuitionistic logic instead of DLIL, new calculi for
BI and BBI can be obtained. These calculi can be extended with the structural rule
for classical logic (see Example 4) to obtain new calculi for dMBI and CBI that are
structural extensions of the calculi for BI and BBI.
More generally, our algorithm yields proper structural rule extensions over δHB−
for a large class of intermediate logics. Taking the free combination of such calculi with
{DLLM, DLdMM} yield cut-eliminable calculi for new bunched logics (intermediate
between BI and CBI) which may express interesting properties on resources.
4.4
Modal and Tense Logics
The modal language LK is obtained from the propositional classical language by the
addition of the modal operators 3 and □. The tense language LKt is obtained from LK
by the addition of the tense operators  and ■. The normal basic modal logic K and
tense logic Kt are conservative extensions of classical propositional logic Cp, obtained
by the addition of the usual axioms (see [3]).
The display calculus δKt [14] for Kt is well-known. Here we use the invertible form
of the rules for ∧r, ∨l and →l. The set of structures Str(LKt) generated from LKt has
the following grammar:
X ::= A ∈ForLKt | I | (X ◦X) | •X | ∗X
The initial sequents of δKt are of the form p ⊢p for any propositional variable p, and
I ⊢⊤and ⊥⊢I. In the following we use a double line to separate the premises from
the conclusion to indicate that a rule is invertible. The display rules of δKt are:
X ◦Y ⊢Z
X ⊢Z ◦∗Y
X ◦Y ⊢Z
Y ⊢∗X ◦Z
X ⊢Y ◦Z
X ◦∗Z ⊢Y
X ⊢Y ◦Z
∗Y ◦X ⊢Z
∗X ⊢Y
∗Y ⊢X
X ⊢∗Y
Y ⊢∗X
∗∗X ⊢Y
X ⊢Y
X ⊢∗∗Y
X ⊢Y
X ⊢•Y
•X ⊢Y
The remaining structural rules of δKt are given below.
X ⊢Z
I ◦X ⊢Z
X ⊢Z
X ⊢I ◦Z
I ⊢Y
∗I ⊢Y
X ⊢I
X ⊢∗I
X ⊢Z
Y ◦X ⊢Z
X ⊢Z
X ◦Y ⊢Z
I ⊢Y
•I ⊢Y
X ⊢I
X ⊢•I
X ◦Y ⊢Z
Y ◦X ⊢Z
Z ⊢X ◦Y
Z ⊢Y ◦X
X ◦X ⊢Z
X ⊢Z
Z ⊢X ◦X
Z ⊢X
X1 ◦(X2 ◦X3) ⊢Z
(X1 ◦X2) ◦X3 ⊢Z
Z ⊢X1 ◦(X2 ◦X3)
Z ⊢(X1 ◦X2) ◦X3

94
A. Ciabattoni and R. Ramanayake
Name
Axiom
Rule
Name
Axiom
Rule
D
□A →3A
(∗• ∗)•X ⊢Y/X ⊢Y
B
A →□3A ∗• ∗X ⊢Y/•X ⊢Y
3□A →□3A •X ⊢∗• ∗Y/∗• ∗X ⊢•Y
4
□A →□□A •X ⊢Y/ • •X ⊢Y
5
3A →□3A
∗• ∗X ⊢Y/∗• ∗X ⊢•Y
T
□A →A
•X ⊢Y/X ⊢Y
Fig. 1. Some I2 axioms and corresponding proper structural rules
The logical rules of δKt are given below.
I ⊢X
⊤l
⊤⊢X
X ⊢I
⊥r
X ⊢⊥
∗A ⊢X
¬l
¬A ⊢X
X ⊢∗A
¬r
X ⊢¬A
A ◦B ⊢X
∧l
A ∧B ⊢X
X ⊢A
X ⊢B
∧r
X ⊢A ∧B
A ⊢X
B ⊢X
∨l
A ∨B ⊢X
X ⊢A ◦B
∨r
X ⊢A ∨B
X ◦∗Y ⊢A
B ⊢∗X ◦Y
→l
A →B ⊢∗X ◦Y
X ◦A ⊢B
→r
X ⊢A →B
A ⊢X
□l
□A ⊢•X
X ⊢•A
□r
X ⊢□A
∗• ∗A ⊢X
3l
3A ⊢X
X ⊢A
3r
∗• ∗X ⊢3A
•A ⊢X
l
A ⊢X
X ⊢A
r
•X ⊢A
A ⊢X
■l
■A ⊢∗• ∗X
X ⊢∗• ∗A ■r
X ⊢■A
Deﬁne the functions l and r from Str(LKt) into ForLKt.
l(A) = A
r(A) = A
l(I) = ⊤
r(I) = ⊥
l(∗X) = ¬r(X)
r(∗X) = ¬l(X)
l(X ◦Y ) = l(X) ∧l(Y )
r(X ◦Y ) = r(X) ∨r(Y )
l(•X) = l(X)
r(•X) = □r(X)
It is easy to check that δKt is amenable.
Proposition 6. Every logical rule with the exception of □l, 3r, r and ■l is invertible.
Theorem 7. There is a proper structural rule extension of δKt for axiomatic extension
of Kt with acyclic I2 axioms.
A procedure to deﬁne proper structural display logic rules for primitive axiomatic ex-
tensions of K and Kt was introduced by Kracht’s [14]. A primitive tense axiom has the
form A →B where both A and B are constructed from propositional variables and ⊤
using {∧, ∨, 3, } and A contains each propositional variable at most once.
Kracht’s method to extract structural rules is very different from our method, and
relies on being able to transform the axiom into a primitive tense formula. Eg. the axiom
□A →A must be rewritten as the primitive tense formula A →3A. [17] rewrites the
familiar B axiom A →□3A in the primitive tense form as (A∧3B) →3(B ∧3A).

Structural Extensions of Display Calculi: A General Recipe
95
Example 5. Fig. 1 contains some examples of I2 axioms (see Table IV in [17]) and
corresponding rules generated using our procedure. Contrast our strucutural rule for the
B axiom with the rule generated by Kracht’s method (see [17]):
∗• ∗(X ◦∗• ∗Y ) ⊢Z
Y ◦∗• ∗X ⊢Z
In contrast with out method, Kracht’s result provides a characterisation (a necessary and
sufﬁcient condition). Indeed
Theorem 8 (Kracht). Let L be a tense logic. Then L is an axiomatic extension of Kt
by primitive tense axioms iff there is a proper structural rule extension of δKt for L.
It follows that every acyclic I2 axiom is equivalent to a primitive tense axiom.
References
1. Avron, A.: A Constructive Analysis of RM. J. of Symbolic Logic 52(4), 939–951 (1987)
2. Belnap, N.D.: Display Logic. Journal of Philosophical Logic 11(4), 375–417 (1982)
3. Blackburn, P., de Rijke, M., Venema, Y.: Modal logic. Cambridge Tracts in Theoretical Com-
puter Science (2001)
4. Brotherston, J.: Bunched Logics Displayed. Studia Logica 100(6), 1223–1254 (2012)
5. Ciabattoni, A., Galatos, N., Terui, K.: From axioms to analytic rules in nonclassical logics.
In: Proceedings of LICS 2008, pp. 229–240 (2008)
6. Ciabattoni, A., Straßburger, L., Terui, K.: Expanding the realm of systematic proof theory. In:
Gr¨adel, E., Kahle, R. (eds.) CSL 2009. LNCS, vol. 5771, pp. 163–178. Springer, Heidelberg
(2009)
7. Fitting, M.: Proof Methods for Modal and Intuitionistic Logics. Dordrecht, Holland (1983)
8. Gentzen, G.: The collected papers of Gerhard Gentzen. Studies in Logic and the Foundations
of Mathematics, Amsterdam (1969); Szabo, M.E. (ed.)
9. Gor´e, R.: Substructural Logics on Display. Logic Journal of the IGPL 6(3), 451–504 (1998)
10. Gor´e, R.: Gaggles, Gentzen and Galois: how to display your favourite substructural logic.
Logic Journal of the IGPL 6(5), 669–694 (1998)
11. Gor´e, R., Postniece, L., Tiu, A.: On the Correspondence between Display Postulates and
Deep Inference in Nested Sequent Calculi for Tense Logics. Logical Methods in Computer
Science 7(2) (2011)
12. Guglielmi, A.: A system of interaction and structure. ACM Transaction on Computational
Logic 8(1), 1–64 (2007)
13. O’Hearn, P., Pym, D.: The Logic of Bunched Implications. Bulletin of Symbolic Logic 5(2),
215–244 (1999)
14. Kracht, M.: Power and weakness of the modal display calculus. In: Proof Theory of Modal
Logic, pp. 93–121. Kluwer (1996)
15. Lellmann, B., Pattinson, D.: Constructing Cut Free Sequent Systems With Context Restric-
tions Based on Classical or Intuitionistic Logic. In: Lodaya, K. (ed.) ICLA 2013. LNCS,
vol. 7750, pp. 148–160. Springer, Heidelberg (2013)
16. Negri, S.: Proof analysis in non-classical logics. In: Logic Colloquium 2005, pp. 107–128
(2007)
17. Wansing, H.: Displaying modal logic. Kluwer Academic Publishers (1998)
18. Wansing, H.: Constructive negation, implication, and co-implication. Journal of Applied
Non-Classical Logics 18, 341–364 (2008)
19. Wolter, F.: On logics with coimplication. Journal of Philosophical Logic 27(4), 353–387
(1998)

The Same, Similar, or Just Completely
Diﬀerent? Equivalence for Argumentation
in Light of Logic
Sjur Kristoﬀer Dyrkolbotn⋆
Durham Law School, Durham University, UK
s.k.dyrkolbotn@durham.ac.uk
Abstract. In recent years, argumentation theory and logic have moved
closer to each other, a development due in large part to Dung’s mathe-
matically precise deﬁnition of an abstract argumentation framework as
a digraph and the intuitively plausible semantics for argumentation that
can be formulated using this structure. This work raises some questions,
however, regarding the relationship between an abstract argumentation
framework – a directed graph – and the underlying argumentative struc-
ture that it is taken to represent. One such question, which we study
in this paper, is the question of when two arguments should be consid-
ered the same, a question which has been surprisingly controversial, and
which also, as we will demonstrate, gives rise to interesting technical
results and future challenges.
1
Introduction
Abstract argumentation in the style of Dung [11] has gained much popularity
in the AI-community, we point to [10] for an overview. Its appeal seems due in
large part to the mathematically simple and precise basis which Dung uses to
introduce his semantic notions. His argumentation frameworks are nothing but
directed graphs, and semantics for abstract argumentation are deﬁned in terms of
the underlying graph-structure. This suggests logical modeling, a challenge that
has been taken on in recent work, e.g., in [8,16,15]. Whereas these contributions
rely on modal logic, we will follow [13,14,20] and use Lukasiewicz logic to study
argumentation. The formalization we propose is very simple, in some sense naive,
but our purpose is not to provide a new form of representation for the semantic
structures themselves, which are already nicely represented in terms of digraphs.
What we want is a logic for reasoning about them, to allow us to state and explore
their properties in a succinct way. In the following, we take this route to shed
new light on the question of equivalence.
⋆I am very thankful for helpful comments from Truls Pedersen, Piotr Ka´zmierczak and
Michal Walicki. I also thank BNC@ECAI 2012 for accepting a preliminary version
of this paper for a presentation at their conference, and the anonymous reviewers,
for making helpful suggestions for improvements.
L. Libkin, U. Kohlenbach, and R. de Queiroz (Eds.): WoLLIC 2013, LNCS 8071, pp. 96–110, 2013.
c
⃝Springer-Verlag Berlin Heidelberg 2013

The Same, Similar, or Just Completely Diﬀerent?
97
In Section 2, we brieﬂy present abstract argumentation and Lukasiewicz logic,
as well as the connection between them. In Section 3, we exploit this connection
to describe notions of equivalence arising from well-known semantics for argu-
mentation. Then, in Section 4, we address the problem of characterizing logical
equivalence, concluding with a result which employs a new notion of bisimulation
to give a suﬃcient condition for when two argumentation frameworks behave the
same way, and have the same logical properties.
2
Background
We ﬁx a countably inﬁnite set of atoms Π, which we think of as abstract argu-
ments. Given some set A ⊆Π, an argumentation framework over A, a framework
for short, is a digraph, F = ⟨A, R⟩with R ⊆A×A a set of directed edges, called
the attack relation. If (a, b) ∈R, we say that a attacks the argument b. We use
the notation R−(x) = {y | (y, x) ∈R} and R+(x) = {y | (x, y) ∈R}, extended
pointwise to sets, such that, for instance, R+(X) = 	
x∈X R+(x). For general
relations α ⊆X × Y , we drop + as a superscript and use α(x) = {y | (x, y) ∈α}
and α−(y) = {x | (x, y) ∈α}. This also extends pointwise to sets. For two frame-
works F and F2, we say they are isomorphic if there is a (graph-)isomorphism be-
tween them, i.e., a bijective function i : A →A2 such that R+
2 (i(a)) = i(R+(a))
A framework F = ⟨A, R⟩is a subframework of a framework F2 = ⟨A2, R2⟩
iﬀA ⊆A2 and R ⊆R2. A subset of arguments X ⊆A gives rise to the
induced subframework X = ⟨X, RX⟩with RX = {(x, y) ∈R | x, y ∈X}. F \ X
denotes the subframework of F induced by A \ X. A backwards inﬁnite walk is
a sequence λ = x1x2x3 . . . such that xi+1 ∈R−(xi) for all i ≥1. Notice that
in ﬁnite argumentation frameworks, there can be backwards inﬁnite walks, but
they must involve one or more arguments twice, i.e., they involve cycles.
Some of the most well-known semantics for argumentation, ﬁrst introduced
in [11] and [19,9] (semi-stable semantics), are given in the following deﬁnition.
Deﬁnition 2.1. Given any argumentation framework F = ⟨A, R⟩and a subset
A ⊆A, we deﬁne D(A) = {x ∈A | R−(x) ⊆R+(A)}, the set of vertices
defended by A. We say that
– A is conﬂict-free if R+(A) ⊆A \ A, i.e., if there are no two arguments in
A that attack each other.
– A is admissible if it is conﬂict free and A ⊆D(A). The set of all admissible
sets in F is denoted a(F).
– A is complete if it is conﬂict free and A = D(A). The set of all complete
sets in F is denoted c(F).
– A is preferred if it is admissible and not strictly contained in any admissible
set. The set of all preferred sets in F is denoted p(F).
– A is stable if R+(A) = A \ A. The set of all stable sets in F is denoted s(F)
– A is semi-stable if it is admissible and there is no admissible set B such that
A ∪R+(A) ⊂B ∪R+(B). The set of all semi-stable sets in F is denoted by
ss(F).

98
S.K. Dyrkolbotn
We also mention the grounded semantics, which can be seen as an application
of the complete semantics. It collects those arguments that are present in every
complete set, i.e., it can be deﬁned as g(F) = $ c(F).1
For any ϵ ∈S = {a, c, p, s, ss}, we also say that S ∈ϵ(F) is an extension (of
the type prescribed by ϵ). Given S ∈ϵ(F), x ∈A we say that x is accepted (by
S) if x ∈S and that it is defeated if R−(x) ∩S ̸= ∅. If neither of these obtain, x
is said to be rejected. Moreover, such a status holds skeptically if it obtains with
respect to all S ∈ϵ(F), and credulously if it obtains for some S ∈ϵ(F).
Clearly, these notions have logical structure. Viewing x as a formula, we might
as well say that it is skeptically accepted just in case it follows as a logical conse-
quence from the framework and credulously accepted if it is mutually consistent
with it. Moreover, if x is defeated, we should be able to say, taking the logical
view further, that ¬x is true. Notice that the notion of rejection does not coin-
cide with defeat, the obvious example being the self-attacking argument, which
is skeptically rejected under any semantics, yet cannot be defeated. It follows
that the logic we need for expressing properties of arguments is not classical,
but three-valued.2
We will use the following (inﬁnitary) propositional language L:
φ ::= a |

Φ | ¬φ | φ →φ
where a ∈A and Φ ⊆L is a (possibly inﬁnite) set of formulas. We remark that
if we restrict attention to ﬁnite frameworks, the ﬁnitary language will always
suﬃce. We deﬁne φ ∧ψ, φ ↔ψ and ⊥(contradiction) standardly, and we will
also use the following abbreviations.

Φ ::= ¬

{¬φ | φ ∈Φ},
!wφ ::= ¬φ →φ,
!φ ::= ¬!w¬φ
The appropriate semantics is Lukasiewicz’s three-valued one, deﬁned as follows,
see for instance [5].
Deﬁnition 2.2. Given an assignment π : Π →{0, 1/2, 1} its extension, ¯π, is
deﬁned inductively on the complexity of formulas.
1 This said, the grounded set has attracted quite some interest in more application-
oriented works on argumentation. It is useful, in particular, because it can be com-
puted in linear time [11].
2 The logical view allows us to oﬀer further qualiﬁcation for our claim that it might
be more appropriate to view the grounded set as an application of the complete set.
Indeed, a similar perspective can be taken on all so-called unique status semantics, of
which the grounded is an example (like ideal and eager semantics [12,6]). They start
from existing semantics and impose some more or less sensible rule for ”picking the
winners”, arriving at a unique extension. It follows – in logical terms – that anything
satisﬁable (credulously acceptable) is tautologically true (skeptically accepted), and
this holds already at the level of individual atoms/arguments, eﬀectively rendering
any logic based on the semantics, like we propose here, void of content. It seems to
us, however, that the diﬃculty on agreeing on the correct rule for picking winners
suggests that a more ﬂexible, and structurally rich, approach, by way logic, is often
more appropriate than committing oneself to a particular unique-status approach.

The Same, Similar, or Just Completely Diﬀerent?
99
– ¯π(a) = π(a) for all a ∈Π
– ¯π(¬φ) = 1 −¯π(φ)
– ¯π(φ →ψ) = min{1, (1 −¯π(φ)) + ¯π(φ)}
– ¯π( Φ) = min{¯π(φ) | φ ∈Φ}
The consequence relation of Lukasiewicz logic is |=L⊆2L × L, deﬁned such that
Φ |=L φ iﬀfor all π : Π →{0, 1/2, 1}, we have that ¯π(φ) = 1 whenever ¯π(ψ) = 1
for all ψ ∈Φ.
The meaning of the abbreviations !φ and !wφ, due to Tarski, can now be ex-
plained: they say of φ that it is true and not false respectively, and they do so
in a deﬁnitive way; they cannot themselves obtain the status of being undeter-
mined (evaluate to 1
2). For π : Π →{0, 1/2, 1} we deﬁne π1 = {x | π(x) = 1}
and similarly for π0 and π
1
2 .
Using Lukasiewicz logic, we can encode extensions of a framework as logi-
cal formulas. We deﬁne, in particular, for all A ⊆A, the (possibly inﬁnitary)
conjunction φid(A):
φid(A) =

x∈A
x ∧

y∈R+(A)
¬y ∧

z∈A\(A∪R+(A))
z ↔¬z
φid(A) characterizes A logically by being made true by exactly those assignments
that agree with A on A. That is, such that for all π : Π →{0, 1/2, 1}, we have
π |= φid(A) if and only if π1 ∩A = A and π0 ∩A = R+(A). We can now write
every extension as the following formula, deﬁned for all ϵ ∈S:
φϵ(F) = !

{φid(A) | A ∈ϵ(F)}
Clearly, this representation, being constructed by brute force by taking the dis-
junction of all extensions that the framework admits under ϵ, provides a faithful
view. We have, in particular, the following simple fact, the proof of which is
trivial and omitted.
Fact 2.3. For any F = ⟨A, R⟩and any ϵ ∈S, we have ϵ(F) = {π1 ∩A | π |=L
φϵ(F))}
The representation provides what we want, namely a logic for reasoning about
consequences of a given semantics.3 As we observed earlier, credulous acceptance
should amount to mutual consistency, and it does; we have that a ∈A is credu-
lously accepted just in case φϵ(F) ∧a ̸|=L ⊥. Since φϵ(F) can never evaluate to 1
2
(because we put ! in front of the conjunction), we also have the relevant instance
3 We mention that Lukasiewicz logic oﬀer a less trivial characterization of φc(F). In
[14], it is established that φc(F) is in fact equivalent to the formula {x ↔{¬y |
y ∈R−(x)} | x ∈A}, which is linear in the size of the framework, and thus provides
a representation of the complete semantics which is more useful, computationally
speaking. See also [1], which builds on a series of similar observations and develops
them within a framework of quantiﬁed boolean logic.

100
S.K. Dyrkolbotn
of the deduction theorem, i.e., the above is equivalent to ̸|=L φϵ(F) ∧a →⊥.
Skeptical acceptance, on the other hand, becomes logical consequence, such that
a is skeptically accepted with respect to ϵ just in case |=L φϵ(F) →a. For a more
complex example of what we can express, consider the following scenario, with
a framework for which it is a logical consequence that if we defeat b, then we
can neither accept nor defeat c. This, in particular, is what the formula on the
right says in logical language.
F : a
 b

 c 
φa(F) |=L ¬b →c ↔¬c
Although our logical representation is simple, examples such as these suggests
its usefulness. Since we have a logical language, we can now express arbitrarily
complex properties and interactions, as long as they arise in a truth-functional
way from the basic notions of acceptance, defeat and rejection.
3
Notions of Equivalence for Argumentation
In the literature, if equivalence is considered, it seems typical to consider a
very simple notion whereby two frameworks are regarded as equivalent if they
have the same sets of extensions. In terms of logic, this equivalence arises at
the level of the theories describing the extensions; it obtains just in case the
theories have the same set of satisfying assignments, i.e., just in case they are
logically equivalent. Another notion of equivalence, which is more subtle, and
also seems more interesting from the point of view of applications, is the notion
that follows as a logical consequence of the extensions. Rather than saying that
the frameworks are the same, this is the notion which says that two arguments,
in the same framework, behave the same way. Such a notion of equivalence has,
as far as we are aware, only been studied in one previous paper [17]. In this work,
however, the focus is on the grounded semantics, and on a notion of semantics
which introduces new distinctions between arguments, distinctions that do not
arise from the grounded semantics itself, but from new notions that the authors
ﬁnd appealing. While introducing new notions might be appropriate, it is not
the same as investigating equivalences that arise from semantic notions already
established, which is our aim here.
Given the simple logical footing we have provided above, it is simple to account
for the behavioral equivalences we have in mind, and to do so in a way that
makes it clear that they arise from existing semantics, and do not represent new
proposals. It seems, in particular, that the notions of equivalence we capture in
the following deﬁnition do not require, and, indeed, can not possibly be given
any other justiﬁcation than that which one might ﬁnd occasion to provide in
support of ϵ itself.
Deﬁnition 3.1. Structural equivalence: For any two frameworks F and F2, we
say that they are structurally equivalent under ϵ ∈S if |=L φϵ(F) ↔φϵ(F2).
Behavioral equivalence: For any framework F and a, b ∈A, we say that a and b
are behaviorally equivalent under ϵ ∈S if |=L φϵ(F) →(a ↔b).

The Same, Similar, or Just Completely Diﬀerent?
101
The following trivial fact explicates the equivalent semantic characteristics, and
both points follows trivially from Fact 2.3.
Fact 3.2. For any two frameworks F, F2 and arguments a, b ∈A:
(1) F and F2 are structurally equivalent under ϵ ∈S iﬀϵ(F) = ϵ(F2)
(2) a and b are behaviorally equivalent under ϵ ∈S iﬀ∀A ∈ϵ(F) : a ∈A ⇔b ∈A
As we mentioned, the notion of structural equivalence has already received some
attention and recognition in the argumentation community. Moreover, nice re-
sults have been obtained in [18,3], where the authors investigate conditions under
which structural equivalence is preserved under various ways in which an argu-
mentation framework can be extended. This is particularly interesting because
extending a framework is not a logically monotone operation; adding arguments
and attacks to a framework does not, for any of the semantics we consider, cor-
respond to adding formulas to the theories characterizing its extensions. Rather,
it introduces new notions of logical revision that have yet to be deﬁned and
explored from a (monotonic) logical point of view. We think doing this is an in-
teresting challenge for future work, but we do not pursue it further in this paper.
Moreover, we note that the results obtained in [18,3] are limiting in the sense
that they demonstrate that structural equivalence tends to be preserved under
expansion/revision only in case of frameworks that are isomorphic. This seems
to indicate that the notions of expansion needs to be restricted, or else that
structural equivalence itself might be of limited relevance.4 It also suggests the
appropriateness of considering other notions of equivalence, and in the following
we will oﬀer a contribution in this regard, by lifting the notion of behavioral
equivalence such it can also be applied to relate diﬀerent, but behaviorally sim-
ilar, frameworks.
First, let us ﬁrst consider a class of frameworks that serves to motivate what
is to follow, namely those that consist of a single cycle of attack. Under all
semantics we consider here, these fall into one of two categories: those that have
even length and those that have odd length.5
Now, it is a basic fact of argumentation that no odd cycle has a non-empty
admissible set, and hence no argument is acceptable with respect to any se-
mantics from Deﬁnition 2.1, in any odd cycle. In particular, all odd cycles are
structurally equivalent in the sense of Deﬁnition 3.1. So far so good, but for the
even cycles, structural equivalence fails: no two even cycles of diﬀerent length
4 The only straightforward notion we know of which does not give rise to severe col-
lapses, is the notion of weak expansion. But as noted in [3], it appears to be of limited
interest, since it disallows introducing any new attacks on arguments already present
in the framework. We also mention [4], which introduces another notion of equiva-
lence based on considering the minimal change needed to enforce a set of arguments.
This notion (or related/competing ones) might be interesting with respect to speciﬁc
heuristics for instantiation, as explored in [7], but will not be addressed further here.
5 Indeed, some have claimed that there is only one category; that even and odd-length
cycles should be treated the same way since they are both ungrounded chains of
arguments. This requires new semantic notions however, as presented in [2].

102
S.K. Dyrkolbotn
are structurally equivalent. In our opinion, this is unsatisfying. To illustrate
further, consider two arbitrary even length cycles, F and F2 depicted below.
F
F2
x1

x2

x4
 x3

x1

x2

x3

x6
 x5
 x4

How do we reason about F and F2?
Well, suppose that the argument x1 from F has some proponent. Then this pro-
ponent should recognize that his argument is attacked by the argument x2 and
then become a proponent of argument x3 as well, since this argument attacks x2
and therefore defends x1. This is when the reasoning stops in F, the proponent
notices at this point that although x4 attacks x3, it is in turn attacked by x1, so
his argument, while not conclusive, is at least admissible. In F2, the story, in all
essential aspects, is the same; a proponent of x1 realizes he should also support
x3, but now, since the cycle is longer, he also comes to support x5 for the same
reason.
The observation we want to make is that even when the length of cycles diﬀer,
if they have the same parity, they are still – logically speaking – the same. But
on the level of the frameworks, we have no notion of equivalence that allows
us to recognize this sense of sameness. On the level of arguments, however, the
notion of behavioral equivalence does detect it. For it follows, for any even cycle,
that every other vertex is behaviorally equivalent. In F2, for instance, we have
φs(F2) |=L (x1 ↔x3 ↔x5)∧(x2 ↔x4 ↔x6). Now, in our opinion, this example
serves to illustrate two things. First, that the notion of behavioral equivalence
is often more informative and useful than that of structural equivalence, and,
second, that behavioral equivalence should indeed be lifted to frameworks.
Formally, it seems natural to do so by ﬁrst deﬁning the behavioral contraction
of a framework, that is, the framework resulting from collapsing all arguments
that are behaviorally equivalent. Given a framework F, such a contraction is an
obvious candidate for a canonical framework, since it captures, in a minimal way,
how F behaves under ϵ. Towards formalization, we will, given ϵ ∈S, start by
partitioning A into equivalence classes 	
a∈A{[a]ϵ = {b ∈A | φϵ(F) |=L a ↔b}}.
Then we can provide the following deﬁnition.
Deﬁnition 3.3. Given a framework F = ⟨A, R⟩, its behavioral contraction un-
der ϵ ∈S is the framework Cϵ(F) = ⟨Cϵ(A), Cϵ(R)⟩where
Cϵ(A) = {[a]ϵ | a ∈A}
and
([a]ϵ, [b]ϵ) ∈Cϵ(R) ⇔∃a′ ∈[a]ϵ, b′ ∈[b]ϵ : (a′, b′) ∈R
Given two frameworks F and F2, we say that they are behaviorally equivalent
if there are frameworks i(Cϵ(F)) and i2(Cϵ(F2)), isomorphic to Cϵ(F) and Cϵ(F2)
respectively, such that |=L φϵ(i(Cϵ(F))) ↔φϵ(i2(Cϵ(F2)))
That is, we regard two frameworks as being behaviorally the same if their be-
havioral contractions are structurally equivalent under renaming of arguments.

The Same, Similar, or Just Completely Diﬀerent?
103
In fact, it seems to us, coming from logic, that this deﬁnition is fairly standard,
following, for instance, the notions of equivalence arising from the use of various
kinds of bisimulations in modal logic. So, is it adequate? Does it indeed capture
a notion of equivalence arising logically from the underlying semantics? It is not
hard to answer this in the aﬃrmative. Formally, for φ ∈L, we let Π(φ) denote the
atoms appearing in φ. Then, for any function f : Π(φ) →Π, we denote by f(φ)
the formula resulting from replacing x in φ by f(x) for each x ∈Π(φ). Now, given
frameworks F and F2 which have behavioral contractions that admit isomor-
phisms i(Cϵ(F)) and i2(Cϵ(F2)) such that |=L φϵ(i(Cϵ(F))) ↔φϵ(i2(Cϵ(F2))), we
let f : A →Cϵ(A) and f2 : A2 →Cϵ(A2) be deﬁned by f(a) = [a]ϵ, f2(a2) = [a2]ϵ
for all a ∈A, a2 ∈A2. Then it is easy to verify that our deﬁnition is logically
adequate, in the sense that logical consequences of F and F2 (under ϵ ∈S) are
preserved under behavioral equivalence, in the following sense:
(1) : φϵ(F) |=L φ ⇔i(f(φϵ(F))) |=L i(f(φ)) ⇔i2(f2(φϵ(F2))) |=L i2(f2(φ))
for all φ such that Π(φ) ⊆A
(2) : φϵ(F2) |=L φ ⇔i2(f2(φϵ(F2))) |=L i2(f2(φ) ⇔i(f(φϵ(F)))) |=L i(f(φ))
for all φ such that Π(φ) ⊆A2
(3.4)
The usefulness of this result depends on how diﬃcult it is to establish behavioral
equivalences, either between arguments, or between frameworks, and in the fol-
lowing we will study this problem. However, its appropriateness seems beyond
doubt. If we can establish behavioral equivalence, we can move freely between
frameworks, analyzing the argumentation scenario at hand in the structure for
which it is easiest to do so. It is a logical truth, in particular, that no informa-
tion is lost by doing so. If the feeling is to the contrary, if it appears that the
notion gives rise to unacceptable collapses or over-simpliﬁcations, this is due to
the semantic notions themselves, not the notion of equivalence they give rise to.
4
Characterizing Behavioral Equivalence
Having demonstrated how a notion of behavioral equivalence arises from argu-
mentation semantics, and having provided a logical basis for it, we now turn to
the question of obtaining results that structurally characterizes when two argu-
ments and/or frameworks are behaviorally equivalent. First, we investigate the
link with relations that happen to both preserve and reﬂect all extensions of a
given semantics.
Deﬁnition 4.1. Given two frameworks F and F2, ϵ ∈S and a relation α ⊆
A × A, we say that α is an ϵ-relation, if the following two conditions hold:
(1) For all A ∈ϵ(F), α(A) ∈ϵ(F2)
(2) For all A2 ∈ϵ(F2), α−(A2) ∈ϵ(F)
If there is an ϵ-relation between F and F2, we write F ≡ϵ F2

104
S.K. Dyrkolbotn
Clearly, if F ≡ϵ F2, there is a close relationship between the arguments, and
how they interact, in these two frameworks. After all, any ϵ-extension in one
gives rise to an ϵ-extension in the other. Does it follow that two argumentation
frameworks are behaviorally equivalent if and only if there is an ϵ-relation be-
tween them? It turns out that the answer is yes for the preferred, semi-stable
and stable semantics, and no for the complete and admissible semantics. To show
the latter claim ﬁrst, consider the following two argumentation frameworks.
F :
F2 :
y
	 x


x′

 y′

x2
 y2

It is not hard to verify that under admissible and complete semantics, F and F2
are both their own behavioral contractions – no two arguments are equivalent in
either framework – and then, since they are not structurally equivalent (under
any renaming), it follows that they are not behaviorally equivalent. Still, the
relation α = {(x, x2), (x′, x2), (y, y2), (y′, y2)} both preserves and reﬂects admis-
sible and complete sets. It follows that existence of an ϵ-relation does not imply
behavioral equivalence for these semantics. Next, let us show that existence of
an ϵ-relation does imply behavioral equivalence with respect to preferred, semi-
stable and stable semantics.
Proposition 4.2. For any two frameworks F and F2 and any ϵ ∈{p, ss, s}, we
have F ≡ϵ F2 if and only if F and F2 are behaviorally equivalent.
Proof. (⇐) Deﬁne f : A →Cϵ(F), f2 : A2 →Cϵ(F2) by f(a) = [a]ϵ, f2(a2) =
[a2]ϵ for all a ∈A, a2 ∈A2. Clearly, we have that f and f2 are ϵ-relations between
F, F2 and Cϵ(F), Cϵ(F2) respectively. Since F and F2 are behaviorally equivalent,
there are isomorphisms i, i2 such that |=L φϵ(i(Cϵ(F))) ↔φϵ(i2(Cϵ(F2))), and it
follows that f −
2 ◦i−
2 ◦i ◦f is an ϵ-relation between F and F2. (⇒) The orbit
of α partitions A and A2 into equivalence classes [a]α and [a2]α, deﬁned for all
a ∈A, a2 ∈A2 as the least set A (resp. A2) such that a ∈A (resp. a2 ∈A2) and
α−(α(A)) = A (resp. α(α−(A2)) = A2). To complete the proof, we will show
that the partitioning of A and A2 into behavioral equivalence classes is a reﬁne-
ment of the partitioning induced by α. By deﬁnition of orbit and the fact that
equivalence is transitive, it suﬃces to show (1): for all a, b ∈A, if a2 ∈α(a)∩α(b)
then φϵ(F) |=L a ↔b and (2): for all a2, b2 ∈A, if a ∈α−(a2) ∩α−(b2) then
φϵ(F2) |=L a2 ↔b2. We show (1) for ϵ = p, the other cases are similar. As-
sume towards contradiction that a2 ∈α(a) ∩α(b) for some preferred set P such
that a ∈P, b ̸∈P. Since α preserves and reﬂects extensions, we know that
P ′ = α−(α(P)) is a preferred set. Clearly, we have P ⊆P ′ and, moreover, we
have b ∈P ′ since a2 ∈α(b) ∩α(a) ⊆α(P). This contradicts maximality of P,
required by deﬁnition of preferred sets.
□
Note that a-relations are c-relations, and are also ϵ-relations for all other seman-
tics. So existence of an a-relation (and c-relation) also establishes behavioral
equivalence with respect to the other semantics. Moreover, note that the failure
of a-relations to establish a-behavioral equivalence is down to some arguments

The Same, Similar, or Just Completely Diﬀerent?
105
not obtaining any deﬁnite status. It holds, in particular, for every ϵ ∈S and
ϵ-relation α that if a2 ∈α(a) ∩α(b), then there can not be any admissible A
such that a ∈A and b ∈R+(A). The reason is that this would imply existence
of c ∈R−(b)∩A, which in turn would imply a, b, c ∈A′ = α−(α(A), meaning A′
is not independent, hence not admissible, contradicting that α is an a-relation.
Moreover, the argument used in the proof of Proposition 4.2 also shows that
for any two a, b ∈A, if they are in the same equivalence class induced by the
orbit of some a-relation, it means that they are equivalent in the looser sense of
satisfying ∀A ∈a(F) : a ∈A ⇒∃A′ ⊇A : A′ ∈a(F) ∧b ∈A′.
Having found an alternative characterization of behavioral equivalence, using
ϵ-relations, we can study behavioral equivalence by proxy, working with the more
straightforward and manageable Deﬁnition 4.1 in place of Deﬁnition 3.1. We do
so in the following, when we investigate bisimulations.6
Deﬁnition 4.3. Given argumentation frameworks F and F2, a relation β ⊆
A × A2 is said to be a bisimulation if we have:
forth: For every x ∈A, y ∈R−(x), for all x2 ∈β(x) there is y2 ∈R−
2 (x2)∩β(y)
back: For every x2 ∈A2, y2 ∈R−
2 (x2), for all x ∈β−(x2) there is y ∈R−(x) ∩
β−(y2)
Notice that the deﬁnition asks for mutual simulation of incoming attacks. For
ϵ ∈{a, c, p, s, ss}, it is not hard to see that existence of bisimulations are neither
necessary nor suﬃcient for existence of ϵ-relations. The problem is that a bisim-
ulation does not ensure that attacks are absent when they need to be in order
to ensure conﬂict-freeness. It is easy to see, for instance, that an even cycle is
bisimilar to a single self-attacking argument.
However, as we show in the Appendix, bisimulations behave well with respect
to defense, and they only fail to preserve conﬂict-freeness in speciﬁc circum-
stances. To illustrate, assume that you have two arguments a, b in some frame-
work F such that a and b are not in any conﬂict, and that you then relate them
by a bisimulation β to some a2, b2 in F2 with b2 ∈R−(a2). It then follows by
β being a bisimulation (”back”), that there must be some c ∈β−(b2) such that
c ∈R−(a). So an attacker of a, namely c, was merged with a non-attacker of a,
namely b. Such a collapse has to occur when bisimulations fail to preserve and
reﬂect extensions. Let us attempt to limit it, by oﬀering the following deﬁnition.
Deﬁnition 4.4. Given two frameworks F and F2, a bisimulation β ⊆A × A2 is
ﬁnitely collapsing (called an fc-bisimulation) if the following holds:
global forth: For every backwards inﬁnite walk λ = x1x2x3 . . . in F2, there
exists some i ∈N such that |β−(xi)| = 1
global back: For every backwards inﬁnite walk λ = x1x2x3 . . . in F, there exists
some i ∈N such that |β(xi)| = 1
6 We should mention that bisimulations also feature in the work of Grossi [16,15],
but there with respect to the authors interpretation of argumentation frameworks
as Kripke models, and hence in the standard modal logical sense.

106
S.K. Dyrkolbotn
The main result, established in the Appendix (Theorem 5.3), is that fc-
bisimulations are ϵ-relations with respect to all semantics we consider. From
this, we obtain immediately the following corollary regarding behavioral
equivalence.
Theorem 4.5. Given a framework F and a reﬂexive relation α ⊆A×A. If α is
a bisimulation and every backwards inﬁnite path contains at least one argument
which is only related to itself, then all arguments related by α are behaviorally
equivalent under all ϵ ∈{p, ss, s}.
As an example of an instance of equivalence witnessed by this result, consider
the following framework.
F :
a
 b

 c

Here, we have that a and c are behaviorally equivalent, and this is witnessed by
the reﬂexive bisimulation which relates a and c and maps b only to itself.
5
Conclusion
We presented a simple representation of argumentation semantics in terms of
Lukasiewicz logic, allowing us to express complex claims concerning arguments,
their semantic status, and their interactions. We showed its merit by studying
equivalence, arriving at notions that are all logically derived from existing seman-
tic notions. We argued for the importance of the notion of behavioral equivalence
between arguments, and we lifted it to the level of frameworks, taking quotients,
and without making any new claims about the nature of argumentation, beyond
those already present in the semantics we considered. We followed up on this
by addressing the problem of ﬁnding nice structural characterizations of behav-
ioral equivalence, providing a result linking the logically deﬁned notion with the
concept of an arbitrary relation between frameworks that preserve and reﬂect
solutions. Moreover, we provided a suﬃcient condition for behavioral equivalence
in terms of bisimulations.
We believe our work shows both the appropriateness and usefulness of the sim-
ple logical representation in Lukasiewicz logic, and, moreover, that it suggests the
merit of investigating further the notions of equivalence that this representation
allows us to recognize.
Appendix
First, we show that bisimulations behave nicely when it comes to defense.
Fact 5.1. Consider arbitrary frameworks F, F2 and some bisimulation β ⊆A ×
A2. Then we have
(1) For all A ⊆A, β(D(A)) = D(β(A)) – β preserves defended arguments and

The Same, Similar, or Just Completely Diﬀerent?
107
(2) For all A2 ⊆A2, β−(D(A2)) = D(β−(A2)) – β reﬂects defended arguments.
Proof. (1) Given A ∈A, we show both inclusions. (⊆) Consider arbitrary
y ∈D(A), y2 ∈β(y) and z2 ∈R−
2 (y2). Then by β being a bisimulation (”back”),
it follows that there is z ∈β−(z2) such that z ∈R−(y). Since y ∈D(A) it
follows that there is x ∈A such that x ∈R−(z). Then by β being a bisimulation
(”forth”) it follows that there is x2 ∈β(x) such that x2 ∈R−
2 (z2), meaning
z2 ∈R−
2 (β(A)). We conclude y2 ∈D(β(A)) as desired. (⊇) Consider arbitrary
y2 ∈D(β(A)), y ∈β−(y2) and z ∈R−(y). Then by β being a bisimulation
(”forth”), it follows that there is z2 ∈β(z) such that z2 ∈R−(y2). Since y2 ∈
D(β(A)), it follows that there is x2 ∈β(A) such that x2 ∈R−(z2). From β being
a bisimulation (”back”), it follows that there is x ∈β−(x2) such that x ∈R−(z).
It follows that y ∈D(A), meaning that y2 ∈β(D(A)) as desired.
(2) The argument is symmetric to that used to show (1).
□
The next result concerns the relationship between various semantics.
Theorem 5.2. Given frameworks F and F2, if β ⊆A × A2 is a bisimulation,
then if β preserves and reﬂects admissible sets, it also preserves and reﬂects
preferred, semi-stable and stable sets.
Proof. For all semantics, we only show preservation. Reﬂection can be shown
symmetrically. Stable: Assume that S ⊆A is stable. We know β(S) is conﬂict-
free and must show A2 \ β(S) = R+
2 (β(S)). Consider arbitrary x2 ∈A2 \ β(S).
Then β−(x2) ⊆A\S, so there is y ∈S such that y ∈R−(β−(x2)). By β being a
bisimulation (”forth”), we have x2 ∈R+
2 (β(S)) as desired. Preferred: Assume
that S ⊆A is preferred. Then β(S) is admissible. Assume towards contradiction
that there is A2 ⊃β(S) which is admissible in F2. Then β−(A2) is admissible in
F and since β(β−(A2)) ⊇A2 ⊃β(S), we have β−(A2) ⊃S, contradiction. Semi-
stable: Assume that S ⊆A is semi-stable, i.e. that S is admissible, and that
there is no admissible A ⊆A such that S∪R+(S) ⊂A∪R+(A). Assume towards
contradiction that β(S) is not semi-stable. Then there is S2 ⊆A2 such that a)
S2∪R+
2 (S2) ⊃β(S)∪R+
2 (β(S)). By β being a bisimulation (”forth”), we have b)
β(R+(S)) ⊆R+
2 (β(S)) and also (”back”) that c) β−(R+
2 (S2)) ⊆R+(β−(S2)).
We will show that β−(S2 ∪R+
2 (S2)) = β−(S2) ∪β−(R+
2 (S2)) ⊃S ∪R+(S),
which is a contradiction since it allows us to conclude, by applying c), that
β−(S2) ∪R+(β−(S2)) ⊃S ∪R+(S). We show inclusion ﬁrst.
β−(S2 ∪R+
2 (S2))
a)
%&'(
⊇β−(β(S) ∪R+
2 (β(S)))
= β−(β(S)) ∪β−(R+
2 (β(S)))
b)
%&'(
⊇β−(β(S)) ∪β−(β(R+(S)))
⊇S ∪R+(S)
To show that the inclusion is strict, consider x2 ∈(S2 ∪R+
2 (S2)) \ (β(S) ∪
R+
2 (β(S)). For arbitrary x ∈β−(x2), observe ﬁrst that since x2 ̸∈β(S), we have

108
S.K. Dyrkolbotn
x ̸∈S. We also have x2 ̸∈R+
2 (β(S)) and from b) it follows that x2 ̸∈β(R+(S)).
Then we conclude that x ̸∈R+(S).
□
Interestingly, a bisimulation that preserves and reﬂects admissible sets might not
preserve complete sets, as shown by the frameworks F and F2 below. Here, we
have the bisimulation β = {(a, a), (e, a), (b, b), (d, b), (f, b), (c, c)} which also pre-
serves and reﬂects with respect to the admissible semantics. We notice, however,
that {a} is a complete set in F while β(a) = {a} is not complete in F2 since d is
defended by {a}.
F :
F2 :
d
 e
 f


a

 b

 c
a
 b

 c
The main theorem now follows, stating that fc-bisimulations are ϵ-relations with
respect to all ϵ ∈S. We remark that it is suﬃcient to show that fc-bisimulations
preserve and reﬂect admissible and complete sets, from which it follows by The-
orem 5.2 that they also preserve and reﬂect preferred, stable and semi-stable
sets.
Theorem 5.3. Given frameworks F and F2, if there is an fc-bisimulation β ⊆
A × A2, then F ≡ϵ F2 for all ϵ ∈{s, a, p, ss, c}
Proof. Admissible: Let β ⊆A × A2 be an arbitrary fc-bisimulation. We show
that β preserves admissible sets. Then, by symmetry, β also reﬂects them, since
the inverse of β, β−⊆A2 × A is clearly also an fc-bisimulation. Let E ⊆A be
an admissible set in F and consider E2 = β(E). If x2 ∈R−
2 (y2) for y2 ∈E2, then
there is y ∈E such that y2 ∈β(y), and by β being a bisimulation (”back”), there
is some x ∈R−(y) such that x2 ∈β(x). Since E defends itself, it follows that
there is z ∈R−(x)∩E. Then, by β being a bisimulation (”forth”), it follows that
there is some z2 ∈R−
2 (x2) such that z2 ∈β(z), meaning z2 ∈E2. This shows
that E2 ⊆D(E2). To show that E2 is conﬂict free, assume towards contradiction
that there is x2, b′ ∈E2 with x2 ∈R−
2 (b′). Then, by deﬁnition of E2, there is
x, b ∈E with x2 ∈β(x) and b′ ∈β(b). Also, we know that x ̸∈R−(b) since E is
conﬂict-free. But by β being a bisimulation (”back”), there must be z ∈R−(b)
such that x2 ∈β(z). Since E is conﬂict-free, we know that z ∈R−(E) ⊆A \ E
Now we have x2 ∈E2 ∩β(x) ∩β(z) such that z attacks E, and this is the ﬁrst
step towards showing that there exists an inﬁnite backwards walk λ = y1y2y3 . . .
in A2 such that for all i ≥1, we have |β−(yi)| ≥2. This will contradict the
assumption that β is an fc-bisimulation (”global forth”). We take y1 = x2 and let
w1 = x, v1 = z. Then for all i ≥2, we deﬁne yi, wi, vi inductively, assuming that
yi−1, wi−1, vi−1 have been deﬁned such that wi−1 ∈E, vi−1 ∈R−(E) ⊆A \ E
and yi−1 ∈β(wi−1) ∩β(vi−1). The construction is visualized below.

The Same, Similar, or Just Completely Diﬀerent?
109








	
	
	
Since E defends itself against all attacks, we can ﬁnd wi ∈E ∩R−(vi−1). Since
we have yi−1 ∈β(vi−1) it follows by β being a bisimulation (”forth”) that we
can ﬁnd yi ∈β(wi) ∩R−(yi−1). But we also have yi−1 ∈β(wi−1), so by β be-
ing a bisimulation (”back”), we ﬁnd vi ∈β−(yi) ∩R−(wi−1). Since wi−1 ∈E
and E is conﬂict-free, it follows that vi ∈R−(E) ⊆A \ E. So yi, wi, vi can
be found for all i ∈N, proving existence of λ that contradicts ”global forth”.
Complete: We know that β preserves and reﬂects admissible sets, and now we
assume that S ⊆A is complete. Consider arbitrary x2 ∈A2\(β(S)∪R+
2 (β(S))).
By β being a bisimulation (”forth”), we get β−(x2) ∩R+(S) = ∅, which implies
β−(x2) ⊆A\(S∪R+(S)). Then, since S is complete, there is y ∈A\(S∪R+(S))
such that y ∈R−(β−(x2)). Then, since β is a bisimulation (”forth”), it fol-
lows that there is y2 ∈β(y) ∩R−
2 (x2). Since x2 ̸∈R+
2 (β(S)) it follows that
y2 ̸∈β(S). Assume towards contradiction that y2 ∈R+
2 (z2) for some z2 ∈β(S).
Then there is z ∈S ∩β−(z2) and also, since β is a bisimulation (”back”),
there is z′ ∈R−(y) ∩β−(z2). Since y ̸∈R+(S), z′ ̸∈S. Since β is a bisimula-
tion (”forth”) and z2 ∈β(S) and β(S) is conﬂict-free, z′ ̸∈R+(S). It follows
that z′ ∈A \ (S ∪R+(S)). To contradict global forth, we prove existence of
a backwards inﬁnite walk λ = x1x2x3 . . . in F2 such that for all i ≥1 we
have |β−(xi)| ≥2. We take x1 = z2, v1 = z′, w1 = z and for all i ≥2,
we assume that we have xi−1, vi−1, wi−1 with xi−1 ∈β(S) ∪R+
2 (β(S)) and
wi−1 ∈(S ∪R+(S))∩β−(xi−1), vi−1 ∈(A\ (S ∪R+(S)))∩β−(xi−1). There are
two cases. I) xi−1 ∈β(S). Then since β(S) is admissible and wi−1 ∈β−(xi−1),
we have wi−1 ̸∈R+(S) by β being a bisimulation (”forth”). Since S is complete,
we ﬁnd vi ∈R−(vi−1)∩(A\(S∪R+(S))). Since β is a bisimulation (”forth”), we
ﬁnd xi ∈R−
2 (xi−1) ∩β(vi), and since β(S) is admissible, xi ∈R+
2 (β(S)). Then,
going back, we ﬁnd wi ∈β−(xi)∩R−(wi−1), and since wi−1 ∈S and S is admis-
sible, wi ∈R+(S). II) xi−1 ∈R+
2 (β(S)). Since wi−1 ∈β−(xi−1) ∩(S ∪R+(S))
and β(S) is admissible, we have wi−1 ∈R+(S). We choose wi ∈S ∩R−(wi−1).
By β being a bisimulation (”forth”), we ﬁnd xi ∈β(wi)∩R−
2 (xi−1) and (”back”)
vi ∈β−(xi) ∩R−(vi−1). Since vi−1 ̸∈R+(S), vi ̸∈S. Also, by β being a bisim-
ulation (”forth”) and xi ∈β(vi) ∩β(S) and β(S) being conﬂict-free, we have
vi ̸∈R+(S). Having established the claim for ϵ ∈{a, c}, the claim follows by
Theorem 5.2 for all ϵ ∈{a, c, p, ss, s}.
□

110
S.K. Dyrkolbotn
References
1. Arieli, O., Caminada, M.W.A.: A QBF-based formalization of abstract argumen-
tation semantics. Journal of Applied Logic 11(2), 229–252 (2013)
2. Baroni, P., Giacomin, M.: Solving semantic problems with odd-length cycles in ar-
gumentation. In: Nielsen, T.D., Zhang, N.L. (eds.) ECSQARU 2003. LNCS (LNAI),
vol. 2711, pp. 440–451. Springer, Heidelberg (2003)
3. Baumann, R.: Normal and strong expansion equivalence for argumentation frame-
works. Artif. Intell. 193, 18–44 (2012)
4. Baumann, R.: What does it take to enforce an argument? Minimal change in ab-
stract argumentation. In: De Raedt, L., Bessi`ere, C., Dubois, D., Doherty, P., Fras-
coni, P., Heintz, F., Lucas, P.J.F. (eds.) ECAI. Frontiers in Artiﬁcial Intelligence
and Applications, vol. 242, pp. 127–132. IOS Press (2012)
5. B´eziau, J.-Y.: A sequent calculus for Lukasiewicz’s three-valued logic based on
Suszko’s bivalent semantics. Bulletin of the Section of Logic 28(2), 89–97 (1998)
6. Caminada, M.W.A.: Comparing two unique extension semantics for formal argu-
mentation: Ideal and eager. In: BNAIC 2007, pp. 81–87 (2007)
7. Caminada, M.W.A., Amgoud, L.: On the evaluation of argumentation formalisms.
Artiﬁcial Intelligence 171(56), 286–310 (2007)
8. Caminada, M.W.A., Gabbay, D.M.: A logical account of formal argumentation.
Studia Logica 93(2-3), 109–145 (2009)
9. Caminada, M.W.A.: Semi-stable semantics. In: Proceedings of the 2006 Conference
on Computational Models of Argument: Proceedings of COMMA 2006, pp. 121–
130. IOS Press, Amsterdam (2006)
10. Bench Capon, T.J.M., Dunne, P.E.: Argumentation in artiﬁcial intelligence. Artif.
Intell. 171(10-15), 619–641 (2007)
11. Dung, P.M.: On the acceptability of arguments and its fundamental role in non-
monotonic reasoning, logic programming and n-person games. Artiﬁcial Intelli-
gence 77, 321–357 (1995)
12. Dung, P.M., Mancarella, P., Toni, F.: Computing ideal sceptical argumentation.
Artiﬁcial Intelligence 171(1015), 642–674 (2007)
13. Dyrkolbotn, S.: Doing argumentation using theories in graph normal form. In:
Rendsvig, R.K. (ed.) ESSLLI 2012 Student Session Proceedings (2012)
14. Dyrkolbotn, S., Walicki, M.: Propositional discourse logic. Synthese (to appear)
15. Grossi, D.: Argumentation in the view of modal logic. In: McBurney, P., Rah-
wan, I., Parsons, S. (eds.) ArgMAS 2010. LNCS, vol. 6614, pp. 190–208. Springer,
Heidelberg (2011)
16. Grossi, D.: On the logic of argumentation theory. In: van der Hoek, W., Kaminka,
G.A., Lesp´erance, Y., Luck, M., Sen, S. (eds.) AAMAS, pp. 409–416. IFAAMAS
(2010)
17. Grossi, D., Gabbay, D.: When are two arguments the same? Invariance in abstract
argumentation. Technical Report 4, University of Liverpool (2012)
18. Oikarinen, E., Woltran, S.: Characterizing strong equivalence for argumentation
frameworks. Artiﬁcial Intelligence 175(14-15), 1985–2009 (2011)
19. Verheij, B.: Two approaches to dialectical argumentation: Admissible sets and ar-
gumentation stages. In: Proceedings of the Biannual International Conference on
Formal and Applied Practical Reasoning (FAPR) Workshop, pp. 357–368, Univer-
siteit (1996)
20. Wu, Y., Caminada, M.W.A., Gabbay, D.M.: Complete extensions in argumentation
coincide with 3-valued stable models in logic programming. Studia Logica 93(2-3),
383–403 (2009)

Boolean Dependence Logic
and Partially-Ordered Connectives
Johannes Ebbing1, Lauri Hella2, Peter Lohmann1, and Jonni Virtema2
1 Leibniz University Hannover, Theoretical Computer Science, Germany
{ebbing,lohmann}@thi.uni-hannover.de
2 University of Tampere, Mathematics, School of Information Sciences, Finland
{lauri.hella,jonni.virtema}@uta.fi
Abstract. We introduce a new variant of dependence logic (D) called
Boolean dependence logic (BD). In BD dependence atoms are of the
type
 x1, . . . , xn, α, where α is a Boolean variable. Intuitively, with
Boolean dependence atoms one can express quantiﬁcation of relations,
while standard dependence atoms express quantiﬁcation over functions.
We compare the expressive power of BD to D and ﬁrst-order logic
enriched by partially-ordered connectives, FO
POC
. We show that the
expressive power of BD and D coincide. We deﬁne natural syntactic
fragments of BD and show that they coincide with the corresponding
fragments of FO
POC
 with respect to expressive power. We then show
that the fragments form a strict hierarchy.
Keywords: Dependence Logic, Partially-Ordered Connectives, Expres-
sivity, Existential Second-Order Logic.
1
Introduction
Dependence is an important concept in many scientiﬁc disciplines. A multitude
of logical formalims have been designed to model dependences, for example, in
database theory, social choice theory and quantum mechanics.
Dependences between variables in formulae is the most direct way to model
dependences in logical systems. In ﬁrst-order logic the order in which quantiﬁers
are written determines dependence relations between variables. For example,
when using game theoretic semantics to evaluate the formula
 x0
x1
 x2
x3 ϕ,
the choice for x1 depends on the value for x0, and the choice for x3 depends
on the value of both universally quantiﬁed variables x0 and x2. The ﬁrst to
consider more complex dependences between variables was Henkin [8] with his
partially-ordered quantiﬁers (1).
  x0
x1
 x2
x3

ϕ
1 
  x
α
 y
β

ϕ
2 
  x

b1
 0,1
 y

b2
 0,1

γ
3 
L. Libkin, U. Kohlenbach, and R. de Queiroz (Eds.): WoLLIC 2013, LNCS 8071, pp. 111–125, 2013.
c
⃝Springer-Verlag Berlin Heidelberg 2013

112
J. Ebbing et al.
In (1) x1 depends only on x0 and x3 depends only on x2. Enderton [6] and
Walkoe [17] observed that exactly the properties deﬁnable in existential second-
order logic (ESO) can be expressed with partially-ordered quantiﬁers. Building
on the ideas of Henkin, Blass and Gurevich introduced in [3] the narrow Henkin
quantiﬁer (2). In (2) the value of the Boolean variable α1 depends on value of the
ﬁrst-order and Boolean variables in the tuple x, while the value of α2 depends on
the value of the tuple y. The idea of Blass and Gurevich was further developed by
Sandu and Väänänen in [13] where they introduced partially-ordered connectives
(3); here γ is a tuple
γ00, γ01, γ10, γ11
 of formulae. In this paper we adopt the
approach based on Boolean variables from [3] for our deﬁnition of partially-
ordered connectives. Hence in this paper, a partially ordered connective is as in
(2) with the exception that x and y are not allowed to contain Boolean variables.
However the expressive power of partially-ordered connectives deﬁned here and
in [13] coincide. For recent work on partially-ordered connectives see e.g. [7,15].
The ﬁrst to linearize the idea behind the syntax of partially-ordered quan-
tiﬁers were Hintikka and Sandu [9,10], who introduced independence-friendly
logic (IF). IF-logic extends FO in terms of so-called slashed quantiﬁers. De-
pendence logic (D), introduced by V¨a¨an¨anen [16], was inspired by IF-logic, but
the approach of V¨a¨an¨anen provided a fresh perspective on quantiﬁer dependence.
In dependence logic the dependence relations between variables are written in
terms of novel atomic dependence formulae. For example, the partially-ordered
quantiﬁer (1) can be expressed in dependence logic as follows
 x0
x1
 x2
x3
x2, x3

 ϕ.
The atomic formula

x2, x3
 has the explicit meaning that x3 is completely
determined by x2 and nothing else.
In recent years, research related to dependence logic has been intense. A vari-
ety of closely related logics have been deﬁned and various applications suggested,
see e.g. [1,4,5,11,12,14].
In this paper we introduce a new variant of dependence logic called Boolean
dependence logic (BD). In BD dependence atoms are of the type

x1, . . . , xn, α,
where α is a Boolean variable. Boolean dependence atoms provide a direct way
to express partially-ordered connectives in the same way as dependence atoms
express partially-ordered quantiﬁers. The partially-ordered connective (2) can
be expressed in Boolean dependence logic as follows
 x α y
β
y, β

 ϕ.
Intuitively, with Boolean dependence atoms one can express quantiﬁcation of re-
lations, while standard dependence atoms
x1, . . . , xn, y
 express quantiﬁcation
over functions. Since in second-order logic it is clear that functions and relations
are interdeﬁnable, the question arises whether there is any signiﬁcant diﬀerence
between D and BD. We show that in terms of expressive power there is no diﬀer-
ence. On the other hand, in BD one can deﬁne directly natural fragments that
correspond to logics with partially-ordered connectives.
Our results can be seen as a contribution to the analysis of fragments of ESO.
In particular we are able to separate natural fragments of ESO. We also give new

Boolean Dependence Logic
113
insight concerning interdeﬁnability of functions and relations in the framework
of dependence logic.
The structure of the paper is as follows. In Section 2 we deﬁne Boolean de-
pendence logic, BD, and its fragments BBD, RBD and
 -BD. In addition we
deﬁne the extension of ﬁrst-order logic with all partially-ordered connectives,
FO
POC
, and its fragments FO
POC

, POC
FO
 and POC
QF
. In Section
3 we prove a normal form for BBD and using this normal form show that the ex-
pressive power of BBD, RBD and
 -BD coincide with FO
POC

, POC
FO

and POC
QF
, respectively. In Section 4 we show that BD, BBD, RBD and
 -BD form a strict hierarchy with respect to expressive power.
2
Preliminaries
2.1
Boolean Dependence Logic
Boolean dependence logic BD is a variant of dependence logic where the conse-
quents of dependence atoms are Boolean variables instead of ﬁrst-order variables.
We use α, β, . . . to denote Boolean variables and x, y, . . . to denote ﬁrst-order
variables. Tuples of variables are denoted by x, y and α, β, respectively.
Deﬁnition 1. Let τ be a relational vocabulary. The logics D
τ
 and BD
τ
 are
deﬁned by the following grammars. The rules common to both D and BD are
ϕ ::
 x1
 x2
	

 x1
 x2
	 R
x 
	

R
x
	
ϕ
 ϕ
	
ϕ
 ϕ
	
 xϕ
	
xϕ.
The additional grammar rule for D is ϕ ::


x1, . . . , xn
, and the additional
grammar rules for BD are ϕ ::
 α
	

α
	
x1, . . . , xn, α
	
αϕ.
In order to deﬁne the semantics of D and BD we ﬁrst need to deﬁne the concept
of a team. Let A be a model with the domain A. Assignments over A are ﬁnite
functions that map ﬁrst-order variables to elements of A and Boolean variables
to elements of
,
. If s is an assignment, χ a Boolean or ﬁrst-order variable,
and a

,
 or a
 A, respectively, then saχ denotes the assignment (with
domain doms

χ) which agrees with s everywhere except that saχχ
 a.
Let A be a set and
x1, . . . , xn, α1, . . . , αm
 a ﬁnite (possibly empty) set of
variables. A team X of A with the domain domX


x1, . . . , xn, α1, . . . , αm

is any set of assignments from the variables
x1, . . . , xk, α1, . . . , αm
 into the
set A

,
. If X is a team of A, F : X
 A and G: X

,
, we use
X
F
x to denote the team
sF
sx
	 s
 X
, X
Gα to denote the team
sGsα
	 s
 X
 and X
Ax for the team
sax
	 s
 X and a
 A. For a
set W
 domX
 we call the function F W-determined iﬀfor all s, s

 X, with
sχ
 s

χ for all χ
 W, we have that F
s
 F
s

.
Deﬁnition 2. Let A be a model and X a team. The satisfaction relation A
	
X ϕ
is deﬁned as follows.
A
	
X ℓ

 s
 X : A, s
	
 ℓ, when ℓis a ﬁrst-order literal
A
	
X α

 s
 X : sα


A
	
X

α

 s
 X : sα


A
	
X ϕ
 ψ

A
	
X ϕ and A
	
X ψ

114
J. Ebbing et al.
A
	
X ϕ
 ψ

A
	
Y ϕ and A
	
Z ψ for some Y
 Z
 X
A
	
X
x, α

 s, s

 X : sx 
 s

x  implies sα
 s

α
A
	
X

x, y


 s, s

 X : sx 
 s

x  implies sy

 s

y

A
	
X
xψ

A
	
X
F
x  ψ for some F : X
 A
A
	
X
αψ

A
	
X
F
α ψ for some F : X

,

A
	
X
 xψ

A
	
X
Ax  ψ
Deﬁnition 3. Let ϕ
 BD. The set Frϕ of free variables of a formula ϕ is
deﬁned as for FO, except that we have the new cases
Fr α
 Fr 
α

α
Fr x, α

x, α
Fr αϕ
 Fr ϕ
α
If Fr ϕ

, we call ϕ a sentence. We say that the sentence ϕ is true in the
model A and write A
	
 ϕ, if A
	

	 ϕ holds.
Deﬁnition 4. Let V

xi1, . . . , xin
 where ij
 ij
1 for all j
 n. By
V, α
and
V, y
 we denote

xi1, . . . , xin, α and
xi1, . . . , xin, y
, respectively.
2.2
Partially-Ordered Connectives
According to the deﬁnition of Sandu and V¨a¨an¨anen [13], a partially-ordered
connective is an expression of the form
D











 x11 . . .
 x1n

b1
 0,1
...
...
...
 xm1 . . .
 xmn

bm
 0,1









	
that binds a tuple γ

ϕb
b 0,1m of formulae. Here it is assumed that all
the variables xij are distinct. We denote the set of all such partially ordered
connectives D by D. By FO
D we denote the extension of ﬁrst-order logic by
all partially-ordered connectives D
 D. Furthermore, by DFO
 and DQF
 we
denote the logics consisting of formulae of the form D
ϕb
b 0,1m, where D
 D
and ϕb are ﬁrst-order formulae or quantiﬁer free formulae, respectively.
We will deviate from the deﬁnitions of [13] in two ways: First, we will replace
the disjunctions

bi
 0,1 by existentially quantiﬁed Boolean variables
αi; this
makes it easier to relate logics with partially-ordered connectives to fragments
of BD. Second, in order to simplify the proofs in Section 3, we will relax the
restriction that the variables xij should be distinct, and that the tuples xi

xi1, . . . , xin
 should be of the same length.
Deﬁnition 5. Let xi

xi1, . . . , xini
, 1
 i
 m, be tuples of ﬁrst-order
variables, and let αi, 1
 i
 m, be distinct Boolean variables. Then
C










 x1
α1
...
...
 xm
αm








	
is a partially-ordered connective. The pattern of C is π

n1, . . . , nm, E
,
where E describes the identities between the variables in the tuples x1, . . . , xm:
E

i, j, k, l

	 1
 i, k
 m, 1
 j
 ni, 1
 l
 nk, xij
 xkl
. If C is a
partially-ordered connective with pattern π, we denote C by Nπ x1α1 . . . xmαm.

Boolean Dependence Logic
115
Deﬁnition 6. The logic FO
POC
 is deﬁned by the following grammar:
ϕ :: α
	

α
	 x1
 x2
	

x1
 x2
	 Rx
	

Rx
	
ϕ
 ϕ
	
ϕ
 ϕ
	
 xϕ
	
xϕ
	 Nπ x1α1 . . . xmαm ϕ
	

Nπ x1α1 . . . xmαm ϕ.
FO
POC

 is the fragment of FO
POC
 that allows only positive occurrences
of partially-ordered quantiﬁers. In other words, FO
POC

 is deﬁned by the
grammar above without the last rule

Nπ x1α1 . . . xmαm ϕ. The logic POC
FO

(POC
QF
) consists of all formulae of the form Nπ x1α1 . . . xmαm ϕ, where
ϕ
 FO (ϕ is a quantiﬁer free formula of FO).
The semantics of these logics is deﬁned in terms of models and assignments in the
usual way. The clause for a formula starting with a partially-ordered connective
C
 Nπ x1α1 . . . xmαm with pattern π

n1, . . . , nm, E
 is the following:
A, s
	
 C ϕ

there exist functions fi : Ani

,
, 1
 i
 m,
such that for all tuples ai
 Ani, 1
 i
 m :
if a1 . . . am is of pattern π, then A, s

	
 ϕ, where
s

 sa1
x1, . . . , am
xm, f1
a1
α1, . . . , fm
am
αm
.
Here “a1 . . . am is of pattern π” means that aij
 akl whenever
i, j, k, l

 E.
Note that s
 is well-deﬁned for all tuples a1 . . . am that are of pattern π.
It is straightforward to prove that the partially-ordered connectives Nπ deﬁned
here have the same expressive power as those deﬁned in [13].
A logic L
 is at least as expressive as L (L
 L
) iﬀfor all sentences ϕ
 L
there is a sentence ϕ

 L
 such that for all structures A it holds that A
	
 ϕ iﬀ
A
	
 ϕ
. We say L and L
 are equivalent (L
 L
) iﬀL
 L
 and L

 L.
Proposition 1. FO
POC

 FO
D. Moreover, POC
FO

 DFO
 and
POC
QF

 DQF
.
2.3
Fragments of BD
In this section we deﬁne fragments of BD that correspond to, with respect
to expressive power, the fragments FO
POC

, POC
FO
 and POC
QF
 of
FO
POC
.
Let ϕ be a BD-formula or a FO
POC
-formula, and and let ψ be a subformula
of ϕ. We deﬁne Vϕ
ψ
 to be the set of all ﬁrst-order variables χ such that there
exists a formula ϑ such that for some quantiﬁer Q, Qχθ is a subformula of ϕ and
ψ is a subformula of ϑ. In other words, Vϕ
ψ
 is the set of ﬁrst-order variables
χ that are quantiﬁed in ϕ and bound ψ.
Deﬁnition 7. We deﬁne the following sublogics of BD.
1. BBD is the restriction of BD to formulae ϕ such that for every subformula
xψ of ϕ and each occurrence of a dependence atom
x1, . . . , xn, α in ψ
it holds that Vϕ
ψ


x1, . . . , xn
.
2. RBD is the restriction of BD to formulae where no dependence atoms occur
inside the scope of an existential ﬁrst-order quantiﬁer.
3.
 -BD is the restriction of BD to formulae without existential quantiﬁcation
of ﬁrst-order variables.

116
J. Ebbing et al.
It is easy to see, that every
 -BD formula is an RBD formula, every RBD
formula is a BBD formula and every BBD formula is a BD formula.
Proposition 2.
 -BD
 RBD
 BBD
 BD
 D
Proof. The ﬁrst three inclusions follow by the observation made above. For the
last inclusion we show that for every BD-sentence ϕ there exists a D-sentence
ϕ
 such that for all structures A
A
	
 ϕ iﬀA
	
 ϕ
.
(4)
W.l.o.g. we can restrict our attension to models with at least two elements. Let
ϕ
 :

x

x

x

 x

 ϕ

, where ϕ
 is the sentence obtained from ϕ by
replacing every subformula of type
αiψ by
xαi

xαi
 x

 xαi
 x


 ψ

,
every atomic not negated Boolean variable αi by xαi
 x
, every atomic negated
Boolean variable

αi by xαi
 x

, and every BD dependence atom
x, αi
 by
the ﬁrst-order dependence atom

x, xαi
. Clearly (4) holds for any model A of
cardinality at least two.
3
Equivalences
In this section we prove a normal form for BBD. Using this normal form we
show that BBD
 FO
POC

, RBD
 POC
FO
 and
 -BD
 POC
QF
. In
addition we show that BD
 D.
Deﬁnition 8. A formula ϕ
 BD is in variable normal form if no variable in
Fr ϕ is quantiﬁed in ϕ, and if each variable is quantiﬁed at most once in ϕ.
Deﬁnition 9. A sentence ϕ
 BBD is in Q-normal form if ϕ is in variable
normal form and there exists a formula ϑ
 BBD such that the following holds.
1. ϕ

 x αϑ, for some (possibly empty) block of universal quantiﬁers
 x
followed by a (possibly empty) block of existential Boolean quantiﬁers
α.
2. Each quantiﬁer in ϑ occurs in some block of quantiﬁers
x y
α, where at
least x is non-empty.
In other words, a sentence ϕ is in Q-normal form if each quantiﬁer in ϕ is pulled
to the nearest existential ﬁrst-order quantiﬁer and then each universal ﬁrst-order
quantiﬁer is pulled past Boolean quantiﬁers.
Deﬁnition 10. A sentence ϕ
 BBD is in dependence normal form if ϕ is in
Q-normal form, and for every maximal non-empty block of Boolean existential
quantiﬁers
α in ϕ there exists a subformula
α



i I
xi, αi


 ψ

of ϕ
such that the Boolean variables αi, i
 I, are exactly the variables quantiﬁed in
α and every dependence atom in ψ is in scope of some quantiﬁer in ψ.
More informally, a sentence in Q-normal form is in dependence normal form if
there is one-to-one correspondence between Boolean existential quantiﬁers and
Boolean dependence atoms such that each quantiﬁer
α is immediately followed
by the corresponding dependence atom
x, α, and conversely each dependence
atom is directly preceded by the corresponding Boolean quantiﬁer.

Boolean Dependence Logic
117
Proposition 3 (Lemma A5 and Propositions A2 and A3 in the Ap-
pendix). Every sentence in BBD has an equivalent sentence in dependence
normal form.
Let ϕ
 BBD be a formula in dependence normal form. We say that a subfor-
mula ψ of ϕ is dependence maximal (with respect to ϕ) if it is either a maximal
subformula containing no dependence atoms, or it is of the form
y
 x α ϑ,
where
y
 xα is a maximal and non-empty block of quantiﬁers.
Theorem 1. BBD
 FO
POC


Proof. We will ﬁrst prove that BBD
 FO
POC

. Let ϕ be a BBD sentence
and A a model. By Proposition 3 we may assume that ϕ is in dependence normal
form. We translate ϕ into an equivalent FO
POC

 sentence ϕ
 by substitut-
ing each maximal block of quantiﬁers along with the corresponding dependence
atoms in ϕ by a partially-ordered connective.
More precisely, we deﬁne a translation ψ
 ψ
 for all subformulas ψ of ϕ
that are dependence maximal or Boolean combinations of dependence maximal
subformulas. The translation is deﬁned recursively as follows:
(i) If ψ is a maximal subformula without dependence atoms, then let ψ
 : ψ.
(ii) If ψ

y
 x α



1im
Vϕ
ψ


yxi
, αi


 ϑ

is dependence maxi-
mal, we deﬁne
ψ
 :
yNπ x0α0x1α1 . . . xmαm ϑ
,
(5)
where x0 are exactly those variables in x that are not in any xi, 1
 i
 m,
and α0 is a fresh Boolean variable not occurring in ϑ
.
(iii) If ψ
 ϑ
 η for


,
, then ψ

 ϑ

 η
.
Note that since ϕ is in dependence normal form, ϕ
 is deﬁned, and clearly
ϕ

 FO
POC

. Thus, it suﬃces to prove that ψ and ψ
 are equivalent for all
dependence maximal subformulas ψ of ϕ and their Boolean combinations: if A
is a model, and X is a team on A such that domX

 Vϕ
ψ
, then
A
	
X ψ
 A, s
	
 ψ
 for all s
 X.
The proof is done by induction on the deﬁnition of the translation.
(i) If ψ is without dependence atoms, the claim holds by [16, Cor. 3.32].
(ii) Assume that ψ

y η is dependence maximal, where
η

 x α



1im

Vϕ
η


xi
, αi


 ϑ

.
Then ψ


y Nπ x0α0x1α1 . . . xmαm ϑ
. We will show that for every team Y
A
	
Y η
 A, s
	
 Nπ x0α0x1α1 . . . xmαm ϑ
 for all s
 Y .
It is easy to see that the claim for ψ follows from this.
Let A be a model, and Y a team on A with domY

 Vϕ
η
. Now A
	
Y η
if and only if there are functions F1, . . . , Fm : Y
An
x 

,
, for n

	x	,
such that
A
	
Z


1im
Vϕ
η


xi
, αi


 ϑ, where Z
 Y
An
x, F
α.
(6)

118
J. Ebbing et al.
Assume that (6) is true. For each s
 Y , let f s
i : Ani

,
, 1
 i
 m, be the
functions such that f s
i
ai

 Fi
sa x, whenever ai
 Ani is the restriction of
a to the variables in xi. Note that f s
i is well-deﬁned, since by the ﬁrst conjunct
in (6), Fi is Vϕ
η


xi
-determined. Let f s
0
a0
 :
 for all a0
 An0.
If ai
 Ani are tuples such that a0a1 . . . am is of pattern π, then we see
that the assignment s
 : sa0
x0, . . . , am
xm, f s
1
a1
α1, . . . , f s
m
am
αm
 is
in Z. Since A
	
Z ϑ, by induction hypothesis we have A, s

	
 ϑ
. Since α0
does not occur in ϑ
, A, s

	
 ϑ
, where s

 s

α0
. Hence, the functions
f s
i , i
 m, are as required in the truth condition of Nπ, and we conclude that
A, s
	
 Nπ x0α0x1α1 . . . xmαm ϑ
 for all s
 Y .
Assume on the other hand that, for each s
 Y , f s
i : Ani

,
, i
 m,
are functions witnessing that A, s
	
 Nπ x0α0x1α1 . . . xmαm ϑ
. Then we deﬁne
F1, . . . , Fm : Y
An
x

,
 by setting Fi
sa x : f s
i
ai
, where ai
 Ani
is the restriction of a to the variables in xi. The functions Fi are then obviously
Vϕ
η


xi
-determined, whence A
	
Z

1im

Vϕ
η


xi
, αi
 for Z :
Y
An
x, F
α
. Furthermore, if s

 Z, then it is of the form
s

 sa0
x0, . . . , am
xm, f s
1
a1
α1, . . . , f s
m
am
αm
,
whence A, s

	
 ϑ
. Thus, by induction hypothesis, A
	
Z ϑ, and we conclude
that A
	
Y η.
(iii) The case ψ
 ϑ
 η for


,
, is trivial.
For the direction FO
POC


 BBD, assume that ϕ
 FO
POC

 is a
sentence; assume w.l.o.g that ϕ is in variable normal form. We deﬁne recursively
a translation ψ
 ψ
 for all subformulas ψ of ϕ as follows. If ψ is a literal,
we let ψ
 : ψ. Furthermore, we deﬁne
ϑ
 η

 : ϑ

 η
 for


,
,
xϑ
 :
xϑ
 and
 xϑ
 :
 xϑ
. Finally, if ψ
 Nπ x1α1 . . . xmαm ϑ, then
we deﬁne
ψ
 :
 x α1 . . .
αm



1im

Vϕ
ψ


xi
, αi


 ϑ


,
where x lists all variables in the tuples x1, . . . , xm.
It is now easy to prove by induction that for every subformula ψ of ϕ
A
	
X ψ

 A, s
	
 ψ for all s
 X
holds for all models A and teams X on A such that domX

 Vϕ
ψ
.
Corollary 1. RBD
 POC
FO
 and
 -BD
 POC
QF
.
Proof. The equivalences follow immediatelly from the proof of Theorem 1.
Theorem 2 (Theorem A1 in the Appendix). BD
 D
4
Separations
Lemma 1. Let A be a model, B a submodel of A and ϕ a
 -BD-sentence. If
A
	
 ϕ then B
	
 ϕ.
Proof. By Corollary 1,
 -BD
 POC
QF
, and by [7, Lemma 6] POC
QF
 is
equivalent with strict Σ1
1. For strict Σ1
1 the claim follows from [2, Lemma 1.2].

Boolean Dependence Logic
119
Proposition 4.
 -BD
 RBD
Proof. By Proposition 2,
 -BD
 RBD. Since by Lemma 1 the truth of a
 -BD-
sentence is preserved under submodels, it is enough to give an RBD-sentence
for which this does not hold. Clearly
xy x
 y is such a sentence.
Deﬁnition 11. Let L be a logic (or a fragment of a logic), τ a vocabulary and
A, B ﬁrst-order structures over τ. Then we write A ⇛L B if and only if the
implication A
	
 ϕ
 B
	
 ϕ holds for all sentences ϕ
 L.
Let Nπ
FOr
 denote the set of all sentences in POC
FO
 which are of the
form Nπx1α1 . . . xmαm ϕ, where ϕ is a ﬁrst-order formula with quantiﬁer rank
at most r. We will next deﬁne an Ehrenfeucht-Fra¨ıss´e game that captures the
truth preservation relation A ⇛Nπ
FOr
 B. This game is a straightforward modi-
ﬁcation of the corresponding game for DFO
 by Sevenster and Tulenheimo [15],
which in turn is based on the game for FO
D by Sandu and V¨a¨an¨anen [13].
Deﬁnition 12. Let A and B be ﬁrst-order structures over a vocabulary τ and
r
 0. The Nπ
FOr
-EF game NπEFr
A, B
 on A and B is played by two
players, Spoiler (S) and Duplicator (D), and it has two phases.
Phase 1:
– S chooses functions fi : Ani

,
, 1
 i
 m, where ni
 |xi|.
– D answers by choosing functions gi : Bni

,
, 1
 i
 m.
– S chooses tuples bi
 Bni, 1
 i
 m such that b1 . . . bm is of pattern π.
– D answers by choosing tuples ai
 Ani, 1
 i
 m such that a1 . . . am is
of pattern π, and fi
ai

 gi
bi
 for each 1
 i
 m. If there are no such
tuples a1, . . . , am, then D loses the play of the game.
Phase 2:
– S and D play the usual ﬁrst-order EF-game of r rounds on the structures
A, a1 . . . am
 and
B, b1 . . . bm
: In each round 1
 j
 r, S picks an ele-
ment cj
 A (or dj
 B), and D answer by choosing an element dj
 B (or
cj
 A, respectively).
D wins the play of the game if and only if the mapping a1 . . . amc1 . . . cr

b1 . . . bmd1 . . . dr is a partial isomorphism A
 B.
We show next that the game NπEFr can be used for studying the truth
preservation relation ⇛Nπ
FOr
.
Lemma 2 (Lemma A6 in the Appendix). Let A and B be ﬁrst-order struc-
tures over a vocabulary τ, π a pattern and r
 0. If D has a winning strategy in
the game NπEFr
A, B
, then A ⇛Nπ
FOr
 B.
Theorem 3. RBD
 BBD
Proof. We show that non-connectivity of graphs is deﬁnable in BBD, but not in
RBD. Note ﬁrst that a graph A

A, EA
 is not connected if and only if there

120
J. Ebbing et al.
is a subset U
 A such that U and AU are non-empty, and there are no edges
a, b 
 EA between U and AU. This can be expressed by the BBD-sentence
u v
 x y
αβ


x, α

y, β


x
 y

α
! β

x
 u
 α

x
 v


α

α


β


Exy


.
We use Lemma 2 to prove that non-connectivity is not deﬁnable in POC
FO
.
By Corollary 1, it then follows that non-connectivity is not deﬁnable in RBD.
Let us ﬁx the number of rounds r
 0, and the pattern π, and consider the game
NπEFr. Let A

A, EA
 and B

B, EB
 be the graphs such that
– B

u1, . . . , uk
, and A
 B

v1, . . . , vk
,
– EB

ui, uj

	
	i
" j
	
 1 

u1, uk
,
uk, u1
,
– EA
 EB

vi, vj

	
	i
" j
	
 1 

v1, vk
,
vk, v1
.
Thus, B is a cycle of length k, and A is the disjoint union of two cycles of length
k. In particular, A is not connected, but B is connected. We will now show that
if k is large enough, then D has a winning strategy in the game NπEFr
A, B
.
Let fi : Ani

,
, 1
 i
 m, be the ﬁrst move of S in the game. The
answer of D is then gi : Bni

,
, 1
 i
 m, where gi : fi
# B for
each 1
 i
 m. In the next move S picks tuples bi
 Bni, 1
 i
 m, such
that b1 . . . bm is of pattern π. Now D can simply answer by choosing the same
tuples: let ai
 bi for each 1
 i
 m. Clearly the requirement fi
ai

 gi
bi

is then satisﬁed. The game continues after this as the ﬁrst-order EF-game with
r rounds on the structures
A, a1 . . . am
 and
B, b1 . . . bm
. Since the mapping
a1 . . . am
 b1 . . . bm respects distances between nodes in the graphs A and B,
a standard argument shows that Duplicator has a winning strategy in the rest
of the game, provided that k is big enough.
Proposition 5. BBD
 BD, and moreover BD
$ FO
POC
.
Proof. In [7] is was proven that FO
D has 0-1 law, thus by Proposition 1 and
Theorem 1, neither BBD nor FO
POC
 can express even cardinality of the
domain. But by Theorem 2 and [16, Ch. 4.1] this property is deﬁnable in BD.
5
Conclusion
In this paper we deﬁne a new variant of dependence logic called Boolean depen-
dence logic. Boolean dependence logic is an extension of ﬁrst-order logic with
dependence atoms of the form

x, α, where x is a tuple of ﬁrst-order variables
and α is a Boolean variable. We also introduce a notational variant of partially-
ordered connectives based on the narrow Henkin quantiﬁers of [3]. We show that
the expressive power of Boolean dependence logic and dependence logic coincide.
We deﬁne natural syntactic fragments of Boolean dependence logic and prove
that the expressive power of these fragments coincide with corresponding logics
based on partially-ordered connectives. Finally we prove that the fragments of
Boolean dependence logic form a strict hierarchy in terms of expressive power.

Boolean Dependence Logic
121
References
1. Abramsky, S., V¨a¨an¨anen, J.: From IF to BI. Synthese 167(2) (2009)
2. Barwise, J.: Applications of Strict Π1
1 Predicates to Inﬁnitary Logic. J. Symb.
Log. 34(3) (1969)
3. Blass, A., Gurevich, Y.: Henkin quantiﬁers and complete problems. Annals of Pure
and Applied Logic 32 (1986)
4. Durand, A., Kontinen, J.: Hierarchies in Dependence Logic. ACM Transactions on
Computational Logic 13(4) (2012)
5. Gr¨adel, E., V¨a¨an¨anen, J.: Dependence and independence. Studia Logica (2013)
6. Enderton, H.B.: Finite partially-ordered quantiﬁers. Z. Math. Logik Grundlagen
Math. 16, 393–397 (1970)
7. Hella, L., Sevenster, M., Tulenheimo, T.: Partially Ordered Connectives and
Monadic Monotone Strict NP. J. of Logic, Lang. and Inf. 17(3) (2008)
8. Henkin, L.: Some remarks on inﬁnitely long formulas. In: Inﬁnitistic Methods
(Proc. Sympos. Foundations of Math., Warsaw, 1959). Pergamon, Oxford (1961)
9. Hintikka, J.: The principles of mathematics revisited. Cambridge Univ. Press
(1996)
10. Hintikka, J., Sandu, G.: Informational independence as a semantical phenomenon.
In: Logic, Methodology and Philosophy of Science, VIII (Moscow, 1987). Stud.
Logic Found. Math., vol. 126, pp. 571–589 (1989)
11. Kontinen, J., Kuusisto, A., Lohmann, P., Virtema, J.: Complexity of two-variable
Dependence Logic and IF-Logic. In: Proceedings of LICS 2011, pp. 289–298 (2011)
12. Lohmann, P., Vollmer, H.: Complexity results for modal dependence logic. In:
Dawar, A., Veith, H. (eds.) CSL 2010. LNCS, vol. 6247, pp. 411–425. Springer,
Heidelberg (2010)
13. Sandu, G., V¨a¨an¨anen, J.: Partially ordered connectives. Zeitschrift f¨ur Mathema-
tische Logik und Grundlagen der Mathematik 38 (1992)
14. Sevenster, M.: Model-theoretic and computational properties of modal dependence
logic. J. Log. Comput. 19(6), 1157–1173 (2009)
15. Sevenster, M., Tulenheimo, T.: Partially Ordered Connectives and
 11 on Finite
Models. In: Beckmann, A., Berger, U., L¨owe, B., Tucker, J.V. (eds.) CiE 2006.
LNCS, vol. 3988, pp. 516–525. Springer, Heidelberg (2006)
16. V¨a¨an¨anen, J.: Dependence logic: A new approach to independence friendly logic.
London Math. Soc. Stud. Texts, vol. 70 (2007)
17. Walkoe Jr., W.J.: Finite partially-ordered quantiﬁcation. J. Symbolic Logic 35,
535–555 (1970)
A
Appendix
Deﬁnition A1. Let ϕ and ψ be BD-formulae of vocabulary τ. We say that the
formulae ϕ and ψ are equivalent and write ϕ
 ψ if for all τ-models A and
teams X of A it holds that A, X
	
 ϕ iﬀA, X
	
 ψ.
Proposition A1 (Analogous to [16, Lemma 3.27]). Let ϕ be a BD-formula
of vocabulary τ, A a τ-model and X a team of A. If V
% Fr ϕ, then A, X
	
 ϕ
if and only if A,
X
# V

	
 ϕ.
Lemma A1 (Analogous to [16, Lemma 3.25]). Suppose that θ, ϕ0
x, α and
ϕ1
x, α are BD-formulae such that ϕ0
x, α
 ϕ1
x, α. Then θ
 θ
ϕ1
ϕ0
.

122
J. Ebbing et al.
Lemma A2. Let ϕ be a BD-formula and let x, α be the free variables of ϕ. Let
y, β, |y|
 |x|, |β|
 |α|, be tuples of variables that do not occur in ϕ. Let ϕ

be the formula obtained from ϕ by replacing each free occurence of the variables
x, α by y, β. Let A be a model and X a team of A where domX


x, α. Let
X
 be the team consisting of the assignments s

y, β

 sx, α, s
 X.
Now A, X
	
 ϕ
 A, X

	
 ϕ
.
Lemma A3. Let ϕ, ϑ
 BD such that x, α
& Fr ϑ. The following hold.
1.
 xϕ
 ϑ

 xϕ
 ϑ.
2.
 xϕ
 ϑ

 xϕ
 ϑ.
3.
αϕ
 ϑ

αϕ
 ϑ.
4.
αϕ
 ϑ

αϕ
 ϑ.
Lemma A4. Let ϕ be a BD formula and ψ

α x βϑ a subformula of ϕ.
Then ϕ
 ϕ

 x αβ

Vϕ
ψ
, α
 ϑ

ψ

.
Lemma A5 (Follows from Lemmas A1 and A2.). Let ϕ be a BD (BBD)
formula of vocabulary τ. There exists a BD (BBD) formula ϕ
 in variable normal
form such that ϕ
 ϕ
.
Proposition A2. Every sentence in BBD has an equivalent sentence in Q-
normal form.
Proof. Let ϕ
 BBD. By Lemma A5 we can assume that ϕ is in variable normal
form. We will give an algorithm that transforms ϕ to an equivalent BBD formula
in Q-normal form.
We will ﬁrst transform ϕ to an equivalent BBD formula ϕ
 such that
ϕ

 Qξψ
(7)
where Qξ is a (possibly empty) vector of universal ﬁrst-order and existential
Boolean quantiﬁers. Furthermore in ψ every universal ﬁrst-order or existential
Boolean quantiﬁer Qχ occurs in a subformula θ of ψ such that θ
 Q
ηQχγ where
Q
η is a quantiﬁer and γ is a BBD formula. In order to obtain ϕ
 from ϕ we
use the equivalences from Lemma A3 repetitively substituting subformulae with
equivalent subformulae. More precisely there exists a natural number n
 N and
a tuple
ϕi
in of BBD formulae such that ϕ0
 ϕ and ϕn
 ϕ
. Furthermore
1. for each i
 n there exist subformulae θ, ψ1 and ψ2 of ϕi such that θ

Qχψ1

 ψ2 (or θ
 ψ1

Qχψ2
 ), where Qχ

 x,
α and


,
,
and ϕi1 is obtained from ϕi by substituting θ by Qχψ1
 ψ2
.
It is easy to see that for each BBD formula the substitution procedure described
in 1. terminates, i.e., there exists some n
 N such that there are no subformu-
lae of ϕn that can be substituted as described in 1. Clearly ϕn is in the form
described in (7). By induction it is easy to show, that since ϕ0 is in variable
normal form it follows that ϕi is in variable normal form for all i
 0. Hence
the assumptions on free variables needed for Lemma A3 hold for each ϕi. By
Lemmas A3 and A1 we conclude that for each i
 n the formulae ϕi and ϕi1
are equivalent. Hence the formulae ϕ0 and ϕn are equivalent.
We still need to transform the formula ϕ
 into an equivalent formula ϕ
 in Q-
normal form. In order to obtain ϕ
 from ϕ
 we use the equivalence from Lemma
A4 repetitively. More precisely there exists a natural number m
 N and a tuple

Boolean Dependence Logic
123
ϕ

i
im of BBD formulae such that ϕ

0
 ϕ
 and ϕ

m
 ϕ
. Furthermore
2. for each i
 m there exists subformulae θ and ψ of ϕ

i and a quantiﬁer
α
such that θ

α x βψ where
 x is a nonempty vector of universal ﬁrst-
order quantiﬁers and ψ does not start with a quantiﬁer, and ϕ

i1 is obtained
from ϕ

i by substituting θ by
 x αβ

Vϕ
 i
θ
, α
 ψ

.
By Lemmas A4 and A1 we conclude that for each i the formulae ϕ

i and ϕ

i1
are equivalent. It is easy to see that for each BBD formula the substitution
procedure described above terminates, i.e., there exists some m
 N such that
there are no subformulae of ϕ

m that can be substituted as descibed in 2. Now
clearly ϕ

m is in Q-normal form.
Proposition A3. Every sentence in BBD has an equivalent sentence in depen-
dence normal form.
Proof. Let ϕ
 BBD. By Proposition A2 we can assume that ϕ is in Q-normal
form. We will give an algorithm that transforms ϕ to an equivalent BBD formula
ϕ
 in dependence normal form. We show that there exists a tuple
ϕi
in, n
 N,
of equivalent BBD formulae in Q-normal form such that ϕ0
 ϕ, ϕn
 ϕ
.
Assume ϕi is not in dependence normal form. Assume ﬁrst that this is due to
the fact that there exists a dependence atom

x, α and subformulae ψ and θ
of ϕi such that θ

y
 z
β ψ, where
x, α is a subformula of ψ not bound
by any quantiﬁer in ψ that violates the condition of Deﬁnition 10. Let U denote
the set of variables that are in the vector x but not in the set Vϕi
 z
βψ
, and
let u be the variables from U in some order. Since ϕi is in BBD the formula

Vϕi
 z
β ψ

U, α and
x, α are equivalent. Therefore due to Lemma A1
we may assume that

x, α is
Vϕi
 z
β ψ

 U, α.
Let θ
 :
y
 z
 w
β
β



Vϕi
 z
β ψ

 W, β


 ψ


, where w is a tu-
ple of fresh distinct ﬁrst-order variables of the same length as u, W is the set
of variables in the tuple w, β
 is a fresh Boolean variable and ψ

 ψ
u

w
 α
 β


x, α. Notice that the formulae θ and θ
 are equivalent. To
see this, ﬁrst observe that since the variables w, β
 do not occur in ψ it is
easy to conclude by Proposition A1 that θ is equivalent to the formula γ :
y
 z
 w
β
β


Vϕi
 z
β ψ

 W, β


 ψ

.
We still need to show that γ is equivalent to θ
. The idea here is that w
and β
 are used to encode a partial function needed for the satisfaction of the
dependence atom
x, α in ψ. First notice that for each team X of A the
following two conditions are equivalent to A, X
	
 γ.
1. A, Y
	

Vϕi
 z
β ψ

 W, β


 ψ, for some team Y obtained from X by
evaluating the quantiﬁer preﬁx of γ.
2. A, Y

	


Vϕi
 z
β ψ

W, β


ψ, for every team Y
 that can be obtained
from Y (Y as above) by changing the values of β
 in any such way that Y

still satisﬁes

Vϕi
 z
β ψ

 W, β

.
Assume then that 1 holds. While there might be many strategies for A, Y to
satisfy ψ, i.e., there might be many diﬀerent ways to split the team on dis-
junctions, for each instance e of evaluating ψ on A, Y there is a team Ye such

124
J. Ebbing et al.
that A, Ye
	


Vϕi
 z
β ψ

 U, α is required to hold. Therefore there ex-
ists a partial function fe : A|Vϕi
z
β ψ
U|

0, 1  that maps the values of
the variables from Vϕi
 z
β ψ

 U to the value of α in the team Ye. Let
ge : A|Vϕi
z
β ψ
U|

0, 1  be a function such that fe
 ge and let Y ge be
the variant of Y where the values for β
 have been picked using the function ge.
It is quite easy to see that A, Y g
e
	
 w
 u
 α
 β
, where Y ge
e
is the team
obtained from Y ge analogously to Ye from Y . Therefore due to the equivalence
of 1 and 2, we conclude that A, X
	
 θ
.
Assume then that A, X
	
 θ
. Hence A, Y
	


Vϕi
 z
β ψ

 W, β


 ψ
,
for some team Y obtained from X by evaluating the quantiﬁer preﬁx of θ
.
Similarly as above, for each strategy e to evaluate ψ
 in A, Y there is a team
Ye such that A, Ye
	
 w
 u
 α
 β
 is required to hold. Since the variables
w, β
 do not occur in other subformulae of ψ
 than w
 u
 α
 β
, we
may assume w.l.o.g that for each assignment s
 Ye and a
 A|w| the modiﬁed
assignment s

 Y of s that maps w to a and β
 to 0 or 1 is also in Ye. Now
since A, Y
	

Vϕi
 z
β ψ

 W, β

 and Ye
 Y we conclude that A, Ye
	


Vϕi
 z
β ψ

 U, α and furthermore that A, X
	
 γ. Hence θ and θ
 are
equivalent.
Let ϕi1 be the formula obtained from ϕi by substituting θ with θ
. By the
above observation and Lemma A1 we conclude that ϕi and ϕi1 are equivalent.
Notice if ϕi is in Q-normal form, then ϕi1 is also in Q-normal form. It is easy to
see that for large enough k the formula ϕk does not have dependence atoms that
violate the condition in Deﬁnition 10. Hence if ϕk is not in dependence normal
form there exists a subformula
β
α ψ of ϕk such that there is no dependence
atom

x, β
 in ψ that is not bound by any quantiﬁer in ψ for any x. Let ϕk 1
denote the formula obtained from ϕk by substituting ψ by


Vϕk
ψ
, β

 ψ

.
Clearly ϕk and ϕk 1 are equivalent. It is easy to see that the procedure described
here terminates and ﬁnally produces an equivalent formula in dependence normal
form.
Theorem A1. BD
 D
Proof. BD
 D holds by Proposition 2. For the other direction we will give a
translation from D to BD. Let ϕ be an arbitrary D-sentence in the normal form
for D from [16, p. 98], i.e., ϕ :
 x
y


i I
xi, yi

 ψ

, where ψ is a
quantiﬁer-free ﬁrst-order formula and I a ﬁnite index set, and xi is a vector of
variables from x and yi a variable from y, for every i
 I. The translation ϕ
 of
ϕ is the BD-sentence
 x
y

ψ

 z
α

i I


xi, zi, αi


zi
 yi
! αi


,
where z and α are tuples of fresh variables of length |I| and zi and αi, i
 I, are
variables from the corresponding tuple. We will show that for every model A it
holds that A
	

	 ϕ iﬀA
	

	 ϕ
.
Assume ﬁrst that A
	

	 ϕ. Hence A
	
X

i I
xi, yi

 ψ for some
team X obtained from
 by evaluating the quantiﬁer preﬁx of ϕ. Now since
A
	
X

i I

xi, yi
 there exists, for every i
 I, a function Fi : A|xi|
 A that

Boolean Dependence Logic
125
maps the values of the variables xi to the value of the variable yi in the team X.
Let Y denote the team X
A|z|
z,
Hi
αi
i I
, where Hi : X
A|z|
z


,

is obtained from Fi in the obvious way
Hi
s



iﬀFi
sxi

 zi

iﬀFi
sxi

 zi.
Notice that A
	
Y

i I

xi, zi, αi


zi
 yi
! αi


. Hence we have that
A
	
X
 z
α

i I

xi, zi, αi


zi
 yi
! αi


. Therefore since A
	
X ψ,
and since X was obtained from
 by evaluating the quantiﬁer preﬁx
 x y,
we conclude that A
	

	 ϕ
.
Assume then that A
	

	 ϕ
. Hence A
	
X ψ

 z
α

i I

xi, zi, αi


zi
 yi
! αi


, for some team X that can be obtained from
 by evaluating
the quantiﬁer preﬁx of ϕ
. Furthermore A
	
Y

i I

xi, zi, αi


zi
 yi
!
αi


, for some team Y obtained from X by evaluating the quantiﬁers
 z
α. We
will show that for each i
 I it holds that A
	
X

xi, yi
. This together with
the fact that A
	
X ψ is enought to prove that A
	

	 ϕ.
Let s, t
 X be any two assignments such that sxi

 txi
. Clearly there
exist assignments s
, t

 Y such that s
 s

# dom
X
, t
 t

# dom
X
 and
s

zi

 syi

 t

zi
. Now since A
	
Y zi
 yi
! αi we have that s

αi

 1.
Furthermore since A
	
Y
xi, zi, αi
 we have that s

α
 t

α. Hence t

α

1 and furthermore t

yi

 t

zi
. Since tyi

 t

yi
 and s

zi

 syi
 and we
conclude that tyi

 syi
. Hence A
	
X

xi, yi
.
Lemma A6. Let A and B be τ-structures, π a pattern, and r
 0. If D has a
winning strategy in the game NπEFr
A, B
, then A ⇛Nπ
FOr
 B.
Proof. Assume that D has a winning strategy in the game NπEFr
A, B
. To
prove A ⇛Nπ
FOr
 B, assume that ψ
 Nπ x1α1 . . . xmαm ϑ is a sentence of
Nπ
FOr
 such that A
	
 ψ. Thus, there are functions fi : Ani

,
, 1

i
 m, such that for all ai
 Ani, if a1 . . . am is of pattern π, then A
	
sa,f
 ψ,
where sa, f
 denotes the assignment that maps xi to ai and αi to fi
ai
, for
1
 i
 m.
Let gi : Bni

,
, 1
 i
 m, be the answer given by the winning
strategy of D in the play where f1, . . . , fm is the ﬁrst move of S. It suﬃces to
show that B
	
sb,g
 ψ for all tuples b1 . . . bm of pattern π such that bi
 Bni for
each i. Thus, let bi
 Bni, 1
 i
 m, be arbitrary tuples such that b1 . . . bm is of
pattern π. Let a1, . . . , am
 An be the answer given by the winning strategy of D
when the second move of S is b1, . . . , bm. By the deﬁnition of the game NπEFr, D
has then a winning strategy in the ﬁrst-order EF game with r rounds between the
structures
A, a1, . . . , am
 and
B, b1, . . . , bm
. By the standard EF theorem, it
follows that
A, a1, . . . , am
 and
B, b1, . . . , bm
 satisfy the same FOr-sentences.
Note further that f1
a1

 g1
b1
 . . . , fm
am

 gm
bm
 by the condition gov-
erning the choice of b1, . . . , bm, whence
A, a1, . . . , am, f1
a1
, . . . , fm
am
 and
B, b1, . . . , bm, g1
b1
, . . . , gm
bm
 are also equivalent with respect to all sen-
tences of FOr extended with Boolean variables. In particular, since A
	
sa,f
 ψ,
we have B
	
sb,g
 ψ, as desired.

Extended Modal Dependence Logic EMDL⋆
Johannes Ebbing1, Lauri Hella2, Arne Meier1, Julian-Steﬀen M¨uller1,
Jonni Virtema2, and Heribert Vollmer1
1 Institut f¨ur Theoretische Informatik, Leibniz Universit¨at Hannover, Appelstr. 4,
30167 Hannover, Germany
{ebbing, meier,mueller,vollmer}@thi.uni-hannover.de
2 School of Information Sciences, University of Tampere, Kanslerinrinne 1 B,
33014 University of Tampere, Finland
{lauri.hella,jonni.virtema}@uta.fi
Abstract. In this paper we extend modal dependence logic MDL by
allowing dependence atoms of the form dep(ϕ1, . . . , ϕn) where ϕi, 1 ≤
i ≤n, are modal formulas (in MDL, only propositional variables are
allowed in dependence atoms). The reasoning behind this extension is
that it introduces a temporal component into modal dependence logic.
E.g., it allows us to express that truth of propositions in some world of
a Kripke structure depends only on a certain part of its past. We show
that EMDL strictly extends MDL, i.e., there exist EMDL-formulas
which are not expressible in MDL. However, from an algorithmic point
of view we do not have to pay for this since we prove that the complexity
of satisﬁability and model checking of EMDL and MDL coincide. In
addition we show that EMDL is equivalent to ML extended by a certain
propositional connective.
1
Introduction
Dependences between values of variables occur in many scientiﬁc disciplines.
For example in physics there are dependences in experimental data, in computer
science dependences are occurring in the execution of discrete systems and in so-
cial science they can occur between voting extrapolations. With the aim to ex-
press such dependences, V¨a¨an¨anen [11] extended ﬁrst-order logic by adding a new
kind of atomic formulas called dependence atoms. A dependence atom, denoted by
dep(x1, . . . , xn), intuitively states that the value of xn is solely determined by the
values of the variables x1, . . . , xn−1, i.e., xn depends functionally on x1, . . . , xn−1.
The extension of ﬁrst-order logic with dependence atoms iscalled dependence logic.
The idea behind the compositional semantics used for dependence logic, deﬁned us-
ing the concept of teams, i.e., sets of assignments was introduced by Hodges [5]; for
more details on dependence logic, see the monograph [11].
The study of modal depencence logic MDL was initiated by V¨a¨an¨anen in [12].
Modal dependence logic extends standard modal logic by modal dependence
atoms, dep(p1, . . . , pn). Teams in this context are sets of worlds of a Kripke
⋆This paper was supported by a grant from DAAD within the PPP programme under
project ID 50740539 and grant 138163 of the Academy of Finland.
L. Libkin, U. Kohlenbach, and R. de Queiroz (Eds.): WoLLIC 2013, LNCS 8071, pp. 126–137, 2013.
c
⃝Springer-Verlag Berlin Heidelberg 2013

Extended Modal Dependence Logic EMDL
127
structure, and the meaning of the formula dep(p1, . . . , pn) is that, in the worlds
of the current team, the value of the proposition pn is functionally determined
by the values of the propositions p1, . . . , pn−1.
Temporal logics have been studied widely in the ﬁeld of automatic system
veriﬁcation. Thus, the computational complexity of temporal logics, e.g., satis-
ﬁability and model checking is important. Following [2], the basic temporal logic
TL is a multi modal logic which contains two dually deﬁned accessibility re-
lations, RF looking into the future and RP looking into the past. Only Kripke
models are considered in which RF is the converse of RP ; these models are called
bidirectional models. In this logic we can express, e.g, that in one time step in
the past (⟨RP ⟩ϕ) or in the next future time step (⟨RF ⟩ϕ) some property ϕ holds
(other notations used for the modalities are ⟨P⟩, ⟨F⟩or ♦P , ♦F ; sometimes the
above formulas are succinctly written as Pϕ and Fϕ, see [2, p. 12].) The most
used temporal logics in the ﬁeld of veriﬁcation (computational tree logic CTL
introduced by Emerson and Clarke [3], linear temporal logics LTL introduced
by Sistla and Clarke [10], etc.) are extensions of the basic temporal logic TL.
In this way, MDL (generalized to multi-modal frames) can bee seen as a ﬁrst
step towards introducing functional dependences into the framework of tem-
poral logic. Sevenster [9] showed that the satisﬁability problem for MDL is
NEXPTIME-complete. A more detailed classiﬁcation over sublogics of MDL was
given by Lohmann and Vollmer [7]. Ebbing and Lohmann [4] studied the model
checking problem for MDL and showed that this problem is less complex than
the satisﬁability problem but is still NP-complete.
Though MDL can be seen as a ﬁrst step towards combining functional de-
pendences and temporal logic, it is clearly not suﬃcient for modelling temporal
aspects of dependence, since the only dependences that are allowed to occur are
dependences between propositional statements within the same world. In this
paper we introduce extended modal dependence logic, EMDL, to overcome this
defect. EMDL is obtained from MDL by extending the scope of dependence
atoms to arbitrary modal formulas, i.e., dependence atoms in EMDL are of the
form dep(ϕ1, . . . ϕn), where ϕ1, . . . , ϕn are ML formulas. In contrast to MDL,
in EMDL we can directly express dependences between events in time, thus
EMDL can be seen as the next logical step to combine functional dependences
with temporal reasoning. As an example, the formula
dep

⟨P⟩p, ⟨P⟩2p, . . . , ⟨P⟩np, p

expresses that the truth of p at this moment only depends on the truth of p in
the previous n time steps.
We will show that EMDL strictly extends MDL by giving an explicit EMDL-
formula that is not expressible in MDL (see Theorem 1). However we will prove
that ML extended with the classical disjunction  can express all EMDL-
formulas (Theorem 2). In fact, we will see that the expressive power of EMDL
coincides with that of ML extended by a restricted use of  (Corollary 1). We
will also show that, although EMDL is strictly more expressive than MDL, the
computational complexity of the satisﬁability and the model checking problems
for MDL and EMDL coincide (Theorems 4 and 5).

128
J. Ebbing et al.
2
Preliminaries
Complexity Theory. In this paper, we make use of the complexity classes
NEXPTIME and NP. Informally speaking NEXPTIME is the class of problems
that can be solved by a nondeterministic turing machine in exponential time.
Similar to this, NP is a class of problems that can be computed by such a turing
machine in polynomial time. For further information we refer to [8].
Modal Dependence Logics. Extended modal dependence logic, EMDL, is ob-
tained from usual modal logic ML by adding dependence atoms dep(ϕ1, . . . , ϕn).
As in MDL, the dependence atom dep(ϕ1, . . . , ϕn) intuitively states, that the
truth value of ϕn is solely determined by the truth values of ϕ1, . . . , ϕn−1. The
diﬀerence between EMDL and MDL is that in MDL the formulas ϕ1, . . . , ϕn in
dependence atoms are required to be atomic propositions, while EMDL allows
arbitrary ML-formulas in dependence atoms.
Before deﬁning EMDL, let us ﬁrst introduce the syntax of usual modal logic
ML and its extension by classical disjunction .
Deﬁnition 1 (Syntax of ML, ML() and ML(ML)). Let Φ be a set of
atomic propositions, and let I be an index set of modal operators. The syntax of
ML is deﬁned by the following grammar
ϕ ::= p | ¬p | (ϕ ∧ϕ) | (ϕ ∨ϕ) | ♦jϕ | □jϕ,
where p ∈Φ and j ∈I.
The syntax of ML() is obtained by extending the syntax of ML by the
grammar rule
ϕ ::= (ϕ  ϕ).
We denote by ML(ML) the fragment of ML() where the rule (ϕ  ϕ) is
allowed only when the ϕ are ML-formulas.
Next we deﬁne MDL which is the syntactical extension of ML by dependence
atoms of the type dep(p1, . . . , pn).
Deﬁnition 2 (Syntax of MDL). The syntax for MDL is obtained by extend-
ing the syntax of ML by dependence atoms
ϕ ::= dep(p1, . . . , pn) ,
where p1, . . . , pn ∈Φ. As in Deﬁnition 1, Φ is a set of atomic propositions.
Now, we introduce EMDL, which is the syntactical extension of MDL that
allows arbitrary ML-formulas inside dependence atoms instead of only atomic
propositions.
Deﬁnition 3 (Syntax of EMDL). The syntax for EMDL is obtained by ex-
tending the syntax of ML by extended dependence atoms
ϕ ::= dep(ϕ1, . . . , ϕn) ,
where ϕ1, . . . , ϕn are ML formulas.

Extended Modal Dependence Logic EMDL
129
If ϕ is a formula in some logic, then SF(ϕ) is the set of all of its subformulas.
The syntactic inclusion structure of the logics deﬁned here is described in
Figure 1 (a).
(a)
EMDL
MDL
ML
ML(ML)
ML()
(b)
ML
MDL
ML(ML) = EMDL
ML()
Fig. 1. (a) Syntactical inclusion structure, (b) Expressiveness inclusion structure
Similar as for ML formulas we evaluate EMDL formulas on Kripke struc-
tures. We will use multimodal Kripke structure here, i.e., Kripke structures with
(possibly) several diﬀerent accessibility relations. As explained in the introduc-
tion, this is useful in modelling temporal behavior of systems; see also Example 2.
Deﬁnition 4 (Kripke structure). Let Φ be a set of atomic propositions. A
Kripke structure (or frame) K over Φ is a tuple K = (W, R, V ), where W is a
set of worlds, R = {R1, . . . , Rℓ} is a set of diﬀerent accessibility relations, and
V is the labeling function V : W →P(Φ).
Note that in contrast to usual modal logic, EMDL formulas are interpreted
over a set of worlds (or a team) T ⊆W. We write K, T |= ϕ if the formula ϕ
is satisﬁed by the team T in the Kripke structure K. We also make use of the
shorthand notation K, s |= ϕ for K, {s} |= ϕ.
Deﬁnition 5 (Semantics of ML, MDL, and EMDL). Let K = (W, R, V )
be a Kripke model with R = {R1, . . . , Rℓ}, T ⊆W be a team, and ϕ, ψ ∈EMDL,
ψ1, . . . , ψn be ML formulas. Then
K, T |= p
iﬀfor all w ∈T : p ∈V (w),
K, T |= ¬p
iﬀfor all w ∈T : p /∈V (w),
K, T |= ϕ ∨ψ
iﬀK, T1 |= ϕ and K, T2 |= ψ for some T1, T2 ⊆T
such that T1 ∪T2 = T ,
K, T |= ϕ  ψ
iﬀK, T |= ϕ or K, T |= ψ,
K, T |= ϕ ∧ψ
iﬀK, T |= ϕ and K, T |= ψ,

130
J. Ebbing et al.
K, T |= ♦iϕ
iﬀK, T ′ |= ϕ for some T ′ ⊆W s.t. for every w ∈T
there exists a w′ ∈T ′ with wRiw′,
K, T |= □iϕ
iﬀK, T ′ |= ϕ for T ′ := {w′ | w ∈T ∧wRiw′},
K, T |= dep(ψ1, . . . , ψn) iﬀ∀w1, w2 ∈T : n−1
i=1 (K, {w1} |= ψi ⇔K, {w2} |= ψi)
implies (K, {w1} |= ψn ⇔K, {w2} |= ψn)
For convenience reasons we will omit the index i at ♦or □if it is clear in the
context or if we only use one single type of transition relation.
Note that dep(ψ) is a special case of dependence atom. By the last clause of
Deﬁnition 5, K, T |= dep(ψ) iﬀthe truth value of ψ is constant in the team T ,
i.e., either K, {w} |= ψ for every w ∈T , or K, {w} ̸|= ψ for every w ∈T .
Satisﬁability and Model Checking. We investigate two diﬀerent compu-
tational problems: Satisﬁability and model checking. In the satisﬁability prob-
lem, we are given an arbitrary EMDL formula. The problem is then to decide,
whether there exist a Kripke structure and a team satisfying the formula. For
the model checking problem the input is an EMDL formula, a Kripke structure
and a team on which the formula is evaluated. The problem is to decide, whether
the given structure satisﬁes the formula w.r.t. the given team.
Deﬁnition 6 (EMDL-SAT). The satisﬁability problem for EMDL is the de-
cision problem over the set
EMDL-SAT :=
⎧
⎨
⎩⟨ϕ⟩
,,,,,,
ϕ ∈EMDL and there exists a Kripke struc-
ture K = (W, R, V ), and a team T ⊆W, s.t.
K, T |= ϕ
⎫
⎬
⎭.
Deﬁnition 7 (EMDL-MC). The model checking problem for EMDL is the
decision problem over the set
EMDL-MC :=

⟨K, T, ϕ⟩
,,,,
ϕ ∈EMDL, K = (W, R, V ) is a ﬁnite Kripke
structure, and T ⊆W, s.t. K, T |= ϕ
0
.
Besides determining the computational complexity of the above two decision
problems, the second contribution of our paper is a study the expressivity of
EMDL. To make this precise, we give the following deﬁnition.
Deﬁnition 8. Let L be one of the above logics. We say that a formula ϕ is
expressible in L if there exists an L-formula ψ such that ψ is logically equivalent
to ϕ. For logics L and L′, we write L ≤L′ if every L-formula ϕ is expressible
in L′. Furthermore, we write L ≡L′ if L ≤L′ and L′ ≤L.
Example 1. (extending the motivating example given in the introduction) The
following formula expresses that some property ψ of a computation depends on
some outcome p when measuring two signals A and B on k measure points in
the past:
dep

♦measAp, ♦measBp, ♦2
measAp, ♦2
measBp, . . . , ♦k
measAp, ♦k
measBp, □compψ

.
Here ♦measA, ♦measB refers to the (past oriented) measure relations for signals A
and B, and □comp refers to the (future oriented) computation relation.

Extended Modal Dependence Logic EMDL
131
Example 2. Cellular automata are a model of computation that has a wide vari-
ety of applications ranging from computability theory to physics and theoretical
biology; see e.g. [1], [6]. Any two-dimensional cellular automaton with cell colors
drawn from a set Φ can be presented as a Kripke structure
K = (W, P, L, R, U, D, V )
over atomic propositions Φ, where
– W is a set of triples (t, i, j) of integers (t represents a time step, (i, j) a cell);
– P is the (past oriented) successor relation on the ﬁrst coordinate of W;
– L (R, U, D, resp.) are the the neighbor relations on the grid, i.e., the suc-
cessor relation to the left (right, up, down, resp.) on the pair given by the
second and third coordinate of W;
– V ((t, i, j)) ⊆Φ is the color of the cell (i, j) at time step t of the computation.
On the other hand, a Kripke structure of this form describes a cellular automaton
only if the color of a cell (i, j) at time t + 1 is completely determined by its own
color and the color of its neighbors at time t. In case where Φ = {q} and only
the immediate successors and predecessors are considered as neighbors, this can
be expressed by the following formula ϕCA of EMDL:
dep(⟨P⟩⟨L⟩q, ⟨P⟩⟨R⟩q, ⟨P⟩⟨U⟩q, ⟨P⟩⟨D⟩q, ⟨P⟩q, q) .
It is straightforward to modify the formula ϕCA for larger sets Φ of colors and
diﬀerent deﬁnitions of neighborhoods.
3
Expressivity of EMDL
In this section we prove the strict inclusion MDL < EMDL. We will also show
that EMDL ≤ML(). In fact, we will see that the expressive power of EMDL
and the fragment ML(ML) of ML() coincide. These results suggest that
indeed EMDL is a natural extension of MDL.
Proposition 1. Let K be a Kripke model, T be a team of K, and ϕ be an
ML-formula.
K, T |= ϕ iﬀK, {w} |= ϕ for all w ∈T.
Proof. Follows from [9, Theorem 1].
Theorem 1. dep(♦p) is not expressible in MDL.
Proof. Let Φ = {p} and K = (W, R, V ) be a Kripke model over Φ such that
W = {a, b}, R = {(b, b)} and V (a) = V (b) = {p}. We will deﬁne a translation
ϕ →ϕ∗from MDL-formulas to ML-formulas and show that on this model each
formula ϕ ∈MDL is equivalent to the ML formula ϕ∗. We deﬁne that
(ψ ∧θ)∗:= (ψ∗∧θ∗), (ψ ∨θ)∗:= (ψ∗∨θ∗), (□ψ)∗:= □ψ∗,
(♦ψ)∗:= ♦ψ∗, p∗:= p, (¬p)∗:= ¬p, dep(p, . . . , p)∗:= p.

132
J. Ebbing et al.
Note that since Φ = {p} each dependence atom in ϕ is of type dep(p, . . . , p), and
K, T |= dep(p, . . . , p) ,
for all T ⊆W. Hence it is a trivial inductive proof, that for all T ⊆W and
ϕ ∈MDL
K, T |= ϕ iﬀK, T |= ϕ∗.
(1)
We will now show that the EMDL-formula dep(♦p) is not expressible in MDL.
For contradiction, assume that there exists a MDL-formula ψ that is equivalent
to dep(♦p). Clearly K, {a} |= dep(♦p) and K, {b} |= dep(♦p). Hence K, {a} |= ψ
and K, {b} |= ψ. Therefore, by (1) K, {a} |= ψ∗and K, {b} |= ψ∗. Now since
ψ∗is an ML-formula by Proposition 1 we have that K, {a, b} |= ψ∗. Hence by
(1) we have that K, {a, b} |= ψ and ﬁnally that K, {a, b} |= dep(♦p). This is a
contradiction since clearly K, {a, b} ̸|= dep(♦p).
⊓⊔
We will next examine the expressivity of EMDL and show that it coincides with
that of ML(ML). We split the proof into two steps.
Theorem 2. EMDL ≤ML(ML).
Proof. We start by the observation of V¨a¨an¨anen [12, Section 8] that the basic
dependence atoms dep(p1, . . . , pn+1) are deﬁnable by using the classical disjunc-
tion . The deﬁnition given in [12] works for our extended dependence atoms
dep(ϕ1, . . . , ϕn, ϑ) as well. Let δ := δ(ϕ1, . . . , ϕn, ϑ) be the formula

b∈{⊥,⊤}n

ϕb1
1 ∧. . . ∧ϕbn
n ∧(ϑ  ϑ⊥)

,
(2)
where b = (b1, . . . , bn), and ϕ⊤:= ϕ and ϕ⊥is the formula obtained from
¬ϕ by pushing negations in front of atomic formulas. Now K, T |= δ if and
only if T can be divided into subteams Tb, b ∈{⊥, ⊤}n, such that Tb contains
exactly those states t that satisfy the formulas ϕbi for 1 ≤i ≤n. Moreover,
since K, Tb |= ϑ  ϑ⊥, the truth value of ϑ is constant in the team Tb for each
b ∈{⊥, ⊤}n. Clearly, this is equivalent with K, T |= dep(ϕ1, . . . , ϕn, ϑ).
Using the equivalence above as a starting point, we will now deﬁne a transla-
tion ϕ →ϕ∗from EMDL to ML(ML) as follows:
dep(ϕ1, . . . , ϕn, ϑ)∗:= δ(ϕ∗
1, . . . , ϕ∗
n, ϑ∗)
p∗:= p, (¬p)∗:= ¬p, (ψ ∧θ)∗:= (ψ∗∧θ∗)
(ψ ∨θ)∗:= (ψ∗∨θ∗), (□ψ)∗:= □ψ∗, (♦ψ)∗:= ♦ψ∗.
Note that ϕ∗= ϕ for every formula not containing dependence atoms. Thus,
δ(ϕ∗
1, . . . , ϕ∗
n, ϑ∗) is in ML(ML) for all ML-formulas ϕ1, . . . , ϕn, ϑ, and hence
ϕ∗is in ML(ML) for every EMDL-formula ϕ.

Extended Modal Dependence Logic EMDL
133
It is straightforward to prove by induction that K, T |= ϕ iﬀK, T |= ϕ∗holds
for every Kripke model K and every team T of K.
⊓⊔
Note that to represent the dependence atoms in ML(ML) we needed an expo-
nential size formula. In fact, the translation from EMDL into ML(ML) can-
not be made polynomial, unless the complexity classes PSPACE and NEXPTIME
collapse. This follows from the fact that satisﬁability for EMDL is NEXPTIME-
complete (see Theorem 4 below), while satisﬁability for ML(ML) is PSPACE-
complete, see [7, Corollary 3.3a].
Theorem 3. ML(ML) ≤EMDL
Proof. We will show that for every ML(ML) formula ϕ there exists an EMDL-
formula ϕ∗such that for every Kripke model K and a team T of K it holds that
K, T |= ϕ iﬀK, T |= ϕ∗.
(3)
We deﬁnite the translation ϕ →ϕ∗recursively in the following manner:
1. (ψ ∧θ)∗:= (ψ∗∧θ∗), (ψ ∨θ)∗:= (ψ∗∨θ∗), (□ψ)∗:= □ψ∗, (♦ψ)∗:= ♦ψ∗,
p∗:= p, (¬p)∗:= ¬p, and
2. (ϕ  ψ)∗:= (ϕ∗∨ψ∗) ∧dep((ϕ∗∧¬ψ∗) ∨(¬ϕ∗∧ψ∗), ψ∗).
The proof is done by induction on the structure of the formulas. The only inter-
esting case is the case for . Assume ﬁrst that K, T |= (ϕψ), and that ϕ and ψ
are ML-formulas for which (3) holds. Hence K, T |= ϕ or K, T |= ψ. Therefore
K, T |= ϕ∗or K, T |= ψ∗and hence K, T |= ϕ∗∨ψ∗. We still need to show that
K, T |= dep((ϕ∗∧¬ψ∗) ∨(¬ϕ∗∧ψ∗), ψ∗) .
(4)
Since K, T |= ϕ∗or K, T |= ψ∗by Proposition 1 we have that K, {a} |= ϕ∗for
all a ∈T or K, {a} |= ψ∗for all a ∈T . If the latter holds then clearly (4) holds,
hence we assume that the former holds. If
K, {a} |= (ϕ∗∧¬ψ∗) ∨(¬ϕ∗∧ψ∗)
for a ∈T , then since K, {a} |= ϕ∗we have that K, {a} |= ¬ψ∗. If on the other
hand it holds that
K, {a} ̸|= (ϕ∗∧¬ψ∗) ∨(¬ϕ∗∧ψ∗)
for some a ∈T , then since K, {a} |= ϕ∗we have that K, {a} |= ψ∗. Hence (4)
holds and we have that
K, T |= (ϕ  ψ)∗.
Assume then that K, T |= (ϕ  ψ)∗. Hence
K, T |= (ϕ∗∨ψ∗) and
(5)
K, T |= dep((ϕ∗∧¬ψ∗) ∨(¬ϕ∗∧ψ∗), ψ∗) .
(6)

134
J. Ebbing et al.
Notice that by Proposition 1 it follows from (5) that K, {a} |= ϕ∗or K, {a} |= ψ∗
for all a ∈T . Hence if for a ∈T it holds that
K, {a} ̸|= (ϕ∗∧¬ψ∗) ∨(¬ϕ∗∧ψ∗)
then K, {a} |= (ϕ∗∧ψ∗) and hence K, {a} |= (ϕ ∧ψ). Now by Proposition 1, if
we can show that for all a ∈T such that
K, {a} |= (ϕ∗∧¬ψ∗) ∨(¬ϕ∗∧ψ∗)
(7)
K, {a} |= ϕ (or K, {a} |= ψ), we are done. Let A ⊆T be the set of points a
from T such that (7) holds. Now since (6) we have that K, {a} |= ψ∗for all
a ∈A or K, {a} ̸|= ψ∗for all a ∈A. And now since we had that K, {a} |= ϕ∗
or K, {a} |= ψ∗for all a ∈T , we conclude that K, {a} |= ψ∗for all a ∈A or
K, {a} |= ϕ∗for all a ∈A.
⊓⊔
The three results given in this section can now be summarized as follows:
Corollary 1. ML < MDL < EMDL ≡ML(ML) ≤ML()
We leave it as an open question whether EMDL ≡ML().
4
Complexity of EMDL
In this section we show that we can decide the satisﬁability problem of EMDL in
NEXPTIME and the model checking problem in NP. Hardness for these problems
follows directly since these problems for MDL are NEXPTIME-complete and
NP-complete, respectively [4,7,9].
Theorem 4. EMDL-SAT is NEXPTIME-complete.
Proof. Let ϕ be an EMDL formula. Then each dep(·)-subformula of the form
dep(δ1, . . . , δn) is substituted by
dep(pδ1, . . . , pδn) ∧

1≤i≤n
pδi ↔δi,
where pδ1, . . . , pδn are fresh variables.
Claim. For every ϕ ∈EMDL it holds that ϕ is equisatisﬁable to ϕ′, where ϕ′
is the transformed formula from above.
Proof (of claim). Let ϕ ∈EMDL-SAT via the satisfying model K = (W, R, V ).
Construct a new Kripke model K′ = (W, R, V ′) from K by labelling the newly
added propositions. For all dep(δ1, . . . , δn) ∈SF(ϕ) we label with pδi those
worlds satisfying δi; more formally: for all w ∈W
V ′(w) = V (w) ∪{pδi | K, w |= δi and dep(δ1, . . . , δn) ∈SF(ϕ) , i ≤n}.

Extended Modal Dependence Logic EMDL
135
Let dep(δ1, . . . , δn) ∈SF(ϕ) and T ⊆W. By the above deﬁnition it holds for all
w, w′ ∈T that
⎛
⎜
⎝
K, w |= δ1
⇔K, w′ |= δ1 and
...
K, w |= δn−1 ⇔
K, w′ |= δn−1
⎞
⎟
⎠implies K, w |= δn ⇔K, w′ |= δn
if and only if
⎛
⎜
⎝
K′, w |= pδ1
⇔K′, w′ |= pδ1 and
...
K′, w |= pδn−1 ⇔
K′, w′ |= pδn−1
⎞
⎟
⎠implies K′, w |= pδn ⇔K′, w′ |= pδn.
Hence K, T |= dep(δ1, . . . , δn) if and only if K′, T |= dep(pδ1, . . . , pδn). Fur-
thermore, since all δi are ML-formulas we conclude by Proposition 1 that
K′, T |= n
i=1(δi ↔pδi). Hence it is an easy inductive proof that K′ is a sat-
isfying model for ϕ′. For the other direction, it is easy to prove by a similar
argument that any satisfying model for ϕ′ is also a satisfying model for ϕ.
Observe that the above transformation is polynomial. This means that we can
solve satisﬁability for EMDL with the satisﬁability algorithm for MDL-SAT,
giving us the upper bound NEXPTIME [7]. Since MDL is a sublogic of EMDL,
NEXPTIME-hardness for EMDL-SAT follows from that of MDL-SAT [7].
⊓⊔
Theorem 5. EMDL-MC is NP-complete.
Proof. The membership result is shown with an algorithm completely analogous
to the one for MDL-MC in [4]. In the following the check algorithm for the
dependence atom is given, which will be the only part changed compared to the
original MDL-MC algorithm.
Algorithm 1. Algorithm deciding EMDL-MC
Input: K, T, ϕ
if ϕ = dep(ϕ1, . . . , ϕn) then
forall the w1 ∈T do
forall the w2 ∈T do
t1 = (K, {w1} |= ϕ1, . . . , K, {w1} |= ϕn−1);
t2 = (K, {w2} |= ϕ1, . . . , K, {w2} |= ϕn−1);
if t1 = t2 and K, {w1} |= ϕn ⇔K, {w2} ̸|= ϕn then reject
end
end
end
// Other cases like in the usual MDL-MC algorithm [4];
accept
Let dep(ϕ1, . . . , ϕn) be the dependence atom that has to be checked. Since all ϕi
are ML formulas we can check K, {w} |= ϕi in polynomial time, which together
with MDL-MC being in NP [4] shows the upper bound.

136
J. Ebbing et al.
The lower bound follows from the NP-completeness of MDL-MC shown in [4]
and the fact that MDL is a subset of EMDL.
⊓⊔
5
Conclusion
We introduced EMDL as a ﬁrst approach towards a temporal dependence logic.
EMDL is a multi-modal extension of MDL that allows to express dependences
between arbitrary modal formulas. We showed that there are properties deﬁnable
in EMDL that cannot be deﬁned in MDL, but on the other hand EMDL can
be embedded into ML with classical disjunction . The translation, however,
is exponential and cannot be made polynomial unless PSPACE = NEXPTIME.
Unfortunately, we were only able to prove a partial converse, obtaining that
the expressive power of EMDL coincides with that of ML with only restricted
use of the classical disjunction operator , see Corollary 1. Thus, we leave the
question, whether EMDL ≡ML(), as an open problem.
Somewhat surprising, given the strict chain of Corollary 1, is the second
achievement of this paper: We showed that the computational complexity of
satisﬁability and model checking of EMDL is not higher than that of MDL.
In a similar fashion as the basic temporal logic TL has been extended to CTL
and LTL, one might introduce temporal operators like “Until” and “Globally”
into EMDL. Further work has to be done here to reasonably represent paths of
a Kripke model in modal dependence logic.
References
1. Berto, F., Tagliabue, J.: Cellular automata. In: Zalta, E.N. (ed.) The Stanford
Encyclopedia of Philosophy. Summer 2012 edn. (2012)
2. Blackburn, P., de Rijke, M., Venema, Y.: Modal Logics, Cambridge Tracts in The-
oretical Computer Science, vol. 53. Cambridge University Press, Cambridge (2001)
3. Clarke, E.M., Emerson, E.A.: Desing and synthesis of synchronisation skeletons
using branching time temporal logic. In: Kozen, D. (ed.) Logic of Programs 1981.
LNCS, vol. 131, pp. 52–71. Springer, Heidelberg (1982)
4. Ebbing, J., Lohmann, P.: Complexity of model checking for modal dependence
logic. In: Bielikov´a, M., Friedrich, G., Gottlob, G., Katzenbeisser, S., Tur´an, G.
(eds.) SOFSEM 2012. LNCS, vol. 7147, pp. 226–237. Springer, Heidelberg (2012)
5. Hodges, W.: Some strange quantiﬁers. In: Mycielski, J., Rozenberg, G., Salomaa,
A. (eds.) Structures in Logic and Computer Science. LNCS, vol. 1261, pp. 51–65.
Springer, Heidelberg (1997)
6. Ilachinski, A.: Cellular Automata: A Discrete Universe. World Scientiﬁc, Singapore
(2001)
7. Lohmann, P., Vollmer, H.: Complexity results for modal dependence logic. In:
Dawar, A., Veith, H. (eds.) CSL 2010. LNCS, vol. 6247, pp. 411–425. Springer,
Heidelberg (2010), http://dx.doi.org/10.1007/978-3-642-15205-4_32
8. Papadimitriou, C.H.: Computational Complexity. Addison-Wesley (1994)
9. Sevenster, M.: Model-theoretic and computational properties of modal de-
pendence logic. Journal of Logic and Computation 19(6), 1157–1173 (2009),
http://logcom.oxfordjournals.org/cgi/content/abstract/exn102v1

Extended Modal Dependence Logic EMDL
137
10. Sistla, A.P., Clarke, E.M.: The complexity of propositional linear temporal logics.
J. ACM 32(3), 733–749 (1985)
11. V¨a¨an¨anen, J.: Dependence logic: A new approach to independence friendly logic.
London Mathematical Society student texts, vol. 70. Cambridge University Press
(2007)
12. V¨a¨an¨anen, J.: Modal dependence logic. In: Apt, K.R., van Rooij, R. (eds.) New
Perspectives on Games and Interaction, Texts in Logic and Games, vol. 4, pp.
237–254. Amsterdam University Press (2008)

Dependence Logic with Generalized Quantiﬁers:
Axiomatizations
Fredrik Engstr¨om1, Juha Kontinen2, and Jouko V¨a¨an¨anen2,3
1 Department of Philosophy, Linguistics and Theory of Science, University of Gothenburg
2 Department of Mathematics and Statistics, University of Helsinki, Finland
3 Institute for Logic, Language and Computation, University of Amsterdam, The Netherlands
Abstract. We prove two completeness results, one for the extension of depen-
dence logic by a monotone generalized quantiﬁer Q with weak interpretation,
weak in the sense that the interpretation of Q varies with the structures. The sec-
ond result considers the extension of dependence logic where Q is interpreted
as “there exist uncountably many.” Both of the axiomatizations are shown to be
sound and complete for FO(Q) consequences.
1
Introduction
Generalized quantiﬁers constitute a well-studied method of extending the expressive
power of ﬁrst order logic. A more recent extension of ﬁrst order logic is obtained by
adding dependence atoms, permitting the expression of partially ordered quantiﬁcation.
In this paper we study the combination of the two methods, adding to ﬁrst order logic
both generalized quantiﬁers Q and dependence atoms as deﬁned in [1]. It was shown
in [2] that the resulting logic, D(Q), properly extends both FO(Q) and dependence
logic. We analyse further the expressive power and give natural axioms for the new
logic. There are theoretical limits to the extent that the axioms can be complete but we
give partial completeness results in the sense that completeness is shown with respect
to FO(Q) consequences.
Generalized quantiﬁers were introduced by Mostowski [3]. The most important of
them is perhaps the quantiﬁer
M ⊨Q1xφ(x,¯b) ⇐⇒M ⊨φ(a,¯b) for uncountably many a ∈M
owing to the beautiful axiomatization of it by Keisler [4]. On the other hand, generalized
quantiﬁers have made an entrance to both linguistics [5] and computer science [6]. In
natural language we can use generalized quantiﬁers to analyse constructs such as
Most boys run,
where we think of “most” as a generalized quantiﬁer. Other natural language quantiﬁers
are “two thirds”, “quite a few”, “many”, etc. There are various so-called polyadic lifts
of such quantiﬁers, for example,
Ramsey lift:
At least two thirds of the boys in your class like each other. [7]
L. Libkin, U. Kohlenbach, and R. de Queiroz (Eds.): WoLLIC 2013, LNCS 8071, pp. 138–152, 2013.
c⃝Springer-Verlag Berlin Heidelberg 2013

Dependence Logic with Generalized Quantiﬁers: Axiomatizations
139
Branching lift:
A few boys in my class and a few girls in your class have dated each other. [8]
Resumption lift:
Most neighbours like each other. [7]
In computer science, or more exactly ﬁnite model theory, we have the counting
quantiﬁers
M ⊨∃≥kxφ(x,¯b) ⇐⇒M ⊨φ(a,¯b) for at least k elements a ∈M
which, although ﬁrst order deﬁnable, have turn out relevant, but also the non-ﬁrst order
M ⊨∃evenxφ(x,¯b) ⇐⇒M ⊨φ(a,¯b) for an even number of a ∈M
and other similar ones. The lifts, also called vectorizations, are important in ﬁnite model
theory, too. For example, the resumption lift sequence of the transitive closure quan-
tiﬁers characterises in ordered models NLOGSPACE [9], and the resumption lift se-
quence of the so-called alternating transitive closure quantiﬁer characterises, even in
unordered models, least ﬁxpoint logic [10].
Dependence logic was introduced in [11]. It gives compositional semantics to the
partially ordered quantiﬁers of [12]:

∀x ∃y
∀u ∃v

φ(x, y, u, v, ¯z) ⇐⇒∃f∃g∀x∀uφ(x, f(x), u, g(u), ¯z).
The compositional analysis is

∀x ∃y
∀u ∃v

φ(x, y, u, v, ¯z) ⇐⇒∀x∃y∀u∃v(=(¯z, u, v) ∧φ(x, y, u, v, ¯z)),
where =(¯z, u, v) is a so-called dependence atom, see section 2.1 for its semantics. De-
pendence logic has the same expressive power as existential second order logic [13].
Thus dependence logic alone cannot express, for example, uncountability, in fact not
even ﬁniteness.
The idea of combining partially ordered quantiﬁers and generalized quantiﬁers was
ﬁrst suggested by Barwise [8]. He used this combination to analyse lifts such as the
Ramsey lift and the branching lift. It was proved in [7] that the polyadic lifts of mono-
tone (unbounded) generalized quantiﬁers lead to a strong hierarchy, giving immediately
the result that there is no ﬁnite number of generalized quantiﬁers, including partially or-
dered quantiﬁers, which would be able to express all Ramsey lifts of a given monotone
(unbounded) quantiﬁer. The same is true of branching lifts, and to a lesser extent of
resumption lifts [7].
The situation is quite different with the extension of dependence logic (rather than
ﬁrst order logic) by a monotone generalized quantiﬁer. All the mentioned polyadic lifts
(and vectorizations) can be readily deﬁned (in all arities). Let us see how this is done
for the Ramsey lift of a monotone quantiﬁer Q.

140
F. Engstr¨om, J. Kontinen, and J. V¨a¨an¨anen
∃A∈Q ∀x∈A ∀y∈A φ(x, y, ¯z)
⇐⇒
∃w(=(¯z, w) ∧Qx∃y( y = w ∧
∀u∃v(=(¯z, u, v) ∧(x = u →v = w)∧
∀u′∃v′(=(¯z, u′, v′) ∧(u = u′ →v′ = w)∧
((v = w ∧v′ = w) →φ(u, u′, ¯z))))))
Resumption and branching can be handled similarly.
Thus putting generalized quantiﬁers and dependence atoms together results in a pow-
erful combination extending far beyond either generalized quantiﬁers alone or depen-
dence atoms alone.
This paper is organised as follows. In Section 2 we review the basics on depen-
dence logic and generalized quantiﬁers in the dependence logic context. In Section 3
we present a system of natural deduction for the extension D(Q, ˇQ) of dependence
logic by a monotone generalized quantiﬁer Q and its dual ˇQ, and show that these rules
are sound. Finally in Section 4 two completeness results for FO(Q) consequences are
shown for D(Q, ˇQ). In the ﬁrst result Q has the so-called weak interpretation, and in
the second Q is interpreted as Q1, that is, “there exist uncountably many.”
2
Preliminaries
2.1
Dependence Logic
In this section we give a brief introduction to dependence logic. For a detailed account
see [11].
The syntax of dependence logic extends the syntax of ﬁrst order logic with new
atomic formulas, the dependence atoms. There is one dependence atom for each arity.
We write the atom expressing that the term tn is uniquely determined by the values
of the terms t1, . . . , tn−1 as =(t1, . . . , tn). We consider formulas where negation can
only appear in front of formulas without dependence atoms. For a vocabulary τ, D[τ]
denotes the set of τ-formulas of dependence logic. The set FV(φ) of free variables of a
formula φ is deﬁned as in ﬁrst order logic except that
FV(=(t1, . . . , tn)) = FV(t1) ∪. . . ∪FV(tn).
To deﬁne a compositional semantics for dependence logic we use sets of assignments,
called teams, instead of single assignments as in ﬁrst order logic. An assignment is a
function s : V →M where V is a ﬁnite set of variables and M is the universe under
consideration. A team on M is a set of assignments for some ﬁxed ﬁnite set of variables
V . If V = ∅there is only one assignment, the empty function ∅. Observe that the team
of the empty assignment { ∅} is different from the empty team ∅.
– Given an assignment s : V →M and a ∈M let s[a/x] : V ∪{ x } →M be the
assignment:
s[a/x] : y →
3
s(y)
if y ∈V \ { x }, and
a
if x = y.

Dependence Logic with Generalized Quantiﬁers: Axiomatizations
141
– Let X[M/y] be the team
{ s[a/y] | s ∈X, a ∈M } ,
– and whenever f : X →M, let X[f/y] denote the team
{ s[f(s)/y] | s ∈X } .
The domain of a non-empty team X, denoted dom(X), is the set of variables V . The
interpretation of the term t in the model M under the assignment s is denoted by tM,s.
We write s(¯x) for the tuple obtained by pointwise application of s to the ﬁnite sequence
¯x of variables.
The satisfaction relation for dependence logic M, X ⊨φ is deﬁned as follows. Be-
low, the notation M, s ⊨φ refers to the ordinary satisfaction relation of ﬁrst order logic.
We also assume that FV(φ) ⊆dom(X).
1. For formulas ψ without dependence atoms: M, X ⊨ψ iff ∀s ∈X : M, s ⊨ψ.
2. M, X ⊨=(t1, . . . , tn+1) iff ∀s, s′ ∈X : 
1≤i≤n tM,s
i
= tM,s′
i
→tM,s
n+1 = tM,s′
n+1
3. M, X ⊨φ ∧ψ iff M, X ⊨φ and M, X ⊨ψ
4. M, X
⊨
φ ∨ψ iff there are Y and Z such that X
=
Y ∪Z, and M, Y
⊨
φ and M, Z ⊨ψ
5. M, X ⊨∃yφ iff there is f : X →M, such that M, X[f/y] ⊨φ
6. M, X ⊨∀yφ iff M, X[M/y] ⊨φ.
We deﬁne M ⊨σ for a sentence σ to hold if M, { ∅} ⊨σ. Let us make some easy
remarks.
– Every formula is satisﬁed by the empty team.
– The satisfaction relation is downwards closed: If M, X ⊨φ and Y ⊆X then
M, Y ⊨φ.
– The satisfaction relation is local: M, X ⊨φ iff M, Y ⊨φ where
Y = { s ↾FV(φ) | s ∈X } .
The expressive power for sentences of dependence logic is the same as that of existential
second order logic.
2.2
D(Q)
The notion of a generalized quantiﬁer goes back to Mostowski [3] and Lindstr¨om [14].
In [1] semantics for generalized quantiﬁers in the framework of dependence logic was
introduced. We will review the deﬁnitions below.
Let Q be a quantiﬁer of type ⟨k⟩, meaning that Q is a class of τ-structures, where
the signature τ has a single k-ary relation symbol. Also, assume that Q is monotone
increasing, i.e., for every M and every A ⊆B ⊆M k, if A ∈QM then also B ∈QM,
where QM = { R ⊆M k | (M, R) ∈Q }.
The formulas of dependence logic extended with a quantiﬁer Q, D(Q), is built up
from FO(Q)-formulas and dependence atoms using the connectives ∧and ∨, and the

142
F. Engstr¨om, J. Kontinen, and J. V¨a¨an¨anen
quantiﬁer expressions ∃x, ∀x and Qx in the usual way. We write φ →ψ as a shorthand
for ¬φ ∨ψ, where φ is a formula without dependence atoms.
An assignment s satisﬁes a formula Q¯x φ in a structure M,
M, s ⊨Q¯x φ, if the set { ¯a ∈M k | M, s[¯a/¯x] ⊨φ } is in QM.
In the context of teams we say that a team X satisﬁes a formula Q¯x φ,
M, X ⊨Q¯x φ, if there exists F : X →QM such that M, X[F/¯x] ⊨φ,
(1)
where X[F/¯x] = { s[¯a/¯x] | ¯a ∈F(s), s ∈X }. This deﬁnition works well only with
monotone (increasing) quantiﬁers, see [1] for details.
The following easy proposition suggests that we indeed have the right truth condition
for monotone quantiﬁers:
Proposition 1 ([1])
(i) D(Q) is downwards closed.
(ii) D(Q) is local, in the sense that M, X ⊨φ iff M, (X ↾FV(φ)) ⊨φ.
(iii) Viewing ∃and ∀as generalized quantiﬁers of type ⟨1⟩, the truth conditions in (1)
are equivalent to the truth conditions of dependence logic.
(iv) For every D(Q) formula φ we have M, ∅⊨φ.
As proved in [2], the expressive power of D(Q) sentences corresponds to that of a
certain natural extension of existential second order logic by Q.
In order to get a prenex normal form for all formulas we will focus on the logics
D(Q, ˇQ), where ˇQ is the dual of Q, i.e,
ˇQ = { (M, M k \ R) | R ⊆M k, (M, R) /∈Q } ,
instead of D(Q). Note that, according to our deﬁnition of D(Q), a formula Qxφ may
be negated only if φ is a FO(Q) formula.
We will consider monotone increasing quantiﬁers Q satisfying two non-triviality
assumptions: (M, ∅) /∈Q and (M, M k) ∈Q for all M. In [2] the following normal
form for sentences of D(Q) was shown for such non-trivial quantiﬁers. In the following
we will use the notations ¯xi and ¯xi interchangeably.
Theorem 1. Every D(Q) sentence in negation normal form, where Q is non-trivial,
can be written as
H1¯x1 . . . Hm¯xm∃y1 . . . ∃yn
 
1≤i≤n
=(¯zi, yi) ∧θ

,
where Hi is either Q or ∀and θ is a quantifer-free FO-formula.
In the present paper a similar normal form for all D(Q, ˇQ) formulas is obtained in
Proposition 3.
A weak semantics can be given for D(Q) (and FO(Q), etc) by regarding Q as an
interpreted symbol rather than a logical constant in the following way (see [4] and [15]

Dependence Logic with Generalized Quantiﬁers: Axiomatizations
143
for more on this). A weak model is a structure together with an interpretation of Q, often
denoted by q. We deﬁne T ⊨w σ to hold if every weak model (M, q) of T satisﬁes σ. In
this paper we require the interpretation q of Q to be monotone increasing and non-trivial
(In essence this is the monotone logic of [16]). In the weak semantics for D(Q, ˇQ) we
require that the interpretation ˇq of ˇQ is the dual of the interpretation q of Q. Thus, if
T ∪{ σ } consists of D(Q, ˇQ) sentences, then T ⊨w σ if every model (M, q, ˇq) of T
satisﬁes σ.
3
Natural Deduction for D(Q, ˇ
Q)
In this section we present a set of natural deduction rules for the logic D(Q, ˇQ), where Q
is monotone and satisﬁes the non-triviality conditions: (M, ∅) /∈Q and (M, M k) ∈Q
for all M. Observe that then also the dual quantiﬁer ˇQ satisﬁes these conditions. To
simplify notation, we will restrict attention to type ⟨1⟩quantiﬁers.
We use an abbreviation ¯x = ¯y for the formula 
1≤i≤len(¯x) xi = yi, assuming of
course that ¯x and ¯y are tuples of the same length len(¯x). The substitution of a term t to
the free occurrences of x in ψ is denoted by ψ[t/x]. Analogously to ﬁrst order logic, no
variable of t may become bound in such a substitution. For tuples ¯t = (t1, . . . , tn) and
¯x = (x1, . . . , xn) we write ψ[¯t/¯x] to denote the simultaneous substitution of xi by ti
for 1 ≤i ≤n.
We use the standard ﬁrst order introduction and elimination rules for conjunction,
existential quantiﬁer, and universal quantiﬁer. We also adopt rules for commutativity
and associativity of disjunction, and the usual identity axioms for FO(Q, ˇQ) formulas.
The rest of the rules are listed below:
1. Disjunction:
φ
φ ∨ψ ∨I
ψ
φ ∨ψ ∨I
φ ∨ψ
[φ]....γ
[ψ]....γ
γ
∨E
where γ is a FO(Q, ˇQ) formula.
2. Negation and duality:
[φ]....
⊥
¬φ ¬I
[¬φ]
....
⊥
φ RAA
φ
¬φ
⊥
⊥I
ˇQxφ
¬Qx¬φ
where φ is a FO(Q, ˇQ) formula.
3. Disjunction substitution:
φ ∨ψ
[ψ]....γ
φ ∨γ

144
F. Engstr¨om, J. Kontinen, and J. V¨a¨an¨anen
4. Extending scope:
Hxφ ∨ψ
Hx(φ ∨ψ)
Qxφ ∧ψ
Qx(φ ∧ψ)
where H ∈{Q, ˇQ, ∃, ∀}, and the prerequisite for applying these rules is that x does
not appear free in ψ. The rule on the right is also assumed for ˇQ.
5. Unnesting:
=(t1, ..., tn)
∃z(=(t1, ..., z, ..., tn) ∧z = ti)
where z is a new variable.
6. Dependence distribution: let
φ = ∃y1 . . . ∃yn(

1≤j≤n
=(¯zj, yj) ∧φ0),
ψ = ∃yn+1 . . . ∃ym(

n+1≤j≤m
=(¯zj, yj) ∧ψ0).
where φ0 and ψ0 are quantiﬁer-free formulas without dependence atoms, and yi,
for 1 ≤i ≤n, does not appear in ψ and yi, for n + 1 ≤i ≤m, does not appear in
φ. Then,
φ ∨ψ
∃y1 . . . ∃ym(
1≤j≤m =(¯zj, yj) ∧(φ0 ∨ψ0))
7. Dependence introduction:
∃x∀yφ
∀y∃x(=(¯z, x) ∧φ)
∃xQyφ
Qy∃x(=(¯z, x) ∧φ)
where ¯z lists the variables in FV(φ) −{x, y}. Similar for ˇQ.
8. Monotonicity of Q and ˇQ:
Qxφ
[φ]....
ψ
Qxψ
where the prerequisite for applying this rule is that the variable x cannot appear
free in any non-discharged assumption used in the derivation of ψ, except for φ.
Similar for ˇQ.
9. Bound variables:
Qxφ
Qyφ[y/x],
where y does not appear in φ. Similar for ˇQ.
Observe that FO(Q, ˇQ)
≡
FO(Q), but syntactically FO(Q, ˇQ) includes more
formulas.

Dependence Logic with Generalized Quantiﬁers: Axiomatizations
145
3.1
Soundness of the Rules
In this section we show the soundness of the rules introduced in the previous section
under any monotone and non-trivial interpretation of Q. Clearly this is the same as
soundness in the weak semantics for Q.
The following lemmas will be needed in the proof.
Lemma 1. Let φ(x) be a D(Q, ˇQ) formula, and t a term such that in the substitution
φ(t/x) no variable of t becomes bound. Then for all M and teams X, where (FV(φ) −
{x}) ∪Var(t) ⊆dom(X)
M, X ⊨φ(t/x) ⇔M, X(F/x) ⊨φ(x),
where F : X →A is deﬁned by F(s) = tM⟨s⟩.
Proof. Analogous to Lemma 8 in [17].
It is easy to verify that Lemma 1 gives the following familiar property concerning
changing free variables.
Lemma 2 (Change of free variables). Let the free variables of φ ∈D(Q, ˇQ) be
x1, . . . , xn and let y1, . . . , yn be distinct variables. Then for all structures M and teams
X with domain {x1, . . . , xn} it holds that
M, X ⊨φ ⇔M, X′ ⊨φ(¯y/¯x),
where X′ is the team with domain {y1, . . . , yn} containing the assignments s′ : yi →
s(xi) for s ∈X.
Proposition 2. Assume that Q is monotone and non-trivial. Let T ∪{φ} be a set of
sentences of D(Q, ˇQ). If T ⊢φ, then T ⊨φ.
Proof. We prove the statement that if T ⊢φ, where T ∪{ φ } is a set of formulas, then
for any M and X where dom(X) ⊇FV(T ) ∪FV(φ), if M, X ⊨T then M, X ⊨φ.
This is done by using induction on the length of derivation.
It sufﬁces to consider the rules 2 (duality), 4, 7, 8, and 9 since the soundness of the
other rules can be proved analogously to [17] using the fact that D(Q, ˇQ) is local and
has downwards closure (see (ii) and (i) of Proposition 1). In particular, Lemma 1 is used
in the soundness proofs of the rules ∃I and ∀E.
2. Assume M, X ⊨ˇQxφ then, since ˇQxφ is a FO(Q, ˇQ) formula we have M, s ⊨
ˇQxφ for all s ∈X. This clearly implies that M, s ⊨¬Qx¬φ for all s ∈X, which
is equivalent to M, X ⊨¬Qx¬φ.
4. These two rules preserve logical equivalence analogously to Lemma 3.2 in [2].
7. The soundness of this rule follows from the logical equivalence
Qy∃x(=(¯z, x) ∧φ) ≡∃xQyφ
the proof of which is analogous to the case where Q is replaced by ∀(see [17]).

146
F. Engstr¨om, J. Kontinen, and J. V¨a¨an¨anen
8. Assume that we have a natural deduction proof of Qxψ from the assumptions
{γ1, . . . , γk}
with the last rule 13. Let M and X be such that M, X ⊨φi, for 1 ≤i ≤k.
By the assumption, we have a shorter deduction of Qxφ from the assumptions
{γn1, . . . , γnl} and a deduction of ψ from the assumptions {φ, γnl+1, . . . , γnm}.
Hence by the induction assumption it holds that M, X ⊨Qxφ. Therefore, there
is F : X →QM such that M, X[F/x] ⊨φ. Since the variable x cannot ap-
pear free in the formulas γnl+1, . . . , γnm it follows that M, X[F/x] ⊨γi, for i ∈
{ nl+1, . . . , nm }. Now by the induction assumption we get that M, X[F/x] ⊨ψ
and M, X ⊨Qxψ.
9. This rule preserves logical equivalence by Lemma 2.
⊓⊔
Note that since Proposition 2 holds for every monotone non-trivial quantiﬁer Q we get
also soundness for weak semantics: If T ⊢φ then T ⊨w φ.
4
Completeness Results for FO(Q, ˇ
Q) Consequences
4.1
Deriving a Normal Form for D(Q, ˇ
Q)
In this section we show that from each formula φ ∈D(Q, ˇQ) we can derive a logically
equivalent formula in the following normal form:
H1x1 . . . Hmxm∃y1 . . . ∃yn
 
1≤i≤n
=(¯xi, yi) ∧θ

,
(2)
where Hi is either Q, ˇQ or ∀, and θ is a quantiﬁer-free FO-formula.
Proposition 3. Let φ be a formula of D(Q, ˇQ). Then φ ⊢φ′, where φ′ is of the form
(2), and φ′ is logically equivalent to φ.
Proof. The proofof this Proposition is analogousto the proof of the correspondingresult
for dependence logic formulas in [17]. See the full version of this article [18].
⊓⊔
4.2
Completeness for D(Q, ˇ
Q)
In this section we prove a completeness result for D(Q, ˇQ) with respect to FO(Q, ˇQ)
consequences of D(Q, ˇQ)-sentences, with weak semantics. Analogously to [17], we
approximate D(Q, ˇQ)-sentences in the normal form (2) by an inﬁnite set of FO(Q, ˇQ)
sentences. We use an extra predicate R to encode a team witnessing the satisﬁability of
the quantiﬁer preﬁx H1x1 . . . Hmxm.
Let σ be
H1x1 . . . Hmxm∃y1 . . . ∃yn
 
1≤i≤n
=(¯xi, yi) ∧θ(x1, . . . , xm, y1, . . . , yn)

,
where each Hi is either Q, ˇQ or ∀.

Dependence Logic with Generalized Quantiﬁers: Axiomatizations
147
We deﬁne ﬁnite approximations Aiσ of σ as follows. The ﬁrst approximation, A1σ,
is
∀¯x∃¯y

R(¯x) →θ(¯x, ¯y)

.
The second approximation A2σ is
∀¯x1∃¯y1∀¯x2∃y2

R(¯x1) ∧R(¯x2) →θ(¯x1, ¯y1) ∧θ(¯x2, ¯y2) ∧

1<i<n
(¯xi
1 = ¯xi
2 →yi,1 = yi,2)

With the notational convention that (xi1, . . . , xik)j is the sequence (xi1,j, . . . , xik,j).
By generalizing this construction we get the k-th approximation:
∀¯x1∃¯y1 . . . ∀¯xk∃¯yk
 
1≤j≤k
R(¯xj) →

1≤j≤k
θ(¯xj, ¯yj) ∧

1≤i≤n
1≤j,j′≤k
(¯xi
j = ¯xi
j′ →yi,j = yi,j′)

Also we need a sentence saying that R is of the right kind, witnessing the quantiﬁer
preﬁx: Let Bσ be
H1x1 . . . HmxmR(x1, . . . , xm).
We will adopt the following rule in our deduction system:
(10) Approximation rule:
σ
[Bσ]
...
[Anσ]
...
ψ (Approx)
ψ
where σ is a sentence in normal form, and R does not appear in ψ nor in any uncancelled
assumptions in the derivation of ψ, except for Bσ and Anσ.
Proposition 4. Adding the approximation rule to the inference system results in a sound
system for D(Q, ˇQ) with regard to weak semantics.
Proof. We plug in the following induction step to the proof of Proposition 2:
Assume that there is a derivation of ψ from Γ ending with the approximation rule.
Then there are shorter derivations from Γ of σ and from Γ ′, Bσ, Anσ of ψ, where
Γ ′ ⊆Γ is such that R does not occur in Γ ′. By the induction hypothesis we get Γ ⊨σ
and Γ ′, Bσ, Anσ ⊨ψ. We will prove that Γ ⊨ψ, by assuming M, X ⊨Γ for some
non-empty X and proving that M, X ⊨ψ.
Assume σ is of the form
H1x1 . . . Hmxm∃y1 . . . ∃yn
 
1≤i≤n
=(¯xi, yi) ∧θ

.

148
F. Engstr¨om, J. Kontinen, and J. V¨a¨an¨anen
where θ is a quantiﬁer free ﬁrst order formula.
From the fact that M, X ⊨σ we get M ⊨σ and thus there is a (non-empty) team Y
such that
M, Y ⊨∃y1 . . . ∃yn
 
1≤i≤n
=(¯xi, yi) ∧θ

.
Let r ⊆M m be the relation Y (¯x) = { s(¯x) | s ∈X } corresponding to Y . Then
(M, r) ⊨Bσ and, it should also be clear that (M, r) ⊨Anσ. Since R does not occur in
Γ ′ we have (M, r), X ⊨Γ ′, Bσ, Anσ. By the induction hypothesis (M, r), X ⊨ψ, and
since R does not occur in ψ we have M, X ⊨ψ.
⊓⊔
Lemma 3. If T is a set of FO(Q, ˇQ)-sentences consistent in the deduction system de-
scribed above then there are a countable recursively saturated model M and an inter-
pretation q of Q such that (M, q, ˇq) ⊨T .
Proof. First translate T to T ¬ in which each ˇQxφ is replaced by ¬Qx¬φ. By using
the same argument as in [4,15] we may reduce FO(Q) to FO by replacing subformulas
of the form Qxφ with new relation symbols Rφ(¯y), ¯y being the free variables of Qxφ.
This will reduce the set T ¬ to a set T ∗. Let T ′ be T ∗together with the translations of
the universal closures of
– (φ →ψ) →(Qxφ →Qxψ), for all φ and ψ; and
– Qxφ →Qy(φ[y/x]), for all φ such that the substitution is legal.
Now T ′ is consistent by the same argument as in [15]. Let M∗be a countable recursively
saturated model of T ′, and M its reduct to the original signature. Now we may deﬁne q
to be
{ A ⊆M | A ⊇{ a ∈M | M∗, s[a/x] ⊨φ∗} for some φ s.t. M ∗, s ⊨Qxφ∗} .
Proposition 2.3.4 in [15] shows that (M, q) ⊨T ¬, and thus (M, q, ˇq) ⊨T .
⊓⊔
The main result of this section can now be stated as follows.
Theorem 2. Let T be a set of sentences of D(Q, ˇQ) and φ ∈FO(Q, ˇQ) a sentence.
Then the following are equivalent:
(I) T ⊨w φ
(II) T ⊢φ
Lemma 4. In a countable recursively saturated weak model (M, q, ˇq) in which Bσ and
Anσ holds for all n, σ holds.
Proof. Suppose σ is
H1x1 . . . Hmxm∃y1 . . . ∃yn
 
1≤i≤n
=(¯xi, yi) ∧θ

.
Note that the sentences Anσ can be viewed as the ﬁnite approximations as deﬁned in
[17] (and see also [19]) of the D sentence σ′:
∀¯x∃¯y
 
1≤i≤n
=(¯xi, yi) ∧(R(¯x) →θ)

.

Dependence Logic with Generalized Quantiﬁers: Axiomatizations
149
Thus by Theorem 2.4 in [19] (see also [17]), we know that M ⊨σ′.
Let X be the team { s : { x1, . . . , xk } →M | (s(x1), . . . , s(xm)) ∈RM }. To prove
that (M, q, ˇq) ⊨σ we ﬁnd F1, . . . , Fm so that { ∅} [F1/x1] . . . [Fm/xm] = X.
F1(∅) = X ↾{ x1 } ,
Fi+1 : { ∅} [F1/x1] . . . [Fi/xi] →M
Fi+1(s) = { a ∈M | ∃s′ ∈X : (s′(x1), . . . , s′(xi+1)) = (s(x1), . . . , s(xi), a) } .
By the assumption (M, q, ˇq) ⊨Bσ it follows that Fi(s) ∈Hi
M. Furthermore, since
M ⊨σ′ we get that
M, X ⊨∃y1 . . . ∃yn
 
1≤i≤n
=(¯xi, yi) ∧θ

.
Therefore
(M, q, ˇq) ⊨H1x1 . . . Hmxm∃y1 . . . ∃yn
 
1≤i≤n
=(¯xi, yi) ∧θ

as wanted.
⊓⊔
Proof (Proof of Theorem 2.). (I) ⇒(II): This is just a special case (for sentences) of
soundness.
(II) ⇒(I): Suppose T ⊬φ, where φ is a FO(Q, ˇQ)-sentence. We will construct
a weak model of T ∪{ ¬φ } showing that T ⊭w φ. Replacing T with the set T ′ =
{ Bσ, Anσ | σ ∈T, n ∈N } we can conclude that T ′∪{ ¬φ } ⊬⊥. By applying Lemma
3 we get a weak countable recursively saturated model (M, q, ˇq) of T ′. Lemma 4 im-
plies that (M, q, ˇq) ⊨T . Now since (M, q, ˇq) ⊭φ, we get T ̸⊨w φ as wanted.
⊓⊔
4.3
Completeness for D(Q1, ˇ
Q1)
We will now prove a completeness result similar to Theorem 2 for the logic D(Q, ˇQ)
where Q is interpretated as Q1, the quantiﬁer “there exist uncountably many.” In this
section we consider only structures over uncountable universes.
We add the following two rules from [4] to the system presented in Section 3. Note
that the approximation rule of section 4.2 is not included.
¬Qx(x = y ∨x = z)
Qx∃yφ
∃yQxφ ∨Qy∃xφ
The intuitive meaning of the second rule is that a countable union of countable sets is
countable. The ﬁrst is needed to avoid Q being interpreted as the quantiﬁer “the exists
at least two.”
For each D(Q, ˇQ) sentence σ
H1x1 . . . Hmxm∃y1 . . . ∃yn
 
1≤i≤n
=(¯xi, yi) ∧θ


150
F. Engstr¨om, J. Kontinen, and J. V¨a¨an¨anen
in normal form we deﬁne the Skolem translation Sσ of σ to be:
H1x1 . . . Hmxmθ(fi(¯xi)/yi),
where the fi’s are new function symbols of the right arity. If σ is a sentence in the
signature τ then Sσ will be in the extended signature τ ∪{ f1, . . . , fn }.
The last rule of the deduction system is the following:
σ
[Sσ]
...
ψ (Skolem)
ψ
Here σ is a D(Q, ˇQ) sentence in normal form, and the function symbols f1, . . . , fn do
not occur in ψ nor in any uncancelled assumption of the derivation of ψ, except for Sσ.
Proposition 5. If T ⊢φ in the deduction system for D(Q1, ˇQ1) then T ⊨φ.
Proof. We extend the proof of Proposition 2 to also cover the three new rules:
(1) The soundness of the ﬁrst rule is easily seen by observing that the formula
Q1x(x = y ∨x = z) is a FO(Q1) formula and thus a team satisﬁes it iff every as-
signment in the team satisﬁes the formula.
(2) For the second rule we need to prove that if M, X ⊨Γ, Q1x∃yφ then M, X ⊨
Γ, ∃yQ1xφ ∨Q1y∃xφ. By the assumption we get functions F : X →QM and f :
X[F/x] →M such that M, X[F/x][f/y] ⊨φ. Thus, for each s ∈X there is a binary
relation Rs = { (a, f(s[a/y])) | a ∈F(s) } such that (M, Rs) ⊨Q1x∃yR(x, y). Let
Y = { s ∈X | (M, Rs) ⊨∃yQ1xR(x, y) }
and
Z = { s ∈X | (M, Rs) ⊨Q1y∃xR(x, y) } .
By the validity of the rule for FO(Q1) we see that X = Y ∪Z.
It should be clear that Y ⊨∃yQ1xφ since by letting g(s) be such that (M, Rs) ⊨
Q1xR(x, g(s)) and
G(s[g(s)/y]) = { a ∈M | (M, Rs) ⊨R(a, g(s)) } ,
we have that Y [g/y][G/x] ⊆X[F/x][f/y] and thus by downward closure
M, Y [g/y][G/x] ⊨φ.
Similarly we can prove that M, Z ⊨Q1y∃xφ, and thus that M, X ⊨Γ, ∃yQ1xφ ∨
Q1y∃xφ.
(3) For the Skolem rule assume that there is a derivation of ψ from Γ ending with
the Skolem rule. Then there are shorter derivations from Γ of σ and from Γ, Sσ of ψ.
By the induction hypothesis we get Γ ⊨σ and Γ, Sσ ⊨ψ. We will prove that Γ ⊨ψ,
by assuming M, X ⊨Γ for some non-empty X and proving that M, X ⊨ψ.

Dependence Logic with Generalized Quantiﬁers: Axiomatizations
151
From the proof of Theorem 3.5 in [2] we see that M ⊨σ iff M ⊨∃f1 . . . ∃fkSσ.
From M, X ⊨Γ and Γ ⊨σ we get that M ⊨σ and thus there are f1, . . . , fk such that
(M, f1, . . . , fk) ⊨Sσ. Now since the fi’s do not occur in formulas Γ ′ ⊆Γ used in
the derivation of ψ, M, X ⊨Γ implies that (M, f1, . . . , fk), X ⊨Γ ′. By locality, we
also have (M, f1, . . . , fk), X ⊨Sσ. Therefore, by the induction hypothesis, we get that
(M, f1, . . . , fk), X ⊨ψ, and, since the fi’s do not occur in ψ, M, X ⊨ψ follows.
⊓⊔
Theorem 3. If T is a set of D(Q1, ˇQ1) sentences and φ is a FO(Q1, ˇQ1) sentence then
T ⊢φ iff T ⊨φ.
Proof. Assume T ⊬φ. We build a model of T ′ = T ∪{ ¬φ } ⊬⊥by translating
sentences σ of T into normal form σnf and considering the FO(Q, ˇQ) theory TS =
{ Sσnf | σ ∈T } ∪{ ¬φ }. This theory is consistent, since otherwise the Skolem rule
and Proposition 3 would allow us to derive a contradiction from T ′.
Since the deduction system for D(Q1, ˇQ1) contains Keisler’s system [4] we may
apply the completeness theorem for FO(Q1) and get a model M of TS ∪{ ¬φ }. By
the remark made in the proof of Proposition 5 and Proposition 3 M is also a model of
T ∪{ ¬φ }. Thus T ⊭φ.
⊓⊔
5
Conclusion
In this article we have presented inference rules and axioms for extensions of depen-
dence logic by monotone generalized quantiﬁers. We also proved two completeness
results for FO(Q) consequences in the cases where Q either has a weak interpretation
or Q is interpreted as “there exist uncountably many.” In the ﬁrst completeness theorem,
an important feature of the proof is the approximation of a D(Q1, ˇQ1) sentence by an
inﬁnite set of FO(Q) sentences. In the second completeness theorem the approxima-
tions were replaced by the Skolem rule which however is slightly unsatisfactory due
to the extra function symbols fi used in its formulation. In future work our plan is to
further analyze the completeness theorem of D(Q1, ˇQ1), and replace the Skolem rule
with rules that do not rely on the explicit use of the Skolem functions fi.
References
1. Engstr¨om, F.: Generalized quantiﬁers in dependence logic. Journal of Logic, Language and
Information 21, 299–324 (2012)
2. Engstr¨om, F., Kontinen, J.: Characterizing quantiﬁer extensions of dependence logic. Journal
of Symbolic Logic 78(1), 307–316 (2013)
3. Mostowski, A.: On a generalization of quantiﬁers. Fund. Math. 44, 12–36 (1957)
4. Keisler, H.: Logic with the quantiﬁer “there exist uncountably many”. Annals of Mathemat-
ical Logic 1(1), 1–93 (1970)
5. Peters, S., Westerst˚ahl, D.: Quantiﬁers in Language and Logic. Clarendon Press (2006)
6. Kolaitis, P.G., V¨a¨an¨anen, J.A.: Generalized quantiﬁers and pebble games on ﬁnite structures.
Ann. Pure Appl. Logic 74(1), 23–75 (1995)
7. Hella, L., V¨a¨an¨anen, J., Westerst˚ahl, D.: Deﬁnability of polyadic lifts of generalized quanti-
ﬁers. J. Logic Lang. Inform. 6(3), 305–335 (1997)

152
F. Engstr¨om, J. Kontinen, and J. V¨a¨an¨anen
8. Barwise, J.: On branching quantiﬁers in English. J. Philos. Logic 8(1), 47–80 (1979)
9. Immerman, N.: Languages that capture complexity classes. SIAM J. Comput. 16(4), 760–
778 (1987)
10. Dahlhaus, E.: Skolem normal forms concerning the least ﬁxpoint. In: B¨orger, E. (ed.) Com-
putation Theory and Logic. LNCS, vol. 270, pp. 101–106. Springer, Heidelberg (1987)
11. V¨a¨an¨anen, J.: Dependence Logic - A New Approach to Independence Friendly Logic. Lon-
don Mathematical Society Student Texts, vol. 70. Cambridge University Press, Cambridge
(2007)
12. Henkin, L.: Some remarks on inﬁnitely long formulas. In: Inﬁnitistic Methods (Proc. Sym-
pos. Foundations of Math., Warsaw, 1959, pp. 167–183. Pergamon, Oxford (1961)
13. Kontinen, J., V¨a¨an¨anen, J.A.: On deﬁnability in dependence logic. Journal of Logic, Lan-
guage and Information 18(3), 317–332 (2009)
14. Lindstr¨om, P.: First order predicate logic with generalized quantiﬁers. Theoria 32, 186–195
(1966)
15. Kaufmann, M.: The quantiﬁer “there exist uncountably many”, and some of its relatives.
In: Barwise, J., Feferman, S. (eds.) Perspectives in Mathematical Logic. Model Theoretic
Logics, pp. 123–176. Springer (1985)
16. Makowsky, J., Tulipani, S.: Some model theory for monotone quantiﬁers. Archive for Math-
ematical Logic 18(1), 115–134 (1977)
17. Kontinen, J., V¨a¨an¨anen, J.: Axiomatizingﬁrst orderconsequencesindependencelogic. Annals
of Pure and Applied Logic (June 6, 2013)
18. Engstr¨om, F., Kontinen, J., V¨a¨an¨anen, J.: Dependence logic with generalized quantiﬁers:
Axiomatizations. arxiv:1304.0611 (2013)
19. Barwise, J.: Some applications of henkin quantiﬁers. Israel Journal of Mathematics 25(1),
47–63 (1976)

Continuous Truth II: Reﬂections
Michael P. Fourman
School of Informatics, The University of Edinbugh, Scotland, UK
Michael.Fourman@ed.ac.uk
Abstract. In the late 1960s, Dana Scott ﬁrst showed how the Stone -
Tarski topological interpretation of Heyting’s calculus could be extended
to model intuitionistic analysis; in particular Brouwer’s continuity prin-
ciple. In the early ’80s we and others outlined a general treatment of
non-constructive objects, using sheaf models—constructions from topos
theory—to model not only Brouwer’s non-classical conclusions, but also
his creation of “new mathematical entities”. These categorical models are
intimately related to, but more general than Scott’s topological model.
The primary goal of this paper is to consider the question of iterated
extensions. Can we derive new insights by repeating the second act?
In Continuous Truth I, presented at Logic Colloquium ’82 in Flo-
rence, we showed that general principles of continuity, local choice and
local compactness hold in the gros topos of sheaves over the category of
separable locales equipped with the open cover topology.
We touched on the question of iteration. Here we develop a more gen-
eral analysis of iterated categorical extensions, that leads to a reﬂection
schema for statements of predicative analysis.
We also take the opportunity to revisit some aspects of both Continu-
ous Truth I and Formal Spaces (Fourman & Grayson 1982), and correct
two long-standing errors therein.
Keywords: sheaf model, logic, intuitionism, predicative, analysis, topos.
1
Introduction
Brouwer, in his Cambridge lectures [8], distinguishes two “acts of intuitionism”.
The ﬁrst (p. 4) is to reject some “principles of classical logic, blindly formulated.”
In particular, Brouwer rejects the principium tertii exclusi: “the principle of the
excluded third, ... cannot in general serve as a principle for discovering mathe-
matical truths.” This ﬁrst act is formally enshrined in Heyting’s predicate calcu-
lus, which intuitionism shares with various ﬂavours of constructive mathematics.
Brouwer’s second act of intuitionism is more subtle.
Admitting two ways of creating new mathematical entities: ﬁrstly in the
shape of more or less freely proceeding inﬁnite sequences of mathemat-
ical entities previously acquired; secondly in the shape of mathematical
species, ...
(op cit. p.8)
Brouwer uses such non-constructive creations to derive strongly non-classical
results, such as his celebrated continuity principle:
L. Libkin, U. Kohlenbach, and R. de Queiroz (Eds.): WoLLIC 2013, LNCS 8071, pp. 153–167, 2013.
c
⃝Springer-Verlag Berlin Heidelberg 2013

154
M.P. Fourman
Each full function of the unity continuum is uniformly continuous. (p.80)
To model this ‘second act’, we base ourselves in a constructive setting B, and
model the addition of new mathematical entities by the passage to an extension
E = B[D], that includes a new entity, D. Working within the extension, we model
Brouwer’s arguments, and his non-classical conclusions—such as the contnuity
principle.
The Lawvere-Tierney notion of an elementary topos E provides a paradigmatic
example of a constructive setting, and their construction of a classifying topos,
extending a base topos by adding a generic model, D, of some geometric theory,
has now been widely used to model the introduction of new mathematical entities
(see e.g. [9] for a recent example).
For the simplest inﬁnitary extensions — adding a generic inﬁnite sequence by
taking sheaves over formal Baire space or formal Cantor space [1, 2] — it is easy
to see that the construction is reﬂexive. This was part of the folklore thirty years
ago, but appears to be still unrecorded in the literature. We ﬁrst review these
examples, and then consider models such as those introduced in [3–6] and used
extensively by, e.g., [7, 9].
In [6], we considered the interpretation of logic in the gros topos of sheaves
over the category of separable locales equipped with the open cover topology. We
showed that general principles of continuity, local choice and local compactness
hold for these models. In §5 we touched on the question of iteration. Our analysis
there focussed on low-level detail. We failed to see the wood for the trees. Plans,
announced there, to develop a high-level account in collaboration with Max Kelly
never materialised.
Here we provide a quite general category-theoretic account of iteration — the
construction of a model within the model — a preliminary report of ongoing
work. This allows us to show that in some models, M, a reﬂection principle that
states that, a statement φ of predicative analysis is true iﬀit is true in the model,
is valid:
Reﬂection for φ :
M ⊨φ
iﬀ
M ⊨⌜M ⊨φ⌝
We also present the basic facts we need relating open locales to open maps,
correcting an error in [10]. These facts are no longer new — for an elephantine
account see [11] (
) — but our presentation maybe more accessible, from a
logical perspective, than the deﬁnitive treatment in [12].
2
Preliminaries
We compose morphisms in diagram order: for a
f- b
g- c we have a
fg- c .
Otherwise, our notations and deﬁnitions generally follow those of Mac Lane &
Moerdijk [13] (M&M) or Johnstone
, except where some constructive ﬁnesse
is required.

Continuous Truth II: Reﬂections
155
Context. Our arguments are intended always to be formalisable in Higher-order
Heyting Arithmetic (HAH), a simple impredicative type theory also known as
the logic of topoi. Much, maybe all, of what we say will be formalisable within a
weaker predicative setting [9, 14], but we have neither space nor time to attempt
that here. A set (Kuratowski) ﬁnite iﬀit can be enumerated by some natural
number, and countable iﬀit can be enumerated by IN ; in each case, repetitions
are allowed. Any countable X is inhabited — which means that there is some x
such that x ∈X .
We use the locutions of dependent types, for example when we discuss cov-
erings and sheaves, but these can be interpreted within a simple type theory
using a standard categorical trick, due originally to Grothendieck. An indexed
type Ai | i ∈I is given by a morphism A
- I. This representation means
that operations are deﬁned uniformly across the family. Jean B´enabou and his
school showed how it can be used to develop category theory in an essentially
predicative setting [15].
2.1
Frames and Locales
We recap some facts, which should be well-known [10, 12, 14, 16–19].
Deﬁnition 1. A frame, F, is a complete ∧-distributive lattice; ﬁnite meets
distribute over arbitrary joins: a ∧
i∈I bi = 
i∈I(a ∧bi) . A frame morphism
preserves ⊤∧. A basis G ⊆F is a subset such that u = {v ∈G | v ≤u},
for every u ∈F. The category L of locales is deﬁned to be the opposite of the
category of frames. Following [12] we often refer to its objects as spaces.
Given f : X
- Y, a morphism in L, the corresponding frame morphism is the
inverse image morphism f ∗: O(Y) - O(X) . L can be viewed as a category
of generalised spaces [19]. Any set X, can be viewed as a discrete space corre-
sponding to the frame P(X). The one-point space 1l = {∗} corresponds to the
frame P(1l) . A point of X is a morphism x : 1l - X . Classically, P(1l) appears
trivial; constructively it encapsulates the ambient propositional logic,
For U ⊆1l we have U = {⊤| ∗∈U} ({1l} is a basis). Since this join must
be preserved, for any locale, X, there is a unique frame morphism,
ˆ· : P(1l) - O(X), given by ˆU =

{⊤| ∗∈U} ,
(1)
and thus a unique locale morphism X
- 1l to the one-point space.
Open Maps. Any frame provides a model of Heyting’s propositional calculus.
Heyting’s implication is given by, p ⇒q = {r | r∧p ≤q} . Heyting’s implication
⇒is not, in general preserved by a frame morphism. Frame morphisms that do
preserve ⇒correspond to open maps of locales. They also have a simple logical
characterisation [12].

156
M.P. Fourman
Deﬁnition 2. A locale morphism f : A
- B is deﬁned to be: surjective iﬀf ∗
is 1-1; injective iﬀf ∗is onto; open [12, 20]1 iﬀf ∗preserves both  and ⇒.
A locale A is said to be open (and surjective) iﬀthe locale morphism A
- ∗
is open (and surjective).
Remark 1. ([12] V.1;
A Lemma 1.5.8) Since a frame morphism f ∗preserves ,
it has a right adjoint, f∗, given by f∗A = {B | f ∗B ≤A} . Dually, f ∗preserves
, iﬀit has a left adjoint, f!, given by f!A = {B | A ≤f ∗B} , in which case
f ∗preserves ⇒iﬀf! satisﬁes the Frobenius Condition: f!(A∧f ∗(B)) = f!A∧B .
Lemma 1. The locale morphism A
- ∗is open iﬀit preserves  .
Proof. (c.f. [12] Chapter V 3.1) For U, V ⊆1l
U ≤V
iﬀ
∗∈U →∗∈V
iﬀ
U = 1l →V = 1l
(2)
Assuming we have a left adjoint ! ⊣ˆ· , so that !U ≤p iﬀU ≤ˆp , obviously

p ⇒q ≤ˆp ⇒ˆq . It remains to show ˆp ⇒ˆq ≤
p ⇒q . Equivalently it suﬃces to
show, assuming U ∧ˆp ≤ˆq that U ≤
p ⇒q . Now the following are equivalent:
U ≤
p ⇒q
iﬀ
!U ≤p ⇒q
iﬀ
p ∧!U ≤q .
Assuming U ∧ˆp ≤ˆq, we apply (2) to show the last of these. If p ∧!U = 1l then
p = 1l , so ˆp = ⊤. Substituting ⊤for ˆp in our assumption tells us that U ≤ˆq , so
!U ≤q; but we also know that !U = 1l , so q = 1l .
⊓⊔
As an exercise in this form of constructive argument, we give a direct proof of
the Frobenius condition.
Lemma 2. (
p. 618) If the inverse image of locale map A
- ∗has a left
adjoint, ! ⊣ˆ· then it satisﬁes the Frobenius condition !(U ∧ˆp) = !U ∧p .
Proof. By adjointness, !(U ∧ˆp) ≤!U ∧p . To show equality, assume !U ∧p = 1l
then !U = 1l and p = 1l so ˆp = ⊤and !(U ∧ˆp) = !U = 1l .
⊓⊔
Any frame, O(X) , can be used to provide an O(X)-valued interpretation, as in
[16], of the impredicative higher-order logic (HAH). This is the interpretation of
HAH in the localic topos, Sh(X) , of sheaves on X .
Example 1. Given a locale morphism πA : A - X we deﬁne an O(X)-valued
poset O(A/X ) with underlying set O(A). For U, V ∈O(A) we deﬁne
U = V  =
4
p ∈O(X) | U ∧πA∗(p) = V ∧πA∗(p)
5
(3)
U ≤V  =
4
p ∈O(X) | U ∧πA∗(p) ≤V ∧πA∗(p)
5
(4)
1 Our earlier paper on Formal Spaces [10] betrayed an unfortunate confusion: our Def-
inition 2.9 of open map omitted the Frobenius condition. We are grateful to the eagle-
eyed Peter Johnstone for pointing this out in his review, MR0717242 (85c:03023).
The statement of Theorem 2 (below) appears already as Lemma 2.12 of [10], but in
the context of this weaker deﬁnition of ‘open’—thus making a weaker claim. Lemma
1 provides the necessary buttress to our earlier proof.

Continuous Truth II: Reﬂections
157
This O(X)-valued poset can be viewed a frame within the O(X)-valued inter-
pretation. In fact, every internal frame in a localic topos arises in this way
[10]. Given πB : B - X, a map f ∗: O(A) - O(B) represents an internal map
f ∗: O(A/X ) - O(B/X ) iﬀit is extensional in the sense that,
for all U, V ∈O(A), we have U = V  ≤f ∗U = f ∗V  .
(5)
Extensional maps correspond to commuting triangles π∗
A = π∗
Bf ∗.
Lemma 3. For any extensional map
f ∗: O(A/X ) - O(X/X ), we have f ∗(V ) ∧p ≤f ∗(V ∧πA
∗(p)) .
(6)
Proof. It follows from (3) that, p ≤U = V  iﬀU ∧πA∗(p) = V ∧πA∗(p) . Since
p ≤V = V ∧πA∗(p) , we have p ≤f ∗(V ) = f ∗(V ∧πA∗(p)) , and thus,
f ∗(V ) ∧p ≤f ∗(V ∧πA∗(p)) . This is the semantic counterpart to Lemma 2.
⊓⊔
Proposition 1. [12] The locale morphism πA : A - X is open (and surjec-
tive) iﬀthe the O(X)-valued poset O(A/X ) it represents is internally open (and
surjective).
Proposition 2. An element U ∈O(X) is said to be positive (Pos(U)) iﬀevery
cover of U is inhabited. A locale, X, is surjective iﬀPos(⊤) , and open iﬀ{U |
Pos(U)} is a basis for O(X). 2
Formal Spaces. are locales presented as spaces of models for some, possibly
inﬁnitary, geometric propositional theory. If x : 1l - X is a point of X, then for
each U ∈O(X), we write x ∈U to mean that ∗∈x∗(U), so x∗(U) = x ∈U .
We can use the same notation, α ∈U = α∗(U), for a generalised point, α,
which is just a morphism α : A - X .
Consider a language L with a set of basic propositions p ∈IP ⊆O(X). An
O(A)-valued model for L is given by a morphism α : A - X . We give each basic
proposition p ∈IP the truth value pα = α∗(p) = α ∈p. We say a sequent,
p ⊢C, where p ∈IP and C ⊆IP, is valid for α iﬀpα ≤{qα | q ∈C} .
Deﬁnition 3. [10] A geometric presentation of a formal space (IP, A) consists
of a structure IP of basic propositions and a collections A of axioms:
IP is a preordered set with conditional ﬁnite meets: if a ﬁnite set has a lower
bound then it has a greatest lower bound. In particular, if IP is inhabited, then
it has a top element ⊤. We write p ↓for {q | q ≤p}. A crible of p is a set
K ⊆p↓, such that ∀q ∈K. q↓⊆K. For K a crible of p and q ≤p, observe that,
K ↾q = K ∩q↓is a crible of q.
A is a covering relation, that is, a set of sequents, p ⊢C, “C is a basic cover
of p”, where p ∈IP and C ⊆p↓, which is stable in the sense that, if p ⊢C, K
is a crible of p with C ⊆K, and q ≤p, then there is some basic cover q ⊢D of
q such that D ⊆K ↾q.
2 These appeared in [10] but are due to Joyal ([12] Chapter V;
Lemma C3.1.7).

158
M.P. Fourman
A crible, K of ⊤is closed iﬀfor all basic covers p ⊢C, if C ⊆K then p ∈K.
The closed cribles are the formal opens O(IP, A) of the formal space.
We say the formal space is separable if IP is countable and has decidable
equality.
O(IP, A) is a frame. The corresponding locale is the formal space (IP, A) of
models of the presentation. Geometrically a sequent, p ⊢C, is a cover; logically
we read it as an entailment, where the right-hand side is an implicit disjunction.
When presenting a formal space we often write a cover as a formal disjunction—
this can be viewed as simply a suggestive notation for a set of basic propositions.
Proposition 3. The formal space (IP, A) is open if for every cover p ⊢C ∈A,
C is inhabited. In this case, if IP is inhabited the space is surjective.
Deﬁnition 4. A O(X)-valued model of (IP, A) is an assignment of a truth value
p ∈O(X) to each basic proposition such that:
p ≤q →p ≤q
⊤ = ⊤
p ∧q ≤

{p ∧q}
(7)
p ≤

{q | q ∈C} for each axiom p ⊢C ∈A .
(8)
Morphisms, α∗: O(IP, A) - O(X) , from a locale X to a formal space (IP, A)
correspond to O(X)-valued models. Since each p ∈IP is a basic open of the
formal space, we write α ∈p for α∗(p).
Examples. For each example below, the basic opens are well-known from math-
ematical practice, and we adjust our notation accordingly — for example, to
axiomatise a real number, we write p < r < q in place of r ∈(p, q).
For any set X, the discrete formal space, X, is given by X = X⊤, the poset
obtained by adjoining a (new) top element, ⊤, with ∀x ∈X. x < ⊤, together
with a single axiom:
X
⊤⊢

x∈X
α = x
(9)
Each basic open is a singleton; we write α = x for the basic proposition x. The
corresponding frame is the power set, O(X, ⊤⊢X) = P(X). A P(1l)-valued
model, corresponds to a point of the formal space of models of (IP, A) . A P(X)-
valued model corresponds to a function: an X-indexed family of models.
If (IP, A) and (Q, B) are formal spaces, their product is given by (IP×Q, A+B)
where IP × Q has the product (pointwise) preorder and A + B includes both
4
(p, q) ⊢C × {q} | p ⊢A C
5
and
4
(p, q) ⊢{p} × C | q ⊢B C
5
.
If X = (IP, A) is a formal space, and X is a set then the formal product
space is X X = (X ⊗IP, X ⊗A). We introduce a formal α : X - X. The basic
proposition (x, p) should be read as x ∈α∗(p).
Here, X ⊗IP consists of those ﬁnite subsets F ⊆X × IP satisfying the com-
patibility condition: (x, p) ∈F ∧(x, q) ∈F →(x, p ∧q) ∈F , ordered by,
F ≤G iﬀ∀(x, p) ∈G. p = ⊤∨∃q ≤p. (x, q) ∈F .
(10)

Continuous Truth II: Reﬂections
159
We say (x, p) is compatible with F ∈X ⊗IP iﬀfor every q such that (x, q) ∈F
the meet p ∧q is deﬁned. In this case, we write
F ⊕(x, p) for F ∪{(x, p)} ∪{(x, p ∧q) | (x, q) ∈F} .
X ⊗A includes a family of covers for each cover p ⊢C ∈A. For each (x, p)
compatible with F we have a cover F ⊕{(x, p)} ⊢
4
{F ⊕{q} | q ∈C
5
. This con-
structive presentation of a product of locales is a (very) special case of Hyland’s
construction of exponents [21] Proposition 3: a discrete space is locally compact!
Formal Baire Space, B, is the formal space of models of the theory of a function
α : IN - IN; for brevity we call it simply the formal space of functions α ∈ININ .
Similarly, formal Cantor Space, C, is the formal space of functions α ∈2IN. The
basic opens correspond to ﬁnite initial segments of an inﬁnite sequence: a ≺α
is the proposition represented by a ∈T = X<IN, the tree of ﬁnite sequences,
where X is IN or 2, respectively. In any model, ⊤⊢⟨⟩≺α, since ⟨⟩= ⊤. We
also require:
B
a ≺α ⊢

n∈IN
aˆn ≺α
for each a ∈T = IN<IN,
(11)
C
a ≺α ⊢aˆ0 ≺α ∨aˆ1 ≺α
for each a ∈T = 2<IN,
(12)
where, aˆn is the extension of a by n. So, a model corresponds to an inﬁnite path
through the tree. We could, of course, construct these as exponents of discrete
spaces.
The formal Dedekind Reals, R, axiomatise an open cut in the rationals. Our
basic propositions are proper, rational open intervals, (p, q) with p < q, where
p, q ∈Q∗= Q ∪{−∞, ∞}. These intervals are ordered by inclusion. We write
p < r < q, for r ∈(p, q). The covering axioms are:
R
p < r < q ⊢

{p′ < r < q′ | p < p′ < q′ < q}
p < r < q ⊢p < r < q′ ∨p′ < r < q where, p < p′ < q′ < q
(13)
Deﬁnition 5. [17] A locale A is T1 iﬀfor every locale X, the specialisation
ordering on the set of X-valued points [X, A] is trivial: x ≤y →x = y, or,
equivalently, if every localic topos, Sh(X) satisﬁes
∀x, y ∈Pt(A). ∀U ∈O(A). (x ∈U →y ∈U) →x = y .
Lemma 4. Each of X, B, C, R is T1. if A is T1 then so is AX for any set X.
Proof. For Baire space and Cantor space this is straightforward, since the values
α(n) = m, where m, n ∈IN, determine α, which is single-valued.
Lemma
1.2.17 tells us that since R is regular, it is T1 (there called TU), but a direct
constructive proof “in the internal logic” is instructive.
Suppose s ≤r, are generalised points of R: that is, for any U ∈O(R) , if
s ∈U then r ∈U (it suﬃces to assume this for every proper rational interval

160
M.P. Fourman
U). For p < q < q′ < p′, let P = (p, p′) and Q = (q, q′). It suﬃces to show that,
if r ∈Q then s ∈P, since such proper subintervals cover P. Let W be such that
W ∧Q = ⊥and W ∨P = ⊤in O(R) . (if such an W exists we say Q ◁P; in
this case, it can be chosen as the join of two basic intervals.) Certainly s ∈P
or s ∈W, since W ∨P = ⊤. So s ∈P or r ∈W. Now suppose r ∈Q; this is
incompatible with r ∈W, since W ∧Q = ⊥, so we conclude that s ∈P.
Tracing the interpretation of this argument would give an algebraic proof: a
sequence of inequalities starting from the assumption that s ∈U ≤r ∈U
and showing for the chosen basic opens Q ◁P that r ∈Q ≤s ∈P .
⊓⊔
Lemma 5. If A = (IP, A) is a formal space, and we lift the presentation to
Sh(X) then the corresponding internal locale — the interpretation of the (lifting
of the) presentation in Sh(X) — is represented by the projection X × A - X,
where X × A is the product locale.
Proposition 4. If A
- X is a morphism of locales, then the correspond-
ing geometric morphism Sh(A) - E = Sh(X) is equivalent to the extension
Sh
E (A/X )
- E = Sh(X).
Adjoint Retracts. Now consider two formal spaces, P = (IP, A) and Q = (Q, A),
where IP ⊆Q is a subset, with the inherited preorder, closed under conditional
ﬁnite meets: if a ﬁnite subset of IP has a meet in Q then its meet is in IP.
These presentations have possibly diﬀerent posets of basic propositions, but the
same axioms, which must mention only propositions in IP . Clearly the map
i∗: O(Q, A) - O(IP, A), given by V
- V ∩IP, is a frame morphism, that
also preserves . So it has both right (i∗) and left (i!) adjoints:
U
i∗- 4
q | ∀p ≤q. p ∈U
5
U
i!- 4
q | ∃p ∈U. q ≤p
5
O(IP, A)
i∗
-
 i∗= r∗
i!= r∗-
O(Q, A)
Lemma 6. [18] In the situation just described, i! preserves ∧, so we have an ad-
joint retraction P
⊂-

Q of locales. For any T1 locale, X, we have an equivalence
L[P, X] ∼= L[Q, X].
3
Reﬂections
A reﬂection principle in set theory asserts that some property of the class of all
sets is reﬂected already in some set, and thus serves to extend the universe of
discourse and reduce incompleteness. A proto-example might be the introduction
of an inﬁnite set by reﬂection on the closure of the class of all sets under the
successor operation x
- x ∪{x}. (See e.g. [22] for more elevated examples.)
Brouwer’s introspection serves a similar philosophical purpose. It is natural
to ask whether iterating Brouwer’s second act leads to further insights. We say

Continuous Truth II: Reﬂections
161
that an extension is reﬂexive if truth in the iterated model is reﬂected to the
model, as described in the Introduction.
3.1
Topological Models
Joyal ﬁrst pointed out that topological models are best viewed as localic models
that introduce a generic point of a formal space. From this perspective, Scott’s
topological model [1, 2] is an extension constructed by adding a generic point
of ININ. From the classical perspective adopted in Scott’s two papers there is no
diﬀerence between the open sets of the space of points of ININ, equipped with
the product topology, and the formal Baire space B [10]. Here we start from a
non-classical base. We take the formal space as the primary object of study.
Classically, the theories R, B, C are complete — which means, in each case,
that the formal space has enough points (to distinguish the formal opens), or
equivalently that the topological opens and formal opens coincide. Construc-
tively, this is not provable in HAH—completeness is equivalent (in HAH), for R,
to the Heine-Borel theorem (IR is locally compact), and for B, C to Brouwer’s
Principle of Bar Induction, and Fan Theorem, respectively [10].
Theorem 1. The O(X)-valued model includes suﬃcient points to distinguish
the formal opens of X , where X may be B, C, or R .
Proof. Our proof is constructive, and does not presume a metatheory in which
X has enough points. Let O(X) = O(IP, A). In the O(X)-valued model, X is
represented by a projection π : X × X
- X . Elements of IP play two rˆoles: in
the ﬁrst dimension (onto which we project), p ∈IP is a basic truth value. In the
second dimension q ∈IP is a basic proposition of the internal presentation of X.
An internal formal open K ∈O(X) is represented by a formal open of X × X,
determined by the values q ∈K, for q ∈IP, which, in turn, are determined by
the sets
4
p ∈IP | p ≤q ∈K
5
.
Internal points are functions α : X
- X , or, equivalently, sections of the
projection [16]. The identity function on X (the diagonal section) gives a generic
point, γ. By deﬁnition, γ ∈q = q↓, for any q ∈IP.
To show that X has enough points it suﬃces to exhibit points αp,q , where
if q = ⊤then p = ⊤, such that αp,q ∈¯q = p ↓; that is, frame morphisms
α∗
a,b : X
- X such that α∗
p,q(q ↓) = p ↓. In the case of the reals, for example,
there is a unique rational linear function that maps one rational open interval to
another; so these functions suﬃce to distinguish formal opens. We leave B and
C as an exercise for the reader.
⊓⊔
Whether the base from which we start is classical or constructive, the localic
model using the formal opens produces an extension π : B[B] - B that
includes a generic point, corresponding to the identity morphism γ : B
- B.
Geometrically, generic means that the points α of B in any topos E
- B corre-
spond to geometric morphisms, E
a- B[B], with α = a∗(γ), making the triangle
commute.

162
M.P. Fourman
E
a
- B[B]
B[B][B]
d - B[B]
B

π
-
B[B]
b
?
π
- B
π
?
Iterating this construction gives us a topos B[B][B]
b- B[B]. Like any topos over
B[B] it includes a point β = b∗γ ∈B; it also includes another point δ ∈B which
is generic for points of B in toposes over B[B]. Since any topos over B[B] is
also a topos over B, we see that δ corresponds to a morphism B[B][B]
d- B[B]
making the square commute. Furthermore, the square is a pullback, by the uni-
versal property of our second extension. Logically, B[B][B] - B classiﬁes pairs
of models of the formal space B. Geometrically, it is given by the formal space
B × B whose points are pairs of points of B.
Classically, it is well-known that B × B ∼= B. The classical proof exhibits a
homeomorphism ININ × ININ ∼= ININ, for example, a zip function that interleaves
two sequences, whose inverse takes α to the pair (even(α), odd(α)). So the double
extension is equivalent to the single extension, and has the same logic. Working
constructively, the same is true, but we must work directly with the formal opens.
The map a↓- (even(a), odd(a))↓gives a homeomorphism of formal spaces.
Entirely analogous remarks hold for formal Cantor space, C, mutatis mutandis,
with T = 2IN. So we have full reﬂection for [5] (2.1) Open Data.
Proposition 5. If B is an elementary topos, B the formal Baire space, and C
the formal Cantor space in B, then B[B][B] ≡B[B] and B[C][C] ≡B[C] as toposes
over B. So, B[B] ⊨φ
iﬀ
B[B] ⊨⌜B[B] ⊨φ⌝, for any formula φ of HAH.
We have no such straightforward reﬂection theorem for R, since R ̸≡R × R .
3.2
Extensions over Sites
Deﬁnition 6. [12] A site (C, J ) is a category C equipped with a covering sys-
tem, J . That is, a collection, J (A), of covers R = {Ai
- A}i∈I , for each ob-
ject A in C, such that: if α : A′
- A and R ∈J (A), then, for some R′ ∈J (A′)
we have R′ ⊆{β : A′′ - A′ | βα ∈ˆR} .
The Fundamental Fibration. [15] Let T = (C, J ) be a site, where C has pull-
backs. The topos of sheaves can be viewed as an extension B[C, J ] = Sh(C, J ):
the Yoneda embedding provides a universal model of (C, J ) in a topos over our
base, B. Grothendieck showed how the Yoneda embedding Y : C - B[C, J ] can
be viewed as an internal site. We view the codomain projection C2
- C, from
the category of arrows C2 to C as an internal category, C2
/C, whose ﬁbre over a
representable X is the slice category C/X. For α : Y
- X, the restriction map
α∗: C/X - C/Y is given by pullbacks along α .

Continuous Truth II: Reﬂections
163
We have described the internal category C2
/C corresponding to the ﬁbration
∂1 . The topology J also lifts to an internal topology J/C on C2
/C :
if R = {ui : Ai
- A}i∈I is a covering family in C, and β : A - X ∈C/X ,
then Rβ = {ui : uiβ
- β}i∈I covers in C/X.
To give an external representation of this extension, letJ 2 be the topology on C2
with covering families as follows: If R = {ui : Ai
- A}i∈I is a covering family in
C, and β : A - X ∈C/X , then Rβ = {ui : uiβ
- β}i∈I covers β : A - X.
If, furthermore, δ : X
- A then the pullbacks δ∗ui : Ai ×A X - X below cover
δ : X
- A :
Ai
ui
- A
Ai ×A X
δ∗ui - X
X

β
-
Ai
?
ui
- A
δ
?
.
The codomain morphism ∂1 : C2
- C gives a geometric morphism,
∂1 : Sh(C2, J 2) - Sh(C, J ) ,
whose inverse image is composition with ∂1 followed by sheaﬁﬁcation; and whose
direct image is given by composition with the inclusion Δ : C
- C2, which
takes each object to its identity morphism. The inverse image just constructs
internal constant sheaves, and the direct image takes global sections. Since Δ
preserves covers and ∂1 ⊣Δ, this is a case of Theorem 4 of M&M §VII.10 .
Proposition 6
The geometric morphism ∂1 : Sh(C2, J 2) - E = Sh(C, J )
is equivalent to the extension Sh
E (C2
/C, J ∗) - E = Sh(C, J ) .
We now investigate the logical properties of the iterated extension. Just as in
the localic case, it suﬃces to ﬁnd some functor comparing 6
C
  and 7C . We have
three functors ∂1 ⊣Δ ⊣∂0 . These all preserve covers, so ∂1 and Δ have the
cover lifting property (M&M §VII.10 Lemma 3).
Lemma 7. ∂0 also has the cover lifting property.
Proof. If R = {Xi - X}i∈I is such that both ∂0(R) = {∂0(Xi) - ∂0(X)}i∈I
and ∂1(R), deﬁned similarly, are covers in C, then R is a cover in C2.
Suppose X = π : X
- Y and R = {ui : Xi - X}i∈I is a cover in C then
the morphisms, (ui, 1lY ), from the objects R/Y = {uiπ : Xi - Y }i∈I in C2 ,
to X, form a cover in J 2 .
We are now in the situation where each of the adjoint functors ∂1 ⊣Δ ⊣∂0
preserves covers and has the cover lifting property. Therefore (M&M §VII.10), we

164
M.P. Fourman
have three geometric morphisms whose inverse images are given by composition
(e.g. ∂∗
0(A) = ∂0A), followed by sheaﬁﬁcation. We write 7C for Sh(C) .
6
C2
∂0-

∂1
- 7C
6
C2 

∂∗
1
7C 
Δ∗
∂1∗= ∂0!
6
C2 
∂∗
0
Δ∗
7C
(14)
Both Δ∗and ∂0
∗preserve sheaves, so, for them, sheaﬁﬁcation is unnecessary.
Since Δ∂0 = 1lC we have an adjoint retraction 7C
⊂Δ-

δ0
6
C2 , and ∂0 is a surjection.
We have ∂0! = Δ∗⊣∂∗
0 and, since these functors preserve sheaves,
Δ∗(B ×
C2 ∂∗
0(A)) = (ΔB ×C Δ∂0A) = ΔB ×C A = Δ∗(B) ×C A ;
(15)
the Frobenius condition holds. This means that ∂0 is locally connected, hence
open; it preserves exponentials and ﬁrst-order logic. In fact, we are in the sit-
uation described by Moerdijk and Reyes [23] Theorem 2.2: ∂0 is a left-exact
functor which preserves covers and has the covering lifting property; Δ ⊣∂0 is
a left-adjoint “right inverse”, Δ∂0 = 1lC . This gives a principle of predicative
reﬂection.
Proposition 7. [23] ∂∗
0 preserves and reﬂects ﬁrst-order logic, preserves expo-
nentials, and preserves the sheaf of points of any T1 formal space.
So, Sh(C, J ) ⊨
φ
iﬀ
Sh(C, J ) ⊨⌜Sh(C2
/X , J ∗) ⊨φ⌝, for φ a formula
in a language for predicative analysis — a language with ﬁnite types over IN, R,
possibly with constants for relations and functions in Sh(C, J ).
We might hope for an impredicative reﬂection, but this seems unlikely for ex-
tensions over sites. Extensions that preserve powersets are quite special.
Lemma 8. Let C, J ) be a site. If Ω(B), the frame of closed cribles of some
B ∈C0 , is isomorphic to a powerset P(X), then X is a singleton, and every
inhabited sieve contains 1lB. 3
Proof. Let φ be the composite X - P(X) - Ω(B) be the composite of the
singleton map with the isomorphism. Then, since X = 	4
{x} | x ∈X
5
, we
have 1lB ∈	4
φ(x) | x ∈X
5
. Thus, for some x ∈X we have 1lB ∈φ(x) , so,
φ(x) = ⊤. Furthermore, given such an x, for all y ∈X we have φ(y) ≤φ(x) ,
whence {y} ⊆{x}; ergo, y = x.
⊓⊔
Theorem 2. If ECop is an atomic topos then C is a groupoid in E.4
Proof. This is a direct consequence of the lemma since Barr and Diaconescu
show (op. cit.) that for each object A in an atomic topos Γ(ΩA) is isomoprphic
to some P(X).
⊓⊔
3 A classical proof of this fact appears in [24] (§7 Example 2). Here we give a con-
structive proof that can be interpreted in any elementary topos.
4 This is implicit in [12] VII.4 . Barr and Diaconescu use their classical version of the
lemma to prove this for a Boolean base topos, E. (
Corollary C3.5.2).

Continuous Truth II: Reﬂections
165
3.3
Continuous Truth
Deﬁnition 7. A topological site is a category of open locales and continuous
maps, including enough open inclusions (a basis for each locale), closed under
ﬁnite limits, and equipped with the open cover topology.
This deﬁnition diﬀers from those of [18, 23]; Moerdijk and Reyes use topological
spaces to construct their topological sites; we use locales. They, therefore, have to
appeal to principles such as Bar Induction, or Fan Theorem, in the metatheory
in order to show they hold in the topos of sheaves.
In [6] §4, we claimed, with proofs formalisable in HAH, that general principles
of continuity, local choice and local compactness hold for these models. The proof
of the key result, Proposition 4.1, presumes that a projection π : W × U
- U
is a cover for the open cover topology. This is true if W is an open surjective
locale, but obviously not in general—consider the empty space. The remedy is
to require that the site (C, J ) introduced in the opening sentence of §4 should
be a topological site, whose objects are open locales. The results claimed in §4
are then valid if we take any elementary topos with natural number object as a
base. We restate and prove Proposition 4.1.
Theorem 3. Let (C, J ) be a topological site. For any X ∈C, the internal locale,
X represented by, O(X)(U) = O(U × X), has enough points.
Proof. We must show that, if U ⊩K covers Pt(W) and U ⊩K is closed, then
U ⊩W ∈K , for U ∈C, and W ∈O(X) . We assume the hypotheses, and let
IK = {Ui × Wi | Ui ⊩Wi ∈K↾Ui}
(16)
Clearly, IK is a closed crible of O(U) × O(X), that is, an open in O(U × X) . We
will show that IK covers U × W, so U × W ∈IK, which means that U ⊩W ∈K .
We pull back along the projection π2 : W × U
- U . This introduces a generic
point of W given by π1 : W × U - W . We have, W ×U ⊩K↾π2 covers Pt(W) ,
by persistence. In particular, the generic point is covered:
W × U ⊩K↾π2 covers π1
that is, W × U ⊩∃V ∈K↾π2. π1 ∈V .
V ranges over basic opens of X. By unpacking the forcing deﬁnition, we see that
IK∗= {Wi × Ui | for some V ≤W, Wi × Ui ⊩V ∈K↾π2 ∧π1 ∈V }
(17)
covers W × U . We now show that every basic open W × U ∈IK∗is in IK. Given
U, V, W such that W × U ⊩V ∈K↾π2 ∧π1 ∈V we must show U ⊩W ∈K.
First, W × U ⊩π1 ∈V iﬀW ≤V , so, by monotonicity, W × U ⊩W ∈K↾π2.
Second, W is open surjective, so π2 is an open surjection; viewed as a basic open
in O(X) , W is constant, so U ⊩W ∈K .
⊓⊔
We observe that this proof does not require that every object of C be surjective,
indeed a subcategory of L with only open surjective objects will seldom be closed
under limits. However, if W is a positive open of any open space, like the W in

166
M.P. Fourman
the ﬁnal steps of the proof just given, then W, as a subspace in its own right,
is open surjective. Any open space is surjective in so far as its positive basis is
inhabited. Nor do we require a full subcategory of L, so the result should apply,
for example, to a suitable localic version of the Euclidean topos, of sheaves over
the category of closed subspaces of IRn with C∞functions, deﬁned by Moerdijk
and Reyes [23], and other smooth topoi.
Proposition 8. If (C, J ) is a topological site and X ∈C, then the inclusion
functor i : O(X) - C/X has a right adjoint π which induces an adjoint retract
pair of geometric morphisms i : Sh(X)
⊂i-

π
Sh(C/X) . So, π∗preserves and re-
ﬂects ﬁrst-order logic, preserves exponentials, and preserves the sheaf of points
of any T1 formal space.
Proof. The right adjoint π is given by f
- 
{U | U factors through f}, which
satisﬁes the conditions of [23] Theorem 2.2 . So Proposition 7 applies. (The spa-
tial counterpart of this proposition appears in M&M (§VII.10 Theorem 5 ﬀ.).
To show a predicative reﬂection principle, we must choose a suitable topological
site (C, J ) with extension E = ShB(C, J ); then provide a representation of the
iterated extension ShE(C, J ) as ShB(C†, J †), together with a left-exact functor
C†
- C which preserves covers, and has the covering lifting property and a
left-adjoint “right inverse”.
Conjecture 1. Let (C, J ) be the topological site of open subspaces of separa-
ble open locales with open maps, with the open cover topology, then (C2, J 2)
provides a representation of the corresponding internal site.
This general setting should provide reﬂection principles for several of the exten-
sions introduced in [5]: (2.2) Independent Open Data , (2.3) Lawless Data, and
(2.4) Spread Data. One key point is that the category of open spaces with open
maps is closed under ﬁnite limits.
To extend such an account to more general examples, such as (2.5) Continuous
Data, will require further analysis of the constructive theory of the category of
open locales and continuous maps.
Acknowledgements. I am grateful to B´enabou for hosting my extended visit
to S´eminaire B´enabou in 1975, my introduction to ﬁbrations; to Andr´e Joyal for
formal spaces; to Thomas Streicher & Peter Johnstone for writing things down;
and to Martin Hyland, Alex Simpson, John Longley, and Mart´ın Escardo for
more recent discussions.

Continuous Truth II: Reﬂections
167
References
1. Scott, D.S.: Extending the topological interpretation to intuistionistic analysis.
Compos. Math. 20, 194–210 (1968)
2. Scott, D.S.: Extending the topological interpretation to intuitionistic analysis, II.
In: Kino, A., Myhill, J., Vesley, R.E. (eds.) Intuitionism and Proof Theory: Proc.
Buﬀalo, N.Y., 1968. Stud. Logic Found. Math., vol. 60, pp. 235–255. Elsevier B.V.
(1970) ISBN: 978-0-7204-2257-3
3. Fourman, M.P.: Continuous truth. Abstr. Amer. Math. Soc. (1981) (abstract) 81-
T-03-135
4. Fourman, M.P.: A model for the theory of choice sequences (CS). Abstr. Amer.
Math. Soc., 183 (1982) (abstract) 82-T-03-80
5. Fourman, M.P.: Notions of choice sequence. In: [25], pp. 91–105
6. Fourman, M.P.: Continuous truth I, non-constructive objects. In: Lolli, G., Longo,
G., Marcja, A. (eds.) Logic Colloquium: Florence, 1982. Stud. Logic Found. Math.,
pp. 161–180. North-Holland (1984)
7. van der Hoeven, G., Moerdijk, I.: On choice sequences determined by spreads.
JSL 49, 908–916 (1984)
8. van Dalen, D. (ed.): Brouwer’s Cambridge lectures on intuitionism. CUP (1981)
ISBN: 0521234417
9. Xu, C., Escard´o, M.: A constructive model of uniform continuity. In: Hasegawa,
M. (ed.) TLCA 2013. LNCS, vol. 7941, pp. 236–249. Springer, Heidelberg (2013)
10. Fourman, M.P., Grayson, R.J.: Formal spaces. In: [25], pp. 107–122
11. Johnstone, P.T.: Sketches of an Elephant: a topos theory compendium. Oxford
Logic Guides, vol. 43-44. OUP (2002) ISBN: 9780198524960
12. Joyal, A., Tierney, M.: An extension of the Galois theory of Grothendieck. Mem.
Amer. Math. Soc., vol. 309. AMS (1984) ISBN: 0821823124
13. Mac Lane, S., Moerdijk, I.: Sheaves in Geometry and Logic; A First Introduction
to Topos Theory. Springer (1992)
14. Grayson, R.J.: Forcing in intuitionistic systems without power-set. JSL 48, 670–682
(1983), http://www.jstor.org/stable/2273459
15. Streicher, T.: Fibred categories `a la Jean B´enabou. PDF document (1999-2012),
http://www.mathematik.tu-darmstadt.de/~streicher/FIBR/FibLec.pdf
16. Fourman, M.P., Scott, D.S.: Sheaves and logic. In: Fourman, M.P., Mulvey, C.J.,
Scott, D.S. (eds.) Applications of Sheaves. Lect. Notes Math., vol. 753, pp. 302–401.
Springer (1979) ISBN: 0-387-09564-0
17. Grayson, R.J.: Concepts of general topology in constructive mathematics and
sheaves. Ann. Math. Logic 20, 1–41 (1981)
18. Fourman, M.P.: T1 spaces over topological sites. JPAA 27, 223–224 (1983)
19. Johnstone, P.T.: Stone Spaces. Cam. St. Adv. Math., vol. 3. CUP (1986) ISBN:
978-0-5213-3779-3
20. Johnstone, P.T.: Open maps of toposes. Manuscripta Math. 31, 217–247 (1980)
21. Hyland, J.: Function spaces in the category of locales. In: Continuous Lattices
(Proc. Bremen workshop, 1979). Lect. Notes Math., pp. 264–281. Springer (1981)
22. Koellner, P.: On reﬂection principles. Ann. P. Appl. Logic 157, 206–219 (2009)
23. Moerdijk, I., Reyes, G.E.: Smooth spaces versus continuous spaces in models for
synthetic diﬀerential geometry. JPAA 32, 143–176 (1984)
24. Barr, M., Diaconescu, R.: Atomic toposes. JPAA 17, 1–24 (1980)
25. Troelstra, A.S., van Dalen, D. (eds.): The L.E.J. Brouwer Centenary Symposium.
Stud. Logic Found. Math., vol. 110. North-Holland (1982) ISBN: 0-444-86494-6

A Simple Separation Logic
Andreas Herzig
University of Toulouse, CNRS
Institut de recherche en informatique de Toulouse (IRIT)
Toulouse, France
www.irit.fr/˜Andreas.Herzig
Abstract. The kinds of models that are usually considered in separation logic
are structures such as words, trees, and more generally pointer structures (heaps).
In this paper we introduce the separation logic of much simpler structures, viz.
sets. The models of our set separation logic are nothing but valuations of classical
propositional logic. Separating a valuation V consists in splitting it up into two
partial valuations v1 and v2. Truth of a formula ϕ1 ∗ϕ2 in a valuation V can then
be deﬁned in two diﬀerent ways: ﬁrst, as truth of ϕ1 in all total extensions of v1
and truth of ϕ2 in all total extensions of v2; and second, as truth of ϕ1 in some
total extension of v1 and truth of ϕ2 in some total extension of v2. The ﬁrst is an
operator of separation of resources: the update of ϕ1 ∗ϕ2 by ψ is the conjunction
of the update of ϕ1 by ψ and the update of ϕ2 by ψ; in other words, ϕ1 ∗ϕ2 can
be updated independently. The second is an operator of separation of processes:
updates by ψ1∗ψ2 can be performed independently. We show that the satisﬁability
problem of our logic is decidable in polynomial space (PSPACE). We do so by
embedding it into dynamic logic of propositional assignments (which is PSPACE
complete). We moreover investigate its applicability to belief update and belief
revision, where the separation operators allow to formulate natural requirements
on independent pieces of information.
1
Introduction
Separation logics [7, 13, 17] have a modal operator ∗which allows to talk about the
separation of resources. Basically, the formula ϕ1 ∗ϕ2 is true in the model M if M can
be split into two parts M1 and M2 such that ϕ1 is true in M1 and ϕ2 is true in M2. The
kinds of models that are usually considered in separation logic are structures such as
words, trees, and more generally pointer structures (heaps). The separation logics of
such structures are often undecidable. In this paper we investigate the separation logic
of much simpler structures, viz. sets. We call our logic set separation logic, abbreviated
SSL. The models of SSL are nothing but valuations of classical propositional logic.
Separating a valuation V consists in splitting it up into two partial valuations v1 and v2.
Then separability of ϕ1 and ϕ2 in a valuation V can be deﬁned in two diﬀerent ways:
ﬁrst, as truth of ϕ1 in all total extensions of v1 and truth of ϕ2 in all total extensions
of v2; and second, as truth of ϕ1 in some total extension of v1 and truth of ϕ2 in some
total extension of v2. We respectively denote these two separation operators by ˙∧and
˙∥. We chose the symbol ˙∧due to its analogy with the symbol of disjoint union ˙∪, and
we chose the symbol ˙∥because ∥denotes parallel execution.
L. Libkin, U. Kohlenbach, and R. de Queiroz (Eds.): WoLLIC 2013, LNCS 8071, pp. 168–178, 2013.
c⃝Springer-Verlag Berlin Heidelberg 2013

A Simple Separation Logic
169
We show that the satisﬁability problem of set separation logic is decidable in polyno-
mial space (PSPACE). We do so by embedding SSL into dynamic logic of propositional
assignments DL-PA [2], whose star-free fragment is PSPACE complete. This contrasts
with separation logics having the implicational connective −∗, which are often undecid-
able even in the proopositional language [4,11].
Our initial motivation to investigate separation operators was that they can be given
an interesting interpretation in the context of the revision and update of propositional
belief bases: we consider that when ϕ1 and ϕ2 are separable then they are independent
pieces of information. This naturally leads to the following requirements.
– We suppose that ˙∧expresses independence of resources: the update of ϕ1 ˙∧ϕ2 by
ψ is the conjunction of the update of ϕ1 by ψ and the update of ϕ2 by ψ; in other
words, ϕ1 ˙∧ϕ2 can be updated independently.
– We suppose that ˙∥expresses independence of processes: the update of ϕ by ψ1 ˙∥ψ2
is the parallel update of ϕ by ψ1 and by ψ2; in other worlds, updates by ψ1 ˙∥ψ2 can
be performed independently.
This extends previous approaches by Parikh, Makinson and others that are based on
splitting languages [3,10,14]. We investigate the compatibility of existing belief change
operations with the above two requirements.
The paper is organised as follows. In Section 2 we introduce set separation logic
SSL. In Section 3 we provide a PSPACE upper bound for both its model checking
and its satisﬁability problem. In Section 4 we discuss the relation between SSL and
language splitting-based belief change. Section 5 concludes.
2
Set Separation Logic SSL
Throughout the paper we use the following conventions.
P = {p, q, . . .} is a countable set of propositional variables. The set {P1, P2} is a
partition of P iﬀP1 ∪P2 = P and P1 ∩P2 = ∅.
A valuation is a total function from P to {0, 1}. We use V, V1, ...for valuations. Two
valuations V and V′ agree on the set of variables P ⊆P, if both give the same truth
value to each of the variables in P: V ∼P V′ iﬀV(p) = V′(p) for every p ∈P.
A partial valuation is a partial function from P to {0, 1}. For a valuation V : P −→
{0, 1} and a set of propositional variables P ⊆P, the restriction of V to P is the partial
function whose domain is P, noted V|P. We use v, v1, ...for partial valuations. The
total valuation V is an extension of the partial valuation v if V(p) = v(p) for every
p ∈dom(v).1
The language of SSL is deﬁned by the following grammar:
ϕ  p | ¬ϕ | ϕ ∧ϕ | ϕ ˙∧ϕ | ϕ ˙∥ϕ
where p ranges over the set of propositional variables P. The formula ϕ ˙∧ψ may be
read “ϕ and ψ are statically separable” and ϕ ˙∥ψ may be read “ϕ and ψ are dynamically
1 We might as well deﬁne valuations to be sets of propositional variables. However, it would
have been less elegant to account for partial valuations under such a presentation.

170
A. Herzig
separable”. Our intuition is the following: when ϕ ˙∧ψ is true then the conjunction of ϕ
and ψ can be updated separately; and when ϕ ˙∥ψ is true then updating by the conjunction
of ϕ and ψ can be performed in parallel.
We abbreviate the logical connectives ∧, →and ↔in the usual way.
The truth conditions are as follows:
V |= p iﬀV(p) = 1;
V |= ¬ϕ iﬀV ̸|= ϕ;
V |= ϕ1 ∧ϕ2 iﬀV |= ϕ1 and V |= ϕ2;
V |= ϕ1 ˙∧ϕ2 iﬀthere is a partition {P1, P2} of P such that
V1 |= ϕ1 for every valuation V1 agreeing with V on P1 and
V2 |= ϕ2 for every valuation V2 agreeing with V on P2;
V |= ϕ1 ˙∥ϕ2 iﬀthere is a partition {P1, P2} of P such that
V1 |= ϕ1 for some valuation V1 agreeing with V on P1 and
V2 |= ϕ2 for some valuation V2 agreeing with V on P2.
The conditions for the two separation operators can be reformulated in terms of partial
valuations as follows:
V |= ϕ1 ˙∧ϕ2 iﬀthere is a partition {P1, P2} of P such that
V1 |= ϕ1 for every extension V1 of V|P1 and
V2 |= ϕ2 for every extension V2 of V|P2;
V |= ϕ1 ˙∥ϕ2 iﬀthere is a partition {P1, P2} of P such that
V1 |= ϕ1 for some extension V1 of V|P1 and
V2 |= ϕ2 for some extension V2 of V|P2.
Some observations:
– In the truth condition for ˙∧, the exhaustiveness condition P1 ∪P2 = P can be
dropped. If we dropped the disjointness condition P1 ∩P2 = ∅then ϕ ˙∧ψ trivialises
to the conjunction ϕ ∧ψ.
– In the truth condition for ˙∥, if we drop the exhaustiveness condition P1 ∪P2 = P
then ϕ ˙∥ψ trivialises to the consistency of both ϕ and ψ.
Here are some examples. Let Vpq be a valuation such that Vpq(p) = Vpq(q) = 1 and let
Vp¯q be a valuation such that Vp¯q(p) = 1 and Vp¯q(q) = 0. Then we have:
Vpq |= p ˙∧q
Vpq |= p ˙∥q
Vpq |= (¬p) ˙∥(¬q)
Vpq |= p ˙∧(p ∨q)
Vpq |= p ˙∥(¬p ∧¬q)
Vpq ̸|= ¬p ˙∥(¬p ∧¬q)
Vp¯q ̸|= p ˙∧(p ∨q)
Vp¯q |= p ˙∥(p ∨q)
Vp¯q |= ¬p ˙∥(p ∨q)
Vp¯q |= p ˙∧(p ∨¬q)
Vp¯q |= p ˙∥(p ∨¬q)
Vp¯q ̸|= ¬p ˙∥¬(p ∨q)

A Simple Separation Logic
171
Satisﬁability and validity are deﬁned as usual. The following formula schemas are valid:
ϕ1 ˙∧ϕ2 ↔ϕ2 ˙∧ϕ1
ϕ1 ˙∥ϕ2 ↔ϕ2 ˙∥ϕ1
ϕ1 ˙∧ϕ2 →ϕ2 ∧ϕ1
ϕ1 ∧ϕ2 →ϕ2 ˙∥ϕ1
⊤˙∧ϕ ↔ϕ
⊤˙∥ϕ ↔
⎧⎪⎪⎨⎪⎪⎩
⊤
if ϕ is satisﬁable
⊥
otherwise
As the last line shows, consistency of a formula ϕ can be expressed in the language of
SSL by the formula ⊤˙∥ϕ. Here are two inference rules preserving validity:
ϕ →ψ
(ϕ ˙∧χ) →(ψ ˙∧χ)
ϕ →ψ
(ϕ ˙∥χ) →(ψ ˙∥χ)
The following equivalences are valid, where the propositional variables p and q are
supposed to be diﬀerent:
p ˙∧p ↔⊥
p ˙∥p ↔p
p ˙∧¬p ↔⊥
p ˙∥¬p ↔⊤
p ˙∧q ↔p ∧q
p ˙∥q ↔⊤
p ˙∧(p ∨q) ↔p ∧q
p ˙∥(p ∨q) ↔⊤
(p ∨q) ˙∧(p ∨q) ↔p ∧q
(p ∨q) ˙∥(p ∨q) ↔⊤
3
Complexity
In this section we establish an upper bound for the complexity of both model checking
and satisﬁability checking of set separation logic. We prove this by showing that both
ϕ1 ˙∧ϕ2 and ϕ1 ˙∥ϕ2 can be expressed in dynamic logic of propositional assignments
DL-PA (that we have recently proposed with Philippe Balbiani and Nicolas Troquard
in [2]) by equivalent formulas whose length is polynomial in the length of ϕ1 ˙∧ϕ2 and
ϕ1 ˙∥ϕ2, respectively.
3.1
DL-PA: Dynamic Logic of Propositional Assignments
The language of DL-PA is deﬁned by the following grammar:
π  p←⊤| p←⊥| ϕ? | π; π | π ∪π | π∗
ϕ  p | ⊤| ⊥| ¬ϕ | ϕ ∨ϕ | ⟨π⟩ϕ
where p ranges over P. So an atomic program of the language of DL-PA is a program of
the form p←ϕ. The operators of sequential composition (“;”), nondeterministic compo-
sition (“∪”), unbounded iteration (“∗”, the Kleene star), and test (“?”) are familiar from
PDL.
We deﬁne Pϕ to be the set of variables from P occurring in formula ϕ, and we deﬁne
Pπ to be the set of variables from P occurring in program π. For example, Pp←q∪p←¬q =
{p, q} = P⟨p←⊥⟩q.

172
A. Herzig
We abbreviate the logical connectives ∧, →and ↔in the usual way. Moreover, [π]ϕ
abbreviates ¬⟨π⟩¬ϕ. The program skip abbreviates ⊤? (“nothing happens”) and the
program p←q abbreviates (q?; p←⊤) ∪(¬q?; p←⊥) (“p gets the truth value of q”).
DL-PA programs are interpreted by means of a (unique) relation between valuations:
atomic programs p←⊤and p←⊥update valuations in the obvious way, and complex
programs are interpreted just as in PDL by mutual recursion. Table 1 gives the interpre-
tation of the DL-PA connectives.
Table 1. Interpretation of the DL-PA connectives
||p←⊤|| = (V, V′) : V′(p) = 1 and V′ agrees with V on P \ {p}
||p←⊥|| = (V, V′) : V′(p) = 0 and V′ agrees with V on P \ {p}
||π; π′|| = ||π|| ◦||π′||
||π ∪π′|| = ||π|| ∪||π′||
||π∗|| =

k∈N0
(||π||)k
||ϕ?|| = {(V,V) : V ∈||ϕ||}
||p|| = {V : V(p) = 1}
||⊤|| = 2P
||⊥|| = ∅
||¬ϕ|| = 2P \ ||ϕ||
||ϕ ∨ψ|| = ||ϕ|| ∪||ψ||
||⟨π⟩ϕ|| = {V : there is V′ s.t. (V, V′) ∈||π|| and V′ ∈||ϕ||}
A formula ϕ is DL-PA valid if ||ϕ|| = 2P, and ϕ is DL-PA satisﬁable if ||ϕ||  ∅. For
example, the formulas ⟨p←⊤⟩⊤and ⟨p←⊤⟩ϕ ↔¬⟨p←⊤⟩¬ϕ are DL-PA valid. Other
examples of DL-PA validities are ⟨p←⊤⟩p and ⟨p←⊥⟩¬p. Observe that if p does not
occur in ϕ then both ϕ →⟨p←⊤⟩ϕ and ϕ →⟨p←⊥⟩ϕ are valid. This is due to the
following semantical property.
Proposition 1. Suppose p  Pϕ, i.e., p does not occur in ϕ. Then ϕ ∈||V ∪{p}|| iﬀ
ϕ ∈||V \ {p}||.
Theorem 1 ( [2]). For the full language, both the DL-PA satisﬁability problem and the
DL-PA model checking problem are EXPTIME complete.
For the star-free fragment, both the DL-PA satisﬁability problem and the DL-PA
model checking problem are PSPACE complete.
3.2
Embedding Set Separation Logic into DL-PA
We now give a polynomial transformation mapping set separation logic formulas ϕ0
into DL-PA formulas.

A Simple Separation Logic
173
Let P′ be the set of variables p′ such that p is in P and p′ is fresh: p′ does not occur
in the formula ϕ0 under consideration. The following abbreviations will be useful:
±p = p←⊤∪p←⊥
changeSome({p1, · · · , pn}) = ± p1; · · · ; ±pn
store({p1, · · · , pn}) = p′
1←p1; · · · ; p′
n←pn
retrieve({p1, · · · , pn}) = p1←p′
1; · · · ; pn←p′
n
changeSomeMarked({p1, · · · , pn}) = ¬(p1 ↔p′
1)? ∪(p1 ↔p′
1?; ±p1);
· · ·
¬(pn ↔p′
n)? ∪(pn ↔p′
n?; ±pn)
changeSomeUnmarked({p1, · · · , pn}) = p1 ↔p′
1? ∪(¬(p1 ↔p′
1)?; ±p1);
· · ·
pn ↔p′
n? ∪(¬(pn ↔p′
n)?; ±pn)
changeRestAndRestore({p1, · · · , pn}) = ((p1 ↔p′
1?; ±p1) ∪(¬(p1 ↔p′
1)?; p1←p′
1));
· · ·
((pn ↔p′
n?; ±pn) ∪(¬(pn ↔p′
n)?; pn←p′
n))
The program changeSome(P) nondeterministically changes the truth value of some vari-
ables in P. The program store(P) stores the truth value of each variable p by means of
a fresh variable p′, and retrieve(P) reestablishes that ‘old’ value. When p and p′ have
diﬀerent truth values then we say that p is marked; else we say that p is unmarked. The
program changeSomeMarked(P) arbitrarily changes only the unmarked variables. The
other way round, the program changeSomeUnmarked(P) leaves every unmarked p ∈P
unchanged and arbitrarily changes the marked p’s.
Observe that each of the above programs has length linear in the cardinality n of the
set of propositional variables {p1, . . . , pn}.
The next two propositions provide an embedding of set separation logic into DL-PA.
Proposition 2. Let ϕ1 and ϕ2 be two propositional formulas. Let P = Pϕ1 ∩Pϕ2. Let
P′ be the set of variables p′ such that p is in P and p′ is fresh: p′ does not occur in
the formula under consideration. Then the formula ϕ1 ˙∥ϕ2 is equivalent to the DL-PA
formula
⟨store(P); changeSome(P)⟩	 ⟨changeSome(Pϕ1 \ P)⟩ϕ1 ∧
⟨changeRestAndRestore(P)⟩⟨changeSome(Pϕ2 \ P)⟩ϕ2

Proposition 3. Let ϕ1 and ϕ2 be two propositional formulas. Let P = Pϕ1 ∩Pϕ2. Let P′
be the set of variables p′ such that p is in P and p′ is fresh: p′ does not occur in the
formula under consideration. Then the formula ϕ1 ˙∧ϕ2 is equivalent to the following
DL-PA formula:
⟨store(P); changeSome(P′)⟩	 [changeSomeMarked(P)]ϕ1 ∧
[changeSomeUnmarked(P)]ϕ2


174
A. Herzig
Intuitively, after the program store(P) has stored the value of each of the elements of
P, the program changeSome(P′) allows to (nondeterministically) identify a subset of P:
those p whose value diﬀers from its copy p′. We consider that these ‘marked’ variables
are those of the partial valuation for ϕ1, while the complementary, unmarked variables
make up the partial valuation for ϕ2.
This can be turned more formally into a transformation from the language of set
separation logic into the language of DL-PA. The transformation is clearly linear in the
size of the original formula ϕ0.
The codomain of the transformation is the star-free fragment of DL-PA. As both
model checking and satisﬁability checking in DL-PA are PSPACE complete, it follows
that model checking and satisﬁability checking in set separation logic are in PSPACE.
It remains to investigate the lower bounds.
4
Separability in the Context of Belief Change Operations
As we have mentioned in the introduction, one can use the SSL operators to formulate
new postulates for belief change operations such as AGM belief revision operators [1,6]
and KM update operators [8,9]. We investigate this now in more depth.
4.1
The Basic Belief Change Postulates
Let ◦be a belief change operator and let β and ψ be boolean formulas. (We use β for the
base and ψ for the input.) β ◦ψ is the result of incorporating the input ψ into the base β.
Both revision and update operations were mainly studied from a semantical perspective:
β ◦ψ is viewed as a set of valuations.
Katsuno and Mendelzon promoted the distinction between belief update and belief
revision [9]. Their idea is that update keeps track of changes in the world while revision
corrects errors about an unchanged world. This can be illustrated by the revised and
updated edition of a dictionary: we say that it has been revised because past errors have
been corrected, and we say that it has been updated because new usages of existing
words have been added to it and outdated usages have been dropped. Traditionally,
β ⋄ψ denotes the update of the base β by the input ψ and β ∗ψ denotes the revision of
the base β by the input ψ.
Alchourr´on, G¨ardenfors and Makinson designed a set of postulates for belief revision
operations (the so-called AGM postulates), and Katsuno and Mendelzon designed a set
of postulates for belief update operations (the so-called KM-postulates). The following
postulates are common to both kinds of operations:
(RE)
if ||β1|| = ||β2|| and ||ψ1|| = ||ψ2|| then β1 ◦ψ1 = β2 ◦ψ2
(SUCCESS) β ◦ψ ⊆||ψ||
(PRESw)
if ||β|| ⊆||ψ|| then β ◦ψ = ||β||
where ||ϕ|| is the set of valuations where ϕ is true (just as in Section 3.1). We call the
above the basic belief change postulates.
RE is a postulate of insensitivity to syntax. SUCCESS says that belief change is
successful: the input has priority. PRESw is a weak preservation postulate: if the input is

A Simple Separation Logic
175
already in the base then the base should not change. AGM revision operations moreover
satisfy a strengthening of PRESw:
(PRES) if ||β|| ∩||ψ||  ∅then β ◦ψ = ||β ∧ψ||
4.2
Belief Change Operations and Language Splitting
It has been observed by many that the drastic update operation deﬁned as
β ◦ψ =
⎧⎪⎪⎨⎪⎪⎩
||β||
if ||β|| ⊆||ψ||
||ψ||
otherwise
satisﬁes the KM postulates. Similarly, the following drastic revision operation
β ◦ψ =
⎧⎪⎪⎨⎪⎪⎩
||β ∧ψ||
if ||β|| ∩||ψ||  ∅
||ψ||
otherwise
satisﬁes the AGM postulates. In order to exclude such operations, Parikh, Makinson
and others argued for a further postulate of relevance [3,10,14]. Its formulation refers
to the syntax of the base and the input.
(REL) (β1 ∧β2) ◦ψ = (β1 ◦ψ) ∩(β2 ◦ψ)
if Pβ1 ∩Pβ2 = ∅
Just as in Section 2, Pϕ denotes the set of propositional variables occurring in the
boolean formula ϕ. Therefore Pβ1 ∩Pβ2 = ∅means that the signatures of β1 and β2
are disjoint: the languages of β1 and β2 can be split. Each of the above drastic opera-
tions violates the postulate REL.
4.3
Separation-Based Belief Change Operations
In the same spirit and as already stated informally in the introduction, the SSL operators
enable us to go beyond such syntax-based postulates and strengthen the above relevance
postulate REL. The strengthening comes in a static version and in a dynamic version:
(RELs) (β1 ˙∧β2) ◦ψ = (β1 ◦ψ) ∩(β2 ◦ψ)
(RELd) β ◦(ψ1 ˙∥ψ2) = (β ◦ψ1) ◦ψ2
= (β ◦ψ2) ◦ψ1
where ◦is any belief change operation, be it update or revision.2 The static relevance
postulate RELs says that when the bases β1 and β2 are statically separable then they can
be updated separately. Its dynamic counterpart RELd says that when the inputs ψ1 and
ψ2 are dynamically separable then the update can be performed in parallel (or rather, in
an interleaving fashion).
It turns out that both postulates are violated by any AGM revision operation and and
any KM update operation.
2 Strictly speaking, RELd requires to build a formula representing the updates β ◦ψ1 and β ◦ψ2,
as usually done in the KM framework.

176
A. Herzig
Proposition 4. There is no operation ◦satisfying both the basic belief change postu-
lates and RELs.
Proof. Suppose ◦satisﬁes the basic belief change postulates and RELs. Consider the
base β = (p ∨q) ˙∧(p ∨q) and the input ψ = p ∨q. We have seen above that β is
equivalent to p ∧q, and we therefore have:
β ◦ψ = (p ∨q) ˙∧(p ∨q) ◦p ∨q
= p ∧q ◦p ∨q
(by RE)
= ||p ∧q||
(by PRESw)
This is incompatible with what postulate RELs gives us:
β ◦ψ = (p ∨q) ˙∧(p ∨q) ◦p ∨q
= p ∨q ◦p ∨q ∩p ∨q ◦p ∨q
(by RELs)
= ||p ∨q|| ∩||p ∨q||
(by PRESw)
= ||p ∨q||
□
Proposition 5. There is no operation ◦satisfying both the basic belief change postu-
lates and RELd.
Proof. Suppose ◦satisﬁes the KM postulates and RELd. Consider the base β = ¬p and
the input ψ = ¬p ˙∥p. We have seen above that ψ is equivalent to ⊤, and we therefore
have:
β ◦ψ = ¬p ◦¬p ˙∥p
= ¬p ◦⊤
(by RE)
= ||¬p||
(by PRESw)
This is incompatible with what postulate RELd gives us:3
β ◦ψ = ¬p ◦¬p ˙∥p
= (¬p ◦¬p) ⋄p
(by RELd)
= ¬p ◦p
(by PRESw)
⊆||p||
(by SUCCESS)
Incompatibility isthecasebecausethesetofvaluationswhere¬p istrueisnonempty.
□
5
Discussion and Conclusion
We have introduced a simple version of separation logic working on sets (alias propo-
sitional valuations) that we have called set separation logic, SSL. Our logic has two
separation operators: ˙∧allows to separate resources, and ˙∥allows to separate updates.
We have shown that in our logic, both model checking and satisﬁability checking can
be done in polynomial space. We conjecture that the PSPACE upper bound that we have
established coincides with the lower bound, but this remains to be proved. We would
also like to provide an axiomatisation.
3 We recall that the second line of the proof is formulated sloppily: instead of the set of valuations
¬p ◦¬p there should be a formula representing that valuation.

A Simple Separation Logic
177
In the last part of the paper we have investigated the relation between SSL and belief
change operations. We have formulated two postulates that appear to be natural and
have shown that they are nevertheless incompatible with both AGM belief revision
operations and KM belief update operations.
The problem of belief change respecting separation that we have studied in the last
section is related to the frame problem in artiﬁcial intelligence [12]. Reiter’s solution
to that problem [15, 16] is by now widely accepted for actions without ramiﬁcations,
i.e., without side eﬀects. In joint work with Hans van Ditmarsch and Tiago de Lima [5]
we have recently shown that Reiter’s solution can be mapped to dynamic logics with
propositional assignments DL-PA. Given that set separation logic can be embedded into
DL-PA, it is immediate to extend it by propositional assignments.
It would be interesting to add the implicational connective −∗of separation logic to
SSL (which should lead to undecidability given the results of [4,11]). it is however not
clear how the semantics of −∗can be deﬁned in the framework of valuations.
Acknowledgements. The work in this paper was done in the framework of the ANR
project DynRes (Dynamic Resources and Separation and Update Logics, project no.
ANR-11-BS02-011). I would like to thank the members of the project for their com-
ments of a (very preliminary) presentation of the ideas that are worked out in more
detail here. Thanks are also due to the reviewers of WoLLIC 2013 whose comments I
took into account as far as I could.
References
[1] Alchourr´on, C., G¨ardenfors, P., Makinson, D.: On the logic of theory change: Partial meet
contraction and revision functions. J. of Symbolic Logic 50, 510–530 (1985)
[2] Balbiani, P., Herzig, A., Troquard, N.: Dynamic logic of propositional assignments: a well-
behaved variant of PDL. In: Kupferman, O. (ed.) Logic in Computer Science (LICS), New
Orleans, June 25-28. IEEE (2013), http://www.ieee.org/
[3] Bienvenu, M., Herzig, A., Qi, G.: Prime implicate-based belief revision operators. In: Ghal-
lab, M., Spyropoulos, C.D., Fakotakis, N., Avouris, N. (eds.) European Conference on Ar-
tiﬁcial Intelligence (ECAI), Patras, Greece, pp. 741–742. IOS Press (July 2008)
[4] Brotherston, J., Kanovich, M.I.: Undecidability of propositional separation logic and its
neighbours. In: Proceedings of the 25th Annual IEEE Symposium on Logic in Computer
Science, LICS 2010, Edinburgh, United Kingdom, July 11-14, pp. 130–139. IEEE Com-
puter Society (2010)
[5] van Ditmarsch, H., Herzig, A., de Lima, T.: From Situation Calculus to Dynamic Logic.
Journal of Logic and Computation 21(2), 179–204 (2011),
http://logcom.oxfordjournals.org/content/21/2/179.abstract?etoc
[6] G¨ardenfors, P.: Knowledge in Flux: Modeling the Dynamics of Epistemic States. MIT Press
(1988)
[7] Ishtiaq, S.S., O’Hearn, P.W.: BI as an assertion language for mutable data structures. In:
Hankin, C., Schmidt, D. (eds.) POPL, pp. 14–26. ACM (2001)
[8] Katsuno, H., Mendelzon, A.O.: Propositional knowledge base revision and minimal
change. Artiﬁcial Intelligence 52, 263–294 (1991)

178
A. Herzig
[9] Katsuno, H., Mendelzon, A.O.: On the diﬀerence between updating a knowledge base and
revising it. In: G¨ardenfors, P. (ed.) Belief Revision, pp. 183–203. Cambridge University
Press (1992); Preliminary version in Allen, J.A., Fikes, R., Sandewall, E. (eds.) Principles
of Knowledge Representation and Reasoning: Proc. 2nd Int. Conf., pp. 387–394. Morgan
Kaufmann Publishers (1991)
[10] Kourousias, G., Makinson, D.: Parallel interpolation, splitting, and relevance in belief
change. Journal of Symbolic Logic 72(3), 994–1002 (2007)
[11] Larchey-Wendling, D., Galmiche, D.: The undecidability of boolean bi through phase se-
mantics. In: Proceedings of the 25th Annual IEEE Symposium on Logic in Computer Sci-
ence, LICS 2010, Edinburgh, United Kingdom, July 11-14, pp. 140–149. IEEE Computer
Society (2010)
[12] McCarthy, J., Hayes, P.J.: Some philosophical problems from the standpoint of artiﬁcial
intelligence. In: Meltzer, B., Mitchie, D. (eds.) Machine Intelligence, vol. 4, pp. 463–502.
Edinburgh University Press (1969)
[13] O’Hearn, P.W., Reynolds, J.C., Yang, H.: Local reasoning about programs that alter data
structures. In: Fribourg, L. (ed.) CSL 2001. LNCS, vol. 2142, pp. 1–19. Springer, Heidel-
berg (2001)
[14] Parikh, R.: Beliefs, belief revision, and splitting languages. In: Moss, L.S., Ginzburg, J., de
Rijke, M. (eds.) Logic, Language, and Computation, vol. 2, pp. 266–278. CSLI Publications
(1999)
[15] Reiter, R.: The frame problem in the situation calculus: A simple solution (sometimes) and
a completeness result for goal regression. In: Lifschitz, V. (ed.) Artiﬁcial Intelligence and
Mathematical Theory of Computation: Papers in Honor of John McCarthy, pp. 359–380.
Academic Press, San Diego (1991)
[16] Reiter, R.: Knowledge in Action: Logical Foundations for Specifying and Implementing
Dynamical Systems. The MIT Press (2001)
[17] Reynolds, J.C.: Separation logic: A logic for shared mutable data structures. In: Proceed-
ings of the 17th IEEE Symposium on Logic in Computer Science (LICS 2002), Copen-
hagen, Denmark, July 22-25, pp. 55–74. IEEE Computer Society (2002)

Independence in Database Relations
Juha Kontinen1, Sebastian Link2, and Jouko V¨a¨an¨anen1,3
1 Department of Mathematics and Statistics, University of Helsinki, Finland
2 Department of Computer Science, The University of Auckland, New Zealand
3 Institute for Logic, Language and Computation, University of Amsterdam,
The Netherlands
Abstract. We investigate the implication problem for independence
atoms X ⊥Y of disjoint attribute sets X and Y on database schemata.
A relation satisﬁes X ⊥Y if for every X-value and every Y -value that
occurs in the relation there is some tuple in the relation in which the
X-value occurs together with the Y -value. We establish an axiomatiza-
tion by a ﬁnite set of Horn rules, and derive an algorithm for deciding
the implication problem in low-degree polynomial time in the input. We
show how to construct Armstrong relations which satisfy an arbitrarily
given set of independence atoms and violate every independence atom
not implied by the given set. Our results establish independence atoms as
an eﬃcient subclass of embedded multivalued data dependencies which
are not axiomatizable by a ﬁnite set of Horn rules, and whose implication
problem is undecidable.
1
Introduction
Independence and conditional independence are fundamental concepts in areas
as diverse as artiﬁcial intelligence, probability theory, social choice theory, and
statistics [2,9,17]. Recently, independence logic has been introduced as an ex-
tension of classical ﬁrst-order logic by independence atoms [8]. In databases,
conditional independence is better known as the class of embedded multivalued
data dependencies. Their associated implication problem is known to be not ax-
iomatizable by a ﬁnite set of Horn rules, and undecidable [11,16]. Multivalued
data dependencies [3] form an eﬃcient subclass of embedded multivalued data
dependencies whose implication problem has been axiomatized by a ﬁnite set of
Horn rules [1] and can be decided in almost linear time [5]. They form the basis
for Fagin’s fourth normal form proposal to avoid data redundancy in database
relations and guarantee the absence of processing diﬃculties [3].
In this paper we investigate an eﬃcient subclass of embedded multivalued
data dependencies which we call—in accordance with [8]— independence atoms.
Intuitively, a relation r satisﬁes the independence atom X ⊥Y between two dis-
joint sets X and Y of attributes, if for all tuples t1, t2 ∈r there is some tuple
t ∈r which matches the values of t1 on all attributes in X and matches the val-
ues of t2 on all attributes in Y . In other words, in relations that satisfy X ⊥Y ,
the occurrence of X-values is independent of the occurrence of Y -values.
L. Libkin, U. Kohlenbach, and R. de Queiroz (Eds.): WoLLIC 2013, LNCS 8071, pp. 179–193, 2013.
c
⃝Springer-Verlag Berlin Heidelberg 2013

180
J. Kontinen, S. Link, and J. V¨a¨an¨anen
Example 1. Consider a simple database schema that stores information about
the enrolment of students into a ﬁxed course. In fact, the schema records for
each enrolled student, the year in which they completed a prerequisite course.
More formally, we have the schema Enrol={S(tudent), P(rerequisite), Y(ear)}.
Intuitively, every student must have completed every prerequisite in some year.
For this reason, for any value in the Student column and every value in the
Prerequisite column there is some year for when this student has completed that
prerequisite. That is, the values in the Student column are independent of the
values in the Prerequisite column. A snapshot relation r over Enrol may be:
Student
Prerequisite
Year
Turing
Math201
1932
G¨odel
Math201
1925
Turing
Phys220
1932
G¨odel
Phys220
1925
illustrating the independence of Student from Prerequisite.
Primarily, we propose the use of independence atoms to restrict the set of possible
relations to those considered semantically meaningful for the given application
domain. In this sense, updates would only be allowed if they result in a relation
that satisﬁes all the independence atoms declared on the schema. For eﬃcient up-
dates it is therefore important to eliminate redundant independence atoms from
those that need to be validated whenever updates occur. Naturally, this leads
us to the implication problem: given a set Σ ∪{ϕ} of independence atoms, does
every relation that satisﬁes all elements in Σ also satisfy ϕ? If that is true, then
ϕ is redundant since validating that the updated relation satisﬁes all elements in
Σ guarantees that it also satisﬁes ϕ. If it is false, then it must also be validated
that ϕ is satisﬁed after the update. In our example, S⊥P implies P ⊥S. Hence,
we do not need to validate P ⊥S explicitly, since it is already validated implicitly
by validating S⊥P explicitly. Eﬃcient solutions to the implication problem for
classes of embedded data dependencies are particularly important for eﬃcient
updates. Indeed, validating independence atoms is rather costly due to the high
amount of redundancy they cause relations to exhibit. However, in contrast to
full dependencies, such as multivalued dependencies, it is yet unknown how to
eﬀectively avoid data redundancy caused by embedded dependencies. For multi-
valued dependencies, larger database schemata can be decomposed into smaller
schemata that satisfy Fagin’s Fourth Normal Form condition, which characterizes
the absence of data redundancy under such dependencies [3]. For now, therefore,
the primary practical impact of solving the implication problem eﬃciently is an
eﬀective way of avoiding redundant independence atoms.
Besides increased consistency and integrity, independence atoms can be ex-
ploited for other important data processing tasks. In query optimization, for
example, they can be used to avoid expensive database operations to return
query answers more eﬃciently. For instance, knowing that the independence
atom S⊥P is implied by the atoms that relations are validated against, the
query on the right can be used instead of the query on the left - both returning

Independence in Database Relations
181
all combinations of students and prerequisites that occur in the relation. The
right query does not use an expensive join unlike the left query.
SELECT E.Student, E’.Prerequisite
FROM Enrol AS E, Enrol AS E’
SELECT E.Student, E.Prerequiste
FROM Enrol AS E
Contributions. Motivated by these beneﬁts we investigate the implication
problem of independence atoms in database relations. Our work is inspired by
and based on [7] where, however, the basic setup is one of random variables. In
particular, we show that the results of [7] can be transferred from the context of
random variables to the context of databases. Our ﬁrst contribution is an axiom-
atization of the implication problem by a ﬁnite set of Horn rules. In particular,
for each atom ϕ which cannot be inferred by our inference rules from the atoms
in Σ, we construct a ﬁnite relation rϕ that satisﬁes Σ and violates ϕ. This also
shows that ﬁnite and unrestricted implication problem coincide for the class of
independence atoms. Exploiting our axiomatization we establish an algorithm
that decides the implication problem in O(|Σ| · ||ϕ||2 + |Σ| · ||Σ ∪{ϕ}||) time,
where |Σ| denotes the number of atoms in Σ, and ||Σ|| denotes the number of
attributes in Σ. Finally, we show that the implication problem of independence
atoms can be reduced to the model checking problem on a single relation. For
that purpose, we show how to construct for an arbitrarily given set Σ of in-
dependence atoms a relation that satisﬁes all the elements of Σ and violates
every independence atom not implied by Σ. In the literature such relations are
known as Armstrong relations [4]. Hence, checking whether ϕ is implied by Σ
amounts to checking whether an Armstrong relation for Σ satisﬁes ϕ. Inspecting
Armstrong relations is likely to increase the number of data dependencies that
business analysts discover to be meaningful for a given application domain [12].
Organization. We summarize related work in Section 2, providing further moti-
vation for the study of independence atoms and relating them to existing work in
probability theory and artiﬁcial intelligence. We introduce independence atoms
and their associated implication problem in Section 3. Axiomatic and algorith-
mic characterizations of the implication problem are established in Sections 4
and 5, respectively. The construction of Armstrong relations is shown in Section
6. We conclude in Section 7 where we also comment on future work.
2
Related Work
Approximately 100 diﬀerent classes of relational data dependencies have been
studied in the research literature [22]. The expressivity of embedded multivalued
dependencies results in the non-axiomatizability of its implication problem by a
ﬁnite set of Horn rules [16] and its undecidability [11]. Multivalued dependencies
[3] form an eﬃcient sub-class of embedded multivalued dependencies, whose im-
plication problem has been characterized by a ﬁnite axiomatization of Horn rules
[1], by an almost linear time algorithm [5], and by a fragment of Boolean propo-
sitional logic [19]. These results have recently been generalized to multivalued

182
J. Kontinen, S. Link, and J. V¨a¨an¨anen
dependencies over SQL databases [10]. Multivalued dependencies are very special
embedded dependencies, called full dependencies, as their attributes cover the
full set of attributes of the underlying relation schema. Our results show that
independence atoms form another eﬃcient sub-class of embedded multivalued
dependencies. In contrast to multivalued dependencies, independence atoms are
not full dependencies. Given the vast amount of literature on data dependen-
cies, given that independence is a natural concept in many areas, and given the
outlined beneﬁts of independence atoms, it is surprising that their investigation
in the database literature is rather limited [15,20]1.
In [20] Sagiv and Walecka introduce the class of subset dependencies which
are generalizations of embedded multivalued dependencies. A subset dependency
Z(X) ⊆Z(Y ) for attribute sets X, Y, Z of R, where both X and Y are disjoint
from Z, is satisﬁed by some relation r over R, if for all tuples t1, t2 ∈r that
agree on all attributes in X there is some tuple t3 ∈r that agrees with t1 on all
attributes in Y and that agrees with t2 on all attributes in Z. In particular, the
independence atom Y ⊥Z is satisﬁed by r if and only if the subset dependency
Z(∅) ⊆Z(Y ) is satisﬁed by r. The authors establish a ﬁnite axiomatization for
the class of Z-subset dependencies, which, for all relation schemata R and some
ﬁxed set Z ⊆R, consists of the subset dependencies Z(X) ⊆Z(Y ). It follows
from the deﬁnitions that Z-subset dependencies and independence atoms are
diﬀerent classes of embedded multivalued dependencies.
In [15], Paredaens investigates, among three other classes of data dependen-
cies, so called crosses X × Y which are equivalent to independence atoms X ⊥Y
where both X and Y are non-empty. Paredaens establishes a ﬁnite axioma-
tization for crosses, including the symmetry and decomposition rules, and a
somewhat convoluted version of the exchange rule. If empty attribute sets are
excluded, then our axiomatization is equivalent to that for crosses, as one would
expect. The motivation for our axiomatization comes from its strong analogy to
the Geiger-Paz-Pearl axioms for independence atoms over probability distribu-
tions [7], in particular the simplicity of the exchange rule. Indeed, Paradaens’
version of the exchange rule can be derived from the symmetry, decomposition
and our exchange rule. Based on our motivation from the introduction we were
also interested in algorithmic solutions to the implication problem, and Arm-
strong relations, which Paradaens did not aim to address.
As indicated, our study is further motivated by the existing studies of condi-
tional independence in artiﬁcial intelligence and statistics. Here, the implication
problem of conditional independence atoms is known to be not axiomatizable by
a ﬁnite set of Horn rules, and to be diﬀerent from that of embedded multivalued
dependencies [21]. The implication problem of saturated conditional indepen-
dence atoms is axiomatizable by a ﬁnite set of Horn rules, equivalent to the
implication problem of multivalued dependencies, and thus equivalent to that of
a fragment in Boolean propositional logic and decidable in almost linear time
[2,6]. In contrast to databases, independence atoms have been investigated in
1 We would like to thank the anonymous reviewers who pointed us to the paper by
Sagiv and Walecka [20], which pointed us to the paper by Paredaens [15].

Independence in Database Relations
183
probability theory. Indeed, their implication problem over discrete probability
measures has been axiomatized by a ﬁnite set of Horn rules, and can be de-
cided in low-degree polynomial time [7]. Furthermore, probability distributions
can be constructed that satisfy a given set of probabilistic independence atoms
and violate all those probabilistic independence atoms not implied by the given
set [7]. Therefore, our paper establishes results for independence atoms over
database relations that correspond to those known for independence atoms over
probability distributions. They further show that reasoning about probabilistic
independence atoms does not require probabilities at all.
3
Independence Atoms
In this section we ﬁrst summarize basic concepts from the relational model of
data, and then introduce the syntax and semantics of independence atoms, as
well as their associated implication problem.
Let A = {A1, A2, . . .} be a (countably) inﬁnite set of symbols, called attributes.
A relation schema is a ﬁnite set R = {A1, . . . , An} of attributes from A. Each
attribute A of a relation schema is associated with a domain dom(A) which rep-
resents the set of possible values that can occur in the column named A. A tu-
ple over R is a function t : R →	
A∈R dom(A) with t(A) ∈dom(A) for all
A ∈R. For X ⊆R let t(X) denote the restriction of the tuple t over R on X, and
dom(X) = 8
A∈X dom(A) the Cartesian product of the domains of attributes in
X. A relation r over R is a ﬁnite set of tuples over R. Let r(X) = {t(X) | t ∈r}
denote the projection of the relation r over R on X ⊆R. For attribute sets X and
Y we often write XY for their set union X ∪Y . For disjoint subsets X, Y ⊆R,
r1 ⊆dom(X) and r2 ⊆dom(Y ) let r1 × r2 = {t ∈dom(XY ) | ∃t1 ∈r1, t2 ∈
r2(t(X) = t1(X) ∧t(Y ) = t2(Y ))} denote the Cartesian product of r1 and r2.
3.1
Syntax and Semantics
Intuitively, an attribute set X is independent of a disjoint attribute set Y , if
X-values occur independently of Y -values. That is, the independence holds in a
relation, if every X-value that occurs in the relation occurs together with every
Y -value that occurs in the relation. Therefore, we arrive at the following concept,
in analogy with the similar concept in so-called team semantics [8]:
Deﬁnition 1. An independence atom over relation schema R is an expression
X ⊥Y where X and Y are two disjoint subsets of R. A relation r over R is said
to satisfy the independence atom X ⊥Y over R if and only if for all t1, t2 ∈r
there is some t ∈r such that t(X) = t1(X) and t(Y ) = t2(Y ). If r does not
satisfy X ⊥Y , then we also say that r violates X ⊥Y .
The semantics of independence atoms can be stated explicitly as that of an
embedded dependency. In the context of the attribute set XY , the concept
represented by X is independent of the concept represented by Y .

184
J. Kontinen, S. Link, and J. V¨a¨an¨anen
Proposition 1. Let r be a relation, and X ⊥Y an independence atom over rela-
tion schema R. Then r satisﬁes X ⊥Y if and only if r(XY ) = r(X) × r(Y ).
⊓⊔
Proposition 1 captures the equivalence of independence atoms to crosses [15].
Rissanen shows in [18] that a relation r over relation schema R which satisﬁes
a functional dependency X →Y is the lossless join of its projections r(XY )
and r(X(R −XY )). Proposition 1 shows that for a relation r which satisﬁes
the independence atom X ⊥Y , the projection r(XY ) is the lossless Cartesian
product of the projections r(X) and r(Y ).
We illustrate the semantics of independence atoms on our running example.
Example 2. The projection of relation r from Example 1 on Student and Prereq-
uisite is the Cartesian product of the projection on Student and the projection
on Prerequisite. Hence, r satisﬁes Student ⊥Prerequisite. However, the projec-
tion of r on Student and Year is not the Cartesian product of the projection on
Student and the projection on Year. Thus, r violates Student ⊥Year.
3.2
The Implication Problem
Data dependencies are usually deﬁned as semantic constraints that restrict the
possible relations of a schema to those considered meaningful for a given appli-
cation domain. Relations that satisfy all those data dependencies that express
“business rules” of the domain are considered meaningful, relations that violate
some business rule are considered meaningless. For eﬃcient data processing it
is therefore important to minimize the time that it takes to validate whether a
relation satisﬁes the given set of data dependencies. Indeed, relations that satisfy
a given set of data dependencies do not need to be tested whether they satisfy
any data dependency that is implied by the given set. Therefore, it is essential
to eﬃciently decide the implication problem of data dependencies. We will now
deﬁne this problem for independence atoms.
For a set Σ ∪{ϕ} of independence atoms we say that Σ implies ϕ, or that ϕ
is implied by Σ, written Σ |= ϕ, if every relation that satisﬁes every element in
Σ also satisﬁes ϕ. For a set Σ of independence atoms over some ﬁxed relation
schema R, we let Σ∗= {ϕ | Σ |= ϕ} be the semantic closure of Σ, i.e., the
set of all independence atoms implied by Σ. In order to determine the implied
independence atoms we use a syntactic approach by applying inference rules.
These inference rules have the form
premise
conclusion and inference rules without any
premise are called axioms. An inference rule is called sound, if the independence
atoms in the premise of the rule imply the independence atom in the conclusion
of the rule. We let Σ ⊢R ϕ denote the inference of ϕ from Σ by the set R of
inference rules. That is, there is some sequence γ = [σ1, . . . , σn] of independence
atoms such that σn = ϕ and every σi is an element of Σ or results from an
application of an inference rule in R to some elements in {σ1, . . . , σi−1}. For
Σ, let Σ+
R = {ϕ | Σ ⊢R ϕ} be its syntactic closure under inferences by R. A
set R of inference rules is said to be sound (complete) for the implication of
independence atoms, if for every R and for every set Σ of independence atoms

Independence in Database Relations
185
over R we have Σ+
R ⊆Σ∗(Σ∗⊆Σ+
R). The (ﬁnite) set R is said to be a (ﬁnite)
axiomatization for the implication of independence atoms if R is both sound and
complete. The implication problem of independence atoms is deﬁned as follows.
PROBLEM: Implication problem for independence atoms
INPUT:
Relation schema R,
Set Σ ∪{ϕ} of independence atoms over R
OUTPUT:
Yes, if Σ |= ϕ; No, otherwise
We illustrate the implication problem on our running example.
Example 3. Continuing Example 1, the set Σ of independence atoms consisted
of Student ⊥Prerequisite. If ϕ denotes the independence atom Student ⊥Year,
then the relation r from Example 1 shows that Σ ̸|= ϕ. An example of an
independence atom that is implied by Σ is Prerequisite ⊥Student.
4
Axiomatic Characterization
In this section we establish an axiomatic characterization of the implication
problem for independence atoms over relations. In fact, we show that the set I
of inference rules from Table 1 is sound and complete. The set I of inference rules
is the same set used in [7] to axiomatize implication among independence atoms
in the framework of random variables. It is remarkable that the same axioms
have found their way also to the study of concurrency [13] and secrecy [14]. If
the attribute sets X, Y and Z are interpreted as sets of vectors in a vector space,
the rules I would govern the concept of linear (as well as algebraic) independence
as was noted already in [23,24].
Table 1. Axiomatization I of Independence in Database Relations
X ⊥∅
X ⊥Y
Y ⊥X
(trivial independence, T )
(symmetry, S)
X ⊥Y Z
X ⊥Y
X ⊥Y
XY ⊥Z
X ⊥Y Z
(decomposition, D)
(exchange, E)
Using Deﬁnition 1 it is not diﬃcult to show the soundness of the inference
rules in I for the implication of independence atoms. As an example, we prove
the soundness of the exchange rule E. Let r be a relation that satisﬁes the
independence atoms X ⊥Y and XY ⊥Z. Let t1, t2 ∈r. Then there is some tuple
¯t ∈r such that ¯t(X) = t1(X) and ¯t(Y ) = t2(Y ), since r satisﬁes X ⊥Y . Since r
satisﬁes XY ⊥Z, for ¯t, t2 ∈r there must be some t ∈r such that t(XY ) = ¯t(XY )
and t(Z) = t2(Z). In particular, t(X) = ¯t(X) = t1(X), t(Y ) = ¯t(Y ) = t2(Y ),

186
J. Kontinen, S. Link, and J. V¨a¨an¨anen
and t(Z) = t2(Z). Hence, there is some t ∈r such that t(X) = t1(X) and
t(Y Z) = t2(Y Z). That is, r also satisﬁes the independence atom X ⊥Y Z.
The soundness of the rules in I allows us to mechanically infer several implied
independence atoms.
Example 4. Recall that Σ = {Student ⊥Prerequisite} in our running exam-
ple. A single application of the symmetry rule S to Student ⊥Prerequisite
gives us the independence atom Prerequisite ⊥Student ∈Σ+
I . Consequently,
Prerequisite ⊥Student ∈Σ∗due to the soundness of the symmetry rule.
The inference rules in I are also complete. That is, every implied independence
atom can be inferred by applications of the inference rules in I. The following
theorem is like Theorem 3 of [7]:
Theorem 1. The set I of Horn rules forms a ﬁnite axiomatization for the class
of independence atoms.
Proof. We proceed as in [7, Theorem 3], but working with relations instead of
random variables. Let R be some relation schema and Σ a set of independence
atoms over R. Let ϕ = X ⊥Y /∈Σ+
I . Without loss of generality we assume that
for all non-empty sets X′ ⊆X and Y ′ ⊆Y with X′Y ′ ̸= XY , X′⊥Y ′ ∈Σ+
I
holds. An independence atom ϕ with these properties is called minimal. Indeed,
if ϕ = X ⊥Y is not minimal, then we can remove attributes from X or from
Y to obtain a minimal atom ϕ′ = X′⊥Y ′ /∈Σ+
I . Note that, if X′ and Y ′ are
both singletons, then X′⊥Y ′ is a minimal atom due to the trivial independence
axiom T . For each minimal atom ϕ′ we construct a relation rϕ′ that satisﬁes Σ
and violates ϕ′. Due to the decomposition rule D, rϕ′ also violates ϕ and, hence,
ϕ is not implied by Σ.
Let ϕ = X ⊥Y /∈Σ+
I be a minimal atom. For all A ∈R assume that dom(A) =
{0, 1}, and let Z = R −XY . Let A0 ∈X. Deﬁne rϕ ⊆dom(R) as follows: for all
t ∈dom(R) we have,
t ∈rϕ if and only if t(A0) = 
A∈(X−A0)Y t(A) mod 2 .
Clearly, r = r(XY ) × 8
A∈Z dom(A).
We show ﬁrst that rϕ violates the independence atom X ⊥Y . Let t be a tuple
where t(A0) = 1 and t(A) = 0 for all A ∈XY −A0. Then t ∈r(X) × r(Y ), but
t /∈r(XY ).
It remains to show that rϕ satisﬁes every independence atom V ⊥W ∈Σ.
Case 1. Assume that V ⊆Z or W ⊆Z. Say, for example, that V ⊆Z. By
construction, for every tuple t1 ∈r(Z) and every tuple in t2 ∈r(W) there is
some tuple t ∈r(V W) such that t(V ) = t1(V ) and t(W) = t2(W). The case
where W ⊆Z holds is similar. Hence, r(V W) = r(V ) × r(W).
Case 2. Assume that V ∩XY ̸= ∅and W ∩XY ̸= ∅.
Case 2.1. Suppose XY ̸⊆V W. For U ⊆XY with U ̸= XY we have r(U) =
8
A∈U r(A). Hence, r(V W) = 8
A∈V W r(A). In particular, r(V W) = r(V ) ×
r(W).

Independence in Database Relations
187
Case 2.2. Suppose XY ⊆V W. Then let V = X′Y ′Z′, W = X′′Y ′′Z′′ where
X = X′X′′, Y = Y ′Y ′′, and Z′Z′′ ⊆Z holds. Assume that V ⊥W ∈Σ+
I .
We show, under this assumption, the contradiction that X ⊥Y ∈Σ+
I holds.
Consequently, V ⊥W /∈Σ+
I and this case cannot occur.
Since X ⊥Y is a minimal independence atom, X′⊥Y ′, X′′⊥Y ∈Σ+
I . The
inference
X′Y ′Z′⊥X′′Y ′′Z′′
X′⊥Y ′
D : X′Y ′⊥X′′Y ′′
X′′⊥Y
E :
X′⊥X′′Y
D : Y ⊥X′′
S :
X′′Y ⊥X′
E :
Y ⊥X
S :
X ⊥Y
gives the anticipated contradiction that X ⊥Y ∈Σ+
I under the assumption that
V ⊥W ∈Σ+
I when XY ⊆V W. Note that the inference of X ⊥Y ∈Σ+
I remains
valid even if some of the X′, X′′, Y ′, Y ′′ are empty, as long as X = X′X′′ and
Y = Y ′Y ′′ hold.
⊓⊔
We illustrate the completeness argument on our running example.
Example 5. Let Σ = {Student ⊥Prerequisite} be a set of independence atoms
and ϕ = Prerequiste ⊥Year be an independence atom over Enrol. The con-
struction from the completeness proof of Theorem 1 may result in the relation
on the left, which may result in the relation on the right by suitable substitutions.
Student
Prerequiste
Year
S1
P1
Y1
S1
P2
Y2
S2
P1
Y1
S2
P2
Y2
Student
Prerequiste
Year
Hilbert
Phil101
1900
Hilbert
Phys110
1905
Ackermann
Phil101
1900
Ackermann
Phys110
1905
Both relations satisfy Σ and violate ϕ.
Instead of the exchange rule E, Paredaens used the following rule on the left
X′⊥Z
X ⊥Y
X ∩X′⊥Y ∪(X ∩Z) X ∩X′ ̸= ∅
UV ⊥WW ′
UWW ′′⊥Y
U ⊥Y W
for crosses, deﬁned for non-empty attribute sets. This rule produces an indepen-
dence atom that cannot already be inferred by the decomposition and symmetry
rules alone, if X ∩X′ ̸= ∅and X ∩Z ̸= ∅hold. In that case, the rule can be
rewritten as the rule on the right above. This rule can be inferred as follows
UV ⊥WW ′
D : UV ⊥W
S : W ⊥UV
D : W ⊥U
UWW ′′⊥Y
S : U ⊥W
D : UW ⊥Y
E :
U ⊥Y W
from the decomposition, symmetry, and exchange rule.

188
J. Kontinen, S. Link, and J. V¨a¨an¨anen
5
Algorithmic Characterization
We establish an algorithmic characterization of the implication problem. In prac-
tice, one may simply want to check if a single independence atom ϕ is implied by
a given set Σ of independence atoms. One could compute Σ∗= Σ+
I and check
if ϕ ∈Σ∗. However, this algorithm is hardly eﬃcient. Instead, we exploit the
extra knowledge about ϕ to decide more eﬃciently if ϕ is implied by Σ.
The divide-and-conquer algorithm is presented as Algorithm 1. On input
(Σ, X ⊥Y ) it reduces Σ to Σ′ = Σ[XY ] = {(V ∩XY )⊥(W ∩XY ) | V ⊥W ∈Σ}
(line 3). If X ⊥Y is a trivial independence atom, i.e., if one of its sets is empty, or
if the atom or its symmetric atom is included in Σ′, then the algorithm returns
true (line 4-5). If there is no non-trivial atom U ⊥V ∈Σ′ where UV = XY ,
then the algorithm returns false (line 7-8). Otherwise, there is some non-trivial
atom U ⊥V ∈Σ′ where U = QR, V = ST , and X = QS, Y = RT . In this
case, the Algorithm returns true if and only if it returns true on both inputs
(Σ′, Q⊥R) and (Σ′, S⊥T ) (line 12).
Algorithm 1. Implication
1: procedure Implied(Σ, ϕ)
2:
ϕ ←X ⊥Y ;
3:
Σ′ ←Σ[XY ];
4:
if X = ∅or Y = ∅or X ⊥Y ∈Σ′ or Y ⊥X ∈Σ′ then
5:
Implied(Σ, ϕ) ←true;
6:
end if;
7:
if for all U ⊥V ∈Σ′ with U ̸= ∅and V ̸= ∅, UV ̸= XY then
8:
Implied(Σ, ϕ) ←false;
9:
else
▷∃U ⊥V ∈Σ′ with ∅̸= U = QR, ∅̸= V = ST , X = QS, Y = RT
10:
ϕ1 ←Q⊥R;
11:
ϕ2 ←S⊥T ;
12:
Implied(Σ, ϕ) ←Implied(Σ′, ϕ1) ∧Implied(Σ′, ϕ2);
13:
end if;
14: end procedure
Algorithm 1 works correctly in low-degree polynomial time. This yields the
following result, reminiscent of Theorems 8 and 9 of [7]:
Theorem 2. Algorithm 1 terminates, and Implied(Σ, ϕ) = true if and only
if Σ |= ϕ. The time-complexity of Algorithm 1, on input (Σ, ϕ), is in O(|Σ| ·
||ϕ||2 + |Σ| · ||Σ ∪{ϕ}||).
Proof (Sketch). Let ϕ = X ⊥Y . Firstly, it follows from an inspection of the
inference rules in I that Σ ⊢I ϕ holds if and only if Σ′ ⊢I ϕ holds.
Secondly, for any non-trivial ϕ, Σ′ ⊢I ϕ holds only if there is some atom
U ⊥V ∈Σ′ such that UV = XY . This follows from the observation that no
inference rule in I introduces an attribute to its conclusion that does not already
occur in one of its premises.

Independence in Database Relations
189
These observations justify lines 2-7 of Algorithm 1. We will now justify lines
9-12. Let X = QS, Y = RT , U = QR, and V = ST . Then we show that, if
U ⊥V ∈Σ+
I , then X ⊥Y ∈Σ+
I if and only if Q⊥R ∈Σ[QR]+
I and S⊥T ∈
Σ[ST ]+
I .
Assume ﬁrst that QR⊥ST, Q⊥R, S⊥T ∈Σ+
I . Then the following inference
shows that QS⊥RT ∈Σ+
I , too.
QR⊥ST
S⊥T
S : ST ⊥QR
E :
S⊥QRT
Q⊥R
QR⊥ST
D :
S⊥RT
E :
Q⊥RST
S :
RT ⊥S
S :
SRT ⊥Q
E :
RT ⊥QS
S :
QS⊥RT
If QS⊥RT ∈Σ+
I , then there is an inference U1⊥V1, . . . , Uk ⊥Vk = QS⊥RT
from Σ. Consequently, (U1∩QR)⊥(V1∩QR), . . . , (Uk∩QR)⊥(Vk∩QR) = Q⊥R
is an inference of Q⊥R from Σ[QR]. Similarly, an inference of S⊥T from Σ[ST ]
can be constructed from an inference of QS⊥RT from Σ.
Note that this shows, in particular, that a selection of U ⊥V in line 9 can be
made arbitrarily since any selection provides a necessary and suﬃcient means to
check whether X ⊥Y ∈Σ+
I .
Algorithm 1 terminates since the size of the independence atoms strictly de-
creases in line 12. If the algorithm did not terminate before, it will terminate
when the number of attributes in the two atoms have reached 2 (line 4 or line 7).
The ﬁrst statement of Theorem 2 follows from a simple induction on the number
of attributes in ϕ.
We will now analyze the time complexity of Algorithm 1. The complexity
is measured in terms of two types of basic operations: the comparison of two
independence atoms and the projection of independence atoms. Both operations
are bounded by the number ||Σ ∪{ϕ}|| of distinct attributes in Σ ∪{ϕ}. Let
c(ϕ) denote the number of basic operations required to solve a problem for an
independence atom ϕ, and assume for now that the distinct attributes in Σ are
those in ϕ. By line 12, c(ϕ) must satisfy the equation c(ϕ) ≤c(ϕ1)+c(ϕ2)+|Σ|,
where |Σ| denotes the number of atoms in Σ, and where ||ϕ|| = ||ϕ1||+||ϕ2||. The
solution to this equation is O(|Σ| · ||ϕ||) measured in basic operations. Adding
the cost of projecting Σ to the attributes in ϕ is in O(|Σ| · ||Σ ∪{ϕ}||).
⊓⊔
Example 6. Let Σ = {Student ⊥Prerequisite} be a set of independence atoms
and ϕ = Prerequiste ⊥Year be an independence atom over relation schema
Enrol. On input (Σ, ϕ), Algorithm 1 computes Σ′ = ∅in Step 3, and re-
turns Implied(Σ, ϕ) = false in Step 8, since the condition in Step 7 is trivially
satisﬁed. Hence, by Theorem 2, ϕ is not implied by Σ.

190
J. Kontinen, S. Link, and J. V¨a¨an¨anen
6
Armstrong Relations
We show that independence atoms enjoy Armstrong relations. That is, for every
relation schema R and every set Σ of independence atoms, there is a relation
over R that satisﬁes Σ and violates every independence atom not implied by Σ.
The property of enjoying Armstrong relations has been characterized by Fagin
in a very general framework [4]. We will exploit this characterization to show
how to construct Armstrong relations for independence atoms.
Theorem 3. [4] Let S denote a set of sentences. The following properties of S
are equivalent:
1. Existence of a faithful operator. There exists an operator ⊗that maps non-
empty families of models into models, such that if σ is a sentence in S and
⟨Pi : i ∈I⟩is a non-empty family of models, then σ holds for ⊗⟨Pi : i ∈I⟩
if and only if σ holds for each Pi.
2. Existence of Armstrong models. Whenever Σ is a consistent subset of S and
Σ∗is the set of sentences in S that are logical consequences of Σ, then there
exists a model (an “Armstrong” model) that obeys Σ∗and no other sentence
in S.
3. Splitting of disjunctions. Whenever Σ is a subset of S and {σi : i ∈I} is a
non-empty subset of S, then Σ |= {σi : i ∈I} if and only if there exists
some i ∈I such that Σ |= σi.
⊓⊔
Indeed, there is a faithful operator for independence atoms. While Fagin’s theo-
rem holds for any cardinality of I [4], we use it only for ﬁnite non-empty I. An
analog of the below theorem was proved in [7, Theorem 11] for distributions.
Theorem 4. Let {ri : i = 1, . . . , n} be a ﬁnite set of relations. There exists
an operation ⊗that maps ﬁnite sets of relations to relations such that for each
independence atom σ, the relation ⊗{ri : i = 1, . . . , n} satisﬁes σ if and only if
for i = 1, . . . , n, ri satisﬁes σ.
Proof. We construct the operation ⊗by using a binary operation ⊗b such that
for every independence atom σ, the relation r1 ⊗b r2 satisﬁes σ if and only if
both relations r1 and r2 satisfy σ. The operation ⊗is then deﬁned recursively
by ⊗{ri : i = 1, . . . , n} := (· · · ((r1 ⊗b r2) ⊗b r3) · · · ⊗b rn). Let r1, r2 be relations
over relation schema R. Then r1 ⊗b r2 is deﬁned by
((a1, a′
1), . . . , (an, a′
n)) ∈r1 ⊗b r2 iﬀ(a1, . . . , an) ∈r1 and (a′
1, . . . , a′
n) ∈r2.
We now show that for an independence atom X ⊥Y over R we have, r1 ⊗b r2
satisﬁes X ⊥Y if and only if r1 satisﬁes X ⊥Y and r2 satisﬁes X ⊥Y .
We show ﬁrst that if r1 satisﬁes X ⊥Y and r2 satisﬁes X ⊥Y , then r1⊗br2 sat-
isﬁes X ⊥Y . Let t1 = ((a1, a′
1), . . . , (an, a′
n)), t2 = ((b1, b′
1), . . . , (bn, b′
n)) ∈r1 ⊗b
r2. Then, t1
1 = (a1, . . . , an), t1
2 = (b1, . . . , bn) ∈r1, and t2
1 = (a′
1, . . . , a′
n), t2
2 =
(b′
1, . . . , b′
n) ∈r2. Since r1 satisﬁes X ⊥Y there is some ¯t = (c1, . . . , cn) ∈r1
such that ¯t = t1
1(X) and ¯t = t1
2(Y ). Since r2 satisﬁes X ⊥Y there is some

Independence in Database Relations
191
t′ = (c′
1, . . . , c′
n) ∈r2 such that t′(X) = t2
1(X) and t′ = t2
2(Y ). Let t :=
((c1, c′
1), . . . , (cn, c′
n)) ∈r1 ⊗b r2. It follows that t(X) = t1(X) and t(Y ) = t2(Y ).
Hence, r1 ⊗b r2 satisﬁes X ⊥Y .
It remains to show that if r1 ⊗b r2 satisﬁes X ⊥Y , then r1 satisﬁes X ⊥Y
and r2 satisﬁes X ⊥Y . Let t1
1 = (a1, . . . , an), t1
2 = (b1, . . . , bn) ∈r1 and
t2
1 = (a′
1, . . . , a′
n), t2
2 = (b′
1, . . . , b′
n) ∈r2. Then, t1 = ((a1, a′
1), . . . , (an, a′
n)), t2 =
((b1, b′
1), . . . , (bn, b′
n)) ∈r1 ⊗b r2. Since r1 ⊗b r2 satisﬁes X ⊥Y there is some
t = ((c1, c′
1), . . . , (cn, c′
n)) ∈r1 ⊗r2 where t(X) = t1(X) and t(Y ) = t2(Y ). Then
tr1 := (c1, . . . , cn) satisﬁes tr1(X) = t1
1(X) and tr1(Y ) = t1
2(Y ). Thus, r1 satisﬁes
X ⊥Y . Similarly, tr2 := (c′
1, . . . , c′
n) satisﬁes tr2(X) = t2
1(X) and tr2(Y ) = t2
2(Y ).
Hence, r2 satisﬁes X ⊥Y .
⊓⊔
We illustrate the construction of Armstrong relations on our example.
Example 7. Let Σ = {Student ⊥Prerequisite} be a set of independence atoms
over Enrol. From previous examples we have seen the relation r1 on the left
that satisﬁes Σ and P ⊥Y , but violates S⊥Y , and the relation r2 on the right
that satisﬁes Σ and S⊥Y , but violates P ⊥Y .
Student
Prerequiste
Year
S1
P1
Y1
S2
P1
Y2
S1
P2
Y1
S2
P2
Y2
Student
Prerequiste
Year
S3
P3
Y3
S3
P4
Y4
S4
P3
Y3
S4
P4
Y4
The Armstrong construction results in the relation r1 ⊗b r2, deﬁned by
((a1, a′
1), . . . , (an, a′
n)) ∈r1 ⊗b r2 iﬀ(a1, . . . , an) ∈r1 and (a′
1, . . . , a′
n) ∈r2, on
the left, and suitable substitutions yield the relation on the right.
Student
Prerequiste
Year
(S1,S3)
(P1,P3)
(Y1,Y3)
(S1,S3)
(P1,P4)
(Y1,Y4)
(S1,S4)
(P1,P3)
(Y1,Y3)
(S1,S4)
(P1,P4)
(Y1,Y4)
(S2,S3)
(P1,P3)
(Y2,Y3)
(S2,S3)
(P1,P4)
(Y2,Y4)
(S2,S4)
(P1,P3)
(Y2,Y3)
(S2,S4)
(P1,P4)
(Y2,Y4)
(S1,S3)
(P2,P3)
(Y1,Y3)
(S1,S3)
(P2,P4)
(Y1,Y4)
(S1,S4)
(P2,P3)
(Y1,Y3)
(S1,S4)
(P2,P4)
(Y1,Y4)
(S2,S3)
(P2,P3)
(Y2,Y3)
(S2,S3)
(P2,P4)
(Y2,Y4)
(S2,S4)
(P2,P3)
(Y2,Y3)
(S2,S4)
(P2,P4)
(Y2,Y4)
Student
Prerequiste
Year
Sheldon
Ethi101
2010
Sheldon
Logi120
2011
Leonard
Ethi101
2010
Leonard
Logi120
2011
Howard
Ethi101
2012
Howard
Logi120
2013
Raj
Ethi101
2012
Raj
Logi120
2013
Sheldon
Chem110
2010
Sheldon
Biol105
2011
Leonard
Chem110
2010
Leonard
Biol105
2011
Howard
Chem110
2012
Howard
Biol105
2013
Raj
Chem110
2012
Raj
Biol105
2013
Indeed the latter two relations are Armstrong relations for Σ. That is, they sat-
isfy Σ and violate S⊥Y and P ⊥Y , and thereby also S⊥PY , SY ⊥P, SP ⊥Y ,
S⊥Y P, and their symmetric independence atoms.

192
J. Kontinen, S. Link, and J. V¨a¨an¨anen
It can now be shown how an arbitrary set of independence atoms can be
visualized as a single Armstrong relation. In practice, Armstrong relations can
be used by database designers and business analysts as a communication tool
to acquire and discuss the meaningfulness of business rules with domain experts
[12]. Just as [7, Theorem 11] obtains for distributions, we obtain:
Theorem 5. The class of independence atoms enjoys Armstrong relations.
Proof. Let R be an arbitrary relation schema and Σ a set of independence atoms
over R. By Theorem 1, for each ϕ /∈Σ+
I there is some relation rϕ that satisﬁes
Σ and violates ϕ. Let r := ⊗{rϕ | ϕ /∈Σ+
I }. The relation is well-deﬁned since
the set of all independence atoms over a relation schema is ﬁnite. According to
Theorem 4, r satisﬁes all independence atoms in Σ and violates every indepen-
dence atom not implied by Σ.
⊓⊔
It also follows from our results and Theorem 3 that the set I of inference rules is
powerful enough to infer all disjunctions of independence atoms that are logically
implied by a set of independence atoms, and not merely single independence
atoms.
7
Conclusion and Future Work
We investigated independence atoms, introduced in [8], as a new class of re-
lational data dependencies. Our results show that independence atoms form
an eﬃcient sub-class of embedded multivalued dependencies whose implication
problem is not ﬁnitely axiomatizable and undecidable. Our eﬃcient solutions to
the implication problem can result in enormous cost savings in data processing,
for example when validating the consistency of update operations on relations,
or when querying relations. Independence atoms form the database counterpart
of probabilistic independence atoms known from probability theory.
In future work we plan to implement our algorithms as a tool, and analyze how
the inspection of Armstrong relations can help database designers or business
analysts with the task of identifying independence atoms that are semantically
meaningful for a given application domain. It is interesting to investigate the
minimum number of tuples required in Armstrong relations. It is also a challeng-
ing problem to identify means to reduce data redundancy caused by embedded
dependencies. For the ﬁeld of (in)dependence logic, it would be interesting to
axiomatize the combined class of independence and dependence atoms.
Acknowledgement. This research is supported by the Marsden Fund Council
from Government funding, administered by the Royal Society of New Zealand,
and grants 264917 and 251557 of the Academy of Finland.
References
1. Beeri, C., Fagin, R., Howard, J.H.: A complete axiomatization for functional and
multivalued dependencies in database relations. In: SIGMOD Conference, pp. 47–
61. ACM (1977)

Independence in Database Relations
193
2. Dawid, A.P.: Conditional independence in statistical theory. Journal of the Royal
Statistical Society. Series B (Methodological) 41(1), 1–31 (1979)
3. Fagin, R.: Multivalued dependencies and a new normal form for relational
databases. ACM Trans. Database Syst. 2(3), 262–278 (1977)
4. Fagin, R.: Horn clauses and database dependencies. J. ACM 29(4), 952–985 (1982)
5. Galil, Z.: An almost linear-time algorithm for computing a dependency basis in a
relational database. J. ACM 29(1), 96–102 (1982)
6. Geiger, D., Pearl, J.: Logical and algorithmic properties of conditional indepen-
dence and graphical models. The Annals of Statistics 21(4), 2001–2021 (1993)
7. Geiger, D., Paz, A., Pearl, J.: Axioms and algorithms for inferences involving prob-
abilistic independence. Inf. Comput. 91(1), 128–141 (1991)
8. Gr¨adel, E., V¨a¨an¨anen, J.A.: Dependence and independence. Studia Logica 101(2),
399–410 (2013)
9. Halpern, J.: Reasoning about uncertainty. MIT Press (2005)
10. Hartmann, S., Link, S.: The implication problem of data dependencies over SQL
table deﬁnitions. ACM Trans. Datab. Syst. 37(2), 13.1–13.52 (2012)
11. Herrmann, C.: On the undecidability of implications between embedded multival-
ued database dependencies. Inf. Comput. 204(12), 1847–1851 (2006)
12. Langeveldt, W., Link, S.: Empirical evidence for the usefulness of Armstrong rela-
tions on the acquisition of meaningful FDs. Inf. Syst. 35(3), 352–374 (2010)
13. More, S.M., Naumov, P., Sapp, B.: Concurrency Semantics for the Geiger-Paz-Pearl
Axioms of Independence. In: CSL, vol. 12, pp. 443–457 (2011)
14. Naumov, P.: Independence in information spaces. Studia Logica 100(5), 953–973
(2012)
15. Paredaens, J.: The interaction of integrity constraints in an information system. J.
Comput. Syst. Sci. 20(3), 310–329 (1980)
16. Parker Jr., D., Parsaye-Ghomi, K.: Inferences involving embedded multivalued de-
pendencies and transitive dependencies. In: SIGMOD Conference, pp. 52–57 (1980)
17. Pearl, J.: Probabilistic Reasoning in Intelligent Systems: Networks of Plausible
Inference. Morgan Kaufmann (1988)
18. Rissanen, J.: Independent components of relations. ACM Trans. Database
Syst. 2(4), 317–325 (1977)
19. Sagiv, Y., Delobel, C., Parker Jr., D., Fagin, R.: An equivalence between relational
database dependencies and a fragment of propositional logic. J. ACM 28(3), 435–
453 (1981)
20. Sagiv, Y., Walecka, S.F.: Subset dependencies and a completeness result for a
subclass of embedded multivalued dependencies. J. ACM 29(1), 103–117 (1982)
21. Studen´y, M.: Conditional independence relations have no ﬁnite complete charac-
terization. In: Transactions of the 11th Prague Conference on Information Theory,
pp. 377–396. Kluwer (1992)
22. Thalheim, B.: Dependencies in relational databases. Teubner (1991)
23. van der Waerden, B.L.: Moderne Algebra. J. Springer, Berlin (1940)
24. Whitney, H.: On the Abstract Properties of Linear Dependence. Amer. J.
Math. 57(3), 509–533 (1935)

Substructural Logic of Proofs
Hidenori Kurokawa1 and Hirohiko Kushida2
1 Kobe University
hidenori.kurokawa@gmail.com
2 The City University of New York, Graduate Center
hkushida@gc.cuny.edu
Abstract. In this paper, we introduce substructural variants of Arte-
mov’s logic of proofs. We show a few things here. First, we introduce
a bimodal logic that has both the exponential operator in linear logic
and an S4 modal operator which does not bring in any structural fea-
ture. Both Girard’s embedding and G¨odel’s modal embedding (not the
double negation translation) are used to directly connect intuitionistic
substructural logics and substructural logics with the involutive negation.
Second, we formulate substructural logic of proofs, which is an explicit
counterpart of the foregoing bimodal substructural logics, and show that
the substructural logic of proofs can realize the bimodal substructural
logic, following the idea of [1]. Third, adopting the idea of Yu [10], we
also show that the contraction-free, multiplicative S4-fragment of the bi-
modal substructural logic is realizable without appealing to a so-called
“self-referential constant speciﬁcation.”
1
Introduction
The logic of proofs (LP) has been introduced in order to analyze a combinatorial
structure of “proofs” underlying S4 compliant (or other normal) modal logics.
S4, into which intuitionistic logic (IL) is embeddable ([5]), is usually taken to
codify the notion of “informal provability.” The structure of proofs underlying
the S4 modality is made explicit via proof-terms in LP in such a way that (1)
LP, an explicit counterpart of S4, is given an intended arithmetic interpretation
(sound and complete w.r.t. PA), whereas S4 itself is not sound under arithmetic
interpretation; however, (2) the precise connection with S4 is given via its real-
ization theorem, which roughly states that for any theorem of S4, we can assign
an appropriate proof term to each 2.
On the other hand, in linear logic (LL), it has been shown that intuitionistic
logic can be embedded in intuitionistic linear logic (ILL) by its linear implica-
tion and the exponential operator, and it is embedded into classical linear logic
via double negation translation ([4]). We have yet another tradition of modal
substructural logics (introduced by Doˇsen [3]), whose modalities have been mo-
tivated by a reason diﬀerent from Girard’s exponential. Those modalities are
introduced to formulate the modal embeddings from constructive substructural
logics into modal substructural logics with the involutive negation. We call this
modality “non-structural modality.”
L. Libkin, U. Kohlenbach, and R. de Queiroz (Eds.): WoLLIC 2013, LNCS 8071, pp. 194–210, 2013.
c
⃝Springer-Verlag Berlin Heidelberg 2013

Substructural Logic of Proofs
195
Although classical LL is usually related to intuitionistic LL only via double
negation translation, it may be natural to consider a purely modal framework
into which intuitionistic LL can be embedded. Such a system must be a bimodal
logic, since we have both Girard’s exponential and modality used for G¨odel
embedding. In this paper, we introduce such a bimodal logic called LLS4 (and
its subsystem that has only non-structural modality called BCS4) and we prove
cut-elimination for LLS4.
In addition, we introduce a two-sorted substructural logic of proofs (LLP)
that is an explicit counterpart of the bimodal substructural logic. This logic has
two diﬀerent kinds of proof terms, one of which allows us to apply structural
rules to the formulas with the proof terms (analogous to Girard’s exponential)
and the other does not. We call the former “structural proof terms” and the
latter “non-structural proof terms.” We also introduce a subsystem of the two-
sorted substructural logic of proofs (MALLP) which is an explicit counterpart of
the substructural logic with non-structural modality. We prove the realization
theorems for the modal substructural logics via the substructural logics of proofs.
An analysis of combinatorial structure of proof terms under substructural
constraints is not the whole point of this project. In LP, in order to prove its
proof internalization (if s : Γ, Δ ⊢LP ϕ, then s : Γ, y : Δ ⊢LP t(s, y) : ϕ for some
proof term t),1 we use a machinery called “constant speciﬁcation” (roughly, this
is an assignment of an axiom to a proof term called “proof constant”), by which
we can have a rule called an “axiom necessitation” of the form c : A where A is
one of the axioms of LP. It is already known ([6]) that in order to realize S4 (and
its fragment that is in the range of G¨odel embedding [11]), we need a so-called
“self-referential constant speciﬁcation,” which yields an axiom necessitation of
the form c : A(c) in a schematic form (namely, the same proof constant as used
for the whole axiom occurs in an instance of the axiom). The full signiﬁcance
of this self-referentiality is yet to be investigated. However, applying a recent
proof-theoretic analysis of self-referentiality by Yu ([10], [12]), we show that the
multiplicative fragment of the weakening-free and contraction-free subsystem
of S4, i.e. BCS4,2 is realizable without using self-referential constant speciﬁca-
tions. The result suggests that there is an essential relationship between the
self-referentiality at issue here and the structural rules, since the multiplicative
fragment is the one where the eﬀect of being contraction-free becomes particu-
larly clear, since there is no merge of formulas in a proof tree in this fragment.
(See section 6.)
2
Bimodal Substructural Logic
Let us present a Gentzen-style sequent calculus for the bimodal substructural
logic LLS4. Here we follow the notation of [7]. Hence, we use ⊗, ⊕, 0, 1 for the
multiplicative constants, ∧, ∨, ⊤, ⊥for the additive constants, and →, ¬ for the
1 s stands for s1, . . . , sn.
2 Although the name of a logic BC stands for a subsystem of intuitionistic logic, by
this nomenclature, we invariantly talk about the logic with involutive negation.

196
H. Kurokawa and H. Kushida
linear implication and the involutive negation, respectively. ⊡is our notation
for the exponential ! in linear logic, and 2 is the additional modal operator that
has no structural capacity. (We assume that these modal operators are more
strongly associated with other formulas than the other logical constants, so we
omit parentheses for these.) The language is oﬃcially speciﬁed as follows.
A ::= 1|⊥|⊤|0|P|A ∧B|A ⊗B|A ∨B|A ⊕B|A →B|¬A|2A| ⊡A.
We now present a Gentzen-style sequent calculus for LLS4.
Axioms:
A ⇒A
0 ⇒
⇒1
Γ ⇒⊤, Δ
⊥, Γ ⇒Δ
Inference rules for additive connectives:
A, Γ ⇒Δ
A ∧B, Γ ⇒Δ ∧: l
B, Γ ⇒Δ
A ∧B, Γ ⇒Δ ∧: l
Γ ⇒Δ, A
Γ ⇒Δ, B
Γ ⇒Δ, A ∧B
∧: r
A, Γ ⇒Δ
B, Γ ⇒Δ
A ∨B, Γ ⇒Δ
∨: l
Γ ⇒Δ, A
Γ ⇒Δ, A ∨B ∨: r
Γ ⇒Δ, B
Γ ⇒Δ, A ∨B ∨: r
Inference rules for multiplicative connectives:
A, B, Γ ⇒Δ
A ⊗B, Γ ⇒Δ ⊗: l
Γ ⇒Δ, A
Π ⇒Θ, B
Γ, Π ⇒Δ, Θ, A ⊗B
⊗: r
A, Γ ⇒Δ
B, Π ⇒Θ
A ⊕B, Γ, Π ⇒Δ, Θ
⊕: l
Γ ⇒Δ, A, B
Γ ⇒Δ, A ⊕B ⊕: r
Γ ⇒Δ, A
B, Π ⇒Θ
A →B, Γ, Π ⇒Δ, Θ
→: l
A, Γ ⇒Δ, B
Γ ⇒Δ, A →B →: r
A, Γ ⇒Δ
Γ ⇒Δ, ¬A ¬ : r
Γ ⇒Δ, A
¬A, Γ ⇒Δ ¬ : l
Inference rules for modalities:
A, Γ ⇒Δ
2A, Γ ⇒Δ 2 : l
⊡Γ, 2Δ ⇒B
⊡Γ, 2Δ ⇒2B 2 : r
A, Γ ⇒Δ
⊡A, Γ ⇒Δ ⊡: l
⊡Γ ⇒B
⊡Γ ⇒⊡B ⊡: r
⊡A, ⊡A, Γ ⇒Δ
⊡A, Γ ⇒Δ
contraction
Γ ⇒Δ
⊡A, Γ ⇒Δ weakening

Substructural Logic of Proofs
197
Inference rules for constants and cut:
Γ ⇒Δ
Γ ⇒Δ, 0 0
Γ ⇒Δ
1, Γ ⇒Δ 1
Γ ⇒Δ, A
A, Π ⇒Θ
Γ, Π ⇒Δ, Θ
cut
Here, each capital greek letter (Γ, Δ, . . .) denotes a multiset of formulas; when Γ
is (A1, . . . , An), 2Γ denotes a multiset of the form (2A1, . . . , 2An); ⊡Γ denotes
a multiset of the form (⊡A1, . . . , ⊡An). We write ⊢LLS4 S or ⊢cf
LLS4 S to express
that the sequent S is provable in LLS4 or cut-free provable in LLS4, respectively.
Note: 1. It is clear that ⊢LLS4 ⊡ϕ →2ϕ. This is motivated by the following
consideration. Both ⊡and 2 are S4 modalities, but the former has an additional
structural feature. Hence, the former can be taken as a special case of the latter,
although in our embedding they play diﬀerent roles.
2. Rules for LL ([4]) can be obtained from LLS4 by omitting 2 : l and 2 : r
and by restricting the language to that of LL. ILL can be obtained from LL by
omitting ¬ : l and ¬ : l and omitting ¬ from the language of LL.
3. Rules for MALL ([4]) can be obtained from LL by omitting ⊡: l and ⊡: r,
contraction, weakening and by restricting the language to that of MALL.
4. Rules for a subsystem of LLS4 called “BCS4” can be obtained by adding 2
to the language of MALL and 2 : l and a restricted 2 : r (with ⊡Γ = ∅).
5. Although we do not have any space to present a proof, let us give the
deﬁnitions of the two embeddings.
Deﬁnition 1. 1. The embedding of IL into ILL: (A →B)◦= ⊡A◦→B◦. (Other
cases are quite trivial. See [4]) 2. The embedding of ILL into LLS4 ∗: Put 2 in
front of every subformula except inside the scope of ⊡.
The composition of ◦and ∗gives an embedding from ILL into LLS4.
Theorem 1. (Cut-Elimination for LLS4) Let S be any sequent of LLS4.
If ⊢LLS4 S, then ⊢cf
LLS4 S.
Proof. We can apply the usual proof as in Takeuti [9] for LLS4. We introduce
the following form of cut for the cut formula ⊡A.
Γ ⇒Δ, ⊡A
n many
%
&'
(
⊡A, . . . , ⊡A, Π ⇒Θ
Γ, Π ⇒Δ, Θ
cut
Let P be a proof of S in LLS4 where the cut rule occurs only in the last step. We
proceed by the double induction on the degree and the rank of P, denoted by
d(P) and r(P), respectively. d(P) is the number of the logical symbols of the cut
formula, and r(P) is the number of the related occurrences of the cut formula
in P. (We refer to [9] for a precise deﬁnition for rank.) See the appendix 2 for
the details of the proof.

198
H. Kurokawa and H. Kushida
3
Substructural Logic of Proofs
We move on to substructural logic of proofs. We present two systems MALLP
and LLP. Let us ﬁrst give a speciﬁcation of the language of LLP.
s ::= x|c|!s|s · t|s · t|s · t|s + t|s + t|s + t|s♯t|s♯t|s♯t.
s ::= x|c|!s|s · t|s + t|s♯t|s♭t.
A ::= 1|⊥|⊤|0|P|A ∧B|A ⊗B|A ∨B|A ⊕B|A →B|¬A|s : A|s : A.
Proof terms consisting only of boldface terms are “structural terms,” which have
the structural capacity. All other terms are “non-structural terms, ” which have
no structural capacity. Also, the language of MALLP is a sublanguage of that of
LLP obtained by removing all the boldface terms from that of LLP.
We present Hilbert-style axiomatizations of MALLP and LLP in the following.
MALLP: MALLP is obtained from MALL∗, which is the auxiliary system for
MALL obtained by adding derivations from assumptions as primitive via “inter-
nal consequence relation” in [2], by adding the following axiom schemata and
inference rules in the language of MALLP. MALL∗is introduced to prove the
Lifting Lemma smoothly. (We give a Hilbert style system for MALL and MALL∗
in Appendix 1.)
A1. s : A →A
A2. s : (A →B) →(t : A →(s · t) : B)
A3. s : A →!s : (s : A)
A4. s : A →(s + t) : A ; t : A →(s + t) : A
R3. u : Γ ⊢t : A
u : Γ ⊢s : B
u : Γ ⊢t♯s : A ∧B
R4. ⊢c : A, where A is an axiom of MALLP and c is a constant.
Note: The new operation ♯is essentially the same as the pairing operation,
which is indispensable to prove the Lifting Lemma for the substructural logic
of proofs without the axiom corresponding to weakening, for then we would not
have any proof operation corresponding to the rule of adjunction.
LLP: LLP is obtained from MALLP by extending the language to that of LLP and
by adding the following axiom schemata and inference rules in the language of LLP.
A5. (s : A →(s : A →B)) →(s : A →B)
A6. B →(s : A →B)
A7. s : u : A →(t : v : B →(s♭t) : (u♯v) : (A ∧B))
R5. ⊢c : d : A, where A is an axiom of LLP, c is a structural constant, and d is
a non-structural constant.

Substructural Logic of Proofs
199
The intuitive meaning of the operation ♭in A7 is to ‘witness’ the internal-
ization of an application of adjunction by non-structural term. Note that the
proof-operation ♭is applicable only to structural terms. Also, the meaning of
R5 is to ‘witness’ the axiom necessitation by a structural constant. The axioms
used in R4 in LLP are extended to those of LLP. Terms in A1-4 and R3, 4
can be structural or non-structural in LLP. The axiom A7 and the rule R5 are
introduced in order to prove the realization theorem smoothly.3
Now we show that BCS4 and LLS4 are realizable in MALLP and LLP, re-
spectively. A realization of a formula ϕ of BCS4 or LLS4 is deﬁned to be a
replacement of each occurrence of structural modality ⊡in ϕ by a structural
term and each occurrence of non-structural modality 2 in ϕ by a non-structural
term, preserving derivability. By ϕr we denote the result of a realization r of ϕ.
Theorem 2. (Realization of BCS4 and LLS4)
1.⊢BCS4 ϕ if and only if, for some realization r, ⊢MALLP ϕr.
2.⊢LLS4 ϕ if and only if, for some realization r, ⊢LLP ϕr.
We prove the theorem in a way similar to the case of S4 in [1]. The parts ‘if’ in
both 1 and 2 are shown by the ‘forgetful’ projection. We can show by an easy
inductive argument that from a given proof of ϕr in MALLP or LLP, we can
obtain a proof ϕ in MALLP or LLP, respectively, by replacing all the occurrences
of non-structural terms and structural terms by 2 and ⊡, respectively.
For the part ‘only if’ of 1, we can apply the method of [1] straightforwardly.
However, for ‘only if’ of 2, we need to make sure that both structural modality and
non-structural modality are appropriately realized. For this purpose, we needed
to introduce an additional proof operation ♭, a new axiom, and a new rule.
We prove Theorem 2. Let us ﬁrst observe the following facts.
(♮1) For any structural term s, there is a non-structural term t such that
⊢LLP s : A →t(s) : s : A.
(♮2) For any structural term s, there are a structural term t and a non-
structural term u such that ⊢LLP s : A →t(s) : u(s) : A.
For (♮1). Take a non-structural constant c so that ⊢LLP c : (s : A →s : A), by R4.
As s : A →!s : s : A is an axiom, by using A2, we have ⊢LLP s : A →(c·!s) : s : A.
For (♮2). Take constants c, d, e so that ⊢LLP d : c : (s : A →A) and ⊢LLP e : (s :
A →!s : s : A), by R4, 5. Then, for some w, ⊢LLP w(e, d) : (s : A →(c·!s) : A).4
Finally, using A3 and A2, ⊢LLP s : A →(w(e, d)·!s) : (c·!s) : A.
Lemma 1. (Lifting Lemma for MALLP, LLP) Let L denote MALLP or LLP.
1. If s : Γ ⊢L A, then s : Γ ⊢L t(s) : A, for some non-structural term t.
3 It turns out to be possible to realize LLS4 in a system without the axiom A7. However,
the proof of the realization in this case would become much more complicated, so
we omit it here due to lack of space.
4 This term w(e, d) has the form (g · e) · (d · f), where f : [c: (s :A→A) →(!s :
s :A) →c·!s :A)] and g : [(s :A→!s : s :A) →((!s : s :A→c·!s :A) →(s :A→c·!s :A))].

200
H. Kurokawa and H. Kushida
2. If s : Γ, t : Δ ⊢LLP A, then s : Γ, t : Δ ⊢LLP u(s, t) : A, for some non-
structural term u.
3. If s : Γ ⊢LLP A, then s : Γ ⊢LLP t(s) : A, for some structural term t.
Proof. We treat 2 and 3. The proof for 1 is similar.
(For 2) By induction on the length of a proof of s : Γ, t : Δ ⊢L A in LLP.
When A is an axiom, we take a non-structural constant c such that c : A is
provable by R4. When A is some s : B ∈s : Γ, we have a non-structural term
t(s) such that t(s) : s : A is provable by (♮1). When A is some t : B ∈t : Δ,
by using an axiom t : B →!t : t : B, we can derive !t : t : B. In the induction
step, we treat the rules R2, R3. The proofs for R1, R4 are similar. For R2. By
the induction hypothesis, we can derive s : A and t : B for some non-structural
s, t. We obtain (s♯t) : (A ∧B) by R3. For R3. When (s♯t) : (A ∧B) is provable
with non-structural s♯t, we can derive !(s♯t) : (s♯t) : (A ∧B) by A3. When
(s♯t) : (A ∧B) is provable with structural s♯t, we have a non-structural term
u(s♯t) such that u(s♯t) : (s♯t) : (A ∧B) is provable, by (♮1).
(For 3) By induction on the length of a proof of s : Γ ⊢LLP A in LLP. We treat
only the case when R3 or R4 is applied. The other cases can be proved similarly
to the above cases. For R3. When (s♯t) : (A∧B) is provable with structural (s♯t),
we can derive !(s♯t) : (s♯t) : (A ∧B) by A3. When (s♯t) : (A ∧B) is provable
with non-structural s♯t from s : A and t : B, by the induction hypotheses, we
have u : s : A and v : t : B provable with some structural u, v. By using A7, we
can derive (u♭v) : (s♯t) : (A ∧B). For R4. When c : A is provable by R4, A is
an axiom, and so, we have structural d such that d : c : A is provable.
Corollary 1. (Constructive necessitation for MALLP, LLP)
Let L denote MALLP or LLP.
1. If ⊢L A, then ⊢L s : A, for some non-structural term s.
2. If ⊢LLP A, then ⊢LLP s : A, for some structural term s.
Proof. (Theorem 2) Let us now prove the theorem, but we ﬁrst introduce some
technical terms. We use the standard terminology of the polarity of an occurrence
of a formula. Note that in a cut-free proof, the polarity is always preserved. For a
sequent S ≡Γ ⇒Δ, let Sr denote Γ r ⇒Δr. A realization is said to be normal
if each negative occurrence of 2 and ⊡is replaced by a structural proof-variable
and a non-structural proof-variable, respectively. A realization for S is normal
if that for ⊗Γ →⊕Δ is normal. We say that Sr is provable in a system if
⊗Γ r →⊕Δr is provable in it. We say that an occurrence of 2 in a premise and
a corresponding occurrence of 2 in a conclusion “related.” Taking the reﬂexive
transitive closure of this relation on occurrences of 2, we consider an equivalence
class of “related” 2es, and we call them a family of occurrences of 2. We call
a family “essential” if it contains at least one occurrence of 2 introduced by
2 : r. Since the relation is an equivalence relation, we can consider a partition
of occurrences of 2 in a proof tree.
Suppose that a sequent S is provable in M (where M = BCS4 or LLS4). By
Theorem 1, we may assume that there is a cut-free proof P of S in M. We shall
construct a proof of Sr in L with a normal r. The construction goes as follows.

Substructural Logic of Proofs
201
(Step 1) For each negative family of 2 and each nonessential family of 2,
substitute a non-structural variable, for all occurrences of 2 of the family. Also,
for each negative family of ⊡and each nonessential family of ⊡, substitute a
structural variable for all occurrences of ⊡of the family.
(Step 2) For each essential family of2, substitute a non-structural term x1+· · ·+
xn for all occurrences of 2 of the family. Each xi is called a provisional variable. n
is the number of applications of the rule 2 : r for the family. Also, for each essential
family of ⊡, substitute a structural term y1 + · · · + ym for all occurrences of ⊡of
the family. m is the number of applications of the ⊡: r for the family.
(Step 3) Proceed from top to bottom in the proof ﬁgure. For a 2 : r, we
have the realization of the upper and lower sequents: s : Γ, t : Δ ⊢L A and
s : Γ, t : Δ ⊢L (x1 +· · ·+xi +· · ·+xn) : A in (Step 1, 2). By applying the Lifting
Lemma, construct a non-structural term u such that s : Γ, t : Δ ⊢L u : A. (When
L is MALLP, Γ is empty.) When the 2 : r is the ith one among all 2 : r in
the family, substitute ui for all the occurrences of the same provisional variable
xi. Then we have, e.g., s : Γ, t : Δ ⊢L (x1 + · · · + ui + · · · + xn) : A. Repeat
this procedure until we substitute all of ui for all of the provisional variables xi.
Then, e.g., we obtain s : Γ, t : Δ ⊢L (u1 + · · · + ui + · · · + un) : A.
Similarly, for each ⊡: r, we have the realization of the upper and lower
sequents: s : Γ ⊢LLP A and s : Γ ⊢LLP (x1 + · · · + xj + · · · + xm) : A in (Step 1,
2). By the Lifting Lemma, construct a structural term v such that s : Γ ⊢LLP
v : A. When the ⊡: r is the jth one among all ⊡: r in the family, substitute
vj for all the occurrences of the same provisional variable xj. Then we have,
e.g., s : Γ ⊢LLP (x1 + · · · + vj + · · · + xm) : A. Repeat this procedure until we
substitute all of vj for all of the provisional variables xj. Then, we obtain, e.g.,
s : Γ ⊢LLP (v1 + · · · + vj + · · · + vm) : A.
In this procedure, each formula in P is replaced by a formula in the language
of MALLP or LLP and it is easy to check that each sequent consisting of these
formulas is either an axiom or derivable from the upper sequent. Thus, for a given
sequent S provable in M, we obtain a proof of Sr with a normal realization r in
L. This completes the proof of Theorem 2
4
Prehistoric-Loop-Free Proofs
Yu ([10], [12]) deﬁnes a notion of prehistoric loop. Intuitively, this means that
an introduction of an occurrence of a modal operator essentially requires that
it be related to another occurrence of the modal operator in the same “family”
which precedes it. Yu ([10], [12]) showed that such a loop is a necessary condition
that any realization of the modal formula essentially requires a self-referential
constant speciﬁcation. Applying this idea, we identify a natural subsystem of S4
in the hierarchy of modal substructural logics in Doˇsen [3]. We start from giving
necessary deﬁnitions.
The phenomenon that two occurrences of symbols in premise(s) share the
same corresponding occurrence in the conclusion is called a uniﬁcation. Con-
traction is a structural rule that makes this happen, and also side formulas in
the binary rules for additive logical constants typically make this happen.

202
H. Kurokawa and H. Kushida
A Gentzen-style proof (tree) is denoted by T , with each of its node (a sequent)
denoted s1, s2, · · · , and its conclusion-premise relation denoted by R. The root
of a proof tree is the conclusion sequent of the proof. For any proof T and any
sequent s in T . T ↾s means the subproof of s in T . Following the deﬁnition of a
family of occurrences of 2 in section 3, we use a notation 2i where i = 1, 2, 3. . . ..
By this, we mean that the occurrence of 2 indexed by i belongs to a family i
of occurrences of 2. A family of occurrences of 2 has its own polarity (negative
or positive). We denote a positive family by 2+
i and a negative family by 2−
i In
the following, we say a family of 2+
i or 2−
i occurs in ϕ if there is an occurrence
of 2i in ϕ (we write this as ϕ(2i)).
Deﬁnition 2 (Prehistoric graph [12]).
In a BCS4 proof T , the prehistoric graph P(T ) is deﬁned as the directed graph
P(T ) := (F, ≺L, ≺R, ≺), where F is the set of positive families in T , all of ≺L,
≺R, ≻are binary relations on F, ≺:=≺L ∪≺R, and
≺L:= {(i, j)|
2−Θ(2+
i ) ⇒ϕ
2−Θ(2+
i ) ⇒2+
j ϕ (2 : r) is in T }
≺R:= {(i, j)|
2−Θ ⇒ϕ(2+
i )
2−Θ ⇒2+
j ϕ(2+
i ) (2 : r) is in T }
Lemma 2. In a proof T , each family has a unique occurrence in the root.
Proof. In any rule in those systems, each occurrence in a premise has exactly
one corresponding occurrence in the conclusion.
Due to the limitation of space, we omit proofs of some statements below up to
Proposition 1. (The details of these can be found in [12].)
Lemma 3. In P(T ) of a proof T , for any i ∈F, (i, i) /∈≺R.
Lemma 4. In P(T ) of a proof T , for any i, j, k ∈F, (1) if k ≺R j ≺L i and
(2) k ≺R j ≺R then k ≺R i
Deﬁnition 3 ([12]).
A (left, right) prehistoric graph has a loop w.r.t. ≺(≺L, ≺R) if there is a
ﬁnite sequence of i1 ≺i2 ≺· · · ≺in ≺i1.
Theorem 3 ([12]).
In P(T ) of a proof of T , (1) (F, ≺R) has no loop, and (2) (F, ≺) has a loop
if and only if (F, ≺L) has a loop.
Obviously, if we have no introduction of a new edge and no uniﬁcation of occur-
rences of modal operator by applying a rule, it introduces no loop.
Proposition 1. 1. ⊗: r, ⊗: l, ⊕: r, ⊕: l, →: r, and →: l do not introduce
any loop. 2. 2 : r and 2 : l introduce no loop, either.

Substructural Logic of Proofs
203
Yu [10] observes that in his formulation of S4 in a G3-type sequent calculus
only his versions of →: l(context sharing), 2 : l (contraction built-in5) rules can
possibly bring in loop. It is obvious that if the form of 2 : l is not the one in
which contraction is built-in, then 2 : l involves no uniﬁcation. Also, note that
2 : r introduces a new edge, but clearly this introduces no uniﬁcation.
Lemma 5. In no sequent in a BCS4 proof, more than one occurrence of 2+ of
the same family can occur in it.
Proof. Note that there is exactly one occurrence of 2+ from one family in the
root, due to the deﬁnition of a family. To show this lemma, it is suﬃcient to
observe that no rule in BCS4 can make two occurrences of a formula into one.
In addition to Yu’s observation that there is no direct right loop, we can also
observe that in BCS4, there is no direct left loop.
Lemma 6. In P(T ) of a proof T , for any i ∈F, (i, i) /∈≺L.
Proof. Oﬃcially, it is shown by the induction of the length of proofs. But it suf-
ﬁces to observe that there is no rule in these systems that relates two occurrences
of 2+ in the premises can come in the same occurrence of 2+.
Since BCS4 enjoys cut-elimination and the subformula property, we can state
the following.
Proposition 2. In BCS4, any 2 formula in each positive essential family of 2+
i
is introduced as a principal formula of 2 : r only in one place in each branch s.
Proof. In BCS4, only binary additive rules can introduce a uniﬁcation, but such
a case occurs only at a node of a proof tree where two branches meet. Hence,
for each branch, any 2 formula in each positive family of 2+
i is introduced only
once via 2 : r.
Yu’s theorem (theorem 3) concerning equivalence between having a loop and
having a left loop still holds here. Hence, we can conclude that there is no loop
in s of T at all.
Theorem 4. Let T be a BCS4 proof. No branch s in T can have a left-prehistoric
loop. Hence, no branch s in T can have a prehistoric loop.
This theorem on the loop-free nature of BCS4 proofs is stated only for a branch
s. However, to prove an interesting property of a proof, we focus on the multi-
plicative fragment of BCS4. We call it mBCS4. But then the following hold for
mBCS4. since (1) no rules in these allow us to introduce a prehistoric loop in one
branch and (2) there is no additive (context-sharing) binary rule that makes a
uniﬁcation possible.
Lemma 7. In an mBCS4 derivation, each positive family of 2+
i
can be intro-
duced only once in the entire proof tree.
Theorem 5. An mBCS4 proof cannot have a left prehistoric loop.
5 This rule has the form θ, 2θ, Γ ⇒Δ
2θ, Γ ⇒Δ .

204
H. Kurokawa and H. Kushida
5
Non-self-Referential Constant Speciﬁcations
Now let us show that there is a realization of a prehistoric loop-free proof that
does not require a self-referential constant speciﬁcation. Let us ﬁrst give the
deﬁnition of self-referential constant speciﬁcation.
Deﬁnition 4 (Self-referentiality in constant speciﬁcations [6])
A constant speciﬁcation CS is self-referential if CS has at least one subset of
the form {c1 : A1(c2), . . . , cn−1 : An−1(cn), cn : An(c1)}. A constant speciﬁcation
CS is non-self-referential, otherwise.
Theorem 6. There is a realization of r such that mBCS4 ⊢ϕ if and only if L
⊢ϕr which satisﬁes the following two conditions.
1. L is the multiplicative fragment of MALLP (called “MLLP.”)
2. The constant speciﬁcation contains no self-referential constant speciﬁcation.
Proof. (=⇒) (Proof sketch) Let us ﬁrst prove the harder part.
(1) We prove that there exists a desired realization, following a reﬁned version
of the realization algorithm. We reﬁne the original realization algorithm given
in [1] via the order of families of modal operators. The order of families can be
given by keeping track of an introduction of a positive occurrence of a 2+ by
using a function called “ϵ-function.”
Let us give a few necessary deﬁnitions about this function here. Using Yu’s
notation ([12]), we write ϵ(i, j). This means a function that assigns a natural
number to the j-th application of 2 : r in the i-th family of positive occurrences
of the modal operator. The j-th application of 2 : r in the family i is denoted
by (2 : r)ij. The premise and the conclusion of (2 : r)ij are denoted by Iij and
Oij, respectively. Since we have only one case of principal application of 2 : r in
one family, it suﬃces to have ϵ(i). Let R+ be a transitive closure of a relation
expressing the relationship between the premise and the conclusion of 2 : r.
Here clearly it follows by deﬁnition that Oi1R+Oi2 if and only if ϵ(i1) < ϵ(i2).
Thus, a new constant ci is associated with the unique (2 : r)i. ϵ(i) is the number
associated with this constant.
Claim. h1 ≺h2 implies ϵ(h1) < ϵ(h2)
Proof. (proof sketch of the claim) There must be a i1 such that for all h, h ⊀i1 (it
is like an innermost family). Otherwise, there is a loop in a proof. Then, excluding
i1 from the set of all relevant families, we can pick i2 such that ϵ(i1) < ϵ(i2),
and so on. Since the set of families is at most ﬁnite, this can always be done.
Hence, the families can be linearly ordered according to the order of applications
of 2 : r in them.
(2) To prove that our realization does not rely on any self-referential constant
speciﬁcation, we show that our reﬁned realization which ensures that the sub-
stitution for a provisional variable can be done strictly according to the order

Substructural Logic of Proofs
205
of the applications of 2 : r works. Note that, in the general case of realization
algorithm used in section 3, it is not possible to exclude a case in which an
occurrence of a provisional variable can be substituted only when a relevant
application of the Lifting Lemma occurs below the provisional variable in a
proof tree. Let us deﬁne now the following notion.
Deﬁnition 5 ([12]). An application of Axiom Necessitation ci : Ai
is ϵ-allowed
if (1) Ai contains no provisional variables and (2) Ai contains no ci′ s.t. ϵ(i) ≤
ϵ(i′).
(3) The description of the realization algorithm can be given as follows. 1) Take
a cut-free proof of mBCS4. 2) Replace all the negative occurrences of modal
operators (and positive occurrences of modal operators belonging to an non-
essential family introduced by weakening) with proof variables by using the
same variable for the occurrences related to a 2 at the root node of a proof tree.
Replace all positive occurrences of modal operators in an essential family by the
same provisional variable. (Note that since we have only one possible application
of 2 : r for one family, we do not need to introduce + part of the realization at
all.) 3) At every application of 2 : r, we substitute a relevant provisional variable
by an appropriate proof term by applying the Lifting Lemma.
(4) We show that the realization algorithm produces a proof in the corre-
sponding substructural logic of proofs (i.e. MLLP). We use an induction on ϵ(i)
and a subinduction on the structure of a subtree of a proof tree to ensure that
both the substitution steps and the subderivations between substitution steps
work as desired.
(4.1) We carry out substitutions of an appropriate proof terms with ϵ-allowed
c.s. into provisional variable based on induction over ϵ(i).
By using IH for ϵ(i1) −1, we have a provisional-variable-free derivation of
Iϵ(i)−1
i
with an ϵ-allowed c.s. Then the step from Iϵ(i)−1
i
to Oϵ(i)−1
i
can be treated
as follows. 1) Apply the Lifting Lemma to Iϵ(i)−1
i
(the c.s. used here is ϵ-allowed,
since all the constants in the c.s. used in Lifting are fresh, according to (1)).6 2)
By carrying out the substitution, we can replace the provisional variable by a
provisional-variable-free term. Then we get T i from what is obtained from T i−1
possibly by some other steps in the derivation (here T i stands for a subtree of
T in which the substitution for ϵ(i) is done). This completes the i-th step of
induction in the substitution procedure in the realization algorithm.
(4.2) Between the previous substitution for obtaining T i−1 and the substitu-
tion for obtaining T i, we show that all the steps of the derivation here can be
mimicked in the Hilbert-style system of the corresponding substructural logic
proofs (MLLP). The proof of this part is tedious but a routine and essentially
the same as in [12].
Hence, we have completed both the description of the algorithm and the proof
that the algorithm produces a proof in MLLP with ϵ-allowed c.s in such a way
that all the substitutions are done following the order of ϵ(i).
6 Our procedure is simpler than Yu’s since we do not need + in our realization and,
unlike in G3-style systems, our modal rules do not incorporate weakening.

206
H. Kurokawa and H. Kushida
(5) We now show that our constructed proof in MLLP is non-self-referential,
i.e., the ϵ-allowed c.s. that we have used (we call it CS′′ is non-self-referential.
To prove this, suppose CS′′ is self-referential. Namely, assume the following holds.
{ci1,k1:Ai1,k1(ci2,k2), . . . , ciz−1,kz−1:Aiz−1,kz−1(ciz,kz), ciz,kz:Aiz,kz(ci1,k1)} ⊆CS′′.
Since CS′′ is ϵ-allowed, we have ϵ(iz) < ϵ(iz−1) < · · · < ϵ(i1) < ϵ(iz). But this is
impossible. Hence, CS′′ is non-self-referential.
(⇐=) Given any derivation in the multiplicative fragment of MALLP, we can
apply the forgetful projection. It can be shown by an easy inductive argument
that the forgetful projection gives a proof in mBCS4
6
Discussions
1. We acknowledge that there is another work independently done concerning
the issue of non-self-referentiality of contraction-less fragment of S4 ([8]).
However, the work only considers a fragment of G3-style formulation of S4.
The author does not systematically consider how this fragment can be lo-
cated in the hierarchy of modal substructural logics. As a result, it is not
clear what kind of logic we obtain if we take a forgetful projection of the
fragment of G3-style formulation of S4. On the other hand, our result pre-
sented here is a consequence of a more systematic consideration about how
realization works in the hierarchy of modal substructural logics. Hence, it
is obvious that the resulting logic by applying the forgetful projection to
MLL is exactly mBCS4. Also, it is worth noting that the realization does not
require + operation, either.
2. Although we formulate only BCS4 and MLLP in this paper mainly due to
the limitation of space, it is quite obvious that the same method works for
the multiplicative fragment of BCKS4. In addition, our proof method also
suggests a natural conjecture that multiplicative and additive BCS4 (and
BCKS4) can also be realized without using self-referential constant speciﬁ-
cation.
3. Not only has it been observed that contraction-free logics have an important
connection to polynomial time computation, but it was also observed by
G¨odel already in 1930’s that the intended interpretation (Brouwer-Heyting-
Kolmogorov interpretation) of intuitionistic implication contains some sort
of “impredicativity.” Self-referentiality in realization of S4 seems to have an
important connection with this impredicativity of intuitionistic logic through
contraction.7
7 Yu [11] has recently proved that self-referentiality also occurs in the range of G¨odel
embedding from intuitionistic propositional logic into S4.

Substructural Logic of Proofs
207
Appendix 1
(1) A Hilbert-style axiomatic system for MALL (a notational variant from [2]).
Axioms schemata:
1. A →A
2. (A →B) →((B →C) →(A →C))
3. (A →(B →C)) →(B →(A →C))
4. ¬¬A →A
5. (A →¬B) →(B →¬A)
6. (A →(B →A ⊗B))
7. (A →(B →C)) →((A ⊗B) →C)
8. 1
9. 1 →(A →A)
10. A →(¬A →0)
11. ¬0
12. (A ⊕B) →(¬A →B)
13. (¬A →B) →(A ⊕B)
14. (A ∧B) →A
15. (A ∧B) →B
16. ((A →B) ∧(A →C)) →(A →(B ∧C))
17. A →(A ∨B)
18. B →(A ∨B)
19. ((A →C) ∧(B →C)) →((A ∨B) →C))
20. A →⊤
21. ⊥→A
Inference rules:
R1. A
A →B
B
R2. A
B
⊢A ∧B
(2) The internal consequence relation ⊢for LL, which makes it possible to talk
about a derivation from assumption naturally, can be introduced as follows.
Internal consequence : A1, . . . , An ⊢B if and only if ⊢A1 →(· · · (An →
B) · · · ).
(3) To facilitate the proof of the Lifting Lemma, we introduce an auxiliary
axiomatization of MALL∗which takes ⊢as primitive. The axioms are the same
as those of MALL, but the inferences rules are formulated as follows.
Inference rules:
R1∗. Γ1 ⊢A
Γ2 ⊢A →B
Γ1, Γ2 ⊢B
R2∗. Γ ⊢A
Γ ⊢B
Γ ⊢A ∧B
Given the foregoing deﬁnition of ⊢, the equivalence of MALL and MALL∗is
obvious (it suﬃces to show the derivability of R1∗and R2∗by MALL and the
deﬁnition of ⊢).
Appendix 2
In this appendix, we show the details of our proof of cut-elimination for LLS4.
We examine only the cases when the cut formula is a modal formula. First, we
handle the cases when the cut formula is ⊡A and r(P) = 2. We have a few cases.
Below, we illustrate the proof-transformation to be carried out for each case.

208
H. Kurokawa and H. Kushida
(1)
⊡Γ ⇒A
⊡Γ ⇒⊡A ⊡: r
A, Π ⇒Θ
⊡A, Π ⇒Θ ⊡: l
⊡Γ, Π ⇒Θ
cut
▽
⊡Γ ⇒A
A, Π ⇒Θ
⊡Γ, Π ⇒Θ
cut
(2)
⊡Γ ⇒A
⊡Γ ⇒⊡A ⊡: r
Π ⇒Θ
⊡A, Π ⇒Θ weak.
⊡Γ, Π ⇒Θ
cut
▽
Π ⇒Θ
⊡Γ, Π ⇒Θ weak.
d(P) is reduced by one in the transformation of (1). Thus, we can eliminate the
new cut inference in (1). Next, we examine the cases when the cut formula is
⊡A and r(P) ≥3. When the left upper inference is not ⊡: r. We demonstrate
the proof-transformation only for one case.
(3)
Γ ⇒Δ, B
C, Π ⇒Θ, ⊡A
B →C, Γ, Π ⇒Δ, Θ, ⊡A
→: l
(⊡A)n, Σ ⇒Φ
B →C, Γ, Π, Σ ⇒Δ, Θ, Φ
cut
▽
Γ ⇒Δ, B
C, Π ⇒Θ, ⊡A
(⊡A)n, Σ ⇒Φ
C, Π, Σ ⇒Θ, Φ
cut
B →C, Γ, Π, Σ ⇒Δ, Θ, Φ
→: l
When the left upper inference is ⊡: r and the right upper one is not concerned
with the cut formula, the transformation is similar to (3). Otherwise, there are
the following three cases.
(4)
⊡Γ ⇒A
⊡Γ ⇒⊡A ⊡: r
⊡A, (⊡A)n, Π ⇒Θ
(⊡A)n, Π ⇒Θ
contr.
⊡Γ, Π ⇒Θ
cut
▽
⊡Γ ⇒A
⊡Γ ⇒⊡A ⊡: r
⊡A, (⊡A)n, Π ⇒Θ
⊡Γ, Π ⇒Θ
cut

Substructural Logic of Proofs
209
(5)
⊡Γ ⇒A
⊡Γ ⇒⊡A ⊡: r
(⊡A)n, Π ⇒Θ
⊡A, (⊡A)n, Π ⇒Θ weak.
⊡Γ, Π ⇒Θ
cut
▽
⊡Γ ⇒A
⊡Γ ⇒⊡A ⊡: r
(⊡A)n, Π ⇒Θ
⊡Γ, Π ⇒Θ
cut
(6)
⊡Γ ⇒A
⊡Γ ⇒⊡A ⊡: r
A, (⊡A)n, Π ⇒Θ
⊡A, (⊡A)n, Π ⇒Θ ⊡: l
⊡Γ, Π ⇒Θ
cut
▽
⊡Γ ⇒A
⊡Γ ⇒⊡A ⊡: r
A, (⊡A)n, Π ⇒Θ
⊡Γ, A, Π ⇒Θ
cut
In all cases (3-6), r(P) is reduced by one, and, hence, we can eliminate the new
cut inferences. As to (6), we have not yet reached the desired sequent, which is
obtained by further applying the cut in the following way.
⊡Γ ⇒A
⊡Γ, A, Π ⇒Θ
⊡Γ, ⊡Γ, Π ⇒Θ
cut
⊡Γ, Π ⇒Θ
contraction
This cut can be eliminated as the d(P) is reduced by one.
Next, we examine the cases when the cut formula is 2A. When the left upper
inference is not 2 : r, we can handle the cases in a similar way to the case
of (4) above. When the left upper inference is 2 : r, we apply the following
transformation.
(7)
⊡Γ, 2Δ ⇒A
⊡Γ, 2Δ ⇒2A 2 : r
A, Π ⇒Θ
2A, Π ⇒Θ 2 : l
⊡Γ, 2Δ, Π ⇒Θ
cut
▽
⊡Γ, 2Δ ⇒A
A, Π ⇒Θ
⊡Γ, 2Δ, Π ⇒Θ
cut
d(P) is reduced by one in (7). So, we can eliminate the new cut inferences in
(7).

210
H. Kurokawa and H. Kushida
References
1. Artemov, S.N.: Explicit provability and constructive semantics. The Bulletin of
Symbolic Logic 7(1), 1–36 (2001)
2. Avron, A.: The semantics and proof theory of linear logic. Theoretical Computer
Science 57, 161–184 (1988)
3. Doˇsen, K.: Modal translations in substructural logics. Journal of Philosophical
Logic 21(3), 283–336 (1992)
4. Girard, J.: Linear logic. Theoretical Computer Science 50, 1–102 (1987)
5. G¨odel, K.: Zum intuitionistischen Aussagenkalk¨ul. Anzeiger Akademie der Wis-
senschaften Wien, Mathematisch-naturwiss. Klasse 32, 65–66 (1932)
6. Kuznets, R.: Self-referential justiﬁcations in epistemic logic. Theory of Computing
Systems 46(4), 636–661 (2010)
7. Paoli, F.: Substructural Logics: A Primer. Trends in Logic, vol. 13. Kluwer Aca-
demic Pub. (2002)
8. Pulver, C.: Self-referentiality in contraction-free fragments of modal logic S4. MS.
Thesis (2010)
9. Takeuti, G.: Proof Theory, 2nd edn. North Holland (1987)
10. Yu, J.: Prehistoric phenomena and self-referentiality. In: Ablayev, F., Mayr, E.W.
(eds.) CSR 2010. LNCS, vol. 6072, pp. 384–396. Springer, Heidelberg (2010)
11. Yu, J.: Self-referentiality in the brouwer–heyting–kolmogorov semantics of intu-
itionistic logic. In: Artemov, S., Nerode, A. (eds.) LFCS 2013. LNCS, vol. 7734,
pp. 401–414. Springer, Heidelberg (2013)
12. Yu, J.: Prehistoric graph of modal sequent proof and non-self-referential realization
(unpublished manuscript)

Full Lambek Hyperdoctrine: Categorical
Semantics for First-Order Substructural Logics
Yoshihiro Maruyama⋆
Quantum Group, Dept. of Computer Science, University of Oxford
http://researchmap.jp/ymaruyama
Abstract. We pursue the idea that predicate logic is a “ﬁbred algebra”
while propositional logic is a single algebra; in the context of intuitionism,
this algebraic understanding of predicate logic goes back to Lawvere, in
particular his concept of hyperdoctrine. Here, we aim at demonstrating
that the notion of monad-relativised hyperdoctrines, which are what we
call ﬁbred algebras, yields algebraisations of a wide variety of predicate
logics. More speciﬁcally, we discuss a typed, ﬁrst-order version of the non-
commutative Full Lambek calculus, which has extensively been studied in
the past few decades, functioning as a unifying language for diﬀerent sorts
of logical systems (classical, intuitionistic, linear, fuzzy, relevant, etc.).
Through the concept of Full Lambek hyperdoctrines, we establish both
generic and set-theoretical completeness results for any extension of the
base system; the latter arises from a dual adjunction, and is relevant to
the tripos-to-topos construction and quantale-valued sets. Furthermore,
we give a hyperdoctrinal account of Girard’s and G¨odel’s translation.
1
Introduction
Categorical logic deconstructs the traditional dichotomy between proof theory
and model theory, in the sense that both of them can be represented in cer-
tain syntactic and set-theoretical categories (or hyperdoctrines in this paper)
respectively. We may thus say that categorical semantics does encompass both
proof-theoretic and model-theoretic semantics in terms of philosophy of logic.
Categorical semantics divides into two sub-disciplines: semantics of provability
(e.g., semantics via toposes or logoses) and semantics of proofs (e.g., semantics
via CCC or monoidal CC). Our focus shall be upon the former wrt. logic and the
latter wrt. type theory because we aim at developing categorical semantics for a
broad range of logics over type theories, including classical, intuitionistic, linear,
and fuzzy logics. Type theories have inherent identities of proofs (or terms), and
fully admit semantics of proofs, however, logics in general do not allow semantics
of proofs, due to collapsing phenomena on their identities of proofs (for the case
of classical logic, refer to the Joyal lemma, e.g., in Lambek-Scott [11]).
Thus, the Curry-Howard paradigm does not make so much sense in this gen-
eral context of logics over type theories, for the logics of the latter (types) may
⋆I am indebted to Samson Abramsky and Bob Coecke for both useful discussion and
kind encouragement. This work was supported by the Nakajima Foundation.
L. Libkin, U. Kohlenbach, and R. de Queiroz (Eds.): WoLLIC 2013, LNCS 8071, pp. 211–225, 2013.
c
⃝Springer-Verlag Berlin Heidelberg 2013

212
Y. Maruyama
diﬀer from the former original logics (propositions), just as Abramsky-Coecke’s
type theory of quantum mechanics is distinct from Birkhoﬀ-von Neumann’s logic
of it. In general, we thus need to treat logic and type theory separately, and the
concept of ﬁbred universal algebras does the job, as elucidated below. Aczel’s
idea of logic-enriched type theory is along a similar line. Fibred algebras to
represent logics over monoidal type theories even allow us to reconcile Birkhoﬀ-
von Neumann’s cartesian logic of quantum propositions and Abramsky-Coecke’s
monoidal logic (or type theory) of quantum systems; this is future work, however.
Substructural logics over the Full Lambek calculus (FL for short), which en-
compass a wide variety of logical systems (classical, intuitionistic, linear, fuzzy,
relevant, etc.), have extensively been investigated in the past few decades, espe-
cially by algebraic logicians in relation to residuated lattices (a major reference
is Galatos-Jipsen-Kowalski-Ono [3]). Although some eﬀorts have been made to-
wards the algebraic treatment of logics over quantiﬁed FL (see, e.g., Ono [14,15]
and references therein), however, it seems that there has so far been no adequate
concept of algebraic models of them. Note that complete residuated lattices can
only give complete semantics for those classes of substructural predicate logics for
which completions (such as Dedekind-MacNeille’s or Crawley’s) of Lindenbaum-
Tarski algebras work adequately (see, e.g., Ono [14,15]); for this reason, complete
residuated lattices (or quantales) cannot serve the purpose.
In the context as articulated above, we propose ﬁbred algebras as algebraic
models of predicate logic, especially substructural logics over quantiﬁed FL. Fi-
bred algebras expand Lawvere’s concept of hyperdoctrine [12]. According to
Pitts’ formulation [16], a hyperdoctrine is a functor (presheaf) P : Cop →HA
where HA is the category of heyting algebras; there are additional conditions
on P (and C) to express quantiﬁers and other logical concepts (for a ﬁbrational
formulation of hyperdoctrine, see Jacobs [8]; the two formulations are equivalent
via the Grothendieck construction).1 We may see a hyperdoctrine as a ﬁbred
heyting algebra (P(C))C∈C, a bunch of algebras indexed by C.
Now, a ﬁbred algebra is a universal algebra indexed by a category: categori-
cally, it is a functor (presheaf) P : Cop →Alg(T ) (apart from logical conditions
to express quantiﬁers and others) where T is a monad on Set, and Alg(T ) is its
Eilenberg-Moore algebras; note that monads on Set are equivalent to (possibly
inﬁnitary) varieties in terms of universal algebra (see, e.g., Ad´amek et al. [1]).
The intuitive meaning of the base category C is the category of types (aka. sorts)
or domains of discourse, and then P(C) is the algebra of predicates on a type
C. If a propositional logic L is sound and complete wrt. a variety Alg(T ), then
the corresponding ﬁbred algebras P : Cop →Alg(T ) yield sound and complete
semantics for the predicate logic that extends L. This may be called the thesis
of completeness lifting: the completeness of propositional logic wrt. Alg(T ) lifts
to the completeness of predicate logic wrt. P : Cop →Alg(T ).
The present paper is meant to demonstrate the thesis in the fairly general
context of substructural logics over FL, hopefully bridging between algebraic
1 Toposes amount to higher-order hyperdoctrines via the two functors of taking sub-
object hyperdoctrines and of the tripos-to-topos construction (see, e.g., Frey [4]).

Full Lambek Hyperdoctrine
213
logic, in which logics over FL have been studied, and categorical logic, in which
hyperdoctrines have been pursued. Although the two disciplines are currently
separated to the author’s eyes, nevertheless, Lawvere’s original ideas on cate-
gorical logic are of algebraic nature (especially, his functorial semantics directly
targets universal algebra), and it would be fruitful to restore lost interactions
between them. Along this line of thought, in subsequent work, the author plans
to develop “Categorical Universal Logic” qua theory of ﬁbred universal algebras
or monad-relativised hyperdoctrines. The paper takes a ﬁrst step towards it.
Main technical contributions are three-fold as follows: (i) generic complete-
ness wrt. Full Lambek hyperdoctrines, which are hyperdoctrines for logics over
FL; (ii) Tarskian completeness wrt. Set-based models, which arise from a dual
adjunction, with more specialised completeness results; (iii) hyperdoctrinal for-
mulations of Girard’s translation and G¨odel’s translation. The generic and set-
theoretical completeness results are established for any axiomatic extension of
FL, therefore covering a great majority of standard logical systems (classical,
intuitionistic, linear, fuzzy, relevant, and so on). In passing, we brieﬂy discuss
the tripos-to-topos construction in the present context, which is originally due to
Hyland-Johnstone-Pitts [7]. Our uniform categorical semantics for various logi-
cal systems enables us to compare diﬀerent categorical logics on the one setting,
and (iii) indeed embodies such a comparison in terms of logical translation. The
paper proceeds in the same order as above, after an introduction to typed FL.
2
Typed Full Lambek Calculus
In this section, we deﬁne a typed (or many-sorted) version of quantiﬁed FL
as in Ono [15], which shall be called TFLq (“T” means “typed”; “q” means
“quantiﬁed”). In particular, TFLq follows the typing style of Pitts [16].
Standard categorical logic discusses a typed version of intuitionistic (or co-
herent or regular) logic, as observed in Pitts [16], Lambek-Scott [11], Jacobs [8],
and Johnstone [10]. Typed logic is more natural than single-sorted one from a
categorical point of view, and is more expressive in general, since it can encom-
pass various type constructors. If one prefers single-sorted logic to typed logic,
the latter can be reduced to the former by allowing for one type (or sort) only.
To put it diﬀerently, typed logic is the combination of logic and type theory,
and has not only a logic structure but also a type structure, and the latter itself
has a rich structure as well as the former. For this reason, syntactic hyperdoc-
trines constructed from typed systems of logic (which are discussed in relation
to completeness in the next section) are amalgamations of syntactic categories
obtained from their type theories on the one hand, and Lindenbaum-Tarski al-
gebras obtained from their logic parts on the other; in a nutshell, syntactic
hyperdoctrines are type-ﬁbred Lindenbaum-Tarski algebras.
Another merit of typed logic is that the problem of empty domains is resolved
because it allows us to have explicit control on type contexts. This was discovered
by Joyal, and shall be touched upon later, in more detail.

214
Y. Maruyama
TFLq has the following logical connectives:
⊗, ∧, ∨, \, /, 1, 0, ⊤, ⊥, ∀, ∃.
Note that there are two kinds of implication connectives \ and /, owing to the
non-commutative nature of TFLq.
In TFLq, every variable x comes with its type σ. That is, TFLq has basic
types, which are denoted by letters like σ, τ, and x : σ is a formal expression
meaning that a variable x is of type σ. Then, a (type) context is a ﬁnite list of
type declarations on variables: x1 : σ1, ..., xn : σn. A context is often denoted Γ.
Accordingly, TFLq has typed predicate symbols (aka. predicates in context)
and typed function symbols (aka. function symbols in context): R(x1, ..., xn) [x1 :
σ1, ..., xn : σn] is a formal expression meaning that R is a predicate with n
variables x1, ..., xn of types σ1, ..., σn respectively; likewise, f : τ [x1 : σ1, ..., xn :
σn] is a formal expression meaning that f is a function symbol with n variables
x1, ..., xn of types σ1, ..., σn and with its values in τ. Then, formulae-in-context
ϕ [Γ] and terms-in-context t : τ [Γ] are deﬁned in the usual, inductive way. Our
terminology is basically following Pitts [16].
In the present paper, we do not consider any speciﬁc type constructor. Higher-
Order Full Lambek Calculus shall be discussed in a subsequent paper, and have
products and function spaces as type constructors. In this paper, however, we
shall focus upon plainly typed predicate logic with no complicated type struc-
ture; still, products (not as types but as categorical structures) shall be used in
categorical semantics in the next section, to the end of interpreting predicate
and function symbols (of arity greater than one).
TFLq thus has both a type structure and a logic structure, dealing with
sequents-in-contexts: Φ ⊢ϕ [Γ] where Γ is a type context, and Φ is a ﬁnite
list of formulae: ϕ1, ..., ϕn. Although it is common to write Γ | Φ ⊢ϕ rather
than Φ ⊢ϕ [Γ], we employ the latter notation in this paper, following Pitts [16],
since TFLq is an adaptation of Pitts’ typed system for intuitionistic logic to the
system of the Full Lambek calculus.
The syntax of type contexts Γ in TFLq is the same as that of typed intu-
itionistic logic in Pitts [16]; due to space limitations, we do not repeat it here,
referring to Pitts [16] for details. Yet we note it is allowed to add a fresh x : σ
to a context Γ: e.g., Φ ⊢ϕ [Γ, x : σ] whenever Φ ⊢ϕ [Γ]. On the other hand, it
is not permitted to delete redundant variables; the reason becomes clear in later
discussion on empty domains. It is allowed to change the order of contexts (e.g.,
[Γ, Γ ′] into [Γ ′, Γ]). In the below, we focus upon logical rules of inference, which
are most relevant part of TFLq in the paper, being of central importance for us.
TFLq has no structural rule other than the following cut rule
Φ1 ⊢ϕ [Γ]
Φ2, ϕ, Φ3 ⊢ψ [Γ]
Φ2, Φ1, Φ3 ⊢ψ [Γ]
(cut)
where ψ may be empty; this is allowed in the following L (left) rules as well. As
usual, we have the rule of identity
ϕ ⊢ϕ [Γ] (id)

Full Lambek Hyperdoctrine
215
In the following, we list the rules of inference for the logical connectives of TFLq.
There are two kinds of conjunction in TFLq: multiplicative or monoidal ⊗and
additive or cartesian ∧:
Φ, ϕ, ψ, Ψ ⊢χ [Γ]
Φ, ϕ ⊗ψ, Ψ ⊢χ [Γ] (⊗L)
Φ ⊢ϕ [Γ]
Ψ ⊢ψ [Γ]
Φ, Ψ ⊢ϕ ⊗ψ [Γ]
(⊗R)
Φ, ϕ, Ψ ⊢χ [Γ]
Φ, ϕ ∧ψ, Ψ ⊢χ [Γ] (∧L1)
Φ, ϕ, Ψ ⊢χ [Γ]
Φ, ψ ∧ϕ, Ψ ⊢χ [Γ] (∧L2)
Φ ⊢ϕ [Γ]
Φ ⊢ψ [Γ]
Φ ⊢ϕ ∧ψ [Γ]
(∧R)
There is only one disjunction in TFLq, which is additive, since TFLq is intuition-
istic in the sense that only one formula is allowed to appear on the right-hand
side of sequents. Nevertheles, we can treat classical logic as an axiomatic ex-
tension of TFLq, by adding to TFLq exchange, weakening, contraction, and the
excluded middle; note that structural rules can be expressed as axioms.
Φ, ϕ, Ψ ⊢χ [Γ]
Φ, ψ, Ψ ⊢χ [Γ]
Φ, ϕ ∨ψ, Ψ ⊢χ [Γ]
(∨L)
Φ ⊢ϕ [Γ]
Φ ⊢ϕ ∨ψ [Γ] (∨R1)
Φ ⊢ϕ [Γ]
Φ ⊢ψ ∨ϕ [Γ] (∨R2)
Due to non-commutativity, there are two kinds of implication in TFLq, \ and /,
which are a right adjoint of ϕ ⊗(-) and a right adjoint of (-) ⊗ψ respectively.
Φ ⊢ϕ [Γ]
Ψ1, ψ, Ψ2 ⊢χ [Γ]
Ψ1, Φ, ϕ\ψ, Ψ2 ⊢χ [Γ]
(\L)
ϕ, Φ ⊢ψ [Γ]
Φ ⊢ϕ\ψ [Γ] (\R)
Φ ⊢ϕ [Γ]
Ψ1, ψ, Ψ2 ⊢χ [Γ]
Ψ1, ψ/ϕ, Φ, Ψ2 ⊢χ [Γ]
(/L)
Φ, ϕ ⊢ψ [Γ]
Φ ⊢ψ/ϕ [Γ] (/R)
There are two kinds of truth and falsity constants, monoidal and cartesian ones.
Ψ1, Ψ2 ⊢ϕ [Γ]
Ψ1, 1, Ψ2 ⊢ϕ [Γ] (1L)
⊢1 [Γ] (1R)
0 ⊢[Γ] (0L)
Φ ⊢[Γ]
Φ ⊢0 [Γ] (0R)
Φ ⊢⊤[Γ] (⊤R)
Φ1, ⊥, Φ2 ⊢ϕ [Γ] (⊥L)
Finally, we have the following rules for quantiﬁers ∀and ∃, in which type contexts
explicitly change; notice that type contexts do not change in the rest of the rules
presented above.
Φ1, ϕ, Φ2 ⊢ψ [x : σ, Γ]
Φ1, ∀xϕ, Φ2 ⊢ψ [x : σ, Γ] (∀L)
Φ ⊢ϕ [x : σ, Γ]
Φ ⊢∀xϕ [Γ]
(∀R)

216
Y. Maruyama
Φ1, ϕ, Φ2 ⊢ψ [x : σ, Γ]
Φ1, ∃xϕ, Φ2 ⊢ψ [Γ]
(∃L)
Φ ⊢ϕ [x : σ, Γ]
Φ ⊢∃xϕ [x : σ, Γ] (∃R)
As usual, there are eigenvariable conditions on the rules above: x does not appear
as a free variable in the bottom sequent of Rule ∀R; likewise, x does not appear
as a free variable in the bottom sequent of Rule ∃L. The other two rules do not
have eigenvariable conditions, and this is why contexts do not change in them.
The deducibility of sequents-in-context in TFLq is deﬁned in the usual way.
In this paper, we denote by FL the propositional (and hence no contextual) part
of TFLq. Note that what is called FL in the literature often lacks ⊥and ⊤.
As is well known, the following propositional (resp. predicate) logics can be
represented as axiomatic (to be precise, axiom-schematic) extensions of FL (resp.
TFLq): classical logic, intuitionistic logic, linear logic (without exponentials),
relevance logics, fuzzy logics such as G¨odel-Dummett logic (see, e.g., Galatos et
al. [3]). Given a set of axioms (to be precise, axiom schemata), say X, we denote
by FLX (resp. TFLq
X) the corresponding extension of FL (resp. TFLq) via X.
Lemma 1. The following sequents-in-context are deducible in TFLq:
– ϕ ⊗(∃xψ) ⊢∃x(ϕ ⊗ψ) [Γ] and ∃x(ϕ ⊗ψ) ⊢ϕ ⊗(∃xψ) [Γ].
– (∃xψ) ⊗ϕ ⊢∃x(ψ ⊗ϕ) [Γ] and ∃x(ψ ⊗ϕ) ⊢(∃xψ) ⊗ϕ [Γ].
where it is supposed that ϕ does not contain x as a free variable, and Γ contains
type declarations on those free variables that appear in ϕ and ∃xψ.
A striking feature of typed predicate logic is that domains of discourse in se-
mantics can be empty; they are assumed to be non-empty in the usual Tarski
semantics of predicate logic. This means that a type σ can be interpreted as an
initial object in a category. We therefore need no ad hoc condition on domains of
discourse if we work with typed predicate logic. This resolution of the problem
of empty domains is due to Joyal as noted in Marquis and Reyes [13].
A proof-theoretic manifestation of this feature is that the following sequent-
in-context is not necessarily deducible in TFLq: ∀xϕ ⊢∃xϕ [ ] where the context
is empty. Nonetheless, the following is deducible in TFLq: ∀xϕ ⊢∃xϕ [x : σ, Γ]
where Γ is an appropriate context including type declarations on free variables in
ϕ. This means that we can prove the sequent above when a type σ is inhabited.
Here, it is crucial that it is not allowed to delete redundant free variables (e.g.,
[x : σ, Γ] cannot be reduced into [Γ] even if x does not appear as a free variable in
formulae involved); however, it is allowed to add fresh free variables to a context.
3
Full Lambek Hyperdoctrine
It is well known that FL algebras (deﬁned below) provide sound and complete
semantics for propositional logic FL (see, e.g., Galatos et al. [3]). In this section
we show that ﬁbred FL algebras, or FL hyperdoctrines (deﬁned below), yield
sound and complete semantics for typed (or many-sorted) predicate logic TFLq.

Full Lambek Hyperdoctrine
217
We again emphasise the simple, algebro-logical idea that single algebras (sym-
bolically, A with no indexing) correspond to propositional logic, and ﬁbred alge-
bras (symbolically, (AC)C∈C indexed by a category C) correspond to predicate
logic. As universal algebra gives foundations for algebraic propositional logic, so
ﬁbred universal algebra lays foundations for algebraic predicate logic.
Deﬁnition 2 ([3]). (A, ⊗, ∧, ∨, \, /, 1, 0, ⊤, ⊥) is called an FL algebra iﬀ
– (A, ⊗, 1) is a monoid; 0 is a (distinguished) element of A;
– (A, ∧, ∨, ⊤, ⊥) is a bounded lattice, which induces a partial order ≤on A;
– for any a ∈A, a\(-) : A →A is a right adjoint of a ⊗(-) : A →A: i.e.,
a ⊗b ≤c iﬀb ≤a\c for any a, b, c ∈A;
– for any b ∈A, (-)/b : A →A is a right adjoint of (-) ⊗b : A →A: i.e.,
a ⊗b ≤c iﬀa ≤c/b for any a, b, c ∈A.
A homomorphism of FL algebras is deﬁned as a map preserving all the opera-
tions (⊗, ∧, ∨, \, /, 1, 0, ⊤, ⊥). FL denotes the category of FL algebras and their
homomorphisms.
Although 0 is just a neutral element of A with no axiom, the rules for 0 are
automatically valid by the deﬁnition of interpretations deﬁned below.
FL is an algebraic category (i.e., a category monadic over Set), or a variety in
terms of universal algebra, since the two adjointness conditions can be rephrased
by equations (see, e.g., Galatos et al. [3]). An axiomatic extension FLX of FL
corresponds to an algebraic full subcategory (or sub-variety) of FL, denoted
FLX (algebraicity follows from deﬁnability by axioms); this is the well-known,
logic-variety correspondence for logics over FL (see Galatos et al. [3]).
Deﬁnition 3. An FL (Full Lambek) hyperdoctrine is an FL-valued presheaf P :
Cop →FL such that C is a category with ﬁnite products, and the following
conditions on quantiﬁers hold:
– For any projection π : X × Y →Y in C, P(π) : P(Y ) →P(X × Y ) has a
right adjoint, denoted
∀π : P(X × Y ) →P(Y ).
And the corresponding Beck-Chevalley condition holds, i.e., the following
diagram commutes for any arrow f : Z →Y in C (π′ : X × Z →Z below
denotes a projection):
P(X × Y )
P(Y )
P(X × Z)
P(Z)
?
P (X×f)
-
∀π
?
P (f)
-
∀π′

218
Y. Maruyama
– For any projection π : X × Y →Y in C, P(π) : P(Y ) →P(X × Y ) has a
left adjoint, denoted
∃π : P(X × Y ) →P(Y ).
The corresponding Beck-Chevalley condition holds:
P(X × Y )
P(Y )
P(X × Z)
P(Z)
?
P (X×f)
-
∃π
?
P (f)
-
∃π′
Furthermore, the Frobenius Reciprocity conditions hold: for any projection
π : X × Y →Y in C, any a ∈P(Y ), and any b ∈P(X × Y ),
a ⊗(∃πb) = ∃π(P(π)(a) ⊗b)
(∃πb) ⊗a = ∃π(b ⊗P(π)(a)).
For an axiomatic extension FLX of FL, an FLX hyperdoctrine is deﬁned by
restricting the value category FL into FLX. An FL (resp. FLX) hyperdoctrine
is also called a ﬁbred FL (resp. FLX) algebra.
The category C of an FL hyperdoctrine P : C →FL is called its base category
or type category, and P is also called its predicate functor; intuitively, P(C) is
the algebra of predicates on a type, or domain of discourse, C.
Note that, in the deﬁnition above, we need two Frobenius Reciprocity condi-
tions due to the non-commutativity of FL algebras.
An FL hyperdoctrine may be seen as an indexed category, and so as a ﬁbration
via the Grothendieck construction. Although we discuss in terms of indexed
categories in this paper, we can do the job in terms of ﬁbrations as well. In the
view of ﬁbrations, each P(C) is called a ﬁbre of an FL hyperdoctrine P.
The FL (resp. FLX) hyperdoctrine semantics for TFLq (resp. TFLq
X) is de-
ﬁned as follows.
Deﬁnition 4. Fix an FL hyperdoctrine P : Cop →FL. An interpretation -
of TFLq in the FL hyperdoctrine P consists of the following:
– assignment of an object σ in C to each basic type σ in TFLq;
– assignment of an arrow f : τ [Γ] : σ1×...×σn →σ in C to each typed
function symbol f : τ [Γ] in TFLq where Γ is supposed to be x1 : σ1, ..., xn :
σn (note that σ1 × ... × σn makes sense because C has ﬁnite products);
– assignment of an element R [Γ] in P(Γ), which is an FL algebra, to each
typed predicate symbol R [Γ] in TFLq; if the context Γ is x1 : σ1, ..., xn : σn,
then Γ denotes σ1 × ... × σn.
Then, terms are inductively interpreted in the following way:
– x : σ [Γ1, x : σ, Γ2] is deﬁned as the following projection in C:
π : Γ1 × σ × Γ2 →σ.

Full Lambek Hyperdoctrine
219
– f(t1, ..., tn) : τ [Γ] is deﬁned as:
f ◦⟨t1 : σ1 [Γ], ..., tn : σn [Γ]⟩
where it is supposed that f : τ [x1 : σ1, ..., xn : σn], and t1 : σ1 [Γ], ..., tn :
σn [Γ]. Note that ⟨t1 : σ1 [Γ], ..., tn : σn [Γ]⟩above is the product (or
pairing) of arrows in C.
Formuli are then interpreted inductively in the following manner:
– R(t1, ..., tn) [Γ] is deﬁned as
P(⟨t1 : σ1[Γ], ..., tn : σn[Γ]⟩)(R [x : σ1, ..., xn : σn])
where R is a predicate symbol in context x1 : σ1, ..., xn : σn.
– ϕ ⊗ψ [Γ] is deﬁned as ϕ [Γ] ⊗ψ [Γ]. The other binary connectives
∧, ∨, \, / are interpreted in the same way. 1 [Γ] is deﬁned as the monoidal
unit of P(Γ). The other constants 0, ⊤, ⊥are interpreted in the same way.
– ∀xϕ [Γ] is deﬁned as
∀π(ϕ [x : σ, Γ])
where π : σ×Γ →Γ is a projection in C, and ϕ is a formula in context
[x : σ, Γ]. Similarly, ∃xϕ [Γ] is deﬁned as
∃π(ϕ [x : σ, Γ]).
Finally, satisfaction of sequents is deﬁned:
– ϕ1, ..., ϕn ⊢ψ [Γ] is satisﬁed in an interpretation - in an FL hyperdoctrine
P iﬀthe following holds in P(Γ):
ϕ1 [Γ] ⊗... ⊗ϕn [Γ] ≤ψ [Γ].
In case the right-hand side of a sequent is empty, ϕ1, ..., ϕn ⊢[Γ] is satisﬁed
in - iﬀϕ1 [Γ] ⊗... ⊗ϕn [Γ] ≤0 in P(Γ). In case the left-hand side
of a sequent is empty, ⊢ϕ [Γ] is satisﬁed in - iﬀ1 ≤ϕ[Γ] in P(Γ).
An interpretation of TFLq
X in an FLX hyperdoctrine is deﬁned by replacing FL
and TFLq above with FLX and TFLq
X respectively.
In the following, we show that the FL (resp. FLX) hyperdoctrine semantics is
sound and complete for TFLq (resp. TFLq
X). Let Φ [Γ] denote ϕ1 [Γ] ⊗... ⊗
ϕn [Γ] if Φ is ϕ1, ..., ϕn.
Intuitively, an arrow f in C is a term, and P(f) is a substitution opera-
tion (this is exactly true in syntactic hyperdoctrines deﬁned later); then, the
Beck-Chevalley conditions and the functoriality of P tell us that substitution
commutes with all the logical operations (namely, both propositional connec-
tives and quantiﬁers). From such a logical point of view, the meaning of the
Beck-Chevalley conditions is crystal clear; they just say that substitution after
quantiﬁcation is the same as quantiﬁcation after substitution.

220
Y. Maruyama
Proposition 5. If Φ ⊢ψ [Γ] is deducible in TFLq (resp. TFLq
X), then it is
satisﬁed in any interpretation in any FL (resp. FLX) hyperdoctrine.
Proof. Fix an FL or FLX hyperdoctrine P and an interpretation - in P. Initial
sequents in context are satisﬁed because a ≤a in any ﬁbre P(C). The cut rule
preserves satisfaction, since tensoring preserves ≤and ≤has transitivity. It is
easy to verify that all the rules for the logical connectives preserve satisfaction.
Let us consider universal quantiﬁer ∀. To show the case of Rule ∀R, assume
that Φ [x : σ, Γ] ≤ϕ [x : σ, Γ] in P(σ × Γ). It then follows that Φ [x :
σ, Γ] = P(π : σ × Γ →Γ)(Φ [Γ]) where π is a projection in C, and note
that Φ does not include x among its free variables by the eigenvariable condition.
We thus have P(π)(Φ [Γ]) ≤ϕ [x : σ, Γ]. Since ∀π : P(σ × Γ) →P(Γ)
is a right adjoint of P(π), it follows that Φ [Γ] ≤∀π(ϕ [x : σ, Γ]) = ∀xϕ [Γ].
We next show the case of ∀L. Assume that Φ1 [x : σ, Γ]⊗ϕ [x : σ, Γ]⊗Φ2 [x :
σ, Γ] ≤ψ [x : σ, Γ]. The adjunction condition for universal quantiﬁer gives
us P(π)(∀π(ϕ [x : σ, Γ])) ≤ϕ [x : σ, Γ] where π : σ × Γ →Γ is
a projection. Yet we also have P(π)(∀π(ϕ [x : σ, Γ])) = P(π)(∀xϕ [Γ]) =
∀xϕ [x : σ, Γ]. Since tensoring respects ≤, these together imply that Φ1 [x :
σ, Γ] ⊗∀xϕ [x : σ, Γ] ⊗Φ2 [x : σ, Γ] ≤ψ [x : σ, Γ].
It remains to show the case of existential quantiﬁer ∃. In order to prove that
Rule ∃L preserves satisfaction, assume that Φ1 [x : σ, Γ]⊗ϕ [x : σ, Γ]⊗Φ2 [x :
σ, Γ] ≤ψ [x : σ, Γ]. This is equivalent to the following: Φ1 [x : σ, Γ]⊗ϕ [x :
σ, Γ] ⊗Φ2 [x : σ, Γ] ≤P(π)(ψ [Γ]) where π : σ × Γ →Γ is a projec-
tion. Since ∃π : P(σ × Γ) →P(Γ) is left adjoint to P(π), it follows that
∃π(Φ1 [x : σ, Γ] ⊗ϕ [x : σ, Γ] ⊗Φ2 [x : σ, Γ]) ≤ψ [Γ]. This is equiva-
lent to the following: ∃π( P(π)(Φ1 [Γ]) ⊗ϕ [x : σ, Γ] ⊗P(π)(Φ2 [Γ]) ) ≤
ψ [Γ]. Repeated applications of the two Frobenius Reciprocity conditions give
us Φ1 [Γ] ⊗∃π(ϕ [x : σ, Γ]) ⊗Φ2 [Γ] ≤ψ [Γ]. Then we ﬁnally have the
following: Φ1 [Γ] ⊗∃xϕ [Γ] ⊗Φ2 [Γ] ≤ψ [Γ]. To show the case of ∃R,
assume that Φ [x : σ, Γ] ≤ϕ [x : σ, Γ]. The adjunction condition for exis-
tential quantiﬁer tells us that ϕ [x : σ, Γ] ≤P(π)(∃π(ϕ [x : σ, Γ])) where
π : σ × Γ →Γ is a projection. We thus have the following: Φ [x : σ, Γ] ≤
P(π)(∃π(ϕ [x : σ, Γ])) = ∃xϕ [x : σ, Γ]. This completes the proof.
Syntactic hyperdoctrines are then deﬁned as follows towards the goal of proving
completeness. They are the categoriﬁcaton of Lindenbaum-Tarski algebras.
Deﬁnition 6. The syntactic hyperdoctrine of TFLq is deﬁned as follows; that
of TFLq
X is deﬁned by replacing FL and TFLq below with FLX and TFLq
X.
We ﬁrst deﬁne the base category C. An object in C is a context Γ up to α-
equivalence (i.e., the naming of variables does not matter). An arrow in C from
an object Γ to another Γ ′ is a list of terms [t1, ..., tn] (up to equivalence) such
that t1 : σ1 [Γ], ..., tn : σn [Γ] where Γ ′ is supposed to be x1 : σ1, ..., xn : σn.
The syntactic hyperdoctrine P : Cop →FL is then deﬁned in the following
way. For an object Γ in C, let FormΓ = {ϕ | ϕ is a formula in context Γ}.
Deﬁne an equivalence relation ∼on FormΓ as follows: for ϕ, ψ ∈FormΓ , ϕ ∼ψ
iﬀboth ϕ ⊢ψ [Γ] and ψ ⊢ϕ [Γ] are deducible in TFLq. We then deﬁne

Full Lambek Hyperdoctrine
221
P(Γ) = FormΓ / ∼
with an FL algebra structure induced by the logical connectives.
The arrow part of P is deﬁned as follows. Let [t1, ..., tn] : Γ →Γ ′ be an arrow
in C where Γ ′ is x1 : σ1, ..., xn : σn. Then we deﬁne P([t1, ..., tn]) : P(Γ ′) →
P(Γ) by
P([t1, ..., tn])(ϕ) = ϕ[t1/x1, ..., tn/xn]
where it is supposed that t1 : σ1 [Γ], ..., tn : σn [Γ], and that ϕ is a formula in
context x1 : σ1, ..., xn : σn.
Intuitively, P(Γ) above is a Lindenbaum-Tarski algebra sliced with respect to
each Γ. It is straightforward to verify that the operations of P(Γ) above are well
deﬁned, and P(Γ) forms an FL algebra. We still have to check that P deﬁned
above is a hyperdoctrine; this is done in the following lemma.
Lemma 7. The syntactic hyperdoctrine P : Cop →FL (resp. FLX) is an FL
(resp. FLX) hyperdoctrine. In particular, it has quantiﬁer structures satisfying
the Beck-Chevalley and Frobenius Reciprocity conditions.
Proof. Since substitution commutes with all the logical connectives, P([t1, ..., tn])
deﬁned above is always a homomorphism of FL algebras. Thus, P is a contravari-
ant functor.
We have to verify that the base category C has ﬁnite products, or equivalently,
binary products. For objects Γ, Γ ′ in C, we deﬁne their product Γ ×Γ ′ as follows.
Suppose that Γ is x1 : σ1, ..., xn : σn, and Γ ′ is y1 : τ1, ..., ym : τm. Then, Γ × Γ ′
is deﬁned as x1 : σ1, ..., xn : σn, y1 : τ1, ..., ym : τm. An associated projection
π : Γ × Γ ′ →Γ ′ is deﬁned as [y1, ..., ym] : Γ × Γ ′ →Γ ′ where the context
of each yi is taken to be x1 : σ1, ..., xn : σn, y1 : τ1, ..., ym : τm (rather than
y1 : τ1, ..., ym : τm). The other projection is deﬁned in a similar way. It is easily
veriﬁed that these indeed form a categorical product in C.
In order to show that P has quantiﬁer structures, let π : Γ × Γ ′ →Γ ′ denote
the projection in C deﬁned above, and then consider P(π), which we have to
show has right and left adjoints. The right and left adjoints of P(π) can be
constructed as follows. Recall Γ is x : σ1, ..., xn : σn. Let ϕ ∈P(Γ × Γ ′); here
we are identifying ϕ with the equivalence class to which ϕ belongs, since every
argument below respects the equivalence. Then deﬁne ∀π : P(Γ × Γ ′) →P(Γ ′)
by ∀π(ϕ) = ∀x1...∀xnϕ where the formula on the right-hand side actually denotes
the corresponding equivalence class. Similarly, we deﬁne ∃π : P(Γ ×Γ ′) →P(Γ ′)
by ∃π(ϕ) = ∃x1...∃xnϕ. Let us show that ∀π is the right adjoint of P(π). We
ﬁrst assume P(π)(ψ) ≤ϕ in P(Γ × Γ ′) for ψ ∈P(Γ ′) and ϕ ∈P(Γ × Γ ′).
Then it follows from the deﬁnition of P and π that P(π)(ψ [Γ]) = ψ [Γ, Γ ′]
where we are making explicit the two diﬀerent contexts of ψ; the role of P(π)
just lies in changing contexts. Since the ≤of P(Γ × Γ ′) is induced by its lattice
structure, we have ϕ ∧ψ = ψ. It follows from the deﬁnition of P(Γ × Γ ′) that
ϕ ∧ψ ⊢ψ [Γ, Γ ′] and ψ ⊢ϕ ∧ψ [Γ, Γ ′] are deducible in TFLq (resp. TFLq
X),
whence ψ ⊢ϕ [Γ, Γ ′] is deducible as well. By repeated applications of rule

222
Y. Maruyama
∀R, it follows that ψ ⊢∀x1...∀xnϕ [Γ ′] is deducible. This implies that both
ψ ⊢ψ ∧∀x1...∀xnϕ [Γ ′] and ψ ∧∀x1...∀xnϕ ⊢ψ [Γ ′] are deducible, whence
ψ ≤∀x1...∀xnϕ in P(Γ ′).
We show the converse. Assume that ψ ≤∀x1...∀xnϕ in P(Γ ′). By arguing
as in the above, ψ ⊢∀x1...∀xnϕ [Γ ′] is deducible. By enriching the context,
ψ ⊢∀x1...∀xnϕ [Γ, Γ ′] is deducible. Since ∀x1...∀xnϕ ⊢ϕ [Γ, Γ ′] is deducible
by rule ∀L, the cut rule tells us that ψ ⊢ϕ [Γ, Γ ′] is deducible; note that the
contexts of two sequents-in-context must be the same when applying the cut
rule to them. It ﬁnally follows that P(π)(ψ) ≤ϕ in P(Γ × Γ ′). Thus, ∀π is the
right adjoint of P(π). Similarly, ∃π can be shown to be the left adjoint of P(π).
The Beck-Chevalley condition for ∀can be veriﬁed as follows. Let ϕ ∈P(Γ ×
Γ ′), π : Γ × Γ ′ →Γ ′ a projection in C, and π′ : Γ × Γ ′′ →Γ ′′ another
projection in C for objects Γ, Γ ′, Γ ′′ in C. Then, we have P([t1, ..., tn])◦∀π(ϕ) =
(∀x1...∀xnϕ)[t1/y1, ..., tn/ym] where it is supposed that Γ is x1 : σ1, ..., xn :
σn, Γ ′ is y1 : τ1, ..., ym : τm, and t1 : τ1 [Γ ′′], ..., tm : τm [Γ ′′]. We also have
the following ∀π′ ◦P([t1, ..., tn])(ϕ) = ∀x1...∀xn(ϕ[t1/y1, ..., tn/ym]). The Beck-
Chevalley condition for ∀thus follows. The Beck-Chevalley condition for ∃can
be veriﬁed in a similar way. The two Frobenius Reciprocity conditions for ∃
follow immediately from Lemma 1.
The syntactic hyperdoctrine is a free or classifying hyperdoctrine in a suitable
sense. It is the combination of the classifying category C above and the free
algebras P(Γ) above, which has the universal property inherited from both of
them, though we do not have space to work out the details in this paper.
Now, there is the obvious, canonical interpretation of TFLq (resp. TFLq
X) in
the syntactic hyperdoctrine of TFLq (resp. TFLq
X); it is straightforward to see:
Lemma 8. If Φ ⊢ψ [Γ] is satisﬁed in the canonical interpretation in the syntac-
tic hyperdoctrine of TFLq (resp. TFLq
X), it is deducible in TFLq (resp. TFLq
X).
The lemmata above give us the completeness result: If Φ ⊢ψ [Γ] is satisﬁed in
any interpretation in any FL (resp. FLX) hyperdoctrine, then it is deducible in
TFLq (resp. TFLq
X). Combining soundness and completeness, we obtain:
Theorem 9. Φ ⊢ψ [Γ] is deducible in TFLq (resp. TFLq
X) iﬀit is satisﬁed in
any interpretation in any FL (resp. FLX) hyperdoctrine.
4
Duality-Induced Set-Theoretical Hyperdoctrines
In this section, we discuss hyperdoctrines induced from dual adjunctions between
Set and FL, which are, so to say, many-valued powerset hyperdoctrines, and give
many-valued Tarski semantics with soundness and completeness, generalising the
powerset hyperdoctrine HomSet(-, 2), which is equivalent to Tarski semantics.
We mostly omit proofs in this section due to space limitations.
Theorem 10. Let Ω ∈FL. The following dual adjunction holds between Set
and FL, induced by Ω as a dualising object:
HomFL(-, Ω)op ⊣HomSet(-, Ω) : Setop →FL.

Full Lambek Hyperdoctrine
223
Proposition 11. Let Ω ∈FL with Ω complete. Then, HomSet(-, Ω) : Setop →
FL (resp. FLX) is an FL (resp. FLX) hyperdoctrine.
Proof. Let π : X×Y →Y be a projection in Set. We deﬁne ∀π and ∃π as follows:
given v ∈Hom(X × Y, Ω) and y ∈Y , let ∀π(v)(y) := {v(x, y) | x ∈X} and
∃π(v)(y) := {v(x, y) | x ∈X}. These yield the required quantiﬁer structures
with the Beck-Chevalley and Frobenius Reciprocity conditions; details omitted.
Now, we aim at obtaining completeness with respect to models of form
HomSet(-, Ω). The above proof tells us that ∀and ∃in HomSet(-, Ω) are ac-
tually meets and joins in Ω. This implies that if Ω is not complete, in general,
HomSet(-, Ω) cannot interpret quantiﬁers. At the same time, however, assum-
ing completeness prevents us from obtaining completeness for any axiomatic
extension TFLq
X of TFLq; this is why we do not assume it. Such incompleteness
phenomena have already been observed (see, e.g., Ono [14]). A standard remedy
to this problem is to restrict attention to “safe” interpretations while considering
general Ω. In our context, a safe interpretation - in HomSet(-, Ω) is such that
- uses those joins and meets only that exist in Ω, i.e., quantiﬁers are always
interpreted via existing joins and meets only. We then have completeness with
respect to the special class of set-theoretical models HomSet(-, Ω).
Theorem 12. Φ ⊢ψ [Γ] is deducible in TFLq
X iﬀit is satisﬁed in any safe
interpretation in HomSet(-, Ω) for any Ω ∈FL.
In the special case of TFLq, it suﬃces to consider complete Ω’s only: Φ ⊢
ψ [Γ] is deducible in TFLq iﬀit is satisﬁed in any interpretation in any FL
hyperdoctrine HomSet(-, Ω) with Ω ∈FL complete.
Focusing on a more speciﬁc context, we can further reduce the class of models
HomSet(-, Ω) into a smaller one. In the strongest case of classical logic, it suﬃces
to consider {0, 1} only in the place of Ω; this is exactly the Tarski completeness.
For an intermediate case, consider MTL (monoidal t-norm logic; see H´ajek et
al. [5]), which is FL expanded with exchange, weakening, and the pre-linearity
axiom, (ϕ →ψ) ∨(ψ →ϕ). The algebras of MTL are denoted by MTL. We
denote by MTLq the quantiﬁed version with the additional axiom of ∀-∨dis-
tributivity, i.e., ∀x(ϕ ∨ψ) ↔∀xϕ ∨ψ where x does not occur in ψ as a free
variable, and by MTLq
X an axiomatic extension of MTLq.
Theorem 13. Φ ⊢ψ [Γ] is deducible in MTLq
X iﬀit is satisﬁed in any inter-
pretation in HomSet(-, Ω) for any linearly ordered Ω ∈MTLX.
We brieﬂy discuss the tripos-topos construction in the present context of FL
hyperdoctrines; it is originally due to Hyland-Johnstone-Pitts [7]. To this end,
we work in the internal logic of FL hyperdoctrines P : Cop →FL: i.e., we
have types X and function symbols f corresponding to objects X and arrows
f in C respectively, and also those predicate symbols R on a type C ∈C that
correspond to elements R ∈P(C).
Deﬁnition 14. Let P be an FL hyperdoctrine. We deﬁne a category T[P] as fol-
lows. An object of T[P] is a partial equivalence relation, i.e., a pair (X, EX) such

224
Y. Maruyama
that X is an object in the base category C, and EX is an element of P(X×X) and
is symmetric and transitive in the internal logic of P: EX(x, y) ⊢EX(y, x) [x, y :
X] and EX(x, y), EX(y, z) ⊢EX(x, z) [x, y, z : X].
An arrow from (X, EX) to (Y, EY ) is F ∈P(X × Y ) such that (i) extension-
ality: EX(x1, x2), EY (y1, y2), F(x1, y1) ⊢F(x2, y2) [x1, x2 : X, y1, y2 : Y ]; (ii)
strictness: F(x, y) ⊢EX(x, x) ∧EY (y, y) [x : X, y : Y ]; (iii) single-valuedness:
F(x, y1), F(x, y2) ⊢EY (y1, y2) [x : X, y1, y2 : Y ]; (iv) totality: EX(x, x) ⊢
∃y F(x, y) [x : X]. Such an F is called a functional relation.
For a complete FL algebra Ω, which is a quantale with additional operations,
T[HomSet(-, Ω)] may be called the category of Ω-valued sets. Quantale sets in
the sense of H¨ohle et al. [6] are objects in T[HomSet(-, Ω)], but not vice versa:
our Ω-valued sets are slightly more general than their quantale sets.
Note that if Ω is a locale, T[HomSet(-, Ω)] is the Higgs topos of Ω-valued
sets, which is in turn equivalent to the category of sheaves on Ω.
5
Girard’s and G¨odel’s Translation Hyperdoctrinally
In this section, we discuss Girard’s and G¨odel’s translation theorems on the
hyperdoctrinal setting. The former embeds intuitionistic logic into linear logic via
exponential !; the latter embeds classical logic into intuitionistic logic via double
negation ¬¬. Since logic is dual to algebraic semantics, we construct intuitionistic
(resp. classical) hyperdoctrines from linear (resp. intuitionistic) hyperdoctrines.
We omit proofs in this section as well for space limitations.
We ﬁrst consider G¨odel’s translation. We think of ¬¬ as a functor Fix¬¬
from HA, the category of heyting algebras, to BA, the category of boolean
algebras: i.e., deﬁne Fix¬¬(A) = {a ∈A | ¬¬a = a}; the arrow part is deﬁned
by restriction. Here, Fix¬¬(A) forms a boolean algebra.
Let us deﬁne IL hyperdoctrines as FL hyperdoctrines with values in HA.
Likewise, CL hyperdoctrines are deﬁned as FL hyperdoctrines with values in BA.
Note that both kinds of hyperdoctrines are TFLq
X hyperdoctrines with suitable
choices of axioms X. Finally, G¨odel’s translation theorem can be understood in
terms of hyperdoctrines as follows.
Theorem 15. Let P : Cop →HA be an IL hyperdoctrine. Then, the following
composed functor Fix¬¬ ◦P : Cop →BA forms a CL hyperdoctrine.
This is a ﬁrst-order and hyperdoctrinal version of the construction of boolean
toposes from given toposes via double negation topologies on them.
We can treat Girard’s translation along a similar line. An exponential ! on
an FL algebra A is deﬁned as a unary operation satisfying: (i) a ≤b implies
!a ≤!b; (ii) !!a =!a ≤a; (iii) !⊤= 1; (iv) !a⊗!b =!(a ∧b) (see Coumans et al. [2]).
We denote by FL!
c the category of commutative FL algebras with ! and maps
preserving both ! and FL algebra operations; they give the algebraic counterpart
of intuitionistic linear logic with !, denoted ILL.
We regard exponential ! as a functor Fix! from FL!
c to HA: deﬁne Fix!(A) =
{a ∈A | !a = a}; the arrow part is deﬁned by restriction. Fix!(A) is the set of

Full Lambek Hyperdoctrine
225
those elements of A that admit structural rules, and forms a heyting algebra.
ILL hyperdoctrines are deﬁned as FL hyperdoctrines with values in FL!
c.
Theorem 16. Let P : Cop →FL!
c be an ILL hyperdoctrine. Then, the following
composed functor Fix! ◦P : Cop →HA forms an IL hyperdoctrine.
The theorem above is slightly more general than Girard’s translation theorem,
in the sense that the latter corresponds to the case of syntactic hyperdoctrines
in the former. Although in this paper we do not explicitly discuss substructural
logics enriched with modalities and their hyperdoctrinal semantics, neverthe-
less, our method perfectly works for them as well, yielding the corresponding
soundness and completeness results in terms of hyperdoctrines with values in
FL algebras with modalities; Girard’s ! is just a special case.
References
1. Ad´amek, J., Herrlich, H., Strecker, G.E.: Abstract and Concrete Categories. John
Wiley and Sons, Inc. (1990)
2. Coumans, D., Gehrke, M., van Rooijen, L.: Relational semantics for full linear
logic. To appear in J. Applied Logic
3. Galatos, N., Jipsen, P., Kowalski, T., Ono, H.: Residuated Lattices: An Algebraic
Glimpse at Substructural Logics. Elsevier (2007)
4. Frey, J.: A 2-Categorical Analysis of the Tripos-to-Topos Construction (preprint)
5. H´ajek, P., Cintula, P.: On theories and models in fuzzy predicate logics. J. Symb.
Log. 71, 863–880 (2006)
6. H¨ohle, U., Kubiak, T.: A non-commutative and non-idempotent theory of quantale
sets. Fuzzy Sets and Systems 166, 1–43 (2011)
7. Hyland, M., Johnstone, P.T., Pitts, A.: Tripos Theory. Math. Proc. Cambridge
Philos. Soc. 88, 205–232 (1980)
8. Jacobs, B.: Categorical Logic and Type Theory. Elsevier (1999)
9. Johnstone, P.T.: Stone Spaces. CUP (1982)
10. Johnstone, P.T.: Sketches of an Elephant. OUP (2002)
11. Lambek, J., Scott, P.J.: Introduction to Higher-Order Categorical Logic (1986)
12. Lawvere, F.W.: Adjointness in Foundations. Dialectica 23, 281–296 (1969)
13. Marquis, J.-P., Reyes, G.: The History of Categorical Logic: 1963-1977. In: Hand-
book of the History of Logic, vol. 6, pp. 689–800. Elsevier (2011)
14. Ono, H.: Algebraic semantics for predicate logics and their completeness. RIMS
Kokyuroku 927, 88–103 (1995)
15. Ono, H.: Crawley Completions of Residuated Lattices and Algebraic Completeness
of Substructural Predicate Logics. Studia Logica 100, 339–359 (2012)
16. Pitts, A.: Categorical Logic. In: Handbook of Logic in Computer Science, vol. 5,
ch. 2. OUP (2000)

A Finite Model Property for G¨odel Modal Logics
Xavier Caicedo1, George Metcalfe2,⋆, Ricardo Rodr´ıguez3, and Jonas Rogger2
1 Departamento de Matem´aticas, Universidad de los Andes, Bogot´a, Colombia
xcaicedo@uniandes.edu.co
2 Mathematical Institute, University of Bern, Switzerland
{george.metcalfe,jonas.rogger}@math.unibe.ch
3 Departamento de Computaci´on, Universidad de Buenos Aires, Argentina
ricardo@dc.uba.ar
Abstract. A new semantics with the ﬁnite model property is provided
and used to establish decidability for G¨odel modal logics based on (crisp
or fuzzy) Kripke frames combined locally with G¨odel logic. A similar
methodology is also used to establish decidability, and indeed co-NP-
completeness for a G¨odel S5 logic that coincides with the one-variable
fragment of ﬁrst-order G¨odel logic.
1
Introduction
G¨odel modal logics combine Kripke frames of modal logics with the semantics of
the well-known fuzzy (and intermediate) G¨odel logic. These logics, in particular,
analogues GK (for “fuzzy” frames) and GKC (for “crisp” frames) of the modal
logic K, have been investigated in some detail by Caicedo and Rodr´ıguez [7,6]
and Metcalfe and Olivetti [13,14]. More general approaches, focussing mainly on
ﬁnite-valued modal logics, have been developed by Fitting [9,10], Priest [15], and
Bou et al. [4]. Multimodal variants of GK have also been proposed as the basis
for fuzzy description logics in [12] and (restricting to ﬁnite models) [3].
Axiomatizations were obtained for the box and diamond fragments of GK
(where the box fragments of GK and GKC coincide) in [7] and for the diamond
fragment of GKC in [14]. It was subsequently shown in [6] that the full logic GK
is axiomatized either by adding the Fischer Servi axioms for intuitionistic modal
logic IK (see [8]) to the union of the axioms for both fragments, or by adding the
prelinearity axiom for G¨odel logic to IK. Decidability of the diamond fragment
of GK was established in [7], using the fact that the fragment has the ﬁnite
model property with respect to its Kripke semantics. This ﬁnite model property
fails for the box fragment of GK and GKC and the diamond fragment of GKC,
but decidability and PSPACE-completeness for these fragments was established
in [13,14] using analytic Gentzen-style proof systems.
The ﬁrst main contribution of this paper is to establish the decidability of
validity in full GK and GKC by providing an alternative Kripke semantics for
⋆Supported
by
Swiss
National
Science
Foundation
grants
20002 129507
and
200021 146748.
L. Libkin, U. Kohlenbach, and R. de Queiroz (Eds.): WoLLIC 2013, LNCS 8071, pp. 226–237, 2013.
c
⃝Springer-Verlag Berlin Heidelberg 2013

A Finite Model Property for G¨odel Modal Logics
227
these logics that have the same valid formulas as the original semantics, but
also admit the ﬁnite model property. The key idea of the new semantics is to
restrict evaluations of modal formulas at a given world to a particular ﬁnite set of
truth values. We then use a similar strategy to establish decidability, and indeed
co-NP completeness, for the crisp G¨odel modal logic GS5C based on S5 frames
where accessibility is an equivalence relation. Moreover, this logic, an extension
of the intuitionistic modal logic MIPC of Bull [5] and Prior [16] with prelinearity
and a further modal axiom, corresponds exactly to the one-variable fragment of
ﬁrst-order G¨odel logic (see [11]).
2
G¨odel Modal Logics
G¨odel modal logics are deﬁned based on a language L□♦consisting of a ﬁxed
countably inﬁnite set Var of (propositional) variables, denoted p, q, . . ., binary
connectives →, ∧, ∨, constants ⊥, ⊤, and unary operators □and ♦. The set of
formulas Fml□♦, with arbitrary members denoted ϕ, ψ, χ, . . . is deﬁned induc-
tively as usual, as are subformulas of formulas. We call formulas of the form □ϕ
and ♦ϕ box-formulas and diamond-formulas, respectively, and ﬁx the length of
a formula ϕ, denoted ℓ(ϕ), to be the number of symbols occurring in ϕ. We also
deﬁne ¬ϕ = ϕ →⊥and let Var(ϕ) denote the set of all variables occurring in
the formula ϕ.
The standard semantics of G¨odel logic is characterized by the G¨odel t-norm
min and its residuum →G, deﬁned on the real unit interval [0, 1] by
x →G y =
3
y
if x > y
1
otherwise.
The G¨odel modal logics GK and GKC are deﬁned semantically as generalizations
of the modal logic K where connectives behave at a given world as in G¨odel logic.
A fuzzy Kripke frame is a pair F = ⟨W, R⟩where W is a non-empty set of
worlds and R: W × W →[0, 1] is a binary fuzzy accessibility relation on W. If
Rxy ∈{0, 1} for all x, y ∈W, then R is called crisp and F, a crisp Kripke frame.
In this case, we often write R ⊆W × W and Rxy to mean Rxy = 1.
A GK-model is a triple M = ⟨W, R, V ⟩, where ⟨W, R⟩is a fuzzy Kripke
frame and V : Var × W →[0, 1] is a mapping, called a valuation, extended to
V : Fml□♦× W →[0, 1] as follows:
V (⊥, x) = 0
V (⊤, x) = 1
V (ϕ →ψ, x) = V (ϕ, x) →G V (ψ, x)
V (ϕ ∧ψ, x) = min(V (ϕ, x), V (ψ, x))
V (ϕ ∨ψ, x) = max(V (ϕ, x), V (ψ, x))
V (□ϕ, x) = inf{Rxy →G V (ϕ, y) : y ∈W}
V (♦ϕ, x) = sup{min(Rxy, V (ϕ, y)) : y ∈W}.

228
X. Caicedo et al.
A GKC-model satisﬁes the extra condition that ⟨W, R⟩is a crisp Kripke frame.
In this case, the conditions for □and ♦may also be read as
V (□ϕ, x) = inf({1} ∪{V (ϕ, y) : Rxy})
V (♦ϕ, x) = sup({0} ∪{V (ϕ, y) : Rxy}).
A formula ϕ ∈Fml□♦is valid in a GK-model M = ⟨W, R, V ⟩if V (ϕ, x) = 1 for
all x ∈W. If ϕ is valid in all L-models for some logic L (in particular GK or
GKC), then ϕ is said to be L-valid, written |=L ϕ.
It is shown in [7] that validity in the box and diamond fragments of GK are
axiomatized by extending any axiom system for G¨odel logic (e.g., intuitionistic
logic plus the prelinearity axiom (ϕ →ψ) ∨(ψ →ϕ)) with, respectively:
□(ϕ →ψ) →(□ϕ →□ψ)
and
♦(ϕ ∨ψ) →(♦ϕ ∨♦ψ)
¬¬□ϕ →□¬¬ϕ
♦¬¬ϕ →¬¬♦ψ
ϕ / □ϕ
¬♦⊥
ϕ →ψ / ♦ϕ →♦ψ.
Moreover, it was shown in [6] that extending the union of these axiomatizations
with the following Fischer Servi axioms (see [8]) axiomatizes the full logic GK
(equivalently, extending the intuitionistic modal logic IK with prelinearity):
♦(ϕ →ψ) →(□ϕ →♦ψ)
(♦ϕ →□ψ) →□(ϕ →ψ).
The box fragment of GKC coincides with the box fragment of GK [7], while
the diamond fragment of GKC is axiomatized by adding the rule χ ∨(ϕ →
ψ) / ♦χ ∨(♦ϕ →♦ψ) to the diamond fragment of GK [14]. No axiomatization
has yet been found for the full logic GKC.
Let us agree to call a model ﬁnite if its set of worlds is ﬁnite, and say that a
logic has the ﬁnite model property if validity in the logic coincides with validity in
all ﬁnite models of the logic. In [7], it is shown that the formula □¬¬p →¬¬□p
is valid in all ﬁnite GK-models, but not in the inﬁnite crisp model ⟨N, R, V ⟩
where Rxy = 1 for all x, y ∈N and V (p, x) = 1/(x + 1) for all x ∈N. That
is, neither GK nor GKC has the ﬁnite model property. The diamond fragment of
GK (but not of GKC) does have the ﬁnite model property and this can be used
to show that validity in the fragment is decidable [7]. Decidability and indeed
PSPACE-completeness of validity in the box and diamond fragments of both GK
and GKC was established in [13,14] using analytic Gentzen-style proof systems.
However, decidability of validity in the full logics GK and GKC has not as yet
been established, and indeed will be the main goal of the following two sections.
3
A New Semantics and Finite Model Property
In order for a GKC-model to render the formula ϕ = □¬¬p →¬¬□p invalid
at a world x, there must be values of p at worlds accessible to x that form an

A Finite Model Property for G¨odel Modal Logics
229
inﬁnite descending sequence tending to but never reaching 0. This ensures that
the inﬁnite model falsiﬁes ϕ, but also that no particular world acts as a “witness”
to the value of □p. Our strategy in what follows will be to redeﬁne models to
allow only a ﬁnite number of values at each world that can be taken by box-
formulas and diamond-formulas. A formula such as □p can then be “witnessed”
at a world where the value of p is merely “suﬃciently close” to the value of □p.
Let us deﬁne a GFK-model as a quadruple M = ⟨W, R, T, V ⟩, where ⟨W, R, V ⟩
is a GK-model and T : W →P<ω([0, 1]) is a function from worlds to ﬁnite sets
of truth values satisfying {0, 1} ⊆T (x) ⊆[0, 1] for all x ∈W. If ⟨W, R, V ⟩is
also a GKC-model, then M will be called a GFKC-model.
The GFK-valuation V is extended to formulas using the same clauses for
non-modal connectives as for GK-valuations, together with the revised modal
connective clauses:
V (□ϕ, x) = max{r ∈T (x) : r ≤inf{Rxy →G V (ϕ, y) : y ∈W}}
V (♦ϕ, x) = min{r ∈T (x) : r ≥sup{min(Rxy, V (ϕ, y)) : y ∈W}}.
As before, a formula ϕ ∈Fml□♦is valid in a GFK-model M = ⟨W, R, T, V ⟩if
V (ϕ, x) = 1 for all x ∈W, written M |=GFK ϕ.
Observe now that for the formula ϕ = □¬¬p →¬¬□p, there are very simple
ﬁnite GFKC-counter-models: for example, M0 = ⟨W, R, T, V ⟩with W = {a},
Raa = 1, T (a) = {0, 1}, and V (p, a) = 1
2. It is easy to see that V (¬p, a) = 0,
Raa →G V (¬¬p, a) = 1, and so V (□¬¬p, a) = 1. Moreover, V (□p, a) = 0
(since Raa →G V (p, a) = 1
2, and 0 is the next smaller element of T (a)); hence
V (¬□p, a) = 1 and V (¬¬□p, a) = 0. So 1 = V (□¬¬p, a) > V (¬¬□p, a) = 0 and
M0 ⊭GFKC □¬¬p →¬¬□p.
Of course, such an observation is useful only if the new semantics characterizes
the same logics. For convenience, let us agree to write WM, RM, TM, and VM
for, respectively, the set of worlds, accessibility relation, truth value function,
and valuation function of an L-model M where L ∈{GK, GKC, GFK, GFKC}. In
the next section, we prove the following:
Theorem 1. For each ϕ ∈Fml□♦:
(a) |=GK ϕ iﬀ|=GFK ϕ iﬀϕ is valid in all GFK-models M satisfying
|WM| ≤(ℓ(ϕ) + 2)ℓ(ϕ) and |TM(x)| ≤ℓ(ϕ) + 2 for all x ∈WM.
(b) |=GKC ϕ iﬀ|=GFKC ϕ iﬀϕ is valid in all GFKC-models M satisfying
|WM| ≤(ℓ(ϕ) + 2)ℓ(ϕ) and |TM(x)| ≤ℓ(ϕ) + 2 for all x ∈WM.
For decidability, we then reason as follows. Observe ﬁrst that for any ﬁnite GFK-
model M and formula ϕ, the values taken by the subformulas of ϕ and the fuzzy
accessibility relation RM are contained in the ﬁnite set
U =

x∈WM
({VM(p, x) : p ∈Var(ϕ)} ∪{RMxy : y ∈WM} ∪TM(x)).
Moreover, using Lemma 1(c) below, we may assume without loss of generality
that U = {0,
1
|U|−1, . . . , |U|−2
|U|−1, 1}. Hence, by Theorem 1, to check whether ϕ is

230
X. Caicedo et al.
GK-valid or GKC-valid, it suﬃces to consider ﬁnitely many diﬀerent ﬁnite GFK-
models or GFKC-models M (with |WM| ≤(ℓ(ϕ) + 2)ℓ(ϕ)). So we obtain:
Theorem 2. Validity in GK and GKC are decidable.
4
Proof of Theorem 1
We begin by ﬁxing some useful notation. For a fuzzy Kripke frame ⟨W, R⟩, we
deﬁne a crisp relation R+ = {(x, y) ∈W 2 : Rxy > 0} and let R+[x] = {y ∈W :
R+xy} for each x ∈W.
We call ⟨W ′, R′⟩a subframe of ⟨W, R⟩, written ⟨W ′, R′⟩⊆⟨W, R⟩, if W ′ ⊆W
and R′ is R restricted to W ′. A submodel 
M of a model M is based on a subframe
⟨W
M, R
M⟩⊆⟨WM, RM⟩, with T
M (if appropriate) and V
M being, respectively,
TM and VM restricted to W
M. In particular, given X ⊆WM, the submodel of
M generated by X is the smallest submodel 
M of M satisfying X ⊆W
M and
for all x ∈W
M, if y ∈R+
M[x] then y ∈W
M. Also, M will be called a tree-model
if ⟨WM, R+
M⟩is a tree, and the height hg(M) of M is the height of ⟨WM, R+
M⟩
(possibly ∞).
Parts (a) and (b) of the following lemma generalize well-known results for the
modal logic K (see, e.g., [2]), while part (c) generalizes a useful result from [14]
(Lemma 3.1). Their proofs will be omitted here, but follow very closely the ideas
of the previous proofs from the references.
Lemma 1. Let L ∈{GK, GKC, GFK, GFKC} and let M be an L-model.
(a) Given any generated submodel 
M of M, V
M(ϕ, x) = VM(ϕ, x) for all x ∈
W
M, and ϕ ∈Fml□♦.
(b) Given x0 ∈WM and ϕ ∈Fml□♦, there is an L-tree-model 
M with root 9x0
and hg(
M) ≤ℓ(ϕ) satisfying V
M(ϕ, 9x0) = VM(ϕ, x0).
(c) Given an order-embedding h: [0, 1] →[0, 1] satisfying h(0) = 0 and h(1) = 1,
consider 
M with W
M = WM, R
Mxy = h(RMxy), T
M(x) = h(TM(x)), and
V
M(p, x) = h(VM(p, x)) for all x, y ∈WM and p ∈Var. Then V
M(ϕ, x) =
h(VM(ϕ, x)) for all ϕ ∈Fml□♦and x ∈WM.
Note that the tree in (b), although it is of ﬁnite height, can still be inﬁnitely
branching and thus contain inﬁnitely many nodes (i.e., worlds).
We now provide the key construction of a GK-tree-model taking the same
values for formulas at its root as a given GFK-tree-model. Note ﬁrst that the
original GFK-model without the function T cannot play this role in general
since the inﬁmum or supremum required for calculating the value of a box or
diamond formula might not be in the set T (x0) (where x0 is the root world).
This problem is resolved by taking inﬁnitely many order-isomorphic copies of the
original GFK-model (without T ) in such a way that the open intervals between
members of T (x0) are “squeezed” closer to either their lower or upper bounds.
The obtained inﬁma and suprema will then coincide with the next smaller or

A Finite Model Property for G¨odel Modal Logics
231
larger member of T (x0), that is, the required values of the formulas at x0 in the
original GFK-model.
Lemma 2. For any GFK-tree-model M = ⟨W, R, T, V ⟩of ﬁnite height with root
x0, there is a GK-tree-model 
M = ⟨
W, 9R, 9V ⟩with root 9x0, such that 9V (ϕ, 9x0) =
V (ϕ, x0) for all ϕ ∈Fml□♦. Moreover, if M is crisp, then so is 
M.
Proof. The lemma is proved by induction on hg(M). The base case hg(M) = 0
is immediate, ﬁxing 
M = ⟨
W, 9R, 9V ⟩with 
W = W = {x0}, 9R = R = ∅, and
9V = V . For the inductive step hg(M) = n + 1, deﬁne for all y ∈R+[x0],
My = ⟨Wy, Ry, Ty, Vy⟩as the submodel of M generated by {y}. That is, My is a
GFK-tree-model of ﬁnite height with root y, hg(My) ≤n, and, by Lemma 1(a),
Vy(ϕ, x) = V (ϕ, x) for all x ∈Wy and ϕ ∈Fml□♦. So, by the induction hypothe-
sis, for each y ∈R+[x0], there is a GK-tree-model 
My = ⟨
Wy, 9Ry, 9Vy⟩(crisp if M
is crisp) with root 9y such that 9Vy(ϕ, 9y) = Vy(ϕ, y) (= V (ϕ, y)) for all ϕ ∈Fml□♦.
We now deﬁne inﬁnitely many copies of our models 
My such that at each copy,
all the values of our formulas (and fuzzy accessibility relation) get “squeezed”
closer and closer towards the next smaller (or next larger) element of T (x0). This
is achieved by deﬁning for each k ∈Z+, an order-embedding (using Lemma 1(c))
that “squeezes” the open interval between two members αi and αi+1 of T (x0)
into the interval (αi, αi + 1
k) (or (αi+1 −1
k, αi+1)), which gets inﬁnitely small as
k approaches inﬁnity.
More formally, consider T (x0) = {α1, . . . , αm} with 0 = α1 < . . . < αm = 1
and deﬁne a family of order-embeddings {hk}k∈Z+ from [0, 1] into [0, 1] satisfying
hk(0) = 0 and hk(1) = 1, such that
hk(αi) = αi
for all i ≤m and k ∈Z+
hk[(αi, αi+1)] = (αi, min(αi + 1
k, αi+1))
for all i ≤m −1 and even k ∈Z+
hk[(αi, αi+1)] = (max(αi, αi+1 −1
k), αi+1) for all i ≤m −1 and odd k ∈Z+.
Furthermore, for each y ∈R+[x0] and k ∈Z+, we deﬁne a GK-model 
Mk
y =
⟨
W k
y , 9Rk
y, 9V k
y ⟩such that for each k ∈Z+ and y ∈R+[x0]:
(1) 
W k
y is a copy of 
Wy with distinct worlds, where 9xk
y is the corresponding copy
of 9xy (the root is denoted by 9yk)
(2) 9Rk
y9xk
y9zk
y = hk( 9Ry9xy9zy), for all 9xk
y, 9zk
y ∈
W k
y
(3) 9V k
y (ϕ, 9xk
y) = hk(9Vy(ϕ, 9xy)) for all ϕ ∈Fml□♦and 9xk
y ∈
W k
y .
Note that for all y ∈R+[x0], 9xy, 9zy ∈
Wy, and ϕ ∈Fml□♦, if 9Ry9xy9zy →G
9Vy(ϕ, 9xy) ∈(αi, αi+1), then 9Rk
y9xk
y9zk
y →G 9V k
y (ϕ, 9xk
y) ∈(αi, αi + 1
k), for each even
k ∈Z+, and if min( 9Ry9xy9zy, 9Vy(ϕ, 9xy)) ∈(αi, αi+1), then min( 9Rk
y9xk
y9zk
y, 9V k
y (ϕ, 9xk
y))
∈(αi+1 −1
k, αi+1), for each odd k ∈Z+.
We now deﬁne the GK-tree-model 
M = ⟨
W, 9R, 9V ⟩with

232
X. Caicedo et al.

W = 	
y∈R+[x0]
	
k∈Z+ 
W k
y ∪{9x0}
9Rxz =
⎧
⎪
⎨
⎪
⎩
hk(Rx0y)
if x = 9x0 and z = 9yk for some y ∈R+[x0] and k ∈Z+
9Rk
yxz
if x, z ∈
W k
y for some y ∈R+[x0] and k ∈Z+
0
otherwise
9V (p, x) =
3
V (p, x0)
if x = 9x0
9V k
y (p, x)
if x ∈
W k
y for some y ∈R+[x0] and k ∈Z+.
If M is crisp, then for all y ∈R+[x0], 
My is crisp and so also are 
Mk
y for all
k ∈Z+. Hence, by construction, 
M is crisp. Moreover, 9V k
y (ϕ, 9xk
y) = 9V (ϕ, 9xk
y) for
all ϕ ∈Fml□♦and 9xk
y ∈
W \ {9x0}.
Now we prove that 9V (ϕ, 9x0) = V (ϕ, x0) for all ϕ ∈Fml□♦, proceeding by
induction on ℓ(ϕ). The base case ℓ(ϕ) = 1 follows directly from the deﬁnition of
9V . For the inductive step, the cases for the non-modal connectives follow easily
using the induction hypothesis. Let us just consider the case ϕ = □ψ, the case
ϕ = ♦ψ being very similar. There are two possibilities. Suppose ﬁrst that
V (□ψ, x0) = max{r ∈T (x0) : r ≤inf{Rx0y →G V (ψ, y) : y ∈W}} = 1.
Then for all y ∈R+[x0], Rx0y ≤V (ψ, y) and by Lemma 1(a), V (ψ, y) =
Vy(ψ, y) = 9Vy(ψ, 9y). Thus Rx0y ≤9Vy(ψ, 9y) and therefore, for all k ∈Z+ and
y ∈R+[x0],
9R9x09yk = hk(Rx0y) ≤hk(9Vy(ψ, 9y)) = 9V k
y (ψ, 9yk) = 9V (ψ, 9yk).
It follows that
9V (□ψ, 
x0) = inf{ 9R9x0z →G 9V (ψ, z) : z ∈
W} = 1 = V (□ψ, x0).
Now suppose that V (□ψ, x0) = αi < 1 for some i ≤m −1. Then Rx0z →G
V (ψ, z) ≥αi for all z ∈W, and thus, (⋆), 9R9x0z →G 9V (ψ, z) ≥αi for all z ∈
W,
by construction using the order-embeddings {hk}k∈Z+.
There are two subcases. First, suppose that there is at least one y ∈W such
that Rx0y →G V (ψ, y) = αi; call it y0. This means that Rx0y0 > V (ψ, y0) = αi
and for all k ∈Z+, 9V (ψ, 9yk
0) = 9V k
y0(ψ, 9yk
0) = hk(9Vy0(ψ, 9y0)) = hk(Vy0(ψ, y0)) =
hk(V (ψ, y0)) = hk(αi) = αi. Since Rx0y > αi, also for all k ∈Z+, 9R9x09yk
0 =
hk(Rx0y0) > αi = 9V (ψ, 9yk
0), and hence, using (⋆),
9V (□ψ, 9x0) = inf{ 9R9x0z →G 9V (ψ, z) : z ∈
W} = αi = V (□ψ, x0).
Now suppose that Rx0y →G V (ψ, y) > αi for all y ∈W. Since V (□ψ, x0) =
max{r ∈T (x0) : r ≤inf{Rx0y →G V (ψ, y) : y ∈W}} = αi, there is at least
one y ∈W such that Rx0y →G V (ψ, y) ∈(αi, αi+1); call it y0. Then, by con-
struction, for any ε > 0 there is a k ∈Z+ such that hk(Rx0y0 →G V (ψ, y0)) =
hk(Rx0y0) →G hk(V (ψ, y0)) = 9R9x09yk
0 →G 9V (ψ, 9yk
0) ∈(αi, αi + ε). Using (⋆),
9V (□ψ, 9x0) = inf{ 9R9x0z →G 9V (ψ, z) : z ∈
W} = αi = V (□ψ, x0).
⊓⊔

A Finite Model Property for G¨odel Modal Logics
233
A subset Σ ⊆Fml□♦will be called a fragment iﬀit is closed with respect to
taking subformulas and contains ⊥and ⊤. For a formula ϕ ∈Fml□♦, we let
Σ(ϕ) be the smallest fragment containing ϕ. Clearly, |Σ(ϕ)| ≤ℓ(ϕ) + 2.
We now show that given any ﬁnite fragment Σ and GK-tree-model M, we are
able to “prune” (i.e., remove branches from) M and introduce a suitable function
T to obtain a ﬁnite GFK-tree-model 
M such that the evaluations of formulas in
Σ at the roots of M and 
M coincide.
Lemma 3. Let Σ ⊆Fml□♦be a ﬁnite fragment. Then for any GK-tree-model
M = ⟨W, R, V ⟩of ﬁnite height with root x0, there is a ﬁnite GFK-tree-model

M = ⟨
W, 9R, 9T, 9V ⟩with ⟨
W, 9R⟩⊆⟨W, R⟩, root x0 ∈
W, |
W| ≤|Σ|hg(M), and
| 9T(x)| ≤|Σ| for all x ∈
W, such that 9V (ϕ, x0) = V (ϕ, x0) for all ϕ ∈Σ.
Moreover, if M is crisp, then so is 
M.
Proof. Let Σ□be the set of all box-formulas in Σ, Σ♦the set of all diamond-
formulas in Σ, and ΣVar the set of all variables in Σ. Let us also deﬁne Vx[Δ] =
{V (ϕ, x) : ϕ ∈Δ} for any x ∈W and Δ ⊆Fml□♦. We prove the lemma by
induction on hg(M). For the base case, it suﬃces to deﬁne 
W = W, 9R = R = ∅,
9V = V , and 9T (x0) = {0, 1}.
For the induction step hg(M) = n + 1, consider for each y ∈R+[x0], the
submodel My = ⟨Wy, Ry, Vy⟩of M generated by {y}. It is clear that each My
is a GK-tree-model of ﬁnite height with root y and hg(My) ≤n. Hence, by
the induction hypothesis, for each y ∈R+[x0] there is a ﬁnite GFK-tree model

My = ⟨
Wy, 9Ry, 9Ty, 9Vy⟩with ⟨
Wy, 9Ry⟩⊆⟨Wy, Ry⟩and root y, such that for all
ϕ ∈Σ: 9Vy(ϕ, y) = Vy(ϕ, y) (= V (ϕ, y)). Moreover, we know for all y ∈R+[x0]
that |
Wy| ≤|Σ|n and | 9Ty(x)| ≤|Σ| for all x ∈
Wy.
We now choose a ﬁnite number of appropriate y ∈R+[x0] in order to build
our ﬁnite GFK-model. To this end, note that we can view Vx0[Σ□∪Σ♦] ∪{0, 1}
as a ﬁnite set {α1, . . . , αm} with 0 = α1 < . . . < αm = 1. Then, for each
□ψ ∈Σ□, such that V (□ψ, x0) = αi < 1, choose a y = y□ψ ∈R+[x0] such that
Rx0y□ψ →G V (ψ, y□ψ) < αi+1, and for each ♦ψ ∈Σ♦, such that V (♦ψ, x) =
αi > 0, choose a y = y♦ψ ∈R+[x0] such that min(Rx0y♦ψ, V (ψ, y♦ψ)) > αi−1.
Then let Y = {y□ψ ∈R+[x0] : □ψ ∈Σ□} ∪{y♦ψ ∈R[x0] : ♦ψ ∈Σ♦}, noting
that Y is ﬁnite and |Y | ≤|Σ□∪Σ♦|.
Now we deﬁne 
M = ⟨
W , 9R, 9T, 9V ⟩with 
W = 	
y∈Y 
Wy ∪{x0} and
9Rxz =
⎧
⎪
⎨
⎪
⎩
Rx0z,
if x = x0 and z ∈R+[x0]
9Ryxz
if x, z ∈
Wy, for some y ∈Y
0
otherwise
9T(x) =
3
Vx0[Σ□∪Σ♦] ∪{0, 1}
if x = x0
9Ty(x),
if x ∈
Wy for some y ∈Y
9V (p, x) =
3
V (p, x0)
if x = x0
9Vy(p, x)
if x ∈
Wy, for some y ∈Y.

234
X. Caicedo et al.
Note that, since for all y ∈W, ⟨
Wy, 9Ry⟩⊆⟨Wy, Ry⟩⊆⟨W, R⟩, it follows that
⟨
Wy, 9Ry⟩⊆⟨
W , 9R⟩⊆⟨W, R⟩for all y ∈Y . Furthermore, because 
Wy is ﬁnite for
all y ∈Y ⊆W, 
W is ﬁnite. Therefore, it is clear that, (⋆), 9R+[x0] = Y ⊆R+[x0]
and for all y ∈Y , 9Rx0y = Rx0y and 9V (ϕ, y) = V (ϕ, y). Then, by an induction
on the length of ϕ, we further show that for all ϕ ∈Σ: 9V (ϕ, x0) = V (ϕ, x0).
The base case follows directly from the deﬁnition of 9V . For the inductive step,
let ϕ ∈Σ be of the form ϕ = □ψ (the non-modal cases follow directly, using
the induction hypothesis). We need to consider two cases. First, let Rx0y →G
V (ψ, y) = 1 for all y ∈R+[x0]. This implies that for all y ∈R+[x0]: Rx0y ≤
V (ψ, y), and by (⋆), that 9Rx0y →G 9V (ψ, y) = 1 for all y ∈9R+[x0] and thus for
all y ∈
W. Because 1 ∈9T(x0), we conclude that
9V (□ψ, x0) = max{r ∈9T(x0) : r ≤inf{ 9Rx0y →G 9V (ψ, y) : y ∈
W}} = 1.
For the second case, let V (□ψ, x0) = inf{Rx0y →G V (ψ, y) : y ∈W} = αi < 1
for some i ∈{1, . . . , m −1}, call it i0. By (⋆), it follows that for all y ∈
W,
9Rx0y →G 9V (ψ, y) = Rx0y →G V (ψ, y). Because 
W ⊆W, this implies that
inf{ 9Rx0y →G 9V (ψ, y) : y ∈
W} ≥inf{Rx0y →G V (ψ, y) : y ∈W} = αi0.
Furthermore, because of our choice of y□ψ ∈
W, we know that 9Rx0y□ψ →G
9V (ψ, y□ψ) = Rx0y□ψ →G V (ψ, y□ψ) < αi0+1. Thus αi0 ≤inf{ 9Rx0y →G
9V (ψ, y) : y ∈
W} < αi0+1 and, by the construction of 9T ( 9T(x0) = {α1, . . . , αm}),
9V (□ψ, x) = max{r ∈9T(x0) : r ≤inf{ 9Rx0y →G 9V (ψ, y) : y ∈
W}} = αi0.
The diamond-case case follows similarly to the box-case and is therefore omitted.
Note also that since ⟨
W, 9R⟩⊆⟨W, R⟩, crispness is clearly preserved. Finally, we
note that |
W| ≤|Y ||Σ|n + 1 ≤|Σ||Σ|n = |Σ|hg(M) and | 9T(x0)| ≤|Σ□∪Σ♦| + 2,
thus | 9T(x)| ≤|Σ| for all x ∈
W. This concludes the induction on the height of
the model and therefore the proof of Lemma 3.
⊓⊔
We now have all the tools required to prove Theorem 1. Suppose ﬁrst that
̸|=GFK ϕ. By Lemma 1(b), ϕ is not valid in a GFK-tree model of ﬁnite height, and
hence, by Lemma 2, ̸|=GK ϕ. Conversely, suppose that ̸|=GK ϕ. By Lemma 1(b), ϕ
is not valid in a GK-tree model M with hg(M) ≤ℓ(ϕ). But then, by Lemma 3, ϕ
is not valid in a GFK-tree model 
M = ⟨
W, 9R, 9T, 9V ⟩with (since |Σ(ϕ)| ≤ℓ(ϕ)+2)
|
W| ≤(ℓ(ϕ) + 2)ℓ(ϕ) and | 9T (x)| ≤ℓ(ϕ) + 2 for all x ∈
W. This completes the
reasoning for (a), and (b) follows in exactly the same manner, using the fact
that Lemmas 2 and 3 preserve crispness.
5
A Crisp G¨odel S5 Logic
The crisp G¨odel modal logic GS5C is characterized by validity in GKC-models
where R is an equivalence relation. In fact, it is easily seen that GS5C-validity
corresponds to validity in universal GS5C-models where all worlds are related

A Finite Model Property for G¨odel Modal Logics
235
(i.e., GKC-models M where RM = WM × WM). Such models may be written
M = ⟨W, V ⟩with simpliﬁed valuation clauses
V (□ϕ, x) = inf{V (ϕ, y) : y ∈W}
and
V (♦ϕ, x) = sup{V (ϕ, y) : y ∈W}.
GS5C can be axiomatized as an extension of the intuitionistic modal logic
MIPC [5,16] with prelinearity and □(□ϕ ∨ψ) →(□ϕ ∨□ψ) [6]. It may also
be viewed as the one-variable fragment of ﬁrst-order G¨odel logic G∀(see [11]).
Given a formula ϕ ∈Fml□♦, let ϕ∗be the ﬁrst-order formula obtained by replac-
ing each propositional variable p with the predicate P(x), □with ∀x, and ♦with
∃x. Then |=GS5C ϕ if and only if |=G∀ϕ∗. Similarly, if ϕ is a ﬁrst-order formula
with one variable, let ϕ◦be the modal formula obtained by replacing each P(x)
with p, ∀x with □, and ∃x with ♦. Then |=G∀ϕ if and only if |=GS5C ϕ◦.
We deﬁne a GFS5C-model as a GFKC-model M = ⟨W, R, T, V ⟩such that
⟨W, R, V ⟩is a GS5C-model, and also T (x) = T (y) whenever Rxy. Again, GFS5C-
validity amounts to validity in universal GFS5C-models, written M = ⟨W, T, V ⟩,
where T may now be understood as a single ﬁxed ﬁnite subset of [0, 1], and
V (□ϕ, x) = max{r ∈T : r ≤inf{V (ϕ, y) : y ∈W}}
V (♦ϕ, x) = min{r ∈T : r ≥sup{V (ϕ, y) : y ∈W}}.
Note in particular that in both GS5C-models and GFS5C-models, the truth values
of box-formulas and diamond-formulas are independent of the world.
Lemma 4. For any universal GFS5C-model M, there is a universal GS5C-model

M with WM ⊆W
M, such that V
M(ϕ, x) = VM(ϕ, x) for all ϕ ∈Fml□♦and
x ∈WM.
Proof. We proceed similarly to the proof of Lemma 2, but since there is no
accessibility relation here, an induction is not required. Given a universal GFS5C-
model M, we construct the universal GS5C-model 
M directly by taking inﬁnitely
many copies of M. Consider TM = {α1, . . . , αn} with 0 = α1 < . . . < αn = 1
and, using Lemma 1(c), deﬁne a family of order-embeddings {hk}k∈Z+ exactly
as in the proof of Lemma 2. For all k ∈Z+, we deﬁne a universal GS5C-model

Mk = ⟨
Wk, 9Vk⟩such that each 
Wk is a copy of WM with distinct worlds and
9Vk(ϕ, xk) = hk(VM(ϕ, x)) for each copy xk of x ∈WM and ϕ ∈Fml□♦. We also
let 
W0 = WM and 9V0 = VM. Then 
M = ⟨
W, 9V ⟩where

W =

k∈N

Wk
and
9V (p, x) = 9Vk(p, x) for x ∈
Wk.
It then suﬃces to prove that 9V (ϕ, x) = V (ϕ, x) for all ϕ ∈Fml□♦and x ∈W,
proceeding by an induction on ℓ(ϕ) similar to the proof of Lemma 2.
⊓⊔
Lemma 5. Let Σ ⊆Fml□♦be a ﬁnite fragment. Then, for any universal GS5C-
model M, there is a ﬁnite universal GFS5C-model 
M with W
M ⊆WM, such that
V
M(ϕ, x) = VM(ϕ, x) for all ϕ ∈Σ and x ∈W
M. Moreover, |W
M|+|T
M| ≤2|Σ|.

236
X. Caicedo et al.
Proof. Let Σ ⊆Fml□♦be a ﬁnite fragment, M = ⟨W, V ⟩a universal GS5C-
model, and ﬁx x0 ∈W. First, deﬁne Σ□, Σ♦, ΣVar, and Vx[Δ] as in Lemma 3
and let Vx0[Σ□∪Σ♦] ∪{0, 1} = {α1, . . . , αn} with 0 = α1 < . . . < αn = 1. As
in Lemma 3, we choose a ﬁnite number of y ∈W. For each □ψ ∈Σ□such that
V (□ψ, x0) = αi < 1, choose a y = y□ψ ∈W such that V (ψ, y□ψ) < αi+1, and
for each ♦ψ ∈Σ♦, such that V (♦ψ, x0) = αi > 0, choose a y = y♦ψ ∈W such
that V (ψ, y♦ψ) > αi−1. Then let 
W = {x0} ∪{y□ψ ∈W : □ψ ∈Σ□} ∪{y♦ψ ∈
W : ♦ψ ∈Σ♦}. Clearly 
W ⊆W is ﬁnite. We deﬁne 
M = ⟨
W, 9T, 9V ⟩where
9T = Vx0[Σ□∪Σ♦]∪{0, 1}, and 9V is V restricted to 
W. It then follows by induction
on ℓ(ϕ) (omitted here) as in Lemma 3 that 9V (ϕ, x) = V (ϕ, x) for all x ∈
W and
ϕ ∈Σ. Moreover, |
W| ≤|Σ□∪Σ♦| + 1 ≤|Σ| and | 9T| ≤|Σ□∪Σ♦| + 2 ≤|Σ|, and
therefore |
W| + | 9T| ≤2|Σ|.
⊓⊔
Hence, immediately by Lemmas 4 and 5:
Theorem 3. For each ϕ ∈Fml□♦: |=GS5C ϕ iﬀ|=GFS5C ϕ iﬀϕ is valid in all
universal GFS5C-models M where |WM| + |TM| ≤2(ℓ(ϕ) + 2).
Finally, to check non-deterministically if a formula ϕ ∈Fml□♦is not GS5C-
valid, it suﬃces, using Lemmas 4 and 5, to guess a universal GFS5C-model M
with |WM| = ℓ(ϕ) and values in U = {0,
1
ℓ(ϕ)2+1, . . . ,
ℓ(ϕ)2
ℓ(ϕ)2+1, 1} and then to
guess a world x ∈WM and check whether VM(ϕ, x) < 1. This means choosing
ℓ(ϕ)|Var(ϕ)| values in U for VM and also a subset of U for TM. Choosing these
values and the world x ∈WM and then computing the value of VM(ϕ, x) = 1
can be achieved in time polynomial in ℓ(ϕ)2. So validity in GS5C is in co-NP.
Since checking validity in G¨odel logic is co-NP hard (see, e.g., [11]), we obtain:
Theorem 4. Validity in GS5C and the one-variable fragment of ﬁrst-order G¨odel
logic is decidable and indeed co-NP-complete.
6
Concluding Remarks
In this paper, we have established the decidability of validity in the G¨odel modal
logics GK and GKC based, respectively, on fuzzy and crisp Kripke frames. We
have also established decidability and co-NP completeness for validity in the
one-variable fragment of ﬁrst-order G¨odel logic and, equivalently, the logic GS5C
based on crisp Kripke frames where accessibility is an equivalence relation. In
ongoing work, we aim to determine the complexity of validity in GK and GKC
(both of which we conjecture to be PSPACE complete), possibly via Gentzen-
style proof systems. We also intend to extend our approach to other logics. From
a modal perspective, we plan to consider logics with multiple modalities (in
particular, G¨odel description logics) and modalities whose accessibility relations
satisfy conditions such as reﬂexivity, symmetry, and transitivity. Moreover, in
the propositional setting, we intend to treat modal logics based on so-called
“projective logics” (see [1]) where similar methods should apply.

A Finite Model Property for G¨odel Modal Logics
237
References
1. Baaz, M., Ferm¨uller, C.G.: Analytic calculi for projective logics. In: Murray, N.V.
(ed.) TABLEAUX 1999. LNCS (LNAI), vol. 1617, pp. 36–51. Springer, Heidelberg
(1999)
2. Blackburn, P., de Rijke, M., Venema, Y.: Modal logic. Cambridge University Press,
Cambridge (2001)
3. Bobillo, F., Delgado, M., G´omez-Romero, J., Straccia, U.: Fuzzy description logics
under G¨odel semantics. International Journal of Approximate Reasoning 50(3),
494–514 (2009)
4. Bou, F., Esteva, F., Godo, L., Rodr´ıguez, R.: On the minimum many-valued logic
over a ﬁnite residuated lattice. Journal of Logic and Computation 21(5), 739–790
(2011)
5. Bull, R.A.: MIPC as formalisation of an intuitionist concept of modality. Journal
of Symbolic Logic 31, 609–616 (1966)
6. Caicedo, X., Rodr´ıguez, R.: Bi-modal G¨odel logic over [0,1]-valued Kripke frames.
To appear in Journal of Logic and Computation
7. Caicedo, X., Rodr´ıguez, R.: Standard G¨odel modal logics. Studia Logica 94(2),
189–214 (2010)
8. Fischer Servi, G.: Axiomatizations for some intuitionistic modal logics. Rend. Sem.
Mat. Polit de Torino 42, 179–194 (1984)
9. Fitting, M.C.: Many-valued modal logics. Fundamenta Informaticae 15(3-4), 235–
254 (1991)
10. Fitting, M.C.: Many-valued modal logics II. Fundamenta Informaticae 17, 55–73
(1992)
11. H´ajek, P.: Metamathematics of Fuzzy Logic. Kluwer, Dordrecht (1998)
12. H´ajek, P.: Making fuzzy description logic more general. Fuzzy Sets and Sys-
tems 154(1), 1–15 (2005)
13. Metcalfe, G., Olivetti, N.: Proof systems for a G¨odel modal logic. In: Giese,
M., Waaler, A. (eds.) TABLEAUX 2009. LNCS (LNAI), vol. 5607, pp. 265–279.
Springer, Heidelberg (2009)
14. Metcalfe, G., Olivetti, N.: Towards a proof theory of G¨odel modal logics. Log.
Methods Comput. Sci. 7(2), 1–27 (2011)
15. Priest, G.: Many-valued modal logics: a simple approach. Review of Symbolic
Logic 1, 190–203 (2008)
16. Prior, A.: Time and Modality. Clarendon Press, Oxford (1957)

Model Checking for Modal Dependence Logic:
An Approach through Post’s Lattice
Julian-Steﬀen M¨uller and Heribert Vollmer
Institut f¨ur Theoretische Informatik
Leibniz Universit¨at Hannover
Appelstr. 4, 30167 Hannover, Germany
{mueller,vollmer}@thi.uni-hannover.de
Abstract. In this paper we investigate an extended version of modal
dependence logic by allowing arbitrary Boolean connectives. Modal de-
pendence logic was recently introduced by Jouko V¨a¨an¨anen by extending
modal logic by a the dependence atom dep(·). In this paper we study the
computational complexity of the model checking problem. For a com-
plete classiﬁcation of arbitrary Boolean functions we are using a Lat-
tice approach introduced by Emil Post. This classiﬁcation is done for
all fragments of the logical language allowing modalities ♦and □, the
dependence atom, and logical symbols for arbitrary Boolean functions.
1
Introduction
Many algorithmic problems for propositional logic and its extensions are presum-
ably computationally intractable, the most prominent of course the simple satis-
ﬁability problem SAT known to be NP-complete. For propositional modal logic,
satisﬁability is even PSPACE-complete [7]. Much eﬀort has therefore been spent
on identifying fragments of the logical language that admit eﬃcient algorithms
for satisﬁability, see [8] for propositional logic and [6] for modal logic. These
studies ﬁrst extend propositional (modal) logic by allowing arbitrary Boolean
connectives (i.e., logical symbols for arbitrary Boolean functions) in the formu-
las, and then classify the computational complexity of satisﬁability for each ﬁnite
subset B of allowed Boolean functions/connectives. An important tool in these
complexity classiﬁcations is Post’s lattice of all closed classes of Boolean func-
tions, also known as Boolean clones, since it can be shown that the complexity
of satisﬁability for a logic with connectives from B depends only on the clone
[B] generated by B.
In this paper we are interested in modal dependence logic (MDL). This logic
extends (propositional) modal logic by dependence atoms, i.e., atomic formulas
that describe functional dependencies between variables. This logic was intro-
duced recently by V¨a¨an¨anen [13] and examined from a complexity theoretic point
of view in [11,4,9]. While the model checking problem for propositional modal
logic is known to be eﬃciently solvable (i.e., in polynomial time) [5], it gets
PSPACE-complete for modal dependence logic. The above sketched approach
to identify eﬃciently solvable fragments making use of the structure of Post’s
L. Libkin, U. Kohlenbach, and R. de Queiroz (Eds.): WoLLIC 2013, LNCS 8071, pp. 238–250, 2013.
c
⃝Springer-Verlag Berlin Heidelberg 2013

Model Checking for Modal Dependence Logic
239
lattice does not work here, because the semantics of the Boolean connectives
is not immediate in dependence logic. For example, ⊗(here called splitjunc-
tion) and →(intuitionistic implication) are deﬁned in somewhat non-classical
ways making use of so called team-semantics, see [13,11]. Ebbing and Lohmann
[4] examined the complexity of a few fragments, but the fragments were given
by somewhat arbitrary bases; their results determine the complexity of model
checking in some important special cases, but the full picture is still missing.
In the present paper we introduce a novel approach to the study of fragments
of dependence logic: We do not aim at a classiﬁcation of all fragments deﬁned by
arbitrary dependence connectives like splitjunction or intuitionistic implication.
Instead we make a distinction between dependence connectives on the one side
and classical Boolean connectives on the other side. In other words, we introduce
connectives given by Boolean function into dependence logic and deﬁne their
semantics in the classical way. Then it can be observed that for this latter class
of connectives an approach via Post’s lattice is possible, and this is what we
exploit in this paper. We achieve a classiﬁcation of the model checking problem
for modal dependence logic for all fragments of the language making use of
dependence atoms, one or both modalities, and arbitrary Boolean connectives.
As we will explain, the complexity will depend not on the particular choice
of Boolean functions that we allow in our formulas, but on the clones in Post’s
lattice that is deﬁned by the set of Boolean functions. In this way, the mentioned
results from [4] will allow us more generally to determine the complexity of model
checking for all monotone clones. We then extend these observations to all the
remaining clones by considering also the connectives of logical negation and
exclusive-or.
For the results presented here, we do not consider dependence connectives
(splitjunction, intuitionistic implication, etc.), but we come back to this question
in the conclusion.
After introducing the reader to dependence logic and our extension via arbi-
trary classical Boolean connectives we shortly recall basic results about Post’s
lattice in Sect. 2. Then, in Sect. 3 we prove our classiﬁcation results. We will
see that when restricting the language to the modality □, model checking be-
comes a very eﬃciently solvable task, independently of what else we allow in
our language. Introducing the modality ♦, however, makes model checking hard.
We obtain fragments that are NP-complete, some are complete for PNP[1]. The
technically most interesting theorem of our paper shows that as soon as the con-
nective exclusive-or is present or can be simulated, model checking reaches its
maximal complexity and becomes PSPACE-complete.
2
The Modal Language and Its Fragments
We ﬁrst deﬁne syntax and semantics of modal dependence logic.
Deﬁnition 1. Let B be a set of Boolean functions. Then we deﬁne the set of
MDLB-formulae (B-formulae for
short) as follows: Every variable p is
a B-formula. If p1, . . . , pn, q are variables, then dep(p1, . . . , pn, q) is a B-formula.

240
J.-S. M¨uller and H. Vollmer
If f is an n-ary function in B and φ1, . . . , φn are B-formulae, then f(φ1, . . . , φn)
is a B-formula. If φ is a B-formula, then ♦φ and □φ are B-formulae.
For U ⊆{□, ♦, dep(·)} we say that a B-formula is a (B, U)-formula, if it uses
only logical symbols from B ∪U.
We remark that, as usual, we do not distinguish in our notation between a
Boolean function f and a logical symbol for f.
The dependence atom dep(p1, . . . , pn, q) is meant to express that the value
of q functionally depends on those of p1, . . . , pn. Unlike in usual modal logic, it
does not make sense to evaluate such a formula in a single state but in a set
of states (in this context called team), and this is diﬀerent from evaluating the
formula in each state separately.
As usual, in a Kripke structure M = (W, R, π) the set of all successors of
T ⊆W is deﬁned as R(T ) = {s ∈W | ∃s′ ∈T : (s′, s) ∈R}. Furthermore we
deﬁne R⟨T ⟩= {T ′ ⊆R(T ) | ∀s ∈T ∃s′ ∈T ′ : (s, s′) ∈R}.
Deﬁnition 2. Let M be a Kripke structure, T be a team over M and φ be a
B-formula. The semantic evaluation (denoted as M , T |= φ) is deﬁned by the
induction below. We also deﬁne the function ⟨·⟩M
T
which maps a formula to a
truth value, where ⟨φ⟩M
T
is true if and only if M , T |= φ.
M , ∅|= φ
true
M , T |= p
if
for all w ∈T : p ∈π(w)
M , T |= p
if
for all w ∈T : p ̸∈π(w)
M , T |= dep(p1, . . . , pn, q) if
for all w, w′ ∈T :
π(w) ∩{p1, . . . , pn} = π(w′) ∩{p1, . . . , pn}
implies q ∈π(w) ⇔q ∈π(w′)
M , T |= f(φ1, . . . , φn)
if
f(⟨φ1⟩M
T , . . . , ⟨φn⟩M
T ) = 1
M , T |= ♦φ
if
there is a T ′ ∈R⟨T ⟩such that ⟨φ⟩M
T ′
M , T |= □φ
if
⟨φ⟩M
R(T )
These modalities, as deﬁned by V¨a¨an¨anen, do not fulﬁll the usual dualities; as
a technical tool for our upcoming results we therefore deﬁne a further modality
by □· φ ≡¬♦¬φ. Also, note that □φ ≡¬□¬φ holds and that the empty team
satisﬁes all formulae, including ¬φ.
We collect some important observations, all of which follows quite immediately
from the deﬁnitions.
Lemma 1. Let φ, φ′ be MDL formulae. Then the following axioms are satisﬁed
on all Kripke models M .
1. □(φ ∧φ′) →□φ ∧□φ′.
2. □(φ ∨φ′) →□φ ∨□φ′.
3. □(¬φ) →¬□φ.
4. Let f n be a n-ary Boolean formula over the basis B. Then □f(φ1, . . . , φn) →
f(□φ1, . . . , □, φn) holds.

Model Checking for Modal Dependence Logic
241
Proof. Let φ, φ′ be MDL formulae, M be a Kripke model and T be a team over
M . Let ⊙∈{∨, ∧}. Then the axioms 1 and 2 will follow by simple equivalencies
from the deﬁnition as follows:
M , T |= □(φ ⊙φ′) ⇔M , R(T ) |= (φ ⊙φ′)
⇔M , R(T ) |= φ and/or M , R(T ) |= φ′
⇔M , T |= □φ ⊙□φ′
.
The axiom 3 is stating a self duality property of □and can be proven by the
following equivilance.
M , T |= □¬φ ⇔M , R(T ) |= ¬φ ⇔M , R(T ) ̸|= φ
⇔M , T ̸|= □φ ⇔M , T |= ¬□φ
Axiom 4 directly follows from the axioms 1-3, because each Boolean function f
can be eﬃciently transformed into a logically equivalent function f ′ over the
basis {∧, ∨, ¬}. By applying the axioms 1-3 iteratively on f ′ we obtain the
axiom 4.
⊓⊔
The algorithmic problem family whose computational complexity we want to
determine in this paper is deﬁned as follows. Here, B denotes a ﬁnite set of
Boolean functions, and U ⊆{□, ♦, dep(·)}.
Problem: MDL-MC(B, U)
Description: Model checking problem for (B, U)-formulae.
Input: (B, U)-formula φ, Kripke model M and team T .
Question: Is φ satisﬁed in M on T ?
ID
∅
E
{∧}
V
{∨}
M
{∧, ∨}
N
{¬}
L
{⊕}
BF
{∧, ¬}
Fig. 1. Post’s Lattice for Boolean clones with both constants and their “standard”
basises

242
J.-S. M¨uller and H. Vollmer
Post’s Lattice
Emil Post [10] classiﬁed the lattice of all closed sets of Boolean functions—called
clones—and found a ﬁnite base for each clone. For an arbitrary ﬁnite set B of
Boolean functions we deﬁne [B] to be the clone generated by B, i.e., the class of
all Boolean functions that contains B, all projections (identities), and is closed
under composition. A list of all clones as well as the full inclusion graph can be
found, for example, in [2]. Whereas in general there is an inﬁnite set of clones, for
model checking luckily there are only seven diﬀerent clones [1]. This is essentially
due to the fact that the constants for false and true do not need to be part of the
language but can be expressed by atoms that are either nowhere or everywhere
satisﬁed in the model. In other words, MDL-MC(B) ≡MDL-MC(B ∪{0, 1}) (≡
denotes a suitable reduction, e.g., polynomial-time, logspace, or even constant-
depth).
But there are only seven clones that contain the constants, see Fig. 1. This
means (and is proved formally in [12]) that if one wishes to study the compu-
tational complexity of model checking for propositional formulas with logical
connectives restricted to some set B of Boolean functions, it is not necessary to
consider all inﬁnite possibilities for such sets B but actually suﬃces to consider
these seven clones, depicted in Fig. 1, where we describe the clones by their
standard bases (we use ⊕to denote the exclusive or).
As an example, notice that even though {∧, ⊕} is not a base for all Boolean
functions, it suﬃces to express all Boolean functions w.r.t. model checking prob-
lems because of the “free” existence of the constants; e.g., ¬x = x ⊕1 and
x ∨y = ((x ⊕1) ∧(y ⊕1)) ⊕1.
To summarize, given any ﬁnite set B of Boolean functions/propositional con-
nectives, the computational complexity of model checking for formulas over B
is equivalent to the complexity of model checking for one of the bases given in
Fig. 1.
Hence, in all upcoming results, if we classify the computational complexity of
a model checking problem for the bases in Fig. 1, we have in fact achieved a full
complexity classiﬁcation for all ﬁnite sets B of Boolean connectives.
3
Complexity Results
We ﬁrst study fragments of the modal language with □as only modality. The
following theorem completely clariﬁes the complexity of all arising fragments.
Theorem 1. For all ﬁnite sets B, MDL-MC(B, {□, dep(·)}) is NL-complete.
Proof. To prove hardness, we give a reduction from the standard NL-complete
graph reachability problem. Let ⟨G = (V, E), s, t⟩be a instance of REACH, then
we construct a Kripke model M = (W, R, π) as follows:
(W, R) := (V, E ∪{(v, v) | v ∈V })
π−1(q) := V \ {t}

Model Checking for Modal Dependence Logic
243
Now we conclude: If there is no path in G from s to t, then t is not contained in
one of the ﬁrst |V | −1 breath depth ﬁrst search levels. By the deﬁnition of π it
holds, that all vertices in the ﬁrst |V |−1 levels are labeled with the proposition q
and therefore □(|W|−1)dep(q) holds on M at the starting team {s}. The converse
direction is proved similarly.
The membership result uses a well known fact by Buss [3], that propositional
formulae can be evaluated in NL. Because of Lemma 1 we know that modalities
can only occur as a sequence at the leafs of the formula tree followed by an
atomic formula. Every time the Buss algorithm needs to evaluate such a modal
leaf we evaluate that leaf in NL with Algorithm 1 and the Buss algorithm can
proceed with the corresponding Boolean value. This procedure is shown in the
algorithm, where φleaf is such a modal leaf and Depthmodal(φleaf) gives the length
of the modal sequence.
Input
: MDLBF formula φ, Kripke model M = (W, R, π), team T ⊆W and
leaf φleaf
Output: Is φleaf satisﬁed in M on T ?
universally guess w1 ∈W with d(t, w1) = Depthmodal(φleaf) for t ∈T
universally guess w2 ∈W with d(t, w2) = Depthmodal(φleaf) for t ∈T
if φleaf = dep(p1, . . . , pn) then
labellingAgrees ←true
for i ←0 to n −1 do
if
not (pi ∈π(w1) ⇔pi ∈π(w2)) then
labellingAgrees ←False
end
end
if labellingAgrees then
if not (pn ∈π(w1) ⇔pn ∈π(w2)) then
reject
end
end
else if φleaf = p then
if p ̸∈π(w1) then
reject
end
else if φleaf = p then
if p ∈π(w1) then
reject
end
end
accept
Algorithm 1. co-NL leaf checking algorithm MDL-MC(BF, {□})
⊓⊔
In the rest of the section we study the modal language with modality ♦.
However, we will see that all obtained classiﬁcations hold as well for the modal
language with both modalities ♦and □. The results we will obtain are summa-
rized in Fig. 2.

244
J.-S. M¨uller and H. Vollmer
ID
E
V
M
N
L
BF
NP
PNP[1]
PSPACE
Fig. 2. Complexity of MDL-MC({♦, dep(·)}) and MDL-MC({♦, □, dep(·)})
In order to prove the upper bound for the negation clone N, we have to prove
a property called downwards closure for the universal modal operator.
We say that a logic has the downwards closure property if for all Kripke models
M , all teams T over M and all formulae φ, if φ is satisﬁed in M on T, then it
is satisﬁed on any subset T ′ of T . We also say that in this case, φ is downards
closed.
Lemma 2. Let φ be a downwards closed MDL formula. Then the formula □· φ
is logically equivalent to □φ.
Proof. Let φ be a downwards closed MDL formula, M be a Kripke model, T be
team over M and □· φ be satisﬁed in M on T . By deﬁnition φ has to be satisﬁed
on all successor teams in R⟨T ⟩, especially on R(T ). Clearly all teams T ′ in R⟨T ⟩
are subsets of the team of all successors R(T ). Because of this and the fact that
φ is downwards closed, it is suﬃcient to check if φ evaluates to true on R(T ).
⊓⊔
Theorem 2. Let [B] = N, then MDL-MC(B, {♦, dep(·)}) is PNP[1]-complete.
Proof. Let φ be a (B, {♦, dep(·)})-formula and k1, . . . , kn ∈N. Then φ is always
either of the form φ := ¬φ′ or φ := φ′, where
φ′ := ♦k1□· k2 . . . □· knλ,
λ is a literal or a dependence atom.
Let ˆφ be any sub formula of φ′. Then it follows from Lemma 2, that □· ˆφ can be
replaced by □ˆφ. Hence we can rewrite φ′ as
φ′ := ♦k1□k2 . . . □knλ,
λ is a literal or a dependence atom.
Thus, model checking for φ can be reduced clearly to model checking for φ′. Since
Ebbing and Lohmann showed in [4] that MDL model checking for the operator
fragment {♦, □, dep(·), ·} is NP-complete, we conclude MDL-MC(N, {♦, dep(·)})
is in PNP[1].

Model Checking for Modal Dependence Logic
245
It remains to show that MDL-MC({N, ♦, dep(·)}) is PNP[1]-hard. Let A ∈
PNP[1], and let the corresponding Turing-Machine be MA. We have to show that
A ≤p
m MDL-MC(N, {♦, dep(·)}).
In the polynomial many-one reduction, we can simulate the polynomial part
of the machine. Therefore the only thing that is left, is the oracle question and
four possible acceptance behaviours of MA as shown in Figure 3.
input x
f ∈SAT
acc
rej
1
0
(a) f ∈SAT
input x
f ∈SAT
acc
rej
1
0
(b) f ∈SAT
input x
f ∈SAT
acc
acc
1
0
(c) Accept always
input x
f ∈SAT
rej
rej
1
0
(d) Reject always
Fig. 3. Acceptance cases in PNP[1]
SAT is represented in MDL-MC(N, {♦, dep(·)}) in the same way it is repre-
sented by Ebbing and Lohmann in [4], but we have to adjust our formula to
represent the four possible acceptance cases.
Let ψ := 
i Ci be the SAT oracle question and g(ψ) = ⟨M , T, φ⟩the reduction
function.
The Kripke structure M = (W, R, π) is deﬁned as follows:
W := {c1, . . . , cn, s1, . . . , sm, s1, . . . , sm},
R ⊇
3
{(ci, sj)}
, if xj occurs in Ci
{(ci, sj)}
, if xj occurs in Ci,
π(si) ⊇{pi, q},
π(si) ⊇{pi}.
The initial team is deﬁned by the worlds, which representing the clauses of ψ.
T := {c1, . . . , cn},
φ :=
⎧
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎩
♦dep(p1, . . . , pm, q)
, ψ ∈SAT
¬♦dep(p1, . . . , pm, q)
, ψ ∈SAT
t
, accept always
f
, reject always.
The correctness follows directly from the MDL-MC(N, {♦, dep(·)}) correctness
proof in [4] and the deﬁnition of ¬.
⊓⊔
Theorem 3. Let [B] ⊇L, then MDL-MC(B, {♦, dep(·)}) is PSPACE-complete.

246
J.-S. M¨uller and H. Vollmer
Proof. To prove hardness, we give a reduction from the standard PSPACE-
complete problem QBF, the validity problem for quantiﬁed Boolean formulae,
to MDL-MC({⊕}, {♦, dep(·)}).
Let φ := ∃x1∀x2 . . . ∃xn(Ci) be a QBF formula. The QBF formula will be
transformed to a MDL-MC instance ⟨M = (W, R, π), T, ψ⟩as follows. For each
quantiﬁed variable we will construct one connected component. In these con-
nected component the nesting of the variables will be simulated by value states
xi, xi and delay states di. There are also components for each clause.
W :=
n

i=1

{xi, xi} ∪{xj
i, xj
i|i ≤j ≤n} ∪{dj
i|1 ≤j ≤i}

∪{cj
i|1 ≤i ≤m, 1 ≤j ≤n + 1}
For the quantiﬁed variable xi the variables value decision will be made at point
i. At the decision point the natural ordering of delay states will branch in a
natural ordering of the diﬀerent values states.
R :=
n
i=1

{(xj
i, xj+1
i
)|1 ≤j < n −i} ∪{(xj
i, xj+1
i
)|i ≤j ≤n} ∪
{(xj
i, xi)|j = n −i}
∪{(xj
i, xi)|j = n −i} ∪
{(dj
i, dj+1
i
)|1 ≤j < i} ∪{(di
i, xi+1
i
), (di
i, xi+1
i
)}∪
{(cj
i, cj+1
i
)|1 ≤i ≤n}

∪{(ci, xi|1 ≤i ≤m, xi ∈Ci}
The starting team is the set of all initial delay nodes and the initial clause nodes.
T := {d0
i |1 ≤i ≤n} ∪{c1
i |1 ≤i ≤m}
At last we have to deﬁne the labelling of the Kripke structure. For each positive
value world xj
i , xj
i, xi, xi pi is labelled to represent the variable and to represent
the value on each positive value node q is labelled also.
π−1(pi) :={xj
i, xi, xj
i, xi|1 ≤i ≤n, i ≤j ≤n}
π−1(q) :={xj
i, xi|1 ≤i ≤n, i ≤j ≤n}
The following formula ψ will simulate the QBF evaluation on the given Kripke
model M = (W, R, π) over the team starting team T .
ψ := ♦□· . . . ♦
'
(%
&
n-times
(¬dep(p2, p4, . . . , pn−1, q) ⊕♦dep(p1, . . . , pn, q))
'
(%
&
ψ′
Let φ′ be a CNF over the variables x1, . . . , xn and φ = ∃x1∀x2 . . . ∃xnφ′ be a
satisﬁed QBF formula. Then M , T |= ψ. After n modal quantiﬁcation steps,
the formula ψ′ will be evaluated on teams T ′ over {x1, x1, . . . , xn, xn}, because
in the i’s modal step we pick one or both variable vertices in the connected

Model Checking for Modal Dependence Logic
247
d1
1
x2
2
x2
3
x3
2
x3
3
x4
1
x4
3
d1
2
d2
2
x3
2
x3
2
x4
2
x4
2
d1
3
d2
3
d3
3
x4
3
x4
3
x
x
y
y
z
z
c4
1
c3
1
c2
1
c1
1
c4
2
c3
2
c2
2
c1
2
Fig. 4. Kripke Model for QBF formula φ := ∃x∀y∃z(x ∨y ∨z) ∧(x ∨y ∨z)
component corresponding to the i’s variable. For convenience we say that a
team is consistent if is does not contain a variable positively and negatively and
not consistent if it does. In the following we want to choose satisfying teams with
respect to the QBF assignment tree and show that these teams satisfy ψ′. In the
case of existential quantiﬁcation we can choose the variable path with respect
to the QBF assignment, but for the universal quantiﬁcation we have to ensure
that the case of both variable assignments are picked, does not falsify ψ′.
Claim (1). Let T ′ be a team over {x1, x1, . . . , xn, xn}, where the universal quan-
tiﬁed variable xi is contained positively and negatively. Then M , T ′ |= ψ′ holds.
To prove the claim, let xi and xi be in T’. Then ¬dep(p2, p4, . . . , pn−1, q) is
true, because T’ does not satisfy the dependence atom. By this it follows that
♦dep(p, q) will also be false, because {p2, p4, . . . , pn−1} ⊆{p1, . . . , pn} and the
modal operator does not shrink the team T ′. This proves the claim.
With this claim in mind, we construct all consistent successor teams of the
form T ′ = 	n
i=1{tn
i } ∪	m
i=1{ck
i }, which are representing the assignments of a
QBF assignment tree. In the last claim we show that a consistent team evaluated
to true on ψ′ if and only if the corresponding variable assignments satisﬁes φ′.
Hardness now follows from the following claim.
Claim (2). Let T be of the form 	n
i=1{tn
i } ∪	m
i=1{ck
i }, where ti ∈{xn
i , xn
i } and
α(xi) =
3
1
, ti = {xn
i }
0
, otherwise. Then M , T |= ψ′ if and only if α |= φ′.
We prove the claim. Because of team T is being consistent the sub formula
¬dep(p2, p4, . . . , pn−1, q) is false. It remains to show that ♦dep(p1, . . . , pn, q) is
true if and only if α |= φ′ holds and false otherwise. Let α |= φ′. Then each
clause Cj is satisﬁed by at least one variable assignment in α. W.lo.g. let Cj be
satisﬁed by xi = 0. By deﬁnition it follows that Cj is connected with the vertex

248
J.-S. M¨uller and H. Vollmer
xi and by α(xi) = 0 that xn
i ∈T . Then by consistency of T and α it directly
follows that a consistent successor team T ′ with xi ∈R⟨T ⟩and xi ̸∈R⟨T ⟩exists.
Finally, MDL-MC(B, {♦, dep(·)}) ∈PSPACE follows from Algorithm 2 eval-
uating the formula in the obvious way.
Input
: MDLBF formula φ, Kripke model M = (W, R, π) and team T ⊆W
Output: Is φ is satisﬁed in M on T ?
if φ = f(φ1, . . . , φn)) then
return f(check (M , T, φ1), . . . , check(M , T, φn))
else if φ = p then
foreach wi ∈T do
if p ̸∈π(wi) then return false
end
return true
else if φ = p then
foreach wi ∈T do
if p ∈π(wi) then return false
end
return true
else if φ = dep(p1, . . . , pn, q) then
forall the pi in {p1, . . . , pn} do
forall the wtj in {wt1, . . . , wtm} = T do
cij = valid(M , {wtj}, pi)
end
end
for wti ∈T do
for wtj ∈T do
if ci = cj then
if valid(M , {wti}, q) ̸= valid(M , {wtj }, q) then
return false
end
end
end
end
return true
else if φ = ♦φ′ then
guess existentially T ′ ∈R⟨T ⟩
return check (M ,T ′,φ′)
else if φ = □φ′ then
return check (M , R(T ), φ′)
end
Algorithm 2. PSPACE algorithm check(M , T, φ)
⊓⊔
From results presented by Ebbing and Lohmann in [4], in which the NP-
completeness of some particular fragments for modal dependence logic model
checking was shown, it follows that if a set B of Boolean connectives forms a
base for one of the Boolean clones ID, E, V, M, it yields an NP-complete model
checking problem.

Model Checking for Modal Dependence Logic
249
Together with Theorem 2 and 3 above, we thus obtain a complete picture for
the complexity of model checking for modal dependence logic, as given in Fig. 2.
For any set B of Boolean connectives, the complexity falls in one of the cases
given there.
4
Conclusion
We obtained a complete classiﬁcation of the complexity of the model checking
problem for modal dependence logic for formulas that may contain dependence
atoms, one or two modalities, and symbols for arbitrary Boolean functions.
What we did not address here is formulas that besides the arbitrary sets
of Boolean connectives also involve dependence connectives, e.g., splitjunction,
intuitionistic implication, linear implication, etc. While partial results, at least
for the ﬁrst two mentioned connectives, are known, a full classiﬁcation is still
missing. For the case of splitjunction combined with the diamond modality it is
known that the classiﬁcation shown in Figure 2 is still valid expect for the N
case. In this case no result is known. The classiﬁcation of splitjucntion combined
with the □modality misses the cases L and N.
Even more interesting is maybe the question how to develop a general concept
of what a dependence connective is, and then study complexity issues concern-
ing formulas with arbitrary sets of dependence connectives, maybe via a similar
lattice as Post’s. First steps into the direction of a concept of such general con-
nectives have been made by Antti Kuusisto (personal communication).
References
1. Bauland, M., Mundhenk, M., Schneider, T., Schnoor, H., Schnoor, I., Vollmer,
H.: The tractability of model checking for LTL: The good, the bad, and the ugly
fragments. ACM Trans. Comput. Log. 12(2), 26 (2011)
2. B¨ohler, E., Creignou, N., Reith, S., Vollmer, H.: Playing with Boolean blocks, part
I: Post’s lattice with applications to complexity theory. SIGACT News 34(4), 38–52
(2003)
3. Buss, S.R.: The boolean formula value problem is in alogtime. In: Proceedings of
the 19th Annual ACM Symposium on Theory of Computing, pp. 123–131 (1987)
4. Ebbing, J., Lohmann, P.: Complexity of model checking for modal dependence
logic. In: Bielikov´a, M., Friedrich, G., Gottlob, G., Katzenbeisser, S., Tur´an, G.
(eds.) SOFSEM 2012. LNCS, vol. 7147, pp. 226–237. Springer, Heidelberg (2012)
5. Fischer, M.J., Ladner, R.E.: Propositional dynamic logic of regular programs. Jour-
nal of Computer and Systems Sciences 18(2), 194–211 (1979)
6. Hemaspaandra, E., Schnoor, H., Schnoor, I.: Generalized modal satisﬁability. J.
Comput. Syst. Sci. 76(7), 561–578 (2010)
7. Ladner, R.E.: The computational complexity of provability in systems of modal
propositional logic. SIAM J. Comput. 6(3), 467–480 (1977)
8. Lewis, H.R.: Satisﬁability problems for propositional calculi. Mathematical Sys-
tems Theory 13, 45–53 (1979)

250
J.-S. M¨uller and H. Vollmer
9. Lohmann, P., Vollmer, H.: Complexity results for modal dependence logic. In:
Dawar, A., Veith, H. (eds.) CSL 2010. LNCS, vol. 6247, pp. 411–425. Springer,
Heidelberg (2010)
10. Post, E.: The two-valued iterative systems of mathematical logic. Annals of Math-
ematical Studies 5, 1–122 (1941)
11. Sevenster, M.: Model-theoretic and computational properties of modal de-
pendence logic. Journal of Logic and Computation 19(6), 1157–1173 (2009),
http://logcom.oxfordjournals.org/cgi/content/abstract/exn102v1
12. Thomas, M.: On the applicability of Post’s lattice. Inf. Process. Lett. 112(10),
386–391 (2012)
13. V¨a¨an¨anen, J.: Modal dependence logic. In: Apt, K.R., van Rooij, R. (eds.) New
Perspectives on Games and Interaction, Texts in Logic and Games, vol. 4, pp.
237–254. Amsterdam University Press (2008)

Ockhamist Propositional Dynamic Logic:
A Natural Link between PDL and CTL∗
Philippe Balbiani and Emiliano Lorini
Universit´e de Toulouse, IRIT-CNRS, France
Abstract. We present a new logic called Ockhamist Propositional Dynamic Logic,
OPDL, which provides a natural link between PDL and CTL∗. We show that both
PDL and CTL∗can be polynomially embedded into OPDL in a rather simple and
direct way. More generally, the semantics on which OPDL is based provides a
unifying framework for making the dynamic logic family and the temporal logic
family converge in a single logical framework. Decidability of the satisﬁability
problem for OPDL is studied in the paper.
1
Introduction
Different logical systems are traditionally used in theoretical computer science and in
artiﬁcial intelligence for the veriﬁcation of programs and for modelling reactive sys-
tems and multi-agent systems. Among them we should mention Propositional Dynamic
Logic PDL [12], Propositional Linear Temporal Logic PLTL [20], Computation Tree
Logic CTL [11], Full Computation Tree Logic CTL∗[22] and Alternating-time Tem-
poral Logic ATL [1]. Some relationships between these different logical systems have
been studied. For instance, it is well-known that PLTL and CTL are fragments of CTL∗
and that CTL is a fragment of ATL [13]. However, at the current stage, the general
picture remains incomplete. For example, it is clear (and well-known) that the logic of
programs PDL can express properties that Full Computation Tree Logic CTL∗cannot
and vice-versa. Moreover, there are no clear relationships between PDL and logics of
strategic reasoning such as ATL. More precisely, it is not known whether there exists
natural embeddings of PDL into ATL or of ATL in PDL. Even more importantly, there
is still no logical system that can be said to be more general than the others. For in-
stance, there is no logic that embeds in a natural and simple way both PDL and CTL∗.
Indeed, although there exist some logics that embed both PDL and CTL∗, they do it
in a rather complicated and unnatural way. For example, it is well-known that PDL
and CTL∗can be embedded in modal μ-calculus. However, although the embedding of
PDL into modal μ-calculus is simple and direct, the embedding of CTL∗into modal μ-
calculus is rather complicated and doubly exponential in the length of the input formula
[7]. Another logic that links PDL with CTL∗is the extension of PDL with a repeti-
tion construct (PDL-Δ) by [26]. But again, the embedding of CTL∗into PDL-Δ too
L. Libkin, U. Kohlenbach, and R. de Queiroz (Eds.): WoLLIC 2013, LNCS 8071, pp. 251–265, 2013.
c⃝Springer-Verlag Berlin Heidelberg 2013

252
P. Balbiani and E. Lorini
is rather complicated and doubly exponential in the length of the input formula [29].1
For this reason, a challenge arises of making the previous competing logical systems
converge into a single logical system. The aim of this paper is to make a step into this
direction by proposing an Ockhamist variant of Propositional Dynamic Logic, OPDL,
that provides a natural link between PDL and CTL∗. Speciﬁcally, we show that both
PDL and CTL∗can be polynomially embedded into OPDL in a rather simple and di-
rect way. More generally, the Ockhamist semantics on which OPDL is based provides a
unifying framework for making the dynamic logic family and the temporal logic family
converge into a single logical framework. Ockhamist semantics for temporal logic have
been widely studied in the 80ies and in the 90ies [27,30,5]. The logic of agency STIT
(the logic of “seeing to it that”) by Belnap et al. [4] is based on such semantics. Accord-
ing to the Ockhamist conception of time (also called indeterminist actualist, see [30])
the truth of statements is evaluated with respect to a moment and to a particular actual
linear history passing through that moment, and the temporal operators are relativized
to the actual history of the evaluation.
The rest of the paper is organized as follows. We ﬁrst present the syntax and the
semantics of OPDL and provide a decidability result for this logic (Section 2). Then, we
discuss, in Section 3, about the relationship of OPDL with PDL and CTL∗(Section 3).
In particular, we provide polynomial reductions of PDL and CTL∗to OPDL. In Section
4 we present a variant of OPDL whose semantics is based on the notion of labeled
transition system (LTS). In Section 5 we conclude by discussing some perspectives for
future work.2
2
Ockhamist Propositional Dynamic Logic
The distinction between the ‘Ockhamist’ semantics and the ‘Peircean’ semantics for
branching-time temporal logic was proposed by Prior in his seminal work on the logic
of time [21] (see also [27]). According to the ‘Peircean’ view the truth of a temporal
formula should be evaluated with respect either to some history or all histories starting
in a given state. In the ‘Ockhamist’ semantics for branching time a notion of actual
course of events is given. In particular, according to the ‘Ockhamist’ view, the truth
of a temporal formula should be evaluated with respect to a particular actual history
starting in a given state. While the branching-time temporal logic CTL∗is compatible
with the Ockhamist conception of time, the semantics for PDL in terms of labelled
transition systems is closer to the Peircean view than to the Ockhamist view since it
does not consider a notion of actual history or actual path in a transition system. The
logic OPDL can be conceived as a variant of the logic of programs PDL based on the
1 It is worth noting that Axelsson et al. [2] have recently studied generic extensions of CTL in
which temporal operators are parameterized with different kinds of formal languages recog-
nized by different classes of automata (e.g., regular languages, visibly pushdown and context-
free languages). They compare the expressive power of these extensions of PDL to CTL, PDL
and extensions of PDL such as PDL-Δ. However, they also show that CTL∗cannot be em-
bedded in any of these extensions of CTL, as the property of fairness is expressible in CTL∗
but is not expressible is any of these logics (see [2, Theorem 4.3]).
2 An extended version of this paper containing detailed proofs is available at [3].

Ockhamist Propositional Dynamic Logic: A Natural Link between PDL and CTL∗
253
Ockhamist view of time. Speciﬁcally, OPDL is a variant of PDL in which the truth of a
formula is evaluated with respect to a given actual history. The syntax and the semantics
of this logic are presented in Sections 2.1 and 2.2.
2.1
Syntax
Assume a countable set Prop of atomic propositions (with typical members denoted
p, q, . . .) and a countable set Atm of atomic programs (or atomic actions) (with typical
members denoted a, b, . . .). Let 2Atm∗= 2Atm \{∅}. The language LOPDL(Prop, Atm)
of OPDL consists of a set Prg of programs and a set Fml of formulae. It is deﬁned as
follows:
Prg : π ::= a |≡| (π1; π2) | (π1 ∪π2) | π∗| ϕ?
Fml : ϕ ::= p | ¬ϕ | (ϕ1 ∧ϕ2) | [[π]]ϕ
where p ranges over Prop and a ranges over Atm. We adopt the standard deﬁnitions
for the remaining Boolean operations. The dual ⟨⟨π⟩⟩of the operator [[π]] is deﬁned in
the expected way: ⟨⟨π⟩⟩ϕ
def
=
¬[[π]]¬ϕ. We follow the usual rules for omission of the
parentheses. Given a formula ϕ, let FL(ϕ) denote its Fischer-Ladner closure. See [12,
Chapter 6] for details. It is a well-known fact that card(FL(ϕ)) is linear in the length
of ϕ.
Complex programs of sequential composition (π1; π2), non-deterministic choice(π1∪
π2), iteration (π∗) and test (ϕ?) are built from atomic programs in Atm, from the special
program ≡and from formulae in Fml. The special program ≡allows to move from a
history to an alternative history passing through the same moment. The behavior of this
program will become clearer in Section 2.2 when presenting the OPDL semantics.
The formula [[π]]ϕ has to be read “ϕ will be true at the end of all possible executions
of program π” whereas ⟨⟨π⟩⟩ϕ has to be read “ϕ will be true at the end of some possible
execution of program π”. As it is assumed that atomic programs in Atm are linear (i.e.,
all atomic programs in Atm occurring at a given state lead to the same successor state),
[[a]]ϕ can also be read “if the atomic program a occurs, ϕ will be true afterwards”.
Indeed, from the assumption of linearity, it follows that atomic programs in Atm are
deterministic (i.e., there is at most one possible execution of an atomic program a at a
given state). Finally, the formula [[≡]]ϕ has to be read “ϕ is true in all histories passing
through the current moment” or, more shortly, “ϕ is necessarily true in the current
moment”.
2.2
Semantics
OPDL frames are structures with two dimensions: a vertical dimension correspond-
ing to the concept of history, a horizontal dimension corresponding to the concept of
moment.
Deﬁnition 1 (OPDL frame). An OPDL frame is a tuple F = (W, Q, L, R≡) where:
– W is a nonempty set of states (or worlds),
– Q is a partial function Q : W −→W,

254
P. Balbiani and E. Lorini
– L is a mapping L : Z −→2Atm∗from state transitions to non-empty sets of atomic
programs, Z = {(w, v) | w, v ∈W and Q(w) = v} being the transition relation
induced by the successor state function Q,
– R≡⊆W × W is an equivalence relation between states in W such that for all
w, v, u ∈W:
(C1)
if Q(w) = v and (v, u) ∈R≡then there is z ∈W such that (w, z) ∈R≡
and Q(z) = u and L(z, u) = L(w, v).
For every w, v ∈W, Q(w) = v means that v is the successor state of w. If Q(w) = v
then we also say that w is a predecessor of v. If L(w, v) = {a, b}, then the actions a and
b are responsible for the transition from the state w to the state v. In other words, the
function L labels every state transition with a set of atomic actions (viz. the actions that
are responsible for the transition). The assumption that the set L(w, v) should be non-
empty means that every state transition is due to the execution of at least one atomic
action.
R≡-equivalence classes are called moments. If w and v belong to the same moment
then they are called alternatives. A maximal sequence of states according to the tran-
sition relation Z starting at a given state w is called history starting in w. If w and v
belong to the same moment, then the history starting in w and the history starting in v
are alternative histories (viz. histories starting at the same moment).
Constraint (C1) corresponds to what in Ockhamist semantics is called property of
weak diagram completion [30]. This means that if two worlds v and u are in the same
moment and world w is a predecessor of v then, there exists a world z such that (i) w
and z are in the same moment, (ii) u is the successor of z, (iii) the transition from w to
v and the transition from z to u are labeled with the same set of action names.
Figure 1 is an example of OPDL frame. The R≡-equivalences classes {w1, w2, w3,
w4}, {w5, w6}, {w7, w8}, {w9}, {w10}, {w11}, {w12}, {w13}, {w14}, {w15} and
{w16} are the moments. The sequences of states (w1, w5, w9, w13), (w2, w6, w10, w14),
(w3, w7, w11, w15) and (w4, w8, w12, w16) are the alternative histories starting at the
same moment {w1, w2, w3, w4}. Actions a and c are responsible for the transition from
the state w1 to the state w5 and, because of Constraint (C1), actions a and c are also
responsible for the transition from the state w2 to the state w6. Moreover, actions b and
c are responsible for the transition from the state w3 to the state w7 and, because of
Constraint (C1), actions b and c are also responsible for the transition from the state w4
to the state w8.
Deﬁnition 2 (Atomic transitions). Given an OPDL frame F = (W, Q, L, R≡) and
an atomic program a ∈Atm, let
Ra = {(w, v) | Q(w) = v and a ∈L(w, v)}
be the set of a-transitions in the frame F.
An OPDL model is an OPDL frame supplemented with a valuation function mapping
each state to the set of propositional atoms which are true in it, under the assumption
that two states belonging to the same moment agree on the atoms. More precisely:
Deﬁnition 3 (OPDL model). An OPDL model is a tuple M = (W, Q, L, R≡, V)
where:

Ockhamist Propositional Dynamic Logic: A Natural Link between PDL and CTL∗
255






	





















Fig. 1. An OPDL frame
– (W, Q, L, R≡) is a OPDL frame and
– V : W −→2Prop is a valuation function for atomic propositions such that for all
w, v ∈W:
(C2)
if (w, v) ∈R≡then V(w) = V(v).
The truth of a OPDL formula is evaluated with respect to a world w in an OPDL model
M.
Deﬁnition 4 (π-transitions and truth conditions). Let M = (W, Q, L, R≡, V) be
an OPDL model. Given a program π, let us deﬁne a binary relation Rπ on W with
(w, v) ∈Rπ (or wRπv) meaning that v is accessible from w by performing program
π. Let us also deﬁne a binary relation |= between worlds in M and formulae with
M, w |= ϕ meaning that formula ϕ is true at w in M. The rules inductively deﬁning
Rπ and |= are:
Rπ1;π2 = Rπ1 ◦Rπ2
Rπ1∪π2 = Rπ1 ∪Rπ2
Rπ∗
= (Rπ)∗
Rϕ?
= {(w, w) | w ∈W and M, w |= ϕ}
and
M, w |= p ⇐⇒p ∈V(w);
M, w |= ¬ϕ ⇐⇒M, w ̸|= ϕ;
M, w |= ϕ ∧ψ ⇐⇒M, w |= ϕ AND M, w |= ψ;
M, w |= [[π]]ϕ ⇐⇒∀v ∈Rπ(w) : M, v |= ϕ

256
P. Balbiani and E. Lorini
with Rπ(w) = {v ∈W | (w, v) ∈Rπ}.
An OPDL formula ϕ is said to be OPDL valid, denoted by |=OPDL ϕ, if and only if ϕ is
true in all OPDL models (i.e., for every OPDL model M and for every world w in M,
we have M, w |= ϕ). An OPDL formula ϕ is said to be OPDL satisﬁable if and only if
¬ϕ is not OPDL valid.
OPDL formulae can also be interpreted over standard Kripke structures.
Deﬁnition 5 (Kripke OPDL model). A Kripke OPDL model is a tuple M = (W, {Ra |
a ∈Atm}, R≡, V) where:
– W is a set of states (or worlds),
– R≡is an equivalence relation on W and all Ra are binary relations on W satisfy-
ing the following two constraints for all w, v, u ∈W:
(C1∗)
if (w, v) ∈RX and (w, u) ∈RX then u = v,
(C2∗)
if (w, v) ∈RX and (v, u) ∈R≡then there is z ∈W such that (w, z) ∈
R≡and for all a ∈Atm, (w, v) ∈Ra if and only if (z, u) ∈Ra,
with RX = 	
a∈Atm Ra,
– V : W −→2Prop is a valuation function for atomic propositions such that for all
w, v ∈W:
(C3∗)
if (w, v) ∈R≡then V(w) = V(v).
Constraints (C2∗) and (C3∗) are respectively the counterparts of Constraint (C1) and
Constraint (C2) in the deﬁnition of an OPDL model. Constraint (C1∗) forces the suc-
cessor relation RX to be deterministic (i.e., every state has at most one successor).
As stated by the following proposition, the notion of satisﬁability with respect to the
class of OPDL models is equivalent to the notion of satisﬁability with respect to the
class of Kripke OPDL models.
Proposition 1. Let ϕ be an OPDL formula. Then, there exists an OPDL model which
satisﬁes ϕ if and only if there exists a Kripke OPDL model which satisﬁes ϕ.
We shall say that ϕ is a global logical consequence of a ﬁnite set of global axioms
Γ = {χ1, . . . , χn}, denoted by Γ |=OPDL ϕ, if and only if for every OPDL model M,
if Γ is true in M (i.e., for every world w in M, we have M, w |= χ1 ∧. . . ∧χn) then ϕ
is true in M too (i.e., for every world w in M, we have M, w |= ϕ).
As the following proposition highlights, when the set of atomic programs Atm is
ﬁnite, the problem of logical consequence in OPDL with a ﬁnite set of global axioms
is reducible to the validity problem for OPDL formulae.
Proposition 2. Let Γ = {χ1, . . . , χn} be a ﬁnite set of OPDL formulae. If Atm is
ﬁnite, Γ |=OPDL ϕ if and only if |=OPDL [[any∗]](χ1 ∧. . . ∧χn) →ϕ with any
def
=
(	
a∈Atm ∪≡).
The model checking problem for OPDL is the following decision problem: given a ﬁ-
nite OPDL model M and an OPDL formula ϕ, is there a world in M such that M, w |=
ϕ? With ﬁnite OPDL model, we mean a OPDL model M = (W, Q, L, R≡, V) that sat-
isﬁes the following three conditions: (1) W is ﬁnite; (2) L associates to every transition
(w, v) ∈Z = {(w, v) | w, v ∈W and Q(w) = v} a non-empty ﬁnite set of atomic

Ockhamist Propositional Dynamic Logic: A Natural Link between PDL and CTL∗
257
actions in Atm; (3) V associates to every world w ∈W a ﬁnite set of atomic for-
mulas in Prop. In order to determine whether there exists a world w in M such that
M, w |= ϕ, we can use the model checking algorithm for PDL showing that the model
checking problem for PDL is PTIME-complete with respect to the size of the input
model and the input formula. It follows that the model checking problem for OPDL is
PTIME-complete too with respect to size(M) + size(ϕ).
2.3
Decidability of OPDL
Using the “mosaic method”, a technique used in algebraic logic [18] to prove the de-
cidability of equational theories, we will prove the decidability of SAT , the following
decision problem: determine whether a given OPDL formula ϕ is satisﬁable with re-
spect to the class of OPDL models.
Theorem 1. SAT is decidable.
Proof (Sketch). Let ϕ be a formula. In order to simplify the proof, we assume that at
most one atomic action, namely a, occurs in ϕ. A type for ϕ is a subset t of FL(ϕ). It
is normal iff it satisﬁes the conditions of atomicity considered in [14, Deﬁnition 2.2]. A
group for ϕ is a ﬁnite set G of normal types for ϕ. A mosaic for ϕ is a ﬁnite set M of
groups for ϕ. It is normal iff it satisﬁes the following conditions: (i) if p ∈FL(ϕ) then
for all G ∈M, for all t ∈G, if p ∈t then for all H ∈M, for all u ∈H, p ∈u; (ii) if [[≡
]]ψ ∈FL(ϕ) then for all G ∈M, for all t ∈G, if [[≡]]ψ ∈t then for all H ∈M, for all
u ∈H, ψ ∈u; (iii) if ¬[[≡]]ψ ∈FL(ϕ) then for all G ∈M, for all t ∈G, if ¬[[≡]]ψ ∈t
then there exists H ∈M, there exists u ∈H such that ¬ψ ∈u. A system for ϕ is a
ﬁnite set S of normal mosaics for ϕ. A context for S is a structure of the form (M, G, t)
where M ∈S, G ∈M and t ∈G. Obviously, there exists ﬁnitely many types, groups,
mosaics and systems for ϕ. Since the normality conditions for types and mosaics are
decidable, the set of all contexts can be computed. Let Σ = {a, ≡}∪{ψ?: ψ ∈FL(ϕ)}.
For all α ∈Σ, we deﬁne the transition relation −→S
α between contexts for S as follows:
(M, G, t) −→S
α (N, H, u) iff one of the following conditions is satisﬁed: (i) α = a and
there exists a bijection f : G →N such that (a) f(t) = u, (b) if [[a]]ψ ∈FL(ϕ)
then for all v ∈G, if [[a]]ψ ∈v then ψ ∈f(v), (c) if ¬[[a]]ψ ∈FL(ϕ) then for
all v ∈G, if ¬[[a]]ψ ∈v then ¬ψ ∈f(v); (ii) α =≡and M = N; (iii) α = ψ?,
M = N, G = H, t = u and ψ ∈u. For all programs π, we inductively deﬁne the
transition relation −→S
π between contexts for S as follows: −→S
π1;π2 = −→S
π1 ◦−→S
π2,
−→S
π1∪π2 = −→S
π1 ∪−→S
π2, −→S
π⋆= (−→S
π)⋆. Since the set of all contexts can be
computed, the transition relations −→S
π are all decidable. A system S for ϕ is said to
be saturated iff it satisﬁes the following condition: if ¬[[π]]ψ ∈FL(ϕ) then for all
contexts (M, G, t) for S, if ¬[[π]]ψ ∈t then there exists a context (N, H, u) for S such
that (M, G, t) −→S
π (N, H, u) and ¬ψ ∈u. Since the transition relations −→S
π are all
decidable, checking the saturation of a given system for ϕ is decidable. The proof of the
decidability of SAT proceeds in two steps. First, in Proposition 3, we prove that ϕ is
satisﬁable iff there exists a saturated system S for ϕ and there exists a context (M, G, t)
in S such that ϕ ∈t. Second, in Proposition 4, we prove the decidability of the decision
problem SY S deﬁned as follows: determine whether there exists a saturated system S
for a given formula ϕ and there exists a context (M, G, t) in S such that ϕ ∈t.

258
P. Balbiani and E. Lorini
Proposition 3. Let ϕ be a formula. The following conditions are equivalent: (i) ϕ is
satisﬁable; (ii) there exists a saturated system S for ϕ, there exists a context (M, G, t)
in S such that ϕ ∈t.
Proposition 4. SY S is decidable.
As a result, SAT is decidable.
⊓⊔
3
Relationships between OPDL, PDL and CTL∗
In this section we study the relationships between OPDL and PDL, and between OPDL
and CTL∗. In particular, we provide a polynomial embedding of PDL into OPDL and
a polynomial embedding of CTL∗into OPDL.
3.1
Relationships between OPDL and PDL
Propositional Dynamic Logic PDL [15] is the well-known logic of programs. Again
assume the countable set of atomic propositions Prop = {p, q, . . .} and the countable
set of atomic programs Atm = {a, b, . . .}. The language LPDL(Prop, Atm) of PDL is
deﬁned by the following grammar in Backus-Naur Form (BNF):
Prg : π ::= a | (π1; π2) | (π1 ∪π2) | π∗| ϕ?
Fml : ϕ ::= p | ¬ϕ | (ϕ1 ∧ϕ2) | [π]ϕ
where p ranges over Prop and a ranges over Atm.
PDL models are nothing but labeled transition systems, i.e., transition systems where
transitions between states are labeled with atomic programs.
Deﬁnition 6. PDL models are tuples M = (W, {Ra | a ∈Atm}, V) where:
– W is a nonempty set of possible worlds or states;
– {Ra | a ∈Atm} is a set of binary relations on W;
– V : W −→2Prop is a valuation function.
The accessibility relations for atomic programs are generalized to complex programs in
the usual way (see Deﬁnition 2).
The truth conditions of PDL formulae are standard for the Boolean constructions
plus the following one for the dynamic operators [π]:
M, w |= [π]ϕ ⇐⇒∀v ∈Rπ(w) : M, v |= ϕ
A PDL formula ϕ is said to be PDL valid if and only if ϕ is true in all PDL models.
We can embed PDL in OPDL. Consider the following polynomial translation tr1 :
LPDL(Prop, Atm) −→LOPDL(Prop, Atm) from the language of PDL to the OPDL
language.
tr1(p)
= p for all p ∈Prop
tr1(¬ϕ)
= ¬tr 1(ϕ)
tr1(ϕ1 ∧ϕ2) = tr 1(ϕ1) ∧tr 1(ϕ2)
tr1([π]ϕ)
= [[tr 2(π)]]tr 1(ϕ)

Ockhamist Propositional Dynamic Logic: A Natural Link between PDL and CTL∗
259
where
tr2(a)
= ≡; a for all a ∈Atm
tr2(π1; π2)
= tr 2(π1); tr 2(π2)
tr2(π1 ∪π2) = tr 2(π1) ∪tr 2(π2)
tr2(π∗)
= (tr 2(π))∗
tr 2(ϕ?)
= tr 1(ϕ)?
As the following theorem shows, the preceding translation is a correct embedding.
Theorem 2. Let ϕ be a PDL formula. ϕ is PDL valid if and only if tr 1(ϕ) is OPDL
valid.
3.2
Relationships between OPDL and CTL∗
Full Computation Tree Logic CTL∗was ﬁrst described in [10,9] as an extension of
Computation Tree Logic CTL [6] and Propositional Linear Temporal Logic PLTL [20].
The language of CTL∗is built recursively from the atomic propositions using the tem-
poral operators of PLTL, and the existential path switching operator of CTL as well as
classical connectives.
Again assume the countable set of atomic propositions Prop = {p, q, . . .}. The
language LCTL∗(Prop) of CTL∗is deﬁned by the following grammar in Backus-Naur
Form (BNF):
ϕ ::= p | ¬ϕ | (ϕ1 ∧ϕ2) | Xϕ | ϕ U ψ | Aϕ
where p ranges over Prop. The constructs X and U are respectively the operators next
and until of PLTL, the formulas Xϕ and ϕ U ψ being respectively read “ϕ will be true
in the next state along the current path” and “ψ will be true at some point in the future
along the current path and ϕ has to hold until ψ”. These two operators can be used to
express other kinds of temporal notions such as eventually Fψ
def
= ⊤U ψ, henceforth
Gψ
def
= ¬F¬ψ and before ϕ B ψ
def
= ¬(¬ϕ U ψ). The construct A is a modal operator
quantifying over possible paths, the formula Aϕ being read “ϕ is true in all possible
paths”. The existential path-quantiﬁer operator E, is deﬁned by Eϕ
def
= ¬A¬ϕ.
Different semantics for CTL∗have been given in the literature. One of this semantics
is based on the notion of Ockhamist structure. Here we mainly follow the presentation
of the Ockhamist semantics for CTL∗given by Reynolds [22] who introduces a special
kind of Ockhamist structures called (N × W) structures.
Deﬁnition 7. A (N × W) structure is a tuple (W, ∼, g) where:
– W is a set of points;
– ∼is an equivalence relation over N × W such that for all w, v ∈W and for all
n, m ∈N:
(S1)
if (n, w) ∼(m, v) then n = m,
(S2)
if (n, w) ∼(n, v) and m < n then (m, w) ∼(m, v),
(S3)
(0, w) ∼(0, v);

260
P. Balbiani and E. Lorini
– g : N × W −→2Prop is a valuation function mapping each integer and each point
into a set of atoms such that for all w, v ∈W and for all n ∈N:
(S4)
if (n, w) ∼(n, v) then g(n, w) = g(n, v).
Given a (N × W) structure (W, ∼, g) and a CTL∗formula ϕ, (W, ∼, g), (n, w) |= ϕ
means that ϕ is true at the index (n, w) in the (N × W) structure (W, ∼, g). The rules
deﬁning the truth conditions of CTL∗formulae are inductively deﬁned as follows:
(W, ∼, g), (n, w) |= p ⇐⇒p ∈g(n, w);
(W, ∼, g), (n, w) |= ¬ϕ ⇐⇒(W, ∼, g), (n, w) ̸|= ϕ;
(W, ∼, g), (n, w) |= ϕ1 ∧ϕ2 ⇐⇒(W, ∼, g), (n, w) |= ϕ1 AND (W, ∼, g), (n, w) |= ϕ2;
(W, ∼, g), (n, w) |= Xϕ ⇐⇒(W, ∼, g), (n + 1, w) |= ϕ
(W, ∼, g), (n, w) |= ϕ U ψ ⇐⇒∃m ∈N : m ≥n AND (W, ∼, g), (m, w) |= ψ AND
∀k ∈N : IF n ≤k < m THEN (W, ∼, g), (k, w) |= ϕ
(W, ∼, g), (n, w) |= Aϕ ⇐⇒∀v ∈W : IF (n, w) ∼(n, v) THEN (W, ∼, g), (n, v) |= ϕ
As shown by Reynolds [22] the CTL∗semantics in terms of (N × W) structures is
equivalent to the CTL∗semantics in terms of bundled trees. However, it is more general
than the common CTL∗semantics in terms of R-generable models used by [9], i.e.,
Kripke structures with states, a total accessibility relation R between them and the set
of all paths which arise by moving from state to state along the accessibility relation.
The difference between the CTL∗semantics in terms of bundled trees and the CTL∗
semantics in terms of R-generable models is that the latter quantiﬁes over all paths in-
duced by the relation R whereas the former quantiﬁes over a bundle of paths. Although
this bundle is sufﬁx and fusion closed, it does not need to be be limit closed. For exam-
ple, it may be the case that all paths include a right branch even though at every world
there is a path where the next branch goes left, which violates the limit closure property.
In order to distinguish full computation tree logic interpreted over R-generable models
and full computation tree logic interpreted over bundled trees (and equivalently over
(N × W) structures), some authors (see, e.g., [23,16,17]) use the term CTL∗to indicate
the former logic and the term BCTL∗(bundled CTL∗) to indicate the latter (in [25] it is
called ∀LTFC ).
It is well-known that CTL∗interpreted over R-generable models is 2-EXPTIME
complete: [10] provides a doubly exponential automaton based satisﬁability checker,
and [28] gives a lowerbound. As pointed by [17], an argument for the 2-EXPTIME
hardness of the satisﬁability problem could also be made for CTL∗interpreted over
bundled trees in a way similar to the argument for CTL∗interpreted over R-generable
models. Therefore, as the CTL∗semantics in terms of bundled trees is equivalent to the
CTL∗semantics in terms of (N × W) structures [22], it follows that the satisﬁability
problem for CTL∗interpreted over (N×W) structures is also 2-EXPTIME hard. There-
fore, CTL∗interpreted over bundled trees (or over (N × W) structures) is not easier to
deal with than CTL∗interpreted over R-generable models. However, one interesting
aspect of the former kind of CTL∗is that it is closely connected to Ockhamist temporal
logics studied in the ﬁeld of philosophical logic [30]. Moreover, one might argue that
reasoning in BCTL∗is relatively easier than reasoning in CTL∗. For example the speci-
ﬁcation for the tableau method for BCTL∗proposed by [23] was much simpler than the
CTL∗tableau that originated from it [24].

Ockhamist Propositional Dynamic Logic: A Natural Link between PDL and CTL∗
261
Consider the following translation tr 3 : LCTL∗(Prop) −→LOPDL(Prop, Atm) from
the language of CTL∗to the OPDL language where x is an arbitrary atomic program
in Atm:
tr 3(p)
= p for all p ∈Prop
tr 3(¬ϕ)
= ¬tr 3(ϕ)
tr 3(ϕ1 ∧ϕ2) = tr3(ϕ1) ∧tr3(ϕ2)
tr 3(Xϕ)
= ⟨⟨x⟩⟩tr 3(ϕ)
tr 3(ϕ U ψ)
= ⟨⟨(tr 3(ϕ)?; x)∗⟩⟩tr 3(ψ)
tr 3(Aϕ)
= [[≡]]tr3(ϕ)
The preceding translation is polynomial and, as the following theorem shows, it pro-
vides an embedding of the variant of CTL∗interpreted over (N × W) structures into
OPDL.
Theorem 3. Let ϕ be a CTL∗formula. ϕ is valid with respect to the class of (N × W)
structures if and only if {⟨⟨x⟩⟩⊤} |=OPDL tr 3(ϕ).
From Theorem 3 and Proposition 2 in Section 2.2, it follows that the satisﬁability prob-
lem in the variant of CTL∗interpreted over (N × W) structures can be reduced to the
satisﬁability problem in OPDL with a ﬁnite number of atomic programs.
Corollary 1. Let ϕ be a CTL∗formula and let Atm be ﬁnite. ϕ is valid with respect to
the class of (N × W) structures if and only if |=OPDL [[any∗]]⟨⟨x⟩⟩⊤→tr3(ϕ).
Since the satisﬁability problem of (N×W) structures is 2-EXPTIME-hard (see above),
the preceding polynomial embedding of CTL∗into OPDL provides an argument for the
2-EXPTIME-hardness of the satisﬁability problem of our logic OPDL.
3.3
Relationships with Other Logics: Discussion
The logic OPDL has interesting connections with other logical systems proposed in
the ﬁeld of theoretical computer science such as propositional linear time temporal
logic PLTL and Nishimura’s combination of PDL and PLTL (call it, NL) [19]. As for
PLTL, in the previous Section 3.2 we have provided a polynomial embedding of CTL∗
into OPDL. As PLTL is nothing but the fragment of CTL∗without the path quantiﬁer
operator A, the translation tr3 also provides a polynomial embedding of PLTL into
OPDL. As for NL, we just need to put together the translation tr 1 from PDL to OPDL
given in Section 3.1 and the translation from PLTL to OPDL in order to provide a
polynomial reduction of Nishimura’s logic NL to OPDL. Another logic that is related
with OPDL is ACTL∗, the action based version of CTL∗proposed by [8]. ACTL∗
extends CTL∗with temporal operators Xa indexed by atomic programs a in the set of
atomic programs Atm. The ACTL∗formula Xaϕ has to be read “the next transition
is labeled with the atomic program a and ϕ will be true in the next state along the
current path”. By adding the following item to the preceding translation tr 3 from CTL∗
to OPDL, we get a polynomial embedding of ACTL∗into OPDL:
tr3(Xaϕ) = ⟨⟨a⟩⟩tr 3(ϕ) for all a ∈Atm

262
P. Balbiani and E. Lorini
4
A Variant of OPDL Interpreted over Labeled Transition
Systems
As we have shown in Section 3.2, the logic OPDL interpreted over OPDL models
(Deﬁnition 3) embeds the variant of CTL∗interpreted over (N × W) structures which
in turn is equivalent to the variant of CTL∗interpreted over bundled trees.
A second variant of CTL∗, ﬁrst introduced by [9], is the one interpreted over R-
generable models of the form M = (W, R, V) where W is a set of states, R ⊆W ×W
is a total binary relation on W (i.e., for every w ∈W, there is some v ∈W such that
(w, v) ∈R) and V : W −→2Prop is a valuation function for atomic propositions.3
Given a model M = (W, R, V), a fullpath in M is deﬁned to be an inﬁnite sequence
(w1, w2, w3, . . .) of states of M such that for each i ≥1, (wi, wi+1) ∈R. Given
a fullpath σ = (w1, w2, w3, . . .) and an integer i ≥1, the symbol σ≥i denotes the
fullpath (wi, wi+1, . . .). As usual, σ[1] denotes the ﬁrst element of the sequence σ.
Truth of a CTL∗formula is evaluated with respect to a R-generable model M and a
fullpath σ in M. Speciﬁcally, the rules deﬁning the truth conditions of CTL∗formulae
are inductively deﬁned as follows:
M, σ |= p ⇐⇒p ∈V(σ[1]);
M, σ |= ¬ϕ ⇐⇒M, σ ̸|= ϕ;
M, σ |= ϕ1 ∧ϕ2 ⇐⇒M, σ |= ϕ1 AND M, σ |= ϕ2;
M, σ |= Xϕ ⇐⇒M, σ≥2 |= ϕ
M, σ |= ϕ U ψ ⇐⇒∃i ≥1 : M, σ≥i |= ψ AND ∀j : IF 1 ≤j < i THEN M, σ≥j |= ϕ
M, σ |= Aϕ ⇐⇒∀σ′ : IF σ[1] = σ′[1] THEN M, σ′ |= ϕ
Here we consider a variant of OPDL which embeds the preceding variant of CTL∗
interpreted over R-generable models. We call OPDLlts this variant of OPDL, where
OPDLlts means ‘OPDL interpreted over labeled transition systems’. The semantics for
OPDLlts is given in terms of PDL models as deﬁned in Section 3.1 (Deﬁnition 6),
which are nothing but labeled transition systems, i.e., transition systems where tran-
sitions between states are labeled with atomic programs. Given a PDL model M =
(W, {Ra | a ∈Atm}, V), let the successor state function succ be deﬁned by succ(w) =
	
a∈Atm{v ∈W | (w, v) ∈Ra} for each w ∈W. succ(w) identiﬁes the successors of
world w in M. Moreover, for every w ∈W, let
PA ={(w1, . . . , wn) | w1, . . . , wn ∈W and wi+1 = succ(wi) for all 1 ≤i < n}
be the set of all paths in M. For every w ∈W, let MPAw be the set of all maximal
paths starting in w, also called histories starting in w. That is, σ ∈MPAw if and only if
σ ∈PA and σ[1] = w and there is no σ′ ∈PA such that σ′[1] = w and σ ⊏σ′ (i.e., σ is
a proper initial subsequence of σ′). Finally, let IN = {w/σ | w ∈W and σ ∈MPAw}
be the set of all indexes in the model M.
3 It has been proved that the variant of CTL∗interpreted over (N×W ) structures is more general
than the variant of CTL∗interpreted R-generable models, in the sense that the former have
less validities than the latter. For instance, as shown by [22], the formula AG(p →EXp) →
(p →EGp) is valid in the latter variant of CTL∗but is not valid in the former.

Ockhamist Propositional Dynamic Logic: A Natural Link between PDL and CTL∗
263
Truth of an OPDL formula is evaluated at a given index w/σ ∈IN of a PDL model
M. The rules inductively deﬁning the truth conditions of OPDL formulae are:
M, w/σ |= p ⇐⇒p ∈V(w);
M, w/σ |= ¬ϕ ⇐⇒M, w/σ ̸|= ϕ;
M, w/σ |= ϕ ∧ψ ⇐⇒M, w/σ |= ϕ AND M, w/σ |= ψ;
M, w/σ |= [[π]]ϕ ⇐⇒∀v/σ′ ∈ρπ(w/σ) : M, v/σ′ |= ϕ
where
ρa
= {(w/σ, v/σ′) | w/σ, v/σ′ ∈IN , (w, v) ∈Ra and σ = (w, σ′)}
ρ≡
= {(w/σ, v/σ′) | w/σ, v/σ′ ∈IN and w = v}
ρπ1;π2 = ρπ1 ◦ρπ2
ρπ1∪π2 = ρπ1 ∪ρπ2
ρπ∗
= (ρπ)∗
ρϕ?
= {(w/σ, w/σ) | w/σ ∈IN and M, w/σ |= ϕ}
and ρπ(w/σ) = {v/σ′ | (w/σ, v/σ′) ∈ρπ}.
A formula ϕ of the language LOPDL(Prop, Atm) is said to be OPDLlts valid, de-
noted by |=OPDLlts ϕ, if and only if ϕ is true in all PDL models. As usual, a formula ϕ
of the language LOPDL(Prop, Atm) is said to be OPDLlts satisﬁable if and only if ¬ϕ
is not OPDLlts valid. We shall say that a formula ϕ of the language LOPDL(Prop, Atm)
is a global logical consequence in OPDLlts of a ﬁnite set of global axioms Γ =
{χ1, . . . , χn}, denoted by Γ |=OPDLlts ϕ, if and only if for every PDL model M, if
Γ is true in M then ϕ is true in M too.
As the following theorem shows, the translation given in Section 3.2 provides an
embedding of the variant of CTL∗interpreted over R-generable models into OPDLlts.
Theorem 4. Let ϕ be a CTL∗formula. ϕ is valid with respect to the class of R-
generable models if and only if {⟨⟨x⟩⟩⊤} |=OPDLlts tr 3(ϕ).
From Theorem 4 and the fact that, as in OPDL, the problem of global logical conse-
quence in OPDLlts with a ﬁnite number of global axioms is reducible to the problem
of OPDLlts validity, it follows that the satisﬁability problem in the variant of CTL∗
interpreted over R-generable models can be reduced to the satisﬁability problem in
OPDLlts with a ﬁnite number of atomic programs.
Corollary 2. Let ϕ be a CTL∗formula and let Atm be ﬁnite. ϕ is valid with respect to
the class of R-generable models if and only if |=OPDLlts [[any∗]]⟨⟨x⟩⟩⊤→tr3(ϕ).
5
Perspectives
We have presented a new logic called Ockhamist Propositional Dynamic Logic OPDL
and studied its relationship with PDL and CTL∗. An interesting issue for future research
is the study of the relationship between OPDL and PDL with intersections of programs.
Intersections of atomic programs can be simulated in OPDL as follows:
[[a ∩b]]ϕ
def
= [[≡]](⟨⟨a⟩⟩⊤→[[b]]ϕ)

264
P. Balbiani and E. Lorini
However, it is not clear whether we can ﬁnd a simple translation from PDL with inter-
section of (not necessarily atomic) programs to OPDL that preserves validity.
Another direction of future research is the study of the exact complexity of the sat-
isﬁability problem for OPDL. The embedding of CTL∗into OPDL ensures that it is
2-EXPTIME hard. However, the construction based on the “mosaic method” given in
the Section 2.3 does not provide an optimal decision procedure for OPDL. Future work
will be devoted to ﬁnd an optimal decision procedure for OPDL showing that its sat-
isﬁability problem is in 2-EXPTIME. Indeed, at the current stage, we conjecture that
CTL∗is not easier to deal with than OPDL. We also plan to ﬁnd a sound and complete
axiomatization for the logic OPDL.
As to the logic OPDLlts whose semantics has been sketched in Section 4, much work
remains to be done. First of all, we plan to study more in detail the differences between
OPDL and OPDLlts, taking inspiration from Reynolds’ work [22] on the comparison
between the CTL∗semantics in terms of R-generable models and the CTL∗semantics
in terms of (N × W) structures (or bundled trees). For instance, we plan to ﬁnd some
interesting examples of formulae of the language LOPDL(Prop, Atm) which are valid
in OPDLlts but are not valid in OPDL. Secondly, we plan to adapt the proof of the
decidability of the satisﬁability problem for OPDL given in the Section 2.3 in order
to prove the decidability of the satisﬁability problem for OPDLlts. Another aspect of
the logic OPDLlts that we plan to investigate in the future is its relationship with the
extension of PDL with a repetition construct (PDL-Δ) by [26]. PDL-Δ extends PDL
with constructions of the form Δπ meaning that “the program π can be repeatedly
executed inﬁnitely many times”. We believe that the construction Δπ can be simulated
in OPDLlts as follows:
Δπ
def
= ⟨⟨≡⟩⟩[[π∗]]⟨⟨π⟩⟩⊤
We postpone to future work the deﬁnition of the exact translation from PDL-Δ formulae
to OPDLlts formulae and a theorem stating that, for every PDL-Δ formula ϕ, ϕ is PDL-
Δ valid if and only if the translation of ϕ in OPDLlts is OPDLlts valid.
References
1. Alur, R., Henzinger, T., Kupferman, O.: Alternating-time temporal logic. Journal of the
ACM 49, 672–713 (2002)
2. Axelsson, R., Hague, M., Kreutzer, S., Lange, M., Latte, M.: Extended computation tree
logic. In: Ferm¨uller, C.G., Voronkov, A. (eds.) LPAR-17. LNCS, vol. 6397, pp. 67–81.
Springer, Heidelberg (2010)
3. Balbiani, P., Lorini, E.: Ockhamist propositional dynamic logic: a natural link between PDL
and CTL∗. Technical Report IRIT/RT–2013-12–FR, Institut de Recherche en Informatique
de Toulouse (2013)
4. Belnap, N., Perloff, M., Xu, M.: Facing the future: agents and choices in our indeterminist
world. Oxford University Press (2001)
5. Brown, M., Goranko, V.: An extended branching-time ockhamist temporal logic. Journal of
Logic, Language and Information 8(2), 143–166 (1999)
6. Clarke, E.M., Emerson, E.A.: Design and synthesis of synchronization skeletons using
branching time temporal logic. In: Kozen, D. (ed.) Logic of Programs 1981. LNCS, vol. 131,
pp. 52–71. Springer, Heidelberg (1982)

Ockhamist Propositional Dynamic Logic: A Natural Link between PDL and CTL∗
265
7. Dam, M.: CTL* and ECTL* as fragments of the modal mu-calculus. Theoretical Computer
Science 126(1), 77–96 (1994)
8. De Nicola, R., Vaandrager, F.W.: Action versus state based logics for transition systems. In:
Guessarian, I. (ed.) LITP 1990. LNCS, vol. 469, pp. 407–419. Springer, Heidelberg (1990)
9. Emerson, E.A., Halpern, J.: ‘Sometimes’ and ‘not never’ revisited: on branching versus linear
time. Journal of the ACM 33, 151–178 (1986)
10. Emerson, E.A., Sistla, A.: Deciding full branching time logic. Information and Control 61,
175–201 (1984)
11. Emerson, E.A.: Temporal and modal logic. In: van Leeuwen, J. (ed.) Handbook of Theoreti-
cal Computer Science. Formal Models and Semantics, vol. B. North-Holland Pub. Co./MIT
Press (1990)
12. Fischer, M.J., Ladner, R.E.: Propositional dynamic logic of regular programs. Journal of
Computer Systems Science 18(2), 194–211 (1979)
13. Goranko, V.: Coalition games and alternating temporal logics. In: Proc. of TARK 2001, pp.
259–272. Morgan Kaufmann (2001)
14. Harel, D.: Dynamic logic. In: Gabbay, D., Guenthner, F. (eds.) Handbook of Philosophical
Logic, vol. 2, pp. 497–604. Reidel, Dordrecht (1984)
15. Harel, D., Kozen, D., Tiuryn, J.: Dynamic Logic. MIT Press (2000)
16. Masini, A., Vigan`o, L., Volpe, M.: Labelled natural deduction for a bundled branching tem-
poral logic. Journal of Logic and Computation 21(6), 1093–1163 (2011)
17. McCabe-Dansted, J.C.: A tableau for the combination of CTL and BCTL. In: Proc. of TIME
2012, pp. 29–36. IEEE Computer Society (2012)
18. N´emeti, I.: Decidable versions of ﬁrst order logic and cylindric-relativized set algebras. In:
Csirmaz, L., Gabbay, D., de Rijke, M. (eds.) Logic Colloquium 1992, pp. 171–241. CSLI
Publications (1995)
19. Nishimura, H.: Descriptively complete process logic. Acta Informatica 14, 359–369 (1980)
20. Pnueli, A.: The temporal logic of programs. In: Proc. of the Eighteenth Symposium on Foun-
dations of Computer Science, pp. 46–57. IEEE Computer Society (1977)
21. Prior, A.: Past, Present, and Future. Clarendon Press, Oxford (1967)
22. Reynolds, M.: An axiomatization of full computation tree logic. Journal of Symbolic
Logic 66(3), 1011–1057 (2001)
23. Reynolds, M.: A tableau for bundled CTL*. Journal of Logic and Computation 17(1), 117–
132 (2007)
24. Reynolds, M.: A tableau for CTL*. In: Cavalcanti, A., Dams, D.R. (eds.) FM 2009. LNCS,
vol. 5850, pp. 403–418. Springer, Heidelberg (2009)
25. Stirling, C.: Modal and temporal logics. In: Abramsky, S., Gabbay, D.M., Maibaum, T.S.E.
(eds.) Handbook of Logic in Computer Science, vol. 2. Clarendon Press, Oxford (1992)
26. Streett, R.S.: Propositional dynamic logic of looping and converse is elementarily decidable.
Information and Control 54(1-2), 121–141 (1982)
27. Thomason, R.: Combinations of tense and modality. In: Gabbay, D., Guenthner, F. (eds.)
Handbook of Philosophical Logic, vol. 2, pp. 135–165. Reidel, Dordrecht (1984)
28. Vardi, M.Y., Stockmeyer, L.J.: Improved upper and lower bounds for modal logics of pro-
grams. In: Proc. of the 17th Annual ACM Symposium on Theory of Computing, pp. 240–251.
ACM (1985)
29. Wolper, P.: A translation from full branching time temporal logic to one letter propositional
dynamic logic with looping. Unpublished manuscript (1982)
30. Zanardo, A.: Branching-time logic with quantiﬁcation over branches: The point of view of
modal logic. Journal of Symbolic Logic 61(1), 143–166 (1996)

Information, Awareness and Substructural
Logics
Igor Sedl´ar
Faculty of Arts, Comenius University in Bratislava
Gondova 2, 814 99 Bratislava, Slovak Republic
sedlar@fphil.uniba.sk
Abstract. The paper outlines a generalisation of the awareness-based
epistemic semantics by Fagin and Halpern. Awareness is construed as a
relation between agents and pieces of information instead of formulas.
The main motive for introducing the generalisation is that it shows sub-
structural logics to be a natural component of information-based epis-
temic logic: substructural logics can be seen as describing the logical
behaviour of pieces of information. Substructural epistemic logics are
introduced and some of their properties are discussed. In addition, ex-
tensions of substructural epistemic logics invoking group-epistemic and
dynamic modalities are sketched.
Keywords: Awareness,EpistemicActions,EpistemicLogic,Information,
Substructural Logic.
1
Introduction
The present paper provides a generalisation of the awareness-based epistemic
framework by Fagin and Halpern [17]: awareness is construed as a relation be-
tween agents and pieces of information. The main motive for introducing the gen-
eralisation is that it connects epistemic logics with substructural logics [29,32]. It
is shown that the latter are a natural component of information-based epistemic
logics: substructural logics can be seen as describing the logical behaviour of
pieces of information.
The generalisation provides a framework for studying a large class of substruc-
tural epistemic logics. The paper is an introductory overview of the framework,
focusing on a general discussion of substructural epistemic logics. Consequently,
many standard investigations of speciﬁc logics (such as completeness proofs) are
postponed to a sequel. We note that our approach owes much to justiﬁcation
logics [3,4,5,6] and to the Fitting semantics [19,20] in particular. While being
similar in some respects, our approach and Fitting semantics are motivated by
diﬀerent goals: we are aiming solely at explaining the possible applications of
substructural logics within epistemic logic.
The paper is organised as follows. Section 2 outlines the awareness-based
framework [17]. Section 3 suggests a generalisation of the framework: ‘pieces of
information’ are discussed explicitly and awareness is construed as pertaining to
L. Libkin, U. Kohlenbach, and R. de Queiroz (Eds.): WoLLIC 2013, LNCS 8071, pp. 266–281, 2013.
c
⃝Springer-Verlag Berlin Heidelberg 2013

Information, Awareness and Substructural Logics
267
these. Building on the relational semantics for distributive substructural logics,
Sect. 4 explains that the logics can be seen as natural ‘logics of information’.
Section 5 expands on the above observations and introduces substructural epis-
temic logics. Section 6 outlines an information-based generalisation of public
announcements and discusses some of its idiosyncrasies. Section 7 concludes the
paper and outlines some interesting directions for future work. Proofs of some
of the propositions are given in a technical appendix.
2
Logical Omniscience and Awareness
It has been argued since the inception of epistemic logic that the modal-logic-
based approach1 is rather optimistic as to the agents’ epistemic abilities. If ‘α
believes that F’ is equivalent to ‘F holds in every α-accessible alternative’ and
F1 ∧. . . ∧Fn →G
(1)
holds in every alternative, then if α believes F1, . . . , Fn, then she is bound to
believe G as well.2 This is rather optimistic indeed. There are no logical reasons
why α should ‘realise’ that (1) holds in every alternative and adjust her beliefs
accordingly. The problem is known as the logical omniscience problem.3
This is a conceptual issue: the notion of belief embodied in the modal-logic-
based epistemic logics is rather speciﬁc and it does not conform to many intu-
itions associated with our use of the word ‘belief’.4 The intuitions are numerous,
unclear, and perhaps mutually inconsistent. However, one may try to explicate
one’s intuitions in a little more detail and provide appropriate formalisations.
This has been done by many, which led to a number of sophisticated contribu-
tions to epistemic logic.5
One may argue that the ‘pre-theoretical notion of belief’ includes a crucial
element ignored by the modal-logic-based approach, namely the agent’s active
attitudes towards the believed proposition. Thus, Fagin and Halpern [17] cou-
ple the true-in-every-alternative condition with α’s awareness of the believed
formula. Formally, an awareness model is a quadruple
M = ⟨W, R, A, V ⟩
(2)
where W is the set of alternatives (or ‘possible worlds’), R is a binary relation
on W (the ‘accessibility’ relation) and V is a valuation. The crucial element is
1 This approach originates in Hintikka’s classic [21]. For a more recent overview, see
[10], for example.
2 To ensure that or discussion is as general as possible, we shall be using the notion of
belief throughout the paper. However, some contexts will allow us to use the stronger
‘true belief’ and even ‘knowledge’.
3 The term has been coined by Hintikka, see [22]. For more details on the problem,
see [18, Ch. 9].
4 Hintikka [21] concludes his discussion of the problem in a similar vein. For a more
recent incarnation of the idea, see [10].
5 See [18, Ch. 9] for an overview.

268
I. Sedl´ar
A, a function from W to sets of formulas. Informally, F ∈A(w) means that
α is aware of F at w. ‘α believes that F’ holds at a world w ∈W iﬀi) Rwv
implies that F holds at v (α ‘implicitly’ believes that F) and, importantly, ii)
F ∈A(w). The syntactic nature of the awareness function makes it clear that
one may avoid the logical omniscience problem for every instance of (1). Since
A(w) may be arbitrary, it is always possible to construct a pointed model M, w
such that ‘α believes that Fi’ holds at M, w for every 1 ≤i ≤n, but G ̸∈A(w).
However, one can argue that the syntactic ﬂavour of the approach is, in fact,
a shortcoming. The syntactical nature of the awareness function can be seen as
depriving the approach from the capacity to oﬀer a deeper internal justiﬁcation
of the respective failures of omniscience. One may strive for a logic of non-
omniscient belief where the properties of belief are arrived at by using a subtler
‘inner semantic mechanism’.
3
Awareness and Information
This section introduces the core notions of the paper. First, the information-
based generalisation of the awareness framework is discussed on an intuitive level
(3.1). After that, information models and related technical notions are deﬁned
(3.2).
3.1
Awareness Generalised
Note that propositions, represented by formulas, can be seen as a special case
of pieces of information. A piece of information can be tentatively characterised
as everything that can corroborate (give support to) a proposition.6
Example 1. Assume that during a murder trial the jury is shown a video of the
defendant entering the victim’s home around the established time of death and
carrying something that could be the murder weapon. The video itself can be
seen as a piece of information that corroborates the proposition ‘The defendant
is guilty’. The prosecution can be said to have made the jury aware of this piece
of information by introducing it during the trial. A statement ‘The defendant
threatened to kill the victim on numerous occasions’ of a witness is another
possible piece of information that corroborates the same proposition.
6 Unfortunately, we do not have space in this paper to provide a satisfactory philo-
sophical analysis of the notions of information and corroboration. However, our being
vague about these notions can be justiﬁed. First, depending on the academic dis-
cipline, distinct notions are associated with the term ‘information’, see [1]. Second,
a similar ambiguity pertains to the often used ‘agent’ as well. However, our use of
‘piece of information’ is close to the standard use of ‘signal’, see [16,31]. ‘Corrobo-
ration’ can be seen as a generalisation of ‘carrying’ information: we do not adopt
Dretske’s [16] assumption that if a signal carries information that F, then F is the
case. ‘s corroborates F’ can be tentatively seen as being close to ‘If accepted by an
agent, s is likely to cause the agent’s belief that F’.

Information, Awareness and Substructural Logics
269
The picture can be complemented by adding general corroboration conditions.
For example, it may be stipulated that if a piece of information s corroborates
a conjunction F ∧G, then it corroborates both conjuncts F, G. In this manner,
pieces of information can be endowed with ‘logical character’.
Example 2. A perceptual image of my two hands can be seen as a piece of
information that corroborates the proposition ‘Both of my hands exist now’.
The image then obviously corroborates both ‘My left hand exists now’ and ‘My
right hand exists now’.
Moreover, taking pieces of information into consideration opens door for con-
sidering relations on pieces of information in addition to the pieces themselves.
These may be, in turn, called upon within corroboration conditions. Examples
will be provided later on.
3.2
Information Models
Deﬁnition 1 (The basic epistemic language). Let Φ = {p1, p2, . . .} be a de-
numerable set of propositional variables and let G be a non-empty set (‘agents’).
The set of formulas of the basic epistemic language LG(Φ) is given by:
F ::= p | ¬F | F ∧F | F ∨F | F →F | F ↔F | αF
(3)
where p ∈Φ and α ∈G. The set of LG-formulas will be denoted as Form(LG).
Formulas αF are read ‘α believes that F’. The Boolean fragment of LG is the
subset of Form(LG) consisting of formulas that do not contain occurrences of
α, for any α ∈G.
Deﬁnition 2 (Information structure and L-structure). An information
structure is a couple
I = ⟨I, △⟩
(4)
where I is a non-empty set (‘pieces of information’) and △is a set of relations
on I. Let ‘X ⊆I’ and ‘s ∈I’ be short for ‘X ⊆I ∈I’ and ‘s ∈I ∈I’,
respectively.
Let L be a language. An information L-structure is a couple
I(L) = ⟨I, ⊩⟩
(5)
where I is an information structure and ⊩is a subset of I × Form(L) (‘corrob-
oration relation’). We shall use ‘s ⊩F’ instead of ‘⟨s, F⟩∈⊩’.
A familiar special case of information structure are sets of atomic programs
together with the program operators, known from propositional dynamic logic
[23]. A special case of information L-structure are action models, known from
dynamic epistemic logics [7,8].
Deﬁnition 3 (Information frames and models). An information frame for
LG is a tuple
F = ⟨W, R, I, A⟩
(6)

270
I. Sedl´ar
where W is a non-empty set (‘possible worlds’), R : G →P(W ×W) is a function
from the set of agents to binary relations on W, I is an information structure,
A : (G × W) →(P(I) −∅) is a function that assigns to every agent α and
possible world w a non-empty set of pieces of information A(α, w) ⊆I. We
shall write ‘Rαwv’ instead of ‘⟨w, v⟩∈R(α)’ and Rα shall be referred to as the
‘α-accessibility’ relation.
An information model for LG is a tuple
M = ⟨F, V, ⊩⟩
(7)
where F is an information frame for LG, V : Φ →P(W) is a valuation and ⊩
is a corroboration relation.
The α-accessibility relations are interpreted in the usual way (implicit belief).
A(α, w) is to be thought of as the set of pieces of information α is aware of at
w. Our target notion of belief can be characterised as follows: α believes that
F iﬀα implicitly believes that F and is aware of a piece of information that
corroborates F.7
It is clear that awareness models are a special case of information models.
Just consider information structures where I = Form(LG) and ⊩is the identity
relation on I. Speciﬁc closure principles may be validated by incorporating extra
corroboration conditions. For example, closure under ∧-elimination corresponds
to the condition:
– If s ⊩F ∧G, then s ⊩F and s ⊩G
Deﬁnition 4 (Truth conditions). The truth conditions of the Boolean for-
mulas are as usual and we state only some:
– M, w |= p iﬀw ∈V (p)
– M, w |= ¬F iﬀM, w ̸|= F
– M, w |= F ∧G iﬀM, w |= F and M, w |= G
The target notion of belief is formalised in an obvious way:
– M, w |= αF iﬀi) Rαwv implies M, v |= F and ii) there is a s ∈A(α, w)
such that s ⊩F
The usual notions of validity in a model, frame and class of frames are assumed.
Note that, to ensure maximal generality, we have not introduced speciﬁc cor-
roboration conditions yet. However, Sect. 4 points out that truth conditions in
substructural models are natural candidates.
7 The requirement that the awareness sets be non-empty is a useful idealisation, see
the proof of Prop. 3.

Information, Awareness and Substructural Logics
271
4
Information and Substructural Logics
‘Pieces of information’ have been invoked within informal interpretations of the
semantics of many substructural logics. For example, Kripke [24] describes the
points of intuitionistic models as ‘points in time (or “evidential situations”),
at which we may have various pieces of information’ [24, p. 98]. Urquhart’s
interpretation of his semi-lattice semantics for relevant implication [33] invokes
‘pieces of information’ together with speciﬁc operations on them. More recent
interpretations [26,28] invoke a related notion of situation. Hence, there is hope
that epistemic models where pieces of information are considered explicitly will
be a natural ‘meeting point’ of epistemic and substructural logics.
Deﬁnition 5 (Substructural frames and models). We shall use a slight
modiﬁcation of the standard deﬁnitions [29, Ch. 11]. A substructural frame is a
tuple
F = ⟨P, ⊑, •, C⟩
(8)
where P is a non-empty set (‘points’), ⊑is a partial order on P (‘informational
containment’), • is a binary operation on P (‘application’) and C is a symmetric
binary relation on P (‘compatibility’). It is assumed that
– If Cxy, x′ ⊑x and y′ ⊑y, then Cx′y′
– if x • y ⊑z, x′ ⊑x, y′ ⊑y and z ⊑z′, then x′ • y′ ⊑z′
A substructural model for LG is a couple
M = ⟨F, ⊩⟩
(9)
where F is a frame and ⊩is a relation between points and members of Form(LG)
such that:
– x ⊑y and x ⊩p implies y ⊩p
– x ⊩¬F iﬀCxy implies y ̸⊩F for all y
– x ⊩F ∧G iﬀx ⊩F and x ⊩G
– x ⊩F ∨G iﬀx ⊩F or x ⊩G
– x ⊩F →G iﬀy ⊩F and x • y ⊑z imply z ⊩G, for all y, z
– x ⊩F ↔G iﬀx ⊩F →G and x ⊩G →F
F entails G in M iﬀx ⊩F implies x ⊩G for every x ∈M. Entailment in
frames and classes of frames is then deﬁned in the usual way.
Substructural frames (models) clearly are a special case of information structures
(LG-structures). Substructural frames correspond to a set of pieces of information
together with a binary relation ⊑of informational containment, a relation of
compatibility C and an operation of application •. Let us discuss these in reverse
order.
Example 3. Application corresponds to ‘taking two pieces of information to-
gether’: the two pieces of information taken together can be seen as a ‘new’
piece of information. For example, two consecutive statements s, t by witnesses
during a trial can be seen as a ‘complex’ piece of information s • t, considered
by the jury.

272
I. Sedl´ar
Example 4. As an example of two compatible pieces of information, consider a
sworn statement of a witness to the eﬀect that the defendant’s car was parked
somewhere far away from the crime scene around the time of the victim’s death
(s) and the video from Exam. 1 (t). The two are obviously compatible. Conse-
quently, s does not corroborate the proposition ‘The defendant is not guilty’,
¬F, since it is consistent with t, a piece of information that corroborates F.
Proposition 1. Let F be a member of the Boolean fragment of LG, M a sub-
structural model and x, y points of M. If x ⊩F and x ⊑y, then y ⊩F.
Hence, if x is informationally contained in y, then every Boolean formula that
holds at x holds at y as well. The Proposition is a standard result in substructural
logic and a simple consequence of Def. 5.
Example 5. Informational containment can be seen as a complex relation: s ⊑t
iﬀi) s is contained in t and ii) every F corroborated by s is corroborated by t
as well. For an example of a piece of information contained in a ‘larger’ piece,
consider two ﬁngerprints found on a crime scene. The couple of prints can be
seen as a piece of information containing the two single prints. It is plausible
to assume automatically that if one of the prints corroborates a proposition
(e.g. that a given suspect is guilty), then the couple does so as well. However,
this is not plausible in general. For example, consider a sworn statement that the
defendant was playing poker at a local casino at the estimated time of the murder
(s) and, again, the video from Exam. 1 (t). The jury can take these together,
i.e. consider s • t. In a sense, both s, t are contained in s • t. However, they are
not so in the informational sense: while s alone can be said to corroborate ¬F,
s • t cannot. The new piece of information t ‘neutralised’ the force of s.
Consequently, the corroboration condition for F →G makes sense: s can
be said to corroborate F →G iﬀtaking s together with any possible piece of
information t that corroborates F results in s • t that corroborates G, and so
does every u such that s • t ⊑u.
Observe that the ‘boxed’ formulas αF have not received attention yet. To retain
generality, we shall not provide truth conditions, but we will focus on a speciﬁc
class of substructural models.
Deﬁnition 6 (Intended substructural models). An intended substructural
model for LG is a substructural model for LG such that
s ⊩F only if s ⊩αF for every α ∈G
(10)
In intended models, boxed formulas behave somewhat like propositional atoms.
Extension of Prop. 1 to the whole LG within intended models is a trivial conse-
quence of Def. 6. The clause (10) is included also for technical reasons that will
become clear in Sect. 5.2. But it can be motivated independently as well: if s
corroborates F, then s should be a suﬃcient reason to believe F. Of course, (10)
can be dropped in case it is not considered intuitive enough, but we choose to

Information, Awareness and Substructural Logics
273
keep it.8 Another reason to keep the clause is that it allows for a natural way of
dealing with common belief (Sect. 5.3).
5
Substructural Epistemic Logics
Substructural epistemic logics emerge as soon as we use substructural models as
the information structures in information models.
5.1
Substructural Information Models
Deﬁnition 7 (Substructural information C-frames and C-models). Let
C be a class of substructural frames. A substructural information C-frame is a
tuple
F = ⟨W, R, F, A⟩
(11)
where W, R, A are as in Def. 3 and F is a substructural frame such that F ∈C.
Moreover, let us assume for technical convenience9 that
s ∈A(α, w) and s′ ⊑s only if s′ ∈A(α, w)
(12)
A substructural information C-model built on F = ⟨W, R, F, A⟩is a tuple
M = ⟨W, R, M, A, V ⟩
(13)
where W, R, A are as in Def. 3, M = ⟨F, ⊩⟩is an intended substructural model
and V is a valuation.
The truth conditions of LG-formulas are those of Def. 4. The usual notions of
validity in a model and a frame are assumed. F is C-valid iﬀit is valid in every
substructural information C-frame. The set of C-valid formulas shall be denoted
as K(C).
The sets K(C) can be seen as basic information-based epistemic logics where the
pieces of information are ‘described’ by the logic of C. The actual choice of C
will depend on the application.10 However, since this paper is focused on the
general framework, we shall not discuss such special cases here. We shall limit
our discussion to a rather general observation instead.
Proposition 2. F is C-valid if (but not only if) i) F is a propositional tautology
or ii) F = αG →αG′, where G entails G′ in C.
8 There is a standard way of dealing with ‘boxes’ that invokes additional relations, see
[29]. A diﬀerent evidence-based approach that builds only on C and ⊑is discussed
in [12].
9 See the proof of Prop. 4 in the appendix.
10 For example, Sequoiah-Grayson [30] argues that, when modelling the ﬂow of infor-
mation in inference, associativity s • (t • u) = (s • t) • u, contraction s • s = s and
other assumptions have to be rejected, leaving only weak commutativity s •t = t •s.

274
I. Sedl´ar
Hence, substructural epistemic logics in general respect propositional validity
and belief is closed under C-entailment.
Example 6. An example of such a closure principle would be closure under con-
junction elimination:
α(F ∧G) →(αF ∧αG)
(14)
On the other hand, some of the more problematic closure principles are not valid.
Example 7. Examples of invalid closure principles include closure under conjunc-
tion introduction and Modus Ponens:
(αF ∧αG) →α(F ∧G)
(15)
α(F →G) →(αF →αG)
(16)
The construction of counterexamples is easy and the reader may try it as an
exercise.
Closure under logical equivalence does not hold either, i.e. it is not the case
that if F ↔G is C-valid, then αF ↔αG is C-valid as well. For example,
counterexamples concerning the classical tautology (p →q) ↔(¬p ∨q) are
easily constructed for most classes C.
Consequently, substructural epistemic logics achieve the goal mentioned in Sect.
2: the non-omniscient properties of belief are explained by reference to the ‘logical
character’ of pieces of information.
5.2
Factive and Introspective Models
Deﬁnition 8 (Factive frames and models). A substructural information
frame
F = ⟨W, R, F, A⟩
is factive iﬀevery R(α) is reﬂexive on W. A substructural information model
M built on F is factive iﬀF is factive. The set of formulas valid in every factive
C-frame will be denoted T(C).
Proposition 3. αF →F is F-valid iﬀF is a factive frame. Consequently,
αF →F ∈T(C) for every C.
Hence, in the context of factive models and frames, α may be read in terms of
‘true belief’ or even ‘knowledge’.
Deﬁnition 9 (Introspective frames and models). A substructural infor-
mation frame F = ⟨W, R, F, A⟩is introspective iﬀevery R(α) is transitive on
W and Rαwv implies A(α, w) ⊆A(α, v) for every α and w. A substructural
information model M built on F is introspective iﬀF is introspective. The set
of formulas valid in every introspective C-frame will be denoted K4(C) and the
set of formulas valid in every factive and introspective C-frame will be denoted
S4(C).
Proposition 4. αF →ααF is F-valid iﬀF is an introspective frame.
Consequently, αF →ααF ∈K4(C) for every C.

Information, Awareness and Substructural Logics
275
5.3
Common Belief
This section outlines a way to deal with common belief in the substructural
epistemic framework. We will work with the standard construal of common be-
lief as an inﬁnite iteration of the ‘everybody-believes-operator’. It is noted that
common belief lacks some of the standard properties.
Deﬁnition 10 (Language with common belief). The language with com-
mon belief L∗
G extends the basic epistemic language with a family of operators
B for every B ⊆G. Formulas BF are read ‘It is common belief in B that F’.
Moreover, BF is a shorthand for 
α∈B αF, read ‘every agent in B believes
that F’.
Deﬁnition 11 (Common belief information structures). A B-sequence
σB is a sequence of belief-operators α1 . . . αn where n ≥1 and every αi ∈B.
I(L∗
G) is a common belief information L∗
G-structure iﬀit is the case that
– s ⊩BF iﬀs ⊩σBF for every B-sequence σB
A common belief C-model is a substructural information C-model where the infor-
mation L∗
G-structure is a common belief information L∗
G-structure. K∗(C), T∗(C),
K4∗(C) and S4∗(C) are sets of L∗
G-formulas valid in every common belief C-model,
every factive, introspective and factive and introspective common belief C-model,
respectively.
Lemma 1. If s ⊩F, then s ⊩σBF for every B-sequence σB and every B ⊆G.
Deﬁnition 12 (Group accessibility). Let B ⊆G. Let a B-path from w to
v be a sequence of couples ⟨w1, w2⟩, . . . , ⟨wn−1, wn⟩such that w1 = w, wn = v
and every ⟨wi, wi+1⟩∈R(α) for some α ∈B. Let R(B) (‘B-accessibility’) be a
binary relation on W such that ⟨w, v⟩∈R(B) iﬀthere is a B-path from w to v.
Deﬁnition 13 (Truth conditions for common belief). The truth condi-
tions for every L∗
G-formula are speciﬁed by adding the following clause to Def.
4:
– M, w |= BF iﬀi) M, w |= BF and ii) RBwv implies M, v |= BF.
Let us close the section by pointing out that two of the well known axioms for
‘common knowledge’ hold also for common belief in the substructural epistemic
setting, if we limit our attention to factive frames (i.e. if we are studying ‘common
true belief’ or ‘common knowledge’).
Proposition 5. The following belong to T∗(C) for every C:
1. BF →(F ∧BBF) (‘Mix’)
2. B(F →BF) →(F →BF) (‘Induction’)
However, other standard axioms, such as B-closure under Modus Ponens and
B-necessitation, do not hold due to the speciﬁcs of the simple α-belief.

276
I. Sedl´ar
6
Public Information Introduction
This section investigates into a generalisation of public announcements (not nec-
essarily truthful). If we see formulas as special cases of pieces of information, then
the action of publicly announcing a formula is a special case of publicly intro-
ducing a piece of information. Hence, it is interesting to look at the more general
case.
Deﬁnition 14 (The announcement language). Let AI (‘active pieces of in-
formation’) and G (‘agents’) be non-empty sets of labels. Formulas of the an-
nouncement language L+
G (Φ, AI) are constructed as follows:
F ::= p | ¬F | F ∧F | F ∨F | F →F | F ↔F | αF | s : F | [+s]F
(17)
where p ∈Φ, α ∈G and s ∈AI.
Formulas s : F are read ‘s corroborates F’ and [+s]F is read ‘F is the case
after the public introduction of s’. We shall not assume special corroboration
conditions for formulas s : F and [+s]F.11
Deﬁnition 15 (Information models for the announcement language).
We shall use the models of Def. 7 with the proviso that I ⊆AI. Validity of for-
mulas in models, frames and classes of frames is deﬁned in the usual way. Truth
conditions for the ‘basic epistemic fragment’ of the announcement language are
as before (Def. 4). Moreover:
– M, w |= s : F iﬀs ∈I and s ⊩F
– M, w |= [+s]F iﬀs ∈I implies M +s, w |= F
where
M+s = ⟨W +s, R+s, I(L+
G )+s, A+s, V +s⟩
(18)
such that
– W +s = W, I(L+
G )+s = I(L+
G ) and V +s(p) = V (p) for all p ∈Φ
– R+s
α (w) = Rα(w) −sM for every α, w
– A+s(α, w) = A(α, w) ∪{s} for every α, w
where Rα(w) = {v | Rαwv} and sM = {w | M, w |= ¬F for some F such that
s ⊩F}.
K+(C) is the class of L+
G -formulas valid in every information C-model for L+
G .
T+(C), K4+(C) and S4+(C) are the classes of L+
G -formulas valid in every factive,
introspective, and factive and introspective C-model for L+
G .
‘s corroborates F’ holds in a pointed model only if s is ‘active’ in the model, i.e.
if s ∈I ⊆AI. A public introduction of s inserts s into every A(α, w) and ‘cuts
oﬀ’ the accessibility arrows leading to points where the negation of a formula
corroborated by s holds. Such an introduction is ‘persuasive’ and ‘monotonic’:
11 However, it might be plausible to assume that s ⊩[+t]F iﬀs • t ⊩F.

Information, Awareness and Substructural Logics
277
Lemma 2 (Persuasiveness and monotonicity). The following are contained
in K+(C), for every C:
1. s : F →[+s]αF
2. αF →[+s]αF
There is a stronger version of information introduction for which these properties
do not hold. It is possible to add the assumption that Cst holds for every t ∈
A+s(α, w). In other words, we could assume that the introduction of s results in
‘removing’ every t that is not consistent with s from the awareness set. For sake
of simplicity, we shall not discuss this version in more detail here.12
Note that application of the standard ‘reduction-axioms-technique’ is seriously
limited in the substructural epistemic framework. Importantly, there is no hope
of being able to ﬁnd an equivalent LG-formula for every L+
G -formula. The reason
is explained by Exam. 7: it is possible that there are formulas [+s]F and G such
that [+s]F ↔G is valid, but α[+s]F ↔αG is not. However, variants of some
of the well-known reduction axioms are still valid.
Proposition 6. The following belong to K+(C), for every C:
1. s : G →([+s]p ↔p)
2. s : G →([+s]¬F ↔¬[+s]F)
3. [+s](F ∧G) ↔([+s]F ∧[+s]G)
4. [+s](F ∨G) ↔([+s]F ∨[+s]G)
5. [+s](F →G) ↔([+s]F →[+s]G)
6. [+s](F ↔G) ↔([+s]F ↔[+s]G)
7. s : G →([+s]αF ↔(s : F ∨
αF))
8. s : G →([+s]t : F ↔t : F)
Notice items 1., 2., 7. and 8.: the antecedent s : G is necessary, since not every
s is ‘active’ in every model.13 To sidestep this, we could narrow our attention
down to models where every piece of information expressible in the language is
active.
Deﬁnition 16 (Full frames). An information frame is AI-full iﬀI = ⟨AI, △⟩.
Corollary 1. The following are valid in every AI-full information frame:
1. [+s]p ↔p
2. [+s]¬F ↔¬[+s]F
3. [+s]αF ↔(s : F ∨αF)
4. [+s]t : F ↔t : F
A note on related work. Combinations of public announcements and information-
based epistemic logics are widely studied within dynamic justiﬁcation logics.
However, there are notable diﬀerences between the justiﬁcation-logic-based
12 However, there is hope that working with both of these versions will yield interesting
results concerning the relation of the present framework to the AGM belief revision
theory, see [2].
13 This fact partly justiﬁes our inclusion of formulas s : F into the announcement
language. The other part of the justiﬁcation is the fact that without such formulas,
no interesting ‘recursion implication’ for formulas [+s]αF would be provable.

278
I. Sedl´ar
approaches and the approach of the present paper. Bucheli et al. [13,14] and
Renne [27] combine justiﬁcation logic with announcements, but the latter are
classical formula announcements. Kuznets and Studer [25] combine formula an-
nouncements with evidence introduction, in that the announcement itself is con-
sidered as a new piece of evidence. The rich framework of Baltag et al. [9] deals
with various versions of evidence dynamics, but does so only for the singe-agent
case and the ‘pieces of information’ are considered from the viewpoint of jus-
tiﬁcation logic, not substructural logic. Apart from the justiﬁcation-logic-based
approaches, an interesting contribution has been made by van Benthem and
Pacuit [11], but they construe evidence in terms of sets of possible worlds and
their announcements are formula-based as well.
7
Conclusion
Our primary goal in this paper was to explain that substructural logics are a
natural part of information-based epistemic logic. This observation may stim-
ulate productive collaborations between sub-ﬁelds of logic that have perhaps
been thought of as rather remote from one another. The paper is an introduc-
tory outline and, consequently, there are many interesting directions for future
work. First, we plan to concentrate on speciﬁc substructural epistemic logics:
to explain their respective philosophical motivations in more detail and to pro-
vide axiomatisations. Second, as the present framework is rather general, its
will be interesting to expound connections to the established formalisms. Third,
the information-introduction-extensions of substructural epistemic logics deserve
systematic attention: sound and complete axiomatisations are a natural goal, as
is establishing connections with the well-known version of dynamic-epistemic
logics. Moreover, there are many other dynamic extensions that have been left
out of the present outline. In addition, it is interesting to dwell upon the ‘philo-
sophical background’ of the present framework: one could formulate diﬀerent
readings of ‘corroboration’ and ‘piece of information’ and provide various ver-
sions of information-based logics built to ﬁt the diﬀerent readings. There is hope
that this will result in non-trivial applications of the present framework in epis-
temology.
Acknowledgements. I gratefully acknowledge the constructive comments of
the anonymous referees. The paper builds upon a talk given at MCMP, Munich
in February 2013, where the audience provided helpful feedback as well. This
work was carried out at the Department of Logic and Methodology of Sciences,
Comenius University in Bratislava as a part of the research project ‘Seman-
tic models, their explanatory power and applications’, supported by the grant
VEGA 1/0046/11.

Information, Awareness and Substructural Logics
279
Appendix: Proofs of Propositions
This technical appendix contains proofs of some of the Propositions stated in
the paper.
Proof of Prop. 3. The implication from right to left is trivial. The converse
implication is easily demonstrated in the usual way. Assume that F is not a
factive frame. Hence, there are α and w such that ¬Rαww. Since A(α, w) is
non-empty by Def. 3, we may choose an arbitrary s ∈A(α, w). Now deﬁne a
model M built on F such that s ⊩p, M, w ̸|= p and Rαwv implies M, v |= p for
every v. It is obvious that M ̸|= αp →p.
Proof of Prop. 4. The implication from right to left is trivial. Again, the converse
implication is easily demostrated in the usual way. Assume that F is not intro-
spective. The assumption entails that 1) there are α, w, v, v′ such that Rαwv,
Rαvv′ and ¬Rαwv′, or 2) there are α, w, v such that Rαwv and A(α, w) ̸⊆
A(α, v).
Assume 1). Build a model M as follows. Choose an arbitrary s ∈A(α, w) and
set s ⊩p. In addition, set M, u |= p for every u such that Rαwu and M, u′ ̸|= p
for every u′ such that Rαvu′. It is plain that M, w ̸|= αp →ααp.
Now assume 2). There is a s ∈A(α, w) such that s ̸∈A(α, v). Build a model
M as follows. Let t ⊩p iﬀt ∈{s′ | s ⊑s′} for all t. Moreover, let t ̸⊩p for every
t ∈A(α, v). This choice is possible due to (12) of Def. 7. Moreover, set M, u |= p
for every u such that Rαwu. It is plain that M, w ̸|= αp →ααp.
Proof of Prop. 5. Item 1. BF obviously entails F (Def. 8, 13 and Prop. 3). It
remains to prove that BF entails BBF. Now M, w |= BF entails M, w |=
αF for every α ∈B (Def. 13). The latter entails that there is a t ∈A(α, w)
such that t ⊩F. Consequently, t ⊩σBF for every B-sequence σB (Lem. 1) and
t ⊩BF.
Hence, it remains to prove that Rαwv and M, w |= BF together imply
M, v |= BF for every v and α ∈B. Assume to the contrary. The assumption
entails that a) M, v ̸|= BF or b) RBvu and M, u ̸|= BF for some u. How-
ever, both are impossible, since RBwv and RBwu: consequently, the assumption
entails that M, v |= BF and M, u |= BF.
Item 2. The proof is virtually identical to the standard inductive proof of
a similar claim in modal-logic-based epistemic logic [15, p. 37]. Assume that
M, w |= B(F →BF) ∧F. We have to show that M, w |= BF, i.e. that
Rn
Bwv entails M, v |= BF for every n ≥0, where R0
Bwv iﬀw = v and Rm
B wv
iﬀv is reachable from w by a B-path of length m. The base case for n = 0 is
trivial. Now assume that the claim holds for a speciﬁc m: there is a v such that
Rm
B wv and M, v |= BF. To prove the claim for m + 1, pick an α ∈B and a
u such that Rαvu. Now M, v |= αF obviously entails M, u |= F. But RBwu
and, consequently, M, u |= F →BF. Thus, M, u |= BF as desired.

280
I. Sedl´ar
Proof of Prop. 6. Item 1. For every M, w: M, w |= s : G →[+s]p iﬀ(s ∈
I and s ⊩G) implies (s ∈I and M+s, w |= p) iﬀ(s ∈I and s ⊩G) implies
(s ∈I and M, w |= p) iﬀM, w |= s : G →p. By propositional logic, M, w |= s :
G →([+s]p ↔p), for every M, w.
Item 2. First, let us prove that s : G ∧¬[+s]F implies [+s]¬F. By Def.
15, ¬[+s]F is equivalent to the conjunction of s ∈I and M+s, w |= ¬F. The
conjunction implies that s ∈I ⇒M+s, w |= ¬F, i.e. that M, w |= [+s]¬F.
The desired result follows by propositional logic. Second, let us prove that s :
G∧[+s]¬F implies ¬[+s]F. The assumption M, w |= s : G∧[+s]¬F is equivalent
to the conjunction of s ∈I, s ⊩G and (s ∈I
⇒
M+s, w |= ¬F). The
conjunction obviously entails s ∈I and M+s, w ̸|= F, i.e. M, w |= ¬[+s]F.
Items 3. – 6. can be demonstrated by simple propositional reasoning. Item 7.
One half of the result follows from Lemma 2. To prove the second half, assume
that M, w |= s : G ∧¬s : F ∧¬αF. The ﬁrst two conjuncts entail that s ̸⊩F.
The third conjunct entails that i) there is a v such that Rαwv and M, v |= ¬F,
or ii) there is no t ∈A(α, w) such that t ⊩F. Assume i). Since s ̸⊩F, R+s
α wv
for the ¬F-world v. Consequently, M, w ̸|= [+s]αF. Assume ii). Since, s ̸⊩F,
there is no t′ ∈A+s(α, w) such that t′ ⊩F and, consequently, M, w ̸|= [+s]αF.
Item 8. can be proved easily by propositional reasoning and by using the fact
that I(L+
G )+s = I(L+
G ) (Def. 15).
References
1. Adriaans, P., van Benthem, J. (eds.): Philosophy of Information. Elsevier, Amster-
dam (2008)
2. Alchourron, C., G¨ardenfors, P., Makinson, D.: On the Logic of Theory Change:
Partial Meet Contraction and Revision Functions. J. Symbolic Logic 50, 510–530
(1985)
3. Artemov, S.: Operational Modal Logic. Technical report, Cornell University (1995)
4. Artemov, S.: Explicit Provability and Constructive Semantics. B. Symb. Log. 7,
1–36 (2001)
5. Artemov, S.: The Logic of Justiﬁcation. Rev. Symb. Log. 1, 477–513 (2008)
6. Artemov, S.: Why Do We Need Justiﬁcation Logic? In: van Benthem, J., Gupta,
A., Pacuit, E. (eds.) Games, Norms and Reasons: Logic at the Crossroads, pp.
23–38. Springer, Dordrecht (2011)
7. Baltag, A., Moss, L., Solecki, S.: The Logic of Common Knowledge, Public An-
nouncements, and Private Suspicions. In: Gilboa, I. (ed.) Proceedings of the 7th
Conference on Theoretical Aspects of Rationality and Knowledge (TARK 1998),
pp. 43–56. Morgan Kaufmann, San Francisco (1998)
8. Baltag, A., Moss, L.: Logics for Epistemic Programs. Synthese 139, 165–224 (2004)
9. Baltag, A., Renne, B., Smets, S.: The Logic of Justiﬁed Belief Change, Soft Evi-
dence and Defeasible Knowledge. In: Ong, L., de Queiroz, R. (eds.) WoLLIC 2012.
LNCS, vol. 7456, pp. 168–190. Springer, Heidelberg (2012)
10. van Benthem, J.: Logical Dynamics of Information and Interaction. Cambridge
University Press, Cambridge (2011)
11. van Benthem, J., Pacuit, E.: Dynamic Logics of Evidence-Based Beliefs. Studia
Logica 99, 61–92 (2011)

Information, Awareness and Substructural Logics
281
12. B´ılkov´a, M., Majer, O., Peliˇs, M., Restall, G.: Relevant Agents. In: Beklemishev,
L., Goranko, V., Shehtman, V. (eds.) Advances in Modal Logic, vol. 8, pp. 22–38.
College Publications, London (2010)
13. Bucheli, S., Kuznets, R., Renne, B., Sack, J., Studer, T.: Justiﬁed Belief Change.
In: Arrazola, X., Ponte, M. (eds.) Proceedings of the Second ILCLI International
Workshop on Logic and Philosophy of Knowledge, Communication and Action
(LogKCA 2010). The University of the Basque Country Press, San Sebastian (2010)
14. Bucheli, S., Kuznets, R., Studer, T.: Realizing public announcements by justiﬁca-
tions. To appear in J. Comput. Syst. Sci.
15. van Ditmarsch, H., van der Hoek, W., Kooi, B.: Dynamic Epistemic Logic. Springer,
Dordrecht (2008)
16. Dretske, F.: Knowledge and the Flow of Information. MIT Press, Cambridge (1981)
17. Fagin, R., Halpern, J.: Belief, Awareness, and Limited Reasoning. Artif. Intell. 34,
39–76 (1988)
18. Fagin, R., Halpern, J., Moses, Y., Vardi, M.: Reasoning About Knowledge. MIT
Press, Cambridge (1995)
19. Fitting, M.: Logic of Proofs, Semantically. Ann. Pure Appl. Logic 132, 1–25 (2005)
20. Fitting, M.: Reasoning with Justiﬁcations. In: Makinson, D., Malinowski, J., Wans-
ing, H. (eds.) Towards Mathematical Philosophy: Papers from the Studia Logica
Conference Trends in Logic IV, pp. 107–123. Springer, Dordrecht (2009)
21. Hintikka, J.: Knowledge and Belief: An Introduction to the Logic of the Two No-
tions. Cornell University Press, Ithaca (1962)
22. Hintikka, J.: Impossible Possible Worlds Vindicated. J. Philos. Logic 4, 475–484
(1975)
23. Harel, D., Kozen, D., Tiuryn, J.: Dynamic Logic. MIT Press, Cambridge (2000)
24. Kripke, S.: Semantical Analysis of Intuitionistic Logic. In: Crossley, J., Dummett,
M.A.E. (eds.) Formal Systems and Recursive Functions, pp. 92–130. North-Holland
Publishing Company, Amsterdam (1965)
25. Kuznets, R., Studer, T.: Update as Evidence: Belief Expansion. In: Artemov, S.,
Nerode, A. (eds.) LFCS 2013. LNCS, vol. 7734, pp. 266–279. Springer, Heidelberg
(2013)
26. Mares, E.: Relevant Logic. A Philosophical Interpretation. Cambridge University
Press, Cambridge (2004)
27. Renne, B.: Public Communication in Justiﬁcation Logic. J. Logic Comput. 21,
1005–1034 (2011)
28. Restall, G.: Information Flow and Relevant Logics. In: Seligman, J., Westerstøahl,
D. (eds.) Logic, Language, and Computation, vol. 1, pp. 463–467. CSLI Publica-
tions, Stanford (1995)
29. Restall, G.: An Introduction to Substructural Logics. Routledge, London (2000)
30. Sequoiah-Grayson, S.: Epistemic Closure and Commutative, Nonassociative Resid-
uated Structures. Synthese 190, 113–128 (2013)
31. Shannon, C.E.: A Mathematical Theory of Communication. AT&T Tech. J. 27,
379–423, 623–656 (1948)
32. Schr¨oder-Heister, P., Doˇsen, K.: Substructural Logics. Oxford University Press,
Oxford (1993)
33. Urquhart, A.: Semantics for Relevant Logics. J. Symbolic Logic 37, 159–169 (1972)

Author Index
Alechina, Natasha
1
Andrade, La´ıs
34
Arratia, Argimiro
49
Awodey, Steve
11
Balbiani, Philippe
251
Baltag, Alexandru
64
Bergfeld, Jort M.
64
Boja´nczyk, Mikolaj
13
Caicedo, Xavier
226
Carvalho, Ruan
34
Ciabattoni, Agata
81
de Oliveira, Anjolina
34
de Queiroz, Ruy
34
Dyrkolbotn, Sjur Kristoﬀer
96
Ebbing, Johannes
111, 126
Engstr¨om, Fredrik
138
Fourman, Michael P.
153
Hella, Lauri
111, 126
Herzig, Andreas
168
Kishida, Kohei
64
Kontinen, Juha
138, 179
Kurokawa, Hidenori
194
Kushida, Hirohiko
194
Link, Sebastian
179
Lohmann, Peter
111
Lorini, Emiliano
251
Martens, Wim
29
Maruyama, Yoshihiro
211
Meier, Arne
126
Metcalfe, George
226
M¨uller, Julian-Steﬀen
126, 238
Ortiz, Carlos E.
49
Palamidessi, Catuscia
31
Ramanayake, Revantha
81
Rodr´ıguez, Ricardo
226
Rogger, Jonas
226
Sack, Joshua
64
Schwentick, Thomas
33
Sedl´ar, Igor
266
Smets, Sonja J.L.
64
V¨a¨an¨anen, Jouko
138, 179
Virtema, Jonni
111, 126
Vollmer, Heribert
126, 238
Zhong, Shengyang
64

