Bruno Berstel-Da Silva
Veriﬁ cation 
of Business 
Rules 
Programs

Veriﬁcation of Business Rules Programs


Bruno Berstel-Da Silva
Veriﬁcation of Business
Rules Programs
123

Bruno Berstel-Da Silva
Software Engineering group
University of Freiburg
Georges-Köhler-Allee 52
79110 Freiburg
Germany
ISBN 978-3-642-40037-7
ISBN 978-3-642-40038-4 (eBook)
DOI 10.1007/978-3-642-40038-4
Springer Heidelberg New York Dordrecht London
Library of Congress Control Number: 2013952961
© Springer-Verlag Berlin Heidelberg 2014
This work is subject to copyright. All rights are reserved by the Publisher, whether the whole or part of
the material is concerned, speciﬁcally the rights of translation, reprinting, reuse of illustrations, recitation,
broadcasting, reproduction on microﬁlms or in any other physical way, and transmission or information
storage and retrieval, electronic adaptation, computer software, or by similar or dissimilar methodology
now known or hereafter developed. Exempted from this legal reservation are brief excerpts in connection
with reviews or scholarly analysis or material supplied speciﬁcally for the purpose of being entered
and executed on a computer system, for exclusive use by the purchaser of the work. Duplication of
this publication or parts thereof is permitted only under the provisions of the Copyright Law of the
Publisher’s location, in its current version, and permission for use must always be obtained from Springer.
Permissions for use may be obtained through RightsLink at the Copyright Clearance Center. Violations
are liable to prosecution under the respective Copyright Law.
The use of general descriptive names, registered names, trademarks, service marks, etc. in this publication
does not imply, even in the absence of a speciﬁc statement, that such names are exempt from the relevant
protective laws and regulations and therefore free for general use.
While the advice and information in this book are believed to be true and accurate at the date of
publication, neither the authors nor the editors nor the publisher can accept any legal responsibility for
any errors or omissions that may be made. The publisher makes no warranty, express or implied, with
respect to the material contained herein.
Printed on acid-free paper
Springer is part of Springer Science+Business Media (www.springer.com)

To Emil Post, to Robert Floyd,
and to all the zebras around the world.


Foreword
It is my great pleasure to introduce Bruno Berstel-Da Silva’s book on the formal
validation of rule programs.
Rules are very simple programming language. Rules may lack the generality
of other general-purpose languages such as Fortran, Lisp, C++, or Java, but they
are congruent with very pervasive human brain constructs, and for this reason they
fascinated early artiﬁcial intelligence experts such as Herbert Simon from Carnegie
Mellon University.
With the advent of better grammars and syntactic editors, it has been possible to
introduce business rules to thousands of business people—not programmers—who
are now able to modify themselves these programs, because they are readable and
their intent is rather simple to understand, and therefore to modify.
Because we often learn and think in rules, mapping expert intent into code is very
easy and is demonstrated in thousands of applications in the world. Rule systems
detect frauds, validate credit card payments, make loan proposals, check all sorts of
transactions against general regulations, offer health advice, promotions for travel,
lodging, and much more: : :
For years, rule systems have been rather slow compared to programs written
by professional software developers, but progress in rule compilation has enabled
the modern rule systems to be as fast as, if not faster than, equivalent hard-coded
programs. Response times are now routinely measured in milliseconds, expanding
the scope of the potential applications of such systems.
With accessibility to business users, and no loss of performance, one cannot but
wonder why rules systems are not even more pervasive than they are today.
I strongly believe that the answer to that question can be found in large part in
this book: if business users are enabled to write their intent in code directly, one
cannot but worry about the quality of such programs.
For sure, all traditional software validation tools can apply: testing different
scenarios before releasing the code, making sure that all rules have been executed at
least once in the test phase, performing champion–challengercomparisons for every
new release, and so on: : :
vii

viii
Foreword
What Bruno’s book demonstrates is that the simpler structure of rules can be
exploited to perform deeper static validations of their coherence and detect errors
that a traditional software validation system could not detect.
This is the work that Bruno has been leading since 2002, with great results. Some
of the results are now embedded in IBM Operational Decision Manager and enable
thousands of users to detect errors in their rules programs at a very early stage. The
reader will ﬁnd in the appendix a description of the IBM ODM veriﬁcation system
using the more generic terminology of the book.
A more abstract version of Bruno’s ﬁndings and the theory behind them can
be found in this book. I will not paraphrase Bruno’s excellent description of his
ﬂow and his ﬁndings. However, I will emphasize the complexity of what happens
behind the scenes to alert a business user of such simple errors as a rule that is never
applicable, or that two rules are conﬂicting.
Bruno’s work is a brilliant step to get us closer to pervasive rule systems.
Fast, explicit, and safe code can help many of us deal with the exponential
complexity of our future world.
Salt Lake City, UT
Pierre Haren
May 2013
ILOG CEO, IBM

Preface
The work presented in this book stems from a collaboration between ILOG and the
University of Freiburg, Germany. ILOG was a French software company, founded
in 1987 as a spin-off of INRIA, a French national research institution. ILOG quickly
became a leader in artiﬁcial intelligence software and contributed to deﬁne the
market of Business Rules Management Systems with its ﬂagship product ILOG
JRules. ILOG was acquired by IBM in 2009; IBM continues to develop and sell
ILOG’s Business Rules Management System under the name IBM Operational
Decision Manager.
In 2002, ILOG decided to investigate the ﬁeld of formal veriﬁcation of programs
and how it could give birth to useful features in its Business Rules Management
System. To this effect, a partnership was established with Prof. Podelski, then at the
Max-Planck-Institut für Informatik in Saarbrücken, and now at the Albert-Ludwigs-
Universität Freiburg. As part of this partnership, it was proposed to me to further
explore and formalize some of the scientiﬁc aspects of the project, in the form of a
Ph.D. thesis, which I defended in Freiburg in July 2012.
The content of this book originates mostly from this Ph.D. thesis. The work
in the thesis proposes an approach to the formal veriﬁcation of rule programs as
found in Business Rules Management Systems. The approach enables rule authors
and tool developers to understand, express formally, and prove properties of the
execution behavior of business rules programs. However, this work only represents
a possible starting point for the further development of scientiﬁc results, veriﬁcation
algorithms, or product features. The purpose of this book is thus to provide an
enabling framework for treating business rules as a topic of scientiﬁc investigation
in semantics and program veriﬁcation.
Acknowledgments
I carried out the research on which this book is based as a remote-working student,
ﬁrst of the Max-Planck Institut für Informatik of Saarbrücken, and then of the
Institut für Informatik of the Albert-Ludwigs-Universität in Freiburg. At the same
ix

x
Preface
time I was a software engineer at ILOG, and then at IBM after this company
acquired ILOG. My thanks go to Nitsan Seniak for proposing to me the subject
of rule program veriﬁcation within ILOG; to Hassan Aït-Kaci for establishing the
connection with Andreas Podelski; and to Andreas Podelski, my supervisor, for
suggesting that I should reify our thoughts as a Ph.D. thesis and for his support
and guidance throughout the years. It has also been an honor for me to count Prof.
Georg Lausen as the Zweitgutachter, as well as Prof. Bernhard Nebel and Prof. Peter
Thiemann as the members of my defense committee.
Achieving the present work in an industrial environment would not have been
possible without the initial agreement of Jean-François Abramatic, and overall the
creativity in management demonstrated by Nitsan Seniak and Antoine Melki. More
generally, I would like to thank the members of the “BEAR R&D Governance” team
within ILOG for their patience.
Substantial advances in this work were achieved during a 6-month period spent
in the Modélisation et Vériﬁcation team of the LIAFA laboratory of Université Paris
Diderot. I am most grateful to Ahmed Bouajjani for welcoming me. This stay was
a major step for me, thanks to the friendly atmosphere and stimulating discussions.
My thoughts go to Mihaela Sighireanu, Tayssir Touili, Cezara Dr˘agoi, Constantin
Enea, Mathilde Bouvel, and Ahmed Rezine, as well as the whole “Vérif” team.
Within ILOG I have also beneﬁted from enriching conversations and exchanges.
I was nurtured by the RVS project, which included Hassan Aït-Kaci, Ulrich Junker,
Michel Leconte, and Andreas Podelski; by the proofreading and most relevant
comments of Hassan, Michel, Philippe Bonnard, and Hélène Kencker; and by
fruitful discussions with Hugues Citeau, Amina Chniti, Aurélie Baton, Marie
Girard, and Philippe Laborie. Very special thanks are deserved by Michel for his
continuous support, sustained stimulation, and for the demand for accuracy inherited
from my father.
During the long process that my Ph.D. thesis has represented for me, the right
words were found on several occasions by Ulrich Junker and Claire David to help
me ﬁnd the required energy. Turning the thesis into a book was possible thanks
to Andreas Podelski, again, as well as Ronan Nugent and the staff from Springer-
Verlag. Special thanks go to Pierre Haren, who did not hesitate before agreeing to
write the Foreword.
Last, but far from least, I am specially grateful to my wife and children for their
support and their care.
Paris, France
Bruno Berstel-Da Silva
January 2013

Contents
Part I
Context
1
Introduction .................................................................
3
1.1
An Example of a Veriﬁcation Problem ..............................
3
1.2
Business Rules Management Systems ..............................
6
1.2.1
From Business Policies to Business Rules ................
6
1.2.2
A Brief Genealogy of Business Rules
Management Systems ......................................
7
1.2.3
Industrial Context...........................................
9
1.3
Motivation ............................................................
10
1.4
Summary of Contribution ............................................
12
1.5
Structure of This Book ...............................................
14
References....................................................................
15
2
Related Work ...............................................................
19
2.1
Rule-Based Paradigms: Model vs. State ............................
19
2.1.1
Model-Oriented Rules ......................................
20
2.1.2
State-Oriented Rules........................................
20
2.1.3
Combining the Two Approaches...........................
21
2.2
Formalization and Veriﬁcation of Rule Programs ..................
22
2.2.1
Formalization ...............................................
22
2.2.2
Veriﬁcation of Model-Oriented Rule Programs ...........
23
2.2.3
Veriﬁcation of State-Oriented Rule Programs.............
24
2.3
Veriﬁcation of Pointer and Concurrent Programs...................
25
References....................................................................
26
Part II
Rule Programs
3
Syntax of Rules and Rule Programs ......................................
33
3.1
Signature..............................................................
33
3.2
Symbols...............................................................
34
xi

xii
Contents
3.3
Expressions and Formulas ...........................................
35
3.3.1
Parameterized Languages of Expressions
and Formulas................................................
35
3.3.2
Well-Typed Expressions and Formulas ....................
37
3.3.3
Formulas Are Flat ..........................................
38
3.3.4
Theory Used in Examples ..................................
38
3.4
Assignment ...........................................................
39
3.5
Rules ..................................................................
40
3.5.1
Rule Variables ..............................................
40
3.5.2
Rule Guard ..................................................
41
3.5.3
Rule Action .................................................
42
3.6
Rule Programs ........................................................
42
References....................................................................
43
4
States and State Assertions ................................................
45
4.1
States Are First-Order Logic Structures.............................
46
4.1.1
Domain ......................................................
46
4.1.2
Variable Valuations .........................................
47
4.1.3
Interpretation of Expressions...............................
47
4.1.4
Interpretation of Formulas .................................
49
4.1.5
States ........................................................
52
4.2
State Assertions ......................................................
53
4.2.1
Assertions ...................................................
53
4.2.2
Global Assertions...........................................
53
4.2.3
Assertions Focused on a Rule ..............................
54
4.3
Transition Assertions.................................................
54
4.3.1
Forward Transition Assertions .............................
54
4.3.2
Backward Transition Assertions ...........................
56
4.3.3
Global Transition Assertions ...............................
56
4.4
Semantics of Assignment ............................................
57
4.4.1
Update of an Attribute......................................
57
4.4.2
Executing an Assignment ..................................
58
4.4.3
Assignment as a Relation Between States.................
59
4.5
Rule Guard and Action...............................................
59
4.5.1
Rule Guard ..................................................
59
4.5.2
Rule Action .................................................
59
References....................................................................
60
5
Operational Semantics of Rule Programs ...............................
63
5.1
Rule Program Execution, Informally ................................
63
5.2
Working Memory ....................................................
67
5.2.1
Type-System Compliant States ............................
67
5.2.2
Objects as Instances of Types ..............................
68
5.2.3
Preservation Properties .....................................
69
5.3
Rule Execution .......................................................
71
5.3.1
Rule Instance................................................
71

Contents
xiii
5.3.2
Applicability of a Rule Instance ...........................
71
5.3.3
Application of a Rule Instance .............................
72
5.3.4
Execution of a Rule Instance...............................
73
5.3.5
Executions of a Rule........................................
74
5.4
Rule Program Execution .............................................
76
5.4.1
Conﬁgurations ..............................................
76
5.4.2
Initial Conﬁguration ........................................
76
5.4.3
Transition Between Conﬁgurations ........................
77
5.4.4
Executions of a Rule Program .............................
78
5.5
Selection Strategies ..................................................
81
5.6
Eligibility Strategies..................................................
82
5.6.1
Identity Eligibility Strategy ................................
83
5.6.2
Refraction Eligibility Strategy .............................
84
5.6.3
Sequential Execution Strategy .............................
86
5.6.4
One-Shot Eligibility Strategy ..............................
87
References....................................................................
89
Part III
A Hoare Logic for Rule Programs
6
Correctness of Rule Programs ............................................
93
6.1
Preliminaries..........................................................
93
6.1.1
Fixing the Execution Strategy..............................
93
6.1.2
Correctness Formulas, Proofs, Proof Systems ............
94
6.2
Correctness Formula for a Single Rule..............................
95
6.3
Rules Compared to Conditional Statements ........................
98
6.3.1
Loop-Free Programs........................................
98
6.3.2
Rules vs. Conditional Statements .......................... 100
6.4
Correctness Formula for a Rule Program ........................... 102
6.4.1
Syntax and Semantics ...................................... 102
6.4.2
From Rules to Rule Programs.............................. 104
References.................................................................... 106
7
Correctness of Programs: A Comparison................................ 107
7.1
Correctness of Loop-Free Parallel Programs ....................... 107
7.1.1
Loop-Free Parallel Programs............................... 108
7.1.2
Loop-Free Parallel Program Derived
from a Rule Program ....................................... 110
7.1.3
Rule Programs vs. Loop-Free Parallel Programs ......... 112
7.2
Correctness of Parallel Programs .................................... 113
7.2.1
Ghost Variables ............................................. 113
7.2.2
while Programs ........................................... 115
7.2.3
Parallel Programs ........................................... 116
7.2.4
Parallel Program Derived from a Rule Program .......... 116
7.2.5
Rule Programs vs. Parallel Programs ...................... 120

xiv
Contents
7.3
Correctness of Nondeterministic Programs ......................... 122
7.3.1
Nondeterministic Programs ................................ 123
7.3.2
Nondeterministic Program Derived
from a Rule Program ....................................... 125
References.................................................................... 127
Part IV
Proof Rules for Rule Programs
8
Main Steps in Rule Program Veriﬁcation ................................ 131
8.1
Interference Cases in Rule Programs................................ 132
8.1.1
Cross-Rule Interference .................................... 132
8.1.2
Interference Due to Aliasing ............................... 133
8.2
Unary Rules .......................................................... 135
8.3
A First Proof Rule .................................................... 136
8.4
Usage ................................................................. 141
8.4.1
Use the Proof Rule Bottom-Up ............................ 141
8.4.2
What to Look for ........................................... 142
8.4.3
Application of the Veriﬁcation Method.................... 143
8.5
Incompleteness ....................................................... 145
References.................................................................... 148
9
A Veriﬁcation Method for Rule Programs ............................... 149
9.1
Taking Eligibility into Account...................................... 149
9.1.1
Eligibility Ghost Variables ................................. 149
9.1.2
Eligibility-Aware Assertions ............................... 151
9.1.3
Eligibility-Aware Execution................................ 152
9.1.4
Eligibility-Aware Correctness Formulas................... 156
9.2
Interference Freedom ................................................ 158
9.2.1
Cross-Rule Interference .................................... 158
9.2.2
Interference Due to Aliasing ............................... 159
9.3
General Proof Rule ................................................... 160
9.4
Relative Completeness ............................................... 165
9.5
Application of the Veriﬁcation Method ............................. 173
9.5.1
Approach .................................................... 173
9.5.2
Example ..................................................... 175
References.................................................................... 183
10
Specialized Proof Rules .................................................... 185
10.1
Eligibility-Aware Unary Rules ...................................... 185
10.1.1
Proof Rule................................................... 186
10.1.2
Example ..................................................... 189
10.2
Aliasing-Free n-ary Rule Programs ................................. 194
10.3
Disjointness in Rule Programs....................................... 196
10.3.1
Disjoint Unary Rules ....................................... 196
10.3.2
Disjoint Rule Programs .................................... 200
References.................................................................... 201

Contents
xv
11
Conclusion................................................................... 203
11.1
Modeling an Industrial Product...................................... 204
11.2
Local vs. Global: What Is a State? .................................. 204
11.3
Are Rule Programs Magical? ........................................ 205
11.4
From Local to Global ................................................ 206
11.5
Possible Directions of Extension .................................... 207
11.5.1
Propose an Algorithm ...................................... 207
11.5.2
Study More General Rule Programs ....................... 207
11.5.3
Study Other Properties ..................................... 208
11.5.4
Leverage Program Analysis and Veriﬁcation
Techniques .................................................. 209
References.................................................................... 209
A
Veriﬁcation in an Industrial Business Rules Management System.... 211
A.1
Preliminaries.......................................................... 211
A.1.1
Rule Static Analysis Features .............................. 211
A.1.2
Notations .................................................... 212
A.2
Rule Applicability .................................................... 214
A.2.1
Rule May Apply When... ................................. 214
A.2.2
Rule Is Never Applicable................................... 216
A.3
Impact Analysis ...................................................... 216
A.3.1
Rule May Lead to a State Where... ....................... 217
A.3.2
Rule May Enable... ........................................ 218
A.3.3
Rule May Become Applicable When... .................. 220
A.4
Redundancy........................................................... 221
A.4.1
Equivalent Rules ............................................ 221
A.4.2
Redundant Rules............................................ 221
A.5
Conﬂuence and Completeness ....................................... 222
A.5.1
Conﬂicting Rules ........................................... 222
A.5.2
Completeness Analysis..................................... 224
A.6
Safety ................................................................. 225
A.6.1
Rule May Have an Unsafe Execution ..................... 225
A.7
Discussion ............................................................ 226
References.................................................................... 227
List of Proof Rules ............................................................... 229
Index ............................................................................... 231


List of Figures
Fig. 1.1
Discount campaign by Vision Express in India.....................
4
Fig. 1.2
A business rule written with IBM Operational Decision
Manager ..............................................................
11
Fig. 3.1
Grammar — Expressions and formulas .............................
36
Fig. 3.2
Grammar — Expressions and formulas on numbers
and symbolic values (extension to Fig. 3.1).........................
39
Fig. 3.3
Grammar — Assignment ............................................
40
Fig. 5.1
Execution of a rule program by a rule engine.......................
65
Fig. 5.2
Automaton — Identity eligibility strategy .........................
83
Fig. 5.3
Automaton — Refraction eligibility strategy ......................
85
Fig. 5.4
Automaton — Sequential eligibility strategy ......................
88
Fig. 5.5
Automaton — One-shot eligibility strategy ........................
88
Fig. 6.1
Grammar — Loop-free programs ...................................
99
Fig. 7.1
Grammar — Parallel programs with loop-free processes .......... 108
Fig. 7.2
Grammar — Expressions and assignment with ghost variables ... 114
Fig. 7.3
Grammar — while programs ...................................... 115
Fig. 7.4
Grammar — Parallel programs composed of while programs ... 116
Fig. 7.5
Grammar — Nondeterministic programs ........................... 123
Fig. 8.1
Example — Bonus depending on age ............................... 142
Fig. 10.1
A decision table and its implementation as a rule program ........ 201
xvii

Part I
Context

Chapter 1
Introduction
Our focus in this book is on business rules programs, that is, rule programs
as handled in Business Rules Management Systems. We deﬁne Business Rules
Management Systems (BRMS) in this chapter, and we position them among other
rule-based paradigms in the next one.
The conceptual contribution of this book is to present the foundation for treating
business rules as a topic of scientiﬁc investigation in semantics and program
veriﬁcation.
The technical contribution of the book is to present an approach to the formal
veriﬁcation of business rules programs. We propose a veriﬁcation method for
proving correctness properties for a business rules program in a compositional way.
Compositionality means that the proof of a correctness property for a program is
built up from correctness properties for the individual rules. With our approach,
we aim at enabling rule authors and tool developers to understand, express formally,
and prove, properties of the execution behavior of business rules programs.
We start this chapter with an example of a veriﬁcation problem for a business
rules program that was inspired by actual discount campaigns. Then, we settle the
context and motivation of our work. Finally, we give a short description of the
subsequent chapters.
1.1
An Example of a Veriﬁcation Problem
Business rules as a programming paradigm, and Business Rules Management
Systems as an industrial product, are used in numerous and varied areas—as
discussed in the next section. Among these areas, the computation of discounts in
the context of promotional campaigns is a great source of examples for business
rules programs, and hence for the veriﬁcation of these programs.
Some retail groups have a business model that relies heavily on such
tools as special offers, gifts, or loyalty cards. Several such companies express
B. Berstel-Da Silva, Veriﬁcation of Business Rules Programs,
DOI 10.1007/978-3-642-40038-4__1, © Springer-Verlag Berlin Heidelberg 2014
3

4
1
Introduction
Fig. 1.1 Discount campaign
by Vision Express in India
(reproduced with the
permission of Vision Express
India)
their commercial campaigns as business rules programs that are authored by
the marketing department, and pushed on a periodic basis into the cash registers for
execution.
The example in this section is based on a simple discount campaign, like the ones
that are regularly launched by optical chains. Due to the population targeted by these
companies, the promotional rules are often based on the age of the customers, and
provide convenient examples of simple rule programs. Figure 1.1 shows an Indian
ad, where the discount granted to customers is directly linked to their ages.
An Example Rule Program
Consider the promotional offer advertised in Fig. 1.1. This offer states that when
buying spectacles at Vision Express, you will be granted a discount on the frames,
and that this discount in percentage shall equal your age in years. If we imagine that

1.1
An Example of a Veriﬁcation Problem
5
Vision Express implements its discount campaign with a business rules program,
this program could contain a rule such as the following:
r1.p/ W : : : * p:discount :D p:age
This rule applies to a customer p, and sets his/her discount to the value of his/her
age, provided some conditions (not stated here) are met.
It is well known however that a commercial policy is not fully deﬁned by the ads
that promote it. There is always small print, or references to terms and conditions.
Their purpose is to complete the deﬁnition of the offer, and provide a safeguard for
the vendors. Each campaign has its speciﬁc safeguard rules, however a reasonable
one could be that it should never result in the discount exceeding the price of
the product. In other words, discounts cannot exceed 100 %. Such a rule can be
implemented as follows:
r2.p/ W p:discount > 100 * p:discount :D 100
With the two rules above, we have a small program R D fr1; r2g that implements
a discount campaign, based on the customer age, and that makes an effort to avoid
granting discounts higher than 100 %. However, this effort is not a guarantee:
it would be better if we could have a formal proof that, when executed from
some reasonable initial state, the rule program R will always end up in a state
where no discount higher than 100 % has been granted. Using the well-known
Hoare triple formalism (otherwise introduced in Chap. 6), this can be expressed as
f: : :g R f8p .p:discount  100/g.
Challenges
Let us consider the rule program R D fr1; r2g drafted above and recapped below:
r1.p/ W p:age  18 * p:discount :D p:age
r2.p/ W p:discount > 100 * p:discount :D 100
Let us also consider the following correctness assertion, which expresses the desired
behavior of R. Namely, when executed from a state where all customers have a zero
discount, it terminates in a state where all discounts are less than or equal to 100.
f8p .p:discount D 0/g R f8p .p:discount  100/g
(1.1)
The purpose of formal veriﬁcation is to build a formal proof of a correctness
property such as (1.1), based on the execution semantics of the rule program R, and
using proof rules that have been shown to be theoretically sound.

6
1
Introduction
At ﬁrst sight, it may seem obvious that the rule program R D fr1; r2g has the
expected behavior expressed by (1.1). Indeed, consider a customer aged 105: rule
r1 may well grant a discount of 105 %, but this discount will be limited to 100 %
by rule r2. However, this intuitive reasoning makes the implicit assumption that
the execution of R ends here. Yet, after applying r1 and then r2, the customer is
still aged 105, which means that rule r1 is still applicable, and hence could set the
discount to 105 % again.
Our intuition considers here that, once a rule has been executed, it would take
more that the mere fact that it is applicable for it to be executed again. In order to
provide a formal proof of a correctness property, such an intuition of the semantics
of a rule program has to be formally described. Furthermore, several execution
semantics exist in current Business Rules Management Systems. This is the subject
of Part II.
Another challenge in the construction of a proof comes from the asymmetry
in the effects of a single rule and of a whole rule program. The local behavior
of a single rule involves only a object on which the rule is applied, whereas the
global behavior of the rule program involves the whole, ﬁnite but unbounded,
set of objects on which the program is run. This asymmetry requires a deﬁnition
of correctness properties satisﬁed by individual rules, as well as a deﬁnition of
correctness properties expected from rule programs. This is the subject of Part III.
Then, the gap between local, rule-scoped properties and global, program-scoped
ones has to be crossed. This is the subject of Part IV, which presents several proof
rules to derive a correctness property for a rule program from correctness properties
for its individual rules. This part also shows the soundness of the proof rules and,
when applicable, their completeness.
In particular, proof rule (PR3) presented in Chap. 10 makes it possible to prove
the correctness property expressed by (1.1).
1.2
Business Rules Management Systems
1.2.1
From Business Policies to Business Rules
The business policies that describe how a company, small or large, should be
run in order to execute its mission take various forms, from informal manuals to
methodologies, to standards. For a few decades now, they have often been automated
as software to be executed by a computer. Software business applications in such
areas as industry, ﬁnance, insurance, or administration implement the policies of an
enterprise or organization for such tasks as loan approval, pricing, claim processing,
and many more.
Change in general, and in business policies in particular, is inevitable. It has
become increasingly frequent due the recent trends in regulations and business.
Organizations have to conform with more and more regulations, such as new

1.2
Business Rules Management Systems
7
accounting standards, laws addressing environmental concerns, or related to global
or homeland security, etc. In addition, competition and market demand motivate
changes in the business policies of a company, by introducing new pricing plans,
implementing new production schemes, etc.
Due to the stress put by these changes on software systems and I.T. departments,
the traditional, monolithic implementation of a business application, in which
business policies are hard-coded in databases or in COBOL, is no longer able to
deliver the agility required. This is where Business Rules Management Systems
come into play.
To cope with frequent change and achieve the desired agility, the part of
the application that implements the business policies is logically externalized as
business rules. That is, it is reimplemented (possibly semi-automatically from its
original implementation) as an external component, by means of constructs such as
condition-action rules or decision tables. The business application is equipped with
a rule engine responsible for executing this new component. Also, tools are provided
for business users to manage the business rules, such as versioning or collaborative
working features. Additional tools allow the I.T. department to devise semi-natural,
domain-speciﬁc rule languages, so that business experts with no advanced computer
knowledge can read and even write business rules.
A Business Rules Management System (BRMS) is a software system that gathers
these authoring, management, and execution tools. Using business rules and a
BRMS to implement the business logic of an application is a recognized way
to achieve greater agility [23]: the business policies are no longer hard-coded in
the application, and business experts, who own the knowledge about the business
policies, can author business rules directly.
1.2.2
A Brief Genealogy of Business Rules Management
Systems
Business Rules Management Systems, or BRMS, can be seen as the convergence of
production systems and business rules.
Production systems were originally proposed by logician Emil Post in 1943 [40]
in his work on decidability. They were brought to computer science by Robert
Floyd in 1961 [9,22] as a way to describe translation from one language to another,
a seminal step in compiler construction. They really became a reasoning tool, as well
as a programming one, in the work of Allen Newell on problem solving [25]. Newell
was designing heuristics inspired by human reasoning. In these heuristics, operators
were applied to a state to evolve it towards a goal. He resorted to production
systems when he equipped each operator with a description of the conditions under
which the operator could be applied, actually turning the operators into if-then
statements [28].

8
1
Introduction
Such if-then statements, initially named productions and later rules, became
a ubiquitous tool in artiﬁcial intelligence and beyond. Section 2.1 compares rules in
BRMS (and hence production rules) with some other occurrences of the concept of
rule in computer science.
A production system is thus composed of: a set of production rules that describes
the operations at hand and the conditions under which they can be applied; a working
memory that models the state operated upon by the production rules; and an
inference engine responsible for choosing production rules and applying them to
the working memory. Production systems, and more generally expert systems, gave
birth to numerous implementations, the seminal one being OPS5 [5, 10], based on
the Rete algorithm invented by Charles Forgy [11]. The other algorithm of great
historical signiﬁcance is TREAT [24]; the Gator algorithm [15] is derived from both
of them. The key ideas in the Rete algorithm are to compile the production rules
into a network where the predicates shared by the rules are not duplicated, and to
use this network to maintain incremental information on the applicability of each
rule on the working memory. This algorithm and its variants are still in use in many
production rule engines.
Recently, the W3C has issued the RIF-PRD recommendation [34]. This recom-
mendation is part of the Rule Interchange Format effort. It proposes a standard for
a Production Rule Dialect, with an abstract syntax and an operational semantics.
Although the door is left open for alternatives, the recommendation describes the
semantics of Rete only.
The other parent of BRMS, business rules, appeared in the 1970s as a tool to
model the business policies introduced in the previous section. Although Ronald
Ross claims to be “the father of business rules”, a number of other authors
contributed to the deﬁnition and expanded use of business rules as an approach
to representing business knowledge [13, 14, 32]. Methodologies have been deﬁned
and a consortium, the Business Rules Group, has been created [38].
Users of business rules, seeing them as a knowledge representation tool, are
more interested in the elicitation and harvesting of business expertise than in the
automation of their execution. Software tools for business rules aim at assisting
business analysts and knowledge engineers in deﬁning glossaries of business terms,
authoring business rules, and checking the consistency of rule bases. A connection
with the semantic web has been established through the deﬁnition of standards such
as the Object Management Group’s one on Semantics of Business Vocabulary and
Business Rules (SBVR) [39].
Business Rules Management Systems have inherited from the business rules
community the objective of remaining close to the business expert. The vocabulary
deﬁnition and authoring tools found in BRMS reﬂect this concern. From production
systems they have inherited the operational orientation towards execution of the
rules. The execution components of BRMS provide this aspect by being integrated
in applications, in which production rules implement the business logic.

1.2
Business Rules Management Systems
9
1.2.3
Industrial Context
The commercial successors of OPS5 as production system implementations, such
as CLIPS [6], Jess [12], Rules [2], or Nexpert [1], were designed for the implemen-
tation of complex algorithms using production rules. Typical examples are found
in telecommunications, with alarm correlation applications [16], where signals
from physical sources are entered in working memory, and higher-level events are
synthesized and correlated by the rules, to eventually issue alarms to the operator.
In such rule programs, executions often include the chaining of several rules, and
the system state permanently evolves as new signals are inserted.
However, with the increasing demand for agile software systems to cope with
frequent changes in business policies, production systems evolved to meet business
rules and were renamed Business Rules Engines [37]. As part of this evolution,
the kind of rule programs that were written changed as well. The number of
rules in a rule program increased, especially since they often resulted from the
automated translation of existing databases or COBOL components, but their
complexity decreased. Executions now more rarely include complex inferences and
the combination of numerous rules. They rather involve a handful of objects and act
as a procedure call, than perform an endless loop on a ﬂow of data.
This evolution motivated the introduction in Business Rules Engines of alterna-
tives to the historical Rete-like algorithms, such as the sequential execution mode
described in Sect. 5.6.3 [7,21,31]. It also fostered the development of authoring and
management tools, including web-based tools directly targeted at the business user.
All in all, this evolution deﬁned a new family of industrial products that took the
name of Business Rules Management Systems [23,33].
Analysts have valued the BRMS market in 2008 at $ 285M, with an estimated
10 % annual growth until 2013 [18]. Both the size of the market and the added value
of BRMS have led large software publishers to acquire the leading BRMS vendors
or products. Nowadays, the main players in the BRMS arena are:
•
IBM [19] with the IBM Operational Decision Manager line of products, after the
acquisition of ILOG;
•
FICO [8] with the FICOTM Blaze Advisor R product, after the acquisition of
Blaze, formerly Nexpert [1];
•
Oracle [26] with the Oracle Business Rules product, after the acquisition of
Haley;
•
Red Hat [30] with the JBoss Enterprise BRMS product, repackaged from the
Drools open-source project;
•
SAP [35] with the NetWeaver Business Rules Management product, after the
acquisition of Yasu;
•
Progress Software [29] with the Corticon Business Rule Management System
product, after the acquisition of Corticon.

10
1
Introduction
With the incorporation of BRMS into broader catalogues of software products,
a trend has developed, in addition to the market for a pure BRMS offer, to integrate
them with Business Process Management or Predictive Analytics software.
1.3
Motivation
As explained in the previous section, Business Rules Management Systems are
increasingly used in industrial applications to implement fast-changing, mission-
critical parts of their application tier—the so-called business logic. A business rules
program consists of a set of mutually independent rules, that is, conditional update
statements arranged in a modular, case-by-case approach. A business rules program
is declarative in that it does not specify the control ﬂow; the set of rules are executed
on a set of objects, exhaustively for each rule and each object, in any order.
In spite of the crucial role of business rules programs, until now the emphasis
in research on rule programs has been on optimizing their execution by a BRMS.
A variety of compilation and execution schemes have been developed, including the
well-known Rete algorithm. The veriﬁcation of business rules programs has been
neglected as a topic of scientiﬁc research. This may be due to their categorization
as information systems, that is, rather as a business area than as computer science.
The need for veriﬁcation tools in BRMS has only recently been expressed [17].
It is, however, no less obvious for business rules programs than it is for safety-
critical systems, even though the risks at stake are economic and usually not life-
threatening. Fulﬁlling this need requires us to describe the correctness of a rule
program in BRMS, and hence to introduce a formalization of these programs.
The Need for Formalization
Business Rules Management Systems are industrial products: as such they are
ultimately deﬁned by their implementations. Yet, of course, reasoning in a rigorous
manner about a business rules program, for example to verify its correctness,
requires a formal description of the language and of the execution engine. More
generally, the task of providing a formal basis for veriﬁcation features in a BRMS
is a cornerstone to an agreement on their deﬁnitions, for example between product
marketing and development teams.
Proposing a formalism for an industrial product is a trade-off between the
simpliﬁcations required to achieve a practical model, and keeping the substance
of the modeled product. In particular, such a formalism must take into account the
fact that rules in a BRMS are most of the time based on an object-oriented model,
deﬁned by the application in which they are integrated. For example, it should be
able to handle a rule such as the one given in Fig. 1.2, which was written with IBM
Operational Decision Manager.

1.3
Motivation
11
Fig. 1.2 A business rule written with IBM Operational Decision Manager
In Part II, we present a formal framework based on ﬁrst-order logic structures.
Although not exotic, this framework meets the above requirements. In addition,
it supports the description of the recently introduced alternatives to the Rete
algorithm.
As a result, our formalization of rule programs makes it possible to specify
the expected behavior of a business rules program, and to verify (that is, to prove
formally) that the executions of the program will comply with this speciﬁcation.
This goes further than most veriﬁcation features of current BRMS products, which
either are based only on a syntactic analysis of the rules, or are limited to the
execution of individual rules and do not consider the full execution of a rule
program.
Note also that apart from enabling formal veriﬁcation, being able to express
speciﬁcations can be useful in other cases. A well-known example is testing, that
is, running the program on some input data and checking that the actual output
conforms to the one predicted by the speciﬁcation. In addition to indicating the
outputs expected, a speciﬁcation can be used to assess the comprehensiveness of the
input data sets used for tests with respect to the data space that the program might
receive as input. The speciﬁcation can also be used to enhance this by generating
missing test cases.
Other usages of speciﬁcations include run-time testing, that is, instrumenting
the executable code to trigger an exception when a speciﬁcation is violated; and
historical testing, that is, comparing recorded executions of the program with
speciﬁcations, for example to detect changes in the program behavior over time or
to assess the compliance of the program in its current implementation with respect
to a proposed evolution of its speciﬁcation.
The Need for Veriﬁcation
The need for veriﬁcation of programs developed with a Business Rules Management
System (BRMS) comes both from reasons that apply to all software systems, and
from reasons more speciﬁc to BRMS themselves.

12
1
Introduction
As highlighted earlier in this chapter, one major role of a BRMS in industrial
applications is to provide tools for the authoring and execution of programs written
as rules. In other words, it provides a programming language and its interpreter.
As such, the question of the correctness of a program with respect to a speciﬁcation
is natural (or should be). This concern is reinforced by two factors.
Firstly, the functions implemented with a BRMS are often critical functions for
the company. These can range from stock trading to loan approval, to produc-
tion control, etc. A failure in a business-critical application could have dramatic
consequences.
Secondly, these applications represent large software projects, both by the size
of the teams involved in their development and maintenance, and by the number
of rules that a BRMS-based application often contains. Indeed, it is common to
ﬁnd applications involving thousands of rules [20, 36]. As mentioned previously,
this often comes from the fact that a BRMS-based application is the result of
the externalization of a component previously implemented in COBOL or with
databases. It is usually considered simpler and safer to mechanically translate the
policies encoded in database table rows into as many rules, than to reengineer the
implementation into a more compact but more subtle set of rules.
As a consequence, the development and maintenance of a BRMS-based appli-
cation will beneﬁt from tools dedicated to veriﬁcation, as for any software project
with a large code base.
In addition to the above, organizations have felt the need to monitor the agility
that they have gained from the use of a Business Rules Management System. Indeed
a BRMS gives business users access to the rules. This feature is motivated by
the idea that business users, as domain experts, have a good knowledge of what
the business rules should be. It increases the agility of the overall application by
shortening its production cycle, thus allowing the organization as a whole to adapt
to change faster.
Yet this increased ﬂexibility gained by giving programming power to users
with no advanced qualiﬁcation in computer programming demands some control.
In early BRMS products, the lack of veriﬁcation features has been pointed out as
a shortcoming [17]. As an answer the initial argument of agility has evolved into
that of controlled agility, where program analysis techniques are applied to rule
programs to try to raise alarms when relevant. A sampling of such rule analysis
features contributing to controlled agility is given in App. A.
1.4
Summary of Contribution
The contribution of the work in this book consists in a formal, logic-based
description of the behavior of rule programs in Business Rules Management
Systems (BRMS) and in the introduction of a Hoare logic and a veriﬁcation
method for these rule programs. With this, we provide tools to express and verify

1.4
Summary of Contribution
13
global correctness properties on rule programs, based on local knowledge about the
individual rules in the program.
As a ﬁrst step, we present a formal characterization of the execution behavior
of business rules programs. The task of formally characterizing the execution
behavior of business rules programs faces several issues. An immediate issue is the
diversity of compilation and execution schemes used in existing BRMS. Previous
descriptions of business rules execution depended on the intrinsics of each speciﬁc
compilation scheme. We have designed a general, yet formally simple, framework
that enables us to describe the execution behavior of business rules programs and
to single out the main differences between the various execution schemes. The
formalization of the execution behavior of business rules programs allows us to
observe that the apparent simplicity of business rules is only superﬁcial. Indeed,
the interplay between executions of one or several rules on one or several, possibly
shared, objects (selected nondeterministically from a ﬁnite, but unbounded set) can
become extremely complex, even for small examples.
An execution is formally a sequence of states. To account for the unboundedness
of the set of objects in each state, we model a state as a ﬁrst-order logic structure.
We account for the diversity of execution schemes, including recent alternatives to
the Rete algorithm, by introducing concepts that allow us to distinguish between the
applicability and the eligibility of a rule.
Based on our formal framework, we introduce correctness speciﬁcations for
business rules programs. Previously, the only way to assess the correctness of a
business rules program was to examine each of its rules and its possible behaviors
when applied to various objects. The expected global effect of a program had
to be expressed in natural language, which could result in misunderstandings
between authors of programs and their users. The difﬁculty in formally deﬁning
the correctness of business rules programs stems from the gap between the local
behavior of a single application of a rule and the global effect of a whole business
rules program on a set of objects. The local behavior involves only the object on
which the rule is applied, whereas the global behavior involves the whole, ﬁnite but
unbounded, set of objects on which the program is run.
We deﬁne the meaning of a correctness formula of the form fpg R fqg where R
is a rule program, as a conservative extension of the meaning of a correctness
formula of the form fpg r fqg where r is a rule. We thus obtain correctness
speciﬁcations that follow the modular and declarative nature of a business
rules program. With correctness formulas for both rules and rule programs, we
give the BRMS user a tool for expressing knowledge about rules and speciﬁcations
of rule programs. We also deﬁne the building blocks of a compositional veriﬁcation
method for rule programs.
Finally, we propose such a compositional veriﬁcation method for rule programs.
The challenge of compositionality stems from the possibility of interference
between rule applications during the execution of a program. Proving a correctness
property of a business rules program cannot simply follow the decomposition of
the program into its syntactic constituents, i.e., the rules. Borrowing the intuition of
the Owicki-Gries method for parallel programs (see [27], but also the presentation

14
1
Introduction
of proof systems for sequential and concurrent programs in [3] by Krzysztof Apt
and Ernst-Rüdiger Olderog, and the revised version [4] by Apt, Olderog, and
Frank de Boer), we present a proof system that features an extended notion of
compositionality, suitable for business rules programs. Using our proof system, a
global correctness formula for a program can be derived from local correctness
formulas for its individual rules. We show that the proof system is sound and
relatively complete (we use relative completeness in the same sense as for Hoare
logic). We also study several particular cases of this proof rule for specialized classes
of rule programs and correctness formulas.
1.5
Structure of This Book
After the bird’s eye view of Business Rules Management Systems given in this ﬁrst
chapter, Chap. 2 relates them to other bodies of work. In that chapter, we see that rule
programs as handled by BRMS have both similarities to, and differences from, other
paradigms that use the concept of rules. From the viewpoint of their execution, and
therefore of verifying execution properties, they also share features with databases,
programs with pointers, and concurrent programs.
The subsequent eight chapters contain our contribution and are structured in
three parts. Part II (Chaps. 3–5) presents our formalization of rule programs as
handled by BRMS. Part III (Chaps. 6 and 7) deﬁnes a Hoare logic for these rule
programs. Part IV (Chaps. 8–10) proposes a compositional veriﬁcation method for
rule programs. The focus of each of these chapters is as follows.
Chapters 3 and 4 deﬁne the syntax and semantics of a prototypical rule language,
as well as assertions to express conditions on the states of systems that execute
programs written in this rule language. Such programs can handle objects, reason on
the values of their attributes, and perform updates on these attributes. The business
facet is a parameter to this language, embodied in a theory and a type system that
are considered ﬁxed orthogonally to the rule language. The theory describes the
data types (such as numbers) and the operations allowed on them; the type system
structures the objects into classes.
Chapter 5 deﬁnes the meaning of putting rules together as a rule program, and
executing a rule program on a set of objects. We describe the operational semantics
of a rule program by modeling a rule engine with an abstract machine. This abstract
machine is parameterized by execution strategies, which represent varying aspects
of the algorithms used in BRMS, either Rete or not. We give a formal description of
the main execution strategies, including the one-shot strategy. Parts III and IV study
rule programs from the viewpoint of this execution strategy, as it is a reasonable
approximation of the Rete algorithm and a good abstraction of the principal alterna-
tive to Rete, in the sense that it abstracts away its implementation-dependentaspects.
Chapter 6 studies the semantics of rule programs from the viewpoint of the
relation between their inputs and their outputs, represented by their initial and ﬁnal
states. To this end, it deﬁnes correctness formulas in the classical form of so-called

References
15
Hoare triples fpg r fqg, where r is a rule. It then deﬁnes correctness formulas of the
same form fpg R fqg, where R is now a rule program.
Chapter 7 builds on the deﬁnition of correctness formulas for rule programs,
to compare rule programs with parallel and then nondeterministic programs. This
comparison investigates whether a parallel program, and then a nondeterministic
one, can be found for any rule program, so that it has the same input/output
behavior. We will see that in general, one cannot ﬁnd a parallel program with
the same input/output behavior as a rule program. This result motivates the search
for a veriﬁcation method to derive a correctness formula for a rule program from
individual correctness formulas for its rules.
Chapters 8–10 propose several proof rules achieving the above, under various
conditions. In Chap. 8 we ﬁrst introduce a simpler proof rule for a particular class
of rule programs, so as to exhibit the core mechanism at play. Then in Chap. 9
we present the general case and prove that the corresponding proof rule is sound
and relatively complete. Chapter 10 completes the presentation of proof rules with
several other particular cases that can beneﬁt from specialized proof rules.
Chapter 11 concludes with a summary of the work presented in this book. In this
last chapter, we also suggest directions for extensions of this work.
Finally, in App. A, we demonstrate the practical potential of our formal approach
in the context of an existing commercial Business Rules Management System. This
BRMS developed by IBM comes with a lightweight analysis engine. Its various
analysis and veriﬁcation features are not an application of the present work, as
they are limited to the executions of individual rules, as opposed to considering
the full execution of a rule program. However, we show that they can be given a
solid foundation thanks to the approach to the formal veriﬁcation of business rules
programs presented in this book.
References
All URLs were successfully accessed on January 22, 2013.
1. Aiken, M.W., Liu Sheng, O.R.: Nexpert object. Expert Syst. 7(1), 54–57 (1990)
2. Albert, P.: ILOG Rules, embedding rules in C++: Results and limits.
In: Proceedings of
the OOPSLA’94 Workshop on Embedded Object-Oriented Production Systems (EOOPS).
Technical Report LAFORIA 94/24, Institut Blaise Pascal, Paris (1994)
3. Apt, K.R., Olderog, E.R.: Veriﬁcation of Sequential and Concurrent Programs, 2nd edn. Texts
in Computer Science. Springer, Berlin (1997)
4. Apt, K.R., de Boer, F.S., Olderog, E.R.: Veriﬁcation of Sequential and Concurrent Programs,
3rd edn. Texts in Computer Science. Springer, Berlin (2009)
5. Brownston, L., Farrell, R., Kant, E., Martin, N.: Programming Expert Systems in OPS5:
An Introduction to Rule-Based Programming. Addison-Wesley, Boston (1985)
6. Culbert, C., Riley, G.: CLIPS Basic Programming Guide (2003)
7. Fair, Isaac, and Company: High-volume batch processing with Blaze Advisor.
Com-
puter World UK (2007). http://www.computerworlduk.com/white-paper/business-process/
5092/high-volume-batch-processing-with-blaze-advisor/

16
1
Introduction
8. FICOTM Blaze Advisor R
. http://www.ﬁco.com/en/Products/DMTools/Pages/FICO-Blaze-
Advisor-System.aspx
9. Floyd, R.W.: A descriptive language for symbol manipulation. J. ACM 8(4), 579–584 (1961)
10. Forgy, C.: OPS5 User’s manual. Tech. Rep. CMU-CS-81-135, Carnegie-Mellon University,
Pittsburgh (1981)
11. Forgy, C.: Rete: A fast algorithm for the many patterns/many objects match problem. Artif.
Intell. 19(1), 17–37 (1982)
12. Friedman-Hill, E.J.: JESS in Action. Manning Publications, New York (2003)
13. von Halle, B.: Business Rules Applied. Wiley, New York (2002)
14. von Halle, B., Goldberg, L.: The Business Rule Revolution. Happy About, Cupertino (2006)
15. Hanson, E., Hasan, M.S.: Gator: An optimized discrimination network for active database rule
condition testing. Tech. Rep. TR93-036, University of Florida (1993)
16. Hasan, M., Sugla, B., Viswanathan, R.: A conceptual framework for network management
event correlation and ﬁltering systems.
In: Sixth IFIP/IEEE International Symposium on
Integrated Network Management, pp. 233–246. Boston (1999)
17. Hendrick, S.D.: Business Rule Management Systems: Addressing Referential Rule Integrity.
IDC
(2006).
http://www.marketresearch.com/IDC-v2477/Business-Rule-Management-
Systems-Addressing-1286198/
18. Hendrick, S.D.: Worldwide Business Rules Management Systems 2009–2013
Fore-
cast. IDC (2009). http://www.biareports.com/en/Worldwide_Business_Rules_Management_
Systems_2009-2013_Forecast_A_First_Look_in_a_Difﬁcult_Economy.html
19. IBM Operational
Decision
Manager.
http://www.ibm.com/software/websphere/products/
business-rule-management
20. IBM: VISA Europe: Processing payments with unprecedented agility and reliability. http://
www.ibm.com/software/success/cssdb.nsf/CS/SSAO-8FNJEB
21. IBM: IBM Operational Decision Manager v8.0 User’s Manual (2012). http://publib.boulder.
ibm.com/infocenter/dmanager/v8r0/
22. Knuth, D.E.: Robert W. Floyd, in memoriam. SIGACT News 34(4), 3–13 (2003).
http://
courses.csail.mit.edu/6.042/spring10/ﬂoyd-eulogy-by-knuth.pdf
23. McCoy, D.W., Sinur, J.: Achieving Agility: The Agile Power of Business Rules.
Gartner
(2006). http://www.gartner.com/DisplayDocument?doc_cd=138218
24. Miranker, D.P.: TREAT: A better match algorithm for AI production systems. In: Proceedings
of the Sixth National Conference on Artiﬁcial Intelligence – Volume 1, AAAI’87, pp. 42–47.
AAAI, Seattle (1987)
25. Newell, A., Simon, H.A.: Human Problem Solving. Prentice Hall, Englewood Cliffs (1972)
26. Oracle
Business
Rules.
http://www.oracle.com/technetwork/middleware/business-rules/
overview
27. Owicki, S.S., Gries, D.: An axiomatic proof technique for parallel programs I. Acta Informatica
6, 319–340 (1976)
28. Piccinini, G.: Allen Newell. In: New Dictionary of Scientiﬁc Biography. Thomson Gale (2007).
http://www.umsl.edu/~piccininig/Newell%205.htm
29. Progress: Corticon Business Rules Management System. http://www.progress.com/corticon/
30. Red Hat: JBoss Enterprise BRMS. http://www.redhat.com/products/jbossenterprisemiddle
ware/business-rules/
31. Red Hat: JBoss Rules 5 Reference Guide (2012). https://access.redhat.com/knowledge/docs/
en-US/JBoss_Enterprise_BRMS_Platform/5/html-single/JBoss_Rules_5_Reference_Guide/
index.html#Sequential_Mode
32. Ross, R.: Principles of the Business Rules Approach. Addison-Wesley, Boston (2003)
33. Rymer, J.R., Gualtieri, M.: The Forrester WaveTM: Business Rules Platforms, Q2 2008.
Forrester Research (2008). http://www.forrester.com/The+Forrester+Wave+Business+Rules+
Platforms+Q2+2008/fulltext/-/E-RES39088
34. de Sainte Marie, C., Hallmark, G., Paschke, A.: Rule Interchange Format, Production Rule
Dialect. Recommendation, W3C (2010). http://www.w3.org/TR/rif-prd/

References
17
35. SAP NetWeaver Business Rules Management. http://www.sap.com/platform/netweaver/
components/brm/index.epx
36. Soloway, E., Bachant, J., Jensen, K.: Assessing the maintainability of XCON-in-RIME: Coping
with the problems of a VERY large rule-base. In: AAAI, pp. 824–829. Seattle (1987)
37. Taylor, J., Raden, N.: Smart (Enough) Systems: How to Deliver Competitive Advantage by
Automating the Decisions Hidden in your Business. Prentice Hall, Upper Saddle River (2007)
38. The Business Rules Group: http://www.businessrulesgroup.org
39. The Object Management Group: Semantics of Business Vocabulary and Business Rules (SBVR
1.0) (2008). http://www.omg.org/spec/SBVR/1.0/
40. Urquhart, A.: Emil Post. In: Gabbay, D.M., Woods, J. (eds.) Logic from Russell to Church.
Handbook of the History of Logic, vol. 5, pp. 617–666. North-Holland, Amsterdam (2009)

Chapter 2
Related Work
Rule programs as handled by Business Rules Management Systems (BRMS)
are the focus of this book. In the present chapter we relate these programs to
other programming paradigms, whether rule-based or not. We concentrate on the
similarities and differences that have an impact on our objective, which is to help
understand the effects, and prove correctness properties on the executions of rule
programs as handled by BRMS.
The ﬁrst section of this chapter reviews several rule-based paradigms, which
allows us to relate them more or less closely to rule programs in BRMS. Then
we discuss some formalization and veriﬁcation approaches of related rule-based
paradigms, but also of concurrent programs.
2.1
Rule-Based Paradigms: Model vs. State
Rule programs as handled by Business Rules Management Systems are by far not
the only occurrence of the concept of rules in computer science. To sort out the
numerous paradigms that give an important role to rules, we adopt a schematic
classiﬁcation between those where rules are used to model knowledge about a given
domain, and those where they are used to perform a computation. We refer to the
former as model-oriented rule-based paradigms, and to the latter as state-oriented
ones.
This classiﬁcation, which follows a similar one proposed by Victor Vianu [79],
has the advantage of concentrating on the intent behind using rules. This contrasts,
for example, with a common distinction based on whether the rules are used in
backward- or forward-chaining. In the latter classiﬁcation, the focus is on the way
in which rules are put into action: this gives little, if any, information on their actual
role.
The distinction between model- and state-oriented rule-based paradigms should
not hide the fact that the usages of rules are not clear cut. In particular, and as
B. Berstel-Da Silva, Veriﬁcation of Business Rules Programs,
DOI 10.1007/978-3-642-40038-4__2, © Springer-Verlag Berlin Heidelberg 2014
19

20
2
Related Work
suggested by their genealogy brieﬂy presented in Sect. 1.2.2, BRMS inherit from
paradigms in both categories.
We conclude this section with a brief review of some other cases where the two
categories are combined.
2.1.1
Model-Oriented Rules
In rule-based paradigms to which we refer as model-oriented, the intent is to build
a description of a given body of knowledge. Rules are used to provide parts of this
model intensionally. They are commonly gathered in rule bases, in contrast with
state-oriented paradigms which often collect them in rule programs.
Model-oriented rules are of course abundantly used in the large area of artiﬁcial
intelligence that studies knowledge representation; see for example [42] or [75] for
a survey. Deriving from this area are business rules in the sense of the description
given in Sect. 1.2.2, which are used to implement models of business policies.
As a consequence, Business Rules Management Systems naturally inherit from
these rules. This inheritance materializes primarily in the authoring components.
By authoring components, we mean the tools that provide business experts with rule
languages that are as close as possible to their domain-speciﬁc vocabulary. BRMS
will for example use standards such as the OMG one on Semantics of Business
Vocabulary and Business Rules (SBVR) [77].
Another important occurrence of model-oriented rules is to be found in deductive
databases, or deductive rules in databases [47, 50]. Here also rules are used to
provide parts of the model intensionally. Examples are rules used to enrich the data
stored in the base (for instance through recursive views), or rules used to specify
integrity constraints in a concise way.
The increasing work on the semantic web [16] in the last decade has leveraged
several concepts from artiﬁcial intelligence, with a renewed interest for ontologies.
An extensive survey of the combination of rules and ontologies in the context of the
semantic web is given in [6]. This remains an area of active research with an annual
Conference on Web Reasoning and Rule Systems [21]. As mentioned in [6, p. 20],
the kind of rules that are considered are model-oriented ones.
It is interesting to note also that the semantic web community is showing interest
[25] in the SBVR standard, which had initially been promoted by the business rules
community.
2.1.2
State-Oriented Rules
In rule-based paradigms to which we refer as state-oriented, the role of rules is not to
build a model intensionally for a body of knowledge, but rather to solve a problem.
In this, rules are used to evolve a state of the system towards a goal, by performing

2.1
Rule-Based Paradigms: Model vs. State
21
a series of computations. Particularly in this category of rule-based paradigms, both
forward- and backward-chaining approaches are represented.
Again, artiﬁcial intelligence provides several occurrences of state-oriented rules.
As mentioned in Chap. 1, production systems were introduced through the work
of Allen Newell on heuristics reproducing the human approach [53, 60]. Business
Rules Management Systems have inherited from production systems the basis for
their execution components: the engines that are in charge of selecting the rules to
apply, and actually perform their actions on the current state of the system.
The most obvious contribution is the Rete algorithm [29], the variants and
evolutions of which are implemented in the rule engines of BRMS. This inﬂuence
of production systems on BRMS is the one that is the most relevant to us, since
we are interested in the execution of rule programs as handled by Business Rules
Management Systems. Despite the seminal role of Rete, alternatives to Rete-based
execution have emerged in the last decade [27, 37, 65]. However, in Chap. 5 we
exhibit a structure in the execution of rule programs that is common to all execution
algorithms. We achieve this by dissociating applicability and eligibility of rules, and
exploit it to deﬁne a semantics of rule programs formally.
Databases, which as just seen use model-oriented rules through deductive rules,
also use state-oriented rules in active databases [80]. While the rules in production
systems are also called condition-action rules, the active rules in databases are often
called event-condition-action rules, because they react to events that are internal
or external to the database. The actions taken by these rules range from checking
integrity constraints to updating data in the base, to triggering broader operations
outside of the database. Even when the purpose of these rules is to ensure the
integrity of the database, the fact that they do so by applying updates to the base
gives them a state orientation.
The use of event-condition-action rules, not in the context of databases but in that
of the semantic web, has been investigated in [15,18].
2.1.3
Combining the Two Approaches
Although the classiﬁcation between model- and state-oriented rules reﬂects an
actual difference in the intent for using rules, there are several cases where a
combination of the two approaches has been investigated.
One of them is automated planning and scheduling, another occurrence of rules in
artiﬁcial intelligence. In this ﬁeld, rules can be used to infer additional information
on a given state from domain knowledge; this usage of rules is called axiomatic
inference and is rather model-oriented. Rules are also extensively used in the state
space approach to planning, to evolve the state of the system towards a goal, that
is, with a state orientation. See [33] for an overview of automated planning and
scheduling.
The deductive and active rules in databases give another illustration of the
use of both approaches in a common area, with deductive rules oriented towards

22
2
Related Work
knowledge modeling and active rules oriented towards computation. In [47] their
seemingly diverging capabilities are integrated by the introduction of the Statelog
language, which Bertram Ludäscher deﬁnes as a state-oriented extension of Datalog.
This goes further than the work of Vianu, who provides alternate semantics for the
same syntax in [79]. Indeed, Ludäscher simultaneously puts into play features of
both kinds of rules to build Statelog.
The FLORID engine [30] was developed to evaluate rules in deductive databases,
thus in a model-oriented usage of rules. In [68] the use of the Rete algorithm, which
was introduced for the implementation of production rule systems, is investigated
as an evaluation technique.
Another example of combining the two approaches is given by the work on
performing rule-based computations on the semantic web, that is, on universes
described by ontologies. This usage of state-oriented rules on the semantic web
is addressed in [6], and is one of the subjects of study for the REWERSE network
[66]. The speciﬁc question of how Business Rules Management Systems could be
enabled to handle data modeled by such intensional mechanisms as ontologies is
one objective of the ONTORULE project [58], addressed for example in [22,35].
2.2
Formalization and Veriﬁcation of Rule Programs
2.2.1
Formalization
Business Rules Management Systems inherit from both model-oriented and state-
oriented rules, although the inﬂuence of each category expresses itself in distinct
components. On the one hand, the model orientation has an inﬂuence in the rule
authoring components, through the design and implementation of vocabularies
targeted at business experts. On the other hand, the state orientation shows in
execution components, through the semantics given to rules. We can therefore
expect that the formalization of rule programs as handled by BRMS will show the
inﬂuence of formalisms adopted for both orientations of rule-based paradigms.
Databases also make extensive use of both kinds of rules with deductive
and active rules being the respective representatives of model- and state-oriented
rules. The Datalog language [31, 50, 78] is at the heart of deductive and active
databases, and formalizations of numerous variants of this language have been
proposed [1, 2, 50, 79]. These formalisms, which provide several semantics for
Datalog, are all logic-based.
Among them, F-logic [39] has the peculiarity of having originally been devel-
oped for deductive databases, and of being used more recently in the context of the
semantic web as a formalism for ontologies [5], together with description logic [11]
and order-sorted features logic [3, 4]. There is no deﬁnitive formalism for rules in
the context of the semantic web. The choice depends primarily on the formalism

2.2
Formalization and Veriﬁcation of Rule Programs
23
adopted for ontologies, and on whether the rules are used in a model orientation to
provide parts of the knowledge, or in a state orientation to perform computations.
The principal point of effort when formalizing state-oriented rules, such as active
rules in databases or production rules, is the fact that they perform updates on states.
To this end, [20] uses -calculus to represent propositional production systems,
and ﬁxed-point logic to represent production systems with variables. This approach
leads to using ﬁrst-order logic structures as we do. A formalization of production
systems with situation calculus is given by Baral and Lobo [13], while Baralis and
Widom [14] represents active rules in databases by means of an extended relational
algebra.
The formalizations proposed by François Fages and Rémi Lissajoux in [26],
then by Claude Kirchner, Pierre-Étienne Moreau et al. in [24], are also based on
ﬁrst-order logic. They are restricted to the Rete algorithm. Furthermore, the former
explicitly discards the control strategy from its scope, and the latter gives no detail
of how it affects the execution of a rule program. On the other hand, the RIF-PRD
recommendation by the W3C [67] does provide a rigorous description of the control
strategy of the Rete algorithm and its inﬂuence on rule program execution.
Our formalization goes one step further towards the veriﬁcation of properties
of rule programs as handled by BRMS, in particular by considering the execution
strategy as a parameter (Chap. 5), and by allowing the description of a saturation
semantics that extends to parallel or nondeterministic programs (Chap.7).
2.2.2
Veriﬁcation of Model-Oriented Rule Programs
As seen in Sect. 2.1.1, model-oriented rules are primarily used in knowledge man-
agement applications and in deductive databases. In these contexts the veriﬁcation
concerns are almost exclusively focused on consistency and completeness of the
knowledge base, respectively of the database. See [49, 62, 76] for a survey of
problems and techniques in the veriﬁcation of knowledge bases, and [46] for an
illustration on a speciﬁc knowledge management system. Deductive databases reuse
these techniques, or develop speciﬁc ones [41,50].
The veriﬁcation of the consistency of an ontology can be seen as a particular
case of consistency of a knowledge base. Speciﬁc investigations have been carried
out when ontologies are used in the semantic web context [64], and in particular
when they are implemented with description logic [63].
The veriﬁcation of business rules in the sense of Sect. 1.2.2, that is, rules
modeling business policies, has been the subject of extensive study by Rik Gerrits
and Silvie Spreeuwenberg [32]. It has given birth to the commercial product LibRT
VALENS, which it is claimed is used by a few Business Rules Management
Systems. However the description of the product in [32] and on the company
website, furthermore conﬁrmed by an in-depth study from the standpoint of a BRMS
[52], shows that LibRT VALENS considers rules with a model orientation, and
proves to be out of focus for a BRMS. For example, a self-contradiction is signaled

24
2
Related Work
when a rule is not applicable in the state that results from its execution, which is a
rather common case in state-oriented rule applications as they are nonmonotonic.
More generally, the veriﬁcation concerns of LibRT VALENS focus on rule base
consistency and completeness, and transpose badly to production rules.
Consistency and completeness of a rule base are not our primary focus here.
Rather, we are interested in correctness properties of executions of a rule program.
However, we can provide an interpretation of consistency and completeness in the
context of Business Rules Management Systems. For example, a rule that can never
be applicable, no matter the values of the attributes of the objects in the working
memory, can be seen as an inconsistency in the rule program. Additional examples
of such interpretations of consistency for rule programs in BRMS are given in
App. A and in [23, 64]. Completeness can also be relevant for BRMS: checking
the completeness of a rule program means verifying whether the program can be
executed from all possible working memories—or from all working memories in a
subspace of interest.
2.2.3
Veriﬁcation of State-Oriented Rule Programs
While the veriﬁcation concerns for model-oriented rules are focused on consistency
and completeness, those for state-oriented rules primarily concentrate on conﬂuence
and termination.
Several approaches to the veriﬁcation of conﬂuence and termination in active
databases are reviewed in [14]. Among them, Karadimce and Urban [38] reduces
event-condition-action rules to conditional term rewriting, and Hellerstein and Hsu
[34] restricts the rule language to guarantee conﬂuence. Baralis and Widom [14]
itself proposes an approach based on an extension of the relational algebra. On the
other hand, Ludäscher and Lausen [48] focuses on the termination problem in active
databases.
The connection between production rules and term-rewriting systems has been
explored with the intention of using the techniques of rewriting systems to ana-
lyze properties, and eventually verify the correctness, of production systems. In
[69–72, 74], James Schmolze and Wayne Snyder propose a rewrite semantics
for OPS5. This proposal includes a form of constrained rewriting for negative
tests (“there is no object such that...”, which we do not address). In addition,
techniques such as Knuth-Bendix completion [40] are applied to test the conﬂuence
of production systems and repair it in case of failure, and to detect design issues
such as redundancy. This approach has shortcomings, which are listed by the
authors themselves [74, pp. 514–515]. Some of them can probably be addressed by
appropriate extensions of the formalism: for example the limitation of expressions
to Boolean ones, and of actions to additions to, and removals from, the working
memory. Other limitations however, such as not modeling the selection and
eligibility strategies, may prove too severe for this approach to be applied to rule
programs as handled by BRMS.

2.3
Veriﬁcation of Pointer and Concurrent Programs
25
For rule programs as handled by Business Rules Management Systems, con-
ﬂuence can be deﬁned as the property of a rule program that all its executions
from a given state lead to the same ﬁnal state. This property is described in
[17]. We do not study it here, mainly because general conﬂuence involves several
concurrent executions and hence cannot be expressed with correctness formulas of
the form fpg R fqg. However, in App. A, we present examples of particular cases
of conﬂuence checking.
In addition to conﬂuence and termination veriﬁcation, analyses have been
designed in the context of production systems to ﬁnd design ﬂaws. For example,
Prakash et al. [61] describes a method to analyze OPS5 programs statically, in order
to detect relations between production rules that would suggest errors in the design
of the program.
The veriﬁcation of safety properties in BRMS rule programs is within our
focus. Berstel and Leconte [17] addresses it by translating this veriﬁcation task
into a constraint satisﬁability problem. However, the technique described in this
paper for proving these safety properties lacks compositionality, contrary to the one
introduced in Part IV.
2.3
Veriﬁcation of Pointer and Concurrent Programs
Veriﬁcation of programs with a Hoare logic is a widespread technique. Its origins
are in the work of Robert Floyd [28] and Tony Hoare [36]. It has since been
extended to numerous programming paradigms. Surveys can be found for example
in [7,8,12,54].
We have seen that rule programs as handled by Business Rules Management
Systems have common points with databases, in particular because production rules
can be seen as a special case of event-condition-action rules in active databases,
although the execution semantics of the two kinds of rule programs are different.
In addition they share features with two other, non-rule-based paradigms: programs
with pointers and concurrent programs.
The similarities with programs with pointers come from the fact that business
applications integrating with Business Rules Management Systems are typically
object-oriented applications. As a result, rules in BRMS handle objects with
attributes and methods. As mentioned in Chap. 1 (and formally described in Chap.5)
the objects on which the rules reason are handled through a set called the working
memory.
In many aspects the working memory is similar to a heap: it is ﬁnite but not
bounded, it is accessed randomly, in particular when rule instances are formed, and
it is dynamic in two ways. Firstly, the links between the objects can be updated by
the execution of the rules (this aspect is covered in the present work). Secondly,
rules can add objects to the working memory or remove objects from it (we do not
cover this aspect). In contrast with programs with pointers however, there is usually
no concern such as shape analysis when verifying rule programs.

26
2
Related Work
Beyond the similarities between the working memory and a heap, the fact that
rules handle objects brings in the aliasing problem, that is, the fact that two distinct
variables can hold the same object. This has to be taken into account, in particular,
in the way updates of attributes are interpreted (Sect. 4.4) or rule execution is
deﬁned (Sect. 5.3). We adopt the approach of Joseph Morris [51], which consists
in including a conditional expression in the formula that deﬁnes the effect of
assignment. We present it on p. 57; it is also presented in detail in [9, pp. 42–45].
Rule programs in BRMS also have important similarities with concurrent pro-
grams, which is a well-studied topic [19,44,45,55–57]. Clearly the working memory
can be seen as a shared memory. Furthermore, the execution of a rule program
as described in Chap.5 shows two degrees of concurrency, which result from the
Cartesian product between rules and object tuples that is performed by the rule
engine. One way to look at this is to consider each rule in the program as a process,
within which all objects are concurrent; the symmetric vision holds as well, where
all objects are processes and run the same program made of the rules concurrently.
In addition, both viewpoints must account for the fact that rules do not match
individual objects but object tuples, which introduces synchronization constraints.
Chapter 7 handles this complexity by transposing the saturated semantics of rule
engines onto parallel programs.
In the light of the similarities between rule programs in BRMS and concur-
rent programs, the question naturally arises of whether veriﬁcation methods for
concurrent programs could apply to rule programs. Such methods were initially
designed by Edward Ashcroft [10] using a global invariant, then independently
made compositional by Leslie Lamport [43], and by Susan Owicki and David Gries
[59]. These methods are also described or discussed in [9,44,73].
We shall see in Chap. 7 that in general a rule program as handled by a BRMS
cannot be simulated by a concurrent program. As a consequence, the veriﬁcation of
a rule program cannot be performed by translating it into a concurrent one and then
applying the veriﬁcation methods for concurrent programs.
References
All URLs were successfully accessed on January 22, 2013.
1. Abiteboul, S., Vianu, V.: Procedural and declarative database update languages. In: PODS,
pp. 240–250. ACM, New York (1988)
2. Abiteboul, S., Vianu, V.: Datalog extensions for database queries and updates. J. Comp. Syst.
Sci. 43(1), 62–124 (1991)
3. Aït-Kaci, H.: Description logic vs. order-sorted feature logic. In: Calvanese, D., Franconi,
E., Haarslev, V., Lembo, D., Motik, B., Turhan, A.Y., Tessaris, S. (eds.) Description Logics.
CEUR Workshop Proceedings, vol. 250. CEUR-WS.org (2007). http://ceur-ws.org/Vol-250/
paper_2.pdf
4. Aït-Kaci, H., Podelski, A., Copen Goldstein, S.: Order sorted feature theory uniﬁcation.
J. Logic Program. 30(2), 99–124 (1997)

References
27
5. Angele, J., Kifer, M., Lausen, G.: Ontologies in F-logic. In: Bernus, P., Blazewics, J., Schmidt,
G., Shaw, M., Staab, S., Studer, R. (eds.) Handbook on Ontologies. International Handbooks
on Information Systems, pp. 45–70. Springer, Berlin (2009)
6. Antoniou,
G.,
Damásio,
C.V.,
Grosof,
B.,
Horrocks,
I.,
Kifer,
M.,
Maluszynski,
J., Patel-Schneider, P.F.: Combining Rules and Ontologies: A Survey.
Tech. Rep.
IST506779/Linköping/I3-D3/D/PU/a1, Linköping University (2005).
IST-2004-506779
REWERSE
Deliverable
2005-I3-D3.
http://rewerse.net/publications/rewerse-description/
REWERSE-DEL-2005-I3-D3.html
7. Apt, K.R.: Ten years of Hoare’s logic: A survey—part I. ACM Trans. Program. Lang. Syst.
3(4), 431–483 (1981)
8. Apt, K.R.: Ten years of Hoare’s logic: A survey—part II: Nondeterminism. Theor. Comp. Sci.
28, 83–109 (1984)
9. Apt, K.R., de Boer, F.S., Olderog, E.R.: Veriﬁcation of Sequential and Concurrent Programs,
3rd edn. Texts in Computer Science. Springer, Berlin (2009)
10. Ashcroft, E.A.: Proving assertions about parallel programs. J. Comp. Syst. Sci. 10(1), 110–135
(1975)
11. Baader, F., Calvanese, D., McGuinness, D.L., Nardi, D., Patel-Schneider, P.F. (eds.):
The Description Logic Handbook: Theory, Implementation, and Applications.
Cambridge
University Press, London (2003)
12. de Bakker, J.W., de Bruin, A., Zucker, J.: Mathematical Theory of Program Correctness.
Prentice-Hall International Series in Computer Science. Prentice Hall, Englewood Cliffs (1980)
13. Baral, C., Lobo, J.: Characterizing production systems using logic programming and situation
calculus (2007). http://cs.utep.edu/chitta/papers/char-prod-systems.ps
14. Baralis, E., Widom, J.: An algebraic approach to rule analysis in expert database systems. In:
Bocca, J.B., Jarke, M., Zaniolo, C. (eds.) VLDB, pp. 475–486. Morgan Kaufmann, Los Altos
(1994)
15. Behrends, E., Fritzen, O., May, W., Schenk, F., Schubert, D.: A framework and components
for ECA rules in the web. In: Proceedings of Second International Conference on Rules and
Rule Markup Languages for the Semantic Web, Athens, GA, USA (RuleML) (2006). http://
rewerse.net/publications/rewerse-description/REWERSE-RP-2006-165.html
16. Berners-Lee, T., Hendler, J.: The semantic web. Sci. Am. 284, 34–43 (2001)
17. Berstel, B., Leconte, M.: Using constraints to verify properties of rule programs.
In: Pro-
ceedings of the 2010 Third International Conference on Software Testing, Veriﬁcation, and
Validation Workshops, ICSTW’10, pp. 349–354. IEEE Computer Society, Silver Spring (2010)
18. Berstel, B., Bonnard, P., Bry, F., Eckert, M., P˘atrânjan, P.L.: Reactive rules on the web. In:
Antoniou, G., Aßmann, U., Baroglio, C., Decker, S., Henze, N., P˘atrânjan, P.L., Tolksdorf, R.
(eds.) Reasoning Web. Lecture Notes in Computer Science, vol. 4636, pp. 183–239. Springer,
Berlin (2007)
19. Broy, M., Olderog, E.R.: Trace-oriented models of concurrency.
In: Bergstra, J.A., Ponse,
A., Smolka, S.A. (eds.) Handbook of Process Algebra, pp. 101–195. Elsevier Science,
New York (2001)
20. de Bruijn, J., Rezk, M.: A logic based approach to the static analysis of production systems. In:
Polleres, A., Swift, T. (eds.) RR. Lecture Notes in Computer Science, vol. 5837, pp. 254–268.
Springer, Berlin (2009)
21. Calvanese, D., Lausen, G. (eds.): Web Reasoning and Rule Systems. Proceedings of Second
International Conference, RR 2008, Karlsruhe, Germany, 31 October–1 November 2008.
Lecture Notes in Computer Science, vol. 5341. Springer, Berlin (2008)
22. Chniti, A., Dehors, S., Albert, P., Charlet, J.: Authoring business rules grounded in OWL
ontologies.
In: Dean, M., Hall, J., Rotolo, A., Tabet, S. (eds.) RuleML. Lecture Notes in
Computer Science, vol. 6403, pp. 297–304. Springer, Berlin (2010)
23. Chniti, A., Albert, P., Charlet, J.: Gestion de la cohérence des règles métier éditées à partir
d’ontologies OWL. In: Conférence Francophone d’Apprentissage 2011 (2011)

28
2
Related Work
24. Cirstea, H., Kirchner, C., Moossen, M., Moreau, P.É.: Production systems and Rete algorithm
formalisation. Research report, LORIA, Nancy (2004). http://hal.inria.fr/inria-00280938/PDF/
rete.formalisation.pdf
25. Demuth, B., Liebau, H.B.: An approach for bridging the gap between business rules and the
semantic web. In: Proceedings of the 2007 International Conference on Advances in Rule
Interchange and Applications, RuleML’07, pp. 119–133. Springer, Berlin (2007)
26. Fages, F., Lissajoux, R.: Sémantique opérationnelle et compilation des systèmes de production.
Revue d’Intelligence Artiﬁcielle 6(4), 431–456 (1992)
27. Fair, Isaac, and Company: High-volume batch processing with Blaze Advisor.
Computer
World UK (2007).
http://www.computerworlduk.com/white-paper/business-process/5092/
high-volume-batch-processing-with-blaze-advisor/
28. Floyd, R.W.: Assigning meaning to programs. In: Proceedings of the Symposium on Applied
Math, vol. 19, pp. 19–32. American Mathematical Society, Providence (1967)
29. Forgy, C.: Rete: A fast algorithm for the many patterns/many objects match problem. Artif.
Intell. 19(1), 17–37 (1982)
30. Frohn, J., Himmeröder, R., Kandzia, P.T., Lausen, G., Schlepphorst, C.: FLORID: A prototype
for F-logic. In: Gray, W.A., Larson, P.Å. (eds.) ICDE, p. 583. IEEE Computer Society, Silver
Spring (1997)
31. Gallaire, H., Minker, J. (eds.): Symposium on Logic and Data Bases, Centre d’études et de
recherches de Toulouse. Advances in Data Base Theory. Plenum Press, New York (1977)
32. Gerrits, R., Spreeuwenberg, S.: VALENS: A knowledge based tool to validate and verify an
Aion knowledge base. In: Horn, W. (ed.) ECAI, pp. 731–738. IOS Press, Amsterdam (2000)
33. Ghallab, M., Nau, D.S., Traverso, P.: Automated Planning: Theory and Practice.
Morgan
Kaufmann, Los Altos (2004)
34. Hellerstein, J.M., Hsu, M.: Determinism in partially ordered production systems. Research
report, IBM Almaden Research Center (1991)
35. Heymans, S., de Bruijn, J., Rezk, M., Aït-Kaci, H., Citeau, H., Korf, R., Pührer, J., Feier, C.,
Eiter, T.: Initial combinations of rules and ontologies. Public Deliverable 3.2, ONTORULE
Project (2009). http://ontorule-project.eu/outcomes?func=ﬁleinfo&id=18
36. Hoare, C.A.R.: An axiomatic basis for computer programming. Comm. ACM 12, 576–580
(1969)
37. IBM: IBM Operational Decision Manager v8.0 User’s Manual (2012). http://publib.boulder.
ibm.com/infocenter/dmanager/v8r0/
38. Karadimce, A.P., Urban, S.D.: Conditional term rewriting as a formal basis for active database
rules. In: RIDE-ADS, pp. 156–162. IEEE Computer Society (1994)
39. Kifer, M., Lausen, G.: F-logic: A higher-order language for reasoning about objects, inheri-
tance, and scheme. In: Proceedings of the 1989 ACM SIGMOD International Conference on
Management of Data, SIGMOD’89, pp. 134–146. ACM, New York (1989)
40. Knuth, D., Bendix, P.: Simple word problems in universal algebra. In: Computational Problems
in Abstract Algebra, pp. 263–297. Pergamon Press, New York (1970)
41. Kowalski, R.A., Sadri, F., Soper, P.: Integrity checking in deductive databases. In: Proceedings
of the 13th International Conference on Very Large Data Bases, VLDB’87, pp. 61–69. Morgan
Kaufmann, Los Altos (1987)
42. Lakemeyer, G., Nebel, B. (eds.): Foundation of Knowledge Representation and Reasoning.
Lecture Notes in Computer Science, vol. 810. Springer, Berlin (1994)
43. Lamport, L.: Proving the correctness of multiprocess programs. IEEE Trans. Software Eng.
3(2), 125–143 (1977)
44. Lamport, L.: Veriﬁcation and speciﬁcation of concurrent programs.
In: de Bakker, J.W.,
de Roever, W.P., Rozenberg, G. (eds.) REX School/Symposium. Lecture Notes in Computer
Science, vol. 803, pp. 347–374. Springer, Berlin (1993)
45. Lamport, L.: Specifying Systems, The TLA+ Language and Tools for Hardware and Software
Engineers. Addison-Wesley, Reading (2002). http://research.microsoft.com/en-us/um/people/
lamport/tla/book.html

References
29
46. von Luck, K., Nebel, B., Peltason, C., Schmiedel, A.: BACK to consistency and incomplete-
ness. In: Stoyan, H. (ed.) GWAI. Informatik-Fachberichte, vol. 118, pp. 245–256. Springer,
Berlin (1985)
47. Ludäscher, B.: Integration of Active and Deductive Database Rules. DISDBIS, vol. 45. Inﬁx
Verlag, St. Augustin (1998)
48. Ludäscher, B., Lausen, G.: Handling termination in a logical language for active rules.
Informatica (Lithuanian Academy of Sciences) 9(1), 65–84 (1998)
49. Menzies, T., Pecheur, C.: Veriﬁcation and validation and artiﬁcial intelligence. Adv. Comp. 65,
154–203 (2005)
50. Minker, J.: Logic and databases: A 20 year retrospective. In: Pedreschi, D., Zaniolo, C. (eds.)
Logic in Databases. Lecture Notes in Computer Science, vol. 1154, pp. 3–57. Springer, Berlin
(1996)
51. Morris, J.M.: A general axiom of assignment.
In: Bauer, F.L., Dijkstra, E.W., Hoare,
C.A.R. (eds.) Theoretical Foundations of Programming Methodology: Lecture Notes of an
International Summer School. Reidel, Dordrecht (1982)
52. Nakoulima, S.D.: Added value of LibRT VALENS for ILOG JRules. Rapport de stage, École
des Mines de Nancy (2004). Available from Bruno Berstel-Da Silva
53. Newell, A., Simon, H.A.: Human Problem Solving. Prentice Hall, Englewood Cliffs (1972)
54. Olderog, E.R.: Hoare’s logic for programs with procedures—What has been achieved? In:
Clarke, E.M., Kozen, D. (eds.) Logics of Programs. Lecture Notes in Computer Science,
vol. 164, pp. 383–395. Springer, Berlin (1984)
55. Olderog, E.R.: Correctness of concurrent processes. Theor. Comp. Sci. 80, 263–288 (1991)
56. Olderog, E.R.: Nets, Terms and Formulas: Three Views of Concurrent Processes and Their
Relationship. Cambridge University Press, London (1991). Paperback Edition 2005
57. Olderog, E.R., Rössig, S.: A case study in transformational design of concurrent systems.
In: Gaudel, M.C., Jouannaud, J.P. (eds.) Theory and Practice of Software Development
(TAPSOFT’93). Lecture Notes in Computer Science, vol. 668, pp. 90–104. Springer, Berlin
(1993)
58. ONTORULE Project. http://ontorule-project.eu
59. Owicki, S.S., Gries, D.: An axiomatic proof technique for parallel programs I. Acta Informatica
6, 319–340 (1976)
60. Piccinini, G.: Allen Newell. In: New Dictionary of Scientiﬁc Biography. Thomson Gale (2007).
http://www.umsl.edu/~piccininig/Newell%205.htm
61. Prakash, G.R., Subrahmanian, E., Mahabala, H.N.: A methodology for systematic veriﬁcation
of OPS5-based AI applications. In: IJCAI, pp. 3–8. Morgan Kaufmann, Los Altos (1991)
62. Preece, A.D., Shinghal, R.: Foundation and application of knowledge base veriﬁcation. Int. J.
Intell. Syst. 9(8), 683–701 (1994)
63. Pührer, J., Heymans, S., Eiter, T.: Dealing with inconsistency when combining ontologies
and rules using DL-programs.
In: Aroyo, L., Antoniou, G., Hyvönen, E., ten Teije, A.,
Stuckenschmidt, H., Cabral, L., Tudorache, T. (eds.) ESWC (1). Lecture Notes in Computer
Science, vol. 6088, pp. 183–197. Springer, Berlin (2010)
64. Pührer, J., Ghali, A.E., Chniti, A., Korf, R., Schwichtenberg, A., Lévy, F., Heymans, S., Xiao,
G., Eiter, T.: Consistency Maintenance. Public Deliverable 2.3, ONTORULE Project (2011).
http://ontorule-project.eu/outcomes?func=ﬁleinfo&id=44
65. Red Hat: JBoss Rules 5 Reference Guide (2012). https://access.redhat.com/knowledge/docs/
en-US/JBoss_Enterprise_BRMS_Platform/5/html-single/JBoss_Rules_5_Reference_Guide/
index.html#Sequential_Mode
66. REWERSE Network of excellence. http://rewerse.net
67. de Sainte Marie, C., Hallmark, G., Paschke, A.: Rule Interchange Format, Production Rule
Dialect. Recommendation, W3C (2010). http://www.w3.org/TR/rif-prd/
68. Schmedding, F., Sawas, N., Lausen, G.: Adapting the Rete-algorithm to evaluate F-logic rules.
In: Paschke, A., Biletskiy, Y. (eds.) Advances in Rule Interchange and Applications. Lecture
Notes in Computer Science, vol. 4824, pp. 166–173. Springer, Berlin (2007)

30
2
Related Work
69. Schmolze, J.G., Snyder, W.: Using conﬂuence to control parallel production systems. In: Kanal,
L.N. (ed.) Parallel Processing for Artiﬁcial Intelligence. Elsevier Science, New York (1994)
70. Schmolze, J.G., Snyder, W.: A tool for testing conﬂuence of production rules.
In: Ayel,
M., Rousset, M.C. (eds.) EUROVAV, pp. 91–104. ADERIAS-LIA, Université de Savoie (1995)
71. Schmolze, J.G., Snyder, W.: Detecting redundant production rules.
In: AAAI/IAAI,
pp. 417–423 (1997)
72. Schmolze, J.G., Snyder, W.: Detecting redundancy among production rules using term rewrite
semantics. Knowl. Base. Syst. 12(1–2), 3–11 (1999)
73. Schneider, F.B., Andrews, G.R.: Concepts for concurrent programming. In: de Bakker, J.W.,
de Roever, W.P., Rozenberg, G. (eds.) Current Trends in Concurrency. Lecture Notes in
Computer Science, vol. 224, pp. 669–716. Springer, Berlin (1986)
74. Snyder, W., Schmolze, J.G.: Rewrite semantics for production rule systems: Theory and
applications.
In: McRobbie, M.A., Slaney, J.K. (eds.) CADE. Lecture Notes in Computer
Science, vol. 1104, pp. 508–522. Springer, Berlin (1996)
75. Sowa, J.F.: Knowledge Representation: Logical, Philosophical, and Computational Founda-
tions. Brooks/Cole, Belmont (1999)
76. Suwa, M., Scott, A.C., Shortliffe, E.H.: An approach to verifying completeness and consistency
in a rule-based expert system. AI Mag. 3(4), 16–21 (1982)
77. The Object Management Group: Semantics of Business Vocabulary and Business Rules (SBVR
1.0) (2008). http://www.omg.org/spec/SBVR/1.0/
78. Ullman, J.D.: Principles of Database and Knowledge-Base Systems, Volume I.
Computer
Science Press, Rockville (1988)
79. Vianu, V.: Rule-based languages. Ann. Math. Artif. Intell. 19(1–2), 215–259 (1997)
80. Widom, J., Ceri, S.: Introduction to active database systems. In: Active Database Systems:
Triggers and Rules For Advanced Database Processing, pp. 1–41. Morgan Kaufmann, Los
Altos (1996)

Part II
Rule Programs

Chapter 3
Syntax of Rules and Rule Programs
The rule programs we consider are written in a language built on a set of symbols.
The symbols are assembled into formulas and statements, to eventually form rules
and rule programs. The symbols and assembly rules are introduced in this chapter;
the next two chapters give the semantic interpretation of elements of rule programs
and of rule programs themselves.
3.1
Signature
We consider a set ˙ of symbols. This signature includes symbols for constants,
variables, types, and attributes, as well as operators and symbols for writing
statements.
Rule programs implement the business logic of a wider BRMS-based application,
and to this end handle and transform the data of this application. The data types
involved can range from Boolean values, to numbers, either integral or real, to
enumerations of symbolic values such as colors or customer categories, and beyond.
Since we consider rule programs integrated in object-oriented applications, rules
will also handle objects, which are basically data structures that aggregate references
to other objects and values of the data types just mentioned. Objects are classiﬁed
by an application into object types, as described below.
Data types vary from one BRMS-based application to another. Fundamentally,
they are parameters of the rule language. To formalize application data types, we
consider from now on that a theory  has been ﬁxed. This theory describes the data
types from the application that are handled by the rule language. The theory comes
with a signature, which contributes constant symbols and operators to ˙.
In addition, we consider that a type system T , as deﬁned in Sect. 3.3.2, has been
ﬁxed. The type system describes the classiﬁcation among object types enforced by
the BRMS-based application. It contributes to ˙ a set of symbols (the type names,
deﬁned below) that denote the object types.
B. Berstel-Da Silva, Veriﬁcation of Business Rules Programs,
DOI 10.1007/978-3-642-40038-4__3, © Springer-Verlag Berlin Heidelberg 2014
33

34
3
Syntax of Rules and Rule Programs
In our examples, we will use real numbers and enumerated symbolic values as the
data types of our applicative theory. We will also use object types such as persons,
shopping carts, or cars.
3.2
Symbols
Symbols for Constants
Constant symbols denote the values handled by rule programs. We include the
Boolean constants true and false in our rule language. Other constant symbols come
from the signature of the theory . Examples are integral or real numbers, as well
as enumerations of symbolic values such as Red or Blue for colors, or Silver or
Gold for customer categories.
Symbols for Variables
Variable symbols denote free or quantiﬁed variables. As we shall see, variables are
used in rule programs to handle the objects matched and acted upon by the rules.
Variable symbols come in inﬁnite number and their set is denoted Var.
Since variables hold objects, they are usually named o or o1; o2; : : : In examples,
where the objects handled through the variables are given a business meaning such
as persons or shopping carts, they might be named with more meaningful letters
such as p or c. Conversely, dummy or quantiﬁed variables are usually named x, y,
etc. Metavariables are denoted  or .
Type Names
Type names are symbols that denote object types as deﬁned by the BRMS-based
application. The set of type names is ﬁnite and is denoted Types.
A common generic name for a type is T , or T1; T2; : : : In examples we might use
more business-oriented names such as Person, Car, etc.
Attribute Symbols
Attribute symbols denote attributes or ﬁelds, that is, structural features of objects.
An object attribute has a name and a value. The symbol denoting an attribute carries
the attribute name. The inﬁnite set of all attribute symbols is denoted Attr.
Examples of attribute symbols are age or value. A common generic name for an
attribute symbol is f (for ﬁeld, or feature).

3.3
Expressions and Formulas
35
Operators
Operators are function symbols used in inﬁx notation, which are introduced by each
value type.
All data types use equality, Booleans introduce logical connectors, and numbers
introduce arithmetic and comparison operators.
Objects also use equality, and two additional operators. The dot is used for
attribute reference: for example, p:age denotes the age attribute of the object held by
the variable p. The colon is used to express an object typing expression: for exam-
ple, p W Person denotes that the variable p is expected to hold objects of type Person.
3.3
Expressions and Formulas
3.3.1
Parameterized Languages of Expressions and Formulas
Expressions and formulas are built with the symbols deﬁned above. Depending
on the context, we might want to restrict which variables are allowed to appear
in an expression or a formula. To this end, we deﬁne parameterized languages of
expressions and formulas, based on a set of variables V  Var.
In Fig. 3.1, we give a deﬁnition of a few parameterized languages, namely
the language of expressions E .V /, the language of Boolean expressions or non-
quantiﬁed formulas B.V /, and the language of possibly quantiﬁed formulas F.V /.
For these deﬁnitions we use grammars in Backus-Naur format. We slightly
extend the notation for non-terminals, such as hexpressioni, to link a language with
the root non-terminal of its grammar, as for example in hexpression : E .V /i. Also,
we sometimes introduce shortcuts for a non-terminal, as ' in hformula : ' 2 F.V /i.
In the grammar of Fig. 3.1, one can note the presence of the theory-dependent
non-terminals h expr.i and h formulai. With these extension points, we can
integrate expressions and formulas from the application theory into the language.
In Sect. 3.3.4, we give the deﬁnitions for the expressions and formulas that we use
in examples.
Also, the grammar does not enforce any typing constraint. For example, an
attribute reference can occur as a Boolean expression or as an object expression.
These cases are handled in the semantic interpretation in Chap. 4, by deﬁning for
example that Blue D 2 is false. Similarly, constraints that result from object types
are not enforced by the grammar, but will be enforced through the notion of well-
typed expressions and formulas, introduced in Sect. 3.3.2.
Variables and Attribute Symbols of Expressions and Formulas
Let us consider a set of variables V  Var and a formula ' 2 F.V /. We write
var.'/ for the set of variables appearing in '.

36
3
Syntax of Rules and Rule Programs
Fig. 3.1 Expressions and formulas
Variables in a formula appear either under the scope of a quantiﬁer, in which case
they are called bound variables, or not, in which case they are called free variables.
The set of free variables in ' is denoted free.'/. Formulas with no free variables
are called closed formulas. Given the deﬁnition of F.V /, the set V is not a superset
of all the variables in a formula ' 2 F.V /, but only of the free variables in '. If
' 2 B.V /, that is, it contains no quantiﬁer, then free.'/ D var.'/ and var.'/  V .
Conversely, F.;/ is the set of all closed formulas.
For a formula ' 2 F.V /, we write Attr.'/ for the set of attribute symbols
appearing in '. In addition, given a variable  2 Var, we write Ref.; '/ for the
set of attribute symbols appearing in ' in an attribute reference where the variable
is . Finally, we write Free.'/ D [2free.'/Ref.; '/ for the set of attribute symbols
appearing in references to attributes of free variables in '.
We make similar deﬁnitions for expressions: given an expression e 2 E .V / and a
variable  2 Var, we deﬁne the sets var.e/, Attr.e/, and Ref.; e/. Since expressions
contain no quantiﬁers, there is no notion of bound or free variable in expressions.
Example. Given the formula
'  8p .p:age > 60 ^ p:ancestor D q/ _ q:age D 0
we have
var.'/ D fp; qg
Attr.'/ D fage; ancestorg
free.'/ D fqg
Ref.p; '/ D fage; ancestorg
Free.'/ D fageg
Ref.q; '/ D fageg .

3.3
Expressions and Formulas
37
3.3.2
Well-Typed Expressions and Formulas
We use a basic type framework inspired by Kifer et al. [2]. We introduce below only
the concepts that we need.
In our framework, a type system contains type names and type deﬁnitions. Type
names are symbols as deﬁned in Sect. 3.2, and denote what are called classes in
the object-oriented paradigm. Type deﬁnitions provide a set of attribute symbols for
each type, which corresponds in the object-oriented paradigm to the set of attributes
deﬁned in the class.
It results naturally that when a variable is equipped with a type, well-typed
expressions and formulas should not contain references to other attributes of this
variable than those included in the deﬁnition of its type.
Deﬁnition 3.1. A type system T D .Types; ˛/ consists of
(i) a set of type names denoted Types;
(ii) a type deﬁnition function ˛ W Types ! }.Attr/ that maps each type name
T 2 Types onto a ﬁnite set of attribute symbols ˛.T /  Attr.
To simplify the deﬁnitions and notations that will occur later, we require type
deﬁnitions to be disjoint, that is, given any two distinct type names T1; T2 2 Types,
we require that ˛.T1/ \ ˛.T2/ D ;.
This requirement for type deﬁnitions to be disjoint amounts to forbidding
attribute symbol overloading.For example, we forbid the age of a person and the age
of a car from being denoted by the same attribute symbol. Such a restriction does
not reduce the expressive power of type systems. In practice, it is usually hidden
from the programmer through some mangling process performed by the language
compiler. Also, we do not consider subtyping, as occurs in the object-oriented
paradigm with subclasses, because it does not introduce signiﬁcant differences in
our formalism, and is not our focus.
We denote by Attr.T / D S
T 2Types ˛.T / the set of all attribute symbols used in
type deﬁnitions of our type system. This set is ﬁnite by construction.
We now introduce the deﬁnition of a type constraint on a set of variables, and we
build on this concept to deﬁne well-typed expressions and formulas.
Deﬁnition 3.2. A type constraint on variables is a function  W V ! Types, with
V  Var, that associates a type name with each variable in V . We write Dom./ for
the domain V of the type constraint.
Deﬁnition 3.3. Given a set of variables V  Var, a type system T D .Types; ˛/
and a type constraint :
(i) An expression e 2 E .V / is well-typed with respect to T and  if for each
variable  2 var.e/ \ Dom./ we have Ref.; e/  ˛..//.
(ii) A formula ' 2 F.V / is well-typed with respect to T and  if for each variable
 2 var.'/ \ Dom./ we have Ref.; '/  ˛..//.

38
3
Syntax of Rules and Rule Programs
Since we work with a ﬁxed type system, we will usually omit citing it, and say
that an expression or a formula is well-typed for a given type constraint.
3.3.3
Formulas Are Flat
Note that the grammar for B.V / imposes the constraint that an object can be
referred to only either through a variable, or through the reference to an attribute of
a variable. That is, the grammar excludes chains of attribute references, forbidding
for example p:parent:age. The resulting formulas are called ﬂat by analogy with ﬂat
terms where variables occur only at depth 0 or 1.
As will become obvious when we introduce the semantics of formulas, this is not
a proper restriction. In short, a formula from an extension of some F.V / language
with chains of attribute references can be transposed into an equivalent formula
of the strict F.V / language by introducing existentially-quantiﬁed fresh variables.
For non-quantiﬁed formulas, the transposition from an extension of some B.V /
language with chains of attribute references includes the introduction of additional
variables, resulting in formulas from some B.V 0/ where V 0 is a strict superset of V .
For example, the formula p:parent:age > 60 will be written q D p:parent ^
q:age > 60.
3.3.4
Theory Used in Examples
The deﬁnition of the languages of expressions and formulas above opens the door
for theory-speciﬁc expressions and formulas. In the subsequent examples we use
this mechanism to include numbers and symbolic values in the rules.
The grammar in Fig. 3.2 gives the derivations to complete the grammar of
Fig. 3.1 with numbers and symbolic values, thus deﬁning the languages used in our
examples.
Throughout this book, we use the following precedence rules between operators.
These rules are standard, but recalling them may help in reading composite formulas
such as (9.6) on p. 178. In order of decreasing precedence:
(i) logical negation, quantiﬁcation: :, 8, 9;
(ii) arithmetics with usual precedence: C, , 	, etc.;
(iii) equality and inequality: D, <, , etc.;
(iv) binary logical connectors with usual precedence: ^, _, !.

3.4
Assignment
39
⟨
expr.⟩::= ⟨num. expr.⟩| ⟨symb. expr.⟩
⟨num. expr. : e⟩::= ‘(’ e ‘)’ | e ‘+’ e | e ‘−’ e | e ‘×’ e | e ‘ ’ e
| NUMBER
| ⟨attribute ref.⟩
⟨symb. expr.⟩::= SYMBOLIC-VALUE | ⟨attribute ref.⟩
⟨
formula⟩::= e ‘=’ e | e ‘<’ e | e ‘≤’ e | e ‘>’ e | e ‘≥’ e
| ⟨symb. expr.⟩‘=’ ⟨symb. expr.⟩
Fig. 3.2 Expressions and formulas on numbers and symbolic values (extension to Fig. 3.1)
3.4
Assignment
Our rule language contains only one statement: assignment of a value to an attribute
of an object. Because the rule engine takes charge of the control, no control ﬂow
statement, such as conditionals or loops, is included in the action language for our
rules.
However, in our later reasoning about rule programs, we will resort to traditional
sequential statements and to some statements found in parallel and nondeterministic
programs. We will formally introduce these statements in Chap. 6. For now we
simply deﬁne the syntax of assignment, and deﬁne its semantics in the next chapter.
The deﬁnition of assignment is based on the deﬁnition of expressions provided in
Fig. 3.1. As a consequence, this deﬁnition is also parameterized by a set of variables
V  Var. In Fig. 3.3, we deﬁne the language of assignment A .V /, which also
constitutes the language for rule actions.
An assignment operates on an attribute reference, and assigns it an expression
from the language E .V / as deﬁned in Fig. 3.1. In particular, the expression can
contain theory-speciﬁc terms.
Example. The following ﬁrst assignment sets the value of the category attribute of
the object held by variable p, to the constant Gold. The second one increments by
10 the value of the discount attribute of the object held by variable c.
(i) p:category:D Gold
(ii) c:discount :D c:discount C 10
Deﬁnition 3.4. Let x:f :D e be an assignment. Given a type system T
D
.Types; ˛/ and a type constraint , the assignment is well-typed for  if:
(i) the attribute on the left-hand side of the assignment is in the type deﬁnition of
the variable, that is, f 2 ˛..x//; and
(ii) the expression e is well-typed for .

40
3
Syntax of Rules and Rule Programs
⟨assignment :
(V)⟩::= ⟨attribute ref.⟩‘:=’ ⟨expression :
(V)⟩
⟨attribute ref.⟩::= ⟨variable : V⟩‘.’ ⟨attribute symbol : Attr⟩
Fig. 3.3 Assignment
3.5
Rules
Deﬁnition 3.5. A rule r D .Eo; ET ; g; a/ consists of:
(i) Eo D .o1; : : : ; om/: a tuple of variables;
(ii) ET D .T1; : : : ; Tm/: a tuple of type names of the same length, and called the
types of the variables; together with the tuple of variables, the tuple of type
names forms a type constraint .Eo W ET / as deﬁned in Deﬁnition 3.6 just below;
(iii) g 2 B.fo1; : : : ; omg/: a non-quantiﬁed formula in the above variables, well-
typed for the rule type constraint .Eo W ET /, and called the guard of the rule;
(iv) a 2 A .fo1; : : : ; omg/: an assignment to an attribute of one of the above
variables, well-typed for the rule type constraint .Eo W ET /, and called the action
of the rule.
Deﬁnition 3.6. Given a rule r D .Eo; ET ; g; a/ involving a tuple of variables Eo D
.o1; : : : ; om/ and a tuple of type names ET D .T1; : : : ; Tm/, the rule type constraint
for r is the type constraint , also written .Eo W ET /, deﬁned by
Dom./ D fo1; : : : ; omg
and
.oj/ D Tj
for j D 1; : : : ; m .
Example. The following rule is made of two rule variables c and p, respectively
of type Cart and Person, a guard p:age > 60 ^ c:value > 1000, and an action
c:discount :D 10.
r.c W Cart; p W Person/ W p:age > 60 & c:value > 1000 * c:discount :D 10
All rules in the examples will be expressed in this self-explanatory concrete
syntax that provides the rule name, its variables and their types in parenthesis, and
its guard and action separated by an arrow.1
3.5.1
Rule Variables
The variables of a rule r D .Eo; ET ; g; a/ are those in the tuple Eo D .o1; : : : ; om/.
Their number m  0 can vary from rule to rule, and is called the arity of the rule,
also denoted jrj.
1In this book, an arrow is used in three situations: for logical implication, in the concrete syntax
of rules introduced here, and in guarded commands introduced in Chap. 7. Although the context
should make the meaning of arrows clear, we will use the regular arrow ! for logical implication,
and special arrows for the other two cases, namely * in rules and + in guarded commands.

3.5
Rules
41
The rule variables denote the objects that will be matched by the rule (as deﬁned
in Chap. 5). We refer to their set as var.r/ D fo1; : : : ; omg. They appear as variables
of the guard g and/or in the assignment performed in the action a. To avoid
spurious matches we require that var.r/ D var.g/ [ var.a/, that is, the tuple of
rule variables contains no extra variable.
The rule variables are in essence dummy variables, in the sense that their actual
names do not matter within the scope of one individual rule. As for the formal
parameters in a procedure deﬁnition, what matters is their number and their order. In
the previous example, the rule variables are named c and p, in reference to shopping
carts and persons, but could have any name.
Given a tuple Ex D .x1; : : : ; xm/ of m variables, we will write r.Ex/ for the rule
r where the variables o1; : : : ; om have been replaced by the variables x1; : : : ; xm,
respectively.
When several rules are considered together, it is important to be conscious that
the variables of each rule are distinct. Although it is a common practice, that we
will often adopt in examples, to reuse the variable names from rule to rule, an
unambiguous description of a set of rules will introduce distinct variable names
for each rule. For instance, the variables of two rules r1 D .Eo1; ET1; g1; a1/ and
r2 D .Eo2; ET2; g2; a2/ will be denoted Eo1 D .o1
1; : : : ; o1
m1/ and Eo2 D .o2
1; : : : ; o2
m2/.
The type names T1; : : : ; Tm provide a type constraint on the variables, that will
have to be complied with by the rule guard and action. The above comment on
variable names being distinct between rules applies to type names, with the type
names of some rule ri having to be denoted ETi D .T i
1 ; : : : ; T i
mi/. However, in a rule
program the same type name can, and usually will, occur several times as the type of
variables of several rules. It is the case in the rule program given as an example in
Sect. 3.6.
3.5.2
Rule Guard
The guard of a rule r D .Eo; ET ; g; a/ with Eo D .o1; : : : ; om/ is a non-quantiﬁed
formula g 2 B.fo1; : : : ; omg/. Its variables are all among the rule variables.
The guard is well-typed with respect to the rule type constraint .Eo W ET /, meaning
that it contains references to no other attribute of each variable oj than those
included in the deﬁnition of the type Tj, for j D 1; : : : ; m. In the previous example,
this implies that value 2 ˛.Cart/ and age 2 ˛.Person/.
As noted in Sect. 3.3.3, the guard of a rule is a ﬂat formula. This means that no
chains of attribute reference are allowed, and represents no loss in expressive power,
at the possible cost of introducing new rule variables.
As a result, all the objects involved in the guard of a rule are directly held by one
of the rule variables. This will make it easier to control interference between rules.

42
3
Syntax of Rules and Rule Programs
3.5.3
Rule Action
The action of a rule r D .Eo; ET ; g; a/ with Eo D .o1; : : : ; om/ is a single assignment,
of the form o1:fr :D er, where fr is some attribute symbol and er an expression that
involves the rule variables, their attributes, constants, etc. To simplify notations and
without loss of generality, we ﬁx that the object whose attribute is set in a rule action
is the one held by the ﬁrst rule variable o1.
The action is also well-typed with respect to the rule type constraint .Eo W ET /. In
the previous example, this additionally implies that discount 2 ˛.Cart/.
Contrary to the constraint imposed on rule guards to be ﬂat formulas, the
limitation of rule actions to only one assignment affects the expressive power of
rule programs. For example, a rule that implements a reset of a customer score
when upgrading its category could be expressed as follows:
r.p W Person/ W p:cat D Gold & p:score > 1000 * p:cat :D Plat I p:score :D 0
Yet this rule cannot be rephrased with one or several rules whose action is limited
to a single assignment.
The motivation for this restriction on the actions of rules is simpliﬁcation.
The work on correctness and veriﬁcation described in Parts III and IV is largely
independent of this aspect and could be reformulated for more complex rule actions,
at the cost of more complicated formulas [1].
3.6
Rule Programs
Deﬁnition 3.7. A rule program is a ﬁnite set of rules R D fr1; : : : ; rng with n  0.
Each rule ri (for i D 1; : : : ; n) has
(i) its own variables Eoi D .oi
1; : : : ; oi
mi/ and their types ETi D .T i
1 ; : : : ; T i
mi/, which
deﬁne the rule type constraint .Eoi W ETi/;
(ii) its own guard gi 2 B.foi
1; : : : ; oi
mig/, well-typed for .Eoi W ETi/; and
(iii) its own action ai 2 A .foi
1; : : : ; oi
mig/, well-typed for .Eoi W ETi/, of the form
ai  oi
1:fri :D eri.
Example. Consider the rule program R D fr1; r2; r3g composed of the following
rules:
r1.c W Cart; p W Person/ W p:age > 60 & c:value > 1000 * c:discount :D 10
r2.p W Person/ W p:cat D Gold * p:bonus :D 20
r3.c W Cart; p W Person/ W p:bonus > 15 & c:value > 2000 * c:discount :D 30

References
43
Here we followed the tradition, and reused variable names across the rules. How-
ever, when manipulating these rules together, we would distinguish the variables,
and for example describe the rules as follows:
•
Rule r1 is made of
– the variables Eo1 D .c1; p1/,
– the type names ET1 D .Cart; Person/,
– the guard g1  p1:age > 60 ^ c1:value > 1000, and
– the action a1  c1:discount :D 10.
•
Rule r2 is made of
– the variables Eo2 D .p2/,
– the type names ET2 D .Person/,
– the guard g2  p2:cat D Gold, and
– the action a2  p2:bonus :D 20.
•
Rule r3 is made of
– the variables Eo3 D .c3; p3/,
– the type names ET3 D .Cart; Person/,
– the guard g3  p3:bonus > 15 ^ c3:value > 2000, and
– the action a3  c3:discount :D 30.
Given a rule program R, we write var.R/ for the set that gathers all the variables
of all the rules of R. That is, if R D fr1; : : : ; rng with ri D .Eoi; ETi; gi; ai/ for each
i D 1; : : : ; n, we have
var.R/
def
D
n
[
iD1
foi
1; : : : ; oi
jri jg .
In the example above, we have var.R/ D fc1; c3; p1; p2; p3g.
References
1. Berstel-Da Silva, B.: Formalizing both refraction-based and sequential executions of production
rule programs. In: Bikakis, A., Giurca, A. (eds.) Rules on the Web: Research and Applications.
Lecture Notes in Computer Science, vol. 7438, pp. 47–61. Springer, Berlin (2012)
2. Kifer, M., Lausen, G., Wu, J.: Logical foundations of object-oriented and frame-based
languages. J. ACM 42(4), 741–843 (1995)

Chapter 4
States and State Assertions
The syntactic elements described in the previous chapter allow us to build rule
programs, as well as assertions for reasoning about them. In the present chapter,
we use ﬁrst-order logic structures and variable valuations to give a meaning to these
syntactic elements.
For the purpose of giving expressions a value, and formulas a truth value,
ﬁrst-order logic structures provide a semantic interpretation of constant symbols,
attribute symbols, and operators; variable valuations provide an object value for
each variable symbol.
We shall see that constant symbols and operators are interpreted in a classical
way, and that attribute symbols are interpreted by functions providing for each
object the value of the attribute. With this informal description of our semantics, let
us consider an example. (This example is discussed in a more complete description
in Sect. 4.1.5.)
Example. In all examples, including this one, we will use names such as Alice,
Bob, Alfa, or Beetle to denote objects; that is, concrete objects that are the values of
variables.
A valuation  assigning the object Alice to the variable q and the object Beetle
to the variable c is written
 W q 7! Alice
c 7! Beetle .
An example of a ﬁrst-order logic structure consists of the functions that interpret
each attribute symbol. Each such function maps the objects (Alice and the others)
onto values. Let us assume that the attribute symbols deﬁned by our type system
are age, car, and color. The ﬁrst-order logic structure s given below deﬁnes the
three corresponding functions, where ages denotes the function that interprets the
attribute symbol age, etc.:
B. Berstel-Da Silva, Veriﬁcation of Business Rules Programs,
DOI 10.1007/978-3-642-40038-4__4, © Springer-Verlag Berlin Heidelberg 2014
45

46
4
States and State Assertions
ages W Alice 7!21
cars W Alice7!Beetle
colors W Alfa7!Red
Bob 7!80
Bob 7!Alfa
Beetle 7!Yellow .
Carol7!75
Carol7!Alfa
The ﬁrst-order logic structure s and the variable valuation  above make the
formulas below valid:
'  c:color D Yellow
  8p 8w ..p:age > 60 ^ w D p:car/ ! w:color D Red/ ^ q:age D 21 .
This can be explained, still informally, as follows. The formula ' holds because
the value onto which  maps c is Beetle, and the image under colors of Beetle is
Yellow. In the formula  the ﬁrst, quantiﬁed conjunct is true because in s, all
persons over 60 own the car Alfa, the color of which is red; the second conjunct in
 is true because the valuation assigns the object Alice to the variable q, and the
age of Alice in s is 21.
4.1
States Are First-Order Logic Structures
A state is a ﬁrst-order logic structure. It provides a domain and an interpretation
function for constant symbols, attribute symbols, and operators. Throughout this
section, we deﬁne the domain and interpretation function of states, leading to the
formal deﬁnition of a state in Sect. 4.1.5.
A state and a valuation (deﬁned in Sect. 4.1.2) are enough to give expressions
a value, and formulas a truth value. In Sect. 4.4, we introduce another construction
on ﬁrst-order logic structures to describe, together with a valuation, the effect of a
statement.
4.1.1
Domain
The common domain for all the ﬁrst-order logic structures we will use is
D D
  [
, where
  is the object space and
 is the value space, as deﬁned below.
We write
  for the inﬁnite set of all objects. An object has a unique identity.
The identities of two objects can be compared for equality; no other operations are
available on the identities of objects.
We denote by
 the set of all (non-object) values considered, from Booleans
to application-speciﬁc values described by the ﬁxed theory  which acts as a
parameter of our rule language. In this chapter we give the interpretation of the
parameterized language, plus an interpretation of the theory used in examples,
including numbers and symbolic values.

4.1
States Are First-Order Logic Structures
47
4.1.2
Variable Valuations
Deﬁnition 4.1. A valuation is a function  W Var !
  assigning an object to each
variable symbol.
The role of a valuation in the interpretation of expressions and formulas is to
provide object values for variables.
As already mentioned when deﬁning variable symbols in Sect. 3.2, and as
formalized by the deﬁnition above, variables hold objects. Our rule language
does not include scalar, non-object variables. Allowing scalar variables as rule
variables (see Sect. 3.5.1) would diverge from the reality of rule programs as handled
by Business Rules Management Systems, where rules only match objects from
the working memory (deﬁned in the next chapter). Adding scalar variables to
expressions and formulas while forbidding them as rule variables is possible, but
would add little value to our rule language in terms of expressive power.
A common formalization of production rule programs uses the notion of
substitution to model a rule matching facts (see for example [3,4,9]). In these non-
object-oriented settings, facts are ground terms and a rule contains patterns, which
are non-ground terms; a rule is said to match a fact if there exists a substitution
that maps the patterns of the rule onto the fact (for positive patterns). Our setting
is not fundamentally different: as we shall see below, a state interprets the attribute
symbols that occur in the rule guard by functions; the valuations just deﬁned are
used to “ground” these functions on objects.
4.1.3
Interpretation of Expressions
Constants
The constant symbols for Booleans are interpreted by the corresponding Boolean
values. When needed, we write
 D ftrue; falseg for the set of Boolean values.
Numbers are interpreted by integral ones (from
) or real ones (from
)—or
complex ones, etc.—as speciﬁed by the ﬁxed theory . This choice has an impact
only when decidability or completeness comes into play; we will then discuss it.
The constant symbols for symbolic values (such as Red or Child) are inter-
preted by values with no other features than their identities. All symbolic values are
distinct, which is usually referred to as the Unique Name Assumption [8].
Also, symbolic values are not objects, and as such cannot be compared to them.
In some cases, such as completeness analysis of rule programs (see Sect. A.5.2),
symbolic values are grouped into enumerations, such as colors, genders, customer
categories, etc. Each enumeration is ﬁnite, which is usually referred to as the
Domain Closure Assumption (on each enumeration) [8].

48
4
States and State Assertions
Attributes
An attribute symbol f 2 Attr is interpreted in a state s by a function denoted Is.f /
or f s. This function is total, and deﬁned from
  to D [ f?g. The ? value is used
to deﬁne the function on objects that have no value for the attribute.1
Deﬁnition 4.2. Given a state s and an attribute symbol f , the domain of f in s is
the set of objects for which the function f s, which interprets the attribute symbol in
the state, has a non-? value. We write
Doms.f / D fO 2
  j f s.O/ ¤ ?g .
We impose as an additional constraint on our states that each attribute symbol
must have a ﬁnite domain, that is, the set of objects with a non-? value in a given
state must be ﬁnite for all attributes.
Attribute References
Given this interpretation of attribute symbols, the reference to an attribute of an
object is simply interpreted by the application of the corresponding function.
For example, in a state where the attribute symbol age is interpreted by a function
ages such that ages.Alice/ D 10, and under a valuation that maps p onto Alice, the
attribute reference p:age is given the value 10.
Numeric Expressions
Faced with the question of whether to interpret numbers in the mathematical
sense, or to treat them as machine numbers, with such behaviors as modularity or
rounding errors, we decide to follow the mathematical interpretation of operations
on numbers.
This decision is motivated by the focus of Business Rules Management Systems
toward domain experts rather than programmers, and the belief that the busi-
ness rules authors have this semantics in mind rather than the machine one. With
this choice, we favor ﬁnding errors in reasoning, such as x2 < 0, which is not
1An alternate, but equivalent, approach is taken in [2], where an attribute symbol f 2 Attr is
interpreted in a state s by a partial function f s, deﬁned on a ﬁnite subset of
  denoted Doms.f /.
Then, an expression or a formula cannot always be interpreted: given a state s and a valuation
, an expression e is interpretable in s under  if, for all  2 var.e/ and for all f 2 Ref.; e/, we
have ./ 2 Doms.f /. Similarly, a formula ' is interpretable in s under  if, for all  2 free.'/
and for all f 2 Ref.; '/, we have ./ 2 Doms.f /. In other words, the variables in the attribute
references of an expression or a formula must be mapped into the domains of the attribute symbols.
This approach has the advantage of saving the computation rules that deal with ?. On the other
hand, extra work is required for some quantiﬁed formulas to have a clean deﬁnition, such as the
transition assertion for an action, introduced in Sect. 4.5, and intensively used afterwards.

4.1
States Are First-Order Logic Structures
49
always false with machine numbers, over tracking behaviors related to the speciﬁcs
of machine implementations of numbers.
We augment the classical computation rules of number arithmetics with one rule
due to the introduction of the ? value. When one of the operands in an arithmetic
operation is ?, then the result of the operation is ?. Similarly when one of the
operands in an arithmetic operation is not a number. For example, ? C 3 and 5 
Blue both equal ?.
4.1.4
Interpretation of Formulas
Truth Value of a Formula
We say that a formula ' 2 F.V / holds in a given state s under a valuation 
when the interpretation function of the state deﬁned in this section, together with the
variable-to-object mapping deﬁned by the valuation, gives true as the truth value of
the formula. We write this s;  ˆ '.
For example, under a valuation  such that .p/ D Alice, and in a state s where
the attribute symbol age is interpreted by a function ages such that ages.Alice/ D
10, we have s;  ˆ p:age < 21.
The rest of this section deﬁnes the interpretation of formulas. This interpretation
provides a truth value for the formulas, by induction on their structure.
In addition, by ' )  we mean that for any state s and valuation , if s;  ˆ '
then s;  ˆ  . And by '
”  we mean that for any state s and valuation ,
s;  ˆ ' if and only if s;  ˆ  .
Typing Expression
Informally, the typing expression o W T expresses that the object held by o complies
with the deﬁnition given to the object type T by the type deﬁnition function ˛ of
the ﬁxed type system. The deﬁnition of a type is a set of attribute symbols; an object
complies with such a deﬁnition when exactly the attributes denoted by the attribute
symbols in the deﬁnition have a non-? value on the object.
Formally, let o be a variable and T be a type name. The Boolean expression o W T
holds in a state s under a valuation  if
for all f 2 ˛.T / and Nf 2 Attr n ˛.T / one has f s..o// ¤ ? and Nf s..o// D? .
Equalities
Object or symbolic value comparison is performed on their respective identities.
Numeric equality is deﬁned in the classical way. An equality mixing objects,
symbolic values or numbers (as in Blue D 2) is false.

50
4
States and State Assertions
In all three cases, if ? is involved in an equality, the equality is false if one side,
but not both, of the equality is ?. In other words,
? D ?
is true
for all x 2 D
x D ?
is false .
Inequalities Between Numbers
Inequalities (built with the comparison operators <, >, , ) between numbers
are deﬁned in the classical way. An inequality between a number and ? is always
false. An inequality between ? and itself is true only if using one of the non-strict
comparison operators  or .
With these computation rules in the presence of ?, the usual correspondences
between the comparison operators, such as x < y ” y > x or x  y ”
x D y _ x < y hold, with the exception of the correspondences for negated
comparisons (such as :.x < y/
”
x  y). These must be replaced with
the following ones:
:.x < y/ ” x D ? _ y D ? _ x  y
:.x > y/ ” x D ? _ y D ? _ x  y
:.x  y/ ” x ¤ y ^ .x D ? _ y D ? _ x > y/
:.x  y/ ” x ¤ y ^ .x D ? _ y D ? _ x < y/ .
Logical Connectors
The truth value of formulas built with the logical connectors :, ^, _, and ! is
deﬁned in the classical way, with ? being treated as false. The computation rules
for logical connectors in the presence of ? are thus:
?
is false
:?
is true
for all b 2
 [ f?g
? ^ b
is false
for all b 2
 [ f?g
? _ b
has the truth value of b
for all b 2
 [ f?g
? ! b
is true
for all b 2

b ! ?
is false .
Note that the only potential occurrence of ? as an operand of a logical connector
comes from a reference to an object attribute with a Boolean value.

4.1
States Are First-Order Logic Structures
51
Quantiﬁers
Let us consider some set of variables V  Var, as well as a formula ' 2 F.V / and
a variable  2 V .
The formula 8 ' holds in a state s under a valuation  if and only if ' holds in s
under all valuations that coincide with  on all other variables of V than . That is,
s;  ˆ 8 '
iff
s; 0 ˆ '
for every 0 s.t. 0./ D ./ for  2 V n fg .
The formula 9 ' holds in a state s under a valuation  if and only if ' holds in s
under at least one valuation that coincides with  on all other variables of V than .
That is,
s;  ˆ 9 '
iff
s; 0 ˆ '
for some 0 s.t. 0./ D ./ for  2 V n fg .
Typed Quantiﬁcation
Consider the quantiﬁed formula 8p .p:age > 21/. Per the deﬁnition of quantiﬁers
above, this formula holds in a state s and under a valuation  if and only if s; 0 ˆ
p:age > 21 for any valuation 0 that coincides with  on all other variables than p,
and takes an arbitrary value on p. Since  itself is arbitrary, the formula holds if
s; 0 ˆ p:age > 21 for every valuation 0; that is, if ages.O/ > 21 for every object
O 2
 .
It may happen that the given state s interprets the attribute symbol age as a
function that assigns a value greater than 21 to all objects in its domain. For all
the valuations 0 that map the variable p onto an object in Doms.age/, we then have
s; 0 ˆ p:age > 21. However, the interpretation of attribute symbols (in Sect. 4.1.3)
states that their domains are ﬁnite. Therefore, there exist valuations 0 such that
ages.0.p// D ?. As a result, 8p .p:age > 21/ never holds.
What is missing here for this simple quantiﬁed formula to avoid being trivially
invalid is the information that only a subset of the objects is to be considered, namely
a subset that is guaranteed to be included in the domain of age in s. Providing this
information is the intent of object types. Assume that the Person type has the age
attribute in its deﬁnition, the formula 8p .p W Person ! p:age > 21/ expresses
what was originally intended.
Such a case is so common that we deﬁne an abbreviation for it. Given a formula
' 2 F.V /, a variable  2 V , and a type name T 2 Types:
(i) we write 8 W T ' as an abbreviation for 8 . W T ! '/;
(ii) we write 9 W T ' as an abbreviation for 9 . W T ^ '/.

52
4
States and State Assertions
4.1.5
States
Deﬁnition 4.3. A state is a ﬁrst-order logic structure s D .D; Is/ over the
signature ˙, whose domain D is deﬁned in Sect. 4.1.1, and whose interpretation
function Is conforms with the deﬁnitions of Sects. 4.1.3 and 4.1.4.
Example. Let us consider again the introductory example, this time in its full
description:
Types D fPerson; Carg
˛.Person/ D fage; carg
˛.Car/ D fcolorg
Var D fp; q; w; x; : : : g
  D fAlice; Bob; Carol; Alfa; Beetle; : : : g
 D f: : : ; 2; 1; 0; 1; 2; : : : ; Red; Yellow; : : : g
'  8p W Person 8w W Car ..p:age > 60 ^ w D p:car/ ! w:color D Red/
^ q:age D 21 .
The formula ' has only q as a free variable. The following state and valuation make
it valid:
s W ages W Alice 7!21
cars W Alice7!Beetle
colors W Alfa7!Red
Bob 7!80
Bob7!Alfa
Beetle 7!Yellow
Carol7!75
Carol7!Alfa
otherwise7!?
otherwise7!?
otherwise7!?
 W
q 7! Alice
otherwise 7! anything .
From the deﬁnition of s above follows the composition of the sets of objects of
each type, which are used for interpreting the quantiﬁed sub-formulas:
objects of type Person:
fAlice; Bob; Carolg
objects of type Car:
fAlfa; Beetleg .
The formula ' would not be made valid if, for example, one of the following
variations was made from the s and  deﬁned above:
•
Setting .q/ D Bob would cause q:age D 21 to have the truth value of 80 D 21,
that is, false.

4.2
State Assertions
53
•
Setting ages.Alice/ D Red would cause q:age D 21 to have the truth value of
Red D 21, that is, false.
•
Setting colors.Alfa/ D Yellow would cause w:color D Red to be false, for
example for p D Bob.
4.2
State Assertions
4.2.1
Assertions
State assertions, or in short assertions, are formulas from F.Var/ as deﬁned in
Sect. 3.3, that is, ﬁrst-order, ﬂat, possibly quantiﬁed formulas.
As such, they are given a truth value by a state and a valuation, as deﬁned
in Sect. 4.1.4. The state is used to interpret the attribute symbols in the formula,
and the valuation to assign an object to each variable. Note however that, in the
valuation, only the values given to the free variables of the formula matter. This will
be leveraged later, and is formalized in Lemma 4.1 below.
Lemma 4.1. If an assertion ' 2 F.Var/ holds in a state s under a valuation ,
then it holds in s under any valuation 0 that coincides with  on free.'/.
Another practical fact is that the truth value of an assertion does not change
when a free variable of the assertion is renamed. This property is formalized in
Lemma 4.2, where the notation 'Œ= has the standard meaning of “the formula '
in which  is substituted for all occurrences of .”
Lemma 4.2. Let ' 2 F.Var/ be an assertion, let  2 free.'/ be a free variable of
the assertion, and let  2 Var n var.'/ be a fresh variable. The assertion ' holds
in a state s under a valuation , if and only if the assertion 'Œ= holds in s under
the valuation 0, such that 0./ D ./ and 0 coincides with  on all other free
variables of '.
Proofs. Both lemmas are proven by induction on the structure of formulas, as
deﬁned in the grammar in Fig. 3.1. We prove for each derivation that an expression
(resp. a formula), has the same value (resp. truth value) in s under  or 0, taking
into account the variable renaming in the case of the second lemma.
ut
4.2.2
Global Assertions
Deﬁnition 4.4. A global assertion is a formula from the language F.;/.
A global assertion is a closed, quantiﬁed, ﬂat ﬁrst-order formula. An example is
8p W Person 8c W Car ..p:age > 60 ^ c D p:car/ ! c:color D Red/ .

54
4
States and State Assertions
Strictly speaking, both a state and a valuation should be used to give a truth value
to a global assertion. Yet, since a global assertion is a closed formula, Lemma 4.1
indicates that any valuation can be used, and it is usually omitted.
We thus say that a global assertion ' holds in a given state s if and only if this
state, together with any valuation, makes the formula valid. We write this s ˆ '.
For example, for any state s we have: s ˆ 8p .p:age > 21 ! p:age  0/.
4.2.3
Assertions Focused on a Rule
One often needs to express properties of the values in a given state of attributes of
the objects matched by a rule. For this purpose, we introduce assertions focused on
a rule. These assertions have no free variables other than the variables of the rule,
and are well-typed with respect to the rule type constraint.
Deﬁnition 4.5. Given a rule r D .Eo; ET ; g; a/ with Eo D fo1; : : : ; omg, an assertion
' is focused on r if
(i) ' 2 F.fo1; : : : ; omg/, and
(ii) ' is well-typed with respect to .Eo W ET /.
We then write ' 2 F.r/.
Given a rule r of arity m, an assertion ' focused on r, and a tuple Ex D
.x1; : : : ; xm/ of m variables, we will write '.x1; : : : ; xm/ or '.Ex/ for the assertion
' where the variables o1; : : : ; om have been replaced by the variables x1; : : : ; xm,
respectively: '.Ex/ D 'Œxj =ojm
j D1.
4.3
Transition Assertions
The purpose of assertions on transitions between states, or transition assertions, is
to express a property on the relationship between two states, such as the initial state
and the ﬁnal state in the execution of a rule or rule program.
Depending on the way one looks at the transition, that is, from the viewpoint of
the initial or of the ﬁnal state, a given property can be expressed in two ways. To this
end, we deﬁne forward and backward transition assertions, a concept introduced for
example in [6].
4.3.1
Forward Transition Assertions
Classically [5], we start by extending the set of attribute symbols Attr with new
attribute symbols obtained by adding a prime to each attribute symbol in Attr. We
write AttrC for the extended set:

4.3
Transition Assertions
55
AttrC def
D Attr [ ff 0 j f 2 Attrg .
We then introduce forward transition assertions as the ﬁrst-order, ﬂat, possibly
quantiﬁed formulas as deﬁned by the same grammar presented in Fig. 3.1 that
deﬁnes the F.Var/ language, but where attribute symbols are taken from AttrC
instead of just Attr. For a set V  Var of variables, we write F C.V / for the set
of forward transition assertions in the variables of V .
A forward transition assertion is thus a formula that contains primed and
unprimed attribute symbols. An example is
8p .p:age < 60 ^ p:bonus0 > q:bonus/ _ q:age > 21 .
Like all of our formulas, a forward transition assertion is to be interpreted by a
ﬁrst-order logic structure and a valuation. Here, the ﬁrst-order logic structure has to
provide an interpretation for both primed and unprimed attribute symbols. This can
be achieved with state pairs deﬁned as follows.
Deﬁnition 4.6. Given two states s1 and s2, the state pair based on s1 and s2, denoted
hs1; s2i, is the ﬁrst-order logic structure with the domain D common to both states,
and an interpretation function that can offer two interpretations for each attribute
symbol in Attr. Other syntactic constructs are interpreted in the way common to
both states, deﬁned in Sect. 4.1.
We say that a forward transition assertion ' holds in a state pair hs1; s2i under
a valuation , or that ' holds between s1 and s2 under , if the ﬁrst-order logic
structure hs1; s2i where each unprimed attribute symbol is interpreted in s1 and
each primed attribute symbol is interpreted in the same way as the corresponding
unprimed attribute symbol in s2, together with the valuation , make ' valid. We
write this hs1; s2i;  ˆ '.
A forward transition assertion relates initial values of attributes of objects,
denoted by unprimed attribute symbols, to their ﬁnal values, denoted by primed
attribute symbols.
Example. The transition assertion
'  p:bonus0  p:bonus C 5
is made valid by a state pair hs1; s2i and a valuation  that satisﬁes for example
.p/ D Alice
bonuss1.Alice/ D 20
bonuss2.Alice/ D 23 .
The meaning of ' as a transition assertion is that the bonus of the object held by p
is not incremented by more than 5 during the transition.

56
4
States and State Assertions
4.3.2
Backward Transition Assertions
We deﬁne another extension of the set of attribute symbols by adding a quote in
front of each attribute symbol in Attr. We write Attr for this other extension:
Attr def
D Attr [ f0f j f 2 Attrg .
The symbol 0f is usually pronounced “old f ”.
Backward transition assertions are ﬁrst-order, ﬂat, possibly quantiﬁed formulas
as deﬁned by the grammar presented in Fig. 3.1, but where attribute symbols are
taken from Attr instead of Attr. For a set V  Var of variables, we write F .V /
for the set of backward transition assertions in the variables of V . As mentioned
previously, a backward transition assertion is simply another way at looking at the
same property as the forward transition assertion obtained by replacing unprimed
attribute symbols with primed ones, and quoted ones with unprimed ones.
An example of a backward transition assertion (equivalent to the ﬁrst example of
a forward transition assertion) is
8p .p:0age < 60 ^ p:bonus > q:0bonus/ _ q:0age > 21 .
A backward transition assertion relates initial values of attributes of objects,
denoted by quoted attribute symbols, to their ﬁnal values, denoted by unprimed
attribute symbols. We say that a backward transition assertion ' holds in a state pair
hs1; s2i under a valuation , or that ' holds between s1 and s2 under , if the ﬁrst-
order logic structure hs1; s2i where each quoted attribute symbol is interpreted in the
same way as the corresponding unprimed attribute symbol in s1 and each unprimed
attribute symbol is interpreted as in s2, together with the valuation , make it valid.
We write this hs1; s2i;  ˆ '.
4.3.3
Global Transition Assertions
Global (forward or backward) transition assertions are closed transition assertions,
that is, formulas in F C.;/ or F .;/. As for other closed assertions, we omit the
valuation when interpreting global transition assertions, writing hs1; s2i ˆ ' when
the global transition assertion ' holds between s1 and s2.
Examples of global assertion transitions are
8p .p:bonus0  p:bonus C 2/
8p 8c .p:0cat D Gold ^ c:0value > 1000 ! c:discount > c:0discount/ .

4.4
Semantics of Assignment
57
A frequently used global transition assertion is the one that states the identity
between two states, that is, the fact that all attributes have the same values on
all objects in both states. Here is this transition assertion, as a forward then as a
backward assertion:
IdC def

^
f 2Attr
8o .o:f D o:f 0/
Id def

^
f 2Attr
8o .o:0f D o:f / .
4.4
Semantics of Assignment
In Sect. 3.4, we deﬁned the syntax of the assignment of a value to an attribute of
an object. The effect of an assignment, when executed in a given state and under
a given valuation, is to produce a new state. More generally, an assignment as a
statement deﬁnes a relation between states.
The state produced by the execution of an assignment coincides with the initial
state, except on the interpretation of the attribute that is assigned to, where it
coincides with the updated attribute, as deﬁned below. This deﬁnition follows the
approach of [7], also described in detail in [1, pp. 42–45].
4.4.1
Update of an Attribute
Deﬁnition 4.7. Given an attribute symbol f 2 Attr, a variable o 2 Var, and an
expression e 2 E .Var/, the update of f on o by e is the attribute denoted f Œo 7! e,
and interpreted in a state s and under a valuation  by the function f Œo 7! es

deﬁned as follows for any O 2
 :
f Œo 7! es
.O/ D
 Is.eŒ./=2Var/ if O D .o/
f s.O/
otherwise .
An alternate notation for f Œo 7! e is 	x:if x D o then e else x:f . Note that
the equality x D o here is a semantic one, as opposed to a syntactic one: what is to
be tested is not whether the variables have the same names, but whether the objects
referred to by the variables are in fact the same object or not. This information
will be given by the valuation that comes with the state in the interpretation of the
updated attribute.
Example. Consider the attribute value, to be updated on the variable o by the
expression e  o:value 	 p:bonus.

58
4
States and State Assertions
Consider also the following state s and valuation :
s W bonuss W Alice7!2
values W Caddie7!50
Bob 7!3
Shopper7!80
Carol7!4
otherwise7!?
otherwise7!?
 W o 7! Caddie
p 7! Carol
otherwise 7! anything .
The attribute valueŒo 7! e will be interpreted as follows in s under :
valueŒo 7! es
 W Caddie 7! 200
Shopper 7! 80
otherwise 7! ? .
4.4.2
Executing an Assignment
Consider an assignment a  o:f :D e, where o is a variable, f is an attribute
symbol, and e is an expression. The free variables in this statement are o plus the
free variables of e.
The execution of this assignment in a state s under a valuation  produces a new
state s0 where:
(i) The domains of s and s0 are D; the interpretations of all constant symbols and
operators are the same in s and s0.
(ii) The interpretations of all attribute symbols except f are the same in s and s0.
That is, for any g 2 Attr n ff g we have gs0 D gs.
(iii) The attribute symbol f is interpreted in s0 the same as f Œo 7! e is interpreted
in s under .
We write s
.a;/
! s0 for the fact that s0 is the state produced by the execution of
the assignment a in s under .
Example. Consider the assignment o:value WD o:value 	 p:bonus, executed
in the state s and under the valuation  introduced in the previous example. This
execution produces the state s0 deﬁned as follows:
s0 W bonuss0 W Alice 7!2
values0 W Caddie7!200
Bob 7!3
Shopper7!80
Carol7!4
otherwise7!? .
otherwise7!?

4.5
Rule Guard and Action
59
4.4.3
Assignment as a Relation Between States
Given two states s and s0, we would like to say that there is an execution of an
assignment a leading from s to s0 if there exists a valuation , such that s0 is the
state produced by the execution of the assignment a in s under . That is,
s
a! s0
iff
there exists  s.t. s
.a;/
! s0 .
However, since there is an inﬁnite number of variables and objects, there is an
inﬁnite number of valuations, and hence in general an inﬁnite number of states
resulting from the execution of an assignment in a given state. Practically, only a
ﬁnite number of state pairs in the relation that deﬁnes the semantics of an assignment
are interesting, namely the ones that preserve the non-? values of attributes.
To restrict the deﬁnition of s
a! s0 to only the relevant instances .a; /, we need
the notion of well-typed valuation, which is introduced in Sect. 5.2.3. The deﬁnition
of assignment as a relation between states is therefore given in Sect. 6.3.1, as part
of the semantics of loop-less sequential programs. However the semantics of an
assignment given in Sect. 4.4.2 is already enough to give a meaning to a rule action,
as done in the next section.
4.5
Rule Guard and Action
4.5.1
Rule Guard
A rule r D .Eo; ET ; g; a/ is deﬁned in Sect. 3.5 as consisting of a tuple of variables, a
tuple of type names, a guard, and an action. The tuple of variables Eo D .o1; : : : ; om/
and the tuple of type names ET D .T1; : : : ; Tm/ have the same arity m. The rule
action a 2 A .fo1; : : : ; omg/ is discussed in the next section.
The rule guard g 2 B.fo1; : : : ; omg/ is a ﬁrst-order, ﬂat, non-quantiﬁed formula.
The rule variables and type names form a type constraint .Eo W ET /, for which g has to
be well-typed.
It follows from this deﬁnition that the guard of a rule is an assertion focused on
the rule, as deﬁned in Sect. 4.2.3: g 2 F.r/.
4.5.2
Rule Action
As indicated in Sect. 3.5.3, the action of a rule is a single assignment. An extended
syntax and semantics of rule actions is provided in [2] for sequences of assignments.
More generally, a rule action could be extended to a sequential program, as
described in the literature [1], or in Chaps. 6 and 7.

60
4
States and State Assertions
For the sake of simplicity, we consider rule actions made of a single assignment
of an attribute of the object held by the ﬁrst rule variable. That is, in a rule r D
.Eo; ET ; g; a/ the action is a  o1:fr :D er with fr 2 ˛.T1/ and er 2 E .fo1; : : : ; omg/.
The rule action a is well-typed for the rule type constraint .Eo W ET /.
The semantics of the rule action is the one described in Sect. 4.4: the state s0 that
results from the execution of a in a state s and under a valuation  interprets all
attributes other than fr in the same way as s, and interprets fr as s interprets the
updated attribute frŒo1 7! er.
This relationship s
.a;/
! s0 can be described by a transition assertion linking the
initial and ﬁnal states s and s0 under the valuation :
hs; s0i;  ˆ 8o .o:f 0
r D .	x:if x D o1 then er else x:fr/.o//^
^
f 2Attrnffr g
8o .o:f 0 D o:f /
which can be rewritten as hs; s0i;  ˆ Oa, where Oa is the transition assertion for the
action a, as deﬁned below.
Deﬁnition 4.8. Given a rule r D .Eo; ET ; g; a/ with Eo D .o1; : : : ; om/ and a 
o1:fr :D er, the transition assertion for the action a of the rule r is
Oa
def
 o1:f 0
r D er ^ 8o .o ¤ o1 ! o:f 0
r D o:fr/ ^
^
f 2Attrnffr g
8o .o:f 0 D o:f / .
This transition assertion is a forward transition assertion in the rule variables:
Oa 2 F C.var.r//. It is by construction well-typed for the rule type constraint .Eo W ET /.
Example. Consider the following rule:
r.p W Person/ W p:age > 10 * p:bonus :D p:age  10
In a setting where the attribute symbols deﬁned by our type system are age and
bonus, the transition assertion for the action of this rule is
p:bonus0 D p:age  10 ^ 8o .o ¤ p ! o:bonus0 D o:bonus/ ^ 8o .o:age0 D o:age/ .
References
All URLs were successfully accessed on January 22, 2013.
1. Apt, K.R., de Boer, F.S., Olderog, E.R.: Veriﬁcation of Sequential and Concurrent Programs,
3rd edn. Texts in Computer Science. Springer, Berlin (2009)
2. Berstel-Da Silva, B.: Formalizing both refraction-based and sequential executions of production
rule programs. In: Bikakis, A., Giurca, A. (eds.) Rules on the Web: Research and Applications.
Lecture Notes in Computer Science, vol. 7438, pp. 47–61. Springer, Berlin (2012)

References
61
3. Cirstea, H., Kirchner, C., Moossen, M., Moreau, P.É.: Production systems and Rete algorithm
formalisation. Research report, LORIA, Nancy (2004). http://hal.inria.fr/inria-00280938/PDF/
rete.formalisation.pdf
4. Fages, F., Lissajoux, R.: Sémantique opérationnelle et compilation des systèmes de production.
Revue d’Intelligence Artiﬁcielle 6(4), 431–456 (1992)
5. Lamport, L.: The temporal logic of actions. ACM Trans. Program. Lang. Syst. 16(3), 872–923
(1994)
6. Manna, Z., Pnueli, A.: Completing the temporal picture. In: Ausiello, G., Dezani-Ciancaglini,
M., Ronchi Della Rocca, S. (eds.) ICALP. Lecture Notes in Computer Science, vol. 372,
pp. 534–558. Springer, Berlin (1989)
7. Morris, J.M.: A general axiom of assignment. In: Bauer, F.L., Dijkstra, E.W., Hoare, C.A.R.
(eds.) Theoretical Foundations of Programming Methodology: Lecture Notes of an International
Summer School. Reidel, Dordrecht (1982)
8. Russell, S.J., Norvig, P.: Artiﬁcial Intelligence: A Modern Approach, 3rd edn. Prentice Hall,
Upper Saddle River (2009)
9. de Sainte Marie, C., Hallmark, G., Paschke, A.: Rule Interchange Format, Production Rule
Dialect. Recommendation, W3C (2010). http://www.w3.org/TR/rif-prd/

Chapter 5
Operational Semantics of Rule Programs
In Business Rules Management Systems, and more generally in production systems,
a rule program is executed by a machine called a rule engine, on a set of objects
called the working memory [2]. Execution of a rule program consists of a sequence
of applications of rule instances, that is, the execution of rule actions on objects that
make the rule guards valid.
In this chapter, we build on the previous two chapters to deﬁne the working
memory, rule instances, and rule execution, and ﬁnally an abstract machine that
describes the execution of a rule program. The operational semantics that we deﬁne
differs from previous formalizations of production systems [3, 4, 12], in that we
differentiate eligibility and applicability of a rule instance. The applicability of a
rule instance relates to whether the rule guard is valid on the objects in the instance,
whereas the eligibility of a rule instance is determined by the rule instances executed
so far by the rule engine. This distinction between eligibility and applicability allows
us to describe other execution strategies than the historical Rete algorithm.
After an informal presentation of the notions at stake in the execution of rule
programs, we formally deﬁne the abstract machine that models rule engines.
5.1
Rule Program Execution, Informally
Declarative Programs
Rule programs belong to the category of declarative programming paradigms, in the
sense that the text of a rule program is a collection of independent statements (the
rules), and does not make explicit the control ﬂow, that is, how the statements are to
be combined upon execution of the program.
Rule programs share this aspect with parallel programs, where the processes
composing the program are combined upon execution by a scheduler that is not
explicit in the program. A given parallel program might even admit distinct sets of
executions if it is run using different schedulers.
B. Berstel-Da Silva, Veriﬁcation of Business Rules Programs,
DOI 10.1007/978-3-642-40038-4__5, © Springer-Verlag Berlin Heidelberg 2014
63

64
5
Operational Semantics of Rule Programs
In contrast, imperative programs contain in their texts the control structures that
dictate the combination of their statements.
Rule Engine
The rule engine is the mechanism that conducts the execution of a rule program.
Like the schedulers of parallel programs, a rule engine can adopt variations in its
behavior. These variations are collectively referred to as the execution strategy, and
basically arbitrate between several possible sequences of rule executions.
On a given data set and under a given execution strategy, a rule program will in
practice always exhibit the same execution. This behavior is mandatory for actual
rule engines, on which the logic of business-critical applications is based, so that
rule programs have reproducible executions. It is however interesting, from the
viewpoint of program analysis and veriﬁcation, to allow a degree of nondeterminism
in the execution strategy. It is the case with the execution strategies described in
Sects. 5.5 and 5.6: when using these abstract execution strategies, a rule program
can have several possible executions on a given data set.
Working Memory
A feature of rule programs is that not only their texts have a declarative form, but
the data on which they are executed as well.
When an imperative or a parallel program is executed on a given data set,
the components of the programs (statements, processes) are instantiated: each
variable is given a unique initial value taken from the data set. The instances of
the components are then combined for execution, either linearly or in parallel.
In contrast, when a rule program is executed on a given data set, the rule engine
creates multiple instances of each rule. It then combines all the rule instances
according to its execution strategy. The data set on which a rule program is executed
is a collection of objects, and is called the working memory. It is formally deﬁned
in Sect. 5.2 below, and rule instances are deﬁned in Sect. 5.3.1.
This way of feeding data into a program by saturation on a working memory is
not the classical way of executing other kinds of program. It is rather typical for
paradigms described in Sect. 2.1, such as deductive databases and rule programs.
However, execution by saturation is general enough to be deﬁned for parallel
programs and nondeterministic programs, as we do in the next chapter.
Execution
In Fig. 5.1, we summarize the work performed by a rule engine. Of course, the
mechanisms given in this ﬁgure and in the description below are implemented in an

5.1
Rule Program Execution, Informally
65
Rules
Objects
Form Rule Instances
Rule Instances
Filter
Applicable
Filter
Eligible
Conﬂict Set
Selection
Strategy
Selection
Apply
Selection
Eligibility
Strategy
Update Working Memory
Fig. 5.1 Execution of a rule program by a rule engine
optimized manner by the rule engines found in actual Business Rules Management
Systems.
The execution of a rule program is composed of a series of rule instance
applications. The role of the rule engine is to combine the rules in the rule program
and the objects in the working memory to form rule instances, then to assess their
applicability in the current state, and to evolve this current state by executing the
actions of chosen rule instances. All these notions are explained in detail below and
are formally deﬁned later in this chapter.
The ﬁrst task of the rule engine is to form rule instances by assembling the rules
in the program and the objects found in working memory. The resulting set of rule
instances is ﬁltered in two independent ways. On the one hand, the applicability
of each rule instance in the current state is assessed. This amounts to determining,
for each rule instance, the truth value of the guard of the rule on the objects in the
instance. On the other hand, the eligibility of each rule instance is tested.
The eligibility of rule instances is a notion used by rule engines to avoid trivial
loops due to the repeated execution of rule instances whose application produces a
state where the rule instance is still applicable. An example of such a trivial loop is
given by the rule r.p W Person/ W p:age > 21 * p:bonus WD 10. If an instance
of this rule is applicable once, it remains applicable after it has been applied.
Deﬁning that at some point the rule instance is not eligible for execution although
its guard might hold, is a way to avoid its endless application. Knowing which rule
instances are eligible at a given moment is deﬁned by the eligibility strategy of the
engine.

66
5
Operational Semantics of Rule Programs
Once the applicability and eligibility of all rule instances have been indepen-
dently assessed, the conﬂict set is formed with the rule instances that are both
applicable and eligible.
The next task of the rule engine is to apply its selection strategy (also called the
conﬂict set resolution strategy), to choose from the conﬂict set a rule instance that
shall be applied. In Sect. 5.5, we will see that a selection strategy is often based on
an order deﬁned on rule instances. As a consequence, it is common to implement the
conﬂict set as an ordered list; it is then called the agenda. The rule instance chosen
by the selection strategy is either named the selection or, as a result of the previous
remark, the head of the agenda.
It can happen however that there is no head of the agenda, either because the
conﬂict set is empty, that is, no rule instance is both applicable and eligible, or
because the selection strategy retained none of them. In this case, the execution of
the rule program terminates, with the current state of the engine as the resulting state
of the execution.
If there is a head of the agenda, then the rule engine executes the action of this
rule instance. The effect of this execution is twofold. Firstly, it updates the current
state with the state that results from the execution of the statements in the rule action.
In our setting, that is the assignment of a new value to an attribute of an object.
This update might have an effect on the applicability of some rule instances. More
generally the action of a rule might also insert new objects into the working memory,
or remove objects from it, which might additionally affect the list of rule instances to
be ﬁltered. Secondly, it updates the eligibility of the rule instances according to the
engine’s eligibility strategy. The rule engine then starts again, updating the conﬂict
set, selecting a new head of the agenda, etc.
Properties of Executions
As noted, the execution of a rule program is subject to the choices implemented in
the selection and eligibility strategies. These strategies are formally deﬁned further
below in this chapter, and several examples of each are given. They are collectively
referred to as the execution strategy of the engine.
The selection strategy mainly controls whether only one, or several, or even
many, executions of a rule program are possible on a given working memory. As
already mentioned, implementations of rule engines must ensure that the execution
of a rule program on a given working memory can be repeated. More generally,
properties similar to those of schedulers of parallel programs, such as fairness, are
involved for selection strategies.
The eligibility strategy mainly inﬂuences the termination of rule programs, with
some strategies having the property of ensuring the termination of all rule programs.

5.2
Working Memory
67
5.2
Working Memory
We informally described the working memory earlier as the set of objects on which
a rule program is executed. In this section, we establish a link between the (inﬁnite)
set of all objects and the type system underlying our formalism. These deﬁnitions
allow us to consider objects as instances of types, and to deﬁne the working memory
as the collection of all instances of all types. In addition, we will see that the working
memory is ﬁnite and constant over rule program executions (in terms of the objects
it contains).
5.2.1
Type-System Compliant States
In Chap.3, we ﬁxed and deﬁned a type system T D .Types; ˛/, which introduces
the set Types of type names and the type deﬁnition function ˛ that maps type names
onto sets of attribute symbols.
In Sect. 3.3.2, we also deﬁned a type constraint as being a partial function
associating a type name with each variable in its domain. We additionally deﬁned
well-typed expressions and formulas for a type constraint , as those including only
attribute references (of the form o:f ) in which the attribute symbol belongs to the
deﬁnition of the type associated with the variable by the type constraint (that is,
f 2 ˛..o//).
Finally, in Sect. 3.5, we introduced rules of the form r D .Eo; ET ; g; a/, where
the tuple of variables Eo and the tuple of type names ET constitute a type constraint
denoted .Eo W ET /, for which g and a must be well-typed.
We deﬁne below ﬁrst the attribute span of an object in a state, then the notion of
a type-system compliant state.
Deﬁnition 5.1. Given an object O 2
  and a state s, the attribute span of O in s,
denoted ˛s.O/, is the set of attribute symbols for which O has a non-? value in s.
That is,
˛s.O/ D ff 2 Attr j f s.O/ ¤ ?g
The attribute span of an object is a symmetric notion to the domain of an attribute
symbol introduced in Sect. 4.1.3. It also corresponds to what is sometimes called the
effective type of an object.
Deﬁnition 5.2. A state s is T -compliant, or compliant with the type system T , if
all objects with a non-empty attribute span in s match the deﬁnition of a type in the
type system. That is, for any O 2
 , either ˛s.O/ D ;, or there exists T 2 Types
such that ˛s.O/ D ˛.T /.
Example. Examples of compliant and non-compliant states are included in the
example of the next section.

68
5
Operational Semantics of Rule Programs
In states that are T -compliant, we can consider objects as instances of types, as
deﬁned below.
5.2.2
Objects as Instances of Types
Deﬁnition 5.3. Given a type name T 2 Types and a T -compliant state s, the insta-
nces of T in s, denoted Ms.T /, are the objects whose attribute span in s matches
the deﬁnition of T . That is,
Ms.T / D fO 2
  j ˛s.O/ D ˛.T /g .
From the requirement stated in Sect. 4.1.3 that attribute symbols must have a
ﬁnite domain in any state, it follows that the set of instances of a type is ﬁnite.
In addition, we stated in Sect. 3.3.2 the requirement for type deﬁnitions to be
disjoint, that is, for any two distinct type names T1; T2 2 Types, we have ˛.T1/ \
˛.T2/ D ;. (We noted there that this does not reduce our expressivity, and is
usually made transparent to the user through some mangling process performed by
the language compiler.) It follows from this requirement that the sets of instances of
two distinct types are disjoint as well.
As a consequence, if the attribute span of an object in a given state matches the
deﬁnition of a type, this type is unique. We can therefore say that T is the type of
an object O in a T -compliant state s, if O 2 Ms.T /.
Note that, for a T -compliant state s and a valuation , we have s;  ˆ o W T if
and only if .o/ 2 Ms.T /. Also, to assess whether s;  ˆ 8 W T ' holds, it sufﬁces
to assess whether s; 0 ˆ ' holds for all 0./ 2 Ms.T / where 0 coincides with 
on the other variables.
Deﬁnition 5.4. Given a state s, the working memory in s is the set of objects with
at least one non-? attribute value in s. We denote it by Ms and we thus have
Ms
def
D fO 2
  j there exists f 2 Attr s.t. f s.O/ ¤ ?g .
The fact that the working memory is ﬁnite in any state derives from the
requirement that attribute symbols must have a ﬁnite domain in any state. It can
also be derived from the following equivalent deﬁnitions of the working memory in
a (T -compliant where required) state s:
Ms D
[
f 2Attr
Doms.f /
— union of the domains of all attributes;
Ms D fO 2
  j ˛s.O/ ¤ ;g
— all objects with a non-empty attribute span;
Ms D
]
T 2Types
Ms.T /
— disjoint union of the instances of all types.

5.2
Working Memory
69
Example. Let us consider the following setting:
Attr D f: : : ; age; car; color; mileage; : : : g
Types D fPerson; Carg
˛.Person/ D fage; carg
˛.Car/ D fcolor; mileageg
  D fAlice; Bob; Alfa; Beetle; : : : g
s D
ages W Alice 7! 21
cars W Alice 7! Alfa
Bob 7! 50
Bob 7! Beetle
Alfa 7! ?
Alfa 7! ?
Beetle 7! ?
Beetle 7! ?
otherwise 7! ?
otherwise 7! ?
colors W Alice 7! ?
mileages W Alice 7! ?
Bob 7! ?
Bob 7! ?
Alfa 7! Yellow
Alfa 7! 60 000
Beetle 7! Red
Beetle 7! 25 000
otherwise 7! ?
otherwise 7! ? .
We have
˛s.Alice/ D fage; carg
˛s.Alfa/ D fcolor; mileageg
˛s.Bob/ D fage; carg
˛s.Beetle/ D fcolor; mileageg .
Therefore s is T -compliant and we have
Ms.Person/ D fAlice; Bobg
Ms.Car/ D fAlfa; Beetleg
Ms D fAlice; Bob; Alfa; Beetleg .
The state s would not have been T -compliant if, for example, we had deﬁned
ages.Alfa/ D 12 or mileages.Beetle/ D ?.
5.2.3
Preservation Properties
The preservation properties below involve the execution of an assignment. They will
be extended to the execution of a rule, and of a rule program, once these are deﬁned.
For all these properties the lemma below is crucial: it states the preservation of
attribute spans when executing an assignment under a well-typed valuation, which
we ﬁrst deﬁne.

70
5
Operational Semantics of Rule Programs
Deﬁnition 5.5. Given a type constraint  and a T -compliant state s, a valuation 
is well-typed for  in s if  maps each variable of the domain of  onto an instance
of the type associated with the variable by . That is,
for all  2 Dom./ we have ./ 2 Ms..// .
Example. In the context of the previous example, consider the variables p and c,
and the following valuation and type constraint:
 W
p 7! Alice
c 7! Beetle
otherwise 7! anything
 W
p 7! Person
c 7! Car .
This valuation  is well-typed for  in s.
Since the set of instances of a type is ﬁnite, there is only a ﬁnite number of well-
typed valuations for a type constraint with a ﬁnite domain, in a given state (up to the
values given by the valuations to variables outside of the type constraint domain).
Lemma 5.1. Let s be a T -compliant state,  be a type constraint, and  be a
valuation well-typed for  in s. Let a 2 A .Dom.// be an assignment well-typed
for , and s0 be the state that results from the execution of a in s under .
Then the attribute span of any object is the same in s0 as in s, that is, for any
O 2
  we have ˛s0.O/ D ˛s.O/.
Proof. Let the domain of the type constraint  be Dom./ D fo1; : : : ; omg. Consider
an object O 2
  and assume that a  o1:f :D e. What follows derives from the
semantics of assignment as deﬁned in Sect. 4.4.
If O ¤ .o1/ then for any attribute symbol h 2 Attr we have hs0.O/ D hs.O/.
As a result we have ˛s0.O/ D ˛s.O/.
If O D .o1/ then f s0.O/ D Is.eŒ.oj/=ojm
j D1/. Since e is well-typed for 
and  is well-typed for  in s, we have f s0.O/ ¤ ?. On the other hand, since a is
well-typed for  we have f 2 ˛.T1/, and since  is well-typed for  in s we have
˛s.O/ D ˛.T1/, and hence f 2 ˛s.O/, that is, f s.O/ ¤ ?. In addition, for any
h 2 Attr n ff g we have hs0.O/ D hs.O/. As a result we have ˛s0.O/ D ˛s.O/.
ut
It results directly from this lemma that an assignment preserves the properties
for states to be type-system compliant and for valuations to be well-typed; it also
preserves the instances of types and the working memory.
Proposition 5.2. Let s be a T -compliant state,  be a type constraint, and  be a
valuation well-typed for  in s. Let a 2 A .Dom.// be an assignment well-typed
for , and s0 be the state that results from the execution of a in s under .
Then s0 is T -compliant, and  is well-typed for  in s0. In addition, the set of
instances of any type is the same in s and in s0; the working memory is the same in
s and in s0.

5.3
Rule Execution
71
Let us note that, since the working memory is a set of objects, saying that it is
the same in two states s and s0 “only” means that the same objects make up the
working memory in these two states. However, the values of the attributes of these
objects may differ in s and s0, as these values are the result of the interpretation of
the attribute symbols by s and s0.
5.3
Rule Execution
A rule is a component of a rule program. As such, its instances are combined by the
rule engine to form an execution of the rule program. The rule as a statement is also
interesting from the viewpoint of the relation that it establishes between states.
In this section we deﬁne rule instances, when they are applicable and how they
are applied; we also deﬁne the effect of executing a rule.
5.3.1
Rule Instance
Deﬁnition 5.6. Given a rule r of arity m, a rule instance R D .r; O1; : : : ; Om/ is
a .m C 1/-tuple made of the rule r and m objects from
 . The objects O1; : : : ; Om
are not necessarily pairwise distinct. We say that R is an instance of rule r on the
objects O1; : : : ; Om.
The rule instance .r; O1; : : : ; Om/ is also sometimes written .r; EO/, with EO D
.O1; : : : ; Om/.
In addition, given a rule r D .Eo; ET ; g; a/ with Eo D .o1; : : : ; om/, and a valuation
, we write .r; / for the rule instance .r; .o1/; : : : ; .om//. In particular, given two
valuations  and 0 that coincide on Eo, the notations .r; / and .r; 0/ refer to the
same rule instance.
5.3.2
Applicability of a Rule Instance
We say that a rule instance is applicable, or that the rule is applicable to the objects
in the instance, when the guard of the rule is valid on the objects. As deﬁned below,
this depends on the state considered.
Deﬁnition 5.7. Given a rule instance R D .r; O1; : : : ; Om/ with r D .Eo; ET ; g; a/
and a state s, R is applicable in s if for any valuation  that maps each variable oj
onto the object Oj for j D 1; : : : ; m, we have s;  ˆ g.
From Lemma 4.1, we know that it sufﬁces to ﬁnd one valuation  that maps each
oj onto Oj for j D 1; : : : ; m, and such that s;  ˆ g, to decide that the rule instance

72
5
Operational Semantics of Rule Programs
is applicable in s. Conversely, it sufﬁces to ﬁnd one valuation  that maps each oj
onto Oj for j D 1; : : : ; m, and such that s;  6ˆ g, to know that the rule instance is
not applicable.
Example. The rule r below states that, provided the customer is old enough, a tenth
of the value of his cart should be added to his bonus.
r.p W P; c W C/ W p:age  50 & p D c:owner * p:bonus :D p:bonus C c:value = 10
In this rule, the variables are .p; c/ and the guard is p:age  50 ^ p D c:owner.
Consider the following setting:
  D fAlice; Bob; Caddie; : : : g
Attr.T / D fage; bonus; owner; valueg
s1 D
ages1 W Alice 7!61
bonuss1 W Alice 7!30
Bob 7!80
Bob 7!10
otherwise7!?
otherwise7!?
owners1 W Caddie7!Alice
values1 W Caddie7!500
otherwise7!?
otherwise7!? .
In this setting the rule instance .r; Alice; Caddie/ is applicable in s1, since s1;  ˆ
p:age  50 ^ p D c:owner for any valuation  that maps p onto Alice and c onto
Caddie. On the other hand, the rule instance .r; Bob; Caddie/ is not applicable in s1
because owners1.Caddie/ ¤ Bob.
5.3.3
Application of a Rule Instance
In a state where a rule instance is applicable, the application of the rule instance
produces a new state, deﬁned below. The application of a rule instance in a state
where it is not applicable is not deﬁned.
Deﬁnition 5.8. Given a state s, a rule r D .Eo; ET ; g; a/, and a rule instance R D
.r; O1; : : : ; Om/ applicable in s, the state that results from the application of R in s
is the state s0, such that hs; s0i;  ˆ Oa for any valuation  that maps each variable oj
onto the object Oj for j D 1; : : : ; m.
Let us recall the deﬁnition given in Sect. 4.5 of the transition assertion Oa for the
action of a rule r D .Eo; ET ; g; a/ with a  o1:fr :D er:
Oa
def
 o1:f 0
r D er ^ 8o .o ¤ o1 ! o:f 0
r D o:fr/ ^
^
f 2Attrnffr g
8o .o:f 0 D o:f / .

5.3
Rule Execution
73
Example. Applying the rule instance .r; Alice; Caddie/ from the previous example
in the state s1, results in a state s2 deﬁned by the following transition assertion for
any  such that .p/ D Alice and .c/ D Caddie:
hs1; s2i;  ˆ p:bonus0 D p:bonus C c:value = 10
^ 8o .o ¤ p ! o:bonus0 D o:bonus/ ^
^
f 2Attrnfbonusg
8o .o:f 0 D o:f / .
This deﬁnes s2 as follows:
ages2 W Alice 7! 61
bonuss2 W Alice 7! 80
Bob 7! 80
Bob 7! 10
otherwise 7! ?
otherwise 7! ?
owners2 W Caddie 7! Alice
values2 W Caddie 7! 500
otherwise 7! ?
otherwise 7! ? .
The transition assertion Oa deﬁnes the state s0 uniquely for a given state s and
a given valuation . By Lemma 4.1 again, the transition assertion also uniquely
deﬁnes s0 for a given s and any valuation that coincides with  on the free variables
of Oa. Note that each of the conjuncts in Oa has a different set of free variables:
•
The free variables in o1:f 0
r D er are fo1g[var.er/, which can span fo1; : : : ; omg.
•
The free variables in 8o .o ¤ o1 ! o:f 0
r D o:fr/ are limited to fo1g.
•
Finally, V
f 2Attrnffr g 8o .o:f 0 D o:f / has no free variables.
This implies that, when s0 is the state that results from the application of the rule
instance .r; O1; : : : ; Om/ in s, we have in particular
hs; s0i ˆ
^
f 2Attrnffrg
8o .o:f 0 D o:f /
which depends only on the rule r, and not on the objects O1; : : : ; Om in the rule
instance; and
hs; s0i;  ˆ 8o .o ¤ o1 ! o:f 0
r D o:fr/
for any  that maps o1 onto O1
which depends only on r and O1.
5.3.4
Execution of a Rule Instance
We have just deﬁned the application of a rule instance, which is possible only when
the rule instance is applicable. The execution of a rule instance covers in addition
the case where the rule instance is not applicable.

74
5
Operational Semantics of Rule Programs
Deﬁnition 5.9. Given a state s, and a rule instance R, the state that results from the
execution of R in s is the state that results from the application of R in s if R is
applicable in s, or s itself otherwise.
Considering a rule instance .r; O1; : : : ; Om/ with r
D .Eo; ET ; g; a/, and a
valuation  such that .oj/ D Oj for j D 1; : : : ; m, the deﬁnition above means
that the state s0 is deﬁned as follows:
(i) if s;  ˆ g, then hs; s0i;  ˆ Oa;
(ii) if s;  ˆ :g, then s0 D s;
This deﬁnition is correct because s;  6ˆ g is equivalent to s;  ˆ :g, according
to the interpretation deﬁned in Sect. 4.1; and because Lemma 4.1 prevents us from
having both s;  ˆ g for some  such that .oj/ D Oj for j D 1; : : : ; m, and
s;  ˆ :g for some others.
The execution of a rule instance in a given state thus always leads to one resulting
state, whether the rule instance is applicable or not.
Given two states s and s0, and a rule instance R (applicable in s or not), we denote
by s
R! s0 the fact that s0 is the state that results from the execution of R in s.
Example. Considering the rule r and the states s1 and s2 introduced in the previous
examples, we have
s1
.r;Alice;Caddie/
! s2
s1
.r;Bob;Caddie/
! s1 .
5.3.5
Executions of a Rule
A rule is executed during the execution of a rule program by the application of
one of its instances, if it is applicable. If we consider all the possible executions of
instances of a rule from a given state, we obtain a description of the effect of this
rule on the state. For the instances of the rule that are applicable in the state, the
effect will be to produce a new state; and for the instances that are not applicable,
the effect will be to remain in the same state.
To discard trivially inapplicable instances, we will only consider rule instances
that are well-typed in the initial state of execution, as deﬁned below.
Deﬁnition 5.10. Given a rule r D .Eo; ET ; g; a/ and a T -compliant state s, the set
of well-typed object tuples for r in s is the Cartesian product of the sets of instances
of the types constraining the rule variables, that is,
M .r/
s
def
D Ms.T1/ 	 
 
 
 	 Ms.Tm/ .

5.3
Rule Execution
75
In addition, the rule instance .r; O1; : : : ; Om/ is well-typed in s if .O1; : : : ; Om/ is
a well-typed object tuple for r in s.
Given a valuation , we have introduced in Sect. 5.3.1 the notation .r; / as an
equivalent to .r; .o1/; : : : ; .om//. We have also deﬁned in Sect. 5.2.3 the notion of
a valuation well-typed for a type constraint in a given state. We can note that a rule
instance .r; / is well-typed in a state s if and only if  is well-typed for .Eo W ET / in s.
Deﬁnition 5.11. Given a rule r and two states s and s0, there is an execution of r
leading from s to s0 if there exists an instance R of r well-typed in s, such that s0
results from the execution of R in s. That is,
s
r! s0
iff
there exists EO 2 M .r/
s
s.t. s
.r; EO/
! s0 .
We also say that s0 results from the execution of r in s.
Example. Considering again the rule r and the states s1 and s2 introduced in
the previous examples, we have s1
r! s1 and s1
r! s2, which derive from the
executions of the rule instances .r; Bob; Caddie/ and .r; Alice; Caddie/, respectively.
But we also have s2
r! s2 since .r; Bob; Caddie/ is not applicable in s2 either. And
furthermore s2
r! s3 where s3 differs from s2 only in that bonuss3.Alice/ D 130.
This pattern repeats indeﬁnitely.
The deﬁnition of the execution of a rule has a few equivalent formulations, and
yields the following remarks. Let us consider a rule r D .Eo; ET ; g; a/, two T -
compliant states s and s0, and a valuation  well-typed for .Eo W ET / in s:
•
Either we have s;  ˆ g, and then we have s
r! s0, where s0 is deﬁned by
hs; s0i;  ˆ Oa; or we have s;  ˆ :g, and then we have s
r! s.
•
Conversely, we have s
r! s0 if there exists an instance R of r well-typed in s,
that is applicable in s and whose application results in s0 (which can be distinct
from s or not). And we have s
r! s if there exists an instance R of r well-typed
in s, that is not applicable in s.
•
Since the set of instances of a type in s is ﬁnite, there are ﬁnitely many well-typed
object tuples for r in s, and there is also a ﬁnite number of possible executions of
r in s.
•
The only case where there is no execution of r in s is when there is no instance
of r well-typed in s, that is, if M .r/
s
D ;. Indeed, if an instance of r well-typed
in s can be formed, then executing this instance gives an execution of r, either to
a new state if the instance is applicable, or to s itself otherwise.
Also, the preservation properties stated in Sect. 5.2.3 hold on rule instances and
rule executions.

76
5
Operational Semantics of Rule Programs
Proposition 5.3. Let r D .Eo; ET ; g; a/ be rule, s be a T -compliant state, and  be
a valuation well-typed for .Eo W ET / in s. The state s0 that results from the execution of
the rule instance .r; / in s is T -compliant, and  is well-typed for  in s0.
Proof. If .r; / is applicable in s, then the state s0 is deﬁned by hs; s0i;  ˆ Oa. By
Proposition 5.2, s0 is T -compliant, and  is well-typed for  in s0.
If .r; / is not applicable in s, then s0 D s. Then s0 is T -compliant and  is
well-typed for  in s0 by hypothesis.
ut
More generally, any state that results from an execution of a rule in a
T -compliant state is T -compliant, and a chain of executions of well-typed rule
instances that starts in a T -compliant state contains only T -compliant states.
Along this chain, the working memory and the instances of types are constant. In
this context we can omit the state in the notations, and write M for the working
memory and M .T / for the instances of type T .
As noted in Sect. 5.2.3, saying that a set of objects such as M or M .T / is
constant along a chain of rule instance executions simply means that no object is
added to, or removed from, the set. It makes no statement on the values of the
attributes of these objects, which may change during these executions.
5.4
Rule Program Execution
As announced, we deﬁne the operational semantics (in the sense of [10]) of a rule
program by using transitions between conﬁgurations of an abstract machine.
5.4.1
Conﬁgurations
The abstract machine that we use to describe the semantics of rule programs has
conﬁgurations of the form hE; si, where s is a T -compliant state and E is a set of
rule instances well-typed in s. In a given conﬁguration, s represents the current state
and E the set of eligible rule instances.
We describe the semantics of the execution of a rule program from a given
state by deﬁning the initial conﬁguration of the abstract machine and the possible
transitions between conﬁgurations.
5.4.2
Initial Conﬁguration
As suggested by the deﬁnition of a conﬁguration of our abstract machine, we are
going to consider only the executions of a rule program that start in a T -compliant

5.4
Rule Program Execution
77
state. Let us recall that a state is T -compliant if each object either has a ? value
for all its attributes in this state, or the set of attributes for which it has a non-?
value (the attribute span of the object) matches the deﬁnition of a type in the type
system T .
In the initial conﬁguration for the execution of a rule program, all rule instances
are eligible. This is admittedly an arbitrary choice, and the set of initially eligible
rule instances could be a component of the eligibility strategy. However, it is not
necessary, for the eligibility strategies that we consider, to include the set of initially
eligible rule instances in the deﬁnition of an eligibility strategy.
We write RIs.R/ for the set of all the instances of rules from the rule program R
that are well-typed in s, that is,
RIs.R/ D f.r; EO/ j r 2 R; EO 2 M .r/
s g .
With this deﬁnition, the initial conﬁguration for the execution of a rule program
R in a T -compliant state s0 is hRIs0.R/; s0i.
5.4.3
Transition Between Conﬁgurations
A transition between two conﬁgurations of our abstract machine can occur by the
application of a rule instance. This rule instance must be retained by the selection
strategy among the instances that are both applicable and eligible. The resulting
conﬁguration is made of the state that results from the application of the rule
instance, and of the set of eligible rules updated according to the eligibility strategy.
The above is expressed by the following transition rule. The details of the
notations used in this rule are given just below; in short, As and E respectively
denote the sets of applicable and eligible rule instances, S and E are the selection
and eligibility strategies, and R is the rule instance that is applied in the transition.
R 2 S .As \ E/
s
R! s0
E0 D E .E; : : : /
hE; si
R! hE0; s0i
(5.1)
In this transition rule we write As for the set of all rule instances applicable in
the state s:
As
def
D fR 2 RIs.R/ j R applicable in sg .
The set As \ E thus denotes the conﬂict set, that is, the set of rule instances that
are both applicable and eligible in hE; si. The selection strategy S is a function
that computes a subset of the conﬂict set that we call the selection, and which is
the abstract counterpart to the “head of the agenda” of the concrete rule engines
described in Sect. 5.1. The selection is a set of rule instances—whereas the head

78
5
Operational Semantics of Rule Programs
of the agenda is unitary. With this choice we abstract away some implementation-
dependent aspects of the selection strategies of rule engines that do not participate
in the semantics of the rule program.
As a consequence, there can be several candidate rule instances for a transition
from the current conﬁguration; all of them will be considered, leading to several
possible executions of the rule program. In each possible transition, the state s0 is
the one that results from the application in the initial state s of the rule instance
considered.
The eligibility strategy E is also a function that takes and returns a set of rule
instances. It produces the set of eligible rule instances in the resulting conﬁguration
from the corresponding set in the initial conﬁguration and possibly additional
arguments depending on each eligibility strategy.
The selection strategy and the eligibility strategy are parameters of the opera-
tional semantics of rule programs. Together, they are referred to as an execution
strategy. They must be ﬁxed in order for the transition system of our abstract
machine to describe the execution of a rule program. In Sect. 5.5 we present some
common selection strategies; in Sect. 5.6 we present some common eligibility strate-
gies. In Sect. 6.1.1, we ﬁx the execution strategy that we will use from Chap. 6 on.
5.4.4
Executions of a Rule Program
A transition sequence is a sequence of conﬁgurations where each conﬁguration
is obtained from the previous one by an application of the transition rule. Such a
sequence can be ﬁnite or inﬁnite. A transition sequence that cannot be extended is
called maximal.
Deﬁnition 5.12. An execution of a rule program R from a T -compliant state s0
under the selection strategy S and the eligibility strategy E is a maximal transition
sequence by the transition rule (5.1) from the initial conﬁguration hRIs0.R/; s0i.
Given two states s and s0 and a rule program R, we write s
R=S ;E
! s0 when
there is an execution of R under the selection strategy S and the eligibility strategy
E , that starts in s and results in s0. When either of S or E , or both, are ﬁxed they
can be omitted from the notation.
Since the execution of a rule program starts in a T -compliant state and contains
only well-typed rule instances, all states in the execution are T -compliant, and the
working memory M , the sets of instances of each type, and the set of well-typed
rule instances RI.R/, are constant along the execution. (Again, a constant working
memory means that the objects in the set are the same. The values of the attributes
of these objects may change.)
It can also be noted that the executions of a program R D frg reduced to only
one rule, are not the same as the executions of r as a rule, as deﬁned in Sect. 5.3.5.
Indeed, considering two T -compliant states s and s0, we have s
r! s0 when s0

5.4
Rule Program Execution
79
results from the execution of one instance of r in s, whereas we have s
R
! s0
when s0 results from the execution of all the instances of r on M . In addition, the
executions of R will depend on the chosen execution strategy, which has no effect
on the execution of r.
Example. Let us consider the rule program R D fr1; r2g:
r1.p W Person/W p:age < 21 * p:score :D p:score C 10
r2.p W Person/W p:score > 35 * p:score :D p:score = 2
and the following initial conﬁguration:
M D Ms0.Person/ D fAlice; Bobg
s0 D ages0 W Alice 7! 10
scores0 W Alice 7! 20
Bob 7! 30
Bob 7! 40
E0 D f.r1; Alice/; .r1; Bob/; .r2; Alice/; .r2; Bob/g .
Let us deﬁne a ﬁctive execution strategy made of the selection strategy Sﬁc and
the eligibility strategy Eﬁc deﬁned below:
Sﬁc.C/ D
(
C \ finstances of r1g
if non empty
C \ finstances of r2g
otherwise
Eﬁc.E; k/ D finstances of ri j i > k=2g
after k transitions .
In the initial conﬁguration hE0; s0i the applicable rule instances are
As0 D f.r1; Alice/; .r2; Bob/g
since ages0.Alice/ D 10 < 21 and scores0.Bob/ D 40 > 35, but ages0.Bob/ D
30  21 and scores0.Alice/ D 20  35. As all rule instances are eligible in the
initial conﬁguration, the conﬂict set is equal to As0.
The application of the selection strategy Sﬁc to As0 retains only the instances
of r1, leaving only .r1; Alice/ in the selection. The application of this rule instance
causes a transition to hE1; s1i with
s1 D ages1 W Alice 7! 10
scores1 W Alice 7! 30
Bob 7! 30
Bob 7! 40
E1 D finstances of ri j i > 1=2g
D f.r1; Alice/; .r1; Bob/; .r2; Alice/; .r2; Bob/g .
The applicable rule instances in s1 are As1 D f.r1; Alice/; .r2; Bob/g again,
which leads to the same conﬂict set, and again only .r1; Alice/ in the selection.

80
5
Operational Semantics of Rule Programs
The application of this rule instance causes a transition to hE2; s2i with
s2 D
: : :
scores2 W Alice 7! 40
: : :
E2 D finstances of ri j i > 1g D f.r2; Alice/; .r2; Bob/g .
The applicable rule instances are As2 D f.r1; Alice/; .r2; Alice/; .r2; Bob/g in
this conﬁguration, since the scores of both Alice and Bob are greater than 35.
The conﬂict set is therefore As2 \ E2 D f.r2; Alice/; .r2; Bob/g, and is returned
untouched as the selection by the selection strategy.
We have here a selection that contains two elements, and hence two possible
transitions from hE2; s2i, by either of these rule instances. Let us denote by
hEAlice
3
; sAlice
3
i and hEBob
3
; sBob
3
i the conﬁgurations that result from the transition by
.r2; Alice/ and by .r2; Bob/, respectively. For any P 2 fAlice; Bobg we have
sP
3 D
: : :
scoresP
3 W P 7! 20
: : :
EP
3 D finstances of ri j i > 3=2g D f.r2; Alice/; .r2; Bob/g .
Let us denote by P 0 the other person than P . In either conﬁguration hEP
3 ; sP
3 i,
the only applicable and eligible rule instance is .r2; P 0/, and it is retained by Sﬁc.
From either conﬁguration the transition by this rule instance leads to hE4; s4i, with
s4 D ages4 W Alice 7! 10
scores4 W Alice 7! 20
Bob 7! 30
Bob 7! 20
E4 D finstances of ri j i > 2g D fg .
In this conﬁguration, the set of applicable rule instances is reduced to As4 D
f.r1; Alice/g, but this rule instance is not eligible since none is. The conﬂict set and
hence the selection are empty. Both executions stop, with s4 as their ﬁnal state.
As a summary, we have s0
R=Sﬁc;Eﬁc
! s4 as the rule program R used in this
example admits two executions under the ﬁctive execution strategy deﬁned for this
example. These two executions start in the state s0 and result in the state s4. They
are:
.r1; Alice/
.r1; Alice/
.r2; Alice/
.r2; Bob/
.r1; Alice/
.r1; Alice/
.r2; Bob/
.r2; Alice/ .
Note also that the same rule instance .r1; Alice/ was applied twice in the
transitions hE0; s0i ! hE1; s1i and hE1; s1i ! hE2; s2i; this happened because
the rule instance was applicable in both s0 and s1, and the eligibility strategy did
not remove it from the set of eligible rule instances until E2. One of the major roles
of the eligibility strategy is to avoid trivial loops in rule program execution, with
the meaning of “trivial” varying from one strategy to another. Some strategies even
ensure that all executions of a rule program terminate.

5.5
Selection Strategies
81
5.5
Selection Strategies
When several rule instances are both applicable and eligible in a given state, the
choice of which to apply to perform the transition to the next conﬁguration is the
role of the selection strategy. Since the set of applicable and eligible rule instances is
called the conﬂict set, the selection strategy is also called the conﬂict set resolution
strategy.
The selection strategies used in practice by rule engines are deterministic: they
ensure that, when applied in a given state to a given conﬂict set, they will always
return the same rule instance. This behavior is of course required for real executions
of rule programs to be reproducible. However, to ensure this, rule engines need to
resort to criteria such as the name of the rule or its position in a program source ﬁle,
which have no actual meaning in the logic of the program, and might even be out of
the control of the rule author.
This is why veriﬁcation systems for rule programs use abstracted selection
strategies, which ignore these additional practical criteria, and which consider that
the outcome of the selection strategy is a set of rule instances. This can lead a rule
program to have several executions on the abstract machine. All these executions
can have the same termination status, and if terminating, can lead to the same ﬁnal
state. Or not.
With this choice of using abstracted selection strategies, veriﬁcation systems for
rule programs might report errors (non-conﬂuences) that would not actually occur
in practice, but that reﬂect a ﬂaw in the rule program design, because its execution
depends on internal, technical choices of the rule engine. This feature is analogous to
the choice of interpreting numbers in the mathematical sense, versus using machine
arithmetics.
In our formalization, a selection strategy is thus a function that takes a set of rule
instances (the conﬂict set) and returns a subset of this set (the selection).
In most cases, selection strategies deﬁne an order on rule instances, and return
the maximal elements of the conﬂict set according to this order. When the order is
not strict, the returned selection can contain several elements. A selection strategy
might also be deﬁned by the lexicographic combination of various orders.
The simplest selection strategy performs no ﬁltering of the conﬂict set. We call it
the identity strategy. In this strategy we have
Sid.C/ D C .
Here are various orders that are commonly used to deﬁne selection strategies
[2,9]:
•
Priority on rule instances. For this order, a rule r D .Eo; ET ; g; a/ is additionally
equipped with a numerical expression 
r 2 E .fo1; : : : ; omg/ well-typed for
.Eo W ET /. The order is based on the value of this expression for each rule instance
in the current state.

82
5
Operational Semantics of Rule Programs
•
Priority on rules. This order is a simpliﬁed version of the previous one, where
the expressions 
r are numerical constants. The priority of all instances of a rule
r is then equal to the number 
r, independently of the state.
•
Strict ordering of the rules. A strict order is deﬁned on the rules, for example by
setting the rule priorities to a permutation of f1; : : : ; ng.
•
Speciﬁcity of the rules. A rule r1 is said to be more speciﬁc than another rule r2
when one has g1 ) g2, where gi is the guard of ri. This deﬁnes a partial order on
rules. Some rule engines approximate this order by using empirical indications
of the rule speciﬁcity, such as the number of elementary Boolean expressions in
the rule guard, or the arity of the rule.
•
Recency. This order is based on a numerical constant associated with each object
in the working memory, called the object recency, with the idea that objects have
been inserted into the working memory in some order. The recency of a rule
instance is given by the maximal recency of the objects in the rule instance.
5.6
Eligibility Strategies
Classical production rule systems such as OPS5 do not consider selection and
eligibility as separate strategies [1, 2, 9]. Instead, their “conﬂict set resolution
strategies” are a composition of several selection strategies listed in the previous
section, such as speciﬁcity or recency, and usually also include refraction, although
the latter has an eliminating effect whereas the former have a selecting effect.
We choose to distinguish the selection strategy from the eligibility strategy in our
abstract machine, both because the two strategies are often independent, and so that
we can more easily consider alternatives to refraction.
The notion of rule instance eligibility has the objective of avoiding trivial loops as
illustrated on p. 65. The role of the eligibility strategy is to update the set of eligible
rules, which is part of the conﬁguration of the abstract machine.
We deﬁne the eligibility strategy as a function that returns the set of eligible rule
instances for the conﬁguration that results from the transition. The arguments to the
eligibility strategy as a function vary with the deﬁnition of each strategy. However
most strategies can be deﬁned with the set of eligible rules before the transition, the
rule instance that caused the transition, the initial and ﬁnal states of the transition,
and the initial state of the program execution.
Another representation of an eligibility strategy, proposed by Ahmed Bouajjani
(Personal communication, 2008), uses an automaton to describe the evolution of
a rule instance during an execution of the rule program. The accepting states of
this automaton correspond to conﬁgurations of the abstract machine in which the
rule instance is eligible. The transitions of the automaton depend on criteria that
are similar to the possible arguments to the eligibility strategy seen as a function,
such as the rule instance that caused the abstract machine transition or the ﬁnal state
of this transition. Each of the eligibility strategies described further below in this
section is also represented by such an automaton.

5.6
Eligibility Strategies
83
any R
This automaton describes the eligibility of a rule instance (r,n) and its evolution upon transitions
of the abstract machine by a rule instance R.
Under the identity eligibility strategy, a rule instance is initially eligible and remains eligible
during the whole rule program execution, no matter which rule instances are applied. This gives
an automaton with only one state. This state is the initial state and is accepting. A transition of the
abstract machine by any rule instance leaves the automaton in this state.
Fig. 5.2 Identity eligibility strategy
As for selection strategies, several eligibility strategies exist in rule engine
implementations. We formalize them below. What makes the difference between
eligibility strategies is how drastic they are in declaring a rule instance ineligible.
Some strategies make rule instances ineligible only if they have been applied, while
others may make rule instances ineligible even if they have not been applied;
some strategies never make rule instances eligible again once they have been made
ineligible, while others allow such rule instances to be included again in the set of
eligible ones.
The effect of these variations is on the termination of rule program executions.
If the strategy allows rule instances to become eligible again, it makes it possible
to have inﬁnite executions. Conversely, an eligibility strategy where the set of
eligible rules strictly decreases on each transition will ensure the termination of all
executions. On the other hand, a strategy that is very drastic in making rule instances
ineligible prevents rule programs from implementing complex reasoning based on
inference and interactions between rules.
5.6.1
Identity Eligibility Strategy
The simplest eligibility strategy imposes no ﬁlter on the rule instances: in any
conﬁguration,all rule instances that can be formed from the rules in the rule program
and objects in the working memory are eligible. We call it the identity strategy. It
can be deﬁned equivalently by
Eid.E/ D RI.R/
or
Eid.E/ D E .
This eligibility strategy will almost always lead to inﬁnite executions, including
trivial ones like inﬁnite application of always the same rule instance. Exceptions will
occur when the action of a rule invalidates its guard, as well as variants involving
cross-invalidation between rules. For this reason it is not used in practice, and its
principal interest is illustrative (Fig. 5.2).

84
5
Operational Semantics of Rule Programs
5.6.2
Refraction Eligibility Strategy
The refraction eligibility strategy is the one at work in the Rete algorithm [3,4,7,12]
used in most major rule engine implementations. In the traditional presentation of
this algorithm [1,6], refraction is just one step of the algorithm, whereas we describe
it as an eligibility strategy, and we would collect together the other steps as the
selection strategy.
The refraction eligibility strategy includes cases where rule instances become
eligible again after having been made ineligible. As a consequence, this strategy
does not guarantee termination of executions. On the other hand, it makes it possible
to implement complex inference-based algorithms with rule programs.
It can be noted that this ability has been of lesser use recently, as rule programs
tend to be used more and more to implement algorithms that are less and less
stateful. Although the Rete algorithm can still properly execute these less stateful
rule programs, other execution strategies such as the sequential one have been
introduced, targeting these rule programs with more efﬁcient implementations. The
sequential execution strategy is described in Sect. 5.6.3; a comparison between this
strategy and refraction is given in [1].
As mentioned in the RIF-PRD recommendation [12]: The essential idea of
refraction is that a given instance of a rule must not be ﬁred more than once as
long as the reasons that made it eligible for ﬁring hold. Refraction thus states that,
once executed, a rule instance cannot be re-executed before it becomes inapplicable,
and then of course applicable again. Let us illustrate this statement with the example
below, before transposing it into an eligibility strategy.
Example. Consider the rule program R D fr1; r2g:
r1.p W Person/W p:age < 21 * p:score :D p:score C 10
r2.p W Person/W p:score > 25 * p:score :D p:score = 2
and the following initial conﬁguration:
Ms0 D Ms0.Person/ D fAliceg
s0 D ages0 W Alice 7! 10
scores0 W Alice 7! 40
E0 D f.r1; Alice/; .r2; Alice/g .
In this initial state, both rule instances .r1; Alice/ and .r2; Alice/ are eligible and
applicable. Consider the execution where .r2; Alice/ gets executed. This sets Alice’s
score to 20, which invalidates the guard of r2 on Alice. The only applicable rule
instance .r1; Alice/ is then executed, causing Alice’s score to be set to 30. The
refraction strategy states that .r2; Alice/ can then be executed again.
The refraction eligibility strategy states that a rule instance becomes ineligible
when executed, and becomes eligible again as soon as it becomes inapplicable
(Fig. 5.3).

5.6
Eligibility Strategies
85
true
s,n
n
|= g
any R
any R
s,
̸|= g
any R
any R
any R
This automaton describes the eligibility of a rule instance and its evolution upon transitions of
the abstract machine. Each state of the automaton is annotated with a condition (expressed on the
state of the abstract machine) that is required to hold for a transition to this state to be possible.
Under the refraction eligibility strategy, a rule instance (r,n
n
n
n
) with r = (o
Æ
Æ
,T,g,a) is initially
eligible and subsequently becomes or remains eligible when a rule instance R (possibly (r, )
itself) is applied and brings the abstract machine into a state s where the rule instance (r, ) is
applicable, that is, such that s,
|= g. This gives an automaton with an accepting initial state, and
two other states corresponding to the cases where the rule instance considered is applicable or
not. The state where the rule instance is not applicable is accepting.
Fig. 5.3 Refraction eligibility strategy
The strategy is thus deﬁned as follows, in a transition hE; si
R! hE0; s0i:
Erefraction.E; R; s0/ D E n fRg [ fR0 2 RI.R/ j R0 is not applicable in s0g .
The refraction eligibility strategy underlines the difference between the applica-
bility and the eligibility of a rule instance. The deﬁnition of Erefraction above states
that all inapplicable rule instances are eligible after each transition. Actually this
adds to the set of already eligible rule instances only the ones that satisfy the two
following conditions:
(i) The rule instance has been applied at least once in this rule program execution,
as the rule instances that have never been applied have remained eligible since
the initial conﬁguration of the rule program execution.
(ii) The rule instance was applicable up until the initial conﬁguration of the
transition, otherwise it would have been added during a previous transition.
In other words, the rule instances added are exactly the ones that have already been
applied in this execution, and that have been made inapplicable by the last transition.
Of course, these newly eligible rule instances will be in the conﬂict set only when
their guards are valid again, but that is not the role of the eligibility strategy and, as
far as eligibility is concerned, the guard turning invalid is sufﬁcient.
This mechanism ensures that once executed, a rule instance will not be executed a
second time before it becomes ﬁrst inapplicable and then applicable again, as stated
by the Rete algorithm.
Example. Consider the same rule program and conﬁguration as in the previous
example. The initial set of eligible rules is

86
5
Operational Semantics of Rule Programs
E0 D RI.R/ D f.r1; Alice/; .r2; Alice/g
We chose to consider the execution of .r2; Alice/, which invalidates its own guard;
the resulting conﬁguration is therefore
s1 D ages1 W Alice 7! 10
scores1 W Alice 7! 20
E1 D E0 n f.r2; Alice/g [ f.r2; Alice/g D f.r1; Alice/; .r2; Alice/g .
In this transition, the rule instance .r2; Alice/ has been removed from the set of
eligible ones because it was applied in the transition, and then added back as a rule
instance that was made inapplicable by the transition. The fact that it was made
inapplicable by its own application is coincidental.
In the conﬁguration hE1; s1i the only applicable rule instance is .r1; Alice/. As it
is eligible it gets applied, causing the transition to hE2; s2i, with
s2 D ages2 W Alice 7! 10
scores2 W Alice 7! 30
E2 D E1 n f.r1; Alice/g [ fg D f.r2; Alice/g .
Here, both rule instances are applicable but only .r2; Alice/ is eligible. As above,
when this rule instance is applied, it invalidates its own guard, which makes it
eligible again. The conﬁguration hE3; s3i is therefore
s3 D ages3 W Alice 7! 10
scores3 W Alice 7! 15
E3 D E2 n f.r2; Alice/g [ f.r2; Alice/g D f.r2; Alice/g .
In this conﬁguration, the rule instance .r1; Alice/ is applicable but not eligible,
and .r2; Alice/ is eligible but not applicable. This execution of the rule program thus
terminates with the state s3 as its ﬁnal state.
It is interesting to note that if Alice’s score in the initial state s0 is 60, then
the application of .r2; Alice/ sets it to 30. With this value, the rule instance is
still applicable, and hence it is not added back to the set E1 of eligible rule
instances. This execution ends with no eligible rule instances after the application
of .r1; Alice/, because it sets Alice’s score to 40 without invalidating any guard.
5.6.3
Sequential Execution Strategy
The sequential execution strategy has recently emerged [5, 8, 11] as a competitive
option for rule engine implementations. This occurred as stateful rule programs
became less common than stateless ones, as the latter can be compiled more
efﬁciently with this execution strategy than with the Rete algorithm.

5.6
Eligibility Strategies
87
Neither the identity nor the refraction eligibility strategies just described, nor the
one-shot strategy described further below, is tied to a particular selection strategy.
In contrast, the sequential eligibility strategy comes with a companion selection
strategy, forming a complete execution strategy.
The sequential execution strategy states that the rules and objects are to be taken
into consideration in some sequential order, and that each rule instance is to be
applied if it is applicable at the moment it is considered. If a rule instance has
been considered for application and only later becomes applicable, for example as
the consequence of another rule instance application, the rule instance is not to be
considered again.
To get this behavior, the roles of the selection and eligibility strategies in the
sequential execution strategy will be for the eligibility strategy to deﬁne the set of
rule instances under consideration, and for the selection strategy to ensure that the
rule instances are picked in the proper order.
The sequential execution strategy is based on a strict ordering of the rules in the
rule program, and of the objects in the working memory. Since only well-typed rule
instances are formed, it sufﬁces in fact to deﬁne a strict order within the instances
of each type.
The orders on the rules and on the instances of each type lexicographically deﬁne
a strict order <seq on the rule instances. The sequential execution strategy is then
deﬁned as follows:
(i) The sequential selection strategy returns the minimal rule instance from the
conﬂict set:
Sseq.C/ D fR 2 C j R is minimal with respect to <seqg .
(ii) The sequential eligibility strategy retains for further consideration only the
rule instances that follow (are greater than) the rule instance just applied; in
a transition hE; si
R! hE0; s0i:
Eseq.E; R/ D fR0 2 E j R <seq R0g .
This eligibility strategy is depicted in Fig. 5.4.
5.6.4
One-Shot Eligibility Strategy
The one-shot eligibility strategy states that, in each transition of the rule program
execution, the last rule instance applied is permanently removed from the set of
eligible ones. It is thus deﬁned as follows, in a transition hE; si
R! hE0; s0i:
Eoneshot.E; R/ D E n fRg .

88
5
Operational Semantics of Rule Programs
R <seq (r,n
n
)
R ≥seq (r, )
any R
This automaton describes the eligibility of a rule instance (r,n) and its evolution upon transitions
of the abstract machine by a rule instance R.
Under the sequential eligibility strategy, a rule instance remains eligible as long as the rule
instance that is applied is strictly smaller with respect to the order deﬁned on rule instances. Once
the rule instance, or a greater one, is applied, it ceases to be eligible.
Fig. 5.4 Sequential eligibility strategy
R ̸= (r,n
n
)
(r, )
any R
This automaton describes the eligibility of a rule instance (r,n) and its evolution upon transitions
of the abstract machine by a rule instance R.
Under the one-shot eligibility strategy, a rule instance remains eligible until it is applied. The
application of other rule instances has no effect on its eligibility.
Fig. 5.5 One-shot eligibility strategy
According to this strategy, each rule instance is eligible until it gets executed.
The fact that the set of eligible rules decreases upon each transition ensures that all
executions of the rule program under this strategy are ﬁnite. In the ﬁnal state, the
rule instances that might still be eligible are inapplicable.
The one-shot eligibility strategy is depicted in Fig. 5.5.
The one-shot eligibility strategy can be seen as a trade-off between the refraction
and sequential eligibility strategies. Like the sequential strategy, it never adds
rule instances to the set of eligible ones. Like the refraction strategy, it makes rule
instances ineligible only when they are applied. This combination ensures the termi-
nation of all rule program executions, while not imposing any precedence between
the rules or their instances. As a result, any rule instance has the opportunity of being
applied when it is applicable, but only once since its application makes it ineligible.
The one-shot eligibility strategy is equivalent to the refraction strategy when no
rule instance appears in the conﬂict set after it has been executed once. This will
happen if there is no way for a rule instance to become inapplicable, and then
applicable again, as the result of the application of one or several rule instances.

References
89
Such a condition is quite complex to express in general, however it admits sufﬁcient
conditions at the syntactic level. Consider for example a program where the set of
attribute symbols that occur in the guards is disjoint from the set of attribute symbols
that are updated in the rule actions. This program will have the same executions
under the refraction and the one-shot eligibility strategies. Such rule programs exist,
and are sometimes referred to as ﬁltering programs.
References
All URLs were successfully accessed on January 22, 2013.
1. Berstel-Da Silva, B.: Formalizing both refraction-based and sequential executions of pro-
duction rule programs. In: Bikakis, A., Giurca, A. (eds.) Rules on the Web: Research and
Applications. Lecture Notes in Computer Science, vol. 7438, pp. 47–61. Springer, Berlin
(2012)
2. Brownston, L., Farrell, R., Kant, E., Martin, N.: Programming Expert Systems in OPS5: An
Introduction to Rule-Based Programming. Addison-Wesley, Boston (1985)
3. Cirstea, H., Kirchner, C., Moossen, M., Moreau, P.É.: Production systems and Rete algorithm
formalisation. Research report, LORIA, Nancy (2004). http://hal.inria.fr/inria-00280938/PDF/
rete.formalisation.pdf
4. Fages, F., Lissajoux, R.: Sémantique opérationnelle et compilation des systèmes de production.
Revue d’Intelligence Artiﬁcielle 6(4), 431–456 (1992)
5. Fair, Isaac, and Company: High-volume batch processing with Blaze Advisor. Computer
World UK (2007). http://www.computerworlduk.com/white-paper/business-process/5092/
high-volume-batch-processing-with-blaze-advisor/
6. Forgy, C.: OPS5 User’s manual. Tech. Rep. CMU-CS-81-135, Carnegie-Mellon University,
Pittsburgh (1981)
7. Forgy, C.: Rete: A fast algorithm for the many patterns/many objects match problem. Artif.
Intell. 19(1), 17–37 (1982)
8. IBM: IBM Operational Decision Manager v8.0 User’s Manual (2012). http://publib.boulder.
ibm.com/infocenter/dmanager/v8r0/
9. Mettrey, W.: A comparative evaluation of expert system tools. Computer 24, 19–31 (1991)
10. Plotkin, G.D.: A structural approach to operational semantics. J. Logic Algebr. Program.
60–61, 17–139 (2004). Reprint with corrections of the 1981 article
11. Red Hat: JBoss Rules 5 Reference Guide (2012). https://access.redhat.com/knowledge/docs/
en-US/JBoss_Enterprise_BRMS_Platform/5/html-single/JBoss_Rules_5_Reference_Guide/
index.html#Sequential_Mode
12. de Sainte Marie, C., Hallmark, G., Paschke, A.: Rule Interchange Format, Production Rule
Dialect. Recommendation, W3C (2010). http://www.w3.org/TR/rif-prd/

Part III
A Hoare Logic for Rule Programs

Chapter 6
Correctness of Rule Programs
We have just deﬁned the operational semantics of a rule program by the transitions
it makes possible between conﬁgurations of an abstract machine. We have seen
that this establishes a relation between the initial and ﬁnal states of the possible
executions of the rule program.
We now study the correctness of a rule program from the viewpoint of this
relation. In other words, requirements on the correctness of a rule program are
expressed through assertions on the initial and ﬁnal states in a rule program
execution. For this purpose, we use correctness formulas of the well-known form
fpg S fqg.
In this chapter, we deﬁne and discuss correctness formulas for rules, and then for
rule programs. Chapters 8–10 introduce proof rules to reason on such correctness
formulas.
6.1
Preliminaries
6.1.1
Fixing the Execution Strategy
From now on, and unless otherwise noted, the rule program executions that we
consider use the identity selection strategy and the one-shot eligibility strategy,
collectively referred to as the one-shot execution strategy. Let us recall their
deﬁnitions:
(i) The identity selection strategy deﬁnes the selection as equal to the conﬂict
set, leaving unspeciﬁed the choice of the rule instance to be applied:
Sid.C/ D C .
B. Berstel-Da Silva, Veriﬁcation of Business Rules Programs,
DOI 10.1007/978-3-642-40038-4__6, © Springer-Verlag Berlin Heidelberg 2014
93

94
6
Correctness of Rule Programs
(ii) The one-shot eligibility strategy makes the last-applied rule instance ineligi-
ble; that is, in a transition hE; si
R! hE0; s0i:
Eoneshot.E; R/ D E n fRg .
The selection and eligibility strategies have a central role in the transition
rule (5.1) of the abstract machine that describes the execution of rule programs.
The use of the identity selection strategy and one-shot eligibility strategy in this
transition rule yields the specialized transition rule below:
R 2 As
R 2 E
s
R! s0
E0 D E n fRg
hE; si
R! hE0; s0i
.
(6.1)
Given two T -compliant states s and s0, we will from now on write s
R
! s0
when there exists a maximal transition sequence by the transition rule (6.1) from
the conﬁguration hRIs.R/; si to a conﬁguration hE0; s0i.
As mentioned before, the one-shot eligibility strategy ensures the termination of
all executions of all rule programs. In the ﬁnal conﬁguration hE0; s0i of an execution
of a rule program R, for any instance R D .r; / of a rule r D .Eo; ET ; g; a/ of R,
one has either R … E0 or s0;  ˆ :g. Conversely, in a conﬁguration hE0; s0i that
satisﬁes the latter, no rule of R can be executed.
6.1.2
Correctness Formulas, Proofs, Proof Systems
Correctness formulas of the form fpg S fqg have been introduced by Hoare [6],
as an axiomatic formulation of Floyd’s method for proving partial correctness [5].
The central element S in such a correctness formula is a statement or a program; the
assertions p and q express conditions on the initial and ﬁnal states of executions of
S, and hence act as pre- and postconditions of S.
This formalism is widely used [1, 2, 4, 9] to describe the correctness of many
kinds of programs, from the standpoint of their input-output behavior. We give a
deﬁnition of correctness formulas of this form for rules in the next section, and for
rule programs in Sect. 6.4.
Proofs are built by deriving new correctness formulas from already known
correctness formulas, by means of proof rules that are gathered in proof systems.
We place ourselves in the context of the standard deﬁnitions of proof rules, proof
systems, and of proofs built using them [3, pp. 38–39]. A proof rule is presented as:
'1
: : :
'n
'
where : : :

6.2
Correctness Formula for a Single Rule
95
Such a proof rule means that if the formulas '1; : : : ; 'n above the horizontal line
(called the premises of the rule) hold, then the formula ' below the line (called
the conclusion of the rule) holds. An optional side condition may restrict the cases
where the rule can be applied. A proof rule with no horizontal line is called an axiom
scheme, and can be read as a proof rule with true premises.
The (CONSEQUENCE) proof rule below is used, sometimes implicitly, to exploit
logical implications between assertions in order to generalize a correctness formula.
The proof rule is given, for example, in [1], where the combination of assertions and
correctness formulas in proof rules is also discussed.
p ! p0
fp0g S fq0g
q0 ! q
fpg S fqg
(CONSEQUENCE)
6.2
Correctness Formula for a Single Rule
Syntax
Deﬁnition 6.1. A correctness formula for a rule is a formula of the form fpg r fqg,
where r is a rule, and p and q are ﬁrst-order, ﬂat, possibly quantiﬁed formulas from
F.Var/. The formulas p and q are called the pre- and postcondition, respectively.
The free variables in the correctness formula fpg r fqg are those occurring free in
p, in r, or in q. The variables found in the rule r D .Eo; ET ; g; a/ are the o1; : : : ; om;
those in p and q may be in this set, or not. We call a correctness formula focused
when only the rule variables appear as free variables of the pre- and postconditions.
Deﬁnition 6.2. A correctness formula for a rule fpg r fqg is focused on the rule r if
the pre- and postconditions p and q are assertions focused on r. That is, as deﬁned
in Sect. 4.2.3, the free variables of p and q are rule variables of r, and p and q are
well-typed for the type constraint implied by the rule variable types.
Typing
In a rule r D .Eo; ET ; g; a/, the variables are typed by the type constraint .Eo W ET /. A
type constraint on the free variables of a correctness formula for a rule fpg r fqg
will thus include this constraint, and may also include constraints on the additional
free variables appearing in the pre- and postconditions.
Deﬁnition 6.3. A correctness formula for a rule fpg r fqg is well-typed for a type
constraint  on its free variables if the formulas p and q are well-typed for .
We can note that a focused correctness formula is always well-typed for any type
constraint on its free variables.

96
6
Correctness of Rule Programs
Semantics
In line with the usual semantics of correctness formulas [1,6], a correctness formula
for a rule means that any execution of the rule in a state that satisﬁes the precondition
results in a state that satisﬁes the postcondition. There is no mention of termination
here, since an execution of a single rule always terminates.
Deﬁnition 6.4. Let fpg r fqg be a correctness formula for a rule, well-typed for a
type constraint  on its free variables. The correctness formula holds if
for any T -compliant states s and s0, and any valuation  well-typed for 
in s, such that
s;  ˆ p
and
s
.r;/
! s0
we have
s0;  ˆ q .
As a reminder, the notation s
.r;/
! s0 means that s0 is the state that results from
the execution of the rule r in the state s under the valuation , which is deﬁned in
Sect. 5.3.4 as the state that results from the execution of the action of r in s under 
if the rule instance .r; / is applicable in s, and as s itself otherwise.
Let us also recall that a valuation  is well-typed for a type constraint  in a state
s if it maps each variable in the domain of the type constraint to an instance of its
associated type, that is, for any  2 Dom./ we have ./ 2 Ms..//. The type
constraint  mentioned by Deﬁnition 6.4 on the free variables of the correctness
formula is thus key to assessing the truth value of the correctness formula. Indeed,
the objects used to execute the rule and to assess the pre- and postconditions of the
correctness formula are instances of the types of these variables as constrained by .
This property is visible in the examples below.
In a correctness formula focused on a rule, the free variables are all variables
of the rule, and hence are typed by construction. Some correctness formulas that
appear in the interference-freedom conditions of Part IV are not focused on a rule;
however, all the free variables in these correctness formulas are still variables of
rules in the program, and hence are typed by the corresponding rule deﬁnitions.
Examples
Example. Consider the rule
r.x W Person/W x:age  12 * x:status :D Child
and the following correctness formula for r
fx:age D 10g r f:.x:status D Adult/g .

6.2
Correctness Formula for a Single Rule
97
Consider now a T -compliant state s
and a valuation 
well-typed for
.x W Person/, such that the precondition of the correctness formula holds in s under ,
that is, s;  ˆ x:age D 10. We thus have ages..x// D 10, hence ages..x//  12,
that is, the guard of the rule r holds in s under .
As a consequence, if s0 is the state that results from the execution of r in s
under , it is deﬁned by hs; s0i;  ˆ Oa with a  x:status :D Child, that is,
hs; s0i;  ˆ x:status0 D Child ^ 8o .o ¤ x ! o:status0 D o:status/
^
^
f 2Attrnfstatusg
8o .o:f 0 D o:f / .
In particular, we have statuss0..x// D Child, and hence s0;  ˆ :.x:status D
Adult/.
The postcondition holds in s0 under , meaning that the correctness formula for
r holds.
Example. Consider the same rule as above, and the following correctness formula
for r.
fx:age > 10g r fx:status D Childg .
This correctness formula does not hold. Indeed, consider an instance Alice of the
type Person, a valuation  such that .x/ D Alice, and a T -compliant state s such
that ages.Alice/ D 30 and statuss.Alice/ D Adult.
In the state s and under the valuation , the precondition holds, that is, s;  ˆ
x:age > 10. On the other hand, the guard of the rule does not hold in s under ,
since ages.Alice/ D 30 6 12. The state that results from the execution of r in s
under  is therefore s itself, where statuss.Alice/ D Adult ¤ Child, that is,
s;  6ˆ x:status D Child.
There is a state and a valuation where the precondition holds, but the postcon-
dition does not hold in the state that results from the execution of the rule. The
correctness formula for r thus does not hold.
Example. Consider the rule used in the previous examples, and the following
correctness formula, with the type constraint .y W Person/:
fx:age < 10 ^ y:status D Childg r fx:status D y:statusg .
The valuation to consider to apply Deﬁnition 6.4 must now be well-typed for
..x; y/ W .Person; Person//. Consider such a valuation  and a T -compliant state
s, such that the precondition of the correctness formula holds in s under , that is,
ages..x// D 10 and statuss..y// D Child. Then the guard of the rule r holds
in s under , and the state s0 that results from the execution of r in s under  is
deﬁned by

98
6
Correctness of Rule Programs
hs; s0i;  ˆ x:status0 D Child ^ 8o .o ¤ x ! o:status0 D o:status/
^
^
f 2Attrnfstatusg
8o .o:f 0 D o:f / .
In particular, we have statuss0..x// D Child.
As for y, we should distinguish whether it is equal to x under , or not. If
it is, then statuss0..y// D statuss0..x//; if it is not, then statuss0..y// D
statuss..y// by the second conjunct above. In all cases, statuss0..y// D Child
and hence s0;  ˆ x:status D y:status. The correctness formula for r holds.
In the examples above, it can be noted that in a correctness formula fpg r fqg,
the precondition p might or might not imply the guard of the rule. Therefore, the
correctness formula must be considered both in the case where the execution of
the rule results in the application of its action, and in the case where it results
in a skip operation. The interaction between the precondition and the guard is
discussed further below, at the end of Sect. 6.3.2 on pp. 101–102.
6.3
Rules Compared to Conditional Statements
From the deﬁnition of the execution of a rule in Sect. 5.3.5, it appears that a rule r D
.Eo; ET ; g; a/ is similar to the imperative command if g then a else skip fi.
Below we brieﬂy introduce the statements in this command, so as to connect their
standard deﬁnitions to our formal framework; then we show that a rule and the
command above have the same behavior from the viewpoint of the correctness
formulas they satisfy.
6.3.1
Loop-Free Programs
Syntax
We consider the standard statements in a loop-free imperative program [6, 7].
In Fig. 6.1, we provide a grammar for their language L .V /. As usual, the language
is parameterized by a set of variables V  Var. Although loop-free programs are
more general than the conditional command mentioned above, we deﬁne them now
because we will use them as processes of parallel programs in the next chapter.
The language L .V / includes the skip statement and the assignment deﬁned
in Sect. 3.4 by the A .V / language. It combines these statements with the sequence
and conditional control structures.
The variables that occur in a loop-free program may come with associated types.
For example, if the loop-free program is computed from a rule r D .Eo; ET ; g; a/, it
will inherit its variables and their types .Eo W ET /.

6.3
Rules Compared to Conditional Statements
99
Fig. 6.1 Loop-free programs
We deﬁne that a loop-free program is well-typed for a type constraint by
induction on its structure, based on well-typed formulas and assignment.
Semantics
We adopt the standard semantics for loop-free programs, as deﬁned below. We con-
sider executions in T -compliant states of loop-free programs that are well-typed
for some given type constraint .
We say that s0 is a state that results from the execution of a program L 2 L .Var/
in a state s, and we write s
L! s0, if there exists a valuation  well-typed for , such
that the program results in s0 when executed in s under . We deﬁne s0 by induction
on the structure on the program, as follows.
•
The execution of the skip statement in s under  (actually under any valuation)
results in s itself.
•
The execution of an assignment in s under  is deﬁned in Sect. 4.4.2.
•
The execution of a conditional statement if b then L1 else L2 fi in s under
, where b 2 B.V / is a Boolean expression, and L1 and L2 are loop-free
programs, results in the state that results from the execution of L1 in s under
 if b holds in s under ; and in the state that results from the execution of L2 in
s under  otherwise.
•
The execution of a sequence S I L in s under , where S is a loop-free statement
and L is a loop-free program, results in the state that results from the execution
of L in the state that resulted from the execution of S in s under .
Example. Consider the loop-free program
L W if p:age > 21 then p:status WD Adult else p:status WD Child fi
with the following type constraint, instances, and initial state:
 W p 7! Person
M .Person/ D fAlice; Bobg
s D ages W Alice 7! 12
statuss W Alice 7! Unknown
Bob 7! 30
Bob 7! Unknown .

100
6
Correctness of Rule Programs
The valuations that are well-typed for  in s may map p only onto Alice or onto
Bob. There are therefore only two states that result from an execution of L in s
under a valuation well-typed for , namely s1 and s2 as deﬁned below:
s1 D ages1 W Alice 7! 12
statuss1 W Alice 7! Child
Bob 7! 30
Bob 7! Unknown
s2 D ages2 W Alice 7! 12
statuss2 W Alice 7! Unknown
Bob 7! 30
Bob 7! Adult .
The states that result from executions of the program L in s are thus s1 and s2.
Correctness Formulas, Axioms, and Proof Rules
Correctness formulas fpg L fqg for loop-free programs have the standard meaning,
formalized as follows. Given a loop-free program L 2 L .Var/, two assertions
p; q 2 F.Var/, and a type constraint  for which L, p and q are well-typed,
the correctness formula fpg L fqg is well-typed for , and it holds if for any
T -compliant states s and s0, and any valuation  well-typed for , such that
s;  ˆ p and s
L! s0, we have s0;  ˆ q.
We thus inherit the standard axiom schemes and proof rules associated with
skip, the assignment and the conditional statement [1, 3, 6, 8]. We revisit them
below, with p; q; r 2 F.Var/ and the notations used above for the various cases of
loop-free programs.
fpg skipfpg
(SKIP)
fqŒf Œo 7! e=f g o:f :D e fqg
(ASSIGNMENT)
fp ^ bg L1 fqg
fp ^ :bg L2 fqg
fpg if b then L1 else L2 fi fqg
(IF)
fpg S frg
frg L fqg
fpg S I L fqg
(SEQUENCE)
6.3.2
Rules vs. Conditional Statements
We now formally present the equivalence between a rule r D .Eo; ET ; g; a/ and the
imperative command if g then a else skip fi. To this end, we ﬁrst deﬁne the
latter as the loop-free program derived from the former rule, then we prove that they
satisfy the same correctness formulas.

6.3
Rules Compared to Conditional Statements
101
Deﬁnition 6.5. Given a rule r D .Eo; ET ; g; a/, the loop-free program derived from
r is the program
Lr.Eo W ET / W if g then a else skip fi
The loop-free program derived from a rule inherits the type constraint attached
to the rule. It is by construction well-typed for it.
A rule and the loop-free program derived from it have the same behavior, in the
sense that they satisfy the same correctness formulas.
Proposition 6.1. Given a rule r D .Eo; ET ; g; a/ and two assertions p; q 2 F.Var/
that form a correctness formula well-typed for some type constraint  including
.Eo W ET /, the correctness formula fpg r fqg for the rule r holds if and only if the
correctness formula fpg Lr fqg for the loop-free program derived from r holds.
Proof. We have Lr  if g then a else skip fi. Let s be a T -compliant state
and  be a valuation well-typed for  in s, such that s;  ˆ p.
Case 1: s;  ˆ g. Then the state s0 that results from the execution of the rule
instance .r; / in s is deﬁned in Sect. 5.3.4 by hs; s0i;  ˆ Oa. On the other hand, the
state that results from the execution of Lr in s under  is deﬁned as the state that
results from the execution of a in s under , that is, s0 as well.
Case 2: s;  6ˆ g. Then the state s0 that results from the execution of the rule
instance .r; / in s is deﬁned to be s itself. On the other hand, the state that results
from the execution of Lr in s under  is deﬁned as the state that results from the
execution of skip in s under , that is, s itself as well.
Summary. In all cases, the state s0 that results from the execution of the rule instance
.r; / in s is the same as the state that results from the execution of Lr in s under .
As a consequence, if s0;  ˆ q, both the correctness formulas for the rule and for
the loop-free program derived from it hold; and if s0;  6ˆ q, neither holds.
ut
The fact that a rule and the loop-free program derived from it have the
same behavior is consistent with the application of the proof rule (IF) for
the conditional statement, to combine under a test consisting of the guard the
axioms (ASSIGNMENT) for assignment and (SKIP) for skip.
Another expression of this similarity between a rule and the derived loop-free
program is the decomposition of a correctness formula for a rule that can be
performed by distinguishing between the cases where the rule guard holds or not.
In other words, the correctness formula fpg r fqg for a rule r D .Eo; ET ; g; a/ with
a  o1:fr :D er, is equivalent to the conjunction of
fp ^ gg a fqg
and
fp ^ :gg skipfqg
that is, by the axioms (ASSIGNMENT) and (SKIP),

102
6
Correctness of Rule Programs
p ^ g ! qŒfrŒo1 7! er=fr
and
p ^ :g ! q .
In the particular cases where the precondition of the correctness formula implies
the guard of the rule, or where it is incompatible with the guard of the rule, this
gives:
(i) if we have p ! g, then fpg r fqg is equivalent to fpg a fqg, that is, to p !
qŒf 0
r =fr where f 0
r D frŒo1 7! er;
(ii) if we have :.p ^ g/, then fpg r fqg is equivalent to fpg skipfqg, that is, to
p ! q.
Conversely, in the context of a rule r D .Eo; ET ; g; a/, the correctness formula
fp ^ gg a fqg is equivalent to fpg r fq _ p ^ :gg.
The equivalences listed above give additional insight into the precise meaning
of rule execution. They can also be leveraged to apply the veriﬁcation method
described in Part IV in the particular cases to which they relate.
6.4
Correctness Formula for a Rule Program
6.4.1
Syntax and Semantics
Deﬁnition 6.6. A correctness formula for a rule program is a formula of the form
fpg R fqg, where R is a rule program, and p and q are closed, ﬁrst-order, ﬂat,
possibly quantiﬁed formulas from F.;/. The formulas p and q are called the pre-
and postcondition of the correctness formula, respectively.
As seen in Sect. 6.2, the pre- and postconditions in a correctness formula for a
rule are formulas with free variables. They express assertions on the objects handled
by the rule. In contrast, the pre- and postconditions in a correctness formula for a
rule program are closed formulas, and they express assertions on the whole working
memory.
The semantics of a correctness formula for a rule program is in line with the
standard deﬁnition [1, 3, 6], including the distinction between partial and total
correctness. Indeed, for a general execution strategy, a rule program might not
terminate.
Deﬁnition 6.7. Let fpg R fqg be a correctness formula for a rule program; let S be
a selection strategy and E be an eligibility strategy. The correctness formula holds
in the sense of partial correctness for S and E if
for any T -compliant state s such that s ˆ p, any terminating execution of
R from s under the execution strategy S ; E results in a state s0 such that
s0 ˆ q.

6.4
Correctness Formula for a Rule Program
103
Deﬁnition 6.8. Let fpg R fqg be a correctness formula for a rule program; let S be
a selection strategy and E be an eligibility strategy. The correctness formula holds
in the sense of total correctness for S and E if
for any T -compliant state s such that s ˆ p, all executions of R from s
under the execution strategy S ; E terminate, and for each resulting state
s0, we have s0 ˆ q.
As announced, a correctness formula for a rule program, taken in the sense of
partial correctness, means that any execution of the rule program that starts in a state
that satisﬁes the precondition, and that terminates, results in a state that satisﬁes the
postcondition. And when taken in the sense of total correctness, it means that any
execution of the rule program that starts in a state that satisﬁes the precondition
terminates and results in a state that satisﬁes the postcondition.
Since the one-shot execution strategy (see Sect. 6.1.1) ensures that all rule
program executions terminate, the two notions coincide when under this execution
strategy, and we will omit the distinction.
Example. Consider the rule program R D fr1; r2g below:
r1.x W Person/W x:age  12 * x:status :D Child
r2.y W Person/W y:status D Child * y:gift :D TeddyBear
Consider the following correctness formula for R:
f8o W Person .o:age D 10/g R f8o W Person :.o:gift D Champagne/g .
This correctness formula holds for the one-shot execution strategy. Indeed, consider
a T -compliant state s0 where the precondition of the correctness formula holds, that
is, s0 ˆ 8o W Person .o:age D 10/. Consider also an execution of R from s0 under
the one-shot execution strategy.
The initial conﬁguration for this execution will be hE0; s0i, where the set of
eligible rule instances will contain all the instances of the rules r1 and r2 that can be
formed with the instances of the type Person, that is, E0 D f.r; O/ j r 2 R; O 2
M .Person/g. Since s0 satisﬁes the precondition of the correctness formula, the age
of all persons is 10, and therefore all instances of r1 in E0 are applicable. Depending
on the status of persons in the state s0, which is not constrained by the precondition,
the corresponding instances of r2 are applicable or not.
An execution of R from this conﬁguration under the one-shot execution strategy
will consist of the application of all the instances of r1 and r2, since the instances
of r2 that are initially not applicable will be made applicable by the execution of r1
on the same object. The execution of each rule instance makes it ineligible, so each
rule instance is executed exactly once. Each application of an instance of r2 causes
the gift of the corresponding person to be set to TeddyBear, so all executions end
in a state where all gifts equal TeddyBear, thus satisfying the postcondition of the
correctness formula.

104
6
Correctness of Rule Programs
In this example we have chosen the one-shot execution strategy to execute
R. The sequential and refraction eligibility strategies would also have made the
considered correctness formula valid both in the senses of partial and of total
correctness. However, under the identity strategy Eid (deﬁned in Sect. 5.6.1), no
execution of R would terminate. The correctness formula would then trivially
hold in the sense of partial correctness, and would not hold in the sense of total
correctness.
6.4.2
From Rules to Rule Programs
Consider a rule r, and the rule program R D frg made of only this rule. Given
two assertions p and q, we want to compare the correctness formulas fpg r fqg and
fpg R fqg.
Both when deﬁning the meaning of correctness formulas for rules and of
correctness formulas for rule programs, we noted that these meanings were standard.
However, these meanings are signiﬁcantly different from one another. This contrasts
with usual programming paradigms, where the meanings of correctness formulas for
statements and for programs are close. This peculiarity of rule programs is due to
the speciﬁc way rules are orchestrated in a rule program execution.
We examine these differences below. We also note that, due to these differences,
a correctness formula fpg r fqg for a rule r does not imply the corresponding
correctness formula for a rule program that contains only the rule r.
A ﬁrst, syntactic difference between correctness formulas for rules and for rule
programs is that the pre- and postconditions in a correctness formula for a rule are
assertions with free variables, whereas those in a correctness formula for a rule
program are closed. The former express conditions on the objects handled by the
rule, while the latter express conditions on the whole working memory.
The other major difference between correctness formulas for rules and for rule
programs is that for the former only one rule instance execution is considered,
whereas for the latter all the rule instance applications that make an execution of
the program are considered.
Indeed, on the one hand, the correctness formula fpg r fqg for the rule expresses
that when the rule is executed—that is, when one instance of r is executed—from a
state that satisﬁes p, then the resulting state satisﬁes q.
On the other hand, the correctness formula fpg R fqg for the rule program
(taken in the sense of partial correctness) expresses that when the rule program is
executed—that is, since the program contains only one rule, when all the instances
of r that are eligible and applicable have been applied—from a state that satisﬁes p,
then the states that result from terminating executions satisfy q.
This difference in semantics makes it wrong, in the general case, to transpose
a correctness formula for a rule into a correctness formula for the program made
of only this rule, even once the syntactic concerns are worked out. The proposition
below expresses it formally.

6.4
Correctness Formula for a Rule Program
105
Proposition 6.2. Let fpg r fqg be a correctness formula focused on a rule r D
.Eo; ET ; g; a/, and let R D frg be the rule program made of only the rule r. Then
the correctness formula f8Eo W ET pg R f8Eo W ET qg does not hold for the one-shot
execution strategy. In other words, the proof rule below is not sound
fpg r fqg
f8Eo W ET pg R f8Eo W ET qg
where R D frg
The notation 8Eo W ET used above is an abbreviation for 8o1 W T1 : : : 8on W Tn.
Proof. To prove the proposition, we exhibit a counterexample. Consider the rule
program R D frg made of the only rule below:
r.c W Cart; p W Person/ W p:age D 21 * c:value :D c:value C 10
The correctness formula fp:age D 21 ^ c:value D 0g r fc:value D 10g holds for
this rule. We are going to show that the correctness formula
f8c W Cart 8p W Person .p:age D 21 ^ c:value D 0/g R
f8c W Cart 8p W Person .c:value D 10/g
does not hold for the rule program R.
Consider the following setting:
M .Person/ D fAlice; Bobg
M .Cart/ D fCaddieg
s0 D
ages0 W Alice 7! 21
values0 W Caddie 7! 0 .
Bob 7! 21
With this setting we have s0 ˆ 8c W Cart 8p W Person .p:age D 21 ^ c:value D 0/.
An execution of R from s0 is
s0
.r;Caddie;Alice/
! s1
.r;Caddie;Bob/
! s2 .
In this execution, we have values1.Caddie/ D 10 and values2.Caddie/ D 20. As a
consequence, the ﬁnal state s2 of this execution does not satisfy
8c W Cart 8p W Person .c:value D 10/ .
ut
The reason behind this negative result is that among the multiple rule instance
applications in a rule program execution, some might interfere with the pre- and
postconditions of the correctness formula, hence breaking its validity.

106
6
Correctness of Rule Programs
It is the subject of Part IV to study under which conditions individual correctness
formulas focused on the rules of a program can be leveraged to prove a correctness
formula for the rule program itself.
References
1. Apt, K.R.: Ten years of Hoare’s logic: A survey—part I. ACM Trans. Program. Lang. Syst. 3(4),
431–483 (1981)
2. Apt, K.R.: Ten years of Hoare’s logic: A survey—part II: Nondeterminism. Theor. Comp. Sci.
28, 83–109 (1984)
3. Apt, K.R., de Boer, F.S., Olderog, E.R.: Veriﬁcation of Sequential and Concurrent Programs,
3rd edn. Texts in Computer Science. Springer, Berlin (2009)
4. de Bakker, J.W., de Bruin, A., Zucker, J.: Mathematical Theory of Program Correctness.
Prentice-Hall International Series in Computer Science. Prentice Hall, Englewood Cliffs (1980)
5. Floyd, R.W.: Assigning meaning to programs. In: Proceedings of the Symposium on Applied
Math, vol. 19, pp. 19–32. American Mathematical Society, Providence (1967)
6. Hoare, C.A.R.: An axiomatic basis for computer programming. Comm. ACM 12, 576–580
(1969)
7. Manna, Z.: Mathematical Theory of Computation.
Dover Books on Mathematics. Dover,
New York (2003)
8. Morris, J.M.: A general axiom of assignment. In: Bauer, F.L., Dijkstra, E.W., Hoare, C.A.R.
(eds.) Theoretical Foundations of Programming Methodology: Lecture Notes of an International
Summer School. Reidel, Dordrecht (1982)
9. Olderog, E.R.: Hoare’s logic for programs with procedures—What has been achieved?
In:
Clarke, E.M., Kozen, D. (eds.) Logics of Programs. Lecture Notes in Computer Science,
vol. 164, pp. 383–395. Springer, Berlin (1984)

Chapter 7
Correctness of Programs: A Comparison
In the previous chapter, we studied the meaning of a rule program from the view-
point of the relation between the initial and ﬁnal states of its possible executions.
We used correctness formulas of the form fpg R fqg to embody this meaning.
In the present chapter, we compare rule programs with parallel programs and
with nondeterministic programs. In these comparisons, we study whether a given
rule program can, in general, be simulated by a parallel or a nondeterministic
program, in the sense that both would satisfy the same correctness formulas.
The outcome is that, in general, a rule program cannot be simulated by a parallel
program. This implies that a rule program cannot be veriﬁed by a mere translation
into a parallel one, on which the existing veriﬁcation methods for parallel programs
[4,5] would then be applied.
On the other hand, a rule program can always be simulated by a nondeterministic
program. However, the veriﬁcation method for nondeterministic programs based on
a dedicated Hoare logic [1] is not compositional, as it relies on a global invariant.
These results motivate the search for a compositional method to derive a
correctness formula for a rule program from individual correctness formulas for
its rules. This search is the subject of the next chapters.
7.1
Correctness of Loop-Free Parallel Programs
As mentioned in Chap. 5, rule programs are declarative programs composed of rules
that are combined by a rule engine. It is thus natural to draw an analogy with parallel
programs, which are composed of processes combined by a scheduler.
In this section, we compare rule programs with parallel ones composed of loop-
free processes. In the next section, we compare them with parallel programs that
admit while programs as their processes. We show in particular that in general
there is no parallel program (of a precise form) with the same behavior as a rule
program.
B. Berstel-Da Silva, Veriﬁcation of Business Rules Programs,
DOI 10.1007/978-3-642-40038-4__7, © Springer-Verlag Berlin Heidelberg 2014
107

108
7
Correctness of Programs: A Comparison
⟨loop-free stat.⟩::= ‘⟨’ ⟨loop-free pgm.⟩‘⟩’
⟨lf-par. pgm. :
(V)⟩::= ‘[’ ⟨lf-processes⟩‘]’
⟨lf-processes⟩::= ⟨lf-process :
(V)⟩
| ⟨lf-process :
(V)⟩‘∥’ ⟨lf-processes⟩
Fig. 7.1 Parallel programs with loop-free processes
7.1.1
Loop-Free Parallel Programs
Syntax
We consider parallel programs built the classical way [2, 4], that is, by assembling
processes with a parallel composition control structure. Each process is a loop-
free program as deﬁned by the grammar of the language L .V / given in Fig. 6.1,
augmented with a new derivation for statements that introduces the atomic region.
In Fig. 7.1, we provide this rule and the grammar for the PL .V / language of parallel
programs with loop-free processes.
A parallel program inherits the type constraints on the variables of its component
processes.
Example. The program L D ŒL1kL2 is a parallel program with two loop-free
processes:
L1.x W Person/ W x:bonus :D 0
L2.x W Person; y WPerson/ W y:bonus :D x:bonus C 10
Classical Interleaving Semantics
In the widely used interleaving semantics for parallel programs, the executions of a
parallel program are obtained by combining the execution of the statements in the
processes in all the possible manners that respect the control ﬂow of each process.
In this semantics, when a parallel program is executed on some input data, the
processes are ﬁrst instantiated on the data, that is, variables are given the values
provided as input to the program, and then all combinations of the statements of the
process instances are formed.
For example, consider the parallel program L D ŒL1kL2 deﬁned in the example
above. Consider also a valuation that maps the variable x onto the value Alice,
and the variable y onto Bob. Finally, consider an execution of L on the input data
modeled by this valuation and from the state s0 deﬁned below:
bonuss0.Alice/ D 30
bonuss0.Bob/ D 20

7.1
Correctness of Loop-Free Parallel Programs
109
The program L then admits the following two executions:
s0
.L1;Alice/
!
1st statement
bonus.Alice/ D 0
bonus.Bob/ D 20
.L2;Alice;Bob/
!
1st statement
bonus.Alice/ D 0
bonus.Bob/ D 10
s0
.L2;Alice;Bob/
!
1st statement
bonus.Alice/ D 30
bonus.Bob/ D 40
.L1;Alice/
!
1st statement
bonus.Alice/ D 0
bonus.Bob/ D 40 .
Saturated Interleaving Semantics
The semantics for parallel processes that we introduce here does not differ from
the classic interleaving semantics in the way the executions of the rule program are
obtained, as far as the combination of process statements is concerned. Its difference
lies in the way the processes are instantiated on input data before the combination
occurs. On this point, it reproduces the instantiation of rules into rule instances by
the rule engine.
In the saturated interleaving semantics, a parallel program L D ŒL1k : : : kLn
is considered for execution on a working memory M . For each i D 1; : : : ; n, the
process Li involves variables in its text and comes with a type constraint .Eoi W ETi/
for them.
To instantiate the processes, the classic interleaving semantics ﬁnds in the input
data the (single) value to give to each variable of the program. Instead, the saturated
interleaving semantics considers, for a process Li, all the instances of the type T i
j
as possible values of the variable oi
j, and creates as many instances of the process
Li. That is, it creates one instance of Li for each tuple of objects in the working
memory that is well-typed for .Eoi W ETi/.
For example, consider a parallel program L D ŒL1kL2 composed of two
processes, where L1 involves the variables p W Person and c W Cart, and L2 involves
the variable q W Person. In an execution of L on a working memory with the instances
M .Person/ D fAlice; Bobg and M .Cart/ D fCaddieg, the following process
instances are created:
.L1; Alice; Caddie/
.L2; Alice/
.L1; Bob; Caddie/
.L2; Bob/ .
The statements of all the process instances are then combined to form the
executions of the parallel program. Assuming that each process of the example just
above contains only one statement, the combination of the four process instances
gives 4Š D 24 possible executions of L, although these executions might represent
fewer pairs of initial and ﬁnal states.
The saturated interleaving semantics for parallel programs is well-suited to
compare a rule program with a parallel program, because it provides a meaning

110
7
Correctness of Programs: A Comparison
for the execution of a parallel program on a working memory. It does so by
transposing to parallel programs the way in which a rule engine instantiates rules.
The speciﬁcity of the parallel programming paradigm, namely the interleaving
semantics, is preserved.
The classic and saturated interleaving semantics coincide when the working
memory contains exactly one instance of each type involved in the program. Each
process then yields only one instance.
7.1.2
Loop-Free Parallel Program Derived from a Rule
Program
We have deﬁned in Sect. 6.3.2 that the loop-free program derived from a rule r D
.Eo; ET ; g; a/ is the program Lr.Eo W ET / W if g then a else skip fi.
Deﬁnition 7.1. Given a rule program R D fr1; : : : ; rng, the parallel program with
loop-free processes derived from R, is the program LR  ŒhLr1ik : : : khLrni
composed of the loop-free programs derived from the rules of R, each treated as
an atomic region.
Example. Consider the rule program R D fr1; r2g composed of the rules below:
r1.p W Person/W p:age > 21 * p:bonus :D 10
r2.c W Car/ W c:mileage < 100000 * c:score :D 15
The parallel program with loop-free processes derived from R is the program LR 
ŒhLr1ikhLr2i, with
Lr1.p W Person/ W if p:age > 21 then p:bonus :D 10 else skip fi
Lr2.c W Car/ W if c:mileage < 100000 then c:score :D 15 else skip fi
The natural question that arises is whether, given a rule program R, the derived
program LR has the same behavior, in the sense that its executions under the
saturated interleaving semantics make the same correctness formulas valid. The
answer is: in general, no.
In the example just above, R and LR have the same behavior, but this is a
consequence of the fact that the rules in R (and hence the processes in LR) are
disjoint, in the sense that no attribute updated by one of the rules occurs in the other
rule.
Proposition 7.1. There exist rule programs R such that the parallel program with
loop-free processes LR derived from R does not satisfy the same correctness
formulas as R.

7.1
Correctness of Loop-Free Parallel Programs
111
Proof. Consider the rule program R D fr1; r2g composed of the rules below:
r1.x W T/ W x:a D 1 * x:b :D 1
r2.x W T/ W x:b D 1 * x:c :D 1
The parallel program with loop-free processes derived from R is the program LR 
ŒhLr1ikhLr2i, with
Lr1.x W T/ W if x:a D 1 then x:b :D 1 else skip fi
Lr2.x W T/ W if x:b D 1 then x:c :D 1 else skip fi
The proof is based on the fact that the rule program satisﬁes the following
correctness formula, whereas the derived parallel program does not:
f8x W T .x:a D 1 ^ x:b D 0 ^ x:c D 0/g R f8x W T .x:a D 1 ^ x:b D 1 ^ x:c D 1/g .
During the whole proof, we limit ourselves to executions of R and LR on a working
memory reduced to one object; since the difference of behavior is visible under this
limitation, it sufﬁces to prove the proposition.
Executions of R. The initial conﬁguration of the rule engine is hE0; s0i, with
M .T/ D fXg
E0 D f.r1; X/; .r2; X/g
s0 D as0 W X 7! 1
bs0 W X 7! 0
cs0 W X 7! 0 .
In this initial conﬁguration, the instances of r1 and r2 on X are eligible, but only
.r1; X/ is applicable.
The only possible transition is by .r1; X/ to a conﬁguration hE1; s1i, where E1 D
f.r2; X/g and as1.X/ D bs1.X/ D 1 while cs1.X/ D 0. In this conﬁguration, both
.r1; X/ and .r2; X/ are applicable, but only the latter is also eligible.
The only possible transition is by .r2; X/ to a conﬁguration hE2; s2i, where
E2 D ; and as2.X/ D bs2.X/ D cs2.X/ D 1. The execution of R ends in this
conﬁguration, in which the postcondition of the correctness formula holds.
Executions of LR. Since the working memory is reduced to M .T/ D fXg,
the process instances are simply .hLr1i; X/ and .hLr2i; X/. Since each process is
composed of an atomic region, there are two executions of LR, corresponding to
the execution of the two process instances in one order or the other.
Let us consider the execution in which .hLr2i; X/ is executed ﬁrst, from the state
s0 described above. In this execution, the loop-free program L2 takes the else
branch and executes skip. The resulting state is therefore s0 itself. The process
instance .hLr1i; X/ is then executed, with the else branch of the conditional,
resulting in the ﬁnal state s1 where as1.X/ D bs1.X/ D 1, but cs1.X/ D 0. The
correctness formula is thus not satisﬁed.
ut

112
7
Correctness of Programs: A Comparison
7.1.3
Rule Programs vs. Loop-Free Parallel Programs
We have just seen that the parallel program with loop-free processes LR derived
from a rule program R is not a good candidate to reproduce the behavior of R. The
next proposition expresses that, in general, there does not exist a parallel program
with loop-free processes (obeying a few reasonable syntactic constraints) that would
reproduce the behavior of a given rule program.
Proposition 7.2. There are rule programs of the form R D fr1; : : : ; rng, for which
no parallel program L  ŒL1k : : : kLn satisﬁes the same correctness formulas
as the rule program, and where Li 2 L .var.ri// with Attr.Li/  Attr.ri/ for
i D 1; : : : ; n.
The requirement Li 2 L .var.ri// means that Li is a loop-free program whose
variables are among those of the rule ri. In addition, Attr.Li/  Attr.ri/ means that
the attribute symbols used in Li are also among those of ri.
Proof. To prove the proposition, we consider a speciﬁc rule program and we prove
by contradiction that there exists no parallel program with the same behavior.
Consider again the rule program R D fr1; r2g composed of the rules below:
r1.x W T/ W x:a D 1 * x:b :D 1
r2.x W T/ W x:b D 1 * x:c :D 1
Assume that a program L D ŒL1kL2 exists, where L1 2 L .fxg/ and L2 2
L .fxg/, with Attr.L1/  fa; bg and Attr.L2/  fb; cg, and satisfying the same
correctness formulas as R.
Consider the executions of L on a working memory M .T/ D fXg reduced to one
object. Since L1 and L2 are loop-free programs, there exists an execution of L in
which .L2; X/ terminates before .L1; X/ starts. Let us call s1 the state at this point,
and s and s0 the initial and ﬁnal states of this execution. Therefore, we have
s
.L2;X/
! s1
.L1;X/
! s0 .
Since L1 cannot modify the values of the c attribute, the value of this attribute
on X is the same in s1 and at the end of the execution. That is, cs0.X/ D cs1.X/.
On the other hand, since L2 is deterministic and does not involve the a attribute,
the value cs1.X/ is the same if
as.X/ D 0
bs.X/ D 1
cs.X/ D 0
and if
as.X/ D 1
bs.X/ D 1
cs.X/ D 0 .

7.2
Correctness of Parallel Programs
113
Yet the ﬁnal value of c on X is not the same when R is executed from these
two initial states. This contradicts the assumption that L and R satisfy the same
correctness formulas.
ut
7.2
Correctness of Parallel Programs
In this section, we compare rule programs with parallel programs with while
programs as their processes. In addition to not being loop-free, parallel programs
with while programs as their processes also contain additional variables, called
ghost variables.
We start the section with the deﬁnition of ghost variables, which can be used
to encode information that is otherwise kept implicit in the rule engine. Based on
this deﬁnition, we introduce while programs and parallel programs using while
programs as their processes. Then, we compare rule programs with the parallel
programs that can be derived from them in a similar way to Sect. 7.1.2. Finally,
we compare rule programs with general parallel programs with while programs as
their processes.
7.2.1
Ghost Variables
The purpose of ghost variables is to allow imperative programs, such as while
programs, to encode information that is implicit in rule programs because it is
maintained internally by the rule engine. This information is analogous to the
program counter maintained by the processor that executes a sequential program.
More generally, a ghost variable is used to store information in addition to the
information encoded by attributes of objects. Contrary to attributes, ghost variables
do not take object values but only Boolean or theory-speciﬁc values, such as
numbers.
In the context of parallel programs, each ghost variable is local to a process.
There are no shared ghost variables. (An extension with shared additional variables
is discussed at the end of Sect. 7.2.5, but we do not include these in the deﬁnition
of ghost variables.) One consequence is that during the execution of a parallel
program under the saturated interleaving semantics, ghost variables undergo the
same instantiation scheme as the processes in which they occur, leading to as many
replicates of the ghost variable as there are instances of the process. From this
perspective, ghost variables are in fact functions, and each process instance handles
the image under this function of the objects on which the process is instantiated.

114
7
Correctness of Programs: A Comparison
Fig. 7.2 Expressions and
assignment with ghost
variables
Syntax
We augment the signature ˙ introduced in Sect. 3.1 with an inﬁnite set of function
symbols, denoted Ghost. We will use lowercase Greek letters for ghost variables,
such as ; ı; : : :
We add a second parameter to all the languages deﬁned up to now with one
parameter. These languages are: E .V /, B.V /, F.V / introducing respectively
expressions, Boolean expressions or non-quantiﬁed formulas, and possibly quan-
tiﬁed formulas in Fig. 3.1; A .V / introducing assignment in Fig. 3.3; L .V / for
loop-free programs in Fig. 6.1; and PL .V / for parallel programs with loop-free
processes in Fig. 7.1.
The second parameter comes in addition to the set V  Var of variables, and
is a set of ghost variables G  Ghost. We deﬁne the languages E .V; G/ and
A .V; G/ by the grammar in Fig. 7.2. This grammar simply adds derivations to
incorporate ghost variables into expressions and assignment to the grammars of
E .V / and A .V /. (Similar extensions have to be made for each theory-speciﬁc kind
of expression.)
The B.V; G/, F.V; G/, L .V; G/ and PL .V; G/ languages are obtained by
replacing expressions and assignments in their grammars with those from E .V; G/
and A .V; G/. Unsurprisingly, the one-parameter version of each of these languages
is equivalent to its two-parameter version where the set of ghost variables is empty:
for example, the languages L .V / and L .V; ;/ are the same.
Example. The following program contains the ghost variable :
L.p W Person/W  :D false I if  then p:bonus :D 0 else p:bonus :D 1 fi
Although ghost variables are included in the signature as function symbols, a
ghost variable appears in a program only with its symbol. Its implicit argument list
is made of the variables of the program in which it appears.

7.2
Correctness of Parallel Programs
115
Fig. 7.3 while programs
Semantics
A state s interprets a ghost variable  occurring in a program that involves the
variables o1; : : : ; om by a function s deﬁned on
 m with values in
[f?g. A ghost
variable is eventually given a value by an additional variable valuation. The value
of  in the state s under the valuation  is s..o1/; : : : ; .om//.
Assigning an expression e to a ghost variable  in a state s and under a valuation 
results in a state s0, where the ghost variable is interpreted by a function s0 that
has the same values as s, except on ..o1/; : : : ; .om// where it takes the value
resulting from the interpretation of e in s under .
7.2.2
while Programs
We now introduce the languages W .V; G/ of while programs, parameterized by a
set V  Var of variables and a set G  Ghost of ghost variables.
The grammar of W .V; G/ in Fig. 7.3 relies on the languages of expressions,
formulas and assignment extended with ghost variables in Fig. 7.2. It builds on
the grammar of loop-free programs introduced in Fig. 6.1, adding the while
statement. Note that although while loops may occur within other loops or within
conditionals, they may not occur within atomic regions.
Also, if b 2 B.V; G/ is a Boolean expression, and L 2 L .V; G/ is a loop-
free program, we will use while b hLi as an abbreviated notation for the loop
while b begin hLi end.
We deﬁne that a while program is well-typed for a type constraint by induction
on its structure.
The execution of a loop while b begin W end in a state s under a valuation
, where b is a Boolean expression and W is a while program, is composed of a
possibly inﬁnite sequence of transitions between states. This sequence starts in s;
if b does not hold in s under  it ends, and the state resulting from the execution
of the loop is s. Otherwise, the transition sequence extends from s by executing the
program W , resulting in a state s0. If b does not hold in s0 under  the transition
sequence ends, and the state resulting from the execution of the loop is s0, etc.

116
7
Correctness of Programs: A Comparison
Fig. 7.4 Parallel programs
composed of while
programs
Given a while program W 2 W .Var; Ghost/ well-typed for some type cons-
traint , and two T -compliant states s and s0, we write s
W! s0 if there exists a
valuation  well-typed for , such that the execution of W in s under  terminates
and results in s0.
7.2.3
Parallel Programs
We can now introduce the language PW .V; G/ of parallel programs composed of
while programs with ghost variables as their processes. Its grammar is provided
in Fig. 7.4.
We will use the saturated interleaving semantics for parallel programs. We
deﬁned this semantics in Sect. 7.1.1 on parallel programs with loop-free processes;
it transposes directly onto parallel programs composed of while programs with
ghost variables.
Example. Consider the parallel program P D ŒP1 with only one process, as deﬁned
below.
P1.p W Person/ W  :D true I
if  then p:bonus :D 0 I  :D false else p:bonus :D 1 fi
An execution of P on a working memory M .Person/ D fAlice; Bobg made of two
persons will interleave the statements of two process instances, namely .P1; Alice/
and .P1; Bob/. In each of these process instances, the ghost variable  will be
interpreted on the person speciﬁc to the instance. As a consequence, the statement
 :D false in one process instance, say .P1; Alice/, will update only the value of 
on Alice.
In other words, and as mentioned earlier, ghost variables are local to each process
instance; there are no shared ghost variables. Process instances may still share data
through attributes of objects, although in this example this cannot happen because
the process has only one variable. As a consequence, the two process instances are
disjoint, and the program P has only one execution, which sets the bonuses of Alice
and Bob to zero.
7.2.4
Parallel Program Derived from a Rule Program
We have seen in Proposition 7.1 that, in general, the parallel program with loop-
free processes LR derived from a rule program R does not have the same behavior

7.2
Correctness of Parallel Programs
117
as R, basically because the loop-free process derived from one rule might terminate
before the rule guard has the chance of being made valid by the execution of another
rule/process.
With the introduction of the while statement, we are now able to propose
an alternate parallel program derived from a rule program that will not terminate
prematurely. We must however prevent this program from entering trivial loops
when the application of a rule does not invalidate its guard. This task is the role
of the eligibility strategy in a rule engine.
The one-shot eligibility strategy makes a rule instance ineligible once it has been
applied (see Sect. 5.6.4). To encode it, we use for each rule a ghost variable ı (for
“done”) with Boolean values.
Deﬁnition 7.2. Given a rule program R D fr1; : : : ; rng, the parallel program
with while programs as processes derived from R, is the program WR 
ŒWr1k : : : kWrn deﬁned as follows, with ri D .Eoi; ETi; gi; ai/ and ıi 2 Ghost for
i D 1; : : : ; n:
Wri.Eoi W ETi/
def
 ıi:DfalseIwhile :ıi hif gi then ai I ıi :D true else skip fii
Example. Let us consider the program taken as counterexample in Proposition 7.1:
r1.x W T/ W x:a D 1 * x:b :D 1
r2.x W T/ W x:b D 1 * x:c :D 1
The parallel program with while programs as processes derived from R is the
program WR  ŒWr1kWr2, with
Wr1.x W T /  ı1 :D false I
while :ı1 hif x:a D 1 then x:b :D 1 I ı1:Dtrue else skip fii
Wr2.x W T /  ı2:Dfalse I
while :ı2 hif x:b D 1 then x:c :D 1 I ı2:Dtrue else skip fii
As in the proof of Proposition 7.1, let us consider the execution of WR from the
state s0 below:
M .T/ D fXg
s0 D as0 W X 7! 1
bs0 W X 7! 0
cs0 W X 7! 0 .
The execution of the parallel program that caused the mismatch in behavior was the
one in which the process derived from r2 was executed ﬁrst. In such an execution,
with .Wr2; X/ starting while we still have bs0.X/ D 0, the process instance .Wr2; X/
loops on the skip statement.
Assuming a fair scheduler, .Wr1; X/ is eventually started; this causes a transition
to a state s1 where bs1.X/ D 1 and ıs1
1 .X/ D true.

118
7
Correctness of Programs: A Comparison
The process instance .Wr1; X/ then terminates, whereas .Wr2; X/ causes a
transition to a state s2 where cs2.X/ D 1 and ıs2
2 .X/ D true.
With the process instance .Wr2; X/ terminating in turn, the program WR ends in
a state that satisﬁes the expected postcondition.
The program WR is thus a better candidate than LR to reproduce the behavior
of R. However, it fails to do so from the standpoint of termination.
Proposition 7.3. Let WR be the parallel program with while programs as
processes derived from a rule program R:
(i) Any terminating execution of WR is also an execution of R.
(ii) WR might not terminate (whereas R always does).
This proposition can informally be worded as “WR has the same behavior as R
when it terminates”. To prove it, we ﬁrst introduce ghost-independent states, which
are states in which the ghost variables have been “erased”.
Deﬁnition 7.3. Given a state s, the ghost-independent state s\ is the state that
interprets all the symbols in the same way as s, except ghost variables which are
all interpreted by the constant function returning ?.
An assertion ' 2 F.Var/ that contains no ghost variable holds in a state s if and
only if it holds in the state s\.
Proof of Proposition 7.3. The proof addresses each statement of the proposition in
turn.
– Proof of (i). Consider a rule program R D fr1; : : : ; rng. The parallel program
with while programs as processes derived from R is WR  ŒWr1k : : : kWrn, with
for i D 1; : : : ; n:
Wri.Eoi W ETi/ 
`0 W ıi :D false I
`1 W while :ıi begin
`2 W
hif gi then ai I ıi :D true else skip fii
`3 W end
Let s and s0 be two T -compliant states such that s
W! s0, that is, there is a
terminating execution of the parallel program WR from s that results in s0. This
means that there exist some states s0; : : : ; sm such that
s D s0
w1
!
`1 s1
w2
!
`2 : : :
wm1
!
`m1 sm1
wm
!
`m sm D s0
For each j D 1; : : : ; m, the transition from sj 1 to sj involves a process instance
wj D .Wrij ; EOj /, where ij 2 f1; : : : ; ng is the index of a rule rij 2 R, and EOj 2
M .rij / is a tuple of objects well-typed for the rule rij ; and a statement of the process
Wrij , labeled by `j 2 f`0; `1; `2g. The transition occurs when the statement of Wrij

7.2
Correctness of Parallel Programs
119
is executed at `j on the objects EOj, that is, under some valuation  that maps the
variables in Eoij onto the objects in EOj , and is hence well-typed for .Eoij W ETij /.
Let us now consider the ghost-independent states s\
0; : : : ; s\
m corresponding to the
states of the transition sequence above, and let us examine for each j D 1; : : : ; m
the relationship between s\
j 1 and s\
j, depending on the statement at `j .
(a) If `j D `0, the executed statement relates only to the ghost variable ıij , so
we have s\
j 1 D s\
j . In addition we have sj ;  ˆ :ıij , which implies that the
next transition for the process instance wj will execute the statement at `1 as
described by case (b) below.
(b) If `j D `1 and sj 1;  ˆ :ıij , the next transition for the process instance wj
will enter the loop at `2, as described by cases (c) and (d). Also, since no action
is performed in this transition, we have sj 1 D sj and hence s\
j 1 D s\
j .
(c) If `j D `2 and sj 1;  6ˆ gij , the statement executed is skip, so we have
s\
j 1 D s\
j . The next transition for the process instance wj will execute the
statement at `1 as described by case (b).
(d) If `j D `2 and sj 1;  ˆ gij the statement executed is aij I ıij :D true, meaning
on the one hand that hs\
j 1; s\
j i;  ˆ Oaij , and on the other hand that sj;  ˆ ıij .
The next transition for wj will therefore execute the statement at `1 as described
by case (e).
(e) If `j D `1 and sj 1;  ˆ ıij the next transition for the process instance wj will
end its execution at `3.
Since by hypothesis the execution of WR from s terminates, the last transition
related to each process instance corresponds to the case (e) above. It follows
from the analysis above that the preceding transition related to the same process
instance must correspond to case (d). In this transition we have s\
j 1;  ˆ gij and
hs\
j 1; s\
j i;  ˆ Oaij , that is, s\
j 1
.rij ; E
Oj /
! s\
j . In all other transitions related to this
process instance we have s\
j 1 D s\
j .
Since each well-typed rule instance that can be formed from R and M occurs
exactly once in the sequence, we have s\
0
R
! s\
m. As ghost variables are neither
considered nor modiﬁed during the execution of R, we have s
R
! s0 as well. In
other words, the execution of WR is also an execution of R.
– Proof of (ii). We now prove the second statement of Proposition 7.3 by exhibiting
a rule program whose derived parallel program with while programs as processes
does not terminate. Consider again the rule program R D fr1; r2g below
r1.x W T/ W x:a D 1 * x:b :D 1
r2.x W T/ W x:b D 1 * x:c :D 1

120
7
Correctness of Programs: A Comparison
The parallel program with while programs as processes derived from R is the
program WR  ŒWr1kWr2, with
Wr1.x W T /  ı1 :D false I
while :ı1 hif x:a D 1 then x:b:D1 I ı1 :D true else skip fii
Wr2.x W T /  ı2 :D false I
while :ı2 hif x:b D 1 then x:c:D1 I ı2 :D true else skip fii
This program does not terminate when executed from the state s0 deﬁned as
M .T/ D fXg
s0 D as0 W X 7! 0
bs0 W X 7! 0
cs0 W X 7! 0
because none of the rule guards ever becomes valid.
ut
7.2.5
Rule Programs vs. Parallel Programs
Given a rule program R, the parallel program WR derived from R as deﬁned in
the previous section fails to reproduce the behavior of R from the viewpoint of
termination.
Is it possible to devise a systematic and compositional way of building a parallel
program composed of while programs, possibly with ghost variables, from a rule
program, so that the parallel program and the rule program have the same behavior
in the sense that they satisfy the same correctness formulas?
By “compositional”, we mean that the parallel program has one process per
rule; the variables and attribute symbols of each process are among those of the
corresponding rule; the generation of the process is based only on the rule, and is
thus independent from the other rules of the rule program. Again the answer is:
no. That is, it is not possible to devise a way of generating a parallel program that
simulates a rule program.
Theorem 7.4. There exists no function ˘ that maps a rule r onto a while
program with ghost variables, where ˘.r/ 2 W .var.r/; Ghost/ and Attr.˘.r// 
Attr.r/, such that given a rule program R D fr1; : : : ; rng, the parallel program
Œ˘.r1/k : : : k˘.rn/ satisﬁes the same correctness formulas as R, either in the sense
of partial or of total correctness.
Proof. To prove the theorem, we exhibit a counterexample. Consider the three rule
programs R1 D fr1g, R2 D fr2g and R3 D fr1; r2g constructed with the two rules
below:

7.2
Correctness of Parallel Programs
121
r1.x W T/ W x:a D 1 * x:a :D 2
r2.x W T/ W true * x:a :D 1
These programs satisfy the following correctness formulas:
f8x W T .x:a D 0/g R1 f8x W T .x:a D 0/g
f8x W T .x:a D 0/g R2 f8x W T .x:a D 1/g
f8x W T .x:a D 0/g R3 f8x W T .x:a D 2/g .
Let us assume that the function ˘ described above exists. In addition, let us write
p  8x W T .x:a D 0/.
If ˘ exists, then the parallel program P1 D Œ˘.r1/ has the same behavior as R1.
Firstly, this implies that P1 terminates when executed from a state that satisﬁes p:
otherwise it would satisfy in the sense of partial correctness any correctness formula
with p as its precondition, which R1 does not. Secondly, when P1 is executed from a
state that satisﬁes p, it results in a state where the same holds. In such an execution,
the process instances executed are all the instances of ˘.r1/ on the instances of the
type T, that is, I1 D f.˘.r1/; X/ j X 2 M .T/g.
Similarly, the parallel program P2 D Œ˘.r2/, when executed from a state that
satisﬁes p, terminates and results in a state where the value of a is 1 for all instances
of the type T. The process instances executed are I2 D f.˘.r2/; X/ j X 2 M .T/g.
Consider now the parallel program P3 D Œ˘.r1/k˘.r2/, and its executions
from a state that satisﬁes p. The process instances to execute are I1 [ I2. Since
the execution of P1 from the same state terminates, there is an execution of P3 in
which all the process instances in I1 are executed and terminate, before an instance
of ˘.r2/ is executed. The state at this point of the execution still satisﬁes p, as
seen above. In this execution of P3, all the instances of ˘.r2/ are then executed and
terminate.
The program P3 thus terminates, but in a state where 8x W T .x:a D 1/. This con-
tradicts the assumption that P3 and R3 satisfy the same correctness formulas.
ut
We have just shown with Theorem 7.4 that, in general, a rule program cannot be
simulated by a parallel program whose processes are while programs possibly
involving ghost variables under a few reasonable syntactic constraints. As a
consequence, in general we cannot prove a correctness formula for a rule program
by applying a proof method such as the Owicki-Gries one [2,5] to a parallel program
built from the rule program.
This result is basically due to the fact that the execution of a rule instance can
have an effect on the applicability of another rule instance, whereas this is not the
case among process instances. In other words, the individual processes of a parallel
program cannot simulate the global scheduling performed by the rule engine.
In particular, this result is not the consequence of the constraint for ghost
variables to be local to each process instance. Assume indeed that we allow

122
7
Correctness of Programs: A Comparison
additional variables to be shared by all the processes of a parallel program (these
additional variables could be introduced in our language as function symbols of
arity 0). Assume also that there exists a function Init that maps the rules of a
rule program onto some while program such that the parallel program P 
Init.r1; : : : ; rn/ I Œ˘.r1/k : : : k˘.rn/ satisﬁes the same correctness formulas as the
rule program fr1; : : : ; rng.
Consider the rule program R D fr1; r2; r3g constructed with the rules below:
r1.x W T/ W x:a D 1 * x:a :D 2
r2.x W T/ W true * x:a :D 1
r3.x W T/ W x:a D 2 * x:a :D 3
Consider an execution of R on a working memory that contains only one object
X 2 M .T/. As noted in Sect. 6.1.1, in the ﬁnal conﬁguration of this execution, for
each i D 1; 2; 3 either the rule instance .ri; X/ is not eligible or the guard gi does
not hold on X. This is the condition that the parallel program P has to encode as the
exit condition of each process ˘.ri/.
Contrary to the eligibility of each rule instance, which can vary only as the
consequence of the rule instance’s own application, the truth value of a rule guard on
the object X can vary as the result of the application of another rule. For example,
executing .r2; X/ in a state s where as.X/ D 0 changes the truth value of g1 on
X. This change must be reﬂected by the update of a shared variable 1 in order
to be taken into account by the exit conditions of all processes, including ˘.r3/.
However, the shared variable can be updated only by the process ˘.r1/, since ˘
is a function of each rule only. If the process ˘.r3/ is scheduled after ˘.r2/ has
changed the truth value of g1 but before ˘.r1/ has updated 1, then ˘.r3/ will base
its execution on a wrong value of 1, possibly exiting too early.
7.3
Correctness of Nondeterministic Programs
Nondeterministic programs are another programming paradigm of a declarative
nature. The central construct of nondeterministic programs is the guarded command
introduced by Edsger Dijkstra [3]. The implicit aspect of nondeterministic programs
lies in the unspeciﬁed choice between several valid guards in nondeterministic
statements.
In this section, we ﬁrst brieﬂy introduce nondeterministic programs, so as to
connect their standard deﬁnition to our formal framework. Then we compare rule
programs and nondeterministic programs, to ﬁnd that there is a way of deriving a
nondeterministic program with ghost variables from a rule program, so that both
have the same behavior.

7.3
Correctness of Nondeterministic Programs
123
Fig. 7.5 Nondeterministic programs
7.3.1
Nondeterministic Programs
Syntax
As just mentioned, the central construct of nondeterministic programs is the guarded
command. A guarded command is made of a Boolean expression (the guard) and a
program (the command). It does not constitute a statement in itself, but serves as a
building block for the nondeterministic conditional and loop. As we will only use
the nondeterministic loop, we do not include the nondeterministic conditional in our
language of nondeterministic programs.
In Fig. 7.5, we deﬁne the grammar of the N .V; G/ language of nondeterministic
programs, which resembles the language of while programs, with the do-od
nondeterministic loop in lieu of the while loop. Note that, to avoid any confusion
with logical implication or with the concrete syntax of rules, we use a special
arrow + between the guard and the command in guarded commands.
The variables that occur in a nondeterministic program usually come with
associated types, for example because they were inherited from a rule program.
As for the other languages that we introduced in this chapter, we deﬁne that a
nondeterministic program is well-typed for a type constraint by induction on its
structure, based on well-typed formulas and assignment.
Saturated Semantics
The standard semantics for executing a nondeterministic loop on some input
data would be to consider the guards that hold in the current state, to pick one
nondeterministically, to update the current state by executing the corresponding
command, and to repeat this process until no guard holds [3].
Example. Assume that, for some reason, one wants to reduce the ages of two
persons to their greatest common divisor. This could be achieved by the following
nondeterministic program under the standard semantics for do-od loops:
P.p W Person; q W Person/ W do p:age > q:age + p:age :D p:age  q:age Œ
p:age < q:age + q:age:Dq:age  p:age od

124
7
Correctness of Programs: A Comparison
For example, consider an execution of P from the state s0 deﬁned below, on some
input data (that is, under some valuation) that maps p onto Alice and q onto Bob:
ages0.Alice/ D 24
ages0.Bob/ D 18 .
In the state s0, the ﬁrst guard holds, and the execution of the ﬁrst command results
in the state s1 where ages1.Alice/ D 6. In s1, the second guard holds, leading to s2
where ages2.Bob/ D 12. There again, the second guard holds, leading to s3 where
ages3.Alice/ D ages3.Bob/ D 6. The loop and the program then terminate.
As with parallel programs (see Sect. 7.1.1) we are going to extend the standard
semantics of nondeterministic programs by adapting the instantiation of programs
to support executions on a working memory.
A nondeterministic loop is of the form do gc1 Œ : : : Œ gcn od, where for i D
1; : : : ; n each gci  gi + ci is a guarded command with gi 2 B.Var; Ghost/ and
ci 2 N .Var; Ghost/. For each i D 1; : : : ; n, the guarded command gci involves
variables in its guard and command, which come with a type constraint .Eoi W ETi/ for
them.
When executing a nondeterministic loop on a working memory M , the saturated
semantics considers for a guarded command gci all the instances of the type T i
j
as possible values for each variable oi
j that occurs in the guarded command. As a
consequence, as many instances of each guard gi are assessed, and all of them that
hold in the current state are candidates to be picked.
Example. Consider the following nondeterministic program:
P.p W Person; q W Person/ W do p:age > q:age + p:age:Dp:age  q:age od
and its execution under the saturated semantics on a working memory such as
M .Person/ D fAlice; Bobg.
In this execution, four instances of the guarded command are created, corre-
sponding to the four ways of mapping the two variables p and q onto the two
instances of the type Person. The guard p:age > q:age is thus assessed in each
successive state of the execution under the following four valuations:
1 W
p 7! Alice
q 7! Alice
2 W
p 7! Alice
q 7! Bob
3 W
p 7! Bob
q 7! Alice
4 W
p 7! Bob
q 7! Bob .
Regardless of the state, the guard will never hold under 1 nor under 4. Therefore,
we end up with the same guards being assessed in each successive state, and the
same commands executed, as in the previous example.

7.3
Correctness of Nondeterministic Programs
125
Note that with this same program and the saturated semantics, we can compute
the greatest common divisor of the ages of any number of persons by simply adding
them to the working memory.
7.3.2
Nondeterministic Program Derived from a Rule Program
Deﬁnition 7.4. Given a rule program R D fr1; : : : ; rng, the nondeterministic
program derived from R is the program deﬁned as follows, with ri D .Eoi; ETi; gi; ai/
and ıi 2 Ghost for i D 1; : : : ; n:
PR.Eo W ET /
def
 ı1 :D falseI : : : I ın :D false I do
n
iD1 gi ^ :ıi + ai I ıi :D true od
The notations Eo and ET denote the respective concatenations of the tuples Eoi and
ETi for i D 1; : : : ; n.
As for parallel programs in Sect. 7.2.4, for each rule ri we use a ghost variable ıi
(with ı standing for “done”) with Boolean values to encode the one-shot eligibility
strategy.
Example. Consider the rule program R D fr1; r2g below:
r1.x W P/ W x:age  12 * x:status :D Child
r2.y W P/ W y:status D Child * y:gift :D Bear
The nondeterministic program PR derived from R is:
PR.x W P; y W P/ W ı1 :D false I ı2 :D false I
do x:age  12 & :ı1 + x:status :D Child I ı1 :D true Œ
y:status D Child & :ı2 + y:gift :D Bear I ı2 :D true od
The nondeterministic program derived from a given rule program can be seen
as the partial evaluation on the rule program of the description given in Chap. 5
of a rule engine under the one-shot execution strategy. We show below that a rule
program R and the nondeterministic program PR have the same behavior.
Theorem 7.5. The nondeterministic program PR derived from a given rule pro-
gram R satisﬁes the same correctness formulas as R in the sense of total
correctness.
Since R always terminates under the one-shot execution strategy, the indication
“in the sense of total correctness” implies that PR always terminates as well.

126
7
Correctness of Programs: A Comparison
Proof. Consider a rule program R D fr1; : : : ; rng with ri D .Eoi; ETi; gi; ai/ for
i D 1; : : : ; n, and the nondeterministic program PR derived from it. To prove the
theorem, we have to show that PR always terminates, that any execution of PR is
an execution of R, and conversely that any execution of R is an execution of PR.
Termination of PR. When the nondeterministic loop in PR is ﬁrst executed, all
ghost variables ıi are false for all object tuples. Either no rule guard holds, and then
PR terminates immediately; or at least one rule guard holds, and the execution of the
picked command sets the corresponding ghost variable to true. In other words, on
each loop iteration, either the program ends or one ıi is set to true among those that
were false. It follows that the loop eventually ends, and hence that PR terminates.
Any execution of PR is an execution of R. Consider two T -compliant states s
and s0 such that s
PR
! s0, that is, there is a (terminating) execution of PR from s
that results in s0. This means that there exist some states s0; : : : ; sm such that
s
ı1 :D false I ::: I ın :D false
! s0
GC1
! s1
GC2
! : : :
GCm1
! sm1
GCm
! sm D s0
where for j D 1; : : : ; m, GCj D .gcij ; EOj/ is an instance of the guarded command
corresponding to the rule rij on a tuple of objects well-typed for this rule.
For each j D 1; : : : ; m, the transition sj 1
GCj
! sj occurs because the guard
gij holds in the state sj 1 under some valuation  that maps the variables Eoij onto
the objects EOj, and because the ghost variable ıij is false in the state sj 1 on the
objects EOj . The state sj results from the execution of the action aij in sj 1 under 
and then from the update of the ghost variable ıij on the objects EOj. In particular,
we have
sj 1;  ˆ gij
and
hsj 1; sj i;  ˆ Oaij .
(a)
On the other hand, let us deﬁne for each j D 1; : : : ; m the set
Ej D f.ri; EO/ j 1  i  n; EO 2 M .ri/; ı
sj
i . EO/ D falseg
of all the instances of rules of R whose corresponding ghost variable is false on the
objects of the instance. In each transition sj 1
GCj
! sj described above, we have
.rij ; EOj / 2 Ej 1
and
.rij ; EOj/ … Ej .
(b)
The assertions (a) and (b) mean that hEj; sj i is a conﬁguration that results from
a transition from hEj 1; sj 1i by the application of the rule instance .rij ; EOj/ under
the one-shot eligibility strategy.

References
127
As E0 D RIs0.R/, it follows that s0
R
! sm, that is, there is an execution of the
rule program R from the state s0 that results in sm. Since s\ D s\
0 and sm D s0, we
have s
R
! s0, and hence any execution of PR is an execution of R.
Any execution of R is an execution of PR. An argument similar to the previous,
symmetric one gives this result. This ends the proof of Theorem 7.5.
ut
As a conclusion, we now know how to get a nondeterministic program that
satisﬁes the same correctness formulas in the sense of total correctness as any rule
program considered for execution under the one-shot strategy. This means that given
a correctness formula fpg R fqg for a rule program R, we could use proof rule
(DO-OD) below [1] on the nondeterministic program derived from R to prove it.
fI ^ Big Si fIg
for i D 1; : : : ; n
fIg do
n
iD1 Bi + Si od fI ^ Vn
iD1 8Eoi W ETi :Big
(DO-OD)
where I 2 F.;; Ghost/
However this method is not compositional, in that it relies on a global invariant and
not on individual correctness formulas for the rules of R. This is a drawback in
our context, as it does not leverage the declarative nature of rule programs and the
modularity of rules.
Finding such a compositional proof rule is the subject of the next part.
References
1. Apt, K.R.: Ten years of Hoare’s logic: A survey—part II: Nondeterminism. Theor. Comp. Sci.
28, 83–109 (1984)
2. Apt, K.R., de Boer, F.S., Olderog, E.R.: Veriﬁcation of Sequential and Concurrent Programs,
3rd edn. Texts in Computer Science. Springer, Berlin (2009)
3. Dijkstra, E.W.: Guarded commands, nondeterminacy and formal derivation of programs. Comm.
ACM 18(8), 453–457 (1975)
4. Hoare, C.A.R.: Parallel programming: An axiomatic approach. Comp. Lang. 1(2), 151–160
(1976)
5. Owicki, S.S., Gries, D.: An axiomatic proof technique for parallel programs I. Acta Informatica
6, 319–340 (1976)

Part IV
Proof Rules for Rule Programs

Chapter 8
Main Steps in Rule Program Veriﬁcation
The purpose of the present Part IV is to propose a compositional veriﬁcation method
for rule programs. This veriﬁcation method is based on proof rules to derive a
correctness formula for a rule program from individual correctness formulas for
the rules of the program. It is compositional in the sense that it exploits the modular,
declarative nature of rule programs by deriving a global piece of information on the
rule program from local knowledge about each individual rule.
In the present chapter, we explain the foundations of our veriﬁcation method
with a proof rule for a simple, although not trivial, class of rule programs. The next
chapter presents our veriﬁcation method for general rule programs, based on a
sound and relatively complete proof rule. Chapter 10 explores other classes of rule
programs and provides the proof rules suited to each case.
We still work within the setting described in Sect. 6.1, that is, rule programs are
executed under the one-shot execution strategy and we use the classical deﬁnitions
of proofs and proof rules, as discussed in that section.
The objective of a compositional veriﬁcation method for rule programs is to
help prove a correctness formula for a rule program by leveraging the declarative,
modular structure of the program as a set of rules. Consider a rule program
R D fr1; : : : ; rng and a correctness formula fpg R fqg for this rule program.
The veriﬁcation method should allow us to prove this correctness formula by
proving “smaller” correctness formulas fpig ri fqig for the individual rules in the
program. Indeed, proving the correctness formulas for the rules is considered
simpler, because they involve only the objects handled in one execution of one rule.
However, we have seen with Proposition 6.2 that correctness formulas do
not trivially transpose from rules to rule programs. This is due to the possible
interference cases between the multiple rule instance applications in a rule program
execution and the pre- and postconditions of the correctness formulas.
Interference between the statements of a program and the individual correctness
formulas for these statements is a well-known phenomenon in parallel programs
[3, 4, 6]. Tackling them is the focus of veriﬁcation methods for parallel programs,
such as the one proposed by Owicki and Gries [6]. This approach is presented in
B. Berstel-Da Silva, Veriﬁcation of Business Rules Programs,
DOI 10.1007/978-3-642-40038-4__8, © Springer-Verlag Berlin Heidelberg 2014
131

132
8
Main Steps in Rule Program Veriﬁcation
great detail in [1, 2], with a progressive introduction of gradually more complex
classes of parallel programs.
Although Theorem 7.4 has invalidated the idea of mapping rule programs
onto parallel ones to use a veriﬁcation method devised for parallel programs,
our approach to addressing interference in rule programs follows similar paths.
The speciﬁcities come from the kinds of interference that can occur during the
execution of a rule program.
8.1
Interference Cases in Rule Programs
An execution of a rule program is a sequence of rule instance applications. Each rule
instance application has an effect on the current state. Those effects that are called
interference cases are the ones that prevent the derivation of the global correctness
formula to prove from the correctness formulas focused on the individual rules.
An interference has the undesired effect of leading to a state where the pre- or
postcondition of an individual correctness formula no longer holds.
An interference thus involves the application of a rule instance and an assertion.
In a rule program execution, two kinds of interference can occur: cross-rule
interference and interference due to aliasing.
8.1.1
Cross-Rule Interference
Consider the two rules below:
r1.p W P/ W p:age > 60 * p:bonus :D p:bonus C 10
r2.p W P/ W p:cat D Gold * p:bonus :D p:bonus C 15
The following correctness formulas hold for each of the individual rules r1 and r2:
ftrueg r1 ftrueg
fp:bonus D 0 ^ p:cat D Goldg r2 fp:bonus D 15g .
The interference between the rules r1 and r2 and these individual correctness
formulas is visible when considering the following global correctness formula for
the rule program R1 D fr1; r2g:
f8p W P .p:bonus D 0 ^ p:cat D Gold/g R1 f8p W P .p:bonus D 15/g .
This correctness formula is obtained by conjunction of the pre- and postconditions
of the individual correctness formulas above, but it does not hold. Indeed, when

8.1
Interference Cases in Rule Programs
133
executing the program R1 from a state where an instance of P both has age greater
than 60 and is in the Gold category, its bonus is increased by 25.
The interference here results from the fact that neither the pre- nor the post-
condition of the correctness formula for r2 is guaranteed to be preserved by the
application of r1. This is why we call it cross-rule interference. In contrast, the
same global correctness formula holds for the rule program R2 D fr2g, which does
not contain r1:
f8p W P .p:bonus D 0 ^ p:cat D Gold/g R2 f8p W P .p:bonus D 15/g .
Furthermore, the following correctness formulas for R1 hold, and can be derived
by the proof rules given in Sect. 8.3 or in Chap.9 from individual correctness
formulas that do not suffer from cross-rule interference with the rules in the
program:
f8p W P .p:bonus D 0 ^ p:cat D Gold ^ p:age  60/g R1
f8p W P .p:bonus D 15/g
f8p W P .p:bonus D 0 ^ p:cat D Gold/g R1
f8p W P .p:bonus D 15 _ p:bonus D 25/g
f8p W P .p:bonus D 0 ^ p:cat D Gold/g R1
f8p W P .p:age  60 ^ p:bonus D 15 _ p:age > 60 ^ p:bonus D 25/g .
8.1.2
Interference Due to Aliasing
The aliasing phenomenon is inherited by rule programs from their use of objects.
Its name comes from the fact that two variables can refer to the same object. As a
consequence, an update of the object held in one variable can cause a change in the
object held by another one. Aliasing is widely studied, for example by Morris [5]
from whom we adopt the approach which consists of including a conditional
expression in the formula that deﬁnes the effect of assignment. See Sects. 4.4 and 5.3
for our handling of aliasing, and [2, p. 240] for additional references.
The two rules below provide an example of interference due to aliasing. They
state the rules for assigning points on a discount card depending on the bonus of a
person.
r3.c W C; p W P/ W p:bonus < 20 * c:points :D c:points C 5
r4.c W C; p W P/ W p:bonus  20 * c:points :D c:points C 10
These rules satisfy the following correctness formulas:

134
8
Main Steps in Rule Program Veriﬁcation
fc:points D 0g r3 fc:points D 0 _ c:points D 5g
fc:points D 0g r4 fc:points D 0 _ c:points D 10g .
The global correctness formula obtained by conjunction of the pre- and postcon-
ditions of these individual correctness formulas obviously does not hold for the rule
program R3 D fr3; r4g:
f8c W C .c:points D 0/g R3 f8c W C .c:points D 0/g .
Even the following correctness formulas, suggested by the ones that hold for R1
above, do not hold:
f8c W C .c:points D 0/g R3 f8c W C .c:points D 0 _ c:points D 5 _ c:points D 10/g
f8p W P 8c W C .p:bonus < 20 ^ c:points D 0/g R3 f8c W C .c:points D 5/g .
Indeed, consider an execution of R3 on a working memory that contains three
persons with bonuses lower than 20 and an empty discount card. This execution
results in a state where the discount card has 15 points. The interference due to
aliasing at work here results in the fact that the same card object is referred to by
the c variables of all rule instances during the execution of R3.
The rule program R3 could be modiﬁed into R0
3 D fr0
3; r0
4g to avoid aliasing, by
adding a link between p and c to the guard of each rule:
r0
3.c W C; p W P/ W p:bonus < 20 & p D c:owner * c:points :D c:points C 5
r0
4.c W C; p W P/ W p:bonus 20 & p D c:owner * c:points :D c:points C10
However these modiﬁed rules have a different behavior from the rules in R3.
For example, when executed on a working memory that contains one instance of
P for each person in a family, and one instance of C representing the discount card
of the family, program R3 computes the discount points earned by the family. Such
a scenario is not supported by rule program R0
3. In other words, aliasing might be
considered as a feature by the author of a rule program, who consciously leverages
it to implement a given speciﬁcation.
Using the proof rule given in Chap. 9, the following global correctness formula
for R3 can be derived from individual correctness formulas that do not suffer from
interference due to aliasing:
f8c W C .c:points D 0/g R3 f8c W C .c:points  0/g .
Another illustration of such an interference due to aliasing is provided by the
counterexample used in the proof of Proposition 6.2 on p. 105. The rule program
in this counterexample contains only one rule; interference occurs between several
instances of this rule.

8.2
Unary Rules
135
8.2
Unary Rules
We introduce now unary rules, which provide a simpliﬁed setting where the core
principles of our veriﬁcation method can be more easily grasped. As we see below,
the main contribution of unary rules is to eliminate interference due to aliasing.
Deﬁnition 8.1. A rule is a unary rule if it has at most one rule variable. An
assertion is a unary assertion if it has at most one free variable.
Example. The following rules are unary:
r1.p W Person/W p:age > 60 * p:bonus :D p:bonus C 10
r2.p W Person/W p:cat D Gold * p:bonus :D p:bonus C 15
The following assertions are unary:
p:bonus D 0 ^ p:cat D Gold
true .
In contrast, the following rule and assertion are not unary:
r3.p W Person; c W Cart/ W c:value > 500 * p:bonus :D p:bonus C c:value = 10
p:bonus  c:value .
By deﬁnition (see p. 54), an assertion focused on a unary rule is a unary assertion.
The interest of unary rules comes from the constraint imposed by the grammar
of expressions and discussed in Sect. 3.3.3, that formulas must be ﬂat. The conse-
quence is that neither the guard of a rule nor its action can contain a chain of attribute
references, such as p:spouse:bonus. Combine this constraint with the one for rules,
and hence for their guards and actions, to involve only one variable: the execution of
a unary rule is affected by, and affects, only the object to which it is applied. In other
words, unary rules and assertions cannot cause, or suffer from, interference due to
aliasing. On the other hand, however, not all rule programs can be expressed with
unary rules, as illustrated by the program used as an example in Sect. 8.1.2.
Lemma 8.1 below formalizes the immunity of unary rules to aliasing. Before
presenting it, we take the opportunity of simplifying notations for rule programs
made of unary rules.
If a rule r D .Eo; ET ; g; a/ is unary, its tuple of variables Eo is actually a singleton.
The sole variable of r is then written o and its type is written T ; the rule is thus
written r D .o; T; g; a/. The rule guard g is a unary assertion in o and the rule
action a is an assignment to an attribute of o.
Given a rule program R D fr1; : : : ; rng made of unary rules, we write each rule
ri of the rule program ri D .oi; Ti; gi; ai/ with ai  oi:fri :D eri. We use the
notation 8Eo W ET as an abbreviation for 8o1 W T1 : : : 8on W Tn.

136
8
Main Steps in Rule Program Veriﬁcation
Finally we simplify in a similar way the notations introduced in Sects. 3.5.1
and 4.2.3 when renaming the variables of a rule or of an assertion focused on a
rule. If x is a variable, r D .o; T; g; a/ is a unary rule, and ' is an assertion focused
on r (such as the guard g of r, or the pre- or postcondition of a correctness formula
focused on r), we write r.x/ and '.x/ for the rule r and the assertion ' where the
variable x has been substituted for o.
Lemma 8.1. Given a unary rule r D .o; T; g; a/ and a unary assertion ' 2
F.fxg/ in some variable x, the rule r preserves ' under the condition x ¤ o.
That is,
fx ¤ o ^ 'g r f'g .
Proof. Consider two T -compliant states s and s0, and a valuation  well-typed for
.o W T /, such that s;  ˆ x ¤ o ^ ' and s
.r;/
! s0.
If the rule instance .r; / is not applicable in s, then s0 D s and hence s0;  ˆ '.
If the rule instance .r; / is applicable in s, then hs; s0i;  ˆ Oa. The transition
assertion Oa for the action a  o:fr :D er is deﬁned in Sect. 4.5; in particular and as
noted in Sect. 5.3.3, it follows from x ¤ o that
hs; s0i;  ˆ x:f 0
r D x:fr ^
^
f 2Attrnffrg
x:f 0 D x:f .
That is, the states s and s0 give the same values to all attributes of the object onto
which  maps x. Since  is arbitrary and ' is unary in x, its truth value is the same
in s and s0.
In all cases we thus have s0;  ˆ ', which proves the lemma.
ut
8.3
A First Proof Rule
Consider a rule program R made of unary rules. Consider also a collection of
correctness formulas focused on the rules in R. As just discussed, these rules
and correctness formulas cannot suffer from interference due to aliasing. In the
present section we give a proof rule that tackles the other source of interference,
namely cross-rule interference. Both its form and the proof of its soundness will be
reminiscent of the Owicki-Gries proof rule for parallel programs [2,6]. As noted in
Sect. 7.2 though, the simulation of R by a parallel program, which would open the
door to applying the Owicki-Gries proof rule, is not possible in general.
Theorem 8.2. Let R D fr1; : : : ; rng be a rule program, and for i D 1; : : : ; n let
pi; qi 2 F.ri/ be assertions focused on the rules. If R is made of unary rules, then
the proof rule below is sound:

8.3
A First Proof Rule
137
fpig ri fqig
for i D 1; : : : ; n
fpi ^ pjg rj fpig
fqi ^ pj g rj fqig
)
for i; j D 1; : : : ; n with i ¤ j
n n
^
iD1
8oi W Ti pi
o
R
n n
^
iD1
8oi W Ti qi
o
.
(PR1)
In addition to the correctness formulas focused on the rules, the premises of this
proof rule contain correctness formulas expressing interference freedom, that is,
the fact that no cross-rule interference can occur. Although it might not be obvious
at ﬁrst sight, these correctness formulas are not focused on a rule, as they involve
both the variable oi used by the assertion pi or qi, and the variable oj used by the
assertion pj and the rule rj. The semantics of such correctness formulas for single
rules, which include variables that are not variables of the rule in their pre- and
postconditions, has been discussed in Sect. 6.2.
The application of this proof rule is discussed in detail on an example in
Sect. 8.4. Lemma 8.4 introduced in that section addresses the fact that the
interference-freedom correctness formulas are not focused on a rule.
As we show in Sect. 8.5, this proof rule is not complete, in the sense that there
exist rule programs and global correctness formulas for these rule programs that
cannot be proven with the proof rule. As for parallel programs, completeness is
achieved with the introduction of ghost variables. This is described in Sect. 10.1 for
the particular case of unary rules, and in Chap. 9 for the general case of rules of
arbitrary arity.
The proof of Theorem 8.2 relies on the fact that, among the correctness formulas
focused on the rules, only one makes a transition from its pre- to its postcondition
at each step in an execution of the rule program; and this correctness formula is
the one related to the rule instance that is executed. We formalize this property in
Lemma 8.3 below. To this end, we ﬁrst deﬁne what it means for a conﬁguration
of the abstract machine used for execution of rule programs (see Sect. 5.4.1) to be
consistent with a collection of correctness formulas focused on rules. The lemma is
then used to prove the theorem.
Deﬁnition 8.2. Given a rule program R D fr1; : : : ; rng made of unary rules, and
correctness formulas fpig ri fqig for i D 1; : : : ; n focused on the rules of R, a
conﬁguration hE; si of the abstract machine used for execution of rule programs is
consistent with the unary correctness formulas, or unary cf-consistent, if
for each i 2 f1; : : : ; ng and for any valuation  well-typed for .oi W Ti/, that
is, such that .oi/ 2 M .Ti/, we have
either
.ri; / 2 E and s;  ˆ pi
or
.ri; / … E and s;  ˆ qi .
We can now state Lemma 8.3, by which the premises of proof rule (PR1) ensure
that an execution of a rule program that starts in a conﬁguration consistent with
the unary correctness formulas considered results in a conﬁguration equally unary
cf-consistent.

138
8
Main Steps in Rule Program Veriﬁcation
Lemma 8.3. Let R D fr1; : : : ; rng be a rule program made of unary rules, and for
i D 1; : : : ; n let pi; qi 2 F.ri/ be assertions focused on the rules, such that the
following correctness formulas hold:
fpig ri fqig
for i D 1; : : : ; n
(a)
fpi ^ pj g rj fpig
fqi ^ pj g rj fqig

for i; j D 1; : : : ; n with i ¤ j .
(b)
In an execution hE; si
R
! hE0; s0i of the rule program, if hE; si is consistent with
the correctness formulas fpig ri fqig then hE0; s0i is as well.
Proof. The lemma is proven by induction on the length of executions of R.
Base step. If the execution is empty, that is, hE0; s0i is equal to hE; si, then the
lemma holds by hypothesis.
Induction step. We consider an execution hE0; s0i
R
! hEk; ski of length k  1
of the rule program, such that hE0; s0i is unary cf-consistent, and we assume that
hEk1; sk1i is unary cf-consistent.
Let hEk1; sk1i
Rk
! hEk; ski be the last transition of this execution, where Rk D
.rik; Ok/ with ik 2 f1; : : : ; ng and Ok 2 M .Tik/ by the deﬁnitions of Sect. 5.4.
Let us also consider some i 2 f1; : : : ; ng and some valuation , such that .oi/ 2
M .Ti/. We examine in turn the cases where the rule instance R D .ri; / is equal
to the rule instance Rk used in the last transition, or not; and if not, why.
– First case: R D Rk, that is, Rk D .ri; /. From hEk1; sk1i
Rk
! hEk; ski and the
transition rule (6.1), we have
.ri; / 2 Ek1
(c)
sk1
.ri;/
! sk
(d)
.ri; / … Ek .
(e)
From (c) and the hypothesis that hEk1; sk1i is unary cf-consistent, we have
sk1;  ˆ pi. By (a) and (d), this gives
sk;  ˆ qi .
– Second and third cases: R ¤ Rk, that is, .ri; / ¤ .rik; Ok/. By the transition
rule (6.1), a consequence is that if R 2 Ek1 then R 2 Ek and if R … Ek1 then
R … Ek.
Let us write '  pi when R 2 Ek1, and '  qi when R … Ek1. Since by
hypothesis hEk1; sk1i is unary cf-consistent, we have sk1;  ˆ '.
We now examine the cases where i D ik and i ¤ ik.

8.3
A First Proof Rule
139
– Second case: R ¤ Rk but still i D ik. Then we must have .oi/ ¤ Ok.
Consider another valuation 0, such that 0.oi/ D Ok and 0.x/ D .oi/ for some
fresh variable x: since .oi/ ¤ Ok and hence 0.x/ ¤ 0.oi/, we have 0 ˆ x ¤ oi.
By Lemma 4.2 we have sk1; 0 ˆ '.x/. Since sk1
.ri;0/
! sk and both ri and ' are
unary, by Lemma 8.1 we have sk; 0 ˆ '.x/. That is by Lemma 4.2 again,
sk;  ˆ ' .
– Third case: R ¤ Rk and i ¤ ik. Consider a valuation 0 such that 0.oi/ D .oi/
and 0.oik/ D Ok. Note that we can have 0.oi/ D 0.oik/ or not. However we
always have Rk D .rik; 0/.
By the transition rule (6.1) we have .rik; 0/ 2 Ek1. Since hEk1; sk1i is unary
cf-consistent by hypothesis, we have
sk1; 0 ˆ pik .
(f)
By Lemma 4.1, sk1;  ˆ ' gives
sk1; 0 ˆ ' .
(g)
By (b) we have f' ^ pikg rik f'g. With (f) and (g) this gives sk; 0 ˆ '. That is
by Lemma 4.1 again,
sk;  ˆ ' .
– Summary. We have considered an arbitrary i 2 f1; : : : ; ng and an arbitrary
valuation , such that .oi/ 2 M .Ti/.
In the ﬁrst case, we have shown that sk;  ˆ qi while .ri; / … Ek by (e).
In the second and third cases, we have shown that sk;  ˆ ', where '  pi when
.ri; / 2 Ek and '  qi when .ri; / … Ek.
In all cases we have therefore shown that hEk; ski is unary cf-consistent, which
proves the lemma.
ut
Proof of Theorem 8.2. Let R D fr1; : : : ; rng be a rule program made of unary rules,
and for i D 1; : : : ; n let pi; qi 2 F.ri/ be assertions focused on the rules, such that
the following correctness formulas hold:
fpig ri fqig
for i D 1; : : : ; n
(a)
fpi ^ pjg rj fpig
fqi ^ pjg rj fqig

for i; j D 1; : : : ; n with i ¤ j .
Also let s be a T -compliant state in which the precondition of the correctness
formula to prove holds, that is,

140
8
Main Steps in Rule Program Veriﬁcation
s ˆ
n
^
iD1
8oi W Ti pi .
(b)
Finally let s0 be a state that results from the execution of R from s, that is, s
R
! s0.
Each conjunct in (b) involves a typed quantiﬁcation, deﬁned in Sect. 4.1.4. By
this deﬁnition, for any i 2 f1; : : : ; ng we have s;  ˆ pi for any valuation  such
that .oi/ 2 M .Ti/.
For all of these i and , the rule instance .ri; / belongs to the set RIs.R/ of
all the instances of rules from the rule program R that are well-typed in s, a set
introduced in Sect. 5.4.2.
By deﬁnition, hRIs.R/; si is the initial conﬁguration of all executions of R from
s. The last two statements above express that this conﬁguration is consistent with
the correctness formulas fpig ri fqig for i D 1; : : : ; n. Consider the set E0 of all
eligible rule instances at the end of the execution from s to s0. By Lemma 8.3, the
ﬁnal conﬁguration hE0; s0i is also consistent with these correctness formulas.
It follows that, for any i 2 f1; : : : ; ng and any valuation  such that .oi/ 2
M .Ti/, we have s0;  ˆ qi. Indeed, consider the rule instance R D .ri; /:
(i) If R 2 E0 then since hE0; s0i is unary cf-consistent, we have s0;  ˆ pi. Since
s0 is the ﬁnal state of the execution of R, the rule instance R is not applicable
in s0, meaning that s0 R! s0. Thus by (a) we have s0;  ˆ qi.
(ii) If R … E0 then since hE0; s0i is unary cf-consistent, we have s0;  ˆ qi.
Therefore, by deﬁnition of typed quantiﬁcation again, we have
s0 ˆ
n
^
iD1
8oi W Ti qi
which proves the conclusion of proof rule (PR1), and ends the proof of the theorem.
ut
As a practical note, it is often the case in programs made of unary rules that
the sole variables of the rules in the program all have the same type. The pre- and
postconditions of the correctness formula in the conclusion of the proof rule can use
this as follows. If ri D .oi; T; gi; ai/ for i D 1; : : : ; n, then the proof rule can be
written
fpig ri fqig
for i D 1; : : : ; n
fpi ^ pjg rj fpig
fqi ^ pjg rj fqig
)
for i; j D 1; : : : ; n with i ¤ j
n
8o W T
n
^
iD1
pi.o/
o
R
n
8o W T
n
^
iD1
qi.o/
o
.

8.4
Usage
141
8.4
Usage
Consider a rule program responsible for assigning a bonus to customers based on
their ages, according to the function depicted in Fig. 8.1. The rule program R D
fr1; r2g below implements this speciﬁcation.
r1.x W P/ W x:age  50 * x:bonus :D x:age C 10
r2.y W P/ W y:age > 50 * y:bonus :D y:age 	 2  40
This program contains only unary rules. To avoid any confusion, we have given a
different name to the variable of each rule.
Imagine we have to certify that, to a set of customers with ages between 20
and 80, the rule program R will always assign bonuses between 30 and 120. This
amounts to proving the following correctness formula:
f8o W P .o:age 2 Œ20; 80/g R f8o W P .o:bonus 2 Œ30; 120/g .
8.4.1
Use the Proof Rule Bottom-Up
Given a correctness formula for a rule program, the proof task consists in ﬁnding
two assertions per rule in the program. These assertions must form valid correct-
ness formulas focused on the rules. The resulting correctness formulas must be
interference free. In addition, they must lead to the correctness formula to prove,
by means of the proof rule on rule programs, and possibly other proof rules, such as
the (CONSEQUENCE) one presented in Sect. 6.1.2.
We call this approach bottom-up because it starts from the correctness formula
to prove, which appears in the conclusion of the proof rule, and it looks for the
correctness formulas appearing in the premises.
In contrast, adopting a top-down approach on the rule program R presented
above would be of little use. Indeed, if we start by expressing correctness formulas
for the rules, we will probably propose
fx:age  50g r1 fx:bonus D x:age C 10g
fy:age > 50g r2 fy:bonus D 2 	 y:age  40g
which are not interference free, as each postcondition is invalidated by the other rule.
We will then perhaps weaken the postconditions to achieve interference freedom,
and propose

142
8
Main Steps in Rule Program Veriﬁcation
6
bonus
-
age
10
60
50
0

Fig. 8.1 Bonus depending
on age
fx:age  50g r1 fx:bonus D x:age C 10 _ x:bonus D 2 	 x:age  40g
fy:age > 50g r2 fy:bonus D y:age C 10 _ y:bonus D 2 	 y:age  40g .
However, since these correctness formulas have incompatible preconditions, one
can only derive a correctness formula whose precondition is false from them, which
is of little use.
On the other hand, weakening the preconditions would force us to account
in the postconditions for the executions of the rules where the guards do not
hold. And since in these cases we cannot say anything on the value of the bonus,
we seem to be unable to propose interesting correctness formulas that hold on the
individual rules.
8.4.2
What to Look for
The bottom-up approach means that, given a correctness formula fpg R fqg to prove
on a rule program R D fr1; : : : ; rng made of unary rules, we are going to look for
assertions pi; qi that meet the following criteria for i D 1; : : : ; n:
(i) The assertions are focused on the corresponding rule, that is, we have pi; qi 2
F.ri/.
(ii) Each correctness formula holds, that is, we have fpig ri fqig.
(iii) The correctness formulas are interference free, that is, for j D 1; : : : ; n with
j ¤ i, one has fpi ^ pjg rj fpig and fqi ^ pjg rj fqig.
(iv) The correctness formula derived by the proof rule leads to the target one, that
is, p !
 Vn
iD1 8oi W Ti pi

and
 Vn
iD1 8oi W Ti qi

! q.

8.4
Usage
143
In the search for the assertions pi; qi, we will draw inspiration from the pre- and
postconditions of the correctness formula to prove and from the effect of the rule
actions on the assertions proposed so far.
From a practical standpoint, each time a correctness formula for a rule is to
be veriﬁed in steps (ii) and (iii), we must consider both the case where the guard
of the rule is satisﬁed and the case where it is not. Furthermore, in step (iii)
the correctness formulas involve other variables that the rule variables. Then the
cases where these variables equal, or do not equal, the rule variables must both be
considered. However, the following lemma gives a useful shortcut, especially for
the correctness formulas that express the interference-freedom conditions.
Lemma 8.4. Given a correctness formula fpg r fqg focused on a unary rule r D
.o; T; g; a/, and a unary assertion ' 2 F.fxg/ in some variable x, if
f' ^ p ^ g ^ x D og r f'g
then
f' ^ pg r f'g .
Proof. Consider two states s and s0 and a valuation , such that s;  ˆ ' ^ p and
s
.r;/
! s0.
– If s;  ˆ g and  ˆ x D o then by hypothesis s0;  ˆ '.
– If s;  ˆ g and  ˆ x ¤ o then by Lemma 8.1 we have s0;  ˆ '.
– If s;  ˆ :g then we have s0 D s and hence s0;  ˆ '.
We thus have f' ^ pg r f'g in all cases, which proves the lemma.
ut
This
lemma
is
useful
when
applying
the
method,
to
verify
such
interference-freedom conditions as fpi ^ pjg rj fpig. Here, the assertion pi plays
the role of ' and the variable x is here oi. By the lemma, to verify this correctness
formula, it sufﬁces to verify that fpi.oj/ ^ pj ^ gj g rj fpi.oj/g holds.
8.4.3
Application of the Veriﬁcation Method
Let us recall the rule program R D fr1; r2g, which computes bonuses based on ages
according to the function depicted in Fig. 8.1.
r1.x W P/ W x:age  50 * x:bonus :D x:age C 10
r2.y W P/ W y:age > 50 * y:bonus :D y:age 	 2  40
We want to prove the following correctness formula for R, expressing that to a set
of customers with ages between 20 and 80, the rule program will always assign

144
8
Main Steps in Rule Program Veriﬁcation
bonuses between 30 and 120. In the rest of this example, we write a for the age
attribute and b for the bonus.
f8o W P .o:a 2 Œ20; 80/g R f8o W P .o:b 2 Œ30; 120/g
(8.1)
Adopting the approach described in this section, we are looking for a pre- and a
postcondition for each rule, such that:
(i) The correctness formulas for r1 and r2 that can be formed with these pre- and
postconditions hold.
(ii) These correctness formulas are interference free.
(iii) By the proof rule, they lead to the global correctness formula (8.1).
As mentioned in Sect. 8.4.2, we shall draw inspiration from the pre- and
postconditions of the target correctness formula to ﬁnd the assertions focused on the
rules. In our case, we see from the text of the rules, or from Fig. 8.1, that the lower
bound 30 on the bonus in the postcondition of (8.1) comes from the application of
r1 to the lower bound 20 on the age in the precondition. Similarly, a bonus of 120
results from the application of r2 to an age of 80. Hence the idea of distributing
the precondition of (8.1) over the two rules, with x:a  20 as the precondition for
r1 and y:a  80 as that for r2. The postconditions are obtained by symbolically
executing the rules on their preconditions. In this, one must not forget to take into
account both the case where the rule is applicable, and the case where it is not.
We thus propose the following assertions as pre- and postconditions of the
correctness formulas focused on each rule:
p1  x:a  20
q1  x:b 2 Œ30; 60 _ x:a > 50
p2  y:a  80
q2  y:b 2 .60; 120 _ y:a  50 .
The Individual Correctness Formulas Hold
We start by verifying that the correctness formula fp1g r1 fq1g holds. Consider two
states s and s0 and a valuation , such that s;  ˆ p1 and s
.r1;/
! s0. As described
by the semantics of rule instance execution (see Sect. 5.3.4), the deﬁnition of s0
depends on the applicability of .r1; / in s, that is, on whether s;  ˆ x:a  50 or
not. Combined with the precondition p1, we have
either
s;  ˆ x:a 2 Œ20; 50
and then
hs; s0i;  ˆ x:b0 D x:a C 10
or
s;  ˆ x:a > 50
and then
s D s0 .
The ﬁrst case gives s0;  ˆ x:b 2 Œ30; 60, so in all cases we have s0;  ˆ q1. As a
consequence fp1g r1 fq1g holds.
A similar argument gives that fp2g r2 fq2g holds.

8.5
Incompleteness
145
Interference Freedom
We start by verifying that fp1 ^ p2g r2 fp1g holds. By Lemma 8.4 it sufﬁces to verify
that fp1.y/ ^ p2 ^ g2g r2 fp1.y/g holds, that is,
fy:a  20 ^ y:a  80 ^ y:a > 50g r2 fy:a  20g .
This correctness formula is simply fy:a 2 .50; 80g r2 fy:a  20g, which holds
obviously since r2 does not update the age. A similar argument gives that the
formula fp2 ^ p1g r1 fp2g holds.
To verify fq1 ^ p2g r2 fq1g we use Lemma 8.4 again, and we only verify that
fq1.y/ ^ p2 ^ g2g r2 fq1.y/g holds, that is,
f.y:b 2 Œ30; 60 _ y:a > 50/ ^ y:a 2 .50; 80g r2 fy:b 2 Œ30; 60 _ y:a > 50g .
Let us consider an execution s
.r2;/
! s0 of an instance of r2 from a state that satisﬁes
the precondition of this correctness formula. In particular, we have s;  ˆ y:a > 50.
Since r2 does not update the age, we also have s0;  ˆ y:a > 50, which implies
s0;  ˆ q1.y/. As a consequence fq1 ^ p2g r2 fq1g holds. A similar argument gives
fq2 ^ p1g r1 fq2g.
Proving the Targeted Correctness Formula
Having veriﬁed all the premises of proof rule (PR1), we can derive its conclusion,
that is,
f8o W P .o:a  20 ^ o:a  80/g R
f8o W P .o:b 2 Œ30; 60 _ o:a > 50/ ^ .o:b 2 .60; 120 _ o:a  50/g .
The precondition of this correctness formula is directly equivalent to 8o W P .o:a 2
Œ20; 80/ and the postcondition implies 8o W P .o:b 2 Œ30; 120/.
We have thus proven the targeted correctness formula for R, and by doing so
we have certiﬁed that to a set of customers with ages between 20 and 80, the rule
program will always assign bonuses between 30 and 120.
8.5
Incompleteness
Proof rule (PR1) is sound, meaning that all the correctness formulas that are derived
by this proof rule are valid. However, it is not complete, meaning that there are
valid correctness formulas for some rule programs made of unary rules, for which
no proof can be found using the proof rule. That is, for such a correctness formula

146
8
Main Steps in Rule Program Veriﬁcation
we cannot ﬁnd individual correctness formulas focused on the rules that hold, are
interference free, and whose combination leads to the correctness formula for the
rule program. This property is formalized by Theorem 8.5.
Theorem 8.5. The proof rule (PR1) is not complete.
Proof. To prove the theorem, we exhibit a counterexample.
Consider the rule program R D fr1; r2g made of the following rules, writing
r1 D .x; T; g1; a1/ and r2 D .y; T; g2; a2/:
r1.x W T/ W x:a  20 * x:b :D x:a  10
r2.y W T/ W y:b > 70 * y:b :D 70
The following correctness formula for R states that, when executed from a state
where all bonuses are zero, the rule program leads to a state where no bonus is
greater than 70. It is formally proven in Sect. 10.1.1, but its validity is quite obvious
to the trained eye.
f8o W T .o:b D 0/g R f8o W T .o:b  70/g .
(a)
However, this correctness formula cannot be proven using proof rule (PR1), which
we show below by contradiction.
Indeed, suppose that this correctness formula can be proven using proof rule
(PR1). Then there exist assertions p1; q1 2 F.r1/ and p2; q2 2 F.r2/ that form
valid, interference-free correctness formulas for the rules r1 and r2, and such that in
addition
8o W T .o:b D 0/ ! 8o W T

p1.o/ ^ p2.o/

(b)
8o W T q1.o/ ^ q2.o/ ! 8o W T .o:b  70/ .
(c)
Consider the following working memory, states and valuation:
M .T/ D fXg
s1 W
as1.X/ D 81
bs1.X/ D 0
s2 W
as2.X/ D 81
bs2.X/ D 71
 W
x 7! X
y 7! X
o 7! X .
In the state s1 the value of the attribute b on the only instance X of the type T is 0,
so we have s1 ˆ 8o W T .o:b D 0/. By (b) this gives s1 ˆ 8o W T

p1.o/ ^ p2.o/

,
hence
s1;  ˆ p1
(d)
s1;  ˆ p2 .
(e)

8.5
Incompleteness
147
In addition, the states s1 and s2 have been deﬁned so that s1;  ˆ g1 and hs1; s2i;  ˆ
Oa1. Therefore, we have
s1
.r1;/
! s2 .
(f)
Since the correctness formula fp1g r1 fq1g holds by hypothesis, from (d) and (f) we
have
s2;  ˆ q1 .
(g)
On the other hand, the state s1 is such that s1;  6ˆ g2. A consequence is that
s1
.r2;/
! s1. Since the correctness formula fp2g r2 fq2g holds by hypothesis, this
with (e) give that
s1;  ˆ q2 .
(h)
Another part of the hypothesis is that the interference-freedom correctness
formula fq2 ^ p1g r1 fq2g holds. Therefore, from (h), (d) and (f), we have s2;  ˆ q2.
This and (g) give by Lemma 4.2 that s2;  ˆ q1.o/ ^ q2.o/. By Lemma 4.1, and due
to the fact that M .T/ is a singleton, this means that s2; 0 ˆ q1.o/ ^ q2.o/ for any
valuation 0 such that 0.o/ 2 M .T/, which is the deﬁnition of
s2 ˆ 8o W T .q1.o/ ^ q2.o// .
By (c) this gives s2 ˆ 8o W T .o:b  70/, which contradicts bs2.X/ D 71.
We have thus exhibited a valid correctness formula that cannot be proven using
proof rule (PR1). We have shown this by demonstrating that otherwise, a false
statement (namely 71  70) would follow.
ut
In this proof, the contradiction is built by considering an execution of R in
which an instance of r1 is applied after an instance of r2 to the same object X.
The interference freedom between r1 and the postcondition of the correctness
formula focused on r2 is expressed by the premise fq2 ^ p1g r1 fq2g of the proof
rule. It is exploited after step (h) to lead to the contradiction.
However, this execution of the rule program is not possible, because the
applications of .r2; X/, and then of .r1; X/, are considered on an object X with the
initial attribute value bs1.X/ D 0. In this initial state, only r1 is applicable to X. And
once the rule instance .r1; X/ has been applied, it becomes ineligible, and hence will
never be applied again. Therefore, there can be no execution of R from a state s1
where bs1.X/ D 0, in which the rule instance .r1; X/ is applied after .r2; X/.
The incompleteness of the proof rule manifests itself in the fact that the premises
of the proof rule do not discard such an impossible execution.
Eligibility plays a central role here. The premises of the proof rule do not take it
into account, which causes the proof rule to fail to prove a correctness formula when
eligibility has to be relied upon. Proof rule (PR2) introduced in Chap. 9 does take

148
8
Main Steps in Rule Program Veriﬁcation
eligibility into account, and is complete—actually relatively complete, in the sense
discussed in Sect. 9.4. Its specialization (PR3) for unary rules (given in Sect. 10.1.1)
is also relatively complete for rule programs made of unary rules.
References
1. Apt, K.R., Olderog, E.R.: Veriﬁcation of Sequential and Concurrent Programs, 2nd edn. Texts
in Computer Science. Springer, Berlin (1997)
2. Apt, K.R., de Boer, F.S., Olderog, E.R.: Veriﬁcation of Sequential and Concurrent Programs,
3rd edn. Texts in Computer Science. Springer, Berlin (2009)
3. Lamport, L.: Proving the correctness of multiprocess programs. IEEE Trans. Software Eng.
3(2), 125–143 (1977)
4. Lipton, R.J.: Reduction: A method of proving properties of parallel programs. Comm. ACM
18(12), 717–721 (1975)
5. Morris, J.M.: A general axiom of assignment. In: Bauer, F.L., Dijkstra, E.W., Hoare, C.A.R.
(eds.) Theoretical Foundations of Programming Methodology: Lecture Notes of an International
Summer School. Reidel, Dordrecht (1982)
6. Owicki, S.S., Gries, D.: An axiomatic proof technique for parallel programs I. Acta Informatica
6, 319–340 (1976)

Chapter 9
A Veriﬁcation Method for Rule Programs
In the previous chapter, we have introduced a proof rule suited to rule programs
made of unary rules. We used this proof rule to present the core principle
of our veriﬁcation method: derive a correctness formula for a rule program
from interference-free correctness formulas focused on the individual rules in the
program.
However, this ﬁrst proof rule has two limitations. Firstly, it applies only to rule
programs made of unary rules. Secondly, it does not take the eligibility of rule
instances into account, hence it is not complete.
The present chapter proposes a proof rule that does not suffer from these
limitations. On the one hand, relieving the constraint for rules to be unary brings
back the possibility of interference due to aliasing. This possibility is addressed
through additional premises in the proof rule. On the other hand, eligibility of rule
instances is taken into account by the introduction of dedicated ghost variables. As a
result, we obtain a veriﬁcation method that handles rules of arbitrary arity, and that
is relatively complete (in the sense discussed in Sect. 9.4).
As since the start of Part III, we work within the setting described by Sect. 6.1,
that is, rule programs are executed under the one-shot execution strategy and we use
the classical deﬁnitions of proofs and proof rules, as recalled in that section.
9.1
Taking Eligibility into Account
9.1.1
Eligibility Ghost Variables
With each rule in a rule program, we associate a ghost variable with a precise
interpretation that binds instances of this ghost variable to the eligibility of instances
of the rule. These eligibility ghost variables follow the deﬁnitions of Sect. 7.2.1,
which introduced ghost variables. We restate the main points below.
B. Berstel-Da Silva, Veriﬁcation of Business Rules Programs,
DOI 10.1007/978-3-642-40038-4__9, © Springer-Verlag Berlin Heidelberg 2014
149

150
9
A Veriﬁcation Method for Rule Programs
(i) Ghost variables are introduced by augmenting the signature ˙ (Sect. 3.1) with
an inﬁnite set of function symbols, denoted Ghost.
(ii) They are incorporated into expressions and assertions by deﬁning extended ver-
sions of the corresponding languages: Fig. 7.2 deﬁnes the languages E .V; G/
and A .V; G/ of expressions and assignments; the deﬁnition of the languages
B.V; G/ and F.V; G/ of non-quantiﬁed and quantiﬁed formulas is based on
them. In the above, V  Var is a set of variables and G  Ghost is a set of
ghost variables.
(iii) A ghost variable is a function symbol. If its arity is m, it is interpreted in a state
by a function deﬁned on
 m with values in
 [ f?g.
The general purpose of ghost variables is to encode information that is otherwise
implicit because it is maintained by the execution engine. A common example is the
program counter of sequential programs. The purpose of eligibility ghost variables
is to enable states to encode the eligibility information that is otherwise stored in the
sets of eligible rule instances of conﬁgurations.
We now deﬁne the eligibility ghost variables associated with a rule program. We
deﬁne their interpretation later in this section.
Deﬁnition 9.1. Given a rule program R D fr1; : : : ; rng, the set of eligibility ghost
variables for R is  D fı1; : : : ; ıng with ıi 2 Ghost and jıij D jrij, for i D
1; : : : ; n; that is, each ıi is a ghost variable of the same arity as the rule ri.
The name ıi of eligibility ghost variables has been chosen to stand for “done”
because, as we shall see, it encodes the ineligibility of the rule instance, which in
the one-shot strategy occurs when the rule instance has been applied once.
For a given i 2 f1; : : : ; ng, the eligibility ghost variable ıi names a function
whose formal parameters are the variables of the rule ri. However, as for ghost
variables in Sect. 7.2.1, its argument list is left implicit when unambiguous, and
only the ıi symbol is used instead of the full ıi.oi
1; : : : ; oi
mi/, or ıi.Eoi/ for short.
A common case where the argument list of the eligibility ghost variable ıi must
be made explicit is to refer to the eligibility of an instance of the rule ri on objects
held by other variables than those of ri. We then write ıi.Ex/ for the eligibility of an
instance of the rule ri on objects held in the mi-tuple of variables Ex.
Example. Consider the rule program R D fr1; r2; r3; r4g made of the rules below:
r1.p1 W P/ W p1:age > 60 * p1:bonus :D p1:bonus C 10
r2.p2 W P/ W p2:cat D Gold * p2:bonus :D p2:bonus C 15
r3.c3 W C; p3 W P/ W p3:bonus < 20 * c3:points :D c3:points C 5
r4.c4 W C; p4 W P/ W p4:bonus  20 * c4:points :D c4:points C 10
The set of eligibility ghost variables for R is  D fı1; ı2; ı3; ı4g, where ı1 and ı2
are unary, ı3 and ı4 are binary.
Here, ı1 is a shorthand for ı1.p1/ and ı3 is a shorthand for ı3.c3; p3/. The
notation ı4.c; p/ would refer to the eligibility of an instance of r4 on objects held in
the variables c and p.

9.1
Taking Eligibility into Account
151
Deﬁnition 9.2. Let R D fr1; : : : ; rng be a rule program and  D fı1; : : : ; ıng the
set of its eligibility ghost variables; let hE0; s0i
R1
! hE1; s1i
R2
! 
 
 
 be an execution
of R. In any state sk of this execution, each variable ıi is interpreted by the function
ısk
i deﬁned below, for i D 1; : : : ; n:
ısk
i W
 jri j !

EO 7!
(
false
if .ri; EO/ 2 Ek
true
if .ri; EO/ … Ek .
The introduction of eligibility ghost variables reiﬁes the notion of eligibility.
It establishes a connection between the set of eligible rule instances and the state
in conﬁgurations of the abstract machine used to model the execution of a rule
program.
In particular, the interpretation of the eligibility ghost variables in Deﬁnition 9.2
means that during a transition in an execution of the program, not only is the rule
instance removed from the set of eligible rule instances, but the value of the ghost
variable associated with the rule also changes from false to true on the objects in the
instance:
if
hE; si
.ri; E
O/
! hE0; s0i
then
ıs
i . EO/ D false
and
ıs0
i . EO/ D true .
More generally, eligibility-aware assertions, rule execution, and correctness
formulas described in the rest of this section make it possible to model rule program
execution with formulas that include eligibility ghost variables. This opens the way
to a proof rule that takes eligibility into account, as proposed in Sect. 9.3.
9.1.2
Eligibility-Aware Assertions
The eligibility ghost variables are not meant to be used in the guards or actions of
rules, but in the assertions that express properties of rules or of rule programs, in
particular as pre- and postconditions of correctness formulas.
These assertions belong to a language of the F.V; G/ family, as introduced in
Sect. 7.2.1. More precisely, given a rule program R D fr1; : : : ; rng and the set  of
its eligibility ghost variables, the following three languages of so-called eligibility-
aware assertions are used, for the following purposes.
•
Correctness formulas for an individual rule ri are formed with assertions in
the variables of the rule ri, possibly involving eligibility ghost variables. This
corresponds to the language F.var.ri/; /.
When these assertions are in addition well-typed for .Eoi W ETi/, we call them
eligibility-aware assertions focused on ri. We denote their set by F.ri/.

152
9
A Veriﬁcation Method for Rule Programs
•
Correctness formulas expressing the interference freedom between rules are
formed with assertions in the variables of several rules of the program,
possibly involving eligibility ghost variables. This corresponds to the language
F.var.R/; /.
•
Correctness formulas expressing global properties of the working memory in an
execution of a rule program are formed with closed assertions, possibly involving
eligibility ghost variables. This corresponds to the language F.;; /.
Example. Given the rules in the previous example, the assertion below expresses
that the bonus of the person held in variable p2 is 0 if the instance of r1 on this
person has not yet been applied, and is 10 if the instance of r1 on the person held in
p2 has already been applied.
p2:bonus D 0 ^ :ı1.p2/ _ p2:bonus D 10 ^ ı1.p2/
Although it contains occurrences of the eligibility ghost variable for r1, its only free
(regular) variable is p2. It is thus an eligibility-aware assertion focused on rule r2,
that is, it belongs to F.r2/.
An eligibility-aware assertion is given a truth value by a state and a valuation.
In addition, in order for the state to interpret eligibility ghost variables as per
Deﬁnition 9.2, it must be related to the set of eligible rule instances in a con-
ﬁguration. In the initial state of a rule program execution, this relation stems
from the deﬁnition given in Sect 5.4.2. The next section on eligibility-aware
execution describes the effect of a transition between conﬁgurations on eligibility
ghost variables. This description inductively enables all states in a rule program
execution to interpret eligibility ghost variables without the explicit reference to the
corresponding set of eligible rule instances.
9.1.3
Eligibility-Aware Execution
The application of rule instances during the execution of a rule program depends,
and has an effect, on the eligibility of rule instances. Chapter 5 formalizes this with
conﬁgurations of an abstract machine. In this section, we introduce “eligibility-
aware” concepts to encode it using eligibility ghost variables.
Rule Instance Execution
Deﬁnition 9.3. Let R D fr1; : : : ; rng be a rule program and  the set of its
eligibility ghost variables; let ri D .Eoi; ETi; gi; ai/ be a rule in this program and 
a valuation well-typed for .Eoi W ETi/. Let us write EO D ..o1/; : : : ; .ojrij//.

9.1
Taking Eligibility into Account
153
(i) The eligibility-aware rule instance of ri on the tuple of objects EO is written
.r
i ; .o1/; : : : ; .ojrij//, or .r
i ; EO/ or .r
i ; /.
(ii) Given a state s, the eligibility-aware rule instance .r
i ; / is selectable in s if
the rule instance .ri; / is applicable in s and ıs
i . EO/ D false. That is,
s;  ˆ gi ^ :ıi .
During the execution of a rule program, the set of selectable rule instances in
a conﬁguration hE; si coincides with the rule instances in E that are applicable
in s. The deﬁnition above extends this notion to states that are not considered in the
context of a conﬁguration.
The effect of applying a rule instance from a given state is described in Sect. 5.3.3
as producing a new state, related to the initial one by the transition assertion Oa for
the action a of the rule, deﬁned in Sect. 4.5. We express the effect on the eligibility
ghost variables by a similar transition assertion, as follows.
Deﬁnition 9.4. Let R D fr1; : : : ; rng be a rule program and  the set of its
eligibility ghost variables; let ri D .Eoi; ETi; gi; ai/ be a rule in this program and 
a valuation well-typed for .Eoi W ETi/.
(i) Given a state s in which .r
i ; / is selectable, the state that results from the
eligibility-aware application of .r
i ; / in s is the state s0 such that
hs; s0i;  ˆ Oai ^ Oıi
with the deﬁnition given in Sect. 4.5 of the transition assertion Oai for the action
of ri, and with the following deﬁnition for the Oıi transition assertion:
Oıi
def
 ı0
i.Eoi/ ^ 8Eo .Eo ¤ Eoi ! ı0
i.Eo/ D ıi.Eo// ^
^
ı2nfıi g
8Eo .ı0.Eo/ D ı.Eo// .
(ii) Given a state s, the state that results from the eligibility-aware execution of
.r
i ; / in s is the state that results from its eligibility-aware application if .r
i ; /
is selectable in s, and is s itself otherwise. We write s
.r
i ;/
! s0 if s0 is the
resulting state.
The deﬁnition of the transition assertion Oıi for the eligibility ghost variables
above formalizes the transition of ıi from false in state s to true in state s0,
additionally taking into account the chances of aliasing.
Example. Let us focus on the rules r1 and r3 of the same program as in previous
examples:
r1.p1 W P/ W p1:age > 60 * p1:bonus :D p1:bonus C 10
r3.c3 W C; p3 W P/ W p3:bonus < 20 * c3:points :D c3:points C 5

154
9
A Veriﬁcation Method for Rule Programs
Consider the following setting:
M .P/ D fAlice; Bobg
M .C/ D fCardg
s1 D
ages1 W Alice 7! 75
bonuss1 W Alice 7! 15
Bob 7! 50
Bob 7! 30
pointss1 W Card 7! 25
ıs1
1 W Alice 7! true
ıs1
3 W Card; Alice 7! false
Bob 7! false
Card; Bob 7! true .
In the state s1, the eligibility-aware rule instance .r
1; Alice/ is applicable but it is
not selectable since s1;  6ˆ :ı1 for any valuation  that maps p1 onto Alice. In
contrast, the eligibility-aware rule instance .r
3; Card; Alice/ is selectable.
Let us name s2 the state that results from the eligibility-aware application of
.r
3; Card; Alice/ from s1, that is, s1
.r
3 ;Card;Alice/
! s2. Let us denote by  a valuation
that maps c3 onto Card and p3 onto Alice. Since the rule instance .r
3; / is selectable
in s1, we have hs1; s2i;  ˆ Oa3 ^ Oı3, that is,
hs1; s2i;  ˆ c3:points0 D c3:points C 5 ^ ı0
3.c3; p3/ D true
^ 8o .o ¤ c3 ! c3:points0 D c3:points/ ^
^
f 2Attrnfpointsg
8o .o:f 0 D o:f /
^ 8Eo .Eo ¤ .c3; p3/ ! ı0
3.Eo/ D ı3.Eo// ^
^
ı2nfı3g
8Eo .ı0.Eo/ D ı.Eo// .
This gives the following for s2:
s2 D
ages2 W Alice 7! 75
bonuss2 W Alice 7! 15
Bob 7! 50
Bob 7! 30
pointss2 W Card 7! 30
ıs2
1 W Alice 7! true
ıs2
3 W Card; Alice 7! true
Bob 7! false
Card; Bob 7! true .
Transition Assertions in Detail
Given two states s and s0, the deﬁnition of the eligibility-aware execution of a rule
instance s
.r
i ;/
! s0 can be summed up as:
either
s;  ˆ gi ^ :ıi
and then
hs; s0i;  ˆ Oai ^ Oıi
or
s;  ˆ :gi _ ıi
and then
s D s0

9.1
Taking Eligibility into Account
155
In the above, the equation s;  ˆ gi ^ :ıi expresses that the rule instance .r
i ; / is
selectable. In that case, the resulting state is deﬁned by the transition assertions
Oai and Oıi. These were introduced by Deﬁnitions 4.8 and 9.4, respectively. The
transition assertion Oai describes the effect of the action of the rule on the attributes,
the transition assertion Oıi describes the update of the eligibility ghost variables.
When .r
i ; / is not selectable, the state that results from the rule execution is deﬁned
as identical to the initial one.
In the same way as noted in Sect. 5.3.3 about the transition assertion for a rule
action, the combined transition assertion Oai ^ Oıi describes the transition for several
objects, or sets of objects:
(i) The objects in the rule instance .ri; / are held by the variables Eoi. On the
object held by the ﬁrst variable oi
1, the attribute fri is updated to the value
eri. Also, the instance of the rule on the tuple of objects becomes ineligible.
That is, we have the following in the state s0 that results from the rule instance
application:
hs; s0i;  ˆ oi
1:f 0
ri D eri
hs; s0i;  ˆ ı0
i
that is
s0;  ˆ ıi.Eoi/ .
(ii) On any other object than the one held by the ﬁrst variable oi
1 of the rule, the
value of the attribute fri is left unchanged. Also, the instances of ri on any
other tuple of objects than the ones held by the variables Eoi keeps its (positive
or negative) eligibility. That is, in s0 we have
hs; s0i;  ˆ o ¤ oi
1 ! o:f 0
ri D o:fri
hs; s0i;  ˆ Eo ¤ Eoi ! ı0
i.Eo/ D ıi.Eo/ .
(iii) For all objects, the value of any other attribute than fri is left unchanged. The
eligibility of all instances of any other rule than ri does not change either. That
is, in s0 we have
hs; s0i ˆ 8o .o:f 0 D o:f /
for any f 2 Attr n ffrig
hs; s0i ˆ 8Eo .ı0.Eo/ D ı.Eo//
for any ı 2  n fıig .
These three viewpoints on the effects of a rule instance application will be
successively used in many of the proofs of this chapter and the next.
Rule and Rule Program Execution
From the deﬁnition of the eligibility-aware execution of a rule instance
(Deﬁnition 9.4), the eligibility-aware execution of a rule follows naturally.

156
9
A Veriﬁcation Method for Rule Programs
Deﬁnition 9.5. Let R D fr1; : : : ; rng be a rule program and  the set of its
eligibility ghost variables; let ri D .Eoi; ETi; gi; ai/ be a rule in this program. Given
two states s and s0, there is an eligibility-aware execution of the rule ri from s to s0,
and we write s
r
i! s0, if there exists an eligibility-aware instance R of ri such that
s
R
! s0.
The execution of rule programs is inherently eligibility-aware: the deﬁnition
of rule program execution given in Sect. 5.4 already handles eligibility. However,
with the introduction of eligibility ghost variables, the transition rule (5.1), which
we specialized for the one-shot strategy as transition rule (6.1), can be expressed
as follows. The transition rule (9.1) below describes a transition of the abstract
machine from a state s to a state s0 by the application of an instance of the rule
ri D .Eoi; ETi; gi; ai/:
hs; s0i;  ˆ :ıi ^ gi ^ Oai ^ Oıi
hE; si
.ri;/
! hE0; s0i
.
(9.1)
9.1.4
Eligibility-Aware Correctness Formulas
Correctness formulas that take into account the eligibility of rule instances, namely
eligibility-aware correctness formulas, build upon the eligibility-aware concepts
introduced so far. Their pre- and postconditions are eligibility-aware assertions,
that is, assertions that contain occurrences of the eligibility ghost variables. They
relate the initial and ﬁnal states in the eligibility-aware execution of a rule or of a
rule program, that is, they reﬂect the effect of this execution both on the objects in
the working memory and on the eligibility of rule instances.
Deﬁnition 9.6. Let R be a rule program and  the set of its eligibility ghost
variables; let p; q 2 F.var.R/; / be two assertions involving eligibility ghost
variables. Given a rule r
2 R in the program and its associated eligibility
ghost variable ı 2 , the eligibility-aware correctness formula fpg r fqg for the
rule r holds if:
for any T -compliant states s and s0, and any valuation  well-typed for r,
such that
s;  ˆ p
and
s
.r;/
! s0
we have
s0;  ˆ q .
Although lexically close to a “regular” correctness formula fpg r fqg, an eligibi-
lity-aware one fpg r fqg as just deﬁned is more powerful for two reasons. Firstly, it
admits occurrences of the eligibility ghost variables in its pre- and postconditions p

9.1
Taking Eligibility into Account
157
and q. Secondly, it updates these eligibility ghost variables to reﬂect the effect of the
rule execution and thus to ensure consistency with the one-shot eligibility strategy.
Example. Let us consider again the rule r1 used in the previous examples:
r1.p1 W P/ W p1:age > 60 * p1:bonus :D p1:bonus C 10
and the eligibility-aware assertion proposed earlier, only with a variable renaming:
'  x:bonus D 0 ^ :ı1.x/ _ x:bonus D 10 ^ ı1.x/ .
When executing the rule r1 on a person p1 aged more than 60 from a state that
satisﬁes '.p1/, we can assert that the bonus of that person will ﬁnally be 10:
f'.p1/ ^ p1:age > 60g r
1 fp1:bonus D 10g .
Indeed, either the instance of the rule r1 on the object held by p1 is eligible, and
then the rule instance is selectable and its application increments the bonus from 0
to 10, or the rule instance is not eligible and the eligibility-aware execution of the
rule instance boils down to a skip, leaving the bonus at its initial value of 10.
Since the execution of rule programs is inherently eligibility-aware, so are
correctness formulas for rule programs. Deﬁnition 6.7 of a correctness formula for a
rule program still holds when the pre- and postconditions include occurrences of the
eligibility ghost variables. A correctness formula fpg R fqg, where p; q 2 F.;; /
contain eligibility ghost variables, thus holds if:
for any T -compliant states s and s0 such that s ˆ p and s
R
! s0, we have
s0 ˆ q.
Let us recall that, since we consider executions of rule programs under the one-shot
execution strategy, partial and total correctness coincide.
We have the following property for the ﬁrst and last conﬁgurations in an
execution of a rule program.
Lemma 9.1. Let R D fr1; : : : ; rng be a rule program with ri D .Eoi; ETi; gi; ai/ for
i D 1; : : : ; n, and let  be the set of its eligibility ghost variables; if s and s0 are
two T -compliant states such that s
R
! s0, then
(i)
s ˆ
n
^
iD1
8Eoi W ETi :ıi
(ii)
s0 ˆ
n
^
iD1
8Eoi W ETi .:gi _ ıi/ .
Proof. (i) is a direct consequence of the deﬁnition of the eligibility ghost variables
and of the fact that all rule instances are eligible in the initial conﬁguration of an
execution.

158
9
A Veriﬁcation Method for Rule Programs
(ii) follows from the fact that the execution has ended. Let us write hE0; s0i for the
last conﬁguration in an execution of R from s to s0. Consider for any i D 1; : : : ; n
a rule instance .ri; / well-typed for .Eoi W ETi/. Since the execution has ended, the
rule instance is not applicable or not eligible (or both). If the rule instance is not
eligible we have, by deﬁnition of the eligibility ghost variables, s0;  ˆ ıi. If it is
not applicable we have s0;  ˆ :gi.
ut
9.2
Interference Freedom
In Sect. 8.1, we listed two kinds of interference that appear in rule programs: cross-
rule interference and interference due to aliasing. The proof rule presented in the
previous chapter avoided interference due to aliasing by considering only unary
rules, and omitted eligibility. The general proof rule (PR2) introduced in Sect. 9.3
aims at addressing both kinds of interference, and at taking eligibility into account.
In this section, we discuss how the premises of proof rule (PR2) address
interference. Here are these premises:
for i D 1; : : : ; n W
fpi ^ :ıig r
i fqig
for i; j D 1; : : : ; n with i ¤ j W
fpi ^ pj ^ :ıi ^ :ıjg r
j fpi ^ :ıig
fqi ^ pj ^ ıi ^ :ıjg r
j fqi ^ ıig
for i D 1; : : : ; n and Ex 2 Varmi W
fEx ¤ Eoi ^ pi.Ex/ ^ pi ^ :ıi.Ex/ ^ :ıig r
i fpi.Ex/ ^ :ıi.Ex/g
fEx ¤ Eoi ^ qi.Ex/ ^ pi ^ ıi.Ex/ ^ :ıig r
i fqi.Ex/ ^ ıi.Ex/g .
Using eligibility-aware correctness formulas allows these premises to take eligi-
bility into account. The second and third group of correctness formulas express
interference freedom.
9.2.1
Cross-Rule Interference
The correctness formulas expressing cross-rule interference freedom in proof rule
(PR1) are
fpi ^ pjg rj fpig
fqi ^ pj g rj fqig

for i; j D 1; : : : ; n with i ¤ j .
The correctness formula fpi ^ pjg rj fpig, for example, states that the asser-
tion pi is preserved by an execution of the rule rj. The restriction to executions from

9.2
Interference Freedom
159
a state where pj holds can be justiﬁed as a consequence of Lemma 8.3. Indeed,
for an instance of the rule rj to be executed, it must be eligible. And since the
conﬁgurations of the abstract machine during the execution of the rule program are
consistent with the correctness formulas focused on the rules, the precondition pj
associated with the rule rj then holds.
However the fact that pj holds is only a consequence of the eligibility of the
instance of rj. Explicitly taking eligibility into account requires that :ıj holds as
well.
Similarly, the soundness of proof rule (PR2) does not require the rule rj to
be interference free with the entire assertion pi, but only with the portion of
this assertion that holds when the rule ri is eligible. Hence the eligibility-aware
correctness formula found in the premises of this proof rule, which states that the
assertion pi ^ :ıi is preserved by an eligibility-aware execution of the rule rj from
a state where pj ^ :ıj holds.
We might note that the pre- and postconditions of eligibility-aware correctness
formulas are typically longer than those which do not contain eligibility ghost
variables. Indeed, a correctness formula for a rule ri usually addresses cross-rule
interference by including the eligibility ghost variables for the other rules. It is
typically of the following form, assuming a three-rule program:
p1  p00
1 ^ :ı2 ^ :ı3 _ p01
1 ^ :ı2 ^ ı3 _ p10
1 ^ ı2 ^ :ı3 _ p11
1 ^ ı2 ^ ı3 .
where the pxy
1
are assertions in the variables of r1, containing no ghost variables.
As a result, a conjunction with an eligibility ghost variable has the effect of
“selecting” disjuncts in the assertion. For example,
p1 ^ :ı2
is
.p00
1 ^ :ı3 _ p01
1 ^ ı3/ ^ :ı2 .
This phenomenon is exploited when devising the pre- and postconditions of the
correctness formulas for the individual rules, so that they take into account the past
executions of the other rules.
9.2.2
Interference Due to Aliasing
Interference due to aliasing, deﬁned in Sect. 8.1.2, occurs when the execution of a
rule instance does not preserve the pre- or postcondition of a correctness formula on
a partially distinct tuple of objects.
This kind of interference was avoided in the previous chapter because we consid-
ered only rule programs made of unary rules, which prevented aliasing altogether
by the fact that formulas are ﬂat, as discussed in Sect. 8.2. As a consequence,
an instance of a rule could not affect the truth values of pre- and postconditions
considered on other objects. This property is formalized by Lemmas 8.1 and 8.4.
When rules with an arbitrary number of variables are considered, the objects in
various instances of a rule are no longer guaranteed to be distinct. In particular,

160
9
A Veriﬁcation Method for Rule Programs
Lemmas 8.1 and 8.4 do not extend to the n-ary case. As a result, the premises of
a proof rule suited to the n-ary case, such as (PR2), must express that executing a
rule instance preserves the pre- and postconditions of the correctness formulas for
all possible mappings of variables to objects.
The second group of correctness formulas in the premises of (PR2), discussed
in Sect. 9.2.1, involves variables of two rules. For example, the correctness for-
mula fpi ^ pj ^ :ıi ^ :ıjg r
j fpi ^ :ıig implicitly refers to the variables Eoi D
.oi
1; : : : ; oi
mi/ when mentioning pi and ıi, and to the variables Eoj D .oj
1; : : : ; oj
mj /
when mentioning pj , ıj, and rj. All cases of equality or disequality between these
variables are covered in these correctness formulas.
The missing cases are for two instances of the same rule, since the above
correctness formulas are considered for i ¤ j. These cases are addressed by the
third group of correctness formulas in the premises of (PR2). In these correctness
formulas, two instances of a rule ri are considered by providing explicit variable
tuples; the instances are made distinct by additionally requiring the variable tuples
to be different. Hence we have a correctness formula such as
fEx ¤ Eoi ^ pi.Ex/ ^ pi ^ :ıi.Ex/ ^ :ıig r
i fpi.Ex/ ^ :ıi.Ex/g .
9.3
General Proof Rule
With the introduction of eligibility ghost variables and the consideration of interfer-
ence due to aliasing, we have gathered the material for the proof rule at the heart of
our veriﬁcation method. It is given in Theorem 9.2 below.
Theorem 9.2. Let R D fr1; : : : ; rng be a rule program and  the set of its
eligibility ghost variables. For i D 1; : : : ; n, let us write ri D .Eoi; ETi; gi; ai/ with
mi D jrij, and let pi; qi 2 F.ri/ be eligibility-aware assertions focused on the
rule ri. The proof rule (PR2) below is sound.
for i D 1; : : : ; n W
fpi ^ :ıig r
i fqig
for i; j D 1; : : : ; n with i ¤ j W
fpi ^ pj ^ :ıi ^ :ıjg r
j fpi ^ :ıig
fqi ^ pj ^ ıi ^ :ıjg r
j fqi ^ ıig
for i D 1; : : : ; n and Ex 2 Varmi W
fEx ¤ Eoi ^ pi.Ex/ ^ pi ^ :ıi.Ex/ ^ :ıig r
i fpi.Ex/ ^ :ıi.Ex/g
fEx ¤ Eoi ^ qi.Ex/ ^ pi ^ ıi.Ex/ ^ :ıig r
i fqi.Ex/ ^ ıi.Ex/g
n n
^
iD1
8Eoi W ETi .pi ^ :ıi/
o
R
n n
^
iD1
8Eoi W ETi

qi ^ .ıi _ :gi/
o
(PR2)

9.3
General Proof Rule
161
The premises of proof rule (PR2) have just been discussed in Sect. 9.2. Its conclu-
sion might seem quite complex, as it includes combinations of the pi; qi assertions
and the eligibility ghost variables, and additionally involves the rule guards in its
postcondition. As for the premises of the proof rule, the presence of eligibility
ghost variables in the pre- and postconditions of the conclusion is actually a tool.
Including them selects the disjuncts in the pi; qi assertions that are relevant in the
ﬁrst and last conﬁgurations of an execution of the rule program. The rule guards
in the postcondition enhance the completeness of the proof rule, notably in the case
where the precondition does not imply the rule guards. This is related to Lemma 9.1,
and is discussed in Sect. 9.5 on an example.
The proof of Theorem 9.2 follows a path similar to the proof of Theorem 8.2
in Sect. 8.3. We start by deﬁning what it means for a state to be consistent with
the eligibility-aware correctness formulas focused on the rules. We then show that
consistency is an invariant of a rule program execution. Finally we leverage this
result to show the soundness of proof rule (PR2).
Deﬁnition 9.7. Given a rule program R D fr1; : : : ; rng, the set of its eligibility
ghost variables 
D
fı1; : : : ; ıng, and eligibility-aware correctness formulas
fpig r
i fqig for i D 1; : : : ; n focused on the rules of R, a T -compliant state s is
consistent with the correctness formulas, or s is cf-consistent, if
s ˆ
n
^
iD1
8Eoi W ETi .:ıi ^ pi _ ıi ^ qi/ .
We can now state Lemma 9.3, by which the premises of proof rule (PR2) ensure
that an execution of a rule program that starts in a cf-consistent state results in a
cf-consistent state.
Lemma 9.3. Let R D fr1; : : : ; rng be a rule program and  the set of its eligibility
ghost variables. For i D 1; : : : ; n, let us write ri D .Eoi; ETi; gi; ai/ with mi D jrij,
and let pi; qi 2 F.ri/ be eligibility-aware assertions focused on the rule ri, such
that
for i D 1; : : : ; n W
fpi ^ :ıig r
i fqig
(a)
for i; j D 1; : : : ; n with i ¤ j W
fpi ^ pj ^ :ıi ^ :ıjg r
j fpi ^ :ıig
fqi ^ pj ^ ıi ^ :ıjg r
j fqi ^ ıig
(b)
for i D 1; : : : ; n and Ex 2 Varmi W
fEx ¤ Eoi ^ pi.Ex/ ^ pi ^ :ıi.Ex/ ^ :ıig r
i fpi.Ex/ ^ :ıi.Ex/g
fEx ¤ Eoi ^ qi.Ex/ ^ pi ^ ıi.Ex/ ^ :ıig r
i fqi.Ex/ ^ ıi.Ex/g .
(c)
Given two T -compliant states s and s0 such that s
R
! s0, if s is consistent with the
correctness formulas fpig r
i fqig, then s0 is as well.

162
9
A Veriﬁcation Method for Rule Programs
Proof. The proof goes by induction on the length of the executions of R.
Base step. If the execution is empty then s0 D s and the lemma holds by hypothesis.
Induction step. We consider an execution hE0; s0i
R
! hEk; ski of length k  1
of the rule program, such that s0 is cf-consistent, and we assume that sk1 is
cf-consistent.
Let us write hEk1; sk1i
.rik ; E
Ok/
! hEk; ski for the last transition of this execution,
where ik 2 f1; : : : ; ng and EOk D .Ok
1 ; : : : ; Ok
mik / 2 M .rik / with mik D jrikj. By the
transition rule (9.1) we have
hsk1; ski; k ˆ :ıik ^ gik ^ Oaik ^ Oıik
for any valuation k such that k.oik
j / D Ok
j for j D 1; : : : ; mik .
(d)
We want to prove that sk ˆ Vn
iD1 8Eoi W ETi .:ıi ^ pi _ ıi ^ qi/, that is, that
for any i 2 f1; : : : ; ng and any valuation  well-typed for .Eoi W ETi/ we have sk,
 ˆ :ıi^pi_ıi^qi. Let us thus consider some i 2 f1; : : : ; ng and some valuation 
well-typed for .Eoi W ETi/.
The induction hypothesis states that sk1 ˆ Vn
iD1 8Eoi W ETi .:ıi ^ pi _ ıi ^ qi/,
which gives in particular that either sk1;  ˆ :ıi ^ pi or sk1;  ˆ ıi ^ qi holds.
Therefore, we have
sk1;  ˆ '
(e)
where ' denotes either :ıi ^ pi or ıi ^ qi.
We now examine in turn the cases where the rule instance R D .ri; / is equal to
the rule instance Rk D .rik; EOk/ used in the last transition, or not; and if not, why.
– First case: R D Rk, that is, Rk D .ri; /.
Since i D ik we have .oik
j / D .oi
j/ D Ok
j for j D 1; : : : ; mik. The valuation 
thus qualiﬁes for (d), which gives in particular sk1;  ˆ :ıi. By the induction
hypothesis this gives sk1;  ˆ pi ^ :ıi, and hence by (a) we have sk;  ˆ qi.
By (d) again, we have sk;  ˆ ıi, which with the previous gives
sk;  ˆ ıi ^ qi .
– Second case: R ¤ Rk but still i D ik. Then there must exists some ` 2
f1; : : : ; mig such that .oi
`/ ¤ Ok
` .
Let us consider a tuple of variables Ex 2 Varmi and a valuation 0, such that for
j D 1; : : : ; mi we have 0.oi
j/ D Ok
j and 0.xj / D .oi
j/.
Since 0.x`/ D .oi
`/ ¤ Ok
` D 0.oi
`/, we have
0 ˆ Ex ¤ Eoi .
(f)

9.3
General Proof Rule
163
Also, since 0.oi
j/ D Ok
j for j D 1; : : : ; mi we have
.ri; 0/ D Rk .
(g)
By Lemma 4.2 we also have from (e) that
sk1; 0 ˆ '.Ex/ .
(h)
In addition, since i D ik the valuation 0 qualiﬁes for (d) and we thus have
sk1; 0 ˆ :ıi
(i)
which by the induction hypothesis gives
sk1; 0 ˆ pi .
(j)
From (f), (h), (i), and (j) we have sk1; 0 ˆ Ex ¤ Eoi ^'.Ex/^:ıi ^pi. By (g) and
the interference-freedom correctness formulas (c) this gives sk; 0 ˆ '.Ex/, which
by Lemma 4.2 ﬁnally gives
sk;  ˆ ' .
– Third case: R ¤ Rk with i ¤ ik.
Let 0 be a valuation such that for j D 1; : : : ; mik we have 0.oik
j / D Ok
j and for
j D 1; : : : ; mi we have 0.oi
j/ D .oi
j/. We have
.rik; 0/ D Rk .
(k)
By Lemma 4.1 we also have from (e) that
sk1; 0 ˆ ' .
(l)
In addition, the valuation 0 qualiﬁes for (d) and we thus have
sk1; 0 ˆ :ıi
(m)
which by the induction hypothesis gives
sk1; 0 ˆ pi .
(n)
From (l), (m), and (n) we have sk1; 0 ˆ ' ^ :ıi ^ pi. By (k) and the
interference-freedom correctness formulas (b) this gives sk; 0 ˆ ', which by
Lemma 4.1 ﬁnally gives
sk;  ˆ ' .

164
9
A Veriﬁcation Method for Rule Programs
– Summary. We have considered an arbitrary i 2 f1; : : : ; ng and an arbitrary
valuation , such that .oi
j/ 2 M .T i
j / for j D 1; : : : ; mi.
In the ﬁrst case, we have shown that sk;  ˆ ıi ^ qi.
In the second and third cases, we have shown that sk;  ˆ ', where '  :ıi ^pi
or '  ıi ^ qi.
In all cases we have thus shown that sk;  ˆ :ıi ^ pi _ ıi ^ qi. That is, we have
shown that sk is cf-consistent.
ut
We now turn to the proof of Theorem 9.2.
Proof of Theorem 9.2. Let R D fr1; : : : ; rng be a rule program and  the set of its
eligibility ghost variables. For i D 1; : : : ; n, let us write ri D .Eoi; ETi; gi; ai/ with
mi D jrij, and let pi; qi 2 F.ri/ be eligibility-aware assertions focused on the rule
ri, such that the premises of (PR2) hold, and among them
fpi ^ :ıig r
i fqig .
(a)
Consider two T -compliant states s and s0, such that s
R
! s0 and
s ˆ
n
^
iD1
8Eoi W ETi .pi ^ :ıi/ .
(b)
We want to prove the postcondition of the correctness formula in the conclusion
of the proof rule, that is, s ˆ Vn
iD1 8Eoi W ETi

qi ^ .ıi _ :gi/

. Hypothesis (b) gives
that s is cf-consistent. Therefore, by Lemma 9.3, we have that s0 is cf-consistent,
that is,
s0 ˆ
n
^
iD1
8Eoi W ETi .pi ^ :ıi _ qi ^ ıi/ .
Let us consider some i 2 f1; : : : ; ng and some valuation  well-typed for .Eoi W ETi/.
The above means that we have
s0;  ˆ pi ^ :ıi _ qi ^ ıi .
That is:
(i) Either s0;  ˆ qi ^ ıi, which implies
s0;  ˆ qi ^ .ıi _ :gi/ .
(ii) Or
s0;  ˆ pi ^ :ıi .
(c)

9.4
Relative Completeness
165
Since s0 is the ﬁnal state of the execution of R, the rule instance .r
i ; / is not
selectable, that is by Deﬁnition 9.3, s0;  ˆ :gi _ ıi. With (c) this gives
s0;  ˆ :gi .
(d)
As the rule instance .r
i ; / is not selectable, we also have s0
.r
i ;/
! s0.
Therefore, from (c) and (a), we have
s0;  ˆ qi .
This together with (d) gives s0;  ˆ qi ^ :gi, which implies
s0;  ˆ qi ^ .ıi _ :gi/ .
In all cases, and for any i 2 f1; : : : ; ng and valuation  well-typed for .Eoi W ETi/,
we have s0;  ˆ qi ^ .ıi _ :gi/. This means that we have the expected
s ˆ
n
^
iD1
8Eoi W ETi
qi ^ .ıi _ :gi/
which proves the correctness formula in the conclusion of proof rule (PR2), and
proves the theorem.
ut
9.4
Relative Completeness
The proof system proposed by our veriﬁcation method is built on proof rule (PR2).
It also includes the (CONSEQUENCE) proof rule (see Sect. 6.1.2), and the proof rules
inherited from the theory  ﬁxed in Sect. 3.1. The question of whether this proof
system is complete has to be addressed from each of these three viewpoints.
The (CONSEQUENCE) proof rule uses implications between assertions in its side
conditions. Thus, the completeness of our proof system depends on the provability
of these implications. The assertions involved in these implications, as well as in
the pre- and postconditions of correctness formulas, are relative to the theory .
Therefore, their provability is conditioned by the completeness of the proof rules
inherited from .
As a result, we are interested in the classical notion of relative completeness [2].
That is, we focus on the completeness of proof rule (PR2) relative to the existence
of a complete proof system (or of an oracle) for the validity of the implications used
in the side conditions of the (CONSEQUENCE) proof rule.
Theorem 9.4. The proof rule (PR2), and our veriﬁcation method for rule programs,
are relatively complete. That is, given a rule program R D fr1; : : : ; rng and

166
9
A Veriﬁcation Method for Rule Programs
a correctness formula fpg R fqg for this program, if fpg R fqg is valid then
there exist eligibility-aware assertions p1; q1 2 F.r1/; : : : ; pn; qn 2 F.rn/
focused on the rules in the program, such that the individual correctness formulas
fpi ^ :ıig r
i fqig are valid, are interference free, and such that the correctness for-
mula fpg R fqg can be derived by (PR2), under the assumption that the implications
used in the side conditions of the (CONSEQUENCE) proof rule can be proven.
We have shown in Sect. 7.3.2 that rule programs can be reduced to nondeter-
ministic program. That is, from any rule programs, a nondeterministic program
can be derived that satisﬁes the same correctness formulas. The proof of the
relative completeness of (PR2) is based on this equivalence in behavior between rule
programs and derived nondeterministic programs, and on the relative completeness
of the (DO-OD) proof rule [1].
We start this section with a few preliminaries about nondeterministic programs
that will be of use in the proof of Theorem 9.4. Then we proceed to the proof.
Preliminaries: Nondeterministic Programs
Section 7.3.1 introduces nondeterministic programs based on Dijkstra’s do-od
statement [3]. Section 7.3.2 deﬁnes the nondeterministic program derived from a
rule program and shows that they satisfy the same correctness formulas.
Let us recall the deﬁnition of the nondeterministic program PR derived from a
rule program R D fr1; : : : ; rng with ri D .Eoi; ETi; gi; ai/ for i D 1; : : : ; n:
PR.Eo W ET /
def
 
1 :D falseI : : : I 
n :D falseI do
n
iD1 gi ^ :
i + ai I 
i :D true od .
The program PR is a nondeterministic program in the variables o1
1; : : : ; on
mn. The
notation .Eo W ET / is a shorthand for .Eo1 W ET1/ : : : .Eon W ETn/.
In addition, PR contains as many ghost variables as there are rules in R. To
avoid confusion with eligibility ghost variables introduced earlier for rule programs,
we name them 
i in PR. We will refer to them collectively as the set ˘ D
f
1; : : : ; 
ng  Ghost. Note that although we refrain from identifying 
i and ıi,
both sets of ghost variables intuitively encode the same concept, namely whether an
instance of the corresponding rule has been executed.
The program PR is a sequence of assignments and a nondeterministic loop. We
reify this by writing PR  H˘ I P ˘
R with:
H˘.Eo W ET /  
1 :D false I : : : I 
n :D false
P ˘
R.Eo W ET /  do g1 ^ :
1 + a1 I 
1 :D true Œ : : : Œ gn ^ :
n + an I 
n :D true od .

9.4
Relative Completeness
167
Let us also recall that this program is to be executed on a working memory under
the saturated semantics (described in Sect. 7.3.1). That is, in an execution of PR on
a working memory M :
(i) Each assignment 
i :D false in H˘ is instantiated and executed for all the
possible mappings of Eoi onto object tuples from M .ri/;
(ii) In the execution of the loop in P ˘
R , each guarded command is instantiated and
assessed for all these mappings as well. On each loop iteration, one instance of
one guarded command is selected and executed.
Assigning a value to a ghost variable 
i, whether in H˘ or in the action part of
a guarded command, is done after the assignment has been instantiated on a tuple
of objects EO 2 M .ri/. As described in Sect. 7.2.1, neither the value of the ghost
variable on other object tuples nor the values of the other ghost variables are changed
in the state that results from such an assignment. Let us write s and s0 for the initial
and ﬁnal states of an assignment of the value b to the ghost variable 
i under a
valuation  that maps the variables in Eoi onto the objects in EO. The assignment is
then described by hs; s0i;  ˆ O
i.b/, with the transition assertion O
i.b/ deﬁned as
follows:
O
i.b/
def
 
0
i.Eoi/ D b ^ 8Eo .Eo ¤ Eoi ! 
0
i.Eo/ D 
i.Eo// ^
^

2˘nf
i g
8Eo .
0.Eo/ D 
.Eo// .
It is no surprise that O
i.true/ is identical to Oıi introduced by Deﬁnition 9.4, modulo
the ghost variable names.
Finally, the decomposition of PR into H˘ I P ˘
R leads to the following lemma.
Lemma 9.5. Let R be a rule program and PR  H˘ I P ˘
R the nondeterministic
program derived from it. Given two global assertions p; q 2 F.;; ;/ containing no
ghost variable,
if
fpg PR fqg
then
fp ^
n
^
iD1
8Eoi W ETi :
ig P ˘
R fqg .
Proof. Assume that fpg PR fqg holds, and consider two T -compliant states s and
s0, such that s ˆ p ^ Vn
iD1 8Eoi W ETi :
i and s
P ˘
R
! s0.
Let s\ be the ghost-independent state corresponding to s, that is by Deﬁnition 7.3,
the state that interprets all symbols in the same way as s, except ghost variables
which are all interpreted by the constant function returning ?. Since we have in
particular s ˆ p and since p contains no ghost variable, we also have s\ ˆ p.
On the other hand, an execution of H from s\ has the (only) effect of setting all
the ghost variables 
i to false. The resulting state is therefore s. That is, s\
H
! s
and hence s\ PR
! s0.
By fpg PR fqg we ﬁnally have s0 ˆ q, which establishes the targeted correctness
formula.
ut

168
9
A Veriﬁcation Method for Rule Programs
Proof of Relative Completeness
As mentioned earlier, the proof of the relative completeness of (PR2) is based both
on the relative completeness of the (DO-OD) proof rule and on the fact that a
rule program and the nondeterministic program derived from it satisfy the same
correctness formulas.
The proof goes through the following steps. First, we establish the existence of a
proof of the correctness formula for the nondeterministic program derived from the
rule program. From this proof we synthesize assertions focused on the rules. Then
we show that these assertions form valid eligibility-aware correctness formulas for
the rules and that these correctness formulas are interference free, for both forms of
interference. We conclude the proof by showing that the global correctness formula
derived from these individual correctness formulas leads to the correctness formula
to prove.
Proof of Theorem 9.4. Consider a rule program R D fr1; : : : ; rng made of the rules
ri D .Eoi; ETi; gi; ai/ for i D 1; : : : ; n, and two global assertions p; q 2 F.;; ;/,
such that the correctness formula fpg R fqg holds.
Our objective here is to show that there exists a proof of fpg R fqg by proof
rule (PR2). That is, that there exist 2n eligibility-aware assertions pi; qi 2 F.ri/
focused on the rules r1; : : : ; rn, such that the individual correctness formulas
fpi ^ :ıig r
i fqig hold, are interference free, and the correctness formula derived
from them by (PR2) leads to fpg R fqg.
To this end, we leverage the relative completeness of the (DO-OD) proof rule to
exhibit assertions focused on the rules, and we show that these assertions satisfy the
expected criteria.
– Existence of the assertions. Let us consider the nondeterministic program PR
derived from the rule program R:
PR.Eo W ET /  
1:Dfalse I : : : I
n:Dfalse I do
n
iD1 gi ^ :
i + ai I 
i:Dtrue od .
Theorem 7.5 establishes that PR satisﬁes the same correctness formulas as R.
That is, the correctness formula fpg PR fqg holds. By Lemma 9.5 the following
correctness formula thus holds:
fp ^
n
^
iD1
8Eoi W ETi :
ig do
n
iD1 gi ^ :
i + ai I 
i :D true od fqg .
(a)
The (DO-OD) proof rule is given in Sect. 7.3.2 and reproduced below:
fI ^ Big Si fIg
for i D 1; : : : ; n
fIg don
iD1 Bi + Si od fI ^ Vn
iD1 8Eoi W ETi :Big
(DO-OD)
where I 2 F.;; ˘/ .

9.4
Relative Completeness
169
As this proof rule is relatively complete [1], it can prove (a). That is, there exists
an eligibility-aware global assertion I 2 F.;; ˘/ that supports a derivation from
the premises of (DO-OD) to the correctness formula (a). In this derivation, we have
Bi  gi ^ :
i and Si  ai I 
i :D true. The existence of the derivation means that
the following hold:
fI ^ gi ^ :
ig ai I 
i :D true fIg
for i D 1; : : : ; n
(b)
p ^
n
^
iD1
8Eoi W ETi :
i ! I
(c)
I ^
n
^
iD1
8Eoi W ETi .:gi _ 
i/ ! q .
(d)
Let us write I  IŒıi=
in
iD1 for the global assertion from F.;; / obtained
by substituting in I the eligibility ghost variables ıi for the ghost variables 
i.
We deﬁne the assertions pi and qi as follows:
pi
def
 I
and
qi
def
 I
for i D 1; : : : ; n .
It follows from I having no free variable that the pi; qi are focused on the rule ri,
and that pi.Ex/  I and qi.Ex/  I for any Ex 2 Varmi.
– Validity of the individual correctness formulas. For any i 2 f1; : : : ; ng, we show
below that the eligibility-aware correctness formula fpi ^ :ıig r
i fqig holds.
Consider two states s and s0 and a valuation , such that s;  ˆ pi ^ :ıi and
s
.r
i ;/
! s0. We examine in turn the cases where the eligibility-aware rule instance
.r
i ; / is applicable in s, or not.
On the one hand, if the rule instance is not applicable in s, then it is not selectable
and the state s0 is deﬁned as identical to s. It follows then from s;  ˆ pi and from
the fact that, by deﬁnition, pi  qi, that we have s0;  ˆ qi, which proves the
correctness formula fpi ^ :ıig r
i fqig in this case.
If, on the other hand, the rule instance is applicable in s, then s;  ˆ gi. Given
the deﬁnition of pi, we have
s;  ˆ I ^ gi ^ :ıi .
(e)
This expresses in particular that the rule instance is selectable: the state s0 is
deﬁned by hs; s0i;  ˆ Oai ^ Oıi, as stated in Sect. 9.1.3.
Let us deﬁne s˘ and s0
˘ as the states that interpret all attribute symbols and
ghost variables as in s and s0, respectively, except that s˘ and s0
˘ interpret the ghost
variables 
i in the same way as s and s0 interpret the ghost variables ıi. With this
deﬁnition of s˘, and since the rule guard gi contains no ghost variable, we have
from (e) that

170
9
A Veriﬁcation Method for Rule Programs
s˘;  ˆ I ^ gi ^ :
i .
(f)
Similarly, since the rule action ai, and hence the related transition assertion Oai,
contain no ghost variable, we have from the transition assertion that deﬁnes s0
hs˘; s0
˘i;  ˆ Oai ^ O
i.true/ .
(g)
The i-th correctness formula in (b) allows us to derive from (f) and (g) that
s0
˘;  ˆ I .
It follows that s0;  ˆ I, that is, s0;  ˆ qi. This proves the correctness formula
fpi ^ :ıig r
i fqig.
– Freedom from cross-rule interference. For any i; j 2 f1; : : : ; ng with i ¤ j,
we show below that the correctness formula fpi ^ pj ^ :ıi ^ :ıjg r
j fpi ^ :ıig
holds. The proof of the companion correctness formula involving qi ^ ıi is similar.
Consider two states s and s0 and a valuation , such that
s;  ˆ pi ^ pj ^ :ıi ^ :ıj
(h)
and s
.r
j ;/
! s0. We examine in turn the cases where the eligibility-aware rule
instance .r
j; / is applicable in s, or not.
On the one hand, if the rule instance is not applicable in s, then it is not selectable
and the state s0 is deﬁned as identical to s. It follows then from (h) that s0;  ˆ
pi ^ :ıi, which proves the correctness formula in this case.
If, on the other hand, the rule instance is applicable in s, meaning that we have
s;  ˆ gj , then (h) and the deﬁnition of the assertions pi give
s;  ˆ I ^ gj ^ :ıi ^ :ıj .
(i)
This expresses in particular that the rule instance .r
j; / is selectable: the state s0 is
deﬁned by hs; s0i;  ˆ Oaj ^ Oıj.
Let us deﬁne the states s˘ and s0
˘ in the same way as for the proof of the
individual correctness formulas. The equation (i) and the deﬁnition of s0 give
s˘;  ˆ I ^ gj ^ :
j
hs˘; s0
˘i;  ˆ Oaj ^ O
j .true/ .
The j-th correctness formula in (b) allows us to derive from the above that
s0
˘;  ˆ I .
(j)
In addition, since i ¤ j, the transition assertion hs˘; s0
˘i;  ˆ O
j .true/ gives
in particular that hs˘; s0
˘i;  ˆ 
0
i D 
i. And since s˘;  ˆ :
i, it follows that
s0
˘;  ˆ :
i. This with (j) gives s0
˘;  ˆ I ^ :
i, hence

9.4
Relative Completeness
171
s0;  ˆ I ^ :ıi
that is, s0;  ˆ pi ^ :ıi, which proves the desired correctness formula.
– Freedom from interference due to aliasing. For any i 2 f1; : : : ; ng and Ex 2
Varmi, we show below that the third interference-freedom correctness formula
fEx ¤ Eoi ^ pi.Ex/ ^ pi ^ :ıi.Ex/ ^ :ıig r
i fpi.Ex/ ^ :ıi.Ex/g holds. The proof of
the companion correctness formula involving qi.Ex/ ^ ıi.Ex/ is similar.
Consider two states s and s0 and a valuation , such that
s;  ˆ Ex ¤ Eoi ^ pi.Ex/ ^ pi ^ :ıi.Ex/ ^ :ıi
(k)
and s
.r
i ;/
! s0. We examine in turn the cases where the eligibility-aware rule
instance .r
i ; / is applicable in s, or not.
On the one hand, if the rule instance is not applicable in s, then it is not selectable
and the state s0 is deﬁned as identical to s. It follows then from (k) that s0;  ˆ
pi.Ex/ ^ :ıi.Ex/, which proves the targeted correctness formula in this case.
If, on the other hand, the rule instance is applicable in s, meaning that we have
s;  ˆ gi, then (k) and the deﬁnition of pi give
s;  ˆ I ^ gi ^ :ıi.Ex/ ^ :ıi .
(l)
This expresses in particular that the rule instance .r
i ; / is selectable: the state s0 is
deﬁned by hs; s0i;  ˆ Oai ^ Oıi.
Let us deﬁne the states s˘ and s0
˘ in the same way as for the proof of the
individual correctness formulas. The equation (l) and the deﬁnition of s0 give
s˘;  ˆ I ^ gi ^ :
i
hs˘; s0
˘i;  ˆ Oai ^ O
i.true/ .
The i-th correctness formula in (b) allows us to derive from the above that
s0
˘;  ˆ I .
(m)
In addition, since  ˆ Ex ¤ Eoi, the transition assertion hs˘; s0
˘i;  ˆ O
i.true/
gives in particular that hs˘; s0
˘i;  ˆ 
0
i.Ex/ D 
i.Ex/. And since from (l) we also
have s˘;  ˆ :
i.Ex/, it follows that s0
˘;  ˆ :
i.Ex/. This with (m) gives s0
˘;  ˆ
I ^ :
i.Ex/, hence
s0;  ˆ I ^ :ıi.Ex/
that is, s0;  ˆ pi.Ex/ ^ :ıi.Ex/, which proves the targeted correctness formula.
– Derivation by (PR2). We have proven that the eligibility-aware correctness formu-
las fpi ^ :ıig r
i fqig focused on the individual rules hold and are interference free.

172
9
A Veriﬁcation Method for Rule Programs
We can therefore derive the following correctness formula for the rule program R
by proof rule (PR2):
n n
^
iD1
8Eoi W ETi .pi ^ :ıi/
o
R
n n
^
iD1
8Eoi W ETi

qi ^ .:gi _ ıi/
o
.
(n)
We need to prove that the correctness formula fpg R fqg can be derived from this
correctness formula.
For this purpose, consider two states s and s0, such that s ˆ p and s
R
! s0.
Part (i) of Lemma 9.1 indicates that since s is the initial state of a rule program
execution we have s ˆ Vn
iD1 8Eoi W ETi :ıi. Therefore, we have
s ˆ p ^
n
^
iD1
8Eoi W ETi :ıi .
(o)
The implication (c) states that p ^ Vn
iD1 8Eoi W ETi :
i ! I. Let us substitute the
ghost variables ıi for the ghost variables 
i in this implication. Since p 2 F.;; ;/
contains no ghost variable, the substitution gives
p ^
n
^
iD1
8Eoi W ETi :ıi ! I .
This with (o) gives that s ˆ I, and furthermore s ˆ I^Vn
iD1 8Eoi W ETi :ıi, which
is the precondition of the correctness formula (n) given the deﬁnition of pi. As
s
R
! s0, the state s0 satisﬁes the postcondition of the correctness formula (n), that
is, given the deﬁnition of qi:
s0 ˆ I ^
n
^
iD1
8Eoi W ETi .:gi _ ıi/ .
(p)
The implication (d) states that I ^ Vn
iD1 8Eoi W ETi .:gi _ 
i/ ! q. By the same
substitution as above, we obtain I ^ Vn
iD1 8Eoi W ETi .:gi _ ıi/ ! q. This with (p)
gives that s0 ˆ q, proving the correctness formula
fpg R fqg .
– Summary. Given a rule program R D fr1; : : : ; rng and a valid correctness
formula fpg R fqg for this rule program, we have shown that there exists a collection
of 2n eligibility-aware assertions pi; qi 2 F.ri/ focused on the rules in the
program, such that the correctness formulas fpig r
i fqig hold, are interference free,
and the correctness formula derived from them by (PR2) leads to fpg R fqg. That is,
we have given a proof of fpg R fqg by proof rule (PR2).
ut

9.5
Application of the Veriﬁcation Method
173
9.5
Application of the Veriﬁcation Method
9.5.1
Approach
To prove a correctness formula fpg R fqg on a rule program R with proof rule
(PR2), a bottom-up approach similar to the one described in Sect. 8.4 has to be used.
That is, writing R D fr1; : : : ; rng, one should look for assertions pi; qi with
i D 1; : : : ; n, which satisfy the following criteria:
(i) The assertions pi; qi are focused on the corresponding rule, and are eligibility-
aware; that is, pi; qi 2 F.ri/ for i D 1; : : : ; n.
(ii) The eligibility-aware correctness formulas built with these assertions hold for
each rule; that is, fpi ^ :ıig r
i fqig for i D 1; : : : ; n.
(iii) These correctness formulas are free from cross-rule interference, that is, for
i; j D 1; : : : ; n with i ¤ j:
fpi ^ pj ^ :ıi ^ :ıjg r
j fpi ^ :ıig
fqi ^ pj ^ ıi ^ :ıjg r
j fqi ^ ıig .
(iv) They are also free from interference due to aliasing, that is in addition to the
above, for i D 1; : : : ; n and Ex 2 Varmi :
fEx ¤ Eoi ^ pi.Ex/ ^ pi ^ :ıi.Ex/ ^ :ıig r
i fpi.Ex/ ^ :ıi.Ex/g
fEx ¤ Eoi ^ qi.Ex/ ^ pi ^ ıi.Ex/ ^ :ıig r
i fqi.Ex/ ^ ıi.Ex/g .
(v) The correctness formula derived by the proof rule leads to the target one, that is,
p !
n
^
iD1
8Eoi W ETi .pi ^ :ıi/
n
^
iD1
8Eoi W ETi

qi ^ .:gi _ ıi/

! q .
In contrast with (PR1), proof rule (PR2) takes eligibility and aliasing into account.
This has an effect on the assertions pi; qi and on the correctness formulas formed
with them.
To account for eligibility, correctness formulas are now eligibility-aware, with
pre- and postconditions containing eligibility ghost variables. The occurrences of
these ghost variables come both from the assertions pi; qi, and explicitly from the
correctness formulas themselves, as in the precondition of the individual correctness
formulas fpi ^ :ıig r
i fqig.

174
9
A Veriﬁcation Method for Rule Programs
Note that in many examples, the simpler though stronger correctness formula
fpig r
i fqig holds as well. The conjunction with :ıi in the precondition is required
in particular when the assertion pi implies the guard gi, but does not imply the
postcondition qi, as is the case in the example discussed in Sect. 10.1.2. The
conjunction with :ıi then ensures that the executions of ri considered when
verifying the correctness formula effectively apply the rule action.
To address aliasing, the assertions pi; qi should include not only the eligibility
ghost variables for the other rules, but also the one for the rule they are focused on.
Another consequence of aliasing is that the number of applicable instances of
a given rule for a given updated object is not bounded by a constant, but instead
depends on the number of objects in working memory. Consider the following two
rules, extracted from Sect. 8.1:
r1.p W Person/ W p:age > 60 * p:bonus :D p:bonus C 10
r4.c W Card; p W Person/ W p:bonus  20 * c:points :D c:points C 10
An execution of the rule program fr1; r4g contains at most one applicable instance
of the rule r1 on a given instance of Person. On the other hand, such an execution
contains as many applicable instances of r4 on a given instance of Card as there are
instances of Person with a bonus greater than or equal to 20.
This consequence of aliasing usually materializes as weaker postconditions
in correctness formulas, compared to attributes that are updated in unary rules.
More expressivity could be achieved by extending the language of assertions with
constructs expressing the number of objects in working memory that satisfy a given
condition.
Finally, the complexity of the conclusion of (PR2) is both a tool and a burden. On
the one hand, the presence of eligibility ghost variables helps when selecting those
disjuncts in the assertions pi; qi that are relevant in the ﬁrst and last conﬁgurations of
an execution of the rule program. On the other hand, the pre- and postconditions of
a global correctness formula to prove include no eligibility ghost variables. This
makes step (v) in the approach described above more difﬁcult to perform. However
Lemma 9.6 below is of help in this task.
Lemma 9.6. Let R
D fr1; : : : ; rng be a rule program and  the set of its
eligibility ghost variables; let p; q 2 F.;; ;/ be two global assertions containing
no eligibility ghost variable. We have
fpg R fqg
iff
n
p ^
n
^
iD1
8Eoi W ETi :ıi
o
R
n
q ^
n
^
iD1
8Eoi W ETi .:gi _ ıi/
o
.
Proof. We examine each direction of the equivalence in turn.
– Proof of the ) direction. Consider two states s and s0, such that we have s ˆ
p ^ Vn
iD1 8Eoi W ETi :ıi and s
R
! s0. Assume that fpg R fqg holds.

9.5
Application of the Veriﬁcation Method
175
We have in particular s ˆ p and hence by the assumed correctness formula we
have s0 ˆ q.
In addition, since s0 is the ﬁnal state in an execution of R, we have by Lemma 9.1
that s0 ˆ Vn
iD1 8Eoi W ETi .:gi _ ıi/.
Therefore, we have s0 ˆ q ^ Vn
iD1 8Eoi W ETi .:gi _ ıi/, which proves the targeted
correctness formula and this direction of the equivalence.
– Proof of the ( direction. Consider two states s and s0, such that s ˆ p and
s
R
! s0. Assume that fp ^ Vn
iD1 8Eoi W ETi :ıig R fq ^ Vn
iD1 8Eoi W ETi .:gi _ ıi/g
holds.
Since s is the initial state in an execution of R, we have by Lemma 9.1 that
s ˆ Vn
iD1 8Eoi W ETi :ıi. Together with s ˆ p this gives by the assumed correctness
formula that s0 ˆ q ^ Vn
iD1 8Eoi W ETi .:gi _ ıi/.
That is in particular, s0 ˆ q, which proves the targeted correctness formula and
this direction of the equivalence.
ut
The pre- and postconditions in the conclusion of (PR2) are not exactly in the
form of the right-hand side correctness formula in Lemma 9.6. Yet, if two global
assertions p\; q\ 2 F.;; ;/ containing no eligibility ghost variable can be found,
such that
n
^
iD1
8Eoi W ETi .pi ^ :ıi/
,
p\ ^
n
^
iD1
8Eoi W ETi :ıi
n
^
iD1
8Eoi W ETi

qi ^ .:gi _ ıi/

,
q\ ^
n
^
iD1
8Eoi W ETi .:gi _ ıi/
then step (v) can be performed by proving
p ! p\
and
q\ ! q .
The observation of the pre- and postconditions of the conclusion of (PR2) might
suggest to split the inner conjunctions in these assertions, to ﬁnd candidates for
p\ and q\. However, Vn
iD1 8Eoi W ETi pi is usually not eligible for p\, as it contains
eligibility ghost variables. Similarly, Vn
iD1 8Eoi W ETi qi usually contains eligibility
ghost variables and hence is not eligible for q\.
9.5.2
Example
Consider a rule program responsible for accumulating discount points on a collec-
tive discount card, based on the characteristics of the owners of the card. The rule
program R D fr1; r2g below is an example of such a program.

176
9
A Veriﬁcation Method for Rule Programs
r1.u W Card; x W Person/ W x:age > 60 * u:discount :D u:discount C 5
r2.v W Card; y W Person/ W y:cat D Gold * v:discount :D v:discount C 10
Imagine that we want to certify that, at the end of any execution that starts with
empty discount cards, the number of discount points on any card is a non-negative
multiple of 5. This amounts to proving the following correctness formula:
f8c W Card .c:discount D 0/g R f8c W Card 9k .k  0 ^ c:discount D 5k/g .
In the rest of this example, we write P and C for the type names Person and Card,
and d for the discount attribute symbol. The correctness formula to prove is thus
f8c W C .c:d D 0/g R f8c W C 9k .k  0 ^ c:d D 5k/g .
(9.2)
We propose the following eligibility-aware assertions as the pre- and postcondi-
tions of the correctness formulas focused on the individual rules:
p1  u:d D 0 _ 9k .k  0 ^ u:d D 5k/ ^ 9p W P .ı1.u; p/ _ ı2.u; p//
p2  v:d D 0 _ 9k .k  0 ^ v:d D 5k/ ^ 9p W P .ı1.v; p/ _ ı2.v; p//
q1  9k .k  0 ^ u:d D 5k/
q2  9k .k  0 ^ v:d D 5k/ .
These assertions express the evolution of the discount points of a given card,
denoted u in r1 and in the assertions focused on this rule, and v for rule r2. When no
instance of any rule on the given discount card has been applied, it has zero points.
For a card u, this situation corresponds to 8p W P .:ı1.u; p/ ^ :ı2.u; p//. As soon
as one instance of r1 or r2 on the given discount card has been applied, that is, when
9p W P .ı1.u; p/ _ ı2.u; p//, all we know is that the discount points have increased
by 5 or 10 a certain number of times.
In this respect, the assertion p1 could be replaced by
u:d D 0 ^ 8p W P .:ı1.u; p/ ^ :ı2.u; p//
_ 9k .k  1 ^ u:d D 5k/ ^ 9p W P .ı1.u; p/ _ ı2.u; p//
and similarly for p2. However, p1 is implied by the above formula, and sufﬁces to
apply our veriﬁcation method.
Let us now put (PR2) to work on these assertions to prove (9.2).
The Individual Correctness Formulas Hold
We verify below that the eligibility-aware correctness formula fp1 ^ :ı1g r
1 fq1g
holds. A similar argument gives fp2 ^ :ı2g r
2 fq2g.

9.5
Application of the Veriﬁcation Method
177
Consider two states s and s0 and a valuation , such that s;  ˆ p1 ^ :ı1 and
s
.r
1 ;/
! s0. For the correctness formula to hold, we must have s0;  ˆ q1. We
distinguish the cases where the eligibility-aware rule instance .r
1; / is applicable
in s, and hence selectable, or not.
– If the rule instance is selectable, the state s0 is deﬁned by hs; s0i;  ˆ Oa1 ^ Oı1,
which gives in particular (see remark (i) on p. 155)
hs; s0i;  ˆ u:d 0 D u:d C 5 .
(9.3)
By hypothesis we have s;  ˆ p1. Given the deﬁnition of p1 we have either (or
both)
s;  ˆ u:d D 0
or
s;  ˆ 9k .k  0 ^ u:d D 5k/ ^ 9p W P .ı1.u; p/ _ ı2.u; p//
that is in all cases,
s;  ˆ u:d D 5k
for some k  0 .
Applying the transition described by (9.3) to the above gives s0;  ˆ u:d D
5k C 5, that is,
s0;  ˆ 9k .k  1 ^ u:d D 5k/
which implies s0;  ˆ q1.
– If the rule instance is not selectable, the state s0 is deﬁned as identical to s.
As above, s;  ˆ p1 gives in all cases
s0;  ˆ 9k .k  0 ^ u:d D 5k/
which is s0;  ˆ q1.
– Summary. We have seen that, whether the eligibility-aware rule instance .r
i ; /
is selectable or not, we have s0;  ˆ q1. The eligibility-aware correctness formula
fp1 ^ :ı1g r
1 fq1g therefore holds.
Interference Freedom Between Rules: Preconditions
We start by verifying the preservation of p1 ^:ı1 by the eligibility-aware execution
of r2, that is, that fp1 ^ p2 ^ :ı1 ^ :ı2g r
2 fp1 ^ :ı1g holds. A similar argument
gives the preservation of p2 ^ :ı2 by the eligibility-aware execution of r1.

178
9
A Veriﬁcation Method for Rule Programs
Consider two states s and s0 and a valuation , such that
s;  ˆ p1 ^ p2 ^ :ı1 ^ :ı2
(9.4)
and s
.r
2 ;/
! s0. For the correctness formula to hold, we must have s0;  ˆ p1 ^ :ı1.
We distinguish the following cases.
– If the rule instance .r
2; / is not selectable in s, the state s0 is deﬁned as identical
to s. It follows directly from (9.4) that s0;  ˆ p1 ^ :ı1.
– If the rule instance .r
2; / is selectable in s and  ˆ u ¤ v: Since the rule instance
is selectable, the state s0 is deﬁned by hs; s0i;  ˆ Oa2 ^ Oı2, which since  ˆ u ¤ v
gives in particular (see remark (ii) on p. 155)
hs; s0i;  ˆ u:d 0 D u:d ^ 8p W P.ı0
1.u; p/ D ı1.u; p/ ^ ı0
2.u; p/ D ı2.u; p// .
(9.5)
It follows from (9.4) that s;  ˆ p1 ^ :ı1, that is,
s;  ˆ

u:d D 0 _ 9k .k  0 ^ u:d D 5k/ ^ 9p W P .ı1.u; p/ _ ı2.u; p//

^ :ı1.u; x/ .
As the transition described by (9.5) leaves u:d unchanged, as well as ı1.u; 
 / and
ı2.u; 
 /, we have s0;  ˆ p1 ^ :ı1.
– If the rule instance .r
2; / is selectable in s and  ˆ u D v: Since the rule instance
is selectable, the state s0 is deﬁned by hs; s0i;  ˆ Oa2 ^ Oı2, which since  ˆ u D v
gives in particular (see remarks (i) and (ii) on p. 155)
hs; s0i;  ˆ u:d 0 D u:d C 10 ^ ı0
1.u; x/ D ı1.u; x/ ^ ı0
2.u; x/ .
(9.6)
By (9.4) we have s;  ˆ p1, which implies s;  ˆ u:d D 5k for some k  0. By
the ﬁrst conjunct in (9.6) this gives s0;  ˆ u:d D 5k C 10. Together with the last
conjunct in (9.6) this means that
s0;  ˆ 9k .k  2 ^ u:d D 5k/ ^ 9p W P .p D y ^ ı2.u; p//
which implies s0;  ˆ p1.
From (9.4) we have s;  ˆ :ı1, which is a shorthand for s;  ˆ :ı1.u; x/.
Hence, by the second conjunct in (9.6), we have s0;  ˆ :ı1. We ﬁnally have s0;  ˆ
p1 ^ :ı1.
– Summary. We have seen that, whether the eligibility-aware rule instance .r
2; /
is selectable or not, and whether aliasing occurs or not, we have s0;  ˆ p1 ^ :ı1.
The correctness formula fp1 ^ p2 ^ :ı1 ^ :ı2g r
2 fp1 ^ :ı1g therefore holds.

9.5
Application of the Veriﬁcation Method
179
Interference Freedom Between Rules: Postconditions
We now verify the preservation of q1 ^ ı1 by the eligibility-aware execution of r2,
that is, that fq1 ^ p2 ^ ı1 ^ :ı2g r
2 fq1 ^ ı1g holds. A similar argument gives the
preservation of q2 ^ ı2 by the eligibility-aware execution of r1.
Consider two states s and s0 and a valuation , such that
s;  ˆ q1 ^ p2 ^ ı1 ^ :ı2
(9.7)
and s
.r
2 ;/
! s0. For the correctness formula to hold, we must have s0;  ˆ q1 ^ ı1.
We distinguish the same cases as for the preconditions. However, we do not give
the detail of the ﬁrst two cases, as their descriptions are almost identical to the
corresponding cases for the preconditions.
When the rule instance .r
2; / is selectable in s and  ˆ u D v, the deﬁnition of
s0 by hs; s0i;  ˆ Oa2 ^ Oı2 gives in particular
hs; s0i;  ˆ u:d 0 D u:d C 10 ^ ı0
1.u; x/ D ı1.u; x/ ^ ı0
2.u; x/ .
(9.8)
It follows from (9.7) that s;  ˆ q1 ^ ı1, that is,
s;  ˆ 9k .k  0 ^ u:d D 5k/ ^ ı1.u; x/ .
The transition described by (9.8) increases u:d by 10, and leaves ı1.u; x/
unchanged. We thus have
s0;  ˆ 9k .k  2 ^ u:d D 5k/ ^ ı1.u; x/
which implies s0;  ˆ q1 ^ ı1.
The correctness formula fq1 ^ p2 ^ ı1 ^ :ı2g r
2 fq1 ^ ı1g therefore holds.
Interference Freedom Between Instances of a Rule
We now consider two variables t and z, and we verify the preservation of p1.t; z/ ^
:ı1.t; z/ by the eligibility-aware execution of r1 when .t; z/ ¤ .u; x/. That is, we
verify f.t; z/ ¤ .u; x/ ^ p1.t; z/ ^ p1 ^ :ı1.t; z/ ^ :ı1g r
1 fp1.t; z/ ^ :ı1.t; z/g.
A similar argument gives the preservation of p2.t; z/^:ı2.t; z/ by the eligibility-
aware execution of r2 when .t; z/ ¤ .v; y/. Also, the preservation of q1.t; z/ ^
ı1.t; z/ by the eligibility-aware execution of r1 when .t; z/ ¤ .u; x/, and the
preservation of q2.t; z/ ^ ı2.t; z/ by the eligibility-aware execution of r2 when
.t; z/ ¤ .v; y/, are veriﬁed in the same way.
Consider two states s and s0 and a valuation , such that
s;  ˆ .t; z/ ¤ .u; x/ ^ p1.t; z/ ^ p1 ^ :ı1.t; z/ ^ :ı1
(9.9)

180
9
A Veriﬁcation Method for Rule Programs
and s
.r
1 ;/
! s0. For the correctness formula to hold, we must have s0;  ˆ p1.t; z/ ^
:ı1.t; z/. We distinguish the same cases as before.
– If the rule instance .r
1; / is not selectable in s, the state s0 is deﬁned as identical
to s. It follows directly from (9.9) that s0;  ˆ p1.t; z/ ^ :ı1.t; z/.
– If the rule instance .r
1; / is selectable in s and  ˆ t ¤ u, the deﬁnition of s0 by
hs; s0i;  ˆ Oa1 ^ Oı1 gives in particular
hs; s0i;  ˆ t:d 0 D t:d ^ 8p W P.ı0
1.t; p/ D ı1.t; p/ ^ ı0
2.t; p/ D ı2.t; p// .
(9.10)
It follows from (9.9) that s;  ˆ p1.t; z/ ^ :ı1.t; z/, that is,
s;  ˆ

t:d D 0 _ 9k .k  0 ^ t:d D 5k/ ^ 9p W P .ı1.t; p/ _ ı2.t; p//

^ :ı1.t; z/ .
As the transition described by (9.10) leaves t:d unchanged, as well as ı1.t; 
 / and
ı2.t; 
 /, we have s0;  ˆ p1.t; z/ ^ :ı1.t; z/.
– If the rule instance .r
1; / is selectable in s and  ˆ t D u, the deﬁnition of s0 by
hs; s0i;  ˆ Oa1 ^ Oı1 gives in particular
hs; s0i;  ˆ t:d 0 D t:d C 5 ^ ı0
1.t; x/ ^ 8p W P.p ¤ x ! ı0
1.t; p/ D ı1.t; p// .
(9.11)
By (9.9) we have s;  ˆ p1.t; z/, which implies s;  ˆ t:d D 5k for some k  0.
By the ﬁrst conjunct in (9.11) this gives s0;  ˆ t:d D 5k C 5. Together with the
second conjunct in (9.11) this means that
s0;  ˆ 9k .k  1 ^ t:d D 5k/ ^ 9p W P .p D x ^ ı1.t; p//
which implies s0;  ˆ p1.t; z/.
From (9.9) we also have s;  ˆ :ı1.t; z/. Since by hypothesis  ˆ .t; z/ ¤ .u; x/
and  ˆ t D u, we must have  ˆ z ¤ x. Hence, by the last conjunct in (9.11), we
have s0;  ˆ :ı1.t; z/. It follows that s0;  ˆ p1.t; z/ ^ :ı1.t; z/.
– Summary. We have seen that, whether the eligibility-aware rule instance .r
1; /
is selectable or not, and whether aliasing occurs or not, we have s0;  ˆ p1.t; z/ ^
:ı1.t; z/. The expected correctness formula therefore holds.
Proving the Global Correctness Formula
In the above, we have veriﬁed all the premises of proof rule (PR2): we can derive its
conclusion. Let us write f'g R f g for this derived correctness formula: we have

9.5
Application of the Veriﬁcation Method
181
'
def

2^
iD1
8Eoi W ETi .pi ^ :ıi/
 8u W C 8x W P .p1 ^ :ı1/ ^ 8v W C 8y W P .p2 ^ :ı2/
 
def

2^
iD1
8Eoi W ETi

qi ^ .:gi _ ıi/

 8u W C 8x W P

q1 ^ .:g1 _ ı1/

^ 8v W C 8y W P

q2 ^ .:g2 _ ı2/

.
Let us also write fpg R fqg for the correctness formula (9.2) to prove, that is,
p
def
 8c W C .c:d D 0/
q
def
 8c W C 9k .k  0 ^ c:d D 5k// .
To complete the proof of (9.2) with (PR2), we need to show that f'g R f g leads to
fpg R fqg.
– Detail of '. From their deﬁnitions, it can be seen that the only free variables in
p1 and p2 are u and v, respectively. We can therefore rename in ' the card variables
to c and the person variables to p. We get
' , 8c W C 8p W P .p1.c; p/ ^ p2.c; p/ ^ :ı1.c; p/ ^ :ı2.c; p// .
However, we have
p1.c; p/  p2.c; p/  c:d D 0 _ 9k .k  0 ^ c:d D 5k/ ^ 9p W P .ı1.c; p/ _ ı2.c; p// .
Let us write p0
def
 p1.c; p/  p2.c; p/: we have
' , 8c W C 8p W P .p0 ^ :ı1.c; p/ ^ :ı2.c; p//
and since c is the only free variable in p0,
' , 8c W C

p0 ^ 8p W P .:ı1.c; p/ ^ :ı2.c; p//

.
That is, by expanding p0,
' , 8c W C

c:d D 0 _ 9k .k  0 ^ c:d D 5k/ ^ 9p W P .ı1.c; p/ _ ı2.c; p//

^ 8p W P .:ı1.c; p/ ^ :ı2.c; p//
	
which, after simpliﬁcation, gives

182
9
A Veriﬁcation Method for Rule Programs
' , 8c W C .c:d D 0/ ^ 8c W C 8p W P

:ı1.c; p/ ^ :ı2.c; p/

, 8c W C .c:d D 0/ ^ 8u W C 8x W P :ı1 ^ 8v W C 8y W P :ı2 .
– Detail of  . Let us recall that we have
  8u W C 8x W P

q1 ^ .:g1 _ ı1/

^ 8v W C 8y W P

q2 ^ .:g2 _ ı2/

.
The free variables in q1 and q2 are u and v, respectively. We can therefore rename
them to c and the person variables to p:
 , 8c W C 8p W P

q1.c; p/ ^ q2.c; p/

^ 8u W C 8x W P .:g1 _ ı1/ ^ 8v W C 8y W P .:g2 _ ı2/ .
However, we have
q1.c; p/  q2.c; p/  9k .k  0 ^ c:d D 5k/ .
Let us write q0
def
 q1.c; p/  q2.c; p/. Since c is the only free variable in q0, we
have
 , 8c W C q0 ^ 8u W C 8x W P .:g1 _ ı1/ ^ 8v W C 8y W P .:g2 _ ı2/ .
– Conclusion. By proof rule (PR2), we derived f'g R f g. The details of ' and  
have given that
' , 8c W C .c:d D 0/ ^ 8u W C 8x W P :ı1 ^ 8v W C 8y W P :ı2
, p ^ V2
iD18Eoi W ETi :ıi
and
 , 8c W C 9k .k  0 ^ c:d D 5k/ ^ 8u W C 8x W P .:g1 _ ı1/ ^ 8v W C 8y W P .:g2 _ ı2/
, q ^ V2
iD18Eoi W ETi .:gi _ ıi/ .
The correctness formula f'g R f g is thus equivalent to
n
p ^
2^
iD1
8Eoi W ETi :ıi
o
R
n
q ^
2^
iD1
8Eoi W ETi .:gi _ ıi/
o
.
By Lemma 9.6, this correctness formula is equivalent to fpg R fqg, which is
therefore proven.

References
183
Discussion
Given the rule program R restated below, we have proven with proof rule (PR2)
that at the end of any execution that starts with empty discount cards, the number of
discount points on any card is a non-negative multiple of 5.
r1.u W Card; x W Person/ W x:age > 60 * u:discount :D u:discount C 5
r2.v W Card; y W Person/ W y:cat D Gold * v:discount :D v:discount C 10
Although the veriﬁcation of the premises of the rules is long, it is mainly
mechanical. The creative part in the application of proof rule (PR2) resides in ﬁnding
the right pi; qi assertions.
The present example focuses on interference due to aliasing, as for a given
instance of Card the condition c:discount D 0 is subject to being invalidated
by the application of any rule instance that includes this object. As discussed in
Sect. 9.2.2, this kind of interference is addressed by both groups of interference-
freedom correctness formulas in the premises of the proof rule.
The examples in Sect. 10.1 prove correctness formulas for unary rule programs,
which are immune to interference due to aliasing. These examples further illustrate
how to take eligibility into account, independently of cross-rule interference.
References
1. Apt, K.R.: Ten years of Hoare’s logic: A survey—part II: Nondeterminism. Theor. Comp. Sci.
28, 83–109 (1984)
2. Cook, S.A.: Soundness and completeness of an axiom system for program veriﬁcation. Soc.
Ind. Appl. Math. J. Comput. 7(1), 70–90 (1978)
3. Dijkstra, E.W.: Guarded commands, nondeterminacy and formal derivation of programs. Comm.
ACM 18(8), 453–457 (1975)

Chapter 10
Specialized Proof Rules
The proof rule presented in the previous chapter handles rules with an arbitrary
number of variables, takes the eligibility of rule instances into account, and
addresses both cross-rule interference and interference due to aliasing. Naturally,
this proof rule can also be used to prove correctness formulas for rule programs
when eligibility or either kind of interference plays no role. In such cases however,
using a specialized proof rule is simpler, in that fewer premises have to be veriﬁed,
or eligibility ghost variables can be omitted.
Chapter 8 introduced such a specialized proof rule, suited to correctness formulas
for rule programs made of unary rules and where eligibility need not be taken into
account. The present chapter provides additional proof rules, specialized for some
classes of rule programs and correctness formulas to prove on them.
10.1
Eligibility-Aware Unary Rules
Unary rules are deﬁned in Sect. 8.2, with a short reminder below. They have the
simplifying property that they cannot cause, or suffer from, interference due to
aliasing.
A unary rule has only one rule variable. In this context, we simplify the notations:
given a rule program R D fr1; : : : ; rng made of unary rules, we denote the rules
ri D .oi; Ti; gi; ai/ with ai  oi:fri :D eri, for i D 1; : : : ; n. We use the notation
8Eo W ET as an abbreviation for 8o1 W T1 : : : 8on W Tn.
In Chap. 8, we presented the foundations of our veriﬁcation method with rule
programs made of unary rules, in cases where eligibility need not be taken
into account. This restriction eliminates the need for eligibility ghost variables.
Section 8.4 gives an example of such a case.
Here, we address the case of correctness formulas for unary rule programs
in which eligibility must be taken into account. Eligibility ghost variables must
therefore be included in the correctness formulas focused on the rules. Still there
B. Berstel-Da Silva, Veriﬁcation of Business Rules Programs,
DOI 10.1007/978-3-642-40038-4__10, © Springer-Verlag Berlin Heidelberg 2014
185

186
10
Specialized Proof Rules
is no possibility of interference due to aliasing, and the last group of premises in
proof rule (PR2) can be omitted. This property is formalized in the lemma below.
Lemma 10.1. Let R D fr1; : : : ; rng be a rule program made of unary rules and
 the set of its eligibility ghost variables. Given an i 2 f1; : : : ; ng, two eligibility-
aware assertions pi; qi 2 F.ri/ focused on the rule ri, and a variable x, the
following correctness formulas hold:
fx ¤ oi ^ pi.x/ ^ pi ^ :ıi.x/ ^ :ıig r
i fpi.x/ ^ :ıi.x/g
fx ¤ oi ^ qi.x/ ^ pi ^ ıi.x/ ^ :ıig r
i fqi.x/ ^ ıi.x/g .
Proof. Consider two states s and s0 and a valuation , such that s
.r
i ;/
! s0.
If the rule instance .r
i ; / is not selectable in s, then the state s0 is deﬁned as
identical to s. As a consequence, if s satisﬁes the precondition of either correctness
formula, then s0 satisﬁes its conclusion.
If the rule instance .r
i ; / is selectable in s, then the state s0 is deﬁned by
hs; s0i;  ˆ Oai ^ Oıi, as stated in Sect. 9.1.3. If  ˆ x ¤ oi then this transition
gives in particular
hs; s0i;  ˆ
^
f 2Attr
x:f 0 D x:f ^
^
ı2
ı0.x/ D ı.x/ .
Since the rules, and hence the assertions pi; qi and the eligibility ghost variables, are
unary, it follows that the truth values of pi.x/, of qi.x/, and of ıi.x/ are the same
in s and in s0. As a consequence, if s satisﬁes the precondition of either correctness
formula, then s0 satisﬁes its conclusion.
For both correctness formulas, we have proven that any eligibility-aware execu-
tion of ri from a state that satisﬁes the precondition of the correctness formula results
in a state that satisﬁes its postcondition. This proves the validity of the correctness
formulas, and hence the lemma.
ut
10.1.1
Proof Rule
Theorem 10.2. Let R D fr1; : : : ; rng be a rule program made of unary rules and
 its set of eligibility ghost variables. For i D 1; : : : ; n let pi; qi 2 F.ri/ be
assertions focused on the rule ri, possibly containing eligibility ghost variables.
The proof rule below is sound and relatively complete (in the sense of Sect. 9.4).

10.1
Eligibility-Aware Unary Rules
187
fpi ^ :ıig r
i fqig
for i D 1; : : : ; n
fpi ^ pj ^ :ıi ^ :ıjg r
j fpi ^ :ıig
fqi ^ pj ^ ıi ^ :ıjg r
j fqi ^ ıig
)
for i; j D 1; : : : ; n with i ¤ j
n n
^
iD1
8oi W Ti .pi ^ :ıi/
o
R
n n
^
iD1
8oi W Ti

qi ^ .:gi _ ıi/
o
(PR3)
Proof. The soundness of (PR3) is a consequence of Theorem 9.2 stating the
soundness of (PR2), and of Lemma 10.1 above.
Its relative completeness for unary rule programs is deduced below from the
relative completeness of (PR2) stated by Theorem 9.4. The relative completeness of
(PR2) implies that for any valid global correctness formula fpg R fqg, there exist
eligibility-aware assertions pi; qi for i D 1; : : : ; n, such that:
(i) The assertions are focused on the corresponding rules, that is, pi; qi 2 F.ri/.
(ii) The eligibility-aware correctness formulas fpi ^ :ıig r
i fqig hold.
(iii) They are interference free, with in particular
fpi ^ pj ^ :ıi ^ :ıjg r
j fpi ^ :ıig
fqi ^ pj ^ ıi ^ :ıjg r
j fqi ^ ıig
)
for i; j D 1; : : : ; n with i ¤ j .
(iv) The correctness formula derived from them by (PR2), which is the same as the
one in the conclusion of (PR3), leads to fpg R fqg.
The ﬁrst three conditions correspond to the premises of (PR3). Together with the
last one, they express the relative completeness of (PR3) for unary rule programs.
ut
As noted at the end of Sect. 8.3, it is often the case in programs made of unary
rules that the sole variables of the rules in the program all have the same type T . In
this case, the conclusion of the proof rule can be reorganized, and the proof rule can
be written
fpi ^ :ıig r
i fqig
for i D 1; : : : ; n
fpi ^ pj ^ :ıi ^ :ıjg r
j fpi ^ :ıig
fqi ^ pj ^ ıi ^ :ıjg r
j fqi ^ ıig
)
for i; j D 1; : : : ; n with i ¤ j
n
8o W T
n
^
iD1

pi.o/ ^ :ıi.o/
o
R
n
8o W T
n
^
iD1

qi.o/ ^ .:gi.o/ _ ıi.o//
o
.
Example. As a ﬁrst illustration of the interest of (PR3), let us return to the rule
program and correctness formula that served as a counterexample in the proof of
the incompleteness of (PR1) in Sect. 8.5.

188
10
Specialized Proof Rules
Consider the rule program R D fr1; r2g and the correctness formula below:
r1.x W T/ W x:a  20 * x:b :D x:a  10
r2.y W T/ W y:b > 70 * y:b :D 70
f8o W T .o:b D 0/g R f8o W T .o:b  70/g .
We propose the following assertions as pre- and postconditions of the correctness
formulas focused on each rule:
p1  x:b D 0 ^ :ı2.x/
q1  true
p2  true
q2  y:b  70 .
– The individual correctness formulas hold. Because q1  true, the correctness
formula fp1 ^ :ı1g r
1 fq1g holds trivially. On the other hand, fp2 ^ :ı2g r
2 fq2g is
obvious.
– Interference freedom. Let us start with fp1 ^ p2 ^ :ı1 ^ :ı2g r
2 fp1 ^ :ı1g,
and consider two states s and s0 and a valuation , such that s;  ˆ p1 ^ p2 ^
:ı1 ^ :ı2 and s
.r
2 ;/
! s0. If the rule instance .r
2; / is not applicable, then s0 D s
and the correctness formula holds. If, on the other hand, .r
2; / is applicable, we
have s;  ˆ g2. Together with the hypothesis s;  ˆ p1 this gives s;  ˆ x:b D
0 ^ y:b > 70, which implies that  ˆ x ¤ y. As a consequence, p1 and ı1 are left
unchanged by the execution of the rule instance, since their only free variable is x.
Hence s0;  ˆ p1 ^ :ı1.
The correctness formula fp1 ^ p2 ^ :ı1 ^ :ı2g r
1 fp2 ^ :ı2g has the same
precondition: the same reasoning also leads to x ¤ y when the rule instance is
applicable. Its execution therefore leaves p2 and ı2 unchanged, and the postcondi-
tion holds.
The correctness formula expressing the preservation of q1^ı1 by r
2 boils down to
fı1 ^ :ı2g r
2 fı1g. Its precondition forces x ¤ y, which implies that the execution
of the rule r2 leaves ı1 unchanged, and that the postcondition holds.
Finally, the correctness formula expressing the preservation of q2 ^ ı2 by r
1
is fq2 ^ p1 ^ ı2 ^ :ı1g r
1 fq2 ^ ı2g. Its precondition is y:b  70 ^ x:b D 0 ^
:ı2.x/ ^ ı2 ^ :ı1, in which :ı2.x/ ^ ı2 forces x ¤ y. This again implies that
the execution of the rule r1 leaves q2 and ı2 unchanged, and that the postcondition
holds.
– Conclusion. As the premises of (PR3) hold, we can derive the following correct-
ness formula by this proof rule:
f8o W T

o:b D 0 ^ :ı2.o/ ^ :ı1.o/

g R
f8o W T

.:g1.o/ _ ı1.o// ^ o:b  70 ^ .:g2.o/ _ ı2.o//

g

10.1
Eligibility-Aware Unary Rules
189
Lemma 9.6 was proven for rules of arbitrary arity and hence holds for unary rules
as well. By this lemma the correctness formula above is equivalent to
f8o W T .o:b D 0/g R f8o W T .o:b  70/g
which was the correctness formula to prove.
Proof rule (PR3) is thus capable of proving any valid correctness formula for
unary rule programs, even when eligibility has to be taken into account. Compared
to the general proof rule (PR2) presented in the previous chapter, it exploits the fact
that rules are unary, and hence are free from interference due to aliasing.
10.1.2
Example
Imagine a rule program responsible for computing a bonus for customers from
contributions based on their ages and categories. Such a rule program could contain
the two rules below, previously given as an example of unary rules in Sect. 8.2:
r1.x W P/ W x:age > 60 * x:bonus :D x:bonus C 10
r2.y W P/ W y:cat D Gold * y:bonus :D y:bonus C 15
These two rules respectively increment the customer’s bonus by 10 and 15 when
the customer is senior or gold. Our concern here is to prove that the rule program
R D fr1; r2g does not increase the bonus of senior gold customers by more than
15 points. Assuming that the initial bonus is limited to 30, this concern could be
represented by the following correctness formula for R:
f8o W P .o:age > 60 ^ o:bonus 30 ^ o:cat D Gold/g R f8o W P .o:bonus  55/g :
This correctness formula cannot be proven using (PR1), because the rules do
not invalidate their guards. Therefore only the eligibility mechanism can prevent
them from being applied several times. As a result and since their actions are not
idempotent, trying to ﬁnd pre- and postconditions for correctness formulas focused
on them as done in Sect. 8.4 does not converge. That is, repeatedly weakening these
assertions to reﬂect the effect of the rules does not reach a ﬁxed point. Eligibility
ghost variables help solve this problem.
The Approach
As when applying the proof rules (PR1) and (PR2), the proof of a correctness formula
fpg R fqg on a rule program R D fr1; : : : ; rng using (PR3) is achieved by ﬁnding
assertions pi; qi focused on the rules in the program, such that the correctness

190
10
Specialized Proof Rules
formulas fpi ^ :ıig r
i fqig hold, are interference free, and the correctness formula
derived from them by the proof rule leads to fpg R fqg.
Here, the premises of the proof rule contain no correctness formulas speciﬁc to
interference due to aliasing. In addition, since the rules in the program are unary, the
assertions pi; qi are unary as well. The veriﬁcation of the cross-rule interference-
freedom correctness formulas can therefore be simpliﬁed by Lemma 10.3 given
below, which can be seen as the eligibility-aware version of Lemma 8.4.
Finally, Lemma 9.6 can be used to conclude fpg R fqg from the correctness
formula derived from the proof rule.
Lemma 10.3. Let R D fr1; : : : ; rng be a rule program made of unary rules and 
the set of its eligibility ghost variables; let ri D .oi; Ti; gi; ai/ be a rule from R and
' 2 F.fog; / an eligibility-aware unary assertion in the fresh variable o. If we
have
f' ^ pi ^ gi ^ :ıi ^ oi D og r
i f'g
then we have
f' ^ pig r
i f'g .
Proof. Consider two states s and s0 and a valuation , such that s;  ˆ ' ^ pi and
s
.r
i ;/
! s0. To prove the lemma, we must show that s0;  ˆ '.
– If s;  ˆ :gi or s;  ˆ ıi then by deﬁnition of eligibility-aware rule instance
execution (see Sect. 9.1.3), s
.r
i ;/
! s0 means that s0 D s. We then have s0;  ˆ '.
– If s;  ˆ gi ^ :ıi and  ˆ oi D o then we have s0;  ˆ ' by hypothesis.
– If s;  ˆ gi ^ :ıi and  ˆ oi ¤ o then s
.r
i ;/
! s0 means that hs; s0i;  ˆ
Oai ^ Oıi, with in particular (see Sect. 9.1.3 again) hs; s0i;  ˆ V
f 2Attr.o:f 0 D o:f /^
V
ı2.ı0.o/ D ı.o//. Since free.'/ D fog we then have s0;  ˆ '.
ut
The Assertions
The rule program under consideration is R D fr1; r2g made of the two rules below:
r1.x W P/ W x:age > 60 * x:bonus :D x:bonus C 10
r2.y W P/ W y:cat D Gold * y:bonus :D y:bonus C 15
For the rest of this section, we abbreviate the age, bonus and category attribute
symbols to a, b, and c, respectively. The global correctness formula that we want to
prove with proof rule (PR3) therefore reads:
f8o W P .o:a > 60 ^ o:b  30 ^ o:c D Gold/g R f8o W P .o:b  55/g .

10.1
Eligibility-Aware Unary Rules
191
We propose the following eligibility-aware assertions as the pre- and postcondi-
tions of the correctness formulas focused on the individual rules:
p1  x:a > 60 ^ .x:b  30 ^ :ı2.x/ _ x:b  45 ^ ı2.x//
q1  x:a > 60 ^ .x:b  40 ^ :ı2.x/ _ x:b  55 ^ ı2.x//
p2  y:c D Gold ^ .y:b  30 ^ :ı1.y/ _ y:b  40 ^ ı1.y//
q2  y:c D Gold ^ .y:b  45 ^ :ı1.y/ _ y:b  55 ^ ı1.y// .
In each of these assertions, the eligibility ghost variables are clearly used to take
into account whether the other rule has been executed on the same object or not. In
p1 for example, if the rule r2 has not yet been executed on the object held by x, then
ı2.x/ will be false and the assertion will retain x:b  30. If, on the other hand, r2
has already been executed on the object held by x, then ı2.x/ will be true and the
assertion will retain x:b  45, that is, the initial 30 plus the increment brought in
by r2.
Below we explain the application of (PR3) in detail.
The Individual Correctness Formulas Hold
We start by verifying that the correctness formula fp1 ^ :ı1g r
1 fq1g holds. A sim-
ilar argument gives that fp2 ^ :ı2g r
2 fq2g holds.
Consider two states s and s0 and a valuation , such that s;  ˆ p1 ^ :ı1 and
s
.r
1 ;/
! s0, that is,
s;  ˆ x:a > 60 ^ .x:b  30 ^ :ı2.x/ _ x:b  45 ^ ı2.x// ^ :ı1
hs; s0i;  ˆ x:b0 D x:b C 10 ^ 8o .o ¤ x ! o:b0 D o:b/
^ 8o .o:a0 D o:a ^ o:c0 D o:c/
^ ı0
1.x/ ^ 8o .o ¤ x ! ı0
1.o/ D ı1.o//
^ 8o .ı0
2.o/ D ı2.o// .
That is in particular,
hs; s0i;  ˆ x:a0 D x:a ^ x:b0 D x:b C 10 ^ ı0
2.x/ D ı2.x/ .
It follows that
s0;  ˆ x:a > 60 ^ .x:b  40 ^ :ı2.x/ _ x:b  55 ^ ı2.x//
that is, s0;  ˆ q1, which establishes the targeted correctness formula.

192
10
Specialized Proof Rules
Note that here, the correctness formula fp1 ^ :ı1g r
1 fq1g holds, as just proven,
but the stronger fp1g r
1 fq1g does not. Indeed, consider a state s and a valuation ,
such that s;  ˆ p1 ^ ı1. In this state, the eligibility-aware rule instance .r
1; / is
not selectable, and hence s
.r
1 ;/
! s. For fp1g r
1 fq1g to hold, we should therefore
have p1 ! q1, which is not the case.
Interference Freedom
We start by verifying that fp1 ^ p2 ^ :ı1 ^ :ı2g r
2 fp1 ^ :ı1g holds. For this
purpose, we consider two states s and s0 and a valuation , such that s
.r
2 ;/
! s0.
By Lemma 10.3 it sufﬁces to consider the case where s;  ˆ p1.y/ ^ p2 ^ g2 ^
:ı1.y/ ^ :ı2, and to check that s0;  ˆ p1.y/ ^ :ı1.y/.
In the precondition p1.y/ ^ p2 ^ g2 ^ :ı1.y/ ^ :ı2 the disjunction in p1.y/
simpliﬁes with :ı2 to give y:a > 60^y:b  30^:ı2. Similarly p2 simpliﬁes with
:ı1.y/. From these simpliﬁcations, we have
s;  ˆ y:a > 60 ^ y:b  30 ^ y:c D Gold ^ :ı1.y/ ^ :ı2.y/ .
This makes the rule instance .r
2; / selectable. Since from hs; s0i;  ˆ Oa2 ^ Oı2 we
have in particular
hs; s0i;  ˆ y:a0 D y:a ^ y:b0 D y:b C 15 ^ ı0
1.y/ D ı1.y/ ^ ı0
2.y/
it follows that
s0;  ˆ y:a > 60 ^ y:b  45 ^ :ı1.y/ ^ ı2.y/
hence
s0;  ˆ y:a > 60 ^ .y:b  30 ^ :ı2.y/ _ y:b  45 ^ ı2.y// ^ :ı1.y/
that is,
s0;  ˆ p1.y/ ^ :ı1.y/ .
The veriﬁcation of the other three correctness formulas expressing interference
freedom follows the same reasoning: use Lemma 10.3 to restrict the precondition,
and apply the effect of the rule action (that is, increment the bonus and swap the
corresponding eligibility rule variable) to obtain the postcondition.

10.1
Eligibility-Aware Unary Rules
193
Conclusion
Having veriﬁed all the premises of (PR3), we can derive its conclusion, that is,
f8o W P

p1.o/ ^ p2.o/ ^ :ı1.o/ ^ :ı2.o/

g R
f8o W P

q1.o/ ^ q2.o/ ^ .:g1.o/ _ ı1.o// ^ .:g2.o/ _ ı2.o//

g .
As with the correctness formulas expressing interference freedom, the assertions
pi; qi simplify in the pre- and postconditions of this correctness formula with the
eligibility ghost variables. Namely, we have
p1.o/ ^ :ı2.o/  o:a > 60 ^ o:b  30 ^ :ı2.o/
p2.o/ ^ :ı1.o/  o:c D Gold ^ o:b  30 ^ :ı1.o/
q1.o/ ^ .:g2.o/ _ ı2.o//  o:a > 60 ^ o:b  55 ^ ı2.o/ _ q1.o/ ^ o:c ¤ Gold
q2.o/ ^ .:g1.o/ _ ı1.o//  o:c D Gold ^ o:b  55 ^ ı1.o/ _ q2.o/ ^ o:a  60 :
The precondition of the correctness formula derived by (PR3) can therefore be
written as
8o W P .o:a > 60 ^ o:b  30 ^ o:c D Gold/ ^ 8o W P .:ı1.o/ ^ :ı2.o//
while the postcondition, after eliminating the false disjuncts, can be written as
8o W P .o:a > 60 ^ o:b  55 ^ o:c D Gold/ ^ 8o W P .ı1.o/ ^ ı2.o// .
By Lemma 9.6 this leads to the following correctness formula, which was the one
to prove:
f8o W P .o:a > 60 ^ o:b  30 ^ o:c D Gold/g R f8o W P .o:b  55/g .
Discussion
In the example above, the negated guards in the postcondition of the correctness
formula derived by (PR3) are no longer present after simpliﬁcation. This comes from
the fact that each pi implied the corresponding guard gi, which was left untouched
by the rule actions.
In complementary cases, the negated guards would be visible in the postcondition
of the ﬁnal correctness formula, for example, in the following correctness formula
where o:a > 60 is no longer part of the precondition:
f8o W P .o:b  30 ^ o:c D Gold/g R
f8o W P

.o:a  60 ! o:b  45/ ^ .o:a > 60 ! o:b  55/

g .

194
10
Specialized Proof Rules
10.2
Aliasing-Free n-ary Rule Programs
Unary rules, introduced in Chap. 8 and also discussed in Sect. 10.1 above, are an
option to avoid interference due to aliasing. However this option imposes a strong
constraint on the syntax of the rules in the program.
There is an alternative to this constraint that can be used with rules of arbitrary
arity, which we call n-ary rules. In this alternative option, the working memory
must contain at most one instance of each type. This constraint on the contents of
the working memory also ensures that no interference due to aliasing occurs. We
formalize it in the following lemma.
Lemma 10.4. Let R D fr1; : : : ; rng be a rule program and  the set of its eligi-
bility ghost variables. Consider an i 2 f1; : : : ; ng, two eligibility-aware assertions
pi; qi 2 F.ri/ focused on the rule ri, and a tuple of variables Ex 2 Varjri j. In
executions of R on a working memory M with at most one instance per type, that
is, such that
for each T 2 Types
jM .T /j  1
the following correctness formulas hold:
fEx ¤ Eoi ^ pi.Ex/ ^ pi ^ :ıi.Ex/ ^ :ıig r
i fpi.Ex/ ^ :ıi.Ex/g
fEx ¤ Eoi ^ qi.Ex/ ^ pi ^ ıi.Ex/ ^ :ıig r
i fqi.Ex/ ^ ıi.Ex/g .
Proof. Both correctness formulas trivially hold because their preconditions are
false, which we show below by contradiction.
Indeed, suppose that there exist a state s and a valuation , such that s;  ˆ Ex ¤
Eoi ^ pi.Ex/ ^ pi ^ :ıi.Ex/ ^ :ıi or s;  ˆ Ex ¤ Eoi ^ qi.Ex/ ^ pi ^ ıi.Ex/ ^ :ıi. In
both cases this means that  ˆ Ex ¤ Eoi.
Let us write mi D jrij for the arity of the rule ri:  ˆ Ex ¤ Eoi means that there
exists a j 2 f1; : : : ; mig such that .xj/ ¤ .oi
j/. However, since we are in an
execution of a rule program, the valuation  is well-typed for the type constraint
.Eoi W ETi/ induced by the rule, meaning that both .xj / 2 T i
j and .oi
j/ 2 T i
j . This
contradicts jM .T i
j /j  1.
ut
In such a setting where rules can be of arbitrary arity but the working memory
contains at most one instance of each type, the proof rule provided by the following
theorem can be used.
Theorem 10.5. Let R D fr1; : : : ; rng be a rule program and  its set of eligibility
ghost variables. For i D 1; : : : ; n let pi; qi 2 F.ri/ be assertions focused on the
rule ri, possibly containing eligibility ghost variables. The proof rule below is sound
and relatively complete (in the sense of Sect. 9.4) for executions of R on a working
memory that contains at most one instance of each type.

10.2
Aliasing-Free n-ary Rule Programs
195
fpi ^ :ıig r
i fqig
for i D 1; : : : ; n
fpi ^ pj ^ :ıi ^ :ıjg r
j fpi ^ :ıig
fqi ^ pj ^ ıi ^ :ıjg r
j fqi ^ ıig
)
for i; j D 1; : : : ; n with i ¤ j
n n
^
iD1
8Eoi W ETi .pi ^ :ıi/
o
R
n n
^
iD1
8Eoi W ETi

qi ^ .:gi _ ıi/
o
(PR4)
Proof. The soundness of (PR4) is a consequence of Theorem 9.2 stating the
soundness of (PR2), and of Lemma 10.4 above.
Its relative completeness results from the relative completeness of (PR2) stated by
Theorem 9.4. The relative completeness of (PR2) implies that for any valid global
correctness formula fpg R fqg, there exist eligibility-aware assertions pi; qi for i D
1; : : : ; n, such that:
(i) The assertions are focused on the corresponding rules, that is, pi; qi 2 F.ri/.
(ii) The eligibility-aware correctness formulas fpi ^ :ıig r
i fqig hold.
(iii) They are interference free, with in particular
fpi ^ pj ^ :ıi ^ :ıjg r
j fpi ^ :ıig
fqi ^ pj ^ ıi ^ :ıjg r
j fqi ^ ıig
)
for i; j D 1; : : : ; n with i ¤ j .
(iv) The correctness formula derived from them by (PR2), which is the same as the
one in the conclusion of (PR4), leads to fpg R fqg.
The ﬁrst three conditions correspond to the premises of (PR4). Together with the
last one, they express the relative completeness of (PR4) for unary rule programs.
ut
Informally, a working memory with at most one instance per type avoids aliasing
by a similar mechanism to unary rules. Indeed, unary rules limit the number of
objects involved in a rule instance to one. As a result, there cannot be two distinct
instances of a rule that update the same object. On the other hand, a working memory
with at most one instance per type limits the number of instances of each rule to one.
The consequence is that there cannot be two distinct instances of a rule at all.
We can sketch a mapping between the two settings that shows that they are
equivalent: given a rule program R and a working memory M containing at most
one instance of each type, we can build another rule program R0 made of unary
rules and a working memory M 0, and vice versa, such that the executions of R on
M are in bijection with the executions of R0 on M 0.
From R and M to R0 and M 0. We consider a rule program R D fr1; : : : ; rng and
a working memory M , such that for i D 1; : : : ; n and for j D 1; : : : ; jrij we have
ri D .Eoi; ETi; gi; ai/ and jM .T i
j /j  1.
We introduce a new unifying type U that includes in its deﬁnition all the attribute
symbols in the deﬁnitions of the types appearing in the rules:

196
10
Specialized Proof Rules
˛.U/
def
D
[
iD1;:::;n
j D1;:::;jri j
˛.T i
j / .
This deﬁnition beneﬁts from the constraint stated in Sect. 3.3.2 that type deﬁnitions
are disjoint.
Since each type T i
j has at most one instance, the whole working memory M can
be represented by one instance of U. And since all the types have been uniﬁed, the
sole rule instance of each rule of R can be mapped onto an instance of an equivalent
rule with only one variable of type U, on the unique instance of U.
From R0 and M 0 to R and M . We consider a rule program R0 D fr1; : : : ; rng
made of unary rules ri D .oi; Ti; gi; ai/, and a working memory M 0 with possibly
several instances of each type.
For each i D 1; : : : ; n, if the working memory contains mi instances of the
type Ti, we deﬁne in T as many copies T i
1 ; : : : ; T i
mi of the type, each with only
one instance in M , and we deﬁne as many copies of the rule ri in R, each with
a variable typed by a copy of Ti, that is, ri
j D .oi
j; T i
j ; ij .gi/; ij .ai// with the
substitution ij D Œoi
j=oiŒfj =f f 2˛.Ti / for j D 1; : : : ; mi.
Example. As an example of a correctness formula that holds on an n-ary rule
program when the working memory contains at most one instance of each type, we
can use the program and correctness formula proposed in Sect. 10.1.2, only slightly
modiﬁed into a two-variable version:
r1.c W Cart; p W Person/ W p:age > 60 * c:discount :D c:discount C 10
r2.c W Cart; p W Person/ W p:cat D Gold * c:discount :D c:discount C 15
f8p W Person .p:age > 60 ^ p:cat D Gold/ ^ 8c W Cart .c:discount  30/g R
f8c W Cart .c:discount  55/g .
The proof of this correctness formula by (PR4) follows the same path as Sect. 10.1.2,
only with assertions and eligibility ghost variables having an arity of two instead of
being unary. However, since the working memory contains at most one instance of
each type, no possibility of aliasing needs be considered.
10.3
Disjointness in Rule Programs
10.3.1
Disjoint Unary Rules
In [2], Hoare proposes a proof rule for disjoint parallel programs, that is, parallel
programs in which no process ever modiﬁes any variable read by another process.
The constraint on the program is strong, but the beneﬁt is a very simple proof rule,

10.3
Disjointness in Rule Programs
197
as disjointness between processes eliminates any possibility of interference (see for
example [1]).
A similar constraint on the syntax of rules that would eliminate any interference
must address the two kinds of interference described in Sect. 8.1. Combining
disjointness (deﬁned just below) and the constraint for rules to be unary gives a
sufﬁcient syntactic condition to ensure interference freedom. Intuitively, disjoint-
ness addresses cross-rule interference, while unary rules address interference due to
aliasing. For that matter, the constraint for rules to be unary may be replaced by the
constraint for the working memory to contain at most one instance of each type, as
discussed in Sect. 10.2.
Disjointness
Deﬁnition 10.1. Disjointness is deﬁned as follows:
(i) Change.r/ is the set of attributes updated by the action of a rule r.
(ii) The rules r and r0 are disjoint if no attribute modiﬁed by either of the rules
occurs in the other rule, that is, Change.r/ \ Attr.r0/ D ; and Change.r0/ \
Attr.r/ D ;.
(iii) The rule r is disjoint from the assertion ' if no attribute modiﬁed by r occurs
in ', that is, Change.r/ \ Attr.'/ D ;.
(iv) The rule programs R D fr1; : : : ; rng and R0 D fr0
1; : : : ; r0
mg are disjoint if for
i D 1; : : : ; n and j D 1; : : : ; m the rules ri and r0
j are disjoint.
(v) The rule program R
D fr1; : : : ; rng is disjoint from the set of focused
correctness formulas fpig ri fqig if for i; j D 1; : : : ; n with i ¤ j, each rule
ri is disjoint from pj and from qj .
Note that for a rule r D .Eo; ET ; g; a/ with a  o1:fr :D er, we have Change.r/ D
ffrg. As a result, the rule r and an assertion ' are disjoint if fr … Attr.'/.
Example. Consider the three rules below:
r1.c W Cart; p W Person/ W p:age > 21 * c:bonus :D 10
r2.c W Cart; p W Person/ W c:discount > 20 * p:cat :D Gold
r3.c W Cart; p W Person/ W p:age < 50 * c:discount :D 15
The rule program fr1; r2g is made of disjoint rules, but not the rule program fr2; r3g
since Change.r3/ D fdiscountg and Attr.r2/ D fcat; discountg.
Consider in addition the following correctness formulas:
fp:age D 30g r1 fc:bonus D 10g
fc:discount D 25g r2 fp:cat D Goldg
fp:age D 30g r3 fc:discount D 15g .

198
10
Specialized Proof Rules
The rule program fr1; r2g is disjoint from this set of correctness formulas, but not
the rule program fr2; r3g since discount 2 Attr.c:discount D 25/.
A Syntactic Sufﬁcient Condition for Interference Freedom
If a rule program is made of unary rules, and is disjoint from a set of valid
correctness formulas focused on the rules, then the global correctness formula
obtained by combining the individual ones holds. This property is formalized by
the following theorem.
Theorem 10.6. Let R D fr1; : : : ; rng be a rule program, and for i D 1; : : : ; n let
pi; qi 2 F.ri/ be assertions focused on the rule ri. If R is made of unary rules, and
R is disjoint from the correctness formulas fpig ri fqig, then the proof rule below is
sound:
fpig ri fqig
for i D 1; : : : ; n
n n
^
iD1
8oi W Ti pi
o
R
n n
^
iD1
8oi W Ti qi
o
(PR5)
Proof. Assume that the correctness formulas fpig ri fqig hold for i D 1; : : : ; n.
Let us prove that under the hypotheses of the theorem, the correctness formulas
fpi ^ pjg rj fpig and fqi ^ pj g rj fqig also hold, for i; j D 1; : : : ; n with i¤j.
We will then derive the conclusion of (PR5) by proof rule (PR1) introduced by
Theorem 8.2.
Consider two states s and s0 and a valuation , such that s
.rj ;/
! s0. If the rule
instance .rj; / is not applicable in s, then the state s0 is deﬁned as identical to s. As
a consequence, if s satisﬁes the precondition of either correctness formula, then s0
satisﬁes its conclusion.
If, on the other hand, the rule instance .rj; / is applicable in s, then the state s0
is deﬁned by the transition assertion for the action of rule rj, that is, hs; s0i;  ˆ Oaj .
In particular (see Sect. 5.3.3), this transition assertion gives that
hs; s0i;  ˆ
^
f 2Attrnffrj g
8o .o:f 0 D o:f / .
The disjointness hypothesis states in particular that rj is disjoint from the cor-
rectness formula fpig ri fqig, that is, the assertions pi and qi do not include any
reference to the attribute symbol frj . It results from the transition assertion above
that their truth values are the same in s and in s0. As a consequence, if s satisﬁes the
precondition of either correctness formula, then s0 satisﬁes its conclusion.
The premises of proof rule (PR1) are met: its application gives the conclusion of
(PR5), which proves the theorem.
ut
As for previous proof rules, we can note that if the sole variables of all the rules
in the program have the same type, that is, if ri D .oi; T; gi; ai/ for i D 1; : : : ; n

10.3
Disjointness in Rule Programs
199
and some type name T , then the conclusion of the proof rule can be rewritten, and
the proof rule reads
fpig ri fqig
for i D 1; : : : ; n
n
8o W T
n
^
iD1
pi.o/
o
R
n
8o W T
n
^
iD1
qi.o/
o
The two examples below illustrate that both the disjointness and unary rules
constraints are needed for proof rule (PR5) to be sound.
Example. The proof of Proposition 6.2 used the rule program R D frg made of the
only rule below:
r.c W Cart; p W Person/ W p:age D 21 * c:value :D c:value C 10
Since this program is made of only one rule, any disjointness condition is met by
construction. However the rule r is not unary.
We noted that although the correctness formula
fp:age D 21 ^ c:value D 0g r fc:value D 10g
holds for the rule r, the correctness formula
f8c W Cart 8p W Person .p:age D 21 ^ c:value D 0/g R f8c W Cart .c:value D 10/g
which would result from the application of proof rule (PR5), does not hold for
the rule program R. Indeed, an execution of the rule program can include the
application of several instances of r that share the same cart. The value of this cart
is then incremented as many times, and hence exceeds 10.
Such an aliasing on a shared cart would be made impossible by the constraint for
rules to be unary.
Example. To illustrate the role of disjointness, consider the rule program R D
fr1; r2g made of the two unary rules below, which we used as an example of unary
rules on p. 135:
r1.p W Person/W p:age > 60 * p:bonus :D p:bonus C 10
r2.p W Person/W p:cat D Gold * p:bonus :D p:bonus C 15
These rules are not disjoint with the following, otherwise valid, correctness
formulas:
fp:age D 70 ^ p:bonus D 0g r1 fp:bonus D 10g
fp:cat D Gold ^ p:bonus D 0g r2 fp:bonus D 15g .

200
10
Specialized Proof Rules
And indeed, the correctness formula
f8p W Person .p:age D 70 ^ p:cat D Gold ^ p:bonus D 0/g R
f8p W Person .p:bonus D 10 ^ p:bonus D 15/g
which would result from the application of proof rule (PR5) does not hold, since its
postcondition is false.
As a ﬁnal note, we return to the proof rule proposed in Proposition 6.2 for a rule
program made of only one rule. This proof rule did not hold in general, however it
does in the case of unary rules, as a consequence of Theorem 10.6:
fpg r fqg
f8o W T pg R f8o W T qg
where R D frg and r is unary .
(PR6)
10.3.2
Disjoint Rule Programs
Proof rule (PR5) just presented applies to rule programs and correctness formulas
where each rule in the program is disjoint from the correctness formulas focused on
all other rules. However, another occurrence of disjointness in rule programs is of
interest, namely a set of rules that can be partitioned into disjoint groups. In such a
case, a correctness formula for the whole set of rules can be derived from correctness
formulas for each group.
Theorem 10.7. Let R1 and R2 be two rule programs made of rules of arbitrary
arities, and let p1; q1; p2; q2 2 F.;/ be global assertions, such that:
(i) R1 and R2 are disjoint;
(ii) every rule in R1 is disjoint from p2 and from q2;
(iii) every rule in R2 is disjoint from p1 and from q1.
Then the following proof rule is sound:
fp1g R1 fq1g
fp2g R2 fq2g
fp1 ^ p2g R1 [ R2 fq1 ^ q2g
.
(PR7)
Proof. Consider an execution of the rule program R1 [ R2. It is composed of
applications of instances of rules taken from either R1 or R2. Due to the disjointness
hypotheses, each application of an instance of a rule from R1 updates an attribute
that occurs neither in the rules of R2, nor in p2 or q2; and vice versa.
Any execution of R1 [ R2 is therefore equivalent (in the sense given below)
to an execution where all the instances of rules from R1 are applied before all the
instances of rules from R2, with the respective orders of instances from the same
rule program left unchanged. These executions are equivalent from the viewpoint of
the updates performed by each rule instance application, and of their effects on the

References
201
Fig. 10.1 A decision table and its implementation as a rule program
applicability of other rule instances. As a consequence, they satisfy the same global
correctness formulas.
If such a reordered execution is performed from a state that satisﬁes p1^p2, then
when it reaches the state where all the instances of rules from R1 have been applied,
this state satisﬁes q1 ^ p2. All the instances of rules from R2 are then applied to get
to the ﬁnal state, which satisﬁes q1 ^ q2.
As a result, the correctness formula fp1 ^ p2g R1 [ R2 fq1 ^ q2g holds, which
proves the soundness of the proof rule.
ut
Proof rule (PR7) is particularly interesting in the case of rule programs structured
as disjoint decision tables. A decision table [3] includes a set of condition columns
and one decision column; each row in the table maps a conﬁguration of the condition
attributes onto a value to be assigned to the decision attribute. A decision table can
be naturally implemented by a set of rules that all involve the condition attributes in
their guards, and all update the decision attribute in their actions. Figure 10.1 shows
an example of a decision table, and of its implementation as a rule program.
In a set of rules implementing a decision table, the rules cannot be disjoint
from (non-trivial) correctness formulas focused on the other rules. However, a rule
program made of disjoint decision tables will beneﬁt from proof rule (PR7) to derive
a global correctness formula for the rule program from the individual correctness
formulas for the decision tables. The latter are proven with the other proof rules
presented in Part IV.
References
1. Apt, K.R., de Boer, F.S., Olderog, E.R.: Veriﬁcation of Sequential and Concurrent Programs,
3rd edn. Texts in Computer Science. Springer, Berlin (2009)
2. Hoare, C.A.R.: Parallel programming: An axiomatic approach. Comp. Lang. 1(2), 151–160
(1976)
3. Ross, R.: Principles of the Business Rules Approach. Addison-Wesley, Boston (2003)

Chapter 11
Conclusion
In this book we have proposed a set of formal tools to express and verify correctness
properties of rule programs as handled by Business Rules Management Systems
(BRMS). In Part II, we have given a formal, logic-based description of rules, rule
programs, and the meaning of their executions. In Part III, we have introduced
a Hoare logic so that correctness properties can be expressed about both rules
and rule programs. In Part IV, we have proposed a sound and relatively complete
compositional veriﬁcation method to derive correctness formulas for rule programs
from individual correctness formulas for the rules in the program.
With this contribution, our objective is to assist authors of rule programs and
developers of BRMS in precisely understanding the meaning of the programs they
write or handle, and in proving properties of their executions. In App. A, we validate
the adequacy of our formal framework to describe the Rule Static Analysis features
of the IBM Operational Decision Manager product. Our contribution could therefore
provide a basis for further developments in BRMS features.
Throughout this work, we have dealt with both local and global aspects. Rules,
and furthermore rule instances, have a local reach in that they involve only a handful
of objects. Rule programs have a global reach, as they handle a whole working
memory. Yet, the interactions between rules, as well as between rules and objects,
blur the frontier between local and global scopes. This motivates the search for a
veriﬁcation method to turn local knowledge about the rules into global information
about the rule program.
In this chapter, we review our contribution from the standpoint of this tension
between local and global approaches to rule programs as handled by Business
Rules Management Systems. We also give suggestions for possible extensions of
the present work.
B. Berstel-Da Silva, Veriﬁcation of Business Rules Programs,
DOI 10.1007/978-3-642-40038-4__11, © Springer-Verlag Berlin Heidelberg 2014
203

204
11
Conclusion
11.1
Modeling an Industrial Product
Industrial products, in our case Business Rules Management Systems, have a de
facto approach to deﬁnitions. Elaborating a model for such a product is reminiscent
of the work performed by knowledge engineers with business experts in eliciting
domain knowledge. Proposing a description on which to base the development
of formal tools includes making choices in order not to be overwhelmed with
peculiarities of the industrial product, while not losing the speciﬁcities that make
it an interesting subject of study.
The choices we made in deﬁning a rule language in Chaps. 3 and 4 included
simpliﬁcations with respect to the rule languages found in BRMS. The aspects that
were discarded are reviewed in more detail in Sect. 11.5 below. They range from the
syntax of rules to the assertion language, to the connection between rules and Java
programs.
In spite of these simpliﬁcations, important aspects of rules as handled by BRMS
were retained. These include for example the description of other semantics of
rule engines than the classical Rete-based one (see Chap. 5). Also, the rules in our
language apply to tuples of objects. As a corollary, we had to take the risk of aliasing
into account when formalizing the updates performed in rule actions. That is: if a
rule modiﬁes the color of the car of John, does it affect the car of Mary? This point
materializes in Sects. 4.4, 5.3, 8.1.2, and 9.2.2. This salient feature of rule programs
in BRMS had to be present for our formalization to be relevant.
11.2
Local vs. Global: What Is a State?
When writing a rule, or when reasoning about a rule, the world is perceived from
a local viewpoint: it includes the objects handled by the rule, either to evaluate
its guard or to execute its action. In contrast, when writing a rule program or
reasoning about it, a whole working memory is considered, and the world consists
in transitions between states of this working memory.
In Chap. 4 the deﬁnition of a state is introduced as a ﬁrst-order logic structure that
interprets each attribute symbol by a function from objects to values of the domain.
With this deﬁnition, a state is further used to describe three scopes:
(i) When reasoning about the executions of a rule program on a working memory,
as in Chap. 5, a state is considered from a global viewpoint. It provides all the
information to describe the realm of a rule program execution, namely the
values of the attributes of the objects in the working memory (a ﬁnite set of
objects, formally deﬁned with Deﬁnition 5.4).
(ii) When considering a rule in isolation, objects are accessed through a tuple
of variables (see Sect. 3.5). The objects themselves are not ﬁxed; only their
number and their types are. From this viewpoint, the rule scope is both
limited by, and extends to, all the tuples of objects that can be formed

11.3
Are Rule Programs Magical?
205
from the working memory to comply with this number and these types (see
Deﬁnition 5.3).
(iii) From the local viewpoint of a rule instance (a rule plus a tuple of objects,
see Deﬁnition 5.6), the objects are ﬁxed. The scope is then described by the
portion of a state limited to the objects contained in the instance.
Between these three scopes, which correspond to different ways of thinking of a
rule program, a tension results. This variety can cause misunderstandings between
the stakeholders in a Business Rules Management System. A precise deﬁnition of
the behavior of a rule program as handled by a BRMS, as given in Part II, is therefore
needed.
11.3
Are Rule Programs Magical?
The tension between various scopes reﬂects the opposition between authoring rules
and executing rule programs.
Due to its declarative nature, a rule program is written with the rule scope in
mind. For rule authors, the objects to consider are the ones that could match the
rule, that is, the object tuples well-typed for the rule.
On the other hand, the execution of a rule program is considered either in the
global scope of a whole working memory, or in the very local scope of the rule
instances applied.
Rule authors and rule engines thus have different approaches to a rule program.
A consequence is that the authors of rule programs do not (and cannot) always take
into account the interference cases that might occur at execution time between the
instances of the rules that compose the program.
Furthermore, getting used to imagining these interference cases requires some
training. Indeed, not only can they affect the values of attributes in the successive
states during the execution, but they can also affect whether a rule (actually some of
its instances) can be executed or not. In this, rule programs differ from parallel
programs. In the latter, interference between processes can affect the control of
the program only through mechanisms that are explicit in the program text. In rule
programs however, rule instance eligibility plays a role at the rule engine level and
is not visible in the text of rules. Examples such as the one used in the proof of
Proposition 7.1, or those presented in Sects. 5.6.2 or 10.1.1, illustrate this difference.
The potentially complex impact of interference cases in rule programs probably
contributes to their reputation of having unpredictable executions. As some clever
marketing once suggested, “when something exceeds your ability to understand
how it works, it sort of becomes magical” [1]. However, science has taught us
that computer programs are not magical, but instead can be formally described and
reasoned about. Hence the proposal of a formal tooling for rule programs.
Chapter 5 discusses the operational semantics of a rule program. This presenta-
tion introduces rule instances as building blocks of an execution, and an abstract

206
11
Conclusion
machine whose conﬁgurations, and the transitions between them, orchestrate
the applications of rule instances. The process by which a rule engine selects the rule
instance to apply among all the applicable and eligible ones is reiﬁed as the selection
strategy. The eligibility strategy represents the process by which the engine deﬁnes
which rule instances are eligible and which are not. These two strategies are
parameters of the abstract machine that deﬁnes the operational semantics given to a
rule program by a rule engine.
Isolating the selection and eligibility strategies allows us to give a description
not only of the Rete algorithm, but also of the alternatives to Rete that have been
introduced in Business Rule Management Systems in the past decade [8,10,18].
11.4
From Local to Global
Part II deﬁnes assertions, used to express properties of states and of transitions
between states.
Based on these assertions, Part III deﬁnes correctness formulas to express
properties of the execution of rules and of rule programs. Correctness formulas
are of the classical form fpg S fqg, and in Chap.6 these are given a precise (and
different) meaning when S is a rule or a rule program. This need for a distinct
deﬁnition on rules and on rule programs is another manifestation of the tension
between local and global scopes, between properties of executions of a rule and
properties of executions of a rule program.
Part IV resolves this tension with a compositional veriﬁcation method that builds
a link between the local reach of a rule and the global reach of a rule program.
The search for this veriﬁcation method is motivated by the fact that a rule program
can in general not be simulated by a parallel program. This discards the option of
reusing a veriﬁcation method for parallel programs, such as the one introduced by
Owicki and Gries [14].
Our veriﬁcation method is built on a sound and relatively complete proof rule to
derive a correctness formula for a rule program from individual correctness formulas
for the rules in the program. This proof rule is given in Chap. 9, where its soundness
and relative completeness are also proven. In addition, specialized proof rules are
given for particular classes of rule programs than can beneﬁt from simpliﬁcations.
One of them is given in Chap. 8, and serves as a presentation of the foundations of
our veriﬁcation method. The other ones are given in Chap.10. All of the proof rules
are illustrated in detail on examples.
In Sect. 9.4, the relative completeness of the most general proof rule is shown,
meaning that any valid correctness formula for a rule program can be derived from
a set of valid, interference-free correctness formulas for the rules of the program.
However, the completeness proof is not constructive and no algorithm is provided
to ﬁnd the individual interference-free correctness formulas—although practical
lemmas are given, which help checking of the premises of the proof rules or splitting
the rule program into independent chunks.

11.5
Possible Directions of Extension
207
11.5
Possible Directions of Extension
11.5.1
Propose an Algorithm
As just mentioned, we show in Sect. 9.4 that proof rule (PR2) is relatively complete,
but we provide no algorithm to ﬁnd the interference-free individual correctness
formulas for the rules in the program, from which the global correctness formula
to prove can be derived.
Studying whether such an algorithm always exists, and furthermore proposing
one, is a natural direction for a follow-up to the work in this book, and the main
enabler for a direct use of our work in a Business Rules Management System.
To this effect, simpler classes of rule programs and of correctness formulas can be
ﬁrst studied. Chapters 8 and 10 present such classes and the associated specialized
proof rules. For instance, it is relatively easy to design an algorithm for a rule
program made of two unary rules, based on the approach presented in Sect. 8.4.
11.5.2
Study More General Rule Programs
The rule language deﬁned in Chaps. 3 and 4 is a simpliﬁed version of the rule
languages found in Business Rules Management Systems. The simpliﬁcations are
found in the guards of rules, in their actions, and in the strategies used to execute
rule programs. The simpliﬁed language allowed us to nail down the speciﬁc aspects
of rule programs. It may be interesting to study the veriﬁcation of rule programs that
have fewer limitations.
The rules introduced in this book only check for the existence in working
memory of objects that satisfy the conditions included in their guards. They do not
include negative patterns, such as there is no person older than 60. More generally,
they could reason on aggregations over collections of objects.
As mentioned in Sects. 3.5.3 and 4.5.2, a rule in our language does not perform
more than a single assignment in its action. The syntax and semantics of rules
are easily extended to accomodate a sequence of assignments in a rule action [4].
Furthermore, the whole range of imperative programming constructs could be
included in rule actions [2]. However, rule languages that rely on a working memory
traditionally include speciﬁc constructs to add objects into the working memory
and remove objects from it [19]. Adding these constructs could be interesting, as it
would require reconsideration of the preservation properties of Sect. 5.2.3.
Also, rules in BRMS make extensive use, both in their guards and in their actions,
of functions that cannot be analyzed because their code is not accessible. Examples
include Java methods. We do not cover them in our formalism; this could be done
for instance by including uninterpreted functions with equality in the ﬁxed theory
 that represents the application data types (see Sect. 3.1).

208
11
Conclusion
Finally, since the veriﬁcation method described in Part IV was designed specif-
ically for the so-called one-shot strategy, we could examine how this method
extends to other strategies, possibly with modiﬁcations. Furthermore, the properties
of strategies and their inﬂuence on properties of the rule programs, in particular
termination, could be investigated [5,16,17].
11.5.3
Study Other Properties
The properties studied in the previous chapters of this book mainly address safety,
but consistency, completeness, subsumption, and impact analysis can also be
addressed, as shown in App. A.
We suggest above to extend the rule language with constructs for reasoning
on collections of objects. We could then write rules that are applicable when the
average value of the items in a shopping cart is less than 100. Naturally, such
an extension would also involve the assertion language, as they share a common
deﬁnition (see Sect. 3.3). We could then investigate how counter abstraction can
contribute [3,7,15].
The correctness formulas introduced in Chap. 4 include transition assertions.
In this book, transition assertions are used to describe properties of state pairs,
mainly during the execution of a rule action. However, global transition assertions,
introduced in Sect. 4.3.3, could also be used to express correctness formulas on rule
programs with a ﬁner grain. Consider for instance a rule program R that computes
a discount based on the age of customers. Our veriﬁcation method allows us to build
proofs for correctness formulas such as the following one:
f8c .c:age  18/g R f8c .c:discount < 75/g
The global correctness formula above states that if the rule program is executed
from a state where the ages of all customers are at least 18, then it will end in a state
where all customer discounts are under 75.
Such a correctness formula holds vacuously on working memories that also
contain customers aged less than 18. Since its focus is on adults, we would like the
correctness formula to be independent of customers under 18. In such a situation,
global transition assertions are better suited. For example, the following correctness
formula, which states that any customer (initially) aged 18 or more has a (ﬁnal)
discount lower than 75, holds even on a working memory that contains children1:
fIdg R f8c .c:0age  18 ! c:discount < 75/g .
1See p. 57 for the deﬁnition of Id.

References
209
It would thus be interesting to look at proof rules for correctness formulas built with
global transition assertions.
Section A.5 describes how IBM Operational Decision Manager addresses a
limited form of conﬂuence analysis. Several papers by Snyder and Schmolze
have studied how term-rewriting systems can be used to analyze and correct the
conﬂuence of rule programs [12,20,21].
Finally (as is natural), termination is no less important a concern for rule
programs than in other programming paradigms [5,16,17].
11.5.4
Leverage Program Analysis and Veriﬁcation Techniques
In addition to, and in some respect independently from, the techniques developed in
this book that are speciﬁc to rule programs, general techniques of program analysis
and veriﬁcation can be of interest in the veriﬁcation of rule programs. These range
from the analysis of sequential programs, to various abstraction techniques, to the
whole range of software model checking [11].
As mentioned earlier, the whole range of imperative programming constructs
could be included in rule actions [2]. In this context, the associated program analysis
and veriﬁcation techniques will be of help.
We already mentioned counter abstraction [7, 15] in the presence of constructs
for reasoning on collections of objects. More generally, such techniques as predicate
abstraction [9,13,17] or abstract interpretation [6] will play a role to provide more
expressive power to the local and global states involved in a rule program execution.
References
All URLs were successfully accessed on January 22, 2013.
1. Apple: Introducing iPad. http://movies.apple.com/media/us/ipad/2010/tours/apple-ipad-video-
us-20100127_r640-9cie.mov
2. Apt, K.R., de Boer, F.S., Olderog, E.R.: Veriﬁcation of Sequential and Concurrent Programs,
3rd edn. Texts in Computer Science. Springer, Berlin (2009)
3. Basler, G., Mazzucchi, M., Wahl, T., Kroening, D.: Symbolic counter abstraction for concurrent
software.
In: Bouajjani, A., Maler, O. (eds.) CAV. Lecture Notes in Computer Science,
vol. 5643, pp. 64–78. Springer, Berlin (2009)
4. Berstel-Da Silva, B.: Formalizing both refraction-based and sequential executions of pro-
duction rule programs. In: Bikakis, A., Giurca, A. (eds.) Rules on the Web: Research and
Applications. Lecture Notes in Computer Science, vol. 7438, pp. 47–61. Springer, Berlin
(2012)
5. Cook, B., Podelski, A., Rybalchenko, A.: Proving thread termination.
In: Ferrante, J.,
McKinley, K.S. (eds.) PLDI, pp. 320–330. ACM, New York (2007)
6. Cousot, P., Cousot, R.: Abstract interpretation: A uniﬁed lattice model for static analysis of pro-
grams by construction or approximation of ﬁxpoints. In: Proceedings of the 4th ACM SIGACT-
SIGPLAN Symposium on Principles of Programming Languages, POPL’77, pp. 238–252.
ACM, New York (1977)

210
11
Conclusion
7. Emerson, E.A., Treﬂer, R.J.: From asymmetry to full symmetry: New techniques for symmetry
reduction in model checking.
In: Pierre, L., Kropf, T. (eds.) CHARME. Lecture Notes in
Computer Science, vol. 1703, pp. 142–156. Springer, Berlin (1999)
8. Fair, Isaac, and Company: High-volume batch processing with Blaze Advisor. Com-
puter World UK (2007). http://www.computerworlduk.com/white-paper/business-process/
5092/high-volume-batch-processing-with-blaze-advisor/
9. Graf, S., Saïdi, H.: Construction of abstract state graphs with PVS. In: Grumberg, O. (ed.)
CAV. Lecture Notes in Computer Science, vol. 1254, pp. 72–83. Springer, Berlin (1997)
10. IBM: IBM Operational Decision Manager v8.0 User’s Manual (2012). http://publib.boulder.
ibm.com/infocenter/dmanager/v8r0/
11. Jhala, R., Majumdar, R.: Software model checking. ACM Comput. Surv. 41(4), 21:1–21:54
(2009)
12. Knuth, D., Bendix, P.: Simple word problems in universal algebra. In: Computational Problems
in Abstract Algebra, pp. 263–297. Pergamon Press, Oxford (1970)
13. Lahiri, S.K., Bryant, R.E., Cook, B.: A symbolic approach to predicate abstraction.
In: Hunt, W.A. Jr., Somenzi, F. (eds.) CAV. Lecture Notes in Computer Science, vol. 2725,
pp. 141–153. Springer, Berlin (2003)
14. Owicki, S.S., Gries, D.: An axiomatic proof technique for parallel programs I. Acta Informatica
6, 319–340 (1976)
15. Pnueli, A., Xu, J., Zuck, L.D.: Liveness with (0, 1, 1)-counter abstraction. In: Brinksma, E.,
Larsen, K.G. (eds.) CAV. Lecture Notes in Computer Science, vol. 2404, pp. 107–122.
Springer, Berlin (2002)
16. Podelski, A., Rybalchenko, A.: Transition invariants. In: LICS, pp. 32–41. IEEE Computer
Society, Silver Spring (2004)
17. Podelski, A., Rybalchenko, A.: Transition predicate abstraction and fair termination.
In:
Palsberg, J., Abadi, M. (eds.) POPL, pp. 132–144. ACM, New York (2005)
18. Red Hat: JBoss Rules 5 Reference Guide (2012). https://access.redhat.com/knowledge/docs/
en-US/JBoss_Enterprise_BRMS_Platform/5/html-single/JBoss_Rules_5_Reference_Guide/
index.html#Sequential_Mode
19. de Sainte Marie, C., Hallmark, G., Paschke, A.: Rule Interchange Format, Production Rule
Dialect. Recommendation, W3C (2010). http://www.w3.org/TR/rif-prd/
20. Schmolze, J.G., Snyder, W.: Using conﬂuence to control parallel production systems.
In: Kanal, L.N. (ed.) Parallel Processing for Artiﬁcial Intelligence. Elsevier Science, New York
(1994)
21. Schmolze, J.G., Snyder, W.: Detecting redundancy among production rules using term rewrite
semantics. Knowl. Base. Syst. 12(1–2), 3–11 (1999)

Appendix A
Veriﬁcation in an Industrial Business Rules
Management System
In this appendix, we apply our results to an existing industrial Business Rules
Management System, that is, the commercial BRMS sold by IBM under the name
IBM Operational Decision Manager [3,4].
IBM Operational Decision Manager contains several features related to the veri-
ﬁcation of properties of the rule programs it handles. These features are collectively
named Rule Static Analysis. We review them below, and we provide for each of
them a description of the feature as offered in the product, and a formalization using
the tools presented in the previous chapters.
This review is an opportunity to demonstrate the adequacy of our formal frame-
work, and to outline how our work could contribute to expand these features. More
generally, the task of providing a formal basis for such features is a cornerstone
to an agreement on their deﬁnitions, for example between product marketing and
development teams. In the present case, this is made possible by the introduction
of such concepts as states, rule applicability, the rule execution relation, and
correctness formulas. We start the chapter with a reminder on these concepts.
The Rule Static Analysis features were developed by a team within ILOG (now
IBM) that I led, and that included Ulrich Junker and Michel Leconte. Credit must be
given to them for their share in the design and implementation work, and to Steve
Demuth for his insight into the subject. The formalization presented in this chapter
leverages our collaboration.
A.1
Preliminaries
A.1.1
Rule Static Analysis Features
The Rule Static Analysis features in IBM Operational Decision Manager range
from program understanding to lightweight program veriﬁcation. The latter aims
at detecting coding or design errors in the rule program, while the former assists the
B. Berstel-Da Silva, Veriﬁcation of Business Rules Programs,
DOI 10.1007/978-3-642-40038-4, © Springer-Verlag Berlin Heidelberg 2014
211

212
A
Veriﬁcation in an Industrial Business Rules Management System
user in understanding or navigating the rule program by presenting rules that match
various queries.
The present appendix reviews the Rule Static Analysis features by topic. It ﬁrst
addresses the features related to the applicability of rules, then the ones that analyze
the effects of rule execution. The features covering redundancy, conﬂuence, and
completeness are then presented. Finally it describes a feature that implements a
specialized form of safety property checking.
These features are already useful to the users of the product, however none
considers the execution of a whole rule program. Some consider the consecutive
execution of two rule instances, but none go so far as to take eligibility into
account. This limitation was a motivation for the work presented in this book, with
the investigation of techniques to derive global correctness information for a rule
program from local knowledge about each rule.
From an architectural standpoint, the Rule Static Analysis features are provided
as a set of services within the IBM Operational Decision Manager product. Their
implementation relies on a logic engine that is capable of reasoning on assertions
and rules. In contrast with the execution engine, this logic engine can symbolically
perform such operations as assertion assessment or rule execution, even when some
of the object attributes have no concrete values. To this end, the logic engine relies in
turn on a constraint solver that was adapted for program analysis purposes [1,2,6].
A.1.2
Notations
All the concepts and notations used in this chapter have been introduced in the
previous ones. We review them quickly here, with references to their original
deﬁnitions.
An assertion is a ﬁrst-order, ﬂat, possibly quantiﬁed formula (Sect. 3.3).
A rule r is deﬁned in Sect. 3.5 as r D .Eo; ET ; g; a/, where:
(i) Eo D .o1; : : : ; om/ is a tuple of variables, called the rule variables.
(ii) ET D .T1; : : : ; Tm/ is a tuple of type names; together with the rule variables
they deﬁne the rule type constraint .Eo W ET /, restated below.
(iii) g is a non-quantiﬁed assertion in the rule variables, called the guard of the rule.
(iv) a is an assignment to some attribute of the object held by rule variable o1; it is
called the action of the rule.
A type constraint is a partial function that maps variables onto type names (see
Sect. 3.3.2). In the context of a rule r D .Eo; ET ; g; a/, the notation .Eo W ET / refers to
the type constraint  such that .oj/ D Tj for j D 1; : : : ; m.
A valuation is a function that maps variables onto objects (Sect. 4.1.2). A state
is a ﬁrst-order logic structure; it interprets each attribute symbol f as a function,
written f s, that provides a value for each object (Sect. 4.1.5).

A.1
Preliminaries
213
An assertion is given a truth value by a state and a valuation. For example, a
valuation  such that .p/ D Alice and a state s such that ages.Alice/ D 30 make
the assertion p:age > 21 valid. We then write s;  ˆ p:age > 21.
Section 5.2 deﬁnes the working memory as the ﬁnite set of objects matched by
rules. It also introduces the concepts of a state compliant with the type system, and
of a valuation well-typed for a given type constraint. In the present chapter, we only
consider states that are compliant with the type system, and valuations that are well-
typed for the type constraints inherited from the rules at hand, and we will thus not
mention these properties.
The execution of rules is deﬁned in Sect. 5.3, by means of rule instances, as
follows.
(i) An instance of a rule r D .Eo; ET ; g; a/ on a valuation  is the .m C 1/-tuple
.r; O1; : : : ; Om/. In this tuple, each Oj is an object that is an instance of the
type Tj, and is the image of the rule variable oj under the valuation , that is,
Oj D .oj/ for j D 1; : : : ; m. The rule instance is written .r; /.
(ii) Given a rule r D .Eo; ET ; g; a/ and a valuation , the rule instance .r; / is
applicable in a state s if we have s;  ˆ g.
(iii) When an applicable rule instance .r; / is applied in a state s, it produces a
new state s0. The new state results from the execution of the rule action on the
objects in the rule instance, as described in Sect. 5.3.3.
(iv) Finally, the execution of a rule instance .r; / from a state s to a state s0 is
written s
.r;/
! s0. The state s0 is deﬁned as the result of the application of .r; /
in s if the rule instance is applicable in this state; it is deﬁned as identical to s
otherwise.
The execution of a rule r is a relation between states that gathers the executions
of all the possible instances of the rule. This relation is written
r! and is deﬁned as
follows: given two states s and s0, we have s
r! s0 if there exists an instance .r; /
of the rule, such that s
.r;/
! s0.
In this appendix, we also use correctness formulas for rules, which are deﬁned
in Sect. 6.2. A correctness formula for a rule r is of the form fpg r fqg, where p and
q are assertions, respectively called the pre- and postconditions of the correctness
formula. The semantics of the correctness formula is the classical one: it holds if
any execution of an instance of r that starts in a state that satisﬁes p ends in a state
that satisﬁes q. That is:
fpg r fqg holds
iff
8
ˆˆˆˆˆˆˆ<
ˆˆˆˆˆˆˆ:
for any states s and s0, and any valuation ,
such that
s;  ˆ p
and
s
.r;/
! s0
we have
s0;  ˆ q .

214
A
Veriﬁcation in an Industrial Business Rules Management System
A.2
Rule Applicability
As previously mentioned, we start the review of the Rule Static Analysis features
with those related to the applicability of rules. The next sections cover the features
related to the effects of rule execution, to redundancy, conﬂuence, completeness,
and ﬁnally to safety property checking.
For each of them, we ﬁrst give an informal, business-oriented description of
the feature and of its purpose, with an example. Then we proceed to the formal
presentation of the feature, based on the formal framework introduced in Chaps. 3–6
of this book. When relevant, we conclude with a discussion.
A.2.1
Rule May Apply When. . .
This Rule Static Analysis feature is typically used when a rule-based application
is audited. In such a situation, the auditor wants to verify which rules will be
considered for application by the rule engine in some given situations.
The “rule may apply when” feature allows the auditor to check whether the guard
of a rule is compatible with an assertion that describes the situation considered.
When used as a query, the feature yields all the rules whose applicability is not
prevented by the assertion.
Example. Consider the three rules below:
r1.p W Person/W p:age  30 * p:bonus :D 10
r2.p W Person/W p:age > 30 * p:bonus :D 15
r3.p W Person/W p:cat D Gold * p:bonus :D p:bonus C 5
When asking for the rules that “may apply when p:age  60”, the user will be
answered with the rules r2 and r3. Indeed, the guard of rule r1 is p:age  30, which
cannot be valid in any context where p:age  60. On the other hand, the fact that
p:age  60 does not prevent the guard of r3, that is, p:cat D Gold, from being
valid.
Using the formal framework introduced in Part II, we can formalize the feature
as follows. For this speciﬁc feature, we present the formalization in two steps. The
ﬁrst step addresses the intuitive description of the feature as requiring compatibility
between the query and the rule guard. It also introduces the concepts participating
in the formal deﬁnition of the feature. The second step reﬁnes the ﬁrst formalization
to address pragmatic constraints that come from the object-oriented nature of our
rule programs.
The “rule may apply when” feature checks whether the guard of a rule is
compatible with a given situation. Let us write r D .Eo; ET ; g; a/ for the rule under
consideration. In the example above, r would successively represent each of r1, r2,

A.2
Rule Applicability
215
and r3. Let us also represent the situation described by the query with an assertion
'. In the example, this would give '  p:age  60.
Stating that the query assertion ' is compatible with the guard of the rule r
means that an instance of r can be found that is applicable in a state where '
holds. Choosing an instance of r consists in choosing an object for each of the
rule variables Eo D .o1; : : : ; om/ of r: this amounts to choosing a valuation. In the
example above, the rule r has only one rule variable p, so all valuations that map p
to the same object provide the same rule instance.
Once an instance of r is chosen through the choice of a valuation , it is
applicable in a state s if the rule guard holds in this state and under this valuation,
that is, if we have s;  ˆ g. The description of the feature requires the assertion '
to also hold. We can therefore propose the following formalization:
“r may apply when '”
if
there exist a state s and valuation , such that
s;  ˆ g ^ ' .
As mentioned earlier, this formalization is not correct in all cases. To perceive
this, we must take into account the remark of Sect. 3.5.1, which noted that the rule
variable names should be unique. In other words, the assertion ' that represents the
query and the rule r must have distinct variables.
Let us thus keep the notation r D .Eo; ET ; g; a/ for the rule being considered,
with Eo D .o1; : : : ; om/. And let us now write x1; : : : ; xn for the free variables in '.
In our running example, this gives '  x:age  60. With this correct notation,
the formalization above would give that “r1 may apply when '”, which is not
wanted. Indeed, the formula g ^ ' is made valid by a valuation  that maps p
and x onto distinct objects, and a state s that gives ages of 20 and 60 to .p/ and
.x/, respectively.
To avoid this, we add a constraint on the valuation: the objects considered in the
query and in the rule instance must not be totally disjoint, if the type constraints
permit. Let us hence write S1; : : : ; Sn for the respective types of the assertion
variables x1; : : : ; xn, and let us deﬁne the set U of common variable types:
U
def
D fS1; : : : ; Sng \ fT1; : : : ; Tmg
Then either the variables in the query have completely disjoint types from the
variables in the rule, and we consider that the rule “may apply”, as nothing prevents
it from doing so, or the variable types are to some degree compatible, and the
valuation must not map the variables onto totally distinct objects. This gives the
following, ﬁnal formalization of the feature:
“r may apply when '”

216
A
Veriﬁcation in an Industrial Business Rules Management System
if
there exist a state s and valuation , such that
U D ;
or
f.xi/ j Si 2 U; 1  i  ng \ f.oj/ j Tj 2 U; 1  j  mg ¤ ;
s;  ˆ g ^ ' .
A.2.2
Rule Is Never Applicable
This feature may be seen as a complement to the previous one, although historically
it came ﬁrst. Its purpose is to detect and report rules whose guard is unsatisﬁable.
Example. The rule below is “never applicable”:
r.p W Person/ W p:age  20 & p:age  80 * p:bonus :D 0
The author of this rule most probably meant it to apply in cases where the person is
below 20 or above 80.
“Never applicable” rules usually occur because of typing errors, or when the rule
author uses a very complex combination of conjunctions and disjunctions, and is
ﬁnally mistaken about its meaning. This feature can also reveal a misunderstanding
between the business users who authored the rules, and the software engineers who
designed the business rule language. Indeed, it is the translation into the technical
rule language that is analyzed, and ultimately executed.
The feature is formalized as follows. Considering a rule r D .Eo; ET ; g; a/, we say
that
“r is never applicable”
if
for any state s and valuation  we have
s;  ˆ :g
or, equivalently, if
for any state s we have
s ˆ 8Eo W ET .:g/ .
A.3
Impact Analysis
Rule Static Analysis features in the Impact Analysis category aim at exhibiting
the consequences of a state transition, such as when a rule is executed, on the
applicability of rules.

A.3
Impact Analysis
217
A.3.1
Rule May Lead to a State Where. ..
This feature focuses on transitions from a state where a given condition does not
hold, to a state where it holds. It allows the user to check whether a given rule can
cause such a transition. When used as a query, it yields all rules, some executions of
which will cause such a transition to occur.
Example. Consider the rules below:
r1.p W Person/ W p:age  25 * p:bonus :D 30
r2.p W Person/ W p:age  25 * p:cat :D Gold
r3.p W Person/ W p:bonus > 50 * p:bonus :D 50
When asking for the rules that “may lead to a state where p:bonus  20”, the
user will be answered with the rule r1. Indeed, when executed from a state where
p:bonus < 20, rule r1 will cause a transition to a state where p:bonus D 30  20,
provided p:age  25 holds in the initial state, which is possible.
In contrast, rules r2 and r3 will not be part of the answer to this query. For both
rules the reason is the same: although we can ﬁnd executions of the rule where the
ﬁnal state satisﬁes p:bonus  20, the rule cannot be credited for this. Indeed, for r2
as for r3, when the rule is executed from a state where p:bonus < 20, the execution
does not result in a state where p:bonus  20.
With r2 this is due to the fact that the rule does not update the bonus attribute.
With r3 this is due to the fact that, when p:bonus < 20, the rule is not applicable,
and hence its execution leaves the system state unchanged, as deﬁned on p. 75
and restated on p. 213. Note that non-skip executions of r3 do update the bonus
attribute, furthermore to a value greater than 20. However, these executions start in
a state where it already holds: r3 cannot be credited for p:bonus  20 holding in the
ﬁnal state.
The feature can be formalized as follows. Considering a rule r D .Eo; ET ; g; a/
and an assertion ' that represents the query, the rule
“r may lead to a state where '”
if
there exist two states s and s0 and a valuation , such that
s;  ˆ :'
and
s
.r;/
! s0
and
s0;  ˆ ' .
Note that these conditions have two direct implications. On the one hand, they imply
that s;  ˆ g. Otherwise, the execution of .r; / would be a skip, and hence s0 D s,
which makes the transition from s;  ˆ :' to s0;  ˆ ' impossible. On the other

218
A
Veriﬁcation in an Industrial Business Rules Management System
hand, they imply that ' contains an occurrence of the attribute updated in the action
of r. Otherwise, the execution of .r; / would not affect ', as noted in Sect. 5.3.3.
These remarks can serve as hints to optimize an implementation of the feature.
More importantly, this feature cannot be formalized by f:'g r f'g nor by
fg ^ :'g r f'g. Indeed, these correctness formulas would mean that any execution,
resp. any non-skip execution, of r from a state where ' does not hold results
in a state where it holds, whereas the feature only requires that at least one such
execution exists. Consider for example the rule r3 below:
r3.p W Person/ W p:age  25 & p:bonus < 15 * p:bonus :D p:bonus C 10
This rule “may lead to a state where p:bonus  20”: when executed for example
from a state where the age is 21 and the bonus is 12, it leads to a bonus of 22.
However, some executions of this rule contradict both correctness formulas
fp:bonus < 20g r3 fp:bonus  20g
fp:age  25 ^ p:bonus < 15g r3 fp:bonus  20g .
For example, consider an execution from a state where the age is 21 and the bonus
is 5. This state satisﬁes the rule guard and the negation of the query, and hence
the precondition of either correctness formula. However, the execution of the rule
from this state results in a state where the bonus is 15. As a consequence, the
postconditions of the correctness formulas do not hold in this resulting state.
This Rule Static Analysis feature is used to ﬁnd rules whose execution can end
in the state described by the query. Although this information is useful, it is only
partial, as we are interested not only in the last rule leading to the considered
state, but also in the rules that were executed before. In addition, the initial state
causing the rule executions that led to the considered state is interesting as well.
Furthermore, as discussed for the “unsafe execution” feature in Sect. A.6.1 below,
even if one rule may lead to a state where some (safety) property is violated, the
execution of subsequent rules might correct this and the ﬁnal state of the rule
program as a whole might be safe. However, a feature retrieving rule program
executions that end in a given state would require taking eligibility into account,
which is out of the current scope of the Rule Static Analysis features of IBM
Operational Decision Manager.
A.3.2
Rule May Enable. . .
This feature focuses on transitions from a state where a given rule is not applicable,
to a state where it is. It can be seen as an extension of the “may lead to a state
where...” feature just described, where the query assertion is intensionally given
by the applicability condition of a rule.

A.3
Impact Analysis
219
Example. Consider the rules below:
r1.p W Person/ W p:age  25 * p:bonus :D 30
r2.p W Person/ W p:bonus > 20 * p:cat :D Gold
The ﬁrst rule “may enable” the second one because it is possible to ﬁnd an execution
of r1 in which rule r2 changes from being inapplicable to being applicable. An
example of such an execution is from a state where the age is 20 and the bonus
is 10. In this state, r2 is not applicable. However, the execution of r1 results in a
state where the bonus is 30, and hence r2 is applicable.
Considering two rules r1 D .Eo1; ET1; g1; a1/ and r2 D .Eo2; ET2; g2; a2/, we say that
“r1 may enable r2”
if
there exist two states s and s0 and a valuation , such that
s;  ˆ :g2
and
s
.r1;/
! s0
and
s0;  ˆ g2 .
Here again, the above implies that s;  ˆ g1 and that the attribute updated in r1
occurs in g2.
A symmetric feature exists, worded “r1 may disable r2”. This feature means that
there is an execution of r1 by which rule r2 changes from being applicable to being
inapplicable. That is,
“r1 may disable r2”
if
there exist two states s and s0 and a valuation , such that
s;  ˆ g2
and
s
.r1;/
! s0
and
s0;  ˆ :g2 .
These two features can be used to build an inﬂuence graph among rules. These
features, or the inﬂuence graph, can also be used to assess the impact of a change
in the rule program: a user who intends to modify some rule will probably want
to consider adjusting the rules that are enabled or disabled by the rule about to be
modiﬁed, or that enable or disable it.
In this respect, a user who is in the process of modifying a rule r into r0 could
be interested in the rules that were enabled by r and are no longer enabled by its
modiﬁed version r0. And similarly, in the rules that were not enabled by r but are
enabled by r0, as well as the three other pairs of combinations. This goes one step
further than the “may enable” family of features, and introduces a kind of derivative
of these features.

220
A
Veriﬁcation in an Industrial Business Rules Management System
A.3.3
Rule May Become Applicable When...
This Rule Static Analysis feature is only interested in previously inapplicable rules
which becomes applicable, without focusing on the cause of this state transition,
such as a rule execution. This feature thus reports the rules that become applicable
as the result of a transition of the system, from a state where some condition does
not hold to a state where it holds.
Example. Consider the rule below:
r.p W Person/ W p:bonus > 20 * p:cat :D Gold
This rule “may become applicable when p:bonus > 30” because there exists a
transition between two states, in which on the one hand the assertion p:bonus > 30
is initially false and ﬁnally true, and on the other hand the rule r is initially not
applicable and ﬁnally is. An example of such a transition is from a state where the
bonus is 10 to a state where it is 40.
Considering a rule r D .Eo; ET ; g; a/ and an assertion ' that represents the query,
we say that
“r may become applicable when '”
if
there exist two states s and s0 and a valuation , such that
s;  ˆ :g ^ :'
and
s0;  ˆ g ^ ' .
As is visible in the formalization, and illustrated by the example, the cause of the
transition is not made explicit. It could be the execution of a rule, or of several rules.
However it must be the case in the transition that the query (p:bonus > 30 in the
example above) is initially false and it becomes true. This requirement is explicit in
the formalization of the feature, even if not in its wording.
Although apparently close to the “rule may apply when...” feature, the “rule
may become applicable when...” feature has a different usage. The “rule may apply
when...” feature is used when auditing a rule-based application, in the search for
all rules that will be considered for application in a given situation. The “rule may
become applicable when...” feature is rather used when extending a rule program,
to look for rules that deal with cases similar to the one about to be implemented.
Another way to look at the “rule may become applicable when...” feature is to
see it as a “rule may apply when...” feature that would retrieve only the rules that
actually involve the attributes that occur in the query. Indeed, a rule can change from
not being applicable to being applicable only if its guard is affected by the change
in the truth value of the query.

A.4
Redundancy
221
A.4
Redundancy
A.4.1
Equivalent Rules
This Rule Static Analysis feature detects and reports pairs of rules that are applicable
in the same working memories, and that produce the same ones when executed.
Example. The two rules below are “equivalent rules”:
r1.p W Person/ W p:age  21 * p:bonus :D p:bonus 	 2
r2.p W Person/ W p:age > 20 * p:bonus :D p:bonus C p:bonus
Whether or not it is a bug for a rule program to contain two equivalent rules is a
decision to be taken by the author of the program. In the example above, removing
one of the two equivalent rules will actually change the program behavior, since
with both rules the bonus of a matching person is multiplied by four, whereas it
would be doubled with only one of the two rules.
This feature can be formalized as follows.
r1 and r2 are “equivalent rules”
if
r1! and
r2! are the same relation.
A.4.2
Redundant Rules
This feature detects and reports pairs of rules in which the ﬁrst rule makes the second
one redundant, that is, each time the second rule is applicable the ﬁrst is as well, and
it produces at least the same effect as the second.
Example. Consider the rules below. (The rule r1 includes two assignments in its
action, which is not allowed by our rule language. We take this liberty here in order
to illustrate the feature.)
r1.p W Person/W p:age  20 * p:bonus :D p:bonus C 20 I p:cat :D Gold
r2.p W Person/W p:age > 40 * p:bonus :D p:bonus C 20
In this rule program “r1 makes r2 redundant”. Indeed, each time the rule r2 is
applicable, the rule r1 is also applicable; and when r1 is executed it performs the
same actions as r2, and possibly more.

222
A
Veriﬁcation in an Industrial Business Rules Management System
Again, whether or not it is a bug for a rule program to contain redundant rules is
a decision to be taken by the author of the program. Here, the question is whether
the bonus of persons over 40 should be increased by 20, as performed by r1, or by
40, which is the behavior of the rule program fr1; r2g. In the latter case however, the
implementation above with r2 performing only the extra work not performed by r1,
is quite error-prone.
A formalization of this feature in our framework, where only one assignment is
allowed in the action of a rule, is that
“r1 makes r2 redundant”
if
the relation
r2! is included in the relation
r1!.
In a setting where redundant rules could have distinct actions, a formalization would
require a ﬁner deﬁnition of how an update is included in another, for example based
on an order on states.
A.5
Conﬂuence and Completeness
A.5.1
Conﬂicting Rules
This Rule Static Analysis feature reports two rules as conﬂicting if they can be
applied to a common working memory, and they update a common object attribute
with two different values. As discussed further below, this feature does not address
the conﬂuence of the whole rule program, which is outside the current scope of the
IBM Operational Decision Manager product.
Example. Consider the rules below:
r1.p W Person/W p:age  60 * p:bonus :D 15
r2.p W Person/W p:cat D Gold * p:bonus :D 20
These rules are reported as “conﬂicting” because when applied to a senior gold
person, r1 grants a bonus of 15 whereas r2 grants 20.
This feature can be formalized as follows, considering two rules r1 and r2 deﬁned
as r1 D .Eo1; ET1; g1; a1/ and r2 D .Eo2; ET2; g2; a2/, with the notation of actions
introduced in Sect. 3.5.3, that is, a1  o1
1:fr1 :D er1 and a2  o2
1:fr2 :D er2.
r1 and r2 are “conﬂicting”

A.5
Conﬂuence and Completeness
223
if
there exist three states s, s0
1, and s0
2, and a valuation , such that
.o1
1/ D .o2
1/ and fr1 is the same as fr2 and s;  ˆ g1 ^ g2
and
s
.r1;/
! s0
1
and
s
.r2;/
! s0
2
and
s0
1 ¤ s0
2 .
Note that the penultimate line in the formalization above is important. A feature
implementing only the last line would suffer from the following issues: If not
imposing that both rules are applicable, the execution of either rule might reduce
to skip, in which case the ﬁnal states s0
1 and s0
2 would be different just because
one rule performed an action while the other left the initial state unchanged. If not
imposing that the attribute symbols fr1 and fr2 are the same, the feature would
report as conﬂicting any pair of rules that update distinct attributes (such as one
rule assigning a bonus and another rule updating a category), since their executions
actually have different effects. Finally, if not imposing that the actions of the rules
are performed on the same object, the feature would report as conﬂicting any pair
of rules that update the same attribute, since an execution of each rule on a different
object results in different states.
We can also note that, by the deﬁnition of rule execution (see Sect. 5.3), the last
line can be reduced to s;  ˆ er1 ¤ er2 (hence eliminating the need for states s0
1 and
s0
2 in the formalization).
Conﬂuence
The “conﬂicting rules” feature is a ﬁrst step toward checking the conﬂuence of the
rule program. A rule program R is conﬂuent if for any states s, s0
1, and s0
2, such
that s
R
! s0
1 and s
R
! s0
2 we have s0
1 D s0
2 [2]. That is, the relation
R
! is a
(partial) function. However, conﬂicting rules can exist in a conﬂuent rule program;
and furthermore a rule program can be non-conﬂuent and contain no conﬂicting
rules. The following two examples illustrate this.
Consider the two rules below, taken from the example discussed in Sect. 10.1.2.
They are conﬂicting because when executed on a senior gold person with a zero
bonus, the ﬁrst one assigns a bonus of 15 and the second one assigns a bonus of 20.
r1.p W Person/W p:age  60 * p:bonus :D p:bonus C 15
r2.p W Person/W p:cat D Gold * p:bonus :D p:bonus C 20
However, in each case the other rule is applicable, and the complete execution of
the program fr1; r2g ends with a bonus of 35.

224
A
Veriﬁcation in an Industrial Business Rules Management System
Now consider the rules below. They are not conﬂicting in the sense of the Rule
Static Analysis feature, since they do not update the same attribute.
r1.p W Person/ W p:age  60 * p:cat :D Platinum
r2.p W Person/ W p:cat D Gold * p:bonus :D 10
However they form a non-conﬂuent program. For example, on a senior gold person
with a zero bonus, both rules are applicable. The execution in which rule r1 is
applied ﬁrst ends after this application with a zero bonus and a Platinum category.
In contrast, the execution where r2 is applied ﬁrst sets the bonus to 10, then applies
r1 to update the category.
A.5.2
Completeness Analysis
This Rule Static Analysis feature reports cases for which a rule is suspected to be
missing.
Example. Consider the rule program made of the rules below:
r1.p W Person/ W p:age  20 OR p:age  60 * p:bonus :D 10
r2.p W Person/ W p:cat ¤ Gold * p:bonus :D 20
This program contains no rule to address the case where the person’s age is between
20 and 60 and their category is Gold. Whether or not this is a bug is the decision of
the author of the program, as it might be the case that for gold persons between 20
and 60, the bonus should be left unchanged.
Roughly speaking, a rule program is incomplete when there exists a working
memory in which no rule is applicable.
However, this too-simple formalization has to be reﬁned to produce reasonable
results. For example, an empty working memory would cause no rule to be
applicable. Which leads to the question of which sets of instances of each type
should be considered to get meaningful working memories. As another example of
the subject complexity, adding the rule r3 below to the rule program above is usually
not considered to make it complete, since even though there are now applicable rules
for all kinds of persons, the rule r3 can be seen as unrelated to the rules r1 and r2
because they update distinct attributes.
r3.p W Person/ W p:cat D Gold * p:cat :D Platinum
A formal deﬁnition of the completeness of a rule program that also matches the
expectations of users for Business Rules Management Systems is the subject of the
work of Ulrich Junker, as well as methods to detect and report missing cases [5].

A.6
Safety
225
A.6
Safety
A.6.1
Rule May Have an Unsafe Execution
This Rule Static Analysis feature is a particular case of safety property checking. It
is based on additional information provided by the user, in the form of properties
of attributes that are used as invariants. The “unsafe execution” feature reports rules
whose execution can violate these invariants.
Although one might imagine more general forms, the feature limits invariants
provided by the user to closed assertions of the form 8o W T ', where ' is a formula
in the sole variable o and involving only one attribute f deﬁned on the type T .
Example. Consider a setting where the following two invariants have been stated
by the user:
8p W Person .p:age  0/
8c W Cart .c:discount 2 Œ0; 100/ .
Now consider the rule below:
r1.p W Person; c W Cart/ W p:cat D Gold & c D p:cart * c:discount :D p:age
When executed on a person aged more than 100 (which is allowed by the invariant
on the age of persons), this rule will set the discount of the cart to a value forbidden
by the invariant on discounts.
The feature can be formalized as follows. Let us write I for the conjunction of
all the invariants provided by the user. Given a rule r, we say that
“r may have an unsafe execution”
if
there exist two states s and s0 and a valuation , such that
s ˆ I
and
s
.r;/
! s0
and
s0 6ˆ I .
That is, if
fIg r fIg
does not hold.
This feature can be seen as the restriction to one rule of the veriﬁcation of I as
an invariant of the rule program, that is, fIg R fIg. It is obvious that if no rule “may
have an unsafe execution”, then I is an invariant of the rule program. This can be
proven, for example, with proof rule (PR1). However, the opposite is not true. That
is, it can happen that I is an invariant of the rule program even if some rule “may

226
A
Veriﬁcation in an Industrial Business Rules Management System
have an unsafe execution”. Consider for instance the rule program R D fr1; r2g
made of the rule r1 above and the rule r2 below:
r2.c W Cart/ W c:discount > 100 * c:discount :D 100
Let us write I  8p W Person .p:age  0/ ^ 8c W Cart .c:discount 2 Œ0; 100/. As
seen in the example, the correctness formula fIg r1 fIg does not hold. However
the correctness formula fIg R fIg holds, as proven in Sect. 10.1.1 on a similar rule
program.
The “rule may have an unsafe execution” feature is a specialized form of safety
property checking. The general form can be expressed with a correctness formula
as deﬁned in Chap. 6, and veriﬁed with the method described in Part IV.
A.7
Discussion
The Rule Static Analysis features described in this chapter were developed without
the formal framework introduced in this book. Therefore, they may not be consid-
ered as a direct result of this work. Rather, their development created the need for
such a formal framework, and initiated its elaboration.
A posteriori, the fact that they can be expressed quite simply within our formal
framework demonstrates that this framework is well suited to model rule programs
as handled by Business Rule Management Systems, as well as their semantics and
their execution properties. It gives a positive indication on its ability to support the
development of further veriﬁcation features.
As mentioned previously, all the Rule Static Analysis features in the IBM
Operational Decision Manager product are limited to at most one rule execution.
Some features, such as the “conﬂicting rules” detection, consider the execution
of two rules, but these executions are only considered concurrently, as opposed to
being chained. In this, the IBM Operational Decision Manager product is not weaker
than other commercial BRMS products, which sometimes do not even go beyond
a syntax-based analysis, failing for instance to detect that the two rules given as an
example for the “equivalent rules” feature are actually equivalent.
However this limitation to one rule transition motivated our search for a
veriﬁcation method to step from the scope of one rule to the scope of a whole rule
program. Or, as we put it in Chap. 11, to resolve the tension between the local and
global approaches to rule programs in BRMS.
The area where our work can immediately contribute to the development of new
features is the expression of safety properties. Chapter 6 provides a deﬁnition for
rules and rule programs of the classic fpg S fqg formalism for safety properties.
BRMS can thus readily implement the tools to express speciﬁcations that a rule
program should comply with, although another obstacle will be user adoption due
to the additional work implied to express these speciﬁcations.

References
227
Based on these user-provided speciﬁcations, BRMS could also implement
features related to the testing of a rule program, as mentioned in Sect. 1.3. This
would include checking that the expected output for each test input conforms with
the speciﬁcation; assessing the comprehensiveness of the data sets used as input of
the tests, with respect to the data space that the program might receive as input;
or proposing new test cases to enhance this coverage. Other features proposed
in Sect. 1.3, such as run-time or historical testing, could also beneﬁt from the
explicitation of speciﬁcations.
As an application of Part IV, BRMS could implement the methods for proving
a global correctness property of a rule program from individual properties of the
rules. This would require BRMS developers either to devise an algorithm to exploit
the proof rules as illustrated in Sects. 8.4, 9.5, and 10.1.2, or to embed an interactive
theorem prover in order to perform the proofs with the assistance of the user.
References
All URLs were successfully accessed on January 22, 2013.
1. Aït-Kaci, H., Berstel, B., Junker, U., Leconte, M., Podelski, A.: Satisﬁability modulo structures
as constraint satisfaction: An introduction. In: Moreau, P.É., Blazy, S. (eds.) Dix-huitièmes
Journées Francophones des Langages Applicatifs, Aix-les-Bains (2007). http://jﬂa.inria.fr/2007/
2. Berstel, B., Leconte, M.: Using constraints to verify properties of rule programs. In: Proceedings
of the 2010 Third International Conference on Software Testing, Veriﬁcation, and Validation
Workshops, ICSTW’10, pp. 349–354. IEEE Computer Society, Silver Spring (2010)
3. IBM
Operational
Decision
Manager.
http://www.ibm.com/software/websphere/products/
business-rule-management
4. IBM: IBM Operational Decision Manager v8.0 User’s Manual (2012). http://publib.boulder.ibm.
com/infocenter/dmanager/v8r0/
5. Junker, U.: Satisﬁability techniques for detecting missing cases in incomplete business rule
projects. U.S. Patent 20110082826, IBM (2011). http://www.freepatentsonline.com/y2011/
0082826.html
6. Leconte, M., Berstel, B.: Extending a CP solver with congruences as domains for software
veriﬁcation. In: Blanc, B., Gotlieb, A., Michel, C. (eds.) Proceedings of the First Workshop on
Constraints in Software Testing, Veriﬁcation, and Analysis, pp. 22–33. IEEE Computer Society,
Silver Spring (2006)

List of Proof Rules
General Proof Rule
PR2 ................................................................................
160
Soundness: Theorem 9.2 on p. 160.
Completeness: Theorem 9.4 on p. 165.
Specialized Proof Rules
PR1 ................................................................................
137
Unary rules; eligibility does not have to be taken into account.
Soundness: Theorem 8.2 on p. 136.
Incompleteness: Theorem 8.5 on p. 146.
PR3 ................................................................................
187
Unary rules.
Soundness and completeness: Theorem 10.2 on p. 186.
PR4 ................................................................................
195
Working memory contains at most one instance of each type.
Soundness and completeness: Theorem 10.5 on p. 194.
PR5 ................................................................................
198
Rule program is disjoint from the correctness formulas for the rules.
Soundness: Theorem 10.6 on p. 198.
PR6 ................................................................................
200
Rule program contains a single, unary rule.
PR7 ................................................................................
200
Two disjoint rule programs.
Soundness: Theorem 10.7 on p. 200.
B. Berstel-Da Silva, Veriﬁcation of Business Rules Programs,
DOI 10.1007/978-3-642-40038-4, © Springer-Verlag Berlin Heidelberg 2014
229

Index
Page numbers in sans-serif face (as in 66) point to a deﬁnition. Page numbers in
bold face (as in 66) indicate a result, such as a lemma or a theorem.
A
Abstract execution machine
76, 206
conﬁguration
76, 82
consistent with unary correctness
formulas
137, 138, 140, 159
ﬁnal
94, 122, 157, 161, 165, 174
initial
77, 78, 157, 161, 172, 174
transition rule
77, 78
for the one-shot strategy
94, 138, 139
for the one-shot strategy, with eligibility
ghost variables
156, 162
transition sequence
78
Abstraction
abstract interpretation
209
counter
174, 208, 209
predicate
209
Agenda
66
head of
(see Selection)
Aggregation
207. See Abstraction, counter
Aliasing
26, 57, 133, 134, 153, 174, 178,
204
interference
(see Interference, due to
aliasing)
Applicability
13, 21, 63, 65, 71, 77, 121,
153, 213
features in IBM Operational Decision
Manager
214–220
Assertion
eligibility-aware
(see Eligibility-aware,
assertion)
as pre- or postcondition
(see Correctness
formula)
on a state
(see State assertion)
on a transition between states
(see
Transition assertion)
unary
(see State assertion, unary)
Assignment
39, 42, 60, 98, 197
proof rule for
100
semantics
57, 58, 70
well-typed
39
with ghost variables
114
Attribute
reference
35, 48
span
(see Object, attribute span)
symbol
34, 54, 56
domain
48, 67, 68
domain is ﬁnite
48, 51, 68
in expression or formula
36
interpretation
45, 48
updated in rule
197
update
57, 60, (see Assignment)
B
Business rule
6, 8, 20, 23, 48
Business Rules Management System
6, 9
market size
9
products
9–10
IBM Operational Decision Manager
9, 10, 211–227
B. Berstel-Da Silva, Veriﬁcation of Business Rules Programs,
DOI 10.1007/978-3-642-40038-4, © Springer-Verlag Berlin Heidelberg 2014
231

232
Index
C
Collection.
See Aggregation
Completeness.
See Proof rule, for rule
programs, completeness
of a knowledge base
23
relative
165
of a rule program
24, 47
features in IBM Operational Decision
Manager
224
Conclusion.
See Proof rule
Concurrent program.
See Parallel program
Conﬂict set
66, 77
resolution strategy
(see Selection
strategy)
Conﬂuence
24, 81, 223
in active databases
24
features in IBM Operational Decision
Manager
222–224
Consistency
of a knowledge base
23
in a rule program
24, 216
Constant
interpretation
47
number
(see Number)
symbol
34
symbolic value
(see Symbolic value)
Correctness formula
13, 94
eligibility-aware
(see Eligibility-aware,
correctness formula)
for a rule
95, 96, 213, 226
focused
95, 95, 96
not focused
96, 137, 143, 160, 190
precondition implies postcondition
174, 192
precondition implies rule guard
98,
101, 161, 174, 193
well-typed
95
for a rule program
102, 103
compared to correctness formula for a
rule
104–106
D
Database
active
21, 22, 24
deductive
20–23, 64
Decision table
201
Disjoint
rule and assertions
197
rule program and assertions
197, 198
rule programs
197, 200
rules
110, 197
E
ECA rule.
See Event-condition-action rule
Eligibility
13, 21, 24, 63, 65, 76, 78, 82, 117,
147, 150, 159, 173, 185, 189, 205,
212, 218
Eligibility ghost variable
150, 151, 173, 185,
189, 191
argument list
150, 160
update on rule execution
(see Transition
assertion, for eligibility ghost
variables)
Eligibility strategy
65, 66, 77, 78, 78, 82–89
as an automaton
82
identity
83, 104
one-shot
87, 93, 117, 125, 150
abstract execution machine transition
rule
(see Abstract execution
machine, transition rule, for the
one-shot strategy)
ensures termination
(see Termination,
ensured by the one-shot strategy)
equivalent to refraction on ﬁltering
programs
88
refraction
84, 84–86, 88, 104
sequential
(see Execution strategy,
sequential)
Eligibility-aware
abstract execution machine transition rule
(see Abstract execution machine,
transition rule, for the one-shot
strategy, with eligibility ghost
variables)
assertion
151
focused on a rule
151
selection of disjuncts
159, 161, 174
correctness formula
for a rule
156, 190
for a rule program
157
rule execution
156
rule instance
153
application
153
execution
153, 154
selectable
153, 155
Event-condition-action rule
21, 24, 25
Execution strategy
64, 66, 78
one-shot
93
sequential
9, 21, 84, 87, 86–88, 104, 204,
206

Index
233
Expression
35
Boolean
(see Formula, non-quantiﬁed)
containing ghost variables
114
interpretation
47–49
typing
49
well-typed
37, 37, 67
F
Field.
See Attribute
First-order logic structure
45, 46, 52, 55
domain
46
Fixed theory.
See Theory, ﬁxed
Fixed type system.
See Type system, ﬁxed
Formula
35
closed
36, 53, 102
containing ghost variables
114
correctness
(see Correctness formula)
ﬂat
38, 41, 53, 135
interpretation
46, 49–51
non-quantiﬁed
35, 41
quantiﬁed
35, 51, 53, 55, 56
typed
(see Typed quantiﬁcation)
well-typed
37, 37, 54, 67, 95
Function
ghost variable as
(see Ghost variable, is a
function)
operator
35, 49
uninterpreted
207
G
GCD in one rule
124
Ghost variable
113–115, 125, 149, 166
eligibility
(see Eligibility ghost variable)
is a function
114, (see also
Eligibility ghost variable,
argument list)
shared
122
Ghost-independent state.
See State,
ghost-independent
Guarded command
123
I
IBM ODM.
See Business Rules Management
System, products, IBM Operational
Decision Manager
ILOG BRMS.
See IBM ODM
Interference
41, 105, 131, 132, 197, 205
cross-rule
133, 137, 158
due to aliasing
105, 134, 159, 183
avoided by unary rules
136, 139, 159,
185, 186, 195
avoided by unary working memory
194, 195
freedom
premises expressing
96, 137, 143,
147, 158–160, 173, 183
iPad
205
L
Loop-free program
98–100
correctness formula for
100
derived from a rule
101, 101
proof rules for
100
N
Nondeterministic program
123, 166–167
derived from a rule program
125, 166,
167, 168
behaves like the rule program
125,
168
proof rule for
(see Proof rule, DO-OD)
semantics
saturated
64, 124, 167
standard
123
Number
33, 34, 38, 47, 48–50, 81
O
Object
25, 33, 46
attribute span
67, 67–69
preservation
70
count
(see Abstraction, counter)
equality
49, 57
as instance of a type
(see Type, instances)
tuple
71, 204
well-typed
74, 205
One-shot
eligibility strategy
(see Eligibility
strategy, one-shot)
execution strategy
(see Execution
strategy, one-shot)
Ontology.
See Semantic web
OPS5
8, 9, 24, 25, 82

234
Index
P
Parallel program
26, 116
with loop-free programs as processes
108, 112
derived from a rule program
110, 110
semantics
interleaving
108
saturated
64, 109, 116
veriﬁcation
26, 121, 131, 136, 206
with while programs as processes
116
cannot simulate rule programs
120,
132, 136, 206
derived from a rule program
117, 118
Priority
81, 82
Production system
7, 8, 21, 25, 47, 63
implementations
(see Business Rules
Management System, products)
Program
loop-free
(see Loop-free program)
nondeterministic
(see Nondeterministic
program)
parallel
(see Parallel program)
rule
(see Rule program)
while
(see while program)
Proof rule
94
ASSIGNMENT
100
CONSEQUENCE
95, 165, 166
DO-OD
127, 168
IF
100
for rule programs
137, 140, 160, 187,
187, 195, 198, 199, 200
completeness
47, 137, 146, 161, 165,
186, 194, 206
usage
141–145, 173–183, 187–193,
225
SEQUENCE
100
SKIP
100
Q
Quantiﬁcation.
See Formula, quantiﬁed
typed
(see Typed quantiﬁcation)
R
Recency
82
Refraction
82. See Eligibility strategy,
refraction
Rete
8, 21, 22, 84, 206
alternatives
(see Execution strategy,
sequential)
Rule
40, 212
action
40, 42, 59, 207
transition assertion
(see Transition
assertion, for a rule action)
arity
40, 82, 135
conﬂicting
(see Conﬂuence, features
in IBM Operational Decision
Manager)
disjoint
(see Disjoint, rules)
equivalence and redundancy
features in IBM Operational Decision
Manager
221–222
execution
75, 96, 102, 213
impact analysis features in IBM
Operational Decision Manager
216–220
guard
40, 41, 59, 82, 207, 214,
216
priority
(see Priority)
recency
(see Recency)
speciﬁcity
(see Speciﬁcity)
type constraint
40, 41
unary
135, 185, 186, 195, 198
avoids interference due to aliasing
(see Interference, due to aliasing,
avoided by unary rules)
variables
40, 40
variable types
40, 41, (see Variable,
naming)
Rule engine
8, 64, 113, 121
Rule instance
64, 65, 71, 76, 213
applicable
(see Applicability)
application
72, 77, 132, 153, 213
eligible
(see Eligibility)
execution
74, 144, 153, 213
selectable
(see Eligibility-aware, rule
instance, selectable)
well-typed
75, 77, 78, 140
Rule program
42
abstract execution machine
(see Abstract
execution machine)
conﬂuent
(see Conﬂuence)
disjoint
(see Disjoint, rule programs)
execution
78, 94, 157
ﬁnal state
(see Abstract execution
machine, conﬁguration, ﬁnal)
strategy
(see Execution strategy)
made of unary rules
(see Rule, unary)
eligibility-aware
186
operational semantics
76,
205

Index
235
proof rules for
(see Proof rule, for rule
programs)
singleton
78, 105, 200
S
Safety
25
expressed with a correctness formula
226
features in IBM Operational Decision
Manager
225–226
Selection
66, 77
Selection strategy
66, 77, 78, 81–82, 84
sequential
(see Execution strategy,
sequential)
Semantic web
8, 20–23
Sequential execution mode.
See Execution
strategy, sequential
Sequential program.
See Loop-free program;
while program
Shape analysis
25
Signature
33, 52, 54, 56, 114
Speciﬁcity
82
State
46, 52, 204, 212. See First-order logic
structure
consistent with correctness formulas
161, 161, 164
ﬁnal
(see Abstract execution machine,
conﬁguration, ﬁnal)
ghost-independent
118, 167
pair
55, 56
type-system compliant
67, 67,
69, 76, 78
preservation
70, 75, 78
State assertion
53, 212. See also Formula
eligibility-aware
(see Eligibility-aware,
assertion)
focused on a rule
54, 59, 95, 135
global
53, (see Formula, closed)
unary
135
Structure.
See First-order logic structure
Symbolic value
33, 34, 38, 47, 47
equality
49
T
Term rewriting
24, 209
Termination
83, 84, 102, 118, 208, 209
in active databases
24
in a database
24
ensured by the one-shot strategy
88, 94,
103
Testing
11, 227
Theory
as extension point
35, 38, 39
ﬁxed
33, 165, 207
Transition assertion
54–57, 208, 209
backward
56
for eligibility ghost variables
153, 155,
157, 167, 177–180
forward
55
for ghost variables
167
global
56, 208, 209
identity
56, 208
for a rule action
48, 60, 72, 73, 136, 153,
155, 177–180
Transition rule.
See Abstract execution
machine, transition rule
Type
constraint
37, 67, 96, 212
domain
37
for a rule
(see Rule, type
constraint)
deﬁnition
37, 195
are disjoint
37, 68, 196
instances
68, 68, 69
preservation
70, 76, 78
name
34, 37
Type system
37, 67
ﬁxed
33, 38
state compliant with
(see State,
type-system compliant)
Typed quantiﬁcation
51, 51, 68,
140
U
Unary
assertion
(see State assertion, unary)
rule
(see Rule, unary)
working memory
(see Working memory,
with one instance of each type)
V
Valuation
45, 47, 212
and free variables
53
and variable names
53

236
Index
well-typed
59, 70, 75, 96
preservation
70, 75
Variable
bound
36
free
36, 53, 54, 95
ghost
(see Ghost variable)
interpretation
(see Valuation)
naming
41, 43, 53, 141, 215
scalar
47
symbol
34
Variable valuation.
See Valuation
W
while program
115
Working memory
8, 25, 26, 64, 68, 68, 102,
109, 124, 174, 204, 207, 213
preservation
70, 76, 78
unary
(see Working memory, with one
instance of each type)
with one instance of each type
110, 194,
195

