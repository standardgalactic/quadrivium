LOGIC, PROGRAMMING AND
PROLOG (2ED)
Ulf Nilsson and Jan Ma luszy´nski
Copyright c⃝2000, Ulf Nilsson and Jan Ma luszy´nski. The book may be downloaded
and printed for personal use only provided that the text (1) is not altered in any way,
and (2) is accompanied by this copyright notice. The book may also be copied and
distributed in paper-form for non-proﬁt use only. No other form of distribution or
storage is permitted. In particular, it is not allowed to store and distribute the book
electronically.
This book was previously published by John Wiley & Sons Ltd. The book was origi-
nally published in 1990 with the second edition published in 1995. The copyright was
reverted back to the authors in November 2000.
For further information about updates and supplementary material please check out
the book web-site at
http://www.ida.liu.se/~ulfni/lpp
or contact the authors at ulfni@ida.liu.se and janma@ida.liu.se.


Contents
Preface
ix
I
Foundations
1
1
Preliminaries
3
1.1
Logic Formulas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3
1.2
Semantics of Formulas . . . . . . . . . . . . . . . . . . . . . . . . . . .
7
1.3
Models and Logical Consequence . . . . . . . . . . . . . . . . . . . . .
10
1.4
Logical Inference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
13
1.5
Substitutions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
14
Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
16
2
Deﬁnite Logic Programs
19
2.1
Deﬁnite Clauses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19
2.2
Deﬁnite Programs and Goals
. . . . . . . . . . . . . . . . . . . . . . .
21
2.3
The Least Herbrand Model
. . . . . . . . . . . . . . . . . . . . . . . .
24
2.4
Construction of Least Herbrand Models . . . . . . . . . . . . . . . . .
29
Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
31
3
SLD-Resolution
33
3.1
Informal Introduction
. . . . . . . . . . . . . . . . . . . . . . . . . . .
33
3.2
Uniﬁcation
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
37
3.3
SLD-Resolution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
43
3.4
Soundness of SLD-resolution
. . . . . . . . . . . . . . . . . . . . . . .
48
3.5
Completeness of SLD-resolution . . . . . . . . . . . . . . . . . . . . . .
51
3.6
Proof Trees . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
53
Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
57
v

vi
Contents
4
Negation in Logic Programming
59
4.1
Negative Knowledge . . . . . . . . . . . . . . . . . . . . . . . . . . . .
59
4.2
The Completed Program . . . . . . . . . . . . . . . . . . . . . . . . . .
61
4.3
SLDNF-resolution for Deﬁnite Programs . . . . . . . . . . . . . . . . .
65
4.4
General Logic Programs . . . . . . . . . . . . . . . . . . . . . . . . . .
67
4.5
SLDNF-resolution for General Programs . . . . . . . . . . . . . . . . .
70
4.6
Three-valued Completion
. . . . . . . . . . . . . . . . . . . . . . . . .
75
4.7
Well-founded Semantics . . . . . . . . . . . . . . . . . . . . . . . . . .
77
Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
84
5
Towards Prolog: Cut and Arithmetic
87
5.1
Cut: Pruning the SLD-tree
. . . . . . . . . . . . . . . . . . . . . . . .
87
5.2
Built-in Arithmetic . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
93
Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
97
II
Programming in Logic
99
6
Logic and Databases
101
6.1
Relational Databases . . . . . . . . . . . . . . . . . . . . . . . . . . . .
101
6.2
Deductive Databases . . . . . . . . . . . . . . . . . . . . . . . . . . . .
103
6.3
Relational Algebra vs. Logic Programs . . . . . . . . . . . . . . . . . .
104
6.4
Logic as a Query-language . . . . . . . . . . . . . . . . . . . . . . . . .
107
6.5
Special Relations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
109
6.6
Databases with Compound Terms
. . . . . . . . . . . . . . . . . . . .
114
Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
116
7
Programming with Recursive Data Structures
119
7.1
Recursive Data Structures . . . . . . . . . . . . . . . . . . . . . . . . .
119
7.2
Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
119
7.3
Diﬀerence Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
129
Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
131
8
Amalgamating Object- and Meta-language
135
8.1
What is a Meta-language? . . . . . . . . . . . . . . . . . . . . . . . . .
135
8.2
Ground Representation
. . . . . . . . . . . . . . . . . . . . . . . . . .
136
8.3
Nonground Representation . . . . . . . . . . . . . . . . . . . . . . . . .
141
8.4
The Built-in Predicate clause/2 . . . . . . . . . . . . . . . . . . . . . .
143
8.5
The Built-in Predicates assert{a,z}/1 . . . . . . . . . . . . . . . . . . .
144
8.6
The Built-in Predicate retract/1 . . . . . . . . . . . . . . . . . . . . . .
146
Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
146
9
Logic and Expert Systems
149
9.1
Expert Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
149
9.2
Collecting Proofs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
153
9.3
Query-the-user . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
154
9.4
Fixing the Car (Extended Example) . . . . . . . . . . . . . . . . . . .
155
Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
161

Contents
vii
10 Logic and Grammars
163
10.1 Context-free Grammars
. . . . . . . . . . . . . . . . . . . . . . . . . .
163
10.2 Logic Grammars . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
166
10.3 Context-dependent Languages . . . . . . . . . . . . . . . . . . . . . . .
169
10.4 Deﬁnite Clause Grammars (DCGs) . . . . . . . . . . . . . . . . . . . .
171
10.5 Compilation of DCGs into Prolog . . . . . . . . . . . . . . . . . . . . .
175
Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
176
11 Searching in a State-space
179
11.1 State-spaces and State-transitions . . . . . . . . . . . . . . . . . . . . .
179
11.2 Loop Detection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
181
11.3 Water-jug Problem (Extended Example) . . . . . . . . . . . . . . . . .
182
11.4 Blocks World (Extended Example) . . . . . . . . . . . . . . . . . . . .
183
11.5 Alternative Search Strategies
. . . . . . . . . . . . . . . . . . . . . . .
185
Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
186
III
Alternative Logic Programming Schemes
189
12 Logic Programming and Concurrency
191
12.1 Algorithm = Logic + Control . . . . . . . . . . . . . . . . . . . . . . .
191
12.2 And-parallelism . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
193
12.3 Producers and Consumers . . . . . . . . . . . . . . . . . . . . . . . . .
194
12.4 Don’t Care Nondeterminism . . . . . . . . . . . . . . . . . . . . . . . .
196
12.5 Concurrent Logic Programming . . . . . . . . . . . . . . . . . . . . . .
196
Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
202
13 Logic Programs with Equality
203
13.1 Equations and E-uniﬁcation . . . . . . . . . . . . . . . . . . . . . . . .
204
13.2 More on E-uniﬁcation . . . . . . . . . . . . . . . . . . . . . . . . . . .
205
13.3 Logic Programs with Equality . . . . . . . . . . . . . . . . . . . . . . .
207
Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
212
14 Constraint Logic Programming
213
14.1 Logic Programming with Constraints . . . . . . . . . . . . . . . . . . .
214
14.2 Declarative Semantics of CLP . . . . . . . . . . . . . . . . . . . . . . .
215
14.3 Operational Semantics of CLP
. . . . . . . . . . . . . . . . . . . . . .
216
14.4 Examples of CLP-languages . . . . . . . . . . . . . . . . . . . . . . . .
222
Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
227
15 Query-answering in Deductive Databases
229
15.1 Naive Evaluation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
230
15.2 Semi-naive Evaluation . . . . . . . . . . . . . . . . . . . . . . . . . . .
232
15.3 Magic Transformation . . . . . . . . . . . . . . . . . . . . . . . . . . .
233
15.4 Optimizations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
236
Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
239

viii
Contents
A Bibliographical Notes
241
A.1 Foundations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
241
A.2 Programming in Logic . . . . . . . . . . . . . . . . . . . . . . . . . . .
244
A.3 Alternative Logic Programming Schemes . . . . . . . . . . . . . . . . .
247
B Basic Set Theory
251
B.1
Sets
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
251
B.2
Relations
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
252
B.3
Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
252
C Answers to Selected Exercises
253
Bibliography
263
Index
277

Preface
Since the ﬁrst edition of this book the ﬁeld of logic programming has developed and
matured in many respects. This has been reﬂected by the large number of textbooks
that appeared in that period. These books usually fall into one of the following three
categories:
• books which provide a theoretical basis for logic programming;
• books which describe how to write programs in Prolog (sometimes even in par-
ticular Prolog systems);
• books which describe alternative logic programming languages like constraint
logic programming, deductive databases or concurrent logic programming.
Objectives
The main objective of both editions of this textbook is to provide a uniform account
of both the foundations of logic programming and simple programming techniques in
the programming language Prolog. The discussion of the foundations also facilitates
a systematic survey of variants of the logic programming scheme, like constraint logic
programming, deductive databases or concurrent logic programming. This book is
not primarily intended to be a theoretical handbook on logic programming. Nor is
it intended to be a book on advanced Prolog programming or on constraint logic
programming. For each of these topics there are more suitable books around. Because
of the diversity of the ﬁeld there is of course a risk that nothing substantial is said
about anything. We have tried to compensate for this risk by limiting our attention to
(what we think are) the most important areas of logic programming and by providing
the interested reader with pointers containing suggestions for further reading. As a
consequence of this:
ix

x
Preface
• the theoretical presentation is limited to well-established results and many of the
most elaborate theorems are stated only with hints or pointers to their proofs;
• most of the program examples are small programs whose prime aim is to illustrate
the principal use of logic programming and to inspire the reader to apply similar
techniques when writing “real” logic programs.
The objectives of the book have not changed since the ﬁrst edition, but its content
has been revised and updated to reﬂect the development of the ﬁeld.
Prerequisites
Like many other textbooks, this book emerged out of lecture notes which ﬁnally sta-
bilized after several years of teaching. It has been used as introductory reading in
the logic programming course for third year undergraduate students mainly from the
computer science curriculum at Link¨oping University. To take full beneﬁt from the
book, introductory courses in logic and discrete mathematics are recommended. Some
basic knowledge in automata theory may be helpful but is not strictly necessary.
Organization
The book is divided into three parts:
• Foundations;
• Programming in Logic;
• Alternative Logic Programming Schemes.
The ﬁrst part deals with the logical aspects of logic programming and tries to provide
a logical understanding of the programming language Prolog. Logic programs consist
of logical formulas and computation is the process of deduction or proof construction.
This makes logic programming fundamentally diﬀerent from most other programming
languages, largely a consequence of the fact that logic is considerably much older than
electronic computers and not restricted to the view of computation associated with
the Von Neumann machine.
The main diﬀerence between logic programming and
conventional programming languages is the declarative nature of logic. A program
written in, for instance, Fortran can, in general, not be understood without taking
operational considerations into account. That is, a Fortran program cannot be under-
stood without knowing how it is going to be executed. In contrast to that, logic has
no inherent concept of execution and logic formulas can be understood without any
notion of evaluation or execution in mind. One of the most important aims of this
book is to emphasize this distinction between logic programs and programs written in
traditional programming languages.
Chapter 1 contains a recapitulation of notions basic to logic in general. Readers
who are already well acquainted with predicate logic can without problem omit this
chapter. The chapter discusses concepts related both to model- and proof-theory of

Preface
xi
predicate logic including notions like language, interpretation, model, logical conse-
quence, logical inference, soundness and completeness. The ﬁnal section introduces
the concept of substitution which is needed in subsequent chapters.
Chapter 2 introduces the restricted language of deﬁnite programs and discusses the
model-theoretic consequences of restricting the language. By considering only deﬁnite
programs it suﬃces to limit attention to so-called Herbrand interpretations making
the model-theoretic treatment of the language much simpler than for the case of full
predicate logic.
The operational semantics of deﬁnite programs is described in Chapter 3. The
starting point is the notion of uniﬁcation. A uniﬁcation algorithm is provided and
proved correct. Some of its properties are discussed. The uniﬁcation algorithm is the
basis for SLD-resolution which is the only inference rule needed for deﬁnite programs.
Soundness and completeness of this rule are discussed.
The use of negation in logic programming is discussed in Chapter 4. It introduces
the negation-as-ﬁnite-failure rule used to implement negation in most Prolog systems
and also provides a logical justiﬁcation of the rule by extending the user’s program with
additional axioms. Thereafter deﬁnite programs are generalized to general programs.
The resulting proof-technique of this language is called SLDNF-resolution and is a
result of combining SLD-resolution with the negation-as-ﬁnite-failure rule. Results
concerning soundness of both the negation-as-ﬁnite-failure rule and SLDNF-resolution
are discussed. Finally some alternative approaches based on three-valued logics are
described to explain alternative views of negation in logic programming.
The ﬁnal chapter of Part I introduces two notions available in existing Prolog
systems. Cut is introduced as a mechanism for reducing the overhead of Prolog com-
putations. The main objective of this section is to illustrate the eﬀect of cut and to
point out cases when its use is motivated, and cases of misuse of cut. The conclusion
is that cut should be used with great care and can often be avoided. For example,
cut is not used in subsequent chapters, where many example programs are presented.
The second section of Chapter 5 discusses the use of predeﬁned arithmetic predicates
in Prolog and provides a logical explanation for them.
The second part of the book is devoted to some simple, but yet powerful, program-
ming techniques in Prolog. The goal is not to study implementation-speciﬁc details of
diﬀerent Prolog systems nor is it our aim to develop real-size or highly optimized pro-
grams. The intention is rather to emphasize two basic principles which are important
to appreciate before one starts considering writing “real” programs:
• logic programs are used to describe relations, and
• logic programs have both a declarative and an operational meaning. In order to
write good programs it is important to keep both aspects in mind.
Part II of the book is divided into several chapters which relate logic programming to
diﬀerent ﬁelds of computer science while trying to emphasize these two points.
Chapter 6 describes logic programming from a database point of view. It is shown
how logic programs can be used, in a coherent way, as a framework for representing
relational databases and for retrieving information out of them.
The chapter also
contains some extensions to traditional databases. For instance, the ability to deﬁne
inﬁnite relations and the use of structured data.

xii
Preface
Chapter 7 demonstrates techniques for deﬁning relations on recursive data-struc-
tures, in particular on lists. The objective is to study how recursive data-structures give
rise to recursive programs which can be deﬁned in a uniform way by means of inductive
deﬁnitions. The second part of the chapter presents an alternative representation of
lists and discusses advantages and disadvantages of this new representation.
Chapter 8 introduces the notion of meta- and object-language and illustrates how to
use logic programs for describing SLD-resolution. The ability to do this in a simple way
facilitates some very powerful programming techniques. The chapter also introduces
some (controversial) built-in predicates available in most Prolog implementations.
Chapter 9 is a continuation of Chapter 8.
It demonstrates how to extend an
interpreter from Chapter 8 into a simple expert-system shell. The resulting program
can be used as a starting point for developing a full-scale expert system.
Historically one of the main objectives for implementing Prolog was its application
for natural language processing.
Chapter 10 shows how to describe grammars in
Prolog, starting from context-free grammars. Thereafter larger classes of languages are
considered. The last two sections introduce the notion of Deﬁnite Clause Grammars
(DCGs) commonly used for describing both natural and artiﬁcial languages in Prolog.
The last chapter of Part II elaborates on results from Chapter 6. The chapter
demonstrates simple techniques for solving search-problems in state-transition graphs
and raises some of the diﬃculties which are inherently associated with such problems.
The ﬁnal part of the book gives a brief introduction to some extensions of the logic
programming paradigm, which are still subject of active research.
Chapter 12 describes a class of languages commonly called concurrent logic pro-
gramming languages. The underlying execution model of these languages is based on
concurrent execution. It allows therefore for applications of logic programming for de-
scription of concurrent processes. The presentation concentrates on the characteristic
principles of this class of languages, in particular on the mechanisms used to enforce
synchronization between parallel processes and the notion of don’t care nondetermin-
ism.
Chapter 13 discusses an approach to integration of logic programming with func-
tional programming based on the use of equations. The notion of E-uniﬁcation (uni-
ﬁcation modulo a set E of equations) is introduced and properties of E-uniﬁcation
algorithms are discussed. Finally it is shown how to generalize the notion of SLD-
resolution to incorporate E-uniﬁcation instead of “ordinary” uniﬁcation.
Chapter 14 concerns the use of constraints in logic programming. The constraint
logic programming scheme has attracted a great many people because of its generality,
elegance and expressive power. A rigorous semantical framework is brieﬂy described.
The main ideas are illustrated using examples from several constraint domains.
The ﬁnal chapter of Part III concerns the optimization of queries to deductive
databases. The chapter provides an alternative to SLD-resolution as the inference
mechanism in a query-answering system and discusses the principal idea of several
optimizations described in the literature.
In addition the book contains three appendices. The ﬁrst of them provides biblio-
graphical remarks to most of the chapters of the book including suggestions for further
reading. The second appendix contains a brief account of set theoretic notions used
throughout the book and the ﬁnal appendix contains solutions and hints for some of
the exercises which are available in the main text.

Preface
xiii
What is new in the second edition?
The second edition of the book contains one new chapter on query optimization in de-
ductive databases (Chapter 15). Three chapters have also been substantially revised:
The presentation of uniﬁcation in Chapter 3 has been modiﬁed to facilitate better
integration with Chapters 13 (equational logic programming) and 14 (constraint logic
programming). To simplify the presentation of constraint logic programming, Chapter
3 also introduces the notion of derivation trees. Secondly, chapter 4 on negation has
been completely revised. In particular, the deﬁnition of SLDNF-resolution has been
improved and two new sections have been added covering alternative approaches to
negation — three-valued completion and well-founded semantics. Finally, Chapter 14
has been substantially extended providing the theoretical foundation of the constraint
logic programming scheme and several examples of constraint logic programming lan-
guages. Most of the remaining chapters have undergone minor modiﬁcations; new
examples and exercises have been included, the bibliographical remarks have been
updated and an appendix on basic set theory has been added.
Acknowledgements
The authors would like to thank a number of persons for their involvement in the
course of writing the ﬁrst and second edition of this book. In particular, Roland Bol,
Staﬀan Bonnier, Lars Degerstedt, W lodzimierz Drabent and all other members of the
Logic Programming Laboratory. We are also indebted to students, who lived through
draft versions of the book and provided invaluable feedback. Thanks are also due to
Gu Xinli, Jalal Maleki, Mirka Mi lkowska, Simin Nadjm-Tehrani, Torbj¨orn N¨aslund
and Linda Smith who devoted much of their time reading parts of the manuscript.
Needless to say, the remaining ﬂaws are to be attributed to the authors.
Our deepest gratitude also to Roslyn Meredith and Rosemary Altoft at John Wi-
ley, and the anonymous referees whose comments inﬂuenced the ﬁnal structure and
contents of both editions of the book.
Finally we should mention that the material presented in this book is closely related
to our research interests.
We gratefully acknowledge the ﬁnancial support of our
research projects by the Swedish Research Council for Engineering Sciences (TFR)
and by Link¨oping University.
Link¨oping, Sweden
Ulf Nilsson
June 1995
Jan Ma luszy´nski

xiv
Preface

PART I
FOUNDATIONS
1


Chapter 1
Preliminaries
1.1
Logic Formulas
When describing some state of aﬀairs in the real world we often use declarative1 sen-
tences like:
(i) “Every mother loves her children”
(ii) “Mary is a mother and Tom is Mary’s child”
By applying some general rules of reasoning such descriptions can be used to draw
new conclusions. For example, knowing (i) and (ii) it is possible to conclude that:
(iii) “Mary loves Tom”
A closer inspection reveals that (i) and (ii) describe some universe of persons and
some relations between these individuals — like “. . . is a mother”, “. . . is a child
of . . . ” or the relation “. . . loves . . . ” — which may or may not hold between the
persons.2 This example reﬂects the principal idea of logic programming — to describe
possibly inﬁnite relations on objects and to apply the programming system in order
to draw conclusions like (iii).
For a computer to deal with sentences like (i)–(iii) the syntax of the sentences must be
precisely deﬁned. What is even more important, the rules of reasoning — like the one
1The notion of declarative sentence has its roots in linguistics. A declarative sentence is a com-
plete expression of natural language which is either true or false, as opposed to e.g. imperative or
interrogative sentences (commands and questions). Only declarative sentences can be expressed in
predicate logic.
2Some people would probably argue that “being a mother” is not a relation but rather a property.
However, for the sake of uniformity properties will be called relations and so will statements which
relate more than two objects (like “. . . is the sum of . . . and . . . ”).
3

4
Chapter 1:
Preliminaries
which permits inferring (iii) from (i) and (ii) — must be carefully formalized. Such
problems have been studied in the ﬁeld of mathematical logic. This chapter surveys
basic logical concepts that are used later on in the book to relate logic programming
and logic. (For basic set theoretic notions see Appendix B.)
The ﬁrst concept considered is that of logic formulas which provide a formalized syn-
tax for writing sentences like (i)–(iii). Such sentences refer to individuals in some
world and to relations between those individuals. Therefore the starting point is an
assumption about the alphabet of the language. It must include:
• symbols for denoting individuals (e.g. the symbol tom may be used to denote
the person Tom of our example). Such symbols will be called constants;
• symbols for denoting relations (loves, mother, child of ). Such symbols are called
predicate symbols.
Every predicate symbol has an associated natural number, called its arity. The relation
named by an n-ary predicate symbol is a set of n-tuples of individuals; in the example
above the predicate symbol loves denotes a set of pairs of persons, including the pair
Mary and Tom, denoted by the constants mary and tom.
With the alphabet of constants, predicate symbols and some auxiliary characters,
sentences of natural language like “Mary loves Tom” can be formalized as formulas
like loves(mary, tom).
The formal language should also provide the possibility of expressing sentences like
(i) which refers to all elements of the described “world”. This sentence says that “for
all individuals X and Y, if X is a mother and Y is a child of X then X loves Y”. For
this purpose, the language of logic introduces the symbol of universal quantiﬁer “∀”
( to be read “for every” or “for all”) and the alphabet of variables. A variable is a
symbol that refers to an unspeciﬁed individual, like X and Y above. Now the sentences
(i)–(iii) can be formalized accordingly:
∀X (∀Y ((mother(X) ∧child of (Y, X)) ⊃loves(X, Y )))
(1)
mother(mary) ∧child of (tom, mary)
(2)
loves(mary, tom)
(3)
The symbols “∧” and “⊃” are examples of logical connectives which are used to com-
bine logic formulas — “∧” reads “and” and is called conjunction whereas “⊃” is called
implication and corresponds to the “if-then” construction above. Parentheses are used
to disambiguate the language.
Another connective which will be used frequently is that for expressing negation.
It is denoted by “¬” (with reading “not”). For example the sentence “Tom does not
love Mary” can be formalized as the formula:
¬loves(tom, mary)
In what follows the symbol “∃” is also sometimes used. It is called the existential quan-
tiﬁer and reads “there exists”. The existential quantiﬁer makes it possible to express
the fact that, in the world under consideration, there exists at least one individual

1.1 Logic Formulas
5
which is in a certain relation with some other individuals. For example the sentence
“Mary has a child” can be formalized as the formula:
∃X child of (X, mary)
On occasion the logical connectives “∨” and “↔” are used. They formalize the con-
nectives “or” and “if and only if” (“iﬀ”).
So far individuals have been represented only by constants. However it is often
the case that in the world under consideration, some “individuals” are “composed
objects”. For instance, in some world it may be necessary to discuss relations between
families as well as relations between persons. In this case it would be desirable to
refer to a given family by a construction composed of the constants identifying the
members of the family (actually what is needed is a function that constructs a family
from its members). The language of logic oﬀers means of solving this problem. It is
assumed that its alphabet contains symbols called functors that represent functions
over object domains. Every functor has assigned a natural number called its arity,
which determines the number of arguments of the function. The constants can be
seen as 0-ary functors. Assume now that there is a ternary3 functor family, a binary
functor child and a constant none. The family consisting of the parents Bill and Mary
and children Tom and Alice can now be represented by the construction:
family(bill, mary, child(tom, child(alice, none)))
Such a construction is called a compound term.
The above informal discussion based on examples of simple declarative sentences gives
motivation for introducing basic constructs of the language of symbolic logic. The kind
of logic used here is called predicate logic. Next a formal deﬁnition of this language
is given. For the moment we specify only the form of allowed sentences, while the
meaning of the language will be discussed separately. Thus the deﬁnition covers only
the syntax of the language separated from its semantics.
From the syntactic point of view logic formulas are ﬁnite sequences of symbols such
as variables, functors and predicate symbols. There are inﬁnitely many of them and
therefore the symbols are usually represented by ﬁnite strings of primitive characters.
The representation employed in this book usually conforms to that speciﬁed in the
ISO standard of the programming language Prolog (1995). Thus, the alphabet of the
language of predicate logic consists of the following classes of symbols:
• variables which will be written as alphanumeric identiﬁers beginning with capital
letters (sometimes subscriped). Examples of variables are X, Xs, Y, X7, . . .;
• constants which are numerals or alphanumeric identiﬁers beginning with lower-
case letters. Examples of constants are x, alf , none, 17, . . .;
• functors which are alphanumeric identiﬁers beginning with lower-case letters
and with an associated arity > 0. To emphasize the arity n of a functor f it is
sometimes written in the form f/n;
3Usually the terms nullary, unary, binary and ternary are used instead of 0-ary, 1-ary, 2-ary and
3-ary.

6
Chapter 1:
Preliminaries
• predicate symbols which are usually alphanumeric identiﬁers starting with lower-
case letters and with an associated arity ≥0. The notation p/n is used also for
predicate symbols;
• logical connectives which are ∧(conjunction), ¬ (negation), ↔(logical equiva-
lence), ⊃(implication) and ∨(disjunction);
• quantiﬁers — ∀(universal) and ∃(existential);
• auxiliary symbols like parentheses and commas.
No syntactic distinction will be imposed between constants, functors and predicate
symbols.
However, as a notational convention we use a, b, c, . . . (with or without
adornments) to denote constants and X, Y, Z, . . . to denote variables. Functors are
denoted f, g, h, . . . and p, q, r, . . . are used to denote predicate symbols.
Constants
are sometimes viewed as nullary functors. Notice also that the sets of functors and
predicate symbols may contain identical identiﬁers with diﬀerent arities.
Sentences of natural language consist of words where objects of the described world
are represented by nouns. In the formalized language of predicate logic objects will
be represented by strings called terms whose syntax is deﬁned as follows:
Deﬁnition 1.1 (Terms) The set T of terms over a given alphabet A is the smallest
set such that:
• any constant in A is in T ;
• any variable in A is in T ;
• if f/n is a functor in A and t1, . . . , tn ∈T then f(t1, . . . , tn) ∈T .
In this book terms are typically denoted by s and t.
In natural language only certain combinations of words are meaningful sentences.
The counterpart of sentences in predicate logic are special constructs built from terms.
These are called formulas or well-formed formulas (wﬀ) and their syntax is deﬁned as
follows:
Deﬁnition 1.2 (Formulas) Let T be the set of terms over the alphabet A. The set
F of wﬀ(with respect to A) is the smallest set such that:
• if p/n is a predicate symbol in A and t1, . . . , tn ∈T then p(t1, . . . , tn) ∈F;
• if F and G ∈F then so are (¬F), (F ∧G), (F ∨G), (F ⊃G) and (F ↔G);
• if F ∈F and X is a variable in A then (∀XF) and (∃XF) ∈F.
Formulas of the form p(t1, . . . , tn) are called atomic formulas (or simply atoms).
In order to adopt a syntax similar to that of Prolog, formulas in the form (F ⊃G)
are instead written in the form (G ←F). To simplify the notation parentheses will be
removed whenever possible. To avoid ambiguity it will be assumed that the connectives

1.2 Semantics of Formulas
7
have a binding-order where ¬, ∀and ∃bind stronger than ∨, which in turn binds
stronger than ∧followed by ⊃(i.e. ←) and ﬁnally ↔. Thus (a ←((¬b) ∧c)) will
be simpliﬁed into a ←¬b ∧c. Sometimes binary functors and predicate symbols are
written in inﬁx notation (e.g. 2 ≤3).
Let F be a formula. An occurrence of the variable X in F is said to be bound
either if the occurrence follows directly after a quantiﬁer or if it appears inside the
subformula which follows directly after “∀X” or “∃X”. Otherwise the occurrence is
said to be free. A formula with no free occurrences of variables is said to be closed. A
formula/term which contains no variables is called ground.
Let X1, . . . , Xn be all variables that occur free in a formula F. The closed formula
of the form ∀X1(. . . (∀Xn F) . . .) is called the universal closure of F and is denoted
∀F. Similarly, ∃F is called the existential closure of F and denotes the formula F
closed under existential quantiﬁcation.
1.2
Semantics of Formulas
The previous section introduced the language of formulas as a formalization of a class
of declarative statements of natural language. Such sentences refer to some “world”
and may be true or false in this world. The meaning of a logic formula is also deﬁned
relative to an “abstract world” called an (algebraic) structure and is also either true or
false. In other words, to deﬁne the meaning of formulas, a formal connection between
the language and a structure must be established. This section discusses the notions
underlying this idea.
As stated above declarative statements refer to individuals, and concern relations
and functions on individuals. Thus the mathematical abstraction of the “world”, called
a structure, is a nonempty set of individuals (called the domain) with a number of
relations and functions deﬁned on this domain. For example the structure referred
to by the sentences (i)–(iii) may be an abstraction of the world shown in Figure 1.1.
Its domain consists of three individuals — Mary, John and Tom. Moreover, three
relations will be considered on this set: a unary relation, “. . . is a mother”, and two
binary relations, “. . . is a child of . . . ” and “. . . loves . . . ”. For the sake of simplicity
it is assumed that there are no functions in the structure.
The building blocks of the language of formulas are constants, functors and pred-
icate symbols.
The link between the language and the structure is established as
follows:
Deﬁnition 1.3 (Interpretation) An interpretation ℑof an alphabet A is a non-
empty domain D (sometimes denoted |ℑ|) and a mapping that associates:
• each constant c ∈A with an element cℑ∈D;
• each n-ary functor f ∈A with a function fℑ: Dn →D;
• each n-ary predicate symbol p ∈A with a relation pℑ⊆D × · · · × D
|
{z
}
n
.
The interpretation of constants, functors and predicate symbols provides a basis for
assigning truth values to formulas of the language. The meaning of a formula will be

8
Chapter 1:
Preliminaries
Mary
Tom
John
Figure 1.1: A family structure
deﬁned as a function on meanings of its components. First the meaning of terms will
be deﬁned since they are components of formulas. Since terms may contain variables
the auxiliary notion of valuation is needed. A valuation ϕ is a mapping from variables
of the alphabet to the domain of an interpretation. Thus, it is a function which assigns
objects of an interpretation to variables of the language. By the notation ϕ[X 7→t]
we denote the valuation which is identical to ϕ except that ϕ[X 7→t] maps X to t.
Deﬁnition 1.4 (Semantics of terms) Let ℑbe an interpretation, ϕ a valuation
and t a term. Then the meaning ϕℑ(t) of t is an element in |ℑ| deﬁned as follows:
• if t is a constant c then ϕℑ(t) := cℑ;
• if t is a variable X then ϕℑ(t) := ϕ(X);
• if t is of the form f(t1, . . . , tn), then ϕℑ(t) := fℑ(ϕℑ(t1), . . . , ϕℑ(tn)).
Notice that the meaning of a compound term is obtained by applying the function
denoted by its main functor to the meanings of its principal subterms, which are
obtained by recursive application of this deﬁnition.
Example 1.5 Consider a language which includes the constant zero, the unary func-
tor s and the binary functor plus. Assume that the domain of ℑis the set of the
natural numbers (N) and that:
zeroℑ
:=
0

1.2 Semantics of Formulas
9
sℑ(x)
:=
1 + x
plusℑ(x, y)
:=
x + y
That is, zero denotes the natural number 0, s denotes the successor function and plus
denotes the addition function. For the interpretation ℑand a valuation ϕ such that
ϕ(X) := 0 the meaning of the term plus(s(zero), X) is obtained as follows:
ϕℑ(plus(s(zero), X))
=
ϕℑ(s(zero)) + ϕℑ(X)
=
(1 + ϕℑ(zero)) + ϕ(X)
=
(1 + 0) + 0
=
1
The meaning of a formula is a truth value. The meaning depends on the components of
the formula which are either (sub-) formulas or terms. As a consequence the meanings
of formulas also rely on valuations. In the following deﬁnition the notation ℑ|=ϕ Q
is used as a shorthand for the statement “Q is true with respect to ℑand ϕ” and
ℑ̸|=ϕ Q is to be read “Q is false w.r.t. ℑand ϕ”.
Deﬁnition 1.6 (Semantics of wﬀ’s) Let ℑbe an interpretation, ϕ a valuation and
Q a formula. The meaning of Q w.r.t. ℑand ϕ is deﬁned as follows:
• ℑ|=ϕ p(t1, . . . , tn) iﬀ⟨ϕℑ(t1), . . . , ϕℑ(tn)⟩∈pℑ;
• ℑ|=ϕ (¬F) iﬀℑ̸|=ϕ F;
• ℑ|=ϕ (F ∧G) iﬀℑ|=ϕ F and ℑ|=ϕ G;
• ℑ|=ϕ (F ∨G) iﬀℑ|=ϕ F or ℑ|=ϕ G (or both);
• ℑ|=ϕ (F ⊃G) iﬀℑ|=ϕ G whenever ℑ|=ϕ F;
• ℑ|=ϕ (F ↔G) iﬀℑ|=ϕ (F ⊃G) and ℑ|=ϕ (G ⊃F);
• ℑ|=ϕ (∀XF) iﬀℑ|=ϕ[X7→t] F for every t ∈|ℑ|;
• ℑ|=ϕ (∃XF) iﬀℑ|=ϕ[X7→t] F for some t ∈|ℑ|.
The semantics of formulas as deﬁned above relies on the auxiliary concept of valuation
that associates variables of the formula with elements of the domain of the interpre-
tation. It is easy to see that the truth value of a closed formula depends only on
the interpretation. It is therefore common practice in logic programming to consider
all formulas as being implicitly universally quantiﬁed. That is, whenever there are
free occurrences of variables in a formula its universal closure is considered instead.
Since the valuation is of no importance for closed formulas it will be omitted when
considering the meaning of such formulas.

10
Chapter 1:
Preliminaries
Example 1.7 Consider Example 1.5 again. Assume that the language contains also
a unary predicate symbol p and that:
pℑ:= {⟨1⟩, ⟨3⟩, ⟨5⟩, ⟨7⟩, . . .}
Then the meaning of the formula p(zero) ∧p(s(zero)) in the interpretation ℑis de-
termined as follows:
ℑ|= p(zero) ∧p(s(zero))
iﬀ
ℑ|= p(zero) and ℑ|= p(s(zero))
iﬀ
⟨ϕℑ(zero)⟩∈pℑand ⟨ϕℑ(s(zero))⟩∈pℑ
iﬀ
⟨ϕℑ(zero)⟩∈pℑand ⟨1 + ϕℑ(zero)⟩∈pℑ
iﬀ
⟨0⟩∈pℑand ⟨1⟩∈pℑ
Now ⟨1⟩∈pℑbut ⟨0⟩̸∈pℑso the whole formula is false in ℑ.
Example 1.8 Consider the interpretation ℑthat assigns:
• the persons Tom, John and Mary of the structure in Figure 1.1 to the constants
tom, john and mary;
• the relations “. . . is a mother”, “. . . is a child of . . . ” and “. . . loves . . . ” of
the structure in Figure 1.1 to the predicate symbols mother/1, child of /2 and
loves/2.
Using the deﬁnition above it is easy to show that the meaning of the formula:
∀X ∃Y loves(X, Y )
is false in ℑ(since Tom does not love anyone), while the meaning of formula:
∃X ∀Y ¬loves(Y, X)
is true in ℑ(since Mary is not loved by anyone).
1.3
Models and Logical Consequence
The motivation for introducing the language of formulas was to give a tool for describ-
ing “worlds” — that is, algebraic structures. Given a set of closed formulas P and an
interpretation ℑit is natural to ask whether the formulas of P give a proper account
of this world. This is the case if all formulas of P are true in ℑ.
Deﬁnition 1.9 (Model) An interpretation ℑis said to be a model of P iﬀevery
formula of P is true in ℑ.
Clearly P has inﬁnitely many interpretations. However, it may happen that none of
them is a model of P. A trivial example is any P that includes the formula (F ∧¬F)
where F is an arbitrary (closed) formula. Such sets of formulas are called unsatisﬁable.
When using formulas for describing “worlds” it is necessary to make sure that every
description produced is satisﬁable (that is, has at least one model), and in particular
that the world being described is a model of P.
Generally, a satisﬁable set of formulas has (inﬁnitely) many models. This means
that the formulas which properly describe a particular “world” of interest at the same
time describe many other worlds.

1.3 Models and Logical Consequence
11
C
B
A
Figure 1.2: An alternative structure
Example 1.10 Figure 1.2 shows another structure which can be used as a model
of the formulas (1) and (2) of Section 1.1 which were originally used to describe the
world of Figure 1.1. In order for the structure to be a model the constants tom, john
and mary are interpreted as the boxes ‘A’, ‘B’ and ‘C’ respectively — the predicate
symbols loves, child of and mother are interpreted as the relations “. . . is above . . . ”,
“. . . is below . . . ” and “. . . is on top”.
Our intention is to use the description of the world of interest to obtain more infor-
mation about this world. This new information is to be represented by new formulas
not explicitly included in the original description. An example is the formula (3) of
Section 1.1 which is obtained from (1) and (2). In other words, for a given set P of
formulas other formulas (say F) which are also true in the world described by P are
searched for. Unfortunately, P itself has many models and does not uniquely identify
the “intended model” which was described by P. Therefore it must be required that
F is true in every model of P to guarantee that it is also true in the particular world
of interest. This leads to the fundamental concept of logical consequence.
Deﬁnition 1.11 (Logical consequence) Let P be a set of closed formulas. A closed
formula F is called a logical consequence of P (denoted P |= F) iﬀF is true in every
model of P.
Example 1.12 To illustrate this notion by an example it is shown that (3) is a logical
consequence of (1) and (2). Let ℑbe an arbitrary interpretation. If ℑis a model of
(1) and (2) then:
ℑ|= ∀X(∀Y ((mother(X) ∧child of (Y, X)) ⊃loves(X, Y )))
(4)
ℑ|= mother(mary) ∧child of (tom, mary)
(5)
For (4) to be true it is necessary that:
ℑ|=ϕ mother(X) ∧child of (Y, X) ⊃loves(X, Y )
(6)
for any valuation ϕ — speciﬁcally for ϕ(X) = maryℑand ϕ(Y ) = tomℑ. However,
since these individuals are denoted by the constants mary and tom it must also hold
that:
ℑ|= mother(mary) ∧child of (tom, mary) ⊃loves(mary, tom)
(7)
Finally, for this to hold it follows that loves(mary, tom) must be true in ℑ(by Deﬁ-
nition 1.6 and since (5) holds by assumption). Hence, any model of (1) and (2) is also
a model of (3).

12
Chapter 1:
Preliminaries
This example shows that it may be rather diﬃcult to prove that a formula is a logical
consequence of a set of formulas. The reason is that one has to use the semantics of
the language of formulas and to deal with all models of the formulas.
One possible way to prove P |= F is to show that ¬F is false in every model of P,
or put alternatively, that the set of formulas P ∪{¬F} is unsatisﬁable (has no model).
The proof of the following proposition is left as an exercise.
Proposition 1.13 (Unsatisﬁability)
Let P be a set of closed formulas and F a
closed formula. Then P |= F iﬀP ∪{¬F} is unsatisﬁable.
It is often straightforward to show that a formula F is not a logical consequence of the
set P of formulas. For this, it suﬃces to give a model of P which is not a model of F.
Example 1.14 Let P be the formulas:
∀X(r(X) ⊃(p(X) ∨q(X)))
(8)
r(a) ∧r(b)
(9)
To prove that p(a) is not a logical consequence of P it suﬃces to consider an inter-
pretation ℑwhere |ℑ| is the set consisting of the two persons “Adam” and “Eve” and
where:
aℑ:= Adam
bℑ:= Eve
pℑ:= {⟨Eve⟩}
% the property of being female
qℑ:= {⟨Adam⟩}
% the property of being male
rℑ:= {⟨Adam⟩, ⟨Eve⟩}
% the property of being a person
Clearly, (8) is true in ℑsince “any person is either female or male”. Similarly (9) is
true since “both Adam and Eve are persons”. However, p(a) is false in ℑsince Adam
is not a female.
Another important concept based on the semantics of formulas is the notion of logical
equivalence.
Deﬁnition 1.15 (Logical equivalence) Two formulas F and G are said to be log-
ically equivalent (denoted F ≡G) iﬀF and G have the same truth value for all
interpretations ℑand valuations ϕ.
Next a number of well-known facts concerning equivalences of formulas are given. Let
F and G be arbitrary formulas and H(X) a formula with zero or more free occurrences
of X. Then:
¬¬F
≡
F
F ⊃G
≡
¬F ∨G
F ⊃G
≡
¬G ⊃¬F
F ↔G
≡
(F ⊃G) ∧(G ⊃F)
¬(F ∨G)
≡
¬F ∧¬G
DeMorgan’s law
¬(F ∧G)
≡
¬F ∨¬G
DeMorgan’s law
¬∀XH(X)
≡
∃X¬H(X)
DeMorgan’s law
¬∃XH(X)
≡
∀X¬H(X)
DeMorgan’s law

1.4 Logical Inference
13
and if there are no free occurrences of X in F then:
∀X(F ∨H(X)) ≡F ∨∀XH(X)
Proofs of these equivalences are left as an exercise to the reader.
1.4
Logical Inference
In Section 1.1 the sentence (iii) was obtained by reasoning about the sentences (i)
and (ii). The language was then formalized and the sentences were expressed as the
logical formulas (1), (2) and (3). With this formalization, reasoning can be seen as a
process of manipulation of formulas, which from a given set of formulas, like (1) and
(2), called the premises, produces a new formula called the conclusion, for instance
(3). One of the objectives of the symbolic logic is to formalize “reasoning principles”
as formal re-write rules that can be used to generate new formulas from given ones.
These rules are called inference rules. It is required that the inference rules correspond
to correct ways of reasoning — whenever the premises are true in any world under
consideration, any conclusion obtained by application of an inference rule should also
be true in this world. In other words it is required that the inference rules produce
only logical consequences of the premises to which they can be applied. An inference
rule satisfying this requirement is said to be sound.
Among well-known inference rules of predicate logic the following are frequently
used:
• Modus ponens or elimination rule for implication: This rule says that whenever
formulas of the form F and (F ⊃G) belong to or are concluded from a set of
premises, G can be inferred. This rule is often presented as follows:
F
F ⊃G
G
(⊃E)
• Elimination rule for universal quantiﬁer: This rule says that whenever a formula
of the form (∀XF) belongs to or is concluded from the premises a new formula
can be concluded by replacing all free occurrences of X in F by some term t
which is free for X (that is, all variables in t remain free when X is replaced by
t: for details see e.g. van Dalen (1983) page 68). This rule is often presented as
follows:
∀XF(X)
F(t)
(∀E)
• Introduction rule for conjunction: This rule states that if formulas F and G
belong to or are concluded from the premises then the conclusion F ∧G can be
inferred. This is often stated as follows:
F
G
F ∧G
(∧I)
Soundness of these rules can be proved directly from the deﬁnition of the semantics of
the language of formulas.

14
Chapter 1:
Preliminaries
Their use can be illustrated by considering the example above. The premises are:
∀X (∀Y (mother(X) ∧child of (Y, X) ⊃loves(X, Y )))
(10)
mother(mary) ∧child of (tom, mary)
(11)
Elimination of the universal quantiﬁer in (10) yields:
∀Y (mother(mary) ∧child of (Y, mary) ⊃loves(mary, Y ))
(12)
Elimination of the universal quantiﬁer in (12) yields:
mother(mary) ∧child of (tom, mary) ⊃loves(mary, tom)
(13)
Finally modus ponens applied to (11) and (13) yields:
loves(mary, tom)
(14)
Thus the conclusion (14) has been produced in a formal way by application of the
inference rules. The example illustrates the concept of derivability. As observed, (14)
is obtained from (10) and (11) not directly, but in a number of inference steps, each
of them adding a new formula to the initial set of premises. Any formula F that
can be obtained in that way from a given set P of premises is said to be derivable
from P. This is denoted by P ⊢F. If the inference rules are sound it follows that
whenever P ⊢F, then P |= F. That is, whatever can be derived from P is also a
logical consequence of P. An important question related to the use of inference rules is
the problem of whether all logical consequences of an arbitrary set of premises P can
also be derived from P. In this case the set of inference rules is said to be complete.
Deﬁnition 1.16 (Soundness and Completeness)
A set of inference rules are
said to be sound if, for every set of closed formulas P and every closed formula F,
whenever P ⊢F it holds that P |= F. The inference rules are complete if P ⊢F
whenever P |= F.
A set of premises is said to be inconsistent if any formula can be derived from the
set. Inconsistency is the proof-theoretic counterpart of unsatisﬁability, and when the
inference system is both sound and complete the two are frequently used as synonyms.
1.5
Substitutions
The chapter is concluded with a brief discussion on substitutions — a concept funda-
mental to forthcoming chapters. Formally a substitution is a mapping from variables
of a given alphabet to terms in this alphabet. The following syntactic deﬁnition is
often used instead:
Deﬁnition 1.17 (Substitutions) A substitution is a ﬁnite set of pairs of terms
{X1/t1, . . . , Xn/tn} where each ti is a term and each Xi a variable such that Xi ̸= ti
and Xi ̸= Xj if i ̸= j. The empty substitution is denoted ϵ.

1.5 Substitutions
15
The application Xθ of a substitution θ to a variable X is deﬁned as follows:
Xθ
:=

t if X/t ∈θ.
X otherwise
In what follows let Dom({X1/t1, . . . , Xn/tn}) denote the set {X1, . . . , Xn}. Also let
Range({X1/t1, . . . , Xn/tn}) be the set of all variables in t1, . . . , tn. Thus, for variables
not included in Dom(θ), θ behaves as the identity mapping. It is natural to extend
the domain of substitutions to include also terms and formulas. In other words, it is
possible to apply a substitution to an arbitrary term or formula in the following way:
Deﬁnition 1.18 (Application) Let θ be a substitution {X1/t1, . . . , Xn/tn} and E
a term or a formula. The application Eθ of θ to E is the term/formula obtained by
simultaneously replacing ti for every free occurrence of Xi in E (1 ≤i ≤n). Eθ is
called an instance of E.
Example 1.19
p(f(X, Z), f(Y, a)){X/a, Y/Z, W/b}
=
p(f(a, Z), f(Z, a))
p(X, Y ){X/f(Y ), Y/b}
=
p(f(Y ), b)
It is also possible to compose substitutions:
Deﬁnition 1.20 (Composition) Let θ and σ be two substitutions:
θ
:=
{X1/s1, . . . , Xm/sm}
σ
:=
{Y1/t1, . . . , Yn/tn}
The composition θσ of θ and σ is obtained from the set:
{X1/s1σ, . . . , Xm/smσ, Y1/t1, . . . , Yn/tn}
by removing all Xi/siσ for which Xi = siσ (1 ≤i ≤m) and by removing those Yj/tj
for which Yj ∈{X1, . . . , Xm} (1 ≤j ≤n).
It is left as an exercise to prove that the above syntactic deﬁnition of composition
actually coincides with function composition (see exercise 1.13).
Example 1.21
{X/f(Z), Y/W}{X/a, Z/a, W/Y } = {X/f(a), Z/a, W/Y }
A kind of substitution that will be of special interest are the so-called idempotent
substitutions:
Deﬁnition 1.22 (Idempotent substitution) A substitution θ is said to be idem-
potent iﬀθ = θθ.

16
Chapter 1:
Preliminaries
It can be shown that a substitution θ is idempotent iﬀDom(θ) ∩Range(θ) =
?. The
proof of this is left as an exercise and so are the proofs of the following properties:
Proposition 1.23 (Properties of substitutions) Let θ, σ and γ be substitutions
and let E be a term or a formula. Then:
• E(θσ) = (Eθ)σ
• (θσ)γ = θ(σγ)
• ϵθ = θϵ = θ
Notice that composition of substitutions is not commutative as illustrated by the
following example:
{X/f(Y )}{Y/a} = {X/f(a), Y/a} ̸= {Y/a}{X/f(Y )} = {Y/a, X/f(Y )}
Exercises
1.1 Formalize the following sentences of natural language as formulas of predicate
logic:
a)
Every natural number has a successor.
b)
Nothing is better than taking a nap.
c)
There is no such thing as negative integers.
d)
The names have been changed to protect the innocent.
e)
Logic plays an important role in all areas of computer science.
f)
The renter of a car pays the deductible in case of an accident.
1.2 Formalize the following sentences of natural language into predicate logic:
a)
A bronze medal is better than nothing.
b)
Nothing is better than a gold medal.
c)
A bronze medal is better than a gold medal.
1.3 Prove Proposition 1.13.
1.4 Prove the equivalences in connection with Deﬁnition 1.15.
1.5 Let F := ∀X ∃Y p(X, Y ) and G := ∃Y ∀Xp(X, Y ).
State for each of the
following four formulas whether it is satisﬁable or not. If it is, give a model
with the natural numbers as domain, if it is not, explain why.
(F ∧G)
(F ∧¬G)
(¬F ∧¬G)
(¬F ∧G)
1.6 Let F and G be closed formulas. Show that F ≡G iﬀ{F} |= G and {G} |= F.
1.7 Show that P is unsatisﬁable iﬀthere is some closed formula F such that P |= F
and P |= ¬F.

Exercises
17
1.8 Show that the following three formulas are satisﬁable only if the interpretation
has an inﬁnite domain
∀X¬p(X, X)
∀X∀Y ∀Z(p(X, Y ) ∧p(Y, Z) ⊃p(X, Z))
∀X∃Y p(X, Y )
1.9 Let F be a formula and θ a substitution. Show that ∀F |= ∀(Fθ).
1.10 Let P1, P2 and P3 be sets of closed formulas. Redeﬁne |= in such a way that
P1 |= P2 iﬀevery formula in P2 is a logical consequence of P1. Then show that
|= is transitive — that is, if P1 |= P2 and P2 |= P3 then P1 |= P3.
1.11 Let P1 and P2 be sets of closed formulas. Show that if P1 ⊆P2 and P1 |= F
then P2 |= F.
1.12 Prove Proposition 1.23.
1.13 Let θ and σ be substitutions. Show that the composition θσ is equivalent to
function composition of the mappings denoted by θ and σ.
1.14 Show that a substitution θ is idempotent iﬀDom(θ) ∩Range(θ) =
?.
1.15 Which of the following statements are true?
• if σθ = δθ then σ = δ
• if θσ = θδ then σ = δ
• if σ = δ then σθ = δθ

18
Chapter 1:
Preliminaries

Chapter 2
Deﬁnite Logic Programs
2.1
Deﬁnite Clauses
The idea of logic programming is to use a computer for drawing conclusions from
declarative descriptions. Such descriptions — called logic programs — consist of ﬁnite
sets of logic formulas. Thus, the idea has its roots in the research on automatic theorem
proving. However, the transition from experimental theorem proving to applied logic
programming requires improved eﬃciency of the system. This is achieved by introduc-
ing restrictions on the language of formulas — restrictions that make it possible to use
the relatively simple and powerful inference rule called the SLD-resolution principle.
This chapter introduces a restricted language of deﬁnite logic programs and in the
next chapter their computational principles are discussed. In subsequent chapters a
more unrestrictive language of so-called general programs is introduced. In this way
the foundations of the programming language Prolog are presented.
To start with, attention will be restricted to a special type of declarative sentences
of natural language that describe positive facts and rules. A sentence of this type
either states that a relation holds between individuals (in case of a fact), or that a
relation holds between individuals provided that some other relations hold (in case of
a rule). For example, consider the sentences:
(i) “Tom is John’s child”
(ii) “Ann is Tom’s child”
(iii) “John is Mark’s child”
(iv) “Alice is John’s child”
(v) “The grandchild of a person is a child of a child of this person”
19

20
Chapter 2:
Deﬁnite Logic Programs
These sentences may be formalized in two steps. First atomic formulas describing
facts are introduced:
child(tom, john)
(1)
child(ann, tom)
(2)
child(john, mark)
(3)
child(alice, john)
(4)
Applying this notation to the ﬁnal sentence yields:
“For all X and Y , grandchild(X, Y ) if
there exists a Z such that child(X, Z) and child(Z, Y )”
(5)
This can be further formalized using quantiﬁers and the logical connectives “⊃” and
“∧”, but to preserve the natural order of expression the implication is reversed and
written “←”:
∀X ∀Y (grandchild(X, Y ) ←∃Z (child(X, Z) ∧child(Z, Y )))
(6)
This formula can be transformed into the following equivalent forms using the equiv-
alences given in connection with Deﬁnition 1.15:
∀X ∀Y (grandchild(X, Y ) ∨¬ ∃Z (child(X, Z) ∧child(Z, Y )))
∀X ∀Y (grandchild(X, Y ) ∨∀Z ¬ (child(X, Z) ∧child(Z, Y )))
∀X ∀Y ∀Z (grandchild(X, Y ) ∨¬ (child(X, Z) ∧child(Z, Y )))
∀X ∀Y ∀Z (grandchild(X, Y ) ←(child(X, Z) ∧child(Z, Y )))
We now focus attention on the language of formulas exempliﬁed by the example above.
It consists of formulas of the form:
A0 ←A1 ∧· · · ∧An
(where n ≥0)
or equivalently:
A0 ∨¬A1 ∨· · · ∨¬An
where A0, . . . , An are atomic formulas and all variables occurring in a formula are
(implicitly) universally quantiﬁed over the whole formula. The formulas of this form
are called deﬁnite clauses. Facts are deﬁnite clauses where n = 0. (Facts are sometimes
called unit-clauses.) The atomic formula A0 is called the head of the clause whereas
A1 ∧· · · ∧An is called its body.
The initial example shows that deﬁnite clauses use a restricted form of existential
quantiﬁcation — the variables that occur only in body literals are existentially quan-
tiﬁed over the body (though formally this is equivalent to universal quantiﬁcation on
the level of clauses).

2.2 Deﬁnite Programs and Goals
21
2.2
Deﬁnite Programs and Goals
The logic formulas derived above are special cases of a more general form, called clausal
form.
Deﬁnition 2.1 (Clause) A clause is a formula ∀(L1 ∨· · · ∨Ln) where each Li is an
atomic formula (a positive literal) or the negation of an atomic formula (a negative
literal).
As seen above, a deﬁnite clause is a clause that contains exactly one positive literal.
That is, a formula of the form:
∀(A0 ∨¬A1 ∨· · · ∨¬An)
The notational convention is to write such a deﬁnite clause thus:
A0 ←A1, . . . , An
(n ≥0)
If the body is empty (i.e. if n = 0) the implication arrow is usually omitted. Alter-
natively the empty body can be seen as a nullary connective
which is true in every
interpretation. (Symmetrically there is also a nullary connective
 which is false in
every interpretation.) The ﬁrst kind of logic program to be discussed are programs
consisting of a ﬁnite number of deﬁnite clauses:
Deﬁnition 2.2 (Deﬁnite programs) A deﬁnite program is a ﬁnite set of deﬁnite
clauses.
To explain the use of logic formulas as programs, a general view of logic programming
is presented in Figure 2.1. The programmer attempts to describe the intended model
by means of declarative sentences (i.e. when writing a program he has in mind an
algebraic structure, usually inﬁnite, whose relations are to interpret the predicate
symbols of the program). These sentences are deﬁnite clauses — facts and rules. The
program is a set of logic formulas and it may have many models, including the intended
model (Figure 2.1(a)). The concept of intended model makes it possible to discuss
correctness of logic programs — a program P is incorrect iﬀthe intended model is not
a model of P. (Notice that in order to prove programs to be correct or to test programs
it is necessary to have an alternative description of the intended model, independent
of P.)
The program will be used by the computer to draw conclusions about the intended
model (Figure 2.1(b)). However, the only information available to the computer about
the intended model is the program itself. So the conclusions drawn must be true in any
model of the program to guarantee that they are true in the intended model (Figure
2.1(c)). In other words — the soundness of the system is a necessary condition. This
will be discussed in Chapter 3. Before that, attention will be focused on the practical
question of how a logic program is to be used.
The set of logical consequences of a program is inﬁnite.
Therefore the user is
expected to query the program selectively for various aspects of the intended model.
There is an analogy with relational databases — facts explicitly describe elements
of the relations while rules give intensional characterization of some other elements.

22
Chapter 2:
Deﬁnite Logic Programs
model
model
intended
model
P
(a)
P ⊢F
(b)
model
model
intended
model
F
(c)
Figure 2.1: General view of logic programming

2.2 Deﬁnite Programs and Goals
23
Since the rules may be recursive, the relation described may be inﬁnite in contrast
to the traditional relational databases. Another diﬀerence is the use of variables and
compound terms. This chapter considers only “queries” of the form:
∀(¬(A1 ∧· · · ∧Am))
Such formulas are called deﬁnite goals and are usually written as:
←A1, . . . , Am
where Ai’s are atomic formulas called subgoals. The goal where m = 0 is denoted
1
and called the empty goal. The logical meaning of a goal can be explained by referring
to the equivalent universally quantiﬁed formula:
∀X1 · · · ∀Xn ¬(A1 ∧· · · ∧Am)
where X1, . . . , Xn are all variables that occur in the goal. This is equivalent to:
¬ ∃X1 · · · ∃Xn (A1 ∧· · · ∧Am)
This, in turn, can be seen as an existential question and the system attempts to deny
it by constructing a counter-example. That is, it attempts to ﬁnd terms t1, . . . , tn such
that the formula obtained from A1 ∧· · · ∧Am when replacing the variable Xi by ti
(1 ≤i ≤n), is true in any model of the program, i.e. to construct a logical consequence
of the program which is an instance of a conjunction of all subgoals in the goal.
By giving a deﬁnite goal the user selects the set of conclusions to be constructed.
This set may be ﬁnite or inﬁnite. The problem of how the machine constructs it will
be discussed in Chapter 3. The section is concluded with some examples of queries
and the answers obtained to the corresponding goals in a typical Prolog system.
Example 2.3 Referring to the family-example in Section 2.1 the user may ask the
following queries (with the corresponding goal):
Query
Goal
“Is Ann a child of Tom?”
←child(ann, tom)
“Who is a grandchild of Ann?”
←grandchild(X, ann)
“Whose grandchild is Tom?”
←grandchild(tom, X)
“Who is a grandchild of whom?”
←grandchild(X, Y )
The following answers are obtained:
• Since there are no variables in the ﬁrst goal the answer is simply “yes”;
• Since the program contains no information about grandchildren of Ann the an-
swer to the second goal is “no one” (although most Prolog implementations
would answer simply “no”;
1Of course, formally it is not correct to write ←A1, . . . , Am since “←” should have a formula
also on the left-hand side. The problem becomes even more evident when m = 0 because then the
right-hand side disappears as well. However, formally the problem can be viewed as follows — a
deﬁnite goal has the form ∀(¬(A1 ∧· · · ∧Am)) which is equivalent to ∀( ∨¬(A1 ∧· · · ∧Am ∧)). A
nonempty goal can thus be viewed as the formula ∀( ←(A1 ∧· · · ∧Am)). The empty goal can be
viewed as the formula
 ←
which is equivalent to
.

24
Chapter 2:
Deﬁnite Logic Programs
• Since Tom is the grandchild of Mark the answer is X = mark in reply to the
third goal;
• The ﬁnal goal yields three answers:
X = tom
Y = mark
X = alice
Y = mark
X = ann
Y = john
It is also possible to ask more complicated queries, for example “Is there a person
whose grandchildren are Tom and Alice?”, expressed formally as:
←grandchild(tom, X), grandchild(alice, X)
whose (expected) answer is X = mark.
2.3
The Least Herbrand Model
Deﬁnite programs can only express positive knowledge — both facts and rules say
which elements of a structure are in a relation, but they do not say when the relations
do not hold. Therefore, using the language of deﬁnite programs, it is not possible to
construct contradictory descriptions, i.e. unsatisﬁable sets of formulas. In other words,
every deﬁnite program has a model. This section discusses this matter in more detail.
It shows also that every deﬁnite program has a well deﬁned least model. Intuitively
this model reﬂects all information expressed by the program and nothing more.
We ﬁrst focus attention on models of a special kind, called Herbrand models. The
idea is to abstract from the actual meanings of the functors (here, constants are treated
as 0-ary functors) of the language. More precisely, attention is restricted to the inter-
pretations where the domain is the set of variable-free terms and the meaning of every
ground term is the term itself. After all, it is a common practice in databases — the
constants tom and ann may represent persons but the database describes relations
between the persons by handling relations between the terms (symbols) no matter
whom they represent.
The formal deﬁnition of such domains follows and is illustrated by two simple
examples.
Deﬁnition 2.4 (Herbrand universe, Herbrand base)
Let A be an alphabet
containing at least one constant symbol. The set UA of all ground terms constructed
from functors and constants in A is called the Herbrand universe of A. The set BA of
all ground, atomic formulas over A is called the Herbrand base of A.
The Herbrand universe and Herbrand base are often deﬁned for a given program. In
this case it is assumed that the alphabet of the program consists of exactly those
symbols which appear in the program. It is also assumed that the program contains
at least one constant (since otherwise, the domain would be empty).
Example 2.5 Consider the following deﬁnite program P:

2.3 The Least Herbrand Model
25
odd(s(0)).
odd(s(s(X))) ←odd(X).
The program contains one constant (0) and one unary functor (s). Consequently the
Herbrand universe looks as follows:
UP = {0, s(0), s(s(0)), s(s(s(0))), . . .}
Since the program contains only one (unary) predicate symbol (odd) it has the follow-
ing Herbrand base:
BP = {odd(0), odd(s(0)), odd(s(s(0))), . . .}
Example 2.6 Consider the following deﬁnite program P:
owns(owner(corvette), corvette).
happy(X) ←owns(X, corvette).
In this case the Herbrand universe UP consists of the set:
{corvette, owner(corvette), owner(owner(corvette)), . . .}
and the Herbrand base BP of the set:
{owns(s, t) | s, t ∈UP } ∪{happy(s) | s ∈UP }
Deﬁnition 2.7 (Herbrand interpretations) A Herbrand interpretation of P is an
interpretation ℑsuch that:
• the domain of ℑis UP ;
• for every constant c, cℑis deﬁned to be c itself;
• for every n-ary functor f the function fℑis deﬁned as follows
fℑ(x1, . . . , xn) := f(x1, . . . , xn)
That is, the function fℑapplied to n ground terms composes them into the
ground term with the principal functor f;
• for every n-ary predicate symbol p the relation pℑis a subset of U n
P (the set of
all n-tuples of ground terms).
Thus Herbrand interpretations have predeﬁned meanings of functors and constants
and in order to specify a Herbrand interpretation it suﬃces to list the relations as-
sociated with the predicate symbol. Hence, for an n-ary predicate symbol p and a
Herbrand interpretation ℑthe meaning pℑof p consists of the following set of n-
tuples: {⟨t1, . . . , tn⟩∈U n
P | ℑ|= p(t1, . . . , tn)}.

26
Chapter 2:
Deﬁnite Logic Programs
Example 2.8 One possible interpretation of the program P in Example 2.5 is oddℑ=
{⟨s(0)⟩, ⟨s(s(s(0)))⟩}. A Herbrand interpretation can be speciﬁed by giving a family
of such relations (one for every predicate symbol).
Since the domain of a Herbrand interpretation is the Herbrand universe the relations
are sets of tuples of ground terms. One can deﬁne all of them at once by specifying
a set of labelled tuples, where the labels are predicate symbols. In other words: A
Herbrand interpretation ℑcan be seen as a subset of the Herbrand base (or a possibly
inﬁnite relational database), namely {A ∈BP | ℑ|= A}.
Example 2.9 Consider some alternative Herbrand interpretations for P of Example
2.5.
ℑ1
:=
?
ℑ2
:=
{odd(s(0))}
ℑ3
:=
{odd(s(0)), odd(s(s(0)))}
ℑ4
:=
{odd(sn(0)) | n ∈{1, 3, 5, 7, . . .}}
=
{odd(s(0)), odd(s(s(s(0)))), . . .}
ℑ5
:=
BP
Deﬁnition 2.10 (Herbrand model) A Herbrand model of a set of (closed) formulas
is a Herbrand interpretation which is a model of every formula in the set.
It turns out that Herbrand interpretations and Herbrand models have two attractive
properties. The ﬁrst is pragmatic: In order to determine if a Herbrand interpretation
ℑis a model of a universally quantiﬁed formula ∀F it suﬃces to check if all ground
instances of F are true in ℑ. For instance, to check if A0 ←A1, . . . , An is true in ℑit
suﬃces to show that if (A0 ←A1, . . . , An)θ is a ground instance of A0 ←A1, . . . , An
and A1θ, . . . , Anθ ∈ℑthen A0θ ∈ℑ.
Example 2.11 Clearly ℑ1 cannot be a model of P in Example 2.5 as it is not a
Herbrand model of odd(s(0)).
However, ℑ2, ℑ3, ℑ4, ℑ5 are all models of odd(s(0))
since odd(s(0)) ∈ℑi, (2 ≤i ≤5).
Now, ℑ2 is not a model of odd(s(s(X))) ←odd(X) since there is a ground instance
of the rule — namely odd(s(s(s(0)))) ←odd(s(0)) — such that all premises are true:
odd(s(0)) ∈ℑ2, but the conclusion is false: odd(s(s(s(0)))) ̸∈ℑ2.
By a similar
reasoning it follows that ℑ3 is not a model of the rule.
However, ℑ4 is a model also of the rule; let odd(s(s(t))) ←odd(t) be any ground
instance of the rule where t ∈UP . Clearly, odd(s(s(t))) ←odd(t) is true if odd(t) ̸∈ℑ4
(check with Deﬁnition 1.6). Furthermore, if odd(t) ∈ℑ4 then it must also hold that
odd(s(s(t))) ∈ℑ4 (cf. the the deﬁnition of ℑ4 above) and hence odd(s(s(t))) ←odd(t)
is true in ℑ4. Similar reasoning proves that ℑ5 is also a model of the program.
The second reason for focusing on Herbrand interpretations is more theoretical. For
the restricted language of deﬁnite programs, it turns out that in order to determine
whether an atomic formula A is a logical consequence of a deﬁnite program P it suﬃces
to check that every Herbrand model of P is also a Herbrand model of A.

2.3 The Least Herbrand Model
27
Theorem 2.12 Let P be a deﬁnite program and G a deﬁnite goal. If ℑ′ is a model
of P ∪{G} then ℑ:= {A ∈BP | ℑ′ |= A} is a Herbrand model of P ∪{G}.
Proof : Clearly, ℑis a Herbrand interpretation. Now assume that ℑ′ is a model and
that ℑis not a model of P ∪{G}. In other words, there exists a ground instance of a
clause or a goal in P ∪{G}:
A0 ←A1, . . . , Am
(m ≥0)
which is not true in ℑ(A0 =
 in case of a goal).
Since this clause is false in ℑthen A1, . . . , Am are all true and A0 is false in ℑ.
Hence, by the deﬁnition of ℑwe conclude that A1, . . . , Am are true and A0 is false
in ℑ′. This contradicts the assumption that ℑ′ is a model. Hence ℑis a model of
P ∪{G}.
Notice that the form of P in Theorem 2.12 is restricted to deﬁnite programs. In the
general case, nonexistence of a Herbrand model of a set of formulas P does not mean
that P is unsatisﬁable. That is, there are sets of formulas P which do not have a
Herbrand model but which have other models.2
Example 2.13 Consider the formulas {¬p(a), ∃Xp(X)} where UP := {a} and BP :=
{p(a)}. Clearly, there are only two Herbrand interpretations — the empty set and BP
itself. The former is not a model of the second formula. The latter is a model of the
second formula but not of the ﬁrst.
However, it is not very hard to ﬁnd a model of the formulas — let the domain be
the natural numbers, assign 0 to the constant a and the relation {⟨1⟩, ⟨3⟩, ⟨5⟩, . . .} to
the predicate symbol p (i.e. let p denote the “odd”-relation). Clearly this is a model
since “0 is not odd” and “there exists a natural number which is odd, e.g. 1”.
Notice that the Herbrand base of a deﬁnite program P always is a Herbrand model
of the program. To check that this is so, simply take an arbitrary ground instance
of any clause A0 ←A1, . . . , Am in P. Clearly, all A0, . . . , Am are in the Herbrand
base.
Hence the formula is true.
However, this model is rather uninteresting —
every n-ary predicate of the program is interpreted as the full n-ary relation over the
domain of ground terms. More important is of course the question — what are the
interesting models of the program? Intuitively there is no reason to expect that the
model includes more ground atoms than those which follow from the program. By the
analogy to databases — if John is not in the telephone directory he probably has no
telephone. However, the directory gives only positive facts and if John has a telephone
it is not a contradiction to what is said in the directory.
The rest of this section is organized as follows. First it is shown that there exists a
unique minimal model called the least Herbrand model of a deﬁnite program. Then it is
shown that this model really contains all positive information present in the program.
The Herbrand models of a deﬁnite program are subsets of its Herbrand base. Thus
the set-inclusion is a natural ordering of such models. In order to show the existence
of least models with respect to set-inclusion it suﬃces to show that the intersection of
all Herbrand models is also a (Herbrand) model.
2More generally the result of Theorem 2.12 would hold for any set of clauses.

28
Chapter 2:
Deﬁnite Logic Programs
Theorem 2.14 (Model intersection property)
Let M be a non-empty family
of Herbrand models of a deﬁnite program P. Then the intersection ℑ:= T M is a
Herbrand model of P.
Proof : Assume that ℑis not a model of P. Then there exists a ground instance of a
clause of P:
A0 ←A1, . . . , Am
(m ≥0)
which is not true in ℑ. This implies that ℑcontains A1, . . . , Am but not A0. Then
A1, . . . , Am are elements of every interpretation of the family M. Moreover there must
be at least one model ℑi ∈M such that A0 ̸∈ℑi. Thus A0 ←A1, . . . , Am is not true
in this ℑi. Hence ℑi is not a model of the program, which contradicts the assumption.
This concludes the proof that the intersection of any set of Herbrand models of a
program is also a Herbrand model.
Thus by taking the intersection of all Herbrand models (it is known that every deﬁnite
program P has at least one Herbrand model — namely BP ) the least Herbrand model
of the deﬁnite program is obtained.
Example 2.15 Let P be the deﬁnite program {male(adam), female(eve)} with ob-
vious intended interpretation. P has the following four Herbrand models:
{male(adam), female(eve)}
{male(adam), male(eve), female(eve)}
{male(adam), female(eve), female(adam)}
{male(adam), male(eve), female(eve), female(adam)}
It is not very hard to see that any intersection of these yields a Herbrand model.
However, all but the ﬁrst model contain atoms incompatible with the intended one.
Notice also that the intersection of all four models yields a model which corresponds
to the intended model.
This example indicates a connection between the least Herbrand model and the in-
tended model of a deﬁnite program. The intended model is an abstraction of the world
to be described by the program. The world may be richer than the least Herbrand
model. For instance, there may be more female individuals than just Eve. However,
the information not included explicitly (via facts) or implicitly (via rules) in the pro-
gram cannot be obtained as an answer to a goal. The answers correspond to logical
consequences of the program. Ideally, a ground atomic formula p(t1, . . . , tn) is a log-
ical consequence of the program iﬀ, in the intended interpretation ℑ, ti denotes the
individual xi and ⟨x1, . . . , xn⟩∈pℑ. The set of all such ground atoms can be seen as
a “coded” version of the intended model. The following theorem relates this set to the
least Herbrand model.
Theorem 2.16 The least Herbrand model MP of a deﬁnite program P is the set of
all ground atomic logical consequences of the program. That is, MP = {A ∈BP |
P |= A}.

2.4 Construction of Least Herbrand Models
29
Proof : Show ﬁrst MP ⊇{A ∈BP | P |= A}: It is easy to see that every ground atom
A which is a logical consequence of P is an element of MP. Indeed, by the deﬁnition
of logical consequence A must be true in MP . On the other hand, the deﬁnition of
Herbrand interpretation states that A is true in MP iﬀA is an element of MP .
Then show that MP ⊆{A ∈BP | P |= A}: Assume that A is in MP . Hence it is
true in every Herbrand model of P. Assume that it is not true in some non-Herbrand
model ℑ′ of P. But we know (see Theorem 2.12) that the set ℑof all ground atomic
formulas which are true in ℑ′ is a Herbrand model of P. Hence A cannot be an element
of ℑ. This contradicts the assumption that there exists a model of P where A is false.
Hence A is true in every model of P, that is P |= A, which concludes the proof.
The model intersection property expressed by Theorem 2.14 does not hold for arbitrary
formulas as illustrated by the following example.
Example 2.17 Consider the formula p(a) ∨q(b). Clearly, both {p(a)} and {q(b)} are
Herbrand models of the formula. However, the intersection {p(a)} ∩{q(b)} =
? is
not a model. The two models are examples of minimal models — that is, one cannot
remove any element from the model and still have a model. However, there is no least
model — that is, a unique minimal model.
2.4
Construction of Least Herbrand Models
The question arises how the least Herbrand model can be constructed, or approximated
by successive enumeration of its elements. The answer to this question is given by a
ﬁxed point approach to the semantics of deﬁnite programs. (A ﬁxpoint of a function
f : D →D is an element x ∈D such that f(x) = x.) This section gives only a sketch
of the construction. The discussion of the relevant theory is outside of the scope of
this book. However, the intuition behind the construction is the following:
A deﬁnite program consists of facts and rules. Clearly, all ground instances of the
facts must be included in every Herbrand model. If a Herbrand interpretation ℑdoes
not include a ground instance of a fact A of the program then A is not true in ℑand
ℑis not a model.
Next, consider a rule A0 ←A1, . . . , Am where (m > 0). This rule states that
whenever A1, . . . , Am are true then so is A0. In other words, take any ground instance
(A0 ←A1, . . . , Am)θ of the rule. If ℑincludes A1θ, . . . , Amθ it must also include A0θ
in order to be a model.
Consider the set ℑ1 of all ground instances of facts in the program. It is now
possible to use every instance of each rule to augment ℑ1 with new elements which
necessarily must belong to every model. In that way a new set ℑ2 is obtained which
can be used again to generate more elements which must belong to the model. This
process is repeated as long as new elements are generated. The new elements added
to ℑi+1 are those which must follow immediately from ℑi.
The construction outlined above can be formally deﬁned as an iteration of a trans-
formation TP on Herbrand interpretations of the program P. The operation is called
the immediate consequence operator and is deﬁned as follows:
Deﬁnition 2.18 (Immediate consequence operator) Let ground(P) be the set
of all ground instances of clauses in P. TP is a function on Herbrand interpretations

30
Chapter 2:
Deﬁnite Logic Programs
of P deﬁned as follows:
TP (I) := {A0 | A0 ←A1, . . . , Am ∈ground(P) ∧{A1, . . . , Am} ⊆I}
For deﬁnite programs it can be shown that there exists a least interpretation ℑsuch
that TP (ℑ) = ℑand that ℑis identical with the least Herbrand model MP . Moreover,
MP is the limit of the increasing, possibly inﬁnite sequence of iterations:
?,
TP (?),
TP (TP (?)),
TP (TP (TP (?))),
. . .
There is a standard notation used to denote elements of the sequence of interpretations
constructed for P. Namely:
TP ↑0
:=
?
TP ↑(i + 1)
:=
TP (TP ↑i)
TP ↑ω
:=
∞
[
i=0
TP ↑i
The following example illustrates the construction:
Example 2.19 Consider again the program of Example 2.5.
TP ↑0
=
?
TP ↑1
=
{odd(s(0))}
TP ↑2
=
{odd(s(s(s(0)))), odd(s(0))}
...
TP ↑ω
=
{odd(sn(0)) | n ∈{1, 3, 5, . . .}}
As already mentioned above it has been established that the set constructed in this
way is identical to the least Herbrand model.
Theorem 2.20 Let P be a deﬁnite program and MP its least Herbrand model. Then:
• MP is the least Herbrand interpretation such that TP (MP ) = MP (i.e. it is the
least ﬁxpoint of TP ).
• MP = TP ↑ω.
For additional details and proofs see for example Apt (1990), Lloyd (1987) or van Em-
den and Kowalski (1976).

Exercises
31
Exercises
2.1 Rewrite the following formulas in the form A0 ←A1, . . . , Am:
∀X(p(X) ∨¬q(X))
∀X(p(X) ∨¬∃Y (q(X, Y ) ∧r(X)))
∀X(¬p(X) ∨(q(X) ⊃r(X)))
∀X(r(X) ⊃(q(X) ⊃p(X)))
2.2 Formalize the following scenario as a deﬁnite program:
Basil owns Fawlty Towers. Basil and Sybil are married. Polly and
Manuel are employees at Fawlty Towers. Smith and Jones are guests
at Fawlty Towers. All hotel-owners and their spouses serve all guests
at the hotel. All employees at a hotel serve all guests at the hotel. All
employees dislike the owner of the workplace. Basil dislikes Manuel.
Then ask the queries “Who serves who?” and “Who dislikes who?”.
2.3 Give the Herbrand universe and Herbrand base of the following deﬁnite pro-
gram:
p(f(X)) ←q(X, g(X)).
q(a, g(b)).
q(b, g(b)).
2.4 Give the Herbrand universe and Herbrand base of the following deﬁnite pro-
gram:
p(s(X), Y, s(Z)) ←p(X, Y, Z).
p(0, X, X).
2.5 Consider the Herbrand universe consisting of the constants a, b, c and d. Let
ℑbe the Herbrand interpretation:
{p(a), p(b), q(a), q(b), q(c), q(d)}
Which of the following formulas are true in ℑ?
(1)
∀Xp(X)
(2)
∀Xq(X)
(3)
∃X(q(X) ∧p(X))
(4)
∀X(q(X) ⊃p(X))
(5)
∀X(p(X) ⊃q(X))
2.6 Give the least Herbrand model of the program in exercise 2.3.
2.7 Give the least Herbrand model of the program in exercise 2.4. Hint: the model
is inﬁnite, but a certain pattern can be spotted when using the TP-operator.

32
Chapter 2:
Deﬁnite Logic Programs
2.8 Consider the following program:
p(0).
p(s(X)) ←p(X).
Show that p(sn(0)) ∈TP ↑m iﬀn < m.
2.9 Let P be a deﬁnite program and ℑa Herbrand interpretation. Show that ℑ
is a model of P iﬀTP(ℑ) ⊆ℑ.

Chapter 3
SLD-Resolution
This chapter introduces the inference mechanism which is the basis of most logic
programming systems.
The idea is a special case of the inference rule called the
resolution principle — an idea that was ﬁrst introduced by J. A. Robinson in the
mid-sixties for a richer language than deﬁnite programs. As a consequence, only a
specialization of this rule, that applies to deﬁnite programs, is presented here. For
reasons to be explained later, it will be called the SLD-resolution principle.
In the previous chapter the model-theoretic semantics of deﬁnite programs was
discussed. The SLD-resolution principle makes it possible to draw correct conclusions
from the program, thus providing a foundation for a logically sound operational se-
mantics of deﬁnite programs. This chapter ﬁrst deﬁnes the notion of SLD-resolution
and then shows its correctness with respect to the model-theoretic semantics. Finally
SLD-resolution is shown to be an instance of a more general notion involving the
construction of proof trees.
3.1
Informal Introduction
Every inference rule of a logical system formalizes some natural way of reasoning.
The presentation of the SLD-resolution principle is therefore preceded by an informal
discussion about the underlying reasoning techniques.
The sentences of logic programs have a general structure of logical implication:
A0 ←A1, . . . , An
(n ≥0)
where A0, . . . , An are atomic formulas and where A0 may be absent (in which case it
is a goal clause). Consider the following deﬁnite program that describes a world where
“parents of newborn children are proud”, “Adam is the father of Mary” and “Mary is
newborn”:
33

34
Chapter 3:
SLD-Resolution
proud(X) ←parent(X, Y ), newborn(Y ).
parent(X, Y ) ←father(X, Y ).
parent(X, Y ) ←mother(X, Y ).
father(adam, mary).
newborn(mary).
Notice that this program describes only “positive knowledge” — it does not state who
is not proud. Nor does it convey what it means for someone not to be a parent. The
problem of expressing negative knowledge will be investigated in detail in Chapter 4
when extending deﬁnite programs with negation.
Say now that we want to ask the question “Who is proud?”. The question concerns
the world described by the program P, that is, the intended model of P. We would
of course like to see the answer “Adam” to this question. However, as discussed in
the previous chapters predicate logic does not provide the means for expressing this
type of interrogative sentences; only declarative ones. Therefore the question may be
formalized as the goal clause:
←proud(Z)
(G0)
which is an abbreviation for ∀Z ¬proud(Z) which in turn is equivalent to:
¬ ∃Z proud(Z)
whose reading is “Nobody is proud”. That is, a negative answer to the query above.
The aim now is to show that this answer is a false statement in every model of P (and
in particular in the intended model). Then by Proposition 1.13 it can be concluded
that P |= ∃Z proud(Z). Alas this would result only in a “yes”-answer to the original
question, while the expected answer is “Adam”. Thus, the objective is rather to ﬁnd
a substitution θ such that the set P ∪{¬ proud(Z)θ} is unsatisﬁable, or equivalently
such that P |= proud(Z)θ.
The starting point of reasoning is the assumption G0 — “For any Z, Z is not
proud”. Inspection of the program reveals a rule describing one condition for someone
to be proud:
proud(X) ←parent(X, Y ), newborn(Y ).
(C0)
Its equivalent logical reading is:
∀(¬proud(X) ⊃¬(parent(X, Y ) ∧newborn(Y )))
Renaming X into Z, elimination of universal quantiﬁcation and the use of modus
ponens with respect to G0 yields:
¬ (parent(Z, Y ) ∧newborn(Y ))
or equivalently:
←parent(Z, Y ), newborn(Y ).
(G1)

3.1 Informal Introduction
35
Thus, one step of reasoning amounts to replacing a goal G0 by another goal G1 which
is true in any model of P ∪{G0}. It now remains to be shown that P ∪{G1} is
unsatisﬁable. Note that G1 is equivalent to:
∀Z ∀Y (¬parent(Z, Y ) ∨¬newborn(Y ))
Thus G1 can be shown to be unsatisﬁable with P if in every model of P there is some
individual who is a parent of a newborn child. Thus, check ﬁrst whether there are any
parents at all. The program contains a clause:
parent(X, Y ) ←father(X, Y ).
(C1)
which is equivalent to:
∀(¬parent(X, Y ) ⊃¬father(X, Y ))
Thus, G1 reduces to:
←father(Z, Y ), newborn(Y ).
(G2)
The new goal G2 can be shown to be unsatisﬁable with P if in every model of P there
is some individual who is a father of a newborn child. The program states that “Adam
is the father of Mary”:
father(adam, mary).
(C2)
Thus it remains to be shown that “Mary is not newborn” is unsatisﬁable together with
P:
←newborn(mary).
(G3)
But the program also contains a fact:
newborn(mary).
(C3)
equivalent to ¬newborn(mary) ⊃
 leading to a refutation:

(G4)
The way of reasoning used in this example is as follows: to show existence of something,
assume the contrary and use modus ponens and elimination of the universal quantiﬁer
to ﬁnd a counter-example for the assumption. This is a general idea to be used in
computations of logic programs. As illustrated above, a single computation (reasoning)
step transforms a set of atomic formulas — that is, a deﬁnite goal — into a new set of
atoms. (See Figure 3.1.) It uses a selected atomic formula p(s1, . . . , sn) of the goal and
a selected program clause of the form p(t1, . . . , tn) ←A1, . . . , Am (where m ≥0 and
A1, . . . , Am are atoms) to ﬁnd a common instance of p(s1, . . . , sn) and p(t1, . . . , tn). In
other words a substitution θ is constructed such that p(s1, . . . , sn)θ and p(t1, . . . , tn)θ
are identical. Such a substitution is called a uniﬁer and the problem of ﬁnding uniﬁers
will be discussed in the next section. The new goal is constructed from the old one by
replacing the selected atom by the set of body atoms of the clause and applying θ to all

36
Chapter 3:
SLD-Resolution
←proud(Z).
←parent(Z, Y ), newborn(Y ).
←father(Z, Y ), newborn(Y ).
←newborn(mary).


 proud(X) ←parent(X, Y ), newborn(Y ).

 parent(X, Y ) ←father(X, Y ).

 father(adam, mary).

 newborn(mary).
Figure 3.1: Refutation of ←proud(Z).
atoms obtained in that way. This basic computation step can be seen as an inference
rule since it transforms logic formulas. It will be called the resolution principle for
deﬁnite programs or SLD-resolution principle. As illustrated above it combines in a
special way modus ponens with the elimination rule for the universal quantiﬁer.
At the last step of reasoning the empty goal, corresponding to falsity, is obtained.
The ﬁnal conclusion then is the negation of the initial goal. Since this goal is of the
form ∀¬(A1 ∧· · · ∧Am), the conclusion is equivalent (by DeMorgan’s laws) to the
formula ∃(A1 ∧· · · ∧Am). The ﬁnal conclusion can be obtained by the inference rule
known as reductio ad absurdum.
Every step of reasoning produces a substitution.
Unsatisﬁability of the original goal ←A1, . . . , Am with P is demonstrated in k steps
by showing that its instance:
←(A1, . . . , Am)θ1 · · · θk
is unsatisﬁable, or equivalently that:
P |= (A1 ∧· · · ∧Am)θ1 · · · θk
In the example discussed, the goal “Nobody is proud” is unsatisﬁable with P since
its instance “Adam is not proud” is unsatisﬁable with P. In other words — in every
model of P the sentence “Adam is proud” is true.
It is worth noticing that the uniﬁers may leave some variables unbound. In this
case the universal closure of (A1 ∧· · · ∧Am)θ1 · · · θk is a logical consequence of P.
Examples of such answers will appear below.
Notice also that generally the computation steps are not deterministic — any atom
of a goal may be selected and there may be several clauses matching the selected atom.
Another potential source of non-determinism concerns the existence of alternative
uniﬁers for two atoms. These remarks suggest that it may be possible to construct
(sometimes inﬁnitely) many solutions, i.e. counter-examples for the initial goal. On
the other hand it may also happen that the selected atom has no matching clause.

3.2 Uniﬁcation
37
If so, it means that, using this method, it is not possible to construct any counter-
example for the initial goal. The computation may also loop without producing any
solution.
3.2
Uniﬁcation
As demonstrated in the previous section, one of the main ingredients in the inference
mechanism is the process of making two atomic formulas syntactically equivalent. Be-
fore deﬁning the notion of SLD-resolution we focus on this process, called uniﬁcation,
and give an algorithmic solution — a procedure that takes two atomic formulas as
input, and either shows how they can be instantiated to identical atoms or, reports a
failure.
Before considering the problem of unifying atoms (and terms), consider an ordinary
equation over the natural numbers (
N) such as:
2x + 3 .= 4y + 7
(5)
The equation has a set of solutions; that is, valuations ϕ: {x, y} →
N such that ϕℑ(2x+
3) = ϕℑ(4y + 7) where ℑis the standard interpretation of the arithmetic symbols. In
this particular example there are inﬁnitely many solutions ({x 7→2, y 7→0} and
{x 7→4, y 7→1} etc.) but by a sequence of syntactic transformations that preserve
the set of all solutions the equation may be transformed into an new equation that
compactly represents all solutions to the original equation:
x .= 2(y + 1)
(6)
The transformations exploit domain knowledge (such as commutativity, associativity
etc.) speciﬁc to the particular interpretation. In a logic program there is generally
no such knowledge available and the question arises how to compute the solutions
of an equation without any knowledge about the interpretation of the symbols. For
example:
f(X, g(Y )) .= f(a, g(X))
(7)
Clearly it is no longer possible to apply all the transformations that were applied above
since the interpretation of f/2, g/1 is no longer ﬁxed. However, any solution of the
equations:
{X .= a, g(Y ) .= g(X)}
(8)
must clearly be a solution of equation (7). Similarly, any solution of:
{X .= a, Y .= X}
(9)
must be a solution of equations (8). Finally any solution of:
{X .= a, Y .= a}
(10)
is a solution of (9). By analogy to (6) this is a compact representation of some solutions
to equation (7).
However, whether it represents all solution depends on how the

38
Chapter 3:
SLD-Resolution
symbols f/2, g/1 and a are interpreted. For example, if f/2 denotes integer addition,
g/1 the successor function and a the integer zero, then (10) represents only one solution
to equation (7). However, equation (7) has inﬁnitely many integer solutions — any ϕ
such that ϕ(Y ) = 0 is a solution.
On the other hand, consider a Herbrand interpretation ℑ; Solving of an equation
s .= t amounts to ﬁnding a valuation ϕ such that ϕℑ(s) = ϕℑ(t). Now a valuation in
the Herbrand domain is a mapping from variables of the equations to ground terms
(that is, a substitution) and the interpretation of a ground term is the term itself.
Thus, a solution in the Herbrand domain is a grounding substitution ϕ such that
sϕ and tϕ are identical ground terms. This brings us to the fundamental concept of
uniﬁcation and uniﬁers:
Deﬁnition 3.1 (Uniﬁer) Let s and t be terms. A substitution θ such that sθ and
tθ are identical (denoted sθ = tθ) is called a uniﬁer of s and t.
The search for a uniﬁer of two terms, s and t, will be viewed as the process of solving
the equation s .= t. Therefore, more generally, if {s1 .= t1, . . . , sn .= tn} is a set of
equations, then θ is called a uniﬁer of the set if siθ = tiθ for all 1 ≤i ≤n. For instance,
the substitution {X/a, Y/a} is a uniﬁer of equation (7). It is also a uniﬁer of (8)–(10).
In fact, it is the only uniﬁer as long as “irrelevant” variables are not introduced. (For
instance, {X/a, Y/a, Z/a} is also a uniﬁer.) The transformations informally used in
steps (7)–(10) preserve the set of all solutions in the Herbrand domain. (The full set
of transformations will soon be presented.) Note that a solution to a set of equations
is a (grounding) uniﬁer. Thus, if a set of equations has a uniﬁer then the set also has
a solution.
However, not all sets of equations have a solution/uniﬁer. For instance, the set
{sum(1, 1) .= 2} is not uniﬁable. Intuitively sum may be thought of as integer addition,
but bear in mind that the symbols have no predeﬁned interpretation in a logic program.
(In Chapters 13–14 more powerful notions of uniﬁcation are discussed.)
It is often the case that a set of equations have more than one uniﬁer. For in-
stance, both {X/g(Z), Y/Z} and {X/g(a), Y/a, Z/a} are uniﬁers of the set {f(X, Y ) .=
f(g(Z), Z)}. Under the ﬁrst uniﬁer the terms instantiate to f(g(Z), Z) and under the
second uniﬁer the terms instantiate to f(g(a), a). The second uniﬁer is in a sense
more restrictive than the ﬁrst, as it makes the two terms ground whereas the ﬁrst
still provides room for some alternatives in that is does not specify how Z should be
bound. We say that {X/g(Z), Y/Z} is more general than {X/g(a), Y/a, Z/a}. More
formally this can be expressed as follows:
Deﬁnition 3.2 (Generality of substitutions) A substitution θ is said to be more
general than a substitution σ (denoted σ ⪯θ) iﬀthere exists a substitution ω such
that σ = θω.
Deﬁnition 3.3 (Most general uniﬁer) A uniﬁer θ is said to be a most general
uniﬁer (mgu) of two terms iﬀθ is more general than any other uniﬁer of the terms.
Deﬁnition 3.4 (Solved form) A set of equations {X1 .= t1, . . . , Xn .= tn} is said
to be in solved form iﬀX1, . . . , Xn are distinct variables none of which appear in
t1, . . . , tn.

3.2 Uniﬁcation
39
There is a close correspondence between a set of equations in solved form and the most
general uniﬁer(s) of that set as shown by the following theorem:
Proposition 3.5 Let {X1 .= t1, . . . , Xn .= tn} be a set of equations in solved form.
Then {X1/t1, . . . , Xn/tn} is an (idempotent) mgu of the solved form.
Proof : First deﬁne:
E := {X1 .= t1, . . . , Xn .= tn}
θ := {X1/t1, . . . , Xn/tn}
Clearly θ is an idempotent uniﬁer of E. It remains to be shown that θ is more general
than any other uniﬁer of E.
Thus, assume that σ is a uniﬁer of E. Then Xiσ = tiσ for 1 ≤i ≤n. It must
follow that Xi/tiσ ∈σ for 1 ≤i ≤n. In addition σ may contain some additonal pairs
Y1/s1, . . . , Ym/sm such that {X1, . . . , Xn}∩{Y1, . . . , Ym} =
?. Thus, σ is of the form:
{X1/t1σ, . . . , Xn/tnσ, Y1/s1, . . . , Ym/sm}
Now θσ = σ. Thus, there exists a substitution ω (viz. σ) such that σ = θω. Therefore,
θ is an idempotent mgu.
Deﬁnition 3.6 (Equivalence of sets of equations) Two sets of equations E1 and
E2 are said to be equivalent if they have the same set of uniﬁers.
Note that two equivalent sets of equations must have the same set of solutions in any
Herbrand interpretation.
The deﬁnition can be used as follows: to compute a most general uniﬁer mgu(s, t)
of two terms s and t, ﬁrst try to transform the equation {s .= t} into an equivalent
solved form. If this fails then mgu(s, t) = failure. However, if there is a solved form
{X1 .= t1, . . . , Xn .= tn} then mgu(s, t) = {X1/t1, . . . , Xn/tn}.
Figure 3.2 presents a (non-deterministic) algorithm which takes as input a set of
equations E and terminates returning either a solved form equivalent to E or failure
if no such solved form exists. Note that constants are viewed as function symbols of
arity 0. Thus, if an equation c .= c gets selected, the equation is simply removed by
case 1. Before proving the correctness of the algorithm some examples are used to
illustrate the idea:
Example 3.7 The set {f(X, g(Y )) .= f(g(Z), Z)} has a solved form since:
{f(X, g(Y )) .= f(g(Z), Z)}
⇒
{X .= g(Z), g(Y ) .= Z}
⇒
{X .= g(Z), Z .= g(Y )}
⇒
{X .= g(g(Y )), Z .= g(Y )}
The set {f(X, g(X), b) .= f(a, g(Z), Z)}, on the other hand, does not have a solved
form since:
{f(X, g(X), b) .= f(a, g(Z), Z)}
⇒
{X .= a, g(X) .= g(Z), b .= Z}
⇒
{X .= a, g(a) .= g(Z), b .= Z}

40
Chapter 3:
SLD-Resolution
Input: A set E of equations.
Output: An equivalent set of equations in solved form or failure.
repeat
select an arbitrary s .= t ∈E;
case s .= t of
f(s1, . . . , sn) .= f(t1, . . . , tn) where n ≥0 ⇒
replace equation by s1 .= t1, . . . , sn .= tn;
% case 1
f(s1, . . . , sm) .= g(t1, . . . , tn) where f/m ̸= g/n ⇒
halt with failure;
% case 2
X .= X ⇒
remove the equation;
% case 3
t .= X where t is not a variable ⇒
replace equation by X .= t;
% case 4
X .= t where X ̸= t and X has more than one occurrence in E ⇒
if X is a proper subterm of t then
halt with failure
% case 5a
else
replace all other occurrences of X by t;
% case 5b
esac
until no action is possible on any equation in E;
halt with E;
Figure 3.2: Solved form algorithm
⇒
{X .= a, a .= Z, b .= Z}
⇒
{X .= a, Z .= a, b .= Z}
⇒
{X .= a, Z .= a, b .= a}
⇒
failure
The algorithm fails since case 2 applies to b .= a. Finally consider:
{f(X, g(X)) .= f(Z, Z)}
⇒
{X .= Z, g(X) .= Z}
⇒
{X .= Z, g(Z) .= Z}
⇒
{X .= Z, Z .= g(Z)}
⇒
failure
The set does not have a solved form since Z is a proper subterm of g(Z).
Theorem 3.8 The solved form algorithm in Figure 3.2 terminates and returns an
equivalent solved form or failure if no such solved form exists.
Proof : First consider termination: Note that case 5b is the only case that may increase
the number of symbol occurrences in the set of equations. However, case 5b can be
applied at most once for each variable X. Thus, case 5b can be applied only a ﬁnite

3.2 Uniﬁcation
41
number of times and may introduce only a ﬁnite number of new symbol occurrences.
Case 2 and case 5a terminate immediately and case 1 and 3 strictly decrease the
number of symbol occurrences in the set. Since case 4 cannot be applied indeﬁnitely,
but has to be intertwined with the other cases it follows that the algorithm always
terminates.
It should be evident that the algorithm either returns failure or a set of equations
in solved form. Thus, it remains to be shown that each iteration of the algorithm
preserves equivalence between successive sets of equations. It is easy to see that if
case 2 or 5a apply to some equation in:
{s1 .= t1, . . . , sn .= tn}
(E1)
then the set cannot possibly have a uniﬁer. It is also easy to see that if any of case 1, 3
or 4 apply, then the new set of equations has the same set of uniﬁers. Finally assume
that case 5b applies to some equation si .= ti. Then the new set is of the form:
{s1θ .= t1θ, . . . , si−1θ .= ti−1θ, si .= ti, si+1θ .= ti+1θ, . . . snθ .= tnθ}
(E2)
where θ := {si/ti}. First assume that σ is a uniﬁer of E1 — that is, sjσ = tjσ for
every 1 ≤j ≤n. In particular, it must hold that siσ = tiσ. Since si is a variable
which is not a subterm of ti it must follow that si/tiσ ∈σ. Moreover, θσ = σ and it
therefore follows that σ is a uniﬁer also of E2.
Next, assume that σ is a uniﬁer of E2. Thus, si/tiσ ∈σ and θσ = σ which must
then be a uniﬁer also of E1.
The algorithm presented in Figure 3.2 may be very ineﬃcient. One of the reasons is
case 5a; That is, checking if a variable X occurs inside another term t. This is often
referred to as the occur-check. Assume that the time of occur-check is linear with
respect to the size |t| of t.1 Consider application of the solved form algorithm to the
equation:
g(X1, . . . , Xn) .= g(f(X0, X0), f(X1, X1), . . . , f(Xn−1, Xn−1))
where X0, . . . , Xn are distinct. By case 1 this reduces to:
{X1 .= f(X0, X0), X2 .= f(X1, X1), . . . , Xn .= f(Xn−1, Xn−1)}
Assume that the equation selected in step i is of the form Xi = f(. . . , . . .). Then in the
k-th iteration the selected equation is of the form Xk .= Tk where Ti+1 := f(Ti, Ti) and
T0 := X0. Hence, |Ti+1| = 2|Ti| + 1. That is, |Tn| > 2n. This shows the exponential
dependency of the uniﬁcation time on the length of the structures. In this example
the growth of the argument lengths is caused by duplication of subterms. As a matter
of fact, the same check is repeated many times. Something that could be avoided by
sharing various instances of the same structure. In the literature one can ﬁnd linear
algorithms but they are sometimes quite elaborate. On the other hand, Prolog systems
usually “solve” the problem simply by omitting the occur-check during uniﬁcation.
Roughly speaking such an approach corresponds to a solved form algorithm where
case 5a–b is replaced by:
1The size of a term is the total number of constant, variable and functor occurrences in t.

42
Chapter 3:
SLD-Resolution
X .= t where X ̸= t and X has more than one occurrence in E ⇒
replace all other occurrences of X by t;
% case 5
A pragmatic justiﬁcation for this solution is the fact that rule 5a (occur check) never is
used during the computation of many Prolog programs. There are suﬃcient conditions
which guarantee this, but in general this property is undecidable. The ISO Prolog
standard (1995) states that the result of uniﬁcation is undeﬁned if case 5b can be
applied to the set of equations. Strictly speaking, removing case 5a causes looping
of the algorithm on equations where case 5a would otherwise apply. For example, an
attempt to solve X .= f(X) by the modiﬁed algorithm will produce a new equation
X .= f(f(X)). However, case 5 is once again applicable yielding X .= f(f(f(f(X))))
and so forth. In practice many Prolog systems do not loop, but simply bind X to
the inﬁnite structure f(f(f(. . .))). (The notation X/f(∞) will be used to denote this
binding.) Clearly, {X/f(∞)} is an inﬁnite “uniﬁer” of X and f(X). It can easily
be represented in the computer by a ﬁnite cyclic data structure. But this amounts
to generalization of the concepts of term, substitution and uniﬁer for the inﬁnite case
not treated in classical logic. Implementation of uniﬁcation without occur-check may
result in unsoundness as will be illustrated in Example 3.21.
Before concluding the discussion about uniﬁcation we study the notion of most general
uniﬁer in more detail. It turns out that the notion of mgu is a subtle one; For instance,
there is generally not a unique most general uniﬁer of two terms s and t. A trivial
example is the equation f(X) .= f(Y ) which has at least two mgu’s; namely {X/Y }
and {Y/X}. Part of the confusion stems from the fact that ⪯(“being more general
than”) is not an ordering relation. It is reﬂexive: That is, any substitution θ is “more
general” than itself since θ = θϵ. As might be expected it is also transitive: If θ1 = θ2ω1
and θ2 = θ3ω2 then obviously θ1 = θ3ω2ω1. However, ⪯is not anti-symmetric. For
instance, consider the substitution θ := {X/Y, Y/X} and the identity substitution ϵ.
The latter is obviously more general than θ since θ = ϵθ. But θ is also more general
than ϵ, since ϵ = θθ. It may seem odd that two distinct substitutions are more general
than one another. Still there is a rational explanation. First consider the following
deﬁnition:
Deﬁnition 3.9 (Renaming) A substitution {X1/Y1, . . . , Xn/Yn} is called a renam-
ing substitution iﬀY1, . . . , Yn is a permutation of X1, . . . , Xn.
A renaming substitution represents a bijective mapping between variables (or more
generally terms). Such a substitution always preserves the structure of a term; if θ
is a renaming and t a term, then tθ and t are equivalent but for the names of the
variables. Now, the fact that a renaming represents a bijection implies that there
must be an inverse mapping.
Indeed, if {X1/Y1, . . . , Xn/Yn} is a renaming then
{Y1/X1, . . . , Yn/Xn} is its inverse. We denote the inverse of θ by θ−1 and observe
that θθ−1 = θ−1θ = ϵ.
Proposition 3.10 Let θ be an mgu of s and t and assume that ω is a renaming.
Then θω is an mgu of s and t.
The proof of the proposition is left as an exercise. So is the proof of the following
proposition:

3.3 SLD-Resolution
43
Proposition 3.11 Let θ and σ be substitutions. If θ ⪯σ and σ ⪯θ then there exists
a renaming substitution ω such that σ = θω (and θ = σω−1).
Thus, according to the above propositions, the set of all mgu’s of two terms is closed
under renaming.
3.3
SLD-Resolution
The method of reasoning discussed informally in Section 3.1 can be summarized as
the following inference rule:
∀¬ (A1 ∧· · · ∧Ai−1 ∧Ai ∧Ai+1 ∧· · · ∧Am)
∀(B0 ←B1 ∧· · · ∧Bn)
∀¬ (A1 ∧· · · ∧Ai−1 ∧B1 ∧· · · ∧Bn ∧Ai+1 ∧· · · ∧Am)θ
or (using logic programming notation):
←A1, . . . , Ai−1, Ai, Ai+1, . . . , Am
B0 ←B1, . . . , Bn
←(A1, . . . , Ai−1, B1, . . . , Bn, Ai+1, . . . , Am)θ
where
(i) A1, . . . , Am are atomic formulas;
(ii) B0 ←B1, . . . , Bn is a (renamed) deﬁnite clause in P (n ≥0);
(iii) mgu(Ai, B0) = θ.
The rule has two premises — a goal clause and a deﬁnite clause. Notice that each
of them is separately universally quantiﬁed. Thus the scopes of the quantiﬁers are
disjoint. On the other hand, there is only one universal quantiﬁer in the conclusion
of the rule.
Therefore it is required that the sets of variables in the premises are
disjoint. Since all variables of the premises are bound it is always possible to rename
the variables of the deﬁnite clause to satisfy this requirement (that is, to apply some
renaming substitution to it).
The goal clause may include several atomic formulas which unify with the head
of some clause in the program. In this case it may be desirable to introduce some
deterministic choice of the selected atom Ai for uniﬁcation.
In what follows it is
assumed that this is given by some function which for a given goal selects the subgoal
for uniﬁcation. The function is called the selection function or the computation rule.
It is sometimes desirable to generalize this concept so that, in one situation, the
computation rule selects one subgoal from a goal G but, in another situation, selects
another subgoal from G. In that case the computation rule is not a function on goals
but something more complicated. However, for the purpose of this book this extra
generality is not needed.
The inference rule presented above is the only one needed for deﬁnite programs. It
is a version of the inference rule called the resolution principle, which was introduced
by J. A. Robinson in 1965. The resolution principle applies to clauses. Since deﬁnite
clauses are restricted clauses the corresponding restricted form of resolution presented
below is called SLD-resolution (Linear resolution for Deﬁnite clauses with Selection
function).

44
Chapter 3:
SLD-Resolution
Next the use of the SLD-resolution principle is discussed for a given deﬁnite pro-
gram P. The starting point, as exempliﬁed in Section 3.1, is a deﬁnite goal clause G0
of the form:
←A1, . . . , Am
(m ≥0)
From this goal a subgoal Ai is selected (if possible) by the computation rule. A new
goal clause G1 is constructed by selecting (if possible) some renamed program clause
B0 ←B1, . . . , Bn (n ≥0) whose head uniﬁes with Ai (resulting in an mgu θ1). If so,
G1 will be of the form:
←(A1, . . . , Ai−1, B1, . . . , Bn, Ai+1, . . . , Am)θ1
(According to the requirement above, the variables of the program clause are being
renamed so that they are diﬀerent from those of G0.) Now it is possible to apply
the resolution principle to G1 thus obtaining G2, etc. This process may or may not
terminate. There are two cases when it is not possible to obtain Gi+1 from Gi:
• the ﬁrst is when the selected subgoal cannot be resolved (i.e. is not uniﬁable)
with the head of any program clause;
• the other case appears when Gi =
 (i.e. the empty goal).
The process described above results in a ﬁnite or inﬁnite sequence of goals starting
with the initial goal. At every step a program clause (with renamed variables) is used
to resolve the subgoal selected by the computation rule ℜand an mgu is created.
Thus, the full record of a reasoning step would be a pair ⟨Gi, Ci⟩, i ≥0, where Gi is a
goal and Ci a program clause with renamed variables. Clearly, the computation rule
ℜtogether with Gi and Ci determines (up to renaming of variables) the mgu (to be
denoted θi+1) produced at the (i + 1)-th step of the process. A goal Gi+1 is said to be
derived (directly) from Gi and Ci via ℜ(or alternatively, Gi and Ci resolve into Gi+1).
Deﬁnition 3.12 (SLD-derivation) Let G0 be a deﬁnite goal, P a deﬁnite program
and ℜa computation rule. An SLD-derivation of G0 (using P and ℜ) is a ﬁnite or
inﬁnite sequence of goals:
G0
C0
 G1 · · · Gn−1
Cn−1
 Gn . . .
where each Gi+1 is derived directly from Gi and a renamed program clause Ci via
ℜ.
Note that since there are usually inﬁnitely many ways of renaming a clause there are
formally inﬁnitely many derivations. However, some of the derivations diﬀer only in
the names of the variables used. To avoid some technical problems and to make the
renaming of variables in a derivation consistent, the variables in the clause Ci of a
derivation are renamed by adding the subscript i to every variable in the clause. In
what follows we consider only derivations where this renaming strategy is used.
Each ﬁnite SLD-derivation of the form:
G0
C0
 G1 · · · Gn−1
Cn−1
 Gn

3.3 SLD-Resolution
45
yields a sequence θ1, . . . , θn of mgu’s. The composition
θ :=

θ1θ2 · · · θn
if n > 0
ϵ
if n = 0
of mgu’s is called the computed substitution of the derivation.
Example 3.13 Consider the initial goal ←proud(Z) and the program discussed in
Section 3.1.
G0
:
←proud(Z).
C0
:
proud(X0) ←parent(X0, Y0), newborn(Y0).
Uniﬁcation of proud(Z) and proud(X0) yields e.g. the mgu θ1 = {X0/Z}. Assume that
a computation rule which always selects the leftmost subgoal is used (if nothing else is
said, this computation rule is used also in what follows). Such a computation rule will
occasionally be referred to as Prolog’s computation rule since this is the computation
rule used by most Prolog systems. The ﬁrst derivation step yields:
G1
:
←parent(Z, Y0), newborn(Y0).
C1
:
parent(X1, Y1) ←father(X1, Y1).
In the second resolution step the mgu θ2 = {X1/Z, Y1/Y0} is obtained. The derivation
then proceeds as follows:
G2
:
←father(Z, Y0), newborn(Y0).
C2
:
father(adam, mary).
G3
:
←newborn(mary).
C3
:
newborn(mary).
G4
:

The computed substitution of this derivation is:
θ1θ2θ3θ4
=
{X0/Z}{X1/Z, Y1/Y0}{Z/adam, Y0/mary}ϵ
=
{X0/adam, X1/adam, Y1/mary, Z/adam, Y0/mary}
A derivation like the one above is often represented graphically as in Figure 3.1.
Example 3.14 Consider the following deﬁnite program:
1 :
grandfather(X, Z) ←father(X, Y ), parent(Y, Z).
2 :
parent(X, Y ) ←father(X, Y ).
3 :
parent(X, Y ) ←mother(X, Y ).
4 :
father(a, b).
5 :
mother(b, c).

46
Chapter 3:
SLD-Resolution
←grandfather(a, X).
←father(a, Y0), parent(Y0, X).
←parent(b, X).
←mother(b, X).


 grandfather(X0, Z0) ←father(X0, Y0), parent(Y0, Z0).

 father(a, b).

 parent(X2, Y2) ←mother(X2, Y2).

 mother(b, c).
Figure 3.3: SLD-derivation
Figure 3.3 depicts a ﬁnite SLD-derivation of the goal ←grandfather(a, X) (again using
Prolog’s computation rule).
SLD-derivations that end in the empty goal (and the bindings of variables in the initial
goal of such derivations) are of special importance since they correspond to refutations
of (and provide answers to) the initial goal:
Deﬁnition 3.15 (SLD-refutation) A (ﬁnite) SLD-derivation:
G0
C0
 G1 · · · Gn
Cn
 Gn+1
where Gn+1 =
 is called an SLD-refutation of G0.
Deﬁnition 3.16 (Computed answer substitution) The computed substitution of
an SLD-refutation of G0 restricted to the variables in G0 is called a computed answer
substitution for G0.
In Examples 3.13 and 3.14 the computed answer substitutions are {Z/adam} and
{X/c} respectively.
For a given initial goal G0 and computation rule, the sequence G1, . . . , Gn+1 of
goals in a ﬁnite derivation G0
 G1 · · · Gn
 Gn+1 is determined (up to renaming
of variables) by the sequence C0, . . . , Cn of (renamed) program clauses used. This is
particularly interesting in the case of refutations. Let:
G0
C0
 G1 · · · Gn
Cn
 

be a refutation. It turns out that if the computation rule is changed there still exists
another refutation:
G0
C′
0
 G′
1 · · · G′
n
C′
n
 


3.3 SLD-Resolution
47
←grandfather(a, X).
←father(a, Y0), parent(Y0, X).
←parent(b, X).
←father(b, X).

 grandfather(X0, Z0) ←father(X0, Y0), parent(Y0, Z0).

 father(a, b).

 parent(X2, Y2) ←father(X2, Y2).
Figure 3.4: Failed SLD-derivation
of G0 which has the same computed answer substitution (up to renaming of variables)
and where the sequence C′
0, . . . , C′
n of clauses used is a permutation of the sequence
C0, . . . , Cn. This property will be called independence of the computation rule and it
will be discussed further in Section 3.6.
Not all SLD-derivations lead to refutations. As already pointed out, if the selected
subgoal cannot be uniﬁed with any clause, it is not possible to extend the derivation
any further:
Deﬁnition 3.17 (Failed derivation) A derivation of a goal clause G0 whose last
element is not empty and cannot be resolved with any clause of the program is called
a failed derivation.
Figure 3.4 depicts a failed derivation of the program and goal in Example 3.14. Since
the selected literal (the leftmost one) does not unify with the head of any clause in
the program, the derivation is failed. Note that a derivation is failed even if there is
some other subgoal but the selected one which uniﬁes with a clause head.
By a complete derivation we mean a refutation, a failed derivation or an inﬁnite
derivation. As shown above, a given initial goal clause G0 may have many complete
derivations via a given computation rule ℜ. This happens if the selected subgoal of
some goal can be resolved with more than one program clause. All such derivations
may be represented by a possibly inﬁnite tree called the SLD-tree of G0 (using P and
ℜ).
Deﬁnition 3.18 (SLD-tree) Let P be a deﬁnite program, G0 a deﬁnite goal and
ℜa computation rule. The SLD-tree of G0 (using P and ℜ) is a (possibly inﬁnite)
labelled tree satisfying the following conditions:
• the root of the tree is labelled by G0;
• if the tree contains a node labelled by Gi and there is a renamed clause Ci ∈P
such that Gi+1 is derived from Gi and Ci via ℜthen the node labelled by Gi
has a child labelled by Gi+1. The edge connecting them is labelled by Ci.

48
Chapter 3:
SLD-Resolution
←grandfather(a, X).
←father(a, Y0), parent(Y0, X).
←parent(b, X).
←father(b, X).
←mother(b, X).

    @
@
@
@
Figure 3.5: SLD-tree of ←grandfather(a, X)
The nodes of an SLD-tree are thus labelled by goals of a derivation. The edges are
labelled by the clauses of the program. There is in fact a one-to-one correspondence
between the paths of the SLD-tree and the complete derivations of G0 under a ﬁxed
computation rule ℜ. The sequence:
G0
C0
 G1 · · · Gk
Ck
 · · ·
is a complete derivation of G0 via ℜiﬀthere exists a path of the SLD-tree of the form
G0, G1, . . . , Gk, . . . such that for every i, the edge ⟨Gi, Gi+1⟩is labelled by Ci. Usually
this label is abbreviated (e.g. by numbering the clauses of the program) or omitted
when drawing the tree. Additional labelling with the mgu θi+1 or some part of it may
also be included.
Example 3.19 Consider again the program of Example 3.14. The SLD-tree of the
goal ←grandfather(a, X) is depicted in Figure 3.5.
The SLD-trees of a goal clause G0 are often distinct for diﬀerent computation rules. It
may even happen that the SLD-tree for G0 under one computation rule is ﬁnite whereas
the SLD-tree of the same goal under another computation rule is inﬁnite. However,
the independence of computation rules means that for every refutation path in one
SLD-tree there exists a refutation path in the other SLD-tree with the same length
and with the same computed answer substitution (up to renaming). The sequences of
clauses labelling both paths are permutations of one another.
3.4
Soundness of SLD-resolution
The method of reasoning presented informally in Section 3.1 was formalized as the
SLD-resolution principle in the previous section. As a matter of fact one more inference

3.4 Soundness of SLD-resolution
49
rule is used after construction of a refutation. It applies the computed substitution
of the refutation to the body of the initial goal to get the ﬁnal conclusion. This is
the most interesting part of the process since if the initial goal is seen as a query, the
computed substitution of the refutation restricted to its variables is an answer to this
query. It is therefore called a computed answer substitution. In this context it is also
worth noticing the case when no answer substitution exists for a given query. Prolog
systems may sometimes discover this and deliver a “no” answer. The logical meaning
of “no” will be discussed in the next chapter.
As discussed in Chapter 1, the introduction of formal inference rules raises the
questions of their soundness and completeness.
Soundness is an essential property
which guarantees that the conclusions produced by the system are correct. Correctness
in this context means that they are logical consequences of the program. That is, that
they are true in every model of the program. Recall the discussion of Chapter 2 —
a deﬁnite program describes many “worlds” (i.e. models), including the one which
is meant by the user, the intended model. Soundness is necessary to be sure that
the conclusions produced by any refutation are true in every world described by the
program, in particular in the intended one.
This raises the question concerning the soundness of the SLD-resolution principle.
The discussion in Section 3.1 gives some arguments which may by used in a formal
proof. However, the intermediate conclusions produced at every step of refutation are
of little interest for the user of a deﬁnite program. Therefore the soundness of SLD-
resolution is usually understood as correctness of computed answer substitutions. This
can be stated as the following theorem (due to Clark (1979)).
Theorem 3.20 (Soundness of SLD-resolution) Let P be a deﬁnite program, ℜa
computation rule and θ an ℜ-computed answer substitution for a goal ←A1, . . . , Am.
Then ∀((A1 ∧· · · ∧Am)θ) is a logical consequence of the program.
Proof : Any computed answer substitution is obtained by a refutation of the goal via ℜ.
The proof is based on induction over the number of resolution steps of the refutation.
First consider refutations of length one. This is possible only if m = 1 and A1
resolves with some fact A with the mgu θ1. Hence A1θ1 is an instance of A. Now let
θ be θ1 restricted to the variables in A1. Then A1θ = A1θ1. It is a well-known fact
that the universal closure of an instance of a formula F is a logical consequence of the
universal closure of F (cf. exercise 1.9, Chapter 1). Hence the universal closure of A1θ
is a logical consequence of the clause A and consequently of the program P.
Next, assume that the theorem holds for refutations with n −1 steps.
Take a
refutation with n steps of the form:
G0
C0
 G1 · · · Gn−1
Cn−1
 

where G0 is the original goal clause ←A1, . . . , Am.
Now, assume that Aj is the selected atom in the ﬁrst derivation step and that C0
is a (renamed) clause B0 ←B1, . . . , Bk (k ≥0) in P. Then Ajθ1 = B0θ1 and G1 has
to be of the form:
←(A1, . . . , Aj−1, B1, . . . , Bk, Aj+1, . . . , Am)θ1

50
Chapter 3:
SLD-Resolution
By the induction hypothesis the formula:
∀(A1 ∧. . . ∧Aj−1 ∧B1 ∧. . . ∧Bk ∧Aj+1 ∧. . . ∧Am)θ1 · · · θn
(11)
is a logical consequence of the program. It follows by deﬁnition of logical consequence
that also the universal closure of:
(B1 ∧. . . ∧Bk)θ1 · · · θn
(12)
is a logical consequence of the program. By (11):
∀(A1 ∧. . . ∧Aj−1 ∧Aj+1 ∧. . . ∧Am)θ1 · · · θn
(13)
is a logical consequence of P. Now because of (12) and since:
∀(B0 ←B1 ∧. . . ∧Bk)θ1 · · · θn
is a logical consequence of the program (being an instance of a clause in P) it follows
that:
∀B0θ1 · · · θn
(14)
is a logical consequence of P. Hence by (13) and (14):
∀(A1 ∧. . . ∧Aj−1 ∧B0 ∧Aj+1 ∧. . . ∧Am)θ1 · · · θn
(15)
is also a logical consequence of the program. But since θ1 is a most general uniﬁer of
B0 and Aj, B0 can be replaced by Aj in (15). Now let θ be θ1 · · · θn restricted to the
variables in A1, . . . , Am then:
∀(A1 ∧. . . ∧Am)θ
is a logical consequence of P, which concludes the proof.
It should be noticed that the theorem does not hold if the uniﬁer is computed by a
“uniﬁcation” algorithm without occur-check. For illustration consider the following
example.
Example 3.21 A term is said to be f-constructed with a term T if it is of the form
f(T, Y ) for any term Y . A term X is said to be bizarre if it is f-constructed with
itself. (As discussed in Section 3.2 there are no “bizarre” terms since no term can
include itself as a proper subterm.) Finally a term X is said to be crazy if it is the
second direct substructure of a bizarre term. These statements can be formalized as
the following deﬁnite program:
f constructed(f(T, Y ), T).
bizarre(X) ←f constructed(X, X).
crazy(X) ←bizarre(f(Y, X)).

3.5 Completeness of SLD-resolution
51
Now consider the goal ←crazy(X) — representing the query “Are there any crazy
terms?”. There is only one complete SLD-derivation (up to renaming). Namely:
G0
:
←crazy(X)
C0
:
crazy(X0) ←bizarre(f(Y0, X0))
G1
:
←bizarre(f(Y0, X))
C1
:
bizarre(X1) ←f constructed(X1, X1)
G2
:
←f constructed(f(Y0, X), f(Y0, X))
The only subgoal in G2 does not unify with the ﬁrst program clause because of the
occur-check. This corresponds to our expectations: Since, in the intended model, there
are no bizarre terms, there cannot be any crazy terms. Since SLD-resolution is sound,
if there were any answers to G0 they would be correct also in the intended model.
Assume now that a “uniﬁcation” algorithm without occur-check is used. Then the
derivation can be extended as follows:
G2
:
←f constructed(f(Y0, X), f(Y0, X))
C2
:
f constructed(f(T2, Y2), T2)
G3
:

The “substitution” obtained in the last step is {X/Y2, Y0/f(∞, Y2), T2/f(∞, Y2)} (see
Section 3.2). The resulting answer substitution is {X/Y2}. In other words the conclu-
sion is that every term is crazy, which is not true in the intended model. Thus it is
not a logical consequence of the program which shows that the inference is no longer
sound.
3.5
Completeness of SLD-resolution
Another important problem is whether all correct answers for a given goal (i.e. all
logical consequences) can be obtained by SLD-resolution. The answer is given by the
following theorem, called the completeness theorem for SLD-resolution (due to Clark
(1979)).
Theorem 3.22 (Completeness of SLD-resolution) Let P be a deﬁnite program,
←A1, . . . , An a deﬁnite goal and ℜa computation rule. If P |= ∀(A1 ∧· · · ∧An)σ,
there exists a refutation of ←A1, . . . , An via ℜwith the computed answer substitution
θ such that (A1 ∧· · · ∧An)σ is an instance of (A1 ∧· · · ∧An)θ.
The proof of the theorem is not very diﬃcult but is rather long and requires some
auxiliary notions and lemmas. It is therefore omitted. The interested reader is referred
to e.g. Apt (1990), Lloyd (1987), St¨ark (1990) or Doets (1994).
Theorem 3.22 shows that even if all correct answers cannot be computed using
SLD-resolution, every correct answer is an instance of some computed answer. This is

52
Chapter 3:
SLD-Resolution
Figure 3.6: Depth-ﬁrst search with backtracking
due to the fact that only most general uniﬁers — not arbitrary uniﬁers — are computed
in derivations. However every particular correct answer is a special instance of some
computed answer since all uniﬁers can always be obtained by further instantiation of
a most general uniﬁer.
Example 3.23 Consider the goal clause ←p(X) and the following program:
p(f(Y )).
q(a).
Clearly, {X/f(a)} is a correct answer to the goal — that is:
{p(f(Y )), q(a)} |= p(f(a))
However, the only computed answer substitution (up to renaming) is {X/f(Y0)}.
Clearly, this is a more general answer than {X/f(a)}.
The completeness theorem conﬁrms existence of a refutation which produces a more
general answer than any given correct answer. However the problem of how to ﬁnd this
refutation is still open. The refutation corresponds to a complete path in the SLD-tree
of the given goal and computation rule. Thus the problem reduces to a systematic
search of the SLD-tree. Existing Prolog systems often exploit some ordering on the
program clauses, e.g. the textual ordering in the source program. This imposes the
ordering on the edges descending from a node of the SLD-tree.
The tree is then
traversed in a depth-ﬁrst manner following this ordering. For a ﬁnite SLD-tree this
strategy is complete. Whenever a leaf node of the SLD-tree is reached the traversal
continues by backtracking to the last preceding node of the path with unexplored
branches (see Figure 3.6).
If it is the empty goal the answer substitution of the
completed refutation is reported before backtracking. However, as discussed in Section
3.3 the SLD-tree may be inﬁnite.
In this case the traversal of the tree will never

3.6 Proof Trees
53
Figure 3.7: Breadth-ﬁrst search
terminate and some existing answers may never be computed. This can be avoided by a
diﬀerent strategy of tree traversal, like for example the breadth-ﬁrst strategy illustrated
in Figure 3.7. However this creates technical diﬃculties in implementation due to very
complicated memory management being needed in the general case. Because of this,
the majority of Prolog systems use the depth-ﬁrst strategy for traversal of the SLD-
tree.
3.6
Proof Trees
The notion of SLD-derivation resembles the notion of derivation used in formal gram-
mars (see Chapter 10). By analogy to grammars a derivation can be mapped into
a graph called a derivation tree. Such a tree is constructed by combining together
elementary trees representing renamed program clauses. A deﬁnite clause of the form:
A0 ←A1, . . . , An
(n ≥0)
is said to have an elementary tree of one of the forms:
A0
q
  @
@
q
q
A1 · · · An
if n > 0
A0
q
if n = 0
Elementary trees from a deﬁnite program P may be combined into derivation trees by
combining the root of a (renamed) elementary tree labelled by p(s1, . . . , sn) with the
leaf of another (renamed) elementary tree labelled by p(t1, . . . , tn). The joint node is
labelled by an equation p(t1, . . . , tn) .= p(s1, . . . , sn).2 A derivation tree is said to be
complete if it is a tree and all of its leaves are labelled by
. Complete derivation trees
are also called proof trees. Figure 3.8 depicts a proof tree built out of the following
elementary trees from the program in Example 3.14:
2Strictly speaking equations may involve terms only.
Thus, the notation p(t1, . . . , tn)
.=
p(s1, . . . , sn) should be viewed as a shorthand for t1 .= s1, . . . , tn .= sn.

54
Chapter 3:
SLD-Resolution
grandfather(X0, Z0)




H
H
H
H
father(X0, Y0)
parent(Y0, Z0)
.=
.=
father(a, b)
parent(X1, Y1)
mother(X1, Y1)
.=
mother(b, c)
Figure 3.8: Consistent proof tree
grandfather(X0, Z0)
q
  @
@
q
q
father(X0, Y0) parent(Y0, Z0)
parent(X1, Y1)
q
q
mother(X1, Y1)
father(a, b)
q
mother(b, c)
q
A derivation tree or a proof tree can actually be viewed as a collection of equations.
In the particular example above:
{X0 .= a, Y0 .= b, Y0 .= X1, Z0 .= Y1, X1 .= b, Y1 .= c}
In this example the equations can be transformed into solved form:
{X0 .= a, Y0 .= b, X1 .= b, Z0 .= c, Y1 .= c}
A derivation tree or proof tree whose set of equations has a solution (i.e. can be
transformed into a solved form) is said to be consistent. Note that the solved form
may be obtained in many diﬀerent ways. The solved form algorithm is not speciﬁc as
to what equation to select from a set — any selection order yields an equivalent solved
form.
Not all derivation trees are consistent. For instance, the proof tree in Figure 3.9
does not contain a consistent collection of equations since the set:
{X0 .= a, Y0 .= b, Y0 .= X1, Z0 .= c, X1 .= a, Y1 .= b}
does not have a solved form.
The idea of derivation trees may easily be extended to incorporate also atomic goals.
An atomic goal ←A may be seen as an elementary tree with a single node, labelled by
A, which can only be combined with the root of other elementary trees. For instance,
proof tree (a) in Figure 3.10 is a proof tree involving the goal ←grandfather(X, Y ).
Note that the solved form of the associated set of equations provides an answer to the
initial goal — for instance, the solved form:
{X .= a, Y .= c, X0 .= a, Y0 .= b, Y0 .= X1, Z0 .= Y1, X1 .= b, Y1 .= c}

3.6 Proof Trees
55
grandfather(X0, Z0)




H
H
H
H
father(X0, Y0)
parent(Y0, Z0)
.=
.=
father(a, b)
parent(X1, Y1)
father(X1, Y1)
.=
father(a, b)
Figure 3.9: Inconsistent proof tree
of the equations associated with proof tree (a) in Figure 3.10 provides an answer
substitution {X/a, Y/c} to the initial goal.
The solved form of the equations in a consistent derivation tree can be used to
simplify the derivation tree by instantiating the labels of the tree. For instance, ap-
plying the substitution {X/a, Y/c, X0/a, Y0/b, Z0/c, X1/b, Y1/c} (corresponding to the
solved form above) to the nodes in the proof tree yields a new proof tree (depicted in
Figure 3.11). However, nodes labelled by equations of the form A .= A will usually
be abbreviated A so that the tree in Figure 3.11 is instead written as the tree (d) in
Figure 3.10. The equations of the simpliﬁed tree are clearly consistent.
Thus the search for a consistent proof tree can be seen as two interleaving processes:
The process of combining elementary trees and the simpliﬁcation process working on
the equations of the already constructed part of the derivation tree. Note in particular
that it is not necessary to simplify the whole tree at once — the tree (a) has the
following associated equations:
{X .= X0, Y .= Z0, X0 .= a, Y0 .= b, Y0 .= X1, Z0 .= Y1, X1 .= b, Y1 .= c}
Instead of solving all equations only the underlined equations may be solved, resulting
in an mgu θ1 = {Y0/X1, Z0/Y1}. This may be applied to the tree (a) yielding the tree
(b). The associated equations of the new tree can be obtained by applying θ1 to the
previous set of equations after having removed the previously solved equations:
{X .= X0, Y .= Y1, X0 .= a, X1 .= b, X1 .= b, Y1 .= c}
Solving of the new underlined equations yields a mgu θ2 = {X1/b, Y1/c} resulting in
the tree (c) and a new set of equations:
{X .= X0, Y .= c, X0 .= a, b .= b}
Solving all of the remaining equations yields θ3 = {X/a, Y/c, X0/a} and the ﬁnal tree
(d) which is trivially consistent.
Notice that we have not mentioned how proof trees are to be constructed or in
which order the equations are to be solved or checked for consistency. In fact, a whole
spectrum of strategies is possibile. One extreme is to ﬁrst build a complete proof

56
Chapter 3:
SLD-Resolution
grandfather(X, Y )
.=
grandfather(X0, Z0)




H
H
H
H
father(X0, Y0)
parent(Y0, Z0)
.=
.=
father(a, b)
parent(X1, Y1)
mother(X1, Y1)
.=
mother(b, c)
(a)
grandfather(X, Y )
.=
grandfather(X0, Y1)




H
H
H
H
father(X0, X1)
.=
father(a, b)
parent(X1, Y1)
mother(X1, Y1)
.=
mother(b, c)
(b)
grandfather(X, Y )
.=
grandfather(X0, c)




H
H
H
H
father(X0, b)
.=
father(a, b)
parent(b, c)
mother(b, c)
(c)
grandfather(a, c)




H
H
H
H
father(a, b)
parent(b, c)
mother(b, c)
(d)
Figure 3.10: Simpliﬁcation of proof tree
tree and then check if the equations are consistent. At the other end of the spectrum
equations may be checked for consistency while building the tree. In this case there
are two possibilities — either the whole set of equations is checked every time a new
equation is added or the tree is simpliﬁed by trying to solve equations as soon as they
are generated. The latter is the approach used in Prolog — the tree is built in a
depth-ﬁrst manner from left to right and each time a new equation is generated the
tree is simpliﬁed.
From the discussion above it should be clear that many derivations may map
into the same proof tree. This is in fact closely related to the intuition behind the
independence of the computation rule — take “copies” of the clauses to be combined
together. Rename each copy so that it shares no variables with the other copies. The
clauses are then combined into a proof tree. A computation rule determines the order
in which the equations are to be solved but the solution obtained is independent of
this order (up to renaming of variables).

Exercises
57
grandfather(a, c)
.=
grandfather(a, c)




H
H
H
H
father(a, b)
parent(b, c)
.=
.=
father(a, b)
parent(b, c)
mother(b, c)
.=
mother(b, c)
Figure 3.11: Resolved proof tree
Exercises
3.1 What are the mgu’s of the following pairs of atoms:
p(X, f(X))
p(Y, f(a))
p(f(X), Y, g(Y ))
p(Y, f(a), g(a))
p(X, Y, X)
p(f(Y ), a, f(Z))
p(a, X)
p(X, f(X))
3.2 Let θ be an mgu of s and t and ω a renaming substitution. Show that θω is
an mgu of s and t.
3.3 Let θ and σ be substitutions. Show that if θ ⪯σ and σ ⪯θ then there exists
a renaming substitution ω such that σ = θω.
3.4 Let θ be an idempotent mgu of s and t. Prove that σ is a uniﬁer of s and t iﬀ
σ = θσ.
3.5 Consider the following deﬁnite program:
p(Y ) ←q(X, Y ), r(Y ).
p(X) ←q(X, X).
q(X, X) ←s(X).
r(b).
s(a).
s(b).
Draw the SLD-tree of the goal ←p(X) if Prolog’s computation rule is used.
What are the computed answer substitutions?
3.6 Give an example of a deﬁnite program, a goal clause and two computation
rules where one computation rule leads to a ﬁnite SLD-tree and where the
other computation rule leads to an inﬁnite tree.

58
Chapter 3:
SLD-Resolution
3.7 How many consistent proof trees does the goal ←p(a, X) have given the
program:
p(X, Y ) ←q(X, Y ).
p(X, Y ) ←q(X, Z), p(Z, Y ).
q(a, b).
q(b, a).
3.8 Let θ be a renaming substitution. Show that there is only one substitution σ
such that σθ = θσ = ϵ.
3.9 Show that if A ∈BP and ←A has a refutation of length n then A ∈TP ↑n.

Chapter 4
Negation in Logic Programming
4.1
Negative Knowledge
Deﬁnite programs express positive knowledge; the facts and the rules describe that
certain objects are in certain relations with one another.
The relations are made
explicit in the least Herbrand model — the set of all ground atomic consequences of
the program. For instance, consider the following program:
above(X, Y ) ←on(X, Y ).
above(X, Y ) ←on(X, Z), above(Z, Y ).
on(c, b).
on(b, a).
The program describes the situation depicted in Figure 1.2: The object ’C’ is on top
of ’B’ which is on top of ’A’ and an object is above a second object if it is either on top
of it or on top of a third object which is above the second object. The least Herbrand
model of the program looks as follows:
{on(b, a), on(c, b), above(b, a), above(c, b), above(c, a)}
Note that neither the program nor its least Herbrand model include negative infor-
mation, such as ’A’ is not on top of any box or ’B’ is not above ’C’. Also in real
life the negative information is seldom stated explicitly. Swedish Rail in its timetable
explicitly states that there is a daily train from Link¨oping to Stockholm scheduled to
depart at 9:22, but it does not explicitly state that there is no train departing at 9:56
or 10:24.
Thus, in many real-life situations the lack of information is taken as evidence to
the contrary — since the timetable does not indicate a departure from Link¨oping
to Stockholm at 10:24 one does not plan to take such a train. This is because we
59

60
Chapter 4:
Negation in Logic Programming
←above(b, c).
←on(b, c).
←on(b, Z0), above(Z0, c).
←above(a, c).
←on(a, c).
←on(a, Z2), above(Z2, c).





H
H
H
H
H





H
H
H
H
H
Figure 4.1: Finitely failed SLD-tree
assume that the timetable lists all trains from Link¨oping to Stockholm. This idea is
the intuition behind the so-called closed world assumption (cwa).
The closed world assumption is a mechanism that allows us to draw negative
conclusions based on the lack of positive information.
The cwa is a rule which is
used to derive the statement ¬A provided that A is a ground atomic formula which
cannot be derived by the inference rules of the used system, e.g. by SLD-resolution.
This can be expressed as the following “inference rule”1:
P
0 A
¬A
(cwa)
In the case of a sound and complete derivability relation the condition P
0 A is
equivalent to P ̸|= A.
Thus, in the case of SLD-resolution (which is both sound
and complete) the condition could be replaced by A ̸∈MP . For instance, the formula
above(b, c) is not derivable from the program P by means of SLD-resolution, see Figure
4.1 (nor by any other sound system, since above(b, c) is not a logical consequence of
P). By the completeness of SLD-resolution it follows that P ̸|= above(b, c). Thus,
using cwa it can be inferred that ¬above(b, c).
However there are several problems with the cwa.
One is that non-provability
for deﬁnite programs is undecidable in the general case. Thus it is not possible to
determine if the rule is applicable or not. A somewhat weaker version of the cwa rule
therefore is to say that ¬A is derivable from P if the goal ←A has a ﬁnitely failed
SLD-tree w.r.t. P:
←A has a ﬁnitely failed SLD-tree
¬A
(naf )
This is called the negation as (ﬁnite) failure rule (naf ). It should be contrasted with
the cwa which may also be called the negation as inﬁnite failure rule. To illustrate
the diﬀerence between the two approaches the program above is extended with the
following (obviously true) clause:
above(X, Y ) ←above(X, Y ).
1To be more precise, this would not really qualify as an inference rule in the traditional sense since
P
0 A is not a logic formula, but a statement of the meta language.

4.2 The Completed Program
61
The SLD-tree of the goal ←above(b, c) still contains no refutations but the tree is now
inﬁnite. Thus, it cannot be concluded that ¬above(b, c) using naf . However, it still
follows from the cwa.
A second, and more serious problem with the cwa (and the naf ) is that it is unsound
— ¬above(b, c) is not a logical consequence of the program(s) above. In fact, any proof
system that permits inferring a negative literal from a deﬁnite program is unsound!
The reason is that the Herbrand base BP (in which all ground atomic formulas are
true) is always a model of P. There are two principal approaches to repair this problem.
One is to view the program as a shorthand for another, larger, program from which
the negative literal follows. The second approach is to redeﬁne the notion of logical
consequence so that only some of the models of program (e.g. the least Herbrand
model) are considered. The eﬀect in both cases is to discard some “uninteresting”
models of the program. The ﬁrst part of this chapter gives a logical justiﬁcation of
the naf -rule using the completion comp(P) of a deﬁnite program P.
Once able to draw negative conclusions it is natural to extend the language of
deﬁnite programs to permit the use of negative literals in the body of a clause. The
ﬁnal part of this chapter therefore introduces the language of general (logic) programs
and introduces the notion of SLDNF-resolution that combines the SLD inference rule
with the negation as ﬁnite failure rule. The two ﬁnal sections of the chapter survey
two alternative approaches to justify inference of negative conclusions from general
programs.
The ﬁrst idea attempts to repair some problems with trying to justify
negation as ﬁnite failure in terms of the program completion. The second approach,
called the well-founded semantics, generalizes the closed world assumption (and thus,
negation as inﬁnite failure) from deﬁnite to general programs. Both approaches are
based on an extension of classical logic from two into three truth-values.
4.2
The Completed Program
As pointed out above, any proof system that allows negative literals to be derived
from a deﬁnite program is unsound. The objective of this section therefore is to give a
logical justiﬁcation of the naf -rule. The idea presented below is due to K. Clark (1978)
and relies on the claim that when writing a deﬁnite program P the programmer really
means something more than just a set of deﬁnite clauses. The “intended program”
can be formalized and is called the completion of P. Consider the following deﬁnition:
above(X, Y ) ←on(X, Y ).
above(X, Y ) ←on(X, Z), above(Z, Y ).
The rules state that an object is above a second object if the ﬁrst object is (1) on top
of the second object or (2) on top of a third object which is above the second object.
This could also be written thus:
above(X, Y ) ←on(X, Y ) ∨(on(X, Z), above(Z, Y ))
Now what if the if-statement is instead replaced by an if-and-only-if-statement?
above(X, Y ) ↔on(X, Y ) ∨(on(X, Z), above(Z, Y ))

62
Chapter 4:
Negation in Logic Programming
This formula states that X is above Y if and only if at least one of the conditions are
true. That is, if none of the conditions hold it follows that X is not above Y ! This is
the intuition used to explain the negation as failure.
Unfortunately combining deﬁnite clauses as illustrated above is only possible if the
clauses have identical heads. Thus, consider the following clauses:
on(c, b).
on(b, a).
By simple transformation the program can be rewritten as follows:
on(X1, X2) ←X1 .= c, X2 .= b.
on(X1, X2) ←X1 .= b, X2 .= a.
These clauses can be combined into one formula, where implication is replaced by the
equivalence connective. In that way two if-statements have been combined into one
if-and-only-if-statement:
on(X1, X2) ↔(X1 .= c, X2 .= b) ∨(X1 .= b, X2 .= a)
The logical reading of this is that X1 is on top of X2 if and only if either X1 = c and
X2 = b or X1 = b and X2 = a.
The idea outline above will now be formalized as a special transformation of a
deﬁnite program P. The resulting set of formulas is called the completion of P:
Deﬁnition 4.1 (Completed program) Let P be a deﬁnite program. The comple-
tion comp(P) of P is the formulas obtained from the following three transformation
steps:
(i) For every predicate symbol p replace each clause C of the form:
p(t1, . . . , tm) ←L1, . . . , Ln
(n ≥0)
by the formula:
p(X1, . . . , Xm) ←∃Y1, . . . , Yi(X1 .= t1, . . . , Xm .= tm, L1, . . . , Ln)
where Y1, . . . , Yi are all the variables in C and X1, . . . , Xm are distinct variables
which do not appear in C.
Remark:
Note that the ﬁrst step does not really change the logical under-
standing of the clauses provided that the appropriate deﬁnition of .= is added
(this is discussed in the third step).
(ii) For each predicate symbol p replace all formulas:
p(X1, . . . , Xm) ←B1
...
p(X1, . . . , Xm) ←Bj

4.2 The Completed Program
63
by the formula:
∀X1, . . . , Xm(p(X1, . . . , Xm) ↔B1 ∨· · · ∨Bj)
if j > 0
∀X1, . . . , Xm(¬p(X1, . . . , Xm))
if j = 0
(iii) Finally the program is extended with the following free equality axioms deﬁning
the equalities introduced in step (i) (To be more precise some of the axioms are
axiom schemata making the resulting set of axioms inﬁnite):
∀(X .= X)
(E1)
∀(X .= Y ⊃Y .= X)
(E2)
∀(X .= Y ∧Y .= Z ⊃X .= Z)
(E3)
∀(X1 .= Y1 ∧· · · ∧Xn .= Yn ⊃f(X1, . . . , Xn) .= f(Y1, . . . , Yn))
(E4)
∀(X1 .= Y1 ∧· · · ∧Xn .= Yn ⊃(p(X1, . . . , Xn) ⊃p(Y1, . . . , Yn)))
(E5)
∀(f(X1, . . . , Xn) .= f(Y1, . . . , Yn) ⊃X1 .= Y1 ∧· · · ∧Xn .= Yn)
(E6)
∀(¬f(X1, . . . , Xm) .= g(Y1, . . . , Yn))
(if f/m ̸= g/n)
(E7)
∀(¬X .= t)
(if X is a proper subterm of t)
(E8)
The free equality axioms enforce .= to be interpreted as the identity relation in all
Herbrand interpretations. Axioms E1 −E3 must be satisﬁed in order for .= to be an
equivalence relation. Axioms E4 −E5 enforcing .= to be a congruence relation. Axioms
E1 −E5 are sometimes dropped and replaced by the essential constraint that .= always
denotes the identity relation. Therefore the most interesting axioms are E6 −E8 which
formalize the notion of uniﬁcation. They are in fact similar to cases 1, 2 and 5a in
the solved form algorithm. Axiom E6 states that if two compound terms with the
same functor are equal, then the arguments must be pairwise equal. Axiom E7 states
that two terms with distinct functors/constants are not equal and axiom E8 essentially
states that no nesting of functions can return one of its arguments as its result.
Example 4.2 We now construct the completion of the above/2-program again. The
ﬁrst step yields:
above(X1, X2) ←∃X, Y (X1 .= X, X2 .= Y, on(X, Y ))
above(X1, X2) ←∃X, Y, Z(X1 .= X, X2 .= Y, on(X, Z), above(Z, Y ))
on(X1, X2) ←(X1 .= c, X2 .= b)
on(X1, X2) ←(X1 .= b, X2 .= a)
Step two yields:
∀X1, X2(above(X1, X2) ↔∃X, Y (. . .) ∨∃X, Y, Z(. . .))
∀X1, X2(on(X1, X2) ↔(X1 .= c, X2 .= b) ∨(X1 .= b, X2 .= a))
Finally the program is extended with the free equality axioms described above.
Example 4.3 Consider the following program that describes a “world” containing
two parents only, Mary and Kate, both of which are female:

64
Chapter 4:
Negation in Logic Programming
father(X) ←male(X), parent(X).
parent(mary).
parent(kate).
Step one of the transformation yields:
father(X1) ←∃X(X1 .= X, male(X), parent(X))
parent(X1) ←X1 .= mary
parent(X1) ←X1 .= kate
Step two yields:
∀X1(father(X1) ↔∃X(X1 .= X, male(X), parent(X)))
∀X1(parent(X1) ↔X1 .= mary ∨X1 .= kate)
∀X1(¬male(X1))
Note the presence of the formula ∀X1(¬male(X1)) embodying the fact that there are
no males in the world under consideration.
The completion comp(P) of a deﬁnite program P preserves all the positive literals
entailed by P. Hence, if P |= A then comp(P) |= A. It can also be shown that no
information is lost when completing P, i.e. comp(P) |= P (see exercise 4.4) and that no
positive information is added, i.e. if comp(P) |= A then P |= A. Thus, in transforming
P into comp(P) no information is removed from P and only negative information is
added to the program. As concerns negative information it was previously concluded
that no negative literal can be a logical consequence of a deﬁnite program. However,
by replacing the implications in P by equivalences in comp(P) it becomes possible
to infer negative information from the completion of a deﬁnite program. This is the
traditional way of justifying the naf -rule, whose soundness is due to Clark (1978):
Theorem 4.4 (Soundness of negation as ﬁnite failure) Let P be a deﬁnite
program and ←A a deﬁnite goal.
If ←A has a ﬁnitely failed SLD-tree then
comp(P) |= ∀(¬A).
Note that soundness is preserved even if A is not ground. For instance, since the goal
←on(a, X) is ﬁnitely failed, it follows that comp(P) |= ∀(¬on(a, X)).
The next theorem, due to Jaﬀar, Lassez and Lloyd (1983), shows that negation
as ﬁnite failure is also complete (the proof of this theorem as well as the soundness
theorem can also be found in Lloyd (1987), Apt (1990) or Doets (1994)):
Theorem 4.5 (Completeness of negation as ﬁnite failure) Let P be a deﬁnite
program. If comp(P) |= ∀(¬A) then there exists a ﬁnitely failed SLD-tree of ←A.
Note that the theorem only states the existence of a ﬁnitely failed SLD-tree. As already
pointed out in Chapter 3 it may very well happen that the SLD-tree of a goal is ﬁnite
under one computation rule, but inﬁnite under another. In particular, the theorem
does not hold if the computation rule is ﬁxed to that of Prolog. However, the situation
is not quite as bad as it may ﬁrst seem.
An SLD-derivation is said to be fair if it is either ﬁnite or every occurrence of
an atom (or its instance) in the derivation is eventually selected by the computation

4.3 SLDNF-resolution for Deﬁnite Programs
65
rule. An SLD-tree is said to be fair if all its derivations are fair. Jaﬀar, Lassez and
Lloyd showed that the completeness result above holds for any fair SLD-tree. Clearly,
derivations in Prolog are not fair so negation as failure as implemented in Prolog is not
complete. Fair SLD-derivations can be implemented by always selecting the leftmost
subgoal and appending new subgoals to the end of the goal. However, very few logic
programming systems support fair derivations for eﬃciency reasons.
4.3
SLDNF-resolution for Deﬁnite Programs
In the previous chapter SLD-resolution was introduced as a means of proving that
some instance of a positive literal is a logical consequence of a deﬁnite program (and
its completion). Then, in the previous section, it was concluded that also negative
literals can be derived from the completion of a deﬁnite program. By combining SLD-
resolution with negation as ﬁnite failure it is possible to generalize the notion of goal
to include both positive and negative literals. Such goals are called general goals:
Deﬁnition 4.6 (General goal) A general goal is a goal of the form:
←L1, . . . , Ln.
(n ≥0)
where each Li is a positive or negative literal.
The combination of SLD-resolution, to resolve positive literals, and negation as (ﬁnite)
failure, to resolve negative literals, is called SLDNF-resolution:
Deﬁnition 4.7 (SLDNF-resolution for deﬁnite programs) Let P be a deﬁnite
program, G0 a general goal and ℜa computation rule. An SLDNF-derivation of G0
(using P and ℜ) is a ﬁnite or inﬁnite sequence of general goals:
G0
C0
 G1 · · · Gn−1
Cn−1
 Gn · · ·
where Gi
Ci
 Gi+1 if either:
(i) the ℜ-selected literal in Gi is positive and Gi+1 is derived from Gi and Ci by
one step of SLD-resolution;
(ii) the ℜ-selected literal in Gi is of the form ¬A, the goal ←A has a ﬁnitely failed
SLD-tree and Gi+1 is obtained from Gi by removing ¬A (in which case Ci is a
special marker
zz).
Each step of an SLDNF-derivation produces a substitution — in the case of (i) an
mgu and in the case of (ii) the empty substitution.
Thus, a negative literal ¬A succeeds if ←A has a ﬁnitely failed SLD-tree. Dually, ¬A
ﬁnitely fails if ←A succeeds. It may also happen that ←A has an inﬁnite SLD-tree
without refutations (i.e. inﬁnite failure). Hence, apart from refutations and inﬁnite
derivations there are two more classes of complete SLDNF-derivations under a given
computation rule:

66
Chapter 4:
Negation in Logic Programming
←on(X, Y ), ¬on(Z, X).
←¬on(Z, c).
←¬on(Z, b).

zz





H
H
H
H
H
←on(Z, c).
zz
←on(Z, b).

·················
·················
·················
·················
Figure 4.2: SLDNF-derivations of ←on(X, Y ), ¬on(Z, X)
• A derivation is said to be (ﬁnitely) failed if (1) the selected literal is positive and
does not unify with the head of any clause or (2) the selected literal is negative
and ﬁnitely failed;
• A derivation is said to be stuck if the selected subgoal is of the form ¬A and
←A is inﬁnitely failed;
Example 4.8 Consider the following program describing a world where the block ’C’
is piled on top of ’B’ which is on top of ’A’:
on(c, b).
on(b, a).
As shown in Figure 4.2 the goal ←on(X, Y ), ¬on(Z, X) has an SLDNF-refutation
with the computed answer substitution {X/c, Y/b}. (In the ﬁgure failed derivations
are terminated with the marker
zz.)
As might be expected SLDNF-resolution is sound. After all, both SLD-resolution and
negation as ﬁnite failure are sound:
Theorem 4.9 (Soundness of SLDNF-resolution) Let P be a deﬁnite program
and ←L1, . . . , Ln a general goal. If ←L1, . . . , Ln has an SLDNF-refutation with the
computed answer substitution θ, then comp(P) |= ∀(L1θ ∧· · · ∧Lnθ).
However, contrary to what might be expected, SLDNF-resolution is not complete even
though both SLD-resolution and negation as ﬁnite failure are complete.
A simple
counter-example is the goal ←¬on(X, Y ) which intuitively corresponds to the query:
“Are there any blocks, X and Y , such that X is not on top of Y ?”
(†)
One expects several answers to this query. For instance, ’A’ is not on top of any block.
However, the only SLDNF-derivation of ←¬on(X, Y ) fails since the goal ←on(X, Y )
succeeds. The root of the problem is that our notion of failed SLDNF-derivation is
too conservative. The success of ←on(X, Y ) does not necessarily mean that there is
no block which is not on top of another block — only that there exists at least one
block which is on top of another block. Of course, if ←on(X, Y ) succeeds with the
empty computed answer substitution then we can conclude that every block is on top
of every block in which case (†) should be answered negatively.

4.4 General Logic Programs
67
The problem stems from the fact that negation as ﬁnite failure, in contrast to
SLD-resolution, is only a test. Remember that according to the deﬁnition of SLDNF-
resolution and soundness and completeness of negation as ﬁnite failure it holds that:
¬on(X, Y ) succeeds
iﬀ
←on(X, Y ) has a ﬁnitely failed SLD-tree
iﬀ
comp(P) |= ∀(¬on(X, Y ))
Hence the goal ←¬on(X, Y ) should not be read as an existential query but rather as
a universal test:
“For all blocks, X and Y , is X not on top of Y ?”
This query has a negative answer in the intended model, since e.g. ’B’ is on top of
’A’. The problem above is due to the quantiﬁcation of the variables in the negative
literal. If the query above is rephrased as ←¬on(a, b) then SLDNF-resolution yields a
refutation since ←on(a, b) ﬁnitely fails. It is sometimes assumed that the computation
rule is only allowed to select a negative literal ¬A if A is ground or if ←A has an
empty computed answer substitution. Such computation rules are said to be safe. We
will return to this issue when extending SLDNF-resolution to programs containing
negative literals.
4.4
General Logic Programs
Once able to infer both negative and positive literals it is natural to extend the lan-
guage of deﬁnite programs to include clauses that contain both positive and negative
literals in bodies. Such formulas are called general clauses:2
Deﬁnition 4.10 (General clause) A general clause is a formula:
A0 ←L1, . . . , Ln
where A0 is an atomic formula and L1, . . . , Ln are literals (n ≥0).
Thus, by analogy to deﬁnite clauses and deﬁnite programs:
Deﬁnition 4.11 (General program) A general (logic) program is a ﬁnite set of
general clauses.
By means of general clauses it is possible to extend the “blocks world” with the
following relations:
founding(X) ←on(Y, X), on ground(X).
on ground(X) ←¬oﬀground(X).
oﬀground(X) ←on(X, Y ).
on(c, b).
on(b, a).
2General programs are sometimes also called normal logic programs in the literature.

68
Chapter 4:
Negation in Logic Programming
The ﬁrst clause states that a founding block is one which is on the ground and has
another block on top of it. The second clause states that a block which is not oﬀ
ground is on the ground and the third clause says that a block which is on top of
another block is oﬀground.
The new language of general programs introduces a number of subtleties in addition
to those already touched upon earlier in this chapter. For instance, it is not obviously
clear how to understand a general program logically. Moreover, given a particular
logical understanding, what kind of proof system should be used?
There is no single answer to these questions and only some of them will be ad-
dressed here. The remaining part of this chapter will mainly be devoted to the idea
initiated above — that of program completion and SLDNF-resolution. However, some
alternative approaches will also be discussed.
Although the language of programs has now been enriched it is still not possible for
a negative literal to be a logical consequence of a general program P. The reason
is the same as for deﬁnite programs — the Herbrand base is a model of P in which
all negative literals are false. By analogy to deﬁnite programs question arises how
to interpret general programs in order to allow for “sound” negative inferences to be
made. Fortunately, the notion of program completion can be applied also to general
programs. For instance, the completion of:
win(X) ←move(X, Y ), ¬win(Y ).
contains the formula:
∀X1(win(X1) ↔∃X, Y (X1 .= X, move(X, Y ), ¬win(Y )))
However, the completion of general programs sometimes leads to paradoxical situa-
tions. Consider the following general clause:
p ←¬p.
Then the completed program contains the formula p ↔¬p. The inconsistency of the
completed program is due to p/0 being deﬁned in terms of its own complement. Such
situations can be avoided by employing a special discipline when writing programs.
The idea is to build the program in “layers” (called strata), thereby enforcing the
programmer not to refer to the negation of a relation until the relation is fully deﬁned
(in a lower stratum). The following is a formal deﬁnition of the class of stratiﬁed
programs (let the subset of all clauses in P with p in the head be denoted P p):
Deﬁnition 4.12 (Stratiﬁed program) A general program P is said to be stratiﬁed
iﬀthere exists a partitioning P1 ∪· · · ∪Pn of P such that:3
• if p(. . .) ←. . . , q(. . .), . . . ∈Pi then P q ⊆P1 ∪· · · ∪Pi;
• if p(. . .) ←. . . , ¬q(. . .), . . . ∈Pi then P q ⊆P1 ∪· · · ∪Pi−1.
For instance, the following program is stratiﬁed:
3Note that there are often many partitionings of a program that satisfy the requirements.

4.4 General Logic Programs
69
P2 :
founding(X) ←on(Y, X), on ground(X).
on ground(X) ←¬oﬀground(X).
P1 :
oﬀground(X) ←on(X, Y ).
on(c, b).
on(b, a).
It was shown by Apt, Blair and Walker (1988) that the completion of a stratiﬁed pro-
gram is always consistent so that the situation described above cannot occur. However,
stratiﬁcation is only a suﬃcient condition for consistency; To determine if a general
program is stratiﬁed is decidable, but the problem of determining if the completion of a
general program is consistent or not is undecidable. Hence there are general programs
which are not stratiﬁed but whose completion is consistent.
For stratiﬁed programs there is also a natural restatement of the least Herbrand
model. It can be made in terms of the immediate consequence operator originally
deﬁned for deﬁnite programs. However, general clauses may contain negative literals.
Thus, if I is a Herbrand interpretation we note that I |= A iﬀA ∈I and I |= ¬A iﬀ
A ̸∈I. The revised immediate consequence operator TP is deﬁned as follows:
TP (I)
:=
{A0 | A0 ←L1, . . . , Ln ∈ground(P) ∧I |= L1, . . . , Ln}
Then let TP ↑ω(I) denote the limit of the sequence:
TP ↑0(I)
:=
I
TP ↑(n + 1)(I)
:=
TP(TP ↑n(I)) ∪TP ↑n(I)
Now, consider a program stratiﬁed by P = P1 ∪· · · ∪Pn. It is possible to deﬁne a
canonical Herbrand model of P stratum-by-stratum as follows:
M1
:=
TP1 ↑ω(?)
M2
:=
TP2 ↑ω(M1)
...
Mn
:=
TPn ↑ω(Mn−1)
Apt, Blair and Walker (1988) showed that MP := Mn is a minimal Herbrand model
— called the standard model — of P. It was also shown that the model does not
depend on how the program is partitioned (as long as it is stratiﬁed). For instance,
the standard model of the program P1 ∪P2 above may be constructed thus:
M1
=
{on(b, a), on(c, b), oﬀground(b), oﬀground(c)}
M2
=
{on ground(a), founding(a)} ∪M1
The model conforms with our intuition of the intended model. However, in contrast
to deﬁnite programs MP is not necessarily the only minimal Herbrand model. For
instance, the program:
loops ←¬halts

70
Chapter 4:
Negation in Logic Programming
has two minimal Herbrand models — the standard model {loops} and a non-standard
model {halts}. This is obviously a consequence of the fact that the clause is logically
equivalent to loops ∨halts (and halts ←¬loops).
However, by writing this as an
implication with loops/0 in the consequent it is often argued that unless there is
evidence for halts/0 from the rest of the program we should prefer to conclude loops/0.
For instance, the following is an alternative (counter-intuitive) minimal model of the
program P1 ∪P2 above:
{on(b, a), on(c, b), oﬀground(a), oﬀground(b), oﬀground(c)}
We return to the issue of canonical models of general programs when introducing the
well-founded semantics in Section 4.7.
4.5
SLDNF-resolution for General Programs
In Section 4.3 the notion of SLDNF-resolution for deﬁnite programs and general goals
was introduced. Informally speaking SLDNF-resolution combines the SLD-resolution
principle with the following principles:
¬A succeeds iﬀ←A has a ﬁnitely failed SLD-tree
¬A ﬁnitely fails iﬀ←A has an SLD-refutation
When moving from deﬁnite to general programs the situation gets more complicated
— in order to prove ¬A there must be a ﬁnitely failed tree for ←A. But that tree
may contain new negative literals which may either succeed or ﬁnitely fail.
This
complicates the deﬁnition of SLDNF-resolution for general programs quite a bit. For
instance, paradoxical situations may occur when predicates are deﬁned in terms of
their own complement. Consider the non-stratiﬁed program:
p ←¬p
Given an initial goal ←p a derivation ←p
 ←¬p can be constructed. The question
is, whether the derivation can be completed. It can be extended into a refutation if
←p ﬁnitely fails. Alternatively, if ←p has a refutation then the derivation fails. Both
cases are clearly impossible since ←p cannot have a refutation and be ﬁnitely failed
at the same time!
We now introduce the notions of SLDNF-derivation and SLDNF-tree, similar to the
notions of SLD-derivation and SLD-tree used for SLD-resolution. Thus, an SLDNF-
derivation is a sequence of general goals and an SLDNF-tree the combination of all
possible SLDNF-derivations of a given initial goal under a ﬁxed computation rule. It
is diﬃcult to introduce the notions separately since SLDNF-derivations have to be
deﬁned in terms of SLDNF-trees and vice versa. Instead both notions are introduced
in parallel by the following notion of an SLDNF-forest. To simplify the deﬁnition the
following technical deﬁnitions are ﬁrst given: A forest is a set of trees whose nodes are
labelled by general goals. A subforest of F is any forest obtained by removing some of
the nodes (and all their children) in F. Two forests F1 and F2 are considered to be
equivalent if they contain trees equal up to renaming of variables. Moreover, F1 is said
to be smaller than F2 if F1 is equivalent to a subforest of F2. Now the SLDNF-forest
of a goal is deﬁned as follows:

4.5 SLDNF-resolution for General Programs
71
Deﬁnition 4.13 (SLDNF-forest) Let P be a general program, G0 a general goal
and ℜa computation rule. The SLDNF-forest of G0 is the smallest forest (modulo
renaming of variables) such that:
(i) G0 is the root of a tree;
(ii) if G is a node in the forest whose selected literal is positive then for each clause C
such that G′ can be derived from G and C (with mgu θ), G has a child labelled
G′. If there is no such clause then G has a single child labelled
zz;
(iii) if G is a node in the forest whose selected literal is of the form ¬A (that is, G is
of the form ←L1, . . . , Li−1, ¬A, Li+1, . . . , Li+j), then:
• the forest contains a tree with root labelled ←A;
• if the tree with root ←A has a leaf
 with the empty computed answer
substitution, then G has a single child labelled
zz;
• if the tree with the root labelled ←A is ﬁnite and all leaves are labelled
zz, then G has a single child labelled ←L1, . . . , Li−1, Li+1, . . . , Li+j (the
associated substitution is ϵ);
Note that a selected negative literal ¬A fails only if ←A has a refutation with the
empty computed answer substitution. As will be shown below, this condition, which
was not needed when deﬁning SLDNF-resolution for deﬁnite programs, is absolutely
vital for the soundness of SLDNF-resolution of general programs.
The trees of the SLDNF-forest are called (complete) SLDNF-trees and the sequence
of all goals in a branch of an SLDNF-tree with root G is called a complete SLDNF-
derivation of G (under P and ℜ). The tree labelled by G0 is called the main tree. A
tree with root ←A is called subsidiary if ¬A is a selected literal in the forest. (As
shown below the main tree may also be a subsidiary tree.)
Example 4.14 Consider the following stratiﬁed program P:
founding(X) ←on(Y, X), on ground(X).
on ground(X) ←¬oﬀground(X).
oﬀground(X) ←on(X, Y ).
above(X, Y ) ←on(X, Y ).
above(X, Y ) ←on(X, Z), above(Z, Y ).
on(c, b).
on(b, a).
The SLDNF-forest of ←founding(X) is depicted in Figure 4.3. The main tree contains
one failed derivation and one refutation with the computed answer substitution {X/a}.
The branches of an SLDNF-tree in the SLDNF-forest represent all complete SLDNF-
derivations of its root under the computation rule ℜ. There are four kinds of complete
SLDNF-derivations:
• inﬁnite derivations;

72
Chapter 4:
Negation in Logic Programming
←founding(X).
←on(Y0, X), on ground(X).
←on ground(b).
←on ground(a).
←¬oﬀground(b).
←¬oﬀground(a).

zz
←oﬀground(a).
←on(a, Y0).
zz
←oﬀground(b).
←on(b, Y0).






H
H
H
H
H
Figure 4.3: SLDNF-forest of ←founding(X)
←halts(X).
←¬loops(X).
←loops(X).
←loops(X).
∞
Figure 4.4: SLDNF-forest of ←halts(X)
• (ﬁnitely) failed derivations (that end in
zz);
• refutations (that end in
);
• stuck derivations (if none of the previous apply).
Figure 4.3 contains only refutations and failed derivations.
However, consider the
following example:
halts(X) ←¬loops(X).
loops(X) ←loops(X).
The SLDNF-forest depicted in Figure 4.4 contains an inﬁnite derivation (of the sub-
sidiary goal ←loops(X)) and a stuck derivation (of ←halts(X)). This illustrates
one cause of a stuck derivation — when a subsidiary tree contains only inﬁnite or
failed derivations. There are two more reasons why a derivation may get stuck. First
consider the following program:
paradox(X) ←¬ok(X).
ok(X) ←¬paradox(X).

4.5 SLDNF-resolution for General Programs
73
←paradox(X).
←¬ok(X).
←ok(X).
←¬paradox(X).
Figure 4.5: SLDNF-forest of ←paradox(X)
←on top(X).
←¬blocked(X).
←blocked(X).
←on(Y, X).

Y =a,X=b
Figure 4.6: SLDNF-forest of ←on top(X)
Figure 4.5 depicts the SLDNF-forest of the goal ←paradox(X).
(The ﬁgure also
illustrates an example where the main tree is also a subsidiary tree.)
This forest
contains two stuck derivations because the program contains a “loop through negation”
— in order for ←paradox(X) to be successful (resp. ﬁnitely failed) the derivation of
←ok(X) must be ﬁnitely failed (resp. successful). However, in order for ←ok(X) to
be ﬁnitely failed (resp. successful) the derivation of ←paradox(X) must be successful
(resp. ﬁnitely failed).
Note that Deﬁnition 4.13 enforce the SLDNF-forest to be the least forest satisfying
conditions (i)–(iii). If minimality of the forest is dropped, it is possible to get out
of the looping situation above — for instance, it would be consistent with (i)–(iii)
to extend ←ok(X) into a refutation if ←paradox(X) at the same time was ﬁnitely
failed (or vice versa).
The last cause of a stuck derivation is demonstrated by the following example:
on top(X) ←¬blocked(X).
blocked(X) ←on(Y, X).
on(a, b).
Clearly on top(a) should be derived from the program. However, the SLDNF-tree of
the goal ←on top(X) in Figure 4.6 contains no refutation. Note that the derivation
of ←on top(X) is stuck even though ←blocked(X) has a refutation. The reason
why the goal ←on top(X) is not ﬁnitely failed is that ←blocked(X) does not have
an empty computed answer substitution. Note also that it would be very counter-
intuitive if ←on top(X) had been ﬁnitely failed since it would have implied that no
element was on top. This last case, when a subsidiary SLDNF-tree has at least one
refutation, but none with the empty computed answer substitution is usually referred
to as ﬂoundering. Floundering can sometimes be avoided by making sure that negative
literals are selected by the computation rule only when they become ground. However,

74
Chapter 4:
Negation in Logic Programming
checking statically whether a negative literal ever becomes ground is undecidable.
What is even more unfortunate: most Prolog systems do not even check dynamically
if a derivation is ﬂoundering. That is, most Prolog systems assume that ¬A is ﬁnitely
failed if ←A has any refutation. Consider the goal ←¬on top(X) corresponding to
the query “is there an element which is not on top”. We expect the answer b, but Prolog
would answer incorrectly that all elements are not on top, i.e. ∀(¬on top(X)). The
reason is that Prolog considers ←on top(X) to be ﬁnitely failed since ←blocked(X)
has a refutation. Thus, SLDNF-resolution as implemented in most Prolog systems is
unsound. However, SLDNF-resolution as deﬁned in Deﬁnition 4.13 is sound:
Theorem 4.15 (Soundness of SLDNF-resolution) If P is a general program and
←L1, . . . , Ln a general goal then:
• If ←L1, . . . , Ln has a computed answer substitution θ then:
comp(P) |= ∀(L1θ ∧· · · ∧Lnθ)
• If ←L1, . . . , Ln has a ﬁnitely failed SLDNF-tree then:
comp(P) |= ∀(¬(L1 ∧· · · ∧Ln))
Example 4.16 Consider the following stratiﬁed program:
go well together(X, Y ) ←¬incompatible(X, Y )
incompatible(X, Y ) ←¬likes(X, Y )
incompatible(X, Y ) ←¬likes(Y, X)
likes(X, Y ) ←harmless(Y ).
likes(X, Y ) ←eats(X, Y ).
harmless(rabbit).
eats(python, rabbit).
As shown in Figure 4.7 go well together(rabbit, rabbit) is a logical consequence of the
completion. Also ¬incompatible(rabbit, rabbit) is a logical consequence due to the ﬁnite
failure of ←incompatible(rabbit, rabbit).
The deﬁnition of the SLDNF-forest should not be viewed as an implementation of
SLDNF-resolution — it only represents an ideal computation space in which soundness
can be guaranteed. The deﬁnition of the SLDNF-forest does not specify in which order
the trees and the derivations should be constructed. This is similar to the notion of
SLD-tree. Like in the case of SLD-resolution, Prolog uses a depth-ﬁrst strategy when
constructing an SLDNF-tree. If a negative literal (¬A) is encountered the construction
of the tree is temporarily suspended until either the tree for ←A is ﬁnitely failed or
a refutation of ←A is found. As already pointed out, a major problem with most
Prolog systems (and the ISO Prolog standard (1995)) is that a negative literal ¬A is
considered to be ﬁnitely failed if ←A has a refutation — no check is made to see if
the empty computed answer substitution was produced. This is yet another source
of unsound conclusions of Prolog systems in addition to the lack of occur-check! An
implementation of negation as ﬁnite failure as implemented in most Prolog systems is
given in the next chapter.

4.6 Three-valued Completion
75
←go well together(rabbit, rabbit)
←¬incompatible(rabbit, rabbit)

←incompatible(rabbit, rabbit)





H
H
H
H
H
←¬likes(rabbit, rabbit) ←¬likes(rabbit, rabbit)
zz
zz
←likes(rabbit, rabbit)





H
H
H
H
H
←harmless(rabbit) ←eats(rabbit, rabbit)

zz
Figure 4.7: SLDNF-forest of ←go well together(rabbit, rabbit)
4.6
Three-valued Completion
Traditionally the SLDNF-resolution principle is justiﬁed within classical logic in terms
of Clark’s program completion. However, there are some problems with that approach
— in particular, there are some noticeable mismatches between SLDNF-resolution and
the program completion. For instance, there are consistent general programs which
do not have a consistent completion:
p ↔¬p ∈comp(p ←¬p)
Thus, by classical logic, anything can be inferred from the completed program. How-
ever, the SLDNF-tree for ←p is stuck, thus leading to incompleteness.
Another
anomaly of the program completion shows up in case of:
p ↔(q ∨¬q)
∈
comp

p ←q.
p ←¬q.

By the law of the excluded middle, comp(P) |= p. This is certainly in accordance
with our intuition if ←q either succeeds or ﬁnitely fails, but what if it does not? For
instance, what if q is deﬁned by q ←q? Then ←q has neither a refutation nor a
ﬁnitely failed SLD(NF)-tree. Consequently the SLDNF-tree of ←p is stuck.
Both of the problems above were repaired by Kunen (1987; 1989) and Fitting (1985)
who introduced the notion of three-valued program completion of a general program.

76
Chapter 4:
Negation in Logic Programming
In classical logic, formulas take on two truth-values — a formula is either true or false.
In a three-valued (or partial) logic, formulas are also allowed to be undeﬁned. The
intuition behind the extra truth-value is to model diverging computations. Thus, in
terms of SLDNF-resolution, “true” means successful, “false” means ﬁnitely failed and
“undeﬁned” means diverging. It is convenient to encode the truth-values as 0 (false),
1
2 (undeﬁned) and 1 (true) in which case the truth-value of compound formulas can
then be deﬁned as follows:
ℑσ(¬F)
:=
1 −ℑσ(F)
ℑσ(F ∧G)
:=
min{ℑσ(F), ℑσ(G)}
ℑσ(F ∨G)
:=
max{ℑσ(F), ℑσ(G)}
ℑσ(F ←G)
:=
if ℑσ(F) < ℑσ(G) then 0 else 1
ℑσ(F ↔G)
:=
if ℑσ(F) = ℑσ(G) then 1 else 0
ℑσ(∀XF)
:=
min{ℑσ[X7→t](F) | t ∈|ℑ|}
ℑσ(∃XF)
:=
max{ℑσ[X7→t](F) | t ∈|ℑ|}
Most concepts from classical logic have natural counterparts in this three-valued logic:
Let F be a closed formula. An interpretation ℑis called a model of F iﬀℑ(F) = 1.
By analogy to classical logic this is written ℑ|=3 F. Similarly, if P is a set of closed
formulas, then F is a logical consequence of a P (denoted P |=3 F) iﬀevery model of
P is a model of F.
Also by analogy to two-valued Herbrand interpretations, a three-valued or, as it
will be called, partial Herbrand interpretation ℑwill be written as a set of literals with
the restriction that not both A and ¬A may be members of ℑ. Hence, a literal L is
true in ℑiﬀL ∈ℑ. A ground atomic formula A is undeﬁned in ℑif neither A ∈ℑnor
¬A ∈ℑ. Thus, ℑuniquely determines the truth-value of ground literals. A partial
Herbrand interpretation such that either A ∈ℑor ¬A ∈ℑfor each ground atom A is
said to be total (or two-valued).
It can be shown that SLDNF-resolution is sound with respect to the three-valued
completion:
Theorem 4.17 (Soundness of SLDNF-resolution revisited) Let P be a general
program and ←L1, . . . , Ln a general goal.
• If ←L1, . . . , Ln has a computed answer substitution θ then:
comp(P) |=3 ∀(L1θ ∧· · · ∧Lnθ)
• If ←L1, . . . , Ln has a ﬁnitely failed SLDNF-tree then:
comp(P) |=3 ∀(¬(L1 ∧· · · ∧Ln))
No general completeness result for SLDNF-resolution is available with respect to the
three-valued completion. However, the situation is not as bad as in the case of two-
valued completion. With a slightly modiﬁed notion of SLDNF-resolution it was shown
by Drabent (1995a) that the only sources of incompleteness are ﬂoundering and unfair
selection of literals in SLDNF-derivations. As already discussed ﬂoundering is an un-
decidable property but suﬃcient conditions may be imposed to guarantee the absence

4.7 Well-founded Semantics
77
of ﬂoundering. One simple (and rather weak) suﬃcient condition is that every variable
in a clause or in the goal occurs in a positive body literal. A general program P and
a goal G are said to be allowed if all clauses of P and G satisfy this condition. Kunen
(1989) showed the following completeness result for allowed programs:
Theorem 4.18 (Completeness of SLDNF-resolution) If P is an allowed program
and ←L1, . . . , Ln an allowed goal then:
• If comp(P) |=3 ∀((L1 ∧· · · ∧Ln)θ) then ←L1, . . . , Ln has a computed answer
substitution θ.
• If comp(P) |=3 ∀(¬(L1 ∧· · · ∧Ln)) then ←L1, . . . , Ln has a ﬁnitely failed
SLDNF-tree.
To illustrate the diﬀerence between two-valued and three-valued completion consider
the following examples:
Example 4.19 Let P be the following (allowed) program:
p ←¬p.
q.
Classically comp(P) is inconsistent, but {q} is a three-valued model of comp(P). In
fact, comp(P) |=3 q. Consider also the following allowed program:
p ←q
p ←¬q
q ←q
whose completion looks as follows:
p ↔(q ∨¬q)
q ↔q
Classically comp(P) |= p. However, ←p has a stuck SLDNF-tree. In the three-valued
setting there is one interpretation — namely
? (where both p and q are undeﬁned) —
which is a model of comp(P) but not a model of p. Thus, comp(P) ̸|=3 p.
4.7
Well-founded Semantics
Program completion attempts to capture the intuition behind negation as ﬁnite failure
— an imperfect alternative to the closed world assumption or negation as inﬁnite
failure. To illustrate the diﬀerence between the two, consider the following programs:
P1 :
halts(a).
P2 :
halts(a).
halts(b) ←halts(b).

78
Chapter 4:
Negation in Logic Programming
Logically, both programs are equivalent. However, comp(P1) and comp(P2) are not
equivalent. In particular:
comp(P1) |= ¬halts(b)
whereas
comp(P2) ̸|= ¬halts(b)
On the other hand, under the closed world assumption deﬁned as follows:
cwa(P)
:=
P ∪{¬A | A ∈BP and ←A has no SLD-refutation}
(9)
=
P ∪{¬A | A ∈BP and P ̸|= A}
(10)
the programs are indistinguishable:
cwa(P1) |= ¬halts(b)
and
cwa(P2) |= ¬halts(b)
(Since ¬halts(b) ∈cwa(Pi) for i ∈{1, 2}.) The question arises if the closed world
assumption can be generalized to general programs. Deﬁnition (10) leads to problems
as illustrated when P is of the form.
loops(a) ←¬halts(a).
Since neither P |= loops(a) nor P |= halts(a) it follows that cwa(P) is inconsistent.
Deﬁnition (9) also makes little sense since SLD-resolution is only deﬁned for deﬁnite
programs. Note that it would not make sense to replace SLD-resolution by SLDNF-
resolution:
cwa(P) := P ∪{¬A | A ∈BP and ←A has no SLDNF-refutation}
since if P is extended by halts(a) ←halts(a) then cwa(P) is inconsistent. (Neither
loops(a) nor halts(a) have an SLDNF-refutation.)
To avoid these inconsistency problems the closed world assumption will be identi-
ﬁed with one particular Herbrand model of the program — called its canonical model.
In the case of deﬁnite programs it is natural to adopt the least Herbrand model as
the canonical model (as discussed on p. 60).4 However for general programs it is not
obvious which model to select. We ﬁrst specify some properties that a canonical model
should satisfy. Foremost, it has to be a model. Let TP be deﬁned as follows:
TP (I) := {H | H ←L1, . . . , Ln ∈ground(P) ∧I |= L1, . . . , Ln}
It can be shown that:
Theorem 4.20 If P is a general program and I a Herbrand interpretation of P, then
I is a model of P iﬀTP (I) ⊆I.
Moreover, it is reasonable to assume that an atom A is true in the canonical model
only if there is some constructive support for A:
4Note, also that a canonical model I may also be viewed as a (possibly inﬁnite) program of ground
literals:
{A | A ∈BP and I |= A} ∪{¬A | A ∈BP and I |= ¬A}

4.7 Well-founded Semantics
79
Deﬁnition 4.21 (Supported interpretation) Let P be a general program. A Her-
brand interpretation I of P is said to be supported iﬀfor each I |= A there exists some
A ←L1, . . . , Ln ∈ground(P) such that I |= L1, . . . , Ln.
Theorem 4.22 Let P be a general program and I a Herbrand interpretation. Then
I is supported iﬀI ⊆TP (I).
Thus, a canonical model should be a ﬁxed point of the TP -operator. However, the
program:
loops(a) ←loops(a).
has two supported models: {loops(a)} and
?. We therefore require that the canonical
model is also minimal. This means that I is canonical if I is a minimal ﬁxed point of
TP . Clearly this is satisﬁed by the least Herbrand model of a deﬁnite program.
Unfortunately there are general programs which have more than one minimal sup-
ported Herbrand model (see exercise 4.13) and, perhaps more seriously, there are
programs which have no such model. For instance the general program p ←¬p has
only one Herbrand model, {p}, which it is not supported and therefore not a ﬁxed point
of the TP -operator. The crux is that p/0 is deﬁned in terms of its own complement.
The problems just illustrated can be rectiﬁed by resorting to partial (or three-
valued) Herbrand interpretations instead of two-valued ones. (Recall that a partial
Herbrand interpretation I is a set of ground literals where not both A ∈I and ¬A ∈I.)
For instance, the partial interpretation
? is a model of the program above. In this
interpretation p/0 is undeﬁned.
To deal with partial Herbrand interpretations we
make the following modiﬁcations to our deﬁnitions:
TP (I) := {H | H ←L1, . . . , Ln ∈ground(P) ∧I |=3 L1, . . . , Ln}
A partial Herbrand interpretation I of P is said to be supported iﬀfor each I |=3 A
there exists some A ←L1, . . . , Ln ∈ground(P) such that I |=3 L1, . . . , Ln.
Now consider a partial interpretation I. In order for I to be a model of P it is
necessary that if A ∈TP (I) then A ∈I. Similarly, in order for I to be supported it is
required that if A ∈I then A ∈TP(I). Thus, in order for I to be a canonical partial
model of P we require that:
A ∈I iﬀA ∈TP (I)
(C1)
As concerns false atoms the situation is more complicated and we have to introduce
the auxiliary notion of an unfounded set to characterize atoms that must be false.
Assume that a partial interpretation I is given describing literals which are known to
be true. Informally, an atom A is false (i.e. is contained in an unfounded set) if each
grounded clause A ←L1, . . . , Ln either (1) contains a literal which is false in I or (2)
contains a positive literal which is in an unfounded set. (As a special case A is false if
there is no grounded clause with A as its head.)
Deﬁnition 4.23 (Unfounded set) Let I be a partial Herbrand interpretation. A
subset U of the Herbrand base is called an unfounded set of P with respect to I if for
each A ∈U at least one of the following holds for every A ←L1, . . . , Ln ∈ground(P):

80
Chapter 4:
Negation in Logic Programming
• Some L ∈L1, . . . , Ln is false in I;
• Some positive literal A ∈L1, . . . , Ln is in U.
For a given program P and partial interpretation I there is a unique greatest unfounded
set which should be thought of as the set of all ground atomic formulas which are false
provided that all literals in I are true. The greatest unfounded set of P w.r.t. I will
be denoted FP (I).
Example 4.24 If P is a deﬁnite program then FP (?) is always equivalent to the
complement of the least Herbrand model. That is, without any knowledge about the
truth and falsity of body literals, the unfounded set is the set of all atoms which are
false in the least Herbrand model. For instance, let P be:
odd(s(0)).
odd(s(s(X))) ←odd(X).
Then FP (?) = {odd(s2n(0)}. Next let P be a general program:
odd(s(s(X))) ←odd(X).
even(X) ←¬odd(X).
odd(s(0)).
Then FP (?) = {odd(s2n(0))}.
Thus, every atom odd(s2n(0)) is false.
Moreover,
FP ({odd(s(0))}) = {odd(s2n(0)), even(s(0))}.
Hence, if odd(s(0)) is known to be
true, then both odd(s2n(0)) and even(s(0)) must be false.
We now require that a canonical model I satisﬁes:
¬A ∈I iﬀA ∈FP (I)
(C2)
That is, A is false in the canonical model iﬀA is in the greatest unfounded set of P
w.r.t. the canonical model itself. Partial Herbrand interpretations are partially ordered
under set inclusion just like ordinary Herbrand interpretations, but the intuition is
quite diﬀerent. A minimal partial interpretation is maximally undeﬁned whereas a
minimal two-valued interpretation is maximally false. It was shown by Van Gelder,
Ross and Schlipf (1991) that all general programs have a unique minimal partial model
satisfying C1 and C2. The model is called the well-founded model of P:
Deﬁnition 4.25 (Well-founded model) Let P be a general program. The well-
founded model of P is the least partial Herbrand interpretation I such that:
• if A ∈TP (I) then A ∈I;
• if A ∈FP (I) then ¬A ∈I.
Example 4.26 The deﬁnite program:
odd(s(0)).
odd(s(s(X))) ←odd(X).

4.7 Well-founded Semantics
81
U
WP
⇒
WP
⇒· · ·
WP
⇒
U
U
T
T
F
F
BP
BP
BP
Figure 4.8: Approximation of the well-founded model
has the well-founded model {odd(s2n+1(0)) | n ≥0} ∪{¬odd(s2n(0)) | n ≥0}. The
program:
loops(a) ←¬halts(a).
loops(b) ←¬halts(b).
halts(a) ←halts(a).
halts(b).
has the well-founded model {halts(b), loops(a), ¬halts(a), ¬loops(b)}. Finally:
p ←¬p.
q ←q.
r.
has the well-founded model {r, ¬q}.
More formally the well-founded model of P can be characterized as the least ﬁxed
point of the operator:
WP (I)
=
TP (I) ∪¬FP (I)
where ¬FP (I) denotes the set {¬A | A ∈FP (I)}.
By known results from the theory of ﬁxed points the least ﬁxed point of WP is a
limit of a (possibly transﬁnite) iterative process. If the Herbrand universe is ﬁnite it is
always possible to compute the well-founded model of P as the limit of the sequence:
?,
WP (?),
WP (WP (?)),
. . .
The iteration starts from the empty interpretation (where every literal is undeﬁned).
Each iteration of WP then adds new positive and negative literals to the interpretation
(cf. Figure 4.8) until the iteration converges (which happens in a ﬁnite number of steps
if the Herbrand universe is ﬁnite).
Example 4.27 Consider a class of simple games consisting of a set of states and a set
of moves between states. In all games there are two players who make moves in turn.
A player loses if he is unable to make a move or has to move to a position where the
opponent wins, and a player wins if he can move to a state where the opponent loses.

82
Chapter 4:
Negation in Logic Programming
Then assume a particular instance in this class of games that has only three states,
{a, b, c}, and the following moves:
a
b
c
The game can be formalized as follows:
w(X) ←m(X, Y ), ¬w(Y ).
m(a, b).
m(b, a).
m(b, c).
The well-founded model of the program can be computed as the limit of the iteration
WP ↑n (abbreviated In). The ﬁrst iteration yields:
I1
=
TP(?) ∪¬FP (?) where
TP (?)
=
{m(a, b), m(b, a), m(b, c)}
FP (?)
=
{m(a, a), m(a, c), m(b, b), m(c, a), m(c, b), m(c, c), w(c)}
Note that w(c) is in the unfounded set since all ground instances of the partially
instantiated clause w(c) ←m(c, Y ), ¬w(Y ) contain a positive body literal which is in
the unfounded set. The second iteration yields:
I2
=
TP (I1) ∪¬FP (I1) where
TP (I1)
=
{m(a, b), m(b, a), m(b, c), w(b)}
FP (I1)
=
{m(a, a), m(a, c), m(b, b), m(c, a), m(c, b), m(c, c), w(c)}
After which w(b) is known to be true, since I1 |= m(b, c), ¬w(c). The third iteration
yields:
I3
=
TP(I2) ∪¬FP (I2) where
TP (I2)
=
{m(a, b), m(b, a), m(b, c), w(b)}
FP (I2)
=
{m(a, a), m(a, c), m(b, b), m(c, a), m(c, b), m(c, c), w(c), w(a)}
After which the unfounded set is extended by w(a) (since all ground instances of
w(a) ←m(a, Y ), ¬w(Y ) either contain a positive body literal which is in the unfounded
set or a negative literal (¬w(b)) which is false in I2).
Now WP (I3) = I3. Thus, in the well-founded model there are two losing and one
winning state. Obviously, c is a losing state since no moves are possible. Consequently
b is a winning state because the opponent can be put in a losing state. Finally a is
a losing state since the only possible move leaves the opponent in a winning state.
Incidentally, the well-founded model is total.
Next consider the following game:
a
b
c
d
This game can be formalized as follows:

4.7 Well-founded Semantics
83
w(X) ←m(X, Y ), ¬w(Y ).
m(a, b).
m(b, a).
m(b, c).
m(c, d).
The ﬁrst iteration yields:
I1
=
TP(?) ∪¬FP (?)
TP (?)
=
{m(a, b), m(b, a), m(b, c), m(c, d)}
FP (?)
=
{m(x, y) | m(x, y) ̸∈P} ∪{w(d)}
After the second iteration w(c) is known to be true:
I2
=
TP(I1) ∪¬FP (I1)
TP (I1)
=
{m(a, b), m(b, a), m(b, c), m(c, d), w(c)}
FP (I1)
=
{m(x, y) | m(x, y) ̸∈P} ∪{w(d)}
In fact, this is the well-founded model of P:
I3
=
TP (I2) ∪¬FP (I2)
=
I2
This time the well-founded model is partial. The state d is a losing and c is a winning
state. However, nothing is known about a and b. This may appear startling. However,
a player can clearly not win from state b by moving to c. Moreover he does not have to
lose, since there is always the option of moving to state a. (From which the opponent
can always move back to b.) Hence a and b are drawing states.
The well-founded model coincides with the other canonical models discussed earlier in
this chapter. For instance, the least Herbrand model in the case of deﬁnite programs:
Theorem 4.28 If P is a deﬁnite program then the well-founded model is total and
coincides with the least Herbrand model.
It is also coincides with the standard model of stratiﬁed programs:
Theorem 4.29 If P is stratiﬁed then the well-founded model is total and coincides
with the standard model.
Several other connections between the well-founded semantics and other semantics
have also been established.
Several attempts have been made to deﬁne variants of SLDNF-resolutions which com-
pute answers to goals using the well-founded semantics as the underlying declarative
semantics. In general, no complete resolution mechanism can be found, but for re-
stricted classes of general programs such resolution mechanisms exist. Most notably
the notion of SLS-resolution of Przymusinski (1989).

84
Chapter 4:
Negation in Logic Programming
Exercises
4.1 Consider the following deﬁnite program:
p(X) ←q(Y, X), r(Y ).
q(s(X), Y ) ←q(X, Y ).
r(0).
Show that there is one computation rule such that ←p(0) has a ﬁnitely failed
SLD-tree and another computation rule such that ←p(0) has an inﬁnite SLD-
tree.
4.2 Construct the completion of the program in the previous exercise. Show that
¬p(0) is a logic consequence of comp(P).
4.3 Construct the completion of the program:
p(a) ←q(X).
p(b) ←r(X).
r(a).
r(b).
Show that ¬p(a) is a logical consequence of comp(P).
4.4 Let P be a deﬁnite program. Show that comp(P) |= P.
4.5 Consider a general program:
p(b).
p(a) ←¬q(X).
q(a).
Construct comp(P) and show that p(a) is a logical consequence of comp(P).
4.6 Construct a fair SLD-tree for the program:
p(s(X)) ←p(X).
q(X, Y ) ←p(Y ), r(X, 0).
r(X, X).
and the goal ←p(X), q(X, Y ).
4.7 Which of the following four programs are stratiﬁed?
P1
p(X) ←q(X), r(X).
p(X) ←¬r(X).
q(X) ←¬r(X), s(X).
r(X) ←¬s(X).
P2
p(X) ←p(X), s(X).
s(X) ←r(X).
r(X) ←¬p(X).
r(a).
P3
p(X) ←¬q(X), r(X).
r(X) ←q(X).
q(X) ←¬s(X).
P4
p(X) ←r(X), p(X).
r(X) ←¬p(X).
r(X) ←r(X).

Exercises
85
4.8 Construct the completion of the general program:
p(a) ←¬q(b).
and show that {p(a)} is a Herbrand model of the completion. Show also that
the model is minimal.
4.9 Consider the general program:
ﬂies(X) ←bird(X), ¬abnormal(X).
bird(tom).
bird(sam).
bird(donald).
abnormal(donald).
abnormal(X) ←isa(X, penguin).
isa(sam, eagle).
isa(tom, penguin).
isa(donald, duck).
Construct the SLDNF-forest for the goal ←ﬂies(X).
4.10 Consider the program in Example 4.16. Show that
←go well together(python, rabbit)
has a a ﬁnitely failed SLDNF-tree.
4.11 Prove theorem 4.20.
4.12 Prove theorem 4.22.
4.13 Show a general program which has more than one minimal supported Herbrand
model.
4.14 What is the well-founded model of the program:
p ←¬q
q ←¬p
r
s ←p, ¬r.

86
Chapter 4:
Negation in Logic Programming

Chapter 5
Towards Prolog: Cut and
Arithmetic
Computations of logic programs require construction and traversal of SLD-trees. This
is not necessarily the most eﬃcient way of computing. Two extensions — the cut and
built-in arithmetic — that are incorporated in the programming language Prolog to
speed up computations will be presented separately in Sections 5.1 and 5.2. For the
sake of simplicity the exposition covers only deﬁnite programs but all concepts carry
over to general programs, SLDNF-derivations and SLDNF-trees. (In what follows,
mentioning of Prolog refers to the ISO Prolog standard (1995) unless otherwise stated.)
5.1
Cut: Pruning the SLD-tree
An SLD-tree of a goal may have many failed branches and very few, or just one,
success branch. Therefore the programmer may want to prevent the interpreter from
constructing failed branches by adding control information to the program. However,
such information relies on the operational semantics of the program.
To give the
required control information, the programmer has to know how the SLD-tree is con-
structed and traversed. However, for practical reasons this information has to be taken
into account anyway — for the depth-ﬁrst search employed in Prolog-interpreters, ex-
istence of an inﬁnite branch in the SLD-tree may prevent the interpreter from ﬁnding
an existing correct answer. To control the search the concept of cut is introduced in
Prolog. Syntactically the cut is denoted by the nullary predicate symbol “!” and it
may be placed in the body of a clause or a goal as one of its atoms. Its meaning can be
best explained as a “shortcut” in the traversal of the SLD-tree. Thus, the presence of
cut in a clause may avoid construction of some subtrees of the SLD-tree. For a more
precise explanation some auxiliary notions are needed.
Every node n of an SLD-tree corresponds to a goal of an SLD-derivation and has
87

88
Chapter 5:
Towards Prolog: Cut and Arithmetic

←male(mary).
←male(ben).
←parent(X, tom), male(X).
←father(X, tom).





Q
Q
Q
Q
Q
(1)
(2)
(3)
(6)
Figure 5.1: SLD-tree
a selected atom A. Assume that A is not an instance of a subgoal in the initial goal.
Then A is an instance of a body atom Bi of a clause B0 ←B1, . . . , Bi, . . . , Bn whose
head uniﬁes with the selected subgoal in some node n′ between the root and n. Denote
by origin(A) the node n′.
Prolog interpreters traverse the nodes of the SLD-tree in a depth-ﬁrst manner as
depicted in Figure 3.6. The ordering of branches corresponds to the textual ordering
of the clauses in the program. When a leaf of the tree is reached, backtracking takes
place. The process terminates when no more backtracking is possible (that is, when
all subtrees of the root are traversed). The atom “!” is handled as an ordinary atom
in the body of a clause. However, when a cut is selected for resolution it succeeds
immediately (with the empty substitution). The node where “!” is selected will be
called the cut-node. A cut-node may be reached again during backtracking. In this case
the normal order of tree-traversal illustrated in Figure 3.6 is altered — by deﬁnition of
cut the backtracking continues above the node origin(!) (if cut occurs in the initial goal
the execution simply terminates). This is illustrated by the following simple example.
Example 5.1 The father of a person is its male parent. Assume that the following
world is given:
(1)
father(X, Y ) ←parent(X, Y ), male(X).
(2)
parent(ben, tom).
(3)
parent(mary, tom).
(4)
parent(sam, ben).
(5)
parent(alice, ben).
(6)
male(ben).
(7)
male(sam).
The SLD-tree of the goal ←father(X, tom) under Prolog’s computation rule is shown
in Figure 5.1. After ﬁrst ﬁnding the solution X = ben, an attempt to ﬁnd another
solution will fail since Mary is not male. By the formulation of the problem it is clear
that there may be at most one solution for this type of goal (that is, when the second

5.1 Cut: Pruning the SLD-tree
89

←!.
←male(mary), !.
←male(ben), !.
←parent(X, tom), male(X), !.
←father(X, tom).





..................
(1)
(2)
(3)
(6)
Figure 5.2: Pruning failing branches
argument is fully instantiated). When a solution is found the search can be stopped
since no person has more than one father. To enforce this, cut may be inserted at the
end of (1). The modiﬁed SLD-tree is shown in Figure 5.2 (The dashed line designates
the branch cut oﬀby “!”). The origin of the cut-node is the root of the tree so the
search is completed after backtracking to the cut-node. Hence, the other branch of
the tree is not traversed.
Notice that the modiﬁed version of (1) cannot be used for computing more than
one element of the relation “. . . is the father of . . . ”. The cut will stop the search after
ﬁnding the ﬁrst answer to the goal ←father(X, Y ) (consider the SLD-tree in Figure
5.3).
It follows by the deﬁnition that the cut has the following eﬀects:
• It divides the body into two parts where backtracking is carried out separately
— after success of “!” no backtracking to the literals in the left-hand part is
possible. However, in the right-hand part execution proceeds as usual;
• It cuts oﬀunexplored branches directly below origin(!). In other words, there
will be no further attempts to match the selected subgoal of origin(!) with the
remaining clauses of the program.
Cut is, to put it mildly, a controversial construct. The intention of introducing cut is
to control the execution of a program without changing its logical meaning. Therefore
the logical reading of cut is “true”. Operationally, if it removes only the failed branches
of the SLD-tree it does not inﬂuence the meaning of the program. However, it may
also cut oﬀsome success branches, thus destroying completeness of deﬁnite programs
and soundness of general programs. To illustrate the latter, consider the following
example:

90
Chapter 5:
Towards Prolog: Cut and Arithmetic

←!.

←!.
←male(ben), !.
←male(mary), !. ←male(sam), !.
←male(alice), !.
←parent(X, Y ), male(X), !.
←father(X, Y ).
.............
.............












..................
..................
................................
Figure 5.3: Pruning success-branches
Example 5.2 It is a well known fact that fathers of newborn children are proud. This
proposition is reﬂected by the following deﬁnite clause:
(1)
proud(X) ←father(X, Y ), newborn(Y ).
Take additionally the clauses:
(2)
father(X, Y ) ←parent(X, Y ), male(X).
(3)
parent(john, mary).
(4)
parent(john, chris).
(5)
male(john).
(6)
newborn(chris).
The answer to the initial goal ←proud(john) is “yes” since, as described, John is the
father of Chris who is newborn.
Now, replace (2) by the version with cut used in Example 5.1:
(2′)
father(X, Y ) ←parent(X, Y ), male(X), !.
This time the answer to the goal ←proud(john) is “no”. It is so because the ﬁrst
“listed” child of John is Mary — the sister of Chris. After having found this answer
there will be no more attempts to ﬁnd any more children of John because of the cut.
This makes the program incomplete — some correct answer substitutions cannot be
found. More seriously, this incompleteness may result in incorrect answers if negation
is involved. For example, the goal ←¬proud(john) will succeed — implying that John
is not proud.
So far two principal uses of cut have been distinguished — to cut oﬀfailing branches
of the SLD-tree and to prune succeeding branches. Cutting oﬀfailing branches is

5.1 Cut: Pruning the SLD-tree
91
generally considered harmless since it does not alter the answers produced during
the execution. Such cuts are sometimes referred to as “green cuts”. However, this
restricted use of cut is usually tied to some particular use of the program. Thus,
as illustrated in Figures 5.2 and 5.3, for some goals only failing branches are cut oﬀ
whereas for other goals succeeding branches are also pruned.
In general, cutting succeeding branches is considered harmful. (Consequently such
cuts are referred to as “red cuts”.) However, there are some cases when it is motivated.
This section is concluded with two examples — in the ﬁrst example the use of cut is
sometimes (rightfully) advocated. The second example demonstrates a very harmful
(albeit common) use of cut.
Consider the following (partial) program:
proud(X) ←father(X, Y ), newborn(Y ).
...
father(john, sue).
father(john, mary).
...
newborn(sue).
newborn(mary).
The SLD-tree of the goal ←proud(X) has two success-leaves since John has two
children both of which are newborn. However, both answers give the same binding
for X — namely X = john. In general the user is not interested in getting the same
answer twice or more. To avoid this, a cut may be inserted at the very end of the ﬁrst
clause (or possibly as the rightmost subgoal in the goal).
proud(X) ←father(X, Y ), newborn(Y ), !.
Next consider the following example1 which describes the relation between two integers
and their minimum:
min(X, Y, X) ←X < Y, !.
min(X, Y, Y ).
At ﬁrst glance this program may look correct. People used to imperative programming
languages often reason as follows — “If X is less than Y then the minimum of X and Y
is X, else it is Y”. Actually the program returns the expected answer both to the goal
←min(2, 3, X) and ←min(3, 2, X) — in both cases the answer X = 2 is obtained.
However, the program is not correct. Consider the goal ←min(2, 3, 3). This goal
succeeds implying that “3 is the minimum of 2 and 3”! The program above is an
1Here < is a binary predicate symbol written in inﬁx notation designating the less-than relation
over e.g. the integers. Intuitively it may be thought of as an inﬁnite collection of facts:
· · ·
−1 < 0.
0 < 1.
1 < 2.
2 < 3.
· · ·
· · ·
−1 < 1.
0 < 2.
1 < 3.
2 < 4.
· · ·
...
...
...
...
...
...
In Prolog < is implemented as a so-called built-in predicate which will be discussed in the next
section.

92
Chapter 5:
Towards Prolog: Cut and Arithmetic
example of an incorrect program where (some of) the false answers are discarded by
means of the cut. The intended model is simply not a model of the program since the
second clause says that “For any two integers, X and Y, Y is their minimum”. This
use of cut is harmful. It may not only produce incorrect answers, but it also makes
the program hard to read and understand. If cut is to be used it should be added to a
program which is true in the intended model. Thus, the recommended version of the
minimum program (with cut) would look as follows:
min(X, Y, X) ←X < Y, !.
min(X, Y, Y ) ←X ≥Y.
This program is true in the intended model and the goal ←min(2, 3, 3) does not
succeed any longer.
As a ﬁnal remark, cut may be used to implement negation in Prolog. Consider the
following clauses (where fail is a Prolog predicate which lacks a deﬁnition and cannot
be deﬁned by the user):
not(student(X)) ←student(X), !, fail.
not(student(X)).
This deﬁnition relies entirely on the operational semantics of Prolog. That is, subgoals
must be solved from left to right and clauses are searched in the textual order. If we
want to know whether “John is not a student” the goal ←not(student(john)) may be
given. Then there are two cases to consider — if the subgoal student(john) succeeds
(i.e. if John is a student), “!” will cut oﬀthe second clause and the negated goal will
fail. That is, Prolog produces the answer “no”. However, if the subgoal student(john)
ﬁnitely fails, the second clause will be tried (on backtracking) and the negated goal
immediately succeeds.
To avoid having to write a separate deﬁnition for every predicate that the user may
want to negate it is possible to use a predeﬁned meta-predicate named call/1 which
is available in standard Prolog. The argument of call/1 must not be a variable when
the subgoal is selected and a call to the predicate succeeds iﬀthe argument succeeds.
In other words — the goal ←call(G) succeeds iﬀthe goal ←G succeeds. Using this
predicate not/1 may be deﬁned for arbitrary goals:2
not(X) ←call(X), !, fail.
not(X).
Notice that the success of call(t) may produce bindings for variables in t. Hence the
implementation is not logically correct, as discussed in Chapter 4. However, it works
as intended when the argument of not/1 is a ground atom.
In general it is possible to avoid using cut in most cases by sticking to negation
instead. This is in fact advocated since unrestricted use of cut often leads to incorrect
programs. It is not unusual that people — on their ﬁrst contacts with Prolog and faced
with a program that produces incorrect answers — clutter the program with cuts at
random places instead of writing a logically correct program in the ﬁrst place. In the
following chapters the use of cut is avoided to make this point quite clear. However,
this does not mean that cut should be abandoned altogether — correctly used, it can
improve the eﬃciency of programs considerably.
2Standard Prolog uses the predicate \+ with a preﬁx notation to denote negation.

5.2 Built-in Arithmetic
93
5.2
Built-in Arithmetic
It has been proved that deﬁnite programs can describe any computable relation. That
is, any Turing machine can be coded as a logic program. This means that from a
theoretical point of view logic programming is not less expressive than other program-
ming paradigms. In other words, resolution and exhaustive search provide a universal
tool for computation. But from a practical point of view it is not desirable to com-
pute everything in that way. Take for example the arithmetic operations on natural
numbers. They are eﬃciently implemented in the hardware of computers. Therefore,
from a practical point of view, it is desirable to allow logic programs to access machine
arithmetic. A similar argument concerns any other operation or procedure whose ef-
ﬁcient implementation in hardware or software is available. The problem is whether
it is possible to do that without destroying the declarative nature of logic programs
that use these external features. This section discusses the problem for the example
of arithmetic operations and shows the solution adopted in Prolog.
Notice ﬁrst that arithmetic operations like plus or times can be easily described by
a deﬁnite logic program. The natural numbers can be represented by ground terms.
A standard way for that is to use the constant 0 for representing zero and the unary
functor s/1 for representing the successor of a number. Thus, the consecutive natural
numbers are represented by the following terms:
0, s(0), s(s(0)), . . .
The operations of addition and multiplication are binary functions on natural numbers.
Logic programs provide only a formalism for expressing relations. However, a binary
function can be seen as a ternary relation consisting of all triples ⟨x, y, z⟩such that z
is the result of applying the function to the arguments x and y. It is well known that
the operations of addition and multiplication on natural numbers can be characterized
by the following Peano axioms:
0 + X
.=
X
s(X) + Y
.=
s(X + Y )
0 ∗X
.=
0
s(X) ∗Y
.=
(X ∗Y ) + Y
These axioms relate arguments and results of the operations. In the relational notation
of deﬁnite programs they can be reformulated as follows:
plus(0, X, X).
plus(s(X), Y, s(Z)) ←plus(X, Y, Z).
times(0, X, 0).
times(s(X), Y, Z) ←times(X, Y, W), plus(W, Y, Z).
This program can be used to add and multiply natural numbers represented by ground
terms.
For example, to add 2 and 3 the goal ←plus(s(s(0)), s(s(s(0))), X) can be given.
The computed answer is X = s(s(s(s(s(0))))). An SLD-refutation is used to construct
it.

94
Chapter 5:
Towards Prolog: Cut and Arithmetic
On the other hand, the program can be used also for subtraction and (a limited form
of) division. For example, in order to subtract 2 from 5 the goal ←plus(X, s(s(0)),
s(s(s(s(s(0)))))) can be used. The program can also perform certain symbolic compu-
tations. For example, one can add 2 to an unspeciﬁed natural number using the goal
←plus(s(s(0)), X, Y ). The computed answer is Y = s(s(X)). Thus, for any ground
term t the result is obtained by adding two instances of the symbols s in front of t.
When comparing this with the usual practice in programming languages, the fol-
lowing observations can be made:
• the representation of numbers by compound terms is inconvenient for humans;
• the computations of the example program do not make use of arithmetic opera-
tions available in the hardware — therefore they are much slower. For instance,
adding numbers N and M requires N + 1 procedure-calls;
• arithmetic expressions cannot be constructed, since the predicate symbols plus/3
and times/3 represent relations. For example, to compute 2 + (3 ∗4) one has to
introduce new temporary variables representing the values of subexpressions:
←times(s(s(s(0))), s(s(s(s(0)))), X), plus(X, s(s(0)), Y ).
The ﬁrst problem can easily be solved by introducing some “syntactic sugar”, like
the convention that the decimal numeral for the natural number n represents the
term sn(0) — for instance, 3 represents the term s(s(s(0))). Techniques for compiling
arithmetic expressions into machine code are also well known. Thus the main problem
is how to incorporate arithmetic expressions into logic programs without destroying
the declarative meaning of the programs.
Syntactically arithmetic expressions are terms built from numerals, variables and
speciﬁc arithmetic functors, like “+”, “∗”, etc. usually written in inﬁx notation. The
intended meaning of a ground arithmetic expression is a number. It is thus essential
that distinct expressions may denote the same number, take for example 2 + 2, 2 ∗
1 + 4 −2 and 4. Thus, there is a binary relation on ground arithmetic expressions
which holds between arbitrary expressions E1 and E2 iﬀE1 and E2 denote the same
number.
Clearly this relation is an equivalence relation.
Every equivalence class
includes one numeral which is the simplest representation of all terms in the class.
The machine operations give a possibility of eﬃcient reduction of a given ground
arithmetic expression to this numeral.
Assume that arithmetic expressions may appear as terms in deﬁnite logic pro-
grams. The answers of such programs should take into account equivalence between
the arithmetic expressions. For example, consider the following rule for computing tax
— “if the annual income is greater than 150, 000 then the tax is 50%, otherwise 25%
of the income reduced by 30, 000”:
tax(Income, 0.5 ∗Income) ←greater(Income, 150000).
tax(Income, 0.25 ∗(Income −30000)) ←¬greater(Income, 150000).
A tax-payer received a decision from the tax department to pay 25, 000 in tax from
his income of 130, 000. To check whether the decision is correct (s)he may want to
use the rules above by giving the goal ←tax(130000, 25000). But the rules cannot be

5.2 Built-in Arithmetic
95
used to ﬁnd a refutation of the goal since none of the heads of the clauses unify with
the subgoal in the goal. The reason is that standard uniﬁcation is too weak to realize
that the intended interpretations of the terms 25000 and 0.25 ∗(130000 −30000) are
the same. Thus, the equivalence must somehow be described by equality axioms for
arithmetic. But they are not included in the program above.
This discussion shows the need for an extension of the concept of logic programs.
For our example the program should consist of two parts — a set of deﬁnite clauses
P and a set of equality axioms E describing the equivalences of terms. This type of
program has been studied in the literature. The most important result is a concept
of generalized uniﬁcation associated with a given equality theory E and called E-
uniﬁcation. A brief introduction follows below. A more extensive account is provided
in Chapter 13 and 14.
A deﬁnite clause equality theory is a (possibly inﬁnite) set of deﬁnite clauses, where
every atom is of the form s .= t and s and t are terms. Sometimes the form of the
clauses is restricted to facts.
A deﬁnite program with equality is a pair P, E where P is a deﬁnite program which
contains no occurrences of the predicate symbol .= /2 and E is a deﬁnite clause equality
theory.
Let E be a deﬁnite clause equality theory. A substitution θ is an E-uniﬁer of the
terms s and t iﬀsθ .= tθ is a logical consequence of E.
Example 5.3 Let E be an equality theory describing the usual equivalence of arith-
metic expressions. Consider the expressions:
t1 := (2 ∗X) + 1
and
t2 := Y + 2
For instance, the substitution θ := {Y/(2 ∗X −1)} is an E-uniﬁer of t1 and t2. To
check this, notice that t1θ = t1 and that t2θ = (2 ∗X −1) + 2 which is equivalent to
t1.
Now, for a given program P, E and goal ←A1, . . . , Am the refutation of the goal can
be constructed in the same way as for deﬁnite programs, with the only diﬀerence that
E-uniﬁcation is used in place of uniﬁcation as presented in Chapter 3.
Finding E-uniﬁers can be seen as solving of equations in an algebra deﬁned by
the equality axioms.
It is known that the problem of E-uniﬁcation is in general
undecidable. Even if it is decidable for some theory E there may be many diﬀerent
solutions of a given equation. The situation when there exists one most general uniﬁer
is rather unusual. This means that even if it is possible to construct all E-uniﬁers, a
new dimension of nondeterminism is introduced.
Assume now that an equality theory E describes all external functions, including
arithmetic operations, used in a logic program. This means that for any ground terms
s and t whose main functors denote external functions, the formula s .= t is a logical
consequence of E iﬀthe invocation of s returns the same result as the invocation of t.
In other words, in the special case of ground terms their E-uniﬁability can be decided
— they either E-unify with the identity substitution, if both reduce to the same result,
or they are not E-uniﬁable, if their results are diﬀerent. This can be exploited in the
following way — whenever a call of an external function is encountered as a term to
be E-uniﬁed, it is invoked and its reduced form is being uniﬁed instead by the usual

96
Chapter 5:
Towards Prolog: Cut and Arithmetic
uniﬁcation algorithm. However, the external procedures can be invoked only with
ground arguments. If some variables of the call are not instantiated, the computation
cannot proceed and no E-uniﬁer can be found. In this case a run time error may be
reported.
This idea is incorporated in Prolog in a restricted form for arithmetic operations.
Before explaining how, some syntactic issues should be mentioned.
The integers are represented in Prolog as integer numerals, for example 0, 1, 1989
and 17 etc. Prolog also supports a limited form of arithmetic over the reals using
ﬂoating point numbers usually written as e.g. 3.14, 7.0, 0.3333 etc.
Logically the
numerals are constants. In addition, a number of predeﬁned arithmetic functors for
use in the inﬁx notation is available. They denote standard arithmetic functions on
integers and ﬂoats and refer to the operations of the computer. The most important
operations are:
Functor
Operation
+
Addition
−
Subtraction
∗
Multiplication
/
(Floating point) division
//
(Integer) division
mod
Remainder after division
Additionally unary minus is used to represent negative numbers. (For a full list see
the ISO Prolog standard (1995).)
A ground term t constructed from the arithmetic functors and the numerals rep-
resents an integer or a ﬂoating point number, which can also be represented by a
numeral n, possibly preﬁxed by “−”. The machine operations of the computer make
it possible to construct this term t′ in an eﬃcient way. The arithmetic operations can
be axiomatized as an equational theory E such that t .= t′ is its logical consequence.
Two predeﬁned predicates of Prolog handle two speciﬁc cases of E-uniﬁcation. They
are is/2 and =: = /2 both of which are used in the inﬁx notation.
The binary predicate =: = /2 checks if two ground arithmetic expressions are E-
uniﬁable. For example the goal:
←2 + 3 =: = 1 + 4.
succeeds with the answer “yes” (corresponding to the empty substitution).
If the
arguments are not ground arithmetic expressions, the execution aborts with an error
message in most Prolog implementations.
The binary predicate is/2 uniﬁes its ﬁrst argument with the reduced form of a
term constructed from the arithmetic functors and numerals. For example the goal:
←X is 2 + 2.
succeeds with the substitution {X/4}.
The ﬁrst argument of this predicate need not be variable. Operationally the re-
duced form of the second argument, which is either a numeral or a numeral preceded
by “−”, is being uniﬁed with the ﬁrst argument. If the latter is an arithmetic expres-
sion in the reduced form then this is a special case of E-uniﬁcation handled also by

Exercises
97
=: = /2. Otherwise the answer is “no”. But an E-uniﬁer may still exist. For example
the goal:
←X + 1 is 2 + 3.
will fail, although the terms X + 1 and 2 + 3 have an E-uniﬁer — namely {X/4}.
Another standard predicate =\= /2 (also in inﬁx notation) checks whether two
ground terms are not E-uniﬁable. Prolog also provides predeﬁned predicates for com-
paring the number represented by ground arithmetic expressions. These are the binary
inﬁx predicates <, >, ≥and ≤.
Exercises
5.1 Consider the following deﬁnite program:
top(X, Y ) ←p(X, Y ).
top(X, X) ←s(X).
p(X, Y ) ←true(1), q(X), true(2), r(Y ).
p(X, Y ) ←s(X), r(Y ).
q(a).
q(b).
r(c).
r(d).
s(e).
true(X).
Draw the SLD-tree of the goal ←top(X, Y ). Then show what branches are
cut oﬀ:
• when true(1) is replaced by cut;
• when true(2) is replaced by cut.
5.2 Consider the following program:
p(Y ) ←q(X, Y ), r(Y ).
p(X) ←q(X, X).
q(a, a).
q(a, b).
r(b).
Add cut at diﬀerent places in the program above and determine the answers
in response to the goal ←p(Z).
5.3 Consider the deﬁnition of not/1 given on page 92. From a logical point of view,
←p(X) and ←not not p(X) are equivalent formulas. However, they behave
diﬀerently when given to the program that consists of a single clause p(a) —
in what way?

98
Chapter 5:
Towards Prolog: Cut and Arithmetic
5.4 Prolog implementations often incorporate a built-in predicate var/1 which
succeeds (with the empty substitution) if the argument is an uninstantiated
variable when the call is made and fails otherwise. That is:
←var(X), X = a.
succeeds whereas:
←X = a, var(X).
fails under the assumption that Prolog’s computation rule is used.
Deﬁne
var/1 given the deﬁnition of not/1 on page 92.
5.5 Write a program which deﬁnes the relation between integers and their facto-
rial. First use Peano arithmetic and then the built-in arithmetic predicates of
Prolog.
5.6 Write a predicate between(X, Y, Z) which holds if X ≤Y ≤Z. That is, given
a goal ←between(1, X, 10) the program should generate all integers in the
closed interval (via backtracking).
5.7 Write a program that describes the relation between integers and their square
using Peano arithmetic.
5.8 Implement the Euclidean algorithm for computing the greatest common divisor
of two integers. Do this using both Peano arithmetic and built-in arithmetic.
5.9 The polynomial cn ∗xn + · · · + c1 ∗x + c0 where c0, . . . , cn are integers may be
represented by the term
cn ∗xˆn + · · · + c1 ∗x + c0
where ˆ/2 is written with inﬁx notation and binds stronger than ∗/2 which
in turn binds stronger than +/2. Now write a program which evaluates such
polynomials given the value of x. For instance:
←eval(2 ∗xˆ2 + 5, 4, X).
should succeed with answer X = 37. To solve the problem you may presuppose
the existence of a predicate integer/1 which succeeds if the argument is an
integer.

PART II
PROGRAMMING IN LOGIC
99


Chapter 6
Logic and Databases
This chapter discusses the relationship between logic programs and relational data-
bases. It is demonstrated how logic can be used to represent — on a conceptual level
— not only explicit data, but also implicit data (corresponding to views in relational
database theory) and how it can be used as a query language for retrieval of information
in a database.
We do not concern ourselves with implementation issues but only
remark that SLD-resolution does not necessarily provide the best inference mechanism
for full logical databases. (An alternative approach is discussed in Chapter 15.) On the
other hand, logic not only provides a uniform language for representation of databases
— its additional expressive power also enables description, in a concise and intuitive
way, of more complicated relations — for instance, relations which exhibit certain
common properties (like transitivity) and relations involving structured data objects.
6.1
Relational Databases
As indicated by the name, the mathematical notion of relation is a fundamental con-
cept in the ﬁeld of relational databases. Let D1, D2, . . . , Dn be collections of symbols
called domains. In the context of database theory the domains are usually assumed
to be ﬁnite although, for practical reasons, they normally include an inﬁnite domain
of numerals. In addition, the members of the domains are normally assumed to be
atomic or indivisible — that is, it is not possible to access a proper part of a member.
A database relation R over the domains D1, . . . , Dn is a subset of D1 × · · ·× Dn. R
is in this case said to be n-ary. A relational database is a ﬁnite number of such (ﬁnite)
relations. Database relations and domains will be denoted by identiﬁers in capital
letters.
Example 6.1 Let MALE
:= {adam, bill}, FEMALE := {anne, beth} and ﬁnally
PERSON := MALE ∪FEMALE. Then:
101

102
Chapter 6:
Logic and Databases
MALE × PERSON =







⟨adam, adam⟩
⟨bill, adam⟩
⟨adam, bill⟩
⟨bill, bill⟩
⟨adam, anne⟩
⟨bill, anne⟩
⟨adam, beth⟩
⟨bill, beth⟩







Now, let FATHER, MOTHER and PARENT be relations over the domains MALE ×
PERSON , FEMALE × PERSON and PERSON × PERSON deﬁned as follows:
FATHER
:=
{⟨adam, bill⟩, ⟨adam, beth⟩}
MOTHER
:=
{⟨anne, bill⟩, ⟨anne, beth⟩}
PARENT
:=
{⟨adam, bill⟩, ⟨adam, beth⟩, ⟨anne, bill⟩, ⟨anne, beth⟩}
It is of course possible to imagine alternative syntactic representations of these rela-
tions. For instance in the form of tables:
FATHER:
MOTHER:
PARENT:
C1
C2
adam
bill
adam
beth
C1
C2
anne
bill
anne
beth
C1
C2
adam
bill
adam
beth
anne
bill
anne
beth
or as a collection of labelled tuples (that is, facts):
father(adam, bill).
father(adam, beth).
mother(anne, bill).
mother(anne, beth).
parent(adam, bill).
parent(adam, beth).
parent(anne, bill).
parent(anne, beth).
The table-like representation is the one found in most textbooks on relational databases
whereas the latter is a logic program. The two representations are isomorphic if no
notice is taken of the names of the columns in the tables.
Such names are called
attributes and are needed only to simplify the speciﬁcation of some of the operations
discussed in Section 6.3. It is assumed that the attributes of a table are distinct. In
what follows the notation R(A1, A2, . . . , An) will be used to describe the name, R, and
attributes, ⟨A1, A2, . . . , An⟩, of a database table (i.e. relation). R(A1, A2, . . . , An) is
sometimes called a relation scheme. When not needed, the attributes are omitted and
a table will be named only by its relation-name.
A major diﬀerence between the two representations which is not evident above, is
the set of values which may occur in each column/argument-position of the represen-
tations. Logic programs have only a single domain consisting of terms and the user is
permitted to write:
father(anne, adam).

6.2 Deductive Databases
103
whereas in a relational database this is usually not possible since anne ̸∈MALE. To
avoid such problems a notion of type is needed.
Despite this diﬀerence it should be clear that any relational database can be rep-
resented as a logic program (where each domain of the database is extended to the set
of all terms) consisting solely of ground facts. Such a set of facts is commonly called
the extensional database (EDB).
6.2
Deductive Databases
After having established the relationship between relational databases and a (very
simple) class of logic programs, diﬀerent extensions to the relational database-model
are studied. We ﬁrst consider the use of variables and a simple form of rules. By such
extensions it is possible to describe — in a more succinct and intuitive manner —
many database relations. For instance, using rules and variables the database above
can be represented by the program:
parent(X, Y ) ←father(X, Y ).
parent(X, Y ) ←mother(X, Y ).
father(adam, bill).
father(adam, beth).
mother(anne, bill).
mother(anne, beth).
The part of a logic program which consists of rules and nonground facts is called the
intensional database (IDB). Since logic programs facilitate deﬁnition of new atomic
formulas which are ultimately deduced from explicit facts, logic programs are often
referred to as deductive databases. The logic programs above are also examples of a
class of logic programs called datalog programs. They are characterized by the absence
of functors. In other words, the set of terms used in the program solely consists of
constant symbols and variables. For the representation of relational databases this is
suﬃcient since the domains of the relations are assumed to be ﬁnite and it is therefore
always possible to represent the individuals with a ﬁnite set of constant terms. In the
last section of this chapter logic programs which make also use of compound terms are
considered, but until then our attention will be restricted to datalog programs.
Example 6.2 Below is given a deductive family-database whose extensional part con-
sists of deﬁnitions of male/1, female/1, father/2 and mother/2 and whose intensional
part consists of parent/2 and grandparent/2:
grandparent(X, Z) ←parent(X, Y ), parent(Y, Z).
parent(X, Y ) ←father(X, Y ).
parent(X, Y ) ←mother(X, Y ).
father(adam, bill).
mother(anne, bill).
father(adam, beth).
mother(anne, beth).
father(bill, cathy).
mother(cathy, donald).
father(donald, eric).
mother(diana, eric).

104
Chapter 6:
Logic and Databases
female(anne).
male(adam).
female(beth).
male(bill).
female(cathy).
male(donald).
female(diana).
male(eric).
In most cases it is possible to organize the database in many alternative ways. Which
organization to choose is of course highly dependent on what information one needs
to retrieve. Moreover, it often determines the size of the database. Finally, in the
case of updates to the database, the organization is very important to avoid inconsis-
tencies in the database — for instance, how should the removal of the labelled tuple
parent(adam, bill) from the database in Example 6.2 be handled? Although updates
are essential in a database system they will not be discussed in this book.
Another thing worth noticing about Example 6.2 is that the unary deﬁnitions
male/1 and female/1 can be seen as type declarations. It is easy to add another such
type declaration for the domain of persons:
person(X) ←male(X).
person(X) ←female(X).
It is now possible to “type” e.g. the database on page 103 by adding to the body of
every clause the type of each argument in the head of the clause:
parent(X, Y ) ←person(X), person(Y ), father(X, Y ).
parent(X, Y ) ←person(X), person(Y ), mother(X, Y ).
father(adam, bill) ←male(adam), person(bill).
father(adam, beth) ←male(adam), person(beth).
...
person(X) ←male(X).
person(X) ←female(X).
...
In this manner, “type-errors” like father(anne, adam) may be avoided.
6.3
Relational Algebra vs. Logic Programs
In database textbooks one often encounters the concept of views.
A view can be
thought of as a relation which is not explicitly stored in the database, but which
is created by means of operations on existing database relations and other views.
Such implicit relations are described by means of some query-language which is often
compiled into relational algebra for the purpose of computing the views.
Below it
will be shown that all standard operations of relational algebra can be mimicked in
logic programming (with negation) in a natural way. The objective of this section is
twofold — ﬁrst it shows that logic programs have at least the computational power
of relational algebra. Second, it also provides an alternative to SLD-resolution as the
operational semantics of a class of logic programs.

6.3 Relational Algebra vs. Logic Programs
105
The primitive operations of relational algebra are union, set diﬀerence, cartesian
product, projection and selection.
Given two n-ary relations over the same domains, the union of the two relations,
R1 and R2 (denoted R1 ∪R2), is the set:
{⟨x1, . . . , xn⟩| ⟨x1, . . . , xn⟩∈R1 ∨⟨x1, . . . , xn⟩∈R2}
Using deﬁnite programs the union of two relations — represented by the predicate
symbols r1/n and r2/n — can be speciﬁed by the two rules:
r(X1, . . . , Xn) ←r1(X1, . . . , Xn).
r(X1, . . . , Xn) ←r2(X1, . . . , Xn).
For instance, if the EDB includes the deﬁnitions father/2 and mother/2, then parent/2
can be deﬁned as the union of the relations father/2 and mother/2:1
parent(X, Y ) ←father(X, Y ).
parent(X, Y ) ←mother(X, Y ).
The diﬀerence R1 \ R2 of two relations R1 and R2 over the same domains yields the
new relation:
{⟨x1, . . . , xn⟩∈R1 | ⟨x1, . . . , xn⟩̸∈R2}
In logic programming it is not possible to deﬁne such relations without the use of
negation; however, using negation it may be deﬁned thus:
r(X1, . . . , Xn) ←r1(X1, . . . , Xn), not r2(X1, . . . , Xn).
For example, let parent/2 and mother/2 belong to the EDB. Now, father/2 can be
deﬁned as the diﬀerence of the relations parent/2 and mother/2:
father(X, Y ) ←parent(X, Y ), not mother(X, Y ).
The cartesian product of two relations R1 and R2 (denoted R1 × R2) yields the new
relation:
{⟨x1, . . . , xm, y1, . . . , yn⟩| ⟨x1, . . . , xm⟩∈R1 ∧⟨y1, . . . , yn⟩∈R2}
Notice that R1 and R2 may have both diﬀerent domains and diﬀerent arities. More-
over, if R1 and R2 contain disjoint sets of attributes they are carried over to the
resulting relation. However, if the original relations contain some joint attribute the
attribute of the two columns in the new relation must be renamed into distinct ones.
This can be done e.g. by preﬁxing the joint attributes in the new relation by the
relation where they came from. For instance, in the relation R(A, B) × S(B, C) the
attributes are, from left to right, A, R.B, S.B and C. Obviously, it is possible to
achieve the same eﬀect in other ways.
In logic programming the cartesian product is mimicked by the rule:
r(X1, . . . , Xm, Y1, . . . , Yn) ←r1(X1, . . . , Xm), r2(Y1, . . . , Yn).
1In what follows we will sometimes, by abuse of language, write “the relation p/n”. Needless to
say, p/n is not a relation but a predicate symbol which denotes a relation.

106
Chapter 6:
Logic and Databases
For instance, let male/1 and female/1 belong to the EDB. Then the set of all male-
female couples can be deﬁned by the rule:
couple(X, Y ) ←male(X), female(Y ).
Projection can be seen as the deletion and/or rearrangement of one or more “columns”
of a relation.
For instance, by projecting the F- and C-attributes of the relation
FATHER(F, C) on the F-attribute (denoted πF (FATHER(F, C))) the new relation:
{⟨x1⟩| ⟨x1, x2⟩∈FATHER}
is obtained. The same can be achieved in Prolog by means of the rule:
father(X) ←father(X, Y ).
The selection of a relation R is denoted σF (R) (where F is a formula) and is the set
of all tuples ⟨x1, . . . , xn⟩∈R such that “F is true for ⟨x1, . . . , xn⟩”. How to translate
such an operation to a logic program depends on the appearance of the constraining
formula F. In general F is only allowed to contain atomic objects, attributes, ∧, ∨, ¬
and some simple comparisons (e.g. “=” and “<”). For instance, the database relation
deﬁned by σY ≥1,000,000 INCOME(X, Y ) may be deﬁned as follows in Prolog:
millionaire(X, Y ) ←income(X, Y ), Y ≥1000000.
Some other operations (like intersection and composition) are sometimes encountered
in relational algebra but they are usually all deﬁned in terms of the mentioned, prim-
itive ones and are therefore not discussed here. However, one of them deserves special
attention — namely the natural join.
The natural join of two relations R and S can be computed only when the columns
are named by attributes. Thus, assume that T1, . . . , Tk are the attributes which appear
both in R and in S. Then the natural join of R and S is deﬁned thus:
R
 S := πA σR.T1=S.T1 ∧··· ∧R.Tk=S.Tk (R × S)
where A is the list of all attributes of R×S with exception of S.T1, . . . , S.Tk. Thus, the
natural join is obtained by (1) taking the cartesian product of the two relations, (2) se-
lecting those tuples which have identical values in the columns with the same attribute
and (3) ﬁltering out the superﬂuous columns. Notice that if R and S have disjoint
sets of attributes, then the natural join reduces to an ordinary cartesian product.
To illustrate the operation, consider the relation deﬁned by F(X, Y )
 P(Y, Z)
where F(X, Y ) and P(Y, Z) are deﬁned according to Figure 6.1(a) and 6.1(b) and
denote the relation between fathers/parents and their children.
Now F(X, Y )
 P(Y, Z) is deﬁned as πX,F.Y,Z σF.Y =P.Y (F(X, Y ) × P(Y, Z)).
Hence the ﬁrst step consists in computing the cartesian product F(X, Y ) × P(Y, Z)
(cf. Figure 6.1(c)). Next the tuples with equal values in the columns named by F.Y
and P.Y are selected (Figure 6.1(d)). Finally this is projected on the X, F.Y and Z
attributes yielding the relation in Figure 6.1(e).
If we assume that father/2 and parent/2 are used to represent the database rela-
tions F and P then the same relation may be deﬁned with a single deﬁnite clause as
follows:

6.4 Logic as a Query-language
107
X
F.Y
P.Y
Z
adam
bill
bill
cathy
bill
cathy
cathy
dave
(d)
X
F.Y
Z
adam
bill
cathy
bill
cathy
dave
(e)
X
Y
adam
bill
bill
cathy
(a)
Y
Z
adam
bill
bill
cathy
cathy
dave
(b)
X
F.Y
P.Y
Z
adam
bill
adam
bill
adam
bill
bill
cathy
adam
bill
cathy
dave
bill
cathy
adam
bill
bill
cathy
bill
cathy
bill
cathy
cathy
dave
(c)
Figure 6.1: Natural join
grandfather(X, Y, Z) ←father(X, Y ), parent(Y, Z).
Notice that the standard deﬁnition of grandfather/2:
grandfather(X, Z) ←father(X, Y ), parent(Y, Z).
is obtained by projecting X, F.Y, Z on X and Z, that is, by performing the operation
πX,Z(F(X, Y )
 P(Y, Z)).
6.4
Logic as a Query-language
In the previous sections it was observed that logic provides a uniform language for
representing both explicit data and implicit data (so-called views). However, deductive
databases are of little or no interest if it is not possible to retrieve information from
the database. In traditional databases this is achieved by so-called query-languages.
Examples of existing query-languages for relational databases are e.g. ISBL, SQL,
QUEL and Query-by-Example.
By now it should come as no surprise to the reader that logic programming can be
used as a query-language in the same way it was used to deﬁne views. For instance,
to retrieve the children of Adam from the database in Example 6.2 one only has to
give the goal clause:
←parent(adam, X).

108
Chapter 6:
Logic and Databases
To this Prolog-systems would respond with the answers X = bill and X = beth, or put
alternatively — the unary relation {⟨bill⟩, ⟨beth⟩}. Likewise, in response to the goal:
←mother(X, Y ).
Prolog produces four answers:
X = anne,
Y = bill
X = anne,
Y = beth
X = cathy,
Y = donald
X = diana,
Y = eric
That is, the relation:
{⟨anne, bill⟩, ⟨anne, beth⟩, ⟨cathy, donald⟩, ⟨diana, eric⟩}
Notice that a failing goal (e.g. ←parent(X, adam)) computes the empty relation as
opposed to a succeeding goal without variables (e.g ←parent(adam, bill)) which com-
putes a singleton relation containing a 0-ary tuple.
Now consider the following excerpt from a database:
likes(X, Y ) ←baby(Y ).
baby(mary).
...
Informally the two clauses say that “Everybody likes babies” and “Mary is a baby”.
Consider the result of the query “Is anyone liked by someone?”. In other words the
goal clause:
←likes(X, Y ).
Clearly Prolog will reply with Y = mary and X being unbound. This is interpreted
as “Everybody likes Mary” but what does it mean in terms of a database relation?
One solution to the problem is to declare a type-predicate and to extend the goal with
calls to this new predicate:
←likes(X, Y ), person(X), person(Y ).
In response to this goal Prolog would enumerate all individuals of type person/1. It is
also possible to add the extra literal person(X) to the database rule. Another approach
which is often employed when describing deductive databases is to adopt certain as-
sumptions about the world which is modelled. One such assumption was mentioned
already in connection with Chapter 4 — namely the closed world assumption (CWA).
Another assumption which is usually adopted in deductive databases is the so-called
domain closure assumption (DCA) which states that “the only existing individuals are
those mentioned in the database”. In terms of logic this can be expressed through the
additional axiom:
∀X(X = c1 ∨X = c2 ∨· · · ∨X = cn)
where c1, c2, . . . , cn are all the constants occurring in the database. With this axiom
the relation deﬁned by the goal above becomes {⟨t, mary⟩| t ∈UP }. However, this
assumes that the database contains no functors and only a ﬁnite number of constants.

6.5 Special Relations
109
6.5
Special Relations
The main objective of this section is to show how to deﬁne relations that possess
certain properties occurring frequently both in real life and in mathematics.
This
includes properties like reﬂexivity, symmetry and transitivity.
Let R be a binary relation over some domain D. Then:
• R is said to be reﬂexive iﬀfor all x ∈D, it holds that ⟨x, x⟩∈R;
• R is symmetric iﬀ⟨x, y⟩∈R implies that ⟨y, x⟩∈R;
• R is anti-symmetric iﬀ⟨x, y⟩∈R and ⟨y, x⟩∈R implies that x = y;
• R is transitive iﬀ⟨x, y⟩∈R and ⟨y, z⟩∈R implies that ⟨x, z⟩∈R;
• R is asymmetric iﬀ⟨x, y⟩∈R implies that ⟨y, x⟩/∈R.
To deﬁne an EDB which possesses one of these properties is usually a rather cumber-
some task if the domain is large. For instance, to deﬁne a reﬂexive relation over a
domain with n elements requires n tuples, or n facts in the case of a logic program.
Fortunately, in logic programming, relations can be deﬁned to be reﬂexive with a single
clause of the form:
r(X, X).
However, in many cases one thinks of the Herbrand universe as the coded union of
several domains. For instance, the Herbrand universe consisting of the constants bill,
kate and love may be thought of as the coded union of persons and abstract notions.
If — as in this example — the intended domain of r/2 (encoded as terms) ranges over
proper subsets of the Herbrand universe and if the type predicate t/1 characterize this
subset, a reﬂexive relation can be written as follows:
r(X, X) ←t(X).
For instance, in order to say that “every person looks like himself” we may write the
following program:
looks like(X, X) ←person(X).
person(bill).
person(kate).
abstract(love).
In order to deﬁne a symmetric relation R it suﬃces to specify only one of the pairs
⟨x, y⟩and ⟨y, x⟩if ⟨x, y⟩∈R. Then the program is extended with the rule:
r(X, Y ) ←r(Y, X).
However, as shown below such programs suﬀer from operational problems.
Example 6.3 Consider the domain:
{sarah, diane, pamela, simon, david, peter}

110
Chapter 6:
Logic and Databases
The relation “. . . is married to . . . ” clearly is symmetric and it may be written either
as an extensional database:
married(sarah, simon).
married(diane, david).
married(pamela, peter).
married(simon, sarah).
married(david, diane).
married(peter, pamela).
or more brieﬂy as a deductive database:
married(X, Y ) ←married(Y, X).
married(sarah, simon).
married(diane, david).
married(pamela, peter).
Transitive relations can also be simpliﬁed by means of rules. Instead of a program P
consisting solely of facts, P can be fully described by the clause:
r(X, Z) ←r(X, Y ), r(Y, Z).
together with all r(a, c) ∈P for which there exists no b (b ̸= a and b ̸= c) such that
r(a, b) ∈P and r(b, c) ∈P.
Example 6.4 Consider the world consisting of the “objects” a, b, c and d:
d
c
b
a
The relation “. . . is positioned over . . . ” clearly is transitive and may be deﬁned either
through a purely extensional database:
over(a, b).
over(a, c).
over(a, d).
over(b, c).
over(b, d).
over(c, d).
or alternatively as the deductive database:
over(X, Z) ←over(X, Y ), over(Y, Z).
over(a, b).
over(b, c).
over(c, d).

6.5 Special Relations
111
The deﬁnitions above are declaratively correct, but they suﬀer from operational prob-
lems when executed by Prolog systems. Consider the goal ←married(diane, david)
together with the deductive database of Example 6.3. Clearly married(diane, david)
is a logical consequence of the program but any Prolog interpreter would go into an
inﬁnite loop — ﬁrst by trying to prove:
←married(diane, david).
Via uniﬁcation with the rule a new goal clause is obtained:
←married(david, diane).
When trying to satisfy married(david, diane) the subgoal is once again uniﬁed with
the rule yielding a new goal, identical to the initial one. This process will obviously
go on forever. The misbehaviour can, to some extent, be avoided by moving the rule
textually after the facts. By doing so it may be possible to ﬁnd some (or all) refutations
before going into an inﬁnite loop. However, no matter how the clauses are ordered,
goals like ←married(diane, diane) always lead to loops.
A better way of avoiding such problems is to use an auxiliary anti-symmetric
relation instead and to take the symmetric closure of this relation. This can be done
by renaming the predicate symbol of the EDB with the auxiliary predicate symbol
and then introducing two rules which deﬁne the symmetric relation in terms of the
auxiliary one.
Example 6.5 The approach is illustrated by deﬁning married/2 in terms of the aux-
iliary deﬁnition wife/2 which is anti-symmetric:
married(X, Y ) ←wife(X, Y ).
married(X, Y ) ←wife(Y, X).
wife(sarah, simon).
wife(diane, david).
wife(pamela, peter).
This program has the nice property that it never loops — simply because it is not
recursive.
A similar approach can be applied when deﬁning transitive relations. A new auxiliary
predicate symbol is introduced and used to rename the EDB. Then the transitive
closure of this relation is deﬁned by means of the following two rules (where p/2
denotes the transitive relation and q/2 the auxiliary one):
p(X, Y ) ←q(X, Y )
p(X, Y ) ←q(X, Z), p(Z, Y ).
Example 6.6 The relation over/2 may be deﬁned in terms of the predicate symbol
on/2:
over(X, Y ) ←on(X, Y ).
over(X, Z) ←on(X, Y ), over(Y, Z).

112
Chapter 6:
Logic and Databases
on(a, b).
on(b, c).
on(c, d).
Notice that recursion is not completely eliminated. It may therefore happen that the
program loops. As shown below this depends on properties of the auxiliary relation.
The transitive closure may be combined with the reﬂexive closure of a relation. Given
an auxiliary relation denoted by q/2, its reﬂexive and transitive closure is obtained
through the additional clauses:
p(X, X).
p(X, Y ) ←q(X, Y ).
p(X, Z) ←q(X, Y ), p(Y, Z).
Actually, the second clause is superﬂuous since it follows logically from the ﬁrst and
third clause: any goal, ←p(a, b), which is refuted through uniﬁcation with the second
clause can be refuted through uniﬁcation with the third clause where the recursive
subgoal is uniﬁed with the ﬁrst clause.
Next we consider two frequently encountered types of relations — namely partial
orders and equivalence relations.
A binary relation is called a partial order if it is reﬂexive, anti-symmetric and
transitive whereas a relation which is reﬂexive, symmetric and transitive is called an
equivalence relation.
Example 6.7 Consider a directed, acyclic graph:
a
b
d
f
c
e
g
It is easy to see that the relation “there is a path from . . . to . . . ” is a partial order
given the graph above. To formally deﬁne this relation we start with an auxiliary,
asymmetric relation (denoted by edge/2) which describes the edges of the graph:
edge(a, b).
edge(c, e).
edge(a, c).
edge(d, f).
edge(b, d).
edge(e, f).
edge(b, e).
edge(e, g).
Then the reﬂexive and transitive closure of this relation is described through the two
clauses:
path(X, X).
path(X, Z) ←edge(X, Y ), path(Y, Z).

6.5 Special Relations
113
←path(a, f).
←edge(b, Y2), path(Y2, f).
←path(b, f).
←edge(a, Y0), path(Y0, f).
←path(a, f).
.....
Figure 6.2: Inﬁnite branch in the SLD-tree
This program does not suﬀer from inﬁnite loops. In fact, no partial order deﬁned in
this way will loop as long as the domain is ﬁnite. However, if the graph contains a
loop it may happen that the program starts looping — consider the addition of a cycle
in the above graph. For instance, an additional edge from b to a:
edge(b, a).
Part of the SLD-tree of the goal ←path(a, f) is depicted in Figure 6.2. The SLD-tree
clearly contains an inﬁnite branch and hence it may happen that the program starts
looping without returning any answers. In Chapter 11 this problem will be discussed
and a solution will be suggested.
Example 6.8 Next consider some points on a map and bi-directed edges between the
points:
a
c
e
b
f
d
This time the relation “there is a path from . . . to . . . ” is an equivalence relation. To
deﬁne the relation we may start by describing one half of each edge in the graph:

114
Chapter 6:
Logic and Databases
edge(a, b).
edge(a, c).
edge(b, c).
edge(d, e).
Next the other half of each edge is described by means of the symmetric closure of the
relation denoted by edge/2:
bi edge(X, Y ) ←edge(X, Y ).
bi edge(X, Y ) ←edge(Y, X).
Finally, path/2 is deﬁned by taking the reﬂexive and transitive closure of this relation:
path(X, X).
path(X, Z) ←bi edge(X, Y ), path(Y, Z).
Prolog programs deﬁning equivalence relations usually suﬀer from termination prob-
lems unless speciﬁc measures are taken (cf. Chapter 11).
6.6
Databases with Compound Terms
In relational databases it is usually required that the domains consist of atomic ob-
jects, something which simpliﬁes the mathematical treatment of relational databases.
Naturally, when using logic programming, nothing prevents us from using structured
data when writing deductive databases. This allows for data abstraction and in most
cases results in greater expressive power and improves readability of the program.
Example 6.9 Consider a database which contains members of families and the ad-
dresses of the families. Imagine that a family is represented by a ternary term family/3
where the ﬁrst argument is the name of the husband, the second the name of the wife
and the last a structure which contains the names of the children. The absence of
children is represented by the constant none whereas the presence of children is rep-
resented by the binary term of the form c(x, y) whose ﬁrst argument is the name of
one child and whose second argument recursively contains the names of the remain-
ing children (intuitively none can be thought of as the empty set and c(x, y) can be
thought of as a function which constructs a set by adding x to the set represented by
y). An excerpt from such a database might look as follows:
address(family(john, mary, c(tom, c(jim, none))), main street(3)).
address(family(bill, sue, none), main street(4)).
parent(X, Y ) ←
address(family(X, Z, Children), Street),
among(Y, Children).
parent(X, Y ) ←
address(family(Z, X, Children), Street),
among(Y, Children).

6.6 Databases with Compound Terms
115
husband(X) ←
address(family(X, Y, Children), Street).
wife(Y ) ←
address(family(X, Y, Children), Street).
married(X, Y ) ←
address(family(X, Y, Children), Street).
married(Y, X) ←
address(family(X, Y, Children), Street).
among(X, c(X, Y )).
among(X, c(Y, Z)) ←
among(X, Z).
The database above can be represented in the form of a traditional database by intro-
ducing a unique key for each family. For example as follows:
husband(f1, john).
husband(f2, bill).
wife(f1, mary).
wife(f2, sue).
child(f1, tom).
child(f1, jim).
address(f1, main street, 3).
address(f2, main street, 4).
parent(X, Y ) ←husband(Key, X), child(Key, Y ).
...
However, the latter representation is less readable and it may also require some extra
book-keeping to make sure that each family has a unique key.
To conclude — the issues discussed in this chapter were raised to demonstrate the
advantages of using logic as a uniform language for representing databases. Facts, rules
and queries can be written in a single language. Moreover, logic supports deﬁnition of
relations via recursive rules, something which is not allowed in traditional databases.
Finally, the use of structured data facilitates deﬁnition of relations which cannot be
made in traditional relational databases. From this stand-point logic programming
provides a very attractive conceptual framework for describing relational databases.
On the other hand we have not raised important issues like how to implement such
databases let alone how to handle updates to deductive databases.

116
Chapter 6:
Logic and Databases
Exercises
6.1 Reorganize the database in Example 6.2 so that father/2 and mother/2 be-
come part of the intensional database.
6.2 Extend Example 6.2 with some more persons. Then deﬁne the following pred-
icate symbols (with obvious intended interpretations):
• grandchild/2
• sister/2
• brother/2
• cousins/2
• uncle/2
• aunt/2
6.3 Consider an arbitrary planar map of countries. Write a program which colours
the map using only four colours so that no two adjacent countries have the same
colour. NOTE: Two countries which meet only pointwise are not considered
to be adjacent.
6.4 Deﬁne the input-output behaviour of AND- and inverter-gates. Then describe
the relation between input and output of the following nets:
y
x
z
v
z
y
x
w
6.5 Translate the following relational algebra expressions into deﬁnite clauses.
• πX,Y (HUSBAND(Key, X)
 WIFE(Key, Y ))
• πX(PARENT(X, Y ) ∪πX σY ≤20,000 INCOME(X, Y ))
6.6 The following clauses deﬁne a binary relation denoted by p/2 in terms of the
relations q/2 and r/2. How would you deﬁne the same relation using relational
algebra?
p(X, Y ) ←q(Y, X).
p(X, Y ) ←q(X, Z), r(Z, Y ).

Exercises
117
6.7 Let R1 and R2 be subsets of D × D. Deﬁne the composition of R1 and R2
using (1) deﬁnite programs; (2) relational algebra.
6.8 Let R1 and R2 be subsets of D × D. Deﬁne the intersection of R1 and R2
using (1) deﬁnite programs; (2) relational algebra.
6.9 An ancestor is a parent, a grandparent, a great-grandparent etc.
Deﬁne a
relation ancestor/2 which is to hold if someone is an ancestor of somebody
else.
6.10 Andrew, Ann, and Adam are siblings and so are Bill, Beth and Basil. Describe
the relationships between these persons using as few clauses as possible.
6.11 Deﬁne a database which relates dishes and all of their ingredients. For instance,
pancakes contain milk, ﬂour and eggs. Then deﬁne a relation which describes
the available ingredients. Finally deﬁne two relations:
• can cook(X) which should hold for a dish X if all its ingredients are
available;
• needs ingredient(X, Y ) which holds for a dish X and an ingredient Y if
X contains Y .
6.12 Modify the previous exercise as follows — add to the database the quantity
available of each ingredient and for each dish the quantity needed of each
ingredient. Then modify the deﬁnition of can cook/1 so that the dish can be
cooked if each of its ingredients is available in suﬃcient quantity.

118
Chapter 6:
Logic and Databases

Chapter 7
Programming with Recursive Data
Structures
7.1
Recursive Data Structures
In the previous chapter we studied a class of programs that manipulate simple data
objects — mostly constants. However, the last section of the chapter introduced the
use of compound terms for representation of more complex worlds — like families
and their members. Such data objects are typically used when there is a need to
represent some collection of individuals where the size is not ﬁxed or when the set of
individuals is inﬁnite. In the example a family may have indeﬁnitely many children.
Such objects are usually represented by means of so called recursive data structures. A
recursive data structure is so called because its data objects may contain, recursively
as substructures, objects of the same “type”. In the previous chapter the functor c/2
was used to represent the children of a family — the ﬁrst argument contained the name
of one child and the second, recursively, a representation of the remaining children.
This chapter discusses some recursive data structures used commonly in logic pro-
grams and programming techniques for dealing with such structures.
7.2
Lists
Some well-known programming languages — for instance Lisp — use lists as the pri-
mary representation of data (and programs). Although logic programming only allows
terms as representations of individuals, it is not very hard to represent lists as terms.
Most Prolog systems even support the use of lists by means of special syntax. We will
ﬁrst introduce a precise concept of list.
Let D be some domain of objects. The set of all lists (over D) is deﬁned inductively
as the smallest set satisfying the following conditions:
119

120
Chapter 7:
Programming with Recursive Data Structures
• the empty list (denoted ϵ) is a list (over D);
• if T is a list (over D) and H ∈D then the pair ⟨H, T⟩is a list (over D).
For instance ⟨1, ⟨2, ϵ⟩⟩is a list over the domain of natural numbers.
In Prolog the empty list ϵ is usually represented by the constant [ ] and a pair is
represented using the binary functor ./2. The list above is thus represented by the
term .(1,.(2, [ ])) and is said to have two elements — “1” and “2”. The possibility
of having diﬀerent types of lists (depending on what domain D one uses) introduces
a technical problem since logic programs lack a type-system. In general we will only
consider types over a universal domain which will be represented by the Herbrand
universe.
To avoid having to refer to the “representation of lists” every time such a term is
referred to, it will simply be called a list in what follows. However, when the word
“list” is used it is important to keep in mind that the object still is a term.
Every list (but the empty one) has a head and a tail. Given a list of the form
.(H, T) the ﬁrst argument is called the head and the second the tail of the list. For
instance, .(1,.(2, [ ])) has the head 1 and tail .(2, [ ]). To avoid this rather awkward
notation, most Prolog systems use an alternative syntax for lists. The general idea is
to write [H|T] instead of .(H, T). But since [1|[2|[ ]]] is about as diﬃcult to write (and
read) as .(1,.(2, [ ])) the following simpliﬁcations are allowed:
• [s1, . . . , sm|[t1, . . . , tn|X]] is usually written [s1, . . . , sm, t1, . . . , tn|X] (m, n > 0);
• [s1, . . . , sm|[t1, . . . , tn]] is usually written [s1, . . . , sm, t1, . . . , tn] (m > 0, n ≥0).
Hence, instead of writing [a|[b|[c|[ ]]]] the notation [a, b, c] is used (note that [c|[ ]] is
written as [c], [b|[c]] is written as [b, c] and [a|[b, c]] is written as [a, b, c]). Similarly
[a, b|[c|X]] is written as [a, b, c|X].
It is easy to write procedures which relate a list to its head and tail (cf. the functions
CAR and CDR in Lisp):
car(Head, [Head|Tail]).
cdr(Tail, [Head|Tail]).
Presented with the goal ←cdr(X, [a, b, c]) Prolog answers X = [b, c].
Now consider the deﬁnition of lists again. Looking more closely at the two state-
ments deﬁning what a list is, it is not very hard to see that both statements can be
formulated as deﬁnite clauses — the ﬁrst statement as a fact and the second as a
recursive rule.
Example 7.1 Formally the deﬁnition of lists can be expressed as follows:
list([ ]).
list([Head|Tail]) ←list(Tail).
This “type”-declaration has two diﬀerent uses — it can (1) be used to test whether a
term is a list or (2) to enumerate/generate all possible lists. In reply to the deﬁnite goal
←list(X) — “Is there some X such that X is a list?” — Prolog starts enumerating

7.2 Lists
121
all possible lists starting with [ ] and followed by [X1], [X1, X2], etc. Remember that
answers containing variables are understood to be universally quantiﬁed — that is,
the second answer is interpreted as “For any X1, [X1] is a list”. (Of course the names
of the variables may diﬀer but are not important anyway.)
The next program considered is actually a version of the among/2 program from
the previous chapter. Here it is called member/2 and it is used to describe membership
in a list. An informal deﬁnition looks as follows:
• X is a member of any list whose head is X;
• if X is a member of Tail then X is a member of any list whose tail is Tail.
Again observe that the deﬁnition is directly expressible as a deﬁnite program!
Example 7.2
member(X, [X|Tail]).
member(X, [Y |Tail]) ←member(X, Tail).
As a matter of fact, the ﬁrst clause does not quite express what we intended. For
instance, the goal ←member(a, [a | b]) has a refutation even though [a | b] is not a list
according to our deﬁnition. Such unwanted inferences could be avoided by strength-
ening the ﬁrst clause into:
member(X, [X|Tail]) ←list(Tail).
Unfortunately the extra condition makes the program less eﬃcient. Resolving a goal
of the form:
←member(tm, [t1, . . . , tm, . . . , tm+n]).
requires n + 1 extra resolution steps. Moreover, it is not necessary to have the extra
condition if the program is used as expected, that is for examination of list membership
only.
Just as list/1 has more than one use depending on how the arguments of the goal
are instantiated, member/2 can be used either to test or to generate answers. For in-
stance, the goal ←member(b, [a, b, c]) has a refutation whereas ←member(d, [a, b, c])
fails. By leaving the ﬁrst argument uninstantiated the member/2-program will enu-
merate the elements of the list in the second argument.
For instance, the goal
←member(X, [a, b, c]) has three refutations with three diﬀerent answers — under
Prolog’s depth-ﬁrst search strategy the ﬁrst answer is X = a, followed by X = b and
ﬁnally X = c. The SLD-tree of the goal is shown in Figure 7.1.
Note that the program computes all the expected answers. Consider instead the
goal ←member(a, X) which reads “Is there some list which contains a?”. The SLD-
tree of the goal is depicted in Figure 7.2.
The ﬁrst answer produced is X = [a | Tail0] which is interpreted as — “For any
Tail 0, [a | Tail 0] has a as a member” or less strictly “Any list starting with a contains
a”. The second success branch ﬁrst binds X to [Y0|Tail 0] and then binds Tail 0 to
[a | Tail 1].
Hence the complete binding obtained for X is [Y0 | [a | Tail1] ] which is

122
Chapter 7:
Programming with Recursive Data Structures
←member(X, [a, b, c]).

X/a
←member(X, [b, c]).

X/b
←member(X, [c]).

X/c
←member(X, [ ]).
@
@
@
   @
@
@
   @
@
@
   Figure 7.1: SLD-tree of the goal ←member(X,[a, b, c])
←member(a, X).

X/[a|Tail0]
←member(a, Tail 0).

Tail0/[a|Tail1]
←member(a, Tail1).

Tail1/[a|Tail2]
@
@
@
X/[Y0|Tail0]
   @
@
@
Tail0/[Y1|Tail1]
   .............
   Figure 7.2: SLD-tree of the goal ←member(a,X)

7.2 Lists
123
equivalent to [Y0, a | Tail1] and is interpreted as “Any list with a as the second element
contains a”. Similarly the third answer is interpreted as “Any list with a as the third
element contains a”. It is not hard to see that there are inﬁnitely many answers of
this kind and the SLD-tree obviously contains inﬁnitely many success branches. This
brings us to an important question discussed brieﬂy in Chapter 3 — what impact has
the textual ordering of clauses in Prolog?
What happens if the clauses in the member/2-program are swapped? Referring
to Figure 7.1 one can see that instead of ﬁrst traversing the leftmost branch in the
SLD-tree the rightmost branch is traversed ﬁrst. This branch will eventually fail, so
the computation backtracks until the ﬁrst answer (which is X = c) is found. Then
the computation backtracks again and the answer X = b is found followed by the ﬁnal
answer, X = a. Thus, nothing much happens — the SLD-tree is simply traversed
in an alternative fashion which means that the answers show up in a diﬀerent order.
This may, of course, have serious impacts if the tree contains some inﬁnite branch —
consider the rightmost branch of the tree in Figure 7.2. Clearly no clause ordering
will aﬀect the size of the tree and it is therefore not possible to traverse the whole
tree (that is, ﬁnd all answers). However if the rightmost branch in the tree is always
selected before the leftmost one the computation will loop for ever without reporting
any answers (although there are answers to the goal).
The halting problem is of course undecidable (i.e. it is in general not possible to
determine whether a program will loop or not), but it is good practice to put facts
before recursive clauses when writing a recursive program. In doing so it is often
possible to ﬁnd all, or at least some, of the answers to a goal before going into an
inﬁnite loop. There is also another good reason for doing this which has to do with
the implementation of modern Prolog compilers. If the rightmost subgoal in the last
clause of a deﬁnition is a recursive call, the Prolog compiler is sometimes able to
produce more eﬃcient machine code.
The next program considered is that of “putting two lists together”. The name
commonly used for the program is append/3 although a more appropriate name would
be concatenate/3. As an example, appending a list [c, d] to another list [a, b] yields
the new list [a, b, c, d]. More formally the relation can be deﬁned as follows:
• appending any list X to the empty list yields the list X;
• if appending Z to Y yields W, then appending Z to [X|Y ] yields [X|W].
Again there is a direct translation of the deﬁnition into a deﬁnite program:
Example 7.3
append([ ], X, X).
append([X|Y ], Z, [X|W]) ←append(Y, Z, W).
Just like the previous programs, the append/3-program can be used in many diﬀerent
ways. Obviously, we can use it to test if the concatenation of two lists equals a third
list by giving the goal:
←append([a, b], [c, d], [a, b, c, d])

124
Chapter 7:
Programming with Recursive Data Structures
←append(Y, Z, [a, b, c, d]).

Y/[ ]
Z/[a, b, c, d]
←append(Y0, Z, [b, c, d]).

Y0/[ ]
Z/[b, c, d]
←append(Y1, Z, [c, d]).

Y1/[ ]
Z/[c, d]
←append(Y2, Z, [d]).

Y2/[ ]
Z/[d]
←append(Y3, Z, [ ]).

Y3/[ ], Z/[ ]
   @
@
@
Y/[a|Y0]
   @
@
@
Y0/[b|Y1]
   @
@
@
Y1/[c|Y2]
   @
@
@
Y2/[d|Y3]
Figure 7.3: SLD-tree of the goal ←append(Y,Z, [a, b, c, d])
It can also be used “as a function” to concatenate two lists into a third list:
←append([a, b], [c, d], X)
in which case the computation succeeds with the answer X = [a, b, c, d]. However, it
is also possible to give the goal:
←append(Y, Z, [a, b, c, d])
which reads — “Are there two lists, Y and Z, such that Z appended to Y yields
[a, b, c, d]?”. Clearly there are two such lists — there are in fact ﬁve diﬀerent possibil-
ities:
Y = [ ]
Z = [a, b, c, d]
Y = [a]
Z = [b, c, d]
Y = [a, b]
Z = [c, d]
Y = [a, b, c]
Z = [d]
Y = [a, b, c, d]
Z = [ ]
By now it should come as no surprise that all of these answers are reported by Prolog.
The SLD-tree of the goal is depicted in Figure 7.3.

7.2 Lists
125
The program can actually be used for even more sophisticated tasks. For instance,
the rule:
unordered(List) ←append(Front, [X, Y |End], List), X > Y.
describes the property of being an unordered list of integers. The clause expresses the
fact that a list is unordered if there are two consecutive elements where the ﬁrst is
greater than the second.
Another example of the use of append/3 is shown in the following clause, which
deﬁnes the property of being a list with multiple occurrences of some element:
multiple(List) ←append(L1, [X|L2], List), append(L3, [X|L4], L2).
The following is an alternative (and perhaps more obvious) deﬁnition of the same
property:
multiple([Head|Tail]) ←member(Head, Tail).
multiple([Head|Tail]) ←multiple(Tail).
The append/3-program can also be used to deﬁne the membership-relation and the
relation between lists and their last elements. (These are left as exercises.) One may
be willing to compare a deﬁnition of the last element of the list based on append/3
with the following direct deﬁnition:
• X is the last element in the list [X];
• if X is the last element in the list Tail then it is also the last element in the list
[Head|Tail].
This can be formalized as follows:
Example 7.4
last(X, [X]).
last(X, [Head|Tail]) ←last(X, Tail).
All of the programs written so far have a similar structure — the ﬁrst clause in each
of them is a fact and the second clause is a recursive rule. In Examples 7.1 and 7.3
the resemblance is even closer: The program of Example 7.1 can be obtained from
that of Example 7.3 by removing the second and third arguments of each atom in the
program. This is no coincidence since (almost) every program that operates on lists
has a uniform structure. Some programs diﬀer slightly from the general pattern, like
examples 7.2 and 7.4 — on the other hand, when removing the ﬁrst argument from
the atoms in these programs, they also closely resemble the list/1-program.
Almost all programs in this chapter (also those which follow) are deﬁned by means
of a technique which looks like that of inductive deﬁnitions of sets.
Remember that relations are sets of tuples. The propositions of an inductive deﬁni-
tion describe which tuples are in, and outside of this set. The ﬁrst proposition (usually
called the basic clause) in the deﬁnition is normally unconditional or uses only already
fully deﬁned relation(s). It introduces some (one or more) initial tuples in the set.

126
Chapter 7:
Programming with Recursive Data Structures
The second proposition (called the inductive clause) states that if some tuples are in
the set (and possibly satisfy some other, already deﬁned relations) then some other
tuples are also in the set. The inductive clause is used to repeatedly “pump up” the
set as much as possible. That is, the basic clause gives a set S0. The inductive clause
then induces a new set S1 from S0. But since S1 may contain tuples which do not
appear in S0, the inductive clause is used on S1 to obtain the set S2 and so on. The
basic and inductive clause are sometimes called direct clauses.
The direct clauses specify that some tuples are in the set (the relation). But that
does not exclude the set from also containing other tuples. For instance, saying that
1 is an integer does not exclude Tom and 17 from being integers. Hence, an inductive
deﬁnition contains also a third clause (called the extremal clause) which states that
no other tuples are in the set than those which belong to it as a result of the direct
clauses. In the deﬁnitions above this last statement is omitted. A justiﬁcation for
this is that deﬁnite programs describe only positive information and it is not possible
to express the extremal clause as a deﬁnite clause. However, taking into account the
negation-as-failure rule, the extremal clause becomes explicit when considering the
completion of the program. For instance the completion of Example 7.1 contains the
formula:
∀X(list(X) ↔X = [ ] ∨∃Head, Tail(X = [Head|Tail] ∧list(Tail)))
The “if”-part of this formula corresponds to the direct clauses whereas the “only if”-
part is the extremal clause which says that an individual is a list only if it is the empty
list or a pair where the tail is a list.
The deﬁnition of list/1 is in some sense prototypical for inductive deﬁnitions of
relations between lists and other objects. The basic clause states that something holds
for the empty list and the inductive clause says that something holds for lists of length
n given that something holds for lists of length m, n > m. This should be contrasted
with the following programs:
list([ ]).
list(Tail) ←list([Head|Tail]).
and:
list([ ]).
list(X) ←list(X).
Declaratively, there is nothing wrong with them. All statements are true in the in-
tended model. However, as inductive deﬁnitions they are incomplete. Both of them
deﬁne the empty list to be the only list. They are not very useful as programs either
since the goal ←list([a]) yields an inﬁnite loop.
Next some other, more complicated, relations between lists are considered. The
ﬁrst relation is that between a list and its permutations. Informally speaking, a per-
mutation of a list is a reordering of its elements. Consider a list with n elements.
What possible reorderings are there? Clearly the ﬁrst element can be put in n diﬀer-
ent positions. Consequently there are n −1 positions where the second element may
be put. More generally there are n −m + 1 positions where the m-th element may be
put. From this it is easy to see that there are n! diﬀerent permutations of a list with
n elements.
The relation between a list and its permutations is deﬁned inductively as follows:

7.2 Lists
127
• the empty list is a permutation of itself;
• If W is a permutation of Y and Z is the result of inserting X into W then Z is
a permutation of [X|Y ].
Or more formally:
Example 7.5
permutation([ ], [ ]).
permutation([X|Y ], Z) ←permutation(Y, W), insert(X, W, Z).
insert(Y, XZ, XYZ) ←append(X, Z, XZ), append(X, [Y |Z], XYZ).
Operationally the rule of the program states the following — “Remove the ﬁrst ele-
ment, X, from the list to be permuted, then permute the rest of the list and ﬁnally
insert X into the permutation”.
The insertion of an element Y into a list XZ is
achieved by ﬁrst splitting XZ into two parts, X and Z.
Then the parts are put
together with Y in-between.
Now the goal ←permutation([a, b, c], X) may be given, to which Prolog replies
with the six possible permutations:
X = [a, b, c]
X = [b, a, c]
X = [b, c, a]
X = [a, c, b]
X = [c, a, b]
X = [c, b, a]
Conceptually this relation is symmetric — that is, if A is a permutation of B then B is
a permutation of A. In other words, the goal ←permutation(X, [a, b, c]) should return
exactly the same answers. So it does (although the order of the answers is diﬀerent)
but after the ﬁnal answer the program goes into an inﬁnite loop. It turns out that
recursive programs with more than one body-literal have to be used with some care.
They cannot be called as freely as programs with only a single literal in the body.
If, for some reason, the need arises to call permutation/2 with the ﬁrst argument
uninstantiated and still have a ﬁnite SLD-tree, the body literals have to be swapped
both in the rule of permutation/2 and in insert/3. After doing this the computation
terminates, which means that the SLD-tree of the goal is ﬁnite. Hence, when changing
the order of the body literals in a clause (or put alternatively, using another compu-
tation rule), a completely diﬀerent SLD-tree is obtained, not just a diﬀerent traversal
of the same tree. As observed above, it is not unusual that one ordering leads to an
inﬁnite SLD-tree whereas another ordering results in a ﬁnite SLD-tree. Since Prolog
uses a ﬁxed computation rule, it is up to the user to make sure that the ordering is
“optimal” for the intended use. In most cases this implies that the program only runs
eﬃciently for certain types of goals — for other goals it may be very ineﬃcient or even
loop indeﬁnitely (as shown above). If the user wants to run the program in diﬀerent
“directions”, it is often necessary to have several versions of the program with diﬀerent

128
Chapter 7:
Programming with Recursive Data Structures
orderings of literals. Needless to say, some programs loop no matter how the body
literals are ordered.
The permutation/2-program can be used to sort, for instance, lists of natural
numbers. The classical speciﬁcation of the relation between a list and its sorted version
says that — “Y is a sorted version of X if Y is a sorted permutation of X”. Together
with the property sorted/1 (which holds if a list of integers is sorted in ascending
order) the relation may be deﬁned thus (nsort/2 stands for naive sort):
Example 7.6
nsort(X, Y ) ←permutation(X, Y ), sorted(Y ).
sorted([ ]).
sorted([X]).
sorted([X, Y |Z]) ←X ≤Y, sorted([Y |Z]).
The predicate symbol ≤/2 which is used to compare integers is normally predeﬁned
as a so called built-in predicate in most Prolog systems. Needless to say, this program
is incredibly ineﬃcient. For more eﬃcient sorting programs the reader is advised to
solve exercises 7.10 – 7.12. However, the program illustrates quite clearly why the
order among the atoms in the body of a clause is important. Consider the goal:
←nsort([2, 1, 3], X).
This reduces to the new goal:
←permutation([2, 1, 3], X), sorted(X).
With the standard computation rule this amounts to ﬁnding a permutation of [2, 1, 3]
and then checking if this is a sorted list. Not a very eﬃcient way of sorting lists but
it is immensely better than ﬁrst ﬁnding a sorted list and then checking if this is a
permutation of the list [2, 1, 3] which would be the eﬀect of switching the order among
the subgoals. Clearly there are only six permutations of a three-element list but there
are inﬁnitely many sorted lists.
The deﬁnition of sorted/1 diﬀers slightly from what was said above — there are
two basic clauses, one for the empty list and one for the list with a single element. It
may also happen that there are two or more inductive clauses (cf. exercise 7.12).
The last example considered here is that of reversing a list. Formally the relation
between a list and its reversal is deﬁned as follows:
Example 7.7
reverse([ ], [ ]).
reverse([X|Y ], Z) ←reverse(Y, W), append(W, [X], Z).
Or more informally:
• the empty list is the reversal of itself;

7.3 Diﬀerence Lists
129
list1
list2
last1
last2
1
2
3
4
Figure 7.4: Representation of lists
• if W is the reversal of Y and Z is the concatenation of W and [X] then Z is the
reversal of [X|Y ].
Operationally, the second clause says the following — “to reverse [X|Y ], ﬁrst reverse
Y into W then concatenate W with [X] to obtain Z”. Just like in Example 7.5 the
goal ←reverse([a, b, c], X) has a ﬁnite SLD-tree whereas ←reverse(X, [a, b, c]) has
an inﬁnite one. However, when switching the order of the literals in the body of the
recursive clause, the situation becomes the opposite.
7.3
Diﬀerence Lists
The computational cost of appending two lists in Prolog is typically proportional to the
length of the ﬁrst list. In general a linear algorithm is acceptable but other languages
often facilitate concatenation of lists in constant time. The principal idea to achieve
constant time concatenation is to maintain a pointer to the end of the list as shown
in Figure 7.4. In order to append the two lists the following Pascal-like commands are
needed:
...
last1^.pointer := list2;
last1 := last2;
...
In Prolog the same technique can be adopted by using “variables as pointers”. Assume
that, in the world of lists, there is a (partial) function which given two lists where the
second is a suﬃx of the ﬁrst, returns the list obtained by removing the suﬃx from the
ﬁrst (that is, the result is a preﬁx of the ﬁrst list). Now let the functor “−” denote
this function, then the term:
[t1, . . . , tm, tm+1, . . . , tm+n] −[tm+1, . . . , tm+n]
denotes the same list as does [t1, . . . , tm]. More generally, [a, b, c|L]−L denotes the list
[a, b, c] for any list assigned to L. As a special case the term L−L designates the empty
list for any list assigned to L. It is now possible to use this to deﬁne concatenation of
diﬀerence lists:

130
Chapter 7:
Programming with Recursive Data Structures
append(X −Y, Y −Z, X −Z).
Declaratively this stands for “Appending the diﬀerence of Y and Z to the diﬀerence
of X and Y yields the diﬀerence of X and Z”. The correctness of the statement is
easier to see when written as follows:
t1 . . . ti ti+1 . . . tj tj+1 . . . tk
|
{z
}
Z
|
{z
}
Y
|
{z
}
X
Using the new deﬁnition of append/3 it is possible to refute the goal:
←append([a, b|X] −X, [c, d|Y ] −Y, Z)
in a single resolution-step and the computed answer substitution becomes:
{X/[c, d|Y ], Z/[a, b, c, d|Y ] −Y }
which implies that:
append([a, b, c, d|Y ] −[c, d|Y ], [c, d|Y ] −Y, [a, b, c, d|Y ] −Y )
is a logical consequence of the program.
The ability to concatenate lists in constant time comes in quite handy in some
programs. Take for instance the program for reversing lists in Example 7.7. The time
complexity of this program is O(n2) where n is the number of elements in the list
given as the ﬁrst argument. That is, to reverse a list of 100 elements approximately
10,000 resolution steps are needed.
However, using diﬀerence lists it is possible to write a program which does the
same job in linear time:
Example 7.8
reverse(X, Y ) ←rev(X, Y −[ ]).
rev([ ], X −X).
rev([X|Y ], Z −W) ←rev(Y, Z −[X|W]).
This program reverses lists of n elements in n + 2 resolution steps.
Unfortunately, the use of diﬀerence lists is not without problems. Consider the
goal:
←append([a, b] −[b], [c, d] −[d], L).
One expects to get an answer that represents the list [a, c]. However, Prolog cannot
unify the subgoal with the only clause in the program and therefore replies “no”. It
would be possible to write a new program which also handles this kind of goal, but
it is not possible to write a program which concatenates lists in constant time (which
was the main objective for introducing diﬀerence lists in the ﬁrst place).
Another problem with diﬀerence lists is due to the lack of occur-check in most
Prolog systems. A program that speciﬁes the property of being an empty list may
look as follows:

Exercises
131
empty(L −L).
Clearly, [a|Y ]−Y is not an empty list (since it denotes the list [a]). However, the goal
←empty([a|Y ] −Y ) succeeds with Y bound to an inﬁnite term.
Yet another problem with diﬀerence lists stems from the fact that “−” designates
a partial function. Thus far nothing has been said about the meaning of terms such
as [a, b, c] −[d]. For instance the goal:
←append([a, b] −[c], [c] −[b], L)
succeeds with the answer L = [a, b] −[b]. Again such problems can be solved with
additional computational eﬀorts. The append/3 program may for instance be written
as follows:
append(X −Y, Y −Z, X −Z) ←suﬃx(Y, X), suﬃx(Z, Y ).
But this means that concatenation of lists becomes linear again.
Exercises
7.1 Write the following lists as terms with “.” (dot) as functor and [ ] representing
the empty list:
[a, b]
[a | [b, c]]
[a | b]
[a, b | [ ]]
[a, [b, c], d]
[[ ] | [ ]]
[a, b | X]
[a | [b, c | [ ]]]
7.2 Deﬁne a binary relation last/2 between lists and their last elements using only
the predicate append/3.
7.3 Deﬁne the membership-relation by means of the append/3-program.
7.4 Deﬁne a binary relation length/2 between lists and their lengths (i.e. the num-
ber of elements in them).
7.5 Deﬁne a binary relation lshift/2 between lists and the result of shifting them
(circularly) one step to the left. For example, so that the goal:
←lshift([a, b, c], X)
succeeds with the answer X = [b, c, a].
7.6 Deﬁne a binary relation rshift/2 between lists and the result of shifting them
(circularly) one step to the right. For example, so that the goal:
←rshift([a, b, c], X)
succeeds with the answer X = [c, a, b].
7.7 Deﬁne a binary relation preﬁx/2 between lists and all its preﬁxes. Hint: [ ], [a]
and [a, b] are preﬁxes of the list [a, b].

132
Chapter 7:
Programming with Recursive Data Structures
7.8 Deﬁne a binary relation suﬃx/2 between lists and all its suﬃxes. Hint: [ ], [b]
and [a, b] are suﬃxes of the list [a, b].
7.9 Deﬁne a binary relation sublist/2 between lists and their sublists.
7.10 Implement the insert-sort algorithm for integers in Prolog — informally it can
be formulated as follows:
Given a list, remove its ﬁrst element, sort the rest, and insert the
ﬁrst element in its appropriate place in the sorted list.
7.11 Implement the quick-sort algorithm for integers in Prolog — informally it can
be formulated as follows:
Given a list, split the list into two — one part containing elements
less than a given element (e.g. the ﬁrst element in the list) and one
part containing elements greater than or equal to this element. Then
sort the two lists and append the results.
7.12 Implement the merge-sort algorithm for integers in Prolog — informally it can
be formulated as follows:
Given a list, divide the list into two halves. Sort the halves and
“merge” the two sorted lists.
7.13 A nondeterministic ﬁnite automaton (NFA) is a tuple ⟨S, Σ, T, s0, F⟩where:
• S is a ﬁnite set of states;
• Σ is a ﬁnite input alphabet;
• T ⊆S × S × Σ is a transition relation;
• s0 ∈S is an initial state;
• F ⊆S is a set of ﬁnal states.
A string x1x2 . . . xn ∈Σn is accepted by an NFA if there is a sequence:
⟨s0, s1, x1⟩, ⟨s1, s2, x2⟩, · · · , ⟨sn−1, sn, xn⟩∈T ∗
such that sn ∈F. An NFA is often depicted as a transition diagram whose
nodes are states and where the transition relation is denoted by labelled edges
between nodes. The ﬁnal states are indicated by double circles. Deﬁne the
NFA depicted in Figure 7.5 as a logic program (let 1 be the initial state).
Use the program to check if strings (represented by lists of a’s and b’s) are
accepted.
7.14 Informally speaking, a Turing machine consists of an inﬁnite tape divided into
slots which may be read from/written into by a tape-head. In each slot there
is exactly one of two symbols called “blank” (denoted by 0) and “nonblank”
(denoted by 1). Initially the tape is almost blank — the number of slots from
the “leftmost” to the “rightmost” nonblank of the tape is ﬁnite. This sequence
(string) will be referred to as the content of the tape. The machine is always

Exercises
133
start
1
2
3
b
a
b
a
Figure 7.5: Transition diagram for NFA
in one of a ﬁnite number of states, some of which are called ﬁnal and one of
which is called initial.
The tape-head is situated at exactly one of the slots of the tape. Depending
on the contents of this slot and the current state, the machine makes one of a
number of possible moves:
• It writes 0 or 1 in the slot just read from, and
• changes state, and
• moves the tape-head one slot to the right or to the left.
This can be described through a function, which maps the current state and
the symbol in the current slot of the tape into a triple which consists of a new
state, the symbol written in the current slot and the direction of the move.
To start with the machine is in the initial state and the tape-head is situated
at the “leftmost” nonblank of the tape. A string is said to be accepted by a
Turing machine iﬀit is the initial contents of the tape and there is a ﬁnite
sequence of moves that take the machine to one of its ﬁnal states.
Write a Turing machine which accepts a string of n (n > 0) consecutive 1’s
and halts pointing to the leftmost nonblank in a sequence of 2 ∗n 1’s. This
illustrates another view of Turing machines, not only as language acceptors,
but as a function which takes as input a natural number n represented by n
consecutive 1’s and produces some output represented by the consecutive 1’s
starting in the slot pointed to when the machine halts.
7.15 Write a program for multiplying matrices of integers. Obviously the program
should succeed only if the number of columns of the ﬁrst matrix equals the
number of rows in the second. Then write a specialized program for multiplying
matrices of ﬁxed size.
7.16 Find some suitable representation of sets. Then deﬁne some standard opera-
tions on sets, like union, intersection, membership, set-diﬀerence.
7.17 Represent strings by diﬀerence lists. Deﬁne the property of being a palindrome.
7.18 Use the concept of diﬀerence list to implement the quick-sort algorithm in
exercise 7.11.
7.19 Use diﬀerence lists to deﬁne queues. That is, a ﬁrst-in-ﬁrst-out stack. Write re-
lations that describe the eﬀects of adding new objects to and removing objects
from queues.

134
Chapter 7:
Programming with Recursive Data Structures
7.20 Deﬁne the property of being a binary tree. Then deﬁne what it means for an
element to be a member of a binary tree.
7.21 A binary tree is said to be sorted if for every node N in the tree, the nodes
in the left subtree are all less than N and all nodes in the right subtree are
greater than N. Deﬁne this by means of a deﬁnite program and then deﬁne
relations for adding and deleting nodes in a sorted binary tree (so that it stays
sorted).
7.22 Write a program for ﬁnding a minimal spanning tree in a weighted loop-free
undirected connected graph.

Chapter 8
Amalgamating Object- and
Meta-language
8.1
What is a Meta-language?
Generally speaking a language is a, usually inﬁnite, collection of strings. For a given
language L, some existing language has to be used to formulate and reason about the
semantics and syntax of the language L. Sometimes a language is used to describe
itself. This is often the case when reasoning about English (or any natural language
for that matter). The following are examples of such sentences:
This sentence consists of ﬁfty two letters excluding blanks
Rabbit is a noun
A language which is used to reason about another language (or possibly itself) is
called a meta-language and the language reasoned about is called the object-language.
Obviously the meta- and object-languages do not have to be natural languages — they
can be any, more or less, formal languages. In the previous chapters English was used
to describe the language of predicate logic and in forthcoming chapters logic will be
used to formulate rules describing a subset of natural language. In this chapter special
interest is paid to the use of logic programs as a meta-language for describing other
languages, and in particular the use of logic programs to describe logic programming.
In computer science the word “meta” is used extensively in diﬀerent contexts, and
its meaning is not always very clear. In this book the word “meta-program” will be
used for a program that manipulates other programs. With this rather broad def-
inition, programs like compilers, interpreters, debuggers and even language speciﬁc
editors are considered to be meta-programs. The main topic of this chapter is inter-
preters but in subsequent chapters other applications are considered.
135

136
Chapter 8:
Amalgamating Object- and Meta-language
An interpreter describes the operational semantics of a programming language —
in a very general sense it takes as input a program and some data, and produces
as output some (new) data. The language used to implement the interpreter is the
meta-language and the language being interpreted is the object-language.
In this
chapter some alternative interpreters for “pure” Prolog (i.e. Prolog without built-in
predicates) written in Prolog will be presented. Such interpreters are commonly called
meta-circular interpreters1 or simply self-interpreters.
When writing an interpreter for a language one of the most vital decisions is how to
represent programs and data-objects of the object-language in the meta-language. In
this chapter some advantages and drawbacks of various representations are discussed.
First the object-language will be represented by ground terms of the meta-language
but later we show a technique for integration of the object-language with the meta-
language. This may lead to serious ambiguities since it is not always possible to tell
whether a statement, or part of a statement, belongs to the object-language or the
meta-language. For example, consider the following sentence of natural language:
Stockholm is a nine-letter word
If this is a sentence of a meta-language describing the form of words in an object lan-
guage then “Stockholm” denotes itself, and the sentence is a true statement. However,
if “Stockholm” denotes the capital, the statement is false.
8.2
Ground Representation
As discussed in previous chapters logic describes relations between individuals of some
universe (domain). Clearly nothing prevents us from describing the world that consists
of terms and formulas. For this, all constants, variables, compound terms and formulas
of the object-language should be represented uniquely as terms of the meta-language.
One possible representation of deﬁnite programs may look as follows:
• each constant of the object-language is represented by a unique constant of the
meta-language;
• each variable of the object-language is represented by a unique constant of the
meta-language;
• each n-ary functor of the object-language is represented by a unique n-ary functor
of the meta-language;
• each n-ary predicate symbol of the object-language is represented by a unique
n-ary functor of the meta-language;
• each connective of the object-language is represented by a unique functor of the
meta-language (with the corresponding arity).
The representation can be given in terms of a bijective mapping φ from constants,
variables, functors, predicate symbols and connectives of the object-language to a
1The term meta-interpreter is often used as an abbreviation for meta-circular interpreter. However,
the word is somewhat misleading since any interpreter is a meta-interpreter.

8.2 Ground Representation
137
subset of the constants and functors of the meta-language. The meta-language may of
course also contain other symbols — in particular some predicate symbols. However,
leaving them aside for the moment, the domain of the intended interpretation ℑof
the meta-language consists of terms and formulas of the object-language. Now the
meaning of the constants and functors introduced above are given by the bijection φ,
or rather by its inverse (φ−1) as follows:
• The meaning cℑof a constant c of the meta-language is the constant or variable
φ−1(c) of the object-language.
• The meaning fℑof an n-ary functor f of the meta-language is an n-ary function
which maps:
(i) the terms t1, . . . , tn to the term φ−1(f)(t1, . . . , tn) if φ−1(f) is a functor of
the object-language;
(ii) the terms t1, . . . , tn to the atom φ−1(f)(t1, . . . , tn) if φ−1(f) is a predicate
letter of the object-language;
(iii) the formulas f1, . . . , fn to the formula φ−1(f)(f1, . . . , fn) if φ−1(f) is a
connective of the object-language.
Example 8.1 Take as object-language a language with an alphabet consisting of the
constants a and b, the predicate letters p/1 and q/2, the connectives ∧and ←and an
inﬁnite but enumerable set of variables including X.
Now assume that the meta-language contains the constants a, b and x and the
functors p/1, q/2, and/2 and if /2 with the obvious intended interpretation. Then the
meaning of the meta-language term:
if (p(x), and(q(x, a), p(b)))
is the object-language formula:
p(X) ←q(X, a) ∧p(b)
It should be noted that the discussion above avoids some important considerations. In
particular, the interpretation of meta-language functors consists of partial, not total,
functions. For instance, nothing said about the meaning of “ill-formed” terms such
as:
if (p(and(a, b)), q(if (a, b)))
Predicate logic requires that functors are interpreted as total functions and formally
such terms must also have some kind of meaning. There are diﬀerent methods to deal
with the problem. However, they are not discussed here.
The coding of object-language expressions given above is of course only one possi-
bility. In fact, in what follows we will not commit ourselves to any particular repre-
sentation of the object-language. Instead
pAq will be used to denote some particular
representation of the object-language construction A. This makes it possible to present
the idea without discussing technical details of a particular representation.

138
Chapter 8:
Amalgamating Object- and Meta-language
It is now possible to describe relations between terms and formulas of the object-
language in the meta-language.
In particular, our intention is to describe SLD-
resolution and SLD-derivations. The ﬁrst relation considered is that between con-
secutive goals, Gi and Gi+1 (i ≥0), in an SLD-derivation:
G0
C0
 G1 · · · Gi
Ci
 Gi+1
The relationship between two such goals can be expressed through the following “in-
ference rule” discussed in Chapter 3:
←A1, . . . , Ai−1, Ai, Ai+1, . . . , An
B0 ←B1, . . . , Bm
←(A1, . . . , Ai−1, B1, . . . , Bm, Ai+1, . . . , An)θ
where θ is the mgu of the two atoms Ai and B0 and where B0 ←B1, . . . , Bm is a
renamed clause from the program. The relation between the two goals in the rule can
be formulated as the following deﬁnite clause:
Example 8.2
step(Goal, NewGoal) ←
select(Goal, Left, Selected, Right),
clause(C),
rename(C, Goal, Head, Body),
unify(Head, Selected, Mgu),
combine(Left, Body, Right, TmpGoal),
apply(Mgu, TmpGoal, NewGoal).
Informally the intended interpretation of the used predicate symbols is as follows:
• select(A, B, C, D) describes the relation between a goal A and the selected sub-
goal C in A. B and D are the conjunctions of subgoals to the left and right of
the selected one (obviously if A contains only C then B and D are empty);
• clause(A) describes the property of being a clause in the object-language pro-
gram;
• rename(A, B, C, D) describes the relation between four formulas such that C
and D are renamed variants of the head and body of A containing no variables
in common with B;
• unify(A, B, C) describes the relation between two atoms, A and B, and their
mgu C;
• combine(A, B, C, D) describes the relation between a goal D and three conjunc-
tions which, when combined, form the conjunction D;
• apply(A, B, C) describes the relation between a substitution A and two goals
such that A applied to B yields C.

8.2 Ground Representation
139
Some alternative approaches for representing the object-level program have been sug-
gested in the literature. The most general approach is to explicitly carry the program
around using an extra argument. Here a more pragmatic approach is employed where
each clause C of the object-program is stored as a fact, clause(pC
q), of the meta-
language. For instance, clause/1 may consist of the following four facts:
Example 8.3
clause(pgrandparent(X, Z) ←parent(X, Y ), parent(Y, Z)q).
clause(pparent(X, Y ) ←father(X, Y )q).
clause(pfather(adam, bill)q).
clause(pfather(bill, cathy)q).
The task of completing select/4 and the other undeﬁned relations in Example 8.2 is
left as an exercise for the reader.
The relation derivation/2 between two goals G0 and Gi of an SLD-derivation (i.e. if
there is a derivation whose initial goal is G0 and ﬁnal goal is Gi) can be described as the
reﬂexive and transitive closure of the inference rule above. Thus, an SLD-derivation
can be described by means of the following two clauses:
Example 8.4
derivation(G, G).
derivation(G0, G2) ←
step(G0, G1),
derivation(G1, G2).
If all undeﬁned relations were properly deﬁned it would be possible to give the goal
clause:
←derivation(p←grandparent(adam, X)q,
pq).
(where
pq denotes the coding of the empty goal). This corresponds to the query
“Is there a derivation from the object-language goal ←grandparent(adam, X) to the
empty goal?”. The meta-language goal is reduced to:
←step(p←grandparent(adam, X)q, G), derivation(G,
pq).
The leftmost subgoal is then satisﬁed with G bound to the representation of the
object-language goal ←parent(adam, Y ), parent(Y, X) yielding:
←derivation(p←parent(adam, Y ), parent(Y, X)q,
pq).
Again this is uniﬁed with the second clause of derivation/2:
←step(p←parent(adam, Y ), parent(Y, X)q, G), derivation(G,
pq).
The computation then proceeds until the goal:
←derivation(pq,
pq).

140
Chapter 8:
Amalgamating Object- and Meta-language
is obtained. This uniﬁes with the fact of derivation/2 and Prolog produces the answer
“yes”. Note that the answer obtained to the initial goal is only “yes” since the goal
contains no variables (only object-language variables which are represented as ground
terms in the meta-language). The modiﬁed version of the program which also returns
a substitution may look as follows:
Example 8.5
derivation(G, G,
pϵ q).
derivation(G0, G2, S0) ←
step(G0, G1, Mgu),
derivation(G1, G2, S1),
compose(Mgu, S1, S0).
step(Goal, NewGoal, Mgu) ←
select(Goal, Left, Selected, Right),
clause(C),
rename(C, Goal, Head, Body),
unify(Head, Selected, Mgu),
combine(Left, Body, Right, TmpGoal),
apply(Mgu, TmpGoal, NewGoal).
Now what is the point in having self-interpreters? Surely it must be better to let an
interpreter run the object-language directly, instead of letting the interpreter run a
self-interpreter which runs the object-program? The answer is that self-interpreters
provide great ﬂexibility for modifying the behaviour of the logical machinery. With a
self-interpreter it is possible to write:
• interpreters which employ alternative search strategies — for instance, to avoid
using Prolog’s depth-ﬁrst search, an interpreter which uses a breadth-ﬁrst strat-
egy may be written in Prolog and run on the underlying machine which uses
depth-ﬁrst search;
• debugging facilities — for instance, interpreters which emit traces or collect run-
time statistics while running the program;
• interpreters which allow execution of a program which changes during its own
execution — desirable in many A.I. applications or in the case of database up-
dates;
• interpreters which collect the actual proof of a satisﬁed goal — something which
is of utmost importance in expert-systems applications (see the next chapter);
• interpreters for nonstandard logics or “logic-like” languages — this includes
fuzzy logic, nonmonotonic logic, modal logic, context-free grammars and Def-
inite Clause Grammars (see Chapter 10).
Applications like compilers and language speciﬁc editors have already been mentioned.
Furthermore, meta-circular interpreters play a very important role in the area of pro-
gram transformation, veriﬁcation and synthesis — topics which are outside the scope
of this book.

8.3 Nonground Representation
141
8.3
Nonground Representation
Although the interpreters in the previous section are relatively clear and concise, they
suﬀer severely from eﬃciency problems. The ineﬃciency is mainly due to the rep-
resentation of object-language variables by constants in the meta-language.
As a
consequence, rather complicated deﬁnitions of renaming, uniﬁcation and application
of substitutions to terms/formulas are needed. In this section a less logical and more
pragmatic approach is employed resulting in an extremely short interpreter. The idea
is to represent object-language variables by meta-language variables — the whole ap-
proach seems straightforward at ﬁrst sight, but it has severe semantical consequences
some of which are raised below.
In addition to representing variables of the object-language by variables of the
meta-language, an object-language clause of the form:
A0 ←A1, . . . , An
will be represented in the meta-language by the term:2
A0 if A1 and . . . and An
when n ≥1
A0 if true
when n = 0
Similarly, a goal ←A1, . . . , An of the object-language will be represented by the term
A1 and . . . and An when n ≥1 and true when n = 0.
The object-language program in Example 8.3 is thus represented by the following
collection of meta-language facts:
Example 8.6
clause(grandparent(X, Z) if parent(X, Y ) and parent(Y, Z)).
clause(parent(X, Y ) if father(X, Y )).
clause(father(adam, bill) if true).
clause(father(bill, cathy) if true).
The interpreter considered in this section simply looks as follows:
Example 8.7
solve(true).
solve(X and Y ) ←solve(X), solve(Y ).
solve(X) ←clause(X if Y ), solve(Y ).
In what follows we will describe how operations which had to be explicitly spelled
out in the earlier interpreters, are now performed automatically on the meta-level.
Consider ﬁrst uniﬁcation:
Let ←parent(adam, bill) be an object-language goal. In order to ﬁnd a refutation
of this goal we may instead consider the following meta-language goal:
2Here it is assumed that and/2 is a right-associative functor that binds stronger than if /2. That
is, the expression a if b and c and d is identical to the term if (a, and(b, and(c, d))).

142
Chapter 8:
Amalgamating Object- and Meta-language
←solve(parent(adam, bill)).
The subgoal obviously uniﬁes only with the head of the third clause in Example 8.7.
The goal thus reduces to the new goal:
←clause(parent(adam, bill) if Y0), solve(Y0).
Now the leftmost subgoal uniﬁes with the second clause of Example 8.6, resulting in
the new goal:
←solve(father(adam, bill)).
This means that the uniﬁcation of the object-language atom parent(adam, bill) and
the head of the object-language clause parent(X, Y ) ←father(X, Y ) is performed au-
tomatically on the meta-level. There is no need to provide a deﬁnition of uniﬁcation
of object-language formulas as was needed in Example 8.2.
The same eﬀect is achieved when dealing with renaming of variables in object-
language clauses. Consider the goal:
←solve(parent(X, bill)).
This reduces to the new goal:
←clause(parent(X, bill) if Y0), solve(Y0).
Note that the goal and the second clause of Example 8.6 both contain the variable
X. However, the variables of the rule are automatically renamed on the meta-level so
that the next goal becomes:
←solve(father(X, bill)).
Finally, application of a substitution to a goal is considered. The goal:
←clause(father(adam, X) and father(X, Y )).
which represents the object-language goal ←father(adam, X), father(X, Y ) is resolved
with the second clause of Example 8.7 and the goal:
←solve(father(adam, X)), solve(father(X, Y ))
is obtained. This goal is resolved with the third clause of Example 8.7 yielding:
←clause(father(adam, X) if Y1), solve(Y1), solve(father(X, Y )).
Now the leftmost subgoal uniﬁes with the clause:
clause(father(adam, bill) if true).
and the mgu {X/bill, Y1/true} is obtained. This substitution is used to construct the
new goal:
←solve(true), solve(father(bill, Y )).

8.4 The Built-in Predicate clause/2
143
Note that the mgu obtained in this step contains the “object-language substitution”
{X/bill} and that there is no need to apply it explicitly to the subgoal father(X, Y )
as was the case in the previous section.
Hence, by using the interpreter in Example 8.7 instead of that in the previous
section, three of the most laborious operations (uniﬁcation, renaming and application)
are no longer explicitly needed. They are of course still performed but they now take
place on the meta-level.
Yet another advantage of the interpreter in Example 8.7 is that there is no need
to explicitly handle substitutions of the object program. By giving the goal:
←solve(grandparent(adam, X)).
Prolog gives the answer X = cathy since the object-language variable X is now repre-
sented as a meta-language variable. In the previous section object-language variables
were represented by ground terms and to produce a computed answer substitution it
was necessary to explicitly represent such substitutions.
Although the program in Example 8.7 works quite nicely, its declarative reading is
far from clear. Its simplicity is due to the representation of object-language variables as
meta-language variables. But this also introduces problems as pointed out by Hill and
Lloyd (1988a). Namely, the variables in solve/1 and in clause/1 range over diﬀerent
domains — the variables in solve/1 range over formulas of the object-language whereas
the variables in clause/1 range over individuals of the intended interpretation of the
object-language program (intuitively the persons Adam, Bill and Cathy and possibly
some others). The problem can, to some extent, be solved by using a typed language
instead of standard predicate logic. However, this discussion is outside the scope of
this book.
The interpreter in Example 8.7 can be used for, what is sometimes called, pure
Prolog.
This means that the object-program and goal are not allowed to contain
constructs like negation. However, the interpreter may easily be extended to also take
proper care of negation by including the rule:
solve(not X) ←not solve(X).
Similar rules can be added for most built-in predicates of Prolog. One exception is
cut (!), which is diﬃcult to incorporate into the self-interpreter above. However, with
some eﬀort it can be done (see e.g. O’Keefe (1990)).
8.4
The Built-in Predicate clause/2
To better support meta-programming, the Prolog standard provides a number of so
called built-in predicates.
In this section and the following two, some of them are
brieﬂy discussed.
For a complete description of the built-in predicates the reader
should consult his/her own Prolog user’s manual or the ISO Prolog standard (1995).
For the interpreter in Example 8.7 to work, the object-program has to be stored as
facts of the form clause(pC
q), where
pC
q is the representation of an object-language
clause. The built-in predicate clause/2 allows the object-program to be stored “di-
rectly as a meta-program”. The eﬀect of executing clause/2 can be described by the

144
Chapter 8:
Amalgamating Object- and Meta-language
following “inference rule” (assuming that Prolog’s computation rule is used and that
t1 and t2 are terms):
←clause(t1, t2), A2, . . . , Am
B0 ←B1, . . . , Bn
←(A2, . . . , Am)θ
where B0 ←B1, . . . , Bn is a (renamed) program clause and θ is an mgu of clause(t1, t2)
and clause(B0, (B1, . . . , Bn)). Here comma is treated as a binary functor which is
right-associative. That is, the expression (a, b, c) is the same term as ’,’(a, ’,’(b, c)).
For uniformity, a fact A, is treated as a rule of the form A ←true.
Note that there may be more than one clause which uniﬁes with the arguments of
clause(t1, t2). Hence, there may be several possible derivations. For instance, consider
the program:
father(X, Y ) ←parent(X, Y ), male(X).
father(adam, bill).
In case of the goal ←clause(father(X, Y ), Z) Prolog replies with two answers. The
ﬁrst answer binds X to X0, Y to Y0 and Z bound to (parent(X0, Y0), male(X0)). The
second answer binds X to adam, Y to bill and Z to true.
By using clause/2 it is possible to re-write Examples 8.6 and 8.7 as follows:
solve(true).
solve((X, Y )) ←solve(X), solve(Y ).
solve(X) ←clause(X, Y ), solve(Y ).
grandparent(X, Z) ←parent(X, Y ), parent(Y, Z).
...
Note that it is no longer possible to distinguish the meta-language from the the object
language.
The use of clause/2 is normally restricted in that the ﬁrst argument of clause/2
must not be a variable at the time when the subgoal is selected. This is, for instance,
stipulated in the ISO Prolog standard. Thus, the goal ←solve(X) results in a run-time
error in most Prolog systems.
8.5
The Built-in Predicates assert{a,z}/1
The Prolog standard also provides some built-in predicates that are used to modify the
program during execution of a goal. For instance, the built-in predicates asserta/1
and assertz/1 are used to dynamically add new clauses to the program. The only
diﬀerence between the two is that asserta/1 adds its argument textually ﬁrst in the
deﬁnition of a predicate whereas assertz/1 adds it argument textually at the end.
We use assert/1 to stand for either of the two. From a proof-theoretic point of view
the logical meaning of assert/1 can be described as follows (assuming that t is not a
variable and that Prolog’s computation rule is used):
←assert(t), A2, . . . , An
←A2, . . . , An

8.5 The Built-in Predicates assert{a,z}/1
145
In other words, assert/1 can be interpreted as something which is always true when
selected. However, the main eﬀect of assert/1 is the addition of t to the database of
clauses. Of course, t should be a well-formed “clause” not to cause a run-time error.3
Consider the trivial program:
parent(adam, bill).
Presented with the goal:
←assertz(parent(adam, beth)), parent(adam, X).
Prolog replies with two answers — X = bill and X = beth. Prolog ﬁrst adds the
clause parent(adam, beth) to the program database and then tries to satisfy the second
subgoal which now has two solutions. Changes made to Prolog’s database by assert/1
are permanent. That is, they are not undone on backtracking. Moreover, it is possible
to assert the same clause several times.
Unfortunately, the eﬀect of using assert/1 is not always very clear. For instance,
if the order among the subgoals in the previous goal is changed into:
←parent(adam, X), assertz(parent(adam, beth)).
some Prolog systems would return the single answer X = bill, since when the call to
parent/2 is made, Prolog records that its deﬁnition contains only one clause. Thus,
when backtracking takes place the new clause added to the deﬁnition of parent/2
remains invisible to the call.
This is in accordance with the ISO Prolog standard
(1995). However, some (old) Prolog systems would return inﬁnitely many answers.
First X = bill, and thereafter an inﬁnite repetition of the answer X = beth. This
happens if the implementation does not “freeze” the deﬁnition of a predicate when a
call is made to the predicate. Every time a solution is found to the leftmost subgoal
a new copy of the clause parent(adam, beth) is added to the deﬁnition of parent/2.
Hence, there will always be one more clause for the leftmost subgoal to backtrack to.
A similar problem occurs in connection with the clause:
void ←assertz(void), fail.
In some Prolog implementations the goal ←void would succeed, whereas in others it
would fail. However, in both cases the resulting program is:
void ←assertz(void), fail.
void.
This suggests that assert/1 should be used with great care. Just like cut, assert/1 is
often abused in misguided attempts to improve the eﬃciency of programs. However,
there are cases when usage of assert/1 can be motivated. For instance, if a subgoal
is solved, the result can be stored in the database as a lemma. Afterwards the same
subgoal can be solved in a single derivation step. This kind of usage does not cause
any declarative problems since the lemma does not add to, or delete information from
the program.
3The reason for quoting the word clause is that the argument of assert/1 formally is a term.
However, in most Prolog systems clauses are handled just as if they were terms. That is, the logical
connectives “←” and “,” are allowed to be used also as functors.

146
Chapter 8:
Amalgamating Object- and Meta-language
8.6
The Built-in Predicate retract/1
The built-in predicate retract/1 is used to delete clauses dynamically from Prolog’s
database during the execution of a goal. The logical meaning of retract/1 is similar
to that of clause/2. It can be described by the inference rule:
←retract((s ←t)), A2, . . . , Am
B0 ←B1, . . . , Bn
←(A2, . . . , Am)θ
where B0 ←B1, . . . , Bn is a renamed program clause such that s ←t and B0 ←
B1, . . . , Bn have an mgu θ.
Like the case with clause/2 there may be more than
one clause which uniﬁes with (s ←t). Hence, several derivations are possible. For
uniformity, and by analogy to clause/2, a fact may be treated as a rule whose body
consists of the literal true.
As a side-eﬀect retract/1 removes the clause B0 ←B1, . . . , Bn from Prolog’s in-
ternal database. The eﬀect is permanent — that is, the clause is not restored when
backtracking takes place. For instance, consider the Prolog program:
parent(adam, bill).
parent(adam, beth).
parent(bill, cathy).
In reply to the goal:
←retract(parent(adam, X) ←true).
Prolog replies with two answers — X = bill and X = beth. Then execution terminates
and all that is left of the program is the clause:
parent(bill, cathy).
In most Prolog implementations (and according to the ISO standard) it is required
that the argument of retract/1 is not a variable and if it is of the form s ←t that s
is not a variable.
Like assert/1, usage of retract/1 is controversial and the eﬀect of using it may
diverge in diﬀerent implementations.
In general there are both cleaner and more
eﬃcient methods for solving problems than resorting to these two.
For example,
naive users of Prolog often use assert/1 and retract/1 to implement a form of global
variables. This usually has two eﬀects — the program becomes harder to understand
and it runs slower since asserting new clauses to the program involve considerable
amount of work and book-keeping. This often comes as a big surprise to people who
are used to programming in imperative programming languages.
Exercises
8.1 Complete the self-interpreter described in Examples 8.2 – 8.4. Either by us-
ing the suggested representation of the object-language or invent your own
representation.
8.2 Extend Example 8.7 so that execution is aborted when the number of resolution-
steps for solving a subgoal becomes too large.

Exercises
147
8.3 Modify Example 8.7 so that it uses the depth-ﬁrst-iterative-deepening search
strategy. The general idea is to explore all paths of length n from the root
(where n is initially 1) using a depth-ﬁrst strategy. Then the whole process is
repeated after incrementing n by 1. Using this technique every refutation in
an SLD-tree is eventually found.
8.4 Write a program for diﬀerentiating formulas consisting of natural numbers and
some variables (but not Prolog ones!). Implement the program by deﬁning
some of the most common diﬀerentiation-rules.
For instance the following
ones:
∂m
∂x = 0
∂x
∂x = 1
∂xn
∂x = n ∗xn−1
∂(f + g)
∂x
= ∂f
∂x + ∂g
∂x
∂(f ∗g)
∂x
= g ∗∂f
∂x + f ∗∂g
∂x
where m ≥0 and n > 0.
8.5 Write a Prolog program which determines if a collection of formulas of propo-
sitional logic is satisﬁable.
8.6 Consider a small imperative language given by the following abstract syntax:
I
::=
x | y | z | . . .
N
::=
0 | 1 | 2 | . . .
B
::=
true | false | E > E | . . .
E
::=
I | N | E + E | E −E | E ∗E | . . .
C
::=
skip | assign(I, E) | if (B, C, C) | while(B, C) | seq(C, C)
For instance, the factorial program:
y := 1; while x > 0 do y := y ∗x; x := x −1 od
is represented by the abstract syntax:
seq(assign(y, 1), while(x > 0, seq(assign(y, y ∗x), assign(x, x −1))))
Moreover, a binding environment is a mapping from identiﬁers to values (in
our case integers) which could be represented as a list of pairs of variables and
integers.
Now write an interpreter eval/3 which relates an initial binding environment
and a command C to the new binding environment obtained by “executing”
C. For instance, if x maps to 5 in σ and c is the program above the goal
←eval(σ, c, X) should result in a new binding environment where x maps to
0 and y maps to 120 (i.e. the factorial of 5).
8.7 Write a tiny pure-Lisp interpreter which incorporates some of the primitive
functions (like CAR, CONS etc.) and allows the deﬁnition of new functions
in terms of these.

148
Chapter 8:
Amalgamating Object- and Meta-language

Chapter 9
Logic and Expert Systems
9.1
Expert Systems
Roughly speaking, an expert system is a program that guides the user in the solution
of some problem which normally requires intervention of a human expert in the ﬁeld.
Tasks which typically call for expert level knowledge include, for instance, diagnosis,
control and planning. Diagnosis means trying to ﬁnd the cause of some malfunction,
e.g. the cause of an illness. In control-applications the aim is to prevent a system,
such as an industrial process, from entering abnormal states. Planning, ﬁnally, means
trying to ﬁnd a sequence of state transitions ending in a speciﬁed ﬁnal state via a
sequence of intermediate states given an initial one. A typical problem consists in
ﬁnding a plan which assembles a collection of parts into a ﬁnal product. This chapter
illustrates the applicability of logic programming for expert systems and meta-level
reasoning by a diagnosis example.
Usually an expert system exhibits a number of characteristics:
• It is divided into an inference engine and a knowledge-base. The knowledge-base
contains rules which describe general knowledge about some problem domain.
The inference engine is used to infer knowledge from the knowledge-base. Usu-
ally, the inference machine is generic in the sense that one can easily plug in a
new knowledge-base without any major changes to the inference machine.
• It may contain rules which are subject to some uncertainty.
• The system often runs on modern workstations and much eﬀort is put into the
user interface and the dialogue with the user.
• It has the capability not only to infer new knowledge from existing knowledge,
but also to explain how/why some conclusion was reached.
• It has support for incremental knowledge acquisition.
149

150
Chapter 9:
Logic and Expert Systems
It is easy to see that the ﬁrst point above coincides with the objectives of logic pro-
gramming — namely to separate the logic component (what the problem is) from the
control (how the problem should be solved). This can be expressed by the equation:
Algorithm = Logic + Control
That is, Kowalski’s well-known paraphrase of Wirth’s doctrine Program = Algorithm
+ Data Structure. In the spirit of Kowalski we could write:
Expert System = Knowledge-base + Control + User Interface
The last two terms are commonly called an expert-system shell.
The knowledge-base of an expert system typically consists of a set of so called
production rules (or simply rules). Like deﬁnite clauses, they have a set of premises
and a conclusion. Such rules say that whenever all the premises hold the conclusion
also holds. A typical rule found in one of the earliest expert systems called MYCIN
may look as follows:
IF
the stain of the organism is gram-positive
AND
the morphology of the organism is coccus
AND
the growth conformation of the organism is clumps
THEN
the identity of the organism is staphylococcus (0.7)
It is not very hard to express approximately the same knowledge in the form of a
deﬁnite clause:
identity of organism(staphylococcus) ←
stain of organism(gram positive),
morphology of organism(coccus),
growth conformation of organism(clumps).
The ﬁgure (0.7) given in the conclusion of the MYCIN-rule above is an example of
uncertainty of the rule. It says that if the premises hold then the conclusion holds
with probability 0.7. In the following we do not consider these ﬁgures of uncertainty
but assume that they are always 1.0.
We consider an application which involves diagnosing starting problems of cars.
The following two propositions seem to express general knowledge describing the cause
of malfunctioning devices:
• if Y is a necessary component for X and Y is malfunctioning then X is also
malfunctioning;
• if X exhibits a fault-symptom Z then either X is malfunctioning or there exists
another malfunctioning component which is necessary for X.
In predicate logic this may be expressed as follows:
∀X(∃Y (needs(X, Y ) ∧malfunctions(Y )) ⊃malfunctions(X))
∀X, Z(symptom(Z, X) ⊃(malfunctions(X) ∨∃Y (needs(X, Y ) ∧malfunctions(Y ))))
The ﬁrst of these readily transforms into the deﬁnite clause:

9.1 Expert Systems
151
fuel
battery
fuel
pump
starting
motor
sparking
plugs
fuse
fuel
system
ignition
system
electric
system
car
Figure 9.1: Taxonomy of a car-engine
malfunctions(X) ←needs(X, Y ), malfunctions(Y ).
However, in order to write the second formula as a deﬁnite clause some transformations
are needed. First an auxiliary predicate symbol indirect/1 is introduced and deﬁned
as follows:
• X has an indirect fault if there exists a component which is necessary for X and
which malfunctions.
Now the second formula can be replaced by the following two:
∀X, Y (symptom(Y, X) ⊃(malfunctions(X) ∨indirect(X)))
∀X(∃Y (malfunctions(Y ) ∧needs(X, Y )) ⊃indirect(X))
These are straightforward to transform into general clauses:
malfunctions(X) ←symptom(Y, X), not indirect(X).
indirect(X) ←needs(X, Y ), malfunctions(Y ).
We must now deﬁne the relation needs/2 which deﬁnes a hierarchy of components
and dependencies between them. In this chapter a car-engine is abstracted into the
components and dependencies in the taxonomy of Figure 9.1.
The relation described by the ﬁgure may be represented by the following deﬁnite
program:

152
Chapter 9:
Logic and Expert Systems
needs(car, ignition system).
needs(car, fuel system).
needs(car, electric system).
needs(ignition system, starting motor).
needs(ignition system, sparking plugs).
needs(electric system, fuse).
needs(electric system, battery).
needs(fuel system, fuel pump).
needs(sparking plugs, battery).
needs(starting motor, battery).
needs(fuel pump, fuel).
Finally the predicate symptom/2 which describes the symptoms of a car (or rather
parts of the car) should be deﬁned. However, the symptoms exhibited by a speciﬁc
car depend on the particular car in a speciﬁc moment of time. The description of the
symptoms of the car should therefore be added to the database when diagnosing the
cause of malfunction of that particular car. How to cope with this is described below.
As shown above, the knowledge-base of an expert system can be described as a set of
deﬁnite or general clauses. What about the inference engine?
The inference engine is used to infer new knowledge from existing knowledge. This
can be done by using two diﬀerent strategies — (1) either start from what is already
known and infer new knowledge from this, or (2) start from the conclusion to be
proved and reason backwards until the conclusion depends on what is already known.
These methods are called forward- and backward-chaining respectively. Clearly, SLD-
resolution is an example of a backward-chaining proof procedure. There are expert
systems which rely on forward-chaining or a mixture of the two, but there are also
expert systems which use backward-chaining only. MYCIN is an example of such an
expert system.
We have established the close relationship between, on the one hand, the knowledge-
base of an expert system and the set of clauses in logic programming and, on the other
hand, the inference engines used in some expert systems and SLD-resolution. So what
is the main diﬀerence between expert systems and logic programming?
Apart from the probabilities of rules and the user interface, an expert system diﬀers
from a logic program in the sense that its knowledge-base is usually incomplete. As
explained above, the knowledge-base only contains general knowledge concerning dif-
ferent faults and symptoms. It does not contain information about the speciﬁc symp-
toms of a particular individual. This information has to be added to its knowledge-base
whilst diagnosing the individual. That is, while inferring what fault the individual is
suﬀering from, the inference engine asks questions which have to be ﬁlled in, in order
to complete the knowledge-base. Thus, given a general description P of the world and
a symptom or an observation F one can say that the aim of the expert system is to
ﬁnd a cause ∆such that P ∪∆⊢F. This problem is commonly known under the
name abduction.
Another major distinction between logic programming and expert systems is that
expert systems have the capability to explain their conclusions. If an expert system
draws a conclusion concerning the health of a patient it is likely that the doctor (or

9.2 Collecting Proofs
153
the patient) wants to know how the system came to that conclusion. Most Prolog
systems are not automatically equipped with such a mechanism.
So clearly the knowledge-base may be described as a Prolog program but the
Prolog inference engine does not satisfy the requirement needed in an expert system.
In order to remedy this we are going to build a new inference engine based on the
self-interpreter in Example 8.7 to provide these missing features.
9.2
Collecting Proofs
The ﬁrst reﬁnement made to the program in Example 8.7 is to add the capability of
collecting the proof representing the refutation of a goal. As described in Section 3.3
a refutation may be represented as a proof- or derivation-tree. Referring to Example
8.7 we see that there are three types of goals:
• the empty goal (represented by the constant true);
• compound goals of the form X and Y ;
• goals consisting of a single literal.
Now in the case of the goal true we can simply return the term void which repre-
sents an empty proof. Furthermore, under the assumption that X has a proof Px
and that Y has a proof Py, the term Px & Py will represent a proof of the goal
represented by X and Y . Finally, the single literal X has a proof represented by the
term proof (X, Py) if there is a clause instance X if Y and Y has a proof represented
by Py. It is straightforward to convert this into the following deﬁnite program:
Example 9.1
solve(true, void).
solve((X and Y ), (Px & Py)) ←solve(X, Px), solve(Y, Py).
solve(X, proof (X, Py)) ←clause(X if Y ), solve(Y, Py).
Given the goal ←solve(grandparent(X, Y ), Z) and the database:
clause(grandparent(X, Y ) if parent(X, Z) and parent(Z, Y )).
clause(parent(X, Y ) if father(X, Y )).
clause(father(adam, bill) if true).
clause(father(bill, carl) if true).
Prolog not only ﬁnds a refutation and produces the answer X = adam, Y = carl but
also returns the term:
Z = proof (grandparent(adam, carl),
proof (parent(adam, bill),
proof (father(adam, bill), void))
&
proof (parent(bill, carl),
proof (father(bill, carl), void))
)

154
Chapter 9:
Logic and Expert Systems
which represents the refutation of the goal ←grandparent(X, Y ).
As seen, when proving a positive goal it is rather easy to collect its proof. The
situation is more complicated when trying to solve goals containing negative literals.
Since the negation-as-failure rule says that not X succeeds if X ﬁnitely fails (that is,
has no refutation) there is no proof to return (except possibly some kind of meta-
proof). A naive solution is to add the clause:
solve(not X, proof (not X, void)) ←not solve(X, T).
to the interpreter. A more satisfactory solution would be to collect the meta-proof
which proves that X has no proof but writing an interpreter for doing this is rather
complicated. The discussion concerning the “proof-collecting” interpreter is now tem-
porarily abandoned, but is resumed after the following section which suggests a solu-
tion to the problem of the incomplete knowledge-base.
9.3
Query-the-user
As explained above, the knowledge-base of an expert system is only capable of handling
general information valid for every individual. In the case of diagnosing an illness, the
symptoms of a speciﬁc patient have to be collected during “run-time”. This means
that when the inference engine encounters certain predicates it should not look for the
deﬁnition in the knowledge-base but instead query the user for information. In the
example above the predicate symptom/2 is used for this purpose. Such an approach
can readily be implemented by means of the interpreter in Example 8.7 if these special
predicate symbols are known before-hand.1
Example 9.2
solve(true).
solve(X and Y ) ←
solve(X), solve(Y ).
solve(symptom(X, Y )) ←
conﬁrm(X, Y ).
solve(X) ←
clause(X if Y ), solve(Y ).
where conﬁrm/2 is deﬁned as follows:
conﬁrm(X, Y ) ←
write(’Is the ’),
write(Y ), tab(1), write(X), write(’? ’),
read(yes).
Now consider the following (trivial) knowledge-base:
1This and subsequent examples require the use of input and output. The Prolog standard provides
several built-in predicates. Thus, write/1 outputs a term on the current output stream. Similarly
read/1 inputs a term from the current input stream (a call succeeds if the term uniﬁes with the
argument of the call). nl/0 outputs a newline character and tab/1 a speciﬁed number of blanks on
the current output stream. Strings of characters enclosed by single quotes are taken to be constants.

9.4 Fixing the Car (Extended Example)
155
clause(malfunctions(X) if possible fault(Y, X) and symptom(Y, X)).
clause(possible fault(flat, tyre) if true).
When given the goal ←solve(malfunctions(X)) Prolog will print the question “Is the
tyre ﬂat?”. If the user replies with “yes” the execution succeeds with answer X = tyre;
if the user answers anything but “yes” (or a variable) the goal fails.
9.4
Fixing the Car (Extended Example)
Now the principle of implementation of expert systems in Prolog is illustrated by
continuing the example discussed in Section 9.1. We do not claim that the result
is even close to a real expert system, which is, of course, considerably much more
complicated than the program described below.
The ﬁrst step is to describe the knowledge-base as a collection of facts in the meta-
language.
The predicate symbol if /2 is used for that purpose; the ﬁrst argument
represents the head of a rule and the second the conjunction of premises. To avoid
having to treat facts of the object-language separately, they will be written in the
form X if true. The knowledge-base described in Section 9.1 can now be described
as follows:
malfunctions(X) if needs(X, Y ) and malfunctions(Y ).
malfunctions(X) if symptom(Y, X) and not indirect(X).
indirect(X) if needs(X, Y ) and malfunctions(Y ).
needs(car, ignition system) if true.
needs(car, fuel system) if true.
needs(car, electric system) if true.
needs(ignition system, starting motor) if true.
needs(ignition system, sparking plugs) if true.
needs(electric system, fuse) if true.
needs(electric system, battery) if true.
needs(fuel system, fuel pump) if true.
needs(sparking plugs, battery) if true.
needs(starting motor, battery) if true.
needs(fuel pump, fuel) if true.
To construct an inference engine, the interpreters from Examples 9.1 and 9.2 are
“joined” into the following one:
solve(true, void).
solve(X and Y, Px & Py) ←
solve(X, Px), solve(Y, Py).
solve(not X, proof (not X, void)) ←
not solve(X, P).
solve(symptom(X, Y ), proof (symptom(X, Y ), void)) ←
conﬁrm(X, Y ).
solve(X, proof (X, Py)) ←
(X if Y ), solve(Y, Py).

156
Chapter 9:
Logic and Expert Systems
The program is assumed to interact with a mechanic, exploiting the query-the-user
facility. Hence, some easily spotted misbehaviours are characterized:
• one of the sparking plugs does not produce a spark;
• the fuel gauge indicates an empty tank;
• the fuel pump does not feed any fuel;
• a fuse (say number 13) is broken;
• the battery voltage is less than 11 volts;
• the starting motor is silent.
These can be formulated using the predicate symbol conﬁrm/2 which poses questions
to the mechanic and succeeds if he replies “yes”. It may be deﬁned as follows:
conﬁrm(X, Y ) ←
nl, ask(X, Y ), read(yes).
where ask(X, Y ) prints a query asking if Y exhibits the misbehaviour X and is deﬁned
as follows:
ask(worn out, sparking plugs) ←
write(’Do any of the sparking plugs fail to produce a spark?’).
ask(out of, fuel) ←
write(’Does the fuel gauge indicate an empty tank?’).
ask(broken, fuel pump) ←
write(’Does the fuel pump fail to feed any fuel?’).
ask(broken, fuse) ←
write(’Is fuse number 13 broken?’).
ask(discharged, battery) ←
write(’Is the battery voltage less than 11 volts?’).
ask(broken, starting motor) ←
write(’Is the starting motor silent?’).
This more or less completes the knowledge-base and inference engine of the expert
system. However, the program suﬀers from operational problems which become evi-
dent when giving the goal ←solve(malfunctions(car), Proof ). If the user replies “no”
to the question “Is the battery voltage less than 11 volts?”, the system immediately
asks the same question again. This happens because (see Figure 9.1):
• the car needs the ignition system;
• the ignition-system needs the sparking plugs and the starting motor;
• both the sparking plugs and the starting motor need the battery.
To avoid having to answer the same question several times the system must remember
what questions it has already posed and the answers to those questions. This can be
achieved by asserting the question/answer to the Prolog database. Before posing a
query, the system should look into this database to see if an answer to the question is
already there. To implement this facility the predicate conﬁrm/2 must be redeﬁned.
For instance, in the following way:

9.4 Fixing the Car (Extended Example)
157
conﬁrm(X, Y ) ←
known(X, Y, true).
conﬁrm(X, Y ) ←
not known(X, Y, Z), nl, ask(X, Y ),
read(A), remember(X, Y, A), A = yes.
remember(X, Y, yes) ←
assertz(known(X, Y, true)).
remember(X, Y, no) ←
assertz(known(X, Y, false)).
Note that the second clause is an example of unsafe use of negation. Given a selected
subgoal conﬁrm(a, b), the ﬁrst clause is used (and the subgoal is solved) if the question
triggered by a and b was previously conﬁrmed by the user (that is, if conﬁrm(a, b, true)
is solved); the second clause is used if the question triggered by a and b was never
posed before. This will be the eﬀect since the selected subgoal in the next goal will
be the negative literal not known(a, b, Z) which succeeds if there is no Z such that
known(a, b, Z). If neither of these two clauses apply (that is, if the question triggered
by a and b has been posed but denied) the call to conﬁrm/2 fails.
When calling the program with the goal:
←solve(malfunctions(car), X).
the system ﬁrst prints the query:
Is the battery voltage less than 11 volts ?
If the user answers “no” the system asks:
Is the starting motor silent?
Under the assumption that the user replies “no”, the next question posed by the
system is:
Do any of the sparking plugs fail to produce a spark?
If the reply to this question is “yes” the computation stops with the (rather awkward)
answer:
X = proof (malfunctions(car),
proof (needs(car, ignition system), void)
&
proof (malfunctions(ignition system),
proof (needs(ignition system, sparking plugs), void)
&
proof (malfunctions(sparking plugs),
proof (symptom(worn out, sparking plugs), void)
&
proof (not indirect(sparking plugs), void)
)
)
)

158
Chapter 9:
Logic and Expert Systems
Needless to say the answer is rather diﬃcult to overview and there is need for routines
that display the proof in a readable form. Some alternative approaches are possible,
for instance, by printing the proof as a tree. However such a program would require
rather complicated graphics routines. Instead a rather crude approach is employed
where the rule-instances that the proof consists of are printed. The “top-loop” of the
printing routine looks as follows:
print proof (void).
print proof (X & Y ) ←
print proof (X), nl, print proof (Y ).
print proof (proof (X, void)) ←
write(X), nl.
print proof (proof (X, Y )) ←
Y ̸= void, write(X), write(’ BECAUSE’), nl,
print children(Y ), nl, print proof (Y ).
That is, in case of the empty proof nothing is done. If the proof consists of two or more
proofs the proofs are printed separately. If the proof is of the form X if Y then two
possibilities emerge — if Y is the empty proof then X is printed. If Y ̸= void then X
is printed followed by the word “BECAUSE” and the “top nodes of the constituents
of Y ”. Finally the subproofs are printed.
The program for printing the top-nodes of proofs looks as follows:
print children(proof (X, Y ) & Z) ←
tab(8), write(X), write(’ AND’), nl, print children(Z).
print children(proof (X, Y )) ←
tab(8), write(X), nl.
That is, if it is a compound proof then the top of one constituent is printed followed
by the word “AND”, in turn followed by the top-nodes of the remaining constituents.
If the proof is a singleton then the top of that proof is printed.
To complete the program the following “driver”-routine is added:
expert ←
abolish(known/3),
solve(malfunctions(car), X),
print proof (X).
where abolish/1 is a built-in predicate which removes all clauses whose heads have the
same predicate symbol and arity as the argument. When faced with the goal ←expert
the following dialogue may appear (with user input in bold-face):

9.4 Fixing the Car (Extended Example)
159
Is the battery voltage less than 11 volts? no.
Is the starting motor silent? no.
Do any of the sparking plugs fail to produce a spark? yes.
malfunctions(car) BECAUSE
needs(car, ignition system) AND
malfunctions(ignition system)
needs(car, ignition system)
malfunctions(ignition system) BECAUSE
needs(ignition system, sparking plugs) AND
malfunctions(sparking plugs)
needs(ignition system, sparking plugs)
malfunctions(sparking plugs) BECAUSE
symptom(worn out, sparking plugs) AND
not indirect(sparking plugs)
symptom(worn out, sparking plugs)
not indirect(sparking plugs)
In conclusion, the complete listing of this tiny expert-system shell and the particular
knowledge-base for diagnosing starting problems of cars is depicted below.
(Lines
preceded by the symbol “%” are comments.)
% Top level routine
expert ←
abolish(known/3),
solve(malfunctions(car), X),
print proof (X).
solve(true, void).
solve(X and Y, Px & Py) ←
solve(X, Px), solve(Y, Py).
solve(not X, proof (not X, void)) ←
not solve(X, P).
solve(symptom(X, Y ), proof (symptom(X, Y ), void)) ←
conﬁrm(X, Y ).
solve(X, proof (X, Py)) ←
(X if Y ), solve(Y, Py).

160
Chapter 9:
Logic and Expert Systems
% Query-the-user
conﬁrm(X, Y ) ←
known(X, Y, true).
conﬁrm(X, Y ) ←
not known(X, Y, Z), nl, ask(X, Y ),
read(A), remember(X, Y, A), A = yes.
% Queries
ask(worn out, sparking plugs) ←
write(’Do any of the sparking plugs fail to produce a spark?’).
ask(out of, fuel) ←
write(’Does the fuel gauge indicate an empty tank?’).
ask(broken, fuel pump) ←
write(’Does the fuel pump fail to feed any fuel?’).
ask(broken, fuse) ←
write(’Is fuse number 13 broken?’).
ask(discharged, battery) ←
write(’Is the battery voltage less than 11 volts?’).
ask(broken, starting motor) ←
write(’Is the starting motor silent?’).
% Remember replies to queries
remember(X, Y, yes) ←
assertz(known(X, Y, true)).
remember(X, Y, no) ←
assertz(known(X, Y, false)).
% Knowledge-base
malfunctions(X) if needs(X, Y ) and malfunctions(Y ).
malfunctions(X) if symptom(Y, X) and not indirect(X).
indirect(X) if needs(X, Y ) and malfunctions(Y ).
needs(car, ignition system) if true.
needs(car, fuel system) if true.
needs(car, electric system) if true.
needs(ignition system, starting motor) if true.
needs(ignition system, sparking plugs) if true.
needs(electric system, fuse) if true.
needs(electric system, battery) if true.
needs(fuel system, fuel pump) if true.
needs(sparking plugs, battery) if true.
needs(starting motor, battery) if true.
needs(fuel pump, fuel) if true.

Exercises
161
% Explanations
print proof (void).
print proof (X & Y ) ←
print proof (X), nl, print proof (Y ).
print proof (proof (X, void)) ←
write(X), nl.
print proof (proof (X, Y )) ←
Y ̸= void, write(X), write(’ BECAUSE’), nl,
print children(Y ), nl, print proof (Y ).
print children(proof (X, Y ) & Z) ←
tab(8), write(X), write(’ AND’), nl, print children(Z).
print children(proof (X, Y )) ←
tab(8), write(X), nl.
Exercises
9.1 Improve the printing of the proof. For instance, instead of printing the whole
proof at once the system may print the top of the proof and then let the
user decide which branch to explain further. Another possibility is the use of
natural language. Thus a possible interaction may look as follows:
The car malfunctions BECAUSE
(1) the car needs the ignition-system AND
(2) the ignition-system malfunctions
Explore? 2.
The ignition-system malfunctions BECAUSE
(1) the ignition-system needs the sparking-plugs AND
(2) the sparking-plugs malfunction
Explore?
9.2 Write an inference engine which exploits probabilities of rules so that it be-
comes possible to draw conclusions together with some measurement of their
belief. (See Shapiro (1983b).)
9.3 Extend the shell so that the user may give the query “why?” in reply to the
system’s questions. In such cases the system should explain the conclusions
possible if the user gives a particular answer to the query.

162
Chapter 9:
Logic and Expert Systems

Chapter 10
Logic and Grammars
10.1
Context-free Grammars
A language can be viewed as a (usually inﬁnite) set of sentences or strings of ﬁnite
length. Such strings are composed of symbols of some alphabet (not necessarily the
Latin alphabet). However, not all combinations of symbols are well-formed strings.
Thus, when deﬁning a new, or describing an existing language, be it a natural or an
artiﬁcial one (for instance, a programming language), the speciﬁcation should contain
only well-formed strings. A number of formalisms have been suggested to facilitate
such systematic descriptions of languages — most notably the formalism of context-
free grammars (CFGs). This section contains a brief recapitulation of basic deﬁnitions
from formal language theory (for details see e.g. Hopcroft and Ullman (1979)).
Formally a context-free grammar is a 4-tuple ⟨N , T, P, S⟩, where N and T are
ﬁnite, disjoint sets of identiﬁers called the nonterminal- and terminal-alphabets re-
spectively. P is a ﬁnite subset of N × (N ∪T)∗. S is a nonterminal symbol called the
start symbol.
As usual (N ∪T)∗denotes the set of all strings (sequences) of terminals and
nonterminals. Traditionally the empty string is denoted by the symbol ϵ. Elements of
the relation P are usually written in the form:
A →B1 . . . Bn
when n > 0
A →ϵ
when n = 0
Each such element is called a production rule. To distinguish between terminals and
nonterminals the latter are sometimes written within angle brackets. As an example,
consider the production rule:
⟨statement⟩
→
if ⟨condition⟩then ⟨statement⟩
This rule states that a string is a statement if it begins with the symbol “if” followed
in turn by; a string which is a condition, the symbol “then” and ﬁnally a string which
163

164
Chapter 10:
Logic and Grammars
is a statement. A CFG may contain several production rules with the same left-hand
side.
Now let α, β and γ be arbitrary strings from the set (N ∪T)∗. We say that the
string αβγ is directly derivable from αAγ iﬀA →β ∈P. The relation is denoted by
αAγ ⇒αβγ.
Let
∗⇒be the reﬂexive and transitive closure of the relation ⇒and let α, β ∈
(N ∪T)∗. Then β is said to be derived from α iﬀα
∗⇒β. The sequence α ⇒· · · ⇒β
is called a derivation.
Example 10.1 Consider the following set of production rules:
⟨sentence⟩
→
⟨noun-phrase⟩⟨verb-phrase⟩
⟨noun-phrase⟩
→
the ⟨noun⟩
⟨verb-phrase⟩
→
runs
⟨noun⟩
→
engine
⟨noun⟩
→
rabbit
For instance, ⟨sentence⟩derives the string the rabbit runs since:
⟨sentence⟩
⇒
⟨noun-phrase⟩⟨verb-phrase⟩
⇒
the ⟨noun⟩⟨verb-phrase⟩
⇒
the rabbit ⟨verb-phrase⟩
⇒
the rabbit runs
The language of a nonterminal A is the set {α ∈T ∗| A
∗⇒α}. The language of a
CFG is the language of its start-symbol. However, no speciﬁc start-symbol will be
used below.
Example 10.2 The language of ⟨sentence⟩in the previous example is the set:
{the rabbit runs, the engine runs}
The derivation of a terminal string α from a nonterminal A can also be described by
means of a so called derivation-tree (or parse-tree) constructed as follows:
• the root of the tree is labelled by A;
• the leaves of the tree are terminals and concatenation of the leaves from left to
right yields the string α;
• an internal node X has the children X1, . . . , Xn (from left to right) only if there
is a production rule of the form X →X1 . . . Xn.
For instance, the derivation in Example 10.1 is described in Figure 10.1. Notice that
the derivation tree in general represents many derivations depending on which nonter-
minal is selected in each step. There is an analogy to the “independence of computa-
tion rule” which is reﬂected in the derivation- or proof-trees for deﬁnite programs (see
Chapter 3).

10.1 Context-free Grammars
165
runs
rabbit
⟨noun⟩
the
⟨verb phrase⟩
⟨noun phrase⟩
⟨sentence⟩
   @
@
@
   @
@
@
Figure 10.1: Derivation tree for CFG
By describing the two relations “⇒” and “
∗⇒” it is possible to construct an “inter-
preter” for context-free grammars, which behaves as a parser that recognizes strings
deﬁned by the grammar. To do this, terminals and nonterminals will be represented
by constants, strings will be represented by lists and each production rule will be
represented by the clause:
prod rule(X, Y ).
where X and Y represent the left- and right-sides of the rule.
Example 10.3 The CFG in Example 10.1 may be represented by the deﬁnite pro-
gram:
prod rule(sentence, [noun phrase, verb phrase]).
prod rule(noun phrase, [the, noun]).
prod rule(verb phrase, [runs]).
prod rule(noun, [rabbit]).
prod rule(noun, [engine]).
It is now straightforward to deﬁne step/2 denoting the relation “⇒”:
step(X, Y ) ←
append(Left, [Lhs|Right], X),
prod rule(Lhs, Rhs),
append(Left, Rhs, Tmp),
append(Tmp, Right, Y ).
Since “
∗⇒” is the reﬂexive and transitive closure of “⇒” it is deﬁned as follows
(cf. Chapter 6):
derives(X, X).
derives(X, Z) ←step(X, Y ), derives(Y, Z).

166
Chapter 10:
Logic and Grammars
Presented with the goal ←derives([sentence], X) Prolog succeeds with all possible
(non-)terminal strings which may be derived from ⟨sentence⟩including the two termi-
nal strings X = [the, rabbit, runs] and X = [the, engine, runs].
As shown in the next section there are more eﬃcient ways of describing context-free
languages than the program in Example 10.3. However, the program works as long as
the grammar is not left-recursive and it has the following interesting properties:
• The program is quite general — to describe another context-free language it
suﬃces to rewrite the deﬁnition of prod rule/1. The rest of the program may
be used for any context-free grammar.
• When comparing Example 10.3 and Examples 8.2 – 8.4 one realizes that the
programs are very similar. Both deﬁnitions of step/2 describe a relation between
two expressions where the second is obtained by rewriting the ﬁrst expression
using some kind of rule.
The relations derives/2 and derivation/2 are the
reﬂexive and transitive closures of the “step”-relations.
Finally, prod rule/1
and clause/1 are used to represent rules of the formalisms.
• The program operates either as a top-down or a bottom-up parser depending on
how the subgoals in the clauses are ordered. As presented in Example 10.3 it
behaves as a traditional recursive descent parser under Prolog’s computation
rule, but if the subgoals in derives/2 and step/2 are swapped the program
behaves as a (quite ineﬃcient) bottom-up parser.
10.2
Logic Grammars
Although Example 10.3 provides a very general speciﬁcation of the derivability-relation
for context-free grammars it is a rather ineﬃcient program. In this section a more
direct approach is discussed, whereby the extra interpreter-layer is avoided, resulting
in parsers with better eﬃciency than the one above.
As already noted there is a close resemblance between logic programs and context-
free grammars. It is not hard to see that logic programs can be used directly to specify
exactly the same language as a CFG, without resorting to explicit deﬁnitions of the
two relations “⇒” and “
∗⇒”. Consider the following clause:
sentence(Z) ←append(X, Y, Z), noun phrase(X), verb phrase(Y ).
Declaratively it reads “For any X, Y , Z — Z is a sentence if X is a noun-phrase, Y
is a verb-phrase and Z is the concatenation of X and Y ”. By representing strings as
lists of ground terms the whole grammar in Example 10.1 can be formulated as the
following Prolog program:
Example 10.4
sentence(Z) ←append(X, Y, Z), noun phrase(X), verb phrase(Y ).
noun phrase([the|X]) ←noun(X).
verb phrase([runs]).
noun([engine]).
noun([rabbit]).

10.2 Logic Grammars
167
append([ ], X, X).
append([X|Y ], Z, [X|W]) ←append(Y, Z, W).
The program is able to refute goals like:
←sentence([the, rabbit, runs]).
←sentence([the, X, runs])
In reply to the second goal Prolog would give the answers X = rabbit and X = engine.
It is even possible to give the goal:
←sentence(X).
In this case Prolog returns all (i.e. both) sentences of the language before going into
an inﬁnite loop (incidentally, this loop can be avoided by moving the call to append/3
to the very end of the ﬁrst clause).
Unfortunately the program in Example 10.4 is also rather ineﬃcient. The append/3
procedure will blindly generate all partitions of the list and it may take some time to
ﬁnd the correct splitting (at least in the case when the list is very long). To remedy
this problem the concept of diﬀerence lists may be used.
Using diﬀerence lists the ﬁrst clause of Example 10.4 can be written as:
sentence(X0 −X2) ←noun phrase(X0 −X1), verb phrase(X1 −X2).
Declaratively it reads — “The diﬀerence between X0 and X2 is a sentence if the
diﬀerence between X0 and X1 is a noun-phrase and the diﬀerence between X1 and X2
is a verb-phrase”. The statement is evidently true — consider the string:
x1 . . . xi xi+1 . . . xj xj+1 . . . xk
|
{z
}
X2
|
{z
}
X1
|
{z
}
X0
If the diﬀerence between X1 and X2 (that is, the string xi+1 . . . xj) is a verb-phrase
and the diﬀerence between X0 and X1 (the string x1 . . . xi) is a noun-phrase then the
string x1 . . . xixi+1 . . . xj (that is the diﬀerence between X0 and X2) is a sentence.
Using this approach, Example 10.4 can be reformulated as follows:
Example 10.5
sentence(X0 −X2) ←noun phrase(X0 −X1), verb phrase(X1 −X2).
noun phrase(X0 −X2) ←connects(X0, the, X1), noun(X1 −X2).
verb phrase(X0 −X1) ←connects(X0, runs, X1).
noun(X0 −X1) ←connects(X0, engine, X1).
noun(X0 −X1) ←connects(X0, rabbits, X1).
connects([X|Y ], X, Y ).

168
Chapter 10:
Logic and Grammars
Although the intended interpretation of the functor −/2 is a function which produces
the diﬀerence between two lists, the Prolog interpreter has no knowledge about this
particular interpretation. As a consequence the goal:
←sentence([the, rabbit, runs]).
does not succeed (simply because [the, rabbit, runs] does not unify with the term
X0 −X2). In order to get a positive answer the goal must contain, as its argument, a
diﬀerence list. For instance:
←sentence([the, rabbit, runs] −[ ]).
Intuitively, this goal has the same declarative reading as the previous one since the
diﬀerence of the list denoted by [the, rabbit, runs] and the empty list is equivalent to
the intended meaning of the term [the, rabbit, runs].
Other examples of goals which succeed are:
←sentence([the, rabbit, runs|X] −X).
←sentence([the, rabbit, runs, quickly] −[quickly]).
←sentence(X −[ ]).
←sentence(X).
For instance, the third goal produces two answers: X = [the, rabbit, runs] and X =
[the, engine, runs].
Notice the way terminals of the grammar are treated — an auxiliary predicate
connects(A, B, C) is used to check if the diﬀerence of A and C is equal to B. This
auxiliary predicate can be eliminated using unfolding of the program — consider the
clause:1
noun phrase(X0 −X2) ←connects(X0, the, X1), noun(X1 −X2).
Now resolve the leftmost atom in the body! Uniﬁcation of connects(X0, the, X1) with
the clause connects([X|Y ], X, Y ) yields an mgu:
{X0/[the|X1], X/the, Y/X1}
Removing connects(X0, the, X1) from the body of the clause and applying the mgu to
the remaining atoms yields a specialized clause:
1Unfolding is a simple but powerful technique for transforming (logic) programs. Roughly speaking
the idea can be formulated as follows — let C be the clause:
A0 ←A1, . . . , Ai−1, Ai, Ai+1, . . . , An
and let:
B0 ←B1, . . . , Bm
be a clause whose head uniﬁes with Ai (with the mgu θ). Then C may be replaced by the new clause:
(A0 ←A1, . . . , Ai−1, B1, . . . , Bm, Ai+1, . . . , An)θ
It is easy to prove that this transformation does not add to the set of formulas which follow logically
from the program. That is, the transformation is “sound”. Under certain restrictions one can also
prove that the technique is “complete” in the sense that the set of all logical consequences of the old
program is exactly the same as the set of logical consequences of the new program.

10.3 Context-dependent Languages
169
noun phrase([the|X1] −X2) ←noun(X1 −X2).
Resolving all such subgoals from all the other clauses in Example 10.5 yields a new
program which does not make use of the predicate connects(A, B, C):
Example 10.6
sentence(X0 −X2) ←noun phrase(X0 −X1), verb phrase(X1 −X2).
noun phrase([the|X1] −X2) ←noun(X1 −X2).
verb phrase([runs|X1] −X1).
noun([engine|X1] −X1).
noun([rabbit|X1] −X1).
10.3
Context-dependent Languages
Although context-free grammars are often used to specify the syntax of programming
languages they have many limitations. It is well-known that the class of context-free
languages is restricted. Even a simple language such as anbncn where n ∈{0, 1, 2, . . .}
(i.e. all strings which are built from equal number of a’s, b’s and c’s) cannot be deﬁned
by a context-free grammar. Consider the grammar:
⟨abc⟩
→
⟨a⟩⟨b⟩⟨c⟩
⟨a⟩
→
ϵ
⟨a⟩
→
a ⟨a⟩
⟨b⟩
→
ϵ
⟨b⟩
→
b ⟨b⟩
⟨c⟩
→
ϵ
⟨c⟩
→
c ⟨c⟩
The language of ⟨abc⟩certainly contains the language anbncn but also other strings
— like a b b c c c. To describe languages like anbncn more powerful formalisms are
needed. For instance, the property of being a string in the language anbncn is de-
scribed by the following deﬁnite program:
Example 10.7
abc(X0 −X3) ←a(N, X0 −X1), b(N, X1 −X2), c(N, X2 −X3).
a(0, X0 −X0).
a(s(N), [a|X1] −X2) ←a(N, X1 −X2).
b(0, X0 −X0).
b(s(N), [b|X1] −X2) ←b(N, X1 −X2).
c(0, X0 −X0).
c(s(N), [c|X1] −X2) ←c(N, X1 −X2).
Here the ﬁrst clause reads “The string X0 −X3 is a member of anbncn if X0 −X1 is
a string of N a’s and X1 −X2 is a string of N b’s and X2 −X3 is a string of N c’s”.
The restriction to equal number of a’s, b’s and c’s is thus obtained through the extra
argument of the predicate symbols a/2, b/2 and c/2.

170
Chapter 10:
Logic and Grammars
As an additional example consider the following excerpt from a context-free natural
language description:
⟨sentence⟩
→
⟨noun-phrase⟩⟨verb⟩
⟨noun-phrase⟩
→
⟨pronoun⟩
⟨noun-phrase⟩
→
the ⟨noun⟩
⟨noun⟩
→
rabbit
⟨noun⟩
→
rabbits
⟨pronoun⟩
→
it
⟨pronoun⟩
→
they
⟨verb⟩
→
runs
⟨verb⟩
→
run
Unfortunately the language of ⟨sentence⟩includes strings such as the rabbit run,
they runs and it run — strings which should not be part of the language. Again,
this can be repaired reasonably easy by deﬁning the language by means of a logic
program and by adding extra arguments to the predicate symbols corresponding to
nonterminals:
Example 10.8 Consider the following logic program:
sentence(X0 −X2) ←noun phrase(Y, X0 −X1), verb(Y, X1 −X2).
noun phrase(Y, X0 −X1) ←pronoun(Y, X0 −X1).
noun phrase(Y, X0 −X2) ←connects(X0, the, X1), noun(Y, X1 −X2).
noun(singular(3), X0 −X1) ←connects(X0, rabbit, X1).
noun(plural(3), X0 −X1) ←connects(X0, rabbits, X1).
pronoun(singular(3), X0 −X1) ←connects(X0, it, X1).
pronoun(plural(3), X0 −X1) ←connects(X0, they, X1).
verb(plural(Y ), X0 −X1) ←connects(X0, run, X1).
verb(singular(3), X0 −X1) ←connects(X0, runs, X1).
A goal clause of the form:
←sentence([the, rabbits, runs] −[ ]).
may be reduced to the compound goal:
←noun phrase(Y, [the, rabbits, runs] −X1), verb(Y, X1 −[ ]).
The leftmost goal eventually succeeds with the bindings Y = plural(3) and X1 =
[runs] but the remaining subgoal fails:
←verb(plural(3), [runs] −[ ]).
Thus, the string is not a member in the language deﬁned by the program.
The extra arguments added to some predicate symbols serve essentially two purposes
— as demonstrated above, they can be used to propagate constraints between subgoals
corresponding to nonterminals of the grammar and they may also be used to construct
some alternative (structured) representation of the string being analysed. For instance,
as a parse-tree or some other form of intermediate code.

10.4 Deﬁnite Clause Grammars (DCGs)
171
10.4
Deﬁnite Clause Grammars (DCGs)
Many Prolog systems employ special syntax for language speciﬁcations. When such a
description is encountered, the system automatically compiles it into a Prolog program.
Such speciﬁcations are called Deﬁnite Clause Grammars (DCGs).
There are two
possible views of such grammars — either they are viewed as a “syntactic sugar” for
Prolog. That is, the grammar is seen as a convenient shorthand for a Prolog program.
Alternatively the notion of DCG is viewed as an independent formalism on its own.
This book adopts the latter view.
Assume that an alphabet similar to that in Chapter 1 is given. Then a DCG is a
triple ⟨N , T, P⟩where:
• N is a possibly inﬁnite set of atoms;
• T is a possibly inﬁnite set of terms;
• P ⊆N × (N ∪T)∗is a ﬁnite set of (production) rules.
By analogy to CFGs N and T are assumed to be disjoint and are called nonterminals
and terminals respectively.
DCGs are generalizations of CFGs and it is therefore possible to generalize the
concept of direct derivability. Let α, α′, β ∈(N ∪T)∗and let p(t1, . . . , tn) →β ∈P
(where variables are renamed so that no name clashes occur with variables in α). Then
α′ is directly derivable from α iﬀ:
• α is of the form α1p(s1, . . . , sn)α2;
• p(t1, . . . , tn) and p(s1, . . . , sn) unify with mgu θ;
• α′ is of the form (α1βα2)θ.
Also the concept of derivation is a generalization of the CFG-counterpart.
The
derivability-relation for DCGs is the reﬂexive and transitive closure of the direct-
derivability-relation. A string of terminals β ∈T ∗is in the language of A ∈N iﬀ
⟨A, β⟩is in the derivability-relation.
Example 10.9 Consider the following DCG:
sentence(s(X, Y ))
→
np(X, N) vp(Y, N)
np(john, singular(3))
→
john
np(they, plural(3))
→
they
vp(run, plural(X))
→
run
vp(runs, singular(3))
→
runs
From the nonterminal sentence(X) the following derivation may be constructed:
sentence(X)
⇒
np(X0, N0) vp(Y0, N0)
⇒
john vp(Y0, singular(3))
⇒
john runs
Thus, the string john runs is in the language of sentence(X). But more than that,
the mgu’s of the derivation together produce a binding for the variables used in the

172
Chapter 10:
Logic and Grammars
they run
john runs
they vp(Y0, plural(3))
john vp(Y0, singular(3))
np(X0, N0) vp(Y0, N0)
sentence(X)
H
H
H
H
H
H






Figure 10.2: “SLD-tree” for DCGs
derivation — in the ﬁrst step X is bound to the term s(X0, Y0). In the second step
X0 is bound to john and ﬁnally Y0 is bound to runs. Composition of the mgu’s yields
the “answer” X/s(john, runs) to the initial nonterminal.
However, the derivation in the example is not the only one that starts with the non-
terminal sentence(X). For instance, in derivation step two, the second nonterminal
may be selected instead, and in the same step the third production rule may be used
instead of the second. It turns out that the choice of nonterminal is of no impor-
tance, but that the choice of production rule is. This is yet another similarity between
DCGs and logic programs. The choice of nonterminal corresponds to the selection of
subgoal. In fact, the collection of all derivations starting with a nonterminal under
a ﬁxed “computation rule” can be depicted as an “SLD-tree”. For instance, all pos-
sible derivations originating from the nonterminal sentence(X) (where the leftmost
nonterminal is always selected) is depicted in Figure 10.2.
As discussed above many Prolog systems support usage of DCGs by automatically
translating them into Prolog programs.
In order to discuss combining DCGs and
Prolog we need to settle some notational conventions for writing DCGs:
• since Prolog systems cannot distinguish terms from atoms, terminals are enclosed
by list-brackets;
• nonterminals are written as ordinary compound terms or constants except that
they are not allowed to use certain reserved symbols (e.g. ./2) as principal func-
tors;
• the functor ’,’/2 (comma) separates terminals and nonterminals in the right-hand
side of rules;
• the functor ’-->’/2 separates the left- and right-hand sides of a production rule;

10.4 Deﬁnite Clause Grammars (DCGs)
173
• the empty string is denoted by the empty list.
This means that DCGs can be represented as terms. For instance, the rule:
np(X) →the noun(X)
will be written as the term:
np(X) --> [the], noun(X)
or using standard syntax:
’-->’(np(X), ’,’([the], noun(X)))
In addition Prolog often allows special treatment of nonterminals which always derive
the empty string. Consider the language where each string consists of an even number
of a’s followed by the same number of b’s in turn followed by the same number of c’s.
This language can be speciﬁed as follows using DCGs with Prolog syntax:
abc
-->
a(N), b(N), c(N), even(N).
a(0)
-->
[ ].
a(s(N))
-->
[a], a(N).
b(0)
-->
[ ].
b(s(N))
-->
[b], b(N).
c(0)
-->
[ ].
c(s(N))
-->
[c], c(N).
even(0)
-->
[ ].
even(s(s(N)))
-->
even(N).
In this example the occurrence of even(N) in the ﬁrst rule always derives the empty
string. In this respect it can be removed from the rule. However, the primary function
of this nonterminal is to constrain bindings of N to terms representing even numbers.
That is, it not only deﬁnes the language consisting solely of the empty string but
also deﬁnes a relation (in this case the property of being an even natural number).
To distinguish such nonterminals from those which derive nonempty strings they are
written within curly brackets, and the deﬁnition of the relation is written directly in
Prolog. Thus, in Prolog it is possible to write the rule:
abc --> a(N), b(N), c(N), {even(N)}.
together with the deﬁnite program:
even(0).
even(s(s(N))) ←even(N).
replacing the ﬁrst and the two ﬁnal production rules of the previous DCG.
Now since calls to Prolog may be inserted into a DCG it is also possible to utilize
the built-in predicates of Prolog in a DCG.
Example 10.10 This idea is illustrated by the following example, which is a grammar
that recognizes arithmetic expressions but, more than that, also computes the value
of the expression:

174
Chapter 10:
Logic and Grammars
expr(X)
-->
term(Y ), [+], expr(Z), {X is Y + Z}.
expr(X)
-->
term(Y ), [−], expr(Z), {X is Y −Z}.
expr(X)
-->
term(X).
term(X)
-->
factor(Y ), [ ∗], term(Z), {X is Y ∗Z}.
term(X)
-->
factor(Y ), [ / ], term(Z), {X is Y/Z}.
term(X)
-->
factor(X).
factor(X)
-->
[X], {integer(X)}.
For instance, the last rule states that any string which consists of a single terminal
which is an integer is a factor with the same value as the terminal. Similarly, the
ﬁrst rule states that any string which starts with a term of value Y followed by “+”
followed by an expression of value Z is an expression of value Y + Z.
As already discussed, when a DCG is loaded into a Prolog system it is usually compiled
into a Prolog program similar in style to those in Section 10.2. This transformation is
quite simple and it is discussed in the next section. Some implementations of Prolog
do not include this feature. Fortunately, it is not very hard to write an interpreter for
DCGs similar to the Prolog-interpreter in Example 8.7.
For this purpose, view a DCG-rule as a binary fact with predicate symbol ’-->’/2
where the ﬁrst and second arguments consist of the left- and right-side of the pro-
duction rule.
The relationship between strings of terminals/nonterminals and the
derivable terminal strings can then be deﬁned as follows:
derives([ ], S −S).
derives([X], [X|S] −S).
derives({X}, S −S) ←
call(X).
derives((X, Y ), S0 −S2) ←
derives(X, S0 −S1), derives(Y, S1 −S2).
derives(X, S0 −S1) ←
(X --> Y ), derives(Y, S0 −S1).
The interpreter is surprisingly simple. Declaratively the clauses state the following:
• the empty string derives itself. That is, the diﬀerence between S and S for any
S;
• the second clause says that the terminal string [X] derives itself. That is, the
diﬀerence between [X|S] and S for any S;
• a nonterminal X in curly brackets derives the empty string if the goal ←X has
a refutation;
• if the string X derives the terminal string S0 −S1 and the string Y derives the
terminal string S1−S2 then the string (X, Y ) (that is, Y appended to X) derives
the terminal string S0 −S2;
• if there is a rule (X --> Y ) such that Y derives the terminal string S0 −S1 then
the nonterminal X derives the same terminal string.

10.5 Compilation of DCGs into Prolog
175
For instance, in the presence of the DCG of Example 10.9 the goal:
←derives(sentence(X), [john, runs] −[ ]).
succeeds with answer X = s(john, runs). Similarly the grammar in Example 10.10
and the goal:
←derives(expr(X), [2, +, 3, ∗, 4] −[ ]).
result in the answer X = 14.
10.5
Compilation of DCGs into Prolog
The standard treatment of DCGs in most Prolog systems is to compile them directly
into Prolog clauses. Since each production rule translates into one clause, the trans-
formation is relatively simple. The clause obtained as a result of the transformations
described below may diﬀer slightly from what is obtained in some Prolog systems but
the principle is the same.
The general idea is the following — consider a production rule of the form:
p(t1, . . . , tn) --> T1, . . . , Tm
Assume that X0, . . . , Xm are distinct variables which do not appear in the rule. Then
the production rule translates into the deﬁnite clause:
p(t1, . . . , tn, X0, Xm) ←A1, . . . , Am
where:
• if Ti is of the form q(s1, . . . , sj), then Ai is q(s1, . . . , sj, Xi−1, Xi);
• if Ti is of the form [T], then Ai is connects(Xi−1, T, Xi);2
• if Ti is of the form {T}, then Ai is T, Xi−1 .= Xi;
• if Ti is of the form [ ], then Ai is Xi−1 .= Xi.
For instance, the ﬁrst rule of Example 10.10 is transformed as follows:
expr(X) -->
expr(X, X0, X4) ←
term(Y ),
term(Y, X0, X1),
[+],
⇒
connects(X1, +, X2),
expr(Z),
expr(Z, X2, X3),
{X is Y + Z}.
X is Y + Z, X3 .= X4.
Some simpliﬁcations can be made to the ﬁnal result — in particular, subgoals of the
form X .= Y may be omitted if all occurrences of Y are replaced by the variable X.
This means that the result obtained above can be simpliﬁed into:
2Many Prolog systems use instead a built-in predicate ’C’(A, B, C) with the same semantics as
connects(A, B, C).

176
Chapter 10:
Logic and Grammars
expr(X, X0, X3) ←
term(Y, X0, X1),
connects(X1, +, X2),
expr(Z, X2, X3),
X is Y + Z.
When all rules are translated in this way and the program is extended by the deﬁ-
nition connects([X|Y ], X, Y ), the resulting program can be used to refute goals like
←expr(X, [2, +, 3, ∗, 4], [ ]), with the expected answer X = 14.
A CFG (which is a special case of a DCG) like the one in Example 10.1 translates
into the program of Example 10.5 except that arguments of the form X −Y are split
into two arguments and that the names of the variables may diﬀer.
Example 10.11 As a ﬁnal example the translation of Example 10.9 results in the
following program:
sentence(s(X, Y ), X0, X2) ←
np(X, N, X0, X1), vp(Y, N, X1, X2).
np(john, singular(3), X0, X1) ←
connects(X0, john, X1).
np(they, plural(3), X0, X1) ←
connects(X0, they, X1).
vp(run, plural(X), X0, X1) ←
connects(X0, run, X1).
vp(runs, singular(3), X0, X1) ←
connects(X0, runs, X1).
connects([X|Y ], X, Y ).
Given the goal ←sentence(X, [john, runs], [ ]) Prolog replies with the answer X =
s(john, runs).
Exercises
10.1 Write a DCG which describes the language of strings of octal numbers. Extend
the grammar so that the decimal value of the string is returned. For instance,
the goal ←octal(X, [4, 6], [ ]) should succeed with X = 38.
10.2 Write a DCG which accepts strings in the language ambncmdn, (n, m ≥0).
10.3 Consider the following CFG:
⟨bleat⟩
→
b ⟨aaa⟩
⟨aaa⟩
→
a
⟨aaa⟩
→
a ⟨aaa⟩
Describe the same language using DCG notation. Then “compile” the speciﬁ-
cation into a Prolog program and write an SLD-refutation which proves that
the string “b a a” is in the language of ⟨bleat⟩.

Exercises
177
10.4 Explain the usage of the following DCG:
x([ ], X, X)
-->
[ ].
x([X|Y ], Z, [X|W])
-->
x(Y, Z, W).
10.5 Write an interface to a database that facilitates communication in natural
language.
10.6 Deﬁne a concrete syntax for the imperative language outlined in exercise 8.6.
Then write a compiler which translates the concrete syntax (i.e. strings of
characters) into the given abstract syntax.
It is probably a good idea to split the translation into two phases. In the
ﬁrst phase the string is translated into a list of lexical items representing
identiﬁers, reserved words, operators etc, after which the string is translated
into the abstract syntax.
The following context-free grammar may serve as a starting point for the
compiler:
⟨cmnd⟩
→
skip
|
⟨var⟩:= ⟨expr⟩
|
if ⟨bool⟩then ⟨cmnd⟩else ⟨cmnd⟩ﬁ
|
while ⟨bool⟩do ⟨cmnd⟩od
|
⟨cmnd⟩; ⟨cmnd⟩
⟨bool⟩
→
⟨expr⟩> ⟨expr⟩
|
. . .
⟨expr⟩
→
⟨var⟩
|
⟨nat⟩
|
⟨expr⟩⟨op⟩⟨expr⟩
⟨var⟩
→
x | y | z | . . .
⟨nat⟩
→
0 | 1 | 2 | . . .
⟨op⟩
→
+ | −| ∗| . . .
Hint: Most Prolog systems permit using the syntax ”prolog” as an alternative
for the list of ASCII-characters [112, 114, 111, 108, 111, 103].

178
Chapter 10:
Logic and Grammars

Chapter 11
Searching in a State-space
11.1
State-spaces and State-transitions
Many problems in computer science can be formulated as a possibly inﬁnite set S of
states and a binary transition-relation
 over this state-space. Given some start-state
s0 ∈S and a set G ⊆S of goal-states such problems consist in determining whether
there exists a sequence:
s0
 s1, s1
 s2, s2
 s3, · · · sn−1
 sn
such that sn ∈G (i.e. to determine if ⟨s0, sn⟩is in the transitive and reﬂexive closure,
∗
 , of
 ). More informally the states can be seen as nodes in a graph whose edges
represent the pairs in the transition-relation. Then the problem reduces to that of
ﬁnding a path from the start-state to one of the goal-states.
Example 6.7 embodies an instance of such a problem — the state-space consisted
of a ﬁnite set of states named by a, b, c, d, e, f and g. The predicate symbol edge/2
was used to describe the transition relation and path/2 described the transitive and
reﬂexive closure of the transition relation. Hence, the existence of a path from, for
instance, the state a to e is checked by giving the goal ←path(a, e). Now this is by
no means the only example of such a problem. The following ones are all examples of
similar problems:
• Planning amounts to ﬁnding a sequence of worlds where the initial world is
transformed into some desired ﬁnal world. For instance, the initial world may
consist of a robot and some parts. The objective is to ﬁnd a world where the
parts are assembled in some desirable way. Here the description of the world is
a state and the transformations which transform one world to another can be
seen as a transition relation.
• The derivation of a string of terminals α from a nonterminal A can also be viewed
179

180
Chapter 11:
Searching in a State-space
in this way. The state-space consists of all strings of terminals/nonterminals.
The string A is the start-state and α the goal-state. The relation “⇒” is the
transition relation and the problem amounts to ﬁnding a sequence of derivation
steps A ⇒· · · ⇒α.
• Also SLD-derivations may be formulated in this way — the states are goals and
the transition relation consists of the SLD-resolution principle which produces
a goal Gi+1 out of another goal Gi and some program clause Ci. In most cases
the start-state is the initial goal and the goal-state is the empty goal.
Consider the following two clauses of Example 6.7 again:
path(X, X).
path(X, Z) ←edge(X, Y ), path(Y, Z).
Operationally the second clause reads as follows provided that Prolog’s computation
rule is employed — “To ﬁnd a path from X to Z, ﬁrst ﬁnd an edge from X to Y
and then ﬁnd a path from Y to Z”. That is, ﬁrst try to ﬁnd a node adjacent to the
start-state, and then try to ﬁnd a path from the new node to the goal-state. In other
words, the search proceeds in a forward direction — from the start-state to the goal-
state. However, it is easy to modify the program to search in the opposite direction
assuming that Prolog’s computation rule is used — simply rewrite the second clause
as:
path(X, Z) ←edge(Y, Z), path(X, Y ).
The decision whether to search in a forward or backward direction depends on what
the search space looks like. Such considerations will not be discussed here, but the
reader is referred to the AI-literature
The path/2-program above does not work without modiﬁcations if there is more
than one goal-state. For instance, if both f and g are goal-states one has to give two
goals. An alternative solution is to extend the program with the property of being a
goal-state:
goal state(f).
goal state(g).
Now the problem of ﬁnding a path from a to one of the goal-states reduces to ﬁnding
a refutation of the goal:
←path(a, X), goal state(X).
The program above can be simpliﬁed if the goal-state is known in advance. In this
case it is not necessary to use the second argument of path/2. Instead the program
may be simpliﬁed into:
path(pgoal
q).
path(X) ←edge(X, Y ), path(Y ).
where
pgoal
q is a term representing the goal-state (if there are several goal-states there
will be one such fact for each state).

11.2 Loop Detection
181
11.2
Loop Detection
One problem mentioned in connection with Example 6.7, appears when the graph
deﬁned by the transition relation is cyclic.
Example 11.1 Consider the program:
path(X, X).
path(X, Z) ←edge(X, Y ), path(Y, Z).
edge(a, b).
edge(b, a).
edge(a, c).
edge(b, d).
edge(b, e).
edge(c, e).
edge(d, f).
edge(e, f).
edge(e, g).
As pointed out in Chapter 6 the program may go into an inﬁnite loop for certain goals
— from state a it is possible to go to state b and from this state it is possible to go
back to state a via the cycle in the transition relation. One simple solution to such
problems is to keep a log of all states already visited. Before moving to a new state it
should be checked that the new state has not already been visited.
Example 11.2
The following program extends Example 11.1 with a log:
path(X, Y ) ←
path(X, Y, [X]).
path(X, X, Visited).
path(X, Z, Visited) ←
edge(X, Y ),
not member(Y, Visited),
path(Y, Z, [Y |Visited]).
member(X, [X|Y ]).
member(X, [Y |Z]) ←
member(X, Z).
Declaratively the recursive clause of path/3 says that — “there is a path from X to Z
if there is an edge from X to Y and a path from Y to Z such that Y has not already
been visited”.
At ﬁrst glance the solution may look a bit inelegant and there certainly are more
sophisticated solutions around. However, carrying the log around is not such a bad
idea after all — in many problems similar to the one above, it is not suﬃcient just to
answer “yes” or “no” to the question of whether there is a path between two states.
Often it is necessary that the actual path is returned as an answer to the goal. As an
example, it is not much use to know that there is a plan which assembles some pieces
of material into a gadget; in general one wants to see the actual plan.
Example 11.3 This extension can be implemented through the following modiﬁca-
tion of Example 11.2:

182
Chapter 11:
Searching in a State-space
path(X, Y, Path) ←
path(X, Y, [X], Path).
path(X, X, Visited, Visited).
path(X, Z, Visited, Path) ←
edge(X, Y ),
not member(Y, Visited),
path(Y, Z, [Y |Visited], Path).
With these modiﬁcations the goal ←path(a, d, X) succeeds with the answer X =
[d, b, a] which says that the path from a to d goes via the intermediate state b. Intu-
itively, path(A, B, C, D) can be interpreted as follows — “The diﬀerence between D
and C constitutes a path from A to B”.
11.3
Water-jug Problem (Extended Example)
The discussion above will be illustrated with the well-known water-jug problem often
encountered in the AI-literature. The problem is formulated as follows:
Two water jugs are given, a 4-gallon and a 3-gallon jug. Neither of them
has any type of marking on it. There is an inﬁnite supply of water (a tap?)
nearby. How can you get exactly 2 gallons of water into the 4-gallon jug?
Initially both jugs are empty.
The problem can obviously be described as a state-space traversal — a state is de-
scribed by a pair ⟨x, y⟩where x represents the amount of water in the 4-gallon jug
and y represents the amount of water in the 3-gallon jug. The start-state then is ⟨0, 0⟩
and the goal-state is any pair where the ﬁrst component equals 2. First of all some
transformations between states must be formulated. The following is by no means a
complete set of transformations but it turns out that there is no need for additional
ones:
• empty the 4-gallon jug if it is not already empty;
• empty the 3-gallon jug if it is not already empty;
• ﬁll up the 4-gallon jug if it is not already full;
• ﬁll up the 3-gallon jug if it is not already full;
• if there is enough water in the 3-gallon jug, use it to ﬁll up the 4-gallon jug until
it is full;
• if there is enough water in the 4-gallon jug, use it to ﬁll up the 3-gallon jug until
it is full;
• if there is room in the 4-gallon jug, pour all water from the 3-gallon jug into it;
• if there is room in the 3-gallon jug, pour all water from the 4-gallon jug into it.

11.4 Blocks World (Extended Example)
183
It is now possible to express these actions as a binary relation between two states.
The binary functor :/2 (written in inﬁx notation) is used to represent a pair:
action(X : Y, 0 : Y ) ←X > 0.
action(X : Y, X : 0) ←Y > 0.
action(X : Y, 4 : Y ) ←X < 4.
action(X : Y, X : 3) ←Y < 3.
action(X : Y, 4 : Z) ←X < 4, Z is Y −(4 −X), Z ≥0.
action(X : Y, Z : 3) ←Y < 3, Z is X −(3 −Y ), Z ≥0.
action(X : Y, Z : 0) ←Y > 0, Z is X + Y, Z ≤4.
action(X : Y, 0 : Z) ←X > 0, Z is X + Y, Z ≤3.
The deﬁnition of a path is based on the program in Example 11.3. However, since the
goal-state is known to be ⟨2, X⟩for any value of X (or at least 0 ≤X ≤3) there is
no need for the second argument of path/4. With some minor additional changes the
ﬁnal version looks as follows:
path(X) ←
path(0 : 0, [0 : 0], X).
path(2 : X, Visited, Visited).
path(State, Visited, Path) ←
action(State, NewState),
not member(NewState, Visited),
path(NewState, [NewState|Visited], Path).
member(X, [X|Y ]).
member(X, [Y |Z]) ←
member(X, Z).
Given this program and the goal ←path(X) several answers are obtained some of
which are rather naive. One answer is X = [2 : 0, 0 : 2, 4 : 2, 3 : 3, 3 : 0, 0 : 3, 0 : 0].
That is, ﬁrst ﬁll the 3-gallon jug and pour this water into the 4-gallon jug. Then the 3-
gallon jug is ﬁlled again, and the 4-gallon jug is ﬁlled with water from the 3-gallon jug.
The last actions are to empty the 4-gallon jug and then pour the content of the 3-gallon
jug into it. Another answer is X = [2 : 0, 0 : 2, 4 : 2, 3 : 3, 3 : 0, 0 : 3, 4 : 3, 4 : 0, 0 : 0].
In all 27 answers are produced.
11.4
Blocks World (Extended Example)
A similar problem is the so-called blocks world. Consider a table with three distinct
positions. On the table are a number of blocks which may be stacked on top of each
other. The aim is to move the blocks from a given start-state to a goal-state. Only
blocks which are free (that is, with no other block on top of them) can be moved.
The ﬁrst step is to determine how to represent the state. A reasonable solution is to
use a ternary functor state/3 to represent the three positions of the table. Furthermore,
use the constant table to denote the table. Finally represent by on(X, Y ) the fact
that X is positioned on top of Y . That is, state(on(c, on(b, on(a, table))), table, table)
represents the state:

184
Chapter 11:
Searching in a State-space
3
2
1
a
b
c
The following are all possible actions that transform the state:
• if the ﬁrst position is nonempty the topmost block can be moved to either the
second or the third position;
• if the second position is nonempty the topmost block can be moved to either the
ﬁrst or the third position;
• if the third position is nonempty the topmost block can be moved to either the
ﬁrst or the second position.
The ﬁrst action may be formalized as follows:
move(state(on(X, NewX), OldY, Z), state(NewX, on(X, OldY ), Z)).
move(state(on(X, NewX), Y, OldZ), state(NewX, Y, on(X, OldZ))).
The remaining two actions may be formalized in a similar way. Finally the program is
completed by adding the path-program from Example 11.3 (where edge/2 is renamed
into move/2). It is now possible to ﬁnd the path from the start-state above to the
following goal-state:
1
2
3
b
a
c
by giving the goal:
←path(
state(on(c, on(b, on(a, table))), table, table),
state(table, table, on(c, on(a, on(b, table)))),
X).
One answer to the goal is:
X = [
state(table, table, on(c, on(a, on(b, table)))),
state(table, on(c, table), on(a, on(b, table))),
state(on(a, table), on(c, table), on(b, table)),
state(on(b, on(a, table)), on(c, table), table),
state(on(c, on(b, on(a, table))), table, table)
]
That is, ﬁrst move c to position 2. Then move b to position 3 and a on top of b.
Finally move c on top of a.

11.5 Alternative Search Strategies
185
11.5
Alternative Search Strategies
For many problems the depth-ﬁrst traversal of a state-space is suﬃcient as shown
above — the depth-ﬁrst strategy is relatively simple to implement and the memory
requirements are relatively modest. However, sometimes there is need for alternative
search strategies — the depth-ﬁrst traversal may be stuck on an inﬁnite path in the
state-space although there are ﬁnite paths which lead to (one of) the goal-states.
Even worse, sometimes the branching of the state-space is so huge that it is simply
not feasible to try all possible paths — instead one has to rely on heuristic knowledge
to reduce the number of potential paths. When describing such problems by means of
logic programming there are two solutions to this problem — either the logic program
(for instance that in Example 11.1) is given to an inference system which employs the
desired search strategy; or one writes a Prolog program which solves the problem using
the desired strategy (however, this program is of course executed using the standard
depth-ﬁrst technique of Prolog). In this section an example of a Prolog program which
searches a (simple) tree using a breadth-ﬁrst traversal is shown.
Example 11.4 Consider the following tree:
a
b
c
d
e
f
g
h
  @
@
  @
@
  @
@
To look for a path in a tree (or a graph) using a breadth-ﬁrst strategy means ﬁrst
looking at all paths of length 1 from the start-state (or to the goal-state). Then all
paths of length 2 are investigated. The process is repeated until a complete path from
the start- to a goal-state is found.
The tree above will be represented using a binary predicate symbol children/2
where the ﬁrst argument is the name of a node of the tree and the second argument is
the names of the children of that node. Hence the tree above is represented as follows:
children(a, [b, c]).
children(b, [d, e]).
children(c, [f]).
children(e, [g, h]).
In order to realize the breadth-ﬁrst strategy paths will be represented by “reversed”
lists of nodes. For instance, [d, b, a] represents the path which starts at the root of the
tree and proceeds to d via the intermediate node b. Given all paths of length n from
a start-state the problem of ﬁnding a path to a goal-state reduces to ﬁnding a path
from the end of one of these paths to the goal-state. Initially this amounts to ﬁnding
a path from the empty branch [X] (where X is the start-state) to a goal-state. That
is:

186
Chapter 11:
Searching in a State-space
path(X, Y ) ←bf path([[X]], Y ).
The ﬁrst argument of bf path/2 consists of a collection of paths (represented by a list)
and the second argument is the goal-state (this may easily be generalized to several
goal-states):
bf path([ [Leaf |Branch] | Branches ], Leaf ).
bf path([ [Leaf |Branch] | Branches ], Goal) ←
children(Leaf , Adjacent),
expand([Leaf |Branch], Adjacent, Expanded),
append(Branches, Expanded, NewBranches),
bf path(NewBranches, Goal).
bf path([ [Leaf |Branch] | Branches ], Goal) ←
not children(Leaf , Leaves),
bf path(Branches, Goal).
The last clause exploits unsafe use of negation and applies when a path cannot be
expanded any further. Notice, that in order to implement a breadth-ﬁrst search, it is
vital that Expanded is appended to Branches. The other way around would lead to
a depth-ﬁrst search. Thus, the ﬁrst argument of bf path/2 behaves as a FIFO-queue
where a preﬁx contains paths of length n and where the rest of the queue contains
paths of length n+1. expand/3 describes the relation between a path X, the children
X1, . . . , Xn of the ﬁnal node in X and the paths obtained by adding X1, X2, etc. to
the end of X:
expand(X, [ ], [ ]).
expand(X, [Y |Z], [ [Y |X] | W ]) ←
expand(X, Z, W).
For instance, the goal ←expand([b, a], [d, e], X) succeeds with the answer X = [[d, b, a],
[e, b, a]].
When extended with the usual deﬁnition of append/3 the goal ←path(a, X) yields
all eight possible solutions. That is, a, b, c, d, e, f, g and h.
Exercises
11.1 A chessboard of size N × N is given — the problem is to move a knight across
the board in such a way that every square on the board is visited exactly once.
The knight may move only in accordance with the standard chess rules.
11.2 A farmer, a wolf and a goat are standing on the same river-bank accompanied
by a cabbage-head (a huge one!). A boat is available for transportation. Un-
fortunately, it has room for only two individuals including the cabbage-head.
To complicate things even more (1) the boat can be operated only by the
farmer and (2) if the goat is left alone with the wolf it will be eaten. Similarly
if the cabbage-head is left alone with the goat. Is there some way for them to
cross the river without anyone being eaten?
11.3 Three missionaries and three cannibals are standing on the same side of a
river. A boat with room for two persons is available. If the missionaries on

Exercises
187
either side of the river are outnumbered by cannibals they will be done away
with. Is there some way for all missionaries and cannibals to cross the river
without anyone being eaten?
First solve the problem using a depth-ﬁrst search strategy. (In which case a
log must be used to prune inﬁnite paths.) Then solve the same problem using
a breadth-ﬁrst strategy similar to that on page 186.
11.4 (Towers of Hanoi) Three pins are available together with N disks of diﬀerent
sizes. Initially all disks are stacked (smaller on top of bigger) on the leftmost
pin. The task is to move all disks to the rightmost pin. However, at no time
may a disk be on top of a smaller one. Hint: there is a very simple and eﬃcient
algorithmic solution to this puzzle. However, it may also be solved with the
techniques described above.
11.5 How can the program in Example 11.4 be modiﬁed to avoid the use of negation?

188
Chapter 11:
Searching in a State-space

PART III
ALTERNATIVE LOGIC
PROGRAMMING SCHEMES
189


Chapter 12
Logic Programming and
Concurrency
12.1
Algorithm = Logic + Control
The construction of a computer program can be divided into two phases which are
usually intertwined — the formulation of the actual problem (what the problem is)
and the description of how to solve the problem. Together they constitue an algo-
rithm. This idea is the heart of logic programming — the logic provides a description
of the problem and SLD-resolution provides the means for executing the description.
However, the logic has a meaning in itself — its declarative semantics — which is
independent of any particular execution strategy. This means that, as long as the
inference mechanism is sound, the behaviour of the algorithm may be altered by se-
lecting an alternative inference mechanism. We do not have to go as far as abandoning
SLD-resolution — the behaviour of the execution can be altered simply by choosing
diﬀerent computation rules as illustrated by the following example:
Example 12.1 The following execution trace illustrates the impact of a more versatile
computation rule than the one used in Prolog. First consider the program:
(1)
append([ ], X, X).
(2)
append([X|Y ], Z, [X|W]) ←append(Y, Z, W).
(3)
succlist([ ], [ ]).
(4)
succlist([X|Y ], [Z|W]) ←succlist(Y, W), Z is X + 1.
Then consider the following SLD-derivation whose initial goal consists of two compo-
nents (subgoals). Each of the subsequent goals in the derivation can be divided into
two halves originating from the components of the initial goal as visualized by the
191

192
Chapter 12:
Logic Programming and Concurrency
frames:
←append([4, 5], [3], X)
succlist(X, Res)
(G0)
Resolving append([4, 5], [3], X) using (2) yields the binding [4|W0] for X and the new
goal:
←append([5], [3], W0)
succlist([4|W0], Res)
(G1)
Resolving succlist([4|W0], Res) using (4) yields the binding [Z1|W1] for Res and the
goal:
←append([5], [3], W0)
succlist(W0, W1), Z1 is 4 + 1
(G2)
Resolving append([5], [3], W0) using (2) yields the binding [5|W2] for W0:
←append([ ], [3], W2)
succlist([5|W2], W1), Z1 is 4 + 1
(G3)
Selection of Z1 is 4 + 1 binds Z1 to 5. Consequently Res is bound to [5|W1]:
←append([ ], [3], W2)
succlist([5|W2], W1)
(G4)
Resolving succlist([5|W2], W1) using (4) yields the binding [Z4|W4] for W1:
←append([ ], [3], W2)
succlist(W2, W4), Z4 is 5 + 1
(G5)
Resolving append([ ], [3], W2) using (1) binds W2 to [3]:
←
succlist([3], W4), Z4 is 5 + 1
(G6)
Selection of Z4 is 5 + 1 binds Z4 to 6 and Res is bound to [5, 6|W4]:
←
succlist([3], W4)
(G7)
In the next step W4 is bound to [Z7|W7] yielding:
←
succlist([ ], W7), Z7 is 3 + 1
(G8)
Selection of succlist([ ], W7) binds W7 to [ ]:
←
Z7 is 3 + 1
(G9)
Finally Z7 is bound to 4 yielding a refutation where the binding for Res is the list
[5, 6, 4].
Thus, 10 SLD-steps are needed to refute the initial goal. Notice that it is not possible
to improve on this by choosing an alternative computation rule — no matter what
rule is used, the refutation will have the length 10.

12.2 And-parallelism
193
append
succlist
[5, 6, 4]
[4, 5, 3]
[3]
[4, 5]
-
-
-
-
Figure 12.1: Process-interpretation of G0
With this versatile computation rule the two subgoals in G0 may be viewed as
two processes which communicate with each other using the (shared) variable X. The
frames in the derivation capture the internal behaviour of the processes and the shared
variable acts as a “communication channel” where a stream of data ﬂows — namely
the elements of the list to which the shared variable X is (incrementally) bound to
(ﬁrst 4 then 5 and ﬁnally 3). See Figure 12.1.
Notice that there is no real parallelism in this example. The executions of the two
processes are only interleaved with each other. The control is merely shifted between
them and there is no real gain in performance. This type of control is commonly
known as coroutining.
The possibility of viewing subgoals as processes and goals as nets of communicating
processes connected by means of shared variables implies yet another interpretation
of logic programs in addition to its operational and declarative meaning. This new
view of logic programming extends the possible application areas of logic programming
to include also process programming (like operating systems, simulators or industrial
process control systems).
12.2
And-parallelism
Instead of solving the subgoals in a goal in sequence (using SLD-resolution) it is
possible to use an operational semantics where some of the subgoals are solved in
parallel. This is commonly called AND-parallelism. However, since the subgoals may
contain shared variables it is not always feasible to solve all of them independently.
Consider the following program:
do this(a).
do that(b).
A goal of the form:
←do this(X), do that(X).
would fail using SLD-resolution. However, the two subgoals are solvable separately.
The leftmost subgoal binds X to a and the rightmost binds X to b. When two subgoals
contain a shared variable special care must be taken so that diﬀerent occurrences of
the variable do not get bound to inconsistent values.
This calls for some form of
communication/synchronization between the subgoals. However there are some special
cases when two or more derivation-steps can be carried out independently:
• when the subgoals have no shared variable, and

194
Chapter 12:
Logic Programming and Concurrency
• when at most one subgoal binds each shared variable.
Consider the derivation in Example 12.1 again. Note that both subgoals in G1 can be
resolved in parallel since the shared variable (W0) is bound only by append([5], [3], W0).
Similarly, all subgoals in G3, G6 and G8 may be resolved in parallel. Thus, by exploit-
ing AND-parallelism the goal may be solved in only ﬁve steps (G0, G1, G3, G6, G8, G10)
reducing the (theoretical) time of execution by 50%.
12.3
Producers and Consumers
One point worth noticing about Example 12.1 is that the execution is completely de-
terminate — no selected subgoal uniﬁes with more than one clause-head. However,
this is not necessarily the case if some other computation rule is employed. For in-
stance, the rightmost subgoal in G0 uniﬁes with two diﬀerent clauses. To reduce the
search space it is desirable to have a computation rule which is “as determinate as
possible”. Unfortunately it is rather diﬃcult (if at all possible) to implement a com-
putation rule which always selects a determinate subgoal. However, the programmer
often has some idea how the program should be executed to obtain good eﬃciency
(although not always optimal). Hence the programmer may be allowed to provide
additional information describing how the program should be executed.
The subgoal append([4, 5], [3], X) in G0 may be viewed as a process which consumes
input from two streams ([4, 5] and [3]) and acts as a producer of bindings for the variable
X. Similarly succlist(X, Res) may be viewed as a process which consumes bindings for
the variable X and produces a stream of output for the variable Res. Since, in general,
it is not obvious which subgoals are intended to act as consumers and producers
of shared variable-occurrences the user normally has to provide a declaration. For
instance, that the ﬁrst two arguments of append/3 act as consumers and the third as
producer. There are several ways to provide such information. In what follows we
will use a notion of read-only variable which very closely resembles that employed in
languages such as Concurrent Prolog (one of the ﬁrst and most inﬂuential languages
based on a concurrent execution model).
Roughly speaking, each clause (including the goal) may contain several occurrences
of a variable. On the other hand, variables can be bound at most once in an SLD-
derivation. This implies that at most one of the atoms in a clause acts as a producer
of a binding for that variable whereas all remaining atoms containing some occurrence
of the variable act as consumers. The idea employed in Concurrent Prolog is that
the user annotates variable-occurrences appearing in consumer atoms by putting a
question mark immediately after each occurrence. For instance, G0 may be written as
follows:
←append([4, 5], [3], X), succlist(X?, Res).
This means that the call to append/3 acts as a producer of values for X and that
succlist/2 acts as a consumer of values for X and a producer of values for Res.
Variables annotated by ’?’ are called read-only variables. Variables which are not
annotated are said to be write-enabled.
Now what is the meaning of a read-only variable? From a declarative point of view
they are not diﬀerent from write-enabled occurrences of the same variable. Conse-
quently, the question-mark can be ignored in which case X and X? denote the same

12.3 Producers and Consumers
195
variable. However, from an operational point of view X and X? behave diﬀerently.
The role of X? is to suspend uniﬁcation temporarily if it is not possible to unify a
subgoal with a clause head without producing a binding for X?. The uniﬁcation can
be resumed only when the variable X is bound to a non-variable by some other pro-
cess containing a write-enabled occurrence of the variable. For instance, uniﬁcation
of p(X?) and p(f(Y )) suspends whereas uniﬁcation of p(Y ?) and p(X) succeeds with
mgu {X/Y ?}.
Application of a substitution θ to a term or a formula is deﬁned as before except
that X?θ = (Xθ)?.
Consequently, a read-only annotation may appear after non-
variable terms. In this case the annotation has no eﬀect and can simply be removed.
For instance:
p(X?, Y, Z?){X/f(W), Y/f(W?)}
=
p(f(W)?, f(W?), Z?)
=
p(f(W), f(W?), Z?)
Example 12.2 Consider the following (nonterminating) program describing the pro-
ducer-consumer problem with an unbounded buﬀer. That is, there is a producer which
produces data and a consumer which consumes data and we require that the consumer
does not attempt to consume data which is not there:
producer([X|Y ]) ←get(X), producer(Y ).
consumer([X|Y ]) ←print(X?), consumer(Y ?).
We do not specify exctly how get/1 and print/1 are deﬁned but only assume that the
call get(X) suspends until some data (e.g. a text ﬁle) is available from the outside
whereas print(X) is a printer-server which prints the ﬁle X. To avoid some technical
problems we also assume that a call to producer/1 (resp. consumer/1) does not go
ahead until get/1 (resp. print/1) succeeds.
Now consider the goal:
←producer(X), consumer(X?).
Because of the read-only annotation the second subgoal suspends. The ﬁrst subgoal
uniﬁes with producer([X0|Y0]) resulting in the mgu {X/[X0|Y0]} and the new goal:
←get(X0), producer(Y0), consumer([X0|Y0]).
At this point only the third subgoal may proceed. (The ﬁrst subgoal suspends until
some external data becomes available and the second subgoal suspends until the ﬁrst
subgoal succeeds.)
←get(X0), producer(Y0), print(X0?), consumer(Y0?).
This goal suspends until an external job arrives (to avoid having to consider how jobs
are represented we just denote them by jobn). Assume that job1 eventually arrives in
which case get(X0) succeeds with X0 bound to job1:
←producer(Y0), print(job1), consumer(Y0?).
Then assume that the producer/1-process is reduced to:
←get(X1), producer(Y1), print(job1), consumer([X1|Y1]).

196
Chapter 12:
Logic Programming and Concurrency
and that a new job arrives from outside while the ﬁrst is being printed:
←producer(Y1), print(job1), consumer([job2 |Y1]).
The producer/1-process can now be reduced to:
←get(X2), producer(Y2), print(job1), consumer([job2, X2|Y2]).
The whole goal suspends again until either (1) a new job arrives (in which case the
new job is enqueued after the second job) or (2) printing of the ﬁrst job ends (in
which case the second job can be printed). As pointed out above the program does
not terminate.
Notice that it may happen that all subgoals in a goal become suspended forever. A
trivial example is the goal ←consumer(X?). This situation is called deadlock.
12.4
Don’t Care Nondeterminism
The Prolog computation consists of a traversal of the SLD-tree. The branching of
the tree occurs when the selected subgoal matches several clause heads. To be sure
that no refutations are disregarded, a backtracking strategy is employed. Informally
the system “does not know” how to obtain the answers so all possibilities are tried
(unless, of course, the search gets stuck on some inﬁnite branch). This is sometimes
called “don’t know nondeterminism”.
The traversal of the tree may be carried out in parallel. This is commonly called
OR-parallelism. Notice that OR-parallelism does not necessarily speed up the discov-
ery of a particular answer.
Although full OR-parallelism may be combined with AND-parallelism this is sel-
dom done because of implementation diﬃculties.
Instead a form of limited OR-
parallelism is employed. The idea is to commit to a single clause as soon as possible
when trying to solve a literal. Informally this means that all parallel attempts to solve
a subgoal are immediately surrendered when the subgoal uniﬁes with the head of some
clause and certain subgoals in that clause are solved. To make this more precise the
concept of commit operator is introduced. The commit operator divides the body of
a clause into a guard- and body-part. The commit-operator may be viewed as a gener-
alized cut operator in the sense that it cuts oﬀall other attempts to solve a subgoal.
This scheme is usually called “don’t care nondeterminism”. Intuitively this can be
understood as follows — assume that a subgoal can be solved using several diﬀerent
clauses all of which lead to the same solution. Then it does not matter which clause
to pick. Hence, it suﬃces to pick one of the clauses not caring about the others. Of
course, in general it is not possible to tell whether all attempts will lead to the same
solution and the responsibility has to be left to the user.
12.5
Concurrent Logic Programming
The concepts discussed above provide a basis for a class of programming languages
based on logic programming. They are commonly called Concurrent Logic Program-
ming languages or Committed Choice Languages. For the rest of this chapter the

12.5 Concurrent Logic Programming
197
principles of these languages are discussed. To illustrate the principles we use a lan-
guage similar to Shapiro’s Concurrent Prolog (1983a).
By analogy to deﬁnite programs, the programs considered here are ﬁnite sets of
guarded clauses. The general scheme of a guarded clause is as follows:
H ←G1, . . . , Gm | B1, . . . , Bn
(m ≥0, n ≥0)
where H, G1, . . . , Gm, B1, . . . , Bn are atoms (possibly containing read-only annota-
tions). H is called the head of the clause. G1, . . . , Gm and B1, . . . , Bn are called the
guard and the body of the clause. The symbol “|” which divides the clause into a guard-
and body-part is called the commit operator. If the guard is empty the commit oper-
ator is not written out. To simplify the operational semantics of the language, guards
are only allowed to contain certain predeﬁned test-predicates — typically arithmetic
comparisons. Such guards are usually called ﬂat and the restriction of Concurrent
Prolog which allows only ﬂat guards is called Flat Concurrent Prolog (FCP).
Like deﬁnite programs, FCP-programs are used to produce bindings for variables
in goals given by the user. The initial goal is not allowed to contain any guard.
Example 12.3 The following are two examples of FCP-programs for merging lists
and deleting elements from lists:
merge([ ], [ ], [ ]).
merge([X|Y ], Z, [X|W]) ←merge(Y ?, Z, W).
merge(X, [Y |Z], [Y |W]) ←merge(X, Z?, W).
delete(X, [ ], [ ]).
delete(X, [X|Y ], Z) ←delete(X, Y ?, Z).
delete(X, [Y |Z], [Y |W]) ←X ̸= Y | delete(X, Z?, W).
Like deﬁnite clauses, guarded clauses have a logical reading:
• all variables in a guarded clause are implicitly universally quantiﬁed — the read-
only annotations have no logical meaning;
• “←” denotes logical implication;
• “|” and “,” denote logical conjunctions.
Each clause of the program must contain exactly one commit operator (although
usually not explicitly written when the guard-part is empty). Operationally it divides
the right-hand side of a clause into two parts which are solved strictly in sequence.
Before starting solving the body the whole guard must be solved. Literals in the guard
and body are separated by commas. Operationally this means that the literals may
be solved in parallel.
The notion of derivation basically carries over from deﬁnite programs. However,
the read-only annotations and commit operators impose certain restrictions on the
selection of a subgoal in a derivation step. This is because some subgoals may be
temporarily suspended. There are three reasons for this — either because (1) uniﬁca-
tion of a subgoal with a clause head cannot be performed without binding read-only

198
Chapter 12:
Logic Programming and Concurrency
variables or (2) the subgoal appears in the body of a guarded clause whose guard is
not yet satisﬁed or (3) the subgoal is a non-ground test-predicate.
To describe the basic derivation-step taking these restrictions into account the goal
will be partitioned into groups of guards and bodies. To emphasize this the goal will
be written as follows:
←G1 | B1 , . . . , Gi | Bi , . . . , Gn | Bn .
where both Gj and Bj, (1 ≤j ≤n), are possibly empty conjunctions of atoms (in case
of Gj containing only test-predicates). A single reduction of the goal then amounts to
selecting some subgoal A such that either:
(i) A is a test-predicate in Gi or Bi (if Gi is empty) which is both ground and true.
The new goal is obtained by removing A from the goal.
(ii) Gi is empty, A appears in Bi and is a user-deﬁned predicate and there is a
(renamed) guarded clause of the form:
H ←Gm | Bm.
such that A and H unify (with mgu θ) without binding any read-only variables.
The new goal obtained is:
(←G1 | B1 , . . . , Bi \ A , Gm | Bm , . . . , Gn | Bn )θ.
where Bi \ A denotes the result of removing A from Bi.
A successful derivation is one where the ﬁnal goal is empty.
Like SLD-resolution this scheme contains several nondeterministic choices — many
subgoals may be selected and if the subgoal selected is user-deﬁned there may be
several guarded clauses which unify with it. In the latter case the commit operator
has an eﬀect similar to that of cut. In order to solve a subgoal several clauses are
tried in parallel. However, as soon as the subgoal uniﬁes with one of the clauses and
succeeds in solving its guard, all other attempts to solve the subgoal are immediately
surrendered. Thus, the commit operator behaves as a kind of symmetric cut. For
instance, take Example 12.3 and the goal:
←merge([a, b], [c, d], X).
This goal has many solutions in Prolog. In FCP there is only one solution to the goal.
The result depends on what clauses the refutation commits to.
Since each clause is required to contain exactly one commit operator no goal can
have more than one solution. Thus, it is not possible to use append/3 to generate
splittings of a list.
At most one solution will be found.
This is one of the main
disadvantages of this class of languages. However, this is the price that has to be paid
in order to be able to implement these languages eﬃciently. Note that it is vital to test
for inequality in the guard of the last clause of the delete/3-program for this reason.
If the test is moved to the body it may happen that goals fail because of committing
to the third clause instead of the second.

12.5 Concurrent Logic Programming
199
user
user
Σ
dbms
Figure 12.2: Transaction system
The execution model given above is somewhat simpliﬁed since at each step only
one subgoal is selected. As already mentioned, languages like FCP support AND-
parallelism which means that several subgoals may be selected simultaneously. How-
ever, incorporating this extra dimension into the execution model above makes it
rather complicated and we will therefore stick to the sequential version which simu-
lates parallelism through coroutining.
The chapter is concluded with an example of a CLP program that implements a
simple database system with a ﬁxed number of clients.
Example 12.4 Consider an application involving a database transaction system. Such
a system consists of some processes where customers (users) input transactions and
a database management system (DBMS) performs the transactions using a database
and outputs the results to the user. See Figure 12.2.
To start up such a system of processes the following goal may be given (if we
restrict ourselves to two users of the database system):
←user(tty1, X), user(tty2, Y ), merge(X?, Y ?, Z), dbms(Z?, [ ]).
A formal deﬁnition of the user/2-process will not be provided. Informally the process
user(ttyn, X) is assumed to behave as follows:
(i) It suspends until the arrival of a message from the terminal named ttyn;
(ii) When a message M arrives it binds X to the pair [M|Msgs] where Msgs is a
new variable. (For a description of all possible messages see Figure 12.3.);
(iii) Then the process suspends until M becomes ground;
(iv) When M becomes ground it prints a message on ttyn;
(v) Finally it calls itself with user(ttyn, Msgs).
Thus, the two user/2-processes generate two (inﬁnite) streams of transactions which
are merged nondeterministically by the merge/3-process and the resulting stream is
processed (and grounded) by the dbms/2-system.
For the sake of simplicity, assume that the database consists of a list of pairs of the
form item(key, value) where key is a unique identiﬁer and value is the data associated
with the key. Three diﬀerent transactions are to be considered — a pair may be (1)
added to the database, (2) deleted from the database, and (3) retrieved from the
database. On the top level the database management system may be organized as
follows (the ﬁrst clause is not needed in this version of the program but is added as a
hint to exercise 12.3):

200
Chapter 12:
Logic Programming and Concurrency
Transactions
Description
add(key, value, Reply)
This message represents an external request to add
a new item of the form item(key, value) to the
database. The ﬁrst two arguments are ground and
Reply a variable which eventually is grounded by the
DBMS.
del(key, Reply)
This message represents an external request to delete
an item of the form item(key, ) from the database.
The ﬁrst argument is ground and Reply a variable
which eventually is grounded by the DBMS.
in(key, Reply)
This message represents an external request to re-
trieve the value stored in the item of the form
item(key, ) from the database. The ﬁrst argument
is ground and Reply a variable which eventually is
grounded by the DBMS.
Figure 12.3: Description of database transactions
dbms([kill|Nxt], Db).
dbms([in(Key, Reply)|Nxt], Db) ←
retrieve(Key, Db, Reply),
dbms(Nxt?, Db).
dbms([add(Key, V al, Reply)|Nxt], Db) ←
insert(Key, V al, Db?, NewDb, Reply),
dbms(Nxt?, NewDb?).
dbms([del(Key, Reply)|Nxt], Db) ←
delete(Key, Db?, NewDb, Reply),
dbms(Nxt?, NewDb?).
If the ﬁrst transaction appearing in the stream is a request to retrieve information from
the database, dbms/2 invokes the procedure retrieve/3. The ﬁrst argument is the key
sought for, the second argument is the current database and the third argument is
the value associated with the key (or not found if the key does not appear in the
database).
retrieve(Key, [ ], not found).
retrieve(Key, [item(Key, X)|Db], X).
retrieve(Key, [item(K, Y )|Db], X) ←
Key ̸= K | retrieve(Key, Db, X).
If the ﬁrst transaction is a request to add a new key/value-pair to the database the
data is stored in the database by means of the predicate insert/5.
The ﬁrst and
second arguments are the key and the associated value, the third argument is the
current database, the fourth argument is the new database after adding the pair and
the ﬁnal argument returns a reply to the user (since the operation always succeeds the
reply is always done).

12.5 Concurrent Logic Programming
201
insert(Key, X, [ ], [item(Key, X)], done).
insert(Key, X, [item(Key, Y )|Db], [item(Key, X)|Db], done).
insert(Key, X, [item(K, Y )|Db], [item(K, Y )|NewDb], Reply) ←
Key ̸= K | insert(Key, X, Db, NewDb, Reply).
Notice that insert/5 either adds the pair at the very end of the database or, if the
key is already used in the database, replaces the old value associated with the key by
the new value. If the latter is not wanted an error message may be returned instead
by simple modiﬁcations of the second clause.
The last transaction supported is the removal of information from the database.
This is taken care of by the predicate delete/4. The ﬁrst argument is the key of the
pair to be removed from the database — the second argument. The third argument
will be bound to the new database and the fourth argument records the result of the
transaction (done if the key was found and not found otherwise):
delete(Key, [ ], [ ], not found).
delete(Key, [item(Key, Y )|Db], Db, done).
delete(Key, [item(K, Y )|Db], [item(K, Y )|NewDb], Reply) ←
Key ̸= K | delete(Key, Db, NewDb, Reply).
We conclude the example by considering an outline of an execution trace of the goal:
←user(tty1, X), user(tty2, Y ), merge(X?, Y ?, Z), dbms(Z?, [ ]).
Initially, all subgoals are suspended. Now assume that the ﬁrst user/2-process binds
X to [add(k10, john, R)|X0]:
←. . . , merge([add(k10, john, R)|X0], Y ?, Z), dbms(Z?, [ ]).
Then merge/3 can be resumed binding Z to [add(k10, john, R)|W1] and the new goal
becomes:
←. . . , merge(X0?, Y ?, W1), dbms([add(k10, john, R)|W1], [ ]).
At this point dbms/2 is resumed reducing the goal to:
←. . . , merge(. . .), insert(k10, john, [ ], D, R), dbms(W1?, D?).
The call to insert/5 succeeds binding D to [item(k10, john)] and R to done (the reply
done is echoed on tty1):
←. . . , merge(X0?, Y ?, W1), dbms(W1?, [item(k10, john)]).
At this point both merge/3 and dbms/2 are suspended waiting for new messages from
one of the terminals. Assume that the second user wants to know the value associated
with the key k10. Then Y is bound to [in(k10, R)|Y2]:
←. . . , merge(X0?, [in(k10, R)|Y2], W1), dbms(W1?, [item(k10, john)]).
Next W1 is bound to [in(k10, R)|W3] and the goal is reduced to:
←. . . , merge(X0?, Y2?, W3), dbms([in(k10, R)|W3], [item(k10, john)]).

202
Chapter 12:
Logic Programming and Concurrency
Thereafter dbms/2 is resumed and uniﬁed with the second clause yielding the goal:
←. . . , merge(. . .), retrieve(k10, [item(k10, john)], R), dbms(W3?, . . .).
The call to retrieve/3 succeeds with R bound to john. The answer is echoed on tty2
and the goal is reduced to:
←. . . , merge(X0?, Y2?, W3), dbms(W3?, [item(k10, john)]).
At this point the whole system is suspended until one of the users supplies another
transaction.
The example above illustrates one fundamental diﬀerence between sequential SLD-
resolution for deﬁnite programs and concurrent execution. In the former case compu-
tations are normally ﬁnite and the program computes relations. However, in the latter
case, computations may be inﬁnite and the meaning of the program is not so easily
deﬁned in terms of relations. For instance, when giving a goal:
←A1, . . . , An
we normally want this goal to succeed with some answer substitution. However, the
goal in Example 12.4 does not terminate, yet the execution results in some useful
output via side-eﬀects (supplying transactions to the terminal and obtaining answers
echoed on the screen). This fundamental diﬀerence makes more complicated to give a
declarative semantics to concurrent logic programming languages like FCP.
Exercises
12.1 Write a concurrent logic program for checking if two binary trees have the
same set of labels associated with the nodes of the tree. Note that the labels
associated with corresponding nodes do not have to be the same.
12.2 Write a concurrent program for multiplying N × N-matrices of integers (for
arbitrary N’s).
12.3 Suggest a way of including a “kill”-process in Example 12.4. Such a process
is initially suspended but should, when it is activated, terminate all other
processes in the transaction system in a controlled way.
12.4 Write a concurrent program which takes as input a stream of letters (repre-
sented by constants) and replaces all occurrences of the sequence “aa” by “a”
and all occurrences of “–” by the empty string. All other letters should appear
as they stand in the input.
12.5 Give a solution to the producer-consumer problem with a bounded buﬀer.

Chapter 13
Logic Programs with Equality
As emphasized in the previous chapters, logic programs describe relations. Of course,
since a function may be viewed as a special case of a relation it is also possible to deﬁne
functions as relations using logic programs. However, in this case it is usually not clear
whether the described relation is a function or not (cf. Section 5.2). Furthermore, this
kind of description associates functions with predicate symbols, while it would be more
desirable to have functions associated with functors.
In this chapter we present a mechanism that allows us to incorporate such func-
tional deﬁnitions into logic programming. The idea is to introduce a special binary
predicate symbol “ .=” — called the equality — which is to be interpreted as the identity
relation on the domain of any interpretation of logic programs.
The notion of equality thus makes it possible to restrict attention to interpretations
where certain terms are identiﬁed. For instance the factorial function may be deﬁned
by the following (implicitly universally quantiﬁed) equations:
fac(0)
.=
s(0).
fac(s(X))
.=
s(X) ∗fac(X).
0 ∗X
.=
0.
s(X) ∗Y
.=
X ∗Y + Y.
0 + X
.=
X.
s(X) + Y
.=
s(X + Y ).
In any model of these formulas the meanings of the terms fac(0) and s(0) are the
same. The use of such equations may be exploited to extend the notion of uniﬁcation.
Consider a deﬁnite program:
odd(s(0)).
odd(s(s(X))) ←odd(X).
The formula odd(fac(0)) certainly is true in the intended interpretation. However,
203

204
Chapter 13:
Logic Programs with Equality
since SLD-resolution is based on the notion of syntactic equality it is not powerful
enough to produce an SLD-refutation from the deﬁnite goal:
←odd(fac(0)).
In Section 13.3 we will see how deﬁnite programs with equality can be used to extend
the notion of uniﬁcation into so-called E-uniﬁcation. However, before involving deﬁnite
programs we study the meaning of equality axioms similar to those used above.
13.1
Equations and E-uniﬁcation
In what follows an equation will be a formula of the form s .= t where s and t are
terms from a given alphabet. This kind of unconditional equation may be extended
to conditional ones. That is, formulas of the form:
F ⊃(s .= t)
where s and t are terms and F is some formula possibly containing other predicate
symbols than “ .=”. In this chapter attention is restricted to unconditional equations.
At a ﬁrst glance the restriction to unconditional equations may seem to be a serious
limitation, but from a theoretical point of view unconditional equations are suﬃcient
to deﬁne any computable function (e.g. Rogers (1967)). Hence, the restriction is solely
syntactic.
The intuition behind introducing the new predicate symbol “ .=”, is to identify
terms which denote the same individual in the domain of discourse, regardless of the
values of their variables. Hence, for two terms s and t, the formula s .= t is true in an
interpretation ℑand valuation ϕ iﬀs and t have identical interpretations in ℑand ϕ
(that is, if ϕℑ(s) = ϕℑ(t)). An interpretation ℑis said to be a model of ∀(s .= t) if
s .= t is true in ℑunder any valuation ϕ. This extends to sets E of equations: ℑis a
model of a set E of equations iﬀℑis a model of each equation in E.
The concept of logical consequence carries over from Chapter 1 with the modiﬁ-
cation that the only interpretations that are considered are those that associate “ .=”
with the identity relation. Hence, given a set of equations E, s .= t is said to be a
logical consequence of E (denoted E |= s .= t) iﬀs .= t is true in any model of E.
One of the main objectives of any logic is to permit inference of new formulas from
old ones using a system of rewrite rules. The inference rules in Figure 13.1 deﬁnes
the relation between a set of equational hypohesis E and new derived equations. (The
notation E ⊢s .= t should be read “s .= t is derived from E”.) The derivability
relation induces an equivalence relation, ≡E, on the set of all terms, deﬁned by s ≡E t
iﬀE ⊢s .= t.
The relation is called an equality theory.
The inference rules just
introduced were shown to be both sound and complete by Birkhoﬀ(1935):
Theorem 13.1 (Soundness and Completeness)
E |= s .= t
iﬀ
E ⊢s .= t
iﬀ
s ≡E t
The notion of E-uniﬁcation is deﬁned relative to the equality theory, ≡E, induced by
E and ⊢.

13.2 More on E-uniﬁcation
205
Hypothesis:
E ⊢s .= t
(if s .= t ∈E)
Reflexivity:
E ⊢s .= s
Symmetry:
E ⊢s .= t
E ⊢t .= s
Transitivity:
E ⊢r .= s
E ⊢s .= t
E ⊢r .= t
Stability:
E ⊢s .= t
E ⊢sθ .= tθ
Congruence:
E ⊢s1 .= t1
· · ·
E ⊢sn .= tn
E ⊢f(s1, . . . , sn) .= f(t1, . . . , tn)
Figure 13.1: Inference rules for equality
Deﬁnition 13.2 (E-uniﬁer) Two terms, s and t, are said to be E-uniﬁable if there
exists some substitution θ such that sθ ≡E tθ. The substitution θ is called an E-uniﬁer
of s and t.
Example 13.3 Let E be the following equalities deﬁning addition of natural numbers:
sum(0, X)
.=
X.
sum(s(X), Y )
.=
s(sum(X, Y )).
Consider the problem of ﬁnding an E-uniﬁer of the two terms sum(s(X), Y ) and
s(s(0)). As formally shown in Figure 13.2, the two terms have at least one E-uniﬁer
— namely {X/0, Y/s(0)}.
Note that in the case of the empty equality theory, ≡
? relates every term only to itself.
This implies that two terms, s and t, are
?-uniﬁable iﬀthere is some substitution θ such
that sθ is identical to tθ. Hence, the notion of E-uniﬁcation encompasses “standard”
uniﬁcation as a special case.
13.2
More on E-uniﬁcation
As observed above, standard uniﬁcation as deﬁned in Chapter 3 is a special case
of E-uniﬁcation for the degenerate case when E =
? . This suggests that it may
be possible to generalize SLD-resolution into something more powerful by replacing

206
Chapter 13:
Logic Programs with Equality
E ⊢sum(s(X), Y ) .= s(sum(X, Y ))
E ⊢sum(s(0), s(0)) .= s(sum(0, s(0)))
E ⊢sum(0, X) .= X
E ⊢sum(0, s(0)) .= s(0)
E ⊢s(sum(0, s(0))) .= s(s(0))
E ⊢sum(s(0), s(0)) .= s(s(0))
Figure 13.2: Proof of E ⊢sum(s(0), s(0)) .= s(s(0))
standard uniﬁcation by E-uniﬁcation.
Such an extension is discussed in the next
section but ﬁrst a number of questions are raised concerning the practical problems of
E-uniﬁcation.
First of all, an E-uniﬁcation algorithm must be provided.
For the case when
E =
? there are eﬃcient uniﬁcation algorithms available as discussed in Chapter 3.
The algorithm given there has some nice properties — it always terminates and if the
terms given as input to the algorithm are uniﬁable, it returns a most general uniﬁer of
the terms; otherwise it fails. For arbitrary sets of equations these properties are not
carried over. For instance, E-uniﬁcation is undecidable. That is, given an arbitrary
set E of equations and two terms s and t, it is not in general possible to determine
whether s ≡E t.
In addition, the algorithm of Chapter 3 is complete in the sense that if s and t are
uniﬁable, then any of their uniﬁers can be obtained by composing the output of the
algorithm with some other substitution. This is because existence of a uniﬁer implies
the existence of a most general one. This is not true for arbitrary sets of equations.
Instead a set of uniﬁers must be considered. Before resorting to an example, some
preliminaries are needed to formulate this more precisely.
A term t is said to subsume the term s iﬀthere is a substitution σ such that
tσ ≡E s. This is denoted by s ⪯E t. The relation can be extended to substitutions
as follows — let V be a set of variables and σ, θ substitutions. Then θ subsumes σ
relative to V (denoted σ ⪯E θ[V ]) iﬀXσ ⪯E Xθ for all X ∈V . If V is the set of all
variables in s and t, then the set S of substitutions is a complete set of E-uniﬁers of
s and t iﬀ:
• every θ ∈S is an E-uniﬁer of s and t;
• for every E-uniﬁer σ of s and t, there exists θ ∈S such that σ ⪯E θ[V ].
For the case when E =
? the standard uniﬁcation algorithm produces a complete
set of E-uniﬁers. This set is either empty (if the terms are not uniﬁable) or consists
of a single mgu. Unfortunately, for nonempty sets E of equations, complete sets of
E-uniﬁers may be arbitrary large. In fact, there are cases when two terms only have
an inﬁnite complete set of E-uniﬁers.
The following example shows two terms with two E-uniﬁers where the ﬁrst E-
uniﬁer is not subsumed by the other and vice versa.
Example 13.4 Consider the equations in Example 13.3 again. As shown in Figure
13.2 the substitution θ := {X/0, Y/s(0)} is an E-uniﬁer of the terms sum(s(X), Y )
and s(s(0)). However, also σ := {X/s(0), Y/0} is a uniﬁer of the terms. (The proof is

13.3 Logic Programs with Equality
207
left as an exercise). It can be shown that neither θ ⪯E σ[{X, Y }] nor σ ⪯E θ[{X, Y }].
It can also be shown that any other E-uniﬁer of the two terms is subsumed by one of
these two substitutions. Thus, the set {θ, σ} constitutes a complete set of E-uniﬁers
of the two terms.
An E-uniﬁcation algorithm is said to be sound if, for arbitrary terms s and t, its
output is a set of E-uniﬁers of s and t. The algorithm is complete if the set in addition
is a complete set of E-uniﬁers. Needless to say, it is desirable to have an E-uniﬁcation
algorithm which is at least sound and preferably complete. However, as already pointed
out, there are sets of equations and pairs of terms which do not have ﬁnite sets of E-
uniﬁers. For such cases we cannot ﬁnd a complete E-uniﬁcation algorithm. Thus, one
must weaken the notion of completeness by saying that an algorithm is complete if
it enumerates a complete set of E-uniﬁers (for arbitrary pairs of terms). Under this
deﬁnition there are both sound and complete E-uniﬁcation algorithms for arbitrary
sets E of equations. Unfortunately they are of little practical interest because of their
tendency to loop.
Thus, instead of studying general-purpose algorithms, research has concentrated
on trying to ﬁnd algorithms for restricted classes of equations, much like research on
logic programming started with the restricted form of deﬁnite programs. Standard
uniﬁcation is a trivial example where no equations whatsoever are allowed.
The most well-known approach based on restricted forms of equations is called
narrowing which, in many ways, resembles SLD-resolution. It has been shown to be
both sound and complete for a nontrivial class of equational theories. Characterizing
this class more exactly is outside the scope of this book.
Unfortunately narrowing also suﬀers from termination problems. The reason is
that the algorithm does not know when it has found a complete set of uniﬁers. It may
of course happen that this set is inﬁnite in which case there is no hope for termination
whatsoever. But even if the set is ﬁnite, the algorithm often loops since it is not
possible to say whether the set found so far is a complete set of E-uniﬁers. Hence,
in practice one has to impose some sort of restrictions not only on the form of the
equations but also on the terms to be E-uniﬁed. One simple case occurs when both
terms are ground.
In this case either
? or the singleton {ϵ} is a complete set of
E-uniﬁers of the terms.
13.3
Logic Programs with Equality
In this section we review the integration of deﬁnite programs and equations. It turns
out that the proof-theoretic and model-theoretic semantics of this language are natural
extensions of the corresponding concepts for deﬁnite programs alone.
But before
describing the nature of these extensions the syntax of deﬁnite programs with equations
is given. Thereafter weaknesses of deﬁnite programs alone are discussed to motivate
the extensions.
A deﬁnite program with equality is a pair P, E where:
• P is a ﬁnite set of deﬁnite clauses not containing the predicate symbol “ .=”;
• E is a possibly inﬁnite set of equations.

208
Chapter 13:
Logic Programs with Equality
One sometimes sees diﬀerent extensions of this idea where E may contain e.g. con-
ditional equations or where “ .=” may appear in the bodies of clauses in P. What is
described below can also be generalized to such programs with some additional eﬀort.
Now, consider the following deﬁnite program P where the symbols have their nat-
ural intended interpretations:
odd(1).
odd(X + 2) ←odd(X).
Although odd(2+1) is true in the intended model it is not a logical consequence of the
program because the program has at least one model (for instance the least Herbrand
model MP) where odd(2 + 1) is false. It may thus be argued that the least Herbrand
model is “incompatible” with the intended interpretation since the two terms 1 + 2
and 2 + 1 have distinct interpretations in MP — recall that any ground term denotes
itself in any Herbrand interpretation.
As pointed out above equations may be used to focus attention on certain models
— namely those where some terms denote the same object. For instance, by adding
to P the equation E:
2 + 1 .= 1 + 2
(or more generally X + Y .= Y + X) it is possible to exclude certain unwanted inter-
pretations from being models of P and E. In particular, MP is no longer a model of
both P and E. (In fact, no Herbrand interpretation of P is a model of P and E since
the terms 1 + 2 and 2 + 1 denote distinct objects.)
We recall that the model-theoretic semantics of deﬁnite programs without equality
enjoys some attractive properties: To characterize the meaning of a program (i.e. its
set of ground, atomic logical consequences) it is suﬃcient to consider the set of all
Herbrand models. In fact, attention may be focused on a single least Herbrand model.
Evidently, this is not applicable to deﬁnite programs with equality. However, there
is a natural extension of these ideas: Instead of considering interpretations where the
domain consists of ground terms one may consider interpretations where the domain
consists of sets of equivalent ground terms.
More precisely one may consider the
quotient set of UP with respect to a congruence relation. Such a set will be called an
E-universe. In what follows, it will be clear from the context what congruence relation
is intended, and we will just write s to denote the equivalence class which contains s.
By analogy to deﬁnite programs the E-base will be the set:
{p(t1, . . . , tn) | t1, . . . , tn ∈E-universe and p/n is a predicate symbol}
and an E-interpretation will be a subset of the E-base. The intuition behind an E-
interpretation is as follows: (1) the meaning of a ground term t is the equivalence class
t and (2) if s and t are ground terms, then s .= t is true in the interpretation iﬀs and
t are members in the same equivalence class of the domain (i.e. if s = t).
To characterize the set of all ground, atomic logical consequences of a program P, E
we ﬁrst deﬁne a set of E-interpretations which are models of E. Then we consider
E-interpretations which are also models of P. The following theorem shows that it is
reasonable to restrict attention to E-interpretations whose domain is UP /≡E (the set
of all equivalence-classes of UP w.r.t. the relation ≡E), since they characterize the set
of all ground equations which are logical consequences of E:

13.3 Logic Programs with Equality
209
Theorem 13.5 Let E be a set of equations, s and t ground terms and ℑan E-
interpretation whose domain is UP /≡E. Then:
ℑ|= s .= t
iﬀ
s = t
iﬀ
s ≡E t
iﬀ
E |= s .= t
Such E-interpretations are called canonical. Notice that if E =
? then s = {s} for any
ground term s, and ℑreduces to a Herbrand interpretation (except that the domain
consists of singleton sets of ground terms).
Example 13.6 Consider the following set E of equations:
father(sally) .= robert.
father(bruce) .= adam.
father(simon) .= robert.
Then UP /≡E contains elements such as:
robert
=
{robert, father(sally), father(simon)}
adam
=
{adam, father(bruce)}
sally
=
{sally}
bruce
=
{bruce}
Most of the results from Chapter 2 can be carried over to canonical E-interpretations.
For instance (see Jaﬀar, Lassez and Maher (1986) or (1984) for details):
• if P, E has a model then it also has a canonical E-model;
• the intersection of all canonical E-models of P, E is a canonical E-model;
• there is a least canonical E-model (denoted by MP,E).
Moreover, MP,E characterizes the set of all ground, atomic logical consequences of
P, E. In what follows let p(t1, . . . , tn) be an abbreviation of p(t1, . . . , tn). If t1, . . . , tn
are ground terms, then:
P, E |= p(t1, . . . , tn)
iﬀ
p(t1, . . . , tn) ∈MP,E
An alternative characterization of this set can be given by a ﬁxed point-operator
similar to the TP -operator for deﬁnite programs. The operator — denoted by TP,E —
is deﬁned as follows:
TP,E(x) := {A | A ←A1, . . . , An ∈ground(P) ∧A1, . . . , An ∈x}
Jaﬀar, Lassez and Maher (1984) showed that MP,E = TP,E ↑ω.

210
Chapter 13:
Logic Programs with Equality
Example 13.7 Let P, E be the program:
proud(father(X)) ←newborn(X).
newborn(sally).
newborn(bruce).
father(sally) .= robert.
father(bruce) .= adam.
father(simon) .= robert.
In this case:
MP,E = {proud(robert), proud(adam), newborn(sally), newborn(bruce)}
As observed above the model-theoretic semantics of deﬁnite programs with equality
is a generalization of the model-theoretic semantics of deﬁnite programs.
This is
not particularly strange since a deﬁnite program also has a set of equations, albeit
empty. One might expect that a similar situation would crop up for the proof-theoretic
semantics and, indeed, it does. In principle, the only modiﬁcation which is needed to
SLD-resolution is to replace ordinary uniﬁcation by E-uniﬁcation. In what follows we
presuppose the existence of a complete E-uniﬁcation algorithm. However, we do not
spell out how it works. The following informal description describes the principles of
the proof-theory.
Let P be a deﬁnite program, E a set of equations and G the deﬁnite goal:
←A1, . . . , Am−1, Am, Am+1, . . . , An
Now assume that C is the (renamed) program clause:
B0 ←B1, . . . , Bj
(j ≥0)
and that Am and B0 have a nonempty, complete set of E-uniﬁers Θ. Then G and C
resolve into the new goal:
←(A1, . . . , Am−1, B1, . . . , Bj, Am+1, . . . , An)θ
if θ ∈Θ.
To avoid confusing this with ordinary SLD-resolution it will be called the SLDE-
resolution principle. The notion of SLDE-derivation, refutation etc. are carried over
from Chapter 3. SLDE-resolution introduces one extra level of nondeterminism —
since two atoms may have several E-uniﬁers none of which subsume the others, it
may happen that a given computation rule, a goal and a clause with a head that
E-uniﬁes with the selected subgoal, result in several new goals. This was not the case
for SLD-resolution since the existence of a unique mgu allowed only one new goal to
be derived.
Example 13.8 Consider again the following deﬁnite program and equations:

13.3 Logic Programs with Equality
211

←newborn(sally).
←newborn(simon).
←proud(robert).
   @
@
@
Figure 13.3: SLDE-tree for the goal ←proud(robert)
proud(father(X)) ←newborn(X).
newborn(sally).
newborn(bruce).
father(sally) .= robert.
father(bruce) .= adam.
father(simon) .= robert.
Let G0 be the goal:
←proud(robert).
Since {{X0/sally}, {X0/simon}} is a complete set of E-uniﬁers of proud(robert) and
proud(father(X0)), G1 is either of the form:
←newborn(sally).
which results in a refutation; or of the form:
←newborn(simon).
which fails since simon E-uniﬁes neither with sally nor with bruce.
By analogy to SLD-resolution all (complete) SLDE-derivations under a given compu-
tation rule may be depicted in a single SLDE-tree (cf. Figure 13.3). Notice in contrast
to SLD-trees, that the root of the tree has two children despite the fact that the deﬁ-
nition of proud/1 contains only one clause. Since the complete set of E-uniﬁers of two
terms may be inﬁnite, a node in the SLDE-tree may have inﬁnitely many children —
something which is not possible in ordinary SLD-trees. This, of course, may cause op-
erational problems since a breadth-ﬁrst traversal is, in general, not suﬃcient for ﬁnding
all refutations in the SLDE-tree. However, soundness and completeness results sim-
ilar to those for SLD-resolution can and have been proved also for SLDE-resolution
described above.

212
Chapter 13:
Logic Programs with Equality
Exercises
13.1 Consider the equations in Example 13.3. Prove that {X/s(0), Y/0} is an E-
uniﬁer of sum(s(X), Y ) and s(s(0)).
13.2 Show that the inference rules in Figure 13.1 are sound. Try to prove that they
are complete!
13.3 Consider the following equations:
append(nil, X)
.=
X
append(cons(X, Y ), Z)
.=
cons(X, append(Y, Z))
Prove that append(X, cons(b, nil)) and cons(a, cons(b, nil)) are E-uniﬁable.
13.4 Prove that two terms, s and t, are
?-uniﬁable iﬀthere is some substitution θ
such that sθ and tθ are syntactically identical.

Chapter 14
Constraint Logic Programming
The following program (which describes the property of being a list whose elements
are sorted in ascending order) is intended to illustrate some shortcomings of SLD-
resolution as previously presented:
sorted([ ]).
sorted([X]).
sorted([X, Y |Xs]) ←X ≤Y, sorted([Y |Xs]).
Consider the query “Are there integers X, Y and Z, such that the list [X, Y, Z] is
sorted?”. The query may be formalized as a goal:
←sorted([X, Y, Z]).
(G0)
SLD-resolution, as described in Chapter 3, attempts to construct a counter-example
— a substitution θ such that P ∪{∀(¬sorted([X, Y, Z])θ)} is unsatisﬁable. If such a
counter-example can be constructed, then most Prolog systems present the answer as
a set of variable bindings, e.g. {X/1, Y/2, Z/3}. This may be interpreted as follows:
∀(X .= 1 ∧Y .= 2 ∧Z .= 3 ⊃sorted([X, Y, Z]))
Now the goal G0 may be reduced to:
←X ≤Y, sorted([Y, Z]).
(G1)
In a Prolog implementation this would lead to a run-time error since arithmetic tests
can be made only if the arguments are instantiated. This could easily be repaired by
imagining an inﬁnite set of facts of the form 0 ≤0, 0 ≤1, . . . Unfortunately this would
lead to an inﬁnite number of answers to the original query. Assume instead that the
interpreter is clever enough to realize that X ≤Y has at least one solution. Then the
second subgoal of G1 may be selected instead, in which case G1 is reduced to:
←X ≤Y, Y ≤Z, sorted([Z]).
(G2)
213

214
Chapter 14:
Constraint Logic Programming
Under the assumption that the interpreter is intelligent enough to realize that ∃(X ≤
Y ∧Y ≤Z) is satisﬁable, the ﬁnal recursive call can be eliminated:
←X ≤Y, Y ≤Z.
(G3)
If ∃(X ≤Y ∧Y ≤Z) is satisﬁable, then G3 — i.e. ∀¬(X ≤Y ∧Y ≤Z) — is
unsatisﬁable. Thus, G0 has a refutation. Moreover, X ≤Y, Y ≤Z may be viewed as
an answer to G0:
∀(X ≤Y ∧Y ≤Z ⊃sorted([X, Y, Z]))
The example illustrates two desirable extensions of logic programming. First the use
of dedicated predicate symbols (in our case ≤) whose semantics are built into the
interpreter rather than deﬁned by the user. Second the extension of the notion of an
answer not just to include equations. These extensions have spawned a number of new
logic programming languages incorporating various built-in domains, operations and
relations. They are all instances of a more general scheme known as constraint logic
programming (CLP). This chapter surveys the theoretical foundations of constraint
logic programming languages and discusses some speciﬁc instances of the scheme.
14.1
Logic Programming with Constraints
In the previous chapter logic programming was extended with a dedicated predicate
symbol .=, always interpreted as the identity relation. Constraint logic programming
languages generalize this idea by allowing also other dedicated interpreted predicates,
function symbols and constants (in addition to the uninterpreted symbols). Hence, a
CLP language CLP(D) is parameterized by an interpretation D of certain symbols in
the language.
Deﬁnition 14.1 (Constraint logic program) A constraint logic program is a ﬁnite
set of clauses:
A0 ←C1, . . . , Cm, A1, . . . , An
(m, n ≥0)
where C1, . . . , Cm are formulas built from the interpreted alphabet (including vari-
ables, quantiﬁers and logical connectives) and A0, . . . , An are atoms with uninterpreted
predicate symbols.
The formulas C1, . . . , Cm are called constraints. In all our examples, a constraint will
be an atomic formula with an interpreted predicate symbols. All CLP languages are
assumed to contain the predicate .= which is always interpreted as identity.
Let Z be an interpretation of numerals such as 0, 1, . . ., function symbols such
as +, −, . . . and predicates such as .=, <, ≤, . . . Assume that |Z| =
Z (the integers)
and that all symbols have their usual interpretation. (For instance, +Z is integer
addition.) Then the following is a CLP(Z) program with the uninterpreted constant
[ ], the functor ./2 and the predicate symbol sorted/1:
sorted([ ]).
sorted([X]).
sorted([X, Y |Xs]) ←X ≤Y, sorted([Y |Xs]).

14.2 Declarative Semantics of CLP
215
R1
R2
d
d
≡
R1 + R2
d
d
R1
R2
d
d
≡
R1 ∗R2
R1 + R2
d
d
Figure 14.1: Equivalent nets
Similarly, let R be an interpretation of the standard arithmetic operators and relations
(including .=) over the reals (i.e. |R| =
R). Then the following is a CLP(R) program
that describes the relation between some simple electrical circuits and their resistance:
res(r(R), R).
res(cell(E), 0).
res(series(X, Xs), R + Rs) ←
res(X, R), res(Xs, Rs).
res(parallel(X, Xs), R ∗Rs/(R + Rs)) ←
res(X, R), res(Xs, Rs).
The program uses the uninterpreted functors r/1, cell/1, series/2, parallel/2 and the
predicate symbol res/2. The clauses express elementary electrical laws such as those
depicted in Figure 14.1.
Finally, let H be a Herbrand interpretation. That is, |H| = UP and each ground
term is interpreted as itself. The only pre-deﬁned predicate symbol is the equality.
The following is a CLP(H) program:
append(X, Y, Y ) ←X .= [ ].
append(X, Y, Z) ←X .= [U|V ], Z .= [U|W], append(V, Y, W).
In Section 14.4 more examples of CLP languages and CLP programs will be presented.
However, ﬁrst we consider the declarative and operational semantics of the general CLP
scheme.
14.2
Declarative Semantics of CLP
Given a speciﬁc CLP language CLP(D), there are several alternative approaches to
deﬁne the declarative meaning of a CLP(D) program P.
One possibility is to as-
sume that there is a so-called background theory ThD with a unique model, D, in
which case the declarative semantics of P can be deﬁned in terms of classical models
of P ∪ThD. Unfortunately, there are interpretations D which cannot be uniquely
axiomatized in predicate logic. Another approach that is sometimes used is to deﬁne
the declarative meaning of P in terms of a unique classical model (similar to the least
Herbrand model) deﬁned by a generalized TP -operator. The approach used here is
an intermediate one — similar to that of the previous chapter — where a subset of

216
Chapter 14:
Constraint Logic Programming
all classical interpretations are taken into account. Namely those that interpret the
pre-deﬁned symbols in accordance with D.
Consider a CLP language CLP(D). A D-interpretation is an interpretation I which
complies with D on the interpreted symbols of the language:
Deﬁnition 14.2 (D-interpretation) A D-interpretation is an interpretation I such
that |D| ⊆|I| and for all interpreted constants c, functors f/n and predicates p/n
(except .= /2):
• cI = cD;
• fI(d1, . . . , dn) = fD(d1, . . . , dn) for all d1, . . . , dn ∈|D|;
• ⟨d1, . . . , dn⟩∈pI iﬀ⟨d1, . . . , dn⟩∈pD.
As pointed out above .= is always assumed to be contained in the language and always
denotes the identity relation. The notion of logical consequence can now be modiﬁed
taking into account D-interpretations only:
Deﬁnition 14.3 (D-model) A D-interpretation which is a model of a set P of closed
formulas is called a D-model of P.
Deﬁnition 14.4 (Logical consequence) A formula F is a logical D-consequence of
a CLP(D)-program P (denoted P, D |= F) iﬀevery D-model of P is a D-model of
F.
If P is the sorted/1-program then:
P, Z |= ∀(X ≤Y ∧Y ≤Z ⊃sorted([X, Y, Z]))
The notation D |= F is used when F is true in every D-model. For instance:
Z |= ∃(X ≤Y ∧Y ≤Z)
H |= ∃(X .= f(Y ) ∧Y .= a)
14.3
Operational Semantics of CLP
This section describes a class of abstract execution strategies of CLP programs based
on the notion of derivation tree introduced in Section 3.6. Recall that a derivation tree
is a tree built from elementary trees that represent (renamed) program clauses (and
an atomic goal) such as:
sorted([X0, Y0|Z0])
   @
@
@
X0 ≤Y0
sorted([Y0|Z0])
sorted([ ])
sorted([X0])

14.3 Operational Semantics of CLP
217
sorted([X, Y, Z])
.=
sorted([X0, Y0|Z0])





H
H
H
H
H
X0 ≤Y0
sorted([Y0|Z0])
.=
sorted([X1, Y1|Z1])





H
H
H
H
H
X1 ≤Y1
sorted([Y1|Z1])
Figure 14.2: Incomplete derivation tree of ←sorted([X, Y, Z])
The notion of derivation tree will have to be extended to permit the use of constraints,
such as X0 ≤Y0, in programs. Since interpreted predicate symbols are not allowed in
the head of any clause a constraint will always appear in the position of a leaf in a tree.
A derivation tree is said to be complete if all of its leaves are of the form
or labelled by
constraints. A complete derivation tree is also called a proof tree. Figure 14.2 depicts
an (incomplete) derivation tree of the goal ←sorted([X, Y, Z]). The tree can be made
complete by combining the rightmost leaf with one of the following elementary trees:
(i)
sorted([ ])
(ii)
sorted([X2])
A derivation tree has an associated set of equalities (the labels of the internal nodes)
and constraints. This set will be called the constraint store. For instance, the deriva-
tion tree in Figure 14.2 has the following constraint store:
{[X, Y, Z] .= [X0, Y0|Z0], X0 ≤Y0, [Y0|Z0] .= [X1, Y1|Z1], X1 ≤Y1}
(†)
We are particularly interested in constraint stores that are satisﬁable:
Deﬁnition 14.5 (Satisﬁable constraint store) A constraint store {C1, . . . , Cn} is
said to be satisﬁable iﬀD |= ∃(C1 ∧· · · ∧Cn).
The constraint store (†) is satisﬁable. So is the constraint store obtained by combin-
ing the derivation tree in Figure 14.2 with the elementary tree (ii). However, when
combined with (i) the resulting constraint store is unsatisﬁable (since [X1] .= [ ] is not
true in every Z-interpretation).
In what follows we assume the existence of a (possibly imperfect) decision pro-
cedure sat(·) which checks if a constraint store is satisﬁable.
If sat({C1, . . . , Cn})
succeeds (i.e. returns true) then the store is said to be consistent. Ideally, satisﬁability
and consistency coincide in which case sat(·) is said to be complete (or categorical).
However, in the general case it is not possible or even desirable to employ a complete

218
Chapter 14:
Constraint Logic Programming
sorted([X, Y ])
.=
sorted([X0, Y0|Z0])





H
H
H
H
H
X0 ≤Y0
sorted([Y0|Z0])
.=
sorted([X1])
Figure 14.3: Proof tree of ←sorted([X, Y ])
satisﬁability check. In such cases, it is usually required that the check is conservative.
That is to say:
if D |= ∃(C1 ∧· · · ∧Cn) then sat({C1, . . . , Cn}) succeeds
Thus, if the procedure fails (i.e. returns false) then the constraint store must be unsat-
isﬁable. This is typically achieved by checking the satisﬁability only of a subset of the
constraints in the store. This is the case in many CLP languages involving arithmetic
constraints — the satisﬁability check is complete as long as the arithmetic constraints
are linear. Non-linear constraints (such as X2 .= Y ) are not checked at all unless they
can be simpliﬁed into linear constraints.
Complete derivation trees with satisﬁable constraint stores are of particular interest
since they represent answers to the initial goal. However, the constraint store usually
contains a large number of free variables which do not appear in the initial goal. Such
variables are called local variables.
Since the bindings of local variables are of no
direct relevance they can be projected away (cf. computed answer substitutions) by
existential quantiﬁcation:
Deﬁnition 14.6 (Answer constraint) Let ←A be an atomic goal with a complete
derivation tree and a satisﬁable constraint store {C1, . . . , Cn}. If X is the set of all
local variables in {C1, . . . , Cn} then ∃X(C1 ∧· · · ∧Cn) is called a (computed) answer
constraint.
The answer constraint (or an equivalent simpliﬁed expression) can be viewed as an
answer to the initial goal. However, in practice the satisﬁability check may be incom-
plete, in which case the following weaker notion of conditional answer may be used
instead:
Deﬁnition 14.7 (Conditional answer) Let ←A be an atomic goal with a complete
derivation tree and a satisﬁable constraint store {C1, . . . , Cn}. Then ∀((C1∧· · ·∧Cn) ⊃
A) is called a conditional answer.
The goal ←sorted([X, Y ]) has a complete derivation tree depicted in Figure 14.3. The
associated constraint store is satisﬁable. Hence, the following is a conditional answer:

14.3 Operational Semantics of CLP
219
sorted([X, Y, Z])





H
H
H
H
H
X ≤Y
sorted([Y, Z])





H
H
H
H
H
Y ≤Z
sorted([Z])
Figure 14.4: Simpliﬁed derivation tree of ←sorted([X, Y, Z])
∀(([X, Y ] .= [X0, Y0|Z0] ∧X0 ≤Y0 ∧[Y0|Z0] .= [Y0]) ⊃sorted([X, Y ]))
This is obviously not a very informative answer. Fortunately it is usually possible to
eliminate or simplify the constraints. First note that a conditional answer may also
be written as follows:
∀(∃X(C1 ∧· · · ∧Cn) ⊃A)
where X is the set of all local variables.
This means that all local variables are
existentially quantiﬁed on the level of the constraints. It is usually possible to eliminate
or simplify at least constraints involving local variables. Simpliﬁcation is needed not
only for the purpose of producing readable answers, but it is often necessary to simplify
the store in order to avoid having to check the satisﬁability of the whole store when new
constraints are added. Simpliﬁcation, usually amounts to transforming the constraints
into some kind of canonical form, such as solved form. It is normally required that
the new store S ′ is equivalent to the old store S. That is:
D |= ∀(S ↔S ′)
Many of the transformations are of course domain dependent (e.g. that X ≤Y, Y ≤X
can be replaced by X .= Y ). However, some simpliﬁcations are always possible —
the constraint store can be divided into equalities over uninterpreted symbols (and
variables) and other constraints involving interpreted symbols (and variables). The
former are called free constraints and the latter built-in constraints. (Equations such
as X .= [3 + 3] which mix interpreted and uninterpreted symbols may be viewed as
shorthand for the free constraint X .= [Y ] and the built-in constraint Y .= 3 + 3.) If
a constraint store is satisﬁable, it is always possible to transform the free constraints
into solved form. For instance, (†) can be transformed into the equivalent constraint
store:
{X0 .= X, Y0 .= Y, Z0 .= [Z], X1 .= Y, Y1 .= Z, Z1 .= [ ], X0 ≤Y0, X1 ≤Y1}
Such a store can be simpliﬁed further; all equations X .= t where X is a local variable
can be removed provided that all occurrences of X in the store and in the tree are
replaced by t.
Hence, the derivation tree in Figure 14.2 can be simpliﬁed to the
derivation tree in Figure 14.4 and the constraint store (†) can be simpliﬁed into:
{X ≤Y, Y ≤Z}

220
Chapter 14:
Constraint Logic Programming
which is clearly satisﬁable in Z (and thus, consistent provided that the check is con-
servative). Similarly, the conditional answer:
∀(([X, Y ] .= [X0, Y0|Z0] ∧X0 ≤Y0 ∧[Y0|Z0] .= [Y0]) ⊃sorted([X, Y ]))
may be simpliﬁed into:
∀(X ≤Y ⊃sorted([X, Y ]))
The notions of tree construction, checking of satisﬁability (i.e. consistency) and sim-
pliﬁcation are the basis of the operational semantics of many CLP languages. From
an abstract point of view a computation may be seen as a sequence of transitions:
⟨T0, S0⟩
 ⟨T1, S1⟩
 ⟨T2, S2⟩
 · · ·
over a space of computation states consisting of pairs of derivation trees and constraint
stores (and the additional computation state fail representing a failed derivation). A
computation starts with a computation state where T0 is a derivation tree representing
the initial (atomic) goal ←A and S0 is an empty constraint store. The only available
transitions are the following ones:
• ⟨T, S⟩
E
 ⟨T ′, S ′⟩if T can be extended into T ′ by combining a leaf labelled by
Ai with an elementary tree whose root is B0. Moreover, S ′ = S ∪{Ai .= B0};
• ⟨T, S⟩
C
 ⟨T, S⟩if sat(S) = true;
• ⟨T, S⟩
C
 fail if sat(S) = false;
• ⟨T, S⟩
S
 ⟨T ′, S ′⟩if T and S can be simpliﬁed into T ′ and S ′.
Diﬀerent CLP systems use diﬀerent strategies when applying these transitions. At
one end of the spectrum one may imagine a strategy where extension-transitions are
applied until the tree is complete, after which simpliﬁcation and satisﬁability-checking
are performed. Hence, computations are of the form:
•
E
 •
E
 · · ·
E
 •
E
 •
S
 •
C
 •
Such a lazy approach runs the risk of entering inﬁnite loops since failure due to an
unsatisﬁable constraint store might not be detected. On the other hand, the constraint
store is checked for satisﬁability only once.
At the other end of the spectrum one may imagine a strategy where simpliﬁcation
and satisﬁability-checking take place after each extension of the tree:
•
E
 •
S
 •
C
 •
E
 •
S
 •
C
 · · ·
E
 •
S
 •
C
 •
Such an eager strategy has a much improved termination behaviour compared to the
lazy approach above. However, checking for satisﬁability is usually more expensive
than in the lazy strategy. With the eager strategy it is vital that the constraint store
can be checked incrementally to avoid computational overhead. Most CLP systems
seem to employ an eager strategy. This is often combined with a Prolog-like depth

14.3 Operational Semantics of CLP
221
res(series(r(R), r(R)), 20)
.=
res(series(X0, Xs0), R0 + Rs0)





H
H
H
H
H
res(X0, R0)
.=
res(r(R1), R1)
res(Xs0, Rs0)
.=
res(r(R2), R2)
Figure 14.5: Proof tree of ←res(series(r(10), r(R)), 30)
sorted([3, X, 2])





H
H
H
H
H
3 ≤X
sorted([X, 2])





H
H
H
H
H
X ≤2
sorted([2])
Figure 14.6: Derivation tree with unsatisﬁable constraints
ﬁrst search using chronological backtracking in order to handle the non-determinism
that arise due to the extension-transition.
To illustrate the lazy strategy consider the goal ←res(series(r(R), r(R)), 20) and
derivation tree in Figure 14.5. The tree can be constructed by means of three extension-
transitions. The associated constraint store of the tree looks as follows:

series(r(R), r(R)) .= series(X0, Xs0),
20 .= R0 + Rs0, X0 .= r(R1), R0 .= R1, Xs0 .= r(R2), Rs0 .= R2

This store can be simpliﬁed into:
{20 .= R + R}
Which is clearly satisﬁable. Using domain knowledge the store can be further simpliﬁed
yielding the conditional answer:
∀(R .= 10 ⊃res(series(r(R), r(R)), 20))
Next consider the goal ←sorted([3, X, 2]). By an eager strategy it can be detected
already after two “cycles” that the tree has an unsatisﬁable constraint store {3 ≤
X, X ≤2} (cf. Figure 14.6). A lazy strategy may get stuck in an inﬁnite process of
tree construction and may never get to the point of checking the satisﬁability of the
store.

222
Chapter 14:
Constraint Logic Programming
sorted([X, Y, X])





H
H
H
H
H
X ≤Y
sorted([Y, X])





H
H
H
H
H
Y ≤X
sorted([X])
Figure 14.7: Proof tree of ←sorted([X, Y, X])
Finally consider the goal ←sorted([X, Y, X]).
Using either a lazy or an eager
strategy the simpliﬁed proof tree in Figure 14.7 can be constructed. The corresponding
constraint store {X ≤Y, Y ≤X} is clearly satisﬁable.
The store can be further
simpliﬁed into the conditional answer:
∀(X .= Y ⊃sorted([X, Y, X]))
by exploiting domain knowledge.
The execution scheme described above can be shown to be sound:
Theorem 14.8 (Soundness) Let P be a CLP(D)-program and ←A an atomic goal.
If ∀((C1 ∧· · · · · · Cn) ⊃A) is a conditional answer of ←A then P, D |= ∀((C1 ∧· · · ∧
Cn) ⊃A).
The execution scheme can also be shown to be complete and generalized to negation
as ﬁnite failure. However, for this discussion, which requires the introduction of a
number of auxiliary deﬁnitions, see Jaﬀar and Maher (1994).
14.4
Examples of CLP-languages
This section surveys some of the most popular constraint domains found in existing
CLP systems:
• Boolean constraints;
• Numerical constraints over integers, rational numbers or reals;
• String constraints;
• Finite and inﬁnite tree constraints.
It should be noted that most CLP systems come with more than one constraint do-
main. For instance, Prolog III supports constraints over Booleans, rational numbers,
strings and inﬁnite trees. CHIP contains constraints over ﬁnite domains, Booleans and
rational numbers. CLP(BNR) handles constraints involving Booleans and intervals of
natural numbers and reals.

14.4 Examples of CLP-languages
223
Source
Gate
Drain
n-switch MOS
Source
Gate
Drain
p-switch MOS
x
y
z
1
0
tmp
Figure 14.8: Xor-gate in MOS technology
Boolean constraints
Many CLP systems (e.g. CHIP, CAL, CLP(BNR), Prolog III and SICStus Prolog) are
equipped with Boolean constraints. Such a CLP(B) language has a binary domain
|B| = {true, false} and the language typically provides:
• two interpreted constants 0, 1 such that 0B = false and 1B = true;
• function symbols such as ∧, ¬, ∨, . . . with the standard interpretation;
• predicates such as .=, ̸=, . . .
Boolean constraints with more than two values are also available in some systems.
Boolean constraints are useful in many contexts, e.g. for modelling digital circuits.
The following example is due to Dincbas et.al. (1988).
Consider the circuit depicted in Figure 14.8. The circuit is a schematic model of an
xor-gate with inputs x and y and the output z. The gate is built from mos-transistors
of which there are two kinds — n-mos and p-mos (also depicted in Figure 14.8). The
transistors have three connections usually referred to as the drain (D), source (S) and
gate (G). From the logical point of view the transistors may be viewed as binary
switches with the following (Boolean) relationship between D, S and G:
n-mos:
D ∧G
.=
G ∧S
p-mos:
D ∧¬G
.=
¬G ∧S
In a CLP(B) language the circuit in Figure 14.8 can be described as follows:
xor(X, Y, Z) ←
pswitch(Tmp, 1, X),
nswitch(0, Tmp, X),
pswitch(Z, X, Y ),
nswitch(Z, Tmp, Y ),
nswitch(Z, Y, Tmp),
pswitch(Z, Y, X).

224
Chapter 14:
Constraint Logic Programming
nswitch(S, D, G) ←
D ∧G .= G ∧S.
pswitch(S, D, G) ←
D ∧¬G .= ¬G ∧S.
This program may be used to verify that the design in Figure 14.8 is an xor-gate by
giving the goal clause:
←xor(X, Y, Z).
A system such as SICStus Prolog (version 2.1) which has an interpreted functor ⊕
denoting the operation of exclusive or, returns the conditional answer:
∀(X .= Y ⊕Z ⊃xor(X, Y, Z))
which proves that the circuit is indeed correct.
Numerical constraints
Most CLP systems support constraints over a numerical domain. However, constraints
over the integers are diﬃcult to handle eﬃciently and, as a consequence, most systems
support constraints only over the reals (CLP(R)) or the rational numbers (CLP(Q)).
Diﬀerent systems support diﬀerent operations and relations — some CLP languages,
such as CLP(BNR), support arithmetic operations over intervals. Some systems sup-
port only linear equalities, inequalities and disequalities. That is, constraints that may
be written:
cnxn + cn−1xn−1 + · · · + c1x1 + c0

0
where
 ∈{ .=, <, ≤, ̸=} and ci are constants. Systems that permit non-linear con-
straints usually employ an incomplete satisﬁability check which does not take non-
linear constraints into account unless they can be simpliﬁed into linear equations. The
algorithms for checking satisﬁability and for simpliﬁcation of the built-in constraints
often rely on techniques from Operations Research — such as Gauss elimination and
the simplex method — and Artiﬁcial Intelligence. For an introduction to implemen-
tation of various CLP languages, see Jaﬀar and Maher (1994).
Consider the problem to position ﬁve queens on a ﬁve-by-ﬁve chess-board so that no
queen attacks another queen. (Two queens attack one another iﬀthey are on the same
row, column or diagonal.) The program given below should be expressible in any CLP
system that supports linear equations and disequations over the reals, the integers or
the rational numbers.
Before presenting the solution some general observations should be made:
• There must be exactly one queen in each column of the board. Hence, all solu-
tions can be represented by a list of length ﬁve. Moreover, there must be exactly
one queen in each row of the board. This restriction can be imposed by requir-
ing that the solution is a permutation of the list [1, 2, 3, 4, 5]. (For instance, the
solution in Figure 14.9 can be represented by the list [5, 3, 1, 4, 2].) With these
restrictions it is suﬃcient to check that each diagonal of the board contains at
most one piece;

14.4 Examples of CLP-languages
225
Figure 14.9: Five-queens problem
• If a queen in column m + n attacks a queen in column m, then the attack is
mutual. Hence, a board is “attack-free” if no queen is on the same diagonal as
one of the queens to its right.
The two observations can now be formalized as follows:
ﬁve queens(Board) ←
safe(Board), perm(Board, [1, 2, 3, 4, 5]).
safe([ ]).
safe([X|Y ]) ←
noattack(X, 1, Y ), safe(Y ).
noattack(X, N, [ ]).
noattack(X, N, [Y |Z]) ←
Y ̸= X + N, Y ̸= X −N, noattack(X, N + 1, Z).
perm([ ], [ ]).
perm([X|Y ], W) ←
perm(Y, Z), insert(X, Z, W).
insert(X, Y, [X|Y ]).
insert(X, [Y |Z], [Y |W]) ←
insert(X, Z, W).
To solve the puzzle the user may give the goal clause:
←ﬁve queens([A, B, C, D, E]).
The goal has several conditional answers one of which is:
∀((A .= 5 ∧B .= 3 ∧C .= 1 ∧D .= 4 ∧E .= 2) ⊃ﬁve queens([A, B, C, D, E]))
The ﬁve queens program illustrates an interesting strategy for solving complex prob-
lems. Provided that subgoals are expanded from left to right, the program ﬁrst collects
a store of disequations by expanding safe/1. Note that this process is completely de-
terministic and the objective is to constrain the possible values of the variables A–E.
Then perm/2 generates bindings for the constrained variables.
Our solution is an
instance of a more general strategy sometimes called constrain-and-generate:

226
Chapter 14:
Constraint Logic Programming
solution(X) ←
constrain(X), generate(X).
The constrain-and-generate strategy takes a completely diﬀerent direction than the
generate-and-test strategy usually employed in Prolog:
ﬁve queens(Board) ←
perm(Board, [1, 2, 3, 4, 5]), safe(Board).
Here potential solutions are ﬁrst generated and then tested to check if the constraints
can be completely solved.
Monoids
In addition to Boolean and numerical constraints, Prolog III also supports (a limited
form of) constraints over the monoid S of strings equipped with concatenation and a
neutral element. A CLP(S) language typically includes:
• a set of constants denoting string elements;
• an binary functor ♯denoting the associative operation of concatenation;
• a neutral element [ ].
In a CLP(S) language the reverse program may be written as follows:
reverse([ ], [ ]).
reverse([X] ♯Y, Z ♯[X]) ←reverse(Y, Z).
Equational constraints
The previous CLP language is interesting in that it can easily be axiomatized as a set
of equations. A monoid is completely characterized by the following equations:
X ♯(Y ♯Z)
.=
(X ♯Y ) ♯Z
[ ] ♯X
.=
X
X ♯[ ]
.=
X
Hence, a CLP(S) program P may also be deﬁned as a logic program with the above
equality axioms. Conversely, any logic program P with an equality theory E may be
viewed as a constraint logic program CLP(E) where:
• |E| = (UP /≡E);
• every ground term t is interpreted as t (i.e. {s ∈UP | s ≡E t});
• .= is the identity relation.
As already mentioned, the special case when E =
? is of course also a CLP language
where:
• |E| = UP (the Herbrand universe);
• every ground term is interpreted as itself;

Exercises
227
• .= is the identity relation.
Hence, deﬁnite programs may be viewed as constraint logic programs with equational
constraints over the Herbrand universe. The solved form algorithm (with occur-check)
provides a complete satisﬁability check for deﬁnite programs.
The terms of the Herbrand domain may be viewed as ordered ﬁnite trees. Related
to ﬁnite trees are rational trees. A rational tree is a possibly inﬁnite tree with a ﬁnite
set of subtrees. For instance, f(a, f(a, f(a, . . .))) has only two distinct subtrees, a and
the tree itself. Rational trees can be ﬁnitely represented as a (possibly) cyclic graph:
f
a
One of the ﬁrst CLP languages, Prolog II, employed constraints (equations and dise-
quations) over the rational trees. The solved form algorithm without the occur-check
provides a complete satisﬁability check for rational trees.
Exercises
14.1 Solve the “SEND MORE MONEY” puzzle using logic programs with con-
strains similar to those above. The puzzle consists in associating with each
letter a distinct number from 0 to 9 such that the equation:
S
E
N
D
+
M
O
R
E
M
O
N
E
Y
is satisﬁed.
14.2 Modify the ﬁve-queens program so that it handles chess boards of arbitrary
(quadratic) size.
14.3 Three jars A, B and C contain a total of 1 liter of water. In each time unit
water ﬂows as follows between the jars:
A
B
C
20%
40%
10%
Describe the relation between the initial amount of liquid in the three jars and
the amount after n units of time.

228
Chapter 14:
Constraint Logic Programming

Chapter 15
Query-answering in Deductive
Databases
One of the great virtues of logic programming is that programs have a declarative
semantics which can be understood independently of any particular operational se-
mantics. SLD-resolution is one example of a class of interpreters that can be used to
compute the logical consequences of a deﬁnite program. But also other strategies can
be used. In fact, SLD-resolution has several weaknesses also in the case of an ideal
interpreter. For instance, consider the following deﬁnition of the Fibonacci numbers
(for convenience X + n and n abbreviate the terms sn(X) and sn(0)):
ﬁb(0, 1).
ﬁb(1, 1).
ﬁb(X + 2, Y ) ←ﬁb(X + 1, Z), ﬁb(X, W), add(Z, W, Y ).
Now assume that the following goal clause is given:
←ﬁb(10, X).
The goal reduces to the following:
←ﬁb(9, Z0), ﬁb(8, W0), add(Z0, W0, X).
And selection of the leftmost subgoal yields:
←ﬁb(8, Z1), ﬁb(7, W1), add(Z1, W1, Z0), ﬁb(8, W0), add(Z0, W0, X).
This goal contains two subgoals which are identical up to variable renaming: ﬁb(8, Z1)
and ﬁb(8, W0). In order to resolve the whole goal, both subgoals have to be resolved
leading to duplicate work. As a matter of fact, the number of recursive calls to ﬁb/2
grows exponentially with the size of the input.
229

230
Chapter 15:
Query-answering in Deductive Databases
In this particular case it is better to compute answers to ←ﬁb(10, X) starting from
the base cases: Since ﬁb(0, 1) and ﬁb(1, 1) it must hold that ﬁb(2, 2) and so forth:
· · ·
ﬁb(0, 1)
ﬁb(1, 1)
ﬁb(2, 2)
ﬁb(3, 3)
ﬁb(9, 55) ﬁb(10, 89)
Another problem with SLD-resolution has to do with termination.
Even when no
function symbols are involved and there are only a ﬁnite number of answers to a goal,
SLD-resolution may loop. Consider the goal ←married(X, Y ) and the program:
married(X, Y ) ←married(Y, X).
married(adam, anne).
There are only two answers to the goal. However, the SLD-tree is inﬁnite and Prolog
would not even ﬁnd the answers unless the clauses were swapped.
In Chapter 6 logic programming was advocated as a representation language for
relational databases. But as illustrated above, SLD-resolution is not always the best
mechanism for a query-answering system.
In a database system it is particularly
important to guarantee termination of the query-answering process whenever that is
possible. This chapter considers an alternative inference mechanism for logic programs
which has a much improved termination behaviour than SLD-resolution. It may also
avoid unnecessary recomputations such as those above. Some assumptions which are
often made in the deductive database literature are consciously avoided in our expo-
sition. (In particular, the division of the program into an extensional and intensional
part.)
15.1
Naive Evaluation
SLD-resolution is goal-directed — the starting point of the computation is the goal
and the aim of the reasoning process is to derive a contradiction by rewritings of the
goal. This has several advantages:
• The tree-like structure of the search space lends itself to eﬃcient implementa-
tions, both space- and time-wise;
• By focusing attention on the goal it is possible to avoid some inferences which
are of no importance for the answers to the goal.
A completely diﬀerent approach is to start from what is known to be true — the facts
and the rules of the program — and to (blindly) generate consequences of the program
until the goal can be refuted. (For the sake of simplicity, it will be assumed that all
goals are of the form ←A.) For instance, let P be the program:
married(X, Y ) ←married(Y, X).
married(adam, anne).
Clearly, P |= married(adam, anne). Moreover, since married(adam, anne) is true in
any model of the program it must hold that P |= married(anne, adam). This idea
resembles the immediate consequence operator originally introduced in Chapter 3:

15.1 Naive Evaluation
231
fun naive(P)
begin
x := facts(P);
repeat
y := x;
x := SP (y);
until x = y;
return x;
end
Figure 15.1: Naive evaluation
TP (I) = {A0 | A0 ←A1, . . . , An ∈ground(P) and A1, . . . , An ∈I}
Recall that the least ﬁxed point of this operator (which can be obtained as the limit
of TP ↑n where n ≥0) characterizes the set of all ground atomic consequences of
the program. Hence, the TP-operator can be used for query-answering. However, for
computational reasons it is often more practical to represent Herbrand interpretations
by sets of atoms (ground or non-ground). A “non-ground TP -operator” may be deﬁned
as follows:1
SP (I) = {A0θ | A0 ←A1, . . . , An ∈P and θ ∈solve((A1, . . . , An), I)}
where θ ∈solve((A1, . . . , An), I) if θ is an mgu of {A1 .= B1, . . . , An
.= Bn} and
B1, . . . , Bn are members in I renamed apart form each other and A0 ←A1, . . . , An.
It can be shown that SP is closed under logical consequence. That is, if every atom
in I is a logical consequence of P then so is SP (I). In particular, every atom in
? is
clearly a logical consequence of P. Thus, every atom in SP (?) is a logical consequence
of P. Consequently every atom in SP (SP (?)) is a logical consequence of P and so
forth. This iteration — which may be denoted:
SP ↑0,
SP ↑1,
SP ↑2,
. . .
yields larger and larger sets of atomic consequences. By analogy to the immediate
consequence operator it can be shown that there exists a least set I of atomic formulas
such that SP (I) = I and that this set equals the limit of SP ↑n. An algorithmic
formulation of this iteration can be found in Figure 15.1. (Let facts(P) denote the set
of all facts in P.) The algorithm is often referred to as naive evaluation.
The result of the naive evaluation can be used to answer queries to the program:
If B is an atom in naive(P) renamed apart from A and θ is an mgu of A .= B. Then
θ is an answer to the goal ←A.
Example 15.1 Consider the following transitive closure program:
1For the sake of simplicity it is assumed that SP (I) never contains two atoms which are renamings
of each other.

232
Chapter 15:
Query-answering in Deductive Databases
fun semi-naive(P)
begin
∆x := facts(P);
x := ∆x;
repeat
∆x := ∆SP (x, ∆x);
x := x ∪∆x;
until ∆x =
?;
return x;
end
Figure 15.2: Semi-naive evaluation
path(X, Y ) ←edge(X, Y ).
path(X, Y ) ←path(X, Z), edge(Z, Y ).
edge(a, b).
edge(b, a).
Let xi denote the value of x after i iterations. Then the iteration of the naive-evaluation
algorithm looks as follows:
x0
=
{edge(a, b), edge(b, a)}
x1
=
{edge(a, b), edge(b, a), path(a, b), path(b, a)}
x2
=
{edge(a, b), edge(b, a), path(a, b), path(b, a), path(a, a), path(b, b)}
x3
=
{edge(a, b), edge(b, a), path(a, b), path(b, a), path(a, a), path(b, b)}
The goal ←path(a, X) has two answers: {X/a} and {X/b}.
15.2
Semi-naive Evaluation
As suggested by the name, naive evaluation can be improved in several respects. In
particular, each iteration of the algorithm recomputes everything that was computed
in the previous iteration. That is xi ⊆xi+1. The revised algorithm in Figure 15.2
avoids this by keeping track of the diﬀerence xi \ xi−1 in the auxiliary variable ∆x.
Note ﬁrst that the loop of the naive evaluation may be replaced by:
repeat
∆x := SP (x) \ x;
x := x ∪∆x;
until ∆x =
?;
The expensive operations here is SP (x) \ x which renders the modiﬁed algorithm
even more ineﬃcient than the original one. However, the new auxiliary function call
∆SP (x, ∆x) computes the diﬀerence more eﬃciently:

15.3 Magic Transformation
233
∆SP (I, ∆I) = {A0θ ̸∈I |
A0 ←A1, . . . , An ∈P and
θ ∈solve((A1, . . . , An), I, ∆I)}
where θ ∈solve((A1, . . . , An), I, ∆I) if θ is an mgu of {A1 .= B1, . . . , An .= Bn} and
B1, . . . , Bn are atoms in I renamed apart form each other and A0 ←A1, . . . , An and
at least one Bi ∈∆I.
It can be shown that the algorithm in Figure 15.2 — usually called semi-naive
evaluation — is equivalent to naive evaluation:
Theorem 15.2 (Correctness of semi-naive evaluation) Let P be a deﬁnite pro-
gram, then naive(P) = semi-naive(P).
Example 15.3 The following is a trace of the semi-naive evaluation of the programs
in Example 15.1:
∆x0
=
{edge(a, b), edge(b, a)}
∆x1
=
{path(a, b), path(b, a)}
∆x2
=
{path(a, a), path(b, b)}
∆x3
=
?
The main advantage of the naive and semi-naive approach compared to SLD-resolution
is that they terminate for some programs where SLD-resolution loops. In particular
when no function symbols are involved (i.e. datalog programs).
For instance, the
goal ←path(a, X) loops under SLD-resolution. On the other hand, there are also
examples where the (semi-) naive approach loops and SLD-resolution terminates. For
instance, consider the goal ←ﬁb(5, X) and the following program (extended with the
appropriate deﬁnition of add/3):
ﬁb(0, 1).
ﬁb(1, 1).
ﬁb(X + 2, Y ) ←ﬁb(X + 1, Z), ﬁb(X, W), add(Z, W, Y ).
The SLD-derivation terminates but both the naive and the semi-naive evaluation loop.
The reason is that both naive and semi-naive evaluation blindly generate consequences
without taking the goal into account. However, the fact ﬁb(5, 8) is obtained early on
in the iteration. (In fact, if it was not for the addition it would be computed in the
fourth iteration.)
Both naive and semi-naive evaluation also lend themselves to set-oriented opera-
tions in contrast to SLD-resolution which uses a tuple-at-a-time strategy. The set-
oriented approach is often advantageous in database applications where data may
reside on secondary storage and the number of disk accesses must be minimized.
15.3
Magic Transformation
This section presents a query-answering approach which combines the advantages of
semi-naive evaluation with goal-directedness. The approach amounts to transforming

234
Chapter 15:
Query-answering in Deductive Databases
the program P and a goal ←A into a new program magic(P ∪{←A}) which may be
executed by the naive or semi-naive algorithm.
One of the problems with the semi-naive evaluation is that it blindly generates
consequences which are not always needed to answer a speciﬁc query. This can be
repaired by inserting a “ﬁlter” (an extra condition) into the body of each program
clause A0 ←A1, . . . , An so that (an instance of) A0 is a consequence of the program
only if it is needed in order to compute an answer to a speciﬁc atomic goal.
For the purpose of deﬁning such ﬁlters, the alphabet of predicate symbols is
extended with one new predicate symbol call p for each original predicate symbol
p.
If A is of the form p(t1, . . . , tn) then call(A) will be used to denote the atom
call p(t1, . . . , tn). Such an atom is called a magic template. The basic transformation
scheme may be formulated as follows:
Deﬁnition 15.4 (Magic transformation) Let magic(P) be the smallest program
such that if A0 ←A1, . . . , An ∈P then:
• A0 ←call(A0), A1, . . . , An ∈magic(P);
• call(Ai) ←call(A0), A1, . . . , Ai−1 ∈magic(P) for each 1 ≤i ≤n.
Given an initial goal ←A a transformed clause of the form:
A0 ←call(A0), A1, . . . , An
can be interpreted as follows:
A0 is true if A0 is needed (to answer ←A) and A1, . . . , An are true.
The statement “. . . is needed (to answer ←A)” can also be read as “. . . is called (in a
goal-directed computation of ←A)”. Similarly a clause of the form:
call(Ai) ←call(A0), A1, . . . , Ai−1
can then be understood as follows:
Ai is called if A0 is called and A1, . . . , Ai−1 are true.
Hence, the ﬁrst clause extends each clause of the original program with a ﬁlter as
described above and the second clause deﬁnes when a ﬁlter is true. The magic trans-
formation can be said to encode a top-down computation with Prolog’s computation
rule. In fact, as will be illustrated below there is a close correspondence between the
semi-naive evaluation of the magic program and the SLD-derivations of the original
program.
Example 15.5 Let P be the program in Example 15.1. Then magic(P) is the fol-
lowing program:
path(X, Y ) ←call path(X, Y ), edge(X, Y ).
path(X, Y ) ←call path(X, Y ), path(X, Z), edge(Z, Y ).
edge(a, b) ←call edge(a, b).
edge(b, a) ←call edge(b, a).
call edge(X, Y ) ←call path(X, Y ).
call path(X, Z) ←call path(X, Y ).
call edge(Z, Y ) ←call path(X, Y ), path(X, Z).

15.3 Magic Transformation
235
1: ←path(X, Y ).
2: ←edge(X, Y ).
3: ←path(X, Z0), edge(Z0, Y ).
4:

X=a,
Y =b
5:

X=b,
Y =a
6: ←edge(X, Z0), edge(Z0, Y ).
∞
7: ←edge(b, Y ).
8: ←edge(a, Y ).
9:

X=a,
Y =a
10:

X=b,
Y =b









X
X
X
X
X
X
X
X
X
   @
@
@





H
H
H
H
H





H
H
H
H
H
Figure 15.3: SLD-tree of ←path(X, Y )
For instance, note that the last clause may be read: “edge(Z, Y ) is called if path(X, Y )
is called and path(X, Z) is true”. Now compare this with the recursive clause of the
original program in Example 15.1!
Note that the program in the example does not contain any facts. Hence, no atomic
formula can be a logical consequence of the program. In order to be able to use the
magic program for answering a query the program has to be extended with such a
fact. More precisely, in order to answer an atomic goal ←A the transformed program
must be extended with the fact call(A). The fact may be read “A is called”.
Example 15.6 Consider a goal ←path(X, Y ) to the program in Example 15.1. The
semi-naive evaluation of the transformed program looks as follows:
∆x0
=
{call path(X, Y )}
∆x1
=
{call edge(X, Y )}
∆x2
=
{edge(a, b), edge(b, a)}
∆x3
=
{path(a, b), path(b, a)}
∆x4
=
{call edge(a, Y ), call edge(b, Y ), path(a, a), path(b, b)}
∆x5
=
?
Hence, the evaluation terminates and produces the expected answers: path(a, a),
path(a, b), path(b, a) and path(b, b).
It is interesting to compare the semi-naive evaluation of the magic program with the
SLD-tree of the goal ←path(X, Y ) with respect to the original program.
The selected subgoal in the root of the SLD-tree in Figure 15.3 is path(X, Y ).
Conceptually this amounts to a call to the procedure path/2. In the magic computation
this corresponds to the state before the ﬁrst iteration. The ﬁrst iteration generates the
fact call edge(X, Y ) which corresponds to the selection of the subgoal edge(X, Y ) in
node 2 of the SLD-tree. Simultaneously, path(X, Z0) is selected in node 3. However,

236
Chapter 15:
Query-answering in Deductive Databases
s0
s3
s4
· · ·
sn
s1
s2
Figure 15.4: Duplicate paths
this is not explicitly visible in ∆x1 since call path(X, Y ) and call path(X, Z0) are
renamings of each other. Iteration two yields two answers to the call to edge(X, Y );
namely edge(a, b) and edge(b, a) corresponding to nodes 4 and 5 in the SLD-tree. These
nodes also provide answers to the call path(X, Y ) (and path(X, Z0)) and correspond
to the result of iteration three, and so forth.
The magic approach can be shown to be both sound and complete:
Theorem 15.7 (Soundness of magic) Let P be a deﬁnite program and ←A an
atomic goal. If Aθ ∈naive(magic(P ∪{←A})) then P |= ∀(Aθ).
Theorem 15.8 (Completeness of magic) Let P be a deﬁnite program and ←A
an atomic goal. If P |= ∀(Aθ) then there exists Aσ ∈naive(magic(P ∪{←A})) such
that Aθ is an instance of Aσ.
The magic approach combines advantages of naive (and semi-naive) evaluation with
goal-directedness. In particular, it has a much improved termination behaviour over
both SLD-resolution and naive (and semi-naive) evaluation of the original program P:
• If the SLD-tree of ←A is ﬁnite then naive(magic(P ∪{←A})) terminates;
• If naive(P) terminates, then naive(magic(P ∪{←A})) terminates;
Moreover, the magic approach sometimes avoids repeating computations. Consider
the following program and graph in Figure 15.4:
path(X, Y ) ←edge(X, Y ).
path(X, Y ) ←edge(X, Z), path(Z, Y ).
Even if the SLD-tree of ←path(s0, X) is ﬁnite the tree contains two branches which
are identical up to variable renaming — one that computes all paths from s3 via s0 and
s1 and one branch that computes all paths from s3 via s0 and s2. By using semi-naive
evaluation of the transformed program this is avoided since the algorithm computes a
set of magic templates and answers to the templates.
15.4
Optimizations
The magic transformation described in the previous section may be modiﬁed in various
ways to optimize the query-answering process. We give here a brief account of some
potential optimizations without going too much into technical detail.

15.4 Optimizations
237
Supplementary magic
Each iteration of the naive evaluation amounts to computing:
solve((A1, . . . , An), I)
for each program clause A0 ←A1, . . . , An. This in turn amounts to ﬁnding an mgu of
sets of equations of the form:
{A1 .= B1, . . . , An .= Bn}
If the program contains several clauses with common subgoals it means that the same
uniﬁcation steps are repeated in each iteration of the evaluation. (The same can be
said about semi-naive evaluation.) This is a crucial observation for evaluation of magic
programs as the magic transformation of a clause A0 ←A1, . . . , An gives rise to the
following sub-program:
call(A1) ←call(A0).
call(A2) ←call(A0), A1.
call(A3) ←call(A0), A1, A2.
...
call(An) ←call(A0), A1, A2, . . . , An−1.
A0 ←call(A0), A1, A2, . . . , An−1, An.
Hence, naive and semi-naive evaluation run the risk of having to repeat a great many
uniﬁcation steps in each iteration of the evaluation.
It is possible to factor out the common subgoals using so-called supplementary
predicates
O0, . . . ,
On; Let X be the sequence of all variables in the original clause and
let the supplementary predicates be deﬁned as follows:
O0(X) ←call(A0)
O1(X) ←
O0(X), A1
...
On(X) ←
On−1(X), An
Intuitively,
Oi(X) describes the state of the computation in a goal-directed computa-
tion of A0 ←A1, . . . , An after the success of Ai (or before A1 if i = 0). For instance,
the last clause states that “if
On−1(X) is the state of the computation before calling
An and An succeeds then
On(X) is the state of the computation after An”.
Using supplementary predicates the magic transformation may be reformulated as
follows:
call(Ai+1) ←
Oi(X).
(0 ≤i < n)
A0 ←
On(X).
The transformation increases the number of clauses in the transformed program. It
also increases the number of iterations in the evaluation. However, the amount of work
in each iteration decreases dramatically since the clause bodies are shorter and avoids
much of the redundancy due to duplicate uniﬁcations.
Note that no clause in the new sub-program contains more than two body literals.
In fact, the supplementary transformation is very similar in spirit to Chomsky Normal
Form used to transform context-free grammars (see Hopcroft and Ullman (1979)).

238
Chapter 15:
Query-answering in Deductive Databases
Subsumption
In general we are only interested in “most general answers” to a goal. That is to say,
if the answer A1 is a special case of A2 then we are only interested in A2. (This is
why the deﬁnition of SLD-resolution involves only most general uniﬁers.) In a naive or
semi-naive evaluation it may happen that the set being computed contains two atoms,
A1 and A2, where A1 is an instance of A2 (i.e. there is a substitution θ such that
A1 = A2θ). Then A1 is said to be subsumed by A2. In this case A1 is redundant and
may be removed from the set without sacriﬁcing completeness of the query-answering
process. Moreover, keeping the set as small as possible also improves performance of
the algorithms. In the worst case, redundancy due to subsumption may propagate
leading to an explosion in the size of the set.
From a theoretical perspective it is easy to extend both naive and semi-naive
evaluation with a normalization procedure which removes redundancy from the set.
However, checking for subsumption may be so expensive from the computational point
of view (and is so rarely needed), that it is often not used in practice.
Sideways information passing
As commented the magic transformation presented in Deﬁnition 15.4 encodes a goal-
directed computation where the subgoals are solved in the left to right order. Hence,
given a clause:
A0 ←A1, . . . , An
the transformed program contains a clause:
call(Ai) ←call(A0), A1, . . . , Ai−1
In addition to imposing an ordering on the body atoms, the clause also propagates
bindings of call(A0) and A1, . . . , Ai−1 to call(Ai). Now two objections may be raised:
• The left to right goal ordering is not necessarily the most eﬃcient way of an-
swering a query;
• Some of the bindings may be of no use for call(Ai). And even if they are of use,
we may not necessarily want to propagate all bindings to it.
Consider the following sub-program which checks if two nodes (e.g. in a tree) are on the
same depth. That is, if they have a common ancestor the same number of generations
back.
sd(X, X).
sd(X, Y ) ←child(X, Z), child(Y, W), sd(Z, W).
Note that there is no direct ﬂow of bindings between child(X, Z) and child(Y, W) in
a goal-directed computation. Hence the two subgoals may be solved in parallel. How-
ever, the recursive call sd(X, Z) relies on bindings from the previous two, and should
probably await the success of the other subgoals.
Now, the magic transformation
imposes a linear ordering on the subgoals by generating:

Exercises
239
call child(X, Z) ←call sd(X, Y ).
call child(Y, W) ←call sd(X, Y ), child(X, Z).
call sd(Z, W) ←call sd(X, Y ), child(X, Z), child(Y, W).
In this particular case it would probably be more eﬃcient to emit the clauses:
call child(X, Z) ←call sd(X, Y ).
call child(Y, W) ←call sd(X, Y ).
call sd(Z, W) ←call sd(X, Y ), child(X, Z), child(Y, W).
Intuitively this means that the two calls to child/2 are carried out “in parallel” as
soon as sd/2 is called. The recursive call, on the other hand, goes ahead only if the
two calls to child/2 succeed.
This example illustrates that there are variations of the magic transformation which
potentially yield more eﬃcient programs. However, in order to exploit such variations
the transformation must be parameterized by the strategy for solving the subgoals of
each clause. Which strategy to use relies on the ﬂow of data between atoms in the
program and may require global analysis of the program. Such strategies are commonly
called sip’s (sideways information passing strategies) and the problem of generating
eﬃcient strategies is an active area of research (see Ullman (1989) for further reading).
Exercises
15.1 Transform the following program using Deﬁnition 15.4:
expr(X, Z) ←expr(X, [+|Y ]), expr(Y, Z).
expr([id|Y ], Y ).
Then use naive and semi-naive evaluation to “compute” answers to the goal:
←expr([id, +, id], X).
What happens if the goal is evaluated using SLD-resolution and the original
program?
15.2 Consider the program sd/2 on p. 238 and the following “family tree”:
child(b, a).
child(c, a).
child(d, b).
child(e, b).
child(f, c).
child(g, d).
child(h, d).
child(i, e).
child(j, f).
child(k, f).
Transform the program using (a) magic templates (b) supplementary magic.
Then compute the answers to the goal:
←sd(d, X)

240
Chapter 15:
Query-answering in Deductive Databases

Appendix A
Bibliographical Notes
A.1
Foundations
LOGIC:
Logic is the science of valid reasoning and its history dates back to 300-400
B.C. and the work of Aristotle. His work predominated for over 2000 years until logic
ﬁnally begun to take its current shape around 100 years ago. That is, long before
the era of electronic computers. In this historical perspective it is not surprising that
logic programming, in many ways, builds on fundamentally diﬀerent principles than
most existing (algorithmic) programming languages. In fact, many of the results which
constitute the core of logic programming (including some used in this book) actually
date back to the early 20th century. For instance, the name Herbrand interpretation
is given in honour to the French logician Herbrand. However, the ideas were ﬁrst
introduced around 1920 by Skolem and L¨owenheim. Theorem 2.12 is a consequence
of the so-called Skolem-L¨owenheim theorem.
There are a large number of introductory readings on mathemetical logic. Books
by Shoenﬁeld (1967), van Dalen (1983), Galton (1990) and Mendelson (1987) are rec-
ommended. For readers already familiar with the basic concepts of predicate logic the
book by Boolos and Jeﬀrey (1980) provides a good starting point for further studies.
An account by Davis of the early history of mathematical logic and its inﬂuence on
computer science can be found in the collection of Siekmann and Wrightson (1983a).
With the introduction of electronic computers it was widely believed that it was
only a matter of time before computers were able to reason intelligently by means of
logic. Much research was devoted to this ﬁeld (commonly called automated theorem
proving or automated reasoning) during the 1960s. Many of the most inﬂuential papers
from this era are collected by Siekmann and Wrightson (1983a; 1983b). Good intro-
ductions to theorem proving and diﬀerent kinds of resolution methods are provided
by Chang and Lee (1973) and Robinson (1979). The basis of both of these books, and
for logic programming, is the work of Robinson (1965) where he introduced the notion
241

242
Appendix A: Bibliographical Notes
of uniﬁcation and the resolution principle for predicate logic.
DEFINITE PROGRAMS:
Logic programming emerged with the motivation to
improve the eﬃciency of theorem proving. As already stated the proposed solution
was to take a subset of the language of predicate logic called deﬁnite clauses and to use
the specialized inference rule known as the SLD-resolution principle. Deﬁnite clauses
are sometimes also called Horn clauses after the French logician Horn.
The observation that every deﬁnite programs has a unique minimal Herbrand
model (expressed in the Theorems 2.14, 2.16 and 2.20) originates from van Emden
and Kowalski’s landmark paper (1976). Proofs similar to those provided in Chapter 2
can be found also in Apt (1990) and Lloyd (1987).
The name immediate consequence operator was coined by Clark (1979) and uses
results of the theory of ﬁxed points due to Tarski (1955) and Scott (1976). It was
shown by van Emden and Kowalski (1976) that the least ﬁxed point of TP is identical
to the model-theoretic meaning of deﬁnite programs (Theorem 2.20). A corresponding
result relating the greatest ﬁxed point of TP to the subset of the Herbrand base
whose members ﬁnitely fails (that is, has a ﬁnite SLD-tree without any refutations)
was provided by Apt and van Emden (1982). For a comprehensive account of the
ﬁxed point semantics of deﬁnite programs, see Apt (1990) and Lloyd (1987). Several
alternative ﬁxed point characterizations of logic programs have also been proposed. A
survey is provided by Bossi et al. (1994).
SLD-RESOLUTION:
SLD-resolution is an oﬀspring from SL-resolution which was
ﬁrst described by Kowalski and Kuehner (1972). SLD-resolution was originally called
LUSH-resolution (Linear resolution with Unrestricted Selection for Horn clauses) by
Hill (1974).
However, it was ﬁrst described (without being named) by Kowalski
(1974). The formulation of soundness for SLD-resolution (Theorem 3.20) is due to
Clark (1979). Versions of this proof can be found in Apt (1990), Doets (1994) and
Lloyd (1987). The ﬁrst completeness theorem for SLD-resolution was reported by Hill
(1974) but the formulation of the stronger result given in Theorem 3.22 is due to Clark
(1979). The actual proof is not very diﬃcult and can be found in Apt (1990) and Lloyd
(1987). A much simpliﬁed proof was subsequently presented by St¨ark (1990). See also
Doets (1994). The proof is made possible by representing an SLD-refutation as a tree
closely reminiscent of the derivation trees of Section 3.6.
The core of the resolution principle is the uniﬁcation algorithm. The algorithm
as we know it today is usually attributed to the landmark paper of Robinson (1965).
Although its origin is not entirely clear the concept of uniﬁcation goes back to results
of Herbrand (1967) and Prawitz (1960). However, several alternative deﬁnitions and
algorithms have been proposed as discussed by Lassez, Maher and Marriott (1988).
Some important results related to uniﬁcation are also described by Eder (1985). A gen-
eral introduction to uniﬁcation is provided by Siekmann (1984). Various applications,
implementation techniques and generalizations are discussed by Knight (1989).
Several attempts have been made to come up with uniﬁcation algorithms that are
not (worst case) exponential. Some of these are reported to have (worst case) linear
time complexity (see Martelli and Montanari (1982) or Paterson and Wegman (1978)).
However, the ISO Prolog standard (1995) and most Prolog implementations “solve the
problem” simply by omitting the occur-check. This may in rare cases lead to unsound

A.1 Foundations
243
conclusions. Unfortunately, the problem of checking if occur-check is actually needed
is undecidable. Much research has therefore focused on ﬁnding suﬃcient conditions
when occur-check can be safely omitted (for details see Apt and Pellegrini (1992), Beer
(1988), Chadha and Plaisted (1994), Deransart, Ferrand and T´eguia (1991), Marriott
and Søndergaard (1989) or Plaisted (1984)).
NEGATION:
As discussed in Chapter 2, deﬁnite programs and SLD-resolution
cannot be used to infer negative knowledge. The solution to this shortcoming is similar
to that adopted in relational databases — if something is not inside the deﬁnition of
a relation it is assumed to be outside of the relation. This idea, commonly called the
closed world assumption, is due to Reiter (1978). Clark suggested a weaker notion
called the negation as ﬁnite failure rule (1978). Clark provided a logical justiﬁcation
of the this rule by introducing the notion of completion and showed the soundness
(Theorem 4.4) of the rule. Completeness of negation as ﬁnite failure (Theorem 4.5)
was provided by Jaﬀar, Lassez and Lloyd (1983).
There seems to be no general agreement whether to use the term general or nor-
mal program for logic programs containing negative body literals. Moreover, several
deﬁnitions of SLDNF-resolution can be found in the literature. Many deﬁnitions of
SLDNF-derivations and SLDNF-trees are problematic. For instance, the deﬁnitions
of Lloyd (1987) and Nilsson and Ma luszynski (1990) apply only to a restricted class of
general programs. By a construction similar to the search forest of Bol and Degerstedt
(1993b) Deﬁnition 4.13 avoids such problems. The deﬁnition is similar to that of Apt
and Doets (1994) (see also Doets (1994) or Apt and Bol (1994)), but is less operational
in nature. The proof of the soundness of SLDNF-resolution was provided by Clark
(1978) and can also be found in Lloyd (1987).
As pointed out, SLDNF-resolution is not complete. However, there are several com-
pleteness results for restricted classes of programs. Cavedon and Lloyd (1989) showed
the completeness for a limited class of stratiﬁed programs. Later Stroetmann reported
a more general result (1993).
Fitting (1985) and Kunen (1987; 1989) suggested a
three-valued interpretation of the completion semantics which better corresponds to
the intuition of negation as ﬁnite failure. With the three-valued completion as a basis
Kunen (1989) proved completeness of SLDNF-resolution for allowed programs. Later
St¨ark (1992; 1993) and Drabent (1995a) strengthened these results.
The notion of stratiﬁed programs was introduced by Apt, Blair and Walker (1988).
The notion was also independently put forward by Van Gelder (1988). Both of these
papers build on results by Chandra and Harel (1985). Apt, Blair and Walker showed
that every stratiﬁed program has a well-deﬁned minimal model called the standard
model and in the case of deﬁnite programs it coincides with the least Herbrand model.
Later Przymusinski (1988a; 1988b) extended the class of stratiﬁed programs into locally
stratiﬁed programs and the standard model into the perfect model semantics. Roughly
speaking, a program is locally stratiﬁed if the Herbrand base can be partitioned in such
a way that for every ground instance of each program clause, the head appears in higher
or equal stratum than all positive literals in the body and strictly higher stratum than
negative literals in the body. Unfortunately, the property of being locally stratiﬁed is
undecidable whereas ordinary stratiﬁcation is not.
The notion of well-founded models was introduced by van Gelder, Ross and Schlipf
(1991). The well-founded model coincides with the standard model (resp. the perfect

244
Appendix A: Bibliographical Notes
model) in the case of stratiﬁed (resp. locally stratiﬁed) programs. By allowing partial
(or three-valued) interpretations it applies to arbitrary general programs. Several al-
ternative characterizations of the well-founded semantics can be found in the literature
(see Apt and Bol (1994)). An alternative to the well-founded semantics was proposed
by Gelfond and Lifschitz (1988) who suggested a notion of stable models. The sta-
ble model semantics coincides with perfect model semantics (and thus, well-founded
semantics) in the case of locally stratiﬁed programs. However, in the general case it
assigns a set of minimal models to a programs.
There is no well-established equivalent of SLDNF-resolution for computing answers
to goals with the well-founded semantics (or stable model semantics) as the underlying
declarative semantics. Przymusinski (1989) and Ross (1992) suggested a notion of
(global) SLS-resolution which is an idealistic and non-eﬀective procedural semantics for
computing answers to goals using well-founded semantics as the underlying declarative
semantics. An alternative approach based on the notion of search forest was proposed
by Bol and Degerstedt (1993a). A similar idea was independently suggested by Chen
and Warren (1993).
One of the main shortcomings of the negation as ﬁnite failure rule is the disability
to fully handle existentially quantiﬁed negative subgoals — that is, queries which
intuitively read “is there an X such that ¬p(X)?”. This restriction has motivated a
number of techniques with the ability of producing answers (roughly speaking, bindings
for X) to this type of goals. This area of research is commonly called constructive
negation. For further reading see Chan (1988), Drabent (1995b) or Ma luszy´nski and
N¨aslund (1989).
As pointed out in Chapter 3 negation as implemented in Prolog, is unsound. In
particular, the subgoal ¬A fails when the goal ←A succeeds. In a sound implementa-
tion it is necessary to check that the computed answer substitution for ←A is empty.
Still there are implementations such as NU-Prolog (cf. Thom and Zobel (1987)), which
incorporate sound versions of negation. In addition NU-Prolog allows variables to be
existentially quantiﬁed within the scope of “¬”. This, and other features of NU-Prolog,
are reported by Naish (1985) and (1986).
For a ﬁne and extensive survey of negation in logic programming see Apt and Bol
(1994). Surveys are also provided e.g. by Shepherdson (1988).
CUT AND ARITHMETIC:
Cut and built-in arithmetic are part of the ISO
Prolog standard (1995). Our discussion on the eﬀects of cut is somewhat simpliﬁed
since it does not take into account the eﬀects of combining cut with other built-in
predicates of Prolog. For an extensive treatment of diﬀerent uses and eﬀects of cut
see O’Keefe (1990). Several logic programming languages have tried to introduce a
cleaner approach to built-in arithmetic than that employed in the Prolog standard.
For details, see e.g. Ma luszy´nski et al. (1993).
A.2
Programming in Logic
DEDUCTIVE DATABASES:
As pointed out in Chapter 6 there are many sim-
ilarities between relational databases (as ﬁrst deﬁned by Codd (1970)) and logic pro-
gramming in that they are both used to describe relations between objects. There has

A.2 Programming in Logic
245
been a growing interest in the database community to use logic programs as a lan-
guage for representing data, integrity constraints, views and queries in a single uniform
framework. Several survey articles of the ﬁeld of deductive databases are available.
For instance, both Gallaire, Minker and Nicolas (1984) and Reiter (1984) provide
extensive comparison between logic and relational databases, but use a richer logical
language than that normally found in the logic programming literature. Ullman (1988)
and (1989) provides a thorough introduction both to traditional database theory and
the use of logic programming for describing relational databases. Minker (1988) gives
a historical account of the ﬁeld of deductive databases and discusses its relation to
negation.
Several suggestions have been put forward on how to increase the expressive power
of deductive databases. In a series of papers Lloyd and Topor (1984; 1985; 1986)
suggest several extensions. The main idea is to extend logic programs to include a
notion of program clauses which are formulas of the form ∀(A ←F) where A is an
atom and F is an arbitrary typed formula of predicate logic. It is shown how to compile
program clauses into Prolog programs. They also raise the problem of how to handle
integrity constraints. Roughly speaking, an integrity constraint is a formula which
constrains the information which may be stored in the database. The validity of the
constraints must be checked every time updates are made to the database. Lloyd,
Sonenberg and Topor (1987) provide a method for checking the validity of integrity
constraints in the case of stratiﬁed databases. A recapitulation of these results is also
available in Lloyd (1987).
The notion of integrity constraints concerns updates in databases. The semantics
of database updates is a major problem, not only in logic programming systems, but
in any system which must maintain consistent information. The problems become
particularly diﬃcult when the updates are made while making deductions from the
database, since adding information to or deleting information from the database may
invalidate conclusions already made. These are problems which have engaged quite a
number of researchers in diﬀerent ﬁelds. A common suggestion is to treat the database
as a collection of theories and to specify, explicitly, in which theory to prove subgoals.
Some alternative approaches have been suggested by Bacha (1987), Bowen (1985),
Bowen and Kowalski (1982), Hill and Lloyd (1988b) and Warren (1984).
RECURSIVE DATA-STRUCTURES:
Most of the programs in Chapter 7 (to-
gether with programs operating on other recursive data structures) can be found in
Prolog monographs such as Clocksin and Mellish (1994), Sterling and Shapiro (1994)
and O’Keefe (1990). Diﬀerence lists were discussed together with several other data-
structures by Clark and T¨arnlund (1977). Ways of transforming programs operating
on lists into programs operating on diﬀerence lists were discussed by Hansson and
T¨arnlund (1981), Zhang and Grant (1988) and Marriott and Søndergaard (1988).
META-LOGICAL REASONING:
The idea to describe a language in itself is
not new. Many of the most important results on computability and incompleteness of
predicate logic are based on this idea. For instance, G¨odel’s incompleteness theorem
and the undecidability of the halting problem (see e.g. Boolos and Jeﬀrey (1980)
for a comprehensive account of these results).
Bowen and Kowalski (1982) raised
the possibility of amalgamating the object- and meta-language in the case of logic

246
Appendix A: Bibliographical Notes
programming. The self-interpreter based on the ground representation presented in
Chapter 8 is inﬂuenced by their interpreter. Extensions of Bowen’s and Kowalski’s
ideas are reported by Bowen and Weinberg (1985) and Bowen (1985).
The self-interpreter in Example 8.7 which works on a nonground representation
seems to have appeared for the ﬁrst time in Pereira, Pereira and Warren (1979).
O’Keefe (1985) described an extension of the self-interpreter which handles cut. See
also O’Keefe (1990).
Hill and Lloyd (1988a) pointed out several deﬁciencies of existing attempts to
formalize meta-level reasoning in Prolog. Their solution is to use a language of typed
predicate logic and a ground representation of the object language. The solution makes
it possible to give a clean logical meaning to some of Prolog’s built-in predicates. Hill
and Lloyd (1988b) also provide a clean semantics for the predicates assert/1 and
retract/1. These ideas were incorporated in the logic programming language G¨odel
(see Hill and Lloyd (1994) for details).
Meta-logical reasoning is closely related to the area of program transformation.
On the one hand program transformation is a special case of meta-level reasoning.
On the other hand program transformation can be used to improve the eﬃciency of
meta-level programs. In particular partial evaluation plays an important role here.
The notion of partial evaluation was suggested in the 1970s and was introduced into
logic programming by Komorowski (1981).
The approach has gained considerable
interest because of its ability to “compile away” the overhead introduced by having
one extra level of interpretation. Several papers on partial evaluation of logic programs
are collected in Ershov (1988) and annotated bibliographies are available in Bjørner,
Ershov and Jones (1988).
EXPERT SYSTEMS:
Expert systems as described in Chapter 9, are particular
applications of meta-logical reasoning. An early account of the application of logic
programming in the ﬁeld of expert systems was provided by Clark and McCabe (1982).
The example in Chapter 9 is based on the technique of composing self-interpreters
suggested by Sterling and Lakhotia (1988). Similar expert-system shells are described
e.g. by Sterling and Beer (1989) and Sterling and Shapiro (1994). To incorporate
probabilities see Shapiro (1983b).
For a survey of abductive reasoning in logic programming see Kakas, Kowalski and
Toni (1992).
DEFINITE CLAUSE GRAMMARS:
One of the ﬁrst applications of logic pro-
gramming was that of formalizing natural language. In fact, the very ﬁrst implemen-
tation of Prolog — made by Colmerauer’s group in Marseilles (see Roussel (1975)) —
was primarily used for processing of natural language (e.g. Colmerauer et al. (1973)).
Since then several results relating logic programming and various grammatical for-
malisms have been published. For an extensive account of the area see Deransart and
Ma luszy´nski (1993).
The notion of Deﬁnite Clause Grammar (DCG) was introduced by Warren and
Pereira (1980) and incorporated into the DEC-10 Prolog system developed at the
University of Edinburgh. However, the basic idea is an adaptation of Colmerauer’s
Metamorphosis Grammars (1978). The form of DCGs described in Chapter 10 may

A.3 Alternative Logic Programming Schemes
247
deviate somewhat from that implemented in most Prolog systems. In most implemen-
tations DCGs are viewed merely as a syntactic sugar for Prolog and, as a consequence,
all of Prolog built-in features (including cut, negation etc.) may be inserted into the
grammar rules. Any user’s manual of speciﬁc Prolog systems that support DCGs can
ﬁll in the remaining gaps.
The simple translation of DCGs into Prolog clauses shown in Section 10.5 is by no
means the only possibility. Matsumoto et al. (1983) describe a left-corner bottom-up
strategy. Nilsson (1986) showed how to translate an arbitrary DCG into a Prolog pro-
gram which embodies the LR(k) parsing technique. Finally, Cohen and Hickey (1987)
describe a whole range of parsing techniques and their use in compiler construction.
A large number of formalisms similar to DCGs have been suggested.
Some of
the most noteworthy are Abramson’s Deﬁnite Clause Translation Grammars (1984)
(which are closely related to attribute grammars) and Gapping Grammars by Dahl and
Abramson (1984). These, and other formalisms, are surveyed by Dahl and Abramson
(1989). For an extensive account of the use of Prolog in natural language process-
ing, see Dahl (1994) and monographs by Pereira and Shieber (1987) (who also make
extensive use of partial evaluation techniques) and Gazdar and Mellish (1989).
SEARCHING:
Chapter 11 presents some fundamental concepts related to the
problem of searching in a state space. Several other, more advanced techniques can
be found in textbooks by Bratko (1990), Sterling and Shapiro (1994), Clocksin and
Mellish (1994) and O’Keefe (1990).
A.3
Alternative Logic Programming Schemes
CONCURRENCY:
There exists a number of logic programming languages based
on a concurrent execution model. Three of the most inﬂuential are PARLOG, Guarded
Horn Clauses and Concurrent Prolog, but several others have been suggested. They
all originate from the experimental language IC-Prolog developed around 1980 by
Clark, McCabe and Gregory (1982) at Imperial College, London. The main feature of
this language was its execution model based on pseudo-parallelism and coroutining as
suggested by Kowalski (1979a; 1979b). In IC-Prolog this was achieved by associating
control-annotations to variables in the clauses. The language also had a concept of
guards but no commit operator in the sense of Chapter 12. IC-Prolog was succeeded
by the Relational Language of Clark and Gregory (1981) which introduced guards and
the commit operator inspired by Dijkstra’s guarded commands (1976) and Hoare’s
CSP (1985). The synchronization between subgoals was speciﬁed by means of mode-
declarations — that is, annotations which describe how arguments of calls to predicates
are to be instantiated in order for the call to go ahead. Unfortunately, the modes
were so restricted that programs in the language more or less behaved as functional
programs with relational syntax. However, some of these restrictions were relaxed in
the successor language called PARLOG (for details, see Clark and Gregory (1986)
and Gregory (1987)).
Concurrent Prolog was developed by Shapiro (1983a; 1986) as a direct descendant
of the Relational Language. The language is closely related to PARLOG but diﬀers in
some respects. In particular, in Concurrent Prolog synchronization between subgoals

248
Appendix A: Bibliographical Notes
is achieved by means of read-only annotations on variables as opposed to PARLOG
where the same eﬀect is obtained by means of mode-declarations.
Guarded Horn Clauses (GHC) suggested by Ueda (1985) is also based on the same
idea as PARLOG and Concurrent Prolog. In contrast to the previous two, GHC does
not provide any explicit declarations for synchronization. Instead a subgoal suspends
if it is unable to commit to a clause without binding variables in the call.
A large number of papers on concurrent logic programming languages are collected
by Shapiro (1988). Shapiro (1989) also provides a survey of most existing concurrent
logic programming languages.
EQUATIONAL LOGIC PROGRAMMING:
A large number of logic program-
ming languages attempt to combine logic programming with functional programming.
This may be achieved in three diﬀerent ways:
• integration of logic programming on top of some existing functional language.
LOGLISP of Robinson and Sibert (1982), Komorowski’s QLOG (1982) and
POPLOG of Mellish and Hardy (1984) are examples of this approach;
• a logic programming language able to call functions deﬁned in arbitrary lan-
guages through a well-deﬁned interface (cf. Ma luszy´nski et al (1993));
• deﬁning a new language in which it is possible to write both logic and functional
programs. This approach is represented by languages such as LEAF (cf. Bar-
buti et al. (1986), FUNLOG (cf. Subrahmanyam and You (1986)).
BABEL
(cf. Moreno-Navarro and Rodriguez-Artalejo (1992)) and ALF (Hanus (1992)).
All of these have their own merits depending on whether one is interested in eﬃciency
or logical clarity. The ﬁrst approach is usually the most eﬃcient whereas the third is
probably the most attractive from a logical point of view and also the one that is most
closely related to what was said in Chapter 13.
The third approach usually consists of extending logic programming with equa-
tional theories. Operationally, it amounts to extending SLD-resolution with some form
of equation solving — for instance, using diﬀerent adaptations of narrowing (cf. Slagle
(1974)). For further reading see the work of Hullot (1980), Dershowitz and Plaisted
(1988) or the excellent survey by Huet and Oppen (1980). However, as pointed out in
Chapter 13, equation solving without restrictions is likely to end up in inﬁnite loops.
Much of the research is therefore directed towards ﬁnding more eﬃcient methods and
special cases when the technique is more likely to halt.
Surveys describing integration of logic and functional programming are provided by
Bellia and Levi (1985) and Hanus (1994). Some of the papers cited above are collected
by DeGroot and Lindstrom (1986). The generalization of model- and proof-theoretic
semantics from deﬁnite programs into deﬁnite programs with equality is due to Jaﬀar,
Lassez and Maher (1984; 1986). Gallier and Raatz (1986) provide basic soundness and
completeness results for SLD-resolution extended with E-uniﬁcation.
A slightly diﬀerent, but very powerful, approach to combining logic programming
with functional programming can be obtained by exploiting higher-order uniﬁcation of
λ-terms (cf. Huet (1975) or Snyder and Gallier (1990)). This idea has been exploited
in λ-Prolog developed by Miller et al. at the University of Pennsylvania (see Nadathur
and Miller (1995)).

A.3 Alternative Logic Programming Schemes
249
CONSTRAINTS:
The use of constraints (see Leler (1988) and Steele (1980)) in
logic programming is closely related to the integration of logical and functional lan-
guages.
Colmerauer’s Prolog II (1982; 1984), now succeeded by Prolog III (1990),
seems to be the ﬁrst logic programming language that makes extensive use of con-
straints. In the case of Prolog II the constraints are restricted to equalities and dise-
qualities over rational trees. Jaﬀar and Lassez (1987) lay the foundation for combin-
ing logic programming with other constraint domains by providing a parameterized
framework CLP(X ), where X may be instantiated to various domains. An instance
of the scheme — CLP(R) where R stands for the domain of real numbers — was
implemented at Monash University, Australia (see Heintze, Michaylov and Stuckey
(1987a) and Jaﬀar and Michaylov (1987)). Several applications of the system have
been demonstrated. For instance, in electrical engineering (Heintze et al. (1987b))
and in option trading (see Lassez, McAloon and Yap (1987)).
Several other constraint logic programming systems have been proposed. CAL,
by Aiba et al. (1988), supports (non-)linear algebraic polynomial equations, boolean
equations and linear inequalities. The language CHIP supports equations over ﬁnite
domains, Booleans and rational numbers (see Dincbas et al. (1988) and Van Henten-
ryck (1989)). CHIP subsequently split into several successor languages (such as Sepia
and cc(FD)). Prolog III provides constraints over the binary Boolean algebra, strings
and linear equations over the reals and rational numbers (see Colmerauer (1990)).
CLP(BNR) contains constraints over real and integer intervals, ﬁnite domains and the
Boolean algebra. The language CLP(Σ∗) supports constraints over domains of regular
sets (see Walinsky (1989)). The language LIFE supports constraints over a domain of
order-sorted feature trees (see A¨ıt-Kaci and Podelski (1993)).
Imbert, Cohen and Weeger (1993) describe an incremental and eﬃcient algorithm
for testing the satisﬁability of linear constraints. They also describe how to incorporate
the algorithm into a Prolog meta-interpreter.
Constraints may also be combined with concurrent logic programming as shown
by Maher (1987). Saraswat (1993) proposed a family of concurrent constraint (logic)
programming languages. The language AKL (Agents Kernel Language)1 is a multi-
paradigm language which combines constraints with don’t-care non-deteminism of
concurrent logic programming and (a restricted form of) don’t-know non-determinism
of Prolog (see Janson (1994)). AKL provides constraints over ﬁnite domains and is in
several respects similar to the language Oz developed by Smolka (see Schulte, Smolka
and W¨urtz (1994)).
Jaﬀar and Maher (1994) provide an excellent survey of the theory, implementation
and applications of constraint logic programming.
QUERY-ANSWERING IN DEDUCTIVE DATABASES:
Two main streams
can be singled out in query-processing of deductive databases. One approach is based
on naive- or semi-naive evaluation of a transformed program. A large number of trans-
formations have been proposed for various classes of programs. Most notably magic
sets of Bancilhon, Maier, Sagiv and Ullman (1986) and magic templates of Ramakr-
ishnan (1988). For an introduction to these techniques and other methods such as
counting, envelopes see Bancilhon and Ramakrishnan (1988).
1Formerly called the ANDORRA Kernel Language (see Haridi and Brand (1988)).

250
Appendix A: Bibliographical Notes
The other main approach is to extend SLD-resolution with tabulation or dynamic
programming techniques. That is, methods were results are tabulated and re-used
when needed instead of being recomputed. Examples of this approach are Earley de-
duction of Pereira and Warren (1983), OLDT-resolution of Tamaki and Sato (1986),
SLD-AL-resolution of Vieille (1989) and the search forest approach of Bol and Degerst-
edt (1993b). As illustrated by the example in Chapter 15 and as shown by Bry (1990)
there is a strong correspondence between both methods. See also Warren (1992) for a
survey of tabulation techniques.
For an introduction to goal-ordering see Ullman (1985) or (1989). The notion of
sideways information passing (sip) was formally deﬁned by Beeri and Ramakrishnan
(1987) who also introduced the transformation based on supplementary predicates.
Both Ullman (1988; 1989) as well as Abiteboul, Hull and Vianu (1995) provide exten-
sive introductions to foundations of deductive databases.
Several deductive database systems have been developed including Coral, NAIL,
Aditi and LDL. For an introduction to deductive database systems and applications
of deductive databases, see the collection of Ramakrishnan (1995).

Appendix B
Basic Set Theory
This appendix contains a brief summary of basic set theoretic notions used in the book.
It is not intended to be an introduction. To this end we recommend reading Gill (1976)
or Grimaldi (1994) or some other introductory textbook on discrete mathematics.
B.1
Sets
By a set we mean an aggregate, or a collection, of objects. The objects that belong to
a set are called the elements of the set. The notation x ∈S is used to express the fact
that x is an element in S. Similary x ̸∈S expresses the fact that x is not an element
in S. There are several ways of writing a set: a set with a small, ﬁnite number of
elements is usually written out in its entirety. For instance, {0, 1, 2, 3} denotes the
set of all natural numbers that are less than 4. For larger sets, such as the set of all
natural numbers less than 1000, the notation {0, 1, 2, . . ., 999} or {x | 0 ≤x < 1000}
may be used. Note that a set of the form {x1, . . . , xn} is always assumed to be ﬁnite in
contrast to a set of the form {x1, x2, . . .} which is allowed to be inﬁnite. The empty set
is written
?. The set of all natural numbers {0, 1, 2, . . .} is denoted by
N. Similarly
Z,
Q and
R denote the sets of integers, rational numbers and real numbers respectively.
The union, S1 ∪S2, of two sets, S1 and S2, is the set of all elements that belong
either to S1 or to S2. The intersection, S1 ∩S2, is the set of all elements that belong
both to S1 and S2 and the diﬀerence, S1 \ S2, is the set of all elements that belong
to S1 but not to S2. A set S1 is said to be a subset of S2 (denoted S1 ⊆S2) if every
element of S1 is also an element of S2. The set that consists of all subsets of a set, S,
is called the powerset of S. This set is denoted ℘(S).
The cartesian product, S1 × S2, of two sets is the set of all pairs ⟨x1, x2⟩such that
x1 ∈S1 and x2 ∈S2. This can be extended to any number of sets. Thus, S1 ×· · ·×Sn
denotes the set of all n-tuples ⟨x1, . . . , xn⟩such that xi ∈Si (1 ≤i ≤n). If Si = S
(for all 1 ≤i ≤n) we usually write Sn instead of S × · · · × S.
251

252
Appendix B: Basic Set Theory
Let S be a set. By S∗we denote the set of all strings (sequences) of elements from
S. That is, S∗= {x1, . . . , xn | n ≥0 ∧xi ∈S (1 ≤i ≤n)}. Note that S∗contains the
string of length 0, denoted ϵ and called the empty string.
B.2
Relations
Let S1, . . . , Sn be sets and let R ⊆S1 × · · · × Sn. Then R is said to be a relation (over
S1, . . . , Sn). The fact that ⟨x1, . . . , xn⟩∈R is usually written R(x1, . . . , xn). We say
that R is an n-ary relation. When n = 0, 1, 2, 3 we say that R is nullary, unary, binary
and ternary respectively.
A binary relation over S, is said to be reﬂexive if R(x, x) for every x ∈S. The rela-
tion is said to be symmetric if R(x, y) whenever R(y, x) and transitive if R(x, z) when-
ever both R(x, y) and R(y, z). The relation is said to be anti-symmetric if R(x, y) and
R(y, x) imply that x = y. A relation that is reﬂexive, transitive and anti-symmetric
is called a partial order and a relation that is reﬂexive, transitive and symmetric is
called an equivalence relation.
A binary relation R ⊆S × S such that R(x, y) iﬀx = y is called the identity
relation.
B.3
Functions
A binary relation f ⊆S1 × S2 is called a function (or a mapping) if whenever f(x, z)
and f(y, z) then x = y. We say that the function f assigns the value z to x (or maps
x on z) and write this as f(x) = z. The set S1 is called the domain of the function
and S2 is called its codomain. It is common practice to abbreviate this as f: S1 →S2.
A function f: S1 →S2 is said to be total if for every x ∈S1 there exists an element
y in S2 such that f(x) = y. Otherwise f is said to be partial.
The composition, f2 ◦f1, of two functions f1: S1 →S2 and f2: S2 →S3, is itself a
function — with domain S1 and codomain S3 — with the property that (f2 ◦f1)(x) =
f2(f1(x)), for any x ∈S1.
A function f: S1 →S2 is called a bijection if it is total and x = y whenever
f(x) = f(y). Bijections are sometimes called one-to-one-mappings. Every bijection
has a invers f −1: S2 →S1 which satisﬁes f(f −1(x)) = f −1(f(x)) = x.

Appendix C
Answers to Selected Exercises
1.1 The following is a possible solution (but not the only one):
∀X(natural(X) ⊃∃Y (equal(s(X), Y )))
¬∃Xbetter(X, taking a nap)
∀X(integer(X) ⊃¬negative(X))
∀X, Y (name(X, Y ) ∧innocent(X) ⊃changed(Y ))
∀X(area of cs(X) ⊃important for(logic, X)
∀X(renter(X) ∧in accident(X) ⊃pay deductible(X))
1.2 The following is a possible solution (but not the only one):
better(bronze medal, nothing)
¬∃Xbetter(X, gold medal)
better(bronze medal, gold medal)
1.3 Let MOD(X) denote the set of all models of the formulas X. Then:
P |= F
iﬀ
MOD(P) ⊆MOD(F)
iﬀ
MOD(P) ∩MOD(¬F) =
?
iﬀ
MOD(P ∪{¬F}) =
?
iﬀ
P ∪{¬F} is unsatisﬁable
1.4 Take for instance, F ⊃G ≡¬F ∨G. Let ℑand ϕ be an arbitrary interpretation
and valuation respectively. Then:
ℑ|=ϕ F ⊃G
iﬀ
ℑ|=ϕ G whenever ℑ|=ϕ F
iﬀ
ℑ|=ϕ G or ℑ̸|=ϕ F
iﬀ
ℑ|=ϕ ¬F or ℑ|=ϕ G
iﬀ
ℑ|=ϕ ¬F ∨G
253

254
Appendix C: Answers to Selected Exercises
1.6 Let MOD(X) denote the set of all models of the formula X. Then:
F ≡G
iﬀ
MOD(F) = MOD(G)
iﬀ
MOD(F) ⊆MOD(G) and MOD(G) ⊆MOD(F)
iﬀ
{F} |= G and {G} |= F
1.8 Hint: Assume that there is a ﬁnite interpretation and establish a contradiction
using the semantics of formulas.
1.12 Hints:
E(θσ) = (Eθ)σ: by the deﬁnition of application it suﬃces to consider the case
when E is a variable.
(θσ)γ = θ(σγ): it suﬃces to show that the two substitutions give the same
result when applied to an arbitrary variable. The fact that E(θσ) = (Eθ)σ
can be used to complete the proof.
1.15 Only the last one. (Look for counter-examples of the ﬁrst two!)
2.1 Deﬁnite clauses:
(1)
p(X) ←q(X).
(2)
p(X) ←q(X, Y ), r(X).
(3)
r(X) ←p(X), q(X).
(4)
p(X) ←q(X), r(X).
2.3 The Herbrand universe:
UP = {a, b, f(a), f(b), g(a), g(b), f(g(a)), f(g(b)), f(f(a)), f(f(b)), . . .}
The Herbrand base:
BP = {q(x, y) | x, y ∈UP } ∪{p(x) | x ∈UP }
2.4 UP = {0, s(0), s(s(0)), . . .} and BP = {p(x, y, z) | x, y, z ∈UP }.
2.5 Formulas 2, 3 and 5. Hint: Consider ground instances of the formulas.
2.6 Use the immediate consequence operator:
TP ↑0
=
?
TP ↑1
=
{q(a, g(b)), q(b, g(b))}
TP ↑2
=
{p(f(b))} ∪TP ↑1
TP ↑3
=
TP ↑2
That is, MP = TP ↑3.
2.7 Use the immediate consequence operator:
TP ↑0
=
?
TP ↑1
=
{p(0, 0, 0), p(0, s(0), s(0)), p(0, s(s(0)), s(s(0))), . . .}
TP ↑2
=
{p(s(0), 0, s(0)), p(s(0), s(0), s(s(0))), . . .} ∪TP ↑1
...
TP ↑ω
=
{p(sx(0), sy(0), sz(0)) | x + y = z}

Appendix C: Answers to Selected Exercises
255
3.1 {X/a, Y/a}, not uniﬁable, {X/f(a), Y/a, Z/a} and the last pair is not uniﬁable
because of occur-check.
3.2 Let σ be a uniﬁer of s and t. By the deﬁnition of mgu there is a substitution δ
such that σ = θδ. Now since ω is a renaming it follows also that σ = θωω−1δ.
Thus, for every uniﬁer σ of s and t there is a substitution ω−1δ such that
σ = (θω)(ω−1δ).
3.4 Assume that σ is a uniﬁer of s and t. Then by deﬁnition σ = θω for some
substitution ω. Moreover, σ = θθω since θ is idempotent. Thus, σ = θσ.
Next, assume that σ = θσ. Since θ is an mgu it must follow that σ is a uniﬁer.
3.5 {X/b} is produced twice and {X/a} once.
3.6 For instance, the program and goal:
←p.
p ←p, q.
Prolog’s computation rule produces an inﬁnite tree whereas a computation
rule which always selects the rightmost subgoal yields a ﬁnitely failed tree.
3.7 Inﬁnitely many. But there are only two answers, X = b and X = a.
4.4 Hint: Each clause of the form:
p(t1, . . . , tm) ←B
in P gives rise to a formula of the form:
p(X1, . . . , Xm) ↔. . . ∨∃. . . (X1 = t1, . . . , Xm = tm, B) ∨. . .
in comp(P).
Use truth-preserving rewritings of this formula to obtain the
program clause.
4.7 Only P1 and P3.
4.8 comp(P) consists of:
p(X1) ↔X1 = a, ¬q(b)
q(X1) ↔

and some equalities including a = a and b = b.
4.14 The well-founded model is {r, ¬s}.
5.1 Without cut there are seven answers. Replacing true(1) by cut eliminates the
answers X = e, Y = c and X = e, Y = d. Replacing true(2) by cut eliminates
in addition X = b, Y = c and X = b, Y = d.
5.3 The goal without negation gives the answer X = a while the other goal suc-
ceeds without binding X.
5.4 For example:
var(X) ←not(not(X = a)), not(not(X = b)).

256
Appendix C: Answers to Selected Exercises
5.6 For example:
between(X, Z, Z) ←X ≤Z.
between(X, Y, Z) ←X < Z, W is Z −1, between(X, Y, W).
5.7 For instance, since (n + 1)2 = n2 + 2 ∗n + 1, n ≥0:
sqr(0, 0).
sqr(s(X), s(Z)) ←sqr(X, Y ), times(s(s(0)), X, W), plus(Y, W, Z).
5.8 For instance:
gcd(X, 0, X) ←X > 0.
gcd(X, Y, Z) ←Y > 0, W is X mod Y, gcd(Y, W, Z).
6.2 For instance:
grandchild(X, Z) ←parent(Y, X), parent(Z, Y ).
sister(X, Y ) ←female(X), parent(Z, X), parent(Z, Y ), X ̸= Y.
brother(X, Y ) ←male(X), parent(Z, X), parent(Z, Y ), X ̸= Y.
etc.
6.3 Hint: (1) Colours should be assigned to countries. Hence, represent the coun-
tries by variables. (2) Describe the map in the goal by saying which countries
should be assigned diﬀerent colours.
6.4 For instance:
and(1, 1, 1).
and(0, 1, 0).
and(1, 0, 0).
and(0, 0, 0).
inv(1, 0).
inv(0, 1).
circuit1(X, Y, Z) ←
and(X, Y, W), inv(W, Z).
circuit2(X, Y, Z, V, W) ←
and(X, Y, A), and(Z, V, B),
and(A, B, C), inv(C, W).
6.5 For instance:
p(X, Y ) ←husband(K, X), wife(K, Y ).
q(X) ←parent(X, Y ).
q(X) ←income(X, Y ), Y ≥20000.

Appendix C: Answers to Selected Exercises
257
6.6 For instance:
πX,Y (Q(Y, X)) ∪πX,Y (Q(X, Z)
 R(Z, Y ))
6.7 For instance:
compose(X, Z) ←r1(X, Y ), r2(Y, Z).
6.9 Take the transitive closure of the parent/2-relation.
6.11 For instance:
ingredients(tea, needs(water, needs(tea bag, nil))).
ingredients(boiled egg, needs(water, needs(egg, nil))).
available(water).
available(tea bag).
can cook(X) ←
ingredients(X, Ingr), all available(Ingr).
all available(nil).
all available(needs(X, Y )) ←
available(X), all available(Y ).
needs ingredient(X, Y ) ←
ingredients(X, Ingr), among(Y, Ingr).
among(X, needs(X, Y )).
among(X, needs(Y, Z)) ←
among(X, Z).
7.1 Alternative list notation:
.(a,.(b, [ ]))
.(a,.(b,.(c, [ ])))
.(a, b)
.(a,.(b, [ ]))
.(a,.(.(b,.(c, [ ])),.(d, [ ])))
.([ ], [ ])
.(a,.(b, X))
.(a,.(b,.(c, [ ])))
7.4 For instance:
length([ ], 0).
length([X|Y ], N) ←length(Y, M), N is M + 1.
7.5 For instance:
lshift([X|YZ], YZX ) ←append(YZ, [X], YZX).

258
Appendix C: Answers to Selected Exercises
7.9 For instance:
sublist(X, Y ) ←preﬁx(X, Y )
sublist(X, [Y |Z]) ←sublist(X, Z).
7.12 For instance:
msort([ ], [ ]).
msort([X], [X]).
msort(X, Y ) ←
split(X, Split1, Split2),
msort(Split1 , Sorted1),
msort(Split2 , Sorted2),
merge(Sorted1, Sorted2, Y ).
split([X], [], [X]).
split([X, Y |Z], [X|V ], [Y |W]) ←
split(Z, V, W).
merge([ ], [ ], [ ]).
merge([X|A], [Y |B], [X|C]) ←
X < Y, merge(A, [Y |B], C).
merge([X|A], [Y |B], [Y |C]) ←
X ≥Y, merge([X|A], B, C).
7.13 For instance:
edge(1, 2, b).
edge(2, 2, a).
edge(2, 3, a).
edge(3, 2, b).
ﬁnal(3).
accept(State, [ ]) ←
ﬁnal(State).
accept(State, [X|Y ]) ←
edge(State, NewState, X), accept(NewState, Y ).
7.17 For instance:
palindrome(X) ←diﬀpalin(X −[ ]).
diﬀpalin(X −X).
diﬀpalin([X|Y ] −Y ).
diﬀpalin([X|Y ] −Z) ←diﬀpalin(Y −[X|Z]).

Appendix C: Answers to Selected Exercises
259
7.20 Hint: Represent the empty binary tree by the constant empty and the non-
empty tree by node(X, Left, Right) where X is the label and Left and Right
the two subtrees of the node.
8.3 The following program provides a starting point (the program ﬁnds all refu-
tations but it does not terminate):
prove(Goal) ←
int(Depth), dﬁd(Goal, Depth, 0).
dﬁd(true, Depth, Depth).
dﬁd((X, Y ), Depth, NewDepth) ←
dﬁd(X, Depth, TmpDepth),
dﬁd(Y, TmpDepth, NewDepth).
dﬁd(X, s(Depth), NewDepth) ←
clause(X, Y ),
dﬁd(Y, Depth, NewDepth).
int(s(0)).
int(s(X)) ←
int(X).
8.4 Hint: For instance, the fourth rule may be deﬁned as follows:
d(X + Y, Dx + Dy) ←d(X, Dx), d(Y, Dy).
10.3 Deﬁnite clause grammar:
bleat →[b], aaa.
aaa →[a].
aaa →[a], aaa.
Prolog program:
bleat(X0, X2) ←connects(X0, b, X1), aaa(X1, X2).
aaa(X0, X1) ←connects(X0, a, X1).
aaa(X0, X2) ←connects(X0, a, X1), aaa(X1, X2).
connects([X|Y ], X, Y ).
A refutation is obtained, for instance, by giving the goal ←bleat([b, a, a], []).
10.4 The DCG describes a language consisting only of the empty string. However,
at the same time it deﬁnes the “concatenation”-relation among lists. That is,
the nonterminal x([a, b], [c, d], X) not only derives the empty string but also
binds X to [a, b, c, d].
12.1 The deﬁnition of append/3 and member/2 is left to the reader:

260
Appendix C: Answers to Selected Exercises
eq(T1, T2) ←
nodes(T1, N1), nodes(T2, N2), equal(N1?, N2?).
nodes(empty, [ ]).
nodes(tree(X, T1, T2), [X|N]) ←
nodes(T1, N1), nodes(T2, N2), append(N1?, N2?, N).
equal(X, Y ) ←
subset(X, Y ), subset(Y, X).
subset([ ], X).
subset([X|Y ], Z) ←
member(X, Z), subset(Y ?, Z).
12.2 Hint: write a program which transposes the second matrix and then computes
all inner products.
13.3 Hint: The overall structure of the proof is as follows:
E ⊢app(c(X, Y ), Z) .= c(X, app(Y, Z))
E ⊢
.=
E ⊢a .= a
E ⊢app(nil, X) .= X
E ⊢
.=
E ⊢
.=
E ⊢
.=
14.3 The following program with real-valued or rational constraints can be used to
answer e.g. the goal ←jugs([M, 1 −M, 0], Res, N).
jugs([A, B, C], [A, B, C], N) ←
N .= 0, A + B + C .= 1.
jugs([A, B, C], Res, N) ←
N > 0,
jugs([0.6 ∗A + 0.2 ∗B, 0.7 ∗B + 0.4 ∗A, C + 0.1 ∗B], Res, N −1).
15.1 The transformed program looks as follows:
expr(X, Z) ←
call expr(X, Z), expr(X, [+|Y ]), expr(Y, Z).
expr([id|Y ], Y ) ←
call expr([id|Y ], Y ).
call expr(X, [+|Y ]) ←
call expr(X, Z).
call expr(Y, Z) ←
call expr(X, Z), expr(X, [+|Y ]).
Adding call expr([id, +, id], X) to the program yields the semi-naive iteration:

Appendix C: Answers to Selected Exercises
261
∆x0
=
{call expr([id, +, id], A)}
∆x1
=
{expr([id, +, id], [+, id]), call expr([id, +, id], [+|A])}
∆x2
=
{call expr([id], A), call expr([id], [+|A])}
∆x3
=
{expr([id], [ ])}
∆x4
=
{expr([id, +, id], [ ])}

262
Appendix C: Answers to Selected Exercises

Bibliography
Abiteboul, S., Hull, R., and Vianu, V. (1995). Foundations of Databases. Addison-
Wesley.
Abramson, H. (1984). Deﬁnite Clause Translation Grammars. In Proc. 1984 Symp. on
Logic Programming, Atlantic City, pages 233–241.
Aiba, A., Sakai, K., Sato, Y., Hawley, D., and Hasegawa, R. (1988).
Constraint
Logic Programming Language CAL. In Proc. of Int’l Conf. on Fifth Generation
Computer Systems 88, Tokyo, pages 263–276.
A¨ıt-Kaci, H. and Podelski, A. (1993).
Towards a Meaning of LIFE.
J. of Logic
Programming, 16(3–4):195–234.
Apt, K. (1990). Introduction to Logic Programming. In van Leeuwen, J., editor, Hand-
book of Theoretical Computer Science: Formal Models and Semantics, volume B,
chapter 10, pages 493–574. Elsevier.
Apt, K., Blair, H., and Walker, A. (1988). Towards a Theory of Declarative Knowl-
edge. In Minker, J., editor, Foundations of Deductive Databases and Logic Pro-
gramming, pages 89–148. Morgan Kaufmann, Los Altos.
Apt, K. and Bol, R. (1994). Logic Programming and Negation: A Survey. J. of Logic
Programming, 19/20:9–71.
Apt, K. and Doets, K. (1994). A New Deﬁnition of SLDNF-resolution. J. of Logic
Programming, 18(2):177–190.
Apt, K. and Pellegrini, A. (1992). Why the Occur-check is Not a Problem. In Proc. of
PLILP’92, Lecture Notes in Computer Science 631, pages 1–23. Springer-Verlag.
Apt, K. and van Emden, M. (1982). Contributions to the Theory of Logic Program-
ming. J. of ACM, 29(3):841–862.
263

264
Bibliography
Bacha, H. (1987).
Meta-Level Programming: A Compiled Approach.
In Proc. of
Fourth Int’l Conf. on Logic Programming, Melbourne, pages 394–410. MIT Press.
Bancilhon, F., Maier, D., Sagiv, Y., and Ullman, J. (1986). Magic Sets and Other
Strange Ways to Implement Logic Programs.
In Proc. Fifth ACM Symp. on
Principles of Database Systems, pages 1–15.
Bancilhon, F. and Ramakrishnan, R. (1988). An Amateur’s Introduction to Recursive
Query Processing Strategies. In Stonebraker, M., editor, Readings in Database
Systems, pages 507–555. Morgan Kaufmann.
Barbuti, R., Bellia, M., Levi, G., and Martelli, M. (1986). LEAF: A Language which
Integrates Logic, Equations and Functions. In DeGroot, D. and Lindstrom, G.,
editors, Logic Programming, Functions, Relations and Equations, pages 201–238.
Prentice-Hall.
Beer, J. (1988).
The Occur-Check Problem Revisited.
J. of Logic Programming,
5(3):243–262.
Beeri, C. and Ramakrishnan, R. (1987).
On the Power of Magic.
In Proc of 6th
Symposium on Principles of Database Systems, pages 269–283.
Bellia, M. and Levi, G. (1985). The Relation Between Logic and Functional Languages:
A Survey. J. of Logic Programming, 3(3):217–236.
Birkhoﬀ, G. (1935).
On the Structure of Abstract Algebras.
In Proc. Cambridge
Phil. Soc. 31, pages 433–454.
Bjørner, D., Ershov, A., and Jones, N., editors (1988). Partial Evaluation and Mixed
Computation. North Holland.
Bol, R. and Degerstedt, L. (1993a). Tabulated Resolution for Well Founded Semantics.
In Proc. of the Int’l Logic Programming Symposium, Vancouver, pages 199–219.
MIT Press.
Bol, R. and Degerstedt, L. (1993b).
The Underlying Search for Magic Templates
and Tabulation. In Proc. of Int’l Conf. on Logic Programming, Budapest, pages
793–811. MIT Press.
Boolos, G. and Jeﬀrey, R. (1980). Computability and Logic. Cambridge University
Press.
Bossi, A., Gabbrielli, M., Levi, G., and Martelli, M. (1994). The S-semantics Approach:
Theory and Applications. J. of Logic Programming, 19/20:149–197.
Bowen, K. (1985). Meta-Level Programming and Knowledge Representation. New
Generation Computing, 3(1):359–383.
Bowen, K. and Kowalski, R. (1982). Amalgamating Language and Metalanguage in
Logic Programming. In Clark, K. and T¨arnlund, S.-˚A., editors, Logic Program-
ming, pages 153–172. Academic Press.

Bibliography
265
Bowen, K. and Weinberg, T. (1985). A Meta-Level Extension of Prolog. In Proc. 1985
Symp. on Logic Programming, Boston, pages 48–53.
Bratko, I. (1990). Prolog Programming for Artiﬁcial Intelligence. Addison-Wesley, 2nd
edition.
Bry, F. (1990). Query Evaluation in Recursive Databases: Bottom-up and Top-down
Reconciled. IEEE Transactions on Knowledge and Data Engineering, 5:289–312.
Cavedon, L. and Lloyd, J. (1989). A Completeness Theorem for SLDNF Resolution.
J. of Logic Programming, 7(3):177–191.
Chadha, R. and Plaisted, D. (1994). Correctness of Uniﬁcation without Occur Check
in Prolog. J. of Logic Programming, 18(2):99–122.
Chan, D. (1988).
Constructive Negation based on the Completed Database.
In
Proc. of Fifth Int’l Conf./Symp. on Logic Programming, Seattle, pages 111–125.
MIT Press.
Chandra, A. and Harel, D. (1985). Horn Clause Queries and Generalizations. J. of
Logic Programming, 2(1):1–16.
Chang, C. and Lee, R. (1973).
Symbolic Logic and Mechanical Theorem Proving.
Academic Press, New York.
Chen, W. and Warren, D. S. (1993). Query Evaluation under the Well-founded Se-
mantics. In Proc. of SIGACT-SIGMOD-SIGART Symposium on Principles of
Database Systems, pages 168–179, Washington DC.
Clark, K. (1978). Negation as Failure. In Gallaire, H. and Minker, J., editors, Logic
and Databases, pages 293–322. Plenum Press, New York.
Clark, K. (1979). Predicate Logic as a Computational Formalism. Report DOC 79/59,
Dept. of Computing, Imperial College.
Clark, K. and Gregory, S. (1981). A Relational Language for Parallel Programming.
Research Report DOC 81/16, Department of Computing, Imperial College.
Clark, K. and Gregory, S. (1986). PARLOG: Parallel Programming in Logic. ACM
TOPLAS, 8(1):1–49.
Clark, K. and McCabe, F. (1982).
Prolog: A Language for Implementing Expert
Systems. In Hayes, J., Michie, D., and Pao, Y.-H., editors, Machine Intelligence
10, pages 455–470. Ellis Horwood.
Clark, K., McCabe, F., and Gregory, S. (1982). IC-Prolog Language Features. In Clark,
K. and T¨arnlund, S.-˚A., editors, Logic Programming, pages 253–266. Academic
Press.
Clark, K. and T¨arnlund, S.-˚A. (1977). A First Order Theory of Data and Programs.
In Information Processing ‘77, pages 939–944. North-Holland.

266
Bibliography
Clocksin, W. and Mellish, C. (1994). Programming in Prolog. Springer-Verlag, 4th
edition.
Codd, E. F. (1970). A Relational Model of Data for Large Shared Data Banks. Com-
munications of the ACM, 13(6):377–387.
Cohen, J. and Hickey, T. (1987). Parsing and Compiling using Prolog. ACM TOPLAS,
9(2):125–163.
Colmerauer, A. (1978). Metamorphosis Grammars. In Bolc, L., editor, Natural Lan-
guage Communication with Computers, Lecture Notes in Computer Science 63,
pages 133–189. Springer-Verlag.
Colmerauer, A. (1982). Prolog and Inﬁnite Trees. In Clark, K. and T¨arnlund, S.-˚A.,
editors, Logic Programming. Academic Press.
Colmerauer, A. (1984). Equations and Inequations on Finite and Inﬁnite Trees. In
Proc. of Int’l Conf. on Fifth Generation Computer Systems 84, Tokyo, pages
85–102. North-Holland.
Colmerauer, A. (1990). An Introduction to Prolog III. Communications of the ACM,
33(7):69–90.
Colmerauer, A. et al. (1973). Un Syst`eme de Communication Homme-Machine en
Francais. Technical report, Technical Report, Group d’Intelligence Artiﬁcielle,
Marseille.
Dahl, V. (1994). Natural Language Processing and Logic Programming. J. of Logic
Programming, 19/20:681–714.
Dahl, V. and Abramson, H. (1984). On Gapping Grammars. In Proc. of Second Int’l
Conf. on Logic Programming, Uppsala, pages 77–88.
Dahl, V. and Abramson, H. (1989). Logic Grammars. Springer-Verlag.
DeGroot, D. and Lindstrom, G., editors (1986). Logic Programming, Functions, Re-
lations and Equations. Prentice-Hall.
Deransart, P., Ferrand, G., and T´eguia, M. (1991). NSTO Programs (Not Subject To
Occur-check). In Proc. of 1991 Int’l Logic Programming Symposium, San Diego,
pages 533–547. MIT Press.
Deransart, P. and Ma luszy´nski, J. (1993). A Grammatical View of Logic Programming.
MIT Press.
Dershowitz, N. and Plaisted, D. (1988). Equational Programming. In Hayes, J. E.,
Michie, D., and Richards, J., editors, Machine Intelligence 11, pages 21–56. Ox-
ford University Press.
Dijkstra, E. W. (1976). A Discipline of Programming. Prentice-Hall.

Bibliography
267
Dincbas, M., Van Hentenryck, P., Simonis, H., Aggoun, A., Graf, T., and Berthier, F.
(1988). The Constraint Logic Programming Language CHIP. In Intl. Conf. on
Fifth Generation Computer Systems, volume 2, pages 693–702.
Doets, K. (1994). From Logic to Logic Programming. MIT Press.
Drabent, W. (1995a). Completeness of SLDNF-resolution for Non-ﬂoundering Queries.
Submitted for publication.
Drabent, W. (1995b). What is Failure? An Approach to Constructive Negation. Acta
Informatica, 32(1):27–59.
Eder, E. (1985). Properties of Substitutions and Uniﬁcations. J. Symbolic Computa-
tion, 1:31–46.
Ershov, A. P. et al., editors (1988). Selected Papers from the Workshop on Partial
Evaluation and Mixed Computation. Special issue of New Generation Computing,
6(2-3).
F. Pereira, F. and Warren, D. H. D. (1980).
Deﬁnite Clause Grammars for Lan-
guage Analysis—A Survey of the Formalism and a Comparison with Augmented
Transision Networks. Artiﬁcial Intelligence, 13:231–278.
Fitting, M. (1985).
A Kripke-Kleene Semantics for Logic Programs.
J. of Logic
Programming, 2(4):295–312.
Gallaire, H., Minker, J., and Nicolas, J.-M. (1984). Logic and Databases: A Deductive
Approach. Computing Surveys, 16(2):153–185.
Gallier, J. and Raatz, S. (1986).
SLD-Resolution Methods for Horn Clauses with
Equality Based on E-Uniﬁcation. In Proc. 1986 Symp. on Logic Programming,
Salt Lake City, pages 168–179.
Galton, A. (1990). Logic for Information Technology. John Wiley & Sons.
Gazdar, G. and Mellish, C. (1989). Natural Language Processing in Prolog. Addison-
Wesley.
Gelfond, M. and Lifschitz, V. (1988). The Stable Model Semantics for Logic Program-
ming. In Proc. of Fifth Int’l Conf./Symp. on Logic Programming, Seattle, pages
1070–1080. MIT Press.
Gill, A. (1976). Applied Algebra for the Computer Sciences. Prentice-Hall.
Gregory, S. (1987). Parallel Logic Programming in PARLOG. Addison-Wesley.
Grimaldi, R. (1994). Discrete and Combinatorial Mathematics. Addison-Wesley.
Hansson, ˚A. and T¨arnlund, S.-˚A. (1981). Program Transformation by Data Structure
Mapping. In Clark, K. and T¨arnlund, S.-˚A., editors, Logic Programming, pages
117–122. Academic Press.

268
Bibliography
Hanus, M. (1992). Improving Control of Logic Programs by Using Functional Logic
Languages. In PLILP’92, Lecture Notes in Computer Science 631, pages 1–23.
Springer-Verlag.
Hanus, M. (1994). The Integration of Functions into Logic Programming: From Theory
to Practice. J. of Logic Programming, 19/20:583–628.
Haridi, S. and Brand, P. (1988).
ANDORRA Prolog — An Integration of Prolog
and Committed Choice Languages. In Proc. of Int’l Conf. on Fifth Generation
Computer Systems 88, Tokyo, pages 745–754.
Heintze, N., Jaﬀar, J., Michaylov, S., Stuckey, P., and Yap, R. (1987a). The CLP(ℜ)
Programmers Manual (version 2.0). Technical report, Dept. of Computer Science,
Monash University.
Heintze, N., Michaylov, S., and Stuckey, P. (1987b). CLP(ℜ) and Some Electrical
Engineering Problems.
In Proc. of Fourth Int’l Conf. on Logic Programming,
Melbourne, pages 675–703. MIT Press.
Herbrand, J. (1967). Investigations in Proof Theory. In van Heijenoort, J., editor,
From Frege to G¨odel: A Source Book in Mathematical Logic, 1879–1931, pages
525–581. Harvard University Press.
Hill, P. and Lloyd, J. (1988a). Analysis of Meta-Programs. Report CS-88-08, Dept.
of Computer Science, University of Bristol.
Hill, P. and Lloyd, J. (1988b). Meta-Programming for Dynamic Knowledge Bases.
Report CS-88-18, Dept. of Computer Science, University of Bristol.
Hill, P. and Lloyd, J. (1994). The G¨odel Programming Language. MIT Press.
Hill, R. (1974). LUSH-resolution and its Completeness.
DCL Memo 78, Dept. of
Artiﬁcial Intelligence, University of Edinburgh.
Hoare, C. A. R. (1985). Communicating Sequential Processes. Prentice-Hall.
Hopcroft, J. and Ullman, J. (1979). Introduction to Automata Theory, Language, and
Computation. Addison Wesley.
Huet, G. (1975). A Uniﬁcation Algorithm for Typed λ-Calculas. Theoretical Computer
Science, 1:27–57.
Huet, G. and Oppen, D. (1980). Equations and Rewrite Rules: A Survey. In Book,
R., editor, Formal Language Theory: Perspectives and Open Problems, pages
349–405. Academic Press.
Hullot, J. M. (1980). Canonical Forms and Uniﬁcation. In Proc. of 5th CADE, Les
Arcs, France.
Imbert, J.-L., Cohen, J., and Weeger, M.-D. (1993). An Algorithm for Linear Con-
straint Solving: Its Incorporation in a Prolog Meta-interpreter for CLP. J. of
Logic Programming, 16(3–4):195–234.

Bibliography
269
ISO (1995). Information Technology—Programming Language—Prolog—Part 1: Gen-
eral core. ISO/IEC DIS 13211-1:1995(E).
Jaﬀar, J. and Lassez, J.-L. (1987). Constraint Logic Programming. In Conf. Record
of 14th Annual ACM Symp. on POPL.
Jaﬀar, J., Lassez, J.-L., and Lloyd, J. (1983). Completeness of the Negation as Failure
Rule. In Proc. of IJCAI-83, pages 500–506, Karlsruhe.
Jaﬀar, J., Lassez, J.-L., and Maher, M. (1984). A Theory of Complete Logic Programs
with Equality. J. of Logic Programming, 1(3):211–223.
Jaﬀar, J., Lassez, J.-L., and Maher, M. (1986). Logic Programming Language Scheme.
In DeGroot, D. and Lindstrom, G., editors, Logic Programming, Functions, Re-
lations and Equations, pages 441–467. Prentice-Hall.
Jaﬀar, J. and Maher, M. (1994). Constraint Logic Programming: A Survey. J. of
Logic Programming, 19/20:503–581.
Jaﬀar, J. and Michaylov, S. (1987).
Methodology and Implementation of a CLP
System. In Proc. of Fourth Int’l Conf. on Logic Programming, Melbourne, pages
196–218. MIT Press.
Janson, S. (1994). AKL—A Multiparadigm Programming Language. Phd thesis, Up-
psala Univ, Computing Science Dept.
Kakas, A., Kowalski, R., and Toni, F. (1992). Abductive Logic Programming. J. of
Logic and Computation, 2.
Knight, K. (1989). Uniﬁcation: A Multidisciplinary Survey. ACM Computing Surveys,
21(1):93–124.
Komorowski, H. J. (1981).
A Speciﬁcation of an Abstract Prolog Machine and its
Application to Partial Evaluation. PhD thesis, Link¨oping University.
Komorowski, H. J. (1982). QLOG — The Programming Environment for Prolog in
Lisp. In Clark, K. and T¨arnlund, S.-˚A., editors, Logic Programming, pages 315–
324. Academic Press.
Kowalski, R. (1974). Predicate Logic as a Programming Language. In Information
Processing ‘74, pages 569–574. North-Holland.
Kowalski, R. (1979a). Algorithm = Logic + Control. Communications of the ACM,
22(7):424–436.
Kowalski, R. (1979b). Logic For Problem Solving. Elsevier, North-Holland, New York.
Kowalski, R. and Kuehner, D. (1972). Linear Resolution with Selection Function.
Artiﬁcial Intelligence, 2:227–260.
Kunen, K. (1987).
Negation in Logic Programming.
J. of Logic Programming,
4(4):289–308.

270
Bibliography
Kunen, K. (1989). Signed Data Dependencies in Logic Programming. J. of Logic
Programming, 7(3):231–245.
Lassez, J.-L., Maher, M., and Marriott, K. (1988). Uniﬁcation Revisited. In Minker, J.,
editor, Foundations of Deductive Databases and Logic Programming, chapter 15,
pages 587–626. Morgan Kaufmann.
Lassez, K., McAloon, K., and Yap, R. (1987). Constraint Logic Programming and
Option Trading. IEEE Expert, Fall:42–50.
Leler, W. (1988). Constraint Programming Languages. Addison Wesley.
Lloyd, J., Sonenberg, E. A., and Topor, R. (1987). Integrity Constraint Checking in
Stratiﬁed Databases. J. of Logic Programming, 4(4):331–344.
Lloyd, J. and Topor, R. (1984). Making Prolog More Expressive. J. of Logic Program-
ming, 1(3):225–240.
Lloyd, J. and Topor, R. (1985). A Basis for Deductive Database Systems. J. of Logic
Programming, 2(2):93–110.
Lloyd, J. and Topor, R. (1986). A Basis for Deductive Database Systems II. J. of
Logic Programming, 3(1):55–68.
Lloyd, J. W. (1987). Foundations of Logic Programming.
Springer-Verlag, second
edition.
Maher, M. (1987). Logic Semantics for a Class of Committed-choice Programs. In
Proc. of Fourth Int’l Conf. on Logic Programming, Melbourne, pages 858–876.
MIT Press.
Ma luszy´nski, J., Bonnier, S., Boye, J., Klu´zniak, F., K˚agedal, A., and Nilsson, U.
(1993). Logic Programs with External Procedures. In Apt, K., de Bakker, J., and
Rutten, J., editors, Current Trends in Logic Programming Languages, Integration
with Functions, Constraints and Objects. MIT Press.
Ma luszy´nski, J. and N¨aslund, T. (1989). Fail Substitutions for Negation as Failure. In
Proc. of North American Conf. on Logic Programming, Cleveland, pages 461–476.
MIT Press.
Marriott, K. and Søndergaard, H. (1988). Prolog Program Transformation by Intro-
duction of Diﬀerence-Lists. Technical Report 88/14, Department of Computer
Science, The University of Melbourne.
Marriott, K. and Søndergaard, H. (1989). On Prolog and the Occur Check Problem.
Sigplan Notices, 24(5):76–82.
Martelli, A. and Montanari, U. (1982). An Eﬃcient Uniﬁcation Algorithm. ACM
TOPLAS, 4(2):258–282.
Matsumoto, Y., Tanaka, H., Hirakawa, H., Miyoshi, H., and Yasukawa, H. (1983).
BUP: A Bottom-Up Parser Embedded in Prolog. New Generation Computing,
1(2):145–158.

Bibliography
271
Mellish, C. and Hardy, S. (1984). Integrating Prolog in the Poplog Environment. In
Campbell, J., editor, Implementations of Prolog, pages 147–162. Ellis Horwood.
Mendelson, E. (1987). Introduction to Mathematical Logic. Wadsworth & Brooks, 3rd
edition.
Minker, J. (1988). Perspectives in Deductive Databases. J. of Logic Programming,
5(1):33–60.
Moreno-Navarro, J. and Rodriguez-Artalejo, M. (1992).
Logic Programming with
Functions and Predicates:
The Language babel.
J. of Logic Programming,
12(3):191–223.
Nadathur, G. and Miller, D. (1995). Higher-order Logic Programming. In Gabbay, D.,
Hogger, C., and Robinson, A., editors, Handbook of Logic in Artiﬁcial Intelligence
and Logic Programming. Oxford Univ. Press. To appear.
Naish, L. (1985). Automating Control for Logic Programs. J. of Logic Programming,
2(3):167–184.
Naish, L. (1986). Negation and Control in Prolog. Lecture Notes in Computer Science
225. Springer-Verlag.
Nilsson, U. (1986). AID: An Alternative Implementation of DCGs. New Generation
Computing, 4(4):383–399.
Nilsson, U. and Ma luszy´nski, J. (1990). Logic, Programming and Prolog. John Wiley
& Sons, 1st edition.
O’Keefe, R. (1985).
On the Treatment of Cuts in Prolog Source-Level Tools.
In
Proc. 1985 Symp. on Logic Programming, Boston, pages 68–72.
O’Keefe, R. (1990). The Craft of Prolog. MIT Press.
Paterson, M. and Wegman, M. (1978). Linear Uniﬁcation. J. Computer and System
Sciences., 16(2):158–167.
Pereira, F. and Shieber, S. (1987). Prolog and Natural-Language Analysis. CSLI.
Pereira, F. and Warren, D. H. D. (1983). Parsing as Deduction. In Proc. 21st Annual
Meeting of the Assoc. for Computational Linguistics, pages 137–144.
Pereira, L., Pereira, F., and Warren, D. H. D. (1979). User’s Guide to DECsystem-10
Prolog. DAI. Occasional paper no. 15, Dept. of Artiﬁcial Intelligence, University
of Edinburgh.
Plaisted, D. (1984). The Occur-Check Problem in Prolog. In Proc. 1984 Symp. on
Logic Programming, Atlantic City, pages 272–280.
Prawitz, D. (1960). An Improved Proof Procedure. Theoria, 26:102–139.
Przymusinski, T. (1988a).
On the Declarative Semantics of Logic Programs with
Negation. In Minker, J., editor, Foundations of Deductive Databases and Logic
Programming, pages 193–216. Morgan Kaufmann, Los Altos.

272
Bibliography
Przymusinski, T. (1988b).
Perfect Model Semantics.
In Proc. of Fifth Int’l
Conf./Symp. on Logic Programming, Seattle, pages 1081–1096. MIT Press.
Przymusinski, T. (1989). Every Logic Program has a Natural Stratiﬁcation and an
Iterated Fixed Point Model.
In Proc. of the 8th Symposium on Principles of
Database Systems, pages 11–21.
Ramakrishnan, R. (1988). Magic Templates: A Spellbinding Approach to Logic Pro-
gramming. In Proc. of Fifth Int’l Conf./Symp. on Logic Programming, Seattle,
pages 140–159. MIT Press.
Ramakrishnan, R., editor (1995). Applications of Logic Databases. Kluwer Academic
Publishers.
Reiter, R. (1978). On Closed World Data Bases. In Gallaire, H. and Minker, J.,
editors, Logic and Databases, pages 55–76. Plenum Press, New York.
Reiter, R. (1984). Towards a Logical Reconstruction of Relational Database Theory. In
Brodie, M. et al., editors, On Conceptual Modelling: Perspectives from Artiﬁcial
Intelligence, Databases and Programming Languages, pages 191–233. Springer.
Robinson, J. A. (1965). A Machine-Oriented Logic Based on the Resolution Principle.
J. of ACM, 12:23–41.
Robinson, J. A. (1979). Logic: Form and Function. Edinburgh University Press.
Robinson, J. A. and Sibert, E. (1982). LOGLISP: Motivation, Design and Imple-
mentation. In Clark, K. and T¨arnlund, S.-˚A., editors, Logic Programming, pages
299–314. Academic Press.
Rogers, Jr., H. (1967). Theory of Recursive Functions and Eﬀective Computability.
McGraw-Hill.
Ross, K. (1992). A Procedural Semantics for Well-founded Negation in Logic Pro-
grams. J. of Logic Programming, 13(1):1–22.
Roussel, P. (1975). Prolog: Manuel de R´ef´erence et d’Utilisation. Technical report,
Group d’Intelligence Artiﬁcielle, Marseille.
Saraswat, V. A. (1993). Concurrent Constraint Programming. MIT Press.
Schulte, C., Smolka, G., and W¨urtz, J. (1994). Encapsulated Search and Constraint
Programming in Oz. In Second Workshop on Principles and Practice of Constraint
Programming, Lecture Notes in Computer Science 874, pages 134–150. Springer-
Verlag.
Scott, D. (1976). Data Types as Lattices. SIAM J. Comput., 5(3):522–587.
Shapiro, E. (1983a). A Subset of Concurrent Prolog and Its Interpreter. Technical
Report TR–003, ICOT.

Bibliography
273
Shapiro, E. (1983b). Logic Programs with Uncertainties: A Tool for Implementing
Rule-based Systems. In Proc. 8th Int’l Joint Conf. on Artiﬁcial Intelligence, pages
529–532, Karlsruhe.
Shapiro, E. (1986).
Concurrent Prolog:
A Progress Report.
IEEE Computer,
August:44–58.
Shapiro, E., editor (1988). Concurrent Prolog: Collected Papers. MIT Press.
Shapiro, E. (1989). The Family of Concurrent Logic Programming Languages. Com-
puting Surveys, 21(3):413–510.
Shepherdson, J. (1988). Negation in Logic Programming. In Minker, J., editor, Foun-
dations of Deductive Databases and Logic Programming, pages 19–88. Morgan
Kaufmann, Los Altos.
Shoenﬁeld, J. (1967). Mathematical Logic. Addison-Wesley.
Siekmann, J. (1984). Universal Uniﬁcation. In Shostak, R. E., editor, Proc. of 7th
CADE, pages 1–42.
Siekmann, J. and Wrightson, G., editors (1983a). Automation of Reasoning I. Springer-
Verlag.
Siekmann, J. and Wrightson, G., editors (1983b).
Automation of Reasoning II.
Springer-Verlag.
Slagle, J. R. (1974). Automated Theorem-Proving for Theories with Simpliﬁers, Com-
mutativity and Associativity. J. of ACM, 28(3):622–642.
Snyder, W. and Gallier, J. (1990). Higher Order-Uniﬁcation Revisited: Complete Sets
of Transformations. In Kirchner, C., editor, Uniﬁcation. Academic Press.
St¨ark, R. (1990). A Direct Proof for the Completeness of SLD-resolution. In CSL’89,
Lecture Notes in Computer Science 440, pages 382–383. Springer-Verlag.
St¨ark, R. (1992). The Proof Theory of Logic Programs with Negation. Phd thesis,
Univ of Bern.
St¨ark, R. (1993). Input/Output Dependencies of Normal Logic Programs. J. of Logic
and Computation. To appear.
Steele, G. L. (1980). The Deﬁnition and Implementation of a Computer Programming
Language based on Constraints. PhD thesis, MIT AI–TR 595, M.I.T.
Sterling, L. and Beer, R. (1989). Metainterpreters for Expert System Construction.
J. of Logic Programming, 6(1):163–178.
Sterling, L. and Lakhotia, A. (1988). Composing Prolog Meta-Interpreters. In Proc. of
Fifth Int’l Conf./Symp. on Logic Programming, Seattle, pages 386–403. MIT
Press.
Sterling, L. and Shapiro, E. (1994). The Art of Prolog. MIT Press, 2nd edition.

274
Bibliography
Stroetmann, K. (1993). A Completeness Result for SLDNF-resolution. J. of Logic
Programming, 15(4):337–355.
Subrahmanyam, P. A. and You, J.-H. (1986). FUNLOG: A Computational Model In-
tegrating Logic Programming and Functional Programming. In DeGroot, D. and
Lindstrom, G., editors, Logic Programming, Functions, Relations and Equations,
pages 157–198. Prentice-Hall.
Tamaki, H. and Sato, T. (1986). OLD Resolution with Tabulation. In Shapiro, E.,
editor, Proc. of Third Int’l Conf. on Logic Programming, London, Lecture Notes
in Computer Science 225, pages 84–98. Springer-Verlag.
Tarski, A. (1955).
A Lattice Theoretical Fixpoint Theorem and Its Applications.
Paciﬁc J. Math, 5:285–309.
Thom, J. and Zobel, J. (1987). NU-Prolog Reference Manual. Technical Report 86/10,
Department of Computer Science, University of Melbourne. Revised May 1987.
Ueda, K. (1985). Guarded Horn Clauses. Technical Report TR–103, ICOT.
Ullman, J. D. (1985). Implementation of Logical Query Languages for Databases.
ACM Trans. Database Systems, 10(3):289–321.
Ullman, J. D. (1988). Principles of Database and Knowledge-base Systems, volume I.
Computer Science Press.
Ullman, J. D. (1989). Principles of Database and Knowledge-base Systems, volume II.
Computer Science Press.
van Dalen, D. (1983). Logic and Structure. Springer-Verlag, second edition.
van Emden, M. and Kowalski, R. (1976).
The Semantics of Predicate Logic as a
Programming Language. J. of ACM, 23(4):733–742.
Van Gelder, A. (1988). Negation as Failure Using Tight Derivation for General Logic
Programs. In Minker, J., editor, Foundations of Deductive Databases and Logic
Programming, pages 149–176. Morgan Kaufmann, Los Altos.
Van Gelder, A., Ross, K., and Schlipf, J. (1991). The Well-Founded Semantics for
General Logic Programs. J. of the ACM, 38(3):620–650.
Van Hentenryck, P. (1989). Constraint Satisfaction in Logic Programming. MIT Press.
Vieille, L. (1989). Recursive Query Processing: The Power of Logic. Theoretical Comp.
Sci., 69(1):1–53.
Walinsky, C. (1989). CLP(Σ∗): Constraint Logic Programming with Regular Sets.
In Proc. of Sixth Int’l Conf. on Logic Programming, Lisbon, pages 181–198. MIT
Press.
Warren, D. S. (1984). Database Updates in Pure Prolog. In Proc. of Int’l Conf. on
Fifth Generation Computer Systems 84, Tokyo, pages 244–253. North-Holland.

Bibliography
275
Warren, D. S. (1992). Memoing for Logic Programs. CACM, 35(3):93–111.
Zhang, J. and Grant, P. W. (1988).
An Automatic Diﬀerence-list Transformation
Algorithm for Prolog. In Proc. of ECAI’88, pages 320–325.

276
Bibliography

Index
Dom(x), 15
F ≡G, 12
MP , 28
P |= F, 11
P ⊢F, 14
Range(x), 15
S∗, 251
Sn, 251
S1 ∩S2, 251
S1 ∪S2, 251
S1 \ S2, 251
S1 ⊆S2, 251
S1 × S2, 251
TP (x), 29
TP ↑α, 30
UP /≡E, 208
, 21
Z, 251
\+, 92
N, 251
Q, 251
R, 251
ϵ, 14, 163
∃F, 7
∀F, 7
pAq, 137
ℑ|=ϕ Q, 9
σ ⪯θ, 38
, 21
⟨x1, . . . , xn⟩, 251
?, 251
ϕℑ(t), 8
℘(S), 251
f(∞), 42
f/n, 5
f: S1 →S2, 252
f −1, 252
f2 ◦f1, 252
p/n, 6
x ∈S, 251
BA, 24
UA, 24
comp(P), 62
magic(P), 234
ground(P), 29
|ℑ|, 7
abduction, 152
AKL, 249
ALF, 248
allowed, 77
alphabet, 4, 5
answer constraint, 218
arithmetic, 93–97, 244
arity, 4, 5
asserta/1, 144
assertz/1, 144
atom, 6
277

278
Index
attribute, 102
automated reasoning, 241
BABEL, 248
backtracking, 52, 88
backward-chaining, 152
body, 196
body of clause, 20
bound, 7
breadth-ﬁrst, 53, 185
CAL, 223, 249
canonical model, 69, 78
cartesian product, 105, 251
CHIP, 222, 249
clause, 21
deﬁnite, 20
general, 67
guarded, 197
clause/2, 143
closed, 7
closed world assumption, 60, 77, 243
closure
existential, 7
reﬂexive, 112
symmetric, 111
transitive, 111
universal, 7
CLP(Σ∗), 249
CLP(X), 249
CLP(BNR), 222, 249
CLP(R), 249
codomain, 252
collecting proofs, 153
commit operator, 196, 197, 247
completeness, 14
of equational logic, 204
completion, 61–65, 243
three-valued, 75–77
composition, 252
computation rule, 43
independence of, 47, 56
Prolog’s, 45
conclusion, 13
concurrent constraint languages, 249
concurrent logic programming, 196
Concurrent Prolog, 197, 247
conditional answer, 218
conjunction, 4, 6
consistent, see proof tree
constant, 4, 5
constrain-and-generate, 225
constraint, 214
Boolean, 223
equational, 226
monoid, 226
numerical, 224
constraint logic programming, 213–227
constraint store, 217
context-free grammars, 163
coroutining, 193
cut, 87–92, 244
green, 91
red, 91
cut-node, 88
cwa, see closed world assumption
D-interpretation, 216
D-model, 216
database
extensional, 103
intensional, 103
database relation, 101
datalog, 103
DCG, 171
deadlock, 196
declarative, 3, 19
deductive databases, 103–104, 229–239,
244
deﬁnite
clause, 20
goal, 23, 35
program, 19, 21, 242
program with equality, 95, 207
Deﬁnite Clause Grammar, 171–176, 246
DeMorgan’s law, 13, 36
depth-ﬁrst, 52, 185
depth-ﬁrst-iterative-deepening, 147
derivability, 14
derivation
of CFG, 164
of DCG, 171
derivation tree, 53, 216
determinism, 36

Index
279
diﬀerence, 105
diﬀerence list, 129–131, 167, 245
disjunction, 6
domain, 7, 101, 252
domain closure assumption, 108
E-base, 208
E-interpretation, 208
E-uniﬁcation, 95, 204–207
E-uniﬁer, 95, 205
E-universe, 208
Earley deduction, 250
elementary tree, 53
empty goal, 23
equality theory, 95, 204
equation, 37, 53, 204, 226
equivalence, 6
fact, 19
failed derivation, 47
fair derivation, 64
ﬁnite failure
completeness of, 64
soundness of, 64
ﬁxed point, 29, 81, 242
ﬂat, 197
ﬂoundering, 73
formula, 4, 6
atomic, 6
forward-chaining, 152
free, 7
free equality axioms, 63
function, 5, 252
bijection, 252
inverse, 252
partial, 252
total, 252
functor, 5
FUNLOG, 248
G¨odel, 246
general
clause, 67
goal, 65
program, 67
generate-and-test, 226
GHC, 247
goal
deﬁnite, 23
empty, 23
general, 65
ground, 7
guard, 196, 247
Guarded Horn Clauses, 247
head of clause, 20
Herbrand
base, 24
interpretation, 25
model, 26
partial interpretation, 76
universe, 24
Horn clause, 242
IC-Prolog, 247
immediate consequence operator, 29, 69,
78, 209, 230, 242
imperative, 3
implication, 4, 6
inconsistent, 14
inductive deﬁnition, 125
inference engine, 149
inference rule, 13, 204
inﬁnite failure, 77
instance, 15
integrity constraint, 245
interpretation, 7
partial, 76
supported, 78
interrogative, 3
knowledge-base, 149
λ-Prolog, 248
language, 135
meta, 135
object, 135
LEAF, 248
lemmas, 145
LIFE, 249
list, 120–129
head of, 120
tail of, 120
literal, 21
locally stratiﬁed programs, 243
log, 181

280
Index
logical
connective, 4, 6
consequence, 11, 76, 204
equivalence, 12
LOGLISP, 248
magic sets, 249
magic template, 234, 249
magic transformation, 234
main tree, 71
meta-circular interpreter, 136
meta-interpreter, 136
Metamorphosis Grammars, 246
mgu, see uniﬁer, most general
model, 10, 24, 204
canonical, 69, 78
Herbrand, 24–30
intended, 21, 28
intersection property, 28
least, 29
least Herbrand, 27, 30, 83
minimal, 29
standard, 69, 83
well-founded, 80
modus ponens, 13, 36
MYCIN, 150
naive evaluation, 231
narrowing, 207
natural join, 106
negation, 4, 6, 59–85, 90, 92, 143, 243
as failure, 60, 243
constructive, 244
unsafe use of, 157, 186
nondeterminism, 36
don’t care, 196
don’t know, 196
nonterminal
of CFG, 163
of DCG, 171
NU-Prolog, 244
occur-check, 41, 50, 130
OLDT-resolution, 250
operational semantics, 33
Oz, 249
pair, 251
parallelism
AND, 193
OR, 196
PARLOG, 247
partial evaluation, 246
partial order, 112
Peano axioms, 93
perfect model, 243
POPLOG, 248
predicate, 6
predicate symbol, 4
premise, 13
process, 193
production rule, 150
of CFG, 163
projection, 106
Prolog, 5, 41, 74, 87–98, 143–146, 175
Prolog II, 249
Prolog III, 222, 249
proof tree, 53–56, 217
consistent, 54
QLOG, 248
quantiﬁer, 6
existential, 4
universal, 4
query-language, 107
query-the-user, 154
rational tree, 227
recursive data structure, 119
reductio ad absurdum, 36
reﬂexive, see relation
relation, 3, 252
anti-symmetric, 109, 252
asymmetric, 109
database, 101
equivalence, 112, 252
identity, 252
partial order, 252
reﬂexive, 109, 252
symmetric, 109, 252
transitive, 109, 252
relation scheme, 102
relational algebra, 104–107
relational databases, 101–103
Relational Language, 247

Index
281
renaming, see substitution, renaming
resolution, 33, 43
retract/1, 146
rule, 19
safe computation rule, 67
satisﬁable, 10, 217
selection, 106
selection function, 43
self-interpreter, 136
semantics, 5
of formulas, 9
of terms, 8
semi-naive evaluation, 233
shell, 150
SICStus Prolog, 223
sideways information passing, 238, 250
SLD-AL-resolution, 250
SLD-derivation, 44
complete, 47
failed, 47
inﬁnite, 47
SLD-refutation, 46
SLD-resolution, 19, 33–53, 242
completeness of, 51
soundness of, 49
SLD-tree, 47, 235
ﬁnitely failed, 60
SLDE-resolution, 210
SLDNF-derivation, 71
ﬁnitely failed, 66, 72
inﬁnite, 71
refutation, 72
stuck, 66, 72
SLDNF-forest, 70
SLDNF-resolution, 243
completeness of, 77
for deﬁnite programs, 65–67
for general programs, 70–74
soundness of, 66, 74, 76
SLDNF-tree, 71
SLS-resolution, 83, 244
solution, 37
solved form, 38, 54, 219
algorithm, 40
soundness, 13, 14, 21
of equational logic, 204
stable models, 244
standard model, 69
state, 179
state-space, 179
stratiﬁed program, 68
string, 251
structure
algebraic, 7
subgoal, 23
subsidiary tree, 71
substitution, 14
application of, 15
composition of, 15
computed, 45
computed answer, 46
empty, 14
generality of, 38
idempotent, 15
renaming, 42
subsumption, 238
supplementary magic, 237, 250
symmetric, see relation
syntax, 5
tabulation, 250
term, 6
compound, 5, 114
terminal
of CFG, 163
of DCG, 171
three-valued logic, 75
transitive, see relation
tuple, 4, 251
type, 103
type declaration, 104
uncertainty, 149
unfolding, 168
unfounded set, 79
uniﬁcation, 37–43, 242
uniﬁer, 35, 38
most general, 38
union, 105
unit-clause, see fact
universe, 3
unsatisﬁable, 10, 12, 36
update, 245

282
Index
valuation, 8, 9
variable, 4, 5
local, 218
read-only, 194
write-enabled, 194
view, 104
well-founded semantics, 77–83, 243

