Contents
Preface
iii
1
Finite discrete sketches
1
1.1
Sketches with sums
1
1.2
The sketch for ¯elds
3
1.3
Term algebras for FD sketches
5
2
More about sketches
12
2.1
Finite limit sketches
12
2.2
Initial term models of FL sketches
16
2.3
The theory of an FL sketch
19
2.4
General de¯nition of sketch
21
3
The category of sketches
26
3.1
Homomorphisms of sketches
26
3.2
Parametrized data types as pushouts
28
3.3
The model category functor
33
4
Fibrations
38
4.1
Fibrations
38
4.2
The Grothendieck construction
43
4.3
An equivalence of categories
48
4.4
Wreath products
51
5
Toposes
56
5.1
De¯nition of topos
57
5.2
Properties of toposes
60
5.3
Is a two-element poset complete?
64
5.4
Presheaves
66
5.5
Sheaves
67
5.6
Fuzzy sets
72
5.7
External functors
75
5.8
The realizability topos
79
i

ii
Contents
Answers to Exercises
83
Solutions for Chapter 1
83
Solutions for Chapter 2
85
Solutions for Chapter 3
87
Solutions for Chapter 4
88
Solutions for Chapter 5
92
Bibliography
97
Index
102

Preface
This is the electronic supplement to Category Theory for Computing Sci-
ence, second edition, Prentice-Hall International, 1995, ISBN 0-13-
323809-1. It consists of (revisions of) ¯ve chapters from the ¯rst edition of that
book, as well as continuing updates of the ¯rst and second editions.
The chapters included here are, as numbered in the ¯rst edition, Chapters 7
(Finite discrete sketches), 9 (More about sketches), 10 (The category of sketches),
11 (Fibrations) and 14 (Toposes).
References, both in the published book and here to material in this electronic
supplement are pre¯xed by ` ES', while references to the printed book are un-
adorned. Thus a reference to 4.5 of Chapter 3 is a reference to Section 4.5 of
Chapter 3 of the printed book, while references to Section 4.5 of Chapter ES3 is
a reference to Section 4.5 of Chapter 3 of this supplement. A reference without a
chapter number refers, as usual, to the current chapter.
iii

1
Finite discrete sketches
This chapter discusses FD (¯nite discrete) sketches, which are a more general kind
of sketch than that described in Chapter 7. The sketches described here allow
the speci¯cation of objects which are sums as well as products. Section ES 1.1
introduces these sketches. Section ES 1.2 gives a detailed description of the sketch
for ¯elds as an example of an FD sketch. In Section ES 1.3, we show how to modify
initial algebra construction so that it works for FD sketches. FD sketches have
theories, too, but discussion of that is postponed until Chapter ES 2.
1.1 Sketches with sums
Using sum cocones as well as product cones in a sketch allows one to express
alternatives as well as n-ary operations.
1.1.1
A ¯nite discrete sketch, or FD sketch,
= ( ;
;
;
), consists
of a ¯nite graph
, a ¯nite set of ¯nite diagrams
, a ¯nite set
of discrete
cones with ¯nite bases, and a ¯nite set
of discrete cocones with ¯nite bases.
A model of the FD sketch
in Set is a graph homomorphism M :
¡! Set
which takes the diagrams in
to commutative diagrams, the cones in
to
product cones, and the cocones in
to sum cocones.
1.1.2 The sketch for lists
The FD sketch for ¯nite lists illustrates how FD
sketches can be used to specify a data type which has an exceptional case for
which an operation is not de¯ned. (Compare 7.1.6.) The graph has nodes 1, d (the
+
data), l (the lists) and l
(the nonempty lists). There are no diagrams. There is a
cone with empty base expressing the fact that 1 must become a terminal object
in a model, another cone
+
l
¡
@
head
tail
¡
@
¡ª
@R
d
l
and one cocone
+
1
l
@
¡
@
¡
@R
¡ª
l
1

2
Finite discrete sketches
+
These can be summed up in the expressions l
= d £ l (a nonempty list has a
+
datum as head and a list as tail) and l = 1 + l : (a list is either the empty list {
the single member of the terminal set { or a nonempty list). The fact that a sum
becomes a disjoint union in a model in Set enables us to express alternatives in
the way exhibited by this description. We thereby avoid the problem mentioned
in 7.1.6: we can de¯ne head for only nonempty lists because we have a separate
sort for nonempty lists.
If S is any ¯nite set, there is a model M of this sketch for which M(d) = S,
M(1) is the singleton set containing only the empty list hi, M(l) is the set of ¯nite
+
lists of elements of S, and M(l ) is the set of ¯nite nonempty lists of elements
of S. M(head) and M(tail) pick out the head and tail of a nonempty list. This is
an initial term algebra (to be de¯ned in Section ES 1.3) for the sketch extended
by one constant for each element of S.
1.1.3
Given a ¯nite set S, the model M just mentioned is certainly not the only
model of the sketch for which M(d) is S. Another model has M(l) all ¯nite and
+
in¯nite lists of elements of S, with M(l ) the nonempty lists and M(head) and
M(tail) as before. This model contains elements inaccessible by applying opera-
tions to constants: you cannot get in¯nite lists by iterating operations starting
with constants. They are junk as de¯ned in 7.6.3.
1.1.4 The sketch for natural numbers
We will now modify the sketch 7.1.5
in a way which shows how FD sketches can model over°ow.
The graph contains nodes we will call 1, n, n
and n + n
, which we
over
over
interpret, respectively, as a one-element set, a set of natural numbers (of which
there may be only ¯nitely many), an over°ow element and the set of all natural
numbers. The only cone is the one implicit in the name 1: the cone has 1 as the
vertex and the empty base. There is similarly a (discrete) cocone implicit in the
name n +n
. There is a constant operation zero : 1 ¡! n and a unary operation
over
succ : n ¡! n + n
. There are no diagrams.
over
There are many models of this sketch in Set. Here are three of them. They
are all term models.
1.1.5
The ¯rst model we consider of this sketch is the set of natural numbers.
The value of zero is 0 and succ(i) = i + 1. The model takes n
to the empty set.
over
This model illustrates the fact that models are permitted to take the empty set
as value on one or more nodes. Classical model theorists have not usually allowed
sorts in a model to be empty.
1.1.6
The second model takes n to the set of integers up to and including an
upper bound N. The value at n
is a one- element set we will call 1, although
over
any other convenient label (including N + 1) could be used instead. As above,

1.2 The sketch for ¯elds
3
the value of zero is 0. As for succ, it is de¯ned by succ(i) = i + 1 for i < N, while
succ(N) = 1. Note that the domain of succ does not include 1.
1.1.7
The third model takes for the value of n also the set of integers up to a
¯xed bound N. The value of zero is again 0 and of n
is empty. The operation
over
succ is de¯ned by succ(i) = i + 1, for i < N while succ(N) = 0. This is arithmetic
modulo n.
This third model could be varied by letting succ(N) = N or, for that matter,
any intermediate value. This shows that these models really have at least two
parameters: the value of N and what happens to the successor of N.
1.1.8 Exercises
1. Construct an FD sketch whose only model is the two-element Boolean algebra.
2. Give an example of a sketch which has no models in Set. (Hint: In Set,
1 + 1 6
= 1.)
1.2 The sketch for ¯elds
Another example of an FD sketch is the sketch for the mathematical structure
known as a ¯eld. The concept of ¯eld abstracts the properties of the arithmetic
of numbers. We will describe it in some detail here. This section is used later only
as an example in Section ES 1.3. Rather than de¯ne `¯eld' we will describe the
sketch and say that a ¯eld is a model of the sketch in sets.
The nodes are 1; u; f; f £ f and f £ f £ f. There are operations
FO{1 0 : 1 ¡! f.
FO{2 1 : 1 ¡! u.
FO{3 + : f £ f ¡! f.
FO{4 ¤ : f £ f ¡! f.
FO{5 ¡ : f ¡! f.
¡1
FO{6 ( )
: u ¡! u.
FO{7 j : u ¡! f.
The reader should note that the two 1's in FO{2 above are, of course, di®erent.
One of them is the name of a node and the other of an operation. This would
normally be considered inexcusable. The reasons we do it anyway are (a) each
usage is hallowed by long tradition and (b) because they are of di®erent type,
there is never any possibility of actual clash. The reader may think of it as an
early example of overloading.
The diagrams are:
±
±
FE{1 (associativity of +): +
(id£+) = +
(+ £ id) : f £ f £ f ¡! f.

4
Finite discrete sketches
±
±
FE{2 (associativity of ¤): ¤
(id£¤) = ¤
(¤ £ id) : f £ f £ f ¡! f.
±
FE{3 (commutativity of +): +
hp ;p i = + : f £ f ¡! f.
2
1
±
FE{4 (commutativity of ¤): ¤
hp ; p i = ¤ : f £ f ¡! f.
2
1
±
±
±
±
FE{5 (additive unit): +
hid;0
hii = +
h0
hi; idi = id : f ¡! f
±
±
±
±
±
±
FE{6 (multiplicative unit): ¤
hj; j
1
hii = ¤
hj
1
hi;ji = j : u ¡! f
±
±
±
FE{7 (additive inverse): +
hid;¡i = +
h¡; idi = 0
hi : f ¡! f
¡1
¡1
±
±
±
±
±
FE{8 (multiplicative inverse): ¤
(j £ j)
hid; ()
i = ¤
(j £ j)
h()
; idi = 1
hi : u ¡! u
±
±
±
FE{9 (distributive): +
(¤ £ ¤)
hp ; p ; p ;p i = ¤
(id£+);
1
2
1
3
±
±
±
+
(¤ £ ¤)
hp ; p ;p ; p i = ¤
(+ £ id) : f £ f £ f ¡! f.
1
3
2
3
There are cones de¯ned implicitly and one cocone:
1
u
@
¡
@
¡ j
0
@
¡
@R
¡ª
f
Intuitively, this says that each element of a ¯eld is either zero or else is an element
of u. u is interpreted as the set of multiplicatively invertible elements in a model.
1.2.1
An example of a ¯eld is the set of ordinary rational numbers. Expressed
as a model M of the sketch, the numbers M(0) and M(1) are the usual ones,
M(f) and M(u) are the sets of all rationals and nonzero rationals, respectively,
and M(j) is the inclusion. The arithmetic operations are the usual ones. Other
familiar examples are the real and complex numbers.
1.2.2
In building a model of this sketch, we would have to start with the ele-
ments 0 and 1 and then begin adding and multiplying them to get new elements.
For example, we could let 2 = 1 + 1. Now since M(f) = M(u) + f0g, we have
to decide whether 2 2 M(u) or 2 2 f0g, that is, whether or not 2 = 0. Quite
possibly, the only ¯elds the reader has seen have the property that 2 6
= 0. Even
so, one cannot exclude out of hand the possibility that 2 = 0 and it is in fact
possible: there is a model of this sketch whose value at f is f0;1g with the values
of the operations being given by the tables:
+
0
1
¤
0
1
0
0
1
0
0
0
1
1
0
1
0
1
(These tables are addition and multiplication (mod2).) If, on the other hand,
2 6
= 0, we can form 3 = 1 + 2. The same question arises: is 3 = 0 or not? It is not
hard to write down a ¯eld in which 3 = 0.

1.3 Term algebras for FD sketches
5
Suppose that neither 2 nor 3 is 0? We would de¯ne 4 = 1 + 3 (and prove, by
the way, that 2 + 2 = 2 ¤ 2 = 4) and ask whether 4 = 0. It turns out that if 2 6
= 0
then 4 6
= 0. In fact, it is not hard to show that any product of elements of u also
lies in u. Thus the ¯rst instance of an integer being 0 must happen at a prime.
But, of course, it need never happen, since no number gotten by adding 1 to itself
a number of times is zero in the rational, real or complex ¯eld.
1.2.3
A homomorphism between ¯elds must preserve all operations. Since it
¡1
preserves the operation ( )
, no nonzero element can be taken to zero. Conse-
quently, two distinct elements cannot go to the same element since their di®erence
would be sent to zero. Thus ¯eld homomorphisms are injective.
From this, it follows that there can be no ¯eld that has a homomorphism
both to the ¯eld of two elements and to the rationals, since in the ¯rst 1 + 1 = 0,
which is not true in the second. This implies that the category of ¯elds and ¯eld
homomorphisms does not have products.
1.2.4 Exercises
1. Prove that in a ¯eld, if two elements each have multiplicative inverses, then so
does their product. Deduce that if 4 = 0, then 2 = 0.
2. Prove that the next to last sentence of ES 1.2.3 implies that the category of
¯elds and ¯eld homomorphisms does not have products.
1.3 Term algebras for FD sketches
A complication arises in trying to extend the construction of initial term algebras
to FD sketches. As we see from the examples of natural numbers and ¯elds, an
operation taking values in the vertex of a discrete cocone forces us to choose in
which summand the result of any operation shall be. The choice, in general, leads
to nonisomorphic term models which are nevertheless initial in a more general
sense which we will make precise.
1.3.1 D½mons
How to make the choice? Clearly there is no systematic way.
One way of dealing with the problem is to take all choices, or at least to explore
all choices. In the example in Section ES 1.2 of ¯elds, we mentioned that not
all choices are possible; once 2 6
= 0, it followed that also 4 6
= 0. (Recall that in
that example, saying that something is zero is saying that it is in one of two
summands.)
More generally, suppose we have an FD sketch and there is an operation s : a
¡! b and a cocone expressing b = b + b + :: : + b . If we are building a model M
1
2
n
of this sketch and we have an element x 2 M(a), then M(s)(x) 2 M(b), which
means that we must have a unique i between 1 and n for which M(s)(x) 2 M(b ).
i
(For simplicity, this notation assumes that M(b) is the actual union of the M(b ).)
i

6
Finite discrete sketches
Now it may happen that there is some equation that forces it to be in one
rather than another summand, but in general there is no such indication. For
example, the result of a push operation on a stack may or may not be an over°ow,
depending on the capacity of the machine or other considerations. Which one it
is determines the particular term model we construct and it is these choices that
determine which term model we will get.
Our solution is basically to try all possible sequences of choices; some such
sequences will result in a model and others will abort. Thus as we explore all
choices, some will eventually lead to a model; some will not. The theoretical tool
we use to carry out this choice we call a d½mon. Just as a Maxwell D½mon
chooses, for each molecule of a gas, whether it goes into one chamber or another,
our d½mon chooses, for each term of a model, which summand it goes into. The
following description spells this out precisely.
1.3.2 De¯nition
Let
be an FD sketch and suppose the maximum number
of nodes in the base of any cocone is ·. A d½mon for
is a function d from
the set of all strings in the alphabet A
(see 7.6.5) of the underlying FP sketch
(in other words, forget the cocones) to the initial segment f1:: ·g of the positive
integers.
1.3.3
We will use a d½mon this way. We assume that the nodes in the base of
each cocone of
are indexed by 1; 2; :: :; k where k · · is the number of nodes
in that cocone. In constructing an initial algebra, if a string w must be in a sort
which is the vertex of a cocone (hence in the model it must be the disjoint union
of no more than · sorts), we will choose to put it in the D(w)th summand. If
D(w) > k, the construction aborts. We will make this formal.
1.3.4 Construction of initial term models for FD sketches
This con-
struction includes the processes in 4.7.10 and 7.6.5; we repeat them here modi¯ed
to include the e®ects of a d½mon D. The alphabet is the same as in 7.6.5.
If a node b is the vertex of a cocone with k = k(b) summands, the summands
1
k
i
i
will be systematically denoted b ;: :: ; b and the inclusion arrows u : b ¡! b for
1
i = 1; :: : ; k. If b is not the vertex of a cocone, then we take k(b) = 1, b = b
1
and u = id . We denote the congruence relation by » and the congruence class
b
containing the element x by [x]. Rules FD{ES 3 through FD{ES 6 refer to a cone
C in
of the form:
q
¡
@
p
p
p
¡
@
1
i
n
¡
@
¡ª
?
@R
a
a
a
¢¢ ¢
¢¢ ¢
1
i
n
i
i
i
i
FD{1 If u : a ¡! a is an inclusion in a cocone and [x] 2 I(a ), then [u x] 2 a and
i
i
I(u )[x] = [u x]. (Thus we ignore the wishes of the d½mon in this case.)

1.3 Term algebras for FD sketches
7
i
FD{2 Suppose f : a ¡! b in
, f is not an arrow of the form u , and [x] 2 I(a). Let
j = D(fx) (we ask the d½mon what to do). If j > k(b), the construction
j
j
aborts. Otherwise, we let [fx] 2 I(b ) and I(f)[x] = [u fx].
FD{3 For i = 1;: : :; n, let [x ] be a term in I(a ). Let
i
i
j = D(C(x ; : :: ;x ))
1
n
j
If j > k(q), the construction aborts. If not, put [C(x ;: :: ;x )] in I(q ).
1
n
FD{4 If for i = 1;: : :; n, [x ] and [y ] are elements in I(a ) for which [x ] = [y ],
i
i
i
i
i
i = 1;: :: ;n, then
[C(x ; :: :; x )] = [C(y ; :: : ;y )]
1
n
1
n
FD{5 For i = 1;: : :; n, I(p )([C(x ;: : :; x )]) = [x ].
i
1
n
i
FD{6 For x 2 I(q),
[x] = [C(p x; : :: ;p x)]
1
n
FD{7 If hf ; : :: ; f i and hg ; : :: ; g i are paths in a diagram in
, both going
1
m
1
k
from a node labeled a to a node labeled b, and [x] 2 I(a), then
±
±
±
±
±
±
(If
If
:: :
If )[x] = (Ig
Ig
:: :
Ig )[x]
1
2
m
1
2
k
in I(b). If
D(f f :: :f x) 6
= D(g : : :g x)
1
2
m
1
k
±
±
±
±
±
±
(causing (If
If
: : :
If )[x] and (Ig
Ig
: ::
Ig )[x] to be in two
1
2
m
1
2
k
di®erent summands of I(b)), then the construction aborts.
This construction gives a term model if it does not abort. It is an initial model
for only part of the category of models, however. To make this precise, we recall
the de¯nition of connected component from 4.3.10. It is easy to see that each
connected component is a full subcategory of the whole category of models.
1.3.5 Proposition
For each d½mon for which the construction in FD{1 to
FD{6 does not abort, the construction is a recursive de¯nition of a model I of
. Each such model is the initial model of a connected component of the category
of models of
, and there is a d½mon giving the initial model for each connected
component.
We will not prove this theorem here. However, we will indicate how each model
determines a d½mon which produces the initial model for its component. Let M
be a model of an FD sketch
. Every string w which determines an element of
a sort I(a) in a term model as constructed above corresponds to an element of
M(a). That element must be in a unique summand of a; if it is the ith summand,
then de¯ne D(w) = i. On strings not used in the construction of the term models,
de¯ne D(w) = 1, not that it matters.

8
Finite discrete sketches
Our de¯nition of d½mon shows that one can attempt a construction of an
initial model without already knowing models. In concrete cases, of course, it will
often be possible to characterize which choices give initial models and which do
not.
1.3.6 Confusion maybe, junk no
The slogan, `No junk, no confusion' is only
half true of the initial models for FD theories. The `No junk' half of the slogan
expresses exactly what we mean when we say that every element is reachable.
There are no extraneous elements. `No confusion' means no relations except those
forced by the equations in the theory. As we will show by example it may happen
that some initial models have confusion and others not. Later we give an example
of a sketch that has more than one unconfused initial model and one that has no
unconfused initial (or noninitial) model.
If there is just one unconfused initial model, that one may be thought of as
a `generic' model. The others remain nonetheless interesting. In fact, it is likely
that the generic model is the one that cannot be accurately modeled on a real
machine.
1.3.7 Example
A typical example of a sketch with many initial models is the
sketch for natural numbers with over°ow. The generic model is easily seen to be
the one in ES 1.1.5 in which the over°ow state is empty. The models with over°ow
in ES 1.1.6 are all initial algebras for some component of the category of models,
but they have confusion, since nothing in the sketch implies that the successor of
any element can be the same element. None of these models have junk.
The modular arithmetic models of ES 1.1.7 are not initial models; in fact they
are all in the same component as the natural numbers since the remainder map
(modN) is a morphism of models. They also have no junk.
1.3.8 Example
Here is a simple sketch with no generic model. It has two initial
models, each satisfying an equation the other one does not. There are ¯ve nodes
a = b + c, d and 1. There is one constant x of type d, and a single operation s : d
¡! a. The initial models have one element { the constant { of type d. One of the
initial models has an element of type b and the other an element of type c.
By modifying this example, we can get forced confusion. Add constants y and
z of type b and c, respectively, and cones forcing b and c to be terminal. Now
there are two initial models, one in which s(x) = y and another in which s(x) = z.
Since there is a model in which s(x) 6
= y, there can be no equation that forces
s(x) = y and there is similarly no equation that forces s(x) = z. But one or the
other equation must hold in any model.
1.3.9 Example
It is well known and proved in abstract algebra texts that the
initial ¯elds are (a) the rational numbers and (b) the integers mod p for each
prime p. (The word for initial model in these texts is `prime ¯eld'.) A ¯eld is in

1.3 Term algebras for FD sketches
9
the component of the integers mod p if and only if 1 + 1 + : :: + 1 (sum of p 1's)
is zero. These ¯elds have confusion. Otherwise the ¯eld is in the component of
the rational numbers, which have no confusion (nor junk). Duval and Reynaud
[1994a, 1994b] show how to implement simultaneous computation in the initial
algebras for a ¯nite discrete sketch for ¯elds.
The real numbers and the complex numbers form ¯elds with the usual oper-
ations. The irrational real numbers constitute junk.
1.3.10 Example
The example in ES 1.1.2 has only one component and hence
a single initial model in which all sorts are empty except the singleton 1. If you
add constants to d, the initial model is just the set of lists of ¯nite length of
elements of d. In the model discussed there which also has all in¯nite sequences,
the in¯nite sequences are junk.
1.3.11 Binary trees
We now describe a sketch for ordered rooted binary trees
(called trees in this discussion). `Binary' means that each node has either no
children or two children, and `ordered' means that the children are designated
left and right. This is an example which uses cocones to treat exceptional cases,
in this case the empty tree.
Trees are parametrized by the type of data that are stored in them. We will say
nothing about this type of data, supposing only that it is a type for which there
is an initial model. The way in which the parametrized data type is ¯lled in with
a real one is described, for example, in Section ES 3.2. We would like to thank
Adam D. Barr for helpful discussions on how binary trees operate (especially
their error states) on real machines.
The sketch will have sorts 1; t; s; d. Informally, t stands for tree, s for
nonempty tree and d for datum. We have the following operations:
empty : 1 ¡! t
incl : s ¡! t
val : s ¡! d
left : s ¡! t
right : s ¡! t
The intended meaning of these operations is as follows.
Emptyhi is the empty tree; incl is the inclusion of the set of nonempty trees in
the set of trees; val(S) is the datum stored at the root of S; left(S) and right(S) are
the right and left branches (possibly empty) of the nonempty tree S, respectively.
We require that

10
Finite discrete sketches
s
¡
@
¡
@
right
left
val
¡
@
¡
@
¡ª
?
@R
t
d
t
be a cone and that
1
s
@
¡
empty@
¡ incl
@
¡
@R
¡ª
t
be a cocone.
There are no diagrams.
The cocone says that every tree is either empty or nonempty. This cocone
could be alternatively expressed t = s + femptyg. The cone says that every non-
empty tree can be represented uniquely as a triplet (left(S); val(S);right(S)) and
that every such triplet corresponds to a tree. Note that this implies that left, val
and right become coordinate projections in a model.
Using this, we can de¯ne subsidiary operations on trees. For example, we can
de¯ne an operation of left attachment, lat : t £ s ¡! s by letting
lat(T; (left(S);val(S); right(S))) = (T; val(S); right(S))
This can be done without elements: lat is de¯ned in any model as the unique
arrow making the following diagram commute (note that the horizontal arrows
are isomorphisms):
M(t) £ hleft; val;righti-
M(t) £ M(s)
M(t) £ M(t) £ M(d) £ M(t)
hp ;p ; p i
lat
1
3
4
?
?
-
M(s)
M(t) £ M(d) £ M(t)
hleft;val; righti
In a similar way, we can de¯ne right attachment as well as the insertion of a
datum at the root node as operations de¯nable in any tree. These operations
are implicit in the sketch in the sense that they occur as arrows in the theory
generated by the sketch (see 4.6.11), and therefore are present in every model.
1.3.12 Proposition
Supposing there is an initial algebra for the data type,
then the category of binary trees of that type has an initial algebra. If the data type
has (up to isomorphism) a unique initial algebra, then so does the corresponding
category of binary trees.

1.3 Term algebras for FD sketches
11
Proof. We construct the initial algebra recursively according to the rules:
(i) The empty set is a tree;
(ii) If T and T are trees and D is element of the initial term algebra for the
l
r
data type, then (T ;D;T ) is a nonempty tree;
l
r
(iii) Nothing else is a tree.
This is a model M
de¯ned by letting M (s) be the set of nonempty trees,
0
0
M (t) = M (s) + f;g and M (d) be the initial model of the data type. Here `+'
0
0
0
denotes disjoint union. It is clear how to de¯ne the operations of the sketch in
such a way that this becomes a model of the sketch.
Now let M be any model with the property that M(d) is a model for the data
type. Then there is a unique morphism f(d) : M (d) ¡! M(d) that preserves
0
all the operations in the data type. We also de¯ne f(t)f;g to be the value of
M(empty) : 1 ¡! M(t). Finally, we de¯ne
f(s)((T ; D;T )) = (f(t)(T ); f(d)(D);f(t)(T ))
l
r
l
r
where f(t) is de¯ned recursively to agree with f(s) on nonempty trees. It is
immediately clear that this is a morphism of models and is unique. In particular,
if the data type has, up to isomorphism, only one initial model then M is also
0
unique up to isomorphism.
1.3.13
In Pascal textbooks a de¯nition for a tree type typically looks like this:
type TreePtr = bTree;
Tree = record LeftTree, RightTree : TreePtr;
Datum : integer
end;
Note that from the point of view of the preceding sketch, this actually de¯nes
nonempty trees. The empty tree is referred to by a null pointer. This takes ad-
vantage of the fact that in such languages de¯ning a pointer to a type D actually
de¯nes a pointer to what is in e®ect a variant record (union structure) which is
either of type D or of `type' null.
1.3.14 Exercise
y
1. a. Show that if
is an FD sketch and f : M ¡! N is a homomorphism
between models in the category of sets, then the image of f is a submodel of N.
b. Show that every model in the category of sets of an FD sketch has a smallest
submodel.

2
More about sketches
This chapter develops the concept of sketch in several ways. The ¯rst three sec-
tions describe a generalization of FP theories called FL theories which allow the
use of equalizers, pullbacks and other limits in the description of a structure.
These theories have expressive power which includes that of universal Horn the-
ories.
The last section gives further generalizations of the concept of sketch. These
generalizations are described without much detail since they do not appear to
have many applications (yet!) in computer science.
This chapter is needed only for Chapter ES 3, except that the sketch for
categories of Section ES 2.1.5 is required for Section ES 5.7.
2.1 Finite limit sketches
A cone is called ¯nite if its shape graph is ¯nite, meaning that it has only ¯nitely
many nodes and arrows.
2.1.1 De¯nition
A ¯nite limit or FL sketch
= ( ;
;
) is a ¯nite graph
together with a ¯nite set
of diagrams and a ¯nite set
of ¯nite cones. A model
of
is a model of
that takes all the diagrams in
to commutative diagrams
and all the cones in
to limit cones.
For historical reasons, FL sketches are also known as left exact sketches or
LE sketches.
In 7.2.8 we described the way the choice of products and terminal objects in a
model to represent the vertices of cones in a sketch were irrelevant but could result
in the technicality that, for example, the set representing the product might not
actually be a set of ordered pairs. The same sort of statement is true of models
of FL theories. In particular, in a model the equalizer of parallel arrows need not
be a subset of their common domain.
FL sketches allow the speci¯cation of structures or data types with sorts
that include equationally speci¯ed subsorts, by using equalizers. More generally,
you can specify an operation whose domain, in a model, will be an equationally
de¯ned subobject of another sort. FL theories can express anything expressible
by universal Horn theories, but in general FL theories are more powerful (see
[Barr, 1989] and [Ad¶amek and Rosi·cky, 1994], pages 209-210). For example, small
categories and functors form the category of models of an FL theory (which we
12

2.1 Finite limit sketches
13
give in ES 2.1.5 below) but not of a universal Horn theory. Categories of models
of FL sketches can be described axiomatically as locally ¯nitely presentable
categories (see [Gabriel and Ulmer, 1971] and [Ad¶amek and Rosi·cky, 1994]).
In practice it is generally su±cient to restrict the types of cones to a few
simple types, products, pullbacks and equalizers. In principle, an FL sketch can
always be replaced by one which has an equivalent category of models and which
has only these three types of cones, but there might be some case in which this
is not the most e±cient approach.
2.1.2 Other approaches
In the introduction to Chapter 7, we mentioned
three approaches to formalization: logical theories, signatures and equations, and
sketches. Systems equivalent to FL sketches have been developed for both the
other approaches. Coste [1976], Cartmell [1986] and McLarty [1986] generalize
logical systems and Reichel [1987] generalize signatures. The book by Reichel has
many examples of applications to computer science.
2.1.3 Notation for FL sketches
We extend the notational conventions in
Section 7.3 to cover products, pullbacks and equalizers.
First, the notation of N{2 in 7.3.1 using product projections is extended to
cover the arrows from the limit to any of the nodes in the diagram: that is they
are all denoted by an appropriate p; moreover, the notation of N{4 in 7.3.1 is
extended to arrows into the limit in terms of the composite with the projections.
See Example ES 2.1.5 below of the sketch of categories to see how this is used.
Of course, it is sometimes necessary to be more explicit than this.
We add the following to the notational conventions of Section 7.3.
N{8 If we have a node labeled a £ b this implies the existence of a cone
c
a £ b
c
¡
@
¡
@
¡
@
¡ª
@R
-
¾
a
c
b
Of course, this notation is not self-contained since it is necessary to specify
the arrows a ¡! c Ã¡ b. In many cases, these arrows are clear, but it may be
necessary to specify them explicitly.
N{9 If we have an arrow labeled s : a)¡!b (recall from 2.8.2 that in a category this
notation means an arrow that is a monomorphism), then we are implicitly
including a cone

14
More about sketches
a
¡
@
¡
s
@
id
id
¡
@
¡ª
?
@R
-
¾
a
b
a
s
s
This notation makes sense because of Theorem 8.3.3.
We could go on and turn our notational conventions into a formal language, but have
chosen not to do so because we do not know what it would add to the theory. For
us, they remain a set of notational conventions; the real object of study is the whole
sketch or else the theory it generates.
2.1.4 The sketch for simple graphs
Here is a simple example that shows
how the added power of FL sketches can be used to de¯ne a familiar type of
structure. A simple graph is a graph with the property that for any pair (a; b)
of nodes there is no more than one arrow with source a and target b.
The sketch for graphs has the graph
source
¡¡¡¡¡!
a
n
¡¡¡¡¡!
target
and no cones or diagrams. We can modify it to get a sketch for simple graphs
by adding an object n £ n and the necessary discrete cone to make it a formal
product, an arrow u : a )¡! n £ n (hence adding a formal pullback as in N{ES 9
making it formally monic) and also the diagram (not cone)
a
¡
@
target
¡
@
source
u
¡
@
¡ª
?
@R
¾
-
n
n £ n
n
p
p
1
2
The e®ect of this is to make the monic arrow u become hsource; targeti in a model,
so that no two arrows can have the same source-target pair.
2.1.5 The sketch for categories
We give here an FL sketch whose models
in the category of sets are small categories and arrows between the models are
functors. Models in an arbitrary category
with ¯nite limits are called category
objects in
. These are used in Section ES 5.7.
The sketch has nodes c ; c ; c and c which stand for the objects, the arrows,
0
1
2
3
the composable pairs and the composable triples of arrows respectively. The
arrows of the sketch are:
u : c ¡! c
0
1
s;t : c ¡! c
1
0

2.1 Finite limit sketches
15
p ; p ; c : c ¡! c
1
2
2
1
p ; p ; p : c ¡! c
1
2
3
3
1
hp ; p i; hp ;p i; hp ;ci; hc;p i : c ¡! c
1
2
2
3
1
3
3
2
±
±
hu
t;idi; hid; u
si : c ¡! c
1
2
The intention is that in a Set-model, the arrows of the sketch will be inter-
preted as follows:
u is the unit function which assigns to each object its identity,
s and t are the source and target functions from the set of arrows to the
set of objects, and
c is the function which takes a composable pair of arrows to its composite.
The remaining arrows of the sketch are projections from a limit or are inter-
preted as arrows to a limit with speci¯ed projections.
The diagrams are
c
c
3
3
¡
@
¡
@
p
p
p
p
¡
@
¡
@
2
hp ; p i
3
1
hp ;p i
2
2
3
1
2
¡
@
¡
@
¡ª
?
@R
¡ª
?
@R
¾
-
¾
-
c
c
c
c
c
c
1
2
1
1
2
1
p
p
p
p
1
2
1
2
hp ;p i
hp ; p i
1
2
2
3
¾
-
c
c
c
c
3
2
3
2
@
¡
p
p
@
¡
c
c
hc;p i
hp ; ci
3
1
3
1
@
¡
?
@R
?
¡ª
?
?
¾
-
¾
-
c
c
c
c
c
c
1
2
1
1
2
1
p
p
p
p
1
2
1
2
t
s
¾
-
c
c
c
c
1
0
1
0
@
¡
±
±
@
u
¡
u
hu
t;idi
hid;u
si
id
id
@
¡
?
@R
?
¡ª
?
?
¾
-
¾
-
c
c
c
c
c
c
1
2
1
1
2
1
p
p
p
p
1
2
1
2
±
±
hid;u
si
hu
t;idi
hp ; ci
1
-
¾
-
c
c
c
c
c
1
2
1
3
2
@
¡
@
¡
c
c
hc; p i
id
id
3
@
¡
@
¡
@R
?¡ª
?
?
-
c
c
c
1
2
1
c
Finally, there are two cones that say that c
and c
are interpreted as the
2
3
objects of composable pairs and triples or arrows, respectively.

16
More about sketches
c3
¡
@
p
p
p
c
¡
@
1
2
3
2
¡
@
¡
@
¡ª
?
@R
p
p
c
c
c
¡
@
1
2
1
1
1
¡
@
¡
@
¡ª
?
@R
-
¾
c
c
c
s
¡
s@
1
0
1
t
t
s
t
¡
@
?¡ª
?
@R
c
c
0
0
This sketch is the sketch of categories and is one of the simpler FL sketches
around.
The category of models (in Set) of an FP sketch must be regular (see [Barr
and Wells, 1985], Theorem 1 of Section 8.4) and it can be proved that the category
of categories and functors is not regular (see Exercise 6 of Section 8.6). It follows
that categories and functors cannot be the models of an FP sketch.
Lawvere [1966] described another structure whose models are categories. Let 1; 2; 3
and 4 denote the total orders with one, two, three and four elements, considered as
categories in the usual way a poset is. Let
denote the opposite category. In that
opposite category, it turns out that 3 = 2 £ 2 and 4 = 2 £ 2 £ 2. Then Cat is
1
1
1
the category of limit-preserving functors of
into Set with natural transformations
as arrows. It follows that the sketch whose objects and arrows are those of
, whose
diagrams are the commutative diagrams of
and cones are the limit cones of
is
another sketch, closely related in fact to the one above, whose category of models is
Cat.
We show how binary trees can be described as models of an FL sketch in the
next section.
2.1.6 Exercises
1. A groupoid is a category in which every arrow is an isomorphism. Explain
how to modify the sketch for categories to get a sketch for groupoids.
2. Show that in the category of sets, the de¯nition of homomorphism between
two models of the sketch for categories gives the usual de¯nition of functor.
2.2 Initial term models of FL sketches
Like FP sketches, FL sketches always have initial models. The construction 7.6.5
produced an initial term algebra for each ¯nite FP sketch. A modi¯cation of the
last three rules in 7.6.5 is su±cient to construct an initial term algebra for each
¯nite FL sketch. This will be described below.

2.2 Initial term models
17
A di®erent construction is in Barr [1986b], where it is proved that in fact FL
sketches have free algebras on any typed set X (see Section 9.2.) Volger [1987]
gives a logic-based proof for the special case of Horn theories (see [Volger, 1988]
for applications).
The modi¯cation of 7.6.5 is required by the fact that the base diagram D of
a cone in
need not be discrete in the case of general limits; that is, the shape
graph
of the diagram D in Section 8.2 may have nontrivial arrows u : i ¡! j.
A limit of such a cone in the category of sets is not just any tuple of elements of
the sets corresponding to the nodes of
, but only tuples which are compatible
with the arrows of
.
2.2.1
Precisely, suppose E :
¡! Set is a ¯nite diagram (we use the letter E
instead of D to avoid confusion below). A compatible family of elements of E
is a sequence (x ; : :: ;x ) indexed by the nodes of
for which
1
n
C{1 x 2 E(i) for each node i.
i
C{2 If u : i ¡! j in
, then E(u)(x ) = x .
i
j
An initial term algebra of an FL sketch
= ( ;
;
) is then the least model
satisfying the following requirements.
FL{1 If f : a ¡! b is an arrow of
and [x] is an element of I(a), then [fx] 2 I(b)
and I(f)[x] = [fx].
FL{2 If (f ; :: : ; f ) and (g ; : :: ; g ) are paths in a diagram in
, both going
1
m
1
k
from a node labeled a to a node labeled b, and [x] 2 I(a), then
±
±
±
±
±
±
(If
If
: ::
If )[x] = (Ig
Ig
: ::
Ig )[x]
1
2
m
1
2
k
in I(b).
FL{3 If D :
¡!
is a diagram, ([x ]; :: :; [x ]) is a compatible family of ele-
1
n
±
ments of I
D and p : q ¡! D is a cone over D in
, then [C(x ;: :: ; x )]
1
n
is an element of I(q).
0
0
FL{4 If p : q ¡! D and ([x ]; : :: ; [x ]) are as in FL{ES 3, and x ; :: : ; x
is a
1
n
1
n
0
±
compatible family of elements of I
D for which [x ] = [x ] for i = 1;: :: ;n,
i
i
then
0
0
[C(x ;: :: ; x )] = [C(x ;: :: ; x )]
1
n
1
n
FL{5 If p : q ¡! D and ([x ]; :: : ;[x ]) are as in FL{ES 3, then for i = 1; :: : ;n
1
n
[p C(x ; :: :; x )] = [x ]
i
1
n
i
FL{6 If p : q ¡! D is a cone over D in
and x 2 I(q), then
[x] = [C(p x; :: :; p x)]
1
n

18
More about sketches
Compatibility implies that for any arrow u : i ¡! j of
,
I(D(u))([x ]) = [x ]
i
j
As in 7.6.5, it follows that
I(p )([C(x ; :: :; x )]) = [x ]
i
1
n
i
for each i.
2.2.2 Binary trees
We describe an FL sketch whose initial term algebra is the
set of binary trees of integers. We gave an FD sketch for binary trees in ES 1.3.11;
the sketch given here illustrates a di®erent approach to the problem that opera-
tions such as taking the datum at the root or producing the left or right subtrees
are not de¯ned on the empty tree.
+
We have the following basic nodes in the sketch: 1; t; t ; b; n. These should be
thought of as representing the types of binary trees, nonempty binary trees, the
Boolean algebra 2 and the natural numbers, respectively. We have the following
operations:
+
empty : 1 ¡! t
empty? : t ¡! b
incl : t
¡! t
+
+
+
val : t
¡! n
left : t
¡! t
right : t
¡! t
zero : 1 ¡! n
succ : n ¡! n
true : 1 ¡! b
and : b £ b ¡! b
not : b ¡! b
The intended meaning of these operations is as follows: the constant emptyhi
is the empty tree; empty? is the test for whether a tree is the empty tree; incl
is the inclusion of the set of nonempty trees in the set of trees; val(T) is the
datum stored at the root of the nonempty tree T; left(T) and right(T) are the
right and left branches (possibly empty) of the nonempty tree T, respectively.
The remaining operations are the standard operations appropriate to the natural
numbers and the Boolean algebra 2.
We require that
+
t
¡
@
¡
@
right
left
val
¡
@
¡ª
?
@R
t
n
t

2.3 The theory of an FL sketch
19
and
+
t
¡
@
¡
@
incl
¡
@
¡ª
@R
(2.1)
1
t
@
¡
±
@
¡ empty?
not
true
@
¡
@R
¡ª
b
be cones and that
empty-
1
t
@
@
empty?
true
@
?
@R
b
be a diagram.
In the cone (ES 2.1), there should be an arrow from the vertex to the node
b. It will appear in a model as either of the two (necessarily equal) composites.
Since its value is forced, it is customary to omit it from the cone; however, there
actually does have to be such an arrow there to complete the cone (and the
sketch). In omitting it, we have conformed to the standard convention of showing
explicitly only what it is necessary to show.
As in ES 1.3.11, the existence of the ¯rst cone says that every nonempty tree
can be represented uniquely as a triplet
(left(T); val(T); right(T))
+
The fact that (ES 2.1) is a cone requires that in a model M, M(t ) be exactly
the subset of M(t) of those elements which evaluate to false under M(empty?).
2.2.3 Exercise
1. In the sketch for binary trees, show that for any model M, M(incl) is an
injective function. (Hint: use Diagram (ES 2.1).)
2.3 The theory of an FL sketch
Just as in the case of linear and FP sketches, every FL sketch generates a category
with ¯nite limits in which it has a universal model.

20
More about sketches
2.3.1 Theorem
Given any FL sketch
, there is a category Th
(
) with
FL
¯nite limits and a model M :
¡! Th
(
) such that for any model M :
0
FL
¡!
into a category with ¯nite limits, there is a functor F : Th
(
) ¡!
that
FL
preserves ¯nite limits for which
±
(i) F
M = M, and
0
0
(ii) if F : Th
(
) ¡!
is another functor that preserves ¯nite limits for
FL
0
0
±
which F
M = M, then F and F are naturally isomorphic.
0
Th
(
) is de¯ned up to equivalence by the following properties:
FL
FLT{1
has all ¯nite limits.
FLT{2 M takes every diagram of
to a commutative diagram in
.
0
FLT{3 M takes every cone of
to a limit cone of
.
0
FLT{4 No proper subcategory of
includes the image of M and satis¯es FLT-1,
0
FLT-2 and FLT-3.
The comments concerning Theorem 7.5.1 apply here too. See [Barr and Wells,
1985], Section 4.4, Theorem 2 (p. 156). The constructions in [Ehresmann, 1968]
and [Bastiani and Ehresmann, 1972] are more general since they allow cones over
in¯nite diagrams. Barr and Wells [1994] provide a construction of
that shows
that every object of
is a limit of a ¯nite diagram in the graph of
.
2.3.2 Example
The sketch for semigroups (see Section 7.2) is an FP sketch
and therefore an FL sketch whose cones all go to discrete diagrams. The FL
theory of this sketch contains a node v that is the limit of this diagram:
¢
-
s
s £ s
@
¡c
id @
¡
@R
¡ª
(2.2)
s
Since M is injective, we write s for M (s), s £ s for M (s £ s), and so on.
0
0
0
A model M of the sketch induces a limit preserving functor F which must
±
take v to a set. Since v is the equalizer of id and c
¢, F(v) must be the set
s
of elements e of M(s) that satisfy the requirement ee = e, that is, the set of
idempotents in the semigroup M(s). (This set is not in general a subsemigroup.)

2.4 General de¯nition of sketch
21
2.3.3 Example
The FL theory of the sketch for categories (see ES 2.1.5) con-
tains a node v that is the limit of the diagram
c1
¡
@
s
t
¡
@
¡ª
@R
c
c
0
0
(2.3)
@I
¡µ
s@
¡ t
@
¡
c1
If
is a small category, hence a model of the sketch, the induced limit-preserving
functor F takes v to the set of all parallel pairs of arrows in
.
2.3.4 Exercises
1. The following diagram in the sketch for categories has a limit v in the FL
theory of that sketch. What is its value in a model?
c
c
c
1
1
1
¡
¡
@
@
s
s
s
t
t
t
¡
¡
@
@
¡
¡@
@
¡
¡
@
@
?¡ª
¡ª
@R
@R
?
c
c
c
0
0
0
2. Same question as Exercise ES 1 for the following diagram:
c2
¡
@
¡
@
p
p
c
1
2
¡
@
¡
@
¡ª
?
@R
c
c
c
1
1
1
¡
¡
@
@
s
s
s
t
t
t
¡
¡
@
@
¡
¡@
@
¡
¡
@
@
?¡ª
¡ª
@R
@R
?
c
c
c
0
0
0
0
3. Show that any model M of a sketch
is isomorphic to a model M for which
0
0
M (c) and M (d) have no elements in common if c 6
= d.
2.4 General de¯nition of sketch
Although we will not be using the most general notion of sketch, we give the
de¯nition here.

22
More about sketches
2.4.1 De¯nition
A sketch
= ( ;
;
;
) consists of a graph
, a set
of diagrams in
, a set
of cones in
and a set
of cocones in
.
2.4.2 De¯nition
A model M of a sketch
= ( ;
;
;
) in a category
is a homomorphism from
to the underlying graph of
that takes every
diagram in
to a commutative diagram, every cone in
to a limit cone and
every cocone in
to a colimit cocone.
2.4.3 De¯nition
Let M, N be models of a sketch
in a category
. A
homomorphism of models ® : M ¡! N is a natural transformation from M
to N.
Sketches in general do not have initial algebras, or even families of initial
algebras. What they do have is `locally free diagrams' as described by Guitart
and Lair [1981, 1982].
2.4.4 Regular sketches
Chapter 8 of [Barr and Wells, 1985] describes special
classes of sketches with cones and cocones that have in common the fact that
their theories are embedded in a topos, and so inherit the nice properties of a
topos. (Toposes are discussed in Chapter ES 5.) These are the regular sketches,
coherent sketches and geometric sketches. We describe regular sketches here to
illustrate the general pattern. (Note: The French school uses the phrase \regular
sketch" for a sketch in which no node is the vertex of more than one cone.)
2.4.5
An arrow f : A ¡! B is a regular epimorphism if and only if there is a
cocone diagram
g
f
¡¡!
C
A ¡¡! B
¡¡!
h
It follows that the predicate of being a regular epimorphism can be stated within
the semantics of a ¯nite limits sketch. Note that an arrow can be required to
become an epimorphism (not necessarily regular) in a model by using the dual
of Theorem 8.3.3.
Let us say that a regular cocone is one of the form
¡!
c
a ¡! b
¡!
2.4.6 De¯nition
A regular sketch
= ( ;
;
;
) consists of a graph,
a set of diagrams, a set of ¯nite cones and a set of regular cocones.
There is one undesirable feature to the de¯nition above. The introduction
¡!
of a regular sketch requires the introduction of a sort c and two arrows c ¡!
a. A model will have to provide a value for c as well as the two arrows. This
is generally irrelevant information that one would not normally want to have
to provide. Worse, the de¯nition of natural transformation is such that arrows

2.4 General de¯nition of sketch
23
between models will have to preserve this additional information and that is
de¯nitely undesirable. The way in which this is usually dealt with is by adding,
with each cocone
0
d
d
¡¡¡!
c
a ¡¡! b
¡¡¡!
1
d
the cone
0
d -
c
a
1
d
d
?
?
-
a
b
d
It follows from Exercise 5 of Section 8.4 that if d has a kernel pair, then d is
a regular epimorphism if and only if it is the coequalizer of that kernel pair.
The addition of this cone thus adds no new data, at least in the case of models
in a category with ¯nite limits and coequalizers. The preservation of the kernel
pair and the two arrows by homomorphisms of models is automatic, given the
universal mapping properties of limits.
The point of these considerations is that a regular sketch can be described
as one in which one can specify any kind of ¯nite limits and that any particular
arrow is a coequalizer of some pair, without having to specify (or preserve in an
arrow between models) what pair of arrows it coequalizes.
One of the things we want a sketch to do is minimize the number of items { or
amount of information { that has to be speci¯ed and maximize the amount that is
implicit in the sketch. Thus we want to be able to say that an arrow is a regular
epimorphism (that is, coequalizer of some pair of arrows) without specifying what
pair it coequalizes. In the preceding discussion, we described a way to do this: to
observe that a regular epi is a coequalizer of its own kernel pair and that the kernel
pair can be calculated. There is a price to pay in solving the problem in this way,
since this works only when you form models in a category that has that kernel pair.
An alternative approach would be to simply add regular epi to the list of primitives
that a sketch can make use of, so that one could require than an arrow be a regular
epi, without having to specify the arrows it coequalizes, in a category that may or
may not have pullbacks. This is an example of expanding the concept of sketch to
allow speci¯cation of constructions other than commutative diagrams, limits and
colimits. (References to generalized sketches are given at the end of this chapter.)
As an example, we construct a sketch for re°exive graphs { graphs with the
property that there is at least one loop on each node. The problem that arose
in 4.6.9 that homomorphisms had to take certain speci¯c loops to other speci¯c
loops does not arise in this construction.

24
More about sketches
We take the sketch for graphs with nodes n and a and arrows source; target : a
¡! n. We add a new type r with a cone
source
¡¡¡¡¡!
r ¡! a
n
¡¡¡¡¡!
target
and a cocone to express that the composite r ¡! a ¡! n (the latter arrow being
either source or target) is regular epic. In a model, r becomes the set of loops.
The fact that the arrow r ¡! a ¡! n maps surjectively to the nodes implies that
0
there is at least one loop at each node. A homomorphism from M to M must
0
take M(r) to M (r) as a set, but there is no particular loop in M(r) that is
distinguished by the construction.
2.4.7 Theories of sketches with colimits.
The reader may have noticed
that in Chapter 7, we discussed FP sketches, their initial algebras and their
theories, and in Chapter ES 1 we discussed FD sketches and their initial algebras.
We did not discuss theories for FD sketches. In fact, theories exist for FD sketches,
and indeed for all sketches. This is because sketches can themselves be modeled
by an FL theory, and the theory of a sketch can then be realized as an initial
algebra (see Section ES 2.2). See [Wells, 1990], [Bagchi and Wells, 1994].
Here, we state the universal properties for theories of FD sketches for models
in categories with ¯nite products and ¯nite disjoint universal sums. The resulting
theory has these properties, too, and is embedded in a topos. The proof by initial
algebras just mentioned does not give such an embedding.
2.4.8 Theorem
Let
be an FD sketch. Then there is a category denoted
Th
(
) with ¯nite disjoint universal sums and a model M :
¡! Th
(
)
0
FD
FD
such that for any model M :
¡!
into a category with ¯nite products and ¯nite
disjoint universal sums, there is a functor F : Th
(
) ¡!
that preserves
FD
¯nite products and ¯nite sums for which
±
(i) F
M = M, and
0
0
(ii) If F : Th
(
) ¡!
is another functor that preserves ¯nite products and
FD
0
0
±
¯nite sums for which F
M = M, then F and F are naturally isomorphic.
0
A proof may be found in [Barr and Wells, 1985], Proposition 1 of Section 8.2.
(FD sketches are called FS sketches there.)
The situation is similar for regular sketches.
2.4.9 Theorem
Let
be a regular sketch. Then there is a regular category
denoted Th
(
) and a model M :
¡! Th
(
) such that, for any model
0
Reg
Reg
M :
¡!
into a regular category, there is a regular functor F : Th
(
)
Reg
¡!
such that
±
(i) F
M = M, and
0

2.4 General de¯nition of sketch
25
0
0 ±
(ii) if F : Th
(
) ¡!
is another regular functor for which F
M = M,
0
Reg
0
then F and F are naturally isomorphic.
The theories of many types of sketches can be constructed as subcategories
of toposes; this is done in [Barr and Wells, 1985], Chapters 4 and 8. Other con-
structions of theories for special kinds of sketches are given in [Ehresmann, 1968],
[Bastiani and Ehresmann, 1972], [Peake and Peters, 1972], [Kelly, 1982], [Wells,
1990] and [Barr and Wells, 1994].
2.4.10
Categories of set-valued models of general sketches can be axiomatized
as accessible categories (see [Makkai and Par¶e, 1990], [Ad¶amek and Rosi·cky,
1994].) A precise statement of the relationship between categories of models of
¯rst order theories and categories of models of sketches is given in [Ad¶amek and
Rosi·cky, 1994] (Theorems 5.35 and 5.44).
Generalizations of the concept of sketch are given by Lair [1987], Wells [1990]
(see also [Bagchi and Wells, 1994]), Power and Wells [1992], and Makkai [Makkai,
1994].

3
The category of sketches
The ¯rst section of this chapter de¯nes the concept of homomorphism of sketches,
yielding a category of sketches. In Section ES 3.2 we describe a formalism for
de¯ning parametrized data types using sketch homomorphisms. In Section ES 3.3
we develop the theory of sketches further, showing that a homomorphism of
sketches induces a contravariant functor between the model categories and making
contact with Goguen and Burstall's concept of institution.
Section ES 3.3 requires only Section ES 3.1 to read. Nothing in this chapter is
needed later in the book.
Much more is known about the category of sketches than is mentioned here.
It is cartesian closed, for example. A basic study in English of the category of
sketches which is oriented toward computer science is given by Gray [1989].
3.1 Homomorphisms of sketches
0
0
0
0
0
3.1.1
Let
= ( ;
;
;
) and
= (
;
;
;
) be sketches. A graph
0
±
homomorphism F :
¡!
takes a diagram D :
¡!
to a diagram F
D :
0
0
¡!
which is called the image of D in
. It takes a cone p : v ¡! D to a cone
±
F(p) : F(v) ¡! F
D where, for each node a of the shape graph of D, F(p) : F(v)
a
¡! F(D(a)) is de¯ned to be F(p ). It is de¯ned on cocones similarly.
a
0
An arrow or homomorphism of sketches F :
¡!
is a graph homo-
0
morphism from the graph
to the graph
for which, if D is a diagram in
0
0
±
then F
D lies in
; if p : v ¡! D is a cone in
then F(p) is a cone in
; and
0
if c : D ¡! v is a cocone in
then F(c) is a cocone in
.
Note that if in the sketch
the sets of diagrams, cones and cocones are all
0
empty, then an arrow from
to
is precisely a graph homomorphism from
0
to
.
3.1.2 Example
Let
denote the impoverished sketch which has one node we
will call e and no arrows, diagrams, cones or cocones. Any assignment of e to a
node of any sketch is a morphism of sketches.
3.1.3 Example
The sketch for graphs has the graph
source
¡¡¡¡¡!
a
n
¡¡¡¡¡!
target
26

3.1 Homomorphisms of sketches
27
and no cones or diagrams. There is a graph homomorphism from the graph of the
sketch of 4.2.17 to the graph just given that takes 0 to a, 1 to n, and u to source.
This is a sketch homomorphism since there are no diagrams, cones or cocones
in either sketch. (Of course, there is another sketch homomorphism taking u to
target.)
3.1.4 Example
In ES 2.1.4, we modifed the sketch for graphs by adding a cone
making it the sketch for simple graphs. The inclusion of the sketch for graphs into
the sketch for simple graphs is a homomorphism of sketches.
3.1.5 Example
A ¯eld has an associative binary operation of addition on it, so
one would suspect that there is a homomorphism from the sketch for semigroups
in 7.2.1 to the sketch for ¯elds in ES 1.2. That is the case. The homomorphism
takes s to f, s£s to f £f and s£s£s to f £f £f, and the arrow c to the arrow
+. The homomorphism must take projection arrows of cones to corresponding
projection arrows, and of course the associativity diagram (7.8) then is mapped
to the diagram implied by FE{1 of ES 1.2.
3.1.6 The sketch underlying a category
Let
be a category. There is an
underlying sketch of
, call it Sk(
), whose graph consists of the objects of
as nodes and the arrows of
as arrows. This underlying sketch is not in general
¯nite or even small. The commutative diagrams of this sketch are all diagrams
that are commutative in
. Similarly we take for cones all those that are limit
cones in
and for cocones all those that are colimit cocones. An arrow from
to Sk(
) is then exactly what we have called a model of
in
in ES 2.4.2.
We note that although the composition in
has been forgotten, it can be
completely recovered from the knowledge of which diagrams commute. For ex-
±
ample, the information f
g = h is equivalent to the information that
g
-
¢
¢
@
@
f
h
@
?
@R
¢
commutes so that we could recover the category
entirely from the underlying
sketch (in fact, just from the graph and the commutative triangles).
3.1.7 The category of sketches
With the de¯nition of homomorphism of
sketches given above, sketches themselves form a category which we will call
Sketch. By restricting the shape graphs for the diagrams, cones and cocones
one obtains many full subcategories of Sketch, for example the category of FP
sketches, the category of FD sketches, and so on.

28
The category of sketches
One consequence of this is that all constructions that we can carry out in any
category make sense in the category of sketches. The particular construction that
interests us here is the formation of colimits, particularly pushouts.
3.1.8 Exercise
1. Let
be the sketch with one node and no arrows, diagrams, cones or cocones.
Show that the category of models of
in a category
is isomorphic to
. In
particular, the category of models of
in Set is isomorphic to Set.
3.2 Parametrized data types
as pushouts
One thing a theory of data types should do is give a way of saying how the
data types of stacks of integers, say, is like the type of stacks of reals or for that
matter of stacks of arrays of trees of characters. In other words, we need a way
of talking about an abstract stack in a way that leaves it open to ¯ll in the blank
corresponding to the thing that it is stacks of. The data type is the parameter.
The way we do this is to describe a sketch for stacks of d where d stands for
an abstract data type and then use a pushout construction to identify d with a
concrete data type in any particular application. The point is that pushouts are
the general way we use to identify things. We give several illustrations.
3.2.1 Abstract stacks
Consider the sketch whose graph consists of nodes
s; t; d; d £ s and 1. The idea is that s stands for the set of stack con¯gurations,
t the set of nonempty stack con¯gurations, and d the data. There are operations
push : d £ s ¡! t, pop : t ¡! d £ s, empty : 1 ¡! s and incl : t ¡! s. In order to
state the equations we also have two arrows id
and id which will be forced to
d£s
t
be identity arrows.
There are four equations (diagrams). Two of them, id
= ()
and id = () ,
d£s
d£s
t
t
force those arrows to be identities, and the following two, which express the
essence of being a stack:
±
pop
push = idd£s
and
±
push
pop = idt
There are the cones to express 1 as terminal and d £ s as a product, and one
cocone
1
t
@
¡
empty@
¡ incl
@
¡
@R
¡ª
s

3.2 Parametrized data types
29
So far, this sketch is not very interesting, since the type of d is still undetermined.
In fact its initial model I has I(d) = I(t) = ; and I(s) = femptyg. Note that
femptyg is not empty. It contains one element which we interpret as representing
the empty stack. Since the type d of data is empty, the empty stack is the only
kind of stack there is in the model I.
If there were constants in the data type d, then I(s) would be the set of all
possible con¯gurations of a stack of data of type I(d), and I(t) would be the set
of all possible con¯gurations other than the empty stack.
3.2.2 Stacks of natural numbers
In 4.7.7, we described the sketch with two
nodes, 1 and n, two operations zero : 1 ¡! n and succ : n ¡! n. There are no
equations (diagrams), just the cone describing 1 as terminal and no cocones.
This sketch, which we called Nat, has models that can be reasonably viewed as
describing natural numbers. We described a more elaborate sketch in ES 1.1.4
which could also be used in what follows.
Let us consider the following diagram in the category of sketches, where
is the trivial sketch de¯ned in Example ES 3.1.2 and the arrows F and G are
de¯ned by letting Fe = n and Ge = d.
F -
Nat
(3.1)
G
?
Stack
A pushout of this diagram is a sketch Stack(Nat) made by forming the union
of Nat and Stack and then identifying the node n of Nat with the node d of
Stack.
From the de¯nition of pushout, it follows that a model of this sketch is a
model of the sketch for natural numbers that is simultaneously a model of the
sketch for stacks whose value at the node d of Stack is the same as its value at
the node n of Nat. Models of this sketch can be identi¯ed as stacks of natural
numbers. The e®ect of this construction is to ¯ll in the data parameter in the
sketch for stacks with an actual data type. Of course, this data type of natural
numbers could be replaced by any data type desired (including stacks of natural
numbers!) by replacing F :
¡! Nat by an appropriate sketch homomorphism.
Although we think of this sketch as being that of stacks of natural numbers,
the pushout construction is completely symmetric and any asymmetry is imposed
by our way of looking at it. It is caused by our (quite reasonable) perception that
the node d of Stack is an input parameter and the node s represents the actual
data type.

30
The category of sketches
3.2.3 Binary trees, revisited again
Here is a second example. In ES 1.3.11,
we described a sketch called BinTree and then another sketch of the same name
in ES 2.2.2. Here we describe yet another sketch we call BinTree. This third
and ¯nal approach is fully parametrized and represents exactly what we mean
+
by binary trees, no more and no less. We use nodes 1, t , t and d. Now the only
operations we put in are empty; incl; val; left and right. We also need the cones
+
and cocones necessary to say that t
= 1 + t with inclusions empty and incl and
+
that t
= t £ d £ t with projections left, val and right.
Then if F :
¡! Nat is as above and H :
¡! BinTree is de¯ned by H(e) =
d, then the pushout of
F
-
Nat
H
?
?
-
BinTree
BinTree(Nat)
is a sketch whose models can be interpreted as binary trees of natural numbers.
3.2.4 Further combinators
This operation can be iterated. For example, we
can form the pushout
K
-
BinTree(Nat)
G
?
?
-
Stack
Stack(BinTree(Nat))
with Ke = t or even
L
-
Stack(Nat)
H
?
?
-
BinTree
BinTree(Stack(Nat))
with Le = s. Models of these types will be interpreted as stacks of binary trees of
natural numbers, respectively binary trees of stacks of natural numbers. Clearly
what is at issue here is a notion of a type having an input node and an output
node. However, things are not quite so simple, as the following example shows.
3.2.5
The basic idea of this type is that of n-place records (Pascal) or structures
(C). We leave aside here the use of variant records (which can be adequately
handled by judicious use of ¯nite sums as C's union type shows). Another question
we do not tackle is that of parametrizing n. At this point, we make no attempt to

3.2 Parametrized data types
31
relate the sketches for two-place and three-place records, say, although it seems
clear that in a mature theory this will be done. Parametrizing n is discussed in
[Wagner, 1986] and [Gray, 1989].
So we describe a sketch we will call Rec . It has nodes r and d ; d ; : :: ; d
n
1
2
n
and one cone
r
¡
@
¡
@
¡
@
¡ª
@R
¢ ¢¢
d
d
1
n
As it stands, the initial model of this sketch has all values empty. It is really a
shell of a sketch. To give it content, we must ¯ll in values for the data. To do this
we must ¯rst recognize that the sketch has n input types and these must all be
speci¯ed. This could be done in n steps, but it is more coherent to do it all at
once.
Let
denote the discrete graph with nodes e ; :: : ; e . There is an obvious
n
1
n
arrow D :
¡! Rec given by De = d . If, for example, we formed the pushout
n
n
n
i
i
Dn -
Rec
n
n
Fn
?
?
-
Nat
Arrayn
where F e = n; i = 1; :: :; n, the resultant sketch can be evidently interpreted as
n i
arrays of natural numbers. On the other hand, the pushout
D3
-
Rec
3
3
?
?
-
Nat +String + Real
(where we suppose that sketches for String and Real have already been de¯ned)
is a sketch for three-place records, of which the ¯rst ¯eld is natural numbers, the
second is strings and the third is °oating point reals.
The ideas in this section are discussed without the explicit use of sketches in
[Thatcher, Wagner and Wright, 1982], [Ehrig et al., 1984] and [Wagner, 1986].
3.2.6 Parametrizing operations
The sketch
in the upper left corner of
+
the pushout diagrams can contain operations. For example, let Nat
denote the
sketch for natural numbers with an added operation + : n£n ¡! n with diagrams
¤
forcing it to be addition in the initial model, and Nat a similar sketch with an

32
The category of sketches
added operation ¤ : n £ n ¡! n forced to be multiplication there. Let Diag be
the sketch whose graph contains operations
¢
m
n ¡¡! n £ n ¡¡! n
a cone with arrows p : n £ n ¡! n, i = 1; 2, to force n £ n to be the indicated
i
product and a diagram to force ¢ to be the diagonal map in a model. Let BinOp
be the sketch containing n £ n ¡! n and similar data making n £ n the indicated
+
¤
product. BinOp is included in both Diag and in each of Nat
and Nat . A
pushout
-
BinOp
N
?
?
-
Diag
+
+
¤
with N = Nat
would add a doubling operator to Nat
and with N = Nat
¤
would add a squaring operator to Nat .
3.2.7 Arithmetic
One last, more speculative example will show that we have
barely begun to explore this idea. Let us suppose that we have de¯ned two
sketches called Real and Complex that implement the arithmetic operations
(addition, subtraction, multiplication and division) of real and complex numbers,
respectively, as well as absolute value. While it is true that real numbers are a
special case of complex numbers and therefore do not, in principle, have to be
treated di®erently, it is also true that real arithmetic is much easier and faster
and virtually every language that implements a complex number type treats them
separately.
Suppose, further, there is a sketch Trig whose operations implement the
trigonometric functions by means of power series or other approximations which
have the same algorithm for real and for complex numbers. This sketch will use
four formal arithmetic operations on an abstract data type d which admits the
arithmetic operations and absolute value, but is not otherwise speci¯ed. These
¯ve operations are determined by a sketch Arith which has an arrow to all of
Real; Complex; Trig.
If we now form the pushout
-
Arith
Real
?
?
-
Trig
RealTrig
we get a sketch for the real type with trigonometric functions and if we replace
Real by Complex, we get a sketch for complex trigonometry.

3.3 The model category functor
33
3.2.8 Exercise
1. If
is the pushout of Diagram (ES3.1), describe precisely the nodes in
which must become a singleton in a model in Set.
3.3 The model category functor
Sketch is a category whose objects are sketches. If
is a ¯xed category, then each
sketch produces a category of models of the sketch in
(see 7.4.4). The category
of models in
of a sketch
we will call Mod (
). (Mod (
) might very
well be the empty category.)
Most of the examples in this book have had
= Set, which regrettably obscures
one of the major advantages sketches have over standard logical theories: the fact
that their models can be in any suitable category.
3.3.1
For each sketch homomorphism F :
¡!
we will now describe a func-
tor Mod (F) : Mod (
) ¡! Mod (
) (note the reversal). Mod (F) is also
¤
¤
denoted F , and is called the functor induced by F. F
is de¯ned by MF{1
¤
and MF{2 below. If M is a model of
then F (M) is a model of
.
¤
¤
±
MF{1 The object function of F
is de¯ned by F (M) = M
F. Thus if g is a
¤
node or arrow of the graph of
and M is a model of
, then F (M)(g) =
M(F(g)).
¤
MF{2 If ® : M ¡! N is a homomorphism of models of
, de¯ne F (®) to be the
natural transformation ®F as de¯ned in Section 4.4. Thus at a node g of
the graph of
,
¤
F (®)(g) = (®F)g = ®F(g) : M(F(g)) ¡! N(F(g))
3.3.2 Proposition
For each model M of
and homomorphism F :
¡!
,
¤
F (M) is a model of
.
Proof. Since M is among other things a graph homomorphism and so is F, and
the composite of graph homomorphisms is a graph homomorphism, MF{1 makes
¤
±
F (M), which is M
F, respect the source and target of arrows of the graph, so
that it is a graph homomorphism to
as a model should be.
±
If D is a diagram of
, then because F is a homomorphism of sketches, F
D
¤
±
±
±
is a diagram of
. Since M is a model of
, F (M)
D = M
F
D commutes.
±
Suppose v ¡! D is a cone of
. Then F(v) ¡! F
D is a cone of
which must
¤
±
±
be taken to a limit cone by M. Since F (M)(v ¡! D) = M(F(v)) ¡! M
F
D,
¤
F (M) takes v ¡! D to a limit cone. A similar argument deals with cocones.

34
The category of sketches
3.3.3 Proposition
For each homomorphism ® : M ¡! N of models of
and
homomorphism F :
¡!
of sketches, Mod (F)(®) as de¯ned by MF{2 is a
homomorphism of models of
.
¤
Proof. By MF{2, F (®) is the natural transformation ®F de¯ned in 4.4.1. Since
its domain and codomain are models, it is a homomorphism of models by de¯ni-
tion.
For any sketch
, let Mod (
) be the category of models of
in
(we
called this Mod(
;
) in Section ES 2.1. If F :
¡!
is a homomorphism of
sketches, we have de¯ned a functor Mod (F) : Mod (
) ¡! Mod (
).
op
3.3.4 Proposition
Mod
: Sketch
¡! Cat is a functor.
The proof involves some simple checking and is left as an exercise.
3.3.5 Example
In Section 3.1, we gave several examples of underlying set
functors U :
¡! Set. In general, such functors are induced by a homomorphism
of sketches from the trivial sketch
de¯ned in ES 3.1.2 to a particular node of the
sketch
. For example, the underlying set functor U : Sem ¡! Set (see 3.1.8) is
induced by the unique sketch homomorphism from
to the sketch for semigroups
that takes the only node of
to s. This follows directly from MF{1 and MF{
2 and the fact that a model of
in Set is essentially a set (Exercise ES 1 of
Section ES 3.2). Similarly the underlying arrow and node functors A : Grf ¡! Set
and N : Grf ¡! Set (see 3.1.9) are induced by the sketch homomorphisms from
to the sketch for graphs that take e to a and to n respectively.
3.3.6 Example
The sketch homomorphism of Example ES 3.1.3 induces the
functor from the category of graphs to the arrow category of Set that takes a
graph to its source function. The homomorphism of Example ES 3.1.4 that in-
cludes the sketch for graphs into the sketch for simple graphs induces the under-
lying functor that forgets that a graph is simple. Similarly the functor of ES 3.1.5
that includes the sketch for semigroups into the sketch for ¯elds induces the
underlying functor from ¯elds to semigroups that takes a ¯eld to its additive
semigroup.
3.3.7 Example
Sketches usually include only the minimal information that
is needed to describe a theory. There is a cost to this in that they may omit
crucial information needed to de¯ne morphisms. Here is an uncontrived example
that illustrates the point. We begin by observing that in any category, if 1 is a
terminal object (vertex of a cone with empty base) and S £S is a product of two

3.3 The model category functor
35
copies of S, then the square
-
S £ S
S
?
?
-
S
1
is a pullback. Now consider the functor from the category Mon of monoids to the
category Cat of small categories that takes a monoid to the corresponding cate-
gory with one object (see 2.3.12). One expects that this functor would be induced
by a sketch homomorphism from the sketch for categories given by ES 2.1.5 to
the sketch for monoids given by 7.2.1 as augmented by 7.3.2. Since the underlying
set of the monoid is the set of arrows of the corresponding category, the sketch
homomorphism should take the node c of ES 2.1.5 to the node s of 7.2.1, and
1
the arrow c of ES 2.1.5 (which we will call comp here to avoid confusion) should
go to the multiplication c of 7.2.1. Since comp has domain c and c has domain
2
s £ s, c should go to s £ s. Unfortunately, s £ s is the vertex of a discrete cone
2
and c is the vertex of a pullback cone. And besides, where should c go?
2
0
The key is to map c to the object 1 of the sketch for monoids, so that s and
0
t are forced to go to the unique map from s to 1. This would force the pullback
cone
c2
¡
@
p
p
¡
@
1
2
¡
@
¡ª
?
@R
-
¾
c
c
c
1
0
1
s
t
to go to the cone
s £ s
¡
@
p
p
¡
@
1
2
¡
@
¡ª
?
@R
-
¾
s
1
s
which unfortunately is not a cone in the sketch for monoids. However, it is a cone
in the FL theory for the sketch for monoids, so it would appear that, although
we cannot realize the functor in question as induced by a sketch homomorphism
from the sketch for categories to the sketch for monoids, it is nevertheless induced
by a homomorphism to a sketch { the underlying sketch of the theory of monoids.
It is clear that, as the preceding example illustrates, one would normally
want to consider homomorphisms of theories (functors that preserve ¯nite limits
in this case) rather than homomorphisms of sketches. In practice, one would
construct a homomorphism from a sketch
to the theory of a sketch
since

36
The category of sketches
such a homomorphism would extend essentially uniquely to a mapping between
theories. An alternative would be to adjoin just what you need to
to make the
homomorphism work (the cone of Diagram (ES 3.3.7) { and others { in this case),
but that seems excessively clumsy when the whole theory exists in any case.
3.3.8
It is almost immediate that Propositions ES 3.3.2, ES 3.3.3 and ES 3.3.4
remain true if the category Sketch is replaced by the category of sketches with
diagrams based on a speci¯c class of shape graphs, cones to speci¯c class of
shape graphs not necessarily the same as that of the diagrams, and cocones from
a speci¯c class of shape graphs not necessarily the same as either of the other
two. For example, taking any shapes for the diagrams, ¯nite discrete shapes for
the cones, and no shapes for the cocones gives the category of FP sketches and
homomorphisms between them, so all these propositions are true of FP sketches.
3.3.9 Sentences
For this subsection only, we will say a sentence in a sketch
is a diagram, cone or cocone in the graph of
, not necessarily one in the
speci¯ed set of diagrams, cones or cocones. The sentence is satis¯ed in a model
M of
if it commutes when M is applied (if it is a diagram) or if it is a limit
(co)cone when M is applied (if it is a (co)cone).
If F :
¡!
is a sketch homomorphism, and ¾ is a sentence of
, then
F(¾) is a sentence of
where F(¾) is de¯ned by composition: this follows from
the de¯nition of sketch homomorphism.
3.3.10 Proposition
If F :
¡!
is a sketch homomorphism and ¾ is a
sentence of
, then F(¾) is satis¯ed in a model M of
in a category
if and
only if ¾ is satis¯ed in Mod (F)(M).
This follows directly from the de¯nitions and is left as an exercise.
Propositions ES 3.3.4 and ES 3.3.10 imply that the category of sketches with
designated shape graphs for each of the diagrams, cones and cocones, together
with sentences, form a `simple institution' in the sense of [Goguen and Burstall,
1986].
3.3.11
The results of this section show the way in which sketches are a very
di®erent method for describing mathematical structures from the theories of tra-
ditional mathematical logic. Of course, sketches use graphs, diagrams, cones and
cocones instead of variables, symbols, expressions and formulas, but that di®er-
ence, although signi¯cant, is not the biggest di®erence. When you use sketches,
you factor the entire descriptive process di®erently. We have already discussed
the di®erences to some extent for FP sketches in 7.2.8.
An example of the subtlety of the di®erence is exempli¯ed by our word `sen-
tence' above. Diagrams correspond to universally quanti¯ed sentences, and the
correspondence, which is not entirely trivial (see Section 7.7), is nevertheless ex-
act. But to use a cone as a sentence corresponds to a statement about a type in

3.3 The model category functor
37
multisorted logic, rather than statements about terms. (McLarty [1986] makes
this explicit.) Such statements have not played a big role in classical logic. In
classical logic, you do not say (with an axiom) that a type is (for example) a
product type; the product type is implicit in the existence of some given term
which has a sequence of variables of speci¯c types.
On the other hand, our sentences do not provide a way of giving universal
Horn clauses in (for example) an FL sketch. When using sketches, universal Horn
clauses are usually implicit. Such a clause which must be satis¯ed in all models
is given by an arrow built into the graph of the sketch which causes an operation
to factor through some limit type. Thus if you wanted to require
a = b ) g(f(a; b)) = h(f(a;b))
where a and b are of type A, f is an operation of type C and g and h are operations
of type D, you build the graph of your sketch with arrows f : A£A ¡! C, g;h : C
¡! D, e : E ¡! C, u : A ¡! E and d : A ¡! A £ A, with cones requiring A £ A
to be the required product, e to be the equalizer of g and h, d to be the diagonal
map, and this diagram
d-
A
A £ A
u
f
?
?
-
E
C
e
±
which requires f
d to factor through the equalizer of g and h. It is built into
the graph in a way analogous to the way in classical logic you build the product
types implicitly by incorporating speci¯c terms.
There is presumably a theory of sentences built in this way which makes FL
sketches an institution, but it will require work to produce it: it does not ¯t well
with the ingredients of a sketch. In the same way, building an institution out
of classical logic using a de¯nition of sentence which allows you to state that a
type is a certain equalizer or pullback requires work because it does not ¯t the
traditional way of doing things. (It is not impossible, it merely does not ¯t well.)
The classical approach and the sketch approach make di®erent things easy.
3.3.12 Exercises
1. In Example 4.3.6 we de¯ned a functor U £ U : Mon ¡! Set. Show that it is
induced by a homomorphism of sketches.
¤
2. Prove that MF{2 makes F
a natural transformation.
3. Prove Proposition ES 3.3.4.
4. Prove Proposition ES 3.3.10.

4
Fibrations
A category is both a generalized poset and a generalized monoid. Many construc-
tions in category theory can be understood in terms of the constructions in posets
that they generalize, so that it is generally good advice when learning about a
new categorical idea to see what it says about posets. Seeing what a construction
says about monoids has not usually been so instructive.
However, certain concepts used to study the algebraic structure of monoids
generalize to categories in a natural way, and often the theorems about them
remain true. In addition, applications of monoids to the theory of automata have
natural generalizations to categories, and some work has been done on these
generalized ideas.
In this chapter we describe some aspects of categories as generalized monoids.
We begin in Section ES 4.1 with the concept of ¯bration, which has been used
in recent research on polymorphism. One way of constructing ¯brations is by
the Grothendieck construction, described in Section ES 4.2, which is a general-
ization of the semidirect product construction for monoids. Section ES 4.3 gives
an equivalence between certain types of ¯brations and category-valued functors.
Section ES 4.4 describes the wreath product of categories, a generalization of the
concept of the same name for monoids; some applications of the construction are
mentioned.
The Grothendieck construction is used in Section ES 5.7. The rest of the ma-
terial is not used elsewhere in the book.
4.1 Fibrations
In this section, we describe ¯brations, which are special types of functors impor-
tant in category theory and which have been proposed as useful in certain aspects
of computer science.
The next section gives a way of constructing ¯brations from set or category-
valued functors.
4.1.1 Fibrations and op¯brations
Let P :
¡!
be a functor between
small categories, let f : C ¡! D be an arrow of
, and let P(Y ) = D. An arrow
u : X ¡! Y of
is cartesian for f and Y if
CA{1 P(u) = f.
38

4.1 Fibrations
39
CA{2 For any arrow v : Z ¡! Y of
and any arrow h : P(Z) ¡! C of
for
±
±
which f
h = P(v), there is a unique w : Z ¡! X in
such that u
w = v
and P(w) = h.
Similarly, if f : C ¡! D and P(X) = C, then an arrow u : X ¡! Y is op-
cartesian for f and X if
OA{1 P(u) = f.
OA{2 For any arrow v : X ¡! Z of
and any arrow k : D ¡! P(Z) for which
±
±
k
f = P(v), there is a unique w : Y ¡! Z in
for which w
u = v and
P(w) = k.
If P :
¡!
is a functor, categorists often think of
as being above
. (This
is also common for functions between spaces, which is what originally suggested
the ideas in this section.) For example, if P(Y ) = D, one says that Y lies over
D. Similar terminology is used for arrows. Thus a cartesian arrow for f must lie
over f (CA{1) and one refers to CA{2 as a `unique lifting' property.
4.1.2 De¯nition
A functor P :
¡!
is a ¯bration if there is a cartesian
arrow for every f : C ¡! D in
and every object Y of
for which P(Y ) = D.
P is an op¯bration if there is an opcartesian arrow for every f : C ¡! D in
and every object X of
for which P(X) = C. It follows that P :
¡!
is a
op
op
op
¯bration if and only if P
:
¡!
is an op¯bration.
If P :
¡!
is a ¯bration, one also says that
is ¯bered over
. In that
case,
is the base category and
is the total category of the ¯bration.
4.1.3 De¯nition
A cleavage for a ¯bration P :
¡!
is a function ° that
takes an arrow f : C ¡! D and object Y such that P(Y ) = D to an arrow °(f;Y )
of
that is cartesian for f and Y . Similarly an opcleavage · takes f : C ¡! D
and X such that P(X) = C to an arrow ·(f;X) that is opcartesian for f and X.
The cleavage ° is a splitting of the ¯bration if it satis¯es the following two
requirements.
SC{1 Let D be an object of
and let Y be an object of
for which P(Y ) = D.
Then °(id ;Y ) = id .
D
Y
SC{2 Suppose f : C ¡! D and g : D ¡! E in
and suppose Y and Z are objects
of
for which P(Z) = E and Y is the domain of °(g; Z). Then
±
±
°(g; Z)
°(f; Y ) = °(g
f;Z)
Note that under the assumptions in SC{2, P(Y ) = D, so that °(f; Y ) and
±
°(g; Z)
°(f; Y ) are de¯ned.
A ¯bration is split if it has a splitting.

40
Fibrations
Similarly, an opcleavage · is a splitting of an op¯bration P :
¡!
if
·(id ;X) = id
whenever P(X) = C and
C
X
±
±
·(g; Y )
·(f; X) = ·(g
f;X)
whenever f : C ¡! D and g : D ¡! E in
, P(X) = C and Y is the codomain of
·(f;X). A split op¯bration is again one which has a splitting.
4.1.4 Example
Let
and
be any categories. Then the second projection
p :
£
¡!
is both a split ¯bration and a split op¯bration. To see that it
2
0
0
is a ¯bration, suppose that f : C ¡! C in
and let Y = (A;C ) be an object of
0
£
. Then we can take °(f; Y ) to be the arrow (id ; f) : (A; C) ¡! (A;C ). If
A
0
00
0
00
±
(g;h) : (A ;C ) ¡! (A; C ) and u : C ¡! C satisfy f
u = h (note that p (g;h) =
2
0
00
0
h), then the unique arrow from (A ;C ) to (A; C ) required by CA{2 is (g;u).
4.1.5 Example
If
is a category, the arrow category of
(which we have
already mentioned in 4.2.17) has as objects the arrows of
. An arrow from f : A
¡! B to g : C ¡! D is a pair (h; k) of arrows with h : A ¡! C, k : B ¡! D for
which
h -
A
C
g
f
(4.1)
?
?
-
B
D
k
commutes.
If
is the arrow category of
, there is a functor P :
¡!
which takes
f : A ¡! B to B and (h; k) : f ¡! g to k. If
has pullbacks, this functor is a
¯bration. For a given f : C ¡! D in
and object k : B ¡! D of
, a cartesian
arrow for f and k is any (u; f) given by a pullback
u -
P
B
0
k
u
(4.2)
?
?
-
C
D
f
The veri¯cation is left as an exercise (Exercise ES 4).
4.1.6 Fibers
For any functor P :
¡!
, the ¯ber over an object C of
is
the set of objects X for which P(X) = C and arrows f for which P(f) = id . It
C
is easy to verify that this ¯ber is a subcategory of
(Exercise ES 1).

4.1 Fibrations
41
In the case of Example ES 4.1.4, the ¯bers are all the same: each one is iso-
morphic to the category
. This suggests thinking of an arbitrary ¯bration as a
type of generalized product, in which the ¯rst coordinates come in general from
varying sets depending on the second coordinate. This observation can also be
made concerning the relationship between a set product S £ T and a general
T-indexed set.
On the other hand, the ¯ber of the ¯bration in Example ES 4.1.5 over an
object A of
is the slice category
=A. Since an object of
=A can be thought
of as an indexed family of objects of
, indexed by A, this example has been
referred to as
`¯bered over itself'.
4.1.7 Cleavages induce functors
If
is ¯bered over
, then the ¯bers form
an indexed set of categories (indexed by the objects). Given a cleavage, the arrows
of
induce functors between the ¯bers. In this way ¯brations or op¯brations give
a concept like that of indexed sets, in which the indexing takes into account the
arrows of the underlying categories as well as the objects. Propositions ES 4.1.8
and ES4.1.9 below spell this out.
An alternative approach to these ideas which follows the indexed set analogy
more explicitly is the concept of indexed category (see [Johnstone and Par¶e,
1978], [Tarlecki, Burstall and Goguen, 1991]). Rosebrugh and Wood [1992] apply
indexed categories to relational databases and Cockett and Spencer [1992] use
them in studying datatypes.
In the rest of this chapter, when F :
¡! Cat or F :
¡! Set is a functor,
we will normally write Ff for F(f).
Let P :
¡!
be an op¯bration with opcleavage ·. De¯ne F :
¡! Cat by
FF{1 F(C) is the ¯ber over C for each object C of
.
FF{2 For f : C ¡! D in
and X an object of F(C), Ff(X) is de¯ned to be the
codomain of the arrow ·(f;X).
0
FF{3 For f : C ¡! D in
and u : X ¡! X in F(C), Ff(u) is the unique arrow
0
from Ff(X) to Ff(X ) given by OA{2 for which
0
±
±
Ff(u)
·(f; X) = ·(f;X )
u
4.1.8 Proposition
Let P :
¡!
be an op¯bration with cleavage ·. For any
arrow f : C ¡! D in
, Ff : F(C) ¡! F(D) as de¯ned by FF{1 through FF{3
is a functor. Moreover, if · is a splitting, then F is a functor from
to Cat.
0
0
00
Proof. Let u : X ¡! X and v : X ¡! X
in F(C). Then
0
±
±
±
±
Ff(v)
Ff(u)
·(f; X)
=
Ff(v)
·(f; X )
u
(4.3)
00
±
±
=
·(f; X )
v
u
±
by two applications of FF{3. But then by the uniqueness part of FF{3, Ff(v)
±
Ff(u) must be Ff(v
u). This proves Ff preserves composition. We leave the
preservation of identities to you.

42
Fibrations
Now suppose · is a splitting. Let f : C ¡! D and g : D ¡! E in
, and let
0
±
±
u : X ¡! X in F(C). Then F(g
f)(u) is the unique arrow from F(g
f)(X)
0
0
±
±
±
(the codomain of ·(g
f; X)) to F(g
f)(X ) (the codomain of ·(g
f; X )) for
which
0
±
±
±
±
±
F(g
f)(u)
·(g
f; X) = ·(g
f; X )
u
Since · is a splitting, this says
0
0
±
±
±
±
±
F(g
f)(u)
·(g; Ff(X))
·(f; X) = ·(g;Ff(X ))
·(f; X )
u
By FF{3, the right side is
0
±
±
·(g;Ff(X ))
Ff(u)
·(f; X)
Applying FF{3 with g and Ff(u) instead of f and u, this is the same as
±
±
Fg[Ff(u)]
·(g; Ff(X))
·(f; X)
which is
±
±
Fg[Ff(u)]
·(g
f;X)
because · is a splitting. Using the uniqueness requirement in FF{3, this means
±
F(g
f)(u) = Fg[Ff(u)], so that F preserves composition. Again, we leave
preservation of the identity to you.
op
In a similar way, split ¯brations give functors
¡! Cat. Let P :
¡!
op
be a ¯bration with cleavage °. De¯ne F :
¡! Cat by
0
FF {1 F(C) is the ¯ber over C for each object C of
.
0
FF {2 For f : C ¡! D in
and Y an object of F(D), Ff(Y ) is de¯ned to be the
domain of the arrow °(f;Y ).
0
0
FF {3 For f : C ¡! D in
and u : Y ¡! Y in F(D), Ff(u) is the unique arrow
0
from Ff(Y ) to Ff(Y ) given by CA{2 for which
0
±
±
°(f;Y )
Ff(u) = u
°(f; Y )
4.1.9 Proposition
Let P :
¡!
be a ¯bration with cleavage ·. For any
arrow f : C ¡! D in
, Ff : F(C) ¡! F(D) as de¯ned by FF{1 through FF{3
op
is a functor. Moreover, if ° is a splitting, then F is a functor from
to Cat.
The proof is similar to those of Proposition ES 4.1.8 and is left as an exercise.
4.1.10 Exercises
1. Verify that for any functor P :
¡!
and object C of
, the ¯ber over an
object C is a subcategory of
.
2. Prove Proposition ES 4.1.9.

4.2 The Grothendieck construction
43
3. Let Á : Z ¡! Z be the homomorphism de¯ned in Exercise 2 of Section 2.9.
4
2
a. Show that the functor from C(Z ) to C(Z ) induced by Á is a ¯bration and
4
2
an op¯bration. (If you know about groups, this is an instance of the fact that
every surjective group homomorphism is a ¯bration and an op¯bration.)
b. Show that Á is not a split ¯bration or op¯bration.
4. Let
be a category with pullbacks and
its arrow category. For an arrow
f : A ¡! B (object of
) let P(f) = B. For an arrow (h;k) : f ¡! g (where g : C
¡! D in
) in
, let P(h; k) = k.
a. Show that P :
¡!
is a functor.
b. Show that P is a ¯bration.
4.2 The Grothendieck construction
The Grothendieck construction is a way of producing ¯brations. It generalizes
the semidirect product construction for monoids, which is de¯ned here. Hyland
and Pitts [1989] use the Grothendieck construction to construct categories that
are models of the calculus of constructions, a system due to Coquand and Huet
[1988] that provides a way of handling polymorphism essentially by quantifying
over types. (See also [Coquand, 1988], [Ehrhard, 1988] and [Asperti and Martini,
1992].)
The construction can be applied to either set-valued functors or category-
valued functors. Given such a functor F :
¡! Set or F :
¡! Cat, it con-
structs a category G(
; F) and a functor from G(
; F) to
. When F is set-
valued we will write G
instead of G. We will look at the set-valued case ¯rst,
0
since it is simpler.
4.2.1
Let
be a small category and let F :
¡! Set be a functor. For each
object C of
, F(C) is a set, and for each arrow f : C ¡! D, F(f) : F(C) ¡! f(D)
is a set function. There is no set of all sets or set of all set functions, but, since
is small, there certainly is a set consisting of all the elements of all the sets
F(C), and similarly there is a set consisting of all the functions F(f). In other
words, although Set is large, the description of F :
¡! Set requires only a
small amount of data. (`Small' and `large' are used here in the technical sense,
referring to whether or not a set of data is involved. See 1.3.4.)
By contrast, to describe a functor G : Set ¡!
would require a large amount of
data { an object of
for each set, and so on.
We will formalize these observations about F :
¡! Set by taking the disjoint
union of all the sets of the form F(C) for all objects C of
. The elements of
this disjoint union can be represented as pairs (x;C) for all objects C of
and
elements x 2 F(C). (Thus we construct the disjoint union of sets by labeling

44
Fibrations
the elements. The disjoint union is the construction in Set corresponding to the
categorical concept of `sum', discussed in Section 5.4.)
We must do more than this to capture the functorial nature of F { what it
does to arrows of
. The category G (
; F) constructed by the Grothendieck
0
construction does capture this structure, and its set of objects is the disjoint
union just mentioned.
4.2.2
If we were to draw a picture to explain what F does, the result might be
0
0
00
Diagram (ES 4.4), in which f : C ¡! C and g : C ¡! C
are arrows of
and x
0
0
and x are elements of F(C) and F(C ) respectively. The box over each object C
-
-
±
x
Ff(x)
(Fg
Ff)(x)
Ff
Fg
-
-
(4.4)
0
0
-
x
Fg(x )
g
f
0
-
00
-
C
C
C
0
of
represents the elements of F(C). The arrows from x to Ff(x) and from x
0
to Fg(x ) are there informally to illustrate what the set functions Ff and Fg do.
These informal arrows become actual arrows in G (
;F).
0
4.2.3 De¯nition
G (
;F) is the category de¯ned as follows.
0
GS{1 An object of G (
; F) is a pair (x; C) where C is an object of
and x is
0
an element of F(C) (as observed, the C occurs in the pair (x;C) because
we want the disjoint union of the values of F).
0
0
GS{2 An arrow is a pair of the form (x;f) : (x;C) ¡! (x ;C ) where f is an arrow
0
0
f : C ¡! C of
for which Ff(x) = x .
0
0
0
0
0
00
00
0
±
GS{3 If (x; f) : (x; C) ¡! (x ; C ) and (x ; g) : (x ; C ) ¡! (x ; C ), then (x ; g)
00
00
(x; f) : (x; C) ¡! (x ;C ) is de¯ned by
0
±
±
(x ; g)
(x; f) = (x; g
f)
00
±
Note in GS{3 that indeed F(g
f)(x) = x as required by GS{2.
The reason that we use the notation (x; f) is the requirement that an arrow
must determine its source and target. The source of (x; f) is (x;C), where C is
0
0
0
the source of f and x is explicit, while its target is (x ; C ), where C is the target
0
of f and x = Ff(x). In the literature, (x;f) is often denoted simply f, so that

4.2 The Grothendieck construction
45
the same name f may refer to many di®erent arrows { one for each element of
F(C). We used lacunary notation of this sort in de¯ning slice categories in 2.6.10.
Projection on the second coordinate de¯nes a functor
G (F) : G (
;F) ¡!
0
0
G (
; F) together with G (F) is called the split discrete op¯bration induced
0
0
by F, and
is the base category of the op¯bration.
If C is an object of
, the inverse image under G (F) of C is simply the set
0
F(C), although its elements are written as pairs so as to form a disjoint union.
This discrete op¯bration is indeed an op¯bration, in fact a split op¯bration. If
0
f : C ¡! C in
and (x; C) is an object of G (
;F), then an opcartesian arrow
0
0
is (x; f) : (x; C) ¡! (Ff(x); C ) (Exercise ES2). The word `discrete' refers to the
fact that the ¯bers are categories in which the only arrows are identity arrows;
such categories are essentially the same as sets.
4.2.4 Semidirect products
We now describe a more general version of the
Grothendieck construction that has the semidirect product of monoids as a special
case. We ¯rst de¯ne the semidirect product of monoids: it is constructed from
two monoids, one of which acts on the other.
4.2.5 De¯nition
If M and T are monoids, an action of M on T is a function
® : M £ T ¡! T for which
MA{1 ®(m;1 ) = 1
for all m 2 M.
T
T
MA{2 ®(m;tu) = ®(m;t)®(m;u) for all m 2 M and t; u 2 T.
MA{3 ®(1 ; t) = t for all t 2 T.
M
MA{4 ®((mn); t) = ®(m;®(n;t)) for all m;n 2 M and t 2 T.
If we curry ® as in 6.1.2, we get a family of functions Á(m) : T ¡! T with the
0
0
properties listed in MA {1 through MA {4 below.
0
MA {1 Á(m)(1 ) = 1
for all m 2 M.
T
T
0
MA {2 Á(m)(tu) = Á(m)(t)Á(m)(u) for all m 2 M and t; u 2 T.
0
MA {3 Á(1 )(t) = t for all t 2 T.
M
0
MA {4 Á(mn)(t) = Á(m)[Á(n)(t)] for all m; n 2 M and t 2 T.
Thus we see that an alternative formulation of monoid action is that it is a
monoid homomorphism Á : M ¡! End(T) (End(T) being the monoid of endo-
0
0
morphisms of T). MA {1 and MA {2 say that each function Á(m) is an endo-
0
0
morphism of T, and MA {3 and MA {4 say that Á is a monoid homomorphism.

46
Fibrations
4.2.6 De¯nition
The semidirect product of M and T with the given action
® as just de¯ned is the monoid with underlying set T £ M and multiplication
de¯ned by
0
0
0
0
(t;m)(t ; m ) = (t®(m;t ); mm )
To see the connection with the categorical version below you may wish to
write this de¯nition using the curried version of ®.
4.2.7
The categorical construction corresponding to a monoid acting on a mon-
oid is a functor which takes values in Cat rather than in Set. A functor F :
¡! Cat can be regarded as an action of
on a variable category which plays the
role of T in the de¯nition just given.
In the case of a monoid action de¯ned by MA{1 through MA{4, the variable
category is actually not varying: it is the category C(T) determined by the monoid
T. The functor F in that case takes the single object of M to the single object of
T, and, given an element m 2 M, F(m) is the endomorphism of T which takes
t 2 T to mt: in other words, F(m)(t) = mt. Thus F on the arrows is the curried
form of the action ®.
A set-valued functor is a special case of a category-valued functor, since a set can
be regarded as a category with only identity arrows. Note that this is di®erent from
the monoid case: an action by a monoid on a set is not in general a special case of
an action by the monoid on a monoid. It is, however, a special case of the action of
a monoid on a category { a discrete category.
4.2.8
Given a functor F :
¡! Cat, the Grothendieck construction in this
more general setting constructs the op¯bration induced by F, a category G(
;F)
de¯ned as follows:
GC{1 An object of G(
; F) is a pair (x; C) where C is an object of
and x is
an object of F(C).
0
0
0
GC{2 An arrow (u; f) : (x; C) ¡! (x ; C ) has f : C ¡! C an arrow of
and
0
0
u : Ff(x) ¡! x an arrow of F(C ) (note that by de¯nition Ff(x) is an
0
object of F(C )).
0
0
0
0
00
00
±
GC{3 If (u; f) : (x; C) ¡! (x ; C ) and (v; g) : (x ; C ) ¡! (x ; C ), then (v; g)
00
00
(u; f) : (x; C) ¡! (x ; C ) is de¯ned by
±
±
±
(v;g)
(u;f) = (v
Fg(u); g
f)
4.2.9 Theorem
Given a functor F :
¡! Cat, G(
; F) is a category and the
second projection is a functor P : G(
; F) ¡!
which is a split op¯bration with
splitting
0
·(f; X) = (id
; f) : (x; C) ¡! (Ffx;C )
F fx
0
for any arrow f : C ¡! C of
and object (x;C) of G(
;F).

4.2 The Grothendieck construction
47
We omit the proof of this theorem. G(
; F) is called the crossed product
£ F by some authors.
It is instructive to compare this de¯nition with the discrete op¯bration con-
structed from a set-valued functor. In the case that F is set-valued, the ¯rst
0
0
component u of an arrow (u; f) : (x; C) ¡! (x ;C ) has to be an identity arrow
and it has to be id
. Thus the only arrows are of the form (id
;f) : (x;C)
Ff(x)
F f(x)
0
¡! (x ;C). Such an arrow is denoted (x; f) in GS{1 through GS{3.
To visualize the Cat-valued Grothendieck construction, we can modify the
picture in Diagram (ES 4.4) to get Diagram (ES 4.5). The arrows from inside one
-
-
±
x
Ff(x)
(Fg
Ff)(x)
Ff
Fg
-
-
u
Fg(u)
?
?
0
0
-
x
Fg(x )
(4.5)
v
?
00
x
g
f
0
-
00
-
C
C
C
box to inside another, such as the arrow from x to Ff(x), are parts of arrows of
G(f), which are now (in contrast to the discrete case) allowed to miss the target
and be rescued by an internal arrow of the codomain category.
Thus in the picture above there is an arrow from x to Ff(x) and Ff(x)
0
0
0
is not necessarily x ; the gap is ¯lled by the arrow u : Ff(x) ¡! x of F(C ).
0
0
The arrow (u; f) : (x; C) ¡! (x ; C ) of G(
; F) may be pictured as the arrow
from x to Ff(x) followed by u. Observe that the de¯nition of composition says
0
0
±
that the square in the picture with corners Ff(x), (Fg
Ff)(x), x and Fg(x )
`commutes'.
0
0
0
As before, one writes (x; C) for x and (x ; C ) for x only to ensure that the
union of all the categories of the form F(C) is a disjoint union.
4.2.10
An analogous construction, also called the Grothendieck construction (in
fact this is the original one), produces a split ¯bration F(
; G) given a functor
op
G :
¡! Cat.
FC{1 An object of F(
; G) is a pair (C; x) where C is an object of
and x is
an object of G(C).
0
0
0
FC{2 An arrow (f; u) : (C;x) ¡! (C ;x ) has f : C ¡! C an arrow of
and u : x
0
¡! Gf(x ) an arrow of G(C).

48
Fibrations
0
0
0
0
00
00
±
FC{3 If (f; u) : (C; x) ¡! (C ; x ) and (g; v) : (C ; x ) ¡! (C ; x ), then (g; v)
00
00
(f; u) : (C;x) ¡! (C ; x ) is de¯ned by
±
±
±
(g;v)
(f;u) = (g
f; Gf(v)
u)
4.2.11
In line with the concept that a category is a mathematical workspace,
one could ask to construct objects in a suitably rich category which themselves
are categories. The Grothendieck construction provides a way to describe func-
tors from such a category object to the ambient category which is worked out
in ES 5.7.2.
4.2.12 Exercises
1. Verify that GS{1 through GS{3 de¯ne a category.
2. Show that for any functor F :
¡! Set, G (F) : G (
; F) ¡!
is a split
0
0
op¯bration.
3. Verify that GC{1 through GC{3 de¯ne a category.
4. Show that for any functor F :
¡! Cat, G(F) : G(
; F) ¡!
is a split
op¯bration.
5. Verify that the de¯nition of the semidirect product in ES 4.2.6 makes T £ M
a monoid.
6. Let F :
¡! Cat be a functor. Show that for each object C of
, the arrows
of the form (u; id ) : (x; C) ¡! (y; C) (for all arrows u : x ¡! y of F(C)) (and
C
their sources and targets) form a subcategory of the op¯bration G(
; F) which
is isomorphic to F(C).
4.3 An equivalence of categories
In this section, we describe how the construction of a functor from an op¯bration
given in Proposition ES 4.1.8 (in one direction) produces an equivalence of cate-
gories (with the Grothendieck construction as pseudo-inverse) between a category
of functors and a suitably de¯ned category of split op¯brations.
4.3.1 Cat-valued functors
For a category
, Func(
; Cat) is the category
whose objects are functors from
to the category of categories, and whose arrows
are natural transformations between them.
If F :
¡! Cat is such a functor and f : C ¡! D is an arrow of
, then
F(C) and F(D) are categories and Ff : F(C) ¡! F(D) is a functor. If also G :
¡! Cat and ® : F ¡! G is a natural transformation, then for each object of C,

4.3 An equivalence of categories
49
®C : F(C) ¡! G(C) is a functor and the following diagram is a commutative
diagram of categories and functors:
®C-
F(C)
G(C)
Ff
Gf
(4.6)
?
?
-
F(D)
G(D)
®D
0
0
4.3.2 The category of split op¯brations of
Let P :
¡!
and P :
0
¡!
be two split op¯brations of the same category
with splittings · and ·
0
respectively. A homomorphism of split op¯brations is a functor ³ :
¡!
for which
HSO{1 The diagram
³
0
-
@
¡
(4.7)
0
@
¡
P
P
@
¡
@R
¡ª
commutes.
HSO{2 For any arrow f : C ¡! D in
and object X of
such that P(X) = C,
0
³(·(f; X)) = · (f; ³(X))
Thus a homomorphism of split ¯brations `takes ¯bers to ¯bers' and `preserves
the splitting'.
4.3.3 De¯nition
Split op¯brations of
and homomorphisms between them
form a category SO(
).
We will show that SO(
) is equivalent to Func(
; Cat). We do this by
de¯ning two functors
F : SO(
) ¡! Func(
;Cat)
and
G : Func(
;Cat) ¡! SO(
)
so that F is an equivalence with pseudo-inverse G as de¯ned in Section 3.4.

50
Fibrations
4.3.4 De¯nition
For a category
, de¯ne the functor
F : SO(
) ¡! Func(
;Cat)
as follows:
FI{1 If P :
¡!
is a split op¯bration with splitting ·, then F(P;·) :
¡! Cat
is the functor F satisfying FF{1 through FF{3 de¯ned in ES 4.1.7.
0
0
FI{2 If ³ : (P; ·) ¡! (P ; · ) is a homomorphism of op¯brations, F³ : F(P; ·)
0
0
¡! F(P ;· ) is the natural transformation whose component at an object C
¡1
of
is the functor ³ restricted to P
(C).
To show that F³ is a natural transformation, it is necessary to show that for
every f : C ¡! D in
the following diagram commutes:
F³C
0
0
-
F(P; ·)(C)
F(P ;· )(C)
0
0
F(P;·)(f)
F(P ; · )(f)
(4.8)
?
?
0
0
-
F(P;·)(D)
F(P ;· )(D)
F³D
0
Let u : X ¡! X be in F(P;·)(C). Note that u is an arrow in the inverse image
¡1
0
P
C, so Pu = id . Moreover, ³u is an arrow for which P (³u) = id .
C
C
e
e
By de¯nition of cleavage, there are unique arrows u such that P(u) = id
and
D
0
b
b
u such that P (u) = id , for which
D
0
±
±
eu
·(f;X) = ·(f; X )
u
and
0
0
bu ± · (f; ³(X)) = ·(f; ³(X )) ± ³u
b
The top route in Diagram (ES 4.8) takes u to u and the bottom route takes it to
e
³u. The following calculation shows that the diagram commutes:
0
0
0
bu ± · (f;³(X))
=
· (f; ³(X )) ± ³(u)
0
=
³(·(f;X )) ± ³(u)
0
=
³(·(f;X ) ± u)
(4.9)
e
=
³(u ± ·(f; X))
e
=
³(u) ± ³(·(f; X))
0
e
=
³(u) ± · (f; ³(X))
b
e
b
so that u = ³(u) by the uniqueness requirement in the de¯nition of u.
4.3.5 The Grothendieck functor
To de¯ne the functor going the other way
we extend the Grothendieck construction.

4.4 Wreath products
51
4.3.6 De¯nition
For a category
, de¯ne the functor
G : Func(
;Cat) ¡! SO(
)
as follows:
GR{1 For F :
¡! Cat, G(F) = G(
; F).
GR{2 For a natural transformation ® : F ¡! G :
¡! Cat,
G®(x; C) = (®Cx; C)
for (x; C) an object of G(
;F) (so that C is an object of
and x is an
object of FC), and
0
G®(u; f) = (®C u;f)
0
0
for (u; f) an arrow of G(
; F) (so that f : C ¡! C in
and u : Ffx ¡! x
0
in FC ).
0
0
Note that in GR{2, ®C u has domain ®C (Ffx), which is Gf(®Cx) because
® is a natural transformation. The veri¯cation that G® is a functor is omitted.
4.3.7 Theorem
The functor F : SO(
) ¡! Func(
;Cat) de¯ned in ES 4.3.4
is an equivalence of categories with pseudo-inverse G.
There is a similar equivalence of categories between split ¯brations and con-
travariant functors. The details are in [Nico, 1983]. Moreover, the nonsplit case for
both ¯brations and op¯brations corresponds in a precise way to `pseudo-functors',
which are like functors except that identities and composites are preserved only
up to natural isomorphisms. See [Gray, 1966] (the terminology has evolved since
that article).
4.3.8 Exercises
1. Verify that G® as de¯ned by GR{2 is a functor.
2. Verify that G as de¯ned by GR{1 and GR{2 is a functor.
4.4 Wreath products
In this section, we introduce the idea of the wreath product of categories (and
of functors), based on an old construction originating in group theory. In the
monoid case, this construction allows a type of series-parallel decomposition of
¯nite state machines (the Krohn{Rhodes Theorem). This section is not needed
later.

52
Fibrations
4.4.1
Let
and
be small categories and G :
¡! Cat a functor. With
op
these data we de¯ne the shape functor S(G;
) :
¡! Cat as follows. If A
is an object of
, then S(G;
)(A) is the category of functors from the category
G(A) to
with natural transformations as arrows.
Thus an object of S(G;
)(A) is a functor P : G(A) ¡!
and an arrow from
0
0
P : G(A) ¡!
to P : G(A) ¡!
is a natural transformation from P to P . It
is useful to think of S(G;
)(A) as the category of diagrams of shape G(A) (or
models of G(A)) in
; the arrows between them are homomorphisms of diagrams,
in other words natural transformations.
Embedding or modeling a certain shape (diagram, space, structure, etc.) into a cer-
tain workspace (category, topological space, etc.) in all possible ways is a tool used
all over mathematics. In particular, what we have called the shape functor is very
reminiscent of the singular simplex functors in algebraic topology.
op
0
We must say what S(G;
) does to arrows of
. If f : A ¡! A is an arrow
0
of
, then S(G;
)(f) : Func(G(A );
) ¡! Func(G(A);
) takes a functor H :
0
±
G(A ) ¡!
to H
Gf : G(A) ¡!
and it takes a natural transformation ® : H
0
0
0
±
±
¡! H : G(A ) ¡!
to the natural transformation ®Gf : H
Gf ¡! H
Gf :
G(A) ¡!
whose component at an object X of A is the component of ® at
Gf(X). This is the usual action of a functor on diagrams in a category.
op
4.4.2
Since S(G;
) :
¡! Cat is a category-valued functor, we can use
the Grothendieck construction to form the split ¯bration of
by S(G;
). This
G
¯bration consists of a category denoted
wr
, called the wreath product
G
of
by
with given action G, and a functor ¦ :
wr
¡!
.
We now unwind what this implies to give an elementary de¯nition of the
wreath product.
4.4.3 De¯nition
Given small categories
and
and a functor G :
¡!
G
Cat, the wreath product
wr
is a category de¯ned as follows:
G
WP{1 The objects of
wr
are pairs (A;P), where A is an object of
and
P : G(A) ¡!
is a functor.
0
0
G
0
WP{2 An arrow (f;¸) : (A;P) ¡! (A ;P ) of
wr
has f : A ¡! A an arrow
0 ±
of
and ¸ : P ¡! P
Gf a natural transformation.
0
0
0
0
00
00
WP{3 If (f;¸) : (A; P) ¡! (A ;P ) and (g; ¹) : (A ; P ) ¡! (A ; P ) are arrows of
G
wr
, as in
Gf
Gg
0
00
-
-
G(A)
G(A )
G(A )
@
¡
0
00
@
¡
P
P
P
@
¡
@R
?¡ª

4.4 Wreath products
53
then
00
00
±
±
±
(g; ¹)
(f; ¸) = (g
f; ¹:Gf
¸) : (A;P) ¡! (A ; P )
0
0
±
To see the meaning of WP{3, observe that ¸ : P ¡! P
Gf and ¹ : P ¡!
00 ±
P
Gg are natural transformations. Then
0
00
00
±
±
±
±
±
¹:Gf : P
Gf ¡! P
Gg
Gf = P
G(g
f)
is the natural transformation whose component at an object x of G(A) is the
component of ¹ at Gf(x) (this was described in Section 4.4). Then
00
±
±
±
¹:Gf
¸ : P ¡! P
G(g
f)
is the usual composite of natural transformations (see 4.2.11); it is the natural
transformation whose component at an object x of G(A) is the composite of the
±
components (¹:Gf(x))
¸x.
It follows from WP{3 that there is a projection functor
G
¦ :
wr
¡!
taking (A; P) to A and (f;¸) to f.
4.4.4 Special cases of the wreath product
If the functor G in de¯ni-
tion ES 4.4.3 is set-valued, then one obtains the discrete wreath product of
by
with action G. When
and
are both monoids, the discrete wreath
product is also a monoid. (The general case need not be a monoid.)
4.4.5 De¯nition
For any small category
, the right regular representa-
tion of
is the functor R
:
¡! Set de¯ned as follows:
RR{1 If C is an object of
, then R (C) is the set of arrows of
with codomain
C.
0
±
RR{2 If f : C ¡! C in
and g 2 R (C), then R (f)(g) = f
g.
For small categories
and
, the standard wreath product
wr
is
R
the wreath product
wr
. This is a generalization of what is called the
standard wreath product for groups and monoids. It is the wreath product used
in [Rhodes and Tilson, 1989]. They also have a two-sided version of the wreath
product.
4.4.6 The action induced by a wreath product
Given small categories
and
and functors G :
¡! Cat and H :
¡! Cat, there is an induced
G
functor G wr H :
wr
¡! Cat de¯ned as follows:
G
WF{1 For an object (A; P) of
wr
, (G wr H)(A; P) is the split op¯bration
±
induced by H
P : G(A) ¡! Cat.

54
Fibrations
G
WF{2 If (h;¸) is an arrow of
wr
with domain (A;P), and (t;x) is an object
of (G wr H)(A; P), so that x is an object of G(A) and t is an object of
H(P(x)), then
(G wr H)(h; ¸)(t; x) = (H¸x(t); Gh(x))
0
0
WF{3 If (u;f) : (t; x) ¡! (t ; x ) is an arrow of (G wr H)(P; A), then
0
(G wr H)(h; ¸)(u; f) = (H(¸x )(u); Gh(f))
WF{1 can be perceived as saying that G wr H is obtained by composing the shapes
given by G (see the discussion in ES 4.4.1) with H. Indeed, G. M. Kelly, who invented
this concept [1974] called what we call the wreath product the `composite' of the
categories. That is in some ways a better name: the word `product' suggests that the
two factors are involved in the product in symmetric ways, which is not the case, as
the next subsection describes.
G
4.4.7
The action G wr H of
wr
just de¯ned is said to be triangular
because it is a precise generalization of the action of a triangular matrix. For
example, the action
"
#
"
#
"
#
a
b
x
ax + by
£
=
0
c
y
cy
can be described this way: the e®ect on the ¯rst coordinate depends on both the
¯rst and second coordinates, but the e®ect on the second coordinate depends only
on the second coordinate.
The dependency of the action on the coordinates given in WF{2 and WF{3
is analogous to the dependency for the matrices in the example just given.
The wreath product can be generalized to many factors, using the following
theorem, proved in [Kelly, 1974], Section 7. This theorem allows one to think of
the wreath product as generalizing triangular matrices bigger than 2 £ 2.
4.4.8 Proposition
Let G :
¡! Cat, H :
¡! Cat and K :
¡! Cat
be functors. Then there is an isomorphism of categories I making this diagram
commute.
I
G
H
G
G wr H
-
wr (
wr
)
(
wr
) wr
@
¡
@
¡
G wr(H wr K)
(G wr H) wr K
@
¡
@
¡
@R
¡ª
Cat
Note that the standard wreath product is not associative.

4.4 Wreath products
55
4.4.9 Applications of the wreath product
It is natural to wish to simulate
complicated state transition systems using systems built up in some way from a
small stock of simpler ones. This requires a precise notion of simulation. This is
de¯ned in various ways in the literature. In some cases one says a functor F :
¡!
is a simulation of
(the word `cover' is often used) if it has certain special
properties. Other authors have the functor going the other way.
The Krohn{Rhodes Theorem for monoids says that every ¯nite monoid action
is simulated by an iterated wreath product of ¯nite simple groups and certain
very small monoids. The original Krohn{Rhodes Theorem was stated for semi-
groups. Discussions are in [Wells, 1976] and [Eilenberg, 1976]; the latter uses a
di®erent de¯nition of cover. Wells [1980] proved a generalization of a weak form of
the Krohn{Rhodes Theorem for ¯nite categories and set-valued functors (which
generalize the concept of action by a monoid, as discussed in Section 3.2). Wells
[1988a, 1988b] describes how to use some of these decomposition techniques for
category-valued functors.
Rhodes and Tilson use the idea of `division' of categories, which is related
to the notion of cover, as the basic idea of an extensive study of varieties of
semigroups and complexity. See See [Rhodes and Tilson, 1989, Rhodes and Weil,
1989].
Nico [1983] de¯nes a category induced by any functor called the `kernel cate-
gory' of the functor and proves a theorem which embeds the domain of the functor
into the standard wreath product of the codomain and the kernel. This gener-
alizes an old theorem of Kaloujnine and Krasner. It follows that every functor
factors as a full and faithful functor which is injective on objects, followed by a
¯bration. Street and Walters [1973] have a related theorem.
In the case of groups, the kernel category of a homomorphism is a category
equivalent, but not isomorphic, to the actual kernel of the homomorphism. In the
case that
and
are monoids, the kernel category (which is not a monoid in
general) is called the derived category of F. Rhodes and Tilson [1989] have a
tighter de¯nition obtained by imposing a congruence on the kernel. A theorem
analogous to Nico's theorem is true for the tighter de¯nition, as well. It is stated
for semigroups and relations, not merely monoids and homomorphisms, so it is
neither more nor less general than Nico's theorem. In the semigroup case, the
`category' is replaced by a `semigroupoid', which is like a category but does not
have to have identity arrows.
4.4.10 Exercises
1. Show that the discrete wreath product of two monoids is a monoid.
2. Show that the wreath product of two groups (monoids in which every element
is invertible) regarded as categories is a category in which every arrow is an
isomorphism.

5
Toposes
A topos is a cartesian closed category with some extra structure which produces
an object of subobjects for each object. This structure makes toposes more like
the category of sets than cartesian closed categories generally are.
Toposes, and certain subcategories of toposes, have proved attractive for the
purpose of modeling computation. A particular reason for this is that in a topos, a
subobject of an object need not have a complement. One of the fundamental facts
of computation is that it may be possible to list the elements of a subset e®ectively,
but not the elements of its complement (see [Lewis and Papadimitriou, 1981],
Theorems 6.1.3 and 6.1.4.). Sets which cannot be listed e®ectively do not exist for
computational purposes, and toposes provide a universe of objects and functions
which has many nice set-like properties but which does not force complements to
exist. We discuss one speci¯c subcategory of a topos, the category of modest sets,
which has been of particular interest in the semantics of programming languages.
Toposes have interested mathematicians for other reasons. They are an ab-
straction of the concept of sheaf, which is important in pure mathematics. They
allow the interpretation of second-order statements in the category in an exten-
sion of the language associated to cartesian closed categories in Chapter 6. This
fact has resulted in toposes being proposed as an alternative to the category
of sets for the foundations of mathematics. Toposes can also be interpreted as
categories of sets with an internal system of truth values more general than the
familiar two-valued system of classical logic; this allows an object in a topos to be
thought of as a variable or time-dependent set, or as a set with various degrees of
membership. In particular, most ways of de¯ning the category of fuzzy sets lead
to a category which can be embedded in a topos.
Sections ES 5.1 and ES 5.2 describe the basic properties of toposes, for the
most part without proof. Section ES 5.3 takes a closer look at an aspect of toposes
which make many of them a better model of computation than, for example, Set.
Sections ES 5.4 and ES 5.5 describe a special case of categories of sheaves
which makes the connection with sets with degrees of membership clear. The
category of graphs is discussed as an example there. Section ES 5.6 describes the
connection with fuzzy sets.
In Section ES 5.7 we describe category objects in a category, a notion that is
needed in Section ES 5.8, which is a brief description of the realizability topos
and modest sets.
56

5.1 De¯nition of topos
57
This chapter depends on Chapters 1 through 6, Chapter 8, and Chapter 9. In
addition, Section ES 5.7 needs ES 2.1.5, 11.1 and 11.2.
Sections 15.1 and 15.2 are needed in all the remaining sections. After that,
the chapter consists of four independent units: Section 15.3, Sections 15.4 and 5,
Section 15.6 and Sections 15.7 and 8.
Basic toposes are [Johnstone, 1977], [Barr and Wells, 1985], [Lambek and
Scott, 1986], [Bell, 1988], [McLarty, 1992], [Mac Lane and Moerdijk, 1992]. None
of these are aimed at applications to computer science. We do not discuss the
language and logic corresponding to a topos in this book. The most accessible
introduction to this is perhaps that of [McLarty, 1992], Chapter 11. Other discus-
sions of the language and the relation with logic are in [Makkai and Reyes, 1977],
[Fourman, 1977], [Fourman and Vickers, 1986], [Boileau and Joyal, 1981]. The
texts [Makkai and Reyes, 1977] and [Freyd and Scedrov, 1990] discuss toposes
and also more general classes of categories that have a rich logical structure. The
use of toposes speci¯cally for semantics is discussed in [Hyland, 1982], [Hyland
and Pitts, 1989], [Vickers, 1992].
5.1 De¯nition of topos
5.1.1 The subobject functor
Recall from 2.8.11 that if C is an object of a
category, a subobject of C is an equivalence class of monomorphisms C )¡! C
0
where f : C )¡! C is equivalent to f : C )¡!C if and only if there are arrows
0
0
1
1
±
(necessarily isomorphisms) g : C ¡! C and h : C ¡! C such that f
g = f
0
1
1
0
1
0
±
and f
h = f .
0
1
Assuming the ambient category
has pullbacks, the `set of subobjects' func-
op
tion is the object function of a functor Sub :
¡! Set: precisely, for an object
C, Sub(C) is the set of subobjects of C. We must de¯ne Sub on arrows.
0
If k : C ¡! C is an arrow and if f : C )¡! C represents a subobject of C,
0
0
then in a pullback
k0
0
-
C
C0
0?
?
0
(5.1)
f
f0
0
?
?
0
-
C
C
k
0
the arrow f is also a monomorphism (see 8.3.4).
0
It is left as an exercise to prove, using the universal mapping property of
pullbacks, that if the monomorphism f : C )¡! C is equivalent to f : C )¡! C,
0
0
1
1
0
0
0
0
0
0
then the pullbacks f : C )¡! C and f : C )¡! C are also equivalent. Thus not
0
0
1
1
only is a pullback of a monomorphism a monomorphism, but also a pullback of
a subobject is a subobject.

58
Toposes
Thus we can de¯ne, for an arrow k as above,
0
Sub(k) : Sub(C) ¡! Sub(C )
to be the function that sends the equivalence class containing f to the equivalence
0
0
class containing the pullback f .
0
To show that this is a functor, we must show that the identity arrow induces
0
00
0
the identity arrow on subobjects (exercise) and that if k : C
¡! C , then the
diagram
Sub(k)
0
-
Sub(C)
Sub(C )
@
@
@
0
0
±
Sub(k )
Sub(k
k ) @
@
@
?
@R
00
Sub(C )
commutes. But the commutativity of this diagram at the subobject represented
by f is equivalent to the outer rectangle of the diagram
0
0k
k0
00
0
0 -
-
-
-
C
C
C0
0
0
00
0
f
f
f0
0
0
?
?
?
00
0
-
-
-
-
C
C
C
0
k
k
being a pullback when the two smaller squares are, which is true by Exercise 10
of Section 8.3.
5.1.2 De¯nition
A topos is a category which
TOP{1 has ¯nite limits;
TOP{2 is cartesian closed;
TOP{3 has a representable subobject functor.
We know that a functor is representable if and only if it has a universal element
(see 4.5.9). A universal element of the subobject functor is an object, usually
called -, and a subobject - µ - such that for any object A and subobject
0
A µ A, there is a unique arrow Â : A ¡! - such that there is a pullback
0
-
-
A
A
0
Â
?
?
-
-
-
-
0

5.1 De¯nition of topos
59
It can be proved that - is the terminal object and the left arrow is the unique
0
arrow from A ([Barr and Wells, 1985], Proposition 4 of Section 2.3).
0
The object - is called the subobject classi¯er and the arrow from - = 1
0
¡! - is usually denoted true. The arrow Â corresponding to a subobject is called
the characteristic arrow of the subobject.
The fact that the subobject functor is represented by - means precisely that
there is a natural isomorphism
Á : Sub(¡) ¡! Hom(¡;-)
which takes a subobject to its characteristic function.
5.1.3 Example
The category of sets is a topos. It was shown in 6.1.9 that sets
are a cartesian closed category. A two-element set, which we call 2, is a subobject
classi¯er. In fact, call the two elements true and false. Given a set S and subset
S µ S, de¯ne the characteristic function Â : S ¡! ftrue;falseg by
0
(
true
if x 2 S0
Â(x) =
false
if x =2 S0
Then the following square (where the top arrow is inclusion) is a pullback:
-
-
S
S
0
Â
?
?
-
1
2
true
Thus 2 is a subobject classi¯er.
5.1.4 Exercises
1. Referring to Diagram (ES 5.1), show that if the monomorphism f : C )¡!C is
0
0
0
0
0
0
equivalent to f : C )¡!C, then for any g : C ¡! C, the pullbacks f : C )¡! C
1
1
0
0
0
0
0
and f : C )¡! C are also equivalent.
1
1
2. Show that the identity arrow C ¡! C induces the identity arrow Sub(C) ¡!
Sub(C).
3. Show that the category of ¯nite sets and all functions between them is a topos.
y
4. (Requires some knowledge of in¯nite cardinals.) Show that the category of
¯nite and countably in¯nite sets and all functions between them has a subobject
classi¯er but is not cartesian closed. (Hint: the set of subsets of a countable set
is not countable.)

60
Toposes
5.2 Properties of toposes
We list here some of the properties of toposes, without proof.
5.2.1
In the ¯rst place, a topos is not only cartesian closed, it is locally carte-
sian closed (see Section 9.4). This is Corollary 1.43, p. 36 of [Johnstone, 1977],
Corollary 7, p. 182 of [Barr and Wells, 1985] or section 17.2 of [McLarty, 1992].
5.2.2 Power objects
In any topos, the object [A ¡! -] has the property that
»
»
Hom(B;[A ¡! -])
Hom(A £ B; -)
Sub(A £ B)
(5.2)
=
=
These isomorphisms are natural when the functors are regarded as functors of
either A or of B. The object [A ¡! -] is often called the power object of A and
denoted
A. It is the topos theoretic version of the powerset of a set. Theorem 1
of Section 5.4 of [Barr and Wells, 1985] implies that a category with ¯nite limits
is a topos if for each object A there is a power object that satis¯es (ES 5.2).
The inverse image and universal image constructions in 9.2.7 for the powerset
of a set can be made on [A ¡! -] for any object A in a topos. The left and
right adjoints of the pullback functors (they exist because any topos is locally
cartesian closed) are related to these images via the diagram in [Johnstone, 1977],
Proposition 5.29; this diagram is called the `doctrinal diagram' and is the basis
for introducing elementary (¯rst order) logic into a topos.
¡!
5.2.3 E®ective equivalence relations
Let d; e : E
A be two arrows in a
¡!
category. For any object B we have a single function
hHom(B;d);Hom(B;e)i : Hom(B; E) ¡! Hom(B;A) £ Hom(B; A)
±
±
which sends f to the pair (d
f; e
f). If this function is, for each object B, an
isomorphism of Hom(B;E) with an equivalence relation on the set Hom(B; A),
then we say that E is an equivalence relation on the object A. This means
that the image of hHom(B;d); Hom(B;e)i is actually an equivalence relation on
Hom(B; A).
This can be thought of as embodying two separate conditions. First o®, the
function hHom(B;d);Hom(B;e)i must be an injection, because we are supposing
that it maps Hom(B;E) isomorphically to a subset of Hom(B; A) £ Hom(B;A).
Secondly, that subset must satisfy the usual re°exivity, symmetry and transitivity
conditions of equivalence relations.
5.2.4 Kernel pairs
Here is one case in which this condition is automatic. If
g : A ¡! C is an arrow, the pullback of the square

5.2 Properties of toposes
61
d -
E
A
g
e
?
?
-
A
C
g
is called a kernel pair of g. Notation: we will write that
d
g
¡¡!
E
A ¡¡! C
¡¡!
e
is a kernel pair. For an object B of
, the de¯nition of this limit is that there is a
one to one correspondence between arrows B ¡! E and pairs of arrows (h;k) from
±
±
B to A such that g
h = g
k and that the correspondence is got by composing
an arrow from B to E with d and e, resp. To put it in other words, Hom(B; E)
is isomorphic to
±
±
f(h;k) 2 Hom(B;A) £ Hom(B; A) j g
h = g
kg
which is an equivalence relation.
¡!
5.2.5
Suppose that E
A describes an equivalence relation. We say that the
¡!
equivalence relation is e®ective if it is a kernel pair of some arrow from A. We
say that a category has e®ective equivalence relations if every equivalence
relation is e®ective. We give the following without proof. The interested reader
may ¯nd the proof in [Barr and Wells, 1985] Theorem 7 of Section 2.3, [Johnstone,
1977], Proposition 1.23, p. 27, or [McLarty, 1992], Section 16.7.
5.2.6 Theorem
In a topos, every equivalence relation is e®ective.
5.2.7 Example
Equivalence relations in the categories Set and Mon are ef-
fective. An equivalence relation in Set is simply an equivalence relation, and the
class map to the quotient set is a function that has the equivalence relation as
kernel pair. An equivalence relation on a monoid M in Mon is a congruence
relation on M (see Exercise 6 of Section 3.5); it is e®ective because a monoid
multiplication can be de¯ned on the quotient set of the congruence relation that
makes the quotient map a homomorphism (Exercise ES 3).
There are many categories which lack e®ective equivalence relations. One is the
category of partially ordered sets and monotone maps. Here is a simple example.
Let C be a two-element chain x < y. Consider the subset E of C £ C consisting
of all four pairs (x; x), (x;y), (y; x) and (y; y). The only ordering is that (x;x) ·
(y; y). Then E is an equivalence relation, but is not the kernel pair of any arrow
out of C. The least kernel pair that includes E has the same elements as E, but
has the additional orderings (x;x) · (x;y) · (y;y) and (x; x) · (y;x) · (y; y).
Other important properties of toposes are contained in the following.

62
Toposes
5.2.8 Theorem
Let
be a topos.
(a)
has ¯nite colimits.
(b)
has ¯nite disjoint and universal sums.
(c) Every epi in
is regular, and
is a regular category.
An early proof of the fact that a topos has ¯nite colimits ([Mikkelson, 1976] mimicked
the construction in sets. For example, the coequalizer of two arrows was constructed
as a set of subsets, which can be identi¯ed as the set of equivalence classes mod the
equivalence relation generated by the two arrows. However, the argument is di±cult.
The modern proof (due to Par¶e) is much easier, but it involves some legerdemain
with triples and it is hard to see what it is actually doing. See [Barr and Wells, 1985],
Corollary 2 of 5.1 for the latter proof. The rest is found in 5.5 of the same source.
5.2.9 The initial topos
There is an FL sketch whose models are toposes.
(See [Barr and Wells, 1985], Section 4.4. In that book, FL sketches are called LE
sketches.) It follows that there is an initial model of the topos axioms. This topos
lacks a natural numbers object. It might be an interesting model for a rigidly
¯nitistic model of computation, but would not allow the modeling of such things
as recursion.
The phrase `initial topos' is usually reserved for the initial model of the axioms
for toposes with a natural numbers object (Section 5.5). This category provides
an interesting model for computation. The arrows from N to N in that category
are, not surprisingly, the total recursive functions. In fact, all partial recursive
functions are modeled in there as well, but as partial arrows, which we now
describe.
5.2.10 Partial arrows
In 2.1.13 we discussed partial functions between sets.
This concept can be extended to any category. Let A and B be objects. A partial
arrow A to B consists of a subobject A µ A and an arrow f : A ¡! B. This
0
0
de¯nes the partial arrow f in terms of a particular representative A ¡! A of the
0
0
subobject, but given any other representative A ¡! A, there is a unique arrow
0
0
from A to A commuting with the inclusions which determines an arrow from
0
0
0
A to B by composition with f. The subobject determined by A is called the
0
0
domain of the partial arrow. If g : A ¡! B is another partial arrow on A we
1
say the f · g if A µ A
and the restriction of g to A
is f. If we let i : A
0
1
0
0
¡! A denote the inclusion arrow, then the second condition means simply that
1
±
g
i = f. We will say that f and g are the same partial arrow if both f · g and
g · f. This means that the domains of f and g are the same subobject of A and
that f and g are equal on that domain.
We say that partial arrows to B are representable if there is an object
e
e
B and an embedding B )¡! B such that there is a one to one correspondence
e
between arrows A ¡! B and partial arrows A to B, the correspondence given by
pulling back:

5.2 Properties of toposes
63
-
A
A
0
?
?
-
e
B
B
In a topos, the arrow true: 1 ¡! - represents partial functions to 1. The reason
is that since each object has a unique arrow to 1, a partial arrow from A to 1 is
equivalent to a subobject of A.
5.2.11 Theorem
In a topos, partial arrows into any object are representable.
See [Johnstone, 1977], Section 1.26 or [McLarty, 1992], Section 17.1 for the
proof.
5.2.12 Exercises
1. Verify the isomorphisms of (ES 5.2) for Set.
2. Let S be a set and E be an equivalence relation on S. Then there are two arrows
E to S, being the inclusion of E into S £ S, followed by the two projections on
S. Show that E, together with these two arrows, is the kernel pair of the function
that takes each element of S to the equivalence class containing it.
¡!
3. a. Let d;e : E
M be two monoid homomorphisms. Show that they form an
¡!
equivalence relation in Mon if and only if the arrow
hd; ei
E ¡¡¡¡¡! M £ M
is a monomorphism and the image of hd; ei is a congruence on M (see Exercise 6
of Section 3.5 with d; e the projections).
b. Show that equivalence relations in Mon are e®ective.
4. Show that in any category with kernel pairs, if f : C ¡! D is a coequalizer,
then it is the coequalizer of its kernel pair.
5. Give an example in Set of a function with a kernel pair which is not the
coequalizer of its kernel pair.
e
6. Show that in the category of sets, S can be taken to be S [ f¤g, where ¤ is an
element not in S.
e
7. Show that in a topos, the subobject classi¯er is 1, the object that represents
partial arrows into 1.

64
Toposes
5.3 Is a two-element poset complete?
This discussion requires familiarity with the concept of recursive set (there is an
algorithm that always halts that tells whether an element is in the set or not) and
recursively enumerable set (there is an algorithm that generates all the elements
of the set and no others).
We consider a 2 element chain we denote by 2. The word `complete' in the
question in the heading means that it has sups of all subsets. The question seems
absurd at ¯rst, but it improves with age. In fact, we will show that both in a
topos and in realistic models of computation, the answer is `no'. Moreover the
answer is no in both cases for the same reason.
The claim we want to make, and for which this discussion is evidence, is
that topos semantics is an appropriate model for computation, or at least a more
appropriate one than set theory. This will not mean that topos theory will tell you
how to compute something that you could not compute without it. What happens
is that in many toposes certain computationally meaningless constructions cannot
be made at all, although they are all possible in Set.
5.3.1 Computation models
Of course, in a most naive sense, 2 is certainly
complete as a poset, but we want to look at this in a more sophisticated way.
What we really want to be true if we say that a poset P is complete is that for
any other object A, the poset [A ¡! P], with the pointwise order, is complete.
In the case of 2, this means that [A ¡! 2] is complete. To see why we want this
to be true, recall that an element of a set is essentially the same thing as a
function from a one-element set to that set. However, in categories thought of
as workspaces, it is more useful to think of any arrow with codomain S as an
element of S { a variable element of S. (A variable elements whose domain is a
terminal object is then a constant element or global element (2.7.19)). Categories
rich enough to be workspaces for a type of mathematics typically come with an
internal language; statements in that internal language can often be perceived
as statements about elements, but their truth is dependent on `elements' being
interpreted as variable elements.
In the case of ordinary set theory, it is still true that 2 is complete in this
internal sense. For computational semantics, the situation is di®erent. Consider
the case A = N, although any in¯nite set would do as well. A function N ¡! 2 is
determined by and determines a subset of N. However, a computable function N
¡! 2 is determined by and determines a recursive subset of N. And it is well known
that the set of recursive subsets of N is not complete. It is not even countably
complete; in fact, the recursively enumerable subsets are characterized as the
countable unions of recursive subsets. Of course, arbitrary unions of recursive
subsets will be even worse.

5.3 Is a two-element poset complete?
65
5.3.2 Topos models
The situation in an arbitrary topos is similar. A topos
has an object - with the property that for any object A, Hom(A; -) is the set
of subobjects of A. A topos also always has an object 2 = 1 + 1, and an arrow
A ¡! 2 does not represent an arbitrary subobject, but rather a complemented
subobject (see 8.6.2). Such an arrow A ¡! 2 gives a decomposition of A as a sum
A + A
where A
and A
are the pullbacks shown below, where true; false : 1
0
1
0
1
¡! 2 are the two injections:
-
-
A
A
A
A
0
1
?
?
?
?
-
-
1
2
1
2
true
false
The fact that a topos has universal sums implies that from 2 = 1 + 1 we can
conclude that A = A + A . On the other hand, if A = A + A , there is a unique
0
1
0
1
±
±
arrow A ¡! 2 whose restriction to A is false
hi and to A is true
hi. Thus 2
0
1
is internally complete in a topos if and only if the supremum of complemented
sets are complemented. It is not hard to show that this is not true in general.
In fact, there is a topos in which the arrows from N to 2 are just the total
recursive two-valued functions (and in fact, the arrows from N to itself are also
the total recursive functions). In that topos a complemented subset of N is exactly
a recursive subset (one which, with its complement, has a recursive characteristic
function) and the fact that a union of recursive subsets is not recursive ¯nishes
the argument.
In 6.6.4 we constructed a semantics for an If loop by constructing a supre-
mum in [A ¡! D ], where D
is a °at CPO (of which 2 is an example). However,
?
?
the last paragraph shows that in general this semantics does not make compu-
tational sense. The reason is that, although you can write down the sup as a
formal thing, it will not be guaranteed to give a terminating program. The sup of
partial functions exists, but the domain of such a partial function is not generally
computable.
In a topos model of computational semantics, in which all arrows N ¡! N are
given by recursive functions, a subobject of N is determined by an arrow into -.
The maps into - cannot usually be computed. The one special case in which they
can is that of an arrow that factors through the subobject htrue; falsei : 2 ¡! -.
This corresponds to the traditional distinction between recursively enumerable
and recursive subsets. In classical set theory, all subsets are classi¯ed by arrows
into 2, but here only recursive subsets are.

66
Toposes
5.4 Presheaves
op
5.4.1 De¯nition
Let
be a category. A functor E :
¡! Set is called a
presheaf on
. Thus a presheaf on
is a contravariant functor. The presheaves
on
with natural transformations as arrows forms a category denoted Psh(
).
We considered presheaves as actions in Section 3.2. They occur in other guises
in the categorical and computer science literature, too. For example, a functor
F : A ¡! Set, where A is a set treated as a discrete category, is a `bag' of elements
of A. If a 2 A, the set F(a) denotes the multiplicity to which a occurs in A. See
[Taylor, 1989] for an application in computing science.
5.4.2 Proposition
The category of presheaves on a category
form a topos.
The proof may be found in [Barr and Wells, 1985] Section 2.1, Theorem 4.
That proof uses a di®erent, but equivalent, de¯nition of topos.
¡!
5.4.3 Example
Consider the category we will denote by 0
1. It has two
¡!
objects and four arrows, two being the identities. A contravariant set-valued func-
tor on this category is a pair of objects G and G and a pair of arrows we will
0
1
call source;target : G ¡! G . The two identities are sent to identities. Thus the
1
0
category of presheaves on this category is the category of graphs, which is thereby
a topos. This category is the theory of the sketch for graphs given in 4.6.7.
We described the exponential object for graphs in 6.1.12. It is instructive to
see what the subobject classi¯er is. We have to ¯nd a graph - and an arrow
true : 1 ¡! - such that for any graph
and subgraph
µ
, there is a unique
0
graph homomorphism Â :
¡! - such that the diagram
-
-0
Â
?
?
-
1
-
true
commutes.
We de¯ne the graph - as follows. It has ¯ve arrows we will call `all', `source',
`target', `both' and `neither'. The reason for these names should become clear
shortly. It has two nodes we will call `in' and `out'. The arrows `all' and `both'
go from `in' to itself, `neither' goes from `out' to itself. The arrow `source' goes
from `in' to `out' and `target' from `out' to `in'. The terminal graph, which has
one arrow and one node, is embedded by the function true that takes the arrow
to `all' and the node to `in'.
Now given a graph
and a subgraph
we de¯ne a function Â :
¡! -
0
as follows. For a node n of
, Â(n) is `in' or `out', according to whether n is in
or not. For an arrow a, we let Â(a) be `all' if a 2
(whence its source and
0
0

5.5 Sheaves
67
target are as well). If not, there are several possibilities. If the source but not the
target of a belongs to
, then Â(a) =`source'. Similarly, if the target but not the
0
source is in
, it goes to `target'. If both the source and target are in it, then
0
Â(a) =`both' and if neither is, then it goes to `neither'.
5.4.4 Exercises
1. Show that the graphs No and Ar discussed in 6.1.12 are actually the contravari-
¡!
ant set-valued functors on 0
1 represented by the objects 0 and 1, respectively.
¡!
2. Show that the object - in the category of graphs can be described as follows.
The nodes are the subgraphs of No and the arrows are the subgraphs of Ar and
the source and target are induced by s and t (de¯ned in 6.1.12), respectively.
3. Let
be a category, and let M and N be two objects of Psh(
). Use the
Yoneda Lemma and the adjunction de¯ning cartesian closed categories to show
that for any object X of
, [M ¡! N](X) must be the set of natural transfor-
mations from Hom(¡;X) £ M to N, up to isomorphism. Note that this does not
prove that Psh(
) is cartesian closed. That is true, but requires ideas not given
here (see [Mac Lane and Moerdijk, 1992], page 46).
4. Let
be a category and X an object of
. Let - be the subobject classi¯er
of Psh(
). Show that -(X) is, up to isomorphism, the set of subfunctors (see
Exercise 3 of Section 4.3) of Hom(¡;X).
5.5 Sheaves
The general de¯nition of sheaves requires a structure on the category called
a Grothendieck topology. The most accessible and detailed discussion of
Grothendieck topologies is that of [Mac Lane and Moerdijk, 1992]. Here we will
discuss the special case of sheaves in which the category is a partial order.
5.5.1
Let P be a partially ordered set. From the preceding section, a presheaf
E on P assigns to each element x 2 P a set E(x) and whenever x · y assigns a
function we will denote E(x;y) : E(y) ¡! E(x) (note the order; x precedes y, but
the arrow is from E(y) to E(x)). This is subject to two conditions. First, that
E(x; x) be the identity function on E(x) and second that when x · y · z, that
±
E(x;y)
E(y;z) = E(x;z). The arrows E(x;y) are called restriction functions.
5.5.2 Heyting algebras
We make the following supposition about P.
HA{1 There is a top element, denoted 1, in P.
HA{2 Each pair of elements x; y 2 P has an in¯mum, denoted x ^ y.
W
HA{3 Every subset fx g of elements of P has a supremum, denoted
x .
i
i

68
Toposes
W
W
HA{4 For every element x 2 P and every subset fx g µ P, x^(
x ) =
(x^x ).
i
i
i
A poset that satis¯es these conditions is called a complete Heyting algebra.
5.5.3
If fx g is a subset with supremum x, and E is a presheaf, there is given
i
a restriction function e : E(x) ¡! E(x ) for each i. The universal property of
i
i
Q
±
product gives a unique function e : E(x) ¡!
E(x ) such that p
e = e . In
i
i
i
i
addition, for each pair of indices i and j, there are functions c
: E(x ) ¡! E(x ^
ij
i
i
x ) and d
: E(x ) ¡! E(x ^ x ) induced by the relations x ¸ x ^ x and x ¸
j
ij
j
i
j
i
i
j
j
Q
Q
x ^ x . This gives two functions c; d :
E(x ) ¡!
E(x ^ x ) such that
i
j
i
i
j
i
ij
Q
Q
c
-
E(x )
E(x ^ x )
i
i
j
i
ij
p
p
ij
i
?
?
-
E(x )
E(x ^ x )
i
i
j
cij
and
Q
Q
d
-
E(x )
E(x ^ x )
i
i
j
i
ij
p
p
ij
i
?
?
-
E(x )
E(x ^ x )
i
i
j
dij
commute.
5.5.4 De¯nition
A presheaf is called a sheaf if it satis¯es the following addi-
tional condition:
_
x =
xi
implies
Y
Y
c
e
¡¡!
E(x) ¡!
E(x )
E(x ^ x )
¡¡!
i
i
j
d
i
ij
is an equalizer.
5.5.5 Theorem
The category of sheaves on a Heyting algebra is a topos.
As a matter of fact, the category of sheaves for any Grothendieck topology
is a topos (see any of the texts [Johnstone, 1977], [Barr and Wells, 1985], [Mac
Lane and Moerdijk, 1992], [McLarty, 1992]).

5.5 Sheaves
69
5.5.6 Constant sheaves
A presheaf E is called constant if for all x 2 P,
E(x) is always the same set and for all x · y, the function E(y; x) is the identity
function on that set.
The constant presheaf at a one-element set is always a sheaf. This is because
the sheaf condition comes down to a diagram
¡!
1 ¡! 1
1
¡!
which is certainly an equalizer. No constant presheaf whose value is a set with
other than one element can be a sheaf. In fact, the 0 (bottom) element of P is
the supremum of the empty set and the product of the empty set of sets is a
one-element set (see 5.3.6). Hence the sheaf condition on a presheaf E is that
Y
Y
¡!
E(0) ¡!
¡!
;
;
which is
¡!
E(0) ¡! 1
1
¡!
and this is an equalizer if and only if E(0) = 1.
5.5.7
A presheaf is said to be nearly constant if whenever 0 < x · y in P,
the restriction E(y) ¡! E(x) is an isomorphism. It is interesting to inquire when
a nearly constant presheaf is a sheaf. It turns out that every nearly constant
presheaf over P is a sheaf over P if and only if the meet of two nonzero elements
of P is nonzero.
To see this, suppose E is a nearly constant presheaf whose value at any x 6
= 0
W
is S and that x =
x . In the diagram
i
Y
Y
¡!
E(x) ¡!
E(x )
E(x ^ x )
¡!
i
i
j
»
every term in which x = 0 contributes nothing to the product since 1 £ Y
Y .
=
i
An element of the product is a string fs g such that s 2 S. The condition of
i
i
being an element of the equalizer is the condition that the image of s under the
i
induced function E(x ) ¡! E(x ^ x ) is the same as the image of s under E(x )
i
i
j
j
j
¡! E(x ^ x ). But in a nearly constant sheaf, all these sets are the same and all
i
j
the functions are the identity, so this condition is simply that s = s . But this
i
j
means that an element of the equalizer must be the same in every coordinate,
hence that diagram is an equalizer.
5.5.8 Interpretation of sheaves
Let E be a sheaf on P. The reader will want
to know how E is to be interpreted. Start by thinking of P as an algebra of truth
values. Whereas propositions (assertions) in ordinary logic are either true or false
(so that ordinary logic is often called 2-valued), in P-valued logic, the truth of an
assertion is an element of P. In the next section, we will use this idea to discuss

70
Toposes
time sheaves in which propositions can be true at some times and not at others.
If p is some proposition, let us write [[p]] to denote the element of P that is the
truth value.
A sheaf E is a set in this logic. For x 2 P, the (ordinary) set E(x) could,
as a ¯rst approximation, be thought of as the set of all entities a for which
[[a 2 E]] is at least x. If y < x, then [[a 2 E]] ¸ x implies that [[a 2 E]] ¸ y so that
E(x) µ E(y). This is only a ¯rst approximation and what we have described is
actually a P-valued fuzzy set (see ES 5.6). The reason is that equality is also a
predicate and it may happen, for example, that [[a = b]] could lie between x and
y so that the entities a and b are not discernably equal at level x, but are equal at
level y. The result is that rather than an inclusion, we have a restriction function
E(x) ¡! E(y) for y · x.
5.5.9 Time sheaves, I
Here is a good example of a topos in which one can see
that the restriction arrows should not be expected to be injective. Consider the
partially ordered set whose elements are intervals on the real line with inclusion
as ordering. It is helpful to think of these as time intervals.
Now consider any de¯nition of a naive set. Some possible de¯nitions will be
time invariant, such as the set of mathematical statements about, say, natural
numbers, that are true. Others of these `sets' change with time; one example might
be the set of all books that are currently in print; another the set of statements
currently known to be true about the natural numbers. These may conveniently
be thought of as the presheaves whose value on some time interval is the set of
books that were in print over the entire interval and the set of statements about
natural numbers known to be true during that entire interval. The restriction
to a subinterval is simply the inclusion of the set of books in print over the
whole interval to that (larger) set of those in print over that subinterval or the
restriction of the knowledge from the interval to the subinterval. In this example,
the restrictions are injective.
Instead of books in print, we could take the example of businesses in operation.
Because of the possibility of merger, divestment and the like, two businesses which
are actually distinct over a large interval might coincide over a smaller subinterval.
Thus for this example of a \set", the restriction function is not injective in general.
Another situation in which the restriction functions are not necessarily injec-
tive arises from the set of variables in a block-structured programming language.
The presheaf is this: the set for a certain time interval during the running of
the program is the quotient of the set of variables which exist over the whole
time interval, modulo the equivalence relation that identi¯es two variables in an
interval if they should happen to have the same value over the whole interval.
Two variables may not be equivalent over a large interval, whereas they may be
equivalent over a smaller one; in that case the restriction function would not be
injective.

5.5 Sheaves
71
In general, any property describes the set of all entities that have that prop-
erty over the entire interval. The restriction to a subinterval arises out of the
observation that any entity that possesses a property over an interval possesses
it over any subinterval.
The sheaf condition in this case reduces to this: if the interval I is a union of
subintervals I (where k ranges over an index set which need not be countable)
k
and an entity possesses that property over every one of the subintervals I , then
k
it does over the whole interval. This condition puts a de¯nite restriction on the
kinds of properties that can be used. For example, the property of being grue,
that is blue over the ¯rst half of the interval and green on the second half, is not
allowed. The properties that are allowed are what might be called local, that is
true when they are true in each su±ciently small interval surrounding the point
in time. This statement is essentially a tautology, but it does give an idea of what
the sheaf condition means.
5.5.10 Time sheaves, II
Here is another topos, rather di®erent from the one
above, that might also be considered to be time sheaves. Unlike the one above
which is symmetric to forward and reverse time, this one de¯nitely depends on
which way time is °owing. This is not to say that one is better or worse, but they
are di®erent and have di®erent purposes. In this one, the elements of the Heyting
algebra are the times themselves. In other words, we are looking at time indexed
sets, as opposed to sets indexed by time intervals.
We order this set by the reverse of the usual order. So a presheaf in this model
is a family fX(t)g of sets, t a real number, together with functions f(s; t) : X(t)
±
¡! X(s) for t · s, subject to the condition that f(t;t) is the identity and f(r;s)
f(s; t) = f(r; t) for t · s · r. The sheaf condition of De¯nition ES 5.5.4 is a bit
technical, but can easily be understood in the special case of a presheaf all of
whose transition arrows f(s;t) are inclusions. In that case, the condition is that
V
T
when t =
t (so that t is the greatest lower bound of the t ), then X(t) =
X(t ).
i
i
i
An example, which might be thought typical, of such a sheaf might be de-
scribed as the `sheaf of states of knowledge'. At each time t we let X(t) denote
the set of all things known to the human race. On the hypothesis (which might
be disputed) that knowledge is not lost, we have a function X(t) ¡! X(s) for
t · s. In common parlance, we might consider this function to be an inclusion, or
at least injective, but it is possible to modify it in various ways that will render
it not so. We might introduce an equivalence relation on knowledge, so that two
bits of knowledge might be considered the same. In that case, if at some future
time we discover two bits of knowledge the same, then bits not equal at one time
become equal at a later time and the transition arrow is not injective.
For example, consider our knowledge of the set of complex numbers. There
was a time in our history when all the numbers e, i, ¼ and ¡1 were all known,
i¼
i¼
but it was not known that e
= ¡1. In that case, the number e
and ¡1 were

72
Toposes
known separately, but not the fact that they were equal. See [Barr, McLarty and
Wells, 1985]. The sheaf condition is this: if ft g is a set of times and t is their
i
in¯mum, then anything known at time t for every i is known at time t.
i
5.5.11 Exercise
1. Let
be a complete Heyting algebra. De¯ne the binary operation ): H £H
¡! H by requiring that a ) b is the join of all elements c for which a ^ c · b.
a. Prove that a ^ c · b if and only if c · a ) b.
b. Prove that when
is regarded as a category in the usual way, it is cartesian
closed with ) as internal hom.
5.6 Fuzzy sets
Fuzzy set theory is a more-or-less categorical idea that some claim has application
to computer modeling. It appears to be closely related to topos theory. In fact, it
appears to us that the interesting core of the subject is already implicit in topos
theory. We will not go deeply into the subject, but only give a few de¯nitions
and point out the connections. More details can be found in [Barr, 1986a], [Pitts,
1982].
5.6.1
At this point, it would be appropriate to give some de¯nitions. One of
the problems with fuzzy sets is that the meaning of the term has been left vague
(one might say fuzzy). Rather than attempt to give all possible de¯nitions, we
content ourselves with a de¯nition that is common and for which the connection
with topos theory is as simple as possible.
5.6.2 De¯nition
Let P be a complete Heyting algebra. A P-valued set is a
pair (S;¾) consisting of a set S and a function ¾ : S ¡! P. A category of fuzzy
sets is the category of P-valued sets (in other words, the slice category Set =P)
for a ¯xed complete Heyting algebra P.
In practice, fuzzy sets are de¯ned with P being the closed interval of real
numbers from 0 to 1, which is a complete Heyting algebra with the usual ordering.
Think of ¾(s) as being the degree of membership of s in the fuzzy set. If ¾(s) = 1,
then s is fully in the fuzzy set, while if ¾(s) = 0, then s is not in the fuzzy set at
all.
Actually that last statement is not quite true; we will return to this point later;
pretend for the moment that it is.
5.6.3
Let (S; ¾) and (T; ¿) be fuzzy sets. An arrow f : (S; ¾) ¡! (T; ¿) is an
±
arrow f : S ¡! T such that ¾ · ¿
f. Thus the degree of membership of s in
(S;¾) cannot exceed that of f(s) in (T; ¿). With this de¯nition and the obvious
identity arrows, the fuzzy sets based on P form a category Fuzz(P).

5.6 Fuzzy sets
73
op
The hypothesis actually made on P was that both P and the opposite order P
op
were Heyting algebras ([Goguen, 1974]). The hypothesis on P
plays no role in the
theory and so we have omitted it.
5.6.4
Once we have de¯ned the category of fuzzy sets, the de¯nition of subset
of a fuzzy set emerges. For f : (S;¾) )¡!(T; ¿) to be monic it is necessary that f
be injective. In particular, we can think of a subset of (T;¿) as being a fuzzy set
(T ; ¿ ) where T µ T and ¿jT · ¿ .
0
0
0
0
0
5.6.5 More ado about nothing
Consider the following two fuzzy subsets
of (S; ¾). The ¯rst is the set (;; hi) and the second is the set (S; 0) where hi is
the unique function of ; to P and 0 stands for the function that is constantly
zero. One is the empty set and the other is the set in which every element is not
there. There is seemingly no di®erence between these two sets as neither actually
contains any elements. In fact, in fuzzy set theory, these two sets (and sets in
between) are not considered to be equal. This results in the class of fuzzy set
theories being curiously restricted (see ES 5.6.10).
5.6.6 Fuzzy sets and sheaves
The reader may suspect (from the title of this
section, if nothing else) that there is a connection between fuzzy sets and toposes.
Both are generalizations of set theory to introduce lattices more general than the
two-element lattice as truth values.
One of the two di®erences has just been mentioned; the di®erent treatment of
the null set. Actually, this di®erence is relatively minor. The second one is not.
Suppose (S; ¾) is a fuzzy set. We can de¯ne a presheaf E by letting
E(x) = fs 2 S j ¾(s) ¸ xg
as suggested in our informal discussion. Clearly, if y · x, then E(x) µ E(y) and
using these inclusions, we get a presheaf on P. It is almost never a sheaf, however.
The essential reason for this is that E(0) = S, while we have seen in ES 5.5.6 that
E(0) = 1 when E is a sheaf.
5.6.7
It turns out there is a very simple way to make E into a sheaf, but not on
+
P. Let P
denote the poset constructed from P by adding a new bottom element.
Let us call the new bottom element ? to distinguish it from the old one we called
+
0. Now given a P indexed fuzzy set, de¯ne a presheaf on P
by letting E(x) be
de¯ned as above for x 2 P and E(?) = 1.
5.6.8 Proposition
The presheaf E just de¯ned is a sheaf. It is a subsheaf of
the near constant sheaf C de¯ned by C(x) = S for x 6
= ? and C(?) = 1.
+
Proof. We ¯rst observe that P
obviously has the property that the meet of two
nonzero elements is nonzero because P has ¯nite meets. Thus C is a sheaf. A
diagram chase shows that if C is a sheaf and E a subpresheaf, then E is a sheaf
W
if and only if for each x =
x , the diagram
i

74
Toposes
Q
-
E(x)
E(x )
i
?
?
Q
-
C(x)
C(x )
i
is a pullback. The vertical arrows are just the inclusions. As we saw in ES 5.5.7,
the lower horizontal function is just the inclusion of C(x) into the set of constant
strings. It follows that this is essentially what the upper horizontal arrow is. Now
Q
in order that a string of elements fs g 2
E(x ) be constant, it is necessary and
i
i
su±cient that all the s be the same element s and that s 2 E(x ) for all i which
i
i
means that ¾(s) ¸ x for all i. But this is just what is required to have ¾(s) ¸ x
i
and s 2 E(x).
Continuing in this vein, it is possible to show the following.
5.6.9 Theorem
For any Heyting algebra P, the category of fuzzy sets based on
+
P is equivalent to the full subcategory of the category of P
sheaves consisting of
the sheaves that are subsheaves of the near constant sheaves.
+
5.6.10
The introduction of P
instead of P is directly traceable to the failure
the two kinds of empty sets as mentioned in ES 5.6.5 to be the same. The fact
that the sheaves are subsheaves of the near constant sheaves is really a re°ection
of the fact that in fuzzy set theory only one of the two predicates of set theory is
+
made to take values in P (or P ).
This shows up in the fact that in fuzzy set theory there is no fuzzy set of fuzzy
subsets of a fuzzy set. In other words, the
construction is missing. Here's why.
Suppose S is a set, considered as a fuzzy set with ¾(s) = 1 for all s 2 S. (Such
a fuzzy set is called a crisp set.) Let x < y be two elements of P and consider
the subsets S = (S; ¾ ) and S = (S; ¾ ), with ¾
and ¾
being the functions
x
x
y
y
x
y
which are constant at x and y respectively. Then of course, S 6
= S
(actually
x
y
S is a proper subset of S ), but it is clear that when looking only at degrees of
x
y
membership at level x or below, the two subsets are equal. In fact, in the topos,
the degree to which S
equals S is just x. But this predicate cannot be stated
x
y
in the language of fuzzy sets and the result is that there are not and cannot be
power objects (unless P has just one element).
The point is that there are two predicates in set theory, membership and
equality. In topos theory, both may be fuzzy, but in fuzzy set theory, only mem-
bership is allowed to be. But
converts membership into equality as explained
in the preceding paragraph and so cannot be de¯ned in fuzzy set theory. Thus
fuzzy set theory, as currently implemented, lacks a certain conceptual consistency.
One can try to re¯ne the de¯nition of fuzzy set so as to allow fuzzy equality. The
obvious way to proceed is to de¯ne as objects triplets (S; ¾;´), with (S; ¾) as above

5.7 External functors
75
and ´ : S £ S ¡! P, interpreted as fuzzy equality. These must be subject to the
condition that the degree to which two elements are equal cannot exceed the degree
to which either one is de¯ned. The resultant category is equivalent to the topos of
+
sheaves on P .
5.7 External functors
5.7.1 Category objects in a topos
One of the tools proposed for program-
ming language semantics is the category of modest sets, which we will describe
in the next section. The category of modest sets is not a category in the sense we
have been using the word up until now: it is a category object in another category,
called the e®ective topos.
Recall the sketch for categories that was described in detail in ES2.1.5. A
model of this sketch in the category of sets is, of course, a category. A model in
a category
is called a category object in
. A homomorphism between such
category objects is called an internal functor between those category objects.
Referring to the sketch, we see that a category object consists of four objects
»
»
C ; C ; C and C such that C
C £
C and C
C £
C £
C . There are
=
=
0
1
2
3
2
1
C
1
3
1
C
1
C
1
0
0
0
arrows in
corresponding to unit, source, target and composition. The crucial
commutative diagrams are:
±
±
hid;u
si
hu
t;idi
hp ; ci
1
-
¾
-
C
C
C
C
C
1
2
1
3
2
@
¡
@
¡
c
c
hc; p i
id
id
3
@
¡
@
¡
@R
?¡ª
?
?
-
C
C
C
1
2
1
c
We may denote such a category object by C = hC ; C ; u ; s ; t ; c i since
0
1
C
C
C
C
the remaining data are determined by these. As a matter of convenience, we
usually omit the indexes unless they are necessary for comprehension. If D =
hD ; D ; u; s;t; ci is another category object, then an internal functor f : D ¡!
0
1
C is given by homomorphisms f : D ¡! C
and f : D ¡! C
such that the
0
0
0
1
1
1
following diagrams commute, where f : D ¡! C is the unique arrow for which
2
2
2
±
±
p
f = f
p ;
i = 1; 2.
i
2
1
i
f
f
1
1
-
-
D
C
D
C
1
1
1
1
s
s
t
t
?
?
?
?
-
-
D
C
D
C
0
0
0
0
f
f
0
0

76
Toposes
(5.3)
f
f
2
0
-
-
D
C
D
C
2
2
0
0
c
c
u
u
?
?
?
?
-
-
D
C
D
C
1
1
1
1
f
f
1
1
5.7.2 External functors
The notion of a functor from a category into the
category of sets can be extended to describe a functor from a category in
to
itself. Such a functor is called an external functor. This construction is based
on the construction in Section ES 4.2 for Set. Theorem ES 4.3.7 gives an equiva-
lence of categories between external functors and the split op¯brations which are
produced by the Grothendieck construction, and so justi¯es the representation
by split op¯brations of external functors de¯ned on a category object.
Essentially, what we will do is use objects and arrows representing sets and
functions involved in the Grothendieck construction, ¯nd enough cones and com-
mutative diagrams to characterize it, and take that as the de¯nition of external
functor in an arbitrary category.
5.7.3
Let
be a category, and let
C = (C ; C ;source;target; unit; comp)
0
1
be a category object in
. An external functor C ¡!
consists of data
0
1
(D ; D ;D ; d ; d ;u; ¼ ;¼ ; p ;p ; c)
0
1
2
0
1
1
2
for which the D are objects of
and the arrows have sources and targets as
i
indicated:
i
d : D ¡! D ;
i = 1; 2
1
0
u : D ¡! D
0
1
¼ : D ¡! C ;
i = 0; 1
i
i
i
p : D ¡! D ;
i = 1; 2
i
2
1
c : D ¡! D :
2
1
D is the object corresponding to the disjoint union of the values of the functor.
0
Note that we are not given a functor F as we were in Section ES 4.2 { we are being
guided by Theorem ES 4.3.7 and the details of the Grothendieck construction to
de¯ne an external functor, and ¼ represents the projection (taking (x; C) to C
0
in the case of the Grothendieck construction). D is the object corresponding to
1
the arrows of the category G(C; F) as de¯ned in Section ES 4.2, and ¼
takes
1

5.7 External functors
77
(x;f) to f. Thus ¼ and ¼ together describe the functor G(F) in the case of the
0
1
Grothendieck construction.
0
1
d and d are the source and target maps of that category, c is the composition
and u picks out the identities.
The data are subject to the requirements E{1 through E{4 below.
E{1 All three diagrams below must commute and (a) must be a pullback:
¼
¼
¼
1
1
o
-
-
-
D
C
D
C
D
C
1
1
1
1
1
1
6
6
0
1
source
target
u
unit
d
d
(5.4)
?
?
?
?
-
-
-
D
C
D
C
D
C
0
0
0
0
0
0
¼
¼
¼
0
0
1
(a)
(b)
(c)
That (a) is a pullback says in the case of the Grothendieck construction that,
up to unique isomorphism, D consists of elements of the form (x; f) with f an
1
arrow of
and x 2 F(C) where C is the source of f. This is part of GS{2 (see
0
0
Section ES 4.2). The commutation of (b) says that d (x; f) 2 F(C ) where C is
1
0
0
the target of F; that follows from GS{1 and GS{2 (there, x must be in F(C )).
That of (c) says that u(x; C) must be (id ). In the case of the Grothendieck
C
construction that follows from the fact that F is given as a functor.
E{2 The following diagram is a pullback:
p2 -
D
D
2
1
1
p
d
1
?
?
-
D
D
1
0
0
d
(d)
In the case of the Grothendieck construction this forces D
to be the set of
2
composable pairs of arrows of G(C;F).
E{3 The following diagram must commute:

78
Toposes
¼1 -
D
C
1
1
6
6
p
p
1
1
-
D
C
2
2
¼2
p
p
2
2
?
?
-
D
C
1
1
¼1
(e)
¼ is de¯ned by Diagram (ES 5.3) (called f there). In the case of the Grothen-
2
2
0
dieck construction this follows from GS{3: (x; g ) composes with (x;f) only if g
composes with f (but not conversely!).
E{4 The following diagrams must commute.
p
p
¼
1
2
2-
-
-
D
C
D
D
D
D
2
2
2
1
2
1
0
1
comp
c
c
c
d
d
(5.5)
?
?
?
?
?
?
-
-
-
D
C
D
D
D
D
1
1
1
0
1
0
0
1
¼1
d
d
(f)
(g)
(h)
In the case of the Grothendieck construction, (f) says that ¼ preserves composi-
1
tion and (g) and (h) say that the composite has the correct source and target.
As we have presented these diagrams, we have observed that they are all
true in the case of the Grothendieck construction in Set. In the case of the
Grothendieck construction,
(D ; D ;source; target; unit; comp)
0
1
is actually a category, hence a category object in Set. Moreover, ¼ = (¼ ; ¼ ) is
0
1
a functor, namely G(F). That is actually true in any category, as seen in the
following.
5.7.4 Proposition
Let
0
1
(D ; D ;D ; d ; d ;u; ¼ ;¼ ; p ;p ; c)
0
1
2
0
1
1
2
be an external functor to a category object
= (C ; C ; source;target;unit;comp)
0
1

5.8 The realizability topos
79
in a category
. Then
(D ; D ;source; target; unit; comp)
0
1
is a category object in
and (¼ ; ¼ ) is a functor in
.
0
1
The proof is a lengthy series of diagram chases.
The converse is true, too: up to some technicalities, an external functor in Set
arises from a functor to Set from a small category. That means we said enough
about it in E{1 through E{4 to characterize it.
5.7.5 Theorem
Let
0
1
(
;
;
; d ; d ;u; ¼ ;¼ ; p ;p ; c)
0
1
2
0
1
1
2
be an external functor to a category
= (
;
;source; target; unit; comp)
0
1
in Set. De¯ne F :
¡! Set by
¡1
F{1 If C is an object of
, then F(C) = ¼
(C).
1
0
F{2 If f : C ¡! C is an arrow of
and x 2 F(C), then F(f)(x) is the target
0
of the unique arrow ® of
for which ¼ (®) = f and d (®) = x.
1
Then F :
¡! Set is a functor, and there is a unique isomorphism ¯ :
¡!
±
G(
; F) for which G(F)
¯ = ¼.
This theorem is essentially the discrete case of Theorem ES 4.3.7.
F{2 makes use of the fact that Diagram (ES 5.4)(a) is a pullback. A seasoned
2
categorist will simply name ® 2 F
as (x;f), since he knows that between any
two pullbacks de¯ned by (ES 5.4)(a) there is a unique isomorphism respecting
0
the projections ¼ and d .
1
5.8 The realizability topos
The category of modest sets has been proposed as a suitable model for the poly-
morphic ¸-calculus. It is a subcategory of a speci¯c topos, the realizability topos.
Space limitations prevent us from giving a full exposition of this topic, Here we
describe how the realizability topos and the subcategory of modest sets are con-
structed. Further references are [Carboni, Freyd and Scedrov, 1988], [Rosolini,
1990], [Gray, 1991].

80
Toposes
5.8.1 Realizability sets
In the discussion below, we will be writing f(x)
where f is a partial function. It will be understood that f(x) is de¯ned when
we write this.
A realizability set is a pair A = (A;= ) where A is a set called the carrier
A
of A and = : A£A ¡!
(N) is a function to sets of natural numbers (thought of
A
as reasons that two elements are equal; in fact, they can be thought of as the set
of GÄodel numbers of proofs that they are). We denote the value of this function
at (a ;a ) 2 A £ A by [[a =
a ]], often abbreviated to [[a = a ]]. This is subject
1
2
1
2
1
2
A
to the following conditions:
REAL{1 There is a partial recursive function f such that for any a , a 2 A and
1
2
n 2 [[a = a ]], f(n) 2 [[a = a ]].
1
2
2
1
REAL{2 There is a partial recursive function of two variables g with the property
that if n 2 [[a = a ]] and m 2 [[a = a ]], then g(n;m) 2 [[a = a ]].
1
2
2
3
1
3
This is made into a category by de¯ning an arrow from A = (A; = ) to B =
A
(B; = ) to be an equivalence class of partial functions Á : A ¡! B such that there
B
is a partial recursive function f such that n 2 [[a = a ]] implies that f(n) 2
1
2
[[Áa = Áa ]]. Two such arrows Á and Ã are equal if there is a partial recursive f
1
2
such that n 2 [[a = a]] implies that f(n) 2 [[Áa = Ãa]].
Note that the last de¯nition implies that f is de¯ned on all elements a 2 A
for which [[a = a]] 6
= ;. The other elements of A are irrelevant.
5.8.2
This category is a topos. We will not prove this, but simply describe some
of the constructions required. To ¯nd products, for example, ¯rst choose a recur-
sive bijection f : N £ N ¡! N. If A = (A; = ) and B = (B; = ) are realizability
A
B
sets, the product is (A £ B;=
£ = ), where the latter is de¯ned by
A
B
[[(a ; b ) = (a ; b )]] = ff(n;m) j n 2 [[a = a ]];m 2 [[b = b ]]g
1
1
2
2
1
2
1
2
Notice that a choice of f is required to show that products exist. The products
thereby exist, but, owing to the uniqueness of categorical products, do not depend
in any way on the choice of the function.
Equalizers can be de¯ned as follows. If Á; Ã : A ¡! B are two arrows their
equalizer is given by (A;=
) where [[a =
a ]] = [[Áa = Ãa ]].
Á;Ã
1
Á;Ã
2
1
2
Finally power objects can be constructed as follows. Let f denote a pairing
as above and also choose an enumeration g of all the partial recursive functions.
e
The carrier of
A is [A ¡!
N], all functions from A to sets of natural numbers.
If P and Q are two such functions, then we will say that f(d;e) 2 [[P = Q]] if for
all n 2 P(a) and m 2 [[a = b]], we have g (f(n; m)) 2 Q(b) and for all n 2 Q(a)
d
and m 2 [[a = b]], we have g (f(n; m)) 2 P(b).
e
This topos is called the realizability or e®ective topos. It is due to Martin
Hyland [1982], although the basic idea goes back to S. Kleene. See also [Rosolini,
1987].

5.8 The realizability topos
81
5.8.3 Modest sets
`Modest sets' is used more-or-less interchangeably to de-
note either a certain full subcategory of the category of realizability sets or an
internal category object of that topos. A great deal of e®ort has been put into
describing the connection between the two. We will begin with the former. The
category of modest sets can be described directly and then embedded into the
realizability topos.
A modest set consists of A = (N;= ) where as usual N denotes the natural
A
numbers and =
is a partial equivalence relation or PER on N, which means
A
it is symmetric and transitive, but not necessarily re°exive. We think of A as a
quotient of a subobject of N; the subobject is the set of n for which n =
n
A
modulo the relation = .
A
The category of modest sets has arrows from A to B de¯ned as partial recursive
functions f de¯ned on all n such that n =
n and such that n =
m implies that
A
A
f(n) =
f(m). Note that since the relation is symmetric and transitive, as soon
A
as there is some m with n =
m, it is also the case that n =
n and so f(n) and
A
A
f(m) are de¯ned.
The modest sets form a cartesian closed category. Choose, as above, an enu-
meration g of the partial recursive functions. Then [A ¡! B] is the PER with re-
e
lation given by d =
e if and only if whenever n =
m then g (n) =
g (m).
d
e
[A¡!B]
A
B
The modest sets do not form a topos.
We embed the modest sets into the realizability sets by choosing a pairing f
and associating to the modest set A = (N;= ) the realizability set with carrier N
A
and e 2 [[n = m]] if and only if n =
m and e = f(n; m). Although this appears
A
to depend on the choice of a pairing, it is easy to see that up to isomorphism it
does not.
In fact it cannot. The pairing is used only to show that products exist. But
their properties { in particular their isomorphism class { are independent of the
particular construction used to prove their existence. Similar remarks apply to
the cartesian closed structure, which does not depend on a particular enumeration
of the partial recursive functions.
5.8.4 The internal category of modest sets
This is a very brief glance at
how one might internalize the description of modest sets to produce a category
object inside the category of realizability sets. Except by way of motivation,
this category object has no real connection with the category of modest sets.
Nevertheless, we will call it the internal category of modest sets.
This internal category has the remarkable property that every internal dia-
gram in it has a limit. This is not possible for ordinary categories (unless they
are just posets), but the proof that it is not possible requires a property of set
theory which is not valid for the realizability sets (namely the axiom of choice).
The construction is an exercise in internal expression. A modest set is a re-
lation on N with certain properties. The natural numbers object in the category

82
Toposes
of realizability sets is the object (N; = ), where e 2 [[n =
m]] if and only if
N
N
n = m = e. That is [[n =
m]] = fng if n = m and is empty otherwise. We will
N
denote it by N. Then a modest set is a subset of N £ N with certain properties.
The set of objects of the internal category of modest sets is then a certain
set of subsets of N £ N, which is the same as a subset of
(N £ N). We want
to describe this subset as consisting of those relations that are symmetric and
transitive and double negation closed. The trick is to de¯ne endoarrows s and t of
op
±
(N£N) that associate to a relation R the relations R
and R
R, respectively.
For s, this is easy. There is an arrow hp ; p i : N £ N ¡! N £ N that switches the
2
1
coordinates and we let s =
(hp ; p i).
2
1
For t, it is a little harder. By Yoneda, an arrow
(N £ N) to itself can be
de¯ned by describing a natural transformation Hom(¡;
(N £ N)) to itself. An
element of Hom(A;
(N £ N)) is, by the de¯ning property of
, a subobject
0
R µ A £N £N. Given such an R, we de¯ne R to be the pullback in the following
diagram:
0
-
R
R
?
?
-
R
A £ N
The two maps from R ¡! A £ N are the inclusion into A £ N £ N followed by
hp ; p i and hp ; p i, respectively. You should think of R as being a set of triples
1
2
1
3
0
(a; n ;n ) and then R µ A £ N £ N £ N is the set of 4-tuples (a; n ; n ; n ) such
1
2
1
2
3
0
that (a;n ;n ) 2 R and (a;n ;n ) 2 R. Then the inclusion of R into A£N£N£N
1
2
2
3
0
followed by hp ;p ;p i gives us an arrow R ¡! A £N £N whose image we denote
1
2
4
by t(R). It is interpreted as the set of (a; n ; n ) such that there is an n
with
1
3
2
both (a; n ; n ) 2 R and (a; n ; n ) 2 R. We omit the proof that this construction
1
2
2
3
from R to t(R) is natural in A, but assuming that, it follows from the Yoneda
Lemma that this results from an endomorphism t of
(N £ N).
Finally, the object M of objects is de¯ned as the limit of
0
s--
(N £ N)
(N £ N)
-
t
where the middle arrow is the identity. This is to be interpreted as the set of
relations that are ¯xed under both s and t.
The object M is the object of objects of the internal category of modest sets.
0
The object of arrows is de¯ned as a subobject of the object [N ¡! N]e of partial
arrows of N to N; namely those that satisfy the internal version of the de¯nition
of the ordinary of modest sets. This construction is tedious, but not di±cult, and
we omit it.

Answers to Exercises
Solutions for Chapter 1
Section 1.1
1. This should have two sorts 1 and b. There should be an operation true : 1 ¡! b,
an operation false : 1 ¡! b and a cocone
1
1
@
¡
@
¡
true
false
@
¡
@R
¡ª
b
We need a cone with empty base to express that 1 is terminal. We should have
operations _ : b £ b ¡! b, ^ : b £ b ¡! b and : : b ¡! b. We will need diagrams to
express equations like
: true
=
false
: false
=
true
: ^ (x; y)
=
_(x; y)
_(0;0)
=
0
_(0;1)
=
1
_(1;0)
=
1
_(1;1)
=
1
There are other equations, but they all follow from these. In particular, we do
not, in this case, have to express the distributive laws since they follow, there
being so few elements.
2. If we have one sort 1, one empty cone with vertex 1 and one cocone
1
1
@
¡
id
id
@
¡
@R
¡ª
1
83

84
Solutions for section 1.3
then there is no model in sets because the model must take 1 to the one-element
set and that must satisfy that 1 = 1 + 1, which is impossible. It follows from
Exercise 4 of Section 8.6 that this sketch does have a model in the category of
monoids.
Section 1.2
1. This is most readily done using elements, although it can all be done with
¡1
¡1
diagrams. If x ¤ x
= 1 and y ¤ y
= 1, then
¡1
¡1
¡1
¡1
¡1
¡1
(x ¤ y) ¤ (y
¤ x
) = x ¤ (y ¤ (y ¤
¤x
)) = x ¤ ((y ¤ y
) ¤ x
)
¡1
¡1
= x ¤ (1 ¤ x
) = x ¤ x
= 1
¡1
¡1
¡1
If 2 6
= 0 in a ¯eld, then 2
exists, whence (2¤2)
= 4
also exists. Hence 4 6
= 0.
2. Let Q and F denote the ¯elds of rational numbers and the two-element ¯eld
2
respectively. In order to have a product of Q and F , we have to have a cone
2
F
¡
@
¡
@
¡ª
@R
Q
F2
which is exactly what we do not have in the category of ¯elds.
Section 1.3
1. a. Several things have to be shown. First that the image N µ N is closed
0
under the operations (that is if all the arguments of the operation are in the
image, so does the value); second that the diagrams continue to commute; third
that the cones remain products; and fourth that the cocones remain sums.
Let u : s £ s £ ¢¢ ¢ £ s ¡! s be an operation. For i = 1; :: :; n let x 2 M(s )
1
2
n
i
i
and x = u(x ; :: :; x ). Then f(x) = u(f(x ); :: :; f(x )), which demonstrates the
1
n
1
n
¯rst point. Since the operations in N are the restrictions of those in N any two
0
paths that agree on N do so on N
(actually, whether or not they do on M).
0
For the cones, we illustrate on binary cones. Suppose s Ã¡ r ¡! t is a cone in the
sketch. Then in the diagram
-
-
-
M(r)
N (r)
N(r)
0
?
f
??
?
?
--
-
M(s) £ M(t)
N (s) £ N (t)
N(s) £ N(t)
0
0

Solutions for section 1.3
85
certain functions have been labeled as being surjective or injective (although oth-
ers are and some are bijective). These use the facts that the product of two injec-
tive functions is injective and the product of two surjective functions is surjective.
That f is surjective follows from the fact that the composite of two surjective
functions is surjective and if the composite of two functions is surjective, so is the
second one. Dually, the fact that f is injective uses the facts that the composite
of two injective functions is injective and that if the composite of two functions
is injective, the ¯rst one is.
The dual argument, using the fact that a sum of injectives is injective and a
sum of surjectives is surjective, gives the corresponding result for discrete cocones.
It is worth noting that these arguments fail if either the cones or cocones
fail to be discrete or if the category in which the models are taken is other than
the category of sets. The reason is that even in the category of sets, the arrow
induced between equalizers of epis is not necessarily epic and between coequalizers
of monos will not be monic. (Equalizers and coequalizers are de¯ned in chapter 8.)
In categories other than sets, even the sum of epics will not generally be epic, nor
the sums of monics monic.
b. There are two ways of doing this. One is to show that the intersection of
submodels is a submodel. Then the intersection of all submodels is clearly the
smallest submodel. Another is to take the image of the initial term model in the
component of that model. Let M be the initial term model, N is the given model
and N this submodel. If N µ N is any other submodel, there is an initial term
0
1
0
0
model M in the component of N that has an arrow M ¡! N . But N µ N and
1
1
1
0
so is in the same component as N. Thus M = M and the map M ¡! N µ N is
1
the original map M ¡! N. Since that factors through N , it follows that N µ N .
1
0
1
Solutions for Chapter 2
Section 2.1
1. Add a new unary operation i : c ¡! c and the following diagrams:
1
1
c
c
2
2
¡
@
¡
@
¡
@
¡
@
hid; ii
hi;idi
i
i
id
id
¡
@
¡
@
¡ª
@R
¡ª
@R
?
?
¾
-
¾
-
c
c
c
c
c
c
1
2
1
1
2
1
p
p
p
p
1
2
1
2

86
Solutions for section 2.3
hid; ii
hi;idi
-
-
c
c
c
c
1
2
1
2
@
@
@
@
c
c
id
id
@
@
?
@R
?
@R
c
c
1
1
2. Let (C ; C ; s; t; u; c) and (D ; D ; s; t; u; c) be two models of the sketch for
0
1
0
1
categories. Note that we have used the common convention of using the same
letter to stand for the arrow in the sketch and in the model (in every model, in
fact). A homomorphism consists of an arrow F : C ¡! D and an arrow F : C
0
0
0
1
1
¡! D that satisfy some conditions forced by the fact that a homomorphism is
1
±
±
±
±
a natural transformation. First o®, we have s
F = F
s, t
F = F
t and
1
0
1
0
±
±
u
F = F
u. These mean that the homomorphism preserves source, target and
0
1
identity arrows. These identities induce a unique arrow F : C ¡! D such that
2
2
2
±
±
±
±
±
±
p
F = F
p and p
F = F
p . We further suppose that c
F = F
c.
1
2
1
1
2
2
1
2
2
1
These conditions mean that the homomorphism preserves composition; thus the
homomorphism is a functor.
Section 2.2
±
1. Referring to Diagram (ES 2.1), we see that incl is the arrow opposite 6true : 1
¡! b in a cone, which means that in a model it is the arrow opposite an arrow
from 1. But every arrow from 1 is monic (see Section 2.8, Exercise 7). Hence incl
is monic.
Section 2.3
1. It is the set of all diagrams (not necessarily commutative) of the form
f -
A
B
@g
h
@
?
@R
C
2. It is the set of all commutative diagrams of the form
f -
A
B
@g
h
@
?
@R
C
0
3. For each object C of
, let M (c) = f(x; c) j x 2 M(c)g. If t : c ¡! d is an
arrow in
, let t(x;c) = (t(x); d). Then the ¯rst projection is an isomorphism
0
M ¡! M and it is clear that M(c) \ M(d) = ; for c 6
= d.

Solutions for section 3.1
87
Solutions for Chapter 3
Section 3.1
1. A model of
is a sketch homomorphisms
¡!
. This assigns to the single
node of
an object E and that is all. If we denote the single object of
by
w, then the functor M 7
! M(e) is evidently an isomorphism between the objects
of
and those of Mod( ;
). If ® : M ¡! N is a natural transformation, the
®e : M(e) ¡! N(e) is an arrow of
and is subject to no conditions. Thus means
that Nat(M; N) = Hom(M(e);N(e)) and so the functor is an isomorphism.
Section 3.2
1. Nat has one such node, denoted 1, as does Stack. The disjoint union has two
such nodes, but when the coequalizer is formed they are identi¯ed to a single
node in
. This node, and only this, must become a singleton in any model.
Section 3.3
1. U £ U is induced by the sketch homomorphism from
to the sketch for
monoids (given in 7.2.1 and 7.3.2) that takes e to s £ s.
2. For any u : s ¡! s
in
, we have F(u) : F(s ) ¡! F(s ) which gives a
1
2
1
2
commutative square
M(F(u))-
M(F(s ))
M(F(s ))
1
2
®F(s )
®F(s )
1
2
?
?
-
N(F(s ))
N(F(s ))
1
2
N(F(u))
which is the same as
¤
F (M)u
¤
¤
-
F (M)(s )
F (M)(s )
1
2
¤
¤
F (®)s
F (N)u
2
?
?
¤
¤
-
F (N)(s )
F (N)(s )
1
2
¤
F (®)s2
¤
which is naturality of F (M).
¤
±
3. We have for id
:
¡!
that (id
) (M) = M
id
= M and for ® : M
¤
¤
¡! N, (id
) (®) = ® id
= ®. Thus (id
)
is the identity functor. If G : R
¤
±
±
±
¡!
is another homomorphism of sketches, then (F
G) (M) = M
F
G =
¤
¤
¤
¤
¤
±
±
G (M
F) = G (F (M)) = (G
F )(M) and similarly for ® : M ¡! N. Thus
¤
¤
¤
±
±
(F
G) = G
F
which shows that Mod (¡) is a contravariant functor.

88
Solutions for section 4.1
4. Suppose, say, that ¾ is a diagram. The other two possibilities are similar.
Suppose ¾ says that
±
±
±
±
s
¢¢ ¢
s = t
¢¢ ¢
t
1
n
1
m
¤
Then ¾ is satis¯ed in F (M) if and only if
¤
¤
¤
¤
±
±
±
±
F (M)(s )
¢¢ ¢
F (M)(s ) = F (M)(t )
¢¢ ¢
F (M)(t )
1
n
1
m
which is the same as
±
±
±
±
M(F(s ))
¢ ¢ ¢
M(F(s )) = M(F(t ))
¢ ¢¢
M(F(t ))
1
n
1
m
which is the same as the condition that M satisfy F(¾).
Solutions for Chapter 4
Section 4.1
1. Let
be the ¯ber over an object C. If X is an object of
, then P(X) = C
C
C
and P(id ) = id
by de¯nition of functor It follows that id
is an arrow of
.
X
C
X
C
If f : X ¡! Y and g : Y ¡! Z are arrows of
, then P(f) = P(g) = id , so
C
C
±
±
±
±
P(g
f) = P(g)
P(f) = id
id
= id , so g
f is an arrow of
. Hence
is
C
C
C
C
C
a subcategory.
2. Let P :
¡!
be a ¯bration with cleavage °. To see that Ff is a functor,
±
±
note ¯rst that °(f; Y )
id
= id
°(f; Y ) so that Ff(id ) = id
. Suppose
Y
Y
Y
FfY
0
0
00
u : Y ¡! Y . Then
00
0
0
0
0
±
±
±
±
±
±
°(f; Y )
Ff(u )
Ff(u) = u
°(f; Y )
Ff(u) = u
u
°(f; Y )
0
0
±
±
so by uniqueness Ff(u
u) = Ff(u )
Ff(u).
Now we show that F is a contravariant functor. If we show that F(id ) is
C
the identity on arrows it will have to be the identity on objects because functors
preserve source and target. Let C be an object of
and u an arrow of F(C). Then
0
±
±
F(id )(u) is the unique arrow for which °(id ;Y )
F(id )(u) = u
°(id ;Y ). By
C
C
C
C
±
±
0
SC{1, this requirement becomes id
F(id )(u) = u
id . Thus F(id )(u) = u
Y
C
Y
C
as required.
0
Now suppose f : C ¡! D and g : D ¡! E in
. Let u : Y ¡! Y
in F(C).
±
Then F(g
f)(u) must be the unique arrow for which
0
±
±
±
±
±
°(g
f; Y )
F(g
f)(u) = u
°(g
f;Y )
But
±
±
±
±
u
°(g
f;Y )
=
u
°(g; Y )
°(f;Ff(Y ))
0
±
±
=
°(g; Y )
Fg(u)
°(f; Ff(Y ))
0
0
±
±
=
°(g; Y )
°(f; Ff(Y ))
Ff(Fg(u))
±
±
so by CA{2 and SC{2, F(g
f) = F(f)
F(g).

Solutions for section 4.1
89
3. a. We will also denote the functor by Á. It is a ¯bration if for every element
x of Z there is an element u of Z such that Á(u) = x (that is CA{1) and for
2
4
every v 2 Z and h 2 Z such that x+h = Á(v) (mod2), there is a unique w 2 Z
4
2
4
for which Á(w) = h and u + w = v (mod 4) (which is CA{2). This amounts to
saying that Á is surjective and every equation m + y = n (mod4) can be solved
uniquely for y, which requires simple case checking (or knowing that Z and Z
2
4
are groups). An analogous proof works for op¯bration.
b. A splitting would be a monoid homomorphism (this follows immediately
from SC{1 and SC{2) which would make Á a split epimorphism, which it is not
by Exercise 2 of Section 2.9.
0
0
0
4. a. P preserves source and target by de¯nition. Let (h;k) : f ¡! f and (h ; k ) :
0
00
f ¡! f . Then
0
0
0
0
0
0
0
±
±
±
±
±
P((h ; k )
(h; k)) = P(h
h; k
k) = k
k = P(h ; k )
P(h;k)
Thus P preserves composition. The identity on an object (A; B) is (id ;id ), so
A
B
it follows immediately that P preserves identities.
b. Let f : C ¡! D in
and let k : B ¡! D be an object of
lying over D.
Let °(f;k) be the arrow (u; f) of
de¯ned in ES 4.1.5. P(°(f;k)) = f so CA{1
0
is satis¯ed. As for CA{2, let (v; v ) : z ¡! k in
and let h be an arrow of
such
0
±
that f
h = v . Let w be the unique arrow given by the pullback property for
0
±
±
±
which u
w = v and u
w = h
z. The last equation says that (w;h) is an arrow
0
±
±
±
of
, and (u; f)
(w; h) = (u
w; f
h) = (v; v ) as required. The uniqueness
property of the pullback means that (w; h) is the only such arrow.
Section 4.2
0
0
0
0
1. The identity arrow for (x; C) is (x; id ). Let (x;f) : (x; C) ¡! (x ; C ), (x ;f ) :
C
0
0
00
00
00
00
00
00
000
000
(x ; C ) ¡! (x ; C ) and (x ; f ) : (x ; C ) ¡! (x ; C ) be arrows of G (
; F).
0
00
00
0
0
00
00
0
00
00
0
±
±
±
±
±
±
Then ((x ; f )
(x ; f ))
(x; f) = (x ; f
f )
(x; f) = (x ; (f
f )
f) =
00
00
0
00
00
0
0
±
±
±
±
(x ;f
(f
f)) = (x ; f )
((x ;f )
(x; f)) so composition is associative.
0
2. Let f : C ¡! C in
. Let (x;C) be an object of G (
; F) lying over C. De¯ne
0
0
0
0
·(f;(x;C)) to be (x;f) : (x;C) ¡! (x ; C ) where x = Ff(x). Now suppose (x;g) :
00
0
00
±
(x;C) ¡! (y; C ) and suppose k : C ¡! C
has the property that k
f = g. The
0
0
0
00
arrow required by OA{2 is (x ;k) : (x ; C ) ¡! (y; C ). This is well de¯ned since
0
00
±
Fk(x ) = Fk(Ff(x)) = F(k
f)(x) = Fg(x) which must be y since (y; C ) is
0
±
±
the given target of (x; g). Moreover it satis¯es OA{2 since (x ;k)
(x; f) = (x; k
0
0
f) = (x;g). An arrow satisfying OA{2 must lie over k and have source (x ; C ) and
00
0
target (y;C ) so that it can compose with f to give g, so (x ; k) is the only possible
0
0
0
0
00
00
such arrow. To see that · is a splitting, suppose that (x ;f ) : (x ;C ) ¡! (x ;C ).
0
0
0
0
0
0
0
0
0
±
±
±
Then ·(f ; (x ;C )) = (x ; f ) and (x ; f )
(x; f) = (x; f
f) = ·(f
f; (x; C))
as required. The veri¯cation for identities is even easier.

90
Solutions for section 4.2
3.
The identity arrow is (id ;id ) : (x;C) ¡! (x;C). It is well de¯ned since
x
C
F(id )(x) = x, so id : F(id )(x) ¡! x. Suppose that (u;f) is an arrow from (x;C)
C
x
C
0
0
0
0
0
0
0
00
00
to (x ;C ), so that u : Ff(x) ¡! x . Similarly, let (u ;f ) : (x ;C ) ¡! (x ;C ) and
00
00
00
00
000
000
(u ;f ) : (x ;C ) ¡! (x ;C ). Then
00
00
0
0
00
00
0
00
0
±
±
±
±
((u ;f )
(u ;f ))
(u;f)
=
(u ;Ff (u );f
f )
(u;f)
00
00
0
00
0
00
0
±
±
±
±
±
=
(u
Ff (u )
F(f
f )(u);(f
f )
f)
and
00
00
0
0
00
00
0
0
±
±
±
±
±
(u ;f )
((u ;f )
(u;f))
=
(u ;f )
(u
Ff(u);f
f)
00
00
0
0
00
0
±
±
±
±
=
(u
Ff (u
Ff (u));f
(f
f))
00
The result follow from the facts that F and Ff
are functors and composition in
is associative.
0
4. Let f : C ¡! C and let (x; C) lie over C. De¯ne ·(f; (x;C)) to be
0
(id
; f) : (x;C) ¡! (Ff(x); C )
Ff(x)
00
0
00
Let (u; g) : (x; C) ¡! (y; C ) so that u : Fg(x) ¡! y. Let k : C ¡! C
satisfy
0
00
±
k
f = g. Then (u;k) : (Ff(x);C ) ¡! (y; C ) because the domain of u is Fg(x) =
±
F(k
f)(x) = F(k)(Ff(x)). Furthermore,
±
±
±
(u;k)
(id
; f) = (u
F(id
); k
f) = (u; g)
Ff(x)
F f(x)
as required by OA{2. It follows as in the answer to the second problem that (u;k)
is the only possible arrow with this property.
5.
0
0
00
00
0
0
00
00
((t;m)(t ;m ))(t ;m )
=
(t®(m; t );mm )(t ; m )
0
0
00
0
00
=
(t®(m; t )®(mm ; t ); mm m )
and
0
0
00
00
0
00
0
00
(t; m)((t ; m )(t ; m ))
=
(t;m)(t;®(m ; t ); m m )
0
0
00
0
00
=
(t®(m; t ®(m ; t )); mm m )
However, by MA{4,
0
0
00
0
0
00
®(m; t )®(mm ; t ) = ®(m; t )®(m;®(m ; t ))
0
0
00
and that is ®(m;t ®(m ;t )) by MA|2.
6. Let ¯ take an object x of F(C) to (x;C) and an arrow u to (u;id ). By GC{3,
C
if v : y ¡! z then
±
±
±
±
(v;id )
(u; id ) = (v
F(id )(u);id
id ) = (v
u; id )
C
C
C
C
C
C
so ¯ preserves composition. It is clearly a bijection and preserves identities.

Solutions for section 4.3
91
Section 4.3
1. Suppose that ® : F ¡! G is a natural transformation. G® preserves identities
because G®(id ;id ) = ®C(id ; id ) = (id
;id ). Suppose that (u; f) : (x;C)
X
C
X
C
®C(x)
C
0
0
0
0
0
0
00
00
¡! (x ;C ) and (u ;f ) : (x ; C ) ¡! (x ; C ). Then
0
0
0
0
0
±
±
±
(u ;f )
(u;f) = (u
Ff (u);f
f)
by GC{3 (Section ES 4.2). On the other hand,
0
0
00
0
0
0
±
±
G®(u ; f )
G®(u;f)
=
(®C u ; f )
(®C u;f)
00
0
0
0
0
±
±
=
(®C u
Gf (®C u); f
f)
00
0
00
0
0
±
±
=
(®C u
®C (Ff (u));f
f)
00
0
0
0
±
±
=
(®C (u
Ff (u)); f
f)
0
0
0
±
±
=
G®(u
Ff (u);f
f)
where the third equality uses the naturality of ® and the fourth uses the fact that
00
®C
is a functor. Thus G® preserves composition.
2. GR{2 implies that G preserves identity natural transformations, since any
0
component of an identity transformation is an identity arrow. Let ® : F ¡! F
0
00
0
00
and ¯ : F ¡! F
be natural transformations, where F, F and F
are functors
0
from
to Cat. Then for (u;f) : (x;C) ¡! (x; C ),
0
0
0
±
±
G(¯
®)(u;f) = ((¯
®)C u;f) = (¯C (®C u);f)
and
0
0
0
(G¯(G®))(u; f) = G¯(®C u;f) = (¯C (®C u);f)
so G preserves composition.
Section 4.4
1. If
and
are monoids, then each has only one object. By WP{1, an object
G
of
wr
is a pair (A; P) where A is the only object of
and P : G(A) ¡!
is a functor. But if
has only one object and G(A) is discrete, there is only one
functor from G(A) to
{ it must take all the objects of G(A) to the only object
G
of
. Hence
wr
has only one object, so is a monoid.
2. Let
and
be groups. Since they have only one object each, we can simplify
0
the notation in WP{1 through WP{3 and omit mention of the objects A, A and
00
A . The value of G at the only object of
is a category we will call
. If f is
an element of the group
, then Gf is an automorphism of the category
. An
G
0
object of
wr
is a functor P :
¡!
. An arrow (f; ¸) : P ¡! P consists
0 ±
of an element f of the group
and a natural transformation ¸ : P ¡! P
Gf.
Each component of ¸ is an element of the group
so has an inverse; thus ¸ is

92
Solutions for section 5.1
an invertible natural transformation. Since f is also a group element, it has an
¡1
inverse f
. Let ¹ be the natural transformation whose component at an object
¡1
¡1
¡1
X of
is (¸(Gf)
(X))
. Then the inverse of the arrow (f; ¸) is (F
; ¹). To
verify this, we calculate
¡1
¡1
±
±
±
(F
; ¹)
(f; ¸) = (f
f; ¹Gf
¸)
¡1 ±
Now F
f is the identity of
and for an object X of
,
±
±
(¹Gf
¸)X
=
¹(Gf(X))
¸X
¡1
¡1 ±
=
¸((Gf)
(Gf(X)))
¸X
¡1 ±
=
(¸X)
¸X = idX
so (f; ¸) is invertible.
Solutions for Chapter 5
Section 5.1
1. Let the pullbacks be
g
g
0
1
0
0
-
-
C
C
C
C
0
1
0
1
0
0
f
f
f
f
0
1
0
1
?
?
?
?
0
-
0
-
C
C
C
C
g
g
±
Let u : C ¡! C and v : C ¡! C be the inverse isomorphisms such that f
v =
0
1
1
0
0
0
±
±
±
±
±
f and f
u = f . Then f
u
g = f
g = g
f so by the universal mapping
1
1
0
1
0
0
0
0
0
0
0
property of the right hand pullback, there is a unique u : C ¡! C
such that
0
1
0
0
0
0
0
0
0
±
±
±
g
u = f
u and f
u = f . Similarly, there is a unique v : C ¡! C such
1
1
1
0
1
0
0
0
0
0
0
0
±
±
±
that g
v = f
v and f
v = f . Thus f and f belong to the same subobject.
0
0
0
1
0
1
2. For f : C )¡!C, the square
0
f -
C
C
0
id
id
C
C
0
?
?
-
C
C
0
f
is a pullback. Thus the function induced by the identity of C assigns to each
subobject of C the subobject itself (or an equivalent one).

Solutions for section 5.1
93
3. If S and T are ¯nite, so is the set of functions between them. In fact if we let
#(T )
#S denote the number of elements, then #[T ¡! S] = #(S)
. For if T = ;,
then there is exactly one function from T to S no matter what S is. If T 6
= ; and
S = ;, then there are no functions from T to S. If both are nonempty, we suppose
by induction that the conclusion is true for sets with fewer elements than T, let
t 2 T and T = T ¡ftg. A function from T to S is determined by a function from
0
T to S plus an element of S for t to go to. Thus the number of such functions is
0
#(T )
#(T )¡1
#(T )
0
#(S)
#(S) = #(S)
#(S) = #(S)
which is still ¯nite. Thus the category of ¯nite sets is cartesian closed. The two-
element set is also ¯nite so the category of ¯nite sets has a subset classi¯er.
S
4. It is not quite su±cient to point out that when S is in¯nite, the set 2 of subsets
S
»
of S is not countable. The point to be made is that Hom(1; 2 )
Hom(S; 2)
=
(where here 2 is the set f0; 1g) and the latter set of functions is not countable,
while there is no countable or ¯nite set T for which Hom(1; T) is not countable
or ¯nite. Thus there is no ¯nite or countable set that has the universal mapping
S
property required to be the powerset 2 .
Section 5.2
1. In the category of sets, - = 2 so we must verify that
A »
»
Hom(B; 2 )
Hom(A £ B; 2)
Sub(A £ B)
=
=
A
If f : B ¡! 2
is a function, let Á(f) : A £ B ¡! 2 by Á(f)(a; b) = Á(b)(a). If
g : A£B ¡! 2 is a function, let Ã(g) = f(a;b) j g(a;b) = 1g µ A£B. If U µ A£B
is a subset, then let
½ 1
if (a; b) 2 U
½(U)(b)(a) =
0
if (a; b) =2 U
±
±
A
It is immediate that ½
Ã
Á = id
and similarly for the other two serial
Hom(B;2 )
composites, from which it is immediate that each of them is invertible, with
inverse the composite of the other two.
2. For x 2 S, let [x] denote the equivalence class containing it. Then [x] = [y] if
0
1
and only if (x; y) 2 E. Let d ; d
: E ¡! S be the two arrows mentioned above
0
±
and let d : S ¡! S=E denote the arrow x 7
! [x]. Then for (x;y) 2 E, d
d (x; y) =
1
0
1
±
d(x) = [x] = [y] = d(y) = d
d (x; y) so that d coequalizes d
and d .
0
1
0
1
±
±
Now suppose that e ;e : T ¡! S such that d
e = d
e . Then for all x 2
0
1
0
1
T, [e (x)] = [e (x)]; equivalently (e (x); e (x)) 2 E. Thus we can let f : T ¡!
0
1
0
0
0
1
0
±
E by de¯ning f(x) = (e (x); e (x)). Then d
f(x) = d (e (x); e (x)) = e (x)
1
1
0
±
±
and similarly d
f(x) = e (x). Finally if g : T ¡! E is such that d
g(x) =
0
0
1
0
1
1
0
1
±
d (e (x); e (x)) = e (x) and d
g(x) = e (x), then g(x) = (e (x); e (x)) = f(x).

94
Solutions for section 5.2
3. a. Suppose that d, e form an equivalence relation. This means that for any
monoid N, the pair
Hom(N; d); Hom(N;e) : Hom(N; E) ¡! Hom(N; M)
gives an equivalence relation on the latter. This is another way of saying that
hHom(N;d);Hom(N; e)i : Hom(N; E) ¡! Hom(N;M) £ Hom(N; M)
is an equivalence relation. Since
»
Hom(N;M) £ Hom(N; M)
Hom(N; M £ M)
=
we have that hd;ei : E ¡! M £ M is monic. Since the image of a monoid homo-
morphism is a submonoid, the image is a submonoid. By letting N = N, whence
Hom(N;E) and Hom(N; M) are the underlying sets of E and M respectively,
we conclude that the image of hd; ei is also an equivalence relation on the set
underlying M. Thus it is a congruence.
Conversely, let d; e : E ¡! M have the given property. Then up to isomorph-
ism, we may suppose that E µ M £ M is both a submonoid and an equivalence
relation and that d and e are the inclusion followed by the product projections.
Then for any monoid N, Hom(N; E) consists of those pairs of arrows f; g : N
¡! E such that for all x 2 N, (f(x); g(x)) 2 E. Since E is an equivalence rela-
tion, it is immediate that this makes Hom(N; E) into an equivalence relation on
Hom(N;M).
b. Let us suppose that E µ M £ M is a submonoid and simultaneously an
equivalence relation. For an x 2 M, let [x] denote the equivalence class contain-
0
0
0
0
ing x. If x 2 [x] and y 2 [y], then (x; x ) 2 E and (y; y ) 2 E, whence so is
0
0
0
0
0
0
(x; x )(y; y ) = (xy; x y ). Thus x y 2 [xy] which means there an unambiguous
multiplication de¯ned on the set M=E of equivalence classes by [x][y] = [xy].
The associativity is obvious as is [1][x] = [x][1] = [x]. Thus M=E is a monoid
and evidently the arrow p : M ¡! M=E, x 7
! [x] is a monoid homomorphism.
0
0
0
p(x) = p(x ) if and only if x 2 [x] if and only if (x;x ) 2 E so E is the kernel pair
of p.
0
1
4. Let f be the coequalizer of the two arrows e ; e : E ¡! C and let the ker-
0
1
0
1
±
±
nel pair be d ; d
: K ¡! C. Since f
e = f
e , it follows from the universal
mapping property of kernel pairs that there is a unique arrow e : E ¡! K such
0
0
1
1
0
1
±
±
±
±
that d
e = e and d
e = e . Now d
f = d
f is one of the de¯ning prop-
0
1
±
±
erties of kernel pairs. If g : C ¡! B is an arrow such that g
d
= g
d , then
0
0
1
1
0
1
±
±
±
±
±
±
g
e = g
d
e = g
d
e = g
e . Since f is the coequalizer of e
and e ,
±
there is a unique h : D ¡! B such that h
f = g.
0
5. Let S = fag, T = fa;bg and f : S ¡! T be the inclusion. The kernel pair d ,
1
0
1
d of f is the equality relation on S, that is d = d , but f is not the coequalizer.

Solutions for section 5.2
95
For any set U with more than one element and any function g : S ¡! U there are
±
many functions h : T ¡! U such that h
f = g, since g(b) can be any element of
U.
6. Let T be a set, T µ T a subset and f : T ¡! S be an arbitrary function.
0
0
b
De¯ne f : T ¡! S [ f¤g by
½f(x)
if x 2 T
b
0
f(x) =
¤
otherwise
b
Then T = fx 2 T j f(x) 2 Sg, which is another way of saying that
0
f -
T
S
0
?
?
-
T
S [ f¤g
bf
is a pullback. If g is a function with the same property, then g(x) 2 S if and only
b
if f(x) is, which means that g(x) = ¤ if and only if f(x) = ¤. Also, if g(x) 6
= ¤,
b
b
then x 2 T so that g(x) = f(x) = f(x). Thus g = f in all cases.
0
7. Since each object has a unique arrow to 1, there is a one to one correspondence
between subobjects of an object A and partial arrows of A to 1. But partial
e
arrows of A to 1 are in one to one correspondence with arrows A ¡! 1. Thus
e »
Hom(A; 1)
Sub(A) which is the de¯ning property of -.
=
Section 5.4
¡!
1. We are thinking of
= 0
1 as a category and 0 and 1 as two objects.
¡!
The category of graphs is the category of contravariant functors
¡! Set. In
particular, the objects 0 and 1 represent functors and the question is which ones.
Let us denote the two nonidentity arrows of
by s and t (mnemonic for `source'
and `target'). A functor F :
¡! Set determines and is determined by the two
sets F(1) and F(0) and the two arrows F(s) : F(1) ¡! F(0) and f(t) : F(1) ¡!
F(0). In the case that F = Hom(¡;0), the two sets are Hom(0;0) and Hom(1; 0)
which are a one-element set and the empty set, respectively, and the functions
are the unique functions that exists in that case. Thus the contravariant functor
represented by 0 is the graph 1 which we have also called No.
For take the functor represented by 1, the two sets are Hom(1;1) = fid g and
1
Hom(0; 1) = fs, tg. The two arrows take the element of Hom(1; 1) to s and t
respectively. The graph 2 that we have also called No has just one arrow and two
nodes which are the source and target of the arrow, respectively, and so is the
graph represented by 1.

96
Solutions for section 5.5
2. There are two ways of dealing with this question and similar ones. We al-
ready have an explicit description of the subobject classi¯er in this category and
we could simply examine the set of nodes and set of arrows and see that their
subfunctors have the desired structure. However, there is an easier way, once we
know there is a subobject classi¯er. For the set of subobjects of the graph No is
Hom(No; -) which, in turn, is isomorphic by the preceding problem, to the set of
nodes of -. Similarly, the set of subobjects of the graph Ar is Hom(Ar; -), which
is the set of arrows of -.
3. Let NT(F; G) denote the set of natural transformations between functors F
and G. The Yoneda lemma implies that if [M ¡! N] = F, then
»
»
F(X)
NT(Hom(¡; X);F)
NT(Hom(¡;X);[M ¡! N])
=
=
» NT(Hom(¡; X) £ M; N)
=
4. We have that
»
»
Sub(Hom(¡; X))
NT(Hom(¡; X);-)
-(X)
=
=
the latter by the Yoneda Lemma.
Section 5.5
W
1. a. Let C = fc 2
j a ^ c · bg. Then a ) b =
c. Then
c2C
_
_
a ^ (a ) b) = a ^
c =
(a ^ c) · b
c2C
c2C
since a join of elements less than b is also less than b. Therefore, if c · a ) b then
a ^ c · b. On the other hand, if a ^ c · b, then c 2 C so that c · a ) b.
b. The fact that a · b ^ c if and only if a · b and a · c means that when
the Heyting algebra is considered as a category, Hom(a; b ^ c) = Hom(a; b) £
Hom(a; c). This means that b ^ c is the categorical product of b and c. But then
a ^ c · b if and only if c · a ) b means that Hom(a £ c; b) = Hom(c; a ) b),
which means that a ) b is the internal hom.

Bibliography
At the end of each entry, the pages on which that entry is cited are listed in parentheses.
Ad¶amek, J. and J. Rosi·cky (1994). Locally Presentable and Accessible Categories. Cam-
bridge University Press.
(12, 13, 25)
Asperti, A. and S. Martini (1992). `Categorical models of polymorphism'. Information
and Computation, volume 99, pages 1{79.
(43)
Bagchi, A. and C. Wells (1994). `Graph-based logic and sketches I: The general frame-
work'. Available by gopher from the site gopher.cwru.edu, path=/class/mans/
math/pub/wells/.
(24, 25)
Barr, M. and C. Wells (1985). Toposes, Triples and Theories, volume 278 of Grundlehren
der mathematischen Wissenschaften. Springer-Verlag, New York. A list of correc-
tions and additions is maintained in [Barr and Wells, 1993].
(16, 20, 22, 24, 25, 57,
59, 60, 61, 62, 66, 68)
Barr, M. and C. Wells (1994).
`The categorical theory generated by a limit sketch'.
Available by gopher from the site gopher.cwru.edu, path=/class/mans/math/
pub/wells/.
(20, 25)
Barr, M., C. McLarty, and C. Wells (1985). `Variable set theory'.
Technical report,
McGill University.
(72)
Barr, M. (1986). `Fuzzy sets and topos theory'. Canadian Math. Bull., volume 24, pages
501{508.
(72)
Barr, M. (1986). `Models of sketches'. Cahiers de Topologie et G¶eom¶etrie Diff¶erentielle
Cat¶egorique, volume 27, pages 93{107.
(17)
Barr, M. (1989). `Models of Horn theories'. Contemporary Mathematics, volume 92,
pages 1{7.
(12)
Bastiani, A. and C. Ehresmann (1972). `Categories of sketched structures'. Cahiers de
Topologie et G¶eom¶etrie Diff¶erentielle, volume 13, pages 104{213.
(20, 25)
Bell, J. (1988). Toposes and Local Set Theories: An Introduction. Oxford Logic Guides.
Oxford University Press.
(57)
Boileau, A. and A. Joyal (1981). `La logique des topos'. Symbolic Logic, volume 46,
pages 6{16.
(57)
Carboni, A., P. Freyd, and A. Scedrov (1988). `A categorical approach to realizability
and polymorphic types'. In Mathematical Foundations of Programming Language
Semantics, M. Main, A. Melton, M. Mislove, and D. Schmidt, editors, volume 298
of Lecture Notes in Computer Science, pages 23{42. Springer-Verlag.
(79)
Cartmell, J. (1986). `Generalized algebraic theories and contextual categories'. Annals
Pure Applied Logic, volume 32, pages 209{243.
(13)
Cockett, J. R. B. and D. Spencer (1992). `Strong categorical datatypes i'. In Category
Theory 1991, R. Seely, editor. American Mathematical Society.
(41)
97

98
Bibliography
Coquand, T. and G. Huet (1988).
`The calculus of constructions'.
Information and
Computation, volume 76, pages 95{120.
(43)
Coquand, T. (1988). `Categories of embeddings'. In Proceedings of the Third Annual
Symposium on Logic in Computer Science, Edinburgh, 1988, pages 256{263. Com-
puter Society Press and IEEE.
(43)
Coste, M. (1976). `Une approche logique des th¶eories d¶e¯nissables par limites projectives
¯nies'. In S¶eminaire B¶enabou. Universit¶e Paris-Nord.
(13)
Duval, D. and J.-C. Reynaud (1994). `Sketches and computation (1)'. Mathematical
Structures in Computer Science, volume 4.
(9)
Duval, D. and J.-C. Reynaud (1994). `Sketches and computation (2)'. Mathematical
Structures in Computer Science, volume 4.
(9)
Ehresmann, C. (1968). `Esquisses et types des structures alg¶ebriques'. Bul. Inst. Polit.
Ia»si, volume XIV.
(20, 25)
Ehrhard, T. (1988). `A categorical semantics of constructions'. In Proceedings of the
Third Annual Symposium on Logic in Computer Science, Edinburgh, 1988. Com-
puter Society Press and IEEE.
(43)
Ehrig, H., H. Kreowski, J. Thatcher, E. Wagner, and J. Wright (1984). `Parameter pass-
ing in algebraic speci¯cation languages'. Theoretical Computer Science, volume 28,
pages 45{81.
(31)
Eilenberg, S. (1976).
Automata, Languages and Machines, Vol. B.
Academic Press.
(55)
Fourman, M. and S. Vickers (1986). `Theories as categories'. In Category Theory and
Computer Programming, D. Pitt, S. Abramsky, A. Poign¶e, and D. Rydeheard, ed-
itors, volume 240 of Lecture Notes in Computer Science, pages 434{448. Springer-
Verlag.
(57)
Fourman, M. (1977). `The logic of topoi'. In Handbook of Mathematical Logic, J. Barwise
et al., editors. North-Holland.
(57)
Freyd, P. and A. Scedrov (1990). Categories, Allegories, volume 39 of North-Holland
Mathematical Library. North-Holland.
(57)
Gabriel, P. and F. Ulmer (1971). Lokal PrÄasentierbare Kategorien, volume 221 of Lecture
Notes in Mathematics. Springer-Verlag.
(13)
Goguen, J. A. and R. M. Burstall (1986). `A study in the foundations of programming
methodology: Speci¯cations, institutions, charters and parchments'.
In Category
Theory and Computer Programming, D. Pitt, S. Abramsky, A. Poign¶e, and D. Ryde-
heard, editors, volume 240 of Lecture Notes in Computer Science, pages 313{333.
Springer-Verlag.
(36)
Goguen, J. A. (1974). `Concept representation in natural and arti¯cial languages: Ax-
ioms, extensions and applications for fuzzy sets'.
Int. J. Man-machine Studies,
volume 6, pages 513{564.
(73)
Gray, J. W. (1966). `Fibred and co¯bred categories'. In Proc. La Jolla Conference on
Categorical Algebra, S. Eilenberg et al., editors. Springer-Verlag.
(51)
Gray, J. W. (1989). `The category of sketches as a model for algebraic semantics'. In
Categories in Computer Science and Logic, J. W. Gray and A. Scedrov, editors,
volume 92 of Contemporary Mathematics, pages 109{135. American Mathematical
Society.
(26, 31)

Bibliography
99
Gray, J. W. (1991). `Products in PER: an elementary treatment of the semantics of
the polymorphic lambda calculus'. In Category Theory at Work (Bremen, 1990),
volume 18 of Res. Exp. Math., pages 325{340. Heldermann.
(79)
Guitart, R. and C. Lair (1981). `Existence de diagrammes localement libres 1'. Diagram-
mes, volume 6.
(22)
Guitart, R. and C. Lair (1982). `Existence de diagrammes localement libres 2'. Diagram-
mes, volume 7.
(22)
Hyland, J. and A. Pitts (1989).
`The theory of constructions: Categorical semantics
and topos-theoretic models'. In Categories in Computer Science and Logic, J. Gray
and A. Scedrov, editors, volume 92 of Contemporary Mathematics, pages 137{199.
American Mathematical Society.
(43, 57)
Hyland, J. (1982). `The e®ective topos'. In The L.E.J. Brouwer Centenary Symposium,
pages 165{216. North-Holland.
(57, 80)
Johnstone, P. T. and R. Par¶e (1978). Indexed Categories and their Applications. Lecture
Notes in Mathematics. Springer-Verlag.
(41)
Johnstone, P. T. (1977). Topos Theory. Academic Press.
(57, 60, 61, 63, 68)
Kelly, G. (1974).
`On clubs and doctrines'.
In Proceedings Sydney Category Theory
Seminar 1972/1973, G. Kelly, editor, volume 420 of Lecture Notes in Mathematics.
Springer-Verlag.
(54)
Kelly, G. (1982). `On the essentially-algebraic theory generated by a sketch'. Bulletin of
the Australian Mathematical Society, volume 26, pages 45{56.
(25)
Lair, C. (1987). `Trames et semantiques cat¶egoriques des systµemes de trames'. Diagram-
mes, volume 18.
(25)
Lambek, J. and P. Scott (1986). Introduction to Higher Order Categorical Logic, volume 7
of Cambridge Studies in Advanced Mathematics. Cambridge University Press.
(57)
Lawvere, F. (1966). `The category of categories as a foundations for mathematics'. In
Proceedings of the Conference on Categorial Algebra at La Jolla. Springer-Verlag.
(16)
Lewis, H. R. and C. H. Papadimitriou (1981). Elements of the Theory of Computation.
Prentice-Hall.
(56)
Mac Lane, S. and I. Moerdijk (1992). Sheaves in Geometry and Logic. Universitext.
Springer-Verlag.
(57, 67, 68)
Makkai, M. and R. Par¶e (1990). Accessible Categories: the Foundations of Categorical
Model Theory, volume 104 of Contemporary Mathematics. American Mathematical
Society.
(25)
Makkai, M. and G. Reyes (1977). First Order Categorical Logic, volume 611 of Lecture
Notes in Mathematics. Springer-Verlag.
(57)
Makkai, M. (1994). `Generalized sketches as a framework for completeness theorems'.
To appear in Journal of Pure and Applied Algebra.
(25)
McLarty, C. (1986). `Left exact logic'. J. Pure Applied Algebra, volume 41, pages 63{66.
(13, 37)
McLarty, C. (1992). Elementary Categories, Elementary Toposes, volume 21 of Oxford
Logic Guides. Clarendon Press.
(57, 60, 61, 63, 68)
Mikkelson, C. (1976). Lattice Theoretic and Logical Aspects of Elementary Topoi, vol-
ume 25 of Aarhus University Various Publications Series. Aarhus University.
(62)

100
Bibliography
Nico, W. (1983). `Wreath products and extensions'. Houston J. Math., volume 9, pages
71{99.
(51, 55)
Peake, E. J. and G. R. Peters (1972). `Extension of algebraic theories'. Proceedings of
the American Mathematical Society, volume 32, pages 358{362.
(25)
Pitts, A. (1982). `Fuzzy sets do not form a topos'. Fuzzy Sets and Systems, volume 8,
pages 101{104.
(72)
Power, A. and C. Wells (1992). `A formalism for the speci¯cation of essentially algebraic
structures in 2-categories'. Mathematical Structures in Computer Science, volume 2,
pages 1{28.
(25)
Reichel, H. (1987). Initial Computability, Algebraic Speci¯cations and Partial Algebras.
Clarendon Press.
(13)
Rhodes, J. and B. Tilson (1989).
`The kernel of monoid homomorphisms'.
J. Pure
Applied Algebra, volume 62, pages 227{268.
(53, 55)
Rhodes, J. and P. Weil (1989). `Decomposition techniques for ¯nite semigroups i, ii'. J.
Pure Applied Algebra, volume 62, pages 269{284.
(55)
Rosebrugh, R. and R. Wood (1992). `Relational databases and indexed categories'. In
Category Theory 1991, R. Seely, editor. American Mathematical Society.
(41)
Rosolini, G. (1987). `Categories and e®ective computation'. In Category Theory and
Computer Science, volume 283 of Lecture Notes in Computer Science. Springer-Ver-
lag.
(80)
Rosolini, G. (1990).
`About modest sets.'.
International Journal of Foundations of
Computer Science, volume 3, pages 341{353.
(79)
Street, R. and R. Walters (1973). `The comprehensive factorization of a functor'. Bull.
Amer. Math. Soc., volume 79, pages 936{941.
(55)
Tarlecki, A., R. M. Burstall, and J. A. Goguen (1991). `Some fundamental algebraic tools
for the semantics of computation III: Indexed categories'.
Theoretical Computer
Science, volume 91, pages 239{264.
(41)
Taylor, P. (1989). `Quantitative domains, groupoids and linear logic'. In Category Theory
and Computer Science, D. Pitt, D. Rydeheard, P. Dybjer, A. Pitts, and A. Poign¶e,
editors, volume 389 of Lecture Notes in Computer Science. Springer-Verlag.
(66)
Thatcher, J., E. Wagner, and J. Wright (1982). `Data type speci¯cation: Parametrization
and the power of speci¯cation techniques'.
ACM Transactions of Programming
Languages and Systems, volume 4, pages 711{732.
(31)
Vickers, S. (1992). `Geometric theories and databases'. In Applications of Categories in
Computer Science (Durham, 1991), volume 177 of London Math. Soc. Lecture Note
Series, pages 288{314. Cambridge Univ. Press.
(57)
Volger, H. (1987). `On theories which admit initial structures'. Technical report, Uni-
versitÄat Passau.
(17)
Volger, H. (1988). `Model theory of deductive databases'. In CSL '87. First Workshop
on Computer Science Logic. Proceedings, volume 329 of Lecture Notes in Computer
Science. Springer-Verlag.
(17)
Wagner, E. (1986). `Categories, data types and imperative languages'. In Category The-
ory and Computer Programming, D. Pitt, S. Abramsky, A. Poign¶e, and D. Ryde-
heard, editors, volume 240 of Lecture Notes in Computer Science, pages 143{162.
Springer-Verlag.
(31)

Bibliography
101
Wells, C. (1976). `Some applications of the wreath product construction'. Amer. Math.
Monthly, volume 83, pages 317{338.
(55)
Wells, C. (1980). `A Krohn-Rhodes theorem for categories'. J. Algebra, volume 64, pages
37{45.
(55)
Wells, C. (1988a).
`Wreath product decomposition of categories I'.
Acta Sci. Math.
Szeged, volume 52, pages 307{319.
(55)
Wells, C. (1988b). `Wreath product decomposition of categories II'. Acta Sci. Math.
Szeged, volume 52, pages 321{324.
(55)
Wells, C. (1990).
`A generalization of the concept of sketch'.
Theoretical Computer
Science, volume 70, pages 159{178.
(24, 25)

Index
accessible category
25
e®ective equivalence relation
61
action
45
e®ective topos
80
arrow between fuzzy sets
72
empty set
73
arrow category
40
equivalence of categories
48
equivalence relation
60
base category (of a ¯bration)
39
external functor
76
base category (of an op¯bration)
45
binary tree
18, 30
FD sketch
1
Boolean algebra
3
¯ber
40
¯bration
39
carrier
80
¯bration as generalized product
41
cartesian arrow
38
¯eld
3, 8
cartesian closed
58
¯nite cone
12
category
14
¯nite discrete sketch
1
category object
14, 75
¯nite limit sketch
12
category of fuzzy sets
72
FL sketch
12
category of models
33
°at CPO
65
characteristic arrow
59
functor category
48
cleavage
39
functor induced by a sketch
cocone
1
homomorphism
33
colimit
62
fuzzy set
72
compatible family
17
complemented subobject
65
graph
66
complete Heyting algebra
68
Grothendieck construction
43, 76
confusion
8
Grothendieck topology
67
constant
69
groupoid
16
crisp
74
crossed product
47
homomorphism of models
22
homomorphism of sketches
26
derived category
55
homomorphism of split op¯brations
discrete op¯bration
45
49
discrete wreath product
53
disjoint sum
62
idempotent
20
disjoint union
43
image
26
division
55
indexed set
41
domain of a partial arrow
62
d½mon
6
initial algebra
5
102

Index
103
initial model
5
realizability set
80
initial term algebra
16
realizability topos
80
initial term model
16
record type
30
initial topos
62
recursive function
62
internal functor
75
recursive set
64
internal language
64
recursively enumerable
64
regular category
62
junk
8
regular cocone
22
regular epimorphism
22, 62
kernel category
55
regular sketch
22
kernel pair
23, 61
restriction functions
67
Krohn-Rhodes Theorem
55
right regular representation
53
LE sketches
12
satisfy
36
left exact sketches
12
semantics
57, 64
lies over
39
semidirect product
46
list
1
semigroup
20
locally cartesian closed
60
sentence
36
locally presentable category
13
set-valued functor
66
shape functor
52
model of a sketch
22, 33
sheaf
68
model of an FD sketch
1
simple graph
14
model of an FL sketch
12
sketch
1, 22, 26
modest set
81
sketch for categories
14
monoid action
55
sketch for semigroups
20
slice category
41
natural numbers
2, 8, 29
small category
14
nearly constant presheaf
69
split ¯bration
39
notational conventions for sketches
13
split op¯bration
45, 76
splitting
39
opcartesian
39
stack
28
op¯bration
39, 46, 76
standard wreath product
53
state transition system
55
P-valued set
72
structure type
30
parallel pair
21
subobject
57
partial arrow
62
subobject classi¯er
59
partial arrows representable
62
subobject functor
57, 58
partial equivalence relation
81
PER
81
theory of an FL sketch
19
power object
60
topos
58
powerset
60
total category
39
presheaf
66
total order
16
product category
40
tree
9
programming language
70
projection functor
53
triangular action
54

104
Index
true (from 1 to -)
59
variable element
64
universal image
60
universal model
19
universal sum
62
wreath product
52

