
CAMBRIDGE MONOGRAPHS ON
APPLIED AND COMPUTATIONAL
MATHEMATICS
Series Editors
M. ABLOWITZ, S. DAVIS, J. HINCH,
A. ISERLES, J. OCKENDON, P. OLVER
18
Modern Computer Arithmetic

The Cambridge Monographs on Applied and Computational Mathematics series reﬂects
the crucial role of mathematical and computational techniques in contemporary science.
The series publishes expositions on all aspects of applicable and numerical mathemat-
ics, with an emphasis on new developments in this fast-moving area of research.
State-of-the-art methods and algorithms as well as modern mathematical descriptions
of physical and mechanical ideas are presented in a manner suited to graduate research
students and professionals alike. Sound pedagogical presentation is a prerequisite. It is
intended that books in the series will serve to inform a new generation of researchers.
A complete list of books in the series can be found at
http://www.cambridge.org/uk/series/sSeries.asp?code=MACM
Recent titles include the following:
6. The theory of composites, Graeme W. Milton
7. Geometry and topology for mesh generation, Herbert Edelsbrunner
8. Schwarz–Christoffel mapping, Tobin A. Driscoll & Lloyd N. Trefethen
9. High-order methods for incompressible ﬂuid ﬂow, M. O. Deville, P. F. Fischer &
E. H. Mund
10. Practical extrapolation methods, Avram Sidi
11. Generalized Riemann problems in computational ﬂuid dynamics, Matania
Ben-Artzi & Joseph Falcovitz
12. Radial basis functions, Martin D. Buhmann
13. Iterative Krylov methods for large linear systems, Henk van der Vorst
14. Simulating Hamiltonian dynamics, Benedict Leimkuhler & Sebastian Reich
15. Collocation methods for Volterra integral and related functional differential
equations, Hermann Brunner
16. Topology for computing, Afra J. Zomorodian
17. Scattered data approximation, Holger Wendland
18. Modern computer arithmetic, Richard P. Brent & Paul Zimmermann
19. Matrix preconditioning techniques and applications, Ke Chen
21. Spectral methods for time-dependent problems, Jan Hesthaven, Sigal Gottlieb &
David Gottlieb
22. The mathematical foundations of mixing, Rob Sturman, Julio M. Ottino &
Stephen Wiggins
23. Curve and surface reconstruction, Tamal K. Dey
24. Learning theory, Felipe Cucker & Ding Xuan Zhou
25. Algebraic geometry and statistical learning theory, Sumio Watanabe
26. A practical guide to the invariant calculus, Elizabeth Louise Mansﬁeld

Modern Computer Arithmetic
RICHARD P. BRENT
Australian National University, Canberra
PAUL ZIMMERMANN
INRIA, Nancy

C A M B R I D G E U N I V E R S I T Y P R E S S
Cambridge, New York, Melbourne, Madrid, Cape Town, Singapore,
S˜ao Paulo, Delhi, Dubai, Tokyo, Mexico City
Cambridge University Press
The Edinburgh Building, Cambridge CB2 8RU, UK
Published in the United States of America by Cambridge University Press, New York
www.cambridge.org
Information on this title: www.cambridge.org/9780521194693
c⃝R. Brent and P. Zimmermann 2011
This publication is in copyright. Subject to statutory exception
and to the provisions of relevant collective licensing agreements,
no reproduction of any part may take place without the written
permission of Cambridge University Press.
First published 2011
Printed in the United Kingdom at the University Press, Cambridge
A catalogue record for this publication is available from the British Library
Library of Congress Cataloguing in Publication data
ISBN 978-0-521-19469-3 Hardback
Cambridge University Press has no responsibility for the persistence or
accuracy of URLs for external or third-party internet websites referred to
in this publication, and does not guarantee that any content on such
websites is, or will remain, accurate or appropriate.

Contents
Preface
page ix
Acknowledgements
xi
Notation
xiii
1
Integer arithmetic
1
1.1
Representation and notations
1
1.2
Addition and subtraction
2
1.3
Multiplication
3
1.3.1
Naive multiplication
4
1.3.2
Karatsuba’s algorithm
5
1.3.3
Toom–Cook multiplication
6
1.3.4
Use of the fast Fourier transform (FFT)
8
1.3.5
Unbalanced multiplication
8
1.3.6
Squaring
11
1.3.7
Multiplication by a constant
13
1.4
Division
14
1.4.1
Naive division
14
1.4.2
Divisor preconditioning
16
1.4.3
Divide and conquer division
18
1.4.4
Newton’s method
21
1.4.5
Exact division
21
1.4.6
Only quotient or remainder wanted
22
1.4.7
Division by a single word
23
1.4.8
Hensel’s division
24
1.5
Roots
25
1.5.1
Square root
25
1.5.2
kth root
27
1.5.3
Exact root
28

vi
Contents
1.6
Greatest common divisor
29
1.6.1
Naive GCD
29
1.6.2
Extended GCD
32
1.6.3
Half binary GCD, divide and conquer GCD
33
1.7
Base conversion
37
1.7.1
Quadratic algorithms
37
1.7.2
Subquadratic algorithms
38
1.8
Exercises
39
1.9
Notes and references
44
2
Modular arithmetic and the FFT
47
2.1
Representation
47
2.1.1
Classical representation
47
2.1.2
Montgomery’s form
48
2.1.3
Residue number systems
48
2.1.4
MSB vs LSB algorithms
49
2.1.5
Link with polynomials
49
2.2
Modular addition and subtraction
50
2.3
The Fourier transform
50
2.3.1
Theoretical setting
50
2.3.2
The fast Fourier transform
51
2.3.3
The Sch¨onhage–Strassen algorithm
55
2.4
Modular multiplication
58
2.4.1
Barrett’s algorithm
58
2.4.2
Montgomery’s multiplication
60
2.4.3
McLaughlin’s algorithm
63
2.4.4
Special moduli
65
2.5
Modular division and inversion
65
2.5.1
Several inversions at once
67
2.6
Modular exponentiation
68
2.6.1
Binary exponentiation
70
2.6.2
Exponentiation with a larger base
70
2.6.3
Sliding window and redundant representation
72
2.7
Chinese remainder theorem
73
2.8
Exercises
75
2.9
Notes and references
77
3
Floating-point arithmetic
79
3.1
Representation
79
3.1.1
Radix choice
80
3.1.2
Exponent range
81

Contents
vii
3.1.3
Special values
82
3.1.4
Subnormal numbers
82
3.1.5
Encoding
83
3.1.6
Precision: local, global, operation, operand
84
3.1.7
Link to integers
86
3.1.8
Ziv’s algorithm and error analysis
86
3.1.9
Rounding
87
3.1.10
Strategies
90
3.2
Addition, subtraction, comparison
91
3.2.1
Floating-point addition
92
3.2.2
Floating-point subtraction
93
3.3
Multiplication
95
3.3.1
Integer multiplication via complex FFT
98
3.3.2
The middle product
99
3.4
Reciprocal and division
101
3.4.1
Reciprocal
102
3.4.2
Division
106
3.5
Square root
111
3.5.1
Reciprocal square root
112
3.6
Conversion
114
3.6.1
Floating-point output
115
3.6.2
Floating-point input
117
3.7
Exercises
118
3.8
Notes and references
120
4
Elementary and special function evaluation
125
4.1
Introduction
125
4.2
Newton’s method
126
4.2.1
Newton’s method for inverse roots
127
4.2.2
Newton’s method for reciprocals
128
4.2.3
Newton’s method for (reciprocal) square roots
129
4.2.4
Newton’s method for formal power series
129
4.2.5
Newton’s method for functional inverses
130
4.2.6
Higher-order Newton-like methods
131
4.3
Argument reduction
132
4.3.1
Repeated use of a doubling formula
134
4.3.2
Loss of precision
134
4.3.3
Guard digits
135
4.3.4
Doubling versus tripling
136
4.4
Power series
136

viii
Contents
4.4.1
Direct power series evaluation
140
4.4.2
Power series with argument reduction
140
4.4.3
Rectangular series splitting
141
4.5
Asymptotic expansions
144
4.6
Continued fractions
150
4.7
Recurrence relations
152
4.7.1
Evaluation of Bessel functions
153
4.7.2
Evaluation of Bernoulli and tangent numbers
154
4.8
Arithmetic-geometric mean
158
4.8.1
Elliptic integrals
158
4.8.2
First AGM algorithm for the logarithm
159
4.8.3
Theta functions
160
4.8.4
Second AGM algorithm for the logarithm
162
4.8.5
The complex AGM
163
4.9
Binary splitting
163
4.9.1
A binary splitting algorithm for sin, cos
166
4.9.2
The bit-burst algorithm
167
4.10
Contour integration
169
4.11
Exercises
171
4.12
Notes and references
179
5
Implementations and pointers
185
5.1
Software tools
185
5.1.1
CLN
185
5.1.2
GNU MP (GMP)
185
5.1.3
MPFQ
186
5.1.4
GNU MPFR
187
5.1.5
Other multiple-precision packages
187
5.1.6
Computational algebra packages
188
5.2
Mailing lists
189
5.2.1
The GMP lists
189
5.2.2
The MPFR list
190
5.3
On-line documents
190
References
191
Index
207

Preface
This is a book about algorithms for performing arithmetic, and their imple-
mentation on modern computers. We are concerned with software more than
hardware – we do not cover computer architecture or the design of computer
hardware since good books are already available on these topics. Instead, we
focus on algorithms for efﬁciently performing arithmetic operations such as
addition, multiplication, and division, and their connections to topics such
as modular arithmetic, greatest common divisors, the fast Fourier transform
(FFT), and the computation of special functions.
The algorithms that we present are mainly intended for arbitrary-precision
arithmetic. That is, they are not limited by the computer wordsize of 32 or 64
bits, only by the memory and time available for the computation. We consider
both integer and real (ﬂoating-point) computations.
The book is divided into four main chapters, plus one short chapter (essen-
tially an appendix). Chapter 1 covers integer arithmetic. This has, of course,
been considered in many other books and papers. However, there has been
much recent progress, inspired in part by the application to public key cryp-
tography, so most of the published books are now partly out of date or incom-
plete. Our aim is to present the latest developments in a concise manner. At the
same time, we provide a self-contained introduction for the reader who is not
an expert in the ﬁeld.
Chapter 2 is concerned with modular arithmetic and the FFT, and their appli-
cations to computer arithmetic. We consider different number representations,
fast algorithms for multiplication, division and exponentiation, and the use of
the Chinese remainder theorem (CRT).
Chapter 3 covers ﬂoating-point arithmetic. Our concern is with high-
precision ﬂoating-point arithmetic, implemented in software if the precision
provided by the hardware (typically IEEE standard 53-bit signiﬁcand) is

x
Preface
inadequate. The algorithms described in this chapter focus on correct round-
ing, extending the IEEE standard to arbitrary precision.
Chapter 4 deals with the computation, to arbitrary precision, of functions
such as sqrt, exp, ln, sin, cos, and more generally functions deﬁned by power
series or continued fractions. Of course, the computation of special functions is
a huge topic so we have had to be selective. In particular, we have concentrated
on methods that are efﬁcient and suitable for arbitrary-precision computations.
The last chapter contains pointers to implementations, useful web sites,
mailing lists, and so on. Finally, at the end there is a one-page Summary of
complexities which should be a useful aide-m´emoire.
The chapters are fairly self-contained, so it is possible to read them out of
order. For example, Chapter 4 could be read before Chapters 1–3, and Chap-
ter 5 can be consulted at any time. Some topics, such as Newton’s method,
appear in different guises in several chapters. Cross-references are given where
appropriate.
For details that are omitted, we give pointers in the Notes and references
sections of each chapter, as well as in the bibliography. We have tried, as far
as possible, to keep the main text uncluttered by footnotes and references, so
most references are given in the Notes and references sections.
The book is intended for anyone interested in the design and implementation
of efﬁcient algorithms for computer arithmetic, and more generally efﬁcient
numerical algorithms. We did our best to present algorithms that are ready to
implement in your favorite language, while keeping a high-level description
and not getting too involved in low-level or machine-dependent details. An
alphabetical list of algorithms can be found in the index.
Although the book is not speciﬁcally intended as a textbook, it could be
used in a graduate course in mathematics or computer science, and for this
reason, as well as to cover topics that could not be discussed at length in the
text, we have included exercises at the end of each chapter. The exercises vary
considerably in difﬁculty, from easy to small research projects, but we have
not attempted to assign them a numerical rating. For solutions to the exercises,
please contact the authors.
We welcome comments and corrections. Please send them to either of the
authors.
Richard Brent and Paul Zimmermann
Canberra and Nancy
MCA@rpbrent.com
Paul.Zimmermann@inria.fr

Acknowledgements
We thank the French National Institute for Research in Computer Science and
Control (INRIA), the Australian National University (ANU), and the Aus-
tralian Research Council (ARC), for their support. The book could not have
been written without the contributions of many friends and colleagues, too nu-
merous to mention here, but acknowledged in the text and in the Notes and
references sections at the end of each chapter.
We also thank those who have sent us comments on and corrections to ear-
lier versions of this book: J¨org Arndt, Marco Bodrato, Wolfgang Ehrhardt
(with special thanks), Steven Galbraith, Torbj¨orn Granlund, Guillaume Han-
rot, Marc Mezzarobba, Jean-Michel Muller, Denis Roegel, Wolfgang Schmid,
Arnold Sch¨onhage, Sidi Mohamed Sedjelmaci, Emmanuel Thom´e, and Mark
Wezelenburg. Two anonymous reviewers provided very helpful suggestions.
J´er´emie Detrey and Anne Rix helped us in the copy-editing phase.
The Mathematics Genealogy Project (http://www.genealogy.ams.
org/) and Don Knuth’s The Art of Computer Programming [142] were useful
resources for details of entries in the index.
We also thank the authors of the LATEX program, which allowed us to pro-
duce this book, the authors of the gnuplot program, and the authors of the
GNU MP library, which helped us to illustrate several algorithms with concrete
ﬁgures.
Finally, we acknowledge the contribution of Erin Brent, who ﬁrst suggested
writing the book; and thank our wives, Judy-anne and Marie, for their patience
and encouragement.


Notation
C
set of complex numbers
bC
set of extended complex numbers C ∪{∞}
N
set of natural numbers (nonnegative integers)
N∗
set of positive integers N\{0}
Q
set of rational numbers
R
set of real numbers
Z
set of integers
Z/nZ
ring of residues modulo n
Cn
set of (real or complex) functions with n continuous derivatives
in the region of interest
ℜ(z)
real part of a complex number z
ℑ(z)
imaginary part of a complex number z
¯z
conjugate of a complex number z
|z|
Euclidean norm of a complex number z,
or absolute value of a scalar z
Bn
Bernoulli numbers, P
n≥0 Bnzn/n! = z/(ez −1)
Cn
scaled Bernoulli numbers, Cn = B2n/(2n)! ,
P Cnz2n = (z/2)/ tanh(z/2)
Tn
tangent numbers, P Tnz2n−1/(2n −1)! = tan z
Hn
harmonic number Pn
j=1 1/j
(0 if n ≤0)
¡n
k
¢
binomial coefﬁcient “n choose k” = n!/(k! (n −k)!)
(0 if k < 0 or k > n)

xiv
Notation
β
“word” base (usually 232 or 264) or “radix” (ﬂoating-point)
n
“precision”: number of base β digits in an integer or in a
ﬂoating-point signiﬁcand, or a free variable
ε
“machine precision” β1−n/2 or (in complexity bounds)
an arbitrarily small positive constant
η
smallest positive subnormal number
◦(x), ◦n(x)
rounding of real number x in precision n (Deﬁnition 3.1)
ulp(x)
for a ﬂoating-point number x, one unit in the last place
M(n)
time to multiply n-bit integers, or polynomials of
degree n −1, depending on the context
∼M(n)
a function f(n) such that f(n)/M(n) →1 as n →∞
(we sometimes lazily omit the “∼” if the meaning is clear)
M(m, n)
time to multiply an m-bit integer by an n-bit integer
D(n)
time to divide a 2n-bit integer by an n-bit integer,
giving quotient and remainder
D(m, n)
time to divide an m-bit integer by an n-bit integer,
giving quotient and remainder
a|b
a is a divisor of b, that is b = ka for some k ∈Z
a = b mod m
modular equality, m|(a −b)
q ←a div b
assignment of integer quotient to q (0 ≤a −qb < b)
r ←a mod b
assignment of integer remainder to r (0 ≤r = a −qb < b)
(a, b)
greatest common divisor of a and b
¡ a
b
¢
or (a|b)
Jacobi symbol (b odd and positive)
iff
if and only if
i ∧j
bitwise and of integers i and j,
or logical and of two Boolean expressions
i ∨j
bitwise or of integers i and j,
or logical or of two Boolean expressions
i ⊕j
bitwise exclusive-or of integers i and j
i ≪k
integer i multiplied by 2k
i ≫k
quotient of division of integer i by 2k
a · b, a × b
product of scalars a, b
a ∗b
cyclic convolution of vectors a, b
ν(n)
2-valuation: largest k such that 2k divides n (ν(0) = ∞)
σ(e)
length of the shortest addition chain to compute e
φ(n)
Euler’s totient function, #{m : 0 < m ≤n ∧(m, n) = 1}

Notation
xv
deg(A)
for a polynomial A, the degree of A
ord(A)
for a power series A = P
j ajzj,
ord(A) = min{j : aj ̸= 0} (ord(0) = +∞)
exp(x) or ex
exponential function
ln(x)
natural logarithm
logb(x)
base-b logarithm ln(x)/ ln(b)
lg(x)
base-2 logarithm ln(x)/ ln(2) = log2(x)
log(x)
logarithm to any ﬁxed base
logk(x)
(log x)k
⌈x⌉
ceiling function, min{n ∈Z : n ≥x}
⌊x⌋
ﬂoor function, max{n ∈Z : n ≤x}
⌊x⌉
nearest integer function, ⌊x + 1/2⌋
sign(n)
+1 if n > 0, −1 if n < 0, and 0 if n = 0
nbits(n)
⌊lg(n)⌋+ 1 if n > 0, 0 if n = 0
[a, b]
closed interval {x ∈R : a ≤x ≤b} (empty if a > b)
(a, b)
open interval {x ∈R : a < x < b} (empty if a ≥b)
[a, b), (a, b]
half-open intervals, a ≤x < b, a < x ≤b respectively
t[a, b] or [a, b]t
column vector
µ a
b
¶
[a, b; c, d]
2 × 2 matrix
µ a
b
c
d
¶
baj
element of the (forward) Fourier transform of vector a
eaj
element of the backward Fourier transform of vector a
f(n) = O(g(n))
∃c, n0 such that |f(n)| ≤cg(n) for all n ≥n0
f(n) = Ω(g(n))
∃c > 0, n0 such that |f(n)| ≥cg(n) for all n ≥n0
f(n) = Θ(g(n))
f(n) = O(g(n)) and g(n) = O(f(n))
f(n) ∼g(n)
f(n)/g(n) →1 as n →∞
f(n) = o(g(n))
f(n)/g(n) →0 as n →∞
f(n) ≪g(n)
f(n) = O(g(n))
f(n) ≫g(n)
g(n) ≪f(n)
f(x) ∼Pn
0 aj/xj
f(x) −Pn
0 aj/xj = o(1/xn) as x →+∞
123 456 789
123456789 (for large integers, we may use a space after
every third digit)

xvi
Notation
xxx.yyyρ
a number xxx.yyy written in base ρ;
for example, the decimal number 3.25 is 11.012 in binary
a
b+
c
d+
e
f+ · · ·
continued fraction a/(b + c/(d + e/(f + · · · )))
|A|
determinant of a matrix A, e.g.
¯¯¯¯
a
b
c
d
¯¯¯¯ = ad −bc
PV
R b
a f(x) dx
Cauchy principal value integral, deﬁned by a limit
if f has a singularity in (a, b)
s || t
concatenation of strings s and t
⊲<text>
comment in an algorithm
end of a proof

1
Integer arithmetic
In this chapter, our main topic is integer arithmetic. However, we
shall see that many algorithms for polynomial arithmetic are sim-
ilar to the corresponding algorithms for integer arithmetic, but
simpler due to the lack of carries in polynomial arithmetic. Con-
sider for example addition: the sum of two polynomials of degree
n always has degree at most n, whereas the sum of two n-digit in-
tegers may have n + 1 digits. Thus, we often describe algorithms
for polynomials as an aid to understanding the corresponding
algorithms for integers.
1.1 Representation and notations
We consider in this chapter algorithms working on integers. We distinguish
between the logical – or mathematical – representation of an integer, and its
physical representation on a computer. Our algorithms are intended for “large”
integers – they are not restricted to integers that can be represented in a single
computer word.
Several physical representations are possible. We consider here only the
most common one, namely a dense representation in a ﬁxed base. Choose an
integral base β > 1. (In case of ambiguity, β will be called the internal base.)
A positive integer A is represented by the length n and the digits ai of its base
β expansion
A = an−1βn−1 + · · · + a1β + a0,
where 0 ≤ai ≤β −1, and an−1 is sometimes assumed to be non-zero.
Since the base β is usually ﬁxed in a given program, only the length n and
the integers (ai)0≤i<n need to be stored. Some common choices for β are
232 on a 32-bit computer, or 264 on a 64-bit machine; other possible choices

2
Integer arithmetic
are respectively 109 and 1019 for a decimal representation, or 253 when using
double-precision ﬂoating-point registers. Most algorithms given in this chapter
work in any base; the exceptions are explicitly mentioned.
We assume that the sign is stored separately from the absolute value. This
is known as the “sign-magnitude” representation. Zero is an important special
case; to simplify the algorithms we assume that n = 0 if A = 0, and we usually
assume that this case is treated separately.
Except when explicitly mentioned, we assume that all operations are off-line,
i.e. all inputs (resp. outputs) are completely known at the beginning (resp. end)
of the algorithm. Different models include lazy and relaxed algorithms, and
are discussed in the Notes and references (§1.9).
1.2 Addition and subtraction
As an explanatory example, here is an algorithm for integer addition. In the
algorithm, d is a carry bit.
Our algorithms are given in a language that mixes mathematical notation
and syntax similar to that found in many high-level computer languages. It
should be straightforward to translate into a language such as C. Note that
“:=” indicates a deﬁnition, and “←” indicates assignment. Line numbers are
included if we need to refer to individual lines in the description or analysis of
the algorithm.
Algorithm 1.1 IntegerAddition
Input: A = Pn−1
0
aiβi, B = Pn−1
0
biβi, carry-in 0 ≤din ≤1
Output: C := Pn−1
0
ciβi and 0 ≤d ≤1 such that A + B + din = dβn + C
1: d ←din
2: for i from 0 to n −1 do
3:
s ←ai + bi + d
4:
(d, ci) ←(s div β, s mod β)
5: return C, d.
Let T be the number of different values taken by the data type representing
the coefﬁcients ai, bi. (Clearly, β ≤T, but equality does not necessarily hold,
for example β = 109 and T = 232.) At step 3, the value of s can be as
large as 2β −1, which is not representable if β = T. Several workarounds
are possible: either use a machine instruction that gives the possible carry of
ai + bi, or use the fact that, if a carry occurs in ai + bi, then the computed

1.3 Multiplication
3
sum – if performed modulo T – equals t := ai +bi −T < ai; thus, comparing
t and ai will determine if a carry occurred. A third solution is to keep a bit in
reserve, taking β ≤T/2.
The subtraction code is very similar. Step 3 simply becomes s ←ai−bi+d,
where d ∈{−1, 0} is the borrow of the subtraction, and −β ≤s < β. The
other steps are unchanged, with the invariant A −B + din = dβn + C.
We use the arithmetic complexity model, where cost is measured by the
number of machine instructions performed, or equivalently (up to a constant
factor) the time on a single processor.
Addition and subtraction of n-word integers cost O(n), which is negligible
compared to the multiplication cost. However, it is worth trying to reduce the
constant factor implicit in this O(n) cost. We shall see in §1.3 that “fast” mul-
tiplication algorithms are obtained by replacing multiplications by additions
(usually more additions than the multiplications that they replace). Thus, the
faster the additions are, the smaller will be the thresholds for changing over to
the “fast” algorithms.
1.3 Multiplication
A nice application of large integer multiplication is the Kronecker–Sch¨onhage
trick, also called segmentation or substitution by some authors. Assume we
want to multiply two polynomials, A(x) and B(x), with non-negative integer
coefﬁcients (see Exercise 1.1 for negative coefﬁcients). Assume both polyno-
mials have degree less than n, and the coefﬁcients are bounded by ρ. Now take
a power X = βk > nρ2 of the base β, and multiply the integers a = A(X) and
b = B(X) obtained by evaluating A and B at x = X. If C(x) = A(x)B(x) =
P cixi, we clearly have C(X) = P ciXi. Now since the ci are bounded by
nρ2 < X, the coefﬁcients ci can be retrieved by simply “reading” blocks of k
words in C(X). Assume for example that we want to compute
(6x5 + 6x4 + 4x3 + 9x2 + x + 3)(7x4 + x3 + 2x2 + x + 7),
with degree less than n = 6, and coefﬁcients bounded by ρ = 9. We can take
X = 103 > nρ2, and perform the integer multiplication
6 006 004 009 001 003 × 7 001 002 001 007
= 42 048 046 085 072 086 042 070 010 021,
from which we can read off the product
42x9 + 48x8 + 46x7 + 85x6 + 72x5 + 86x4 + 42x3 + 70x2 + 10x + 21.

4
Integer arithmetic
Conversely, suppose we want to multiply two integers a = P
0≤i<n aiβi
and b = P
0≤j<n bjβj. Multiply the polynomials A(x) = P
0≤i<n aixi and
B(x) = P
0≤j<n bjxj, obtaining a polynomial C(x), then evaluate C(x) at
x = β to obtain ab. Note that the coefﬁcients of C(x) may be larger than β, in
fact they may be up to about nβ2. For example, with a = 123, b = 456, and
β = 10, we obtain A(x) = x2 + 2x + 3, B(x) = 4x2 + 5x + 6, with product
C(x) = 4x4 +13x3 +28x2 +27x+18, and C(10) = 56088. These examples
demonstrate the analogy between operations on polynomials and integers, and
also show the limits of the analogy.
A common and very useful notation is to let M(n) denote the time to mul-
tiply n-bit integers, or polynomials of degree n −1, depending on the context.
In the polynomial case, we assume that the cost of multiplying coefﬁcients is
constant; this is known as the arithmetic complexity model, whereas the bit
complexity model also takes into account the cost of multiplying coefﬁcients,
and thus their bit-size.
1.3.1 Naive multiplication
Algorithm 1.2 BasecaseMultiply
Input: A = Pm−1
0
aiβi, B = Pn−1
0
bjβj
Output: C = AB := Pm+n−1
0
ckβk
1: C ←A · b0
2: for j from 1 to n −1 do
3:
C ←C + βj(A · bj)
4: return C.
Theorem 1.1 Algorithm
BasecaseMultiply
computes
the
product
AB
correctly, and uses Θ(mn) word operations.
The multiplication by βj at step 3 is trivial with the chosen dense representa-
tion; it simply requires shifting by j words towards the most signiﬁcant words.
The main operation in Algorithm BasecaseMultiply is the computation of
A · bj and its accumulation into C at step 3. Since all fast algorithms rely on
multiplication, the most important operation to optimize in multiple-precision
software is thus the multiplication of an array of m words by one word, with
accumulation of the result in another array of m + 1 words.

1.3 Multiplication
5
We sometimes call Algorithm BasecaseMultiply schoolbook multiplication
since it is close to the “long multiplication” algorithm that used to be taught at
school.
Since multiplication with accumulation usually makes extensive use of the
pipeline, it is best to give it arrays that are as long as possible, which means
that A rather than B should be the operand of larger size (i.e. m ≥n).
1.3.2 Karatsuba’s algorithm
Karatsuba’s algorithm is a “divide and conquer” algorithm for multiplication
of integers (or polynomials). The idea is to reduce a multiplication of length n
to three multiplications of length n/2, plus some overhead that costs O(n).
In the following, n0 ≥2 denotes the threshold between naive multiplica-
tion and Karatsuba’s algorithm, which is used for n0-word and larger inputs.
The optimal “Karatsuba threshold” n0 can vary from about ten to about 100
words, depending on the processor and on the relative cost of multiplication
and addition (see Exercise 1.6).
Algorithm 1.3 KaratsubaMultiply
Input: A = Pn−1
0
aiβi, B = Pn−1
0
bjβj
Output: C = AB := P2n−1
0
ckβk
if n < n0 then return BasecaseMultiply(A, B)
k ←⌈n/2⌉
(A0, B0) := (A, B) mod βk, (A1, B1) := (A, B) div βk
sA ←sign(A0 −A1), sB ←sign(B0 −B1)
C0 ←KaratsubaMultiply(A0, B0)
C1 ←KaratsubaMultiply(A1, B1)
C2 ←KaratsubaMultiply(|A0 −A1|, |B0 −B1|)
return C := C0 + (C0 + C1 −sAsBC2)βk + C1β2k.
Theorem 1.2 Algorithm KaratsubaMultiply computes the product AB
correctly, using K(n) = O(nα) word multiplications, with α = lg 3 ≈1.585.
Proof. Since sA|A0 −A1| = A0 −A1 and sB|B0 −B1| = B0 −B1, we
have sAsB|A0 −A1||B0 −B1| = (A0 −A1)(B0 −B1), and thus C =
A0B0+(A0B1 + A1B0)βk + A1B1β2k.
Since A0, B0, |A0 −A1| and |B0 −B1| have (at most) ⌈n/2⌉words, and A1
and B1 have (at most) ⌊n/2⌋words, the number K(n) of word multiplications

6
Integer arithmetic
satisﬁes the recurrence K(n) = n2 for n < n0, and K(n) = 2K(⌈n/2⌉) +
K(⌊n/2⌋) for n ≥n0. Assume 2ℓ−1n0 < n ≤2ℓn0 with ℓ≥1. Then K(n)
is the sum of three K(j) values with j ≤2ℓ−1n0, so at most 3ℓK(j) with
j ≤n0. Thus, K(n) ≤3ℓmax(K(n0), (n0 −1)2), which gives K(n) ≤Cnα
with C = 31−lg(n0)max(K(n0), (n0 −1)2).
Different variants of Karatsuba’s algorithm exist; the variant presented here
is known as the subtractive version. Another classical one is the additive ver-
sion, which uses A0+A1 and B0+B1 instead of |A0−A1| and |B0−B1|. How-
ever, the subtractive version is more convenient for integer arithmetic, since it
avoids the possible carries in A0 + A1 and B0 + B1, which require either an
extra word in these sums, or extra additions.
The efﬁciency of an implementation of Karatsuba’s algorithm depends heav-
ily on memory usage. It is important to avoid allocating memory for the inter-
mediate results |A0 −A1|, |B0 −B1|, C0, C1, and C2 at each step (although
modern compilers are quite good at optimizing code and removing unneces-
sary memory references). One possible solution is to allow a large temporary
storage of m words, used both for the intermediate results and for the recur-
sive calls. It can be shown that an auxiliary space of m = 2n words – or even
m = O(log n) – is sufﬁcient (see Exercises 1.7 and 1.8).
Since the product C2 is used only once, it may be faster to have auxiliary
routines KaratsubaAddmul and KaratsubaSubmul that accumulate their re-
sults, calling themselves recursively, together with KaratsubaMultiply (see
Exercise 1.10).
The version presented here uses ∼4n additions (or subtractions): 2 × (n/2)
to compute |A0 −A1| and |B0 −B1|, then n to add C0 and C1, again n to
add or subtract C2, and n to add (C0 + C1 −sAsBC2)βk to C0 + C1β2k. An
improved scheme uses only ∼7n/2 additions (see Exercise 1.9).
When considered as algorithms on polynomials, most fast multiplication
algorithms can be viewed as evaluation/interpolation algorithms. Karatsuba’s
algorithm regards the inputs as polynomials A0+A1x and B0+B1x evaluated
at x = βk; since their product C(x) is of degree 2, Lagrange’s interpolation
theorem says that it is sufﬁcient to evaluate C(x) at three points. The subtrac-
tive version evaluates1 C(x) at x = 0, −1, ∞, whereas the additive version
uses x = 0, +1, ∞.
1.3.3 Toom–Cook multiplication
Karatsuba’s idea readily generalizes to what is known as Toom–Cook r-way
multiplication. Write the inputs as a0+· · ·+ar−1xr−1 and b0+· · ·+br−1xr−1,
1
Evaluating C(x) at ∞means computing the product A1B1 of the leading coefﬁcients.

1.3 Multiplication
7
with x = βk, and k = ⌈n/r⌉. Since their product C(x) is of degree 2r −2,
it sufﬁces to evaluate it at 2r −1 distinct points to be able to recover C(x),
and in particular C(βk). If r is chosen optimally, Toom–Cook multiplication
of n-word numbers takes time n1+O(1/√log n).
Most references, when describing subquadratic multiplication algorithms,
only describe Karatsuba and FFT-based algorithms. Nevertheless, the Toom–
Cook algorithm is quite interesting in practice.
Toom–Cook r-way reduces one n-word product to 2r −1 products of about
n/r words, thus costs O(nν) with ν = log(2r −1)/ log r. However, the con-
stant hidden by the big-O notation depends strongly on the evaluation and
interpolation formulæ, which in turn depend on the chosen points. One possi-
bility is to take −(r −1), . . . , −1, 0, 1, . . . , (r −1) as evaluation points.
The case r = 2 corresponds to Karatsuba’s algorithm (§1.3.2). The case
r = 3 is known as Toom–Cook 3-way, sometimes simply called “the Toom–
Cook algorithm”. Algorithm ToomCook3 uses the evaluation points 0, 1, −1,
2, ∞, and tries to optimize the evaluation and interpolation formulæ.
Algorithm 1.4 ToomCook3
Input: two integers 0 ≤A, B < βn
Output: AB := c0 + c1βk + c2β2k + c3β3k + c4β4k with k = ⌈n/3⌉
Require: a threshold n1 ≥3
1: if n < n1 then return KaratsubaMultiply(A, B)
2: write A = a0 + a1x + a2x2, B = b0 + b1x + b2x2 with x = βk.
3: v0 ←ToomCook3(a0, b0)
4: v1 ←ToomCook3(a02+a1, b02+b1) where a02 ←a0+a2, b02 ←b0+b2
5: v−1 ←ToomCook3(a02 −a1, b02 −b1)
6: v2 ←ToomCook3(a0 + 2a1 + 4a2, b0 + 2b1 + 4b2)
7: v∞←ToomCook3(a2, b2)
8: t1 ←(3v0 + 2v−1 + v2)/6 −2v∞, t2 ←(v1 + v−1)/2
9: c0 ←v0, c1 ←v1 −t1, c2 ←t2 −v0 −v∞, c3 ←t1 −t2, c4 ←v∞.
The divisions at step 8 are exact; if β is a power of two, the division by 6
can be done using a division by 2 – which consists of a single shift – followed
by a division by 3 (see §1.4.7).
Toom–Cook r-way has to invert a (2r −1) × (2r −1) Vandermonde matrix
with parameters the evaluation points; if we choose consecutive integer points,
the determinant of that matrix contains all primes up to 2r −2. This proves
that division by (a multiple of) 3 can not be avoided for Toom–Cook 3-way
with consecutive integer points. See Exercise 1.14 for a generalization of this
result.

8
Integer arithmetic
1.3.4 Use of the fast Fourier transform (FFT)
Most subquadratic multiplication algorithms can be seen as evaluation-inter-
polation algorithms. They mainly differ in the number of evaluation points, and
the values of those points. However, the evaluation and interpolation formulæ
become intricate in Toom–Cook r-way for large r, since they involve O(r2)
scalar operations. The fast Fourier transform (FFT) is a way to perform evalu-
ation and interpolation efﬁciently for some special points (roots of unity) and
special values of r. This explains why multiplication algorithms with the best
known asymptotic complexity are based on the FFT.
There are different ﬂavours of FFT multiplication, depending on the ring
where the operations are performed. The Sch¨onhage–Strassen algorithm, with
a complexity of O(n log n log log n), works in the ring Z/(2n + 1)Z. Since it
is based on modular computations, we describe it in Chapter 2.
Other commonly used algorithms work with ﬂoating-point complex num-
bers. A drawback is that, due to the inexact nature of ﬂoating-point computa-
tions, a careful error analysis is required to guarantee the correctness of the im-
plementation, assuming an underlying arithmetic with rigorous error bounds.
See Theorem 3.6 in Chapter 3.
We say that multiplication is in the FFT range if n is large and the multi-
plication algorithm satisﬁes M(2n) ∼2M(n). For example, this is true if the
Sch¨onhage–Strassen multiplication algorithm is used, but not if the classical
algorithm or Karatsuba’s algorithm is used.
1.3.5 Unbalanced multiplication
The subquadratic algorithms considered so far (Karatsuba and Toom–Cook)
work with equal-size operands. How do we efﬁciently multiply integers of dif-
ferent sizes with a subquadratic algorithm? This case is important in practice,
but is rarely considered in the literature. Assume the larger operand has size
m, and the smaller has size n ≤m, and denote by M(m, n) the corresponding
multiplication cost.
If evaluation-interpolation algorithms are used, the cost depends mainly on
the size of the result, i.e. m + n, so we have M(m, n) ≤M((m + n)/2), at
least approximately. We can do better than M((m+n)/2) if n is much smaller
than m, for example M(m, 1) = O(m).
When m is an exact multiple of n, say m = kn, a trivial strategy is to cut the
larger operand into k pieces, giving M(kn, n) = kM(n) + O(kn). However,
this is not always the best strategy, see Exercise 1.16.

1.3 Multiplication
9
When m is not an exact multiple of n, several strategies are possible:
• split the two operands into an equal number of pieces of unequal sizes;
• or split the two operands into different numbers of pieces.
Each strategy has advantages and disadvantages. We discuss each in turn.
First strategy: equal number of pieces of unequal sizes
Consider for example Karatsuba multiplication, and let K(m, n) be the num-
ber of word-products for an m × n product. Take for example m = 5, n = 3.
A natural idea is to pad the smaller operand to the size of the larger one. How-
ever, there are several ways to perform this padding, as shown in the following
ﬁgure, where the “Karatsuba cut” is represented by a double column:
a4
a3
a2
a1
a0
b2
b1
b0
A × B
a4
a3
a2
a1
a0
b2
b1
b0
A × (βB)
a4
a3
a2
a1
a0
b2
b1
b0
A × (β2B)
The left variant leads to two products of size 3, i.e. 2K(3, 3), the middle one to
K(2, 1)+K(3, 2)+K(3, 3), and the right one to K(2, 2)+K(3, 1)+K(3, 3),
which give respectively 14, 15, 13 word-products.
However, whenever m/2 ≤n ≤m, any such “padding variant” will re-
quire K(⌈m/2⌉, ⌈m/2⌉) for the product of the differences (or sums) of the
low and high parts from the operands, due to a “wrap-around” effect when
subtracting the parts from the smaller operand; this will ultimately lead to a
cost similar to that of an m×m product. The “odd–even scheme” of Algorithm
OddEvenKaratsuba (see also Exercise 1.13) avoids this wrap-around. Here is
an example of this algorithm for m = 3 and n = 2. Take A = a2x2 +a1x+a0
and B = b1x + b0. This yields A0 = a2x + a0, A1 = a1, B0 = b0, B1 = b1;
thus, C0 = (a2x + a0)b0, C1 = (a2x + a0 + a1)(b0 + b1), C2 = a1b1.
Algorithm 1.5 OddEvenKaratsuba
Input: A = Pm−1
0
aixi, B = Pn−1
0
bjxj, m ≥n ≥1
Output: A · B
if n = 1 then return Pm−1
0
aib0xi
write A = A0(x2) + xA1(x2), B = B0(x2) + xB1(x2)
C0 ←OddEvenKaratsuba(A0, B0)
C1 ←OddEvenKaratsuba(A0 + A1, B0 + B1)
C2 ←OddEvenKaratsuba(A1, B1)
return C0(x2) + x(C1 −C0 −C2)(x2) + x2C2(x2).

10
Integer arithmetic
We therefore get K(3, 2) = 2K(2, 1) + K(1) = 5 with the odd–even
scheme. The general recurrence for the odd–even scheme is
K(m, n) = 2K(⌈m/2⌉, ⌈n/2⌉) + K(⌊m/2⌋, ⌊n/2⌋),
instead of
K(m, n) = 2K(⌈m/2⌉, ⌈m/2⌉) + K(⌊m/2⌋, n −⌈m/2⌉)
for the classical variant, assuming n > m/2. We see that the second parameter
in K(·, ·) only depends on the smaller size n for the odd–even scheme.
As for the classical variant, there are several ways of padding with the odd–
even scheme. Consider m = 5, n = 3, and write A := a4x4 + a3x3 + a2x2 +
a1x + a0 = xA1(x2) + A0(x2), with A1(x) = a3x + a1, A0(x) = a4x2 +
a2x + a0; and B := b2x2 + b1x + b0 = xB1(x2) + B0(x2), with B1(x) = b1,
B0(x) = b2x+b0. Without padding, we write AB = x2(A1B1)(x2)+x((A0+
A1)(B0 + B1) −A1B1 −A0B0)(x2) + (A0B0)(x2), which gives K(5, 3) =
K(2, 1) + 2K(3, 2) = 12. With padding, we consider xB = xB′
1(x2) +
B′
0(x2), with B′
1(x) = b2x+b0, B′
0 = b1x. This gives K(2, 2) = 3 for A1B′
1,
K(3, 2) = 5 for (A0 + A1)(B′
0 + B′
1), and K(3, 1) = 3 for A0B′
0 – taking
into account the fact that B′
0 has only one non-zero coefﬁcient – thus, a total
of 11 only.
Note that when the variable x corresponds to say β = 264, Algorithm
OddEvenKaratsuba as presented above is not very practical in the integer
case, because of a problem with carries. For example, in the sum A0 + A1 we
have ⌊m/2⌋carries to store. A workaround is to consider x to be say β10, in
which case we have to store only one carry bit for ten words, instead of one
carry bit per word.
The ﬁrst strategy, which consists in cutting the operands into an equal num-
ber of pieces of unequal sizes, does not scale up nicely. Assume for example
that we want to multiply a number of 999 words by another number of 699
words, using Toom–Cook 3-way. With the classical variant – without padding –
and a “large” base of β333, we cut the larger operand into three pieces of 333
words and the smaller one into two pieces of 333 words and one small piece of
33 words. This gives four full 333 × 333 products – ignoring carries – and one
unbalanced 333 × 33 product (for the evaluation at x = ∞). The “odd–even”
variant cuts the larger operand into three pieces of 333 words, and the smaller
operand into three pieces of 233 words, giving rise to ﬁve equally unbalanced
333 × 233 products, again ignoring carries.

1.3 Multiplication
11
Second strategy: different number of pieces of equal sizes
Instead of splitting unbalanced operands into an equal number of pieces –
which are then necessarily of different sizes – an alternative strategy is to split
the operands into a different number of pieces, and use a multiplication al-
gorithm which is naturally unbalanced. Consider again the example of multi-
plying two numbers of 999 and 699 words. Assume we have a multiplication
algorithm, say Toom-(3, 2), which multiplies a number of 3n words by another
number of 2n words; this requires four products of numbers of about n words.
Using n = 350, we can split the larger number into two pieces of 350 words,
and one piece of 299 words, and the smaller number into one piece of 350
words and one piece of 349 words.
Similarly, for two inputs of 1000 and 500 words, we can use a Toom-(4, 2)
algorithm, which multiplies two numbers of 4n and 2n words, with n = 250.
Such an algorithm requires ﬁve evaluation points; if we choose the same points
as for Toom 3-way, then the interpolation phase can be shared between both
implementations.
It seems that this second strategy is not compatible with the “odd–even”
variant, which requires that both operands are cut into the same number of
pieces. Consider for example the “odd–even” variant modulo 3. It writes the
numbers to be multiplied as A = a(β) and B = b(β) with a(t) = a0(t3) +
ta1(t3)+t2a2(t3), and similarly b(t) = b0(t3)+tb1(t3)+t2b2(t3). We see that
the number of pieces of each operand is the chosen modulus, here 3 (see Exer-
cise 1.11). Experimental results comparing different multiplication algorithms
are illustrated in Figure 1.1.
Asymptotic complexity of unbalanced multiplication
Suppose m ≥n and n is large. To use an evaluation-interpolation scheme,
we need to evaluate the product at m + n points, whereas balanced k by k
multiplication needs 2k points. Taking k ≈(m+n)/2, we see that M(m, n) ≤
M((m + n)/2)(1 + o(1)) as n →∞. On the other hand, from the discussion
above, we have M(m, n) ≤⌈m/n⌉M(n). This explains the upper bound on
M(m, n) given in the Summary of complexities at the end of the book.
1.3.6 Squaring
In many applications, a signiﬁcant proportion of the multiplications have equal
operands, i.e. are squarings. Hence, it is worth tuning a special squaring im-
plementation as much as the implementation of multiplication itself, bearing
in mind that the best possible speedup is two (see Exercise 1.17).

12
Integer arithmetic
4
18
32
46
60
74
88
102
116
130
144
158
4 bc
11 bc bc
18 bc bc 22
25 bc bc bc 22
32 bc bc bc bc 22
39 bc bc bc 32 32 33
46 bc bc bc 32 32 32 22
53 bc bc bc bc 32 32 32 22
60 bc bc bc bc 32 32 32 32 22
67 bc bc bc bc 42 32 32 32 33 33
74 bc bc bc bc 42 32 32 32 32 33 33
81 bc bc bc bc 32 32 32 32 32 33 33 33
88 bc bc bc bc 32 42 42 32 32 32 33 33 33
95 bc bc bc bc 42 42 42 32 32 32 33 33 33 22
102 bc bc bc bc 42 42 42 42 32 32 32 33 33 44 33
109 bc bc bc bc bc 42 42 42 42 32 32 32 33 32 44 44
116 bc bc bc bc bc 42 42 42 42 32 32 32 32 32 44 44 44
123 bc bc bc bc bc 42 42 42 42 42 32 32 32 32 44 44 44 44
130 bc bc bc bc bc 42 42 42 42 42 42 32 32 32 44 44 44 44 44
137 bc bc bc bc bc 42 42 42 42 42 42 32 32 32 33 33 44 33 33 33
144 bc bc bc bc bc 42 42 42 42 42 42 32 32 32 32 32 33 44 33 33 33
151 bc bc bc bc bc 42 42 42 42 42 42 42 32 32 32 32 33 33 33 33 33 33
158 bc bc bc bc bc bc 42 42 42 42 42 42 32 32 32 32 32 33 33 33 33 33 33
Figure 1.1 The best algorithm to multiply two numbers of x and y words
for 4 ≤x ≤y ≤158: bc is schoolbook multiplication, 22 is Karatsuba’s
algorithm, 33 is Toom-3, 32 is Toom-(3, 2), 44 is Toom-4, and 42 is Toom-
(4, 2). This graph was obtained on a Core 2, with GMP 5.0.0, and GCC 4.4.2.
Note that for x ≤(y + 3)/4, only the schoolbook multiplication is avail-
able; since we did not consider the algorithm that cuts the larger operand into
several pieces, this explains why bc is best for say x = 32 and y = 158.
For naive multiplication, Algorithm 1.2 BasecaseMultiply can be modiﬁed
to obtain a theoretical speedup of two, since only about half of the products
aibj need to be computed.
Subquadratic algorithms like Karatsuba and Toom–Cook r-way can be spe-
cialized for squaring too. In general, the threshold obtained is larger than the
corresponding multiplication threshold. For example, on a modern 64-bit com-
puter, we can expect a threshold between the naive quadratic squaring and
Karatsuba’s algorithm in the 30-word range, between Karatsuba and Toom–
Cook 3-way in the 100-word range, between Toom–Cook 3-way and Toom–
Cook 4-way in the 150-word range, and between Toom–Cook 4-way and the
FFT in the 2500-word range.
The classical approach for fast squaring is to take a fast multiplication algo-
rithm, say Toom–Cook r-way, and to replace the 2r −1 recursive products by
2r−1 recursive squarings. For example, starting from Algorithm ToomCook3,
we obtain ﬁve recursive squarings a2
0, (a0 + a1 + a2)2, (a0 −a1 + a2)2,
(a0 + 2a1 + 4a2)2, and a2
2. A different approach, called asymmetric squaring,
is to allow products that are not squares in the recursive calls. For example,

1.3 Multiplication
13
 0
 0.2
 0.4
 0.6
 0.8
 1
 1
 10
 100
 1000
 10000
 100000
 1e+06
mpn_mul_n
mpn_sqr
Figure 1.2 Ratio of the squaring and multiplication time for the GNU MP
library, version 5.0.0, on a Core 2 processor, up to one million words.
the square of a2β2 + a1β + a0 is c4β4 + c3β3 + c2β2 + c1β + c0, where
c4 = a2
2, c3 = 2a1a2, c2 = c0 + c4 −s, c1 = 2a1a0, and c0 = a2
0, where
s = (a0 −a2 + a1)(a0 −a2 −a1). This formula performs two squarings,
and three normal products. Such asymmetric squaring formulæ are not asymp-
totically optimal, but might be faster in some medium range, due to simpler
evaluation or interpolation phases.
Figure 1.2 compares the multiplication and squaring time with the GNU MP
library. It shows that whatever the word range, a good rule of thumb is to count
2/3 of the cost of a product for a squaring.
1.3.7 Multiplication by a constant
It often happens that the same multiplier is used in several consecutive oper-
ations, or even for a complete calculation. If this constant multiplier is small,
i.e. less than the base β, not much speedup can be obtained compared to the
usual product. We thus consider here a “large” constant multiplier.
When using evaluation-interpolation algorithms, such as Karatsuba or Toom–
Cook (see §1.3.2–1.3.3), we may store the evaluations for that ﬁxed multiplier
at the different points chosen.

14
Integer arithmetic
Special-purpose algorithms also exist. These algorithms differ from classi-
cal multiplication algorithms because they take into account the value of the
given constant multiplier, and not only its size in bits or digits. They also dif-
fer in the model of complexity used. For example, R. Bernstein’s algorithm
[27], which is used by several compilers to compute addresses in data struc-
ture records, considers as basic operation x, y 7→2ix ± y, with a cost assumed
to be independent of the integer i.
For example, Bernstein’s algorithm computes 20061x in ﬁve steps:
x1 := 31x
=
25x −x
x2 := 93x
=
21x1 + x1
x3 := 743x
=
23x2 −x
x4 := 6687x
=
23x3 + x3
20061x
=
21x4 + x4.
1.4 Division
Division is the next operation to consider after multiplication. Optimizing di-
vision is almost as important as optimizing multiplication, since division is
usually more expensive, thus the speedup obtained on division will be more
signiﬁcant. On the other hand, we usually perform more multiplications than
divisions.
One strategy is to avoid divisions when possible, or replace them by multi-
plications. An example is when the same divisor is used for several consecutive
operations; we can then precompute its inverse (see §2.4.1).
We distinguish several kinds of division: full division computes both quo-
tient and remainder, while in other cases only the quotient (for example, when
dividing two ﬂoating-point signiﬁcands) or remainder (when multiplying two
residues modulo n) is needed. We also discuss exact division – when the
remainder is known to be zero – and the problem of dividing by a single word.
1.4.1 Naive division
In all division algorithms, we assume that divisors are normalized. We say that
B := Pn−1
0
bjβj is normalized when its most signiﬁcant word bn−1 satisﬁes
bn−1 ≥β/2. This is a stricter condition (for β > 2) than simply requiring that
bn−1 be non-zero.
If B is not normalized, we can compute A′ = 2kA and B′ = 2kB so
that B′ is normalized, then divide A′ by B′ giving A′ = Q′B′ + R′. The

1.4 Division
15
Algorithm 1.6 BasecaseDivRem
Input: A = Pn+m−1
0
aiβi, B = Pn−1
0
bjβj, B normalized, m ≥0
Output: quotient Q and remainder R of A divided by B
1: if A ≥βmB then qm ←1, A ←A −βmB else qm ←0
2: for j from m −1 downto 0 do
3:
q∗
j ←⌊(an+jβ + an+j−1)/bn−1⌋
⊲quotient selection step
4:
qj ←min(q∗
j , β −1)
5:
A ←A −qjβjB
6:
while A < 0 do
7:
qj ←qj −1
8:
A ←A + βjB
9: return Q = Pm
0 qjβj, R = A.
(Note: in step 3, ai denotes the current value of the ith word of A, which may
be modiﬁed at steps 5 and 8.)
quotient and remainder of the division of A by B are, respectively, Q := Q′
and R := R′/2k; the latter division being exact.
Theorem 1.3 Algorithm BasecaseDivRem correctly computes the quotient
and remainder of the division of A by a normalized B, in O(n(m + 1)) word
operations.
Proof. We prove that the invariant A < βj+1B holds at step 2. This holds
trivially for j = m −1: B being normalized, A < 2βmB initially.
First consider the case qj = q∗
j . Then qjbn−1 ≥an+jβ+an+j−1−bn−1+1,
and therefore
A −qjβjB ≤(bn−1 −1)βn+j−1 + (A mod βn+j−1),
which ensures that the new an+j vanishes, and an+j−1
< bn−1; thus,
A < βjB after step 5. Now A may become negative after step 5, but, since
qjbn−1 ≤an+jβ + an+j−1, we have
A −qjβjB > (an+jβ + an+j−1)βn+j−1 −qj(bn−1βn−1 + βn−1)βj
≥−qjβn+j−1.
Therefore, A−qjβjB +2βjB ≥(2bn−1 −qj)βn+j−1 > 0, which proves that
the while-loop at steps 6–8 is performed at most twice [142, Theorem 4.3.1.B].
When the while-loop is entered, A may increase only by βjB at a time; hence,
A < βjB at exit.

16
Integer arithmetic
In the case qj
̸=
q∗
j , i.e. q∗
j
≥
β, we have before the while-loop
A < βj+1B −(β −1)βjB = βjB; thus, the invariant holds. If the while-
loop is entered, the same reasoning as above holds.
We conclude that when the for-loop ends, 0 ≤A < B holds, and, since
(Pm
j qjβj)B + A is invariant throughout the algorithm, the quotient Q and
remainder R are correct.
The most expensive part is step 5, which costs O(n) operations for qjB (the
multiplication by βj is simply a word-shift); the total cost is O(n(m + 1)).
(For m = 0, we need O(n) work if A ≥B, and even if A < B to compare the
inputs in the case A = B −1.)
Here is an example of algorithm BasecaseDivRem for the inputs
A = 766 970 544 842 443 844 and B = 862 664 913, with β = 1000, which
gives quotient Q = 889 071 217 and remainder R = 778 334 723.
j
A
qj
A −qjBβj
after correction
2
766 970 544 842 443 844
889
61 437 185 443 844
no change
1
61 437 185 443 844
071
187 976 620 844
no change
0
187 976 620 844
218
−84 330 190
778 334 723
Algorithm BasecaseDivRem simpliﬁes when A < βmB: remove step 1,
and change m into m −1 in the return value Q. However, the more general
form we give is more convenient for a computer implementation, and will be
used below.
A possible variant when q∗
j ≥β is to let qj = β; then A −qjβjB at step 5
reduces to a single subtraction of B shifted by j + 1 words. However, in this
case the while-loop will be performed at least once, which corresponds to the
identity A −(β −1)βjB = A −βj+1B + βjB.
If instead of having B normalized, i.e. bn ≥β/2, we have bn ≥β/k, there
can be up to k iterations of the while-loop (and step 1 has to be modiﬁed).
A drawback of Algorithm BasecaseDivRem is that the test A < 0 at line 6
is true with non-negligible probability; therefore, branch prediction algorithms
available on modern processors will fail, resulting in wasted cycles. A work-
around is to compute a more accurate partial quotient, in order to decrease the
proportion of corrections to almost zero (see Exercise 1.20).
1.4.2 Divisor preconditioning
Sometimes the quotient selection – step 3 of Algorithm BasecaseDivRem – is
quite expensive compared to the total cost, especially for small sizes. Indeed,
some processors do not have a machine instruction for the division of two

1.4 Division
17
words by one word; one way to compute q∗
j is then to precompute a one-word
approximation of the inverse of bn−1, and to multiply it by an+jβ + an+j−1.
Svoboda’s algorithm makes the quotient selection trivial, after precondition-
ing the divisor. The main idea is that if bn−1 equals the base β in Algorithm
BasecaseDivRem, then the quotient selection is easy, since it sufﬁces to take
q∗
j = an+j. (In addition, q∗
j ≤β −1 is then always fulﬁlled; thus, step 4 of
BasecaseDivRem can be avoided, and q∗
j replaced by qj.)
Algorithm 1.7 SvobodaDivision
Input: A = Pn+m−1
0
aiβi, B = Pn−1
0
bjβj normalized, A < βmB, m ≥1
Output: quotient Q and remainder R of A divided by B
1: k ←⌈βn+1/B⌉
2: B′ ←kB = βn+1 + Pn−1
0
b′
jβj
3: for j from m −1 downto 1 do
4:
qj ←an+j
⊲current value of an+j
5:
A ←A −qjβj−1B′
6:
if A < 0 then
7:
qj ←qj −1
8:
A ←A + βj−1B′
9: Q′ = Pm−1
1
qjβj, R′ = A
10: (q0, R) ←(R′ div B, R′ mod B)
⊲using BasecaseDivRem
11: return Q = kQ′ + q0, R.
With the example of §1.4.1, Svoboda’s algorithm would give k = 1160,
B′ = 1 000 691 299 080:
j
A
qj
A −qjB′βj
after correction
2
766 970 544 842 443 844
766
441 009 747 163 844
no change
1
441 009 747 163 844
441
−295 115 730 436
705 575 568 644
We thus get Q′ = 766 440 and R′ = 705 575 568 644. The ﬁnal division of
step 10 gives R′ = 817B + 778 334 723, and we get Q = 1 160 · 766 440 +
817 = 889 071 217, and R = 778 334 723, as in §1.4.1.
Svoboda’s algorithm is especially interesting when only the remainder is
needed, since then we can avoid the “deconditioning” Q = kQ′ + q0. Note
that when only the quotient is needed, dividing A′ = kA by B′ = kB is
another way to compute it.

18
Integer arithmetic
1.4.3 Divide and conquer division
The base-case division of §1.4.1 determines the quotient word by word. A
natural idea is to try getting several words at a time, for example replacing the
quotient selection step in Algorithm BasecaseDivRem by
q∗
j ←
¹an+jβ3 + an+j−1β2 + an+j−2β + an+j−3
bn−1β + bn−2
º
.
Since q∗
j has then two words, fast multiplication algorithms (§1.3) might speed
up the computation of qjB at step 5 of Algorithm BasecaseDivRem.
More generally, the most signiﬁcant half of the quotient – say Q1, of
ℓ= m −k words – mainly depends on the ℓmost signiﬁcant words of the
dividend and divisor. Once a good approximation to Q1 is known, fast multi-
plication algorithms can be used to compute the partial remainder A−Q1Bβk.
The second idea of the divide and conquer algorithm RecursiveDivRem is to
compute the corresponding remainder together with the partial quotient Q1; in
such a way, we only have to subtract the product of Q1 by the low part of the
divisor, before computing the low part of the quotient.
Algorithm 1.8 RecursiveDivRem
Input: A = Pn+m−1
0
aiβi, B = Pn−1
0
bjβj, B normalized, n ≥m
Output: quotient Q and remainder R of A divided by B
1: if m < 2 then return BasecaseDivRem(A, B)
2: k ←⌊m/2⌋, B1 ←B div βk, B0 ←B mod βk
3: (Q1, R1) ←RecursiveDivRem(A div β2k, B1)
4: A′ ←R1β2k + (A mod β2k) −Q1B0βk
5: while A′ < 0 do Q1 ←Q1 −1, A′ ←A′ + βkB
6: (Q0, R0) ←RecursiveDivRem(A′ div βk, B1)
7: A′′ ←R0βk + (A′ mod βk) −Q0B0
8: while A′′ < 0 do Q0 ←Q0 −1, A′′ ←A′′ + B
9: return Q := Q1βk + Q0, R := A′′.
In Algorithm RecursiveDivRem, we may replace the condition m < 2 at
step 1 by m < T for any integer T ≥2. In practice, T is usually in the range
50 to 200.
We can not require A < βmB at input, since this condition may not be
satisﬁed in the recursive calls. Consider for example A = 5517, B = 56 with
β = 10: the ﬁrst recursive call will divide 55 by 5, which yields a two-digit
quotient 11. Even A ≤βmB is not recursively fulﬁlled, as this example shows.
The weakest possible input condition is that the n most signiﬁcant words of A

1.4 Division
19
do not exceed those of B, i.e. A < βm(B + 1). In that case, the quotient is
bounded by βm + ⌊(βm −1)/B⌋, which yields βm + 1 in the case n = m
(compare Exercise 1.19). See also Exercise 1.22.
Theorem 1.4 Algorithm RecursiveDivRem is correct, and uses D(n+m, n)
operations, where D(n + m, n) = 2D(n, n −m/2) + 2M(m/2) + O(n). In
particular, D(n) := D(2n, n) satisﬁes D(n) = 2D(n/2)+2M(n/2)+O(n),
which gives D(n) ∼M(n)/(2α−1 −1) for M(n) ∼nα, α > 1.
Proof. We ﬁrst check the assumption for the recursive calls: B1 is normalized
since it has the same most signiﬁcant word than B.
After step 3, we have A = (Q1B1 + R1)β2k + (A mod β2k); thus, after
step 4, A′ = A −Q1βkB, which still holds after step 5. After step 6, we have
A′ = (Q0B1 + R0)βk + (A′ mod βk), and, after step 7, A′′ = A′ −Q0B,
which still holds after step 8. At step 9, we have A = QB + R.
A div β2k has m + n −2k words, and B1 has n −k words; thus, 0 ≤Q1 <
2βm−k and 0 ≤R1 < B1 < βn−k. At step 4, −2βm+k < A′ < βkB. Since
B is normalized, the while-loop at step 5 is performed at most four times (this
can happen only when n = m). At step 6, we have 0 ≤A′ < βkB; thus,
A′ div βk has at most n words.
It follows 0 ≤Q0 < 2βk and 0 ≤R0 < B1 < βn−k. Hence, at step
7, −2β2k < A′′ < B, and, after at most four iterations at step 8, we have
0 ≤A′′ < B.
Theorem 1.4 gives D(n) ∼2M(n) for Karatsuba multiplication, and D(n) ∼
2.63M(n) for Toom–Cook 3-way; in the FFT range, see Exercise 1.23.
The same idea as in Exercise 1.20 applies: to decrease the probability that
the estimated quotients Q1 and Q0 are too large, use one extra word of the
truncated dividend and divisors in the recursive calls to RecursiveDivRem.
A graphical view of Algorithm RecursiveDivRem in the case m = n is
given in Figure 1.3, which represents the multiplication Q · B: we ﬁrst com-
pute the lower left corner in D(n/2) (step 3), second the lower right corner in
M(n/2) (step 4), third the upper left corner in D(n/2) (step 6), and ﬁnally the
upper right corner in M(n/2) (step 7).
Unbalanced division
The condition n ≥m in Algorithm RecursiveDivRem means that the divi-
dend A is at most twice as large as the divisor B. When A is more than twice
as large as B (m > n with the notation above), a possible strategy (see Ex-
ercise 1.24) computes n words of the quotient at a time. This reduces to the
base-case algorithm, replacing β by βn.

20
Integer arithmetic
quotient Q
divisor B
M(n/2)
M(n/2)
M(n/4)
M(n/4)
M(n/4)
M(n/4)
M( n
8 )
M( n
8 )
M( n
8 )
M( n
8 )
M( n
8 )
M( n
8 )
M( n
8 )
M( n
8 )
Figure 1.3 Divide and conquer division: a graphical view
(most signiﬁcant parts at the lower left corner).
Algorithm 1.9 UnbalancedDivision
Input: A = Pn+m−1
0
aiβi, B = Pn−1
0
bjβj, B normalized, m > n
Output: quotient Q and remainder R of A divided by B
Q ←0
while m > n do
(q, r) ←RecursiveDivRem(A div βm−n, B)
⊲2n by n division
Q ←Qβn + q
A ←rβm−n + A mod βm−n
m ←m −n
(q, r) ←RecursiveDivRem(A, B)
return Q := Qβm + q, R := r.
Figure 1.4 compares unbalanced multiplication and division in GNU MP.
As expected, multiplying x words by n −x words takes the same time as
multiplying n −x words by n words. However, there is no symmetry for the
division, since dividing n words by x words for x < n/2 is more expensive,
at least for the version of GMP that we used, than dividing n words by n −x
words.

1.4 Division
21
 0
 200
 400
 600
 800
 1000
 1200
 1400
 1600
 1800
 2000
 0
 100
 200
 300
 400
 500
 600
 700
 800
 900
 1000
div
mul
Figure 1.4 Time in 10−5 seconds for the multiplication (lower curve) of x
words by 1000 −x words and for the division (upper curve) of 1000 words
by x words, with GMP 5.0.0 on a Core 2 running at 2.83GHz.
1.4.4 Newton’s method
Newton’s iteration gives the division algorithm with best asymptotic complex-
ity. One basic component of Newton’s iteration is the computation of an ap-
proximate inverse. We refer here to Chapter 4. The p-adic version of Newton’s
method, also called Hensel lifting, is used in §1.4.5 for exact division.
1.4.5 Exact division
A division is exact when the remainder is zero. This happens, for example,
when normalizing a fraction a/b: we divide both a and b by their greatest com-
mon divisor, and both divisions are exact. If the remainder is known
a priori to be zero, this information is useful to speed up the computation
of the quotient.
Two strategies are possible:
• use MSB (most signiﬁcant bits ﬁrst) division algorithms, without computing
the lower part of the remainder. Here, we have to take care of rounding
errors, in order to guarantee the correctness of the ﬁnal result; or

22
Integer arithmetic
• use LSB (least signiﬁcant bits ﬁrst) algorithms. If the quotient is known to
be less than βn, computing a/b mod βn will reveal it.
Subquadratic algorithms can use both strategies. We describe a least signiﬁcant
bit algorithm using Hensel lifting, which can be viewed as a p-adic version of
Newton’s method.
Algorithm ExactDivision uses the Karp–Markstein trick: lines 1–4 compute
1/B mod β⌈n/2⌉, while the two last lines incorporate the dividend to obtain
A/B mod βn. Note that the middle product (§3.3.2) can be used in lines 4 and
6, to speed up the computation of 1 −BC and A −BQ, respectively.
Algorithm 1.10 ExactDivision
Input: A = Pn−1
0
aiβi, B = Pn−1
0
bjβj
Output: quotient Q = A/B mod βn
Require: gcd(b0, β) = 1
1: C ←1/b0 mod β
2: for i from ⌈lg n⌉−1 downto 1 do
3:
k ←⌈n/2i⌉
4:
C ←C + C(1 −BC) mod βk
5: Q ←AC mod βk
6: Q ←Q + C(A −BQ) mod βn.
A further gain can be obtained by using both strategies simultaneously: com-
pute the most signiﬁcant n/2 bits of the quotient using the MSB strategy, and
the least signiﬁcant n/2 bits using the LSB strategy. Since a division of size n
is replaced by two divisions of size n/2, this gives a speedup of up to two for
quadratic algorithms (see Exercise 1.27).
1.4.6 Only quotient or remainder wanted
When both the quotient and remainder of a division are needed, it is best
to compute them simultaneously. This may seem to be a trivial statement;
nevertheless, some high-level languages provide both div and mod, but no
single instruction to compute both quotient and remainder.
Once the quotient is known, the remainder can be recovered by a single
multiplication as A −QB; on the other hand, when the remainder is known,
the quotient can be recovered by an exact division as (A −R)/B (§1.4.5).
However, it often happens that only one of the quotient or remainder is
needed. For example, the division of two ﬂoating-point numbers reduces to the
quotient of their signiﬁcands (see Chapter 3). Conversely, the multiplication of

1.4 Division
23
two numbers modulo N reduces to the remainder of their product after divi-
sion by N (see Chapter 2). In such cases, we may wonder if faster algorithms
exist.
For a dividend of 2n words and a divisor of n words, a signiﬁcant speedup –
up to a factor of two for quadratic algorithms – can be obtained when only
the quotient is needed, since we do not need to update the low n words of the
current remainder (step 5 of Algorithm BasecaseDivRem).
It seems difﬁcult to get a similar speedup when only the remainder is re-
quired. One possibility is to use Svoboda’s algorithm, but this requires some
precomputation, so is only useful when several divisions are performed with
the same divisor. The idea is the following: precompute a multiple B1 of B,
having 3n/2 words, the n/2 most signiﬁcant words being βn/2. Then re-
ducing A mod B1 requires a single n/2 × n multiplication. Once A is re-
duced to A1 of 3n/2 words by Svoboda’s algorithm with cost 2M(n/2), use
RecursiveDivRem on A1 and B, which costs D(n/2) + M(n/2). The to-
tal cost is thus 3M(n/2) + D(n/2), instead of 2M(n/2) + 2D(n/2) for a
full division with RecursiveDivRem. This gives 5M(n)/3 for Karatsuba and
2.04M(n) for Toom–Cook 3-way, instead of 2M(n) and 2.63M(n), respec-
tively. A similar algorithm is described in §2.4.2 (Subquadratic Montgomery
Reduction) with further optimizations.
1.4.7 Division by a single word
We assume here that we want to divide a multiple precision number by a
one-word integer c. As for multiplication by a one-word integer, this is an
important special case. It arises for example in Toom–Cook multiplication,
where we have to perform an exact division by 3 (§1.3.3). We could of course
use a classical division algorithm (§1.4.1). When gcd(c, β) = 1, Algorithm
DivideByWord might be used to compute a modular division
A + bβn = cQ,
where the “carry” b will be zero when the division is exact.
Theorem 1.5 The output of Alg. DivideByWord satisﬁes A + bβn = cQ.
Proof. We show that after step i, 0 ≤i < n, we have Ai+bβi+1 = cQi, where
Ai := Pi
j=0 aiβi and Qi := Pi
j=0 qiβi. For i = 0, this is a0 + bβ = cq0,
which is just line 7; since q0 = a0/c mod β, q0c−a0 is divisible by β. Assume
now that Ai−1 +bβi = cQi−1 holds for 1 ≤i < n. We have ai −b+b′β = x,
so x + b′′β = cqi, thus Ai + (b′ + b′′)βi+1 = Ai−1 + βi(ai + b′β + b′′β) =

24
Integer arithmetic
cQi−1 −bβi + βi(x + b −b′β + b′β + b′′β) = cQi−1 + βi(x + b′′β) = cQi.
Algorithm 1.11 DivideByWord
Input: A = Pn−1
0
aiβi, 0 ≤c < β, gcd(c, β) = 1
Output: Q = Pn−1
0
qiβi and 0 ≤b < c such that A + bβn = cQ
1: d ←1/c mod β
⊲might be precomputed
2: b ←0
3: for i from 0 to n −1 do
4:
if b ≤ai then (x, b′) ←(ai −b, 0)
5:
else (x, b′) ←(ai −b + β, 1)
6:
qi ←dx mod β
7:
b′′ ←(qic −x)/β
8:
b ←b′ + b′′
9: return Pn−1
0
qiβi, b.
REMARK: at step 7, since 0 ≤x < β, b′′ can also be obtained as ⌊qic/β⌋.
Algorithm DivideByWord is just a special case of Hensel’s division, which
is the topic of the next section; it can easily be extended to divide by integers
of a few words.
1.4.8 Hensel’s division
Classical division involves cancelling the most signiﬁcant part of the dividend
by a multiple of the divisor, while Hensel’s division cancels the least signiﬁcant
part (Figure 1.5). Given a dividend A of 2n words and a divisor B of n words,
A
B
QB
R
A
B
Q′B
R′
Figure 1.5 Classical/MSB division (left) vs Hensel/LSB division (right).
the classical or MSB (most signiﬁcant bit) division computes a quotient Q and
a remainder R such that A = QB+R, while Hensel’s or LSB (least signiﬁcant

1.5 Roots
25
bit) division computes a LSB-quotient Q′ and a LSB-remainder R′ such that
A = Q′B + R′βn. While MSB division requires the most signiﬁcant bit of B
to be set, LSB division requires B to be relatively prime to the word base β,
i.e. B to be odd for β a power of two.
The LSB-quotient is uniquely deﬁned by Q′
=
A/B mod βn, with
0 ≤Q′ < βn. This in turn uniquely deﬁnes the LSB-remainder R′ =
(A −Q′B)β−n, with −B < R′ < βn.
Most MSB-division variants (naive, with preconditioning, divide and con-
quer, Newton’s iteration) have their LSB-counterpart. For example, LSB pre-
conditioning involves using a multiple kB of the divisor such that kB =
1 mod β, and Newton’s iteration is called Hensel lifting in the LSB case. The
exact division algorithm described at the end of §1.4.5 uses both MSB- and
LSB-division simultaneously. One important difference is that LSB-division
does not need any correction step, since the carries go in the direction opposite
to the cancelled bits.
When only the remainder is wanted, Hensel’s division is usually known as
Montgomery reduction (see §2.4.2).
1.5 Roots
1.5.1 Square root
The “paper and pencil” method once taught at school to extract square roots is
very similar to “paper and pencil” division. It decomposes an integer m of the
form s2 + r, taking two digits of m at a time, and ﬁnding one digit of s for
each two digits of m. It is based on the following idea. If m = s2 + r is the
current decomposition, then taking two more digits of the argument, we have a
decomposition of the form 100m+r′ = 100s2 +100r+r′ with 0 ≤r′ < 100.
Since (10s + t)2 = 100s2 + 20st + t2, a good approximation to the next digit
t can be found by dividing 10r by 2s.
Algorithm SqrtRem generalizes this idea to a power βℓof the internal base
close to m1/4: we obtain a divide and conquer algorithm, which is in fact an
error-free variant of Newton’s method (cf. Chapter 4):

26
Integer arithmetic
Algorithm 1.12 SqrtRem
Input: m = an−1βn−1 + · · · + a1β + a0 with an−1 ̸= 0
Output: (s, r) such that s2 ≤m = s2 + r < (s + 1)2
Require: a base-case routine BasecaseSqrtRem
ℓ←⌊(n −1)/4⌋
if ℓ= 0 then return BasecaseSqrtRem(m)
write m = a3β3ℓ+ a2β2ℓ+ a1βℓ+ a0 with 0 ≤a2, a1, a0 < βℓ
(s′, r′) ←SqrtRem(a3βℓ+ a2)
(q, u) ←DivRem(r′βℓ+ a1, 2s′)
s ←s′βℓ+ q
r ←uβℓ+ a0 −q2
if r < 0 then
r ←r + 2s −1,
s ←s −1
return (s, r).
Theorem 1.6 Algorithm SqrtRem correctly returns the integer square root
s and remainder r of the input m, and has complexity R(2n) ∼R(n) +
D(n) + S(n), where D(n) and S(n) are the complexities of the division
with remainder and squaring respectively. This gives R(n) ∼n2/2 with naive
multiplication, R(n) ∼4K(n)/3 with Karatsuba’s multiplication, assuming
S(n) ∼2M(n)/3.
As an example, assume Algorithm SqrtRem is called on m = 123 456 789
with β = 10. We have n = 9, ℓ= 2, a3 = 123, a2 = 45, a1 = 67, and
a0 = 89. The recursive call for a3βℓ+ a2 = 12 345 yields s′ = 111 and
r′ = 24. The DivRem call yields q = 11 and u = 25, which gives s = 11 111
and r = 2 468.
Another nice way to compute the integer square root of an integer m, i.e.
⌊m1/2⌋, is Algorithm SqrtInt, which is an all-integer version of Newton’s
method (§4.2).
Still with input 123 456 789, we successively get s = 61 728 395, 30 864 198,
15 432 100, 7 716 053, 3 858 034, 1 929 032, 964 547, 482 337, 241 296,
120 903, 60 962, 31 493, 17 706, 12 339, 11 172, 11 111, 11 111. Convergence
is slow because the initial value of u assigned at line 1 is much too large. How-
ever, any initial value greater than or equal to ⌊m1/2⌋works (see the proof of
Algorithm RootInt below): starting from s = 12 000, we get s = 11 144, then
s = 11 111. See Exercise 1.28.

1.5 Roots
27
Algorithm 1.13 SqrtInt
Input: an integer m ≥1
Output: s = ⌊m1/2⌋
1: u ←m
⊲any value u ≥⌊m1/2⌋works
2: repeat
3:
s ←u
4:
t ←s + ⌊m/s⌋
5:
u ←⌊t/2⌋
6: until u ≥s
7: return s.
1.5.2 kth root
The idea of Algorithm SqrtRem for the integer square root can be generalized
to any power: if the current decomposition is m = m′βk + m′′βk−1 + m′′′,
ﬁrst compute a kth root of m′, say m′ = sk + r, then divide rβ + m′′ by
ksk−1 to get an approximation of the next root digit t, and correct it if needed.
Unfortunately, the computation of the remainder, which is easy for the square
root, involves O(k) terms for the kth root, and this method may be slower than
Newton’s method with ﬂoating-point arithmetic (§4.2.3).
Similarly, Algorithm SqrtInt can be generalized to the kth root (see Algo-
rithm RootInt).
Algorithm 1.14 RootInt
Input: integers m ≥1, and k ≥2
Output: s = ⌊m1/k⌋
1: u ←m
⊲any value u ≥⌊m1/k⌋works
2: repeat
3:
s ←u
4:
t ←(k −1)s + ⌊m/sk−1⌋
5:
u ←⌊t/k⌋
6: until u ≥s
7: return s.
Theorem 1.7 Algorithm RootInt terminates and returns ⌊m1/k⌋.
Proof. As long as u < s in step 6, the sequence of s-values is decreasing;
thus, it sufﬁces to consider what happens when u ≥s. First it is easy so see that
u ≥s implies m ≥sk, because t ≥ks and therefore (k−1)s+m/sk−1 ≥ks.

28
Integer arithmetic
Consider now the function f(t) := [(k−1)t+m/tk−1]/k for t > 0; its deriva-
tive is negative for t
<
m1/k and positive for t
>
m1/k; thus,
f(t) ≥f(m1/k) = m1/k. This proves that s ≥⌊m1/k⌋. Together with
s ≤m1/k, this proves that s = ⌊m1/k⌋at the end of the algorithm.
Note that any initial value greater than or equal to ⌊m1/k⌋works at step 1.
Incidentally, we have proved the correctness of Algorithm SqrtInt, which is
just the special case k = 2 of Algorithm RootInt.
1.5.3 Exact root
When a kth root is known to be exact, there is of course no need to compute
exactly the ﬁnal remainder in “exact root” algorithms, which saves some com-
putation time. However, we have to check that the remainder is sufﬁciently
small that the computed root is correct.
When a root is known to be exact, we may also try to compute it starting
from the least signiﬁcant bits, as for exact division. Indeed, if sk = m, then
sk = m mod βℓfor any integer ℓ. However, in the case of exact division, the
equation a = qb mod βℓhas only one solution q as soon as b is relatively
prime to β. Here, the equation sk = m mod βℓmay have several solutions,
so the lifting process is not unique. For example, x2 = 1 mod 23 has four
solutions 1, 3, 5, 7.
Suppose we have sk = m mod βℓ, and we want to lift to βℓ+1. This implies
(s + tβℓ)k = m + m′βℓmod βℓ+1, where 0 ≤t, m′ < β. Thus
kt = m′ + m −sk
βℓ
mod β.
This equation has a unique solution t when k is relatively prime to β. For
example, we can extract cube roots in this way for β a power of two. When k
is relatively prime to β, we can also compute the root simultaneously from the
most signiﬁcant and least signiﬁcant ends, as for exact division.
Unknown exponent
Assume now that we want to check if a given integer m is an exact power,
without knowing the corresponding exponent. For example, some primality
testing or factorization algorithms fail when given an exact power, so this has
to be checked ﬁrst. Algorithm IsPower detects exact powers, and returns the
largest corresponding exponent (or 1 if the input is not an exact power).
To quickly detect non-kth powers at step 2, we may use modular algorithms
when k is relatively prime to the base β (see above).

1.6 Greatest common divisor
29
Algorithm 1.15 IsPower
Input: a positive integer m
Output: k ≥2 when m is an exact kth power, 1 otherwise
1: for k from ⌊lg m⌋downto 2 do
2:
if m is a kth power then return k
3: return 1.
REMARK: in Algorithm IsPower, we can limit the search to prime exponents
k, but then the algorithm does not necessarily return the largest exponent, and
we might have to call it again. For example, taking m = 117649, the modiﬁed
algorithm ﬁrst returns 3 because 117649 = 493, and when called again with
m = 49, it returns 2.
1.6 Greatest common divisor
Many algorithms for computing gcds may be found in the literature. We can
distinguish between the following (non-exclusive) types:
• Left-to-right (MSB) versus right-to-left (LSB) algorithms: in the former the
actions depend on the most signiﬁcant bits, while in the latter the actions
depend on the least signiﬁcant bits.
• Naive algorithms: these O(n2) algorithms consider one word of each operand
at a time, trying to guess from them the ﬁrst quotients – we count in this class
algorithms considering double-size words, namely Lehmer’s algorithm and
Sorenson’s k-ary reduction in the left-to-right and right-to-left cases respec-
tively; algorithms not in this class consider a number of words that depends
on the input size n, and are often subquadratic.
• Subtraction-only algorithms: these algorithms trade divisions for subtrac-
tions, at the cost of more iterations.
• Plain versus extended algorithms: the former just compute the gcd of the
inputs, while the latter express the gcd as a linear combination of the inputs.
1.6.1 Naive GCD
For completeness, we mention Euclid’s algorithm for ﬁnding the gcd of two
non-negative integers u, v.
Euclid’s algorithm is discussed in many textbooks, and we do not recom-
mend it in its simplest form, except for testing purposes. Indeed, it is usually a

30
Integer arithmetic
slow way to compute a gcd. However, Euclid’s algorithm does show the con-
nection between gcds and continued fractions. If u/v has a regular continued
fraction of the form
u/v = q0 +
1
q1+
1
q2+
1
q3+ · · · ,
then the quotients q0, q1, . . . are precisely the quotients u div v of the divisions
performed in Euclid’s algorithm. For more on continued fractions, see §4.6.
Algorithm 1.16 EuclidGcd
Input: u, v nonnegative integers (not both zero)
Output: gcd(u, v)
while v ̸= 0 do
(u, v) ←(v, u mod v)
return u.
Double-Digit Gcd. A ﬁrst improvement comes from Lehmer’s observation:
the ﬁrst few quotients in Euclid’s algorithm usually can be determined from
the most signiﬁcant words of the inputs. This avoids expensive divisions that
give small quotients most of the time (see [142, §4.5.3]). Consider for exam-
ple a = 427 419 669 081 and b = 321 110 693 270 with 3-digit words. The
ﬁrst quotients are 1, 3, 48, . . . Now, if we consider the most signiﬁcant words,
namely 427 and 321, we get the quotients 1, 3, 35, . . . If we stop after the
ﬁrst two quotients, we see that we can replace the initial inputs by a −b and
−3a + 4b, which gives 106 308 975 811 and 2 183 765 837.
Lehmer’s algorithm determines cofactors from the most signiﬁcant words
of the input integers. Those cofactors usually have size only half a word. The
DoubleDigitGcd algorithm – which should be called “double-word” – uses
the two most signiﬁcant words instead, which gives cofactors t, u, v, w of one
full-word each, such that gcd(a, b) = gcd(ta+ub, va+wb). This is optimal for
the computation of the four products ta, ub, va, wb. With the above example,
if we consider 427 419 and 321 110, we ﬁnd that the ﬁrst ﬁve quotients agree,
so we can replace a, b by −148a+197b and 441a−587b, i.e. 695 550 202 and
97 115 231.
The subroutine HalfBezout takes as input two 2-word integers, performs
Euclid’s algorithm until the smallest remainder ﬁts in one word, and returns
the corresponding matrix [t, u; v, w].
Binary Gcd. A better algorithm than Euclid’s, though also of O(n2) com-
plexity, is the binary algorithm. It differs from Euclid’s algorithm in two ways:

1.6 Greatest common divisor
31
Algorithm 1.17 DoubleDigitGcd
Input: a := an−1βn−1 + · · · + a0, b := bm−1βm−1 + · · · + b0
Output: gcd(a, b)
if b = 0 then return a
if m < 2 then return BasecaseGcd(a, b)
if a < b or n > m then return DoubleDigitGcd(b, a mod b)
(t, u, v, w) ←HalfBezout(an−1β + an−2, bn−1β + bn−2)
return DoubleDigitGcd(|ta + ub|, |va + wb|).
it consider least signiﬁcant bits ﬁrst, and it avoids divisions, except for divi-
sions by two (which can be implemented as shifts on a binary computer). See
Algorithm BinaryGcd. Note that the ﬁrst three “while” loops can be omitted
if the inputs a and b are odd.
Algorithm 1.18 BinaryGcd
Input: a, b > 0
Output: gcd(a, b)
t ←1
while a mod 2 = b mod 2 = 0 do
(t, a, b) ←(2t, a/2, b/2)
while a mod 2 = 0 do
a ←a/2
while b mod 2 = 0 do
b ←b/2
⊲now a and b are both odd
while a ̸= b do
(a, b) ←(|a −b|, min(a, b))
a ←a/2ν(a)
⊲ν(a) is the 2-valuation of a
return ta.
Sorenson’s k-ary reduction
The binary algorithm is based on the fact that if a and b are both odd, then a−b
is even, and we can remove a factor of two since gcd(a, b) is odd. Sorenson’s
k-ary reduction is a generalization of that idea: given a and b odd, we try to
ﬁnd small integers u, v such that ua −vb is divisible by a large power of two.
Theorem 1.8 [226] If a, b > 0, m > 1 with gcd(a, m) = gcd(b, m) = 1,
there exist u, v, 0 < |u|, v < √m such that ua = vb mod m.

32
Integer arithmetic
Algorithm ReducedRatMod ﬁnds such a pair (u, v). It is a simple variation of
the extended Euclidean algorithm; indeed, the ui are quotients in the continued
fraction expansion of c/m.
Algorithm 1.19 ReducedRatMod
Input: a, b > 0, m > 1 with gcd(a, m) = gcd(b, m) = 1
Output: (u, v) such that 0 < |u|, v < √m and ua = vb mod m
1: c ←a/b mod m
2: (u1, v1) ←(0, m)
3: (u2, v2) ←(1, c)
4: while v2 ≥√m do
5:
q ←⌊v1/v2⌋
6:
(u1, u2) ←(u2, u1 −qu2)
7:
(v1, v2) ←(v2, v1 −qv2)
8: return (u2, v2).
When m is a prime power, the inversion 1/b mod m at step 1 of Algorithm
ReducedRatMod can be performed efﬁciently using Hensel lifting (§2.5).
Given two integers a, b of say n words, Algorithm ReducedRatMod with
m = β2 returns two integers u, v such that vb −ua is a multiple of β2. Since
u, v have at most one word each, a′ = (vb−ua)/β2 has at most n−1 words –
plus possibly one bit – therefore with b′ = b mod a′ we obtain gcd(a, b) =
gcd(a′, b′), where both a′ and b′ have about one word less than max(a, b). This
gives an LSB variant of the double-digit (MSB) algorithm.
1.6.2 Extended GCD
Algorithm ExtendedGcd solves the extended greatest common divisor prob-
lem: given two integers a and b, it computes their gcd g, and also two integers
u and v (called B´ezout coefﬁcients or sometimes cofactors or multipliers) such
that g = ua + vb.
If a0 and b0 are the input numbers, and a, b the current values, the following
invariants hold at the start of each iteration of the while loop and after the while
loop: a = ua0 + vb0, and b = wa0 + xb0. (See Exercise 1.30 for a bound on
the cofactor u.)
An important special case is modular inversion (see Chapter 2): given an
integer n, we want to compute 1/a mod n for a relatively prime to n. We then
simply run Algorithm ExtendedGcd with input a and b = n; this yields u and
v with ua + vn = 1, and thus 1/a = u mod n. Since v is not needed here, we
can simply avoid computing v and x, by removing steps 2 and 7.

1.6 Greatest common divisor
33
Algorithm 1.20 ExtendedGcd
Input: positive integers a and b
Output: integers (g, u, v) such that g = gcd(a, b) = ua + vb
1: (u, w) ←(1, 0)
2: (v, x) ←(0, 1)
3: while b ̸= 0 do
4:
(q, r) ←DivRem(a, b)
5:
(a, b) ←(b, r)
6:
(u, w) ←(w, u −qw)
7:
(v, x) ←(x, v −qx)
8: return (a, u, v).
It may also be worthwhile to compute only u in the general case, as the
cofactor v can be recovered from v = (g −ua)/b, this division being exact
(see §1.4.5).
All known algorithms for subquadratic gcd rely on an extended gcd
subroutine, which is called recursively, so we discuss the subquadratic
extended gcd in the next section.
1.6.3 Half binary GCD, divide and conquer GCD
Designing a subquadratic integer gcd algorithm that is both mathematically
correct and efﬁcient in practice is a challenging problem.
A ﬁrst remark is that, starting from n-bit inputs, there are O(n) terms in the
remainder sequence r0 = a, r1 = b, . . . , ri+1 = ri−1 mod ri, . . . , and the size
of ri decreases linearly with i. Thus, computing all the partial remainders ri
leads to a quadratic cost, and a fast algorithm should avoid this.
However, the partial quotients qi = ri−1 div ri are usually small; the main
idea is thus to compute them without computing the partial remainders. This
can be seen as a generalization of the DoubleDigitGcd algorithm: instead of
considering a ﬁxed base β, adjust it so that the inputs have four “big words”.
The cofactor-matrix returned by the HalfBezout subroutine will then reduce
the input size to about 3n/4. A second call with the remaining two most
signiﬁcant “big words” of the new remainders will reduce their size to half
the input size. See Exercise 1.31.
The same method applies in the LSB case, and is in fact simpler to turn
into a correct algorithm. In this case, the terms ri form a binary remainder
sequence, which corresponds to the iteration of the BinaryDivide algorithm,

34
Integer arithmetic
with starting values a, b. The integer q is the binary quotient of a and b, and r
is the binary remainder.
Algorithm 1.21 BinaryDivide
Input: a, b ∈Z with ν(b) −ν(a) = j > 0
Output: |q| < 2j and r = a + q2−jb such that ν(b) < ν(r)
b′ ←2−jb
q ←−a/b′ mod 2j+1
if q ≥2j then q ←q −2j+1
return q, r = a + q2−jb.
This right-to-left division deﬁnes a right-to-left remainder sequence a0 = a,
a1 = b, . . . , where ai+1 = BinaryRemainder (ai−1, ai), and ν(ai+1) <
ν(ai). It can be shown that this sequence eventually reaches ai+1 = 0 for some
index i. Assuming ν(a) = 0, then gcd(a, b) is the odd part of ai. Indeed, in
Algorithm BinaryDivide, if some odd prime divides both a and b, it certainly
divides 2−jb, which is an integer, and thus it divides a + q2−jb. Conversely, if
some odd prime divides both b and r, it divides also 2−jb, and thus it divides
a = r−q2−jb; this shows that no spurious factor appears, unlike in some other
gcd algorithms.
EXAMPLE: let a = a0 = 935 and b = a1 = 714, so ν(b) = ν(a) + 1.
Algorithm BinaryDivide computes b′ = 357, q = 1, and a2 = a + q2−jb =
1292. The next step gives a3 = 1360, then a4 = 1632, a5 = 2176,
a6 = 0. Since 2176 = 27 · 17, we conclude that the gcd of 935 and 714 is
17. Note that the binary remainder sequence might contain negative terms and
terms larger than a, b. For example, starting from a = 19 and b = 2, we get
19, 2, 20, −8, 16, 0.
An asymptotically fast GCD algorithm with complexity O(M(n) log n) can
be constructed with Algorithm HalfBinaryGcd.
Theorem 1.9 Given a, b ∈Z with ν(a) = 0 and ν(b) > 0, and an integer
k ≥0, Algorithm HalfBinaryGcd returns an integer 0 ≤j ≤k and a matrix
R such that, if c = 2−2j(R1,1a + R1,2b) and d = 2−2j(R2,1a + R2,2b):
1. c and d are integers with ν(c) = 0 and ν(d) > 0;
2. c∗= 2jc and d∗= 2jd are two consecutive terms from the binary remain-
der sequence of a, b with ν(c∗) ≤k < ν(d∗).
Proof. We prove the theorem by induction on k. If k = 0, the algorithm re-
turns j = 0 and the identity matrix, thus we have c = a and d = b, and the

1.6 Greatest common divisor
35
Algorithm 1.22 HalfBinaryGcd
Input: a, b ∈Z with 0 = ν(a) < ν(b), a non-negative integer k
Output: an integer j and a 2 × 2 matrix R satisfying Theorem 1.9
1: if ν(b) > k then
2:
return 0,
µ 1
0
0
1
¶
3: k1 ←⌊k/2⌋
4: a1 ←a mod 22k1+1,
b1 ←b mod 22k1+1
5: j1, R ←HalfBinaryGcd(a1, b1, k1)
6: a′ ←2−2j1(R1,1a + R1,2b),
b′ ←2−2j1(R2,1a + R2,2b)
7: j0 ←ν(b′)
8: if j0 + j1 > k then
9:
return j1, R
10: q, r ←BinaryDivide(a′, b′)
11: k2 ←k −(j0 + j1)
12: a2 ←b′/2j0 mod 22k2+1,
b2 ←r/2j0 mod 22k2+1
13: j2, S ←HalfBinaryGcd(a2, b2, k2)
14: return j1 + j0 + j2, S ×
µ
0
2j0
2j0
q
¶
× R.
statement is true. Now suppose k > 0, and assume that the theorem is true up
to k −1.
The ﬁrst recursive call uses k1 < k, since k1 = ⌊k/2⌋< k. After step 5, by
induction, a′
1 = 2−2j1(R1,1a1+R1,2b1) and b′
1 = 2−2j1(R2,1a1+R2,2b1) are
integers with ν(a′
1) = 0 < ν(b′
1), and 2j1a′
1, 2j1b′
1 are two consecutive terms
from the binary remainder sequence of a1, b1. Lemma 7 of [208] says that the
quotients of the remainder sequence of a, b coincide with those of a1, b1 up to
2j1a′ and 2j1b′. This proves that 2j1a′, 2j1b′ are two consecutive terms of the
remainder sequence of a, b. Since a and a1 differ by a multiple of 22k1+1, a′
and a′
1 differ by a multiple of 22k1+1−2j1 ≥2 since j1 ≤k1 by induction. It
follows that ν(a′) = 0. Similarly, b′ and b′
1 differ by a multiple of 2, and thus
j0 = ν(b′) > 0.
The second recursive call uses k2 < k, since by induction j1 ≥0 and we
just showed j0 > 0. It easily follows that j1 + j0 + j2 > 0, and thus j ≥0. If
we exit at step 9, we have j = j1 ≤k1 < k. Otherwise j = j1 + j0 + j2 =
k −k2 + j2 ≤k by induction.
If j0 + j1 > k, we have ν(2j1b′) = j0 + j1 > k, we exit the algorithm, and
the statement holds. Now assume j0 + j1 ≤k. We compute an extra term r

36
Integer arithmetic
of the remainder sequence from a′, b′, which, up to multiplication by 2j1, is an
extra term of the remainder sequence of a, b. Since r = a′ + q2−j0b′, we have
µ b′
r
¶
= 2−j0
µ
0
2j0
2j0
q
¶ µ a′
b′
¶
.
The new terms of the remainder sequence are b′/2j0 and r/2j0, adjusted so that
ν(b′/2j0) = 0. The same argument as above holds for the second recursive
call, which stops when the 2-valuation of the sequence starting from a2, b2
exceeds k2; this corresponds to a 2-valuation larger than j0 + j1 + k2 = k for
the a, b remainder sequence.
Given two n-bit integers a and b, and k = n/2, HalfBinaryGcd yields two
consecutive elements c∗, d∗of their binary remainder sequence with bit-size
about n/2 (for their odd part).
EXAMPLE: let a = 1 889 826 700 059 and b = 421 872 857 844, with k = 20.
The ﬁrst recursive call with a1 = 1 243 931, b1 = 1 372 916, k1 = 10 gives
j1 = 8 and R =
„
352
280
260
393
«
, which corresponds to a′ = 11 952 871 683
and b′ = 10 027 328 112, with j0 = 4. The binary division yields the new
term r = 8 819 331 648, and we have k2 = 8, a2 = 52 775, b2 = 50 468.
The second recursive call gives j2 = 8 and S =
„
64
272
212
−123
«
, which ﬁnally
gives j = 20 and the matrix
„
1 444 544
1 086 512
349 084
1 023 711
«
, which corresponds to the
remainder terms r8 = 2 899 749 · 2j, r9 = 992 790 · 2j. With the same a, b
values, but with k = 41, which corresponds to the bit-size of a, we get as
ﬁnal values of the algorithm r15 = 3 · 241 and r16 = 0, which proves that
gcd(a, b) = 3.
Let H(n) be the complexity of HalfBinaryGcd for inputs of n bits and
k = n/2; a1 and b1 have ∼n/2 bits, the coefﬁcients of R have ∼n/4 bits, and
a′, b′ have ∼3n/4 bits. The remainders a2, b2 have ∼n/2 bits, the coefﬁcients
of S have ∼n/4 bits, and the ﬁnal values c, d have ∼n/2 bits. The main costs
are the matrix–vector product at step 6, and the ﬁnal matrix–matrix product.
We obtain H(n) ∼2H(n/2) + 4M(n/4, n) + 7M(n/4), assuming we use
Strassen’s algorithm to multiply two 2 × 2 matrices with 7 scalar products, i.e.
H(n) ∼2H(n/2) + 17M(n/4), assuming that we compute each M(n/4, n)
product with a single FFT transform of width 5n/4, which gives cost about
M(5n/8) ∼0.625M(n) in the FFT range. Thus, H(n) = O(M(n) log n).
For the plain gcd, we call HalfBinaryGcd with k = n, and instead of com-
puting the ﬁnal matrix product, we multiply 2−2j2S by (b′, r) – the compo-
nents have ∼n/2 bits – to obtain the ﬁnal c, d values. The ﬁrst recursive call
has a1, b1 of size n with k1
≈
n/2, and corresponds to H(n); the

1.7 Base conversion
37
matrix R and a′, b′ have n/2 bits, and k2 ≈n/2, and thus the second recursive
call corresponds to a plain gcd of size n/2. The cost G(n) satisﬁes G(n) =
H(n)+G(n/2)+4M(n/2, n)+4M(n/2) ∼H(n)+G(n/2)+10M(n/2).
Thus, G(n) = O(M(n) log n).
An application of the half-gcd per se in the MSB case is the rational recon-
struction problem. Assume we want to compute a rational p/q, where p and q
are known to be bounded by some constant c. Instead of computing with ratio-
nals, we may perform all computations modulo some integer n > c2. Hence,
we will end up with p/q = m mod n, and the problem is now to ﬁnd the un-
known p and q from the known integer m. To do this, we start an extended
gcd from m and n, and we stop as soon as the current a and u values – as in
ExtendedGcd – are smaller than c: since we have a = um + vn, this gives
m = a/u mod n. This is exactly what is called a half-gcd; a subquadratic
version in the LSB case is given above.
1.7 Base conversion
Since computers usually work with binary numbers, and human prefer decimal
representations, input/output base conversions are needed. In a typical com-
putation, there are only a few conversions, compared to the total number of
operations, so optimizing conversions is less important than optimizing other
aspects of the computation. However, when working with huge numbers, naive
conversion algorithms may slow down the whole computation.
In this section, we consider that numbers are represented internally in base
β – usually a power of 2 – and externally in base B – say a power of ten. When
both bases are commensurable, i.e. both are powers of a common integer, such
as β = 8 and B = 16, conversions of n-digit numbers can be performed
in O(n) operations. We assume here that β and B are not commensurable.
We might think that only one algorithm is needed, since input and output are
symmetric by exchanging bases β and B. Unfortunately, this is not true, since
computations are done only in base β (see Exercise 1.37).
1.7.1 Quadratic algorithms
Algorithms IntegerInput and IntegerOutput, respectively, read and write
n-word integers, both with a complexity of O(n2).

38
Integer arithmetic
Algorithm 1.23 IntegerInput
Input: a string S = sm−1 . . . s1s0 of digits in base B
Output: the value A in base β of the integer represented by S
A ←0
for i from m −1 downto 0 do
A ←BA + val(si)
⊲val(si) is the value of si in base β
return A.
Algorithm 1.24 IntegerOutput
Input: A = Pn−1
0
aiβi > 0
Output: a string S of characters, representing A in base B
m ←0
while A ̸= 0 do
sm ←char(A mod B)
⊲sm: character corresponding to A mod B
A ←A div B
m ←m + 1
return S = sm−1 . . . s1s0.
1.7.2 Subquadratic algorithms
Fast conversion routines are obtained using a “divide and conquer” strategy.
Given two strings s and t, we let s || t denote the concatenation of s and t. For
integer input, if the given string decomposes as S = Shi || Slo, where Slo has
k digits in base B, then
Input(S, B) = Input(Shi, B)Bk + Input(Slo, B),
where Input(S, B) is the value obtained when reading the string S in the
external base B. Algorithm FastIntegerInput shows one way to implement
this: if the output A has n words, Algorithm FastIntegerInput has complexity
O(M(n) log n), more precisely ∼M(n/4) lg n for n a power of two in the
FFT range (see Exercise 1.34).
For integer output, a similar algorithm can be designed, replacing multipli-
cations by divisions. Namely, if A = AhiBk + Alo, then
Output(A, B) = Output(Ahi, B) || Output(Alo, B),
where Output(A, B) is the string resulting from writing the integer A in the
external base B, and it is assumed that Output(Alo, B) has exactly k digits,
after possibly padding with leading zeros.
If the input A has n words, Algorithm FastIntegerOutput has complexity

1.8 Exercises
39
Algorithm 1.25 FastIntegerInput
Input: a string S = sm−1 . . . s1s0 of digits in base B
Output: the value A of the integer represented by S
ℓ←[val(s0), val(s1), . . . , val(sm−1)]
(b, k) ←(B, m)
⊲Invariant: ℓhas k elements ℓ0, . . . , ℓk−1
while k > 1 do
if k even then ℓ←[ℓ0 + bℓ1, ℓ2 + bℓ3, . . . , ℓk−2 + bℓk−1]
else ℓ←[ℓ0 + bℓ1, ℓ2 + bℓ3, . . . , ℓk−1]
(b, k) ←(b2, ⌈k/2⌉)
return ℓ0.
Algorithm 1.26 FastIntegerOutput
Input: A = Pn−1
0
aiβi
Output: a string S of characters, representing A in base B
if A < B then
return char(A)
else
ﬁnd k such that B2k−2 ≤A < B2k
(Q, R) ←DivRem(A, Bk)
r ←FastIntegerOutput(R)
return FastIntegerOutput(Q) || 0k−len(r) || r.
O(M(n) log n), more precisely ∼D(n/4) lg n for n a power of two in the
FFT range, where D(n) is the cost of dividing a 2n-word integer by an n-
word integer. Depending on the cost ratio between multiplication and division,
integer output may thus be from two to ﬁve times slower than integer input;
see however Exercise 1.35.
1.8 Exercises
Exercise 1.1 Extend the Kronecker–Sch¨onhage trick mentioned at the begin-
ning of §1.3 to negative coefﬁcients, assuming the coefﬁcients are in the range
[−ρ, ρ].
Exercise 1.2 (Harvey [114]) For multiplying two polynomials of degree less
than n, with non-negative integer coefﬁcients bounded above by ρ, the
Kronecker–Sch¨onhage trick performs one integer multiplication of size about
2n lg ρ, assuming n is small compared to ρ. Show that it is possible to perform

40
Integer arithmetic
two integer multiplications of size n lg ρ instead, and even four integer multi-
plications of size (n/2) lg ρ.
Exercise 1.3 Assume your processor provides an instruction fmaa(a, b, c, d)
returning h, ℓsuch that ab + c + d = hβ + ℓ, where 0 ≤a, b, c, d, ℓ, h < β.
Rewrite Algorithm BasecaseMultiply using fmaa.
Exercise 1.4 (Harvey, Khachatrian et al.[138]) For A = Pn−1
i=0 aiβi and
B = Pn−1
j=0 biβi, prove the formula
AB =
n−1
X
i=1
i−1
X
j=0
(ai + aj)(bi + bj)βi+j + 2
n−1
X
i=0
aibiβ2i −
n−1
X
i=0
βi
n−1
X
j=0
ajbjβj.
Deduce a new algorithm for schoolbook multiplication.
Exercise 1.5 (Hanrot) Prove that the number K(n) of word-products (as de-
ﬁned in the proof of Thm. 1.2) in Karatsuba’s algorithm is non-decreasing,
provided n0 = 2. Plot the graph of K(n)/nlg 3 with a logarithmic scale for n,
for 27 ≤n ≤210, and ﬁnd experimentally where the maximum appears.
Exercise 1.6 (Ryde) Assume the basecase multiply costs M(n) = an2 + bn,
and that Karatsuba’s algorithm costs K(n) = 3K(n/2)+cn. Show that divid-
ing a by two increases the Karatsuba threshold n0 by a factor of two, and on
the contrary decreasing b and c decreases n0.
Exercise 1.7 (Maeder [157], Thom´e [215]) Show that an auxiliary memory
of 2n + o(n) words is enough to implement Karatsuba’s algorithm in-place,
for an n-word×n-word product. In the polynomial case, prove that an auxiliary
space of n coefﬁcients is enough, in addition to the n + n coefﬁcients of the
input polynomials, and the 2n −1 coefﬁcients of the product. [You can use the
2n result words, but must not destroy the n + n input words.]
Exercise 1.8 (Roche [190]) If Exercise 1.7 was too easy for you, design a
Karatsuba-like algorithm using only O(log n) extra space (you are allowed to
read and write in the 2n output words, but the n+n input words are read-only).
Exercise 1.9 (Quercia, McLaughlin)Modify Algorithm KaratsubaMultiply
to use only ∼7n/2 additions/subtractions. [Hint: decompose each of C0, C1
and C2 into two parts.]
Exercise 1.10 Design an in-place version of KaratsubaMultiply (see Exer-
cise 1.7) that accumulates the result in c0, . . . , cn−1, and returns a carry bit.

1.8 Exercises
41
Exercise 1.11 (Vuillemin) Design an algorithm to multiply a2x2+a1x+a0 by
b1x + b0 using 4 multiplications. Can you extend it to a 6 × 6 product using 16
multiplications?
Exercise 1.12 (Weimerskirch, Paar) Extend the Karatsuba trick to compute
an n × n product in n(n + 1)/2 multiplications. For which n does this win
over the classical Karatsuba algorithm?
Exercise 1.13 (Hanrot) In Algorithm OddEvenKaratsuba, if both m and n
are odd, we combine the larger parts A0 and B0 together, and the smaller parts
A1 and B1 together. Find a way to get instead
K(m, n) = K(⌈m/2⌉, ⌊n/2⌋) + K(⌊m/2⌋, ⌈n/2⌉) + K(⌈m/2⌉, ⌈n/2⌉).
Exercise 1.14 Prove that if ﬁve integer evaluation points are used for Toom–
Cook 3-way (§1.3.3), the division by (a multiple of) three can not be avoided.
Does this remain true if only four integer points are used together with ∞?
Exercise 1.15 (Quercia, Harvey) In Toom–Cook 3-way (§1.3.3), take as eval-
uation point 2w instead of 2, where w is the number of bits per word (usually
w = 32 or 64). Which division is then needed? Similarly for the evaluation
point 2w/2.
Exercise 1.16 For an integer k ≥2 and multiplication of two numbers of size
kn and n, show that the trivial strategy which performs k multiplications, each
n × n, is not the best possible in the FFT range.
Exercise 1.17 (Karatsuba, Zuras [235]) Assuming the multiplication has
superlinear cost, show that the speedup of squaring with respect to multipli-
cation can not signiﬁcantly exceed 2.
Exercise 1.18 (Thom´e, Quercia) Consider two sets A = {a, b, c, . . .} and
U = {u, v, w, . . .}, and a set X = {x, y, z, . . .} of sums of products of el-
ements of A and U (assumed to be in some ﬁeld F). We can ask “what is
the least number of multiplies required to compute all elements of X?”. In
general, this is a difﬁcult problem, related to the problem of computing tensor
rank, which is NP-complete (see for example H˚astad [119] and the book by
B¨urgisser et al. [60]). Special cases include integer/polynomial multiplication,
the middle product, and matrix multiplication (for matrices of ﬁxed size). As a
speciﬁc example, can we compute x = au + cw, y = av + bw, z = bu + cv in
fewer than six multiplies? Similarly for x = au−cw, y = av−bw, z = bu−cv.
Exercise 1.19 In Algorithm BasecaseDivRem (§1.4.1), prove that q∗
j ≤β+1.
Can this bound be reached? In the case q∗
j ≥β, prove that the while-loop at

42
Integer arithmetic
steps 6–8 is executed at most once. Prove that the same holds for Svoboda’s
algorithm, i.e. that A ≥0 after step 8 of Algorithm SvobodaDivision (§1.4.2).
Exercise 1.20 (Granlund, M¨oller) In Algorithm BasecaseDivRem, estimate
the probability that A < 0 is true at step 6, assuming the remainder rj from the
division of an+jβ + an+j−1 by bn−1 is uniformly distributed in [0, bn−1 −1],
A mod βn+j−1 is uniformly distributed in [0, βn+j−1 −1], and B mod βn−1
is uniformly distributed in [0, βn−1−1]. Then replace the computation of q∗
j by
a division of the three most signiﬁcant words of A by the two most signiﬁcant
words of B. Prove the algorithm is still correct. What is the maximal number
of corrections, and the probability that A < 0?
Exercise 1.21 (Montgomery [171]) Let 0 < b < β, and 0 ≤a4, . . . , a0 < β.
Prove that a4(β4 mod b) + · · · + a1(β mod b) + a0 < β2, provided b < β/3.
Use this fact to design an efﬁcient algorithm dividing A = an−1βn−1+· · ·+a0
by b. Does the algorithm extend to division by the least signiﬁcant digits?
Exercise 1.22 In Algorithm RecursiveDivRem, ﬁnd inputs that require 1, 2, 3
or 4 corrections in step 8. [Hint: consider β = 2.] Prove that when n = m and
A < βm(B + 1), at most two corrections occur.
Exercise 1.23 Find the complexity of Algorithm RecursiveDivRem in the
FFT range.
Exercise 1.24 Consider the division of A of kn words by B of n words, with
integer k ≥3, and the alternate strategy that consists of extending the divisor
with zeros so that it has half the size of the dividend. Show that this is al-
ways slower than Algorithm UnbalancedDivision (assuming that division has
superlinear cost).
Exercise 1.25 An important special base of division is when the divisor is of
the form bk. For example, this is useful for an integer output routine (§1.7).
Can a fast algorithm be designed for this case?
Exercise 1.26 (Sedoglavic) Does the Kronecker–Sch¨onhage trick to reduce
polynomial multiplication to integer multiplication (§1.3) also work – in an
efﬁcient way – for division? Assume that you want to divide a degree-2n poly-
nomial A(x) by a monic degree-n polynomial B(x), both polynomials having
integer coefﬁcients bounded by ρ.
Exercise 1.27 Design an algorithm that performs an exact division of a 4n-bit
integer by a 2n-bit integer, with a quotient of 2n bits, using the idea mentioned
in the last paragraph of §1.4.5. Prove that your algorithm is correct.

1.8 Exercises
43
Exercise 1.28 Improve the initial speed of convergence of Algorithm SqrtInt
(§1.5.1) by using a better starting approximation at step 1. Your approximation
should be in the interval [⌊√m⌋, ⌈2√m⌉].
Exercise 1.29 (Luschny) Devise a fast algorithm for computing the binomial
coefﬁcient
C(n, k) =
µn
k
¶
=
n!
k!(n −k)!
for integers n, k, 0 ≤k ≤n. The algorithm should use exact integer arithmetic
and compute the exact answer.
Exercise 1.30 (Shoup) Show that in Algorithm ExtendedGcd, if a ≥b > 0,
and g = gcd(a, b), then the cofactor u satisﬁes −b/(2g) < u ≤b/(2g).
Exercise 1.31 (a) Devise a subquadratic GCD algorithm HalfGcd along the
lines outlined in the ﬁrst three paragraphs of §1.6.3 (most-signiﬁcant bits ﬁrst).
The input is two integers a ≥b > 0. The output is a 2 × 2 matrix R and
integers a′, b′ such that [a′ b′]t = R[a b]t. If the inputs have size n bits, then the
elements of R should have at most n/2+O(1) bits, and the outputs a′, b′ should
have at most 3n/4 + O(1) bits. (b) Construct a plain GCD algorithm which
calls HalfGcd until the arguments are small enough to call a naive algorithm.
(c) Compare this approach with the use of HalfBinaryGcd in §1.6.3.
Exercise 1.32 (Galbraith, Sch¨onhage, Stehl´e) The Jacobi symbol (a|b) of an
integer a and a positive odd integer b satisﬁes (a|b) = (a mod b|b), the law
of quadratic reciprocity (a|b)(b|a) = (−1)(a−1)(b−1)/4 for a odd and posi-
tive, together with (−1|b) = (−1)(b−1)/2, and (2|b) = (−1)(b2−1)/8. This
looks very much like the gcd recurrence: gcd(a, b) = gcd(a mod b, b) and
gcd(a, b) = gcd(b, a). Design an O(M(n) log n) algorithm to compute the
Jacobi symbol of two n-bit integers.
Exercise 1.33 Show that B and β are commensurable, in the sense deﬁned in
§1.7, iff ln(B)/ ln(β) ∈Q.
Exercise 1.34 Find a formula T(n) for the asymptotic complexity of Algo-
rithm FastIntegerInput when n = 2k (§1.7.2). Show that, for general n, the
formula is within a factor of two of T(n). [Hint: consider the binary expansion
of n.]
Exercise 1.35 Show that the integer output routine can be made as fast (asymp-
totically) as the integer input routine FastIntegerInput. Do timing experi-
ments with your favorite multiple-precision software. [Hint: use D. Bernstein’s
scaled remainder tree [21] and the middle product.]

44
Integer arithmetic
Exercise 1.36 If the internal base β and the external base B share a nontrivial
common divisor – as in the case β = 2ℓand B = 10 – show how we can
exploit this to speed up the subquadratic input and output routines.
Exercise 1.37 Assume you are given two n-digit integers in base ten, but you
have implemented fast arithmetic only in base two. Can you multiply the inte-
gers in time O(M(n))?
1.9 Notes and references
“On-line” (as opposed to “off-line”) algorithms are considered in many books
and papers, see for example the book by Borodin and El-Yaniv [33].
“Relaxed” algorithms were introduced by van der Hoeven. For references and
a discussion of the differences between “lazy”, “zealous”, and “relaxed” algo-
rithms, see [124].
An example of an implementation with “guard bits” to avoid overﬂow prob-
lems in integer addition (§1.2) is the block-wise modular arithmetic of Lenstra
and Dixon on the MasPar [87]. They used β = 230 with 32-bit words.
The observation that polynomial multiplication reduces to integer multi-
plication is due to both Kronecker and Sch¨onhage, which explains the name
“Kronecker–Sch¨onhage trick”. More precisely, Kronecker [146, pp. 941–942]
(also [147, §4]) reduced the irreducibility test for factorization of multivariate
polynomials to the univariate case, and Sch¨onhage [196] reduced the univari-
ate case to the integer case. The Kronecker–Sch¨onhage trick is improved in
Harvey [114] (see Exercise 1.2), and some nice applications of it are given in
Steel [206].
Karatsuba’s algorithm was ﬁrst published in [136]. Very little is known about
its average complexity. What is clear is that no simple asymptotic equivalent
can be obtained, since the ratio K(n)/nα does not converge (see Exercise 1.5).
Andrei Toom [217] discovered the class of Toom–Cook algorithms, and they
were discussed by Stephen Cook in his thesis [76, pp. 51–77]. A very good de-
scription of these algorithms can be found in the book by Crandall and Pomer-
ance [81, §9.5.1]. In particular, it describes how to generate the evaluation and
interpolation formulæ symbolically. Zuras [235] considers the 4-way and 5-
way variants, together with squaring. Bodrato and Zanoni [31] show that the
Toom–Cook 3-way interpolation scheme of §1.3.3 is close to optimal for the
points 0, 1, −1, 2, ∞; they also exhibit efﬁcient 4-way and 5-way schemes.
Bodrato and Zanoni also introduced the Toom-2.5 and Toom-3.5 notations for
what we call Toom-(3, 2) and Toom-(4, 3), these algorithms being useful for

1.9 Notes and references
45
unbalanced multiplication using a different number of pieces. They noticed
that Toom-(4, 2) only differs from Toom 3-way in the evaluation phase, thus
most of the implementation can be shared.
The Sch¨onhage–Strassen algorithm ﬁrst appeared in [199], and is described
in §2.3.3. Algorithms using ﬂoating-point complex numbers are discussed in
Knuth’s classic [142, §4.3.3.C]. See also §3.3.1.
The odd–even scheme is described in Hanrot and Zimmermann [112], and
was independently discovered by Andreas Enge. The asymmetric squaring for-
mula given in §1.3.6 was invented by Chung and Hasan (see their paper [66]
for other asymmetric formulæ). Exercise 1.4 was suggested by David Harvey,
who independently discovered the algorithm of Khachatrian et al. [138].
See Lef`evre [152] for a comparison of different algorithms for the problem
of multiplication by an integer constant.
Svoboda’s algorithm was introduced in [211]. The exact division algorithm
starting from least signiﬁcant bits is due to Jebelean [130]. Jebelean and
Krandick invented the “bidirectional” algorithm [144]. The Karp–Markstein
trick to speed up Newton’s iteration (or Hensel lifting over p-adic numbers)
is described in [137]. The “recursive division” of §1.4.3 is from Burnikel and
Ziegler [61], although earlier but not-so-detailed ideas can be found in Jebe-
lean [132], and even earlier in Moenck and Borodin [166]. The deﬁnition of
Hensel’s division used here is due to Shand and Vuillemin [201], who also
point out the duality with Euclidean division.
Algorithm SqrtRem (§1.5.1) was ﬁrst described in Zimmermann [234], and
proved correct in Bertot et al. [29]. Algorithm SqrtInt is described in Cohen
[73]; its generalization to kth roots (Algorithm RootInt) is due to Keith Briggs.
The detection of exact powers is discussed in Bernstein, Lenstra, and Pila [23]
and earlier in Bernstein [17] and Cohen [73]. It is necessary, for example, in
the AKS primality test of Agrawal, Kayal, and Saxena [2].
The classical (quadratic) Euclidean algorithm has been considered by many
authors – a good reference is Knuth [142]. The Gauss–Kuz’min theorem2 gives
the distribution of quotients in the regular continued fraction of almost all real
numbers, and hence is a good guide to the distribution of quotients in the Eu-
clidean algorithm for large, random inputs. Lehmer’s original algorithm is de-
scribed in [154]. The binary gcd is almost as old as the classical Euclidean
algorithm – Knuth [142] has traced it back to a ﬁrst-century AD Chinese text
Chiu Chang Suan Shu (see also Mikami [165]). It was rediscovered several
times in the 20th century, and it is usually attributed to Stein [209]. The bi-
nary gcd has been analysed by Brent [44, 50], Knuth [142], Maze [159], and
2 According to the Gauss–Kuz’min theorem [139], the probability of a quotient q ∈N∗is
lg(1 + 1/q) −lg(1 + 1/(q + 1)).

46
Integer arithmetic
Vall´ee [221]. A parallel (systolic) version that runs in O(n) time using O(n)
processors was given by Brent and Kung [53].
The double-digit gcd is due to Jebelean [131]. The k-ary gcd reduction is
due to Sorenson [205], and was improved and implemented in GNU MP by
Weber. Weber also invented Algorithm ReducedRatMod [226], inspired by
previous work of Wang.
The ﬁrst subquadratic gcd algorithm was published by Knuth [141], but his
complexity analysis was suboptimal – he gave O(n log5 n log log n). The cor-
rect complexity O(n log2 n log log n) was given by Sch¨onhage [195]; for this
reason the algorithm is sometimes called the Knuth–Sch¨onhage algorithm.
A description for the polynomial case can be found in Aho, Hopcroft, and
Ullman [3], and a detailed (but incorrect) description for the integer case in
Yap [232]. The subquadratic binary gcd given in §1.6.3 is due to Stehl´e and
Zimmermann [208]. M¨oller [168] compares various subquadratic algorithms,
and gives a nice algorithm without “repair steps”.
Several authors mention an O(n log2 n log log n) algorithm for the compu-
tation of the Jacobi symbol: e.g. Eikenberry and Sorenson [89] and Shallit and
Sorenson [200]. The earliest reference that we know is a paper by Bach [8],
which gives the basic idea (due to Gauss [101, p. 509]). Details are given in
the book by Bach and Shallit [9, Solution of Exercise 5.52], where the algo-
rithm is said to be “folklore”, with the ideas going back to Bachmann [10]
and Gauss. The existence of such an algorithm is mentioned in Sch¨onhage’s
book [198, §7.2.3], but without details. See also Brent and Zimmermann [57]
and Exercise 1.32.

2
Modular arithmetic and the FFT
In this chapter our main topic is modular arithmetic, i.e. how
to compute efﬁciently modulo a given integer N. In most appli-
cations, the modulus N is ﬁxed, and special-purpose algorithms
beneﬁt from some precomputations, depending only on N, to
speed up arithmetic modulo N.
There is an overlap between Chapter 1 and this chapter. For ex-
ample, integer division and modular multiplication are closely re-
lated. In Chapter 1 we present algorithms where no (or only a few)
precomputations with respect to the modulus N are performed. In
this chapter, we consider algorithms which beneﬁt from such pre-
computations.
Unless explicitly stated, we consider that the modulus N occupies
n words in the word-base β, i.e. βn−1 ≤N < βn.
2.1 Representation
We consider in this section the different possible representations of residues
modulo N. As in Chapter 1, we consider mainly dense representations.
2.1.1 Classical representation
The classical representation stores a residue (class) a as an integer 0 ≤a < N.
Residues are thus always fully reduced, i.e. in canonical form.
Another non-redundant form consists in choosing a symmetric representa-
tion, say −N/2 ≤a < N/2. This form might save some reductions in addi-
tions or subtractions (see §2.2). Negative numbers might be stored either with
a separate sign (sign-magnitude representation) or with a two’s-complement
representation.

48
Modular arithmetic and the FFT
Since N takes n words in base β, an alternative redundant representation
chooses 0 ≤a < βn to represent a residue class. If the underlying arithmetic
is word-based, this will yield no slowdown compared to the canonical form.
An advantage of this representation is that, when adding two residues, it suf-
ﬁces to compare their sum to βn in order to decide whether the sum has to
be reduced, and the result of this comparison is simply given by the carry bit
of the addition (see Algorithm 1.1 IntegerAddition), instead of by comparing
the sum with N. However, in the case that the sum has to be reduced, one or
more further comparisons are needed.
2.1.2 Montgomery’s form
Montgomery’s form is another representation widely used when several mod-
ular operations have to be performed modulo the same integer N (additions,
subtractions, modular multiplications). It implies a small overhead to convert –
if needed – from the classical representation to Montgomery’s and vice-versa,
but this overhead is often more than compensated by the speedup obtained in
the modular multiplication.
The main idea is to represent a residue a by a′ = aR mod N, where
R = βn, and N takes n words in base β. Thus Montgomery is not concerned
with the physical representation of a residue class, but with the meaning as-
sociated to a given physical representation. (As a consequence, the different
choices mentioned above for the physical representation are all possible.) Ad-
dition and subtraction are unchanged, but (modular) multiplication translates
to a different, much simpler, algorithm MontgomeryMul (see §2.4.2).
In most applications using Montgomery’s form, all inputs are ﬁrst converted
to Montgomery’s form, using a′ = aR mod N, then all computations are per-
formed in Montgomery’s form, and ﬁnally all outputs are converted back – if
needed – to the classical form, using a = a′/R mod N. We need to assume
that (R, N) = 1, or equivalently that (β, N) = 1, to ensure the existence of
1/R mod N. This is not usually a problem because β is a power of two and
N can be assumed to be odd.
2.1.3 Residue number systems
In a residue number system (RNS), a residue a is represented by a list of
residues ai modulo Ni, where the moduli Ni are coprime and their product is
N. The integers ai can be efﬁciently computed from a using a remainder tree,
and the unique integer 0 ≤a < N = N1N2 · · · is computed from the ai by an

2.1 Representation
49
explicit Chinese remainder theorem (§2.7). The residue number system is inter-
esting since addition and multiplication can be performed in parallel on each
small residue ai. This representation requires that N factors into convenient
moduli N1, N2, . . ., which is not always the case (see however §2.9). Conver-
sion to/from the RNS representation costs O(M(n) log n), see §2.7.
2.1.4 MSB vs LSB algorithms
Many classical (most signiﬁcant bits ﬁrst or MSB) algorithms have a p-adic
(least signiﬁcant bits ﬁrst or LSB) equivalent form. Thus several algorithms in
this chapter are just LSB-variants of algorithms discussed in Chapter 1 – see
Table 2.1 below.
classical (MSB)
p-adic (LSB)
Euclidean division
Hensel division, Montgomery reduction
Svoboda’s algorithm
Montgomery–Svoboda
Euclidean gcd
binary gcd
Newton’s method
Hensel lifting
Table 2.1 Equivalence between LSB and MSB algorithms.
2.1.5 Link with polynomials
As in Chapter 1, a strong link exists between modular arithmetic and arith-
metic on polynomials. One way of implementing ﬁnite ﬁelds Fq with q = pn
elements is to work with polynomials in Fp[x], which are reduced modulo a
monic irreducible polynomial f(x) ∈Fp[x] of degree n. In this case, modular
reduction happens both at the coefﬁcient level (in Fp) and at the polynomial
level (modulo f(x)).
Some algorithms work in the ring (Z/NZ)[x], where N is a composite in-
teger. An important case is the Sch¨onhage–Strassen multiplication algorithm,
where N has the form 2ℓ+ 1.
In both domains Fp[x] and (Z/NZ)[x], the Kronecker–Sch¨onhage trick
(§1.3) can be applied efﬁciently. Since the coefﬁcients are known to be bounded,
by p and N respectively, and thus have a ﬁxed size, the segmentation is quite
efﬁcient. If polynomials have degree d and coefﬁcients are bounded by N,
the product coefﬁcients are bounded by dN 2, and we have O(M(d log(Nd)))
operations, instead of O(M(d)M(log N)) with the classical approach. Also,
the implementation is simpler, because we only have to implement fast

50
Modular arithmetic and the FFT
arithmetic for large integers instead of fast arithmetic at both the polynomial
level and the coefﬁcient level (see also Exercises 1.2 and 2.4).
2.2 Modular addition and subtraction
The addition of two residues in classical representation can be done as in
Algorithm ModularAdd.
Algorithm 2.1 ModularAdd
Input: residues a, b with 0 ≤a, b < N
Output: c = a + b mod N
c ←a + b
if c ≥N then
c ←c −N.
Assuming that a and b are uniformly distributed in Z ∩[0, N −1], the sub-
traction c ←c −N is performed with probability (1 −1/N)/2. If we use
instead a symmetric representation in [−N/2, N/2), the probability that we
need to add or subtract N drops to 1/4 + O(1/N 2) at the cost of an additional
test. This extra test might be expensive for small N – say one or two words –
but should be relatively cheap if N is large enough, say at least ten words.
2.3 The Fourier transform
In this section, we introduce the discrete Fourier transform (DFT). An impor-
tant application of the DFT is in computing convolutions via the Convolution
Theorem. In general, the convolution of two vectors can be computed using
three DFTs (for details see §2.9). Here we show how to compute the DFT ef-
ﬁciently (via the fast Fourier transform or FFT), and show how it can be used
to multiply two n-bit integers in time O(n log n log log n) (the Sch¨onhage–
Strassen algorithm, see §2.3.3).
2.3.1 Theoretical setting
Let R be a ring, K ≥2 an integer, and ω a principal Kth root of unity in
R, i.e. such that ωK = 1 and PK−1
j=0 ωij = 0 for 1 ≤i < K. The Fourier
transform (or forward (Fourier) transform) of a vector a = [a0, a1, . . . , aK−1]

2.3 The Fourier transform
51
of K elements from R is the vector ba = [ba0, ba1, . . . , baK−1] such that
bai =
K−1
X
j=0
ωijaj.
(2.1)
If we transform the vector a twice, we get back to the initial vector, apart
from a multiplicative factor K and a permutation of the elements of the vector.
Indeed, for 0 ≤i < K
bbai =
K−1
X
j=0
ωijbaj =
K−1
X
j=0
ωij
K−1
X
ℓ=0
ωjℓaℓ=
K−1
X
ℓ=0
aℓ


K−1
X
j=0
ω(i+ℓ)j

.
Let τ = ωi+ℓ. If i+ℓ̸= 0 mod K, i.e. if i+ℓis not 0 or K, the sum PK−1
j=0 τ j
vanishes since ω is principal. For i + ℓ∈{0, K}, we have τ = 1 and the sum
equals K. It follows that
bbai = K
K−1
X
ℓ=0
i+ℓ∈{0,K}
aℓ= Ka(−i) mod K.
Thus, we have bba = K[a0, aK−1, aK−2, . . . , a2, a1].
If we transform the vector a twice, but use ω−1 instead of ω for the second
transform (which is then called a backward transform), we get
ebai =
K−1
X
j=0
ω−ijbaj =
K−1
X
j=0
ω−ij
K−1
X
ℓ=0
ωjℓaℓ=
K−1
X
ℓ=0
aℓ


K−1
X
j=0
ω(ℓ−i)j

.
The sum PK−1
j=0 ω(ℓ−i)j vanishes unless ℓ= i, in which case it equals K.
Thus, we have ebai = Kai. Apart from the multiplicative factor K, the backward
transform is the inverse of the forward transform, as might be expected from
the names.
2.3.2 The fast Fourier transform
If evaluated naively, Eqn. (2.1) requires Ω(K2) operations to compute the
Fourier transform of a vector of K elements. The fast Fourier transform or
FFT is an efﬁcient way to evaluate Eqn. (2.1) using only O(K log K) oper-
ations. From now on we assume that K is a power of two, since this is the
most common case and simpliﬁes the description of the FFT (see §2.9 for the
general case).

52
Modular arithmetic and the FFT
Let us illustrate the FFT for K = 8. Since ω8 = 1, we have reduced the
exponents modulo 8 in the following. We want to compute
ba0 = a0 + a1 + a2 + a3 + a4 + a5 + a6 + a7,
ba1 = a0 + ωa1 + ω2a2 + ω3a3 + ω4a4 + ω5a5 + ω6a6 + ω7a7,
ba2 = a0 + ω2a1 + ω4a2 + ω6a3 + a4 + ω2a5 + ω4a6 + ω6a7,
ba3 = a0 + ω3a1 + ω6a2 + ωa3 + ω4a4 + ω7a5 + ω2a6 + ω5a7,
ba4 = a0 + ω4a1 + a2 + ω4a3 + a4 + ω4a5 + a6 + ω4a7,
ba5 = a0 + ω5a1 + ω2a2 + ω7a3 + ω4a4 + ωa5 + ω6a6 + ω3a7,
ba6 = a0 + ω6a1 + ω4a2 + ω2a3 + a4 + ω6a5 + ω4a6 + ω2a7,
ba7 = a0 + ω7a1 + ω6a2 + ω5a3 + ω4a4 + ω3a5 + ω2a6 + ωa7.
We see that we can share some computations. For example, the sum a0 + a4
appears in four places: in ba0, ba2, ba4, and ba6. Let us deﬁne a0,4 = a0 + a4,
a1,5 = a1 + a5, a2,6 = a2 + a6, a3,7 = a3 + a7, a4,0 = a0 + ω4a4, a5,1 =
a1 + ω4a5, a6,2 = a2 + ω4a6, a7,3 = a3 + ω4a7. Then we have, using the fact
that ω8 = 1
ba0 = a0,4 + a1,5 + a2,6 + a3,7,
ba1 = a4,0 + ωa5,1 + ω2a6,2 + ω3a7,3,
ba2 = a0,4 + ω2a1,5 + ω4a2,6 + ω6a3,7,
ba3 = a4,0 + ω3a5,1 + ω6a6,2 + ωa7,3,
ba4 = a0,4 + ω4a1,5 + a2,6 + ω4a3,7,
ba5 = a4,0 + ω5a5,1 + ω2a6,2 + ω7a7,3,
ba6 = a0,4 + ω6a1,5 + ω4a2,6 + ω2a3,7,
ba7 = a4,0 + ω7a5,1 + ω6a6,2 + ω5a7,3.
Now the sum a0,4 + a2,6 appears at two different places. Let a0,4,2,6 = a0,4 +
a2,6, a1,5,3,7 = a1,5 + a3,7, a2,6,0,4 = a0,4 + ω4a2,6, a3,7,1,5 = a1,5 + ω4a3,7,
a4,0,6,2 = a4,0 + ω2a6,2, a5,1,7,3 = a5,1 + ω2a7,3, a6,2,4,0 = a4,0 + ω6a6,2,
a7,3,5,1 = a5,1 + ω6a7,3. Then we have
ba0
=
a0,4,2,6 + a1,5,3,7,
ba1
=
a4,0,6,2 + ωa5,1,7,3,
ba2
=
a2,6,0,4 + ω2a3,7,1,5,
ba3
=
a6,2,4,0 + ω3a7,3,5,1,
ba4
=
a0,4,2,6 + ω4a1,5,3,7,
ba5
=
a4,0,6,2 + ω5a5,1,7,3,
ba6
=
a2,6,0,4 + ω6a3,7,1,5,
ba7
=
a6,2,4,0 + ω7a7,3,5,1.
In summary, after a ﬁrst stage where we have computed eight intermediary
variables a0,4 to a7,3, and a second stage with eight extra intermediary vari-
ables a0,4,2,6 to a7,3,5,1, we are able to compute the transformed vector in eight
extra steps. The total number of steps is thus 24 = 8 lg 8, where each step has
the form a ←b + ωjc.
If we take a closer look, we can group operations in pairs (a, a′), which have
the form a = b + ωjc and a′ = b + ωj+4c. For example, in the ﬁrst stage we
have a1,5 = a1 + a5 and a5,1 = a1 + ω4a5; in the second stage we have
a4,0,6,2 = a4,0 +ω2a6,2 and a6,2,4,0 = a4,0 +ω6a6,2. Since ω4 = −1, this can

2.3 The Fourier transform
53
also be written (a, a′) = (b + ωjc, b −ωjc), where ωjc needs to be computed
only once. A pair of two such operations is called a butterﬂy operation.
The FFT can be performed in place. Indeed, the result of the butterﬂy
between a0 and a4, i.e (a0,4, a4,0) = (a0+a4, a0−a4), can overwrite (a0, a4),
since the values of a0 and a4 are no longer needed.
Algorithm ForwardFFT is a recursive and in-place implementation of the
forward FFT. It uses an auxiliary function bitrev(j, K), which returns the bit-
reversal of the integer j, considered as an integer of lg K bits. For example,
bitrev(j, 8) gives 0, 4, 2, 6, 1, 5, 3, 7 for j = 0, . . . , 7.
Algorithm 2.2 ForwardFFT
Input: vector a = [a0, a1, . . . , aK−1], ω principal Kth root of unity, K = 2k
Output: in-place transformed vector ba, bit-reversed
1: if K = 2 then
2:
[a0, a1] ←[a0 + a1, a0 −a1]
3: else
4:
[a0, a2, ..., aK−2] ←ForwardFFT([a0, a2, ..., aK−2], ω2, K/2)
5:
[a1, a3, ..., aK−1] ←ForwardFFT([a1, a3, ..., aK−1], ω2, K/2)
6:
for j from 0 to K/2 −1 do
7:
[a2j, a2j+1] ←[a2j + ωbitrev(j,K/2)a2j+1, a2j −ωbitrev(j,K/2)a2j+1].
Theorem 2.1 Given an input vector a = [a0, a1, . . . , aK−1], Algorithm
ForwardFFT replaces it by its Fourier transform, in bit-reverse order, in
O(K log K) operations in the ring R.
Proof. We prove the statement by induction on K = 2k. For K = 2, the
Fourier transform of [a0, a1] is [a0 + a1, a0 + ωa1], and the bit-reverse order
coincides with the normal order; since ω = −1, the statement follows. Now
assume the statement is true for K/2. Let 0 ≤j < K/2, and write j′ :=
bitrev(j, K/2). Let b = [b0, ..., bK/2−1] be the vector obtained at step 4, and
c = [c0, ..., cK/2−1] be the vector obtained at step 5. By induction
bj =
K/2−1
X
ℓ=0
ω2j′ℓa2ℓ,
cj =
K/2−1
X
ℓ=0
ω2j′ℓa2ℓ+1.
Since bj is stored at a2j and cj at a2j+1, we compute at step 7
a2j = bj+ωj′cj =
K/2−1
X
ℓ=0
ω2j′ℓa2ℓ+ωj′
K/2−1
X
ℓ=0
ω2j′ℓa2ℓ+1 =
K−1
X
ℓ=0
ωj′ℓaℓ= baj′.

54
Modular arithmetic and the FFT
Similarly, since −ωj′ = ωK/2+j′
a2j+1 =
K/2−1
X
ℓ=0
ω2j′ℓa2ℓ+ ωK/2+j′
K/2−1
X
ℓ=0
ω2j′ℓa2ℓ+1
=
K−1
X
ℓ=0
ω(K/2+j′)ℓaℓ= baK/2+j′ ,
where we used the fact that ω2j′ = ω2(j′+K/2). Since bitrev(2j, K) =
bitrev(j, K/2) and bitrev(2j + 1, K) = K/2 + bitrev(j, K/2), the ﬁrst part
of the theorem follows. The complexity bound follows from the fact that the
cost T(K) satisﬁes the recurrence T(K) ≤2T(K/2) + O(K).
Algorithm 2.3 BackwardFFT
Input: vector a bit-reversed, ω principal Kth root of unity, K = 2k
Output: in-place transformed vector ea, normal order
1: if K = 2 then
2:
[a0, a1] ←[a0 + a1, a0 −a1]
3: else
4:
[a0, ..., aK/2−1] ←BackwardFFT([a0, ..., aK/2−1], ω2, K/2)
5:
[aK/2, ..., aK−1] ←BackwardFFT([aK/2, ..., aK−1], ω2, K/2)
6:
for j from 0 to K/2 −1 do
⊲ω−j = ωK−j
7:
[aj, aK/2+j] ←[aj + ω−jaK/2+j, aj −ω−jaK/2+j].
Theorem 2.2 Given an input vector a = [a0, aK/2, . . . , aK−1] in bit-reverse
order, Algorithm BackwardFFT replaces it by its backward Fourier trans-
form, in normal order, in O(K log K) operations in R.
Proof. The complexity bound follows as in the proof of Theorem 2.1. For
the correctness result, we again use induction on K = 2k. For K = 2, the
backward Fourier transform ea = [a0 + a1, a0 + ω−1a1] is exactly what the
algorithm returns, since ω = ω−1 = −1 in that case. Assume now K ≥4,
a power of two. The ﬁrst half, say b, of the vector a corresponds to the bit-
reversed vector of the even indices, since bitrev(2j, K) = bitrev(j, K/2).
Similarly, the second half, say c, corresponds to the bit-reversed vector of the
odd indices, since bitrev(2j + 1, K) = K/2 + bitrev(j, K/2). Thus, we can
apply the theorem by induction to b and c. It follows that b is the backward
transform of length K/2 with ω2 for the even indices (in normal order), and

2.3 The Fourier transform
55
similarly c is the backward transform of length K/2 for the odd indices
bj =
K/2−1
X
ℓ=0
ω−2jℓa2ℓ,
cj =
K/2−1
X
ℓ=0
ω−2jℓa2ℓ+1.
Since bj is stored in aj and cj in aK/2+j, we have
aj = bj + ω−jcj =
K/2−1
X
ℓ=0
ω−2jℓa2ℓ+ ω−j
K/2−1
X
ℓ=0
ω−2jℓa2ℓ+1
=
K−1
X
ℓ=0
ω−jℓaℓ= eaj,
and similarly, using −ω−j = ω−K/2−j and ω−2j = ω−2(K/2+j)
aK/2+j =
K/2−1
X
ℓ=0
ω−2jℓa2ℓ+ ω−K/2−j
K/2−1
X
ℓ=0
ω−2jℓa2ℓ+1
=
K−1
X
ℓ=0
ω−(K/2+j)ℓaℓ= eaK/2+j.
2.3.3 The Sch¨onhage–Strassen algorithm
We now describe the Sch¨onhage–Strassen O(n log n log log n) algorithm to
multiply two integers of n bits. The heart of the algorithm is a routine to mul-
tiply two integers modulo 2n + 1.
Theorem 2.3 Given 0 ≤A, B < 2n + 1, Algorithm FFTMulMod correctly
returns A · B mod (2n + 1), and it costs O(n log n log log n) bit-operations if
K = Θ(√n).
Proof. The proof is by induction on n, because at step 8 we call FFTMulMod
recursively, unless n′ is sufﬁciently small that a simpler algorithm (classical,
Karatsuba or Toom–Cook) can be used. There is no difﬁculty in starting the
induction.
With aj, bj the values at steps 1 and 2, we have A = PK−1
j=0 aj2jM and
B = PK−1
j=0 bj2jM; thus, A · B = PK−1
j=0 cj2jM mod (2n + 1) with
cj =
K−1
X
ℓ,m=0
ℓ+m=j
aℓbm −
K−1
X
ℓ,m=0
ℓ+m=K+j
aℓbm.
(2.2)

56
Modular arithmetic and the FFT
Algorithm 2.4 FFTMulMod
Input: 0 ≤A, B < 2n + 1, an integer K = 2k such that n = MK
Output: C = A · B mod (2n + 1)
1: decompose
A = PK−1
j=0 aj2jM
with
0 ≤aj < 2M,
except
that
0 ≤aK−1 ≤2M
2: decompose B similarly
3: choose n′ ≥2n/K + k, n′ multiple of K; let θ = 2n′/K, ω = θ2
4: for j from 0 to K −1 do
5:
(aj, bj) ←(θjaj, θjbj) mod (2n′ + 1)
6: a ←ForwardFFT(a, ω, K),
b ←ForwardFFT(b, ω, K)
7: for j from 0 to K −1 do
⊲call FFTMulMod
8:
cj ←ajbj mod (2n′ + 1)
⊲recursively if n′ is large
9: c ←BackwardFFT(c, ω, K)
10: for j from 0 to K −1 do
11:
cj ←cj/(Kθj) mod (2n′ + 1)
12:
if cj ≥(j + 1)22M then
13:
cj ←cj −(2n′ + 1)
14: C = PK−1
j=0 cj2jM.
We have (j + 1 −K)22M ≤cj < (j + 1)22M, since the ﬁrst sum contains
j + 1 terms, the second sum K −(j + 1) terms, and at least one of aℓand bm
is less than 2M in the ﬁrst sum.
Let a′
j be the value of aj after step 5: a′
j = θjaj mod (2n′ + 1), and
similarly for b′
j. Using Theorem 2.1, after step 6 we have abitrev(j,K) =
PK−1
ℓ=0 ωℓja′
ℓmod (2n′ + 1), and similarly for b. Thus at step 8
cbitrev(j,K) =
ÃK−1
X
ℓ=0
ωℓja′
ℓ
! ÃK−1
X
m=0
ωmjb′
m
!
.
After step 9, using Theorem 2.2
c′
i =
K−1
X
j=0
ω−ij
ÃK−1
X
ℓ=0
ωℓja′
ℓ
! ÃK−1
X
m=0
ωmjb′
m
!
= K
K−1
X
ℓ,m=0
ℓ+m=i
a′
ℓb′
m + K
K−1
X
ℓ,m=0
ℓ+m=K+i
a′
ℓb′
m.
The ﬁrst sum equals θi P
ℓ+m=i aℓbm; the second is θK+i P
ℓ+m=K+i aℓbm.

2.3 The Fourier transform
57
Since θK = −1 mod (2n′ + 1), after step 11 we have
ci =
K−1
X
ℓ,m=0
ℓ+m=i
aℓbm −
K−1
X
ℓ,m=0
ℓ+m=K+i
aℓbm mod (2n′ + 1).
The correction at step 13 ensures that ci lies in the correct interval, as given by
Eqn. (2.2).
For the complexity analysis, assume that K = Θ(√n). Thus, we have
n′ = Θ(√n). Steps 1 and 2 cost O(n); step 5 also costs O(n) (counting the
cumulated cost for all values of j). Step 6 costs O(K log K) times the cost
of one butterﬂy operation mod (2n′ + 1), which is O(n′), thus a total of
O(Kn′ log K) = O(n log n). Step 8, using the same algorithm recursively,
costs O(n′ log n′ log log n′) per value of j by the induction hypothesis,
giving a total of O(n log n log log n). The backward FFT costs O(n log n)
too, and the ﬁnal steps cost O(n), giving a total cost of O(n log n log log n).
The log log n term is the depth of the recursion, each level reducing n to
n′ = O(√n).
EXAMPLE: to multiply two integers modulo (21 048 576 + 1), we can take K =
210 = 1024, and n′ = 3072. We recursively compute 1024 products modulo
(23072 + 1). Alternatively, we can take the smaller value K = 512, with 512
recursive products modulo (24608 + 1).
REMARK 1: the “small” products at step 8 (mod (23072+1) or mod (24608+1)
in our example) can be performed by the same algorithm applied recursively,
but at some point (determined by details of the implementation) it will be more
efﬁcient to use a simpler algorithm, such as the classical or Karatsuba algo-
rithm (see §1.3). In practice, the depth of recursion is a small constant, typi-
cally 1 or 2. Thus, for practical purposes, the log log n term can be regarded
as a constant. For a theoretical way of avoiding the log log n term, see the
comments on F¨urer’s algorithm in §2.9.
REMARK 2: if we replace θ by 1 in Algorithm FFTMulMod, i.e. remove
step 5, replace step 11 by cj ←cj/K mod (2n′ +1), and replace the condition
at step 12 by cj ≥K ·22M, then we compute C = A·B mod (2n −1) instead
of mod(2n + 1). This is useful in McLaughlin’s algorithm (§2.4.3).
Algorithm FFTMulMod enables us to multiply two integers modulo (2n +
1) in O(n log n log log n) operations, for a suitable n and a corresponding FFT
length K = 2k. Since we should have K ≈√n and K must divide n, suitable
values of n are the integers with the low-order half of their bits zero; there is
no shortage of such integers. To multiply two integers of at most n bits, we
ﬁrst choose a suitable bit size m ≥2n. We consider the integers as residues

58
Modular arithmetic and the FFT
modulo (2m + 1), then Algorithm FFTMulMod gives their integer product.
The resulting complexity is O(n log n log log n), since m = O(n). In practice,
the log log n term can be regarded as a constant; theoretically, it can be replaced
by an extremely slowly growing function (see Remark 1 above).
In this book, we sometimes implicitly assume that n-bit integer multiplica-
tion costs the same as three FFTs of length 2n, since this is true if an FFT-based
algorithm is used for multiplication. The constant “three” can be reduced if
some of the FFTs can be precomputed and reused many times, for example if
some of the operands in the multiplications are ﬁxed.
2.4 Modular multiplication
Modular multiplication means computing A · B mod N, where A and B are
residues modulo N. Of course, once the product C = A·B has been computed,
it sufﬁces to perform a modular reduction C mod N, which itself reduces to
an integer division. The reader may ask why we did not cover this topic in
§1.4. There are two reasons. First, the algorithms presented below beneﬁt from
some precomputations involving N, and are thus speciﬁc to the case where
several reductions are performed with the same modulus. Second, some algo-
rithms avoid performing the full product C = A · B; one such example is
McLaughlin’s algorithm (§2.4.3).
Algorithms with precomputations include Barrett’s algorithm (§2.4.1), which
computes an approximation to the inverse of the modulus, thus trading division
for multiplication; Montgomery’s algorithm, which corresponds to Hensel’s
division with remainder only (§1.4.8), and its subquadratic variant, which is
the LSB-variant of Barrett’s algorithm; and ﬁnally McLaughlin’s algorithm
(§2.4.3). The cost of the precomputations is not taken into account; it is
assumed to be negligible if many modular reductions are performed. How-
ever, we assume that the amount of precomputed data uses only linear, i.e.
O(log N), space.
As usual, we assume that the modulus N has n words in base β, that A and
B have at most n words, and in some cases that they are fully reduced, i.e.
0 ≤A, B < N.
2.4.1 Barrett’s algorithm
Barrett’s algorithm is attractive when many divisions have to be made with
the same divisor; this is the case when we perform computations modulo a
ﬁxed integer. The idea is to precompute an approximation to the inverse of

2.4 Modular multiplication
59
the divisor. Thus, an approximation to the quotient is obtained with just one
multiplication, and the corresponding remainder after a second multiplication.
A small number of corrections sufﬁce to convert the approximations into exact
values. For the sake of simplicity, we describe Barrett’s algorithm in base β,
where β might be replaced by any integer, in particular 2n or βn.
Algorithm 2.5 BarrettDivRem
Input: integers A, B with 0 ≤A < β2, β/2 < B < β
Output: quotient Q and remainder R of A divided by B
1: I ←⌊β2/B⌋
⊲precomputation
2: Q ←⌊A1I/β⌋where A = A1β + A0 with 0 ≤A0 < β
3: R ←A −QB
4: while R ≥B do
5:
(Q, R) ←(Q + 1, R −B)
6: return (Q, R).
Theorem 2.4 Algorithm BarrettDivRem is correct and step 5 is performed
at most three times.
Proof. Since A = QB +R is invariant in the algorithm, we just need to prove
that 0 ≤R < B at the end. We ﬁrst consider the value of Q, R before the
while-loop. Since β/2 < B < β, we have β < β2/B < 2β; thus, β ≤
I < 2β. We have Q ≤A1I/β ≤A1β/B ≤A/B. This ensures that R is
non-negative. Now I > β2/B −1, which gives
IB > β2 −B.
Similarly, Q > A1I/β −1 gives
βQ > A1I −β.
This yields βQB > A1IB −βB > A1(β2 −B) −βB = β(A −A0) −
B(β + A1) > βA −4βB since A0 < β < 2B and A1 < β. We conclude that
A < B(Q + 4); thus, at most three corrections are needed.
The bound of three corrections is tight: it is attained for A = 1980, B = 36,
β = 64. In this example, I = 113, A1 = 30, Q = 52, R = 108 = 3B.
The multiplications at steps 2 and 3 may be replaced by short products, more
precisely the multiplication at step 2 by a high short product, and that at step 3
by a low short product (see §3.3).
Barrett’s algorithm can also be used for an unbalanced division, when divid-
ing (k + 1)n words by n words for k ≥2, which amounts to k divisions of

60
Modular arithmetic and the FFT
2n words by the same n-word divisor. In this case, we say that the divisor is
implicitly invariant.
Complexity of Barrett’s algorithm
If the multiplications at steps 2 and 3 are performed using full products,
Barrett’s algorithm costs 2M(n) for a divisor of size n. In the FFT range,
this cost might be lowered to 1.5M(n) using the “wrap-around trick” (§3.4.1);
moreover, if the forward transforms of I and B are stored, the cost decreases
to M(n), assuming M(n) is the cost of three FFTs.
2.4.2 Montgomery’s multiplication
Montgomery’s algorithm is very efﬁcient for modular arithmetic modulo a
ﬁxed modulus N. The main idea is to replace a residue A mod N by A′ =
λA mod N, where A′ is the “Montgomery form” corresponding to the residue
A, with λ an integer constant such that gcd(N, λ) = 1. Addition and subtrac-
tion are unchanged, since λA + λB = λ(A + B) mod N. The multiplication
of two residues in Montgomery form does not give exactly what we want:
(λA)(λB) ̸= λ(AB) mod N. The trick is to replace the classical modular
multiplication by “Montgomery’s multiplication”
MontgomeryMul(A′, B′) = A′B′
λ
mod N.
For some values of λ, MontgomeryMul(A′, B′) can easily be computed, in
particular for λ = βn, where N uses n words in base β. Algorithm 2.6 is
a quadratic algorithm (REDC) to compute MontgomeryMul(A’, B’) in this
case, and a subquadratic reduction (FastREDC) is given in Algorithm 2.7.
Another view of Montgomery’s algorithm for λ = βn is to consider that it
computes the remainder of Hensel’s division (§1.4.8).
Algorithm 2.6 REDC (quadratic non-interleaved version). The ci form the
current base-β decomposition of C, i.e. they are deﬁned by C = P2n−1
0
ciβi .
Input: 0 ≤C < β2n, N < βn, µ ←−N −1 mod β, (β, N) = 1
Output: 0 ≤R < βn such that R = Cβ−n mod N
1: for i from 0 to n −1 do
2:
qi ←µci mod β
⊲quotient selection
3:
C ←C + qiNβi
4: R ←Cβ−n
⊲trivial exact division
5: if R ≥βn then return R −N else return R.

2.4 Modular multiplication
61
Theorem 2.5 Algorithm REDC is correct.
Proof. We ﬁrst prove that R = Cβ−n mod N: C is only modiﬁed in step 3,
which does not change C mod N; thus, at step 4 we have R = Cβ−n mod N,
and this remains true in the last step.
Assume that, for a given i, we have C = 0 mod βi when entering step 2.
Since qi = −ci/N mod β, we have C + qiNβi = 0 mod βi+1 at the next
step, so the next value of ci is 0. Thus, on exiting the for-loop, C is a multiple
of βn, and R is an integer at step 4.
Still at step 4, we have C < β2n + (β −1)N(1 + β + · · · + βn−1) =
β2n + N(βn −1); thus, R < βn + N and R −N < βn.
Compared to classical division (Algorithm 1.6 BasecaseDivRem), Mont-
gomery’s algorithm has two signiﬁcant advantages: the quotient selection is
performed by a multiplication modulo the word base β, which is more efﬁ-
cient than a division by the most signiﬁcant word bn−1 of the divisor as in
BasecaseDivRem; and there is no repair step inside the for-loop – the repair
step is at the very end.
For example, with inputs C = 766 970 544 842 443 844, N = 862 664 913,
and β = 1000, Algorithm REDC precomputes µ = 23; then we have q0 = 412,
which yields C ←C + 412N = 766 970 900 260 388 000; then q1 = 924,
which yields C ←C + 924Nβ = 767 768 002 640 000 000; then q2 = 720,
which yields C ←C + 720Nβ2 = 1 388 886 740 000 000 000. At step 4,
R = 1 388 886 740, and since R ≥β3, REDC returns R −N = 526 221 827.
Since Montgomery’s algorithm – i.e. Hensel’s division with remainder only –
can be viewed as an LSB variant of classical division, Svoboda’s divisor pre-
conditioning (§1.4.2) also translates to the LSB context. More precisely, in Al-
gorithm REDC, we want to modify the divisor N so that the quotient selection
q ←µci mod β at step 2 becomes trivial. The multiplier k used in Svoboda
division is simply the parameter µ in REDC. A natural choice is µ = 1, which
corresponds to N = −1 mod β. This motivates the Montgomery–Svoboda
algorithm, which is as follows:
1. ﬁrst compute N ′ = µN, with N ′ < βn+1, where µ = −1/N mod β;
2. perform the n −1 ﬁrst loops of REDC, replacing µ by 1, and N by N ′;
3. perform a ﬁnal classical loop with µ and N, and the last steps (4–5) from
REDC.
Quotient selection in the Montgomery–Svoboda algorithm simply involves
“reading” the word of weight βi in the divisor C.
For the example above, we get N ′ = 19 841 292 999; q0 is the least signiﬁ-
cant word of C, i.e. q0 = 844, so C ←C+844N ′ = 766 987 290 893 735 000;

62
Modular arithmetic and the FFT
then q1 = 735 and C ←C + 735N ′β = 781 570 641 248 000 000. The last
step gives q2 = 704 and C ←C + 704Nβ2 = 1 388 886 740 000 000 000,
which is what we found previously.
Subquadratic Montgomery reduction
A subquadratic version FastREDC of Algorithm REDC is obtained by taking
n = 1, and considering β as a “giant base” (alternatively, replace β by βn
below):
Algorithm 2.7 FastREDC (subquadratic Montgomery reduction)
Input: 0 ≤C < β2, N < β, µ ←−1/N mod β
Output: 0 ≤R < β such that R = C/β mod N
1: Q ←µC mod β
2: R ←(C + QN)/β
3: if R ≥β then return R −N else return R.
This is exactly the 2-adic counterpart of Barrett’s subquadratic algorithm;
steps 1–2 might be performed by a low short product and a high short product,
respectively.
When combined with Karatsuba’s multiplication, assuming the products
of steps 1–2 are full products, the reduction requires two multiplications of
size n, i.e. six multiplications of size n/2 (n denotes the size of N, β being a
giant base). With some additional precomputation, the reduction might be
performed with ﬁve multiplications of size n/2, assuming n is even. This is
simply the Montgomery–Svoboda algorithm with N having two big words in
base βn/2. The cost of the algorithm is M(n, n/2) to compute q0N ′ (even if
N ′ has in principle 3n/2 words, we know N ′ = Hβn/2 −1 with H < βn, and
thus it sufﬁces to multiply q0 by H), M(n/2) to compute µC mod βn/2, and
Algorithm 2.8 MontgomerySvoboda
Input: 0 ≤C < β2n, N < βn, µ ←−1/N mod βn/2, N ′ = µN
Output: 0 ≤R < βn such that R = C/βn mod N
1: q0 ←C mod βn/2
2: C ←(C + q0N ′)/βn/2
3: q1 ←µC mod βn/2
4: R ←(C + q1N)/βn/2
5: if R ≥βn then return R −N else return R.

2.4 Modular multiplication
63
again M(n, n/2) to compute q1N; thus, a total of 5M(n/2) if each n × (n/2)
product is realized by two (n/2) × (n/2) products.
The algorithm is quite similar to the one described at the end of §1.4.6, where
the cost was 3M(n/2)+D(n/2) for a division of 2n by n with remainder only.
The main difference here is that, thanks to Montgomery’s form, the last classi-
cal division D(n/2) in Svoboda’s algorithm is replaced by multiplications of
total cost 2M(n/2), which is usually faster.
Algorithm MontgomerySvoboda can be extended as follows. The value C
obtained after step 2 has 3n/2 words, i.e. an excess of n/2 words. Instead of
reducing that excess with REDC, we could reduce it using Svoboda’s tech-
nique with µ′ = −1/N mod βn/4, and N ′′ = µ′N. This would reduce the
low n/4 words from C at the cost of M(n, n/4), and a last REDC step would
reduce the ﬁnal excess of n/4, which would give D(2n, n) = M(n, n/2) +
M(n, n/4)+M(n/4)+M(n, n/4). This “folding” process can be generalized
to D(2n, n) = M(n, n/2) + · · · + M(n, n/2k) + M(n/2k) + M(n, n/2k).
If M(n, n/2k) reduces to 2kM(n/2k), this gives
D(n) = 2M(n/2)+4M(n/4)+· · ·+2k−1M(n/2k−1)+(2k+1+1)M(n/2k).
Unfortunately, the resulting multiplications become more and more unbal-
anced, and we need to store k precomputed multiples N ′, N ′′, . . . of N, each
requiring at least n words. Table 2.2 shows that the single-folding algorithm is
the best one.
Algorithm
Karatsuba
Toom–Cook 3-way
Toom–Cook 4-way
D(n)
2.00M(n)
2.63M(n)
3.10M(n)
1-folding
1.67M(n)
1.81M(n)
1.89M(n)
2-folding
1.67M(n)
1.91M(n)
2.04M(n)
3-folding
1.74M(n)
2.06M(n)
2.25M(n)
Table 2.2 Theoretical complexity of subquadratic REDC with 1-, 2- and
3-folding, for different multiplication algorithms.
Exercise 2.6 discusses further possible improvements in the Montgomery–
Svoboda algorithm, achieving D(n) ≈1.58M(n) in the case of Karatsuba
multiplication.
2.4.3 McLaughlin’s algorithm
McLaughlin’s algorithm assumes we can perform fast multiplication modulo
both 2n −1 and 2n + 1, for sufﬁciently many values of n. This assumption is

64
Modular arithmetic and the FFT
true for example with the Sch¨onhage–Strassen algorithm: the original version
multiplies two numbers modulo 2n + 1, but discarding the “twist” operations
before and after the Fourier transforms computes their product modulo 2n −1.
(This has to be done at the top level only: the recursive operations compute
modulo 2n′ + 1 in both cases. See Remark 2 on page 57.)
The key idea in McLaughlin’s algorithm is to avoid the classical “multiply
and divide” method for modular multiplication. Instead, assuming that N is
relatively prime to 2n −1, it determines AB/(2n −1) mod N with convo-
lutions modulo 2n ± 1, which can be performed in an efﬁcient way using the
FFT.
Algorithm 2.9 MultMcLaughlin
Input: A, B with 0 ≤A, B < N < 2n, µ = −N −1 mod (2n −1)
Output: AB/(2n −1) mod N
1: m ←ABµ mod (2n −1)
2: S ←(AB + mN) mod (2n + 1)
3: w ←−S mod (2n + 1)
4: if 2|w then s ←w/2 else s ←(w + 2n + 1)/2
5: if AB + mN = s mod 2 then t ←s else t ←s + 2n + 1
6: if t < N then return t else return t −N.
Theorem 2.6 Algorithm MultMcLaughlin computes AB/(2n −1) mod N
correctly, in ∼1.5M(n) operations, assuming multiplication modulo 2n ± 1
costs ∼M(n/2), or the same as 3 Fourier transforms of size n.
Proof. Step 1 is similar to step 1 of Algorithm FastREDC, with β replaced by
2n −1. It follows that AB +mN = 0 mod (2n −1), therefore we have AB +
mN = k(2n−1) with 0 ≤k < 2N. Step 2 computes S = −2k mod (2n+1),
then step 3 gives w = 2k mod (2n + 1), and s = k mod (2n + 1) in step 4.
Now, since 0 ≤k < 2n+1, the value s does not uniquely determine k, whose
missing bit is determined from the least signiﬁcant bit from AB+mN (step 5).
Finally, the last step reduces t = k modulo N.
The cost of the algorithm is mainly that of the four multiplications AB mod
(2n ±1), (AB)µ mod (2n −1) and mN mod (2n +1), which cost 4M(n/2)
altogether. However, in (AB)µ mod (2n −1) and mN mod (2n + 1), the
operands µ and N are invariant, therefore their Fourier transforms can be pre-
computed, which saves 2M(n/2)/3 altogether. A further saving of M(n/2)/3
is obtained since we perform only one backward Fourier transform in step 2.
Accounting for the savings gives (4 −2/3 −1/3)M(n/2) = 3M(n/2) ∼
1.5M(n).

2.5 Modular division and inversion
65
The ∼1.5M(n) cost of McLaughlin’s algorithm is quite surprising, since it
means that a modular multiplication can be performed faster than two multi-
plications. In other words, since a modular multiplication is basically a mul-
tiplication followed by a division, this means that (at least in this case) the
“division” can be performed for half the cost of a multiplication!
2.4.4 Special moduli
For special moduli N faster algorithms may exist. The ideal case is N =
βn ± 1. This is precisely the kind of modulus used in the Sch¨onhage–Strassen
algorithm based on the fast Fourier transform (FFT). In the FFT range, a mul-
tiplication modulo βn ± 1 is used to perform the product of two integers of
at most n/2 words, and a multiplication modulo βn ± 1 costs ∼M(n/2) ∼
M(n)/2.
For example, in elliptic curve cryptography (ECC), we almost always use a
special modulus, for example a pseudo-Mersenne prime like 2192 −264 −1
or 2256 −2224 + 2192 + 296 −1. However, in most applications the modulus
can not be chosen, and there is no reason for it to have a special form.
We refer to §2.9 for further information about special moduli.
2.5 Modular division and inversion
We have seen above that modular multiplication reduces to integer division,
since to compute ab mod N, the classical method consists of dividing ab by N
to obtain ab = qN+r, then ab = r mod N. In the same vein, modular division
reduces to an (extended) integer gcd. More precisely, the division a/b mod N
is usually computed as a·(1/b) mod N, thus a modular inverse is followed by
a modular multiplication. We concentrate on modular inversion in this section.
We have seen in Chapter 1 that computing an extended gcd is expensive,
both for small sizes, where it usually costs the same as several multiplications,
and for large sizes, where it costs O(M(n) log n). Therefore, modular inver-
sions should be avoided if possible; we explain at the end of this section how
this can be done.
Algorithm 2.10 (ModularInverse) is just Algorithm ExtendedGcd (§1.6.2),
with (a, b) →(b, N) and the lines computing the cofactors of N omitted.
Algorithm ModularInverse is the naive version of modular inversion, with
complexity O(n2) if N takes n words in base β. The subquadratic
O(M(n) log n) algorithm is based on the HalfBinaryGcd algorithm (§1.6.3).
When the modulus N has a special form, faster algorithms may exist. In
particular for N = pk, O(M(n)) algorithms exist, based on Hensel lifting,

66
Modular arithmetic and the FFT
Algorithm 2.10 ModularInverse
Input: integers b and N, b prime to N
Output: integer u = 1/b mod N
(u, w) ←(1, 0), c ←N
while c ̸= 0 do
(q, r) ←DivRem(b, c)
(b, c) ←(c, r)
(u, w) ←(w, u −qw)
return u.
which can be seen as the p-adic variant of Newton’s method (§4.2). To compute
1/b mod N, we use a p-adic version of the iteration (4.5)
xj+1 = xj + xj(1 −bxj) mod pk.
(2.3)
Assume xj approximates 1/b to “p-adic precision” ℓ, i.e. bxj = 1 + εpℓ, and
k = 2ℓ. Then, modulo pk: bxj+1 = bxj(2 −bxj) = (1 + εpℓ)(1 −εpℓ) =
1−ε2p2ℓ. Therefore, xj+1 approximates 1/b to double precision (in the p-adic
sense).
As an example, assume we want to compute the inverse of an odd integer b
modulo 232. The initial approximation x0 = 1 satisﬁes x0 = 1/b mod 2, thus
ﬁve iterations are enough. The ﬁrst iteration is x1 ←x0+x0(1−bx0) mod 22,
which simpliﬁes to x1 ←2 −b mod 4 since x0 = 1. Now, whether b = 1
mod4 or b = 3 mod 4, we have 2 −b = b mod 4; we can therefore start the
second iteration with x1 = b implicit
x2 ←b(2 −b2) mod 24,
x3 ←x2(2 −bx2) mod 28,
x4 ←x3(2 −bx3) mod 216,
x5 ←x4(2 −bx4) mod 232.
Consider for example b = 17. The above algorithm yields x2 = 1, x3 = 241,
x4 = 61 681 and x5 = 4 042 322 161. Of course, any computation mod pℓ
might be computed modulo pk for k ≥ℓ. In particular, all the above compu-
tations might be performed modulo 232. On a 32-bit computer, arithmetic on
basic integer types is usually performed modulo 232, thus the reduction comes
for free, and we can write in the C language (using unsigned variables and
the same variable x for x2, . . . , x5)
x = b*(2-b*b); x *= 2-b*x; x *= 2-b*x; x *= 2-b*x;
Another way to perform modular division when the modulus has a special
form is Hensel’s division (§1.4.8). For a modulus N = βn, given two integers

2.5 Modular division and inversion
67
A, B, we compute Q and R such that
A = QB + Rβn.
Therefore, we have A/B = Q mod βn. While Montgomery’s modular mul-
tiplication only computes the remainder R of Hensel’s division, modular divi-
sion computes the quotient Q; thus, Hensel’s division plays a central role in
modular arithmetic modulo βn.
2.5.1 Several inversions at once
A modular inversion, which reduces to an extended gcd (§1.6.2), is usually
much more expensive than a multiplication. This is true not only in the FFT
range, where a gcd takes time Θ(M(n) log n), but also for smaller numbers.
When several inversions are to be performed modulo the same number, Algo-
rithm MultipleInversion is usually faster.
Algorithm 2.11 MultipleInversion
Input: 0 < x1, . . . , xk < N
Output: y1 = 1/x1 mod N, . . . , yk = 1/xk mod N
1: z1 ←x1
2: for i from 2 to k do
3:
zi ←zi−1xi mod N
4: q ←1/zk mod N
5: for i from k downto 2 do
6:
yi ←qzi−1 mod N
7:
q ←qxi mod N
8: y1 ←q.
Theorem 2.7 Algorithm MultipleInversion is correct.
Proof. We have zi = x1x2 . . . xi mod N; thus, at the beginning of step 6 for
a given i, q = (x1 . . . xi)−1 mod N, which gives yi = 1/xi mod N.
This algorithm uses only one modular inversion (step 4), and 3(k−1) modular
multiplications. Thus, it is faster than k inversions when a modular inversion is
more than three times as expensive as a product. Figure 2.1 shows a recursive
variant of the algorithm, with the same number of modular multiplications: one
for each internal node when going up the (product) tree, and two for each in-
ternal node when going down the (remainder) tree. The recursive variant might
be performed in parallel in O(log k) operations using O(k/ log k) processors.

68
Modular arithmetic and the FFT
¡
¡
¡
¡
¡
@
@
@
@
@
¡
¡
¡
@
@@
¡
¡
¡
@
@@
1/(x1x2x3x4)
1/(x1x2)
1/(x3x4)
1/x1
1/x2
1/x3
1/x4
Figure 2.1 A recursive variant of Algorithm MultipleInversion. First go
up the tree, building x1x2 mod N from x1 and x2 in the left branch,
x3x4 mod N in the right branch, and x1x2x3x4 mod N at the root of the
tree. Then invert the root of the tree. Finally, go down the tree, multiplying
1/(x1x2x3x4) by the stored value x3x4 to get 1/(x1x2), and so on.
A dual case is when there are several moduli but the number to invert is
ﬁxed. Say we want to compute 1/x mod N1, . . . , 1/x mod Nk. We illustrate
a possible algorithm in the case k = 4. First compute N = N1 . . . Nk using
a product tree like that in Figure 2.1. For example, ﬁrst compute N1N2 and
N3N4, then multiply both to get N = (N1N2)(N3N4). Then compute y =
1/x mod N, and go down the tree, while reducing the residue at each node. In
our example, we compute z = y mod (N1N2) in the left branch, then z mod
N1 yields 1/x mod N1. An important difference between this algorithm and
the algorithm illustrated in Figure 2.1 is that here the numbers grow while
going up the tree. Thus, depending on the sizes of x and the Nj, this algorithm
might be of theoretical interest only.
2.6 Modular exponentiation
Modular exponentiation is the most time-consuming mathematical operation
in several cryptographic algorithms. The well-known RSA public-key cryp-
tosystem is based on the fact that computing
c = ae mod N
(2.4)
is relatively easy, but recovering a from c, e and N is difﬁcult when N has
at least two (unknown) large prime factors. The discrete logarithm problem is
similar: here c, a and N are given, and we look for e satisfying Eqn. (2.4). In
this case, the problem is difﬁcult when N has at least one large prime factor
(for example, N could be prime). The discrete logarithm problem is the basis
of the El Gamal cryptosystem, and a closely related problem is the basis of the
Difﬁe–Hellman key exchange protocol.

2.6 Modular exponentiation
69
When the exponent e is ﬁxed (or known to be small), an optimal sequence
of squarings and multiplications might be computed in advance. This is related
to the classical addition chain problem: What is the smallest chain of additions
to reach the integer e, starting from 1? For example, if e = 15, a possible chain
is
1, 1 + 1 = 2, 1 + 2 = 3, 1 + 3 = 4, 3 + 4 = 7, 7 + 7 = 14, 1 + 14 = 15.
The length of a chain is deﬁned to be the number of additions needed to com-
pute it (the above chain has length 6). An addition chain readily translates to a
multiplication chain
a, a·a = a2, a·a2 = a3, a·a3 = a4, a3 ·a4 = a7, a7 ·a7 = a14, a·a14 = a15.
A shorter chain for e = 15 is
1, 1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 5 + 5 = 10, 5 + 10 = 15.
This chain is the shortest possible for e = 15, so we write σ(15) = 5, where in
general σ(e) denotes the length of the shortest addition chain for e. In the case
where e is small, and an addition chain of shortest length σ(e) is known for e,
computing ae mod N may be performed in σ(e) modular multiplications.
When e is large and (a, N) = 1, then e might be reduced modulo φ(N),
where φ(N) is Euler’s totient function, i.e. the number of integers in [1, N]
which are relatively prime to N. This is because aφ(N) = 1 mod N whenever
(a, N) = 1 (Fermat’s little theorem).
Since φ(N) is a multiplicative function, it is easy to compute φ(N) if we
know the prime factorization of N. For example
φ(1001) = φ(7 · 11 · 13) = (7 −1)(11 −1)(13 −1) = 720,
and 2009 = 569 mod 720, so 172009 = 17569 mod 1001.
Assume now that e is smaller than φ(N). Since a lower bound on the length
σ(e) of the addition chain for e is lg e, this yields a lower bound (lg e)M(n)
for modular exponentiation, where n is the size of N. When e is of size k, a
modular exponentiation costs O(kM(n)). For k = n, the cost O(nM(n)) of
modular exponentiation is much more than the cost of operations considered in
Chapter 1, with O(M(n) log n) for the more expensive ones there. The differ-
ent algorithms presented in this section save only a constant factor compared
to binary exponentiation (§2.6.1).
REMARK: when a ﬁts in one word but N does not, the shortest addition chain
for e might not be the best way to compute ae mod N, since in this case com-
puting a · aj mod N is cheaper than computing ai · aj mod N for i ≥2.

70
Modular arithmetic and the FFT
2.6.1 Binary exponentiation
A simple (and not far from optimal) algorithm for modular exponentiation is
binary (modular) exponentiation. Two variants exist: left-to-right and right-to-
left. We give the former in Algorithm LeftToRightBinaryExp and leave the
latter as an exercise for the reader.
Algorithm 2.12 LeftToRightBinaryExp
Input: a, e, N positive integers
Output: x = ae mod N
1: let (eℓeℓ−1 . . . e1e0) be the binary representation of e, with eℓ= 1
2: x ←a
3: for i from ℓ−1 downto 0 do
4:
x ←x2 mod N
5:
if ei = 1 then x ←ax mod N.
Left-to-right binary exponentiation has two advantages over right-to-left
exponentiation:
• it requires only one auxiliary variable, instead of two for the right-to-left
exponentiation: one to store successive values of a2i, and one to store the
result;
• in the case where a is small, the multiplications ax at step 5 always involve
a small operand.
If e is a random integer of ℓ+ 1 bits, step 5 will be performed on average ℓ/2
times, giving average cost 3ℓM(n)/2.
EXAMPLE: for the exponent e = 3 499 211 612, which is
(11 010 000 100 100 011 011 101 101 011 100)2
in binary, Algorithm LeftToRightBinaryExp performs 31 squarings and 15
multiplications (one for each 1-bit, except the most signiﬁcant one).
2.6.2 Exponentiation with a larger base
Compared to binary exponentiation, base 2k exponentiation reduces the
number of multiplications ax mod N (Algorithm LeftToRightBinaryExp,
step 5). The idea is to precompute small powers of a mod N:
The precomputation cost is (2k −2)M(n), and if the digits ei are random
and uniformly distributed in Z ∩[0, 2k), then the modular multiplication at
step 6 of BaseKExp is performed with probability 1 −2−k. If e has n bits, the

2.6 Modular exponentiation
71
Algorithm 2.13 BaseKExp
Input: a, e, N positive integers
Output: x = ae mod N
1: precompute t[i] := ai mod N for 1 ≤i < 2k
2: let (eℓeℓ−1 . . . e1e0) be the base 2k representation of e, with eℓ̸= 0
3: x ←t[eℓ]
4: for i from ℓ−1 downto 0 do
5:
x ←x2k mod N
6:
if ei ̸= 0 then x ←t[ei]x mod N.
number of loops is about n/k. Ignoring the squares at step 5 (their total cost
depends on kℓ≈n so is independent of k), the total expected cost in terms of
multiplications modulo N is
2k −2 + n(1 −2−k)/k.
For k = 1, this formula gives n/2; for k = 2, it gives 3n/8+2, which is faster
for n > 16; for k = 3, it gives 7n/24 + 6, which is faster than the k = 2
formula for n > 48. When n is large, the optimal value of k satisﬁes k22k ≈
n/ ln 2. A minor disadvantage of this algorithm is its memory usage, since
Θ(2k) precomputed entries have to be stored. This is not a serious problem if
we choose the optimal value of k (or a smaller value), because then the number
of precomputed entries to be stored is o(n).
EXAMPLE: consider the exponent e = 3 499 211 612. Algorithm BaseKExp
performs 31 squarings independently of k, we therefore count multiplications
only. For k = 2, we have e = (3 100 210 123 231 130)4: Algorithm BaseKExp
performs two multiplications to precompute a2 and a3, and 11 multiplications
for the non-zero digits of e in base 4 (except for the leading digit), i.e. a total
of 13. For k = 3, we have e = (32 044 335 534)8, and the algorithm performs
six multiplications to precompute a2, a3, . . . , a7, and nine multiplications in
step 6, i.e. a total of 15.
The last example illustrates two facts. First, if some digits (here 6 and 7) do
not appear in the base-2k representation of e, then we do not need to precom-
pute the corresponding powers of a. Second, when a digit is even, say ei = 2,
instead of doing three squarings and multiplying by a2, we could do two squar-
ings, multiply by a, and perform a last squaring. These considerations lead to
Algorithm BaseKExpOdd.
The correctness of steps 7–9 follows from:
x2ka2md = (x2k−mad)2m.

72
Modular arithmetic and the FFT
Algorithm 2.14 BaseKExpOdd
Input: a, e, N positive integers
Output: x = ae mod N
1: precompute a2 then t[i] := ai mod N for i odd, 1 ≤i < 2k
2: let (eℓeℓ−1 . . . e1e0) be the base 2k representation of e, with eℓ̸= 0
3: write eℓ= 2md with d odd
4: x ←t[d],
x ←x2m mod N
5: for i from ℓ−1 downto 0 do
6:
write ei = 2md with d odd (if ei = 0 then m = d = 0)
7:
x ←x2k−m mod N
8:
if ei ̸= 0 then x ←t[d]x mod N
9:
x ←x2m mod N.
On the previous example, with k = 3, this algorithm performs only four
multiplications in step 1 (to precompute a2 then a3, a5, a7), then nine multi-
plications in step 8.
2.6.3 Sliding window and redundant representation
The “sliding window” algorithm is a straightforward generalization of
Algorithm BaseKExpOdd. Instead of cutting the exponent into ﬁxed parts
of k bits each, the idea is to divide it into windows, where two adjacent win-
dows might be separated by a block of zero or more 0-bits. The decomposition
starts from the least signiﬁcant bits. For example, with e = 3 499 211 612, or
in binary
1
|{z}
e8
101
|{z}
e7
00 001
|{z}
e6
001
|{z}
e5
00 011
|{z}
e4
011
|{z}
e3
101
|{z}
e2
101
|{z}
e1
0 111
|{z}
e0
00.
Here there are nine windows (indicated by e8, ..., e0 above) and we perform
only eight multiplications, an improvement of one multiplication over Algo-
rithm BaseKExpOdd. On average, the sliding window base 2k algorithm leads
to about n/(k + 1) windows instead of n/k with ﬁxed windows.
Another improvement may be feasible when division is feasible (and cheap)
in the underlying group. For example, if we encounter three consecutive ones,
say 111, in the binary representation of e, we may replace some bits by −1,
denoted by ¯1, as in 100¯1. We have thus replaced three multiplications by one
multiplication and one division, in other words x7 = x8 · x−1. For our running
example, this gives
e = 11 010 000 100 100 100 ¯100 0¯10 0¯10 ¯100 ¯100,

2.7 Chinese remainder theorem
73
which has only ten non-zero digits, apart from the leading one, instead of
15 with bits 0 and 1 only. The redundant representation with bits {0, 1, ¯1} is
called the Booth representation. It is a special case of the Avizienis signed-digit
redundant representation. Signed-digit representations exist in any base.
For simplicity, we have not distinguished between the cost of multiplica-
tion and the cost of squaring (when the two operands in the multiplication are
known to be equal), but this distinction is signiﬁcant in some applications (e.g.
elliptic curve cryptography). Note that, when the underlying group operation
is denoted by addition rather than multiplication, as is usually the case for
abelian groups (such as groups deﬁned over elliptic curves), then the discus-
sion above applies with “multiplication” replaced by “addition”, “division” by
“subtraction”, and “squaring” by “doubling”.
2.7 Chinese remainder theorem
In applications where integer or rational results are expected, it is often worth-
while to use a “residue number system” (as in §2.1.3) and perform all compu-
tations modulo several small primes (or pairwise coprime integers). The ﬁnal
result can then be recovered via the Chinese remainder theorem (CRT). For
such applications, it is important to have fast conversion routines from integer
to modular representation, and vice versa.
The integer to modular conversion problem is the following: given an integer
x, and several pairwise coprime moduli mi, 1 ≤i ≤k, how do we efﬁciently
compute xi = x mod mi, for 1 ≤i ≤k? This is the remainder tree problem of
Algorithm IntegerToRNS, which is also discussed in §2.5.1 and Exercise 1.35.
Algorithm 2.15 IntegerToRNS
Input: integer x, moduli m1, m2, . . . , mk pairwise coprime, k ≥1
Output: xi = x mod mi for 1 ≤i ≤k
1: if k ≤2 then
2:
return x1 = x mod m1, . . . , xk = x mod mk
3: ℓ←⌊k/2⌋
4: M1 ←m1m2 · · · mℓ,
M2 ←mℓ+1 · · · mk
⊲might be precomputed
5: x1, . . . , xℓ←IntegerToRNS(x mod M1, m1, . . . , mℓ)
6: xℓ+1, . . . , xk ←IntegerToRNS(x mod M2, mℓ+1, . . . , mk).
If all moduli mi have the same size, and if the size n of x is comparable to
that of the product m1m2 · · · mk, the cost T(k) of Algorithm IntegerToRNS

74
Modular arithmetic and the FFT
satisﬁes the recurrence T(n) = 2D(n/2) + 2T(n/2), which yields T(n) =
O(M(n) log n). Such a conversion is therefore more expensive than a multipli-
cation or division, and is comparable in complexity terms to a base conversion
or a gcd.
The converse CRT reconstruction problem is the following: given the xi,
how do we efﬁciently reconstruct the unique integer x, 0 ≤x < m1m2 · · · mk,
such that x = xi mod mi, for 1 ≤i ≤k? Algorithm RNSToInteger performs
that conversion, where the values u, v at step 7 might be precomputed if several
conversions are made with the same moduli, and step 11 ensures that the ﬁnal
result x lies in the interval [0, M1M2).
Algorithm 2.16 RNSToInteger
Input: residues xi, 0 ≤xi < mi for 1 ≤i ≤k, mi pairwise coprime
Output: 0 ≤x < m1m2 · · · mk with x = xi mod mi
1: if k = 1 then
2:
return x1
3: ℓ←⌊k/2⌋
4: M1 ←m1m2 · · · mℓ,
M2 ←mℓ+1 · · · mk
⊲might be precomputed
5: X1 ←RNSToInteger([x1, . . . , xℓ], [m1, . . . , mℓ])
6: X2 ←RNSToInteger([xℓ+1, . . . , xk], [mℓ+1, . . . , mk])
7: compute u, v such that uM1 + vM2 = 1
⊲might be precomputed
8: λ1 ←uX2 mod M2,
λ2 ←vX1 mod M1
9: x ←λ1M1 + λ2M2
10: if x ≥M1M2 then
11:
x ←x −M1M2.
To see that Algorithm RNSToInteger is correct, consider an integer i, 1 ≤
i ≤k, and show that x = xi mod mi. If k = 1, it is trivial. Assume k ≥2,
and without loss of generality 1 ≤i ≤ℓ. Since M1 is a multiple of mi, we
have x mod mi = (x mod M1) mod mi, where
x mod M1 = λ2M2 mod M1 = vX1M2 mod M1 = X1 mod M1,
and the result follows from the induction hypothesis that X1 = xi mod mi.
Like IntegerToRNS, Algorithm RNSToInteger costs O(M(n) log n) for
M = m1m2 · · · mk of size n, assuming that the mi are of equal sizes.
The CRT reconstruction problem is analogous to the Lagrange polynomial
interpolation problem: ﬁnd a polynomial of minimal degree interpolating given
values xi at k points mi.

2.8 Exercises
75
A “ﬂat” variant of the explicit Chinese remainder reconstruction is the
following, taking for example k = 3
x = λ1x1 + λ2x2 + λ3x3,
where λi = 1 mod mi, and λi = 0 mod mj for j ̸= i. In other words, λi is
the reconstruction of x1 = 0, . . . , xi−1 = 0, xi = 1, xi+1 = 0, . . . , xk = 0.
For example, with m1 = 11, m2 = 13 and m3 = 17, we get
x = 221x1 + 1496x2 + 715x3.
To reconstruct the integer corresponding to x1 = 2, x2 = 3, x3 = 4, we
get x = 221 · 2 + 1496 · 3 + 715 · 4 = 7790, which after reduction modulo
11 · 13 · 17 = 2431 gives 497.
2.8 Exercises
Exercise 2.1 In §2.1.3 we considered the representation of non-negative inte-
gers using a residue number system. Show that a residue number system can
also be used to represent signed integers, provided their absolute values are not
too large. (Speciﬁcally, if relatively prime moduli m1, m2, . . . , mk are used,
and B = m1m2 · · · mk, the integers x should satisfy |x| < B/2.)
Exercise 2.2 Suppose two non-negative integers x and y are represented by
their residues modulo a set of relatively prime moduli m1, m2, . . . , mk as in
§2.1.3. Consider the comparison problem: is x < y? Is it necessary to convert
x and y back to a standard (non-CRT) representation in order to answer this
question? Similarly, if a signed integer x is represented as in Exercise 2.1,
consider the sign detection problem: is x < 0?
Exercise 2.3 Consider the use of redundant moduli in the Chinese remainder
representation. In other words, using the notation of Exercise 2.2, consider the
case that x could be reconstructed without using all the residues. Show that this
could be useful for error detection (and possibly error correction) if arithmetic
operations are performed on unreliable hardware.
Exercise 2.4 Consider the two complexity bounds O(M(d log(Nd))) and
O(M(d)M(log N)) given at the end of §2.1.5. Compare the bounds in three
cases: (a) d ≪N; (b) d ∼N; (c) d ≫N. Assume two subcases for the mul-
tiplication algorithm: (i) M(n) = O(n2); (ii) M(n) = O(n log n). (For the
sake of simplicity, ignore any log log factors.)

76
Modular arithmetic and the FFT
Exercise 2.5 Show that, if a symmetric representation in [−N/2, N/2) is used
in Algorithm ModularAdd (§2.2), then the probability that we need to add or
subtract N is 1/4 if N is even, and (1 −1/N 2)/4 if N is odd (assuming in
both cases that a and b are uniformly distributed).
Exercise 2.6 Write down the complexity of the Montgomery–Svoboda algo-
rithm (§2.4.2, page 61) for k steps. For k = 3, use van der Hoeven’s relaxed
Karatsuba multiplication [124] to save one M(n/3) product.
Exercise 2.7 Assume you have an FFT algorithm computing products modulo
2n+1. Prove that, with some preconditioning, you can perform a division with
remainder of a 2n-bit integer by an n-bit integer as fast as 1.5 multiplications
of n bits by n bits.
Exercise 2.8 Assume you know p(x) mod (xn1 −1) and p(x) mod (xn2 −1),
where p(x) ∈F[x] has degree n−1, and n1 > n2, and F is a ﬁeld. Up to which
value of n can you uniquely reconstruct p? Design a corresponding algorithm.
Exercise 2.9 Consider the problem of computing the Fourier transform of a
vector a = [a0, a1, . . . , aK−1], deﬁned in Eqn. (2.1), when the size K is not a
power of two. For example, K might be an odd prime or an odd prime power.
Can you ﬁnd an algorithm to do this in O(K log K) operations?
Exercise 2.10 Consider the problem of computing the cyclic convolution of
two K-vectors, where K is not a power of two. (For the deﬁnition, with K
replaced by N, see §3.3.1.) Show that the cyclic convolution can be computed
using FFTs on 2λ points for some suitable λ, or by using DFTs on K points
(see Exercise 2.9). Which method is better?
Exercise 2.11 Devise a parallel version of Algorithm MultipleInversion as
outlined in §2.5.1. Analyse its time and space complexity. Try to minimize the
number of parallel processors required while achieving a parallel time com-
plexity of O(log k).
Exercise 2.12 Analyse the complexity of the algorithm outlined at the end
of §2.5.1 to compute 1/x mod N1, . . . , 1/x mod Nk, when all the Ni have
size n, and x has size ℓ. For which values of n, ℓis it faster than the naive
algorithm which computes all modular inverses separately? [Assume M(n) is
quasi-linear, and neglect multiplicative constants.]
Exercise 2.13 Write a RightToLeftBinaryExp algorithm and compare it with
Algorithm LeftToRightBinaryExp of §2.6.1.

2.9 Notes and references
77
Exercise 2.14 Investigate heuristic algorithms for obtaining close-to-optimal
addition (or multiplication) chains when the cost of a general addition a + b
(or multiplication a · b) is λ times the cost of duplication a + a (or squaring
a · a), and λ is some ﬁxed positive constant. (This is a reasonable model for
modular exponentiation, because multiplication mod N is generally more ex-
pensive than squaring mod N. It is also a reasonable model for operations in
groups deﬁned by elliptic curves, since in this case the formulæ for addition
and duplication are usually different and have different costs.)
2.9 Notes and references
Several number-theoretic algorithms make heavy use of modular arithmetic, in
particular integer factorization algorithms (for example: Pollard’s ρ algorithm
and the elliptic curve method).
Another important application of modular arithmetic in computer algebra
is computing the roots of a univariate polynomial over a ﬁnite ﬁeld, which
requires efﬁcient arithmetic over Fp[x]. See for example the excellent book
“MCA” by von zur Gathen and Gerhard [100].
We say in §2.1.3 that residue number systems can only be used when N
factors into N1N2 . . .; this is not quite true, since Bernstein and Sorenson show
in [24] how to perform modular arithmetic using a residue number system.
For notes on the Kronecker–Sch¨onhage trick, see §1.9.
Barrett’s algorithm is described in [14], which also mentions the idea of
using two short products. The original description of Montgomery’s REDC al-
gorithm is [169]. It is now widely used in several applications. However, only
a few authors considered using a reduction factor which is not of the form
βn, among them McLaughlin [160] and Mihailescu [164]. The Montgomery–
Svoboda algorithm (§2.4.2) is also called “Montgomery tail tayloring” by
Hars [113], who attributes Svoboda’s algorithm – more precisely its variant
with the most signiﬁcant word being β −1 instead of β – to Quisquater. The
folding optimization of REDC described in §2.4.2 (Subquadratic Montgomery
Reduction) is an LSB-extension of the algorithm described in the context of
Barrett’s algorithm by Hasenplaugh, Gaubatz, and Gopal [118]. Amongst the
algorithms not covered in this book, we mention the “bipartite modular multi-
plication” of Kaihara and Takagi [134], which involves performing both MSB-
and LSB-division in parallel.
The description of McLaughlin’s algorithm in §2.4.3 follows [160, Varia-
tion 2]; McLaughlin’s algorithm was reformulated in a polynomial context by
Mihailescu [164].

78
Modular arithmetic and the FFT
Many authors have proposed FFT algorithms, or improvements of such al-
gorithms, and applications such as fast computation of convolutions. Some
references are Aho, Hopcroft, and Ullman [3]; Nussbaumer [176]; Borodin
and Munro [35], who describe the polynomial approach; Van Loan [222] for
the linear algebra approach; and Pollard [185] for the FFT over ﬁnite ﬁelds.
Rader [187] considered the case where the number of data points is a prime,
and Winograd [230] generalized Rader’s algorithm to prime powers. Bluestein’s
algorithm [30] is also applicable in these cases. In Bernstein [22, §23] the
reader will ﬁnd some historical remarks and several nice applications of the
FFT.
The Sch¨onhage–Strassen algorithm ﬁrst appeared in [199]. Recently,
F¨urer [98] has proposed an integer multiplication algorithm that is asymptoti-
cally faster than the Sch¨onhage–Strassen algorithm. F¨urer’s algorithm almost
achieves the conjectured best possible Θ(n log n) running time.
Concerning special moduli, Percival considers in [183] the case N = a ± b,
where both a and b are highly composite; this is a generalization of the case
N = βn ± 1. The pseudo-Mersenne primes of §2.4.4 are recommended in
the National Institute of Standards and Technology (NIST) Digital Signature
Standard [75]. See also the book by Hankerson, Menezes, and Vanstone [110].
Algorithm MultipleInversion – also known as “batch inversion” – is due
to Montgomery [170]. The application of Barrett’s algorithm for an implicitly
invariant divisor was suggested by Granlund.
Modular exponentiation and cryptographic algorithms are described in much
detail in the book by Menezes, van Oorschot, and Vanstone [161, Chapter 14].
A detailed description of the best theoretical algorithms, with references, can
be found in Bernstein [18]. When both the modulus and base are invariant,
modular exponentiation with k-bit exponent and n-bit modulus can be per-
formed in time O((k/ log k)M(n)), after a precomputation of O(k/ log k)
powers in time O(kM(n)). Take for example b = 2k/t in Note 14.112 and
Algorithm 14.109 of [161], with t log t ≈k, where the powers abi mod N
for 0 ≤i < t are precomputed. An algorithm of same complexity using a
DBNS (Double-Base Number System) was proposed by Dimitrov, Jullien, and
Miller [86], however with a larger table of Θ(k2) precomputed powers.
Original papers on Booth recoding, SRT division, etc., are reprinted in the
book by Swartzlander [212].
A quadratic algorithm for CRT reconstruction is discussed in Cohen [73];
M¨oller gives some improvements in the case of a small number of small moduli
known in advance [167]. Algorithm IntegerToRNS can be found in Borodin
and Moenck [34]. The explicit Chinese remainder theorem and its applications
to modular exponentiation are discussed by Bernstein and Sorenson in [24].

3
Floating-point arithmetic
This chapter discusses the basic operations – addition, subtrac-
tion, multiplication, division, square root, conversion – on arbi-
trary precision ﬂoating-point numbers, as Chapter 1 does for ar-
bitrary precision integers. More advanced functions such as el-
ementary and special functions are covered in Chapter 4. This
chapter largely follows the IEEE 754 standard, and extends it in
a natural way to arbitrary precision; deviations from IEEE 754
are explicitly mentioned. By default, IEEE 754 refers to the 2008
revision, known as IEEE 754-2008; we write IEEE 754-1985
when we explicitly refer to the 1985 initial standard. Topics
not discussed here include: hardware implementations, ﬁxed-
precision implementations, special representations.
3.1 Representation
The classical non-redundant representation of a ﬂoating-point number x in
radix β > 1 is the following (other representations are discussed in §3.8):
x = (−1)s · m · βe,
(3.1)
where (−1)s, s ∈{0, 1}, is the sign, m ≥0 is the signiﬁcand, and the integer
e is the exponent of x. In addition, a positive integer n deﬁnes the precision of
x, which means that the signiﬁcand m contains at most n signiﬁcant digits in
radix β.
An important special case is m = 0 representing zero. In this case, the sign
s and exponent e are irrelevant and may be used to encode other information
(see for example §3.1.3).
For m ̸= 0, several semantics are possible; the most common ones are:

80
Floating-point arithmetic
• β−1 ≤m < 1, then βe−1 ≤|x| < βe. In this case, m is an integer multiple
of β−n. We say that the unit in the last place of x is βe−n, and we write
ulp(x) = βe−n. For example, x = 3.1416 with radix β = 10 is encoded
by m = 0.31416 and e = 1. This is the convention that we will use in this
chapter.
• 1 ≤m < β, then βe ≤|x| < βe+1, and ulp(x) = βe+1−n. With radix ten
the number x = 3.1416 is encoded by m = 3.1416 and e = 0. This is the
convention adopted in the IEEE 754 standard.
• We can also use an integer signiﬁcand βn−1 ≤m < βn, then βe+n−1 ≤
|x| < βe+n, and ulp(x) = βe. With radix ten the number x = 3.1416 is
encoded by m = 31416 and e = −4.
Note that in the above three cases, there is only one possible representation of
a non-zero ﬂoating-point number: we have a canonical representation. In some
applications, it is useful to relax the lower bound on non-zero m, which in the
three cases above gives respectively 0 < m < 1, 0 < m < β, and 0 < m <
βn, with m an integer multiple of βe−n, βe+1−n, and 1 respectively. In this
case, there is no longer a canonical representation. For example, with an integer
signiﬁcand and a precision of ﬁve digits, the number 3.1400 might be encoded
by (m = 31400, e = −4), (m = 03140, e = −3), or (m = 00314, e = −2).
This non-canonical representation has the drawback that the most signiﬁcant
non-zero digit of the signiﬁcand is not known in advance. The unique encoding
with a non-zero most signiﬁcant digit, i.e. (m = 31400, e = −4) here, is called
the normalized – or simply normal – encoding.
The signiﬁcand is also sometimes called the mantissa or fraction. The above
examples demonstrate that the different signiﬁcand semantics correspond to
different positions of the decimal (or radix β) point, or equivalently to different
biases of the exponent. We assume in this chapter that both the radix β and the
signiﬁcand semantics are implicit for a given implementation, and thus are not
physically encoded.
The words “base” and “radix” have similar meanings. For clarity, we reserve
“radix” for the constant β in a ﬂoating-point representation, such as (3.1). The
signiﬁcand m and exponent e might be stored in a different base, as discussed
below.
3.1.1 Radix choice
Most ﬂoating-point implementations use radix β = 2 or a power of two,
because this is convenient and efﬁcient on binary computers. For a radix β,
which is not a power of 2, two choices are possible:

3.1 Representation
81
• Store the signiﬁcand in base β, or more generally in base βk for an integer
k ≥1. Each digit in base βk requires ⌈k lg β⌉bits. With such a choice, indi-
vidual digits can be accessed easily. With β = 10 and k = 1, this is the “Bi-
nary Coded Decimal” or BCD encoding: each decimal digit is represented
by four bits, with a memory loss of about 17% (since lg(10)/4 ≈0.83). A
more compact choice is radix 103, where three decimal digits are stored in
ten bits, instead of in 12 bits with the BCD format. This yields a memory
loss of only 0.34% (since lg(1000)/10 ≈0.9966).
• Store the signiﬁcand in binary. This idea is used in Intel’s Binary-Integer
Decimal (BID) encoding, and in one of the two decimal encodings in IEEE
754-2008. Individual digits can not be accessed directly, but we can use efﬁ-
cient binary hardware or software to perform operations on the signiﬁcand.
A drawback of the binary encoding is that, during the addition of two arbitrary-
precision numbers, it is not easy to detect if the signiﬁcand exceeds the max-
imum value βn −1 (when considered as an integer) and thus if rounding is
required. Either βn is precomputed, which is only realistic if all computations
involve the same precision n, or it is computed on the ﬂy, which might result
in increased complexity (see Chapter 1 and §2.6.1).
3.1.2 Exponent range
In principle, we might consider an unbounded exponent. In other words, the
exponent e might be encoded by an arbitrary-precision integer (see Chapter 1).
This would have the great advantage that no underﬂow or overﬂow could occur
(see below). However, in most applications, an exponent encoded in 32 bits is
more than enough: this enables us to represent values up to about 10646 456 993
for β = 2. A result exceeding this value most probably corresponds to an error
in the algorithm or the implementation. Using arbitrary-precision integers for
the exponent induces an extra overhead that slows down the implementation in
the average case, and it usually requires more memory to store each number.
Thus, in practice the exponent nearly always has a limited range emin ≤
e ≤emax. We say that a ﬂoating-point number is representable if it can be
represented in the form (−1)s · m · βe with emin ≤e ≤emax. The set of
representable numbers clearly depends on the signiﬁcand semantics. For the
convention we use here, i.e. β−1 ≤m < 1, the smallest positive representable
ﬂoating-point number is βemin−1, and the largest one is βemax(1 −β−n).
Other conventions for the signiﬁcand yield different exponent ranges. For
example, the double-precision format – called binary64 in IEEE 754-2008 –
has emin = −1022, emax = 1023 for a signiﬁcand in [1, 2); this corresponds to

82
Floating-point arithmetic
emin = −1021, emax = 1024 for a signiﬁcand in [1/2, 1), and emin = −1074,
emax = 971 for an integer signiﬁcand in [252, 253).
3.1.3 Special values
With a bounded exponent range, if we want a complete arithmetic, we need
some special values to represent very large and very small values. Very small
values are naturally ﬂushed to zero, which is a special number in the sense that
its signiﬁcand is m = 0, which is not normalized. For very large values, it
is natural to introduce two special values −∞and +∞, which encode large
non-representable values. Since we have two inﬁnities, it is natural to have two
zeros −0 and +0, for example 1/(−∞) = −0 and 1/(+∞) = +0. This is the
IEEE 754 choice. Another possibility would be to have only one inﬁnity and
one zero 0, forgetting the sign in both cases.
An additional special value is Not a Number (NaN), which either represents
an uninitialized value, or is the result of an invalid operation like √−1 or
(+∞) −(+∞). Some implementations distinguish between different kinds of
NaN, in particular IEEE 754 deﬁnes signaling and quiet NaNs.
3.1.4 Subnormal numbers
Subnormal numbers are required by the IEEE 754 standard, to allow what is
called gradual underﬂow between the smallest (in absolute value) non-zero
normalized numbers and zero. We ﬁrst explain what subnormal numbers are;
then we will see why they are not necessary in arbitrary precision.
Assume we have an integer signiﬁcand in [βn−1, βn), where n is the pre-
cision, and an exponent in [emin, emax]. Write η = βemin. The two smallest
positive normalized numbers are x = βn−1η and y = (βn−1 + 1)η. The
difference y −x equals η, which is tiny compared to x. In particular, y −x
can not be represented exactly as a normalized number (assuming βn−1 > 1)
and will be rounded to zero in “rounding to nearest” mode (§3.1.9). This has
the unfortunate consequence that instructions such as
if (y != x) then
z = 1.0/(y - x);
will produce a “division by zero” error when executing 1.0/(y - x).
Subnormal numbers solve this problem. The idea is to relax the condition
βn−1 ≤m for the exponent emin. In other words, we include all numbers
of the form m · βemin for 1 ≤m < βn−1 in the set of valid ﬂoating-point

3.1 Representation
83
numbers. We could also permit m = 0, and then zero would be a subnormal
number, but we continue to regard zero as a special case.
Subnormal numbers are all positive integer multiples of ±η, with a multi-
plier m, 1 ≤m < βn−1. The difference between x = βn−1η and
y = (βn−1 + 1)η is now representable, since it equals η, the smallest positive
subnormal number. More generally, all ﬂoating-point numbers are multiples of
η, likewise for their sum or difference (in other words, operations in the sub-
normal domain correspond to ﬁxed-point arithmetic). If the sum or difference
is non-zero, it has magnitude at least η, and thus can not be rounded to zero.
Therefore, the “division by zero” problem mentioned above does not occur
with subnormal numbers.
In the IEEE 754 double-precision format – called binary64 in IEEE 754-
2008 – the smallest positive normal number is 2−1022, and the smallest positive
subnormal number is 2−1074. In arbitrary precision, subnormal numbers sel-
dom occur, since usually the exponent range is huge compared to the expected
exponents in a given application. Thus, the only reason for implementing sub-
normal numbers in arbitrary precision is to provide an extension of IEEE 754
arithmetic. Of course, if the exponent range is unbounded, then there is ab-
solutely no need for subnormal numbers, because any non-zero ﬂoating-point
number can be normalized.
3.1.5 Encoding
The encoding of a ﬂoating-point number x = (−1)s · m · βe is the way the
values s, m, and e are stored in the computer. Remember that β is implicit, i.e.
is considered ﬁxed for a given implementation; as a consequence, we do not
consider here mixed radix operations involving numbers with different radices
β and β′.
We have already seen that there are several ways to encode the signiﬁcand
m when β is not a power of two, in base-βk or in binary. For normal numbers
in radix 2, i.e. 2n−1 ≤m < 2n, the leading bit of the signiﬁcand is necessarily
one, thus we might choose not the encode it in memory, to gain an extra bit
of precision. This is called the implicit leading bit, and it is the choice made
in the IEEE 754 formats. For example, the double-precision format has a sign
bit, an exponent ﬁeld of 11 bits, and a signiﬁcand of 53 bits, with only 52 bits
stored, which gives a total of 64 stored bits:
sign
(biased) exponent
signiﬁcand
(1 bit)
(11 bits)
(52 bits, plus implicit leading bit)

84
Floating-point arithmetic
A nice consequence of this particular encoding is the following. Let x be a
double-precision number, neither subnormal, ±∞, NaN, nor the largest normal
number in absolute value. Consider the 64-bit encoding of x as a 64-bit integer,
with the sign bit in the most signiﬁcant bit, the exponent bits in the next most
signiﬁcant bits, and the explicit part of the signiﬁcand in the low signiﬁcant
bits. Adding 1 to this 64-bit integer yields the next double-precision number
to x, away from zero. Indeed, if the signiﬁcand m is smaller than 253 −1, m
becomes m + 1, which is smaller than 253. If m = 253 −1, then the lowest
52 bits are all set, and a carry occurs between the signiﬁcand ﬁeld and the
exponent ﬁeld. Since the signiﬁcand ﬁeld becomes zero, the new signiﬁcand is
252, taking into account the implicit leading bit. This corresponds to a change
from (253 −1) · 2e to 252 · 2e+1, which is exactly the next number away from
zero. Thanks to this consequence of the encoding, an integer comparison of
two words (ignoring the actual type of the operands) should give the same
result as a ﬂoating-point comparison, so it is possible to sort normal positive
ﬂoating-point numbers as if they were integers of the same length (64-bit for
double precision).
In arbitrary precision, saving one bit is not as crucial as in ﬁxed (small)
precision, where we are constrained by the word size (usually 32 or 64 bits).
Thus, in arbitrary precision, it is easier and preferable to encode the whole
signiﬁcand. Also, note that having an “implicit bit” is not possible in radix
β > 2, since for a normal number the most signiﬁcant digit might take several
values, from 1 to β −1.
When the signiﬁcand occupies several words, it can be stored in a linked
list, or in an array (with a separate size ﬁeld). Lists are easier to extend, but
accessing arrays is usually more efﬁcient because fewer memory references
are required in the inner loops and memory locality is better.
The sign s is most easily encoded as a separate bit ﬁeld, with a non-negative
signiﬁcand. This is the sign-magnitude encoding. Other possibilities are to
have a signed signiﬁcand, using either one’s complement or two’s complement,
but in the latter case a special encoding is required for zero, if it is desired to
distinguish +0 from −0. Finally, the exponent might be encoded as a signed
word (for example, type long in the C language).
3.1.6 Precision: local, global, operation, operand
The different operands of a given operation might have different precisions,
and the result of that operation might be desired with yet another precision.
There are several ways to address this issue.

3.1 Representation
85
• The precision, say n, is attached to a given operation. In this case, operands
with a smaller precision are automatically converted to precision n. Operands
with a larger precision might either be left unchanged, or rounded to preci-
sion n. In the former case, the code implementing the operation must be able
to handle operands with different precisions. In the latter case, the round-
ing mode to shorten the operands must be speciﬁed. Note that this round-
ing mode might differ from that of the operation itself, and that operand
rounding might yield large errors. Consider for example a = 1.345 and
b = 1.234567 with a precision of four digits. If b is taken as exact, the exact
value of a −b equals 0.110433, which when rounded to nearest becomes
0.1104. If b is ﬁrst rounded to nearest to four digits, we get b′ = 1.235, and
a −b′ = 0.1100 is rounded to itself.
• The precision n is attached to each variable. Here again two cases may occur.
If the operation destination is part of the operation inputs, as in
sub(c, a, b), which means c ←round(a −b), then the precision of
the result operand c is known, and thus the rounding precision is known
in advance. Alternatively, if no precision is given for the result, we might
choose the maximal (or minimal) precision from the input operands, or use
a global variable, or request an extra precision parameter for the operation,
as in c = sub(a, b, n).
Of course, these different semantics are inequivalent, and may yield different
results. In the following, we consider the case where each variable, including
the destination variable, has its own precision, and no pre-rounding or post-
rounding occurs. In other words, the operands are considered exact to their full
precision.
Rounding is considered in detail in §3.1.9. Here we deﬁne what we mean by
the correct rounding of a function.
Deﬁnition 3.1 Let a, b, . . . be ﬂoating-point numbers, f a mathematical func-
tion, n ≥1 an integer, and ◦a rounding mode. We say that c is the cor-
rect rounding of f(a, b, . . .), and we write c = ◦n(f(a, b, . . .)), if c is the
ﬂoating-point number closest to f(a, b, . . .) in precision n and according to
the given rounding mode. In case several numbers are at the same distance
from f(a, b, . . .), the rounding mode must deﬁne in a deterministic way which
one is “the closest”. When there is no ambiguity, we omit n and write simply
c = ◦(f(a, b, . . .)).

86
Floating-point arithmetic
3.1.7 Link to integers
Most ﬂoating-point operations reduce to arithmetic on the signiﬁcands, which
can be considered as integers as seen at the beginning of this section.
Therefore, efﬁcient arbitrary precision ﬂoating-point arithmetic requires efﬁ-
cient underlying integer arithmetic (see Chapter 1).
Conversely, ﬂoating-point numbers might be useful for the implementation
of arbitrary precision integer arithmetic. For example, we might use hard-
ware ﬂoating-point numbers to represent an arbitrary precision integer. Indeed,
since a double-precision ﬂoating-point number has 53 bits of precision, it can
represent an integer up to 253 −1, and an integer A can be represented as
A = an−1βn−1 + · · · + aiβi + · · · + a1β + a0, where β = 253, and the ai
are stored in double-precision data types. Such an encoding was popular when
most processors were 32-bit, and some had relatively slow integer operations
in hardware. Now that most computers are 64-bit, this encoding is obsolete.
Floating-point expansions are a variant of the above. Instead of storing ai
and having βi implicit, the idea is to directly store aiβi. Of course, this only
works for relatively small i, i.e. whenever aiβi does not exceed the format
range. For example, for IEEE 754 double precision, the maximal integer preci-
sion is 1024 bits. (Alternatively, we might represent an integer as a multiple of
the smallest positive number 2−1074, with a corresponding maximal precision
of 2098 bits.)
Hardware ﬂoating-point numbers might also be used to implement the fast
Fourier transform (FFT), using complex numbers with ﬂoating-point real and
imaginary part (see §3.3.1).
3.1.8 Ziv’s algorithm and error analysis
A rounding boundary is a point at which the rounding function ◦(x) is discon-
tinuous.
In ﬁxed precision, for basic arithmetic operations, it is sometimes possible
to design one-pass algorithms that directly compute a correct rounding. How-
ever, in arbitrary precision, or for elementary or special functions, the classical
method is to use Ziv’s algorithm:
1. we are given an input x, a target precision n, and a rounding mode;
2. compute an approximation y with precision m > n, and a corresponding
error bound ε such that |y −f(x)| ≤ε;
3. if [y −ε, y + ε] contains a rounding boundary, increase m and go to step 2;
4. output the rounding of y, according to the given rounding mode.

3.1 Representation
87
The error bound ε at step 2 might be computed either a priori, i.e. from x and
n only, or dynamically, i.e. from the different intermediate values computed by
the algorithm. A dynamic bound will usually be tighter, but will require extra
computations (however, those computations might be done in low precision).
Depending on the mathematical function to be implemented, we might pre-
fer an absolute or a relative error analysis. When computing a relative error
bound, at least two techniques are available: we might express the errors in
terms of units in the last place (ulps), or we might express them in terms of
true relative error. It is of course possible in a given analysis to mix both kinds
of errors, but in general a constant factor – the radix β – is lost when converting
from one kind of relative error to the other kind.
Another important distinction is forward versus backward error analysis.
Assume we want to compute y = f(x). Because the input is rounded, and/or
because of rounding errors during the computation, we might actually compute
y′ ≈f(x′). Forward error analysis will bound |y′ −y| if we have a bound on
|x′ −x| and on the rounding errors that occur during the computation.
Backward error analysis works in the other direction. If the computed value
is y′, then backward error analysis will give us a number δ such that, for some
x′ in the ball |x′ −x| ≤δ, we have y′ = f(x′). This means that the error is
no worse than might have been caused by an error of δ in the input value. Note
that, if the problem is ill-conditioned, δ might be small even if |y′ −y| is large.
In our error analyses, we assume that no overﬂow or underﬂow occurs,
or equivalently that the exponent range is unbounded, unless the contrary is
explicitly stated.
3.1.9 Rounding
There are several possible deﬁnitions of rounding. For example probabilistic
rounding – also called stochastic rounding – chooses at random a rounding
towards +∞or −∞for each operation. The IEEE 754 standard deﬁnes four
rounding modes: towards zero, +∞, −∞and to nearest (with ties broken to
even). Another useful mode is “rounding away from zero”, which rounds in the
opposite direction from zero: a positive number is rounded towards +∞, and a
negative number towards −∞. If the sign of the result is known, all IEEE 754
rounding modes might be converted to either rounding to nearest, rounding
towards zero, or rounding away from zero.
Theorem 3.2 Consider a ﬂoating-point system with radix β and precision n.
Let u be the rounding to nearest of some real x. Then the following inequalities
hold: |u −x| ≤1
2 ulp(u), |u −x| ≤1
2β1−n|u|, |u −x| ≤1
2β1−n|x|.

88
Floating-point arithmetic
Proof. For x = 0, necessarily u = 0, and the statement holds. Without loss of
generality, we can assume u and x positive. The ﬁrst inequality is the deﬁnition
of rounding to nearest, and the second one follows from ulp(u) ≤β1−nu.
(In the case β = 2, it gives |u −x| ≤2−n|u|.) For the last inequality, we
distinguish two cases: if u ≤x, it follows from the second inequality. If x < u,
then if x and u have the same exponent, i.e. βe−1 ≤x < u < βe, then
ulp(u) = βe−n ≤β1−nx. The remaining case is βe−1 ≤x < u = βe. Since
the ﬂoating-point number preceding βe is βe(1 −β−n), and x was rounded to
nearest, we have |u −x| ≤βe−n/2 here too.
In order to round according to a given rounding mode, we proceed as fol-
lows:
1. ﬁrst round as if the exponent range was unbounded, with the given rounding
mode;
2. if the rounded result is within the exponent range, return this result;
3. otherwise raise the “underﬂow” or “overﬂow” exception, and return ±0 or
±∞accordingly.
For example, assume radix 10 with precision 4, emax = 3, with x = 0.9234 ·
103, y = 0.7656·102. The exact sum x+y equals 0.99996·103. With rounding
towards zero, we obtain 0.9999 · 103, which is representable, so there is no
overﬂow. With rounding to nearest, x + y rounds to 0.1000 · 104, where the
exponent 4 exceeds emax = 3, so we get +∞as the result, with an overﬂow.
In this model, overﬂow depends not only on the operands, but also on the
rounding mode.
The “round to nearest” mode of IEEE 754 rounds the result of an operation
to the nearest representable number. In case the result of an operation is exactly
halfway between two consecutive numbers, the one with least signiﬁcant bit
zero is chosen (for radix 2). For example, 1.10112 is rounded with a precision
of four bits to 1.1102, as is 1.11012. However, this rule does not readily extend
to an arbitrary radix. Consider for example radix β = 3, a precision of four
digits, and the number 1212.111 . . .3. Both 12123 and 12203 end in an even
digit. The natural extension is to require the whole signiﬁcand to be even, when
interpreted as an integer in [βn−1, βn −1]. In this setting, (1212.111 . . .)3
rounds to (1212)3 = 5010. (Note that βn is an odd number here.)
Assume we want to correctly round a real number, whose binary expansion
is 2e · 0.1b2 . . . bnbn+1 . . ., to n bits. It is enough to know the values of r =
bn+1 – called the round bit – and that of the sticky bit s, which is zero when
bn+2bn+3 . . . is identically zero, and one otherwise. Table 3.1 shows how to
correctly round given r, s, and the given rounding mode; rounding to ±∞

3.1 Representation
89
being converted to rounding towards zero or away from zero, according to the
sign of the number. The entry “bn” is for round to nearest in the case of a tie:
if bn = 0, it will be unchanged, but if bn = 1, we add one (thus changing bn
to zero).
r
s
towards zero
to nearest
away from zero
0
0
0
0
0
0
1
0
0
1
1
0
0
bn
1
1
1
0
1
1
Table 3.1 Rounding rules according to the round bit r and
the sticky bit s: a “0” entry means truncate (round towards
zero), a “1” means round away from zero (add one to the
truncated signiﬁcand).
In general, we do not have an inﬁnite expansion, but a ﬁnite approximation y
of an unknown real value x. For example, y might be the result of an arithmetic
operation such as division, or an approximation to the value of a transcendental
function such as exp. The following problem arises: given the approximation
y, and a bound on the error |y −x|, is it possible to determine the correct
rounding of x? Algorithm RoundingPossible returns true iff it is possible.
Algorithm 3.1 RoundingPossible
Input: a ﬂoating-point number y = 0.1y2 . . . ym, a precision n ≤m, an error
bound ε = 2−k, a rounding mode ◦
Output: true when ◦n(x) can be determined for |y −x| ≤ε
if k ≤n + 1 then return false
if ◦is to nearest then r ←1 else r ←0
if yn+1 = r and yn+2 = · · · = yk = 0 then s ←0 else s ←1
if s = 1 then return true else return false.
Proof of correctness. Since rounding is monotonic, it is possible to determine
◦(x) exactly when ◦(y −2−k) = ◦(y + 2−k), or in other words when the
interval [y −2−k, y + 2−k] contains no rounding boundary (or only one as
y −2−k or y + 2−k).
If k ≤n + 1, then the interval [−2−k, 2−k] has width at least 2−n, and
thus contains at least one rounding boundary in its interior, or two rounding
boundaries, and it is not possible to round correctly. In the case of

90
Floating-point arithmetic
directed rounding (resp. rounding to nearest), if s = 0, the approximation y is
representable (resp. the middle of two representable numbers) in precision
n, and it is clearly not possible to round correctly. If s = 1, the interval
[y −2−k, y +2−k] contains at most one rounding boundary, and, if so, it is one
of the bounds; thus, it is possible to round correctly.
The double rounding problem
When a given real value x is ﬁrst rounded to precision m and then to precision
n < m, we say that a “double rounding” occurs. The “double rounding prob-
lem” happens when this latter value differs from the direct rounding of x to the
smaller precision n, assuming the same rounding mode is used in all cases, i.e.
when
◦n(◦m(x)) ̸= ◦n(x).
The double rounding problem does not occur for directed rounding modes.
For these rounding modes, the rounding boundaries at the larger precision m
reﬁne those at the smaller precision n, thus all real values x that round to the
same value y at precision m also round to the same value at precision n, namely
◦n(y).
Consider the decimal value x = 3.14251. Rounding to nearest to ﬁve digits,
we get y = 3.1425; rounding y to nearest-even to four digits, we get 3.142,
whereas direct rounding of x would give 3.143.
With rounding to nearest mode, the double rounding problem only occurs
when the second rounding involves the even-rule, i.e. the value y = ◦m(x) is
a rounding boundary at precision n. Otherwise, y has distance at least one ulp
(in precision m) from a rounding boundary at precision n, and since |y −x| is
bounded by half an ulp (in precision m), all possible values for x round to the
same value in precision n.
Note that the double rounding problem does not occur with all ways of
breaking ties for rounding to nearest (Exercise 3.2).
3.1.10 Strategies
To determine the correct rounding of f(x) with n bits of precision, the best
strategy is usually to ﬁrst compute an approximation y to f(x) with a working
precision of m = n+h bits, with h relatively small. Several strategies are pos-
sible in Ziv’s algorithm (§3.1.8) when this ﬁrst approximation y is not accurate
enough, or too close to a rounding boundary:
• Compute the exact value of f(x), and round it to the target precision n.
This is possible for a basic operation, for example f(x) = x2, or more

3.2 Addition, subtraction, comparison
91
generally f(x, y) = x + y or x × y. Some elementary functions may yield
an exactly representable output too, for example
√
2.25 = 1.5. An “exact
result” test after the ﬁrst approximation avoids possibly unnecessary further
computations.
• Repeat the computation with a larger working precision m′ = n + h′. As-
suming that the digits of f(x) behave “randomly” and that |f ′(x)/f(x)| is
not too large, using h′ ≈lg n is enough to guarantee that rounding is possi-
ble with probability 1−O(1/n). If rounding is still not possible, because the
h′ last digits of the approximation encode 0 or 2h′ −1, we can increase the
working precision and try again. A check for exact results guarantees that
this process will eventually terminate, provided the algorithm used has the
property that it gives the exact result if this result is representable and the
working precision is high enough. For example, the square root algorithm
should return the exact result if it is representable (see Algorithm FPSqrt in
§3.5, and also Exercise 3.3).
3.2 Addition, subtraction, comparison
Addition and subtraction of ﬂoating-point numbers operate from the most sig-
niﬁcant digits, whereas integer addition and subtraction start from the least
signiﬁcant digits. Thus completely different algorithms are involved. Also, in
the ﬂoating-point case, part or all of the inputs might have no impact on the
output, except in the rounding phase.
In summary, ﬂoating-point addition and subtraction are more difﬁcult to im-
plement than integer addition/subtraction for two reasons:
• Scaling due to the exponents requires shifting the signiﬁcands before adding
or subtracting them – in principle, we could perform all operations using
only integer operations, but this might require huge integers, for example
when adding 1 and 2−1000.
• As the carries are propagated from least to most signiﬁcant digits, we may
have to look at arbitrarily low input digits to guarantee correct rounding.
In this section, we distinguish between “addition”, where both operands to
be added have the same sign, and “subtraction”, where the operands to be
added have different signs (we assume a sign-magnitude representation). The
case of one or both operands zero is treated separately; in the description below
we assume that all operands are non-zero.

92
Floating-point arithmetic
3.2.1 Floating-point addition
Algorithm FPadd adds two binary ﬂoating-point numbers b and c of the same
sign. More precisely, it computes the correct rounding of b + c, with respect
to the given rounding mode ◦. For the sake of simplicity, we assume b and c
are positive, b ≥c > 0. It will also be convenient to scale b and c so that
2n−1 ≤b < 2n and 2m−1 ≤c < 2m, where n is the desired precision of the
output, and m ≤n. Of course, if the inputs b and c to Algorithm FPadd are
scaled by 2k, then, to compensate for this, the output must be scaled by 2−k.
We assume that the rounding mode is to nearest, towards zero, or away from
zero (rounding to ±∞reduces to rounding towards zero or away from zero,
depending on the sign of the operands).
Algorithm 3.2 FPadd
Input: b ≥c > 0 two binary ﬂoating-point numbers, a precision n such that
2n−1 ≤b < 2n, and a rounding mode ◦
Output: a ﬂoating-point number a of precision n and scale e such that
a · 2e = ◦(b + c)
1: split b into bh + bℓwhere bh contains the n most signiﬁcant bits of b.
2: split c into ch + cℓwhere ch contains the most signiﬁcant bits of c, and
ulp(ch) = ulp(bh) = 1
⊲ch might be zero
3: ah ←bh + ch,
e ←0
4: (c, r, s) ←bℓ+ cℓ
⊲see the text
5: (a, t) ←(ah + c + round(◦, r, s), etc.)
⊲for t see Table 3.2 (upper)
6: if a ≥2n then
7:
(a, e) ←(round2(◦, a, t), e + 1)
⊲see Table 3.2 (lower)
8:
if a = 2n then (a, e) ←(a/2, e + 1)
9: return (a, e).
The values of round(◦, r, s) and round2(◦, a, t) are given in Table 3.2. We
have simpliﬁed some of the expressions given in Table 3.2. For example, in
the upper half of the table, r ∨s means 0 if r = s = 0, and 1 otherwise. In
the lower half of the table, 2⌊(a + 1)/4⌋is (a −1)/2 if a = 1 mod 4, and
(a + 1)/2 if a = 3 mod 4.
At step 4 of Algorithm FPadd, the notation (c, r, s) ←bℓ+cℓmeans that c is
the carry bit of bℓ+cℓ, r the round bit, and s the sticky bit; c, r, s ∈{0, 1}. For
rounding to nearest, t = sign(b+c−a) is a ternary value, which is respectively
positive, zero, or negative when a is smaller than, equal to, or larger than the
exact sum b + c.
Theorem 3.3 Algorithm FPadd is correct.

3.2 Addition, subtraction, comparison
93
◦
r
s
round(◦, r, s)
t
towards 0
any
any
0
–
away from 0
any
any
r ∨s
–
to nearest
0
any
0
s
to nearest
1
0
0/1 (even rounding)
+1/−1
to nearest
1
̸= 0
1
−1
◦
a mod 2
t
round2(◦, a, t)
any
0
any
a/2
towards 0
1
any
(a −1)/2
away from 0
1
any
(a + 1)/2
to nearest
1
0
2⌊(a + 1)/4⌋
to nearest
1
±1
(a + t)/2
Table 3.2 Rounding rules for addition.
Proof. We have 2n−1 ≤b < 2n and 2m−1 ≤c < 2m, with m ≤n. Thus,
bh and ch are the integer parts of b and c, bℓand cℓtheir fractional parts. Since
b ≥c, we have ch ≤bh and 2n−1 ≤bh ≤2n−1; thus, 2n−1 ≤ah ≤2n+1−2,
and, at step 5, 2n−1 ≤a ≤2n+1. If a < 2n, a is the correct rounding of b + c.
Otherwise, we face the “double rounding” problem: rounding a down to n bits
will give the correct result, except when a is odd and rounding is to nearest. In
that case, we need to know if the ﬁrst rounding was exact, and if not in which
direction it was rounded; this information is encoded in the ternary value t.
After the second rounding, we have 2n−1 ≤a ≤2n.
Note that the exponent ea of the result lies between eb (the exponent of b –
here we considered the case eb = n) and eb + 2. Thus, no underﬂow can occur
in an addition. The case ea = eb + 2 can occur only when the destination
precision is less than that of the operands.
3.2.2 Floating-point subtraction
Floating-point subtraction (of positive operands) is very similar to addition,
with the difference that cancellation can occur. Consider for example the sub-
traction 6.77823 −5.98771. The most signiﬁcant digit of both operands disap-
peared in the result 0.79052. This cancellation can be dramatic, as in
6.7782357934 −6.7782298731 = 0.0000059203, where six digits were can-
celled.

94
Floating-point arithmetic
Two approaches are possible, assuming n result digits are wanted, and the
exponent difference between the inputs is d:
• Subtract the n −d most-signiﬁcant digits of the smaller operand from the
n most-signiﬁcant digits of the larger operand. If the result has n −e digits
with e > 0, restart with n + e digits from the larger operand and (n + e) −d
from the smaller operand.
• Alternatively, predict the number e of cancelled digits in the subtraction,
and directly subtract the (n + e) −d most-signiﬁcant digits of the smaller
operand from the n + e most-signiﬁcant digits of the larger one.
Note that, in the ﬁrst approach, we might have e = n if all most-signiﬁcant
digits cancel, and thus the process might need to be repeated several times.
The ﬁrst step in the second approach is usually called leading zero detec-
tion. Note that the number e of cancelled digits might depend on the rounding
mode. For example, 6.778 −5.7781 with a 3-digit result yields 0.999 with
rounding toward zero, and 1.00 with rounding to nearest. Therefore, in a real
implementation, the deﬁnition of e has to be made precise.
In practice, we might consider n + g and (n + g) −d digits instead of n
and n−d, where the g “guard digits” would prove useful (i) to decide the ﬁnal
rounding, and/or (ii) to avoid another loop in case e ≤g.
Sterbenz’s theorem
Sterbenz’s theorem is an important result concerning ﬂoating-point subtraction
(of operands of the same sign). It states that the rounding error is zero in some
common cases. More precisely:
Theorem 3.4 (Sterbenz) If x and y are two ﬂoating-point numbers of same
precision n, such that y lies in the interval [x/2, 2x] ∪[2x, x/2], then y −x is
exactly representable in precision n, if there is no underﬂow.
Proof. The case x = y = 0 is trivial, so assume that x ̸= 0. Since y ∈
[x/2, 2x] ∪[2x, x/2], x and y must have the same sign. We assume without
loss of generality that x and y are positive, so y ∈[x/2, 2x].
Assume x ≤y ≤2x (the same reasoning applies for x/2 ≤y ≤x, i.e. y ≤
x ≤2y, by interchanging x and y). Since x ≤y, we have ulp(x) ≤ulp(y),
and thus y is an integer multiple of ulp(x). It follows that y −x is an integer
multiple of ulp(x). Since 0 ≤y −x ≤x, y −x is necessarily representable
with the precision of x.
It is important to note that Sterbenz’s theorem applies for any radix β; the
constant 2 in [x/2, 2x] has nothing to do with the radix.

3.3 Multiplication
95
3.3 Multiplication
Multiplication of ﬂoating-point numbers is called a short product. This reﬂects
the fact that, in some cases, the low part of the full product of the signiﬁ-
cands has no impact – except perhaps for the rounding – on the ﬁnal result.
Consider the multiplication x × y, where x = ℓβe and y = mβf. Then
◦(xy) = ◦(ℓm)βe+f, and it sufﬁces to consider the case that x = ℓand y = m
are integers, and the product is rounded at some weight βg for g ≥0. Either
the integer product ℓ× m is computed exactly, using one of the algorithms
from Chapter 1, and then rounded; or the upper part is computed directly using
a “short product algorithm”, with correct rounding. The different cases that can
occur are depicted in Figure 3.1.
x
y
@
@
@
@
@
@
@
@
@
@
@
@
@
@
@
x
y
@
@
@
@
@
@
@
@
@
@
@
(a)
(b)
x
y
@
@
@
@
@
@
@
x
y
@
@
@
@
(c)
(d)
Figure 3.1 Different multiplication scenarios, according to the input and output
precisions. The rectangle corresponds to the full product of the inputs x and y
(most signiﬁcant digits bottom left), the triangle to the wanted short product.
Case (a): no rounding is necessary, the product being exact; case (b): the full
product needs to be rounded, but the inputs should not be; case (c): the input x
with the larger precision might be truncated before performing a short product;
case (d): both inputs might be truncated.
An interesting question is: how many consecutive identical bits can occur
after the round bit? Without loss of generality, we can rephrase this question

96
Floating-point arithmetic
as follows. Given two odd integers of at most n bits, what is the longest run
of identical bits in their product? (In the case of an even signiﬁcand, we might
write it m = ℓ2e with ℓodd.) There is no a priori bound except the trivial one
of 2n −2 for the number of zeros, and 2n −1 for the number of ones. For
example, with a precision 5 bits, 27 × 19 = (1 000 000 001)2. More generally,
such a case corresponds to a factorization of 22n−1 + 1 into two integers of n
bits, for example 258 513 × 132 913 = 235 + 1. Having 2n consecutive ones
is not possible since 22n −1 can not factor into two integers of at most n bits.
Therefore, the maximal runs have 2n −1 ones, for example 217 × 151 =
(111 111 111 111 111)2 for n = 8. A larger example is 849 583 × 647 089 =
239 −1.
The exact product of two ﬂoating-point numbers mβe and m′βe′ is
(mm′)βe+e′. Therefore, if no underﬂow or overﬂow occurs, the problem re-
duces to the multiplication of the signiﬁcands m and m′. See Algorithm
FPmultiply.
The product at step 1 of FPmultiply is a short product, i.e. a product whose
most signiﬁcant part only is wanted, as discussed at the start of this section. In
the quadratic range, it can be computed in about half the time of a full product.
In the Karatsuba and Toom–Cook ranges, Mulders’ algorithm can gain 10% to
20%; however, due to carries, implementing this algorithm for ﬂoating-point
computations is tricky. In the FFT range, no better algorithm is known than
computing the full product mm′ and then rounding it.
Algorithm 3.3 FPmultiply
Input: x = m · βe, x′ = m′ · βe′, a precision n, a rounding mode ◦
Output: ◦(xx′) rounded to precision n
1: m′′ ←◦(mm′) rounded to precision n
2: return m′′ · βe+e′.
Hence, our advice is to perform a full product of m and m′, possibly after
truncating them to n + g digits if they have more than n + g digits. Here g (the
number of guard digits) should be positive (see Exercise 3.4).
It seems wasteful to multiply n-bit operands, producing a 2n-bit product,
only to discard the low-order n bits. Algorithm ShortProduct computes an
approximation to the short product without computing the 2n-bit full product.
It uses a threshold n0 ≥1, which should be optimized for the given code base.
Error analysis of the short product. Consider two n-word normalized sig-
niﬁcands A and B that we multiply using a short product algorithm, where the
notation FullProduct(A, B) means the full integer product A · B.

3.3 Multiplication
97
Algorithm 3.4 ShortProduct
Input: integers A, B, and n, with 0 ≤A, B < βn
Output: an approximation to AB div βn
Require: a threshold n0
if n ≤n0 then return FullProduct(A, B) div βn
choose k ≥n/2, ℓ←n −k
C1 ←FullProduct(A div βℓ, B div βℓ) div βk−ℓ
C2 ←ShortProduct(A mod βℓ, B div βk, ℓ)
C3 ←ShortProduct(A div βk, B mod βℓ, ℓ)
return C1 + C2 + C3.
@
@
@
@
@
@
@
A
B
C1
C2
C3
C′
2
C′
3
C4
Figure 3.2 Graphical view of Algorithm ShortProduct:
the computed parts are C1, C2, C3, and the neglected
parts are C′
2, C′
3, C4 (most signiﬁcant part bottom left).
Theorem 3.5 The value C′ returned by Algorithm ShortProduct differs from
the exact short product C = AB div βn by at most 3(n −1)
C′ ≤C ≤C′ + 3(n −1).
Proof. First, since A, B are non-negative, and all roundings are truncations,
the inequality C′ ≤C follows.
Let A = P
i aiβi and B = P
j bjβj, where 0 ≤ai, bj < β. The pos-
sible errors come from: (i) the neglected aibj terms, i.e. parts C′
2, C′
3, C4 of
Figure 3.2; (ii) the truncation while computing C1; (iii) the error in the recur-
sive calls for C2 and C3.
We ﬁrst prove that the algorithm accumulates all products aibj with i + j ≥
n −1. This corresponds to all terms on and below the diagonal in
Figure 3.2. The most signiﬁcant neglected terms are the bottom-left terms from
C′
2 and C′
3, respectively aℓ−1bk−1 and ak−1bℓ−1. Their contribution is at most
2(β −1)2βn−2. The neglected terms from the next diagonal contribute at most

98
Floating-point arithmetic
4(β −1)2βn−3, and so on. The total contribution of neglected terms is thus
bounded by
(β −1)2βn[2β−2 + 4β−3 + 6β−4 + · · · ] < 2βn
(the inequality is strict since the sum is ﬁnite).
The truncation error in C1 is at most βn, thus the maximal difference ε(n)
between C and C′ satisﬁes
ε(n) < 3 + 2ε(⌊n/2⌋),
which gives ε(n) < 3(n −1), since ε(1) = 0.
REMARK: if one of the operands was truncated before applying Algorithm
ShortProduct, simply add one unit to the upper bound (the truncated part is
less than 1, and thus its product by the other operand is bounded by βn).
The complexity S(n) of Algorithm ShortProduct satiﬁes the recurrence
S(n) = M(k)+2S(n−k). The optimal choice of k depends on the underlying
multiplication algorithm. Assuming M(n) ≈nα for α > 1 and k = γn, we
get
S(n) =
γα
1 −2(1 −γ)α M(n),
where the optimal value is γ = 1/2 in the quadratic range, γ ≈0.694 in
the Karatsuba range, and γ ≈0.775 in the Toom–Cook 3-way range, giving
respectively S(n) ∼0.5M(n), S(n) ∼0.808M(n), and S(n) ∼0.888M(n).
The ratio S(n)/M(n) →1 as r →∞for Toom–Cook r-way. In the FFT
range, Algorithm ShortProduct is not any faster than a full product.
3.3.1 Integer multiplication via complex FFT
To multiply n-bit integers, it may be advantageous to use the fast Fourier tran-
form (FFT, see §1.3.4, §2.3). Note that three FFTs give the cyclic convolution
z = x ∗y deﬁned by
zk =
X
0≤j<N
xjyk−j mod N for 0 ≤k < N.
In order to use the FFT for integer multiplication, we have to pad the input
vectors with zeros, thus increasing the length of the transform from N to 2N.
FFT algorithms fall into two classes: those using number theoretical proper-
ties (typically working over a ﬁnite ring, as in §2.3.3), and those based on com-
plex ﬂoating-point computations. The latter, while not having the best asymp-
totic complexity, exhibit good practical behavior, because they take advantage

3.3 Multiplication
99
of the efﬁciency of ﬂoating-point hardware. The drawback of the complex
ﬂoating-point FFT (complex FFT for short) is that, being based on ﬂoating-
point computations, it requires a rigorous error analysis. However, in some
contexts where occasional errors are not disastrous, we may accept a small
probability of error if this speeds up the computation. For example, in the con-
text of integer factorization, a small probability of error is acceptable because
the result (a purported factorization) can easily be checked and discarded if
incorrect.
The following theorem provides a tight error analysis:
Theorem 3.6 The complex FFT allows computation of the cyclic convolution
z = x ∗y of two vectors of length N = 2n of complex values such that
||z′ −z||∞≤||x|| · ||y|| · ((1 + ε)3n(1 + ε
√
5)3n+1(1 + µ)3n −1),
(3.2)
where || · || and || · ||∞denote the Euclidean and inﬁnity norms respectively,
ε is such that |(a ± b)′ −(a ± b)| ≤ε|a ± b|, |(ab)′ −(ab)| ≤ε|ab| for all
machine ﬂoats a, b. Here µ ≥|(wk)′ −(wk)|, 0 ≤k < N, w = e2πi/N, and
(·)′ refers to the computed (stored) value of (·) for each expression.
For the IEEE 754 double-precision format, with rounding to nearest, we have
ε = 2−53, and if the wk are correctly rounded, we can take µ = ε/
√
2. For a
ﬁxed FFT size N = 2n, the inequality (3.2) enables us to compute a bound B
on the components of x and y that guarantees ||z′ −z||∞< 1/2. If we know
that the exact result z ∈ZN, this enables us to uniquely round the components
of z′ to z. Table 3.3 gives b = lg B, the number of bits that can be used
in a 64-bit ﬂoating-point word, if we wish to perform m-bit multiplication
exactly (here m = 2n−1b). It is assumed that the FFT is performed with signed
components in Z ∩[−2b−1, +2b−1), see for example [80, p. 161].
Note that Theorem 3.6 is a worst-case result; with rounding to nearest we
expect the error to be smaller due to cancellation – see Exercise 3.9.
Since 64-bit ﬂoating-point numbers have bounded precision, we can not
compute arbitrarily large convolutions by this method – the limit is about
n = 43. However, this corresponds to vectors of size N = 2n = 243 > 1012,
which is more than enough for practical purposes – see also Exercise 3.11.
3.3.2 The middle product
Given two integers of 2n and n bits respectively, their “middle product” con-
sists of the middle n bits of their 3n-bit product (see Figure 3.3). The middle
product might be computed using two short products, one (low) short product
between x and the high part of y, and one (high) short product between x and

100
Floating-point arithmetic
n
b
m
1
25
25
2
24
48
3
23
92
4
22
176
5
22
352
6
21
672
7
20
1280
8
20
2560
9
19
4864
10
19
9728
n
b
m
11
18
18432
12
17
34816
13
17
69632
14
16
131072
15
16
262144
16
15
491520
17
15
983040
18
14
1835008
19
14
3670016
20
13
6815744
Table 3.3 Maximal number b of bits per IEEE 754
double-precision ﬂoating-point number binary64 (53-bit
signiﬁcand), and maximal m for a plain m × m bit integer
product, for a given FFT size 2n, with signed components.
the low part of y. However there are algorithms to compute a 2n × n middle
product with the same ∼M(n) complexity as an n × n full product (see §3.8).
y
x
@
@
@
@
@
@
@
@
@
@
Figure 3.3 The middle product of x of n bits and y of 2n bits
corresponds to the middle region (most signiﬁcant bits bottom
left).
Several applications beneﬁt from an efﬁcient middle product. One of these
applications is Newton’s method (§4.2). Consider, for example, the reciprocal
iteration (§4.2.2): xj+1 = xj + xj(1 −xjy). If xj has n bits, we have to
consider 2n bits from y in order to get 2n accurate bits in xj+1. The product
xjy has 3n bits, but if xj is accurate to n bits, the n most signiﬁcant bits
of xjy cancel with 1, and the n least signiﬁcant bits can be ignored as they
only contribute noise. Thus, the middle product of xj and y is exactly what is
needed.

3.4 Reciprocal and division
101
Payne and Hanek argument reduction
Another application of the middle product is Payne and Hanek argument re-
duction. Assume x = m · 2e is a ﬂoating-point number with a signiﬁcand
0.5 ≤m < 1 of n bits and a large exponent e (say n = 53 and e = 1024 to ﬁx
the ideas). We want to compute sin x with a precision of n bits. The classical
argument reduction works as follows: ﬁrst compute k = ⌊x/π⌉, then compute
the reduced argument
x′ = x −kπ.
(3.3)
About e bits will be cancelled in the subtraction x −(kπ), and thus we need to
compute kπ with a precision of at least e + n bits to get an accuracy of at least
n bits for x′. Of course, this assumes that x is known exactly – otherwise there
is no point in trying to compute sin x. Assuming 1/π has been precomputed to
precision e, the computation of k costs M(e, n), and the multiplication k × π
costs M(e, e + n); therefore, the total cost is about M(e) when e ≫n.
y
x
1/π
@
@
@
@
@
@
@
@
@
@
@
@
@
¡
@
¡
@
¡
Figure 3.4 A graphical view of Payne and Hanek algorithm.
The key idea of the Payne and Hanek algorithm is to rewrite Eqn. (3.3) as
x′ = π
³x
π −k
´
.
(3.4)
If the signiﬁcand of x has n < e bits, only about 2n bits from the expansion
of 1/π will effectively contribute to the n most signiﬁcant bits of x′, namely
the bits of weight 2−e−n to 2−e+n. Let y be the corresponding 2n-bit part
of 1/π. Payne and Hanek’s algorithm works as follows: ﬁrst multiply the n-
bit signiﬁcand of x by y, keep the n middle bits, and multiply by an n-bit
approximation of π. The total cost is ∼(M(2n, n)+M(n)), or even ∼2M(n)
if the middle product is performed in time M(n), and thus independent of e.
3.4 Reciprocal and division
As for integer operations (§1.4), we should try as far as possible to trade
ﬂoating-point divisions for multiplications, since the cost of a ﬂoating-point

102
Floating-point arithmetic
multiplication is theoretically smaller than the cost of a division by a constant
factor (usually from 2 to 5, depending on the algorithm used). In practice, the
ratio might not even be constant, unless care is taken in implementing division.
Some implementations provide division with cost Θ(M(n) log n) or Θ(n2).
When several divisions have to be performed with the same divisor, a well-
known trick is to ﬁrst compute the reciprocal of the divisor (§3.4.1); then each
division reduces to a multiplication by the reciprocal. A small drawback is that
each division incurs two rounding errors (one for the reciprocal and one for
multiplication by the reciprocal) instead of one, so we can no longer guarantee
a correctly rounded result. For example, in base ten with six digits, 3.0/3.0
might evaluate to 0.999 999 = 3.0 × 0.333 333.
The cases of a single division, or several divisions with a varying divisor,
are considered in §3.4.2.
3.4.1 Reciprocal
Here we describe algorithms that compute an approximate reciprocal of a pos-
itive ﬂoating-point number a, using integer-only operations (see Chapter 1).
The integer operations simulate ﬂoating-point computations, but all roundings
are made explicit. The number a is represented by an integer A of n words in
radix β: a = β−nA, and we assume βn/2 ≤A, thus requiring 1/2 ≤a < 1.
(This does not cover all cases for β ≥3, but if βn−1 ≤A < βn/2, multiplying
A by some appropriate integer k < β will reduce to the case βn/2 ≤A; then
it sufﬁces to multiply the reciprocal of ka by k.)
We ﬁrst perform an error analysis of Newton’s method (§4.2) assuming all
computations are done with inﬁnite precision, and thus neglecting roundoff
errors.
Lemma 3.7 Let 1/2 ≤a < 1, ρ = 1/a, x > 0, and x′ = x+x(1−ax). Then
0 ≤ρ −x′ ≤x2
θ3 (ρ −x)2,
for some θ ∈[min(x, ρ), max(x, ρ)].
Proof. Newton’s iteration is based on approximating the function by its tan-
gent. Let f(t) = a −1/t, with ρ the root of f. The second-order expansion of
f at t = ρ with explicit remainder is
f(ρ) = f(x) + (ρ −x)f ′(x) + (ρ −x)2
2
f ′′(θ),

3.4 Reciprocal and division
103
for some θ ∈[min(x, ρ), max(x, ρ)]. Since f(ρ) = 0, this simpliﬁes to
ρ = x −f(x)
f ′(x) −(ρ −x)2
2
f ′′(θ)
f ′(x) .
(3.5)
Substituting f(t) = a −1/t, f ′(t) = 1/t2 and f ′′(t) = −2/t3, it follows that
ρ = x + x(1 −ax) + x2
θ3 (ρ −x)2,
which proves the claim.
Algorithm ApproximateReciprocal computes an approximate reciprocal.
The input A is assumed to be normalized, i.e. βn/2 ≤A < βn. The output
integer X is an approximation to β2n/A.
Algorithm 3.5 ApproximateReciprocal
Input: A = Pn−1
i=0 aiβi, with 0 ≤ai < β and β/2 ≤an−1
Output: X = βn + Pn−1
i=0 xiβi with 0 ≤xi < β
1: if n ≤2 then return ⌈β2n/A⌉−1
2: ℓ←⌊(n −1)/2⌋, h ←n −ℓ
3: Ah ←Ph−1
i=0 aℓ+iβi
4: Xh ←ApproximateReciprocal(Ah)
5: T ←AXh
6: while T ≥βn+h do
7:
(Xh, T) ←(Xh −1, T −A)
8: T ←βn+h −T
9: Tm ←⌊Tβ−ℓ⌋
10: U ←TmXh
11: return Xhβℓ+ ⌊Uβℓ−2h⌋.
Lemma 3.8 If β is a power of two satisfying β ≥8, and βn/2 ≤A < βn,
then the output X of Algorithm ApproximateReciprocal satisﬁes
AX < β2n < A(X + 2).
Proof. For n ≤2, the algorithm returns X = ⌊β2n/A⌋, unless A = βn/2,
when it returns X = 2βn −1. In both cases, we have AX < β2n ≤A(X +1);
thus, the lemma holds for n ≤2.
Now consider n ≥3. We have ℓ= ⌊(n−1)/2⌋and h = n−ℓ, and therefore
n = h + ℓand h > ℓ. The algorithm ﬁrst computes an approximate reciprocal
of the upper h words of A, and then updates it to n words using Newton’s
iteration.

104
Floating-point arithmetic
After the recursive call at line 4, we have by induction
AhXh < β2h < Ah(Xh + 2).
(3.6)
After the product T ←AXh and the while-loop at steps 6–7, we still have
T = AXh, where T and Xh may have new values, and in addition T < βn+h.
We also have βn+h < T + 2A; we prove this by distinguishing two cases.
Either we entered the while-loop, then since the value of T decreased by A at
each loop, the previous value T + A was necessarily ≥βn+h. If we did not
enter the while-loop, the value of T is still AXh. Multiplying Eqn. (3.6) by βℓ
gives: βn+h < Ahβℓ(Xh + 2) ≤A(Xh + 2) = T + 2A. Thus, we have
T < βn+h < T + 2A.
It follows that T > βn+h −2A > βn+h −2βn. As a consequence, the value of
βn+h−T computed at step 8 can not exceed 2βn−1. The last lines compute the
product TmXh, where Tm is the upper part of T, and put its ℓmost signiﬁcant
words in the low part Xℓof the result X.
Now let us perform the error analysis. Compared to Lemma 3.7, x stands
for Xhβ−h, a stands for Aβ−n, and x′ stands for Xβ−n. The while-loop en-
sures that we start from an approximation x < 1/a, i.e. AXh < βn+h. Then
Lemma 3.7 guarantees that x ≤x′ ≤1/a if x′ is computed with inﬁnite preci-
sion. Here we have x ≤x′, since X = Xhβh + Xℓ, where Xℓ≥0. The only
differences compared to inﬁnite precision are:
• the low ℓwords from 1 −ax (here T at line 8) are neglected, and only its
upper part (1 −ax)h (here Tm) is considered;
• the low 2h −ℓwords from x(1 −ax)h are neglected.
Those two approximations make the computed value of x′ ≤the value which
would be computed with inﬁnite precision. Thus, for the computed value x′,
we have
x ≤x′ ≤1/a.
From Lemma 3.7, the mathematical error is bounded by x2θ−3(ρ −x)2 <
4β−2h, since x2 ≤θ3 and |ρ−x| < 2β−h. The truncation from 1−ax, which
is multiplied by x < 2, produces an error < 2β−2h. Finally, the truncation of
x(1 −ax)h produces an error < β−n. The ﬁnal result is thus
x′ ≤ρ < x′ + 6β−2h + β−n.
Assuming 6β−2h ≤β−n, which holds as soon as β ≥6 since 2h > n, this
simpliﬁes to
x′ ≤ρ < x′ + 2β−n,

3.4 Reciprocal and division
105
which gives with x′ = Xβ−n and ρ = βn/A
X ≤β2n
A
< X + 2.
Since β is assumed to be a power of two, equality can hold only when A is
itself a power of two, i.e. A = βn/2. In this case, there is only one value
of Xh that is possible for the recursive call, namely Xh = 2βh −1. In this
case, T = βn+h −βn/2 before the while-loop, which is not entered. Then
βn+h−T = βn/2, which multiplied by Xh gives (again) βn+h−βn/2, whose
h most signiﬁcant words are β −1. Thus, Xℓ= βℓ−1, and X = 2βn −1.
REMARK. Lemma 3.8 might be extended to the case βn−1 ≤A < βn, or to
a radix β which is not a power of two. However, we prefer to state a restricted
result with simple bounds.
COMPLEXITY ANALYSIS. Let I(n) be the cost to invert an n-word num-
ber using Algorithm ApproximateReciprocal. If we neglect the linear costs,
we have I(n) ≈I(n/2) + M(n, n/2) + M(n/2), where M(n, n/2) is the
cost of an n × (n/2) product – the product AXh at step 5 – and M(n/2)
the cost of an (n/2) × (n/2) product – the product TmXh at step 10. If the
n × (n/2) product is performed via two (n/2) × (n/2) products, we have
I(n) ≈I(n/2)+3M(n/2), which yields I(n) ∼M(n) in the quadratic range,
∼1.5M(n) in the Karatsuba range, ∼1.704M(n) in the Toom–Cook 3-way
range, and ∼3M(n) in the FFT range. In the FFT range, an n×(n/2) product
might be directly computed by three FFTs of length 3n/2 words, amounting
to ∼M(3n/4); in this case, the complexity decreases to ∼2.5M(n) (see the
comments at the end of §2.3.3, page 58).
THE WRAP-AROUND TRICK. We now describe a slight modiﬁcation of
Algorithm ApproximateReciprocal, which yields a complexity 2M(n). In
the product AXh at step 5, Eqn. (3.6) tells us that the result approaches βn+h,
or more precisely
βn+h −2βn < AXh < βn+h + 2βn.
(3.7)
Assume we use an FFT-based algorithm such as the Sch¨onhage–Strassen
algorithm that computes products modulo βm + 1, for some integer m ∈
(n, n+h). Let AXh = Uβm+V with 0 ≤V < βm. It follows from Eqn. (3.7)
that U = βn+h−m or U = βn+h−m −1. Let T = AXh mod (βm + 1) be the
value computed by the algorithm. Now T = V −U or T = V −U +(βm +1).
It follows that AXh = T + U(βm + 1) or AXh = T + (U −1)(βm + 1).

106
Floating-point arithmetic
Taking into account the two possible values of U, we have
AXh = T + (βn+h−m −ε)(βm + 1),
where ε ∈{0, 1, 2}. Since β ≥6, βm > 4βn, thus only one value of ε yields
a value of AXh in the interval (βn+h −2βn, βn+h + 2βn).
Thus, we can replace step 5 in Algorithm ApproximateReciprocal by the
following code:
Compute T = AXh mod (βm + 1) using FFTs with length m > n
T ←T + βn+h + βn+h−m
⊲the case ε = 0
while T ≥βn+h + 2βn do
T ←T −(βm + 1)
Assuming that we can take m close to n, the cost of the product AXh is
only about that of three FFTs of length n, i.e. ∼M(n/2).
3.4.2 Division
In this section, we consider the case where the divisor changes between succes-
sive operations, so no precomputation involving the divisor can be performed.
We ﬁrst show that the number of consecutive zeros in the result is bounded by
the divisor length, then we consider the division algorithm and its complexity.
Lemma 3.10 analyses the case where the division operands are truncated, be-
cause they have a larger precision than desired in the result. Finally, we discuss
“short division” and the error analysis of Barrett’s algorithm.
A ﬂoating-point division reduces to an integer division as follows. Assume
dividend a = ℓ·βe and divisor d = m·βf, where ℓ, m are integers. Then a/d =
(ℓ/m)βe−f. If k bits of the quotient are needed, we ﬁrst determine a scaling
factor g such that βk−1 ≤|ℓβg/m| < βk, and we divide ℓβg – truncated
if needed – by m. The following theorem gives a bound on the number of
consecutive zeros after the integer part of the quotient of ⌊ℓβg⌋by m.
Theorem 3.9 Assume we divide an m-digit positive integer by an n-digit pos-
itive integer in radix β, with m ≥n. Then the quotient is either exact, or its
radix β expansion admits at most n −1 consecutive zeros or ones after the
digit of weight β0.
Proof. We ﬁrst consider consecutive zeros. If the expansion of the quotient q
admits n or more consecutive zeros after the binary point, we can write q =
q1+β−nq0, where q1 is an integer and 0 ≤q0 < 1. If q0 = 0, then the quotient
is exact. Otherwise, if a is the dividend and d is the divisor, we should have
a = q1d + β−nq0d. However, a and q1d are integers, and 0 < β−nq0d < 1, so
β−nq0d can not be an integer, and we have a contradiction.

3.4 Reciprocal and division
107
For consecutive ones, the proof is similar: write q = q1 −β−nq0, with
0 ≤q0 ≤1. Since d < βn, we still have 0 ≤β−nq0d < 1.
Algorithm DivideNewton performs the division of two n-digit ﬂoating-
point numbers. The key idea is to approximate the inverse of the divisor to half
precision only, at the expense of additional steps. At step 4, MiddleProduct
(q0, d) denotes the middle product of q0 and d, i.e. the n/2 middle digits of
that product. At step 2, r is an approximation to 1/d1, and thus to 1/d, with
precision n/2 digits. Therefore, at step 3, q0 approximates c/d to about n/2
digits, and the upper n/2 digits of q0d at step 4 agree with those of c. The
value e computed at step 4 thus equals q0d −c to precision n/2. It follows that
re ≈e/d agrees with q0 −c/d to precision n/2; hence, the correction term
(which is really a Newton correction) added in the last step.
Algorithm 3.6 DivideNewton
Input: n-digit ﬂoating-point numbers c and d, with n even, d normalized
Output: an approximation of c/d
1: write d = d1βn/2 + d0 with 0 ≤d1, d0 < βn/2
2: r ←ApproximateReciprocal(d1, n/2)
3: q0 ←cr truncated to n/2 digits
4: e ←MiddleProduct(q0, d)
5: q ←q0 −re.
In the FFT range, the cost of Algorithm DivideNewton is ∼2.5M(n): step 2
costs ∼2M(n/2) ∼M(n) with the wrap-around trick, and steps 3–5 each
cost ∼M(n/2), using a fast middle product algorithm for step 4. By way of
comparison, if we computed a full precision inverse as in Barrett’s algorithm
(see below), the cost would be ∼3.5M(n). (See §3.8 for improved asymptotic
bounds on division.)
In the Karatsuba range, Algorithm DivideNewton costs ∼1.5M(n), and is
useful provided the middle product of step 4 is performed with cost ∼M(n/2).
In the quadratic range, Algorithm DivideNewton costs ∼2M(n), and a clas-
sical division should be preferred.
When the requested precision for the output is smaller than that of the inputs
of a division, we have to truncate the inputs in order to avoid an unnecessarily
expensive computation. Assume for example that we want to divide two num-
bers of 10, 000 bits, with a 10-bit quotient. To apply the following lemma, just
replace µ by an appropriate value such that A1 and B1 have about 2n and n
digits respectively, where n is the desired number of digits in the quotient; for
example, we might choose µ = βk to truncate to k words.

108
Floating-point arithmetic
Lemma 3.10 Let A, B, µ ∈N∗, 2 ≤µ ≤B. Let Q = ⌊A/B⌋, A1 = ⌊A/µ⌋,
B1 = ⌊B/µ⌋, Q1 = ⌊A1/B1⌋. If A/B ≤2B1, then
Q ≤Q1 ≤Q + 2.
The condition A/B ≤2B1 is quite natural: it says that the truncated divisor
B1 should have essentially at least as many digits as the desired quotient.
Proof. Let A1 = Q1B1 + R1. We have A = A1µ + A0, B = B1µ + B0,
therefore
A
B = A1µ + A0
B1µ + B0
≤A1µ + A0
B1µ
= Q1 + R1µ + A0
B1µ
.
Since R1 < B1 and A0 < µ, R1µ + A0 < B1µ, thus A/B < Q1 + 1. Taking
the ﬂoor of each side proves, since Q1 is an integer, that Q ≤Q1.
Now consider the second inequality. For given truncated parts A1 and B1,
and thus given Q1, the worst case is when A is minimal, say A = A1µ, and B
is maximal, say B = B1µ + (µ −1). In this case, we have
¯¯¯¯
A1
B1
−A
B
¯¯¯¯ =
¯¯¯¯
A1
B1
−
A1µ
B1µ + (µ −1)
¯¯¯¯ =
¯¯¯¯
A1(µ −1)
B1(B1µ + µ −1)
¯¯¯¯ .
The numerator equals A −A1 ≤A, and the denominator equals B1B; there-
fore, the difference A1/B1 −A/B is bounded by A/(B1B) ≤2, and so is the
difference between Q and Q1.
Algorithm ShortDivision is useful in the Karatsuba and Toom–Cook ranges.
The key idea is that, when dividing a 2n-digit number by an n-digit number,
some work that is necessary for a full 2n-digit division can be avoided (see
Figure 3.5).
Algorithm 3.7 ShortDivision
Input: 0 ≤A < β2n, βn/2 ≤B < βn
Output: an approximation of A/B
Require: a threshold n0
1: if n ≤n0 then return ⌊A/B⌋
2: choose k ≥n/2, ℓ←n −k
3: (A1, A0) ←(A div β2ℓ, A mod β2ℓ)
4: (B1, B0) ←(B div βℓ, B mod βℓ)
5: (Q1, R1) ←DivRem(A1, B1)
6: A′ ←R1β2ℓ+ A0 −Q1B0βℓ
7: Q0 ←ShortDivision(A′ div βk, B div βk)
8: return Q1βℓ+ Q0.

3.4 Reciprocal and division
109
Theorem 3.11 The approximate quotient Q′ returned by ShortDivision
differs at most by 2 lg n from the exact quotient Q = ⌊A/B⌋, more precisely
Q ≤Q′ ≤Q + 2 lg n.
Proof. If n ≤n0, Q = Q′ so the statement holds. Assume n > n0. We
have A = A1β2ℓ+ A0 and B = B1βℓ+ B0; thus, since A1 = Q1B1 + R1,
A = (Q1B1 + R1)β2ℓ+ A0 = Q1Bβℓ+ A′, with A′ < βn+ℓ. Let A′ =
A′
1βk+A′
0, and B = B′
1βk+B′
0, with 0 ≤A′
0, B′
0 < βk, and A′
1 < β2ℓ. From
Lemma 3.10, the exact quotient of A′ div βk by B div βk is greater or equal to
that of A′ by B; thus, by induction Q0 ≥A′/B. Since A/B = Q1βℓ+ A′/B,
this proves that Q′ ≥Q.
Now by induction, Q0 ≤A′
1/B′
1 + 2 lg ℓ, and A′
1/B′
1 ≤A′/B + 2 (from
Lemma 3.10 again, whose hypothesis A′/B ≤2B′
1 is satisﬁed, since A′ <
B1β2ℓ, thus A′/B ≤βℓ≤2B′
1), so Q0 ≤A′/B + 2 lg n, and Q′ ≤A/B +
2 lg n.
As shown at the lower half of Figure 3.5, we can use a short product to compute
Q1B0 at step 6. Indeed, we need only the upper ℓwords of A′, and thus only the
upper ℓwords of Q1B0. The complexity of Algorithm ShortDivision satisﬁes
D∗(n) = D(k)+M ∗(n−k)+D∗(n−k) with k ≥n/2, where D(n) denotes
the cost of a division with remainder, and M ∗(n) the cost of a short product.
In the Karatsuba range, we have D(n) ∼2M(n), M ∗(n) ∼0.808M(n),
and the best possible value of k is k ≈0.542n, with corresponding cost
D∗(n) ∼1.397M(n). In the Toom–Cook 3-way range, k ≈0.548n is op-
timal, and gives D∗(n) ∼1.988M(n).
Barrett’s ﬂoating-point division algorithm
Here we consider ﬂoating-point division using Barrett’s algorithm and provide
a rigorous error bound (see §2.4.1 for an exact integer version). The algorithm
is useful when the same divisor is used several times; otherwise Algorithm
DivideNewton is faster (see Exercise 3.13). Assume we want to divide a by b
of n bits, each with a quotient of n bits. Barrett’s algorithm is as follows:
1. Compute the reciprocal r of b to n bits [rounding to nearest]
2. q ←◦n(a × r) [rounding to nearest]
The cost of the algorithm in the FFT range is ∼3M(n): ∼2M(n) to compute
the reciprocal with the wrap-around trick, and M(n) for the product a × r.
Lemma 3.12 At step 2 of Barrett’s algorithm, we have |a −bq| ≤3|b|/2.

110
Floating-point arithmetic
M(n/2)
M(n/4)
M(n/4)
M(n/4)
M( n
8 )
M( n
8 )
M( n
8 )
M( n
8 )
M( n
8 )
M( n
8 )
M( n
8 )
@
@
@
@
@
@
@
@
@
@
@
@
@
@
@
@
@
@
@
@
M ∗(n/2)
M( n
4 )
M( n
4 )
M ∗( n
4 )
M( n
8 )
M( n
8 )
M( n
8 )
M( n
8 )
M( n
8 )
M( n
8 )
M ∗( n
8 )
Figure 3.5 Divide and conquer short division: a graphical view. Upper: with
plain multiplication; lower: with short multiplication. See also Figure 1.3.
Proof. By scaling a and b, we can assume that b and q are integers, that
2n−1
≤
b, q
<
2n; thus, a
<
22n. We have r
=
1/b + ε with
|ε| ≤ulp(2−n/2) = 2−2n. Also q = ar + ε′ with |ε′| ≤ulp(q)/2 = 1/2

3.5 Square root
111
since q has n bits. Therefore, q = a(1/b + ε) + ε′ = a/b + aε + ε′, and
|bq −a| = |b||aε + ε′| ≤3|b|/2.
As a consequence of Lemma 3.12, q differs by at most one unit in last place
from the n-bit quotient of a and b, rounded to nearest.
Lemma 3.12 can be applied as follows: to perform several divisions with a
precision of n bits with the same divisor, precompute a reciprocal with n + g
bits, and use the above algorithm with a working precision of n + g bits. If the
last g bits of q are neither 000 . . . 00x nor 111 . . . 11x (where x stands for 0
or 1), then rounding q down to n bits will yield ◦n(a/b) for a directed rounding
mode.
Which algorithm to use?
In this section, we described three algorithms to compute x/y: Divide-Newton
uses Newton’s method for 1/y and incorporates the dividend x at the last
iteration, ShortDivision is a recursive algorithm using division with remainder
and short products, and Barrett’s algorithm assumes we have precomputed an
approximation to 1/y. When the same divisor y is used several times, Barrett’s
algorithm is better, since each division costs only a short product. Otherwise
ShortDivision is theoretically faster than DivideNewton in the schoolbook
and Karatsuba ranges, and taking k = n/2 as parameter in ShortDivision is
close to optimal. In the FFT range, DivideNewton should be preferred.
3.5 Square root
Algorithm FPSqrt computes a ﬂoating-point square root, using as subroutine
Algorithm SqrtRem (§1.5.1 to determine an integer square root (with remain-
der). It assumes an integer signiﬁcand m, and a directed rounding mode (see
Exercise 3.14 for rounding to nearest).
Algorithm 3.8 FPSqrt
Input: x = m · 2e, a target precision n, a directed rounding mode ◦
Output: y = ◦n(√x)
if e is odd then (m′, f) ←(2m, e −1) else (m′, f) ←(m, e)
deﬁne m′ := m122k + m0, m1 integer of 2n or 2n −1 bits, 0 ≤m0 < 22k
(s, r) ←SqrtRem(m1)
if (◦is round towards zero or down) or (r = m0 = 0)
then return s · 2k+f/2 else return (s + 1) · 2k+f/2.

112
Floating-point arithmetic
Theorem 3.13 Algorithm FPSqrt returns the correctly rounded square root
of x.
Proof. Since m1 has 2n or 2n −1 bits, s has exactly n bits, and we have
x ≥s222k+f; thus, √x ≥s2k+f/2. On the other hand, SqrtRem ensures that
r ≤2s, and x2−f = (s2 + r)22k + m0 < (s2 + r + 1)22k ≤(s + 1)222k.
Since y := s · 2k+f/2 and y+ = (s + 1) · 2k+f/2 are two consecutive n-bit
ﬂoating-point numbers, this concludes the proof.
NOTE: in the case s = 2n −1, s + 1 = 2n is still representable in n bits.
A different method is to use an initial approximation to the reciprocal square
root x−1/2 (§3.5.1), see Exercise 3.15. Faster algorithms are mentioned in §3.8.
3.5.1 Reciprocal square root
In this section, we describe an algorithm to compute the reciprocal square root
a−1/2 of a ﬂoating-point number a, with a rigorous error bound.
Lemma 3.14 Let a, x > 0, ρ = a−1/2, and x′ = x + (x/2)(1 −ax2). Then
0 ≤ρ −x′ ≤3x3
2θ4 (ρ −x)2,
for some θ ∈[min(x, ρ), max(x, ρ)].
Proof. The proof is very similar to that of Lemma 3.7. Here we use f(t) =
a −1/t2, with ρ the root of f. Eqn. (3.5) translates to
ρ = x + x
2 (1 −ax2) + 3x3
2θ4 (ρ −x)2,
which proves the Lemma.
Lemma 3.15 Provided that β ≥38, if X is the value returned by Algorithm
ApproximateRecSquareRoot, a = Aβ−n, x = Xβ−n, then 1/2 ≤x < 1
and
|x −a−1/2| ≤2β−n.
Proof. We have 1 ≤a < 4. Since X is bounded by βn −1 at lines 1 and 9,
we have x, xh < 1, with xh = Xhβ−h. We prove the statement by induction
on n. It is true for n ≤2. Now assume the value Xh at step 4 satisﬁes
|xh −a−1/2
h
| ≤β−h,
where ah = Ahβ−h. We have three sources of error, that we will bound sepa-
rately:

3.5 Square root
113
Algorithm 3.9 ApproximateRecSquareRoot
Input: integer A with βn ≤A < 4βn, β ≥38
Output: integer X, βn/2 ≤X < βn satisfying Lemma 3.15
1: if n ≤2 then return min(βn −1, ⌊βn/
p
Aβ−n⌋)
2: ℓ←⌊(n −1)/2⌋, h ←n −ℓ
3: Ah ←⌊Aβ−ℓ⌋
4: Xh ←ApproximateRecSquareRoot(Ah)
5: T ←AX2
h
6: Th ←⌊Tβ−n⌋
7: Tℓ←β2h −Th
8: U ←TℓXh
9: return min(βn −1, Xhβℓ+ ⌊Uβℓ−2h/2⌉).
1. the rounding errors in steps 6 and 9;
2. the mathematical error given by Lemma 3.14, which would occur even if
all computations were exact;
3. the error coming from the fact we use Ah instead of A in the recursive call
at step 4.
At step 5 we have exactly
t := Tβ−n−2h = ax2
h,
which gives |th −ax2
h|
<
β−2h with th
:=
Thβ−2h, and in turn
|tℓ−(1 −ax2
h)| < β−2h with tℓ:= Tℓβ−2h. At step 8, it follows that
|u −xh(1 −ax2
h)| < β−2h, where u = Uβ−3h. Thus, after taking into
account the rounding error in the last step, |x −[xh + xh(1 −ax2
h)/2]| <
(β−2h + β−n)/2.
Now we apply Lemma 3.14 to x →xh, x′ →x, to bound the mathematical
error, assuming no rounding error occurs
0 ≤a−1/2 −x ≤3x3
h
2θ4 (a−1/2 −xh)2,
which gives1 |a−1/2 −x| ≤3.04(a−1/2 −xh)2. Now |a−1/2 −a−1/2
h
| ≤
|a −ah|ν−3/2/2 for ν ∈[min(ah, a), max(ah, a)]; thus, |a−1/2 −a−1/2
h
| ≤
β−h/2. Together with the induction hypothesis |xh −a−1/2
h
| ≤2β−h, it
follows that |a−1/2 −xh| ≤2.5β−h. Thus, |a−1/2 −x| ≤19β−2h.
1
Since θ ∈[xh, a−1/2] and |xh −a−1/2| ≤2.5β−h, we have θ ≥xh −2.5β−h, and
xh/θ ≤1 + 2.5β−h/θ ≤1 + 5β−h (remember θ ∈[xh, a−1/2]), and it follows that
θ ≥1/2. For β ≥38, since h ≥2, we have 1 + 5β−h ≤1.0035; thus,
1.5x3
h/θ4 ≤(1.5/θ)(1.0035)3 ≤3.04.

114
Floating-point arithmetic
The total error is thus bounded by
|a−1/2 −x| ≤3
2β−n + 19β−2h.
Since 2h ≥n + 1, we see that 19β−2h ≤β−n/2 for β ≥38, and the lemma
follows.
NOTE: If AhX2
h ≤β3h at step 4 of Algorithm ApproximateRecSquareRoot,
we could have AX2
h > βn+2h at step 5, which might cause Tℓto be negative.
Let R(n) be the cost of ApproximateRecSquareRoot for an n-digit in-
put. We have h, ℓ≈n/2; thus, the recursive call costs R(n/2), step 5 costs
M(n/2) to compute X2
h, and M(n) for the product AX2
h (or M(3n/4) in the
FFT range using the wrap-around trick described in §3.4.1, since we know the
upper n/2 digits of the product give 1), and again M(n/2) for step 8. We get
R(n) = R(n/2) + 2M(n) (or R(n/2) + 7M(n)/4 in the FFT range), which
yields R(n) ∼4M(n) (or R(n) ∼3.5M(n) in the FFT range).
This algorithm is not optimal in the FFT range, especially when using an
FFT algorithm with cheap point-wise products (such as the complex FFT, see
§3.3.1). Indeed, Algorithm ApproximateRecSquareRoot uses the following
form of Newton’s iteration
x′ = x + x
2 (1 −ax2).
It might be better to write
x′ = x + 1
2(x −ax3).
Here, the product x3 might be computed with a single FFT transform of length
3n/2, replacing the point-wise products bx2
i by bx3
i , with a total cost ∼0.75M(n).
Moreover, the same idea can be used for the full product ax3 of 5n/2 bits,
where the upper n/2 bits match those of x. Thus, using the wrap-around trick,
a transform of length 2n is enough, with a cost of ∼M(n) for the last iter-
ation, and a total cost of ∼2M(n) for the reciprocal square root. With this
improvement, the algorithm of Exercise 3.15 costs only ∼2.25M(n).
3.6 Conversion
Since most software tools work in radix 2 or 2k, and humans usually enter or
read ﬂoating-point numbers in radix 10 or 10k, conversions are needed from
one radix to the other one. Most applications perform very few conversions,

3.6 Conversion
115
in comparison to other arithmetic operations, thus the efﬁciency of the conver-
sions is rarely critical.2 The main issue here is therefore more correctness than
efﬁciency. Correctness of ﬂoating-point conversions is not an easy task, as can
be seen from the history of bugs in Microsoft Excel.3
The algorithms described in this section use as subroutines the integer-
conversion algorithms from Chapter 1. As a consequence, their efﬁciency
depends on the efﬁciency of the integer-conversion algorithms.
3.6.1 Floating-point output
In this section, we follow the convention of using lower-case letters for param-
eters related to the internal radix b, and upper-case for parameters related to
the external radix B. Consider the problem of printing a ﬂoating-point num-
ber, represented internally in radix b (say b = 2) in an external radix B (say
B = 10). We distinguish here two kinds of ﬂoating-point output:
• Fixed-format output, where the output precision is given by the user, and
we want the output value to be correctly rounded according to the given
rounding mode. This is the usual method when values are to be used by
humans, for example to ﬁll a table of results. The input and output precisions
may be very different, for example we may want to print 1000 digits of 2/3,
which uses only one digit internally in radix 3. Conversely, we may want to
print only a few digits of a number accurate to 1000 bits.
• Free-format output, where we want the output value, when read with correct
rounding (usually to nearest), to give exactly the initial number. Here the
minimal number of printed digits may depend on the input number. This
kind of output is useful when storing data in a ﬁle, while guaranteeing that
reading the data back will produce exactly the same internal numbers, or for
exchanging data between different programs.
In other words, if x is the number that we want to print, and X is the printed
value, the ﬁxed-format output requires |x−X| < ulp(X), and the free-format
output requires |x −X| < ulp(x) for directed rounding. Replace < ulp(·) by
≤ulp(·)/2 for rounding to nearest.
Some comments on Algorithm PrintFixed:
• It assumes that we have precomputed values of λB = ◦(log b/ log B) for
2 An important exception is the computation of billions of digits of constants like π, log 2,
where a quadratic conversion routine would be far too slow.
3 In Excel 2007, the product 850 × 77.1 prints as 100, 000 instead of 65, 535; this is really an
output bug, since if we multiply “100, 000” by 2, we get 131, 070. An input bug occurred in
Excel 3.0 to 7.0, where the input 1.40737488355328 gave 0.64.

116
Floating-point arithmetic
Algorithm 3.10 PrintFixed
Input: x = f · be−p with f, e, p integers, bp−1 ≤|f| < bp, external radix B
and precision P, rounding mode ◦
Output: X = F · BE−P with F, E integers, BP −1 ≤|F| < BP , such that
X = ◦(x) in radix B and precision P
1: λ ←◦(log b/log B)
2: E ←1 + ⌊(e −1)λ⌋
3: q ←⌈P/λ⌉
4: y ←◦(xBP −E) with precision q
5: if we can not round y to an integer then increase q and go to step 4
6: F ←Integer(y, ◦).
⊲see §1.7
7: if |F| ≥BP then E ←E + 1 and go to step 4.
8: return F, E.
any possible external radix B (the internal radix b is assumed to be ﬁxed for
a given implementation). Assuming the input exponent e is bounded, it is
possible – see Exercise 3.17 – to choose these values precisely enough that
E = 1 +
¹
(e −1) log b
log B
º
.
(3.8)
Thus, the value of λ at step 1 is simply read from a table.
• The difﬁcult part is step 4, where we have to perform the exponentiation
BP −E – remember all computations are done in the internal radix b – and
multiply the result by x. Since we expect an integer of q digits in step 6, there
is no need to use a precision of more than q digits in these computations,
but a rigorous bound on the rounding errors is required, so as to be able to
correctly round y.
• In step 5, we can round y to an integer if the interval containing all pos-
sible values of xBP −E – including the rounding errors while approaching
xBP −E, and the error while rounding to precision q – contains no rounding
boundary (if ◦is a directed rounding, it should contain no integer; if ◦is
rounding to nearest, it should contain no half-integer).
Theorem 3.16 Algorithm PrintFixed is correct.
Proof. First assume that the algorithm ﬁnishes. Eqn. (3.8) implies BE−1 ≤
be−1; thus |x|BP −E ≥BP −1, which implies that |F| ≥BP −1 at step 6.
Therefore BP −1 ≤|F| < BP at the end of the algorithm. Now, printing x
gives F ·Ba iff printing xBk gives F ·Ba+k for any integer k. Thus, it sufﬁces
to check that printing xBP −E gives F, which is clear by construction.

3.6 Conversion
117
The algorithm terminates because at step 4, xBP −E, if not an integer, can not
be arbitrarily close to an integer. If P −E ≥0, let k be the number of digits of
BP −E in radix b, then xBP −E can be represented exactly with p + k digits.
If P −E < 0, let g = BE−P , of k digits in radix b. Assume f/g = n + ε
with n integer; then f −gn = gε. If ε is not zero, gε is a non-zero integer, and
|ε| ≥1/g ≥2−k.
The case |F| ≥BP at step 7 can occur for two reasons: either |x|BP −E ≥
BP , and its rounding also satisﬁes this inequality; or |x|BP −E < BP , but
its rounding equals BP (this can only occur for rounding away from zero or
to nearest). In the former case, we have |x|BP −E ≥BP −1 at the next pass
in step 4, while in the latter case the rounded value F equals BP −1 and the
algorithm terminates.
Now consider free-format output. For a directed rounding mode, we want
|x −X| < ulp(x) knowing |x −X| < ulp(X). Similarly, for rounding to
nearest, if we replace ulp by ulp /2.
It is easy to see that a sufﬁcient condition is that ulp(X) ≤ulp(x), or
equivalently BE−P ≤be−p in Algorithm PrintFixed (with P not ﬁxed at
input, which explain the “free-format” name). To summarize, we have
be−1 ≤|x| < be,
BE−1 ≤|X| < BE.
Since |x| < be, and X is the rounding of x, it sufﬁces to have BE−1 ≤be. It
follows that BE−P ≤beB1−P , and the above sufﬁcient condition becomes
P ≥1 + p log b
log B .
For example, with b = 2 and B = 10, p = 53 gives P ≥17, and p = 24 gives
P ≥9. As a consequence, if a double-precision IEEE 754 binary ﬂoating-
point number is printed with at least 17 signiﬁcant decimal digits, it can be read
back without any discrepancy, assuming input and output are performed with
correct rounding to nearest (or directed rounding, with appropriately chosen
directions).
3.6.2 Floating-point input
The problem of ﬂoating-point input is the following. Given a ﬂoating-point
number X with a signiﬁcand of P digits in some radix B (say B = 10), a
precision p and a given rounding mode, we want to correctly round X to a
ﬂoating-point number x with p digits in the internal radix b (say b = 2).

118
Floating-point arithmetic
At ﬁrst glance, this problem looks very similar to the ﬂoating-point output
problem, and we might think it sufﬁces to apply Algorithm PrintFixed, simply
exchanging (b, p, e, f) and (B, P, E, F). Unfortunately, this is not the case.
The difﬁculty is that, in Algorithm PrintFixed, all arithmetic operations are
performed in the internal radix b, and we do not have such operations in radix
B (see however Exercise 1.37).
3.7 Exercises
Exercise 3.1 In §3.1.5, we described a trick to get the next ﬂoating-point num-
ber in the direction away from zero. Determine for which IEEE 754 double-
precision numbers the trick works.
Exercise 3.2 (Kidder, Boldo) Assume a binary representation. The “rounding
to odd” mode [42, 148, 220] is deﬁned as follows: in case the exact value is not
representable, it rounds to the unique adjacent number with an odd signiﬁcand.
(“Von Neumann rounding” [42] omits the test for the exact value being repre-
sentable or not, and rounds to odd in all non-zero cases.) Note that overﬂow
never occurs during rounding to odd. Prove that if y = round(x, p + k, odd)
and z = round(y, p, nearest even), and k > 1, then
z = round(x, p, nearest even),
i.e. the double-rounding problem does not occur.
Exercise 3.3 Show that, if √a is computed using Newton’s iteration for a−1/2
x′ = x + 3
2(1 −ax2)
(see §3.5.1), and the identity √a = a × a−1/2, with rounding mode “round to-
wards zero”, then it might never be possible to determine the correctly rounded
value of √a, regardless of the number of additional guard digits used in the
computation.
Exercise 3.4 How does truncating the operands of a multiplication to n + g
digits (as suggested in §3.3) affect the accuracy of the result? Considering the
cases g = 1 and g > 1 separately, what could happen if the same strategy were
used for subtraction?
Exercise 3.5 Is the bound of Theorem 3.5 optimal?

3.7 Exercises
119
Exercise 3.6 Adapt Mulders’ short product algorithm [173] to ﬂoating-point
numbers. In case the ﬁrst rounding fails, can you compute additional digits
without starting again from scratch?
Exercise 3.7 Show that, if a balanced ternary system is used (radix 3 with
digits {0, ±1}), then “round to nearest” is equivalent to truncation.
Exercise 3.8 (Percival) Suppose we compute the product of two complex
ﬂoating-point numbers z0 = a0 + ib0 and z1 = a1 + ib1 in the follow-
ing way: xa = ◦(a0a1), xb = ◦(b0b1), ya = ◦(a0b1), yb = ◦(a1b0), z =
◦(xa−xb)+i◦(ya+yb). All computations are done in precision n, with round-
ing to nearest. Compute an error bound of the form |z −z0z1| ≤c2−n|z0z1|.
What is the best possible constant c?
Exercise 3.9 Show that, if µ = O(ε) and nε < 1, the bound in Theorem 3.6
simpliﬁes to
||z′ −z||∞= O(|x| · |y| · nε).
If the rounding errors cancel, we expect the error in each component of z′ to be
O(|x| · |y| · n1/2ε). The error ||z′ −z||∞could be larger since it is a maximum
of N = 2n component errors. Using your favourite implementation of the
FFT, compare the worst-case error bound given by Theorem 3.6 with the error
||z′ −z||∞that occurs in practice.
Exercise 3.10 (Enge) Design an algorithm that correctly rounds the product
of two complex ﬂoating-point numbers with 3 multiplications only. [Hint: as-
sume all operands and the result have n-bit signiﬁcand.]
Exercise 3.11 Write a computer program to check the entries of Table 3.3 are
correct and optimal, given Theorem 3.6.
Exercise 3.12 (Bodrato) Assuming we use an FFT modulo βm −1 in the
wrap-around trick, how should we modify step 5 of ApproximateReciprocal?
Exercise 3.13 To perform k divisions with the same divisor, which of Algo-
rithm DivideNewton and Barrett’s algorithm is faster?
Exercise 3.14 Adapt Algorithm FPSqrt to the rounding to nearest mode.
Exercise 3.15 Devise an algorithm similar to Algorithm FPSqrt but using Al-
gorithm ApproximateRecSquareRoot to compute an n/2-bit approximation
to x−1/2, and doing one Newton-like correction to return an n-bit approxima-
tion to x1/2. In the FFT range, your algorithm should take time ∼3M(n) (or
better).

120
Floating-point arithmetic
Exercise 3.16 Prove that for any n-bit ﬂoating-point numbers (x, y) ̸= (0, 0),
and if all computations are correctly rounded, with the same rounding mode,
the result of x/
p
x2 + y2 lies in [−1, 1], except in a special case. What is this
special case and for what rounding mode does it occur?
Exercise 3.17 Show that the computation of E in Algorithm PrintFixed,
step 2, is correct – i.e. E = 1 + ⌊(e −1) log b/ log B⌋– as long as there is
no integer n such that |n/(e −1) log B/ log b −1| < ε, where ε is the relative
precision when computing λ: λ = log B/ log b(1 + θ) with |θ| ≤ε. For a
ﬁxed range of exponents −emax ≤e ≤emax, deduce a working precision ε.
Application: for b = 2, and emax = 231, compute the required precision for
3 ≤B ≤36.
Exercise 3.18 (Lef`evre) The IEEE 754-1985 standard required binary to dec-
imal conversions to be correctly rounded in double precision in the range
{m · 10n : |m| ≤1017 −1, |n| ≤27}. Find the hardest-to-print double-
precision number in this range (with rounding to nearest, for example). Write
a C program that outputs double-precision numbers in this range, and compare
it to the sprintf C-language function of your system; similarly, for a con-
version from the IEEE 754-2008 binary64 format (signiﬁcand of 53 bits,
2−1074 ≤|x| < 21024) to the decimal64 format (signiﬁcand of 16 decimal
digits).
Exercise 3.19 The same question as in Exercise 3.18, but for decimal to binary
conversion, and the atof C-language function.
3.8 Notes and references
In her Ph.D. thesis [162, Chapter V], Val´erie M´enissier-Morain discusses con-
tinued fractions and redundant representations as alternatives to the classical
non-redundant representation considered here. She also considers [162, Chap-
ter III] the theory of computable reals, their representation by B-adic numbers,
and the computation of algebraic or transcendental functions.
Other representations were designed to increase the range of representable
values; in particular Clenshaw and Olver [70] invented level-index arithmetic,
where for example 2009 is approximated by 3.7075, since 2009
≈
exp(exp(exp(0.7075))), and the leading 3 indicates the number of iterated ex-
ponentials. The obvious drawback is that it is expensive to perform arithmetic
operations such as addition on numbers in the level-index representation.

3.8 Notes and references
121
Clenshaw and Olver [69] also introduced the concept of an unrestricted
algorithm (meaning no restrictions on the precision or exponent range).
Several such algorithms were described in Brent [48].
Nowadays most computers use radix two, but other choices (for example
radix 16) were popular in the past, before the widespread adoption of the IEEE
754 standard. A discussion of the best choice of radix is given in Brent [42].
For a general discussion of ﬂoating-point addition, rounding modes, the
sticky bit, etc., see Hennessy, Patterson, and Goldberg [120, Appendix A.4].4
The main reference for ﬂoating-point arithmetic is the IEEE 754 standard
[5], which deﬁnes four binary formats: single precision, single extended (dep-
recated), double precision, and double extended. The IEEE 854 standard de-
ﬁnes radix-independent arithmetic, and mainly decimal arithmetic – see Cody
et al. [72]. Both standards were replaced by the revision of IEEE 754 (approved
by the IEEE Standards Committee on June 12, 2008).
We have not found the source of Theorem 3.2 – it seems to be “folklore”.
The rule regarding the precision of a result, given possibly differing precisions
of the operands, was considered by Brent [49] and Hull [127].
Floating-point expansions were introduced by Priest [186]. They are mainly
useful for a small number of summands, typically two or three, and when the
main operations are additions or subtractions. For a larger number of sum-
mands, the combinatorial logic becomes complex, even for addition. Also,
except in simple cases, it seems difﬁcult to obtain correct rounding with
expansions.
Some good references on error analysis of ﬂoating-point algorithms are the
books by Higham [121] and Muller [174]. Older references include Wilkin-
son’s classics [228, 229].
Collins and Krandick [74], and Lef`evre [153], proposed algorithms for
multiple-precision ﬂoating-point addition.
The problem of leading zero anticipation and detection in hardware is classi-
cal; see Schmookler and Nowka [194] for a comparison of different methods.
Theorem 3.4 may be found in Sterbenz [210].
The idea of having a “short product” together with correct rounding was
studied by Krandick and Johnson [145]. They attributed the term “short prod-
uct” to Knuth. They considered both the schoolbook and the Karatsuba do-
mains. Algorithms ShortProduct and ShortDivision are due to Mulders [173].
The problem of consecutive zeros or ones – also called runs of zeros or ones –
has been studied by several authors in the context of computer arithmetic:
Iordache and Matula [129] studied division (Theorem 3.9), square root, and
4 We refer to the ﬁrst edition as later editions may not include the relevant Appendix by
Goldberg.

122
Floating-point arithmetic
reciprocal square root. Muller and Lang [151] generalized their results to alge-
braic functions.
The fast Fourier transform (FFT) using complex ﬂoating-point numbers and
the Sch¨onhage–Strassen algorithm are described in Knuth [142]. Many varia-
tions of the FFT are discussed in the books by Crandall [79, 80]. For further
references, see §2.9.
Theorem 3.6 is from Percival [183]; previous rigorous error analyses of
complex FFT gave very pessimistic bounds. Note that the erroneous proof
given in [183] was corrected by Brent, Percival, and Zimmermann [55] (see
also Exercise 3.8).
The concept of “middle product” for power series is discussed in Hanrot et
al. [111]. Bostan, Lecerf, and Schost [40] have shown that it can be seen as
a special case of “Tellegen’s principle”, and have generalized it to operations
other than multiplication. The link between usual multiplication and the mid-
dle product using trilinear forms was mentioned by Victor Pan [181] for the
multiplication of two complex numbers: “The duality technique enables us to
extend any successful bilinear algorithms to two new ones for the new prob-
lems, sometimes quite different from the original problem · · · ”. Harvey [115]
has shown how to efﬁciently implement the middle product for integers. A
detailed and comprehensive description of the Payne and Hanek argument re-
duction method can be found in Muller [174].
In this section, we drop the “∼” that strictly should be included in the com-
plexity bounds. The 2M(n) reciprocal algorithm of §3.4.1 – with the wrap-
around trick – is due to Sch¨onhage, Grotefeld, and Vetter [198]. It can be
improved, as noticed by Dan Bernstein [20]. If we keep the FFT-transform of
x, we can save M(n)/3 (assuming the term-to-term products have negligible
cost), which gives 5M(n)/3. Bernstein also proposes a “messy” 3M(n)/2
algorithm [20]. Sch¨onhage’s 3M(n)/2 algorithm is simpler [197]. The idea
is to write Newton’s iteration as x′ = 2x −ax2. If x is accurate to n/2 bits,
then ax2 has (in theory) 2n bits, but we know the upper n/2 bits cancel with
x, and we are not interested in the low n bits. Thus, we can perform modu-
lar FFTs of size 3n/2, with cost M(3n/4) for the last iteration, and 1.5M(n)
overall. This 1.5M(n) bound for the reciprocal was improved to 1.444M(n)
by Harvey [116]. See also Cornea-Hasegan, Golliver, and Markstein [78] for
the roundoff error analysis when using a ﬂoating-point multiplier.
The idea of incorporating the dividend in Algorithm DivideNewton is due to
Karp and Markstein [137], and is usually known as the Karp–Markstein trick;
we already used it in Algorithm ExactDivision in Chapter 1. The asymptotic
complexity 5M(n)/2 of ﬂoating-point division can be improved to 5M(n)/3,
as shown by van der Hoeven in [125]. Another well-known method to perform

3.8 Notes and references
123
a ﬂoating-point division is Goldschmidt’s iteration: starting from a/b, ﬁrst ﬁnd
c such that b1 = cb is close to 1, and a/b = a1/b1 with a1 = ca. At step
k, assuming a/b = ak/bk, we multiply both ak and bk by 2 −bk, giving
ak+1 and bk+1. The sequence (bk) converges to 1, and (ak) converges to a/b.
Goldschmidt’s iteration works because, if bk = 1 + εk with εk small, then
bk+1 = (1 + εk)(1 −εk) = 1 −ε2
k. Goldschmidt’s iteration admits quadratic
convergence as does Newton’s method. However, unlike Newton’s method,
Goldschmidt’s iteration is not self-correcting. Thus, it yields an arbitrary pre-
cision division with cost Θ(M(n) log n). For this reason, Goldschmidt’s it-
eration should only be used for small, ﬁxed precision. A detailed analysis of
Goldschmidt’s algorithms for division and square root, and a comparison with
Newton’s method, is given in Markstein [158].
Bernstein [20] obtained faster square root algorithms in the FFT domain, by
caching some Fourier transforms. More precisely, he obtained 11M(n)/6 for
the square root, and 5M(n)/2 for the simultaneous computation of x1/2 and
x−1/2. The bound for the square root was reduced to 4M(n)/3 by
Harvey [116].
Classical ﬂoating-point conversion algorithms are due to Steele and White
[207], Gay [103], and Clinger [71]; most of these authors assume ﬁxed pre-
cision. Cowlishaw maintains an extensive bibliography of conversion to and
from decimal formats (see §5.3). What we call “free-format” output is called
“idempotent conversion” by Kahan [133]; see also Knuth [142, exercise 4.4-
18]. Another useful reference on binary to decimal conversion is Cornea et
al. [77].
B¨urgisser, Clausen, and Shokrollahi [60] is an excellent book on topics such
as lower bounds, fast multiplication of numbers and polynomials, Strassen-like
algorithms for matrix multiplication, and the tensor rank problem.
There is a large literature on interval arithmetic, which is outside the scope
of this chapter. A recent book is Kulisch [149], and a good entry point is the
Interval Computations web page (see Chapter 5).
In this chapter, we did not consider complex arithmetic, except where rel-
evant for its use in the FFT. An algorithm for the complex (ﬂoating-point)
square root, which allows correct rounding, is given in Ercegovac and Muller
[91]. See also the comments on Friedland’s algorithm in §4.12.


4
Elementary and special function evaluation
Here we consider various applications of Newton’s method,
which can be used to compute reciprocals, square roots, and more
generally algebraic and functional inverse functions. We then
consider unrestricted algorithms for computing elementary and
special functions. The algorithms of this chapter are presented at
a higher level than in Chapter 3. A full and detailed analysis of
one special function might be the subject of an entire chapter!
4.1 Introduction
This chapter is concerned with algorithms for computing elementary and
special functions, although the methods apply more generally. First we con-
sider Newton’s method, which is useful for computing inverse functions. For
example, if we have an algorithm for computing y = ln x, then Newton’s
method can be used to compute x = exp y (see §4.2.5). However, Newton’s
method has many other applications. In fact, we already mentioned Newton’s
method in Chapters 1–3, but here we consider it in more detail.
After considering Newton’s method, we go on to consider various methods
for computing elementary and special functions. These methods include power
series (§4.4), asymptotic expansions (§4.5), continued fractions (§4.6), recur-
rence relations (§4.7), the arithmetic-geometric mean (§4.8), binary splitting
(§4.9), and contour integration (§4.10). The methods that we consider are un-
restricted in the sense that there is no restriction on the attainable precision –
in particular, it is not limited to the precision of IEEE standard 32-bit or 64-bit
ﬂoating-point arithmetic. Of course, this depends on the availability of a suit-
able software package for performing ﬂoating-point arithmetic on operands of
arbitrary precision, as discussed in Chapter 3.

126
Elementary and special function evaluation
Unless stated explicitly, we do not consider rounding issues in this chapter;
it is assumed that methods described in Chapter 3 are used. Also, to simplify
the exposition, we assume a binary radix (β = 2), although most of the content
could be extended to any radix. We recall that n denotes the relative precision
(in bits here) of the desired approximation; if the absolute computed value is
close to 1, then we want an approximation to within 2−n.
4.2 Newton’s method
Newton’s method is a major tool in arbitrary-precision arithmetic. We have al-
ready seen it or its p-adic counterpart, namely Hensel lifting, in previous chap-
ters (see for example Algorithm ExactDivision in §1.4.5, or the iteration (2.3)
to compute a modular inverse in §2.5). Newton’s method is also useful in small
precision: most modern processors only implement addition and multiplication
in hardware; division and square root are microcoded, using either Newton’s
method if a fused multiply-add instruction is available, or the SRT algorithm.
See the algorithms to compute a ﬂoating-point reciprocal or reciprocal square
root in §3.4.1 and §3.5.1.
This section discusses Newton’s method is more detail, in the context of
ﬂoating-point computations, for the computation of inverse roots (§4.2.1),
reciprocals (§4.2.2), reciprocal square roots (§4.2.3), formal power series
(§4.2.4), and functional inverses (§4.2.5). We also discuss higher-order Newton-
like methods (§4.2.6).
Newton’s method via linearization
Recall that a function f of a real variable is said to have a zero ζ if f(ζ) = 0.
If f is differentiable in a neighborhood of ζ, and f ′(ζ) ̸= 0, then ζ is said to be
a simple zero. Similarly, for functions of several real (or complex) variables. In
the case of several variables, ζ is a simple zero if the Jacobian matrix evaluated
at ζ is non-singular.
Newton’s method for approximating a simple zero ζ of f is based on the idea
of making successive linear approximations to f(x) in a neighborhood of ζ.
Suppose that x0 is an initial approximation, and that f(x) has two continuous
derivatives in the region of interest. From Taylor’s theorem1
f(ζ) = f(x0) + (ζ −x0)f ′(x0) + (ζ −x0)2
2
f ′′(ξ)
(4.1)
1 Here we use Taylor’s theorem at x0, since this yields a formula in terms of derivatives at x0,
which is known, instead of at ζ, which is unknown. Sometimes (for example in the derivation
of (4.3)), it is preferable to use Taylor’s theorem at the (unknown) zero ζ.

4.2 Newton’s method
127
for some point ξ in an interval including {ζ, x0}. Since f(ζ) = 0, we see that
x1 = x0 −f(x0)/f ′(x0)
is an approximation to ζ, and
x1 −ζ = O
¡
|x0 −ζ|2¢
.
Provided x0 is sufﬁciently close to ζ, we will have
|x1 −ζ| ≤|x0 −ζ|/2 < 1.
This motivates the deﬁnition of Newton’s method as the iteration
xj+1 = xj −f(xj)
f ′(xj), j = 0, 1, . . . .
(4.2)
Provided |x0 −ζ| is sufﬁciently small, we expect xn to converge to ζ. The
order of convergence will be at least two, i.e.
|en+1| ≤K|en|2
for some constant K independent of n, where en = xn −ζ is the error after n
iterations.
A more careful analysis shows that
en+1 = f ′′(ζ)
2f ′(ζ) e2
n + O
¡
|e3
n|
¢
,
(4.3)
provided f ∈C3 near ζ. Thus, the order of convergence is exactly two if
f ′′(ζ) ̸= 0 and e0 is sufﬁciently small but non-zero. (Such an iteration is also
said to be quadratically convergent.)
4.2.1 Newton’s method for inverse roots
Consider applying Newton’s method to the function
f(x) = y −x−m,
where m is a positive integer constant, and (for the moment) y is a positive
constant. Since f ′(x) = mx−(m+1), Newton’s iteration simpliﬁes to
xj+1 = xj + xj(1 −xm
j y)/m.
(4.4)
This iteration converges to ζ = y−1/m provided the initial approximation x0
is sufﬁciently close to ζ. It is perhaps surprising that (4.4) does not involve
divisions, except for a division by the integer constant m. In particular, we can
easily compute reciprocals (the case m = 1) and reciprocal square roots (the
case m = 2) by Newton’s method. These cases are sufﬁciently important that
we discuss them separately in the following subsections.

128
Elementary and special function evaluation
4.2.2 Newton’s method for reciprocals
Taking m = 1 in (4.4), we obtain the iteration
xj+1 = xj + xj(1 −xjy),
(4.5)
which we expect to converge to 1/y, provided x0 is a sufﬁciently good approx-
imation. (See §3.4.1 for a concrete algorithm with error analysis.) To see what
“sufﬁciently good” means, deﬁne
uj = 1 −xjy.
Note that uj →0 iff xj →1/y. Multiplying each side of (4.5) by y, we get
1 −uj+1 = (1 −uj)(1 + uj),
which simpliﬁes to
uj+1 = u2
j.
(4.6)
Thus
uj = (u0)2j
.
(4.7)
We see that the iteration converges iff |u0| < 1, which (for real x0 and y) is
equivalent to the condition x0y ∈(0, 2). Second-order convergence is reﬂected
in the double exponential with exponent 2 on the right-hand side of (4.7).
The iteration (4.5) is sometimes implemented in hardware to compute re-
ciprocals of ﬂoating-point numbers (see §4.12). The sign and exponent of the
ﬂoating-point number are easily handled, so we can assume that y ∈[0.5, 1.0)
(recall we assume a binary radix in this chapter). The initial approximation x0
is found by table lookup, where the table is indexed by the ﬁrst few bits of y.
Since the order of convergence is two, the number of correct bits approximately
doubles at each iteration. Thus, we can predict in advance how many iterations
are required. Of course, this assumes that the table is initialized correctly.2
Computational issues
At ﬁrst glance, it seems better to replace Eqn. (4.5) by
xj+1 = xj(2 −xjy),
(4.8)
which looks simpler. However, although those two forms are mathematically
equivalent, they are not computationally equivalent. Indeed, in Eqn. (4.5), if
xj approximates 1/y to within n/2 bits, then 1 −xjy = O(2−n/2), and the
2 In the case of the infamous Pentium fdiv bug [109, 175], a lookup table used for division
was initialized incorrectly, and the division was occasionally inaccurate. In this case division
used the SRT algorithm, but the moral is the same – tables must be initialized correctly.

4.2 Newton’s method
129
product of xj by 1−xjy might be computed with a precision of only n/2 bits.
In the apparently simpler form (4.8), 2−xjy = 1+O(2−n/2), and the product
of xj by 2−xjy has to be performed with a full precision of n bits to get xj+1
accurate to within n bits.
As a general rule, it is best to separate the terms of different order in New-
ton’s iteration, and not try to factor common expressions. For an exception, see
the discussion of Sch¨onhage’s 3M(n)/2 reciprocal algorithm in §3.8.
4.2.3 Newton’s method for (reciprocal) square roots
Taking m = 2 in (4.4), we obtain the iteration
xj+1 = xj + xj(1 −x2
jy)/2,
(4.9)
which we expect to converge to y−1/2 provided x0 is a sufﬁciently good ap-
proximation.
If we want to compute y1/2, we can do this in one multiplication after ﬁrst
computing y−1/2, since
y1/2 = y × y−1/2.
This method does not involve any divisions (except by 2, see Exercise3.15).
In contrast, if we apply Newton’s method to the function f(x) = x2 −y, we
obtain Heron’s3 iteration (see Algorithm SqrtInt in §1.5.1) for the square root
of y
xj+1 = 1
2
µ
xj + y
xj
¶
.
(4.10)
This requires a division by xj at iteration j, so it is essentially different from
the iteration (4.9). Although both iterations have second-order convergence,
we expect (4.9) to be more efﬁcient (however this depends on the relative cost
of division compared to multiplication). See also §3.5.1 and, for various opti-
mizations, §3.8.
4.2.4 Newton’s method for formal power series
This section is not required for function evaluation, however it gives a comple-
mentary point of view on Newton’s method, and has applications to computing
constants such as Bernoulli numbers (see Exercises 4.41–4.42).
Newton’s method can be applied to ﬁnd roots of functions deﬁned by for-
mal power series as well as of functions of a real or complex variable. For
3 Heron of Alexandria, circa 10–75 AD.

130
Elementary and special function evaluation
simplicity, we consider formal power series of the form
A(z) = a0 + a1z + a2z2 + · · · ,
where ai ∈R (or any ﬁeld of characteristic zero) and ord(A) = 0, i.e. a0 ̸= 0.
For example, if we replace y in (4.5) by 1−z, and take initial approximation
x0 = 1, we obtain a quadratically convergent iteration for the formal power
series
(1 −z)−1 =
∞
X
n=0
zn.
In the case of formal power series, “quadratically convergent” means that
ord(ej) →+∞like 2j, where ej is the difference between the desired
result and the jth approximation. In our example, with the notation of §4.2.2,
u0 = 1 −x0y = z, so uj = z2j and
xj = 1 −uj
1 −z =
1
1 −z + O
³
z2j´
.
Given a formal power series A(z) = P
j≥0 ajzj, we can deﬁne the formal
derivative
A′(z) =
X
j>0
jajzj−1 = a1 + 2a2z + 3a3z2 + · · · ,
and the integral
X
j≥0
aj
j + 1 zj+1,
but there is no useful analogue for multiple-precision integers Pn
j=0 ajβj.
This means that some fast algorithms for operations on power series have no
analogue for operations on integers (see for example Exercise 4.1).
4.2.5 Newton’s method for functional inverses
Given a function g(x), its functional inverse h(x) satisﬁes g(h(x)) = x, and
is denoted by h(x) := g(−1)(x). For example, g(x) = ln x and h(x) = exp x
are functional inverses, as are g(x) = tan x and h(x) = arctan x. Using the
function f(x) = y −g(x) in (4.2), we get a root ζ of f, i.e. a value such that
g(ζ) = y, or ζ = g(−1)(y)
xj+1 = xj + y −g(xj)
g′(xj)
.

4.2 Newton’s method
131
Since this iteration only involves g and g′, it provides an efﬁcient way to eval-
uate h(y), assuming that g(xj) and g′(xj) can be efﬁciently computed. More-
over, if the complexity of evaluating g′ – and of division – is no greater than
that of g, we get a means to evaluate the functional inverse h of g with the same
order of complexity as that of g.
As an example, if one has an efﬁcient implementation of the logarithm, a
similarly efﬁcient implementation of the exponential is deduced as follows.
Consider the root ey of the function f(x) = y−ln x, which yields the iteration
xj+1 = xj + xj(y −ln xj),
(4.11)
and in turn Algorithm LiftExp (for the sake of simplicity, we consider here
only one Newton iteration).
Algorithm 4.1 LiftExp
Input: xj, (n/2)-bit approximation to exp(y)
Output: xj+1, n-bit approximation to exp(y)
t ←ln xj
⊲t computed to n-bit accuracy
u ←y −t
⊲u computed to (n/2)-bit accuracy
v ←xju
⊲v computed to (n/2)-bit accuracy
xj+1 ←xj + v.
4.2.6 Higher-order Newton-like methods
The classical Newton’s method is based on a linear approximation of f(x) near
x0. If we use a higher-order approximation, we can get a higher-order method.
Consider for example a second-order approximation. Eqn. (4.1) becomes:
f(ζ) = f(x0) + (ζ −x0)f ′(x0) + (ζ −x0)2
2
f ′′(x0) + (ζ −x0)3
6
f ′′′(ξ).
Since f(ζ) = 0, we have
ζ = x0 −f(x0)
f ′(x0) −(ζ −x0)2
2
f ′′(x0)
f ′(x0) + O((ζ −x0)3).
(4.12)
A difﬁculty here is that the right-hand side of (4.12) involves the unknown ζ.
Let ζ = x0 −f(x0)/f ′(x0) + ν, where ν is a second-order term. Substituting
this in the right-hand side of (4.12) and neglecting terms of order (ζ −x0)3
yields the cubic iteration
xj+1 = xj −f(xj)
f ′(xj) −f(xj)2f ′′(xj)
2f ′(xj)3
.

132
Elementary and special function evaluation
For the computation of the reciprocal (§4.2.2) with f(x) = y−1/x, this yields
xj+1 = xj + xj(1 −xjy) + xj(1 −xjy)2.
(4.13)
For the computation of exp y using functional inversion (§4.2.5), we get
xj+1 = xj + xj(y −ln xj) + 1
2xj(y −ln xj)2.
(4.14)
These iterations can be obtained in a more systematic way that generalizes to
give iterations of arbitrarily high order. For the computation of the reciprocal,
let εj = 1 −xjy, so xjy = 1 −εj and (assuming |εj| < 1),
1/y = xj/(1 −εj) = xj(1 + εj + ε2
j + · · · ).
Truncating after the term εk−1
j
gives a kth-order iteration
xj+1 = xj(1 + εj + ε2
j + · · · + εk−1
j
)
(4.15)
for the reciprocal. The case k = 2 corresponds to Newton’s method, and the
case k = 3 is just the iteration (4.13) that we derived above.
Similarly, for the exponential we take εj = y −ln xj = ln(x/xj), so
x/xj = exp εj =
∞
X
m=0
εm
j
m!
.
Truncating after k terms gives a kth-order iteration
xj+1 = xj
Ã k−1
X
m=0
εm
j
m!
!
(4.16)
for the exponential function. The case k = 2 corresponds to the Newton itera-
tion, the case k = 3 is the iteration (4.14) that we derived above, and the cases
k > 3 give higher-order Newton-like iterations. For a generalization to other
functions, see Exercises 4.3, 4.6.
4.3 Argument reduction
Argument reduction is a classical method to improve the efﬁciency of the eval-
uation of mathematical functions. The key idea is to reduce the initial problem
to a domain where the function is easier to evaluate. More precisely, given f
to evaluate at x, we proceed in three steps:

4.3 Argument reduction
133
• argument reduction: x is transformed into a reduced argument x′;
• evaluation: f is evaluated at x′;
• reconstruction: f(x) is computed from f(x′) using a functional identity.
In some cases, the argument reduction or the reconstruction is trivial, for ex-
ample x′ = x/2 in radix 2, or f(x) = ±f(x′) (some examples illustrate this
below). It might also be that the evaluation step uses a different function g
instead of f; for example, sin(x + π/2) = cos(x).
Unfortunately, argument reduction formulæ do not exist for every function;
for example, no argument reduction is known for the error function. Argument
reduction is only possible when a functional identity relates f(x) and f(x′) (or
g(x) and g(x′)). The elementary functions have addition formulae such as
exp(x + y) = exp(x) exp(y),
log(xy) = log(x) + log(y),
sin(x + y) = sin(x) cos(y) + cos(x) sin(y),
tan(x + y) = tan(x) + tan(y)
1 −tan(x) tan(y)
.
(4.17)
We use these formulæ to reduce the argument so that power series converge
more rapidly. Usually we take x = y to get doubling formulae such as
exp(2x) = exp(x)2,
(4.18)
though occasionally tripling formulae such as
sin(3x) = 3 sin(x) −4 sin3(x)
might be useful. This tripling formula only involves one function (sin), whereas
the doubling formula sin(2x) = 2 sin x cos x involves two functions (sin and
cos), but this problem can be overcome: see §4.3.4 and §4.9.1.
We usually distinguish two kinds of argument reduction:
• Additive argument reduction, where x′ = x −kc, for some real constant
c and some integer k. This occurs in particular when f(x) is periodic, for
example for the sine and cosine functions with c = 2π.
• Multiplicative argument reduction, where x′ = x/ck for some real constant
c and some integer k. This occurs with c = 2 in the computation of exp x
when using the doubling formula (4.18): see §4.3.1.
Note that, for a given function, both kinds of argument reduction might be
available. For example, for sin x, we might either use the tripling formula
sin(3x) = 3 sin x −4 sin3 x, or the additive reduction sin(x + 2kπ) = sin x
that arises from the periodicity of sin.

134
Elementary and special function evaluation
Sometimes “reduction” is not quite the right word, since a functional identity
is used to increase rather than to decrease the argument. For example, the
Gamma function Γ(x) satisﬁes an identity
xΓ(x) = Γ(x + 1),
that can be used repeatedly to increase the argument until we reach the region
where Stirling’s asymptotic expansion is sufﬁciently accurate, see §4.5.
4.3.1 Repeated use of a doubling formula
If we apply the doubling formula (4.18) for the exponential function k times,
we get
exp(x) = exp(x/2k)2k.
Thus, if |x| = Θ(1), we can reduce the problem of evaluating exp(x) to that of
evaluating exp(x/2k), where the argument is now O(2−k). This is better since
the power series converges more quickly for x/2k. The cost is the k squarings
that we need to reconstruct the ﬁnal result from exp(x/2k).
There is a trade-off here, and k should be chosen to minimize the total time.
If the obvious method for power series evaluation is used, then the optimal k is
of order √n and the overall time is O(n1/2M(n)). We shall see in §4.4.3 that
there are faster ways to evaluate power series, so this is not the best possible
result.
We assumed here that |x| = Θ(1). A more careful analysis shows that the
optimal k depends on the order of magnitude of x (see Exercise 4.5).
4.3.2 Loss of precision
For some power series, especially those with alternating signs, a loss of pre-
cision might occur due to a cancellation between successive terms. A typical
example is the series for exp(x) when x < 0. Assume for example that we
want ten signiﬁcant digits of exp(−10). The ﬁrst ten terms xk/k! for x = −10
are approximately:
1., −10., 50., −166.6666667, 416.6666667, −833.3333333, 1388.888889,
−1984.126984, 2480.158730, −2755.731922.
Note that these terms alternate in sign and initially increase in magnitude. They
only start to decrease in magnitude for k > |x|. If we add the ﬁrst 51 terms
with a working precision of ten decimal digits, we get an approximation to
exp(−10) that is only accurate to about three digits!

4.3 Argument reduction
135
A much better approach is to use the identity
exp(x) = 1/ exp(−x)
to avoid cancellation in the power series summation. In other cases, a different
power series without sign changes might exist for a closely related function:
for example, compare the series (4.22) and (4.23) for computation of the error
function erf(x). See also Exercises 4.19–4.20.
4.3.3 Guard digits
Guard digits are digits in excess of the number of digits that are required in
the ﬁnal answer. Generally, it is necessary to use some guard digits during a
computation in order to obtain an accurate result (one that is correctly rounded
or differs from the correctly rounded result by a small number of units in the
last place). Of course, it is expensive to use too many guard digits. Thus, care
has to be taken to use the right number of guard digits, i.e. the right working
precision. Here and below, we use the generic term “guard digits”, even for
radix β = 2.
Consider once again the example of exp x, with reduced argument x/2k and
x = Θ(1). Since x/2k is O(2−k), when we sum the power series 1+x/2k+· · ·
from left to right (forward summation), we “lose” about k bits of precision.
More precisely, if x/2k is accurate to n bits, then 1+x/2k is accurate to n+k
bits, but if we use the same working precision n, we obtain only n correct bits.
After squaring k times in the reconstruction step, about k bits will be lost (each
squaring loses about one bit), so the ﬁnal accuracy will be only n −k bits. If
we summed the power series in reverse order instead (backward summation),
and used a working precision of n + k when adding 1 and x/2k + · · · and
during the squarings, we would obtain an accuracy of n + k bits before the k
squarings, and an accuracy of n bits in the ﬁnal result.
Another way to avoid loss of precision is to evaluate expm1(x/2k), where
the function expm1 is deﬁned by
expm1(x) = exp(x) −1
and has a doubling formula that avoids loss of signiﬁcance when |x| is small.
See Exercises 4.7–4.9.

136
Elementary and special function evaluation
4.3.4 Doubling versus tripling
Suppose we want to compute the function sinh(x) = (ex −e−x)/2. The
obvious doubling formula for sinh,
sinh(2x) = 2 sinh(x) cosh(x),
involves the auxiliary function cosh(x) = (ex + e−x)/2. Since cosh2(x) −
sinh2(x) = 1, we could use the doubling formula
sinh(2x) = 2 sinh(x)
q
1 + sinh2(x),
but this involves the overhead of computing a square root. This suggests using
the tripling formula
sinh(3x) = sinh(x)(3 + 4 sinh2(x)).
(4.19)
However, it is usually more efﬁcient to do argument reduction via the doubling
formula (4.18) for exp, because it takes one multiplication and one squaring
to apply the tripling formula, but only two squarings to apply the doubling
formula twice (and 3 < 22). A drawback is loss of precision, caused by can-
cellation in the computation of exp(x) −exp(−x), when |x| is small. In this
case, it is better to use (see Exercise 4.10)
sinh(x) = (expm1(x) −expm1(−x))/2.
(4.20)
See §4.12 for further comments on doubling versus tripling, especially in the
FFT range.
4.4 Power series
Once argument reduction has been applied, where possible (§4.3), we are usu-
ally faced with the evaluation of a power series. The elementary and special
functions have power series expansions such as
exp x =
X
j≥0
xj
j!
,
ln(1 + x) =
X
j≥0
(−1)jxj+1
j + 1
,
arctan x =
X
j≥0
(−1)jx2j+1
2j + 1
, sinh x =
X
j≥0
x2j+1
(2j + 1)!
, etc.
This section discusses several techniques to recommend or to avoid. We use
the following notations: x is the evaluation point, n is the desired precision,
and d is the number of terms retained in the power series, or d−1 is the degree
of the corresponding polynomial P
0≤j<d ajxj.

4.4 Power series
137
If f(x) is analytic in a neighborhood of some point c, an obvious method to
consider for the evaluation of f(x) is summation of the Taylor series
f(x) =
d−1
X
j=0
(x −c)j f (j)(c)
j!
+ Rd(x, c).
As a simple but instructive example, we consider the evaluation of exp(x)
for |x| ≤1, using
exp(x) =
d−1
X
j=0
xj
j! + Rd(x),
(4.21)
where |Rd(x)| ≤|x|d exp(|x|)/d! ≤e/d!.
Using Stirling’s approximation for d!, we see that d ≥K(n) ∼n/ lg n is
sufﬁcient to ensure that |Rd(x)| = O(2−n). Thus, the time required to evaluate
(4.21) with Horner’s rule4 is O(nM(n)/ log n).
In practice, it is convenient to sum the series in the forward direction
(j = 0, 1, . . . , d −1). The terms tj = xj/j! and partial sums
Sj =
j
X
i=0
ti
may be generated by the recurrence tj = xtj−1/j, Sj = Sj−1 + tj, and the
summation terminated when |td| < 2−n/e. Thus, it is not necessary to estimate
d in advance, as it would be if the series were summed by Horner’s rule in the
backward direction (j = d −1, d −2, . . . , 0) (see however Exercise 4.4).
We now consider the effect of rounding errors, under the assumption that
ﬂoating-point operations are correctly rounded, i.e. satisfy
◦(x op y) = (x op y)(1 + δ),
where |δ| ≤ε and “op” = “+”, “−”, “×” or “/”. Here ε = 2−n is the “machine
precision” or “working precision”. Let btj be the computed value of tj, etc.
Thus
|btj −tj| / |tj| ≤2jε + O(ε2)
4 By Horner’s rule (with argument x), we mean evaluating the polynomial
s0 = P
0≤j≤d ajxj of degree d (not d −1 in this footnote) by the recurrence sd = ad,
sj = aj + sj+1x for j = d −1, d −2, . . . , 0. Thus, sk = P
k≤j≤d ajxj−k. An
evaluation by Horner’s rule takes d additions and d multiplications, and is more efﬁcient than
explicitly evaluating the individual terms ajxj.

138
Elementary and special function evaluation
and using Pd
j=0 tj = Sd ≤e
|bSd −Sd| ≤deε +
d
X
j=1
2jε|tj| + O(ε2)
≤(d + 2)eε + O(ε2) = O(nε).
Thus, to get |bSd−Sd| = O(2−n), it is sufﬁcient that ε = O(2−n/n). In other
words, we need to work with about lg n guard digits. This is not a signiﬁcant
overhead if (as we assume) the number of digits may vary dynamically. We
can sum with j increasing (the forward direction) or decreasing (the backward
direction). A slightly better error bound is obtainable for summation in the
backward direction, but this method has the disadvantage that the number of
terms d has to be decided in advance (see however Exercise 4.4).
In practice, it is inefﬁcient to keep the working precision ε ﬁxed. We can
proﬁtably reduce it when computing tj from tj−1 if |tj−1| is small, without
signiﬁcantly increasing the error bound. We can also vary the working preci-
sion when accumulating the sum, especially if it is computed in the backward
direction (so the smallest terms are summed ﬁrst).
It is instructive to consider the effect of relaxing our restriction that |x| ≤1.
First suppose that x is large and positive. Since |tj| > |tj−1| when j < |x|, it
is clear that the number of terms required in the sum (4.21) is at least of order
|x|. Thus, the method is slow for large |x| (see §4.3 for faster methods in this
case).
If |x| is large and x is negative, the situation is even worse. From Stirling’s
approximation we have
max
j≥0 |tj| ≃
exp |x|
p
2π|x|
,
but the result is exp(−|x|), so about 2|x|/ log 2 guard digits are required to
compensate for what Lehmer called “catastrophic cancellation” [94]. Since
exp(x) = 1/ exp(−x), this problem may easily be avoided, but the corre-
sponding problem is not always so easily avoided for other analytic functions.
Here is a less trivial example. To compute the error function
erf(x) =
2
√π
Z x
0
e−u2 du,
we may use either the power series
erf(x) = 2x
√π
∞
X
j=0
(−1)j x2j
j!(2j + 1)
(4.22)

4.4 Power series
139
or the (mathematically, but not numerically) equivalent
erf(x) = 2xe−x2
√π
∞
X
j=0
2j x2j
1 · 3 · 5 · · · (2j + 1)
.
(4.23)
For small |x|, the series (4.22) is slightly faster than the series (4.23) because
there is no need to compute an exponential. However, the series (4.23) is prefer-
able to (4.22) for moderate |x| because it involves no cancellation. For large
|x|, neither series is satisfactory, because Ω(x2) terms are required, and in this
case it is preferable to use the asymptotic expansion for erfc(x) = 1 −erf(x):
see §4.5. In the borderline region, use of the continued fraction (4.40) could be
considered: see Exercise 4.31.
In the following subsections, we consider different methods to evaluate power
series. We generally ignore the effect of rounding errors, but the results
obtained above are typical.
Assumption about the coefﬁcients
We assume in this section that we have a power series P
j≥0 ajxj, where
aj+δ/aj is a rational function R(j) of j, and hence it is easy to evaluate
a0, a1, a2, . . . sequentially. Here δ is a ﬁxed positive constant, usually 1 or
2. For example, in the case of exp x, we have δ = 1 and
aj+1
aj
=
j!
(j + 1)! =
1
j + 1
.
Our assumptions cover the common case of hypergeometric functions. For the
more general case of holonomic functions, see §4.9.2.
In common cases where our assumption is invalid, other good methods are
available to evaluate the function. For example, tan x does not satisfy our as-
sumption (the coefﬁcients in its Taylor series are called tangent numbers and
are related to Bernoulli numbers – see §4.7.2), but to evaluate tan x we can
use Newton’s method on the inverse function (arctan, which does satisfy our
assumptions – see §4.2.5), or we can use tan x = sin x/ cos x.
The radius of convergence
If the elementary function is an entire function (e.g. exp, sin), then the power
series converges in the whole complex plane. In this case, the degree of the
denominator of R(j) = aj+1/aj is greater than that of the numerator.
In other cases (such as ln, arctan), the function is not entire. The power
series only converges in a disk because the function has a singularity on the
boundary of this disk. In fact, ln(x) has a singularity at the origin, which is

140
Elementary and special function evaluation
why we consider the power series for ln(1 + x). This power series has radius
of convergence 1.
Similarly, the power series for arctan(x) has radius of convergence 1 be-
cause arctan(x) has singularities on the unit circle (at ±i) even though it is
uniformly bounded for all real x.
4.4.1 Direct power series evaluation
Suppose that we want to evaluate a power series P
j≥0 ajxj at a given argu-
ment x. Using periodicity (in the cases of sin, cos) and/or argument reduction
techniques (§4.3), we can often ensure that |x| is sufﬁciently small. Thus, let
us assume that |x| ≤1/2 and that the radius of convergence of the series is at
least 1.
As above, assume that aj+δ/aj is a rational function of j, and hence easy
to evaluate. For simplicity, we consider only the case δ = 1. To sum the series
with error O(2−n) it is sufﬁcient to take n + O(1) terms, so the time required
is O(nM(n)). If the function is entire, then the series converges faster and the
time is reduced to O(nM(n)/(log n)). However, we can do much better by
carrying the argument reduction further, as demonstrated in the next section.
4.4.2 Power series with argument reduction
Consider the evaluation of exp(x). By applying argument reduction k + O(1)
times, we can ensure that the argument x satisﬁes |x| < 2−k. Then, to obtain n-
bit accuracy we only need to sum O(n/k) terms of the power series. Assuming
that a step of argument reduction is O(M(n)), which is true for the elementary
functions, the total cost is O((k+n/k)M(n)). Indeed, the argument reduction
and/or reconstruction requires O(k) steps of O(M(n)), and the evaluation of
the power series of order n/k costs (n/k)M(n); so choosing k ∼n1/2 gives
cost
O
³
n1/2M(n)
´
.
For example, our comments apply to the evaluation of exp(x) using
exp(x) = exp(x/2)2,
to log1p(x) = ln(1 + x) using
log1p(x) = 2 log1p
µ
x
1 + √1 + x
¶
,

4.4 Power series
141
and to arctan(x) using
arctan x = 2 arctan
µ
x
1 +
√
1 + x2
¶
.
Note that in the last two cases each step of the argument reduction requires
a square root, but this can be done with cost O(M(n)) by Newton’s method
(§3.5). Thus, in all three cases the overall cost is O(n1/2M(n)), although the
implicit constant might be smaller for exp than for log1p or arctan. See Exer-
cises 4.8–4.9.
Using symmetries
A not-so-well-known idea is to evaluate ln(1 + x) using the power series
ln
µ1 + y
1 −y
¶
= 2
X
j≥0
y2j+1
2j + 1
with y deﬁned by (1 + y)/(1 −y) = 1 + x, i.e. y = x/(2 + x). This
saves half the terms and also reduces the argument, since y < x/2 if x > 0.
Unfortunately, this nice idea can be applied only once. For a related example,
see Exercise 4.11.
4.4.3 Rectangular series splitting
Once we determine how many terms in the power series are required for the
desired accuracy, the problem reduces to evaluating a truncated power series,
i.e. a polynomial.
Let P(x) = P
0≤j<d ajxj be the polynomial that we want to evaluate,
deg(P) < d. In the general case, x is a ﬂoating-point number of n bits,
and we aim at an accuracy of n bits for P(x). However, the coefﬁcients aj,
or their ratios R(j) = aj+1/aj, are usually small integers or rational num-
bers of O(log n) bits. A scalar multiplication involves one coefﬁcient aj and
the variable x (or more generally an n-bit ﬂoating-point number), whereas a
non-scalar multiplication involves two powers of x (or more generally two n-
bit ﬂoating-point numbers). Scalar multiplications are cheaper because the aj
are small rationals of size O(log n), whereas x and its powers generally have
Θ(n) bits. It is possible to evaluate P(x) with O(√n) non-scalar multiplica-
tions (plus O(n) scalar multiplications and O(n) additions, using O(√n) stor-
age). The same idea applies, more generally, to evaluation of hypergeometric
functions.

142
Elementary and special function evaluation
Classical splitting
Suppose d = jk, deﬁne y = xk, and write
P(x) =
j−1
X
ℓ=0
yℓPℓ(x),
where
Pℓ(x) =
k−1
X
m=0
akℓ+m xm.
We ﬁrst compute the powers x2, x3, . . . , xk−1, xk = y, then the polynomials
Pℓ(x) are evaluated simply by multiplying akℓ+m and the precomputed xm (it
is important not to use Horner’s rule here, since this would involve expensive
non-scalar multiplications). Finally, P(x) is computed from the Pℓ(x) using
Horner’s rule with argument y. To see the idea geometrically, write P(x) as
y0 [a0
+
a1x
+
a2x2
+
· · ·
+
ak−1xk−1]
+
y1 [ak
+
ak+1x
+
ak+2x2
+
· · ·
+
a2k−1xk−1]
+
y2 [a2k
+
a2k+1x
+
a2k+2x2
+
· · ·
+
a3k−1xk−1]
+
...
...
...
yj−1 [a(j−1)k
+
a(j−1)k+1x
+
a(j−1)k+2x2
+
· · ·
+ ajk−1xk−1] ,
where y = xk. The terms in square brackets are the polynomials P0(x), P1(x),
. . . , Pj−1(x).
As an example, consider d = 12, with j = 3 and k = 4. This gives P0(x) =
a0+a1x+a2x2+a3x3, P1(x) = a4+a5x+a6x2+a7x3, P2(x) = a8+a9x+
a10x2 +a11x3, then P(x) = P0(x)+yP1(x)+y2P2(x), where y = x4. Here
we need to compute x2, x3, x4, which requires three non-scalar products –
note that even powers like x4 should be computed as (x2)2 to use squarings
instead of multiplies – and we need two non-scalar products to evaluate P(x);
thus, a total of ﬁve non-scalar products, instead of d −2 = 10 with a naive
application of Horner’s rule to P(x).5
Modular splitting
An alternate splitting is the following, which may be obtained by transpos-
ing the matrix of coefﬁcients above, swapping j and k, and interchanging the
powers of x and y. It might also be viewed as a generalized odd–even scheme
(§1.3.5). Suppose as before that d = jk, and write, with y = xj:
P(x) =
j−1
X
ℓ=0
xℓPℓ(y),
where
Pℓ(y) =
k−1
X
m=0
ajm+ℓym.
5 P(x) has degree d −1, so Horner’s rule performs d −1 products, but the ﬁrst one x × ad−1
is a scalar product, hence there are d −2 non-scalar products.

4.4 Power series
143
First compute y = xj, y2, y3, . . . , yk−1. Now the polynomials Pℓ(y) can be
evaluated using only scalar multiplications of the form ajm+ℓ× ym.
To see the idea geometrically, write P(x) as
x0 [a0
+
ajy
+
a2jy2
+
· · · ]
+
x1 [a1
+
aj+1y
+
a2j+1y2
+
· · · ]
+
x2 [a2
+
aj+2y
+
a2j+2y2
+
· · · ]
+
...
...
...
xj−1 [aj−1
+
a2j−1y
+
a3j−1y2
+
· · · ] ,
where y = xj. We traverse the ﬁrst row of the array, then the second row, then
the third, . . ., ﬁnally the jth row, accumulating sums S0, S1, . . . , Sj−1 (one
for each row). At the end of this process, Sℓ= Pℓ(y), and we only have to
evaluate
P(x) =
j−1
X
ℓ=0
xℓSℓ.
The complexity of each scheme is almost the same (see Exercise 4.12). With
d = 12 (j = 3 and k = 4) we have P0(y) = a0 + a3y + a6y2 + a9y3,
P1(y) = a1 + a4y + a7y2 + a10y3, P2(y) = a2 + a5y + a8y2 + a11y3.
We ﬁrst compute y = x3, y2, and y3, then we evaluate P0(y) in three scalar
multiplications a3y, a6y2, and a9y3 and three additions, similarly for P1 and
P2. Finally we evaluate P(x) using
P(x) = P0(y) + xP1(y) + x2P2(y),
(here we might use Horner’s rule). In this example, we have a total of six non-
scalar multiplications: four to compute y and its powers, and two to evaluate
P(x).
Complexity of rectangular series splitting
To evaluate a polynomial P(x) of degree d −1 = jk −1, rectangular series
splitting takes O(j + k) non-scalar multiplications – each costing O(M(n)) –
and O(jk) scalar multiplications. The scalar multiplications involve multipli-
cation and/or division of a multiple-precision number by small integers. As-
sume that these multiplications and/or divisions take time c(d)n each (see Ex-
ercise 4.13 for a justiﬁcation of this assumption). The function c(d) accounts
for the fact that the involved scalars (the coefﬁcients aj or the ratios aj+1/aj)
have a size depending on the degree d of P(x). In practice, we can usually
regard c(d) as constant.

144
Elementary and special function evaluation
Choosing j ∼k ∼d1/2, we get overall time
O(d1/2M(n) + dn · c(d)).
(4.24)
If d is of the same order as the precision n of x, this is not an improvement
on the bound O(n1/2M(n)) that we obtained already by argument reduction
and power series evaluation (§4.4.2). However, we can do argument reduction
before applying rectangular series splitting. Assuming that c(n) = O(1) (see
Exercise 4.14 for a detailed analysis), the total complexity is
T(n) = O
³n
d M(n) + d1/2M(n) + dn
´
,
where the extra (n/d)M(n) term comes from argument reduction and/or re-
construction. Which term dominates? There are two cases:
1. M(n) ≫n4/3. Here the minimum is obtained when the ﬁrst two terms –
argument reduction/reconstruction and non-scalar multiplications – are
equal, i.e. for d ∼n2/3, which yields T(n) = O(n1/3M(n)). This case
applies if we use classical or Karatsuba multiplication, since lg 3 > 4/3,
and similarly for Toom–Cook 3-, 4-, 5-, or 6-way multiplication (but not
7-way, since log7 13 < 4/3). In this case, T(n) ≫n5/3.
2. M(n) ≪n4/3. Here the minimum is obtained when the ﬁrst and the last
terms – argument reduction/reconstruction and scalar multiplications – are
equal. The optimal value of d is then
p
M(n), and we get an improved
bound Θ(n
p
M(n)) ≫n3/2. We can not approach the O(n1+ε) that is
achievable with AGM-based methods (if applicable) – see §4.8.
4.5 Asymptotic expansions
Often it is necessary to use different methods to evaluate a special function in
different parts of its domain. For example, the exponential integral6
E1(x) =
Z ∞
x
exp(−u)
u
du
(4.25)
is deﬁned for all x > 0. However, the power series
E1(x) + γ + ln x =
∞
X
j=1
(−1)j−1xj
j!j
(4.26)
6 E1(x) and Ei(x) = PV
R x
−∞(exp(t)/t) dt are both called “exponential integrals”. Closely
related is the “logarithmic integral” li(x) = Ei(ln x) = PV
R x
0 (1/ ln t) dt. Here the integrals
PV
R
· · · should be interpreted as Cauchy principal values if there is a singularity in the range
of integration. The power series (4.26) is valid for x ∈C if | arg x| < π (see Exercise 4.16).

4.5 Asymptotic expansions
145
is unsatisfactory as a means of evaluating E1(x) for large positive x, for the
reasons discussed in §4.4 in connection with the power series (4.22) for erf(x),
or the power series for exp(x) (x negative). For sufﬁciently large positive x, it
is preferable to use
ex E1(x) =
k
X
j=1
(j −1)!(−1)j−1
xj
+ Rk(x),
(4.27)
where
Rk(x) = k! (−1)k exp(x)
Z ∞
x
exp(−u)
uk+1
du.
(4.28)
Note that
|Rk(x)| <
k!
xk+1 ,
so
lim
x→+∞Rk(x) = 0,
but limk→∞Rk(x) does not exist. In other words, the series
∞
X
j=1
(j −1)! (−1)j−1
xj
is divergent. In such cases, we call this an asymptotic series and write
ex E1(x) ∼
X
j>0
(j −1)!(−1)j−1
xj
.
(4.29)
Although they do not generally converge, asymptotic series are very useful.
Often (though not always!) the error is bounded by the last term taken in the
series (or by the ﬁrst term omitted). Also, when the terms in the asymptotic
series alternate in sign, it can often be shown that the true value lies between
two consecutive approximations obtained by summing the series with (say) k
and k + 1 terms. For example, this is true for the series (4.29) above, provided
x is real and positive.
When x is large and positive, the relative error attainable by using (4.27)
with k = ⌊x⌋is O(x1/2 exp(−x)), because
|Rk(k)| ≤k!/kk+1 = O(k−1/2 exp(−k))
(4.30)
and the leading term on the right side of (4.27) is 1/x. Thus, the asymptotic
series
may
be
used
to
evaluate
E1(x)
to
precision
n
whenever

146
Elementary and special function evaluation
x > n ln 2 + O(ln n). More precise estimates can be obtained by using a
version of Stirling’s approximation with error bounds, for example
µk
e
¶k √
2πk < k! <
µk
e
¶k √
2πk exp
µ 1
12k
¶
.
If x is too small for the asymptotic approximation to be sufﬁciently accurate,
we can avoid the problem of cancellation in the power series (4.26) by the
technique of Exercise 4.19. However, the asymptotic approximation is faster
and hence is preferable whenever it is sufﬁciently accurate.
Examples where asymptotic expansions are useful include the evaluation of
erfc(x), Γ(x), Bessel functions, etc. We discuss some of these below.
Asymptotic expansions often arise when the convergence of series is accel-
erated by the Euler–Maclaurin sum formula.7 For example, Euler’s constant γ
is deﬁned by
γ = lim
N→∞(HN −ln N) ,
(4.31)
where HN = P
1≤j≤N 1/j is a harmonic number. However, Eqn. (4.31) con-
verges slowly, so to evaluate γ accurately we need to accelerate the conver-
gence. This can be done using the Euler–Maclaurin formula. The idea is to
split the sum HN into two parts
HN = Hp−1 +
N
X
j=p
1
j
.
We approximate the second sum using the Euler–Maclaurin formula7 with
a = p, b = N, f(x) = 1/x, then let N →+∞. The result is
γ ∼Hp −ln p +
X
k≥1
B2k
2k p−2k.
(4.32)
If p and the number of terms in the asymptotic expansion are chosen judi-
ciously, this gives a good algorithm for computing γ (though not the best algo-
rithm: see §4.12 for a faster algorithm that uses properties of Bessel functions).
7
The Euler–Maclaurin sum formula is a way of expressing the difference between a sum and
an integral as an asymptotic expansion. For example, assuming that a ∈Z, b ∈Z, a ≤b, and
f(x) satisﬁes certain conditions, one form of the formula is
X
a≤k≤b
f(k) −
Z b
a
f(x) dx ∼f(a) + f(b)
2
+
X
k≥1
B2k
(2k)!
“
f(2k−1)(b) −f(2k−1)(a)
”
.
Often we can let b →+∞and omit the terms involving b on the right-hand side. For more
information, see §4.12.

4.5 Asymptotic expansions
147
Here is another example. The Riemann zeta-function ζ(s) is deﬁned for
s ∈C, ℜ(s) > 1, by
ζ(s) =
∞
X
j=1
j−s,
(4.33)
and by analytic continuation for other s ̸= 1. ζ(s) may be evaluated to any
desired precision if m and p are chosen large enough in the Euler–Maclaurin
formula
ζ(s) =
p−1
X
j=1
j−s + p−s
2
+ p1−s
s −1 +
m
X
k=1
Tk,p(s) + Em,p(s),
(4.34)
where
Tk,p(s) = B2k
(2k)! p1−s−2k
2k−2
Y
j=0
(s + j),
(4.35)
|Em,p(s)| < |Tm+1,p(s) (s + 2m + 1)/(σ + 2m + 1)|,
(4.36)
m ≥0, p ≥1, σ = ℜ(s) > −(2m + 1), and the B2k are Bernoulli numbers.
In arbitrary-precision computations, we must be able to compute as many
terms of an asymptotic expansion as are required to give the desired accuracy.
It is easy to see that, if m in (4.34) is bounded as the precision n goes to
∞, then p has to increase as an exponential function of n. To evaluate ζ(s)
from (4.34) to precision n in time polynomial in n, both m and p must tend to
inﬁnity with n. Thus, the Bernoulli numbers B2, . . . , B2m can not be stored in
a table of ﬁxed size,8 but must be computed when needed (see §4.7). For this
reason, we can not use asymptotic expansions when the general form of the
coefﬁcients is unknown or the coefﬁcients are too difﬁcult to evaluate. Often
there is a related expansion with known and relatively simple coefﬁcients. For
example, the asymptotic expansion (4.38) for ln Γ(x) has coefﬁcients related to
the Bernoulli numbers, like the expansion (4.34) for ζ(s), and thus is simpler to
implement than Stirling’s asymptotic expansion for Γ(x) (see Exercise 4.42).
Consider the computation of the error function erf(x). As seen in §4.4, the
series (4.22) and (4.23) are not satisfactory for large |x|, since they require
Ω(x2) terms. For example, to evaluate erf(1000) with an accuracy of six digits,
8 In addition, we would have to store them as exact rationals, taking ∼m2 lg m bits of storage,
since a ﬂoating-point representation would not be convenient unless the target precision n
were known in advance. See §4.7.2 and Exercise 4.37.

148
Elementary and special function evaluation
Eqn. (4.22) requires at least 2 718 279 terms! Instead, we may use an asymp-
totic expansion. The complementary error function erfc(x) = 1 −erf(x) sat-
isﬁes
erfc(x) ∼e−x2
x√π
k
X
j=0
(−1)j (2j)!
j! (2x)−2j,
(4.37)
with the error bounded in absolute value by the next term and of the same sign.
In the case x = 1000, the term for j = 1 of the sum equals −0.5 × 10−6; thus,
e−x2/(x√π) is an approximation to erfc(x) with an accuracy of six digits.
Because erfc(1000) ≈1.86 × 10−434 298 is very small, this gives an extremely
accurate approximation to erf(1000).
For a function like the error function, where both a power series (at x = 0)
and an asymptotic expansion (at x = ∞) are available, we might prefer to use
the former or the latter, depending on the value of the argument and on the
desired precision. We study here in some detail the case of the error function,
since it is typical.
The sum in (4.37) is divergent, since its jth term is ∼
√
2(j/ex2)j. We
need to show that the smallest term is O(2−n) in order to be able to deduce
an n-bit approximation to erfc(x). The terms decrease while j < x2 + 1/2,
so the minimum is obtained for j ≈x2, and is of order e−x2; thus, we need
x >
√
n ln 2. For example, for n = 106 bits this yields x > 833. However,
since erfc(x) is small for large x, say erfc(x) ≈2−λ, we need only m = n−λ
correct bits of erfc(x) to get n correct bits of erf(x) = 1 −erfc(x).
Consider x ﬁxed and j varying in the terms in the sums (4.22) and (4.37).
For j < x2, x2j/j! is an increasing function of j, but (2j)!/(j!(4x2)j) is a
decreasing function of j. In this region, the terms in Eqn. (4.37) are decreasing.
Thus, comparing the series (4.22) and (4.37), we see that the latter should
always be used if it can give sufﬁcient accuracy. Similarly, (4.37) should if
possible be used in preference to (4.23), as the magnitudes of corresponding
terms in (4.22) and in (4.23) are similar.
Algorithm Erf computes erf(x) for real positive x (for other real x, use the
fact that erf(x) is an odd function, so erf(−x) = −erf(x) and erf(0) = 0).
In Algorithm Erf, the number of terms needed if Eqn. (4.22) or Eqn. (4.23)
is used is approximately the unique positive root j0 (rounded up to the next
integer) of
j(ln j −2 ln x −1) = n ln 2,
so j0 > ex2. On the other hand, if Eqn. (4.37) is used, then the summation
bound k is less than x2 + 1/2 (since otherwise the terms start increasing). The

4.5 Asymptotic expansions
149
Algorithm 4.2 Erf
Input: positive ﬂoating-point number x, integer n
Output: an n-bit approximation to erf(x)
m ←⌈n −(x2 + ln x + (ln π)/2)/(ln 2)⌉
if (m + 1/2) ln(2) < x2 then
t ←erfc(x) with the asymptotic expansion (4.37) and precision m
return 1 −t (in precision n)
else if x < 1 then
compute erf(x) with the power series (4.22) in precision n
else
compute erf(x) with the power series (4.23) in precision n.
condition (m + 1/2) ln(2) < x2 in the algorithm ensures that the asymptotic
expansion can give m-bit accuracy.
Here is an example: for x = 800 and a precision of one million bits, Equa-
tion (4.23) requires about j0 = 2 339 601 terms. Eqn. (4.37) tells us that
erfc(x) ≈2−923 335; thus, we need only m = 76 665 bits of precision for
erfc(x) – in this case Eqn. (4.37) requires only about k = 10 375 terms. Note
that using Eqn. (4.22) would be slower than using Eqn. (4.23), because we
would have to compute about the same number of terms, but with higher pre-
cision, to compensate for cancellation. We recommend using Eqn. (4.22) only
if |x| is small enough that any cancellation is insigniﬁcant (for example, if
|x| < 1).
Another example, closer to the boundary: for x = 589, still with n = 106,
we have m = 499 489, which gives j0 = 1 497 924, and k = 325 092. For
somewhat smaller x (or larger n), it might be desirable to use the continued
fraction (4.40), see Exercise 4.31.
Occasionally, an asymptotic expansion can be used to obtain arbitrarily high
precision. For example, consider the computation of ln Γ(x). For large positive
x, we can use Stirling’s asymptotic expansion
ln Γ(x) =
µ
x −1
2
¶
ln x −x + ln(2π)
2
+
m−1
X
k=1
B2k
2k(2k −1)x2k−1 + Rm(x),
(4.38)
where Rm(x) is less in absolute value than the ﬁrst term neglected, i.e.
B2m
2m(2m −1)x2m−1 ,

150
Elementary and special function evaluation
and has the same sign.9 The ratio of successive terms tk and tk+1 of the sum is
tk+1
tk
≈−
µ k
πx
¶2
,
so the terms start to increase in absolute value for (approximately) k > πx.
This gives a bound on the accuracy attainable, in fact
ln |Rm(x)| > −2πx ln(x) + O(x).
However, because Γ(x) satisﬁes the functional equation Γ(x + 1) = xΓ(x),
we can take x′ = x + δ for some sufﬁciently large δ ∈N, evaluate ln Γ(x′)
using the asymptotic expansion, and then compute ln Γ(x) from the functional
equation. See Exercise 4.21.
4.6 Continued fractions
In §4.5, we considered the exponential integral E1(x). This can be computed
using the continued fraction
ex E1(x) =
1
x +
1
1 +
1
x +
2
1 +
2
x +
3
1 + · · ·
.
Writing continued fractions in this way takes a lot of space, so instead we use
the shorthand notation
ex E1(x) =
1
x+
1
1+
1
x+
2
1+
2
x+
3
1+ · · ·
(4.39)
Another example is
erfc(x) =
Ã
e−x2
√π
!
1
x+
1/2
x+
2/2
x+
3/2
x+
4/2
x+
5/2
x+ · · ·
(4.40)
Formally, a continued fraction
f = b0 + a1
b1+
a2
b2+
a3
b3+ · · · ∈bC
9 The asymptotic expansion is also valid for x ∈C, | arg x| < π, x ̸= 0, but the bound on the
error term Rm(x) in this case is more complicated. See for example [1, 6.1.42].

4.6 Continued fractions
151
is deﬁned by two sequences (aj)j∈N∗and (bj)j∈N, where aj, bj ∈C. Here
bC = C ∪{∞} is the set of extended complex numbers.10 The expression f is
deﬁned to be limk→∞fk, if the limit exists, where
fk = b0 + a1
b1+
a2
b2+
a3
b3+ · · · ak
bk
(4.41)
is the ﬁnite continued fraction – called the kth approximant – obtained by
truncating the inﬁnite continued fraction after k quotients.
Sometimes continued fractions are preferable, for computational purposes,
to power series or asymptotic expansions. For example, Euler’s continued frac-
tion (4.39) converges for all real x > 0, and is better for computation of E1(x)
than the power series (4.26) in the region where the power series suffers from
catastrophic cancellation but the asymptotic expansion (4.27) is not sufﬁciently
accurate. Convergence of (4.39) is slow if x is small, so (4.39) is preferred
for precision n evaluation of E1(x) only when x is in a certain interval, say
x ∈(c1n, c2n), c1 ≈0.1, c2 = ln 2 ≈0.6931 (see Exercise 4.24).
Continued fractions may be evaluated by either forward or backward recur-
rence relations. Consider the ﬁnite continued fraction
y = a1
b1+
a2
b2+
a3
b3+ · · · ak
bk
.
(4.42)
The backward recurrence is Rk = 1, Rk−1 = bk,
Rj = bj+1 Rj+1 + aj+2 Rj+2
(j = k −2, . . . , 0),
(4.43)
and y = a1R1/R0, with invariant
Rj
Rj−1
=
1
bj+
aj+1
bj+1+ · · · ak
bk
.
The forward recurrence is P0 = 0, P1 = a1, Q0 = 1, Q1 = b1,
Pj = bj Pj−1 + aj Pj−2
Qj = bj Qj−1 + aj Qj−2
)
(j = 2, . . . , k),
(4.44)
and y = Pk/Qk (see Exercise 4.26).
The advantage of evaluating an inﬁnite continued fraction such as (4.39) via
the forward recurrence is that the cutoff k need not be chosen in advance; we
can stop when |Dk| is sufﬁciently small, where
Dk = Pk
Qk
−Pk−1
Qk−1
.
(4.45)
10 Arithmetic operations on C are extended to bC in the obvious way, for example
1/0 = 1 + ∞= 1 × ∞= ∞, 1/∞= 0. Note that 0/0, 0 × ∞and ∞± ∞are undeﬁned.

152
Elementary and special function evaluation
The main disadvantage of the forward recurrence is that twice as many arith-
metic operations are required as for the backward recurrence with the same
value of k. Another disadvantage is that the forward recurrence may be less
numerically stable than the backward recurrence.
If we are working with variable-precision ﬂoating-point arithmetic, which is
much more expensive than single-precision ﬂoating-point, then a useful strat-
egy is to use the forward recurrence with single-precision arithmetic (scaled to
avoid overﬂow/underﬂow) to estimate k, and then use the backward recurrence
with variable-precision arithmetic. One trick is needed: to evaluate Dk using
scaled single-precision we use the recurrence
D1 = a1/b1,
Dj = −ajQj−2Dj−1/Qj
(j = 2, 3, . . .)
)
,
(4.46)
which avoids the cancellation inherent in (4.45).
By analogy with the case of power series with decreasing terms that alternate
in sign, there is one case in which it is possible to give a simple a posteriori
bound for the error occurred in truncating a continued fraction. Let f be a
convergent continued fraction with approximants fk as in (4.41). Then:
Theorem 4.1 If aj > 0 and bj > 0 for all j ∈N∗, then the sequence (f2k)k∈N
of even order approximants is strictly increasing, and the sequence (f2k+1)k∈N
of odd order approximants is strictly decreasing. Thus
f2k < f < f2k+1
and
¯¯¯¯f −fm−1 + fm
2
¯¯¯¯ <
¯¯¯¯
fm −fm−1
2
¯¯¯¯
for all m ∈N∗.
In general, if the conditions of Theorem 4.1 are not satisﬁed, then it is difﬁ-
cult to give simple, sharp error bounds. Power series and asymptotic series are
usually much easier to analyse than continued fractions.
4.7 Recurrence relations
The evaluation of special functions by continued fractions is a special case
of their evaluation by recurrence relations. To illustrate this, we consider the
Bessel functions of the ﬁrst kind, Jν(x). Here ν and x can in general be com-
plex, but we restrict attention to the case ν ∈Z, x ∈R. The functions Jν(x)

4.7 Recurrence relations
153
can be deﬁned in several ways, for example by the generating function (elegant
but only useful for ν ∈Z)
exp
µx
2
µ
t −1
t
¶¶
=
+∞
X
ν=−∞
tνJν(x),
(4.47)
or by the power series (also valid if ν /∈Z):
Jν(x) =
³x
2
´ν
∞
X
j=0
(−x2/4)j
j! Γ(ν + j + 1)
.
(4.48)
We also need Bessel functions of the second kind (sometimes called Neumann
functions or Weber functions) Yν(x), which may be deﬁned by
Yν(x) = lim
µ→ν
Jµ(x) cos(πµ) −J−µ(x)
sin(πµ)
.
(4.49)
Both Jν(x) and Yν(x) are solutions of Bessel’s differential equation
x2y′′ + xy′ + (x2 −ν2)y = 0.
(4.50)
4.7.1 Evaluation of Bessel functions
The Bessel functions Jν(x) satisfy the recurrence relation
Jν−1(x) + Jν+1(x) = 2ν
x Jν(x).
(4.51)
Dividing both sides by Jν(x), we see that
Jν−1(x)
Jν(x)
= 2ν
x −1
Á Jν(x)
Jν+1(x)
,
which gives a continued fraction for the ratio Jν(x)/Jν−1(x) (ν ≥1)
Jν(x)
Jν−1(x) =
1
2ν/x−
1
2(ν + 1)/x−
1
2(ν + 2)/x−· · · ·
(4.52)
However, (4.52) is not immediately useful for evaluating the Bessel functions
J0(x) or J1(x), as it only gives their ratio.
The recurrence (4.51) may be evaluated backwards by Miller’s algorithm.
The idea is to start at some sufﬁciently large index ν′, take fν′+1 = 0, fν′ = 1,
and evaluate the recurrence
fν−1 + fν+1 = 2ν
x fν
(4.53)

154
Elementary and special function evaluation
backwards to obtain fν′−1, · · · , f0. However, (4.53) is the same recurrence as
(4.51), so we expect to obtain f0 ≈cJ0(x), where c is some scale factor. We
can use the identity
J0(x) + 2
∞
X
ν=1
J2ν(x) = 1
(4.54)
to determine c.
To understand why Miller’s algorithm works, and why evaluation of the re-
currence (4.51) in the forward direction is numerically unstable for ν > x,
we observe that the recurrence (4.53) has two independent solutions: the de-
sired solution Jν(x), and an undesired solution Yν(x), where Yν(x) is a Bessel
function of the second kind, see Eqn. (4.49). The general solution of the recur-
rence (4.53) is a linear combination of the special solutions Jν(x) and Yν(x).
Due to rounding errors, the computed solution will also be a linear combina-
tion, say aJν(x) + bYν(x). Since |Yν(x)| increases exponentially with ν when
ν > ex/2, but |Jν(x)| is bounded, the unwanted component will increase ex-
ponentially if we use the recurrence in the forward direction, but decrease if
we use it in the backward direction.
More precisely, we have
Jν(x) ∼
1
√
2πν
³ex
2ν
´ν
and
Yν(x) ∼−
r
2
πν
µ2ν
ex
¶ν
(4.55)
as ν →+∞with x ﬁxed. Thus, when ν is large and greater than ex/2, Jν(x)
is small and |Yν(x)| is large.
Miller’s algorithm seems to be the most effective method in the region where
the power series (4.48) suffers from catastrophic cancellation, but asymptotic
expansions are not sufﬁciently accurate. For more on Miller’s algorithm, see
§4.12.
4.7.2 Evaluation of Bernoulli and tangent numbers
In §4.5, Eqns. (4.35) and (4.38), the Bernoulli numbers B2k or scaled Bernoulli
numbers Ck = B2k/(2k)! were required. These constants can be deﬁned by
the generating functions
∞
X
k=0
Bk
xk
k! =
x
ex −1
,
(4.56)
∞
X
k=0
Ckx2k =
x
ex −1 + x
2 =
x/2
tanh(x/2)
.
(4.57)

4.7 Recurrence relations
155
Multiplying both sides of (4.56) or (4.57) by ex −1, then equating coefﬁcients,
gives the recurrence relations
B0 = 1,
k
X
j=0
µk + 1
j
¶
Bj = 0 for k > 0,
(4.58)
and
k
X
j=0
Cj
(2k + 1 −2j)! =
1
2 (2k)!
.
(4.59)
These recurrences, or slight variants with similar numerical properties, have
often been used to evaluate Bernoulli numbers.
In this chapter our philosophy is that the required precision is not known in
advance, so it is not possible to precompute the Bernoulli numbers and store
them in a table once and for all. Thus, we need a good algorithm for computing
them at runtime.
Unfortunately, forward evaluation of the recurrence (4.58), or the corre-
sponding recurrence (4.59) for the scaled Bernoulli numbers, is numerically
unstable: using precision n, the relative error in the computed B2k or Ck is of
order 4k2−n: see Exercise 4.35.
Despite its numerical instability, use of (4.59) may give the Ck to acceptable
accuracy if they are only needed to generate coefﬁcients in an Euler–Maclaurin
expansion where the successive terms diminish by at least a factor of four (or if
the Ck are computed using exact rational arithmetic). If the Ck are required to
precision n, then (4.59) should be used with sufﬁcient guard digits, or (better)
a more stable recurrence should be used. If we multiply both sides of (4.57) by
sinh(x/2)/x and equate coefﬁcients, we get the recurrence
k
X
j=0
Cj
(2k + 1 −2j)! 4k−j =
1
(2k)! 4k .
(4.60)
If (4.60) is used to evaluate Ck, using precision n arithmetic, the relative
error is only O(k22−n). Thus, use of (4.60) gives a stable algorithm for
evaluating the scaled Bernoulli numbers Ck (and hence, if desired, the
Bernoulli numbers).
An even better, and perfectly stable, way to compute Bernoulli numbers is
to exploit their relationship with the tangent numbers Tj, deﬁned by
tan x =
X
j≥1
Tj
x2j−1
(2j −1)!
.
(4.61)
The tangent numbers are positive integers and can be expressed in terms of

156
Elementary and special function evaluation
Bernoulli numbers
Tj = (−1)j−122j ¡
22j −1
¢ B2j
2j
.
(4.62)
Conversely, the Bernoulli numbers can be expressed in terms of tangent
numbers
Bj =











1
if j = 0,
−1/2
if j = 1,
(−1)j/2−1jTj/2/(4j −2j)
if j > 0 is even,
0
otherwise.
Eqn. (4.62) shows that the odd primes in the denominator of the Bernoulli
number B2j must be divisors of 22j −1. In fact, this is a consequence of
Fermat’s little theorem and the Von Staudt–Clausen theorem, which says that
the primes p dividing the denominator of B2j are precisely those for which
(p −1)|2j (see §4.12).
We now derive a recurrence that can be used to compute tangent numbers,
using only integer arithmetic. For brevity, write t = tan x and D = d/dx.
Then Dt = sec2 x = 1 + t2. It follows that D(tn) = ntn−1(1 + t2) for all
n ∈N∗.
It is clear that Dnt is a polynomial in t, say Pn(t). For example, P0(t) = t,
P1(t) = 1+t2, etc. Write Pn(t) = P
j≥0 pn,jtj. From the recurrence Pn(t) =
DPn−1(t), and the formula for D(tn) just noted, we see that deg(Pn) = n+1
and
X
j≥0
pn,jtj =
X
j≥0
jpn−1,jtj−1(1 + t2),
so
pn,j = (j −1)pn−1,j−1 + (j + 1)pn−1,j+1
(4.63)
for all n ∈N∗. Using (4.63), it is straightforward to compute the coefﬁcients
of the polynomials P1(t), P2(t), etc.
Observe that, since tan x is an odd function of x, the polynomials P2k(t) are
odd, and the polynomials P2k+1(t) are even. Equivalently, pn,j = 0 if n + j is
even.
We are interested in the tangent numbers Tk = P2k−1(0) = p2k−1,0.
Using the recurrence (4.63) but avoiding computation of the coefﬁcients that
are known to vanish, we obtain Algorithm TangentNumbers for the in-place
computation of tangent numbers. Note that this algorithm uses only arithmetic
on non-negative integers. If implemented with single-precision integers, there

4.7 Recurrence relations
157
Algorithm 4.3 TangentNumbers
Input: positive integer m
Output: Tangent numbers T1, . . . , Tm
T1 ←1
for k from 2 to m do
Tk ←(k −1)Tk−1
for k from 2 to m do
for j from k to m do
Tj ←(j −k)Tj−1 + (j −k + 2)Tj
return T1, T2, . . . , Tm.
may be problems with overﬂow as the tangent numbers grow rapidly. If imple-
mented using ﬂoating-point arithmetic, it is numerically stable because there
is no cancellation. An analogous algorithm SecantNumbers is the topic of
Exercise 4.40.
The tangent numbers grow rapidly because the generating function tan x has
poles at x = ±π/2. Thus, we expect Tk to grow roughly like (2k−1)! (2/π)2k.
More precisely
Tk
(2k −1)! = 22k+1(1 −2−2k)ζ(2k)
π2k
,
(4.64)
where ζ(s) is the usual Riemann zeta-function, and
(1 −2−s)ζ(s) = 1 + 3−s + 5−s + · · ·
is sometimes called the odd zeta-function.
The Bernoulli numbers also grow rapidly, but not quite as fast as the tan-
gent numbers, because the singularities of the generating function (4.56) are
further from the origin (at ±2iπ instead of ±π/2). It is well-known that the
Riemann zeta-function for even non-negative integer arguments can be
expressed in terms of Bernoulli numbers – the relation is
(−1)k−1 B2k
(2k)! = 2ζ(2k)
(2π)2k .
(4.65)
Since ζ(2k) = 1 + O(4−k) as k →+∞, we see that
|B2k| ∼2 (2k)!
(2π)2k .
(4.66)
It is easy to see that (4.64) and (4.65) are equivalent, in view of the rela-
tion (4.62).

158
Elementary and special function evaluation
An asymptotically fast way of computing Bernoulli numbers is the topic of
Exercise 4.41. For yet another way of computing Bernoulli numbers, using
very little space, see §4.10.
4.8 Arithmetic-geometric mean
The (theoretically) fastest known methods for very large precision n use the
arithmetic-geometric mean (AGM) iteration of Gauss and Legendre. The AGM
is another non-linear recurrence, important enough to treat separately. Its com-
plexity is O(M(n) ln n); the implicit constant here can be quite large, so other
methods are better for small n.
Given (a0, b0), the AGM iteration is deﬁned by
(aj+1, bj+1) =
µaj + bj
2
,
p
ajbj
¶
.
For simplicity, we only consider real, positive starting values (a0, b0) here (for
complex starting values, see §4.8.5 and §4.12). The AGM iteration converges
quadratically to a limit that we denote by AGM(a0, b0).
The AGM is useful because:
1. It converges quadratically – eventually the number of correct digits doubles
at each iteration, so only O(log n) iterations are required.
2. Each iteration takes time O(M(n)) because the square root can be com-
puted in time O(M(n)) by Newton’s method (see §3.5 and §4.2.3).
3. If we take suitable starting values (a0, b0), the result AGM(a0, b0) can be
used to compute logarithms (directly) and other elementary functions (less
directly), as well as constants such as π and ln 2.
4.8.1 Elliptic integrals
The theory of the AGM iteration is intimately linked to the theory of elliptic
integrals. The complete elliptic integral of the ﬁrst kind is deﬁned by
K(k) =
Z π/2
0
dθ
p
1 −k2 sin2 θ
=
Z 1
0
dt
p
(1 −t2)(1 −k2t2)
,
(4.67)
and the complete elliptic integral of the second kind is
E(k) =
Z π/2
0
p
1 −k2 sin2 θ dθ =
Z 1
0
r
1 −k2t2
1 −t2
dt,

4.8 Arithmetic-geometric mean
159
where k ∈[0, 1] is called the modulus and k′ =
√
1 −k2 is the complemen-
tary modulus. It is traditional (though confusing as the prime does not denote
differentiation) to write K′(k) for K(k′) and E′(k) for E(k′).
The connection with elliptic integrals. Gauss discovered that
1
AGM(1, k) = 2
π K′(k).
(4.68)
This identity can be used to compute the elliptic integral K rapidly via the
AGM iteration. We can also use it to compute logarithms. From the deﬁni-
tion (4.67), we see that K(k) has a series expansion that converges for |k| < 1
(in fact, K(k) = (π/2)F(1/2, 1/2; 1; k2) is a hypergeometric function). For
small k, we have
K(k) = π
2
µ
1 + k2
4 + O(k4)
¶
.
(4.69)
It can also be shown that
K′(k) = 2
π ln
µ4
k
¶
K(k) −k2
4 + O(k4).
(4.70)
4.8.2 First AGM algorithm for the logarithm
From the formulæ (4.68), (4.69), and (4.70), we easily get
π/2
AGM(1, k) = ln
µ4
k
¶ ¡
1 + O(k2)
¢
.
(4.71)
Thus, if x = 4/k is large, we have
ln(x) =
π/2
AGM(1, 4/x)
µ
1 + O
µ 1
x2
¶¶
.
If x ≥2n/2, we can compute ln(x) to precision n using the AGM iteration. It
takes about 2 lg(n) iterations to converge if x ∈[2n/2, 2n].
Note that we need the constant π, which could be computed by using our
formula twice with slightly different arguments x1 and x2, then taking differ-
ences to approximate (d ln(x)/dx)/π at x1 (see Exercise 4.44). More efﬁcient
is to use the Brent–Salamin (or Gauss–Legendre) algorithm, which is based on
the AGM and the Legendre relation
EK′ + E′K −KK′ = π
2
.
(4.72)

160
Elementary and special function evaluation
Argument expansion. If x is not large enough, we can compute
ln(2ℓx) = ℓln 2 + ln x
by the AGM method (assuming the constant ln 2 is known). Alternatively, if
x > 1, we can square x enough times and compute
ln
³
x2ℓ´
= 2ℓln(x).
This method with x = 2 gives a way of computing ln 2, assuming we already
know π.
The error term. The O(k2) error term in the formula (4.71) is a nuisance. A
rigorous bound is
¯¯¯¯
π/2
AGM(1, k) −ln
µ4
k
¶¯¯¯¯ ≤4k2(8 −ln k)
(4.73)
for all k ∈(0, 1], and the bound can be sharpened to 0.37k2(2.4 −ln(k)) if
k ∈(0, 0.5].
The error O(k2| ln k|) makes it difﬁcult to accelerate convergence by using
a larger value of k (i.e. a value of x = 4/k smaller than 2n/2). There is an exact
formula which is much more elegant and avoids this problem. Before giving
this formula, we need to deﬁne some theta functions and show how they can
be used to parameterize the AGM iteration.
4.8.3 Theta functions
We need the theta functions θ2(q), θ3(q) and θ4(q), deﬁned for |q| < 1 by
θ2(q) =
+∞
X
n=−∞
q(n+1/2)2 = 2q1/4
+∞
X
n=0
qn(n+1),
(4.74)
θ3(q) =
+∞
X
n=−∞
qn2 = 1 + 2
+∞
X
n=1
qn2,
(4.75)
θ4(q) = θ3(−q) = 1 + 2
+∞
X
n=1
(−1)nqn2.
(4.76)
Note that the deﬁning power series are sparse, so it is easy to compute θ2(q)
and θ3(q) for small q. Unfortunately, the rectangular splitting method of §4.4.3
does not help to speed up the computation.
The asymptotically fastest methods to compute theta functions use the AGM.
However, we do not follow this trail, because it would lead us in circles! We
want to use theta functions to give starting values for the AGM iteration.

4.8 Arithmetic-geometric mean
161
Theta function identities. There are many classical identities involving theta
functions. Two that are of interest to us are
θ2
3(q) + θ2
4(q)
2
= θ2
3(q2)
and
θ3(q)θ4(q) = θ2
4(q2).
The latter may be written as
q
θ2
3(q)θ2
4(q) = θ2
4(q2)
to show the connection with the AGM
AGM(θ2
3(q), θ2
4(q)) = AGM(θ2
3(q2), θ2
4(q2)) = · · ·
= AGM(θ2
3(q2k), θ2
4(q2k)) = · · · = 1
for any |q| < 1. (The limit is 1 because q2k converges to 0, thus both θ3 and
θ4 converge to 1.) Apart from scaling, the AGM iteration is parameterized by
(θ2
3(q2k), θ2
4(q2k)) for k = 0, 1, 2, . . ..
The scaling factor. Since AGM(θ2
3(q), θ2
4(q)) = 1, and AGM(λa, λb) =
λ · AGM(a, b), scaling gives AGM(1, k′) = 1/θ2
3(q) if k′ = θ2
4(q)/θ2
3(q).
Equivalently, since θ4
2 + θ4
4 = θ4
3 (Jacobi), k = θ2
2(q)/θ2
3(q). However, we
know (from (4.68) with k →k′) that 1/ AGM(1, k′) = 2K(k)/π, so
K(k) = π
2 θ2
3(q).
(4.77)
Thus, the theta functions are closely related to elliptic integrals. In the literature
q is usually called the nome associated with the modulus k.
From q to k and k to q. We saw that k = θ2
2(q)/θ2
3(q), which gives k in
terms of q. There is also a nice inverse formula which gives q in terms of k:
q = exp(−πK′(k)/K(k)), or equivalently
ln
µ1
q
¶
= πK′(k)
K(k)
.
(4.78)
Sasaki and Kanada’s formula. Substituting (4.68) and (4.77) into (4.78)
with k = θ2
2(q)/θ2
3(q) gives Sasaki and Kanada’s elegant formula
ln
µ1
q
¶
=
π
AGM(θ2
2(q), θ2
3(q))
.
(4.79)
This leads to the following algorithm to compute ln x.

162
Elementary and special function evaluation
4.8.4 Second AGM algorithm for the logarithm
Suppose x is large. Let q = 1/x, compute θ2(q4) and θ3(q4) from their deﬁn-
ing series (4.74) and (4.75), then compute AGM(θ2
2(q4), θ2
3(q4)). Sasaki and
Kanada’s formula (with q replaced by q4 to avoid the q1/4 term in the deﬁnition
of θ2(q)) gives
ln(x) =
π/4
AGM(θ2
2(q4), θ2
3(q4))
.
There is a trade-off between increasing x (by squaring or multiplication by a
power of 2, see the paragraph on “Argument Expansion” in §4.8.2), and taking
longer to compute θ2(q4) and θ3(q4) from their series. In practice, it seems
good to increase x until q = 1/x is small enough that O(q36) terms are negli-
gible. Then we can use
θ2(q4) = 2
¡
q + q9 + q25 + O(q49)
¢
,
θ3(q4) = 1 + 2
¡
q4 + q16 + O(q36)
¢
.
We need x ≥2n/36, which is much better than the requirement x ≥2n/2 for
the ﬁrst AGM algorithm. We save about four AGM iterations at the cost of a
few multiplications.
Implementation notes. Since
AGM(θ2
2, θ2
3) = AGM(θ2
2 + θ2
3, 2θ2θ3)
2
,
we can avoid the ﬁrst square root in the AGM iteration. Also, it only takes two
non-scalar multiplications to compute 2θ2θ3 and θ2
2 + θ2
3 from θ2 and θ3: see
Exercise 4.45. Another speedup is possible by trading the multiplications for
squares, see §4.12.
Drawbacks of the AGM. The AGM has three drawbacks:
1. The AGM iteration is not self-correcting, so we have to work with full pre-
cision (plus any necessary guard digits) throughout. In contrast, when us-
ing Newton’s method or evaluating power series, many of the computations
can be performed with reduced precision, which saves a log n factor (this
amounts to using a negative number of guard digits).
2. The AGM with real arguments gives ln(x) directly. To obtain exp(x), we
need to apply Newton’s method (§4.2.5 and Exercise 4.6). To evaluate
trigonometric functions such as sin(x), cos(x), arctan(x), we need to work
with complex arguments, which increases the constant hidden in the “O”

4.9 Binary splitting
163
time bound. Alternatively, we can use Landen transformations for incom-
plete elliptic integrals, but this gives even larger constants.
3. Because it converges so fast, it is difﬁcult to speed up the AGM. At best we
can save O(1) iterations (see however §4.12).
4.8.5 The complex AGM
In some cases, the asymptotically fastest algorithms require the use of complex
arithmetic to produce a real result. It would be nice to avoid this because com-
plex arithmetic is signiﬁcantly slower than real arithmetic. Examples where we
seem to need complex arithmetic to get the asymptotically fastest algorithms
are:
1. arctan(x), arcsin(x), arccos(x) via the AGM, using, for example,
arctan(x) = ℑ(ln(1 + ix));
2. tan(x), sin(x), cos(x) using Newton’s method and the above, or
cos(x) + i sin(x) = exp(ix),
where the complex exponential is computed by Newton’s method from the
complex logarithm (see Eqn. (4.11)).
The theory that we outlined for the AGM iteration and AGM algorithms for
ln(z) can be extended without problems to complex z /∈(−∞, 0], provided
we always choose the square root with positive real part.
A complex multiplication takes three real multiplications (using Karatsuba’s
trick), and a complex squaring takes two real multiplications. We can do even
better in the FFT domain, assuming that one multiplication of cost M(n) is
equivalent to three Fourier transforms. In this model, a squaring costs 2M(n)/3.
A complex multiplication (a + ib)(c + id) = (ac −bd) + i(ad + bc) requires
four forward and two backward transforms, and thus costs 2M(n). A complex
squaring (a + ib)2 = (a + b)(a −b) + i(2ab) requires two forward and two
backward transforms, and thus costs 4M(n)/3. Taking this into account, we
get the asymptotic upper bounds relative to the cost of one multiplication given
in Table 4.1 (0.666 should be interpreted as ∼2M(n)/3, and so on). See §4.12
for details of the algorithms giving these constants.
4.9 Binary splitting
Since the asymptotically fastest algorithms for arctan, sin, cos, etc. have a
large constant hidden in their time bound O(M(n) log n) (see “Drawbacks of

164
Elementary and special function evaluation
Operation
real
complex
squaring
0.666
1.333
multiplication
1.000
2.000
reciprocal
1.444
3.444
division
1.666
4.777
square root
1.333
5.333
AGM iteration
2.000
6.666
log via AGM
4.000 lg n
13.333 lg n
Table 4.1 Costs in the FFT domain.
the AGM”, §4.8.4, page 162), it is interesting to look for other algorithms that
may be competitive for a large range of precisions, even if not asymptotically
optimal. One such algorithm (or class of algorithms) is based on binary split-
ting (see §4.12). The time complexity of these algorithms is usually
O((log n)αM(n))
for some constant α ≥1 depending on how fast the relevant power series
converges, and also on the multiplication algorithm (classical, Karatsuba, or
quasi-linear).
The idea. Suppose we want to compute arctan(x) for rational x = p/q,
where p and q are small integers and |x| ≤1/2. The Taylor series gives
arctan
µp
q
¶
≈
X
0≤j≤n/2
(−1)jp2j+1
(2j + 1)q2j+1 .
The ﬁnite sum, if computed exactly, gives a rational approximation P/Q to
arctan(p/q), and
log |Q| = O(n log n).
(Note: the series for exp converges faster, so in this case we sum ∼n/ ln n
terms and get log |Q| = O(n).)
The ﬁnite sum can be computed by the “divide and conquer” strategy: sum
the ﬁrst half to get P1/Q1 say, and the second half to get P2/Q2, then
P
Q = P1
Q1
+ P2
Q2
= P1Q2 + P2Q1
Q1Q2
.
The rationals P1/Q1 and P2/Q2 are computed by a recursive application of
the same method, hence the term “binary splitting”. If used with quadratic

4.9 Binary splitting
165
multiplication, this way of computing P/Q does not help; however, fast mul-
tiplication speeds up the balanced products P1Q2, P2Q1, and Q1Q2.
Complexity. The overall time complexity is
O


⌈lg(n)⌉
X
k=1
2k M(2−kn log n)

= O((log n)αM(n)),
(4.80)
where α = 2 in the FFT range; in general α ≤2 (see Exercise 4.47).
We can save a little by working to precision n rather than n log n at the top
levels; but we still have α = 2 for quasi-linear multiplication.
In practice, the multiplication algorithm would not be ﬁxed but would de-
pend on the size of the integers being multiplied. The complexity would de-
pend on the algorithm(s) used at the top levels.
Repeated application of the idea. If x ∈(0, 0.25) and we want to compute
arctan(x), we can approximate x by a rational p/q and compute arctan(p/q)
as a ﬁrst approximation to arctan(x), say p/q ≤x < (p + 1)/q. Now,
from (4.17)
tan(arctan(x) −arctan(p/q)) = x −p/q
1 + px/q
,
so
arctan(x) = arctan(p/q) + arctan(δ),
where
δ = x −p/q
1 + px/q = qx −p
q + px
.
We can apply the same idea to approximate arctan(δ). Eventually we get a
sufﬁciently accurate approximation to arctan(x). Since |δ| < |x−p/q| < 1/q,
it is easy to ensure that the process converges.
Complexity of repeated application. If we use a sequence of about lg n ra-
tionals p1/q1, p2/q2, . . ., where
qi = 22i,
then the computation of each arctan(pi/qi) takes time O((log n)αM(n)), and
the overall time to compute arctan(x) is
O((log n)α+1M(n)).

166
Elementary and special function evaluation
Indeed, we have 0 ≤pi < 22i−1; thus, pi has at most 2i−1 bits, and pi/qi
as a rational has value O(2−2i−1) and size O(2i). The exponent α + 1 is 2
or 3. Although this is not asymptotically as fast as AGM-based algorithms, the
implicit constants for binary splitting are small and the idea is useful for quite
large n (at least 106 decimal places).
Generalizations. The idea of binary splitting can be generalized. For exam-
ple, the Chudnovsky brothers gave a “bit-burst” algorithm, which applies to
fast evaluation of solutions of linear differential equations. This is described in
§4.9.2.
4.9.1 A binary splitting algorithm for sin, cos
Brent [45, Theorem 6.2] claims an O(M(n) log2 n) algorithm for exp x and
sin x; however, the proof only covers the case of the exponential and ends with
“the proof of (6.28) is similar”. He had in mind deducing sin x from a complex
computation of exp(ix) = cos x + i sin x. Algorithm SinCos is a variation
of Brent’s algorithm for exp x that computes sin x and cos x simultaneously,
in a way that avoids computations with complex numbers. The simultaneous
computation of sin x and cos x might be useful to compute tan x or a plane
rotation through the angle x.
Algorithm 4.4 SinCos
Input: ﬂoating-point 0 < x < 1/2, integer n
Output: an approximation of sin x and cos x with error O(2−n)
1: write x ≈Pk
i=0 pi · 2−2i+1 where 0 ≤pi < 22i and k = ⌈lg n⌉−1
2: let xj = Pk
i=j pi · 2−2i+1, with xk+1 = 0, and yj = pj · 2−2j+1
3: (Sk+1, Ck+1) ←(0, 1)
⊲Sj is sin xj and Cj is cos xj
4: for j from k downto 0 do
5:
compute sin yj and cos yj using binary splitting
6:
Sj ←sin yj ·Cj+1 +cos yj ·Sj+1, Cj ←cos yj ·Cj+1 −sin yj ·Sj+1
7: return (S0, C0).
At step 2 of Algorithm SinCos, we have xj = yj + xj+1; thus, sin xj =
sin yj cos xj+1 + cos yj sin xj+1, and similarly for cos xj, explaining the for-
mulæ used at step 6. Step 5 uses a binary splitting algorithm similar to the
one described above for arctan(p/q): yj is a small rational, or is small itself,
so that all needed powers do not exceed n bits in size. This algorithm has the
same complexity O(M(n) log2 n) as Brent’s algorithm for exp x.

4.9 Binary splitting
167
4.9.2 The bit-burst algorithm
The binary-splitting algorithms described above for arctan x, exp x, sin x rely
on a functional equation: tan(x + y) = (tan x + tan y)/(1 −tan x tan y),
exp(x + y) = exp(x) exp(y), sin(x + y) = sin x cos y + sin y cos x. We
describe here a more general algorithm, known as the “bit-burst” algorithm,
which does not require such a functional equation. This algorithm applies to
a class of functions known as holonomic functions. Other names are differen-
tiably ﬁnite and D-ﬁnite.
A function f(x) is said to be holonomic iff it satisﬁes a linear homogeneous
differential equation with polynomial coefﬁcients in x. Equivalently, the Taylor
coefﬁcients uk of f satisfy a linear homogeneous recurrence with coefﬁcients
polynomial in k. The set of holonomic functions is closed under the operations
of addition and multiplication, but not necessarily under division. For example,
the exp, ln, sin, cos functions are holonomic, but tan is not.
An important subclass of holonomic functions is the hypergeometric func-
tions, whose Taylor coefﬁcients satisfy a recurrence uk+1/uk = R(k), where
R(k) is a rational function of k (see §4.4). This matches the second deﬁni-
tion above, because we can write it as uk+1Q(k) −ukP(k) = 0 if R(k) =
P(k)/Q(k). Holonomic functions are much more general than hypergeometric
functions (see Exercise 4.48); in particular, the ratio of two consecutive terms
in a hypergeometric series has size O(log k) (as a rational number), but can be
much larger for holonomic functions.
Theorem 4.2 If f is holonomic and has no singularities on a ﬁnite, closed
interval [A, B], where A < 0 < B and f(0) = 0, then f(x) can be com-
puted to an (absolute) accuracy of n bits, for any n-bit ﬂoating-point number
x ∈(A, B), in time O(M(n) log3 n).
NOTES: For a sharper result, see Exercise 4.49. The condition f(0) = 0 is just
a technical condition to simplify the proof of the theorem; f(0) can be any
value that can be computed to n bits in time O(M(n) log3 n).
Proof. Without loss of generality, we assume 0 ≤x < 1 < B; the binary
expansion of x can then be written x = 0.b1b2 . . . bn. Deﬁne r1 = 0.b1,
r2 = 0.0b2b3, r3 = 0.000b4b5b6b7 (the same decomposition was already used
in Algorithm SinCos): r1 consists of the ﬁrst bit of the binary expansion of x,
r2 consists of the next two bits, r3 the next four bits, and so on. Thus, we have
x = r1 + r2 + . . . + rk, where 2k−1 ≤n < 2k.
Deﬁne xi = r1 + · · · + ri with x0 = 0. The idea of the algorithm is to
translate the Taylor series of f from xi to xi+1; since f is holonomic, this
reduces to translating the recurrence on the corresponding coefﬁcients. The

168
Elementary and special function evaluation
condition that f has no singularity in [0, x] ⊂[A, B] ensures that the translated
recurrence is well-deﬁned. We deﬁne f0(t) = f(t), f1(t) = f0(r1+t), f2(t) =
f1(r2 + t), . . . , fi(t) = fi−1(ri + t) for i ≤k. We have fi(t) = f(xi + t),
and fk(t) = f(x + t) since xk = x. Thus, we are looking for fk(0) = f(x).
Let f ∗
i (t) = fi(t) −fi(0) be the non-constant part of the Taylor expansion
of fi. We have f ∗
i (ri+1) = fi(ri+1) −fi(0) = fi+1(0) −fi(0) because
fi+1(t) = fi(ri+1 + t). Thus
f ∗
0 (r1) + · · · + f ∗
k−1(rk) = (f1(0) −f0(0)) + · · · + (fk(0) −fk−1(0))
= fk(0) −f0(0) = f(x) −f(0).
Since f(0) = 0, this gives
f(x) =
k−1
X
i=0
f ∗
i (ri+1).
To conclude the proof, we will show that each term f ∗
i (ri+1) can be evalu-
ated to n bits in time O(M(n) log2 n). The rational ri+1 has a numerator of at
most 2i bits, and
0 ≤ri+1 < 21−2i.
Thus, to evaluate f ∗
i (ri+1) to n bits, n/2i + O(log n) terms of the Taylor
expansion of f ∗
i (t) are enough. We now use the fact that f is holonomic.
Assume f satisﬁes the following homogeneous linear11 differential equation
with polynomial coefﬁcients
cm(t)f (m)(t) + · · · + c1(t)f ′(t) + c0(t)f(t) = 0.
Substituting xi + t for t, we obtain a differential equation for fi
cm(xi + t)f (m)
i
(t) + · · · + c1(xi + t)f ′
i(t) + c0(xi + t)fi(t) = 0.
From this equation, we deduce (see §4.12) a linear recurrence for the Taylor
coefﬁcients of fi(t), of the same order as that for f(t). The coefﬁcients in the
recurrence for fi(t) have O(2i) bits, since xi = r1 + · · · + ri has O(2i) bits.
It follows that the ℓth Taylor coefﬁcient of fi(t) has size O(ℓ(2i + log ℓ)).
The ℓlog ℓterm comes from the polynomials in ℓin the recurrence. Since
ℓ≤n/2i + O(log n), this is O(n log n).
However, we do not want to evaluate the ℓth Taylor coefﬁcient uℓof fi(t),
11 If f satisﬁes a non-homogeneous differential equation, say
E(t, f(t), f′(t), . . . , f(k)(t)) = b(t), where b(t) is polynomial in t, differentiating it yields
F(t, f(t), f′(t), . . . , f(k+1)(t)) = b′(t), and b′(t)E(·) −b(t)F(·) is homogeneous.

4.10 Contour integration
169
but the series
sℓ=
ℓ
X
j=1
ujrj
i+1 ≈f ∗
i (ri+1).
Noting that uℓ= (sℓ−sℓ−1)/rℓ
i+1, and substituting this value in the recurrence
for (uℓ), say of order d, we obtain a recurrence of order d + 1 for (sℓ). Putting
this latter recurrence in matrix form Sℓ= MℓSℓ−1, where Sℓis the vector
(sℓ, sℓ−1, . . . , sℓ−d), we obtain
Sℓ= MℓMℓ−1 · · · Md+1Sd,
(4.81)
where the matrix product MℓMℓ−1 · · · Md+1 can be evaluated in time
O(M(n) log2 n) using binary splitting.
We illustrate Theorem 4.2 with the arc-tangent function, which satisﬁes the
differential equation f ′(t)(1 + t2) = 1. This equation evaluates at xi + t to
f ′
i(t)(1 + (xi + t)2) = 1, where fi(t) = f(xi + t). This gives the recurrence
(1 + x2
i )ℓuℓ+ 2xi(ℓ−1)uℓ−1 + (ℓ−2)uℓ−2 = 0
for the Taylor coefﬁcients uℓof fi. This recurrence translates to
(1 + x2
i )ℓvℓ+ 2xiri+1(ℓ−1)vℓ−1 + r2
i+1(ℓ−2)vℓ−2 = 0
for vℓ= uℓrℓ
i+1, and to
(1 + x2
i )ℓ(sℓ−sℓ−1)
+ 2xiri+1(ℓ−1)(sℓ−1 −sℓ−2) + r2
i+1(ℓ−2)(sℓ−2 −sℓ−3) = 0
for sℓ= Pℓ
j=1 vj. This recurrence of order 3 can be written in matrix form,
and Eqn. (4.81) enables us to efﬁciently compute sℓ≈fi(ri +1)−fi(0) using
multiplication of 3 × 3 matrices and fast integer multiplication.
4.10 Contour integration
In this section, we assume that facilities for arbitrary-precision complex arith-
metic are available. These can be built on top of an arbitrary-precision real
arithmetic package (see Chapters 3 and 5).
Let f(z) be holomorphic in the disc |z| < R, R > 1, and let the power
series for f be
f(z) =
∞
X
j=0
aj zj.
(4.82)

170
Elementary and special function evaluation
From Cauchy’s theorem [122, Ch. 7], we have
aj =
1
2πi
Z
C
f(z)
zj+1 dz,
(4.83)
where C is the unit circle. The contour integral in (4.83) may be approximated
numerically by sums
Sj,k = 1
k
k−1
X
m=0
f(e2πim/k)e−2πijm/k.
(4.84)
Let C′ be a circle with centre at the origin and radius ρ ∈(1, R). From
Cauchy’s theorem, assuming that j < k, we have (see Exercise 4.50)
Sj,k −aj =
1
2πi
Z
C′
f(z)
(zk −1)zj+1 dz = aj+k + aj+2k + · · · ,
(4.85)
so |Sj,k −aj| = O((R −δ)−(j+k)) as k →∞, for any δ > 0. For example,
let
f(z) =
z
ez −1 + z
2
(4.86)
be the generating function for the scaled Bernoulli numbers as in (4.57), so
a2j = Cj = B2j/(2j)! and R = 2π (because of the poles at ±2πi). Then
S2j,k −B2j
(2j)! =
B2j+k
(2j + k)! +
B2j+2k
(2j + 2k)! + · · · ,
(4.87)
so we can evaluate B2j with relative error O((2π)−k) by evaluating f(z) at k
points on the unit circle.
There is some cancellation when using (4.84) to evaluate S2j,k because the
terms in the sum are of order unity but the result is of order (2π)−2j. Thus,
O(j) guard digits are needed. In the following, we assume j = O(n).
If exp(−2πijm/k) is computed efﬁciently from exp(−2πi/k) in the obvi-
ous way, the time required to evaluate B2, . . . , B2j to precision n is
O(jnM(n)), and the space required is O(n). We assume here that we need
all Bernoulli numbers up to index 2j, but we do not need to store all of them
simultaneously. This is the case if we are using the Bernoulli numbers as coef-
ﬁcients in a sum such as (4.38).
The recurrence relation method of §4.7.2 is faster but requires space Θ(jn).
Thus, the method of contour integration has advantages if space is critical.
For comments on other forms of numerical quadrature, see §4.12.

4.11 Exercises
171
4.11 Exercises
Exercise 4.1 If A(x) = P
j≥0 ajxj is a formal power series over R with
a0 = 1, show that ln(A(x)) can be computed with error O(xn) in time
O(M(n)), where M(n) is the time required to multiply two polynomials of
degree n −1. Assume a reasonable smoothness condition on the growth of
M(n) as a function of n. [Hint: (d/dx) ln(A(x)) = A′(x)/A(x).] Does a
similar result hold for n-bit numbers if x is replaced by 1/2?
Exercise 4.2 (Sch¨onhage [197] and Schost) Assume we want to compute
1/s(x) mod xn, for s(x) a power series. Design an algorithm using an odd–
even scheme (§1.3.5), and estimate its complexity in the FFT range.
Exercise 4.3 Suppose that g and h are sufﬁciently smooth functions satisfying
g(h(x)) = x on some interval. Let yj = h(xj). Show that the iteration
xj+1 = xj +
k−1
X
m=1
(y −yj)m g(m)(yj)
m!
is a kth-order iteration that (under suitable conditions) will converge to x =
g(y). [Hint: generalize the argument leading to (4.16).]
Exercise 4.4 Design a Horner-like algorithm for evaluating a series Pk
j=0 ajxj
in the forward direction, while deciding dynamically where to stop. For the
stopping criterion, assume that the |aj| are monotonic decreasing and that
|x| < 1/2. [Hint: use y = 1/x.]
Exercise 4.5 Assume we want n bits of exp x for x of order 2j, with the
repeated use of the doubling formula (§4.3.1), and the naive method to evaluate
power series. What is the best reduced argument x/2k in terms of n and j?
[Consider both cases j ≥0 and j < 0.]
Exercise 4.6 Assuming we can compute an n-bit approximation to ln x in
time T(n), where n ≪M(n) = o(T(n)), show how to compute an n-bit
approximation to exp x in time ∼T(n). Assume that T(n) and M(n) satisfy
reasonable smoothness conditions.
Exercise 4.7 Care has to be taken to use enough guard digits when computing
exp(x) by argument reduction followed by the power series (4.21). If x is of
order unity and k steps of argument reduction are used to compute exp(x) via
exp(x) =
¡
exp(x/2k)
¢2k
,
show that about k bits of precision will be lost (so it is necessary to use about
k guard bits).

172
Elementary and special function evaluation
Exercise 4.8 Show that the problem analysed in Exercise 4.7 can be avoided
if we work with the function
expm1(x) = exp(x) −1 =
∞
X
j=1
xj
j!
,
which satisﬁes the doubling formula expm1(2x) = expm1(x)(2+expm1(x)).
Exercise 4.9 For x > −1, prove the reduction formula
log1p(x) = 2 log1p
µ
x
1 + √1 + x
¶
,
where the function log1p(x) is deﬁned by log1p(x) = ln(1 + x), as in §4.4.2.
Explain why it might be desirable to work with log1p instead of ln in order
to avoid loss of precision (in the argument reduction, rather than in the recon-
struction as in Exercise 4.7). Note however that argument reduction for log1p
is more expensive than that for expm1, because of the square root.
Exercise 4.10 Give a numerically stable way of computing sinh(x) using one
evaluation of expm1(|x|) and a small number of additional operations (com-
pare Eqn. (4.20)).
Exercise 4.11 (White) Show that exp(x) can be computed via sinh(x) using
the formula
exp(x) = sinh(x) +
q
1 + sinh2(x).
Since
sinh(x) = ex −e−x
2
=
X
k≥0
x2k+1
(2k + 1)!
,
this saves computing about half the terms in the power series for exp(x) at the
expense of one square root. How can we modify this method to preserve nu-
merical stability for negative arguments x? Can this idea be used for functions
other than exp(x)?
Exercise 4.12 Count precisely the number of non-scalar products necessary
for the two variants of rectangular series splitting (§4.4.3).
Exercise 4.13 A drawback of rectangular series splitting as presented in §4.4.3
is that the coefﬁcients (akℓ+m in the classical splitting, or ajm+ℓin the modular
splitting) involved in the scalar multiplications might become large.
Indeed, they are typically a product of factorials, and thus have size
O(d log d). Assuming that the ratios ai+1/ai are small rationals, propose an
alternate way of evaluating P(x).

4.11 Exercises
173
Exercise 4.14 Make explicit the cost of the slowly growing function c(d)
(§4.4.3).
Exercise 4.15 Prove the remainder term (4.28) in the expansion (4.27) for
E1(x). [Hint: prove the result by induction on k, using integration by parts
in the formula (4.28).]
Exercise 4.16 Show that we can avoid using Cauchy principal value integrals
by deﬁning Ei(z) and E1(z) in terms of the entire function
Ein(z) =
Z z
0
1 −exp(−t)
t
dt =
∞
X
j=1
(−1)j−1zj
j! j
.
Exercise 4.17 Let E1(x) be deﬁned by (4.25) for real x > 0. Using (4.27),
show that
1
x −1
x2 < ex E1(x) < 1
x
.
Exercise 4.18 In this exercise, the series are purely formal, so ignore any ques-
tions of convergence. Applications are given in Exercises 4.19–4.20.
Suppose that (aj)j∈N is a sequence with exponential generating function
s(z) = P∞
j=0 ajzj/j!. Suppose that An = Pn
j=0
¡n
j
¢
aj, and let S(z) =
P∞
j=0 Ajzj/j! be the exponential generating function of the sequence (An)n∈N.
Show that
S(z) = exp(z)s(z).
Exercise 4.19 The power series for Ein(z) given in Exercise 4.16 suffers from
catastrophic cancellation when z is large and positive (like the series for
exp(−z)). Use Exercise 4.18 to show that this problem can be avoided by
using the power series (where Hn denotes the nth harmonic number)
ez Ein(z) =
∞
X
j=1
Hjzj
j!
.
Exercise 4.20 Show that Eqn. (4.23) for erf(x) follows from Eqn. (4.22).
[Hint: this is similar to Exercise 4.19.]
Exercise 4.21 Give an algorithm to evaluate Γ(x) for real x ≥1/2, with guar-
anteed relative error O(2−n). Use the method sketched in §4.5 for ln Γ(x).
What can be said about the complexity of the algorithm?

174
Elementary and special function evaluation
Exercise 4.22 Extend your solution to Exercise 4.21 to give an algorithm to
evaluate 1/Γ(z) for z ∈C, with guaranteed relative error O(2−n). Note: Γ(z)
has poles at zero and the negative integers (i.e. for −z ∈N), but we over-
come this difﬁculty by computing the entire function 1/Γ(z). Warning: |Γ(z)|
can be very small if ℑ(z) is large. This follows from Stirling’s asymptotic
expansion. In the particular case of z = iy on the imaginary axis, we have
2 ln |Γ(iy)| = ln
µ
π
y sinh(πy)
¶
≈−π|y|.
More generally
|Γ(x + iy)|2 ≈2π|y|2x−1 exp(−π|y|)
for x, y ∈R and |y| large.
Exercise 4.23 The usual form (4.38) of Stirling’s approximation for ln(Γ(z))
involves a divergent series. It is possible to give a version of Stirling’s approx-
imation where the series is convergent
ln Γ(z) =
µ
z −1
2
¶
ln z −z + ln(2π)
2
+
∞
X
k=1
ck
(z + 1)(z + 2) · · · (z + k)
,
(4.88)
where the constants ck can be expressed in terms of Stirling numbers of the
ﬁrst kind, s(n, k), deﬁned by the generating function
n
X
k=0
s(n, k)xk = x(x −1) · · · (x −n + 1).
In fact
ck = 1
2k
k
X
j=1
j|s(n, j)|
(j + 1)(j + 2)
.
The Stirling numbers s(n, k) can be computed easily from a three-term recur-
rence, so this gives a feasible alternative to the usual form of Stirling’s approx-
imation with coefﬁcients related to Bernoulli numbers.
Show, experimentally and/or theoretically, that the convergent form of Stir-
ling’s approximation is not an improvement over the usual form as used in
Exercise 4.21.
Exercise 4.24 Implement procedures to evaluate E1(x) to high precision for
real positive x, using (a) the power series (4.26), (b) the asymptotic expan-
sion (4.27) (if sufﬁciently accurate), (c) the method of Exercise 4.19, and (d)
the continued fraction (4.39) using the backward and forward recurrences as

4.11 Exercises
175
suggested in §4.6. Determine empirically the regions where each method is the
fastest.
Exercise 4.25 Prove the backward recurrence (4.43).
Exercise 4.26 Prove the forward recurrence (4.44).
[Hint: let
yk(x) = a1
b1+ · · · ak−1
bk−1+
ak
bk + x
.
Show, by induction on k ≥1, that
yk(x) = Pk + Pk−1x
Qk + Qk−1x
. ]
Exercise 4.27 For the forward recurrence (4.44), show that
µ Qk
Qk−1
Pk
Pk−1
¶
=
µ b1
1
a1
0
¶ µ b2
1
a2
0
¶
· · ·
µ bk
1
ak
0
¶
holds for k > 0 (and for k = 0 if we deﬁne P−1, Q−1 appropriately).
Remark. This gives a way to use parallelism when evaluating continued frac-
tions.
Exercise 4.28 For the forward recurrence (4.44), show that
¯¯¯¯
Qk
Qk−1
Pk
Pk−1
¯¯¯¯ = (−1)ka1a2 · · · ak.
Exercise 4.29 Prove the identity (4.46).
Exercise 4.30 Prove Theorem 4.1.
Exercise 4.31 Investigate using the continued fraction (4.40) for evaluating
the complementary error function erfc(x) or the error function erf(x) = 1 −
erfc(x). Is there a region where the continued fraction is preferable to any of
the methods used in Algorithm Erf of §4.6?
Exercise 4.32 Show that the continued fraction (4.41) can be evaluated in time
O(M(k) log k) if the aj and bj are bounded integers (or rational numbers with
bounded numerators and denominators). [Hint: use Exercise 4.27.]
Exercise 4.33 Instead of (4.54), a different normalization condition
J0(x)2 + 2
∞
X
ν=1
Jν(x)2 = 1
(4.89)
could be used in Miller’s algorithm. Which of these normalization conditions
is preferable?

176
Elementary and special function evaluation
Exercise 4.34 Consider the recurrence fν−1 + fν+1 = 2Kfν, where K > 0
is a ﬁxed real constant. We can expect the solution to this recurrence to give
some insight into the behavior of the recurrence (4.53) in the region ν ≈Kx.
Assume for simplicity that K ̸= 1. Show that the general solution has the form
fν = Aλν + Bµν,
where λ and µ are the roots of the quadratic equation x2 −2Kx + 1 = 0, and
A and B are constants determined by the initial conditions. Show that there are
two cases: if K < 1, then λ and µ are complex conjugates on the unit circle,
so |λ| = |µ| = 1; if K > 1, then there are two real roots satisfying λµ = 1.
Exercise 4.35 Prove (or give a plausibility argument for) the statements made
in §4.7 that: (a) if a recurrence based on (4.59) is used to evaluate the scaled
Bernoulli number Ck, using precision n arithmetic, then the relative error is of
order 4k2−n; and (b) if a recurrence based on (4.60) is used, then the relative
error is O(k22−n).
Exercise 4.36 Starting from the deﬁnition (4.56), prove Eqn. (4.57). Deduce
the relation (4.62) connecting tangent numbers and Bernoulli numbers.
Exercise 4.37 (a) Show that the number of bits required to represent the tan-
gent number Tk exactly is ∼2k lg k as k →∞. (b) Show that the same applies
for the exact representation of the Bernoulli number B2k as a rational number.
Exercise 4.38 Explain how the correctness of Algorithm TangentNumbers
(§4.7.2) follows from the recurrence (4.63).
Algorithm 4.5 SecantNumbers
Input: positive integer m
Output: Secant numbers S0, S1, . . . , Sm
S0 ←1
for k from 1 to m do
Sk ←kSk−1
for k from 1 to m do
for j from k + 1 to m do
Sj ←(j −k)Sj−1 + (j −k + 1)Sj
return S0, S1, . . . , Sm.
Exercise 4.39 Show that the complexity of computing the tangent numbers
T1, . . . , Tm by Algorithm TangentNumbers (§4.7.2) is O(m3 log m). Assume

4.11 Exercises
177
that the multiplications of tangent numbers Tj by small integers take time
O(log Tj). [Hint: use the result of Exercise 4.37.]
Exercise 4.40 Verify that Algorithm SecantNumbers computes in-place the
Secant numbers Sk, deﬁned by the generating function
X
k≥0
Sk
x2k
(2k)! = sec x =
1
cos x
,
in much the same way that Algorithm TangentNumbers (§4.7.2) computes
the Tangent numbers.
Exercise 4.41 (Harvey) The generating function (4.56) for Bernoulli num-
bers can be written as
X
k≥0
Bk
xk
k! = 1
,X
k≥0
xk
(k + 1)!
,
and we can use an asymptotically fast algorithm to compute the ﬁrst n + 1
terms in the reciprocal of the power series. This should be asymptotically faster
than using the recurrences given in §4.7.2. Give an algorithm using this idea
to compute the Bernoulli numbers B0, B1, . . . , Bn in time O(n2(log n)2+ε).
Implement your algorithm and see how large n needs to be for it to be faster
than the algorithms discussed in §4.7.2.
Algorithm 4.6 SeriesExponential
Input: positive integer m and real numbers a1, a2, . . . , am
Output: real numbers b0, b1, . . . , bm such that
b0 + b1x + · · · + bmxm = exp(a1x + · · · + amxm) + O(xm+1)
b0 ←1
for k from 1 to m do
bk ←
³Pk
j=1 jajbk−j
´ ±
k
return b0, b1, . . . , bm.
Exercise 4.42 (a) Show that Algorithm SeriesExponential computes B(x) =
exp(A(x)) up to terms of order xm+1, where A(x) = a1x+a2x2+· · ·+amxm
is input data and B(x) = b0 + b1x + · · · + bmxm is the output. [Hint: compare
Exercise 4.1.]

178
Elementary and special function evaluation
(b) Apply this to give an algorithm to compute the coefﬁcients bk in
Stirling’s approximation for n! (or Γ(n + 1)):
n! ∼
³n
e
´ √
2πn
X
k≥0
bk
nk .
[Hint: we know the coefﬁcients in Stirling’s approximation (4.38) for ln Γ(z)
in terms of Bernoulli numbers.]
(c) Is this likely to be useful for high-precision computation of Γ(x) for real
positive x?
Exercise 4.43 Deduce from Eqn. (4.69) and (4.70) an expansion of ln(4/k)
with error term O(k4 log(4/k)). Use any means to ﬁgure out an effective
bound on the O() term. Deduce an algorithm requiring only x ≥2n/4 to get n
bits of ln x.
Exercise 4.44 Show how both π and ln 2 can be evaluated using Eqn. (4.71).
Exercise 4.45 In §4.8.4, we mentioned that 2θ2θ3 and θ2
2 + θ2
3 can be com-
puted using two non-scalar multiplications. For example, we could (A) com-
pute u = (θ2 + θ3)2 and v = θ2θ3; then the desired values are 2v and u −2v.
Alternatively, we could (B) compute u and w = (θ2 −θ3)2; then the desired
values are (u ± w)/2. Which method (A) or (B) is preferable?
Exercise 4.46 Improve the constants in Table 4.1.
Exercise 4.47 Justify Eqn. (4.80) and give an upper bound on the constant α
if the multiplication algorithm satisﬁes M(n) = Θ(nc) for some c ∈(1, 2].
Exercise 4.48 (Salvy) Is the function exp(x2) + x/(1 −x2) holonomic?
Exercise 4.49 (van der Hoeven, Mezzarobba) Improve to O(M(n) log2 n)
the complexity given in Theorem 4.2.
Exercise 4.50 If w = e2πi/k, show that
1
zk −1 = 1
k
k−1
X
m=0
wm
z −wm .
Deduce that Sj,k, deﬁned by Eqn. (4.84), satisﬁes
Sj,k =
1
2πi
Z
C′
zk−j−1
zk −1 f(z) dz
for j < k, where the contour C′ is as in §4.10. Deduce Eqn. (4.85).

4.12 Notes and references
179
Remark. Eqn. (4.85) illustrates the phenomenon of aliasing: observations at
k points can not distinguish between the Fourier coefﬁcients aj, aj+k, aj+2k,
etc.
Exercise 4.51 Show that the sum S2j,k of §4.10 can be computed with (essen-
tially) only about k/4 evaluations of f if k is even. Similarly, show that about
k/2 evaluations of f sufﬁce if k is odd. On the other hand, show that the error
bound O((2π)−k) following Eqn. (4.87) can be improved if k is odd.
4.12 Notes and references
One of the main references for special functions is the “Handbook of Mathe-
matical Functions” by Abramowitz and Stegun [1], which gives many useful
results but no proofs. A more recent book is that of Nico Temme [214], and
a comprehensive reference is Andrews et al. [4]. A large part of the content
of this chapter comes from Brent [48], and was implemented in the MP pack-
age Brent [47]. In the context of ﬂoating-point computations, the “Handbook
of Floating-Point Arithmetic” by Brisebarre et al. [58] is a useful reference,
especially Chapter 11.
The SRT algorithm for division is named after Sweeney, Robertson [189]
and Tocher [216]. Original papers on Booth recoding, SRT division, etc., are
reprinted in the book by Swartzlander [212]. SRT division is similar to non-
restoring division, but uses a lookup table based on the dividend and the divisor
to determine each quotient digit. The Intel Pentium fdiv bug was caused by
an incorrectly initialized lookup table.
Basic material on Newton’s method may be found in many references, for
example the books by Brent [41, Ch. 3], Householder [126] or Traub [218].
Some details on the use of Newton’s method in modern processors can be
found in Intel [128]. The idea of ﬁrst computing y−1/2, then multiplying by
y to get y1/2 (§4.2.3) was pushed further by Karp and Markstein [137], who
perform this at the penultimate iteration, and modify the last iteration of New-
ton’s method for y−1/2 to get y1/2 directly (see §1.4.5 for an example of the
Karp–Markstein trick for division). For more on Newton’s method for power
series, we refer to [43, 52, 56, 142, 150, 202].
Some good references on error analysis of ﬂoating-point algorithms are the
books by Higham [121] and Muller [174]. Older references include Wilkin-
son’s classics [228, 229].
Regarding doubling versus tripling: in §4.3.4, we assumed that one multi-
plication and one squaring were required to apply the tripling formula (4.19).

180
Elementary and special function evaluation
However, we might use the form sinh(3x) = 3 sinh(x)+4 sinh3(x), which re-
quires only one cubing. Assuming a cubing costs 50% more than a squaring –
in the FFT range – the ratio would be 1.5 log3 2 ≈0.946. Thus, if a special-
ized cubing routine is available, tripling may sometimes be slightly faster than
doubling.
For an example of a detailed error analysis of an unrestricted algorithm, see
Clenshaw and Olver [69].
The idea of rectangular series splitting to evaluate a power series with O(√n)
non-scalar multiplications (§4.4.3) was ﬁrst published in 1973 by Paterson and
Stockmeyer [182]. It was rediscovered in the context of multiple-precision
evaluation of elementary functions by Smith [204, §8.7] in 1991. Smith gave it
the name “concurrent series”. Smith proposed modular splitting of the series,
but classical splitting seems slightly better. Smith noticed that the simultaneous
use of this fast technique and argument reduction yields O(n1/3M(n)) algo-
rithms. Earlier, in 1960, Estrin [92] had found a similar technique with n/2
non-scalar multiplications, but O(log n) parallel complexity.
There are several variants of the Euler–Maclaurin sum formula, with and
without bounds on the remainder. See Abramowitz and Stegun [1, Ch. 23],
and Apostol [6], for example.
Most of the asymptotic expansions that we have given in §4.5 may be found
in Abramowitz and Stegun [1]. For more background on asymptotic expan-
sions of special functions, see for example the books by de Bruijn [84],
Olver [180] and Wong [231]. We have omitted mention of many other useful
asymptotic expansions, for example all but a few of those for Bessel functions,
for which see Olver [180], Watson [225], Whittaker and Watson [227].
Most of the continued fractions mentioned in §4.6 may be found in Abram-
owitz and Stegun [1]. The classical theory is given in the books by
Khinchin [139] and Wall [224]. Continued fractions are used in the manner
described in §4.6 in arbitrary-precision packages such as Brent’s MP [47]. A
good recent reference on various aspects of continued fractions for the evalu-
ation of special functions is the Handbook of Continued Fractions for Special
Functions by Cuyt et al. [83]. In particular, Chapter 7 contains a discussion
of error bounds. Our Theorem 4.1 is a trivial modiﬁcation of Cuyt et al. [83,
Theorem 7.5.1]. The asymptotically fast algorithm suggested in Exercise 4.32
was given by Sch¨onhage [195].
A proof of a generalization of (4.54) is given in [4, §4.9]. Miller’s algorithm
is due to J. C. P. Miller. It is described, for example, in [1, §9.12, §19.28] and
Clenshaw et al. [68, §13.14]. An algorithm is given in Gautschi [102].
A recurrence based on (4.60) was used to evaluate the scaled Bernoulli
numbers Ck in the MP package following a suggestion of Reinsch [48, §12].

4.12 Notes and references
181
Previously, the inferior recurrence (4.59) was widely used, for example in
Knuth [140] and in early versions of Brent’s MP package [47, §6.11]. The idea
of using tangent numbers is mentioned in [107, §6.5], where it is attributed to
B. F. Logan. Our in-place Algorithms TangentNumbers and SecantNumbers
may be new (see Exercises 4.38–4.40). Kaneko [135] describes an algorithm
of Akiyama and Tanigawa for computing Bernoulli numbers in a manner simi-
lar to “Pascal’s triangle”. However, it requires more arithmetic operations than
Algorithm TangentNumbers. Also, the Akiyama–Tanigawa algorithm is only
recommended for exact rational arithmetic, since it is numerically unstable if
implemented in ﬂoating-point arithmetic. For more on Bernoulli, tangent and
secant numbers, and a connection with Stirling numbers, see Chen [62] and
Sloane [203, A027641, A000182, A000364].
The Von Staudt–Clausen theorem was proved independently by Karl von
Staudt and Thomas Clausen in 1840. It can be found in many references. If just
a single Bernoulli number of large index is required, then Harvey’s modular
algorithm [117] can be recommended.
Some references on the Arithmetic-Geometric Mean (AGM) are Brent [43,
46, 51], Salamin [192], the Borweins’ book [36], Arndt and Haenel [7]. An
early reference, which includes some results that were rediscovered later, is
the fascinating report HAKMEM by Beeler, Gosper and Schroeppel [15]. Bern-
stein [19] gives a survey of different AGM algorithms for computing the log-
arithm. Eqn. (4.70) is given in Borwein and Borwein [36, (1.3.10)], and the
bound (4.73) is given in [36, p. 11, Exercise 4(c)]. The AGM can be extended
to complex starting values provided we take the correct branch of the square
root (the one with positive real part): see Borwein and Borwein [36, pp. 15–16].
The use of the complex AGM is discussed in [88]. For theta function identities,
see [36, Chapter 2], and for a proof of (4.78), see [36, §2.3].
The use of the exact formula (4.79) to compute ln x was ﬁrst suggested by
Sasaki and Kanada (see [36, (7.2.5)], but beware the typo). See Brent [46] for
Landen transformations, and Brent [43] for more efﬁcient methods; note that
the constants given in those papers might be improved using faster square root
algorithms (Chapter 3).
The constants in Table 4.1 are justiﬁed as follows. We assume we are in
the FFT domain, and one Fourier transform costs M(n)/3. The 13M(n)/9 ≈
1.444M(n) cost for a real reciprocal is from Harvey [116], and assumes
M(n) ∼3T(2n), where T(n) is the time to perform a Fourier transform of
size n. For the complex reciprocal 1/(v+iw) = (v−iw)/(v2 +w2), we com-
pute v2+w2 using two forward transforms and one backward transform, equiv-
alent in cost to M(n), then one real reciprocal to obtain say x = 1/(v2 + w2),
then two real multiplications to compute vx, wx, but take advantage of the

182
Elementary and special function evaluation
fact that we already know the forward transforms of v and w, and the trans-
form of x only needs to be computed once, so these two multiplications cost
only M(n). Thus, the total cost is 31M(n)/9 ≈3.444M(n). The 1.666M(n)
cost for real division is from van der Hoeven [125, Remark 6], and assumes
M(n) ∼3T(2n) as above for the real reciprocal. For complex division, say
(t+iu)/(v+iw), we ﬁrst compute the complex reciprocal x+iy = 1/(v+iw),
then perform a complex multiplication (t + iu)(x + iy), but save the cost
of two transforms by observing that the transforms of x and y are known
as a byproduct of the complex reciprocal algorithm. Thus, the total cost is
(31/9+4/3)M(n) ≈4.777M(n). The 4M(n)/3 cost for the real square root
is from Harvey [116], and assumes M(n) ∼3T(2n) as above. The complex
square root uses Friedland’s algorithm [97]: √x + iy = w + iy/(2w), where
w =
p
(|x| + (x2 + y2)1/2)/2; as for the complex reciprocal, x2 + y2 costs
M(n), then we compute its square root in 4M(n)/3, the second square root
in 4M(n)/3, and the division y/w costs 1.666M(n), which gives a total of
5.333M(n).
The cost of one real AGM iteration is at most the sum of the multiplica-
tion cost and of the square root cost, but since we typically perform several
iterations, it is reasonable to assume that the input and output of the iteration
includes the transforms of the operands. The transform of a + b is obtained by
linearity from the transforms of a and b, so is essentially free. Thus, we save
one transform or M(n)/3 per iteration, giving a cost per iteration of 2M(n).
(Another way to save M(n)/3 is to trade the multiplication for a squaring,
as explained in Sch¨onhage, Grotefeld, and Vetter [198, §8.2.5].) The complex
AGM is analogous: it costs the same as a complex multiplication (2M(n)) and
a complex square root (5.333M(n)), but we can save two (real) transforms per
iteration (2M(n)/3), giving a net cost of 6.666M(n). Finally, the logarithm
via the AGM costs 2 lg(n) + O(1) AGM iterations.
We note that some of the constants in Table 4.1 may not be optimal. For
example, it may be possible to reduce the cost of reciprocal or square root
(Harvey, Sergeev). We leave this as a challenge to the reader (see Exercise 4.46).
Note that the constants for operations on power series may differ from the cor-
responding constants for operations on integers/reals.
The idea of binary splitting is quite old, since in 1976 Brent [45, Th. 6.2]
gave a binary splitting algorithm to compute exp x in time O(M(n)(log n)2).
See also Borwein and Borwein [36, page 335]. The CLN library implements
several functions with binary splitting, see Haible and Papanikolaou [108], and
is quite efﬁcient for precisions of a million bits or more.
The “bit-burst” algorithm was invented by David and Gregory Chud-
novsky [65], and our Theorem 4.2 is based on their work. Some references

4.12 Notes and references
183
on holonomic functions are J. Bernstein [25, 26], van der Hoeven, [123] and
Zeilberger [233]. See also the Maple GFUN package [193], which allows one,
amongst other things, to deduce the recurrence for the Taylor coefﬁcients of
f(x) from its differential equation.
There are several topics that are not covered in this chapter, but might have
been if we had more time and space. We mention some references here. A
useful resource is the website [143].
The Riemann zeta-function ζ(s) can be evaluated by the Euler–Maclaurin
expansion (4.34)–(4.36), or by Borwein’s algorithm [38, 39], but neither of
these methods is efﬁcient if ℑ(s) is large. On the critical line ℜ(s) = 1/2, the
Riemann–Siegel formula [99] is much faster and in practice sufﬁciently accu-
rate, although only an asymptotic expansion. If enough terms are taken, the
error seems to be O(exp(−πt)), where t = ℑ(s): see Brent’s review [82] and
Berry’s paper [28]. An error analysis is given in [184]. The Riemann–Siegel
coefﬁcients may be deﬁned by a recurrence in terms of certain integers ρn that
can be deﬁned using Euler numbers (see Sloane’s sequence A087617 [203]).
Sloane calls this the Gabcke sequence but Gabcke credits Lehmer [155] so
perhaps it should be called the Lehmer–Gabcke sequence. The sequence (ρn)
occurs naturally in the asymptotic expansion of ln(Γ(1/4 + it/2)). The (not
obvious) fact that the ρn are integers was proved by de Reyna [85].
Borwein’s algorithm for ζ(s) can be generalized to cover functions such as
the polylogarithm and the Hurwitz zeta-function: see Vep˘stas [223].
To evaluate the Riemann zeta-function ζ(σ + it) for ﬁxed σ and many
equally spaced points t, the fastest known algorithm is due to Odlyzko and
Sch¨onhage [179]. It has been used by Odlyzko to compute blocks of zeros with
very large height t, see [177, 178]; also (with improvements) by Gourdon to
verify the Riemann Hypothesis for the ﬁrst 1013 non-trivial zeros in the upper
half-plane, see [105]. The Odlyzko–Sch¨onhage algorithm can be generalized
for the computation of other L-functions.
In §4.10, we brieﬂy discussed the numerical approximation of contour inte-
grals, but we omitted any discussion of other forms of numerical quadrature,
for example Romberg quadrature, the tanh rule, the tanh-sinh rule, etc. Some
references are [11, 12, 13, 95, 172, 213], and [37, §7.4.3]. For further dis-
cussion of the contour integration method, see [156]. For Romberg quadra-
ture (which depends on Richardson extrapolation), see [59, 188, 191]. For
Clenshaw–Curtis and Gaussian quadrature, see [67, 93, 219]. An example of
the use of numerical quadrature to evaluate Γ(x) is [32, p. 188]. This is an
interesting alternative to the use of Stirling’s asymptotic expansion (§4.5).
We have not discussed the computation of speciﬁc mathematical constants
such as π, γ (Euler’s constant), ζ(3), etc.
π can be evaluated using π =

184
Elementary and special function evaluation
4 arctan(1) and a fast arctan computation (§4.9.2); or by the Gauss–Legendre
algorithm (also known as the Brent–Salamin algorithm), see [43, 46, 192].
This asymptotically fast algorithm is based on the arithmetic-geometric mean
and Legendre’s relation (4.72). A recent record computation by Bellard [16]
used a rapidly converging series for 1/π by the Chudnovsky brothers [64],
combined with binary splitting. Its complexity is O(M(n) log2 n) (theoret-
ically worse than Gauss–Legendre’s O(M(n) log n), but with a small con-
stant factor). There are several popular books on π: we mention Arndt and
Haenel [7]. A more advanced book is the one by the Borwein brothers [36].
For a clever implementation of binary splitting and its application to the
fast computation of constants such as π and ζ(3) – and more generally con-
stants deﬁned by hypergeometric series – see Cheng, Hanrot, Thom´e, Zima,
and Zimmermann [63].
The computation of γ and its continued fraction is of interest because it
is not known whether γ is rational (though this is unlikely). The best algo-
rithm for computing γ appears to be the “Bessel function” algorithm of Brent
and McMillan [54], as modiﬁed by Papanikolaou and later Gourdon [106] to
incorporate binary splitting. A very useful source of information on the evalua-
tion of constants (including π, e, γ, ln 2, ζ(3)) and certain functions (including
Γ(z) and ζ(s)) is Gourdon and Sebah’s web site [106].
A nice book on accurate numerical computations for a diverse set of “SIAM
100-Digit Challenge” problems is Bornemann, Laurie, Wagon, and Waldvo-
gel [32]. In particular, Appendix B of this book considers how to solve the
problems to 10 000-decimal digit accuracy (and succeeds in all cases but one).

5
Implementations and pointers
Here we present a non-exhaustive list of software packages that
(in most cases) the authors have tried, together with some other
useful pointers. Of course, we cannot accept any responsibility
for bugs/errors/omissions in any of the software or documenta-
tion mentioned here – caveat emptor!
Websites change. If any of the websites mentioned here disappear
in the future, you may be able to ﬁnd the new site using a search
engine with appropriate keywords.
5.1 Software tools
5.1.1 CLN
CLN (Class Library for Numbers, http://www.ginac.de/CLN/) is a
library for efﬁcient computations with all kinds of numbers in arbitrary preci-
sion. It was written by Bruno Haible, and is currently maintained by Richard
Kreckel. It is written in C++ and distributed under the GNU General Public
License (GPL). CLN provides some elementary and special functions, and fast
arithmetic on large numbers, in particular it implements Sch¨onhage–Strassen
multiplication, and the binary splitting algorithm [108]. CLN can be conﬁg-
ured to use GMP low-level MPN routines, which improves its performance.
5.1.2 GNU MP (GMP)
The GNU MP library is the main reference for arbitrary-precision arithmetic.
It has been developed since 1991 by Torbj¨orn Granlund and several other con-
tributors. GNU MP (GMP for short) implements several of the algorithms de-

186
Implementations and pointers
scribed in this book. In particular, we recommend reading the “Algorithms”
chapter of the GMP reference manual [104]. GMP is written in C, is released
under the GNU Lesser General Public License (LGPL), and is available from
http://gmplib.org/.
GMP’s MPZ class implements arbitrary-precision integers (corresponding
to Chapter 1), while the MPF class implements arbitrary-precision ﬂoating-
point numbers (corresponding to Chapter 3).1 The performance of GMP comes
mostly from its low-level MPN class, which is well designed and highly opti-
mized in assembly code for many architectures.
As of version 5.0.0, MPZ implements different multiplication algorithms
(schoolbook, Karatsuba, Toom–Cook 3-way, 4-way, 6-way, 8-way, and FFT
using Sch¨onhage–Strassen’s algorithm); its division routine implements Algo-
rithm RecursiveDivRem (§1.4.3) in the middle range, and beyond that New-
ton’s method, with complexity O(M(n)), and so does its square root, which
implements Algorithm SqrtRem, since it relies on division. The Newton di-
vision ﬁrst precomputes a reciprocal to precision n/2, and then performs two
steps of Barrett reduction to precision n/2: this is an integer variant of Algo-
rithm Divide. It also implements unbalanced multiplication, with Toom–Cook
(3, 2), (4, 3), (5, 3), (4, 2), or (6, 3) [31]. Function mpn ni invertappr,
which is not in the public interface, implements Algorithm Approximate-
Reciprocal (§3.4.1). GMP 5.0.0 does not implement elementary or special
functions (Chapter 4), nor does it provide modular arithmetic with an invariant
divisor in its public interface (Chapter 2). However, it contains a preliminary
interface for Montgomery’s REDC algorithm.
MPIR is a “fork” of GMP, with a different license, and various other dif-
ferences that make some functions more efﬁcient with GMP, and some with
MPIR; also, the difﬁculty of compiling under Microsoft operating systems may
vary between the forks. Of course, the developers of GMP and MPIR are con-
tinually improving their code, so the situation is dynamic. For more on MPIR,
see http://www.mpir.org/.
5.1.3 MPFQ
MPFQ is a software library developed by Pierrick Gaudry and Emmanuel
Thom´e for manipulation of ﬁnite ﬁelds. What makes MPFQ different from
other modular arithmetic libraries is that the target ﬁnite ﬁeld is given at com-
pile time, thus more speciﬁc optimizations can be done. The two main targets
of MPFQ are the Galois ﬁelds F2n and Fp with p prime. MPFQ is available
1 However, the authors of GMP recommend using MPFR (see §5.1.4) for new projects.

5.1 Software tools
187
from http://www.mpfq.org/, and is distributed under the GNU Lesser
General Public License (LGPL).
5.1.4 GNU MPFR
GNU MPFR is a multiple-precision binary ﬂoating-point library, written in C,
based on the GNU MP library, and distributed under the GNU Lesser General
Public License (LGPL). It extends the main ideas of the IEEE 754 standard to
arbitrary-precision arithmetic, by providing correct rounding and exceptions.
MPFR implements the algorithms of Chapter 3 and most of those of Chap-
ter 4, including all mathematical functions deﬁned by the ISO C99 standard.
These strong semantics are in most cases achieved with no signiﬁcant slow-
down compared to other arbitrary-precision tools. For details of the MPFR
library, see http://www.mpfr.org/ and the paper [96].
5.1.5 Other multiple-precision packages
Without attempting to be exhaustive, we brieﬂy mention some of MPFR’s pre-
decessors, competitors, and extensions.
1. ARPREC is a package for multiple-precision ﬂoating-point arithmetic, writ-
ten by David Bailey et al. in C++/Fortran. The distribution includes The Ex-
perimental Mathematician’s Toolkit, which is an interactive high-precision
arithmetic computing environment. ARPREC is available from http://
crd.lbl.gov/˜dhbailey/mpdist/.
2. MP [47] is a package for multiple-precision ﬂoating-point arithmetic and el-
ementary and special function evaluation, written in Fortran77. MP permits
any small base β (subject to restrictions imposed by the word-size), and im-
plements several rounding modes, though correct rounding-to-nearest is not
guaranteed in all cases. MP is now obsolete, and we recommend the use of
a more modern package such as MPFR. However, much of Chapter 4 was
inspired by MP, and some of the algorithms implemented in MP are not yet
available in later packages, so the source code and documentation may be
of interest: see http://rpbrent.com/pub/pub043.html.
3. MPC (http://www.multiprecision.org/) is a C library for arith-
metic using complex numbers with arbitrarily high precision and correct
rounding, written by Andreas Enge, Philippe Th´eveny, and Paul Zimmer-
mann [90]. MPC is built on and follows the same principles as MPFR.

188
Implementations and pointers
4. MPFI is a package for arbitrary-precision ﬂoating-point interval arithmetic,
based on MPFR. It can be useful to get rigorous error bounds using interval
arithmetic. See http://mpfi.gforge.inria.fr/, and also §5.3.
5. Several other interesting/useful packages are listed under “Other Related
Free Software” at the MPFR website http://www.mpfr.org/.
5.1.6 Computational algebra packages
There are several general-purpose computational algebra packages that incor-
porate high-precision or arbitrary-precision arithmetic. These include Magma,
Mathematica, Maple, and Sage. Of these, Sage is free and open-source; the
others are either commercial or semi-commercial and not open-source. The
authors of this book have often used Magma, Maple, and Sage for prototyping
and testing algorithms, since it is usually faster to develop an algorithm in a
high-level language (at least if one is familiar with it) than in a low-level lan-
guage like C, where there are many details to worry about. Of course, if speed
of execution is a concern, it may be worthwhile to translate the high-level code
into a low-level language, but the high-level code will be useful for debugging
the low-level code.
1. Magma (http://magma.maths.usyd.edu.au/magma/) was de-
veloped and is supported by John Cannon’s group at the University of Syd-
ney. Its predecessor was Cayley, a package designed primarily for compu-
tational group theory. However, Magma is a general-purpose algebra pack-
age with logical syntax and clear semantics. It includes arbitrary-precision
arithmetic based on GMP, MPFR, and MPC. Although Magma is not open-
source, it has excellent online documentation.
2. Maple (http://www.maplesoft.com/) is a commercial package orig-
inally developed at the University of Waterloo, now by Waterloo Maple,
Inc. It uses GMP for its integer arithmetic (though not necessarily the latest
version of GMP, so in some cases calling GMP directly may be signiﬁcantly
faster). Unlike most of the other software mentioned in this chapter, Maple
uses radix 10 for its ﬂoating-point arithmetic.
3. Mathematica is a commercial package produced by Stephen Wolfram’s
company Wolfram Research, Inc. In the past, public documentation on
the algorithms used internally by Mathematica was poor. However, this
situation may be improving. Mathematica now appears to use GMP for its

5.2 Mailing lists
189
basic arithmetic. For information about Mathematica, see http://www.
wolfram.com/products/mathematica/.
4. NTL (http://www.shoup.net/ntl/) is a C++ library providing data
structures and algorithms for manipulating arbitrary-length integers, as well
as vectors, matrices, and polynomials over the integers and over ﬁnite ﬁelds.
For example, it is very efﬁcient for operations on polynomials over the ﬁ-
nite ﬁeld F2 (i.e. GF(2)). NTL was written by and is maintained by Victor
Shoup.
5. PARI/GP (http://pari.math.u-bordeaux.fr/) is a computer al-
gebra system designed for fast computations in number theory, but also
able to handle matrices, polynomials, power series, algebraic numbers, etc.
PARI is implemented as a C library, and GP is the scripting language for
an interactive shell giving access to the PARI functions. Overall, PARI is a
small and efﬁcient package. It was originally developed in 1987 by Chris-
tian Batut, Dominique Bernardi, Henri Cohen, and Michel Olivier at Uni-
versit´e Bordeaux I, and is now maintained by Karim Belabas and a team of
volunteers.
6. Sage (http://www.sagemath.org/) is a free, open-source mathe-
matical software system. It combines the power of many existing open-
source packages with a common Python-based interface. According to the
Sage website, its mission is “Creating a viable free open-source alternative
to Magma, Maple, Mathematica and Matlab”. Sage was started by William
Stein and is developed by a large team of volunteers. It uses MPIR, MPFR,
MPC, MPFI, PARI, NTL, etc. Thus, it is a large system, with many capa-
bilities, but occupying a lot of space and taking a long time to compile.
5.2 Mailing lists
5.2.1 The GMP lists
There are four mailing lists associated with GMP: gmp-bugs for bug reports;
gmp-announce for important announcements about GMP, in particular new
releases; gmp-discuss for general discussions about GMP; gmp-devel
for technical discussions between GMP developers. We recommend subscrip-
tion to gmp-announce (very low trafﬁc), to gmp-discuss (medium to
high trafﬁc), and to gmp-devel only if you are interested in the internals of

190
Implementations and pointers
GMP. Information about these lists (including archives and how to subscribe)
is available from http://gmplib.org/mailman/listinfo/.
5.2.2 The MPFR list
There is only one mailing list for the MPFR library. See http://www.
mpfr.org/ to subscribe or search through the list archives.
5.3 On-line documents
The NIST Digital Library of Mathematical Functions (DLMF) is an ambitious
project to completely rewrite Abramowitz and Stegun’s classic Handbook of
Mathematical Functions [1]. It is online at http://dlmf.nist.gov/ and
will also be published in book form by Cambridge University Press.
The Wolfram Functions Site http://functions.wolfram.com/
contains a lot of information about mathematical functions (deﬁnition, spe-
ciﬁc values, general characteristics, representations as series, limits, integrals,
continued fractions, differential equations, transformations, and so on).
The Encyclopedia of Special Functions (ESF) is another nice web site, whose
originality is that all formulæ are automatically generated from very few data
that uniquely deﬁne the corresponding function in a general class [163]. This
encyclopedia is currently being reimplemented in the Dynamic Dictionary of
Mathematical Functions (DDMF); both are available from http://algo.
inria.fr/online.html.
A large amount of information about interval arithmetic (introduction, soft-
ware, languages, books, courses, applications) can be found on the Interval
Computations page http://www.cs.utep.edu/interval-comp/.
Mike Cowlishaw maintains an extensive bibliography of conversion to and
from decimal arithmetic at http://speleotrove.com/decimal/.
Useful if you want to identify an unknown real constant such as 1.414213 · · ·
is the Inverse Symbolic Calculator (ISC) by Simon Plouffe (building on
earlier work by the Borwein brothers) at http://oldweb.cecm.sfu.
ca/projects/ISC/.
Finally, an extremely useful site for all kinds of integer/rational sequences is
Neil Sloane’s Online Encyclopaedia of Integer Sequences (OEIS) at http://
www.research.att.com/˜njas/sequences/.

References
[1] Abramowitz, Milton and Stegun, Irene A. 1973. Handbook of Mathematical
Functions. Dover. (150, 179, 180, 190)
[2] Agrawal, Manindra, Kayal, Neeraj, and Saxena, Nitin. 2004. PRIMES is in P.
Annals of Mathematics, 160, 1–13. (45)
[3] Aho, Alfred V., Hopcroft, John E., and Ullman, Jeffrey D. 1974. The Design and
Analysis of Computer Algorithms. Addison-Wesley. (46, 78)
[4] Andrews, George E., Askey, Richard, and Roy, Ranjan. 1999. Special Functions.
Cambridge University Press. (179, 180)
[5] ANSI/IEEE. 2008. IEEE Standard for Binary Floating-Point Arithmetic. Revi-
sion of IEEE 754-1985, approved on June 12, 2008 by IEEE Standards Board.
(121)
[6] Apostol, Tom M. 1999. An elementary view of Euler’s summation formula. The
American Mathematical Monthly, 106(5), 409–418. (180)
[7] Arndt, J¨org and Haenel, Christoph. 2001. π Unleashed. Berlin: Springer-Verlag.
(181, 184)
[8] Bach, Eric. 1990. A note on square roots in ﬁnite ﬁelds. IEEE Transactions on
Information Theory, 36(6), 1494–1498. (46)
[9] Bach, Eric and Shallit, Jeffrey O. 1996. Algorithmic Number Theory, Volume 1:
Efﬁcient Algorithms. MIT Press. (46)
[10] Bachmann, Paul. 1902.
Niedere Zahlentheorie.
Vol. 1.
Leipzig: Teubner.
Reprinted by Chelsea, New York, 1968. (46)
[11] Bailey, David H. 2006.
Tanh-sinh high-precision quadrature.
Manuscript,
3 pages, Jan 2006: LBNL-60519. Available from http://crd.lbl.gov/
˜dhbailey/dhbpapers/dhb-tanh-sinh.pdf. (183)
[12] Bailey, David H. and Borwein, Jonathan M. 2009.
High-precision nu-
merical integration: progress and challenges.
Manuscript, 19 pages, July
2009: LBNL-547E. http://crd.lbl.gov/˜dhbailey/dhbpapers/
hp-num-int.pdf. (183)
[13] Bailey, David H., Jeyabalan, Karthik, and Li, Xiaoye S. 2005. A comparison
of three high-precision quadrature schemes. Experimental Mathematics, 14(3),
317–329. (183)
[14] Barrett, Paul. 1987. Implementing the Rivest Shamir and Adleman public key
encryption algorithm on a standard digital signal processor. Pages 311–323 of

192
References
Odlyzko, A. M. (ed.), Advances in Cryptology, Proceedings of Crypto’86. Lec-
ture Notes in Computer Science, vol. 263. Springer-Verlag. (77)
[15] Beeler, Michael, Gosper, Richard W., and Schroeppel, Rich. 1972. HAKMEM.
Memo 239. MIT Artiﬁcial Intelligence Laboratory. http://www.inwap.
com/pdp10/hbaker/hakmem/hakmem.html. (181)
[16] Bellard, Fabrice. 2009. Pi computation record. http://bellard.org/pi/
pi2700e9/announce.html. (184)
[17] Bernstein, Daniel J. 1998. Detecting perfect powers in essentially linear time.
Mathematics of Computation, 67, 1253–1283. (45)
[18] Bernstein, Daniel J. 2002. Pippenger’s exponentiation algorithm. http://
cr.yp.to/papers.html. 21 pages. (78)
[19] Bernstein, Daniel J. 2003. Computing logarithm intervals with the arithmetic-
geometric-mean iteration.
http://cr.yp.to/arith.html.
8 pages.
(181)
[20] Bernstein, Daniel J. 2004a. Removing redundancy in high-precision Newton
iteration. http://cr.yp.to/fastnewton.html. 13 pages. (122, 123)
[21] Bernstein, Daniel J. 2004b. Scaled remainder trees. http://cr.yp.to/
arith.html. 8 pages. (43)
[22] Bernstein, Daniel J. 2008. Fast multiplication and its applications. http://
cr.yp.to/arith.html. 60 pages. (78)
[23] Bernstein, Daniel J., Lenstra, Hendrik W., Jr., and Pila, Jonathan. 2007. Detect-
ing perfect powers by factoring into coprimes. Mathematics of Computation,
76(257), 385–388. (45)
[24] Bernstein, Daniel J. and Sorenson, Jonathan P. 2007. Modular exponentiation via
the explicit Chinese remainder theorem. Mathematics of Computation, 76(257),
443–454. (77, 78)
[25] Bernstein, Joseph N. 1971. Modules over a ring of differential operators, study
of the fundamental solutions of equations with constant coefﬁcients. Functional
Analysis and Its Applications, 5(2), Russian original: 1–16, English translation:
89–101. (183)
[26] Bernstein, Joseph N. 1972. The analytic continuation of generalized functions
with respect to a parameter.
Functional Analysis and Its Applications, 6(4),
[3] Russian original: 26–40, English translation: 273–285. (183)
[27] Bernstein, Robert. 1986. Multiplication by integer constants. Software, Practice
and Experience, 16(7), 641–652. (14)
[28] Berry, Michael V. 1995. The Riemann–Siegel expansion for the zeta function:
high orders and remainders. Proc. Roy. Soc. London, 450, 439–462. (183)
[29] Bertot, Yves, Magaud, Nicolas, and Zimmermann, Paul. 2002. A proof of GMP
square root. Journal of Automated Reasoning, 29, 225–252. Special Issue on
Automating and Mechanising Mathematics: In honour of N.G. de Bruijn. (45)
[30] Bluestein, Leo I. 1968. A linear ﬁltering approach to the computation of the
discrete Fourier transform.
Northeast Electronics Research and Engineering
Meeting Record, 10, 218–219. (78)
[31] Bodrato, Marco and Zanoni, Alberto. 2007. Integer and polynomial multiplica-
tion: towards optimal Toom–Cook matrices. Pages 17–24 of Brown, C. W. (ed.),
Proceedings of the 2007 International Symposium on Symbolic and Algebraic
Computation (ISSAC’07). (44, 186)

References
193
[32] Bornemann, Folkmar, Laurie, Dirk, Wagon, Stan, and Waldvogel, J¨org. 2004.
The SIAM 100-Digit Challenge: A Study in High-Accuracy Numerical Comput-
ing. SIAM. (183, 184)
[33] Borodin, Allan and El-Yaniv, Ran. 1998. Online Computation and Competitive
Analysis. Cambridge University Press. (44)
[34] Borodin, Allan and Moenck, Robert. 1974. Fast modular transforms. Journal of
Computer and System Sciences, 8(3), 366–386. (78)
[35] Borodin, Allan and Munro, Ian. 1975. The Computational Complexity of Alge-
braic and Numeric Problems. Elsevier Computer Science Library. (78)
[36] Borwein, Jonathan M. and Borwein, Peter B. 1998. Pi and the AGM: A Study
in Analytic Number Theory and Computational Complexity. Wiley. (181, 182,
184)
[37] Borwein, Jonathan M., Borwein, Peter B., and Girgensohn, Roland. 2004.
Experimentation in Mathematics: Computational Paths to Discovery.
A. K.
Peters. (183)
[38] Borwein, Jonathan M., Bradley, David M., and Crandall, Richard E. 2000. Com-
putational strategies for the Riemann zeta function. Journal of Computational
and Applied Mathematics, 121, 247–296. (183)
[39] Borwein, Peter B. 2000. An efﬁcient algorithm for the Riemann zeta function.
In Constructive, Experimental, and Nonlinear Analysis (Limoges, 1999), CMS
Conf. Proc. 27, Amer. Math. Soc. (183)
[40] Bostan, Alin, Lecerf, Gr´egoire, and Schost, ´Eric. 2003. Tellegen’s principle into
practice. Pages 37–44 of Sendra, J. R. (ed.), Proceedings of the 2003 Interna-
tional Symposium on Symbolic and Algebraic Computation (ISSAC’03). (122)
[41] Brent, Richard P. 1973a.
Algorithms for Minimization without Derivatives.
Prentice-Hall.
Reprinted by Dover, 2002. http://rpbrent.com/pub/
pub011.html. (179)
[42] Brent, Richard P. 1973b. On the precision attainable with various ﬂoating-point
number systems. IEEE Transactions on Computers, C-22, 601–607. http://
rpbrent.com/pub/pub017.html. (118, 121)
[43] Brent, Richard P. 1975. Multiple-precision zero-ﬁnding methods and the com-
plexity of elementary function evaluation. Pages 151–176 of Traub, J. F. (ed.),
Analytic Computational Complexity. New York: Academic Press. http://
rpbrent.com/pub/pub028.html. (179, 181, 184)
[44] Brent, Richard P. 1976a. Analysis of the binary Euclidean algorithm. Pages
321–355 of Traub, J. F. (ed.), New Directions and Recent Results in Algorithms
and Complexity. New York: Academic Press. http://rpbrent.com/pub/
pub037.html. Errata: see the online version. (45)
[45] Brent, Richard P. 1976b. The complexity of multiple-precision arithmetic. Pages
126–165 of Anderssen, R. S. and Brent, R. P. (eds.), The Complexity of Computa-
tional Problem Solving. University of Queensland Press. http://rpbrent.
com/pub/pub032.html. (166, 182)
[46] Brent, Richard P. 1976c. Fast multiple-precision evaluation of elementary func-
tions. Journal of the ACM, 23(2), 242–251. http://rpbrent.com/pub/
pub034.html. (181, 184)

194
References
[47] Brent, Richard P. 1978.
Algorithm 524: MP, a Fortran multiple-precision
arithmetic package. ACM Transactions on Mathematical Software, 4, 71–81.
http://rpbrent.com/pub/pub043.html. (179, 180, 181, 187)
[48] Brent, Richard P. 1980. Unrestricted algorithms for elementary and special func-
tions. Pages 613–619 of Lavington, S. H. (ed.), Information Processing, vol. 80.
http://rpbrent.com/pub/pub052.html. (121, 179, 180)
[49] Brent, Richard P. 1982. An idealist’s view of semantics for integer and real
types. Australian Computer Science Communications, 4, 130–140. http://
rpbrent.com/pub/pub069.html. (121)
[50] Brent, Richard P. 2000. Twenty years’ analysis of the binary Euclidean algo-
rithm.
Pages 41–53 of Davies, J., Roscoe, A. W., and Woodcock, J. (eds.),
Millennial Perspectives in Computer Science. New York: Palgrave. http://
rpbrent.com/pub/pub183.html. (45)
[51] Brent, Richard P. 2006. Fast algorithms for high-precision computation of el-
ementary functions. Invited talk presented at the Real Numbers and Computa-
tion Conference (RNC7), Nancy, France, July 2006. Available from http://
rpbrent.com/talks.html. (181)
[52] Brent, Richard P. and Kung, Hsiang T. 1978. Fast algorithms for manipulat-
ing formal power series.
Journal of the ACM, 25(2), 581–595.
http://
rpbrent.com/pub/pub045.html. (179)
[53] Brent, Richard P. and Kung, Hsiang T. 1983. Systolic VLSI arrays for linear-time
GCD computation. Pages 145–154 of Anceau, F. and Aas, E. J. (eds.), VLSI
83. Amsterdam: North-Holland. http://rpbrent.com/pub/pub082.
html. (46)
[54] Brent, Richard P. and McMillan, Edwin M. 1980. Some new algorithms for
high-precision computation of Euler’s constant. Mathematics of Computation,
34(149), 305–312. http://rpbrent.com/pub/pub049.html. (184)
[55] Brent, Richard P., Percival, Colin, and Zimmermann, Paul. 2007. Error bounds
on complex ﬂoating-point multiplication. Mathematics of Computation, 76(259),
1469–1481. http://rpbrent.com/pub/pub221.html. (122)
[56] Brent, Richard P. and Traub, Joseph F. 1980. On the complexity of composition
and generalized composition of power series. SIAM J. on Computing, 9, 54–66.
http://rpbrent.com/pub/pub050.html. (179)
[57] Brent, Richard P. and Zimmermann, Paul. 2010. An O(M(n) log n) algorithm
for the Jacobi symbol. Pages 83–95 of Hanrot, Guillaume, Morain, Franc¸ois, and
Thom´e, Emmanuel (eds.), Proceedings of the 9th Algorithmic Number Theory
Symposium (ANTS-IX). Lecture Notes in Computer Science, vol. 6197. Nancy,
France, July 19-23, 2010: Springer-Verlag. (46)
[58] Brisebarre, Nicolas, de Dinechin, Florent, Jeannerod, Claude-Pierre, Lef`evre,
Vincent, Melquiond, Guillaume, Muller, Jean-Michel, Revol, Nathalie, Stehl´e,
Damien, and Torres, Serge. 2009.
Handbook of Floating-Point Arithmetic.
Birkh¨auser. 572 pages. (179)
[59] Bulirsch, Roland and Stoer, Josef. 1967. Handbook series numerical integration:
numerical quadrature by extrapolation. Numerische Mathematik, 9, 271–278.
(183)

References
195
[60] B¨urgisser, Peter, Clausen, Michael, and Shokrollahi, Mohammad A. 1997. Al-
gebraic Complexity Theory. Grundlehren der mathematischen Wissenschaften
315. Springer. (41, 123)
[61] Burnikel, Christoph and Ziegler, Joachim. 1998.
Fast Recursive Division.
Research Report MPI-I-98-1-022. MPI Saarbr¨ucken. (45)
[62] Chen, Kwang-Wu. 2001. Algorithms for Bernoulli numbers and Euler numbers.
Journal of Integer Sequences, 4. Article 01.1.6, 7 pp. (181)
[63] Cheng, Howard, Hanrot, Guillaume, Thom´e, Emmanuel, Zima, Eugene, and
Zimmermann, Paul. 2007.
Time- and space-efﬁcient evaluation of some hy-
pergeometric constants. Pages 85–91 of Brown, C. W. (ed.), Proceedings of the
2007 International Symposium on Symbolic (ISSAC’2007). ACM. (184)
[64] Chudnovsky, David V. and Chudnovsky, Gregory G. 1988. Approximations and
complex multiplication according to Ramanujan. Pages 375–472 of Andrews,
G. E., Berndt, B. C., and Rankin, R. A. (eds.), Ramanujan Revisited: Proceedings
of the Centenary Conference. Boston: Academic Press. (184)
[65] Chudnovsky, David V. and Chudnovsky, Gregory V. 1990. Computer algebra
in the service of mathematical physics and number theory. Pages 109–232 of
Computers in Mathematics (Stanford, CA, 1986). Lecture Notes in Pure and
Applied Mathematics, vol. 125. New York: Dekker. (182)
[66] Chung, Jaewook and Hasan, M. Anwar. 2007. Asymmetric squaring formulae.
Pages 113–122 of Kornerup, P. and Muller, J.-M. (eds.), Proceedings of the 18th
IEEE Symposium on Computer Arithmetic (ARITH-18). IEEE Computer Society.
(45)
[67] Clenshaw, Charles W. and Curtis, Alan R. 1960. A method for numerical inte-
gration on an automatic computer. Numerische Mathematik, 2, 197–205. (183)
[68] Clenshaw, Charles W., Goodwin, Charles E. T., Martin, David W., Miller, Geof-
frey F., Olver, Frank W. J., and Wilkinson, James H. 1961. Modern Computing
Methods. Second edn. Notes on Applied Science, No. 16. HMSO. (180)
[69] Clenshaw, Charles W. and Olver, Frank W. J. 1980. An unrestricted algorithm
for the exponential function. SIAM Journal on Numerical Analysis, 17, 310–331.
(121, 180)
[70] Clenshaw, Charles W. and Olver, Frank W. J. 1984. Beyond ﬂoating point. Jour-
nal of the ACM, 31(2), 319–328. (120)
[71] Clinger, William D. 1990. How to read ﬂoating point numbers accurately. Pages
92–101 of Proceedings of the ACM SIGPLAN’90 Conference on Programming
Language Design and Implementation. (123)
[72] Cody, William J., Coonen, Jerome T., Gay, David M., Hanson, Kenton, Hough,
David, Kahan, William, Karpinski, Richard, Palmer, John, Ris, Frederic N., and
Stevenson, David. 1984. A proposed radix- and word-length-independent stan-
dard for ﬂoating-point arithmetic. IEEE Micro, 86–100. (121)
[73] Cohen, Henri. 1993. A Course in Computational Algebraic Number Theory.
Graduate Texts in Mathematics 138. Springer-Verlag. 534 pages. (45, 78)
[74] Collins, George E. and Krandick, Werner. 2000. Multiprecision ﬂoating point
addition. Pages 71–77 of Traverso, C. (ed.), Proceedings of the 2000 Interna-
tional Symposium on Symbolic and Algebraic Computation (ISSAC’00). ACM
Press. (121)

196
References
[75] Commerce, US Department of. 2000. Digital Signature Standard (DSS). Tech.
rept. FIPS PUB 186-2. National Institute of Standards and Technology. 76 pages.
(78)
[76] Cook, Stephen A. 1966. On the minimum computation time of functions. Ph.D.
thesis, Harvard University. Chapter 3 available from http://cr.yp.to/
bib/1966/cook.html. (44)
[77] Cornea, Marius, Anderson, Cristina, Harrison, John, Tang, Ping Tak Peter,
Schneider, Eric, and Tsen, Charles. 2007. A software implementation of the
IEEE 754R decimal ﬂoating-point arithmetic using the binary encoding format.
Pages 29–37 of Proceedings of the 18th IEEE Symposium on Computer Arith-
metic (ARITH-18). (123)
[78] Cornea-Hasegan, Marius A., Golliver, Roger A., and Markstein, Peter. 1999.
Correctness proofs outline for Newton–Raphson based ﬂoating-point divide and
square root algorithms. Pages 96–105 of Koren, I. and Kornerup, P. (eds.), Pro-
ceedings of the 14th IEEE Symposium on Computer Arithmetic (ARITH-14).
(122)
[79] Crandall, Richard E. 1994. Projects in Scientiﬁc Computation. TELOS, The
Electronic Library of Science, Santa Clara, California. (122)
[80] Crandall, Richard E. 1996. Topics in Advanced Scientiﬁc Computation. TELOS,
The Electronic Library of Science, Santa Clara, California. (99, 122)
[81] Crandall, Richard E. and Pomerance, Carl. 2005. Prime Numbers: A Computa-
tional Perspective. Second edn. Springer-Verlag. (44)
[82] Crary, Fred D. and Rosser, John B. 1977. High precision coefﬁcients related
to the zeta function. Reviewed in Mathematics of Computation, 31, 803–804.
Review available from http://rpbrent.com/review01.html. (183)
[83] Cuyt, Annie, Petersen, Vigdis B., Verdonk, Brigitte, Waadeland, Haakon, and
Jones, William B. (with contributions by Franky Backeljauw and Catherine
Bonan-Hamada). 2008. Handbook of Continued Fractions for Special Func-
tions. Springer. xvi+431 pages. (180)
[84] de Bruijn, Nicolaas G. 1970 (reprinted by Dover, New York 1981). Asymptotic
Methods in Analysis. Third edn. North-Holland. (180)
[85] de Reyna, Juan Arias. 2005. Dynamical zeta functions and Kummer congru-
ences. Acta Arithmetica, 119(1), 39–52. (183)
[86] Dimitrov, Vassil S., Jullien, Graham A., and Miller, William C. 1998. An algo-
rithm for modular exponentiation. Information Processing Letters, 66, 155–159.
(78)
[87] Dixon, Brandon and Lenstra, Arjen K. 1993. Massively parallel elliptic curve
factoring. Pages 183–193 of Proceedings of Eurocrypt’92. Lecture Notes in
Computer Science, vol. 658. Springer-Verlag. (44)
[88] Dupont, R´egis. 2010. Fast evaluation of modular functions using Newton itera-
tions and the AGM. Mathematics of Computation. In press, 2010. (181)
[89] Eikenberry, Shawna M. and Sorenson, Jonathan P. 1998. Efﬁcient algorithms for
computing the Jacobi symbol. Journal of Symbolic Computation, 26(4), 509–
523. (46)
[90] Enge, Andreas, Th´eveny, Philippe, and Zimmermann, Paul. 2009. MPC – A
library for multiprecision complex arithmetic with exact rounding. 0.8.1 edn.
INRIA. http://mpc.multiprecision.org/. (187)

References
197
[91] Ercegovac, Miloˇs D. and Muller, Jean-Michel. 2007. Complex square root with
operand prescaling. The Journal of VLSI Signal Processing, 49(1), 19–30. (123)
[92] Estrin, Gerald. 1960. Organization of computer systems – the ﬁxed plus variable
structure computer. Pages 33–40 of Proceedings of the Western Joint Computer
Conference. (180)
[93] F´ejer, Leopold. 1933. On the inﬁnite sequences arising in the theories of har-
monic analysis, of interpolation, and of mechanical quadratures. Bulletin of the
American Mathematical Society, 39, 521–534. (183)
[94] Forsythe, George E. 1970. Pitfalls in computation, or why a math book isn’t
enough. American Mathematical Monthly, 77, 931–956. (138)
[95] Fousse, Laurent. 2006. Int´egration num´erique avec erreur born´ee en pr´ecision
arbitraire. Ph.D. thesis, University Henri Poincar´e Nancy 1. (183)
[96] Fousse, Laurent, Hanrot, Guillaume, Lef`evre, Vincent, P´elissier, Patrick, and
Zimmermann, Paul. 2007. MPFR: A multiple-precision binary ﬂoating-point
library with correct rounding. ACM Transactions on Mathematical Software,
33(2), 13:1–13:15. (187)
[97] Friedland, Paul. 1967. Algorithm 312: Absolute value and square root of a com-
plex number. Communications of the ACM, 10(10), 665. (182)
[98] F¨urer, Martin. 2007. Faster integer multiplication. Pages 57–66 of Johnson,
D. S. and Feige, U. (eds.), Proceedings of the 39th Annual ACM Symposium on
Theory of Computing (STOC), San Diego, California, USA. ACM. (78)
[99] Gabcke, Wolfgang. 1979. Neue Herleitung und explizite Restabsch¨atzung der
Riemann-Siegel-Formel.
Ph.D. thesis, Georg-August-Universit¨at, G¨ottingen.
Spanish translation available from Juan Arias de Reyna. (183)
[100] Gathen, Joachim von zur and Gerhard, J¨urgen. 1999. Modern Computer Al-
gebra.
Cambridge: Cambridge University Press.
http://www-math.
uni-paderborn.de/mca. (77)
[101] Gauss, Carl F. 1889. Untersuchungen ¨uber H¨ohere Arithmetik. Berlin: Springer.
Reprinted by the American Mathematical Society, 2006. (46)
[102] Gautschi, Walter. 1964. Algorithm 236: Bessel functions of the ﬁrst kind. Com-
munications of the ACM, 7, 479–480. (180)
[103] Gay, David M. 1990. Correctly rounded binary-decimal and decimal-binary con-
versions. Numerical Analysis Manuscript 90-10. AT&T Bell Laboratories. (123)
[104] GMP. 2010. GNU MP: The GNU Multiple Precision Arithmetic Library. 5.0.0
edn. http://gmplib.org/. (186)
[105] Gourdon, Xavier. 2004. The 1013 ﬁrst zeros of the Riemann zeta function, and
zeros computation at very large height. http://numbers.computation.
free.fr/Constants/Miscellaneous/zetazeros1e13-1e24.
pdf. (183)
[106] Gourdon, Xavier and Sebah, Pascal. 2010. Numbers, constants and computation.
http://numbers.computation.free.fr/. (184)
[107] Graham, Ronald L., Knuth, Donald E., and Patashnik, Oren. 1994. Concrete
Mathematics. Third edn. Addison-Wesley. (181)
[108] Haible, Bruno and Papanikolaou, Thomas. 1998. Fast multiprecision evaluation
of series of rational numbers. Pages 338–350 of Buhler, J. P. (ed.), Proceedings
of the 3rd Algorithmic Number Theory Symposium (ANTS-III). Lecture Notes in
Computer Science, vol. 1423. Springer-Verlag. (182, 185)

198
References
[109] Halfhill, Tom R. 1995. The truth behind the Pentium bug. Byte. March 1995.
Available
from
http://www2.informatik.uni-jena.de/˜nez/
rechnerarithmetik_5/fdiv_bug/byte_art1.htm. (128)
[110] Hankerson, Darrel, Menezes, Alfred, and Vanstone, Scott. 2004. Guide to El-
liptic Curve Cryptography.
Springer-Verlag.
http://www.cacr.math.
uwaterloo.ca/ecc/. (78)
[111] Hanrot, Guillaume, Quercia, Michel, and Zimmermann, Paul. 2004. The mid-
dle product algorithm, I. Speeding up the division and square root of power
series.
Applicable Algebra in Engineering, Communication and Computing,
14(6), 415–438. (122)
[112] Hanrot, Guillaume and Zimmermann, Paul. 2004. A long note on Mulders’ short
product. Journal of Symbolic Computation, 37, 391–401. (45)
[113] Hars, Laszlo. 2004.
Long modular multiplication for cryptographic applica-
tions. Pages 44–61 of CHES’04. Lecture Notes in Computer Science, vol. 3156.
Springer-Verlag. (77)
[114] Harvey, David. 2009a.
Faster polynomial multiplication via multipoint
Kronecker substitution. Journal of Symbolic Computation, 44, 1502–1510. (39,
44)
[115] Harvey, David. 2009b. The Karatsuba middle product for integers. http://
cims.nyu.edu/˜harvey/papers/mulmid/. Preprint. (122)
[116] Harvey, David. 2010a. Faster algorithms for the square root and reciprocal of
power series. Mathematics of Computation. Posted on July 8, 2010 (to appear
in print). (122, 123, 181, 182)
[117] Harvey,
David.
2010b.
A
multimodular
algorithm
for
computing
Bernoulli numbers. Mathematics of Computation, 79, 2361–2370. (181)
[118] Hasenplaugh, William, Gaubatz, Gunnar, and Gopal, Vinodh. 2007. Fast mod-
ular reduction. Pages 225–229 of Proceedings of the 18th IEEE Symposium on
Computer Arithmetic (ARITH-18). Montpellier, France: IEEE Computer Society
Press. (77)
[119] H˚astad, Johan. 1990. Tensor rank is NP-complete. Journal of Algorithms, 11(4),
644–654. (41)
[120] Hennessy, John L., Patterson, David A., and Goldberg, David. 1990. Computer
Architecture: A Quantitative Approach. Morgan Kaufmann. (121)
[121] Higham, Nicholas J. 2002. Accuracy and Stability of Numerical Algorithms.
Second edn. SIAM. (121, 179)
[122] Hille, Einar. 1959. Analytic Function Theory. Vol. 1. New York: Blaisdell. (170)
[123] Hoeven, Joris van der. 1999. Fast evaluation of holonomic functions. Theoretical
Computer Science, 210, 199–215. (183)
[124] Hoeven, Joris van der. 2002. Relax, but don’t be too lazy. Journal of Sym-
bolic Computation, 34(6), 479–542.
Available from http://www.math.
u-psud.fr/˜vdhoeven. (44, 76)
[125] Hoeven, Joris van der. 2006.
Newton’s method and FFT trading.
Tech.
rept. 2006-17. University Paris-Sud. http://www.texmacs.org/joris/
fnewton/fnewton-abs.html. (122, 182)
[126] Householder, Alston S. 1970. The Numerical Treatment of a Single Nonlinear
Equation. New York: McGraw-Hill. (179)

References
199
[127] Hull, Thomas E. 1982. The use of controlled precision. Pages 71–84 of Reid,
J. K. (ed.), The Relationship Between Numerical Computation and Programming
Languages. North-Holland. (121)
[128] Intel. 2003. Division, square root and remainder algorithms for the Intel(R) Ita-
nium(TM) architecture. Application Note, available from ftp://download.
intel.com/software/opensource/divsqrt.pdf, 120 pages. (179)
[129] Iordache, Cristina and Matula, David W. 1999. On inﬁnitely precise rounding
for division, square root, reciprocal and square root reciprocal. Pages 233–240 of
Proceedings of the 14th IEEE Symposium on Computer Arithmetic (ARITH-14).
IEEE Computer Society. (121)
[130] Jebelean, Tudor. 1993. An algorithm for exact division. Journal of Symbolic
Computation, 15, 169–180. (45)
[131] Jebelean, Tudor. 1995. A double-digit Lehmer–Euclid algorithm for ﬁnding the
GCD of long integers. Journal of Symbolic Computation, 19, 145–157. (46)
[132] Jebelean, Tudor. 1997. Practical integer division with Karatsuba complexity.
Pages 339–341 of K¨uchlin, W. W. (ed.), Proceedings of International Symposium
on Symbolic and Algebraic Computation (ISSAC’97). (45)
[133] Kahan, William M. 2002.
Idempotent binary →decimal →binary
conversion.
http://www.cs.berkeley.edu/˜wkahan/Math128/
BinDecBin.pdf. 1 page. (123)
[134] Kaihara, Marcelo E. and Takagi, Naofumi. 2008. Bipartite modular multiplica-
tion method. IEEE Transactions on Computers, 57(2), 157–164. (77)
[135] Kaneko, Masanobu. 2000.
The Akiyama–Tanigawa algorithm for Bernoulli
numbers. Journal of Integer Sequences, 3. Article 00.2.9, 6 pages. (181)
[136] Karatsuba, Anatolii A. and Ofman, Yuri. 1962. Multiplication of multi-digit
numbers on automata (in Russian). Doklady Akad. Nauk SSSR, 145(2), 293–
294. Translation in Soviet Physics-Doklady 7 (1963), 595–596. (44)
[137] Karp, Alan H. and Markstein, Peter. 1997. High-precision division and square
root. ACM Trans. on Mathematical Software, 23(4), 561–589. (45, 122, 179)
[138] Khachatrian, Gurgen H., Kuregian, Melsik K., Ispiryan, Karen R., and Massey,
James L. 2001. Fast multiplication of integers for public-key applications. Pages
245–254 of Vaudenay, S. and Youssef, A. M. (eds.), Proceedings of the 8th An-
nual International Workshop Selected Areas in Cryptography (SAC 2001). Lec-
ture Notes in Computer Science, vol. 2259. Springer-Verlag. (40, 45)
[139] Khinchin, Aleksandr Y. 1963.
Continued Fractions. Third edn.
Groningen:
Noordhoff. Translated by P. Wynn. Reprinted by Dover, New York, 1997. (45,
180)
[140] Knuth, Donald E. 1962. Euler’s constant to 1271 places. Mathematics of Com-
putation, 16, 275–281. (181)
[141] Knuth, Donald E. 1971. The analysis of algorithms. Pages 269–274 of Actes
du Congr`es International des Math´ematiciens de 1970, vol. 3. Paris: Gauthiers-
Villars. (46)
[142] Knuth, Donald E. 1998. The Art of Computer Programming. Third edn. Vol.
2 : Seminumerical Algorithms. Addison-Wesley. http://www-cs-staff.
stanford.edu/˜knuth/taocp.html. (xi, 15, 30, 45, 122, 123, 179)

200
References
[143] Koornwinder, Tom, Temme, Nico, and Vidunas, Raimundas. 2010. Algorith-
mic methods for special functions by computer algebra.
http://staff.
science.uva.nl/˜thk/specfun/compalg.html. (183)
[144] Krandick, Werner and Jebelean, Tudor. 1996. Bidirectional exact integer divi-
sion. Journal of Symbolic Computation, 21(4–6), 441–456. (45)
[145] Krandick, Werner and Johnson, Jeremy R. 1993. Efﬁcient multiprecision ﬂoat-
ing point multiplication with optimal directional rounding. Pages 228–233 of
Swartzlander, E., Irwin, M. J., and Jullien, G. (eds.), Proceedings of the 11th
IEEE Symposium on Computer Arithmetic (ARITH-11). (121)
[146] Kronecker, Leopold. 1880.
¨Uber die symmetrischen Functionen.
Monats-
berichte der K¨oniglich Preuβischen Akademie der Wissenschaften zu Berlin
1880 (Berlin: Verl. d. Kgl. Akad. d. Wiss., 1881), 936–948. (44)
[147] Kronecker, Leopold. 1882. Grundz¨uge einer arithmetischen Theorie der alge-
braischen Gr¨ossen. Berlin: Druck und Verlag Von G. Reimer. (44)
[148] Kuki, Hirondo and Cody, William J. 1973. A statistical study of the accuracy
of ﬂoating-point number systems. Communications of the ACM, 16, 223–230.
(118)
[149] Kulisch, Ulrich W. 2008. Computer Arithmetic and Validity. Theory, Implemen-
tation, and Applications. Studies in Mathematics, no. 33. de Gruyter. 410 pages.
(123)
[150] Kung, Hsiang T. 1974. On computing reciprocals of power series. Numerische
Mathematik, 22, 341–348. (179)
[151] Lang, Tomas and Muller, Jean-Michel. 2001. Bounds on runs of zeros and ones
for algebraic functions. Pages 13–20 of Proceedings of the 15th IEEE Sympo-
sium on Computer Arithmetic (ARITH-15). IEEE Computer Society. (122)
[152] Lef`evre, Vincent. 2001. Multiplication by an Integer Constant. Research Report
RR-4192. INRIA. (45)
[153] Lef`evre, Vincent. 2004. The generic multiple-precision ﬂoating-point addition
with exact rounding (as in the MPFR library). Pages 135–145 of Proceedings of
the 6th Conference on Real Numbers and Computers. (121)
[154] Lehmer, Derrick H. 1938. Euclid’s algorithm for large numbers. The American
Mathematical Monthly, 45(4), 227–233. (45)
[155] Lehmer, Derrick H. 1956. Extended computation of the Riemann zeta-function.
Mathematika, 3, 102–108. (183)
[156] Lyness, James N. and Moler, Cleve B. 1967. Numerical differentiation of ana-
lytic functions. SIAM Journal on Numerical Analysis, 4, 20–2–210. (183)
[157] Maeder, Roman. 1993. Storage allocation for the Karatsuba integer multiplica-
tion algorithm. Pages 59–65 of Proceedings of the International Symposium on
Design and Implementation of Symbolic Computation Systems (DISCO). Lec-
ture Notes in Computer Science, vol. 722. Springer-Verlag. (40)
[158] Markstein, Peter. 2004. Software division and square root using Goldschmidt’s
algorithms. Pages 146–157 of Frougny, Ch., Brattka, V., and M¨uller, N. (eds.),
Proceedings of the 6th Conference on Real Numbers and Computers (RNC’6).
(123)
[159] Maze, G´erard. 2007. Existence of a limiting distribution for the binary GCD
algorithm. Journal of Discrete Algorithms, 5, 176–186. (45)

References
201
[160] McLaughlin, Philip B., Jr. 2004. New frameworks for Montgomery’s modular
multiplication method. Mathematics of Computation, 73(246), 899–906. (77)
[161] Menezes, Alfred J., van Oorschot, Paul C., and Vanstone, Scott A. 1997. Hand-
book of Applied Cryptography.
CRC Press.
http://www.cacr.math.
uwaterloo.ca/hac/. (78)
[162] M´enissier-Morain, Val´erie. 1994.
Arithm´etique exacte, conception, algorith-
mique et performances d’une impl´ementation informatique en pr´ecision arbi-
traire. Ph.D. thesis, University of Paris 7. (120)
[163] Meunier, Ludovic and Salvy, Bruno. 2003. ESF: an automatically generated
encyclopedia of special functions. Pages 199–206 of Sendra, J. R. (ed.), Pro-
ceedings of the 2003 International Symposium on Symbolic and Algebraic Com-
putation (ISSAC’03). (190)
[164] Mihailescu, Preda. 2008. Fast convolutions meet Montgomery. Mathematics of
Computation, 77, 1199–1221. (77)
[165] Mikami, Yoshio. 1913. The Development of Mathematics in China and Japan.
Teubner. Reprinted by Martino Publishing, Eastford, CT, USA, 2004. (45)
[166] Moenck, Robert and Borodin, Allan. 1972. Fast modular transforms via division.
Pages 90–96 of Proceedings of the 13th Annual IEEE Symposium on Switching
and Automata Theory. (45)
[167] M¨oller, Niels. 2007. Notes on the complexity of CRT. Preprint. 8 pages. (78)
[168] M¨oller, Niels. 2008. On Sch¨onhage’s algorithm and subquadratic integer GCD
computation. Mathematics of Computation, 77(261), 589–607. (46)
[169] Montgomery, Peter L. 1985.
Modular multiplication without trial division.
Mathematics of Computation, 44(170), 519–521. (77)
[170] Montgomery, Peter L. 1987. Speeding the Pollard and elliptic curve methods of
factorization. Mathematics of Computation, 48(177), 243–264. (78)
[171] Montgomery, Peter L. 2001. Personal communication to Torbj¨orn Granlund.
(42)
[172] Mori, Masatake. 2005. Discovery of the double exponential transformation and
its developments.
Publications of RIMS, Kyoto University, 41(4), 897–935.
(183)
[173] Mulders, Thom. 2000. On short multiplications and divisions. Applicable Alge-
bra in Engineering, Communication and Computing, 11(1), 69–88. (119, 121)
[174] Muller, Jean-Michel. 2006. Elementary Functions. Algorithms and Implementa-
tion. Birkh¨auser. Second edition. 265 pages. (121, 122, 179)
[175] Nicely, Thomas R. 1995. Enumeration to 1014 of the twin primes and Brun’s
constant.
Virginia Journal of Science, 46(3), 195–204.
http://www.
trnicely.net/twins/twins.html. Review at http://wwwmaths.
anu.edu.au/˜brent/reviews.html. (128)
[176] Nussbaumer, Henri J. 1982.
Fast Fourier Transform and Convolution Algo-
rithms. Second edn. Springer-Verlag. (78)
[177] Odlyzko, Andrew M. 1992. The 1020-th zero of the Riemann zeta function and
175 million of its neighbors.
http://www.dtc.umn.edu/˜odlyzko/
unpublished/. (183)
[178] Odlyzko, Andrew M. 2001. The 1022-nd zero of the Riemann zeta function.
Pages 139–144 of van Frankenhuysen, M. and Lapidus, M. L. (eds.), Dynamical,

202
References
Spectral, and Arithmetic Zeta Functions. American Math. Soc., Contemporary
Math. series, no. 290. (183)
[179] Odlyzko, Andrew M. and Sch¨onhage, Arnold. 1988. Fast algorithms for multi-
ple evaluations of the zeta-function. Trans. Amer. Math. Soc., 309(2), 797–809.
(183)
[180] Olver, Frank W. J. 1974. Asymptotics and Special Functions. Academic Press.
Reprinted by A. K. Peters, 1997. (180)
[181] Pan, Victor. 1984. How to Multiply Matrices Faster. Lecture Notes in Computer
Science, vol. 179. Springer-Verlag. (122)
[182] Paterson, Michael S. and Stockmeyer, Larry J. 1973. On the number of nonscalar
multiplications necessary to evaluate polynomials. SIAM Journal on Computing,
2(1), 60–66. (180)
[183] Percival, Colin. 2003. Rapid multiplication modulo the sum and difference of
highly composite numbers. Mathematics of Computation, 72(241), 387–395.
(78, 122)
[184] P´etermann, Yves-F. S. and R´emy, Jean-Luc. 2007. On the Cohen–Olivier algo-
rithm for computing ζ(s): error analysis in the real case for an arbitrary preci-
sion. Advances in Applied Mathematics, 38, 54–70. (183)
[185] Pollard, John M. 1971. The fast Fourier transform in a ﬁnite ﬁeld. Mathematics
of Computation, 25(114), 365–374. (78)
[186] Priest, Douglas M. 1991. Algorithms for arbitrary precision ﬂoating point arith-
metic. Pages 132–144 of Kornerup, P. and Matula, D. (eds.), Proceedings of the
10th IEEE Symposium on Computer Arithmetic (ARITH-10). Grenoble, France:
IEEE Computer Society Press. (121)
[187] Rader, Charles M. 1968. Discrete Fourier transforms when the number of data
samples is prime. Proceedings IEEE, 56, 1107–1108. (78)
[188] Richardson, Lewis F. and Gaunt, John A. 1927. The deferred approach to the
limit. Philosophical Transactions of the Royal Society of London, Series A, 226,
299–361. (183)
[189] Robertson, James E. 1958. A new class of digital division methods. IRE Trans-
actions on Electronic Computers, EC–7(3), 218–222. (179)
[190] Roche, Daniel S. 2009. Space- and time-efﬁcient polynomial multiplication.
Pages 295–302 of May, J. P. (ed.), Proceedings of the 2009 International Sym-
posium on Symbolic and Algebraic Computation (ISSAC’09). (40)
[191] Romberg, Werner. 1955. Vereinfachte numerische Integration. Det Kongelige
Norske Videnskabers Selskab Forhandlinger (Tronheim), 28(7), 30–36. (183)
[192] Salamin, Eugene. 1976. Computation of π using arithmetic-geometric mean.
Mathematics of Computation, 30, 565–570. (181, 184)
[193] Salvy, Bruno and Zimmermann, Paul. 1994. Gfun: A Maple package for the ma-
nipulation of generating and holonomic functions in one variable. ACM Trans-
actions on Mathematical Software, 20(2), 163–177. (183)
[194] Schmookler, Martin S. and Nowka, Kevin J. 2001. Leading zero anticipation and
detection – a comparison of methods. Pages 7–12 of Burgess, N. and Ciminiera,
L. (eds.), Proceedings of the 15th IEEE Symposium on Computer Arithmetic
(ARITH-15). IEEE Computer Society. (121)
[195] Sch¨onhage, Arnold. 1971. Schnelle Berechnung von Kettenbruchentwicklun-
gen. Acta Informatica, 1, 139–144. (46, 180)

References
203
[196] Sch¨onhage, Arnold. 1982. Asymptotically fast algorithms for the numerical mul-
tiplication and division of polynomials with complex coefﬁcients. Pages 3–15
of Computer Algebra, EUROCAM’82. Lecture Notes in Computer Science, vol.
144. Springer-Verlag. (44)
[197] Sch¨onhage, Arnold. 2000. Variations on computing reciprocals of power series.
Information Processing Letters, 74, 41–46. (122, 171)
[198] Sch¨onhage, Arnold, Grotefeld, A. F. W., and Vetter, E. 1994. Fast Algorithms: A
Multitape Turing Machine Implementation. BI-Wissenschaftsverlag, Mannheim.
(46, 122, 182)
[199] Sch¨onhage, Arnold and Strassen, Volker. 1971. Schnelle Multiplikation großer
Zahlen. Computing, 7, 281–292. (45, 78)
[200] Shallit, Jeffrey and Sorenson, Jonathan. 1993. A binary algorithm for the Jacobi
symbol. SIGSAM Bulletin, 27(1), 4–11. http://euclid.butler.edu/
˜sorenson/papers/binjac.ps. (46)
[201] Shand, Mark and Vuillemin, Jean. 1993. Fast implementations of RSA cryptog-
raphy. Pages 252–259 of Proceedings of the 11th IEEE Symposium on Computer
Arithmetic (ARITH-11). (45)
[202] Sieveking, Malte. 1972. An algorithm for division of power series. Computing,
10, 153–156. (179)
[203] Sloane, Neil J. A. 2009.
The On-Line Encyclopedia of Integer Sequences.
http://www.research.att.com/˜njas/sequences/. (181, 183)
[204] Smith, David M. 1991. Algorithm 693: A Fortran package for ﬂoating-point
multiple-precision arithmetic.
ACM Transactions on Mathematical Software,
17(2), 273–283. (180)
[205] Sorenson, Jonathan P. 1994. Two fast GCD algorithms. Journal of Algorithms,
16, 110–144. (46)
[206] Steel, Allan. 2006.
Reduce everything to multiplication.
Computing by the
Numbers: Algorithms, Precision, and Complexity, Workshop for Richard Brent’s
sixtieth birthday, Berlin.
http://www.mathematik.hu-berlin.de/
˜gaggle/EVENTS/2006/BRENT60/. (44)
[207] Steele, Guy L. and White, Jon L. 1990. How to print ﬂoating-point numbers
accurately. Pages 112–126 of Proceedings of the ACM SIGPLAN’90 Conference
on Programming Language Design and Implementation. (123)
[208] Stehl´e, Damien and Zimmermann, Paul. 2004. A binary recursive GCD algo-
rithm. Pages 411–425 of Buell, D. A. (ed.), Proceedings of the 6th International
Symposium on Algorithmic Number Theory (ANTS VI). Lecture Notes in Com-
puter Science, vol. 3076. Burlington, USA: Springer-Verlag. (35, 46)
[209] Stein, Josef. 1967.
Computational problems associated with Racah algebra.
Journal of Computational Physics, 1, 397–405. (45)
[210] Sterbenz, Pat H. 1974. Floating-Point Computation. Englewood Cliffs, NJ,
USA: Prentice Hall. (121)
[211] Svoboda, Antonin. 1963. An algorithm for division. Information Processing
Machines, 9, 25–34. (45)
[212] Swartzlander, Earl E., Jr. (ed.). 1980. Computer Arithmetic. Dowden, Hutchison
and Ross (distributed by Van Nostrand, New York). (78, 179)

204
References
[213] Takahasi, Hidetosi and Mori, Masatake. 1974. Double exponential formulas for
numerical integration. Publications of RIMS, Kyoto University, 9(3), 721–741.
(183)
[214] Temme, Nico M. 1996.
Special Functions: An Introduction to the Classical
Functions of Mathematical Physics. Wiley. (179)
[215] Thom´e, Emmanuel. 2002. Karatsuba multiplication with temporary space of size
≤n. 6 pages, http://www.loria.fr/˜thome/. (40)
[216] Tocher, Keith D. 1958. Techniques of multiplication and division for automatic
binary computers. Quarterly Journal of Mechanics and Applied Mathematics,
11(3), 364–384. (179)
[217] Toom, Andrei L. 1963. The complexity of a scheme of functional elements real-
izing the multiplication of integers (in Russian). Doklady Akademii Nauk SSSR,
150(3), 496–498.
Available from http://www.de.ufpe.br/˜toom/
my_articles/rusmat/MULT-R.PDF. Translation in Soviet Mathematics
4 (1963), 714–716. (44)
[218] Traub, Joseph F. 1964. Iterative Methods for the Solution of Equations. Engle-
wood Cliffs, New Jersey: Prentice-Hall. (179)
[219] Trefethen, Lloyd N. 2008. Is Gauss quadrature better than Clenshaw–Curtis?
SIAM Review, 50(1), 67–87. (183)
[220] Urabe, Minoru. 1968. Roundoff error distribution in ﬁxed-point multiplication
and a remark about the rounding rule. SIAM Journal on Numerical Analysis, 5,
202–210. (118)
[221] Vall´ee, Brigitte. 1998. Dynamics of the binary Euclidean algorithm: functional
analysis and operators. Algorithmica, 22, 660–685. (46)
[222] Van Loan, Charles F. 1992. Computational Frameworks for the Fast Fourier
Transform. Philadelphia: SIAM. (78)
[223] Vep˘stas, Linas. 2007. An efﬁcient algorithm for accelerating the convergence of
oscillatory series, useful for computing the polylogarithm and Hurwitz zeta func-
tions. http://arxiv.org/abs/math.CA/0702243. 37 pages. (183)
[224] Wall, Hubert S. 1948. Analytic Theory of Continued Fractions. Van Nostrand.
(180)
[225] Watson, George N. 1966. A Treatise on the Theory of Bessel Functions. Second
edn. Cambridge University Press. (180)
[226] Weber, Kenneth. 1995. The accelerated integer GCD algorithm. ACM Transac-
tions on Mathematical Software, 21(1), 111–122. (31, 46)
[227] Whittaker, Edmund T. and Watson, George N. 1927. A Course of Modern Anal-
ysis. Fourth edn. Cambridge University Press. (180)
[228] Wilkinson, James H. 1963. Rounding Errors in Algebraic Processes. HMSO,
London. (121, 179)
[229] Wilkinson, James H. 1965. The Algebraic Eigenvalue Problem. Clarendon Press,
Oxford. (121, 179)
[230] Winograd, Shmuel. 1978. On computing the discrete Fourier transform. Mathe-
matics of Computation, 32(141), 175–199. (78)
[231] Wong, Roderick. 1989. Asymptotic Approximation of Integrals. Academic Press.
Reprinted by SIAM, 2001. (180)
[232] Yap, Chee K. 2000. Fundamental Problems in Algorithmic Algebra. Oxford
University Press. (46)

References
205
[233] Zeilberger, Doron. 1990. A holonomic systems approach to special function
identities. J. Comput. Appl. Math., 32(3), 321–348. (183)
[234] Zimmermann, Paul. 1999. Karatsuba Square Root. Research Report 3805. IN-
RIA. http://hal.inria.fr/docs/00/07/28/54/PDF/RR-3805.
pdf. (45)
[235] Zuras, Dan. 1994. More on squaring and multiplying large integers. IEEE Trans-
actions on Computers, 43(8), 899–908. (41, 44)


Index
Abramowitz, Milton, 179, 180, 190
addition, 2, 91
carry bit, 10, 92
modular, 50
addition chain, xiv, 69
weighted, 77
Adleman, Leonard Max, 68
AGM, see arithmetic-geometric mean
Agrawal, Manindra, 45
Aho, Alfred Vaino, 46, 78
AKS primality test, 45
algorithm
AGM (for log), 159, 162
Akiyama–Tanigawa, 181
ApproximateReciprocal, 103, 119
ApproximateRecSquareRoot, 113
BackwardFFT, 54
Barrett’s, 58, 78, 109, 111, 119
BarrettDivRem, 59
BasecaseDivRem, 15, 41, 42
BasecaseMultiply, 4, 40
BaseKExp, 71
BaseKExpOdd, 72
D. Bernstein’s, 122
R. Bernstein’s, 14
binary splitting, 163
BinaryDivide, 34
BinaryGcd, 31
bit-burst, 167, 178
Bluestein’s, 78
Brent–Salamin, 159, 184
cryptographic, 68, 78
DivideByWord, 24
DivideNewton, 107, 111, 119, 122
DoubleDigitGcd, 31
Erf, 149, 175
EuclidGcd, 30
ExactDivision, 22, 122
ExtendedGcd, 33, 43
FastIntegerInput, 39, 43
FastIntegerOutput, 39
FastREDC, 62
FFTMulMod, 56
ForwardFFT, 53
FPadd, 92
FPmultiply, 96
FPSqrt, 111, 119
Friedland’s, 182
F¨urer’s, 57, 78
Gauss–Legendre, 159, 184
HalfBinaryGcd, 35, 43
HalfGcd, 43
IntegerAddition, 2
IntegerInput, 38
IntegerOutput, 38
IntegerToRNS, 73, 78

208
Index
IsPower, 29
KaratsubaMultiply, 5, 40
lazy, 2, 44
LeftToRightBinaryExp, 70, 76
LiftExp, 131
McLaughlin’s, 63–65, 77
ModularAdd, 50, 76
ModularInverse, 66
Montgomery’s, 60
MontgomerySvoboda, 62
Mulders’, 96
MultipleInversion, 67, 78
MultMcLaughlin, 64
OddEvenKaratsuba, 9, 41
off-line, 2, 44
on-line, 44
parallel, 46, 49, 67, 76, 77, 175,
180
Payne and Hanek, 101
PrintFixed, 116, 120
Rader’s, 78
RecursiveDivRem, 18, 42
REDC, 60
ReducedRatMod, 32, 46
relaxed, 2, 44
RightToLeftBinaryExp, 76
RNSToInteger, 74
RootInt, 27
RoundingPossible, 89
Sasaki–Kanada, 162, 181
Sch¨onhage–Strassen, 49, 55, 65,
78, 105, 122, 185
SecantNumbers, 176, 177, 181
SeriesExponential, 177
ShortDivision, 108, 111, 121
ShortProduct, 97, 121
SinCos, 166
SqrtInt, 27, 43, 45
SqrtRem, 26, 45
Strassen’s, 36, 123
SvobodaDivision, 17, 42
systolic, 46
TangentNumbers, 157, 176, 177,
181
ToomCook3, 7
UnbalancedDivision, 20, 42
unrestricted, 121, 125
zealous, 44
Ziv’s, 86
aliasing, 179
Andrews, George Eyre, 179, 180
ANU, xi
Apostol, Tom Mike, 180
ARC, xi
argument reduction, 101, 132–135
additive, 133
multiplicative, 133
arithmetic-geometric mean, 158–163
advantages, 158
complex variant, 163
drawbacks, 162
error term, 160
for elliptic integrals, 158
for logarithms, 159–162
optimization of, 162, 182
Sasaki–Kanada algorithm, 162
scaling factor, 161
theta functions, 160
Arndt, J¨org, xi, 181, 184
ARPREC, 187
Askey, Richard Allen, 179, 180
asymptotic equality notation ∼, xv
asymptotic expansions, 144, 180
asymptotic series notation, xv
Avizienis representation, 73
Bach, (Carl) Eric, 46
Bachmann, Paul Gustav Heinrich, 46
Backeljauw, Franky, 180
backward summation, 135, 138

Index
209
Bailey, David Harold, 183, 184, 187
balanced ternary, 119
Barrett’s algorithm, 58–60, 62, 77,
78, 109, 119
Barrett, Paul, 58, 59
base, xiv, 1, 80
conversion, 37, 190
Batut, Christian, 189
Becuwe, Stefan, 180
Beeler, Michael, 181
Belabas, Karim, 189
Bellard, Fabrice, 184
Bernardi, Dominique, 189
Bernoulli numbers, xiii, 147, 154,
156, 169, 176
Akiyama–Tanigawa
algorithm,
181
complexity of evaluation, 177
denominators of, 156
fast evaluation, 177
Harvey’s algorithm, 181
scaled, xiii
space required for, 169, 176
stable computation, 155, 176, 180
via tangent numbers, 156
Bernstein, Daniel Julius, 43, 45, 77,
78, 122, 123, 181
Bernstein, Joseph Naumovich, 183
Bernstein, Robert, 14
Berry, Michael Victor, 183
Bertot, Yves, 45
Bessel functions, 153
ﬁrst kind, Jν(x), 153
in computation of γ, 146, 184
Miller’s algorithm, 154
second kind, Yν(x), 153
Bessel’s differential equation, 153
Bessel, Friedrich Wilhelm, 152
B´ezout coefﬁcients, 32
B´ezout, ´Etienne, 32
Big O notation, xv
binary coded decimal (BCD), 81
binary exponentiation, 69, 70
binary number, notation for, xvi
binary representation, 1
conversion to decimal, 37
binary splitting, 163–166, 178, 185
CLN library, 182
for 1/π, ζ(3), 184
for sin/cos, 166
binary-integer decimal (BID), 81
binary64, 81, 83, 120
BinaryDivide, 34
binomial coefﬁcient, xiii, 43
bipartite modular multiplication, 77
bit reversal, 53, 54
bit-burst algorithm, 166–169, 178
Bluestein, Leo Isaac, 78
Bodrato, Marco, xi, 44, 119
Boldo, Sylvie, 118
Bonan-Hamada, Catherine, 180
Booth representation, 73, 78
Bornemann, Folkmar, 183, 184
Borodin, Allan Bertram, 45, 78
Borwein, Jonathan Michael, 159–
161, 181–184, 190
Borwein, Peter Benjamin, 159–161,
181–184, 190
Bostan, Alin, 122
branch prediction, 16
Brent, Erin Margaret, xi
Brent, Richard Peirce, 45, 121, 166,
182, 184
Brent–McMillan algorithm, 146, 184
Brent–Salamin algorithm, 159, 184
Briggs, Keith Martin, 45
Bruijn, see de Bruijn
Bulirsch, Roland Zdenˇek, 183
B¨urgisser, Peter, 41, 123
Burnikel, Christoph, 45

210
Index
butterﬂy operation, 53
C, 66, 186–189
C++, 185, 187, 189
cancellation, 138
Cannon, John Joseph, 188
carry bit, 10, 40, 92
catastrophic cancellation, 138
Cauchy principal value, xvi, 144
Cauchy’s theorem, 170
Cayley, 188
ceiling function ⌈x⌉, xv
Chen, Kwang-Wu, 181
Cheng, Howard, 184
Chinese
remainder
representation,
see modular representation
Chinese remainder theorem (CRT),
73–75, 78
explicit, 49
reconstruction, 74, 78
Chiu Chang Suan Shu, 45
Chudnovsky, David Volfovich, 166,
182, 184
Chudnovsky,
Gregory
Volfovich,
166, 182, 184
Chung, Jaewook, 45
classical splitting, 142
Clausen, Michael Hermann, 41, 123
Clausen, Thomas, 156, 181
Clenshaw, Charles William, 120, 180,
183
Clenshaw–Curtis quadrature, 183
Clinger, William Douglas, 123
CLN, 182, 185
Cohen, Henri, 45, 189
Collins, George Edwin, 121
complementary error function, see
erfc(x)
complex
AGM, 163
arithmetic, 187
multiplication, 163
square root, 182
squaring, 163
complexity
arithmetic, 3, 4
asymptotic, 8
bit, 4
concatenation, notation for, xvi, 38
continued fraction
approximant, 151
backward recurrence, 151, 175
error bound, 152, 175
fast evaluation, 175, 180
for E1, 150
for erfc, 150
forward recurrence, 151, 175
notation for, xvi, 150
regular, 30
contour integration, 169, 183
convolution, xiv, 78
convolution theorem, 50
cyclic, xiv, 76, 98
via FFT, 64, 99
Cook, Stephen Arthur, 44
Cornea-Hasegan,
Marius
Adrian,
122, 123
correct rounding ◦n, 85
cosh(x), 136
Cowlishaw, Mike, 123, 190
Crandall, Richard Eugene, 44, 122
Crary, Fred D., 183
CRT, see Chinese remainder theorem
cryptographic algorithm, 68, 78
Curtis, Alan R., 183
Cuyt, Annie, 180
D-ﬁnite, see holonomic
DBNS, 78
DDMF, 190

Index
211
de Bruijn, Nicolaas Govert (Dick),
180
decimal arithmetic, 81
decimal representation, 2
conversion to binary, 37
decimal64, 120
deg, xv
determinant, notation for, xvi
Detrey, J´er´emie, xi
DFT, see Discrete Fourier transform
differentiably ﬁnite, see holonomic
Difﬁe, Bailey Whitﬁeld, 68
Difﬁe–Hellman key exchange, 68
Dimitrov, Vassil S., 78
Discrete Fourier transform, 50, 64
notation for, xv
div notation, xiv
divide and conquer
for conversion, 38
for GCD, 33
for multiplication, 5
division, 14–25, 49
by a single word, 23, 42
classical versus Hensel, 24
divide and conquer, 18
Euclidean, 49
exact, 14, 21, 42
full, 14
Goldschmidt’s iteration, 123
modular, 65
notation for, xiv
paper and pencil, 25
SRT algorithm, 126, 128, 179
time for, D(n), xiv, 102
unbalanced, 19, 42
divisor
implicitly invariant, 60, 78
notation for, xiv
preconditioning, 17, 61
Dixon, Brandon, 44
DLMF, 190
double rounding, 90
double-base number system, 78
doubling formula, 133–136, 171, 172
for exp, 133
for sin, 133
for sinh, 136
versus tripling, 136, 179
Dupont, R´egis, 181
e, see Euler’s constant e
ECM, see elliptic curve method
Ehrhardt, Wolfgang, xi
Ein(x), 173
elementary function, 125–144
El Gamal, Taher, 68
El Gamal cryptosystem, 68
elliptic curve cryptography, 65
elliptic curve method, 77
elliptic integral, 158
ﬁrst kind, 158
modulus, 159
nome, 161
second kind, 158
email addresses, x
Enge, Andreas, 45, 119, 187
entire function, 140
Ercegovac, Milˇos Dragutin, 123
erf(x), 138, 148, 173
erfc(x), 139, 148, 150
error correction, 75
error function, see erf(x)
ESF, 190
Estrin, Gerald, 180
Euclid, 29
Euclidean algorithm, see GCD
Euler’s constant e, 184
Euler’s constant γ, 184
Brent–McMillan algorithm, 146,
184

212
Index
Euler–Maclaurin approx., 146
Euler’s totient function, xiv
Euler–Maclaurin formula, 146, 180
for computation of γ, 146
exp(x), see exponential
exponent, 79, 81, 83
exponential
addition formula, 133
binary splitting for, 182
expm1, 135, 172
notations for, xv
exponential integral, 144, 150, 173,
175
exponentiation
binary, 70
modular, 68–73
extended complex numbers bC, 151
fast Fourier transform (FFT), 8, 50,
65, 86, 122
Bluestein’s algorithm, 78
complex, 99
in place algorithm, 53
over ﬁnite ring, 99
padding, 58, 98
Rader’s algorithm, 78
rounding errors in, 99
use for multiplication, 58, 98
F´ejer, Leopold, 183
Fermat, Pierre de
little theorem, 69, 156
FFT, see fast Fourier transform
ﬁeld, ﬁnite, 77, 78
representation, 49
Figures
Figure 1.1, 12
Figure 1.2, 13
Figure 1.3, 20
Figure 1.4, 21
Figure 1.5, 24
Figure 2.1, 68
Figure 3.1, 95
Figure 3.2, 97
Figure 3.3, 100
Figure 3.4, 101
Figure 3.5, 110
ﬁnite ﬁeld, see ﬁeld
ﬂoating-point
addition, 91, 92, 121
binary64, 81
choice of radix, 121
comparison, 91
conversion, 114, 123
decimal, 114
division, 101
double precision, 81
encoding, 83
expansions, 86, 121
guard digits, 135
input, 117
level-index representation, 120
loss of precision, 134
multiplication, 95
output, 115
reciprocal, 101, 102, 122
reciprocal square root, 112
redundant representations, 120
representation, 79
sign-magnitude, 84
special values, 82
square root, 111
subtraction, 91, 93
via integer arithmetic, 86
ﬂoor function ⌊x⌋, xv
fmaa instruction, 40
folding, 63
Fortran, 187
forward summation, 135, 138
Fourier transform, see DFT
fraction, see signiﬁcand

Index
213
free format, 123
Friedland, Paul, 182
function, D-ﬁnite, see holonomic
function, elementary, see elementary
function, holonomic, see holonomic
function, special, see special
functional inverse, 125
F¨urer, Martin, 78
Gabcke sequence, 183
Gabcke, Wolfgang, 183
Galbraith, Steven Douglas, xi, 43
γ, see Euler’s constant γ
Gamma function Γ(x), 134, 137, 138,
147–150, 173, 174, 177, 183,
184
on imaginary axis, 174
Gathen, see von zur Gathen
Gaubatz, Gunnar, 77
Gaudry, Pierrick, 186
Gaunt, John Arthur, 183
Gauss, Johann Carl Friedrich, 46, 158
Gauss–Kuz’min theorem, 45
Gauss–Legendre algorithm, 159, 184
Gaussian quadrature, 183
Gautschi, Walter, 180
Gay, David M., 123
GCD, 29
algorithms for, 29
B´ezout coefﬁcients, 32
binary, 30, 49
cofactors, 32
continued fraction from, 30
divide and conquer, 33
double digit, 30, 33
Euclidean, 29, 45, 49
extended, 29, 32, 43, 65
half binary, 33
Lehmer’s algorithm, 29
multipliers, 32
notation for, xiv
plain, 29
Sorenson’s algorithm, 29
subquadratic, 33–37, 43
subtraction-only algorithms, 29
Gerhard, J¨urgen, 77
Girgensohn, Roland, 183
GMP, xi, 185, 188, 189
gnuplot, xi
Goldberg, David Marc, 121
Goldschmidt’s iteration, 123
Golliver, Roger Allen, 122
Goodwin, Charles E. T., 180
Gopal, Vinodh, 77
Gosper, Ralph William, Jr., 181
Gourdon, Xavier Richard, 183, 184
GP, 189
GPL, 185
Graham, Ronald Lewis, 181
Granlund, Torbj¨orn, xi, 42, 78, 185
greatest common divisor, see GCD
Grotefeld, Andreas Friedrich Wil-
helm, 122, 182
group operation
cost of, 77
notation for, 73
guard digits, 96, 118, 135
for AGM, 162
for Bernoulli numbers, 155, 170
for catastrophic cancellation, 138
for exp, 171
for subtraction, 94
for summation, 138
negative, 162
Haenel, Christoph, 184
Haible, Bruno, 182, 185
HAKMEM, 181
HalfBezout, 30
HalfBinaryGcd, 34, 65

214
Index
HalfGcd, 43
Hanek, Robert N., 101, 122
Hankerson, Darrel Richard, 78
Hanrot, Guillaume, xi, 40, 41, 45,
122, 184
harmonic number, xiii, 173
Hars, Laszlo, 77
Harvey, David, 39–41, 44, 45, 122,
123, 177, 178, 181, 182
Hasan, Mohammed Anwarul, 45
Hasenplaugh, William, 77
H˚astad, Johan Torkel, 41
Hellman, Martin Edward, 68
Hennessy, John LeRoy, 121
Hensel
division, 24–25, 45, 49, 58–61, 66
lifting, 21, 22, 32, 45, 49, 65
Hensel, Kurt Wilhelm Sebastian, 49
Heron of Alexandria, 129
Higham, Nicholas John, 121, 179
Hille, Einar Carl, 170
Hoeven, see van der Hoeven
holonomic function, 139, 167, 178,
183
Hopcroft, John Edward, 46, 78
Horner’s rule, 137, 142, 143
forward, 171
Horner, William George, 137
Householder, Alston Scott, 179
Hull, Thomas Edward, 121
Hurwitz zeta-function, 183
Hurwitz, Adolf, 183
hypergeometric function, 139, 159,
167
idempotent conversion, 123
IEEE 754 standard, 79, 121
extension of, 187
IEEE 854 standard, 121
iff, xiv
inﬁnity, ∞, ±∞, 82
INRIA, xi
integer
notation for, xv
integer division
notation for, xiv
integer sequences, 190
interval arithmetic, 188, 190
inversion
batch, 78
modular, 32, 65–68, 76
Iordache, Cristina S., 121
ISC, 190
Ispiryan, Karen R., 40
Jacobi symbol, 43, 46
notation for, xiv
subquadratic algorithm, 43, 46
Jacobi, Carl Gustav Jacob, 43
Jebelean, Tudor, 45, 46
Johnson, Jeremy Russell, 121
Jones, William B., 180
Jullien, Graham A., 78
Kahan, William Morton, 123
Kaihara, Marcelo Emilio, 77
Kanada, Yasumasa, 162, 181
Kaneko, Masanobu, 181
Karatsuba’s algorithm, 5–6, 40, 41,
44, 62, 163
in-place version, 40
threshold for, 40
Karatsuba, Anatolii Alekseevich, 41,
44, 62, 96
Karp, Alan Hersh, 22, 45, 122, 179
Karp–Markstein trick, 22, 45, 122,
179
Kayal, Neeraj, 45
Khachatrian, Gurgen H., 40, 45

Index
215
Khinchin,
Aleksandr
Yakovlevich,
45, 180
Kidder, Jeffrey Nelson, 118
Knuth, Donald Ervin, xi, 45, 46, 121,
122, 181
Koornwinder, Tom Hendrik, 183
Krandick, Werner, 45, 121
Kreckel, Richard Bernd, 185
Kronecker, Leopold, 44
Kronecker–Sch¨onhage trick, 3, 39,
42, 44, 49, 77
Kulisch, Ulrich Walter Heinz, 123
Kung, Hsiang Tsung, 46, 179
Kuregian, Melsik K., 40
Kuz’min, Rodion Osievich, 45
Lagrange interpolation, 6, 74
Lagrange, Joseph Louis, 6
Landen transformations, 163, 181
Landen, John, 163
Lang, Tomas, 122
Laurie, Dirk, 183, 184
lazy algorithm, 2, 44
leading zero detection, 94
Lecerf, Gr´egoire, 122
Lef`evre, Vincent, 45, 120, 121
Legendre, Adrien-Marie, 158, 184
Lehmer, Derrick Henry, 30, 45, 183
Lehmer–Gabcke sequence, 183
Lenstra, Arjen Klaas, 44
Lenstra, Hendrik Willem, Jr., 45
level-index arithmetic, 120
lg, see logarithm
LGPL, 186, 187
Lickteig, Thomas Michael, 123
lists versus arrays, 84
little o notation, xv
ln, see logarithm
Loan, see Van Loan
log, see logarithm
log1p, see logarithm
Logan, Benjamin Franklin “Tex”, Jr.,
181
logarithm
addition formula, 133
computation via AGM, 159
lg(x), ln(x), log(x), xv
log1p, 140, 172
notations for, xv
Sasaki–Kanada algorithm, 162
logical operations, xiv
LSB, 22, 24, 25, 29, 49
Luschny, Peter, 43
Lyness, James N., 183
machine precision, xiv
Maeder, Roman Erich, 40
Magaud, Nicolas, 45
Magma, 188
mailing lists, 189
mantissa, see signiﬁcand
Maple, 183, 188
Markstein, Peter, 22, 45, 122, 123,
179
Martin, David W., 180
MasPar, 44
Massey, James Lee, 40
Mathematica, 188
Mathematics Genealogy Project, xi
matrix multiplication, 41, 123
matrix notation, xv
Matula, David William, 121
Maze, G´erard, 45
MCA, 77
McLaughlin’s algorithm, 57, 58, 63–
65, 77
polynomial version, 77
McLaughlin, Philip Burtis, Jr., 40, 63,
77
McMillan, Edwin Mattison, 184

216
Index
Menezes, Alfred John, 78
M´enissier-Morain, Val´erie, 120
Mezzarobba, Marc, xi, 178
Microsoft, 186
middle product, 22, 41, 99
Mihailescu, Preda V., 77
Mikami, Yoshio, 45
Miller’s algorithm, 154, 175, 180
Miller, Jeffrey Charles Percy, 154,
180
Miller, William C., 78
mod notation, xiv
modular
addition, 50
division, 65
exponentiation, 68–73, 78
base 2k, 70
inversion, 32, 65–68, 76
multiplication, 58–65
splitting, 142
subtraction, 50
modular arithmetic
notation for, xiv
special moduli, 65, 78
modular representation, 73
comparison problem, 75
conversion to/from, 73
redundant, 75
sign detection problem, 75
Moenck, Robert Thomas, 45, 78
Moler, Cleve Barry, 183
M¨oller, Niels, 42, 43, 46, 78
Montgomery’s algorithm, 58
Montgomery’s form, 48, 60
Montgomery multiplication, 60–63
subquadratic, 62
Montgomery reduction, 25, 49
Montgomery, Peter Lawrence, 42, 48,
77, 78
Montgomery–Svoboda algorithm, 49,
61–63, 76, 77
Mori, Masatake, 183
MP, 179–181, 187
MPC, 187, 188
MPFI, 188
MPFQ, 186
MPFR, 187, 188
MPIR, 186
MSB, 21, 22, 24, 25, 29, 49
Mulders, Thom, 96, 119, 121
Muller, Jean-Michel, xi, 121–123,
179
multiplication
by a constant, 13
carry bit, 40
complex, 163
FFT range, 8
F¨urer’s algorithm, 78
Karatsuba’s algorithm, 163
modular, 58–65
of integers, 3–45
of large integers, 58
Sch¨onhage–Strassen, 49
schoolbook, 5
short product, 95
time for, M(n), xiv
unbalanced, 8–11, 41
complexity of, 11
via complex FFT, 98
multiplication chain, 69
weighted, 77
Munro, (James) Ian, 78
NaN, 82
quiet, 82
signaling, 82
nbits, xv
nearest integer function ⌊x⌉, xv
Neumann, Carl Gottfried, 153

Index
217
Newton’s method, 21, 25, 26, 49, 66,
102, 114, 125–132, 179
for functional inverse, 130, 139
for inverse roots, 127
for power series, 129
for reciprocal, 128
for reciprocal square root, 129
higher-order variants, 131
Karp–Marstein trick, 179
p-adic (Hensel lifting), 22
Newton, Isaac, 21, 49, 102, 125
Nicely, Thomas R., 128
NIST, 78
NIST Digital Library, 190
normalized divisor, 14
Not a Number (NaN), 82
Nowka, Kevin John, 121
NTL, 189
numerical differentiation, 183
numerical instability
in summation, 138
recurrence relations, 155
numerical quadrature, see quadrature
Nussbaumer, Henri Jean, 78
odd zeta-function, 157
odd–even scheme, 9, 45, 142, 171
Odlyzko, Andrew Michael, 183
Odlyzko–Sch¨onhage algorithm, 183
OEIS, 190
off-line algorithm, 2, 44
Olivier, Michel, 189
Olver, Frank William John, 120, 180
Omega notation Ω, xv
on-line algorithm, 44
Oorschot, see van Oorschot
ord, xv
Osborn, Judy-anne Heather, xi
Paar, Christof, 41
p-adic, 49
Pan, Victor Yakovlevich, 122
Papanikolaou, Thomas, 182, 184
PARI/GP, 189
Patashnik, Oren, 181
Paterson, Michael Stewart, 180
Patterson, David Andrew, 121
Payne and Hanek
argument reduction, 101, 122
Payne, Mary H., 101, 122
Pentium bug, 128, 179
Percival, Colin Andrew, 78, 119, 122
P´etermann,
Yves-Franc¸ois
Sap-
phorain, 183
Petersen, Vigdis Brevik, 180
phi function φ, xiv
π, 184
Brent–Salamin algorithm, 159, 181
Chudnovsky series, 184
Gauss–Legendre algorithm, 159
record computation, 184
Pila, Jonathan S., 45
Plouffe, Simon, 190
Pollard, John Michael, 77, 78
polylogarithm, 183
polynomial evaluation, 141
Pomerance, Carl, 44
power
computation of, 69
detection of, 28, 45
power series
argument reduction, 140
assumptions re coefﬁcients, 139
backward summation, 135, 137,
138
direct evaluation, 140
forward summation, 135, 137, 138
radius of convergence, 139
precision, xiv
local/global, 84

218
Index
machine, 137
operand/operation, 84, 121
reduced, 162
working, 90, 137
Priest, Douglas M., 86, 121
product tree, 67
pseudo-Mersenne prime, 65, 78
PV
R
, see Cauchy principal value
Python, 189
quadrature
Clenshaw–Curtis, 183
contour integration, 169
Gaussian, 183
numerical, 183
Romberg, 183
tanh-sinh, 183
Quercia, Michel, 40, 41, 122
Quisquater, Jean-Jacques, 77
quotient selection, 16, 18, 61
Rader, Charles M., 78
radix, xiv, 79–81
choice of, 80
mixed, 83
radix ten, 114
rational reconstruction, 37
reciprocal square root, 112, 129
rectangular series splitting, 141–144,
180
recurrence relations, 152
REDC, 60, 77
redundant representation
for error detection/correction, 75
for exponentiation, 73
for modular addition, 48
Reinsch, Christian, 180
relaxed algorithm, 2, 44
relaxed multiplication, 76
remainder tree, 43, 67
R´emy, Jean-Luc, 183
residue class representation, 47
residue number system, 48, 73, 77
Reyna, Juan Arias de, 183
Richardson extrapolation, 183
Richardson, Lewis Fry, 183
Riemann Hypothesis
computational veriﬁcation, 183
Riemann zeta-function, 147, 184
at equally spaced points, 183
at even integers, 157
Bernoulli numbers, 157
Borwein’s algorithm, 183
error analysis, 183
Euler–Maclaurin expansion, 147,
183
odd zeta-function, 157
Odlyzko–Sch¨onhage
algorithm,
183
Riemann–Siegel formula, 183
Riemann, Georg Friedrich Bernhard,
147
Rivest, Ronald Linn, 68
Rix, Anne, xi
RNS, see residue number system
Robertson, James Evans, 179
Roche, Daniel Steven, 40
Roegel, Denis, xi
Romberg quadrature, 183
Romberg, Werner, 183
root
kth, 27
Goldschmidt’s iteration, 123
inverse, 127
principal, 50
square, 25–26, 111
complex, 123, 182
paper and pencil, 25
wrap-around trick, 114
Rosser, John Barkley, 183

Index
219
rounding
away from zero, 87
boundary, 86
correct, 85, 137
double, 90
mode, 87, 121
notation for, xiv
probabilistic, 87
round bit, 88, 92
sticky bit, 88, 92, 121
stochastic, 87
strategies for, 90
to nearest, 82, 87–90
balanced ternary, 119
to odd, 118
towards zero, 87, 118
Von Neumann, 118
rounding mode ◦, 85–91
Roy, Ranjan, 179, 180
RSA cryptosystem, 68
runs of zeros/ones, 121
Ryde, Kevin, 40
Sage, 189
Salamin, Eugene, 181, 184
Salvy, Bruno, 178
Sasaki, Tateaki, 162, 181
Saxena, Nitin, 45
Schmid, Wolfgang Alexander, xi
Schmookler, Martin S., 121
Sch¨onhage, Arnold, xi, 43, 44, 46,
122, 171, 180, 182, 183
Sch¨onhage–Strassen algorithm, 49,
55, 65, 78, 105, 122, 185
Schost, ´Eric, 122, 171
Schroeppel, Richard Crabtree, 181
Sebah, Pascal, 184
secant numbers, 157, 177
Sedjelmaci, Sidi Mohamed, xi
Sedoglavic, Alexandre, 42
segmentation, see Kronecker–
Sch¨onhage trick
Sergeev, Igor S., 182
Shallit, Jeffrey Outlaw, 46
Shamir, Adi, 68
Shand, Mark Alexander, 45
Shokrollahi, Mohammad Amin, 41,
123
short division, 121
short product, 62, 95–98, 121
Shoup, Victor John, 43, 189
Sieveking, Malte, 179
sign, xv
sign-magnitude, 2, 47, 84, 91
signiﬁcand, 79, 83
sin(x), 133
sinh(x), 136
sliding window algorithm, 72
Sloane, Neil James Alexander, 190
Smith’s method, see rectangular
series splitting
Smith, David Michael, 180
software tools, 185
Sorenson, Jonathan Paul, 31, 46, 77,
78
special function, 125–184, 190
special moduli, 65, 78
splitting
classical, 142
modular, 142
square root, see root
squaring, 11, 41
complex, 163
SRT division, 126, 128, 179
Staudt, Karl Georg Christian von,
156, 181
Steel, Allan, 44
Steele, Guy Lewis, Jr., 123
Stegun, Irene Anne, 179, 180, 190
Stehl´e, Damien, 43, 46

220
Index
Stein, Josef, 45
Stein, William Arthur, 189
Sterbenz’s theorem, 94, 121
Sterbenz, Pat Holmes, 94, 121
sticky bit, 88, 121
Stirling numbers, 174, 181
Stirling’s approximation
convergent form, 174
for ln Γ(iy), 174
for ln Γ(x), 149
for ln Γ(z), 147
for n! or Γ(z), 134, 137, 138, 147,
177, 183
with error bounds, 146
Stirling, James, 134
Stockmeyer, Larry Joseph, 180
Stoer, Josef, 183
Strassen’s algorithm, 36
Strassen, Volker, 36, 123
strings
concatenation, xvi, 38
subnormal numbers, 82
smallest, xiv
substitution, see Kronecker–
Sch¨onhage trick
subtraction, 2, 91
guard digits, 94
leading zero detection, 94
modular, 50
summation
backward, 135, 138
forward, 135, 138
Svoboda’s algorithm, 17, 23, 42, 45,
49, 61, 63, 77
Svoboda, Antonin, 45, 49
Swartzlander, Earl E., Jr., 78, 179
Sweeney, Dura Warren, 179
Tables
Table 2.1, 49
Table 2.2, 63
Table 3.1, 89
Table 3.2, 93
Table 3.3, 100
Table 4.1, 164
Takagi, Naofumi, 77
Takahasi, Hidetosi, 183
tan(x), 133, 155
tangent numbers, xiii, 156, 176, 181
algorithm for, 156
complexity of evaluation, 177
space required for, 176
Tellegen’s principle, 122
Temme, Nico M., 179, 183
tensor rank, 41, 123
ternary system, 119
theta functions, 160
Theta notation Θ, xv
Th´eveny, Philippe, 187
Thom´e, Emmanuel, xi, 40, 41, 184,
186
Tocher, Keith Douglas, 179
Toom, Andrei Leonovich, 44
Toom–Cook multiplication, 6–7, 41
time for, 7
totient function, xiv
Traub, Joseph Frederick, 179
Trefethen, (Lloyd) Nicholas, 183, 184
tripling formula
for sin, 133
for sinh, 136
in FFT range, 136, 180
Ullman, Jeffrey David, 46, 78
unbalanced multiplication, 8–11, 41
unit in the last place (ulp), xiv, 80, 87
unrestricted algorithm, 121, 125
for exp, 180
Vall´ee, Brigitte, 46

Index
221
valuation, xiv
van der Hoeven, Joris, 44, 76, 122,
178, 182, 183
Van Loan, Charles Francis, 78
van Oorschot, Paul Cornelis, 78
Vandermonde matrix, 7
Vanstone, Scott Alexander, 78
vectors, notation for, xv
Vep˘stas, Linas, 183
Verdonk, Brigitte, 180
Vetter, Herbert Dieter Ekkehart, 122,
182
Vidunas, Raimundas, 183
Von Neumann, John (J´anos Lajos),
118
Von Staudt–Clausen theorem, 156,
181
von zur Gathen, Joachim, 77
Vuillemin, Jean ´Etienne, 41, 45
Waadeland, Haakon, 180
Wagon, Stanley (Stan), 183, 184
Waldvogel, J¨org, 183, 184
Wall, Hubert Stanley, 180
Wang, Paul Shyh-Horng, 46
Watson, George Neville, 180
Weber functions, Yν(x), 153
Weber, Heinrich Friedrich, 153
Weber, Kenneth, 46
Weimerskirch, Andr´e, 41
Wezelenburg, Mark, xi
White, Jim, 172
White, Jon L., 123
Whittaker, Edmund Taylor, 180
Wilkinson, James Hardy, 121, 179,
180
Winograd, Shmuel, 78
Wolfram, Stephen, 188
Wong, Roderick, 180
wrap-around trick, 60, 105
Yap, Chee-Keng, 46
Zanoni, Alberto, 44
zealous algorithm, 44
Zeilberger, Doron, 183
zero, ±0, 82, 84
ζ(3), 184
Ziegler, Joachim, 45
Zima, Eugene, 184
Zimmermann, Marie, xi
Zimmermann, Paul Vincent, 45, 46,
122, 184, 187
Ziv’s algorithm, 86
Zuras, Dan, 41, 44


Summary of complexities
Integer arithmetic (n-bit or (m, n)-bit input)
Addition, subtraction
O(n)
Multiplication
M(n)
Unbalanced multiplication (m ≥n)
M(m, n) ≤⌈m
n ⌉M(n), M( m+n
2
)
Division
O(M(n))
Unbalanced division (with remainder)
D(m + n, n) = O(M(m, n))
Square root
O(M(n))
kth root (with remainder)
O(M(n))
GCD, extended GCD, Jacobi symbol
O(M(n) log n)
Base conversion
O(M(n) log n)
Modular arithmetic (n-bit modulus)
Addition, subtraction
O(n)
Multiplication
M(n)
Division, inversion, conversion to/from RNS
O(M(n) log n)
Exponentiation (k-bit exponent)
O(kM(n))
Floating-point arithmetic (n-bit input and output)
Addition, subtraction
O(n)
Multiplication
M(n)
Division
O(M(n))
Square root, kth root
O(M(n))
Base conversion
O(M(n) log n)
Elementary functions
(in a compact set
O(M(n) log n)
excluding zeros and poles)

