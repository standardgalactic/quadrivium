
LOCATION OF VIDEONOTES IN THE TEXT
Chapter 1
Writing your first program with Visual C++ 2010 Express, p. 21
Opening and Executing an Example Program, p. 28
Programming Exercise 1: Creating a new program, p. 34
Chapter 2
Using cout, p. 39
Reading input with cin, p. 55
Assignment Statements and Simple Math Expressions, p. 61
Solving the Total Purchase Programming Problem, p. 83
Chapter 3
The if Statement, p. 89
The if-else statement, p. 97
The if-else-if statement, p. 109
Solving the Time Calculator Problem, p. 130
Chapter 4
The while Loop, p. 133
The for Loop, p. 143
Solving the Calories Burned Problem, p. 163
Chapter 6
Accesing array elements with a loop, p. 210
Passing an array to a function, p. 228
Solving the Total Sales problem, p. 249
Chapter 7
Copying the AGK Template Project and Opening It in Visual Studio, p. 259
The SpriteDemo Program, p. 267
Creating an Image with a transparent background, p. 280
Organizing the Images in your template Folder, p. 284
Solving the Moving Ball Problem, p. 313
Chapter 8
Working with the Mouse, p. 315
Working with Virtual Buttons, p. 323
Working with Virtual Joysticks, p. 329
Working with the Keyboard, p. 336
Working with Texture Atlases, p. 344
Working with Music and Sound, p. 348
Chapter 9
Working with Text Objects, p. 367
Sprite Collision Detection, p. 384
Simulating Falling Objects, p. 394
Chapter 10
Saving a Game’s High Score, p. 445
Using an Array as a Deck of Cards, p. 459
Tile Maps, p. 478
Solving the Bug Zapper Bonus Time Problem, p. 504
Chapter 11
The Balloon Target Game, p. 546
Solving the Coin Class Problem, p. 557
Appendix A
Installing the required software, p. 559
VideoNote

This page intentionally left blank 

 Boston Columbus Indianapolis New York San Francisco Upper Saddle River
Amsterdam Cape Town Dubai London Madrid Milan Munich Paris Montreal Toronto
Delhi Mexico City Sao Paulo Sydney Hong Kong Seoul Singapore Taipei Tokyo  
 Tony Gaddis
Haywood Community College  
 Games & Graphics
                  in C++ 
 Second 
Edition 
 Starting Out with 

 Editorial Director: Marcia Horton 
 Acquisitions Editor: Matt Goldstein 
 Editorial Assistant: Jenah Blitz-Stoehr 
 Director of Marketing: Christy Lesko  
 Marketing Manager: Yez Alayan 
 Marketing Coordinator: Kathryn Ferranti 
 Director of Production: Erin Gregg 
 Managing Editor: Jeff Holcomb 
 Production Project Manager: 
Kayla Smith-Tarbox 
 Operations Supervisor: Nick Sklitsis 
 Manufacturing Buyer: Lisa McDowell 
 Art Director: Anthony Gemmellaro 
 Cover Designer: Studio Montage 
 Manager, Visual Research: Karen Sanatar 
 Photo Researcher: Christa Tilly 
 Manager, Rights and Permissions: 
Michael Joyce 
 Text Permission Coordinator: Sara Smith, 
Creative Compliance 
 Cover Illustration/Art: Studio Montage 
 Lead Media Project Manager: Renata Butera 
 Full-Service Project Management: 
Aptara®, Inc. 
 Composition: Aptara®, Inc. 
 Printer/Binder: Edwards Brothers 
 Cover Printer: Lehigh-Phoenix 
Color/Hagerstown 
 Text Font: Sabon LT Std 
 Credits and acknowledgments borrowed from other sources and reproduced, with permission, in 
this textbook appear on the appropriate page within text.  
 Copyright © 2014, 2010 by Pearson Education, Inc., publishing as Prentice Hall. All rights reserved. 
Manufactured in the United States of America. This publication is protected by Copyright, and 
permission should be obtained from the publisher prior to any prohibited reproduction, storage in a 
retrieval system, or transmission in any form or by any means, electronic, mechanical, photocopying, 
recording, or likewise. To obtain permission(s) to use material from this work, please submit a written 
request to Pearson Education, Inc., Permissions Department, One Lake Street, Upper Saddle River, 
New Jersey 07458, or you may fax your request to 201-236-3290. 
 Many of the designations by manufacturers and sellers to distinguish their products are claimed 
as trademarks. Where those designations appear in this book, and the publisher was aware of a 
trademark claim, the designations have been printed in initial caps or all caps.  
 Library of Congress Cataloging-in-Publication Data
Gaddis, Tony.
 [Starting out with games and graphics in C++]
 Gaddis starting out with games and graphics in C++ / Tony Gaddis, Haywood 
Community College. —2e.
  pages cm
 Includes bibliographical references and index.
 ISBN 978-0-13-312807-9 (alk. paper)—ISBN 0-13-312807-5 (alk. paper)
 1. Computer programming. 2. Computer games—Programming. 3. Computer 
graphics. 4. C++ (Computer program language) I. Title. 
 QA76.6.G3148 2014
 005.13'3—dc23
 
2012034982 
 10 9 8 7 6 5 4 3 2 1 
 ISBN 10: 0-13-312807-5 
 ISBN 13: 978-0-13-312807-9  

v
 Preface   ix  
 PART 1 
 INTRODUCTION TO STANDARD C++   xv  
 Chapter 1 
 Introduction to Computers and Programming   1 
 1.1  Introduction   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1 
 1.2  Hardware   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  2 
 1.3  How Computers Store Data   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  6 
 1.4  How a Program Works   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  11 
 1.5  C++ and the App Game Kit Library . . . . . . . . . . . . . . . . . . . . . . . . . . . .  19 
 IN THE SPOTLIGHT:   Writing Your First Program with Visual 
C++ 2010 Express . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  21 
 IN THE SPOTLIGHT:   Opening and Executing an Example Program . . . . . . . . . . .  28 
 Review Questions   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  30 
 Programming Exercises  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  34 
 Chapter 2 
 C++ Fundamentals   37  
 2.1  The Parts of a C++ Program   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  37 
 2.2  Displaying Screen Output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  39 
 2.3  More about the #include Directive   . . . . . . . . . . . . . . . . . . . . . . . . . . .  45 
 2.4  A First Look at Variables   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  46 
 2.5  Reading Keyboard Input . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  55 
 2.6  Comments, Blank Lines, and Indentation   . . . . . . . . . . . . . . . . . . . . . . .  58 
 2.7  Performing Calculations and Working with Numbers   . . . . . . . . . . . . . .  60 
 IN THE SPOTLIGHT:   Calculating Percentages and Discounts . . . . . . . . . . . . . . . .  68 
 IN THE SPOTLIGHT:   Calculating an Average . . . . . . . . . . . . . . . . . . . . . . . . . . . .  69 
 2.8  Named Constants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  71 
 2.9  Math Functions in the Standard Library   . . . . . . . . . . . . . . . . . . . . . . . .  74 
 2.10  Working with Strings   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  76 
 2.11  The char Data Type   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  79 
 Review Questions   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  80 
 Programming Exercises  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  83 
 Contents 

vi 
Contents
 Chapter 3 
 Decision Structures and Boolean Logic   87  
 3.1  Control Structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  87 
 3.2  Writing a Decision Structure with the if Statement   . . . . . . . . . . . . . . .  89 
 IN THE SPOTLIGHT:  Using the if Statement . . . . . . . . . . . . . . . . . . . . . . . . . . . .  95 
 3.3  The if-else Statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  97 
 IN THE SPOTLIGHT:   Using the if-else Statement   . . . . . . . . . . . . . . . . . . . . . .  100 
 3.4  Nested Decision Structures and the if-else-if Statement . . . . . . . . .  101 
 IN THE SPOTLIGHT:   Multiple Nested Decision Structures . . . . . . . . . . . . . . . . .  107 
 3.5  Logical Operators   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  112 
 3.6  The switch Statement   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  116 
 IN THE SPOTLIGHT:   Using a switch Statement . . . . . . . . . . . . . . . . . . . . . . . . .  119 
 3.7  bool Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  121 
 3.8  Comparing Strings   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  122 
 Review Questions   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  124 
 Programming Exercises  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  128 
 Chapter 4 
 Repetition Structures   131  
 4.1  Introduction to Repetition Structures   . . . . . . . . . . . . . . . . . . . . . . . . .  131 
 4.2  Condition-Controlled Loops: The while and do-while Loops . . . . . . .  132 
 IN THE SPOTLIGHT:   Writing a Program with a while Loop . . . . . . . . . . . . . . .  137 
 4.3  The Increment and Decrement Operators . . . . . . . . . . . . . . . . . . . . . .  141 
 4.4  Count-Controlled Loops: The for Loop   . . . . . . . . . . . . . . . . . . . . . . .  143 
 IN THE SPOTLIGHT:   Writing a Count-Controlled for Loop  . . . . . . . . . . . . . . .  149 
 4.5  Calculating a Running Total   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  152 
 4.6  Nested Loops   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  155 
 IN THE SPOTLIGHT:   Using Nested Loops to Print Patterns   . . . . . . . . . . . . . . . .  156 
 Review Questions   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  161 
 Programming Exercises  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  163  
 Chapter 5 
 Functions   167  
 5.1  Introduction to Functions   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  167 
 5.2  void Functions   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  169 
 5.3  Local Variables   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  174 
 5.4  Passing Arguments to Functions   . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  176 
 5.5  Global Variables and Global Constants   . . . . . . . . . . . . . . . . . . . . . . . .  184 
 IN THE SPOTLIGHT:   Using Global Constants and Reference Parameters . . . . . .  186 
 5.6  Value-Returning Functions   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  188 
 IN THE SPOTLIGHT:   Writing Value-Returning Functions . . . . . . . . . . . . . . . . . .  192 
 5.7  Calling string Class Member Functions . . . . . . . . . . . . . . . . . . . . . . .  197 
 Review Questions   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  198 
 Programming Exercises  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  201 

 
Contents 
vii
 Chapter 6 
 Arrays  205  
 6.1  Array Basics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  205 
 IN THE SPOTLIGHT:   Using Array Elements in a Math Expression . . . . . . . . . . .  214 
 6.2  Sequentially Searching an Array   . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  216 
 6.3  Processing the Contents of an Array   . . . . . . . . . . . . . . . . . . . . . . . . . .  220 
 IN THE SPOTLIGHT:   Processing an Array . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  233 
 6.4  Parallel Arrays   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  237 
 6.5  Two-Dimensional Arrays   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  239 
 6.6  Arrays of Three or More Dimensions . . . . . . . . . . . . . . . . . . . . . . . . . .  246 
 Review Questions   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  247 
 Programming Exercises  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  249 
 PART 2 
 INTRODUCTION TO GAME PROGRAMMING 
WITH C++ AND APP GAME KIT   253  
 Chapter 7 
 Using the App Game Kit with C++   255  
 7.1  The App Game Kit and the Structure of a Game Program . . . . . . . . . .  255 
 TUTORIAL:   Copying the AGK Template Project and Opening 
It in Visual Studio . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  259 
 7.2  The Screen Coordinate System  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  262 
 7.3  Displaying Sprites   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  266 
 7.4  Working in the Game Loop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  286 
 7.5  Working with Colors and Transparency . . . . . . . . . . . . . . . . . . . . . . . .  296 
 7.6  Displaying Text in the AGK Window . . . . . . . . . . . . . . . . . . . . . . . . . .  300 
 7.7  Generating Random Numbers   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  305 
 IN THE SPOTLIGHT:   Using Random Numbers to Position a 
Sprite and Set its Transparency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  307 
 Review Questions   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  310 
 Programming Exercises  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  313 
 Chapter 8 
 Input, Animation, and Sound   315  
 8.1  The Mouse   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  315 
 8.2  Virtual Buttons   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  322 
 8.3  Virtual Joysticks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  329 
 8.4  The Keyboard   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  336 
 8.5  Animation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  340 
 8.6  Music and Sound   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  348 
 8.7  The Bug Zapper Game   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  353 
 IN THE SPOTLIGHT:   The Bug Zapper Game   . . . . . . . . . . . . . . . . . . . . . . . . . . .  354 
 Review Questions   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  362 
 Programming Exercises  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  364 

viii 
Contents
 Chapter 9 
 Text, Collisions, and the Vulture Trouble Game   367  
 9.1  Text Objects   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  367 
 9.2  Sprite Collision Detection   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  384 
 IN THE SPOTLIGHT:   The PizzaBot Game . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  388 
 9.3  Simulating Falling Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  394 
 9.4  The Vulture Trouble Game   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  403 
 Review Questions   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  431 
 Programming Exercises  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  434 
 Chapter 10  Using Files and Arrays with the AGK   437  
 10.1  File Input and Output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  437 
 IN THE SPOTLIGHT:   Saving a Game’s High Score   . . . . . . . . . . . . . . . . . . . . . . .  445 
 IN THE SPOTLIGHT:   Detecting the End of a File   . . . . . . . . . . . . . . . . . . . . . . . .  451 
 IN THE SPOTLIGHT:   Writing a Log File . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  455 
 10.2  Using Arrays in an AGK Program . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  459 
 IN THE SPOTLIGHT:   Using an Array as a Deck of Cards . . . . . . . . . . . . . . . . . .  459 
 IN THE SPOTLIGHT:   Shuffling an Array . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  465 
 10.3  Tile Maps   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  478 
 Review Questions   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  501 
 Programming Exercises  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  504 
 Chapter 11  Object-Oriented Programming   507  
 11.1  Procedural and Object-Oriented Programming . . . . . . . . . . . . . . . . . .  507 
 11.2  Classes and Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  510 
 11.3  Inheritance   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  537 
 IN THE SPOTLIGHT:   An Object-Oriented Game: Balloon Target . . . . . . . . . . . .  546 
 Review Questions   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  554 
 Programming Exercises  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  557 
 Appendix A  Downloading and Installing the 
Required Software   559  
 Index   565  
 Credits  575  

ix
 W
elcome to the second edition of  Starting Out with Games and Graphics in 
C++ . This book teaches the traditional topics of an introductory program-
ming course using C++, along with simple game development using a 
library known as the App Game Kit. Students using this book will start writing tra-
ditional, console-based programs with Microsoft Visual C++. Once the fundamentals 
of procedural programming have been covered, the student learns to use the App 
Game Kit library to develop simple games in C++, as well as programs that use graph-
ics and animation. The examples and assignments are designed to excite and motivate 
students and to keep them engaged throughout the semester. 
 New to This Edition 
 ● The second edition of this book is a complete revision of the first edition. Reviewers 
of the first edition overwhelmingly expressed that their students needed more 
knowledge of standard C++ to be adequately prepared for subsequent courses. To 
address this concern, the second edition is divided into two parts:
● Part 1 ( Chapters   1 through  6 ) covers the fundamentals of procedural pro-
gramming using standard C++.
● Part 2 ( Chapters   7 through   11 ) covers graphics and game programming using 
C++ and the App Game Kit. Part 2 also covers file I/O and introduces object-
oriented programming. 
 ● Another change in the second edition is the use of the App Game Kit Tier 2, 
instead of the Dark GDK. The App Game Kit is the latest development envi-
ronment from The Game Creators. It is designed to create games for Windows, 
as well as a variety of smartphones and tablets. The App Game Kit is avail-
able in two “tiers.”
● Tier 1 provides an integrated development environment that supports a 
BASIC-like programming language.
● Tier 2 provides a C++ library that is compatible with Microsoft Visual C++ 
2010. In Part 2 of this book we use the App Game Kit Tier 2, along with 
Microsoft Visual C++ 2010. (Although the App Game Kit is a commercial 
product, The Game Creators provide a free trial version that includes Tier 
2. The trial version is not time restricted, but it does display a small water-
mark on the screen. You can use either the trial version or the full com-
mercial version with this book.) 
 ● A set of online VideoNotes have also been developed for use with this book. 
The VideoNotes provide short explanations of various topics in the book, 
coding demonstrations, and walkthroughs of selected programming problems 
at the end of each chapter.  
 Preface 

x 
Preface
 Required Software 
 To use this book, you will need the following software and files: 
 ●  Microsoft Visual C++ 2010 
 
When purchased new, this book includes a DVD containing Microsoft Visual 
C++ 2010 Express Edition. If your book does not have the DVD, you can 
download this software. See  Appendix  A for instructions.  
 ●  The App Game Kit (AGK) Tier 2 
 
The App Game Kit Tier 2 must be downloaded and installed from The Game 
Creators’ Web site. A free trial version is available, as well as a commercial version. 
See  Appendix   A for specific instructions.  
 ●  Sample Source Code and Media Files 
 
The source code for the book’s example programs, as well as graphics, audio files, 
and game case studies, are available for download from the publisher’s Web site. 
See  Appendix   A for instructions.  
 Brief Overview of Each Chapter 
 PART 1: INTRODUCTION TO STANDARD C++ 
 Chapter   1 : Introduction to Computers and Programming   
 This chapter begins by giving a very concrete and easy-to-understand explanation of 
how computers work, how data is stored and manipulated, and why we write pro-
grams in high-level languages. Step-by-step tutorials are given that get the student 
started using Visual C++.  
 Chapter   2 : C++ Fundamentals   
 This chapter introduces the student to the fundamental concepts needed to write 
simple C++ programs that display output, gather input, and perform calculations. 
Variables, data types, literals, and named constants are introduced. The student learns 
to use stream input and output and write math expressions.  
 Chapter   3 : Decision Structures and Boolean Logic   
 In this chapter the student learns about relational operators and Boolean expressions 
and is shown how to control the flow of a program with decision structures. The  if , 
 if - else , and  if - else - if statements are covered. Nested decision structures, logical 
operators, and the  switch statement are also discussed.  
 Chapter   4 : Repetition Structures   
 This chapter shows the student how to create repetition structures using the  while 
loop, the  do-while loop, and  for loop. Examples are shown using counters, accumu-
lators, and running totals.  

 
Preface 
xi
 Chapter   5 : Functions   
 In this chapter the student first learns how to write and call void functions, showing 
the benefits of using functions to modularize programs. Then, the student learns to 
pass arguments to functions. Passing by value and by reference are discussed. Local 
and global variables and constants are also discussed. Finally, the student learns to 
write value-returning methods.  
 Chapter   6 : Arrays  
 In this chapter the student learns to create and work with one- and two-dimensional 
arrays. Many examples of array processing are provided, including examples illustrat-
ing how to find the sum, average, and highest and lowest values in an array. Program-
ming techniques using parallel arrays are also demonstrated.  
 PART 2: INTRODUCTION TO GAME PROGRAMMING WITH 
C++ AND APP GAME KIT 
 Chapter   7 : Using the App Game Kit with C++   
 This chapter introduces the student to program development using Visual C++ and 
the App Game Kit (AGK) Tier 2. It starts by introducing the structure of a C++ pro-
gram that is written with the AGK, including the game loop. The game loop is a 
special loop that constantly runs, controlling all the action in a game. The screen 
coordinate system that is used by the AGK to map the locations of pixels is intro-
duced. The student learns to load graphic images from files and create sprites that can 
be displayed and manipulated on the screen. The student also learns how colors are 
produced using the RGB color system and how an alpha channel determines transpar-
ency. The student learns about simple AGK functions for displaying text, and generat-
ing random numbers.  
 Chapter   8 : Input, Animation, and Sound   
 This chapter introduces various ways to get user input in a game or other program 
developed with the AGK. Functions and programming techniques for using the 
mouse, virtual buttons, virtual joysticks, and reading keystrokes on the keyboard are 
covered. Then, the chapter discusses techniques for displaying animations using ani-
mated sprites and texture atlases. A discussion of playing music and sound in a pro-
gram is presented. The chapter concludes with the BugZapper game, in which the user 
attempts to click randomly appearing bugs as fast as possible.  
 Chapter   9 : Text, Collisions, and the Vulture Trouble Game   
 This chapter begins with a discussion of text objects, which give the programmer 
greater control over text that is displayed in an AGK window. Next, the chapter dis-
cusses collision detection between sprites and demonstrates a simple game named 
PizzaBot. Next the student learns how perform the calculations necessary to simulate 
the motion of an object falling toward Earth. This is all finally brought together in 
the Vulture Trouble game. Vulture Trouble is a high-quality video game that incor-
porates all the programming skills that the student has learned to this point.  

xii 
Preface
 NOTE:  Notes appear at several places throughout the text. They are short expla-
nations of interesting or often misunderstood points relevant to the topic at hand.  
 WARNING:  Warnings caution students about programming techniques or prac-
tices that can lead to malfunctioning programs or lost data.  
 Chapter   10 : Using Files and Arrays with the AGK   
 This chapter begins by discussing sequential file input and output, using the AGK file 
functions. Examples include storing a set of random colors in a file, saving a game’s 
high score, and writing a log file. Next, the chapter discusses how arrays can be used 
to hold sprite or image indices, using examples that simulate dealing, shuffling, and 
sorting a deck of cards. The chapter also demonstrates how to use two-dimensional 
arrays to map tiles (small rectangular images) to the screen to make the background 
for a game.  
 Chapter   11 : Object-Oriented Programming   
 This chapter compares procedural and object-oriented programming practices. It covers 
the fundamental concepts of classes and objects. Member variables, member functions, 
access specification, constructors, accessors, and mutators are discussed. The chapter 
also introduces inheritance. An object-oriented game named Balloon Target is presented.  
 Appendix   A : Downloading and Installing the Required Software 
 This appendix is a guide for downloading and installing all the software and files that 
are necessary to use this book.  
 Answers to Checkpoints (available online) 
 This file gives the answers to the checkpoint questions that appear throughout the text.  
 Features of the Text 
 Concept Statements.  Each major section of the text starts with a concept state-
ment. This statement concisely summarizes the main point of the section.  
 Example Programs.  Each chapter has an abundant number of complete and par-
tial example programs, each designed to highlight the current topic.  
 VideoNotes.  Online videos developed specifically for this book are available for 
viewing at  www.pearsonhighered.com/gaddis . Icons appear throughout the text alert-
ing the student to videos about specific topics.  
 In the Spotlight.  Numerous  In the Spotlight sections 
appear throughout the book. These provide detailed discus-
sions and examples of how certain programming techniques 
can be applied to specific applications.  
VideoNote

 
Preface 
xiii
 Review Questions.  Each chapter presents a thorough and diverse set of review 
questions and exercises. They include Multiple Choice, True/False, Algorithm Work-
bench, and Short Answer.  
 Programming Exercises.  Each chapter offers a pool of programming exercises 
designed to solidify the student’s knowledge of the topics currently being studied.  
 Supplements 
 Microsoft Visual Studio 2010 Express Edition 
 When purchased new, this book comes with Visual Studio 2010 Express Edition on 
an accompanying DVD. This DVD provides a suite of software development tools, 
including Visual C++ 2010 Express Edition. If your book does not have the DVD, you 
can download the software. See  Appendix   A for more information.  
 Online Resources 
 This book’s online resource page contains numerous student supplements. To access 
these supplements, go to  www.pearsonhighered.com/gaddis , and click on the image of 
this book’s cover. You will find the following items: 
 ●  A link to download the trial version of the App Game Kit  
 ●  Source code for all the book’s example programs  
 ●  Graphics and audio files that can be used in student projects  
 ●  Access to the book’s companion VideoNotes  
 ●  Answers to the Checkpoint questions  
 Instructor Resources 
 The following supplements are available to qualified instructors only: 
 ●  Answers to the Review Questions  
 ●  Solutions for the exercises  
 ●  PowerPoint presentation slides for each chapter  
 Visit the Pearson Instructor Resource Center ( www.pearsonhighered.com/irc ) or send 
an e-mail to computing@pearson.com for information on how to access them.  
 Acknowledgments 
 I would like to thank The Game Creators for developing the App Game Kit, a power-
ful game development environment that is simple enough for beginning students. I 
would also like to thank Christopher Rich for his invaluable contributions to this 
book. His work on the second half of the book, knowledge of the App Game Kit, and 
original artwork and media helped make this book what it is. Thanks Chris! 
 I also want to thank everyone at Pearson Education for making the  Starting Out with 
series so successful. I have worked so closely with the team at Pearson Education that 
 Checkpoint.  Checkpoints are questions placed at intervals throughout each chapter. 
They are designed to query the student’s knowledge quickly after learning a new topic.  

xiv 
Preface
I consider them among my closest friends. I am extremely grateful that Matt Gold-
stein is my editor. He and Emma Snider, editorial assistant, guided me through the 
process of revising this book. I am also fortunate to have Yez Alyan as marketing 
manager and Kathryn Ferranti as marketing coordinator. They do a great job getting 
my books out to the academic community. The production team, led by Kayla Smith-
Tarbox, worked tirelessly to make this book a reality. Thanks to you all!  
 About the Author 
 Tony Gaddis is the principal author of the  Starting Out with series of textbooks. 
Tony has nearly twenty years of experience teaching computer science courses, pri-
marily at Haywood Community College. He is a highly acclaimed instructor who was 
previously selected as the North Carolina Community College “Teacher of the Year” 
and has received the Teaching Excellence award from the National Institute for Staff 
and Organizational Development. The  Starting Out with series includes introductory 
books covering C++, Java™, Microsoft® Visual Basic®, Microsoft® C#®, Python, 
Programming Logic and Design, and Alice, all published by Pearson Education.  

xv
PART
1
Introduction to Standard C++

This page intentionally left blank 

1
 
1.1  Introduction 
 The goal of this book is to teach computer programming in a fun and interesting way. 
It is assumed that you are a beginner, with little or no programming experience. You 
might have noticed that this book is divided into two parts. In Part 1, you will learn 
to write simple C++ programs that display text on the screen, read input from the 
keyboard, and perform basic calculations. In Part 2, you will advance your knowledge 
by writing programs that are graphical, interactive, and game-like. 
 A  program is a set of instructions that a computer follows to perform a task. Programs 
are commonly referred to as  software . Software is essential to a computer because with-
out software, a computer can do nothing. All the software that we use to make our 
computers useful (and entertaining) is created by individuals known as programmers or 
software developers. A  programmer , or  software developer , is a person with the training 
and skills necessary to design, create, and test computer programs. Computer program-
ming is an exciting and rewarding career. In addition to creating computer games, you 
will find programmers working in business, medicine, government, law enforcement, 
agriculture, academics, telecommunications, and almost every other field. 
 Before we begin to explore the concepts of programming, you need to understand a 
few basics about computers and how they work. This chapter will build a solid foun-
dation of knowledge that you will continually rely on as you study computer science. 
First, we will discuss the physical components of computers. Next, we will look at 
how computers store data and how programs work. Finally, we will discuss the spe-
cific tools that you will use in this book to create games and graphical programs: the 
C++ language and the App Game Kit library.  
 1.1  Introduction    
 1.2  Hardware     
 1.3  How Computers Store Data    
 1.4  How a Program Works    
 1.5  C++ and the App Game Kit Library    
 TOPICS 
 Introduction to Computers 
and Programming 
1 
 CHAPTER

2 
Chapter 1 
 Introduction to Computers and Programming
 
1.2  Hardware 
 CONCEPT:   The physical devices that a computer is made of are referred to as the 
computer’s hardware. Most computer systems are made of similar 
hardware devices.  
 The term  hardware refers to all the physical devices, or  components , of a computer. A 
computer is not one single device, but rather a system of devices that work together. 
Like the different instruments in a symphony orchestra, each device in a computer 
plays its own part. 
 If you have ever shopped for a computer, you’ve probably seen sales literature listing 
components such as microprocessors, memory, disk drives, video displays, graphics 
cards, and so forth. Unless you already know a lot about computers, or at least have 
a friend who does, understanding what these different components do might be chal-
lenging. As shown in  Figure  1-1 , a typical computer system consists of the following 
major components: 
 ●  The central processing unit (CPU)  
 ●  Main memory  
 ●  Secondary storage devices  
 ●  Input devices  
 ●  Output devices  
 Let’s take a closer look at each of these components.  
Input
Devices
Output
Devices
Secondary
Storage Devices
Central Processing
Unit
Main Memory
(RAM)
 Figure 1-1  Typical components of a computer system  

 
1.2 Hardware 
3
 The CPU 
 When a computer is performing the tasks that a program tells it to do, we say that 
the computer is  running or  executing the program. The  central processing unit , or 
 CPU , is the part of a computer that actually runs programs. The CPU is the most 
important component in a computer because without it, the computer could not 
run software. 
 In the earliest computers, CPUs were huge devices made of electrical and mechanical 
components such as vacuum tubes and switches.  Figure   1-2 shows such a device. The 
two women in the photo are working with the historic ENIAC computer. The  ENIAC 
is considered by many as the world’s first programmable electronic computer and 
was built in 1945 to calculate artillery ballistic tables for the U.S. Army. This 
machine, which was primarily one big CPU, was 8 feet tall and 100 feet long and 
weighed 30 tons.  
 Figure 1-2  The ENIAC computer (U.S. Army photo)  
 Today, CPUs are small chips known as  microprocessors .  Figure   1-3 shows a lab tech-
nician holding a modern-day microprocessor. In addition to being much smaller than 
the old electromechanical CPUs in early computers, microprocessors are also much 
more powerful.  
 Main Memory 
 You can think of  main memory as the computer’s work area. This is where the com-
puter stores a program while the program is running, as well as the data that the 
program is working with. For example, suppose you are using a word processing 
program to write an essay for one of your classes. While you do this, both the word 
processing program and the essay are stored in main memory. 

4 
Chapter 1 
 Introduction to Computers and Programming
 Main memory is commonly known as  random-access memory , or  RAM . It is called 
this because the CPU is able to access data stored at any random location in RAM 
quickly. RAM is usually a  volatile type of memory that is used only for temporary 
storage while a program is running. When the computer is turned off, the contents of 
RAM are erased. Inside your computer, RAM is stored in chips, similar to the ones 
shown in  Figure   1-4 . 
 Figure 1-3  A lab technician holds a modern microprocessor 
(photo courtesy of Intel Corporation)  
 Figure 1-4  Memory chips  
 Secondary Storage Devices 
 Secondary storage is a type of memory that can hold data for long periods of time, 
even when there is no power to the computer. Programs are normally stored in sec-
ondary memory and loaded into main memory as needed. Important data, such as 
word processing documents, payroll data, and inventory records, is saved to second-
ary storage as well. 
 The most common type of secondary storage device is the disk drive. A  disk drive 
stores data by magnetically encoding it onto a circular disk. Most computers have a 

 
1.2 Hardware 
5
disk drive mounted inside their case. External disk drives, which connect to one of the 
computer’s communication ports, are also available. External disk drives can be used 
to create backup copies of important data or to move data to another computer. 
 In addition to external disk drives, many types of devices have been created for 
copying data and for moving it to other computers. For many years floppy disk 
drives were popular. A  floppy disk drive records data onto a small floppy disk, 
which can be removed from the drive. Floppy disks have many disadvantages, 
however. They hold only a small amount of data, and are very slow. The use of 
floppy disk drives has declined dramatically in recent years, in favor of superior 
devices such as universal serial bus (USB) drives.  USB drives are small devices that 
plug into a computer’s USB port and appear to the system as a disk drive. These 
drives do not actually contain a disk, however. They store data in a special type of 
memory known as  flash memory . USB drives, which are also known as  memory 
sticks and  flash drives , are inexpensive, reliable, and small enough to be carried in 
your pocket. 
 Optical devices such as the  CD (compact disc) and the  DVD (digital versatile disc) are 
also popular for data storage. Data is not recorded magnetically on an optical disc, 
but is encoded as a series of pits on the disc surface. CD and DVD drives use a laser 
to detect the pits and thus read the encoded data. Optical discs hold large amounts of 
data, and because recordable CD and DVD drives are now common, they are good 
mediums for creating backup copies of data.  
 Input Devices 
 Input is any data the computer collects from people and from other devices. The 
component that collects the data and sends it to the computer is called an  input de-
vice . Common input devices are the keyboard, mouse, joystick, scanner, microphone, 
and digital camera. Disk drives and optical drives can also be considered input devices 
because programs and data are retrieved from them and loaded into the computer’s 
memory.  
 Output Devices 
 Output is any data the computer produces for people or for other devices. It might be 
a sales report, a list of names, or a graphic image. The data is sent to an  output device , 
which formats and presents it. Common output devices are video displays and print-
ers. Disk drives and CD/DVD recorders can also be considered output devices because 
the system sends data to them in order to be saved. 
 Checkpoint 
 1.1.  What is a program?  
 1.2.   What is hardware?  
 1.3.  List the five major components of a computer system.  
 1.4.  What part of the computer actually runs programs?  

6 
Chapter 1 
 Introduction to Computers and Programming
 1.5.  What part of the computer serves as a work area to store a program and its 
data while the program is running?  
 1.6.  What part of the computer holds data for long periods of time, even when 
there is no power to the computer?  
 1.7.  What part of the computer collects data from people or other devices?  
 1.8.  What part of the computer formats and presents data for people or other 
devices?  
 
1.3  How Computers Store Data 
 CONCEPT:   All data that is stored in a computer is converted to sequences of 
0s and 1s.  
 A computer’s memory is made of tiny storage locations known as  bytes . One byte is 
only enough memory to store a letter of the alphabet or a small number. To do anything 
meaningful, a computer has to have lots of bytes. Most computers today have billions 
of bytes of memory. 
 Each byte is made of eight smaller storage locations known as bits. The term  bit 
stands for  binary digit . Computer scientists usually think of bits as tiny switches 
that can be either on or off. Bits aren’t actual “switches,” however, at least not in 
the conventional sense. In most computer systems, bits are tiny electrical compo-
nents that can hold either a positive or a negative charge. Computer scientists think 
of a positive charge as a switch in the  on position and a negative charge as a switch 
in the  off position.  Figure   1-5 shows the way a computer scientist might think of a 
byte of memory: as a collection of switches that are each flipped to either the on 
or off position.  
OFF
ON
OFF
OFF
OFF
ON
ON
ON
 Figure 1-5  Think of a byte as eight switches  
 When a piece of data is stored in a byte, the computer sets the eight bits to an on/
off pattern that represents the data. For example, the pattern shown on the left in 
 Figure  1-6 shows how the number 77 would be stored in a byte, and the pattern on 
the right shows how the letter A would be stored in a byte. In a moment you will 
see how these patterns are determined.  

 
1.3 How Computers Store Data 
7
 Storing Numbers 
 A bit can be used in a very limited way to represent numbers. Depending on whether 
the bit is turned on or off, it can represent one of two different values. In computer 
systems, a bit that is turned off represents the number 0, and a bit that is turned on 
represents the number 1. This corresponds perfectly to the  binary numbering system . 
In the binary numbering system (or  binary , as it is usually called), all numeric values 
are written as sequences of 0s and 1s. Here is an example of a number that is written 
in binary: 
 10011101  
 The position of each digit in a binary number has a value assigned to it. Starting with 
the rightmost digit and moving left, the position values are 2 0 , 2 1 , 2 2 , 2 3 , and so forth, 
as shown in  Figure  1-7 .  Figure  1-8  shows the same diagram with the position values 
calculated. Starting with the rightmost digit and moving left, the position values are 
1, 2, 4, 8, and so forth.  
The number 77 stored in a byte.
The letter A stored in a byte.
OFF
ON
OFF
OFF
OFF
ON
ON
ON
OFF
ON
OFF
OFF OFF OFF OFF
ON
 Figure 1-6  Bit patterns for the number 77 and the letter A  
1 0 0 1 1 1 0 1
20
21
22
23
24
25
26
27
 Figure 1-7  The values of binary digits as 
powers of 2  
1 0 0 1 1 1 0 1
    1
    2
    4
    8
  16
  32
  64
128
 Figure 1-8  The values of binary digits  
 To determine the value of a binary number you simply add up the position values of 
all the 1s. For example, in the binary number 10011101, the position values of the 1s 
are 1, 4, 8, 16, and 128. This is shown in  Figure   1-9 . The sum of all of these position 
values is 157. So, the value of the binary number 10011101 is 157.  

8 
Chapter 1 
 Introduction to Computers and Programming
 Figure   1-10 shows how you can picture the number 157 stored in a byte of memory. 
Each 1 is represented by a bit in the on position, and each 0 is represented by a bit in 
the off position.  
1 0 0 1 1 1 0 1
 1
 4
 8
 16
128
1 + 4 + 8 + 16 + 128 = 157
 Figure 1-9  Determining the value of 10011101  
128 + 16 + 8 + 4 + 1 = 157
1
128
64
32
16
8
4
2
1
Position
values
1
0
1
1
1
1
0
0
 Figure 1-10  The bit pattern for 157  
 When all the bits in a byte are set to 0 (turned off), then the value of the byte is 0. 
When all the bits in a byte are set to 1 (turned on), then the byte holds the largest 
value that can be stored in it. The largest value that can be stored in a byte is 1 + 2 + 
4 + 8 + 16 + 32 + 64 + 128 = 255. This limit exists because there are only eight bits 
in a byte. 
 What if you need to store a number larger than 255? The answer is simple: Use more 
than one byte. For example, suppose we put two bytes together. That gives us 16 bits. 
The position values of those 16 bits would be 2 0 , 2 1 , 2 2 , 2 3 , and so forth, up through 
2 15 . As shown in  Figure   1-11 , the maximum value that can be stored in two bytes is 
65,535. If you need to store a number larger than this, then more bytes are necessary.  
 TIP:   If you are feeling overwhelmed by all this, relax! You will not actually have 
to convert numbers to binary while programming. Knowing that this process is tak-
ing place inside the computer will help you as you learn, and in the long term this 
knowledge will make you a better programmer. 

 
1.3 How Computers Store Data 
9
 Storing Characters 
 Any piece of data that is stored in a computer’s memory must be stored as a binary 
number. This includes characters, such as letters and punctuation marks. When a 
character is stored in memory, it is first converted to a numeric code. The numeric 
code is then stored in memory as a binary number. 
 Over the years, different coding schemes have been developed to represent characters 
in computer memory. Historically, the most important of these coding schemes is 
 ASCII , which stands for the  American Standard Code for Information Interchange . 
ASCII is a set of 128 numeric codes that represent the English letters, various punc-
tuation marks, and other characters. For example, the ASCII code for the uppercase 
letter  A is 65. When you type an uppercase  A on your computer keyboard, the number 
65 is stored in memory (as a binary number, of course). This is shown in  Figure   1-12  . 
128
64
32
16
8
4
2
1
16384 8192 4096 2048
512
256
1024
32768
Position values
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
32768 + 16384 + 8192 + 4096 + 2048 + 1024 + 512 + 256 + 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1 = 65535
 Figure 1-11  Two bytes used for a large number  
65
A
0
0
1
0
1
0
0
0
 Figure 1-12  The letter A is stored in memory as the number 65  
 In case you are curious, the ASCII code for uppercase B is 66, for uppercase C is 67, 
and so forth.   Appendix   B shows all the ASCII codes and the characters they represent.  
 The ASCII character set was developed in the early 1960s and eventually was 
adopted by all computer manufacturers. ASCII is limited, however, because it 
defines codes for only 128 characters. To remedy this, the Unicode character set 
 TIP:   The acronym ASCII is pronounced “askee.” 

10 
Chapter 1 
 Introduction to Computers and Programming
was developed in the early 1990s.  Unicode is an extensive encoding scheme that 
not only is compatible with ASCII, but also can represent all the characters of 
most of the languages in the world. Today, Unicode is quickly becoming the stan-
dard character set used in the computer industry.  
 Negative Integers 
 Perhaps it has occurred to you by now that the binary numbering technique we have 
been discussing can represent only integer values, beginning with 0. Negative numbers 
cannot be represented using this simple technique. To store negative integers in mem-
ory, computers use  two’s complement arithmetic . In two’s complement arithmetic, a 
negative integer is encoded so it can be represented as a binary number.  
 Real Numbers 
 You might also have realized that the binary numbering technique we have been 
discussing cannot be used to store real numbers with a fractional part (such as 
3.14159). To store a number with a fractional part in memory, computers typi-
cally use floating-point notation. In  floating-point notation, a real number is en-
coded so it can be represented as a binary number. They are called floating-point 
numbers because no fixed number of digits comes before or after the decimal 
point. Floating-point notation can be used to represent real numbers such as 
2176.6 or 1.3783652. 
 Real numbers sometimes have many digits, or even an infinite number of digits, 
appearing after the decimal point. For example, when we convert the fraction 1∕3 to a 
decimal, we get 1.333333..., with an infinite number of 3s after the decimal point. 
Storing a value such as 1∕3 in memory is problematic because there is no exact way to 
represent such values using binary numbers. So, floating-point numbers are stored in 
memory with a specified precision. The  precision is the total number of digits (both 
before and after the decimal point) that are stored in memory. 
 For example, if we use seven digits of precision when storing a floating-point number, 
it means that only seven digits are stored in memory. If we try to store a real number 
that has more than seven digits, it will be rounded to seven digits. For example, the 
number 1.23456789 (which has nine digits) would be rounded to 1.234568.  
 Other Types of Data 
 Computers are often referred to as digital devices. The term  digital can be used to 
describe anything that uses binary numbers.  Digital data is data that is stored in bi-
nary, and a  digital device is any device that works with binary data. In this section, 
we have discussed how numbers and characters are stored in binary, but computers 
also work with many other types of digital data. 
 For example, consider the pictures that you take with your digital camera. These 
images are composed of tiny dots of color known as  pixels . (The term pixel stands for 
 picture element .) As shown in  Figure   1-13  , each pixel in an image is converted to a 
numeric code that represents the pixel’s color. The numeric code is stored in memory 
as a binary number. 

 
1.4 How a Program Works 
11
 The music that you play on your CD player, iPod, or MP3 player is also digital. A 
digital song is broken into small pieces known as  samples . Each sample is converted 
to a binary number, which can be stored in memory. The more samples a song is di-
vided into, the more it sounds like the original music when it is played back. A CD-
quality song is divided into more than 44,000 samples per second! 
 Checkpoint 
 1.9.  What amount of memory is enough to store a letter of the alphabet or a small 
number?  
 1.10.  What do you call a tiny “switch” that can be set to either on or off?  
 1.11.  In what numbering system are all numeric values written as sequences of 
0s and 1s?  
 1.12.  What is the purpose of ASCII?  
 1.13.  What encoding scheme is extensive enough to represent the characters of most 
of the languages in the world?  
 1.14.  What do the terms “digital data” and “digital device” mean?  
 
1.4  How a Program Works 
 CONCEPT:    A computer’s CPU only understands instructions that are written in 
machine language. Because people find it very difficult to write entire 
programs in machine language, other programming languages have 
been invented.  
 Earlier, we stated that the CPU is the most important component in a computer be-
cause it is the part of the computer that runs programs. Sometimes the CPU is called 
the “computer’s brain” and is described as being “smart.” Although these are common 
metaphors, you should understand that the CPU is not a brain, and it is not smart. 
The CPU is an electronic device that is designed to do specific things. In particular, the 
CPU is designed to perform operations such as the following: 
 ●  Reading a piece of data from main memory  
 ●  Adding two numbers  
 ●  Subtracting one number from another number  
 ●  Multiplying two numbers  
10
0
1
0
1
0
1
1
1
0
1
0
0
0
1
0
1
0
1
1
0
1
 
 Figure 1-13  A digital image is stored in binary format  

12 
Chapter 1 
 Introduction to Computers and Programming
 ●  Dividing one number by another number  
 ●  Moving a piece of data from one memory location to another location  
 ●  Determining whether one value is equal to another value  
 ●  And so forth...  
 As you can see from this list, the CPU performs simple operations on pieces of data. 
The CPU does nothing on its own, however. It has to be told what to do, and that’s 
the purpose of a program. A program is nothing more than a list of instructions that 
cause the CPU to perform operations. 
 Each instruction in a program is a command that tells the CPU to perform a specific 
operation. Here’s an example of an instruction that might appear in a program: 
 10110000  
 To you and me, this is only a series of 0s and 1s. To a CPU, however, this is an instruc-
tion to perform an operation.  1 It is written in 0s and 1s because CPUs only under-
stand instructions that are written in  machine language , and machine language 
instructions are always written in binary.  
 A machine language instruction exists for each operation that a CPU is capable of 
performing. For example, there is an instruction for adding numbers; there is an 
instruction for subtracting one number from another; and so forth. The entire set of 
instructions that a CPU can execute is known as the CPU’s  instruction set . 
 1 The example shown is an actual instruction for an Intel microprocessor. It tells the microproces-
sor to move a value into the CPU. 
 The machine language instruction that was previously shown is an example of only 
one instruction. It takes a lot more than one instruction, however, for the computer to 
do anything meaningful. The operations that a CPU knows how to perform are very 
basic in nature; therefore, a meaningful task can be accomplished only if the CPU 
performs many operations. For example, if you want your computer to calculate the 
amount of interest that you will earn from your savings account this year, the CPU 
will have to perform a large number of instructions, carried out in the proper sequence. 
It is not unusual for a program to contain thousands, or even a million or more 
machine language instructions. 
 Programs are usually stored on a secondary storage device such as a disk drive. When 
you install a program on your computer, you might download it to your computer’s 
disk drive from a Web site or an app store, or possibly copy it to your computer’s disk 
drive from a CD-ROM, or a DVD. 
 NOTE:    Several microprocessor companies today manufacture CPUs. Some of the 
more well-known microprocessor companies are Intel, AMD, and Motorola. If you 
look carefully at your computer, you might find a tag showing the logo of its 
microprocessor company. 
 Each brand of microprocessor has its own unique instruction set, which is typi-
cally understood only by microprocessors of the same brand. For example, Intel 
microprocessors understand the same instructions, but they do not understand 
instructions for Motorola microprocessors. 

 
1.4 How a Program Works 
13
 Although a program can be stored on a secondary storage device such as a disk drive, it 
has to be copied into main memory, or RAM, each time the CPU executes it. For example, 
suppose you have a word processing program on your computer’s disk. To execute the 
program you use the mouse to double-click the program’s icon. This causes the program 
to be copied from the disk into main memory. Then, the computer’s CPU executes the 
copy of the program that is in main memory. This process is illustrated in  Figure   1-14 .  
Main memory
(RAM)
Disk drive
CPU
 10111000
10100001
 10011110
The program is copied
from secondary storage
to main memory.
The CPU executes
the program in
main memory.
 Figure 1-14  A program is copied into main memory and then executed  
 When a CPU executes the instructions in a program, it is engaged in a process that is 
known as the  fetch–decode–execute cycle . This cycle, which consists of three steps, is 
repeated for each instruction in the program, as follows: 
 1.  Fetch  
 A program is a long sequence of machine language instructions. The 
first step of the cycle is to fetch, or read, the next instruction from 
memory into the CPU.  
 2.  Decode   A machine language instruction is a binary number that represents a 
command that tells the CPU to perform an operation. In this step, the 
CPU decodes the instruction that was just fetched from memory, to 
determine which operation it should perform.  
 3.  Execute   The last step in the cycle is to execute, or perform, the operation.  
 Figure   1-15 illustrates these steps.  
CPU
Main memory
(RAM)
10111000
10100001
10011110
00011010
11011100
and so forth...
10100001
1
Fetch the next instruction
in the program.
Decode the instruction
to determine which
operation to perform.
3
Execute the instruction
(perform the operation).
2
 Figure 1-15  The fetch–decode–execute cycle  

14 
Chapter 1 
 Introduction to Computers and Programming
 From Machine Language to Assembly Language 
 Computers can only execute programs that are written in machine language. As previ-
ously mentioned, a program can have thousands, or even a million or more, binary 
instructions, and writing such a program would be very tedious and time consuming. 
Programming in machine language would also be very difficult because putting a 0 or 
a 1 in the wrong place will cause an error. 
 Although a computer’s CPU only understands machine language, it is impractical for 
people to write programs in machine language. For this reason, in the early days of 
computing 2  assembly language was created as an alternative to machine language. 
Instead of using binary numbers for instructions, assembly language uses short words 
that are known as  mnemonics . For example, in assembly language, the mnemonic  add 
typically means to add numbers,  mul typically means to multiply numbers, and 
 mov typically means to move a value to a location in memory. When a programmer 
uses assembly language to write a program, he or she can write short mnemonics 
instead of binary numbers.  
 2 The first assembly language was most likely the one developed in the 1940s at Cambridge 
University for use with an historic computer known as the EDSAC. 
 Assembly language programs cannot be executed by the CPU, however. The CPU only 
understands machine language, so a special program known as an  assembler is used 
to translate an assembly language program into a machine language program. This 
process is shown in  Figure   1-16  . The machine language program that is created by the 
assembler can then be executed by the CPU.  
mov eax, Z
add eax, 2
mov Y, eax
and so forth...
Assembler
10111000
10100001
10011110
and so forth...
Assembly language
program
Machine language
program
 Figure 1-16  An assembler translates an assembly language program into a machine 
language program  
 High-Level Languages 
 Although assembly language makes it unnecessary to write binary machine lan-
guage instructions, it is not without difficulties. Assembly language is primarily a 
direct substitute for machine language, and like machine language, it requires 
 NOTE:   There are many different versions of assembly language. It was mentioned 
earlier that each brand of CPU has its own machine language instruction set. Each 
brand of CPU typically has its own assembly language as well. 

 
1.4 How a Program Works 
15
that you know a lot about the CPU. Assembly language also requires that you 
write a large number of instructions for even the simplest program. Because as-
sembly language is so close in nature to machine language, it is referred to as a 
 low-level language . 
 In the 1950s, a new generation of programming languages known as  high-level 
languages appeared. A high-level language allows you to create powerful and 
complex programs without knowing how the CPU works and without writing 
large numbers of low-level instructions. In addition, most high-level languages 
use words that are easy to understand. For example, a programmer using COBOL 
(which was one of the early high-level languages created in the 1950s) would 
write the following instruction to display the message  Hello world on the com-
puter screen: 
 DISPLAY "Hello world" 
 Doing the same thing in assembly language would require several instructions and an 
intimate knowledge of how the CPU interacts with the computer’s video circuitry. As 
you can see from this example, high-level languages allow programmers to concen-
trate on the tasks they want to perform with their programs rather than on the details 
of how the CPU will execute those programs. 
 Since the 1950s, thousands of high-level languages have been created.  Table   1-1 lists 
several of the more well-known languages.  
 Table 1-1   Programming languages 
 Language 
 Description 
 Ada 
 Ada was created in the 1970s, primarily for applications used by the U.S. Department 
of Defense. The language is named in honor of Countess Ada Lovelace, an influential 
and historic figure in the field of computing. 
 BASIC 
 B eginners  A ll-purpose  S ymbolic  I nstruction  C ode is a general-purpose language 
that was originally designed in the early 1960s to be simple enough for beginners 
to learn. Today, there are many different versions of BASIC. 
 FORTRAN 
  FOR mula  TRAN slator was the first high-level programming language. It was 
designed in the 1950s for performing complex mathematical calculations. 
 COBOL 
  C ommon  B usiness- O riented  L anguage was created in the 1950s and was designed 
for business applications. 
 Pascal 
 Pascal was created in 1970 and was originally designed for teaching programming. 
The language was named in honor of the mathematician, physicist, and philosopher 
Blaise Pascal. 
 C and C++ 
 C and C++ (pronounced “c plus plus”) are powerful, general-purpose languages 
developed at Bell Laboratories. The C language was created in 1972. The C++ 
language, which was based on the C language, was created in 1983. 
 C# 
 Pronounced “c sharp.” This language was created by Microsoft around the year 
2000 for developing applications based on the Microsoft .NET platform. 
(continues next page)

16 
Chapter 1 
 Introduction to Computers and Programming
 Key Words, Operators, and Syntax: An Overview 
 Each high-level language has its own set of predefined words that the programmer 
must use to write a program. The words that make up a high-level programming 
language are known as  key words or  reserved words . Each key word has a specific 
meaning and cannot be used for any other purpose. In this book we use the C++ pro-
gramming language.  Table   1-2 shows the C++ key words.  
 Language 
 Description 
 Java 
 Java was created by Sun Microsystems in the early 1990s. It can be used to 
develop programs that run on a single computer or over the Internet from a 
Web server. 
 JavaScript 
 JavaScript, created in the 1990s, can be used in Web pages. Despite its name, 
JavaScript is not related to Java. 
 Python 
 Python is a general-purpose language created in the early 1990s. It has become 
popular in business and academic applications. 
 Ruby 
 Ruby is a general-purpose language that was created in the 1990s. It is 
increasingly becoming a popular language for programs that run on Web 
servers. 
 Visual Basic 
 Visual Basic (commonly known as VB) is a Microsoft programming language 
and software development environment that allows programmers to create 
Windows-based applications quickly. VB was originally created in the early 
1990s. 
Table 1-1 Programming languages (continued)
 Table 1-2   The C++ key words 
 and 
 continue 
 goto 
  public 
 try 
 and_eq 
 default 
 if 
 register 
 typedef 
 asm 
 delete 
 inline 
 reinterpret_cast 
 typeid 
 auto 
  do 
 int 
 return 
 typename 
 bitand 
 double 
 long 
  short 
 union 
 bitor 
 dynamic_cast 
 mutable 
 signed 
 unsigned 
 bool 
  else 
 namespace 
 sizeof 
 using 
 break 
 enum 
 new 
 static 
 virtual 
 case 
  explicit 
 not 
 static_cast 
 void 
 catch 
 export 
 not_eq 
 struct 
 volatile 
 char 
  extern 
 operator 
 switch 
 wchar_t 
 class 
 false 
  or 
 template 
 while 
 compl 
 float 
  or_eq 
 this 
 xor 
 const 
 for 
 private 
 throw 
 xor_eq 
 const_cast 
  friend 
 protected 
 true 

 
1.4 How a Program Works 
17
 In addition to key words, programming languages have  operators that perform various 
operations on data. For example, all programming languages have math operators that 
perform arithmetic. In C++, as well as in most other languages, the + sign is an opera-
tor that adds two numbers. The following adds 12 and 75: 
 12 + 75  
 Numerous other operators are in the C++ language, many of which you will learn 
about as you progress through this book. 
 In addition to key words and operators, each language also has its own  syntax , which 
is a set of rules that must be strictly followed when writing a program. The syntax 
rules dictate how key words, operators, and various punctuation characters must be 
used in a program. When you are learning a programming language, you must learn 
the syntax rules for that particular language. 
 The individual instructions that you use to write a program in a high-level program-
ming language are called  statements . A programming statement can consist of key 
words, operators, punctuation, and other allowable programming elements, arranged 
in the proper sequence to perform an operation.  
 Compilers and Interpreters 
 Because the CPU understands only machine language instructions, programs that are 
written in a high-level language must be translated into machine language. Depending 
on the language that a program has been written in, the programmer will use either a 
compiler or an interpreter to make the translation. 
 A  compiler is a program that translates a high-level language program into a separate 
machine language program. The machine language program can then be executed any 
time it is needed. This is shown in  Figure   1-17  . As shown in the figure, compiling and 
executing are two different processes.  
 Some languages use an  interpreter , which is a program that both translates and exe-
cutes the instructions in a high-level language program. As the interpreter reads each 
individual instruction in the program, it converts it to a machine language instruction 
and then immediately executes it. This process repeats for every instruction in the pro-
gram. This process is illustrated in  Figure   1-18 . Because interpreters combine transla-
tion and execution, they typically do not create separate machine language programs.  
 NOTE:    As you look at  Table   1-2 , you might be wondering if you will have to 
memorize these key words or learn what all of them are used for. The answer is no! 
As you learn to program in C++, you will find that you frequently use a handful of 
these key words, and you will quickly learn what they do. Even experienced pro-
grammers occasionally have to look up the proper usage of a key word that they 
do not use often. 
 NOTE:   The C++ language uses a compiler to make the translation from C++ to 
machine language. 

18 
Chapter 1 
 Introduction to Computers and Programming
 The statements that a programmer writes in a high-level language are called  source 
code , or simply  code . Typically, the programmer types a program’s code into a text 
editor and then saves the code in a file on the computer’s disk. Next, the programmer 
uses a compiler to translate the code into a machine language program or an inter-
preter to translate and execute the code. If the code contains a syntax error, however, 
it cannot be translated. A  syntax error is a mistake, such as a misspelled key word, a 
missing punctuation character, or the incorrect use of an operator. If this happens, the 
compiler or interpreter displays an error message, indicating that the program con-
tains a syntax error. The programmer corrects the error and then attempts again to 
translate the program.  
Display 
"Hello World"
and so forth...
High-level language
program
Compiler
10111000
10100001
10011110
and so forth...
Machine language
program
10111000
10100001
10011110
and so forth...
Machine language
program
CPU
The compiler is used
to translate the high-level
language program into a
machine language program.
1
The machine language
program can be executed
at any time, without using
the compiler.
2
 Figure 1-17  Compiling a high-level program and executing it  
The interpreter translates each high-level instruction 
into its equivalent machine language instruction and 
immediately executes it.
This process is repeated for each high-level instruction.
Display 
"Hello World"
and so forth...
High-level language
program
Interpreter
10100001
Machine language
instruction
CPU
 Figure 1-18  Executing a high-level program with an interpreter  

 
1.5 C++ and the App Game Kit Library 
19
 Checkpoint 
 1.15.  A CPU understands instructions that are written only in what language?  
 1.16.  A program has to be copied into what type of memory each time the CPU 
executes it?  
 1.17.  When a CPU executes the instructions in a program, it is engaged in what 
process?  
 1.18.   What is assembly language?  
 1.19.  What type of programming language allows you to create powerful and com-
plex programs without knowing how the CPU works?  
 1.20.  Each language has a set of rules that must be strictly followed when writing a 
program. What is this set of rules called?  
 1.21.  What do you call a program that translates a high-level language program into 
a separate machine language program?  
 1.22.  What do you call a program that both translates and executes the instructions 
in a high-level language program?  
 1.23.  What type of mistake is usually caused by a misspelled key word, a missing 
punctuation character, or the incorrect use of an operator?  
 
1.5  C++ and the App Game Kit Library 
 CONCEPT:    C++ is a high-level programming language, and the App Game Kit 
provides a library of prewritten code that can be used in C++ to write 
games and graphical programs.  
 As previously mentioned, we will be using the C++ programming language in this 
book.  C++ is one of the most popular programming languages used by professional 
programmers and is widely used by game developers. 
 The C++ programming language was based on the C programming language. C was cre-
ated in 1972 by Dennis Ritchie at Bell Laboratories for writing system software.  System 
software controls the operation of a computer. For example, an operating system like 
Windows, Linux, or Mac OS X is system software. Because system software must be effi-
cient and fast, the C programming language was designed as a high-performance language. 
 NOTE:   Human languages also have syntax rules. Do you remember when you took 
your first English class, and you learned all those rules about commas, apostrophes, 
capitalization, and so forth? You were learning the syntax of the English language. 
 Although people commonly violate the syntax rules of their native language 
when speaking and writing, other people usually understand what they mean. 
Unfortunately, compilers and interpreters do not have this ability. If even a single 
syntax error appears in a program, the program cannot be compiled or executed. 

20 
Chapter 1 
 Introduction to Computers and Programming
 The C++ language was created by Bjarne Stroustrup at Bell Laboratories in the early 
1980s as an extension of the C language. C++ retains the speed and efficiency of C 
and adds numerous modern features that make it a good choice for developing large 
applications. Today, many commercial software applications are written in C++. 
Game programmers especially like C++ because speed and performance are critical in 
game programming. 
 The Core Language and Libraries 
 The C++ language consists of two parts: The core language and the standard library. 
The  core language is the set of key words that you saw in  Table  1-2  . Each of the key 
words in the table has a specific meaning and cannot be used for any other purpose. 
These key words allow a program to perform essential operations, but they do not 
perform input, output, or other complex procedures. For example, the core lan-
guage does not have key words for displaying output on the screen or reading input 
from the keyboard. To perform these types of operations you use a library. A  library 
is a collection of prewritten code that exists for some specific purpose. The C++ 
language has a  standard library that contains code for performing common opera-
tions such as input and output.  In Part 1 of this book you will be using the standard 
library extensively.  
 In Part 2 of this book, you will begin to use another library known as the App Game 
Kit.  The App Game Kit library is a collection of code that can be used with C++ for 
handling graphics and writing game programs. App Game Kit was developed by The 
Game Creators, a software company based in the United Kingdom.  
 The Software You Will Need 
 To use this book you will need to install the following software and files: 
 ●  Microsoft Visual Studio 2010, or Microsoft Visual C++ 2010 Express. The ex-
press edition of this software is available for free from Microsoft.  See  Appendix 
 A for instructions on downloading and installing it.  
 ●  App Game Kit.  Starting in Part 2 of this book you  will use App Game Kit 
(AGK), along with Visual Studio, or Visual C++ 2010 Express.  The trial version 
of App Game Kit works very well with this book, and it does not have a time 
limit.  You can download the App Game Kit trial version from the Game Creators 
Web site.  See  Appendix   A for instructions.  
 ●  Sample Source Code and Media Files. These files comprise  all of the  example 
programs in the book , as well as graphics and audio files that you can use in 
your projects.   Appendix  A provides instructions for downloading the files from 
the publisher’s Web site.  
 Before going any further, you should make sure that you have downloaded and 
installed the necessary software and files on your computer. Once you have done 
that, go through the following tutorials. In the following  In the Spotlight , you will 
write   a C++ program and execute it. The steps that you will follow in the tutorial 
will be the same for most of the programs that you will write  as you work through 
Part 1 of this book . In the second  In the Spotlight , you will open and execute  one 
of the book’s   example  programs  . 

 
1.5 C++ and the App Game Kit Library 
21
 In the Spotlight: 
 Writing  Your First   Program with 
Visual C++ 2010 Express 
 Step 1:  Start Visual Studio, or Visual C++ 2010 Express. (You can find it by click-
ing the  Start button, then selecting  All Programs , then selecting  Visual Stu-
dio 2010 Express , then selecting  Visual C++ 2010 Express .) 
 Visual C++ 2010 Express appears similar to  Figure   1-19  when it first 
starts up. The screen shown in the figure is the  Start Page . 
 Figure 1-19  The Visual C++ Start Page  
 Step 2:  To write a program in Visual C++, you need to create a project. A  project is 
a group of one or more files that make up a software application. (Even if 
your program consists of no more than a single source code file, it still must 
belong to a project.) 
 To start a new project, click  File on the menu bar, then  New , then 
 Project . The  New Project window appears, as shown in  Figure   1-20  . In the 
center section of the window, select  Win32 Console Application . 
VideoNote
Writing your fi rst 
program with 
Visual C++ 2010 
Express

22 
Chapter 1 
 Introduction to Computers and Programming
 Each project must have a name. Notice that an entry field for the project’s 
name appears at the bottom of the dialog box. As shown in  Figure   1-20 , this 
field is initially set to  <Enter_name> . Change this to  MyFirstProgram , and 
then click the  OK button to continue.  
 TIP:   When your instructor gives you a programming assignment, you will want 
to give the project a name that identifies the assignment, such as  Lab6 , or 
 Assignment7 . Enter the name of the project in the  Name text box, and then click 
the  OK button to continue. 
 NOTE:   When you create a project, Visual C++ creates a folder where all the 
project files are stored. This folder is referred to as the  project folder , and it has 
the same name as the project. The  Location: entry field lets you specify a loca-
tion on your system where the project folder will be created. You will probably 
want to keep the default location, but if not, click the  Browse… button to select 
a different one. 
Select Win32 Console
Application
Enter the project name here.
 Figure 1-20  The New Project dialog box  
 Step 3:  The  Win32 Application Wizard window appears next, as shown in  Fig-
ure   1-21 . Click  Application Settings .  

 
1.5 C++ and the App Game Kit Library 
23
 Step 5:  Visual C++ has a  Solution Explorer window that shows a list of all the files 
in your project.  Figure   1-23  shows the  Solution Explorer , which should be 
visible. If you do not see the  Solution Explorer , click  View on the menu bar, 
then select  Other Windows , and then click  Solution Explorer . 
Click Application
Settings
 Figure 1-21  The Win32 Application Wizard window  
Check Empty project.
Make sure
Console application
is selected.
 Figure 1-22  The Application Settings window  
 Step 4:  The  Application Settings window appears next, as shown in  Figure  1-22  . As 
shown in the figure, make sure  Console Application is selected, and check 
 Empty project . Click  Finish . 

24 
Chapter 1 
 Introduction to Computers and Programming
 Step 6:  Notice that one of the folders shown in the  Solution Explorer is named 
 Source Files . Right-click the  Source Files folder, then select  Add , then click 
 New Item .  Figure  1-24  shows the pop-up menus.  
The Solution
Explorer
 Figure 1-23  The Solution Explorer  
 Figure 1-24  Adding a source file  

 
1.5 C++ and the App Game Kit Library 
25
 Step 7:  The  Add New Item window appears next, as shown in  Figure   1-25  . Select 
 C++ File (.cpp) in the center section of the window. Notice that an entry 
field for the source file’s name appears at the bottom of the window. This 
field is initially set to  <Enter_name> . Change this to  MyFirstProgram , and 
then click the  Add button to add the new source file to the project.  
 NOTE:    Notice that in this example, we named both the project and the source file 
 MyFirstProgram . You do not have to use the same name for both the project and 
the source file, but it’s a common practice to do so. 
Select C++ File (.cpp)
Enter the name of the source file here.
 Figure 1-25  The Solution Explorer  
 Step 8:  In the  Solution Explorer , you should now see the file  MyFirstProgram.cpp 
listed, as shown in  Figure   1-26  . A text editing window should also be 
opened, as shown in the figure. This text editing window is where you will 
type the C++ code for the file.  
 TIP:    If the text editing window is not opened, you can double-click 
 MyFirstProgram.cpp in the  Solution Explorer . This will open the text editing 
window. 
 Type the following C++ code, exactly as it appears, in the text editing 
window. (For now, do not worry about what the code does. This exercise 
is merely meant to give you practice working with Visual C++.) 
 #include <iostream> 
 using namespace std; 
 int main() 
 { 
    cout << "This is my first program!" << endl; 
    return 0; 
 } 

26 
Chapter 1 
 Introduction to Computers and Programming
 When you have finished typing the code, the text editing window should 
appear as shown in  Figure   1-27  .  
Name of the file that
you just added to
the project.
Text editor
 Figure 1-26  The  MyFirstProgram.cpp file added to the project  
 Figure 1-27  Code typed into the text editing window  

 
1.5 C++ and the App Game Kit Library 
27
 Step 9:  Click  File on the menu bar, then click  Save All to save the project. (Anytime 
you are writing a program, it is a good idea to save the project often.)  
 Step 10:  Now you will compile and execute the program. Earlier in this chapter, 
you read that compiling and executing are two separate processes. Visual 
C++, however, can compile a program and immediately execute it, as 
long as there are no errors in the program. That is what you will do in 
this step. 
 Press Ctrl+F5 on the keyboard. Next, you will see the dialog box, as 
shown in  Figure   1-28 . Click the  Yes button.  
 Figure 1-28  Confirmation dialog box  
 Step 11:  If you typed the program with no mistakes, you should see the program 
execute, as shown in  Figure   1-29  . The program simply prints the following 
message:  This is my first program! Press any key on the keyboard to end the 
program. 
 Figure 1-29  MyFirstprogram.cpp  running  
 If you did not type the program exactly as it was shown, you will prob-
ably see the following error message:  There were build errors. Would you 
like to continue and run the last successful build? If you see this, click the 
 No button, then compare the code that you typed with the code shown in 
Step 8. Make sure your code is exactly like the code we have given you. 
After correcting any mistakes, repeat Steps 10 and 11.  
 Step 12:  To exit Visual C++, click  File on the menu bar, then click  Exit . 

28 
Chapter 1 
 Introduction to Computers and Programming
 In the Spotlight: 
 Opening and Executing an Example Program 
 As you work through this book you will see many example programs.  Program 1-1 
shows how an example program will appear. (For now, do not worry about what the 
program does. We are merely using it for demonstration purposes.) 
 Program 1-1  
 (Welcome.cpp) 
 #include <iostream> 
 using namespace std; 
 int main() 
 { 
    cout << "Welcome to the world of C++ programming." << endl; 
    return 0; 
 } 
 Notice that the program’s name,  Welcome.cpp , is shown at the top of the program 
listing. Assuming you have downloaded the student source code files from the pub-
lisher’s Web site ( www.pearsonhighered.com/gaddis ), you can follow these steps to 
open, compile, and execute the program. 
 Step 1:  Start Visual C++ 2010 Express.  
 Step 2:  Click  File on the menu bar, then select  Open , then select  Project/Solution . 
The  Open Project dialog box will appear. Navigate to the location on your 
system where you saved the student source code files, and locate the source 
code folder for  Chapter   1 . Inside that folder you will see another folder 
named  Welcome . Open that folder, and you will see a file named  Welcome.
sln , as shown in  Figure   1-30  . Select the  Welcome.sln file and click  Open . 
 Figure 1-30  The Open Project dialog box  
VideoNote
Opening and 
Executing an 
Example Program

 
1.5 C++ and the App Game Kit Library 
29
 Step 3:  You have just opened the project that contains the  Welcome.cpp program. 
Locate the entry for the  Welcome.cpp file in the  Solution Explorer window, 
as shown in  Figure  1-31 . (If the  Solution Explorer window is not visible, 
click  View on the menu bar, then select  Other Windows , then click  Solution 
Explorer .) Double-click the entry for the  Welcome.cpp file to open it in the 
text editing window, as shown in  Figure   1-32  . 
Double-click the entry
for Welcome.cpp in
the Solution Explorer.
 Figure 1-31  The  Welcome.cpp  file’s entry in the Solution Explorer  
 Figure 1-32  The  Welcome.cpp  file opened in the text editing window  

30 
Chapter 1 
 Introduction to Computers and Programming
 Step 4:  Press Ctrl+F5 on the keyboard to compile and execute the program. If the 
dialog box that was previously shown in  Figure   1-28  appears, click the 
 Yes button. You should see the program execute, as shown in  Figure   1-33  . 
Pressing any key on the keyboard will end the program.  
 Figure 1-33  The  Welcome.cpp program executing  
 Review Questions 
 Multiple Choice  
 
1.  A(n) _____ is a set of instructions that a computer follows to perform a task.  
 a.  compiler  
 b.  program 
 c.  interpreter  
 d.  programming language  
 
2.   The physical devices that a computer is made of are referred to as _____.  
 a.  hardware  
 b.  software  
 c.  the operating system  
 d.  tools 
 
3.   The part of a computer that runs programs is called _____.  
 a.  RAM  
 b.  secondary storage  
 c.  main memory  
 d.  the CPU  
 
4.   Today, CPUs are small chips known as _____.  
 a.  ENIACs 
 b.  microprocessors  
 c.  memory chips  
 d.  operating systems  

 
Review Questions 
31
 
5.   The computer stores a program while the program is running, as well as storing 
the data that the program is working with, in _____.  
 a.  secondary storage  
 b.  the CPU  
 c.  main memory  
 d.  the microprocessor  
 
6.   This is a volatile type of memory that is used only for temporary storage while a 
program is running: _____.  
 a.  RAM  
 b.  secondary storage  
 c.  the disk drive  
 d.   the USB drive  
 
7.   A type of memory that can hold data for long periods of time—even when there 
is no power to the computer is called _____.  
 a.  RAM  
 b.  main memory  
 c.  secondary storage  
 d.  CPU storage  
 
8.   A component that collects data from people or other devices and sends it to the 
computer is called _____.  
 a.  an output device  
 b.  an input device  
 c.  a secondary storage device  
 d.  main memory  
 
9.   A video display is a(n) _____ device.  
 a.  output device  
 b.   input device  
 c.   secondary storage device  
 d.  main memory  
 
10.   A _____ is enough memory to store a letter of the alphabet or a small number.  
 a.  byte  
 b.  bit 
 c.  switch  
 d.  transistor  
 
11.   A byte is made up of eight _____.  
 a.  CPUs  
 b.  instructions  
 c.  variables  
 d.  bits 
 
12.   In a(n) _____ numbering system, all numeric values are written as sequences of 0s 
and 1s. 
 a.  hexadecimal  
 b.  binary 
 c.  octal  
 d.  decimal  

32 
Chapter 1 
 Introduction to Computers and Programming
 
13.  A bit that is turned off represents the following value: _____.  
 a.  1 
 b.  −1 
 c.  0 
 d.  “no”  
 
14.  A set of 128 numeric codes that represent the English letters, various punctuation 
marks, and other characters is _____. 
 a.  binary numbering  
 b.  ASCII  
 c.  Unicode  
 d.  ENIAC 
 
15.  An extensive encoding scheme that can also represent the characters of most of 
the languages in the world is _____.  
 a.  binary numbering 
 b.  ASCII  
 c.  Unicode  
 d.  ENIAC 
 
16.  Negative numbers are encoded using the _____ technique.  
 a.  two’s complement  
 b.  floating-point  
 c.  ASCII  
 d.  Unicode  
 
17.  Real numbers are encoded using the _____ technique.  
 a.  two’s complement  
 b.  floating-point  
 c.  ASCII  
 d.  Unicode   
 
18.  The tiny dots of color that digital images are composed of are called _____.  
 a.  bits 
 b.  bytes  
 c.  color packets  
 d.  pixels  
 
19.   If you look at a machine language program, you will see _____.  
 a.  C++ code  
 b.  a stream of binary numbers  
 c.  English words  
 d.  circuits  
 
20.  In the _____ part of the fetch–decode–execute cycle, the CPU determines which 
operation it should perform.  
 a.  fetch  
 b.  decode  
 c.  execute  
 d.  immediately after the instruction is executed  

 
Review Questions 
33
 
21.   Computers can only execute programs that are written in _____.  
 a.  Java  
 b.  assembly language  
 c.   machine language  
 d.  C++ 
 
22.  The _____ translates an assembly language program to a machine language 
program.  
 a.  assembler  
 b.  compiler  
 c.  translator  
 d.  interpreter  
 
23.   The words that make up a high-level programming language are called _____.  
 a.  binary instructions  
 b.   mnemonics  
 c.  commands  
 d.  key words  
 
24.   The rules that must be followed when writing a program are called _____.  
 a.  syntax  
 b.  punctuation 
 c.  key words  
 d.  operators  
 
25.   A(n) _____ program translates a high-level language program into a separate 
machine language program.  
 a.  assembler  
 b.  compiler  
 c.  translator  
 d.  utility  
 True or False  
 
1.  Today, CPUs are huge devices made of electrical and mechanical components 
such as vacuum tubes and switches.  
 
2.  Main memory is also known as RAM.  
 
3.  Any piece of data that is stored in a computer’s memory must be stored as a 
binary number.  
 
4.  Images, like the ones you make with your digital camera, cannot be stored as 
binary numbers.  
 
5.  Machine language is the only language that a CPU understands.  
 
6.  Assembly language is considered a high-level language.  
 
7.  An interpreter is a program that both translates and executes the instructions in 
a high-level language program.  

34 
Chapter 1 
 Introduction to Computers and Programming
 
8.  A syntax error does not prevent a program from being compiled and executed.  
 
9.  The C++ language has built-in features for writing games and graphical 
programs.  
 
10.  C++ is a good language for game programming because it is fast and efficient.  
 Short Answer  
 
1.   Why is the CPU the most important component in a computer?  
 
2.   What number does a bit that is turned on represent? What number does a bit that 
is turned off represent?  
 
3.  What would you call a device that works with binary data?  
 
4.   What are the words that make up a high-level programming language called?  
 
5.   What are the short words that are used in assembly language called?  
 
6.   What is the difference between a compiler and an interpreter?  
 
7.   What language was the C++ language based on?  
 
8.   What is the difference between the C++ core language and the standard library?  
 Programming Exercises 
 
1.  This exercise will give you additional practice using Visual C++ to create a project. 
Before attempting this exercise you should complete the steps in the first  In the 
Spotlight in this chapter. 
 Use the steps that you followed in the first  In the Spotlight in this chapter to 
create a new project named MyProgram. When you add a C++ source code file to 
the project (as you did in Step 4 of the first  In the Spotlight ), name it  MyProgram.cpp . 
Then, type the following code into the file. (Be sure to type the code exactly as it 
appears here.) 
 #include <iostream> 
 using namespace std; 
 int main() 
 { 
   cout << "Programming is fun!" << endl; 
   return 0; 
 } 
 Save the project, then compile and execute it. If you typed the code exactly as 
shown, the window shown in  Figure   1-34  should appear. Press any key on the 
keyboard to exit the program.  
 If you did not type the program exactly as shown, you will probably see the 
following error message:  There were build errors. Would you like to continue and 
run the last successful build? If you see this, click the  No button, then compare 
the code that you typed with the code shown in the book. Make sure your code 
is exactly like the code we have given you. After correcting any mistakes, save the 
project, then try to compile and execute it again.  
VideoNote
Programming 
Exercise 1: 
Creating a 
new program

 
Programming Exercises 
35
 
2.   Use what you’ve learned about the binary numbering system in this chapter to 
convert the following decimal numbers to binary: 
 11 
 65 
 100 
 255 
 
3.  Use what you’ve learned about the binary numbering system in this chapter to 
convert the following binary numbers to decimal: 
  1101 
  1000 
 101011  
 
4.   Use the Web to research the history of computer games, and answer the following 
questions: 
 •  From your research, what was the first computer game?  
 •  Have computer games that do not use graphics ever been created?  
 •  What is a serious game?  
 Figure 1-34  Output of the  MyProgram.cpp program  

This page intentionally left blank 

37
 C++ Fundamentals 
 
  2.1  The Parts of a C++ Program 
 CONCEPT:   Your first step in learning C++ is to learn the basic parts of a C++ 
program.  
 As you work through Part 1 of this book, a  ll the C++ programs that you will write 
will contain the following code: 
 #include <iostream> 
 using namespace std; 
 int main() 
 { 
    return 0; 
 } 
 You can think of this as a skeleton program. As it is, it does absolutely nothing. But 
you can add additional code to this program to make it perform an operation. Let’s 
take a closer look at the parts of the skeleton program.  
 2.1  The Parts of a C++ Program      
 2.2  Displaying Screen Output      
 2.3  More about the  #include Directive       
 2.4  A First Look at Variables      
 2.5  Reading Keyboard Input      
 2.6  Comments, Blank Lines, and Indentation    
  2.7   Performing Calculations and Working 
with Numbers      
  2.8  Named Constants      
  2.9  Math Functions in the Standard Library    
 2.10  Working with Strings       
 2.11  The  char Data Type     
 TOPICS 
2 
 CHAPTER

38 
Chapter 2 
 C++ Fundamentals
 The first line reads: 
 #include <iostream>  
 This is called an  include directive . It causes the contents of a file named  iostream to 
be included in the program. The  iostream file is known as a  header file , and it con-
tains a prewritten code that allows a C++ program to display output on the screen 
and read input from the keyboard. The next line reads: 
 using namespace std;  
 A program usually contains several items that have names. C++ uses  namespaces to 
organize the names of program entities. The statement  using namespace std; declares 
that the program will be accessing entities whose names are part of a namespace 
called  std . The reason the program needs access to the  std namespace is because every 
name created by the  iostream file is part of that namespace. For a program to use the 
entities in  iostream , it must have access to the  std namespace. (Notice that the state-
ment ends with a semicolon. More about that in a moment.) 
 The following code appears next: 
 int main() 
 { 
    return 0; 
 } 
 This is called a  function . You will learn a great deal about functions later, but for now, 
you simply need to know that a function is a group of programming statements that 
collectively has a name. The name of this function is  main . Every C++ program must 
have a function named  main , which serves as the program’s starting point. 
 Notice that a set of curly braces appears below the line that reads  int main() . The 
purpose of these braces is to enclose the statements that are in the  main function. In 
this particular program, the  main function contains only one statement, which is 
 return 0;  
 This statement returns the number 0 to the operating system when the program fin-
ishes executing. When you write  your first  C++ programs, you will write other state-
ments inside the main function’s curly braces, as indicated in  Figure   2-1 . 
 NOTE:   At this point, it is not critical that you understand everything about the 
skeleton program. The description that follows is meant to demystify the code, at 
least a little. Because you are a beginning programmer, you should expect that some 
of the following concepts will be unclear. As you dig deeper into the C++ language, 
you will understand these concepts. So, don’t despair! Your journey is just beginning. 
 NOTE:   C++ is a case-sensitive language. That means it regards uppercase letters 
as being entirely different characters than their lowercase counterparts. In C++, the 
name of the  main function must be written in all lowercase letters. C++ doesn’t see 
 Main the same as  main , or  INT the same as  int . This is true for all the C++ key words. 

 
2.2 Displaying Screen Output 
39
 Semicolons 
 In C++, a complete programming  statement ends with a semicolon. You’ll notice 
that some lines of code in the skeleton program do not end with a semicolon, how-
ever. For example, the  include directive does not end with a semicolon because, 
technically speaking, directives are not statements. The  main function header does 
not end with a semicolon because it marks the beginning of a function. Also, the 
curly braces are not followed by a semicolon because they are not statements, as 
they form a container that holds statements. If this is confusing, don’t despair! As 
you practice writing C++ programs more and more, you will develop an intuitive 
understanding of the difference between statements and lines of code that are not 
considered statements. 
 Checkpoint 
 2.1.  Rearrange the following statements to make a skeleton C++ program: 
 int main() 
 return 0; 
 } 
 #include <iostream> 
 { 
 using namespace std;  
#include <iostream>
using namespace std;
int main()
{
    return 0;
}
You will write other C++
statements in this area.
 Figure 2-1  The skeleton program  
 
2.2  Displaying Screen Output 
 CONCEPT:   You write   cout statements to display output in a console window.  
 In this section you will learn to write programs that produce output on the screen. 
The simplest type of screen output that a program can display is  console output , 
which is merely plain text. The word  console is an old computer term. It comes from 
the days when a computer operator interacted with the system by typing on a termi-
nal. The terminal, which consisted of a simple screen and keyboard, was known as 
the  console . 
 On modern computers, running graphical operating systems such as Windows or 
Mac OS, console output is usually displayed in a window such as the one shown in 
 Figure   2-2 .  
VideoNote
Using cout

40 
Chapter 2 
 C++ Fundamentals
 To display console output in C++, you write a  cout statement (pronounced  see out ). 
A  cout statement begins with the word  cout , followed by the  << operator, followed 
by an item of data that is to be displayed. The statement ends with a semicolon. 
Program 2-1 demonstrates.  
 Figure 2-2  A console window  
 NOTE:   The line numbers that are shown at the beginning of each line are  not part 
of the program. This  book shows line numbers in each program because it makes 
it easier to refer to specific parts of the program. When you are typing code, how-
ever, do not type line numbers into your programs! 
 Program 2-1 
  (HelloWorld.cpp) 
 1 #include <iostream> 
 2 using namespace std; 
 3  
 4 int main() 
 5 { 
 6    cout << "Hello world"; 
 7    return 0; 
 8 } 
 Program Output 
 Hello world  
 The  << operator is known as the  stream insertion operator . It always appears on the 
left side of the item of data that you want to display. Notice that in line 6, the  << 
operator appears to the left of the message  Hello world , which is enclosed in a set of 
quotation marks. The quotation marks are not to be displayed. They simply mark the 
beginning and the end of the text that we wish to display. When the program runs, 
 Hello world is displayed. 
 Programs almost always work with data of some type. For example, Program 2-1 uses 
the following piece of data, in line 6: 
 "Hello world" 

 
2.2 Displaying Screen Output 
41
 This piece of data is a sequence of characters. In programming terms, a sequence of 
characters that is used as data is called a  string . When a string appears in the actual 
code of a program, it is called a  string literal . In program code, a string literal is enclosed 
in quotation marks. As mentioned earlier, the quotation marks simply mark where the 
string begins and ends. 
 You can display multiple items with a single  cout statement, as long as a  << operator 
appears to the left of each item. Program 2-2 shows an example. In line 6, three items 
of data are being displayed: the string literal  "Programming " , the string literal  "is " , 
and the string literal  "fun." . Notice that the  << operator appears to the left of each item. 
 Program 2-2 
 (MultipleItems.cpp)  
 1 #include <iostream> 
 2 using namespace std; 
 3  
 4 int main() 
 5 { 
 6    cout << "Programming " << "is " << "fun."; 
 7    return 0; 
 8 } 
 Program Output 
 Programming is fun.  
 Take a closer look at line 6 of Program 2-2:  
 
cout << "Programming " << "is " << "fun.";
Notice the space.
Notice the space.
 
 Notice that the string literal  "Programming " ends with a space, and the string literal 
 "is " ends with a space. That is because in the program output, we want a space to 
separate the words, as shown here:  
 
Programming is fun.
Notice the space.
Notice the space. 
 Without the spaces in the string literals, the words would appear jammed together in 
the output. For example, if the statement in line 6 had been written like this: 
 cout << "Programming" << "is" << "fun."; 
 Then, the output would appear as: 
 Programmingisfun.  

42 
Chapter 2 
 C++ Fundamentals
 Using the  endl Manipulator 
 When you display output with  cout , the output is displayed as one continuous line on 
the screen. For example, look at Program 2-3. Even though the program has three 
 cout statements, its output appears on one line.  
 Program 2-3 
 (OneLine.cpp) 
 1 #include <iostream> 
 2 using namespace std; 
 3  
 4 int main() 
 5 { 
 6    cout << "Programming "; 
 7    cout << "is "; 
 8    cout << "fun."; 
 9    return 0; 
 10 } 
 Program Output 
 Programming is fun.  
 The output comes out as one long line is because the  cout statement does not start a 
new line unless told to do so. One way to instruct  cout to start a new line is to use 
the  endl manipulator. (You pronounce  endl as “end L,” or “end line.”) Program 2-4 
shows an example. 
 Program 2-4 
  (ThreeLines.cpp)  
 1 #include <iostream> 
 2 using namespace std; 
 3  
 4 int main() 
 5 { 
 6    cout << "Programming" << endl; 
 7    cout << "is" << endl; 
 8    cout << "fun." << endl; 
 9    return 0; 
 10 } 
 Program Output 
 Programming 
 is 
 fun.  
 NOTE:    The last character in  endl is the lowercase letter  L ,  not the number one. 

 
2.2 Displaying Screen Output 
43
 Every time  cout encounters an  endl stream manipulator, it advances the output to the 
beginning of the next line for subsequent printing. The manipulator can be inserted 
anywhere in the stream of characters sent to  cout , outside the double quotes. The fol-
lowing statements show an example. 
 cout << "My pets are" << endl << "dog"; 
 cout << endl << "cat" << endl << "bird" << endl;  
 Using the   \n  Escape Sequence 
 Another way to cause  cout to go to a new line is to insert an  escape sequence in 
the string literal itself. An escape sequence starts with the backslash character ( \ ) 
and is followed by one or more control characters. It allows you to control the way 
output is displayed by embedding commands within a string literal. Program 2-5 is 
an example. 
 Program 2-5 
  (EscapeSequence.cpp)  
 1 #include <iostream> 
 2 using namespace std; 
 3 
 4 int main() 
 5 { 
 6    cout << "The following items were top sellers\n"; 
 7    cout << "during the month of June:\n"; 
 8    cout << "Computer games\nCoffee"; 
 9    cout << "\nAspirin\n"; 
 10    return 0; 
 11 } 
 Program Output 
 The following items were top sellers 
 during the month of June: 
 Computer games 
 Coffee 
 Aspirin  
 The  newline escape sequence is  \n . When  cout encounters  \n in a string, it doesn’t 
print it on the screen, but interprets it as a special command to advance the output 
cursor to the next line. In many situations, using the  \n escape sequence within a 
string literal requires less typing than using  endl . 
 A common mistake made by beginning C++ students is to use a forward slash ( / ) 
instead of a backslash ( \ ) when trying to write an escape sequence. This will not work. 
For example, look at the following code. 
 // Error! 
 cout << "Four Score/nAnd seven/nYears ago./n"; 

44 
Chapter 2 
 C++ Fundamentals
 In this code, the programmer accidentally wrote  /n when he or she meant to write  \n . 
The statement will simply display the  /n characters on the screen. This code will dis-
play the following output: 
 Four Score/nAnd seven/nYears ago./n  
 Another common mistake is to forget to put the  \n inside quotation marks. For exam-
ple, the following code will not compile. 
 // Error! This code will not compile. 
 cout << "Good" << \n; 
 cout << "Morning" << \n;  
 This code will result in an error because the  \n sequences are not inside quotation 
marks. We can correct the code by placing the  \n sequences inside the string literals, 
as shown here: 
 // This will work. 
 cout << "Good\n"; 
 cout << "Morning\n"; 
 C++ has many escape sequences. They give you the ability to exercise greater control 
over the way information is output by your program.  Table   2-1 lists a few of them.  
 Table 2-1   Common Escape Sequences 
 Sequence 
 Name 
 Description 
 \n 
 Newline 
 Causes the cursor to go to the next line for subsequent printing. 
 \t 
 Horizontal tab 
 Causes the cursor to skip over to the next tab stop. 
 \a 
 Alarm 
 Causes the computer to beep. 
 \b 
 Backspace 
 Causes the cursor to back up, or move left one position. 
 \r 
 Return 
 Causes the cursor to go to the beginning of the current line, not 
the next line. 
 \\ 
 Backslash 
 Causes a backslash to be printed. 
 \' 
 Single quote 
 Causes a single quotation mark to be printed. 
 \" 
 Double quote 
 Causes a double quotation mark to be printed. 
 When you type an escape sequence in a string literal, you type two characters (a back-
slash followed by another character). However, an escape sequence is stored in mem-
ory as a single character. For example, consider the following string literal: 
 "One\nTwo\nThree\n" 
 The diagram in  Figure   2-3 breaks this string literal into its individual characters. 
Notice how each of the  \n escape sequences are considered one character.  
 WARNING!   When using escape sequences, do not put a space between the back-
slash and the control character. 

 
2.3 More about the #include Directive 
45
 Checkpoint 
 2.2.  What will the following statement display? 
 cout << "one" << "two" << "three" << endl;  
 2.3.  What will the following statement display? 
 cout << "one"  
     << "two"  
     << "three"  
     << endl;  
 2.4.  What will the following statement display? 
 cout << "one" 
     << endl 
     << "two" 
     << endl  
     << "three"  
     << endl;  
 2.5.  What will the following statement display? 
 cout << "one\n" << "two\n" << "three\n";  
 2.6.  What will the following statement display? 
 cout << "one\ntwo\nthree\n";  
O
n
e
\n
T
w
o
T
\n
h
r
e
e
\n
 Figure 2-3  Characters stored in memory  
 
2.3  More about the  #include Directive 
 CONCEPT:   The   #include directive causes the contents of another file to be inserted 
into the program.  
 Now is a good time to expand our discussion of the  #include directive. The following 
line has appeared near the top of every example program: 
 #include <iostream>  
 As mentioned earlier, this directive causes the contents of a file named  iostream to be 
included in the program. When you compile a C++ source code file, a program known 
as the  preprocessor first reads the C++ source code, looking for lines that begin with 
the  # symbol. These lines are special directives that the preprocessor executes. The 
 #include directive causes the preprocessor to copy the contents of the file that is 
named inside the angled brackets ( <> ) into the C++ program. Files such as  iostream , 
which are included by the preprocessor, are known as  header files . 
 The  iostream header file must be included in any program that uses  cout to display 
output. This is because  cout is not part of the core C++ language. Specifically, it is part 

46 
Chapter 2 
 C++ Fundamentals
of the  input–output stream library . The header file,  iostream , contains code that must 
be included in any program that uses  cout . 
 Preprocessor directives are not C++ statements. They are commands to the preproces-
sor, which runs prior to the compiler (hence the name “preprocessor”). The preproces-
sor’s job is to set programs up in a way that makes life easier for the programmer.  
 WARNING!   Do not put semicolons at the end of processor directives. Because pre-
processor directives are not C++ statements, they do not require semicolons. In many 
cases an error will result from a preprocessor directive terminated with a semicolon. 
 NOTE:   When a header file is included in a C++ program by the preprocessor, you 
don’t actually see the contents of the header file appear in the program. The con-
tents of the header file are only temporarily inserted into the C++ program for the 
purpose of compiling the program. 
 
2.4  A First Look at Variables 
 CONCEPT:    A variable is a storage location in memory that is represented by a name  . 
 Quite often a program needs to store data in the computer’s memory so it can perform 
operations on that data. For example, consider the typical online shopping experi-
ence: You browse a Web site and add the items that you want to purchase to the 
shopping cart. As you add items to the shopping cart, data about those items is stored 
in memory. Then, when you click the checkout button, a program running on the Web 
site’s computer calculates the total of all the items you have in your shopping cart, 
applicable sales taxes, shipping costs, and the total of all these charges. When the 
program performs these calculations, it stores the results in the computer’s memory. 
 Programs use variables to store data in memory. A  variable is a storage location in 
memory that is represented by a name. For example, a program that calculates the 
sales tax on a purchase might use a variable named  tax to hold that value in memory. 
And a program that calculates the distance from Earth to a distant star might use a 
variable named  distance to hold that value in memory. 
 In C++, you must declare a variable in a program before you can use it to store data. 
You do this with a  variable declaration , which specifies two things about the variable: 
 1.  The variable’s data type, which is the type of data the variable will hold  
 2.  The variable’s name  
 A variable declaration statement is written in this general format: 
 DataType VariableName ; 
 Let’s take a closer look at each of these. 

 
2.4 A First Look at Variables 
47
 Data Type 
 A variable’s  data type indicates the type of data that the variable will hold. Before you 
declare a variable, you need to think about the type of values that will be stored in 
the variable. For example, will the variable hold a number or a string? If it will hold 
a number, what kind of number will it be, an integer or a real number? When you 
have determined the kind of data that the variable will hold, you select one of the data 
types that C++ provides for variables. The C++ language provides many data types for 
storing fundamental types of data, such as integers, real numbers, and characters. We 
will look at several of them in this chapter.  
 Variable Name 
 A  variable name identifies a variable in the program code. When naming a variable, 
you should always choose a meaningful name that indicates what the variable is used 
for. For example, a variable that holds the temperature might be named  temperature , 
and a variable that holds a car’s speed might be named  speed . You may be tempted to 
give variables short, nondescript names such as  x or  b2 , but names such as these give 
no clue to the purpose of the variables. 
 In addition, you must follow these rules when naming a variable: 
 ●  The first character must be one of the letters  a through  z or  A through  Z or an 
underscore character ( _ ). 
 ●  After the first character, you may use the letters  a through  z or  A through  Z , the 
digits 0 through 9, or underscores.  
 ●  The name cannot contain spaces.  
 Table   2-2 lists some potential variable names and indicates whether each is legal or 
illegal in C++.  
 Table 2-2   Legal and Illegal Variable Names 
 Name 
 Legal or Illegal? 
 dayOfWeek 
 Legal 
 3rdQuarterSales 
 Illegal because identifiers cannot begin with a digit. 
 customer*first*name 
 Illegal because the  * character is not allowed. 
 totalPoints 
 Legal 
 sales tax total 
 Illegal because identifiers cannot contain spaces. 
 Because a variable’s name should reflect the variable’s purpose, programmers often 
find themselves creating names that are made of multiple words. For example, con-
sider the following variable names: 
 grosspay 
 payrate 
 hotdogssoldtoday  
 Unfortunately, these names are not easily read by the human eye because the words 
aren’t separated. Because we can’t have spaces in variable names, we need to find 

48 
Chapter 2 
 C++ Fundamentals
another way to separate the words in a multiword variable name and make it more 
readable to the human eye. 
 One way to do this is to use the underscore character to represent a space. For exam-
ple, the following variable names are easier to read than those previously shown: 
 gross_pay 
 pay_rate 
 hot_dogs_sold_today  
 Another way to address this problem is to use the  camelCase naming convention. 
camelCase names are written in the following manner: 
 ●  You begin writing the name with lowercase letters.  
 ●  The first character of the second and subsequent words is written in uppercase.  
 For example, the following variable names are written in camelCase:  
 grossPay 
 payRate 
 hotDogsSoldToday  
 Table 2-3   Some of the C++ Data Types 
 Data Type 
 Size 
 What It Can Hold 
 short 
 2 bytes 
 Integers in the range of –32,768 to +32,767 
 int 
 4 bytes 
 Integers in the range of –2,147,483,648 to +2,147,483,647 
 long 
 4 bytes 
 Integers in the range of –2,147,483,648 to +2,147,483,647 
 float 
 4 bytes 
 Floating-point numbers in the range of ±3.4×10 –38 to ±3.4×10 38 , 
with 7 digits of accuracy 
 double 
 8 bytes 
 Floating-point numbers in the range of ±1.7×10 –308 to ±1.7×10 308 , 
with 15 digits of accuracy 
 char 
 1 byte 
 Can store integers in the range of –128 to +127. Typically used to 
store characters. 
 string 
 Varies 
 Strings of text. 
 bool 
 1 byte 
 Stores the values  true or  false 
 1 To use the string data type, you must write the directive #include <string> at the top of your 
program. To be correct, string is not a data type in C++, it is a class. We use it as a data type, though. 
 NOTE:    This style of naming is called camelCase because the uppercase characters 
that appear in a name are sometimes reminiscent of a camel’s humps. 
 Commonly Used Data Types 
 Table   2-3 lists some of the C++ data types, gives their memory size in bytes, and de-
scribes the type of data that each can hold.  Note that in Part 1 of this book w  e will 
primarily use the  int ,  double , and  string data types  . 1 

 
2.4 A First Look at Variables 
49
 The  int ,  float , and  double Data Types 
 C++ provides several data types for storing numbers, but most of the time, you 
will use the  int data type to store integers and the  float and  double data type to 
store real numbers.  In Part 1 of this text, w  e will primarily use the  int and  double 
data types  . Here are examples of how you would declare an  int and a  double 
variable: 
 int speed; 
 double distance;  
 The first statement declares an  int variable named  speed . The second example declares 
a  double variable named  distance . 
 In code, you use an  assignment statement to store a value in a variable. For example, 
suppose you have declared an  int variable named  speed , as previously shown. The 
following assignment statement assigns the value 60 to the  speed variable: 
 speed = 60;  
 The equal sign ( = ) is known as the  assignment operator . It assigns the value that 
appears on its right side to the variable that appears on its left side. In this example, 
the item on the left side of the assignment operator is the  speed variable. 
 Let’s look at another assignment statement example. Suppose you have declared a 
 double variable named  distance , as previously shown. The following assignment 
statement assigns the value 27.5 to the  distance variable:  
 distance = 27.5;  
 WARNING!    When writing assignment statements, remember that the variable 
receiving the value must be on the left side of the  = operator. For example, assuming 
that  speed is a variable that has been declared, the following statement will cause 
an error when you compile the program: 
 60 = speed;     ERROR! 
 Once you have assigned a value to a variable, you can use  cout to display the vari-
able’s value. For example, assuming the  speed variable has been declared and a value 
has been assigned to it, the following statement displays its value: 
 cout << speed << endl;  
 Notice that the variable name is not enclosed in quotation marks. Only string literals 
are enclosed in quotation marks. For example, the following statement does not 
display the value of the  speed variable. Instead, it displays the string “speed” on the 
screen: 
 cout << "speed" << endl;   Does  not display the value of the   speed  variable!  
 The code in Program 2-6 demonstrates how variables are declared, assigned values, 
and their values displayed on the screen. 

50 
Chapter 2 
 C++ Fundamentals
 Program 2-6 
  (VariableDemo.cpp) 
 1 #include <iostream> 
 2 using namespace std; 
 3 
 4 int main() 
 5 { 
 6    int speed; 
 7    double distance; 
 8 
 9    speed = 60; 
 10    distance = 27.5; 
 11    cout << "The car's speed was " << speed 
 12         << " miles-per-hour and it traveled " 
 13         << distance << " miles.\n"; 
 14    return 0; 
 15 } 
 Program Output 
 The car's speed was 60 miles-per-hour and it traveled 27.5 miles.  
 Let’s take a closer look at this program. 
 ●  Line 6 declares an  int variable named  speed . 
 ●  Line 7 declares a  double variable named  distance . 
 ●  Line 9 assigns the value 60 to the  speed variable.  
 ●  Line 10 assigns the value 27.5 to the  distance variable.  
 ●  The  cout statement in lines 11 through 13 displays a message that includes the 
values of the  speed and  distance variables.  
 Declaring Variables Inside a Function 
 Notice that the speed and distance variables in Program 2-6 are declared inside the 
 main function. Variables that are declared inside a function are known as local vari-
ables. A  local variable belongs to the function in which it is declared, and only state-
ments inside that function can access the variable. (The term  local is meant to indicate 
that the variable can be used only locally, within the function in which it is declared.) 
 For now, all the programs that you will write will have only one function,  main .  In 
 Chapter   5 , you will learn to write programs with multiple functions, and you will be 
able to declare variables in each function.  
 Declare Variables Before Using Them 
 Notice in Program 2-6 that the variable declarations (in lines 6 and 7) appear before 
any other statements in the function. The purpose of a variable declaration is to tell 
the compiler that you plan to use a variable of a specified name to store a particular 
type of data in the program. A variable declaration statement causes the variable to 
be created in memory. For this reason, a variable’s declaration statement must appear 

 
2.4 A First Look at Variables 
51
 before any other statements in the function that use the variable. This makes perfect 
sense because you cannot store a value in a variable if the variable has not been cre-
ated in memory.  
 Variable Initialization 
 You can optionally initialize a variable with a value when you declare the variable. A 
variable declaration and initialization statement is written in this general format: 
 DataType VariableName = value ; 
 In the general format,   value  is the starting value that the variable should be initialized 
with. For example, the following statement declares an  int variable named  speed , 
initialized with the value 60: 
 int speed = 60;  
 Program 2-7 shows an example. In this program, the  speed and  distance variables 
are declared and initialized in lines 6 and 7. 
 Program 2-7 
  (VariableInit.cpp) 
 1 #include <iostream> 
 2 using namespace std; 
 3 
 4 int main() 
 5 { 
 6    int speed = 60; 
 7    double distance = 27.5; 
 8 
 9    cout << "The car's speed was " << speed 
 10         << " miles-per-hour and it traveled " 
 11         << distance << " miles.\n"; 
 12    return 0; 
 13 } 
 Program Output 
 The car's speed was 60 miles-per-hour and it traveled 27.5 miles.  
 You are not required to initialize a variable when you declare it, but it is usually a 
good idea to do so. If a local variable is declared, but not initialized, it will contain an 
unpredictable value. For this reason, it is almost certain that an error will result if a 
program uses an uninitialized local variable.  
 Declaring Multiple Variables with One Statement 
 You can declare multiple variables of the same data type with one declaration state-
ment. Here is an example: 
 int month, day, year;  

52 
Chapter 2 
 C++ Fundamentals
 This statement declares three  int variables named  month ,  day , and  year . Notice that 
commas separate the variable names. Here is an example of how we can declare and 
initialize the variables with one statement: 
 int month = 5, day = 4, year = 1865;  
 Remember, you can break up a long statement so it spreads across two or more lines. 
Sometimes you will see long variable declarations written across multiple lines, like this: 
 int month = 5, 
    day = 4, 
    year = 1865;  
 Numeric Literals 
 A  numeric literal is a number that is written into a program’s code. When you know, 
at the time that you are writing a program’s code, that you want to store a specific 
number in a variable, you can assign that number as a numeric literal to the variable. 
For example, assuming  speed is an  int variable, the following statement assigns the 
numeric literal 60 to the  speed variable: 
 speed = 60;  
 When you write a numeric literal in a program’s code, the numeric literal is automati-
cally assigned a data type by the compiler. In C++, if a numeric literal is an integer (not 
written with a decimal point), and it fits within the range of an  int (see  Table   2-3 for 
the minimum and maximum values), then the numeric literal is treated as an  int . A 
numeric literal that is treated as an  int is called an   int   literal . For example, each of 
the following statements initializes a variable with an  int literal: 
 int hoursWorked = 40; 
 int unitsSold = 650; 
 int score = -23;  
 If a numeric literal is written with a decimal point, and it fits within the range of a  double 
(see  Table   2-3  for the minimum and maximum values), then the numeric literal is treated 
as a  double . A numeric literal that is treated as a  double is called a   double   literal . For 
example, each of the following statements initializes a variable with a  double literal: 
 double distance = 28.75; 
 double testScore = 87.3; 
 double temperature = -10.0;  
 int Variables and Assignment Compatibility 
 You can assign  int values to  int variables, but you cannot assign  double values to  int 
variables. For example, look at the following declarations. 
 int hoursWorked = 40;   This works 
 int score = -25.5;      ERROR! 
 The first declaration works because we are initializing an  int variable with an  int 
value. The second declaration will cause an error, however, because you cannot assign 
a  double value to an  int variable. 

 
2.4 A First Look at Variables 
53
 You cannot assign a  double value to an  int variable because such an assignment could 
result in a loss of data. Here are the reasons: 
 ●  double values may be fractional, but  int variables can hold only integers. If you 
were allowed to store a fractional value in an  int variable, the fractional part of 
the value would have to be discarded.  
 ●  double values may be much larger or much smaller than allowed by the range 
of an  int variable. A  double number can potentially be so large or so small that 
it will not fit in an  int variable.  
 double Variables and Assignment Compatibility 
 You can assign either  double or  int values to  double variables. For example, look at 
the following declarations. 
 double distance = 28.75;   This works  
 double speed = 75;        This works  
 In the first declaration we are initializing a  double variable with a  double value. In the 
second declaration we are initializing a  double variable with an  int value. Both of 
these statements work. It makes sense that you are allowed to assign an  int value to 
a  double variable because any number that can be stored as an  int can be converted 
to a  double with no loss of data. When you assign an  int value to a  double variable, 
the  int value is implicitly converted to a  double . 
 A Variable Holds One Value at a Time 
 Variables can hold different values while a program is running, but they can hold only one 
value at a time. When you assign a value to a variable, that value will remain in the vari-
able until you assign a different value to the variable. For example, look at Program 2-8. 
 Program 2-8 
  (OneValue.cpp)  
 1 #include <iostream> 
 2 using namespace std; 
 3 
 4 int main() 
 5 { 
 6    double price = 29.95; 
 7 
 8    cout << price << endl; 
 9    price = 12.95; 
 10    cout << price << endl; 
 11    return 0; 
 12 } 
 Program Output 
 29.95 
 12.95  

54 
Chapter 2 
 C++ Fundamentals
 In the program, line 6 declares a  double variable named  price , initialized with the value 
29.95. Line 8 displays the value of the  price variable, which is 29.95. Then, line 9 assigns 
the value 12.95 to the  price variable. This value replaces the value that was previously 
assigned to the variable. Line 10 displays the variable’s value, which is now 12.95. 
 Program 2-8 illustrates two important characteristics of variables: 
 ●  A variable holds only one value at a time.  
 ●  When you store a value in a variable, that value replaces the previous value that 
was in the variable.  
 Scope 
 Programmers use the term  scope to describe the part of a program in which a variable 
may be accessed. A variable is visible only to statements inside the variable’s scope. 
 A local variable’s scope begins at the variable’s declaration and ends at the end of the 
function in which the variable is declared. A local variable cannot be accessed by 
statements that are outside the function in which the variable is declared. In addition, 
a local variable cannot be accessed by code that is inside the function, but before the 
variable’s declaration.  
 Duplicate Variable Names 
 You cannot declare two variables with the same name in the same scope. For example, 
if you declare a variable named  productNumber in a function, you cannot declare an-
other variable with that name in the same function.  
 The  float Data Type 
 You can use the  float data type, as well as the  double data type, to store real numbers. 
If you refer to  Table   2-3  , you will see that the  float data type uses less memory than the 
 double data type, but the  double data type can store a much wider range of numbers and 
has more accuracy.  In Part 1 of this book we  use the  double data type to store real num-
bers because the C++ standard library primarily uses it when working with floating-point 
numbers.  In Part 2, however, we will use the  float data type extensively because the App 
Game Kit library uses it as the primary data type for storing floating-point numbers.  
 Checkpoint 
 2.7.  What is the purpose of a variable?  
 2.8.  What two items do you specify with a variable declaration?  
 2.9.  Summarize the rules for naming variables in C++.  
 2.10.   Indicate whether each of the following is a legal variable name. If it is not, 
explain why. 
 a.  pay_Rate 
 b.   speed Of Sound 
 c.   totalCost 
 d.   1stPlaceScore 

 
2.5 Reading Keyboard Input 
55
 2.11.  For each of the following items, determine whether the data type should be  int 
or  double . 
 a.  The number of apples picked from an apple tree  
 b.   The amount of sales tax for a purchase  
 c.   An average of several test scores  
 d.   The number of items sold  
 2.12.  Describe the camelCase naming convention.  
 2.13.  Does it matter where you write the variable declarations inside a function?  
 2.14.  What is variable initialization?  
 2.15.  What is an uninitialized variable?  
 2.16.  Do uninitialized variables pose any danger in a program?  
 2.17.  What happens when you assign a  double value to an  int variable? 
 2.18.  Write a declaration statement for a variable named  testScore . The data type 
should be  double , and the variable should be initialized with the value 87.5.  
 2.19.  Write a declaration statement for a variable named  points . The data type 
should be  int , and the variable should be initialized with the value 0.  
 
2.5  Reading Keyboard Input 
 CONCEPT:    You write   cin statements to read input from the keyboard.  
 The programs you have seen so far use built-in data, such as numeric literals. Without 
giving the user an opportunity to enter his or her own data, you have initialized the 
variables with the necessary starting values. In reality, most programs require the user 
to enter values that will be assigned to variables. For example, a program that calcu-
lates payroll for a small business might ask the user to enter the employee’s hours 
worked and the employee’s hourly pay rate. When that employee’s pay has been cal-
culated, the program could start over again and ask for the next employee’s hours 
worked and hourly pay rate. 
 To read keyboard input in C++ you write a  cin statement (pronounced  see in ). A  cin 
statement begins with the word  cin , followed by the  >> operator, followed by the 
name of a variable. The statement ends with a semicolon. When the statement exe-
cutes, the program will wait for the user to enter input at the keyboard and press the 
Enter key. When the user presses Enter, the input will be assigned to the variable that 
is listed after the  >> operator. (The  >> operator is known as the  stream extraction 
operator .) Assuming that  value is the name of a variable that has already been 
declared, here is an example of such a statement: 
 cin >> value;  
 This statement causes the program to wait for the user to enter an item of data at the 
keyboard and then press the Enter key. The item that was entered will be stored in the 
 value variable. Program 2-9 demonstrates. 
VideoNote
Reading Input 
with cin

56 
Chapter 2 
 C++ Fundamentals
 Program 2-9 
  (InputExample.cpp) 
 1 #include <iostream> 
 2 using namespace std; 
 3 
 4 int main() 
 5 { 
 6    int age; 
 7 
 8    cout << "What is your age? "; 
 9    cin >> age; 
 10    cout << "I would never have guessed that you are " 
 11         << age << " years old!" << endl; 
 12    return 0; 
 13 } 
 Program Output with Example Input Shown in Bold 
 What is your age?  25 [ Enter ] 
 I would never have guessed that you are 25 years old!  
 Let’s take a closer look at the program: 
 ●  Line 6 declares an  int variable named  age . 
 ●  Line 8 displays a message asking the user what his or her age is.  
 ●  Line 9 uses  cin to read a value from the keyboard. When this statement exe-
cutes, the program waits until the user presses the Enter key. When that happens, 
the value entered at the keyboard is assigned to the  age variable.  
 ●  Lines 10 and 11 display a message that includes the value of the  age variable.  
 The program shown in Program 2-10 uses  cin statements to read a  double and an  int . 
 Program 2-10 
  (SimplePayroll.cpp) 
 1 #include <iostream> 
 2 using namespace std; 
 3 
 4 int main() 
 5 { 
 6    double payRate; 
 7    int hours; 
 8 
 9    cout << "Enter your hourly pay rate: "; 
 10    cin >> payRate; 
 11    cout << "Enter the number of hours worked: "; 
 12    cin >> hours; 
 13 
 14    cout << "Here are the values that you entered:" << endl; 
 15    cout << "Hourly pay rate: " << payRate << endl; 
 16    cout << "Hours worked: " << hours << endl; 
 17    return 0; 
 18 } 

 
2.5 Reading Keyboard Input 
57
 Program Output with Example Input Shown in Bold 
 Enter your hourly pay rate:  25 [ Enter ] 
 Enter the number of hours worked:  40 [ Enter ] 
 Here are the values that you entered: 
 Hourly pay rate: 25 
 Hours worked: 40  
 Prompting the User 
 Getting keyboard input from the user is normally a two-step process: 
 1.  Display a prompt on the screen.  
 2.  Read a value from the keyboard.  
 A  prompt is a message that tells (or asks) the user to enter a specific value. For 
example, Program 2-10 gets the user to enter his or her hourly pay rate with the fol-
lowing statements: 
 cout << "Enter your hourly pay rate: "; 
 cin >> payRate;  
 A  cin statement reads keyboard input, but does not display instructions on the screen. 
It simply causes the program to pause and wait for the user to type something on the 
keyboard and then press the Enter key. For this reason, whenever you write a  cin 
statement to read keyboard input, you should also write a  cout statement just before 
it that tells the user what to enter. Otherwise, the user will not know what he or she 
is expected to do. For example, suppose we remove the  cout statements in lines 9 and 
11 from Program 2-10, as follows: 
 cin >> payRate; 
 cin >> hours;  
 Can you see what would happen when the program runs? The screen would appear blank 
because the first  cin statement would cause the program to wait for something to be typed 
on the keyboard. The user would probably think the computer was malfunctioning. 
 The term  user-friendly is commonly used in the software industry to describe pro-
grams that are easy to use. Programs that do not display adequate or correct 
instructions are frustrating to use and are not considered user-friendly. One of the 
simplest things that you can do to increase a program’s user-friendliness is to make 
sure that it displays clear, understandable prompts prior to each statement that 
reads keyboard input. 
 Checkpoint 
 2.20.  Write a  cin statement that reads an item of input and stores that item in a 
variable named  myvar . 
 2.21.  What is a prompt?  
 2.22.  Write code that prompts the user to enter his or her checking account balance 
and then stores the user’s input in a variable named  balance . 

58 
Chapter 2 
 C++ Fundamentals
 
2.6  Comments, Blank Lines, and Indentation 
 CONCEPT:    Comments are brief notes that are placed in a program’s source code, 
explaining how parts of the program work. Programmers commonly 
use blank lines and indentation in program code to give the code visual 
organization and make it easier to read.  
 Comments are short notes that are placed in different parts of a program, explaining 
how those parts of the program work. Comments are not intended for the compiler. 
They are intended for programmers to read, to help them understand the code. The 
compiler skips all the comments that appear in a program. 
 As a beginning programmer, you might resist the idea of writing a lot of comments in 
your programs. After all, it’s a lot more fun to write code that actually does some-
thing! However, it’s crucial that you take the extra time to write comments. They will 
almost certainly save you time in the future when you have to modify or debug the 
program. Even large and complex programs can be made easy to read and understand 
if they are properly commented. 
 C++ uses two types of comments: single-line and multiline. Let’s briefly discuss 
each type. 
 Single-Line Comments 
 To create a single-line comment, simply place two forward slashes ( // ) where you 
want the comment to begin. The compiler ignores everything from that point to the 
end of the line. Program 2-11 shows that single-line comments may be placed liberally 
throughout a program. 
 Program 2-11 
  (SingleLineComment.cpp) 
 1 // This program calculates gross pay. 
 2 #include <iostream> 
 3 using namespace std; 
 4 
 5 int main() 
 6 { 
 7    double payRate; // To hold the hourly pay rate 
 8    int hours;      // To hold the hours worked 
 9 
 10    // Get the hourly pay rate. 
 11    cout << "Enter your hourly pay rate: "; 
 12    cin >> payRate; 
 13 
 14    // Get the number of hours worked. 
 15    cout << "Enter the number of hours worked: "; 
 16    cin >> hours; 
 17 
 18    // Display the values entered. 

 
2.6 Comments, Blank Lines, and Indentation 
59
 19    cout << "Here are the values that you entered:" << endl; 
 20    cout << "Hourly pay rate: " << payRate << endl; 
 21    cout << "Hours worked: " << hours << endl; 
 22    return 0; 
 23 } 
 Program Output with Example Input Shown in Bold 
 Enter your hourly pay rate:  25 [ Enter ] 
 Enter the number of hours worked:  40 [ Enter ] 
 Here are the values that you entered: 
 Hourly pay rate: 25 
 Hours worked: 40  
 Multiline Comments 
 The second type of comment in C++ is the multi-line comment.  Multiline comments 
start with  /* (a forward slash followed by an asterisk) and end with  */ (an asterisk 
followed by a forward slash). Everything between these markers is ignored. Program 
2-12 shows an example of a multiline comment in lines 1 through 4. 
 Program 2-12 
  (MultilineComment.cpp) 
 1 /* 
 2    This program gets the user's age 
 3    and displays it in a message. 
 4 */ 
 5 #include <iostream> 
 6 using namespace std; 
 7 
 8 int main() 
 9 { 
 10    int age; 
 11 
 12    cout << "What is your age? "; 
 13    cin >> age; 
 14    cout << "I would never have guessed that you are " 
 15         << age << " years old!" << endl; 
 16    return 0; 
 17 } 
 Program Output with Example Input Shown in Bold 
 What is your age?  25 [ Enter ] 
 I would never have guessed that you are 25 years old!  
 Remember the following advice when using block comments: 
 ●  Be careful not to reverse the beginning symbol ( /* ) with the ending symbol ( */ ).  
 ●  Do not forget the ending symbol.  

60 
Chapter 2 
 C++ Fundamentals
 Using Blank Lines and Indentation to Make Your 
Code Easier to Read 
 Programmers commonly use blank lines and indentations in their code to create a 
sense of visual organization. This is similar to the way that authors visually arrange 
the text on the pages of a book. Instead of writing each chapter as one long series of 
sentences, they break it into paragraphs that are visually separated on the page. This 
does not change the information in the book, but it makes it easier to read. 
 For example, look at the following code sample. Notice that we have inserted a blank 
line to visually separate the code into two sets of statements. The blank line is not 
required, but it makes the code easier for humans to read. Programmers commonly 
insert blank lines at various places to make the code easier to read. 
 // Display the number of hours worked. 
 cout << hoursWorked; 
 // Display the gross pay. 
 cout << grossPay;  
 Programmers also use indentation to visually organize code. You may have noticed that 
in the code editor, all the statements that appear inside a set of braces ( {  } ) are indented. 
For example, all the statements inside a function are indented. In fact, Visual Studio is 
normally set up to automatically indent the code that you write in this fashion. 
 Although the indentation is not required, it makes your code much easier to read. By 
indenting the statements inside a function, you visually set them apart. As a result, you 
can tell at a glance which statements belong to the function. This practice of indenta-
tion is a convention that virtually all programmers follow. 
 Checkpoint 
 2.23.   What purpose do comments serve?  
 2.24.   How are line comments and multiline comments different?  
 2.25.   What should you be careful to remember about the beginning and ending 
symbols of multiline comments?  
 2.26.   Why do programmers insert blank lines and indentations in their code?  
 
2.7  Performing Calculations and Working 
with Numbers 
 CONCEPT:    To perform calculations in a C++ program, you use math operators to 
create math expressions.  
 Most programs require calculations to be performed. A programmer’s tools for 
performing calculations are  math operators . The C++ math operators are shown in 
 Table   2-4  .  

 
2.7 Performing Calculations and Working with Numbers  
61
 Programmers use the operators shown in  Table   2-4 to create math expressions. A 
 math expression performs a calculation and gives a value. The following is an exam-
ple of a simple math expression: 
 12 + 2  
 The values on the right and left of the  + operator are called  operands . These are values 
that the  + operator adds together. The value that is given by this expression is 14. 
 Variables may also be used in a math expression. For example, suppose we have two 
variables named  hours and  payRate . The following math expression uses the  * opera-
tor to multiply the value in the  hours variable by the value in the  payRate variable: 
 hours * payRate  
 When we use a math expression to calculate a value, normally we want to save that 
value in memory so we can use it again in the program. We do this with an assignment 
statement. Here are some examples of statements that use an arithmetic operator to 
calculate a value and assign that value to a variable: 
 total = price + tax; 
 sale = price − discount; 
 population = population * 2; 
 half = number / 2; 
 leftOver = 17 % 3;  
 Program 2-11 shows an example program that performs mathematical calculations. 
 Program 2-11 
  (SalePrice.cpp) 
 1 #include <iostream> 
 2 using namespace std; 
 3 
 4 int main() 
 5 { 
 6    // Declare variables 
 7    double retailPrice, 
 8           discount, 
 9           salePrice; 
 10 
 11    // Get the retail price and discount. 
 Table 2-4   C++’s Math Operators 
 Symbol 
 Operation 
 Description 
 + 
 Addition 
 Adds two numbers 
 - 
 Subtraction 
 Subtracts one number from another 
 * 
 Multiplication 
 Multiplies two numbers 
 / 
 Division 
 Divides one number by another and gives the quotient 
 % 
 Remainder, or Modulus 
 Divides one integer by another and gives the remainder 
VideoNote
Assignment 
Statements and 
Simple Math 
Expressions

62 
Chapter 2 
 C++ Fundamentals
 12    cout << "Enter the item's retail price: "; 
 13    cin >> retailPrice; 
 14    cout << "Enter the amount of the discount: "; 
 15    cin >> discount; 
 16 
 17    // Calculate and display the sale price. 
 18    salePrice = retailPrice − discount; 
 19    cout << "The sale price is: " << salePrice << endl; 
 20    return 0; 
 21 } 
 Program Output with Example Input Shown in Bold 
 Enter the item's retail price:  100 [ Enter ] 
 Enter the amount of the discount:  25 [ Enter ] 
 The sale price is: 75  
 The Order of Operations 
 It is possible to build mathematical expressions with several operators. The follow-
ing statement assigns the sum of 17, the variable  x , 21, and the variable  y to the 
variable  answer . 
 answer = 17 + x + 21 + y;  
 Some expressions are not that straightforward, however. Consider the following 
statement: 
 outcome = 12 + 6 / 3;  
 What value will be stored in outcome? The number 6 is used as an operand for both 
the addition and division operators. The outcome variable could be assigned either 6 
or 14, depending on when the division takes place. The answer is 14 because the 
 order of operations dictates that the division operator works before the addition 
operator does. 
 The order of operations in C++ can be summarized as follows: 
 1.  Perform any operations that are enclosed in parentheses.  
 2.  Perform any multiplications, divisions, or modulus operations as they appear 
from left to right.  
 3.  Perform any additions or subtractions as they appear from left to right.  
 Mathematical expressions are evaluated from left to right. When two operators share 
an operand, the order of operations determines which operator works first. 
Multiplication and division are always performed before addition and subtraction, so 
the statement 
 outcome = 12 + 6 / 3;  
 works like this: 
 1.  6 is divided by 3, yielding a result of 2.  
 2.  12 is added to 2, yielding a result of 14.  

 
2.7 Performing Calculations and Working with Numbers  
63
 It could be diagrammed as shown in  Figure  2-4 . 
outcome = 12 + 6 / 3;
outcome =    14
outcome = 12 +   2
 Figure 2-4  The order of operations at work  
 Table   2-5 shows some other sample expressions with their values.  
 Table 2-5   Some expressions and their values 
 Expression 
 Value 
 5 + 2 * 4 
 13 
 10 / 2 – 3 
 2 
 8 + 12 * 2 − 4 
 28 
 6 – 3 * 2 + 7 − 1 
 6 
 Grouping with Parentheses 
 Parts of a mathematical expression may be grouped with parentheses to force some 
operations to be performed before others. In the following statement, the variables  a 
and  b are added together, and their sum is divided by 4: 
 result = (a + b) / 4;  
 Without the parentheses, however,  b would be divided by 4 and the result added to  a . 
 Table   2-6 shows more expressions and their values.  
 Table 2-6   More expressions and their values 
 Expression 
 Value 
 (5 + 2) * 4 
 28 
 10 / (5 − 3) 
 5 
 8 + 12 * (6 − 2) 
 56 
 (6 − 3) * (2 + 7) / 3 
 9 
 Integer Division 
 Be careful when dividing an integer by another integer. In C++, when an integer is 
divided by another integer, the result will also be an integer. This behavior is known 
as  integer division . For example, look at the following code: 
 double number; 
 number = 3 / 2;  

64 
Chapter 2 
 C++ Fundamentals
 The assignment statement divides 3 by 2 and assigns the result to the  number variable. 
What will be assigned to  number ? You would probably assume that 1.5 would be 
assigned to  number because that’s the result your calculator shows when you divide 3 
by 2. However, that’s not what will happen in C++. Because the numeric literals 3 and 
2 are both treated as  int s, the fractional part of the result will be thrown away. 
(Throwing away the fractional part of a number is called  truncation .) As a result, the 
statement will assign the value 1 to the  number variable, not 1.5. 
 In the previously shown code, it doesn’t matter that  number is declared as a  double 
because the fractional part of the result is discarded before the assignment takes place. 
For a division operation to return a fractional value, at least one of the operands must 
be of a floating-point data type, such as  double . For example, the previously shown 
statement could be written as: 
 double number; 
 number = 3.0 / 2;  
 In this code the numeric literal 3.0 is interpreted as a  double , so the division operation 
will return a  double . The value 1.5 will be assigned to  number . 
 The Remainder (Modulus) Operator 
 In C++, the  % symbol is the remainder operator. (This is also known as the  modulus 
operator. ) The remainder operator performs division, but instead of returning the 
quotient, it returns the remainder. The following statement assigns 2 to leftover: 
 leftover = 17 % 3;  
 This statement assigns 2 to  leftover because 17 divided by 3 is 5 with a remainder 
of 2. The remainder operator is useful in certain situations. It is commonly used in 
calculations that convert times or distances, detect odd or even numbers, and per-
form other specialized operations. For example, Program 2-12 gets a number of 
seconds from the user, and it converts that number of seconds to hours, minutes, and 
seconds. For example, it would convert 11,730 seconds to 3 hours, 15 minutes, and 
30 seconds. 
 Program 2-12 
  (SecondsConverter.cpp)  
 1 // This program converts a number of seconds to 
 2 // hours, minutes, and seconds. 
 3 #include <iostream> 
 4 using namespace std; 
 5 
 6 int main() 
 7 { 
 8    int totalSeconds,  // Total number of seconds 
 9        hours,         // Number of hours 
 10        minutes,       // Number of minutes 
 11        seconds;       // Number of seconds 
 12 
 13    // Get the total number of seconds. 
 14    cout << "Enter a number of seconds: "; 

 
2.7 Performing Calculations and Working with Numbers  
65
 15    cin >> totalSeconds; 
 16 
 17    // Calculate the number of hours. 
 18    // Note: This calculation uses integer division. 
 19    hours = totalSeconds / 3600; 
 20 
 21    // Calculate the number of minutes. 
 22    // Note: This calculation also uses integer division. 
 23    minutes = (totalSeconds / 60) % 60; 
 24 
 25    // Calculate the number of remaining seconds. 
 26    seconds = totalSeconds % 60; 
 27 
 28    // Display the results. 
 29    cout << "Here is the time in hours, minutes, and seconds:\n"; 
 30    cout << "Hours: " << hours << endl; 
 31    cout << "Minutes: " << minutes << endl; 
 32    cout << "Seconds: " << seconds << endl; 
 33    return 0; 
 34 } 
 Program Output with Example Input Shown in Bold 
 Enter a number of seconds:  11730 [ Enter ] 
 Here is the time in hours, minutes, and seconds: 
 Hours: 3 
 Minutes: 15 
 Seconds: 30  
 Let’s take a closer look at the program: 
 ●  Line 14 prompts the user for a number of seconds, and line 15 stores the user’s 
input in the  totalSeconds variable.  
 ●  Line 19 calculates the number of hours in the specified number of seconds. 
There are 3600 seconds in an hour, so this statement divides  totalSeconds by 
3600. Notice that this statement performs integer division (because both 
 totalSeconds and the numeric literal 3600 are  int values). This is intentional 
because we want the number of hours with no fractional part. The result is as-
signed to the  hours variable.  
 ●  Line 23 calculates the number of remaining minutes. This statement first uses 
the  / operator to divide  totalSeconds by 60. (Once again, we are intentionally 
performing integer division.) This gives us the total number of minutes. Then, it 
uses the  % operator to divide the total number of minutes by 60 and get the re-
mainder of the division. The result is the number of remaining minutes, and that 
value is assigned to the  minutes variable.  
 ●  Line 26 calculates the number of remaining seconds. There are 60 seconds in a 
minute, so this statement uses the % operator to divide the  totalSeconds by 60 
and get the remainder of the division. The result is the number of remaining 
seconds, and that value is assigned to the  seconds variable.  
 ●  Lines 29 through 32 display the number of hours, minutes, and seconds.  

66 
Chapter 2 
 C++ Fundamentals
 Combined Assignment Operators 
 Sometimes you want to increase a variable’s value by a certain amount. For example, 
suppose you have a variable named  number and you want to increase its value by 1. 
You can accomplish that with the following statement: 
 number = number + 1;  
 The expression on the right side of the assignment operator calculates the value of  number 
plus 1. The result is then assigned to  number , replacing the value that was previously 
stored there. Effectively, this statement adds 1 to  number . For example, if  number is equal 
to 6 before this statement executes, it will be equal to 7 after the statement executes. 
 Similarly, the following statement subtracts 5 from  number : 
 number = number – 5;  
 If  number is equal to 15 before this statement executes, it will be equal to 10 after the 
statement executes. Here’s another example. The following statement doubles the 
value of the  number variable: 
 number = number * 2;  
 If  number is equal to 4 before this statement executes, it will be equal to 8 after the 
statement executes. 
 These types of operations are very common in programming. For convenience, C++ 
offers a special set of operators known as  combined assignment operators that are 
designed specifically for these jobs.  Table   2-7 shows the combined assignment 
operators.  
 Table 2-7   Combined assignment operators 
 Operator 
 Example Usage 
 Equivalence 
 += 
 x += 5; 
 x = x + 5; 
 -= 
 y -= 2; 
 y = y − 2; 
 *= 
 z *= 10; 
 z = z * 10; 
 /= 
 a /= b; 
 a = a / b; 
 %= 
 c %= 3; 
 c = c % 3; 
 As you can see, the combined assignment operators do not require the programmer 
to type the variable name twice. Also, they give a clear indication of what is happen-
ing in the statement.  
 Mixed-Type Expressions and Data Type Conversion 
 When you perform a math operation on two operands, the data type of the result will 
depend on the data type of the operands. C++ follows these rules when evaluating 
mathematical expressions involving  int and  double values: 
 ●  When an operation is performed on two  int values, the result will be an  int . 
 ●  When an operation is performed on two  double values, the result will be a  double . 

 
2.7 Performing Calculations and Working with Numbers  
67
 ●  When an operation is performed on an  int and a  double , the  int value will be 
temporarily converted to a  double , and the result of the operation will be a 
 double . (An expression that uses operands of different data types is called a 
 mixed-type expression .) 
 The first two situations are straightforward: operations on  int s produce  int s, and 
operations on  double s produce  double s. Let’s look at an example of the third situa-
tion, which involves mixed-type expressions: 
 double number; 
 number = 5 * 2.0;  
 When the assignment statement executes, the value 5 will be converted to a  double 
(5.0) and then multiplied by 2.0. The result, 10.0, will be assigned to  number . 
 The  int to  double conversion that takes place in the previous statement happens 
implicitly. If you need to explicitly perform a conversion, you can use a  type cast 
expression . The general format of a type cast expression is 
 static_cast< DataType >( Value )  
 In the general format,   Value  is a variable or literal value that you wish to convert, 
and   DataType  is the data type you wish to convert   Value  to. Here is an example of 
code that uses a type cast expression: 
 double dvalue = 3.7; 
 int ivalue; 
 ivalue = static_cast<int>(dvalue);  
 This code declares two variables:  dvalue , a  double , and  ivalue , an  int . The type cast 
expression in the third statement returns a copy of the value in  dvalue , converted to an  int . 
When a  double is converted to an  int , the fractional part is thrown away, or truncated, so 
this statement stores 3 in  ivalue . The original value in  dvalue is not changed, however. 
 Type cast expressions are useful in situations where C++ will not perform the desired 
conversion automatically. Program 2-13 shows an example where a type cast expres-
sion is used to prevent integer division from taking place. The statement that uses the 
type cast expression is in line 21. 
 Program 2-13 
  (TypeCast.cpp)  
 1 // This program uses a type cast to avoid integer division. 
 2 #include <iostream> 
 3 using namespace std; 
 4 
 5 int main() 
 6 { 
 7    int books;       // Number of books to read 
 8    int months;      // Number of months spent reading 
 9    double perMonth; // Average number of books per month 
 10 
 11    // Get the number of books the user plans to read. 
 12    cout << "How many books do you plan to read? "; 
 13    cin >> books; 

68 
Chapter 2 
 C++ Fundamentals
 NOTE:    Suppose the statement in line 21 of Program 2-13 had been written like this: 
 perMonth = static_cast<double>(books / months);  
 This statement will produce an incorrect result because integer division will take place. 
The result of the expression  books / months is 4. When 4 is converted to a  double , it 
is 4.0. To prevent the integer division from taking place, only one of the operands of 
the division operation should be converted to a  double prior to the division operation. 
This forces C++ to automatically convert the value of the other operand to a double. 
 In the Spotlight: 
 Calculating Percentages and Discounts 
 Determining percentages is a common calculation in computer programming. Although 
the % symbol is used in general mathematics to indicate a percentage, most program-
ming languages (including C++) do not use the % symbol for this purpose. In a pro-
gram, you have to convert a percentage to a floating-point number, just as you would 
if you were using a calculator. For example, 50 percent would be written as 0.5 and 
2 percent would be written as 0.02. 
 Let’s look at an example. Suppose you earn $6,000 per month, and you are allowed 
to contribute a portion of your gross monthly pay to a retirement plan. You want 
to determine the amount of your pay that will go into the plan if you contribute 5 
percent, 7 percent, or 10 percent of your gross wages. To make this determination, 
you write the program shown in Program 2-14. 
 14 
 15    // Get the number of months it will take. 
 16    cout << "How many months will it take you to read them? "; 
 17    cin >> months; 
 18 
 19    // Calculate and display the average number of 
 20    // books per month. 
 21    perMonth = static_cast<double>(books) / months; 
 22    cout << "That is " << perMonth << " books per month.\n"; 
 23    return 0; 
 24 } 
 Program Output with Example Input Shown in Bold 
 How many books do you plan to read?  9 [ Enter ] 
 How many months will it take you to read them?  2 [ Enter ] 
 That is 4.5 books per month.  
 The variable  books is an  int , but in line 21 its value is converted to a  double before 
the division takes place. Without the type cast expression, integer division would have 
been performed resulting in an incorrect result.  

 Program 2-14 
  (Percentages.cpp)  
 1 #include <iostream> 
 2 using namespace std; 
 3 
 4 int main() 
 5 { 
 6    // Variables to hold the monthly pay and the 
 7    // amount of contribution. 
 8    double monthlyPay = 6000.0, contribution; 
 9  
 10    // Calculate and display a 5% contribution. 
 11    contribution = monthlyPay * 0.05; 
 12    cout << "5 percent is $" << contribution 
 13        << " per month.\n"; 
 14     
 15    // Calculate and display a 7% contribution. 
 16    contribution = monthlyPay * 0.07; 
 17  
 18    cout << "7 percent is $" << contribution 
 19        << " per month.\n"; 
 20     
 21    // Calculate and display a 10% contribution. 
 22    contribution = monthlyPay * 0.1; 
 23    cout << "10 percent is $" << contribution 
 24        << " per month.\n"; 
 25    return 0; 
 26 } 
 Program Output 
 5 percent is $300 per month. 
 7 percent is $420 per month. 
 10 percent is $600 per month.   
 
2.7 Performing Calculations and Working with Numbers  
69
 In the Spotlight: 
 Calculating an Average 
 Determining the average of a group of values is a simple calculation: You add all the 
values and then divide the sum by the number of values. Although this is a straight-
forward calculation, it is easy to make a mistake when writing a program that calcu-
lates an average. For example, let’s assume that  a ,  b , and  c are  double variables. Each 
of the variables holds a value, and we want to calculate the average of those values. 
If we are careless, we might write a statement such as the following to perform the 
calculation: 
 average = a + b + c / 3.0;  

70 
Chapter 2 
 C++ Fundamentals
 Can you see the error in this statement? When it executes, the division will take place 
first. The value in c will be divided by 3.0, and then the result will be added to the 
sum of  a +  b . That is not the correct way to calculate an average. To correct this error, 
we need to put parentheses around  a +  b +  c , as shown here: 
 average = (a + b + c) / 3.0;  
 Let’s step through the process of writing a program that calculates an average. Sup-
pose you have taken three tests in your computer science class, and you want to write 
a program that will display the average of the test scores. Here are the general steps 
the program must take: 
 Get the first test score.  
 Get the second test score.  
 Get the third test score.  
 Calculate the average by adding the three test scores and dividing the sum by 3.  
 Display the average. 
 In the first three steps we prompt the user to enter three test scores. Let’s say we store 
those test scores in the double variables test1, test2, and test3. Then in the fourth 
step we calculate the average of the three test scores. We will use the following state-
ment to perform the calculation and store the result in the average variable, which 
is a double: 
 average = (test1 + test2 + test3) / 3.0;  
 The last step is to display the average. Program 2-15 shows the program. 
 Program 2-15 
  (AverageScore.cpp) 
 1 #include <iostream> 
 2 #include <cmath> 
 3 using namespace std; 
 4 
 5 int main() 
 6 { 
 7    double test1, test2, test3; // To hold the scores 
 8    double average;            // To hold the average 
 9  
 10    // Get the three test scores. 
 11    cout << "Enter the first test score: "; 
 12    cin >> test1; 
 13    cout << "Enter the second test score: "; 
 14    cin >> test2; 
 15    cout << "Enter the third test score: "; 
 16    cin >> test3; 
 17  
 18    // Calculate the average of the scores. 
 19    average = (test1 + test2 + test3) / 3.0; 
 20  
 21    // Display the average. 
 22    cout << "The average score is: " << average << endl; 
 23    return 0; 
 24 } 

 
2.8 Named Constants 
71
 Program Output with Input Shown in Bold 
 Enter the first test score:  90 [ Enter ] 
 Enter the second test score:  80 [ Enter ] 
 Enter the third test score:  100 [ Enter ] 
 The average score is 90  
 Checkpoint 
 2.27.  Summarize the mathematical order of operations.  
 2.28.  Assume  result is a  double variable. When the following statement executes, 
what value will be stored in  result ? 
 result = 4 + 10 / 2;  
 2.29.  Assume  result is a  double variable. When the following statement executes, 
what value will be stored in  result ? 
 result = (2 + 5) * 10;  
 2.30.  Assume  result is a  double variable. When the following statement executes, 
what value will be stored in  result ? 
 result = 5 / 2;  
 2.31.  Rewrite the following statements using combined assignment operators: 
 a.  x = x + 1; 
 b.  lowerY = lowerY – 5; 
 c.   radius = radius * 10; 
 d.   length = length / 2; 
 
2.8  Named Constants 
 CONCEPT:    A named constant is a name that represents a value that cannot be 
changed during the program’s execution.  
 Assume that the following statement appears in a banking program that calculates 
data pertaining to loans: 
 amount = balance * 0.069;  
 In such a program, two potential problems arise. First, it is not clear to anyone other 
than the original programmer what 0.069 is. It appears to be an interest rate, but in 
some situations fees are associated with loan payments. How can the purpose of this 
statement be determined without painstakingly checking the rest of the program? 
 The second problem occurs if this number is used in other calculations throughout the 
program and must be changed periodically. Assuming the number is an interest rate, 

72 
Chapter 2 
 C++ Fundamentals
what if the rate changes from 6.9 percent to 7.2 percent? The programmer would 
have to search through the source code for every occurrence of the number. 
 Both of these problems can be addressed by using a named constant. A  named  constant 
is a name that represents a value that cannot be changed during the program’s execution. 
The following is an example of how you can declare a named constant in C++: 
 const double INTEREST_RATE = 0.129;  
 This statement declares a named constant named  INTEREST_RATE initialized with the 
value 0.129. It looks like a regular variable declaration, except that the word  const 
appears before the data type name, and the name of the variable is written in upper-
case characters. The keyword  const is a qualifier that tells the compiler to make the 
variable read only. If a statement attempts to change the constant’s value, an error will 
occur when the program is being compiled. When you declare a named constant, an 
initialization value is required. 
 It is not required that the constant name be written in uppercase letters, but many 
programmers prefer to write them this way so they are easily distinguishable from 
regular variable names. When you are reading a program’s code and see an uppercase 
identifier, you know instantly that it is a constant. 
 An advantage of using named constants is that they make programs more self-explanatory. 
The statement 
 amount = balance * 0.069;  
 can be changed to read 
 amount = balance * INTEREST_RATE;  
 A new programmer can read the second statement and know what is happening. It is 
evident that  balance is being multiplied by the interest rate. Another advantage to this 
approach is that widespread changes can easily be made to the program. Let’s say the 
interest rate appears in a dozen different statements throughout the program. When 
the rate changes, the initialization value in the declaration of the named constant is 
the only value that needs to be modified. If the rate increases to 7.2 percent, the dec-
laration can be changed to the following: 
 const double INTEREST_RATE = 0.072;  
 The new value of 0.072 will then be used in each statement that uses the  INTEREST_RATE 
constant. 
 Named constants can also help prevent typographical errors in a program’s code. For 
example, suppose you use the number 3.14159 as the value of  pi in a program that 
performs various geometric calculations. Each time you type the number 3.14159 in 
the program’s code, there is a chance that you will make a mistake with one or more 
of the digits. As a result, the program will not produce the correct results. To help 
prevent a mistake such as this, you can define a named constant for  pi , initialized with 
the correct value, and then use that constant in all the formulas that require its value. 
Program 2-16 shows an example. It calculates the circumference of a circle that 
has a diameter of 10. 

 
2.8 Named Constants 
73
 Program 2-16 
  (NamedConstant.cpp) 
 1 // This program calculates the circumference of a circle. 
 2 #include <iostream> 
 3 using namespace std; 
 4 
 5 int main() 
 6 { 
 7    // Constants 
 8    const double PI = 3.14159; 
 9    const double DIAMETER = 10.0; 
 10 
 11    // Variable to hold the circumference 
 12    double circumference; 
 13  
 14    // Calculate the circumference. 
 15    circumference = PI * DIAMETER; 
 16 
 17    // Display the circumference. 
 18    cout << "The circumference is: " << circumference << endl; 
 19    return 0; 
 20 } 
 Program Output 
 The circumference is: 31.4159  
 Let’s take a closer look at the program. Line 8 defines a constant  double named  PI , 
initialized with the value 3.14159. This constant will be used for the value of  pi in the 
program’s calculation. Line 9 defines a constant  double named  DIAMETER , initialized 
with the value 10. This will be used for the circle’s diameter. Line 12 defines a  double 
variable named  circumference , which will be used to hold the circle’s circumference. 
Line 15 calculates the circle’s circumference by multiplying  PI by  DIAMETER . The result 
of the calculation is assigned to the  circumference variable. Line 18 displays the 
circle’s circumference. 
 Checkpoint 
 2.32.  Write statements using the  const qualifier to create named constants for the 
following literal values: 
 Literal Value 
Description 
 2.71828 
Euler’s number (known in mathematics as  e ) 
 5.256E5  
Number of minutes in a year  
 32.2  
The gravitational acceleration constant (in feet per second 2 ) 
 9.8  
 The gravitational acceleration constant (in meters per second 2 ) 
 1609  
Number of meters in a mile  

74 
Chapter 2 
 C++ Fundamentals
 
2.9  Math Functions in the Standard Library 
 CONCEPT:    The C++ standard library provides several functions for performing 
advanced mathematical operations.  
 The C++ standard library provides numerous functions that perform common math-
ematical operations. To use these functions you need to write the following include 
directive at the top of your program: 
 #include <cmath>  
 One of the math functions is named  pow , and it raises a number to a power. Here is 
an example of how you use it: 
 area = pow(4.0, 2.0);  
 This statement  calls the  pow function. Notice that inside the parentheses, two numbers 
appear that are separated with a comma. The numbers inside the parentheses are  argu-
ments , which are pieces of data being sent to the function. In this case, the first argument 
is 4.0, and the second argument is 2.0. The  pow function always raises the first argument 
to the power of the second argument. In this example, 4.0 is raised to the power of 2.0. 
The result is  returned from the function. In this case, the value 16 is returned from the 
 pow function and assigned to the  area variable. This is illustrated in  Figure   2-5  .  
area = pow(4.0, 2.0);
16
1st
argument
2nd
argument
 Figure 2-5  Using the  pow function  
 Program 2-17 solves a simple math problem. It asks the user to enter the radius of a circle 
and then calculates the area of the circle. The formula for finding the area of a circle is 
 area = πr2 
 which is expressed in the program as 
 area = PI * pow(radius, 2.0);  
 Program 2-17 
  (PowFunction.cpp)  
 1 // This program demonstrates the pow function. 
 2 #include <iostream> 
 3 #include <cmath> 
 4 using namespace std; 
 5 
 6 int main() 
 7 { 
 8    double radius, area; 

 
2.9 Math Functions in the Standard Library 
75
 9    const double PI = 3.14159; 
 10 
 11    // Get the circle's radius. 
 12    cout << "Enter the circle's radius: "; 
 13    cin >> radius; 
 14 
 15    // Calculate and display the circle's area. 
 16    area = PI * pow(radius, 2.0); 
 17    cout << "The circle's area is: " << area << endl; 
 18    return 0; 
 19 } 
 Program Output with Example Input Shown in Bold 
 Enter the circle's radius:  10 [ Enter ] 
 The circle's area is: 314.159   
 Table 2-8   Some of the C++ math functions 
 Function 
 Description 
 acos( x ) 
 Returns the arc cosine of  x , in radians. The argument and the return value are  double s. 
 asin( x ) 
 Returns the arc sine of  x , in radians. The argument and the return value are  double s. 
 atan( x ) 
 Returns the arc tangent of  x , in radians. The argument and the return value are  double s. 
 ceil( x ) 
 Returns the smallest whole number that is greater than or equal to  x . The argument 
and the return value are  double s. 
 cos( x ) 
 Returns the cosine of  x  in radians. The argument and the return value are  double s. 
 exp( x ) 
 Returns  e x . The argument and the return value are  double s. 
 floor( x ) 
 Returns the largest whole number that is less than or equal to  x . The argument and 
the return value are  double s. 
 log( x ) 
 Returns the natural logarithm of  x . The argument and the return value are  double s. 
 log10( x ) 
 Returns the base-10 logarithm of  x . The argument and the return value are  double s. 
 pow( x, y )  Returns the value of  x  raised to the power of  y . The arguments and the return value 
are  double s. 
 sin( x ) 
 Returns the sine of  x  in radians. The argument and the return value are  double s. 
 sqrt( x ) 
 Returns the square root of  x . The argument and the return value are  double s. 
 tan( x ) 
 Returns the tangent of  x  in radians. The argument and the return value are  double s. 
 NOTE:    Program 2-15 is presented as a demonstration of the  pow function. In real-
ity, there is no reason to use the  pow function in such a simple operation. The math 
statement could just as easily be written as 
 area = PI * radius * radius;  
 The  pow function is useful, however, in operations that involve larger exponents. 
 Table   2-8 lists several of the C++ math functions.  

76 
Chapter 2 
 C++ Fundamentals
 
2.10  Working with Strings 
 CONCEPT:    You use the standard library’s    string  class to create objects that can 
hold strings.  
 C++ does not have a built-in data type for storing strings, but the C++ standard li-
brary does provide something called the   string   class . You can use the  string class 
to create objects in memory that work like string variables. 
 The first step in using the  string class is to include the  string header file. This is 
accomplished with the following preprocessor directive: 
 #include <string>  
 The next step is to declare a  string object. For example, the following statement 
declares a string  object named  movieTitle . 
 string movieTitle;  
 You can initialize the object with a string literal when you declare it, as shown here: 
 string movieTitle = "Wheels of Fury"; 
 You can also assign a string literal to the object with the assignment operator, as 
shown here: 
 movieTitle = "Midnight in the Library"; 
 You can use  cout to display the value of a  string object, as shown here: 
 cout << "My favorite movie is " << movieTitle << endl;  
 Program 2-18 is a complete program that demonstrates some of the preceding statements. 
 Program 2-18 
  (StringExample.cpp)  
 1 // This program demonstrates the string class. 
 2 #include <iostream> 
 3 #include <string> 
 4 using namespace std; 
 5 
 6 int main() 
 7 { 
 8    string movieTitle = "Wheels of Fury"; 
 9 
 10    cout << "My favorite movie is " << movieTitle << endl; 
 11    return 0; 
 12 } 
 Program Output 
 My favorite movie is Wheels of Fury  

 
2.10 Working with Strings 
77
 You can use  cin to read string input from the keyboard, as shown in Program 2-19. 
 Program 2-19 
  (StringInput1.cpp)  
 1 // This program demonstrates string input. 
 2 #include <iostream> 
 3 #include <string> 
 4 using namespace std; 
 5 
 6 int main() 
 7 { 
 8    string name; 
 9 
 10    // Get the user's name. 
 11    cout << "Enter your name: "; 
 12    cin >> name; 
 13 
 14    // Display the user's name. 
 15    cout << "Your name is: " 
 16         << name << endl; 
 17    return 0; 
 18 } 
 Program Output with Example Input Shown in Bold 
 Enter your name:  Liza [ Enter ] 
 Your name is: Liza  
 There is a limitation to using  cin to read string input: A  cin statement can read 
only one word. For example, when Program 2-17 runs, if the user enters  Liza 
Smith , only the word  Liza will be read by  cin and stored in the  name object. The 
program would display  Your name is: Liza . Program 2-20 demonstrates how two 
 cin statements are needed if we want the program to read both the user’s first and 
last names. 
 Program 2-20 
  (StringInput2.cpp)  
 1 // This program demonstrates string input. 
 2 #include <iostream> 
 3 #include <string> 
 4 using namespace std; 
 5 
 6 int main() 
 7 { 
 8    string firstName, lastName; 
 9 
 10    // Get the user's first and last names. 
 11    cout << "Enter your first name: "; 

78 
Chapter 2 
 C++ Fundamentals
 12    cin >> firstName; 
 13    cout << "Enter your last name: "; 
 14    cin >> lastName; 
 15 
 16    // Display the user's first and last names. 
 17    cout << "Your name is: " 
 18         << firstName << " " 
 19         << lastName << endl; 
 20    return 0; 
 21 } 
 Program Output with Example Input Shown in Bold 
 Enter your first name:  Liza [ Enter ] 
 Enter your last name:  Smith [ Enter ] 
 Your name is: Liza Smith  
 The  + operator also works with  string objects. You have already seen how the  + 
operator adds two numbers. Because strings cannot be added, when the  + operator 
is used with strings, it  concatenates them, or joins them together. The following 
demonstrates: 
 string greeting = "Hello " + "world"; 
 This statement declares a  string object named  greeting . The object will be initialized 
with the string  "Hello world" . The following shows another example: 
 string str1 = "Hello "; 
 string str2; 
 string str3 = "World"; 
 string str4 = "People"; 
 str2 = str1 + str3;     // str2 now holds "Hello World" 
 str1 = str1 + str4;      // str1 now holds "Hello People" 
 Checkpoint 
 2.33.   What header file must you include to use  string objects?  
 2.34.   Write a statement that declares a  string object named  myName , initialized with 
your name.  
 2.35.   Look at the following code sample, and assume that the user enters  Cheryl 
Green as input. What will the last  cout statement display? 
 string name; 
 cout << "Enter your name? " 
 cin >> name; 
 cout << name << endl;  
 2.36.   What will be stored in the  message object after the following statement is 
executed? 
 string message = "He" + "ll" + "o!";  

 
2.11 The char Data Type 
79
 
2.11  The  char  Data Type 
 CONCEPT:   You use the   char data type to store individual characters in memory.  
 The  char data type is used to store individual characters. A variable of the  char data 
type can hold only one character at a time. Here is an example of how you might 
declare a  char variable: 
 char letter;  
 This statement declares a  char variable named  letter , which can store one character. 
In C++,  character literals are enclosed in single quotation marks. Here is an example, 
showing how we would assign a character to the  letter variable: 
 letter = 'g'; 
 This statement assigns the character  'g' to the  letter variable. Because  char vari-
ables can hold only one character, they are not compatible with strings. For example, 
you cannot assign a string to a  char variable, even if the string contains only one 
character. The following statement, for example, will not compile because it attempts 
to assign a string literal to a  char variable. 
 letter = "g"; // ERROR! Cannot assign a string to a char  
 It is important that you do not confuse character literals, which are enclosed in single 
quotation marks, with string literals, which are enclosed in double quotation marks. 
Program 2-21 demonstrates how character literals are assigned to a  char variable. 
 Program 2-21 
  (CharLiterals.cpp)  
 1 #include <iostream> 
 2 using namespace std; 
 3 
 4 int main() 
 5 { 
 6    char letter; 
 7  
 8    letter = 'A'; 
 9    cout << letter << endl; 
 10  
 11    letter = 'B'; 
 12    cout << letter << endl; 
 13  
 14    letter = 'C'; 
 15    cout << letter << endl; 
 16    return 0; 
 17 } 
 Program Output 
 A 
 B 
 C 

80 
Chapter 2 
 C++ Fundamentals
 Review Questions 
 Matching  
 
1.  Which of the following include directives is correct?  
 a.  #include (iostream) 
 b.  #include {iostream} 
 c.  #include <iostream> 
 d.  #include [iostream] 
 
2.  A _____ is a storage location in memory that is represented by a name.  
 a.  mnemonic  
 b.  data type  
 c.  namespace  
 d.  variable  
 
3.  In C++, you must _____ a variable before you can use it to store data.  
 a.  cite  
 b.  associate  
 c.  declare  
 d.  instance  
 
4.  A variable’s _____ indicates the type of data that the variable will hold.  
 a.  name  
 b.  data type  
 c.  scope  
 d.  value  
 
5.  A _____ identifies a variable in the program code.  
 a.  binary number 
 b.  variable name  
 c.  unique global identifier  
 d.  hexadecimal value  
 
6.  An operation that is performed on strings using the  + operator is _____, or 
appending one string to the end of another string.  
 a.  addition 
 b.  merging  
 c.  concatenation  
 d.  tying 
 
7.  Programmers use the term _____ to describe the part of a program in which a 
variable may be accessed.  
 a.  range  
 b.  scope  
 c.  focus  
 d.  field  
 
8.  Short notes placed in different parts of a program explaining how those parts of 
the program work are called _____.  
 a.  comments  
 b.  reference manuals  

 
Review Questions 
81
 c.  tutorials  
 d.  external documentation  
 
9.   You can use a _____ to explicitly convert a value from one numeric data type to 
another, even if the conversion might result in a loss of data.  
 a.  transpose statement  
 b.  type cast expression  
 c.  conversion operator  
 d.  literal conversion  
 
10.   The process of dropping a number’s fractional part is called _____.  
 a.  data downgrading  
 b.  two’s complement  
 c.   numeric rounding  
 d.   truncation  
 
11.   A programmer’s tools for performing calculations are _____.  
 a.  math operators  
 b.  numeric literals  
 c.  local variables  
 d.   parsed literals  
 
12.   A _____ performs a calculation and gives a value.  
 a.  numeric literal  
 b.   math expression  
 c.  machine instruction  
 d.   programming statement  
 
13.  In the expression 12 + 7, the values on the right and left of the + symbol are 
called _____.  
 a.  operands 
 b.  operators  
 c.  arguments  
 d.  math expressions  
 
14.  C++ offers a special set of operators known as _____ that are designed specifi-
cally for changing the value of a variable without having to type the variable 
name twice.  
 a.  combined assignment operators  
 b.  advanced math operators  
 c.  variable modifiers  
 d.   assignment sequencers  
 
15.   A _____ is a name that represents a literal value and cannot be changed during 
the program’s execution.  
 a.  named literal  
 b.   named constant  
 c.  variable signature  
 d.  key term  

82 
Chapter 2 
 C++ Fundamentals
 
16.  The _____ data type is used to store individual characters in memory.  
 a.  character 
 b.  alpha 
 c.  char 
 d.  letter 
 True or False  
 
1.  In C++, uppercase and lowercase letters are considered the same.  
 
2.  A semicolon must appear at the end of an include directive.  
 
3.  Comments are ignored by the compiler.  
 
4.  When you declare a named constant, an initialization value is required.  
 
5.  In a math expression, multiplication and division takes place before addition and 
subtraction.  
 
6.  Variable names can have spaces in them.  
 
7.  In C++ the first character of a variable name can be a number.  
 
8.  String literals are enclosed in double quotation marks.  
 
9.  char literals are enclosed in double quotation marks.  
 Short Answer  
 
1.   What two things does a variable declaration specify about a variable?  
 
2.   Give an example of a programming statement that uses string concatenation.  
 
3.   What is the term used for a number that is written into a program’s code?  
 
4.   Write a programming statement that assigns an integer literal to a variable.  
 
5.   Is the following comment written using single-line or multiline comment symbols? 
 /* This program was written by M. A. Codewriter*/  
 
6.  Is the following comment written using single-line or multiline comment symbols? 
 // This program was written by M. A. Codewriter  
 
7.  What standard library function do you use to raise a number to a power? What 
include directive must you write to use the function?  
 Algorithm Workbench  
 
1.  Assume the following code is part of a complete program. What will it display? 
 cout << "Be careful\n"; 
 cout << "This might/n be a trick "; 
 cout << "question\n";  
 
2.  What would the following code display if it were part of a complete program? 
 int a = 5; 
 int b = 2; 
 int c = 3; 
 int result = a + b * c; 
 cout << result << endl;  

 
Programming Exercises 
83
 
3.   What would the following code display if it were part of a complete program? 
 int num = 99; 
 num = 5; 
 cout << num << endl;  
 
4.   Assume that  a ,  b , and  c are variables that have been declared. Write assignment 
statements that perform the following operations: 
 a.  Adds 2 to  a and assigns the result to  b 
 b.  Multiplies  b times 4 and assigns the result to  a 
 c.  Divides  a by 3.14 and assigns the result to  b 
 d.  Subtracts 8 from  b and assigns the result to  a 
 
5.   Write a C++ code that prompts the user to enter his or her height and assigns the 
user’s input to a variable named  height . 
 
6.   Write a C++ code that prompts the user to enter the name of his or her favorite 
color and assigns the user’s input to a  string object named  color . 
 
7.   Rewrite the following statements using combined assignment operators. 
 x = x + 5; 
 total = total + subtotal; 
 dist = dist / rep; 
 ppl = ppl * period; 
 inv = inv − shortage; 
 num = num % 2;  
 Programming Exercises 
 
1.   Personal Information 
 Write a program that displays the following information: 
 •  Your name  
 •  Your address, with city, state, and ZIP  
 •  Your telephone number  
 •  Your college major  
 
2.   Sales Prediction 
 A company has determined that its annual profit is typically 23 percent of total 
sales. Write a program that asks the user to enter the projected amount of total 
sales, and then displays the profit that will be made from that amount.  Hint: Use 
the value 0.23 to represent 23 percent. 
 
3.   Land Calculation 
 One acre of land is equivalent to 43,560 square feet. Write a program that asks 
the user to enter the total square feet in a tract of land and calculates the num-
ber of acres in the tract.  Hint: Divide the amount entered by 43,560 to get the 
number of acres. 
 
4.   Total Purchase 
 A customer in a store is purchasing five items. Write a program that asks for the 
price of each item, and then displays the subtotal of the sale, the amount of sales 
tax, and the total. Assume the sales tax is 6 percent.  
VideoNote
Solving the Total 
Purchase 
Programming 
Problem

84 
Chapter 2 
 C++ Fundamentals
 
5.  Distance Traveled 
 Assuming there are no accidents or delays, the distance that a car travels down 
the interstate can be calculated with the following formula: 
 Distance = Speed × Time 
 A car is traveling at 60 miles per hour. Write a program that displays the 
following: 
 •  The distance the car will travel in 5 hours  
 •  The distance the car will travel in 8 hours  
 •  The distance the car will travel in 12 hours  
 
6.   Sales Tax 
 Write a program that will ask the user to enter the amount of a purchase. The 
program should then compute the state and county sales tax. Assume the state 
sales tax is 4 percent and the county sales tax is 2 percent. The program should 
display the amount of the purchase, the state sales tax, the county sales tax, the 
total sales tax, and the total of the sale (which is the sum of the amount of pur-
chase plus the total sales tax).  Hint: Use the value 0.02 to represent 2 percent, 
and 0.04 to represent 4 percent. 
 
7.   Miles-per-Gallon 
 A car’s miles-per-gallon (MPG) can be calculated with the following formula: 
 MPG = miles ÷ gallons 
 Write a program that asks the user for the number of miles driven and the gallons 
of gas used. It should calculate the car’s MPG and display the result.  
 
8.   Tip, Tax, and Total 
 Write a program that calculates the total amount of a meal purchased at a restau-
rant. The program should ask the user to enter the charge for the food and then 
calculate the amount of a 18 percent tip and 7 percent sales tax. Display each of 
these amounts and the total.  
 
9.   Celsius to Fahrenheit Temperature Converter 
 Write a program that converts Celsius temperatures to Fahrenheit temperatures. 
The formula is as follows: 
 F = 1.8 × C + 32  
 In the formula,  F stands for the Fahrenheit temperature, and  C stands for the 
Celsius temperature. The program should ask the user to enter a temperature in 
Celsius and then display the temperature converted to Fahrenheit.  
 
10.   Stock Transaction Program 
 Last month Joe purchased some stock in Acme Software, Inc. Here are the details 
of the purchase: 
 •  The number of shares that Joe purchased is 1,000.  
 •  When Joe purchased the stock, he paid $32.87 per share.  
 •  Joe paid his stockbroker a commission that amounted to 2 percent of the 
amount he paid for the stock.  

 
Programming Exercises 
85
 Two weeks later Joe sold the stock. Here are the details of the sale: 
 •  The number of shares that Joe sold is 1,000.  
 •  He sold the stock for $33.92 per share.  
 •  He paid his stockbroker another commission that amounted to 2 percent of 
the amount he received for the stock.  
 Write a program that displays the following information: 
 •  The amount of money Joe paid for the stock.  
 •  The amount of commission Joe paid his broker when he bought the stock.  
 •  The amount that Joe sold the stock for.  
 •  The amount of commission Joe paid his broker when he sold the stock.  
 •  Display the amount of money that Joe had left when he sold the stock and 
paid his broker (both times). If this amount is positive, then Joe made a 
profit. If the amount is negative, then Joe lost money.  

This page intentionally left blank 

87
 Decision Structures 
and Boolean Logic 
 3.1  Control Structures  
 3.2  Writing a Decision Structure with the  if 
Statement  
 3.3  The  if - else Statement  
 3.4  Nested Decision Structures and the 
 if - else-if Statement  
 3.5   Logical Operators  
 3.6  The  switch Statement  
 3.7   bool Variables  
 3.8  Comparing Strings  
 TOPICS 
3 
 CHAPTER
 
  3.1  Control Structures 
 CONCEPT:    Control structures affect the order in which statements execute. The three 
main types of control structures are sequence, decision, and repetition.  
 A  control structure determines the order in which a set of statements executes. Back 
in the 1960s a group of mathematicians proved that only three control structures are 
needed to write any type of program: the sequence structure, the decision structure, 
and the repetition structure. The simplest of these structures is the  sequence structure , 
which is a set of statements that executes in the order that they appear. Without real-
izing it, you have already used the sequence structure many times. For example, look 
at the following  main function: 
 int main() 
 { 
   cout << "Hello, world." << endl; 
   cout << "This is a simple program." << endl; 
   return 0; 
 } 
 The statements inside the function are a sequence structure because they execute in the 
order that they are written, from the top of the function to the bottom of the function. 

88 
Chapter 3 
 Decision Structures and Boolean Logic
When programmers design programs, they sometimes draw diagrams known as flow-
charts, which show a program’s logical flow of execution.  Figure  3-1  shows a flowchart 
for the  main function previously shown. The elliptical symbols at the top and bottom of 
the flowchart are known as  terminals because they mark starting and ending points. The 
symbols that appear between the terminals are the steps taken in the program. Notice 
that the symbols are connected by arrows that represent the flow of execution. To step 
through the program’s actions, you begin at the  Start terminal and follow the arrows 
until you reach the  Return 0 terminal. As you can see, this flowchart depicts a sequence 
structure because the steps are taken one after another, from the beginning to the end.  
 NOTE:   Flowcharts are planning tools that programmers sometimes use to design 
a program’s logic. Notice that no actual code is written in  Figure   3-1 . The steps are 
written as informal statements that simply describe the actions that must take place. 
Once the programmer has determined all the actions that must take place and the 
order in which they must be performed, the programmer can refer to the flowchart 
while writing the code. 
 Although the sequence structure is heavily used in programming, it cannot handle every 
type of task. This is because some problems simply cannot be solved by performing a 
set of ordered steps, one after the other. In some programs, a set of statements must be 
executed only under certain circumstances. If those circumstances do not exist, the state-
ments should be skipped. For example, consider a company payroll program that deter-
mines whether an employee has worked overtime. If the employee has worked more 
than 40 hours, he or she is paid extra for all the hours over 40. Otherwise, the overtime 
calculation should be skipped. This can be accomplished with a  decision structure . 
 Suppose the same payroll program calculates pay for all employees. This means it has 
to perform the same steps for each employee. This requires a repetition structure. A 
Return 0
Start
Display
“Hello, world.” 
Display
“This is a simple program.”
 Figure 3-1  Flowchart for a sequence structure  

 
3.2 Writing a Decision Structure with the if Statement 
89
 repetition structure , which is also known as a  loop , is a structure that repeats a set of 
statements as many times as necessary. 
 In this chapter you will learn how to write decision structure code in C++.  In  Chapter  4 , 
you will learn to write repetition structure code.  
 Pseudocode 
 In addition to flowcharts, programmers often use  pseudocode (pronounced “sue doe 
code”) to design their programs. The word  pseudo means fake, so pseudocode is fake 
code. It is an informal language that has no syntax rules and is not meant to be com-
piled or executed. Because programmers don’t have to worry about syntax errors 
while writing pseudocode, they can focus all their attention on the program’s logic. 
Once a satisfactory design has been created with pseudocode, the pseudocode can be 
translated directly to actual code. 
 The following example shows pseudocode for a program that calculates an employee’s 
gross pay: 
 Display “Enter the number of hours the employee worked.”  
 Input hours 
 Display “Enter the employee’s hourly pay rate.”  
 Input payRate  
 grossPay = hours * payRate 
 Display grossPay 
 Each statement in the pseudocode represents an operation that can be translated to 
C++. (This pseudocode is a sequence structure because the steps takes place one after 
the other.)  Throughout this book you will see other examples of pseudocode and how 
it can be translated into actual C++ code.  
 Checkpoint 
 3.1.  What does a control structure determine?  
 3.2.  Name three types of control structures.  
 3.3.  What type of control structure have you used so far  working through this book ?  
 
  3.2  Writing a Decision Structure 
with the  if Statement 
 CONCEPT:    The  if statement is used to create a decision structure, which allows 
a program to have more than one path of execution. The  if statement 
causes one or more statements to execute only when a Boolean 
expression is true.  
 In a decision structure’s simplest form, a specific action is performed only if a certain 
condition exists. If the condition does not exist, the action is not performed.  Figure   3-2  
VideoNote
The if Statement

90 
Chapter 3 
 Decision Structures and Boolean Logic
shows part of a flowchart. The figure shows how the logic of an everyday decision can 
be diagrammed as a decision structure. The diamond symbol represents a true/false 
condition. If the condition is true, we follow one path, which leads to an action being 
performed. If the condition is false, we follow another path, which skips the action.  
 In the flowchart, the diamond symbol indicates some condition that must be tested. 
In this case, we are determining whether the condition  Cold outside is true or false. If 
this condition is true, the action  Wear a coat is performed. If the condition is false, the 
action is skipped. The action is  conditionally executed because it is performed only 
when a certain condition is true. 
 Programmers call the type of decision structure shown in  Figure   3-2 a  single alterna-
tive decision structure . This is because it provides only one alternative path of execu-
tion. If the condition in the diamond symbol is true, we take the alternative path. 
Otherwise, we exit the structure.  Figure  3-3 shows a more elaborate example, where 
three actions are taken only when it is cold outside. It is still a single alternative deci-
sion structure because only one alternative path of execution is given.  
 In C++ you use the  if statement to write a single alternative decision structure. Here 
is the general format of the  if statement: 
 if ( expression ) 
 { 
     statement; 
     statement; 
     etc ; 
 } 
 The statement begins with the word  if , followed by an  expression that is enclosed in 
a set of parentheses. Beginning on the next line is a set of statements that are enclosed 
in curly braces. 
 The  expression that appears inside the parentheses is a Boolean expression. A  Boolean 
expression is an expression that can be evaluated as either true or false. When the  if 
False
True
Wear a coat.
Cold
outside
 Figure 3-2  A simple decision structure  

statement executes, the Boolean expression is tested. If it is true, the statements that 
appear inside the curly braces are executed. If the Boolean expression is false, how-
ever, the statements inside the curly braces are skipped. We say that the statements 
inside the curly braces are conditionally executed because they are executed only if 
the Boolean expression is true. 
 If you are writing an  if statement that has only one conditionally executed statement, 
you do not have to enclose the conditionally executed statement inside curly braces. 
Such an  if statement can be written in the following general format: 
 if ( expression ) 
     statement; 
 When an  if statement written in this format executes, the Boolean expression is 
tested. If it is true, the one statement that appears on the next line will be executed. If 
the Boolean expression is false, however, that one statement is skipped. 
 Although the curly braces are not required when there is only one conditionally 
executed statement, it is still a good idea to use them, as shown in the following 
general format: 
 if ( expression ) 
 { 
     statement; 
 } 
False
True
Wear a coat.
Cold
outside
Wear a hat.
Wear gloves.
 Figure 3-3  A decision structure that performs three actions if it is cold outside  
 
3.2 Writing a Decision Structure with the if Statement 
91

92 
Chapter 3 
 Decision Structures and Boolean Logic
 This is a good style for writing  if statements because it cuts down on errors. 
Remember, if you have more than one conditionally executed statement, those 
statements  must be enclosed in curly braces. If you get into the habit of always 
enclosing the conditionally executed statements in a set of curly braces, it’s less 
likely that you will forget them. 
 Boolean Expressions and Relational Operators 
 The value of a Boolean expression can be either true or false. Boolean expressions are 
named in honor of the English mathematician George Boole. In the 1800s Boole in-
vented a system of mathematics in which the abstract concepts of true and false can 
be used in computations. 
 Typically, the Boolean expression that is tested by an  if statement is formed with a 
relational operator. A  relational operator determines whether a specific relationship 
exists between two values. For example, the greater than operator ( > ) determines 
whether one value is greater than another. The equal to operator ( == ) determines 
whether two values are equal.  Table   3-1 lists the relational operators that are avail-
able in C++.  
 Table 3-1   Relational operators 
 Operator 
 Meaning 
 > 
 Greater than 
 < 
 Less than 
 >= 
 Greater than or equal to 
 <= 
 Less than or equal to 
 == 
 Equal to 
 != 
 Not equal to 
 The following is an example of an expression that uses the greater than ( > ) operator 
to compare two variables,  length and  width : 
 length > width  
 This expression determines whether the value of the  length variable is greater than 
the value of the  width variable. If  length is greater than  width , the value of the 
expression is true. Otherwise, the value of the expression is false. The following 
expression uses the less than operator to determine whether  length is less than  width : 
 length < width  
 Table  3-2 shows examples of several Boolean expressions that compare the variables 
 x and  y . 
 The  >= and  <= Operators 
 Two of the operators,  >= and  <= , test for more than one relationship. The  >= operator 
determines whether the operand on its left is greater than  or equal to the operand on 

its right. The  <= operator determines whether the operand on its left is less than  or 
equal to the operand on its right. 
 For example, assume the variable  a is assigned 4. All the following expressions are true: 
 a >= 4 
 a >= 2 
 8 >= a 
 a <= 4 
 a <= 9 
 4 <= a  
 Table 3-2   Boolean expressions using relational operators 
 Expression 
 Meaning 
 x > y 
 Is  x greater than  y ? 
 x < y 
 Is  x less than  y ? 
 x >= y 
 Is  x greater than or equal to  y ? 
 x <= y 
 Is  x less than or equal to  y ? 
 x == y 
 Is  x equal to  y ? 
 x != y 
 Is  x not equal to  y ? 
 NOTE:    The equality operator is two  = symbols together. Don’t confuse this oper-
ator with the assignment operator, which is one  = symbol. 
 The  != Operator 
 The  != operator is the not-equal-to operator. It determines whether the operand on 
its left is not equal to the operand on its right, which is the opposite of the  == opera-
tor. As before, assuming  a is 4,  b is 6, and  c is 4, both  a != b and  b != c are true 
because  a is not equal to  b, and  b is not equal to  c . However,  a != c is false because 
 a is equal to  c .  
 Putting It All Together 
 Let’s look at the following example of the  if statement: 
 if (sales > 50000) 
 { 
    bonus = 500; 
 } 
 
3.2 Writing a Decision Structure with the if Statement 
93
 The  == Operator 
 The  == operator determines whether the operand on its left is equal to the oper-
and on its right. If the values of both operands are the same, the expression is 
true. Assuming that  a is 4, the expression  a == 4 is true, and the expression  a ==  2 
is false.  

94 
Chapter 3 
 Decision Structures and Boolean Logic
 The following example conditionally executes three statements.  Figure   3-5 shows a 
flowchart for this section of code. 
 if (sales > 50000) 
 { 
    bonus = 500.0; 
    commissionRate = 0.12; 
    cout << "You met your sales quota!" << endl; 
 } 
 Notice that in both of the previous  if statement examples, the conditionally executed 
statements were indented. This indentation is not required, but it makes the code 
easier to read and debug. By indenting the conditionally executed statements, you 
visually set them apart from the surrounding code. This allows you to tell at a glance 
what part of the program is controlled by the  if statement. Most programmers use 
this style of indentation when writing  if statements. 
 The following code uses the  == operator to determine whether two values are equal. 
The expression  balance == 0 will be true if the  balance variable is assigned 0. 
Otherwise, the expression will be false. 
 if (balance == 0) 
 { 
    // Statements appearing here will 
    // be executed only if balance is 
    // equal to 0. 
 } 
bonus = 500
sales > 50000
True
False
 Figure 3-4  Example decision structure  
 This statement uses the  > operator to determine whether  sales is greater than 50,000. 
If the expression  sales > 50000 is true, the  bonus variable is assigned 500. If the 
expression is false, however, the assignment statement is skipped.  Figure   3-4 shows a 
flowchart for this section of code.  

 In the Spotlight: 
 Using the  if Statement 
 Kathryn teaches a science class, and her students are required to take three tests. She 
wants to write a program that her students can use to calculate their average test 
score. She also wants the program to congratulate the student enthusiastically if the 
average is greater than 95. Here is the algorithm in pseudocode: 
 Get the first test score  
 Get the second test score  
bonus = 500.0
sales > 50000
True
False
commissionRate
= 0.12
Display “You met
your sales quota!”
 Figure 3-5  Example decision structure  
 
3.2 Writing a Decision Structure with the if Statement 
95
 The following code uses the  != operator to determine whether two values are  not 
equal. The expression  choice != 5 will be true if the  choice variable is not equal to 5. 
Otherwise the expression will be false. 
 if (choice != 5) 
 { 
    // Statements appearing here will 
    // be executed only if choice is 
    // not equal to 5. 
 } 

96 
Chapter 3 
 Decision Structures and Boolean Logic
 Get the third test score  
 Calculate the average  
 Display the average  
 If the average is greater than 95  
      Congratulate the user  
 Program 3-1 shows the code for the program. 
 Program 3-1 
  (TestAverage.cpp) 
 1 // This program prompts the user to enter three test 
 2 // scores. It displays the average of those scores and 
 3 // and congratulates the user if the average is 95 
 4 // or greater. 
 5 #include <iostream> 
 6 using namespace std; 
 7 
 8 int main() 
 9 { 
 10    // Variables 
 11    double test1,            // To hold test score #1 
 12           test2,            // To hold test score #2 
 13           test3,            // To hold test score #3 
 14           average;          // To hold the average 
 15 
 16    // Constant for a high average. 
 17    const double HIGH_AVERAGE = 95.0; 
 18 
 19    // Get the three test scores. 
 20    cout << "Enter the score for test 1: "; 
 21    cin >> test1; 
 22    cout << "Enter the score for test 2: "; 
 23    cin >> test2; 
 24    cout << "Enter the score for test 3: "; 
 25    cin >> test3; 
 26 
 27    // Calculate the average test score. 
 28    average = (test1 + test2 + test3) / 3.0; 
 29 
 30    // Display the average. 
 31    cout << "The average score is: " 
 32         << average << endl; 
 33 
 34    // If the average is high, congratulate 
 35    // the user. 
 36    if (average >= HIGH_AVERAGE) 
 37    { 
 38       cout << "Congratulations!" << endl; 
 39       cout << "That's a great average!" << endl; 
 40    } 
 41 
 42    return 0; 
 43 } 

 Program Output (with Input Shown in Bold) 
 Enter the score for test 1:  82 [ Enter ] 
 Enter the score for test 2:  76 [ Enter ] 
 Enter the score for test 3:  91 [ Enter ] 
 The average score is 83  
 Program Output (with Input Shown in Bold) 
 Enter the score for test 1:  93 [ Enter ] 
 Enter the score for test 2:  99 [ Enter ] 
 Enter the score for test 3:  96 [ Enter ] 
 The average score is 96 
 Congratulations! 
 That's a great average.  
 Checkpoint 
 3.4.  What is a control structure?  
 3.5.  What is a decision structure?  
 3.6.  What is a single alternative decision structure?  
 3.7.  What is a Boolean expression?  
 3.8.  What types of relationships between values can you test with relational op-
erators?  
 3.9.  Write an  if statement that assigns 0 to the  x variable if the  y variable is equal 
to 20. 
 3.10.  Write an  if statement that assigns 0.2 to the  commission variable if the  sales 
variable is greater than or equal to 10000.  
 
  3.3  The  if - else Statement 
 CONCEPT:   An  if - else statement will execute one block of statements if its 
Boolean expression is true or another block if its Boolean expression 
is false.  
 The previous section introduced the single alternative decision structure (the  if state-
ment), which has one alternative path of execution. Now we will look at the  dual 
alternative decision structure , which has two possible paths of execution—one path 
is taken if a Boolean expression is true, and the other path is taken if the Boolean 
expression is false.  Figure   3-6  shows an example flowchart for a dual alternative 
decision structure.  
 
3.3 The if-else Statement 
97
VideoNote
The if-else 
Statement

98 
Chapter 3 
 Decision Structures and Boolean Logic
 The decision structure in the flowchart tests the expression  temperature < 40 . If this 
expression is true, the message “A little cold, isn’t it?” is displayed. If the expression 
is false, the message “Nice weather we’re having.” is displayed. 
 In code we write a dual alternative decision structure as an  if - else statement. Here 
is the general format of the  if - else statement: 
 if ( expression ) 
 { 
     statement; 
     statement; 
     etc ; 
 } 
 else 
 { 
     statement; 
     statement; 
     etc ; 
 } 
 An  if - else statement has two parts: an  if clause and an  else clause. Just like a regu-
lar  if statement, the  if - else statement tests a Boolean expression. If the expression is 
true, the block of statements following the  if clause is executed, and then control of 
the program jumps to the statement that follows the  if - else statement. If the Boolean 
expression is false, the block of statements following the  else clause is executed, and 
then control of the program jumps to the statement that follows the  if - else state-
ment. This action is described in  Figure  3-7 . 
 The  if - else statement has two sets of conditionally executed statements. One set 
is executed only under the condition that the Boolean expression is true, and the 
other set is executed only under the condition that the Boolean expression is false. 
temperature
< 40
Display “Nice weather
we’re having.” 
Display “A little cold,
isn’t it?” 
True
False
 Figure 3-6  A dual alternative decision structure  

Under no circumstances will both sets of conditionally executed statement be 
 executed. 
 If either set of conditionally executed statements contains only one statement, the 
curly braces are not required. For example, the following general format shows only 
one statement following the  if clause and only one statement following the  else 
clause: 
 if ( expression ) 
     statement; 
 else 
     statement; 
 Although the curly braces are not required when there is only one conditionally exe-
cuted statement, it is still a good idea to use them, as shown in the following general 
format: 
 if ( expression ) 
 { 
     statement; 
 } 
 else 
 { 
     statement; 
 } 
 When we were discussing the regular  if statement we mentioned that this is a good 
style of programming because it cuts down on errors. If more than one conditionally 
executed statement follows either the  if clause or the  else clause, those statements 
 must be enclosed in curly braces. If you get into the habit of always enclosing the 
conditionally executed statements in a set of curly braces, it’s less likely that you will 
forget them. 
 
3.3 The if-else Statement 
99
if (expression)
{
         statement;
         statement;
         etc;
}
else
{
        statement;
        statement;
        etc;
}
If the expression is true, 
this block of statements is 
executed.
Then, control jumps here, 
to the statement following 
the if-else statement.
If the expression is false, 
this block of statements is 
executed.
Then, control jumps here, 
to the statement following 
the if-else statement.
if (expression)
{
         statement;
         statement;
         etc;
}
else
{
        statement;
        statement;
        etc;
}
 Figure 3-7  Conditional execution in an  if - else statement  

100 
Chapter 3 
 Decision Structures and Boolean Logic
 In the Spotlight: 
 Using the  if - else Statement 
 Chris owns an auto repair business and has several employees. If any employee works 
over 40 hours in a week, he pays them 1.5 times their regular hourly pay rate for all hours 
over 40. He has asked you to design a simple payroll program that calculates an employee’s 
gross pay, including any overtime wages. You design the following algorithm: 
 Get the number of hours worked.  
 Get the hourly pay rate.  
 If the employee worked more than 40 hours,  
      Calculate and display the gross pay with overtime.  
 Else  
     Calculate and display the gross pay as usual.  
 The code for the program is shown in Program 3-2. Notice that two named constants 
are created in lines 16 and 17.  BASE_HOURS is assigned 40.0, which is the number of 
hours an employee can work in a week without getting paid overtime.  OT_MULTIPLIER 
is assigned 1.5, which is the pay rate multiplier for overtime hours. This means that 
the employee’s hourly pay rate is multiplied by 1.5 for all overtime hours. 
 Program 3-2  
 (AutoRepairPayroll.cpp) 
 1 // This program calculates payroll, including overtime 
 2 // if the hours worked are more than 40. 
 3 #include <iostream> 
 4 using namespace std; 
 5 
 6 int main() 
 7 { 
 8    // Variables 
 9    double hoursWorked,     // Number of hours worked 
 10           payRate,         // Hourly pay rate 
 11           overtimeHours,    // Number of overtime hours 
 12           overtimePay,      // Amount of overtime pay 
 13           grossPay;        // Amount of gross pay 
 14 
 15    // Constants 
 16    const double BASE_HOURS = 40.0;    // Base hours per week 
 17    const double OT_MULTIPLIER = 1.5;  // Overtime multiplier 
 18 
 19    // Get the number of hours worked. 
 20    cout << "Enter the number of hours worked: "; 
 21    cin >> hoursWorked; 
 22 
 23    // Get the hourly pay rate. 
 24    cout << "Enter the hourly pay rate: "; 
 25    cin >> payRate; 
 26 
 27 
 28    // Calculate the gross pay. 
 29    if (hoursWorked > BASE_HOURS) 
 30    { 

 31       // Calculate the number of overtime hours worked. 
 32       overtimeHours = hoursWorked - BASE_HOURS; 
 33 
 34       // Calculate the amount of overtime pay. 
 35       overtimePay = overtimeHours * payRate * OT_MULTIPLIER; 
 36 
 37       // Calculate the gross pay. 
 38       grossPay = BASE_HOURS * payRate + overtimePay; 
 39    } 
 40    else 
 41    { 
 42       // Calculate the gross pay (no overtime). 
 43       grossPay = hoursWorked * payRate; 
 44    } 
 45 
 46    // Display the gross pay. 
 47    cout << "The gross pay is $" << grossPay << endl; 
 48    return 0; 
 49 } 
 Program Output with Example Input Shown in Bold 
 Enter the number of hours worked:  40 [ Enter ] 
 Enter the hourly pay rate:  20 [ Enter ] 
 The gross pay is $800  
 Program Output with Example Input Shown in Bold 
 Enter the number of hours worked:  50 [ Enter ] 
 Enter the hourly pay rate:  20 [ Enter ] 
 The gross pay is $1100  
 Checkpoint 
 3.11.  Describe how a dual alternative decision structure works.  
 3.12.   In an  if - else statement, under what circumstances are the statements that ap-
pear after the  else clause executed?  
 3.13.   Write an  if - else statement that determines whether  y is less than 0. If this is 
true, set  x to 0. Otherwise, set  x to 320.  
 
 3.4  Nested Decision Structures 
and the  if - else - if Statement 
 CONCEPT:    To test more than one condition, a decision structure can be nested 
inside another decision structure.  
 In  Section   3.1 , we mentioned that a control structure determines the order in which a 
set of statements executes. Programs are usually designed as combinations of different 
 
3.4 Nested Decision Structures and the if-else-if Statement 
101

102 
Chapter 3 
 Decision Structures and Boolean Logic
control structures. For example,  Figure   3-8 shows a flowchart that combines a deci-
sion structure with two sequence structures.  
 The flowchart in the figure starts with a sequence structure. Assuming you have an 
outdoor thermometer in your window, the first step is  Go to the window , and the 
next step is  Read thermometer . A decision structure appears next, testing the condi-
tion  Cold outside . If this is true, the action  Wear a coat is performed. Another 
Wear a coat.
Cold
outside
True
False
Open the door.
Go outside.
Read thermometer.
Go to the window.
Start
End
Sequence structure
Sequence structure
Decision structure
 Figure 3-8  Combining sequence structures with a decision structure  

sequence structure appears next. The step  Open the door is performed, followed by 
 Go outside . 
 Quite often, structures must be nested inside other structures. For example, look at 
the partial flowchart in  Figure   3-9 . It shows a decision structure with a sequence 
structure nested inside it. The decision structure tests the condition  Cold outside . If 
that condition is true, the steps in the sequence structure are executed.  
 You can also nest decision structures inside other decision structures. This is com-
monly done in programs that need to test more than one condition. For example, 
consider a program that determines whether a bank customer qualifies for a loan. To 
qualify, two conditions must exist: (1) the customer must earn at least $30,000 per 
year, and (2) the customer must have been employed at his or her current job for at 
least two years.  Figure   3-10 shows a flowchart for a program that could be used in 
such a program. Assume that the  salary variable is assigned the customer’s annual 
salary, and the  yearsOnJob variable is assigned the number of years that the customer 
has worked on his or her current job.  
 If we follow the flow of execution, we see that the condition  salary >= 30000 is 
tested. If this condition is false, there is no need to perform further tests; we know that 
the customer does not qualify for the loan. If the condition is true, however, we need 
to test the second condition. This is done with a nested decision structure that tests 
the condition  yearsOnJob >= 2 . If this condition is true, then the customer qualifies 
for the loan. If this condition is false, then the customer does not qualify. Program 3-3 
shows the code for the complete program. 
 
3.4 Nested Decision Structures and the if-else-if Statement 
103
Wear a coat.
Cold
outside
True
False
Wear a hat.
Wear gloves.
Sequence
structure
Decision
structure
 Figure 3-9  A sequence structure nested inside a decision structure  

104 
Chapter 3 
 Decision Structures and Boolean Logic
 Program 3-3 
  (LoanQualifier.cpp) 
 1 // This program determines whether a bank customer 
 2 // qualifies for a loan. 
 3 #include <iostream> 
 4 using namespace std; 
 5 
 6 int main() 
 7 { 
 8    // Variables 
 9    double salary;   // Applicant's salary 
 10    int yearsOnJob;  // Years on the job 
 11 
 12    // Constants 
 13    const double MIN_SALARY = 30000.0;  // Minimum salary 
 14    const int MIN_YEARS = 2;            // Minimum years 
 15 
 16    // Get the applicant's salary. 
salary >= 30000
Display “You must earn
at least $30,000 per year
to qualify.”
True
False
yearsOnJob >= 2
Display “You must have
been on your current job
for at least two years to
qualify.” 
Display “You qualify for
the loan.” 
True
False
 Figure 3-10  A nested decision structure  

 17    cout << "Enter your annual salary: "; 
 18    cin >> salary; 
 19 
 20    // Get the applicant's years on the current job. 
 21    cout << "Enter the number of years on your current job: "; 
 22    cin >> yearsOnJob; 
 23 
 24 
 25    // Determine whether the customer qualifies. 
 26    if (salary >= MIN_SALARY) 
 27    { 
 28       if (yearsOnJob >= MIN_YEARS) 
 29       { 
 30          cout << "You qualify for the loan." << endl; 
 31       } 
 32       else 
 33       { 
 34          cout << "You must have been on your current" << endl; 
 35          cout << "job for at least " << MIN_YEARS 
 36               << " years to qualify." << endl; 
 37       } 
 38    } 
 39    else 
 40    { 
 41       cout << "You must earn at least $" << MIN_SALARY 
 42            << " to qualify." << endl; 
 43    } 
 44    return 0; 
 45 } 
 Program Output with Example Input Shown in Bold 
 Enter your annual salary:  35000 [ Enter ] 
 Enter the number of years on your current job:  1 [ Enter ] 
 You must have been on your current 
 job for at least 2 years to qualify.  
 Program Output (with Input Shown in Bold) 
 Enter your annual salary:  25000 [ Enter ] 
 Enter the number of years on your current job:  5 [ Enter ] 
 You must earn at least $30000 to qualify.  
 Program Output (with Input Shown in Bold) 
 Enter your annual salary:  35000 [ Enter ] 
 Enter the number of years on your current job:  5 [ Enter ] 
 You qualify for the loan.  
 Look at the  if - else statement that begins in line 26. It tests the condition 
 salary >= MIN_SALARY . If this condition is true, the  if - else statement that begins in 
line 28 is executed. Otherwise the program jumps to the  else clause in line 39 and 
executes the  cout statement in lines 41 and 42. The program then leaves the decision 
structure. 
 
3.4 Nested Decision Structures and the if-else-if Statement 
105

106 
Chapter 3 
 Decision Structures and Boolean Logic
 For debugging purposes, it is important to use proper alignment and indentation 
in a nested decision structure. This makes it easier to see which actions are per-
formed by each part of the structure. For example, the following code is function-
ally equivalent to lines 26 through 43 in Program 3-3. Although this code is 
logically correct, it would be very difficult to debug because it is not properly 
indented. 
 if (salary >= MIN_SALARY) 
 { 
 if (yearsOnJob >= MIN_YEARS) 
 { 
 cout << "You qualify for the loan." << endl; 
 } 
 else 
 { 
 cout << "You must have been on your current" << endl; 
 cout << "job for at least " << MIN_YEARS 
     << " years to qualify." << endl; 
 } 
 } 
 else 
 { 
 cout << "You must earn at least $" << MIN_SALARY 
     << " to qualify." << endl; 
 } 
 Proper indentation and alignment also makes it easier to see which  if and  else clauses 
belong together, as shown in  Figure   3-11  . 
if (salary >= MIN_SALARY)
{
   if (yearsOnJob >= MIN_YEARS)
   {
      cout << "You qualify for the loan." << endl;
   }
   else
   {
      cout << "You must have been on your current" << endl;
      cout << "job for at least " << MIN_YEARS 
           << " years to qualify." << endl;
   }
}
else
{
   cout << "You must earn at least $" << MIN_SALARY
        << " to qualify." << endl;
}
This if
and else
go together.
This if
and else
go together.
 Figure 3-11  Alignment of  if and  else clauses  

 In the Spotlight: 
 Multiple Nested Decision 
Structures 
 Dr. Suarez teaches a literature class and uses the following 10-point grading scale for 
all of his exams:  
 Testing a Series of Conditions 
 In the previous example you saw how a program can use nested decision structures 
to test more than one condition. It is not uncommon for a program to have a series 
of conditions to test and then perform an action depending on which condition is true. 
One way to accomplish this it to have a decision structure with numerous other deci-
sion structures nested inside it. For example, consider the program presented in the 
following  In the Spotlight section. 
 Test Score 
 Grade 
 90 and above 
 A 
 80–89 
 B 
 70–79 
 C 
 60–69 
 D 
 Below 60 
 F 
 He has asked you to write a program that will allow a student to enter a test score and 
then display the grade for that score. Here is the algorithm that you will use: 
 Ask the user to enter a test score  
 If the score is greater than or equal to 90, then the grade is A  
     Else, if the score is greater than or equal to 80, then the grade is B  
         Else, if the score is greater than or equal to 70, then the grade is C  
             Else, if the score is greater than or equal to 60, then the grade is D  
               Else, the grade is F  
 You decide that the process of determining the grade will require several nested 
decisions structures, as shown in  Figure   3-12  . Program 3-4 shows the code for the 
program. The code for the nested decision structures is in lines 15 through 43.  
 
3.4 Nested Decision Structures and the if-else-if Statement 
107

 Program 3-4  
 (Grader.cpp) 
 1 // This program gets a numeric test score from the 
 2 // user and displays the corresponding letter grade. 
 3 #include <iostream> 
 4 using namespace std; 
 5 
 6 int main() 
 7 { 
 8    int testScore; 
 9 
 10    // Get the test score. 
 11    cout << "Enter your test score: "; 
 12    cin >> testScore; 
 13 
 14    // Determine the letter grade. 
 15    if (testScore >= 90) 
 16    { 
 17       cout << "Your grade is A." << endl; 
 18    } 
 19    else 
108 
Chapter 3  Decision Structures and Boolean Logic
True
False
score
>= 90
True
False
score
>= 80
True
False
score
>= 70
True
False
score
>= 60
Display “Your
grade is D.”
Display “Your
grade is F.”
Display “Your
grade is C.”
Display “Your
grade is B.”
Display “Your
grade is A.”
 Figure 3-12  Nested decision structure to determine a grade  

 20    { 
 21       if (testScore >= 80) 
 22       { 
 23          cout << "Your grade is B." << endl; 
 24       } 
 25       else 
 26       { 
 27          if (testScore >= 70) 
 28          { 
 29             cout << "Your grade is C." << endl; 
 30          } 
 31          else 
 32          { 
 33             if (testScore >= 60) 
 34             { 
 35                cout << "Your grade is D." << endl; 
 36             } 
 37             else 
 38             { 
 39                cout << "Your grade is F." << endl; 
 40             } 
 41          } 
 42       } 
 43    } 
 44    return 0; 
 45 } 
 Program Output (with Input Shown in Bold) 
 Enter your test score:  78 [ Enter ] 
 Your grade is C.  
 Program Output (with Input Shown in Bold) 
 Enter your test score:  84 [ Enter ] 
 Your grade is B.  
 The  if - else - if Statement 
 Even though Program 6-3 is a simple example, the logic of nested decision structures 
can become complex. C++ provides a special version of the decision structure known 
as the  if - else - if statement, which makes this type of logic simpler to write. Here is 
the general format of the  if - else - if statement: 
 if ( BooleanExpression_1 ) 
 { 
     statement; 
     statement; 
     etc. 
 } 
 
3.4 Nested Decision Structures and the if-else-if Statement 
109
VideoNote
The if-else-if 
Statement

110 
Chapter 3 
 Decision Structures and Boolean Logic
 else if ( BooleanExpression_2 ) 
 { 
     statement; 
     statement; 
     etc. 
 } 
 Insert as many  else  if clauses as necessary.  
 else 
 { 
     statement; 
     statement; 
     etc. 
 } 
 When the statement executes,   BooleanExpression_1 is tested. If   BooleanExpression_1 
is true, the block of statements that immediately follow is executed, and the rest of the 
structure is ignored. If   BooleanExpression_1 is false, however, the program jumps to 
the very next  else - if clause and tests   BooleanExpression_2 . If it is true, the block of 
statements that immediately follows is executed, and the rest the structure is then 
ignored. This process continues until a condition is found to be true, or no more 
 else-if clauses are left. If none of the conditions are true, the block of statements 
following the  else clause is executed. 
 The code shown in Program 3-5 is a revision of the test score grading program shown 
in Program 3-4. This version of the program uses an  if - else - if statement instead of 
nested  if - else statements. The output is the same as that of Program 3-4. 
 Program 3-5 
  (Grader2.cpp) 
 1 // This program gets a numeric test score from the 
 2 // user and displays the corresponding letter grade. 
 3 #include <iostream> 
 4 using namespace std; 
 5 
 6 int main() 
 7 { 
 8    int testScore; 
 9 
 10    // Get the test score. 
 11    cout << "Enter your test score: "; 
 12    cin >> testScore; 
 13 
 14    // Determine the letter grade. 
 15    if (testScore >= 90) 
 16       cout << "Your grade is A." << endl; 
 17    else if (testScore >= 80) 
 18       cout << "Your grade is B." << endl; 
 19    else if (testScore >= 70) 
 20       cout << "Your grade is C." << endl; 
 21    else if (testScore >= 60) 
 22       cout << "Your grade is D." << endl; 

 23    else 
 24       cout << "Your grade is F." << endl; 
 25    return 0; 
 26 } 
 Program Output (with Input Shown in Bold) 
 Enter your test score:  78 [ Enter ] 
 Your grade is C.  
 Program Output (with Input Shown in Bold) 
 Enter your test score:  84 [ Enter ] 
 Your grade is B.  
 Notice the alignment and indentation that used with the  if - else - if statement: The 
 if ,  else - if , and  else clauses are all aligned, and the conditionally executed state-
ments are indented. 
 You never have to use the  if - else - if statement because its logic can be coded with 
nested  if - else statements. However, a long series of nested  if - else statements has 
two particular disadvantages when you are debugging code: 
 ●  The code can grow complex and become difficult to understand.  
 ●  Because indenting is important in nested statements, a long series of nested  if -
 else statements can become too long to be displayed on the computer screen 
without horizontal scrolling. Also, long statements tend to “wrap around” when 
printed on paper, making the code even more difficult to read.  
 The logic of an  if - else - if statement is usually easier to follow than a long series of 
nested  if - else statements. And, because all the clauses are aligned in an  if - else - if 
statement, the lengths of the lines in the statement tend to be shorter. 
 Checkpoint 
 3.14.  How does a dual alternative decision structure work?  
 3.15.  What statement do you use in C++ to write a dual alternative decision structure?  
 3.16.  When you write an  if - else statement, under what circumstances does the 
block that appears after the  else clause execute?  
 3.17.  Convert the following code to an  if - else - if statement: 
 if (number == 1) 
 { 
    cout << "One" << endl; 
 } 
 else 
 { 
    if (number == 2) 
    { 
      cout << "Two" << endl; 
    } 
 
3.4 Nested Decision Structures and the if-else-if Statement 
111

112 
Chapter 3 
 Decision Structures and Boolean Logic
   else 
   { 
       if (number == 3) 
       { 
         cout << "Three" << endl; 
       } 
       else 
       { 
         cout << "Unknown" << endl; 
       } 
   } 
 } 
 
 3.5  Logical Operators 
 CONCEPT:   The logical AND operator and the logical OR operator allow you to 
connect multiple Boolean expressions to create a compound expression. 
The logical NOT operator reverses the truth of a Boolean expression.  
 The C++ language provides a set of operators known as  logical operators , which you 
can use to create complex Boolean expressions.  Table   3-3 describes these operators.  
 Table 3-3   Logical operators 
 Operator 
 Meaning 
 && 
 This is the logical AND operator. It connects two Boolean expressions into one com-
pound expression. Both subexpressions must be true for the compound expression 
to be true. 
 || 
 This is the logical OR operator. It connects two Boolean expressions into one com-
pound expression. One or both subexpressions must be true for the compound 
expression to be true. It is only necessary for one of the subexpressions to be true, 
and it does not matter which. 
 ! 
 This is the logical NOT operator, which is a unary operator, meaning it works with only 
one operand. The operand must be a Boolean expression. The NOT operator reverses 
the truth of its operand. If it is applied to an expression that is true, the operator returns 
false. If it is applied to an expression that is false, the operator returns true. 
 Table 3-4   Compound Boolean expressions using logical operators 
 Expression 
 Meaning 
 x > y && a < b 
 Is  x greater than  y AND is  a less than  b ? 
 x == y || x == z 
 Is  x equal to  y OR is  x equal to  z ? 
 ! (x > y) 
 Is the expression  x > y NOT true? 
 Table   3-4 shows examples of several compound Boolean expressions that use logical 
operators.  

 
3.5 Logical Operators 
113
 The  && Operator 
 The  && operator takes two Boolean expressions as operands and creates a compound 
Boolean expression that is true only when both subexpressions are true. The following 
is an example of an  if statement that uses the  && operator: 
 if (temperature < 20 && minutes > 12) 
    cout << "The temperature is in the danger zone." << endl;  
 In this statement, the two Boolean expressions  temperature < 20 and  minutes > 12 are 
combined into a compound expression. The  cout statement will be executed only if 
 temperature is less than 20 and  minutes is greater than 12. If either of the Boolean sub-
expressions is false, the compound expression is false, and the message is not displayed. 
 Table   3-5 shows a truth table for the  && operator. The truth table lists expressions 
showing all the possible combinations of true and false connected with the  && opera-
tor. The resulting values of the expressions are also shown.  
 Table 3-5   Truth table for the and operator 
 Expression 
 Value of the Expression 
 true && false 
 false 
 false && true 
 false 
 false && false 
 false 
 true && true 
 true 
 As the table shows, both sides of the  && operator must be true for the operator to 
return a true value.  
 The  || Operator 
 The  || operator takes two Boolean expressions as operands and creates a compound 
Boolean expression that is true when either of the subexpressions is true. The follow-
ing is an example of an  if statement that uses the  || operator: 
 if (temperature < 20 || temperature > 100) 
   cout << "The temperature is in the danger zone." << endl;  
 The  cout statement will execute only if  temperature is less than 20 or  temperature is 
greater than 100. If either subexpression is true, the compound expression is true. 
 Table   3-6 shows a truth table for the || operator.  
 Table 3-6   Truth table for the || operator 
 Expression 
 Value of the Expression 
 true || false 
 true 
 false || true 
 true 
 false || false 
 false 
 true || true 
 true 

114 
Chapter 3 
 Decision Structures and Boolean Logic
 All it takes for an  || expression to be true is for one side of the  || operator to be true. 
It doesn’t matter if the other side is false or true.  
 Short-Circuit Evaluation 
 Both the  && and  || operators perform  short-circuit evaluation . Here’s how it works 
with the  && operator: If the expression on the left side of the  && operator is false, 
the expression on the right side will not be checked. Because the compound ex-
pression will be false if only one of the subexpressions is false, it would waste CPU 
time to check the remaining expression. So, when the  && operator finds that the 
expression on its left is false, it short-circuits and does not evaluate the expression 
on its right. 
 Here’s how short-circuit evaluation works with the  || operator: If the expression on 
the left side of the  || operator is true, the expression on the right side will not be 
checked. Because it is only necessary for one of the expressions to be true, it would 
waste CPU time to check the remaining expression.  
 The  ! Operator 
 The  ! operator is a unary operator that takes a Boolean expression as its operand and 
reverses its logical value. In other words, if the expression is true, the  ! operator re-
turns false, and if the expression is false, the  ! operator returns true. The following is 
an  if statement using the  ! operator: 
 if (!(temperature > 100)) 
    cout << "This is below the maximum temperature." << endl;  
 First, the expression  (temperature > 100) is tested, and a value of either true or false 
is the result. Then the  ! operator is applied to that value. If the expression 
 (temperature 
> 
100) is true, the  ! operator returns false. If the expression 
 (temperature > 100) is false, the  ! operator returns true. The previous code is equivalent 
to asking: “Is the temperature not greater than 100?”  
 NOTE:    In this example, we have placed parentheses around the expression 
 temperature > 100 . This is to make it clear that we are applying the  ! operator 
to the value of the expression  temperature > 100 , not just to the  temperature 
variable. 
 Table   3-7 shows a truth table for the  ! operator.  
 Table 3-7   Truth table for the  ! operator 
 Expression 
 Value of the Expression 
 ! true 
 false 
 ! false 
 true 

 
3.5 Logical Operators 
115
 Precedence of the Logical Operators 
 We mentioned earlier that the  ! operator has higher precedence than the relational 
operators. The  && and  || logical operators have lower precedence than the relational 
operators. For example, look at the following expression: 
 creditScore > 700 || accountBalance > 9000  
 When this expression is evaluated, the  > operators work first, and then the  || operator 
works. The expression is the same as the following: 
 (creditScore > 700) || (accountBalance > 9000)  
 Many programmers choose to enclose the expressions that are to the left and the right 
of a logical operator in parentheses, as shown here. Even though the parentheses are 
not required in many situations, using them makes the compound expression easier 
to understand.  
 Checking Numeric Ranges with Logical Operators 
 Sometimes you will need to write code that determines whether a numeric value is 
within a specific range of values or outside a specific range of values. When determin-
ing whether a number is inside a range, it is best to use the  && operator. For example, 
the following  if statement checks the value in  x to determine whether it is in the range 
of 20 to 40: 
 if (x > 20 && x < 40) 
 { 
    cout << "The value is in the acceptable range." << endl; 
 } 
 The compound Boolean expression being tested by this statement will be true only 
when  x is greater than 20  AND less than 40. The value in  x must be between the 
values of 20 and 40 for this compound expression to be true. 
 When determining whether a number is outside a range, it is best to use the  || operator. 
The following statement determines whether  x is outside the range of 20 through 40: 
 if (x < 20 || x > 40) 
 { 
    cout << "The value is outside the acceptable range." << endl; 
 } 
 It is important not to get the logic of the logical operators confused when testing for 
a range of numbers. For example, the compound Boolean expression in the following 
code would never test true: 
 // This is an error! 
 if (x < 20 && x > 40) 
 { 
    cout << "The value is outside the acceptable range." << endl; 
 } 
 Obviously,  x cannot be less than 20 and at the same time be greater than 40. 

116 
Chapter 3 
 Decision Structures and Boolean Logic
 Checkpoint 
 3.18.   What is a compound Boolean expression?  
 3.19.   The following truth table shows various combinations of the values true and 
false connected by a logical operator. Complete the table by circling  T or  F to 
indicate whether the result of such a combination is true or false.  
 Logical Expression  
 Result (circle  true  or false ) 
 true  && false 
 T 
 F 
 true  && true 
 T 
 F 
 false  && true 
 T 
 F 
 false  && false 
 T 
 F 
 true  || false 
 T 
 F 
 true  || true 
 T 
 F 
 false  || true 
 T 
 F 
 false  || false 
 T 
 F 
 ! true 
 T 
 F 
 ! false 
 T 
 F 
 3.20.   Assume the variables  a = 2,  b = 4, and  c = 6. Circle  T or  F for each of the fol-
lowing conditions to indicate if it is true or false. 
 a == 4 || b > 2 
 T 
 F 
 6 <= c && a > 3 
 T 
 F 
 1 != b && c != 3 
 T 
 F 
 a >= -1 || a <= b 
 T 
 F 
 !(a > 2) 
 T 
 F 
 3.21.   Explain how short-circuit evaluation works with the  && and  || operators.  
 3.22.   Write an  if statement that displays the message “The number is valid” if the 
variable  speed is within the range 0 through 200.  
 3.23.   Write an  if statement that displays the message “The number is not valid” if 
the variable  speed is outside the range 0 through 200.  
 
 3.6  The  switch Statement 
 CONCEPT:    The  switch statement lets the value of a variable or an expression 
determine which path of execution the program will take.  
 The  switch statement is a  multiple alternative decision structure . It allows you to test 
the value of an integer variable or an expression and then use that value to determine 
which statement or set of statements to execute.  Figure   3-13  shows an example of 
how a  switch statement looks in a flowchart.  
 In the flowchart, the diamond symbol contains the name of an integer variable named 
month. If the variable contains the value 1, then “January” is displayed. If the variable 
contains the value 2, then “February” is displayed. If the variable contains the value 3, 
then “March” is displayed. If the variable contains none of these values, the box labeled 
 Default is executed. In this case, the message “Error: Invalid month” is displayed. 

 
3.6 The switch Statement 
117
 Here is the general format of the  switch statement in C++ code:  
switch (testExpression)
{
   case value_1:
      statement;
      statement;
      etc.
      break;
   case value_2:
      statement;
      statement;
      etc.
      break;
     Insert as many case sections as necessary.
   case value_N:
      statement;
      statement;
      etc.
      break;
   default:
      statement;
      statement;
      etc.
      break;
}
The testExpression is
a variable or expression of
an integer data type.
These statements are executed
if the testExpression is
equal to value_1.
These statements are executed
if the testExpression is
equal to value_2.
These statements are executed
if the testExpression is
equal to value_N. 
These statements are executed
if the testExpression is
not equal to any of the case
 
values.
 
 The first line of the structure starts with the word   switch , followed by a   testExpression , 
which is enclosed in parentheses. The  testExpression is usually an integer variable, 
but it can also be any expression that gives an integer value. Beginning at the next line 
month
Display “January” 
Display “February”
Display “March”
Display “Error:
Invalid month” 
1
2
3
Default
 Figure 3-13  A  switch statement  

118 
Chapter 3 
 Decision Structures and Boolean Logic
is a block of code enclosed in curly braces. Inside this block of code is one or more 
 case sections . A case section begins with the word   case , followed by a value, followed 
by a colon. Each case section contains one or more statements, followed by a  break 
statement. At the end is an optional  default section . 
 When the  switch statement executes, it compares the value of the  testExpression with 
the values that follow each of the   case statements (from top to bottom). When it finds 
a case value that matches the  testExpression ’s value, the program branches to the  case 
statement. The statements that follow the  case statement are executed until a break 
statement is encountered. At that point the program jumps out of the  switch statement. 
If the  testExpression does not match any of the case values, the program branches to 
the  default statement and executes the statements that immediately follow it. 
 For example, the following code performs the same operation as the flowchart in 
 Figure   3-13 : 
 switch (month) 
 { 
   case 1: 
      cout << "January" << endl; 
      break; 
   case 2: 
      cout << "February" << endl; 
      break; 
   case 3: 
      cout << "March" << endl; 
      break; 
   default: 
      cout << "Error: Invalid month" << endl; 
 } 
 In this example the  testExpression is the  month variable. If the value in the  month 
variable is 1, the program will branch to the  case 1: section and execute the  cout 
statement that immediately follows it (displaying “January”). If the value in the  month 
variable is 2, the program will branch to the  case 2: section and execute the  cout 
statement that immediately follows it (displaying “February”). If the value in the 
 month variable is 3, the program will branch to the  case 3: section and execute the 
 cout statement that immediately follows it (displaying “March”). If the value in the 
 month variable is not 1, 2, or 3, the program will branch to the  default: section and 
execute the  cout statement that immediately follows it (displaying the error message). 
 Here are some important points to remember about the  switch statement: 
 ●  The  testExpression must be a variable that is of an integer data type, or an 
expression that gives an integer value.  
 ●  The value that follows a  case statement must be an integer literal or an integer 
constant. It cannot be a variable.  
 ●  The  break statement that appears at the end of a case section is optional, but in 
most situations you will need it. If the program executes a case section that does 
not end with a  break statement, it will continue executing the code in the very 
next case section.  

 ●  The default section is optional, but in most situations you should have one. The default 
section is executed when the  testExpression does not match any of the case values.  
 ●  Because the default section appears at the end of the  switch statement, it does not 
need a  break statement.  
 In the Spotlight: 
 Using a  switch Statement 
 Lenny, who owns Lenny’s Stereo and Television, has asked you to write a program 
that lets the customer pick one of three TV models and then displays the price and 
size of the selected model. 
 Here is the algorithm: 
 Get the TV model number 
 If the model is 100, then display the information for that model. 
   Otherwise, if the model is 200, then display the information for that model. 
      Otherwise, if the model is 300, then display the information for that model.  
 At first you consider designing a nested decision structure to determine the model 
number and display the correct information. But you realize that a  switch statement 
will work just as well because a single value, the model number, will be used to 
determine the action the program will perform. The model number can be stored 
in a variable, and that variable can be tested by a  switch statement. Assuming that 
the model number is stored in a variable named  modelNumber ,  Figure   3-14 shows 
 
3.6 The switch Statement 
119
modelNumber
Display “Invalid
model number” 
100
200
300
Default
Display “Price: $”,
MODEL_300_PRICE
Display “Price: $”,
MODEL_200_PRICE
Display “Price: $”,
MODEL_100_PRICE
Display “Size: ”,
MODEL_100_SIZE
Display “Size: ”,
MODEL_200_SIZE
Display “Size: ”,
MODEL_300_SIZE
 Figure 3-14  Flowchart for the  switch statement  

a flowchart for the  switch statement. Program 3-6 shows the C++ code for the 
program.  
 Program 3-6 
  (SwitchExample.cpp) 
 1 // This program demonstrates the switch statement. 
 2 #include <iostream> 
 3 using namespace std; 
 4 
 5 int main() 
 6 { 
 7    // Constants for the TV prices 
 8    const double MODEL_100_PRICE = 199.99; 
 9    const double MODEL_200_PRICE = 269.99; 
 10    const double MODEL_300_PRICE = 349.99; 
 11 
 12    // Constants for the TV sizes 
 13    const int MODEL_100_SIZE = 24; 
 14    const int MODEL_200_SIZE = 27; 
 15    const int MODEL_300_SIZE = 32; 
 16 
 17    // Variable for the model number 
 18    int modelNumber; 
 19 
 20    // Get the test score. 
 21    cout << "Which TV are you interested in?" << endl; 
 22    cout << "The model 100, 200 or 300? "; 
 23    cin >> modelNumber; 
 24 
 25    // Display the price and size. 
 26    switch (modelNumber) 
 27    { 
 28    case 100: 
 29       cout << "Price: " << MODEL_100_PRICE << endl; 
 30       cout << "Size: " << MODEL_100_SIZE << endl; 
 31       break; 
 32    case 200: 
 33       cout << "Price: " << MODEL_200_PRICE << endl; 
 34       cout << "Size: " << MODEL_200_SIZE << endl; 
 35       break; 
 36    case 300: 
 37       cout << "Price: " << MODEL_300_PRICE << endl; 
 38       cout << "Size: " << MODEL_300_SIZE << endl; 
 39       break; 
 40    default: 
 41       cout << "Invalid model number." << endl; 
 42    } 
 43    return 0; 
 44 } 
 Program Output with Input Shown in Bold 
 Which TV are you interested in? 
 The 100, 200, or 300?  100 [ Enter ] 
120 
Chapter 3  Decision Structures and Boolean Logic

 Price: $199.99 
 Size: 24  
 Program Output with Input Shown in Bold 
 Which TV are you interested in? 
 The 100, 200, or 300?  200 [ Enter ] 
 Price: $269.99 
 Size: 27  
 Program Output with Input Shown in Bold 
 Which TV are you interested in? 
 The 100, 200, or 300?  300 [ Enter ] 
 Price: $349.99 
 Size: 32  
 Program Output with Input Shown in Bold 
 Which TV are you interested in? 
 The 100, 200, or 300?  500 [ Enter ] 
 Invalid model number  
 Checkpoint 
 3.24.  Convert the following  if - else - if code to a  switch statement. 
 if (choice == 1) 
 { 
    cout << "You chose 1." << endl; 
 } 
 else if (choice == 2) 
 { 
    cout << "You chose 2." << endl; 
 } 
 else if (choice == 3) 
 { 
    cout << "You chose 3." << endl; 
 } 
 else 
 { 
    cout << "Make another choice." << endl; 
 } 
 
  3.7  bool Variables 
 CONCEPT:   A  bool variable can hold one of two values:  true or  false . Variables 
of the  bool data type are commonly used as flags, which indicate 
whether specific conditions exist.  
 
3.7 bool Variables 
121

122 
Chapter 3 
 Decision Structures and Boolean Logic
 The C++ language provides a special data type named  bool that you can use to create 
variables that hold true or false values. Here is an example of the declaration of a  bool 
variable: 
 bool grandMaster;  
 This declares a  bool variable named  grandMaster . In the program we can assign the 
special values  true or  false to the variable, as shown here: 
 if (points > 5000) 
 { 
    grandMaster = true; 
 } 
 else 
 { 
    grandMaster = false; 
 } 
 Variables of the  bool data type are commonly used as flags. A  flag is a variable that 
signals when some condition exists in the program. When the flag variable is set to 
 false , it indicates that the condition does not yet exist. When the flag variable is set to 
 true , it means the condition does exist. For example, the previous code might be used 
in a game to determine whether the user is a “grand master.” If he or she has earned 
more than 5,000 points, we set the  grandMaster variable to true. Otherwise, we set the 
variable to  false . Later in the program we can test the  grandMaster variable, like this: 
 if (grandMaster) 
 { 
    powerLevel += 500; 
 } 
 This code performs the following: If  grandMaster is  true , add 500 to  powerLevel . 
Here is another example : 
 if (!grandMaster) 
 { 
    powerLevel = 100; 
 } 
 This code performs the following: If  grandMaster is not  true , set  powerLevel to 100. 
 Checkpoint 
 3.25.   What values can you store in a  bool variable? 
 3.26.   What is a flag variable?  
 
 3.8  Comparing Strings 
 CONCEPT:    C++ allows you to compare strings. This allows you to create decision 
structures that test the value of a string.  

 
3.8 Comparing Strings 
123
 You saw in the preceding examples how numbers can be compared in a decision 
structure. You can also compare strings. For example, look at the following code: 
 string name1 = "Mary"; 
 string name2 = "Mark"; 
 if (name1 == name2) 
 { 
    cout << "The names are the same." << endl; 
 } 
 else 
 { 
    cout << "The names are NOT the same." << endl; 
 } 
 The  == operator compares  name1 and  name2 to determine whether they are equal. 
Because the strings  "Mary" and  "Mark" are not equal, the  else clause will display the 
message  "The names are NOT the same." 
 Let’s look at another example. Assume  month is a  string object. The following code 
uses the  != operator to determine whether the value of  month is not equal to 
 "October" . 
 if (month != "October") 
 { 
    cout << "This is the wrong time for Octoberfest!" << endl; 
 } 
 Program 3-7 is a complete program demonstrating how two strings can be compared. 
The program prompts the user to enter a password and then determines whether the 
string entered is equal to  "prospero" . 
 Program 3-7 
  (CompareStrings.cpp) 
 1 // This program compares strings. 
 2 #include <iostream> 
 3 #include <string> 
 4 using namespace std; 
 5 
 6 int main() 
 7 { 
 8    string password; 
 9 
 10    // Get a password from the user. 
 11    cout << "Enter the password: "; 
 12    cin >> password; 
 13 
 14    // Determine whether the password is correct. 
 15    if (password == "prospero") 
 16    { 
 17       cout << "Password accepted." << endl; 
 18    } 
 19    else 

124 
Chapter 3 
 Decision Structures and Boolean Logic
 20    { 
 21       cout << "Sorry, that's the wrong password." << endl; 
 22    } 
 23    return 0; 
 24 } 
 Program Output with Input Shown in Bold 
 Enter the password:  ferdinand [ Enter ] 
 Sorry, that's the wrong password.  
 Program Output with Input Shown in Bold 
 Enter the password:  prospero [ Enter ] 
 Password accepted.  
 String comparisons are case sensitive. For example, the strings  "saturday" and  "Saturday" 
are not equal because the  s is lowercase in the first string, but uppercase in the second string. 
The following sample session with Program 3-7 shows what happens when the user enters 
 Prospero as the password (with an uppercase   P ). 
 Program Output with Input Shown in Bold 
 Enter the password:  Prospero [ Enter ] 
 Sorry, that is the wrong password.  
 Review Questions 
 Multiple Choice  
 
1.  A _____ structure can execute a set of statements only under certain circum-
stances.  
 a.  sequence  
 b.  circumstantial  
 c.  decision 
 d.  Boolean 
 
2.  A _____ structure provides one alternative path of execution.  
 a.  sequence  
 b.  single alternative decision  
 c.  one path alternative  
 d.  single execution decision  
 
3.  A(n) _____ expression has a value of either true or false.  
 a.  binary 
 b.  decision 
 c.  unconditional 
 d.  Boolean 

 
Review Questions 
125
 
4.   The symbols  > ,  < , and  == are all _____ operators. 
 a.  relational  
 b.  logical  
 c.  conditional 
 d.  ternary  
 
5.   A(n) _____ structure tests a condition and then takes one path if the condition is 
true or another path if the condition is false.  
 a.  if statement  
 b.  single alternative decision  
 c.  dual alternative decision  
 d.  sequence  
 
6.   You use a(n) _____ statement to write a single alternative decision structure.  
 a.  test - jump 
 b.  if 
 c.   if - else 
 d.  if - call 
 
7.   You use a(n) _____ statement to write a dual alternative decision structure.  
 a.  test - jump 
 b.  if 
 c.   if - else 
 d.  if - call 
 
8.   && ,  || , and  ! are _____ operators.  
 a.  relational  
 b.  logical  
 c.  conditional 
 d.  ternary  
 
9.   A compound Boolean expression created with the _____ operator is true only if 
both of its subexpressions are true.  
 a.  && 
 b.  || 
 c.   ! 
 d.  both 
 
10.  A compound Boolean expression created with the _____ operator is true if either 
of its subexpressions is true.  
 a.  && 
 b.  || 
 c.   ! 
 d.  either 
 
11.  The _____ operator takes a Boolean expression as its operand and reverses its 
logical value.  
 a.  && 
 b.  || 
 c.   ! 
 d.  either 

126 
Chapter 3 
 Decision Structures and Boolean Logic
 
12.  This statement allows you to test the value of an integer variable or expression 
and then use that value to determine which statement or set of statements to 
execute:  
 a.  menu. 
 b.  branch. 
 c.  select. 
 d.  switch. 
 
13.   This section of a  switch statement is branched to if none of the  case values match 
the test expression:  
 a.  else. 
 b.  default. 
 c.  case. 
 d.  otherwise. 
 
14.   A _____ is a Boolean variable that signals when some condition exists in the pro-
gram.  
 a.  flag  
 b.  signal 
 c.  sentinel  
 d.  siren 
 
15.   You use the _____ operator to determine whether two strings are equal.  
 a.  != 
 b.  @= 
 c.  == 
 d.  $= 
 True or False  
 
1.  You can write any program using only sequence structures.  
 
2.  A program can be made of only one type of control structure. You cannot com-
bine structures.  
 
3.  A single alternative decision structure tests a condition and then takes one path if 
the condition is true or another path if the condition is false.  
 
4.  A decision structure can be nested inside another decision structure.  
 
5.  A compound Boolean expression that has two subexpressions connected with the 
 && operator is true only when both subexpressions are true.  
 
6.  A compound Boolean expression that has two subexpressions connected with the 
 || operator is true only when both subexpressions are true.  
 
7.  The test expression in a  switch statement must have an integer value.  
 Short Answer  
 
1.  Explain what is meant by the term  conditionally executed . 
 
2.   You need to test a condition and then execute one set of statements if the condi-
tion is true. If the condition is false, you need to execute a different set of state-
ments. What structure will you use?  

 
Review Questions 
127
 
3.   Briefly describe how the  && operator works.  
 
4.   Briefly describe how the  || operator works.  
 
5.   Briefly describe how the  ! operator works. 
 
6.   What is a flag, and how does it work?  
 
7.   If you need to test the value of an integer variable and use that value to deter-
mine which statement or set of statements to execute, which statement would be 
a good choice?  
 Algorithm Workbench  
 
1.  Write an  if statement that assigns 20 to the variable  y and assigns 40 to the vari-
able  z if the variable  x is greater than 100.  
 
2.   Write an  if statement that assigns 0 to the variable  b and assigns 1 to the variable 
 c if the variable  a is less than 10.  
 
3.   Write an  if-else statement that assigns 0 to the variable  b if the variable  a is less 
than 10. Otherwise, it should assign 99 to the variable  b . 
 
4.   The following code contains several nested  if-else statements. Unfortunately, it 
was written without proper alignment and indentation. Rewrite the code and use 
the proper conventions of alignment and indentation. 
 if (score < 60) 
 { 
 cout << "Your grade is F."; 
 } 
 else 
 { 
 if (score < 70) 
 { 
 cout << "Your grade is D."; 
 } 
 else 
 { 
 if (score < 80) 
 { 
 cout << "Your grade is C."; 
 } 
 else 
 { 
 if (score < 90) 
 { 
 cout << "Your grade is B."; 
 } 
 else 
 { 
 cout << "Your grade is A."; 
 }}}} 
 
5.   Write nested decision structures that perform the following: If  amount1 is 
greater than 10 and  amount2 is less than 100, display the greater of  amount1 
and  amount2 .  

128 
Chapter 3 
 Decision Structures and Boolean Logic
 
6.  Write an  if-else statement that displays  "Speed is normal" if the  speed variable 
is within the range of 24 to 56. If the  speed variable’s value is outside this range, 
display  "Speed is abnormal" . 
 
7.  Write an  if-else statement that determines whether the  points variable is out-
side the range of 9 to 51. If the variable’s value is outside this range, it should 
display “Invalid points.” Otherwise, it should display “Valid points.”  
 
8.   Rewrite the following  if - else  if statement as a  switch statement. 
 if (selection == 1) 
   cout << "You selected A." << endl; 
 else if (selection == 2) 
   cout << "You selected 2." << endl; 
 else if (selection == 3) 
   cout << "You selected 3." << endl; 
 else if (selection == 4) 
   cout << "You selected 4." << endl; 
 else 
   cout << "Not good with numbers, eh?" << endl;  
 
9.  Write a  switch statement that tests the  month variable and does the following: 
 •  If the  month variable is set to 1, it displays “January has 31 days.”  
 •  If the  month variable is set to 2, it displays “February has 28 days.”  
 •  If the  month variable is set to 3, it displays “March has 31 days.”  
 •  If the  month variable is set to anything else, it displays “Invalid selection.”  
 
10.   Write an  if statement that sets the variable  hours to 10 if the flag variable  minimum 
is set to  true . 
 Programming Exercises 
 
1.  Roman Numerals 
 Write a program that prompts the user to enter a number within the range of 1 through 
10. The program should display the Roman numeral version of that number. If the 
number is outside the range of 1 through 10, the program should display an error mes-
sage. The following table shows the Roman numerals for the numbers 1 through 10:  
 Number 
 Roman Numeral 
 1 
 I 
 2 
 II 
 3 
 III 
 4 
 IV 
 5 
 V 
 6 
 VI 
 7 
 VII 
 8 
 VIII 
 9 
 IX 
 10 
 X 

 
Programming Exercises 
129
 
2.   Areas of Rectangles 
 The area of a rectangle is the rectangle’s length times its width. Write a program 
that asks for the length and width of two rectangles. The program should tell the 
user which rectangle has the greater area, or if the areas are the same.  
 
3.   Mass and Weight 
 Scientists measure an object’s mass in kilograms and its weight in Newtons. If you 
know the amount of mass of an object, you can calculate its weight, in Newtons, 
with the following formula: 
 Weight = mass × 9.8 
 Write a program that asks the user to enter an object’s mass and then calcu-
lates its weight. If the object weighs more than 1000 Newtons, display a message 
indicating that it is too heavy. If the object weighs less than 10 Newtons, display 
a message indicating that it is too light.  
 
4.   Book Club Points 
 Serendipity Booksellers has a book club that awards points to its customers based 
on the number of books purchased each month. The points are awarded as follows: 
 •  If a customer purchases 0 books, he or she earns 0 points.  
 •  If a customer purchases 1 book, he or she earns 5 points.  
 •  If a customer purchases 2 books, he or she earns 15 points.  
 •  If a customer purchases 3 books, he or she earns 30 points.  
 •  If a customer purchases 4 or more books, he or she earns 60 points.  
 Write a program that asks the user to enter the number of books that he or she 
has purchased this month and displays the number of points awarded,  
 
5.   Software Sales 
 A software company sells a package that retails for $99. Quantity discounts are 
given according to the following table: 
 Quantity 
 Discount 
 10–19 
 20% 
 20–49 
 30% 
 50–99 
 40% 
 100 or more 
 50% 
 Write a program that asks the user to enter the number of packages purchased. 
The program should then display the amount of the discount (if any) and the total 
amount of the purchase after the discount.  
 
6.   Shipping Charges 
 The Fast Freight Shipping Company charges the following rates: 
 Weight of Package 
 Rate per Pound 
 2 pounds or less 
 $1.10 
 Over 2 pounds but not more than 6 pounds 
 $2.20 
 Over 6 pounds but not more than 10 pounds 
 $3.70 
 Over 10 pounds 
 $3.80 

130 
Chapter 3 
 Decision Structures and Boolean Logic
 Write a program that asks the user to enter the weight of a package and then 
displays the shipping charges.  
 
7.   Body Mass Index 
 Write a program that displays a person’s body mass index (BMI). The BMI is 
often used to determine whether a person is overweight or underweight for their 
height. A person’s BMI is calculated with the following formula: 
 BMI = weight × 703/height2 
 In the formula, weight is measured in pounds, and height is measured in inches. 
After the program displays the user’s BMI, it should display a message indicat-
ing whether the person has optimal weight, is underweight, or is overweight. A 
person’s weight is considered to be optimal if his or her BMI is between 18.5 and 
25. If the BMI is less than 18.5, the person is considered to be underweight. If the 
BMI value is greater than 25, the person is considered to be overweight.  
 
8.   Time Calculator 
 Write a program that asks the user to enter a number of seconds and works as 
follows: 
 •  There are 60 seconds in a minute. If the number of seconds entered by the 
user is greater than or equal to 60, the program should display the number 
of minutes in that many seconds.  
 •  There are 3,600 seconds in an hour. If the number of seconds entered by 
the user is greater than or equal to 3,600, the program should display the 
number of hours in that many seconds.  
 •  There are 86,400 seconds in a day. If the number of seconds entered by 
the user is greater than or equal to 86,400, the program should display the 
number of days in that many seconds.  
VideoNote
Solving the Time 
Calculator Problem

131
 
4.1  Introduction to Repetition Structures 
 CONCEPT:   A repetition structure causes a statement or set of statements to execute 
repeatedly.  
 Programmers commonly have to write code that performs the same task over and over. 
For example, suppose you have been asked to write a program that calculates a 10 percent 
sales commission for several salespeople. Although it would not be a good design, one 
approach would be to write the code to calculate one salesperson’s commission, and then 
repeat that code for each salesperson. For example, look at the following pseudocode: 
 // Variables for sales and commission. 
 double sales, commission; 
 // Constant for the commission rate. 
 const double COMMISSION_RATE = 0.15; 
 // Get the amount of sales. 
 cout << "Enter the amount of sales." << endl; 
 cin >> sales;  
 
 // Calculate the commission. 
 commission = sales * COMMISSION_RATE;  
 // Display the commission. 
 
 
 cout << "The commission is $" 
     << commission << endl; 
 ⎛
 ⎜
 ⎜
 ⎜
 ⎜
 ⎨
 ⎜
 ⎜
 ⎜
 ⎜
 ⎝
 4.1  Introduction to Repetition Structures   
 4.2   Condition-Controlled Loops: The  while 
and  do - while Loops   
 4.3   The Increment and Decrement Operators    
 4.4   Count-Controlled Loops: 
The  for Loop   
 4.5   Calculating a Running Total   
 4.6   Nested Loops   
 TOPICS 
 Repetition Structures 
4 
 CHAPTER
 This calculates the first 
salesperson’s commission. 

132 
Chapter 4  Repetition Structures
 // Get the amount of sales. 
  
 cout << "Enter the amount of sales."  
 
 cin >> sales;  
 // Calculate the commission.  
 
 commission = sales * COMMISSION_RATE; 
 // Display the commission. 
 
 
 cout << "The commission is $" 
     << commission << endl; 
 And this code goes on and on... 
 As you can see, this code is one long sequence structure containing a lot of duplicated 
code. The several disadvantages to this approach include the following: 
 ●  The duplicated code makes the program large.  
 ●  Writing a long sequence of statements can be time consuming.  
 ●  If part of the duplicated code has to be corrected or changed, then the correction 
or change has to be done many times.  
 Instead of writing the same sequence of statements over and over, a better way to 
repeatedly perform an operation is to write the code for the operation once, and then 
place that code in a structure that makes the computer repeat it as many times as 
necessary. This can be done with a  repetition structure , which is more commonly 
known as a  loop . 
 Condition-Controlled and Count-Controlled Loops 
 In this chapter we will look at two broad categories of loops: condition-controlled 
and count-controlled. A  condition-controlled loop uses a true/false condition to con-
trol the number of times that it repeats. A  count-controlled loop repeats a specific 
number of times. We will also discuss the C++ statements that allow you to construct 
these types of loops. 
 Checkpoint 
 4.1.  What is a repetition structure?  
 4.2.  What is a condition-controlled loop?  
 4.3.  What is a count-controlled loop?  
 
4.2  Condition-Controlled Loops: 
The  while and  do - while Loops 
 CONCEPT:    Both the  while and  do - while loops cause a statement or set of statements 
to repeat as long as a condition is true.  
 ⎛
 ⎜
 ⎜
 ⎜
 ⎜
 ⎨
 ⎜
 ⎜
 ⎜
 ⎜
 ⎝
 This calculates the second 
salesperson’s commission. 

 
4.2 Condition-Controlled Loops: The while and do-while Loops 
133
 The  while Loop 
 The  while loop gets its name from the way it works:  While a Boolean expression is 
true, do some task . The loop has two parts: (1) a Boolean expression that is tested for 
a true or false value, and (2) a statement or set of statements that is repeated as long 
as the Boolean expression is true.  Figure   4-1 shows the logic of a  while loop.  
Boolean
expression
True
False
Statement(s)
 Figure 4-1  The logic of a  while loop 
 The diamond symbol represents the Boolean expression that is tested. Notice what 
happens if the Boolean expression is true: One or more statements are executed, and 
the program’s execution flows back to the point just above the diamond symbol. The 
Boolean expression is tested again, and if it is true, the process repeats. If the Boolean 
expression is false, the program exits the loop. Each time the loop executes its state-
ment or statements, we say the loop is  iterating , or performing an  iteration . 
 Here is the general format of the  while loop: 
 while ( BooleanExpression ) 
 { 
    statement; 
    statement; 
     etc ; 
 } 
 We will refer to the first line as the   while clause . The  while clause begins with the 
word  while , followed by a Boolean expression that is enclosed in parentheses. 
Beginning on the next line is a block of statements that are enclosed in curly braces. 
This block of statements is known as the  body of the loop. 
 When the  while loop executes, the Boolean expression is tested. If the Boolean expres-
sion is true, the statements that appear in the body of the loop are executed, and then 
the loop starts over. If the Boolean expression is false, the loop ends, and the program 
resumes execution at the statement immediately following the loop. 
VideoNote
The while Loop

134 
Chapter 4  Repetition Structures
 We say that the statements in the body of the loop are conditionally executed because 
they are executed only under the condition that the Boolean expression is true. If you 
are writing a  while loop that has only one statement in its body, you do not have to 
enclose the statement inside curly braces. Such a loop can be written in the following 
general format: 
 while ( BooleanExpression ) 
     statement; 
 When a  while loop written in this format executes, the Boolean expression is tested. 
If it is true, the one statement that appears on the next line will be executed, and then 
the loop starts over. If the Boolean expression is false, however, the loop ends. 
 Although the curly braces are not required when the loop’s body contains only one 
statement, it is still a good idea to use them, as shown in the following general format: 
 while ( BooleanExpression ) 
 { 
     statement; 
 } 
 When we discussed the various  if statements, we mentioned that this is a good style 
of programming because it cuts down on errors. If you have more than one statement 
in the body of a loop, those statements  must be enclosed in curly braces. If you get 
into the habit of always enclosing the conditionally executed statements in a set of 
curly braces, it’s less likely that you will forget them. 
 You should also notice that the statements in the body of the loop are indented. 
As with  if statements, this indentation makes the code easier to read and debug. 
By indenting the statements in the body of the loop, you visually set them apart 
from the surrounding code. Most programmers use this style of indentation when 
writing loops. 
 Program 4-1 shows how we might use a  while loop to write the commission calculat-
ing program that was described at the beginning of this chapter. 
 Program 4-1 
 (Commissions.cpp) 
 1 // This program calculates sales commissions. 
 2 #include <iostream> 
 3 #include <string> 
 4 using namespace std; 
 5 
 6 int main() 
 7 { 
 8    // Variables 
 9    double sales, commission; 
 10    string keepGoing = "y"; 
 11 
 12    // Constant for the commission rate 
 13    const double COMMISSION_RATE = 0.10; 
 14 
 15    // Determine the commissions. 

 16    while (keepGoing == "y") 
 17    { 
 18       // Get the amount of sales. 
 19       cout << "Enter the amount of sales: "; 
 20       cin >> sales; 
 21    
 22       // Calculate the commission. 
 23       commission = sales * COMMISSION_RATE; 
 24    
 25       // Display the commission 
 26       cout << "The commission is $" 
 27           << commission << endl; 
 28 
 29       cout << "Do you want to calculate another" << endl; 
 30       cout << "commission? (Enter y for yes): "; 
 31       cin >> keepGoing; 
 32    } 
 33    return 0; 
 34 } 
 Program Output with Input Shown in Bold 
 Enter the amount of sales:  10000 [ Enter ] 
 The commission is $1000 
 Do you want to calculate another 
 commission? (Enter y for yes):  y [ Enter ] 
 Enter the amount of sales:  5000 [ Enter ] 
 The commission is $500 
 Do you want to calculate another 
 commission? (Enter y for yes):  y [ Enter ] 
 Enter the amount of sales:  12000 [ Enter ] 
 The commission is $1200 
 Do you want to calculate another 
 commission? (Enter y for yes):  n [ Enter ] 
 In line 9 we declare the  sales variable, which will hold the amount of sales, and the 
 commission variable, which will hold the amount of commission. Then, in line 10 we 
declare a  string variable named  keepGoing . Notice that the variable is initialized with 
the value “y”. This initialization value is important, and in a moment you will see why. 
In line 13 we declare a constant,  COMMISSION_RATE , which is initialized with the value 
0.10. This is the commission rate that we will use in our calculation. 
 Line 16 is the beginning of a  while loop, which starts like this: 
 while (keepGoing == "y")  
 Notice the expression that is being tested:  keepGoing == "y" . The loop tests this expres-
sion, and if it is true, the statements in the body of the loop (lines 18 through 31) are 
executed. Then, the loop starts over at line 16. It tests the expression  keepGoing == "y" 
and if it is true, the statements in the body of the loop are executed again. This cycle 
repeats until the expression  keepGoing == "y" is tested in line 16 and found to be false. 
When that happens, the program exits the loop. This is illustrated in  Figure  4-2 . 
 
4.2 Condition-Controlled Loops: The while and do-while Loops 
135

136 
Chapter 4  Repetition Structures
 For this loop to stop executing, something has to happen inside the loop to make the 
expression  keepGoing == "y" false. The statements in lines 29 through 31 take care 
of this. Lines 29 and 30 display a message asking, “Do you want to calculate another 
commission (Enter y for yes).” Then, the  cin statement in line 31 reads the user’s input 
and assigns it to the  keepGoing variable. If the user enters  y (and it must be a lower-
case  y ), then the expression  keepGoing == "y" will be true when the loop starts over. 
This will cause the statements in the body of the loop to execute again. But, if the user 
enters anything other than lowercase  y , the expression will be false when the loop 
starts over, and the program will exit the loop. 
 Now that you have examined the code, look at the program output in the sample 
run. First, the program prompted the user to enter the amount of sales. The user 
entered 10000, and then the program displayed the commission for that amount, 
which is $1000. Then, the user is prompted, “Do you want to calculate another 
commission? (Enter y for yes).” The user entered  y , and the loop starts these steps 
over. In the sample run, the user goes through this process three times. Each execu-
tion of the body of a loop is known as an iteration. In the sample run, the loop 
iterated three times.  
 The  while Loop Is a Pretest Loop 
 The  while loop is known as a  pretest loop, which means it tests its condition  before 
performing an iteration. Because the test is done at the beginning of the loop, you 
usually have to perform some steps prior to the loop to make sure that the loop ex-
ecutes at least once. For example, the loop in Program 4-1 starts like this: 
 while (keepGoing == "y")  
while (keepGoing == "y")
{
   // Get the amount of sales.
   cout << "Enter the amount of sales: ";
   cin >> sales;
   // Calculate the commission.
   commission = sales * COMMISSION_RATE;
   // Display the commission
   cout << "The commission is $" 
        << commission << endl;
   cout << "Do you want to calculate another" << endl;
   cout << "commission? (Enter y for yes): ";
   cin >> keepGoing;
}
This expression is tested.
If the expression is true, 
these statements are 
executed, and then the 
loop starts over.
If the expression is false, 
these statements are 
skipped and the 
program exits the loop.
 Figure 4-2  The  while loop 

 The loop will perform an iteration only if the expression  keepGoing == "y" is true. To 
make sure the expression is true the first time that the loop executes, we declared and 
initialized the  keepGoing variable in line 10 as follows: 
 string keepGoing = "y";  
 If  keepGoing had been initialized with any other value (or not initialized at all), 
the loop would never execute. This is an important characteristic of the  while 
loop: It will never execute if its condition is false to start with. In some programs, 
this is exactly what you want. The following  In the Spotlight section gives an 
example. 
 
4.2 Condition-Controlled Loops: The while and do-while Loops 
137
 In the Spotlight: 
 Writing a Program with a 
 while Loop 
 A project currently underway at Chemical Labs, Inc. requires that a substance be 
continually heated in a vat. A technician must check the substance’s temperature 
every 15 minutes. If the substance’s temperature does not exceed 102.5, then the tech-
nician does nothing. However, if the temperature is greater than 102.5, the technician 
must turn the vat’s thermostat down, wait five minutes, and check the temperature 
again. The technician repeats these steps until the temperature does not exceed 102.5. 
The director of engineering has asked you to write a program that guides the techni-
cian through this process. 
 Here is the algorithm that you designed: 
 1.  Get the substance’s temperature.  
 2.  Repeat these steps as long as the temperature is greater than 102.5: 
 a.  Tell the technician to turn the thermostat down, wait five minutes and check 
the temperature again.  
 b.  Get the substance’s temperature.  
 3.  After the loop finishes, tell the technician that the temperature is acceptable and 
to check it again in 15 minutes.  
 After reviewing this algorithm, you realize that steps 2a and 2b should not be per-
formed if the test condition (temperature is greater than 102.5) is false to begin with. 
The  while loop will work well in this situation because it will not execute even once 
if its condition is false. Program 4-2 shows the code for the program. 
 Program 4-2  
(PretestWhileLoop.cpp) 
 1 // This program demonstrates the pretest while loop. 
 2 #include <iostream> 
 3 using namespace std; 
 4  
 5 int main() 

138 
Chapter 4  Repetition Structures
 6 { 
 7    // Variable to hold the temperature 
 8    double temperature; 
 9  
 10    // Constant for the maximum temperature 
 11    const double MAX_TEMP = 102.5; 
 12  
 13    // Get the substance's temperature. 
 14    cout << "Enter the substance's temperature: "; 
 15    cin >> temperature; 
 16  
 17    // If necessary, adjust the thermostat. 
 18    while (temperature > MAX_TEMP) 
 19    { 
 20       cout << "The temperature is too high." << endl; 
 21       cout << "Turn the thermostat down and wait" << endl; 
 22       cout << "five minutes. Take the temperature" << endl; 
 23       cout << "again and enter it here: "; 
 24       cin >> temperature; 
 25    } 
 26 
 27    // Remind the user to check the temperature 
 28    // again in 15 minutes. 
 29    cout << "The temperature is acceptable." << endl; 
 30    cout << "Check it again in 15 minutes." << endl; 
 31    return 0; 
 32 } 
 Program Output with Input Shown in Bold 
 Enter the substance's temperature:  104.7 [ Enter ] 
 The temperature is too high. 
 Turn the thermostat down and wait 
 five minutes. Take the temperature 
 again and enter it here:  103.2 [ Enter ] 
 The temperature is too high. 
 Turn the thermostat down and wait 
 five minutes. Take the temperature 
 again and enter it here:  102.1 [ Enter ] 
 The temperature is acceptable. 
 Check it again in 15 minutes.  
 Program Output with Input Shown in Bold 
 Enter the substance's temperature:  102.1 [ Enter ] 
 The temperature is acceptable. 
 Check it again in 15 minutes.  

 Infinite Loops 
 In all but rare cases, loops must contain a way to terminate within themselves. 
This means that something inside the loop must eventually make the test condi-
tion false. The loop in Program 4-1 stops when the expression  keepGoing == "y" 
is false. If a loop does not have a way of stopping, it is called an  infinite loop . An 
infinite loop continues to repeat until the program is interrupted. Infinite loops 
usually occur when the programmer forgets to write code inside the loop that 
makes the test condition false. In most circumstances, you should avoid writing 
infinite loops. 
 Program 4-3 demonstrates an infinite loop. This is a modified version of the commis-
sion calculating program. In this version, we have removed the code that modifies the 
 keepGoing variable in the body of the loop. Each time the expression  keepGoing == "y" 
is tested in line 9,  keepGoing will contain the string “y”. As a consequence, the loop 
has no way of stopping. 
 Program 4-3  
(InfiniteLoop.cpp) 
 1 // This program has an infinite loop! 
 2 #include <iostream> 
 3 #include <string> 
 4 using namespace std; 
 5 
 6 int main() 
 7 { 
 8    // Variables 
 9    double sales, commission; 
 10    string keepGoing = "y"; 
 11 
 12    // Constant for the commission rate 
 13    const double COMMISSION_RATE = 0.10; 
 14 
 15    // Warning! Infinite loop! 
 16    while (keepGoing == "y") 
 17    { 
 18       // Get the amount of sales. 
 19       cout << "Enter the amount of sales: "; 
 20       cin >> sales; 
 21    
 22       // Calculate the commission. 
 23       commission = sales * COMMISSION_RATE; 
 24    
 25       // Display the commission 
 26       cout << "The commission is $" 
 27            << commission << endl; 
 28    } 
 29    return 0; 
 30 } 
 
4.2 Condition-Controlled Loops: The while and do-while Loops 
139

140 
Chapter 4  Repetition Structures
 The  do - while Loop: A Posttest Loop 
 You have learned that the  while loop is a pretest loop, which means it tests its Boolean 
expression before performing an iteration. The  do - while loop is a  posttest loop. This 
means it performs an iteration before testing its Boolean expression. As a result, the  do -
 while loop always performs at least one iteration, even if its Boolean expression is false 
to begin with. The logic of a  do - while loop is shown in the flowchart in  Figure   4-3  .  
Boolean
Expression
True
False
Statement(s)
 Figure 4-3  The logic of a  do - while loop 
 In the flowchart, one or more statements are executed, and then a Boolean expression 
is tested. If the Boolean expression is true, the program’s execution flows back to the 
point just above the first statement in the body of the loop, and this process repeats. 
If the Boolean expression is false, the program exits the loop. 
 In code, the  do - while loop looks something like an inverted  while loop. Here is the 
general format of the  do - while loop: 
 do 
 { 
     statement; 
     statement; 
     etc ; 
 } while ( BooleanExpression );  
 As with the  while loop, the braces are optional if only one statement is in the body of 
the loop. This is the general format of the  do - while loop with only one conditionally 
executed statement: 
 do 
      statement; 
 while ( BooleanExpression );  
 Notice that a semicolon appears at the very end of the  do - while statement. This semi-
colon is required, and leaving it out is a common error. 

 
4.3 The Increment and Decrement Operators 
141
 The  do - while loop is a posttest loop. This means it does not test its Boolean expression 
until it has completed an iteration. As a result, the  do - while loop always performs at 
least one iteration, even if the expression is false to begin with. This differs from the 
behavior of a  while loop. For example, in the following  while loop, the  cout state-
ment will not execute at all: 
 int number = 1; 
 while (number < 0) 
 { 
    cout << number << endl; 
 } 
 But, the  cout statement in the following  do - while loop will execute one time because 
the  do - while loop does not test the expression  number < 0 until the end of the iteration. 
 int number = 1; 
 do 
 { 
    cout << number << endl; 
 } while (number < 0);  
 Checkpoint 
 4.4.  What is a repetition structure?  
 4.5.  What is a condition-controlled loop? What is a count-controlled loop?  
 4.6.  What is a loop iteration?  
 4.7.  What is the difference between a pretest loop and a posttest loop?  
 4.8.  Does the  while loop test its condition before or after it performs an iteration?  
 4.9.  Does the  do - while loop test its condition before or after it performs an iteration?  
 4.10.  What is an infinite loop?  
 
  4.3  The Increment and Decrement Operators 
 CONCEPT:    To increment a variable means to increase its value, and to decrement 
a variable means to decrease its value. C++ provides special operators 
to increment and decrement variables.  
 To  increment a variable means to increase its value, and to  decrement a variable means 
to decrease its value. Both of the following statements increment the variable  num by one: 
 num = num + 1; 
 num += 1;  
 And  num  is decremented by one in both of the following statements: 
 num = num - 1; 
 num -= 1;  

142 
Chapter 4  Repetition Structures
 Incrementing and decrementing is so commonly done in programs that C++ provides 
a set of simple unary operators designed just for incrementing and decrementing vari-
ables. The increment operator is  ++ , and the decrement operator is  -- . The following 
statement uses the  ++ operator to add 1 to  num : 
 num++;  
 After this statement executes, the value of num will be increased by one. The following 
statement uses the  -- operator to subtract 1 from  num : 
 num--;  
 NOTE:    The  ++ operator is pronounced “plus plus,” and the  -- operator is pro-
nounced “minus minus.” The expression num++ would be pronounced “num plus 
plus,” and the expression num-- would be pronounced “num minus minus.”  
 In these examples, we have written the  ++ and  -- operators after their operands (or, 
on the right side of their operands). This is called  postfix mode . The operators can 
also be written before (or, on the left side) of their operands, which is called  prefix 
mode . Here are examples: 
 ++num; 
 --num;  
 When you write a simple statement to increment or decrement a variable, such as the 
ones shown here, it doesn’t matter if you use prefix mode or postfix mode. The oper-
ators do the same thing in either mode. However, if you write statements that mix 
these operators with other operators or with other operations, there is a difference in 
the way the two modes work. Such complex code can be difficult to understand and 
debug. When we use the increment and decrement operators, we will do so only in 
ways that are straightforward and easy to understand, such as the statements previ-
ously shown. 
 We introduce these operators at this point because they are commonly used in certain 
types of loops. In the next section, which discusses the  for loop, you will see these 
operators used often. 
 Checkpoint 
 4.11.   When you increment or decrement a variable, what are you doing?  
 4.12.   After the following code executes, what value will be stored in the  number 
 variable? 
 int number = 5; 
 number++;  
 4.13.   After the following code executes, what value will be stored in the  number 
 variable? 
 int number = 5; 
 number--;  

 
  4.4  Count-Controlled Loops: The  for Loop 
 CONCEPT:   A count-controlled loop iterates a specific number of times. In C++ the 
 for loop is commonly used as a count-controlled loop.  
 As mentioned earlier, a count-controlled loop iterates a specific number of times. 
Count-controlled loops are commonly used in programs. For example, suppose a 
business is open six days per week, and you are going to write a program that calcu-
lates the total sales for a week. You will need a loop that iterates exactly six times. 
Each time the loop iterates, it will prompt the user to enter the sales for one day. 
 The way a count-controlled loop works is simple: The loop keeps a count of the number 
of times it iterates, and when the count reaches a specified amount, the loop stops. A count-
controlled loop uses a variable known as a  counter variable , or simply  counter , to store the 
number of iterations that it has performed. Using the counter variable, the loop performs 
the following three actions, which are known as the  initialization ,  test , and  increment : 
 1.  Initialization:   Before the loop begins, the counter variable is initialized to a start-
ing value. In many situations the starting value will be 0, or possibly 1, but it 
can be other values depending on the nature of the problem.  
 2.  Test:   The loop tests the counter variable by comparing it to a maximum value. 
If the counter variable has not reached the maximum value yet, the loop iterates. 
If the counter has reached the maximum value, the program exits the loop.  
 3.  Increment:   To  increment  a variable means to increase its value. During each 
iteration, the loop increments the counter variable by adding one to it.  
 Figure   4-4 shows the general logic of a count-controlled loop. The initialization, test, 
and increment operations are indicated with the ①, ②, and ③ callouts.  
 In the flowchart, assume that  counter is an  int variable. The first step is to set  counter 
to the value 1. Then, we determine whether  counter is less than or equal to a maxi-
mum value. If this is true, we execute the body of the loop. Otherwise, we exit the 
loop. Notice that in the body of the loop we execute one or more statements, and then 
we add one to  counter . Adding one to the counter variable is critical because without 
this step, the loop would iterate an infinite number of times. 
 Using the logic shown in the flowchart, the   maxValue that we use in the comparison 
will be the number of times we want the loop to iterate. For example, if we want the 
loop to iterate six times, we will test the expression  counter <= 6 . Likewise, if we 
want the loop to iterate 100 times, we will test the expression  counter <= 100 . 
 Count-controlled loops are so common that C++ provides a type of loop just for 
them. It is known as the   for loop . The  for loop is specifically designed to initialize, 
test, and increment a counter variable. Here is the general format of the  for loop: 
 for ( InitializationExpression ;  TestExpression ;  IncrementExpression ) 
 { 
     statement ; 
     statement ; 
     etc. 
 } 
 
4.4 Count-Controlled Loops: The for Loop 
143
VideoNote
The for Loop

144 
Chapter 4  Repetition Structures
 The statements that appear inside the curly braces are the body of the loop. These are 
the statements that are executed each time the loop iterates. As with other control 
structures, the curly braces are optional if the body of the loop contains only one 
statement, as shown in the following general format: 
 for ( InitializationExpression ;  TestExpression ;  IncrementExpression ) 
     statement ; 
 As with other control structures, we always recommend using the curly braces, even 
if there is only one statement in the body of the loop. Let’s look at each part of the 
loop. 
 The first line of the  for loop is the  loop header . After the key word  for , three expres-
sions are inside the parentheses, separated by semicolons. (Notice there is not a semi-
colon after the third expression.) 
 The first expression is the  initialization expression . It is normally used to initialize a 
counter variable to its starting value. This is the first action performed by the loop, 
and it is only done once. The second expression is the  test expression . This is a Boolean 
expression that controls the execution of the loop. As long as this expression is true, 
the body of the  for loop will repeat. The  for loop is a pretest loop, so it evaluates the 
test expression before each iteration. The third expression is the  increment expression . 
It executes at the end of each iteration. Typically, this is a statement that increments 
the loop’s counter variable. 
counter <= maxValue
Statement(s)
Add 1 to counter
counter = 1
True
False
1
2
3
Initialization
Test
Increment
 Figure 4-4  Logic of a count-controlled loop  

 Here is an example of a simple  for loop that prints “Hello” five times: 
 for (counter = 1; counter <= 5; counter++) 
 { 
    cout << "Hello" << endl; 
 } 
 In this loop, the initialization expression is  counter = 1 , the test expression is 
 counter <= 5 , and the increment expression is  counter++ . The body of the loop has 
one statement, which is a  cout statement. This is a summary of what happens when 
this loop executes: 
 1.  The initialization expression  counter = 1 is executed. This assigns 1 to the 
 counter variable.  
 2.  The expression  counter <= 5 is tested. If the expression is true, continue with 
step 3. Otherwise, the loop is finished.  
 3.  The statement  cout << "Hello" << endl; is executed.  
 4.  The increment expression  counter++ is executed. This adds 1 to the  counter 
variable.  
 5.   Go back to step 2.  
 Figure  4-5 illustrates this sequence of events. Notice that steps 2 through 4 are repeated 
as long as the test expression is true.  
for (counter = 1; counter <= 5; counter++)
{
    cout << "Hello" << endl;
}
Step 1: Perform the initialization.
Step 2: Evaluate the test expression. If
it is true, go to step 3. Otherwise, the
loop stops.
Step 3: Execute the body
of the loop.
Step 4: Perform the update expression,
then go back to step 2.
 Figure 4-5  Sequence of events in the  for loop 
 Okay, we’ve explained enough! Let’s look at an actual program. Program 4-4 uses a 
 for loop to display the string “Hello world” five times. 
 Program 4-4 
  (ForLoop.cpp) 
 1 // This program demonstrates the for loop. 
 2 #include <iostream> 
 3 using namespace std; 
 4 
 5 int main() 
 6 { 
 7    int counter; 
 8    const int MAX_VALUE = 5; 
 
4.4 Count-Controlled Loops: The for Loop 
145

146 
Chapter 4  Repetition Structures
 9 
 10    for (counter = 0; counter < MAX_VALUE; counter++) 
 11    { 
 12       cout << "Hello world" << endl; 
 13    } 
 14    return 0; 
 15 } 
 Program Output 
 Hello world 
 Hello world 
 Hello world 
 Hello world 
 Hello world  
 Line 7 declares an  int variable that will be used as the counter variable. You do not 
have to name the variable  counter (you are free to name it anything you wish), but in 
many cases that is an appropriate name. Line 8 declares a constant named  MAX_VALUE 
that will be used as the counter’s maximum value. The  for loop begins in line 10. This 
is what’s happening in the loop header: 
 ●  The initialization expression is  count = 0 . This assigns 0 to the  count variable.  
 ●  The test expression is  count < MAX_VALUE . 
 ●  The increment expression is  count++ . 
 As a result of these expressions, the loop will iterate five times. As the loop iterates, 
the  count variable will be assigned the values 0 through 4. Each time it iterates, it 
displays “Hello world”. 
 Notice that the loop does not contain a statement to increment the  counter variable. 
This happens automatically in a  for loop, at the end of each iteration. For that reason, 
you should be careful not to place a statement that modifies the counter variable inside 
the body of a  for loop. Doing so will usually disrupt the way the  for loop works.  
 NOTE:   There are different ways to set up the counter variable in a  for loop to 
achieve the same results. For example, the loop in Program 4-4 could have started 
like this: 
 for (counter = 1; counter <= MAX_VALUE; counter++)  
 In this example  counter is initialized with the value 1, and the loop iterates as long 
as  counter is less than or equal to  MAX_VALUE . This loop will also iterate five times, 
but the  counter variable will be assigned the values 1 through 5.  
 Declaring the Counter Variable 
in the Initialization Expression 
 Not only may the counter variable be initialized in the initialization expression, but it 
may also be declared there as well. The following code shows an example. 

 const int MAX_VALUE = 5; 
 for (int counter = 0; count < MAX_VALUE; counter++) 
 { 
    cout << "Hello" << endl; 
 } 
 In this loop, the  counter variable is both declared and initialized in the initialization 
expression. If the variable is used only in the loop, it makes sense to define it in the 
loop header. This makes the variable’s purpose more clear. 
 When a variable is declared in the initialization expression of a  for loop, the scope of 
the variable is limited to the loop. This means you cannot access the variable in state-
ments outside the loop. For example, the following code would cause a compiler error 
because the last statement (the last  cout statement) cannot access the  count variable. 
 const int MAX_VALUE = 5; 
 for (int count = 0; count < MAX_VALUE; count++) 
 { 
    cout << "Hello" << endl; 
 } 
 cout << "The value of the counter is " << count << endl;  
 Using the Counter Variable in the Body of the Loop 
 In a count-controlled loop, the primary purpose of the counter variable is to store the 
number of times that the loop has iterated. In some situations, it is also helpful to use 
the counter variable in a calculation or other task within the body of the loop. For 
example, suppose you need to write a program that displays the numbers 1 through 
10 and their squares in a table similar to this: 
 Number 
 Square 
 1 
 1 
 2 
 4 
 3 
 9 
 4 
 16 
 5 
 25 
 6 
 36 
 7 
 49 
 8 
 64 
 9 
 81 
 10 
 100 
 This can be accomplished by writing a count-controlled loop that iterates 10 times. 
During the first iteration, the counter variable will be set to 1, during the second 
iteration it will be set to 2, and so forth. Because the counter variable will take on the 
values 1 through 10 during the loop’s execution, you can use it in the calculation 
inside the loop. Program 4-5 demonstrates this logic. 
 
4.4 Count-Controlled Loops: The for Loop 
147

148 
Chapter 4  Repetition Structures
 Program 4-5  
(Squares.cpp) 
 1 // This program prints a table showing the squares 
 2 // of the numbers 1 through 10. 
 3 #include <iostream> 
 4 using namespace std; 
 5 
 6 int main() 
 7 { 
 8    const int MAX_VALUE = 10; 
 9 
 10    // Display the table headings. 
 11    cout << "Number\t\tSquare" << endl; 
 12 
 13    for (int number = 1; number <= MAX_VALUE; number++) 
 14    { 
 15       cout << number << "\t\t" 
 16            << (number * number) << endl; 
 17    } 
 18    return 0; 
 19 } 
 Program Output 
 Number 
 Square 
 1 
 1 
 2 
 4 
 3 
 9 
 4 
 16 
 5 
 25 
 6 
 36 
 7 
 49 
 8 
 64 
 9 
 81 
 10 
 100 
 First, take a closer look at line 11, which displays the table headings: 
 cout << "Number\t\tSquare" << endl;  
 Notice that two  \t escape sequences appear inside the string literal, between the 
words  Number and  Square . The  \t escape sequence is like pressing the Tab key: it 
causes the output cursor to move over to the next tab position. This causes the spaces 
that you see between the words  Number and  Square in the sample output. 
 The  for loop begins in line 13. During the first iteration,  number will be assigned 1, 
during the second iteration  number will be assigned 2, and so forth, up to 10. Inside the 
loop, the statement in lines 15 and 16 displays the value of  number , tabs over twice, and 

then displays the value of  number * number . (Tabbing over twice, with the two  \t 
escape sequence causes the numbers to be aligned in two columns in the output.)  
 Other Forms of the Update Expression 
 You are not limited to using increment statements in the update expression. Here is a 
loop that displays all the even numbers from 2 through 100 by adding 2 to its counter 
variable: 
 for (int counter = 2; counter <= 100; counter += 2) 
   cout << counter << endl;  
 And here is a loop that counts backward from 10 down to 0: 
 for (int counter = 10; counter >= 0; counter--) 
   cout << counter << endl;  
 In the Spotlight: 
 Writing a Count-Controlled  for Loop 
 Your friend Amanda just inherited a European sports car from her uncle. Amanda lives 
in the United States, and she is afraid she will get a speeding ticket because the car’s 
speedometer indicates kilometers per hour. She has asked you to write a program that 
displays a table of speeds in kilometers per hour with their values converted to miles 
per hour. The formula for converting kilometers per hour to miles per hour is 
 MPH = KPH * 0.6214  
 In the formula,  MPH is the speed in miles per hour, and  KPH is the speed in kilome-
ters per hour. 
 The table that your program displays should show speeds from 60 kilometers per 
hour through 130 kilometers per hour, in increments of 10, along with their values 
converted to miles per hour. The table should look something like this: 
 KPH 
 MPH 
 60 
 37.3 
 70 
 43.5 
 80 
 49.7 
 etc.... 
 
 130 
 80.8 
 After thinking about this table of values, you decide that you will write a  for loop that 
uses a counter variable to hold the kilometer-per-hour speeds. The counter’s starting 
value will be 60, its ending value will be 130, and you will add 10 to the counter vari-
able after each iteration. Inside the loop you will use the counter variable to calculate 
a speed in miles-per-hour. Program 4-6 shows the code. 
 
4.4 Count-Controlled Loops: The for Loop 
149

150 
Chapter 4  Repetition Structures
 Program 4-6  
(SpeedConverter.cpp) 
 1 // This program converts the speeds 60 kph through 
 2 // 130 kph (in 10 kph increments) to mph. 
 3 #include <iostream> 
 4 using namespace std; 
 5 
 6 int main() 
 7 { 
 8    // Constants for the speeds 
 9    const int START_KPH = 60,  // Starting speed 
 10              END_KPH = 130,   // Ending speed 
 11              INCREMENT = 10;  // Speed increment 
 12 
 13    // Constant for the conversion factor 
 14    const double CONVERSION_FACTOR = 0.6214; 
 15 
 16    // Variables 
 17    int kph;       // To hold speeds in kph 
 18    double mph;    // To hold speeds in mph 
 19 
 20    // Display the table headings. 
 21    cout << "KPH\tMPH" << endl; 
 22    cout << "---------------" << endl; 
 23 
 24    // Display the speeds. 
 25    for (kph = START_KPH; kph <= END_KPH; kph += INCREMENT) 
 26    { 
 27       // Calculate mph 
 28       mph = kph * CONVERSION_FACTOR; 
 29 
 30       // Display the speeds in kph and mph. 
 31       cout << kph << "\t" << mph << endl; 
 32    } 
 33    return 0; 
 34 } 
 Program Output 
 KPH 
 MPH 
 60 
 37.284 
 70 
 43.498 
 80 
 49.712 
 90 
 55.926 
 100 
 62.14 
 110 
 68.354 
 120 
 74.568 
 130 
 80.782 
---------------

 Letting the User Control the Number of Iterations 
 In many cases, the programmer knows the exact number of iterations that a loop must 
perform. For example, recall Program 4-5, which displays a table showing the num-
bers 1 through 10 and their squares. When the code was written, the programmer 
knew that the loop had to iterate 10 times. A constant named  MAX_VALUE was initial-
ized with the value 10, and the loop was written as follows: 
 for (int number = 1; number <= MAX_VALUE; number++)  
 As a result, the loop iterates exactly 10 times. Sometimes, however, the programmer needs to 
let the user decide the number of times that a loop should iterate. For example, what if you 
want Program 4-4 to be a bit more versatile by allowing the user to specify the maximum 
value displayed by the loop? The code in Program 4-7 shows how you can accomplish this. 
 Program 4-7  
(UserSquares.cpp) 
 1 // This program prints a table of numbers 
 2 // and their squares. 
 3 #include <iostream> 
 4 using namespace std; 
 5 
 6 int main() 
 7 { 
 8    int upperLimit; 
 9 
 10    // Get the upper limit. 
 11    cout << "This program displays numbers, starting at 1," << endl; 
 12    cout << "and their squares. How high should I go? "; 
 13    cin >> upperLimit; 
 14 
 15    // Display the table headings. 
 16    cout << "Number\t\tSquare" << endl; 
 17 
 18    // Display the values. 
 19    for (int number = 1; number <= upperLimit; number++) 
 20    { 
 21       cout << number << "\t\t" 
 22           << (number * number) << endl; 
 23    } 
 24    return 0; 
 25 } 
 Program Output with Input Shown in Bold 
 This program displays numbers, starting at 1,
and their squares. How high should I go?  5 [ Enter ] 
 Number 
 Square 
 1 
 1 
 2 
 4 
 3 
 9 
 4 
 16 
 5 
 25 
 
4.4 Count-Controlled Loops: The for Loop 
151

152 
Chapter 4  Repetition Structures
 Lines 11 and 12 ask the user how high the numbers in the table should go, and the 
statement in line 13 assigns the user’s input to the  upperLimit variable. Then, the  for 
loop uses the  upperLimit variable as the counter’s ending value: 
 for (int number = 1; number <= upperLimit; number++)  
 As a result, the  counter variable starts with 1 and ends with the value in  upperLimit . 
 Checkpoint 
 4.14.   What is a counter variable?  
 4.15.   What three actions do count-controlled loops typically perform using the 
counter variable?  
 4.16.   What would the following code display? 
 for (int counter = 1; count <= 5; count++) 
 { 
  cout << counter << endl; 
 } 
 4.17.   What would the following code display? 
 for (int counter = 0; count <= 500; count += 100) 
 { 
  cout << counter << endl; 
 } 
 
 4.5  Calculating a Running Total 
 CONCEPT:   A running total is a sum of numbers that accumulates with each 
iteration of a loop. The variable used to keep the running total is 
called an accumulator.  
 Many programming tasks require you to calculate the total of a series of numbers. For 
example, suppose you are writing a program that calculates a business’s total sales for 
a week. The program would read the sales for each day as input and calculate the 
total of those numbers. 
 Programs that calculate the total of a series of numbers typically use two elements: 
 ●  A loop that reads each number in the series.  
 ●  A variable that accumulates the total of the numbers as they are read.  
 The variable that is used to accumulate the total of the numbers is called an  accumu-
lator . It is often said that the loop keeps a  running total because it accumulates the 
total as it reads each number in the series.  Figure   4-6 shows the general logic of a loop 
that calculates a running total.  

 
4.5 Calculating a Running Total 
153
 When the loop finishes, the accumulator will contain the total of the numbers that 
were read by the loop. Notice that the first step in the flowchart is to set the accumu-
lator variable to 0. This is a critical step. Each time the loop reads a number, it adds 
it to the accumulator. If the accumulator starts with any value other than 0, it will not 
contain the correct total when the loop finishes. 
 Let’s look at a program that calculates a running total. The code shown in Program 4-8 
allows the user to enter five numbers, and it displays the total of the numbers entered. 
 Program 4-8  
(SumOfNumbers.cpp) 
 1 // This program calculates the sum of a series of numbers. 
 2 #include <iostream> 
 3 using namespace std; 
 4 
 5 int main() 
 6 { 
 7    // Variables 
 8    int number,      // To hold each number 
 9        total = 0;   // Accumulator, initialized with 0 
 10 
 11    // Constant for the number of numbers 
 12    const int MAX_NUMS = 5; 
 13 
 14    // Explain the program's purpose. 
 15    cout << "This program calculates the total" << endl; 
 16    cout << "of " << MAX_NUMS << " numbers." << endl; 
Is there another
number to read?
Read the next number
Add the number to the 
accumulator.
Yes
(True)
No
(False)
Set accumulator to 0
 Figure 4-6  Logic for calculating a running total  

154 
Chapter 4  Repetition Structures
 17 
 18    // Get the numbers and accumulate them. 
 19    for (int counter = 0; counter < MAX_NUMS; counter++) 
 20    { 
 21       cout << "Enter a number: "; 
 22       cin >> number; 
 23       total += number; 
 24    } 
 25 
 26    // Display the total. 
 27    cout << "The total is: " << total << endl; 
 28    return 0; 
 29 } 
 Program Output with Input Shown in Bold 
 This program calculates the total of 5 numbers. 
 Enter a number:  2 [ Enter ] 
 Enter a number:  4 [ Enter ] 
 Enter a number:  6 [ Enter ] 
 Enter a number:  8 [ Enter ] 
 Enter a number:  10 [ Enter ] 
 The total is: 30  
 First, let’s look at the variable declarations. The  number variable, declared in line 8, will be 
used to hold a number entered by the user. The  total variable, declared in line 9, is the 
accumulator. Notice that it is initialized with the value 0. The  for loop, in lines 19 through 
24, does the work of getting the numbers from the user and calculating their total. Line 
21 prompts the user to enter a number, and line 22 gets the user’s input and stores it in 
the  number variable. Then, the following statement in line 23 adds  number to  total : 
 total += number;  
 After this statement executes, the value in the  number variable will be added to the 
value in the  total variable. When the loop finishes, the  total variable will hold the 
sum of all the numbers that were added to it. This value is displayed in line 27. 
 Checkpoint 
 4.18.   A program that calculates the total of a series of numbers typically has what 
two elements?  
 4.19.   What is an accumulator?  
 4.20.   Should an accumulator be initialized to any specific value? Why, or why not?  
 4.21.   Look at the following code. If it were a real program, what would it display? 
 int counter, total = 0; 
 const int MAX = 6; 
 for (int counter = 1; counter < MAX; counter++) 
 { 
   total += counter; 
 } 
 cout << total << endl;  

 
4.6 Nested Loops 
155
 
4.6  Nested Loops 
 CONCEPT:   A loop that is inside another loop is called a nested loop.  
 A nested loop is a loop that is inside another loop. A clock is a good example of some-
thing that works like a nested loop. The second hand, minute hand, and hour hand all 
spin around the face of the clock. The hour hand, however, only makes one revolution 
for every 12 of the minute hand’s revolutions. And it takes 60 revolutions of the second 
hand for the minute hand to make one revolution. This means that for every complete 
revolution of the hour hand, the second hand has revolved 720 times. Here is code with 
a loop that partially simulates a digital clock. It displays the seconds from 0 to 59: 
 const int MAX_SECONDS = 60; 
 for (int seconds = 0; seconds < MAX_SECONDS; seconds++) 
 { 
   cout << seconds << endl; 
 } 
 To count the minutes as well as the seconds, we can nest the preceding loop inside 
another loop that cycles through 60 minutes: 
 const int MAX_SECONDS = 60; 
 const int MAX_MINUTES = 60; 
 for (int minutes = 0; minutes < MAX_MINUTES; minutes++) 
 { 
   for (int seconds = 0; seconds < MAX_SECONDS; seconds++) 
   { 
      cout << minutes << ":" 
           << seconds << endl; 
   } 
 } 
 To make the simulated clock complete, another loop can be added to count the hours: 
 const int MAX_SECONDS = 60; 
 const int MAX_MINUTES = 60; 
 const int MAX_HOURS = 24; 
 for (int hours = 0; hours < MAX_HOURS; hours++) 
 { 
   for (int minutes = 0; minutes < MAX_MINUTES; minutes++) 
   { 
      for (int seconds = 0; seconds < MAX_SECONDS; seconds++) 
      { 
         cout << hours << ":" 
              << minutes << ":" 
              << seconds << endl; 
      } 
   } 
 } 

156 
Chapter 4  Repetition Structures
 If this code were part of a complete program, its output would be: 
 0:0:0 
 0:0:1 
 0:0:2  
 . (The program will count through each second of 24 hours.) 
 . 
 . 
 23:59:59  
 The innermost loop will iterate 60 times for each iteration of the middle loop. The 
middle loop will iterate 60 times for each iteration of the outermost loop. When the 
outermost loop has iterated 24 times, the middle loop will have iterated 1,440 times, 
and the innermost loop will have iterated 86,400 times! 
 The simulated clock example brings up a few points about nested loops: 
 ●  An inner loop goes through all its iterations for every single iteration of an outer 
loop.  
 ●  Inner loops complete their iterations faster than outer loops.  
 ●  To get the total number of iterations of a nested loop, multiply the number of 
iterations of all the loops.  
 In the Spotlight: 
 Using Nested Loops to Print Patterns 
 One interesting way to learn about nested loops is to use them to display patterns on 
the screen. Let’s look at a simple example. Suppose we want to print asterisks on the 
screen in the following rectangular pattern: 
 ****** 
 ****** 
 ****** 
 ****** 
 ****** 
 ****** 
 ****** 
 ******  
 If you think of this pattern as having rows and columns, you can see that it has eight 
rows, and each row has six columns. The following code can be used to display one 
row of asterisks: 
 const int COLS = 6; 
 for (int col = 0; col < COLS; col++) 
 { 
   cout << "*"; 
 } 
 cout << endl;  

 
4.6 Nested Loops 
157
 If we run this code in a program, it will produce the following output: 
 ******  
 To complete the entire pattern, we need to execute this loop eight times. We can place 
the loop inside another loop that iterates eight times, as shown here: 
  1       const int COLS = 6; 
  2      const int ROWS = 8; 
  3      for (int row = 0; row < ROWS; row++) 
  4      { 
  5         for (int col = 0; col < COLS; col++) 
  6          { 
  7             cout << "*"; 
  8          } 
  9          cout << endl; 
 10         } 
 The outer loop iterates eight times. Each time it iterates, the inner loop iterates 
six times. (Notice that in line 9, after each row has been printed, the statement 
 cout << endl;  appears. We have that statement to advance the screen cursor to the 
next line at the end of each row. Without that statement, all the asterisks will be 
printed in one long row on the screen.) 
 We could easily write a program that prompts the user for the number of rows and 
columns, as shown in Program 4-9. 
 Program 4-9  
(RectangularPattern.cpp) 
 1 // This program displays a rectangular pattern 
 2 // of asterisks. 
 3 #include <iostream> 
 4 using namespace std; 
 5 
 6 int main() 
 7 { 
 8    int rows, cols; 
 9 
 10    // Get the number of rows and columns. 
 11    cout << "How many rows? "; 
 12    cin >> rows; 
 13    cout << "How many columns? "; 
 14    cin >> cols; 
 15 
 16    // Display the pattern. 
 17    for (int r = 0; r < rows; r++) 
 18    { 
 19       for (int c = 0; c < cols; c++) 
 20       { 
 21          cout << "*"; 
 22       } 
 23       cout << endl; 

158 
Chapter 4  Repetition Structures
 24     } 
 25    return 0; 
 26 } 
 Program Output with Input Shown in Bold 
 How many rows?  5 [ Enter] 
 How many columns?  10 [Enter] 
 ********** 
 ********** 
 ********** 
 ********** 
 **********  
 Let’s look at another example. Suppose you want to print asterisks in a pattern that 
looks like the following triangle: 
 * 
 ** 
 *** 
 **** 
 ***** 
 ****** 
 ******* 
 ********  
 Once again, think of the pattern as being arranged in rows and columns. The pat-
tern has a total of eight rows. In the first row is one column. In the second row 
are two columns. In the third row are three columns. This continues to the eighth 
row, which has eight columns. Program 4-10 shows the program that produces 
this pattern. 
 Program 4-10 
 (TrianglePattern.cpp) 
 1 // This program displays a triangle pattern. 
 2 #include <iostream> 
 3 using namespace std; 
 4 
 5 int main() 
 6 { 
 7    const int BASE_SIZE = 8; 
 8       
 9    for (int r = 0; r < BASE_SIZE; r++) 
 10    { 
 11       for (int c = 0; c < (r+1); c++) 
 12       { 
 13          cout << "*"; 
 14       } 

 
4.6 Nested Loops 
159
 15       cout << endl; 
 16    } 
 17    return 0; 
 18 } 
 Program Output 
 * 
 ** 
 *** 
 **** 
 ***** 
 ****** 
 ******* 
 ********  
 The outer loop (which begins in line 9) will iterate 8 times. As the loop iterates, the 
variable  r  will be assigned the values 0 through 7. 
 For each iteration of the outer loop, the inner loop will iterate  r+1 times. So, 
 •  During the outer loop’s 1st iteration, the variable  r is assigned 0. The inner loop 
iterates one time, printing one asterisk.  
 •  During the outer loop’s 2nd iteration, the variable  r is assigned 1. The inner loop 
iterates two times, printing two asterisks.  
 •  During the outer loop’s 3rd iteration, the variable  r is assigned 2. The inner loop 
iterates three times, printing three asterisks.  
 •  And so forth.  
 Let’s look at another example. Suppose you want to display the following stair-step 
pattern: 
 # 
 # 
  # 
   # 
    # 
     #  
 The pattern has six rows. In general, we can describe each row as having some num-
ber of spaces followed by a  # character. Here’s a row-by-row description: 
 First row: 
0 spaces followed by a # character. 
 Second row: 
1 space followed by a # character. 
 Third row:  
2 spaces followed by a # character. 
 Fourth row:  
3 spaces followed by a # character. 
 Fifth row:  
4 spaces followed by a # character. 
 Sixth row:  
5 spaces followed by a # character.  

160 
Chapter 4  Repetition Structures
 To display this pattern, we can write code containing a pair of nested loops that work 
in the following manner: 
 •  The outer loop will iterate six times. Each iteration will perform the following: 
 •  The inner loop will display the correct number of spaces, side-by-side.  
 •  Then, a  # character will be displayed.  
 Program 4-11 shows the C++ code. 
 Program 4-11 
 (StairStepPattern.cpp) 
 1 // This program displays a stair-step pattern. 
 2 #include <iostream> 
 3 using namespace std; 
 4 
 5 int main() 
 6 { 
 7    const int NUM_STEPS = 6; 
 8       
 9    for (int r = 0; r < NUM_STEPS; r++) 
 10    { 
 11       for (int c = 0; c < r; c++) 
 12       { 
 13         cout << " "; 
 14       } 
 15       cout << "#" << endl; 
 16    } 
 17    return 0; 
 18 } 
 Program Output 
 # 
 # 
  # 
   # 
    # 
     #  
 The outer loop (which begins in line 9) will iterate six times. As the loop iterates, the 
variable  r will be assigned the values 0 through 5. 
 For each iteration of the outer loop, the inner loop will iterate  r times. So, 
 •  During the outer loop’s 1st iteration, the variable  r is assigned 0. The inner loop 
will not execute at this time.  
 •  During the outer loop’s 2nd iteration, the variable  r is assigned 1. The inner loop 
iterates one time, printing one space.  
 •  During the outer loop’s 3rd iteration, the variable  r is assigned 2. The inner loop 
iterates two times, printing two spaces.  
 •  And so forth.  

 
Review Questions 
161
 Review Questions 
 Multiple Choice  
 
1.   A _____-controlled loop uses a true/false condition to control the number of times 
that it repeats.  
 a.  Boolean 
 b.   condition 
 c.  decision 
 d.   count 
 
2.   A _____-controlled loop repeats a specific number of times.  
 a.  Boolean 
 b.   condition 
 c.  decision 
 d.   count 
 
3.   Each repetition of a loop is known as a(n) _____.  
 a.  cycle  
 b.   revolution 
 c.  orbit 
 d.  iteration  
 
4.  The  while loop is a _____ type of loop.  
 a.  pretest  
 b.  no-test  
 c.  prequalified  
 d.  posttest  
 
5.  The  do - while loop is a _____ type of loop.  
 a.  pretest  
 b.  no-test  
 c.  prequalified  
 d.  posttest  
 
6.  A(n) _____ loop has no way of ending and repeats until the program is interrupted.  
 a.  indeterminate  
 b.  interminable  
 c.   infinite  
 d.  timeless  
 
7.  This type of loop always executes at least once:  
 a.  pretest.  
 b.  posttest.  
 c.  condition-controlled.  
 d.   count-controlled.  
 
8.   This is a variable that keeps a running total:  
 a.  sentinel.  
 b.  sum. 
 c.  total. 
 d.   accumulator.  

162 
Chapter 4 
 Repetition Structures
 
9.  The expression  x++ uses the increment operator in _____ mode.  
 a.  automatic  
 b.  prefix 
 c.  postfix 
 d.  infix 
 True or False  
 
1.  A condition-controlled loop always repeats a specific number of times.  
 
2.  The  while loop is a pretest loop.  
 
3.  An infinite loop will automatically stop after 256 seconds.  
 
3.  The  do - while loop is a pretest loop.  
 
4.  You should not write code that modifies the contents of the counter variable in 
the body of a  for loop. 
 
5.  You cannot display the contents of the counter variable in the body of a loop.  
 
6.  It is not possible to increment a counter variable by any value other than 1.  
 
7.  The  ++ operator adds 2 to its operand.  
 
8.  It is not necessary to initialize accumulator variables.  
 
9.  In a nested loop, the inner loop goes through all its iterations for every single 
iteration of the outer loop.  
 
10.  To calculate the total number of iterations of a nested loop, add the number of 
iterations of all the loops.  
 Short Answer  
 
1.  What is a condition-controlled loop?  
 
2.   What is a count-controlled loop?  
 
3.  What is an infinite loop? Write the code for an infinite loop.  
 
4.   Describe the difference between pretest loops and posttest loops.  
 
5.   What three actions do count-controlled loops typically perform using the counter 
variable?  
 
6.   Why is it critical that accumulator variables are properly initialized?  
 
7.   What would the following code sample display? 
 int number = 9; 
 number++; 
 cout << number << endl; 
 number--; 
 cout << number << endl;  

 
Programming Exercises 
163
 Algorithm Workbench  
 
1.   Write a  while loop that lets the user enter a number. The number should be multi-
plied by 10 and the result assigned to a variable named  product . The loop should 
iterate as long as  product is less than 100. 
 
2.   Write a  while loop that asks the user to enter two numbers. The numbers should be 
added and the sum displayed. The loop should ask the user if he or she wishes to per-
form the operation again. If so, the loop should repeat; otherwise, it should terminate.  
 
3.   Write a  for loop that displays the following set of numbers: 
 0, 10, 20, 30, 40, 50 . . . 1000  
 
4.   Design a loop that asks the user to enter a number. The loop should iterate 10 
times and keep a running total of the numbers entered.  
 
5.   Write a  for loop that calculates the total of the following series of numbers: 
 1
30 + 2
29 + 3
28 + . . . 30
1  
 
6.   Write a set of nested loops that displays 10 rows of ‘#’ characters. There should 
be 15 ‘#’ characters in each row.  
 
7.   Convert the  while loop in the following code to a  do - while loop: 
 int x = 1; 
 while (x > 0) 
 { 
   cout << "Enter a number: "; 
   cin >> x; 
 } 
 Programming Exercises 
 
1.   Bug Collector 
 A bug collector collects bugs every day for seven days. Write a program that 
keeps a running total of the number of bugs collected during the seven days. The 
loop should ask for the number of bugs collected for each day, and when the loop 
is finished, the program should display the total number of bugs  collected.  
 
2.   Calories Burned 
 Running on a particular treadmill, you burn 3.9 calories per minute. Write a 
program that uses a loop to display the number of calories burned after 10, 15, 
20, 25, and 30 minutes.  
 
3.   Ocean Levels 
 Assuming the ocean’s level is currently rising at about 1.5 millimeters per year, 
write a program that displays a table showing the number of millimeters that the 
ocean will rise each year for the next 25 years.  
 
4.   Budget Analysis 
 Write a program that asks the user to enter the amount that he or she has 
budgeted for a month. A loop should then prompt the user to enter each 
VideoNote
Solving the Calories 
Burned Problem

164 
Chapter 4 
 Repetition Structures
of his or her expenses for the month and keep a running total. When the 
loop finishes, the program should display the amount that the user is over 
or under budget.   
 
5.   Distance Traveled 
 The distance a vehicle travels can be calculated as follows: 
 Distance = Speed × Time 
 For example, if a train travels 40 miles per hour for three hours, the distance trav-
eled is 120 miles. Write a program that asks the user for the speed of a vehicle (in 
miles per hour) and the number of hours it has traveled. It should then use a loop 
to display the distance the vehicle has traveled for each hour of that time period. 
Here is an example of the output: 
 What is the speed of the vehicle in mph?  40 [ Enter ] 
 How many hours has it traveled?  3 [ Enter ] 
 Hour 
 Distance Traveled 
 1 
 40 
 2 
 80 
 3 
 120 
 
6.  Average Rainfall 
 Write a program that uses nested loops to collect data and calculate the average 
rainfall over a period of years. The program should first ask for the number of 
years. The outer loop will iterate once for each year. The inner loop will iterate 
twelve times, once for each month. Each iteration of the inner loop will ask the 
user for the inches of rainfall for that month. After all iterations, the program 
should display the number of months, the total inches of rainfall, and the average 
rainfall per month for the entire period.  
 
7.  Centigrade to Fahrenheit Table 
 Write a program that displays a table of the centigrade temperatures 0 through 
20 and their Fahrenheit equivalents. The formula for converting a temperature 
from centigrade to Fahrenheit is 
 F = 9
5 C + 32  
 where  F is the Fahrenheit temperature and  C is the centigrade temperature. Your 
program must use a loop to display the table.  
 
8.   Pennies for Pay 
 Write a program that calculates the amount of money a person would earn over 
a period of time if his or her salary is one penny the first day, two pennies the 
second day, and continues to double each day. The program should ask the user 
for the number of days. Display a table showing what the salary was for each 
day, and then show the total pay at the end of the period. The output should be 
displayed in a dollar amount, not the number of pennies.  
 
9.   Square Display 
 Write a program that asks the user for a positive integer no greater than 15. The 
program should then display a square on the screen using the character  X . The 

 
Programming Exercises 
165
number entered by the user will be the length of each side of the square. For 
example, if the user enters 5, the program should display the following: 
 XXXXX 
 XXXXX 
 XXXXX 
 XXXXX 
 XXXXX  
 If the user enters 8, the program should display the following: 
 XXXXXXXX 
 XXXXXXXX 
 XXXXXXXX 
 XXXXXXXX 
 XXXXXXXX 
 XXXXXXXX 
 XXXXXXXX 
 XXXXXXXX  
 
10.   Pattern Displays 
 Write a program that uses a loop to display Pattern A as follows, followed by 
another loop that displays Pattern B. 
 Pattern A 
 Pattern B 
 + 
 ++++++++++ 
 ++ 
 +++++++++ 
 +++ 
 ++++++++ 
 ++++ 
 +++++++ 
 +++++ 
 ++++++ 
 ++++++ 
 +++++ 
 +++++++ 
 ++++ 
 ++++++++ 
 +++ 
 +++++++++ 
 ++ 
 ++++++++++ 
 + 

This page intentionally left blank 

167
 
5.1  Introduction to Functions 
 CONCEPT:   A function is a group of statements that exist within a program for the 
purpose of performing a specific task.  
 In  Chapter   2 you saw a simple algorithm for calculating an employee’s pay (Program 
2-10).  In  the  program , the number of hours worked is multiplied by an hourly pay 
rate. A more realistic payroll algorithm, however, would do much more than this. In 
a real-world application, the overall task of calculating an employee’s pay would 
consist of several subtasks, such as the following: 
 ●  Getting the employee’s hourly pay rate  
 ●  Getting the number of hours worked  
 ●  Calculating the employee’s gross pay  
 ●  Calculating overtime pay  
 ●  Calculating withholdings for taxes and benefits  
 ●  Calculating the net pay  
 ●  Printing the paycheck  
 Most programs perform tasks that are large enough to be broken down into several 
subtasks. For this reason, programmers usually break down their programs into small 
manageable pieces known as functions. A  function is a group of statements that exist 
within a program for the purpose of performing a specific task. Instead of writing a 
 5.1  Introduction to Functions   
 5.2   void Functions   
 5.3  Local Variables  
 5.4  Passing Arguments to Functions   
 5.5  Global Variables and Global Constants   
 5.6  Value-Returning Functions   
 5.7  Calling  string Class Member 
Functions   
 TOPICS 
 Functions 
5 
 CHAPTER

168 
Chapter 5 
 Functions
large program as one long sequence of statements, it can be written as several small 
functions, each one performing a specific part of the task. These small functions can 
then be executed in the desired order to perform the overall task. 
 This approach is sometimes called  divide and conquer because a large task is divided 
into several smaller tasks that are easily performed.  Figure   5-1 illustrates this idea by 
comparing two programs: one that performs a task with a long sequence of statements 
in the  main function, and another that divides the task into smaller tasks, each of 
which is performed by a separate function. 
int main()
{
   statement;
   statement;
   statement;
   statement;
   statement;
   statement;
   statement;
   statement;
   statement;
   statement;
   statement;
   statement;
   statement;
   statement;
   statement;
   statement;
   statement;
   statement;
   statement;
   statement;
   statement;
   statement;
   statement;
   statement;
   return 0;
}
This program performs one long 
sequence of statements in the main 
function.
In this program the task has been 
divided into smaller tasks, each of which 
is performed by a separate function.
int main()
{
   statement;
   statement;
   statement;
   return 0;
}
function
void function2()
{
   statement;
   statement;
   statement;
}
function
void function3()
{
   statement;
   statement;
   statement;
}
function
 Figure 5-1  Using functions to divide and conquer a large task  
 When using functions in a program, you generally isolate each task within the pro-
gram in its own function. For example, a realistic pay calculating program might have 
the following functions: 
 ●  A function that gets the employee’s hourly pay rate  
 ●  A function that gets the number of hours worked  
 ●  A function that calculates the employee’s gross pay  

 
5.2 void Functions 
169
 ●  A function that calculates the overtime pay  
 ●  A function that calculates the withholdings for taxes and benefits  
 ●  A function that calculates the net pay  
 ●  A function that prints the paycheck  
 A program that has been written with each task in its own function is called a  modu-
larized program. 
 In general terms, a program that is broken into smaller units of code, such as 
functions, is known as a  modularized program . Modularization tends to simplify 
code. If a specific task is performed in several places in a program, a function can 
be written once to perform that task and then be executed any time it is needed. 
This benefit of using functions is known as  code reuse because you are writing 
the code to perform a task once and then reusing it each time you need to per-
form the task. 
 void Functions and Value-Returning Functions 
 In this chapter you will learn to write two types of functions:  void functions and 
value-returning functions. When you call a   void function , it simply executes the 
statements it contains and then terminates. When you call a  value-returning func-
tion , it executes the statements that it contains and then it returns a value to the 
statement that called it. The  pow function  that you saw in  Chapter   2 is an example 
of a value-returning function. The first type of function that you will learn to write 
is the  void function.  
 
5.2  void Functions 
 CONCEPT:    A  void function performs a task and then terminates. It does not 
return a value to the statement that called it.  
 To create a function you write its definition. A function definition has two parts: a 
header and a body. The  function header , which appears at the beginning of a function 
definition, lists several important things about the function, including the function’s 
name. The  function body is a collection of statements that are performed when the 
function is executed. These statements are enclosed inside a set of curly braces. Here 
is an example of a function definition: 
 void displayMessage() 
 { 
    cout << "This is the displayMessage function." << endl; 
 } 
 The Function Header 
 Using the previously shown function definition,  Figure   5-2 points out the different 
parts of the function header, which is the first line.  

170 
Chapter 5 
 Functions
 Let’s take a closer look at the parts identified in the figure: 
 ●  Return type —Recall our previous discussion of  void and value-returning func-
tions. When the key word  void appears here, it means that the function is a  void 
function and does not return a value. As you will see later in this chapter, a 
value-returning function lists a data type here.  
 ●  Function name —You should give each function a descriptive name. In general, 
the same rules that apply to variable names also apply to function names. The 
function in this example is named  displayMessage , so we can easily guess what 
the function does: it displays a message.  
 ●  Parentheses —In the header, the function name is always followed by a set of 
parentheses. As you will see later in this chapter, you sometimes write declara-
tions inside the parentheses, but for now, the parentheses will be empty.  
void displayMessage()
{
    cout << "This is the displayMessage function." << endl;
}
Return
type
Function
name
Parentheses
 Figure 5-2  Parts of the function header  
 NOTE:    The function header is never terminated with a semicolon. 
 The Function Body 
 Beginning at the line after the function header, one or more statements will appear 
inside a set of curly braces ( { } ). These statements are the function’s body and are 
performed any time the function is executed. 
 When you write a function definition, Visual Studio automatically indents the state-
ments in the function body. The indentation is not required, but it makes the code 
easier to read and debug. By indenting the statements in the body of the function, you 
visually set them apart from the surrounding code. This allows you to tell at a glance 
what part of the program is part of the function.  
 Calling a Function 
 A function executes when it is called. When a function is called, the program branches 
to that function and executes the statements in its body. Here is an example of a state-
ment that calls the  displayMessage function we previously examined: 
 displayMessage();  
 The statement is simply the name of the function followed by a set of parentheses. 
Because it is a complete statement, it is terminated with a semicolon. Program 5-1 
shows a complete program that uses the  displayMessage function. 

 Program 5-1 
 (SimpleFunction.cpp)  
 1 #include <iostream> 
 2 using namespace std; 
 3  
 4 // Definition of the displayMessage function 
 5 void displayMessage() 
 6 { 
 7    cout << "This is the displayMessage function." << endl; 
 8 } 
 9  
 10 // Definition of the main function 
 11 int main() 
 12 { 
 13    cout << "This is the main function." << endl; 
 14    displayMessage(); 
 15    cout << "Back in the main function." << endl; 
 16    return 0; 
 17 } 
 Program Output 
 This is the main function. 
 This is the displayMessage function. 
 Back in the main function.  
 Let’s step through this program. When the program runs, it begins executing in the 
 main function, which starts in line 11. Line 13 displays  This is the main function. , and 
then line 14 calls the  displayMessage function. As shown in  Figure   5-3 , the program 
jumps to the  displayMessage function and executes the statements in its body. Only 
one statement is in the body of the  displayMessage function, which is line 7. This 
statement displays  This is the displayMessage function ., and then the function ends. 
#include <iostream>
using namespace std;
// Definition of the displayMessage function
void displayMessage()
{
 
cout << "This is the displayMessage function." << endl;
}
// Definition of the main function
int main()
{
 
cout << "This is the main function." << endl;
 
displayMessage();
 
cout << "Back in the main function." << endl;
 
return 0;
}
The program jumps to the
displayMessage function
and executes the statements
in its body.
 Figure 5-3  Calling the  displayMessage function  
 
5.2 void Functions 
171

172 
Chapter 5 
 Functions
As shown in  Figure   5-4 , the program jumps back to the part of the program that 
called the  displayMessage function and resumes execution from that point. In this 
case, the program resumes execution at line 15, which displays  Back in the main func-
tion . The  main function ends at line 17.  
#include <iostream>
using namespace std;
// Definition of the displayMessage function
void displayMessage()
{
 
cout << "This is the displayMessage function." << endl;
}
// Definition of the main function
int main()
{
 
cout << "This is the main function." << endl;
 
displayMessage();
 
cout << "Back in the main function." << endl;
 
return 0;
}
When the displayMessage function
ends, the program returns to the part
of the program that called it, and
resumes execution at that point.
 Figure 5-4  The  displayMessage function returns  
 When a function is called, some operations are performed “behind the scenes” so the 
system will know where the program should return after the function ends. First, the 
system saves the memory address of the location where it should return. This is typi-
cally the statement that appears immediately after the function call. This memory 
location is known as the  return point . Then, the system jumps to the function and 
executes the statements in its body. When the function ends, the system jumps back to 
the return point and resumes execution.  
 NOTE:   When a program calls a function, programmers commonly say that the 
 control of the program transfers to that function. This simply means that the func-
tion takes control of the program’s execution. 
 Function Prototypes 
 Before the compiler encounters a call to a particular function, it must already know 
the function’s return type, the number of parameters it uses, and the type of each 
parameter. (You will learn how to use parameters in the next section.) 
 One way of ensuring that the compiler has this information is to place the function 
definition before all calls to that function. This was the approach taken in Program 
5-1. A more common technique, however, is to write a function prototype near the 
top of the program. A  function prototype is a statement that declares the existence 
of a function, but does not define the function. It is a way of telling the compiler 

that a particular function exists in the program and that its definition appears at a 
later point. The function prototype for the  displayMessage function in Program 5-1 
would look like this: 
 void displayMessage();  
 The prototype looks similar to the function header, except a semicolon is at the end. 
Program 5-2 shows how a function prototype is typically used. In this program, the 
prototype for the  displayMessage function appears in line 5. The definition of the 
 main function appears next, in lines 8 through 14, and then the definition of the 
 displayMessage function appears in lines 17 through 20.  
 Program 5-2 
 (FunctionPrototype.cpp)  
 1 #include <iostream> 
 2 using namespace std; 
 3  
 4 // Function prototype 
 5 void displayMessage(); 
 6  
 7 // Definition of the main function 
 8 int main() 
 9 { 
 10    cout << "This is the main function." << endl; 
 11    displayMessage(); 
 12    cout << "Back in the main function." << endl; 
 13    return 0; 
 14 } 
 15  
 16 // Definition of the displayMessage function 
 17 void displayMessage() 
 18 { 
 19    cout << "This is the displayMessage function." << endl; 
 20 } 
 Program Output 
 This is the main function. 
 This is the displayMessage function. 
 Back in the main function.  
 NOTE:   You must place either the function definition or the function prototype 
ahead of all calls to the function. Otherwise the program will not compile. 
 Top-Down Design 
 In this section, we have discussed and demonstrated how functions work. You’ve seen 
how the program jumps to a function when it is called and returns to the part of the 
program that called the function when the function ends. It is important to under-
stand these mechanical aspects of functions. 
 
5.2 void Functions 
173

174 
Chapter 5 
 Functions
 Just as important as understanding how functions work is understanding how to use 
functions to modularize a program. Programmers commonly use a technique known 
as  top-down design to break down an algorithm into functions. The process of top-
down design is performed in the following manner: 
 ●  The overall task that the program is to perform is broken down into a series of 
subtasks.  
 ●  Each of the subtasks is examined to determine whether it can be further broken 
down into more subtasks. This step is repeated until no more subtasks can 
be identified.  
 ●  Once all the subtasks have been identified, they are written in code.  
 This process is called top-down design because the programmer begins by looking at 
the topmost level of tasks that must be performed, and then breaks down those tasks 
into lower levels of subtasks.  
 NOTE:    The top-down design process is sometimes called  stepwise refinement . 
 Checkpoint 
 5.1.  What is the difference between a  void function and a value-returning function?  
 5.2.  What two parts does a function definition have?  
 5.3.  What does the phrase “calling a function” mean?  
 5.4.  When a  void function is executing, what happens when the end of the function 
is reached?  
 5.5.  Describe the steps involved in the top-down design process.  
 
5.3  Local Variables 
 CONCEPT:   A local variable is a variable that is declared inside a function. A 
local variable cannot be accessed by statements that are outside 
the function. Different functions can have local variables with the 
same names because the functions cannot see each other’s local 
variables.  
 A variable that is declared inside a function is called a  local variable . A local variable 
belongs to the function in which it is declared, and only statements inside that func-
tion can access the variable. (The term  local is meant to indicate that the variable can 
be used only locally, within the function in which it is declared.) An error will occur 
if a statement in one function tries to access a local variable that belongs to another 
function. For example, look at the following code:  

 
5.3 Local Variables 
175
 First, look at the  getName function, and notice that the  name object is declared in inside 
the  getName function. Because it is declared inside the  getName function, it is local to 
that function. The  getName function prompts the user to enter his or her name, and 
the  cin statement stores the user’s input in the  name object. 
 Now look at the  main function. It calls the  getName function, and then the  cout state-
ment tries to access the  name object. This causes a compiler error because the  name 
object is local to the  getName function, and statements in the  main function cannot 
access it. 
 Scope and Local Variables 
 Programmers commonly use the term  scope to describe the part of a program in 
which a variable may be accessed. A variable is visible only to statements inside the 
variable’s scope. 
 A local variable’s scope begins at the variable’s declaration and ends at the end of the 
function in which the variable is declared. The variable cannot be accessed by state-
ments that are outside this region. This means that a local variable cannot be accessed 
by code that is outside the function or inside the function but before the variable’s 
declaration. For example, look at the following code. It has an error because the  cin 
statement tries to store a value in the  age variable, but the statement is outside the 
variable’s scope. Moving the variable declaration to a line before the  cin statement 
will fix this error.  
// This program has an error!
#include <iostream>
#include <string>
using namespace std;
// Function prototype
void getName();
// Definition of main function
int main()
{
   getName();
   cout << "Hello " << name << endl;
}
// Definition of getName function
void getName()
{
   string name;
   cout << "Enter your first name: ";
   cin >> name;
}
name is local to
the getName function.
This will cause an error because
name is not accessible to the
main function.
 
void getAge()
{
   cout << "Enter your age: ";
   cin >> age;
   int age;
}
This statement will cause an error because
the age variable has not been declared yet.
 

176 
Chapter 5 
 Functions
 Duplicate Variable Names 
 You cannot have two variables with the same name in the same scope. For example, 
look at the following function:  
void getTwoAges()
{
   int age;
   cout << "Enter your age: ";
   cin >> age;
   
   int age;
   cout << "Enter your pet’s age: ";
   cin >> age;
}
This will cause an error because
the age variable has already 
been declared.
 
 This  getTwoAges function declares two local variables named  age . The second variable 
declaration will cause an error because a variable named  age has already been declared 
in the function. Renaming one of the variables will fix this error.  
 TIP:   You cannot have two variables with the same name in the same function 
because the compiler would not know which variable to use when a statement tries 
to access one of them. All variables that exist within the same scope must have 
unique names. 
 Although you cannot have two local variables with the same name in the same func-
tion, it is okay for a local variable in one function to have the same name as a local 
variable in a different function. For example, suppose a program has two functions: 
 getPersonAge and  getPetAge . It would be legal for both functions to have a local vari-
able named  age . 
 Checkpoint 
 5.6.  What is a local variable? How is access to a local variable restricted?  
 5.7.  What is a variable’s scope?  
 5.8.  Is it permissible to have more than one variable with the same name in the 
same scope? Why or why not?  
 5.9.  Is it permissible for a local variable in one function to have the same name as 
a local variable in a different function?  
 
5.4  Passing Arguments to Functions 
 CONCEPT:   An argument is any piece of data that is passed into a function when 
the function is called. A parameter is a variable that receives an argu-
ment that is passed into a function.  

 
5.4 Passing Arguments to Functions 
177
 Sometimes it is necessary to send one or more pieces of data into a function when you 
call the function. Pieces of data that are sent into a function are known as  arguments . 
The function can use its arguments in calculations or other operations. 
 If you want a function to receive arguments when it is called, you must equip the 
function with one or more parameter variables. A  parameter variable , often simply 
called a  parameter , is a special variable that is assigned the value of an argument when 
a function is called. Here is an example of a function that has a parameter variable: 
 void showDouble(int number) 
 { 
   int result = number * 2; 
   cout << result << endl; 
 } 
 This function’s name is  showDouble . Its purpose is to accept an integer as an argument 
and display the value of that integer doubled. Look at the function header and notice 
the words  int number that appear inside the parentheses. This is the declaration of a 
parameter variable. The parameter variable’s name is  number , and its data type is  int . 
The purpose of this variable is to receive an int argument when the function is called. 
Program 5-3 demonstrates the function in a complete program. 
 Program 5-3 
 (PassArgument.cpp)  
 1 #include <iostream> 
 2 using namespace std; 
 3  
 4 // Function prototype 
 5 void doubleNumber(int); 
 6  
 7 // Definition of the main function 
 8 int main() 
 9 { 
 10    doubleNumber(4); 
 11    return 0; 
 12 } 
 13  
 14 // Definition of the doubleNumber function 
 15 void doubleNumber(int number) 
 16 { 
 17    int result = number *2; 
 18    cout << result << endl; 
 19 } 
 Program Output 
 8 
 First, notice the function prototype for  doubleNumber in line 5: 
 void doubleNumber(int);  

178 
Chapter 5 
 Functions
 In the function prototype, it is not necessary to list the name of the parameter variable 
inside the parentheses. Only its data type is required. This function prototype could 
optionally have been written as: 
 void doubleNumber(int number);  
 However, the compiler ignores the name of the parameter variable in the function 
prototype. 
 When this program runs, the  main function will begin executing. The statement in line 
10 calls the  doubleNumber function. Notice that the number 4 appears inside the 
parentheses. This is an argument that is being passed to the  doubleNumber function. 
When this statement executes, the  doubleNumber function will be called with the value 
4 copied into the  number parameter variable. This is shown in  Figure  5-5 . 
int main()
{
   doubleNumber(4)
   return 0;
}
void doubleNumber(int number)
{
   int result = number * 2;
   cout << result << endl;
}
The argument 4 is copied into
the number parameter variable.
 Figure 5-5  The argument 4 is copied into the  number parameter variable  
 Let’s step through the  doubleNumber function. As we do, remember that the  number 
parameter variable will be assigned the value that was passed to it as an argument. In 
this program, that number is 4. 
 Line 17 declares a local variable named  result and initializes the  result variable 
with the value of the expression  number * 2 . Because the  number parameter is 
assigned the value 4, this statement assigns 8 to  result . Line 18 displays the  result 
variable. 
 You can also pass the contents of a variable as an argument. For example, look at 
Program 5-4. The  main function declares an  int variable named  value in line 10. Line 
12 prompts the user to enter a number, and line 13 reads the user’s input into the 
 value variable. Notice that in line 14  value is passed as an argument to the  doubleNumber 
function, which causes the  value variable’s contents to be copied into the  number 
parameter variable. This is shown in  Figure   5-6 . 
 Program 5-4 
 (PassVariable.cpp)  
 1 #include <iostream> 
 2 using namespace std; 
 3  
 4 // Function prototype 
 5 void doubleNumber(int); 
 6  

 
5.4 Passing Arguments to Functions 
179
 7 // Definition of the main function 
 8 int main() 
 9 { 
 10    int value; 
 11  
 12    cout << "Enter a value and I will double it: "; 
 13    cin >> value; 
 14    doubleNumber(value); 
 15    return 0; 
 16 } 
 17  
 18 // Definition of the doubleNumber function 
 19 void doubleNumber(int number) 
 20 { 
 21    int result = number *2; 
 22    cout << result << endl; 
 23 } 
 Program Output with Input Shown in Bold 
 Enter a value and I will double it:  5 [ Enter ] 
 10  
int main()
{
int value;
cout << "Enter a value and I will double it: ";
cin >> value;
doubleNumber(value);
return 0;
}
void doubleNumber(int number)
{
  int result = number * 2;
  cout << result << endl;
}
The contents of the value 
variable are assigned to the
number parameter variable.
5
 Figure 5-6  The  value variable is passed into the  number parameter variable  
 WARNING!    When passing a variable as an argument, simply write the variable 
name inside the parentheses of the function call. Do not write the data type of the 
argument variable in the function call. For example, the following function call will 
cause an error: 
 doubleNumber(int x);    // Error!  
 The function call should appear as 
 doubleNumber(x);        // Correct  

180 
Chapter 5 
 Functions
 Parameter Variable Scope 
 Earlier in this chapter, you learned that a variable’s scope is the part of the program 
in which the variable may be accessed. A variable is visible only to statements inside 
the variable’s scope. A parameter variable’s scope is the function in which the param-
eter is used. All the statements inside the function can access the parameter variable, 
but no statement outside the function can access it.  
 Passing Multiple Arguments 
 Often it is useful to write functions that can accept multiple arguments. Program 5-5 
shows a function named  showSum that accepts two arguments. The function adds the 
two arguments and displays their sum. 
 Program 5-5 
 (TwoArgs.cpp)  
 1 #include <iostream> 
 2 using namespace std; 
 3  
 4 // Function prototype 
 5 void showSum(int, int); 
 6  
 7 // Definition of the main function 
 8 int main() 
 9 { 
 10    cout << "The sum of 12 and 45 is:" << endl; 
 11    showSum(12, 45); 
 12    return 0; 
 13 } 
 14  
 15 // Definition of the showSum function 
 16 void showSum(int num1, int num2) 
 17 { 
 18    int result = num1 + num2; 
 19    cout << result << endl; 
 20 } 
 Program Output 
 The sum of 12 and 45 is: 
 57  
 NOTE:    If you pass an argument whose type is not the same as the parameter’s type, 
the argument will be promoted or demoted automatically. For instance, the argument in 
the following function call would be truncated, causing the value 4 to be passed to num: 
 doubleNumber(4.7);  
 It is worth mentioning that the compiler will warn you that this function call could result 
in a possible loss of data. However, the program will still be compiled and will execute. 

 
5.4 Passing Arguments to Functions 
181
 Notice in line 16 that two parameter variables,  num1 and  num2 , are declared inside the 
parentheses in the  showSum function header. This is often referred to as a  parameter 
list . Also notice that a comma separates the declarations. Also notice in line 5 that the 
function prototype shows the data type for each parameter. 
 The statement in line 11 calls the  showSum function and passes two arguments: 12 and 
45. The arguments are passed into the parameter variables in the order that they 
appear in the function call. In other words, the first argument is passed into the first 
parameter variable, and the second argument is passed into the second parameter 
variable. So, this statement causes 12 to be passed into the  num1 parameter and 45 to 
be passed into the  num2 parameter, as shown in  Figure   5-7 . 
int main()
{
   cout << "The sum of 12 and 45 is:" << endl;
   showSum(12, 45);
   return 0;
}
void showSum(int num1, int num2)
{
   int result = num1 + num2;
   cout << result << endl;
}
 Figure 5-7  Two arguments passed into two parameters  
 Suppose we were to reverse the order in which the arguments are listed in the function 
call, as shown here: 
 showSum(45, 12);  
 This would cause 45 to be passed into the  num1 parameter and 12 to be passed into 
the  num2 parameter. The following code snippet shows one more example. This time 
we are passing variables as arguments. 
 int value1 = 2; 
 int value2 = 3; 
 showSum(value1, value2);  
 When the  showSum function executes as a result of this code, the  num1 parameter will 
contain 2, and the  num2 parameter will contain 3.  
 NOTE:   In a function header, you have to write the data type for each parameter 
variable that is declared in a parameter list. For example, a compiler error would 
occur if the parameter list for the  showSum function were written as shown here: 
 void showSum(int num1, num2) // Error!  
 A data type for both the  num1 and  num2 parameter variables must be listed, as shown here: 
 void showSum(int num1, int num2)  

182 
Chapter 5 
 Functions
 Passing Arguments by Value 
 All of the example programs that you have looked at so far pass arguments by value. 
Arguments and parameter variables are separate items in memory. When an argument 
is  passed by value , only a copy of the argument’s value is passed into the parameter 
variable. If the contents of the parameter variable are changed inside the function, it 
has no effect on the argument in the calling part of the program. For example, look 
at Program 5-6. 
 Program 5-6 
 (PassByValue.cpp)  
 1 #include <iostream> 
 2 using namespace std; 
 3  
 4 // Function Prototype 
 5 void changeMe(int); 
 6  
 7 int main() 
 8 { 
 9    int number = 99; 
 10  
 11    // Display the value in number. 
 12    cout << "In main, number is " << number << endl; 
 13     
 14    // Call changeMe, passing the value in number 
 15    // as an argument. 
 16    changeMe(number); 
 17     
 18    // Display the value in number again. 
 19    cout << "Now back in main again." << endl; 
 20    cout << "The number variable is " << number << endl; 
 21    return 0; 
 22 } 
 23  
 24 // Definition of the changeMe function 
 25 void changeMe(int myValue) 
 26 { 
 27    // Change the value of myValue to 0. 
 28    myValue = 0; 
 29     
 30    // Display the value in myValue. 
 31    cout << "In changeMe, the value is " << myValue << endl; 
 32 } 
 Program Output 
 In main, number is 99 
 In changeMe, the value is 0 
 Now back in main again. 
 The number variable is 12  

 
5.4 Passing Arguments to Functions 
183
 The  main function declares a local variable named  number in line 9 and initializes it to 
the value 99. As a result, the  cout statement in line 12 displays “In main, number is 
99.” The  number variable’s value is then passed as an argument to the  changeMe func-
tion in line 16. This means that in the  changeMe function, the value 99 will be copied 
into the  myValue parameter variable. 
 Inside the  changeMe function, in line 28, the  myValue parameter variable is set to 0. As 
a result, the  cout statement in line 31 displays “In changeMe, the value is 0.” The func-
tion ends, and control of the program returns to the  main function. The next statements 
to execute are the  cout statements in lines 19 and 20. The statement in line 20 displays 
“The number variable is 99.” Even though the  myValue parameter variable was changed 
in the  changeMe function, the argument (the  number variable in  main ) was not modified. 
 Passing an argument is a way that one function can communicate with another func-
tion. When the argument is passed by value, the communication channel works in only 
one direction: the calling function can communicate with the called function. The called 
function, however, cannot use the argument to communicate with the calling function.  
 Passing Arguments by Reference 
 Passing an argument  by reference means that the argument is passed into a special 
type of parameter known as a  reference variable . When a reference variable is used as 
a parameter in a function, it allows the function to modify the argument in the calling 
part of the program. 
 A reference variable acts as an alias for the variable that was passed into it as an argument. 
It is called a reference variable because it references the other variable. Anything that you 
do to the reference variable is actually done to the variable it references. Reference vari-
ables are useful for establishing two-way communication between functions. 
 When a function calls another function and passes a variable by reference, communi-
cation between the functions can take place in the following ways: 
 ●  The calling function can communicate with the called function by passing an 
argument.  
 ●  The called function can communicate with the calling function by modifying the 
value of the argument via the reference variable.  
 Reference variables are declared like regular variables, except you place an amper-
sand ( & ) in front of the name. Program 5-7 shows an example. In the program, an 
 int argument is passed by reference to the  setToZero function. The  setToZero 
function sets its parameter variable to 0, which also sets the original variable that 
was passed as an argument to 0. 
 Program 5-7 
 (PassByReference.cpp)  
 1 #include <iostream> 
 2 using namespace std; 
 3  
 4 // Function prototype 

184 
Chapter 5 
 Functions
 5 void setToZero(int &); 
 6  
 7 int main() 
 8 { 
 9    int value = 99; 
 10    cout << "The value is " << value << endl; 
 11    setToZero(value); 
 12    cout << "Now the value is " << value << endl; 
 13    return 0; 
 14 } 
 15  
 16 // Definition of the setToZero function 
 17 void setToZero(int &num) 
 18 { 
 19    num = 0; 
 20 } 
 Program Output 
 The value is 99 
 Now the value is 0  
 Checkpoint 
 5.10.   What are the pieces of data that are passed into a function called?  
 5.11.   What are the variables that receive pieces of data in a function called?  
 5.12.   Typically, what is a parameter variable’s scope?  
 5.13.   Explain the difference between passing by value and passing by reference.  
 
5.5  Global Variables and Global Constants 
 CONCEPT:   Global variables and global constants are accessible to all the func-
tions in a program.  
 Global Variables 
 A  global variable is a variable that is visible to every function in the program. A 
global variable’s scope is the entire program, so all the functions in the program can 
access a global variable. To declare a global variable or constant in a C++ program, 
you write the declaration outside all functions and above the definitions of the func-
tions. As a result, all the functions in the program have access to the variable or 
constant. Program 5-8 shows two functions,  main and  anotherFunction , that access 
the same global variable,  num . 

 
5.5 Global Variables and Global Constants 
185
 Program 5-8 
 (GlobalVariable.cpp)  
 1 #include <iostream> 
 2 using namespace std; 
 3  
 4 // Function prototype 
 5 void anotherFunction(); 
 6  
 7 // Global variable declaration 
 8 int num = 2; 
 9  
 10 // Definition of the main function 
 11 int main() 
 12 { 
 13    cout << "In main, num is " << num << endl; 
 14    anotherFunction(); 
 15    cout << "Back in main, num is " << num << endl; 
 16    return 0; 
 17 } 
 18  
 19 // Definition of anotherFunction 
 20 void anotherFunction() 
 21 { 
 22    cout << "In anotherFunction, num is " << num << endl; 
 23    num = 50; 
 24    cout << "But, it is now changed to " << num << endl; 
 25 } 
 Program Output 
 In main, num is 2 
 In anotherFunction, num is 2 
 But, it is now changed to 50 
 Back in main, num is 50  
 Line 8 declares an  int variable named  num . Because the declaration does not appear 
inside a function, the number variable is a global variable. All the functions that are 
defined in the program have access to the variable. 
 Although you will see some programs that require global variables in Part 2 of this 
book, you should be very careful hen using them. The reasons are as follows: 
 ●  Global variables make debugging difficult. Any statement in a program can 
change the value of a global variable. If you find that the wrong value is being 
stored in a global variable, you have to track down every statement that accesses 
it to determine where the bad value is coming from. In a program with thou-
sands of lines of code, this can be difficult.  
 ●  Functions that use global variables are usually dependent on those variables. If 
you want to use such a function in a different program, most likely you will have 
to redesign it so it does not rely on the global variable.  

186 
Chapter 5 
 Functions
 ●  Global variables make a program hard to understand. A global variable can be 
modified by any statement in the program. If you are to understand any part of 
the program that uses a global variable, you have to be aware of all the other 
parts of the program that access the global variable.  
 When possible, you should declare variables locally and pass them as arguments to 
the functions that need to access them.  
 Global Constants 
 A  global constant is a named constant that is available to every function in the program. 
Because a global constant’s value cannot be changed during the program’s execution, 
you do not have to worry about many of the potential hazards that are associated with 
the use of global variables. 
 Global constants are typically used to represent unchanging values that are needed 
throughout a program. For example, suppose a banking program uses a named con-
stant to represent an interest rate. If the interest rate is used in several functions, it is 
easier to create a global constant, rather than a local named constant in each function. 
This also simplifies maintenance. If the interest rate changes, only the declaration of 
the global constant has to be changed, instead of several local declarations.  
 In the Spotlight: 
 Using Global Constants and Reference 
Parameters 
 Marilyn works for Integrated Systems, Inc., a software company that has a reputation 
for providing excellent fringe benefits. One of its benefits is a quarterly bonus that is paid 
to all employees. Another benefit is a retirement plan for each employee. The company 
contributes 5 percent of each employee’s gross pay and bonuses to his or her retirement 
plan. Marilyn wants to design a program that will calculate the company’s contribution 
to an employee’s retirement account for a year. She wants the program to show the 
amount of contribution for the employee’s gross pay and for the bonuses separately. 
 Here is an outline of the actions that the program will perform: 
 1.  Get the employee’s annual gross pay.  
 2.  Get the amount of bonuses paid to the employee.  
 3.  Calculate and display the contribution for the gross pay.  
 4.  Calculate and display the contribution for the bonuses.  
 Program 5-9 shows the program’s code. 
 Program 5-9 
  (Contributions.cpp) 
 1 #include <iostream> 
 2 using namespace std; 
 3  
 4 // Function prototypes 

 
5.5 Global Variables and Global Constants 
187
 5 void getGrossPay(double &); 
 6 void getBonuses(double &); 
 7 void showGrossPayContrib(double); 
 8 void showBonusContrib(double); 
 9  
 10 // Global variable declaration 
 11 double CONTRIBUTION_RATE = 0.05; 
 12  
 13 // Definition of the main function 
 14 int main() 
 15 { 
 16    // Variables 
 17    double annualGrossPay, // To hold the annual gross pay 
 18           totalBonuses;   // To hold the total bonuses 
 19  
 20    // Get the annual gross pay. 
 21    getGrossPay(annualGrossPay); 
 22  
 23    // Get the total of the bonuses. 
 24    getBonuses(totalBonuses); 
 25  
 26    // Display the contribution for the gross pay. 
 27    showGrossPayContrib(annualGrossPay); 
 28  
 29    // Display the contribution for the bonuses. 
 30    showBonusContrib(totalBonuses); 
 31    return 0; 
 32 } 
 33  
 34 // The getGrossPay function gets the user's 
 35 // annual gross pay and assigns it to the 
 36 // grossPay reference parameter. 
 37 void getGrossPay(double &grossPay) 
 38 { 
 39    cout << "Enter the annual gross pay: "; 
 40    cin >> grossPay; 
 41 } 
 42  
 43 // The getBonuses function gets the amount 
 44 // of bonuses and assigns it to the bonuses 
 45 // reference parameter. 
 46 void getBonuses(double &bonuses) 
 47 { 
 48    cout << "Enter the amount of bonuses: "; 
 49    cin >> bonuses; 
 50 } 
 51  
 52 // The showGrossPayContrib function accepts 
 53 // the gross pay as an argument and displays 
 54 // the retirement contribution for gross pay. 
 55 void showGrossPayContrib(double grossPay) 
 56 { 
 57    double contrib = grossPay * CONTRIBUTION_RATE; 
 58    cout << "Contribution for the gross pay: $" 
 59        << contrib << endl; 

188 
Chapter 5  Functions
 60 } 
 61  
 62 // The showBonusContrib function accepts 
 63 // the bonus amount as an argument and displays 
 64 // the retirement contribution for bonuses. 
 65 void showBonusContrib(double bonuses) 
 66 { 
 67    double contrib = bonuses * CONTRIBUTION_RATE; 
 68    cout << "Contribution for bonuses: $" 
 69         << contrib << endl; 
 70 } 
 Program Output with Input Shown in Bold 
 Enter the annual gross pay:  80000 [ Enter ] 
 Enter the amount of bonuses:  20000 [ Enter ] 
 Contribution for the gross pay: $4000 
 Contribution for bonuses: $1000  
 A global constant named  CONTRIBUTION_RATE is declared in line 11 and initial-
ized with the value 0.05. The constant is used in the calculation in line 57 (in the 
 showGrossPayContrib function) and again in line 67 (in the  showBonusContrib func-
tion). Marilyn decided to use this global constant to represent the 5 percent contribu-
tion rate for two reasons: 
 •  It makes the program easier to read. When you look at the calculations in lines 
57 and 67, it is apparent what is happening.  
 •  Occasionally the contribution rate changes. When this happens, it will be easy 
to update the program by changing the declaration statement in line 11.  
 Checkpoint 
 5.14.   What is the scope of a global variable?  
 5.15.   Give one good reason why you should not use global variables in a program.  
 5.16.   What is a global constant? Is it permissible to use global constants in a program?  
 
5.6  Value-Returning Functions 
 CONCEPT:   A value-returning function is a function that returns a value to the part 
of the program that called it.  
 A value-returning function is like a  void function in the following ways: 
 ●  It contains a group of statements that performs a specific task.  
 ●  When you want to execute the function, you call it.  

 
5.6 Value-Returning Functions 
189
 When a value-returning function finishes, however, it returns a value to the statement 
that called it. The value that is returned from a function can be used like any other 
value: It can be assigned to a variable, displayed on the screen, used in a mathematical 
expression (if it is a number), and so on. 
 The  pow function , which you have already seen,  is an example of a value-returning 
function. Here is an example: 
 double x; 
 x = pow(4.0, 2.0);  
 The second line in this code calls the  pow function, passing 4.0 and 2.0 as arguments. 
The function calculates the value of 4.0 raised to the power of 2.0 and returns that 
value. The value, which is 16.0, is assigned to the  x variable by the  = operator. 
 Writing Your Own Value-Returning Functions 
 You write a value-returning function in the same way that you write a  void function, 
with two exceptions: 
 ●  You must specify a data type for a value-returning function. The value that is 
returned from the function must be of the specified data type.  
 ●  A value-returning function must have a  return statement. The  return statement 
causes a value to be returned from the function.  
 Here is the general format of a value-returning function definition in C++: 
 DataType FunctionName ( ParameterList ) 
 { 
     statement; 
     statement; 
     etc. 
    return  expression ; 
 } 
 ●  DataType is the data type of the value that the function returns. We commonly 
call this the function’s  return type . For example, if the function returns an inte-
ger, the word   int will appear here. If the function returns a  double value, then 
the word   double will appear here.  
 ●  FunctionName is the name of the function.  
 ●  ParameterList is an optional parameter list. If the function does not accept 
arguments, then an empty set of parentheses will appear.  
 One of the statements inside the function must be a  return statement, which takes the 
following form: 
 return  expression ; 
 The value of the   expression that follows the key word  return will be sent back 
to the statement that called the function. This can be any value, variable, or expres-
sion that has a value (such as a math expression). The value that is returned must 
be of the same data type as that specified in the function header, or a compiler error 
will occur. 

190 
Chapter 5 
 Functions
 Here is an example of a value-returning function: 
 int sum(int num1, int num2) 
 { 
   return num1 + num2; 
 } 
 Figure  5-8 illustrates the various parts of the function header. Notice that the function 
returns an  int , the function’s name is  sum , and the function has two  int parameters, 
named  num1 and  num2 . 
int sum(int num1, int num2)
{
    return num1 + num2;
}
The function
returns an int
The function’s
name is sum
num1 and num2
are parameters
 Figure 5-8  Parts of the function header  
 The purpose of this function is to accept two  int values as arguments and return 
their sum. Notice that the  return statement returns the value of the expression 
 num1 + num2 . When the  return statement executes, the function ends its execution 
and sends the value of  num1 + num2 back to the part of the program that called 
the function. 
 Let’s look at a complete program that demonstrates the  sum function. 
 Program 5-10 
 (ValueReturn.cpp)  
 1 #include <iostream> 
 2 using namespace std; 
 3  
 4 // Function prototypes 
 5 int sum(int, int); 
 6  
 7 // Definition of the main function 
 8 int main() 
 9 { 
 10    // Variables 
 11    int userAge,       // The user's age 
 12        friendAge,     // A friend's age 
 13        combinedAge;   // The combined age 
 14  
 15    // Get the user's age. 
 16    cout << "What is your age? "; 
 17    cin >> userAge; 
 18  
 19    // Get a friend's age. 
 20    cout << "What is your friend's age? "; 
 21    cin >> friendAge; 

 
5.6 Value-Returning Functions 
191
 22  
 23    // Get the combined age. 
 24    combinedAge = sum(userAge, friendAge); 
 25  
 26    // Display the combined age. 
 27    cout << "Your combined age is " 
 28         << combinedAge << " years." << endl; 
 29    return 0; 
 30 } 
 31  
 32 // The sum function accepts two int 
 33 // arguments and returns their sum. 
 34 int sum(int num1, int num2) 
 35 { 
 36     return num1 + num2; 
 37 } 
 Program Output with Input Shown in Bold 
 What is your age?  23 [ Enter ] 
 What is your friend's age?  25 [ Enter ] 
 Your combined age is 48 years.  
 In lines 16 and 17 the user is prompted to enter his or her age, and the input is 
assigned to the  userAge variable. In lines 20 and 21 the user is prompted to enter 
a friend’s age, and the input is assigned to the  friendAge variable. Line 24 calls 
the  sum function, passing the  userAge and  friendAge variables as arguments. The 
sum of the two variables is returned from the function and assigned to the 
 combinedAge variable. In lines 27 and 28 the value of the  combinedAge variable is 
displayed. 
 Let’s assume the  userAge variable is set to the value 23 and the  friendAge variable is 
set to the value 25.  Figure   5-9 shows how the arguments are passed to the function 
and how a value is returned from the function.  
combinedAge = sum(userAge, friendAge);
23
25
48
private int sum(int num1, int num2)
{
    return num1 + num2;
}
 Figure 5-9  Arguments passed to  sum and a value returned  
 When you call a value-returning function, you usually want to do something meaning-
ful with the value it returns. In line 24 of Program 5-10, the value that is returned 
from the  sum function is assigned to a variable. This is commonly how return values 

192 
Chapter 5 
 Functions
are used, but you can do many other things with them. For example, the following 
code shows a math expression that uses a call to the  sum function: 
 int x = 10, y = 15; 
 double average; 
 average = sum(x, y) / 2.0;  
 In the last statement, the  sum function is called with  x and  y as its arguments. The 
function’s return value, which is 25, is divided by 2.0. The result, 12.5, is assigned to 
 average . Here is another example: 
 int x = 10, y = 15; 
 cout << "The sum is " + sum(x, y) << endl;  
 This code uses  cout to display the  sum function’s return value on the screen. The mes-
sage  “The sum is 25” will be displayed. Remember, a value-returning function returns 
a value of a specific data type. You can use the function’s return value anywhere that 
you can use a regular value of the same data type. This means that anywhere an  int 
value can be used, a call to an  int value-returning function can be used. Likewise, 
anywhere a  double value can be used, a call to a  double value-returning function can 
be used. The same is true for any other data type.  
 In the Spotlight: 
 Writing Value-Returning Functions 
 Your friend Michael runs a catering company. Some of the ingredients that his recipes 
require are measured in cups. When he goes to the grocery store to buy those ingre-
dients, however, they are sold only by the fluid ounce. He has asked you to write a 
simple program that converts cups to fluid ounces. 
 You design the following algorithm: 
 1.  Display an introductory screen that explains what the program does.  
 2.  Get the number of cups.  
 3.  Convert the number of cups to fluid ounces, and display the result.  
 This algorithm lists the top level of tasks that the program needs to perform and 
becomes the basis of the program’s  main function. In addition to  main , you decide to 
break down the program into the following functions: 
 •  showIntro —This function will display a message on the screen that explains 
what the program does.  
 •  getCups —This function will prompt the user to enter the number of cups and 
then returns that value as a  double . 
 •  cupsToOunces —This function will accept the number of cups as an argument 
and then return equivalent number of fluid ounces as a  double . 
 Program 5-11 shows the code for the program. 

 
5.6 Value-Returning Functions 
193
 Program 5-11 
  (CupsToOunces.cpp) 
 1 #include <iostream> 
 2 using namespace std; 
 3  
 4 // Function prototypes 
 5 void showIntro(); 
 6 double getCups(); 
 7 double cupsToOunces(double); 
 8  
 9 int main() 
 10 { 
 11    // Variables for the cups and ounces. 
 12    double cups, ounces; 
 13  
 14    // Display an intro screen. 
 15    showIntro(); 
 16  
 17    // Get the number of cups. 
 18    cups = getCups(); 
 19  
 20    // Convert cups to fluid ounces. 
 21    ounces = cupsToOunces(cups); 
 22  
 23    // Display the number of ounces. 
 24    cout << cups << " cups equals " 
 25         << ounces << " ounces.\n"; 
 26  
 27    return 0; 
 28 } 
 29  
 30 // The showIntro function displays an intro screen. 
 31 void showIntro() 
 32 { 
 33    cout << "This program converts measurements" << endl 
 34         << "in cups to fluid ounces. For your" << endl 
 35         << "reference the formula is:" << endl 
 36         << "    1 cup = 8 fluid ounces" << endl << endl; 
 37 } 
 38  
 39 // The getCups function prompts the user to enter 
 40 // the number of cups and then returns that value 
 41 // as a double. 
 42 double getCups() 
 43 { 
 44    double numCups; 
 45  
 46    cout << "Enter the number of cups: "; 
 47    cin >> numCups; 
 48    return numCups; 
 49 } 
 50  
 51 // The cupsToOunces function accepts a number of 
 52 // cups as an argument and returns the equivalent 

194 
Chapter 5 
 Functions
 53 // number of fluid ounces as a double. 
 54 double cupsToOunces(double numCups) 
 55 { 
 56    return numCups * 8.0; 
 57 } 
 Program Output with Input Shown in Bold 
 This program converts measurements 
 in cups to fluid ounces. For your 
 reference the formula is: 
    1 cup = 8 fluid ounces 
 Enter the number of cups:  2 [ Enter ] 
    2 cups equals 16 ounces.  
 bool Functions 
 A  bool function returns either  true or  false . You can use a  bool function to test a 
condition and then return either  true or  false to indicate whether the condition ex-
ists.  bool functions are useful for simplifying complex conditions that are tested in 
decision and repetition structures. 
 For example, suppose you are writing a program that will ask the user to enter a 
number and then determine whether that number is even or odd. The following code 
shows how you can make that determination. Assume  number is an  int variable con-
taining the number entered by the user. 
 if (number % 2 == 0) 
 { 
    cout << "The number is even." << endl; 
 } 
 else 
 { 
    cout << "The number is odd." << endl; 
 } 
 The meaning of the  bool expression being tested by this  if - else statement isn’t clear, 
so let’s take a closer look at it: 
 number % 2 == 0  
 This expression uses the  % operator , which was introduced in  Chapter   2 .  Recall that the  
 % operator divides two integers and returns the remainder of the division. So, this code 
is saying, “If the remainder of number divided by 2 is equal to 0, then display a message 
indicating the number is even, or else display a message indicating the number is odd.” 
 Because dividing an even number by 2 will always give a remainder of 0, this logic 
will work. The code would be easier to understand, however, if you could somehow 
rewrite it to say, “If the number is even, then display a message indicating it is even, 

 
5.6 Value-Returning Functions 
195
or else display a message indicating it is odd.” As it turns out, this can be done with a 
 bool function. In this example, you could write a  bool function named  isEven that 
accepts an  int as an argument and returns  true if the number is even, or  false oth-
erwise. Here is an example how the  isEven function might be written: 
 bool isEven(int number) 
 { 
    // Local variable to hold true or false 
    bool numberIsEven; 
    // Determine whether the number is even. 
    if (number % 2 == 0) 
    { 
       numberIsEven = true; 
    } 
    else 
    { 
       numberIsEven = false; 
    } 
    // Return the result. 
    return numberIsEven; 
 } 
 Then you can rewrite the previously shown  if - else statement so it calls the  isEven 
function to determine whether  number is even: 
 if (isEven(number)) 
 { 
    cout << "The number is even." << endl; 
 } 
 else 
 { 
    cout << "The number is odd." << endl; 
 } 
 Not only is this logic easier to understand, but now you have a function that you can 
call in the program anytime you need to test a number to determine whether it is even.  
 Returning a String from a Function 
 So far you’ve seen examples of functions that return numbers and Boolean values. 
You can write functions that return any type of data. Program 5-12 shows an example 
that uses a string-returning function. 
 Program 5-12 
 (ReturnString.cpp)  
 1 #include <iostream> 
 2 #include <string> 
 3 using namespace std; 
 4  
 5 // Function prototype 

196 
Chapter 5 
 Functions
 6 string fullName(string, string, string); 
 7  
 8 // The main function 
 9 int main() 
 10 { 
 11    // String objects 
 12    string first,     // To hold the first name 
 13           middle,    // To hold the middle name 
 14           last,      // To hold the last name 
 15           full;      // To hold the full name 
 16  
 17    // Get the user's first name. 
 18    cout << "Enter your first name: "; 
 19    cin >> first; 
 20  
 21    // Get the user's middle name. 
 22    cout << "Enter your middle name: "; 
 23    cin >> middle; 
 24  
 25    // Get the user's last name. 
 26    cout << "Enter your last name: "; 
 27    cin >> last; 
 28  
 29    // Get the user's full name. 
 30    full = fullName(first, middle, last); 
 31  
 32    // Display the user's full name. 
 33    cout << "Your full name is " << full << endl; 
 34    return 0; 
 35 } 
 36  
 37 // The showIntro function displays an intro screen. 
 38 string fullName(string first, string middle, string last) 
 39 { 
 40    return first + " " + middle + " " + last; 
 41 } 
 Program Output with Input Shown in Bold 
 Enter your first name:  Sarah [ Enter ] 
 Enter your middle name:  Lynn [ Enter ] 
 Enter your last name:  MacEwen [ Enter ] 
 Your full name is Sarah Lynn MacEwen  
 Lines 38 through 41 define a function named  fullName . Notice the following things 
about the function: 
 ●  Its return type is  string . 
 ●  It accepts has three  string parameters:  first ,  middle , and  last . When we call 
the function, we pass a first name, a middle name, and a last name as arguments.  
 ●  In line 40 it returns a string that is the concatenation of the  first ,  middle , and 
 last parameters, with spaces inserted between each.  

 
5.7 Calling string Class Member Functions 
197
 Checkpoint 
 5.17.  What is a value-returning function? How is it used?  
 5.18.  What is returned by a  bool function? 
 5.19.  Can a function be written to return any type of data?  
 
5.7  Calling  string Class Member Functions 
 CONCEPT:   A member function is a special function that operates on an object.  
 Recall from  Chapter   2 that  string   objects are created from the standard library’s 
 string class. Objects that are created from a class are much more versatile than 
simple variables. For example, objects that are created from a class usually have built-
in functions that are known as member functions. A  member function is a function 
that operates on a specific object’s data. You call a member function in a slightly dif-
ferent manner than a regular function. Here is the general format: 
 objectName . functionName ( arguments ) 
 In the general format,   objectName is the name of the object that you are using to call the 
member function,   functionName is the name of the member function, and   arguments  
are arguments (if any) that you are passing to the function. 
 For example, if you want to know the length of the string that is stored in a  string 
object, you can call the object’s  length member function. Here is an example of how 
to use it. 
 string state = "Texas"; 
 int size; 
 size = state.length();  
 The first statement creates a  string object named  state , initialized with the string 
“Texas”. The second statement declares an  int variable named  size . The third 
statement calls the  state object’s  length member function, which returns the length 
of the string in the  state object. The value that is returned from the member func-
tion is assigned to the  size variable. After this code executes, the  size variable will 
hold the value 5. 
 Another  string member function  that you will use quite a bit in the second part 
of this book  is the  c_str() member function. The  c_str() member function 
returns the value of a  string object formatted as a null terminated string. A  null -
 terminated string is stored in memory with a byte that is set to the numeric value 
0 at the end of the string. This is a particular format that is required by the App 
Game Kit library.  You will see several examples of this member function used 
later in the book.  

198 
Chapter 5 
 Functions
 Review Questions 
 Multiple Choice  
 
1.  In general terms, a program that is broken into smaller units of code, such as 
functions, is known as a(n) _____.  
 a.  object-oriented program  
 b.  modularized program  
 c.  procedural program  
 d.  function-driven program  
 
2.  Writing the code to perform a task once and then reusing it each time you need 
to perform the task is a benefit of using functions called _____.  
 a.  code reuse  
 b.  the single use philosophy  
 c.  function recycling  
 d.  code reprocessing  
 
3.  When you call a(n) _____, it simply executes the statements it contains then 
terminates.  
 a.  intrinsic function  
 b.  empty function  
 c.  logical function  
 d.   void function  
 
4.   The _____, which appears at the beginning of a function definition, lists several 
important things about the function, including the function’s name.  
 a.  function title  
 b.  function description  
 c.  function header  
 d.  function declaration  
 
5.  The _____ is a collection of statements enclosed inside a set of curly braces that 
are performed when the function is executed.  
 a.  function body  
 b.  function designation  
 c.  function code  
 d.  function classification  
 
6.   A statement, usually appearing near the top of the program, which declares the 
existence of a function, but does not define the function is a _____.  
 a.  function predefinition  
 b.  function prototype  
 c.  function initialization  
 d.  function disclosure  
 
7.  The _____ is the memory address that is saved by the system when a function is 
called and is the location the system should return to after a function ends.  
 a.  calling address  
 b.  function address  
 c.  return point  
 d.  come back position  

 
Review Questions 
199
 
8.   Programmers commonly use a technique known as _____ to break down an algo-
rithm into functions.  
 a.   prototyping 
 b.   function modeling  
 c.   algorithm division  
 d.  top-down design  
 
9.   Pieces of data that are sent into a function are known as _____.  
 a.  arguments  
 b.  references  
 c.  function variables  
 d.   data entries  
 
10.   A(n) _____ is a special variable that receives an argument when a function is called.  
 a.  reference variable  
 b.  argument variable  
 c.  parameter variable  
 d.  function variable  
 
11.   When an argument is _____, only a copy of the argument’s value is passed into 
the parameter variable.  
 a.   a named constant  
 b.  passed by association  
 c.   passed by reference  
 d.  passed by value  
 
12.   When you want a function to be able to change the value of a variable that is 
passed to it as an argument, the variable must be _____.  
 a.  passed by reference  
 b.  a local variable  
 c.  passed by value  
 d.  a named constant  
 
13.   A _____ is a special type of parameter variable that is useful for establishing two-
way communication between functions.  
 a.  communication variable  
 b.  reference parameter  
 c.  function parameter  
 d.  global variable  
 
14.   A function’s _____ is the type of value that the function returns.  
 a.  data type  
 b.  return type  
 c.  value type  
 d.  function type  
 True or False  
 
1.   Dividing a large problem into several smaller problems that are easily solved is 
sometimes called divide and conquer.  
 
2.  Calling a function and defining a function mean the same thing.  

200 
Chapter 5 
 Functions
 
3.  A function prototype declares the existence of a function, but does not define the 
function. 
 
4.  A value-returning function must contain a  return statement.  
 
5.  A statement in one function can access a local variable in another function.  
 
6.  You cannot have two variables with the same name in the same scope.  
 
7.  It is permissible to have local variables with the same name declared in separate 
functions. 
 
8.  Functions are not allowed to accept multiple arguments.  
 
9.  When an argument is passed by reference, the function can modify the argument 
in the calling part of the program.  
 
10.  Passing an argument by value is a means of establishing two-way communication 
between functions.  
 
11.  A Boolean function returns either  yes or  no . 
 Short Answer  
 
1.   What do you call a function that executes the statements it contains and then 
returns a value back to the statement that called it?  
 
2.   What is another name for the top-down design process?  
 
3.   What is a parameter list?  
 
4.  How is a value-returning function like a  void function? How is it different?  
 
5.   When a function is executing, what happens when the end of the function is reached?  
 
6.   What is a local variable? What statements are able to access a local variable?  
 
7.   Where does a local variable’s scope begin and end?  
 
8.   What is the difference between passing an argument by value and passing it by 
reference?  
 Algorithm Workbench  
 
1.  Examine the following function header, then write an example call to the function. 
 private void showValue()  
 
2.  The following statement calls a function named  showHalf . The  showHalf function 
displays a value that is half that of the argument. Write the function. 
 showHalf(50);  
 
3.  Write the function header for a function named  showRetailPrice . The function 
should include parameter variables for a wholesale price and a markup percentage.  
 
4.   Examine the following function header, then write an example call to the function. 
 private void resetValue(int &value)  

 
Programming Exercises 
201
 
5.   A program contains the following value-returning function. 
 private int square(int value) 
 { 
     return value * value; 
 } 
 Write a statement that passes the value  10 as an argument to this function and 
assigns its return value to the variable  result . 
 Programming Exercises 
 
1.   Retail Price Calculator 
 Write a program that lets the user enter an item’s wholesale cost and its markup 
percentage. It should then display the item’s retail price. For example: 
 •  If an item’s wholesale cost is 5.00 and its markup percentage is 100 percent, 
then the item’s retail price is 10.00.  
 •  If an item’s wholesale cost is 5.00 and its markup percentage is 50 percent, 
then the item’s retail price is 7.50.  
 The program should have a function named  calculateRetail that receives the 
wholesale cost and the markup percentage as arguments and returns the retail 
price of the item.  
 
2.   Celsius Temperature Table 
 The formula for converting a temperature from Fahrenheit to Celsius is 
 C = 5
9(F – 32) 
 where  F is the Fahrenheit temperature and  C is the Celsius temperature. Write a 
function named  celsius that accepts a Fahrenheit temperature as an argument. 
The function should return the temperature, converted to Celsius. Demonstrate 
the function by calling it in a loop that displays a table of the Fahrenheit tempera-
tures 0 through 20 and their Celsius equivalents.  
 
3.   Falling Distance 
 When an object is falling because of gravity, the following formula can be used 
to determine the distance the object falls in a specific time period: 
 d = ½ gt2 
 The variables in the formula are as follows:  d is the distance in meters,  g is 9.8, 
and  t is the amount of time in seconds that the object has been falling. Write a 
program that allows the user to enter the amount of time that an object has fallen 
and then displays the distance that the object fell. The program should have a 
function named  fallingDistance . The  fallingDistance function should accept 
an object’s falling time (in seconds) as an argument. The function should return 
in meters the distance that the object has fallen during that time interval.  
 
4.   Kinetic Energy 
 In physics, an object that is in motion is said to have kinetic energy. The following 
formula can be used to determine a moving object’s kinetic energy: 
 KE = ½ mv2 

202 
Chapter 5 
 Functions
 In the formula  KE is the kinetic energy,  m is the object’s mass in kilograms, 
and  v is the object’s velocity in meters per second. Write a program that allows 
the user to enter an object’s mass and velocity and then displays the object’s 
kinetic energy. The program should have a function named  kineticEnergy that 
accepts an object’s mass (in kilograms) and velocity (in meters per second) as 
arguments. The function should return the amount of kinetic energy that the 
object has.  
 
5.  Calories from Fat and Carbohydrates 
 A nutritionist who works for a fitness club helps members by evaluating 
their diets. As part of her evaluation, she asks members for the number of 
fat grams and carbohydrate grams that they consumed in a day. Then, she 
calculates the number of calories that result from the fat, using the following 
formula: 
 Calories from Fat = Fat Grams × 9 
 Next, she calculates the number of calories that result from the carbohydrates, 
using the following formula: 
 Calories from Carbs = Carb Grams × 4 
 Write a program that will make these calculations. In the program, you should 
have the following functions: 
 •  fatCalories —This function should accept a number of fat grams as an 
argument and return the number of calories from that amount of fat.  
 •  carbCalories —This function should accept a number of carbohydrate 
grams as an argument and return the number of calories from that amount 
of carbohydrates.  
 
6.   Hospital Charges 
 Write a program that calculates the total cost of a hospital stay. The daily base 
charge is $350. The hospital also charges for medication, surgical fees, lab fees, 
and physical rehab. The program should accept the following input: 
 •  The number of days spent in the hospital  
 •  The amount of medication charges  
 •  The amount of surgical charges  
 •  The amount of lab fees  
 •  The amount of physical rehabilitation charges  
 Create and use the following value-returning functions in the application: 
 •  calcStayCharges —Calculates and returns the base charges for the hospital 
stay. This is computed as $350 times the number of days in the hospital.  
 •  calcMiscCharges —Calculates and returns the total of the medication, surgi-
cal, lab, and physical rehabilitation charges.  
 •  calcTotalCharges —Calculates and returns the total charges.  
 
7.   Present Value 
 Suppose you want to deposit a certain amount of money into a savings account 
and then leave it alone to draw interest for the next 10 years. At the end of 10 
years you would like to have $10,000 in the account. How much do you need to 

 
Programming Exercises 
203
deposit today to make that happen? You can use the following formula, which is 
known as the present value formula, to find out: 
 P = 
F
(1 + r)n 
 The terms in the formula are as follows: 
 •  P is the present value, or the amount that you need to deposit today.  
 •  F is the future value that you want in the account. (In this case,  F is $10,000.)  
 •  r is the annual interest rate.  
 •  n is the number of years that you plan to let the money sit in the account.  
 Write a function named  presentValue that performs this calculation. The func-
tion should accept the future value, annual interest rate, and number of years as 
arguments. It should return the present value, which is the amount that you need 
to deposit today. Demonstrate the function in a program that lets the user experi-
ment with different values for the formula’s terms.  
 
8.   Population 
 In a population, the birthrate is the percentage increase of the population due 
to births, and the death rate is the percentage decrease of the population due to 
deaths. Write a program that displays the size of a population for any number of 
years. The program should ask for the following data: 
 The starting size of a population  
 The annual birthrate  
 The annual death rate  
 The number of years to display  
 Write a function that calculates the size of the population for a year. The formula is 
 N = P + BP – DP 
 where  N is the new population size,  P is the previous population size,  B is the 
birthrate, and  D is the death rate.  
 
9.   Prime Numbers 
 A prime number is a number that can be evenly divided by only itself and 1. For 
example, the number 5 is prime because it can be evenly divided by only 1 and 5. 
The number 6, however, is not prime because it can be evenly divided by 1, 2, 3, 
and 6. Write a  bool function named  isPrime that takes an integer as an argument 
and returns  true if the argument is a prime number or  false otherwise. Use the 
function in a program that lets the user enter a number and then displays a mes-
sage indicating whether the number is prime.  
 
10.   Prime Number List 
 This exercise assumes you have already written the  isPrime function in Program-
ming Exercise 9. Write another program that uses this function to display all the 
prime numbers from 1 through 100. The program should have a loop that calls 
the  isPrime function.  
 TIP:    Recall that the  % operator divides one number by another and returns the 
remainder of the division. In an expression such as  num1 % num2 , the  % operator will 
return 0 if  num1 is evenly divisible by  num2 . 

This page intentionally left blank 

205
 
  6.1  Array Basics 
 CONCEPT:   An array allows you to store a group of items of the same data type 
together in memory. Processing a large number of items in an array is 
usually easier than processing a large number of items stored in sepa-
rate variables.  
 In the programs you have written so far, you have used variables to store data 
in memory.  The simplest way to store a value in memory is to store it in a vari-
able. Variables work well in many situations, but they have limitations. For ex-
ample, they can hold only one value at a time. Consider the following variable 
declaration: 
 int number = 99;  
 This statement declares an  int variable named  number , initialized with the value 99. 
Consider what happens if the following statement appears later in the program: 
 number = 5;  
 This statement assigns the value 5 to  number , replacing the value 99 that was previ-
ously stored there. Because  number is an ordinary variable, it can hold only one value 
at a time. 
 6.1  Array Basics   
 6.2  Sequentially Searching an Array   
 6.3  Processing the Contents of an Array   
 6.4  Parallel Arrays   
 6.5  Two-Dimensional Arrays   
 6.6  Arrays of Three or More Dimensions   
 TOPICS 
 Arrays 
6 
 CHAPTER 

206 
Chapter 6 
 Arrays
 Because variables hold only a single value, they can be cumbersome in programs 
that process lists of data. For example, suppose you are asked to write a program 
that holds the names of 50 employees. Imagine declaring 50 variables to hold all 
those names: 
 string employee1; 
 string employee2; 
 string employee3; 
 and so on . . . 
 string employee50  
 Then, imagine writing the code to process all 50 names. For example, if you wanted 
to display the contents of the variables, you would write code such as this: 
 cout << employee1  << endl;  // Display employee 1 
 cout << employee2  << endl;  // Display employee 2 
 cout << employee3  << endl;  // Display employee 3 
 and so on . . . 
 cout << employee50 << endl;   // Display employee 50  
 As you can see, variables are not well suited for storing and processing lists of data. 
Each variable is a separate item that must be declared and individually processed. 
 Fortunately, you can use an array as an alternative to a group of variables. An  array 
can hold a group of values that are all of the same data type. You can have an array 
of  int values, an array of  double values, or an array of  string values, but you cannot 
store a mixture of data types in an array. Once you create an array, you can write 
simple and efficient code to process the values that are stored in it. Here is an example 
of how you can declare an  int array: 
 int values[20];  
 Notice that this statement looks like a regular  int variable declaration except for 
the number inside the brackets. The number inside the brackets is known as a  size 
declarator . The size declarator specifies the number of values that the array can 
hold. This statement declares an array named  values that can hold 20 integer 
values. The array size declarator must be a nonnegative integer. Here is another 
example: 
 double salesAmounts[7];  
 This statement declares an array named  salesAmounts that can hold 7  double values. 
The following statement shows one more example. This statement declares an array 
that can hold 50  string values. The name of the array is  names . 
 string names[50];  
 An array’s size cannot be changed while the program is running. If you have written 
a program that uses an array and then find that you must change the array’s size, 
you have to change the array’s size declarator in the source code. Then you must 
recompile the program with the new size declarator. To make array sizes easier to 

 
6.1 Array Basics 
207
maintain, it’s a good idea to use named constants as array size declarators. Here is 
an example: 
 const int SIZE = 20; 
 int values[SIZE];  
 As you will see later in this chapter, many array processing techniques require you to 
refer to the array’s size. When you use a named constant as an array’s size declarator, 
you can use the constant to refer to the size of the array in your algorithms. If you 
ever need to modify the program so that the array is a different size, you only need to 
change the value of the named constant. 
const int SIZE = 5;
int numbers[SIZE];
Element
0
Element
1
Element
2
Element
3
Element
4
 Figure 6-1  Array subscripts  
 Assigning Values to Array Elements 
 You access the individual elements in an array by using their subscripts. For example, 
assuming  numbers is the  int array previously described, the following code assigns 
values to each of its five elements: 
 numbers[0] = 20; 
 numbers[1] = 30; 
 numbers[2] = 40; 
 numbers[3] = 50; 
 numbers[4] = 60;  
 Array Elements and Subscripts 
 The storage locations in an array are known as  elements . In memory, an array’s ele-
ments are located in consecutive memory locations. Each element in an array is as-
signed a unique number known as a  subscript . Subscripts are used to identify specific 
elements in an array. In C++, the first element is assigned the subscript 0, the second 
element is assigned the subscript 1, and so forth. For example, suppose we have the 
following declarations in a program: 
 const int SIZE = 5; 
 int numbers[SIZE];  
 As shown in  Figure   6-1 , the  numbers array has five elements. The elements are assigned 
the subscripts 0 through 4. (Because subscript numbering starts at zero, the subscript of 
the last element in an array is one less than the total number of elements in the array.)  

208 
Chapter 6 
 Arrays
Element
0
Element
1
Element
2
Element
3
Element
4
20
30
40
50
60
 Figure 6-2  Values assigned to each element  
 Inputting and Outputting Array Contents 
 You can read values from the keyboard and store them in an array element just as 
you can a regular variable. You can also output the contents of an array element. The 
code in Program 6-1 shows an array being used to store and display values entered 
by the user. 
 Program 6-1 
  (ArrayInputOutput.cpp) 
 1 #include <iostream> 
 2 using namespace std; 
 3  
 4 int main() 
 5 { 
 6    const int SIZE = 3;   // Constant for array size 
 7    int hours[SIZE];      // Array to hold hours 
 8  
 9    // Get the hours worked by employee 1. 
 10    cout << "Enter the hours worked by employee 1: "; 
 11    cin >> hours[0]; 
 12     
 13    // Get the hours worked by employee 2. 
 14    cout << "Enter the hours worked by employee 2: "; 
 15    cin >> hours[1]; 
 16     
 17    // Get the hours worked by employee 3. 
 18    cout << "Enter the hours worked by employee 3: "; 
 19    cin >> hours[2]; 
 20  
 21    // Display the values in the array. 
 22    cout << "The hours you entered are:" << endl; 
 23    cout << hours[0] << endl; 
 24    cout << hours[1] << endl; 
 25    cout << hours[2] << endl; 
 26    return 0; 
 27 } 
 NOTE:   The expression  numbers[0] is pronounced “numbers sub zero.” 
 This code assigns the value 20 to element 0, the value 30 to element 1, and so forth. 
 Figure   6-2 shows the contents of the array after these statements execute.  

 
6.1 Array Basics 
209
 Program Output with Input Shown in Bold 
 Enter the hours worked by employee 1:  40 [ Enter ] 
 Enter the hours worked by employee 2:  20 [ Enter ] 
 Enter the hours worked by employee 3:  15 [ Enter ] 
 The hours you entered are: 
 40 
 20 
 15  
 Let’s take a closer look at the program. A named constant,  SIZE , is declared in 
line 6 and initialized with the value 3. Then, an  int array named  hours is declared 
in line 7. The  SIZE constant is used as the array size declarator, so the  hours array 
will have three elements. The  cin statements in lines 11, 15, and 19 read values 
from the keyboard and store those values in the elements of the  hours array. 
Then, the  cout statements in lines 23 through 25 output the values stored in each 
array element. 
 In the sample running of the program, the user entered the values 40, 20, and 15, 
which were stored in the  hours array.  Figure   6-3 shows the contents of the array after 
these values are stored in it.  
hours[0]
hours[1]
hours[2]
40
20
15
 Figure 6-3  Contents of the  hours array 
 Array Initialization 
 When you create an array, you can optionally initialize it with a group of values. Here 
is an example: 
 const int SIZE = 5; 
 int numbersArray[SIZE] = { 10, 20, 30, 40, 50 };  
 The series of values inside the braces and separated with commas is called an  initial-
ization list . These values are stored in the array elements in the order they appear in 
the list. (The first value, 10, is stored in  numbersArray[0] , the second value, 20, is 
stored in  numbersArray[1] , and so forth). 
 When you provide an initialization list, the size declarator can be left out. The com-
piler will determine the size of the array from the number of items in the initialization 
list. Here is an example: 
 int numbersArray[] = { 10, 20, 30, 40, 50 };  

210 
Chapter 6 
 Arrays
 In this example, the compiler will determine that the array should have five elements 
because five values appear in the initialization list. 
 Here are two separate examples that declare and initialize a  string array named  days . 
Each of these examples results in the same array: 
 // Example 1 
 const int SIZE = 7; 
 string days[SIZE] = { "Sunday", "Monday", "Tuesday", 
                     "Wednesday", "Thursday", 
                     "Friday","Saturday" }; 
 // Example 2 
 const int SIZE = 7; 
 string days[] = { "Sunday", "Monday", "Tuesday", 
                 "Wednesday", "Thursday", 
                   "Friday","Saturday" };  
 Using a Loop to Step through an Array 
 You can store a number in an  int variable and then use that variable as a sub-
script. This makes it possible to use a loop to step through an array, performing 
the same operation on each element. For example, look at the following code 
sample: 
 1  // Create an array to hold three integers. 
 2  const int SIZE = 3; 
 3  int myValues[SIZE]; 
 4  
 5  // Assign 99 to each array element. 
 6  for (int index = 0; index < SIZE; index++) 
 7  { 
 8      myValues[index] = 99; 
 9  }  
 Line 3 creates an  int array named  myValues with three elements. The  for loop that 
starts in line 6 uses an  int variable named  index as its counter. The  index variable is 
initialized with the value 0 and is incremented after each loop iteration. The loop iter-
ates as long as  index is less than 3. Thus, the loop will iterate three times. As it iterates, 
the  index variable will be assigned the values 0, 1, and 2. 
 Inside the loop, the statement in line 8 assigns the value 99 to an array element, 
using the  index variable as the subscript. The following is what happens as the 
loop iterates. 
 ●  The first time the loop iterates,  index will be set to 0, so 99 will be assigned to 
 myValues[0] . 
 ●  The second time the loop iterates,  index will be set to 1, so 99 will be assigned 
to  myValues[1] . 
 ●  The third time the loop iterates,  index will be set to 2, so 99 will be assigned to 
 myValues [2] . 
VideoNote
Accesing array 
elements with 
a loop

 
6.1 Array Basics 
211
 Program 6-2 shows a complete example, using two loops to process the contents of 
an array. 
 Program 6-2 
 (ArrayLoop.cpp) 
 1 #include <iostream> 
 2 using namespace std; 
 3  
 4 int main() 
 5 { 
 6    const int SIZE = 3;   // Constant for array size 
 7    int hours[SIZE];      // Array to hold hours 
 8  
 9    // Get the hours for each employee. 
 10    for (int index = 0; index < SIZE; index++) 
 11    { 
 12       cout << "Enter the hours worked by employee " 
 13            << index + 1 << ": "; 
 14       cin >> hours[index]; 
 15    } 
 16     
 17    // Display the values in the array. 
 18    cout << "The hours you entered are:" << endl; 
 19    for (int index = 0; index < SIZE; index++) 
 20    { 
 21       cout << hours[index] << endl; 
 22    } 
 23    return 0; 
 24 } 
 NOTE:   We should emphasize the fact that the loop shown in the previous code 
iterates as long as  index  is less than  SIZE . Remember, the subscript of the last ele-
ment in an array is one less than the size of the array. In this case, the subscript of 
the last element of the  myValues array is 2, which is one less than  SIZE . It would be 
an error to write the loop as shown in the following: 
 // Create an array to hold three integers. 
 const int SIZE = 3; 
 int myValues[SIZE]; 
 // ERROR! This loop writes outside the array! 
 for (int index = 0; index <= SIZE; index++) 
 { 
    myValues[index] = 99; 
 } 
 Can you spot the error in this code? The  for loop iterates as long as  index is 
less than or equal to  SIZE . The last time the loop iterates, the  index variable will 
be set to 3, and the statement inside the loop will try to assign the value 99 to 
 myValues[3] , which is a nonexistent element. 

212 
Chapter 6 
 Arrays
 Program Output with Input Shown in Bold 
 Enter the hours worked by employee 1:  40 [ Enter ] 
 Enter the hours worked by employee 2:  20 [ Enter ] 
 Enter the hours worked by employee 3:  15 [ Enter ] 
 The hours you entered are: 
 40 
 20 
 15  
 Let’s take a closer look at the first  for loop, which appears in lines 10 through 15. 
Here is the first line of the loop: 
 for (int index = 0; index < SIZE; index++)  
 This specifies that the  index variable will be initialized with the value 0 and will be 
incremented at the end of each iteration. The loop will iterate as long as  index is less 
than  SIZE . As a result, the  index variable will be assigned the values 0 through 2 as 
the loop executes. Inside the loop, in line 14, the  index variable is used as a subscript: 
 cin >> hours[index];  
 During the loop’s first iteration, the  index variable will be set to 0, so the user’s input is 
stored in  hours[0] . During the next iteration, the user’s input is stored in  hours[1] . Then, 
during the last iteration, the user’s input is stored in  hours[2] . Notice that the loop cor-
rectly starts and ends the  index variable with valid subscript values (0 through 2). 
 The second  for loop appears in lines 19 through 22. This loop also uses a variable 
named  index , which takes on the values 0 through 2 as the loop iterates. The first time 
the loop iterates, the statement in line 21 displays the contents of  hours[0] . The sec-
ond time the loop iterates, the statement displays the contents of  hours[1] . The third 
time the loop iterates, the statement displays the contents of  hours[2] . 
 There is one last thing to point out about the program. Notice that the program out-
put refers to the employees as “employee 1,” “employee 2,” and “employee 3.” Here 
is the  cout statement that appears inside the first  for loop, in lines 12 and 13: 
 cout << "Enter the hours worked by employee " 
     << index + 1 << ": ";  
 Notice that the statement uses the expression  index + 1 to display the employee 
number. What do you think would happen if we left out the  + 1 part of the expression, 
and the statements were written like this? 
 cout << "Enter the hours worked by employee " 
     << index << ": ";  
 Because the  index variable is assigned the values 0, 1, and 2 as the loop runs, this 
statement would cause the program to refer to the employees as “employee 0,” 
“employee 1,” and “employee 2.” Most people find it unnatural to start with 0 when 
counting people or things, so we used the expression  index + 1 to start the employee 
numbers at 1.  

 
6.1 Array Basics 
213
 No Array Bounds Checking in C++ 
 The C++ language does not perform  array bounds checking , which means the C++ 
compiler does not check the values that you use as array subscripts to make sure they 
are valid. For example, look at the following code: 
 // Create an array 
 const int SIZE = 5; 
 int numbers[SIZE]; 
 // ERROR! The following statement uses an invalid 
subscript! 
 numbers[5] = 99;  
 This code declares an array with five elements. The subscripts for the array’s elements 
are 0 through 4. The last statement, however, attempts to assign a value to  numbers[5] , 
a nonexistent element. If this code were part of a complete program, it would compile 
and execute. When the assignment statement executes, however, it will attempt to 
write the value 99 to an invalid location in memory. This is an error and will most 
likely cause the program to crash.  
 Watch for Off-by-One Errors 
 In working with arrays, a common type of mistake is the  off-by-one error . This is an 
easy mistake to make because array subscripts start at 0 rather than 1. For example, 
look at the following code: 
 // This code has an off-by-one error. 
 const int SIZE = 100; 
 int numbers[SIZE]; 
 for (int index = 1; index <= SIZE; index++) 
 { 
    numbers[index] = 0; 
 } 
 The intent of this code is to create an array of integers with 100 elements and store 
the value 0 in each element. However, this code has an off-by-one error. The loop 
uses the  index variable as a subscript with the  numbers array. During the loop’s 
execution, the  index variable takes on the values 1 through 100 when it should take 
on the values 0 through 99. As a result, the first element, which is at subscript 0, is 
skipped. In addition, the loop attempts to use 100 as a subscript during the last 
iteration. Because 100 is an invalid subscript, the program will write data beyond the 
array’s boundaries.  
 Processing the Elements of an Array 
 Processing array elements is no different than processing other variables. In the previ-
ous programs, you saw how you can assign values to array elements, store input in 
array elements, and display the contents of array elements. The following  In the 
Spotlight section shows how array elements can be used in math expressions.  

214 
Chapter 6 
 Arrays
 In the Spotlight: 
 Using Array Elements in a Math Expression 
 Megan owns a small neighborhood coffee shop, and she has six employees who work 
as baristas (coffee bartenders). All the employees have the same hourly pay rate. 
Megan has asked you to design a program that will allow her to enter the number of 
hours worked by each employee and then display the amounts of all the employees’ 
gross pay. You determine that the program should perform the following steps: 
 1.  Get the hourly pay rate for all employees.  
 2.  For each employee: 
 Get the number of hours worked and store it in an array element.  
 3.  For each array element: 
 Use the value stored in the element to calculate an employee’s gross pay. 
 Display the amount of the gross pay.  
 Program 6-3 shows the code for the program.  
 Program 6-3 
  (CoffeShopPayroll.cpp) 
 1 #include <iostream> 
 2 using namespace std; 
 3  
 4 int main() 
 5 { 
 6    const int SIZE = 6;   // Constant for array size 
 7    int hours[SIZE];      // Array to hold employee's hours 
 8    double payRate,       // To hold pay rate 
 9           grossPay;      // To hold gross pay 
 10  
 11    // Get the hourly pay rate for all employees. 
 12    cout << "Enter the hourly pay rate: "; 
 13    cin >> payRate; 
 14  
 15    // Get the hours for each employee. 
 16    for (int index = 0; index < SIZE; index++) 
 17    { 
 18       cout << "Enter the hours worked by employee " 
 19            << index + 1 << ": "; 
 20       cin >> hours[index]; 
 21    } 
 22     
 23    // Display each employee's gross pay. 
 24    cout << "Gross pay for each employee:" << endl; 
 25    for (int index = 0; index < SIZE; index++) 
 26    { 
 27       grossPay = hours[index] * payRate; 
 28       cout << "Employee " << index + 1 
 29            << ": $" << grossPay << endl; 
 30    } 
 31    return 0; 
 32 } 

 
6.1 Array Basics 
215
 Program Output with Input Shown in Bold 
 Enter the hourly pay rate:  12.00 [ Enter ] 
 Enter the hours worked by employee 1:  10 [ Enter ] 
 Enter the hours worked by employee 2:  20 [ Enter ] 
 Enter the hours worked by employee 3:  15 [ Enter ] 
 Enter the hours worked by employee 4:  40 [ Enter ] 
 Enter the hours worked by employee 5:  20 [ Enter ] 
 Enter the hours worked by employee 6:  18 [ Enter ] 
 Gross pay for each employee: 
 Employee 1: $120 
 Employee 2: $240 
 Employee 3: $180 
 Employee 4: $480 
 Employee 5: $240 
 Employee 6: $216  
 Checkpoint 
 6.1.  Can you store a mixture of data types in an array?  
 6.2.  What is an array size declarator?  
 6.3.  Can the size of an array be changed while the program is running?  
 6.4.  What is an array element?  
 6.5.  What is a subscript?  
 NOTE:    Suppose Megan’s business increases, and she has to hire two additional 
baristas. This would require you to change the program so it processes 8 employees 
instead of 6. Because you used a named constant for the array size, this is a simple 
modification—you just have to change the statement in line 6 to read: 
 const int SIZE = 8;  
 Because the  SIZE constant is used as the array size declarator in line 7, the size of 
the  hours array will automatically become 8. Also, because you used the  SIZE con-
stant to control the loop iterations in lines 16 and 25, the loops will automatically 
iterate 8 times, once for each employee. 
 Imagine how much more difficult this modification would be if you had not 
used a named constant to specify the array size. You would have to change 
each individual statement in the program that refers to the array size. Not only 
would this require more work, but it would also open the possibility for errors. 
If you overlooked only one of the statements that refer to the array size, a bug 
would occur. 

216 
Chapter 6 
 Arrays
 6.6.  What is the first subscript in an array?  
 6.7.  Look at the following code sample and answer questions a through d. 
 const int SIZE = 7; 
 double numbers[SIZE];  
 a.  What is the name of the array that is being declared?  
 b.   What is the size of the array?  
 c.  What data type are the array elements?  
 d.   What is the subscript of the last element in the array?  
 6.8.  What does “array bounds checking” mean?  
 6.9.  What is an off-by-one error?  
 
6.2  Sequentially Searching an Array 
 CONCEPT:   The sequential search algorithm is a simple technique for finding an 
item in an array. It steps through the array, beginning at the first ele-
ment, and compares each element to the item being searched for. The 
search stops when the item is found or the end of the array is reached.  
 Programs commonly need to search for data that is stored in an array. Various 
techniques known as  search algorithms have been developed to locate a specific 
item in a larger collection of data, such as an array. This section shows you how to 
use the simplest of all search algorithms—the sequential search. The  sequential 
search algorithm uses a loop to sequentially step through an array, starting with the 
first element. It compares each element with the value being searched for and stops 
when the value is found or the end of the array is encountered. If the value being 
searched for is not in the array, the algorithm unsuccessfully searches to the end of 
the array. 
 Figure   6-4 shows the general logic of the sequential search algorithm. Here is a sum-
mary of the data items in the figure: 
 ●  array is the array being searched.  
 ●  searchValue is the value that the algorithm is searching for.  
 ●  found is a  bool variable that is used as a flag. Setting  found to  false indicates 
that  searchValue has not been found. Setting  found to  true indicates that 
 searchValue has been found.  
 ●  index is an  int variable used to step through the elements of the array.  
 When the algorithm finishes, the  found variable will be set to  true if the  searchValue 
was found in the array. When this is the case, the  index variable will be set to the 
subscript of the element containing the  searchValue . If the  searchValue was not 
found in the array,  found will be set to  false . The following shows the C++ code for 
this logic: 
 found = false; 
 index = 0; 
 while (found == false && index < SIZE) 

 
6.2 Sequentially Searching an Array 
217
 { 
   if (array[index] == searchValue) 
   { 
      found = true; 
   } 
   else 
   { 
      index = index + 1; 
   } 
 } 
found == False 
AND index < SIZE 
index = 0
True
False
found = false
array[index] ==
searchValue
True
found = true
False
index = index + 1
 Figure 6-4  Sequential search logic  
 The code in Program 6-4 demonstrates how to implement the sequential search in 
a program. This program has an array that holds test scores. It sequentially searches 
the array for a score of 100. If a score of 100 is found, the program displays the 
test number. 

218 
Chapter 6 
 Arrays
 Program 6-4 
 (SequentialSearch.cpp) 
 1 #include <iostream> 
 2 using namespace std; 
 3  
 4 int main() 
 5 { 
 6    // Constant for the array size. 
 7    const int SIZE = 10; 
 8  
 9    // Declare an array to hold test scores. 
 10    int scores[SIZE] = { 87, 75, 98, 100, 82, 
 11                         72, 88, 92, 60,  78 }; 
 12  
 13    // Declare a Boolean variable to act as a flag. 
 14    bool found; 
 15  
 16    // Declare a variable to step through the array. 
 17    int index; 
 18  
 19    // The flag must initially be set to False. 
 20    found = false; 
 21  
 22    // Set the counter variable to 0. 
 23    index = 0; 
 24  
 25    // Step through the array searching for a 
 26    // score equal to 100. 
 27    while (found == false && index < SIZE) 
 28    { 
 29       if (scores[index] == 100) 
 30       { 
 31         found = true; 
 32       } 
 33       else 
 34       { 
 35         index = index + 1; 
 36       } 
 37    } 
 38  
 39    // Display the search results. 
 40    if (found) 
 41    { 
 42       cout << "you earned 100 on test number " 
 43            << (index + 1) << endl; 
 44    } 
 45    else 
 46    { 
 47       cout << "you did not earn 100 on any test." << endl; 
 48    } 
 49    return 0; 
 50 } 
 Program Output 
 You earned 100 on test number 4  

 
6.2 Sequentially Searching an Array 
219
 Searching a String Array 
 Program 6-4 demonstrates how to use the sequential search algorithm to find a spe-
cific number in an  int array. As shown in Program 6-5, you can also use the algorithm 
to find a string in a  string array. 
 Program 6-5 
 (StringSearch.cpp) 
 1 #include <iostream> 
 2 #include <string> 
 3 using namespace std; 
 4  
 5 int main() 
 6 { 
 7    // Declare a constant for the array size. 
 8    const int SIZE = 6; 
 9  
 10    // Declare a string array initialized with values. 
 11    string cars[SIZE] = { "BMW", "Audi", "Lamborghini", 
 12                          "Mercedes", "Porsche", "Ferrari" }; 
 13  
 14    // Declare a variable to hold the search value. 
 15    string searchValue; 
 16  
 17    // Declare a Boolean variable to act as a flag. 
 18    bool found; 
 19  
 20    // Declare a variable to step through the array. 
 21    int index; 
 22  
 23    // The flag must initially be set to False. 
 24    found = false; 
 25  
 26    // Set the counter variable to 0. 
 27    index = 0; 
 28  
 29    // Get the string to search for. 
 30    cout << "What car should I search for? "; 
 31    cin >> searchValue; 
 32  
 33    // Step through the array searching for 
 34    // the specified name. 
 35    while (found == false && index < SIZE) 
 36    { 
 37       if (cars[index] == searchValue) 
 38       { 
 39         found = true; 
 40       } 
 41       else 
 42       { 
 43         index = index + 1; 
 44       } 
 45    } 
 46  

220 
Chapter 6 
 Arrays
 47    // Display the search results. 
 48    if (found) 
 49    { 
 50       cout << "That car was found in element " 
 51            << index << endl; 
 52    } 
 53    else 
 54    { 
 55       cout << "That car was not found in the array." << endl; 
 56    } 
 57    return 0; 
 58 } 
 Program Output with Input Shown in Bold 
 What car should I search for?  Mercedes [ Enter ] 
 That car was found in element 3  
 Program Output 
 What car should I search for?  Fiat [ Enter ] 
 That car was not found in the array.  
 Checkpoint 
 6.10.   What is a search algorithm?  
 6.11.   Which array element does the sequential search algorithm look at first?  
 6.12.   What does the loop do in the sequential search algorithm? What happens when 
the value being searched for is found?  
 6.13.   How many elements does the sequential search algorithm look at in the case 
that the search value is not found in the array?  
 
6.3  Processing the Contents of an Array 
 In this chapter you’ve seen several examples of how loops are used to step through 
the elements of an array. You can perform many operations on an array using a loop, 
and this section examines several such algorithms. 
 Copying an Array 
 If you need to copy the contents of one array to another, you have to assign the 
individual elements of the array that you are copying to the elements of the 

 
6.3 Processing the Contents of an Array 
221
other array. Usually this is best done with a loop. For example, look at the fol-
lowing code: 
 const int SIZE = 5; 
 int firstArray[SIZE] = { 100, 200, 300, 400, 500 }; 
 int secondArray[SIZE];  
 Suppose you wish to copy the values in  firstArray to  secondArray . The following 
code assigns each element of  firstArray to the corresponding element in 
 secondArray . 
 for (int index = 0; index < SIZE; index++) 
 { 
     secondArray[index] = firstArray[index]; 
 } 
 Comparing Arrays 
 You cannot use the  == operator to compare two arrays and determine whether the 
arrays are equal. For example, the following code sample appears to compare two 
arrays, but in reality does not: 
 1 const int SIZE = 5; 
 2 int firstArray[SIZE]  = { 5, 10, 15, 20, 25 }; 
 3 int secondArray[SIZE] = { 5, 10, 15, 20, 25 }; 
 4  
 5 if (firstArray == secondArray) // This is a mistake. 
 6 { 
 7     cout << "The arrays are the same." << endl; 
 8 } 
 9 else 
 10 { 
 11     cout << "The arrays are not the same." << endl; 
 12 } 
 When you use the  == operator with two arrays, the operator compares the arrays’ 
starting memory addresses, not the contents of the arrays. Because the  firstArray and 
 secondArray variables in this example are stored at different memory addresses, the 
result of the Boolean expression  firstArray == secondArray is false, and the code 
reports that the arrays are not the same. 
 To compare the contents of two arrays, you must compare the individual elements of 
the two arrays. Program 6-6 shows an example. 
 Program 6-6 
 (CompareArrays.cpp) 
 1 #include <iostream> 
 2 using namespace std; 
 3  
 4 int main() 

222 
Chapter 6 
 Arrays
 5 { 
 6     // Declare a constant for the array size. 
 7    const int SIZE = 5; 
 8  
 9    // Declare and initialize two arrays. 
 10    int firstArray[SIZE]  = { 5, 10, 15, 20, 25 }; 
 11    int secondArray[SIZE] = { 5, 10, 15, 20, 25 }; 
 12  
 13    // Variables 
 14    bool arraysEqual = true; // Flag variable 
 15    int index = 0;           // To hold array subscripts 
 16  
 17    // Determine whether the elements contain the same data. 
 18    while (arraysEqual && index < SIZE) 
 19    { 
 20       if (firstArray[index] != secondArray[index]) 
 21       { 
 22          arraysEqual = false; 
 23       } 
 24       index++; 
 25    } 
 26  
 27    // Display the results. 
 28    if (arraysEqual) 
 29    { 
 30       cout << "The arrays are equal." << endl; 
 31    } 
 32    else 
 33    { 
 34       cout << "The arrays are not equal." << endl; 
 35    } 
 36    return 0; 
 37 } 
 Program Output 
 The arrays are equal.  
 This program determines whether  firstArray and  secondArray (declared in lines 
10 and 11) contain the same values. A  bool flag variable,  arraysEqual , declared 
and initialized to  true , is declared in line 14. The  arraysEqual variable is used to 
signal whether the arrays are equal. Another variable,  index , is declared and 
 initialized to 0 in line 15. The  index variable is used in a loop to step through 
the arrays. 
 Then a  while loop begins in line 18. The loop executes as long as  arraysEqual is 
true and the  index variable is less than  SIZE . During each iteration, it compares a 
different set of corresponding elements in the arrays. When it finds two corre-
sponding elements that have different values, the flag variable  arraysEqual is set 
to  false . 

 
6.3 Processing the Contents of an Array 
223
 After the loop finishes, an  if statement examines the  arraysEqual variable in line 28. If 
the variable is  true , then the arrays are equal, and a message indicating so is displayed 
in line 30. Otherwise, they are not equal, so a different message is displayed in line 34.  
 Totaling the Values in an Array 
 To calculate the total of the values in a numeric array, you use a loop with an ac-
cumulator variable.  Recall from  Chapter  4 that an  accumulator is a variable that 
is used to accumulate the total of a series of numbers. First, the accumulator is 
initialized with 0. Then, the loop steps through the array, adding the value of each 
array element to the accumulator. 
 Program 6-7 
 (TotalArray.cpp) 
 1 #include <iostream> 
 2 using namespace std; 
 3  
 4 int main() 
 5 { 
 6    // Declare a constant for the array size. 
 7    const int SIZE = 5; 
 8  
 9    // Create an int array. 
 10    int numbers[SIZE] = { 2, 4, 6, 8, 10 }; 
 11  
 12    // Declare and initialize an accumulator variable. 
 13    int total = 0; 
 14  
 15    // Step through the array, adding each element to 
 16    // the accumulator. 
 17    for (int index = 0; index < SIZE; index++) 
 18    { 
 19       total += numbers[index]; 
 20    } 
 21  
 22    // Display the total. 
 23    cout << "The total is " << total << endl; 
 24    return 0; 
 25 } 
 Program Output 
 The total is 30  
 Averaging the Values in an Array 
 The first step in calculating the average of all the values in a numeric array is to get 
the total of the values. The second step is to divide the total by the number of elements 
in the array. Program 6-8 shows an example. 

224 
Chapter 6 
 Arrays
 Program 6-8 
  (AverageArray.cpp) 
 1 #include <iostream> 
 2 using namespace std; 
 3  
 4 int main() 
 5 { 
 6     // Declare a constant for the array size. 
 7    const int SIZE = 4; 
 8  
 9    // Declare an array. 
 10    double scores[SIZE] = { 92.5, 81.6, 65.7, 72.8 }; 
 11  
 12    // Declare and initialize an accumulator variable. 
 13    double total = 0.0; 
 14  
 15    // Declare a variable to hold the average. 
 16    double average;  
 17  
 18    // Step through the array, adding each element to 
 19    // the accumulator. 
 20    for (int index = 0; index < SIZE; index++) 
 21    { 
 22       total += scores[index]; 
 23    } 
 24  
 25    // Calculate the average. 
 26    average = total / SIZE; 
 27  
 28    // Display the average. 
 29    cout << "The average is " <<  average << endl; 
 30    return 0; 
 31 } 
 Program Output 
 The average is 78.15  
 The loop in lines 20 through 23 gets the sum of the array elements, and line 26 
divides the sum by the size of the array. Notice that the calculation in line 26 is not 
inside the loop. This statement should only execute once, after the loop has finished 
its iterations.  
 Finding the Highest and Lowest Values 
in an Array 
 Some programming tasks require you to find the highest value in a set of data. 
Examples include programs that report the highest sales amount for a given time 
period, the highest test score in a set of test scores, the highest temperature for a given 
set of days, and so forth. 

 
6.3 Processing the Contents of an Array 
225
 The algorithm for finding the highest value in an array works like this: You create 
a variable to hold the highest value (the following example names this variable 
 highest ). Then, you assign the value at element 0 to the  highest variable. Next, 
you use a loop to step through the rest of the array elements, beginning at element 
1. Each time the loop iterates, it compares an array element to the  highest vari-
able. If the array element is greater than the  highest variable, then the value in the 
array element is assigned to the  highest variable. When the loop finishes, the 
 highest variable will contain the highest value in the array. The flowchart in 
 Figure   6-5 illustrates this logic. Program 6-9 shows a simple demonstration of the 
algorithm.  
index < SIZE
index = 1 
True
False
highest = array[0]
array[index] >
highest
True
highest = array[index]
False
index = index + 1
 Figure 6-5  Flowchart for finding the highest value in an array  

226 
Chapter 6 
 Arrays
 Program 6-9 
 (HighestElement.cpp) 
 1 #include <iostream> 
 2 using namespace std; 
 3  
 4 int main() 
 5 { 
 6    // Declare a constant for the array size. 
 7    const int SIZE = 5; 
 8  
 9    // Declare an array. 
 10    int numbers[SIZE] = { 8, 1, 12, 6, 2 }; 
 11  
 12    // Declare a variable to hold the highest value, and 
 13    // initialize it with the first value in the array. 
 14    int highest = numbers[0]; 
 15  
 16    // Step through the rest of the array, beginning at 
 17    // element 1. When a value greater than highest is found, 
 18    // assign that value to highest. 
 19    for (int index = 1; index < SIZE; index++) 
 20    { 
 21       if (numbers[index] > highest) 
 22       { 
 23          highest = numbers[index]; 
 24       } 
 25    } 
 26  
 27    // Display the highest value. 
 28    cout << "The highest value is " << highest << endl; 
 29    return 0; 
 30 } 
 Program Output 
 The highest value is 12  
 In some programs you are more interested in finding the lowest value than the highest 
value in a set of data. For example, suppose you are writing a program that stores 
several players’ golf scores in an array, and you need to find the best score. In golf, the 
lower the score the better, so you would need an algorithm that finds the lowest value 
in the array. 
 The algorithm for finding the lowest value in an array is very similar to the algo-
rithm for finding the highest score. It works like this: You create a variable to hold 
the lowest value (the following example names this variable  lowest ). Then, you 
assign the value at element 0 to the  lowest variable. Next, you use a loop to step 
through the rest of the array elements, beginning at element 1. Each time the loop 
iterates, it compares an array element to the  lowest variable. If the array element is 
less than the  lowest variable, then the value in the array element is assigned to the 
 lowest variable. When the loop finishes, the  lowest variable will contain the lowest 

 
6.3 Processing the Contents of an Array 
227
index < SIZE
index = 1
True
False
lowest = array[0]
array[index] <
lowest
True
lowest = array[index]
False
index = index + 1
 Figure 6-6  Flowchart for finding the lowest value in an array  
value in the array. The flowchart in  Figure  6-6  illustrates this logic. Program 6-10 
demonstrates this algorithm.  
 Program 6-10 
 (LowestElement.cpp) 
 1 #include <iostream> 
 2 using namespace std; 
 3  
 4 int main() 
 5 { 
 6    // Declare a constant for the array size. 
 7    const int SIZE = 5; 

228 
Chapter 6 
 Arrays
 8  
 9    // Declare an array. 
 10    int numbers[SIZE] = { 8, 1, 12, 6, 2 }; 
 11  
 12    // Declare a variable to hold the lowest value, and 
 13    // initialize it with the first value in the array. 
 14    int lowest = numbers[0]; 
 15  
 16    // Step through the rest of the array, beginning at 
 17    // element 1. When a value less than lowest is found, 
 18    // assign that value to lowest. 
 19    for (int index = 1; index < SIZE; index++) 
 20    { 
 21       if (numbers[index] < lowest) 
 22       { 
 23          lowest = numbers[index]; 
 24       } 
 25    } 
 26  
 27    // Display the lowest value. 
 28    cout << "The lowest value is " << lowest << endl; 
 29    return 0; 
 30 } 
 Program Output 
 The lowest value is 1  
 Passing an Array as an Argument to a Function 
 You can pass an array as an argument to a function, which gives you the ability 
to modularize many of the operations that you perform on the array. Passing an 
array as an argument typically requires that you pass two arguments: (1) the array 
itself, and (2) an integer that specifies the number of elements in the array. The 
following code shows a function that has been written to accept an array as an 
argument: 
 void showArray(int array[], int size) 
 { 
   for (int i = 0; i < size; i++) 
   { 
      cout << array[i] << " "; 
   } 
 } 
 Notice that the parameter variable,  array , is declared as an  int array, without a size 
declarator. When we call this function, we must pass an  int array to it as an argument. 
Let’s assume that  numbers is the name of an  int array, and  SIZE is a constant that 
specifies the size of the array. Here is a statement that calls the  showArray function, 
passing the  numbers array and  SIZE as arguments: 
 showArray(numbers, SIZE);  
VideoNote
Passing an array to 
a function

 
6.3 Processing the Contents of an Array 
229
 Program 6-11 shows another example. This program has a function that accepts an 
 int array as an argument. The function returns the total of the array’s elements. 
 Program 6-11 
 (ArrayArgument.cpp) 
 1 #include <iostream> 
 2 using namespace std; 
 3  
 4 // Function prototype 
 5 int getTotal(int[], int ); 
 6  
 7 int main() 
 8 { 
 9    // A constant for the array size 
 10    const int SIZE = 5; 
 11  
 12    // An array initialized with values 
 13    int numbers[SIZE] = { 2, 4, 6, 8, 10 }; 
 14  
 15    // A variable to hold the sum of the elements 
 16    int sum; 
 17  
 18    // Get the sum of the elements. 
 19    sum = getTotal(numbers, SIZE); 
 20  
 21    // Display the sum of the array elements. 
 22    cout << "The sum of the array elements is " 
 23         << sum << endl; 
 24  
 25    return 0; 
 26 } 
 27  
 28 // The getTotal function accepts an Integer array, and the 
 29 // array's size as arguments. It returns the total of the 
 30 // array elements. 
 31 int getTotal(int arr[], int size) 
 32 { 
 33    // Accumulator, initialized to 0 
 34    int total = 0; 
 35     
 36    // Calculate the total of the array elements. 
 37    for (int index = 0; index < size; index++) 
 38    { 
 39       total = total + arr[index]; 
 40    } 
 41  
 42    // Return the total. 
 43    return total; 
 44 } 
 Program Output 
 The sum of the array elements is 30  

230 
Chapter 6 
 Arrays
 In the  main function, an  int array is declared in line 13 and initialized with five values. 
In line 19, the following statement calls the  getTotal function and assigns its return 
value to the  sum variable: 
 sum = getTotal(numbers, SIZE);  
 This statement passes two arguments to the  getTotal function: the  numbers array and 
the value of the  SIZE constant. Here is the first line of the  getTotal function, which 
appears in line 31: 
 int getTotal(int arr[], int size)  
 Notice that the function has the following two parameters: 
 ●  int arr[] —This parameter accepts an array of  int s as an argument. 
 ●  int size —This parameter accepts an integer that specifies the number of ele-
ments in the array.  
 When the function is called in line 19, it passes the  numbers array into the  arr parameter 
and the value of the  SIZE constant into the  size parameter. This is shown in  Figure  6-7 . 
The function then calculates the total of the values in array and returns that value.  
int getTotal(int arr[], int size)
sum = getTotal(numbers, SIZE);
2
4
6
8
10
5
 Figure 6-7  Passing arguments to the  getTotal function  
 Partially Filled Arrays 
 Sometimes you need to store a series of items in an array, but you do not know the 
total number of items. As a result, you do not know the exact number of elements 
needed for the array. One solution is to make the array large enough to hold the larg-
est possible number of items. This can lead to another problem, however. If the actual 
number of items stored in the array is less than the number of elements, the array will 
only be partially filled. When you process a partially filled array, you must process 
only the elements that contain valid data items. 
 A partially filled array is normally used with an accompanying integer variable that 
holds the number of items stored in the array. For example, suppose a program uses 
the following code to create an array named  myNumbers with 100 elements and an  int 
variable named  count that will hold the number of items stored in the array: 
 const int SIZE = 100; 
 int myNumbers[SIZE]; 
 int count = 0;  

 
6.3 Processing the Contents of an Array 
231
 Each time we add an item to the array, we must increment  count . The following code 
demonstrates: 
 int number; 
 // Get a number from the user. 
 cout << "Enter a number or −1 to quit: "; 
 cin >> number; 
 // Add numbers to the myNumbers array until the user 
 // enters −1. 
 while (number != −1 && count < SIZE) 
 { 
    // Increment count. 
    count++; 
    // Add the number to the array. 
    myNumbers[count − 1] = number; 
    // Get the next number 
    cout << "Enter a number or −1 to quit: "; 
    cin >> number; 
 } 
 Each iteration of this loop allows the user to enter a number to be stored in the 
array, or −1 to quit. The  count variable is incremented and then used to calculate 
the subscript of the next available element in the array. When the user enters −1, or 
 count exceeds 99, the loop stops. The following code displays all the valid items in 
the array: 
 for (int index = 0; index < count; index++) 
 { 
    cout << myNumbers[index] << endl; 
 } 
 Notice that this code uses  count instead of the array size to determine where the array 
subscripts end. 
 Program 6-12 shows an example that uses a partially filled array. 
 Program 6-12 
 (PartiallyFilledArray.cpp) 
 1 #include <iostream> 
 2 using namespace std; 
 3  
 4 int main() 
 5 { 
 6    // Declare a constant for the array size. 
 7    const int SIZE = 100; 
 8  
 9    // Declare an array. 
 10    int values[SIZE]; 
 11  

232 
Chapter 6 
 Arrays
 12    // Declare a variable to hold the number of items 
 13    // that are actually stored in the array. 
 14    int count = 0; 
 15  
 16    // Declare a variable to hold the user's input. 
 17    int number; 
 18  
 19    // Prompt the user to enter a number. If the user enters 
 20    // −1 we will stop accepting input. 
 21    cout << "Enter a number or −1 to quit: "; 
 22    cin >> number; 
 23  
 24    // If the input is not −1 and the array is not 
 25    // full, process the input. 
 26    while (number != −1 && count < SIZE) 
 27    { 
 28       // Store the input in the array. 
 29       values[count] = number; 
 30  
 31       // Increment count. 
 32       count++; 
 33  
 34       // Prompt the user for the next number. 
 35       cout << "Enter a number or −1 to quit: "; 
 36       cin >> number; 
 37    } 
 38     
 39    // Display the values stored in the array. 
 40    cout < "Here are the numbers you entered:" << endl; 
 41    for (int index = 0; index < count; index++) 
 42    { 
 43       cout << values[index] << endl; 
 44    } 
 45    return 0; 
 46 } 
 Program Output with Input Shown in Bold 
 Enter a number or −1 to quit:  2 [ Enter ] 
 Enter a number or −1 to quit:  4 [ Enter ] 
 Enter a number or −1 to quit:  6 [ Enter ] 
 Enter a number or −1 to quit:  −1 [ Enter ] 
 Here are the numbers you entered: 
 2 
 4 
 6  
 Let’s examine the code in detail. Line 7 declares a constant,  SIZE , initialized with 
the value 100. Line 10 declares an  int array named  values , using  SIZE as the size 
declarator. As a result, the  values array will have 100 elements. Line 14 declares 
an  int variable named  count , which will hold the number of items that are stored 
in the  values array. Notice that  count is initialized with 0 because no values are 

 
6.3 Processing the Contents of an Array 
233
stored in the array. Line 17 declares an  int variable named  number that will hold 
values entered by the user. 
 Line 21 prompts the user to enter a number or −1 to quit. When the user enters −1, the 
program will stop reading input. Line 22 reads the user’s input and stores it in the 
 number variable. A  while loop begins in line 26. The loop iterates as long as  number is 
not −1 and  count is less than the size of the array. Inside the loop, in line 29 the  numbers 
variable is assigned to  values[count] , and in line 32 the  count variable is incremented. 
(Each time a number is assigned to an array element, the  count variable is incremented. 
As a result, the  count variable will hold the number of items that are stored in the 
array.) Then, line 35 prompts the user to enter another number (or −1 to quit), and line 
36 reads the user’s input into the  number variable. The loop then starts over. 
 When the user enters −1, or  count reaches the size of the array, the  while loop stops. 
The  for loop that begins in line 41 displays all the items that are stored in the array. 
Rather than stepping through all of the elements in the array, however, the loop steps 
through only the elements that contain values. Notice that the loop iterates as long as 
 index is less than  count . The loop will stop when the element containing the last valid 
value has been displayed, not when the end of the array has been reached.  
 In the Spotlight: 
 Processing an Array 
 Dr. LaClaire gives four exams during the semester in her chemistry class. At the end 
of the semester she drops each student’s lowest test score before averaging the scores. 
She has asked you to write a program that will read a student’s four test scores as 
input and calculate the average with the lowest score dropped. Here is the pseudocode 
algorithm that you developed: 
 Read the student’s four test scores. 
 Calculate the total of the scores. 
 Find the lowest score. 
 Subtract the lowest score from the total. This gives the adjusted total. 
 Divide the adjusted total by 3. This is the average. 
 Display the average. 
 Program 6-13 shows the program, which is modularized. Rather than presenting the 
entire program at once, let’s first examine the  main function and then each additional 
function separately. Here is the first part of the program, including the  main function: 
 Program 6-13 
  (main function) 
 1 #include <iostream> 
 2 using namespace std; 
 3  
 4 // Function prototypes 
 5 void getTestScores(double[], int); 

234 
Chapter 6 
 Arrays
 6 double getTotal(double[], int); 
 7 double getLowest(double[], int); 
 8  
 9 int main() 
 10 { 
 11    const int SIZE = 4;       // Array size 
 12    double testScores[SIZE],  // Array of test scores 
 13           total,            // Total of the scores 
 14           lowestScore,       // Lowest test score 
 15           average;          // Average test score 
 16  
 17    // Get the test scores from the user. 
 18    getTestScores(testScores, SIZE); 
 19  
 20    // Get the total of the test scores. 
 21    total = getTotal(testScores, SIZE); 
 22  
 23    // Get the lowest test score. 
 24    lowestScore = getLowest(testScores, SIZE); 
 25  
 26    // Subtract the lowest score from the total. 
 27    total −= lowestScore; 
 28  
 29    // Calculate the average. Divide by 3 because 
 30    // the lowest test score was dropped. 
 31    average = total / (SIZE − 1); 
 32  
 33    // Display the average. 
 34    cout << "The average with the lowest score " 
 35         << "dropped is " << average << ".\n"; 
 36  
 37    return 0; 
 38 } 
 39 
 Lines 11 through 15 define the following items: 
 •  SIZE , an  int constant that is used as an array size declarator  
 •  testScores , a  double array to hold the test scores  
 •  total , a  double variable that will hold the test score totals  
 •  lowestScore , a  double variable that will hold the lowest test score  
 •  average , a  double variable that will hold the average of the test scores  
 Line 18 calls the  getTestScores function, passing the  testScores array and the value 
of the  SIZE constant as arguments. The function gets the test scores from the user and 
stores them in the array. 
 Line 21 calls the  getTotal function, passing the  testScores array and the value of the 
 SIZE constant as arguments. The function returns the total of the values in the array. 
This value is assigned to the  total variable. 
 Line 23 calls the  getLowest function, passing the  testScores array and the value of 
the  SIZE constant as arguments. The function returns the lowest value in the array. 
This value is assigned to the  lowestScore variable. 

 
6.3 Processing the Contents of an Array 
235
 Line 27 subtracts the lowest test score from the  total variable. Then, line 31 calcu-
lates the average by dividing  total by  SIZE  –  1 . (The program divides by  SIZE  –  1 
because the lowest test score was dropped.) Lines 34 and 35 display the average. 
 The  getTestScores function appears next, as shown here: 
 Program 6-13 
  (getTestScores function) 
 40 // The getTestScores function accepts an array and its size 
 41 // as arguments. It prompts the user to enter test scores, 
 42 // which are stored in the array. 
 43 void getTestScores(double scores[], int size) 
 44 { 
 45    // Get each test score. 
 46    for(int index = 0; index <= size − 1; index++) 
 47    { 
 48       cout << "Enter test score number " 
 49            << (index + 1) << ": "; 
 50       cin > scores[index]; 
 51    } 
 52 } 
 53 
 The  getTestScores function has two parameters:  
 •  scores[] —A  double array  
 •  size —An  int specifying the size of the array that is passed into the  scores[] 
parameter  
 The purpose of this function is to get a student’s test scores from the user and store 
them in the array that is passed as an argument into the  scores[] parameter. 
 The  getTotal function appears next, as shown here: 
 Program 6-13 
 (getTotal function) 
 54 // The getTotal function accepts a double array 
 55 // and its size as arguments. The sum of the array's 
 56 // elements is returned as a double. 
 57 double getTotal(double array[], int size) 
 58 { 
 59    double total = 0; // Accumulator 
 60  
 61    // Add each element to total. 
 62    for (int count = 0; count < size; count++) 
 63    { 
 64       total += array[count]; 
 65    } 
 66  
 67    // Return the total. 
 68    return total; 
 69 } 
 70 

236 
Chapter 6 
 Arrays
 The  getTotal function has two parameters: 
 •  array[] —A  double array  
 •  size —An  int specifying the size of the array that is passed into the  array[] 
parameter  
 This function returns the total of the values in the array that is passed as an argument 
into the  array[] parameter. 
 The  getLowest function appears next, as shown here: 
 Program 6-13 
 (getlowest function) 
 71 // The getLowest function accepts a double array and 
 72 // its size as arguments. The lowest value in the 
 73 // array is returned as a double. 
 74 double getLowest(double array[], int size) 
 75 { 
 76    double lowest;  // To hold the lowest value 
 77  
 78    // Get the first array's first element. 
 79    lowest = array[0]; 
 80  
 81    // Step through the rest of the array. When a 
 82    // value less than lowest is found, assign it 
 83    // to lowest. 
 84    for (int count = 1; count < size; count++) 
 85    { 
 86      if (array[count] < lowest) 
 87      { 
 88          lowest = array[count]; 
 89      } 
 90    } 
 91  
 92    // Return the lowest value. 
 93    return lowest; 
 94 } 
 The  getLowest function has two parameters: 
 •  array[] —A  double array  
 •  size —An  int specifying the size of the array that is passed into the  array[] 
parameter  
 This function returns the lowest value in the array that is passed as an argument into 
the  array[] parameter. Here is an example of the program’s output: 
 Program Output with Example Input Shown in Bold 
 Enter test score number 1:  92 [ Enter ] 
 Enter test score number 2:  67 [ Enter ] 
 Enter test score number 3:  75 [ Enter ] 
 Enter test score number 4:  88 [ Enter ] 
 The average with the lowest score dropped is 85  

 
6.4 Parallel Arrays 
237
 Checkpoint 
 6.14.  Briefly describe how you calculate the total of the values in an array.  
 6.15.  Briefly describe how you get the average of the values in an array.  
 6.16.  Describe the algorithm for finding the highest value in an array.  
 6.17.  Describe the algorithm for finding the lowest value in an array.  
 6.18.  How do you copy the contents of one array to another array?  
 
6.4  Parallel Arrays 
 CONCEPT:   By using the same subscript, you can establish relationships between 
data stored in two or more arrays.  
 Sometimes it is useful to store related data in two or more arrays. For example, as-
sume you have designed a program with the following array declarations: 
 const int SIZE = 5; 
 string names[SIZE]; 
 int idNumbers[SIZE];  
 The  names array stores the names of five people, and the  idNumbers array stores the ID 
numbers of the same five people. The data for each person is stored in the same relative 
location in each array. For instance, the first person’s name is stored in  names[0] , and 
that same person’s ID number is stored in  idNumbers[0] .  Figure   6-8 illustrates this. To 
Person
#1
Person
#2
Person
#3
Person
#4
Person
#5
names[0]
idNumbers
[0]
names[1]
names[2]
names[3]
names[4]
idNumbers
[1]
idNumbers
[4]
idNumbers
[2]
idNumbers
[3]
 Figure 6-8  The  names and  idNumbers arrays 

238 
Chapter 6 
 Arrays
access the data, you use the same subscript with both arrays. For example, the loop in 
the following code displays each person’s name and address: 
 for (int index = 0; index < SIZE; index++) 
 { 
   cout << names[index] << endl; 
   cout << addresses[index] << endl; 
 } 
 The  names and  idNumbers arrays are examples of parallel arrays.  Parallel arrays are 
two or more arrays that hold related data, and the related elements in each array are 
accessed with a common subscript. 
 Program 6-14, another payroll program variation, demonstrates. It uses two arrays: 
one to store the hours worked by each employee (as  int s), and another to store each 
employee’s hourly pay rate (as  double s). 
 Program 6-14 
 (ParallelArrays.cpp) 
 1 #include <iostream> 
 2 using namespace std; 
 3 int main() 
 4 { 
 5    const int NUM_EMPLOYEES = 3;   // Number of employees 
 6    int hours[NUM_EMPLOYEES];      // Holds hours worked 
 7    double payRate[NUM_EMPLOYEES]; // Holds pay rates 
 8    double grossPay;               // Holds gross pay 
 9  
 10    // Input the hours worked and the hourly pay rate. 
 11    cout << "Enter the hours worked by " << NUM_EMPLOYEES 
 12         << " employees and their" << endl; 
 13    cout << "hourly pay rates." << endl; 
 14  
 15    for (int index = 0; index < NUM_EMPLOYEES; index++) 
 16    { 
 17       cout << "Hours worked by employee #" 
 18            << index+1 << ": "; 
 19       cin >> hours[index]; 
 20  
 21       cout << "Hourly pay rate for employee #" 
 22            << index+1 << ": "; 
 23       cin >> payRate[index]; 
 24    } 
 25  
 26    // Display each employee's gross pay. 
 27    cout << "Gross pay for each employee:" << endl; 
 28    for (int index = 0; index < NUM_EMPLOYEES; index++) 
 29    { 
 30       grossPay = hours[index] * payRate[index]; 
 31       cout << "Employee #" << index + 1 
 32            << ": $" << grossPay << endl; 
 33    } 
 34    return 0; 
 35 } 

 
6.5 Two-Dimensional Arrays 
239
 Program Output with Input Shown in Bold 
 Enter the hours worked by 3 employees and their 
 hourly pay rates. 
 Hours worked by employee #1:  15 [ Enter ] 
 Hourly pay rate for employee #1:  10.00 [ Enter ] 
 Hours worked by employee #2:  20 [ Enter ] 
 Hourly pay rate for employee #2:  12.00 [ Enter ] 
 Hours worked by employee #3:  40 [ Enter ] 
 Hourly pay rate for employee #3:  15.00 [ Enter ] 
 Here is the gross pay for each employee: 
 Employee #1: $150 
 Employee #2: $240 
 Employee #3: $600  
 Checkpoint 
 6.19.  How do you establish a relationship between the data stored in two parallel 
arrays?  
 6.20.  A program uses two parallel arrays:  names and  creditScore . The  names array 
holds customer names, and the  creditScore array holds customer credit scores. 
If a particular customer’s name is stored in  names[82] , where would that cus-
tomer’s credit score be stored?  
 
6.5  Two-Dimensional Arrays 
 CONCEPT:   A two-dimensional array is like several identical arrays put together. 
It is useful for storing multiple sets of data.  
 The arrays that you have studied so far are known as one-dimensional arrays. They 
are called  one dimensional because they can hold only one set of data. Two-
dimensional arrays, which are also called  2-D arrays, can hold multiple sets of data. 
Think of a two-dimensional array as having rows and columns of elements, as shown 
in  Figure  6-9  .  
Row 0
Row 1
Row 2
Column 0
Column 1
Column 2
Column 3
 Figure 6-9  A two-dimensional array  

240 
Chapter 6 
 Arrays
 This figure shows a two-dimensional array having three rows and four columns. 
Notice that the rows are numbered 0, 1, and 2, and the columns are numbered 0, 1, 
2, and 3. This creates a total of twelve elements in the array. 
 Two-dimensional arrays are useful for working with multiple sets of data. For 
example, suppose you are designing a grade-averaging program for a teacher. The 
teacher has six students, and each student takes five exams during the semester. One 
approach would be to create six one-dimensional arrays, one for each student. Each 
of these arrays would have five elements, one for each exam score. This approach 
would be cumbersome, however, because you would have to separately process each 
of the arrays. A better approach would be to use a two-dimensional array with six 
rows (one for each student) and five columns (one for each exam score), as shown 
in  Figure   6-10 .  
Row 0
Row 1
Row 2
Column 0
Column 1
Column 2
Column 3
Row 3
Row 4
Row 5
Column 4
This row is for student #1.
This column
contains
 scores for
exam #1.
This column
contains
 scores for
exam #2.
This column
contains
 scores for
exam #3.
This column
contains
 scores for
exam #4.
This column
contains
 scores for
exam #5.
This row is for student #2.
This row is for student #3.
This row is for student #4.
This row is for student #5.
This row is for student #6.
 Figure 6-10  Two-dimensional array with six rows and five columns  
 Declaring a Two-Dimensional Array 
 To declare a two-dimensional array, two size declarators are required: The first one 
is for the number of rows, and the second one is for the number of columns. The 
following code sample shows an example of how to declare a two-dimensional 
array: 
 int values[3][4];  
 This statement declares a two-dimensional integer array with three rows and four 
columns. The name of the array is  values , and it has a total of twelve elements in the 
array. As with one-dimensional arrays, it is best to use named constants as the size 
declarators. Here is an example: 

 
6.5 Two-Dimensional Arrays 
241
 const int ROWS = 3; 
 const int COLS = 4; 
 int values[ROWS][COLS];  
 When processing the data in a two-dimensional array, each element has two sub-
scripts: one for its row and another for its column. In the  values array, the elements 
in row 0 are referenced as follows: 
 values[0][0] 
 values[0][1] 
 values[0][2] 
 values[0][3]  
 The elements in row 1 are as follows: 
 values[1][0] 
 values[1][1] 
 values[1][2] 
 values[1][3]  
 And the elements in row 2 are as follows: 
 values[2][0] 
 values[2][1] 
 values[2][2] 
 values[2][3]  
 Figure   6-11 illustrates the array with the subscripts shown for each element.  
Row 0
Row 1
Row 2
Column 0
Column 1
Column 2
Column 3
values[0][0]
values[1][0]
values[2][0]
values[0][1]
values[1][1]
values[2][1]
values[0][2]
values[1][2]
values[2][2]
values[0][3]
values[1][3]
values[2][3]
 Figure 6-11  Array with subscripts shown for each element  
 Accessing the Elements in a Two-Dimensional Array 
 To access one of the elements in a two-dimensional array, you must use both sub-
scripts. For example, the following statement assigns the number 95 to  values[2][1] : 
 values[2][1] = 95;  
 Programs that process two-dimensional arrays commonly do so with nested loops. 
The code in Program 6-15 shows an example. It declares an array with three rows and 
four columns, prompts the user for values to store in each element, and then displays 
the values in each element. 

242 
Chapter 6 
 Arrays
 Program 6-15 
  (TwoDimensionalArray.cpp) 
 1 #include <iostream> 
 2 using namespace std; 
 3  
 4 // Function prototype 
 5 int getTotal(int[], int ); 
 6  
 7 int main() 
 8 { 
 9    // Create a 2D array 
 10    const int ROWS = 3; 
 11    const int COLS = 4; 
 12    int values[ROWS][COLS]; 
 13  
 14    // Counter variables for rows and columns 
 15    int row, col; 
 16  
 17    // Get values to store in the array. 
 18    for (row = 0; row <= ROWS - 1; row++) 
 19    { 
 20       for (col = 0; col <= COLS - 1; col++) 
 21       { 
 22         cout << "Enter a number: "; 
 23         cin >> values[row][col]; 
 24       } 
 25    } 
 26  
 27    // Display the values in the array. 
 28    cout << "Here are the values you entered." << endl; 
 29    for (row = 0; row <= ROWS - 1; row++) 
 30    { 
 31       for (col = 0; col <= COLS - 1; col++) 
 32       { 
 33         cout << values[row][col] << endl; 
 34       } 
 35    } 
 36  
 37    return 0; 
 38 } 
 Program Output 
 Enter a number:  1 [ Enter ] 
 Enter a number:  2 [ Enter ] 
 Enter a number:  3 [ Enter ] 
 Enter a number:  4 [ Enter ] 
 Enter a number:  5 [ Enter ] 
 Enter a number:  6 [ Enter ] 
 Enter a number:  7 [ Enter ] 
 Enter a number:  8 [ Enter ] 
 Enter a number:  9 [ Enter ] 

 
6.5 Two-Dimensional Arrays 
243
 Enter a number:  10 [ Enter ] 
 Enter a number:  11 [ Enter ] 
 Enter a number:  12 [ Enter ] 
 Here are the values you entered. 
 1 
 2 
 3 
 4 
 5 
 6 
 7 
 8 
 9 
 10 
 11 
 12  
 When initializing a two-dimensional array, it helps to enclose each row’s initialization 
list in a set of braces. Here is an example: 
 const int ROWS = 3; 
 const int COLS = 2; 
 int values[ROWS][COLS] = { {8, 5}, {7, 9}, {6, 3} };  
 The same declaration could also be written as: 
 const int ROWS = 3; 
 const int COLS = 2; 
 int values[ROWS][COLS] = { {8, 5}, 
                         {7, 9}, 
                         {6, 3} };  
 In either case, the initial values are assigned to the  values array in the following 
manner: 
 values[0][0] is set to 8 
 values[0][1] is set to 5 
 values[1][0] is set to 7 
 values[1][1] is set to 9 
 values[2][0] is set to 6 
 values[2][1] is set to 3  
 The extra braces that enclose each row’s initialization list are optional. Both the fol-
lowing statements perform the same initialization: 
 const int ROWS = 3; 
 const int COLS = 2; 
 int values[ROWS][COLS] = {{8, 5}, {7, 9}, {6, 3}}; 
 int values[ROWS][COLS] = {8, 5, 7, 9, 6, 3};  
 Because the extra braces visually separate each row, however, it’s a good idea to use them.  

244 
Chapter 6 
 Arrays
 Passing Two-Dimensional Arrays 
to Functions 
 Program 6-16 demonstrates passing a two-dimensional array to a function. When a 
two-dimensional array is passed to a function, the parameter type must contain a size 
declarator for the number of columns. Here is the header for the function  showArray , 
from Program 6-16: 
 void showArray(const int array[][COLS], int rows)  
 COLS is a global named constant that is set to 4. The function can accept any two-
dimensional integer array, as long as it consists of four columns. In the program, the 
contents of two separate arrays are displayed by the function. 
 Program 6-16 
  (Pass2dArray.cpp) 
 1 #include <iostream> 
 2 using namespace std; 
 3  
 4 // Global constants 
 5 const int COLS = 4;        // Number of columns in each array 
 6 const int ARR1_ROWS = 3;   // Number of rows in array1 
 7 const int ARR2_ROWS = 4;   // Number of rows in array2 
 8  
 9 // Function prototype 
 10 void showArray(const int [][COLS], int); 
 11  
 12 int main() 
 13 { 
 14    // Declare and initialize two arrays. 
 15    int array1[ARR1_ROWS][COLS] = {{1, 2, 3, 4}, 
 16                                   {5, 6, 7, 8}, 
 17                                   {9, 10, 11, 12}}; 
 18  
 19    int array2[ARR2_ROWS][COLS] = {{10, 20, 30, 40}, 
 20                                   {50, 60, 70, 80}, 
 21                                   {90, 100, 110, 120}, 
 22                                   {130, 140, 150, 160}}; 
 23     
 24    // Display the contents of array1. 
 25    cout << "The contents of array1 are:\n"; 
 26    showArray(array1, ARR1_ROWS); 
 27  
 28    // Display the contents of array2. 
 29    cout << "The contents of array2 are:\n"; 
 30    showArray(array2, ARR2_ROWS); 
 31    return 0; 
 32 } 
 33  
 34 // Function Definition for showArray 

 
6.5 Two-Dimensional Arrays 
245
 35 // The first argument is a two-dimensional int array with 
 36 // COLS columns. The second argument, rows, specifies the 
 37 // number of rows in the array. The function displays the 
 38 // array's contents. 
 39 void showArray(const int arr[][COLS], int rows) 
 40 { 
 41    for (int x = 0; x < rows; x++) 
 42    { 
 43       for (int y = 0; y < COLS; y++) 
 44       { 
 45          cout << arr[x][y] << "\t"; 
 46       } 
 47       cout << endl; 
 48    } 
 49 } 
 Program Output 
 The contents of array1 are: 
 1 
2 
3 
4 
 5 
6 
7 
8 
 9 
10 
11 
12 
 The contents of array2 are: 
 10 
20 
30 
40 
 50 
60 
70 
80 
 90 
100 
110 
120 
 130 
140 
150 
160  
 Checkpoint 
 6.21.  How many rows and how many columns are in the following array? 
 int points[88][100];  
 6.22.  Write a statement that assigns the value 100 to the very last element in the 
points array declared in Checkpoint 6.21  
 6.23.  Write a declaration for a two-dimensional array initialized with the following 
table of data: 
 12 
24 
32 
21 
42 
 14 
67 
87 
65 
90 
 19 
1 
24 
12 
8  
 6.24.  Write code with a set of nested loops that stores the value 99 in each element 
of the following info array. 
 const int ROWS = 100; 
 const int COLS = 50; 
 int info[ROWS][COLS];  

246 
Chapter 6 
 Arrays
 
6.6  Arrays of Three or More Dimensions 
 CONCEPT:   To model data that occurs in multiple sets, most languages allow you 
to create arrays with multiple dimensions.  
 In the previous section you saw examples of two-dimensional arrays. You can also 
create arrays with three or more dimensions. Here is an example of a three-dimensional 
array declaration: 
 double seats[3][5][8];  
 You can think of this array as three sets of five rows, with each row containing eight 
elements. The array might be used to store the prices of seats in an auditorium, where 
eight seats are in a row, five rows in a section, and a total of three sections.  Figure  6-12 
illustrates the concept of a three-dimensional array as “pages” of two-dimensional arrays.  
Column 0
Column 1
Column 2
Column 3
Row 0
Row 1
Row 2
Page 0
Page 1
Page 2
 Figure 6-12  A three-dimensional array  
 Arrays with more than three dimensions are difficult to visualize, but they can be use-
ful in some programming problems. For example, in a factory warehouse where cases 
of widgets are stacked on pallets, an array with four dimensions could be used to store 
a part number for each widget. The four subscripts of each element could represent the 
pallet number, case number, row number, and column number of each widget. Similarly, 
an array with five dimensions could be used in the case of multiple warehouses. 
 Checkpoint 
 6.25.   A bookstore keeps books on 50 racks with 10 shelves each. Each shelf holds 
25 books. Declare a 3-D  string array to hold the names of all the books in the 
store. The array’s three dimensions should represent the racks, shelves, and 
books in the store.  

 
Review Questions 
247
 Review Questions 
 Multiple Choice  
 
1.  This appears in an array declaration and specifies the number of elements in 
the array:  
 a.  subscript. 
 b.  size declarator.  
 c.  array name.  
 d.  initialization value.  
 
2.   To make programs easier to maintain, many programmers use these to specify the 
size of an array:  
 a.  real numbers.  
 b.  string expressions.  
 c.   math expressions.  
 d.  named constants.  
 
3.   This is an individual storage location in an array:  
 a.  element.  
 b.  bin. 
 c.  cubbyhole. 
 d.  size declarator.  
 
4.   This is a number that identifies a storage location in an array:  
 a.  element.  
 b.  subscript. 
 c.  size declarator.  
 d.  identifier.  
 
5.   This is the first subscript in an array:  
 a.  −1. 
 b.  1. 
 c.  0. 
  d.  the size of the array minus one.  
 
6.   This is the last subscript in an array:  
 a.  −1. 
 b.  99. 
 c.   0. 
 d.  the size of the array minus one.  
 
7.   This algorithm uses a loop to step through each element of an array, starting with 
the first element, searching for a value:  
 a.  sequential search.  
 b.  step-by-step search.  
 c.  elemental search.  
 d.   binary search.  
 
8.   The C++ compiler does not do this:  
 a.  check the syntax of array declarations.  
 b.  allow the use of  int arrays.  

248 
Chapter 6 
 Arrays
 c.  array bounds checking.  
 d.  allow arrays of more than two dimensions.  
 
9.   This term describes two or more arrays that hold related data, and the related 
elements in each array are accessed with a common subscript:  
 a.  synchronous arrays.  
 b.  asynchronous arrays.  
 c.  parallel arrays.  
 d.  two-dimensional arrays.  
 
10.  You typically think of a two-dimensional array as containing  
 a.  lines and statements.  
 b.  chapters and pages.  
 c.  rows and columns. 
 d.  horizontal and vertical elements.  
 True or False  
 
1.  You can store a mixture of different data types in an array.  
 
2.  An array’s size cannot be changed while the program is running.  
 
3.  An array’s size declarator can be either a literal, a named constant, or a variable.  
 
4.  If you leave out the size declarator of an array definition, you do not have to 
include an initialization list.  
 
5.  C++ performs array bounds checking when the program is compiled  
 
6.  You can do many things with arrays, but you cannot pass one as an argument to 
a function.  
 
7.  A declaration for a two-dimensional array requires only one size declarator.  
 
8.  C++ allows you to create arrays with three or more dimensions.  
 Short Answer  
 
1.   What is an off-by-one error?  
 
2.  Look at the following code: 
 const int SIZE = 10; 
 int values[SIZE];  
 a.  How many elements does the array have?  
 b.  What is the subscript of the first element in the array?  
 c.  What is the subscript of the last element in the array?  
 
3.   Look at the following code: 
 const int SIZE = 3; 
 int numbers[SIZE] = { 1, 2, 3 };  
 a.  What value is stored in  numbers[2] ? 
 b.  What value is stored in  numbers[0] ? 
 
4.   A program uses two parallel arrays named  customerNumbers and  balances . 
The  customerNumbers array holds customer numbers, and the  balances array 

 
Programming Exercises 
249
holds customer account balances. If a particular customer’s customer number is 
stored in  customerNumbers[187] , where would that customer’s account balance 
be stored?  
 
5.   Look at the following array declaration: 
 double sales[8][10];  
 a.  How many rows does the array have?  
 b.  How many columns does the array have?  
 c.  How many elements does the array have?  
 d.   Write a statement that stores a number in the last column of the last row in 
the array.  
 Algorithm Workbench  
 
1.   Write a declaration for a string array initialized with the following strings: 
 "Einstein" ,  "Newton" ,  "Copernicus" , and  "Kepler" . 
 
2.   Assume  numbers is an  int array with 20 elements. Write a  for loop that displays 
each element of the array.  
 
3.   Assume the arrays  numberArray1 and  numberArray2 each have 100 elements. Write 
code that copies the values in  numberArray1 to  numberArray2 . 
 
4.   In a program you need to store the identification numbers of 10 employees (as 
 int s) and their weekly gross pay (as  double s). 
 a.  Declare two arrays that may be used in parallel to store the 10 employee iden-
tification numbers and gross pay amounts.  
 b.  Write a loop that uses these arrays to display each employee’s identification 
number and weekly gross pay.  
 
5.   Declare a two-dimensional array of integers named  grades . It should have 30 
rows and 10 columns.  
 
6.   Write a function that accepts an  int array as an argument and returns the total 
of the values in the array.  
 Programming Exercises 
 
1.   Total Sales 
 Write a program that asks the user to enter a store’s sales for each day of the 
week. The amounts should be stored in an array. Use a loop to calculate the total 
sales for the week and display the result.  
 
2.   Largest/Smallest Array Values 
 Write a program that lets the user enter 10 values into an array. The program 
should then display the largest and smallest values stored in the array.  
 
3.   Rainfall Statistics 
 Write a program that lets the user enter the total rainfall for each of 12 months 
into an array of  double s. The program should calculate and display the total rain-
fall for the year, the average monthly rainfall, and the months with the highest 
and lowest amounts.  
VideoNote
Solving the Total 
Sales problem

250 
Chapter 6 
 Arrays
 
4.  Driver’s License Exam 
 The local driver’s license office has asked you to create an application that grades 
the written portion of the driver’s license exam. The exam has 20 multiple-choice 
questions. Here are the correct answers: 
 1. B 
  6. A 
11. B 
16. C  
 2. D 
  7. B 
12. C 
17. C  
 3. A 
  8. A 
13. D 
18. B  
 4. A 
  9. C 
14. A 
19. D  
 5. C 
10. D 
15. D 
20. A  
 Your program should store these correct answers in an array. It should ask the 
user to enter the student’s answers for each of the 20 questions, and the answers 
should be stored in another array. After the student’s answers have been entered, 
the program should display a message indicating whether the student passed or 
failed the exam. (A student must correctly answer 15 of the 20 questions to pass 
the exam.) It should then display the total number of correctly answered ques-
tions, the total number of incorrectly answered questions, and a list showing the 
question numbers of the incorrectly answered questions.  
 
5.   Days of Each Month 
 Write a program that displays the number of days in each month. The program’s 
output should be similar to this: 
 January has 31 days.  
 February has 28 days.  
 March has 31 days.  
 April has 30 days.  
 May has 31 days.  
 June has 30 days.  
 July has 31 days.  
 August has 31 days.  
 September has 30 days.  
 October has 31 days.  
 November has 30 days.  
 December has 31 days.  
 The program should have two parallel arrays: a 12-element  string array that is initial-
ized with the names of the months and a 12-element  int array that is initialized with 
the number of days in each month. To produce the output specified, use a loop to step 
through the arrays getting the name of a month and the number of days in that month.  
 
6.   Payroll 
 Write a program that uses the following arrays: 
 •  empId : an array of seven  int s to hold employee identification numbers.  
 •  The array should be initialized with the following numbers: 
 658845 520125 895122 777541 
 451277 302850 580489  
 •  hours : an array of seven  int s to hold the number of hours worked by each 
employee  
 •  payRate : an array of seven  double s to hold each employee’s hourly pay rate  
 •  wages : an array of seven  double s to hold each employee’s gross wages  

 
Programming Exercises 
251
 The program should relate the data in each array through the subscripts. For 
example, the number in element 0 of the  hours array should be the number of 
hours worked by the employee whose identification number is stored in element 
0 of the  empId array. That same employee’s pay rate should be stored in element 
0 of the  payRate array. 
 The program should display each employee number and ask the user to enter 
that employee’s hours and pay rate. It should then calculate the gross wages for 
that employee (hours times pay rate) and store them in the wages array. After 
the data has been entered for all the employees, the program should display each 
employee’s identification number and gross wages.  
 
7.   Tic-Tac-Toe Game 
 Write a program that allows two players to play a game of tic-tac-toe. Use a 
two-dimensional  string (or  char ) array with three rows and three columns as the 
game board. Each element of the array should be initialized with an asterisk (*). 
The program should run a loop that: 
 •  Displays the contents of the board array.  
 •  Allows player 1 to select a location on the board for an X. The program 
should ask the user to enter the row and column number.  
 •  Allows player 2 to select a location on the board for an O. The program 
should ask the user to enter the row and column number.  
 •  Determines whether a player has won, or a tie has occurred. If a player has 
won, the program should declare that player the winner and end. If a tie has 
occurred, the program should say so and end.  
 Player 1 wins when there are three Xs in a row on the game board. The Xs can 
appear in a row, in a column, or diagonally across the board. A tie occurs when 
all the locations on the board are full, but there is no winner.  

This page intentionally left blank 

253
PART
2
Introduction to Game Programming 
with C++ and App Game Kit

This page intentionally left blank 

255
 
  7.1  The App Game Kit and the Structure 
of a Game Program 
 CONCEPT:   The App Game Kit, or AGK, is a commercial programming tool that 
you can use to write games in C++. It provides a programming tem-
plate that supports the typical structure of a game program.  
 In the previous chapters you learned to write simple programs using only the standard 
features of C++. The programs that you have written, until now, have displayed text 
output in a console window and read input from the keyboard. We mentioned in 
 Chapter   1 that although C++ is a fast and efficient programming language, it does not 
have built-in features for writing graphical programs or games.  In this chapter we will 
move beyond the standard features of C++. We will begin using the App Game Kit 
library, which allows you to write games and interactive graphical programs in C++. 
 The App Game Kit (or AGK, as it is commonly called) is a commercial programming 
environment that was developed by The Game Creators, a software company based 
in the United Kingdom. It is designed to create games for Windows, as well as a 
variety of smartphones and tablets. The AGK is available in two levels: 
 Tier 1:  This product provides a programming language that is derived from BASIC 
and an integrated development environment.  
 Tier 2:  This product provides everything in Tier 1, plus a C++ library that works 
with Microsoft Visual Studio.  
 7.1  The App Game Kit and the Structure of a 
Game Program  
 7.2  The Screen Coordinate System   
 7.3  Displaying Sprites   
 7.4  Working in the Game Loop   
 7.5  Working with Colors and Transparency   
 7.6  Displaying Text in the AGK Window   
 7.7  Generating Random Numbers   
 TOPICS 
7 
 Using the App Game 
Kit with C++  
 CHAPTER 

256 
Chapter 7 
 Using the App Game Kit with C++
 In this  book  we will use the C++ library from the AGK Tier 2, along with Visual 
Studio 2010. The Game Creators provide a free trial version of AGK Tier 2 that is 
fully functional and is not time restricted. The difference between the trial version and 
the commercial version is that all programs developed with the trial version run with 
a watermark message displayed on the screen. See   Appendix A for instructions on 
downloading and installing the AGK trial version. 
 The Structure of a Typical Game Program 
 Virtually all game programs are structured into the following three general phases: 
 ●  Initialization —The initialization phase occurs when the program starts. During 
initialization, the program loads the resources that it needs, such as graphic im-
ages and sound files, and gets things set up so the game can play.  
 ●  Game Loop —This is a loop that repeats continuously until the game is over. During 
each iteration of the loop, the program gets the latest input from the user, moves ob-
jects on the screen, plays sounds, and so forth. When the game is over, the loop stops.  
 ●  Shutdown —When the game is over, the program saves any data that must be 
kept (such as the user’s score), and then the program ends.  
 Figure   7-1 illustrates these three program phases.  
Most of the game code is 
in a loop that executes over 
and over, as long as the game
is in play.
The program starts.
The program ends.
Initialization
Game Loop
Shutdown
Resources, such as graphic
images and sounds, are loaded
and the game is setup for play.
When the game ends, any data
that needs to be kept is saved.
 Figure 7-1  Typical game phases  

 
7.1 The App Game Kit and the Structure of a Game Program  
257
 When you write a C++ program that uses the AGK, you work with a code template 
that is already set up for the three phases of a game program. A C++ program that 
uses the AGK looks quite different from the standard C++ programs that you are 
accustomed to writing, however. 
 For example,  you learned in  Chapter   2 that all C++ programs must have a function 
named  main , and that the  main function is the program’s starting point. Although that 
is still true, you will not actually see the  main function in any of your C++ programs 
that use the AGK. This is because graphics programming can be quite complex, and 
the AGK is designed to handle much of that complexity for you. As a result, the  main 
function in an AGK program is hidden. 
 Instead, you will work primarily with three functions shown in the following pro-
gram template: 
 1  // Includes, namespace and prototypes 
 2  #include "template.h" 
 3  using namespace AGK; 
 4  app App; 
 5 
 6  // Begin app, called once at the start 
 7  void app::Begin( void ) 
 8  { 
 9  } 
 10 
 11  // Main loop, called every frame 
 12  void app::Loop ( void ) 
 13  { 
 14  } 
 15 
 16  // Called when the app ends 
 17  void app::End ( void ) 
 18  { 
 19  }  
 At this point, you do not need a deep understanding of the code in lines 2, 3, and 4, 
but here is a brief overview of those statements: 
 ●  The include directive in line 2 includes the contents of a file named  template.h . 
The  template.h file contains declarations and other code needed by the AGK 
library.  
 ●  The  using  namespace statement in line 3 declares that we are using the  AGK 
namespace. You have already learned that when you write a program using 
the standard C++ library, you need to use the  std namespace. Likewise, when 
you write a program using the AGK library, you need to use the  AGK 
namespace.  
 ●  Line 4 declares an object named  App that is used by the AGK to control the 
program.  
 The remaining code consists of three functions, named  app::Begin ,  app::Loop , and 
 app::End . You will spend most of your time writing code in these three functions, 

258 
Chapter 7 
 Using the App Game Kit with C++
which correspond to the three phases of a game program. Here is a summary of 
each function: 
 ●  The  app::Begin function is in lines 7 through 9. This function executes once, 
when the program starts. Its purpose is to perform initialization, such as load-
ing graphical images and sounds, and to prepare the program when it first 
executes.  
 ●  The  app::Loop function appears in lines 12 through 14. This function performs 
the game loop, and it does most of the work in an AGK program. After the 
 app::Begin function has executed, the  app::Loop function executes over and 
over until the program ends.  
 ●  The  app::End function appears in lines 17 through 19. This function executes 
when the program ends. It performs any necessary shutdown operations, such 
as saving game data.  
 Figure   7-2 illustrates the sequence in which these functions execute.  
void app::End ( void )
{
}
void app::Begin( void )
{
}
void app::Loop ( void )
{
}
The app::Loop function 
executes over and over, as 
long as the program is running.
The app::Begin function executes
once, when the program starts.
The app::End function executes
once, when the program ends.
The program starts.
The program ends.
 Figure 7-2  Sequence of function execution in an AGK program  
 A metaphor for these three functions might go as follows: The  app::Begin function is 
similar to a person getting ready to go to work, making sure they have everything they 
need. When they are ready, they head off for work and enter the  app::Loop function. 

 
7.1 The App Game Kit and the Structure of a Game Program  
259
This function is like the person working at a job where he or she completes many 
different tasks over and over until quitting time. Then, when the work is finished, the 
person enters the  app::End function. In this function the person cleans up the work 
area and goes home.  
 Remember—The  app::Loop Function 
Loops Automatically 
 Up to this chapter, you have been in  control  of  the “flow” of each   program that you 
 have written  . For example, if you want a group of statements to execute repeatedly in 
a standard C++ program, you have to write a loop that executes those statements. In 
the AGK template, however, the  app::Loop function repeats automatically. Any state-
ment or statements that you write inside the  app::Loop function will execute over and 
over until the game is over or the user ends the program.  
 Creating an AGK Project for Visual C++ 
 Once you have installed the AGK on your system, you will have a template C++ proj-
ect that you can copy and then open in Visual Studio. You can then add your own 
code to the template project. The following tutorial leads you through the steps of 
copying the template project and opening it in Visual Studio.  
 Tutorial: 
 Copying the AGK Template Project and 
Opening It in Visual Studio 
 Step 1:  Open Windows Explorer, and go to the folder where the AGK is installed. 
(If you followed the instructions in   Appendix A , you installed the AGK in a 
folder named  AGK , under  My Documents . This is the location that we 
recommend.) 
 Inside the AGK folder, go to the IDE folder, and then go to the templates 
folder, as shown in  Figure   7-3 . Inside the templates folder, you should see 
the folders shown in  Figure   7-4 . 
 Figure 7-3  Go to the  AGK\IDE\templates folder  
VideoNote
Copying the AGK 
Template Project 
and Opening It in 
Visual Studio

260 
Chapter 7 
 Using the App Game Kit with C++
 Step 2:  As shown in  Figure  7-4 , one of the folders is  template_vs10 . This is the tem-
plate for Visual Studio 2010, which is the version we are using in this  book  . 
Make a copy of this folder, as shown in  Figure   7-5  . (To copy the folder, right-
click the  template_vs10 folder, then select  Copy from the menu. Next, right-
click anywhere inside the current folder, then select  Paste .)  
 Figure 7-4  Contents of the  AGK\IDE\templates folder  
 WARNING!   You must paste the copy of the folder in the  templates folder. If you 
paste it anywhere else on your system, the Visual Studio compiler will not be able 
to find many of the files that it needs to compile your project. 
 Figure 7-5  Make a copy of the  template_vs10 folder  

 
7.1 The App Game Kit and the Structure of a Game Program  
261
 Step 3:  As shown in  Figure   7-6  , rename the copy of the  template_vs10 
folder that you just created. In the figure, we have renamed it as 
 MyFirstAGKProject . (To rename the folder, right-click it, then select 
 Rename from the menu.)  
 Figure 7-6  The folder renamed  
 Step 4:  Go into the folder that you just renamed, and locate the file named 
 template.sln (as shown in  Figure   7-7 ). This is the Visual Studio solution file 
for the project. Double-click the file to open it in Visual Studio.  
 Figure 7-7  Double-click the  template.sln file  

262 
Chapter 7 
 Using the App Game Kit with C++
 Step 5:  In the Solution Explorer window in Visual Studio, open the App folder, and 
then double-click the template.cpp file to open it in the editor, as shown in 
Figure 7-8. This is the C++ file that contains the template AGK code that 
you will work with in each project you create.  
Double-click template.cpp
to open it in the editor.
 Figure 7-8  Open the  template.cpp file in the editor  
 App Game Kit Online Documentation 
 We cover many aspects of AGK programming in this  book  , but we do not cover every-
thing. You can find documentation for all the AGK function, as well as other topics, at 
  http://www.appgamekit.com/documentation  . 
 Checkpoint 
 7.1.  What is the App Game Kit?  
 7.2.  Virtually all games are structured into what three general phases?  
 7.3.  What three functions are already written in the AGK C++ template?  
 7.4.  Which AGK template function performs the work of the game loop?  
 
 7.2  The Screen Coordinate System 
 CONCEPT:   A system of X- and Y-coordinates is used to identify the locations of 
pixels in a window.  

 
7.2 The Screen Coordinate System 
263
 When you run a program that you have created with the AGK, the output appears 
in a graphics window. The display area in the window is made up of tiny dots 
called  pixels , and a  screen coordinate system is used to identify the position of each 
pixel in the window. 
 Each pixel has an  X -coordinate and a  Y -coordinate. The  X -coordinate identifies the 
pixel’s horizontal position, and the  Y -coordinate identifies its vertical position. The 
coordinates are usually written in the form ( X ,  Y ). For example, the coordinates of the 
pixel in the upper-left corner of the window are (0, 0). This means that its  X -coordinate 
is 0 and its  Y -coordinate is 0. The  X -coordinates increase from left to right, and the 
Y-coordinates increase from top to bottom. 
 The AGK has two ways of handling screen coordinates. The default method uses a 
percentage-based coordinate system where the screen coordinates start in the upper-
left corner at (0, 0) and end in the lower-right corner at (100, 100). This is shown 
in  Figure   7-9 . As you can see from the figure, the displayable area does not fill the 
entire window.  
 Figure 7-9  The percentage-based screen coordinate system  
 The second method, which we will use in this  book  , is called virtual resolution. 
It is somewhat easier to use than the percentage-based system because it is based 
on the screen size of the window. The default window that is displayed by an 
AGK program is 640 pixels wide and 480 pixels high. We say that the window 
has a  resolution of 640 by 480. In a window that is 640 pixels wide by 480 
pixels high, the coordinates of the pixel at the bottom-right corner of the screen 
are (639, 479). In the same window, the coordinates of the pixel in the center of 
the screen are (319, 239).  Figure   7-10  shows some coordinates of a resolution-
based system.  

264 
Chapter 7 
 Using the App Game Kit with C++
 Notice that the pixels at the far right edge of the screen have an  X -coordinate of 
639, not 640. This is because coordinate numbering begins at 0 in the upper-left 
corner. Likewise, the pixels at the bottom edge of the screen have a  Y -coordinate of 
479, not 480.  
 Figure 7-10  The resolution-based screen coordinate system  
 NOTE:    The screen coordinate system differs from the Cartesian coordinate sys-
tem that you learned about in mathematics. In the Cartesian coordinate system, 
the  Y -coordinates decrease as you move downward. In the screen coordinate 
system the  Y -coordinates increase as you move downward, toward the bottom 
of the screen. 
 Setting the Virtual Resolution 
 As previously mentioned, an AGK program uses the percentage-based screen resolu-
tion by default. If you want your program to use the virtual resolution system (which 
we use in this book), you have to call the  agk::SetVirtualResolution function. Here 
is the general format of how you call the function: 
 agk::SetVirtualResolution( width, height ); 
 You pass two integer arguments to the function. The   width argument sets the number 
of pixels wide that the screen will be, and the   height argument sets the number of 
pixels high that the screen will be. The following statement sets the virtual resolution 
to 640 by 480: 
 agk::SetVirtualResolution(640, 480);  

 
7.2 The Screen Coordinate System 
265
 You call this function in your program’s  app::Begin function, as shown in line 14 of 
Program 7-1. Notice that we have declared two global constants for the screen’s width 
and height, in lines 7 and 8. 
 Program 7-1 
 (VirtualResolutionSetup) 
 1 // Includes, namespace and prototypes 
 2 #include "template.h" 
 3 using namespace AGK; 
 4 app App; 
 5  
 6 // Constants for the screen resolution 
 7 const int SCREEN_WIDTH = 640; 
 8 const int SCREEN_HEIGHT = 480; 
 9  
 10 // Begin app, called once at the start 
 11 void app::Begin( void ) 
 12 { 
 13    // Set the virtual resolution. 
 14    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 15 } 
 16  
 17 // Main loop, called every frame 
 18 void app::Loop ( void ) 
 19 { 
 20 } 
 21  
 22 // Called when the app ends 
 23 void app::End ( void ) 
 24 { 
 25 } 
 Checkpoint 
 7.5.  What are the tiny dots that make up the display area of the screen?  
 7.6.  What two coordinates identify a position in the AGK’s output window?  
 7.7.  The AGK uses what two methods of handling screen coordinates?  
 7.8.  What are the coordinates of the upper-left corner of the AGK’s output 
window?  
 7.9.  In the percentage-based system, what are the coordinates of the position in the 
lower-right corner of the AGK’s output window?  
 7.10.  In the virtual resolution system, what are the coordinates of the position in the 
lower-right corner of the AGK’s output window?  
 7.11.  How are the screen coordinates different from the Cartesian coordinate 
system?  
 7.12.  How do you switch to the virtual resolution system in an AGK C++ program?  

266 
Chapter 7 
 Using the App Game Kit with C++
 
 7.3  Displaying Sprites 
 CONCEPT:   A sprite is a graphic image that is displayed in a game.  
 Bitmap Images 
 Most of the programs that you will write with the AGK will display images that have 
been created with a graphics program such as Microsoft Paint or perhaps captured 
with a digital camera and stored on your computer’s disk. When graphic images are 
stored on a computer’s disk, they are commonly stored as bitmaps. The term  bitmap 
refers to a set of data that describes every pixel in an image. When an image is saved 
on the computer’s disk as a bitmap, it is saved in a file that contains data describing 
every pixel in the image. 
 If you use a digital camera, a scanner, or a graphics program like Microsoft Paint, 
you have probably created image files that end with extensions such as  .png ,  .jpg , 
and  .bmp . These are all different formats for saving a bitmap image in a file.  
 Sprites 
 Graphic images are used extensively in computer games. The graphics for the back-
ground scenery, the game characters, and practically everything else are images that 
are loaded from bitmap files. The graphic images that are displayed in a computer 
game are commonly known as  sprites . The AGK provides many functions for creating 
and using sprites. 
 To create a sprite in an AGK program, you use the  agk::CreateSprite function. Here 
is the general format that we will typically use: 
 agk::CreateSprite( SpriteIndex ,  ImageFile );  
 Here is a summary of the two arguments that you pass to the function: 
 ●  SpriteIndex is the sprite index, which is a number that identifies the sprite in 
your program. The sprite index can be an integer in the range of 1 through 
4,294,967,295. Once the sprite is created, you will use its sprite index to identify 
it in subsequent operations.  
 ●  ImageFile is the name of the file that contains the image. This can be the name 
of any image file of the  .png ,  .jpg , or  .bmp file formats.  
 For example, suppose we have an image file named  LadyBug.png that we want to use 
as a sprite. The following statement shows how we can create the sprite, and assign 1 
as its sprite index: 
 agk::CreateSprite(1, "LadyBug.png");  
 When a sprite is created, its default position on the screen will be the upper-left corner, 
at the coordinates (0, 0).  

 
7.3 Displaying Sprites 
267
 The Location of a Program’s Graphic Files 
 When an AGK program looks for an image file, it looks in the  My Documents >  AGK 
>  template folder, as shown in  Figure   7-11  . Any graphic files that you want to use in 
your program should be stored in this folder.  
This is the folder that
holds your project’s
graphic files.
 Figure 7-11  Location of the  template folder that holds your project’s graphic files  
 Understanding the Backbuffer and Syncing 
 Although the  agk::CreateSprite function creates a sprite in memory, it does not dis-
play the sprite on the screen. This is because the AGK keeps a copy of the output 
screen, known as the  backbuffer , in memory. When the AGK draws an image, it draws 
the image on the backbuffer instead of the actual screen. When you are ready for the 
contents of the backbuffer to be displayed on the actual screen, you call the  agk::Sync 
function. (The word  sync stands for synchronize. When you call the  agk::Sync func-
tion, it synchronizes the screen with the backbuffer.) 
 You call the  agk::Sync function in the  app::Loop function. Calling the  agk::Sync 
function is typically the last operation performed in  app::Loop , after all other actions 
have taken place. 
 As an example, look at Program 7-2. This program creates a sprite, using a graphic file 
named  ghost.png . (Before you run this program, you must copy  ghost.png file to the 
 template folder that is in the  AGK folder.) When the program runs, it displays the 
screen shown in  Figure   7-12  . To end the program’s execution, click the window’s close 
button (  
). 
 Program 7-2 
 (SpriteDemo) 
 1 // Includes, namespace and prototypes 
 2 #include "template.h" 
 3 using namespace AGK; 
 4 app App; 
 5  
 NOTE:    The  template folder that holds your project’s graphic files will be created 
the first time you load the template project in Visual Studio. 
VideoNote
The SpriteDemo 
Program

268 
Chapter 7 
 Using the App Game Kit with C++
 6 // Constants for the screen resolution 
 7 const int SCREEN_WIDTH = 640; 
 8 const int SCREEN_HEIGHT = 480; 
 9  
 10 // Constant for the sprite index 
 11 const int SPRITE_INDEX = 1; 
 12  
 13 // Begin app, called once at the start 
 14 void app::Begin( void ) 
 15 { 
 16    // Set the virtual resolution. 
 17    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 18  
 19    // Create the ghost sprite. 
 20    agk::CreateSprite(SPRITE_INDEX, "ghost.png"); 
 21 } 
 22  
 23 // Main loop, called every frame 
 24 void app::Loop ( void ) 
 25 { 
 26    // Display the screen. 
 27    agk::Sync(); 
 28 } 
 29  
 30 // Called when the app ends 
 31 void app::End ( void ) 
 32 { 
 33 } 
 Figure 7-12  Output of Program 7-2  

 
7.3 Displaying Sprites 
269
 Let’s take a closer look at the program. Lines 7 and 8 declare global constants for the 
screen’s width and height. Line 11 declares the global constant  SPRITE _ INDEX , set to 
the value 1. We will use this constant as the ghost’s sprite index. 
 Inside the  app::Begin function, line 17 sets the virtual resolution. Line 20 creates a 
sprite with the index 1, using the graphic file  ghost.png . (The program will look for 
this file in the  My Documents >  AGK >  template folder.) The sprite will be positioned 
in the upper-left corner of the backbuffer. 
 After the  app::Begin function finishes, the program executes the  app::Loop function. 
Line 27 calls the  agk::Sync function, which displays the backbuffer. This causes the 
ghost sprite to appear on the screen. The  app::Loop function continues to execute 
repeatedly, but its only action is to display the ghost sprite.  
 NOTE:   Simple programs such as this one do not usually perform any actions in 
the  app::End function. The  app::End function is typically used to save game data. 
 Using a Sprite as the Background 
 Most of the games and other programs that you develop with the AGK will display a 
bitmap image for the background. If you want to fill the entire background, it is best 
to use an image that is the same size as the window (which, by default, is 640 by 480 
pixels). You simply create a sprite using the desired bitmap image, and it will fill the 
window when the  agk::Sync function is called. Program 7-3 demonstrates by creating 
a sprite from a bitmap image that is 640 by 480 pixels in size. The program’s output 
is shown in  Figure   7-13 . 
 Figure 7-13  Output of Program 7-3  

270 
Chapter 7 
 Using the App Game Kit with C++
 If you study Program 7-3 carefully, you will notice that the only difference between it 
and Program 7-2 is the name of the graphic file that is being used to create the sprite 
in line 20. Program 7-3 uses a file named  beach . png (which must be located in the  My 
Documents >  AGK >  template folder). 
 Program 7-3 
 (BeachBackground) 
 1 // Includes, namespace and prototypes 
 2 #include "template.h" 
 3 using namespace AGK; 
 4 app App; 
 5  
 6 // Constants for the screen resolution 
 7 const int SCREEN_WIDTH = 640; 
 8 const int SCREEN_HEIGHT = 480; 
 9  
 10 // Constant for the sprite index 
 11 const int SPRITE_INDEX = 1; 
 12  
 13 // Begin app, called once at the start 
 14 void app::Begin( void ) 
 15 { 
 16    // Set the virtual resolution. 
 17    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 18  
 19    // Create the beach sprite. 
 20    agk::CreateSprite(SPRITE_INDEX, "beach.png"); 
 21 } 
 22  
 23 // Main loop, called every frame 
 24 void app::Loop ( void ) 
 25 { 
 26    // Display the screen. 
 27    agk::Sync(); 
 28 } 
 29  
 30 // Called when the app ends 
 31 void app::End ( void ) 
 32 { 
 33 } 
 Displaying Multiple Sprites 
 Most of your AGK programs will have more than one sprite. When you create mul-
tiple sprites in the same program, each sprite must have a unique index. For example, 
Program 7-4 creates two sprites: the first is a haunted house image, used for the back-
ground, and the second is a ghost. Notice that in lines 11 and 12 we declare two 
global constants for the sprite indices. Then, in lines 21 and 24 we create the indi-
vidual sprites. The program’s output is shown in  Figure   7-14  . (This also appears as 
Figure C-2 in the book’s color insert.)  

 
7.3 Displaying Sprites 
271
 Program 7-4 
 (HauntedHouse) 
 1 // Includes, namespace and prototypes 
 2 #include "template.h" 
 3 using namespace AGK; 
 4 app App; 
 5  
 6 // Constants for the screen resolution 
 7 const int SCREEN_WIDTH = 640; 
 8 const int SCREEN_HEIGHT = 480; 
 9  
 10 // Constants for the sprite indices 
 11 const int HOUSE_INDEX = 1; 
 12 const int GHOST_INDEX = 2; 
 13  
 14 // Begin app, called once at the start 
 15 void app::Begin( void ) 
 16 { 
 17    // Set the virtual resolution. 
 18    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 19  
 20    // Create the haunted house sprite for the background. 
 21    agk::CreateSprite(HOUSE_INDEX, "haunted_house.png"); 
 22  
 23    // Create the ghost sprite. 
 24    agk::CreateSprite(GHOST_INDEX, "ghost.png"); 
 25 } 
 26  
 27 // Main loop, called every frame 
 28 void app::Loop ( void ) 
 29 { 
 30    // Display the screen. 
 31    agk::Sync(); 
 32 } 
 33  
 34 // Called when the app ends 
 35 void app::End ( void ) 
 36 { 
 37 } 
 NOTE:    You can use the same image file for multiple sprites. For example, suppose 
you have an image file named Fish.png. The following code creates two sprites, 
both using the same image: 
 const int FISH1_INDEX = 1; 
 const int FISH2_INDEX = 2; 
 agk::CreateSprite(FISH1_INDEX, "Fish.png"); 
 agk::CreateSprite(FISH2_INDEX, "Fish.png");  

272 
Chapter 7 
 Using the App Game Kit with C++
 Sprite Depth 
 It is important to note that sprites are drawn on the screen in the order that they were 
created in the program. In Program 7-4, the sprite for the background image (the haunted 
house) was created first, and the sprite for the ghost was created second. When the screen 
is displayed, the background image is drawn first, and the ghost is drawn second. If we 
had reversed the order in which the sprites were created, the ghost would have been 
drawn first, and then the haunted house would have been drawn second. If this were the 
case, we would not see the ghost because the haunted house image would cover it. 
 In situations where you want to control the order in which sprites are displayed, 
regardless of the order in which they were created, you can use the  agk::SetSpriteDepth 
function. Here is the function’s general format: 
 agk::SetSpriteDepth( SpriteIndex ,  Depth );  
 In the general format,   SpriteIndex is the index of the sprite that we are affecting, and 
 Depth is an integer in the range of 0 through 1000. The lower the depth value, the 
closer to the screen the sprite will be positioned. For example, suppose you have two 
sprites: one with a depth of 0 and the other with a depth of 5. The sprite that has the 
depth of 0 will be closer to the screen, so any time the two sprites overlap, the one 
that has the depth of 0 will be drawn in front. 
 Program 7-5 demonstrates. In this program, the ghost sprite is created first (in line 
21), and the haunted house sprite is created second (in line 24). To make sure that the 
ghost is drawn in front of the haunted house, we set the ghost sprite’s depth to 0 (in 
line 28) and the haunted house sprite’s depth to 1000 (in line 29). The output of the 
program is the same as previously shown in  Figure   7-14  . 
 Figure 7-14  Output of Program 7-4  

 
7.3 Displaying Sprites 
273
 Program 7-5 
 (SpriteDepth) 
 1 // Includes, namespace and prototypes 
 2 #include "template.h" 
 3 using namespace AGK; 
 4 app App; 
 5  
 6 // Constants for the screen resolution 
 7 const int SCREEN_WIDTH = 640; 
 8 const int SCREEN_HEIGHT = 480; 
 9  
 10 // Constants for the sprite indices 
 11 const int HOUSE_INDEX = 1; 
 12 const int GHOST_INDEX = 2; 
 13  
 14 // Begin app, called once at the start 
 15 void app::Begin( void ) 
 16 { 
 17    // Set the virtual resolution. 
 18    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 19  
 20    // Create the ghost sprite. 
 21    agk::CreateSprite(GHOST_INDEX, "ghost.png"); 
 22  
 23    // Create the haunted house sprite for the background. 
 24    agk::CreateSprite(HOUSE_INDEX, "haunted_house.png"); 
 25  
 26    // Set the sprite depth values so the ghost is always 
 27    // drawn in front of the haunted house. 
 28    agk::SetSpriteDepth(GHOST_INDEX, 0); 
 29    agk::SetSpriteDepth(HOUSE_INDEX, 1000); 
 30 } 
 31  
 32 // Main loop, called every frame 
 33 void app::Loop ( void ) 
 34 { 
 35    // Display the screen. 
 36    agk::Sync(); 
 37 } 
 38  
 39 // Called when the app ends 
 40 void app::End ( void ) 
 41 { 
 42 } 
 Setting a Sprite’s Position 
 By default, a sprite is positioned in the upper-left corner of the screen. However, you 
can call the  agk::SetSpritePosition function to move a sprite to a new position. 
Here is the function’s general format: 
 agk::SetSpritePosition( SpriteIndex ,  X ,  Y );  

274 
Chapter 7 
 Using the App Game Kit with C++
 In the general format,   SpriteIndex is the index of the sprite that you are moving, 
 X is an  X -coordinate, and  Y is a  Y -coordinate. The function will move the sprite 
so its upper-left corner is positioned at the specified  X- and  Y -coordinates. 
Program 7-6 demonstrates this function. The statement in line 31 positions the 
ghost sprite at the coordinate (200, 150). The program’s output is shown in 
 Figure  7-15  .  
 NOTE:   It should be mentioned that the  agk::SetSpritePosition function 
expects the arguments for the  X- and  Y -coordinates to be of the  float data type. 
This is because programs using the percentage-based coordinate systems can 
express coordinates as floating-point numbers. In this  book  , however, we are 
using the virtual coordinate system, and all the coordinates will be expressed as 
whole numbers. 
 Program 7-6 
 (SpritePosition) 
 1 // Includes, namespace and prototypes 
 2 #include "template.h" 
 3 using namespace AGK; 
 4 app App; 
 5  
 6 // Constants for the screen resolution 
 7 const int SCREEN_WIDTH = 640; 
 8 const int SCREEN_HEIGHT = 480; 
 9  
 10 // Constants for the sprite indices 
 11 const int HOUSE_INDEX = 1; 
 12 const int GHOST_INDEX = 2; 
 13  
 14 // Constants for the ghost's position 
 15 const float GHOST_X = 200; 
 16 const float GHOST_Y = 150; 
 17  
 18 // Begin app, called once at the start 
 19 void app::Begin( void ) 
 20 { 
 21    // Set the virtual resolution. 
 22    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 23  
 24    // Create the haunted house sprite for the background. 
 25    agk::CreateSprite(HOUSE_INDEX, "haunted_house.png"); 
 26  
 27    // Create the ghost sprite. 
 28    agk::CreateSprite(GHOST_INDEX, "ghost.png"); 
 29  
 30    // Set the ghost's position. 
 31    agk::SetSpritePosition(GHOST_INDEX, GHOST_X, GHOST_Y); 
 32 } 
 33  
 34 // Main loop, called every frame 
 35 void app::Loop ( void ) 

 
7.3 Displaying Sprites 
275
 36 { 
 37    // Display the screen. 
 38    agk::Sync(); 
 39 } 
 40  
 41 // Called when the app ends 
 42 void app::End ( void ) 
 43 { 
 44 } 
 Figure 7-15  Output of Program 7-6  
 You can also use the  agk::SetSpriteX function to set a sprite’s  X -coordinate only and 
the  agk::SetSpriteY function to set a sprite’s  Y -coordinate only. Here are the func-
tions’ general formats: 
 agk::SetSpriteX( SpriteIndex ,  X ); 
 agk::SetSpriteY( SpriteIndex ,  Y ); 
 In each of the general formats,   SpriteIndex is the index of the sprite that you are moving. 
The  X and   Y arguments are  X- and  Y -coordinates. For example, assuming  GHOST_INDEX is 
a valid sprite index, the following statement will move the sprite so its upper-left corner 
is at the  X -coordinate 200. The sprite will not be moved along the  Y -axis, however. 
 agk::SetSpriteX(GHOST_INDEX, 200);  
 Assuming  GHOST_INDEX is a valid sprite index, the following statement will move the 
sprite so its upper-left corner is at the  Y -coordinate 150. The sprite will not be moved 
along the  X -axis, however. 
 agk::SetSpriteY(GHOST_INDEX, 150);  

276 
Chapter 7 
 Using the App Game Kit with C++
 Getting a Sprite’s  X - and  Y -Coordinates 
 You can get the current  X- and  Y -coordinates of any existing sprite by calling the 
 agk::GetSpriteX and  agk::GetSpriteY functions, passing the sprite index as an argu-
ment. The  agk::GetSpriteX function returns the sprite’s  X -coordinate, as a  float , and 
the  agk::GetSpriteY function returns the sprite’s  Y -coordinate, also as a  float . 
 For example, assume that  GHOST_INDEX is a valid sprite index from the previously 
shown program. The following statements declare two variables:  spriteX and  spriteY . 
The  spriteX variable is initialized with the value that is returned from the 
 agk::GetSpriteX function, and the  spriteY variable is initialized with the value that 
is returned from the  agk::GetSpriteY function. As a result, the  spriteX variable will 
hold the sprite’s  X -coordinate, and the  spriteY variable will hold the sprite’s 
 Y -coordinate. 
 float spriteX = agk::GetSpriteX(GHOST_INDEX); 
 float spriteY = agk::GetSpriteY(GHOST_INDEX);  
 Getting the Width and Height of a Sprite 
 You can get the width of an existing sprite by calling the  agk::GetSpriteWidth func-
tion, passing the sprite index as an argument. The function returns the width of the 
sprite as a  float . Assuming that  SPRITE_INDEX is a valid sprite index, the following 
statement shows an example. 
 float spriteWidth = agk::GetSpriteWidth(SPRITE_INDEX);  
 This statement declares a  float variable named  spriteWidth , initialized with the 
width of the sprite that is specified by  SPRITE_INDEX . 
 You can get the height of an existing sprite by calling the  agk::GetSpriteHeight func-
tion, passing the sprite index as an argument. The function returns the height of the 
sprite as a  float . Assuming that  SPRITE_INDEX is a valid sprite index, the following 
statement shows an example. 
 float spriteHeight = agk::GetSpriteHeight(SPRITE_INDEX);  
 This statement declares a  float variable named  spriteHeight , initialized with the 
height of the sprite that is specified by  SPRITE_INDEX . 
 Scaling a Sprite 
 You can scale the size of an existing sprite by calling the  agk::SetSpriteScale func-
tion. The function resizes the sprite by a multiple of its original size. Here is the gen-
eral format of how you call the function: 
 agk::SetSpriteScale( SpriteIndex ,  Xscale ,  Yscale );  
 The   SpriteIndex is the index of the sprite you want to scale.   Xscale is the amount to 
scale the sprite in the  X direction, and   Yscale is the amount to scale the sprite in the 
 Y direction. (Both   Xscale and  Yscale are float values.) For example, suppose 
 SPRITE_INDEX is a valid sprite index, and you call the function in the following manner: 
 agk::SetSpriteScale(SPRITE_INDEX, 2, 2);  

 
7.3 Displaying Sprites 
277
 This function call will make the sprite twice as big in both the  X and  Y directions, as 
shown in  Figure   7-16 . Here is another example: 
 agk::SetSpriteScale(SPRITE_INDEX, 0.5, 0.5);  
 This function call will make the sprite smaller than its original size. In fact, it will 
make the sprite half as big in both the  X and  Y directions.  
 NOTE:    The  agk::SetSpriteScale function scales the sprite from the top-left corner. 
The sprite’s top-left corner will still be in the same location after the scaling is done. 
 Rotating a Sprite 
 You can use the  agk::SetSpriteAngle function to rotate a sprite around its center 
point. A sprite can be rotated any angle from 0 degrees through 359 degrees. Here is 
the general format of how you call the function: 
 agk::SetSpriteAngle( SpriteIndex ,  Angle ); 
  SpriteIndex   is the index of the sprite that you want to rotate, and   Angle is a 
floating-point value indicating the angle of rotation, in degrees. Assuming that 
 SPRITE_INDEX is a valid sprite index, the following statement rotates the specified 
sprite 90 degrees: 
 agk::SetSpriteAngle(SPRITE_INDEX, 90);  
 You can determine the current rotation of a sprite with the  agk::GetSpriteAngle 
function. You pass the function a sprite index as an argument, and it returns the 
number of degrees that the sprite has been rotated. Assuming that  SPRITE_INDEX is 
a valid sprite index, the following statement shows an example: 
 float angle = agk::GetSpriteAngle(SPRITE_INDEX);  
 This statement declares a  float variable named  angle , initialized with the current 
rotation of the specified sprite.  
Original Size
Scaled by 2 in both the
X and Y directions
 Figure 7-16  A sprite shown at its original size, and scaled by 2 in the  X and  Y directions  

278 
Chapter 7 
 Using the App Game Kit with C++
 NOTE:   If you prefer to work in radians instead of degrees, you can use the 
 agk::SetSpriteAngleRad function to rotate a sprite. It works just like 
 agk::SetSpriteAngle , but the angle is specified in radians. Then, you can use the 
 agk::GetSpriteAngleRad function to get the sprite’s current rotation in radians. 
 Flipping a Sprite 
 You can use the  agk::SetSpriteFlip function to flip a sprite either horizontally or 
vertically. The function’s general format is 
 agk::SetSpriteFlip( SpriteIndex ,  Horizontal ,  Vertical );  
 Here is a summary of the arguments: 
 ●  SpriteIndex is the index of the sprite that you want to flip.  
 ●  Horizontal is either 0 or 1. If 0, the sprite will not be flipped horizontally. If 1, 
the sprite will be flipped horizontally.  
 ●  Vertical is either 0 or 1. If 0, the sprite will not be flipped vertically. If 1, the 
sprite will be flipped vertically.  
 Assuming that  SPRITE_INDEX is a valid sprite index, the following statement flips the 
specified sprite horizontally, but not vertically: 
 agk:: SetSpriteFlip(SPRITE_INDEX, 1, 0);  
 The following statement flips the specified sprite vertically, but not horizontally: 
 agk:: SetSpriteFlip(SPRITE_INDEX, 0, 1);  
 And, the following statement flips the specified sprite both horizontally and vertically: 
 agk:: SetSpriteFlip(SPRITE_INDEX, 1, 1);  
 Making a Sprite Visible or Invisible 
 You can make a sprite invisible or visible by calling the  agk::SetSpriteVisible func-
tion. Here is the general format of how you call the function: 
 agk::SetSpriteVisible( SpriteIndex ,  Visible ); 
 The  SpriteIndex is the index of a sprite, and   Visible is either 0 or 1. If you pass 0 
for the   Visible argument, the sprite will become invisible. If you pass 1 for the   Visible 
argument, the sprite will become visible. Assuming  SPRITE_INDEX is a valid sprite 
index, here is an example: 
 agk::SetSpriteVisible(SPRITE_INDEX, 0);  
 This function call will make the sprite invisible. To make it visible again, you would 
use the following function call: 
 agk::SetSpriteVisible(SPRITE_INDEX, 1);  
 Cloning a Sprite 
 A sprite clone is a copy of an existing sprite. When you clone a sprite, you are making 
a copy that is independent from the original sprite. The clone will be created at the 
same location as the original, and it will have the characteristics of the original sprite, 
such as size, rotation angle, and so on. If you manipulate the original sprite, (such as 

 
7.3 Displaying Sprites 
279
resize or flip it), it has no effect on the sprite’s clones. The opposite is also true: if you 
manipulate a clone, it has no effect on the original sprite. 
 You clone a sprite by calling the  agk::CloneSprite function. Here is the general for-
mat for calling the function: 
 agk::CloneSprite( SpriteIndex ,  DestinationSpriteIndex );  
  SpriteIndex  is the number of the original sprite, and   DestinationSpriteIndex is the 
number you want to assign to the clone. For example assume that  SPRITE_INDEX is a 
valid sprite index. The following statement creates a clone of the sprite, assigning it 
the index specified by  CLONE_INDEX : 
 agk::CloneSprite(SPRITE_INDEX, CLONE_INDEX);  
 The clone specified by  CLONE_INDEX will have the same image, be of the same size and 
rotation, and be in the same location as the sprite specified by  SPRITE_INDEX . 
 Transparent Backgrounds in Sprites 
 Most graphic images are rectangular. However, the contents of many of the graphic im-
ages that you will use to create sprites are not rectangular. For example, look at the image 
in  Figure   7-17  . The image is a circle, but it is saved in a black rectangle in the image file.  
 Figure 7-17  Circle image on a rectangular background  
 Let’s say you are using this image to create a sprite in a game, perhaps as a ball that is 
moving around on the screen. You have another image that you will use as the game’s 
background, and you want the ball to be displayed on top of the background image. 
You will probably want the black, rectangular area in the circle image to be invisible so 
only the ball is shown moving around the screen, on top of the background image. 

280 
Chapter 7 
 Using the App Game Kit with C++
 Fortunately, images that are saved in the  png format can have transparent backgrounds. 
For example, the  ghost.png graphic shown in  Figure   7-18 shows a checkerboard pattern 
to indicate the transparent region of the image. (This figure also appears as Figure C-3 
in the book’s color insert.) When you use a graphics editor to create a  png image, you can 
specify that the image should have a transparent background, and then, when you load 
that image into an AGK program, its transparent background region will be invisible.  
 NOTE:    The specific steps for creating an image with a transparent background 
vary from one editor to another. On this book’s companion Web site you will find 
a VideoNote that gives one example of how it is done. 
 Figure 7-18  The  ghost.png image with its transparent background  
 Using Black to Create Transparent Backgrounds 
 Some of the simpler graphics editors do not support transparent backgrounds, even 
in  png files. Microsoft Paint is an example. If you are using such an editor, you can 
still create sprites that are displayed with a transparent background in your AGK 
programs. The process requires extra steps, however, than those previously shown.  
 NOTE:   The steps following steps are necessary only if you are using a graphics 
editor that does not support transparency in  .png files, such as Microsoft Paint. 
 First, in your graphics editor, use black as the background color. (The background must be 
pure black. A dark shade of gray will not work.) Then, in your AGK program, use the 
 agk::LoadImage function to load the image into memory, using the following general format: 
 agk::LoadImage( ImageIndex ,  ImageFile, BlackToTransparent ); 
 Here is a summary of the three arguments that you pass to the function: 
 ●  ImageIndex is the image index, which is a number that identifies the image in your 
program. The image index can be an integer in the range of 1 through 4,294,967,295. 
Once the image is loaded into memory, you will use its image index to identify it 
in subsequent operations. (Take note that the image index is not the same thing as 
a sprite index. The image index identifies an image only, not a sprite.)  
 ●  ImageFile is the name of the file that contains the image. This can be the name 
of any image file of the  .png ,  .jpg , or  .bmp file formats, however, only the  .png 
format supports transparency.  
VideoNote
Creating an image 
with a transparent 
background

 
7.3 Displaying Sprites 
281
 ●  BlackToTransparent can be either 0 or 1. It must be 1 if you want the black 
pixels to become transparent. If 0 is used, the black pixels will be displayed.  
 The  agk::LoadImage function does not create a sprite. It only loads the specified image 
into memory. To create a sprite from the loaded image, you use the  agk::CreateSprite 
function, using the following general format: 
 agk::CreateSprite( SpriteIndex ,  ImageIndex ); 
 Here is a summary of the two arguments that you pass to the function: 
 ●  SpriteIndex is the sprite index, which is a number that identifies the sprite in 
your program. The sprite index can be an integer in the range of 1 through 
4,294,967,295. Once the sprite is created, you will use its sprite index to identify 
it in subsequent operations.  
 ●  ImageIndex is the image index of an image that you have previously loaded with 
the  agk::LoadImage function.  
 Let’s look at an example of how to do this. The image on the left of  Figure   7-19  is in 
a file named  Dog.png . Notice that the image’s background is black. The image on the 
right is in a file named  Beach.png . (The figure also appears as Figure C-4 in the book’s 
color insert.) In Program 7-7 we will do the following: 
 ●  Create a sprite from the  Beach.png image and display it.  
 ●  Load the  Dog.png image with its black pixels transparent.  
 ●  Create a sprite from the dog image.  
 ●  Display the dog sprite over the beach sprite. Because the dog image’s black 
pixels are transparent, it will look like the dog is at the beach.  Figure   7-20  
(which also appears as Figure C-5 in the book’s color insert) shows the pro-
gram’s output.  
 Figure 7-19  The Dog and Beach images  

282 
Chapter 7 
 Using the App Game Kit with C++
 Program 7-7 
 (DogAtTheBeach) 
 1 // Includes, namespace and prototypes 
 2 #include "template.h" 
 3 using namespace AGK; 
 4 app App; 
 5  
 6 // Constants for the screen resolution 
 7 const int SCREEN_WIDTH = 640; 
 8 const int SCREEN_HEIGHT = 480; 
 9  
 10 // Constants for the beach background 
 11 const int BEACH_SPRITE_INDEX = 1; 
 12  
 13 // Constants for the Dog image and sprite 
 14 const int DOG_IMAGE_INDEX = 1; 
 15 const int DOG_SPRITE_INDEX = 2; 
 16 const int BLACK_TRANSPARENT = 1; 
 17 const int DOG_X = 100; 
 18 const int DOG_Y = 240; 
 19  
 20 // Begin app, called once at the start 
 21 void app::Begin( void ) 
 22 { 
 23    // Set the virtual resolution. 
 24    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 25  
 26    // Create the beach sprite. 
 27    agk::CreateSprite(BEACH_SPRITE_INDEX, "Beach.png"); 
 28  
 29    // Load the dog image with black pixels transparent. 
 30    agk::LoadImage(DOG_IMAGE_INDEX, "Dog.png", 
 31                  BLACK_TRANSPARENT); 
 32  
 33    // Create the dog sprite from the dog image. 
 34    agk::CreateSprite(DOG_SPRITE_INDEX, DOG_IMAGE_INDEX); 
 35  
 36    // Set the dog sprite's position. 
 37    agk::SetSpritePosition(DOG_SPRITE_INDEX, DOG_X, DOG_Y); 
 38 } 
 39  
 40 // Main loop, called every frame 
 41 void app::Loop ( void ) 
 42 { 
 43    // Display the screen. 
 44    agk::Sync(); 
 45 } 
 46  
 47 // Called when the app ends 
 48 void app::End ( void ) 
 49 { 
 50 }  

 
7.3 Displaying Sprites 
283
 Let’s take a closer look at the program. Here is a summary of the global constants: 
 ●  Lines 7 and 8 declare constants for the screen width and height.  
 ●  Line 11 declares a constant for the beach sprite’s index, which is 1.  
 ●  Line 14 declares a constant for the dog image index, which is 1.  
 ●  Line 15 declares a constant for the dog sprite index, which is 2.  
 ●  Line 16 declares a constant to specify that black pixels are transparent. We will 
use this when we load the dog image.  
 ●  Lines 17 and 18 declare constants for the dog sprite’s screen position.  
 Here is a summary of the  app::Begin function: 
 ●  Line 24 sets the virtual resolution.  
 ●  Line 27 creates a sprite with the index 1, using the graphic file  Beach.png . 
(The program will look for this file in the  My Documents >  AGK >  template 
folder.)  
 ●  Lines 30 and 31 load the  Dog.png image, assigning it the image index 1 and 
specifying that black pixels should be transparent.  
 ●  Line 34 creates a sprite from the dog image (image index 1) and assigns the 
sprite the sprite index 2.  
 ●  Line 37 positions the dog sprite at the coordinates (100, 240).  
 After the  app::Begin function finishes, the program executes the  app::Loop function. 
Line 44 calls the  agk::Sync function, which displays the backbuffer.  
 Figure 7-20  Output of Program 7-7  

284 
Chapter 7 
 Using the App Game Kit with C++
 Deleting Sprites 
 After a program is finished using a sprite, it can remove it with the  agk::DeleteSprite 
function. You pass a sprite index as an argument to the function, and it removes that sprite 
from memory. Assuming SPRITE_INDEX is a valid sprite index, here is an example: 
 agk::DeleteSprite(SPRITE_INDEX);  
 This statement removes the sprite specified by  SPRITE_INDEX from memory. Deleting 
unused sprites frees memory and can improve the program’s performance. If a pro-
gram has several sprites loaded and continues to run when those sprite are no longer 
needed, it’s a good idea to delete them to increase system performance. 
 You can determine whether a sprite exists with the  agk::GetSpriteExists function. 
Here is the general format: 
 agk::GetSpriteExists( SpriteIndex ) 
 In the general format,  SpriteIndex is the index of the sprite you are testing. If the 
sprite exists in memory, the function returns 1. Otherwise, it returns 0. The following 
code sample shows an example. It determines whether the sprite specified by 
 SPRITE_INDEX exists. If so, it sets the sprite’s location to (0, 0). 
 if ( agk::(GetSpriteExists(SPRITE_INDEX) == 1 ) 
 { 
     agk::SetSpritePosition(SPRITE_INDEX, 0, 0); 
 } 
 Organizing the Images in Your  template Folder 
 As you develop more AGK projects, your  My Documents >  AGK >  template folder 
will soon become cluttered with lots of image files. Fortunately, you can organize the 
image files in  My Documents >  AGK >  template folder. You do this by creating a 
subfolder for each project in  My Documents >  AGK >  template and then storing all 
the image files for that project in the subfolder. Of course, in your project’s source 
code you must include the name of the subfolder in the image file’s path. Let’s look at 
an example of how we might do this with a project that uses the ghost and haunted 
house graphics shown previously in this chapter. 
 First, we will create a folder named  HauntedHouse in the  My Documents >  AGK > 
 template folder, as shown on the left in  Figure  7-21  . Then, in the  HauntedHouse 
folder you will store the  haunted_house.png and  ghost.png graphic files, as shown on 
the right in  Figure   7-21 . Then, in Program 7-8 we load the images as sprites in lines 
25 through 26 and lines 29 through 30. Notice that we use the path names 
 HauntedHouse/haunted_house.png and  HauntedHouse/ghost.png to load the images.  
 Program 7-8 
  (ImageSubfolderDemo) 
 1 // Includes, namespace and prototypes 
 2 #include "template.h" 
 3 using namespace AGK; 
 4 app App; 
VideoNote
Organizing the 
Images in your 
template Folder

 
7.3 Displaying Sprites 
285
 5  
 6 // Constants for the screen resolution 
 7 const int SCREEN_WIDTH = 640; 
 8 const int SCREEN_HEIGHT = 480; 
 9  
 10 // Constants for the sprite indices 
 11 const int HOUSE_INDEX = 1; 
 12 const int GHOST_INDEX = 2; 
 13  
 14 // Constants for the ghost's position 
 15 const float GHOST_X = 200; 
 16 const float GHOST_Y = 150; 
 17  
 18 // Begin app, called once at the start 
 19 void app::Begin( void ) 
 20 { 
 21    // Set the virtual resolution. 
 22    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 23  
 24    // Create the haunted house sprite for the background. 
 25     agk::CreateSprite(HOUSE_INDEX, 
 26           "HauntedHouse/haunted_house.png"); 
 27  
 28    // Create the ghost sprite. 
 29     agk::CreateSprite(GHOST_INDEX, 
 30           "HauntedHouse/ghost.png"); 
 31  
 32    // Set the ghost's position. 
 33    agk::SetSpritePosition(GHOST_INDEX, GHOST_X, GHOST_Y); 
 34 } 
 35  
 36 // Main loop, called every frame 
 37 void app::Loop ( void ) 
 38 { 
 39    // Display the screen. 
 40    agk::Sync(); 
 41 } 
 42  
 43 // Called when the app ends 
 44 void app::End ( void ) 
 45 { 
 46 } 
 NOTE:    The  My Documents >  AGK >  template folder is the base folder for all 
your AGK projects’ media files. Your AGK projects will always look in this folder 
for resources such as image files. For this reason, any location that you specify for 
an image file in your AGK source code must be relative to the  My Documents > 
 AGK >  template folder. You cannot specify a location that is not under the  My 
Documents >  AGK >  template folder. 

286 
Chapter 7 
 Using the App Game Kit with C++
 Checkpoint 
 7.13.   What is a bitmap?  
 7.14.   What is a sprite?  
 7.15.   What is a sprite index?  
 7.16.   When you create a sprite, what is its default position on the screen?  
 7.17.   What is the backbuffer?  
 7.18.   What AGK function do you call to update the screen with the contents of the 
backbuffer?  
 7.19.   You can have multiple sprites on the screen at one time. By default, in what 
order are sprites drawn on the screen?  
 7.20.   How do you set a sprite’s position on the screen? How do you get a sprite’s 
current position?  
 7.21.   How do you get a sprite’s width and height? How do you scale a sprite so it is 
larger or smaller than its original size?  
 7.22.   How do you rotate a sprite? How do you get a sprite’s current angle of  rotation?  
 7.23.   How do you make a sprite invisible? If a sprite is already invisible, how do you 
make it visible?  
Create this folder.
 Figure 7-21  The  HauntedHouse folder created under  My  Documents >  AGK >  template 
 
 7.4  Working in the Game Loop 
 CONCEPT:    Most of your program’s work will be done in the  app::Loop function, 
which is the game loop of an AGK application.  

 
7.4 Working in the Game Loop 
287
 Now that you know the basics of creating and manipulating sprites, you can have 
some fun working in the  app::Loop function. The important thing to remember about 
the  app::Loop function is that it works like a loop. It begins executing after the 
 app::Begin function finishes, and it automatically repeats until the user ends the pro-
gram. Each iteration of the  app::Loop function is called a  frame . 
 Program 7-9 shows a simple example. When the program runs, it creates the ghost 
sprite that you have seen previously and displays it at the default coordinates of (0, 
0). During each iteration of the  app::Loop function, the sprite is rotated by 10 
degrees.  Figure   7-22 shows an example of the program’s output during one frame 
of execution. 
 Program 7-9 
  (SpinningSprite) 
 1 // Includes, namespace and prototypes 
 2 #include "template.h" 
 3 using namespace AGK; 
 4 app App; 
 5  
 6 // Constants for the screen resolution 
 7 const int SCREEN_WIDTH = 640; 
 8 const int SCREEN_HEIGHT = 480; 
 9  
 10 // Constants for the sprite index 
 11 const int GHOST_INDEX = 1; 
 12  
 13 // Constant for the amount to rotate 
 14 const float ROTATION = 10; 
 15  
 16 // Begin app, called once at the start 
 17 void app::Begin( void ) 
 18 { 
 19    // Set the virtual resolution. 
 20    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 21  
 22    // Create the ghost sprite. 
 23    agk::CreateSprite(GHOST_INDEX, "ghost.png"); 
 24 } 
 25  
 26 // Main loop, called every frame 
 27 void app::Loop ( void ) 
 28 { 
 29    // Get the ghost's angle. 
 30    float ghostAngle = agk::GetSpriteAngle(GHOST_INDEX); 
 31  
 32    // Rotate the ghost. 
 33    agk::SetSpriteAngle(GHOST_INDEX, ghostAngle + ROTATION); 
 34  
 35    // Display the screen. 
 36    agk::Sync(); 
 37 } 
 38  

288 
Chapter 7 
 Using the App Game Kit with C++
 39 // Called when the app ends 
 40 void app::End ( void ) 
 41 { 
 42 } 
 Figure 7-22  Screen capture of one frame from Program 7-9  
 Let’s take a closer look at the program. First, we have the following global  constants: 
 ●  In lines 7 and 8, the  SCREEN_WIDTH and  SCREEN_HEIGHT constants will be used to 
set the virtual resolution to 640 by 480 pixels.  
 ●  In line 11 the  GHOST_INDEX constant is set to 1. This will be used as the sprite 
index for the ghost.  
 ●  Line 14 sets the  ROTATION constant to 10. This is the amount by which the ghost 
sprite will be rotated during each frame.  
 The  app::Begin function does the following: 
 ●  Line 20 sets the virtual resolution to 640 by 480 pixels.  
 ●  Line 23 creates the ghost sprite.  
 The  app::Loop function does the following during each frame: 
 ●  Line 30 declares a  float variable named  ghostAngle . The variable is initialized with 
the value that is returned from the  agk::GetSpriteAngle function. After this state-
ment executes, the  ghostAngle variable will hold the ghost sprite’s current degrees 
of rotation. (If the sprite has not been rotated, the degrees of rotation will be 0).  
 ●  Line 33 calls the  agk::SetSpriteAngle function to rotate the ghost sprite. Notice 
that the second argument is the expression  ghostAngle + ROTATION . This specifies 
that the sprite’s angle of rotation should be its current angle plus 10.  
 ●  Line 36 calls the  agk::Sync function, which updates the screen.  
 Program 7-10 shows another simple example. When the program runs, it creates the 
ghost sprite and displays it at the coordinates (0, 150). During each iteration of the 
 app::Loop function, the sprite is moved to the right by 10 pixels. When the sprite reaches 
the rightmost edge of the screen, it is moved back to its original position.  Figure  7-23 
shows an example of the program’s output, during one frame of execution. 

 
7.4 Working in the Game Loop 
289
 Program 7-10 
  (LoopMoveSprite) 
 1 // Includes, namespace and prototypes 
 2 #include "template.h" 
 3 using namespace AGK; 
 4 app App; 
 5  
 6 // Constants for the screen resolution 
 7 const int SCREEN_WIDTH = 640; 
 8 const int SCREEN_HEIGHT = 480; 
 9  
 10 // Constants for the sprite index 
 11 const int GHOST_INDEX = 1; 
 12  
 13 // Constants for the ghost's starting position 
 14 const float GHOST_START_X = 0; 
 15 const float GHOST_START_Y = 150; 
 16  
 17 // Constant for the ghost's ending X coordinate 
 18 const float GHOST_END_X = 540; 
 19  
 20 // Constant for the amount to increment the 
 21 // ghost's X coordinate 
 22 const int INCREMENT = 10; 
 23  
 24 // Begin app, called once at the start 
 25 void app::Begin( void ) 
 26 { 
 27    // Set the virtual resolution. 
 28    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 29  
 30    // Create the ghost sprite. 
 31    agk::CreateSprite(GHOST_INDEX, "ghost.png"); 
 32  
 33    // Set the ghost's position. 
 34    agk::SetSpritePosition(GHOST_INDEX, 
 35                 GHOST_START_X, GHOST_START_Y); 
 36 } 
 37  
 38 // Main loop, called every frame 
 39 void app::Loop( void ) 
 40 { 
 41    // Get the ghost's current X coordinate. 
 42    float ghostX = agk::GetSpriteX(GHOST_INDEX); 
 43  
 44    if (ghostX < GHOST_END_X) 
 45    { 
 46       agk::SetSpriteX(GHOST_INDEX, ghostX + INCREMENT); 
 47    } 
 48    else 
 49    { 
 50       agk::SetSpriteX(GHOST_INDEX, GHOST_START_X); 
 51    } 
 52  
 53    // Display the screen. 

290 
Chapter 7 
 Using the App Game Kit with C++
 54    agk::Sync(); 
 55 } 
 56  
 57 // Called when the app ends 
 58 void app::End ( void ) 
 59 { 
 60 } 
 Figure 7-23  Screen capture of one frame from Program 7-10  
 Let’s take a closer look at the program. First, we have several global constants: 
 ●  In lines 7 and 8, the  SCREEN_WIDTH and  SCREEN_HEIGHT constants will be used to 
set the virtual resolution to 640 by 480 pixels.  
 ●  In line 11 the  GHOST_INDEX constant is set to 1. This will be used as the sprite 
index for the ghost.  
 ●  In lines 14 and 15, the  GHOST_START_X and  GHOST_START_Y constants are set to 0 
and 150, respectively. These will be used to set the ghost sprite’s initial position.  
 ●  In line 18 the  GHOST_END_X constant is set to 540. This is the ghost sprite’s ending 
position on the screen. When the sprite’s upper-left corner reaches this  X -coordinate, 
the program will move the sprite back to its original position. (The sprite is 
100 pixels wide, so it will be at the far right side of the screen when its upper-left 
corner is at 540.)  
 ●  Line 22 sets the  INCREMENT constant to 10. This is the amount by which the ghost 
sprite will move across the screen during each frame.  

 
7.4 Working in the Game Loop 
291
 The  app::Begin function does the following: 
 ●  Line 28 sets the virtual resolution to 640 by 480 pixels.  
 ●  Line 31 creates the ghost sprite.  
 ●  Lines 34 and 35 position the ghost sprite at the coordinates (0, 150).  
 The  app::Loop function does the following during each frame: 
 ●  Line 42 declares a  float variable named  ghostX . The variable is initialized with 
the value that is returned from the  agk::GetSpriteX function. After this statement 
executes, the  ghostX variable will hold the ghost sprite’s current  X -coordinate.  
 ●  The  if statement that begins in line 44 determines whether  ghostX is less than 
 GHOST_END_X (which is 540). If this is true, then the ghost has not reached the 
right edge of the screen, so line 46 moves the sprite right by 10 pixels. If  ghostX 
is not less than  GHOST_END_X , then the sprite has reached the right edge of the 
screen, and line 50 moves the sprite back to its original  X position, which is 0.  
 ●  Line 54 calls the  agk::Sync function, which updates the screen.  
 Changing the Sync Rate 
 The  sync rate , or  frame rate , is the number of times per second that  app::Loop function 
is executing. By default, the function executes approximately 60 times per second. Recall 
that each iteration of the  app::Loop function is called a frame. If the function is executing 
60 times per second, we say that the program has a sync rate of 60  frames per second . 
 Sometimes you might want to change the sync rate. For example, in Program 7-9 the 
ghost sprite moves very quickly across the screen, and you might want to slow the 
program down so you can see the ghost more easily. To slow the program down, you 
decrease its sync rate. You use the  agk::SetSyncRate  function to specify a sync rate. 
Here is the function’s general format: 
 agk::SetSyncRate( FramesPerSecond ,  Mode ); 
 Here is a summary of the function’s arguments in the general format: 
 ●  FramesPerSecond is a  float specifying the maximum number of frames per sec-
ond for the program. While the program is running, it will attempt to execute 
the  app::Loop function this many times per second. (We say  attempt because the 
program might be busy doing so much work that it cannot fully achieve the 
specified frame rate.)  
 ●  Mode is an  int that can be either 0 or 1. When the Mode is 0, the program uses the 
CPU less between frames and requires less power. This can be important for pro-
grams that run on mobile devices. When the Mode is 1, the program will use the CPU 
more intensively and consume more power, but the sync rate will be more accurate.  
 For example, if we want the ghost to move more slowly in Program 7-9, and we aren’t 
particularly concerned with CPU usage, we might add the following global constants: 
 const float FRAMES_PER_SECOND = 5; 
 const int REFRESH_MODE = 1;  
 Then, we might add the following statement to the  app::Begin function: 
 agk::SetSyncRate(FRAMES_PER_SECOND, REFRESH_MODE);  

292 
Chapter 7 
 Using the App Game Kit with C++
 This will slow the program’s sync rate to five frames per second, which is much slower 
than the default 60 frames per second.  
 Game State 
 A game can be in different states while it is running. For example, suppose you are 
playing a game in which you are driving a car on a racetrack. At any given moment, 
the game can be in one of several possible states, including the following: 
 ●  You are driving the car in the correct direction on the track.  
 ●  You are driving the car in the wrong direction on the track.  
 ●  You have crashed the car.  
 As your programs become more sophisticated, you will usually find that the game loop 
must determine the state that the game is in, and then act accordingly. For example, sup-
pose we want to enhance Program 7-10 so that the ghost moves back and forth across 
the screen. When the ghost reaches one side of the screen, it reverses directions and goes 
toward the opposite side of the screen. When it reaches that side of the screen, it reverses 
direction again. At any moment, the program can be in one of the following states: 
 ●  The ghost is moving to the right  
 ●  The ghost is moving to the left  
 In the game loop, the program has to determine which of these states the program is 
in and then determine whether the sprite has reached the edge of the screen that it is 
moving toward. If the sprite has not reached the edge of the screen, it must keep mov-
ing in its current direction. Otherwise, the sprite must reverse its direction. The fol-
lowing pseudocode shows the program’s logic:  
 
If the ghost is moving to the right
        If the ghost has not reached the right edge of the screen
              Move the ghost right 10 pixels
        Else
              Reverse the ghost's direction
        End If
Else
        If the ghost has not reached the left edge of the screen
              Move the ghost left 10 pixels
        Else
              Reverse the ghost's direction
        End If
End If
 
 Program 7-11 shows actual code that implements this logic.  Figure   7-24  illustrates 
how the program runs. 
 Program 7-11 
  (GameState) 
 1 // Includes, namespace and prototypes 
 2 #include "template.h" 
 3 using namespace AGK; 
 4 app App; 

 
7.4 Working in the Game Loop 
293
 5  
 6 // Global constants for screen resolution 
 7 const int   SCREEN_WIDTH = 640;  // Screen width 
 8 const int   SCREEN_HEIGHT = 480; // Screen height 
 9  
 10 // Global constants for the ghost sprite 
 11 const int   GHOST_INDEX = 1;     // Ghost sprite index 
 12 const float GHOST_START_X = 0;   // Ghost's starting X 
 13 const float GHOST_START_Y = 150; // Ghost's starting Y 
 14 const float GHOST_END_X = 540;   // Ghost's ending X 
 15 const int   INCREMENT = 10;      // Amount to move the ghost 
 16  
 17 // Global constants for the game state 
 18 const int   MOVING_RIGHT = 0; 
 19 const int   MOVING_LEFT  = 1; 
 20  
 21 // Global variable for game state 
 22 int g_gameState = MOVING_RIGHT; 
 23  
 24 // Begin app, called once at the start 
 25 void app::Begin( void ) 
 26 { 
 27    // Set the virtual resolution. 
 28    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 29  
 30    // Create the ghost sprite. 
 31    agk::CreateSprite(GHOST_INDEX, "ghost.png"); 
 32  
 33    // Set the ghost's position. 
 34    agk::SetSpritePosition(GHOST_INDEX, 
 35                 GHOST_START_X, GHOST_START_Y); 
 36 } 
 37  
 38 // Main loop, called every frame 
 39 void app::Loop( void ) 
 40 { 
 41    // Get the ghost's current X coordinate. 
 42    float ghostX = agk::GetSpriteX(GHOST_INDEX); 
 43  
 44    // Is the sprite moving to the right side of the screen? 
 45    if (g_gameState == MOVING_RIGHT) 
 46    { 
 47       // The sprite is moving right. Has it reached the 
 48       // edge of the screen? 
 49       if (ghostX < GHOST_END_X) 
 50       { 
 51          // Not at the edge yet, so keep moving right. 
 52          agk::SetSpriteX(GHOST_INDEX, ghostX + INCREMENT); 
 53       } 
 54       else 
 55       { 
 56          // The sprite is at the right edge of the screen. 
 57          // Change the game state to reverse directions. 
 58          g_gameState = MOVING_LEFT; 
 59       } 
 60    } 

294 
Chapter 7 
 Using the App Game Kit with C++
 61    else 
 62    { 
 63       // The sprite is moving to the left. 
 64       // Has it reached the edge of the screen? 
 65       if (ghostX > GHOST_START_X) 
 66       { 
 67          // Not at the edge yet, so keep moving left. 
 68          agk::SetSpriteX(GHOST_INDEX, ghostX - INCREMENT); 
 69       } 
 70       else 
 71       { 
 72          // The sprite is at the left edge of the screen. 
 73          // Change the game state to reverse directions. 
 74          g_gameState = MOVING_RIGHT; 
 75       } 
 76    } 
 77  
 78    // Display the screen. 
 79    agk::Sync(); 
 80 } 
 81  
 82 // Called when the app ends 
 83 void app::End ( void ) 
 84 { 
 85 } 
The sprite moves back and forth from one 
side of the screen to the other.
 Figure 7-24  The moving sprite from Program 7-11  

 
7.4 Working in the Game Loop 
295
 Let’s take a closer look at the program. First, we have the global constant declaration 
for the screen resolution and various properties of the sprite: 
 ●  In lines 7 and 8, the  SCREEN_WIDTH and  SCREEN_HEIGHT constants will be used to 
set the virtual resolution to 640 by 480 pixels.  
 ●  In line 11 the  GHOST_INDEX constant is set to 1. This will be used as the sprite 
index for the ghost.  
 ●  In lines 12 and 13, the  GHOST_START_X and  GHOST_START_Y constants are set to 0 
and 150, respectively. These will be used to set the ghost sprite’s initial position.  
 ●  In line 14 the  GHOST_END_X constant is set to 540. This is the ghost sprite’s ending 
position on the screen. When the sprite’s upper-left corner reaches this  X -coordinate, 
the program will move the sprite back to its original position. (The sprite is 
100 pixels wide, so it will be at the far right side of the screen when its upper-left 
corner is at 540.)  
 ●  Line 15 sets the  INCREMENT constant to 10. This is the amount by which the ghost 
sprite will move across the screen during each frame.  
 Next we have the following global constant declarations that will be used to indicate 
which state the program is in: 
 ●  Line 18 declares the  int constant  MOVING_RIGHT , set to the value 0.  
 ●  Line 19 declares the  int constant  MOVING_LEFT , set to the value 1.  
 Then we declare the following global declaration: 
 ●  Line 22 declares the global  int variable  g_gameState , initialized to the value 
 MOVING_RIGHT . 
 The global variable  g_gameState will be used to indicate which state the program is 
in. When the sprite is moving to the right, this variable will be set to the value 
 MOVING_RIGHT . When the sprite is moving to the left, this variable will be set to the 
value  MOVING_LEFT . Any time the program needs to know what state it is in, it can 
examine the contents of this variable. (Note that we have started the name of the vari-
able with the  g_ prefix to indicate that it is a global variable. This is not required, but 
it is a convention that we will use in this  book . When you are reading the code, the 
 g_ prefix serves as a reminder that the variable is global.) 
 The  app::Begin function does the following: 
 ●  Line 28 sets the virtual resolution to 640 by 480 pixels.  
 ●  Line 31 creates the ghost sprite.  
 ●  Lines 34 and 35 position the ghost sprite at the coordinates (0, 150).  
 The  app::Loop function does the following: 
 ●  Line 42 declares a  float variable named  ghostX . The variable is initialized 
with the value that is returned from the  agk::GetSpriteX function. After this 
statement executes, the  ghostX variable will hold the ghost sprite’s current 
 X -coordinate.  
 ●  The logic that was previously shown as pseudocode is implemented in the set of 
nested  if statements that begins in line 45: 
 ●  The  if statement in line 45 determines whether  g_gameState is equal to 
 MOVING_RIGHT . If so, then the sprite is moving to the right, and the  if statement 

296 
Chapter 7 
 Using the App Game Kit with C++
in line 49 determines whether the sprite has not reached the right edge of the 
screen. If this is the case, the statement in line 52 moves the sprite to the right 
10 pixels. However, if the sprite has reached the right edge of the screen, line 
58 assigns  MOVING_LEFT to the  g_gameState variable to indicate that the sprite 
is now moving to the left. (This changes the game state.)  
 ●  When the  if statement in line 45 executes, if the  g_gameState variable is set 
to  MOVING_LEFT , the program will jump to the  else clause in line 61. Then, the 
 if statement in line 65 determines whether the sprite has not reached the left 
edge of the screen. If this is the case, the statement in line 68 moves the sprite 
to the left 10 pixels. However, if the sprite has reached the left edge of the 
screen, line 74 assigns  MOVING_RIGHT to the  g_gameState variable, to indicate 
that the sprite is now moving to the right. (This changes the game state.)  
 ●  Line 79 calls the  agk::Sync function, which updates the screen.  
 WARNING!   It should be mentioned that, whenever possible, the use of global 
variables should be avoided, or at least kept to a minimum.  Recall that  Chapter   6 
discussed the potential problems that global variables can cause.  In some situations, 
however, a global variable can be justified if there is simply no better way to accom-
plish the required task. This is the case with Program 7-10. 
 Checkpoint 
 7.24.   What is a frame?  
 7.25.   What is the sync rate (or frame rate)?  
 7.26.   How do you change the default sync rate in an AGK program?  
 7.27.   In your own words, what is meant by “game state”?  
 
 7.5  Working with Colors and Transparency 
 CONCEPT:    The AGK uses the RGB (red, green, and blue) system to specify col-
ors for pixels. The pixels of images that are stored in .png files also 
have a fourth component, known as the alpha channel, that specifies 
transparency.  
 The RGB Color System 
 The AGK uses the  RGB color system to define colors. In the RGB color system, all 
colors are created by mixing various shades of red, green, and blue. For example, in 
the RGB system, if you mix bright red, bright green, and no blue, you get yellow. If 
you mix bright red, bright blue, and no green, you get purple. White is created by 
mixing all three colors at their maximum brightness, and black is created when there 
is no red, green, or blue. 

 
7.5 Working with Colors and Transparency 
297
 In programming, we commonly refer to the red, green, and blue components of a 
color as  color channels . When you define a color, you specify a value in the range of 
0 through 255 for each of the color channels. The higher the number for a channel, 
the brighter that color component will be. For a quick demonstration of how these 
channels work, we can use the  agk::SetClearColor function and the  agk::ClearScreen 
function. The  agk::SetClearColor function specifies a background color that will fill 
the screen when the  agk::ClearScreen function is called. Here is the general format 
of how you call the  agk::SetClearColor function: 
 agk::SetClearColor( Red, Green, Blue );  
 In the general format, the Red, Green, and Blue arguments are values for the red, 
green, and blue color channels. For example, the following statement calls the func-
tion and specifies 255 for the red channel, 0 for the green channel, and 127 for the 
blue channel: 
 agk::SetClearColor(255, 0, 127);  
 The color that is created by these channel values will be the combination of bright 
red, no green, and medium-intensity blue. The result will be a color in the purple or 
magenta family. Here is another example: 
 agk::SetClearColor(255, 0, 0);  
 This statement specifies 255 for red, 0 for green, and 0 for blue. These values specify 
a bright red color. Here is another example: 
 agk::SetClearColor(255, 255, 255);  
 This statement specifies 255 for red, 255 for green, and 255 for blue. These values 
result in the color white.  Figure C-1 (which is located in this book’s color insert) 
shows how various red, green, and blue channel values create cyan, magenta, white, 
and black.  
 Once you have set the background color, you can call the  agk::ClearScreen function 
to clear the screen and fill it with the specified color. Here is the function’s general 
format: 
 agk::ClearScreen();  
 Applying Colors and Transparency to Sprites 
 Although image files have their own colors, you can apply a color to an existing 
sprite, giving it a tint. For example, if you can give a sprite a red tint by setting its red 
color channel. You can set the individual red, green, and blue color channels with the 
following functions: 
 agk::SetSpriteColorRed( SpriteIndex ,  RedChannel ); 
 agk::SetSpriteColorGreen( SpriteIndex ,  GreenChannel ); 
 agk::SetSpriteColorBlue( SpriteIndex ,  BlueChannel ); 
 In each of the functions, the   SpriteIndex is the index of a sprite. The   RedChannel , 
 GreenChannel , and   BlueChannel arguments are integers in the range of 0 through 255, 
specifying a value for the sprite’s red channel, green channel, or blue channel. 

298 
Chapter 7 
 Using the App Game Kit with C++
 For example, assuming  SPRITE_INDEX is a valid sprite index, the following statement 
sets the sprite’s red channel to 200, giving it a red tint: 
 agk::SetSpriteColorRed(SPRITE_INDEX, 200);  
 The following statements set the sprite’s red, green, and blue channels to 50, 100, and 
200, respectively: 
 agk::SetSpriteColorRed(SPRITE_INDEX, 50); 
 agk::SetSpriteColorGreen(SPRITE_INDEX, 100); 
 agk::SetSpriteColorBlue(SPRITE_INDEX, 200);  
 Sprites also have an alpha value, which specifies the sprite’s transparency. A sprite’s 
alpha value is an integer in the range of 0 through 255. If a sprite’s alpha value is set 
to 255 (which is the default value), then the sprite is completely opaque, and you can-
not see through it. An alpha value of 0 makes a sprite completely invisible. Alpha 
values between 0 and 255 will make the sprite semitransparent. You can use the 
 agk::SetSpriteColorAlpha to set a sprite’s alpha value. Here is the function’s general 
format: 
 agk::SetSpriteColorAlpha( SpriteIndex ,  Alpha ); 
 In the general format,   SpriteIndex is the index of a sprite, and   Alpha is an integer in 
the range of 0 through 255, specifying the sprite’s transparency. For example, assum-
ing  SPRITE_INDEX is a valid sprite index, the following statements demonstrate the 
function: 
 agk::SetSpriteColorAlpha(SPRITE_INDEX, 100); // Semitransparent 
 agk::SetSpriteColorAlpha(SPRITE_INDEX, 0);   // Invisible 
 agk::SetSpriteColorAlpha(SPRITE_INDEX, 255); // Opaque  
 Figure  7-25 shows an example of a semitransparent sprite. The ghost sprite in the 
figure has an alpha value of 100. (This also appears as Figure C-6 in the book’s 
color insert.)  
 Figure 7-25  Ghost sprite with alpha value of 100  

 
7.5 Working with Colors and Transparency 
299
 You can use the  agk::SetSpriteColor function to set all of a sprite’s color channels, 
including its alpha value, with one function call. Here is the general format: 
 agk::SetSpriteColor( SpriteIndex ,  Red ,  Green ,  Blue ,  Alpha );  
 In the general format,   SpriteIndex is the index of a sprite. The   Red ,   Green , and   Blue , 
and  Alpha arguments are integers in the range of 0 through 255, specifying a value for 
the sprite’s red, green, and blue channels, and the sprite’s alpha value. Assuming 
 SPRITE_INDEX is a valid sprite index, the following statement demonstrates the function: 
 agk::SetSpriteColorAlpha(SPRITE_INDEX, 50, 25, 200, 100);  
 In this example, the sprite’s red, green and blue channels are set to 50, 25, and 200, 
respectively. Its alpha value is set to 100.  
 Getting a Sprite’s Color and Alpha Values 
 You can get a sprite’s red, green, blue, and alpha values with the following functions: 
 agk::GetSpriteColorRed( SpriteIndex ); 
 agk::GetSpriteColorGreen( SpriteIndex ); 
 agk::GetSpriteColorBlue( SpriteIndex ); 
 agk::GetSpriteColorAlpha( SpriteIndex );  
 In each of the general formats,   SpriteIndex is the index of a sprite. The functions return 
the specified sprite’s red, green, blue, and alpha values. For example, assuming 
 SPRITE_INDEX is a valid sprite index, the following code demonstrates each function call: 
 // Declare variables to hold the sprite's color attributes. 
 int red, green, blue, alpha; 
 // Get the sprite's color attributes. 
 red = agk::GetSpriteColorRed(SPRITE_INDEX); 
 green = agk::GetSpriteColorGreen(SPRITE_INDEX); 
 blue = agk::GetSpriteColorBlue(SPRITE_INDEX); 
 alpha = agk::GetSpriteColorAlpha(SPRITE_INDEX);  
 After this code executes, the variables  red ,  green ,  blue , and  alpha will contain the 
sprite’s red, green, blue, and alpha values. 
 Checkpoint 
 7.28.  What three color channels does the RGB system use to generate colors?  
 7.29.  What color is specified by each of the following statements? 
 agk::SetClearColor(0, 0, 255); 
 agk::SetClearColor(255, 0, 0); 
 agk::SetClearColor(0, 255, 0); 
 agk::SetClearColor(255, 255, 255); 
 agk::SetClearColor(0, 0, 0);  
 7.30.  What happens when you apply a color to a sprite?  
 7.31.  What is a sprite’s alpha value? What are the valid values for a sprite’s alpha value?  

300 
Chapter 7 
 Using the App Game Kit with C++
 
 7.6  Displaying Text in the AGK Window 
 CONCEPT:    You can use the  agk::Print and  agk::PrintC functions to display text 
in the AGK window. 
 Most of your AGK programs will use sprites to display graphics, but in some situa-
tions you might want to display text. The AGK provides two functions for displaying 
text in the AGK window. These functions are  agk::Print and  agk::Printc . 
 The  agk::Print function prints a line of output in the AGK window, followed by a 
newline. This is similar to using  endl with a  cout statement in standard C++. After the 
 agk::Print function executes, the output of a subsequent to the function will appear 
on the next line in the window. 
 The three different general formats for the  agk::Print function are shown here: 
 agk::Print( IntValue ); 
 agk::Print( FloatValue ); 
 agk::Print( String );  
 In the first general format,   IntValue is an integer value that is displayed. In the second 
general format,   FloatValue is a  float value that is displayed. In the third general 
format,   String is a string that is displayed. Program 7-12 demonstrates each of these 
functions. The program’s output is shown in  Figure   7-26  . 
 Program 7-12 
  (PrintDemo) 
 1 // Includes, namespace and prototypes 
 2 #include "template.h" 
 3 using namespace AGK; 
 4 app App; 
 5  
 6 // Constants for the screen resolution 
 7 const int SCREEN_WIDTH = 640; 
 8 const int SCREEN_HEIGHT = 480; 
 9  
 10 // Begin app, called once at the start 
 11 void app::Begin( void ) 
 12 { 
 13    // Set the virtual resolution. 
 14    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 15 } 
 16  
 17 // Main loop, called every frame 
 18 void app::Loop ( void ) 
 19 { 
 20    // Declare variables 
 21    int iNum = 1; 

 
7.6 Displaying Text in the AGK Window 
301
 22    float fNum = 99.5; 
 23  
 24    // Display some values. 
 25    agk::Print("This demonstrates the agk::Print function."); 
 26    agk::Print("Here are an int and a float:"); 
 27    agk::Print(iNum); 
 28    agk::Print(fNum); 
 29  
 30    // Display the screen. 
 31    agk::Sync(); 
 32 } 
 33  
 34 // Called when the app ends 
 35 void app::End ( void ) 
 36 { 
 37 } 
 Figure 7-26  Output of Program 7-12  
 The  agk::PrintC function prints a line of output in the AGK window without an ending 
newline. The output of any subsequent call to  agk::PrintC or  agk::Print will follow 
immediately, on the same line. Here are the general formats of the  agk::PrintC function: 
 agk::PrintC( IntValue ); 
 agk::PrintC( FloatValue ); 
 agk::PrintC( String ); 

302 
Chapter 7 
 Using the App Game Kit with C++
 In the first general format,   IntValue is an integer value that is displayed. In the second 
general format,   FloatValue is a  float value that is displayed. In the third general 
format,   String is a string that is displayed. Program 7-13 demonstrates each of these 
functions. The program’s output is shown in  Figure   7-27  . 
 Program 7-13 
  (PrintCDemo) 
 1 // Includes, namespace and prototypes 
 2 #include "template.h" 
 3 using namespace AGK; 
 4 app App; 
 5  
 6 // Constants for the screen resolution 
 7 const int SCREEN_WIDTH = 640; 
 8 const int SCREEN_HEIGHT = 480; 
 9  
 10 // Begin app, called once at the start 
 11 void app::Begin( void ) 
 12 { 
 13    // Set the virtual resolution. 
 14    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 15 } 
 16  
 17 // Main loop, called every frame 
 18 void app::Loop ( void ) 
 19 { 
 20    // Declare variables 
 21    int iNum = 1; 
 22    float fNum = 99.5; 
 23  
 24    // Display some values. 
 25    agk::PrintC("Here are an int and a float:"); 
 26    agk::PrintC(iNum); 
 27    agk::PrintC(fNum); 
 28  
 29    // Display the screen. 
 30    agk::Sync(); 
 31 } 
 32  
 33 // Called when the app ends 
 34 void app::End ( void ) 
 35 { 
 36 } 
 In this program, line 25 prints the string  "Here are an int and a float:" . Then, line 
26 prints the value of the  iNum variable, which is 1. Notice that the output of line 26 
appears immediately after the output of line 25. Then, line 27 prints the value of the 
 fNum variable, which is 99.5. Notice that the output of line 27 appears immediately 
after the output of line 26. 

 
7.6 Displaying Text in the AGK Window 
303
 Printing  string Objects 
 In Programs 7-12 and 7-13 you saw string literals being printed in the AGK window. 
You can declare  string objects in your AGK programs, but you cannot pass a  string 
object directly to the  agk::Print or  agk::PrintC functions. Instead, you must call a 
member function named  c_str that is built into the  string object. Functions that are 
built into objects are known as  member functions . The  c_str member function con-
verts the contents of a  string object to a format that is compatible with the  agk::Print 
and  agk::PrintC functions. This is the general format of the  c_str member function: 
 StringObject .c_str()  
 In the general format,   StringObject is the name of the  string object that you are 
converting. The function returns a string that can be passed directly to  agk::Print or 
 agk::PrintC . Program 7-14 demonstrates how this is done.  Figure   7-28  shows the 
program’s output. 
 Program 7-14 
 (AGKPrintString) 
 1 // Includes, namespace and prototypes 
 2 #include <string>       // Needed for string objects 
 3 #include "template.h" 
 4 using namespace AGK; 
 5 using namespace std;    // Needed for string objects 
 6 app App; 
 Figure 7-27  Output of Program 7-13  

304 
Chapter 7 
 Using the App Game Kit with C++
 7  
 8 // Constants for the screen resolution 
 9 const int SCREEN_WIDTH = 640; 
 10 const int SCREEN_HEIGHT = 480; 
 11  
 12 // Begin app, called once at the start 
 13 void app::Begin( void ) 
 14 { 
 15    // Set the virtual resolution. 
 16    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 17 } 
 18  
 19 // Main loop, called every frame 
 20 void app::Loop ( void ) 
 21 { 
 22    // Declare a string object. 
 23    string str = "This is a test."; 
 24  
 25    // Display the string object. 
 26    agk::Print(str.c_str()); 
 27  
 28    // Display the screen. 
 29    agk::Sync(); 
 30 } 
 31  
 32 // Called when the app ends 
 33 void app::End ( void ) 
 34 { 
 35 } 
 Figure 7-28  Output of Program 7-14  

 
7.7 Generating Random Numbers 
305
 Let’s take a closer look at the program. 
 ●  Line 2 includes the  string header file, which is required for any program using 
 string objects.  
 ●  The  using namespace std; statement in line 5 is also required for  string objects 
because the  string class is part of the C++ standard library.  
 ●  Inside the  app::Loop function, in line 23 we declare a  string object named  str , 
initialized with the string  "This is a test." 
 ●  Line 26 calls the  str object’s  c_str () member function, and the value that is 
returned from the function is passed to the  agk::Print function. As a result, the 
value of the  str object is displayed.  
 ●  Line 29 calls the  agk::Sync function to update the screen.  
 Displaying a Title in the Window’s Title Bar 
 In an AGK program, the  agk::SetWindowTitle function displays text in the window’s 
title bar, which appears at the top of the window. This helps you to customize the ap-
pearance of the window. Here is the general format of how you call the function: 
 agk::SetWindowTitle( String ) 
 In the general format   String is the string that you want to appear in the window’s 
title bar. Here is an example: 
 agk::SetWindowTitle("My AGK Program");  
 This causes the text  "My AGK Program" to appear in the window’s title bar, as shown 
in  Figure   7-29 . 
 Figure 7-29  The window title set  
 Checkpoint 
 7.32.  What is the difference between the  agk::Print and  agk::PrintC functions? 
 7.33.  How do you print the contents of a string object with the  agk::Print and 
 agk::PrintC functions?  
 7.34.  How do you display text in the output window’s title bar?  
 
  7.7  Generating Random Numbers 
 CONCEPT:    Random numbers are used in many applications, including games. 
The AGK provides a function named  agk::Random that generates ran-
dom numbers. 

306 
Chapter 7 
 Using the App Game Kit with C++
 The AGK provides a function named  agk::Random that generates random numbers. 
Random numbers are useful for lots of different programming tasks. The following 
are a few examples: 
 ●  Random numbers are commonly used in games. For example, computer games 
that let the player roll dice use random numbers to represent the values of the 
dice. Games that show cards being drawn from a shuffled deck use random 
numbers to represent the face values of the cards.  
 ●  Random numbers are useful in simulation programs. In some simulations, the 
computer must randomly decide how a person, animal, insect, or other living 
being will behave. Formulas can be constructed in which a random number is 
used to determine various actions and events that take place in the program.  
 ●  Random numbers are useful in statistical programs that must randomly select 
data for analysis.  
 ●  Random numbers are commonly used in computer security to encrypt sensitive 
data.  
 The  agk::Random function can be called in the following general format: 
 agk::Random()  
 In this general format, the function returns a random number in the range of 0 through 
65,535. For example, after the following statement executes, the  number variable will 
be assigned a value in the range of 0 through 65,535: 
 int number; 
 number = agk::Random();  
 If you want to specify a range for the random number, you can call the function using 
the following general format: 
 agk::Random( From ,  To ) 
 In this general format the   From argument is the lowest possible value to return and   To 
is the highest possible value to return. The function will return a random number 
within the range of these two values. For example, after the following code executes, 
the  number variable will be assigned a random value in the range of 1 through 10: 
 int number; 
 number = agk::Random(1, 10);  
 The following code sample shows another example: positioning a sprite at a random loca-
tion on the screen. Assume the constants  SCREEN_WIDTH and  SCREEN_HEIGHT have been set 
to the width and height of the AGK window and that  SPRITE_INDEX is a valid sprite index. 
 1  // Declare variables for the sprite's X- and Y-coordinates. 
 2  int spriteX, spriteY; 
 3 
 4  // Get random values for the X- and Y-coordinates. 
 5  spriteX = agk::Random(0, SCREEN_WIDTH); 
 6  spriteY = agk::Random(0, SCREEN_HEIGHT); 
 7 
 8  // Set the sprite's position. 
 9  agk::SetSpritePosition(SPRITE_INDEX, spriteX, spriteY);  

 
7.7 Generating Random Numbers 
307
 Let’s take a closer look at the code: 
 ●  Line 2 declares two  int variables:  spriteX and  spriteY . These variables will be 
used to hold the sprite’s  X- and  Y -coordinates. 
 ●  Line 5 gets a random number in the range of 0 through  SCREEN_WIDTH and as-
signs it to the  spriteX variable.  
 ●  Line 6 gets a random number in the range of 0 through  SCREEN_HEIGHT and as-
signs it to the  spriteY variable.  
 ●  Line 9 sets the sprite that is specified by  SPRITE_INDEX to the coordinates held in 
the  spriteX and  spriteY variables.  
 The following  In the Spotlight section shows how this is done in a complete program.  
 In the Spotlight: 
 Using Random Numbers to Position 
a Sprite and Set its Transparency 
 Program 7-15 displays the haunted house sprite as the background image, and during 
each frame, it displays the ghost sprite at a random location. The ghost’s alpha value 
is also randomly generated during each frame (within the range of 50 through 255). 
As a result, the ghost will appear to jump around to random locations on the screen, 
with varying levels of transparency. The program’s sync rate is slowed to five frames 
per second to make the ghost easier to see.  Figure   7-30  shows the ghost as it appears 
in various frames. 
 Program 7-15 
  (RandomPositionAndAlpha) 
 1 // Includes, namespace and prototypes 
 2 #include "template.h" 
 3 using namespace AGK; 
 4 app App; 
 5  
 6 // Constants for the screen resolution 
 7 const int SCREEN_WIDTH = 640; 
 8 const int SCREEN_HEIGHT = 480; 
 9  
 10 // Constants for the frame rate and refresh mode. 
 11 const float FRAME_RATE = 5; 
 12 const int REFRESH_MODE = 1; 
 13  
 14 // Constants for the sprite indices 
 15 const int HOUSE_INDEX = 1; 
 16 const int GHOST_INDEX = 2; 
 17  
 18 // Constants for the ghost's minimum and maximum alpha. 
 19 const int MIN_ALPHA = 50; 
 20 const int MAX_ALPHA = 255; 
 21  
 22 // Begin app, called once at the start 

308 
Chapter 7 
 Using the App Game Kit with C++
 23 void app::Begin( void ) 
 24 { 
 25    // Set the virtual resolution. 
 26    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 27  
 28    // Create the haunted house sprite for the background. 
 29    agk::CreateSprite(HOUSE_INDEX, 
 30          "HauntedHouse/haunted_house.png"); 
 31  
 32    // Create the ghost sprite. 
 33    agk::CreateSprite(GHOST_INDEX, 
 34          "HauntedHouse/ghost.png"); 
 35  
 36    // Set the frame rate. 
 37    agk::SetSyncRate(FRAME_RATE, REFRESH_MODE); 
 38 } 
 39  
 40 // Main loop, called every frame 
 41 void app::Loop ( void ) 
 42 { 
 43    // Variables for the ghost's location and alpha value 
 44    int ghostX, ghostY, ghostAlpha; 
 45  
 46    // Get random coordinates. 
 47    ghostX = agk::Random(0, SCREEN_WIDTH); 
 48    ghostY = agk::Random(0, SCREEN_HEIGHT); 
 49  
 50    // Get a random value for the ghost's alpha. 
 51    ghostAlpha = agk::Random(MIN_ALPHA, MAX_ALPHA); 
 52  
 53    // Set the ghost's position. 
 54    agk::SetSpritePosition(GHOST_INDEX, ghostX, ghostY); 
 55  
 56    // Set the ghost's alpha value. 
 57    agk::SetSpriteColorAlpha(GHOST_INDEX, ghostAlpha); 
 58  
 59    // Display the screen. 
 60    agk::Sync(); 
 61 } 
 62  
 63 // Called when the app ends 
 64 void app::End ( void ) 
 65 { 
 66 } 
 Let’s take a closer look at the program. Here is a summary of the global constants: 
 •  Lines 7 and 8 declare constants for the screen size.  
 •  Line 11 declares a constant for that will be used to change the program’s sync 
rate. This constant specifies a sync rate of five frames per second.  
 •  Line 12 declares a constant specifying a refresh mode of 1. Recall that the 
refresh mode 1 causes the program to use more CPU power, but more accurately 
refreshes the screen at the specified number of frames per second.  

 
7.7 Generating Random Numbers 
309
 •  Lines 15 and 16 declare constants for the sprite indices.  
 •  Lines 19 and 20 declare constants that specify the minimum and maximum 
alpha values for the ghost sprite.  
 Here is a description of the  app::Begin function: 
 •  Line 26 sets the virtual resolution.  
 •  Lines 29 and 30 create the haunted house sprite.  
 •  Lines 33 and 34 create the ghost sprite.  
 •  Line 37 sets the sync rate to five frames per second. This will cause the program 
to update the screen slowly enough to see the ghost between frames.  
 Here is a description of the  app::Loop function: 
 •  Line 44 declares the  ghostX variable, which will hold the ghost’s  X -coordinate, 
the  ghostY variable, which will hold the ghost’s  Y -coordinate, and the  ghostAlpha 
variable, which will hold the ghost’s alpha value.  
 •  Line 47 gets a random number between 0 and the width of the screen and 
assigns the number to the  ghostX variable.  
 •  Line 48 gets a random number between 0 and the height of the screen and 
assigns the number to the  ghostY variable.  
 •  Line 51 gets a random number between 50 and 255 and assigns the number to 
the  ghostAlpha variable.  
 •  Line 54 sets the ghost sprite’s position to the coordinates specified by the  ghostX 
and  ghostY variables.  
 •  Line 57 sets the ghost sprite’s alpha value to the number stored in the  ghostAlpha 
variable.  
 •  Line 60 updates the screen.  
 Figure 7-30  Three frames of output of Program 7-15  

310 
Chapter 7 
 Using the App Game Kit with C++
 Checkpoint 
 7.35.   After this statement executes, what value will be stored in the  number variable? 
 int number = agk::Random();  
 7.36.   After this statement executes, what value will be stored in the  number variable? 
 int number = agk::Random(0, 100);  
 Review Questions 
 Multiple Choice  
 
1.  This is a loop that repeats continuously, until the game is over:  
 a.  Initialization loop.  
 b.  Game loop.  
 c.  Player’s loop. 
 d.  AGK Loop.  
 
2.  In the AGK C++ template, this function executes once, when the program starts:  
 a.  app::Begin. 
 b.  app::Loop. 
 c.  app::End. 
 d.  app::Start. 
 
3.   In the AGK C++ template, this function performs the game loop:  
 a.  app::Begin. 
 b.  app::Loop. 
 c.  app::End. 
 d.  app::GameLoop. 
 
4.  In the AGK C++ template, this function executes when the program ends:  
 a.  app::Begin. 
 b.  app::Loop. 
 c.  app::End. 
 d.  app::Shutdown. 
 
5.  These are the tiny dots that make up the display area of the screen:  
 a.  display points. 
 b.  pixels. 
 c.  backlights.  
 d.  display elements.  
 
6.  This is used to identify a specific position within the AGK’s output window:  
 a.  coordinate system.  
 b.  position locator.  
 c.  position sensor. 
 d.  memory address.  

 
Review Questions 
311
 
7.   This is the AGK’s default method of handling screen coordinates:  
 a.  planar. 
 b.  virtual resolution.  
 c.  percentage-based.  
 d.   memory mapped.  
 
8.   This is the default size of the AGK output window:  
 a.  1024 by 768. 
 b.  100 by 100. 
 c.  640 by 480. 
 d.  2048 by 1536.  
 
9.   You call this function in an AGK program to use the virtual resolution system:  
 a.  agk::SetVirtualResolution. 
 b.  agk::VirtualResolution. 
 c.  agk::Resolution. 
 d.  Nothing. Virtual resolution is used by default.  
 
10.   This is a set of data that describes every pixel in an image:  
 a.  pixel dataset.  
 b.  display database.  
 c.   bitmap. 
 d.  pixelmap. 
 
11.   A graphic image displayed in a game program is usually called this:  
 a.  pixie. 
 b.  sprite.  
 c.   elf.  
 d.  troll. 
 
12.  This is a copy of the output screen that the AGK keeps in memory:  
 a.  backbuffer.  
 b.  backcopy. 
 c.  backup screen.  
 d.  screen clone.  
 
13.   This function updates the screen:  
 a.  agk::UpdateScreen. 
 b.   agk::DrawScreen. 
 c.   agk::Sync. 
 d.  agk::SyncScreen. 
 
14.   Each iteration of the  app::Loop function is:  
 a.  one millisecond long.  
 b.  one CPU clock cycle.  
 c.  one frame.  
 d.  one second long.  
 
15.   In the AGK, colors are generated by combining these color channels:  
 a.  red, green, and yellow.  
 b.  cyan, magenta, and yellow.  
 c.  red, orange, yellow, green, blue, indigo, and violet.  
 d.  red, green, and blue.  

312 
Chapter 7 
 Using the App Game Kit with C++
 
16.  A sprite’s transparency is specified by this:  
 a.  the sprite’s alpha value.  
 b.  the sprite’s name.  
 c.  the value of the sprite’s RGB channels added together.  
 d.  the program’s sync rate.  
 True or False  
 
1.  In the AGK C++ template, the  app::Begin function works as the program’s 
game loop.  
 
2.  The  app::Loop function does not loop automatically. It is meant to be called from 
a  while loop. 
 
3.  By default, the AGK uses the virtual resolution system for its output window.  
 
4.  The default size of the AGK output window in virtual resolution is 100 
by 100.  
 
5.  A sprite index must be in the range of 0 through 255.  
 
6.  A sprite with a depth of 0 will be drawn before a sprite with a depth of 100.  
 
7.  You can specify a value in the range of 0 through 255 for an RGB color channel.  
 Short Answer  
 
1.  What three general phases are virtually all game programs structured into?  
 
2.   What is the game loop in a game program?  
 
3.   What are the three functions that are already provided in the AGK C++ template? 
How do they relate to the three phases of a game program?  
 
4.   What is a pixel?  
 
5.  What is the default resolution of the AGK’s output window when virtual resolu-
tion is used?  
 
6.   What is the default resolution of the AGK’s output window when virtual resolu-
tion is used?  
 
7.   What is a bitmap?  
 
8.   What is a sprite?  
 
9.   What is the backbuffer?  
 
10.  How does sprite depth affect the order in which sprites are drawn?  
 
11.   What are the three color channels in the RGB system?  
 
12.   What color would result from the RGB color channels (0, 0, 255)?  
 
13.   What is an alpha value? What happens if you set a sprite’s alpha value to 0? What 
happens if you set a sprite’s alpha value to 255? What happens if you set a sprite’s 
alpha value to 50?  

 
Programming Exercises 
313
 Algorithm Workbench  
 
1.   Assume the file  goldfish.png is in your  My Documents >  AGK >  template folder. 
Write a statement that creates a sprite using this image file, with the sprite index 1.  
 
2.   Assume  SPRITE_INDEX is a valid sprite index. Write a statement that makes the 
sprite twice its current size.  
 
3.   Assume  SPRITE_INDEX is a valid sprite index. Write a statement that rotates the 
sprite 45 degrees.  
 
4.   Assume  SPRITE_INDEX is a valid sprite index. Write a statement that positions the 
sprite’s upper-left corner at the coordinates 100, 50.  
 
5.   Assume  SPRITE_INDEX is a valid sprite index. Write code that displays the sprite’s 
 X- and  Y -coordinates in the output window.  
 
6.   Assume  SPRITE_INDEX is a valid sprite index. Write code that displays the sprite’s 
width and height in the output window.  
 
7.   Write code that clears the output window to green.  
 
8.   Assume  SPRITE_INDEX is a valid sprite index. Write code that sets the sprite’s alpha 
value to 50.  
 
9.   Assume  SPRITE_INDEX is a valid sprite index. Write code that applies a red tint to 
the sprite.  
 Programming Exercises 
 
1.   Random Screen Colors 
 
 Write an AGK program that repeatedly clears the screen to a random color as 
long as the program is running. (Generate random numbers for each of the clear 
color’s RGB channels.)  
 
2.   Moving Ball 
 
  In the sample media that you can download from this book’s Web site, you will 
find a ball image. Write an AGK program that makes a sprite from the ball image 
and makes the ball move up and down on the screen, from the bottom of the 
window to the top, and back again.  
 
3.   Fish 
 
  In the sample media that you can download from this book’s Web site, you will find 
a fish image and an undersea background. Write an AGK program that displays the 
undersea background and makes the fish move back and forth across the screen.  
 
4.   School of Fish 
 
  Modify the program that you created for Programming Exercise 3 so it has three 
fish sprites, each moving back and forth across the screen. Use the same image file 
for each fish sprite.  
 
5.   Fish Swimming in Opposite Directions 
 
  Write a program similar to the one that you wrote for Programming Exercise 3, 
except this one should have two fish moving in opposite directions. Use the same 
image file for each fish sprite.  
VideoNote
Solving the 
Moving Ball 
Problem

314 
Chapter 7 
 Using the App Game Kit with C++
 
6.  Growing and Shrinking Ghost 
 
  Write a program that displays the ghost shown earlier in this chapter (available in 
the book’s sample media collection) first at its normal size. Then the ghost should 
then grow to twice its size, and then to four times its size. Next, the ghost should 
shrink back down to twice its size, and then shrink back down to its normal size. 
This pattern of growing and shrinking should repeat as long as the program is 
running.  
 
7.  Random Falling Ball 
 
  In the sample media that you can download from this book’s Web site, you will 
find a ball image. Write a program that displays the ball at a random location 
and then makes the ball move down to the bottom of the screen. When the ball 
reaches the bottom of the screen, it should start these actions over again, appear-
ing at another random location, and then moving to the bottom of the screen.  
 
8.   Two Random Falling Balls 
 
  Modify the program that you wrote for Programming Exercise 7 so it has two 
balls that appear at random locations and fall to the bottom of the screen.  
 
9.   Embarrassed Ghost 
 
  Use the ghost and haunted house images shown in this chapter (available in the 
book’s sample media collection) in a program that makes the ghost appear with 
an increasingly red tint. At first, the ghost should be displayed normally, but as 
the program runs, you should increase the value of the ghost’s red color channel a 
small amount until it has reached its maximum value. Then, you should decrease 
the ghost’s red color channel a small amount until it has reached 0. This pattern 
of becoming more red, and then less red should repeat as long as the program is 
running.  
 
10.  Fading Ghost 
 
  Use the ghost and haunted house images shown in this chapter (available in the 
book’s sample media collection) in a program that makes the ghost fade in and 
out. At first, the ghost should be completely transparent, but as the program runs, 
it should fade in until it is completely opaque. Then, the ghost should start fading 
out until it is completely transparent. This pattern of fading in and out should 
repeat as long as the program is running.  

315
 
  8.1  The Mouse 
 CONCEPT:   The AGK provides functions that you can use to work with the mouse. 
These functions allow you to track the mouse pointer’s location on the 
screen and determine when the user is pressing one or more of the 
mouse buttons. 
 Getting the Mouse Coordinates 
 You can call the  agk::GetRawMouseX and  agk::GetRawMouseY functions to get the cur-
rent coordinates of the mouse pointer. The following code shows an example. Assume 
that  x and  y are  float variables. 
 x = agk::GetRawMouseX(); 
 y = agk::GetRawMouseY();  
 After this code executes,  x will contain the mouse pointer’s  X -coordinate, and  y will 
contain the mouse pointer’s  Y -coordinate. Program 8-1 demonstrates how these func-
tions work. The program uses the  app::Loop function to continually get the mouse 
pointer’s coordinates (lines 32 and 33) and sets the sprite’s position to that location 
(line 37). This is shown in  Figure   8-1 . As the user moves the mouse pointer, the sprite 
moves with it. 
 8.1  The Mouse  
 8.2  Virtual Buttons   
 8.3  Virtual Joysticks   
 8.4  The Keyboard   
 8.5  Animation  
 8.6  Music and Sound   
 8.7  The Bug Zapper Game   
 TOPICS 
8 
 CHAPTER 
 Input, Animation, 
and Sound 
VideoNote
Working with 
the Mouse

316 
Chapter 8 
 Input, Animation, and Sound
 Program 8-1 
 (Sprite Mouse) 
 1 // This program demonstrates how to get 
 2 // the mouse pointer's location. 
 3 
 4 // Includes, namespace and prototypes 
 5 #include "template.h" 
 6 using namespace AGK; 
 7 app App; 
 8 
 9 // Constants 
 10 const int SCREEN_WIDTH      = 640; 
 11 const int SCREEN_HEIGHT     = 480; 
 12 const int SPRITE_INDEX      = 1; 
 13 
 14 // Variables to hold the mouse pointer's 
 15 // X- and Y-coordinates. 
 16 float g_mouseX, g_mouseY; 
 17 
 18 // Begin app, called once at the start 
 19 void app::Begin( void ) 
 20 { 
 21    // Set the virtual resolution, window title, and 
 22    // create the sprite. 
 23    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 24    agk::SetWindowTitle("Sprite Mouse"); 
 25    agk::CreateSprite(SPRITE_INDEX, "mouse.png"); 
 26 } 
 27 
 28 // Main loop, called every frame 
 29 void app::Loop ( void ) 
 30 { 
 31    // Get the mouse pointer's location. 
 32    g_mouseX = agk::GetRawMouseX(); 
 33    g_mouseY = agk::GetRawMouseY(); 
 34 
 35    // Set the sprite's position to the mouse 
 36    // pointer's location. 
 37    agk::SetSpritePosition(SPRITE_INDEX, g_mouseX, g_mouseY); 
 38 
 39    // Refresh the screen. 
 40    agk::Sync(); 
 41 } 
 42 
 43 // Called when the app ends 
 44 void app::End ( void ) 
 45 { 
 46 } 

 
8.1 The Mouse 
317
 Showing and Hiding the Mouse 
 By default, the mouse pointer is visible when an AGK program is running. You can 
control the mouse pointer’s visibility, however, with the  agk::SetRawMouseVisible 
function. Here is the general format of how you call the function. 
 agk::SetRawMouseVisible( Visible );  
 The function accepts an integer value as an argument. The value 0 will hide the mouse 
pointer, and the value 1 will show the mouse pointer. When you call the function and 
pass the value 0 as an argument, the mouse pointer becomes invisible within the 
program’s window. (When the user moves the mouse pointer outside the program’s 
window, it becomes visible again.) When the mouse is hidden, it is still active within 
the program’s window. For example, you can still call  agk::GetRawMouseX and 
 agk::GetRawMouseY to get its position. To make the mouse pointer visible again, you 
call the  agk::SetRawMouseVisible function and pass the value 1 as an argument.  
 Detecting Mouse Input 
 The AGK provides several functions to determine if a mouse button has been pressed, 
released, or held down. 
 The  agk::GetRawMouseLeftPressed and  agk::GetRawMouseLeftPressed functions can be 
used to determine when the user presses the left or right mouse button. The functions 
return a value of 1 when the mouse button is pressed; otherwise, they return a value of 0. 
 Program 8-2 demonstrates the  GetRawMouseLeftPressed and  GetRawMouseRightPressed 
functions. The program draws a mouse sprite when the left mouse button is pressed, 
and if the right mouse button is pressed it draws a cat sprite.  
 Figure 8-1  Example output of Program 8-1  

318 
Chapter 8 
 Input, Animation, and Sound
 Program 8-2 
  (Mouse Presses) 
 1 // This program demonstrates pressing 
 2 // the left or right mouse buttons. 
 3  
 4 // Includes, namespace and prototypes 
 5 #include "template.h" 
 6 using namespace AGK; 
 7 app App; 
 8  
 9 // Begin app, called once at the start 
 10 void app::Begin( void ) 
 11 { 
 12    // Set the window title and the virtual resolution. 
 13    agk::SetWindowTitle("Mouse Presses"); 
 14    agk::SetVirtualResolution(agk::GetDeviceWidth(), 
 15                              agk::GetDeviceHeight()); 
 16 } 
 17  
 18 // Main loop, called every frame 
 19 void app::Loop ( void ) 
 20 { 
 21    // Determine if the left mouse button was pressed. 
 22    if(agk::GetRawMouseLeftPressed()) 
 23    { 
 24       // Create a sprite using the "mouse.png" image, and 
 25       // set its position to the current mouse coordinates. 
 26       agk::SetSpritePosition(agk::CreateSprite("mouse.png"), 
 27                              agk::GetRawMouseX(), 
 28                              agk::GetRawMouseY()); 
 29    } 
 30  
 31    // Determine if the right mouse button was pressed. 
 32    if(agk::GetRawMouseRightPressed()) 
 33    { 
 34       // Create a sprite using the "cat.png" image, and 
 35       // set its position to the current mouse coordinates. 
 36       agk::SetSpritePosition(agk::CreateSprite("cat.png"), 
 37                              agk::GetRawMouseX(), 
 38                              agk::GetRawMouseY()); 
 39    } 
 40  
 41    // Refresh the screen. 
 42    agk::Sync(); 
 43 } 
 44  
 45 // Called when the app ends 
 46 void app::End ( void ) 
 47 { 
 48 } 

 
8.1 The Mouse 
319
 The  agk::GetRawMouseLeftReleased and  agk::GetRawMouseRightReleased functions can 
be used to determine when the user releases the left or right mouse button. The functions 
return 1 when the mouse button is released; otherwise, they return a value of 0. 
 The  agk::GetRawMouseLeftState and  agk::GetRawMouseRightState functions can be 
used to determine when the left or right mouse button is being held down. The func-
tions return 1 while the button is held down; otherwise, they return a value of 0.  
 Determining If the Mouse Has Hit a Sprite With the 
agk::GetSpriteHit Function 
 You may want to determine when the user has clicked on a sprite and then perform 
some action in response. Earlier we introduced the functions for detecting mouse in-
put, but how do we know when the mouse pointer is actually overlapping a sprite? 
The following pseudocode shows the logic for checking the position of the mouse 
pointer and the position of the sprite to see if they overlap: 
 Let x equal the X-coordinate of the mouse pointer. 
 Let y equal the Y-coordinate of the mouse pointer. 
 Let x1 equal the upper-left X-coordinate of the sprite. 
 Let y1 equal the upper-left Y-coordinate of the sprite. 
 Let x2 equal the lower-right X-coordinate of the sprite. 
 Let y2 equal the lower-right Y-coordinate of the sprite. 
 If x is greater than or equal to x1 and y is greater than or equal
to y1 and x is less than or equal to x2 and y is less than or equal 
to y2, then the mouse pointer is overlapping the sprite. 
 Figure 8-2  Example output of Program 8-2  

320 
Chapter 8 
 Input, Animation, and Sound
 Fortunately, the AGK provides a function, named  agk::GetSpriteHit that performs 
this logic for you. It determines if a single point has hit a sprite and returns the index 
number of the sprite if it does. Here is the general format of the function: 
 agk::GetSpriteHit( x ,  y ) 
  x  is the  X -coordinate of the point, and   y is the  Y -coordinate of the point. If the 
specified  XY -coordinate is overlapping a sprite, the function will return the index 
number of the sprite; otherwise, the function returns 0. 
 Putting It All Together 
 The  agk::GetRawMouseLeftPressed or  agk::GetRawMouseRightPressed functions can be 
used along with the  agk::GetSpriteHit function to determine if the user has clicked on a 
sprite. Program 8-3 demonstrates using these functions.  Figure   8-4 shows an example of 
the program’s output (this figure is also shown as Figure C-7 in the book’s color insert). 
 Program 8-3 
  (Virtual Light Switch) 
 1 // This program demonstrates a virtual light switch. 
 2  
 3 // Includes, namespace and prototypes 
 4 #include "template.h" 
 Figure 8-3  Single point bounding box collision test  
 Figure  8-3 illustrates the method of determining if a single point is overlapping a 
sprite’s bounding box.  

 
8.1 The Mouse 
321
 5 using namespace AGK; 
 6 app App; 
 7  
 8 // Constants 
 9 const int SCREEN_WIDTH  = 640; 
 10 const int SCREEN_HEIGHT = 480; 
 11  
 12 const int ROOM    = 1; 
 13 const int SWITCH  = 2; 
 14 const int ON      = 1; 
 15 const int OFF     = 2; 
 16  
 17 // Global variable for the light switch state. 
 18 bool g_lightOn = true; 
 19  
 20 // Begin app, called once at the start 
 21 void app::Begin( void ) 
 22 { 
 23    // Set the window title. 
 24    agk::SetWindowTitle("Virtual Light Switch"); 
 25  
 26    // Set the virtual resolution. 
 27    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 28  
 29    // Load the images. 
 30    agk::LoadImage(ON, "light_switch_on.png"); 
 31    agk::LoadImage(OFF, "light_switch_off.png"); 
 32  
 33    // Create the sprites. 
 34    agk::CreateSprite(ROOM, "room.png"); 
 35    agk::CreateSprite(SWITCH, ON); 
 36    agk::SetSpriteScale(SWITCH, 0.15f, 0.15f); 
 37    agk::SetSpritePosition(SWITCH, 50, 50); 
 38 } 
 39  
 40 // Main loop, called every frame 
 41 void app::Loop ( void ) 
 42 { 
 43    // Determine if the left mouse button was pressed. 
 44    if(agk::GetRawMouseLeftPressed()) 
 45    { 
 46       // Get the mouse coordinates. 
 47       float mouseX = agk::GetRawMouseX(); 
 48       float mouseY = agk::GetRawMouseY(); 
 49  
 50       // Determine if the mouse hit the sprite. 
 51       if (agk::GetSpriteHit(mouseX, mouseY) == SWITCH) 
 52       { 
 53          // Determine if the light is already on. 
 54          if(g_lightOn) 
 55          { 
 56             // Turn the light switch off. 
 57             agk::SetSpriteColor(ROOM, 64, 64, 64, 255); 
 58             agk::SetSpriteColor(SWITCH, 64, 64, 64, 255); 
 59             agk::SetSpriteImage(SWITCH, OFF); 

322 
Chapter 8 
 Input, Animation, and Sound
 60  
 61             g_lightOn = false;   // Set the state to false. 
 62          } 
 63          else 
 64          { 
 65             // Turn the light switch on. 
 66             agk::SetSpriteColor(ROOM, 255, 255, 255, 255); 
 67             agk::SetSpriteColor(SWITCH, 255, 255, 255, 255); 
 68             agk::SetSpriteImage(SWITCH, ON); 
 69  
 70             g_lightOn = true; // Set the state to true. 
 71          } 
 72       } 
 73    } 
 74  
 75    // Refresh the screen. 
 76    agk::Sync(); 
 77 } 
 78  
 79 // Called when the app ends 
 80 void app::End ( void ) 
 81 { 
 82 } 
 Figure 8-4  Example output for Program 8-3  
 Checkpoint 
 8.1.  What two functions are used to get the coordinates of the mouse pointer?  
 8.2.  Briefly describe each of the functions for detecting mouse input.  
 8.3.  How can you determine whether or not the mouse pointer is over a sprite?  
 
 8.2  Virtual Buttons 
 CONCEPT:   The AGK allows you to create up to 12 virtual buttons on the screen. 
Virtual buttons can be used to determine when the user clicks on them 
with the mouse.  

 
8.2 Virtual Buttons 
323
 Adding a Virtual Button to the Screen 
 A virtual button is an image of a button that you can display in your AGK program. 
The user may click the button with the mouse. You can have up to 12 virtual buttons 
in an AGK program. To add a virtual button, call the  agk::AddVirtualButton func-
tion. Here is the general format of the function: 
 agk::AddVirtualButton( Index ,  X ,  Y ,  Size );  
 This function accepts four arguments. The first argument,   Index , sets the index num-
ber that will be used to identify the virtual button, the value used for the index should 
be an integer in the range of 1 through 12. The second argument,   X , is a floating-point 
value that sets the  X -coordinate where the button will appear on the screen and is 
based on the center of the virtual button. The third argument,   Y , is a floating-point 
value that sets the  Y -coordinate where the button will appear on the screen and is 
based on the center of the virtual button. The fourth argument,   Size , is a floating 
point value that sets the diameter of the button.  Figure  8-5 illustrates how the size of 
the virtual button is determined based on diameter.  
 Figure 8-5  The size of a virtual button is based on the diameter of a circle  
 Changing a Virtual Button’s Position on the Screen 
 If at any time you need to change the position of a virtual button, you can do so by 
calling the  agk::SetVirtualButtonPosition function and passing the index number 
of the virtual button and the new  X and  Y values as arguments. For example, the fol-
lowing statement positions a virtual button with an index value of 1 centered at the 
screen coordinates (120, 120): 
 agk::SetVirtualButtonPosition(1, 120, 120);  
 Changing the Size of a Virtual Button 
 If you find you need to change the size of a virtual button you added to the screen ear-
lier, you can call the  agk::SetVirtualButtonSize function passing the index number of 
VideoNote
Working with 
Virtual Buttons

324 
Chapter 8 
 Input, Animation, and Sound
the button and a floating-point value containing the new size as arguments. For exam-
ple, the following statement changes the size of a virtual button with index number 1 
to a diameter of 50. 
 agk::SetVirtualButtonSize(1, 50);  
 Displaying Text on a Virtual Button 
 It is possible to display text on top of a virtual button. Displaying text on a virtual 
button can help the user determine what the button will do. If you want to display 
text on a virtual button, call the  agk::SetVirtualButtonText function passing the 
index number of the button and a string containing the text you want to display as 
arguments. For example, the following statement causes the text “OK” to be displayed 
on a virtual button with an index number of 1. 
 Agk::SetVirtualButtonText(1, "OK");  
 Changing the Color of a Virtual Button 
 Occasionally you might want to add a little variety to the virtual buttons in an ap-
plication. One way you can do this is by changing their color. To change the color of 
a virtual button you have added to the screen, call the  agk::SetVirtualButtonColor 
function. Here is the general format of how you call the function. 
 agk::SetVirtualButtonColor( Index ,  Red ,  Green ,  Blue );  
 The first argument is the index number of the virtual button whose color you want 
to change. The remaining arguments are for the red, green, and blue color channels. 
You pass a value from 0 to 255 for each of these arguments. The 0 means that the 
color channel will have no intensity, and 255 means that the color channel will be 
displayed at full intensity. For example, the following statement changes the color of 
a button with the index number 1 to the color yellow. 
 agk::SetVirtualButtonColor(1, 255, 255, 0);  
 Changing the Transparency of a Virtual Button 
 A virtual button can be displayed with varying alpha transparency values. This 
might be a good idea when you want your button to become transparent when not 
in use and then become completely opaque when the mouse cursor rolls over it. You 
can change the alpha value of a virtual button by calling the  agk::SetVirtualButtonAlpha 
function. Here is the general format of how you call the function. 
 agk::SetVirtualButtonAlpha( Index ,  Alpha ); 
 The first argument is the index number of the virtual button whose alpha value you 
want to change. The second argument is an integer ranging from 0, which is com-
pletely transparent to 255 and will cause the button to be completely solid or opaque. 
The following statement sets the alpha value of virtual button 1 to 255. 
 agk::SetVirtualButtonAlpha(1, 255);  

 
8.2 Virtual Buttons 
325
 Showing and Hiding a Virtual Button 
 In some instances, you might want to hide the virtual buttons in an application until 
they are needed. If you want to hide a virtual button or show a previously hidden 
virtual button, you can call the  agk::SetVirtualButtonVisible function. Here is the 
general format of how you call the function: 
 agk::SetVirtualButtonVisible( Index ,  Visible );  
 The first argument is the index number of the virtual button whose visibility you want 
to set. The second argument sets the visibility. Passing a value of 0 (false) will hide the 
virtual button, and passing a value of 1 (true) will show the virtual button. The fol-
lowing example hides a virtual button with an index number of 1. 
 agk::SetVirtualButtonVisible(1, 0);  
 Enabling or Disabling a Virtual Button 
 In some situations you may or may not want a button to be active in an application. 
For instance, if the purpose of a virtual button is to load a previously saved game, then 
the button should only be active if the game data exists. Or if you have a virtual but-
ton that throws a dart in a game, when the player runs out of darts, the button should 
be disabled. Maybe your game has a virtual button that should become active when 
the player has collected enough items, and so forth. You can make a virtual button 
active or inactive by calling the  agk::SetVirtualButtonActive function. Here is the 
general format of how you call the function: 
 agk::SetVirtualButtonActive( Index ,  Active ); 
 The first argument is the index number of the virtual button you want to set. The 
second argument sets the button as either active or inactive. A value of 0 (false) will 
disable the button making it inactive, whereas a value of 1 (true) will cause the button 
to become active. The following statement disables a virtual button with an index 
number of 1. 
 agk::SetVirtualButtonActive(1, 0);  
 Changing a Virtual Button’s Images 
 A virtual button uses two images: one image for when the button is up and another 
image for when the button is down. The AGK provides a set of default images for a 
virtual button (which are stored in your  My Documents >  AGK >  template folder), 
but you can change these images to anything that suits your needs or matches the 
theme of your game. 
 To set the images for a virtual button, you must first load the images you want to use. 
Next, set the image for when the button is up with the  agk::SetVirtualButtonUp func-
tion. You set the image for when the button is down with the  agk::SetVirtualButtonDown 
function. Both functions accept two arguments: The first argument is the index 
number of the virtual button you want to change, and the second argument is the 

326 
Chapter 8 
 Input, Animation, and Sound
index number of the image you want to use. For example, look at the following 
statements: 
 1 agk::LoadImage(1, "myButtonUp.png"); 
 2 agk::LoadImage(2, "myButtonDown.png"); 
 3 
 4 agk::SetVirtualButtonImageUp(1, 1); 
 5 agk::SetVirtualButtonImageDown(1, 2);  
 The first two statements (in lines 1 and 2) load the images, and the last two statements 
(lines 4 and 5) set the virtual button to use those images. Notice that index numbers 
are used to identify the virtual button and to set the image. 
 As you have learned, the AGK provides many ways to customize how virtual buttons 
look and behave. This kind of customization is great for developing unique games 
and applications. Next we will take a look at a program that responds to virtual 
button presses.  
 Responding to the Virtual Button Presses 
 Responding to the virtual button presses is very similar to how we responded to 
mouse button presses earlier in the chapter. Just like the mouse, three different func-
tions are used for determining when the user has pressed a virtual button. The  
 agk::GetVirtualButtonPressed function returns 1 (true) when the user initially 
presses the button, then it returns 0 (false). The  agk::GetVirtualButtonState re-
turns 1 (true) as long as the button is held down, and otherwise it returns 0 (false). 
The  agk::GetVirtualButtonReleased function returns 1 (true) as soon as the button 
is released, then it returns 0 (false). All three functions accept a single argument: the 
index number of the virtual button you want to check. In the following statements, 
each type of function is called, and the return value is stored in a variable. These 
variables could be used later in a program, along with an  if statement to perform 
an action. 
 int pressed = agk::GetVirtualButtonPressed(1); 
 int down = agk::GetVirtualButtonState(1); 
 int released = agk::GetVirtualButtonReleased(1);  
 Program 8-4 demonstrates how to add virtual buttons to an application and how to 
respond when a virtual button is pressed. Figure 8-6 shows the program’s output.  
 Program 8-4 
 (Virtual Buttons) 
 1 // This program demonstrates virtual buttons. 
 2  
 3 // Includes, namespace and prototypes 
 4 #include "template.h" 
 5 using namespace AGK; 
 6 app App; 
 7  
 8 // Constants 

 
8.2 Virtual Buttons 
327
 9 const int SCREEN_WIDTH      = 640; 
 10 const int SCREEN_HEIGHT     = 480; 
 11 const int SPRITE_INDEX      = 1; 
 12 const int SHOW_BUTTON_INDEX = 1; 
 13 const int HIDE_BUTTON_INDEX = 2; 
 14 const float BUTTON_SIZE     = 100.0; 
 15  
 16 // Begin app, called once at the start 
 17 void app::Begin( void ) 
 18 { 
 19    // Set the window title. 
 20    agk::SetWindowTitle("Virtual Buttons"); 
 21  
 22    // Set the virtual resolution. 
 23    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 24  
 25    // Create the sprite. 
 26    agk::CreateSprite(SPRITE_INDEX, "frog.png"); 
 27  
 28    // Calculate the position of the sprite. 
 29    float spriteWidth = agk::GetSpriteWidth(SPRITE_INDEX); 
 30    float spriteX = SCREEN_WIDTH / 2 - spriteWidth / 2; 
 31    float spriteY = 0.0; 
 32  
 33    // Set the position of the sprite. 
 34    agk::SetSpritePosition(SPRITE_INDEX, spriteX, spriteY); 
 35  
 36    // Calculate the position of the virtual "show" button. 
 37    float showButtonX = SCREEN_WIDTH / 2 - BUTTON_SIZE; 
 38    float showButtonY = SCREEN_HEIGHT - BUTTON_SIZE; 
 39  
 40    // Calculate the position of the virtual "hide" button. 
 41    float hideButtonX = SCREEN_WIDTH / 2 + BUTTON_SIZE; 
 42    float hideButtonY = SCREEN_HEIGHT - BUTTON_SIZE; 
 43  
 44    // Add the virtual buttons. 
 45    agk::AddVirtualButton(SHOW_BUTTON_INDEX, showButtonX, 
 46                          showButtonY, BUTTON_SIZE); 
 47    agk::AddVirtualButton(HIDE_BUTTON_INDEX, hideButtonX, 
 48                          hideButtonY, BUTTON_SIZE); 
 49  
 50    // Set the text of the virtual buttons. 
 51    agk::SetVirtualButtonText(SHOW_BUTTON_INDEX, "Show"); 
 52    agk::SetVirtualButtonText(HIDE_BUTTON_INDEX, "Hide"); 
 53 } 
 54  
 55 // Main loop, called every frame 
 56 void app::Loop ( void ) 
 57 { 
 58    // Determine if the virtual "show" button was pressed. 
 59    if(agk::GetVirtualButtonPressed(SHOW_BUTTON_INDEX)) 
 60    { 
 61       // Show the sprite. 
 62       agk::SetSpriteVisible(SPRITE_INDEX, 1); 
 63    } 

328 
Chapter 8 
 Input, Animation, and Sound
 64     
 65    // Determine if the virtual "hide" button was pressed. 
 66    if(agk::GetVirtualButtonPressed(HIDE_BUTTON_INDEX)) 
 67    { 
 68       // Hide the sprite. 
 69       agk::SetSpriteVisible(SPRITE_INDEX, 0); 
 70    } 
 71  
 72    // Refresh the screen. 
 73    agk::Sync(); 
 74 } 
 75  
 76 // Called when the app ends 
 77 void app::End ( void ) 
 78 { 
 79 } 
 Figure 8-6  Example Output of Program 8-4  
 Checkpoint 
 8.4.  How is the size of a virtual button determined? Is it possible to change this 
value?  
 8.5.  Is there a limit to the number of virtual buttons you can create, and if so, what 
is it?  
 8.6.  How can you determine if a virtual button is being held down?  

 
8.3 Virtual Joysticks 
329
 
  8.3  Virtual Joysticks 
 CONCEPT:   The AGK provides up to four virtual joysticks that you can you use to 
control sprites or other items in a game. Virtual joysticks are con-
trolled using the mouse or other pointing device.  
 Adding Virtual Joysticks 
 A  virtual joystick is a simulated joystick that you can display in your program and 
that the user can interact with. You add a virtual joystick to the screen with the 
 agk::AddVirtualJoystick function. Here is the general format of the function: 
 agk::AddVirtualJoystick( Index ,  X ,  Y ,  Size ); 
 The function accepts four arguments. The first argument is the index number 
you want to assign the joystick. It can be a number from 1 to 4. The second and 
third arguments are floating-point values for the  X - and  Y -coordinates for the 
center of the joystick on the screen. The fourth argument,   Size , is a floating-
point value that sets the diameter of the joystick.  Figure  8-7  illustrates how the 
size of the virtual joystick is determined based on diameter, which is similar to a 
virtual button.  
 Figure 8-7  The size of a virtual joystick is based on the diameter of a circle  
 The following code adds a virtual joystick with an index number of 1 to the top-left 
corner of the screen using a size of 50: 
 agk::AddVirtualJoystick(1, 50, 50, 50);  
 Setting the Position of a Virtual Joystick 
 If you ever want to move the virtual joystick after it has been added to the screen, you 
can do so with the  agk::SetVirtualJoystickPosition function. Here is the format of 
how you call the function: 
 agk::SetVirtualJoystickPosition (Index, X, Y) 
VideoNote
Working with 
Virtual Joysticks

330 
Chapter 8 
 Input, Animation, and Sound
 The function takes three arguments; first is an integer value containing the index 
number for the virtual joystick whose position you want to change. The second and 
third arguments are floating-point values for the  X - and  Y -coordinates of the new 
location. The following statement positions a virtual joystick with an index number 
of 1 to be centered at the screen position (100, 100): 
 agk::SetVirtualJoystickPosition(1, 100, 100);  
 Setting the Size of a Virtual Joystick 
 There may be times when you want to resize a virtual joystick after it has been added 
to the screen. You can change the size of a virtual joystick you have previously created 
by calling the  agk::SetVirtualJoystickSize function. Here is the general format of 
the function: 
 agk::SetVirtualJoystickSize( Index ,  Size ); 
 The function accepts two arguments. The first argument is an integer containing the 
index number of the virtual joystick whose size you want to change, and the second 
argument is a floating-point value containing the new size of the virtual joystick. For 
example, the following statement sets the size of a virtual joystick with an index num-
ber of 1 to 200: 
 agk::SetVirtualJoystickSize(1, 200);  
 Setting Transparency of a Virtual Joystick 
 You can change the alpha transparency of a virtual joystick that you have added to 
your program by calling the  agk::SetVirtualJoystickAlpha function. Here is the 
general format of how you call the function: 
 agk::SetVirtualJoystickAlpha( Index ,  Alpha1 ,  Alpha2 );  
 The function accepts three arguments. The first argument is an integer value con-
taining the index number of the virtual joystick whose transparency you want to 
change. The second argument,   Alpha1 , is an integer value that should be between 
0 and 255 for the alpha value of the outer part of the joystick. The third argument, 
 Alpha2 , is an integer value that should be between 0 and 25 for the alpha value of 
the inner part of the joystick. The following statement changes the transparency 
of a virtual joystick with an index number of 1 so that the outer part of the joy-
stick is completely transparent, whereas the inner part of the virtual joystick is 
completely opaque. 
 agk::SetVirtualJoystickAlpha(1, 0, 255);  
 Setting a Virtual Joystick as Active or Inactive 
 You can disable a virtual joystick so that it no longer responds to input by the mouse 
pointer or enable it again by calling the  agk::SetVirtualJoystickActive function. 
Here is the general format of the function: 
 agk::SetVirtualJoystickActive( Index, Active );  

 
8.3 Virtual Joysticks 
331
 The function accepts two arguments. The first argument is an integer containing 
the index number of the virtual joystick that you want to enable or disable. The 
second argument is an integer value that will enable or disable the virtual joystick’s 
ability to receive input. A value of 1 (true) enables the joystick to receive input, 
whereas a value of 0 (false) will disable the joystick and prevent it from receiving 
input. The following statement sets a virtual joystick with an index value of 1 to 
be inactive. 
 agk::SetVirtualJoystickActive(1, 0);  
 Setting the Visibility of a Virtual Joystick 
 There may be times when you want to hide a virtual joystick in your program and 
then show it again. You can do this by calling the  agk::SetVirtualJoystickVisible 
function. Keep in mind that even though a virtual joystick may be hidden, it can still 
accept input, so it might be a good idea to make a joystick inactive before it is hidden 
and then enable it again when it is shown. Here is the general format of how you call 
the function: 
 agk::SetVirtualJoystickVisible( Index ,  Visible );  
 The function accepts two arguments. The first argument is an integer containing the 
index number for the virtual joystick whose visibility you want to set. The second 
argument is an integer value of either 0 or 1. A value of 0 (false) will hide the virtual 
joystick and a value of 1 (true) will show the virtual joystick. The following code seg-
ment disables and then hides a virtual joystick with an index number of 1. 
 agk::SetVirtualJoystickActive(1, 0); 
 agk::SetVirtualJoystickVisible(1, 0);  
 Changing a Virtual Joystick’s Images 
 Like a virtual button, a virtual joystick uses two images: One image for the outer 
part of the joystick and another image for the inner part of the joystick. The AGK 
provides a set of default images for a virtual joystick, but you can easily change 
the images. 
 To set the inner and outer images used by a virtual joystick, you must first load 
the images you want to use with the  agk::LoadImage function. You set the image for 
the outer part of the virtual joystick with the  agk::SetVirtualJoystickImageOuter 
function. You set the image for the inner part of the joystick with the 
 agk::SetVirtualJoystickImageInner function. Both functions accept two arguments: 
the first argument is the index number of the virtual button you want to change, and 
the second argument is the index number of the image you want to use. For example, 
look at the following statements: 
 1 agk::LoadImage(1, "myOuterJoystickImage.png"); 
 2 agk::LoadImage(2, "myInnerJoystickImage.png"); 
 3 
 4 agk::SetVirtualJoystickImageOuter(1, 1); 
 5 agk::SetVirtualJoystickImageInner(1, 2);  

332 
Chapter 8 
 Input, Animation, and Sound
 The first two statements (in lines 1 and 2) load the images, and the last two statements 
(lines 4 and 5) set the virtual joystick to use image 1 for the outer image and image 2 
for the inner image. If, for any reason, you want to return the joystick to its default 
images, you can call the functions and pass 0 as the index number. The following 
statements return the virtual joystick whose images were changed earlier to use the 
default images. 
 agk::SetVirtualJoystickImageOuter(0, 1); 
 agk::SetVirtualJoystickImageInner(0, 2);  
 Notice in the preceding statements that we still must specify the index numbers for 
the inner and outer joystick images.  
 Determining If a Virtual Joystick Exists 
 You can call the  agk::GetVirtualJoystickExists function to determine whether a 
virtual joystick exists. When you call the function, you pass the index number, in the 
range of 1 through 4, of the virtual joystick you want to check. The function returns 
a value of 1 (true) if a virtual joystick exists with the specified index number, and it 
returns 0 (false) otherwise. For example, the following statement determines if a vir-
tual joystick with an index number of 1 exists. It calls the function passing a value of 
1 for the argument and then assigns the return value of the function to an integer 
variable named  virtualJoystickExists : 
 int virtualJoystickExists = agk::GetVirtualJoystickExists(1);  
 Deleting an Existing Virtual Joystick 
 You can delete a virtual joystick and remove it from the screen by calling the 
 agk::DeleteVirtualJoystick function passing the index number of the virtual joy-
stick you want to delete as an argument. It is a good idea to check if the joystick exists 
and then delete it. The following code segment determines if a virtual joystick with an 
index number of 2 exists and then, if it does, deletes it: 
 if(agk::GetVirtualJoystickExists(2)) 
 { 
   agk::DeleteVirtualJoystick(2); 
 } 
 Setting the Virtual Joystick Dead Zone 
 You can customize the sensitivity of all virtual joysticks that you might add to 
the screen by calling the  agk::SetVirtualJoystickDeadZone function. The  dead 
zone is an area around the virtual joystick’s center that affects how far you have 
to move the joystick before it registers input. You can totally disable a virtual 
joystick by setting the dead zone value to 1 or allow the joystick to be extremely 
sensitive by setting the dead zone to 0. The default setting for all virtual joysticks 

 
8.3 Virtual Joysticks 
333
is 0.15. The following statement sets the dead zone for all virtual joysticks to a 
value of 0.05: 
 agk::SetVirtualJoystickDeadZone(0.05);  
 Getting Virtual Joystick Input 
 You can get the input of a virtual joystick along the  X- and  Y -axes with 
the 
 agk::GetVirtualJoystickX 
and 
 agkGetVirtualJoystickY 
functions. The 
 agk::GetVirtualJoystickX function returns input along the  X -axis. It will return 
a floating-point value of −1.0 if the joystick is moved to the far left, and it will 
return a floating-point value of 1.0 if the joystick is moved to the far right. If the 
joystick is not receiving input (or input is within the dead zone), the function re-
turns a value of 0. The same is true for the  agk::GetVirtualJoystickY function, 
except this function returns input along the  Y -axis. The function will return a 
floating-point value of −1.0 if the joystick is moved all the way up and 1.0 if the 
joystick is moved all the way down. The function returns a value of 0 if the joy-
stick is within the dead zone or is not receiving input. You call each of these func-
tions, passing the index number of the virtual joystick whose input you want to 
receive as an argument. The following code segment stores the input of a joystick 
with an index number of 1 in two floating-point variables named  joystickX and 
 joystickY : 
 float joystickX = agk::GetVirtualJoystickX(1); 
 float joystickY = agk::GetVirtualJoystickY(1);  
 Program 8-5 demonstrates how to use a virtual joystick to move a sprite around 
the screen. 
 Program 8-5 
 (Virtual Joystick) 
 1 // This program demonstrates a virtual joystick. 
 2  
 3 // Includes, namespace and prototypes 
 4 #include "template.h" 
 5 using namespace AGK; 
 6 app App; 
 7  
 8 // Constants 
 9 const int SCREEN_WIDTH  = 640; 
 10 const int SCREEN_HEIGHT = 480; 
 11 const int SPRITE_INDEX  = 1; 
 12 const int JOY_INDEX     = 1; 
 13 const float JOY_SIZE    = 100.0; 
 14  
 15 // Begin app, called once at the start 
 16 void app::Begin( void ) 
 17 { 
 18    // Set the window title. 
 19    agk::SetWindowTitle("Virtual Joystick"); 

334 
Chapter 8 
 Input, Animation, and Sound
 20  
 21    // Set the virtual resolution. 
 22    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 23  
 24    // Create the sprite. 
 25    agk::CreateSprite(SPRITE_INDEX, "fish.png"); 
 26  
 27    // Calculate the position of the virtual joystick. 
 28    float joyX = SCREEN_WIDTH / 2; 
 29    float joyY = SCREEN_HEIGHT - JOY_SIZE / 2; 
 30  
 31    // Add the virtual joystick. 
 32    agk::AddVirtualJoystick(JOY_INDEX, joyX, joyY, JOY_SIZE); 
 33 } 
 34  
 35 // Main loop, called every frame 
 36 void app::Loop ( void ) 
 37 { 
 38    // Get the joystick input. 
 39    float joystickX = agk::GetVirtualJoystickX(JOY_INDEX); 
 40    float joystickY = agk::GetVirtualJoystickY(JOY_INDEX); 
 41  
 42    // Get the sprite position. 
 43    float spriteX = agk::GetSpriteX(SPRITE_INDEX); 
 44    float spriteY = agk::GetSpriteY(SPRITE_INDEX); 
 45  
 46    // Calculate how far the sprite will move. 
 47    float moveX = spriteX + joystickX; 
 48    float moveY = spriteY + joystickY; 
 49  
 50    // Set the sprite position. 
 51    agk::SetSpritePosition(SPRITE_INDEX, moveX, moveY); 
 52  
 53    // Refresh the screen. 
 54    agk::Sync(); 
 55 } 
 56  
 57 // Called when the app ends 
 58 void app::End ( void ) 
 59 { 
 60 } 
 The program starts by storing the sprite and virtual joystick index numbers, the 
screen size, and the size of the virtual joystick in named constants in lines 9 
through 13. 
 First, we set up our virtual joystick and sprite in the  app::Begin function in lines 16 
through 33. Lines 28 and 29 set the position of the virtual joystick to be centered 
horizontally and to appear at the bottom of the screen. This is done by setting the  X 
value of the joystick to the center of the screen, which we store in the variable  joyX . 
We calculate the  Y value of the joystick to the height of the screen minus half the 
size of the joystick. Keep in mind when you position a virtual joystick or a virtual 

 
8.3 Virtual Joysticks 
335
button that the  X and  Y values are located in the center and not the upper-left cor-
ner, as is the default for sprites. 
 In line 32 we add the virtual joystick to the screen by supplying the index number, 
 JOY_INDEX , the calculated  X and  Y values,  joyX and  joyY , and the size of the joystick, 
 JOY_SIZE , to the  agk::AddVirtualJoystick function. 
 Now that our virtual joystick has been added to the screen and our sprite has been 
created, we can enter the game loop, which is defined in the  app::Loop function in 
lines 36 through 55. 
 To make our sprite move, one of the things we need to know is how far the sprite 
needs to be moved. The distance that the sprite will move along the  X- and  Y -axes 
needs to be stored once each frame by getting the virtual joystick input. In lines 39 
and 40 we declare two floating-point variables named  joystickX and  joystickY . 
These variables are assigned the return values of the  agk::GetVirtualJoystickX and 
 agk::GetJoystickY functions. The purpose of these variables is to store the input of 
the joystick when it is moved left or right along the  X -axis and up or down along the 
 Y -axis. We will use these values later in the program to move the sprite to a new 
location on the screen. 
 The next thing we need to know is the location of the sprite. We need to store the  X 
and  Y values of the sprite so that we can calculate its new position using the values 
we stored earlier for the virtual joystick input. In lines 43 and 44, we store the  X and 
 Y values of the sprite, as they are in the current frame. The location of the sprite along 
the  X -axis is stored in the floating-point variable  spriteX , and the location of the 
sprite along the  Y -axis is stored in the floating-point variable  spriteY . These values 
will be used together with the joystick input stored in the  joystickX and  joystickY 
variables to move the sprite. 
 Now that we have the current location of the sprite and the distance we want to 
move, we can calculate the new position of the sprite. In lines 47 and 48 we declare 
two floating-point variables,  moveX and  moveY . The value of the  moveX  variable is 
calculated by adding the value of the  joystickX variable to the  spriteX variable, and 
the value of the  moveY variable is calculated by adding the value of the  joystickY 
variable to the  spriteY variable. Remember that the  joystickX and  joystickY vari-
ables are assigned values based on the joystick input, which can range anywhere 
from −1.0 to 1.0, so if the joystick is moved left or up, the  joystickX or  joystickY 
variables will contain a negative value. Adding a negative value to the sprite’s current 
location along the  X- or  Y -axes will cause it to move left or up. On the other hand, 
if the joystick is moved right or down, the  joystickX or  joystickY  variables will 
contain a positive value, and the sprite’s location along the  X- or  Y -axis will increase 
moving it right or down. This is because the values we add to the sprite’s current 
position will be positive. 
 The last thing to do before we update the screen is to actually move the sprite to a 
new location. We do this in line 51 by calling the  agk::SetSpritePosition function 
and passing it the  moveX and  moveY values that we calculated earlier by adding the 
joystick input to the sprite’s current position. When the screen is updated, the sprite 
will appear to move to the new position.  Figure   8-8 shows example output from 
Program 8-5.  

336 
Chapter 8 
 Input, Animation, and Sound
 Checkpoint 
 8.7.  How do you control a virtual joystick?  
 8.8.  What does the term  dead zone refer to?  
 8.9.  Is it possible to change the images used by a virtual joystick, and if so, how is 
it done?  
 Figure 8-8  Example output for Program 8-5  
 
 8.4  The Keyboard 
 CONCEPT:   The AGK provides functions that let you know whether certain keys 
are being pressed on the keyboard. Many games and animation pro-
grams allow the user to control objects on the screen with such keys.  
 Games commonly allow the player to use keys on the keyboard to control objects on 
the screen. For example, the up, down, left, and right arrow keys are typically used to 
move objects. Also, other keys such as the spacebar and Enter key are sometimes used 
to perform actions. 
 Moving Objects with the Keyboard Arrow Keys 
 In the previous section we introduced the virtual joystick, and in Program 8-5 we 
demonstrated how to use input from a virtual joystick to move a sprite around the 
screen. That program could easily be modified to use the arrow keys on the keyboard 
as input to move the sprite. Take a look at Program 8-6: 
VideoNote
Working with 
the Keyboard

 
8.4 The Keyboard 
337
 Program 8-6 
 (Direction Keys) 
 1 // This program demonstrates direction keys. 
 2  
 3 // Includes, namespace and prototypes 
 4 #include "template.h" 
 5 using namespace AGK; 
 6 app App; 
 7  
 8 // Constants 
 9 const int SCREEN_WIDTH     = 640; 
 10 const int SCREEN_HEIGHT    = 480; 
 11 const int SPRITE_INDEX     = 1; 
 12  
 13 // Begin app, called once at the start 
 14 void app::Begin( void ) 
 15 { 
 16    // Set the window title. 
 17    agk::SetWindowTitle("Direction Keys"); 
 18  
 19    // Set the virtual resolution. 
 20    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 21  
 22    // Create the sprite. 
 23    agk::CreateSprite(SPRITE_INDEX, "fish.png"); 
 24 } 
 25  
 26 // Main loop, called every frame 
 27 void app::Loop ( void ) 
 28 { 
 29    // Get the direction as input from the keyboard. 
 30    float directionX = agk::GetDirectionX(); 
 31    float directionY = agk::GetDirectionY(); 
 32  
 33    // Get the sprite position. 
 34    float spriteX = agk::GetSpriteX(SPRITE_INDEX); 
 35    float spriteY = agk::GetSpriteY(SPRITE_INDEX); 
 36  
 37    // Calculate how far the sprite will move. 
 38    float moveX = spriteX + directionX; 
 39    float moveY = spriteY + directionY; 
 40  
 41    // Set the sprite position. 
 42    agk::SetSpritePosition(SPRITE_INDEX, moveX, moveY); 
 43  
 44    // Refresh the screen. 
 45    agk::Sync(); 
 46 } 
 47  
 48 // Called when the app ends 
 49 void app::End ( void ) 
 50 { 
 51 }  

338 
Chapter 8 
 Input, Animation, and Sound
 Program 8-6 has the same output as Program 8-5 (except for the virtual joystick). 
 Most of this program remains unchanged except for the removal of the code to create 
the virtual joystick and the way we are getting input in lines 30 and 31. Program 8-6 
uses the  agk::GetDirectionX and  agk::GetDirectionY functions to move the sprite 
along the  X- and  Y -axes. 
 These functions are very similar to how the virtual joystick input functions worked, 
as they return a value ranging from −0.9 to 0.9, depending on the arrow key that is 
pressed. They return a value of 0 when no key is pressed. When the  agk::GetDirectionX 
function is called in line 30, it returns a positive or negative value, depending on 
whether the right or left arrow key is being pressed. Similarly, when the 
 agk::GetDirectionY function is called in line 31, it returns a positive or negative 
value, depending on whether the down arrow key or up arrow key is being pressed. 
As was shown in Program 8-6, these values are then used in a calculation that sets the 
new position of the sprite for each frame, making it appear to move.  
 NOTE:    The  agk::GetDirectionX and  agk::GetDirectionY functions can be used 
to get input from a device that has an accelerometer, but when no accelerometer is 
available, they simulate its behavior and make the task of moving sprites around 
with the arrow keys very easy to accomplish. 
 Responding to Specific Key Presses 
 Responding the specific key presses on the keyboard is very similar to how we re-
sponded to virtual button presses earlier in the chapter. Just like a virtual button, three 
different functions are used for determining when the user has pressed a specific key 
on the keyboard. The  agk::GetRawKeyPressed function returns 1 (true) when the user 
initially presses the specified key, then it returns 0 (false). The  agk::GetRawKeyboardState 
returns 1 (true) as long as the specified key is held down, and otherwise it returns 0 
(false). The  agk::GetRawKeyReleased function returns 1 (true) as soon as the specified 
key is released, then it returns 0 (false). All three functions accept a single argument: 
an integer value in the range of 0 through 255 representing the key code for the spe-
cific key you want to check. 
 Many of the common key codes are defined by the AGK.  Table   8-1 lists a few of them.  
 Table 8-1   Key codes defined by the AGK 
Name
Key
AGK_KEY_UP
Up Arrow Key
AGK_KEY_DOWN
Down Arrow Key
AGK_KEY_LEFT
Left Arrow Key
AGK_KEY_RIGHT
Right Arrow Key
AGK_KEY_SPACE
Spacebar Key
AGK_KEY_TAB
Tab Key
AGK_KEY_ENTER
Enter Key

 
8.4 The Keyboard 
339
 In the following statements, each type of function is called with the  AGK_KEY_TAB value 
passed as an argument, and the return value is stored in a variable. These variables 
could be used later in a program, along with an  if statement to perform an action 
when the user presses the Tab key on the keyboard. 
 int tabPressed = agk::GetRawKeyPressed(AGK_KEY_TAB); 
 int tabDown = agk::GetRawKeyboardState(AGK_KEY_TAB); 
 int tabReleased = agk::GetRawKeyReleased(AGK_KEY_TAB);  
 Determining the Last Key That Was Pressed 
 You can determine the last key that was pressed by calling the  agk::GetRawLastKey 
function. The function returns the key code for the last key that was pressed. You can 
compare this value to one of the defined key codes provided by the AGK as a way to 
detect input for specific keys. Program 8-7 demonstrates this idea. 
 Program 8-7 
 (Last Key Pressed) 
 1 // This program demonstrates detecting the 
 2 // last key that was pressed on the keyboard. 
 3  
 4 // Includes, namespace and prototypes 
 5 #include "template.h" 
 6 using namespace AGK; 
 7 app App; 
 8  
 9 // Constants 
 10 const int SCREEN_WIDTH     = 640; 
 11 const int SCREEN_HEIGHT    = 480; 
 12  
 13 // Begin app, called once at the start 
 14 void app::Begin( void ) 
 15 { 
 16    // Set the window title. 
 17    agk::SetWindowTitle("Last Key Pressed"); 
 18  
 19    // Set the virtual resolution. 
 20    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 21 } 
 22  
 23 // Main loop, called every frame 
 24 void app::Loop ( void ) 
 25 { 
 26    // Get the key code of the last key that was pressed. 
 27    int keycode = agk::GetRawLastKey(); 
 28  
 29    // Determine which message to display. 
 30    switch(keycode) 
 31    { 
 32       case AGK_KEY_SPACE: 
 33          agk::Print("You pressed the spacebar."); 
 34          break; 

340 
Chapter 8 
 Input, Animation, and Sound
 35  
 36       case AGK_KEY_ENTER: 
 37          agk::Print("You pressed the enter key."); 
 38          break; 
 39  
 40       default: 
 41          agk::Print("Press the spacebar or enter key."); 
 42          break; 
 43    } 
 44  
 45    // Refresh the screen. 
 46    agk::Sync(); 
 47 } 
 48  
 49 // Called when the app ends 
 50 void app::End ( void ) 
 51 { 
 52 } 
 In line 27 we declare an integer variable named  keycode and use it to store the value 
returned by the  agk::GetRawLastKey function. 
 In lines 30 through 43 we have a  switch statement that displays a message to the user 
based on the last key that was pressed. If the spacebar or enter keys are pressed, a mes-
sage is displayed to the user indicating that those keys were pressed. If any other key is 
pressed, a message is displayed for the user to press either the spacebar or the enter key. 
 Checkpoint 
 8.10.   Briefly describe the method used to move a sprite with the arrow keys.  
 8.11.   Is it possible to determine when a specific key on the keyboard is pressed, and 
if so how do you determine its value?  
 8.12.   What function could you use to keep track of the keys pressed during a game?  
 
8.5  Animation 
 CONCEPT:   You can create a simple animation by displaying a sequence of images 
one after the other. This can be done by manually loading and display-
ing separate images or via a texture atlas, which contains all the ani-
mation frames in a single image.  
 Perhaps you’ve seen simple animations created with flip books. The first page in a flip 
book shows an image. The next page shows a nearly identical image, but with a slight 
change. Following this pattern, each page in the book is slightly different from the 
previous page. When you flip rapidly through the pages, the illusion of movement is 
created. This type of animation is often called  cel animation . The term  cel is an ab-
breviation of the world  celluloid , which was the material onto which animators once 
painted the individual images of cartoons. 

 
8.5 Animation 
341
 You can create simple cel animations by displaying a sequence of images, one after the 
other, in the same location on the screen. If the images are similar except for slight 
changes and are displayed in the correct order, the illusion of movement can be created. 
 For example, look at the sequence of eight images shown in  Figure   8-9 . Each image 
shows a cartoon person in a different position. When the images are viewed one after 
the other, the person appears to be walking.  
 Figure 8-9  Cel animation images  
 The eight images shown in  Figure  8-9 are named  WalkingMan1.png ,  WalkingMan2.png , 
and so forth. Each image is considered a frame in the animation sequence. Program 8-8 
loads these images and then displays them one after the other. After the last image is 
displayed, the program starts over with the first image. 
 Program 8-8 
  (CelAnimation) 
 1 // This program demonstrates cel animation. 
 2  
 3 // Includes, namespace and prototypes 
 4 #include "template.h" 
 5 using namespace AGK; 
 6 app App; 
 7  
 8 // Constants 

342 
Chapter 8 
 Input, Animation, and Sound
 9 const int SCREEN_WIDTH  = 640; 
 10 const int SCREEN_HEIGHT = 480; 
 11 const int FIRST_IMAGE   = 1; 
 12 const int LAST_IMAGE    = 8; 
 13 const int SPRITE_INDEX  = 1; 
 14 const float FPS         = 8; 
 15 const int MODE          = 0; 
 16  
 17 // Begin app, called once at the start 
 18 void app::Begin( void ) 
 19 { 
 20    // Set the window title. 
 21    agk::SetWindowTitle("Cel Animation"); 
 22  
 23    // Set the virtual resolution. 
 24    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 25  
 26    // Set the frame rate and mode. 
 27    agk::SetSyncRate(FPS, MODE); 
 28  
 29    // Load the walking man images. 
 30    agk::LoadImage(1, "WalkingMan1.png", 1); 
 31    agk::LoadImage(2, "WalkingMan2.png", 1); 
 32    agk::LoadImage(3, "WalkingMan3.png", 1); 
 33    agk::LoadImage(4, "WalkingMan4.png", 1); 
 34    agk::LoadImage(5, "WalkingMan5.png", 1); 
 35    agk::LoadImage(6, "WalkingMan6.png", 1); 
 36    agk::LoadImage(7, "WalkingMan7.png", 1); 
 37    agk::LoadImage(8, "WalkingMan8.png", 1); 
 38  
 39    // Create the sprite using the first frame of animation. 
 40    agk::CreateSprite(SPRITE_INDEX, FIRST_IMAGE); 
 41  
 42    // Calculate the sprite's position. 
 43    float spriteWidth = agk::GetSpriteWidth(SPRITE_INDEX); 
 44    float spriteHeight = agk::GetSpriteHeight(SPRITE_INDEX); 
 45    float spriteX = SCREEN_WIDTH / 2 - spriteWidth / 2; 
 46    float spriteY = SCREEN_HEIGHT / 2 - spriteHeight / 2; 
 47  
 48    // Set the sprite's position. 
 49    agk::SetSpritePosition(SPRITE_INDEX, spriteX, spriteY); 
 50 } 
 51  
 52 // Main loop, called every frame 
 53 void app::Loop ( void ) 
 54 { 
 55    // Get the sprite's image number. 
 56    int currentImage = agk::GetSpriteImageID(SPRITE_INDEX); 
 57  
 58    // Update the sprite's image number. 
 59    if (currentImage == LAST_IMAGE) 
 60    { 
 61      currentImage = FIRST_IMAGE; 
 62    } 
 63    else 

 
8.5 Animation 
343
 64     { 
 65        currentImage++; 
 66     } 
 67   
 68     // Set the sprite's image number. 
 69     agk::SetSpriteImage(SPRITE_INDEX, currentImage); 
 70   
 71     // Refresh the screen. 
 72     agk::Sync(); 
 73  } 
 74   
 75  // Called when the app ends 
 76  void app::End ( void ) 
 77  { 
 78  }  
 The following global constants are declared in lines 9 through 15: 
 ●  The  SCREEN_WIDTH and  SCREEN_HEIGHT constants are declared in lines 9 and 10 
and initialized with the values 640 and 480. We will use these constants to set 
the virtual resolution of the screen.  
 ●  Lines 11 and 12 declare the  FIRST_IMAGE constant (initialized with 1) and the 
 LAST_IMAGE constant (initialized with 8). These are the image numbers that we 
will use for the first and last images in the animation sequence.  
 ●  The  SPRITE_INDEX constant is declared in line 13 and initialized with the value 
1. This value will be used to reference the sprite that will display the images that 
make up the animation sequence.  
 ●  Lines 14 and 15 declare the  FPS and  MODE constants. The  FPS constant is initial-
ized with the value 8. We will use this constant to set the number of frames per 
second that the  app::Loop function will iterate. We chose 8, a low value, because 
we want the animation to run somewhat slowly. (If we use the default value, the 
cartoon man will appear to be running instead of walking!) The  MODE constant 
is initialized with a value of 0. This is the default value, which will cause the 
game loop to sleep between frames, but a value of 1, which uses a continuous 
loop, could have been used as well. We will use these constants to set the rate 
that the frames of animation will be drawn to the screen and define the behavior 
of the game loop between frames.  
 The  app::Begin function is defined in lines 18 through 50: 
 ●  In line 21 we set the window title to  “Cel Animation” . This is the text that will 
appear in the window’s title bar during execution of the program.  
 ●  In line 24 we set the virtual resolution using the constants  SCREEN_WIDTH and 
 SCREEN_HEIGHT that we initialized earlier in the program.  
 ●  In line 27 we set the frame rate and the game loop mode using the constants  FPS 
and  MODE . 
 ●  In lines 30 through 37 we load each of the eight images that will be used for 
the animation sequence. These statements store each image in memory so 
that we can retrieve any of the images at a later time by using its image 
number.  

344 
Chapter 8 
 Input, Animation, and Sound
 ●  In line 40 we create the sprite we will use to display the animation on the screen. 
The sprite is created using the  SPRITE_INDEX and  FIRST_IMAGE constants. This 
will create a sprite that will use the first frame of animation as its image, so 
when the program begins, the sprite will display the image for the very first 
frame of animation.  
 ●  In lines 43 through 46 we calculate the position where we would like to display 
the sprite on the screen. The sprite’s width and height are stored in the  spriteWidth 
and  spriteHeight variables in lines 43 and 44. These values are based on the 
width and height of the image that is currently being used by the sprite (which 
is the image for the first frame of animation). In lines 45 and 46 the sprite’s 
width and height are used along with the  SCREEN_WIDTH and  SCREEN_HEIGHT con-
stants to calculate the center of the screen and then center the sprite accordingly.  
 ●  In line 49 we set the sprite’s position. When the program executes, the sprite will 
appear centered on the screen.  
 The  app::Loop function is defined in lines 53 through 73: 
 ●  In line 56 we declare a variable named  currentImage and initialize it with the 
image number of the image that is currently being used by the sprite.  
 ●  An  if statement in lines 59 through 66 determines whether the  currentImage is 
equal to  LAST_IMAGE . If so, we reset  currentImage to  FIRST_IMAGE in line 61.  
 ●  Line 69 sets the sprite’s image to  currentImage . In line 72, we update the 
game loop.  
 The  app::End function in lines 76 through 78 contains no code. 
 Simplifying Animation with Texture Atlases 
 Although Program 8-8 illustrates the fundamental idea behind cel animation, the 
AGK provides a simpler way to achieve the same results. Instead of having separate 
image files for the frames in an animation sequence stored on your disk, you can have 
one image file that contains all the images. Such a file is known as a  texture atlas . 
 Figure  8-10 shows an example of a texture atlas containing all the images for the 
walking man animation we looked at previously.  
 Figure 8-10  A texture atlas  
 The images in a texture atlas are organized in rows and columns. The texture atlas 
shown in  Figure   8-10 has one row and eight columns. When this texture atlas is used 
to create an animation, the images are displayed from left to right. This means the 
image (or frame) in the first column is displayed, then the image (or frame) in the 
second column is displayed, and so forth. 
VideoNote
Working with 
Texture Atlases

 
8.5 Animation 
345
 The AGK can calculate the positions of each image in a texture atlas by using the 
width and height of each frame. For example, the entire texture atlas shown in 
 Figure  8-10  is 1024 pixels wide by 256 pixels high. There are eight columns in 
the texture atlas, so each column is 128 pixels wide. The first 128 by 256 block 
contains the first image, the second 128 by 256 block contains the second image, 
and so forth. 
 Figure   8-11 shows another example of a texture atlas. This one has two rows and four 
columns. Each image in the texture atlas occupies an area that is 240 pixels wide by 
240 pixels high. The entire texture atlas is 960 pixels wide by 480 pixels high.  
 Figure 8-11  A texture atlas with two rows and four columns  
 When a texture atlas containing multiple rows is used to create an animation, the 
images in the first row are displayed from left to right, then the images in the second 
row are displayed from left to right, and so forth. 
 This is consistent with the internal numbering system that the AGK uses to identify 
the images in a texture atlas. The images are numbered, starting at 1, from left to 
right. If the texture atlas contains multiple rows, the numbering continues from one 
row to the next. For example, in the texture atlas shown in  Figure  8-11  , the images in 
the first row would be numbered 1, 2, 3, and 4, and the images in the second row 
would be numbered 5, 6, 7, and 8.  
 Playing Sprite Animations with the AGK 
 To play an animation using the images in a texture atlas, first must you load the image 
containing the texture atlas, create a sprite, and then set up the animation frames that 
will be used by the sprite. To set up the animation, you call the  agk::SetSpriteAnimation 
function. Here is the general format of how you call the function: 
 agk::SetSpriteAnimation( SpriteIndex ,  FrameWidth , 
                      FrameHeight ,  FrameCount );  
  SpriteIndex  is the sprite index number you will use for the animated sprite; 
 FrameWidth is the width, in pixels, of a single frame of animation;   FrameHeight is the 

346 
Chapter 8 
 Input, Animation, and Sound
height, in pixels, of a single frame of animation; and   FrameCount is the total number 
of frames that make up the animation sequence. Here is an example that loads a 
texture atlas, creates a sprite, and then sets up sprite to use the animation sequence 
stored in the texture atlas: 
 1  agk::LoadImage(1, "animation.png"); 
 2  agk::CreateSprite(1, 1); 
 3  agk::SetSpriteAnimation(1, 128, 256, 8);  
 The first statement loads the texture atlas stored in the animation.png file. The second 
statement creates a sprite specifying the texture atlas as its image. The third statement 
sets up the animation for the sprite. It is made up of eight frames of animation, where 
each frame is 128 pixels wide by 256 pixels high. 
 Once a sprite has been set up for animation, it may be played by calling the 
 agk::PlaySprite function. Here is the general format of how you call the function: 
 agk::PlaySprite( SpriteIndex ,  Fps ,  Loop ,  FromFrame ,  ToFrame );  
  SpriteIndex  is the integer index number of the sprite you want to play the anima-
tion for, and it is the only required argument for the function. If you don’t need to 
do a lot of customization for your animation, the calling the function with only the 
sprite index will work fine.   Fps is an optional float argument that sets the frames 
per second of the animation. The value of the   Fps argument applies to the frame 
rate of the animation only and does not change the frame rate of the game loop. 
 Loop is an optional integer argument that sets whether or not the animation will 
loop. If the Loop value is set to 0 (false), the animation to play once and then stop, 
whereas a value of 1 (true) will loop the animation.   FromFrame is an optional integer 
argument that sets the first frame of animation, and   ToFrame is an optional integer 
argument that sets the last frame of animation. 
 To demonstrate, look at Program 8-9. This program loads the clock texture atlas 
shown in  Figure   8-11 and plays the animation. 
 Program 8-9 
  (Clock Texture Atlas) 
 1 // This program demonstrates using a texture atlas 
 2 // to display an animated clock. 
 3  
 4 // Includes, namespace and prototypes 
 5 #include "template.h" 
 6 using namespace AGK; 
 7 app App; 
 8  
 9 // Constants 
 10 const int SCREEN_WIDTH  = 640; 
 11 const int SCREEN_HEIGHT = 480; 
 12 const int IMAGE_INDEX   = 1; 
 13 const int FRAME_WIDTH   = 240; 
 14 const int FRAME_HEIGHT  = 240; 

 
8.5 Animation 
347
 15 const int FRAME_COUNT   = 8; 
 16 const int SPRITE_INDEX  = 1; 
 17 const float SPRITE_X = SCREEN_WIDTH / 2 - FRAME_WIDTH / 2; 
 18 const float SPRITE_Y = SCREEN_HEIGHT / 2 - FRAME_HEIGHT / 2; 
 19  
 20 // Begin app, called once at the start 
 21 void app::Begin( void ) 
 22 { 
 23    // Set the window title. 
 24    agk::SetWindowTitle("Clock Texture Atlas"); 
 25  
 26    // Set the virtual resolution. 
 27    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 28  
 29    // Load the texture atlas. 
 30    agk::LoadImage(IMAGE_INDEX, "ClockTextureAtlas.png"); 
 31  
 32    // Create the sprite using the texture atlas as the image. 
 33    agk::CreateSprite(SPRITE_INDEX, IMAGE_INDEX); 
 34  
 35    // Set the sprite animation. 
 36    agk::SetSpriteAnimation(SPRITE_INDEX, FRAME_WIDTH, 
 37                            FRAME_HEIGHT, FRAME_COUNT); 
 38  
 39    // Set the sprite's position. 
 40    agk::SetSpritePosition(SPRITE_INDEX, SPRITE_X, SPRITE_Y); 
 41  
 42    // Play the clock animation. 
 43    agk::PlaySprite(SPRITE_INDEX); 
 44 } 
 45  
 46 // Main loop, called every frame 
 47 void app::Loop ( void ) 
 48 { 
 49    // Refresh the screen. 
 50    agk::Sync(); 
 51 } 
 52  
 53 // Called when the app ends 
 54 void app::End ( void ) 
 55 { 
 56 } 
 Stopping and Resuming an Animated Sprite 
 You can stop an animated sprite with the  agk::StopSprite function. You can resume 
animation for a sprite with the  agk::ResumeSprite function. Both functions accept a 
sprite index number as their only argument. When animation for a sprite is stopped, 
the frame where the animation was stopped is persevered, and the sprite will begin the 
animation sequence right where it left off when the animation sequence is resumed. 

348 
Chapter 8 
 Input, Animation, and Sound
The following example calls the  agk::StopSprite function to stop a sprite’s animation 
sequence and then calls the  agk::ResumeSprite function to resume the animation. 
 agk::StopSprite(1); 
 agk::ResumeSprite(1);  
 Checkpoint 
 8.13.   What is a texture atlas?  
 8.14.   What AGK function do you call to set up a sprite for animation?  
 8.15.   What AGK function do you call to play a sprite’s animation?  
 
8.6  Music and Sound 
 CONCEPT:   The AGK lets you play audio files that have been saved in the MP3 
and WAV formats. The library provides numerous functions for 
working with these audio files.  
 Sound effects are important in games, as they are often used to signal events like colliding 
objects, selecting items, completing part of a game, and gaining extra power. Background 
music also plays an important role in games. It can create a particular mood, for exam-
ple, by making the game seem silly and whimsical or dark and mysterious. 
 The AGK allows you to play sound from audio files that are stored in the WAV and 
MP3 formats. In the AGK, audio that is saved in the WAV format is classified as sound, 
and audio that is saved in the MP3 format is classified as music. There are two sets of 
functions for loading and playing audio: one for sound files and one for music files. 
 Loading a Sound File 
 Audio files that are saved in the WAV format are considered sound files by the AGK. 
To use a sound file, first you must load it into memory. Then you can play the sound 
file and perform other operations with it.  
 You load a sound file into memory by calling the  agk::LoadSound function. There are 
several versions of this function, but the version we will use accepts two arguments: 
an index number and filename for the sound you want to load. The following shows 
the general format of how you call the function: 
 agk::LoadSound( SoundNumber ,  Filename );  
 The following code shows an example that loads a sound from the file  mySound.wav 
and assigns it an index value of 1: 
 agk::LoadSound(1, "mySound.wav");  
 In this example, we have specified only the filename, without a path. Audio files must 
be placed in the same folder as image files for the program to find them. 
VideoNote
Working with 
Music and Sound

 
8.6 Music and Sound 
349
 Playing a Sound 
 Once you have loaded a sound file into memory, you can play it with the  agk::PlaySound 
function. Here is the general format of how you call the function: 
 agk::PlaySound( SoundNumber ); 
  SoundNumber  is the index number of the sound that you want to play. For example, the 
following statement plays a sound with an index number of 1. 
 agk::PlaySound(1);  
 When you call the  agk::PlaySound function, the specified sound will be played. Program 
8-10 shows a simple example that plays a sound. Program 8-11 shows a more elaborate 
example that lets the user play a guitar, a drum, and a horn by clicking them with the mouse.  
 Program 8-10 
 (Play Sound) 
 1 // This program loads a sound file and plays it. 
 2  
 3 // Includes, namespace and prototypes 
 4 #include "template.h" 
 5 using namespace AGK; 
 6 app App; 
 7  
 8 // Begin app, called once at the start 
 9 void app::Begin( void ) 
 10 { 
 11    // Set the window title. 
 12    agk::SetWindowTitle("Play Sound"); 
 13  
 14    // Set the virtual resolution. 
 15    agk::SetVirtualResolution(640, 480); 
 16  
 17    // Load the sound file sparkle.wav as 
 18    // sound number 1. 
 19    agk::LoadSound(1, "sparkle.wav"); 
 20  
 21    // Play sound number 1. 
 22    agk::PlaySound(1); 
 23 } 
 24  
 25 // Main loop, called every frame 
 26 void app::Loop ( void ) 
 27 { 
 28    // Refresh the screen. 
 29    agk::Sync(); 
 30 } 
 31  
 32 // Called when the app ends 
 33 void app::End ( void ) 
 34 { 
 35 } 

350 
Chapter 8 
 Input, Animation, and Sound
 Program 8-11 
 (Sprite Sounds) 
 1 // This program demonstrates playing sounds 
 2 // when a sprite is clicked by the mouse. 
 3  
 4 // Includes, namespace and prototypes 
 5 #include "template.h" 
 6 using namespace AGK; 
 7 app App; 
 8  
 9 // Constants 
 10 const int SCREEN_WIDTH  = 640; 
 11 const int SCREEN_HEIGHT = 480; 
 12 const int GUITAR_SPRITE = 1; 
 13 const int DRUM_SPRITE   = 2; 
 14 const int HORN_SPRITE   = 3; 
 15 const int GUITAR_SOUND  = 1; 
 16 const int DRUM_SOUND    = 2; 
 17 const int HORN_SOUND    = 3; 
 18  
 19 // Begin app, called once at the start 
 20 void app::Begin( void ) 
 21 { 
 22    // Set the window title. 
 23    agk::SetWindowTitle("Sprite Sounds"); 
 24  
 25    // Set the virtual resolution. 
 26    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 27  
 28    // Load the sounds. 
 29    agk::LoadSound(GUITAR_SOUND, "guitar.wav"); 
 30    agk::LoadSound(DRUM_SOUND, "drum.wav"); 
 31    agk::LoadSound(HORN_SOUND, "horn.wav"); 
 32  
 33    // Create the sprites. 
 34    agk::CreateSprite(GUITAR_SPRITE, "guitar.png"); 
 35    agk::CreateSprite(DRUM_SPRITE, "drum.png"); 
 36    agk::CreateSprite(HORN_SPRITE, "horn.png"); 
 37  
 38    // Position the sprites. 
 39    agk::SetSpritePosition(GUITAR_SPRITE, 0.0, 0.0); 
 40    agk::SetSpritePosition(DRUM_SPRITE, 200.0, 200.0); 
 41    agk::SetSpritePosition(HORN_SPRITE, 300.0, 300.0); 
 42 } 
 43  
 44 // Main loop, called every frame 
 45 void app::Loop ( void ) 
 46 { 
 47    // Get the mouse coordinates. 
 48    float mouseX = agk::GetRawMouseX(); 
 49    float mouseY = agk::GetRawMouseY(); 
 50  
 51    // Determine if the left mouse button was pressed. 
 52    if(agk::GetRawMouseLeftPressed()) 

 
8.6 Music and Sound 
351
 53    { 
 54       // Get the index number of the sprite that the mouse 
 55       // is pointing at. 
 56       int spriteIndex = agk::GetSpriteHit(mouseX, mouseY); 
 57  
 58       // Determine if the sound is already playing. 
 59       if(agk::GetSoundsPlaying(spriteIndex)) 
 60       { 
 61          // Stop the sound. 
 62          agk::StopSound(spriteIndex); 
 63       } 
 64       else 
 65       { 
 66          // Play the sound. 
 67          agk::PlaySound(spriteIndex); 
 68       } 
 69    } 
 70  
 71    // Refresh the screen. 
 72    agk::Sync(); 
 73 } 
 74  
 75 // Called when the app ends 
 76 void app::End ( void ) 
 77 { 
 78 } 
 Figure 8-12  Example output for Program 8-11  

352 
Chapter 8 
 Input, Animation, and Sound
 Music Files 
 Music files are files that are saved in the MP3 format. The AGK provides many of the 
same operations for music files as sound files. Let’s take a closer look at some of the 
things you can do with music files.  
 Loading a Music File 
 Before you can use a music file, you have to load it into memory by calling the 
 agk::LoadMusic function. Here is the general format of how you call the function: 
 agk::LoadMusic( MusicNumber ,  Filename );  
  MusicNumber  is an integer number that you are assigning to the music. This can be an 
integer in the range of 1 through 50. You will use the music number to identify the 
music when you want to play it or perform other operations with it.   Filename is the 
name of the music file that you would like to load into the program’s memory. For 
example, the following statement loads the file myMusic.mp3 as music number 1. 
 agk::LoadMusic(1, "myMusic.mp3");  
 Playing Music 
 Once you have loaded a music file into memory, you can play it with the  agk::PlayMusic 
function. Only one music file may be played at any one time. Here is the general for-
mat of how you call the function: 
 agk::PlayMusic( MusicNumber );  
  MusicNumber  is the number of the music that you want to play. For example, the follow-
ing statement plays music number 1: 
 agk::PlayMusic(1);  
 Program 8-12 demonstrates playing three different music files when the user clicks on 
three different virtual buttons. 
 Program 8-12 
 (Play Music) 
 1 // This program demonstrates playing music 
 2 // when a virtual button is clicked by the mouse. 
 3  
 4 // Includes, namespace and prototypes 
 5 #include "template.h" 
 6 using namespace AGK; 
 7 app App; 
 8  
 9 // Begin app, called once at the start 
 10 void app::Begin( void ) 
 11 { 
 12    // Set the window title. 
 13    agk::SetWindowTitle("Music Player"); 
 14  
 15    // Set the virtual resolution. 
 16    agk::SetVirtualResolution(640, 480); 
 17  

 
8.7 The Bug Zapper Game 
353
 18    // Load the music files. 
 19    agk::LoadMusic(1, "MusicA.mp3"); 
 20    agk::LoadMusic(2, "MusicB.mp3"); 
 21    agk::LoadMusic(3, "MusicC.mp3"); 
 22  
 23    // Add the virtual buttons. 
 24    agk::AddVirtualButton(1, 220, 240, 100); 
 25    agk::AddVirtualButton(2, 320, 240, 100); 
 26    agk::AddVirtualButton(3, 420, 240, 100); 
 27  
 28    // Set the text for the virtual buttons. 
 29    agk::SetVirtualButtonText(1, "1"); 
 30    agk::SetVirtualButtonText(2, "2"); 
 31    agk::SetVirtualButtonText(3, "3"); 
 32 } 
 33  
 34 // Main loop, called every frame 
 35 void app::Loop ( void ) 
 36 { 
 37    // If button 1 was pressed, play music 1. 
 38    if(agk::GetVirtualButtonPressed(1)) 
 39    { 
 40       agk::PlayMusic(1); 
 41    } 
 42  
 43    // If button 2 was pressed, play music 2. 
 44    if(agk::GetVirtualButtonPressed(2)) 
 45    { 
 46       agk::PlayMusic(2); 
 47    } 
 48  
 49    // If button 3 was pressed, play music 3. 
 50    if(agk::GetVirtualButtonPressed(3)) 
 51    { 
 52       agk::PlayMusic(3); 
 53    } 
 54  
 55    // Refresh the screen. 
 56    agk::Sync(); 
 57 } 
 58  
 59 // Called when the app ends 
 60 void app::End ( void ) 
 61 { 
 62 } 
 
8.7  The Bug Zapper Game 
 In this section we will look at a simple game that incorporates many of the topics that 
we have discussed in this chapter. The Bug Zapper game displays an animated sprite of 
a bug. The user zaps the bug by clicking it with the mouse. When this happens, a new 

354 
Chapter 8 
 Input, Animation, and Sound
bug appears at a random location on the screen. The game will run for 10 seconds be-
fore ending. The object of the game is to zap as many bugs as possible within the allot-
ted time. When the game ends, a screen displays the number of bugs that were zapped.  
 In the Spotlight: 
 The Bug Zapper Game 
 Figure  8-13  shows some screens from the game (this is also shown as Figure C-8 in the 
book’s color insert). The intro screen shown in the top-left is displayed when the game 
begins. The user presses a key on the keyboard, and a screen similar to the one in the 
top-right is displayed. The user zaps as many bugs as possible until time runs out. Then 
the bottom screen is displayed, showing the number of bugs that were zapped.  
 Figure 8-13  Screens from the Bug Zapper game  
 To determine when 10 seconds has elapsed, the program will use two AGK functions: 
 agk::ResetTimer and  agk::Timer . The AGK has a timer that measures the number of 
seconds that have elapsed since the program started or since the last time the timer was 
reset. The  agk::ResetTimer function resets the timer. Its general format is shown here: 
 agk::ResetTimer();  
 The  agk::Timer function returns the value of the timer. When you call the  agk::Timer 
function, it returns either the number of seconds since the program started or since the 
last time that the timer was restarted. Its general format is shown here: 
 agk::Timer();  

 
8.7 The Bug Zapper Game 
355
 Program 8-13 shows the code for the game, but rather than showing all the code at 
once, we will show sections of it, with a description following each section. Lines 1 
through 11 are shown first. These lines contain the initial code and a set of function 
prototypes in lines 7 through 11. 
 Program 8-13 
  (BugZapper partial listing) 
  1 // Includes, namespace and prototypes 
  2 #include "template.h" 
  3 using namespace AGK; 
  4 app App; 
  5  
  6 // Function prototypes 
  7 void generateNewBug(); 
  8 void displayIntro(); 
  9 void hideIntro(); 
 10 void playGame(); 
 11 void closingScreen(); 
 12   
 Lines 13 through 41 are shown next. These statements contain the program’s global 
declarations. 
 Program 8-13 
  (BugZapper partial listing) 
 13 // Constants for the screen resolution 
 14 const int SCREEN_WIDTH = 640; 
 15 const int SCREEN_HEIGHT = 480; 
 16  
 17 // Constants for sprites 
 18 const int INTRO_INDEX = 1; 
 19 const int GRASS_INDEX = 2; 
 20 const int BUG_INDEX   = 3; 
 21  
 22 // Constant for the sound file 
 23 const int BOINK_SOUND = 1; 
 24  
 25 // Constants for animation 
 26 const int FRAME_WIDTH = 64; 
 27 const int FRAME_HEIGHT = 64; 
 28 const int FRAME_COUNT = 2; 
 29  
 30 // Constant for game time 
 31 const int MAX_TIME = 10; 
 32  
 33 // Constants for the possible game states. 
 34 const int GAME_JUST_STARTED = 0; 
 35 const int GAME_IN_PLAY      = 1; 
 36 const int GAME_OVER         = 3; 
 37  
 38 // Global counter for the number of bugs zapped. 

356 
Chapter 8 
 Input, Animation, and Sound
 39 int g_bugsZapped = 0; 
 40 int g_gameState = GAME_JUST_STARTED; 
 41  
 Here is a summary of the global declarations: 
 •  Lines 14 and 15 declare constants for the screen sizes.  
 •  Lines 18 through 20 declare the  INTRO_INDEX, GRASS_INDEX and  BUG_INDEX con-
stants that will be used as sprite indices.  
 •  Line 23 declares a constant named  BOINK_INDEX that will be used as a sound 
index.  
 •  Lines 26 through 28 declare the  FRAME_WIDTH ,  FRAME_HEIGHT , and  FRAME_COUNT 
constants that are used in the lady bug animation.  
 •  Line 31 declares the const  MAX_TIME  that is set to the number of seconds that the 
game should run.  
 •  Lines 34 through 36 declare the constants  GAME_JUST_STARTED ,  GAME_IN_PLAY , 
and  GAME_OVER . These constants will represent the three states of the game.  
 •  Line 39 declares the global variable  g_bugsZapped , initialized with 0. This vari-
able will be used to keep count of the number of bugs that are zapped.  
 •  Line 40 declares the global variable  g_gameState , initialized with the constant 
 GAME_JUST_STARTED . Throughout the running of the program, this variable will 
always be assigned one of the constants declared in lines 34 through 36 to indi-
cate the current game state.  
 The  app::Begin function is shown next. 
 Program 8-13 
 (BugZapper partial listing) 
 42 // Begin app, called once at the start 
 43 void app::Begin( void ) 
 44 { 
 45    // Set the virtual resolution. 
 46    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 47  
 48    // Set the text in the window title bar. 
 49    agk::SetWindowTitle("Bug Zapper"); 
 50  
 51    // Create the background sprite. 
 52    agk::CreateSprite(GRASS_INDEX, "BugZapper/Grass.png"); 
 53  
 54    // Create the bug sprite. 
 55    agk::CreateSprite(BUG_INDEX, "BugZapper/Bug.png"); 
 56  
 57    // Create the intro screen sprite. 
 58    agk::CreateSprite(INTRO_INDEX, "BugZapper/Intro.png"); 
 59  
 60    // Load the sound file. 
 61    agk::LoadSound(BOINK_SOUND, "BugZapper/Boink.wav"); 
 62  
 63    // Randomly position the bug. 
 64    generateNewBug(); 

 
8.7 The Bug Zapper Game 
357
 65  
 66    // Set the sprite animation 
 67    agk::SetSpriteAnimation(BUG_INDEX, FRAME_WIDTH, 
 68                 FRAME_HEIGHT, FRAME_COUNT); 
 69  
 70    // Play the bug animation. 
 71    agk::PlaySprite(BUG_INDEX); 
 72 }  
 Here is a summary of the function: 
 •  Line 46 sets the virtual resolution.  
 •  Line 49 sets the text in the window’s title bar.  
 •  Line 52 creates a sprite that will be used as the game’s background image. The 
sprite is an image of grass that fills the entire screen.  
 •  Line 55 creates the bug sprite.  
 •  Line 58 creates the sprite that is displayed as the game’s intro screen.  
 •  Line 61 loads the sound file that will be played each time the user zaps a bug.  
 •  Line 64 calls a function named  generateNewBug . This function, which is defined 
in lines 121 through 133, positions the bug sprite at a random location.  
 •  Lines 67 and 68 call the  agk::SetSpriteAnimation function to setup the anima-
tion of the bug.  
 •  Line 71 calls the  agk::PlaySprite function to start the bug animation.  
 The  app::Loop function appears in lines 75 through 112. 
 Program 8-13 
 (BugZapper partial listing) 
 74 // Main loop, called every frame 
 75 void app::Loop ( void ) 
 76 { 
 77    // Determine the game state and 
 78    // act accordingly. 
 79    switch (g_gameState) 
 80    { 
 81    case GAME_JUST_STARTED: 
 82       // Display the intro screen. 
 83       displayIntro(); 
 84  
 85       // Check for a key press. 
 86       if (agk::GetRawLastKey()) 
 87       { 
 88          // Hide the intro screen 
 89          hideIntro(); 
 90  
 91          // Change the game state. 
 92          g_gameState = GAME_IN_PLAY; 
 93  
 94          // Reset the timer. 
 95          agk::ResetTimer(); 
 96       } 

358 
Chapter 8 
 Input, Animation, and Sound
 97       break; 
 98  
 99    case GAME_IN_PLAY: 
 100       // Engage in game play. 
 101       playGame(); 
 102       break; 
 103  
 104    case GAME_OVER: 
 105       // Display the closing screen. 
 106       closingScreen(); 
 107       break; 
 108    }; 
 109  
 110    // Update the screen. 
 111    agk::Sync(); 
 112 } 
 113  
 114 // Called when the app ends 
 115 void app::End ( void ) 
 116 { 
 117 } 
 118  
 Most of the code in this function is in a  switch statement that determines the state 
of the game and then acts accordingly. The  g_gameState variable can be set to one of 
the following constants: 
 •  GAME_JUST_STARTED , which indicates that the game just started, and the intro 
screen should be displayed.  
 •  GAME_IN_PLAY , which indicates that the intro screen has been dismissed, and the 
game is in play. In this state, the user has 10 seconds to zap as many bugs as 
possible.  
 •  GAME_OVER , which indicates that the 10 seconds have ended, and the game is over.  
 The  switch statement tests the  g_gameState variable and works as follows: 
 •  If  g_gameState is equal to  GAME_JUST_STARTED , the program jumps to the  case 
statement in line 81. Line 83 calls the  displayIntro function, which displays the 
intro screen. The  if statement in line 86 determines if the user has pressed a key 
on the keyboard. It does this by testing the value that is returned from the 
 agk::GetRawLastKey function. The function returns a nonzero value if the user 
has pressed a key, or zero otherwise. The  if statement will treat a nonzero value 
as true, so if the user has pressed a key, the program branches to line 89, which 
calls the  hideIntro function. The  hideIntro function hides the intro screen and 
makes the grass and bug visible. Then, line 92 assigns  GAME_IN_PLAY to 
 g_gameState to indicate that the game is now in play. Line 95 resets the timer.  
 •  If  g_gameState is equal to  GAME_IN_PLAY , the program jumps to the  case statement 
in line 99. Line 101 calls the  playGame  function, which handles all the game action.  
 •  If  g_gameState is equal to  GAME_OVER , the program jumps to the  case statement 
in line 104. Line 106 calls the closingScreen function, which displays the game’s 
closing screen reporting the number of bugs that were zapped.  

 
8.7 The Bug Zapper Game 
359
 After the  switch statement, line 111 calls the  agk::Sync function to update the screen. 
 The generateNewBug function is shown next, in lines 121 through 133. 
 Program 8-13 
  (BugZapper partial listing) 
 119 // The generateNewBug function generates a new bug at 
 120 // random location. 
 121 void generateNewBug() 
 122 { 
 123     // Get the bug's width and height. 
 124     int bugWidth = agk::GetSpriteWidth(BUG_INDEX); 
 125     int bugHeight = agk::GetSpriteHeight(BUG_INDEX); 
 126  
 127     // Generate a new location. 
 128     int x = agk::Random(0, SCREEN_WIDTH - bugWidth); 
 129     int y = agk::Random(0, SCREEN_HEIGHT - bugHeight); 
 130  
 131     // Put the bug at that location. 
 132     agk::SetSpritePosition(BUG_INDEX, x, y); 
 133 } 
 134 
 Lines 124 and 125 get the bug sprite’s width and height and assign those values to the 
local variables  bugWidth and  bugHeight . We use these values in lines 128 and 129 to 
generate random numbers for the bug sprite’s  X- and  Y -coordinates. Line 132 posi-
tions the bug sprite at the new coordinates. 
 The  displayIntro function is shown next, in lines 137 through 145. 
 Program 8-13 
 (BugZapper partial listing) 
 135 // The displayIntro function hides the grass and the 
 136 // bug sprite and makes the intro screen visible. 
 137 void displayIntro() 
 138 { 
 139    // Make the grass and bug invisible. 
 140    agk::SetSpriteVisible(GRASS_INDEX, 0); 
 141    agk::SetSpriteVisible(BUG_INDEX, 0); 
 142  
 143    // Make the intro screen visible. 
 144    agk::SetSpriteVisible(INTRO_INDEX, 1); 
 145 } 
 146  
 The  displayIntro function simply hides the grass and bug sprites (in lines 140 and 
141) and makes the intro screen sprite visible (in line 144). 
 The  hideIntro function is shown next, in lines 149 through 154. 

360 
Chapter 8 
 Input, Animation, and Sound
 Program 8-13 
 (BugZapper partial listing) 
 147 // The hideIntro function hides the intro screen 
 148 // and makes the grass and bug visible. 
 149 void hideIntro() 
 150 { 
 151    agk::SetSpriteVisible(INTRO_INDEX, 0); 
 152    agk::SetSpriteVisible(BUG_INDEX, 1); 
 153    agk::SetSpriteVisible(GRASS_INDEX, 1); 
 154 } 
 155  
 The  hideIntro function simply hides the intro screen sprite (in line 151) and makes 
the grass and bug sprites visible (in lines 152 and 153). 
 The  playGame function is shown next, in lines 157 through 191. 
 Program 8-13 
  (BugZapper partial listing) 
 156 // The playGame function processes a frame of game play. 
 157 void playGame() 
 158 { 
 159       // Variables for mouse coordinates 
 160    float mouseX, mouseY; 
 161  
 162    // Do we still have time left? 
 163    if (agk::Timer() < MAX_TIME) 
 164    { 
 165       // Determine if the left mouse button was pressed. 
 166       if(agk::GetRawMouseLeftPressed()) 
 167       { 
 168          // Get the mouse pointer location. 
 169          mouseX = agk::GetRawMouseX(); 
 170          mouseY = agk::GetRawMouseY(); 
 171  
 172          // Check to see if the bug was hit. 
 173          if (agk::GetSpriteHit(mouseX, mouseY) == BUG_INDEX) 
 174          { 
 175             // Play the boink sound. 
 176             agk::PlaySound(BOINK_SOUND); 
 177  
 178             // Update the count. 
 179             g_bugsZapped++; 
 180  
 181             // Generate a new bug. 
 182             generateNewBug(); 
 183          } 
 184       } 
 185    } 

 
8.7 The Bug Zapper Game 
361
 186    else 
 187    { 
 188       // Time is up, game over. 
 189       g_gameState = GAME_OVER; 
 190    } 
 191 } 
 192  
 The  playGame function handles all the game action while the user is zapping bugs. It 
also monitors the timer to determine when the game is over. Here is a summary of 
the function’s code: 
 •  Line 160 declares two local variables,  mouseX and  mouseY , to hold the coordi-
nates of the mouse pointer.  
 •  The  if statement in line 163 gets the amount of time that the program has been 
running (since it was last reset) and determines if this is less than  MAX_TIME . If so, 
the game is still in play, and the program branches to line 166. Line 166 is 
another  if statement. It determines whether the left mouse button was clicked. 
If so, the program branches to line 169. Lines 169 and 170 get the mouse pointer’s 
coordinates and assigns them to the  mouseX and  mouseY variables. Then the  if 
statement in line 170 determines whether the mouse was clicked on the bug 
sprite. If so, line 176 plays a sound, line 179 adds one to the  g_bugsZapped vari-
able, and line 182 calls the  generateNewBug function to reposition the bug at a 
new, random location. 
 •  If the  if statement in line 163 determines that that the game’s play time is over, 
then line 189 assigns the constant  GAME_OVER to the  g_gameState variable.  
 The  closingScreen function is shown next, in lines 194 through 203. 
 Program 8-13 
 (BugZapper partial listing) 
 193 // The closingScreen function displays the closing screen. 
 194 void closingScreen() 
 195 { 
 196    // Hide the bug and the grass. 
 197    agk::SetSpriteVisible(GRASS_INDEX, 0); 
 198    agk::SetSpriteVisible(BUG_INDEX, 0); 
 199  
 200    // Display the results. 
 201    agk::PrintC("Number of bugs zapped: "); 
 202    agk::Print(g_bugsZapped); 
 203 }  
 Lines 197 and 198 make the grass and bug sprites invisible. Then, lines 201 and 202 
display a message reporting the number of bugs that have been zapped. 

362 
Chapter 8 
 Input, Animation, and Sound
 Review Questions 
 Multiple Choice  
 
1.  These functions return the mouse pointer’s  X- and  Y -coordinates.  
 a.  agk::GetMouseX and  agk::GetMouseY 
 b.  agk::GetRawMouseX and  agk::GetRawMouseY 
 c.  agk::MouseX and  agk::MouseY 
 d.  agk::GetXMouse and  agk::GetYMouse 
 
2.   This function makes the mouse pointer visible or invisible.  
 a.  agk::SetMouseVisible 
 b.  agk::SetMouseInvisible 
 c.  agk::SetRawMouseVisible 
 d.  agk::ShowMouse 
 
3.   These functions can be used to determine whether the left or right mouse button 
is being pressed.  
 a.  agk::GetRawMouseLeftPressed and 
 
 agk::GetRawMouseRightPressed 
 b.  agk::GetMouseLeftPressed and 
 
 agk::GetMouseRightPressed 
 c.  agk::GetLeftPressed and  agk::GetRightPressed 
 d.  agk::GetMouseLeft and  agk::GetMouseRight 
 
4.   This function determines if the user clicked on a sprite with the mouse.  
 a.  agk::MouseSpriteHit 
 b.  agk::GetSpriteClicked 
 c.  agk::GetSpriteHit 
 d.  agk::GetMouseClicked 
 
5.   When you set a virtual button’s position, you set it by the button’s _____.  
 a.  upper-left corner  
 b.  center point  
 c.  lower-right corner  
 d.  lower-left corner  
 
6.  This function returns 1 (true) as long as the button is held down, and otherwise 
it returns 0 (false).  
 a.  agk::GetVirtualButtonPressed 
 b.  agk::GetVirtualButtonState 
 c.  agk::GetVirtualButtonReleased 
 d.  agk::GetVirtualButtonRawData 
 
7.   This is an area around a virtual joystick’s center that affects how far you have to 
move the joystick before it registers input:  
 a.  dead zone.  
 b.  home position.  
 c.  center point.  
 d.  sensitivity zone.  

 
Review Questions 
363
 
8.   You use this function to determine whether the left or right arrow keys have been 
pressed on the keyboard.  
 a.  agk::GetArrowKey 
 b.  agk::GetLeftRightArrow 
 c.  agk::GetDirectionY 
 d.   agk::GetDirectionX 
 
9.   You use this function to determine the last key that was pressed on the 
keyboard.  
 a.  agk::GetRawLastKey 
 b.   agk::GetKey 
 c.  agk::GetLastKey 
 d.  agk::KeyPressed 
 
10.   This is an image file containing all the images used in an animation.  
 a.  Sprite array  
 b.  Texture atlas  
 c.  Image sheet  
 d.  Animation matrix  
 True or False  
 
1.   By default, the mouse pointer is invisible when an AGK program is running.  
 
2.  A virtual button is positioned by its upper-left corner.  
 
3.  You can change the color of a virtual button.  
 
4.  You can change the images that are used to display a virtual button.  
 
5.  You can have an unlimited number of virtual buttons in an AGK program.  
 
6.  You can have four virtual joysticks in an AGK program.  
 
7.  You can totally disable a virtual joystick by setting the dead zone value to 0.  
 
8.  Files that are stored in the  .wav format are considered music files.  
 Short Answer  
 
1.   Using the AGK, how do you tell if the user has clicked on a sprite using the 
mouse?  
 
2.   What is a virtual button?  
 
3.   How can you determine if a virtual button is being held down?  
 
4.   What is a virtual joystick?  
 
5.   How do you adjust the sensitivity of a virtual joystick?  
 
6.   What is the default dead zone value of a virtual joystick?  
 
7.   How do you know if a virtual joystick is being moved to the left? How do you 
know if it is being moved to the right?  

364 
Chapter 8 
 Input, Animation, and Sound
 
8.  What is cel animation?  
 
9.   MP3 files are considered what kind of file?  
 Algorithm Workbench  
 
1.  Write code that gets the mouse pointer’s coordinates and assigns those values to 
variables named  mouseX and  mouseY . 
 
2.   Write a statement that makes the mouse pointer invisible.  
 
3.   Write a statement that adds a virtual button to the program. The virtual button’s 
index should be 1, its size should be 50 pixels, and its coordinates should be 
(400, 100).  
 
4.  Write a statement that deactivates the virtual button with the index 1.  
 
5.   Suppose you have two image files that you want to use for a virtual button, 
instead of the default images provided by the AGK. The image files are named 
 custom_button_up.png and  custom_button_down.png . Write code that sets these 
image files as the images for the virtual button with the index 1.  
 
6.   Write a statement that adds a virtual joystick with an index number of 1 to the 
top-left corner of the screen using a size of 75.  
 
7.   Write a statement that sets all virtual joystick dead zones to 0.5.  
 
8.   Write code that determines whether the last key that was pressed was the space-
bar and, if so, displays a message.  
 
9.   You have an image file named  animation.png that contains all the images for an 
animation. Each frame in the file is 128 pixels wide and 246 pixels high. Write 
the code to load the image file, and then play the animation sequence.  
 
10.   Write code that loads and plays the sound file  roar.wav . 
 Programming Exercises 
 
1.  Mouse Rollover 
 Write a program that displays an image. When the user moves the mouse pointer 
over the image, it should change to a second image. The second image should remain 
displayed as long as the mouse pointer is over it. When the user moves the mouse 
pointer away from the second image, it should change back to the first image.  
 
2.   Coin Toss 
 Write a program that simulates the tossing of a coin. The program should wait 
for the user to press a key and then generate a random number in the range 
of 0 through 1. If the number is 0, the program should display the image of a 
coin with heads facing up. If the number is 1, the program should display the 
image of a coin with tails facing up. (You can create your own coin images 
or use the ones provided in  the book’s  online resources, downloadable from 
 www.pearsonhighered.com/gaddis .)  

 
Programming Exercises 
365
 
3.   Make Your Head Spin 
 Have a friend use a digital camera to take photos of your head from different 
angles. (For example, your left profile, your face, your right profile, the back of 
your head, etc.) Copy the photos to your computer, and put them together as a 
texture atlas. Then write a program that creates an animation that shows your 
head spinning.  
 
4.   Lunar Lander,  Part   1 
 The book’s online  resources (downloadable from  www.pearsonhighered.com/
gaddis ) provide images of a spacecraft and a background drawing of the moon’s 
surface. Write a program that initially displays the spacecraft on the moon’s sur-
face. When the user presses the spacebar, the spacecraft should slowly lift off the 
surface and continue to lift as long as the spacebar is held down. When the user 
releases the spacebar, the spacecraft should slowly descend back down toward the 
surface and stop when it reaches the surface.  
 
5.   Lunar Lander,  Part   2 
 Enhance the lunar lander program (see Programming Exercise 4) so the user can 
press the left or right arrow keys, along with the spacebar, to slowly guide the 
spacecraft to the left or right. If the spacebar is not pressed, however, the left and 
right arrow keys should have no effect.  
 
6.   Lunar Lander,  Part   3 
 Enhance the lunar lander program (see Programming Exercises 4 and 5) so the 
spacecraft initially appears on one side of the screen, and a landing pad appears 
on the opposite side. The user should try to fly the spacecraft and guide it so that 
it lands on the landing pad. If the spacecraft successfully lands on the landing pad, 
display a message congratulating the user.  
 
7.   Change for a Dollar Game 
 The book’s online  resources (downloadable from  www.pearsonhighered.com/
gaddis ) provide images of a penny, a nickel, a dime, and a quarter. Create a game 
that displays each of these images, plus another image showing the text “Count 
Change”. The game should let the user click on any of the coins, in any order. 
To win the game, the user must click on the coins that, when added together, 
equal exactly one dollar. When the user clicks the “Count Change” image the 
program should show the amount of money that the user clicked. If the amount 
equals one dollar, the program should indicate that the user won the game.  
 
8.   Rock, Paper, Scissors Game 
 Write a program that lets the user play the game of Rock, Paper, Scissors against 
the computer. The program should work as follows. 
 (1)   When the program begins, a random number in the range of 0 through 2 
is generated. If the number is 0, then the computer has chosen rock. If the 
number is 1, then the computer has chosen paper. If the number is 2, then 
the computer has chosen scissors. (Don’t display the computer’s choice yet.)  
 (2)   To make his or her selection, the user clicks an image on the screen. (You 
can find images for this game included in  the book’s  online resources at 
 www.pearsonhighered.com/gaddis .) 

366 
Chapter 8 
 Input, Animation, and Sound
 (3)  The computer’s choice is displayed.  
 (4)   A winner is selected according to the following rules: 
 •  If one player chooses rock and the other player chooses scissors, then 
rock wins. (The rock smashes the scissors.)  
 •  If one player chooses scissors and the other player chooses paper, 
then scissors wins. (Scissors cuts paper.)  
 •  If one player chooses paper and the other player chooses rock, then 
paper wins. (Paper wraps rock.)  
 •  If both players make the same choice, the game is a tie.  

367
 
  9.1  Text Objects 
 CONCEPT:    You can create text objects to display messages and information. Text 
objects have properties such as position, size, and color.  
 So far we have used  the  agk::Print and  agk::PrintC functions to display text on the 
screen. These functions work well for displaying simple messages, but they don’t al-
low you to change the position of the text or perform other operations. With the AGK 
you can create text objects that you can use to display custom text anywhere on the 
screen. A text object is similar to a sprite. It has an index number that identifies it in 
code. Instead of an image, however, a text object contains a string of characters that 
you can place anywhere on the screen. You can change many properties of a text 
object such as its position, color, and size. In this section we will take a look at some 
of the basics of working with text objects. 
 Creating a Text Object 
 Before you can display text using a text object, you must create it. You can create a 
text object by calling the  agk::CreateText function. Creating a text object is very 
similar to the way we have created other resources such sprites or images. Here is the 
general format of how you call the function: 
 agk::CreateText( TextIndex, String );  
  TextIndex  is an integer index that that will be used to identify the text object.   String 
is a string value containing the text you want to display. For example, the following 
 9.1  Text Objects   
 9.2  Sprite Collision Detection   
 9.3  Simulating Falling Objects   
 9.4  The Vulture Trouble Game   
 TOPICS 
9 
 CHAPTER 
 Text, Collisions, and the 
Vulture Trouble Game  
VideoNote
Working with 
Text Objects

368 
Chapter 9 
 Text, Collisions, and the Vulture Trouble Game
statement creates a text object with an index number of 1 and sets its   String argu-
ment to display the text  “GAME OVER” : 
 agk::CreateText(1, "GAME OVER");  
 Deleting a Text Object 
 If you are finished using a text object and would like to remove it from memory, then 
you can call the  agk::DeleteText function. Here is the general format of how you call 
the function: 
 agk::DeleteText( TextIndex );  
  TextIndex  is the index number of the text object that you want to delete. For example, 
the following statement deletes a text object with an index number of 1: 
 agk::DeleteText(1);  
 Determining If a Text Object Exists 
 If you need to make sure that a text object exists before you perform operations on 
it, you can use the  agk::GetTextExists function. Here is the general format of how 
you call the function: 
 agk::GetTextExists( TextIndex ) 
  TextIndex  is the index number of the text object whose existence you want to check. 
The function returns an integer value of 0 (false) if the specified text object does not 
exist or 1 (true) if the text object does exist. For example, the following  if statement 
calls the  agk::GetTextExists function and uses its return value to determine whether 
a text object with an index number of 1 exists. If the text object exists, then it is 
deleted: 
 If (agk::GetTextExists(1)) 
 { 
    agk::DeleteText(1); 
 } 
 Setting the Size of a Text Object 
 By default the size of a text object is set to 4 units (which is approximately 4 pixels 
in our 640 by 480 virtual resolution), but you can easily change the size of a text 
object to any value. You do this by calling the  agk::SetTextSize function. Here is the 
general format of how you call the function: 
 agk::SetTextSize( TextIndex, Size );  
  TextIndex  is the index number of the text object whose size you want to change.   Size 
is a floating-point value that will set the height of the text object. The width of the 
text object is calculated internally by the AGK. The following statement sets the size 
of a text object with an index number of 1 to 16 units. 
 agk::SetTextSize(1, 16);  

 
9.1 Text Objects 
369
 Getting the Size of a Text Object 
 You can get the size of a text object by calling the  agk::GetTextSize function. Here 
is the general format of how you call the function: 
 agk::GetTextSize( TextIndex ) 
  TextIndex  is the index number of the text object whose size you want to get.  The func-
tion returns a floating-point value for the size of the text object specified by the index 
number. The following statement gets the size of a text object with an index number of 
1 and stores the return value in the floating-point variable named  textSize : 
 float textSize = agk::GetTextSize(1);  
 Setting the Position of a Text Object 
 Text objects are positioned in the top-left corner of the screen by default. After 
you have created a text object, you can change its position by calling the 
 agk::SetTextPosition function. Here is the general format of how you call the function: 
 agk::SetTextPosition( TextIndex, X, Y ) 
  TextIndex  is the index number of the text object whose position you want to change. 
The remaining arguments,   X and   Y , are floating-point values for the  X- and 
 Y -coordinates that you want to move the text object to. For example, the following 
statement changes the position of a text object with an index number of 1 so that its 
top-left corner appears 10 units across and 10 units down from the top-left corner of 
the screen: 
 agk::SetTextPosition(1, 10, 10);  
 Setting the  X -Coordinate of a Text Object 
 Sometimes you may only want to move a text object left or right across the screen. 
You can do this by calling the  agk::SetTextX function. Here is the general format of 
how you call the function: 
 agk::SetTextX( TextIndex, X ) 
  TextIndex  is the index number of the text object you want to change. The second argu-
ment,   X , is a floating-point value specifying the  X -coordinate you want to move the text 
object to. For example, the following statement sets the  X -coordinate of a text object 
with an index number of 1 to 100 units along the  X -axis: 
 agk::SetTextX(1, 100);  
 Getting the  X -Coordinate of a Text Object 
 You can get the value of a text object’s  X -coordinate by calling the  agk::GetTextX 
function and passing the index number of the text object you want to get the value of 
the  X -coordinate for. The function returns a floating-point value. For example, the 
following statement gets the  X -coordinate of a text object with an index number of 1 
and stores it in a floating-point variable named  textX : 
 float textX = agk::GetTextX(1);  

370 
Chapter 9 
 Text, Collisions, and the Vulture Trouble Game
 Setting the  Y -Coordinate of a Text Object 
 You can change the vertical position of a text object by calling the  agk::SetTextY 
function and passing the index number of the text object you want to change followed 
by the value of the new  Y -coordinate. For example, the following statement sets the 
 Y -coordinate of a text object with an index number of 1 to 100: 
 agk::SetTextY(1, 100);  
 Getting the  Y- Coordinate of a Text Object 
 You can get the value of a text object’s  Y -coordinate by calling the  agk::GetTextY 
function and passing the index number of the text object you want to get the value of 
the  Y -coordinate for. The function returns a floating-point value. For example, the 
following statement gets the  Y -coordinate of a text object with an index number of 1 
and stores it in a floating-point variable named  textY : 
 float textY = agk::GetTextY(1);  
 Now that we have covered several properties of text objects, it is a good time to look 
at a program that uses these functions to create text objects and set some of their prop-
erties. Program 9-1 demonstrates setting the size and position of several text objects. 
 Program 9-1 
 (Text Sizes) 
  1 // This program demonstrates setting the 
  2 // size and position of several text objects. 
  3  
  4 // Includes, namespace and prototypes 
  5 #include "template.h" 
  6 using namespace AGK; 
  7 app App; 
  8  
  9 // Constants for the screen resolution 
 10 const int SCREEN_WIDTH  = 640; 
 11 const int SCREEN_HEIGHT = 480; 
 12  
 13 // Constants for the text object index numbers 
 14 const int TEXT_A = 1; 
 15 const int TEXT_B = 2; 
 16 const int TEXT_C = 3; 
 17 const int TEXT_D = 4; 
 18 const int TEXT_E = 5; 
 19 const int TEXT_F = 6; 
 20  
 21 // Constants for the text object sizes 
 22 const float SIZE_A = 12; 
 23 const float SIZE_B = 16; 
 24 const float SIZE_C = 24; 
 25 const float SIZE_D = 36; 
 26 const float SIZE_E = 48; 
 27 const float SIZE_F = 72; 

 
9.1 Text Objects 
371
 28  
 29 // Begin app, called once at the start 
 30 void app::Begin( void ) 
 31 { 
 32    // Set the virtual resolution. 
 33    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 34  
 35    // Set the window title. 
 36    agk::SetWindowTitle("Text Sizes"); 
 37  
 38    // Create the text objects. 
 39    agk::CreateText(TEXT_A, "Text Size 12"); 
 40    agk::CreateText(TEXT_B, "Text Size 16"); 
 41    agk::CreateText(TEXT_C, "Text Size 24"); 
 42    agk::CreateText(TEXT_D, "Text Size 36"); 
 43    agk::CreateText(TEXT_E, "Text Size 48"); 
 44    agk::CreateText(TEXT_F, "Text Size 72"); 
 45  
 46    // Set the size of each text object. 
 47    agk::SetTextSize(TEXT_A, SIZE_A); 
 48    agk::SetTextSize(TEXT_B, SIZE_B); 
 49    agk::SetTextSize(TEXT_C, SIZE_C); 
 50    agk::SetTextSize(TEXT_D, SIZE_D); 
 51    agk::SetTextSize(TEXT_E, SIZE_E); 
 52    agk::SetTextSize(TEXT_F, SIZE_F); 
 53  
 54    // Variables to hold  XY -coordinates, initialized to 0. 
 55    float x = 0; 
 56    float y = 0; 
 57  
 58    // Set the position of text object A. 
 59    agk::SetTextPosition(TEXT_A, x, y); 
 60  
 61    // Increment the  Y -coordinate with 
 62    // the size of text object A. 
 63    y += SIZE_A; 
 64  
 65    // Set the position of text object B. 
 66    agk::SetTextPosition(TEXT_B, x, y); 
 67  
 68    // Increment the  Y -coordinate with 
 69    // the size of text object B. 
 70    y += SIZE_B; 
 71  
 72    // Set the position of text object C. 
 73    agk::SetTextPosition(TEXT_C, x, y); 
 74  
 75    // Increment the  Y -coordinate with 
 76    // the size of text object C. 
 77    y += SIZE_C; 
 78  
 79    // Set the position of text object D. 
 80    agk::SetTextPosition(TEXT_D, x, y); 
 81  

372 
Chapter 9 
 Text, Collisions, and the Vulture Trouble Game
 82    // Increment the  Y -coordinate with 
 83    // the size of text object D. 
 84    y += SIZE_D; 
 85  
 86    // Set the position of text object E. 
 87    agk::SetTextPosition(TEXT_E, x, y); 
 88  
 89    // Increment the  Y -coordinate with 
 90    // the size of text object E. 
 91    y += SIZE_E; 
 92  
 93    // Set the position of text object F. 
 94    agk::SetTextPosition(TEXT_F, x, y); 
 95 } 
 96  
 97 // Main loop, called every frame 
 98 void app::Loop ( void ) 
 99 { 
 100    // Refresh the screen. 
 101    agk::Sync(); 
 102 } 
 103  
 104 // Called when the app ends 
 105 void app::End ( void ) 
 106 { 
 107 }  
 The following global constants are declared in lines 14 through 27: 
 ●  The  TEXT_A ,  TEXT_B ,  TEXT_C ,  TEXT_D ,  TEXT_E , and  TEXT_F constants are declared 
in lines 14 through 19. These constants will be used for the index numbers of 
each type of text object.  TEXT_A contains the index number for the text object 
that will have the smallest size.  TEXT_F contains the index number for the text 
object that will have the largest size.  
 ●  Lines 22 through 27 declare the  SIZE_A ,  SIZE_B ,  SIZE_C ,  SIZE_D ,  SIZE_E , and 
 SIZE_F constants. These constants represent the values we will use to set the size 
of each text object. Each of the constants contains a value for the size it will set. 
 SIZE_A represents the smallest size, which is the value 12.  SIZE_F represents the 
largest size, which is the value 72.  
 The  app::Begin function appears in lines 30 through 95: 
 ●  In lines 39 through 44 we create each of the text objects. Notice that the string 
value for each text object specifies its size. The string “Text Size 12” belongs to 
the  TEXT_A text object. The string “Text Size 72” belongs to the  TEXT_F text 
object.  
 ●  In lines 47 through 52 we set the size of each text object.  TEXT_A is set to use 
 SIZE_A .  TEXT_B is set to use  SIZE_B , and so on.  
 ●  In lines 55 and 56 we declare two floating-point variables:  x and  y . These vari-
ables will be used to store the  X- and  Y -coordinates we will use to position each 

 
9.1 Text Objects 
373
text object. These variables are initialized with the value 0. This will represent 
the position of the top-left corner of the screen.  
 ●  In lines 59 through 94 we set the position of each text object. The position of 
TEXT_A is set to the top-left corner of the screen. In line 63 the y variable is incre-
mented by the SIZE_A constant. This will move the position of the next text 
object down by the value of the SIZE_A constant. This pattern is repeated for the 
remaining text objects, with each text object’s  y value being incremented by the 
size of the previous text object.  
 Inside the  app::Loop function, in line 101 the  agk::Sync function is called to refresh 
the screen. 
 In  Figure  9-1 you can see the output of Program 9-1. Notice how the vertical spacing 
increases as the size of each text object increases.  
 Figure 9-1  Output of Program 9-1  
 Setting the Alignment of a Text Object 
 The alignment of a text object is set to its top-left corner (left-aligned) by default. You 
can change the alignment of a text object by calling the  agk::SetTextAlignment func-
tion passing the index number of the text object you want to change the alignment 
for and an integer value,   Mode , indicating the type of alignment you want to use for 
the text object. A value of 0 will set the alignment to left. A value of 1 sets the align-
ment to center, and a value of 2 sets the alignment to right. 
 Figure  9-2 illustrates each type of alignment. Program 9-2 demonstrates the three dif-
ferent types of text alignment.  

374 
Chapter 9 
 Text, Collisions, and the Vulture Trouble Game
 Program 9-2 
  (Text Alignment) 
 1 // This program demonstrates text alignment. 
 2 #include "template.h" 
 3 using namespace AGK; 
 4 app App; 
 5  
 6 // Constants for the screen resolution 
 7 const int SCREEN_WIDTH  = 640; 
 8 const int SCREEN_HEIGHT = 480; 
 9  
 10 // Constants for the text objects 
 11 const int LEFT_TEXT     = 1; 
 12 const int CENTER_TEXT   = 2; 
 13 const int RIGHT_TEXT    = 3; 
 14  
 15 const int ALIGN_LEFT    = 0; 
 16 const int ALIGN_CENTER  = 1; 
 17 const int ALIGN_RIGHT   = 2; 
 18  
 19 const float TEXT_SIZE   = 16; 
 20  
 21 const float CENTER_X = SCREEN_WIDTH / 2; 
 22 const float CENTER_Y = SCREEN_HEIGHT / 2; 
 23  
 24 // Begin app, called once at the start 
 25 void app::Begin( void ) 
 26 { 
 27    // Set the virtual screen resolution. 
 28    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 29  
 30    // Set the window title. 
 31    agk::SetWindowTitle("Text Alignment"); 
 32  
 33    // Create the text objects. 
 34    agk::CreateText(LEFT_TEXT, "Left-aligned"); 
 35    agk::CreateText(CENTER_TEXT, "Center-aligned"); 
 36    agk::CreateText(RIGHT_TEXT, "Right-aligned"); 
 37  
 Figure 9-2  Different alignments of a text object  

 
9.1 Text Objects 
375
 38    // Set the size of each text object. 
 39    agk::SetTextSize(LEFT_TEXT, TEXT_SIZE); 
 40    agk::SetTextSize(CENTER_TEXT, TEXT_SIZE); 
 41    agk::SetTextSize(RIGHT_TEXT, TEXT_SIZE); 
 42  
 43    // Set the alignment of each text object. 
 44    agk::SetTextAlignment(LEFT_TEXT, ALIGN_LEFT); 
 45    agk::SetTextAlignment(CENTER_TEXT, ALIGN_CENTER); 
 46    agk::SetTextAlignment(RIGHT_TEXT, ALIGN_RIGHT); 
 47  
 48    // Set the position of each text object. 
 49    agk::SetTextPosition(LEFT_TEXT, CENTER_X, CENTER_Y - 40); 
 50    agk::SetTextPosition(CENTER_TEXT, CENTER_X, CENTER_Y); 
 51    agk::SetTextPosition(RIGHT_TEXT, CENTER_X, CENTER_Y + 40); 
 52 } 
 53  
 54 // Main loop, called every frame 
 55 void app::Loop ( void ) 
 56 { 
 57    // Refresh the screen. 
 58    agk::Sync(); 
 59 } 
 60  
 61 // Called when the app ends 
 62 void app::End ( void ) 
 63 { 
 64 } 
 The following global constants are declared in lines 11 through 22: 
 ●  The  LEFT_TEXT ,  CENTER_TEXT , and  RIGHT_TEXT constants are declared in lines 11 
through 13. These constants will be used for the index numbers of each type of 
text object.  LEFT_TEXT is the index number for the text object that will be left-
aligned.  CENTER_TEXT is the index number for the text object that will be center-
aligned, and  RIGHT_TEXT is the index number for the text object that will be 
right-aligned.  
 ●  Lines 15 through 17 declare the  ALIGN_LEFT ,  ALIGN_CENTER , and  ALIGN_RIGHT 
constants. These constants represent the values we will use to set the alignment 
of each text object. Each of the constants contains the value for the mode it will 
set.  ALIGN_LEFT , which has a value of 0, will set the text object to be left-aligned, 
 ALIGN_CENTER , which has a value of 1, will set the text object to be center-
aligned, and  ALIGN_RIGHT , which has a value of 2, will set the text object to be 
right-aligned.  
 ●  Line 19 declares the floating-point constant TEXT_SIZE initialized with the value 
16. This value will be used to set the size of each text object.  
 ●  Lines 21 and 22 declare the  CENTER_X and  CENTER_Y constants. These are float-
ing-point values for  XY -coordinates for the center of the screen.  CENTER_X is 
initialized with half the value of  SCREEN_WIDTH, and  CENTER_Y is initialized with 
half the value of  SCREEN_HEIGHT . We will use these constants to set the position 
of each text object.  

376 
Chapter 9 
 Text, Collisions, and the Vulture Trouble Game
 The  app::Begin function appears in lines 25 through 52: 
 ●  In lines 34 through 36 we create each of the text objects. Notice that the string 
value for each text object specifies its alignment. The string “Left-aligned” be-
longs to the  LEFT_TEXT text object. The string “Center-aligned” belongs to the 
 CENTER_TEXT text object. The string “Right-aligned” belongs to the  RIGHT_TEXT 
text object.  
 ●  In lines 39 through 41 we set the size of each text object with the  TEXT_SIZE 
constant.  
 ●  In lines 44 through 46 we set the alignment for each text object. The LEFT_TEXT text 
object has its alignment set using the ALIGN_LEFT value, which is the default. The 
CENTER_TEXT text object is set to be center-aligned because its alignment mode is 
set using the ALIGN_CENTER value. RIGHT_TEXT is set to be right-aligned because its 
alignment mode is set using the ALIGN_RIGHT value.  
 ●  In lines 49 through 51 we set the position of each text object. To show how the 
alignment mode affects the position of each text object, each text object is set 
using the same value for the  X -coordinate. The  LEFT_TEXT object will appear 
left-aligned, the  CENTER_TEXT object will appear center-aligned, and the 
 RIGHT_TEXT object will appear right-aligned.  
 Inside the  app::Loop function, in line 58 the  agk::Sync function is called to refresh 
the screen. 
 In  Figure   9-3 you can see how the alignment affects the position of the text. Although 
each text object has the same  X -coordinate value, the text appears differently. Left-
aligned text has its origin in the top-left corner. Center-aligned text has its origin in 
the top-center. Right-aligned text has its origin in the top-right corner.   
 Figure 9-3  Output of Program 9-2  

 
9.1 Text Objects 
377
 Changing the Spacing between Letters in a Text Object 
 You can change the spacing between letters in a text object by calling the 
 agk::SetTextSpacing function. Here is the general format of how you call the function: 
 agk::SetTextSpacing( TextIndex, Spacing ); 
  TextIndex  is the integer index of the text object whose spacing you want to change. 
 Spacing is a floating-point value that indicates the amount of spacing between each let-
ter in the text object. If you specify a positive value, then the spacing will increase. If 
you specify a negative value, then the spacing will decrease, and the letters will appear 
closer together. A value of zero displays the text object using the default spacing. 
 Program 9-3 demonstrates letter spacing with three different text objects. Figure 9-4 
shows the program’s output. 
 Program 9-3 
 (Text Spacing) 
 1 // This program demonstrates text spacing. 
 2 #include "template.h" 
 3 using namespace AGK; 
 4 app App; 
 5  
 6 // Constants for the screen resolution 
 7 const int SCREEN_WIDTH  = 640; 
 8 const int SCREEN_HEIGHT = 480; 
 9  
 10 // Constants for the text objects 
 11 const int TEXT_A  = 1; 
 12 const int TEXT_B  = 2; 
 13 const int TEXT_C  = 3; 
 14  
 15 const int ALIGN_CENTER  = 1; 
 16 const float TEXT_SIZE   = 16; 
 17  
 18 const float CENTER_X = SCREEN_WIDTH / 2; 
 19 const float CENTER_Y = SCREEN_HEIGHT / 2; 
 20  
 21 // Begin app, called once at the start 
 22 void app::Begin( void ) 
 23 { 
 24    // Set the virtual screen resolution. 
 25    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 26  
 27    // Set the window title. 
 28    agk::SetWindowTitle("Text Spacing"); 
 29  
 30    // Create the text objects. 
 31    agk::CreateText(TEXT_A, "Default Spacing"); 
 32    agk::CreateText(TEXT_B, "Ten Unit Spacing"); 
 33    agk::CreateText(TEXT_C, "Twenty Unit Spacing"); 
 34  
 35    // Set the size of each text object. 
 36    agk::SetTextSize(TEXT_A, TEXT_SIZE); 
 37    agk::SetTextSize(TEXT_B, TEXT_SIZE); 

378 
Chapter 9 
 Text, Collisions, and the Vulture Trouble Game
 38    agk::SetTextSize(TEXT_C, TEXT_SIZE); 
 39  
 40    // Set the alignment of each text object. 
 41    agk::SetTextAlignment(TEXT_A, ALIGN_CENTER); 
 42    agk::SetTextAlignment(TEXT_B, ALIGN_CENTER); 
 43    agk::SetTextAlignment(TEXT_C, ALIGN_CENTER); 
 44  
 45    // Set the spacing of each text object. 
 46    agk::SetTextSpacing(TEXT_A, 0); 
 47    agk::SetTextSpacing(TEXT_B, 10); 
 48    agk::SetTextSpacing(TEXT_C, 20); 
 49  
 50    // Set the position of each text object. 
 51    agk::SetTextPosition(TEXT_A, CENTER_X, CENTER_Y - 40); 
 52    agk::SetTextPosition(TEXT_B, CENTER_X, CENTER_Y); 
 53    agk::SetTextPosition(TEXT_C, CENTER_X, CENTER_Y + 40); 
 54 } 
 55  
 56 // Main loop, called every frame 
 57 void app::Loop ( void ) 
 58 { 
 59    // Refresh the screen. 
 60    agk::Sync(); 
 61 } 
 62  
 63 // Called when the app ends 
 64 void app::End ( void ) 
 65 { 
 66 } 
 The following global constants are declared in lines 11 through 19: 
 ●  The  TEXT_A ,  TEXT_B , and  TEXT_C constants are declared in lines 11 through 13. 
These constants will be used for the index numbers of each type of text object. 
 TEXT_A is the index number for the text object that will use default spacing. 
 TEXT_B is the index number for the text object that will be spaced 10 units be-
tween each letter, and  TEXT_C is the index number for the text object that will be 
spaced 20 units between each letter.  
 ●  Line 15 declares the  ALIGN_CENTER constant. This constant represents the value 
we will use to set the alignment of each text object to be center-aligned.  
 ●  Line 16 declares the floating-point constant TEXT_SIZE initialized with the value 
16. This value will be used to set the size of each text object.  
 ●  Lines 18 and 19 declare the  CENTER_X and  CENTER_Y constants. These are floating-
point values for the  XY -coordinates of the center of the screen.  CENTER_X is initial-
ized with half the value of  SCREEN_WIDTH .  CENTER_Y is initialized with half the value 
of  SCREEN_HEIGHT . We will use these constants to set the position of each text object.  
 The  app::Begin function appears in lines 22 through 54: 
 ●  In lines 31 through 33 we create each of the text objects. Notice that the string value 
for each text object describes the spacing it will use. The string “Default Spacing” 
belongs to the  TEXT_A text object. The string “Ten Unit Spacing” belongs to the  TEXT_B 
text object. The string “Twenty Unit Spacing” belongs to the  TEXT_C text object.  

 
9.1 Text Objects 
379
 ●  In lines 36 through 38 we set the size of each text object with the  TEXT_SIZE 
constant.  
 ●  In lines 41 through 43 we set the alignment for each text object by using the 
 ALIGN_CENTER value.  
 ●  In lines 46 through 48 we set the spacing of each text object.  TEXT_A is set to use 
default spacing.  TEXT_B is set to use 10 units of spacing.  TEXT_C is set to use 20 
units of spacing.  
 ●  In lines 51 through 53 we set the position of each text object. The position of 
each text object is set using the same value for the  X -coordinate. The  Y -
coordinate of each text object is modified so that each text object appears in its 
own vertical space. If we were to use the same  Y -coordinate, the text objects 
would overlap.  
 In the  app::Loop function, line 60 calls the  agk::Sync function is called to refresh 
the screen.  
 Figure 9-4  Output of Program 9-3  
 Setting the String Value of a Text Object 
 If you want to change the string value that was initially set for a text object to a dif-
ferent value, you can call the  agk::SetTextString function. Here is the general format 
of how you call the function: 
 agk::SetTextString(TextIndex, String);  
 This function is similar to the  agk::CreateTextFunction , but in this case the   TextIndex 
argument is for an existing text object.   String contains the string of characters you 
want to display. For example, the following statement changes the string value of a 
text object with an index number of 1 to  “GAME START” : 
 agk::SetTextString(1, "GAME START");  

380 
Chapter 9 
 Text, Collisions, and the Vulture Trouble Game
 Getting the Total Width of a Text Object 
 You can get the total width of a text object by calling the  agk::GetTextTotalWidth 
function and passing the index number of the text object whose total width you want 
to get. The function returns a floating-point value for the total width of the text ob-
ject. For example, the following statement stores the total width of a text object with 
an index number of 1 in a floating-point variable named  textTotalWidth : 
 float textTotalWidth = agk::GetTextTotalWidth(1);  
 Getting the Total Height of a Text Object 
 You can get the total height of a text object by calling the  agk::GetTextTotalHeight  
function and passing the index number of the text object whose total height you want 
to get. The function returns a floating-point value for the total height of the text ob-
ject. For example, the following statement stores the total height of a text object with 
an index number of 1 in a floating-point variable named  textTotalHeight : 
 float textTotalHeight = agk::GetTextTotalHeight(1);  
 Showing or Hiding a Text Object 
 In some instances you might want to hide the text objects in an application until they 
are needed. If you want to hide a text object or show a previously hidden text object, 
you can call the  agk::SetTextVisible function. Here the general format of how you 
call the function: 
 agk::SetTextVisible( TextIndex, Visible );  
 The first argument,  TextIndex , is the integer index of the text object whose visibility 
you want to set. The second argument,   Visible , is an integer value that sets the visibil-
ity. Passing a value of 0 (false) will hide the text object, and passing a value of 1 (true) 
will show the text object. The following example hides a text object with an index 
number of 1. 
 agk::SetVirtualButtonVisible(1, 0);  
 Changing the Color of a Text Object 
 You can call the  agk::SetTextColor function to change the color and transparency of 
a text object. Here is the general format of how you call the function: 
 agk::SetTextColor( TextIndex, Red, Green, Blue, Alpha );  
 The first argument is the index number of the text object whose color you want to change. 
The next three arguments are for the red, green, and blue color channels. You pass a value 
from 0 to 255 for each of these arguments. A 0 means that the color channel will have no 
intensity and 255 means that the color channel will be displayed at full intensity. The final 
argument,   Alpha , is an optional argument that is set to 255 by default. If you want to 
specify a value for this argument, it must be an integer ranging from 0, which is completely 
transparent, to 255 which would draw the text object completely solid or opaque. For 
example, the following statement changes the color of a text object with an index number 
of 1 to the color yellow. It does not specify the optional   Alpha argument. 
 agk::SetTextColor(1, 255, 255, 0);  

 
9.1 Text Objects 
381
 Detecting Collisions with a Text Object 
 You can detect if a single point is within the bounds of a text object’s bounding box 
by using the  agk::GetTextHitTest function. Here is the general format of the function: 
 agk::GetTextHitTest( TextIndex, X, Y ) 
  TextIndex  is an integer value containing the index number of the text object you want 
to check for a collision. The remaining arguments,   X and   Y , are floating-point values 
for the  X- and  Y -coordinates of the point that you want to check. The function 
returns an integer value of 1 (true) if the point is within the text object’s bounding 
box. Otherwise, the function returns 0 (false). 
 Program 9-4 demonstrates detecting a collision between a text object and the 
mouse pointer. Figure 9-5 shows the program’s output. 
 Program 9-4 
 (Text Object Collision) 
 1 // This program demonstrates collision detection 
 2 // with a text object and the mouse pointer. 
 3  
 4 // Includes, namespace and prototypes 
 5 #include "template.h" 
 6 using namespace AGK; 
 7 app App; 
 8  
 9 // Constants for the screen resolution 
 10 const int SCREEN_WIDTH  = 640; 
 11 const int SCREEN_HEIGHT = 480; 
 12  
 13 // Constant for the text object index number. 
 14 const int TEXT = 1; 
 15  
 16 // Constant for the text object size. 
 17 const float TEXT_SIZE = 16; 
 18  
 19 // Constant for the text object alignment. 
 20 const int ALIGN_CENTER = 1; 
 21  
 22 // Constants for the center of the screen. 
 23 const float CENTER_X = SCREEN_WIDTH / 2; 
 24 const float CENTER_Y = SCREEN_HEIGHT / 2; 
 25  
 26 // Begin app, called once at the start 
 27 void app::Begin( void ) 
 28 { 
 29    // Set the virtual resolution. 
 30    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 31  
 32    // Set the window title. 
 33    agk::SetWindowTitle("Text Object Collision"); 
 34  
 35    // Create the text object. 
 36    agk::CreateText(TEXT, ""); 
 37  

382 
Chapter 9 
 Text, Collisions, and the Vulture Trouble Game
 38    // Set the size of the text object. 
 39    agk::SetTextSize(TEXT, TEXT_SIZE); 
 40  
 41    // Set the alignment of the text object. 
 42    agk::SetTextAlignment(TEXT, ALIGN_CENTER); 
 43  
 44    // Set the position of the text object. 
 45    agk::SetTextPosition(TEXT, CENTER_X, CENTER_Y); 
 46 } 
 47  
 48 // Main loop, called every frame 
 49 void app::Loop ( void ) 
 50 { 
 51    // Get the mouse coordinates. 
 52    float mouseX = agk::GetRawMouseX(); 
 53    float mouseY = agk::GetRawMouseY(); 
 54  
 55    // Determine if the mouse pointer has hit the text object. 
 56    if (agk::GetTextHitTest(TEXT, mouseX, mouseY)) 
 57    { 
 58       agk::SetTextString(TEXT, "Ouch! You hit me."); 
 59    } 
 60    else 
 61    { 
 62       agk::SetTextString(TEXT, "I am a text object."); 
 63    } 
 64  
 65    // Refresh the screen. 
 66    agk::Sync(); 
 67 } 
 68  
 69 // Called when the app ends 
 70 void app::End ( void ) 
 71 { 
 72 } 
 The following global constants are declared in lines 14 through 24: 
 ●  The  TEXT constant is declared in line 14 and initialized with the value 1. This is 
the constant we will use as the index number to identify the text object.  
 ●  Line 17 declares the floating-point constant  TEXT_SIZE initialized with the value 
16. This value will be used to set the size of the text object.  
 ●  Line 20 declares the  ALIGN_CENTER constant. This constant represents the value 
we will use to set the alignment of the text object to be center-aligned.  
 ●  Lines 23 and 24 declare the  CENTER_X and  CENTER_Y constants. These are float-
ing-point values for the  XY -coordinates of the center of the screen.  CENTER_X is 
initialized with half the value of  SCREEN_WIDTH .  CENTER_Y is initialized with half 
the value of  SCREEN_HEIGHT . We will use these constants to set the position of the 
text object to the center of the screen.  
 The  app::Begin function appears in lines 27 through 46: 
 ●  In line 36 we create the text object. Notice that the string value is an empty 
string. An empty string is being used as the initialization value of the text object 
because it will be changed when the program runs, so its value is not important.  

 
9.1 Text Objects 
383
 ●  In line 39 we set the size of the text object with the  TEXT_SIZE constant. 
 ●  In line 42 we set the alignment of the text object by using the  ALIGN_CENTER value.  
 ●  In line 45 we set the position of the text object by using the  CENTER_X and 
 CENTER_Y constants we declared earlier. This will center the text on the screen.  
 The  app::Loop function appears in lines 49 through 67: 
 ●  In lines 52 and 53 we declare two floating-point variables:  mouseX and  mouseY . 
The  mouseX variable in line 52 is initialized with the return value of the 
 agk::GetRawMouseX function. The  mouseY variable in line 53 is initialized with 
the return value of the  agk::GetRawMouseY function. These variables will be 
updated during each frame of the program’s game loop. During the game loop, 
the  mouseX and  mouseY variables will store the updated coordinates of the 
mouse pointer, which we will use as the point for the collision detection with 
the text object.  
 ●  In line 56 we have an  if statement that checks the return value of the 
 agk::GetTextHitTest function. If the function returns true, then we execute the 
statement in line 58, otherwise we execute the statement In line 62.  
 ●  In line 58 the  agk::SetTextString function is called. It changes the text object’s 
string to  “Ouch! You hit me.” 
 ●  In line 62 the  agk::SetTextString function is called. It sets the text object’s 
string to  “I am a text object.” 
 ●  In line 66 the  agk::Sync function is called. When this statement executes, it will 
update the screen and display any changes that were made.  
 Figure 9-5  Output of Program 9-4  
 Checkpoint 
 9.1.  What advantage does a text object have over the  agk::Print or  agk::PrintC 
functions when displaying text in a game or other application?  
 9.2.  How can you change the string displayed by a text object after it has been created?  
 9.3.  How can you determine if a text object exists?  
 9.4.  Is it possible to change the size of a text object? If so, how is it accomplished?  

384 
Chapter 9 
 Text, Collisions, and the Vulture Trouble Game
 NOTE:    A sprite’s bounding box will be the size, in pixels, of the sprite’s image file. 
For example, suppose you use Microsoft Paint to create an image file that is 64 
pixels wide by 96 pixels high. If a sprite uses this image, the sprite’s bounding box 
will be 64 pixels wide by 64 pixels high. 
 
 9.2  Sprite Collision Detection 
 CONCEPT:   A collision between sprites occurs when one sprite’s bounding box 
comes in contact with another sprite’s bounding box. Collisions 
between sprites can be detected.  
 When a sprite is displayed on the screen, it is displayed within a rectangle that is 
known as the sprite’s  bounding box . The bounding box is the size, in pixels, of the 
sprite’s image file. If the image file is saved with transparency, then the bounding 
box will not be visible, but if the image is created with a black background color as 
the transparency, then you can clearly see the bounding box. This is illustrated in 
 Figure   9-6 .  
 Figure 9-6  A sprite displayed inside its bounding box  
 9.5.  Briefly describe the effect on text spacing if a negative value is used.  
 9.6.  Consider a situation where you only need to move a text object left or right. 
What function could you use to do this?  
 9.7.  What function do you call to change the color of a text object?  
 9.8.   Is it possible to detect collisions with text objects? If so, what function do 
you call?  
 When one sprite’s bounding box comes in contact with another sprite’s bounding box, 
it is said that the two sprites have  collided . In games, sprite collisions are usually an 
important part of the game play. For this reason, it is important that you can detect 
collisions between sprites in your programs. 
VideoNote
Sprite Collision 
Detection

 
9.2 Sprite Collision Detection 
385
 The AGK provides a function called  agk::GetSpriteCollision that determines 
whether two sprites have collided. You pass two sprite index numbers as argu-
ments, and the function returns 1 (true) if the bounding boxes of the two sprites 
are overlapping or 0 (false) otherwise. The following code shows an example; it 
determines whether the sprite referenced by index number 1 and the sprite refer-
enced by index number 2 have collided, and if so, it hides both sprites: 
 if (agk::GetSpriteCollision(1, 2)) 
 { 
    agk::SetSpriteVisible(1, 0); 
    agk::SetSpriteVisible(2, 0); 
 } 
 Program 9-5 shows a complete example that detects sprite collisions. When the pro-
gram runs, it displays the two bowling ball sprites shown in  Figure   9-7 . The sprites 
move toward each other until a collision is detected. When that happens, they are 
reset back to their original positions. 
 Program 9-5 
 (Sprite Collision) 
 1 // This program demonstrates how sprite 
 2 // collisions can be detected. 
 3  
 4 // Includes, namespace and prototypes 
 5 #include "template.h" 
 6 using namespace AGK; 
 7 app App; 
 8  
 9 // Constants for the screen resolution 
 10 const int SCREEN_WIDTH  = 640; 
 11 const int SCREEN_HEIGHT = 480; 
 12  
 13 // Constant for the image index numbers. 
 14 const int BALL1_IMAGE = 1; 
 15 const int BALL2_IMAGE = 2; 
 16  
 17 // Constant for the sprite index numbers. 
 18 const int BALL1_SPRITE = 1; 
 19 const int BALL2_SPRITE = 2; 
 20  
 21 // Constant for ball 1's initial  X position. 
 22 const float BALL1_X = 0; 
 23  
 24 // Constant for ball 2's initial  Y position. 
 25 const float BALL2_X = 511; 
 26  
 27 // Constant for the  Y position of both sprites. 
 28 const float BALL_Y = 175; 
 29  
 30 // Constant for the distance to move each frame. 
 31 const float DISTANCE = 1; 
 32  

386 
Chapter 9 
 Text, Collisions, and the Vulture Trouble Game
 33 // Begin app, called once at the start 
 34 void app::Begin( void ) 
 35 { 
 36    // Set the virtual resolution. 
 37    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 38  
 39    // Set the window title. 
 40    agk::SetWindowTitle("Sprite Collision"); 
 41  
 42    // Load the images. 
 43    agk::LoadImage(BALL1_IMAGE, "BowlingBall1.png"); 
 44    agk::LoadImage(BALL2_IMAGE, "BowlingBall2.png"); 
 45  
 46    // Create the sprites. 
 47    agk::CreateSprite(BALL1_SPRITE, BALL1_IMAGE); 
 48    agk::CreateSprite(BALL2_SPRITE, BALL2_IMAGE); 
 49  
 50    // Set the position of each sprite. 
 51    agk::SetSpritePosition(BALL1_SPRITE, BALL1_X, BALL_Y); 
 52    agk::SetSpritePosition(BALL2_SPRITE, BALL2_X, BALL_Y); 
 53 } 
 54  
 55 // Main loop, called every frame 
 56 void app::Loop ( void ) 
 57 { 
 58    // Get the  X -coordinate of each sprite. 
 59    float ball1x = agk::GetSpriteX(BALL1_SPRITE); 
 60    float ball2x = agk::GetSpriteX(BALL2_SPRITE); 
 61  
 62    // Determine if the two sprites have collided. 
 63    if (agk::GetSpriteCollision(BALL1_SPRITE, BALL2_SPRITE)) 
 64    { 
 65       // Reset the sprites to their original locations. 
 66       agk::SetSpriteX(BALL1_SPRITE, BALL1_X); 
 67       agk::SetSpriteX(BALL2_SPRITE, BALL2_X); 
 68    } 
 69    else 
 70    { 
 71       // Move ball 1 to the right. 
 72       agk::SetSpriteX(BALL1_SPRITE, ball1x + DISTANCE); 
 73  
 74       // Move ball 2 to the left. 
 75       agk::SetSpriteX(BALL2_SPRITE, ball2x - DISTANCE); 
 76    } 
 77  
 78    // Refresh the screen. 
 79    agk::Sync(); 
 80 } 
 81  
 82 // Called when the app ends 
 83 void app::End ( void ) 
 84 { 
 85 } 

 
9.2 Sprite Collision Detection 
387
 Figure 9-7  Sprites displayed by Program 9-5  
 The following global constants are declared in lines 14 through 31: 
 ●  Lines 14 through 19 declare constants for the bowling ball image index numbers 
and sprite index numbers.  
 ●  Lines 22 and 25 declare constants for ball 1’s initial  X -coordinate and ball 2’s 
initial  X- coordinate. Line 28 declares a constant that will be used for both balls’ 
 Y -coordinates.  
 ●  Line 31 declares a constant for the distance that each ball will move during an 
iteration of the game loop.  
 The  app::Begin function appears in lines 34 through 53: 
 ●  In lines 43 and 44 we load the image that will be used by the sprites.  
 ●  In lines 47 and 48 we create the sprites that will display the bowling ball images.  
 ●  In lines 51 and 52 we set the position of each sprite to the default location.  
 The  app::Loop function appears in lines 56 through 80: 
 ●  Lines 59 and 60 declare variables to store the  X -coordinate of ball 1 and ball 2.  
 ●  In line 63 we use an  if statement to determine if ball 1 has collided with ball 2.  
 ●  If a collision occurs, the code in lines 66 and 67 will reset the balls to their de-
fault  X- coordinates.  
 ●  Line 72 moves ball 1 to the right by adding the value of the  DISTANCE constant 
to the value of its  X -coordinate. 
 ●  Line 75 moves ball 2 to the left by subtracting the value of the  DISTANCE constant 
from the value of its  X- coordinate.  
 ●  Line 79 calls the  agk::Sync function to refresh the screen.  

388 
Chapter 9 
 Text, Collisions, and the Vulture Trouble Game
 In the Spotlight: 
 The PizzaBot Game 
 Program 9-6 is called PizzaBot because the main character is a pizza-eating robot! 
 Figure  9-8 shows the texture atlas that we will use to create an animated sprite for the 
robot. The image is saved in a file named  Robot.png . Notice that the texture atlas has 
one row and three columns. 
 When the program runs, the robot will appear in the lower-right corner of the screen. 
The slice of pizza shown on the left in  Figure   9-9 will also appear, in a random loca-
tion. This image is saved in a file named  Pizza.png . The object of the game is to use 
the arrow keys to move the robot to the slice of pizza. When the robot collides with 
the slice of pizza, the Yum! image shown on the right in  Figure   9-9 will appear in 
place of the pizza. It is saved in a file named  Yum.png . 
 Program 9-6 
 (PizzaBot) 
  1 // This program lets the user chase randomly generated 
  2 // pizza slices with a robot. It demonstrates collision 
  3 // detection with sprites. 
  4  
  5 // Includes, namespace and prototypes 
  6 #include "template.h" 
  7 using namespace AGK; 
  8 app App; 
  9  
 10 // Constants for the screen resolution 
 11 const int SCREEN_WIDTH  = 640; 
 12 const int SCREEN_HEIGHT = 480; 
 13  
 14 // Constants for images 
 15 const int ROBOT_IMAGE = 1; 
 16 const int PIZZA_IMAGE = 2; 
 17 const int YUM_IMAGE   = 3; 
 18  
 19 // Constants for sprites 
 20 const int ROBOT_SPRITE = 1; 
 21 const int PIZZA_SPRITE = 2; 
 22 const int YUM_SPRITE   = 3; 
 23  
 24 // Constants for animation 
 25 const int FRAME_WIDTH   = 128; 
 26 const int FRAME_HEIGHT  = 128; 
 27 const int FRAME_COUNT   = 3; 
 28 const float FRAMES_PER_SECOND = 3; 
 29  
 30 // Constant for the amount to move the robot 
 31 const float ROBOT_MOVE = 4; 
 32  
 33 // Constants for the robot's initial  XY values. 
 34 const float ROBOT_X = 0; 

 
9.2 Sprite Collision Detection 
389
 35 const float ROBOT_Y = SCREEN_HEIGHT - FRAME_HEIGHT; 
 36  
 37 // Constant for the sleep time. 
 38 const int HALF_SECOND = 500; 
 39  
 40 // Constants for showing and hiding sprites. 
 41 const int HIDE = 0; 
 42 const int SHOW = 1; 
 43  
 44 // Function prototypes 
 45 void updateRobot(); 
 46 void detectCollision(); 
 47 void showYum(); 
 48 void generatePizza(); 
 49  
 50 // Begin app, called once at the start 
 51 void app::Begin( void ) 
 52 { 
 53    // Set the virtual resolution. 
 54    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 55  
 56    // Set the window title. 
 57    agk::SetWindowTitle("PizzaBot"); 
 58  
 59    // Load the Images. 
 60    agk::LoadImage(ROBOT_IMAGE, "PizzaBot/Robot.png"); 
 61    agk::LoadImage(PIZZA_IMAGE, "PizzaBot/Pizza.png"); 
 62    agk::LoadImage(YUM_IMAGE, "PizzaBot/Yum.png"); 
 63  
 64    // Create the sprites. 
 65    agk::CreateSprite(ROBOT_SPRITE, ROBOT_IMAGE); 
 66    agk::CreateSprite(PIZZA_SPRITE, PIZZA_IMAGE); 
 67    agk::CreateSprite(YUM_SPRITE, YUM_IMAGE); 
 68  
 69    // Set the sprite animation sequence for the robot. 
 70    agk::SetSpriteAnimation(ROBOT_SPRITE, FRAME_WIDTH, 
 71                          FRAME_HEIGHT, FRAME_COUNT); 
 72  
 73    // Set the position of the robot sprite. 
 74    agk::SetSpritePosition(ROBOT_SPRITE, ROBOT_X, ROBOT_Y); 
 75  
 76    // Play the robot sprite animation. 
 77    agk::PlaySprite(ROBOT_SPRITE, FRAMES_PER_SECOND); 
 78  
 79    // Generate a slice of pizza. 
 80    generatePizza(); 
 81 } 
 82  
 83 // Main loop, called every frame 
 84 void app::Loop ( void ) 
 85 { 
 86    // Update the robot's position. 
 87    updateRobot(); 
 88  

390 
Chapter 9 
 Text, Collisions, and the Vulture Trouble Game
 89    // Check for a collision between 
 90    // the robot and the pizza. 
 91    detectcollision(); 
 92  
 93    // Refresh the screen. 
 94    agk::Sync(); 
 95 } 
 96  
 97 // Called when the app ends 
 98 void app::End ( void ) 
 99 { 
 100 } 
 101  
 102 // The update function moves the robot if the user 
 103 // is pressing an arrow key. 
 104 void updateRobot() 
 105 { 
 106    // Store the robot's  X -and  Y -coordinates. 
 107    float robotX = agk::GetSpriteX(ROBOT_SPRITE); 
 108    float robotY = agk::GetSpriteY(ROBOT_SPRITE); 
 109  
 110    // Determine if the user is pressing the down arrow key, 
 111    // and if so move the robot down. 
 112    if (agk::GetRawKeyState(AGK_KEY_DOWN)) 
 113       robotY += ROBOT_MOVE; 
 114  
 115    // Determine if the user is pressing the up arrow key, 
 116    // and if so, move the robot up. 
 117    if (agk::GetRawKeyState(AGK_KEY_UP)) 
 118       robotY -= ROBOT_MOVE; 
 119  
 120    // Determine if the user is pressing the left arrow key, 
 121    // and if so, move the robot left. 
 122    if (agk::GetRawKeyState(AGK_KEY_LEFT)) 
 123       robotX -= ROBOT_MOVE; 
 124  
 125    // Determine if the user is pressing the right arrow key, 
 126    // and if so, move the robot up. 
 127    if (agk::GetRawKeyState(AGK_KEY_RIGHT)) 
 128       robotX += ROBOT_MOVE; 
 129  
 130    // Update the robot's position. 
 131    agk::SetSpritePosition(ROBOT_SPRITE, robotX, robotY); 
 132 } 
 133  
 134 // The generatePizza function generates a new slice of 
 135 // pizza at a random location. 
 136 void generatePizza() 
 137 { 
 138    // Store the width and height of the pizza sprite. 
 139    float width = agk::GetSpriteWidth(PIZZA_SPRITE); 
 140    float height = agk::GetSpriteHeight(PIZZA_SPRITE); 
 141  

 
9.2 Sprite Collision Detection 
391
 142    // Calculate the maximum  XY values for the 
 143    // random position of the pizza sprite. 
 144    float maxX = SCREEN_WIDTH - width; 
 145    float maxY = SCREEN_HEIGHT - height; 
 146  
 147    // Generate and store the random  XY - 
 148    // coordinates of the pizza. 
 149    float x = (float)(agk::Random(0, (int)maxX)); 
 150    float y = (float)(agk::Random(0, (int)maxY)); 
 151  
 152    // Hide the Yum! sprite. 
 153    agk::SetSpriteVisible(YUM_SPRITE, HIDE); 
 154  
 155    // Set the new position of the pizza and Yum! sprites. 
 156    agk::SetSpritePosition(PIZZA_SPRITE, x, y); 
 157    agk::SetSpritePosition(YUM_SPRITE, x, y); 
 158  
 159    // Show the pizza sprite. 
 160    agk::SetSpriteVisible(PIZZA_SPRITE, SHOW); 
 161 } 
 162  
 163 // The showYum function momentarily displays the Yum! 
 164 // sprite in place of the pizza sprite. 
 165 void showYum() 
 166 { 
 167    // Hide the pizza sprite. 
 168    agk::SetSpriteVisible(PIZZA_SPRITE, HIDE); 
 169  
 170    // Show the Yum! sprite. 
 171    agk::SetSpriteVisible(YUM_SPRITE, SHOW); 
 172  
 173    // Refresh the screen, so we can see the changes. 
 174    agk::Sync(); 
 175  
 176    // Wait for half a second. 
 177    agk::Sleep(HALF_SECOND); 
 178 } 
 179  
 180 // The detectCollision function determines whether the 
 181 // robot has collided with the pizza. If so, a new slice 
 182 // of pizza is generated. 
 183 void detectCollision() 
 184 { 
 185    // Determine if the robot has collided with the pizza. 
 186    if (agk::GetSpriteCollision(ROBOT_SPRITE, PIZZA_SPRITE)) 
 187    { 
 188       // Hide the pizza and show the Yum! sprite. 
 189       showYum(); 
 190  
 191       // Hide the Yum! sprite and show the pizza. 
 192       generatePizza(); 
 193    } 
 194 }  

392 
Chapter 9 
 Text, Collisions, and the Vulture Trouble Game
 The sprite displaying the Yum! image will appear only briefly, and then disappear. 
After that, another slice of pizza will be randomly placed on the screen. 
 Let’s review each part of the program. 
 Global Constants 
 Several global constants are declared in lines 11 through 42, summarized here: 
 •  Lines 11 and 12 declare  SCREEN_WIDTH and  SCREEN_HEIGHT to represent the vir-
tual resolution of the screen.  
 •  Lines 15 through 17 declare  ROBOT_IMAGE ,  PIZZA_IMAGE , and  YUM_IMAGE to repre-
sent the robot, pizza, and Yum! image index numbers.  
 •  Lines 20 through 22 declare  ROBOT_SPRITE ,  PIZZA_SPRITE , and  YUM_SPRITE to 
represent the robot, pizza, and Yum! sprite index numbers.  
 •  Lines 25 through 28 declare  FRAME_WIDTH ,  FRAME_HEIGHT ,  FRAME_COUNT , and 
 FRAMES_PER_SECOND to represent the animation values of the robot texture atlas.  
 •  Line 31 declares  ROBOT_MOVE , which holds the amount by which the robot will 
move when the user presses an arrow key.  
 •  Lines 34 and 35 declare  ROBOT_X and  ROBOT_Y to represent the robot’s starting  X 
and  Y screen coordinates.  
 •  Line 38 declares  HALF_SECOND , which represents the number of milliseconds the 
application will sleep after displaying the Yum! sprite.  
 •  Lines 41 and 42 declare  HIDE  and  SHOW , which represent the values used to hide 
and show the pizza and Yum! sprites.  
 The  app::Begin Function 
 The  app::Begin function is defined in lines 51 through 81. It sets the virtual resolu-
tion in line 54. The window title is set in line 57. In lines 60 through 62, we load 
the robot, pizza, and Yum! images. In lines 65 through 67, we create the robot, 
pizza, and Yum! sprites. The animation is set for the robot sprite in lines 70 and 
71. In line 74, we set the position of the robot sprite to the bottom-left portion of 
the screen. In line 77, we play the robot sprite’s animation. Finally, in line 80, we 
call the  generatePizza function.  
 The  app::Loop Function 
 The  app::Loop function is defined in lines 84 through 95. It calls the  updateRobot 
function in line 87. This function determines whether an arrow key has been pressed 
and, if so, updates the robot’s position accordingly. Then, we call the  detectCollision 
function in line 91. This function determines whether the robot has collided with the 
 Figure 9-8  Robot texture atlas  
 Figure 9-9  The pizza and Yum! images  

 
9.2 Sprite Collision Detection 
393
pizza. If so, it displays the Yum! sprite for a brief instant and then generates a new 
slice of pizza at a random location. Line 94 calls the  agk::Sync function to refresh 
the screen.  
 The  updateRobot Function 
 The updateRobot function is defined in lines 104 through 132. Its purpose is to 
determine whether the user is pressing an arrow key and update the robot’s position 
accordingly. The statements in lines 107 and 108 get the robot sprite’s current  X and 
 Y screen coordinates and assigns those values to the  robotX and  robotY variables. 
 The  if statements that appear in lines 112 through 128 check each of the keyboard’s 
arrow keys. If any of them are being pressed, the  robotX and  robotY variables are 
adjusted accordingly. 
 The  agk::SetSpritePosition function is called in line 131. This function sets the 
robot’s new position using the  robotX and  robotY variables. 
 The  generatePizza Function 
 The  generatePizza function is defined in lines 136 through 161. Its purpose is to 
display the pizza sprite at a random location on the screen. Lines 139 and 140 get 
the width and height of the pizza sprite and assign those values to the local  width and 
 height variables. Lines 144 and 145 calculate the maximum  X- and  Y -coordinates 
that we can use, to make sure the pizza sprite doesn’t get placed somewhere off-
screen, and assign those values to the local  maxX and  maxY variables. Then, lines 149 
and 150 generate random values for the local variables  x and  y . Line 153 hides the 
Yum! sprite (by setting its visibility using the  HIDE constant). The local  x and  y values 
are used to set the new position of the pizza and Yum! sprites in lines 156 and 157. 
Line 160 shows the pizza sprite (by setting its visibility using the  SHOW constant).  
 The  showYum Function 
 The  showYum function is defined in lines 165 through 178. Its purpose is to display the 
Yum! sprite in place of the pizza sprite. (This occurs when the robot collides with the 
pizza.) Line 168 hides the pizza sprite. Line 171 shows the Yum! sprite. Line 174 imme-
diately refreshes the screen by calling the  agk::Sync function. This line of code is impor-
tant because if we wait until the screen is refreshed in the  app::Loop function (in line 
94), the changes will not show. In line 177 we call the  agk::Sleep function passing the 
 HALF_SECOND constant we defined earlier as an argument. This will pause the program’s 
execution for half of a second, allowing the Yum! sprite to be shown for a brief instant. 
The Yum! sprite will be hidden when the  generatePizza function is called (in line 192).  
 The  detectCollision Function 
 The  detectCollision function is defined in lines 183 through 194. Its purpose is to 
determine whether the robot sprite has collided with the pizza sprite. The  if state-
ment in line 186 calls the  agk::GetSpriteCollision function to make this determina-
tion. If the sprites have collided, the  showYum function is called (line 189) to display 
the Yum! sprite, and then the  generatePizza function is called in line 192 to show 
the pizza sprite at a new location.  

394 
Chapter 9 
 Text, Collisions, and the Vulture Trouble Game
 NOTE:    If you’re thinking, “Wait a minute, I didn’t sign up to learn physics. I want to 
learn programming!”—then relax. You don’t need to master physics to program real-
istic motion. Understanding a little about the physics of gravity and free fall, however, 
will go a long way toward helping you understand the code that we will write later. 
 Checkpoint 
 9.9.  What is a sprite’s bounding box?  
 9.10.   What constitutes a sprite collision?  
 9.11.   How do you detect a collision between two sprites?  
 
 9.3  Simulating Falling Objects 
 CONCEPT:   When an object in the real world falls to Earth, its speed increases as 
it falls. If you want to write a program that realistically simulates fall-
ing objects, you will need to incorporate this acceleration into your 
program.  
 Game programmers often need to simulate moving objects, and in many cases the 
objects must move realistically. For example, suppose you are writing a program that 
shows an object falling toward the ground. You could design a loop that merely 
moves the object down the screen’s  Y -axis the same amount each time the loop iter-
ates. The resulting animation would not be realistic, however, because in the world, 
objects do not fall at a steady speed. 
 Designing programs that simulate realistic motion requires some knowledge of simple 
physics. In this section, we will discuss the motion of an object that is falling toward 
Earth because of gravity. Then we will look at how that motion can be reasonably 
simulated in a computer program.  
 Gravity is a force that attracts objects to one another. The more massive the objects 
are, the greater the gravitational attraction between them. For example, Earth is so 
massive that its gravitational pull keeps us from floating off into space. When an apple 
falls from a tree, it falls because it is attracted to Earth by gravity. 
 If you watch an object fall from a considerable height, such as the top of a building, 
you will notice that the object’s speed increases as it falls. The object’s increase in 
speed is known as  acceleration . When an object falls in a vacuum (where there are no 
air molecules to slow it down), its speed increases at a rate of 9.8 meters per second, 
 each second . Did you get that? For each second that an object falls, its speed increases 
by an additional 9.8 meters per second. 
 For example, suppose a construction worker is building a skyscraper, and he acci-
dently drops a brick from the top of the building. If we forget about the fact that the 
VideoNote
Simulating 
Falling Objects

 
9.3 Simulating Falling Objects 
395
air will slow the brick down a small amount, we can calculate how fast the brick will 
be traveling each second as it plummets to the ground: 
 ●  At one second the brick is falling at a speed of 9.8 meters per second.  
 ●  At two seconds the brick is falling at a speed of 19.6 meters per second.  
 ●  At three seconds the brick is falling at a speed of 29.4 meters per second.  
 ●  At four seconds the brick is falling at a speed of 39.2 meters per second.  
 ●  And so forth.  
 This is illustrated in  Figure   9-10 . 
 Figure 9-10  Speed of a falling brick at various time intervals (not drawn to scale)  
 If this is interesting enough to make you want to read a physics book, you will see the 
acceleration rate of a falling object written as 9.8 m/s 2 (which is pronounced “9.8 meters 
per second squared”). The letter  g is commonly used to represent the acceleration rate 
of a falling object in formulas. 
 Now let’s talk about the distance that an object falls over time. When an object is 
moving, two factors determine the distance the object moves: the object’s speed and 
the amount of time the object is moving. For example, a ball that is moving at a con-
stant speed of 12 meters per second will travel a distance of 24 meters in two seconds. 
By constant speed, we mean that the ball is not speeding up or slowing down; it is 

396 
Chapter 9 
 Text, Collisions, and the Vulture Trouble Game
moving steadily at 12 meters per second. However, a falling object does not move at 
a constant speed. A falling object speeds up as it falls. As a result, a falling object 
travels downward an increasingly greater distance each second that it falls. We can 
use the following formula to calculate the distance that a falling object falls: 
 d = ½gt2 
 In this formula,  d is the distance,  g is 9.8, and  t is the number of seconds that the 
object has been falling. Going back to the brick example, we can use the formula to 
calculate the following distances: 
 ●  At one second the brick is falling at a speed of 4.9 meters.  
 ●  At two seconds the brick is falling at a speed of 19.6 meters.  
 ●  At three seconds the brick is falling at a speed of 44.1 meters.  
 ●  At four seconds the brick is falling at a speed of 78.4 meters.  
 ●  And so forth.  
 This is illustrated in  Figure  9-11  . 
 Figure 9-11  A falling brick’s distance at various time intervals (not drawn to scale)  

 
9.3 Simulating Falling Objects 
397
 So how do you simulate the behavior of falling objects in a program? After all, a 
computer screen is measured in pixels, not meters. Because of this, the formula for 
calculating the distance that a falling object moves on the screen will have to be 
“tweaked.” 
 First, you have to decide how accurate the simulation must be. If your program will 
be used for scientific research, it will need to be accurate. If you are creating a game, 
however, accuracy is probably not essential. That’s the case with the Vulture Trouble 
game that is presented later in this chapter. We want to display eggs that are falling 
realistically, but also we want the falling motion to work for the game and the game 
player. If the eggs fall too fast, then the player might get frustrated because the game 
is too difficult. Likewise, if the eggs fall too slowly, then the game will not be chal-
lenging enough. 
 Program 9-7 shows how we can approximate the motion of a falling object, at a 
speed that is slow enough to easily observe, yet fast enough to seem realistic. When 
the program runs, it displays the ball sprite shown in  Figure  9-12  falling from the 
top of the screen to the bottom. To achieve the falling motion, we have used the 
value 0.98 as the gravitational acceleration and the default screen refresh rate of 60 
frames per second. 
 Program 9-7 
 (Free Fall) 
 1 // This program simulates a falling ball. 
 2  
 3 // Includes, namespace and prototypes 
 4 #include "template.h" 
 5 using namespace AGK; 
 6 app App; 
 7  
 8 // Global Constants 
 9 const int SCREEN_WIDTH   = 640; 
 10 const int SCREEN_HEIGHT  = 480; 
 11 const int BALL_IMAGE     = 1; 
 12 const int BALL_SPRITE    = 1; 
 13 const float ACCELERATION = 0.98; 
 14  
 15 // Global variables 
 16 float g_time     = 0; 
 17 float g_distance = 0; 
 18  
 19 // Begin app, called once at the start 
 20 void app::Begin( void ) 
 21 { 
 22    // Set the virtual resolution. 
 23    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 24  
 25    // Set the window title. 
 26    agk::SetWindowTitle("Free Fall"); 
 27  
 28    // Load the ball image. 
 29    agk::LoadImage(BALL_IMAGE, "ball.png"); 
 30  

398 
Chapter 9 
 Text, Collisions, and the Vulture Trouble Game
 31    // Create the ball sprite. 
 32    agk::CreateSprite(BALL_SPRITE, BALL_IMAGE); 
 33  
 34    // Set the starting position of the ball sprite. 
 35    agk::SetSpriteX(BALL_SPRITE, SCREEN_WIDTH / 2 - 
 36         agk::GetSpriteWidth(BALL_SPRITE) / 2); 
 37 } 
 38  
 39 // Main loop, called every frame 
 40 void app::Loop ( void ) 
 41 { 
 42    // Get the Y-coordinate of the ball sprite. 
 43    float y = agk::GetSpriteY(BALL_SPRITE); 
 44  
 45    // If the ball is above the bottom of the screen, 
 46    // then update its position. 
 47    if (y < SCREEN_HEIGHT - agk::GetSpriteHeight(BALL_SPRITE)) 
 48    { 
 49       // Calculate the object's distance using the 
 50       // distance formula. 
 51       g_distance = 0.5 * ACCELERATION * g_time * g_time; 
 52  
 53       // Set the  Y -coordinate of the ball sprite to 
 54       // the distance. 
 55       y = g_distance; 
 56  
 57       // Increment time. 
 58       g_time++; 
 59    } 
 60    // Else, set the  Y -coordinate of the ball sprite at 
 61    // the bottom of the screen. 
 62    else 
 63    { 
 64       y = SCREEN_HEIGHT - agk::GetSpriteHeight(BALL_SPRITE); 
 65    } 
 66  
 67    // Update the  Y -coordinate of the ball sprite. 
 68    agk::SetSpriteY(BALL_SPRITE, y); 
 69  
 70    // Refresh the screen. 
 71    agk::Sync(); 
 72 } 
 73  
 74 // Called when the app ends 
 75 void app::End ( void ) 
 76 { 
 77 } 
 The following global constants are declared in lines 9 through 13: 
 ●  The  SCREEN_WIDTH and  SCREEN_HEIGHT constants are declared in lines 9 and 10. 
These constants are used to set the virtual resolution of the screen.  
 ●  Line 11 declares the  BALL_IMAGE constant. This constant represents the index 
number we will use to reference the ball image.  

 
9.3 Simulating Falling Objects 
399
 ●  Line 12 declares the BALL_SPRITE constant. This constant represents the index 
number we will use to reference the ball sprite.  
 ●  Line 13 declares the floating-point  ACCELERATION constant, initialized with the 
value 0.98. We will use this value for gravitational acceleration. If you’re won-
dering how we decided to use the value 0.98, we used the trial-and-error method. 
When we tried the value 9.8, it produced motion that was so fast the ball could 
barely be seen. So, we knew that we needed to scale down the acceleration value. 
Next, we tried the value 0.98, and we were happy with the results.  
 The following global variables are declared in lines 16 and 17: 
 ●  Line 16 declares the  g_time global variable, initialized with the value 0. This 
variable will keep a count of the game loop’s iterations. We will use it as the time 
value in the distance calculation.  
 ●  Line 17 declares the  g_distance global variable, initialized with the value 0. This 
variable will hold the distance that the ball sprite falls during each iteration of 
the game loop.  
 The  app::Begin function appears in lines 20 through 37: 
 ●  In line 23 we set the virtual resolution using the  SCREEN_WIDTH and  SCREEN_HEIGHT 
constants.  
 ●  In line 26 we set the window title so that when the program runs, it displays the 
string “Free Fall” in the window’s title bar.  
 ●  In line 29 we load the  ball.png image, using the  BALL_IMAGE constant as the 
image index number.  
 ●  In line 32 we create the ball sprite, using the  BALL_SPRITE constant as the sprite 
index number and the  BALL_IMAGE constant for the image index number.  
 Figure 9-12  Ball sprite from Program 9-7  

400 
Chapter 9 
 Text, Collisions, and the Vulture Trouble Game
 ●  In lines 35 through 36 we set the ball sprite to its starting position. In 
this program, we want the ball to start at the top of the screen and to be 
centered along the  X -axis. Because the  Y -coordinate is already set to 0 by 
default, we only need to set the  X -coordinate. The expression  SCREEN_WIDTH / 2 − 
agk::GetSpriteWidth(BALL_SPRITE) / 2 calculates the center of the screen 
along the  X -axis and then subtracts half the width of the ball sprite. This will 
position the ball exactly where we want it to be when the program starts.  
 The  app::Loop function appears in lines 40 through 72: 
 ●  In line 43, we declare a local floating-point variable named  y . The  y variable will 
update as the loop iterates, storing the most recent value for the ball sprite’s  Y -
coordinate.  
 ●  The  if statement in line 47 determines whether the ball sprite’s  Y -coordinate is less 
than the expression  SCREEN_HEIGHT − agk::GetSpriteHeight(BALL_SPRITE) . This 
expression calculates the bottom edge of the screen minus the height of the ball 
sprite. If the expression is true, then the ball sprite is above the bottom of the 
screen, and the ball will continue to fall. In that case, line 51 uses the distance 
formula you saw earlier to calculate the distance that ball has fallen down 
the screen. Then, line 55 sets the  y variable to this distance. Line 58 incre-
ments the  time variable.  
 ●  The  else clause in line 62 handles things if the ball has reached the bottom of 
the screen. If that is the case, the  y variable is set to the expression  SCREEN_HEIGHT − 
agk::GetSpriteHeight(BALL_SPRITE) . This makes the ball stop falling, and the 
ball remains at the bottom of the screen.  
 ●  The  agk::Sync function appears in line 71 and refreshes the screen once for each 
iteration of the game loop.  
 Simulating Motion in Two Directions 
 In the previous example, we simulated a ball that was moving in one direction: straight 
down. But what about situations in which an object is moving in two directions si-
multaneously? For example, when a baseball pitcher throws the ball toward the 
catcher, the baseball is moving in two directions simultaneously: 
 ●  It is moving horizontally, toward the catcher, because the pitcher threw it in that 
direction.  
 ●  It is moving vertically, toward the ground, because gravity is pulling it down.  
 To simulate this type of motion, we need to update the falling object’s position along 
both the  X- and  Y -axes. Program 9-8 shows an example. 
 Program 9-8 
 (Dual Motion) 
 1 // This program simulates a ball that is falling 
 2 // and moving horizontally. 
 3  
 4 // Includes, namespace and prototypes 
 5 #include "template.h" 
 6 using namespace AGK; 
 7 app App; 

 
9.3 Simulating Falling Objects 
401
 8  
 9 // Constants 
 10 const int SCREEN_WIDTH   = 640; 
 11 const int SCREEN_HEIGHT  = 480; 
 12 const int BALL_IMAGE     = 1; 
 13 const int BALL_SPRITE    = 1; 
 14 const float X_MOVEMENT   = 10.0; 
 15 const float ACCELERATION = 0.98; 
 16  
 17 // Global variables 
 18 float g_time     = 0; 
 19 float g_distance = 0; 
 20  
 21 // Begin app, called once at the start 
 22 void app::Begin( void ) 
 23 { 
 24    // Set the virtual resolution. 
 25    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 26  
 27    // Set the window title. 
 28    agk::SetWindowTitle("Dual Motion"); 
 29  
 30    // Load the ball image. 
 31    agk::LoadImage(BALL_IMAGE, "ball.png"); 
 32  
 33    // Create the ball sprite. 
 34    agk::CreateSprite(BALL_SPRITE, BALL_IMAGE); 
 35  
 36    // Set the starting position of the ball sprite. 
 37    agk::SetSpriteX(BALL_SPRITE, SCREEN_WIDTH - 
 38         agk::GetSpriteWidth(BALL_SPRITE)); 
 39 } 
 40  
 41 // Main loop, called every frame 
 42 void app::Loop ( void ) 
 43 { 
 44    // Get the  XY -coordinates of the ball sprite. 
 45    float y = agk::GetSpriteY(BALL_SPRITE); 
 46    float x = agk::GetSpriteX(BALL_SPRITE); 
 47  
 48    // If the ball is above the bottom of the screen, 
 49    // then update its position. 
 50    if (y < SCREEN_HEIGHT - agk::GetSpriteHeight(BALL_SPRITE)) 
 51    { 
 52  
 53       // Set the  X -coordinate of the ball sprite so 
 54       // that it will move to the left. 
 55       x -= X_MOVEMENT; 
 56  
 57       // Calculate the object's distance using the 
 58       // distance formula. 
 59       g_distance = 0.5 * ACCELERATION * g_time * g_time; 
 60  
 61       // Set the  Y -coordinate of the ball sprite to 
 62       // the distance. 
 63       y = g_distance; 

402 
Chapter 9 
 Text, Collisions, and the Vulture Trouble Game
 64  
 65       // Increment time. 
 66       g_time++; 
 67    } 
 68    // Else, set the  Y -coordinate of the ball sprite at 
 69    // the bottom of the screen. 
 70    else 
 71    { 
 72       y = SCREEN_HEIGHT - agk::GetSpriteHeight(BALL_SPRITE); 
 73    } 
 74  
 75    // Update the  XY -coordinates of the ball sprite. 
 76    agk::SetSpritePosition(BALL_SPRITE, x, y); 
 77  
 78    // Refresh the screen. 
 79    agk::Sync(); 
 80 } 
 81  
 82 // Called when the app ends 
 83 void app::End ( void ) 
 84 { 
 85 } 
 In this program, a ball is initially positioned in the upper-right corner of the screen. 
As the ball accelerates toward the bottom of the screen, it also moves to the left along 
the  X -axis at a constant speed. The resulting animation looks like the ball was not 
merely dropped, but also given a slight kick toward the left side of the screen. In 
 Figure   9-13 we have captured four different frames from the program’s output and 
superimposed them so you can see the ball’s path as it falls.  
 Figure 9-13  Four frames captured from Program 9-8’s output  

 
9.4 The Vulture Trouble Game 
403
 This program’s code is very similar to Program 9-7. We have declared a constant 
named  X_MOVEMENT , initialized with the value 10. This is the distance that the ball will 
move along the  X -axis each time the loop iterates. 
 Inside the game loop we subtract the value of the  X_MOVEMENT constant from the  x 
variable in line 55, and we assign the value of the  distance variable to the  y variable 
in line 63. As a result, the ball moves to the left 10 pixels and accelerates down toward 
the bottom of the screen each time the game loop iterates.  
 Checkpoint 
 9.12.  When gravity causes an object to fall in a vacuum toward Earth, does the ob-
ject fall at a steady speed, or does its speed increase as it falls?  
 9.13.  If gravity is causing an object to fall in a vacuum toward Earth, how far will 
the object have fallen after 10 seconds?  
 NOTE:   If you have downloaded  the book’s  sample programs from   www.
pearsonhighered.com/gaddis  , you will find an additional program named  DropTheBall 
that provides a more in-depth example of horizontal and vertical motion. 
 
 9.4  The Vulture Trouble Game 
 In this section, we will demonstrate the Vulture Trouble game. In the game, a greedy 
vulture has stolen eggs from a farmer’s henhouse. The vulture realizes he’s been caught 
and is dropping the eggs one by one. The player’s objective is to use a basket to catch as 
many eggs as possible. If the player does not catch an egg, it hits the ground and breaks. 
 The top screen shown in  Figure   9-14 shows the game’s title screen, which is displayed 
when the program starts. The bottom screen is the introductory screen that is dis-
played after the user presses the Enter key. The introductory screen gives the user 
instructions for playing the game. The top screen shown in  Figure   9-15  shows the 
game’s main screen, which appears next. The vulture is an animated sprite that moves 
back and forth across the screen. The egg that is dropped from the vulture, as well as 
the basket that appears at the bottom of the screen, are also sprites. The player uses 
the left and right arrow keys to move the basket sprite and, hopefully, catch the eggs 
as they fall. The vulture has stolen a total of 40 eggs. 
 When the game begins, a row of 40 mini-eggs appears across the top of the screen. This 
serves as an indicator of the number of eggs left. Each time the vulture drops an egg, 
one of the mini-eggs is removed from the top of the screen. The program keeps count 
of the number of eggs that the player catches, as well as the number of broken eggs. 
After the last egg has been dropped, a summary screen like the one shown at the bot-
tom of  Figure   9-15  appears. 
 Figure   9-16  shows all the images that we will use in the game. Here is a summary of each: 
 ●  The  farm.png image will serve as the background for the game.  
 ●  The  vulture.png image contains the texture atlas we will use to create an ani-
mated sprite for the flying vulture.  

404 
Chapter 9 
 Text, Collisions, and the Vulture Trouble Game
 ●  The  egg.png image shows an egg.  
 ●  The  basket.png image shows the basket that the player will use to catch eggs.  
 ●  The  hitBasket.png image will be displayed briefly when an egg hits the 
basket.  
 ●  The  brokenEgg.png image will be displayed briefly when an egg hits the ground.  
 Figure 9-14  Vulture Trouble title screen and introductory screen  

 
9.4 The Vulture Trouble Game 
405
 Figure 9-15  Vulture Trouble main screen and summary screen  
 Now let’s look at the game’s code in Program 9-9. Rather than presenting all the code 
at once, we will show a section at a time, discussing each part. The first part of the 
program shows the global constant declarations and global variables. 

406 
Chapter 9 
 Text, Collisions, and the Vulture Trouble Game
 Program 9-9 
  (VultureTrouble, partial listing) 
 1 // This program demonstrates the Vulture Trouble Game. 
 2  
 3 // Includes, namespace and prototypes 
 4 #include "template.h" 
 5 using namespace AGK; 
 6 app App; 
 7  
 8 // Constants for the screen resolution 
 9 const int SCREEN_WIDTH  = 640; 
 10 const int SCREEN_HEIGHT = 480; 
 11  
 12 // Constants for images 
 13 const int TITLE_SCREEN_IMAGE  = 1; 
 14 const int INTRO_SCREEN_IMAGE  = 2; 
 15 const int EGG_IMAGE           = 3; 
 16 const int BROKEN_EGG_IMAGE    = 4; 
 17 const int FARM_IMAGE          = 5; 
 18 const int BASKET_IMAGE        = 6; 
 19 const int HIT_BASKET_IMAGE    = 7; 
 20 const int VULTURE_IMAGE       = 8; 
 21  
 22 // Constants for sprites 
 23 const int TITLE_SCREEN_SPRITE = 1; 
 24 const int INTRO_SCREEN_SPRITE = 2; 
 25 const int EGG_SPRITE          = 3; 
 26 const int BROKEN_EGG_SPRITE   = 4; 
 27 const int FARM_SPRITE         = 5; 
 Figure 9-16  Images used in the Vulture Trouble game  

 
9.4 The Vulture Trouble Game 
407
 28 const int BASKET_SPRITE       = 6; 
 29 const int HIT_BASKET_SPRITE   = 7; 
 30 const int VULTURE_SPRITE      = 8; 
 31  
 32 // Constants for animation 
 33 const int FRAME_WIDTH         = 120; 
 34 const int FRAME_HEIGHT        = 110; 
 35 const int FRAME_COUNT         = 8; 
 36 const float FRAMES_PER_SECOND = 8; 
 37  
 38 // Constants for the sounds 
 39 const int POP_SOUND           = 1; 
 40 const int CLAP_SOUND          = 2; 
 41 const int TYPE_SOUND          = 3; 
 42 const int COMPLETE_SOUND      = 4; 
 43 const int PERFECT_SCORE_SOUND = 5; 
 44  
 45 // Constants for the music 
 46 const int INTRO_MUSIC = 1; 
 47 const int MAIN_MUSIC  = 2; 
 48  
 49 // Constants for text 
 50 const int GAME_OVER_TEXT         = 1; 
 51 const int GAME_RESULTS_TEXT      = 2; 
 52 const int EGGS_CAUGHT_TEXT       = 3; 
 53 const int EGGS_MISSED_TEXT       = 4; 
 54 const int TOTAL_SCORE_TEXT       = 5; 
 55 const int CAUGHT_MULTIPLIER_TEXT = 6; 
 56 const int MISSED_MULTIPLIER_TEXT = 7; 
 57 const int PERFECT_SCORE_TEXT     = 8; 
 58 const float TEXT_SIZE            = 36; 
 59  
 60 // Constants for the possible game states 
 61 const int GAME_STARTED    = 1; 
 62 const int INTRO_STARTED   = 2; 
 63 const int GAME_IN_PLAY    = 3; 
 64 const int GAME_OVER       = 4; 
 65 const int SUMMARY_STARTED = 5; 
 66  
 67 // Other constants 
 68 const int SCORE_MULTIPLIER  = 1000; 
 69 const int MAX_EGGS          = 40; 
 70 const int EGG_CLONE         = 100; 
 71 const int HIDE              = 0; 
 72 const int SHOW              = 1; 
 73 const int LOOP              = 1; 
 74 const int NO                = 0; 
 75 const int YES               = 1; 
 76 const float ACCELERATION    = 0.008f; 
 77 const float MIN_X           = 0; 
 78 const float MAX_X           = SCREEN_WIDTH; 
 79 const float BASKET_MOVE     = 4; 
 80 const float VULTURE_MOVE    = 2; 
 81 const float INTRO_TIMER     = 5; 
 82 const float SUMMARY_TIMER   = 5; 
 83 const float GAME_OVER_TIMER = 4; 
 84  

408 
Chapter 9 
 Text, Collisions, and the Vulture Trouble Game
 85 // Global variables 
 86 int g_eggs            = MAX_EGGS; 
 87 int g_time            = 0; 
 88 int g_eggsCaught      = 0; 
 89 int g_eggsMissed      = 0; 
 90 int g_totalScore      = 0; 
 91 int g_summaryComplete = NO; 
 92 int g_gameState       = GAME_STARTED; 
 93 
 94 // Function prototypes 
 95 void displayTitleScreen(); 
 96 void hideTitleScreen(); 
 97 void displayIntroScreen(); 
 98 void hideIntroScreen(); 
 99 void playGame(); 
 100 void hideGame(); 
 101 void moveBasket(); 
 102 void moveVulture(); 
 103 void moveEgg(); 
 104 void checkCollisions(); 
 105 void showHitBasket(); 
 106 void showBrokenEgg(); 
 107 void resetEgg(); 
 108 void displayGameOverScreen(); 
 109 void hideGameOverScreen() ;
 110 void displaySummaryScreen(); 
 111 void hideSummaryScreen(); 
 112 
 Here is a summary of the constant declarations: 
 ●  Lines 9 and 10 declare constants for the virtual resolution.  
 ●  Lines 13 through 20 declare constants for the image index numbers that we will use.  
 ●  Lines 23 through 30 declare constants for the sprite index numbers that we will use.  
 ●  Lines 33 through 36 declare constants that we will use for the animated vulture sprite.  
 ●  Lines 39 through 43 declare constants for the sound index numbers that we will use.  
 ●  Lines 46 and 47 declare constants for the music index numbers that we use will use.  
 ●  Lines 50 through 57 declare constants for the text object index numbers that we 
will use. 
 ●  Line 58 declares a constant for the size of the text objects.  
 ●  Lines 61 through 65 declare constants for the game states we will use.  
 ●  Lines 68 through 83 declare these other constants: 
 ●  SCORE_MULTIPLIER is the value that each egg that is caught will be multiplied 
by when tallying the score.  
 ●  MAX_EGGS is the total number of eggs that the vulture has stolen.  
 ●  EGG_CLONE is the starting index number for the mini-egg sprites.  
 ●  HIDE is the value we will use when hiding a sprite.  
 ●  SHOW is the value we will use when showing a sprite.  
 ●  LOOP is the value we will use when lopping music.  
 ●  NO is the value we will use for false.  
 ●  YES is the value we will use for true.  
 ●  ACCELERATION is the value we will use for the acceleration of a dropped egg.  

 
9.4 The Vulture Trouble Game 
409
 ●  MIN_X is the value we will use for the left-edge of the screen while moving the 
vulture sprite.  
 ●  MAX_X is the value we will use for the right-edge of the screen while moving 
the vulture sprite.  
 ●  BASKET_MOVE is the value we will use when moving the basket.  
 ●  VULTURE_MOVE is the value we will use when moving the vulture.  
 ●  INTRO_TIMER is the value we will use when displaying the introduction screen.  
 ●  SUMMARY_TIMER is the value we will use when displaying the summary screen.  
 ●  GAME_OVER_TIMER is the value we will use when displaying the game over text.  
 Here is a summary of the global variable declarations In lines 86 through 92: 
 ●  g_eggs is a global variable initialized with the value of the  MAX_EGGS constant. 
This variable will keep track of the number of eggs left in play during the game.  
 ●  g_time is a global variable initialized with the value 0. This variable will keep 
track of the time in which one of the eggs is falling.  
 ●  g_eggsCaught is a global variable initialized with the value 0. This variable will 
keep track of the number of eggs that are caught in the basket.  
 ●  g_eggsMissed is a global variable initialized with the value 0. This variable will 
keep track of the number of eggs that are missed, hit the ground, and are broken.  
 ●  g_totalScore is a global variable initialized with the value 0. This variable will 
keep track of the total score when the game is finished.  
 ●  g_gameSummaryComplete is a global variable initialized with value of the  NO con-
stant. This variable acts as a flag. It keeps track of whether or not the summary 
is complete.  
 ●  g_gameState is a global variable initialized with the value of the  GAME_STARTED 
constant. This variable will keep track of the game state as the game is played.  
 Lines 95 through 111 hold the function prototypes, and then the  app::Begin function 
is shown: 
 Program 9-9 
  (VultureTrouble, continued) 
 113 // Begin app, called once at the start 
 114 void app::Begin( void ) 
 115 { 
 116    // Set the virtual screen resolution. 
 117    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 118  
 119    // Set the window title. 
 120    agk::SetWindowTitle("Vulture Trouble"); 
 121  
 122    // Load the images. 
 123    agk::LoadImage(TITLE_SCREEN_IMAGE, "titleScreen.png"); 
 124    agk::LoadImage(INTRO_SCREEN_IMAGE, "intro.png"); 
 125    agk::LoadImage(EGG_IMAGE, "egg.png"); 
 126    agk::LoadImage(BROKEN_EGG_IMAGE, "brokenEgg.png"); 
 127    agk::LoadImage(FARM_IMAGE, "farm.png"); 
 128    agk::LoadImage(BASKET_IMAGE, "basket.png"); 
 129    agk::LoadImage(HIT_BASKET_IMAGE, "hitBasket.png"); 
 130    agk::LoadImage(VULTURE_IMAGE, "vulture.png"); 
 131  
 132    // Create the sprites. 

410 
Chapter 9 
 Text, Collisions, and the Vulture Trouble Game
 133    agk::CreateSprite(TITLE_SCREEN_SPRITE, 
 134        TITLE_SCREEN_IMAGE); 
 135    agk::CreateSprite(INTRO_SCREEN_SPRITE, 
 136        INTRO_SCREEN_IMAGE); 
 137    agk::CreateSprite(FARM_SPRITE, FARM_IMAGE); 
 138    agk::CreateSprite(EGG_SPRITE, EGG_IMAGE); 
 139    agk::CreateSprite(VULTURE_SPRITE, VULTURE_IMAGE); 
 140    agk::CreateSprite(BASKET_SPRITE, BASKET_IMAGE); 
 141    agk::CreateSprite(BROKEN_EGG_SPRITE, BROKEN_EGG_IMAGE); 
 142    agk::CreateSprite(HIT_BASKET_SPRITE, HIT_BASKET_IMAGE); 
 143  
 144    // Load the sounds. 
 145    agk::LoadSound(POP_SOUND, "pop.wav"); 
 146    agk::LoadSound(CLAP_SOUND, "clap.wav"); 
 147    agk::LoadSound(TYPE_SOUND, "type.wav"); 
 148    agk::LoadSound(COMPLETE_SOUND, "complete.wav"); 
 149    agk::LoadSound(PERFECT_SCORE_SOUND,"vulturePerfect.wav"); 
 150  
 151    // Load the music. 
 152    agk::LoadMusic(INTRO_MUSIC, "vultureTrouble.mp3"); 
 153    agk::LoadMusic(MAIN_MUSIC, "vultureLevel.mp3"); 
 154  
 155    // Set up the vulture animation sequence. 
 156    agk::SetSpriteAnimation(VULTURE_SPRITE, FRAME_WIDTH, 
 157         FRAME_HEIGHT, FRAME_COUNT); 
 158  
 159    // Set the  X -coordinate of the vulture sprite. 
 160    float vultureX = SCREEN_WIDTH / 2 - 
 161         agk::GetSpriteWidth(VULTURE_SPRITE) / 2; 
 162  
 163    // Set the  Y -coordinate of the vulture sprite. 
 164    float vultureY = 0; 
 165     
 166    // Set the starting position of the vulture sprite. 
 167    agk::SetSpritePosition(VULTURE_SPRITE, vultureX, 
 168         vultureY); 
 169  
 170    // Set the  X -coordinate of the basket sprite. 
 171    float basketX = SCREEN_WIDTH / 2 - 
 172          agk::GetSpriteWidth(BASKET_SPRITE) / 2; 
 173  
 174    // Set the  Y -coordinate of the basket sprite. 
 175    float basketY = SCREEN_HEIGHT - 
 176          agk::GetSpriteHeight(BASKET_SPRITE); 
 177  
 178    // Set the starting position of the basket sprite. 
 179    agk::SetSpritePosition(BASKET_SPRITE, basketX, 
 180         basketY); 
 181  
 182    // Set the  X -coordinate of the egg sprite. 
 183    float eggX = vultureX; 
 184  
 185    // Set the  Y -coordinate of the egg sprite. 
 186    float eggY = vultureY + 
 187          agk::GetSpriteHeight(EGG_SPRITE) * 1.5; 
 188  

 
9.4 The Vulture Trouble Game 
411
 189    // Set the starting position of the egg sprite. 
 190    agk::SetSpritePosition(EGG_SPRITE, eggX, eggY); 
 191  
 192    // Hide the sprites. 
 193    agk::SetSpriteVisible(TITLE_SCREEN_SPRITE, HIDE); 
 194    agk::SetSpriteVisible(INTRO_SCREEN_IMAGE, HIDE); 
 195    agk::SetSpriteVisible(EGG_SPRITE, HIDE); 
 196    agk::SetSpriteVisible(BROKEN_EGG_SPRITE, HIDE); 
 197    agk::SetSpriteVisible(FARM_SPRITE, HIDE); 
 198    agk::SetSpriteVisible(BASKET_SPRITE, HIDE); 
 199    agk::SetSpriteVisible(HIT_BASKET_SPRITE, HIDE); 
 200    agk::SetSpriteVisible(VULTURE_SPRITE, HIDE); 
 201  
 202    // Generate the row of mini-eggs clones. 
 203    for(int count = 0; count < MAX_EGGS; count++) 
 204    { 
 205       // Store the sprite index number of the 
 206       // mini-egg sprite. 
 207       int clone = EGG_CLONE + count; 
 208  
 209       // Set the scale of the mini-egg sprite. 
 210       float scale = 0.5; 
 211  
 212       // Clone the mini-egg sprite. 
 213       agk::CloneSprite(clone, EGG_SPRITE); 
 214  
 215       // Set the scale of the mini-egg sprite. 
 216       agk::SetSpriteScale(clone, scale, scale); 
 217  
 218       // Set the  X -coordinate of the mini-egg sprite. 
 219       float x = agk::GetSpriteWidth(clone) * count; 
 220  
 221       // Set the  Y -coordinate of the mini-egg sprite. 
 222       float y = 0; 
 223  
 224       // Set the position of the mini-egg sprite. 
 225       agk::SetSpritePosition(clone, x, y); 
 226    } 
 227  
 228    // Create the text objects. 
 229    agk::CreateText(GAME_OVER_TEXT, "GAME OVER"); 
 230    agk::CreateText(GAME_RESULTS_TEXT, "GAME RESULTS"); 
 231    agk::CreateText(EGGS_CAUGHT_TEXT, "0"); 
 232    agk::CreateText(EGGS_MISSED_TEXT, "0"); 
 233    agk::CreateText(CAUGHT_MULTIPLIER_TEXT, " X "); 
 234    agk::CreateText(MISSED_MULTIPLIER_TEXT, " X "); 
 235    agk::CreateText(TOTAL_SCORE_TEXT, "0"); 
 236    agk::CreateText(PERFECT_SCORE_TEXT, "PERFECT SCORE!"); 
 237     
 238    // Set the size of the text objects. 
 239    agk::SetTextSize(GAME_OVER_TEXT, TEXT_SIZE); 
 240    agk::SetTextSize(GAME_RESULTS_TEXT, TEXT_SIZE); 
 241    agk::SetTextSize(EGGS_CAUGHT_TEXT, TEXT_SIZE); 
 242    agk::SetTextSize(EGGS_MISSED_TEXT, TEXT_SIZE); 
 243    agk::SetTextSize(CAUGHT_MULTIPLIER_TEXT, TEXT_SIZE); 
 244    agk::SetTextSize(MISSED_MULTIPLIER_TEXT, TEXT_SIZE); 

412 
Chapter 9 
 Text, Collisions, and the Vulture Trouble Game
 245    agk::SetTextSize(TOTAL_SCORE_TEXT, TEXT_SIZE); 
 246    agk::SetTextSize(PERFECT_SCORE_TEXT, TEXT_SIZE); 
 247  
 248    // Set the  X -coordinate of the game over text object. 
 249    float gameOverTextX = SCREEN_WIDTH / 2 - 
 250          agk::GetTextTotalWidth(GAME_OVER_TEXT) / 2; 
 251  
 252    // Set the  Y -coordinate of the game over text object. 
 253    float gameOverTextY = SCREEN_HEIGHT / 2 - 
 254          agk::GetTextTotalHeight(GAME_OVER_TEXT) / 2; 
 255  
 256    // Set the position of the game over text object. 
 257    agk::SetTextPosition(GAME_OVER_TEXT, gameOverTextX, 
 258         gameOverTextY); 
 259  
 260    // Set the  X -coordinate of the game results text object. 
 261    float gameResultsTextX = SCREEN_WIDTH / 2 - 
 262          agk::GetTextTotalWidth(GAME_RESULTS_TEXT) / 2; 
 263  
 264    // Set the  Y -coordinate of the game results text object. 
 265    float gameResultsTextY = SCREEN_HEIGHT / 6 - 
 266          agk::GetTextTotalHeight(GAME_RESULTS_TEXT) / 2; 
 267  
 268    // Set the position of the game results text object. 
 269    agk::SetTextPosition(GAME_RESULTS_TEXT, 
 270         gameResultsTextX, gameResultsTextY); 
 271  
 272    // Set the  X -coordinate of the eggs caught 
 273    // multiplier text object. 
 274    float caughtMultiplierTextX = SCREEN_WIDTH / 4; 
 275  
 276    // Set the  Y -coordinate of the eggs caught 
 277    // multiplier text object. 
 278    float caughtMultiplierTextY = SCREEN_HEIGHT / 2 - 
 279          agk::GetTextTotalHeight(CAUGHT_MULTIPLIER_TEXT)/ 2; 
 280  
 281    // Set the position of the eggs caught 
 282    // multiplier text object. 
 283    agk::SetTextPosition(CAUGHT_MULTIPLIER_TEXT, 
 284         caughtMultiplierTextX, caughtMultiplierTextY); 
 285  
 286    // Set the  X -coordinate of the eggs caught text object. 
 287    float eggsCaughtTextX = caughtMultiplierTextX + 
 288          agk::GetTextTotalWidth(EGGS_CAUGHT_TEXT) * 3; 
 289  
 290    // Set the  Y -coordinate of the eggs caught text object. 
 291    float eggsCaughtTextY = SCREEN_HEIGHT / 2 - 
 292          agk::GetTextTotalHeight(EGGS_CAUGHT_TEXT) / 2; 
 293  
 294    // Set the position of the eggs caught text object. 
 295    agk::SetTextPosition(EGGS_CAUGHT_TEXT, eggsCaughtTextX, 
 296         eggsCaughtTextY); 
 297  
 298    // Set the  X -coordinate of the eggs missed 
 299    // multiplier text object. 

 
9.4 The Vulture Trouble Game 
413
 300    float missedMultiplierTextX = SCREEN_WIDTH - 
 301          SCREEN_WIDTH / 3; 
 302  
 303    // Set the  Y -coordinate of the eggs missed 
 304    // multiplier text object. 
 305    float missedMultiplierTextY = SCREEN_HEIGHT / 2 - 
 306          agk::GetTextTotalHeight(MISSED_MULTIPLIER_TEXT) / 
 307          2; 
 308  
 309    // Set the position of the eggs missed 
 310    // multiplier text object. 
 311    agk::SetTextPosition(MISSED_MULTIPLIER_TEXT,  
 312         missedMultiplierTextX, missedMultiplierTextY); 
 313  
 314    // Set the  X -coordinate of the eggs missed text object. 
 315    float eggsMissedTextX = missedMultiplierTextX + 
 316          agk::GetTextTotalWidth(EGGS_MISSED_TEXT) * 3; 
 317  
 318    // Set the  Y -coordinate of the eggs missed text object. 
 319    float eggsMissedTextY = SCREEN_HEIGHT / 2 - 
 320          agk::GetTextTotalHeight(EGGS_MISSED_TEXT) / 2; 
 321  
 322    // Set the position of the eggs missed text object. 
 323    agk::SetTextPosition(EGGS_MISSED_TEXT, eggsMissedTextX, 
 324         eggsMissedTextY); 
 325  
 326    // Set the  X -coordinate of the total score text object. 
 327    float totalScoreTextX = SCREEN_WIDTH / 2 - 
 328          agk::GetTextTotalWidth(TOTAL_SCORE_TEXT) / 2; 
 329  
 330    // Set the  Y -coordinate of the total score text object. 
 331    float totalScoreTextY = SCREEN_HEIGHT - 
 332          agk::GetTextTotalHeight(TOTAL_SCORE_TEXT) * 4; 
 333  
 334    // Set the position of the total score text object. 
 335    agk::SetTextPosition(TOTAL_SCORE_TEXT, totalScoreTextX, 
 336         totalScoreTextY); 
 337  
 338    // Set the  X -coordinate of the perfect score text object. 
 339    float perfectScoreTextX = SCREEN_WIDTH / 2 - 
 340          agk::GetTextTotalWidth(PERFECT_SCORE_TEXT) / 2; 
 341  
 342    // Set the  Y -coordinate of the perfect score text object. 
 343    float perfectScoreTextY = SCREEN_HEIGHT - 
 344          agk::GetTextTotalHeight(TOTAL_SCORE_TEXT) * 2; 
 345  
 346    // Set the position of the perfect score text object. 
 347    agk::SetTextPosition(PERFECT_SCORE_TEXT,perfectScoreTextX, 
 348        perfectScoreTextY); 
 349  
 350    // Hide the text objects. 
 351    agk::SetTextVisible(GAME_OVER_TEXT, HIDE); 
 352    agk::SetTextVisible(GAME_RESULTS_TEXT, HIDE); 
 353    agk::SetTextVisible(EGGS_CAUGHT_TEXT, HIDE); 
 354    agk::SetTextVisible(EGGS_MISSED_TEXT, HIDE); 
 355    agk::SetTextVisible(CAUGHT_MULTIPLIER_TEXT, HIDE); 

414 
Chapter 9 
 Text, Collisions, and the Vulture Trouble Game
 356    agk::SetTextVisible(MISSED_MULTIPLIER_TEXT, HIDE); 
 357    agk::SetTextVisible(TOTAL_SCORE_TEXT, HIDE); 
 358    agk::SetTextVisible(PERFECT_SCORE_TEXT, HIDE); 
 359 } 
 360 
 Figure 9-17  Row of mini-egg sprites at the top of the screen  
 Next is the  app::Loop Function: 
 Program 9-9 
 (VultureTrouble, continued) 
 361 // Main loop, called every frame 
 362 void app::Loop ( void ) 
 363 { 
 364    // This switch statement determines the game state. 
 365    switch(g_gameState) 
 366    { 
 367       // The game has just started. 
 368       case GAME_STARTED: 
 369  
 370          // Display the title screen. 
 371          displayTitleScreen(); 
 372  
 373          // If the user presses the enter key, 
 374          // hide the title screen and change 
 375          // the game state to intro started. 
 376          if (agk::GetRawKeyPressed(AGK_KEY_ENTER)) 
 377             hideTitleScreen(); 
 378          break; 
 379  
 380       // The intro has just started. 
 381       case INTRO_STARTED: 
 382  
 383          // Display the instructions to the user. 
 384          displayIntroScreen(); 
 This function does a lot of work!  First we set the virtual resolution and the window 
title. We load the images (lines 123 through 130), create the sprites (lines 133 through 
142), and load the sounds and music (lines 145 through 153). Then, in lines 156 and 
157 we set up the animation sequence for the vulture. Next, in lines 160 through 
190, we set the starting positions of the vulture, egg, and basket sprites. Then, in lines 
193 through 200, we hide the sprites. In lines 203 through 226 we step through a 
 for loop and create the mini-egg sprites, as shown in Figure 9-17. Then, we create 
the text objects, set their sizes, and set the initial position of each one in lines 229 
through 348. After this is done, we hide the text objects.  

 
9.4 The Vulture Trouble Game 
415
 385  
 386          // When the time has expired, hide 
 387          // the instructions and change the 
 388          // game state to in play. 
 389          if (agk::Timer() >= INTRO_TIMER) 
 390             hideIntroScreen(); 
 391          break; 
 392  
 393       // The game is in play. 
 394       case GAME_IN_PLAY: 
 395  
 396          // Play the game. 
 397          playGame(); 
 398  
 399          // When the number of eggs in play 
 400          // reaches zero, hide the game and 
 401          // change the game state to game over. 
 402          if (g_eggs <= 0) 
 403             hideGame(); 
 404          break; 
 405  
 406       // The game is over. 
 407       case GAME_OVER: 
 408  
 409          // Display the game over screen. 
 410          displayGameOverScreen(); 
 411  
 412          // When the time has expired, hide 
 413          // the game over screen and change the 
 414          // game state to summary started. 
 415          if (agk::Timer() >= GAME_OVER_TIMER) 
 416             hideGameOverScreen(); 
 417          break; 
 418  
 419       // The summary has started. 
 420       case SUMMARY_STARTED: 
 421  
 422          // Display the summary screen. 
 423          displaySummaryScreen(); 
 424  
 425          // When the time has expired, hide 
 426          // the summary screen and change the 
 427          // game state to game started. 
 428          if (agk::Timer() >= SUMMARY_TIMER) 
 429             hideSummaryScreen(); 
 430          break; 
 431    } 
 432  
 433    // Refresh the screen. 
 434    agk::Sync(); 
 435 } 
 436 
 437 // Called when the app ends 
 438 void app::End ( void ) 
 439 { 
 440 } 
 441 

416 
Chapter 9 
 Text, Collisions, and the Vulture Trouble Game
 As you know by now, the  app:Loop function is the game loop. It is where all the action 
takes place, frame by frame, in our game. The Vulture Trouble game displays several 
screens while the program is running, and a great way to handle the transitions from one 
screen to the next is by using game states. Here is a summary of the game loop and each 
of its states: 
 ●  The  GAME_STARTED state is the initial state of the game. It displays the title screen 
and plays the music until the enter key is pressed. When the enter key is pressed, 
we move onto the next state.  
 ●  The  INTRO_STARTED state is the second state of the game. It displays the introduc-
tion screen for a short amount of time. When the timer has expired, then the 
game state changes to its third state.  
 ●  The  GAME_IN_PLAY state is the third and most important state of the game. This 
is where the actual game takes place, and we move the basket while the vulture 
flies back and forth across the screen dropping eggs. Once the vulture has 
dropped all its eggs, and we have been given a chance to either catch or miss 
them, the game state changes.  
 ●  The  GAME_OVER state is the fourth state of the game. During this state of the game 
we simply display the text GAME OVER in the center of the screen. When the 
timer is up, we change states.  
 ●  The  SUMMARY_STARTED state is the fifth state of the game. This is where we tally 
up the player’s score. Once the score has been tallied and the timer expires, 
we reset the game and return to the first state. This creates a loop, so the game 
is never really over. This provides the player an opportunity to play the game 
as many times as they wish, without having to restart the application.  
 The  app::End function appears in lines 438 through 440 and contains no code. 
 Next is the  displayTitleScreen function: 
 Program 9-9 
  (VultureTrouble, continued) 
 442 // The displayTitleScreen function plays the 
 443 // intro music and displays the title screen. 
 444 void displayTitleScreen() 
 445 { 
 446    // If the title screen is not visible, display it. 
 447    if (!agk::GetSpriteVisible(TITLE_SCREEN_SPRITE)) 
 448       agk::SetSpriteVisible(TITLE_SCREEN_SPRITE, SHOW); 
 449  
 450    // If the intro music is not playing, play it. 
 451    if (!agk::GetMusicPlaying()) 
 452       agk::PlayMusic(INTRO_MUSIC, LOOP, INTRO_MUSIC, 
 453            INTRO_MUSIC); 
 454 } 
 455 
 This function displays the title screen and plays the intro music. It contains  if state-
ments that determine if the title screen sprite is visible and if the intro music is play-
ing. If the title screen is hidden, then the program displays it. If the intro music is 

 
9.4 The Vulture Trouble Game 
417
not playing, then the program plays it. Notice that the intro music is played so that 
it will loop, and it will be the only music that is played. 
 Next, is the  hideTitleScreen function: 
 Program 9-9 
  (VultureTrouble, continued) 
 456 // The hideTitleScreen function hides the title screen 
 457 // and changes the game state to intro started. 
 458 void hideTitleScreen() 
 459 { 
 460    // Hide the title screen. 
 461    agk::SetSpriteVisible(TITLE_SCREEN_SPRITE, HIDE); 
 462  
 463    // Reset the game timer. 
 464    agk::ResetTimer(); 
 465  
 466    // Change the game state. 
 467    g_gameState = INTRO_STARTED; 
 468 } 
 469 
 This function hides the title screen, resets the game timer, and changes the game state 
to  INTRO_STARTED . 
 Next, is the  displayIntroScreen function: 
 Program 9-9 
  (VultureTrouble, continued) 
 470 // The displayIntroScreen function displays an 
 471 // intro screen with instructions for how to 
 472 // play the game. 
 473 void displayIntroScreen() 
 474 {   
 475    // If the intro screen is not visible, display it. 
 476    if (!agk::GetSpriteVisible(INTRO_SCREEN_SPRITE)) 
 477       agk::SetSpriteVisible(INTRO_SCREEN_SPRITE, SHOW); 
 478  
 479    // If the main music is not playing, play it. 
 480    if (agk::GetMusicPlaying() != MAIN_MUSIC) 
 481       agk::PlayMusic(MAIN_MUSIC, LOOP, MAIN_MUSIC, 
 482            MAIN_MUSIC); 
 483 } 
 484 
 This function is called when the game state changes to  INTRO_STARTED . It contains  if 
statements that determine if the introduction screen is visible and if the main music is 
playing. If the introduction screen is hidden, then the program displays it. If the main 
music is not playing, then the program plays it. Notice that the main music is played 
so that it will loop, and it will be the only music that is played. 

418 
Chapter 9 
 Text, Collisions, and the Vulture Trouble Game
 Next is the  hideIntroScreen function: 
 Program 9-9 
 (VultureTrouble, continued) 
 485 // The hideIntroScreen function hides the intro screen 
 486 // shows the game sprites, and changes the game state  
 487 // to game in play. 
 488 void hideIntroScreen() 
 489 { 
 490    // Hide the intro screen. 
 491    agk::SetSpriteVisible(INTRO_SCREEN_IMAGE, HIDE); 
 492  
 493    // Show the farm, basket, egg, and vulture sprites. 
 494    agk::SetSpriteVisible(FARM_SPRITE, SHOW); 
 495    agk::SetSpriteVisible(BASKET_SPRITE, SHOW); 
 496    agk::SetSpriteVisible(VULTURE_SPRITE, SHOW); 
 497    agk::SetSpriteVisible(EGG_SPRITE, SHOW); 
 498  
 499    // Show the row of mini-egg sprites. 
 500    for(int count = 0; count < MAX_EGGS; count++) 
 501    { 
 502       int clone = EGG_CLONE + count; 
 503       agk::SetSpriteVisible(clone, YES); 
 504    } 
 505  
 506    // Change the game state. 
 507    g_gameState = GAME_IN_PLAY; 
 508 } 
 509 
 This function hides the introduction screen. It shows the farm, basket, egg, and vul-
ture sprites. It also steps through a  for loop that shows all the mini-egg sprites. After 
these operations are complete, the game state is changed to  GAME_IN_PLAY . 
 Next is the  playGame function: 
 Program 9-9 
  (VultureTrouble, continued) 
 510 // The playGame function processes a frame of game play. 
 511 void playGame() 
 512 { 
 513    // Move the basket. 
 514    moveBasket(); 
 515  
 516    // Move the vulture. 
 517    moveVulture(); 
 518  
 519    // Move the egg. 
 520    moveEgg(); 
 521  
 522    // Check for collisions. 
 523    checkCollisions(); 
 524 } 
 525 

 
9.4 The Vulture Trouble Game 
419
 This function is the heart of the game. It calls the  moveBasket function to update 
the position of the basket sprite when it is moved by the player. It calls the 
 moveVulture function, which is responsible for moving the vulture back and forth 
across the top of the screen. It calls the  moveEgg function that updates the position 
of the egg as it falls. Finally, it calls the  checkCollisions function. This function is 
responsible for determining if the egg has hit the basket and was caught, or if the 
egg has hit the ground and was broken. This function is called until there are no 
more eggs left. 
 Next is the  hideGame function: 
 Program 9-9 
 (VultureTrouble, continued) 
 526 // The hideGame function stops the game's main music 
 527 // and hides the sprites. It changes the game state 
 528 // to game over. 
 529 void hideGame() 
 530 { 
 531    // Stop the music. 
 532    agk::StopMusic(); 
 533  
 534    // Hide the farm, basket, egg, and vulture sprites. 
 535    agk::SetSpriteVisible(FARM_SPRITE, HIDE); 
 536    agk::SetSpriteVisible(BASKET_SPRITE, HIDE); 
 537    agk::SetSpriteVisible(VULTURE_SPRITE, HIDE); 
 538    agk::SetSpriteVisible(EGG_SPRITE, HIDE); 
 539  
 540    // Reset the game timer. 
 541    agk::ResetTimer(); 
 542  
 543    // Change the game State. 
 544    g_gameState = GAME_OVER; 
 545 } 
 546 
 This function is called after no more eggs are left. It stops the main music and hides 
the farm, basket, egg, and vulture sprites. It resets the timer and changes the game 
state to  GAME_OVER . 
 Next is the  moveBasket function: 
 Program 9-9 
 (VultureTrouble, continued) 
 547 // The moveBasket function moves the basket sprite back 
 548 // and forth along the  X -axis according to user input. 
 549 void moveBasket() 
 550 { 
 551    // Get the  X -coordinate of the basket sprite. 
 552    float x = agk::GetSpriteX(BASKET_SPRITE); 
 553  
 554    // Get the width of the basket sprite. 
 555    float width = agk::GetSpriteWidth(BASKET_SPRITE); 

420 
Chapter 9 
 Text, Collisions, and the Vulture Trouble Game
 556  
 557    // Store the minimum value that the  X -coordinate of 
 558    // the basket sprite can reach without going beyond 
 559    // the left edge of the screen. 
 560    float minimumX = MIN_X; 
 561  
 562    // Store the maximum value that the  X -coordinate of  
 563    // the basket sprite can reach without going beyond 
 564    // the right edge of the screen. 
 565    float maximumX = MAX_X - width; 
 566  
 567    // Determine if the keyboard's left arrow key is 
 568    // being held down. 
 569    if (agk::GetRawKeyState(AGK_KEY_LEFT)) 
 570    { 
 571       // If the  X -coordinate of the basket sprite 
 572       // has reached the left edge of the screen, 
 573       // it can go no further. 
 574       if (x <= minimumX) 
 575          x = minimumX; 
 576  
 577       // Otherwise, move to the left. 
 578       else 
 579          x -= BASKET_MOVE; 
 580    } 
 581  
 582    // Determine if the keyboard's right arrow key is 
 583    // being held down. 
 584    if (agk::GetRawKeyState(AGK_KEY_RIGHT)) 
 585    { 
 586       // If the  X -coordinate of the basket sprite 
 587       // has reached the right edge of the screen, 
 588       // it can go no further. 
 589       if (x >= maximumX) 
 590          x = maximumX; 
 591  
 592       // Otherwise, move to the right. 
 593       else 
 594          x += BASKET_MOVE; 
 595    } 
 596  
 597    // Update the basket sprite's  X -coordinate. 
 598    agk::SetSpriteX(BASKET_SPRITE, x); 
 599 } 
 600 
 This function moves the basket back and forth along the bottom of the screen. It gets 
the current  X -coordinate of the basket, determines if the basket is within the limits 
of the screen, and moves the basket left or right, depending on whether the user 
presses the left or right arrow key. Finally, it sets the position of the basket sprite, 
which will update its position. 
 Next is the  moveVulture function: 

 
9.4 The Vulture Trouble Game 
421
 Program 9-9 
 (VultureTrouble, continued) 
 601 // The moveVulture function moves the vulture sprite back 
 602 // and forth along the  X -axis based on location and angle. 
 603 void moveVulture() 
 604 { 
 605    // If the vulture animation is not playing, play it. 
 606    if (!agk::GetSpritePlaying(VULTURE_SPRITE)) 
 607       agk::PlaySprite(VULTURE_SPRITE, FRAMES_PER_SECOND); 
 608  
 609    // Get the  X -coordinate of the vulture sprite. 
 610    float x = agk::GetSpriteX(VULTURE_SPRITE); 
 611  
 612    // Get the width of the vulture sprite. 
 613    float width = agk::GetSpriteWidth(VULTURE_SPRITE); 
 614  
 615    // Store the minimum value that the  X -coordinate of 
 616    // the vulture sprite can reach without going beyond 
 617    // the left edge of the screen. 
 618    float minimumX = MIN_X; 
 619  
 620    // Store the maximum value that the  X -coordinate of 
 621    // the vulture sprite can reach without going beyond  
 622    // the right edge of the screen. 
 623    float maximumX = MAX_X - width; 
 624  
 625    // If the  X -coordinate of the vulture sprite 
 626    // has reached the left edge of the screen, 
 627    // it can go no further. 
 628    if (x <= minimumX) 
 629    { 
 630       // Flip the sprite vertically and set its angle to 
 631       // 180 degrees. This will make the sprite turn and 
 632       // face right. 
 633       agk::SetSpriteFlip(VULTURE_SPRITE, NO, YES); 
 634       agk::SetSpriteAngle(VULTURE_SPRITE, 180.0f); 
 635    } 
 636  
 637    // If the  X -coordinate of the vulture sprite 
 638    // has reached the right edge of the screen, 
 639    // it can go no further. 
 640    if (x >= maximumX) 
 641    { 
 642       // Do not flip the sprite, just set the angle 
 643       // to 0 degrees. 
 644       // This will make the sprite turn and face left. 
 645       agk::SetSpriteFlip(VULTURE_SPRITE, NO, NO); 
 646       agk::SetSpriteAngle(VULTURE_SPRITE, 0.0f); 
 647    } 
 648  
 649    // If the vulture sprite is facing right, move right. 
 650    if (agk::GetSpriteAngle(VULTURE_SPRITE) == 180.0f) 
 651       x += VULTURE_MOVE; 
 652  
 653    // Otherwise, the vulture sprite is facing left, 

422 
Chapter 9 
 Text, Collisions, and the Vulture Trouble Game
 654    // so move left. 
 655    else 
 656       x -= VULTURE_MOVE; 
 657  
 658    // Update the vulture sprite's  X -coordinate. 
 659    agk::SetSpriteX(VULTURE_SPRITE, x); 
 660 } 
 661 
 This function moves the vulture sprite back and forth across the top of the screen. It stores 
the vulture’s current  X -coordinate and then determines if the vulture needs to be rotated, 
so that it will appear to be flying in the other direction when it reaches the edges of the 
screen. Finally, it sets the  X -coordinate of the vulture sprite, which will update its position. 
 Next is the  moveEgg function: 
 Program 9-9 
  (VultureTrouble, continued) 
 662 // The moveEgg function moves the egg sprite both 
 663 // down the screen and across the screen. 
 664 void moveEgg() 
 665 { 
 666    // Get the egg sprite's  XY -coordinates. 
 667    float eggX = agk::GetSpriteX(VULTURE_SPRITE); 
 668    float eggY = agk::GetSpriteY(EGG_SPRITE); 
 669  
 670    // Create a variable to hold the falling distance. 
 671    float distance; 
 672  
 673    // Set the egg's  X position so it is below 
 674    // the vulture's beak. This will depend on 
 675    // the vulture's angle. 
 676    if(agk::GetSpriteAngle(VULTURE_SPRITE) == 180.0f) 
 677    { 
 678       eggX = agk::GetSpriteX(VULTURE_SPRITE) + 
 679              agk::GetSpriteWidth(VULTURE_SPRITE) - 
 680              agk::GetSpriteWidth(EGG_SPRITE); 
 681    } 
 682  
 683    // Calculate the falling distance. 
 684    distance = 0.5 * ACCELERATION * g_time * g_time; 
 685  
 686    // Update the egg sprite's  Y -coordinate. 
 687    eggY += distance; 
 688  
 689    // Update the egg sprite's position. 
 690    agk::SetSpritePosition(EGG_SPRITE, eggX, eggY); 
 691     
 692    // Increment the falling time. 
 693    g_time++; 
 694 } 
 695 

 
9.4 The Vulture Trouble Game 
423
 The moveEgg function updates the position of the egg while it is in the vulture’s beak 
and also while it is falling toward the ground, as illustrated in Figure 9-18. The 
 Y -coordinate of the egg is determined by the free fall distance formula.  
 Figure 9-18  An egg moving horizontally and vertically  
 Next is the  checkCollisions function: 
 Program 9-9 
 (VultureTrouble, continued) 
 696 // The checkCollisions function checks for a collision 
 697 // between the egg and the basket or the ground. 
 698 void checkCollisions() 
 699 { 
 700    // Get the  Y -coordinate for the bottom of the egg sprite. 
 701    float eggBottom = agk::GetSpriteY(EGG_SPRITE) + 
 702                      agk::GetSpriteHeight(EGG_SPRITE); 
 703  
 704    // Determine if the egg has hit the basket. 
 705    if (agk::GetSpriteCollision(EGG_SPRITE, BASKET_SPRITE)) 
 706    { 
 707       // Increment the number of eggs caught. 
 708       g_eggsCaught++; 
 709  
 710       // Decrement the number of eggs in play. 
 711       g_eggs--; 
 712  
 713       // Show the hit basket effect. 
 714       showHitBasket(); 
 715  
 716       // Reset the egg. 
 717       resetEgg(); 

424 
Chapter 9 
 Text, Collisions, and the Vulture Trouble Game
 718  
 719       // Reset the falling time. 
 720       g_time = 0; 
 721    } 
 722  
 723    // The egg has missed the basket and hit the ground. 
 724    else if (eggBottom >= SCREEN_HEIGHT) 
 725    { 
 726       // Increment the number of eggs missed. 
 727       g_eggsMissed++; 
 728  
 729       // Decrement the number of eggs in play. 
 730       g_eggs--; 
 731        
 732       // Show the broken egg effect. 
 733       showBrokenEgg(); 
 734  
 735       // Reset the egg. 
 736       resetEgg(); 
 737  
 738       // Reset the falling time. 
 739       g_time = 0; 
 740    } 
 741 } 
 742 
 This function determines whether the egg has hit the basket or has hit the ground. 
First we get the  Y -coordinate for the bottom of the egg. Then we check for a collision 
with the basket. If the egg collides with the basket, then we know it has been caught, 
but if the bottom of the egg is greater than or equal to the ground, then we know the 
egg has been missed. If an egg is caught, we call the  showHitBasket function, which 
will display an image and play a sound indicating that the egg has been caught. We 
also increment the number of eggs caught. If an egg has been missed, however, we call 
the  showBrokenEgg function, which will display an image and play a sound indicating 
that the egg was missed and has been broken. We also increment the number of eggs 
missed. Notice that in both cases, whether the egg is caught in the basket or is missed 
and breaks on the ground, we decrement the number of eggs left in the game, we reset 
the time variable needed to calculate the free fall distance, and we reset the egg to 
appear in the vulture’s beak. 
 Next is the  showHitBasket function: 
 Program 9-9 
 (VultureTrouble, continued) 
 743 // The showHitBasket function displays the hit 
 744 // basket effect and plays the pop sound. 
 745 void showHitBasket() 
 746 { 
 747    // Set the hit basket sprite to the same 
 748    // position as the basket sprite. 

 
9.4 The Vulture Trouble Game 
425
 749    agk::SetSpritePosition(HIT_BASKET_SPRITE, 
 750         agk::GetSpriteX(BASKET_SPRITE), 
 751         agk::GetSpriteY(BASKET_SPRITE)); 
 752  
 753    // Show the hit basket sprite. 
 754    agk::SetSpriteVisible(HIT_BASKET_SPRITE, SHOW); 
 755  
 756    // Play the pop sound. 
 757    agk::PlaySound(POP_SOUND); 
 758  
 759    // Refresh the screen now, so we can see the changes. 
 760    agk::Sync(); 
 761  
 762    // Wait for 1/10 of a second. 
 763    agk::Sleep(100); 
 764  
 765    // Hide the hit basket sprite. 
 766    agk::SetSpriteVisible(HIT_BASKET_SPRITE, HIDE); 
 767 } 
 768 
 This function is called when the egg collides with the basket. It shows the hit basket 
sprite as shown in Figure 9-19, and plays a sound indicating that the user has caught an 
egg in the basket. Notice that in line 760 we call the  agk::Sync function. This is so we 
can update the screen to show the effects. After we update the screen, we sleep for an 
instant and then hide the sprite.  
 Figure 9-19  The hit basket sprite displayed  
 Next is the  showBrokenEgg function: 
 Program 9-9 
  (VultureTrouble, continued) 
 769 // The showBrokenEgg function displays the broken 
 770 // egg effect and plays the clap sound. 
 771 void showBrokenEgg() 
 772 { 
 773    // Set the broken egg sprite's position. 
 774    agk::SetSpritePosition(BROKEN_EGG_SPRITE, 
 775         agk::GetSpriteX(EGG_SPRITE), 
 776         agk::GetSpriteY(EGG_SPRITE) - 
 777         agk::GetSpriteHeight(EGG_SPRITE) / 2); 
 778  

426 
Chapter 9 
 Text, Collisions, and the Vulture Trouble Game
 779    // Show the broken egg sprite. 
 780    agk::SetSpriteVisible(BROKEN_EGG_SPRITE, SHOW); 
 781  
 782    // Play the clap sound. 
 783    agk::PlaySound(CLAP_SOUND); 
 784  
 785    // Refresh the screen now, so we can see the changes. 
 786    agk::Sync(); 
 787  
 788    // Wait for 1/10 of a second. 
 789    agk::Sleep(100); 
 790  
 791    // Hide the broken egg sprite. 
 792    agk::SetSpriteVisible(BROKEN_EGG_SPRITE, HIDE); 
 793 } 
 794 
 This function is called when the egg collides with the ground. It shows the broken egg 
sprite, as shown in Figure 9-20, and plays a sound indicating that the user has missed 
an egg and it has broken on the ground. Notice that in line 786 we call the  agk::Sync 
function. This is so we can update the screen to show the effects. After we update the 
screen, we sleep for an instant and then hide the sprite.  
 Figure 9-20  The broken egg sprite displayed  
 Next is the  resetEgg function: 
 Program 9-9 
  (VultureTrouble, continued) 
 795 // The resetEgg function resets the egg after it has 
 796 // either been caught in the basket or hit the ground. 
 797 void resetEgg() 
 798 { 
 799    // Hide the current mini-egg sprite clone. 
 800    agk::SetSpriteVisible(EGG_CLONE + g_eggs, HIDE); 
 801  
 802    // Reset the egg sprite's position. 
 803    agk::SetSpriteY(EGG_SPRITE, 
 804         agk::GetSpriteY(VULTURE_SPRITE) + 
 805         agk::GetSpriteHeight(EGG_SPRITE) * 1.5); 
 806 } 
 807 
 This function is called when the egg collides with either the basket or the ground. It hides 
one of the mini-eggs and resets the eggs position so that it appears in the vulture’s beak, 
as shown in Figure 9-21.  

 
9.4 The Vulture Trouble Game 
427
 Figure 9-21  Egg positioned below the vulture’s beak  
 Next, is the  displayGameOverScreen Function: 
 Program 9-9 
  (VultureTrouble, continued) 
 808 // The displayGameOverScreen function displays the 
 809 // game over text and plays the complete sound. 
 810 void displayGameOverScreen() 
 811 { 
 812    // Display the game over text. 
 813    agk::SetTextVisible(GAME_OVER_TEXT, SHOW); 
 814  
 815    // If the complete sound is not playing, play it. 
 816    if (!agk::GetSoundsPlaying(COMPLETE_SOUND)) 
 817       agk::PlaySound(COMPLETE_SOUND); 
 818 } 
 819 
 This function displays the game over screen. It shows the game over text object and 
plays the game complete sound. It contains an  if statement that determines if the 
sound is not playing, to play it. This screen is displayed for a short while, and when 
the timer expires, it is hidden. 
 Next is the  hideGameOverScreen function: 
 Program 9-9 
 (VultureTrouble, continued) 
 820 // The hideGameOverScreen function prepares the 
 821 // game for the summary screen. 
 822 void hideGameOverScreen() 
 823 { 
 824    // Hide the game over text. 
 825    agk::SetTextVisible(GAME_OVER_TEXT, HIDE); 
 826  
 827    // Stop the complete sound. 
 828    agk::StopSound(COMPLETE_SOUND); 
 829  
 830    // Reset the timer. 
 831    agk::ResetTimer(); 
 832  
 833   // Change the game state. 
 834    g_gameState = SUMMARY_STARTED; 
 835 } 
 836 

428 
Chapter 9 
 Text, Collisions, and the Vulture Trouble Game
 This function is called when the timer expires for the game over screen. It hides the 
game over text object, stops the game complete sound, resets the timer, and changes 
the game state to  SUMMARY_STARTED . 
 Next is the  displaySummaryScreen function: 
 Program 9-9 
  (VultureTrouble, continued) 
 837 // The displaySummaryScreen function displays a 
 838 // summary of the player's performance, including 
 839 // points earned. 
 840 // Each egg caught earns 1000 points. 
 841 void displaySummaryScreen() 
 842 { 
 843    // Determine if the summary is complete. 
 844    if (g_summaryComplete == NO) 
 845    { 
 846       // Update the string of the eggs caught text object. 
 847       agk::SetTextString(EGGS_CAUGHT_TEXT, 
 848            agk::Str(g_eggsCaught)); 
 849  
 850       // Update the  X -coordinate of the eggs caught text 
 851       // object. 
 852       agk::SetTextX(EGGS_CAUGHT_TEXT, 
 853            agk::GetTextX(CAUGHT_MULTIPLIER_TEXT) + 
 854            agk::GetTextTotalWidth(CAUGHT_MULTIPLIER_TEXT) 
 855            / 2 + 
 856            agk::GetTextTotalWidth(EGGS_CAUGHT_TEXT) / 2); 
 857  
 858       // Set the egg sprite position inline with the text. 
 859       agk::SetSpritePosition(EGG_SPRITE,  
 860            agk::GetTextX(CAUGHT_MULTIPLIER_TEXT) - 
 861            agk::GetSpriteWidth(EGG_SPRITE) / 2, 
 862            agk::GetTextY(EGGS_CAUGHT_TEXT)); 
 863  
 864       // Update the string of the eggs missed text object. 
 865       agk::SetTextString(EGGS_MISSED_TEXT, 
 866            agk::Str(g_eggsMissed)); 
 867  
 868       // Update the  X -coordinate of the eggs missed text 
 869       // object. 
 870       agk::SetTextX(EGGS_MISSED_TEXT,  
 871            agk::GetTextX(MISSED_MULTIPLIER_TEXT) + 
 872            agk::GetTextTotalWidth(MISSED_MULTIPLIER_TEXT) 
 873            / 2 + 
 874            agk::GetTextTotalWidth(EGGS_MISSED_TEXT) / 2); 
 875  
 876       // Set the broken egg sprite position inline 
 877       // with the text. 
 878       agk::SetSpritePosition(BROKEN_EGG_SPRITE, 
 879            agk::GetTextX(MISSED_MULTIPLIER_TEXT) - 
 880            agk::GetSpriteWidth(BROKEN_EGG_SPRITE), 
 881            agk::GetTextY(EGGS_MISSED_TEXT)); 
 882  

 
9.4 The Vulture Trouble Game 
429
 883       // Show the egg and broken egg sprites. 
 884       agk::SetSpriteVisible(EGG_SPRITE, SHOW); 
 885       agk::SetSpriteVisible(BROKEN_EGG_SPRITE, SHOW); 
 886  
 887       // Show the text objects. 
 888       agk::SetTextVisible(GAME_RESULTS_TEXT, SHOW); 
 889       agk::SetTextVisible(EGGS_CAUGHT_TEXT, SHOW); 
 890       agk::SetTextVisible(EGGS_MISSED_TEXT, SHOW); 
 891       agk::SetTextVisible(CAUGHT_MULTIPLIER_TEXT, SHOW); 
 892       agk::SetTextVisible(MISSED_MULTIPLIER_TEXT, SHOW); 
 893       agk::SetTextVisible(TOTAL_SCORE_TEXT, SHOW); 
 894  
 895       // Tally up the total score. 
 896       for(int i = 0; i <= g_eggsCaught; i++) 
 897       { 
 898          // Update the string of the total score 
 899          // text object. 
 900          agk::SetTextString(TOTAL_SCORE_TEXT, 
 901               agk::Str(i * SCORE_MULTIPLIER)); 
 902  
 903          // Update the  X -coordinate of the total 
 904          // score text object. 
 905          agk::SetTextX(TOTAL_SCORE_TEXT, 
 906               SCREEN_WIDTH / 2 - 
 907               agk::GetTextTotalWidth(TOTAL_SCORE_TEXT) / 
 908               2); 
 909  
 910          // Play the type sound. 
 911          agk::PlaySound(TYPE_SOUND); 
 912  
 913          // Wait for 1/10 of a second. 
 914          agk::Sleep(100); 
 915  
 916          // Refresh the screen now, so we can see the 
 917          // changes. 
 918          agk::Sync(); 
 919       } 
 920  
 921       // If no eggs were broken, display a special message. 
 922       if (g_eggsCaught == MAX_EGGS) 
 923       { 
 924          // Display the perfect score text object. 
 925          agk::SetTextVisible(PERFECT_SCORE_TEXT, SHOW); 
 926           
 927          // Play the perfect score sound. 
 928          agk::PlaySound(PERFECT_SCORE_SOUND); 
 929  
 930          // Wait for 1/10 of a second. 
 931          agk::Sleep(100); 
 932  
 933          // Refresh the screen now, so we can see the 
 934          // changes. 
 935          agk::Sync(); 
 936       } 
 937  

430 
Chapter 9 
 Text, Collisions, and the Vulture Trouble Game
 938       // After we tally the score and exit the loop, 
 939       // the summary is complete. 
 940       g_summaryComplete = YES; 
 941  
 942       // Reset the timer. 
 943       agk::ResetTimer(); 
 944    } 
 945 } 
 946 
 This function displays the results of the game to the user. It shows the text objects, 
updates their positions, and then tallies the player’s score based on how many eggs 
were caught during the game. Notice that the  agk::Sync function is called to update 
the screen. If the user had a perfect score and caught all the eggs, a special message 
appears and a sound is played. When the tally is complete, the  g_summaryComplete vari-
able is set to  YES . The timer is reset, and the screen is displayed until the timer expires. 
 Next is the  hideSummaryScreen function: 
 Program 9-9 
  (VultureTrouble, continued) 
 947 // The hideSummaryScreen hides the summary screen 
 948 // and changes the game state to when the game 
 949 // started. 
 950 void hideSummaryScreen() 
 951 { 
 952    // Hide the text. 
 953    agk::SetTextVisible(GAME_OVER_TEXT, HIDE); 
 954    agk::SetTextVisible(GAME_RESULTS_TEXT, HIDE); 
 955    agk::SetTextVisible(EGGS_CAUGHT_TEXT, HIDE); 
 956    agk::SetTextVisible(EGGS_MISSED_TEXT, HIDE); 
 957    agk::SetTextVisible(CAUGHT_MULTIPLIER_TEXT, HIDE); 
 958    agk::SetTextVisible(MISSED_MULTIPLIER_TEXT, HIDE); 
 959    agk::SetTextVisible(TOTAL_SCORE_TEXT, HIDE); 
 960    agk::SetTextVisible(PERFECT_SCORE_TEXT, HIDE); 
 961  
 962    // Hide the sprites. 
 963    agk::SetSpriteVisible(EGG_SPRITE, HIDE); 
 964    agk::SetSpriteVisible(BROKEN_EGG_SPRITE, HIDE); 
 965  
 966    // Reset  X -coordinate of the vulture sprite to the 
 967    // starting value. 
 968    float vultureX = SCREEN_WIDTH / 2 - 
 969          agk::GetSpriteWidth(VULTURE_SPRITE) / 2; 
 970  
 971    // Reset  Y -coordinate of the vulture sprite to the 
 972    // starting value. 
 973    float vultureY = 0; 
 974  
 975    // Reset the vulture sprite to the starting position. 
 976    agk::SetSpritePosition(VULTURE_SPRITE, vultureX, 
 977         vultureY); 
 978  

 
Review Questions 
431
 979    // Reset  X -coordinate of the basket sprite to the 
 980    // starting value. 
 981    float basketX = SCREEN_WIDTH / 2 - 
 982          agk::GetSpriteWidth(BASKET_SPRITE) / 2; 
 983  
 984    // Reset  Y -coordinate of the basket sprite to the 
 985    // starting value. 
 986    float basketY = SCREEN_HEIGHT - 
 987          agk::GetSpriteHeight(BASKET_SPRITE); 
 988  
 989    // Reset the basket sprite to the starting position. 
 990    agk::SetSpritePosition(BASKET_SPRITE, basketX, basketY); 
 991  
 992    // Reset  X -coordinate of the egg sprite to the 
 993    // starting value. 
 994    float eggX = vultureX; 
 995  
 996    // Reset  Y -coordinate of the egg sprite to the 
 997    // starting value. 
 998    float eggY = vultureY + 
 999          agk::GetSpriteHeight(EGG_SPRITE) * 1.5f; 
 1000  
 1001    // Reset the egg sprite to the starting position. 
 1002    agk::SetSpritePosition(EGG_SPRITE, eggX, eggY); 
 1003     
 1004    // Reset the timer. 
 1005    agk::ResetTimer(); 
 1006  
 1007    // Reset the global variables. 
 1008    g_summaryComplete = NO; 
 1009    g_eggs = MAX_EGGS; 
 1010    g_eggsMissed = 0; 
 1011    g_eggsCaught = 0; 
 1012  
 1013    // Reset the game state. 
 1014    g_gameState = GAME_STARTED; 
 1015 }  
 This function hides the text objects and sprites and resets the global variables, so that 
the game may be played again. It sets the game state to  GAME_STARTED , and the game 
starts all over again.  
 Review Questions 
 Multiple Choice  
 
1.   The _____ function returns the size of a text object.  
 a.  agk::GetSize 
 b.  agk::TextSize 
 c.   agk::TotalTextSize 
 d.   agk::GetTextSize 

432 
Chapter 9 
 Text, Collisions, and the Vulture Trouble Game
 
2.  When _____ overlap, a sprite collision occurs.  
 a.  two sprites  
 b.  bounding boxes 
 c.  several particles  
 d.  two copies of the same sprite  
 
3.   Without considering the effects of air resistance, suppose a boy drops a marble 
off the top of a building. The marble’s speed will _____.  
 a.  increase as it falls  
 b.  be the same all the way down  
 c.  decrease as it falls  
 d.  alternatively decrease and increase  
 
4.   Which one of the following is the default alignment for text objects?  
 a.  Left  
 b.  Right  
 c.  Center  
 d.  Bottom  
 
5.  If you specify a negative value when setting the spacing of a text object, the spac-
ing between letters will _____.  
 a.  increase  
 b.  not change  
 c.  decrease  
 d.  double 
 
6.   What function can be used to detect a collision between a text object and a 
single point?  
 a.  agk::TextHit 
 b.  agk::TextCollidePoint 
 c.  agk::GetTextCollision 
 d.  agk::GetTextHitTest 
 
7.  You can change the vertical position of a text object by calling the _____ function.  
 a.  agk::ChangeTextY 
 b.  agk::SetTextY 
 c.  agk::MoveTextY 
 d.  agk::SetTextVertical 
 
8.   Which one of the following functions will show or hide a text object?  
 a.  agk::SetTextVisible 
 b.  agk::ShowText 
 c.  agk::HideText 
 d.  agk::SetTextSize 
 
9.   If you want to simulate a falling object, you must change the value of the 
_____.  
 a.  gravity  
 b.  Y -coordinate  
 c.  acceleration  
 d.  X -coordinate  

 
Review Questions 
433
 
10.   Which one of the following is an optional argument when setting the color of a 
text object?  
 a.  Red 
 b.   Green 
 c.  Blue 
 d.   Alpha  
 True or False  
 
1.   By default, the size of a text object is set to 16.  
 
2.  When gravity causes an object to fall toward Earth, the object’s speed increases 
as it falls.  
 
3.   You can set a text object’s size and color, but not its position.  
 
4.  You call the  agk::GetSpritesHit function to determine if two sprites have collided.  
 
5.  When setting the spacing of a text object, If you specify a positive value, then the 
spacing will increase.  
 
6.  Even if a sprite uses an image that has been saved with transparency, the bound-
ing box will always be visible.  
 
7.  You can detect collisions between two text objects with the  agk::GetTextCollision 
function. 
 
8.  Once a text object has been created, its string value can never be changed.  
 Short Answer  
 
1.   Suppose gravity is causing an object to fall in a vacuum, toward Earth. At three 
seconds, what is the object’s speed?  
 
2.   What is a sprite’s bounding box?  
 
3.   How do you simulate an object that is moving both horizontally and vertically?  
 
4.   What function can you call to determine the total width of a text object?  
 
5.   When a text object is created, what two values must be passes as arguments?  
 Algorithm Workbench  
 
1.   Write code that sets the size of a text object to twice its current value.  
 
2.   Write a statement that determines if a sprite that has an index number of 1 has 
collided with a sprite that has an index number of 4.  
 
3.   Write a statement that sets the color of a text object with an index number of 5 
to yellow.  
 
4.  Write a statement that determines if a sprite that has an index number of 3 has 
collided with a sprite that has an index number of 4. If so, hide both sprites.  
 
5.   Write a statement that determines if a text object with an index number of 1 
exists. If it does, set the alignment of the text object to right-aligned.  

434 
Chapter 9 
 Text, Collisions, and the Vulture Trouble Game
 Programming Exercises 
 
1.  Randomly Moving Bowling Balls 
 The  Sprite Collision program shown earlier in this chapter (see Program 9-5) 
shows two bowling balls that initially appear on opposite sides of the screen. 
The balls move toward each other, and when they collide, they are repositioned 
back at their original locations, and the animation repeats. Modify the program 
so that the bowling balls move in random directions. If a ball reaches the edge of 
the screen, it should change directions. If the bowling balls collide, they should 
be repositioned back at their random locations.  
 
2.   Vulture Trouble Modification 
 Modify the Vulture Trouble game (see Program 9-9) so that the gravitational 
acceleration increases a slight amount for each egg that drops. This will make 
the game more challenging because the eggs will fall faster and faster as play 
continues.  
 
3.   Catch the Boulder Game 
 Design and create a game named Catch the Boulder. The object of the game is to 
catch falling boulders in a cart that can be moved back and forth on a railroad 
track. Figure 9-22 shows an example of the game’s screen. In many ways the 
game can be patterned after the Vulture Trouble game presented in this chapter. 
 This book’s online  resources (downloadable from  www.pearsonhighered.com/
gaddis ) provide several images that you can use to create the game.  
 Figure 9-22  Sample screen from Catch the Boulder  

 
Programming Exercises 
435
 Figure 9-23  Sample screen from Balloon Ace  
 
4.   Balloon Ace Game 
 Design and create a game named Balloon Ace. Figure 9-23 shows an example 
of a screen from the game. When the game runs, the user will control the move-
ment of an airplane. Yellow and green balloons will randomly appear from the 
right edge of the screen and move toward the left edge of the screen. This will 
give the appearance that the plane is flying toward the balloons. The object of 
the game is to pop the green balloons by colliding into them with the plane and 
to avoid the yellow balloons. At the end of the game the program should award 
points to the user for the number of green balloons popped and the number 
of yellow balloons avoided.  The book’s online  resources (downloadable from 
 www.pearsonhighered.com/gaddis ) provide several images that you can use to 
create the game.  
 
5.   Invisible Pizza Modification 
 Modify the PizzaBot game (see Program 9-6) so the slice of pizza is shown on the 
screen for a half second, and then becomes invisible. The user must then guide 
the robot to the invisible slice of pizza.  

This page intentionally left blank 

437
 
10.1  File Input and Output 
 CONCEPT:    When a program needs to save data for later use, it writes the data in 
a file. The data can be read from the file later.  
 The data that is stored in variables in RAM disappears once the program stops run-
ning. If a program is to retain data between the times it runs, it must have a way of 
saving it. Data is saved in a file, which is usually stored on a computer’s disk. Once 
the data is saved in a file, it will remain there after the program stops running. Data 
that is stored in a file can be retrieved and used later. 
 Most of the commercial software packages that you use store data in files. Here are 
a few examples: 
 ●  Games:  Many computer games keep data stored in files. For example, some 
games keep a list of player names with their scores stored in a file. Some 
games also allow you to save your current game status in a file so you can 
quit the game and then resume playing it without having to start from the 
beginning.  
 ●  Word Processors:   Word processing programs are used to write letters, memos, 
reports, and other documents. The documents can then be saved in files so they 
can be edited and printed.  
 ●  Image Editors:   Image editing programs are used to draw graphics and edit im-
ages such as the ones that you take with a digital camera. The images that you 
create or edit with an image editor are saved in files.  
 10.1  File Input and Output   
 10.2  Using Arrays in an AGK Program   
 10.3  Tile Maps   
 TOPICS 
 Using Files and Arrays 
with the AGK 
10 
 CHAPTER 

438 
Chapter 10  Using Files and Arrays with the AGK
 ●  Spreadsheets:   Spreadsheet programs are used to work with numerical data. 
Numbers and mathematical formulas can be inserted into the rows and columns 
of the spreadsheet. The spreadsheet can then be saved in a file for later use.  
 ●  Web Browsers:   Sometimes when you visit a Web page, the browser stores a 
small file known as a cookie on your computer. Typically, cookies contain infor-
mation about the browsing session, such the contents of a shopping cart.  
 Programs that are used in daily business operations rely extensively on files. Payroll 
programs keep employee data in files, inventory programs keep data about a com-
pany’s products in files, accounting systems keep data about a company’s financial 
operations in files, and so forth. 
 Programmers usually refer to the process of saving data in a file as “writing data” to the 
file. When a piece of data is written to a file, it is copied from a variable in RAM to the 
file. This is illustrated in  Figure  10-1  . The term  output file is used to describe a file to 
which data is written. It is called an output file because the program stores output in it. 
Cin
dy C
hand
ler 
7451
3 
18.6
5 
Cindy Chandler
char array
employeeName[]
74513
int Variable
employeeID
18.65
float Variable
payRate
Data is copied from
memory to the file.
A file on the disk
 Figure 10-1  Writing data to a file  
 The process of retrieving data from a file is known as “reading data” from the file. 
When a piece of data is read from a file, it is copied from the file into a variable in 
RAM, as shown in  Figure  10-2 . The term  input file is used to describe a file from which 
data is read. It is called an input file because the program gets input from the file.  
 In this section, we will discuss writing data to files and reading data from files. Three 
steps must always be taken when a file is used by a program: 
 1.  Open the file — Opening a file creates a connection between the file and the pro-
gram. Opening an output file creates the file on the disk and allows the program to 
write data to it. Opening an input file allows the program to read data from the file.  

 
10.1 File Input and Output 
439
 2.  Process the file — In this step, data is either written to the file (if it is an output 
file) or read from the file (if it is an input file).  
 3.  Close the file — When the program is finished using the file, the file must be 
closed. Closing a file disconnects the file from the program.  
 File Names 
 Most computer users are accustomed to the fact that a file is identified by a file name. 
For example, when you create a document with a word processor and then save the 
document in a file, you have to specify a file name. When you use a utility such as 
Windows Explorer to examine the contents of your disk, you see a list of file names. 
 Figure   10-3 shows how three files named cat.jpg, notes.txt, and resume.doc might be 
represented in Windows Explorer.  
Cin
dy C
hand
ler 
7451
3 
18.6
5 
Cindy Chandler
char array
employeeName[]
74513
int Variable
employeeID
18.65
float Variable
payRate
Data is copied from
the file into memory.
A file on the disk
 Figure 10-2  Reading data from a file  
 Figure 10-3  Three files  
 Each operating system has its own rules for naming files. Many systems, including 
Windows, support the use of file name extensions, which are short sequences of char-
acters that appear at the end of a file name, preceded by a period (which is known as 
a “dot”). For example, the file names shown in  Figure   10-3 have the extensions .jpg, 
.txt, and .doc. The extension usually indicates the type of data stored in the file. For 
example, the .jpg extension usually indicates that the file contains a graphic image that 

440 
Chapter 10  Using Files and Arrays with the AGK
is compressed according to the JPEG image standard. The .txt extension usually indi-
cates that the file contains text. The .doc extension usually indicates that the file con-
tains a Microsoft Word document.  In this book, we  will use the .dat extension with all 
the files we create in our programs. The .dat extension simply stands for “data.”  
 File Numbers 
 When you use the AGK to open a file, you assign a file number to the file. A  file number 
is an integer that you use to identify the file in subsequent operations. (Just as a sprite 
index identifies a sprite, a file number identifies a file.)  
 Opening an Output File 
 To open an output file with the AGK, you use the  agk::OpenToWrite function. Here is 
the general format for calling the function: 
 agk::OpenToWrite(  FileNumber , FileName ); 
  FileNumber  is the integer file number that you are assigning to the file, and   FileName 
is a string specifying the name of the file. Here is an example: 
 agk::OpenToWrite( 1, "GameData.dat" );  
 After this statement executes, a file named GameData.dat will be opened as an output 
file, which means that we will be able to write data to the file. The file number 1 will 
be assigned to the file. Most of the time you will want to declare a constant for the 
file number, as follows: 
 const int OUTPUT_FILE = 1; 
 agk::OpenToWrite( OUTPUT_FILE, "GameData.dat" );  
 Declaring a constant for the file number will make the code easier to read and maintain. 
 Opening an output file actually creates the file on the disk.  
 Appending Data to an Existing File 
 Calling the  agk::OpenToWrite function creates the specified file if it does not exist. By 
default, if the file already exists, its contents will be erased. You can change this be-
havior by specifying an optional third argument to the  agk::OpenToWrite function. 
Here is the general format: 
 agk::OpenToWrite(  FileNumber , FileName ,  AppendMode );  
  FileNumber  is the integer file number that you are assigning to the file.   FileName is a 
string specifying the name of the file.   AppendMode is an integer (either 0 or 1). If 
 AppendMode is 0, the specified file’s contents will be erased if the file already exists. If 
 AppendMode is 1, the specified file’s contents will be preserved if the file already exists, 
and any new data will be appended to the file’s existing contents. Here is an example 
that opens a file, preserving its existing contents: 
 const int OUTPUT_FILE = 1; 
 const int APPEND_MODE = 1; 
 agk::OpenToWrite( OUTPUT_FILE, "GameData.dat", APPEND_MODE );  

 
10.1 File Input and Output 
441
 After this code executes, any data that is written to the GameData.dat file will be 
appended to the file’s existing contents. If the file does not exist, it will be created.  
 Writing Data to an Output File 
 Once a file has been opened with the  agk::OpenToWrite function, you can write 
data to it. The AGK provides the following functions for writing data to files: 
 agk::WriteInteger ,  agk::WriteFloat, agk::WriteString , and  agk::WriteLine . We 
will look at each function.  
 The  agk::WriteInteger Function 
 The  agk::WriteInteger function writes an  int value to a file. This is the general 
format: 
 agk::WriteInteger(  FileNumber, Value ); 
  FileNumber  is the file number of a file that is open for writing, and Value is an  int 
value. The function will write the integer   value to the specified file. The following 
code shows an example. Assume that  OUTPUT_FILE is the file number for an open 
output file and  myData is an  int variable. 
 agk::WriteInteger( OUTPUT_FILE, myData );  
 The  agk::WriteFloat Function 
 The  agk::WriteFloat function writes a  float value to a file. This is the general 
format: 
 agk::WriteFloat(  FileNumber, Value ); 
  FileNumber  is the file number of a file that is open for writing, and   Value is a  float 
value. The function will write the   float value to the specified file. The following code 
shows an example. Assume that  OUTPUT_FILE is the file number for an open output 
file and  myData is a  float variable. 
 agk::WriteFloat( OUTPUT_FILE, myData );  
 The  agk::WriteString Function 
 The  agk::WriteString function writes a null-terminated string to a file. A  null-
terminated string is a string that is followed by a byte that is set to the numeric 
value 0. This is the general format: 
 agk::WriteString(  FileNumber, String ); 
  FileNumber  is the file number of a file that is open for writing, and   String is a string 
literal, or the value of a  string object that has been returned from the  c_str member 
 NOTE:    The files that an AGK program creates are located in the  My Documents > 
 AGK >  template folder. 

442 
Chapter 10  Using Files and Arrays with the AGK
function. The  agk::WriteString function will write the string to the specified file. 
Here is an example that writes a string literal to a file: 
 agk::WriteString( OUTPUT_FILE, "Activity Log" );  
 The following code shows another example. Assume that  OUTPUT_FILE is the file num-
ber for an open output file, and  name is a  string object. 
 agk::WriteString( OUTPUT_FILE, name.c_str() );  
 The  agk::WriteLine Function 
 The  agk::WriteLine function writes a string to a file and ends the string with a new-
line character. This is the general format: 
 agk::WriteLine (  FileNumber, String );  
  FileNumber  is the file number of a file that is open for writing, and   String is a string 
literal, or the value of a  string object that has been returned from the  c_str member 
function. The  agk::WriteLine function will write the string to the specified file, fol-
lowed by a newline character. Here is an example that writes a string literal to a file: 
 agk::WriteString( OUTPUT_FILE, "Activity Log" );  
 Closing an Output File 
 Once a program is finished writing data to a file, it should use the  agk::CloseFile 
function to close the file. Closing a file disconnects the program from the file and frees 
the file number so it can be used with another file. Here is the general format of the 
 agk::CloseFile function: 
 agk::CloseFile( FileNumber );  
  FileNumber  is the file number of a file that is currently open. After the  agk::CloseFile 
function executes, the file associated with that file number will be closed. The follow-
ing statement shows an example. Assume that  OUTPUT_FILE is a constant that specifies 
the file number of an open file. 
 agk::CloseFile(OUTPUT_FILE);  
 Opening an Input File 
 To open an input file with the AGK, use the  agk::OpenToRead function. Here is the 
general format for calling the function: 
 agk::OpenToRead(  FileNumber, FileNam e ); 
  FileNumber  is the integer file number that you are assigning to the file.   FileName is a 
string specifying the name of the file. The following code shows an example. Assume 
that  INPUT_FILE is a constant that has been declared to specify the file number. 
 agk::OpenToRead( INPUT_FILE, "GameData.dat" );  
 After this statement executes, a file named GameData.dat will be opened as an input 
file. This means that we will be able to read data from the file. The file number 
specified by the  INPUT_FILE constant will be assigned to the file. 

 
10.1 File Input and Output 
443
 When opening an input file, the file must exist in the  My Documents >  AGK > 
 template folder, or the  agk::OpenToRead function will fail. You can use the 
 agk::GetFileExists  function to make sure the file exists before attempting to 
open it, as shown here:  
 // Constant for the file number 
 const int INPUT_FILE = 1; 
 // If the GameData.dat file exists, open it. 
 if ( agk::GetFileExists("GameData.dat") ) 
 { 
     agk::OpenToRead( INPUT_FILE, "GameData.dat" ); 
 } 
 Reading Data from an Input File 
 Once a file has been opened with the  agk::OpenToRead function, you can read data 
from it. The AGK provides several functions for reading data from files. We will discuss 
four of the most useful functions:  agk::ReadInteger ,  agk::ReadFloat ,  agk::ReadString , 
and  agk::ReadLine .  
 The  agk::ReadInteger  Function 
 The  agk::ReadInteger function is a value-returning function. You pass the file number 
of a file that is open for reading as an argument. The function reads a value from the 
file and returns that value as an  int . The following code shows an example. Assume 
that  INPUT_FILE is the file number for an open input file and  myData is an  int variable. 
 myData = agk::ReadInteger( INPUT_FILE );  
 The  agk::ReadFloat Function 
 The  agk::ReadFloat function is a value-returning function. You pass the file number 
of a file that is open for reading as an argument. The function reads a value from 
the file and returns that value as a  float . The following code shows an example. 
Assume that  INPUT_FILE is the file number for an open input file and  myData is a 
 float variable. 
 myData = agk::ReadFloat( INPUT_FILE );  
 The  agk::ReadString Function 
 The  agk::ReadString function is a value-returning function. You pass the file number 
of a file that is open for reading as an argument. The function reads a null-terminated 
string from the file and returns that string. (Any string that was written to the file with 
the  agk::WriteString function can be read from the file with the  agk::ReadString 
 NOTE:    A file must be located in the  My Documents >  AGK >  template folder to 
be opened by an AGK program. 

444 
Chapter 10  Using Files and Arrays with the AGK
function.) The following code shows an example. Assume that  INPUT_FILE is the file 
number for an open input file, and  str is a  string object. 
 str = agk::ReadString(INPUT_FILE);  
 After this statement executes, a string will be read from the file specified by  INPUT_FILE . 
The string will be assigned to the  str object.  
 The  agk::ReadLine Function 
 The  agk::ReadLine function is a value-returning function. You pass the file number 
of a file that is open for reading as an argument. The function reads a string that is 
terminated with a newline character from the file and returns that string. (Any string 
that was written to the file with the  agk::WriteLine function can be read from the 
file with the  agk::ReadLine function.) The following code shows an example. Assume 
that  INPUT_FILE is the file number for an open input file, and  str is a  string object. 
 str = agk::ReadLine(INPUT_FILE);  
 After this statement executes, a string will be read from the file specified by  INPUT_FILE . 
The string will be assigned to the  str object.  
 Closing an Output File 
 Once a program is finished reading data from a file, it should use the  agk::CloseFile 
function to close the file. As previously mentioned, closing a file disconnects the pro-
gram from the file and frees the file number so it can be used with another file. The 
following statement shows an example. Assume that  INPUT_FILE is a constant that 
specifies the file number of an open file. 
 agk::CloseFile(INPUT_FILE);  
 Determining If a File Is Open 
 In some circumstances you might need to determine if a file is opened before perform-
ing operations with the file. This can be done with the  agk::FileIsOpen function. You 
pass a file number as an argument to  agk::FileIsOpen , and it returns 1 (true) if the 
file is open or 0 (false) if the file is not open. Here is an example: 
 if ( agk::FileIsOpen(INPUT_FILE) ) 
 { 
     // Code here reads from the file. 
 } 
 else 
 { 
     agk::Print("Error: The file is not open."); 
 } 
 You can use the  agk::FileIsOpen function to test both input and output files. 
 Let’s look at an example program that writes data to a file. The following  In the 
Spotlight section shows how a game can save its highest score in a file.  

 
10.1 File Input and Output 
445
 In the Spotlight: 
 Saving a Game’s High Score 
 Many games keep track of the highest score that has been earned in the game. When 
a player beats the current high score, he or she is usually congratulated, and their 
score replaces the old high score. This provides motivation for the player to continue 
playing the game to beat the current high score. 
 A game that keeps track of the high score usually works something like this: A file is 
kept on the disk that contains the highest score achieved so far. When the player has 
finished the game, the program reads the file to get the high score. If the player’s score 
is greater than the high score, the player is congratulated, and then the player’s score 
is written to the file. The first time the game is played, the file will not exist. In that 
case, the file is created, and the player’s score is written to it. 
 To demonstrate this, Program 10-1 shows a  modified version of the  Bug Zapper 
 game that was presented in  Chapter   8 .  Recall that the  Bug Zapper game displays an 
animated sprite of a bug. The user zaps the bug by clicking it with the mouse. When 
this happens, a new bug appears at a random location on the screen. The game will 
run for 10 seconds before ending. The object of the game is to zap as many bugs as 
possible within the allotted time. When the game ends, a screen displays the user’s 
score, which is the number of bugs that were zapped. This modified version of the 
game keeps the high score in a file named BugZapperHighScore.dat. Each time the 
user beats the high score, he or she is congratulated with the screen shown in  Figure 
 10-4 , and then the user’s score is written to the BugZapperHighScore.dat file, replac-
ing the value previously stored there. 
 Because we discussed the original Bug Zapper game in detail in  Chapter   8 , we 
will discuss only the modifications that were made in this version. First, we’ve 
added a new state that the game can be in.  Line 38 declares a constant named 
 CHECK_FOR_HIGH_SCORE . This constant represents the state that the game is in 
immediately after the 10 seconds of game play has expired, but before the clos-
ing screen is displayed. Notice that in line 200 (which executes as soon as we 
determine that 10 seconds has passed), we assign  CHECK_FOR_HIGH_SCORE to the 
 g_gameState variable. 
 Inside the  app::Loop function, the  switch statement jumps to line 111 when 
the  g_gameState variable is set to  CHECK_FOR_HIGH_SCORE . Line 113 calls the 
 checkForHighScore function. The  checkForHighScore function is defined in lines 
226 through 256. Inside the function, the  if statement in line 230 determines if the 
BugZapperHighScore.dat file exists. If it does, lines 233 and 234 open the file for 
reading, line 237 reads an integer from the file (the high score) and assigns it to the 
 g_prevHighScore variable, and line 240 closes the file. If the BugZapperHighScore.
dat file does not exist, line 244 assigns 0 to the  g_prevHighScore variable. (The 
BugZapperHighScore.dat file will not exist the first time the program runs.) Next, 
the  if statement in line 249 determines if the current score is higher than the high 
score that was read from the file. If so, we have a new high score, and line 251 
calls the  newHighScore function. Then, line 255 sets the  g_gameState variable to 
 GAME_OVER . 
VideoNote
Saving a Game’s 
High Score

446 
Chapter 10  Using Files and Arrays with the AGK
 The  newHighScore function is defined in lines 260 through 272. This function simply 
writes the current score to the BugZapperHighScore.dat file. Lines 264 and 265 open 
the file for writing (erasing its contents if the file already exists), line 268 writes the 
value of the  g_bugsZapped variable to the file, and line 271 closes the file. 
 Program 10-1 
  (BugZapperVersion2) 
  1 // Includes, namespace and prototypes 
  2 #include "template.h" 
  3 using namespace AGK; 
  4 app App; 
  5  
  6 // Function prototypes 
  7 void generateNewBug(); 
  8 void displayIntro(); 
  9 void hideIntro(); 
 10 void playGame(); 
 11 void checkForHighScore(); 
 12 void newHighScore(); 
 13 void closingScreen(); 
 14  
 15 // Constants for the screen resolution 
 16 const int SCREEN_WIDTH  = 640; 
 17 const int SCREEN_HEIGHT = 480; 
 18  
 19 // Constants for sprites 
 20 const int INTRO_INDEX = 1; 
 21 const int GRASS_INDEX = 2; 
 22 const int BUG_INDEX   = 3; 
 23  
 24 // Constant for the sound file 
 25 const int BOINK_SOUND = 1; 
 26  
 27 // Constants for animation 
 28 const int FRAME_WIDTH  = 64; 
 29 const int FRAME_HEIGHT = 64; 
 30 const int FRAME_COUNT  = 2; 
 31  
 32 // Constant for game time 
 33 const int MAX_TIME = 10; 
 34  
 35 // Constants for the possible game states. 
 36 const int GAME_JUST_STARTED    = 0; 
 37 const int GAME_IN_PLAY         = 1; 
 38 const int CHECK_FOR_HIGH_SCORE = 2; 
 39 const int GAME_OVER            = 3; 
 40  
 41 // Constant for the high score file number 
 42 const int HIGH_SCORE_FILE = 1; 
 43  
 44 // Global variables 
 45 int g_bugsZapped = 0;        // Counter for bugs zapped 
 46 int g_prevHighScore = 0;     // Previous high score 

 
10.1 File Input and Output 
447
 47 int g_gameState = GAME_JUST_STARTED;  // Game state 
 48  
 49 // Begin app, called once at the start 
 50 void app::Begin( void ) 
 51 { 
 52    // Set the virtual resolution. 
 53    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 54  
 55    // Set the text in the window title bar. 
 56    agk::SetWindowTitle("Bug Zapper"); 
 57  
 58    // Create the background sprite. 
 59    agk::CreateSprite(GRASS_INDEX, "BugZapper/Grass.png"); 
 60  
 61    // Create the bug sprite. 
 62    agk::CreateSprite(BUG_INDEX, "BugZapper/Bug.png"); 
 63  
 64    // Create the intro screen sprite. 
 65    agk::CreateSprite(INTRO_INDEX, "BugZapper/Intro.png"); 
 66  
 67    // Load the sound file. 
 68    agk::LoadSound(BOINK_SOUND, "BugZapper/Boink.wav"); 
 69  
 70    // Randomly position the bug. 
 71    generateNewBug(); 
 72  
 73    // Set the sprite animation 
 74    agk::SetSpriteAnimation(BUG_INDEX, FRAME_WIDTH, 
 75                          FRAME_HEIGHT, FRAME_COUNT); 
 76  
 77    // Play the bug animation. 
 78    agk::PlaySprite(BUG_INDEX); 
 79 } 
 80  
 81 // Main loop, called every frame 
 82 void app::Loop ( void ) 
 83 { 
 84    // Determine the game state and 
 85    // act accordingly. 
 86    switch (g_gameState) 
 87    { 
 88    case GAME_JUST_STARTED: 
 89       // Display the intro screen. 
 90       displayIntro(); 
 91  
 92       // Check for a key press. 
 93       if (agk::GetRawLastKey()) 
 94       { 
 95          // Hide the intro screen 
 96          hideIntro(); 
 97  
 98          // Change the game state. 
 99          g_gameState = GAME_IN_PLAY; 
 100  

448 
Chapter 10  Using Files and Arrays with the AGK
 101          // Reset the timer. 
 102          agk::ResetTimer(); 
 103       } 
 104       break; 
 105  
 106    case GAME_IN_PLAY: 
 107       // Engage in game play. 
 108       playGame(); 
 109       break; 
 110  
 111    case CHECK_FOR_HIGH_SCORE: 
 112       // Get the high score so far. 
 113       checkForHighScore(); 
 114  
 115    case GAME_OVER: 
 116       // Display the closing screen. 
 117       closingScreen(); 
 118       break; 
 119    }; 
 120  
 121    // Update the screen. 
 122    agk::Sync(); 
 123 } 
 124  
 125 // Called when the app ends 
 126 void app::End ( void ) 
 127 { 
 128 } 
 129  
 130 // The generateNewBug function generates a new bug at 
 131 // random location. 
 132 void generateNewBug() 
 133 { 
 134     // Get the bug's width and height. 
 135     int bugWidth = agk::GetSpriteWidth(BUG_INDEX); 
 136     int bugHeight = agk::GetSpriteHeight(BUG_INDEX); 
 137  
 138     // Generate a new location. 
 139     int x = agk::Random(0, SCREEN_WIDTH - bugWidth); 
 140     int y = agk::Random(0, SCREEN_HEIGHT - bugHeight); 
 141  
 142     // Put the bug at that location. 
 143     agk::SetSpritePosition(BUG_INDEX, x, y); 
 144 } 
 145  
 146 // The displayIntro function hides the grass and the 
 147 // bug sprite, and makes the intro screen visible. 
 148 void displayIntro() 
 149 { 
 150    // Make the grass and bug invisible. 
 151    agk::SetSpriteVisible(GRASS_INDEX, 0); 
 152    agk::SetSpriteVisible(BUG_INDEX, 0); 
 153  
 154    // Make the intro screen visible. 
 155    agk::SetSpriteVisible(INTRO_INDEX, 1); 
 156 } 

 
10.1 File Input and Output 
449
 157  
 158 // The hideIntro function hides the intro screen 
 159 // and makes the grass and bug visible. 
 160 void hideIntro() 
 161 { 
 162    agk::SetSpriteVisible(INTRO_INDEX, 0); 
 163    agk::SetSpriteVisible(BUG_INDEX, 1); 
 164    agk::SetSpriteVisible(GRASS_INDEX, 1); 
 165 } 
 166  
 167 // The playGame function processes a frame of game play. 
 168 void playGame() 
 169 { 
 170    // Variables for mouse coordinates 
 171    float mouseX, mouseY; 
 172  
 173    // Do we still have time left? 
 174    if (agk::Timer() < MAX_TIME) 
 175    { 
 176       // Determine if the left mouse button was pressed. 
 177       if(agk::GetRawMouseLeftPressed()) 
 178       { 
 179          // Get the mouse pointer location. 
 180          mouseX = agk::GetRawMouseX(); 
 181          mouseY = agk::GetRawMouseY(); 
 182  
 183          // Check to see if the bug was hit. 
 184          if (agk::GetSpriteHit(mouseX, mouseY) == BUG_INDEX) 
 185          { 
 186             // Play the boink sound. 
 187             agk::PlaySound(BOINK_SOUND); 
 188  
 189             // Update the count. 
 190             g_bugsZapped++; 
 191  
 192             // Generate a new bug. 
 193             generateNewBug(); 
 194          } 
 195       } 
 196    } 
 197    else 
 198    { 
 199       // Time is up, check for a high score. 
 200       g_gameState = CHECK_FOR_HIGH_SCORE; 
 201    } 
 202 } 
 203  
 204 // The closingScreen function displays the closing screen. 
 205 void closingScreen() 
 206 { 
 207    // Hide the bug and the grass. 
 208    agk::SetSpriteVisible(GRASS_INDEX, 0); 
 209    agk::SetSpriteVisible(BUG_INDEX, 0); 
 210  
 211    // Display the results. 
 212    agk::PrintC("Number of bugs zapped: "); 

450 
Chapter 10  Using Files and Arrays with the AGK
 213    agk::Print(g_bugsZapped); 
 214  
 215    if (g_bugsZapped > g_prevHighScore) 
 216    { 
 217       // Congratulate the user. 
 218       agk::Print("Congratulations!"); 
 219       agk::Print("You set a new high score!"); 
 220    } 
 221 } 
 222  
 223 // The checkForHighScore function reads the high score from 
 224 // the BugZapperHighScore.dat file and determines whether 
 225 // the user's score is the new high score. 
 226 void checkForHighScore() 
 227 { 
 228    // If the BugZapperHighScore.dat file exists, open it 
 229    // and read its value. Otherwise, set highScore to 0. 
 230    if (agk::GetFileExists("BugZapperHighScore.dat")) 
 231    { 
 232       // Open the file. 
 233       agk::OpenToRead(HIGH_SCORE_FILE, 
 234                      "BugZapperHighScore.dat"); 
 235  
 236       // Read the high score. 
 237       g_prevHighScore = agk::ReadInteger(HIGH_SCORE_FILE); 
 238  
 239       // Close the file. 
 240       agk::CloseFile(HIGH_SCORE_FILE); 
 241    } 
 242    else 
 243    { 
 244       g_prevHighScore = 0; 
 245    } 
 246  
 247    // If this is the new high score, write it to 
 248    // the file. 
 249    if (g_bugsZapped > g_prevHighScore) 
 250    { 
 251       newHighScore(); 
 252    } 
 253  
 254    // Change the game state to end the game. 
 255    g_gameState = GAME_OVER; 
 256 } 
 257  
 258 // The newHighScore function writes the current score to 
 259 // the BugZapperHighScore.dat 
 260 void newHighScore() 
 261 { 
 262    // Open the BugZapperHighScore.dat file for writing. 
 263    // If the file already exists, this will replace it. 
 264    agk::OpenToWrite(HIGH_SCORE_FILE, 
 265                   "BugZapperHighScore.dat"); 
 266  

 
10.1 File Input and Output 
451
 267    // Write the current score to the file. 
 268    agk::WriteInteger(HIGH_SCORE_FILE, g_bugsZapped); 
 269  
 270    // Close the file. 
 271    agk::CloseFile(HIGH_SCORE_FILE); 
 272 }  
 Figure 10-4  Closing screen with high score message  
 In the Spotlight: 
 Detecting the End of a File 
 Quite often, a program must read the contents of a file without knowing the num-
ber of items that are stored in the file. This presents a problem if you want to 
write a program that processes all the items in the file, regardless of how many 
there are. You can write a loop that reads all the items in a file, or in an AGK 
program you can write code in the  app::Loop function that repeatedly reads items 
from a file, but an error will occur if the program attempts to read beyond the last 
item in the file. 
 To prevent a program from reading beyond the end of a file, the AGK provides a 
function named  agk::FileEOF . You pass a file number to the  agk::FileEOF function, 
and it returns 1 (true) if the last item in the file has been read. If there are more items 
to read from the file, the function returns 0 (false). The following code shows how 
you use the  agk::FileEOF function to determine whether the end of the file has not 
been reached. Assume  INPUT_FILE a file number. 
 if (!agk::FileEOF(INPUT_FILE)) 
 { 
    // Read an item from the file and process it. 
 } 
 To demonstrate how this technique works, we will look at Programs 10-2 and 10-3. 
Program 10-2 generates a set of random color values (as integers) and writes them 
to a file. Then, Program 10-3 reads each set of color values from the file. Each time 
Program 10-3 reads a set of color values from the file, it clears the screen to the speci-
fied color. The program reads color values from the file until it encounters the end 
of the file. 

452 
Chapter 10  Using Files and Arrays with the AGK
 Program 10-2 
 (WriteRandomColors) 
 1 // Includes, namespace and prototypes 
 2 #include "template.h" 
 3 using namespace AGK; 
 4 app App; 
 5  
 6 // Constants for the screen resolution 
 7 const int SCREEN_WIDTH = 640; 
 8 const int SCREEN_HEIGHT = 480; 
 9  
 10 // Constant for the file number 
 11 const int OUTPUT_FILE = 1; 
 12  
 13 // Constant for the number of colors 
 14 const int MAX_COLORS = 10; 
 15  
 16 // Global variable to count the colors 
 17 int g_numColors = 0; 
 18  
 19 // Begin app, called once at the start 
 20 void app::Begin( void ) 
 21 { 
 22    // Set the virtual resolution. 
 23    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 24  
 25    // Open the output file. 
 26    agk::OpenToWrite(OUTPUT_FILE, "Colors.dat"); 
 27 } 
 28  
 29 // Main loop, called every frame 
 30 void app::Loop ( void ) 
 31 { 
 32    // Variables to hold color channel values 
 33    int red, green, blue; 
 34  
 35    if (g_numColors < MAX_COLORS) 
 36    { 
 37       // Generate random color values 
 38       red = agk::Random(0, 255); 
 39       green = agk::Random(0, 255); 
 40       blue = agk::Random(0, 255); 
 41  
 42       // Write the color values to the file. 
 43       agk::WriteInteger(OUTPUT_FILE, red); 
 44       agk::WriteInteger(OUTPUT_FILE, green); 
 45       agk::WriteInteger(OUTPUT_FILE, blue); 
 46  
 47       // Increment the color counter. 
 48       g_numColors++; 
 49    } 
 50    else 
 51    { 
 52       agk::Print("Finished!"); 
 53    } 

 
10.1 File Input and Output 
453
 54  
 55    // Update the screen. 
 56    agk::Sync(); 
 57 } 
 58  
 59 // Called when the app ends 
 60 void app::End ( void ) 
 61 { 
 62    // Close the file. 
 63    agk::CloseFile(OUTPUT_FILE); 
 64 } 
 Let’s take a closer look at Program 10-2. Lines 7 and 8 declare the usual constants 
that we will use to set the virtual resolution. Line 11 declares an  int constant named 
 OUTPUT_FILE , set to 1, which we will use as a file number. Line 14 declares an  int con-
stant named  MAX_COLORS , set to 10, which we will use as the number of colors to gen-
erate and save to the file. Line 17 declares a global  int variable named  g_numColors , 
initialized with 0, which we will use to count the number of colors that are written 
to the file. 
 Inside the  app::Begin function, line 23 sets the virtual resolution, and line 26 opens a 
file named Colors.dat for writing. Inside the  app::Loop function, line 33 declares the 
local  int variables  red ,  green , and  blue . These variables will be assigned the random 
numbers that we generate for each color’s red, green, and blue channels. 
 The  if statement that begins in line 35 determines whether we have written the 
maximum number of colors yet. If not, lines 38 through 40 generate three random 
integers in the range of 0 through 255 and assign them to the  red ,  green , and  blue 
variables. Then, lines 43 through 45 write the values to the file. Line 48 increments 
the  g_numColors variable. 
 If the maximum number of colors has been written, the program jumps to the 
 else clause in line 50, and line 52 prints “Finished!” on the screen. Line 56 calls 
the  agk::Sync function to update the screen. Inside the  app::End function, line 63 
closes the file. 
 Next, we look at Program 10-3, which opens the Colors.dat file and reads the values 
from it. 
 Program 10-3 
 (ReadRandomColors) 
 1 // Includes, namespace and prototypes 
 2 #include "template.h" 
 3 using namespace AGK; 
 4 app App; 
 5  
 6 // Constants for the screen resolution, refresh rate, 
 7 // and refresh mode 
 8 const int SCREEN_WIDTH = 640; 
 9 const int SCREEN_HEIGHT = 480; 
 10 const int REFRESH_RATE = 1; 
 11 const int REFRESH_MODE = 0; 

454 
Chapter 10  Using Files and Arrays with the AGK
 12  
 13 // Constant for the file number 
 14 const int INPUT_FILE = 1; 
 15  
 16 // Begin app, called once at the start 
 17 void app::Begin( void ) 
 18 { 
 19    // Set the virtual resolution. 
 20    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 21  
 22    // Set the sync rate. 
 23    agk::SetSyncRate(REFRESH_RATE, REFRESH_MODE); 
 24  
 25    // Open the output file. 
 26    agk::OpenToRead(INPUT_FILE, "Colors.dat"); 
 27 } 
 28  
 29 // Main loop, called every frame 
 30 void app::Loop ( void ) 
 31 { 
 32    // Variables to hold color channel values 
 33    int red, green, blue; 
 34  
 35    // If not at the end of the file, read the next 
 36    // set of color values and clear the screen to 
 37    // that color. 
 38    if (!agk::FileEOF(INPUT_FILE)) 
 39    { 
 40       // Generate random color values 
 41       red = agk::ReadInteger(INPUT_FILE); 
 42       green = agk::ReadInteger(INPUT_FILE); 
 43       blue = agk::ReadInteger(INPUT_FILE); 
 44  
 45       // Set the screen's clear color. 
 46       agk::SetClearColor(red, green, blue); 
 47  
 48       // Clear the screen. 
 49       agk::ClearScreen(); 
 50    } 
 51    else 
 52    { 
 53       agk::Print("Finished!"); 
 54    } 
 55  
 56    // Update the screen. 
 57    agk::Sync(); 
 58 } 
 59  
 60 // Called when the app ends 
 61 void app::End ( void ) 
 62 { 
 63    // Close the file. 
 64    agk::CloseFile(INPUT_FILE); 
 65 } 

 
10.1 File Input and Output 
455
 Let’s take a closer look at Program 10-3. Lines 8 and 9 declare the constants that 
we will use to set the virtual resolution. Line 10 declares an  int constant named 
 REFRESH_RATE , set to 1, which we will use to set the sync rate to 1 frame per second. 
Line 11 declares an  int constant named  REFRESH_MODE , set to 0, which we will use 
to set the refresh mode. (Recall that the refresh mode 0 is the most energy efficient 
mode.) Line 14 declares an  int constant named  INPUT_FILE , set to 1, which we will 
use as a file number. 
 Inside the  app::Begin function, line 20 sets the virtual resolution, line 23 sets the sync 
rate to 1 frame per second, and line 26 opens a file named Colors.dat for writing. 
Inside the  app::Loop function, line 33 declares the local  int variables  red ,  green , and 
 blue . These variables will be assigned the color values that are read from the file. 
 The  if statement that begins in line 38 determines whether or not we have 
reached the end of the file. If we have not, lines 41 through 43 read three integers 
from the file and assign them to the  red ,  green , and  blue variables. Then, line 46 
uses these values to set the screen’s clear color. Line 49 clears the screen to the 
current color. 
 If the maximum number of colors has been written, the program jumps to the 
 else clause in line 51, and line 53 prints “Finished!” on the screen. Line 57 calls 
the  agk::Sync function to update the screen. Inside the  app::End function, line 64 
closes the file.  
 In the Spotlight: 
 Writing a Log File 
 Sometimes, for debugging purposes, it is helpful to for a program to keep a log of its 
activity in a file. Each time the program performs an operation, it writes a line of 
information to a file describing what it just did. Such a file, known as a  log file , usu-
ally contains pure text so it can be opened in a text editor such as Notepad. 
 In an AGK program, you use the  agk::WriteString and  agk::WriteLine functions to 
write pure text to a file. These functions simply write a string to an open file. Recall 
that the  agk::WriteLine function writes a newline character after the string, which 
starts a new line in the file when viewed in a text editor. 
 If you want to write the contents of an integer or floating-point value to a file as 
text, you must use the  agk::Str function to convert the value to a string. Here is the 
general format of the function: 
 agk::Str( NumericValue ) 
 In the general format,   NumericValue is an integer or a floating-point numeric value. 
The function returns that value as a string. For example, assume that number is an 
 int or a  float variable and that  OUTPUT_FILE is the file number of a file that is opened 
for writing. The following statement writes the contents of the number variable, as 
text, to the file: 
 agk::WriteString( agk::Str(number) );  

456 
Chapter 10  Using Files and Arrays with the AGK
 You can also use the  agk::WriteLine function if you want the value to appear on its 
own line in the file: 
 agk::WriteLine( agk::Str(number) );  
 Program 10-4 shows a demonstration of how a log file can be kept by a program. 
 This is a modified version of the DirectionKeys project that was shown in  Chapter  8 . 
Recall that the  program displays a fish sprite (shown in  Figure   10-5 ) that can be moved 
around the screen with the arrow keys. Each time the user presses an arrow key, the 
program records the amount of movement in a log file. 
 Program 10-4 
  (DirectionKeysLog) 
 1 // Includes, namespace and prototypes 
 2 #include "template.h" 
 3 using namespace AGK; 
 4 app App; 
 5  
 6 // Constants 
 7 const int SCREEN_WIDTH  = 640;  // Screen width 
 8 const int SCREEN_HEIGHT = 480;  // Screen height 
 9 const int SPRITE_INDEX  = 1;    // Sprite index 
 10 const int OUTPUT_FILE   = 1;    // File number 
 11  
 12 // Begin app, called once at the start 
 13 void app::Begin( void ) 
 14 { 
 15    // Set the window title. 
 16    agk::SetWindowTitle("Direction Keys"); 
 17  
 18    // Set the virtual resolution. 
 19    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 20  
 21    // Create the sprite. 
 22    agk::CreateSprite(SPRITE_INDEX, "fish.png"); 
 23  
 24    // Open the activity log file. 
 25    agk::OpenToWrite(OUTPUT_FILE, "ActivityLog.txt"); 
 26 } 
 27  
 28 // Main loop, called every frame 
 29 void app::Loop ( void ) 
 30 { 
 31    // Get the direction as input from the keyboard. 
 32    float directionX = agk::GetDirectionX(); 
 33    float directionY = agk::GetDirectionY(); 
 34  
 35    // Log any movement along the  X -axis. 
 36    if (directionX != 0) 
 37    { 
 38       agk::WriteString(OUTPUT_FILE, "X movement: "); 
 39       agk::WriteLine(OUTPUT_FILE, agk::Str(directionX)); 
 40    } 

 
10.1 File Input and Output 
457
 41  
 42    // Log any movement along the  Y -axis. 
 43    if (directionY != 0) 
 44    { 
 45       agk::WriteString(OUTPUT_FILE, "Y movement: "); 
 46       agk::WriteLine(OUTPUT_FILE, agk::Str(directionY)); 
 47    } 
 48  
 49    // Get the sprite position. 
 50    float spriteX = agk::GetSpriteX(SPRITE_INDEX); 
 51    float spriteY = agk::GetSpriteY(SPRITE_INDEX); 
 52  
 53    // Calculate how far the sprite will move. 
 54    float moveX = spriteX + directionX; 
 55    float moveY = spriteY + directionY; 
 56  
 57    // Set the sprite position. 
 58    agk::SetSpritePosition(SPRITE_INDEX, moveX, moveY); 
 59  
 60    // Refresh the screen. 
 61    agk::Sync(); 
 62 } 
 63  
 64 // Called when the app ends 
 65 void app::End ( void ) 
 66 { 
 67    // Close the activity log file. 
 68    agk::CloseFile(OUTPUT_FILE); 
 69 } 
 Figure 10-5  Output of Program 10-4  

 Let’s take a closer look at Program 10-4. Lines 7 and 8 declare the usual constants 
that we will use to set the virtual resolution. Line 9 declares an  int constant named 
 SPRITE_INDEX , set to 1, which we will use as a sprite index, and line 10 declares an  int 
constant named  OUTPUT_FILE , set to 1, which we will use as a file number. 
 Inside the  app::Begin function, line 16 sets the window’s title bar text, and line 19 sets 
the virtual resolution. Line 22 creates the fish sprite, and line 25 opens the ActivityLog.txt 
file for writing. 
 Inside the  app::Loop function, lines 32 and 33 call the  agk::GetDirectionX and 
 agk::GetDirectionY functions to determine whether the arrow keys are being 
pressed. The values returned from these functions are assigned to the  directionX and 
 directionY variables. 
 The  if statement in line 36 determines whether the left or right arrow was pressed. 
(Recall that the  agk::GetDirectionX function returns 0 if neither the left or right 
arrow is being pressed. If one of these keys is being pressed, it returns negative or 
a positive number.) If the left or right arrow key is being pressed, line 38 writes the 
string “X movement:”, and then line 39 writes the value of the  directionX variable, 
converted to a string. Notice that line 39 uses the  agk::WriteLine function, which 
writes a string to the file, followed by a newline character to end the line. 
 The  if statement in line 43 determines whether the up or down arrow was pressed. 
(Recall that the  agk::GetDirectionY function returns 0 if neither the up or down 
arrow is being pressed. If one of these keys is being pressed, it returns negative or a 
positive number.) If the up or down arrow key is being pressed, line 45 writes the 
string “Y movement:”, and then line 46 writes the value of the  directionY variable, 
converted to a string. Line 46 uses the  agk::WriteLine function, which writes a string 
to the file, followed by a newline character to end the line. 
 The rest of the  app::Loop function calculates the fish sprite’s new position and moves 
it to that location. In the  app::End function, line 68 closes the file. 
 Figure   10-6 shows an example of the ActivityLog.txt file, opened in Notepad.  
 Figure 10-6  Example activity log generated by Program 10-4  
458 
Chapter 10  Using Files and Arrays with the AGK
 Checkpoint 
  10.1.   What is an input file? What is an output file?  
  10.2.   What three steps are always taken when a file is used by a program?  
  10.3.   How are files identified on a computer disk?  

 
10.2 Using Arrays in an AGK Program 
459
  10.4.  How are files identified in an AGK program?  
  10.5.  What AGK function do you use to perform the following? 
 •  Open a fi le for writing  
 •  Open a fi le for reading  
 •  Write an integer to a fi le 
 •  Write a fl oating-point number to a fi le  
 •  Write a null-terminated string to a fi le  
 •  Write a string, followed by a newline, to a fi le  
 •  Read an integer from a fi le  
 •  Read a fl oating-point number from a fi le  
 •  Read a null-terminated string from a fi le  
 •  Read a newline-terminated string from a fi le  
 •  Close a fi le 
  10.6.  What is the difference between append mode 0 and append mode 1 when 
opening an output file?  
  10.7.  Describe the  agk::FileEOF function.  
 
10.2  Using Arrays in an AGK Program  
 CONCEPT:    Arrays can be used for a variety of tasks in a game, such as simulating 
a card deck, keeping a list of sprites, or creating a tile-based screen.  
 In  Chapter  6 you learned how to use arrays in a standard C++ program.  Arrays are  also 
 useful in AGK programs to hold sets of data such as sprite numbers, image numbers, and 
other items. In this section we will look at examples in which an array is used to represent 
a deck of cards. We will also look at a programming technique known as tile mapping, 
in which a two-dimensional array is used to construct a game’s background imagery.  
 In the Spotlight: 
 Using an Array as a Deck of Cards 
 Card games are very popular, and in many ways, a deck of cards is similar to an array. 
To demonstrate this, we will look at an AGK program that creates a set of poker card 
sprites and uses an  int array to hold the sprite indices. When the program runs, it 
initially appears as shown in  Figure   10-7  . The image of a card backface is shown to 
represent the deck of cards. Each time the user clicks the virtual button that appears 
in the lower-right corner, a card is dealt from the deck and appears faceup. The pro-
gram has a total of 9 card sprites, and when all 9 cards have been dealt from the deck, 
the screen appears as shown in  Figure   10-8  . 
VideoNote
Using an Array as 
a Deck of Cards

460 
Chapter 10  Using Files and Arrays with the AGK
 Program 10-5 
 (DealCards) 
  1 // Includes, namespace and prototypes 
  2 #include "template.h" 
  3 #include <string>      // Needed for string class 
  4 using namespace std;   // Needed for string class 
 Figure 10-7  Initial screen of the DealCards program  
 Figure 10-8  Screen after all cards are dealt  

 
10.2 Using Arrays in an AGK Program 
461
  5 using namespace AGK; 
  6 app App; 
  7  
  8 // Function prototype 
  9 void createCardSprites(); 
 10  
 11 // Constants for the screen resolution 
 12 const int SCREEN_WIDTH  = 640;  // Screen width 
 13 const int SCREEN_HEIGHT = 480;  // Screen height 
 14  
 15 // Constants for the virtual button 
 16 const int   BUTTON_INDEX = 1; 
 17 const int   BUTTON_SIZE  = 100; 
 18 const float BUTTON_X     = 580; 
 19 const float BUTTON_Y     = 420; 
 20  
 21 // Constants for card sprite numbers 
 22 const int HEARTS_ACE = 1; 
 23 const int HEARTS_2   = 2; 
 24 const int HEARTS_3   = 3; 
 25 const int HEARTS_4   = 4; 
 26 const int HEARTS_5   = 5; 
 27 const int HEARTS_6   = 6; 
 28 const int HEARTS_7   = 7; 
 29 const int HEARTS_8   = 8; 
 30 const int HEARTS_9   = 9; 
 31 const int BACKFACE   = 10; 
 32  
 33 // Constants for card screen placement 
 34 const float STARTING_X    = 25; 
 35 const float CARD_Y        = 100; 
 36 const float CARD_DISTANCE = 10; 
 37 const float BACKFACE_X    = 25; 
 38 const float BACKFACE_Y    = 200; 
 39  
 40 // Constant for the number of cards 
 41 const int NUM_CARDS = 9; 
 42  
 43 // Array holding the card sprite numbers. 
 44 int g_cardSprites[NUM_CARDS] = { HEARTS_ACE, HEARTS_2, 
 45    HEARTS_3, HEARTS_4, HEARTS_5, HEARTS_6, HEARTS_7, 
 46    HEARTS_8, HEARTS_9 }; 
 47  
 48 // Array holding the names of the card image files 
 49 string g_imageFiles[NUM_CARDS] = { "Cards/Ace_hearts.png", 
 50              "Cards/2_hearts.png", "Cards/3_hearts.png", 
 51              "Cards/4_hearts.png", "Cards/5_hearts.png", 
 52              "Cards/6_hearts.png", "Cards/7_hearts.png", 
 53              "Cards/8_hearts.png", "Cards/9_hearts.png" }; 
 54 
 55 // Variable to hold the number of cards dealt 
 56 int g_cardsDealt = 0; 
 57  
 58 // Variable to hold each card's  X -coordinate 
 59 float g_cardX = STARTING_X; 

462 
Chapter 10  Using Files and Arrays with the AGK
 60  
 61 // Begin app, called once at the start 
 62 void app::Begin( void ) 
 63 { 
 64    // Set the window title. 
 65    agk::SetWindowTitle("Card Dealer"); 
 66  
 67    // Set the virtual resolution. 
 68    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 69  
 70    // Add the virtual button. 
 71    agk::AddVirtualButton(BUTTON_INDEX, BUTTON_X, BUTTON_Y, BUTTON_SIZE); 
 72    agk::SetVirtualButtonText(BUTTON_INDEX, "Deal"); 
 73  
 74    // Create the backface card sprite. 
 75    agk::CreateSprite(BACKFACE, "Cards/Backface_Red.png"); 
 76  
 77    // Position the backface card sprite. 
 78    agk::SetSpritePosition(BACKFACE, BACKFACE_X, BACKFACE_Y); 
 79  
 80    // Create the card sprites. 
 81    createCardSprites(); 
 82 } 
 83  
 84 // Main loop, called every frame 
 85 void app::Loop ( void ) 
 86 { 
 87    // Variables for the card location 
 88    float cardX, cardY; 
 89  
 90    // Are cards left to be dealt? 
 91    if (g_cardsDealt < NUM_CARDS) 
 92    { 
 93       // Check for a button press. 
 94       if (agk::GetVirtualButtonPressed(BUTTON_INDEX)) 
 95       { 
 96          // Position the card sprite that is being dealt. 
 97          agk::SetSpritePosition(g_cardSprites[g_cardsDealt], 
 98                               g_cardX, CARD_Y); 
 99  
 100          // Make the card sprite visible. 
 101          agk::SetSpriteVisible(g_cardSprites[g_cardsDealt], 1); 
 102  
 103          // Calculate the next card's  X -coordinate. 
 104          g_cardX += agk::GetSpriteWidth(g_cardSprites[g_cardsDealt]) + 
 105                    CARD_DISTANCE; 
 106  
 107          // Increment the number of cards dealt. 
 108          g_cardsDealt++; 
 109       } 
 110    } 
 111    else 
 112    { 
 113       // All cards are dealt. Print a message and hide 

 
10.2 Using Arrays in an AGK Program 
463
 114       // the backface card. 
 115       agk::Print("All cards are dealt."); 
 116       agk::SetSpriteVisible(BACKFACE, 0); 
 117    } 
 118  
 119     // Refresh the screen. 
 120     agk::Sync(); 
 121 } 
 122  
 123 // Called when the app ends 
 124 void app::End ( void ) 
 125 { 
 126 } 
 127  
 128 // The createCardSprites function creates the card sprites 
 129 // and makes them invisible. 
 130 void createCardSprites() 
 131 { 
 132    for (int count = 0; count < NUM_CARDS; count++) 
 133    { 
 134       // Create the next card sprite. 
 135       agk::CreateSprite(g_cardSprites[count], 
 136                        g_imageFiles[count].c_str()); 
 137  
 138       // Make the sprite invisible. 
 139       agk::SetSpriteVisible(g_cardSprites[count], 0); 
 140    } 
 141 }  
 Let’s take a closer look at the program. First, notice that in line 3 we have an  include 
directive for the  string  header file, and in line 4 we have the  using namespace std; 
statement. These are necessary because we are going to have a  string array contain-
ing the names of the card image files. 
 Here is a summary of the global constants: 
 •  Lines 12 and 13 declare constants for the screen resolution.  
 •  Lines 16 through 19 declare constants for the virtual button.  
 •  Lines 22 through 31 declare constants for the card sprite indices.  
 •  Lines 34 through 38 declare the following constants that are related to the location 
of the cards on the screen: 
 •  The  STARTING_X constant specifies the  X -coordinate of the first card that is 
dealt from the deck.  
 •  The  CARD_Y constant specifies the  Y -coordinate for each card that is dealt 
from the deck.  
 •  The  CARD_DISTANCE constant specifies the distance between cards, in pixels.  
 •  The  BACKFACE_X and  BACKFACE_Y constants specify the  X- and  Y -coordinates 
of the card backface.  
 •  Line 41 declares the  NUM_CARDS constant that specifies the number of cards we 
will have.  

464 
Chapter 10  Using Files and Arrays with the AGK
 Lines 44 through 46 declare an  int array named  g_cardSprites that is initialized with 
all the sprite indices for the cards: 
 int g_cardSprites[NUM_CARDS] = { HEARTS_ACE, HEARTS_2, 
   HEARTS_3, HEARTS_4, HEARTS_5, HEARTS_6, HEARTS_7, 
   HEARTS_8, HEARTS_9 };  
 Lines 49 through 53 declare a  string array named  g_imageFiles that is initialized 
with the names of the image files for the cards: 
 string g_imageFiles[NUM_CARDS] = { "Cards/Ace_hearts.png", 
             "Cards/2_hearts.png", "Cards/3_hearts.png", 
             "Cards/4_hearts.png", "Cards/5_hearts.png", 
             "Cards/6_hearts.png", "Cards/7_hearts.png", 
              "Cards/8_hearts.png", "Cards/9_hearts.png" };  
 Note that a parallel relationship exists between the  g_cardSprites array and the 
 g_imageFiles array.  Recall from  Chapter   6 that parallel  arrays are two or more 
arrays that hold related data, and the related elements in each array are accessed with 
a common subscript. In this case, element 0 of the  g_cardSprites array holds the 
sprite index for the ace of hearts card, and element 0 of the  g_imageFiles array holds 
the name of the image file for the ace of hearts card. This parallel relationship exists 
for all the corresponding elements of the two arrays. 
 Line 56 declares an  int variable named  g_cardsDealt , initialized with the value 0. 
This variable will keep count of the number of cards that have been dealt. 
 Line 59 declares a  float variable named  g_cardX , initialized with the value of the 
 STARTING_X constant. The  g_cardX variable holds the  X -coordinate of the next card 
that will be dealt. 
 The  app::Begin function appears in lines 62 through 82. Here is a summary of its code: 
 •  Line 65 sets the text for the window’s title bar.  
 •  Line 68 sets the virtual resolution.  
 •  Line 71 adds the virtual button, and line 72 displays the string “Deal” on the button.  
 •  Line 75 creates the sprite for the card backface, and line 78 positions the back-
face on the screen.  
 •  Line 81 calls the  createCardSprites function, which creates the card sprites and 
then hides them. (The definition of the  createCardSprites function appears in 
lines 130 through 141.)  
 The  app::Loop function appears in lines 85 through 121. Here is a summary of its code: 
 •  Line 88 declares the  cardX and  cardY variables that will hold the  X- and 
 Y -coordinates of the cards as they are displayed on the screen.  
 •  The  if statement in line 91 determines whether the number of cards dealt is less 
than the number of cards. If so, cards are still left in the deck, and the following 
actions take place: 
 •  Line 94 determines whether the virtual button is being clicked. If so, the fol-
lowing actions take place: 
 •  Lines 97 and 98 position the next card sprite on the screen.  
 •  Line 101 makes the card sprite visible.  

 
10.2 Using Arrays in an AGK Program 
465
 •  Lines 104 and 105 calculate the next card’s  X -coordinate.  
 •  Line 108 increments the  g_cardsDealt variable, which holds the number 
of cards dealt.  
 •   If all the cards have been dealt, the program jumps to the  else clause in line 111. 
Line 115 displays the message “All cards are dealt.” Line 116 makes the card 
backface invisible.  
 •  Line 120 updates the screen.  
 The  createCardSprites function appears in lines 130 through 141. The  for loop that 
starts in line 132 creates all the card sprites, using the elements of the  g_cardSprites 
array as the sprite indices and the elements of the  g_imageFiles array as the names of 
the corresponding image files. After each sprite is created, the statement in line 139 
makes it invisible. 
 Figure  10-9  shows how the first element of the array holds the index of the ace of 
hearts sprite, the second element holds the index of the two of hearts sprite, and 
so on.  
1
2
3
4
5
6
7
8
9
10
The g_cardSprites array
 Figure 10-9  The  g_cardSprites array 
 In the Spotlight: 
 Shuffling an Array 
 In Program 10-5, the card sprite numbers were stored in the  g_cardSprites array in 
the following order: ace of hearts, two of hearts, three of hearts, and so forth. When 
the cards were dealt from the deck, they were displayed on the screen in the order that 
their sprite numbers were stored in the array. If you want to write a card game pro-
gram, however, you will probably want a shuffled deck, instead of one in which the 
cards are arranged in order. 
 To  shuffle an array means to randomly rearrange its contents. Program 10-6 shows 
a modified version of the DealCards program, in which we have added a func-
tion that shuffles the contents of the  g_cardSprites array. The shuffle function 
is called just after the card sprites are created, so when the user clicks the virtual 
button to deal the cards, they are displayed in random order.  Figure  10-10  shows 
an example.  

466 
Chapter 10  Using Files and Arrays with the AGK
 Program 10-6 
 (ShuffleCards) 
  1 // Includes, namespace and prototypes 
  2 #include "template.h" 
  3 #include <string>      // Needed for string class 
  4 using namespace std;   // Needed for string class 
  5 using namespace AGK; 
  6 app App; 
  7  
  8 // Function prototypes 
  9 void createCardSprites(); 
 10 void shuffle(); 
 11 void swap(int &, int &); 
 12  
 13 // Constants for the screen resolution 
 14 const int SCREEN_WIDTH  = 640;  // Screen width 
 15 const int SCREEN_HEIGHT = 480;  // Screen height 
 16  
 17 // Constants for the virtual button 
 18 const int   BUTTON_INDEX = 1; 
 19 const int   BUTTON_SIZE  = 100; 
 20 const float BUTTON_X     = 580; 
 21 const float BUTTON_Y     = 420; 
 22  
 23 // Constants for card sprite numbers 
 24 const int HEARTS_ACE = 1; 
 25 const int HEARTS_2   = 2; 
 26 const int HEARTS_3   = 3; 
 Figure 10-10  Cards dealt in random order  

 
10.2 Using Arrays in an AGK Program 
467
 27 const int HEARTS_4   = 4; 
 28 const int HEARTS_5   = 5; 
 29 const int HEARTS_6   = 6; 
 30 const int HEARTS_7   = 7; 
 31 const int HEARTS_8   = 8; 
 32 const int HEARTS_9   = 9; 
 33 const int BACKFACE   = 10; 
 34  
 35 // Constants for card screen placement 
 36 const float STARTING_X    = 25; 
 37 const float CARD_Y        = 100; 
 38 const float CARD_DISTANCE = 10; 
 39 const float BACKFACE_X    = 25; 
 40 const float BACKFACE_Y    = 200; 
 41  
 42 // Constant for the number of cards 
 43 const int NUM_CARDS = 9; 
 44  
 45 // Array holding the card sprite numbers. 
 46 int g_cardSprites[NUM_CARDS] = { HEARTS_ACE, HEARTS_2, 
 47    HEARTS_3, HEARTS_4, HEARTS_5, HEARTS_6, HEARTS_7, 
 48    HEARTS_8, HEARTS_9 }; 
 49  
 50 // Array holding the names of the card image files 
 51 string g_imageFiles[NUM_CARDS] = { "Cards/Ace_hearts.png", 
 52              "Cards/2_hearts.png", "Cards/3_hearts.png", 
 53              "Cards/4_hearts.png", "Cards/5_hearts.png", 
 54              "Cards/6_hearts.png", "Cards/7_hearts.png", 
 55              "Cards/8_hearts.png", "Cards/9_hearts.png" }; 
 56  
 57 // Variable to hold the number of cards dealt 
 58 int g_cardsDealt = 0; 
 59  
 60 // Variable to hold each card's  X -coordinate 
 61 float g_cardX = STARTING_X; 
 62  
 63 // Begin app, called once at the start 
 64 void app::Begin( void ) 
 65 { 
 66    // Set the window title. 
 67    agk::SetWindowTitle("Card Dealer"); 
 68  
 69    // Set the virtual resolution. 
 70    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 71  
 72    // Add the virtual button. 
 73    agk::AddVirtualButton(BUTTON_INDEX, BUTTON_X, BUTTON_Y, BUTTON_SIZE); 
 74    agk::SetVirtualButtonText(BUTTON_INDEX, "Deal"); 
 75  
 76    // Create the backface card sprite. 
 77    agk::CreateSprite(BACKFACE, "Cards/Backface_Red.png"); 
 78  
 79    // Position the backface card sprite. 
 80    agk::SetSpritePosition(BACKFACE, BACKFACE_X, BACKFACE_Y); 

468 
Chapter 10  Using Files and Arrays with the AGK
 81  
 82    // Create the card sprites. 
 83    createCardSprites(); 
 84  
 85    // Shuffle the card sprites. 
 86    shuffle(); 
 87 } 
 88  
 89 // Main loop, called every frame 
 90 void app::Loop ( void ) 
 91 { 
 92    // Variables for the card location 
 93    float cardX, cardY; 
 94  
 95    // Are cards left to be dealt? 
 96    if (g_cardsDealt < NUM_CARDS) 
 97    { 
 98       // Check for a button press. 
 99       if (agk::GetVirtualButtonPressed(BUTTON_INDEX)) 
 100       { 
 101          // Position the card sprite that is being dealt. 
 102          agk::SetSpritePosition(g_cardSprites[g_cardsDealt], 
 103                               g_cardX, CARD_Y); 
 104  
 105          // Make the card sprite visible. 
 106          agk::SetSpriteVisible(g_cardSprites[g_cardsDealt], 1); 
 107  
 108          // Calculate the next card's  X -coordinate. 
 109          g_cardX += agk::GetSpriteWidth(g_cardSprites[g_cardsDealt]) +  
 110                    CARD_DISTANCE; 
 111  
 112          // Increment the number of cards dealt. 
 113          g_cardsDealt++; 
 114       } 
 115    } 
 116    else 
 117    { 
 118       // All cards are dealt. Print a message and hide 
 119       // the backface card. 
 120       agk::Print("All cards are dealt."); 
 121       agk::SetSpriteVisible(BACKFACE, 0); 
 122    } 
 123  
 124     // Refresh the screen. 
 125     agk::Sync(); 
 126 } 
 127  
 128 // Called when the app ends 
 129 void app::End ( void ) 
 130 { 
 131 } 
 132  
 133 // The createCardSprites function creates the card sprites 
 134 // and makes them invisible. 
 135 void createCardSprites() 

 
10.2 Using Arrays in an AGK Program 
469
 136 { 
 137    for (int count = 0; count < NUM_CARDS; count++) 
 138    { 
 139       // Create the next card sprite. 
 140       agk::CreateSprite(g_cardSprites[count], 
 141                        g_imageFiles[count].c_str()); 
 142  
 143       // Make the sprite invisible. 
 144       agk::SetSpriteVisible(g_cardSprites[count], 0); 
 145    } 
 146 } 
 147  
 148 // The shuffle function shuffles the elements of the 
 149 // g_cardSprites array randomly. 
 150 void shuffle() 
 151 { 
 152    // Variable to hold a random subscript 
 153    int randomSub; 
 154  
 155    // Step through the array, swapping each element with 
 156    // a random subscript. 
 157    for (int index = 0; index < NUM_CARDS; index++) 
 158    { 
 159       // Get a random subscript. 
 160       randomSub = agk::Random(0, NUM_CARDS - 1); 
 161  
 162       // Swap two elements. 
 163       swap(g_cardSprites[index], g_cardSprites[randomSub]); 
 164    } 
 165 } 
 166  
 167 // The swap function accepts two int arguments, passed 
 168 // by reference. The function swaps the contents of the 
 169 // two arguments. 
 170 void swap(int &a, int &b) 
 171 { 
 172    // Assign a to temp. 
 173    int temp = a; 
 174  
 175    // Assign b to a. 
 176    a = b; 
 177  
 178    // Assign temp to b. 
 179    b = temp; 
 180 }  
 Inside the  app::Begin function, in line 86, we call the  shuffle function, which is 
defined in lines 150 through 165. Before we look at the code, let’s take a look at the 
general logic used to shuffle the array’s contents. The algorithm works like this: 
 For each element in the array: 
 Randomly select another element 
 Swap the contents of this element with the randomly selected element 

470 
Chapter 10  Using Files and Arrays with the AGK
 Now let’s look at the code. Line 153 declares a local  int  variable named  randomSub , 
which will hold a randomly generated subscript. The loop that begins in line 157 
iterates once for each element in the array. (Inside the loop, the index variable will be 
assigned the values 0 through  NUM_CARDS - 1 .) Line 160 generates a random number 
in the range of 0 through  NUM_CARDS - 1 and assigns the number to  randomNum . Then 
line 163 calls the  swap  function, passing  numbers[index] and  numbers[randomNum] 
as arguments. These arguments are passed by reference, and after the function call is 
complete, the contents of the two array elements will be swapped. 
 Swapping Array Elements 
 Before we look at the code for the swap function, let’s briefly discuss the process of 
swapping two items in computer memory. Assume we have the following variable 
declarations: 
 int a = 1; 
 int b = 9;  
 Suppose we want to swap the values in these variables so variable  a contains 9 and 
variable  b contains 1. At first, you might think that we only need to assign the vari-
ables to each other, like this: 
 // ERROR! This does NOT swap the variables. 
 a = b; 
 b = a;  
 To understand why this doesn’t work, let’s step through the code. The first statement 
is  a = b; . This causes the value 9 to be assigned to  a . But, what happens to the value 
1 that was previously stored in  a ? Remember, when you assign a new value to a vari-
able, the new value replaces any value that was previously stored in the variable. So 
the old value, 1, will be thrown away. Then the next statement is  b = a; . Because 
variable  a contains 9, this assigns 9 to  b . After these statements execute, both variables 
 a and  b will contain the value 9. 
 To successfully swap the contents of two variables, we need a third variable to serve 
as a temporary storage location: 
 int temp;  
 Then we can perform the following steps to swap the values in variables  a and  b : 
 •  Assign the value of a to  temp . 
 •  Assign the value of  b to  a . 
 •  Assign the value of  temp to  b . 
 Now let’s look at the code for the  swap function, which appears in lines 170 through 
180. The function has two reference parameters,  a and b. It is critical that these 
parameters be reference variables because the function will need to change the values 
of the arguments that are passed into them. Line 173 assigns the value of  a to the 
local variable  temp , line 176 assigns the value of  b to  a , and line 179 assigns the value 
of  temp to  b . After these steps have been performed, the arguments that were passed 
into  a and  b will be swapped.  

 
10.2 Using Arrays in an AGK Program 
471
 Sorting an Array 
 Many programming tasks require that the data in an array be sorted in some order. If 
an array is sorted in  ascending order , it means the values in the array are stored from 
lowest to highest. If the values are sorted in  descending order , they are stored from 
highest to lowest. To sort the data in an array, the programmer must use an appropri-
ate sorting algorithm. A  sorting algorithm is a technique for stepping through an array 
and rearranging its contents in some order. In this chapter, we will examine the  selec-
tion sort algorithm . 
 The selection sort algorithm works like this: The smallest value in the array is located 
and moved to element 0. Then, the next smallest value is located and moved to ele-
ment 1. This process continues until all the elements have been placed in their proper 
order. Let’s see how the selection sort works when arranging the elements of the array 
in  Figure   10-11 . 
Element 0
Element 3
Element 1
Element 2
Element 4
Element 5
5
7
2
8
9
1
 Figure 10-11  Values in an array  
 The selection sort scans the array, starting at element 0, and locates the element with 
the smallest value. Then the contents of this element are swapped with the contents 
of element 0. In this example, the 1 stored in element 5 is swapped with the 5 stored 
in element 0. After the swap, the array appears as shown in  Figure   10-12  . 
Element 0
Element 3
Element 1
Element 2
Element 4
Element 5
1
7
2
8
9
5
These two elements were swapped.
 Figure 10-12  Values in the array after the first swap  
 Then, the algorithm repeats the process, but because element 0 already contains the 
smallest value in the array, it can be left out of the procedure. This time, the algorithm 
begins the scan at element 1. In this example, the value in element 2 is swapped with 
the value in element 1. Then the array appears as shown in  Figure   10-13  . 

472 
Chapter 10  Using Files and Arrays with the AGK
 Once again the process is repeated, but this time the scan begins at element 2. The 
algorithm will find that element 5 contains the next smallest value. This element’s 
value is swapped with that of element 2, causing the array to appear as shown in 
 Figure   10-14 . 
Element 0
Element 3
Element 1
Element 2
Element 4
Element 5
1
2
7
8
9
5
These two elements were swapped.
 Figure 10-13  Values in the array after the second swap  
Element 0
Element 3
Element 1
Element 2
Element 4
Element 5
1
2
5
8
9
7
These two elements were swapped.
 Figure 10-14  Values in the array after the third swap  
 Next, the scanning begins at element 3. Its value is swapped with that of element 5, 
causing the array to appear as shown in  Figure   10-15  . 
Element 0
Element 3
Element 1
Element 2
Element 4
Element 5
1
2
5
7
9
8
These two elements were swapped.
 Figure 10-15  Values in the array after the fourth swap  

 
10.2 Using Arrays in an AGK Program 
473
 At this point only two elements are left to sort. The algorithm finds that the value in 
element 5 is smaller than that of element 4, so the two are swapped. This puts the 
array in its final arrangement, as shown in  Figure   10-16  . 
Element 0
Element 3
Element 1
Element 2
Element 4
Element 5
1
2
5
7
8
9
These two elements were swapped.
 Figure 10-16  Values in the array after the fifth swap  
 Program 10-7 shows a demonstration of the selection sort algorithm using the simu-
lated deck of cards that you saw in Programs 10-5 and 10-6. This program has two 
virtual buttons: one that sorts the cards and displays them, and another that shuffles 
the cards and displays them.  Figure  10-17  shows an example of the program’s output. 
The screen on the left shows the cards after they have been sorted, and the screen on 
the right shows the cards after they have been shuffled.  
The cards sorted
The cards shuffled
 Figure 10-17  The cards sorted and shuffled  
 Program 10-7 
 (SortAndShuffle) 
  1 // Includes, namespace and prototypes 
  2 #include "template.h" 
  3 #include <string>      // Needed for string class 
  4 using namespace std;   // Needed for string class 
  5 using namespace AGK; 

474 
Chapter 10  Using Files and Arrays with the AGK
  6 app App; 
  7  
  8 // Function prototypes 
  9 void createCardSprites(); 
 10 void shuffle(); 
 11 void selectionSort(); 
 12 void swap(int &, int &); 
 13 void displayCards(); 
 14  
 15 // Constants for the screen resolution 
 16 const int SCREEN_WIDTH  = 640; 
 17 const int SCREEN_HEIGHT = 480; 
 18  
 19 // Constants for the virtual buttons 
 20 const int   BUTTON_SIZE  = 100; 
 21  
 22 const int   SORT_BUTTON_INDEX = 1; 
 23 const float SORT_BUTTON_X     = 60; 
 24 const float SORT_BUTTON_Y     = 420; 
 25  
 26 const int   SHUFFLE_BUTTON_INDEX = 2; 
 27 const float SHUFFLE_BUTTON_X     = 580; 
 28 const float SHUFFLE_BUTTON_Y     = 420; 
 29  
 30 // Constants for card sprite numbers 
 31 const int HEARTS_ACE = 1; 
 32 const int HEARTS_2   = 2; 
 33 const int HEARTS_3   = 3; 
 34 const int HEARTS_4   = 4; 
 35 const int HEARTS_5   = 5; 
 36 const int HEARTS_6   = 6; 
 37 const int HEARTS_7   = 7; 
 38 const int HEARTS_8   = 8; 
 39 const int HEARTS_9   = 9; 
 40 const int BACKFACE   = 10; 
 41  
 42 // Constants for card screen placement 
 43 const float STARTING_X    = 25; 
 44 const float CARD_Y        = 100; 
 45 const float CARD_DISTANCE = 10; 
 46  
 47 // Constant for the number of cards 
 48 const int NUM_CARDS = 9; 
 49  
 50 // Array holding the card sprite numbers. 
 51 int g_cardSprites[NUM_CARDS] = { HEARTS_ACE, HEARTS_2, 
 52      HEARTS_3, HEARTS_4, HEARTS_5, HEARTS_6, HEARTS_7, 
 53      HEARTS_8, HEARTS_9 }; 
 54  
 55 // Array holding the names of the card image files 
 56 string g_imageFiles[NUM_CARDS] = { "Cards/Ace_hearts.png", 
 57               "Cards/2_hearts.png", "Cards/3_hearts.png", 
 58               "Cards/4_hearts.png", "Cards/5_hearts.png", 
 59               "Cards/6_hearts.png", "Cards/7_hearts.png", 
 60               "Cards/8_hearts.png", "Cards/9_hearts.png" }; 

 
10.2 Using Arrays in an AGK Program 
475
 61  
 62 // Begin app, called once at the start 
 63 void app::Begin( void ) 
 64 { 
 65    // Set the window title. 
 66    agk::SetWindowTitle("Card Dealer"); 
 67  
 68    // Set the virtual resolution. 
 69    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 70  
 71    // Add the virtual sort button. 
 72    agk::AddVirtualButton(SORT_BUTTON_INDEX, SORT_BUTTON_X, 
 73                          SORT_BUTTON_Y, BUTTON_SIZE); 
 74    agk::SetVirtualButtonText(SORT_BUTTON_INDEX, "Sort"); 
 75  
 76    // Add the virtual shuffle button. 
 77    agk::AddVirtualButton(SHUFFLE_BUTTON_INDEX, SHUFFLE_BUTTON_X, 
 78                          SHUFFLE_BUTTON_Y, BUTTON_SIZE); 
 79    agk::SetVirtualButtonText(SHUFFLE_BUTTON_INDEX, "Shuff"); 
 80  
 81    // Create the card sprites. 
 82    createCardSprites(); 
 83 } 
 84  
 85 // Main loop, called every frame 
 86 void app::Loop ( void ) 
 87 { 
 88    // Check for the shuffle button. 
 89    if (agk::GetVirtualButtonPressed(SHUFFLE_BUTTON_INDEX)) 
 90    { 
 91       // Shuffle the card sprites. 
 92       shuffle(); 
 93  
 94       // Display the cards. 
 95       displayCards(); 
 96    } 
 97  
 98    // Check for the sort button. 
 99    if (agk::GetVirtualButtonPressed(SORT_BUTTON_INDEX)) 
 100    { 
 101       // Shuffle the card sprites. 
 102       selectionSort(); 
 103  
 104       // Display the cards. 
 105       displayCards(); 
 106    } 
 107  
 108    // Refresh the screen. 
 109    agk::Sync(); 
 110 } 
 111  
 112 // Called when the app ends 
 113 void app::End ( void ) 
 114 { 
 115 } 

476 
Chapter 10  Using Files and Arrays with the AGK
 116  
 117 // The createCardSprites function creates the card sprites 
 118 // and makes them invisible. 
 119 void createCardSprites() 
 120 { 
 121    for (int count = 0; count < NUM_CARDS; count++) 
 122    { 
 123       // Create the next card sprite. 
 124       agk::CreateSprite(g_cardSprites[count], 
 125                         g_imageFiles[count].c_str()); 
 126  
 127       // Make the sprite invisible. 
 128       agk::SetSpriteVisible(g_cardSprites[count], 0); 
 129    } 
 130 } 
 131  
 132 // The shuffle function shuffles the elements of the 
 133 // g_cardSprites array randomly. 
 134 void shuffle() 
 135 { 
 136    // Variable to hold a random subscript 
 137    int randomSub; 
 138  
 139    // Step through the array, swapping each element with 
 140    // a random subscript. 
 141    for (int index = 0; index < NUM_CARDS; index++) 
 142    { 
 143       // Get a random subscript. 
 144       randomSub = agk::Random(0, NUM_CARDS - 1); 
 145  
 146       // Swap two elements. 
 147       swap(g_cardSprites[index], g_cardSprites[randomSub]); 
 148    } 
 149 } 
 150  
 151 // The selectionSort function sorts the g_cardSprites array 
 152 // in ascending order. 
 153 void selectionSort() 
 154 { 
 155    int startScan; // Starting position of the scan 
 156    int index;     // To hold a subscript value 
 157    int minIndex;  // Element with smallest value in the scan 
 158    int minValue;  // The smallest value found in the scan 
 159  
 160    // The outer loop iterates once for each element in the 
 161    // g_cardSprites array. The startScan variable marks the position 
 162    // where the scan should begin. 
 163    for (startScan = 0; startScan < (NUM_CARDS - 1); startScan++) 
 164    { 
 165       // Assume the first element in the scannable area 
 166         // is the smallest value. 
 167         minIndex = startScan; 
 168         minValue = g_cardSprites[startScan]; 
 169  
 170         // Scan the array starting at the 2nd element in the 

 
10.2 Using Arrays in an AGK Program 
477
 171         // scannable area. We are looking for the smallest 
 172         // value in the scannable area. 
 173         for(index = startScan + 1; index < NUM_CARDS; index++) 
 174         { 
 175             if (g_cardSprites[index] < minValue) 
 176             { 
 177                minValue = g_cardSprites[index]; 
 178                minIndex = index; 
 179             } 
 180         } 
 181  
 182         // Swap the element with the smallest value 
 183         // with the first element in the scannable area. 
 184         swap( g_cardSprites[minIndex], g_cardSprites[startScan] ); 
 185      } 
 186 } 
 187  
 188 // The swap function accepts two int arguments, passed 
 189 // by reference. The function swaps the contents of the 
 190 // two arguments. 
 191 void swap(int &a, int &b) 
 192 { 
 193    // Assign a to temp. 
 194    int temp = a; 
 195  
 196    // Assign b to a. 
 197    a = b; 
 198  
 199    // Assign temp to b. 
 200    b = temp; 
 201 } 
 202  
 203 // The displayCards function displays the card sprites 
 204 // in the order that their sprite numbers appear in 
 205 // the g_cardSprites array. 
 206 void displayCards() 
 207 { 
 208    // Variable to hold each card's  X -coordinate 
 209    float cardX = STARTING_X; 
 210  
 211    for (int index = 0; index < NUM_CARDS; index++) 
 212    { 
 213       // Position this card sprite. 
 214       agk::SetSpritePosition(g_cardSprites[index], 
 215                              cardX, CARD_Y); 
 216        
 217       // Make the card sprite visible. 
 218       agk::SetSpriteVisible(g_cardSprites[index], 1); 
 219  
 220       // Calculate the next card's  X -coordinate. 
 221       cardX += agk::GetSpriteWidth(g_cardSprites[index]) + 
 222                                       CARD_DISTANCE; 
 223    } 
 224 }   

478 
Chapter 10  Using Files and Arrays with the AGK
 
10.3  Tile Maps  
 CONCEPT:    Tiles are small rectangular images that are commonly used to construct 
the background imagery in a game. A tile map is a two-dimensional 
array that specifies tiles and their locations on the screen.  
 Tiles are small rectangular images that can be put together to form a larger image. In 
the early days of video games, computers had much less memory and much lower 
processing speeds than they do today. Game developers commonly used tiles to con-
struct the background imagery in games. Breaking a large image down into many 
smaller ones was more memory efficient, and processing the smaller images was faster. 
Many game programmers today still prefer to use tiles. In this section, we will discuss 
how two-dimensional arrays are used to map the locations of tiles on the screen. 
 For example, the image on the left in  Figure   10-18  shows a screen from a game (this also 
appears as Figure C-11 in the book’s color insert). We are looking down on the scene, 
which is a grass field with a stone path that leads around a tree and some rocks. The image 
on the right shows how the image is actually constructed of small tiles. This particular scene 
has 10 rows and 10 columns of tiles, for a total of 100 tiles. In this example, the entire 
screen is 640 pixels wide by 480 pixels high. So each tile is 64 pixels wide by 48 pixels high.  
 NOTE:   You can modify the  selectionSort function so it sorts the array in 
descending order by changing the less-than operator in line 175 to a greater-than 
operator, as shown here: 
 if (g_cardSprites[index] > maxValue)  
 Notice that we have also changed the name of the  minValue variable to  maxValue , 
which is more appropriate for a descending order sort. You would need to make 
this change throughout the function. 
 Figure 10-18  A tile-based image  
VideoNote
Tile Maps

 
10.3 Tile Maps 
479
 Although a total of 100 tiles are in the image, many of them are duplicates. The entire 
image is actually constructed of only 11 tiles, which are shown in  Figure  10-19  (this 
also appears as Figure C-12 in the book’s color insert). One tile is used for the grass, 
five tiles for different sections of the path, one tile for the rocks, and four tiles for the 
different sections of the tree.  
Grass.png
Path.png
PathNE.png
PathNW.png
PathSE.png
PathSW.png
Rock.png
TreeNE.png
TreeNW.png
TreeSE.png
TreeSW.png
 Figure 10-19  Tiles 
 Let’s look at the steps we would take to construct the image shown in  Figure   10-18  
from the tiles shown in  Figure   10-19  . As usual we declare constants for the image 
indices, as shown here: 
 // Constants for the image indices 
 const int GRASS  = 1; 
 const int PATH   = 2; 
 const int PATHNE = 3; 
 const int PATHNW = 4; 
 const int PATHSE = 5; 
 const int PATHSW = 6; 
 const int TREENW = 7; 
 const int TREENE = 8; 
 const int TREESW = 9; 
 const int TREESE = 10; 
 const int ROCK   = 11;  
 We use these image indices when we load the tile images, as shown in the following 
function: 
 void loadTiles() 
 { 
   agk::LoadImage(GRASS,  "Alec/Grass.png"); 
   agk::LoadImage(PATH,   "Alec/Path.png"); 
   agk::LoadImage(PATHNE, "Alec/PathNE.png"); 
   agk::LoadImage(PATHNW, "Alec/PathNW.png"); 
   agk::LoadImage(PATHSE, "Alec/PathSE.png"); 
   agk::LoadImage(PATHSW, "Alec/PathSW.png"); 
   agk::LoadImage(TREENE, "Alec/TreeNE.png"); 
 NOTE:   The letters NE, NW, SE, and SW in the tile names stand for northeast, 
northwest, southeast, and southwest. 

480 
Chapter 10  Using Files and Arrays with the AGK
   agk::LoadImage(TREENW, "Alec/TreeNW.png"); 
   agk::LoadImage(TREESE, "Alec/TreeSE.png"); 
   agk::LoadImage(TREESW, "Alec/TreeSW.png"); 
   agk::LoadImage(ROCK,   "Alec/Rock.png"); 
 } 
 We will also declare constants for the tile image sizes, as shown here: 
 // Constants for the tile image sizes 
 const int TILE_WIDTH  = 64; 
 const int TILE_HEIGHT = 48;  
 Then we create a two-dimensional  int  array to serve as the tile map. A  tile map is an 
array that maps the location of each tile on the screen. In this example, the image is 
constructed using 10 rows of tiles, with each row containing 10 tiles. As a result, our 
tile map will be an array with 10 rows and 10 columns. Here are the constants that 
we will use as the array size declarators: 
 // Constants for the tile map size declarators 
 const int TILE_ROWS = 10; 
 const int TILE_COLS = 10;  
 Each element of the tile map array will hold the image number for a tile. For 
example, the element at subscript  [0][0] will hold the image number for the first 
tile in the first row. (This is the tile in the upper-left corner of the screen.) The 
element at subscript  [0][1] will hold the image number for the second tile in the 
first row. This continues until the last element in the array, at subscript  [9][9] , 
which will hold the image number for the tenth tile in the 10th row (the tile in the 
lower-right corner). The following code shows how we would declare and initial-
ize the array: 
 int g_tileMap[TILE_ROWS][TILE_COLS] = 
 { {GRASS, GRASS, GRASS, GRASS, GRASS,  GRASS,  GRASS,  GRASS,  GRASS, GRASS}, 
  {GRASS, GRASS, GRASS, ROCK,  GRASS,  GRASS,  GRASS,  GRASS,  GRASS, GRASS}, 
  {GRASS, GRASS, GRASS, GRASS, GRASS,  GRASS,  GRASS,  PATHNW, PATH,  PATH }, 
  {GRASS, GRASS, GRASS, GRASS, GRASS,  TREENW, TREENE, PATH,   GRASS, GRASS}, 
  {PATH,  PATH,  PATH,  PATH,  PATHNE, TREESW, TREESE, PATH,   ROCK,  GRASS}, 
  {GRASS, GRASS, GRASS, GRASS, PATH,   GRASS,  GRASS,  PATH,   GRASS, GRASS}, 
  {GRASS, GRASS, GRASS, GRASS, PATHSW, PATH,   PATH,   PATHSE, GRASS, GRASS}, 
  {GRASS, GRASS, GRASS, GRASS, GRASS,  GRASS,  GRASS,  GRASS,  GRASS, GRASS}, 
  {GRASS, ROCK,  GRASS, GRASS, GRASS,  GRASS,  GRASS,  GRASS,  GRASS, GRASS}, 
  {GRASS, GRASS, GRASS, GRASS, GRASS,  GRASS,  GRASS,  GRASS,  GRASS, GRASS} 
 };  
 To display the tiles we will write a function such as shown in the following code. This 
is obviously not a complete program, but we have provided line numbers so we can 
discuss each part of the code. 
 1 // The displayTiles function displays the tiles, as 
 2 // specified by the tile map. 
 3 void displayTiles() 
 4 { 

 
10.3 Tile Maps 
481
 5    // Variables for the tile coordinates 
 6    float x = 0, y = 0; 
 7  
 8    // Variable to temporarily hold a sprite index 
 9    int spriteIndex; 
 10     
 11    // Display all the tiles specified in the map. 
 12    for (int r = 0; r < TILE_ROWS; r++) 
 13    { 
 14       // Set x to 0. 
 15       x = 0; 
 16  
 17       // Display all the tiles in this row. 
 18       for (int c = 0; c < TILE_COLS; c++) 
 19       { 
 20          // Create a sprite for this tile. 
 21          spriteIndex = agk::CreateSprite(g_tileMap[r][c]); 
 22  
 23          // Set the tile's position. 
 24          agk::SetSpritePosition(spriteIndex, x, y); 
 25  
 26          // Update the  X -coordinate for the next tile. 
 27          x += TILE_WIDTH; 
 28       } 
 29     
 30       // Increase y for the next row. 
 31       y += TILE_HEIGHT; 
 32     } 
 33 }  
 In line 6 we declare two local  float variables named  x and  y . These variables will hold the 
coordinates for each tile that we display. The  for loop in lines 12 through 28 displays each 
row of tiles. Inside the loop, in line 15, we set  x to 0 because the  X -coordinate of the first 
tile in each row is 0. Then the nested  for loop that appears in lines 18 through 28 displays 
each of the tiles in the row. When this loop iterates, line 21 creates a sprite, using the tile 
image specified in the  g_tileMap array, line 24 sets the sprite’s position, and line 27 increases 
the value of  x for the next tile. After this loop finishes all its iterations, a complete row of 
tiles will have been displayed. Then line 31 increases the  y variable for the next row. 
 The code in Program 10-8 demonstrates how this works in a complete program. 
When you execute this program, it will display the image previously shown on the left 
of  Figure   10-18 . 
 Program 10-8 
 (TileDemo) 
  1 // Includes, namespace and prototypes 
  2 #include "template.h" 
  3 using namespace AGK; 
  4 app App; 

482 
Chapter 10  Using Files and Arrays with the AGK
  5  
  6 // Function prototypes 
  7 void loadTiles(); 
  8 void displayTiles(); 
  9  
 10 // Constants for the screen resolution 
 11 const int SCREEN_WIDTH  = 640; 
 12 const int SCREEN_HEIGHT = 480; 
 13  
 14 // Constants for the image indices 
 15 const int GRASS  = 1; 
 16 const int PATH   = 2; 
 17 const int PATHNE = 3; 
 18 const int PATHNW = 4; 
 19 const int PATHSE = 5; 
 20 const int PATHSW = 6; 
 21 const int TREENW = 7; 
 22 const int TREENE = 8; 
 23 const int TREESW = 9; 
 24 const int TREESE = 10; 
 25 const int ROCK   = 11; 
 26  
 27 // Constants for the tile image sizes 
 28 const int TILE_WIDTH  = 64; 
 29 const int TILE_HEIGHT = 48; 
 30  
 31 // Constants for the tile map size declarators 
 32 const int TILE_ROWS = 10; 
 33 const int TILE_COLS = 10; 
 34  
 35 // The tile map 
 36 int g_tileMap[TILE_ROWS][TILE_COLS] = 
 37 { {GRASS, GRASS, GRASS, GRASS, GRASS,  GRASS,  GRASS,  GRASS,  GRASS, GRASS}, 
 38   {GRASS, GRASS, GRASS, ROCK,  GRASS,  GRASS,  GRASS,  GRASS,  GRASS, GRASS}, 
 39   {GRASS, GRASS, GRASS, GRASS, GRASS,  GRASS,  GRASS,  PATHNW, PATH,  PATH }, 
 40   {GRASS, GRASS, GRASS, GRASS, GRASS,  TREENW, TREENE, PATH,   GRASS, GRASS}, 
 41   {PATH,  PATH,  PATH,  PATH,  PATHNE, TREESW, TREESE, PATH,   ROCK,  GRASS}, 
 42   {GRASS, GRASS, GRASS, GRASS, PATH,   GRASS,  GRASS,  PATH,   GRASS, GRASS}, 
 43   {GRASS, GRASS, GRASS, GRASS, PATHSW, PATH,   PATH,   PATHSE, GRASS, GRASS}, 
 44   {GRASS, GRASS, GRASS, GRASS, GRASS,  GRASS,  GRASS,  GRASS,  GRASS, GRASS}, 
 45   {GRASS, ROCK,  GRASS, GRASS, GRASS,  GRASS,  GRASS,  GRASS,  GRASS, GRASS}, 
 46   {GRASS, GRASS, GRASS, GRASS, GRASS,  GRASS,  GRASS,  GRASS,  GRASS, GRASS} 
 47 }; 
 48  
 49 // Begin app, called once at the start 
 50 void app::Begin( void ) 
 51 { 
 52    // Set the window title. 
 53    agk::SetWindowTitle("Walking Alec"); 
 54  
 55    // Set the virtual resolution. 
 56    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 57  
 58    // Load the tile images. 
 59    loadTiles(); 

 
10.3 Tile Maps 
483
 60  
 61    // Create the tile sprites and display them. 
 62    displayTiles(); 
 63 } 
 64  
 65 // Main loop, called every frame 
 66 void app::Loop ( void ) 
 67 { 
 68    // Refresh the screen. 
 69    agk::Sync(); 
 70 } 
 71  
 72 // Called when the app ends 
 73 void app::End ( void ) 
 74 { 
 75 } 
 76  
 77 // The loadTiles function loads the images that will be 
 78 // used for tiles. 
 79 void loadTiles() 
 80 { 
 81    agk::LoadImage(GRASS,  "Alec/Grass.png"); 
 82    agk::LoadImage(PATH,   "Alec/Path.png"); 
 83    agk::LoadImage(PATHNE, "Alec/PathNE.png"); 
 84    agk::LoadImage(PATHNW, "Alec/PathNW.png"); 
 85    agk::LoadImage(PATHSE, "Alec/PathSE.png"); 
 86    agk::LoadImage(PATHSW, "Alec/PathSW.png"); 
 87    agk::LoadImage(TREENE, "Alec/TreeNE.png"); 
 88    agk::LoadImage(TREENW, "Alec/TreeNW.png"); 
 89    agk::LoadImage(TREESE, "Alec/TreeSE.png"); 
 90    agk::LoadImage(TREESW, "Alec/TreeSW.png"); 
 91    agk::LoadImage(ROCK,   "Alec/Rock.png"); 
 92 } 
 93  
 94 // The displayTiles function displays the tiles, as 
 95 // specified by the tile map. 
 96 void displayTiles() 
 97 { 
 98    // Variables for the tile coordinates 
 99    float x = 0, y = 0; 
 100  
 101    // Variable to temporarily hold a sprite index 
 102    int spriteIndex; 
 103     
 104    // Display all the tiles specified in the map. 
 105    for (int r = 0; r < TILE_ROWS; r++) 
 106    { 
 107       // Set x to 0. 
 108       x = 0; 
 109  
 110       // Display all the tiles in this row. 
 111       for (int c = 0; c < TILE_COLS; c++) 
 112       { 
 113          // Create a sprite for this tile. 
 114          spriteIndex = agk::CreateSprite(g_tileMap[r][c]); 

484 
Chapter 10  Using Files and Arrays with the AGK
 115  
 116          // Set the tile's position. 
 117          agk::SetSpritePosition(spriteIndex, x, y); 
 118  
 119          // Update the  X -coordinate for the next tile. 
 120          x += TILE_WIDTH; 
 121       } 
 122     
 123       // Increase y for the next row. 
 124       y += TILE_HEIGHT; 
 125    } 
 126 }  
 Now that we’ve demonstrated the basic technique for displaying a set of tiles using 
a tile map, let’s add some action. Program 10-9 displays the same set of tiles as 
Program 10-8 and also displays a sprite of a character that we’ve named Alec. 
When you run the program, you can use the arrow keys to make Alec walk around 
the screen. 
 Program 10-9 
  (WalkingAlec) 
  1 // Includes, namespace and prototypes 
  2 #include "template.h" 
  3 using namespace AGK; 
  4 app App; 
  5  
  6 // Function prototypes 
  7 void loadTiles(); 
  8 void displayTiles(); 
  9 void updateAlecX(float); 
 10 void updateAlecY(float); 
 11  
 12 // Constants for the screen resolution 
 13 const int SCREEN_WIDTH  = 640; 
 14 const int SCREEN_HEIGHT = 480; 
 15  
 16 // Constants for the image numbers 
 17 const int GRASS  = 1; 
 18 const int PATH   = 2; 
 19 const int PATHNE = 3; 
 20 const int PATHNW = 4; 
 21 const int PATHSE = 5; 
 22 const int PATHSW = 6; 
 23 const int TREENW = 7; 
 24 const int TREENE = 8; 
 25 const int TREESW = 9; 
 26 const int TREESE = 10; 
 27 const int ROCK   = 11; 
 28  
 29 // Constants for the tile image sizes 
 30 const int TILE_WIDTH  = 64; 
 31 const int TILE_HEIGHT = 48; 

 
10.3 Tile Maps 
485
 32  
 33 // Constants for the tile map size declarators 
 34 const int TILE_ROWS = 10; 
 35 const int TILE_COLS = 10; 
 36  
 37 // Constants for the Alec sprite sheet 
 38 const int ALEC_IMAGE        = 12;  // Texture atlas image index 
 39 const int ALEC_SPRITE       = 100; // Alec's sprite index 
 40 const int ALEC_FRAME_WIDTH  = 40;  // Alec's frame width 
 41 const int ALEC_FRAME_HEIGHT = 75;  // Alec's frame height 
 42 const int ALEC_FRAME_COUNT  = 16;  // Alec's frame count 
 43 const int EAST_START        = 1;   // First frame for going east 
 44 const int EAST_END          = 4;   // Last frame for going east 
 45 const int NORTH_START       = 5;   // First frame for going north 
 46 const int NORTH_END         = 8;   // Last frame for going north 
 47 const int SOUTH_START       = 9;   // First frame for going south 
 48 const int SOUTH_END         = 12;  // Last frame for going south 
 49 const int WEST_START        = 13;  // First frame for going west 
 50 const int WEST_END          = 16;  // Last frame for going west 
 51 const int ALEC_FPS          = 5;   // Alec's frames per second 
 52 const int ANIMATION_LOOP    = 1;   // To make Alec loop 
 53 const float ALEC_STARTING_X = 0;   // Alec's starting  X -coordinate 
 54 const float ALEC_STARTING_Y = 150; // Alec's starting  Y -coordinate 
 55  
 56 // Constants for Alec's direction 
 57 const int NORTH   = 1; 
 58 const int SOUTH = 2; 
 59 const int EAST  = 3; 
 60 const int WEST  = 4; 
 61  
 62 // The tile map 
 63 int g_tileMap[TILE_ROWS][TILE_COLS] = 
 64 { {GRASS, GRASS, GRASS, GRASS, GRASS,  GRASS,  GRASS,  GRASS,  GRASS, GRASS}, 
 65   {GRASS, GRASS, GRASS, ROCK,  GRASS,  GRASS,  GRASS,  GRASS,  GRASS, GRASS}, 
 66   {GRASS, GRASS, GRASS, GRASS, GRASS,  GRASS,  GRASS,  PATHNW, PATH,  PATH }, 
 67   {GRASS, GRASS, GRASS, GRASS, GRASS,  TREENW, TREENE, PATH,   GRASS, GRASS}, 
 68   {PATH,  PATH,  PATH,  PATH,  PATHNE, TREESW, TREESE, PATH,   ROCK,  GRASS}, 
 69   {GRASS, GRASS, GRASS, GRASS, PATH,   GRASS,  GRASS,  PATH,   GRASS, GRASS}, 
 70   {GRASS, GRASS, GRASS, GRASS, PATHSW, PATH,   PATH,   PATHSE, GRASS, GRASS}, 
 71   {GRASS, GRASS, GRASS, GRASS, GRASS,  GRASS,  GRASS,  GRASS,  GRASS, GRASS}, 
 72   {GRASS, ROCK,  GRASS, GRASS, GRASS,  GRASS,  GRASS,  GRASS,  GRASS, GRASS}, 
 73   {GRASS, GRASS, GRASS, GRASS, GRASS,  GRASS,  GRASS,  GRASS,  GRASS, GRASS} 
 74 }; 
 75  
 76 // Variable for Alec's direction 
 77 int g_alecDirection = EAST; 
 78  
 79 // Begin app, called once at the start 
 80 void app::Begin( void ) 
 81 { 
 82    // Set the window title. 
 83    agk::SetWindowTitle("Walking Alec"); 
 84  
 85    // Set the virtual resolution. 
 86    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 

486 
Chapter 10  Using Files and Arrays with the AGK
 87  
 88    // Load the texture atlas. 
 89    agk::LoadImage(ALEC_IMAGE, "Alec/Alec.png"); 
 90  
 91    // Create the sprite using the texture atlas as the image. 
 92    agk::CreateSprite(ALEC_SPRITE, ALEC_IMAGE); 
 93  
 94    // Make sure Alec is displayed on top of the tile sprites. 
 95    agk::SetSpriteDepth(ALEC_SPRITE, 0); 
 96  
 97    // Set Alec's starting position. 
 98    agk::SetSpritePosition(ALEC_SPRITE, ALEC_STARTING_X, 
 99                           ALEC_STARTING_Y); 
 100  
 101    // Set the sprite animation. 
 102    agk::SetSpriteAnimation(ALEC_SPRITE, ALEC_FRAME_WIDTH, 
 103                            ALEC_FRAME_HEIGHT, ALEC_FRAME_COUNT); 
 104  
 105    // Load the tile images. 
 106    loadTiles(); 
 107  
 108    // Create the tile sprites and display them. 
 109    displayTiles(); 
 110 } 
 111  
 112 // Main loop, called every frame 
 113 void app::Loop ( void ) 
 114 { 
 115    // Get the state of the direction keys. 
 116    float directionX = agk::GetDirectionX(); 
 117    float directionY = agk::GetDirectionY(); 
 118  
 119    // If the right or left arrow keys are pressed, 
 120    // update Alec's  X -coordinate. 
 121    if (directionX != 0) 
 122    { 
 123       updateAlecX(directionX); 
 124    } 
 125  
 126    // If the up or down arrow keys are pressed, 
 127    // update Alec's  Y -coordinate. 
 128    if (directionY != 0) 
 129    { 
 130       updateAlecY(directionY); 
 131    } 
 132  
 133    // Refresh the screen. 
 134    agk::Sync(); 
 135 } 
 136  
 137 // Called when the app ends 
 138 void app::End ( void ) 
 139 { 
 140 } 
 141  

 
10.3 Tile Maps 
487
 142 // The loadTiles function loads the images that will be 
 143 // used for tiles. 
 144 void loadTiles() 
 145 { 
 146    agk::LoadImage(GRASS,  "Alec/Grass.png"); 
 147    agk::LoadImage(PATH,   "Alec/Path.png"); 
 148    agk::LoadImage(PATHNE, "Alec/PathNE.png"); 
 149    agk::LoadImage(PATHNW, "Alec/PathNW.png"); 
 150    agk::LoadImage(PATHSE, "Alec/PathSE.png"); 
 151    agk::LoadImage(PATHSW, "Alec/PathSW.png"); 
 152    agk::LoadImage(TREENE, "Alec/TreeNE.png"); 
 153    agk::LoadImage(TREENW, "Alec/TreeNW.png"); 
 154    agk::LoadImage(TREESE, "Alec/TreeSE.png"); 
 155    agk::LoadImage(TREESW, "Alec/TreeSW.png"); 
 156    agk::LoadImage(ROCK,   "Alec/Rock.png"); 
 157 } 
 158  
 159 // The displayTiles function displays the tiles, as 
 160 // specified by the tile map. 
 161 void displayTiles() 
 162 { 
 163    // Variables for the tile coordinates 
 164    float x = 0, y = 0; 
 165  
 166    // Variable to temporarily hold a sprite index 
 167    int spriteIndex; 
 168     
 169    // Display all the tiles specified in the map. 
 170    for (int r = 0; r < TILE_ROWS; r++) 
 171    { 
 172       // Set x to 0. 
 173       x = 0; 
 174  
 175       // Display all the tiles in this row. 
 176       for (int c = 0; c < TILE_COLS; c++) 
 177       { 
 178          // Create a sprite for this tile. 
 179          spriteIndex = agk::CreateSprite(g_tileMap[r][c]); 
 180  
 181          // Set the tile's position. 
 182          agk::SetSpritePosition(spriteIndex, x, y); 
 183  
 184          // Update the  X -coordinate for the next tile. 
 185          x += TILE_WIDTH; 
 186       } 
 187     
 188       // Increase y for the next row. 
 189       y += TILE_HEIGHT; 
 190    } 
 191 } 
 192  
 193 // The updateAlecX function turns Alec either east or west, 
 194 // depending on which arrow key is being pressed, and moves 
 195 // him to his new  X -coordinate. 
 196 void updateAlecX(float directionX) 

488 
Chapter 10  Using Files and Arrays with the AGK
 197 { 
 198    float alecX,   // Alec's current X position 
 199          newX;    // Alec's new  X -coordinate 
 200  
 201    // Get Alec's  X -coordinate 
 202    alecX = agk::GetSpriteX(ALEC_SPRITE); 
 203  
 204    // Which key was pressed? Right or left? 
 205    if (directionX > 0) 
 206    { 
 207       // Turn Alec east 
 208       agk::PlaySprite(ALEC_SPRITE, ALEC_FPS, 
 209                       ANIMATION_LOOP, 
 210                       EAST_START, EAST_END); 
 211  
 212       // Save Alec's current direction. 
 213       g_alecDirection = EAST; 
 214  
 215       // Calculate Alec's new  X -coordinate. 
 216       newX = alecX + 1; 
 217    } 
 218    else if (directionX < 0) 
 219    { 
 220       // Turn Alec west 
 221       agk::PlaySprite(ALEC_SPRITE, ALEC_FPS, 
 222                       ANIMATION_LOOP, 
 223                       WEST_START, WEST_END); 
 224  
 225       // Save Alec's current direction. 
 226       g_alecDirection = WEST; 
 227  
 228       // Calculate Alec's new  X -coordinate 
 229       newX = alecX - 1; 
 230    } 
 231  
 232    // Move Alec 
 233    agk::SetSpriteX(ALEC_SPRITE, newX); 
 234 } 
 235  
 236 // The updateAlecY function turns Alec either north or south, 
 237 // depending on which arrow key is being pressed, and moves 
 238 // him to his new  Y -coordinate. 
 239 void updateAlecY(float directionY) 
 240 { 
 241    float alecY,   // Alec's current Y position 
 242          newY;    // Alec's new  Y -coordinate 
 243  
 244    // Get Alec's  Y -coordinate 
 245    alecY = agk::GetSpriteY(ALEC_SPRITE); 
 246  
 247    // Which key was pressed? Up or down? 
 248    if (directionY < 0) 
 249    { 
 250       // Turn Alec north 
 251       agk::PlaySprite(ALEC_SPRITE, ALEC_FPS, 
 252                       ANIMATION_LOOP, 
 253                       NORTH_START, NORTH_END); 

 
10.3 Tile Maps 
489
 254  
 255       // Save Alec's current direction. 
 256       g_alecDirection = NORTH; 
 257  
 258       // Calculate Alec's new  Y -coordinate. 
 259       newY = alecY - 1; 
 260    } 
 261    else if (directionY > 0) 
 262    { 
 263       // Turn Alec south 
 264       agk::PlaySprite(ALEC_SPRITE, ALEC_FPS, 
 265                       ANIMATION_LOOP, 
 266                       SOUTH_START, SOUTH_END); 
 267  
 268       // Save Alec's current direction. 
 269       g_alecDirection = SOUTH; 
 270  
 271       // Calculate Alec's new  Y -coordinate. 
 272       newY = alecY + 1; 
 273    } 
 274  
 275    // Move Alec 
 276    agk::SetSpriteY(ALEC_SPRITE, newY); 
 277 }  
 Figure 10-20  Animated sprite frames for the Alec character (stored in Alec.png)  
 The Alec character is an animated sprite, created from the Alec.png texture atlas 
shown in  Figure   10-20  (this also appears as Figure C-13 in the book’s color insert). 
When you press the  Right arrow key, the program uses the four frames in the top 
row (frames 1 through 4) to make Alec face east as he walks. When you press the 
 Up arrow key, the program uses the four frames in the second row (frames 5 
through 8) to make Alec face north as he walks. When you press the  Down arrow 
key, the program uses the four frames in the third row (frames 9 through 12) to 
make Alec face south as he walks. When you press the  Left arrow key, the program 
uses the four frames in the fourth row (frames 13 through 16) to make Alec face 
west as he walks. 

490 
Chapter 10  Using Files and Arrays with the AGK
 Figure  10-21 shows the screen that is displayed when you start the program, with Alec 
positioned on the stone pathway (this also appears as Figure C-14 in the book’s color insert).  
 Figure 10-21  Starting screen from Program 10-9  
 Let’s analyze the program. Lines 17 through 27 declare the constants that we will use 
as image numbers for the tiles. Lines 30 and 31 declare constants for the tile image 
width and height. Lines 34 and 35 declare constants for the numbers of tile rows and 
columns that we will display. (These constants will be used as size declarators for the 
two-dimensional tile map array.) 
 Lines 38 through 54 declare the following constants that are used for the Alec char-
acter’s animated sprite: 
 37  // Constants for the Alec sprite sheet 
 38  const int ALEC_IMAGE       = 12;  // Texture atlas image index 
 39  const int ALEC_SPRITE       = 100; // Alec's sprite index 
 40  const int ALEC_FRAME_WIDTH  = 40;  // Alec's frame width 
 41  const int ALEC_FRAME_HEIGHT = 75;  // Alec's frame height 
 42  const int ALEC_FRAME_COUNT  = 16;  // Alec's frame count 
 43  const int EAST_START        = 1;   // First frame for going east 
 44  const int EAST_END          = 4;   // Last frame for going east 
 45  const int NORTH_START       = 5;   // First frame for going north 
 46  const int NORTH_END        = 8;   // Last frame for going north 
 47  const int SOUTH_START       = 9;   // First frame for going south 
 48  const int SOUTH_END         = 12;  // Last frame for going south 
 49  const int WEST_START        = 13;  // First frame for going west 
 50  const int WEST_END          = 16;  // Last frame for going west 
 51  const int ALEC_FPS          = 5;   // Alec's frames per second 
 52  const int ANIMATION_LOOP    = 1;   // To make Alec loop 
 53  const float ALEC_STARTING_X = 0;   // Alec's starting  X -coordinate 
 54  const float ALEC_STARTING_Y  = 150;  // Alec's starting  Y -coordinate  

 
10.3 Tile Maps 
491
 ●  Line 38:  ALEC_IMAGE is the image index that we will use for the texture atlas that 
contains the animation frames for the Alec character.  
 ●  Line 39:  ALEC _ SPRITE is the sprite index for the Alec character.  
 ●  Lines 40 and 41:  ALEC_FRAME_WIDTH and  ALEC_FRAME_HEIGHT are the width and 
height of each frame in the texture atlas.  
 ●  Line 42:  ALEC_FRAME_COUNT is the number of frames in the texture atlas.  
 ●  Lines 43 and 44:  EAST_START is the frame number for Alec’s first east-facing 
frame, and  EAST_END is the frame number for Alec’s last east-facing frame.  
 ●  Lines 45 and 46:  NORTH_START is the frame number for Alec’s first north-facing 
frame, and  NORTH_END is the frame number for Alec’s last north-facing frame.  
 ●  Lines 47 and 48:  SOUTH_START is the frame number for Alec’s first south-facing 
frame, and  SOUTH_END is the frame number for Alec’s last south-facing frame.  
 ●  Lines 49 and 50:  WEST_START is the frame number for Alec’s first west-facing 
frame, and  WEST_END is the frame number for Alec’s last west-facing frame.  
 ●  Line 51:  ALEC_FPS specifies the frames per second for the animation.  
 ●  Line 52:  ANIMATION_LOOP specifies that the Alec animation sequence should loop.  
 ●  Lines 53 and 54:  ALEC_STARTING_X and  ALEC_STARTING_Y specify the starting  X- 
and  Y -coordinates for the Alec sprite.  
 Lines 57 through 60 declare the constants  NORTH ,  SOUTH ,  EAST , and  WEST , initialized 
with the values 1, 2, 3, and 4, respectively. We will use these constants to indicate the 
direction that Alec is facing. 
 In lines 63 through 74 we declare the  g_tileMap array and initialize it with image 
index constants for the tiles. 
 Inside the  app::Begin function, we set the text for the window’s title bar in line 83, 
and we set the virtual resolution in line 86. In line 89 we load the Alec.png file as an 
image. This file contains the texture map for the Alec character. 
 In line 92 we create the Alec sprite, using the texture map as its image. In line 95 we 
set the Alec sprite’s depth to 0 to ensure that it is displayed on top of the tile images. 
In lines 98 and 99 we set the Alec sprite’s position. In lines 102 through 103 we call 
the  agk::SetSpriteAnimation function to specify the frame width, frame height, and 
frame count in the texture atlas. 
 Line 106 calls the  loadTiles function, to load the image tiles, and line 109 calls the 
 displayTiles function to display the tiles. 
 Inside the  app::Loop function, line 116 declares a local variable,  directionX , ini-
tialized with the value returned from the  agk::GetDirectionX function. Line 117 
declares a local variable,  directionY , initialized with the value returned from the 
 agk::GetDirectionY function.  Recall from  Chapter  8 that the  agk::GetDirectionX 
function returns a nonzero value if either the left or right arrow key is being 
pressed, and the  agk::GetDirectionY function returns a nonzero value if either the 
up or down arrow key is being pressed. 
 The  if statement in line 121 determines whether the  directionX variable is not zero. 
If this is the case, then either the left or right arrow key was pressed, so line 123 calls 
the  updateAlecX function, passing  directionX as an argument. The  updateAlecX func-
tion, which is defined in lines 196 through 234, determines which arrow key is bring 
pressed and updates Alec accordingly. 

492 
Chapter 10  Using Files and Arrays with the AGK
 The  if statement in line 128 determines whether the  directionY variable is not zero. 
If this is the case, then either the up or down arrow key was pressed, so line 130 calls 
the  updateAlecY function, passing  directionY as an argument. The  updateAlecY func-
tion, which is defined in lines 239 through 277, determines which arrow key is bring 
pressed and updates Alec accordingly. 
 Line 134 calls the  agk::Sync function to update the screen. 
 The  loadTiles function, in lines 144 through 157, and the  displayTiles function, in 
lines 161 through 191, are the same as in Program 10-8. 
 The  updateAlecX function is defined in lines 196 through 234. The function has a 
parameter variable named  directionX . When this function is called, the value that is 
returned from  agk::GetDirectionX is passed as an argument. Line 198 declares a local 
variable named  alecX, which is used to hold Alec’s current  X -coordinate. Line 199 
declares a local variable named  newX that will hold Alec’s new  X -coordinate. Line 202 
gets Alec’s current  X -coordinate. The  if statement in line 205 determines whether 
 directionX is greater than 0. If this is the case, then the right arrow key is pressed. 
Lines 208 through 210 start Alec’s east-facing animation, line 213 saves Alec’s new 
direction to the  g_alecDirection variable, and line 216 calculates Alec’s new 
 X -coordinate by adding 1 to the sprite’s current  X -coordinate. Otherwise, the  else  if 
clause in line 218 determines whether  directionX is less than 0. If this is the case, then 
the left arrow key is pressed, and lines 221 through 223 start Alec’s west-facing ani-
mation. Line 226 saves Alec’s new direction to the  g_alecDirection variable, and line 
229 calculates Alec’s new  X -coordinate by subtracting 1 from the sprite’s current 
 X -coordinate. Line 233 moves the Alec sprite. 
 The  updateAlecY function is defined in lines 239 through 273. The function has a param-
eter variable named  directionY . When this function is called, the value that is returned 
from  agk::GetDirectionY is passed as an argument. Line 241 declares a local variable 
named  alecY, which is used to hold Alec’s current  Y -coordinate. Line 242 declares a 
local variable named  newY that will hold Alec’s new  Y -coordinate. Line 245 gets Alec’s 
current  Y -coordinate. The  if statement in line 248 determines whether  directionY is less 
than 0. If this is the case, then the up arrow key is pressed. Lines 251 through 253 start 
Alec’s north-facing animation, line 256 saves Alec’s new direction to the  g_alecDirection 
variable, and line 259 calculates Alec’s new  Y- coordinate by subtracting 1 from the 
sprite’s current  Y -coordinate. Otherwise, the  else  if clause in line 261 determines 
whether  directionY is less than 0. If this is the case, then the down arrow key is pressed, 
and lines 264 through 266 start Alec’s south-facing animation. Line 269 saves Alec’s new 
direction to the  g_alecDirection variable, and line 272 calculates Alec’s new  Y -coordinate 
by adding 1 to the sprite’s current  Y -coordinate. Line 276 moves the Alec sprite. 
 Encountering Obstacles 
 In Program 10-10, the user can make the Alec character walk anywhere on the screen 
on top of the background tiles. This includes the rock tiles and the tiles that make up 
the tree. To make the program more realistic, we should treat the rocks and the tree 
as obstacles and prevent Alec from walking on those tiles. 
 To achieve this, we will create an array to hold the sprite indices of the tiles that we 
consider obstacles. Then, when we move Alec around on the screen, we will check 

 
10.3 Tile Maps 
493
for collisions with any of those sprites. If Alec collides with an obstacle sprite, we will 
prevent him from moving on top of that sprite. Program 10-10 demonstrates how 
this is done. 
 Program 10-10 
  (Obstacles.cpp) 
  1 // Includes, namespace and prototypes 
  2 #include "template.h" 
  3 using namespace AGK; 
  4 app App; 
  5  
  6 // Function prototypes 
  7 void loadTiles(); 
  8 void displayTiles(); 
  9 void addObstacle(int); 
 10 void updateAlecX(float); 
 11 void updateAlecY(float); 
 12 void checkForCollision(); 
 13  
 14 // Constants for the screen resolution 
 15 const int SCREEN_WIDTH  = 640; 
 16 const int SCREEN_HEIGHT = 480; 
 17  
 18 // Constants for the image numbers 
 19 const int GRASS  = 1; 
 20 const int PATH   = 2; 
 21 const int PATHNE = 3; 
 22 const int PATHNW = 4; 
 23 const int PATHSE = 5; 
 24 const int PATHSW = 6; 
 25 const int TREENW = 7; 
 26 const int TREENE = 8; 
 27 const int TREESW = 9; 
 28 const int TREESE = 10; 
 29 const int ROCK   = 11; 
 30  
 31 // Constants for the tile image sizes 
 32 const int TILE_WIDTH  = 64; 
 33 const int TILE_HEIGHT = 48; 
 34  
 35 // Constants for the tile map size declarators 
 36 const int TILE_ROWS = 10; 
 37 const int TILE_COLS = 10; 
 38  
 39 // Constants for the Alec sprite sheet 
 40 const int ALEC_IMAGE        = 12;  // Texture atlas image index 
 41 const int ALEC_SPRITE       = 100; // Alec's sprite index 
 42 const int ALEC_FRAME_WIDTH  = 40;  // Alec's frame width 
 43 const int ALEC_FRAME_HEIGHT = 75;  // Alec's frame height 
 44 const int ALEC_FRAME_COUNT  = 16;  // Alec's frame count 
 45 const int EAST_START        = 1;   // First frame for going east 
 46 const int EAST_END          = 4;   // Last frame for going east 
 47 const int NORTH_START       = 5;   // First frame for going north 
 48 const int NORTH_END         = 8;   // Last frame for going north 

494 
Chapter 10  Using Files and Arrays with the AGK
 49 const int SOUTH_START       = 9;   // First frame for going south 
 50 const int SOUTH_END         = 12;  // Last frame for going south 
 51 const int WEST_START        = 13;  // First frame for going west 
 52 const int WEST_END          = 16;  // Last frame for going west 
 53 const int ALEC_FPS          = 5;   // Alec's frames per second 
 54 const int ANIMATION_LOOP    = 1;   // To make Alec loop 
 55 const float ALEC_STARTING_X = 0;   // Alec's starting  X -coordinate 
 56 const float ALEC_STARTING_Y = 150; // Alec's starting  Y -coordinate 
 57  
 58 // Constants for Alec's direction 
 59 const int NORTH = 1; 
 60 const int SOUTH = 2; 
 61 const int EAST  = 3; 
 62 const int WEST  = 4; 
 63  
 64 // Constant for the maximum number of obstacles 
 65 const int MAX_OBSTACLES = 7; 
 66  
 67 // Constant for the collision sound index 
 68 const int COLLISION_SOUND = 1; 
 69  
 70 // The tile map 
 71 int g_tileMap[TILE_ROWS][TILE_COLS] = 
 72 { {GRASS, GRASS, GRASS, GRASS, GRASS,  GRASS,  GRASS,  GRASS,  GRASS, GRASS}, 
 73   {GRASS, GRASS, GRASS, ROCK,  GRASS,  GRASS,  GRASS,  GRASS,  GRASS, GRASS}, 
 74   {GRASS, GRASS, GRASS, GRASS, GRASS,  GRASS,  GRASS,  PATHNW, PATH,  PATH }, 
 75   {GRASS, GRASS, GRASS, GRASS, GRASS,  TREENW, TREENE, PATH,   GRASS, GRASS}, 
 76   {PATH,  PATH,  PATH,  PATH,  PATHNE, TREESW, TREESE, PATH,   ROCK,  GRASS}, 
 77   {GRASS, GRASS, GRASS, GRASS, PATH,   GRASS,  GRASS,  PATH,   GRASS, GRASS}, 
 78   {GRASS, GRASS, GRASS, GRASS, PATHSW, PATH,   PATH,   PATHSE, GRASS, GRASS}, 
 79   {GRASS, GRASS, GRASS, GRASS, GRASS,  GRASS,  GRASS,  GRASS,  GRASS, GRASS}, 
 80   {GRASS, ROCK,  GRASS, GRASS, GRASS,  GRASS,  GRASS,  GRASS,  GRASS, GRASS}, 
 81   {GRASS, GRASS, GRASS, GRASS, GRASS,  GRASS,  GRASS,  GRASS,  GRASS, GRASS} 
 82 }; 
 83  
 84 // Obstacle array 
 85 int g_obstacles[MAX_OBSTACLES]; 
 86  
 87 // Variable for Alec's direction 
 88 int g_alecDirection = EAST; 
 89  
 90 // Begin app, called once at the start 
 91 void app::Begin( void ) 
 92 { 
 93    // Set the window title. 
 94    agk::SetWindowTitle("Walking Alec"); 
 95  
 96    // Set the virtual resolution. 
 97    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 98  
 99    // Load the collision sound. 
 100    agk::LoadSound(COLLISION_SOUND, "Alec/boink.wav"); 
 101  
 102    // Load the texture atlas. 
 103    agk::LoadImage(ALEC_IMAGE, "Alec/Alec.png"); 
 104  

 
10.3 Tile Maps 
495
 105    // Create the sprite using the texture atlas as the image. 
 106    agk::CreateSprite(ALEC_SPRITE, ALEC_IMAGE); 
 107  
 108    // Make sure Alec is displayed on top of the tile sprites. 
 109    agk::SetSpriteDepth(ALEC_SPRITE, 0); 
 110  
 111    // Set Alec's starting position. 
 112    agk::SetSpritePosition(ALEC_SPRITE, ALEC_STARTING_X, 
 113                           ALEC_STARTING_Y); 
 114  
 115    // Set the sprite animation. 
 116    agk::SetSpriteAnimation(ALEC_SPRITE, ALEC_FRAME_WIDTH, 
 117                            ALEC_FRAME_HEIGHT, ALEC_FRAME_COUNT); 
 118  
 119    // Load the tile images. 
 120    loadTiles(); 
 121  
 122    // Create the tile sprites and display them. 
 123    displayTiles(); 
 124 } 
 125  
 126 // Main loop, called every frame 
 127 void app::Loop ( void ) 
 128 { 
 129    // Get the state of the direction keys. 
 130    float directionX = agk::GetDirectionX(); 
 131    float directionY = agk::GetDirectionY(); 
 132  
 133    // If the right or left arrow keys are pressed, 
 134    // update Alec's position. 
 135    if (directionX != 0) 
 136    { 
 137       // Update Alec's  X -coordinate. 
 138       updateAlecX(directionX); 
 139  
 140       // Check for any collisions. 
 141       checkForCollision(); 
 142    } 
 143  
 144    // If the up or down arrow keys are pressed, 
 145    // update Alec's position. 
 146    if (directionY != 0) 
 147    { 
 148       // Update Alec's  Y -coordinate 
 149       updateAlecY(directionY); 
 150  
 151       // Check for any collisions. 
 152       checkForCollision(); 
 153    } 
 154  
 155    // Refresh the screen. 
 156    agk::Sync(); 
 157 } 
 158  
 159 // Called when the app ends 
 160 void app::End ( void ) 

496 
Chapter 10  Using Files and Arrays with the AGK
 161 { 
 162 } 
 163  
 164 // The loadTiles function loads the images that will be 
 165 // used for tiles. 
 166 void loadTiles() 
 167 { 
 168    agk::LoadImage(GRASS,  "Alec/Grass.png"); 
 169    agk::LoadImage(PATH,   "Alec/Path.png"); 
 170    agk::LoadImage(PATHNE, "Alec/PathNE.png"); 
 171    agk::LoadImage(PATHNW, "Alec/PathNW.png"); 
 172    agk::LoadImage(PATHSE, "Alec/PathSE.png"); 
 173    agk::LoadImage(PATHSW, "Alec/PathSW.png"); 
 174    agk::LoadImage(TREENE, "Alec/TreeNE.png"); 
 175    agk::LoadImage(TREENW, "Alec/TreeNW.png"); 
 176    agk::LoadImage(TREESE, "Alec/TreeSE.png"); 
 177    agk::LoadImage(TREESW, "Alec/TreeSW.png"); 
 178    agk::LoadImage(ROCK,   "Alec/Rock.png"); 
 179 } 
 180  
 181 // The displayTiles function displays the tiles, as 
 182 // specified by the tile map. 
 183 void displayTiles() 
 184 { 
 185    // Variables for the tile coordinates 
 186    float x = 0, y = 0; 
 187  
 188    // Variable to temporarily hold a sprite index 
 189    int spriteIndex; 
 190  
 191    // Variable to be an obstacle counter 
 192    int obstacleCounter = 0; 
 193     
 194    // Display all the tiles specified in the map. 
 195    for (int r = 0; r < TILE_ROWS; r++) 
 196    { 
 197       // Set x to 0. 
 198       x = 0; 
 199  
 200       // Display all the tiles in this row. 
 201       for (int c = 0; c < TILE_COLS; c++) 
 202       { 
 203          // Create a sprite for this tile. 
 204          spriteIndex = agk::CreateSprite(g_tileMap[r][c]); 
 205  
 206          // If this is an obstacle, add it to the 
 207          // obstacle array. 
 208          if (g_tileMap[r][c] > PATHSW) 
 209          { 
 210             // Add it to the array. 
 211             g_obstacles[obstacleCounter] = spriteIndex; 
 212  
 213             // Update the obstacle counter. 
 214             obstacleCounter++; 
 215          } 

 
10.3 Tile Maps 
497
 216  
 217          // Set the tile's position. 
 218          agk::SetSpritePosition(spriteIndex, x, y); 
 219  
 220          // Update the  X -coordinate for the next tile. 
 221          x += TILE_WIDTH; 
 222       } 
 223     
 224       // Increase y for the next row. 
 225       y += TILE_HEIGHT; 
 226    } 
 227 } 
 228  
 229 // The updateAlecX function turns Alec either east or west, 
 230 // depending on which arrow key is being pressed, and moves 
 231 // him to his new  X -coordinate. 
 232 void updateAlecX(float directionX) 
 233 { 
 234    float alecX,   // Alec's current X position 
 235          newX;    // Alec's new  X -coordinate 
 236  
 237    // Get Alec's  X -coordinate 
 238    alecX = agk::GetSpriteX(ALEC_SPRITE); 
 239  
 240    // Which key was pressed? Right or left? 
 241    if (directionX > 0) 
 242    { 
 243       // Turn Alec east 
 244       agk::PlaySprite(ALEC_SPRITE, ALEC_FPS, 
 245                       ANIMATION_LOOP, 
 246                       EAST_START, EAST_END); 
 247  
 248       // Save Alec's current direction. 
 249       g_alecDirection = EAST; 
 250  
 251       // Calculate Alec's new  X -coordinate. 
 252       newX = alecX + 1; 
 253    } 
 254    else if (directionX < 0) 
 255    { 
 256       // Turn Alec west 
 257       agk::PlaySprite(ALEC_SPRITE, ALEC_FPS, 
 258                       ANIMATION_LOOP, 
 259                       WEST_START, WEST_END); 
 260  
 261       // Save Alec's current direction. 
 262       g_alecDirection = WEST; 
 263  
 264       // Calculate Alec's new  X -coordinate 
 265       newX = alecX - 1; 
 266    } 
 267  
 268    // Move Alec 
 269    agk::SetSpriteX(ALEC_SPRITE, newX); 
 270 } 

498 
Chapter 10  Using Files and Arrays with the AGK
 271  
 272 // The updateAlecY function turns Alec either north or south, 
 273 // depending on which arrow key is being pressed, and moves 
 274 // him to his new  Y -coordinate. 
 275 void updateAlecY(float directionY) 
 276 { 
 277    float alecY,   // Alec's current Y position 
 278          newY;    // Alec's new  Y -coordinate 
 279  
 280    // Get Alec's  Y -coordinate 
 281    alecY = agk::GetSpriteY(ALEC_SPRITE); 
 282  
 283    // Which key was pressed? Up or down? 
 284    if (directionY < 0) 
 285    { 
 286       // Turn Alec north 
 287       agk::PlaySprite(ALEC_SPRITE, ALEC_FPS, 
 288                       ANIMATION_LOOP, 
 289                       NORTH_START, NORTH_END); 
 290  
 291       // Save Alec's current direction. 
 292       g_alecDirection = NORTH; 
 293  
 294       // Calculate Alec's new  Y -coordinate. 
 295       newY = alecY - 1; 
 296    } 
 297    else if (directionY > 0) 
 298    { 
 299       // Turn Alec south 
 300       agk::PlaySprite(ALEC_SPRITE, ALEC_FPS, 
 301                       ANIMATION_LOOP, 
 302                       SOUTH_START, SOUTH_END); 
 303 
 304       // Save Alec's current direction. 
 305       g_alecDirection = SOUTH; 
 306  
 307       // Calculate Alec's new  Y -coordinate. 
 308       newY = alecY + 1; 
 309    } 
 310  
 311    // Move Alec 
 312    agk::SetSpriteY(ALEC_SPRITE, newY); 
 313 } 
 314  
 315 // The checkForCollision function determines whether Alec 
 316 // has collided with an obstacle. If Alec has collided 
 317 // with an obstacle, it moves his position in the opposite 
 318 // direction one pixel. 
 319 void checkForCollision() 
 320 { 
 321    // Get Alec's position. 
 322    float x = agk::GetSpriteX(ALEC_SPRITE); 
 323    float y = agk::GetSpriteY(ALEC_SPRITE); 
 324  
 325    // Step through the obstacles array checking for 

 
10.3 Tile Maps 
499
 326    // a collision. 
 327    for (int index = 0; index < MAX_OBSTACLES; index++) 
 328    { 
 329       if (agk::GetSpriteCollision(ALEC_SPRITE, g_obstacles[index])) 
 330       { 
 331          // Play the collision sound. 
 332          agk::PlaySound(COLLISION_SOUND); 
 333  
 334          // Move Alec one pixel in the direction opposite 
 335          // that which he is facing. 
 336          switch (g_alecDirection) 
 337          { 
 338          case NORTH: 
 339             y++; 
 340             break; 
 341  
 342          case SOUTH: 
 343             y--; 
 344             break; 
 345  
 346          case EAST: 
 347             x--; 
 348             break; 
 349  
 350          case WEST: 
 351             x++; 
 352             break; 
 353          } 
 354  
 355          // Move Alec. 
 356          agk::SetSpritePosition(ALEC_SPRITE, x, y); 
 357       } 
 358    } 
 359 }  
 Program 10-10 works in many ways like Program 10-9, but we need to look at the 
differences. First, let’s look at the new constants that are declared: 
 ●  Line 65 declares an  int constant named  MAX_OBSTACLES , which specifies the 
number of obstacles that appear in the game. We set this constant to the 
value 7 because we have a total of 7 obstacle tiles in the tile map. This con-
stant will be used as the size declarator for the array that holds the obstacle 
sprite numbers  
 ●  Line 68 declares an  int constant named  COLLISION_SOUND , which specifies the 
sound index for a sound that we will play when Alec collides with an obstacle.  
 In line 85 we declare an  int array named  g_obstacles . This is the array that will 
hold the sprite indices of the obstacle sprites. The sprite numbers of the obstacles 
are added to the array in the  displayTiles function. In the  displayTiles function, 
in line 192, we have declared a local variable named  obstacleCounter , initialized 
with 0. This variable will be used to keep count of the obstacles as we add them to 
the  g_obstacles array. The  for loop that appears in lines 201 through 222 steps 

500 
Chapter 10  Using Files and Arrays with the AGK
through each element of the  g_tileMap array, creating and displaying all the tile 
sprites. We have added the  if statement that appears in lines 208 through 215. The 
 if statement starts like this: 
 if (g_tileMap[r][c] > PATHSW)  
 To understand how this works, look at the constants declared in lines 19 through 29 
for the tile image indices: 
 19  const int GRASS  = 1; 
 20  const int PATH   = 2; 
 21  const int PATHNE = 3; 
 22  const int PATHNW = 4; 
 23  const int PATHSE = 5; 
 24  const int PATHSW = 6; 
 25  const int TREENW = 7; 
 26  const int TREENE = 8; 
 27  const int TREESW = 9; 
 28  const int TREESE = 10; 
 29  const int ROCK   = 11;  
 The constants that represent the obstacles are  TREENW ,  TREENE ,  TREESW ,  TREESE , and 
 ROCK . Notice that the values of all of these constants are greater than the value of 
the  PATHSW constant. The  if statement in line 208 determines whether a value in 
the array represents an obstacle. If so, it means the sprite that was just created is 
an obstacle, so line 211 adds the sprite index to the  g_obstacles array, and line 
214 increments the  obstacleCounter variable. When the  displayTiles function 
finishes, the  g_obstacles array will contain the sprite indices of all the obstacle 
sprites. 
 The  app::Begin function is the same as previously shown in Program 10-9, except for 
the new statement in line 100 that loads a sound file. We will play this sound each 
time Alec collides with an obstacle sprite. 
 In the app::Loop function, notice that we call a function named  checkForCollision  in 
lines 141 and 152. The  checkForCollision function determines whether Alec has col-
lided with an obstacle. If so, it moves him back one pixel, thus preventing him from 
walking over it. 
 The  checkForCollision function appears in lines 319 through 359. The statements 
in lines 322 and 323 get the Alec sprite’s  X- and  Y -coordinates and stores those 
values in the local variables   x and  y . Then, the  for loop that starts in line 327 steps 
through the  g_obstacles array, checking to see if the Alec sprite has collided with 
any obstacles. It does this with the  if statement in line 329. If a collision has 
occurred, line 332 plays the collision sound, and the  switch statement in line 336 
executes. The  switch statement tests the value of the  g_alecDirection variable and 
then branches to the appropriate  case statement to increase or decrease either the   x 
or  y variable (to move Alec backward by one pixel). The statement in line 356 sets 
the Alec sprite’s position. 
 When you run this program, you will be able to move Alec up to, but not over, any 
of the rocks or the tree.  

 
Review Questions 
501
 Checkpoint 
  10.8.  What are tiles?  
  10.9.   What is a tile map?  
 10.10.   Suppose you are writing a tile-based game that uses a screen 640 pixels wide 
by 480 pixels high. The tiles that you want to use for the background are 
80 pixels wide by 80 pixels high. How many rows and columns will the tile 
map have?  
 Review Questions 
 Multiple Choice  
 
1.   A file that data is written to is known as a(n) _____.  
 a.  input file  
 b.  output file  
 c.  sequential access file  
 d.   binary file  
 
2.   A file that data is read from is known as a(n) _____.  
 a.  input file  
 b.  output file  
 c.  sequential access file  
 d.   binary file  
 
3.   Before a file can be used by a program, it must be _____.  
 a.  formatted  
 b.  encrypted  
 c.  closed  
 d.  opened 
 
4.  When a program is finished using a file, it should _____.  
 a.  erase the file  
 b.   open the file  
 c.   close the file  
 d.   encrypt the file  
 
5.   You use _____ to open an output file.  
 a.  agk::OpenToWrite 
 b.  agk::OpenToRead 
 c.  agk::OpenOutput 
 d.  agk::Open 
 
6.   You use _____ to open an input file.  
 a.  agk::OpenToWrite 
 b.  agk::OpenToRead 
 c.  agk::OpenInput 
 d.  agk::Open 

502 
Chapter 10  Using Files and Arrays with the AGK
 
7.  You use _____ to write an integer value to a file.  
 a.  agk::WriteInteger 
 b.  agk::WriteInt 
 c.  agk::IntegerOut 
 d.  agk::WriteFile 
 
8.   You use _____ to write a null-terminated string to a file.  
 a.  agk::WriteNullString 
 b.  agk::WriteStr 
 c.  agk::WriteLine 
 d.  agk::WriteString 
 
9.   You use _____ to write a string, followed by a newline, to a file.  
 a.  agk::WriteNullString 
 b.  agk::WriteStr 
 c.  agk::WriteLine 
 d.  agk::WriteString 
 
10.   _____ returns 1 (true) if the end of the specified file has been reached.  
 a.  agk::FileEOF 
 b.  agk::FileEnd 
 c.  agk::EndOfFile 
 d.  agk::EndReached 
 
11.   Small rectangular images that can be put together to form a larger image are 
called _____.  
 a.  tiles  
 b.  maps 
 c.  components  
 d.  elements  
 
12.   A _____ is a two-dimensional array that specifies the locations of tiles on the 
screen.  
 a.  tile locator  
 b.  tile specifier  
 c.  tile bank  
 d.  tile map  
 True or False  
 
1.  The  agk::OpenToWrite function will fail if the specified file already exists.  
 
2.   When an input file is opened, the read position is set to the last item in the file.  
 
3.  You use the same AGK function to close input files and output files.  
 
4.  The process of opening a file is only necessary with input files. Output files are 
automatically opened when data is written to them.  
 
5.  When a file that already exists is opened for writing in append mode 0, the file’s 
existing contents are erased.  

 
Review Questions 
503
 Short Answer  
 
1.   Describe the three steps that must be taken when a file is used by a program.  
 
2.   Why should a program close a file when it’s finished using it?  
 
3.   What is the purpose of the  agk::FileEOF function? 
 
4.   If an existing file is opened for writing in append mode 0, what happens to the 
file’s existing contents?  
 
5.   If an existing file is opened for writing in append mode 1, what happens to the 
file’s existing contents?  
 
6.   How can you determine whether a file is open in an AGK program?  
 Algorithm Workbench  
 
1.   Write an AGK program that does the following: 
 •  In the  app::Begin function, opens an output file with the name NumberList.dat  
 •  In the  app::Loop function writes the numbers 1 through 100 to the file  
 •  In the  app::End function closes the file  
 
2.   Write an AGK program that does the following: 
 •  In the  app::Begin function, opens the NumberList.dat file that was created 
by the program created in question 1  
 •  In the  app::Loop function, reads all the numbers from the file  
 •  In the  app::End function closes the file  
 
3.   Modify the program that you created in question 2 so it adds all the numbers read 
from the file and displays their total.  
 
4.   Suppose you have the images shown in  Figure   10-22  to use as tiles in a program. 
In the program you declare the following constants for image numbers: 
 const int GRASS  = 1; 
 const int PATH   = 2; 
 const int PATHNE = 3; 
 const int PATHNW = 4; 
 const int PATHSE = 5; 
 const int PATHSW = 6;  
Grass.bmp
Path.bmp
PathNE.bmp
PathNW.bmp
PathSE.bmp
PathSW.bmp
 Figure 10-22  Tile images  
 In the same program you load the images using the following statements: 
 agk::LoadImage(GRASS,  "Grass.bmp"); 
 agk::LoadImage(PATH,   "Path.bmp"); 
 agk::LoadImage(PATHNE, "PathNE.bmp"); 
 agk::LoadImage(PATHNW, "PathNW.bmp"); 
 agk::LoadImage(PATHSE, "PathSE.bmp"); 
 agk::LoadImage(PATHSW, "PathSW.bmp");  

504 
Chapter 10  Using Files and Arrays with the AGK
 Write the declaration for a tile map that you would use to display the image 
shown in  Figure  10-23 . Assume that the program uses a virtual resolution of 640 
by 480, and each of the tiles is 64 pixels wide by 48 pixels high.  
 Figure 10-23  Tile-based screen  
 Programming Exercises 
 
1.  Bug Zapper Bonus Time 
 Modify the Bug Zapper game so it reads the high score file when the program 
begins. If the user beats the high score while the game is playing, the user should 
immediately get an extra three seconds of play time.  
 
2.   Log File 
 Modify the Obstacle program shown in this chapter so it writes data to a log file 
describing the movements of the Alec character. For example, the program should 
make an entry in the log file each time Alec changes direction and each time Alec 
collides with an obstacle.  
 
3.   ESP Game 
 Create a game that can test your ESP abilities. In  the book’s  online resources 
(located at  www.pearsonhighered.com/gaddis ), you will find images for cards 
with a triangle, a square, and a circle, as well as a facedown card image. The 
game should work this way: 
 Three cards are shown facedown. Internally, the program should randomly 
select values for each card (one triangle, one square, and one circle). The user 
should be instructed to use the mouse to select which card is the triangle. The 
selected card should then be revealed. 
 Repeat this 10 times, and then display the number of times the user correctly 
identified the triangle card.  
VideoNote
Solving the Bug 
Zapper Bonus Time 
Problem

 
Programming Exercises 
505
 
4.   Matching Card Game 
 For this game you will use six of the poker card images provided in  the book’s 
 online resources (available at  www.pearsonhighered.com/gaddis ) to create a deck 
of 12 cards. There should two of each symbol in the deck. For example, there 
might be two queen of hearts cards, two ace of spades cards, two jack of dia-
monds cards, and so forth. 
 This game is designed for two players. When the game begins, the cards should be 
shuffled, and then all the cards should be shown facedown. Each player takes turns 
picking two cards, with the objective of finding two cards that match. If the two cards 
match, the player gets points, and those two cards are removed from the game. If 
the two cards don’t match, the computer turns them back over, and the next player 
takes a turn. The game ends when all the matching cards have been selected, and the 
player with the highest score wins.  
 
5.   Domination Card Game 
 This is a card game where the user plays against the computer. Create a deck of 
at least 20 cards in which the cards are numbered 1 through 20. When the game 
begins, the deck is shuffled. Then half the deck is given to the user, and the other 
half is given to the computer, with no card values showing. At this point in the 
game, you might want to display the two players’ cards as two separate facedown 
decks, one on the left side of the screen and the other on the right side. 
 During each turn, one card from the user and one card from the computer are 
turned over. The player with the highest value gets to keep both cards, which 
are placed back at the bottom of that player’s deck. The game is won when one 
player has all the cards. (As an alternative, you can design the game to end after 
a specified number of turns. The player with the highest value set of cards wins.)  
 
6.   Coins and Snakes 
 In this chapter, you saw Program 10-10, which lets the user move the Alec char-
acter around a tile-based screen. Use the same tile images to create a similar game 
that has at least 10 rocks placed around the screen. Some of the rocks should turn 
into a coin when Alec comes in contact with them, and some of the rocks should 
turn into a snake. When a rock turns into a coin, the player earns one point, and 
when a rock turns into a snake, the player loses one point. When all the coins or 
all the snakes have been uncovered, the game ends. The object of the game is to 
have at least one point when the game ends. (You will find coin and snake images 
in  the book’s  online resources at  www.pearsonhighered.com/gaddis .) 

This page intentionally left blank 

507
 
11.1  Procedural and Object-Oriented Programming 
 CONCEPT:    Procedural programming is a method of writing software. It is a pro-
gramming practice centered on the procedures or actions that take place 
in a program. Object-oriented programming is centered on objects. 
Objects are created from abstract data types that encapsulate data and 
functions together.  
 Primarily two methods of programming are in use today: procedural and object ori-
ented. The earliest programming languages were procedural, meaning a program was 
made of one or more procedures. A  procedure is simply a function that performs a 
specific task such as gathering input from the user, performing calculations, reading 
or writing files, or displaying output. The programs that you have written so far have 
been procedural in nature. 
 Procedures typically operate on data items that are separate from the procedures. In 
a procedural program, the data items are commonly passed from one procedure to 
another. As you might imagine, the focus of procedural programming is on the cre-
ation of procedures that operate on the program’s data. The separation of data and 
the code that operates on the data can lead to problems, however, as the program 
becomes larger and more complex. 
 For example, suppose you are part of a programming team that has developed a game. 
When the program was initially designed, it kept several sprite indices in  int variables. 
Your job was to design several functions that accept those variables as arguments and 
perform operations with them. The software has been operating successfully for some 
 11.1   Procedural and Object-Oriented 
Programming   
 11.2  Classes and Objects   
 11.3  Inheritance   
 TOPICS 
 Object-Oriented 
Programming  
11 
 CHAPTER 

508 
Chapter 11  Object-Oriented Programming
time, but your team has been asked to update it by adding several new features. During 
the revision process, the senior programmer informs you that the sprite indices will no 
longer be stored in variables. Instead, they will be stored in an  int array. This means 
that you will have to modify all the functions that you have designed so they accept 
and work with an  int array instead of the variables. Making these extensive modifica-
tions is not only a great deal of work, but it also opens the opportunity for errors to 
appear in your code. 
 Whereas procedural programming is centered on creating functions,  object-oriented 
programming ( OOP ) is centered on creating objects. An  object is a software entity 
that contains fields and methods. An object’s  fields are simply variables, arrays, or 
other data structures that are stored in the object. An object’s  methods are functions 
that perform operations on the object’s data. The object is, conceptually, a self-con-
tained unit consisting of data (fields) and functions (methods). This is illustrated in 
 Figure   11-1 . 
 OOP addresses the problem of code/data separation through encapsulation and data 
hiding.  Encapsulation refers to combining data and code into a single object.  Data 
hiding refers to an object’s ability to hide its fields from code that is outside the object. 
Only the object’s methods may then directly access and make changes to the object’s 
fields. An object typically hides its fields, but allows outside code to access its meth-
ods. As shown in  Figure  11-2  , the object’s methods provide programming statements 
outside the object with indirect access to the object’s fields.  
Methods That 
Operate on the Data
Data (Fields)
Object
 Figure 11-1  An object contains data and 
functions  
Methods That 
Operate on the Data
Data (Fields)
Object
Code
outside the
object
 Figure 11-2  Code outside the object 
interacts with the object’s methods  
 When an object’s fields are hidden from outside code and access to those fields is 
restricted to the object’s methods, the fields are protected from accidental corruption. 
In addition, the programming code outside the object does not need to know about 
the format or internal structure of the object’s fields. The code only needs to interact 

 
11.1 Procedural and Object-Oriented Programming 
509
with the object’s methods. When a programmer changes the structure of an object’s 
internal data, he or she also modifies the object’s methods so they may properly oper-
ate on the data. The way in which outside code interacts with the methods, however, 
does not change. 
 Object Reusability 
 In addition to solving the problems of code/data separation, the use of OOP has also 
been encouraged by the trend of  object reusability . An object is not a stand-alone 
program, but is used by programs that need its service. For example, Sharon is a pro-
grammer who has developed an object for rendering 3-D images. She is a math whiz 
and knows a lot about computer graphics, so her object is coded to perform all the 
necessary 3-D mathematical operations and handle the computer’s video hardware. 
Tom, who is writing a program for an architectural firm, needs his application to 
display 3-D images of buildings. Because he is working under a tight deadline and 
does not possess a great deal of knowledge about computer graphics, he can use 
Sharon’s object to perform the 3-D rendering (for a small fee, of course!).  
 An Everyday Example of an Object 
 Think of your alarm clock as an object. It has the following fields: 
 ●  The current second (a value in the range of 0–59)  
 ●  The current minute (a value in the range of 0–59)  
 ●  The current hour (a value in the range of 1–12)  
 ●  The time the alarm is set for (a valid hour and minute)  
 ●  Whether the alarm is on or off (“on” or “off”)  
 As you can see, the fields are merely data values that define the  state that the alarm 
clock is currently in. You, the user of the alarm clock object, cannot directly manipu-
late these fields because they are  private . To change a field’s value, you must use one 
of the object’s methods. Here are some of the alarm clock object’s methods: 
 ●  Set time  
 ●  Set alarm time  
 ●  Turn alarm on  
 ●  Turn alarm off  
 Each method manipulates one or more of the fields. For example, the “Set time” method 
allows you to set the alarm clock’s time. You activate the method by pressing a button 
on the clock. By using another button, you can activate the “Set alarm time” method. 
 In addition, another button allows you to execute the “Turn alarm on” and “Turn 
alarm off” methods. Notice that all these methods can be activated by you, who are 
outside the alarm clock. Methods that can be accessed by entities outside the object 
are known as  public methods . 
 OOP Terminology 
 OOP programmers commonly use the term  fields to describe the items of data that 
are stored in an object and the term  methods to describe the procedures that operate 

510 
Chapter 11  Object-Oriented Programming
on an object’s data. C++ programmers often refer to fields as  member variables and 
refer to methods as  member functions . These are the terms that we will use because 
they are commonly used in C++. 
 Checkpoint 
  11.1.   What is an object?  
  11.2.   What is encapsulation?  
  11.3.   Why is an object’s internal data usually hidden from outside code?  
  11.4.   What are public methods?  
 
11.2  Classes and Objects  
 CONCEPT:   A class is code that specifies the fields and methods for a particular 
type of object.  
 Let’s discuss how objects are created in software. Before an object can be created, it 
must be designed by a programmer. The programmer determines the member vari-
ables and member functions that are necessary and then creates a  class . A class is code 
that specifies the member variables and member functions that a particular type of 
object has. Think of a class as a “blueprint” that may be used to create objects. It 
serves a similar purpose as the blueprint for a house. The blueprint itself is not a 
house, but is a detailed description of a house. When we use the blueprint to build an 
actual house, we could say we are building an instance of the house described by the 
blueprint. If we so desire, we can build several identical houses from the same blue-
print. Each house is a separate instance of the house described by the blueprint. This 
idea is illustrated in  Figure   11-3  . 
House Plan
Living Room
Bedroom
Blueprint that describes a house.
Instances of the house described by the blueprint.
 Figure 11-3  A blueprint and houses built from the blueprint  

 
11.2 Classes and Objects 
511
 Another way of thinking about the difference between a class and an object is to think 
of the difference between a cookie cutter and a cookie. A cookie cutter itself is not a 
cookie, but it describes a cookie. The cookie cutter can be used to make several cook-
ies, as shown in  Figure  11-4 . Think of a class as a cookie cutter and the objects created 
from the class as cookies.  
 So, a class is not an object, but a description of an object. When the program is 
running, it can use the class to create, in memory, as many objects of a specific 
type as needed. Each object that is created from a class is called an  instance of 
the class. 
 For example, Jessica is a game programmer. She is developing a game in which the 
user moves a hero sprite around the screen. During game play, the program auto-
matically moves an enemy sprite around the screen. The user must make sure the hero 
sprite does not come in contact with the enemy sprite. 
 Although the hero and enemy sprites are separate elements in the game, all sprites 
have the same characteristics. For example, all sprites have a sprite index, an 
 X -coordinate, a  Y -coordinate, and an alpha value. Jessica decides that she can write a 
 Sprite class that specifies member variables to hold a sprite’s data and member func-
tions that perform operations on a sprite. The  Sprite class is not an object, but a 
blueprint from which objects may be created. 
 Jessica’s program will then use the  Sprite class to create a  hero object in memory. 
The  hero object is an instance of the  Sprite class, and it stores data specific to the 
hero sprite. When the program needs to manipulate the hero sprite, it calls the  hero 
object’s member functions. The program will also use the  Sprite class to create an 
 enemy object in memory. The  enemy object is also an instance of the  Sprite class, 
and it stores data specific to the enemy sprite. When the program needs to manip-
ulate the enemy sprite, it calls the  enemy object’s member functions.  Figure   11-5 
illustrates the idea that the  hero object and the  enemy object are both instances of 
the  Sprite class.  
Cookie cutter
Cookies
Think of a class as a cookie cutter and objects as the cookies.
 Figure 11-4  The cookie cutter metaphor  

512 
Chapter 11  Object-Oriented Programming
 Class Declarations 
 To create a class, you first write the  class declaration . This is the general format that 
we will use to write a class definition in C++: 
 class  ClassName 
 { 
 private:  
 Member variables go here. 
 public:  
 Member function declarations go here. 
 };  
 The first line is known as the  class header . It starts with the key word  class , followed 
by the name of the class. The same rules for naming variables apply to naming classes. 
Many programmers follow the convention of beginning class names with an uppercase 
letter. This serves as a visual reminder that the name is that of a class, not a variable. 
 Following the class header is an opening curly brace. On the line after the opening 
curly brace we write the key word  private followed by a colon. This marks the begin-
ning of the class’s  private section . We typically declare all the class’s member variables 
(fields) in the private section. As a result, those member variables can be accessed only 
by the class’s member functions. 
 After the private section we write the key word  public , followed by a colon. This 
marks the beginning of the class’s  public section . Any class members that are declared 
in the public section can be accessed by code that is outside the class. This is where 
we typically declare the class’s member functions. Declaring member functions in the 
public section makes them available to code outside the class. 
 At the end of the class definition is a closing curly brace, followed by a semicolon. 
Don’t forget to write the semicolon, or an error will occur when you compile the code.  
Sprite
class
hero
object
enemy
object
The Sprite class describes
a particular type of object.
The hero object is an instance of the
Sprite class. It has the member
variables and member functions
described by the Sprite class.
The enemy object is an instance of the
Sprite class. It has the member
variables and member functions
described by the Sprite class.
 Figure 11-5  The hero and enemy objects are instances of the Sprite class  
 NOTE:   You normally don’t write a semicolon after a closing brace, but C++ 
requires that you write a semicolon after a class’s closing brace. Forgetting to do so 
is a common mistake and will prevent your code from compiling. 

 
11.2 Classes and Objects 
513
 Mutators and Accessors 
 By declaring a class’s member variables private and providing access to those variables 
through public member functions, you ensure that the object owning those member 
variables is in control of all changes being made to them. A member function that 
stores a value in a member variable or changes the value of a member variable in some 
other way is known as a  mutator function . A member function that gets a value from 
a class’s member variable but does not change it is known as an  accessor function . 
 Constructors 
 Classes usually have a special member function known as a constructor. A  constructor 
is automatically executed when an object of the class is created. A constructor is used 
to initialize the object’s member variables with starting values and perform any startup 
operations. These member functions are called “constructors” because they help con-
struct an object. A constructor will always have the same name as the class that it 
belongs to.  
 Destructors 
 Classes sometimes have a special member function known as a destructor. A destructor 
is automatically called when an object of the class is destroyed. In the same way that 
constructors set things up when an object is created, destructors perform shutdown 
procedures when the object is destroyed. Destructors always have the same name as 
the class, preceded by a tilde character ( ~ ).  
 Designing a  Sprite Class 
 Let’s look at an example of a class that you can use in your AGK programs. When 
designing a game as an object-oriented program, you will want to make objects for 
all the major elements in the game. Sprites are excellent candidates to become objects. 
Earlier in this chapter we mentioned that all sprites have the same characteristics. For 
example, all sprites have a sprite index, an  X -coordinate, a  Y -coordinate, an alpha 
value, and so on. In addition, all sprites support the same set of operations, such as 
setting the position, hiding, showing, and so forth. Because all sprites have so much 
in common, we can create a  Sprite class, and then each time we need a sprite in our 
program, use the class to create an object. 
 We will examine a simple  Sprite class that provides the basic operations needed to cre-
ate and work with a sprite. The class will have the following private member variables: 
 ●  spriteIndex —An  int variable will hold the sprite’s index.  
 ●  imageFile —A  string object to hold the name of the sprite’s image file.  
 The class also has the following public member functions: 
 ●  Constructor—Initializes the member variables.  
 ●  createSprite —Creates the sprite in the AGK window.  
 ●  setPosition —Sets the sprite’s position to a specific set of  XY -coordinates. 
 ●  setX —Sets the sprite’s  X -coordinate only.  
 ●  setY —Sets the sprite’s  Y -coordinate only.  

514 
Chapter 11  Object-Oriented Programming
 ●  getSpriteIndex —Returns the index for the sprite.  
 ●  getX —Returns the sprite’s current  X -coordinate.  
 ●  getY —Returns the sprite’s current  Y -coordinate.  
 ●  Destructor—Deletes the sprite from memory.  
 Program 11-1 shows a partial listing for the program that demonstrates the class. The 
 Sprite class declaration is shown in lines 8 through 30. 
 Let’s look at the actual code for the  Sprite class. We will write the class in an AGK 
 template.cpp program, after the include directives and other code that appears at the 
top of the program, but before the  app::Begin function. Program 11-1 is a partial 
listing for the program, showing only lines 1 through 32. The  Sprite class declaration 
begins in line 8. 
 Program 11-1 
 (SpriteClassDemo1, partial listing) 
 1 // Includes, namespace and prototypes 
 2 #include "template.h" 
 3 #include <string>      // Needed for the string class 
 4 using namespace std;   // Needed for the string class 
 5 using namespace AGK; 
 6 app App; 
 7  
 8 class Sprite 
 9 { 
 10 private: 
 11    int spriteIndex;   // The sprite index 
 12    string imageFile;  // The name of the image file 
 13 public: 
 14    // Constructor 
 15    Sprite(int, string); 
 16  
 17    // Mutators 
 18    void createSprite(); 
 19    void setPosition(float, float); 
 20    void setX(float); 
 21    void setY(float); 
 22  
 23    // Accessors 
 24    int getSpriteIndex() const; 
 25    string getImageFile() const; 
 26    float getX() const; 
 27    float getY() const; 
 28  
 29    // Destructor 
 30    ~Sprite(); 
 31 }; 
 32  
 Let’s step through the code. First, notice that we have an  include directive for the 
 string header file in line 3, and the  using namespace std; statement in line 4. These 
are necessary because we are using  string objects in the program. 

 
11.2 Classes and Objects 
515
 The  Sprite class definition appears in lines 8 through 31. Notice that the name of the 
class begins with an uppercase letter. As previously mentioned, this serves as a visual 
reminder that  Sprite is a class. 
 The class’s private section begins in line 10. In lines 11 and 12 we declare the 
 spriteIndex and   imageFile member variables. As previously mentioned, these vari-
ables will hold the sprite’s index and the name of the image file to use when the sprite 
is created on the screen. Because these member variables are declared in the  Sprite 
class’s private section, they can be accessed only by functions that are members of the 
 Sprite class. 
 We declare the member functions in the class’s public section, which begins in line 13. 
Notice that the member function declarations look just like function prototypes, 
except that they appear inside the class declaration. Here is a summary of the member 
function declarations: 
 ●  In line 15 we declare the constructor. Notice that the constructor’s name is the 
same as the class— Sprite . Also notice that there is no return type—not even 
 void . This is because constructors are not executed by explicit function calls and 
cannot return a value.  
 ●  In line 18 we declare a  void member function named  createSprite . The 
function creates the sprite in the AGK output window, at the default position 
of (0, 0).  
 ●  In line 19 we declare a  void member function named  setPosition . The function 
accepts two  float arguments. These arguments are the  X- and  Y -coordinates 
where the sprite will be positioned.  
 ●  In line 20 we declare a  void member function named  setX . The function accepts 
a  float argument for the sprite’s  X -coordinate.  
 ●  In line 21 we declare a  void member function named  setY . The function accepts 
a  float argument for the sprite’s  Y -coordinate.  
 ●  In line 24 we declare an  int member function named  getSpriteIndex . The func-
tion returns the sprite’s index.  
 ●  In line 25 we declare an  string member function named  getImageFile . The 
function returns the name of the sprite’s image file.  
 ●  In line 26 we declare a  float member function named  getX . The function returns 
the sprite’s  X -coordinate.  
 ●  In line 27 we declare a  float member function named  getY . The function returns 
the sprite’s  Y -coordinate.  
 ●  In line 30 we declare the destructor. Notice that the destructor’s name is the same 
as the class, with a tilde character ( ~ ) at the beginning. Also notice that there is no 
return type. Like constructors, destructors are not executed by explicit function 
calls and cannot return a value.  
 NOTE:   Perhaps you noticed that the word  const appears at the end of the func-
tion headers in lines 24 through 27. This specifies that these functions do not change 
any data stored in the calling object. In any of these functions, if you inadvertently 
write code that changes the calling object’s data, the compiler will generate an error. 
It is good programming practice to mark all accessor functions as  const . 

516 
Chapter 11  Object-Oriented Programming
 Defining Member Functions 
 In lines 15 through 30 of the  Sprite class we declared 10 member functions. Those 
declarations alone do nothing. They simply inform the compiler that those functions 
are members of the class. Now we must write the definitions of those member func-
tions. The definition of the constructor is shown in lines 36 through 40, as follows. 
 Program 11-1 
 (SpriteClassDemo1, continued) 
 33 // The Sprite class constructor accepts as arguments 
 34 // the sprite index and the name of the image file, 
 35 // and initializes the member variables. 
 36 Sprite::Sprite(int index, string filename) 
 37 { 
 38    spriteIndex = index; 
 39    imageFile = filename; 
 40 } 
 41  
 The function header appears in line 36. Notice that the function name starts with  Sprite:: . 
This indicates that the function is not a regular function, but a member of the  Sprite class. 
Following that, the word  Sprite is the name of the function. Because this is a constructor, 
it has the same name as the class that it belongs to. Inside the parentheses are two param-
eters,  index and  filename . The constructor header is illustrated in  Figure   11-6 . 
Sprite::Sprite(int index, string filename)
This indicates that the function
belongs to the Sprite class.
This is the name of the function.
Parameters
 Figure 11-6  Constructor function header  
 The purpose of the constructor is to initialize the two private member variables, 
 spriteIndex and   imageFile with the values that are passed as arguments to the 
constructor. The argument passed into  index is assigned to  spriteIndex , and the 
argument passed into  filename is assigned to  imageFile .  
 The definition of the  createSprite member function is shown in lines 43 through 51, 
as follows: 
 Program 11-1 
 (SpriteClassDemo1, continued) 
 42 // The Sprite::createSprite member function 
 43 void Sprite::createSprite() 
 44 { 
 45    // If the sprite does not already exist, 

 
11.2 Classes and Objects 
517
 46    // then create it. 
 47    if (!agk::GetSpriteExists(spriteIndex)) 
 48    { 
 49       agk::CreateSprite(spriteIndex, imageFile.c_str()); 
 50    } 
 51 } 
 52 
 The function header appears in line 43. Once again, notice that the function name is pre-
fixed with  Sprite:: to indicate that it is a member of the  Sprite class. The purpose of this 
function is to create the sprite on the screen. The  if statement in line 47 determines 
whether the sprite already exists. If it does not exist, line 49 calls the  agk::CreateSprite 
function to create it. 
 Recall that when you call the  agk::CreateSprite function, you pass the sprite index 
and the name of the image file as arguments. In line 49 we pass the following argu-
ments to the  agk::CreateSprite function: 
 ●  For the first argument, we pass the  spriteIndex member variable. This assigns 
the value of  spriteIndex as the sprite’s index.  
 ●  For the second argument, we call the  imageFile object’s  c_str member function. 
This is necessary because you cannot pass a  string object directly to the 
 agk::CreateSprite function. The  string object’s  c_str member function re-
turns the object’s contents formatted in a way that is compatible with the 
 agk::CreateSprite function. (You might recall from  Chapter   7 that you have to 
use the  c_str member function to print the contents of a  string object with the 
 agk::Print and  agk::PrintC functions.) 
 The definition of the  setPosition member function is shown in lines 55 through 58, 
as follows: 
 Program 11-1 
 (SpriteClassDemo1, continued) 
 53 // The Sprite::setPosition member function sets the 
 54 // sprite's position. 
 55 void Sprite::setPosition(float x, float y) 
 56 { 
 57    agk::SetSpritePosition(spriteIndex, x, y); 
 58 } 
 59   
 The purpose of the  setPosition member function is to set the sprite’s position. When 
you call this function, you pass two arguments: an  X- and a  Y -coordinate. Line 57 
calls the  agk::SetSpritePosition function, passing the sprite index and the  XY -
coordinates as arguments. 
 The definition of the  setX member function is shown in lines 62 through 65, as 
follows: 

518 
Chapter 11  Object-Oriented Programming
 Program 11-1 
 (SpriteClassDemo1, continued) 
 60 // The Sprite::setX member function sets the 
 61 // sprite's  X -coordinate. 
 62 void Sprite::setX(float x) 
 63 { 
 64    agk::SetSpriteX(spriteIndex, x); 
 65 } 
 66  
 The purpose of the  setX member function is to set the sprite’s  X -coordinate only. When 
you call this function, you pass an  X -coordinate as an argument, and line 64 calls the 
 agk::SetSpriteX function, passing the sprite index and the  X -coordinate as arguments. 
 The definition of the  setY member function is shown in lines 69 through 72, as follows: 
 Program 11-1 
 (SpriteClassDemo1, continued) 
 67 // The Sprite::setY member function sets the 
 68 // sprite's  Y -coordinate. 
 69 void Sprite::setY(float y) 
 70 { 
 71    agk::SetSpriteY(spriteIndex, y); 
 72 } 
 73  
 The purpose of the  setY member function is to set the sprite’s  Y -coordinate only. When 
you call this function, you pass a  Y -coordinate as an argument, and line 71 calls the 
 agk::SetSpriteY function, passing the sprite index and the  Y -coordinate as arguments. 
 The definition of the  getSpriteIndex member function is shown in lines 76 through 
79, as follows: 
 Program 11-1 
 (SpriteClassDemo1, continued) 
 74 // The Sprite::getSpriteIndex member function 
 75 // returns the sprite's index. 
 76 int Sprite::getSpriteIndex() const 
 77 { 
 78    return spriteIndex; 
 79 } 
 80  
 The purpose of the  getSpriteIndex member function is to return the sprite’s index. 
The  getSpriteIndex member function is an accessor that returns the value of the 
 spriteIndex member variable. Notice that the word   const appears at the end of the 
function header in line 76. As previously mentioned, this specifies that the function 
does not modify the object’s state. It merely returns a value from the object. 

 
11.2 Classes and Objects 
519
 The definition of the  getImageFile member function is shown in lines 84 through 87, 
as follows: 
 Program 11-1 
 (SpriteClassDemo1, continued) 
 81 // The Sprite::getImageFile member function 
 82 // returns the name of the image file used to 
 83 // create this sprite. 
 84 string Sprite::getImageFile() const 
 85 { 
 86    return imageFile; 
 87 } 
 88   
 The purpose of the  getImageFile member function is to return the name of the sprite’s 
image file. The  getSpriteIndex member function is an accessor that returns the value 
of the  imageFile member variable. (As previously mentioned, the word   const at the 
end of the function header specifies that the function does not modify the object’s 
state. It merely returns a value from the object.) 
 The definition of the  getX member function is shown in lines 91 through 94, as follows: 
 Program 11-1 
 (SpriteClassDemo1, continued) 
 89 // The Sprite::getX member function returns the 
 90 // sprite's  X -coordinate. 
 91 float Sprite::getX() const 
 92 { 
 93    return agk::GetSpriteX(spriteIndex); 
 94 } 
 95  
 The purpose of the  getX member function is to return the sprite’s  X -coordinate. In line 
93, the  agk::GetSpriteX function is called to get the sprite’s  X -coordinate, and that 
value is returned from the  getX member function. (As previously mentioned, the word 
 const at the end of the function header specifies that the function does not modify the 
object’s state. It merely returns a value from the object.) 
 The definition of the  getY member function is shown in lines 98 through 101, as follows: 
 Program 11-1 
 (SpriteClassDemo1, continued) 
 96 // The Sprite::getY member function returns the 
 97 // sprite's  Y -coordinate. 
 98 float Sprite::getY() const 
 99 { 
 100    return agk::GetSpriteY(spriteIndex); 
 101 } 
 102  

520 
Chapter 11  Object-Oriented Programming
 The purpose of the  getY member function is to return the sprite’s  Y -coordinate. In line 
100, the  agk::GetSpriteX function is called to get the sprite’s  Y -coordinate, and that 
value is returned from the  getY member function. (As previously mentioned, the word 
 const at the end of the function header specifies that the function does not modify the 
object’s state. It merely returns a value from the object.) 
 The class destructor is shown next, in lines 105 through 108. When an instance of this 
class is destroyed, the destructor deletes the sprite from memory. 
 Program 11-1 
 (SpriteClassDemo1, continued) 
 103 // The Sprite class destructor deletes the 
 104 // sprite from memory. 
 105 Sprite::~Sprite() 
 106 { 
 107    agk::DeleteSprite(spriteIndex); 
 108 } 
 109  
 Now, let’s look at the rest of the program, which uses the  Sprite class to create and 
display a spaceship sprite. Lines 110 through 144 are shown here: 
 Program 11-1 
 (SpriteClassDemo1, continued) 
 110 // Constants for the screen resolution 
 111 const int SCREEN_WIDTH = 640; 
 112 const int SCREEN_HEIGHT = 480; 
 113  
 114 // Constants related to the sprite. 
 115 const int SPACESHIP_INDEX = 1; 
 116 const float SPACESHIP_X = 215; 
 117 const float SPACESHIP_Y = 212; 
 118  
 119 Sprite spaceship(SPACESHIP_INDEX, "Space/spaceship.png"); 
 120  
 121 // Begin app, called once at the start 
 122 void app::Begin( void ) 
 123 { 
 124    // Set the virtual resolution. 
 125    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 126  
 127    // Create the sprite on the screen. 
 128    spaceship.createSprite(); 
 129  
 130    // Position the sprite. 
 131    spaceship.setPosition(SPACESHIP_X, SPACESHIP_Y); 
 132 } 
 133  
 134 // Main loop, called every frame 
 135 void app::Loop ( void ) 

 
11.2 Classes and Objects 
521
 136 { 
 137    // Display the screen. 
 138    agk::Sync(); 
 139 } 
 140  
 141 // Called when the app ends 
 142 void app::End ( void ) 
 143 { 
 144 }  
 Lines 111 and 112 declare global constants for the screen resolution, and lines 115 through 
117 declare global constants for the sprite’s index,  X -coordinate, and  Y -coordinate. 
 Line 119 creates an object from the  Sprite class. Here is the statement that creates 
the object: 
 Sprite spaceship(SPACESHIP_INDEX, "Space/spaceship.png");  
 Think of this statement as being similar to a variable declaration. Instead of a vari-
able, however, we are declaring an object of the  Sprite  class. The object’s name is 
 spaceship . The items that appear inside the parentheses are arguments we are passing 
to the class constructor (previously shown in lines 36 through 40). After this state-
ment executes, an object that is an instance of the  Sprite  class will exist in memory, 
and the object’s name will be  spaceship . That object’s  index  member variable will be 
assigned the value 1 (the value of the  SPACESHIP_INDEX  constant), and the object’s 
 imageFile  member variable will be assigned the string  "Space/spaceship.png" . This 
is illustrated in  Figure   11-7 . Note that because the object is declared globally, it will 
be available to all the functions in the program.  
spaceship is a Sprite object
index
imageFile
1
"Space/spaceship.png"
 Figure 11-7  An instance of the  Sprite class 
 Next is the  app::Begin function, shown in lines 122 through 132. Line 125 sets the 
virtual resolution. Line 128, shown here, appears next: 
 spaceship.createSprite();  
 The statement is written in  dot notation . It’s called dot notation because programmers 
refer to the period as a “dot.” On the left side of the dot is the name of an object. On 
the right side of the dot is the name of the member function we are calling. When this 
statement executes, the  createSprite member function will be called to operate on 
the  spaceship object. Recall that the  createSprite member function (previously 
shown in lines 43 through 51) creates the sprite on the screen. 

522 
Chapter 11  Object-Oriented Programming
 Next, in line 131, we call the  setPosition member function on the  spaceship object, 
passing the constants  SPACESHIP_X and  SPACESHIP_Y as arguments: 
 spaceship.setPosition(SPACESHIP_X, SPACESHIP_Y);  
 The values of the constants  SPACESHIP_X and  SPACESHIP_Y are 215 and 212, respectively. 
After this statement executes, the sprite will be located at the coordinates (215, 212). 
 Next is the  app::Loop function that simply calls the  agk::Sync function in line 138 to 
update the screen. The program’s output is shown in  Figure   11-8  . 
 NOTE:   To run this program, you will need to create a folder named  Space in your 
 My Documents >  AGK >  template folder and then copy the image file  spaceship.png 
into the  Space folder. 
 Figure 11-8  Output of Program 11-1  
 Creating Multiple Objects From the Same Class 
 You can create several objects from the same class in a program. Each object has its 
own set of member variables. For example, look at Program 11-2, which creates three 
spaceship sprites, each of which is an instance of the  Sprite class. The spaceship 
sprites are placed at different positions on the screen. (To save space, we have left out 
lines 32 through 109, which contain the definitions of the  Sprite class’s member func-
tions. The function definitions are the same as those shown in Program 11-1.) 
 Program 11-2 
 (MultipleObjects) 
  1 // Includes, namespace and prototypes 
  2 #include "template.h" 
  3 #include <string>      // Needed for the string class 

 
11.2 Classes and Objects 
523
  4 using namespace std;   // Needed for the string class 
  5 using namespace AGK; 
  6 app App; 
  7  
  8 class Sprite 
  9 { 
 10 private: 
 11    int spriteIndex;  // The sprite index 
 12    string imageFile; // The name of the image file 
 13 public: 
 14    // Constructor 
 15    Sprite(int, string); 
 16  
 17    // Mutators 
 18    void createSprite(); 
 19    void setPosition(float, float); 
 20    void setX(float); 
 21    void setY(float); 
 22  
 23    // Accessors 
 24    int getSpriteIndex() const; 
 25    string getImageFile() const; 
 26    float getX() const; 
 27    float getY() const; 
 28  
 29    // Destructor 
 30    ~Sprite(); 
 31 }; 
 Lines 32 through 109 are not shown. They are the same as was shown in Program 11-1.  
 110 // Constants for the screen resolution 
 111 const int SCREEN_WIDTH = 640; 
 112 const int SCREEN_HEIGHT = 480; 
 113  
 114 // Constants for the sprite indices 
 115 const int SPACESHIP1_INDEX = 1; 
 116 const int SPACESHIP2_INDEX = 2; 
 117 const int SPACESHIP3_INDEX = 3; 
 118  
 119 // Constants for the sprite positions 
 120 const float SPACESHIP1_X = 0; 
 121 const float SPACESHIP1_Y = 0; 
 122  
 123 const float SPACESHIP2_X = 215; 
 124 const float SPACESHIP2_Y = 212; 
 125  
 126 const float SPACESHIP3_X = 430; 
 127 const float SPACESHIP3_Y = 424; 
 128  
 129 Sprite spaceship1(SPACESHIP1_INDEX, "Space/spaceship.png"); 
 130 Sprite spaceship2(SPACESHIP2_INDEX, "Space/spaceship.png"); 
 131 Sprite spaceship3(SPACESHIP3_INDEX, "Space/spaceship.png"); 
 132  
 133 // Begin app, called once at the start 
 134 void app::Begin( void ) 

524 
Chapter 11  Object-Oriented Programming
 135 { 
 136    // Set the virtual resolution. 
 137    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 138  
 139    // Create the sprites on the screen. 
 140    spaceship1.createSprite(); 
 141    spaceship2.createSprite(); 
 142    spaceship3.createSprite(); 
 143  
 144    // Position the sprite. 
 145    spaceship1.setPosition(SPACESHIP1_X, SPACESHIP1_Y); 
 146    spaceship2.setPosition(SPACESHIP2_X, SPACESHIP2_Y); 
 147    spaceship3.setPosition(SPACESHIP3_X, SPACESHIP3_Y); 
 148 } 
 149  
 150 // Main loop, called every frame 
 151 void app::Loop ( void ) 
 152 { 
 153    // Display the screen. 
 154    agk::Sync(); 
 155 } 
 156  
 157 // Called when the app ends 
 158 void app::End ( void ) 
 159 { 
 160 }  
 In lines 115 through 117 we declare constants for the three sprite indices. In lines 120 
through 127 we declare constants for the three sprite’s  XY -coordinates. Then, in lines 
129 through 131 we declare three  Sprite  objects, named  spaceship1 ,  spaceship2 , 
and  spaceship3 : 
 ●  Line 129 declares the  spaceship1 object. We pass the  SPACESHIP1_INDEX  con-
stant (which is set to the value 1) as the sprite index and  "Space/spaceship.png" 
as the name of the image file.  
 ●  Line 130 declares the  spaceship2 object. We pass the  SPACESHIP2_INDEX  con-
stant (which is set to the value 2) as the sprite index and  "Space/spaceship.png" 
as the name of the image file.  
 ●  Line 131 declares the  spaceship3 object. We pass the  SPACESHIP3_INDEX  con-
stant (which is set to the value 3) as the sprite index and  "Space/spaceship.png" 
as the name of the image file.  
 Figure  11-9 illustrates the state of these three objects, showing the values of each 
object’s  index and  imageFile member variable.  
The spaceship1 object
index
imageFile
1
"Space/spaceship.png"
The spaceship2 object
index
imageFile
2
"Space/spaceship.png"
The spaceship3 object
index
imageFile
3
"Space/spaceship.png"
 Figure 11-9  The  spaceship1 ,  spaceship2 , and   spaceship3 objects  

 
11.2 Classes and Objects 
525
 Next is the  app::Begin function, shown in lines 134 through 148. Line 137 sets the 
virtual resolution. Line 140 through 142, shown here, appears next: 
 spaceship1.createSprite(); 
 spaceship2.createSprite(); 
 spaceship3.createSprite();  
 These statements call each object’s  createSprite member function, which creates the 
sprites on the screen. Then, lines 145 through 147 call each object’s  setPosition 
member function, passing the constants that were previously created for the  X- and 
 Y -coordinates: 
 spaceship1.setPosition(SPACESHIP1_X, SPACESHIP1_Y); 
 spaceship2.setPosition(SPACESHIP2_X, SPACESHIP2_Y); 
 spaceship3.setPosition(SPACESHIP3_X, SPACESHIP3_Y);  
 After these statements execute, the  spaceship1 object’s sprite will be positioned at 
(0,0), the  spaceship2 object’s sprite will be positioned at (215, 212), and the  spaceship3 
object’s sprite will be positioned at (430, 424). 
 Next is the  app::Loop function that simply calls the  agk::Sync function in line 154 to 
update the screen. The program’s output is shown in  Figure   11-10  . 
 Overloaded Constructors and Member Functions 
 Sometimes you need different ways to perform the same operations in a class. For 
example, the  Sprite class that was previously shown in Programs 11-1 and 11-2 
requires that you pass a sprite index and an image file name as arguments to the 
constructor. Suppose that in some situations, you need to create an instance of the 
 Sprite class without providing these arguments. For example, the sprite index might 
 Figure 11-10  Output of Program 11-2  

526 
Chapter 11  Object-Oriented Programming
be calculated by the program, or the image file name might be selected by the pro-
gram from several potential file names just before the sprite is created. 
 Fortunately, you can have more than one constructor in a class. When a class has 
multiple constructors, we say that the constructor is  overloaded . When a class has 
overloaded constructors, each of the constructors must have a different parameter list. 
Here is an example of two overloaded  Sprite class constructors: 
 // Constructor #1 
 Sprite::Sprite() 
 { 
    spriteIndex = 1; 
    imageFile = ""; 
 } 
 // Constructor #2 
 Sprite::Sprite(int index, string filename) 
 { 
    spriteIndex = index; 
    imageFile = filename; 
 } 
 The first constructor accepts no arguments. It simply assigns the number 1 to the 
 spriteIndex member variable, and it assigns an empty string ( "" ) to the  imageFile 
member variable. You would use this constructor any time you wanted to create an 
instance of the  Sprite class, but you were not ready to assign a sprite index or specify 
an image file. 
 The second constructor is the same one that you saw in Programs 11-1 and 11-2. It 
has two parameters: an  int named  index and a  string named  filename . These param-
eters are assigned to the object’s member variables. You would use this version of the 
constructor when you know the sprite number and image file name at the time the 
object is created.  
 NOTE:   A constructor that accepts no arguments is known as the class’s  default 
constructor . A constructor that accepts arguments is known as a  parameterized 
constructor. 
 Regular member functions can be overloaded too. For example, here are two over-
loaded versions of the  Sprite class’s  createSprite member function: 
 // Version #1 of the createSprite member function 
 void Sprite::createSprite() 
 { 
     // If the sprite does not already exist, 
     // then create it. 
     if (!agk::GetSpriteExists(spriteIndex)) 
     { 
         agk::CreateSprite(spriteIndex, imageFile.c_str()); 
     } 
 } 

 
11.2 Classes and Objects 
527
 // Version #2 of the createSprite member function 
 void Sprite::createSprite(int index, string filename) 
 { 
     // Set the member variables. 
     spriteIndex = index; 
     imageFile = filename; 
     // If the sprite does not already exist, 
     // then create it. 
     if (!agk::GetSpriteExists(spriteIndex)) 
     { 
        agk::CreateSprite(spriteIndex, imageFile.c_str()); 
     } 
 } 
 The first version of the member function is the same as you previously saw in Programs 
11-1 and 11-2. It accepts no arguments and creates the sprite using the existing values 
of the  spriteIndex and  imageFile member variables. You would use this version of 
the member function whenever the object already contains, in its member variables, 
the desired sprite index and the image file name. (This would be the case when the 
object was created with constructor #2). 
 The second one, however, has two parameters: an  int named  index , and a  string named 
 filename . These parameters are assigned to the object’s member variables, and then the 
sprite is created using those values. You would use this version of the function whenever 
the desired sprite index and image file name have not been assigned to the object’s mem-
ber variables. (This would be the case when the object was created with constructor #1). 
 When an overloaded constructor or member function is called, the compiler must 
determine which of the overloaded constructors or member functions we intended to 
call. The process of matching a function call with the correct function is known as 
 binding . When an overloaded constructor or function is being called, the compiler 
uses the function’s name and parameter list to determine to which function to bind 
the call. For example, if no arguments are passed to the  createSprite member func-
tion, the version of the function with no parameters is called. Likewise, when an  int 
and a  string are passed as arguments to the  createSprite function, the version with 
 int and  string parameters is called.  
 NOTE:    When a class has a constructor that accepts no arguments, that construc-
tor is referred to as the  default constructor . 
 The compiler uses a function’s signature to distinguish it from other functions of the 
same name. A function’s  signature consists of the function’s name and the data types 
of the function’s parameters, in the order that they appear. For example, here are the 
signatures of the  createSprite functions that were previously shown: 
 Sprite::createSprite() 
 Sprite::createSprite(int, string)  
 Note that the function’s return type is  not part of the signature. For this reason, you 
cannot overload functions by giving them different return types. 

528 
Chapter 11  Object-Oriented Programming
 Program 11-3 demonstrates the  Sprite class with the overloaded constructors and 
overloaded  createSprite member functions that we just discussed. This program is 
very similar to Program 11-2, except that it uses the  Sprite class’s default constructor 
(with no arguments) to create the three  Sprite objects. Then, in the  app::Begin func-
tion, it uses the  createSprite member function that accepts an index and an image 
file name as arguments. The program’s output is the same as that of Program 11-2, 
which was previously shown in  Figure   11-10  . 
 Program 11-3 
 (Overloaded) 
  1 // Includes, namespace and prototypes 
  2 #include "template.h" 
  3 #include <string>      // Needed for the string class 
  4 using namespace std;   // Needed for the string class 
  5 using namespace AGK; 
  6 app App; 
  7  
  8 class Sprite 
  9 { 
 10 private: 
 11    int spriteIndex;    // The sprite index 
 12    string imageFile;   // The name of the image file 
 13 public: 
 14    // Constructors 
 15    Sprite(); 
 16    Sprite(int, string); 
 17  
 18    // Mutators 
 19    void createSprite(); 
 20    void createSprite(int, string); 
 21    void setPosition(float, float); 
 22    void setX(float); 
 23    void setY(float); 
 24  
 25    // Accessors 
 26    int getSpriteIndex() const; 
 27    string getImageFile() const; 
 28    float getX() const; 
 29    float getY() const; 
 30  
 31    // Destructor 
 32    ~Sprite(); 
 33 }; 
 34  
 35 // This is the default constructor for the Sprite 
 36 // class. It sets index to 1 and imageFile to 
 37 // an empty string. 
 38 Sprite::Sprite() 
 39 { 
 40    spriteIndex = 1; 
 41    imageFile = ""; 
 42 } 
 43  

 
11.2 Classes and Objects 
529
 44 // This Sprite class constructor accepts as arguments 
 45 // the sprite index and the name of the image file, 
 46 // and initializes the member variables. 
 47 Sprite::Sprite(int index, string filename) 
 48 { 
 49    spriteIndex = index; 
 50    imageFile = filename; 
 51 } 
 52  
 53 // The Sprite::createSprite member function 
 54 void Sprite::createSprite() 
 55 { 
 56    // If the sprite does not already exist, 
 57    // then create it. 
 58    if (!agk::GetSpriteExists(spriteIndex)) 
 59    { 
 60       agk::CreateSprite(spriteIndex, imageFile.c_str()); 
 61    } 
 62 } 
 63  
 64 // The Sprite::createSprite member function 
 65 void Sprite::createSprite(int index, string filename) 
 66 { 
 67    // Set the member variables. 
 68    spriteIndex = index; 
 69    imageFile = filename; 
 70  
 71    // If the sprite does not already exist, 
 72    // then create it. 
 73    if (!agk::GetSpriteExists(spriteIndex)) 
 74    { 
 75       agk::CreateSprite(spriteIndex, imageFile.c_str()); 
 76    } 
 77 } 
 78  
 79 // The Sprite::setPosition member function sets the 
 80 // sprite's position. 
 81 void Sprite::setPosition(float x, float y) 
 82 { 
 83    agk::SetSpritePosition(spriteIndex, x, y); 
 84 } 
 85  
 86 // The Sprite::setX member function sets the 
 87 // sprite's  X -coordinate. 
 88 void Sprite::setX(float x) 
 89 { 
 90    agk::SetSpriteX(spriteIndex, x); 
 91 } 
 92  
 93 // The Sprite::setY member function sets the 
 94 // sprite's  Y -coordinate. 
 95 void Sprite::setY(float y) 
 96 { 
 97    agk::SetSpriteY(spriteIndex, y); 
 98 } 

530 
Chapter 11  Object-Oriented Programming
 99  
 100 // The Sprite::getSpriteIndex member function 
 101 // returns the sprite's index. 
 102 int Sprite::getSpriteIndex() const 
 103 { 
 104    return spriteIndex; 
 105 } 
 106  
 107 // The Sprite::getImageFile member function 
 108 // returns the name of the image file used to 
 109 // create this sprite. 
 110 string Sprite::getImageFile() const 
 111 { 
 112    return imageFile; 
 113 } 
 114  
 115 // The Sprite::getX member function returns the 
 116 // sprite's  X -coordinate. 
 117 float Sprite::getX() const 
 118 { 
 119    return agk::GetSpriteX(spriteIndex); 
 120 } 
 121  
 122 // The Sprite::getY member function returns the 
 123 // sprite's  Y -coordinate. 
 124 float Sprite::getY() const 
 125 { 
 126    return agk::GetSpriteY(spriteIndex); 
 127 } 
 128  
 129 // The Sprite class destructor deletes the 
 130 // sprite from memory. 
 131 Sprite::~Sprite() 
 132 { 
 133    agk::DeleteSprite(spriteIndex); 
 134 } 
 135  
 136 // Constants for the screen resolution 
 137 const int SCREEN_WIDTH = 640; 
 138 const int SCREEN_HEIGHT = 480; 
 139  
 140 // Constants for the sprite indices 
 141 const int SPACESHIP1_INDEX = 1; 
 142 const int SPACESHIP2_INDEX = 2; 
 143 const int SPACESHIP3_INDEX = 3; 
 144  
 145 // Constants for the sprite positions 
 146 const float SPACESHIP1_X = 0; 
 147 const float SPACESHIP1_Y = 0; 
 148  
 149 const float SPACESHIP2_X = 215; 
 150 const float SPACESHIP2_Y = 212; 
 151  
 152 const float SPACESHIP3_X = 430; 
 153 const float SPACESHIP3_Y = 424; 

 
11.2 Classes and Objects 
531
 154  
 155 // Declare three Sprite objects. 
 156 Sprite spaceship1; 
 157 Sprite spaceship2; 
 158 Sprite spaceship3; 
 159  
 160 // Begin app, called once at the start 
 161 void app::Begin( void ) 
 162 { 
 163    // Set the virtual resolution. 
 164    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 165  
 166    // Create the sprites on the screen. 
 167    spaceship1.createSprite(SPACESHIP1_INDEX, "Space/spaceship.png"); 
 168    spaceship2.createSprite(SPACESHIP2_INDEX, "Space/spaceship.png"); 
 169    spaceship3.createSprite(SPACESHIP3_INDEX, "Space/spaceship.png"); 
 170  
 171    // Position the sprite. 
 172    spaceship1.setPosition(SPACESHIP1_X, SPACESHIP1_Y); 
 173    spaceship2.setPosition(SPACESHIP2_X, SPACESHIP2_Y); 
 174    spaceship3.setPosition(SPACESHIP3_X, SPACESHIP3_Y); 
 175 } 
 176  
 177 // Main loop, called every frame 
 178 void app::Loop ( void ) 
 179 { 
 180    // Display the screen. 
 181    agk::Sync(); 
 182 } 
 183  
 184 // Called when the app ends 
 185 void app::End ( void ) 
 186 { 
 187 }  
 Inside the  Sprite class, notice the following: 
 ●  The two overloaded constructors are declared in lines 15 and 16.  
 ●  The two overloaded  createSprite member functions are declared in lines 19 
and 20. 
 After the class definition, the overloaded constructors are defined in lines 38 through 
42 and 47 through 51. The overloaded  createSprite member functions are defined 
in lines 54 through 62 and lines 65 through 77. 
 In lines 156 through 158, we declare three  Sprite objects named  spaceship1 , 
 spaceship2 , and  spaceship3 . Notice that no arguments are passed to the constructor 
(in fact, there aren’t even any parentheses following the object names). This causes the 
default constructor, which is defined in lines 38 through 42, to execute. As a result, 
each object’s  spriteIndex member variable will be set to 1, and each object’s  imageFile 
member variable will be set to an empty string ( "" ). 

532 
Chapter 11  Object-Oriented Programming
 Inside the  app::Begin function, lines 167 through 169, shown here, call each object’s 
 createSprite member function: 
 spaceship1.createSprite(SPACESHIP1_INDEX, "Space/spaceship.png"); 
 spaceship2.createSprite(SPACESHIP2_INDEX, "Space/spaceship.png"); 
 spaceship3.createSprite(SPACESHIP3_INDEX, "Space/spaceship.png");  
 In each of these statements we are passing an  int and a string as arguments. As a 
result, the version of the  createSprite function that appears in lines 65 through 77 
will be called.  
 Creating Arrays of Objects 
 As with any other data type in C++, you can define arrays of class objects. For ex-
ample, the following creates an array of  Sprite objects: 
 const int ARRAY_SIZE = 5; 
 Sprite mysprites[ARRAY_SIZE];  
 This code creates an array of five  Sprite objects. The name of the array is  mysprites , 
and the default constructor is called for each object in the array. Program 11-4 declares 
such an array and demonstrates how to process its elements. (To save space, we have 
left out lines 34 through 135, which contain the definitions of the  Sprite class’s mem-
ber functions. The function definitions are the same as those shown in Program 11-3.) 
The program’s output is shown in  Figure   11-11  . 
 Program 11-4 
 (ObjectArray) 
 1 // Includes, namespace and prototypes 
 2 #include "template.h" 
 3 #include <string>      // Needed for the string class 
 4 using namespace std;   // Needed for the string class 
 5 using namespace AGK; 
 6 app App; 
 7  
 8 class Sprite 
 9 { 
 10 private: 
 11    int spriteIndex;  // The sprite index 
 12    string imageFile; // The name of the image file 
 13 public: 
 14    // Constructors 
 15    Sprite(); 
 16    Sprite(int, string); 
 17  
 18    // Mutators 
 19    void createSprite(); 
 20    void createSprite(int, string); 
 21    void setPosition(float, float); 
 22    void setX(float); 
 23    void setY(float); 
 24  

 
11.2 Classes and Objects 
533
 25    // Accessors 
 26    int getSpriteIndex() const; 
 27    string getImageFile() const; 
 28    float getX() const; 
 29    float getY() const; 
 30  
 31    // Destructor 
 32    ~Sprite(); 
 33 }; 
 Lines 34 through 135 are not shown. They are the same as was shown in Program 11-3.  
 136 // Constants for the screen resolution 
 137 const int SCREEN_WIDTH = 640; 
 138 const int SCREEN_HEIGHT = 480; 
 139  
 140 // Constants for the sprite positions 
 141 const float STARTING_X = 0; 
 142 const float STARTING_Y = 0; 
 143  
 144 // Declare an array of 5 Sprite objects. 
 145 const int ARRAY_SIZE = 5; 
 146 Sprite mysprites[ARRAY_SIZE]; 
 147  
 148 // Begin app, called once at the start 
 149 void app::Begin( void ) 
 150 { 
 151    // Set the virtual resolution. 
 152    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 153  
 154    // Create the sprites on the screen, in a column 
 155    // along the left edge of the window. 
 156    for (int i = 0; i < ARRAY_SIZE; i++) 
 157    { 
 158       mysprites[i].createSprite(i + 1, "Space/spaceship.png"); 
 159    } 
 160  
 161    // Position the sprite. 
 162    for (int i = 0; i < ARRAY_SIZE; i++) 
 163    { 
 164       mysprites[i].setPosition(STARTING_X, STARTING_Y + i * 100); 
 165    } 
 166 } 
 167  
 168 // Main loop, called every frame 
 169 void app::Loop ( void ) 
 170 { 
 171    // Display the screen. 
 172    agk::Sync(); 
 173 } 
 174  
 175 // Called when the app ends 
 176 void app::End ( void ) 
 177 { 
 178 }   

534 
Chapter 11  Object-Oriented Programming
 The  STARTING_X and  STARTING_Y constants, declared in lines 141 and 142, are used as 
the  XY -coordinates of the first sprite that is displayed. We will calculate the coordi-
nates of the remaining sprites, using these values. 
 The following statements in lines 145 and 146 create an array of five  Sprite objects. 
The name of the array is  mysprites , and the default constructor is called for each object: 
 const int ARRAY_SIZE = 5; 
 Sprite mysprites[ARRAY_SIZE];  
 Then, in the  app::Begin function, the following loop appears in lines 156 through 159: 
 for (int i = 0; i < ARRAY_SIZE; i++) 
 { 
   mysprites[i].createSprite(i + 1, "Space/spaceship.png"); 
 } 
 This loop steps through each element of the  mysprites array. Inside the loop, the 
element’s  createSprite member function is called. The value of the expression  i + 1 
is passed as the sprite’s index. As a result, the five sprites will have the indices 1 
through 5. The string   "Space/spaceship.png"  is passed as the image file name for 
each element. 
 Next, the following loop appears in lines 162 through 165: 
 for (int i = 0; i < ARRAY_SIZE; i++) 
 { 
   mysprites[i].setPosition(STARTING_X, STARTING_Y + i * 100); 
 } 
 This loop also steps through each element of the  mysprites array. Inside the loop, the 
element’s  setPosition member function is called to position the element on the screen. 
 Figure 11-11  Output of Program 11-4  

 
11.2 Classes and Objects 
535
The constant  STARTING_X (which is set to 0) is passed as the  X -coordinate for each ele-
ment. The value of the expression  STARTING_Y + i * 100  is passed as the  Y -coordinate. 
As a result, the sprites are displayed in a column along the left edge of the window.  
 Passing Objects as Arguments to Functions 
 Objects can be passed as arguments to functions just like regular variables. When you 
pass an object by value, only a copy of the object is passed into the function. If you want 
the function to be able to modify the object, you must pass it by reference. Program 11-5 
shows an example. In this program we have written a  void function named  placeSprite . 
The  placeSprite function accepts a  Sprite object by reference. It then sets the object’s 
position to a random value. (As with previous programs, we have left out lines 34 
through 135, which contain the definitions of the  Sprite class’s member functions. The 
function definitions are the same as those shown in Program 11-3.) 
 Program 11-5 
 (PassObject) 
  1 // Includes, namespace and prototypes 
  2 #include "template.h" 
  3 #include <string>      // Needed for the string class 
  4 using namespace std;   // Needed for the string class 
  5 using namespace AGK; 
  6 app App; 
  7  
  8 class Sprite 
  9 { 
 10 private: 
 11    int spriteIndex;  // The sprite index 
 12    string imageFile; // The name of the image file 
 13 public: 
 14    // Constructors 
 15    Sprite(); 
 16    Sprite(int, string); 
 17  
 18    // Mutators 
 19    void createSprite(); 
 20    void createSprite(int, string); 
 21    void setPosition(float, float); 
 22    void setX(float); 
 23    void setY(float); 
 24  
 25    // Accessors 
 26    int getSpriteIndex() const; 
 27    string getImageFile() const; 
 28    float getX() const; 
 29    float getY() const; 
 30  
 31    // Destructor 
 32    ~Sprite(); 
 33 }; 
 Lines 34 through 135 are not shown. They are the same as was shown in Program 11-3.  
 136 // Function prototype for the placeSprite function 
 137 void placeSprite(Sprite &); 

536 
Chapter 11  Object-Oriented Programming
 138  
 139 // Constants for the screen resolution 
 140 const int SCREEN_WIDTH = 640; 
 141 const int SCREEN_HEIGHT = 480; 
 142  
 143 // Constants for the sprite index 
 144 const int SPRITE_INDEX = 1; 
 145  
 146 // Declare an instance of the Sprite class 
 147 Sprite spaceship(SPRITE_INDEX, "Space/spaceship.png"); 
 148  
 149 // Begin app, called once at the start 
 150 void app::Begin( void ) 
 151 { 
 152    // Set the virtual resolution. 
 153    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 154  
 155    // Create the sprite on the screen. 
 156    spaceship.createSprite(); 
 157  
 158    // Place the sprite at a random location. 
 159    placeSprite(spaceship); 
 160 } 
 161  
 162 // Main loop, called every frame 
 163 void app::Loop ( void ) 
 164 { 
 165    // Display the screen. 
 166    agk::Sync(); 
 167 } 
 168  
 169 // Called when the app ends 
 170 void app::End ( void ) 
 171 { 
 172 } 
 173  
 174 // The placeSprite function accepts a Sprite object as 
 175 // an argument, and it places that sprite at a random 
 176 // location on the screen. 
 177 void placeSprite(Sprite &sprite) 
 178 { 
 179    // Get random  XY -coordinates for the sprite. 
 180    int x = agk::Random(0, SCREEN_WIDTH - 210); 
 181    int y = agk::Random(0, SCREEN_HEIGHT - 56); 
 182  
 183    // Position the sprite. 
 184    sprite.setPosition(x, y); 
 185 }  
 Note that the function prototype for the  placeSprite function, in line 137, is written after 
the declaration of the  Sprite class. This is necessary because the  placeSprite function 
accepts a  Sprite object as an argument. The compiler must be aware of the  Sprite class’s 
existence before it can process the prototype or the definition of the  placeSprite function. 

 
11.3 Inheritance 
537
 Also note that in line 180, we get a random number in the range of 0 through 
 SCREEN_WIDTH - 210 , and in line 181 we get a random number in the range of 0 
through  SCREEN_HEIGHT - 56 . This is because the  spaceship.png image is 210 pixels 
wide and 56 pixels high, and by using these calculations, we make sure the sprite is 
never positioned offscreen.  
 Checkpoint 
  11.5.  You hear someone make the following comment: “A blueprint is a design for 
a house. A carpenter can use the blueprint to build the house. If the carpenter 
wishes, he or she can build several identical houses from the same blueprint.” 
Think of this as a metaphor for classes and objects. Does the blueprint repre-
sent a class, or does it represent an object?  
  11.6.  In this chapter we use the metaphor of a cookie cutter and cookies that are 
made from the cookie cutter to describe classes and objects. In this metaphor, 
are objects the cookie cutter, or the cookies?  
  11.7.  An object’s private members are accessible by what code?  
  11.8.  Are a class’s member variables typically declared in the class’s public section 
or the class’s private section?  
  11.9.  Are a class’s member functions typically declared in the class’s public section 
or the class’s private section?  
 11.10.  What is an accessor? What is a mutator?  
 11.11.  What is a constructor?  
 11.12.  What is a parameterized constructor? What is a default constructor?  
 11.13.  What are overloaded member functions?  
 11.14.  What is a destructor?  
 
11.3  Inheritance  
 CONCEPT:   Inheritance allows a new class to extend an existing class. The new class 
inherits the members of the class it extends.  
 Generalization and Specialization 
 In the real world you can find many objects that are specialized versions of other more 
general objects. For example, the term  insect describes a very general type of creature 
with numerous characteristics. Because grasshoppers and bumblebees are insects, they 
have all the general characteristics of an insect. In addition, they have special charac-
teristics of their own. For example, the grasshopper has its jumping ability, and the 
bumblebee has its stinger. Grasshoppers and bumblebees are specialized versions of 
an insect. This is illustrated in  Figure   11-12  . 

538 
Chapter 11  Object-Oriented Programming
 Inheritance and the “Is-a” Relationship 
 When one object is a specialized version of another object, an “is-a” relationship ex-
ists between them. For example, a grasshopper is an insect. Here are a few other ex-
amples of the is-a relationship: 
 ●  A poodle is a dog.  
 ●  A car is a vehicle.  
 ●  A flower is a plant.  
 ●  A rectangle is a shape.  
 ●  A football player is an athlete.  
 When an is-a relationship exists between objects, it means that the specialized object 
has all the characteristics of the general object, plus additional characteristics that 
make it special. In object-oriented programming, inheritance is used to create an is-a 
relationship among classes. This allows you to extend the capabilities of a class by 
creating another class that is a specialized version of the first one. 
 Inheritance involves a base class and a derived class. The  base class is the general class, 
and the  derived class is the specialized class. You can think of the derived class as an 
extended version of the base class. The derived class inherits members from the base class 
without any of them having to be rewritten. Furthermore, new members may be added 
to the derived class, and that is what makes it a specialized version of the base class. 
 Let’s look at an example of inheritance. In the previous section we demonstrated a simple 
 Sprite class that provides the basic operations needed to create and work with a sprite. 
In this section we will examine a  MoveableSprite class that is derived from the  Sprite 
class. The  MoveableSprite class will give the ability to move the sprite on the screen. 
 When we derive the  MoveableSprite class from the  Sprite class, the  MoveableSprite 
class will inherit all the members of the  Sprite class. So, when we declare the 
Insect
All insects have
certain characteristics.
In addition to the common
insect characteristics, the
 bumblebee has unique
characteristics such as the
ability to sting.
In addition to the common
insect characteristics, the
 grasshopper has unique
characteristics such as the
ability to jump.
 Figure 11-12  Bumblebees and grasshoppers are specialized versions of an insect  

 
11.3 Inheritance 
539
 MoveableSprite class, we only specify the members that are new to the  MoveableSprite 
class. We will have the following member variable in the  MoveableSprite class: 
 ●  distance —This  int variable will hold the sprite’s moving distance. This is the 
number of pixels that the sprite is to  move each time it is moved.  
 The  MoveableSprite class will also have the following public member functions: 
 ●  Constructor—A parameterized constructor that accepts as arguments the sprite 
index number, the image file name, and the sprite’s moving distance.  
 ●  setDistance —This member function accepts an argument for the sprite’s mov-
ing distance and assigns it to the distance member variable.  
 ●  getDistance —This member function returns the sprite’s moving distance.  
 ●  moveUp —This member function moves the sprite up.  
 ●  moveDown —This member function moves the sprite down.  
 ●  moveLeft —This member function moves the sprite to the left.  
 ●  moveRight —This member function moves the sprite to the right.  
 Program 11-6 demonstrates the  MoveableSprite class. When this program is compiled 
and executed, it displays the spaceship sprite on the screen. You can use the arrow keys 
on the keyboard to move the spaceship up, down, left, or right. To save space, we will not 
show lines 1 through 135 of the program. These lines contain the include directives, other 
initial code, and the  Sprite class code, which is the same as was shown in Program 11-5. 
 The declaration for the  MoveableSprite class begins in line 137. 
 Program 11-6 
 (MoveableSpriteDemo, partial listing) 
 136 // MoveableSprite declaration 
 137 class MoveableSprite : public Sprite 
 138 { 
 139 private: 
 140    int distance; 
 141 public: 
 142    // Constructors 
 143    MoveableSprite(); 
 144    MoveableSprite(int, string, int); 
 145  
 146    // Mutators and accessors 
 147    void setDistance(int); 
 148    int getDistance() const; 
 149  
 150    // Functions to move the sprite 
 151    void moveUp(); 
 152    void moveDown(); 
 153    void moveLeft(); 
 154    void moveRight(); 
 155 }; 
 156  
 The only new notation in this class declaration appears in line 137. After the name of the 
class,  MoveableSprite , a colon appears, followed by  public Sprite . This indicates that the 

540 
Chapter 11  Object-Oriented Programming
 MoveableSprite class is derived from the  Sprite class. (The  MoveableSprite class is the 
derived class, and the  Sprite class is the base class.)  Figure   11-13  illustrates this notation.  
 The  MoveableSprite class has two overloaded constructors, shown here: 
 Program 11-6 
 (MoveableSpriteDemo, continued) 
 157 // Default constructor 
 158 MoveableSprite::MoveableSprite() : Sprite() 
 159 { 
 160    distance = 0; 
 161 } 
 162  
 163 // This constructor accepts arguments for the sprite 
 164 // index, image file name, and distance to move. 
 165 MoveableSprite::MoveableSprite(int index, string filename, 
 166                int dist) : Sprite(index, filename) 
 167 { 
 168    distance = dist; 
 169 } 
 170  
 The default constructor, defined in lines 158 through 161, sets the  distance member 
variable to 0. Notice the notation  : Sprite that appears at the end of line 158. This is an 
explicit call to the  Sprite class’s constructor. This indicates that the  Sprite class’s default 
constructor will be executed first, then the  MoveableSprite constructor will execute. 
 The second constructor, which appears in lines 165 through 169, accepts arguments 
for the sprite index, the image file name, and the sprite’s moving distance. Notice the 
following that appears at the end of line 166: 
 : Sprite(index, filename)  
The class being declared
(the derived class)
The colon indicates that this class
is derived from another class.
The base class
class MoveableSprite : public Sprite
{
private:
    int distance;
public:
   // Constructors
   MoveableSprite();
   MoveableSprite(int, string, int);
   and so forth...
 Figure 11-13  Inheritance notation in the class header  
 WARNING!   When writing the class header for a derived class, don’t forget the 
word   public that appears after the colon. If you leave out the word   public , the class 
will compile, but it will not be able to access any of the base class members. 

 
11.3 Inheritance 
541
 This is an explicit call to the  Sprite class constructor. This executes the parameterized 
 Sprite class constructor, passing the values of  index and  filename as arguments. After 
the parameterized  Sprite class constructor executes, the  MoveableSprite class con-
structor executes. In line 168, it assigns the value of the  dist parameter to the distance 
member variable. 
 The  setDistance member function is defined in lines 173 through 176. 
 Program 11-6 
 (MoveableSpriteDemo, continued) 
 171 // The setDistance member function sets 
 172 // the moving distance. 
 173 void MoveableSprite::setDistance(int dist) 
 174 { 
 175    distance = dist; 
 176 } 
 177  
 The  getDistance member function is defined in lines 180 through 183. 
 Program 11-6 
 (MoveableSpriteDemo, continued) 
 178 // The getDistance member function returns the 
 179 // sprite's moving distance. 
 180 int MoveableSprite::getDistance() const 
 181 { 
 182    return distance; 
 183 } 
 184  
 The  moveUp member function is defined in lines 186 through 197. 
 Program 11-6 
 (MoveableSpriteDemo, continued) 
 185 // The moveUp member function moves the sprite up. 
 186 void MoveableSprite::moveUp() 
 187 { 
 188    // Get the sprite's current coordinates. 
 189    int x = getX(); 
 190    int y = getY(); 
 191  
 192    // Decrease y. 
 193    y -= distance; 
 194  
 195    // Move the sprite to its new location. 
 196    setY(y); 
 197 } 
 198  
 Lines 189 and 190 call the  Sprite class’s  getX and  getY member functions to get the 
sprite’s current  XY -coordinates. Those values are assigned to the local variables  x and  y . 

542 
Chapter 11  Object-Oriented Programming
Line 193 decreases the value of  y by the value of the  distance member variable. Line 196 
calls the  Sprite class’s  setY function to position the sprite at its new location. 
 The  moveDown member function is defined in lines 200 through 211, as follows: 
 Program 11-6 
 (MoveableSpriteDemo, continued) 
 199 // The moveDown member function moves the sprite down. 
 200 void MoveableSprite::moveDown() 
 201 { 
 202    // Get the sprite's current coordinates. 
 203    int x = getX(); 
 204    int y = getY(); 
 205  
 206    // Increase y. 
 207    y += distance; 
 208  
 209    // Move the sprite to its new location. 
 210    setY(y); 
 211 } 
 212  
 Lines 203 and 204 call the  Sprite class’s  getX and  getY member functions to get the 
sprite’s current  XY -coordinates. Those values are assigned to the local variables  x and 
 y . Line 207 increases the value of  y by the value of the  distance member variable. Line 
210 calls the  Sprite class’s  setY function to position the sprite at its new location. 
 The  moveLeft member function is defined in lines 214 through 225, as follows: 
 Program 11-6 
 (MoveableSpriteDemo, continued) 
 213 // The moveLeft member function moves the sprite left. 
 214 void MoveableSprite::moveLeft() 
 215 { 
 216    // Get the sprite's current coordinates. 
 217    int x = getX(); 
 218    int y = getY(); 
 219  
 220    // Decrease x. 
 221    x -= distance; 
 222  
 223    // Move the sprite to its new location. 
 224    setX(x); 
 225 } 
 226  
 Lines 217 and 218 call the  Sprite class’s  getX and  getY member functions to get the 
sprite’s current  XY -coordinates. Those values are assigned to the local variables  x and 
 y . Line 221 decreases the value of  x by the value of the  distance member variable. Line 
224 calls the  Sprite class’s  setX function to position the sprite at its new location. 

 
11.3 Inheritance 
543
 The  moveRight member function is defined in lines 228 through 239, as follows: 
 Program 11-6 
 (MoveableSpriteDemo, continued) 
 227 // The moveRight member function moves the sprite right. 
 228 void MoveableSprite::moveRight() 
 229 { 
 230    // Get the sprite's current coordinates. 
 231    int x = getX(); 
 232    int y = getY(); 
 233  
 234    // Increase x. 
 235    x += distance; 
 236  
 237    // Move the sprite to its new location. 
 238    setX(x); 
 239 } 
 240  
 Lines 231 and 232 call the  Sprite class’s  getX and  getY member functions to get the 
sprite’s current  XY -coordinates. Those values are assigned to the local variables  x and 
 y . Line 235 increases the value of  x by the value of the  distance member variable. Line 
238 calls the  Sprite class’s  setX function to position the sprite at its new location. 
 The remaining lines of the program are shown here: 
 Program 11-6 
 (MoveableSpriteDemo, continued) 
 241 // Function prototype for the updateSprite function 
 242 void updateSprite(MoveableSprite &); 
 243  
 244 // Constants for the screen resolution 
 245 const int SCREEN_WIDTH = 640; 
 246 const int SCREEN_HEIGHT = 480; 
 247  
 248 // Constant for the sprite index 
 249 const int SPRITE_INDEX = 1; 
 250  
 251 // Constant for the moving distance 
 252 const int MOVING_DISTANCE = 10; 
 253  
 254 // Declare an instance of the MoveableSprite class 
 255 MoveableSprite spaceship(SPRITE_INDEX, 
 256    "Space/spaceship.png", MOVING_DISTANCE); 
 257  
 258 // Begin app, called once at the start 
 259 void app::Begin( void ) 
 260 { 
 261    // Set the virtual resolution. 
 262    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 263  
 264    // Create the sprite on the screen. 
 265    spaceship.createSprite(); 

544 
Chapter 11  Object-Oriented Programming
 266  
 267    // Position the sprite at the center of the screen. 
 268    spaceship.setPosition(SCREEN_WIDTH / 2 - 105, 
 269                          SCREEN_HEIGHT / 2 - 26); 
 270 } 
 271  
 272 // Main loop, called every frame 
 273 void app::Loop ( void ) 
 274 { 
 275    // Update the sprite position. 
 276    updateSprite(spaceship); 
 277  
 278    // Display the screen. 
 279    agk::Sync(); 
 280 } 
 281  
 282 // Called when the app ends 
 283 void app::End ( void ) 
 284 { 
 285 } 
 286  
 287 // The updateSprite function checks for arrow key 
 288 // presses and moves the argument accordingly. 
 289 void updateSprite(MoveableSprite &sprite) 
 290 { 
 291    // Get the direction as input from the keyboard. 
 292    float directionX = agk::GetDirectionX(); 
 293    float directionY = agk::GetDirectionY(); 
 294  
 295    // Check for left/right arrow keys. 
 296    if (directionX < 0) 
 297    { 
 298       sprite.moveLeft(); 
 299    } 
 300    else if (directionX > 0) 
 301    { 
 302       sprite.moveRight(); 
 303    } 
 304  
 305    // Check for up/down arrow keys. 
 306    if (directionY < 0) 
 307    { 
 308       sprite.moveUp(); 
 309    } 
 310    else if (directionY > 0) 
 311    { 
 312       sprite.moveDown(); 
 313    } 
 314 }  
 Here is a summary of the code: 
 ●  Line 242 is the function prototype for a function named  updateSprite . (The 
function definition appears in lines 289 through 314.)  
 ●  Lines 245 and 246 declare constants for the screen width and height.  
 ●  Line 249 declares a constant for the sprite index.  
 ●  Line 252 declares a constant for the moving distance.  

 
11.3 Inheritance 
545
 ●  Lines 255 and 256 declare an instance of the  MoveableSprite class named 
spaceship. This statement calls the class’s parameterized constructor, passing 
arguments for the sprite index, the image file name, and the moving distance.  
 Here is a summary of the  app::Begin function: 
 ●  Line 262 sets the virtual resolution.  
 ●  Line 265 calls the  spaceship object’s  createSprite member function (inherited 
from the  Sprite class), which creates the sprite on the screen.  
 ●  Lines 268 and 269 set the sprite’s position to the middle of the screen.  
 Here is a summary  of the  app::Loop function: 
 ●  Line 276 calls the  updateSprite function, passing the spaceship object as an argu-
ment. The  updateSprite function definition is shown in lines 289 through 313.  
 ●  Line 279 calls the  agk::Sync function to update the screen.  
 Here is a summary of the  updateSprite function: 
 ●  Line 292 calls the  agk::GetDirectionX function.  Recall from  Chapter   8 that this  
function returns a positive number if the right arrow key is being pressed, a 
negative number if the left arrow key is being pressed, or 0 is neither key is being 
pressed. The value that is returned is assigned to the  directionX variable.  
 ●  Line 293 calls the  agk::GetDirectionY function.  Recall from  Chapter   8 that this  
function returns a positive number if the down arrow key is being pressed, a 
negative number if the up arrow key is being pressed, or 0 is neither key is being 
pressed. The value that is returned is assigned to the  directionY variable.  
 ●  The  if-else statements that appear in lines 296 through 313 determine whether 
one of the arrow keys is being pressed, and if so, call the  spaceship object’s 
appropriate member function.  
 When the program runs, the screen shown in  Figure   11-14  appears. When the user 
presses any of the arrow keys, the spaceship sprite moves accordingly.  
 Figure 11-14  Output of Program 11-6  

546 
Chapter 11  Object-Oriented Programming
 In the Spotlight: 
 An Object-Oriented Game: Balloon Target 
 In this section we will examine an object-oriented game program named Balloon 
Target.  Figure   11-15 shows a screen from the game (this also appears as Figure C-15 
in the book’s color insert). In the game, a balloon moves repeatedly across the screen, 
from the left to the right. Each time the balloon starts at the left side of the screen, its 
speed randomly changes. A dart is positioned at the bottom of the screen. When the 
user presses the spacebar, the dart is launched. The object of the game is to hit the 
balloon as many times as possible with the dart.  
 Figure 11-15  The Balloon Target game  
 Program 11-7 shows the code. In the program, we create instances of the 
 MoveableSprite class to represent the balloon and the dart. The  MoveableSprite class 
is exactly as it was presented in Program 11-6, so we will not show its code again. 
However, we have added two member functions to the  Sprite class:  getSpriteHeight 
and  getSpriteWidth . These member functions return the height and width of the 
sprite, respectively. The following shows the first part of the program, including 
the updated  Sprite class declaration. The declarations for the  getSpriteHeight and 
 getSpriteWidth functions appear in lines 30 and 31. 
 Program 11-7 
  (BalloonTarget, partial listing) 
 1 // Includes, namespace and prototypes 
 2 #include "template.h" 
 3 #include <string>      // Needed for the string class 
 4 using namespace std;   // Needed for the string class 
VideoNote
The Balloon Target 
Game

 
11.3 Inheritance 
547
 5 using namespace AGK; 
 6 app App; 
 7  
 8 class Sprite 
 9 { 
 10 private: 
 11    int spriteIndex;  // The sprite index 
 12    string imageFile; // The name of the image file 
 13 public: 
 14    // Constructors 
 15    Sprite(); 
 16    Sprite(int, string); 
 17  
 18    // Mutators 
 19    void createSprite(); 
 20    void createSprite(int, string); 
 21    void setPosition(float, float); 
 22    void setX(float); 
 23    void setY(float); 
 24  
 25    // Accessors 
 26    int getSpriteIndex() const; 
 27    string getImageFile() const; 
 28    float getX() const; 
 29    float getY() const; 
 30    float getSpriteHeight() const; 
 31    float getSpriteWidth() const; 
 32  
 33    // Destructor 
 34    ~Sprite(); 
 35 };  
 The definitions for the  getSpriteHeight and  getSpriteWidth functions appear in lines 
133 through 143, as shown here. All the other  Sprite class member functions are the 
same as shown earlier in this chapter, so we will not repeat their code here. 
 Program 11-7 
 (BalloonTarget, continued) 
 131 // The getSpriteHeight member function returns 
 132 // the sprite's height. 
 133 float Sprite::getSpriteHeight() const 
 134 { 
 135    return agk::GetSpriteHeight(spriteIndex); 
 136 } 
 137  
 138 // The getSpriteWidth member function returns 
 139 // the sprite's height. 
 140 float Sprite::getSpriteWidth() const 
 141 { 
 142    return agk::GetSpriteWidth(spriteIndex); 
 143 }  

548 
Chapter 11  Object-Oriented Programming
 Next, we will skip to lines 257 through 262, where we have function prototypes for 
the various functions that we have written to modularize the program. 
 Program 11-7 
  (BalloonTarget, continued) 
 257 // Function prototypes 
 258 void restartDart(); 
 259 void restartBalloon(); 
 260 void moveBalloon(); 
 261 void moveDart(); 
 262 void checkForCollision(); 
 263 
 Starting at line 265, we have global constant and variable declarations: 
 Program 11-7 
  (BalloonTarget, continued) 
 264 // Constants for the screen resolution 
 265 const int SCREEN_WIDTH = 640; 
 266 const int SCREEN_HEIGHT = 480; 
 267  
 268 // Constants for sprites and sound 
 269 const int BALLOON_INDEX    = 1;  // Balloon sprite index 
 270 const int DART_INDEX       = 2;  // Dart sprite index 
 271 const int DART_DIST        = 10; // Dart moving distance 
 272 const int MAX_BALLOON_DIST = 14; // Maximum balloon distance 
 273 const int LASER_SOUND      = 1;  // Sound number 
 274  
 275 // Variable to indicate whether the dart has been launched 
 276 bool g_dartLaunched = false; 
 277  
 Lines 265 and 266 declare constants for the screen width and height. Here is a sum-
mary of the other declarations in this section of code: 
 •  BALLOON_INDEX and  DART_INDEX will be used as sprite indices.  
 •  DART_DIST is the dart sprite’s moving distance.  
 •  MAX_BALLOON_DIST is used to calculate the maximum moving distance for the 
balloon sprite. The greater the balloon’s moving distance, the faster it moves 
across the screen.  
 •  LASER_SOUND will be used as a sound number.  
 •  g_dartLaunched is a  bool variable that will indicate the state of the dart sprite. 
When this variable is set to  true , it means the dart has been launched and is 
currently in motion. When it is set to  false , the dart has not been launched.  
 Program 11-7 
 (BalloonTarget, continued) 
 278 // Create MoveableSprite objects for the balloon and dart. 
 279 MoveableSprite balloon(BALLOON_INDEX, 
 280               "BalloonTarget/balloon.png", 0); 

 
11.3 Inheritance 
549
 281  
 282 MoveableSprite dart(DART_INDEX, 
 283               "BalloonTarget/dart.png", DART_DIST); 
 284  
 In lines 279 and 280 we declare a  MoveableSprite  object named  balloon . This object 
will represent the balloon. We pass the  BALLOON_INDEX constant as the sprite index, 
the string  "balloon.png" as the image file name, and 0 as the argument for the mov-
ing distance. At this point, the value that we pass for the balloon’s moving distance is 
unimportant because it will soon be set to a random value. 
 In lines 282 and 283 we create a  MoveableSprite object named  dart . This object will rep-
resent the dart. We pass the  DART_INDEX constant as the sprite index, the string  "dart.png" 
as the image file name, and  DART_DIST as the argument for the moving distance. 
 The  app::Begin function is shown next: 
 Program 11-7 
  (BalloonTarget, continued) 
 285 // Begin app, called once at the start 
 286 void app::Begin( void ) 
 287 { 
 288    // Set the virtual resolution. 
 289    agk::SetVirtualResolution(SCREEN_WIDTH, SCREEN_HEIGHT); 
 290  
 291    // Set the text in the window title bar. 
 292    agk::SetWindowTitle("Balloon Target"); 
 293  
 294    // Load the laser sound. 
 295    agk::LoadSound(LASER_SOUND, "BalloonTarget/laser.wav"); 
 296  
 297    // Create the balloon and dart sprites on the screen. 
 298    balloon.createSprite(); 
 299    dart.createSprite(); 
 300  
 301    // Position the dart and balloon. 
 302    restartDart(); 
 303    restartBalloon(); 
 304 } 
 305  
 Line 289 sets the virtual resolution, and line 292 sets the text for the window’s title 
bar. Line 295 loads the  laser.wav sound file, which will be played when the dart pops 
a balloon. Line 298 calls the balloon object’s  createSprite member function to cre-
ate the balloon sprite on the screen, and line 299 calls the dart object’s  createSprite 
member function to create the dart sprite on the screen. 
 In line 302 we call the  restartDart function, which horizontally centers the dart at 
the bottom of the screen. In line 303 we call the  restartBalloon function, which 
positions the balloon at a random location along the screen’s left edge and sets the 
balloon’s moving distance to a random value. 

550 
Chapter 11  Object-Oriented Programming
 The  app::Loop function is shown next: 
 Program 11-7 
 (BalloonTarget, continued) 
 306 // Main loop, called every frame 
 307 void app::Loop ( void ) 
 308 { 
 309    // Move the balloon. 
 310    moveBalloon(); 
 311  
 312    // Determine whether the spacebar is being pressed. 
 313    if (agk::GetRawKeyState(AGK_KEY_SPACE)) 
 314    { 
 315       g_dartLaunched = true; 
 316    } 
 317  
 318    // If the dart is launched, move it. 
 319    if (g_dartLaunched) 
 320    { 
 321       moveDart(); 
 322    } 
 323  
 324    // Check for collisions. 
 325    checkForCollision(); 
 326     
 327    // Display the screen. 
 328    agk::Sync(); 
 329 } 
 330  
 331 // Called when the app ends 
 332 void app::End ( void ) 
 333 { 
 334 } 
 335  
 Line 310 calls the  moveBalloon function, which moves the balloon toward the screen’s 
right edge. If the balloon is at the edge of the screen, it is restarted. 
 The  if statement in line 313 determines whether the user is pressing the spacebar. 
If so, the  g_dartLaunched variable is set to  true to indicate that the dart has been 
launched. 
 The  if statement in line 319 determines whether the  g_dartLaunched variable is set 
to  true . If so, the  moveDart function is called in line 321, which moves the dart up 
the screen. If the dart is at the top of the screen, it is reset, and  g_dartLaunched is set 
to  false . 
 Line 324 calls the  checkForCollision function, which determines whether the dart 
and the balloon have collided. If so, the laser sound is played, both the balloon and 
the dart are reset, and the  g_dartLaunched variable is set to  false . 
 Line 328 updates the screen. 

 
11.3 Inheritance 
551
 The definition of the  restartBalloon function is shown in lines 338 through 358, 
as follows. 
 Program 11-7 
  (BalloonTarget, continued) 
 336 // The restartBalloon function restarts the balloon along 
 337 // the left edge of the screen, with a random moving distance. 
 338 void restartBalloon() 
 339 { 
 340    // We want to keep the balloon in the top 
 341    // two-thirds of the screen. Calculate the 
 342    // greatest  Y -coordinate for the balloon. 
 343    int maxY = SCREEN_HEIGHT * 0.66; 
 344  
 345    // Get a random value for the  Y -coordinate. 
 346    int y = agk::Random(0, maxY); 
 347  
 348    // Display the balloon at its new location 
 349    // along the left edge of the screen. 
 350    balloon.setPosition( 0, y ); 
 351  
 352    // Generate a random value for the balloon's 
 353    // moving distance. 
 354    int dist = agk::Random(1, MAX_BALLOON_DIST); 
 355  
 356    // Set the balloon's moving distance. 
 357    balloon.setDistance(dist); 
 358 } 
 359  
 When we reposition the balloon, we want it to appear somewhere in the top two-
thirds of the screen. The statement in line 343 calculates the maximum  Y -coordinate 
for the balloon and assigns it to the local variable  maxY . Line 346 gets a random 
number in the range of 0 through  maxY and assigns that value to the local variable 
 y . Line 350 displays the balloon at its new position. (We always want the balloon 
to appear at the left edge of the screen, so 0 is always passed as the  X -coordinate in 
this statement.) 
 Line 354 gets a random value for the balloon’s moving distance. The  MAX_BALLOON_DIST 
constant is set to 14, so this statement will get a random number in the range of 1 
through 14. Line 357 uses this value to set the moving distance. 
 The definition of the  restartDart function is shown in lines 362 through 375, as 
follows. 
 Program 11-7 
 (BalloonTarget, continued) 
 360 // The restartDart function repositions the dart sprite 
 361 // at the bottom center of the screen. 
 362 void restartDart() 

552 
Chapter 11  Object-Oriented Programming
 363 { 
 364    // Calculate the dart's  X -coordinate so it is 
 365    // centered horizontally on the screen. 
 366    int x = ( SCREEN_WIDTH / 2 ) - 
 367          (dart.getSpriteWidth()  / 2); 
 368  
 369    // Set the dart's  Y -coordinate so it is at the 
 370    // bottom of the screen. 
 371    int y = SCREEN_HEIGHT - dart.getSpriteHeight(); 
 372  
 373    // Position the dart at its new location. 
 374    dart.setPosition( x, y ); 
 375 } 
 376  
 We want to display the dart sprite horizontally centered at the bottom of the screen. 
In lines 366 and 367 we calculate the  X -coordinate, and in line 371 we calculate the 
 Y -coordinate. In line 374 we call the  setPosition member function to display the dart 
at these coordinates. 
 The definition of the  moveBalloon function is shown in lines 380 through 390, as 
follows. 
 Program 11-7 
 (BalloonTarget, continued) 
 377 // The moveBalloon function moves the balloon to the 
 378 // right. If it is at the right edge of the screen, 
 379 // it restarts the balloon. 
 380 void moveBalloon() 
 381 { 
 382    if (balloon.getX() < SCREEN_WIDTH) 
 383    { 
 384       balloon.moveRight(); 
 385    } 
 386    else 
 387    { 
 388       restartBalloon(); 
 389    } 
 390 } 
 391  
 The  if statement in line 382 determines whether the balloon sprite is at the right 
edge of the screen. If the balloon sprite has not reached the screen’s right edge, 
line 384 calls the  balloon object’s  moveRight member function. Otherwise, line 
388 calls the  restartBalloon function to restart the balloon sprite at the left side 
of the screen. 
 The definition of the  moveDart function is shown in lines 397 through 415, as 
follows. 

 
11.3 Inheritance 
553
 Program 11-7 
 (BalloonTarget, continued) 
 392 // The moveDart function updates the dart's position. 
 393 // If the dart has been launched, it is moved up. 
 394 // If the dart has reached the top of the screen, 
 395 // it is restarted, and the dartLaunched flag is 
 396 // set to false. 
 397 void moveDart() 
 398 { 
 399     // If the dart has been launched, move it up. 
 400     if (g_dartLaunched) 
 401     { 
 402         dart.moveUp(); 
 403     } 
 404  
 405     // If the dart has reached the top of the screen, 
 406     // restart it. 
 407     if ( dart.getY() < 0 ) 
 408     { 
 409         // Restart the dart. 
 410         restartDart(); 
 411  
 412         // Reset the dartLaunched flag. 
 413         g_dartLaunched = false; 
 414     } 
 415 } 
 416 
 The  if statement in line 400 tests the  g_dartLaunched variable. If it is  true , then 
the dart has been launched, so line 402 moves the dart up. The  if statement in line 
407 determines whether the dart has reached the top of the screen. If it has, line 
410 calls  restartDart to reposition the dart, and line 413 sets the  g_dartLaunched 
variable to  false . 
 The definition of the  checkForCollision function is shown in lines 421 through 439, 
as follows. 
 Program 11-7 
 (BalloonTarget, continued) 
 418 // The checkForCollision function determines whether 
 419 // the dart and the balloon have collided. If so, a 
 420 // laser sound is played, and the objects are reset. 
 421 void checkForCollision() 
 422 { 
 423    // Determine whether the dart and the balloon 
 424    // have collided. 
 425    if ( agk::GetSpriteCollision( dart.getSpriteIndex(), 
 426                       balloon.getSpriteIndex() ) ) 
 427    { 
 428       // Play the laser sound. 
 429       agk::PlaySound(LASER_SOUND); 

554 
Chapter 11  Object-Oriented Programming
 430  
 431       // Restart the balloon. 
 432       restartBalloon(); 
 433  
 434       // Restart the dart. 
 435       restartDart(); 
 436  
 437       // Reset the g_dartLaunched flag. 
 438       g_dartLaunched = false; 
 439    } 
 440 }  
 The  if statement that begins in line 425 determines whether the dart and the balloon 
sprites have collided. If the sprites have collided, line 429 plays the laser sound. Line 
432 calls  restartBalloon to restart the balloon at the left side of the screen, and 
line 435 calls the  restartDart function to restart the dart at the bottom of the screen. 
Line 438 sets  g_dartLaunched to  false . 
 Checkpoint 
 11.15.  In this section we discussed base classes and derived classes. Which is the gen-
eral class, and which is the specialized class?  
 11.16.  What does it mean to say there is an is-a relationship between two objects?  
 11.17.  What does a derived class inherit from its base class?  
 11.18.  Look at the following code, which is the first line of a class declaration. What 
is the name of the base class? What is the name of the derived class? 
 class Canary : public Bird  
 11.19.  Can a derived class have a member function with the same name as base class 
member function?  
 Review Questions 
 Multiple Choice  
 
1.  This programming practice is centered on creating functions that are separate 
from the data that they work on:  
 a.  modular programming.  
 b.  procedural programming.  
 c.  functional programming.  
 d.  object-oriented programming.  

 
Review Questions 
555
 
2.   This programming practice is centered on creating objects:  
 a.  object-centric programming.  
 b.  objective programming.  
 c.  procedural programming.  
 d.  object-oriented programming.  
 
3.   This is a member of a class that holds data:  
 a.  method, or member function.  
 b.  instance.  
 c.  field, or member variable.  
 d.  constructor.  
 
4.   A class’s member variables are commonly declared in this section of a class.  
 a.  Private  
 b.  Public 
 c.  Read Only  
 d.  Hidden 
 
5.  This is a member function that gets a value from a class’s member variable but 
does not change it:  
 a.  retriever.  
 b.  constructor.  
 c.  mutator.  
 d.   accessor.  
 
6.  This is a member function that stores a value in a member variable or changes the 
value of a member variable in some other way:  
 a.  modifier.  
 b.  constructor.  
 c.  mutator. 
 d.   accessor.   
 
7.   This is a member function that is automatically called when an object is 
created:  
 a.  accessor.  
 b.   constructor.  
 c.  setter.  
 d.  mutator.  
 
8.  In an inheritance relationship, this is the general class:  
 a.  derived class.  
 b.   base class.  
 c.  slave class.  
 d.  child class.  
 
9.   In an inheritance relationship, this is the specialized class:  
 a.  base class.  
 b.  master class.  
 c.   derived class.  
 d.  parent class.  

556 
Chapter 11  Object-Oriented Programming
 
10.  If a derived class constructor does not explicitly call a base class constructor, this 
base class constructor will be automatically called.  
 a.  Default constructor  
 b.  The first parameterized constructor  
 c.  None. Nothing will happen.  
 d.  None. An error will occur.  
 True or False  
 
1.  The base class inherits member variables and member functions from the 
derived class.  
 
2.  The practice of procedural programming is centered on the creation of objects.  
 
3.  Object reusability has been a factor in the increased use of object-oriented pro-
gramming. 
 
4.  It is a common practice in object-oriented programming to make all of a class’s 
member variables public.  
 
5.  If a derived class constructor does not explicitly call a base class constructor, none 
of the base class’s constructors will be called.  
 Short Answer  
 
1.   What is encapsulation?  
 
2.   Why is an object’s internal data usually hidden from outside code?  
 
3.   What is the difference between a class and an instance of a class?  
 
4.   The following statement calls an object’s member function. What is the name of 
the member function? What is the name of the object? 
 wallet.getDollar();  
 
5.  What is a destructor?  
 
6.  What is a constructor?  
 
7.  What is an is-a relationship between classes?  
 
8.   What does a derived class inherit from its base class?  
 
9.   Look at the following class header. What is the name of the base class? What is 
the name of the derived class? 
 class Tiger : public Felis  
 
10.  Which executes first, the derived class constructor or the base class constructor?  
 Algorithm Workbench  
 
1.  Suppose  myCar is the name of an object, and  go is the name of a member function. 
(The  go function does not take any arguments.) Write a statement that uses the 
 myCar object to call the member function.  

 
Programming Exercises 
557
 
2.   Look at the following partial class definition, and then respond to the questions 
that follow it: 
 class Point 
 { 
 private: 
   int x; 
   in y; 
    
   };  
 a.  Write a constructor for this class. The constructor should accept an argument 
for each of the member variables.  
 b.  Write accessor and mutator member functions for each member variable.  
 
3.  Write the class header for a  Poodle class. The class should be derived from the 
 Dog class.  
 Programming Exercises 
 
1.   Coin Class 
 Write a program with a class named  Coin that can simulate the tossing of a coin. 
When an object of the class is created, it should display the image of a coin that 
is faceup. The class should have a member function named  toss that randomly 
determines whether the coin is faceup or facedown and displays the appropriate 
coin image. (You can create your own coin images or use the ones provided in the 
book’s online resources, downloadable from   www.pearsonhighered.com/gaddis  .) 
 In the program, create a  Coin  object. Each time the user presses the spacebar, 
the program should simulate the tossing of the coin.  
 
2.   Dice Simulator 
 Write a program with a class named  Die that can simulate the rolling of a die. 
The class should have a member function named  toss that randomly determines 
which side of the die is facing up (a value in the range of 1 through 6). When 
the  toss member function is called, it should display an image of die side that is 
facing up. (You can create your own die images or use the ones provided in  the 
book’s  online resources, downloadable from   www.pearsonhighered.com/gaddis  .) 
 In the program, create two  Die objects to simulate a pair of dice. Each time 
the user presses the spacebar, the program should simulate the rolling of the dice.  
 
3.   PointKeeper Class 
 Modify the Balloon Target game so it reports the number of points earned by the 
user. (Each balloon that is popped earns 1 point.) To keep track of the points, 
you will write a  PointKeeper class that has one member variable named  points . 
This member variable will hold the number of points earned by the user. The 
class will also have a constructor and the appropriate mutator and accessor 
functions. 
 In the Balloon Target game, create an instance of the  PointKeeper class. 
Each time the user pops a balloon, the program should update the  PointKeeper 
object. At the end of the game, the program should report the number of points 
earned.  
VideoNote
Solving the Coin 
Class Problem

558 
Chapter 11  Object-Oriented Programming
 
4.  Floating Asteroids,  Part   1 
 Write a program that creates an array of at least five  MoveableSprite objects. 
Each of the objects in the array should display an image of an asteroid. (You can 
create your own image, or use the one provided in  the book’s  online resources at 
  www.pearsonhighered.com/gaddis  .) 
 As the program runs, the asteroids should slowly move across the screen, from 
right to left. When each asteroid reaches screen’s the left edge, it should be repo-
sitioned at a random location along the screen’s right edge.  
 
5.   Floating Asteroids,  Part  2 
 Modify the program that you wrote for Programming Exercise 4 to include a 
spaceship that the user can control with the arrow keys. As the program runs, the 
user should maneuver the spaceship to avoid colliding with any of the floating 
asteroids. If the spaceship collides with an asteroid, play an appropriate sound 
and then regenerate the spaceship at a random location. In the program, create a 
 MoveableSprite object to represent the spaceship.  
 
6.   Object-Oriented Catch the Boulder Game 
 In  Chapter   9 , Programming Exercise 3 asks you to design  and create a game 
named Catch the Boulder. The object of the game is to catch falling boulders in 
a cart that can be moved back and forth on a railroad track. Create an object-
oriented version of the game. The program should create objects to represent the 
boulders and the cart.  

559
 Downloading and Installing 
the Required Software 
 APPENDIX 
A 
 To use this text you will need the following software and files: 
 ●  Microsoft Visual C++ 2010  
 ●  The AGK (App Game Kit)  
 ●  Sample Source Code, Media Files, and Game Case Studies  
 This appendix serves as a guide for installing these items.  
 NOTE:   To see a video demonstrating the software installation, go to the  book’s  
companion Web site at   www.pearsonhighered.com/gaddis  . 
 Step 1:  Install Microsoft Visual C++ 2010 .  When purchased new, this book includes 
Visual Studio 2010 Express Edition on a DVD. This DVD provides a suite 
of software development tools. You will need to insert the DVD and install 
Visual C++ 2010 Express Edition.  
 The setup program is very simple. Follow the instructions in the next few 
screens, and in a few minutes Visual C++ 2010 Express Edition will be 
installed on your system. You can now continue to Step 2, Download and 
Install the AGK.  
 If You Do Not Have the Microsoft DVD  
 If your book does not have the Visual Studio 2010 Express Edition DVD, 
you can download   and install Visual C++ 2010 Express Edition from the 
following Microsoft Web site: 
 www.microsoft.com/express/download  
VideoNote
Installing the 
required 
software

560 
Appendix A  Downloading and Installing the Required Software
 Scroll down the Web page until you see the download area for Visual C++ 
2010 Express Edition, as shown in  Figure   A-1 . Click the download link.  
 Figure A-1  Visual Studio 2010 Express Edition download page  
 Next you should see a  File Download dialog box. Depending on the 
browser you are using, it will be similar to that shown in  Figure   A-2  . 
 Figure A-2  File Download dialog box  
 Click  Run . At this point you will probably see another dialog asking 
for permission to run the program. Click  Continue in that dialog box. 
Some files will be downloaded to your system, and then the installation 
will begin. 
 The installation is very simple. Follow the instructions in the next few 
screens. The time required to install the software will depend on the speed 
of your Internet connection. Once the installation is complete, you can pro-
ceed to Step 2, Download and Install the AGK.  

 
Appendix A  Downloading and Installing the Required Software 
561
 Step 2:  Download and Install the AGK . To download and install the AGK trial 
directly from The Game Creators Web site, go to the following address: 
 http://files.thegamecreators.com/agk/AppGameKitTrial.zip  
 Next you should see the AGK trial  File Download dialog box, as shown 
in  Figure   A-3 . 
 Click  Open . The download process will begin. This may take some time, 
depending on the speed of your Internet connection. When the download is 
complete, a window will appear containing the  AppGameKitTrial.exe file. 
 Run the file. If you are prompted for permission to continue, click  Yes . 
 When the setup program executes, you will see the screen shown in  Fig-
ure  A-4 . Click the  Next button to continue with the setup. On the next 
screen you will choose the location where the AGK trial will be installed. 
Because of the way C++ programs are developed with the AGK, we advise 
that you do not install the AGK in its default location. Instead, you will 
install it under  My Documents , in a folder named  AGK . Click the  Browse 
button, as shown in  Figure   A-5  . 
 Figure A-3  AGK trial download dialog box  
 Figure A-4  AGK trial setup  

562 
Appendix A  Downloading and Installing the Required Software
 The  Browse For Folder dialog appears as shown in  Figure  A-6  . Select  My 
Documents . Click the  Make New Folder button. Name the new folder 
 AGK . When you have finished naming the folder, click  OK . 
 Figure A-5  Choose Install Location dialog  
 Figure A-6  Browse for Folder Dialog  
 The installation program returns to the previous window, as illustrated 
in  Figure  A-7 . Notice that the installation path has changed. Click the 
 Install button to begin installing the AGK trial in the specified location.  
 The installation will take a few minutes. When it is finished, you will 
see a screen similar to the one in  Figure   A-8  . Uncheck the  Launch AGK 
Trial checkbox and click  Finish . The AGK trial has now been installed on 
your system.  

 
Appendix A  Downloading and Installing the Required Software 
563
 Step 3:  Download the Sample Source Code, Media Files, and Game Case Studies . 
The last step is to download the sample source code for the examples 
 shown in the book , sample media files, and game case studies. Go to   www.
pearsonhighered.com/gaddis  , and click the image of  this book’s cover. 
This will take you to the book’s online resource page, where you can 
download the supplementary files. 
 After downloading and installing the required software and files, you are 
ready to begin working  through this book . 
 Figure A-7  Destination Path for AGK Installation  
 Figure A-8  AGK Trial Installation Complete  

This page intentionally left blank 

 Symbols 
 /* (forward slash + asterisk),  59  
 || (OR) operator 
 Boolean expressions,  113 – 114  
 defined,  112 
 short-circuit evaluation,  114  
 + operator,  78 
 ++ (increment) operator,  141 – 142  
 == (equal to) operator 
 array comparison and,  221  
 assignment operator (=) versus,  93  
 defined,  93 
 use of,  94 ,  123 
 ! (NOT) operator 
 Boolean expressions,  114  
 defined,  112 
 != (not equal to) operator,  92 ,  93 ,  95  
 # symbol,  45 
 % operator,  194 ,  203  
 && (AND) operator 
 Boolean expressions,  113  
 defined,  112 
 precedence,  115 
 short-circuit evaluation,  114  
 truth table,  113 
 < (less than) operator,  92 ,  94  
 << (stream insertion) operator,  40 ,  41  
 <= (less than or equal to) operator, 
 92 – 93 
 > (greater than) operator,  92 ,  94  
 >= (greater than or equal to) operator, 
 92 – 93 
 A 
 acceleration,  394 
 accessor functions,  513 
 accumulators,  152 
 acos function,  75 
 active/inactive setting, virtual joystick,  331  
 AGK programs.  See also App Game 
Kit (AGK) 
 arrays in,  459 – 478 
 automatic looping,  257  
 bitmap images,  264 
 creating,  257 – 260 
 files,  441 
 function execution,  256 – 257  
 main function,  255 
 string object declaration in, 
 301 – 303 
 template, copying and opening in 
Visual Studio,  257 – 260  
 agk::GetSpriteColorGreen 
function,  297  
 agk::GetSpriteColorRed function,  297 
 agk::GetSpriteExists function,  282  
 agk::GetSpriteHeight function,  274  
 agk::GetSpriteHit function,  320  
 agk::GetSpriteWidth function,  274  
 agk::GetSpriteX function,  274  
 agk::GetSpriteY function,  274  
 agk::GetTextExists function,  368  
 agk::GetTextHitTest function,  381  
 agk::GetTextSize function,  369  
 agk::GetTextTotalHeight 
function,  380  
 agk::GetTextTotalWidth 
function,  380  
 agk::GetTextX function,  369  
 agk::GetTextY function,  370  
 agk::GetVirtualButtonReleased 
function,  326  
 agk::GetVirtualButtonState 
function,  326  
 agk::GetVirtualJoystickImageExists 
function,  332  
 agk::GetVirtualJoystickX function, 
 333 ,  335  
 agk::GetVirtualJoystickY function, 
 333 ,  335  
 agk::LoadImage function 
 arguments passed to,  278 – 279  
 defined,  278  
 format,  278  
 virtual joystick images,  331  
 agk::LoadMusic function,  352  
 agk::LoadSound function,  348  
 agk::OpenToRead function,  442  
 agk::OpenToWrite function,  440  
 agk::PlayMusic function,  352  
 agk::PlaySprite  function,  346  
 agk::Print function 
 defined,  298  
 formats,  298  
 program use example,  298 – 299  
 agk::PrintC function 
 defined,  299  
 formats,  299 – 300  
 program use example,  300 – 301  
 agk::Random function 
 defined,  303 ,  304  
 example use of,  304 – 305  
 format,  304  
 uses for,  304  
 AGK window 
 text display in,  298 – 303  
 title display in,  303  
 agk::AddVirtualButton function,  323  
 agk::AddVirtualJoystick function, 
 329 ,  335 
 agk::ClearScreen function,  295  
 agk::CloneSprite function,  277  
 agk::CloseFile function,  442 ,  444  
 agk::CreateSprite function,  264 , 
 278 – 279 ,  517  
 agk::CreateText function,  367 – 368  
 agk::DeleteSprite function,  282  
 agk::DeleteText function,  368  
 agk::DeleteVirtualJoystick 
function,  332  
 agk::FileEOF ,  451  
 agk::FileIsOpen function,  444  
 agk::GetDirectionX function,  338 ,  491 
 agk::GetDirectionY function,  338 ,  491 
 agk::GetFileExists function,  443  
 agk::GetRawKeyPressed function, 
 338 ,  339 
 agk::GetRawLastKey function,  339 ,  340 
 agk::GetRawMouseLeftPressed 
function 
 with  agk::GetSpriteHit 
function,  320  
 defined,  317  
 in determining button releases,  319  
 program use example,  317 – 318 , 
 320 – 322 
 agk::GetRawMouseLeftState 
function,  319  
 agk::GetRawMouseRightPressed 
function 
 with  agk::GetSpriteHit 
function,  320  
 defined,  317  
 in determining button releases,  319  
 program use example,  317 – 318 , 
 320 – 322 
 agk::GetRawMouseRightState 
function,  319  
 agk::GetRawMouseX function,  317  
 agk::GetRawMouseY function,  317  
 agk::GetSpriteAngle function,  275  
 agk::GetSpriteAngleRad function,  276 
 agk::GetSpriteCollision 
function,  385  
 agk::GetSpriteColorBlue 
function,  297  
 Index 
565

566 
Index
 app::Loop function 
 defined,  256  
 functioning of,  286 ,  289  
 game loop,  286 ,  288  
 game state determination,  290 – 294  
 game states,  293 – 294  
 as loop,  285  
 multiple objects,  525  
 program use example,  285 – 289  
 repeat,  257  
 sync rate,  289 – 290  
 working in,  284 – 294  
 arguments 
 defined,  74 ,  176  
 multiple, passing,  180 – 181  
 passing,  176 – 184  
 passing arrays as,  228 – 230  
 passing objects as,  535 – 537  
 arrays 
 in AGK programs,  459 – 478  
 as alternative to groups of 
variables,  206  
 bounds checking and,  213  
 comparing,  221 – 223  
 contents, processing,  220 – 237  
 copying,  220 – 221  
 as deck of cards,  459 – 465  
 defined,  205 ,  206  
 elements,  207 – 208 ,  213  
 in games,  459  
 initialization,  209 – 210  
 inputting contents,  208 – 209  
 loops for stepping through,  210 – 212  
 of multiple dimensions,  246  
 object, creating,  532 – 535  
 off-by-one errors,  213  
 one-dimensional,  239  
 outputting contents,  208 – 209  
 parallel,  237 – 239  
 partially filled,  230 – 233  
 passing as arguments to functions, 
 228 – 230  
 processing example,  233 – 236  
 sequential search algorithms,  216 – 220  
 shuffling,  465 – 470  
 size declarators,  206 ,  215  
 sorting,  471 – 478  
 string,  219 – 220  
 subscripts,  207 ,  237  
 two-dimensional,  239 – 245  
 use of,  205 – 206  
 values,  206  
 values, averaging,  223 – 224  
 values, finding highest/lowest,  224 – 228  
 values, totaling,  223  
 arrow keys, keyboard,  336 – 338  
 ASCII (American Standard Code for 
Information Interchange) 
 character set,  9 – 10 
 defined,  9  
 asin function,  75 
 assembly language 
 defined,  14 
 as low-level language,  15 
 programs,  14 
 assignment 
 double variables and,  53 
 int variables and,  52 – 53 
 agk::SetVirtualJoystickImageInner  
function,  331 – 332  
 agk::SetVirtualJoystickImageOuter 
function,  331 – 332  
 agk::SetVirtualJoystickPosition 
function,  330  
 agk::SetVirtualJoystickSize 
function,  330  
 agk::SetVirtualJoystickVisible 
function,  331  
 agk::SetVirtualResolution 
function,  262  
 agk::SetWindowTitle function,  303  
 agk::StopSprite  function,  347  
 agk::Str function,  455  
 agk::Sync function,  265 ,  267 ,  358 ,  522  
 agk::Timer function,  354  
 agk::WriteFloat function,  441  
 agk::WriteInteger function,  441  
 agk::WriteLine function,  442 ,  456  
 agk::WriteString function,  441 – 442 , 
 455 – 456 
 alignment 
 if-else-if statement,  111  
 nested decision structures,  106  
 text objects,  373 – 377  
 American Standard Code for 
Information Interchange.  See ASCII  
 AND (&&) operator 
 Boolean expressions,  113  
 defined,  112  
 precedence,  115  
 short-circuit evaluation,  114  
 truth table,  113  
 animation 
 cel,  340 – 344  
 creating,  340 – 348  
 resuming,  347  
 sprite, playing,  345 – 347  
 stopping,  347  
 with texture atlases,  344 – 345  
 App Game Kit (AGK) 
 animation,  340 – 348  
 backbuffer,  265  
 defined,  20 ,  253  
 download path for installation,  563  
 downloading,  561  
 installing,  561 – 562  
 key codes,  338 
 keyboard,  336 – 340  
 levels,  253 – 254  
 mouse functions,  315 – 322  
 music and sound,  348 – 353  
 online documentation,  260  
 RGB color system,  294  
 screen coordinate system,  260 – 263  
 trial,  20  
 trial setup,  561  
 using with C++,  253 – 308  
 virtual buttons,  322 – 328  
 virtual joysticks,  329 – 336  
 app::Begin function 
 calling functions to,  263  
 defined,  256  
 game loop,  286 ,  288  
 game states,  293  
 app::End function,  256  
 appending data,  440 – 441  
 agk::ReadFloat function,  443 – 444  
 agk::ReadInteger function,  443  
 agk::ReadLine function,  444  
 agk::ResetTimer function,  354  
 agk::ResumeSprite  function,  347  
 agk::SetClearColor function,  295  
 agk::SetRawMouseVisible function,  317  
 agk::SetSpriteAngle function,  275  
 agk::SetSpriteAngleRad function,  276  
 agk::SetSpriteAnimation function, 
 345 – 346 
 agk::SetSpriteColor function,  297  
 agk::SetSpriteColorAlpha function, 
 296 ,  297 
 agk::SetSpriteColorBlue function, 
 295 – 296 
 agk::SetSpriteColorGreen function, 
 295 – 296 
 agk::SetSpriteColorRed function, 
 295 – 296 
 agk::SetSpriteDepth function,  270  
 agk::SetSpriteFlip function,  276  
 agk::SetSpritePosition function 
 defined,  271 
 format,  271 – 272 
 program use example,  272 – 273  
 X-/Y-coordinates and,  272  
 agk::SetSpriteScale function 
 calling,  274 – 275 
 defined,  274 
 format,  274 
 scale direction,  275 
 agk::SetSpriteVisible function,  276  
 agk::SetSpriteX function,  273  
 agk::SetSpriteY function,  273  
 agk::SetSyncRate function,  289  
 agk::SetTextAlignment function,  373  
 agk::SetTextColor function,  380  
 agk::SetTextPosition function,  369  
 agk::SetTextSize function,  368  
 agk::SetTextSpacing function,  377  
 agk::SetTextString function,  379  
 agk::SetTextVisible function,  380  
 agk::SetTextX function,  369  
 agk::SetTextY function,  370  
 agk::SetVirtualButtonActive 
function,  325 
 agk::SetVirtualButtonAlpha 
function,  324 – 325 
 agk::SetVirtualButtonColor 
function,  324 
 agk::SetVirtualButtonDown 
function,  326 
 agk::SetVirtualButtonPosition 
function,  323 – 324 
 agk::SetVirtualButtonSize 
function,  324 
 agk::SetVirtualButtonText 
function,  324 
 agk::SetVirtualButtonUp function,  325  
 agk::SetVirtualButtonVisible 
function,  325 
 agk::SetVirtualJoystickActive 
function,  331 
 agk::SetVirtualJoystickAlpha 
function,  330 
 agk::SetVirtualJoystickDeadZone 
function,  332 – 333 

 
Index 
567
 characters 
 ASCII set,  9 – 10 
 literals,  79 
 storing,  9 – 10 
 cin statement,  55 – 57 ,  77 
 class declarations 
 defined,  512  
 elements of,  512  
 format,  512  
 sprite class,  514  
 class headers 
 defined,  512  
 for derived classes,  540  
 inheritance notation in,  540  
 classes 
 base,  538  
 as “blueprint,”  510  
 cookie cutter metaphor,  511  
 defined,  510  
 derived,  538  
 inheritance,  537 – 554  
 multiple object creation from, 
 522 – 525  
 naming,  512  
 objects versus,  510 – 511  
 cloning, sprites,  276 – 277  
 code 
 blank lines,  60 
 defined,  18 
 reuse,  169  
 collision detection 
 sprites,  384 – 394  
 text objects,  381 – 384  
 tile maps,  492 – 501  
 color channels,  295  
 colors 
 applying to sprites,  295 – 297  
 background,  295  
 RGB color system,  294 – 295  
 sprite values, getting,  297  
 text object,  380  
 virtual buttons,  324  
 working with,  294 – 297  
 combined assignment operators,  66 
 comments 
 defined,  58 
 multiline,  59 
 single-line,  58 – 59 
 types of,  58 
 comparing arrays.  See also arrays 
 == (equal to) operator and,  221  
 process,  221 – 223  
 program example,  221 – 223  
 comparing strings.  See also strings 
 with == operator,  123  
 program example,  123 – 124  
 uses of,  122  
 compilers,  17 – 18 
 computers 
 data storage,  6 – 11 
 hardware,  2 – 6 
 introduction to,  1 – 11 
 concatenation,  78 
 condition-controlled loops,  132 – 141  
 console output 
 defined,  39 
 displaying total sales,  40 
 consoles,  39 
 closingScreen function,  361  
 code,  355 – 361 
 defined,  353 – 354  
 displayIntro function,  359  
 g_gameState variable,  358  
 game states,  356  
 generateNewBug function,  359  
 lady bug animation,  356  
 playGame function,  360 ,  361  
 runtime,  354 
 screen size constants,  356  
 screens,  354  
 sprite indices,  356  
 switch statement,  358  
 timer reset,  354  
 timer value,  354  
 zapped bug counter,  356  
 Bug Zapper game (version 2) 
 app::Loop function,  445  
 closing screen,  451  
 code,  446 – 451 
 defined,  445 
 newHighScore function,  445 – 446  
 bytes 
 defined,  6 
 illustrated,  6 
 for large numbers,  9 
 C 
 c_str member function 
 defined,  301  
 format,  301 
 program use example,  301 – 303  
 C++ programming language 
 App Game Kit (AGK) with,  253 – 308  
 array bounds checking and,  213  
 as case sensitive,  38 
 core language,  20 
 creation of,  15 ,  20 
 defined,  19  
 key words,  16 
 overview,  19 – 20 
 standard library,  20 
 calculations 
 average,  69 – 71 
 discount,  68 – 69 
 percentage,  68 – 69 
 performing,  60 – 71 
 running total,  152 – 154  
 calling functions 
 control of program and,  172  
 defined,  170  
 illustrated,  171  
 program example,  171 – 172  
 string class,  197  
 value-returning,  191 – 192  
 camelCase,  48 
 Cartesian coordinate system,  262  
 case sections,  118  
 case statement,  118  
 ceil function,  75 
 cel animation.  See also animations 
 creating,  341  
 defined,  340 
 images,  341 
 program example,  341 – 344  
 central processing units.  See CPUs  
 char data type,  48 ,  79 
 assignment operators 
 combined,  66 
 defined,  49 
 equal to (==) versus,  93  
 types of,  66 
 assignment statements,  49  
 atan function,  75 
 audio files.  See music files; sound files  
 averages 
 array values,  223 – 224  
 calculating,  69 – 71 
 B 
 backbuffer,  265 
 backgrounds 
 sprites as,  267 – 268 
 transparent, in sprites,  277 – 281  
 backslash (\),  43 
 Balloon Target game 
 app::Begin function,  549  
 app::Loop function,  550  
 checkForCollision function,  550 , 
 553 – 554 
 code,  546 – 554 
 defined,  546 
 getSpriteHeight function,  546 – 547  
 getSpriteWidth function,  546 – 547  
 global constants,  548 
 global variables,  548 
 illustrated,  546 
 moveBalloon function,  550 ,  552  
 moveDart function,  550 ,  552 – 553  
 restartBalloon function,  549 ,  551 , 
 552 ,  554 
 restartDart function,  550 – 551 ,  554  
 X-coordinate/Y-coordinate,  552  
 base classes,  538 
 binary numbering system,  7 
 binding,  527 
 bitmap images 
 defined,  264 
 save formats,  264 
 sprite creation from,  267  
 bits (binary digits) 
 defined,  6 
 pattern illustrations,  7 ,  8 
 blank lines,  60 
 bool data type,  48 
 bool functions 
 defined,  194 
 example use of,  195 
 bool variables 
 declaration,  122 
 defined,  121 ,  122  
 as flags,  122  
 Boolean expressions 
 AND (&&) operator,  113  
 compound,  115 
 defined,  90 
 with logical operators,  112  
 NOT (!) operator,  114  
 OR (||) operator,  113 
 relational operators and,  92 – 93  
 testing,  91 
 while loop,  133 
 bounding boxes, sprite,  384  
 break statement,  118 
 Bug Zapper game 

568 
Index
 E 
 elements.  See also arrays 
 assigning values to,  207 – 208  
 comparing,  221 – 222  
 defined,  207  
 processing,  213  
 two-dimensional array, accessing, 
 241 – 245  
 using in math expression,  214 – 215  
 encapsulation,  508  
 end of file 
 agk::FileEOF ,  451  
 code,  452 – 455  
 detecting,  451 – 455  
 endl manipulator,  42 – 43 
 ENIAC computer,  3 
 escape sequences 
 backslash (\),  43 
 common,  44 
 defined,  43 
 newline,  43 – 46 
 using,  44 – 45 
 executing programs,  27 ,  30 
 existence determination 
 text objects,  368  
 Virtual Joystick,  332  
 exp function,  75 
 expressions 
 Boolean,  90 – 93 
 cast type,  67 
 math,  61 
 mixed-type,  66 – 68 
 F 
 falling objects simulation 
 acceleration,  394  
 defined,  394  
 distance,  395 – 396  
 global variables,  399  
 gravity,  394  
 motion approximation,  397  
 program design,  394  
 program example,  397 – 400  
 speed,  395  
 in two directions,  400 – 403  
 fetch-decode-execute cycle,  13 
 fields,  508 ,  509 .  See also member variables  
 file names 
 extensions,  439 – 440  
 illustrated,  439  
 operating system rules,  439  
 file numbers,  440  
 files.  See also input files; output files 
 AGK program,  441  
 appending data to,  440 – 441  
 closing,  439  
 defined,  437  
 end detection,  451 – 455  
 header,  38 ,  45 ,  46 
 log,  455 – 458  
 open determination,  444  
 opening,  438  
 processing,  439  
 programs using,  437 – 438  
 reading data from,  439  
 types of,  437 – 438  
 writing data to,  438  
 long ,  48  
 parameter,  181  
 short ,  48  
 string ,  48 
 types of,  48 
 dead zone.  See also virtual joysticks 
 defined,  332  
 setting,  332 – 333  
 debugging 
 global variables and,  185  
 nested decision structures,  106  
 decision structures 
 defined,  88  
 dual-alternative,  97 – 101  
 example,  94 ,  95 
 with  if statement,  89 – 97 
 illustrated,  90 ,  91 
 multiple alternative,  116 – 121  
 nested,  101 – 112  
 single alternative,  90 – 97 
 deck of cards program 
 code,  460 – 463 
 createCardSprites function,  465  
 defined,  459  
 g_cardSprites array,  465  
 global constants,  463 – 464  
 initial screen,  460  
 screen after cards dealt,  460  
 decrement (––) operator,  141 – 142  
 default constructors 
 defined,  526 ,  527  
 sprite class,  528  
 default sections,  118  
 deleting sprites,  282  
 derived classes.  See also classes 
 class header,  540  
 defined,  538  
 destructors,  513  
 digital data,  10 
 digital devices,  10 
 discounts, calculating,  68 – 69 
 disk drives,  4 – 5 
 distance, falling object simulation, 
 395 – 396 
 divide and conquer approach,  168  
 division 
 integer,  63 – 64 
 remainder (modulus) operator,  64 – 65 
 truncation,  64 
 dot notation,  521 
 double data type,  48 ,  49 
 double literals,  52 
 double  variables,  53 
 doubleNumber function,  178  
 do-while loops.  See also loops 
 defined,  140 
 flowchart,  140 
 logic of,  140 
 as posttest loop,  141  
 downloading 
 AGK trial,  561  
 sample source code,  563  
 Visual C++ 2010 Express Edition,  560  
 dual-alternative decision structures 
 defined,  97 
 illustrated,  98 
 writing as  if-else statement,  98 – 101  
 constructors 
 default,  526 ,  527 
 defined,  513 
 function header,  516 
 overloaded,  525 – 532 
 parameterized,  526 
 control structures 
 decision,  88 ,  89 – 97 
 defined,  87 
 repetition,  88 – 89 ,  131 – 160  
 sequence,  87 – 88 
 cookie cutter metaphor,  511  
 copying arrays,  220 – 221  
 core language,  20 
 cos function,  75 
 count-controlled loops.  See also loops 
 counter variable declaration,  146 – 147  
 counter variable use,  147  
 defined,  143 
 flowchart,  144 
 increment,  143 
 initialization,  143 
 logic,  144 
 for loop,  143 – 152 
 program use example,  149 – 150  
 test,  143 
 user control,  151 – 152  
 user iteration control,  151 – 152  
 writing,  149 – 150 
 counter variables 
 declaring in initialization expression, 
 146 – 147 
 initialization,  232 – 233  
 setup methods,  146 
 using in body of loop,  147 – 149  
 cout statement,  41 ,  76 
 CPUs (central processing units) 
 as computer’s brain,  11  
 defined,  3 
 history of,  3  
 manufacture of,  12 
 as microprocessors,  3 
 operations,  11 – 12 
 program instruction execution,  13  
 curly braces 
 class declaration,  512 
 in conditionally executed statement,  91 
 function body,  170 
 purpose of,  38 
 two-dimensional arrays,  243  
 D 
 data hiding,  508 
 data storage 
 additional data,  10 – 11  
 characters,  9 – 10 
 negative integers,  10 
 numbers,  7 – 9 
 overview,  6 – 7 
 real numbers,  10 
 data types 
 bool ,  48 
 char ,  48 ,  79 
 defined,  47 
 double ,  48 ,  49 
 float ,  48 ,  49 ,  54 ,  272 
 int ,  48 ,  49 

 
Index 
569
 header files 
 contents,  46 
 defined,  38 ,  45 
 height, text objects,  380  
 high-level languages,  14 – 16 
 human languages,  19 
 I 
 if statement 
 decision structure,  90 
 defined,  89 
 format,  90 
 one conditionally executed statement,  91 
 using,  95 – 97 
 writing decision structures with,  89 – 97 
 if-else statement 
 conditionally executed statements,  98 
 curly braces,  99 
 defined,  97 
 illustrated,  99 
 parts of,  98 
 using,  100 – 101  
 if-else-if statement 
 alignment,  111  
 defined,  109  
 format,  109 – 110  
 indentation,  111  
 nested decision structures and,  101 – 112 
 program use example,  110 – 111  
 image files 
 defined,  264  
 for multiple sprites,  269  
 in  template   folder,  282 – 284  
 images 
 cell animation,  341  
 indices,  479  
 texture atlas,  344  
 tile-based,  478  
 virtual buttons,  325 – 326  
 virtual joystick,  331 – 332  
 Vulture Trouble game,  403 – 404 , 
 406 – 431  
 #include directive 
 defined,  38 ,  45 
 using,  45 – 46 
 increment (++) operator,  141 – 142  
 increment expression,  144  
 indentation 
 function body statements,  170  
 if-else-if statement,  111  
 nested decision structures,  106  
 infinite loops,  139  
 inheritance 
 base class,  538  
 defined,  537  
 derived class,  538  
 example,  538  
 “is-a” relationship and,  538 – 545  
 notation in class header,  540  
 initialization 
 array,  209 – 210  
 count,  232 – 233  
 count-controlled loop,  143  
 expression,  144 ,  146 – 147  
 game program,  254  
 object,  76 
 variable,  51 
 passing arrays as arguments to, 
 228 – 230 
 passing objects as arguments to, 
 535 – 537 
 passing two-dimensional arrays to, 
 244 – 245 
 returning strings from,  195 – 196  
 top-down design and,  173 – 174  
 using global variables,  185  
 value-returning,  169 ,  188 – 197  
 void ,  169 – 174  
 G 
 game loop 
 defined,  254 ,  285  
 program example,  285 – 289  
 state determination,  290  
 sync rate,  289 – 290  
 working in,  284 – 294  
 game states 
 defined,  290  
 program example,  290 – 294  
 games 
 Balloon Target,  546 – 554  
 Bug Zapper,  353 – 361  
 Bug Zapper (version 2), 
 445 – 451  
 data, saving,  267  
 game loop,  254  
 high score, saving,  445 – 451  
 initialization,  254  
 phases,  254  
 PizzaBot,  388 – 393  
 shutdown,  254  
 structure of,  254 – 257  
 tile use in,  478 
 Vulture Trouble,  403 – 431  
 generalization,  537 – 538  
 ghost sprites,  285  
 global constants 
 defined,  186  
 use example,  186 – 188  
 global variables 
 debugging and,  185  
 declaration,  184  
 defined,  184  
 functions using,  185  
 program example,  185  
 restricting use of,  185  
 warning,  294  
 graphics editor, transparent background 
creation in,  278  
 graphics files 
 location of,  265  
 template folder,  265  
 use in computer games,  264  
 H 
 hardware 
 CPU,  3 
 defined,  2 
 illustrated,  2 
 input devices,  5 
 main memory,  3 – 4 
 output devices,  5 
 secondary storage devices,  4 – 5 
 types of,  2 
 flags,  bool variables as,  122  
 flash memory,  5 
 flipping sprites,  276 
 float data type,  48 ,  49 ,  54 ,  272  
 floating-point notation,  10  
 floor function,  75 
 floppy disk drives,  5 
 flowcharts 
 count-controlled loops,  144  
 defined,  88 
 do-while loop,  140 
 dual alternative decision structure,  98  
 highest value in array,  225  
 illustrated,  88 
 nested decision structure,  102 ,  104  
 running total calculation,  153  
 sequence structure nested in decision 
structure,  103 
 sequential search algorithm,  217  
 switch statement,  117 ,  119  
 for loop.  See also loops 
 counter variable,  146 – 149  
 execution summary,  145  
 format,  143 
 increment expression,  144  
 initialization expression,  144 , 
 146 – 147  
 loop header,  144 
 program use example,  145 – 146 , 
 149 – 150 
 test expression,  144 
 update expression,  149  
 user iteration control,  151 – 152  
 writing,  149 – 150 
 forward slashes (/),  43 
 frame rate.  See sync rate  
 function body,  170 
 function definition 
 defined,  169 
 placement of,  173 
 function header 
 contructor,  516 
 defined,  169 
 function name,  170 
 parameter data type in,  181  
 parentheses,  170 
 parts of,  170 
 return type,  170 
 value-returning function,  190  
 function prototypes 
 defined,  172 
 illustrated example,  173  
 placement of,  173 
 functions.  See also specific functions 
 bool ,  194 – 195 
 breaking down programs into,  192  
 calling,  170 – 172 
 declaring variables inside,  50  
 defined,  38 ,  167 
 to divide and conquer large tasks,  168  
 elements of,  169 
 example,  168 – 169 
 introduction to,  167 – 169  
 math,  74 – 75 
 member,  197 ,  301 
 name,  170 
 passing arguments to,  176 – 184  

570 
Index
 return type,  527  
 signature,  527  
 Sprite class,  513 – 514  
 string class, calling,  197  
 member variables,  513  
 memory 
 flash,  5 
 main,  3 – 4 
 RAM (random-access memory),  4 
 return point,  172  
 methods,  508 ,  509 .  See also member 
functions  
 microprocessors,  3 
 Microsoft Visual C++ 2010 Express,  20 
 Microsoft Visual Studio 2010 
 copying/opening AGK template 
project in,  257 – 260  
 defined,  20 
 Express Edition download page,  560  
 file download dialog box,  560  
 installing,  559  
 setup program,  559  
 Solution Explorer,  23 – 25 ,  260  
 mixed-type expressions,  66 – 68 
 mnemonics,  14 
 modularized programs,  169  
 motion simulation in two directions, 
 400 – 403  
 mouse 
 coordinates, getting,  315 – 317  
 input, detecting,  317 – 319  
 showing/hiding,  317  
 sprite hit determination,  319 – 320  
 X-coordinate,  315  
 Y-coordinate,  315  
 MoveableSprite class 
 declaring,  539  
 defined,  538  
 deriving,  539  
 getDistance member function,  541  
 moveDown member function,  542  
 moveLeft member function,  542  
 moveRight member function, 
 542 – 543  
 moveUp member function,  541 – 542  
 overloaded constructors,  540  
 program code,  539 – 545  
 program use example,  539  
 public member functions,  539  
 setDistance member function,  541  
 updateSprite function,  545  
 MP3 format,  348  
 multiline comments,  59 
 multiple alternative decision 
structures,  116  
 multiple objects 
 creating from same class,  522 – 525  
 object states,  524  
 program,  522 – 525  
 Sprite object declaration,  524  
 multiple-dimensional arrays,  246  
 music files 
 defined,  352  
 loading,  352  
 playing,  352 – 353  
 program use example,  352 – 353  
 mutator functions,  513  
 log files 
 agk::Str function,  455  
 agk::WriteLine function,  456  
 agk::WriteString function, 
 455 – 456  
 defined,  455  
 illustrated example,  458  
 program example,  456 – 458  
 writing,  455 – 458  
 log function,  75 
 log10 function,  75 
 logical operators.  See also operators 
 AND (&&) operator,  112 ,  113  
 Boolean expressions with,  112  
 defined,  112  
 NOT (!) operator,  112 ,  114  
 numeric ranges,  115  
 OR (||) operator,  112 ,  113 – 114  
 precedence of,  115  
 short-circuit evaluation,  114  
 types of,  112  
 long data type,  48 
 loop header,  144  
 loops 
 condition-controlled,  132 – 141  
 count-controlled,  143 – 152  
 do-while ,  140 – 141  
 for loop,  143 – 152  
 game,  284 – 294  
 infinite,  139  
 nested,  155 – 160  
 posttest,  140 – 141  
 pretest,  136 – 137  
 for stepping through arrays, 
 210 – 212  
 while ,  133 – 139  
 M 
 machine language 
 to assembly language,  14 
 instructions,  12 
 main memory 
 chips illustration,  4 
 defined,  3 
 programs in,  13 
 as random-access memory 
(RAM),  3 
 math expressions 
 defined,  61  
 examples of,  61 – 62 
 mixed-type,  66 – 68 
 order of operations,  62 
 parentheses in,  63 
 variables in,  61 
 math functions 
 defined,  74  
 list of,  75  
 program use example,  74 – 75 
 math operators 
 defined,  60 – 61 
 remainder (modulus),  64 – 65 
 member functions 
 calling format,  197  
 defined,  197 ,  301  
 defining,  516 – 522  
 MoveableSprite class,  539  
 overloaded,  526 – 527  
 initialization lists,  209 
 input 
 defined,  5 
 devices,  5 
 keyboard, reading,  55 – 57  
 mouse,  317 – 319 
 virtual joystick,  333 – 336  
 input files.  See also files; output files 
 closing,  444 
 defined,  438 
 opening,  442 – 443 
 reading data from,  443 – 444  
 input-output stream library,  46  
 instances 
 defined,  511 
 sprite class,  521 
 int data type,  48 ,  49 
 int literals,  52 
 int variables,  52 – 53 
 integers 
 division,  63 – 64 
 negative,  10 
 interpreters 
 defined,  17 
 executing programs with,  18  
 iostream file,  38 ,  45 
 “is-a” relationship 
 example,  538 
 existence,  538 
 inheritance and,  538 – 545  
 isEven function,  195 
 K 
 key words,  16 
 keyboard 
 arrow keys,  336 – 338 
 input, reading,  55 – 57 
 key codes,  338 
 key presses, responding to, 
 338 – 339 
 last key pressed, determining, 
 339 – 340  
 moving objects with,  336 – 338  
 uses,  336 
 L 
 libraries 
 defined,  20 
 input-output stream,  46  
 standard,  20 
 lines, blank,  60 
 literals 
 character,  79 
 double,  52 
 int ,  52 
 numeric,  52 
 string,  41 ,  76 
 loading files 
 music,  352 
 sound,  348 
 loadTiles function,  491 ,  492  
 local variables 
 accessing,  54 ,  175 
 defined,  174  
 duplicate names,  176 
 example,  175  
 scope and,  175 

 
Index 
571
 program example,  231 – 233  
 use of,  230  
 passing arguments 
 arrays to functions,  228 – 230  
 defined,  176 – 177  
 to functions,  176 – 184  
 illustrated,  179  
 multiple,  180 – 181  
 parameter variable scope and,  180  
 program example,  177 – 179  
 by reference,  183 – 184  
 type and,  180  
 by value,  182 – 183  
 value-returning functions,  191  
 warning,  179  
 passing objects 
 as arguments,  535 – 537  
 program example,  535 – 537  
 by value,  535  
 percentages, calculating,  68 – 69 
 pixels (picture elements) 
 defined,  10 
 graphics window,  261  
 PizzaBot game 
 defined,  388 – 391  
 detectCollision function,  393  
 generatePizza function,  393  
 global constants,  392  
 robot texture atlas,  392  
 showYum function,  393  
 updateRobot function,  393  
 playing music,  352 – 353  
 playing sound,  349 – 351  
 position 
 sprite, setting,  271 – 273  
 text objects,  369  
 virtual buttons,  323 – 324  
 virtual joystick,  330  
 posttest loops,  140 – 141  
 pow function,  74 ,  75 ,  189  
 precision,  10 
 preprocessor,  45 
 presses 
 keyboard key,  338 – 339  
 last key,  339 – 340  
 virtual buttons,  326 – 328  
 pretest loops,  136 – 137  
 printing objects,  301 – 303  
 private keyword,  512  
 private section 
 defined,  512  
 Sprite class,  515  
 procedural programming,  507  
 procedures 
 defined,  507  
 function creation focus,  507 – 508  
 operation of,  507  
 programmers,  1 
 programming languages 
 assembly,  14 
 high-level,  14 – 16 
 low-level,  14 ,  15 
 types of,  15 
 programs.  See also AGK programs; games 
 compiling,  27 
 copied into main memory,  13 
 defined,  1 
 passing as arguments to functions, 
 535 – 537 
 reusability,  509  
 text,  367 – 384 
 obstacle encounters 
 defined,  492 – 493  
 program code,  493 – 499  
 off-by-one errors,  213  
  one-dimensional arrays,  239  
 OOP.  See object-oriented 
programming 
 opening programs,  28 
 operators 
 assignment,  49 
 combined assignment,  66 
 decrement,  141 – 142  
 defined,  17  
 increment,  141 – 142  
 logical,  112 – 116  
 math,  60 – 61 
 relational,  92 – 93 
 optical devices,  5 
 OR (||) operator 
 Boolean expressions,  113 – 114  
 defined,  112 
 precedence,  113 – 114 ,  115  
 short-circuit evaluation,  114  
 truth table,  113  
 order of operations,  62 – 63 
 output 
 console,  39 – 45 
 defined,  5 
 devices,  5 
 screen, displaying,  39 – 45 
 output files.  See also files; input files 
 closing,  442  
 defined,  438 
 opening,  440 – 442  
 overloaded constructors 
 binding,  527  
 defined,  526  
 example,  526  
 MoveableSprite class,  540  
 program example,  528 – 531  
 overloaded member functions 
 defined,  526 – 527  
 program example,  528 – 531  
 P 
 parallel arrays.  See also arrays 
 defined,  238  
 program example,  238 – 239  
 using,  237 – 239  
 parameter lists,  181  
 parameterized constructors,  526  
 parameters 
 data type,  181  
 defined,  176 ,  177  
 example,  177  
 multiple arguments passed to,  181  
 scope,  180 
 parentheses 
 function header,  170  
 in math expressions,  63 
 partially filled arrays 
 count increment,  231  
 problem,  230  
 N 
 named constants 
 defined,  71 ,  72 
 in program example,  72 – 73  
 use advantages,  72 
 uses for,  72 
 namespaces,  38 
 negative integers,  10 
 nested decision structures 
 alignment,  106 
 debugging,  106 
 decision structure in,  103  
 defined,  101 – 102 
 flowchart,  102 ,  104 
 with  if-else-if statement, 
 101 – 112 
 indentation,  106 
 multiple,  107 – 109 
 program use example,  104 – 105  
 sequence structure in,  103  
 series of conditions, testing,  107 – 109  
 nested loops 
 clock example,  155 – 156  
 defined,  155 
 using to print patterns,  156 – 160  
 newline escape sequence,  43 – 46  
 NOT (!) operator 
 Boolean expressions,  114  
 defined,  112 
 precedence,  114 ,  115 
 truth table,  113 ,  114 
 numbers 
 calculations with,  60 – 71  
 random, generating,  303 – 308  
 real,  10 
 storing,  7 – 9 
 numeric literals,  52 
 O 
 object arrays.  See also arrays 
 creating,  532 – 535 
 defined,  532 
 program example,  532 – 535  
 object-oriented programming 
 Balloon Target game,  546 – 554  
 inheritance,  537 – 554 
 object-oriented programming (OOP) 
 data hiding,  508 
 defined,  507 ,  508 
 encapsulation,  508 
 fields,  508 ,  509 
 member functions,  510 
 member variables,  510 
 methods,  508 ,  509 – 510  
 object reusability,  509  
 terminology,  509 – 510  
 objects 
 classes versus,  510 – 511  
 defined,  508 
 elements of,  508 
 example of,  509 
 falling, simulation,  394 – 403  
 initializing,  76 
 moving with keyboard arrow keys, 
 336 – 338 
 multiple, creation from same class, 
 522 – 525 

572 
Index
 software developers,  1 
 Solution Explorer,  23 – 25 ,  260  
 sorting arrays.  See also arrays 
 ascending order,  471  
 descending order,  471  
 section sort algorithm,  471 – 478  
 values,  471 ,  472 ,  473  
 sound files 
 loading,  348  
 playing,  349 – 351  
 program use example,  349 – 351  
 WAV format,  348  
 spacing, text object letters,  377 – 379  
 specialization,  537 – 538  
 sprite animations 
 playing,  345 – 347  
 resuming,  347  
 stopping,  347  
 Sprite class 
 default constructor,  528  
 defined,  511  
 definition,  515  
 designing,  513 – 515  
 example,  513 – 514  
 explicit call to constructor,  541  
 instance of,  511–512, 521  
 member function declarations,  515  
 membership identification,  517  
 object creation from,  521  
 overloaded constructors,  526  
 private member variables,  513  
 private section,  515  
 program example,  514 – 515  
 public member functions,  513 – 514  
 public section,  515  
 sprite collision detection 
 agk::GetSpriteCollision 
function,  385  
 defined,  384  
 global constants,  387  
 PizzaBot game,  388 – 393  
 program example,  385 – 387  
 sprite index 
 assigning,  264  
 defined,  264  
 sprites 
 as background,  267 – 268  
 from bitmap images,  267  
 bounding boxes,  384  
 cloning,  276 – 277  
 collisions,  384  
 colors, applying,  295 – 297  
 creating,  264  
 defined,  264  
 deleting,  282  
 depth,  270 – 271  
 flipping,  276  
 ghost,  285  
 height,  274  
 invisible,  276  
 mouse hit determination, 
 319 – 320  
 moving,  335  
 multiple, creating,  268 – 270  
 position, setting,  271 – 273  
 position, setting with random 
numbers,  305 – 308  
 S 
 samples,  11  
 scope 
 defined,  54 
 local variables and,  175  
 parameter variable,  180  
 variable visibility and,  180  
 screen coordinate system 
 Cartesian coordinate system versus,  262 
 defined,  261  
 resolution,  261 ,  262  
 virtual resolution,  261 – 263  
 X-/Y-coordinates,  260 ,  261  
 screen position, virtual button,  323 – 324  
 screen resolution,  293  
 search algorithms 
 defined,  216  
 sequential,  216 – 220  
 secondary storage devices 
 defined,  4 
 disk drive,  4 – 5 
 floppy disk drive,  5 
 optical,  5 
 programs on,  12 – 13 
 types of,  4 – 5 
 USB drive,  5  
 selection sort algorithm 
 defined,  471 
 process,  471 – 473  
 program example,  473 – 477  
 selectSort function,  478  
 semicolons,  39 ,  46 ,  512  
 sequence structures 
 in decisions structure,  103  
 defined,  88 – 89 
 flowcharts,  88 
 sequential search algorithms. 
 See also arrays 
 defined,  216  
 flowchart,  217  
 logic,  217  
 program use example,  218  
 for string arrays,  219 – 220  
 short data type,  48 
 short-circuit evaluation,  114  
 shuffling program 
 algorithm,  469 
 code,  466 – 469 
 dealt cards screen,  466  
 defined,  465  
 swapping array elements,  470  
 shutdown,  254  
 signature, function,  527  
 sin function,  75 
 single alternative decision structures, 
 90 – 97  
 single-line comments,  58 – 59 
 size 
 text objects,  368 – 369  
 virtual buttons,  324  
 virtual joystick,  330  
 size declarators 
 array,  206 ,  215  
 defined,  206  
 software 
 defined,  1 
 for using this book,  20 
 programs (Continued) 
 executing,  27 ,  30 
 execution,  13 
 files used by,  437 – 438  
 functioning of,  11 – 19 
 modularized,  168 – 169  
 opening,  28 
 parts of,  37 – 39 
 storage,  12 – 13  
 writing,  21 – 27 
 projects 
 defined,  21 
 folders,  22 
 starting,  21 
 prompts,  57 
 pseudocode 
 algorithm example,  95 – 96  
 defined,  89 
 examples of,  89 
 game state,  290 
 mouse pointer position,  319  
 public keyword,  512 
 public section 
 defined,  512 
 Sprite class,  515 
 Q 
 quotation marks,  79 
 R 
 RAM (random-access memory),  4 
 random numbers 
 generating,  303 – 308 
 use of,  303 
 using to position/set transparency of 
sprites,  305 – 308 
 random-access memory (RAM),  4 
 real numbers,  10 
 reference, passing arguments by,  183 – 184  
 reference variables 
 declaration,  183 
 defined,  183 
 program use example,  183 – 184  
 use of,  183 
 relational operators,  92 – 93  
 remainder (modulus) operator,  64 – 65  
 repetition structures.  See also control 
structures 
 condition-controlled loops,  132 – 141  
 count-controlled loops,  143 – 152  
 defined,  88 – 89 ,  132 
 introduction to,  131 – 132  
 nested loops,  155 – 160 
 running total calculation,  152 – 154  
 reserved words,  16 
 return point,  172 
 return type 
 defined,  170 
 member function,  527  
 RGB color system,  294 – 295  
 rotating sprites,  275 – 276  
 running totals 
 calculating,  152 – 154 
 defined,  152 
 elements in,  152 
 logic,  153 
 program use example,  153 – 154  

 
Index 
573
 transparent backgrounds 
 black in creating,  278 – 281  
 creating images with,  278  
 program example,  280 – 281  
 in sprites,  277 – 278  
 use illustration,  277  
 truncation,  64 
 truth tables 
 AND (&&) operator,  113  
 NOT (!) operator,  114  
 OR (||) operator,  113  
 two-dimensional arrays.  See also arrays 
 curly braces,  243  
 data processing in,  241  
 declaring,  240 – 241  
 defined,  239  
 example,  240 – 241  
 illustrated,  239 ,  240  
 passing to functions,  244 – 245  
 processing of,  241  
 program example,  242 – 243  
 with subscripts,  241  
 use of,  240  
 two’s complement arithmetic,  10 
 type cast expressions,  67 
 U 
 Unicode,  10 
 USB drives,  5 
 user-friendly,  57 
 users, prompting,  57 
 V 
 value-returning functions 
 defined,  169 ,  188  
 example,  190  
 at finish,  189  
 format,  189  
 function header,  190  
 passing arguments and,  191  
 return statement,  190  
 return values,  191 – 192  
 void functions versus,  188  
 writing,  189 – 194  
 values 
 array,  206 ,  223 – 228 ,  471 ,  472 ,  473  
 array element,  207 – 208  
 passing arguments by,  182 – 183  
 return,  191 – 192  
 variables, increasing,  66 
 variable declaration 
 defined,  46 
 format,  46 
 global variables,  184  
 in initialization expression,  146 – 147  
 initializing in,  51 
 inside functions,  50 
 local variables,  174  
 multiple variables,  51 – 52 
 reference variable,  183  
 statements,  50 – 51 
 before using,  50 – 51  
 variables 
 counter,  146 – 149  
 data type,  47 
 decrementing,  141 – 142  
 defined,  46 
 T 
 tan function,  75 
 template  folder 
 as base folder,  283  
 illustrated,  284  
 location of,  282 ,  283  
 organizing images in,  282 – 284  
 test expression,  144  
 testExpression, in switch statement, 
 117 – 118  
 text 
 display, virtual buttons,  324  
 display in AGK window,  298 – 303  
 title display,  303  
 text objects 
 alignment,  373 – 376  
 alignment types,  374  
 collision detection,  381 – 384  
 color, changing,  380  
 creating,  367 – 368  
 defined,  367  
 deleting,  368  
 existence determination,  368  
 letter spacing,  377 – 379  
 position, setting,  369  
 showing/hiding,  380  
 size, getting,  369  
 size, setting,  368  
 string value, changing,  379  
 total height,  380  
 total width,  380  
 uses for,  367 
 X-coordinate, getting,  369  
 X-coordinate, setting,  369  
 Y-coordinate, getting,  370 – 373  
 Y-coordinate, setting,  370  
 texture atlases 
 animation with,  344 – 345  
 animations, playing,  345  
 defined,  344  
 illustrated,  344 ,  345  
 image identification,  345  
 images,  344  
 rows and columns,  344 – 345  
 three-dimensional arrays,  246  
 tile maps 
 defined,  478 ,  480  
 elements,  480  
 obstacle encounter,  492 – 501  
 tile display program,  481 – 484  
 Walking Alec program,  484 – 501  
 tile-based images,  478  
 tiles 
 constants declaration,  480  
 defined,  478  
 displaying,  480 – 481  
 game use,  478  
 illustrated,  479  
 top-down design,  173 – 174  
 totaling, array values,  223  
 transparency 
 applying to sprites,  295 – 297  
 setting with random numbers, 
 305 – 308  
 virtual buttons,  324 – 325  
 virtual joystick,  330  
 working with,  294 – 297  
 rotating,  275 – 276 
 scaling,  274 – 275 
 transparency, applying,  295 – 297  
 transparency, setting with random 
numbers,  305 – 308 
 transparent backgrounds, 
 277 – 281 
 visible,  276 
 width,  274 
 X-/Y-coordinates, getting,  274  
 sqrt function,  75 
 standard library,  20 
 statements 
 assignment,  49 
 defined,  17 
 semicolon,  39 
 variable declaration,  50 – 51  
 stepwise refinement,  174  
 stream insertion operator (<< operator), 
 40 ,  41 
 string arrays,  219 – 220 
 string class 
 defined,  76 
 member functions, calling,  197  
 using,  76 
 string data type,  48 
 string literals 
 assigning,  76 
 defined,  41 
 string objects 
 declaring,  76 
 printing,  301 – 303 
 strings 
 comparing,  122 – 124 
 concatenation,  78 
 defined,  41 
 null-terminated,  197 
 program use examples,  76 – 78  
 returning from functions, 
 195 – 196 
 text object value,  379 – 380  
 working with,  76 – 78 
 subscripts 
 data in more than three 
dimensions,  246 
 defined,  207 
 illustrated,  207 
 with parallel arrays,  237  
 two-dimensional array,  241  
 sum function,  192 
 swap function,  470 
 switch statement 
 defined,  116 
 flowchart,  117 ,  119 
 format,  117 
 guidelines for using,  118  
 program use example,  120 – 121  
 testExpression ,  117 – 118  
 using,  119 – 121 
 sync rate 
 changing,  289 – 290 
 defined,  289 
 slowing,  290 
 syncing,  265 
 syntax 
 defined,  17 
 errors,  18 

574 
Index
 defined,  484  
 displayTiles function, 
 499 ,  500  
 global constants,  490 – 491 ,  499  
 loadTiles function,  491 ,  492  
 obstacle encounters code, 
 493 – 499  
 starting screen,  490  
 updateAlecX function, 
 491 ,  492  
 updateAlecY function,  492  
 WAV format,  348  
 while loop.  See also loops 
 Boolean expression,  133  
 defined,  133  
 execution,  134  
 format,  133  
 illustrated,  136  
 logic,  133  
 as pretest loop,  136 – 137  
 program use example,  134 – 135  
 stopping execution of,  136  
 while  clause,  133  
 writing programs with,  137 – 138  
 width, text objects,  380  
 writing data,  438  
 X 
 X-axis,  273  
 X-coordinate 
 agk::SetSpritePosition function 
and,  272  
 Balloon Target game,  552  
 floating-point value,  381  
 mouse,  315  
 in screen coordinate system, 
 260 ,  261  
 sprite, getting,  274  
 text objects,  369  
 Y 
 Y-coordinate 
 agk::SetSpritePosition function 
and,  272  
 floating-point value,  381  
 mouse,  315  
 in screen coordinate system,  260 ,  261  
 sprite, getting,  274  
 text objects,  370 – 373  
 visibility, setting, virtual joystick,  331  
 Visual Studio.  See Microsoft Visual 
Studio 2010  
 void functions 
 calling,  170 – 172  
 defined,  169 
 function body,  169 ,  170  
 function definition,  169  
 function header,  169 – 170  
 Vulture Trouble game 
 app::Loop function,  414 – 416  
 checkCollisions function,  423 – 424  
 displaySummaryScreen function, 
 428 – 430 
 displayTitleScreen function,  416  
 global constants,  408  
 global variables,  409  
 hideGame function,  419  
 hideGameOverScreen function, 
 427 – 428 
 hideIntroScreen function, 
 417 – 418  
 hideSummaryScreen function, 
 430 – 431 
 hideTitleScreen function, 
 416 – 417  
 images,  403 – 404 ,  406  
 introductory screen,  403 ,  404  
 main screen,  403 ,  405  
 moveBasket function,  419 – 420  
 moveEgg function,  422 – 423  
 moveVulture function,  418 – 419 , 
 420 – 422  
 playGame function,  418  
 resetEgg function,  426 – 427  
 showBrokenEgg function, 
 425 – 426 
 showHitBasket function, 
 424 – 425 
 summary screen,  403 ,  405  
 title screen,  403 ,  404  
 W 
 Walking Alec program.  See also tile maps 
 animated sprite frames,  489  
 app::Begin function,  491 ,  500  
 app::Loop function,  491 – 492 ,  500  
 checkForCollision function,  500  
 code,  484 – 489 
 variables (Continued) 
 global,  184 – 186 
 holding one value at a time,  53 – 54  
 incrementing,  141 – 142  
 initializing,  51 
 local,  174 – 176 
 in math expressions,  61  
 names,  47 – 48 
 names, duplicating,  54 ,  176  
 parameter,  177 
 reference,  183 
 scope,  54 
 as storage location,  46 
 swapping content of,  470  
 value, increasing,  66 
 virtual buttons 
 adding to screen,  323 
 color, changing,  324 
 customization,  326 
 defined,  323 
 enabling/disabling,  325  
 images, changing,  325 – 326  
 position, changing,  323 – 324  
 presses, responding to,  326 – 328  
 showing/hiding,  325 
 size, changing,  324 
 text, displaying,  324 
 transparency, changing,  324 – 325  
 uses,  322 
 virtual joysticks 
 active/inactive setting,  331  
 adding,  329 
 dead zone, setting,  332 – 333  
 defined,  329 
 deleting,  332 
 existence, determining,  332  
 images, changing,  331 – 332  
 input, getting,  333 – 336  
 position, setting,  330 
 size, setting,  330 
 sprite movement and,  335  
 transparency, setting with random 
numbers,  330 
 uses,  329 
 visibility, setting,  331 
 virtual resolution 
 defined,  261 
 program example,  263 
 setting,  262 – 263 ,  267  

Copyright © 2012 by Microsoft Corporation. Used with permission from Microsoft. Microsoft 
and/or its respective suppliers make no representations about the suitability of the information 
contained in the documents and related graphics published as part of the services for any purpose. 
All such documents and related graphics are provided “as is” without warranty of any kind. 
Microsoft and/or its respective suppliers hereby disclaim all warranties and conditions with regard 
to this information, including all warranties and conditions of merchantability, whether express, 
implied or statutory, fitness for a particular purpose, title and non-infringement. In no event shall 
Microsoft and/or its respective suppliers be liable for any special, indirect or consequential 
damages or any damages whatsoever resulting from loss of use, data or profits, whether in an 
action of contract, negligence or other tortious action, arising out of or in connection with the use 
or performance of information available from the services. The documents and related graphics 
contained herein could include technical inaccuracies or typographical errors. Changes are 
periodically added to the information herein. Microsoft and/or its respective suppliers may make 
improvements and/or changes in the product(s) and/or the program(s) described herein at any 
time. Partial screen shots may be viewed in full within the software version specified.
Figure 1.1a © IKO | Shutterstock, Figure 1.1b © feng Yu | Shutterstock, Figure 1.1c 
© Nikita Rogul | Shutterstock, Figure 1.1d © Chiyacat | Shutterstock, Figure 1.1e 
© Eikostas | Shutterstock, Figure 1.1f © tkemot | Shutterstock, Figure 1.1g © Vitaly Korovin | 
Shutterstock, Figure 1.1h © Lusoimages | Shutterstock, Figure 1.1i © jocic | Shutterstock, 
Figure 1.1j © Marina7 | Shutterstock, Figure 1.1k © Peter Guess | Shutterstock, Figure 1.1l 
© Aquila | Shutterstock, Figure 1.2 © US Army Center of Military History, Figure 1.3 
© Ronstik | Shutterstock, Figure 1.4 © Garsya | Shutterstock, Figures 1.19–1.34 © Microsoft 
Visual C++® 2010 Express screenshots copyright © 2010 by Microsoft Corporation. 
Reprinted with permission, Figures A.4–A.8 © Reprinted with permission of The Game 
Creators Ltd.
Credits
575

This page intentionally left blank 

 
black
(0,0,0)
blue
(0,0,255)
red
(255,0,0)
green
(0,255,0)
yellow
(255,255,0)
cyan
(0,255,255)
magenta
(255,0,255)
white
(255,255,255)
 Figure C-1  Red, green, and blue channels  
 Figure C-2  Output of Program 7-4  

 Figure C-3  The ghost.png image with its transparent background  
 Figure C-4  The Dog and Beach images  

 Figure C-5  Output of Program 7-7  
 Figure C-6  Ghost sprite with alpha value of 100  

 Figure C-7  Example output for Program 8-3  
 Figure C-8  Screens from the Bug Zapper game  

 Figure C-9  Vulture Trouble title screen and introductory screen  

 Figure C-10  Vulture Trouble main screen and summary screen  

 Figure C-11  A tile-based image  
 Figure C-12  Tiles  
 Figure C-13  Animated sprite frames for the Alec character (stored in Alec.png)  

 Figure C-14  Starting screen from Program 10-9  
 Figure C-15  The Balloon Target game  

