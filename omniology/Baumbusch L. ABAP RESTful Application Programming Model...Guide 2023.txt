
Lutz Baumbusch, Matthias Jäger, Michael Lensch
ABAP RESTful Application Programming
Model
The Comprehensive Guide

Imprint
This e-book is a publication many contributed to, specifically:
Editor   Hareem Shafi
German Edition Editor   Janina Schweitzer
Copyeditor   Tanya Thamkruphat
Translation   Lemoine International, Inc.
Cover Design   Bastian Illerhaus
Photo Credit    Shutterstock: 295387826/©somsak nitimongkolchai
Production E-Book   Kyrsten Coleman
Typesetting E-Book   Satz-Pro (Germany)
We hope that you liked this e-book. Please share your feedback with
us and read the Service Pages to find out how to contact us.
Library of Congress Cataloging-in-Publishing Control Number:
2022945836
ISBN 978-1-4932-2379-4 (print)
ISBN 978-1-4932-2380-0 (e-book)
ISBN 978-1-4932-2381-7 (print and e-book)
© 2023 by Rheinwerk Publishing Inc., Boston (MA)
1st edition 2023

Dear Reader,
I love routines. My favorite juice in the morning, the drive to work,
listening to NPR on my way home, a chapter or two of a book before
bed—even the simplest habits bring comforting order to my day.
So when I first learned about programming models, they made a lot
of sense to me. What better way to streamline application
development than to create structure—define a programming
workflow, provide a set of tools and technologies, and map out the
application building, testing, and troubleshooting processes.
Of course, no matter how efficient and effective a new routine might
be, it still takes some getting used to. Over the course of this book,
you’ll gain the practical knowledge you need to make the ABAP
RESTful application programming model part of your day-to-day
programming practices.
What did you think about ABAP RESTful Application Programming
Model? Your comments and suggestions are the most useful tools to
help us make our books the best they can be. Please feel free to
contact me and share any praise or criticism you may have.
Thank you for purchasing a book from SAP PRESS!
Hareem Shafi 
Editor, SAP PRESS
hareems@rheinwerk-publishing.com 
www.sap-press.com 

Rheinwerk Publishing • Boston, MA

Notes on Usage
This e-book is protected by copyright. By purchasing this e-book,
you have agreed to accept and adhere to the copyrights. You are
entitled to use this e-book for personal purposes. You may print and
copy it, too, but also only for personal use. Sharing an electronic or
printed copy with others, however, is not permitted, neither as a
whole nor in parts. Of course, making them available on the internet
or in a company network is illegal as well.
For detailed and legally binding usage conditions, please refer to the
section Legal Notes.
This e-book copy contains a digital watermark, a signature that
indicates which person may use this copy:
 

Notes on the Screen Presentation
You are reading this e-book in a file format (EPUB or Mobi) that
makes the book content adaptable to the display options of your
reading device and to your personal needs. That’s a great thing; but
unfortunately not every device displays the content in the same way
and the rendering of features such as pictures and tables or
hyphenation can lead to difficulties. This e-book was optimized for
the presentation on as many common reading devices as possible.
If you want to zoom in on a figure (especially in iBooks on the iPad),
tap the respective figure once. By tapping once again, you return to
the previous screen. You can find more recommendations on the
customization of the screen layout on the Service Pages.

Table of Contents
Dear Reader
Notes on Usage
Table of Contents
Foreword
Preface

Part I   Basic Concepts and
Technical Components
1   Introduction
1.1   What is the ABAP RESTful Application
Programming Model?
1.1.1   The Purpose of the Programming Model
1.1.2   The REST Architectural Style
1.1.3   OData
1.1.4   Technological Innovations with SAP S/4HANA
1.1.5   Evolution of ABAP-Based Programming Models
1.2   Architecture and Concepts
1.2.1   Transaction Model
1.2.2   Implementation Types
1.2.3   Entity Manipulation Language
1.2.4   Technical Context of Applications and Runtime
Environment
1.3   Development Objects
1.3.1   Data Modeling with Core Data Services
1.3.2   Behavior Definition
1.3.3   Behavior Implementation
1.3.4   Projection Layer
1.3.5   Business Services

1.3.6   Interaction of the Artifacts
1.4   ABAP Development Tools
1.5   Quality Attributes of the ABAP RESTful
Application Programming Model
1.5.1   Evolution Capability
1.5.2   Development Efficiency
1.5.3   Testability
1.5.4   Separation between Business and Technology
1.6   Availability of the ABAP RESTful
Application Programming Model
1.6.1   SAP BTP, ABAP Environment
1.6.2   ABAP Platform for SAP S/4HANA On-Premise
2   Core Data Services: Data
Modeling
2.1   What are Core Data Services?
2.2   Structure and Syntax of Core Data
Services
2.2.1   Creating a Basic Interface View
2.2.2   Analyzing the Data Model
2.2.3   Using CDS Views
2.2.4   Extending the Data Model
2.3   Associations
2.4   Annotations

2.5   Access Controls
2.6   Extensibility of CDS Entities
2.6.1   CDS View Extensions
2.6.2   CDS Metadata Extension
2.7   Additional CDS Functionality
2.7.1   Virtual Elements
2.7.2   CDS Custom Entities
2.8   Virtual Data Model
2.9   CDS Language Elements for Modeling
Business Objects
3   Behavior Definition
3.1   What is a Behavior Definition?
3.1.1   Context and Structure of a Behavior Definition
3.1.2   Syntax of a Behavior Definition
3.1.3   Possible Behavior
3.2   Editing a Behavior Definition in ABAP
Development Tools
3.2.1   Creating a Behavior Definition
3.2.2   Changing and Activating a Behavior Definition
3.2.3   Finding and Opening a Behavior Definition
3.2.4   Documenting Behavior Definitions and
Relationships
3.3   Implementation Types
3.3.1   Managed Scenario

3.3.2   Unmanaged Scenario
3.4   Strict Mode
3.5   Entity Behavior Definition
3.6   Defining a Behavior Pool
3.6.1   Behavior Pool for Behavior Definition
3.6.2   Behavior Pool for the CDS Entity
3.6.3   Behavior Pool for the Implementation Group
3.7   Numbering
3.7.1   Early, External Numbering
3.7.2   Early, Internal Numbering
3.7.3   Late Numbering
3.8   Field Properties
3.8.1   Mandatory Fields
3.8.2   Protection Against Write Access
3.8.3   Combination: Mandatory Field in Case of Creation,
Write Protection in Case of Updates
3.9   Field Mappings
3.10   Standard Operations for a CDS Entity
3.10.1   Create, Read, Update, and Delete
3.10.2   Create and Read Operation by Association
3.11   Specific Operations for a CDS Entity
3.11.1   Actions
3.11.2   Functions
3.12   Concurrency and Locking Behavior
3.12.1   Pessimistic Locking
3.12.2   Optimistic Locking
3.13   Internal Business Logic

3.13.1   Determinations
3.13.2   Validations
3.13.3   Calling Determinations via an Action
3.14   Authorization Checks
3.14.1   Authorization Master
3.14.2   Authorization-Dependent
3.14.3   Delegating Authorization Checks
3.15   Draft Handling
3.15.1   Enabling Draft Handling
3.15.2   Draft Handling in the Business Object Composition
Tree
3.15.3   Draft Lifecycle and Draft Actions
3.16   Overarching Concepts
3.16.1   Dynamic Feature Control
3.16.2   Preliminary Checks of Operations
3.16.3   Internal Visibility of Operations
4   Entity Manipulation Language:
Accessing Business Logic
4.1   Data Types
4.1.1   Derived Data Types
4.1.2   Implicit Return Parameters
4.2   EML Operations
4.2.1   READ ENTITIES
4.2.2   MODIFY ENTITIES

4.2.3   GET PERMISSIONS
4.2.4   SET LOCKS
4.2.5   COMMIT ENTITES
4.2.6   ROLLBACK ENTITIES
4.3   Using EML Outside of Behavioral
Implementations
4.3.1   Use in the Context of an ABAP Report
4.3.2   Implementation in the Context of a Test Class
5   Behavior Implementation
5.1   Business Object Provider API
5.2   Runtime Behavior of the ABAP RESTful
Application Programming Model
5.2.1   Interaction Phase and Transaction Buffer
5.2.2   Save Sequence
5.3   Interfaces for the Interaction Handler and
the Save Handler
5.4   Interaction Handler
5.4.1   FOR MODIFY
5.4.2   FOR INSTANCE AUTHORIZATION
5.4.3   FOR GLOBAL AUTHORIZATION
5.4.4   FOR FEATURES
5.4.5   FOR GLOBAL FEATURES
5.4.6   FOR LOCK
5.4.7   FOR READ

5.4.8   FOR READ BY ASSOCIATION
5.4.9   FOR DETERMINE
5.4.10   FOR VALIDATE
5.4.11   FOR NUMBERING
5.4.12   FOR PRECHECK
5.5   Save Handler
5.5.1   FINALIZE
5.5.2   CHECK_BEFORE_SAVE
5.5.3   ADJUST_NUMBERS
5.5.4   SAVE
5.5.5   CLEANUP
5.5.6   CLEANUP_FINALIZE
6   Business Services
6.1   Projection Layer
6.1.1   CDS Projection View
6.1.2   Projection Behavior Definition
6.2   Service Definition
6.3   Service Binding
6.4   Testing Business Services in the SAP
Gateway Client
6.5   Testing UI Services with SAP Fiori
Elements Preview

7   User Interfaces and SAP Fiori
Elements
7.1   Development Tools
7.1.1   SAP Business Application Studio
7.1.2   Visual Studio Code
7.2   SAP Fiori Elements
7.2.1   Floorplans in SAP Fiori Elements
7.2.2   Selected UI Annotations
7.2.3   Defining UI Annotations in a CDS View
7.2.4   Generating Annotations via the Service Modeler

Part II   Practical Application
Development
8   Use Cases
8.1   Applications Types
8.2   Implementation Types
8.3   Selecting the Appropriate Implementation
Type
9   Managed Scenario:
Developing an Application with
SAP Fiori Elements
9.1   Description of the Use Case
9.2   Building the Data Model
9.2.1   Database Tables
9.2.2   CDS Modeling
9.3   Creating Behavior Definitions
9.3.1   Creating Behavior Definitions for Certificate
Management

9.3.2   Enabling Draft Handling
9.4   Defining a Business Service
9.4.1   Creating a Service Definition
9.4.2   Creating the Service Binding
9.5   Creating an SAP Fiori Elements User
Interface
9.6   Enrichment with a Determination
9.7   Enrichment with a Validation
9.8   Enrichment with an Action
9.9   Generation and Deployment of the
Application
10   Managed Scenario with
Unmanaged Save: Integrating an
Existing Application
10.1   Description of the Use Case
10.2   Building the Data Model
10.2.1   Overview of the Logical Data Model
10.2.2   Database Tables
10.2.3   CDS Modeling
10.3   Creating a Behavior Definition
10.4   Implementing the Create Purchase Order
Function

10.4.1   Declaring Late Numbering
10.4.2   Setting Field Properties
10.4.3   Creating the Behavior Pool
10.4.4   Implementing Determinations
10.4.5   Save Sequence: Implementing the Creation via
BAPI
10.4.6   Implementing Validations
10.5   Implementing the Delete Purchase Order
Function
10.5.1   Save Sequence: Implementing the Deletion via
BAPI
10.5.2   Implementing a Validation
10.6   Defining Business Services
10.6.1   Setting up the Projection Layer for the My
Purchase Orders Application
10.6.2   Creating a Service Definition
10.6.3   Creating a Service Binding
10.7   Implementing Authorization Checks
10.7.1   Access Controls for Read Access
10.7.2   Access Controls for Write Access
10.8   Creating an SAP Fiori Elements User
Interface
10.8.1   Creating a Metadata Extension
10.8.2   Generating and Deploying the Application
11   Unmanaged Scenario:
Reusing Existing Source Code

11.1   Description of the Use Case
11.2   Description of the Existing Application
11.2.1   Database Tables
11.2.2   Source Code of the Existing Application
11.3   Extending the Data Model
11.4   Creating a Behavior Definition
11.5   Creating a Behavior Implementation
11.5.1   Implementing the Interaction Phase
11.5.2   Implementing the Save Sequence
11.6   Defining a Business Service
12   Specific Features for the
SAP BTP, ABAP Environment
12.1   Technical Fundamentals
12.1.1   ABAP for Cloud Development
12.1.2   Technical Infrastructure Components
12.1.3   Migrating Legacy Code
12.2   Identity and Access Management
12.3   Deploying SAP Fiori Apps and Assigning
Authorizations
12.3.1   Creating an IAM App and Business Catalog
12.3.2   Creating an IAM Business Role
12.3.3   Integration in SAP Fiori Launchpad
12.4   Consuming Business Services

13   Outlook
13.1   Build
13.2   Extensibility
13.3   Integration and Reusability
A   Bibliography
A.1   Books
A.2   Online Resources
B   Authors
Index
Service Pages
Legal Notes

Foreword
Everyone involved in the process of software development, whether
they’re developers, architects, or project managers, knows the
challenges and uncertainties that are brought about by new
technology trends, frameworks, tools, and standards. The driving
force behind these changes is usually that business application
software development should be simplified and thus made more
efficient. However, existing software, and the investments made with
it, must also be taken into account. Existing software must be
effortlessly adapted or integrated into the new standards.
Realistically, this is easier said than done, because technical aspects
and business logic are often mixed up in the source code of an
application. This makes it difficult to adapt to changing technological
conditions, such as a new user interface (UI) or a new application
interface technology. Sometimes, it even necessitates completely
new developments.
While technology is one side of the software development coin, on
the other side is business logic. Over the years, we've repeatedly
heard the following credo, and we’re sure you know it, too:
“Application development should focus more on its actual work—
namely, the implementation of business logic based on the
requirements of the respective business departments.”
If improved focus is required, there must obviously be some form of
distraction. This distraction exists, for example, in changing
technological frameworks that must be accounted for on top of

technical requirements, during implementation. These typically
increase implementation costs (total cost of development [TCD]). It’s
important, therefore, to eliminate such distractions.
Against this backdrop, the ABAP stack was created. Over the years,
it has established itself as a rich and stable technical foundation for
successful application development. The Business Object
Processing Framework (BOPF) was the first to standardize business
logic (i.e., the technical side of business applications). The ABAP
programming model for SAP Fiori adopts BOPF in a core data
services-based (CDS-based) variant and decouples from technical
components, such as SAP Fiori elements, by using annotations.
If we mix the development of ABAP as a language for creating
business application software with the basic ideas of BOPF, the
programming models of the ABAP platform, and the desire to build
software that’s capable of evolution or to provide existing software
with “evolution protection,” then the logical consequence is a
programming model anchored in the ABAP core. It comes with its
own repository objects and numerous extensions to the ABAP
language and inherently ensures that business and technology
remain two separate sides of the same coin. As the software
development journey moves to the cloud, a Representational State
Transfer-based (REST-based) approach helps to decoupling
application interaction from the cloud infrastructure being used. The
result of these considerations is the ABAP RESTful application
programming model for the development of SAP Fiori apps and web
application programming interfaces (APIs).
We would like to thank the authors and the publisher for producing
this book. We hope the readers will enjoy it.

Volker Drees
RAP Product Expert
Marcel Hermanns
RAP Product Lead/Chief Development Expert

Preface
The ABAP programming language and its associated programming
models have always been evolving. With the current ABAP RESTful
application programming model, there have been drastic changes in
the way applications are developed. This programming model
provides some new programming concepts, such as behavior
definitions and business services.
The goal of this book is to give you a comprehensive overview of the
latest programming model. Not only will you acquire the necessary
theoretical background knowledge, but you’ll also apply what you’ll
learn to three extensive, practical chapters. The practical use cases
described in those three chapters can serve as a basis to help you
adapt your own development projects to the new programming
model.
Part I of this book lays the foundation for the more practical Part II,
and introduces the basic concepts of the programming model in
detail. Thus, the first part of the book is suitable for readers of
varying knowledge levels. It’s aimed at both ABAP developers who
have experience with the programming model and want to deepen
their knowledge, and those who have no previous experience with
the model. However, you should already have basic knowledge of
ABAP development to understand the book, whether you work in a
cloud environment or on an on-premise SAP S/4HANA system.
If you’re new to the ABAP RESTful application programming model,
it’s a good idea to read the book chronologically. If you already have

some experience with the programming model, it may make sense to
dive deeper into the topics that are of specific interest to you. As a
note, the examples in Part II are independent of each other. Since
the examples don’t build upon each other, you can read the book in
whichever order you prefer.
[»]  Downloadable Programming Examples
All programming examples from the book are available in the
Product Supplements section at www.sap-press.com/5647. In
some cases, only excerpts from some development objects of the
sample data models and applications are printed in the listings of
this book. You can find the full source code in the downloadable
materials.
As already mentioned, the book consists of two parts. In Part I, you’ll
learn the basic concepts of the ABAP RESTful application
programming model.
In Chapter 1, we introduce the programming model and categorize it
software architecture within other architectural models. Also, we
explain the different use cases and variants of development with
ABAP RESTful application programming model in this chapter.
Chapter 2 describes CDS capabilities and functions using examples.
Since CDS is a central building block of the programming model, this
chapter forms the basis for the language elements and development
objects that build upon it.
Chapter 3 introduces behavior definition and builds upon the
introduction to CDS to explain the different implementation types of
the programming model. We describe the structure, the essential

language elements, and the capabilities of behavior definitions by
using numerous examples.
Chapter 4 describes the concept, syntax, and capabilities of the
entity manipulation language (EML) integrated in ABAP. By this
chapter, we’ll have already built the bridge to learning about behavior
implementation.
Chapter 5 explains behavior implementation. You’ll learn about the
structure of the interface for implementing an application’s business
logic. You’ll also learn when and where behavior can be
implemented.
In Chapter 6, we’ll show you how you can use a service definition to
define the scope of an Open Data Protocol (OData) service for a
business object. We’ll also explore how to use service binding to
define the protocol of the service.
Chapter 7 focuses on the user interface of your applications. In this
chapter, we won't discuss all the features of SAP Fiori, but we’ll
show how you can generate simple interfaces with SAP Fiori
elements and how to configure them with annotations. This helps lay
the foundation for the practical chapters in Part II.
In Part II, various ABAP RESTful application programming model
development scenarios are illustrated with concrete examples.
First, in Chapter 8, we’ll look at the different use cases of the
programming model in ABAP development, and discuss the
suitability of the scenarios in each context. The chapter will address
when to use each implementation type.
You’ll then create your first application based on the ABAP RESTful
application programming model in Chapter 9. This is a completely
independent application without reference to the SAP standard. The

focus here is on implementing the managed scenario. The
application will be extended with actions, validations, and
investigations as part of behavior definition and implementation.
In Chapter 10, we’ll also deal with the managed scenario, but
implement our own update logic—called a managed scenario with
unmanaged save. Topics such as numbering or the implementation
of the save sequence are central here. The aim of this second
application is to integrate standard SAP functions into in-house
developments.
Chapter 11 covers the unmanaged scenario and is based on an
existing custom application that is mapped using the ABAP RESTful
application programming model. In this chapter, a key point is the
implementation of the interaction phase since this isn’t provided by
the programming model in the unmanaged scenario (unlike the
managed scenario).
In Chapter 12, you’ll learn about the SAP BTP, ABAP environment.
We’ll highlight the differences between ABAP development in the
cloud and on-premise. You’ll also learn how you can adapt
applications created with the ABAP RESTful application
programming model to the technical conditions of the SAP BTP,
ABAP environment.
Chapter 13, takes a brief look at the future, planned development of
the programming model, for example, in terms of extensibility,
integration, and reusability, as well as the role of the model in the
SAP S/4HANA Cloud environment.
The note boxes in this book highlight useful information that is good
to know, but is outside the scope of this book:
Note boxes refer to additional topics.

Warning boxes refers to specific information that you should
consider. They also warn you about frequent errors or problems
that can occur.
Tip boxes provide specific tips that can help make your work
easier.
Example boxes refer to real-life scenarios and illustrate the
described functions.
Acknowledgements
We would like to thank All for One Group SE for their kind support
and provision of infrastructure. Without them, this book would not
have been possible. In particular, we would like to thank Lars Woll
and Andreas Klose.
A special thanks to our colleagues at SAP for their active support
and constructive feedback. In particular, we would like to thank
Marcel Hermanns and Volker Drees.
Also, many thanks to Janina Schweitzer of SAP PRESS for
supporting us during the editing process.
Michael Lensch would like to thank to his wife, Stefanie, and their
son, Paul, for their support and understanding while he dedicated
countless hours, including many weekends, to this book.
Matthias Jäger would like to thank his partner, Andrea, and his two
children, Emilia and Clemens, who patiently and supportively gave
him space and time to write this book.
We hope that this book will serve as a useful reference guide for
developing applications based on the ABAP RESTful application

programming model and will help you get started with the new
programming model. Have fun reading!
Lutz Baumbusch, Matthias Jäger, and Michael Lensch

Part I
Basic Concepts and Technical Components

1    Introduction
This introductory chapter provides an overview of the ABAP
RESTful application programming model. You’ll learn about the
model’s origin, features, architecture, basic elements, and
technical availability.
This chapter introduces the ABAP RESTful application programming
model. You’ll learn what the programming model is and understand
its basic technical features.
In Section 1.1, we’ll review the Representational State Transfer
(REST) architectural style and its principles, and explain why the
programming model is called RESTful. You’ll also learn which
existing ABAP technologies are reflected in the ABAP RESTful
application programming model and how they influence the
programming model.
Section 1.2 describes the basic architectural concepts of the
programming model before we discuss the relevant artifacts and
their capabilities in Section 1.3. In Section 1.4, we’ll take a first look
at the development environment you’ll be using to develop
applications with the ABAP RESTful application programming model.
The REST architecture and the basic concepts of the programming
model give rise to the essential qualitative properties of the
programming model. We’ll discuss those properties in Section 1.5.
To conclude this introduction, in Section 1.6, we’ll place the ABAP

RESTful application programming model in the context of SAP
products, which is the basis for its technical availability.
[»]  RAP as an Abbreviation
You’ll frequently come across the abbreviation, RAP, used for the
ABAP RESTful application programming model. Even though it’s
not an official or approved abbreviation, it has become
commonplace in the developer community.
In this book, we generally use the complete term ABAP RESTful
application programming model. Where using the complete term
might make sentences more difficult to read, we have opted for the
abbreviation RAP. In this book RAP always means ABAP RESTful
application programming model.
1.1    What is the ABAP RESTful Application
Programming Model?
In this section, we’ll first explain what a programming model is. Then,
we’ll describe the essential features of the ABAP RESTful
application programming model, look at the REST architectural style
that serves as the basis for the programming model, and explain the
role of OData in the context of the programming model. We’ll explain
the interaction of the ABAP RESTful application programming model
with the main technological innovations of SAP S/4HANA and then
illustrate the historical development of ABAP-based programming
models.
1.1.1    The Purpose of the Programming Model

The ABAP RESTful application programming model is a new way to
develop enterprise applications on the ABAP platform. The
programming model includes all application development steps and
elements: the data model; operations (e.g., creating, reading,
changing, or deleting business objects); business logic (e.g.,
calculations or checks); transactional behavior (e.g., locking
behavior, numbering, etc.); and technical interface (typically, OData).
Regardless of the technology, a programming model describes how
an application developer builds, tests, and troubleshoots applications
based on a particular software architecture. A programming model
provides certain technologies, concepts, artifacts (referred to as
development objects in ABAP), and tools. A defined development
flow brings these components together.
When it comes to the ABAP platform, a programming model must
answer the following questions:
Which development objects are used to implement a specific
application or functionality, and what are the tasks of these
development objects?
How are these development objects related to and how do they
build on each other (i.e., what are the dependencies between the
development objects)?
Which application programming interfaces (APIs) are available to
help implement the typical requirements and functionalities of an
application?
With APIs, it’s useful to distinguish between two different types:
Which APIs are made available to the application for direct calls in
order to implement specific functions? These APIs are referred to
as library-based APIs, as they’re provided via libraries.

Which APIs are implemented by the application so that they are
called at defined processing times from the outside (i.e., from the
framework that implements the control flow)? These APIs are
called framework-based interfaces.
A programming model thus includes the ingredients for application
development and concrete recipe suggestions. It describes how you
can use these ingredients for specific purposes, and also how to
combine them.
Properties of the Programming Model
In the following sections, we’ll describe some features of the ABAP
RESTful application programming model and requirements for this
programming model that are of strategic importance for SAP
application development.
The ABAP RESTful application programming model is designed to
be a long-term, sustainable solution for implementing business
applications on the ABAP platform. You can use this programming
model to develop completely new business applications (greenfield
development) and to integrate existing business applications, i.e.,
encapsulate them in the ABAP RESTful application programming
model (integration of legacy code or brownfield development).
Existing applications interconnected this way benefit just as much as
newly-developed applications from the qualitative properties of the
programming model. We’ll discuss the aspect of evolvability (i.e., the
adaptability of the programming model to changing conditions such
as technological changes) and, consequently, the adaptability of
RAP applications in Section 1.5.1.
The REST architectural style is directly reflected in the name of the
programming model. When you implement enterprise applications

with the ABAP RESTful application programming model, this
automatically results in APIs and applications that are REST-based
and follow the design principles of the REST architectural style. The
ABAP RESTful application programming model is based on a
stateless web server as part of the ABAP platform that provides
REST-based APIs. In this context, the application state can be kept
on the client or persistently on the server side in the database, but
not within the context of an ABAP session, as is the case with classic
applications on SAP NetWeaver Application Server for ABAP (SAP
NetWeaver AS ABAP).
To keep the application state persistent on the database, you can
use the draft handling feature in the ABAP RESTful application
programming model. Application data can be stored persistently in
the database a in draft mode for a user. The maintenance of the data
can then be continued at a later time or from another terminal
device. In this way, scalability and load balancing can be leveraged
within a cloud environment, since API requests sent to a RAP
application can be processed independently of each other and
therefore by different application servers. We’ll describe this
stateless communication between the client and server, and other
details about the REST architectural style in Section 1.1.2.
Standard Architecture of Business Applications
The ABAP RESTful application programming model defines a
standard business application architecture and sets development
guidelines so that this standard architecture can be implemented
consistently. This results in a standardized development flow for the
business application, up to the provisioning of web-based APIs for
accessing business data. Based on this standard architecture, for
example, modern user interfaces (UIs) can be implemented or a web

API can be provided as a technical interface for integration
purposes.
The standardization is reflected in the ABAP RESTful application
programming model with the following features:
Defined development flow
The programming model provides development objects in the
ABAP repository for various aspects of application development.
For data modeling, you can use the ABAP dictionary (DDIC) and
core data services (CDS) that are based on the ABAP dictionary.
You can add a behavioral definition to the entities defined with
CDS, to implement transactional properties and business logic.
You can formulate ABAP code in the behavior implementation that
matches the behavior definition. Finally, business services expose
the application's entities and their business logic as external
(OData) interfaces. We’ll describe all the development objects
mentioned in this flow in more detail in Section 1.3.
Support for technical aspects
By default, the programming model takes into account various
technical aspects that are typical of enterprise applications. These
include, for example, the implementation of standard operations
such as the creation (create), reading (read), update (update), or
deletion (delete) of business objects within a logical transaction
and the persistence of transactional data (these are known as
CRUD operations). Numbering, persistence, locking behavior,
draft handling, or the installation of authorization checks are also
supported by the programming model. The programming model
provides ready-made implementations (e.g., for CRUD operations
or for the draft handling function). You can thus focus your
attention on developing business logic and business rules and will
no longer need to worry about the typical cross-cutting issues of

application development. We’ll describe this development
efficiency in more detail in Section 1.5.2.
Defined program flow for processing business operations
The runtime environment of the programming model already
defines a suitable program flow for the operations of an
application (such as creating a purchase order or cancelling a
sales order), so you don’t need to be concerned about this
program flow. There are clearly defined points in time at which you
can use your own ABAP coding to link into the program flow (via
framework-based interfaces), for example, to implement
numbering or an authorization check.
Declarative, model-based approach
The programming model follows a model-based approach. This
means that the programming model provides specific languages
tailored to an application purpose (domain-specific languages
[DSL]). These are distinct from general programming languages.
A good programming model guides the application architect or
developer so it’s easy for them to follow the model and use it “in
the spirit of the inventor.” This is achieved through a declarative,
model-based approach.
Table 1.1 contains a list of all the DSLs that are relevant to the ABAP
RESTful application programming model. For example, CDS
(introduced with SAP NetWeaver 7.40) provides a data definition
language (DDL) that you can use to define the semantic data models
of an application. A data model defined this way can be exposed
directly as the data model of an OData service or serves as an API
to read the entities of an application. If the CDS data model is
expanded to include RAP behavior, this behavior can also be
exposed to OData or can be called internally. The ABAP RESTful
application programming model can thus derive technical information

(e.g., the OData interface, internal interfaces, data types, etc.) from
the models of the application.
Language Name
DDL
Data definition language
DDLA
Data definition language annotations
DCL
Data control language
BDL
Behavior definition language
SDL
Service definition language
Table 1.1     Domain-Specific Languages in the ABAP RESTful Application Programming
Model
Support of SAP Product Features
The ABAP RESTful application programming model is designed to
support existing SAP technologies and product features, including:
SAP Fiori user experience
The programming model allows you to develop applications with
an OData-based interface that seamlessly integrates with an SAP
Fiori UI. Such interfaces can be implemented with SAP Fiori
elements. A preview function is available in the development
environment for applications based on this framework.
SAP HANA database capabilities
The programming model uses CDS as the base technology for the
data model of a business application. This enables code
pushdown to the SAP HANA database from within the ABAP
development context. This means that computations can be
performed directly on the SAP HANA database layer.

Cloud Readiness
Applications developed with the programming model are RESTful,
which means they provide stateless APIs. A server-side
application state is not maintained. The resulting scalability makes
it possible to use the ABAP RESTful application programming
model in cloud environments, too. It’s therefore also available with
SAP S/4HANA Cloud.
The cloud operating model also requires that applications or their
interfaces remain stable across software updates. With the
extension concept built into the ABAP RESTful application
programming model, RAP applications can be extended without
modification, which supports update stability.
1.1.2    The REST Architectural Style
The REST architectural style dates back to Roy Fielding's doctoral
thesis, written in 2000. REST describes the architecture of the World
Wide Web (WWW) and defined the guidelines for its design and
evolution.
In theory, the architectural style is independent of the implementation
by concrete technologies. For practical reasons, however, we’ll
immediately place the basic REST principles and architecture
elements in the context of the software building blocks and
standards underlying the WWW. However, before that, we’ll describe
the essential elements of the WWW. If you’re already familiar with
this, you can proceed directly to learning about REST architecture
principles.
World Wide Web

Via the WWW, web content or resources, such as HTML files, image
files, or program scripts, are made available globally in a distributed
manner. These resources are provided by a HTTP server and can be
requested via a HTTP client such as a web browser. The
communication protocol for requesting and transferring resources
between the client and server is referred to as the hypertext transfer
protocol (HTTP).
[»]  Resources
Resources are not necessarily always actual files, such as HTML
pages, scripts or image files. Resources can also involve elements
that are kept in a database, such as a sales order with the number
123.
A resource is uniquely identifiable and retrievable via its web
address. The web address is also referred to as a uniform resource
locator (URL). A URL describes the location of a resource on a
network. A URL is a real use case of a unified resource identifier
(URI). The URI standard specifies the structure and syntax of web
addresses.
The HTTP client uses the URL to request a resource on the HTTP
server. The client's request is called the HTTP request, and the
server's response is the HTTP response, which is transmitted with
an HTTP status code (e.g., 200 OK if processing is successful). The
HTTP request and HTTP response are HTTP messages that can
store application data in their HTTP body.
The HTTP method (also called HTTP verb) is an essential part of an
HTTP request and is used by an HTTP client to specify the nature of
its request to the HTTP server. The most common HTTP method is
the GET method, which is used to request a resource. For example,

the HTTP request GET www.sap.com HTTP/1.1 returns the SAP
homepage.
The server responds with the HTTP request in the HTTP body of
which the resource representation is transmitted. This representation
consists of text-based or binary data representing the resource in
question. These are described in more detail by metadata. For
example, the media or content type is specified. This allows the
receiver of the request to process this request in a suitable way. For
example, the content type for HTML content is text/html, for XML
content it’s text/xml, and for JSON content it’s application/json.
[»]  Representations for Write Access
Representations can also be transferred from an HTTP client to an
HTTP server, for example, if the resource “business partner
master with customer number 123” is changed by a user via the
web browser and these changes are transferred to the web server
in JSON format. Representations are thus used for read and write
purposes.
Not only are URLs used to request resources, but they can
themselves be a content component of the representation of a
resource. For example, an HTML page with hyperlinks (or links) can
refer to other HTML pages or to the image files embedded on the
HTML page. A hyperlink serves as information for an HTTP client,
such as a web browser, on how to request the additional HTML page
or image file.
REST Architecture Principles

The REST architectural style describes technical requirements for
the building blocks or the restrictions of a hypertext-based software
system. It also describes the interaction between the building blocks.
Since REST and the WWW are closely related, we place the
technical requirements that we discuss next in the context of the
WWW.
There are system modules that interact with each other as a client or
as a server. Servers provide services that can be used by clients. In
business application systems, server components typically provide
software to map business processes (i.e., the business logic). For
example, client modules can provide the UI, request business data
from the server, and display the server's response, such as a
request for sales orders, on the UI. For this purpose, the REST
architecture style uses the infrastructure of the WWW. HTTP clients
or HTTP servers are the basic building blocks of a client/server
architecture.
The communication between client and server modules is stateless
(i.e., each request sent from the client to the server is independent of
previously executed requests). Accordingly, the client request must
be self-contained and complete in order for the server to understand
and process the request. The client can’t assume that context
information is kept on the server across different requests.
HTTP is a stateless request-response-based protocol. Different
HTTP requests aren’t related to each other in terms of content for
the HTTP server, so the server doesn’t store any context information
(the so-called state) about the requests. For this reason, the
communication is referred to as stateless.
[eg]  Example: Complete Representation of a Resource

For example, a REST request formulated via HTTP to create a
sales order sends the full representation of that resource via the
JSON content. That is, the entire sales order data must be
included in the request for the REST-compliant server to process
it.
In classic web applications it’s possible to keep the session state on
the HTTP server via a session ID. The session ID can be mapped as
a cookie or URL parameter within a HTTP request. This way,
multiple HTTP requests with a session ID can refer to one session
state. This allows stateful communication between the client and
server to be implemented at the application level. However, this
implementation is not REST-compliant.
In communication between the client and server, a server response
(i.e., a representation) can be buffered to reduce the general network
load or to reduce response times. Representations are provided with
metadata that refers to the buffering and defines the validity period of
the buffer. If a server representation is bufferable, the buffered
representation can be used as a result for similar client requests
instead of making a new request to the original server.
The layering of systems means that client and server components
can be located in different layers, but should only interact with the
next layer. Thus, the client doesn’t need to know whether a response
originates from the original server or from a server in a middle layer.
On the WWW, a request from an HTTP client takes several technical
paths to the original server. In the process, servers can be
interposed to act as a proxy (i.e., servers accept and forward the
request to the requested HTTP server).
Client and server modules interact on the basis of a uniform
interface. Here, a uniform interface means that the interface between

the client and server is standardized across applications and is
therefore independent of the specific (operational) application. The
server provides a service by implementing the interface, and the
client consumes that service through the interface. Due to the
separation of the interface and implementation, the client and server
are decoupled from each other (both “know” only the interface) and
can thus be implemented in different programming languages and
runtime environments.
A unified REST-based interface specifies the following:
Identification of resources
Manipulation of resources (i.e., write access) that is performed via
a representation of the resource
Self-describing messages
Hypermedia as the Engine of Application State (HATEOS)
HATEOS refers to the mechanism a client uses to navigate to or
manipulate other resources via links with the corresponding URL
within the representations of resources. The client only needs to
know the links and their types in order to interact with the server. The
specific URL doesn’t need to be known to the client, since it’s part of
the representation returned by the server. This representation is the
application state.
[eg]  Example: To Query Sales Order Items
For example, the JSON representation of a sales order entity can
provide a link through which all entries of the sales order item
entity can be found for the specific sales order with the number
123. A GET request of this URL will then return all sales order items
for sales order 123. It also includes other links, for example, to

navigate to a specific sales order item 10. In this way, a network of
links is formed, which a client can use on the basis of the uniformly
defined interface.
If required, a client component can be extended with program code
that’s kept on the server. This property is optional in the REST
architectural style.
If the technical requirements and restrictions defined in the REST
architectural style are met, we speak of a REST-compliant software
architecture. Since the technical implementation of enterprise
applications can take place on different platforms and with different
programming languages, a key focus should be on ensuring that this
application provides REST-compliant or REST-based interfaces
(RESTful APIs). For this reason, the following sections discuss the
essential features of a REST-based interface and outline its typical
functionality in more detail.
RESTful APIs
The REST-based architecture of a software application follows the
architectural principles described in the previous section (for
example, uses the technical infrastructure of the WWW and exposes
REST-based APIs that can be consumed by a web interface).
One of the requirements for REST is the use of a standardized
interface. We refer to this requirement next and explain the means
by which a REST-based API is typically implemented. You can, for
example, specify the following:
HTTP methods are used to implement standard operations for the
entities that model an enterprise application. Such operations can
involve both read and write access.

The body of HTTP messages is used to transfer the
representations of resources between the client and server; that
is, to realize read and write access to entities.
The content type (in the HTTP header or body) is used to specify
the format of this representation.
Status codes matching the HTTP method are returned in the
HTTP response.
Other HTTP headers are used, for example, to deal with
concurrent accesses to business objects. As an example, you can
consider the ETag procedure, an implementation of the optimistic
locking procedure.
Links are used in the exchanged representations of resources to
reference other resources, thus providing URLs that allow the
client to read or modify the resource.
The following section lists and describes all the relevant HTTP
methods. Their use is part of implementing the REST architecture
principle of using a standardized interface.
GET
The GET method requests one or more resources. A HTTP GET
request implements a read access, which must be fully
implemented without side effects. If processing is successful, the
response returns the status code 200 OK. If the resource can’t be
found, status code 404 Not found will be returned.
POST
A HTTP POST request creates a new resource. Upon successful
processing, the response ideally returns the status code 201
Created. However, 200 OK or 204 No content are also common.

PUT
A HTTP PUT request modifies an existing resource. If processing is
successful, the response returns the status code 200 OK or 204 No
content.
DELETE
A HTTP DELETE request deletes an existing resource. If processing
is successful, the response returns the status code 200 OK or 204
No content.
PATCH
A HTTP PATCH request modifies a selection of attributes of an
existing resource. If processing is successful, the response
returns the status code 200 OK or 204 No content. The PATCH
request can be distinguished from a PUT request as follows: Unlike
PATCH, PUT completely replaces a resource with the submitted
representation.
1.1.3    OData
The Open Data Protocol (OData) is a specification of a REST-
compliant API based on HTTP. As an open standard, it’s managed
by the OASIS consortium. An OData service exposes application
data for read and/or write access by a consumer. The OData
protocol defines the communication between the consumer and the
OData service.
OData defines, for example, that an OData service has a data model
and how that model is constructed. In such a data model, the entities
(EntityType) are described with their attributes (Property) and
associations (Association, NavigationProperty).

The data model of an OData service is provided via the service
metadata document. Figure 1.1 shows an example of a service
metadata document from the new ABAP flight data model, the ABAP
flight reference scenario. Here, TravelType is an entity defined in the
data model.
Figure 1.1     Example of an OData Service Metadata Document
Furthermore, each OData service returns a service document that
provides all exposed entity sets (EntitySet), with the standard
operations valid for it. The service document serves as an entry point
to the resources provided through the links listed in it. Figure 1.2
shows an example of a service document from the ABAP flight
reference scenario. Travel is an entity set made available through
the service.
Figure 1.2     Example of an OData Service Document
OData further specifies the way in which the elements of HTTP (e.g.,
HTTP request, response, status codes, etc.) are used to provide

data, CRUD operations, and other nonstandard operations to an
application via an OData service. For example, there are URL
conventions for identifying, querying, and manipulating resources, or
for displaying representations within the HTTP message. The
conventions defined by OData also include a rich set of query
options for business data (e.g., filtering, projecting, sorting, browsing,
etc.) or handling binary data (media link entries) via the elements of
HTTP.
While OData in itself specifies a wealth of functionality a consumer
can use to access an application, OData vocabularies make it
possible to enrich the data model of an OData service with specific
concepts. These concepts typically map cross-application
functionality, such as analytics procedures or the output of data on a
UI. Annotations exposed via an OData service are used in the
application to enrich elements of the data model with additional
information. For example, they can be evaluated by the UI.
For example, in the UI domain, there might be the concept of the
title, represented as an annotation. In an HR management
application, you could, for example, add a “title” annotation to the
“person” EntityType, stating that the UI title is composed of the
LastName and FirstName properties. A UI component of a web
interface can evaluate this annotation at runtime and generate a UI
title that outputs the current values for first name and last name of a
person instance.
In the following sections, we present some important OData queries.
Since OData is based on HTTP, an OData service is accessible
through an HTTP endpoint. This endpoint is also referred to as the
service URL and serves as the entry point to the OData service. The
service URL enables you to access the already mentioned service
document.

To outline the main OData requests in the following, we use an
OData service from the ABAP flight reference scenario that has been
exposed to the ABAP RESTful application programming model via
business services (see also Section 1.3.5). The associated HTTP
endpoint is /sap/opu/odata/DMO/UI_TRAVEL_PROC_M_O2/. For
information on the HTTP methods used, Section 1.1.2.
If you want to query the data model of an OData service, you must
use an HTTP GET request GET /<service-url>/$metadata (for
example, GET /sap/opu/odata/DMO/UI_TRAVEL_PROC_M_O2/$metadata).
If you want to query a specific entry, such as a specific trip, you can
use HTTP GET, too. The request GET
/.../DMO/UI_TRAVEL_PROC_M_O2/Travel('1') reads a travel resource
with the key 1. If you want to create a new entry, OData provides
HTTP POST. HTTP PUT is used for changes and HTTP DELETE to
delete an entry.
For detailed information on URL conventions, query options, and
other aspects of the OData protocol, go to https://www.odata.org.
[+]  Tip: Navigating to the Service URL
If you want to reproduce the examples in this section within a web
browser, open the service binding /DMO/UI_TRAVEL_PROC_M_O2 in the
ABAP development tools (ADT) and navigate to the HTTP
endpoint of the OData service by clicking Service URL. Host
name and port are added, and the service document opens in the
web browser. In the browser, you can read the service document
or the service metadata document and perform other reading
operations. For more information on service binding, see
Chapter 6, Section 6.3.

[+]  Tip: Trying out RESTful
The web address https://api.sap.com allows you to access the
SAP API Business Hub, where SAP provides the available remote
APIs of its products. There you can view the APIs and also try
them out. The OData-based Business Partner API from SAP
S/4HANA Cloud is a good example.
1.1.4    Technological Innovations with SAP S/4HANA
SAP S/4HANA is the successor to SAP ERP and the latest, modern
standard business software from SAP. With SAP S/4HANA,
fundamental technological changes have been made to the ABAP
platform that will have a far-reaching impact on how you customize
and extend applications or create entirely new applications. These
changes affect all technical software layers:
SAP HANA database
CDS and virtual data model
SAP Gateway and OData
SAP Fiori user experience (UX) with the SAP Fiori launchpad and
the SAPUI5 framework
With SAP HANA, an in-memory database technology has entered
the environment of SAP's business software. The SAP HANA
database keeps datasets mostly in the main memory of the database
server, depending on their access category. To increase the access
speed of read accesses and reduce the memory requirements in the
main memory, data sets are stored in a column-oriented manner in
the column store and automatically indexed.

With the introduction of CDS, you have the option of a code
pushdown into the SAP HANA database. Calculations can be
performed directly where the data resides (i.e., on the database
server). The respective data no longer needs to be loaded into the
main memory of the application server first. CDS also allows you to
define a semantic data model of your application based on database
tables. You can integrate the CDS entities at various points in the
application. The semantic data model of SAP S/4HANA modeled
with CDS is referred to as a virtual data model (VDM).
OData allows an application to provide REST-compliant APIs in a
consistent manner. As described in Section 1.1.3, OData uses open
standards, such as HTTP, XML or JSON. SAP Gateway is a product
that links the ABAP world with the OData protocol. During
development you can implement read or write access to application
data using the functions of SAP Gateway without having to know the
details of the OData protocol. SAP Gateway also provides features
to integrate CDS functionalities and expose OData services on this
basis.
With SAP S/4HANA, the UI and the entire look-and-feel (i.e., the
user experience (UX)) of the SAP system has been further
developed. Role-based applications are replacing transaction-based
applications. They focus on the user's particular task by tailoring the
selection of visible fields and dialogue steps to that task. SAP Fiori
apps are modern, browser-based applications that are
technologically implemented by the SAPUI5 framework. They also
meet the requirements of the SAP Fiori design guidelines.
All SAP Fiori apps available to a user are displayed as tiles in the
SAP Fiori launchpad. SAP Fiori apps or SAPUI5 apps are designed
to read data from the backend via the OData protocol and to write
data back to the backend via this protocol. For this reason, they

usually communicate with SAP Gateway to access application
functionality.
1.1.5    Evolution of ABAP-Based Programming Models
To better understand innovations in the ABAP RESTful application
programming model, it’s useful to know the technological influences
and historical developments in the ABAP environment. Thus, in this
section we’ll review the history of the programming model and
introduce predecessor technologies that have a significant impact on
its components.
We’ll describe the following programming models and technologies:
Classical application development with ABAP
Business Object Processing Framework (BOPF)
ABAP programming model for SAP Fiori
In Figure 1.3 you can see, from left to right, the chronological
sequence of ABAP-based programming models up to the
introduction of the ABAP RESTful application programming model.
BOPF isn’t listed as a separate programming model, but is used, for
example, in the programming model for SAP Fiori. Since important
concepts are anchored in it, we nevertheless briefly introduce this
framework in the following sections.

Figure 1.3     Evolution of ABAP-Based Programming Models (Source: SAP)
Classical Application Development with ABAP
Originally derived from SAP R/3, the SAP NetWeaver Application
Server for ABAP (often referred to as the ABAP stack), is the central
technological runtime environment for ABAP-based applications. The
application server is a product independent of the respective
application and centrally provides technical services for application
development, such as UI technologies, interface technologies,
libraries, and components for print output, background processing,
and processing of business rules.
The classical programming model for ABAP is based on the
following elements:
Data modeling with the ABAP dictionary
The ABAP dictionary enables you to create global data types,
such as data elements, structures, and database tables. SAP
NetWeaver Application Server for ABAP 7.40 Support Package 5
(SP05), introduced the CDS technology, which can be used to
develop semantic data models based on the ABAP dictionary.
Business logic development and encapsulation
In ABAP, you can use various modularization units, such as form

routines, function modules, classes, and interfaces to encapsulate
program logic. We recommend using classes or interfaces as a
means of object orientation for the modularization of an
application. The ABAP RESTful application programming model
uses only classes and interfaces.
UI development (SAP GUI-based or web-based)
The ABAP stack provides various technical options for
implementing UIs. Classically, for example, SAP GUI-based UIs
can be created using the Dynpro technology. Web-based UIs can
be implemented using the technologies Business Server Pages
(BSP), Web Dynpro ABAP or the Floorplan Manager for Web
Dynpro ABAP. In rare cases, SAPUI5 interfaces are already used
with the classical programming model.
Interface development
Furthermore, the ABAP stack provides various technologies for
integrating applications: IDoc, SOAP, RFC, HTTP and SMTP.
These technologies are supported from both a consumer and
provider perspective. SAP Gateway, as an implementation of the
OData protocol, has been an integral part of the SAP NetWeaver
Application Server for ABAP since version 7.40.
With SAP NetWeaver Application Server for ABAP 7.40, an
important new functionality has entered the ABAP language scope
that is particularly useful for application development with the ABAP
RESTful application programming model. These changes include
constructor and table expressions (from versions 7.40 SP02, 7.40
SP05, and SP08). Constructor and table expressions allow you to
conveniently provide data objects with values. In the context of the
ABAP RESTful application programming model, you can make the
behavior implementation and handling of the entity manipulation
language (EML) much easier. The new ABAP keywords VALUE,

CORRESPONDING, FOR, COND, etc. are particularly noteworthy in this
context.
Business Object Processing Framework
While the ABAP stack provides technologies and infrastructure that
affect the periphery of the application (e.g., UI, interfaces,
persistence, etc.), the Business Object Processing Framework
(BOPF) was the first framework to support the direct implementation
of the business core of an application. BOPF is based on ABAP
objects. In its capacity as a framework, it defines the control flow of
business logic processing. An ABAP application implements certain
BOPF interfaces and thus hooks into this control flow.
Some key elements of BOPF are:
Business objects
They are hierarchically structured in nodes with (key) attributes.
Business logic
The application logic is implemented in the form of validations,
determinations and actions.
Business object API
This API is used for multi-instance implementation of business
objects and their internal business logic. Consumers aren’t aware
of the business object API, but access it through the consumer
API.
Consumer API 
This API enables consumers (e.g., ABAP source code in the
context of a UI or a background job) to use business object
functionality.

You’ll find many of these concepts in the ABAP RESTful application
programming model, even if they’ve been technically implemented
differently there. In the ABAP RESTful application programming
model, the processing of operations and business logic is merged
into the ABAP core; that is, it’s implemented using special ABAP
keywords that are executed by the ABAP runtime environment. You
may be familiar with this type of integration in the ABAP core from
the Business Add-Ins (BAdIs) enhancement technique. Initially, the
BAdI framework was implemented in ABAP objects (like BOPF). In
the enhancement framework introduced later, the BAdIs then
entered the ABAP core as kernel-based BAdIs.
[»]  Availability of Business Object Processing Framework
BOPF is available for use with SAP NetWeaver Application Server
for ABAP 7.40.
The ABAP Programming Model for SAP Fiori
The ABAP programming model for SAP Fiori was created in
response to the technological innovations related to SAP S/4HANA
from a development perspective. It uses technologies, such as CDS,
BOPF, and SAP Gateway, and is available with ABAP stack 7.50—
even if you are not yet using a SAP S/4HANA system. In version
7.50 SP01, the draft handling function was added.
Essential elements of this programming model include:
Data modeling with CDS
CDS is used to define the data model of the application. CDS
entities can then be exposed as OData services to provide read
access to the respective application data. To access native SAP

HANA functionality in ABAP programs (code pushdown), CDS
table functions, ABAP-managed database procedures (AMDP),
and SQLScript are available.
Transactional behavior with BOPF
Using a lightweight CDS-based variant of BOPF, you can add
transactional behavior to CDS entities.
SAP Gateway
OData-based interfaces are provided via SAP Gateway. The
central transaction in this context is SEGW, which you can use to
connect the ABAP world with OData and, for example, provide
CDS entities as referenced data sources. SAP Gateway can be
installed on its own ABAP stack (in this case, it’s called a hub
deployment) or on the same stack as the respective SAP
Business Suite or SAP S/4HANA application (embedded
deployment).
SAPUI5 and SAP Fiori
UIs are developed using SAPUI5 or SAP Fiori elements. With
SAPUI5, interfaces can be freely designed, while SAP Fiori
elements provides templates for specific use cases. The
applications are typically made available to users via the SAP Fiori
launchpad. UI annotations, which are stored via CDS or directly in
the SAPUI5 application, define the layout and behavior of the UI
as metadata.
The interaction of these components is illustrated in Figure 1.4. SAP
Gateway can communicate locally with the ABAP backend as an
integral part of the ABAP stack, since both components run on one
application server. Basically, SAP Gateway can also run on its own
ABAP stack, which then acts as a frontend server and
communicates with the ABAP backend via remote function call
(RFC).

Figure 1.4     ABAP Programming Model for SAP Fiori
[»]  Migrating the CDS-Based BOPF Objects to the ABAP
RESTful Application Programming Model
Currently, SAP is developing a tool to migrate the CDS-based
BOPF objects created in the context of the ABAP programming
model for SAP Fiori. In the future, you can use a BOPF-managed
implementation for this purpose (“BOPF-managed” implementation
type).

1.2    Architecture and Concepts
In this section, we’ll go into more detail about the main architecture-
relevant concepts of the ABAP RESTful application programming
model. This includes the technical components in which a RAP
application is embedded at runtime.
1.2.1    Transaction Model
The RAP transaction model distinguishes between two phases in the
processing of operations on business objects:
1. During the interaction phase, operations are performed on a
business object instance (e.g., a position is created or changed).
As a result of these operations, instances of the respective CDS
entities are stored in the transaction buffer.
2. The subsequent save sequence is triggered by a commit. The
state of the transaction buffer is persistently written to the
database. The state of the transaction buffer isn’t kept across
multiple requests, as this would violate a key REST principle
(Section 1.1.2). The CDS entity instances that are stored in the
transaction buffer, which have been created, modified, or
deleted (modify), can be considered a logical unit of work (LUW)
within the SAP system. As part of the save sequence, the LUW
is persistently written to the database within a database LUW.
The draft handling in the ABAP RESTful application programming
model allows to temporarily store the state of the transaction buffer
with inconsistent application data persistently on the database. This
enables you to distribute the interaction phase across multiple

standalone requests or user sessions without violating the REST
principles of stateless communication. Users can continue their work
at a later point in time, regardless of the terminal device. The draft
handling functionality is fully implemented by the RAP runtime.
[»]  Can the ABAP RESTful Application Programming Model
Also Be Stateful?
Basically, the ABAP RESTful application programming model
doesn’t preclude the implementation of a stateful application. The
RAP transaction model technically includes an area (the
transaction buffer) where the application state can be stored on
the server side. However, in this book we’ll focus on REST-based
applications.
1.2.2    Implementation Types
The ABAP RESTful application programming model includes the
concept of the implementation type, which you use to specify who
provides the implementation of reading functionality (query) and
transactional or writing functionality (behavior). There are two
implementation types: managed and unmanaged. In the managed case,
the programming model provides the desired functionality; in the
unmanaged case, the application must do this by itself.
The technical implementation of read and write access or the
behavior of a business object is handled by the business object
provider. When implementing the business object, we distinguish
between the use of the managed scenario and the unmanaged
scenario:

Managed scenario 
In the managed scenario, you use a ready-made implementation
of the business object provided by the ABAP RESTful application
programming model, the managed business object provider. It
implements the standard CRUD operations for creating (create),
reading (read), updating (update), and deleting (delete) instances
of the respective CDS entity during the interaction phase and the
save sequence. This is also accompanied by the handling of the
transaction buffer. 
When using the managed scenario, an already executable
business object that supports CRUD operations is available to you
without any programming effort on your part. Optionally, you can
add more logic to the save sequence (additional save) or
implement it yourself (unmanaged save).
Unmanaged scenario 
In the unmanaged scenario, you can implement the standard
functionality of a business object by yourself. This involves the
interaction phase with the transaction buffer and the save
sequence. This gives you the option of integrating the API of an
existing application and wrapping it with RAP resources. This
scenario is therefore often used for brownfield development.
In addition to the use cases that can be implemented by these
implementation types, there are always very specific business
requirements (e.g., the validation of a certain data constellation or
the calculation of certain values of a business object instance). In
these cases, the business object provider can’t provide an
implementation. However, in both the managed and unmanaged
scenarios, you can implement the respective business logic yourself.
We’ll demonstrate this in Chapter 9, Section 9.6 and Section 9.7.

Read accesses are referred to as queries in the ABAP RESTful
application programming model. They can be implemented without
transactional behavior or associated write accesses. A managed
implementation of this type of read access is called a managed
query, and an unmanaged implementation is called an unmanaged
query. Via the managed query, the programming model provides the
standard functions for reading business data from the underlying
database. This also includes, for example, functions for sorting,
filtering, or aggregating the read data. If you implement an
unmanaged query, you can implement these functions yourself and
thus have the option of including any data source in the
programming model (e.g., via remote call of APIs), or bridging
differences between the data model of the data source and that of
the business object in the ABAP RESTful application programming
model.
1.2.3    Entity Manipulation Language
The entity manipulation language (EML) is a standardized, type-safe
API used to access the data and functionality of a business object.
It’s an integral part of the ABAP language scope. Using EML, you
can access instances of a business object in write mode (via the
ABAP statement MODIFY ENTITIES), but you can also read individual
instances from the transaction buffer (via READ ENTITIES).
EML plays a major role within the ABAP RESTful application
programming model in the following use cases:
Implementing the behavior of a business object
You can use EML statements to implement the behavior of a
business object in ABAP. In this case, your application assumes
the role of a business object provider.

Performing operations on a business object
You need EML statements if you program an ABAP application
that accesses the functionality of a business object as a consumer
(i.e., assumes the role of the business object consumer). It’s also
possible to use EML in the context of unit tests to check the
functionality of a business object in your application.
When you use EML within the business object provider, for example,
to read data for validation, you also use the EML in the business
object consumer role. You use it to read data about the business
object from the transaction buffer to validate it, bypassing
authorization checks, for example, because the access is IN LOCAL
MODE. You thus consume the read or write functionality of your own
business object. In addition to read and write operations, you can
also use EML to define transaction boundaries (COMMIT and ROLLBACK
behavior) and trigger the save sequence.
1.2.4    Technical Context of Applications and Runtime
Environment
In Figure 1.5, you can see the technical context in which an
application created with the ABAP RESTful application programming
model is embedded. Here, you will gain an idea of the technical
paths and protocols that can be used to access the data and
services of a RAP application. A RAP application uses the SAP
HANA database to persist application data. CDS custom entities
allow you to connect an external system or other data source
through synchronous communication using a query programmed,
specifically in ABAP.

Figure 1.5     Technical Context of a RAP Application
Although you don’t need to understand the specific technical
components of the ABAP RESTful application programming model in
detail for the RAP runtime to process RAP requests, it does help to
know the essential building blocks involved in this process. It not
only improves the general understanding of the programming model,
but can also be very useful with regard to troubleshooting.
In Figure 1.6, you can see the technical components involved in
processing a RAP request.
Figure 1.6     Components of the RAP Runtime Environment (Source: SAP)

This type of request can be, for example, the creation of a purchase
order via the CRUD operation create. A request can originate from
an external application (e.g., a SAP Fiori interface or a web API
consumer) using the OData protocol, or it can be made as a local
call (that is, internal to the system) via the EML.
In the following sections we’ll describe the individual components:
SAP Gateway
SAP Gateway implements the OData protocol and serves external
applications as an entry point into the respective application. To do
this, SAP Gateway receives the OData request and forwards it to
the orchestration framework for generic processing.
Orchestration framework
The orchestration framework maps the OData request to a RAP
request and evaluates it generically. The orchestration framework
is also known as the service adaptation and description language
(SADL) framework. A read access is forwarded to the appropriate
query implementation, a write and, thus, transactional access is
processed via the business object framework. The orchestration
framework thus forms the transactional bracket around the RAP
request and is responsible, for example, for requesting locks,
ETag handling, and commit and rollback behavior. For read and
write accesses, the orchestration framework determines whether
the methods of a managed or unmanaged implementation need to
be invoked.
Business Object Framework
The business object framework controls the processing of
operations on a business object. It ensures that during the
interaction phase and save sequence, the intended methods of
the business object provider API are called in the managed or
unmanaged behavior implementation. While in an OData request,

the orchestration framework takes over the control of the
interaction phase and the save sequence, you have the possibility
via your ABAP and the EML code to control which operations run
within the interaction phase and when the save sequence will be
triggered.
[»]  Using SAP Gateway in the Background
The ABAP RESTful application programming model uses OData
by default to expose access to the application's functionality, using
SAP Gateway as the framework and runtime environment. For
you, however, SAP Gateway doesn’t appear during the
development of RAP applications. The programming model
generates the gateway artifacts in the background so that they can
accept an OData request for the programming model at runtime.
This also means that you can’t use the ABAP RESTful application
programming model to access the gateway development
capabilities (that is, Transaction SEGW, and the data and model
provider implementation), even if they are technically available on
the respective ABAP application server. Such direct access would
make the programming model dependent on a particular
technology, which is contrary to the architectural goals of the
programming model.

1.3    Development Objects
This section provides an overview of the main artifacts of the ABAP
RESTful application programming model. Among other things, a
programming model makes development objects, languages, and
APIs available and specifies their interaction to implement a specific
business functionality.
1.3.1    Data Modeling with Core Data Services
Every software application is based on a data or object model that
represents its entities, describes them using attributes, and maps the
relationships (associations) to other entities. An entity represents a
concept from the business world. Business processes are usually
mapped via multiple entities in an application. Entities are also called
business objects. The material master is an example of such a
business object that belongs to the master data. A sales order is
another typical example of a business object. It belongs to the
transaction data.
[eg]  Example: Data Model of the Sales Order Business Object
As an example, the business object “sales order” consists of the
entities, “sales order header” and “order item”. Together these
entities form the structure of the business object. The order item is
an entity dependent on the “sales order header”. The order item
also has an association with another business object, the
“material”, which represents the item ordered in the sales order.

To define the logical data model of an application, you can use CDS.
For each entity, you create a CDS entity in the system. Typically,
CDS entities are created based on transparent tables, but CDS
custom entities can also be defined independently of this type of
data source.
The concept of the business object with its dependent CDS entities
is particularly important for the ABAP RESTful application
programming model. A RAP transaction or business object is
mapped in its entirety (i.e., with all dependent CDS entities and as a
special CDS entity called CDS root entity [see Figure 1.7]).
Figure 1.7     CDS Data Model with “Sales Order” Example
1.3.2    Behavior Definition
The CDS data model described in the previous section is an
important initial component of a business object in the ABAP
RESTful application programming model. Another component is the
behavior of a business object. The programming model groups
writing operations, associated transactional properties, and business
logic under this term. Thus, behavior can include standard
operations (e.g., the creation or modification of an object), internal
business logic (e.g., checks or calculations), or other transactional
behavior (e.g., locking behavior, authorization checks, etc.).

If you want to define the behavior of a business object, you can
create a behavior definition for it. This is a new development object
introduced in the ABAP RESTful application programming model.
The creation is done with reference to the CDS root entity. Thus, a
behavior definition also applies to all CDS entities subordinate to the
root entity.
You can declare the desired behavior using the behavior definition
language (BDL). For example, you can use the BDL keywords
create, update, or delete to specify that your CDS entity supports the
appropriate default operation to create, update, or delete an instance
of that business object.
In the behavior definition, you can further specify which
implementation type you want to choose for implementing the
functionality of the business object. The managed implementation type
enables you to access a standard implementation of basic
functionalities. The unmanaged implementation type indicates that you
implement the business object in ABAP yourself. This way you can,
for example, encapsulate legacy coding with the ABAP RESTful
application programming model.
1.3.3    Behavior Implementation
Once you have declared the behavior of a business object using the
BDL, you still need the program logic that implements this behavior
at runtime. Depending on the implementation type or scenario you
chose when creating the behavior definition, the scope of the
required implementation can be quite different. You must provide the
behavior implementation, which is also called the behavior pool, in
ABAP.

To do this, you must define an ABAP class that interfaces with the
business object provider API to implement specific business logic,
such as validations, calculations, transactional behavior, or save
logic. Specifically, you can implement the following operations:
Standard operations
Standard operations include creating, reading, updating, and
deleting business objects. To enable these operations, they must
be implemented appropriately in the context of the interaction
phase, the transaction buffer, and the save sequence. For
example, the create operation requires the instance to be added
to the transaction buffer. Within the save sequence, this instance
held in the transaction buffer for creation must then be persistently
saved to the database. You can either choose an implementation
managed by the business object framework (managed business
object provider), or perform the implementation yourself
(unmanaged business object provider).
Specific operations
There are some specific operations for the program-related
implementation of actions or functions. These always require their
own behavioral implementation.
Internal business logic
The program-based implementation of validations or
determinations, which are only visible within the business object,
is called internal business logic. You always need your own
behavior implementation for this, too.
Transactional behavior
You also usually need your own behavior implementation for the
program-based implementation of authorization checks,
numberings, locks, etc. However, when assigning numbers, you
can also refer to a ready implementation of the business object

runtime (managed numbering with global unique identifiers
(GUIDs)). GUIDs can be used to assign key values.
1.3.4    Projection Layer
You can use the projection layer development objects in the ABAP
RESTful application programming model to tailor the CDS data
model or the core business object behavior to a specific use case. In
general, you use it to limit the available attributes and operations.
The projection layer contains the following development objects:
CDS projection view
You can use a CDS projection view to declare relevant attributes
and associations and enrich them with annotations, if necessary.
These annotations can be used, for example, to define the UI, to
run a search, or for input help. CDS projection views are similar to
the consumption views from the ABAP programming model for
SAP Fiori.
Behavior projection
Behavior projection is a special implementation type (projection)
of the behavior definition. It subsequently restricts the operations
and behaviors declared in the behavior definition to a selection.
You can also add additional operations in their processing in
ABAP coding without having to change the functionality of the
core business object. This requires additional behavior
implementation based on behavior projection.
The projection layer is also used to define visibility in your application
since it lets you decide what data and behavior you want to expose
to consumers. It thus forms the basis for providing remote APIs or
APIs for role-based SAP Fiori UIs via business services.

1.3.5    Business Services
The business services layer is used to expose RAP business
objects, along with their data and behavior, as a remote API for
consumers. The following development objects are available in this
layer:
Service definition
The service definition contains the CDS entities to be exposed
from the application's data model. The CDS entities can be used
to determine what data and behavior is exposed as a service. This
can be done based on CDS projection views (and behavioral
projections) or, in simple cases, directly based on the CDS entities
of the core business object.
Service binding 
The service binding, which is based on a service definition, allows
you to define the specific technical protocol via which the CDS
entities of the service definition are to be exposed. This can be, for
example, OData version 2 (OData V2) or OData version 4 (OData
V4). For these protocols, a distinction is made in each case
between a variant for UI or web API consumers. Service binding
supports the versioning of the interface. Standard authorizations
can also be assigned here.
1.3.6    Interaction of the Artifacts
In Figure 1.8, you can see how the RAP artifacts presented in the
previous sections interact and depend on each other. Almost all
elements are shown here. However, the option to program a custom
query for read accesses (unmanaged queries) is not shown.

Figure 1.8     Artifacts of the ABAP RESTful Application Programming Model
Note that the projection layer is optional. It depends on the particular
use case (whether you need these elements or not).
[»]  User Interface Development is Not Covered by the ABAP
RESTful Application Programming Model
Creating the UI for a RAP application is explicitly not part of the
programming model. However, since you can easily expose
OData-based interfaces as APIs using the ABAP RESTful
application programming model, it makes sense to use SAPUI5 as
the UI framework. The programming model also creates space to
enrich CDS entities with UI annotations. You can use these
annotations to influence the appearance and control of UIs based
on SAP Fiori elements. We’ll describe how you can use these
annotations in Chapter 7.

1.4    ABAP Development Tools
ABAP development tools (ADT) is the development tool of choice
when it comes to modern ABAP programming and increasing
developer productivity. This is also true when you build RAP
applications. ADT supports the well-known server-based
development model with a connection to the transport system of the
SAP system (or change and transport system [CTS]). Technically,
however, this development environment is completely independent
of the business applications installed on an ABAP system, such as
applications from SAP Business Suite, SAP S/4HANA, or SAP
S/4HANA Cloud. It can be used as of SAP NetWeaver 7.31 SP04.
Some key features of ADT include convenient source code editing,
an integrated code wizard, auto-completion, quick fixes, and the
navigation between development objects and their parallel display.
Refactoring is also supported. ADT is provided with a highly
customizable UI.
ADT is based on Eclipse and installed locally on your computer. You
can connect one ADT installation to several ABAP systems of
different releases. These can be on-premise systems, cloud-based
ABAP systems deployed on SAP Business Technology Platform
(SAP BTP), or SAP S/4HANA Cloud systems. The functional scope
of the development environment is always dependent on the basic
release status of the connected system. Figure 1.9 illustrates the
system context in which ADT operates.

Figure 1.9     System Context of ABAP Development Tools
When you build RAP applications, you must only use ADT. All
necessary development, testing, and analysis tools are available in
this environment. ADT is used for RAP development for both on-
premise and cloud-based systems. The SAP GUI-based transactions
of the ABAP Workbench no longer play a role in the ABAP RESTful
application programming model.
[»]  Development Tool for UI Development
To develop SAP Fiori UIs, you can use SAP Fiori tools for Visual
Studio Code or SAP Business Application Studio. For details
about these development environments, see Chapter 7.

1.5    Quality Attributes of the ABAP RESTful
Application Programming Model
In software architecture, nonfunctional requirements and the quality
attributes of the software play a significant role. These include, for
example, performance, usability, changeability, flexibility, and
adaptability of software.
A software architecture should take into account the quality
requirements placed on it. These determine the long-term usability
and longevity of the software product. Thus, the architecture of the
ABAP RESTful application programming model also brings with it
certain quality features, some of which will be described in greater
detail in this section. For SAP development teams, and for SAP
partners and customers, there are important consequences
associated with the use of the programming model.
In this section, we’ll take a closer look at the following selected
quality features:
Evolution capability
Development efficiency
Testability
Separation between business and technology
1.5.1    Evolution Capability
Software development has always strived to create software that is
capable of evolution (i.e., software that is—and remains—
changeable in the long term and that can also take into account new

technical trends and developments). Technical trends usually
concern the infrastructure of a business application (e.g., a new UI
technology or a way of storing data, rather than the business logic of
the application). A software is adaptable to trends if its business logic
hasn’t been mixed with technical coding for the infrastructure. It’s
also useful to have the software provide a business-motivated API
as an access point for consumers, making it usable in a variety of
technical contexts. Similarly, the business core of an application
should also be readily adaptable to additional business
requirements. This is the case when there’s no technical coding in it.
The ABAP RESTful application programming model supports one of
its quality attributes, evolvability, through its end-to-end declarative
approach. Thanks to CDS, applications are generally independent of
the underlying data source. The data model is declared exclusively
at the logical level. UI annotations are also located on the logical
level, because with such annotations you specify the desired
functionality without having to know the concrete implementation in
the UI. This makes it possible to leave annotations basically
unchanged in the application, even if you later interpret them using a
different UI technology.
You also declare transactional properties and business logic in the
behavior definition without having to know the concrete technical
implementation. Business services again abstract from the
underlying runtime environment, the SAP Gateway system. Prior to
the service definition, you don’t yet reference a specific technical
protocol that will be used to expose the defined entities. This
reference must be established only in the service binding. From
SAP's point of view, service binding can therefore serve as an
anchor point for adapting new interface technologies and protocols.

This evolutionary capability benefits not only applications developed
from scratch with the ABAP RESTful application programming
model, but also existing applications that have been encapsulated
with the ABAP RESTful application programming model. Such
encapsulated legacy applications can also be exposed to various
interfaces and protocols using ABAP RESTful application
programming model means without having defined this in the legacy
application itself. This also means that existing RAP applications can
continue to benefit from newly supported technical functionality or
interfaces (e.g., for data retrieval for forms) in the future.
1.5.2    Development Efficiency
The quality requirements for a programming model also include
efficiently supporting application developers in building applications.
Thus, it’s been a long-standing endeavor in software development to
relieve the burden on development teams by offering technologies
and crosscutting services (e.g., UI technologies, application servers,
etc.) so that they can focus on implementing the business application
layer.
The ABAP RESTful application programming model supports
development efficiency with the following approaches:
Declarative, model-based approach
A model-based approach provides a formal language tailored to
the specific application purpose. For example, BDL is a formal
language tailored to the purpose of behavior modeling.
Development objects (of the standard SAP) are generated from
the source code created on the basis of the language (the model,
which can also be a graphical model), or the model is evaluated
generically at runtime. So you declare the desired functionality

(the “what”) and don't have to bother about the concrete technical
implementation (the “how”).
Integration into the ABAP language
Based on the CDS data model, the ABAP RESTful application
programming model is tightly integrated into the ABAP language,
thereby ensuring strict typing of RAP-based interfaces (through
derived data types). This allows static syntax checking and better
tool support (e.g., through the code assist and element information
in ADT). This in turn reduces the susceptibility to errors and the
amount of research required, which benefits development
efficiency.
Standard implementations
The programming model provides default implementations for
certain application development tasks, such as implementing
standard operations (e.g., create, update, delete), transaction
buffer management, persistence, and draft handling. You can use
these default implementations by specifying appropriate keywords
in the behavior definition for the business object. This way you can
very quickly develop the first versions of a new application.
The default implementation of OData is provided by the SAP
Gateway used in the background, whose functionality you can
access via the service binding. You don't even need to know that
SAP Gateway is the technology used to do this. SAP Gateway
knowledge is therefore not necessary, which has a positive effect
on the number of prerequisites you need to bring along.
Standard vocabulary for business applications
The programming model defines a standard vocabulary for
business applications and business logic. Validations (validation),
determinations (determination), and actions (action) can be used
as explicit keywords in the behavior definition and are thus also

included in the ABAP language scope. These concepts facilitate
the communication within the development team and with subject
matter experts when discussing requirements and their
implementation.
1.5.3    Testability
Changeability has been ensured since the early days of agile
development, primarily via automated testing at various levels of
granularity (from individual modules to complete end-to-end
applications). However, software usually can’t be tested easily. The
testability feature determines how easily the functionality of an
application can be tested automatically by a test suite. Program code
is much easier and safer to change if it has been backed up with
reliable test cases using the tools of test automation.
As described in Section 1.2.1, the ABAP RESTful application
programming model introduces the concept of the interaction phase
(separate from the save sequence) and the transaction buffer. By
using the ABAP RESTful application programming model, it’s difficult
to “program past” this concept. The presence of the (transient)
transaction buffer makes it easier to store different test data
depending on the test case and to execute test cases automatically
one after the other without overlapping the data areas. Tests are
typically enabled by implementing test cases using the ABAP Unit
framework. ABAP Unit is a testing framework that allows you to
develop and execute unit tests for your applications.
1.5.4    Separation between Business and Technology

The principle of separation between business and technology is an
application of the separation of concerns principle. It is necessary in
order to develop business logic that’s independent of external
technology, that can be changed independently of technology, and
that can be reused as permanently as possible. This principle is an
important means of implementing certain quality features.
Business logic refers to implementing the business software’s
application purpose (i.e., the program logic with which, for example,
purchasing and ordering processes are handled). The technical
environment of such a domain-oriented core includes, for example,
the UI and the persistence layer (e.g., the database technology
used).
Technological changes occur more frequently or for different reasons
than changes in the application domain. Thus, the calculation of the
best purchase price is independent of the logic of the technical
environment (e.g., which code artifacts are needed to display this
price on the UI, or what interface and message format are needed to
transmit the price to a third-party system). Software is easier to
customize if the business logic is separated from the technical
program logic.
With the concept of the business object with its behavior definition
and implementation, the ABAP RESTful application programming
model creates an explicit space for the business logic. It becomes
difficult to incorporate technically motivated coding into this behavior
logic, which would impact subsequent steps of the application
development process. The programming model also defines a flow
for processing standard operations or actions. This process specifies
explicit points in time and interfaces, for example, to implement
authorization checks, numbering, or the saving of business data.

1.6    Availability of the ABAP RESTful
Application Programming Model
In this section, you’ll learn about which SAP products the ABAP
RESTful application programming model is available in. You’ll get a
brief overview of the relevant features of the respective products and
learn how the programming model is positioned there in each case.
The ABAP RESTful application programming model is available with
the following products:
SAP BTP, ABAP environment (see Chapter 12)
ABAP platform for SAP S/4HANA on-premise
1.6.1    SAP BTP, ABAP Environment
With the SAP BTP, ABAP environment, the ABAP platform is
available as a cloud service on the SAP Business Technology
Platform (SAP BTP). The first version of SAP BTP, ABAP
environment was version 1808. SAP BTP, ABAP environment is, on
a logical level, the cloud counterpart of on-premise SAP NetWeaver.
However, extensive clean-up measures were required to implement
a cloud-capable version of SAP NetWeaver.
Within SAP, the project name Steampunk was used to refer to the
SAP BTP, ABAP environment, and has also become part of common
parlance in the developer community.
There is a separate ABAP language version for cloud development.
Access to standard SAP functionality is only possible via officially
released APIs (whitelisted APIs). Modifications to the standard SAP

code are not permitted, and only a well-defined selection of
infrastructure components is still available for application
development, such as the application log, background processing, or
the numbering service. UI frameworks, such as Web Dynpro ABAP
or Floorplan Manager are no longer supported, since SAP Fiori is
also the tool of choice in the cloud for implementing web-based UIs.
The ABAP RESTful application programming model is fully available
on SAP BTP for efficient application development. New releases of
SAP BTP, ABAP environment are published quarterly. This means
that the latest features of the programming model are also always
provided. You can use SAP BTP, ABAP environment as a platform to
implement standalone applications, enabling you, as an SAP partner,
to develop and operate cloud applications. In addition, you can use
the side-by-side extension option of the application software, such as
SAP S/4HANA, SAP S/4HANA Cloud, or SAP ERP. However, you
aren’t necessarily limited to application software from SAP; you can
ultimately integrate any application, provided it exposes suitable
interfaces.
1.6.2    ABAP Platform for SAP S/4HANA On-Premise
The ABAP RESTful application programming model for SAP
S/4HANA on-premise was first available with the ABAP Platform for
SAP S/4HANA 1909 FPS00 (equivalent to SAP NetWeaver 7.54).
The programming model replaced the ABAP programming model for
SAP Fiori, which was introduced in SAP NetWeaver 7.50. The ABAP
programming model for SAP Fiori continues to be fully supported
today.

[»]  Release-Dependent Information on the Functions of the
ABAP RESTful Application Programming Model
You can find out which functionality of the ABAP RESTful
application programming model is available to you in which
release of the ABAP platform for SAP S/4HANA. That can be
found in SAP Help Portal (https://help.sap.com) on the page for
the ABAP RESTful application programming model, under the
product context ABAP Platform and the release notes stored for
the programming model.
Even though the “clean core” principle applies to all versions of SAP
S/4HANA, on-premise you have the option of using all SAP
development objects for your own developments, even if they aren’t
released and the API release isn’t enforced via a syntactical check.
Likewise, it’s still technically possible to make modifications to the
system. ABAP development tools are available as a development
environment for this purpose.
The ABAP platform is no longer provided individually as SAP
NetWeaver Application Server for ABAP, but is part of an SAP
S/4HANA installation. Thus, the ABAP platform is tied to the annual
release cycle of SAP S/4HANA on-premise. New features in the
ABAP RESTful application programming model are therefore only
available once a year.

2    Core Data Services: Data
Modeling
Core data services (CDS) play a central role in SAP S/4HANA.
With their technical capabilities for data modeling, they form
the basis of any application. As it is one of the key
technologies in the ABAP RESTful application programming
model, we now want to take a detailed look at CDS and thus
lay the foundation for the following chapters.
ABAP core data services (ABAP CDS) have been available since
ABAP 7.40 SP05. They provide you with numerous options when
you create applications. To be able to use them, it’s necessary to
work with ABAP development tools (ADT) in Eclipse. Editing CDS
views using the classic ABAP Workbench is not supported.
[»]  Installing and Configuring ABAP Development Tools
For information on how to install Eclipse and ADT, and how to
connect them to your ABAP backend system, go to
https://tools.hana.ondemand.com/.
In Section 2.1, you’ll become familiar with the basic concepts of CDS
and why CDS plays a significant role in development for SAP
S/4HANA. Based on the information in Section 2.2, you’ll create your
first CDS data model and gain initial experience with ADT.
Section 2.3 will explain how to map relationships between CDS

entities. In Section 2.4, we’ll describe annotations, which are meta-
information you can use to enrich your data model.
You can use access controls to restrict access to your CDS data
model; this is described in Section 2.5. In Section 2.6, you’ll learn
how to enrich CDS views with additional information without any
modification.
You won’t always be able to map all requirements standard CDS
functionalities. Section 2.7 describes how you can still achieve your
goals in such a scenario. In Section 2.8, you’ll learn about SAP's
virtual data model (VDM), which provides you with another way to
access the persisted data of an SAP S/4HANA system. Finally, in
Section 2.9, we’ll introduce some language elements that you can
use when modeling business objects.
2.1    What are Core Data Services?
SAP defines CDS in SAP Help as an “infrastructure that developers
can use to create semantically rich and persistent data models.” The
resulting data models are built on top of existing database tables and
are intended to be easier to understand and utilize. This is achieved
by changing the perspective away from a purely technical view of the
database tables to a view of data oriented toward the business
object.
CDS views are used for flexible data retrieval and are the central tool
for data modeling in the ABAP RESTful application programming
model. There are two CDS implementations: ABAP and SAP HANA
CDS. While SAP HANA CDS views are created at the database
level, ABAP CDS views are maintained on the SAP application
server or ABAP platform. One of the major advantages of developing

ABAP CDS views over native SAP HANA CDS views created on the
SAP HANA database is the connection to the SAP change and
transport system (CTS). Working on the application server also
allows you to continue working in your familiar ABAP environment
while taking advantage of the capabilities of the SAP HANA
database. In the following sections, we’ll only take a look at the
concept of ABAP CDS views.
The syntax of CDS is aligned with the SQL standard. CDS is
therefore often referred to as an extension of SQL. In detail, CDS
includes the following domain-specific languages:
Data definition language (DDL) for data modeling
Query language (QL) for querying data
Data control language (DCL) for defining access restrictions
You’ll learn how to use these languages in the following sections.
Since CDS plays a central role in SAP S/4HANA, it’s logical that it’s
of great importance for the daily work of SAP S/4HANA development
teams. CDS plays a crucial role in the implementation of the
following basic concepts of the SAP S/4HANA architecture:
Code-to-data paradigm
Virtual data model (VDM)
Programming models for SAP S/4HANA
The basic idea of the code-to-data paradigm is to move application
logic from the application server to the database (code pushdown,
see Figure 2.1). Calculations should be performed by the database
system as much as possible. The results of these calculations are
then delivered to the application server. This approach reduces the
amount of data that must be transferred from the database to the

application server. In addition to the extended possibilities of ABAP
SQL (formerly Open SQL), which have been available since ABAP
7.40 SP05, and the ABAP-managed database procedures (AMDP),
CDS views are excellently suited for implementing the code-to-data
paradigm, for example, by defining calculations or access controls
directly in the data model and thus shifting them to the database
level. This enables you to harness the power of the SAP HANA
database and let the database do the work for you.
Figure 2.1     Code-to-Data Paradigm
CDS serve as a tool for data modeling. With the virtual data model
(VDM), SAP provides a data model based on CDS in the standard
SAP S/4HANA system. VDM was developed by SAP according to
extensive, detailed guidelines and standards regarding hierarchical
structure and naming conventions. It maps the application data of
SAP S/4HANA and is used by transactional and analytical
applications and by the APIs provided for SAP S/4HANA. Figure 2.2
shows the hierarchical structure of the VDM using the example of the
SalesOrder business object in ADT’s Dependency Analyzer. This tool
is good for getting an initial overview of a view hierarchy.

Figure 2.2     Excerpt from Virtual Data Model: API View of A_SalesOrder in the
Dependency Analyzer of ABAP Development Tools
The strict adherence to guidelines and standards results in a high
degree of consistency and comprehensibility. Many of the CDS
views in SAP S/4HANA are explicitly enabled for use. For SAP
S/4HANA developers, VDM is another way to obtain data. It can be
regarded as an additional data access layer. In Section 2.8, we’ll go
into more detail about the VDM.
The programming models provided by SAP support development
teams in implementing your requirements and making the
development process efficient. Looking at the evolution of ABAP-
based programming models (see Section 1.1.5), the importance of
data modeling using CDS becomes apparent. Classic ABAP
development was still based on a data model consisting of ABAP
dictionary elements, such as tables, data elements, and domains.
The relationships between the tables were represented by the
definition of foreign keys. Since the introduction of ABAP CDS, on
the other hand, it has been possible to rely on data models based on
CDS views, which define the relationships between the individual
CDS views via associations. These data models are semantically
enriched by annotations, which describe, for example, how a

consumer (e.g., a user interface based on SAP Fiori elements)
should interpret the data.
However, classic ABAP applications developed on the basis of such
data models are subject to certain limitations. You can only access
the CDS view in read-only mode, and no transactional processing is
possible. For this reason, and also because of the increasing
importance of SAP Fiori as an SAP interface technology, SAP
initially developed the ABAP programming model for SAP Fiori.
Here, the transactional behavior is implemented by annotations that
are used to automatically generate a Business Object Processing
Framework (BOPF) model. The behavior implementation of the
BOPF actions, derivations, and validations are carried out in ABAP.
However, this approach introduces complexity and requires the
parallel use of two modeling frameworks (CDS and BOPF). While
type checking is already performed at design time in the typed CDS
framework, errors often only occur at runtime in the very generic
BOPF, which makes troubleshooting more difficult due to the
complexity. The desire to reduce the complexity of the programming
model eventually led to the introduction of the ABAP RESTful
application programming model. The ABAP RESTful application
programming model is also based on a semantic CDS data model.
The transactional logic is expressed by the behavior definition and its
implementation. The entities to be used by the consumer (e.g., an
SAP Fiori app) are defined and published by a business service (see
Figure 2.3).

Figure 2.3     Layers of the ABAP RESTful Application Programming Model

2.2    Structure and Syntax of Core Data
Services
In this section, we’ll show you how to create your first simple CDS
views. You’ll learn how to proceed when developing CDS views,
especially how to use the Eclipse development tool and ADT. You’ll
also get to know the basic syntax elements of CDS and some ways
to obtain data. Here, we don’t yet make a concrete reference to the
ABAP RESTful application programming model. Rather, we intend to
lay the foundation to understand the following chapters. If you
already have experience with CDS views, you can skip Core Data
Services: Data ModelingChapter 2. In Part II, we show you how you
can apply essential CDS concepts in various scenarios.
The example in this section is based on the ABAP flight reference
scenario provided by SAP. You’ll create CDS views that read data
from the tables in this reference scenario, and add simple logic to the
CDS views you create. This way you’ll develop an initial, simple CDS
data model. In the process, you’ll also learn about some functions
you can use to analyze the created CDS views.
[»]  ABAP Flight Reference Scenario
The ABAP flight reference scenario provides sufficient sample
data and logic to familiarize yourself with the ABAP RESTful
application programming model. All information about this
reference scenario, especially about the installation, can be found
in a Git repository at http://s-prs.de/v868501.

The goal of this section is to merge and enrich information from the
database table persistence model. Table 2.1 lists the database
tables of the reference scenario we use.
Table
Meaning
/DMO/FLIGHT
Flights
/DMO/CARRIER
Airlines
/DMO/CONNECTION
Flight connections
Table 2.1     Tables Used from the Reference Scenario
As a complementary logic, for example, a simple statement and a
currency conversion are to be performed.
2.2.1    Creating a Basic Interface View
The main task of a basic interface view is to read data from database
tables and to convert the technical names of the database fields into
more meaningful names (for this and other CDS view types,
Section 2.8).
You can create a basic interface view as the first CDS view by
following these steps:
1. Start Eclipse and open the ABAP perspective via the menu path
Window • Perspective • Open Perspective • Other...
2. In the popup window, select the ABAP perspective (see
Figure 2.4).

Figure 2.4     Selecting the ABAP Perspective
3. Select File • New • Other in the main menu.
4. In the next popup window, select the entry ABAP • Core Data
Services • Data Definition and confirm the selection by clicking
the Next button (see Figure 2.5).

Figure 2.5     Selecting the Type of Development Object to Create
5. This calls a dialog to create a CDS view (see Figure 2.6). Enter
the ABAP project in the Project field and your development
package in the Package field. You should enter the name of the
CDS transport object (data definition language source [DDLS]
type) in the Name field (e.g., “ZI_Flight”) and a description in the
Description field (e.g., “Flight”). Then, confirm your input by
clicking the Next button.

Figure 2.6     Properties of the CDS View
6. In the next screen, select a transport request (if you aren’t
working with local objects) and confirm again by clicking the
Next button.
7. In the following screen, you can then select a template for the
creation of your CDS view. The provided templates refer to
commonly used CDS modeling options and simplify the creation
of corresponding CDS views. If you want to work without a
template, you must uncheck the Use the selected template
box. To create a simple CDS view, select the Define View
template and confirm your selection by clicking the Finish button
(see Figure 2.7).
Figure 2.7     Selecting a Template
You’ll then be redirected to a source code-based editor where you
can edit the details of your CDS view. Due to the selection of the
template, some basic elements of the code will already be suggested
(see Figure 2.8).

Figure 2.8     Coding Generated by the Template in the Source Code-Based Editor
To complete your first CDS view, perform these steps:
1. You must assign a name for the SQL view in the ABAP
dictionary, which is automatically generated when the CDS view
gets activated.
2. You must also define the data source of your CDS view.
3. Also, you must define the field list (also referred to as an
element list or select list).
Then, you assign the name of the ABAP dictionary representation of
your CDS view using the following annotation:
@ABAPCatalog.sqlViewName: 'ZI_FLIGHTV' 
Then, you must specify the data source after the language element
as select from:
as select from /DMO/FLIGHT 
The field list can be defined inside the curly brackets. The easiest
way to do this is to place the cursor in this area and press the
keyboard shortcut (Ctrl) + (Space). Then, you can include
individual elements in the field list, or select Insert all elements
(template), as shown in Figure 2.9.

Figure 2.9     Defining the Field List
Now you must activate your CDS view using the keyboard shortcut
(Ctrl) + (F3). You have now created your first CDS view, activated
it, and made it available for use. Listing 2.1 shows the complete
coding.
@AbapCatalog.sqlViewName: 'ZI_FLIGHTV'
@AbapCatalog.compiler.compareFilter: true
@AbapCatalog.preserveKey: true
@AccessControl.authorizationCheck: #CHECK
@EndUserText.label: 'Flight'
define view ZI_Flight
  as select from /dmo/flight
{
  key carrier_id     as CarrierId,
  key connection_id  as ConnectionId,
  key flight_date    as FlightDate,
      price          as Price,
      currency_code  as CurrencyCode,
      plane_type_id  as PlaneTypeId,
      seats_max      as SeatsMax,
      seats_occupied as SeatsOccupied
} 
Listing 2.1     CDS View ZI_Flight
2.2.2    Analyzing the Data Model
You should now take a closer look at your first CDS data model.
When you activated it, you created three objects (see Figure 2.10).

Figure 2.10     Objects of the CDS Data Model
 The CDS entity ZI_Flight represents the properties of your
CDS view (that is, the SQL characteristic and additional
metadata). You can reference this entity as a data source in an
ABAP SQL statement, for example.
 The DDLS source code object ZI_FLIGHT is the transportable
development object that you’ll find in your transport request
accordingly (see Figure 2.11).
Figure 2.11     DDLS Transport Object
 When you activated the CDS view, you generated the SQL view
ZI_FLIGHTV in the ABAP dictionary. You can display this in the
dictionary maintenance Transaction SE11 (see Figure 2.12) and
test it using Transaction SE16. Note that this is a SQL view
based on CDS. Changes via Transaction SE11 are not possible
for this reason. Also, not all CDS entity information can be
represented in Transaction SE11. For example, the display and
maintenance of meta information and the definition of
calculations or type conversions are only possible in the Eclipse
environment.
1
2
3

Figure 2.12     Representation of the CDS View in the ABAP Dictionary
[»]  Deleting CDS Views
Deleting only the SQL view isn’t possible. CDS entity and SQL
view can’t be deleted independently. When the CDS entity gets
deleted, the generated SQL view will also be deleted.
For testing and analyzing the CDS view result set, the ADT data
preview function is useful. This is similar to the classic Transaction
SE16 because you don’t need to execute an SQL statement to test
the CDS view. Simply right-click on the source code to open the
context menu of the CDS editor and select the Open With • Data
Preview path (see Figure 2.13).

Figure 2.13     Data Preview in ABAP Development Tools
By default, the first 100 entries of the result set will be displayed (see
Figure 2.14). When you click on the column headers, you can sort
the result set. In addition, the following useful functions are available
in the toolbar:
Add filter restricts the result set.
Select Columns selects the field list.
Number of Entries displays the number of hits according to the
chosen selection criteria. 
Figure 2.14     Result Set of the Data Preview
For a more detailed analysis of the data set, you can use the SQL
Console function. It opens another view that displays the SQL
statement underlying the selected records. This statement can also
be edited. For example, you can add a WHERE clause to further restrict
the result set. Selecting Run will re-run the query and display the
updated result set (see Figure 2.15).
Figure 2.15     SQL Console Within the Data Preview
You can get information about the syntax and meaning of individual
language elements by placing the cursor on the corresponding
language element in the source code editor and pressing the F1 key.

The context-sensitive function then opens the ABAP CDS language
reference in a separate view (see Figure 2.16).
Figure 2.16     ABAP CDS Language Reference
On the other hand, if you need information about the elements used
in the source editor, such as tables, views, or table fields, you can
press the (F2) key. This opens a popup window with the
corresponding information (see Figure 2.17).
Figure 2.17     Information About the Selected Code Element
2.2.3    Using CDS Views
You can use the CDS view within an ABAP program essentially in
the same way as you are used to using database tables. For
example, you can select data from the CDS view in a SELECT
statement, as shown in Listing 2.2, or refer to the CDS view in the
typing of variables. The use of uppercase and lowercase letters
doesn’t matter when using the CDS view, but it’s recommended to
use camel case notation for better readability. This notation will be

retained when the development object is created, even if the
technical name is converted to uppercase in the repository and is
displayed that way in the project explorer in Eclipse. When
generating OData services based on CDS views, this notation is
preserved.
DATA flights TYPE STANDARD TABLE OF zi_flight.
 
SELECT carrierid, connectionid, flightdate, Price,
       CurrencyCode, PlaneTypeId, SeatsMax, SeatsOccupied
  FROM ZI_Flight
  INTO TABLE @flights
  WHERE carrierid = 'LH'. 
Listing 2.2     Using a CDS View in ABAP
A CDS view can also be called from another CDS view (see
Listing 2.3). This enables a hierarchical structure of CDS-based data
models, which is called a view stack.
@EndUserText.label: 'Flight detail'
define view ZI_FlightDetail
  as select from ZI_Flight
{
  key CarrierId, 
Listing 2.3     Using a CDS View Within Another CDS View
2.2.4    Extending the Data Model
The created CDS view ZI_Flight accesses the database table
/DMO/FLIGHT and makes its fields available for use. The technical field
names of the database table have been replaced in the CDS view
with meaningful labels in camel-case notation. This kind of naming is
the first step from the more technical view of the database table to a
more business-oriented view of the data and, therefore, one of the
most important tasks of basic interface views.

We now want to extend the data model with additional information by
providing data from additional data sources. We’ll also add
descriptive information (metadata). In addition, we’ll use simple
statements and calculations to move logic to the database level,
which is in keeping with the code-to-data paradigm.
To do this, you must first create another CDS view ZI_FlightDetail,
which is based on the CDS view ZI_Flight, by selecting data from
ZI_Flight. This results in a hierarchical structure that’s typical of
CDS data models, which you can see in Listing 2.4.
01 @AbapCatalog.sqlViewName: 'ZI_FLIGHTDETAILV'
02 @AbapCatalog.compiler.compareFilter: true
03 @AbapCatalog.preserveKey: true
04 @AccessControl.authorizationCheck: #NOT_REQUIRED
05 @EndUserText.label: 'Flight detail'
06 define view ZI_FlightDetail
07  with parameters
08    P_TargetCurrency :abap.cuky( 5 )
09  as select from ZI_Flight
10  association [1] to /DMO/I_Carrier as _Carrier 
11    on  $projection.CarrierId = _Carrier.AirlineID
12  association [1] to /DMO/I_Connection as _Connection 
13    on  $projection.ConnectionId = _Connection.ConnectionID
14    and $projection.CarrierId = _Connection.AirlineID
15 {
16  key CarrierId,
17  key ConnectionId,
18  key FlightDate,
19
20      @Semantics.amount.currencyCode: 'CurrencyCode'
21      Price,
22      @Semantics.currencyCode: true
23      CurrencyCode,
24
25      PlaneTypeId,
26      SeatsMax,
27      SeatsOccupied,
28
29      SeatsMax - SeatsOccupied as SeatsFree,
30
31      case SeatsOccupied
32        when SeatsMax
33          then 'X'
34          else ''
35        end as FlightOccupied,
36
37      @Semantics.amount.currencyCode: 'TargetCurrency'

38      currency_conversion( 
39        amount => Price,
40        source_currency => CurrencyCode,
41        round => 'X',
42        target_currency => :P_TargetCurrency,
43        exchange_rate_date => FlightDate
44      ) as PriceInTargetCurrency,
45
46      @Semantics.currencyCode: true
47      cast(:P_TargetCurrency
48        as vdm_v_target_currency
49        preserving type) as TargetCurrency,
50
51      _Carrier,
52      _Connection
53 }
54 where
55  FlightDate >= $session.system_date 
Listing 2.4     CDS View ZI_FlightDetail
Descriptive properties are added in CDS by using annotations. For
example, the annotation @Semantics.currencyCode:true in line 46
identifies the CurrencyCode field as a currency key. The annotation
@Semantics.amount.currencyCode:'TargetCurrency' in line 37
identifies the field as an amount field for which the associated
currency key is contained in the referenced field.
While these two annotations refer to the respective elements of the
CDS view, the scope of the annotation
@AccessControl.authorizationCheck:#NOT_REQUIRED in line 4
comprises the view level. This annotation is used if no access control
is currently provided for the CDS view, but appropriate roles can be
defined at a later time.
With SeatsMax - SeatsOccupied as SeatsFree a simple calculation of
the number of unoccupied seats of a flight is done in line 29.
Arithmetic expressions (e.g., addition, subtraction, multiplication,
division) can be used in CDS, as can aggregate functions (e.g.,
MAX, MIN, AVG, SUM, COUNT).

Built-in functions provide support for some common requirements.
Built-in functions from a wide range of areas are available for this
purpose: string functions, numeric functions, date and time
conversion functions, and conversion functions. For example, the
currency_conversion function in lines 38 to 44 performs a currency
conversion for the value passed to the formal parameter amount.
The target currency is passed as a typed parameter in the example
when the CDS view is called in lines 7 and 8: with parameters
P_TargetCurrency :abap.cuky( 5 ). With cast(:P_TargetCurrency as
vdm_v_target_currency preserving type) a type conversion to the
semantic attributes of the data element vdm_v_target_currency is
performed in line 47 to 49.
An example of a case distinction used in the Select statement can
be found in the statement block case SeatsOccupied when ...
The access to the data of the CDS view /DMO/I_Carrier and
/DMO/I_Connection happens via associations. Associations are used
to map relationships between CDS entities. By expressing
association [1] to /DMO/I_Carrier and explicitly releasing the
associated data with _Carrier in line 10, a consumer of the CDS
view gains access to these fields.
Last but not least, the Where clause in lines 54 and 55 constrains the
rows in the result set when accessing the CDS view. In the clause
where FlightDate >= $session.system_date a session variable is
used. Session variables contain global information about the current
context, the contents of which correspond to the value of certain
ABAP system fields when accessed. Direct access to the SY-DATUM
system variable is not possible.
When you call the data preview now, a popup window for parameter
input will display (see Figure 2.18). This behavior is determined by

specifying the target currency as a typed parameter.
Figure 2.18     Popup Window for Parameter Input
The result set contains the calculated fields and has been filtered by
flight date (see Figure 2.19).
Figure 2.19     Data Preview of the Result Set of the ZI_FlightDetail View
If you select the Follow Association entry in the context menu of
the result set, as shown in Figure 2.20, you can display the result set
of the selected navigation target.

Figure 2.20     Tracing Associations
In the next popup window, you can select one of the displayed
associations (see Figure 2.21).
Figure 2.21     Selecting an Association
Figure 2.22 shows the output of the result set of the associated
entity.
Figure 2.22     Result Set for the _Connection Association
By creating this simple CDS data model, you have already become
familiar with some of the language elements of the CDS data
definition language (DDL). Due to the large number of available
statements and functions, we can provide only a first overview here.
Details on the syntax, which is based on SQL, can be found, for

example, in the ABAP keyword documentation at http://s-
prs.de/v868502.
Due to the use of associations and annotations, you have also
already become familiar with two central concepts of CDS data
modeling. Because of their importance, we’ll discuss these concepts
in greater detail in the following sections. We’ll also dedicate a
separate section to the implementation of access controls in CDS in
Section 2.5.

2.3    Associations
Relationships are often represented as foreign key links at the
database level. You can map relationships between CDS views
using associations. Associations in CDS are thus an important tool
for data modeling in the ABAP RESTful application programming
model and a precursor for modeling business objects in the behavior
definition.
An association links a CDS view (as the source data) to the target
data source specified in the association definition by means of an On
condition. Besides CDS views, database tables or SQL views can
also be used as a target data source.
[ ! ]  Warning: Other Target Data Sources
Using target data sources other than CDS views may result in
limited functionality when using the CDS view in applications. For
this reason, it’s recommended to use only CDS views as the target
data source.
From a technical point of view, associations are similar to a JOIN
operation. However, they don’t merely link multiple data sources;
they are used to clarify the relationships between entities, and they
contain additional semantic properties, such as cardinality
information. Basically, an association is a description of a possible
connection between entities. It’s the conceptual view of the data that
is the focus here.
A relationship represented by an association is therefore also
referred to as a functional relationship. The association is necessary

only if data from other entities is needed for a certain functionality. In
this context, the term join on demand is often used.
For clarity, we’ll now extend the CDS view ZI_Flight in Listing 2.5
with an association to the standard CDS view I_Currency.
@AbapCatalog.sqlViewName: 'ZI_FLIGHTV'
@AbapCatalog.compiler.compareFilter: true
@AbapCatalog.preserveKey: true
@AccessControl.authorizationCheck: #CHECK
@EndUserText.label: 'Flight'
define view ZI_Flight
  as select from /dmo/flight
  association [0..1] to I_Currency as _Currency on 
  $projection.CurrencyCode = _Currency.Currency
{
  key carrier_id     as CarrierId,
  key connection_id  as ConnectionId,
  key flight_date    as FlightDate,
      price          as Price,
      currency_code  as CurrencyCode,
      plane_type_id  as PlaneTypeId,
      seats_max      as SeatsMax,
      seats_occupied as SeatsOccupied,
      _Currency
} 
Listing 2.5     Association
By defining the association with association [0..1] to I_Currency
and exposing it with _Currency as another element in the projection
list, all components from the associated CDS view I_Currency are
available for callers. The easiest way to test this again is to select
the Follow Association context menu function in the data preview.
Figure 2.23 shows the result.
Figure 2.23     Association in the Data Preview

At the database level, this exposure of the association alone doesn’t
define a join. You can check this by displaying the SQL statement
CREATE via the context menu of the CDS editor. Select the Show
SQL CREATE Statement entry here. The results are displayed in
Figure 2.24. Alternatively, you can view the corresponding SQL view
ZI_FLIGHTV in Transaction SE11. The actual join occurs only when
the consumer accesses fields in the data source. Thus, no
preselection of supposedly relevant fields of the data source is made
during data modeling. This task is left to the user of the data model.
Figure 2.24     Display of the SQL Statement CREATE in the Popup Window with the
Element Information
Access to associations of a CDS view via a higher-level CDS view
built on top of it occurs in exactly the same way as access to the
other components of that view. You can see an example in
Listing 2.6. You can access individual components of the association
or, if desired, re-expose the association under a different name, by
assigning an appropriate alias.
define view ZI_FlightCurr as select from ZI_Flight
{ 
  key CarrierId,
  key ConnectionId,
  key FlightDate,
  CurrencyCode, 
  _Currency.CurrencyISOCode,
  _Currency as _FlightCurrency 
} 
Listing 2.6     Using an Exposed Association in CDS

Direct access to individual fields of an association (as is done in
Listing 2.6, to the CurrencyISOCode field) is often referred to as an ad-
hoc association. In this case, the activation of the CDS view creates
a corresponding join at the database level, thus overriding the join
on-demand principle.
It’s also possible to access fields of exposed associations from
ABAP SQL. This also applies, for example, to the use in a WHERE
condition.
SELECT Price, \_Currency-CurrencyISOCode
FROM zi_flight
WHERE \_Currency-Decimals = 0
INTO TABLE @DATA(currencies). 
Listing 2.7     Using an Exposed Association in ABAP SQL
As an additional option, you can work with filter conditions when
using associations in CDS-based data modeling, as in the following
example:
Currency[Currency = $parameters.P_TargetCurrency] as _TargetCurrency 
This way you can further restrict the associated target records
according to your requirements. When the path expression is
converted to a join in the database, the filter becomes part of the On
condition. Using filters in associations often improves readability and
facilitates the interpretation of the data model. An additional Where
clause would be less readable.
When defining associations, you can include the cardinality in square
brackets. It’s the cardinality of the target data source (that is, the
possible number of related target records). This specification is
optional. If you don’t specify the cardinality, the default value [0..1]
will be used. However, it’s recommended to specify the cardinality as
precisely as possible. It is primarily used to document the semantics

of the data model and thus significantly improves the readability of
your data model.
Even if the cardinality isn’t validated at runtime, it can lead to
warnings and errors during syntax checking, as shown in the
example in Figure 2.25. Incorrect cardinality specifications can also
lead to incorrect data selections, such as duplicates or missing
records in the result set.
Figure 2.25     Syntax Warning About Cardinality
Just like specifying the cardinality, specifying a name for the
association isn’t mandatory. If a name isn’t specified, the name of the
target data source will be used implicitly. In any case, to ensure that
the data model is readable, you should use the name assignment by
means of the alias function. As a naming convention, SAP
recommends an underscore (_) as the first character; this also helps
distinguish associations from the other fields in the element list.
[+]  Tip: Using Associations Instead of Joins
When defining a CDS data model, you should use associations
rather than joins. If possible, you should also avoid the formation
of implicit joins (ad-hoc associations). Instead, try to represent the
relationships of the data using associations. In this way, you can
provide the consumer with a fully comprehensive data image

without having to generate an extensive join for it (and, thus,
incurring performance losses).

2.4    Annotations
In the CDS views we’ve created over the course of this chapter,
we’ve already used some CDS annotations. For example, in
Listing 2.1, we specified the name of the SQL view created during
activation by an annotation:
@AbapCatalog.sqlViewName: 'ZI_FLIGHTV' 
Annotations enable you to add additional information (metadata) to
your CDS data model. Annotations are therefore an essential part of
data modeling. The information can be evaluated by the users of the
data model. It can be used purely for documentation purposes, but
also to activate certain functions.
According to their usage, the CDS annotations provided by SAP
(SAP annotations) can be divided into
ABAP annotations
Framework-specific annotations 
ABAP annotations are evaluated when the object defined in the CDS
source code is activated or used. Framework-specific annotations
are evaluated by the framework of another software component; for
example, by the OData or analytics software components.
[ ! ]  Warning: Use Only SAP Annotations
Currently, only annotations predefined by SAP are to be used in
the CDS source codes. SAP partners and customers aren’t yet
allowed to define their own annotations.

From a technical point of view, CDS annotations (analogous to the
CDS views that use them) are themselves CDS objects (object type
DDLA) that are created and provided by an annotation definition.
The definition of a CDS annotation is done using the following
statement:
define annotation 
The annotation definition specifies the unique name of the
annotation and describes its technical properties:
Scope
Type
Allowed values (optional)
Default value (optional) 
The structure of an annotation definition is illustrated in Listing 2.8. It
contains an excerpt from the definition of the SAP annotation
Semantics. The use of uppercase and lowercase letters is relevant
here.
@Scope: [#ELEMENT, #PARAMETER]
define annotation Semantics
{
...
 
   eMail
   {
       type : array of String(10) enum
       {
           HOME;
           WORK;
           PREF;
           OTHER;
       }
...
   systemDateTime
   {
       createdAt                  : Boolean default true;
       lastChangedAt              : Boolean default true;
       localInstanceLastChangedAt : Boolean default true;
   };
...
   @Scope:[#ELEMENT]
...

   currencyCode        : Boolean default true;
 
}; 
Listing 2.8     Sample Annotation Definition (Excerpt)
Semantics is the main annotation (domain) of this annotation
definition. It’s further structured by subannotations, such as eMail or
systemDateTime. This results in a hierarchical structure. The domains
are used to group thematically related subannotations. In Table 2.2,
some domains and their field of application are listed (not complete).
Domain
Area of Use
Analytics
Generation of evaluations using analytic manager,
a system component that evaluates analytical
annotations
OData
Generation of an OData service from the data
obtained from a CDS entity.
EndUserText
Definition of translatable texts
UI
Display of data in user interfaces
VDM
Classification of CDS views for the purposes of
structuring and interpretation
Semantics
Provision of information on the meaning and use
of individual elements of a CDS View
Search
Marking CDS entities as searchable and defining
search properties
ABAPCatalog
Determination of technical settings of the CDS
entity
AccessControl
Access control management
ObjectModel
Definitions of structural and transactional aspects
of the data model

Table 2.2     Important Domains for Annotations
[+]  Tip: Overview of All Annotations
ABAP_DOCU_CDS_ANNOS_OVERVIEW program lists all SAP annotations
and their properties.
The specification @Scope: [#ELEMENT, #PARAMETER] enables you to
define the scope of an annotation. It determines at which positions of
a CDS source code the annotation may be specified. The
specification of a scope is mandatory. Basically, a distinction is made
between annotations with scope at the level of the entire CDS view
and annotations that apply only to individual elements of a view.
If a scope can’t be determined for an annotation or subannotation, a
syntax error will occur. If a scope isn’t specified in subannotations,
those subannotations will adopt the scope of the parent annotation.
So, in Listing 2.8, for the currencyCode subannotation, @Scope:
[#ELEMENT] specifies a scope that differs from the Semantics
annotation: currencyCode isn’t permitted for use with parameters.
Basically, the top level (CDS view, CDS view extension, CDS table
function, CDS role, or CDS annotation definition) or its sublevels
(elements, parameters, or associations) can be specified as the
scope of annotations.
[eg]  Example: Scope of the Scope Annotation
The Scope annotation is an annotation definition annotation (scope
#ANNOTATION) that contains information about the annotation itself.
More simply, it can also be called meta-annotation.
Annotations are typed either as single values, structures, or lists. For
example, Listing 2.8 shows that you can specify the type of an email

address as a list while the annotation currencyCode can be used to
mark an element with a Boolean scalar value as a currency field.
Allowed values (corresponding to the typing) can be specified in the
annotation definition. It’s also possible to set a default value. This
value is used when an annotation is specified without explicitly
assigning a value to it as well. It doesn’t mean that the default value
applies if the annotation isn’t used in the CDS data model.
The way to specify a CDS annotation in a CDS source code in detail
is described by the CDS annotation syntax. That syntax is fixed and
is supplemented by the CDS annotation definition with rules for using
an annotation.
The specification of a CDS annotation for an element within the CDS
source code always starts with an introductory @. This is followed by
the specification of the domain (main annotation) and, separated by
a dot in each case, the specification of the subannotations. The
value of the annotation is then specified after a colon:
@Semantics.currencyCode: true
currency_code as CurrencyCode, 
Semantics is the domain here, currencyCode is the subannotation,
and true is the value.
[»]  Annotation After an Element to be Marked
Specifying annotations after the element to which the annotations
are to be applied in the CDS source code is also possible, but it
then starts with the characters @<:
currency_code as CurrencyCode
@<Semantics.currencyCode: true, 
For readability, it’s best to use the prefixed notation throughout.

[+]  Tip: Help Function in ABAP Development Tools
When specifying annotations, ADT supports you with source code
coloring and code completion. To call the help for an ABAP
annotation, you should position the cursor in the DDL source
editor on the corresponding annotation and press the (F1) key.
When an object that is defined in CDS source code is activated, the
annotations specified there with the CDS annotation syntax are
stored in database tables of the ABAP dictionary, which can then be
accessed for evaluation. The DDHEADANNO table contains the
annotations that apply at the upper level (e.g., at the CDS view
level). The tables DDFIELDANNO and DDPARAMETERANNO contain the
annotations of the individual elements and parameters of a CDS
view, respectively.
The class CL_DD_DDL_ANNOTATION_SERVICE is available for the
evaluation of these database tables. When evaluating, it’s essential
to note that the actual value of an annotation isn’t necessarily
identical to the value specified in the CDS source code for the
annotation. Possible sources of annotation values are:
Direct annotations
Annotations specified directly in the DDL source code of the CDS
entity.
Annotations from metadata extensions
Metadata extensions add further annotations to a CDS entity or
override existing annotations.
Indirect, inherited annotations
When accessing other CDS entities, their direct and indirect
annotations and the annotations from metadata extensions are

inherited. This applies exclusively to annotations at the element
level.
Indirect, derived annotations
Annotations of the EndUserText domain are derived from the field
identifiers of associated data elements. 
The hierarchical structure of CDS data models is reflected in the
determination of annotation values: Higher-level CDS views adopt
annotations of lower-level CDS views. Annotations defined locally in
a CDS view override these inherited annotations. These can be
overwritten by annotations from metadata extensions. The result
thus obtained is referred to as the active annotations of a CDS view.
[+]  Tip: Preventing the Annotations from Being Passed On
You can prevent annotations that are propagated in this way from
being considered for a CDS view by specifying the annotation
@Metadata.ignorePropagatedAnnotations: true with the scope
ENTITY.
If you right-click on the source code in ADT and select Open With •
Active Annotations in the context menu, the active annotations of
the selected CDS entity will be displayed (see Figure 2.26).

Figure 2.26     Display of Active Annotations
We’ll describe how to proceed when creating a metadata extension
in Section 2.6.

2.5    Access Controls
Access controls ensure that only authorized persons are granted
access to protected data.
Corresponding access restrictions can take place at different levels:
Application level
A user doesn’t have the authorization to perform a specific
function (e.g., a transaction).
Record level
Despite the authorization for a function, access to a subset of the
data records is restricted.
Field level
A user is only granted access to individual elements of the
authorized data records.
Protection against unauthorized data access is implemented in
ABAP CDS by an authorization concept, which is based on a data
control language (DCL). The define role statement allows you to
define CDS roles for CDS entities. These roles contain access
conditions that allow you to restrict the result of the data selections.
These access conditions are implicitly evaluated each time the CDS
entity for which the CDS role was defined is directly accessed (using
ABAP SQL, service adaptation description language [SADL] query,
or entity manipulation language [EML]). However, if this CDS entity
only forms the data source for CDS views of a higher hierarchy level,
the access control of the CDS entity remains without effect.
Therefore, when modeling, you must be careful to create a separate
CDS role for each CDS entity for which protection is required.

[ ! ]  Warning: No Access Control for SQL Views
When you access the generated SQL view, the CDS access
conditions won’t be evaluated. For this reason, you should always
use the CDS view in the ABAP SQL statements instead of the
generated SQL view.
To create access control for a CDS view, you must select a package
in the ADT project explorer and choose the path New • Other ABAP
Repository Object • Core Data Services • Access Control from
the context menu. Concerning the name of the CDS role, it’s best to
choose the same name as for the CDS view to which the access
control is to apply. As usual, you’ll be supported by templates (see
Figure 2.27).
Figure 2.27     Templates Available When Creating a CDS Role
Once you’ve created the role using the wizard, you must define the
characteristic of the CDS role in the source code editor. Listing 2.9
shows this using the example of the ZI_Flight role. When the CDS

role is activated, a transportable ABAP development object of type
DCLS (data control language source) is created.
@EndUserText.label: 'CDS role for ZI_Flight'
@MappingRole: true
define role ZI_Flight {
    grant select on ZI_Flight
    where ( CarrierId ) = aspect pfcg_auth( Z_DMO_CAR, 
                                            CARRIER_ID,
                                            ACTVT = '03' )
      and ConnectionId like '04%'; 
} 
Listing 2.9     CDS Role for CDS View ZI_Flight
In Listing 2.9, a user-dependent check for the CDS view ZI_Flight is
combined with a user-independent check. For the user-dependent
check, the classic SAP authorization concept is used, which is based
on authorization objects and their assignment to authorization roles
in Transaction PFCG. Authorizations are assigned to the user via
these authorization roles. In addition, user-independent checks are
made against the value of the ConnectionID element (linked by the
logical AND operator).
A user who is assigned the PFCG authorization role Z_DMO_CARRIER
from Figure 2.28 would, for example, receive the result from
Figure 2.29 as the result of selecting the CDS view ZI_Flight
(without further restriction of the selection conditions).
Figure 2.28     Classic PFCG Authorization Role Z_DMO_CARRIER

Figure 2.29     Selection Result After Querying CDS View ZI_Flight
By implicitly evaluating the access condition when reading records
from the database, the SQL statement is augmented with the WHERE
condition derived from the access conditions, as you can see in the
SQL trace of Transaction SACMSEL (the CDS access control
runtime simulator) (see Figure 2.30).
Figure 2.30     SQL Statement When Reading Records from the ZI_Flight View with CDS
Role ZI_Flight
In contrast, when indirectly accessing CDS view ZI_Flight, for
example, via CDS view ZI_FlightDetail from Listing 2.4, which is
based on it, the access conditions defined in CDS role ZI_Flight
wouldn’t be evaluated. Transaction SACMSEL allows you to test
your CDS roles in detail. In addition to the executed SQL statement,
you can see the result of the data selection and information about
the underlying PFCG authorization roles.
Unlike when you perform authorization checks in the classic ABAP
programming model (where you first read the records to be checked
from the database to the application server so that you can check

them there at the individual record level using the AUTHORITY-CHECK
statement), here you move the authorization logic to the database
level by using CDS roles. This approach allows you to achieve
significant performance gains.
You can store information about documenting and controlling access
using CDS roles in a CDS entity with the annotation
AccessControl.authorizationCheck. In the following list, we’ll
describe the possible expressions of the annotation values:
#CHECK
Access control is to be performed for the CDS entity via a CDS
role (default value of the annotation). If no CDS role exists for the
CDS entity, the syntax check generates a warning message.
#NOT_REQUIRED
Access control isn’t strictly required for the CDS entity. However,
access control is performed if a CDS role is available. The syntax
check warning message about a missing CDS role is omitted.
#NOT_ALLOWED
There’s no access control, even if a CDS role does exist.
#PRIVILEGED_ONLY
This value is used in CDS entities for which direct access to the
data should generally not be allowed (implemented by a condition
in the CDS role that’s never met). Access control for direct access
to the CDS entity can be bypassed by specifying a special ABAP
SQL statement (WITH PRIVILEGED ACCESS), but is otherwise
performed.
To illustrate the use of the #PRIVILEGED_ONLY annotation value, let's
look at the corresponding specification in the standard SAP CDS
view I_USER:

@AccessControl.authorizationCheck: #PRIVILEGED_ONLY
define view I_User
  as select from usr21 
The CDS role I_USER with the same name exists for this view (see
Listing 2.10).
@MappingRole: true
//Deny ALL direct access to I_USER. Only privileged access allowed.
define role I_User { 
  grant select on I_USER 
  where UserID is null and UserID is not null; 
} 
Listing 2.10     CDS Role I_USER (Excerpt)
Because the condition where UserID is null and UserID is not null in
the Where clause of the CDS role is never met, no records are
selected in a direct call. A corresponding message is displayed in the
ADT data preview (see Figure 2.31).
Figure 2.31     Data Preview for CDS View I_USER
In ABAP, this access control can be bypassed by adding WITH
PRIVILEGED ACCESS (see the debugger excerpt in Figure 2.32). Access
control is not executed and the records are selected from CDS view
I_USER according to the selection in ABAP SQL.
Figure 2.32     Debugger for the WITH PRIVILEGED ACCESS Statement

It’s also possible to create multiple CDS roles for one CDS entity.
These are then linked by an OR condition. The result of the selection
can be extended by additional CDS roles, but not restricted. For
clarity, however, you should create only one CDS role per CDS
entity.
An enhancement concept for a modification-free adaptation of the
standard CDS roles provided by SAP is not available. However, by
adding another CDS role whose access condition is always met, you
can override the standard SAP role check. The same applies to the
use of the WITH PRIVILEGED ACCESS addition in the ABAP SQL
statement.

2.6    Extensibility of CDS Entities
CDS entities can be extended without modification to override
standard functionality or add custom functionality:
CDS view extensions enable you to add individual elements to a
CDS view, extend it with associations, or even add aggregate
expressions.
CDS metadata extensions let you override existing metadata or
add additional metadata to a data definition. 
2.6.1    CDS View Extensions
A typical use case for a CDS view extension is the extension of a
standard SAP table with additional customer-specific fields. These
additional fields should also be made available in standard CDS
views based on this table. As an example, we’ve extended the table
MARA by means of an append structure by a field named ZZPREMIUM,
which will be used to mark premium products (see Figure 2.33).
Figure 2.33     Append Structure ZZPREMIUM_MARA with Additional Field
The standard CDS view I_PRODUCT returns data from the MARA table.
This view is now also to be extended to include the ZZPREMIUM field.
For this purpose, you must create a CDS view extension via the
menu path New • Other ABAP Repository Object • Core Data

Services • Data Definition. Select the Extend View template (see
Figure 2.34).
Figure 2.34     Selecting the Extend View Template
Then, complete the source code of the template in the CDS editor,
as shown in Listing 2.11.
@AbapCatalog.sqlViewAppendName: 'ZXIPRODUCTPREM'
@EndUserText.label: 'CDS view extension I_Product'
extend view I_Product with ZX_I_Product_Premium {
    mara.zzpremium as ZZPremium
} 
Listing 2.11     CDS View Extension ZX_I_Product_Premium
Once you’ve activated the extension, the additional field ZZPremium
will be available for use in the CDS view I_Product (see Figure 2.35).
All dependent CDS views are also activated by the activation of the
CDS view extension, so the activation may take some time.
Figure 2.35     Data Preview for CDS View I_Product with the ZZPremium Extension Field

You can create multiple CDS view extensions for one CDS view. The
annotation @AbapCatalog.viewEnhancementCategory controls whether
and how a CDS entity can be enhanced. Possible annotation values
are:
#NONE
A CDS view extension isn’t permitted.
#PROJECTION_LIST
The element list can be enhanced by additional fields (also
calculated ones). Adding additional associations is also allowed.
#GROUP_BY
An enhancement of the element list by aggregate expressions is
only allowed in combination with the #PROJECTION_LIST value.
#UNION
An enhancement of the element list with UNION clauses is only
allowed in combination with the #PROJECTION_LIST value. 
As you have seen, a CDS view extension is quite easy to create.
However, if a CDS view is a view of the top hierarchy level of an
extensive view stack, you’d have to extend all views of the hierarchy
from bottom to top by the additional element. This results in an
increased effort. It can also result in stability issues, as it’s entirely
possible that SAP will replace the CDS view of a hierarchy level with
a differently named CDS view in later releases, which would then
cause syntax errors in the CDS data model.
For this reason, SAP has introduced the concept of extension
include views. An extension include view is a CDS view whose
element list initially consists exclusively of the key fields of the
database table on which a view stack is based. It’s included by
association in the CDS views of the individual hierarchy levels
without exposing them. Figure 2.36 shows, for example, the

inclusion of the extension include view E_Product in the hierarchy of
the CDS views of the material master, A_Product and I_Product.
Figure 2.36     Example: Material Master CDS Views with Extension Include View
To include the ZZPremium field in the top-level A_Product view, only
two steps are required:
1. Extend the extension include view E_Product with a CDS view
extension to include the ZZPremium field, as shown in
Listing 2.12.
@AbapCatalog.sqlViewAppendName: 'ZXEPRODUCTPREM'
@EndUserText.label: 'CDS view  extension  E_Product (extension include view)'
extend view E_Product with ZX_E_Product_Premium {
    Persistence.zzpremium as ZZPremium
}
Listing 2.12     CDS View Extension ZX_E_Product_Premium to Extend the
Extension Include View E_Product
2. Extend the standard view A_Product with the field ZZPremium. Use
the association to the extension include view E_Product (see
Listing 2.13).
@AbapCatalog.sqlViewAppendName: 'ZXAPRODUCTPREM'
@EndUserText.label: 'CDS view extension A_Product'
extend view A_Product with ZX_A_Product_Premium {
    _ProductExt.ZZPremium as ZZPremium
 }
Listing 2.13     CDS View Extension ZX_A_Product_Premium

Now you can also access the ZZPremium field in the A_Product view
(see Figure 2.37). With this approach, no extension of the CDS
views of the intermediate layers (in the example of the CDS view
I_Product) is required for this purpose.
Figure 2.37     Data Preview for CDS View A_Product with Extension Field ZZPremium
[+]  Tip: Key User Extensions
Key users can use the SAP Fiori app Custom Field and Logic to
define additional fields without having to edit CDS source code.
Technically, field extensions performed with this app are created in
the background in the same way as a CDS view extension to an
extension include view.
2.6.2    CDS Metadata Extension
CDS metadata extensions allow you to add additional annotations to
a CDS data model or overwrite existing annotations. The following
requirements must be met:
The use of the annotation in metadata extensions is permitted. In
the annotation definition, this is specified with
@MetadataExtension.usageAllowed: true.
The extension of the CDS entity by means of metadata extension
is permitted. In the CDS entity, this is defined by the specification

@Metadata.allowExtensions: true.
If these prerequisites are missing, error messages are output in the
syntax check when editing.
[+]  Tip: Overview of the Annotations That Can Be Used
The ABAP_DOCU_MDE_ANNOS program lists all annotations that can be
used in metadata enhancements.
A CDS metadata extension is a transportable CDS object of object
type DDLX (CDS metadata extension) and consequently has its own
namespace. Base the naming on the name of the CDS entity to be
extended (with appropriate prefix to identify it as a custom
development, e.g., "Z").
When creating metadata extensions, ADT will support you as usual
with templates. For this purpose, you must select the path New •
Other ABAP Repository Object • Core Data Services • Metadata
Extension. Listing 2.14 shows the source code of the metadata
extension to the CDS view ZI_FlightDetail from Listing 2.4.
@Metadata.layer: #CORE
@EndUserText.label: 'Flight details of current flights'
annotate view ZI_FlightDetail with
{
  @EndUserText.label: 'Flight fully booked'
  FlightOccupied;
} 
Listing 2.14     CDS Metadata Extension ZI_FlightDetail
The translatable text 'Flight details of current flights' defined in
it overwrites the text 'Flight details' defined in the CDS view.
Since this annotation is an annotation with the scope of the view, it’s
specified before the annotate view keyword. The FlightOccupied
view element is a field whose content is calculated in the CDS view.

Since the field is not based on a data element, no translatable text
can be derived. It’s therefore explicitly defined as 'Flight fully
booked' in the metadata extension. All other annotations of CDS
view ZI_FlightDetail remain unchanged.
As a prerequisite you still need to permit the metadata extension for
CDS view ZI_FlightDetail via @Metadata.allowExtensions: true,
otherwise you’ll get an error message like the one shown in
Figure 2.38.
Figure 2.38     Error Message in Case of Invalid Metadata Extension
If there are metadata extensions to a CDS entity, that’s indicated in
the source editor by a spiral icon, as shown in Figure 2.39.
Figure 2.39     Information Window with Existing Metadata Extension
The easiest way to check the effect of the metadata extension is to
view the active annotations in ADT via Open With • Active
Annotations. The source of the EndUserText annotations should be
the metadata extension listed there, as shown in Figure 2.40.

Figure 2.40     Active Annotations of the Extended CDS View ZI_FlightDetail
There can be more than one CDS metadata extension to a CDS
entity. Using the @Metadata.layer annotation, you can assign your
extension to a specific layer. This assignment determines which
metadata extension is used for evaluating the annotation. Each layer
has a certain priority. The possible layers are (in descending priority):
1. #CUSTOMER
2. #PARTNER
3. #INDUSTRY
4. #LOCALIZATION
5. #CORE
For example, annotations from a metadata extension assigned to the
CUSTOMER layer override annotations from a metadata extension
assigned to the PARTNER layer. If more than one metadata extension
is assigned to a layer, the order of evaluation remains undetermined.
You should use the assignment to layers if your data model will be
used by customers, partners, or industries with different
customization requirements.
Swapping annotations to CDS metadata extensions can significantly
improve the readability and maintainability of a data model. In this
way, the specification of the metadata can be separated from the
actual data definition, ensuring adherence to the principle of

separation of concerns. It also allows you to activate and transport
the metadata independently of the actual data definition. In any case,
it’s recommended to outsource all UI annotations (which you use to
define the layout of a user interface) to a metadata extension. This
way you separate the functional aspects from those of the UI. For
readability, you shouldn’t distribute annotations of the same domain
across several metadata extensions.

2.7    Additional CDS Functionality
You may run into a scenario where requirements placed on your
CDS data model are very difficult or impossible to meet with the CDS
functionality presented so far. Examples of such requirements are:
Performing complex calculations
Calling function modules to determine field values
(BAPI_SALESORDER_SIMULATE, ADDRESS_INTO_PRINTLINE)
Mapping a recursive logic
Using data from other systems (via remote function call [RFC])
The use of virtual elements or custom entities allows you to
implement such requirements for your data model. The following
sections will introduce you to these concepts. In addition, the use of
CDS table functions based on ABAP-managed database procedures
and SQLScript is possible, but we don’t use them in this book.
2.7.1    Virtual Elements
Virtual elements are used if you want to include elements in your
CDS data model that aren’t available in the persistence data model
of the database, but are calculated using (complex) ABAP program
logic. The calculation is performed in ABAP classes that implement
interfaces provided for this purpose.
[»]  Calculations Outside the Database
The virtual elements are calculated on the ABAP application
server or the ABAP platform. Note that this means you don’t use

the code pushdown capability (Section 2.1) for these virtual
elements.
You can define a virtual element in the data model by specifying a
designated annotation. To specify the implementing class you need
to specify another annotation. To illustrate this, we’ll extend the CDS
view ZI_FlightDetail from Listing 2.4 with another field that should
contain the day of the week for a flight date. The day of the week is
determined using the function block GET_WEEKDAY_NAME (see
Listing 2.15).
@ObjectModel.virtualElement: true
@ObjectModel.virtualElementCalculatedBy:
            'ABAP:ZCL_FLIGHTDETAIL_CALC_EXIT'
cast ( '' as langt ) as FlightDateWeekday, 
Listing 2.15     Definition of the Virtual Element FlightDateWeekday in the CDS View
ZI_FlightDetail
The first of the two annotations of the ObjectModel domain identifies
the field as a virtual field; with the second annotation, you specify the
ZCL_FLIGHTDETAIL_CALC_EXIT class as the implementation class. In
this class, you implement the interface
IF_SADL_EXIT_CALC_ELEMENT_READ with the following methods:
GET_CALCULATION_INFO
You must use this method to specify which fields of the CDS view
are needed to calculate the virtual element. These fields are
available even if they aren’t requested by the caller (i.e., they have
been hidden in an SAP Fiori interface, for example).
CALCULATE
This method is called after the data selection. Here, you calculate
the value of the virtual element based on the passed data. 
Listing 2.16 shows a possible implementation of the calculation.

CLASS zcl_flightdetail_calc_exit DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC.
  PUBLIC SECTION.
    INTERFACES if_sadl_exit_calc_element_read.
*   INTERFACES if_sadl_exit_filter_transform.
*   INTERFACES if_sadl_exit_sort_transform.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.
 
CLASS zcl_flightdetail_calc_exit IMPLEMENTATION.
 
  METHOD if_sadl_exit_calc_element_read~get_calculation_info.
    IF iv_entity <> 'ZI_FLIGHTDETAIL'.
      RAISE EXCEPTION TYPE zcx_sadl_exit.
    ENDIF.
    LOOP AT it_requested_calc_elements
         ASSIGNING FIELD-SYMBOL(<fs_calc_element>).
      CASE <fs_calc_element>.
        WHEN 'FLIGHTDATEWEEKDAY'.
          APPEND 'FLIGHTDATE' TO et_requested_orig_elements.
        WHEN OTHERS.
          RAISE EXCEPTION TYPE zcx_sadl_exit.
      ENDCASE.
    ENDLOOP.
  ENDMETHOD.
 
  METHOD if_sadl_exit_calc_element_read~calculate.
    DATA lt_original_data
      TYPE STANDARD TABLE OF zi_flightdetail
      WITH DEFAULT KEY.
    lt_original_data = CORRESPONDING #( it_original_data ).
    LOOP AT lt_original_data
         ASSIGNING FIELD-SYMBOL(<fs_original_data>).
      CALL FUNCTION 'GET_WEEKDAY_NAME'
        EXPORTING
          date        = <fs_original_data>-FlightDate
          language    = sy-langu
        IMPORTING
          longtext    = <fs_original_data>-FlightDateWeekday
        EXCEPTIONS
          calendar_id = 1
          date_error  = 2
          not_found   = 3
          wrong_input = 4
          OTHERS      = 5.
      IF sy-subrc <> 0.
*       MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*       WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
      ENDIF.
    ENDLOOP.
    ct_calculated_data = CORRESPONDING #( lt_original_data ).

  ENDMETHOD.
 
ENDCLASS. 
Listing 2.16     Implementation Class for the Virtual Element FlightDateWeekday
[+]  Tip: Interfaces for Filter and Sort Functions
The interfaces IF_SADL_EXIT_FILTER_TRANSFORM and
IF_SADL_EXIT_SORT_TRANSFORM are used to enable filter and sort
functions for a virtual element. You can define the responsible
implementation class via the annotations
@ObjectModel.filter.transformedBy or
@ObjectModel.sort.transformedBy.
Since the virtual element is calculated at the service level on the
ABAP platform and not at the database level, a SELECT statement in
ABAP SQL on the CDS view returns an initial value for the virtual
element (the same applies to the data preview function in ADT).
However, the annotations are evaluated by the SADL framework, so
when queried via an OData entity based on the CDS data model, the
computation is performed by the associated implementation class.
Therefore, one way you can perform a test is to publish your CDS
view as an OData service (with the annotation @OData.publish: true
at the view level) and then test this OData service in the SAP
Gateway client (Transaction /IWFND/MAINT_SERVICE). Figure 2.41
shows the result of this test in our example.

Figure 2.41     OData Service Call in the SAP Gateway Client
[»]  Typing a Virtual Element in a CDS Projection View
The labeling and typing of a virtual element in a CDS projection
view in the ABAP RESTful application programming model
(Section 2.9) differ slightly in their syntax from those described
here. In the example, they would look as follows:
virtual FlightDateWeekday: langt 
The annotation @ObjectModel.virtualElement: true is omitted.
2.7.2    CDS Custom Entities
For read access (i.e., a query) to CDS data models, the ABAP
RESTful application programming model distinguishes between two
approaches:
With a managed query, the data selection is forwarded to the
database via a CDS view and a corresponding SQL query.

In contrast, the unmanaged query is based on a CDS custom
entity that delegates the selection of data to an ABAP class. 
Figure 2.42 compares these two concepts.
Figure 2.42     Managed Versus Unmanaged Query in the ABAP RESTful Application
Programming Model
CDS custom entities thus allow you to implement your own data
selection in ABAP. At the CDS level, only the definition of the
interface remains.
Typical use cases for a CDS custom entity are:
Access to external data source is necessary.
The data access is supposed to take place via an ABAP API.
CDS functionality is not sufficient for data selection.
The functional scope of the CDS access controls isn’t sufficient for
the required authorization checks. 
CDS custom entities are used in the RAP framework as the basis for
data selection of unmanaged queries. However, they can also be
used in transactional RAP applications within business object
modeling. In ABAP CDS, CDS custom entities can be specified as

the target of associations. However, they can’t be used as a data
source for SELECT statements in other CDS entities.
In ABAP programs, a CDS custom entity can also not be used as a
data source of SELECT statements. However, the structured type of
the CDS custom entity is known in ABAP programs and can be
used, for example, after the TYPE addition.
A CDS custom entity can be defined via the define custom entity
statement in the DDL source code. The easiest way to do this is to
use the Define Custom Entity with Parameters template in ADT.
Listing 2.17 shows the syntax for defining a CDS custom entity using
a simple example.
@EndUserText.label: 'CDS Custom Entity Demo'
@ObjectModel.query.implementedBy: 'ABAP:ZCL_CUST_ENTITY_DEMO'
define custom entity zcust_entity_demo
// with parameters parameter_name : parameter_type
{
// Element list, Element annotations
      @UI.selectionField: [{position: 10}]
      @UI.lineItem: [{position: 10}]
  key UserName  : xubname;
      @UI.lineItem: [{position: 20}] 
      FirstName : ad_namefir;
      @UI.lineItem: [{position: 30}] 
      LastName  : ad_namelas;
      FullName  : ad_namtext; 
} 
Listing 2.17     Definition of a CDS Custom Entity
The annotation @ObjectModel.query.ImplementedBy at the view level
references the ABAP class in which the query is implemented. Since
the data types can’t be derived from an underlying database table or
CDS entity, the element list of a CDS custom entity must be typed.
Optionally, you can declare view-level and element-level metadata, a
parameter list, or associations in the element list.

The query implementation class implements the interface
IF_RAP_QUERY_PROVIDER and its Select method. Note that all functions
(e.g., sorting, filtering, paging) that are provided by default in a
managed query must be explicitly programmed here. In the following
example, SAP user data is supposed to be queried via the Business
Application Programming Interface (BAPI) BAPI_USER_GETLIST.
Listing 2.18 shows an excerpt of the implementation. For the
complete implementation of the example, you should refer to the
SAP documentation on the ABAP RESTful application programming
model at http://s-prs.de/v868503.
CLASS zcl_cust_entity_demo DEFINITION
...
  PUBLIC SECTION.
    INTERFACES if_rap_query_provider.
...
ENDCLASS.
 
CLASS zcl_cust_entity_demo IMPLEMENTATION.
  METHOD if_rap_query_provider~select.
 
    DATA(lv_top)    = io_request->get_paging( )->get_page_size( ).
    DATA(lv_skip)   = io_request->get_paging( )->get_offset( ).
    DATA(lt_clause) = io_request->get_filter( )->get_as_sql_string( ).
...
    DATA lt_userlist TYPE STANDARD TABLE OF bapiusname.
    DATA lt_result TYPE STANDARD TABLE OF zcust_entity_demo.
...
    TRY.
        DATA(lt_filter_cond) = io_request->get_filter( )->
                                                    get_as_ranges( ).
      CATCH cx_rap_query_filter_no_range INTO DATA(lx_no_sel_option).
    ENDTRY.
 
    TRY.
        IF io_request->is_data_requested( ).
          CALL FUNCTION 'BAPI_USER_GETLIST'
            EXPORTING
              with_username = abap_true
            TABLES
              userlist      = lt_userlist
              return        = lt_bapiret.
* Filter
          LOOP AT lt_userlist INTO DATA(ls_userlist).
            DATA(lv_tabix) = sy-tabix.
            LOOP AT lt_filter_cond INTO DATA(ls_filter_cond).
              CASE ls_filter_cond-name.

...
* Sorting
          IF lt_sort IS NOT INITIAL.
            LOOP AT lt_sort INTO DATA(ls_sort).
...
* Paging
          IF lv_top > 0.
            LOOP AT lt_userlist INTO ls_userlist FROM lv_skip 
                                         + 1 TO ( lv_skip + lv_top ).
              MOVE-CORRESPONDING ls_userlist TO ls_result.
              APPEND ls_result TO lt_result.
...
* Count
          IF io_request->is_total_numb_of_rec_requested( ).
            io_response->set_total_number_of_records( lines( 
                                                       lt_result ) ).
          ENDIF.
          io_response->set_data( lt_result ).
        ELSE.
*         no data is requested
        ENDIF.
      CATCH cx_rap_query_provider INTO DATA(lx_exc). "error handling
    ENDTRY.
 
  ENDMETHOD.
ENDCLASS. 
Listing 2.18     Implementation Class of the CDS Custom Entity
After creating a service definition and a service binding (see
Chapter 6), you can test the query directly in ADT. Figure 2.43 shows
the result of the query in the data preview.
Figure 2.43     Preview of the OData Service Output for CDS Custom Entity
ZCUST_ENTITY_DEMO

2.8    Virtual Data Model
As mentioned in Section 2.1, SAP provides a data model based on
CDS views with SAP S/4HANA, the virtual data model (VDM). This
isn’t simply a collection of individual CDS views; the VDM strictly
follows a hierarchical structure arranged in layers. There are also
precise specifications for the naming of the CDS views and their
elements. Strict adherence to them is intended to ensure the
homogeneity of the virtual data model and avoid redundancies.
VDM is intended to be an easy-to-understand data model that
provides SAP business data. Unlike the more technically oriented
database tables, it is oriented towards business data or business
objects. As a descriptive model of business data, it’s based on the
existing database model.
The VDM forms the basis for data access in SAP S/4HANA. This
applies to the analytical and transactional applications and to the
available APIs. In addition to internal SAP use, parts of the VDM are
also released for developments by SAP customers or partners.
Figure 2.44 shows the Properties view of ADT, which provides
information on the release status of a CDS view in the API State
area.

Figure 2.44     Release of CDS Views
Figure 2.45 shows the layered structure of the VDM from different
CDS view types.
Figure 2.45     Hierarchy of CDS Views in the Virtual Data Model
The tasks of the individual view types differ from layer to layer:
Basic interface views
Basic interface views are located directly above the database level
and are the only view type that selects data directly from the
database tables. They form the data basis for other CDS views. In
doing so, they replace the difficult-to-understand, technical field
names with names oriented to business logic. This name
conversion is done exclusively in the basic interface views.
There’s exactly one basic interface view for each business object
to avoid redundancies in the VDM. With the help of associations,
the relationships to other business objects as well as to texts and
foreign keys can be established. Field-level annotations add
descriptive information (@Semantics), such as whether a field is a

currency field or a date field. At the view level, basic interface
views are marked with the annotation @VDM.viewType: #BASIC.
The following naming convention applies: Basic interface views
start with the prefix I_. For example, I_PurchasingDocument is the
basic interface view for purchasing document business data.
Composite interface views
Composite interface views don’t have direct access to the
database tables. Instead, they combine basic interface views and
other composite interface views to create a new view of the
business data. For example, in the composite interface view
I_PurchaseOrder, which accesses the basic interface view
I_PurchasingDocument, the business object “purchase order” is
formed by a specialization relationship from general purchasing
document data:
where I_PurchasingDocument.PurchasingDocumentCategory = 'F' 
The names of composite interface views also start with the prefix
I_. @VDM.viewType: #COMPOSITE is used as the view type.
Composite interface views are designed for reuse. Together with
the basic interface views, they form the interface view layer of the
VDM.
Consumption views
Consumption views are based on the interface views and
represent the top level of the VDM. Unlike interface views, they
are each defined for a very specific purpose, such as for use in
analytic or transactional apps, and provide the data required for
that purpose. They are therefore geared to concrete application-
specific requirements and aren’t intended for reuse. The view type
is @VDM.viewType: #CONSUMPTION; the name of a
consumption view starts with the prefix C_. 

The annotation @VDM.viewType is used to structure the CDS views
and is informative in nature. This information is evaluated, for
example, in the SAP Fiori app View Browser (see Figure 2.46). This
application outputs a list of available CDS views and their properties
(e.g., type, release status, description, annotations). It’s very useful
for searching released CDS views based on various search criteria.
Figure 2.46     View Browser
In addition to the described central types, there are several other
types of CDS views available in the VDM. Extension include views,
which you already learned about in Section 2.6.1, (@VDM.viewType:
#EXTENSION, prefix E_), for example, allow you to add more fields to a
standard CDS view. The extensions are then implemented using
CDS view extensions (@VDM.viewExtension: true, prefix X_).
The private views, which are defined with the prefix P_ and the
annotation @VDM.private: true, are helper views to support the
definition of other VDM views that are only used internally by SAP.
They aren’t intended for reuse.
Remote API views with the prefix A_ and the annotation
VDM.lifecycle.contract.type: #PUBLIC_REMOTE_API are used to
define OData or SOAP services that can be used to access the
functionality of a business object (for more information, see the SAP
API Business Hub at http://s-prs.de/v868504).
The consistent application of the naming conventions for the CDS
views and their elements is crucial for the homogeneity and
comprehensibility of the VDM. The name of an entity should always
describe its meaning as accurately as possible. It should also be

unique, meaning that no two different entities can use the same
name.
Somewhat simplified, the name of a CDS view in the VDM consists
of three components (see Table 2.3): a prefix, the core part of the
name, and an optional suffix. The camel-case notation and the
English language are used as a matter of principle.
Prefix
Name Core (Semantic
Name)
Suffix
Mandatory
Component
Yes
Yes
No
Contents
VDM view
type
followed by
underscore
Meaningful business-
oriented name of the data
projected by the view (in
singular)
Purpose
Examples
C_, I_, A_
PurchasingDocument,
SalesOrderItem,
ProductCategory
Query, TP,
ValueHelp
(or VH)
Table 2.3     Structure of Names of CDS Views in the VDM
For example, C_PurchaseOrderTypeValueHelp is a CDS view that can
be used as a value help for purchase document types.
C_SalesOrderQuery is an analytical query based on sales order data.
Customer views are prefixed with a namespace abbreviation such as
Z or Y as usual.
The names of the individual elements of a CDS view also describe
the contents of the element as precisely and unambiguously as
possible. The structure of the name depends on the type of a field
(see Table 2.4).
Field Type
Meaning
Examples

Field Type
Meaning
Examples
Identifier
Unique ID of the entity
(e.g., the order number of
a purchase order);
optionally, with suffix (ID,
UUID)
PurchaseDocument,
Product, UserID,
BusinessPartnerUUID
Code
A value from a list of
values (e.g., a currency, a
purchase order type, a
material type)
Currency,
PurchaseOrderType
Characteristic Contains the truth value
of a statement
ReleaseIsNotCompleted,
OrderIsScheduled,
Time, Date,
Time
Information about the
creation time of an entity,
for example
CreationDateTime,
LastChangeDate,
CreationTime
Table 2.4     Structure of CDS View Field Names in the VDM (Excerpt of Field Types)
We recommend that you follow the VDM architecture principles and
naming conventions when building your own CDS data models.

2.9    CDS Language Elements for Modeling
Business Objects
In this section, we’ll describe other CDS language elements and
CDS view types that play a significant role, especially in business
object modeling with the ABAP RESTful application programming
model. The sample CDS views used in the preceding sections, and
the CDS views of the VDM, are ABAP dictionary-based CDS views
created with the define view statement. A key feature of this view
type is that when it gets activated, the SQL view specified in the
@AbapCatalog.sqlViewName annotation will be created in the ABAP
dictionary.
Since ABAP 7.55, another CDS view type is available with the CDS
view entity, which you can create using the define view entity
statement. The basic functionalities correspond to those of the ABAP
dictionary-based CDS views. However, CDS view entities provide
some advantages:
No additional SQL view needs to be created during activation.
The nonuniform naming of CDS entity and SQL view is thus also
obsolete.
The syntax has been optimized (e.g., there are extended
possibilities when using the Where clause).
There’s a stricter syntax check (for example, for the annotations). 
Additional benefits have been announced for future releases. In SAP
S/4HANA, both view types will coexist for the foreseeable future. For
data modeling in the ABAP RESTful application programming model,

you should use the CDS view entity view type, not least because of
the technical improvements.
In Section 2.3, we described how you can use associations to
represent relationships between CDS entities. Figure 2.47 shows an
example of the hierarchical structure of a business object. To
describe this type of business object structure with its relationships,
the ABAP RESTful application programming model uses some CDS
language elements we haven’t described yet.
Figure 2.47     Business Object Structure (Source: SAP)
The root keyword is used to set an entity as the root entity of the
business object hierarchy. The root entity has the following
characteristics:
Each business object structure has exactly one root entity.
The root entity may have child entities defined by the keyword
composition [] of as composition; that is, as a specialization of the
association stating that the child entity doesn’t exist without the
parent entity.
A root entity has no parent entity. The association to parent
keyword isn’t allowed in root entities.

Besides its structure, it’s the behavior that characterizes a business
object. The behavior describes the possible operations of a business
object (e.g., create, change, delete, actions), its general properties
(e.g., locking logic, authorization check, numbering), and properties
of its individual elements. In the ABAP RESTful application
programming model, the behavior of a business object is defined in
the behavior definition. This is a CDS object (object type BDEF)
specifically intended for use in the ABAP RESTful application
programming model, in which you define the behavior of the
business object using the language elements of the CDS behavior
definition language (BDL).
The behavior definition always refers to the CDS data model
underlying the business object, and, more precisely, to the root entity
of the data model. Each root entity has a maximum of one behavior
definition. In it, the behavior of the child entities of the CDS data
model is also handled. The actual implementation of the behavior
takes place in one or more ABAP classes (the behavior pool). The
statement for defining a behavior definition is define behavior for
<Entity>. You specify the implementing class after implementation in
class. Chapter 3 and Chapter 5 describe BDL and behavior
implementation in detail.
CDS projection views form another CDS view type that’s used in the
ABAP RESTful application programming model. With their help, you
can enable the flexible use of a business object. Namely, the
projection contains exactly the subset of the business object
structure and behavior that is relevant to a particular service. It thus
reflects a limited view of a CDS entity, tailored to a very specific
application. In addition, service-specific information that doesn’t
belong to the actual core of the data model, such as UI annotations,
is defined in the projection layer.

Through this concept you have more flexibility in the use of a
business object. It also increases the stability of a service. The
underlying data model can be extended without affecting an existing
service. In CDS projection views, you use the syntax element as
projection on <ProjectedEntity> to map the relationship to the
underlying CDS entity.
In the ABAP RESTful application programming model, the data and
behavior of a business object is made available to the consumer
through a REST-based business service. A business service
consists of a service definition and a service binding. The service
definition exposes the data model and associated behavior to be
exposed. The service binding specifies the type of service and the
communication protocol to be provided to the consumer. This
separation makes the service definition protocol independent: It can
be used in multiple service bindings with different protocols.
The service definition is a RAP-specific CDS object, which is of
object type SRVD that you create by using the define service
statement of the CDS service definition language (SDL). After the
expose keyword, you then specify the names of those CDS entities
that are to be made available. If you expose multiple CDS entities in
a service definition, they should be semantically related. For
example, along with the root entity, you usually expose other CDS
entities of the underlying CDS data model. You can learn more about
business services in Chapter 6.
[+]  Tip: Additional Information about Core Data Services
In this chapter, you’ve learned about the main concepts of CDS. A
complete and detailed description of ABAP CDS can be found in
the book Core Data Services for ABAP by Renzo Colle, Ralf
Dentzer, and Jan Hrastnik (SAP PRESS).


3    Behavior Definition
In this chapter, you’ll learn how to add a behavior definition to a
data model defined with core data services (CDS), and enrich
it with the desired transactional behavior and business logic
using the behavior definition language.
In the previous chapter, you learned how to model the structure of a
business object in CDS. For read-only operations (queries) on a
business object, this modeling is already sufficient. But what
happens if you want to add write operations or business logic (i.e.,
behavior) to this business object and its child entities? This chapter
describes how you can create a behavior definition for that purpose.
After a short introduction in Section 3.1, we’ll show you how to create
behavior definitions in ABAP development tools (ADT) in
Section 3.2. In Section 3.3, Section 3.4, and Section 3.5, we’ll go into
more detail about some general concepts of behavior definition, such
as the definition of the different implementation types, strict mode,
and entity behavior definitions. In Section 3.6, you’ll learn how to
define a behavior pool, which you’ll then flesh out later in the
behavior implementation.
The subsequent sections deal in greater detail with concrete
behavior that you can define. Section 3.7 deals with the method of
numbering. In Section 3.8, you’ll learn about field properties for the
CDS data model. Section 3.9 is about field mappings, Section 3.10
describes standard operations, and Section 3.11 deals with specific

operations. Section 3.12 covers concurrent access and locking
behavior, Section 3.13 describes the definition of internal business
logic, Section 3.14 covers authorization checks, and Section 3.15
describes draft handling. Section 3.16 concludes this chapter with
some overarching concepts of behavioral definition.
3.1    What is a Behavior Definition?
The CDS behavior definition (hereafter referred to as behavior
definition) is the central development object for declaring the
behavior of a business object via the behavior definition language
(BDL). When you add a behavior definition to a CDS root entity,
you’re defining a RAP business object.
3.1.1    Context and Structure of a Behavior Definition
In Figure 3.1, you can see the artifacts in which a behavior definition
is embedded. A RAP business object consists of a CDS data model
and of behavior. You can create a behavior definition for a CDS root
entity so you can add transactional behavior. There can only be one
such definition for a CDS root entity. No behavior definition can be
created for other CDS entities that are not root.

Figure 3.1     Artifacts for the Definition of a RAP Business Object
The behavior declared via BDL requires a suitable behavior
implementation in ABAP. Either the ABAP RESTful application
programming model provides the corresponding behavior (e.g., a
standard operation), or the respective application implements it.
Depending on the application, mixed forms are also frequently
encountered. For more information on this, Section 3.3.
A RAP application can consist of more than one RAP business
object if the data model of the application provides for this and the
business mapping requires it. Different RAP business objects might
also refer to each other or invoke an appropriately exposed behavior
(e.g., an update operation or an action).
As an example, let's look at the behavior definition of the Travel
business object from the ABAP flight reference scenario. It
represents a trip that consists of multiple bookings (CDS child entity
Booking). The Travel business object is represented by the CDS root
entity /DMO/I_Travel_D. Since there can only be one behavior
definition for a CDS root entity, its name is also /DMO/I_Travel_D. In
ABAP development tools (ADT), this behavior definition can be
found in the Project Explorer under Core Data Services •
Behavior Definitions (see Figure 3.2).

Figure 3.2     Behavior Definition /DMO/I_TRAVEL_D in the Project Explorer
[»]  Projection Behavior Definition
The development objects /DMO/C_TRAVEL_A_D, /DMO/C_TRAVEL_D_D,
and /DMO/I_TRAVEL_D, shown in Figure 3.2, are projection behavior
definitions, which represent a special type of behavior definition.
For more details on this, see Chapter 6, Section 6.1.2.
Double-clicking on the behavior definition /DMO/I_Travel_D takes you
to the ADT editor, where the BDL source code is displayed (see
Figure 3.3).
Figure 3.3     BDL Source Code of Behavior Definition /DMO/I_Travel_D
A behavior definition is divided into four areas:
 Header of the behavior definition
 Area of the entity behavior definition
 Header of the entity behavior definition with transactional
properties
 Body of the entity behavior definition
The head of the behavior definition starts with the implementation
type selection. In this example, managed declares that the managed
1
2
3
4

scenario should be used for the RAP business object. This area also
defines properties that apply to the entire composition tree of the
business object, such as draft handling (with draft).
For each CDS entity of the composition tree, an entity behavior
definition can now follow. Thus, there might be one or more entity
behavior definitions within a behavior definition. An entity behavior
definition consists of a head and a body.
The entity behavior definition is introduced with the define behavior
for statement and forms the beginning of the head section. Then,
you can define a behavior pool via implementation in class (this is
also possible at the behavior definition level; Section 3.6). You can
also declare other transactional properties of the CDS entity. For
example, in the managed scenario, the database table for the CDS
entity is set via persistent table.
The head section is followed by the body of the entity behavior
definition. This is enclosed in curly brackets { ... } and contains
additional keywords that specify the behavior of the CDS entity. For
example, the BDL statements create, update, and delete specify that
this CDS entity can be created, updated, and deleted. With action,
you can declare an action (i.e., a specific operation, on the CDS
entity), which you can implement later in the behavior pool (here:
action ... acceptTravel or action ... rejectTravel).
In Figure 3.3, due to space constraints, we’ve shown only one entity
behavior definition of the Travel business object, namely the
mandatory definition for the CDS root entity. However, the Travel
business object consists of the additional CDS child entities
/DMO/I_Booking_D and /DMO/I_BookSuppl_D, which in turn have their
own entity behavior definition, and, together with the CDS root entity,
they form the composition tree of the business object (see
Figure 3.4).

Figure 3.5 illustrates the relationship between a business object's
CDS entities, that business object's behavior definition, and the
entity behavior definitions it contains.
Figure 3.4     Additional Entity Behavior Definitions of the Travel Business Object
Figure 3.5     Relationship between Behavior Definition and CDS Entities
3.1.2    Syntax of a Behavior Definition
In Listing 3.1, you can see the behavior definition of the Travel
business object. We’ve shortened it considerably to illustrate the
general BDL syntax with this example.
managed;
strict;
with draft;
 
define behavior for /DMO/I_Travel_D alias Travel
implementation in class /dmo/bp_travel_d unique
persistent table /dmo/a_travel_d
...
{
   create;

   update;
   delete;
 
   association _Booking { create; }
   validation validateCustomer on save { create; field CustomerID; }
} 
Listing 3.1     BDL Syntax Based on the Behavior Definition for the /DMO/I_Travel_D
Object
The general syntax of the BDL is based on the CDS syntax. The
following rules apply:
Keywords
BDL keywords, such as managed or define behavior for, are
written in lowercase. A mixture of lowercase and uppercase letters
is not allowed.
Ending of statements
Statements usually end with a semicolon (;). This is not the case
for statements in the context of the entity behavior definition and
its transactional properties.
Names or identifiers
Names or identifiers, such as the name of the validation
validateCustomer, are not case sensitive. Here, the name of the
validation is given in camel-case notation for readability. Because
of this rule, another validation called ValidateCustomer would
result in a syntax error because it has already been declared.
Numbers and underscores in the name are allowed.
Comments
A line comment is introduced by a double slash //. This can be
placed anywhere within a line. All characters following the double
slash are treated as comments. A multiline comment is introduced
by the string /* and ends with */. Text that’s between these
characters is treated as a comment.

3.1.3    Possible Behavior
This section provides an overview of the possible behaviors you can
equip a RAP business object with. In the ABAP RESTful application
programming model, the behavior is also summarized under the
term, features. By features we mean the functions of a business
object. In addition, in this section, we'll look at the effects of declaring
behavior using the BDL in the behavior definition. This way you can
assess what behavior is available to you when designing a business
object. Secondly, you’ll see the impact BDL statements have, not
only in initial design, but also when you want to make changes to the
behavior definition and when there are already business object
consumers.
Overview of Features
We assign the behavior of a RAP business object to the following
categories:
Transactional behavior and properties
Standard operations
Specific operations
Internal business logic
Fields
Overarching elements
If a business object supports write operations, other aspects become
technically relevant, such as the persistence of the business data or
the handling of concurrent accesses in the event of changes. The
ABAP RESTful application programming model summarizes these
aspects under the terms, transactional behavior and properties. In

the context of application development, you might think about how
authorization checks (authorization), lock behavior (lock, etag, etag
total), numbering (numbering), or persistence of data (persistent
table) are implemented. Furthermore, you can activate draft
handling (with draft) and, thereby, use the draft mode built into the
ABAP RESTful application programming model for a business object
(see Table 3.1).
Behavior
BDL Keyword
Properties
Authorization
Checks
authorization master
authorization
dependent by ...
Behavior implementation
required
Lock
Behavior
(Pessimistic
Method)
lock master
lock dependent by ...
Managed by the RAP
framework; behavior
implementation required in
the unmanaged scenario
Lock
Behavior
(Optimistic
Method)
etag master
etag dependent ...
total etag
Managed by the RAP
framework
Numbering
early numbering
late numbering
Behavior implementation
required
Numbering
(UUID)
field
k1(numbering:managed) Managed by the RAP
framework
Persistence
persistent table ...
Managed by the RAP
framework
Draft
Handling
with draft;
draft table ...
draft action ...;
draft determine
action ...;
Managed by the RAP
framework; behavior
implementation for draft
action possible
Table 3.1     Overview of Transactional Behavior and Properties

Standard operations are operations that create (create), update
(update), or delete (delete) instances of a CDS entity. These
operations make changes to the business object’s CDS entities and,
thus, count as write operations. Standard operations also include
reading the business object’s CDS entities and locking, in the
context of a pessimistic locking procedure (see Table 3.2).
Behavior
BDL
Keyword
Properties
Create
Change
Delete
create;
update;
delete;
Business-object-externally visible,
callable
Read
Locks
read;
lock;
Business-object-externally visible,
callable
Explicit specification of read and lock
only for implementation groups and the
unmanaged scenario
Creation
via
Association
association
_a1 {
create; }
Business-object-externally visible,
callable
Reading
via
Association
association
_a1 { }
Business-object-externally visible,
callable
Table 3.2     Overview of Standard Operations
Specific operations on a RAP business object are operations that go
beyond general CRUD operations, and have a functional reference
to the business object. These include actions (action) and functions
(function, see Table 3.3).
Behavior BDL
Keyword
Properties

Behavior BDL
Keyword
Properties
Action
action a1
...;
static
action a2;
Business-object-externally visible,
callable; write operation
Function
function f1
...;
static
function f2
...;
Business-object-externally visible,
callable; operation without side effects
Table 3.3     Overview of Specific Operations
Internal business logic refers to all functionally-motivated program
logic within business objects that’s used to implement business
processes. While this is broad and also applies to actions, for
example, here we explicitly refer to internally visible business logic
(i.e., logic that isn’t visible and consumable from outside the
business object). The ABAP RESTful application programming
model provides validation and determination for this purpose, as
well as the determine action, which makes it possible to call
validation and determination together (see Table 3.4).
Behavior
BDL
Keyword
Properties
Determination
determination
d1 ... on
modify;
determination
d2 ... on
save;
Business object-internal;
calculation during interaction
phase or save sequence, with side
effects
Validation
validation v1
... on save;
Business object-internal; data
check of the transaction buffer
without side effects

Behavior
BDL
Keyword
Properties
Determination
Action
determine
action da1
{...}
Business object-external;
determinations or validations
declared as externally callable
Table 3.4     Overview of Internal Business Logic
The fields of a business object are determined by the fields of the
respective CDS entity. In the context of the behavior definition and
the standard write operations already described, you can decide
which fields are mandatory (field(mandatory:create)) or which fields
are unchangeable (field(readonly)). You can also define a field
mapping (mapping) and thus make field mappings between structured
ABAP dictionary objects and a CDS entity, and use them in the
behavior implementation (see Table 3.5).
Behavior
BDL
Keyword
Properties
Field
Properties
field
(...) f1,
f2, fn;
Business object-external; declare fields as
mandatory or protect against write
accesses
Field
Mappings
mapping
... {...}
Business object-internal; field mappings
can be used in the behavior pool
Table 3.5     Overview of Fields
In the last category, we have grouped BDL keywords that have an
overarching character. That is, these keywords can’t stand alone, but
add certain properties to standard or specific operations. For
example, you can mark certain elements as only internally visible
(internal) or use a dynamic feature control to determine at runtime
whether or not a field is protected against write access (features).

Additionally, you can declare a preliminary check (precheck) for an
operation performed on the RAP business object (see Table 3.6).
Behavior
BDL Keyword
Properties
Dynamic
Feature
Control
features:instance
features:global
Dynamic determination of field
properties, standard operations,
and actions; behavior
implementation required
Preliminary
Check of
Operations
precheck
Check for feasibility of standard
operations or actions before
transaction buffer is reached;
behavior implementation
required.
Visibility
internal
The BDL feature is only internally
visible.
Table 3.6     Overview of Cross-Sectional BDL Keywords
Effects of Behavioral Declarations
If you declare behavior in the behavior definition, this has various
effects on both business object-internal and business object-external
artifacts of a RAP application (see Figure 3.6).
Figure 3.6     Features of the Behavior Definition and Surrounding Artifacts

The BDL keywords impact the following areas:
Business object interface
Using the features in the behavior definition, you can design the
external interface of the RAP business object that consists of read
and write operations. This can comprise the standard CRUD
operations (and a possible locking operation in the context of
pessimistic locking), actions, and functions. If a RAP business
object supports only the create and update operations, but not the
delete operation, you can declare only the corresponding standard
operations create and update, but not delete. The business object
interface also includes the fields of the respective CDS entities
defined via the CDS data model and any field properties (field)
specified in the behavior definition.
[+]  Tip: Lean Interface for a RAP Business Object
Select only the behavior that is useful and necessary for the
functionality of the business object, since all features are
components of the business object interface. If a standard
operation can only be used internally in the business object (for
example, the create or update operation), you can use the
additional internal operation (Section 3.16.3).
Provision of the behavior implementation
The behavior definition also allows you to influence the way in
which a RAP business object is implemented, and thus how the
operations provided in the business object interface will come into
effect. This concerns, for example, the choice of the
implementation type. For example, you can use the managed
business object provider (managed) or the draft handler of the RAP
framework (with draft).

When you declare behavior via the BDL that requires a method
implementation (e.g., a validation or action), you enable the
corresponding method in the behavior implementation and can
implement it. The behavior definition can thus be viewed as an
interface implemented by one or more classes. In addition, BDL
behavior also affects the derived data types in the context of
behavior implementation and EML consumers.
Business services
The business object interface has external characteristics, but
initially can only be called locally via the EML. The RAP business
object with its remote interface, which was first exposed to OData
via a business service, is then found in the metadata of the OData
service, and in the usable operations of the OData service.
So, for example, if you have exposed a web API based on a RAP
business object for integration purposes, then it’s important to
keep this external interface compatible and know that the
behavioral definition or artifacts of the projection layer can have a
direct impact on it, like when a field that was previously modifiable
is now protected against write access.
SAP Fiori elements UI
Even though the behavior definition in isolation has no direct
impact on a SAP Fiori elements UI, the default operations, for
example, are still exposed via the OData metadata and
represented as buttons in a SAP Fiori elements UI. Draft handling
also affects the SAP Fiori elements UI via the declaration in the
behavior definition and represents UI elements that implement
draft handling.

3.2    Editing a Behavior Definition in ABAP
Development Tools
In this section, we’ll show you how to use ADT to create, update,
activate, and search for a behavior definition. The behavior definition
is an independent development object in the ABAP repository. It’s
assigned to a package and connected to the transport system. It can
be maintained exclusively via ADT.
3.2.1    Creating a Behavior Definition
In Figure 3.2, you’ve already seen how a behavior definition is
displayed in ADT’s Project Explorer. There are now two ways you
can create a behavior definition in ADT:
Creation with direct reference to the CDS root entity
You must use the context menu to select the CDS root entity for
which you want to create the behavior definition.
Creation via the creation wizard to the behavior definition
development object type
Here, you manually select the CDS root entity during the creation
process.
If you want to create a behavior definition via the context menu, you
should proceed as follows:
1. In the Project Explorer, select the CDS root entity for which you
want to create the behavior definition.
2. Right-click on the CDS root entity to open the context menu, and
select the New Behavior Definition entry (see Figure 3.7).

Figure 3.7     Creating a Behavior Definition with Reference to the CDS Root Entity
3. A dialog box opens, as shown in Figure 3.8. Here, the Name
and Root Entity fields are already predefined by the CDS root
entity selection (here: ZI_TRAVEL_M).
4. Enter an appropriate description for your behavior definition
under Description and select the desired implementation type
under Implementation Type. For our example, we chose
Managed. Confirm your entries by clicking the Next button.
Figure 3.8     Dialog Box for Creating a Behavior Definition

5. Create a new transport request or select an existing one.
Confirm your entry by using the (Enter) key.
The project explorer display will refresh and you’ll see the newly
created behavior definition (see Figure 3.9).
Figure 3.9     The New Behavior Definition ZI_TRAVEL_M in the Project Explorer
After the creation, the editor for the BDL source code of the behavior
definition ZI_TRAVEL_M opens (see Figure 3.10). The coding is already
suggested here based on the selected implementation type. For
example, you’ll find the managed keyword in the behavior definition
head, the entity behavior definition for the selected CDS root entity
ZI_TRAVEL_M, and the standard operations, create, update, and
delete. Furthermore, the alias addition (//alias <alias_name>) is
suggested in the entity behavior definition when initially created. We
recommend directly assigning a suitable, descriptive alias name.
Figure 3.10     BDL Source Code Editor for the New Behavior Definition ZI_TRAVEL_M

The gray diamond icon that you can see on the 
 icon in the editor
tab indicates that the behavior definition is still in an inactive state.
You can also select the creation via the wizard for the behavior
definition object type. Here, you want to proceed as follows:
1. Open the creation wizard via the menu path File • New • Other
or using the keyboard shortcut (Alt) + (N).
2. Select the ABAP • Business Services node and then the
Behavior Definition development object type (see Figure 3.11).
Confirm your selection by clicking the Next button.
Figure 3.11     Selecting the Behavior Definition via the Creation Wizard
3. The dialog window for creating the behavior definition will open
(see Figure 3.8). Click the Browse button next to the Root
Entity input field and select the CDS root entity for which you
want to create the behavior definition. Confirm your entries by
clicking the Next button.

[»]  Name of Behavior Definition Can’t be Changed
The behavior definition name always corresponds to the CDS
root entity name since there can only be one behavior definition
for a CDS root entity. Consequently, you can’t change the name.
4. Create a new transport request or select an existing one.
Confirm your entry with the (Enter) key.
Next, let's look at how you can change and activate a behavior
definition.
3.2.2    Changing and Activating a Behavior Definition
Follow these steps if you want to change a behavior definition:
1. Double-click the behavior definition in the project explorer.
2. The behavior definition editor with the BDL source code will
open.
3. Update the BDL source code. In addition to manual entries, you
can also use the auto-complete function (see Figure 3.12). To do
this, position the cursor where you want to add code (e.g., in the
body of the entity behavior definition), and use the keyboard
shortcut (Ctrl) + (Space).

Figure 3.12     Using Auto-Completion in the BDL Editor
4. Choose a suitable keyword and confirm your selection using the
(Enter) key. Make necessary additions so that the syntax of the
keyword is correct.
5. Save the BDL source code via the Save button (
) or use the
keyboard shortcut (Ctrl) + (S).
You can activate the behavior definition via the Activate button (
)
or the keyboard shortcut (Ctrl) + (F3).
As is the case with many other development objects, you can view
details about your behavior definition in the Properties view. The
activation status (here it is Inactive) can be seen behind the field
label Version (see Figure 3.13).
Figure 3.13     Activation State of the Behavior Definition

3.2.3    Finding and Opening a Behavior Definition
Proceed as follows if you want to search for a behavior definition that
has already been created:
1. Open the dialog for searching development objects via the
button 
 for opening development objects in the toolbar or via
the shortcut (Ctrl) + (Shift) + (A). We recommend using the
shortcut. The general use of shortcuts can speed up the
handling of ADT. ADT provides shortcuts for many development
tasks.
2. In the search box, type “type:” and then press the (Ctrl) +
(Space) keys. Select the development object type BDEF
(Behavior Definition) to restrict the search to this type (see
Figure 3.14).
Figure 3.14     Restricting a Search Run to Behavior Definitions
3. Enter the behavior definition name you want to find in the search
field. You can use wildcards (e.g., “Z*TRAVEL*”).
4. The results list for the entered search query will appear (see
Figure 3.15). Double-click the relevant entry to open the

behavior definition.
Figure 3.15     Searching for a Behavior Definition by Wildcard with Result List
3.2.4    Documenting Behavior Definitions and
Relationships
You can document various development objects via knowledge
transfer documents (KTD), which also includes the behavior
definition. With KTDs, you document various elements of the
behavior definition, such as the create operation or an action, using
Markdown syntax, a simplified markup language. To create a KTD,
you want to right-click to open the context menu of your behavior
definition and select New Knowledge Transfer Document (see
Figure 3.16).
Figure 3.16     Creating a KTD for a Behavior Definition

[»]  Behavior Extensions
In Figure 3.16, you can also see the context menu item New
Behavior Extension. However, at the time of printing this book,
these extensions aren’t yet available.
You can maintain Markdown-based documentation in the
Documentation section of the Source tab. In the Object Structure
section, you must select the behavior definition element you want to
document (here, the create operation). To preview the
documentation, select the Preview tab (see Figure 3.17).
Figure 3.17     Documenting the Create Operation in Markdown Syntax
If a KTD exists, the behavior definition editor displays a
corresponding Open Documentation option (see Figure 3.18).
Figure 3.18     Jump to Documentation in the Behavior Definition
[»]  Documenting Other RAP Artifacts
You can also document a CDS entity or a projection behavior
definition using a KTD.

The Relation Explorer is a separate view in ADT that allows you to
view contextual information about a business object (or other
development object). You can choose whether you want to see the
development object in question in the overview, in the context of its
users or in the context of the development objects used.
You can open the Relation Explorer (see Figure 3.19) in the editor of
the behavior definition via the context menu path Show In • Relation
Explorer.
Figure 3.19     Business Object ZI_TRAVEL_M in the Relation Explorer
The documentation created for an element in the previous section
can also be viewed in the Relation Explorer. To do this, select the
Show Element Information entry in the context menu or press the
F2 function key (see Figure 3.20).
Figure 3.20     Documentation for the Create Operation in the Relation Explorer

3.3    Implementation Types
The implementation type is your first specification in the behavior definition. You use
it to specify the source of the RAP business object implementation. The
implementation type names two sources (see Figure 3.21):
Managed
SAP provides the implementation through the RAP framework. The
implementation can be done by a business object provider or the draft handling
provider, or both in combination.
Unmanaged
The RAP business object provides the implementation via the behavior pool
(unmanaged business object provider).
The implementation type applies to all CDS entities of the business object
composition tree. It isn’t possible to declare one CDS entity as managed and another
as unmanaged.
Figure 3.21     Implementation Types of a Behavior Definition
In Table 3.7, we’ve summarized each implementation type of a RAP business object
and indicated in each case the responsibility for providing the implementation.
Implementation
Scope
Managed Managed
with
Additional
Save
Managed
with
Unmanaged
Save
Unmanaged

Implementation
Scope
Managed Managed
with
Additional
Save
Managed
with
Unmanaged
Save
Unmanaged
Standard
Operations in
the Interaction
Phase and in
the Transaction
Buffer
RAP
RAP
RAP
Custom implementation
Complete Save
Sequence
RAP
RAP
RAP (except
SAVE)
Custom implementation
SAVE Phase of
the Save
Sequence (see
Section 5.5.4)
–
Custom
Custom
–
Specific
Operations and
Internal
Business Logic
Custom
Custom
Custom
Custom implementation;
validations/determinations
only in draft mode
Table 3.7     RAP Business Object Implementation Deployment by Implementation Type
[»]  Projection Behavior Definition
You can use projection to declare the implementation type of a projection
behavior definition that’s based on a behavior definition. Chapter 6 provides more
information about this implementation type.
3.3.1    Managed Scenario
You can use the managed keyword if you want to use the managed business object
provider to implement the RAP business object (see Listing 3.2). The managed
business object provider implements CRUD operations across the interaction phase
and save sequence.
managed;
 
define behavior for /DMO/I_Travel_M alias Travel
persistent table /DMO/TRAVEL_M... 
Listing 3.2     Managed Implementation Type for a RAP Business Object

In the managed scenario, the ABAP RESTful application programming model takes
care of saving changes to the transaction buffer for you and stores them in the
database. For this purpose, you must specify the database table in the entity
behavior definition using persistent table, followed by the database table name.
This specification is only relevant in the managed scenario.
[»]  Using Field Mappings
If you use persistent table, specifying a field mapping between the database
table and the CDS entity with mapping is necessary or recommended (Section 3.9).
The following save options are available in the managed scenario:
Unmanaged save
Here you can implement the save process yourself.
Additional save
Here you can implement additional save logic.
This allows you to influence the save sequence. But all other properties of the
managed implementation type are still valid.
In the following sections, we’ll first describe the behavior definition level specification
that applies to all CDS entities of a business object's composition tree. Finally, we’ll
demonstrate how you can also declare a save option specifically for a CDS entity.
[»]  Other Combinations of the Save Options
It’s also possible to combine the save options at the behavior definition level with
those at the level of the respective CDS entity.
Unmanaged Save
By using the managed scenario with unmanaged save, you can implement the save
process within the save sequence yourself. The default save implementation (see
Section 5.5.4) of the managed business object provider is not run in this case. You
can specify this using the addition with unmanaged save:
managed with unmanaged save;
 
define behavior for ZI_SalesOrder alias SalesOrder
... 

If you specify the save option in the behavior definition head, it applies to all CDS
entities. However, you can also define the save option at the level of the respective
CDS entity (see the upcoming section regarding the save options at the CDS entity
level).
You can add and cleanup to the unmanaged save option. This allows you to
implement the cleanup method in the behavior pool later:
managed with unmanaged save and cleanup;
 
define behavior for ZI_SalesOrder alias SalesOrder
... 
[»]  Using Persistent Table Not Permitted
If you use the managed scenario with unmanaged save, the specification of
persistent table is not allowed because you implement the save process within
the save sequence yourself. The specification can therefore no longer be
meaningfully evaluated by the RAP framework.
Additional Save
If you want to add your own save logic to the process in the save sequence (whether
with managed or with unmanaged save), you can use the addition with additional save:
managed with additional save;
 
define behavior for ZI_SalesOrder alias SalesOrder
... 
This allows you to implement the update of simple change documents at a later
stage, for example. Here you can also use the addition and cleanup. The same rules
for specifying this save option in the behavior definition apply for the save option
with unmanaged save, too.
Save Options at the CDS Entity Level
You can also individually declare the additional or unmanaged save for one or more
CDS entities at the entity behavior definition level (see Listing 3.3).
managed implementation in class ... unique;
strict;
 
define behavior for ZI_SalesOrder alias SalesOrder
with additional save
... 

Listing 3.3     Additional Save at the CDS Entity Level
The declaration of the unmanaged save would look like the following at this point:
...
define behavior for ZI_SalesOrder alias SalesOrder
with unmanaged save
... 
3.3.2    Unmanaged Scenario
You can use the unmanaged keyword to declare the unmanaged implementation type
for a RAP business object. In the behavior pool, you make the full implementation of
the interaction phase and save sequence in this case. Here you need to specify a
global ABAP class as behavior pool in the header of the behavior definition using the
keyword implementation in class (see Listing 3.4).
unmanaged implementation in class /DMO/BP_TRAVEL_U unique;
strict;
 
define behavior for /DMO/I_Travel_U alias Travel
... 
Listing 3.4     Using the Unmanaged Scenario
We’ll describe the implementation process for this case in Chapter 5, Section 5.5.
Chapter 11 contains a use case for the unmanaged scenario.
[»]  Abstract Implementation Type
You can alternatively declare an abstract implementation type using the abstract
keyword. This behavior definition is based on an abstract CDS entity. This
implementation type is intended for typing of parameters (of actions or functions).
Only a severely limited set of syntactic elements is available. You can’t declare
transactional behavior there.

3.4    Strict Mode
The keyword strict allows you to specify that a stricter syntax check
of the BDL source code should be performed (see Listing 3.5).
managed implementation in class /DMO/BP_TRAVEL_M unique;
strict;
 
define behavior for /DMO/I_Travel_M alias Travel
... 
Listing 3.5     Strict Mode Definition in the Behavior Definition Head
The stricter syntax checks are based on ABAP RESTful application
programming model best practices and they ensure that the RAP
business object remains stable against changes in the programming
model. For example, if the strict mode is used in the unmanaged
scenario, you must define the locking and authorization behavior for
each CDS entity. Otherwise, the behavior definition can’t be
activated. Using strict mode also ensures that you must declare
implicit behavior explicitly in the BDL source code. We recommend
that you use the strict mode by default for your behavior definitions.

3.5    Entity Behavior Definition
You can use define behavior for, followed by the CDS entity name,
to initiate an entity behavior definition. You can specify any of the
CDS entities in the business object composition tree, but at a
minimum you must specify the CDS root entity (see Listing 3.6):
managed implementation in class /DMO/BP_TRAVEL_M unique;
strict;
 
define behavior for /DMO/I_Travel_M alias Travel
...
 
define behavior for /DMO/I_Booking_M alias Booking
...
 
define behavior for /DMO/I_BookSuppl_M alias Booksuppl
... 
Listing 3.6     Different Entity Behavior Definitions Within a Behavior Definition
The alias addition enables you to use a descriptive name for the
CDS entity. This is in contrast to the technical name of the CDS
entity, which must be unique within the ABAP dictionary, satisfy
certain naming conventions, and be created in a specific
namespace. The alias name is used as an identifier in derived data
types to refer to the respective CDS entity. This facilitates access to
the business object via entity manipulation language (EML).
[ ! ]  Warning: Alias Name is Visible Outside the Business
Object
Note that the alias name is an externally visible identifier. It can be
used both internally on the part of behavioral implementation and
by external consumers via the EML. Changing the alias name can
therefore lead to syntax errors on the consumer side. For this

reason, you should assign the alias name wisely and change it
with caution.
Also, this affects not only the alias name, but also all other
declarations of the behavior definition that belong to the externally
visible part of the RAP business object.
With the addition external '<external name>', you can assign
another meaningful name for the CDS entity whose length isn’t
limited to 30 characters. This external name isn’t visible in ABAP
programs, but can be found in the metadata of the OData service in
which the CDS entity was exposed.

3.6    Defining a Behavior Pool
Depending on the implementation type and declared behavior, you
need a separate implementation for this (e.g., separate numbering,
action, determination, etc.). You can do this in the behavior pool, a
special ABAP class. You can declare one or more behavior pools at
different levels of the behavior definition:
RAP business object: Level of the behavior definition
CDS entity: Head of the entity behavior definition
CDS entity: Body of the entity behavior definition
Thus, it’s also possible to distribute the implementation to several
behavior pools for a RAP business object and to combine the
specified levels according to certain rules. This allows for parallel
work on a RAP business object and also leads to better
comprehensibility if there’s a direct mapping of the CDS entity to the
behavior pool.
3.6.1    Behavior Pool for Behavior Definition
You can declare a behavior pool in the head of the behavior
definition. This way you can implement all the necessary behavior for
all CDS entities of the RAP business object in one place. You make
the declaration with implementation in class, followed by the name
of the implementation class, and end it with unique (see Listing 3.7).
managed implementation in class /DMO/BP_TRAVEL_M unique;
strict;
 
define behavior for /DMO/I_Travel_M alias Travel
... 

Listing 3.7     Declaring a Behavior Pool in the Head of the Behavior Definition
The addition unique is mandatory and ensures that implemented
behavior is applied without overlap.
Specifying a behavior pool at the behavior definition level is optional.
However, if you need to implement the save sequence yourself
because the keywords unmanaged, with additional save, or with
unmanaged save are specified, you absolutely need a behavior pool at
the behavior definition level for this. This also applies when the save
option is defined at the CDS entity level, as shown in Listing 3.3.
3.6.2    Behavior Pool for the CDS Entity
You can declare a behavior pool for each CDS entity within the
behavior definition and implement the associated behavior there
(except for a save option defined there; see Listing 3.8).
define behavior for /DMO/I_Travel_D alias Travel
implementation in class /dmo/bp_travel_d unique
...
 
define behavior for /DMO/I_Booking_D alias Booking
implementation in class /dmo/bp_booking_d unique
... 
Listing 3.8     Behavior Pool at the Level of CDS Entities
You can also combine the specification of a behavior pool at the
behavior definition level with the specification at the CDS entity level.
In this case, you must implement the save sequence in the behavior
pool of the behavior definition and specific behavior of the CDS
entities in the associated behavior pools (see Listing 3.9).
managed with additional save implementation in class 
                                        zbp_i_salesorder_save unique;
strict;
 
define behavior for ZI_SalesOrder alias SalesOrder

implementation in class zbp_i_salesorder unique
...
define behavior for ZI_SalesOrderItem alias Item
implementation in class zbp_i_salesorderitem unique
... 
Listing 3.9     Behavior Pools for the Behavior Definition and the CDS Entities
Specifying a behavior pool at the CDS entity level is optional. If no
behavior pool is specified here, you want to make the
implementation of the CDS entity's behavior in the behavior pool of
the behavior definition.
3.6.3    Behavior Pool for the Implementation Group
Implementation groups enable you to distribute implementation-
relevant behavior of a CDS entity to separate behavior pools. If you
use implementation groups for a CDS entity, you mustn’t declare a
behavior pool for the CDS entity. The global specification at the
behavior definition level, however, is still permitted. For this reason, if
you use implementation groups, each implementation-relevant
behavior must be associated with an implementation group.
You use the keyword group followed by the name of the
implementation group (here it is grpCancelation) and the
specification of the responsible behavior pool to declare an
implementation group. The behavior you want to implement in the
specified behavior pool must be enclosed in parentheses. In
Listing 3.10, for example, the action cancel is supposed to be
implemented.
define behavior for ZI_SalesOrder alias SalesOrder
...
{
  create;
  update;
  delete;
 

  group grpCancelation implementation in class 
                                       zbp_i_salesorder_cancel unique
  {
    action cancel result [1] $self;
  }
  group ...
  { ... }
} 
Listing 3.10     Defining an Implementation Group for an Action
[+]  Tip: Meaningful Use of Implementation Groups
You should use implementation groups only if you want to
distribute behavior across more than one implementation group.
This is necessary if you want to enable parallel working within a
CDS entity and thus have to use different behavior pools. For
example, you can group functionally related behavior into an
implementation group.
The name of the implementation group must be different from the
name of the respective behavior. For example, there mustn’t be a
cancel action if there’s an implementation group with the same
name, and vice versa. Implementation groups act only business-
object-internally, so you can change the name and structure of
implementation groups without violating the interface contract with
consumers.

3.7    Numbering
The type of numbering is a central aspect of an application that plays
an important role already in the data modeling phase. In the
following sections, we’ll describe the basic principles of numbering in
the ABAP RESTful application programming model and show you
the options provided for this by the programming model in the
behavior definition.
Using numbering, you specify in the behavior definition for the
respective CDS entity how its key fields are supplied with values
when an instance of the CDS entity is created. The numbering is
thus relevant to the standard operations create and create via
association. They are applied in the interaction phase and in the
save sequence.
It’s useful to distinguish between temporary and permanent key
values:
A temporary key value uniquely identifies a newly created
instance only in the transaction buffer. This is necessary, for
example, to access the instances or to establish associations
between instances of different CDS entities of the business object
composition tree in the transaction buffer.
A permanent key value is the final key value with which the
instance is persistently stored and permanently identifiable.
Using RAP numbering, you can define the way in which a permanent
key value is assigned. The time of the numbering and the origin of
the permanent key value are important in this context:

Time
The time determines when the numbering takes place. Here, we
distinguish between early or late numbering. The early numbering
takes place within the interaction phase, the late numbering takes
place within the save sequence.
Origin
The origin defines whether the key value is set business object-
externally or business object-internally. For external numbering,
the key value needs to be specified by the consumer (e.g., an end
user via the user interface or an EML consumer). Internal
numbering means that the key value is assigned business object-
internally.
In the following sections, we’ll take a closer look at the possible
combinations of time and origin and show you how you can specify
them in the behavior definition. The possible combinations are:
Early, external numbering
Early, internal numbering
Late, internal numbering
In the context of numbering, it’s also important to check and report
(to the user, for example) as early as possible whether or not the
selected key value is unique. This check is called a uniqueness
check in the ABAP RESTful application programming model. Its
implementation depends on the type of numbering:
Implementation for internal numbering
In the case of internal (early or late) numbering, the
implementation of the check (for example, via a number range)
must ensure the uniqueness of the assigned key value. For
universally unique identifier (UUID) key values, a check for
uniqueness isn’t necessary.

Implementation for external numbering
For external numbering, the check can be performed by the RAP
framework in the managed scenario without draft handling and for
active instances with draft handling. Otherwise, you must provide
for the implementation of the uniqueness check via a precheck
(Section 3.16.2) or, for draft instances, via the resume action
(Section 3.15.3).
3.7.1    Early, External Numbering
Early external numbering is the default numbering behavior for the
CDS entity. You don’t need to explicitly specify anything in the
behavior definition for this. Consumers set the permanent key value
during the interaction phase. This type of numbering is useful for
meaningful key values or if you want to explicitly allow the consumer
to assign external numbers, for example in interface scenarios.
[eg]  Example: Assignment of Material Numbers
The CDS root entity “Material” with a key field Material number can
provide for early external numbering. In this way, a user can
assign a material number by himself or herself according to
company-specific rules.
3.7.2    Early, Internal Numbering
You can use the early numbering keyword to declare early numbering
for a CDS entity (see Listing 3.11).
define behavior for ZI_SalesOrder alias SalesOrder
early numbering
...

{
  ... 
Listing 3.11     Declaring Early, Internal Numbering
You can use early internal numbering in the managed and in the
unmanaged scenario with draft handling and implement numbering
yourself.
[»]  Method in Behavior Implementation
Using the early numbering keyword requires an implementation of
the FOR NUMBERING method in the handler class (see Chapter 5,
Section 5.4.11).
A variant of early, internal numbering is the use of UUIDs to identify
the created instances. The RAP framework provides this feature by
default, so this is a form of managed numbering.
To declare early, internal numbering, you must use the field
statement with the field property numbering : managed and specify the
corresponding key field (here it is SalesOrderUuid; see Listing 3.12).
define behavior for ZI_SalesOrder alias SalesOrder
...
{
  field ( numbering : managed ) SalesOrderUuid;
  ...
} 
Listing 3.12     Early, Internal Numbering with UUIDs
For more details on setting field properties with the field statement
(e.g., to protect key fields against business-object-external write
access external), Section 3.8.
[+]  Tip: Using UUID Numbering

In Chapter 9, you can find a practical example of how to use UUID
numbering.
3.7.3    Late Numbering
Late numbering occurs as part of the save sequence, just before the
instances are saved to the database. This can be used, for example,
to ensure that instances are numbered without gaps.
You usually use number range intervals to implement late
numbering, for example for an invoice or purchase order number.
Another use case could be the assignment of a meaningful key
according to a certain system. A new material number, for example,
could be derived from certain values of the instance to be saved,
such as the material type, the business field, and the version status.
These values aren’t already known at the time when create is
deployed, but only at the time of saving.
You can use the late numbering keyword in the head of each entity
behavior definition to declare late numbering for a CDS entity (see
Listing 3.13).
define behavior for ZI_SalesOrder alias SalesOrder
late numbering
...
{
  // Set key field to "read only"
  field ( readonly ) SalesOrderId;
  ...
} 
Listing 3.13     Declaring Late Numbering
For the SalesOrder entity, late numbering is declared here. The
SalesOrderId key field can be provided with a value within the save
sequence via a number range, for example.

[»]  Method in Behavior Implementation
When you specify late numbering, you must implement the
ADJUST_NUMBERS method of the save handler in the behavior
implementation (see Chapter 5, Section 5.5.3).
Late numbering is available in both the managed and unmanaged
scenario. This is true irrespective of whether or not you use draft
handling for the RAP business object. However, late numbering in
the managed scenario is only available with SAP BTP, ABAP
environment 2111 and SAP S/4HANA 2021 FPS01.
[»]  Composite Keys of CDS Child Entities
If a CDS child entity has a composite key and thus includes the
key of the CDS parent entity, late numbering must also be used for
the CDS child entity.

3.8    Field Properties
When you add behavior to a CDS data model, all fields of the entity
are usable for the standard operations, create, create-by-
association, and update. That’s not always what you want. Usually
you want to define precisely which fields should be accessible in the
context of these operations. That way you can define the interface of
the respective operation. These field properties are declared using
the BDL keyword field.
[»]  Checks for External Consumers Only
Note that restrictions you’ve made for certain fields apply only to
external consumers of the RAP business object. Within the
behavior implementation, corresponding checks, such as those
specified by field( mandatory:create ), are not performed.
Managed numbering via UUIDs is also specified with a field
property. For details, Section 3.7.2.
3.8.1    Mandatory Fields
With field( mandatory ) f1, ..., fn; you can define one or more
fields as mandatory fields for write operations. This concerns the
operations create, create-by-association, and update. The
respective field will then be marked as mandatory in the user
interface. However, you must initiate the check to determine whether
it has actually been maintained (e.g., in the form of a validation)
(Section 3.13.2).

With field( mandatory:create ) f1, ..., fn; you specify for the
specified fields that they are mandatory fields in the context of the
operations, create and create-by-association (see Listing 3.14).
define behavior for ZI_SalesOrder alias SalesOrder
...
{
  field ( numbering : managed ) SalesOrderUuid;
  // Set key to read only
  field ( readonly ) SalesOrderUuid;
  field ( mandatory : create ) SalesOrderType;
  ... 
Listing 3.14     Mandatory Fields for the Create Operation
For the fields provided with the mandatory:create field property, the
RAP framework checks whether they have been filled. If that’s not
the case, a runtime error(BEHAVIOR_MANDATORY_FIELD) will be thrown.
Thus, no testing takes place within the behavior implementation.
You can generally use this field property for fields that have to be
provided with values by the consumer in the creation process (e.g., a
key value for external numbering). It also makes sense to assign this
field property to fields that must be provided with data as part of a
creation operation so that the business object instance can be run in
a meaningful way, for example, a document type SalesOrderType of a
SalesOrder entity.
3.8.2    Protection Against Write Access
With field( readonly ) f1, ..., fn; you protect the specified fields
from external write access; that is, their values can’t be set by the
operations create, create-by-association, or update. If an external
consumer tries to change a read-only field, a runtime error will be
triggered.

In Listing 3.15, you see the example of a Person entity that has a
PersonUuid key field, and administrative fields CreatedAt and
CreatedBy. The key fields or administrative fields are only open for
read access.
define behavior for ZRAP_I_Person_M alias Person
...
{
  field ( numbering : managed ) PersonUuid;
  field ( readonly ) PersonUuid;
  field ( readonly ) CreatedAt, CreatedBy,
                     LastChangedAt, LastChangedBy;
  ... 
Listing 3.15     Setting Key Fields or Administrative Fields to readonly
In Listing 3.16 you can see an example of a foreign key field (here it
is PersonUuid, to which the Address entity belongs) that is protected
against write access via readonly.
define behavior for ZRAP_I_Address_M alias Address
...
{
  field ( numbering : managed ) AddressUuid;
  field ( readonly ) PersonUuid, AddressUuid;
   ... 
Listing 3.16     Setting Foreign Key Fields to readonly
Read-only fields are used in the following cases, for example:
Key fields for internal numbering
Fields for creating (composition) associations (foreign key fields)
Administrative fields, such as the creation or modification
timestamp
Other calculated fields, such as a status or an amount calculated
via a determination
With field ( readonly:update ) f1, ..., fn; you specify that the
specified fields are protected against write access only during update

operations. The field is thus open during the create and create-by-
association operations.
3.8.3    Combination: Mandatory Field in Case of
Creation, Write Protection in Case of Updates
With field ( mandatory:create, readonly:update ) f1, ..., fn; you
can combine a field both as a mandatory field in the create case and
as a read-only field in the update case (see Listing 3.17).
define behavior for ZRAP_I_Person_K_U alias Person
...
{
  field( mandatory : create, readonly : update ) PersonId;
   ... 
Listing 3.17     Mandatory Field Combined with Write Protection for Updates
A frequent use case for this combination are controlling fields (e.g.,
for a document type) that have to be maintained at the time of
creation and can’t be updated later. Key fields in the context of
external numbering also play an important role.
[»]  Setting Field Properties Dynamically
You can also use the ABAP RESTful application programming
model to determine the field properties at runtime. To learn how to
do this, Section 3.16.1.

3.9    Field Mappings
With field mappings you can map the fields of a CDS entity to fields
of a structured data type (a database table or structure) from the
ABAP dictionary. The following use cases exist for this:
Field mapping between database table and CDS entity
Field mapping between structure and CDS entity
Field mapping between control structure and CDS entity
Field mapping between structure and input parameter of an action
In the managed scenario, you can use persistent table to specify
the database table where instances of the respective CDS entity are
stored (Section 3.3.1). We recommend that you assign meaningful
field names in the CDS entity, so that the names are different from
the names of the respective columns in the database table. For this
reason, you must use mapping for to declare a field mapping for the
CDS entity between the CDS entity and the database table which
has been declared via persistent table in the behavior definition
(see Listing 3.18).
define behavior for ZRAP_I_Person_M alias Person
persistent table zrap_a_ph
...
{
  mapping for zrap_a_ph corresponding
  {
    PersonUuid = person_uuid;
    Surname = surname;
    GivenName = given_name;
    DateOfBirth = date_of_birth;
    CreatedAt = created_at;
    CreatedBy = created_by;
    LastChangedAt = last_changed_at;
    LastChangedBy = last_changed_by;
  }

   ...
} 
Listing 3.18     Field Mapping Between Database Table and CDS Entity
With the addition corresponding, you can ensure that fields with the
same name are mapped, even if they aren’t explicitly listed.
A field mapping is also useful if you call existing ABAP
modularization units, such as function modules, in the behavior
implementation and the structures used in the interface are different
from the fields of the corresponding CDS entity. This may be the
case, for example, if you want to integrate the API of an existing
application into the ABAP RESTful application programming model.
Let’s suppose you want to use a business application programming
interface (BAPI) within a behavioral implementation to create orders
(see Chapter 10). You can define a field mapping between the BAPI
interface data types (here, it’s bapimepoheader) and the CDS entity
(see Listing 3.19).
...
  mapping for bapimepoheader corresponding
  {
    PurchaseOrder = po_number;
    PurchasingOrganization = purch_org;
    PurchasingGroup = pur_group;
    Supplier = vendor;
  }
... 
Listing 3.19     Field Mapping Between a BAPI Data Type and CDS Entity
This central definition in the behavior definition allows you to use
field mapping both in behavior implementation and in value
assignments between the structured data type and the
corresponding CDS entity. This is possible in both directions. We’ll
first show you an assignment with the CDS entity as the source:

DATA ls_po TYPE bapimepoheader.
ls_po = CORRESPONDING #( po_entity MAPPING FROM ENTITY ). 
In this next example, you can see the reverse case, namely the
assignment of the mapped structured data type bapimepoheader with
the CDS entity as the target:
DATA ls_po TYPE bapimepoheader.
DATA ls_po_entity TYPE zi_rap_purchaseorder_m.
ls_po_entity = CORRESPONDING #( ls_po MAPPING TO ENTITY ). 
BAPIs often provide parameters consumers can use to define which
fields are to be changed when the BAPI is called (called checkbox
structures). A RAP business object provides these types of
structures by default in the interface of standard operations (%CONTROL
structure; see Chapter 4, Section 4.1.1), which can be consumed
via the EML and evaluated within the behavior implementation. For
this reason, you can add the data type of the control structure to a
field mapping using the control addition (see Listing 3.20).
...
  mapping for bapimepoheader control bapimepoheaderx corresponding
  {
    PurchaseOrder = po_number;
    PurchasingOrganization = purch_org;
    PurchasingGroup = pur_group;
    Supplier = vendor;
  }
... 
Listing 3.20     Field Mapping for Control Structures

3.10    Standard Operations for a CDS Entity
The standard operations for the CDS entities of a business object
include the CRUD operations (create, read, update, and delete). We
distinguish between standard operations that are executed directly
on the CDS entity and those that are executed via associations.
[»]  Business Object-Internal and Business Object-External
Consumers
Operations can be consumed both business object-internally and
business object-externally if they haven’t been explicitly declared
as internal (Section 3.16.3). When we refer to consumers in the
following sections, we always mean both business-object-internal
consumers (the behavior implementation) and business-object-
external consumers.
3.10.1    Create, Read, Update, and Delete
Standard write operations on a CDS entity include the creation
(create), update (update), and deletion (delete) of business object
instances. These operations perform changes to the data of a
business object and can basically be specified optionally. The read
operation is always implicitly available and doesn’t need to be
explicitly declared.
Accordingly, the keywords create, update, and delete allow you to
specify which of the standard write operations the CDS entity
supports; that is, which operations must be implemented depending
on the implementation type (see Listing 3.21).

define behavior for /DMO/I_Travel_M alias Travel ...
...
{
  // Standard operations for the travel entity
  create;
  update;
  delete;
  ...
} 
Listing 3.21     Example of Declaring Standard Operations
You can use create to specify that the CDS entity supports the
create operation. Thus, consumers can create new instances of the
CDS entity. The CDS entity is used to declare one or more key fields
that must be populated during the creation operation. Numbering to
uniquely identify the created instances across a RAP transaction
plays an essential role (Section 3.7). The non-key fields of the CDS
entity are populated as part of the creation operation. You can use
field properties to specify which fields are mandatory or open for
write access (Section 3.8).
[»]  Create Operation Only for CDS Root Entity
The create operation can be declared only for CDS root entities.
CDS child entities are created using the create-by-association
operation (Section 3.10.2).
With update, you define that instances of the respective CDS entity
can be updated. The operation passes corresponding non-key fields
to the CDS entity for modification. The instance to be changed is
identified by the values of the key fields. These values are set as
part of the create operation and by their very nature can’t be
changed.
You can use delete to specify that instances of the respective CDS
entity can be deleted. The instance to be deleted is identified in each

case by the values of the key fields. During the interaction phase, the
instances to be deleted are flagged in the transaction buffer; during
the save sequence, the instance is persistently deleted from the
database.
3.10.2    Create and Read Operation by Association
Composition associations (composition of) and to-parent
associations (association to parent) link CDS entities to each other
and form the composition tree of a RAP business object. In the
behavior definition, you can define these associations using the
standard operations, create-by-association (create-by-association
[CBA]) and read-by-association (read-by-association [RBA]). The
update and delete operations are declared directly for the respective
CDS child entity.
[+]  Tip: Explicitly Specifying Associations
If you don’t explicitly specify the create-by-association and read-
by-association operations in the behavior definition, they will still
be implicitly available for composition and to-parent associations.
However, we always recommend declaring the operations
explicitly in the behavior definition.
Read-by-Association
With the read-by-association operation, you grant consumers read
access to the instances of CDS entities of the association target. You
can read instances of the subordinate CDS child entities and the
instance of the CDS parent entity.

You do this using the association keyword followed by the
association name and empty curly brackets (see Listing 3.22). This
example defines the reading of instances of the CDS child entity
(i.e., in the direction of the composition association from the CDS
data model).
define behavior for ZI_SalesOrder alias SalesOrder
...
{
   association _Item { }
} 
Listing 3.22     Read-by-Association in the Direction of the Composition
Let’s suppose there is a SalesOrder entity (sales order) that consists
of Item instances (items). The Item instances for the respective
SalesOrder instance can then be read via the linked _Item
association.
[»]  Read Operation by Association as a Prerequisite
You need the read operation by association as a prerequisite for
declaring authorization checks (Section 3.14) or locking behavior
(Section 3.12). The RAP framework uses these operations to read
the respective master instance.
If you want to support reading the respective parent instance, you
should define the already mentioned association operation in the
CDS child entity (see Listing 3.23). This example defines reading the
instance of the CDS parent entity (i.e., in the direction of the to
parent association from the CDS data model).
define behavior for ZI_SalesOrderItem alias Item
...
{
   association _SalesOrder { }
} 

Listing 3.23     Read Operation by Association in the Direction of a to parent Association
With this declaration it’s possible to read the corresponding
SalesOrder instance starting from an Item instance.
Create-by-Association
With the create-by-association operation, you allow consumers to
create one or more instances of a CDS child entity from its parent.
This assumes an existing instance of the CDS parent entity. The
operation can be performed only in the direction of the CDS child
entity.
You can use the association keyword to declare the operation,
followed by the association name and supplemented by the create
operation (see Listing 3.24).
define behavior for ZI_SalesOrder alias SalesOrder
...
{
  association _Item { create; }
} 
Listing 3.24     Declaration of Create and Read Operations by Association
This allows you to create one or more Item instances based on a
SalesOrder instance, which are associated with each other. It means
that a foreign key relationship is established. The declaration of the
read-by-association operation is thus supplemented by the create
operation. The create-by-association operation can therefore only
be declared together with the read-by-association operation.

3.11    Specific Operations for a CDS Entity
Beyond the standard operations, additional, specific operations can
be declared for a CDS entity in the ABAP RESTful application
programming model. These operations must then be implemented in
the behavior pool. The following specific operations are possible:
Actions
Functions
The use of actions and functions is optional.
3.11.1    Actions
An action is a specific operation of a CDS entity that can perform
business object-internal or business object-external change
operations. An action is therefore always a write access. You can
use it to implement your own business logic in the behavior pool. An
action is declared in the BDL with the keyword action, followed by
the name of the action. It’s always assigned to a concrete CDS entity
of the business object composition tree.
By default, an action is instance-based; that is, it applies to concrete
instances of the respective entity. For example, a SalesOrder entity
that provides an instance-based cancel action (to cancel the
SalesOrder instance) is conceivable here. When this action gets
executed, it performs all the functionally defined changes that make
up the cancellation of a sales order, such as a change in status.
Listing 3.25 shows this by using the instances of the SalesOrder
entity as an example.

define behavior for ZI_SalesOrder alias SalesOrder
...
{
   ...
   action cancel;
} 
Listing 3.25     Declaration of an Instance-Based Action
In addition to instance-based actions, there are also static actions. A
static action isn’t performed on concrete instances of the entity, but
applies to the entire entity. It maps cross-instance logic and is
introduced with the keyword static. For example, an Address entity
could have a markDuplicates action that identifies duplicates among
all Address instances and marks them as such (see Listing 3.26).
define behavior for ZI_Address alias Address
...
{
   ...
   static action markDuplicates;
} 
Listing 3.26     Declaration of a Static Action
Static actions are often factory actions. We’ll describe this particular
type of action in the upcoming section about factory actions.
Input Parameter
You can define exactly one input parameter for actions and thus
parameterize the behavior of the action. This applies to both
instance-based and static actions.
You can use the parameter keyword followed by the appropriate data
type to provide the action with an input parameter. The input
parameter can have one of the following structured data types:
A structured data type from the ABAP dictionary

An abstract CDS entity
The CDS entity for which the action was defined
The last option is relevant only for static actions since actions are
instance-based by default.
[»]  Advantages of Structured Parameters
You may wonder why RAP actions (and functions) support only
one input or return parameter and why you can’t declare a set of
parameters, in the way you’re used to, from classical
modularization units like function blocks or methods. The
parameter data types are structured data types (e.g., from the
ABAP dictionary or abstract CDS entities) in which you can include
a set of fields. This way you can map multiple parameters. If new
fields are added, you only have to maintain them in one place,
namely in the data type. Wherever the data type in question is
used (e.g., in other methods within the behavior implementation),
the new field is then also present, without you having to adapt the
method signature(s) and calls, and add additional parameters.
This facilitates the adaptation of existing coding.
For example, an action to cancel a sales order might receive a
parameter of type zrap_s_cancellation_opts (see Listing 3.27). In
addition, the consumer is able to pass the cancellation options to be
applied (such as the type of remittance or whether the cancellation
should skip certain checks).
define behavior for ZI_SalesOrder alias SalesOrder
...
{
   ...
   action cancel parameter zrap_s_cancellation_opts;
} 

Listing 3.27     Input Parameter Typed with Structure
You can also use an abstract CDS entity to type the input parameter
of an action. The definition of the abstract CDS entity can be found in
Listing 3.28. Non-abstract CDS entities can’t be used for typing.
@EndUserText.label: 'Cancellation options'
define abstract entity ZRAP_A_CancellationOpts
{
  payment_return_type : abap.char(3);
  force_cancellation  : abap_boolean;
} 
Listing 3.28     Abstract CDS Entity for Typing the Input Parameter of an Action
In Listing 3.29, the abstract CDS entity ZRAP_A_CancellationOpts is
used to type the input parameter.
define behavior for ZI_SalesOrder alias SalesOrder
...
{
   ...
   action cancel parameter ZRAP_A_CancellationOpts;
} 
Listing 3.29     Input Parameter Typed with Abstract CDS Entity
[»]  Warning
In strict behavior definitions (Section 3.4), explicitly specifying
$self as an input parameter for instance-based actions is not
supported and results in a syntax error. In non-strict behavior
definitions, the definition doesn’t result in an error until runtime.
However, $self can be used as a data type for an input parameter
in static actions.
Return Parameter

Not only can actions be provided with an input parameter, but they
also can be provided with exactly one output parameter (or return
parameter). This specification is optional. You can use the following
data types for this purpose:
The CDS entity for which the action was defined
A non-abstract CDS entity with behavior definition
An abstract CDS entity
A structured data type from the ABAP dictionary
You can use the result keyword, followed by the cardinality and data
type to define the return parameter of an action. You specify the
cardinality in square brackets [], declaring how many instances of
the return parameter are returned by the action. For instance-based
actions, the cardinality specifies how many return values are
returned per instance passed to the action (via keys in the
implementation) (see Table 3.8).
Cardinality Meaning
[0..1]
The action returns, at most, one return value per
passed instance.
[1]
The action returns exactly one return value per
passed instance.
[0..*]
The action returns any number of return values per
passed instance.
[1..*]
The action returns any number of return values per
passed instance, but at least one for each instance.
Table 3.8     Cardinalities for Return Parameters
Let’s suppose there is a Customer entity associated with an Address
entity via a composition relationship. A Customer instance can consist

of multiple Address instances. The Address entity provides a
setAsDefault action via the behavior definition (see Listing 3.30).
define behavior for ZI_Address alias Address
...
{
   ...
   action setAsDefault result [1] $self;
} 
Listing 3.30     Custom CDS Entity as Type of the Return Parameter
If the action is executed on the respective passed Address instances,
the corresponding instances are set as default addresses for the
respective Customer instance, whereby the implementation ensures
that there’s only one default address per Customer instance. You can
use $self to type the return parameter with the CDS entity for which
the action is defined; that is, with ZI_Address. The cardinality of [1]
indicates that there’s exactly one return value for each instance
passed to the action, which means that one Address instance will be
returned. The action returns the data of the Address instance that
was set as the default address.
[»]  Cardinalities for Static Actions
Since static actions are executed without reference to one or more
instances of the respective CDS entity, the cardinality for static
actions declares how many instances will be returned when the
action is called.
The entity keyword allows you to use a non-abstract CDS entity that
has a behavior definition as the data type for the return parameter.
Let’s assume that there’s a SalesOrder entity on the basis of which
an Invoice entity can be created. The Invoice entity is a standalone
RAP business object. In this case, you can map the creation of the

invoice as a createInvoice action, which returns the data for the
created Invoice instance as a return parameter. The return
parameter is typed with the corresponding CDS entity (in the
example, ZI_Invoice) (see Listing 3.31).
define behavior for ZI_SalesOrder alias SalesOrder
...
{
   ...
   action createInvoice result [0..1] entity ZI_Invoice;
} 
Listing 3.31     CDS Entity for Typing the Return Parameter
If you omit the entity keyword, you can only use a structured data
type from the ABAP dictionary or an abstract CDS entity as the data
type of the return parameter, as opposed to a concrete entity from a
RAP business object. Let’s suppose you have a SalesOrder entity
(sales order) that provides a createInvoice action, as in the previous
example. The action creates an invoice based on the respective
SalesOrder instance, now via an existing legacy API, rather than
another RAP business object. In this case, the action could be
provided with a data type for the invoice header data of the existing
API as a return parameter (see Listing 3.32).
define behavior for ZI_SalesOrder alias SalesOrder
...
{
   ...
   action createInvoice result [0..1] zrap_legacy_invoice_head;
} 
Listing 3.32     ABAP Dictionary Structure for Typing the Return Parameter
[»]  Using the Selective Keyword
You can also equip the return parameter of an action with the
selective keyword. This way you allow the consumer to provide a

choice of fields of the return parameter. Details about this keyword
can be found in Section 3.11.2.
If you provide an action (or function) with an entity parameter, you
must also include this entity in the respective service definition (see
Chapter 6). The entity is exposed to OData as EntityType (in
contrast to the structured data type), which is exposed as
ComplexType. You can trace this in the metadata document for the
OData service (via $metadata).
Factory Actions
A factory action is initiated with the factory keyword and creates
new instances of the CDS entity to which it is assigned. A factory
action can be instance-based or static. The data type of the return
parameter is always implicitly $self and doesn’t need to be specified
explicitly. However, you must specify the cardinality explicitly with
[1].
You can use an instance-based factory action to enable the copying
of a business object. For example, you can offer users to use a
specific instance of a SalesOrder entity as a copy template to create
a new instance from. For this purpose, you can define a factory
action named copy (see Listing 3.33).
define behavior for ZI_SalesOrder alias SalesOrder
...
{
   ...
   factory action copy [1];
} 
Listing 3.33     Declaration of a Factory Action
You can also provide factory actions with an input parameter. This
could, for example, control the copy process and determine which

child CDS entities should be copied as well and which ones should
not. For example, a SalesOrder entity whose composition tree
consists of Partner and Item entities could provide a factory action,
deepCopy, whose input parameters allow the consumer to control
whether the subordinate Partner or Item instances should be copied
as well (see Listing 3.34).
define behavior for ZI_SalesOrder alias SalesOrder
...
{
   ...
   factory action deepCopy parameter zrap_s_so_copy_ops [1];
} 
Listing 3.34     Factory Action with Input Parameter
You can see the definition of the zrap_s_so_copy_ops data type of the
input parameter in Listing 3.35. The factory action implementation
can evaluate the copy_partner or copy_items flags.
@EndUserText.label : 'SalesOrder, Copy Options'
@AbapCatalog.enhancement.category : #NOT_EXTENSIBLE
define structure zrap_s_so_copy_ops {
  copy_partner : abap_boolean;
  copy_items   : abap_boolean;
} 
Listing 3.35     ABAP Dictionary Structure for Typing an Input Parameter
Factory actions can also be defined as static. In this case, they are
applied at the CDS root entity level. For example, you can use it to
create and return instances with default values. Let’s suppose you
want to implement user management with a User entity. This entity
has certain attributes, such as the user name or a flag indicating
whether or not the User instance is locked. You could now declare a
static factory action createDefaultUser that creates a new User
instance (see Listing 3.36). In the implementation, the lock flag of the
new instance is set by default.

define behavior for ZI_User alias User
...
{
   ...
   static factory action createDefaultUser [1];
} 
Listing 3.36     Declaration of a Static Factory Action
[»]  Static Factory Actions for CDS Child Entities
CDS child entities, by definition, require an existing CDS parent
entity (Section 3.10.2). For this reason, you typically use instance-
based factory actions at this level, even if static factory actions
would be allowed.
3.11.2    Functions
A function is a specific operation of a CDS entity with which you can
implement calculations or complex selections. Unlike an action, a
function is a read access and free of side effects for the business
object. Thus, no lock is set when a function is processed. Functions
allow you to implement your own business logic in the behavior pool.
A function is declared in the BDL with the function keyword followed
by the name of the function. It’s always assigned to a CDS entity of
the business object composition tree.
Like actions, functions can be instance-based or static, and also
have an input and a return parameter (Section 3.11.1). Note that in
this context, unlike actions, the return parameter is a mandatory part
of a function. Below are some examples and different use cases of
functions.
Let’s suppose you have defined an Address entity and want to find
duplicates among the address instances based on various criteria.

You can implement this requirement using a static function that
returns corresponding Address instances. The action could be named
findDuplicates, for example. The return parameter of this function
would be typed with the current CDS entity via $self, and thus with
the CDS entity for which the function is declared (see Listing 3.37).
define behavior for ZI_Address alias Address
...
{
  ...
  static function findDuplicates result [0..*] $self;
} 
Listing 3.37     Static Function with a Return Parameter Typed with $self
You can also type the return parameter with a CDS entity of the
business object composition tree. Let’s suppose there’s a Project
entity defined in the context of a project management. This entity has
a composition of tasks (Task entity). Task instances can have a “plan
duration” attribute and predecessor-successor relationships among
them. So, for example, a Task instance can’t start until another Task
instance has been completed. You now want to realize which Task
instances are on the critical path of the project based on their plan
duration and dependency relationship. You can implement this
complex calculation using an instance-based function of the Project
entity, which then internally calculates corresponding Task instances
that lie on the critical path of the project and returns them as a result
(see Listing 3.38).
define behavior for ZI_Project alias Project
...
{
  ...
  function calcCriticalPath result [0..*] entity ZI_Task;
}
 
define behavior for ZI_Task alias Task
... 

Listing 3.38     Function with a Return Parameter Typed with a CDS Entity of the Business
Object Composition Tree
You can also use an abstract CDS entity to type the return
parameter. Let’s suppose there’s a SalesOrder entity with a
composition of Item entities. Starting from a SalesOrder instance, you
want to calculate the total of all discounts given based on associated
Item instances. To do this, you can declare an instance-based
function, sumDiscounts, that internally sums up the discounts and
returns the result via a return parameter typed as an abstract CDS
entity (see Listing 3.39).
define behavior for ZI_SalesOrder alias SalesOrder
...
{
   ...
  function sumDiscounts result [1] ZRAP_A_SalesOrderDiscount;
} 
Listing 3.39     Function with Abstract CDS Entity for Typing the Return Parameter
In Listing 3.40 you can see the definition of the abstract CDS entity.
@EndUserText.label: 'SalesOrder, Discounts'
define abstract entity ZRAP_A_SalesOrderDiscount
{
  @Semantics.amount.currencyCode : 'Currency'
  DiscountSum : abap.dec(11,2);
  Currency    : abap.cuky( 5 );
} 
Listing 3.40     Declaration of an Abstract CDS Entity as Output Data Type of a Function
Using the selective keyword, you allow the consumer of the function
to request only a certain selection of fields of the return parameter.
The function can be implemented in a performance-optimized
manner, taking into account the consumer's field selection. For
example, you could add the selective keyword to the
calcCriticalPath function mentioned earlier to read and return only

specific fields of the Task instance requested by the consumer (see
Listing 3.41). The selective keyword can also be used for actions.
define behavior for ZI_Project alias Project
...
{
  ...
  function calcCriticalPath result selective 
      [0..*] entity ZI_Task;
} 
Listing 3.41     Using the Selective Keyword in a Function

3.12    Concurrency and Locking Behavior
Whenever a RAP business object supports write operations you
need to worry about the data consistency of a persistent business
object instance. In this case, you must ensure that concurrent write
accesses don’t jeopardize the data consistency of a business object
instance. You can use the following RAP procedures for this
purpose:
Pessimistic locking
Optimistic locking
Both methods can be combined within one RAP business object. If
you use the optimistic locking procedure, you must declare the
pessimistic locking procedure as well. The pessimistic locking
procedure is required in any case to prevent concurrent accesses.
3.12.1    Pessimistic Locking
Pessimistic locking is about setting a write lock before making
changes to a business object instance. Changes should only be
made after the lock has been successfully set. After that, the lock will
be removed again. Parallel changes that are to be made in the
meantime by another consumer are rejected, since the lock attempt
fails when the first lock has already been set.
The locking of business object instances is implemented in ABAP-
based systems (and then also in the ABAP RESTful application
programming model) via the enqueue server with a global lock table
(lock table). Lock objects are used to set or query locks.

A lock that has already been set is released again after an ABAP
session has been processed (i.e., in the RAP context, after a
stateless server roundtrip has been processed). Completing a RAP
transaction via a commit or rollback also causes the previously set
lock to be released.
[»]  Locks in Draft Handling
The lock is dependent on the lifetime of the draft instance and
therefore independent of the ABAP session. For more information,
Section 3.15.3.
If you want to use the RAP locking behavior, you can set the lock
master keyword in the entity behavior definition (see Listing 3.42).
The lock master is the CDS entity based on which the lock is set in
the global lock table. You can declare only CDS root entities as lock
masters.
define behavior for /DMO/I_Travel_D alias Travel
lock master
...
{ 
Listing 3.42     Defining a CDS Root Entity as Lock Master
In Figure 3.22, you can see an entry in the global lock table for the
managed business object Travel.
Figure 3.22     Generic Entry in the Global Lock Table for the Travel Business Object
Instance
CDS child entities of the business object composition tree can now
refer to the lock master (i.e., the CDS root entity). These CDS
entities are referred to as lock-dependent. You can declare this type

of a CDS entity with lock dependent by, followed by the association to
the CDS root entity. If an instance of the CDS child entity needs to
be changed, the instance of the lock master gets locked. This
implicitly locks all instances of the CDS child entity as well (see
Listing 3.43).
define behavior for /DMO/I_Booking_D alias Booking
lock dependent by _Travel
...
{
   ...
   association _Travel { }
} 
Listing 3.43     Defining a CDS Child Entity as Lock-Dependent
The association specified after lock dependent by must be declared
with the read per association operation (Section 3.10.2) for reading
the associated instance of the CDS root entity. It must be a direct
association to the instance of the CDS root entity. This also applies
to CDS entities that aren’t defined directly below the CDS root entity.
Let’s suppose there’s a PurchaseOrder RAP business object. There’s
an instance of this object with the order number 123, which contains
two items, 10 and 20. Within a RAP transaction, item 20 now gets
updated. Since the CDS entity to the item is lock-dependent on the
CDS root entity for the order (the lock master), the order instance
with the number 123 gets locked. Above this, all items, including item
10, are locked, as they depend on this lock. If item 10 is to be
updated in parallel, the update will be rejected by the RAP runtime
because the lock master with the number 123 is already locked.
In the managed scenario, locking behavior is implemented by the
RAP framework. For this purpose, you only need to make the
declarations shown previously in the behavior definition. In the
unmanaged scenario, you must implement the locking behavior
yourself. In the managed scenario, you can implement your own

locking logic if needed by using the lock master unmanaged
declaration (see Listing 3.44).
define behavior for ZI_PurchaseOrder alias PurchaseOrder
lock master unmanaged
...
{ 
Listing 3.44     CDS Root Entity with Unmanaged Locking Behavior
This makes sense, for example, if the RAP business object is based
on an existing application that can set locks (see Chapter 10). In the
unmanaged scenario, you must implement the locking behavior
yourself.
[»]  Implementation of the Locking Behavior in the Behavior
Implementation
If you use lock master unmanaged or have declared the managed
scenario for the RAP business object, you need an implementation
of the FOR LOCK method in the handler class (see Chapter 5,
Section 5.4.6).
3.12.2    Optimistic Locking
Optimistic locking is not a locking in the true sense of the word
because a lock entry isn’t created. This strategy is about detecting
changes made to an instance based on an instance's outdated data.
Instance data is outdated if it has been changed by another
consumer in the meantime. If such a change is detected, it gets
rejected and the consumer must reload the current data of the
instance and make the change based on that data.

This type of change is detected by the field of a CDS entity that
represents the change status of an instance. This field is called an
entity tag (ETag). It’s used to indicate the change status of an
instance. The RAP framework compares the value of the passed
ETag field with the value available in the database during update
operations (update, delete, and action). If the value is identical, the
operation will be performed, otherwise it will be rejected so that the
modification won’t be based on outdated instance data.
For example, an ETag field can be a last modified timestamp, a hash
value, or a version counter. The ETag field must be reliably updated
with every modification.
[»]  Only Relevant in OData
In the ABAP RESTful application programming model, the
optimistic locking procedure is only relevant in the OData context
and doesn’t apply to local consumers via EML.
You can use the etag master keyword followed by the ETag field
name to define a CDS entity in the business object composition tree
as an ETag master. The ETag master is often the CDS root entity,
but CDS child entities can also be defined as ETag masters. Using
this definition, you use the ETag field comparison provided by the
RAP framework. In the following example, the LocalLastChangedAt
field is declared as an ETag field.
define behavior for /DMO/I_Travel_D alias Travel
etag master LocalLastChangedAt
... 
You can also declare multiple ETag masters within one RAP
business object. In the case of change operations, the respective
content of the ETag field is then compared with that of the instance

to be changed, even if these are instances of CDS child entities (see
Listing 3.45).
define behavior for /DMO/I_Travel_M alias Travel
etag master LocalLastChangedAt
...
 
define behavior for /DMO/I_Booking_D alias Booking
etag master LocalLastChangedAt
... 
Listing 3.45     Declaring Multiple CDS Entities as ETag Masters
If a CDS entity is declared as an ETag master, other CDS entities
(but only subordinate ones) can refer to this entity as ETag
dependents. You can do this using the expression etag dependent by
followed by the association to the CDS parent entity (see
Listing 3.46).
define behavior for ZI_SalesOrder alias SalesOrder
etag master LastChangedAt
...
 
define behavior for ZI_SalesOrderItem alias Item
etag dependant by _SalesOrder
...
{
   association _SalesOrder { }
} 
Listing 3.46     Declaring CDS Entities as ETag Dependent
The field comparison for changes to instances of this CDS entity is
based on the ETag field content of the parent instance. For this
purpose, it’s also necessary to explicitly declare the read-by-
association operation. However, we recommend declaring CDS
child entities as their own ETag masters since this makes it easier to
handle changes via the user interface.
[»]  LocalLastChanged and LastChanged Timestamp Fields

In the preceding examples, the timestamp fields LocalLastChanged
and LastChanged are used as ETag fields. Typically, a field such as
LastChanged at the CDS root entity level denotes the change
timestamp for the entire RAP business object, regardless of the
level at which an instance was changed. A field like
LocalLastChanged denotes the change timestamp at the level of the
respective CDS entity. The Local prefix refers to this local
reference of the change timestamp.
In draft handling, optimistic locking via the total ETag procedure is
required to ensure that the transition from the draft instance to the
active instance is consistent. We describe this procedure in
Section 3.15. However, you can also use the ETag procedure
described in this section in the context of draft handling.

3.13    Internal Business Logic
In the ABAP RESTful application programming model, you have two
options for declaring internal business logic:
Determinations
Validations
Both behaviors are optional components of a RAP business object,
and for both you need an implementation in the behavior pool.
Determinations and validations are available in the managed
scenario (with and without draft handling) and in the unmanaged
scenario (with only draft handling).
3.13.1    Determinations
Determinations allow you to make changes to the instances of a
business object based on trigger conditions (also called triggers). As
trigger conditions, you can choose the standard operations create,
update or delete. You can only use operations that are also declared
as default operations in the entity behavior definition (Section 3.10).
You can also use fields of the CDS entity for which the
determinations are declared as trigger conditions. Changes to the
relevant field contents will then cause the trigger condition to apply.
Standard operations and fields can also be combined as trigger
conditions.
[»]  OR Connection of Trigger Conditions

Note that all trigger conditions, regardless of whether they are
standard operations or fields, are linked with a logical OR (i.e., it’s
sufficient for one of the specified trigger conditions to be true for
the determination to be performed).
If the trigger condition applies, you have two points in time at your
disposal in which the determination will be performed:
on modify
The determination is performed immediately after a change
operation in the transaction buffer.
on save
The determination is performed just before saving (in the FINALIZE
phase) during the save sequence.
A determination can only run at one of these two times.
You can use determinations to implement a range of use cases:
To provide newly created instances with initial values
To sum up values of different instances on the level of the parent
instance
To reload values based on field changes
To derive a status value from the instances of an entity
To create new instances based on operations or field changes
You can use the keyword determination, followed by the
determination name, time, and trigger condition, to declare a
determination in the body of the entity behavior definition.
Standard Operations as Trigger Conditions

Let’s suppose you want to set the initial status of a newly created
Travel instance. To do this, you can declare a determination called
setStatusToNew at the on modify time. As a trigger condition, you
select the create operation by specifying { create; } (see
Listing 3.47).
define behavior for /DMO/I_Travel_D alias Travel
...
{
   ...
   determination setStatusToNew on modify { create; }
} 
Listing 3.47     Determination with Create Operation as Trigger Condition
If you have a SalesOrder entity with a composition of Item entities
and you want to calculate the total value of a SalesOrder instance
based on the item values, you can declare a calcTotalAmount
determination for the Item entity. This determination is called when
an Item instance is created, updated, or deleted (see Listing 3.48).
define behavior for ZI_SalesOrderItem alias Item
...
{
   ...
   determination calcTotalAmount on modify { create; update; delete; }
} 
Listing 3.48     Multiple Standard Operations as Trigger Conditions
In the implementation, the calculation of the total value in the
SalesOrder instance is triggered via an action. We’ll return to this
example later and reduce the scope of the trigger conditions.
[»]  Delete Operation as a Trigger Condition for
Determinations
When using the delete operation as a trigger condition, note that
the RAP framework doesn’t currently provide a way to determine

deleted instances from the transaction buffer. Thus, if you declare
a determination with multiple operations as trigger conditions, as in
the previous example, you can’t distinguish which of the passed
instances was deleted. To be able to do this, you would need to
define a determination that uses only the delete operation as a
trigger condition.
Fields as Trigger Conditions
You can also use the fields of the CDS entity for which you declare
the determination as a trigger condition. This can be one or multiple
fields. If one of the specified fields changes, for instance, due to a
standard operation or action, the determination will be called.
So, again there could be an Item entity for the items that compose a
SalesOrder entity. The ordered material for the Item entity can then
be set using the MaterialId field. If the MaterialId field changes, the
standard price of the material, for example, is to be read via a
setItemPrice determination and set in the Item instance (see
Listing 3.49).
define behavior for ZI_SalesOrderItem alias Item
...
{
   ...
   determination setItemPrice on modify { field MaterialId; }
} 
Listing 3.49     Determination with One Field as Trigger Condition
You can also declare multiple fields as trigger conditions for a
determination. Thus, a setTravelDuration determination for the
Travel entity is conceivable, which determines the duration of the trip
based on changes of the start and end date within the Travel

instances. If one or both fields change, the duration must be
recalculated (see Listing 3.50).
define behavior for /DMO/I_Travel_D alias Travel
...
{
   ...
   determination setTravelDuration on modify { field BeginDate, 
     EndDate; }
} 
Listing 3.50     Determination with Multiple Fields as Trigger Conditions
By default, this determination isn’t included in the ABAP flight
reference scenario.
Combination of Trigger Conditions
You can also combine the standard operations as trigger conditions
with the specification of fields. It’s also possible to specify multiple
standard operations with multiple fields.
We now want to refine the determination from Listing 3.48 and
declare it specifically only for the delete operation and a field change
of the item value ItemAmount of the Item instance (see Listing 3.51). If
an Item instance is deleted, the total amount must be recalculated.
define behavior for ZI_SalesOrderItem alias Item
...
{
   ...
   determination calcTotalAmount on modify { delete; field ItemAmount }
} 
Listing 3.51     Combined Trigger Condition from Standard Operation and Field
We refine combined trigger conditions to tailor them very specifically
to the relevant professional constellations.
[+]  Tip: Declaring Determinations as Specific as Possible

It’s best to declare specific trigger conditions for determinations if
possible. Fields as trigger conditions primarily communicate
business relationships between the triggering fields and the
internal change operations and calculations of the determination.
In some cases, a modularization of determinations is also sought
in order to separate the functionally related logic in one
determination from that of other determinations. However, such a
modularization can affect the performance if the same or similar
logic runs repeatedly in the modularization units (e.g., selections
from the database). Another advantage of having trigger
conditions that are as field-specific as possible is that you limit the
likelihood of determinations re-triggering themselves across
multiple stages and leading to an infinite loop.
Cascades of Determinations
Determinations don’t necessarily stand side by side in isolation.
Change operations within a determination can fulfill the trigger
condition of further determinations and thus cause them to be
executed. Thus, one determination triggers the next. In order to
avoid an endless loop of indirectly self-calling determinations, it
makes sense to declare field-specific trigger conditions for
determinations if possible and to take this into account in the
implementation (see Section 5.4.9).
Let’s now consider the previous examples of determinations from the
point of view of a cascade of determinations. In Listing 3.52 we have
summarized all Item entity determinations.
define behavior for ZI_SalesOrderItem alias Item
...
{
   ...
   determination setItemPrice on modify { field MaterialId; }

   determination calcItemAmount on modify { update; field 
OrderedQuantity, ItemPrice; }
   determination calcTotalAmount on modify { delete; field 
ItemAmount }
} 
Listing 3.52     Different Determinations for One Entity
Let’s assume that the MaterialId field of an Item instance gets
changed by the consumer (e.g., via the user interface). This causes
the determination setItemPrice to be executed. This process
internally determines a price for the set MaterialId and changes the
ItemPrice field, which triggers the calcItemPrice determination,
which in turn triggers the calcTotalAmount determination to be
executed by internal write operations on the ItemAmount field (see
Table 3.9).
Determination
Changes Field
Triggers Determination
setItemPrice
ItemPrice
(Item instance)
calcItemPrice
calcItemPrice
ItemAmount
(Item instance)
calcTotalAmount
calcTotalAmount
TotalAmount
(SalesOrder instance)
–
Table 3.9     Cascading Execution of Determinations
Determinations in the Save Sequence
With on save you can define the time of a determination in such a
way that these run within the save sequence in the FINALIZE phase
(see Section 5.5.1). In this way, you can, for example, perform
elaborate calculations just before saving and thus avoid a potentially
repetitive execution within the interaction phase.

Let’s suppose you want to calculate the total value of a SalesOrder
instance only in the save sequence. For this purpose, you can also
specify the time on save for the determination (see Listing 3.53).
define behavior for ZI_SalesOrderItem alias Item
...
{
   ...
   determination calcTotalAmount on save { delete; field ItemAmount }
} 
Listing 3.53     Determination During the Save Sequence
You can also specify the standard operations create, update, or
delete as trigger conditions here. Field-specific trigger conditions or
a combination of both are also possible. The update operation can
only be used together with the create operation as a trigger
condition.
During a RAP transaction, the instance of an entity may be subject to
various change operations. To determine which operation is used as
the trigger condition in the save sequence, the RAP framework
aggregates the operations performed and uses this aggregation to
determine the operation that’s used as the trigger condition (see
Table 3.10).
Sequence of Change
Operations
Operation for Trigger
Condition
create and update
create
create and delete
delete
update and update
update
update and delete
delete
delete and create
create
Table 3.10     Standard Operations for Trigger Condition at Time of Save

3.13.2    Validations
With validations you can implement your own consistency checks for
the data of business object instances based on trigger conditions. A
validation is executed within the save sequence. If it fails, the RAP
runtime aborts the save sequence in a controlled manner.
As with determinations, the standard operations create, update and
delete are available as trigger conditions for validations. Likewise,
you can define field-specific trigger conditions or combine them with
standard operations.
The validation is declared at the time on save and executed by the
RAP framework based on the applicable trigger conditions. It runs
within the save sequence in the CHECK_BEFORE_SAVE phase (see
Section 5.5.2).
You can use the BDL keyword validation followed by the name of
the validation, the on save time, and the trigger condition to declare a
validation.
Standard Operations as Trigger Conditions
If you want a validation to be called on a specific operation, you
should use one or more of the standard create, update, or delete
operations as the trigger condition.
Let’s suppose you want to perform checks of the same content both
when creating and when modifying the instance of a CDS entity. In
this case, you can declare both the create and update operations as
trigger conditions. Listing 3.54 shows the validateOnChange validation
as an example. It is carried out for created and updated instances of
the SalesOrder entity.

define behavior for ZI_SalesOrder alias SalesOrder
...
{
   ...
   validation validateOnChange on save { create; update; }
} 
Listing 3.54     Trigger Condition with Several Standard Operations for a Validation
As with determinations, specifying the update operation as a trigger
condition is only permitted together with the create operation for
validations.
[»]  Delete Operation as Trigger Condition
When you use the delete operation as a trigger condition for a
validation, the deleted instance is already located inside the
transaction buffer. That is, you cannot undo the program-based
deletion within the RAP transaction. If you want to check whether
or not an instance can be deleted from a functional point of view,
you should use the preliminary check via precheck
(Section 3.16.2).
The relevant default operation is determined during the evaluation of
the trigger conditions in the same way for determinations performed
at the time on save (Section 3.13.1).
Fields as Trigger Conditions
Let’s suppose there’s an Item entity which is associated with a
SalesOrder entity via a composition based on that entity. You want to
check the MaterialId field of the Item entity when the field changes.
For this purpose, you can declare a validateMaterial validation that
contains the MaterialId field as a trigger condition (see Listing 3.55).

define behavior for ZI_SalesOrderItem alias Item
...
{
   ...
   validation validateMaterial on save { field MaterialId; }
} 
Listing 3.55     Validation with Field as Trigger Condition
You can also store several fields as trigger conditions. For example,
if there’s a Travel entity that contains the fields BeginDate of the trip
and EndDate of the trip, you can perform a check to ensure that the
begin date isn’t earlier than the end date. For this purpose, you must
declare a validation called validateTravelDates and specify the two
fields BeginDate and EndDate as trigger conditions (see Listing 3.56).
define behavior for /DMO/I_Travel_D alias Travel
...
{
   ...
   validation validateTravelDates on save { field BeginDate, 
     EndDate; }
} 
Listing 3.56     Validation with Multiple Fields as Trigger Conditions
Combinations of the Trigger Conditions
As with determinations, you can combine standard operations with
fields to create a trigger condition for validations. Let’s take the
example from Listing 3.55 and adapt it accordingly. We assume that
you not only want to check whether a passed material ID is valid in
the context of the application, but also want to ensure that the
MaterialId field is provided with a value when a new Item instance
gets created. To do this, you must provide the validateMaterial
trigger condition with the MaterialId field and also with the create
operation (see Listing 3.57).
define behavior for ZI_SalesOrderItem alias Item
...

{
   ...
   field ( mandatory ) MaterialId;
   validation validateMaterial on save { create; field MaterialId; }
} 
Listing 3.57     Validation with Standard Operation and Field as Trigger Condition
[»]  Differentiation from Field Property Mandatory
You can use validations in combination with the field property
field( mandatory ) to check mandatory fields. Such mandatory
fields couldn’t be populated with data in the course of a RAP
transaction. You should use field ( mandatory:create ) only for
fields whose transfer is mandatory for a new business object
instance to work (e.g., a document type). In this case, leaving the
field empty is considered a programming error and results in a
dump.
3.13.3    Calling Determinations via an Action
With the keyword determine action you can combine determinations
and validations that run at the time on save in the behavior definition
and make them callable business object-externally via an action
during the interaction phase. When such an action is called, the
trigger conditions are evaluated, the corresponding determinations
are called, and then the validations are executed. This concept is
particularly relevant in draft handling (Section 3.15.3).
A use case is when you want to run a group of determinations for a
RAP business object in a SAP Fiori elements application and output
the changes made by the determinations to the user interface. For
this purpose, you can use so-called side effects in SAP Fiori
elements. You can define a determination action as the target of the

side effect. Then, you can reload the fields affected by the
determinations from the draft instance on the SAP Fiori elements UI
and have the relevant fields updated.
Another use case is when the EML consumer of the RAP business
object within the RAP transaction wants to perform a group of
validations at specific times outside of the save sequence and
present appropriate messages to do so.
You can declare a determination action in the behavior definition
using the determine action keyword followed by the action name
(see Listing 3.58).
define behavior for ZI_SalesOrder alias SalesOrder
...
{
   ...
   validation validateDeliveryDate on save { create; 
                                               field DeliveryDate; }
   validation validateCustomer on save { create; field CustomerId; }
 
   determine action check {
      validation validateDeliveryDate;
      validation validateCustomer;
   }
} 
Listing 3.58     Determination Action with Validations
Here the validations validateDeliveryDate and validateCustomer are
combined and made executable via the determination action, check.
You can also reference CDS child entity determinations and
validations in a CDS parent entity determination action (see
Listing 3.59).
define behavior for ZI_SalesOrder alias SalesOrder
...
{
   determine action CalcAmounts {
      determination Item~calcTotalAmount; 
   }
}

 
define behavior for ZI_SalesOrderItem alias Item
...
{
   ...
   determination calcTotalAmount on save { delete; field ItemAmount }
} 
Listing 3.59     Determination Action with Reference to a Determination of a CDS Child
Entity
In the example, the determination of the total amount of an order
(SalesOrder instance) is defined by the subordinate Item entity with a
trigger condition and included via a CalcAmounts determination action
at the level of the parent entity SalesOrder, and made externally
accessible.
You can mark a determination or validation within the determination
action with always and thus have it executed independently of the
evaluation of the trigger conditions. The determination
calcTotalAmount from Listing 3.59 is executed in Listing 3.60
regardless of whether an Item instance has been deleted or whether
the ItemAmount field has been modified.
define behavior for ZI_SalesOrder alias SalesOrder
...
{
   determine action calcAmounts {
      determination (always) Item~calcTotalAmount; 
   }
} 
Listing 3.60     Determine Action with a Determination that is Independent of Trigger
Conditions
Determination actions are available in the managed scenario (with
and without draft handling) and in the unmanaged scenario with draft
handling. They can be used with the two save options, additional
save and unmanaged save.

3.14    Authorization Checks
For standard write operations or actions, you can declare
authorization checks in the behavior definition in the ABAP RESTful
application programming model to prevent unauthorized access. To
perform the checks, they must be implemented in the behavior pool.
[»]  Access Protection for Read Operations
For read accesses, the authorization check is performed by the
CDS runtime environment. The authorization checks defined via
CDS data control language (DCL) are evaluated (see Chapter 2,
Section 2.5). This type of authorization check also takes effect for
read accesses to business object instances in a transactional
context via the EML. Such accesses are only possible if special
behavior has been defined for the CDS entity via a behavior
definition, even if it is a read-only EML access. Read accesses are
thus fully protected via the CDS DCL.
The RAP framework calls the authorization check you implemented
in the behavior pool within a RAP transaction when a standard write
operation or action is executed, and rejects further processing of the
operation if the authorization check fails. Typically, you would use
SAP authorization objects to implement an authorization check.
In the behavior definition, you can declare either a global or an
instance-based authorization check:
The global authorization check allows you to check whether or not
the respective operation is basically executable based on the
authorizations of a consumer.

The instance-based authorization check enables you to make the
check dependent on the actual data of an instance.
In Table 3.11, you can see which operations can be authorized with a
global or an instance-based authorization check.
Authorization
Check
Standard
Operations
Actions
Global
create;
update;
delete;
static action
static factory
action
action
factory action
Instance-Based
update
delete
_Assoc { create; }
action
factory action
Table 3.11     Available Operations for Instance-Based and Global Authorization Checks
[»]  Instance-based Authorization Check of the Create
Operation
If you want to check the create operation depending on actual
values of an instance (e.g., whether the creation of a sales order is
possible for a certain company code), you should carry out a
preliminary check via precheck (Section 3.16.2).
Functions can’t be access-protected via authorization checks. In the
implementation of functions, DCL access control takes effect when
you access CDS entities, if applicable.
3.14.1    Authorization Master
If you want to use authorization checks for a RAP business object,
you must first declare the CDS root entity as the authorization

master; a CDS child entity can’t be declared as such
(Section 3.14.2). You can use the authorization master to determine
whether a global authorization check, an instance-based
authorization check, or a combination of both is used for the RAP
business object in question.
You can declare the authorization master using the authorization
master keyword. For the global authorization check, you must specify
the usage ( global ) (see Listing 3.61).
...
define behavior for /DMO/I_Travel_D alias Travel
...
authorization master ( global )
{ 
   create;
   action acceptTravel ...;
   ...
} 
Listing 3.61     Declaring a CDS Root Entity as Authorization Master with Global
Authorization Check
You can use this method to add authorization protection to an action
such as acceptTravel or the create operation. No instance-based
authorization check is possible for the create operation, which is why
only the global authorization check is used here. For such a
declaration, you need an implementation of the method with the FOR
GLOBAL AUTHORIZATION addition (see Section 5.4.3).
You can also declare an instance-based authorization check for the
authorization master, for example to determine whether an update or
delete operation or an action (here it is acceptTravel) may be
executed on an instance or not. You can declare the instance-based
authorization check using authorization master ( instance ), as
shown in Listing 3.62.
...
define behavior for /DMO/I_Travel_D alias Travel

...
authorization master ( instance )
{ 
   ...
   update;
   delete;
   action acceptTravel ...;
   ...
} 
Listing 3.62     Declaring a CDS Root Entity as Authorization Master with Instance-Based
Authorization Check
With this declaration you need an implementation of the method with
the addition FOR INSTANCE AUTHORIZATION (see Chapter 5,
Section 5.4.2).
It’s also allowed to declare a combination of global and instance-
based authorization checks, as shown in Listing 3.63.
...
define behavior for /DMO/I_Travel_D alias Travel
...
authorization master ( global, instance )
{ 
   create;
   update;
   delete;
   action acceptTravel ...;
   ...
} 
Listing 3.63     Combining Global and Instance-Based Authorization Checks
At runtime, in this case, the global authorization check is executed
first and then the instance-based authorization check at a later time.
It may happen that the global authorization check succeeds while the
instance-based authorization check fails.
[eg]  Example: Double-Check a Purchase Order
For example, the “release” action of a purchase order business
object could be allowed for a user (the global authorization check

would therefore be successful). The instance-based check may
still fail, for example, because an additional authorization for this
action is only valid up to a certain order value, which was
exceeded in the order in question.
3.14.2    Authorization-Dependent
If you want to implement authorization checks for CDS child entities
of a RAP business object, you must declare them as authorization-
dependent. You can use the authorization dependent by expression
for this purpose, followed by the association with the authorization
master (see Listing 3.64).
...
define behavior for /DMO/I_Travel_D alias Travel
...
authorization master ( global, instance )
{ 
   ...
   association _Booking { create; }
}
 
define behavior for /DMO/I_Booking_D alias Booking
...
authorization dependent by _Travel
{
   update;
   delete;
   association _Travel  { }
} 
Listing 3.64     Declaring a CDS Child Entity as Authorization-Dependent
Authorization checks for the update, delete and create operations
via association of the CDS child entity (in the example, association
_Booking { create; }) are delegated to the authorization master and
interpreted in terms of the authorization check for the update
operation of the authorization master. The update operation doesn’t
have to be explicitly declared for the authorization master.

Authorization checks for actions, on the other hand, are always
implemented directly by the respective CDS entity that declares the
action. They aren’t delegated to the authorization master.
[+]  Tip: Declaring all CDS Child Entities as Authorization-
Dependent
We recommend that you declare all CDS child entities for which
you have stored behavior in the behavior definition as
authorization-dependent, so that authorization checks for standard
operations are delegated to the authorization master and executed
there at runtime. If you have declared the strict mode
(Section 3.14) in the behavior definition, the syntax check ensures
that all declared CDS child entities are marked as authorization-
dependent.
The CDS child entity always needs a direct association (for the read-
by-association operation) to the authorization master (i.e., to the
CDS root entity in the behavior definition), regardless of the
hierarchy level it is on within the business object composition tree.
3.14.3    Delegating Authorization Checks
You can have authorization checks for the standard operation
delete, the create-by-association operation, and actions interpreted
as update operation and delegated to the authorization check for this
operation. To do this, you must use the authorization:update
addition for the respective operation (see Listing 3.65). Such
forwarding is possible for both the authorization master and
authorization-dependent entities.
...
define behavior for /DMO/I_Travel_D alias Travel

...
authorization master ( global )
{
   delete ( authorization : update );
   ...
} 
Listing 3.65     Delegating an Authorization Check for Standard Operations
In Listing 3.66, you can see an example of how a create operation is
interpreted as an update operation by association.
...
define behavior for /DMO/I_Travel_D alias Travel
...
authorization master ( global )
{
   association _Booking { create ( authorization : update ); }
   ...
} 
Listing 3.66     Authorization Check for a Create Operation by Association
[ ! ]  Warning: Forwarding of Authorization Checks in CDS
Child Entities
The authorization:update declaration in CDS child entities is only
useful for actions since all other write operations are interpreted as
update operations and delegated to the authorization master.
If you want to exclude an operation from an authorization check, you
should add authorization : none. This is possible in both the
authorization master and authorization-dependent entities.

3.15    Draft Handling
This section covers the basics of draft handling in the ABAP RESTful
application programming model, and shows the ways in which you
can enable draft handling in the behavior definition. In Chapter 9, we
describe the practical implementation of this concept in the managed
scenario.
[+]  Tip: Using Draft Handling by Default
You should consider using draft handling even for simple use
cases. It’s fully implemented by the ABAP RESTful application
programming model and is therefore very easy to use for a RAP
business object.
By providing a RAP business object with the draft handling
functionality, it’s possible to store the temporary version of a
business object and its instances (which can also be inconsistent)
persistently on the database and continue processing at a later time.
This temporary version is called the draft instance, whereas the
productive version is the active instance. For each active instance,
there’s only one draft instance. The draft instance data is kept in
separate draft tables in the backend and doesn’t affect the
productive data of the active instance of the business object.
Within the RAP transaction model, draft instances represent a
persistent form of the transaction buffer, decoupling the state of the
transaction buffer from a stateless REST-based request. This way,
REST-based requests can still be stateless, and a logical RAP
transaction can still span multiple ABAP sessions (i.e., requests).

[»]  Draft Handling in SAP Fiori Elements
At runtime, the SAP Fiori UI automatically performs data backups
of the draft instance as soon as changes are made to it. By
default, users can select a list report by draft instances without
having to do any programming work.
Draft handling is available in both the managed and the unmanaged
scenario. This also applies in the context of the unmanaged save
and additional save options. If you want to use validations and
determinations in the unmanaged scenario, this is only possible with
enabled draft handling. The validations and determinations then only
apply to the draft instances.
3.15.1    Enabling Draft Handling
You can declare draft handling only for an entire RAP business
object and not for individual CDS entities. You do this by using the
with draft keyword in the behavior definition head (see Listing 3.67).
managed;
strict;
with draft;
 
define behavior for /DMO/I_Travel_D alias Travel
... 
Listing 3.67     Draft Handling Enabled in the Head of a Behavior Definition
It’s also possible to introduce draft handling subsequently for a RAP
business object, even if existing data is already located in the
production database tables. The draft instances are kept separate
from production data.

3.15.2    Draft Handling in the Business Object
Composition Tree
Once a RAP business object has been declared as draftable via with
draft, some follow-up work is required in the entity behavior
definition of the business object composition tree. This includes
specifying a draft table, ETag handling, and associations.
Draft Table
If you have enabled draft handling for a RAP business object in the
behavior definition, you must declare a draft table for each of the
CDS entities in the business object composition tree. You can do this
using the draft table keyword followed by the draft table name (see
Listing 3.68).
...
define behavior for /DMO/I_Travel_D alias Travel
...
persistent table /dmo/a_travel_d
draft table /dmo/d_travel_d
...
 
define behavior for /DMO/I_Booking_D alias Booking
...
persistent table /dmo/a_booking_d
draft table /dmo/d_booking_d
... 
Listing 3.68     Declaring Draft Tables
You can create draft tables in the behavior definition editor using a
quick fix (see Section 9.3.2).
To distinguish application tables for production instances from draft
tables, you can use the _A or _D prefix after the corresponding
namespace.
Application table: /DMO/A_TRAVEL_D

Draft table: /DMO/D_TRAVEL_D
A draft table is a database table in which draft instances are
persistently stored. With regard to the production database table,
you should note the following aspects:
The column names of the draft table correspond to the field
names of the CDS entity and not to the column names of the
production table.
If you make field changes to the production table, you must
manually keep the fields in the draft table in sync.
In the CDS entity there may be transient fields (i.e., fields that
aren’t stored persistently and thus have no counterpart in the
production table).
The draft table has special administrative fields which the RAP
framework needs for draft handling. These administrative fields
are summarized in the structure SYCH_BDL_DRAFT_ADMIN_INC and
are appended to the end of the draft table column definition via an
include operation.
ETag Handling
When a draft instance is created, its active instance is exclusively
assigned to the respective user and locked for a certain period of
time. This is referred to as an exclusive lock. When a new draft
instance is created, this affects the assigned key value (an active
instance doesn’t yet exist in this case); when an active instance is
changed, it gets locked. Editing by another user within the exclusive
lock isn’t possible.
Once the exclusive lock of the draft instance expires, the RAP
framework uses the optimistic locking procedure (Section 3.12.2) to

ensure consistent transition from the draft instance to the active
instance. For example, it could happen that the active instance is
modified by legacy coding after the exclusive lock expires, for
example, by a job run (and thus the draft instance is based on an
outdated dataset).
To prevent this scenario, it’s necessary to declare an ETag field that
applies to the entire business object instance, since instances can’t
be partially activated. You must use the total etag keyword, followed
by the name of a field used as ETag. You declare this field for the
CDS root entity (see Listing 3.69).
define behavior for /DMO/I_Travel_D alias Travel
...
total etag LastChangedAt
... 
Listing 3.69     Declaring the Total ETag Field
Draftable Associations
In order for the draft instances and active instances within the
business object composition tree to be read separately from each
other (e.g., a Travel instance separately from the associated Booking
instance in draft mode), the associations defined for these CDS
entities must also be draftable. This is automatically the case if you
have specified the with draft addition at the behavior definition level.
However, you can also explicitly add the with draft addition to an
association (see Listing 3.70).
define behavior for /DMO/I_Travel_D alias Travel
...
{
   ...
     association _Booking { create; with draft; }
}
... 
Listing 3.70     Declaring a Draftable Association

3.15.3    Draft Lifecycle and Draft Actions
The RAP framework fully implements the lifecycle of a draft instance,
and also the transition from a draft instance to the active instance
and vice versa. For this purpose, you must declare draft actions at
the CDS root entity level. These are built-in actions in the RAP
framework (see Listing 3.71).
define behavior for /DMO/I_Travel_D alias Travel
...
{
   draft action Resume;
   draft action Edit;
   draft action Activate;
   draft action Discard;
 
   draft determine action Prepare
   {
     validation validateAgency;
     validation validateCustomer;
     ...
   }
 
  validation validateCustomer on save { ... }
  validation validateAgency on save { ... }
  ...
} 
Listing 3.71     Draft Actions for a CDS Root Entity
Even though the ABAP RESTful application programming model
handles the draft handling and implements and executes the
declared actions for you, it makes sense to take a closer look at the
individual actions and the lifecycle of a draft instance (see
Figure 3.23). On the one hand, the lifecycle influences numbering,
and on the other hand, you also have the possibility to get involved
via ABAP coding.

Figure 3.23     Draft Actions and States in Draft Handling
The create operation is used to create a new draft instance (i.e., a
new draft) if there’s no active instance yet. If an active instance
already exists, it’s copied via the draft action edit and created as a
draft instance (i.e., as an edited draft). Once editing of the draft
instance is complete, it can be activated and converted into an active
instance by executing the draft action activate. All determinations or
validations declared within the draft determination action prepare will
be executed. If a validation fails, the activation of the draft instance
will be aborted. In the draft determination action, you can specify
only determinations and validations that are executed at the time on
save.
When a draft instance is created via create or edit, the active
instance is exclusively locked for a certain period of time. Concurrent
changes to the active instance are thus not possible. Once the
exclusive lock expires, concurrent changes to the draft and active
instances are processed via the ETag procedure. The draft instance
itself is protected from concurrent changes via the ETag procedure.
This is necessary, for example, if a business user edits a draft
instance in multiple browser windows (possibly on different end

devices) and this results in an outdated draft instance dataset in one
of the open user interfaces.
Editing a draft instance can be continued at a later time. If the
exclusive lock no longer exists, the draft action resume will be
executed. This action performs a uniqueness check (Section 3.7)
and ensures the renewal of the exclusive lock on the active instance.
The draft action discard can be used to discard a draft instance.
Once the exclusive lock on the active instance has expired, another
user can overwrite the changes made to the original user's existing
draft instance, thereby discarding it. After a certain period of time,
draft instances which are no longer used are automatically removed
from the draft table(s) by the RAP framework.
As mentioned above, you can add an additional implementation to
draft actions. This implementation will be executed after the draft
action. You can use the addition with additional implementation in
the behavior definition for this purpose. Listing 3.72 shows this with
the example of the resume action.
define behavior for ZI_SalesOrder alias SalesOrder
...
{
   ...
   draft action Resume with additional implementation;
   ...
} 
Listing 3.72     Resume Action with Additional Implementation
In the unmanaged scenario, for example, you can provide a
uniqueness check for early, external numbering to ensure that the
key value of the draft instance hasn’t already been assigned
elsewhere in the meantime (after the exclusive lock has expired).

3.16    Overarching Concepts
The following concepts have an overarching nature within the
behavioral definition and thus can be applied to several other
concepts within the BDL. The following sections describe each of
these concepts in greater detail.
Dynamic feature control
Preliminary checks of operations
Internal visibility of operations
3.16.1    Dynamic Feature Control
You can use a dynamic feature control to influence the properties of
a RAP business object's features, such as fields, default operations,
and actions, at runtime (see Table 3.12). You need a declaration of
the respective feature in the behavior definition and an
implementation in the behavior pool. Using this concept is optional.
Feature
Property
Fields
Without restrictions
With readonly restriction
With mandatory restriction
With all restrictions (readonly and
mandatory)
Standard
Operations
Active/inactive

Feature
Property
Actions
Active/inactive
Table 3.12     Properties of Features That Can be Set Dynamically
Dynamic feature control for functions isn’t currently supported.
You can decide whether to use either an instance-based or global
feature control for each field, default operation, or action when
declaring it in the behavior definition. To do this, you must add (
features:instance ) to the feature for an instance-based feature
control, or ( features:global ) for a global feature control. You can’t
use both options simultaneously for a given feature.
With an instance-based feature control, you can influence the
property of the corresponding feature depending on the data of the
respective instance. With the global feature control, you decide on
the property of the respective feature independently of the respective
instance. In Table 3.13, you can see which concrete features are
available to you for instance-based and global feature control.
Feature
Control
Fields
Standard
Operations
Actions
Global
–
create
_Assoc { create;
}
update
delete
static action
static factory
action
action
factory action

Feature
Control
Fields
Standard
Operations
Actions
Instance-
based
field
f1
update
delete
_Assoc { create;
}
action
factory action
Table 3.13     Feature Availability for Instance-Based and Global Feature Control
[»]  Static Versus Dynamic Feature Control
In the ABAP RESTful application programming model, we already
use the term “feature control” when you declare a field, a standard
operation, or an action in the behavior definition. Since the feature
is declared fixed at design time, this is a static feature control. It’s
also considered global since the declaration is valid regardless of
the specific instance.
This section, on the other hand, is about a dynamic feature
control. Here you have the possibility to adjust the properties of
statically declared features at runtime (i.e., dynamically). At
runtime, the data of the respective instances is available, which
enables an instance-based, dynamic feature control.
Dynamic Feature Control for Fields
Let’s suppose we have an Item entity of a sales order that contains
an OrderedQuantity field representing the quantity ordered. This field
should only be ready for input if the respective Item instance hasn’t
yet been provided. This could be mapped via a separate
DeliveryStatus field of the Item entity. You can also add ( features :

instance ) to the OrderedQuantity field to determine the field's
readonly property at runtime, instance-based and depending on the
contents of the DeliveryStatus field (see Listing 3.73).
define behavior for ZI_SalesOrderItem alias Item
...
{
   ...
   field ( features : instance ) OrderedQuantity;
} 
Listing 3.73     Instance-Based Feature Control for a Field
You can also provide multiple fields with an instance-based feature
control and combine them syntactically with the static specification of
field properties. For the features : instance declaration, you need an
implementation of the method with the addition FOR FEATURES (see
Chapter 5, Section 5.4.4).
[»]  The readonly Field Property
Note that the static definition of a field's readonly property can’t be
combined with dynamic feature control.
Dynamic Feature Control for Standard Operations
You can also add a dynamic feature control to standard operations.
For example, let’s suppose a SalesOrder entity represents a sales
order. Now you want to determine whether or not the creation of a
SalesOrder instance via the create operation is possible at runtime.
For this purpose, you could evaluate a global period-dependent
posting lock. To do this, you must add ( features : global ) to the
create operation to activate the global feature control (see
Listing 3.74).

define behavior for ZI_SalesOrder alias SalesOrder
...
{
   ...
   create ( features : global );
} 
Listing 3.74     Global Feature Control for the Standard Create Operation
The features : global declaration requires you to have an
implementation of the method with the addition FOR GLOBAL FEATURES
(see Section 5.4.5).
[»]  Dynamic Feature Control Versus Authorization Check
You should use a dynamic feature control when, for business
reasons, a particular standard operation or action should or should
not be executable. In this case, dynamic feature control is
performed depending on the field contents of instances.
Authorization checks, on the other hand, are only used when you
query the authorizations of a user also using field contents (i.e.,
without any functionally motivated logic). Conversely, you
shouldn’t use permission queries in the context of the dynamic
feature control.
You can also declare a dynamic feature control for the standard
operation create via an association and, for example, control at
runtime whether the creation of Item instances based on a
SalesOrder instance is possible or not (see Listing 3.75). Note that
this is still a global feature control, so it’s independent of the specific
instance.
define behavior for ZI_SalesOrder alias SalesOrder
...
{
   ...
   association _Item { create ( features : global ); }
} 

Listing 3.75     Global Feature Control for the Standard Create Operation via an
Association
For standard operations, you can also declare an instance-based
feature control. Imagine you want to determine at runtime whether or
not a SalesOrder instance may be deleted. This decision should
depend on the specific SalesOrder instance. For example, this might
still be deleted as long as the order hasn’t been confirmed. You can
add the delete operation via ( features : instance ) for this purpose
(see Listing 3.76).
define behavior for ZI_SalesOrder alias SalesOrder
...
{
   ...
   delete ( features : instance );
} 
Listing 3.76     Instance-Based Feature Control for the Standard Delete Operation
Dynamic Feature Control for Actions
You can also provide actions with a dynamic feature control. Let’s
suppose you want to evaluate the posting lock for SalesOrder
instances also for a cancel action and determine at runtime whether
or not the action is executable. To do this, you must provide the
cancel action with the addition ( features : global ) to enable or
disable the action independently of the data of the actual instance
(see Listing 3.77).
define behavior for ZI_SalesOrder alias SalesOrder
...
{
   ...
   action ( features : global ) cancel;
} 
Listing 3.77     Global Feature Control for Actions

You can also enable an instance-based feature control for actions.
For example, if you want to determine whether or not an actual
SalesOrder instance may be canceled via a cancel action, you can
provide it with ( features : instance ) (see Listing 3.78).
define behavior for ZI_SalesOrder alias SalesOrder
...
{
   ...
   action ( features : instance ) cancel;
} 
Listing 3.78     Instance-Based Feature Control for an Action
It’s also possible to assign a global feature control to static actions.
Instance-based feature control isn’t useful for static actions because
they can be executed independently of actual instances.
Suppose there’s an Address entity that provides a static action
markDuplicates to determine and mark them as duplicates among
Address instances. If you want to activate the status of this function in
a controlled manner via a customizing entry, you can use a global
feature control for this purpose (see Listing 3.79).
define behavior for ZI_Address alias Address
...
{
   ...
   static action ( features : global ) markDuplicates; 
} 
Listing 3.79     Global Feature Control for a Static Action
3.16.2    Preliminary Checks of Operations
You can run a preliminary check on write operations using the
precheck keyword and implement it in the behavior pool. This
preliminary check plays an essential role if you want to perform
value-dependent checks to ensure that a write operation doesn’t

reach the transaction buffer in the first place. You can, for example,
implement a uniqueness check (Section 3.7) or an additional
authorization check, depending on the request data of a create
operation. In the behavior implementation, you can use a preliminary
check to prevent further processing of the operation.
[»]  Behavioral Implementation of the Preliminary Check
If you use the precheck addition, you need an implementation of
the method with the FOR PRECHECK addition in the handler class for
this (see Chapter 5, Section 5.4.12).
You can use the precheck keyword within a write operation to be able
to implement a preliminary check for it (see Listing 3.80).
define behavior for ZI_SalesOrder alias SalesOrder
...
{
   create ( precheck );
   ...
} 
Listing 3.80     Declaration of a Preliminary Check for a Create Operation with the Precheck
Keyword
In the example, a preliminary check is declared for the create
operation. This preliminary check can be used to check whether the
user has authorization to create a SalesOrder instance, for example,
in a specific company code.
3.16.3    Internal Visibility of Operations
You can mark operations in the behavior definition as internal so that
they are only visible and usable within the business object in
question. This improves the changeability of the RAP business

object because you ensure that the operation is only available to
business-object-internal consumers in the form of the behavior
implementation. Accordingly, you don’t need to consider business-
object-external consumers when making adjustments. External
access to internal elements of a RAP business object results in a
syntax error.
You can use the internal keyword to make standard operations,
actions, determination actions, and functions only internally visible
(see Listing 3.81).
define behavior for /DMO/I_Travel_D alias Travel
...
{
   internal action reCalcTotalPrice;
...
}
 
define behavior for /DMO/I_Booking_D alias Booking
...
{
  determination calculateTotalPrice on modify { create; 
field FlightPrice, CurrencyCode; } 
} 
Listing 3.81     Declaration of Internal Visibility for an Action
In the example, the reCalcTotalPrice action is only internally visible.
It’s called within the implementation of the Booking entity's
calculateTotalPrice determination to recalculate the total price of
the Travel instance.
You can also declare the create operation as internal by means of an
association (see Listing 3.82).
define behavior for ZI_SalesOrder alias SalesOrder
...
{
   association _StatusLog { internal create; }
}
 
define behavior for ZI_SalesOrderStatusLog alias StatusLog
...

{
  association _SalesOrder { }
} 
Listing 3.82     Declaration of the Internal Visibility of a Create Operation via an Association
Listing 3.82 contains a SalesOrder business object with a
composition of the SalesOrder entity and a StatusLog entity.
StatusLog instances represent a status log that logs various events
for processing the SalesOrder instance (e.g., for delivery processing
or invoicing). The status log should only be populated internally
within the behavior implementation and should be accessible as
read-only from the outside.
Another use case can involve using a static factory action in
combination with an internal create operation (see Listing 3.83).
define behavior for ZI_SalesOrder alias SalesOrder
...
{
   internal create;
   static factory action createDefaultSalesOrder [1];
} 
Listing 3.83     Internal Create Operation in Combination with Factory Action
In this way, SalesOrder instances can be created business-object-
externally only via the static factory action createDefaultSalesOrder.
However, the implementation of the action uses the create operation
business-object-internally.

4    Entity Manipulation Language:
Accessing Business Logic
This chapter describes the concept, syntax, and functions of
the entity manipulation language (EML) to provide access to
RAP business objects.
The entity manipulation language (EML) is a part of the ABAP
language that provides access to RAP business objects. Since
business objects are typically used via the OData protocol from
outside (e.g., via a SAP Fiori interface or a web API), the EML must
enable type-safe access to business objects directly via ABAP. EML
interacts with business objects by triggering the operations defined
for the business object’s specific entities. An operation can only be
triggered by EML if it has been previously defined for the
corresponding entity in the behavior definition and implemented in
the behavior implementation.
EML is mass-capable throughout, meaning that all EML operations
can be performed on individual instances and on lists of instances
(whether reading or writing). In the following sections, you’ll learn
more about EML. After an introduction, you’ll get to know new data
types in Section 4.1 and the various EML operations in Section 4.2.
Section 4.3 contains examples of how you can use EML outside of
behavior implementations.
EML plays a central role in the following use cases:

Implementing behavior of a business object within the framework
of behavior implementation
Performing operations on the business object
If you want to implement behaviors, such as validations or
investigations, a solid understanding of EML is key. The second,
important use case of EML involves access to the operations and
actions of the business object from outside. EML thus also enables
an external view of a business object from the consumer's
perspective.
In a sense, it leads a double life: It’s used for both behavior
implementation and external access. In this chapter, we’ll focus on
the behavior implementation use case. That is, we’ll look at the
business object from the inside and take the internal view of the
business object provider.
EML is an integral part of the ABAP language scope. EML
statements enable you to access the data of business object
instances in read-only mode and perform operations on the
instances (e.g., an update operation or a specific action). So, EML is
used for both read and write access. The prerequisite for accessing
the CDS entities is that they are listed in the behavior definition.
Elements of the business services are not necessary to access a
business object using EML.
An important element of EML is the IN LOCAL MODE addition. An
implementation of a business object marked with this addition is only
possible if the EML implementation consumes instances of this RAP
business object in its own behavior implementation. The IN LOCAL
MODE addition makes sure that a business object is accessed directly
without checking access control, authorization control, or dynamic
property control.

[»]  EML versus Direct Database Access
The big advantage of EML is that you can use it to access the
transaction buffer as part of the ABAP RESTful application
programming model and thus also access data that hasn’t been
updated in the database yet. EML allows you to perform read and
write operations (also on dependent entities) using the BY
ASSOCIATION addition. This way you can ensure that dependent
entities will be correctly posted together based on the modeling in
the behavior definition. You can also use EML to perform cross-
business-object operations.
4.1    Data Types
In this section, you’ll learn about data types that can be used to type
parameters correctly and with reference to an entity.
4.1.1    Derived Data Types
The ABAP compiler derives data types from the CDS views involved
to ensure the correct typing of parameters with reference to an entity
of the business object, for example in the context of a behavior
implementation. Such derived types usually contain at least the
instance key according to the CDS definition, or even the complete
line type and additional components resulting from the model.
However, all derived data types in the context of the ABAP RESTful
application programming model also contain components that don’t
originate from the entity's line type. Their names start with the %
character to avoid naming conflicts with the original components. For

example, the line type of the table for failed records (FAILED) contains
a %FAIL component to store the cause of a failed instance, and also a
%KEY include structure that contains all the primary key fields of the
entity. The most important of these components are as follows:
%CID
The content ID %CID is a temporary primary key for an instance.
It’s valid as long as no primary key gets generated by the
business object runtime. The content ID is provided by the service
adaptation description language (SADL) framework (see
Chapter 1, Section 1.2.4). If you use a create operation in EML,
you must assign the content ID yourself. The value for %CID should
be specified by the caller for each create operation. This allows
the instance being created to be uniquely identified.
The content ID establishes the relationship between the
connected entity instances. A good example of using the content
ID is a DEEP INSERT statement for multiple parent/child instances
with internal numbering and/or late numbering. In this case, the
references between the parent and child instances are established
using the content ID %CID. Another example would be the creation
of multiple instances (e.g., via create). In this case, the content ID
%CID tells you which key (including a temporary key, if applicable)
has been generated or mapped for each content ID.
%CID_REF
%CID_REF specifies a reference to the content ID %CID. An operation
at the instance level imports this content ID reference. If you want
to refer directly to a resulting instance in an EML statement, the
consumer must populate the %CID_REF with the value of the
content ID %CID. This is especially useful if it’s a newly created
instance that doesn’t have a final primary key yet. In simple terms,
we’re dealing here with the transactional key (%CID) and the
transactional foreign key (%CID_REF).

%TKY
%TKY contains all key elements of an entity from a CDS view,
including the derived key components. Derived components
include, for example, %IS_DRAFT in draft scenarios and %PID in
scenarios with late numbering.
%PID
%PID defines a preliminary ID in scenarios with late numbering.
This value remains valid until the final key is set in the
ADJUST_NUMBERS method.
%CONTROL
The %CONTROL structure specifies which elements are requested by
the consumer. Depending on the operation, the fields of the
structure provide information about which elements of the entity
are passed in the request (for create and update operations) or
which elements are requested (for read operations). For each
entity element, this structure contains a flag indicating whether or
not the corresponding field was provided or requested by the
consumer. All elements of the entity have the type ABP_BEHV_FLAG
in their %CONTROL structure.
%DATA
The %DATA structure contains all data elements of an entity from a
CDS view.
%FAIL
%FAIL stores the cause of a failed record, referring to a specific
business object instance.
%MSG
%MSG provides an instance of the IF_ABAP_BEHV_MESSAGE message
interface.

%ELEMENT
The %ELEMENT structure refers to all elements of an entity.
%PARAM
%PARAM contains the import/result type of operations.
%ISDRAFT
%ISDRAFT contains a draft record or a record to be posted.
The transactional key contains the primary key fields from the CDS
entity: %ISDRAFT, %CID and %PID, if necessary. Depending on the state,
different fields are populated; in concrete terms, this means:
%CID 
Gets populated if given during the execution of the EML
statement.
%PID
Gets populated during a create operation and then occurs after
the create statement and before the execution of the
ADJUST_NUMBERS method (see Chapter 5, Section 5.5.3). The
primary key fields are passed on.
Gets passed during early numbering after the create operation
or after the execution of the ADJUST_NUMBERS method.
%ISDRAFT
Gets populated depending on whether an instance is a draft or an
active instance. The other properties remain unaffected.
4.1.2    Implicit Return Parameters
The interaction handler and save handler methods have some
implicit return parameters. These implicit parameters can be
declared as return parameters in the signatures of the interaction

handler or save handler methods using the generic type DATA. The
actual typing happens during the compilation via the ABAP compiler.
Here, the derived data types are updated depending on the behavior
definition with reference to the entities.
The following implicit return parameters can be declared:
FAILED
The export parameter FAILED is defined as a nested table or deep
structure containing one error table for each entity defined in the
behavior definition. These tables contain information to identify the
record in which an error occurred. The identification is based on
the following derived data types:
%CID
%TKY
%KEY
%PKY
%FAIL
REPORTED
The export parameter REPORTED is used for returning messages.
The messages are instance-specific and can be reused by the
consumer. The parameter is a nested table containing one table
for each entity defined in the behavior definition.
The data set for which the message is relevant is identified by the
following components:
%CID
%TKY
%KEY
%PKY

%MSG
%ELEMENT
MAPPED
Like the FAILED and REPORTED parameters, the MAPPED parameter is
mapped as a nested table hierarchy and contains one table per
entity. These tables provide the consumer with ID mapping
information. They contain information about which key values for
certain content IDs were created by the application. The business
object runtime passes the created key values in all subsequent
calls in the same request and the same response.
The relevant content ID is identified by the following derived data
types:
%CID
%TKY
%KEY
%PKY

4.2    EML Operations
The following sections provide an overview of the different EML
operations and describe their options. An EML operation represents
an access to entities of a business object (read or write access).
Table 4.1 contains an overview of which EML operations cause
which return parameters to be populated.
EML Operation FAILED MAPPED REPORTED
READ
X
–
X
MODIFY
X
X
X
GET PERMISSIONS
X
–
X
SET LOCKS
X
–
X
COMMIT
X
–
X
ROLLBACK
X
–
X
Table 4.1     Overview of the Implicit Return Parameters of EML Operations
4.2.1    READ ENTITIES
Using a READ ENTITIES statement, you can access entities in a read-
only manner and determine instances and fields within the
framework of EML. This statement can be regarded as a basic
operation that provides all necessary data for the business logic
that’s subsequently implemented.
Read access to CDS entities is performed using the EML language
element READ ENTITIES. You can add key values of the business

object instances you want to read. READ ENTITIES enables you to
access the transaction buffer of the current business object, for
example, to read field contents for validation and then check them. If
the data isn’t yet in the transaction buffer, it will be read from the
database. You can still directly model pure data selections based on
any filter criteria using CDS entities.
[»]  Different Behavior in the Managed and Unmanaged
Scenarios
When you implement an application in the managed scenario, the
reading of the transaction buffer is handled by the RAP framework
as part of the READ ENTITIES statement. In the unmanaged scenario
you need to read the transaction buffer yourself. This requires an
implementation of READ ENTITIES as part of the method with the FOR
READ addition in the interaction handler of the behavior
implementation (see Chapter 5, Section 5.4.7).
Listing 4.1 shows the general syntax of a READ ENTITIES statement.
READ ENTITIES OF root_name 
   ENTITY entity_1_name 
     FROM it_instance 
       RESULT it_result | DATA(it_result) 
     BY \assoc_name FROM it_instance_rba 
       RESULT it_result_rba | DATA(it_result_rba) 
       LINK   it_link_rba | DATA(it_link_rba) 
     EXECUTE action_name FROM it_instance_a 
       RESULT it_result_a | DATA(it_result_a) 
       LINK   it_link_a | DATA(it_link_a) 
   ENTITY entity_name_2 
   ... 
  [FAILED   it_failed | DATA(it_failed)] 
  [REPORTED it_reported | DATA(it_reported)]. 
Listing 4.1     Syntax of the Read Entities Statement
In Listing 4.2, you can see an example of using the READ ENTITIES
statement to implement a read access as part of an action. In this

case, the columns travel_id, agency_id, customer_id, booking_fee,
total_price, and currency_code are read from the travel entity for
the primary keys contained in the internal table keys. The internal
table specified after the RESULT keyword serves as a response
parameter for the result of the read operation. The type of the
response parameter lt_read_result is derived from the specified
entity (travel) and from the read operation triggered by the RAP
framework.
READ ENTITIES OF /dmo/i_travel_m IN LOCAL MODE
  ENTITY travel
     FIELDS ( travel_id
              agency_id
              customer_id
              booking_fee
              total_price
              currency_code )
       WITH CORRESPONDING #( keys )
     RESULT    DATA(lt_read_result)
     FAILED    failed
     REPORTED  reported. 
Listing 4.2     Sample Implementation of the READ ENTITIES Statement from the
copy_travel Method of the /dmo/bp_travel_m Class
During read access the implicit return parameters FAILED and
REPORTED are populated with data. In contrast to a SELECT statement
with the SINGLE addition, READ ENTITIES doesn’t read the database but
the transaction buffer of the application (i.e., you receive the current
state of the data back from the application).
In addition to the case described above, there’s a second variant of
the READ ENTITIES statement: the read-by-association variant (see
also Chapter 3, Section 3.10.2). This statement allows you to read
instances of entities linked to an entity by association via the former
entity. The example shown in Listing 4.3 demonstrates how you can
access the _Booking entity that is linked by association via the Travel
entity. Here, the airfares are read from the _Booking entity (i.e., the

bookings), and totaled later in the method to calculate the total price
for the trip (Travel entity).
READ ENTITIES OF /DMO/I_Travel_D IN LOCAL MODE
  ENTITY Travel BY \_Booking
    FIELDS ( FlightPrice CurrencyCode )
  WITH VALUE #( ( %tky = <fs_travel>-%tky ) )
  RESULT DATA(lt_booking). 
Listing 4.3     Sample Implementation of Read Entities ... BY <Association> from the
reCalcTotalPrice Method of the /dmo/bp_travel_d Class
This example is a good illustration of how useful the read-by-
association variant is, because it can be applied to many scenarios
that contain entities with parent-child relationships. For example, for
sales orders, you have statuses at both the header and item levels,
with the header level status set as a function of the items. The status
update at the header level could therefore be mapped to an internal
action for determining the item statuses in the behavior
implementation using the read-by-association variant.
4.2.2    MODIFY ENTITIES
Write access is enabled via the EML language element MODIFY
ENTITIES. Here, you also need to specify the key values of the
business object instances you want to change. Standard operations
or actions can be called for the changes.
Listing 4.4 shows the general syntax of a MODIFY ENTITIES statement.
MODIFY ENTITIES OF root_name 
  ENTITY entity_1_name 
    CREATE FROM it_instance 
    CREATE BY \assoc_name FROM it_instance_cba 
    UPDATE FROM it_instance_u 
    DELETE FROM it_instance_d 
    EXECUTE action_name FROM it_instance_a 
      [RESULT it_result_a | DATA(it_result_a)] 
  ENTITY entity_2_name 
    ... 

  [FAILED   it_failed | DATA(it_failed)] 
  [MAPPED   it_mapped | DATA(it_mapped)] 
  [REPORTED it_reported | DATA(it_reported)]. 
Listing 4.4     Syntax of the Modify Entities Statement
The example from Listing 4.5 shows how you can implement the
creation of a new record using the EML operation MODIFY ENTITIES.
After CREATE FIELDS, you need to specify all fields that are supposed
to be populated during the creation; all other entity fields remain
initial. The contents of the fields are taken from the internal table
lt_create in this example. As with any call of the EML operation
MODIFY ENTITIES, all three implicit return parameters are populated
(MAPPED, FAILED, REPORTED).
MODIFY ENTITIES OF /dmo/i_travel_m IN LOCAL MODE
    ENTITY travel
           CREATE FIELDS (    travel_id
                              agency_id
                              customer_id
                              begin_date
                              end_date
                              booking_fee
                              total_price
                              currency_code
                              description
                              overall_status )
           WITH lt_create
         MAPPED   mapped
         FAILED   failed
         REPORTED reported. 
Listing 4.5     Sample Implementation of the Modify Entities Statement with a Create
Operation from the copyTravel Method of the /dmo/bp_travel_m Class
Listing 4.6 shows a variant of the MODIFY ENTITIES statement with
create operation, a create-by-association (see Section 3.10.2). In
the example, two booking instances are created based on the
created travel instance. This type of creation is used whenever
there’s an association. Especially in the case of a composition, the
create-by-association variant plays an important role, because the

entity that’s linked to the other entity by composition can’t exist alone
(as is the case for header and item entities, for example).
...
    MODIFY ENTITIES OF /DMO/I_Travel_D
        ENTITY Travel
          CREATE FIELDS ( 
             CustomerID AgencyID BeginDate 
             EndDate Description ) WITH create
          CREATE BY \_Booking
          FIELDS ( CustomerID AirlineID ConnectionID 
             FlightDate ) WITH VALUE #( ( 
             %cid_ref = 'create_travel' 
             %target = VALUE #( ( 
                    %cid         = 'create_booking_1'
                    %is_draft    = if_abap_behv=>mk-off
                    CustomerID   = '1'
                    AirlineID    = flight-AirlineID
                    ConnectionID = flight-ConnectionID
                    FlightDate   = flight-FlightDate )
             (    %cid         = 'create_booking_2'
                    %is_draft    = if_abap_behv=>mk-off
                    CustomerID   = '1'
                    AirlineID    = flight-AirlineID
                    ConnectionID = flight-ConnectionID
                    FlightDate   = flight-FlightDate )     ) ) )
    MAPPED DATA(mapped)
    REPORTED DATA(reported)
    FAILED DATA(failed).
... 
Listing 4.6     Sample Implementation of Modify Entities Statement with Create-By-
Association Operation
The MODIFY ENTITIES statement triggers the EML operations create
and create-by-association of the Travel entity, which is why the
Travel entity must be specified here. This is done using the alias
specified for the entity in the behavior definition. The CREATE FIELDS
keywords are followed by the names of the fields to be populated.
After the WITH keyword, the name of the internal table is specified on
the basis of which the Travel instance is to be created. The derived
data type, with which the internal table is typed, ensures the type-
safe creation of the Travel instance.

Using the example from Listing 4.7, you can see how you can
implement an update operation with the MODIFY ENTITIES command.
The operation is introduced by the keywords MODIFY ENTITIES OF,
followed by the name of the behavior definition of the business
object to which the statement refers. This operation updates the
OverallStatus field from the Travel entity based on the transaction
key (%tky).
MODIFY ENTITIES OF /DMO/I_Travel_D IN LOCAL MODE
  ENTITY Travel
    UPDATE FIELDS (  OverallStatus )
    WITH VALUE #( FOR key IN keys ( 
                    %tky          = key-%tky
                    OverallStatus = travel_status-accepted )) 
Listing 4.7     Sample Implementation of the Modify Entities Statement with Update from
the acceptTravel Method of the /dmo/bp_travel_d Class
[»]  Modify Entities Statement with Update Operation
It’s no longer recommended to use the SET FIELDS WITH keyword to
populate fields when names are the same. It’s better to list the
fields separately (FIELDS (...) WITH) or to use the %CONTROL
structure (AUTO FILL CID WITH fields_tab).
A syntax check for static fields via the readonly property isn’t
possible when using the SET FIELDS WITH keyword (unlike a field list
with FIELDS (...) WITH). Also, with this variant, fields can’t be set to
their initial values. For more information, see SAP Help Portal at
http://s-prs.de/v868505.
The DELETE statement can be used to delete the instances of an
entity. For example, the statement from Listing 4.8 deletes an
instance of the Travel entity. It can be used in a separate unit test
class to test the delete operation of the reference business object.

...
MODIFY ENTITIES OF /DMO/I_Travel_D 
  ENTITY TRAVEL 
    DELETE FROM VALUE #( ( TravelUUID = lv_travel_id
                           %is_draft  = if_abap_behv=>mk-off ) )
FAILED DATA(failed)
REPORTED DATA(reported).
... 
Listing 4.8     Sample Implementation of the Modify Entities Statement with Delete
Operation
You can use the EXECUTE <action> statement to execute actions. For
example, you can define your own action as part of the behavior
definition and then call it explicitly using the EXECUTE statement as
part of a MODIFY ENTITIES statement. In the example from Listing 4.9,
the internal action reCalcTotalPrice is called on an instance of the
Travel entity, which is used to recalculate the total price.
MODIFY ENTITIES OF /DMO/I_Travel_D IN LOCAL MODE
  ENTITY Travel
    EXECUTE reCalcTotalPrice
    FROM CORRESPONDING #( keys )
REPORTED DATA(lt_reported). 
Listing 4.9     Sample Implementation of the MODIFY ENTITIES Statement from the
calculateTotalPrice Method of the /dmo/bp_travel_d Class with Execution of an Action
As you can see in the examples, the EML language element MODIFY
ENTITIES is very powerful and has many manifestations that can be
useful in mapping business process logic.
4.2.3    GET PERMISSIONS
You can use the GET PERMISSIONS statement to check whether
necessary permissions exist to access an entity. Global and
instance-based authorization checks (see Chapter 3, Section 3.14)
and the feature control for the operations create, create-by-
association, update, and delete (see Chapter 3, Section 3.16.1) can

all be queried. Authorization checks for custom actions and fields
can also be performed this way.
[»]  Availability of the Get Permissions Statement
The GET PERMISSIONS statement is only available as of SAP
S/4HANA 2021.
Listing 4.10 shows the general syntax of this statement.
GET PERMISSIONS [PRIVILEGED] [only_clause] OF bdef 
     ENTITY bdef1 [FROM keys] REQUEST request RESULT result 
    [ENTITY bdef2 [FROM keys] REQUEST request RESULT result] 
    [...] 
    [response_param]. 
Listing 4.10     Syntax of the Get Permissions Statement
The code from Listing 4.11 is used to check if the logged-in user has
the authorization to perform create operations for the business
object, /DMO/I_Travel_D. You can use the ONLY clause to specify
which control features should be included in the GET PERMISSIONS
command (e.g., whether it should be global or instance-specific).
* Declare derived types
DATA: request_ga TYPE STRUCTURE FOR PERMISSIONS REQUEST 
/DMO/I_Travel_D.
 
* Activate check for the creation process
request_ga-%create = if_abap_behv=>mk-on.
 
* Perform authorization check
GET PERMISSIONS ONLY GLOBAL AUTHORIZATION ENTITY /DMO/I_Travel_D
  REQUEST request_ga
RESULT DATA(result)
FAILED DATA(failed)
REPORTED DATA(reported). 
Listing 4.11     Sample Implementation of the Get Permissions Statement

4.2.4    SET LOCKS
Using the SET LOCKS statement you can apply an explicit lock to
business objects. Usually, you don’t need to lock your application's
business objects for changes because the RAP framework
automatically locks all objects that appear in the FOR MODIFY methods
of the behavior implementation. However, SET LOCKS enables you to
specifically lock any business object. The idea behind this is that you
should be able to lock instances of business objects that you
indirectly need as part of your application to protect them from
concurrent changes.
Listing 4.12 shows the general syntax of the SET LOCKS statement.
SET LOCKS OF root_name 
   ENTITY entity_1_name FROM lt1 
  [ENTITY entity_2_name FROM lt2 ...] 
  [FAILED   it_failed] 
  [REPORTED it_reported]. 
Listing 4.12     Set Locks Syntax
The example from Listing 4.13 shows how you can lock an instance
of the Travel entity with the Travel_ID = '00000001' key from
business object /DMO/I_Travel_M. You can insert this call in any
application without reference to the /DMO/I_Travel_M business object.
SET LOCKS OF /DMO/I_Travel_M
    ENTITY TRAVEL
FROM VALUE #( (  Travel_ID = '00000001' ) )
FAILED DATA(lt_failed)
REPORTED DATA(lt_reported). 
Listing 4.13     Sample Implementation of the Set Locks Statement
[ ! ]  Warning: Selectively Use Set Locks Statement
You should use the SET LOCKS statement only when you need to
lock instances that aren’t included in the current FOR MODIFY

method of your behavior implementation. All instances contained
in the method are automatically locked by the RAP framework.
4.2.5    COMMIT ENTITES
The COMMIT ENTITIES statement triggers the save sequence. This
means that the data from the transaction buffer is written to the
database for all business objects that have been changed within the
current logical unit of work (LUW). COMMIT ENTITIES must be explicitly
specified for change operations that are triggered outside of a
behavior implementation to terminate the LUW. In general, the owner
of a transaction also triggers the COMMIT ENTITIES. In the case of
RAP-based OData services, the RAP framework is the owner and
accordingly triggers the COMMIT ENTITIES. Here you don’t need to do
anything. On the other hand, if you make changes via the EML, for
example within a report, you’ll be the owner and must trigger the
COMMIT ENTITIES.
Listing 4.14 shows the general syntax of this statement.
COMMIT ENTITIES 
  [RESPONSE OF root_name_1 
    [FAILED    it_failed   | DATA(it_failed)] 
    [REPORTED  it_reported | DATA(it_reported)]] 
  [RESPONSE OF root_name_2 
    [FAILED    it_failed   | DATA(it_failed)] 
    [REPORTED  it_reported | DATA(it_reported)]]. 
Listing 4.14     Syntax of the Commit Entities Statement
With the addition IN SIMULATION MODE, the EML statement COMMIT
ENTITIES can be executed in test mode (i.e., the backup sequence is
executed without actually saving the data). This concerns the
methods with the additions FINALIZE, CHECK_BEFORE_SAVE, and
CLEANUP or CLEANUP_FINALIZE. A final COMMIT WORK doesn’t implicitly

exist in this variant. A use case for COMMIT ENTITIES with the IN
SIMULATION MODE addition is when a non-RAP application modifies
data. It must therefore persist the data itself and it has its own
backup logic.
The addition CONVERT KEY OF specifies the business object whose
keys are to be converted. As a consumer, you can apply the CONVERT
KEY statement to a root entity to retrieve the final key value assigned
to an instance of a business object in the method with the
ADJUST_NUMBERS addition and use it for further processing. You can’t
use CONVERT KEY for instances of your own business object, but only
for foreign RAP business objects (e.g., in a cross-business object
relationship). CONVERT KEY can also only be used in the late save
sequence during COMMIT when the final key values are assigned.
4.2.6    ROLLBACK ENTITIES
Similar to the COMMIT ENTITIES statement, you only need the ROLLBACK
ENTITIES statement outside of a behavior implementation. You can
use this statement to reset the transaction buffer. This resets the
data to the status of the last COMMIT ENTITIES.
The syntax is simple:
ROLLBACK ENTITIES. 
[+]  Tip: Further Information about the Entity Manipulation
Language
For more information on the correct use of EML operations (as
business object provider and business object consumer), you
should refer to the RAP business object contract documentation in
SAP Help Portal at http://s‐prs.de/v868506. The documentation

describes the parameters populated in each situation or
parameters that are to be populated by the provider.

4.3    Using EML Outside of Behavioral
Implementations
So far, we’ve primarily described the use of EML in the context of
behavioral implementations. However, you can use EML in other
contexts to access business object logic implemented in behavioral
implementations. For example, you can use EML as part of an ABAP
report or an ABAP unit test class.
4.3.1    Use in the Context of an ABAP Report
One possible use case of EML is its use in ABAP reports.
Listing 4.15 shows an example of a highly simplified report based on
EML operations. The read accesses are done with the READ ENTITIES
operation; the write accesses are mapped with MODIFY ENTITIES.
REPORT zrap_eml_test_unmanaged_v2.
DATA: gr_alv          TYPE REF TO cl_salv_table.
 
PARAMETERS pa_show TYPE xfeld DEFAULT 'X'.
PARAMETERS pa_trav TYPE /dmo/travel_id DEFAULT '00000001'.
PARAMETERS pa_desc TYPE /dmo/description DEFAULT 'Test 1'.
 
START-OF-SELECTION.
  IF pa_show = 'X'.
* Execute READ ENTITIES for the Travel ID found
    READ ENTITIES OF /DMO/I_Travel_U
    ENTITY travel
    ALL FIELDS
    WITH VALUE #( ( travelid = pa_trav ) )
    RESULT DATA(gt_my_Sales_Orders).
    TRY.
        CALL METHOD cl_salv_table=>factory
          EXPORTING
            list_display = if_salv_c_bool_sap=>false
          IMPORTING
            r_salv_table = gr_alv
          CHANGING
            t_table      = gt_my_Sales_Orders.
        ##NO_HANDLER.

      CATCH cx_salv_msg.
    ENDTRY.
    CALL METHOD gr_alv->display.
  ELSE.
    " UPDATE of travel dates
    MODIFY ENTITY /DMO/I_Travel_U
       UPDATE FIELDS ( memo )
       WITH VALUE #( (
              travelid          = pa_trav
              memo              = pa_desc ) )
    FAILED   DATA(ls_failed)
    REPORTED DATA(ls_reported).
* Update data in the database
    IF ls_failed IS INITIAL.
* Start save sequence -> FINALIZE ...
      COMMIT ENTITIES.
* Execute READ ENTITIES for the Travel ID found
      READ ENTITIES OF /DMO/I_Travel_U
      ENTITY travel
      ALL FIELDS
      WITH VALUE #( ( travelid = pa_trav ) )
      RESULT gt_my_Sales_Orders.
      TRY.
          CALL METHOD cl_salv_table=>factory
            EXPORTING
              list_display = if_salv_c_bool_sap=>false
            IMPORTING
              r_salv_table = gr_alv
            CHANGING
              t_table      = gt_my_Sales_Orders.
          ##NO_HANDLER.
        CATCH cx_salv_msg.
      ENDTRY.
      CALL METHOD gr_alv->display.
    ENDIF.
  ENDIF. 
Listing 4.15     Sample Implementation of EML Operations in an ABAP Report
When you use EML in ABAP reports, it’s important to note that data
changes must always be completed using the EML operation COMMIT
ENTITIES, since they aren’t part of the behavior implementation.
4.3.2    Implementation in the Context of a Test Class
Another possible use case of EML is the use in test classes for the
ABAP Unit test framework. The example from Listing 4.16 shows

how you can use EML in the context of a test class for reading data.
In the first step, one row of the internal table mt_read_travel is filled
with travel_id = '110', all other fields remain empty. The internal
table is only needed to have a reference in the mock data as part of
the test method. The mock data is assigned to the
mo_test_environment object (type if_cds_test_environment). After
the read access via the READ ENTITIES statement, the determined
value from the travel_id field is compared with the value '110'. If
this value was found, the test was successful.
  METHOD read_ok.
    mt_read_travel =  VALUE #( (
                              travel_id = '110'
                             ) ).
* Generate test data
    mo_test_environment->insert_test_data( 
                    i_data = mt_read_travel  ).
 
    READ ENTITIES OF /DMO/I_Travel_U
    ENTITY travel ALL FIELDS WITH
       VALUE #( ( 
            %key-TravelID = mt_read_travel[ 1 ]-travel_id 
       ) )
      RESULT DATA(lt_read_travel)
      FAILED DATA(ls_failed)
      REPORTED DATA(reported).
 
    cl_abap_unit_assert=>assert_equals(
    EXPORTING
      act                  =  lt_read_travel[ 1 ]-travelid
      exp                  =  '110'
      msg                  = 'Error reading the data.'
  ).
  ENDMETHOD. 
Listing 4.16     Test Class for Read Access
Although this is a highly simplified example of an ABAP Unit test, it
can still illustrate how you can include EML operations in test
classes.
[»]  Test Class Used

The complete test class ztc_eml_travel around the two ABAP Unit
test methods used can be found in the development package in
the download material of this book at www.sap-press.com/5647.
Further examples can be found in the official RAP documentation
in the chapter, “Test Guide” (see http://s-prs.de/v868507).
In the following chapter, you’ll learn more about behavior
implementations and how you can use EML in these
implementations.

5    Behavior Implementation
This chapter provides an overview of the behavior
implementations. We’ll explain in detail how the interface is
structured and at which points or times a behavior
implementation can be performed in the program.
In Chapter 3, you learned what a behavior definition is, what
operations it supports, what options you have for implementing
custom logic, and how it comes into play in the various scenarios of
the programming model. After that, in Chapter 4, we described the
various options provided by the entity manipulation language (EML).
In this chapter, we’ll now show you how you can implement the
behavior definitions from Chapter 3 and where you can use EML to
do so.
In Section 5.1, we’ll first describe how the behavior implementation is
defined and what is behind the business object provider ID. We’ll
then describe how the runtime behavior of the ABAP RESTful
application programming model is structured in Section 5.2. The
runtime behavior interfaces are presented in Section 5.3. Finally,
Section 5.4 and Section 5.5 present the concrete methods for
implementing the behavior in the interaction handler and the save
handler, respectively.
5.1    Business Object Provider API

In simple terms, the Business Object Provider API is the
programming interface for behavior implementation. One or more
behavior implementations can be specified for each behavior
definition. These behavior implementations are also called behavior
pool. In fact, these are special ABAP classes.
You need a behavior implementation if you want or need to
implement the behavior of a business object yourself. The ABAP
class you implement in the process is referenced by the behavior
definition.
Note that a business object doesn’t necessarily need a behavior
implementation if the desired behavior can already be provided by
the runtime of the business object (business object runtime). This
could be the case in the managed scenario. But even if you use a
standard business object, you can implement certain behavior (e.g.,
validation of a certain data constellation) via your own behavior
implementation.
If you implement your application in the unmanaged scenario or
don’t use standard operations, you must implement the essential
parts of the business object runtime yourself. To do this, you must
specify all the desired operations including the standard operations
(e.g., create, update, delete) in the behavior definition using behavior
definition language (BDL) and then reference and implement them in
the associated behavior implementation using ABAP and EML.

5.2    Runtime Behavior of the ABAP RESTful
Application Programming Model
A key feature of the ABAP RESTful application programming model
consists of defining the program flow for processing business
operations through the business object runtime (see Chapter 1,
Section 1.1.1). As described in Chapter 1, Section 1.2.1, this
program or processing flow can be divided into the following two
phases:
Interaction phase
Save sequence
The two phases are linked via the transaction buffer. In the simplest
case, the transaction buffer can be an internal table, which provides
the necessary data of the business objects for the respective
operation. Figure 5.1 shows an overview of interaction phase, save
sequence, and transaction buffer in the context of the business
object runtime. We’ll describe the methods listed here in greater
detail in Section 5.4 and Section 5.5.
Figure 5.1     Phases of the Program Flow within the Business Object Runtime

5.2.1    Interaction Phase and Transaction Buffer
During the interaction phase, consumers of a business object (e.g., a
SAP Fiori UI, another RAP business object, or an integration test)
perform operations on that object. For example, the header data of
the root entity gets changed (update), an item is added (create), or
another item gets deleted (delete). The metadata of these changes
(i.e., which instances were created, updated, or deleted, or which
field changes were made are managed in the transaction buffer).
This means that the changes aren’t yet saved to the database, but
only to the main memory. The transaction buffer is modified by the
operations during the interaction phase, and it collects the operations
and field changes to be performed. This corresponds to the logical
unit of work (LUW) from classic ABAP programming, which is more
clearly modeled in the ABAP RESTful application programming
model with the transaction buffer.
The performed operations (i.e., the state of the transaction buffer)
will be saved persistently in the database at a certain point in time.
Saving the transaction buffer data happens in the save sequence. At
this point, you can validate the data in the transaction buffer and
cancel the saving process if necessary.
Figure 5.2 illustrates this process. Operations on a business object
instance can be performed as a local interaction via EML (in an
ABAP program) and via an OData remote API (e.g., in an SAP Fiori
UI).

Figure 5.2     Phases of the RAP Transaction Model
For a RAP-based application, the ABAP RESTful application
programming model is always the transaction owner. It triggers the
EML statement COMMIT ENTITIES after the changes (see also
Chapter 4, Section 4.2.5). In contrast, in an application that hasn’t
been developed using the ABAP RESTful application programming
model, such as an ABAP report that performs change operations on
a RAP-based business object using EML, the ABAP RESTful
application programming model is not the transaction owner. In this
case, the COMMIT ENTITIES command must therefore be actively
executed as part of the ABAP report. The transaction buffer is
reinitialized after the save sequence has been executed. In the
unmanaged scenario, the initialization of the transaction buffer must
be done manually as part of the CLEANUP method (Section 5.5.5 and
Section 5.5.6). The interaction phase is implemented in the
interaction handler.
[»]  Commit Entities versus Commit Work Commands
The COMMIT ENTITIES and COMMIT WORK commands are “married”
internally in the system so that a transaction owner who isn’t in the

ABAP RESTful application programming model needn’t know that
a RAP business object is involved and nested somewhere. Thus,
COMMIT ENTITIES does the same thing as COMMIT WORK and vice
versa. COMMIT ENTITIES only provides additional options, such as
fetching the implicit return parameters REPORTED and FAILED (see
Chapter 4, Section 4.1.2) or the CONVERT KEY statement. The
CONVERT KEY command can be used to convert the key information
from the implicit return parameter MAPPED into a semantic key, so
the derived data type (e.g., %CID) gets converted into actual key
fields.
5.2.2    Save Sequence
The save sequence is a part of the business object runtime along
with the interaction phase. It gets called when one or more
operations have been successfully triggered during the interaction
phase. In the first step, the FINALIZE method, the final calculations
are performed for all involved business objects in the current LUW.
After that, the data mustn’t be changed. Any change to the data after
this step will result in a runtime error.
Then there is a step to check the data for the last time before saving.
This check is performed as part of the CHECK_BEFORE_SAVE method.
No more changes can be made in this method. This ensures that
each business object has a final status and can be checked.
The point of no return is then reached (i.e., no more errors are
allowed to occur), either in the data or in the business process.
Errors may only occur in the methods of the two steps before the
point of no return (i.e., in the FINALIZE and CHECK_BEFORE_SAVE
methods). If an error occurs within these methods, this error must be
reported back so that the user can correct it.

The only change that’s still possible now is numbering, provided that
the principle of late numbering (late numbering) is used.
Subsequently, the data from the transaction buffer will be written to
the database. Once the data has been written, the CLEANUP,
CLEANUP_FINALIZE, and ROLLBACK ENTITIES methods are used to clear
the data from the transaction buffer. The save sequence is
implemented in the save handler.

5.3    Interfaces for the Interaction Handler
and the Save Handler
In the previous sections, you learned about the Business Object
Provider API and the runtime behavior of the ABAP RESTful
application programming model. The Business Object Provider API
provides you with a hierarchical collection of classes. The class at
the highest level is CL_ABAP_BEHV. This class defines basic data types
for behavior implementation and methods for message creation as
part of the behavior implementation.
Two other classes are derived from this class:
The CL_ABAP_BEHAVIOR_HANDLER class is the base class for the
interaction handler.
The CL_ABAP_BEHAVIOR_SAVER class is the base class for the save
handler. It specifies the signature of all methods used to
implement the save sequence of a business object provider.
Figure 5.3 provides an overview of this class hierarchy.
Figure 5.3     Classes of the Business Object Provider API

A behavior implementation is created in a global, abstract and final
class with reference to a behavior definition. For this reason, such a
behavior implementation can only be used with reference to the
business object. The behavior implementation can include static
methods, attributes, constants and types.
The actual flow logic is mapped in the context of local classes in the
behavior implementation. A local class inherits either from the
CL_ABAP_BEHAVIOR_HANDLER class or from the CL_ABAP_BEHAVIOR_SAVER
class. So, the local classes map either the interaction handler or the
save handler. One or more local handler classes can be defined and
implemented as part of a behavior implementation.

5.4    Interaction Handler
As described in Section 5.3, the interaction handler class inherits
from the CL_ABAP_BEHAVIOR_HANDLER class and is implemented as a
local class in the behavior implementation.
The example in Listing 5.1 uses the /dmo/bp_travel_u behavior
implementation to show how the interaction handler definition can be
constructed.
CLASS lhc_travel DEFINITION INHERITING FROM cl_abap_behavior_handler.
  PRIVATE SECTION.
    TYPES:
         tt_travel_update TYPE TABLE 
           FOR UPDATE /dmo/i_travel_u.
    METHODS:
      create_travel     FOR MODIFY
        IMPORTING it_travel_create FOR CREATE travel,
      update_travel     FOR MODIFY
        IMPORTING it_travel_update FOR UPDATE travel,
      delete_travel     FOR MODIFY
        IMPORTING it_travel_delete FOR DELETE travel,
      read_travel       FOR READ
        IMPORTING it_travel FOR READ travel
        RESULT    et_travel,
      create_booking_ba FOR MODIFY
        IMPORTING it_booking_create_ba 
           FOR CREATE travel\_booking,
      read_booking_ba   FOR READ
        IMPORTING it_travel  FOR READ travel\_Booking
                    FULL iv_full_requested
        RESULT    et_booking
                    LINK et_link_table,
      lock              FOR LOCK
        IMPORTING it_travel_lock FOR LOCK travel,
      set_travel_status FOR MODIFY
        IMPORTING it_travel_set_status_booked 
           FOR ACTION travel~set_status_booked
        RESULT    et_travel_set_status_booked,
      get_features      FOR FEATURES
        IMPORTING keys   REQUEST requested_features 
           FOR travel
        RESULT    result.
ENDCLASS. 

Listing 5.1     Example of Defining the Interaction Handler
In the following sections, we describe the various additions you can
use for method definitions within the interaction handler class
definition. Then, you can implement the methods declared with these
additions.
5.4.1    FOR MODIFY
Methods with the FOR MODIFY addition are implemented for all change
operations for an entity (e.g., create, update, delete, and specific
actions defined in the behavior definition). Such methods can handle
multiple entities (e.g., root, element, sub-element) and multiple
operations in one processing step. Sometimes it might be useful to
split the implementation of the handler into separate methods. Then,
multiple interaction handlers can be defined, specifically multiple
local interaction handlers within a global behavior implementation or
even within multiple global behavior implementations. The question
whether one or more global behavior implementations are
appropriate must be decided on a case-by-case basis.
In the unmanaged scenario, it is usually existing code (such as
methods or function blocks) that’s called. If multiple nodes can be
processed at once in this coding, it’s recommended to pass and
process the nodes together for interconnection in the ABAP RESTful
application programming model.
The declaration of the method with the FOR MODIFY addition specifies
the change operations for which this method is responsible. A
method can handle exactly one or many change operations.
Listing 5.2 shows the syntax when working with multiple methods to
map the change operations. In this case, each creation, update, or
deletion operation for an entity is implemented in a separate method.

METHODS: 
  create_entity_method FOR MODIFY 
    [IMPORTING] create_import_parameter 
          FOR CREATE entity,
  update_entity_method FOR MODIFY 
    [IMPORTING] update_import_parameter 
          FOR UPDATE entity,
  delete_entity_method FOR MODIFY 
    [IMPORTING] delete_import_parameter 
          FOR DELETE entity,
  action_method FOR MODIFY 
    [IMPORTING] action_import_parameter 
          FOR ACTION entity~action_name
    RESULT    action_export_parameter,
  create_by_association 
          FOR MODIFY 
    [IMPORTING] create_ba_import_parameter 
          FOR CREATE entity\_association. 
Listing 5.2     Syntax of the Method Declaration with the FOR MODIFY Addition with
Several Methods
Listing 5.3, on the other hand, shows the syntax for implementing all
operations with only one method.
METHODS modify_method FOR MODIFY 
  [IMPORTING]
    create_import_parameter      FOR CREATE entity
    update_import_parameter      FOR UPDATE entity
    delete_import_parameter      FOR DELETE entity
    action_import_parameter 
                      FOR ACTION entity~action_name
      [REQUEST requested-fields]
      [RESULT action_export_parameter]
    create_ba_import_parameter 
      FOR CREATE entity\_association. 
Listing 5.3     Syntax of the Method Declaration with the FOR MODIFY Addition with Only
One Method
The IMPORTING keyword can be used for improved readability, but it
isn’t mandatory. The used parameters of the methods can
alternatively be declared as reference parameters via the REFERENCE
keyword. However, a declaration as a value passing parameter using
the VALUE keyword is not allowed.

The transfer as a reference parameter has a consequence: the
parameters can’t be changed. The data types with which the
parameters are implicitly provided by the ABAP compiler are derived
types that result from the entities of the behavior definition.
The method with the FOR MODIFY addition has three implicit return
parameters by default: FAILED, MAPPED, and REPORTED. These
parameters are structure types with one component per entity from
the behavior definition (i.e., per entity in a business object). The
names of the components are the alias names defined in the
behavior definition. If an alias hasn’t been assigned, the names of
the components are the entity names.
Since all parameters and components of these structures are tables,
mass processing is possible. Together with the bundling of several
operations in one method, it is thus possible to implement extensive
changes in a single FOR MODIFY method call.
The business object framework doesn’t specify a mandatory order
for processing the individual operations of the FOR MODIFY methods.
However, the operations should be processed in an order that makes
sense. For example, a creation operation should be performed
before an update operation.
Listing 5.4 shows an example of an implementation of the interaction
handler class.
CLASS lhc_travel DEFINITION INHERITING FROM cl_abap_behavior_handler.
 
  PRIVATE SECTION.
 
...
    METHODS set_status_completed       FOR MODIFY 
       IMPORTING   keys FOR ACTION travel~acceptTravel 
       RESULT result.
...
ENDCLASS.
 
CLASS lhc_travel IMPLEMENTATION.

...
  METHOD set_status_completed.
 
* business-object-related changes in local mode 
* Changes are not relevant for authorization checks
    MODIFY ENTITIES OF /dmo/i_travel_m IN LOCAL MODE
           ENTITY travel
              UPDATE FIELDS ( overall_status )
                 WITH VALUE #( FOR key IN keys ( 
                   travel_id      = key-travel_id
                   overall_status = 'A' ) ) " Accepted
           FAILED   failed
           REPORTED reported.
 
    " Reading the changed data 
    READ ENTITIES OF /DMO/I_Travel_M IN LOCAL MODE
         ENTITY travel
           FIELDS ( agency_id
                    customer_id
                    begin_date
                    end_date
                    booking_fee
                    total_price
                    currency_code
                    overall_status
                    description
                    created_by
                    created_at
                    last_changed_at
                    last_changed_by )
             WITH VALUE #( FOR key IN keys ( 
                    travel_id = key-travel_id ) )
                    RESULT DATA(lt_travel).
 
    result = VALUE #( FOR travel IN lt_travel ( 
             travel_id = travel-travel_id
             %param    = travel ) ).
 
  ENDMETHOD.
...
ENDCLASS. 
Listing 5.4     Sample Implementation for a FOR MODIFY Method
5.4.2    FOR INSTANCE AUTHORIZATION
In methods with the FOR INSTANCE AUTHORIZATION addition, instance-
based authorization checks can be implemented to access the

entities. A method for instance-based authorization checking is
called directly before the modification of the respective instance. At
this point, the authorization can only be checked based on the state
of the instance before the change request was triggered. This state,
called the before-image, is thus relevant for the authorization check.
You don’t have the option to check authorizations against incoming
values. To check the entered values in the interaction handler
methods, you would have to implement the operation with the FOR
PRECHECK addition (Section 5.4.12).
Listing 5.5 shows the syntax of this method declaration. The square
brackets indicate optional elements. The curly brackets contain
alternatives separated from each other by a vertical line.
METHODS meth [FINAL] 
   FOR [INSTANCE] AUTHORIZATION 
   [IMPORTING] { REFERENCE(im_par_auth) | im_par_auth } 
   REQUEST { REFERENCE(req_auth) | req_auth } 
   FOR bdef 
   RESULT { REFERENCE(res_auth) | res_auth } 
  [CHANGING { [failed TYPE data] [reported TYPE data] }]. 
Listing 5.5     Syntax for the Declaration of FOR INSTANCE AUTHORIZATION Methods
The following import parameters can be passed:
im_par_auth 
This parameter is an internal table of type FOR AUTHORIZATION KEY,
which is used to pass the keys of the instances that are to be
checked. The parameter can also be passed as a reference
parameter using the REFERENCE keyword. The use of the IMPORTING
keyword is optional.
req_auth 
req_auth is a request parameter that serves as the basis for
information retrieval for instance-based authorization checking.
This is a structure of type FOR AUTHORIZATION REQUEST. For all

operations marked FOR INSTANCE AUTHORIZATION in the behavior
definition, a check is made to see if there’s an element in the
derived data type that states that the authorization for this
operation/action must be determined. The parameter can also be
passed as a reference parameter.
The following return parameters can be passed to the methods with
the FOR INSTANCE AUTHORIZATION addition:
The res_auth parameter is used to pass the result of retrieving the
authorization information to the RAP framework. This is an internal
table of the FOR AUTHORIZATION RESULT type. The parameter can
also be passed by reference. If the return table is returned empty,
full permission will be granted.
The FAILED and REPORTED return parameters are implicitly
available. The FAILED parameter gets populated if the
determination was technically unsuccessful (e.g., for the value
not_found). The REPORTED parameter is populated to return the
information that the required permission is missing.
Listing 5.6 shows an example of the implementation of the FOR
INSTANCE AUTHORIZATION method in an interaction handler class.
CLASS lhc_travel DEFINITION INHERITING FROM cl_abap_behavior_handler.
 
  PRIVATE SECTION.
 
...
    METHODS get_instance_authorizations 
             FOR INSTANCE AUTHORIZATION
      IMPORTING keys REQUEST requested_authorizations 
             FOR travel RESULT result.
 
ENDCLASS.
 
CLASS lhc_travel IMPLEMENTATION.
  METHOD get_instance_authorizations.
...
    READ ENTITIES OF /DMO/I_Travel_D IN LOCAL MODE
      ENTITY Travel
        FIELDS ( AgencyID )

        WITH CORRESPONDING #( keys )
    RESULT DATA(travels)
    FAILED failed.
 
    CHECK travels IS NOT INITIAL.
...
        " Authorization check before deletion
        IF delete_requested = abap_true.
          delete_granted = is_delete_granted(
           <travel_agency_country_code>-country_code ).
          IF delete_granted = abap_false.
            APPEND VALUE #( %tky = travel-%tky
                            %msg = 
                              NEW /dmo/cm_flight_messages(
                            textid = 
                 /dmo/cm_flight_messages=>not_authorized_for_agencyid
                            agency_id = travel-AgencyID
                            severity = 
                      if_abap_behv_message=>severity-error )
                            %element-AgencyID = 
                                 if_abap_behv=>mk-on
                           ) TO reported-travel.
          ENDIF.
        ENDIF.
...
  ENDMETHOD.
 
ENDCLASS. 
Listing 5.6     Sample Implementation of the FOR INSTANCE AUTHORIZATION Method
from Demo Project /dmo/bp_travel_d
5.4.3    FOR GLOBAL AUTHORIZATION
In methods with the FOR GLOBAL AUTHORIZATION addition, global
authorization checks can be implemented for the access to entities.
Since a method with this addition is independent of the state of the
entity and only checks the authorization of the user who executed
the request, the global authorization handler is normally used to
generally prohibit certain operations for certain user groups. A typical
use case of this method is to allow only certain users to enter new
entries. Since there’s no instance yet for a create operation, only a
global authorization check is possible.

Listing 5.7 shows the syntax for declaring this type of method.
METHODS meth [FINAL] 
   FOR GLOBAL AUTHORIZATION 
   [IMPORTING] { REFERENCE(im_par_gl_auth) | im_par_gl_auth } 
   REQUEST { REFERENCE(req_gl_auth) | req_gl_auth } 
   FOR bdef 
   RESULT { REFERENCE(res_gl_auth) | res_gl_auth } 
   [CHANGING reported TYPE data]. 
Listing 5.7     Syntax for the FOR GLOBAL AUTHORIZATION Methods
The request parameter req_gl_auth can be specified as an import
parameter, which serves as the basis for the information retrieval for
the instance-based authorization check. This parameter is a
structure of type FOR GLOBAL AUTHORIZATION REQUEST. Because the
global authorization check is independent of an entity instance, this
method doesn’t import any keys. For performance optimization,
however, instance-based operations or actions such as update and
delete can also be prohibited via this handler. This is useful, for
example, if there’s no update authorization at all, because in this
case this operation also doesn’t need to be recalculated for each
instance.
The res_gl_auth parameter is used to store the result of retrieving
the authorization information. This is a structure of type FOR GLOBAL
AUTHORIZATION RESULT. In addition, the return parameter REPORTED is
implicitly available, which can be used to return messages.
Listing 5.8 shows an example of implementing a FOR GLOBAL
AUTHORIZATION method in an interaction handler class.
CLASS lhc_handler DEFINITION INHERITING FROM cl_abap_behavior_handler.
 
PRIVATE SECTION. 
...
    METHODS get_global_authorizations 
      FOR GLOBAL AUTHORIZATION
      IMPORTING REQUEST requested_authorizations FOR Entity 
      RESULT result.
...

ENDCLASS.
 
CLASS lhc_handler IMPLEMENTATION.
  METHOD get_global_authorizations.
 
    IF requested_authorizations-%create EQ 
         if_abap_behv=>mk-on.
      IF is_create_granted( ) = abap_true.
        result-%create = if_abap_behv=>auth-allowed.
      ELSE.
        result-%create = if_abap_behv=>auth-unauthorized.
        APPEND VALUE #( %msg    = 
                          NEW /dmo/cm_flight_messages(
                        textid   = 
                   /dmo/cm_flight_messages=>not_authorized
                        severity = 
                    if_abap_behv_message=>severity-error )
                        %global = 
                    if_abap_behv=>mk-on ) TO reported-travel.
 
      ENDIF.
    ENDIF.
 
    "Actions are treated like updates
    IF requested_authorizations-%update                = 
             if_abap_behv=>mk-on OR
       requested_authorizations-%action-Edit           = 
             if_abap_behv=>mk-on OR
       requested_authorizations-%action-acceptTravel   = 
             if_abap_behv=>mk-on OR
       requested_authorizations-%action-rejectTravel   = 
             if_abap_behv=>mk-on OR
       requested_authorizations-%action-deductDiscount = 
             if_abap_behv=>mk-on.
...
    ENDIF.
  ENDMETHOD.
...
ENDCLASS. 
Listing 5.8     Sample implementation for the FOR GLOBAL AUTHORIZATION Methods
5.4.4    FOR FEATURES
This method implements the feature control (i.e., the dynamic
property control of entities). The feature control can be used for the
standard operations create, delete, create-by-association, and for

actions. Depending on the feature conditions, the operation is
executable or not executable.
The method with the FOR FEATURES addition is called by the RAP
runtime environment for each operation or field that’s dynamically
controlled. This method can be used to override properties from the
behavior definition for certain fields and operations (e.g., the features
active/inactive, read-only, etc.).
The operations or fields that are dynamically controlled receive the
addition features: instance in the behavior definition. Dynamic
property control for an entity is implemented in the interaction
handler class using the get_instance_features method from
Listing 5.9. The signature of this handler method is specified after
the FOR FEATURES keyword, followed by the input parameters keys and
the requested_features of the entity.
METHODS get_instance_features [FINAL] 
   FOR [INSTANCE] FEATURES 
   [IMPORTING] { REFERENCE(keys) | keys } 
   REQUEST { REFERENCE(req_feat) | req_feat } 
   FOR bdef 
   RESULT { REFERENCE(res_feat) | res_feat } 
  [CHANGING { [failed TYPE data] [reported TYPE data] }]. 
Listing 5.9     Syntax for the FOR FEATURES Method
The name of the method is arbitrary, but often the name
get_instance_features is used. For this reason, we also use this
method name in Listing 5.9.
To define the SAP Fiori user interface, the feature control is
associated with authorization checks so that only the permitted
operations are enabled. All other operations are inactive.
The following import parameters can be passed to the method:

keys
The keys table type includes all elements specified as keys for the
associated entity.
req_feat
The structure type of the req_feat parameter specifies which
elements (e.g., fields, default operations and actions) of the entity
are requested for dynamic feature control by the consumer.
The export parameter result is used to return the values of the
feature control. It’s a return table that contains, in addition to the key
fields, all the fields of the entity and the default operations and
actions for which the feature control was defined in the behavior
definition. If the table is returned empty, all features will be activated.
Listing 5.10 uses the behavior definition /DMO/I_Travel_M as an
example to show how feature control properties can be defined and
controlled at both field and operation level.
... 
  field (features : instance ) travel_id;
...
  // Instance operation and dynamic feature control
acceptTravel result [1] $self;
action  ( features: instance ) acceptTravel result [1] $self;
action  ( features: instance ) rejectTravel result [1] $self;
 ...
  // Create a booking using create-by-association
  association _Booking { create (features:instance); }
... 
Listing 5.10     Definition of the Dynamic Feature Control from the Behavior Definition for
/DMO/I_Travel_M.
The expression field (features : instance ) travel_id; specifies
that the behavior of the travel_id field can be controlled as part of
the behavior implementation in the FOR FEATURES method. The
specification action ( features: instance ) acceptTravel result [1]
$self; determines that the features of the acceptTravel operation

can be overridden in the FOR FEATURES method of the behavior
implementation.
Listing 5.11 shows the behavior implementation for the behavior
definition from Listing 5.10.
METHOD get_features.
 
  READ ENTITIES OF /dmo/i_travel_m IN LOCAL MODE
    ENTITY travel
       FIELDS (  travel_id overall_status )
       WITH CORRESPONDING #( keys )
     RESULT DATA(lt_travel_result).
 
  result = VALUE #( FOR ls_travel IN lt_travel_result
          ( %key = ls_travel-%key
            %field-travel_id = if_abap_behv=>fc-f-read_only
            %features-%action-rejectTravel = 
                  COND #( 
                  WHEN ls_travel-overall_status = 'X'
                  THEN if_abap_behv=>fc-o-disabled 
                  ELSE if_abap_behv=>fc-o-enabled  )
            %features-%action-acceptTravel = 
                  COND #( 
                  WHEN ls_travel-overall_status = 'A'
                  THEN if_abap_behv=>fc-o-disabled 
                  ELSE if_abap_behv=>fc-o-enabled   )
           %assoc-_Booking = 
                  COND #( 
                  WHEN ls_travel-overall_status = 'X'
 
                  THEN if_abap_behv=>fc-o-disabled 
                  ELSE if_abap_behv=>fc-o-enabled   )
                    ) ).
ENDMETHOD. 
Listing 5.11     Implementation of the Dynamic Feature Control from the Behavior Definition
for /DMO/I_Travel_M.
The travel_id field gets the read-only property (variant 1). This
property could also be restricted via a condition. The buttons for the
rejectTravel and acceptTravel operations will be activated or
deactivated, depending on the overall_status field from the travel
entity (variant 2). The third variant from Listing 5.11 uses the
association _Booking as an example to show how an association can

be activated or deactivated at runtime. In this example, this behavior
is also linked to the value of the overall_status field.
[»]  Important Feature Control Properties
The FC structure from the interface IF_ABAP_BHAV contains a
number of constants to control the properties in the FOR_FEATURES
method.
The FC-F structure contains the constants for the field properties.
The following properties are possible at the field level:
UNRESTRICTED, MANDATORY, READ_ONLY and ALL.
The FC-O structure contains the constants for the possible
operation-level properties. The following properties are possible
for operations: ENABLED and DISABLED.
5.4.5    FOR GLOBAL FEATURES
In methods that have the FOR GLOBAL FEATURES addition, similar to the
methods with the FOR FEATURES addition, it’s possible to implement
global feature control for entities without reference to an explicit
instance. In the behavior definition, operations that are supposed to
use the global feature control are provided with the addition
features: global.
Listing 5.12 shows the syntax for declaring a FOR GLOBAL FEATURES
method.
METHODS meth [FINAL] 
   FOR GLOBAL FEATURES 
   [IMPORTING] REQUEST { REFERENCE(req_gl_feat) | req_gl_feat } 
   FOR bdef 
   RESULT { REFERENCE(result) | result } 
   [CHANGING reported TYPE data]. 

Listing 5.12     Syntax for the FOR GLOBAL FEATURES Methods
The result export parameter is used to return the global features.
The parameter contains the default operations and actions for which
a global feature control has been defined in the behavior definition.
In addition to the explicitly specified return parameters, the FOR
GLOBAL FEATURES method returns the implicit return parameters
FAILED, MAPPED, and REPORTED.
Listing 5.13 shows an exemplary implementation of this method.
CLASS lhc_handler DEFINITION INHERITING FROM cl_abap_behavior_handler.
PRIVATE SECTION. 
  METHODS get_global_features FOR GLOBAL FEATURES
      IMPORTING REQUEST requested_features 
         FOR entity RESULT result.
ENDCLASS.
 
CLASS lhc_handler IMPLEMENTATION.
  METHOD get_global_features.
  result = VALUE #(
    " Feature control for action
    %features-%action-action_name = COND #( 
       WHEN condition
       THEN if_abap_behv=>fc-o-disabled
       ELSE if_abap_behv=>fc-o-enabled   )
    %features-%update             = COND #( 
       WHEN condition
       THEN if_abap_behv=>fc-o-disabled
       ELSE if_abap_behv=>fc-o-enabled   )
    " Feature control for a create-by-association operation
    %assoc-_Assoc                 = COND #( 
       WHEN condition
       THEN if_abap_behv=>fc-o-disabled
       ELSE if_abap_behv=>fc-o-enabled   )
              ) ).
  ENDMETHOD.
ENDCLASS. 
Listing 5.13     Sample Implementation of the FOR GLOBAL FEATURES Method
5.4.6    FOR LOCK

The FOR LOCK addition can be used to implement a method for locking
entities based on the lock properties from the behavior definition.
The FOR LOCK method is automatically called by the RAP framework
before a change operation (FOR MODIFY), such as an update, is called.
In the behavior definition, you can specify which entities support
direct locking by defining them as lock masters. In addition, you can
define lock-dependent entities. This status can be assigned to
entities that depend on the lock status of a parent or root entity. The
lock dependency specification contains an association that’s used to
automatically determine the lock master at runtime. Subsequently, its
FOR LOCK method can be executed as soon as change requests occur
for the dependent entities.
Listing 5.14 shows the syntax of a locking method definition.
METHODS meth [FINAL] 
   FOR LOCK 
   [IMPORTING] { REFERENCE(im_par_lock) | im_par_lock } 
   FOR LOCK bdef 
   [CHANGING { [failed TYPE data] [reported TYPE data] }]. 
Listing 5.14     Syntax for the FOR LOCK Method
[»]  Differences Between the Managed and Unmanaged
Scenarios
The FOR LOCK addition is only available in the managed scenario if
the lock master has been declared as unmanaged in the behavior
definition. Otherwise, the RAP framework will take care of the lock
management.
The import parameter im_par_lock contains all elements specified as
keys in the CDS view associated with the entity. The compiler-
generated structures %CID, %CID_REF, and %PID aren’t relevant in the

context of locks since locks affect only persistent (non-transient)
instances.
The FOR LOCK method provides the implicit return parameters FAILED
and REPORTED:
The FAILED parameter is used to log the failure of a lock and its
causes.
The REPORTED parameter is used to store messages about the
cause of the error.
The RAP lock mechanism requires the instantiation of a lock object.
A lock object is an ABAP dictionary object you can use to queue
(enqueue) and dequeue (dequeue) lock requests. Listing 5.15 shows a
simple sample implementation of the FOR LOCK method.
CLASS lhc_travel IMPLEMENTATION.
  ...
   METHOD lock.
    TRY.
        "Create lock object
        DATA(lock) = 
             cl_abap_lock_object_factory=>get_instance( 
             iv_name = '/DMO/ETRAVEL' ).
      CATCH cx_abap_lock_failure INTO DATA(exception).
        RAISE SHORTDUMP exception.
    ENDTRY.
 
    LOOP AT keys ASSIGNING FIELD-SYMBOL(<travel>).
      TRY.
          "Lock travel instance
          lock->enqueue(
              it_parameter  = VALUE #( ( 
       name = 'TRAVEL_ID' value = REF #( <travel>-travelid ) ) )
          ).
* Intercept, if another application has already 
* set the lock
        CATCH cx_abap_foreign_lock INTO DATA(foreign_lock).
          map_messages(
           EXPORTING
                travel_id = <travel>-TravelID
                messages  =  VALUE #( (
                            msgid = '/DMO/CM_FLIGHT_LEGAC'
                            msgty = 'E'
                            msgno = '032'

                            msgv1 = <travel>-travelid
                            msgv2 = foreign_lock->user_name )
                          )
              CHANGING
                failed    = failed-travel
                reported  = reported-travel
            ).
        CATCH cx_abap_lock_failure INTO exception.
          RAISE SHORTDUMP exception.
      ENDTRY.
    ENDLOOP.
  ENDMETHOD.
  ...
ENDCLASS. 
Listing 5.15     Sample implementation of the For Lock Method
5.4.7    FOR READ
The method with the addition FOR READ is used to return the data from
the transaction buffer. When the buffer is empty, the data is read
from the database (which normally populates the transaction buffer).
There are two ways to read data from the transaction buffer:
Directly using a FOR READ method
Indirectly via a method with the addition FOR READ by association
(Section 5.4.8)
Listing 5.16 shows the syntax of the first variant.
METHODS method_name FOR READ
        [IMPORTING] read_import_parameter FOR READ entity
        RESULT read_result_parameter. 
Listing 5.16     Syntax of the FOR READ Method
For better readability, the IMPORTING keyword can optionally be
specified before the import parameter. You can choose the name of
the import parameter as you like, read_import_parameter is just a

placeholder here. The parameter imports the key fields of the entity
to be read and specifies which elements are requested.
The entity placeholder refers to the name of the entity (e.g., a CDS
view) to be read from, or to its alias defined in the behavior definition.
The import parameter read_import_parameter contains all elements
that are specified as keys in the corresponding CDS view. The
%CONTROL structure specifies which elements are requested by the
consumer.
The export parameter read_result_parameter returns the
successfully read data in a table. This table contains rows for all
elements specified in the element list of the entity to be read.
However, only the requested elements specified in the %CONTROL
structure can be returned.
In addition to the explicitly specified return parameter, the FOR READ
method also returns the implicit return parameters FAILED, MAPPED,
and REPORTED.
For a sample implementation of the FOR READ method see Listing
11.13 in Chapter 11, Section 11.5.1.
5.4.8    FOR READ BY ASSOCIATION
The FOR READ by association method is used to return the data from
the transaction buffer using an association. Listing 5.17 shows the
syntax of this variant of the FOR READ method.
METHODS
      method_name   FOR READ
        [IMPORTING] read_ba_import_parameter 
            FOR READ entity\_association 
        FULL full_read_import_parameter
        RESULT read_result_parameter
        LINK read_link_parameter. 

Listing 5.17     Syntax of the FOR READ by Association Method
The ID of all elements specified as keys in the underlying CDS view
is passed as the import parameter. The %CONTROL structure specifies
which elements are requested by the consumer. The import
parameter full_read_import_parameter is of type Boolean. This
parameter is used to specify whether the result parameter must be
passed or whether it’s sufficient to fill only the link parameter.
Besides the import parameters, there are the following export
parameters:
read_ba_import_parameter
Returns the successfully read data from the associated CDS entity
as a table if the import parameter FULL has been set. The row type
of this table contains all elements specified in the element list of
the entity to be read. However, only the requested elements
specified in the %CONTROL structure will be read.
read_link_parameter
Returns the source and destination keys of the successfully read
entity instances.
In addition to the explicitly specified return parameter, the FOR READ
method also returns the implicit return parameters FAILED, MAPPED,
and REPORTED.
Listing 5.18 shows an exemplary implementation of the FOR READ
method by association.
CLASS lhc_travel DEFINITION INHERITING FROM cl_abap_behavior_handler.
  PRIVATE SECTION.
...
      read_booking_ba   FOR READ
        IMPORTING it_travel  FOR READ travel\_Booking
                    FULL iv_full_requested
        RESULT    et_booking
                    LINK et_link_table,
...

ENDCLASS.
 
CLASS lhc_travel IMPLEMENTATION.
  METHOD read_booking_ba.
    DATA: ls_travel_out  TYPE /dmo/travel,
          lt_booking_out TYPE /dmo/t_booking,
          ls_booking     LIKE LINE OF et_booking,
          lt_message     TYPE /dmo/t_message.
    LOOP AT it_travel ASSIGNING FIELD-SYMBOL(<fs_travel_rba>) 
       GROUP BY <fs_travel_rba>-TravelID.
      CALL FUNCTION '/DMO/FLIGHT_TRAVEL_READ'
        EXPORTING
          iv_travel_id = <fs_travel_rba>-travelid
        IMPORTING
          es_travel    = ls_travel_out
          et_booking   = lt_booking_out
          et_messages  = lt_message.
      IF lt_message IS INITIAL.
        LOOP AT lt_booking_out 
          ASSIGNING FIELD-SYMBOL(<fs_booking>).
* Populate link parameters with the key fields.
 
          INSERT
            VALUE #(
              source-%key = <fs_travel_rba>-%key
              target-%key = VALUE #(
                TravelID  = <fs_booking>-travel_id
                BookingID = <fs_booking>-booking_id
              )
            )
            INTO TABLE et_link_table.
* Set return parameter
          IF iv_full_requested = abap_true.
            ls_booking = CORRESPONDING #( 
             <fs_booking> MAPPING TO ENTITY ).
            INSERT ls_booking INTO TABLE et_booking.
          ENDIF.
        ENDLOOP.
      ELSE.
        "Populate FAILED parameter in case of error
        failed-travel = VALUE #(
          BASE failed-travel
          FOR msg IN lt_message (
            %key = <fs_travel_rba>-TravelID
            %fail-cause = COND #(
              WHEN msg-msgty = 'E' AND ( 
                   msg-msgno = '016' OR msg-msgno = '009' )
              THEN if_abap_behv=>cause-not_found
              ELSE if_abap_behv=>cause-unspecific
            )
          )
        ).
 
      ENDIF.

    ENDLOOP.
  ENDMETHOD.
...
ENDCLASS. 
Listing 5.18     Sample Implementation for a FOR READ Method by Association
5.4.9    FOR DETERMINE
The determination method FOR DETERMINE provides the last option to
make adjustments, calculations, or similar actions before saving the
data in the database. With this type of method, for example, you can
implement a header-level status adjustment based on the statuses of
the items.
The signature of a determination method is typed with the keyword
FOR DETERMINE, followed by the selected event (on modify or on save)
and the import parameter. The type of the import parameter is an
internal table that contains the keys of the instances for which the
determination is to be performed. The signature contains the
affected entity followed by the method name of the determination
specified in the behavior definition.
It’s possible to implement multiple determinations for multiple entities
together in one method if these determinations use the same trigger
time. Once a determination has been defined in the behavior
definition, it can be implemented.
Listing 5.19 shows the syntax for defining a FOR DETERMINE method.
METHODS method_name1 FOR DETERMINE ON MODIFY 
  IMPORTING keys FOR AliasedEntityName~DetOnModify.
 
METHODS method_name2 FOR DETERMINE ON SAVE
   IMPORTING keys FOR AliasedEntityName~DetOnSave
                  keys2 FOR AliasedEntityName2~DetOnSave2. 
Listing 5.19     Syntax of the FOR DETERMINE Method

The import parameter of the keys table type includes all elements
specified as keys for the associated entity.
The method also returns the implicit return parameters FAILED,
MAPPED and REPORTED.
See Chapter 9, Section 9.6 for a sample implementation of the
determination method.
5.4.10    FOR VALIDATE
Validations allow you to check the consistency of business object
instances based on a trigger condition. This can prevent incorrect or
inconsistent data from being stored in the database. The interface of
the method with the addition FOR VALIDATE provides the possibility to
send messages to the consumer so that the data can be adjusted to
meet the test conditions. Once a validation has been defined in the
behavior definition, it can be implemented.
Listing 5.20 shows the syntax of this method definition.
METHODS method_name1 FOR VALIDATE ON SAVE 
  IMPORTING keys FOR AliasedEntityName~MyValidation.
 
METHODS method_name2 FOR VALIDATE ONE SAVE
  IMPORTING keys FOR AliasedEntityName~AnotherValidation
    keys2 FOR AliasedEntityName2~AnotherValidation2. 
Listing 5.20     Syntax of the FOR VALIDATE Method
The import parameter of the keys table type includes all elements
specified as keys for the associated entity.
The method also returns the implicit return parameters FAILED,
MAPPED, and REPORTED.

See Chapter 9, Section 9.7 for a sample implementation of the
validation method.
5.4.11    FOR NUMBERING
The method with the addition FOR NUMBERING implements early
numbering for business objects (early unmanaged numbering) in the
managed scenario, which isn’t controlled by the RAP framework.
Note that early numbering can’t be used in combination with the
numbering:managed addition from the behavior definition. So, you
have to decide in the behavior definition whether you want to assign
the numbers yourself or leave this task to the RAP framework.
Below you can see the syntax for defining a FOR NUMBERING method:
METHODS earlyNumbering_Create method FOR NUMBERING 
  [IMPORTING] entities FOR CREATE business_object_entity. 
The import parameter of the table type entities includes all
elements defined in the associated entity. The method also returns
the implicit return parameters FAILED, MAPPED, and REPORTED. Each
instance passed via the entities parameter must be contained in
either the FAILED or MAPPED structure, otherwise a short dump will
occur.
Listing 5.21 shows a sample implementation of the FOR NUMBERING
method.
METHOD earlynumbering_create.
...
* Determine ID
    TRY.
        cl_numberrange_runtime=>number_get(
          EXPORTING
            nr_range_nr       = '01'
            object            = '/DMO/TRV_M'
            quantity          = 
             CONV #( lines( entities_wo_travelid ) )
          IMPORTING

            number            = DATA(number_range_key)
            returncode        = 
              DATA(number_range_return_code)
            returned_quantity = 
              DATA(number_range_returned_quantity)
        ).
...
    CASE number_range_return_code.
      WHEN '1'.
* The returned number is in a critical range
        LOOP AT entities_wo_travelid INTO entity.
          APPEND VALUE #( %cid = entity-%cid
                          %key = entity-%key
                          %msg = 
                    NEW /dmo/cm_flight_messages(
                          textid = 
                dmo/cm_flight_messages=>number_range_depleted
                          severity = 
                if_abap_behv_message=>severity-warning )
                        ) TO reported-travel.
        ENDLOOP.
...
    ENDCASE.
* From here on every entry gets an ID
    ASSERT number_range_returned_quantity = lines( 
             entities_wo_travelid ).
    travel_id_max = number_range_key - 
             number_range_returned_quantity.
* Set Travel ID
    LOOP AT entities_wo_travelid INTO entity.
      travel_id_max += 1.
      entity-travel_id = travel_id_max.
 
      APPEND VALUE #( %cid  = entity-%cid
                      %key  = entity-%key
                    ) TO mapped-travel.
    ENDLOOP.
  ENDMETHOD. 
Listing 5.21     Sample Implementation of the FOR NUMBERING Method
5.4.12    FOR PRECHECK
You can use the method with the FOR PRECHECK addition to reject
incoming requests before the data reaches the transaction buffer.
You can use this feature to prevent invalid changes from entering the
transaction buffer by checking the change operations in advance

(i.e., performing a precheck). However, you can only check the data
for consistency and accuracy as part of this method. Authorization
checks, on the other hand, are performed in the implementations of
the methods with the FOR INSTANCE AUTHORIZATION and FOR GLOBAL
AUTHORIZATION additions.
Listing 5.22 shows the syntax for defining a FOR PRECHECK method.
METHODS meth [FINAL] 
   FOR PRECHECK 
   [IMPORTING] { REFERENCE(keys) | keys } 
   FOR { CREATE bdef } 
     | { CREATE bdef\_assoc } 
     | { UPDATE bdef } 
     | { DELETE bdef } 
     | { ACTION bdef~action 
         [REQUEST { REFERENCE(req_act_pre) | req_act_pre } ] } 
   [CHANGING { [failed TYPE data] [reported TYPE data] }] . 
Listing 5.22     Syntax of the FOR PRECHECK Method
The import parameter keys contains all elements specified as keys in
the underlying CDS view. The action to be checked is specified with
reference to the action and the behavior implementation, analogous
to the syntax of the method implementation with the FOR MODIFY
addition (Section 5.4.1). The method also returns the implicit return
parameters FAILED and REPORTED.
Listing 5.23 shows an exemplary implementation of the FOR PRECHECK
method.
CLASS lhc_salesorder DEFINITION INHERITING FROM cl_abap_behavior_handler.
...
METHODS testCheck for PRECHECK
      IMPORTING keys FOR ACTION SalesOrder~test.
...
CLASS lhc_salesorder IMPLEMENTATION.
...
  METHOD testcheck.
       READ ENTITIES OF ... 
       IF ... 
...
  ENDMETHOD.
... 

Listing 5.23     Sample Implementation of the FOR PRECHECK Method

5.5    Save Handler
In Section 5.2.2, you’ve already learned about the main methods of
the save sequence, which we’ll describe in greater detail in this
section. The save handler processes the implementations of these
methods according to a fixed sequence of steps. All business objects
involved in the save process are taken into account. The following
list provides an overview of the call times of the individual methods:
1. First, the implementation of the FINALIZE method is called. In the
managed scenario, this is done by calling the implementation of
the interaction handler method with the FOR DETERMINE on save
addition. In the unmanaged scenario, you must implement the
FINALIZE method directly.
2. The second step involves calling the implementation of the
CHECK_BEFORE_SAVE method. In the managed scenario, this is the
implementation of the method with the FOR VALIDATION addition.
In the unmanaged scenario, you must implement the
CHECK_BEFORE_SAVE method directly. After this step, you’ve
reached the point of no return.
3. Then the implementation of the ADJUST_NUMBERS method is called,
if available. In the managed scenario, this method isn’t
implemented because numbering is controlled by the RAP
framework. In the unmanaged scenario, you can implement the
ADJUST_NUMBERS method for this purpose.
4. Next, the implementation of the SAVE method is called. In the
managed scenario, this is an implementation of the
SAVE_MODIFIED method. In the unmanaged scenario, you can
freely implement the SAVE method.

5. Finally, the save sequence is completed by calling the CLEANUP
method. The CLEANUP method is implemented for this purpose in
both the managed and unmanaged scenarios. In the event of an
error, the implementation of the CLEANUP_FINALIZE method is
called instead for both implementation types.
[»]  Point of No Return
After the points FINALIZE and CHECK_BEFORE_SAVE the point of no
return is reached in the save sequence. From this point on, the
framework assumes that all possible failure cases have been
checked and excluded. This also means that the data may no
longer be changed from this point on. All business object
instances involved in saving are now consistent, which means
there are no more application errors. Errors that occur after this
point can only be technical errors (e.g., if no more numbers are
free in the number range interval), which must lead to a dump.
In the following sections, we’ll go into more detail about the individual
methods of the save sequence.
5.5.1    FINALIZE
The FINALIZE implementation is called before the data can be
updated in the database. It’s the first step of the save sequence
where final calculations are performed based on the results of the
interaction phase for all involved business objects in the current
LUW. This event is the last opportunity to modify business object
instances in the transaction buffer via EML modify calls. EML modify
calls after this step will result in runtime errors.

Depending on whether managed or unmanaged business objects
are used, the implementation of this step of the save sequence will
differ (see Figure 5.4):
For managed business objects (i.e., in the managed scenario), the
final adjustments are mapped in the context of determinations
(Section 5.4.9).
For unmanaged business objects (i.e., in the unmanaged
scenario), the final adjustments are implemented in the FINALIZE
method of the save handler class.
Figure 5.4     Flow of the FINALIZE Step Within the Save Sequence
Listing 5.24 shows the syntax of the FINALIZE method definition
within the save handler class.
METHODS finalize
  CHANGING
    !failed TYPE data
    !reported TYPE data. 
Listing 5.24     Syntax of the FINALIZE Method of the Save Handler
The following return parameters are passed by the method:
The FAILED parameter is passed to log the entities where the
FINALIZE method failed. Values for this parameter will cause the
save sequence to abort.

The REPORTED parameter can be passed to return messages in
case of an error.
Listing 5.25 shows the structure of an implementation of the method
in the save handler class.
CLASS lcl_saver DEFINITION INHERITING FROM cl_abap_behavior_saver.
  PROTECTED SECTION.
    METHODS finalize REDEFINITION.
ENDCLASS.
 
CLASS lcl_save IMPLEMENTATION.
METHOD finalize. 
// ** implement finalize **//
ENDMETHOD. 
Listing 5.25     Implementation of the FINALIZE Method of the Save Handler
5.5.2    CHECK_BEFORE_SAVE
Consistency checks can be implemented as part of the
CHECK_BEFORE_SAVE method to ensure that data is saved successfully.
The implementation of this method is called during the save
sequence before the point of no return. Again, a distinction is made
between managed and unmanaged business objects (see
Figure 5.5):
For managed business objects, consistency checks are mapped
as part of validations (Section 5.4.10).
For unmanaged business objects, the consistency checks are
implemented in the CHECK_BEFORE_SAVE method of the save handler
class.

Figure 5.5     Flow of the CHECK_BEFORE_SAVE Step Within the Save Sequence
Listing 5.26 shows the syntax of the definition of the
CHECK_BEFORE_SAVE method.
METHODS check_before_save
  CHANGING
    !failed TYPE data
    !reported TYPE data. 
Listing 5.26     Syntax of the CHECK_BEFORE_SAVE Method of the Save Handler
The following return parameters can be passed by this method:
The FAILED parameter is passed to log the entities for which the
consistency check failed. Entries for this parameter will cause the
save sequence to abort.
The REPORTED parameter can be passed to return messages in
case of an error.
For a sample implementation of the CHECK_BEFORE_SAVE method, see
Chapter 11, Section 11.5.2, Listing 11.19.
5.5.3    ADJUST_NUMBERS
In the method ADJUST_NUMBERS, you can implement late numbering.
The implementation of this method is called during the save
sequence, but after the point of no return. This ensures that the

numbers are assigned without gaps. The implementation of the
ADJUST_NUMBERS method is only required if late numbering has been
modeled in the behavior definition (see Figure 5.6).
Listing 5.27 shows the syntax for defining the ADJUST_NUMBERS
method.
METHODS adjust_numbers
  CHANGING
    !mapped TYPE data
    !reported TYPE data OPTIONAL. 
Listing 5.27     Syntax of the ADJUST_NUMBERS Method
The following return parameters can be used in this method. The
contents of the derived data type %PRE are transferred to the derived
data type %KEY. The mapping in the ADJUST_NUMBERS method occurs
from %PRE to %KEY in the mapped response parameter, MAPPED. The
%PRE structure contains the ID for late numbering (%PID) and the
semantic key in the %TMP structure.
Listing 5.28 shows a mapping where both components from the %PID
structure are used for unique identification during the interaction
phase.
Messages can be returned via the implicit return parameter REPORTED.
Since the point of no return has already been passed at the time the
ADJUST_NUMBERS method is called, no more errors may occur.
Therefore, REPORTED should contain only success or information
messages. If the save process still needs to be aborted, the only
option is to trigger a short dump.

Figure 5.6     Flow of the ADJUST_NUMBERS Step Within the Save Sequence
Listing 5.28 shows an exemplary implementation of the
ADJUST_NUMBERS method.
  METHOD adjust_numbers.
...
* Fill %key-<key_field> with the assigned number.
    APPEND VALUE #( %pre-%pid               = 'MyPID'
                    %pre-%tmp-<key_field>   = 
                       'MyPreliminaryKey_InPlace'
                    %key-<key_field>        = 'MyFinalKey'
                  ) TO mapped-<entity>.
 
  ENDMETHOD. 
Listing 5.28     Sample Implementation of the ADJUST_NUMBERS Method of the Save
Handler
5.5.4    SAVE
In the context of the implementation of the save method, the saving
of data in the database is enabled. The implementation of the
corresponding method is called at the end of the save sequence to
update the current data in the database. Which method is
implemented for the save operation depends on the implementation
type used (see Figure 5.7):
For managed business objects, saving can be mapped in the
SAVE_MODIFIED method of the save handler class. If this method

isn’t implemented, the framework automatically updates the data
in the managed scenario.
For unmanaged business objects, saving data is implemented in
the SAVE method of the save handler class.
Figure 5.7     Flow of the Save Process in the Save Sequence
SAVE_MODIFIED Method
The SAVE_MODIFIED method from the CL_ABAP_BEHAVIOR_SAVER class
must be redefined to implement custom save logic. The method is
only used in the managed scenario with an unmanaged or additional
save operation.
Listing 5.29 shows the syntax for defining the SAVE_MODIFIED method.
  METHODS save_modified
    IMPORTING
      !create TYPE data
      !update TYPE data
      !delete TYPE data
    CHANGING
      !reported TYPE data OPTIONAL. 
Listing 5.29     Syntax of the SAVE_MODIFIED Method of the Save Handler

The following import parameters can be passed to this method:
CREATE
This parameter contains information about instances that have
been created during the LUW. In the %CONTROL structure, the fields
that were changed are marked.
UPDATE
This parameter contains information about instances that have
been changed during the LUW. In the %CONTROL structure, the fields
that were changed are marked.
DELETE
This parameter contains information about instances that have
been deleted during LUW.
Messages can be returned via the implicit return parameter REPORTED.
Since the point of no return has already been passed at the time the
save method is called, no more errors may occur. Therefore,
REPORTED should contain only success or information messages. If
the save process still needs to be aborted, the only option is to
trigger a short dump.
Chapter 10, Section 10.5.1 contains a sample implementation of the
SAVE_MODIFIED method in Listing 10.43.
SAVE Method
The SAVE method from the CL_ABAP_BEHAVIOR_SAVER class must be
redefined to implement saving in the unmanaged scenario. The
method is defined as follows:
METHODS save
  CHANGING
    !reported TYPE data OPTIONAL. 

Messages can be returned via the implicit return parameter,
REPORTED. Since the point of no return has already been passed when
the SAVE method is called, no more errors may occur. Therefore,
REPORTED should contain only success or information messages. If
the save process still needs to be aborted, the only option is to
trigger a short dump.
For an example of the SAVE method redefinition, see Chapter 11,
Section 11.5.2, Listing 11.20.
5.5.5    CLEANUP
The CLEANUP method is used to implement the clearing of the
transaction buffer. This will undo all changes in the buffer and a new
LUW can be started. The implementation of this method is called
after the save sequence has been traversed. It can also be called
after a ROLLBACK ENTITIES statement for any type of instance access
during the interaction phase. The cleanup action empties the
transactional buffer of all remaining instance data to terminate the
LUW. It’s called whenever instance data is written to the transaction
buffer. That is, it’s called for all affected business objects, regardless
of whether they failed or succeeded.
There are also differences in this cleanup process between the
managed and unmanaged scenarios (see Figure 5.8):
For managed business objects, the call of the CLEANUP method is
performed by the managed business object provider. If the
application is implemented as a managed business object with
additional save or as a managed business object with unmanaged
save, you can also implement the CLEANUP method yourself. To do
this, you must specify the addition with additional or unmanaged
save and cleanup in the behavior definition.

For unmanaged business objects, you must always implement the
CLEANUP method yourself.
Figure 5.8     Flow of the Cleanup Operation in The Save Sequence
The syntax for defining the method is simple:
METHODS cleanup. 
At the end of Chapter 11, Section 11.5.2, you’ll find an example of
the implementation of the CLEANUP method.
5.5.6    CLEANUP_FINALIZE
By using the CLEANUP_FINALIZE method you can clear the transaction
buffer if the FINALIZE or CHECK_BEFORE_SAVE method failed. For this
purpose, the CLEANUP_FINALIZE method can be redefined in the saver
class of a RAP behavior implementation (see Figure 5.9).

Figure 5.9     Flow of the Call of the CLEANUP_FINALIZE Method
The method is defined as follows:
METHODS cleanup_finalize. 
The implementation is similar to that of the CLEANUP method.

6    Business Services
This chapter provides an introduction to the topic of business
services. We’ll also describe how the individual levels are
interrelated, from the database to the business service.
In the context of the ABAP RESTful application programming model,
a business service is a RESTful or OData service that can be used
by a consumer. It’s defined by the announcement of its data model
and associated behavior. A business service consists of two parts, a
service definition and a service binding:
Numerous task-based and role-based SAP Fiori apps are based
on the same data basis. This basis is implemented in reusable
data models and behavior models. The service definition is a
projection of the data model and associated behavior.
The service binding, on the other hand, defines a specific
communication protocol such as OData V2 or OData V4 and the
type of service (e.g., a UI service or an API).
By separating the service definition from the service binding, the
data models and service definition can be integrated into different
communication protocols without the need for re-implementation.
Figure 6.1 shows the different layers of the ABAP RESTful
application programming model from the database to the business
service with their respective object types. In this chapter, we turn our
attention to the projection and business services layer. First, in

Section 6.1, we’ll introduce the CDS projection view and the
projection behavior definition as objects of the projection layer. In
Section 6.2, we’ll address the service definition, and Section 6.3
focuses on service binding.
The remaining sections are dedicated to testing and operating
business services. In Section 6.4, you’ll learn how to test the
business service using the SAP Gateway client. Section 6.5 will then
describe a simple but effective way to test the functionality of a
business service using the SAP Fiori elements preview.
Figure 6.1     Layers of the ABAP RESTful Application Programming Model from the
Database to the Business Service
6.1    Projection Layer
Projecting a business object is an ABAP RESTful application
programming model approach to provide a subset of the business
object fields for a specific use case--i.e., a specific business service.
Meaningful aliases should be assigned for the entities that fit this
specific use case. The projection enables flexible service usage and
role-based service designs since it allows the business object and its
behavior to be built detached from the service. The underlying

business object contains the maximum number of functions that can
be used by a service based on it. The projection layer contains
service-specific information that doesn’t belong to the general data
model layer (e.g., UI annotations, input helps, calculations or default
settings).
Using a projection layer for your business object gives you flexibility
with using the business service. The business object can be further
developed without affecting an already existing service. This allows
for a robust application development. The projection layer also
makes it possible to use a business object in an OData service for a
SAP Fiori interface and a web API. The service-specific differences
can be implemented in the respective projections. For example, UI
specifications are defined only in the business object projection
that’s exposed for the UI service.
Furthermore, it’s possible to use different projections to implement
role-based user interfaces. The projection layer for a business object
consists of two parts: the CDS projection view and the projection
behavior definition. For the latter, there can be a separate behavior
implementation.
6.1.1    CDS Projection View
In Chapter 2, Section 2.9, we introduced the CDS projection view.
This is a special CDS view type for the projection layer. A CDS
projection view provides a subset of the CDS entities of a data model
for the projection layer. These CDS entities can be renamed via
aliases to match the business service context of the particular
projection. New data elements from other CDS views or database
tables can no longer be added with this view type. That is, the
underlying data model forms the maximum expression of the

possible elements in the CDS projection view. However, it’s possible
to add virtual elements (see Chapter 2, Section 2.7.1) as columns to
a CDS projection view. New associations can be added in read-only
mode, for example, to display new information as diagrams in the
user interface. If your business service is a UI service and you want
to influence the interface in the context of CDS via UI annotations,
these UI annotations must be defined in the context of the CDS
projection view or in the associated metadata extension.
Listing 6.1 shows an example of a CDS projection view. For
example, the @Consumption.valueHelpDefinition annotation, is used
to provide search help for use in the application interface. In this
example, the field for the customer name (CustomerName) is included
in the maximum number of possible elements via the association,
_Customer. In Chapter 9, Section 9.2.2, in the CDS projection view
section, you’ll find another example of a CDS projection view that
uses a virtual element.
...
define root view entity /DMO/C_Travel_U
  as projection on /DMO/I_Travel_U
 
{     ///DMO/I_Travel_U
 
  key TravelID,
 
      @Consumption.valueHelpDefinition: [{ 
            entity: {    name:    '/DMO/I_Agency', 
                         element: 'AgencyID' } }]
      @ObjectModel.text.element: ['AgencyName']
      @Search.defaultSearchElement: true
      AgencyID,
      _Agency.Name       as AgencyName,
 
      @Consumption.valueHelpDefinition: [{ 
      entity: {    name:    '/DMO/I_Customer', 
                   element: 'CustomerID'  } }]
      @ObjectModel.text.element: ['CustomerName']
      @Search.defaultSearchElement: true
      CustomerID,
      _Customer.LastName as CustomerName,
... 

Listing 6.1     Example of a CDS Projection View Named /DMO/C_Travel_U
Only the orchestration framework resolves a virtual element and
executes the associated method. This is also the reason why virtual
elements aren’t executed in the SAP GUI, because the orchestration
framework isn’t run through there. Information Access (InA) services
can’t resolve virtual items either, so they can’t be evaluated by a live
data connection in SAP Analytics Cloud, for example.
6.1.2    Projection Behavior Definition
As briefly addressed in Chapter 3, Section 3.1.1, there is a special
implementation type for behavior definitions: the projection behavior
definition. Basically, a projection behavior definition enables you to
define service-specific behavior for a business object projection.
With this type of definition, only behavior characteristics and
operations defined in the underlying behavior definition can be
projected.
The use of the respective behavior characteristic or the desired
operations is introduced with the keyword use. This keyword can
publish the following features or operations for the service-specific
behavior of a business object projection:
Entity tag (ETag)
Standard operations
Actions
Functions
create-by-association
Each operation you want to make available to your service must be
listed in the projection behavior definition.

Projection behavior definitions don’t have behavior implementations
(these will be available for projection behavior definitions as of SAP
S/4HANA Cloud 2195, according to the current SAP roadmap). The
complete behavior is defined by the underlying behavior definition for
which there may be a behavior implementation. If constraints, such
as locks, permissions, or feature controls, have already been defined
via a feature control in the underlying behavior definition, those
constraints can’t be overridden in projection behavior definitions.
Listing 6.2 shows part of a projection behavior definition based on
the CDS projection view /DMO/C_Travel_U from Listing 6.1. In this
case, the CRUD functionalities are activated using the use keyword.
In addition, the set_status_booked action is also published via the
use keyword. In the last step, the _BOOKING association is still
provided as part of the business service.
projection;
define behavior for /DMO/C_Travel_U alias travel
use etag
{
  use create;
  use update;
  use delete;
  use action set_status_booked;
  use association _BOOKING { create; }
}
... 
Listing 6.2     Example of a Projection Behavior Definition for the CDS Projection View
/DMO/C_Travel_U

6.2    Service Definition
A service definition describes which CDS entities of a data model
should be exposed to enable a particular business service. You can
use a service definition to specify which data is to be made available
as a business service via one or more service bindings. The service
definition is independent of protocol version or type used for the
business service. So basically, a service definition is a consumer-
specific but protocol-independent view of a data model. However, it
can only be used in conjunction with a service binding.
In Listing 6.3 you can see the service definition ZUI_Travel_U, which
compiles all CDS entities necessary for the "manage travels" use
case.
@EndUserText.label: 'Service Definition for manage Travels'
define service ZUI_Travel_U {
  expose /DMO/C_Travel_U as Travel;
  expose /DMO/C_Booking_U as Booking;
} 
Listing 6.3     Service Definition ZUI_Travel_U
The entities include the CDS projection view /DMO/C_Travel_U, which
is aliased Travel, and the CDS projection view /DMO/C_Booking_U,
which is aliased Booking. The latter is a projection of the dependent
child entity. This service definition in itself doesn’t yet provide a
technically consumable service. That only happens with the service
binding based on it.

6.3    Service Binding
The service binding is an ABAP repository object used to bind a
service definition to a client-server communication protocol such as
OData. A service binding is always based on a service definition,
which in turn is derived from the underlying CDS-based data model.
A variety of service bindings can be created based on a single
service definition.
The separation between service definition and service binding
makes it possible to integrate a large number of service protocols for
a service definition without the need for a new implementation.
Services implemented in this way are based on the principle of
separating the service protocol from the business logic. With a few
clicks, for example, an OData service of version V4 can be exposed
to an OData service of version V2.
The binding type defines the specific service type and thus the
protocol used. At the time of printing of this book, the following
protocols are supported for CDS data models:
As of SAP S/4HANA 2020 FPS0:
OData 2.0 (V2): This version is used for user interfaces,
especially SAP Fiori elements.
OData 2.0 (V2): This version is used for web APIs.
As of SAP S/4HANA 2021 FPS0, the following protocols are also
supported:
OData 4.0 (V4) for web APIs
OData 4.0 (V4) for user interfaces

Information Access (InA) for user interfaces. This protocol is
used specifically in analytics. For example, SAP Analytics
Cloud uses InA to query live data.
SQL for web APIs. This protocol allows you to access published
database API objects managed from your ABAP code using
ABAP SQL, which means you access the API using ABAP
rather than OData commands. Currently, only read-only access
to SQL is allowed.
The binding type parameter, which you specify when creating a
service binding in the wizard, determines the way a service is
provided to a consumer. There are two options here:
UI
A UI service allows you to add an SAP Fiori elements UI or other
UI clients to the service. In a UI service, unlike a web API, search
helps and UI annotations are included. Currently, UI services for
OData and InA services are supported.
Web API
A service deployed as a web API is used for all use cases other
than user interfaces. Web APIs can be consumed by an unknown
consumer via OData. They can also be extended. Currently, web
APIs for OData and SQL services are supported.
The versioning of service bindings occurs via a version number
assigned to a service binding. Adding another service definition to
the existing service binding creates a new version. Functional
changes or enhancements (compared to the previous version)
become visible through this additional service definition.
Basically, each version of the service can be viewed and used like a
separate service. This means you can keep an old version of a
service stable and simultaneously create a new version and publish

it. Figure 6.2 shows an example of a service binding with two
versions.
You can create this type of service binding in ABAP development
tools (ADT) by opening the context menu for a service definition and
selecting Define Service Binding. In Chapter 9, Section 9.4.2, we’ll
describe the creation in detail based on an example.
Figure 6.2     Service Binding with Two Versions
The local service endpoint of an OData service must be published in
the service binding editor via the Publish button (see Figure 6.3). An
OData service, or in our case a business service, is the actual
implementation of the OData protocol and provides the consumable
local service endpoint (also referred to as root URL). This publication
of the service binding activates the business service only locally for
the current system. It can’t be consumed by other systems.
Basically, this is a pure test function that enables you to test the
service easily and quickly in the development system. Local
publishing is possible only in this system.
Figure 6.3     Publishing a Service Binding Locally

To transport the service and use it in the quality assurance or
production system, you must first unpublish the local publication
using the Unpublish button. Then, you register the service using the
SAP Gateway tools (for example, Transaction
/IWFND/MAINT_SERVICE) and assign it to a transport.
In Figure 6.4, you can see the service binding ZUI_TRAVEL_ODATA_O2,
which is built on top of the service definition ZUI_Travel_U. The
business service provides the CDS entities listed as part of the
service binding as a remote API. In our example, this remote API
serves as a business object provider for an SAP Fiori elements
interface for managing trips.
Figure 6.4     Service Binding ZUI_TRAVEL_ODATA_O2
In the Service Version Details section, Entity Set and Association
provides insight into the entity sets (EntitySet) and associations
provided by the business service based on the service definition. For
example, the entity set Travel can be seen there.
Figure 6.5 again shows the layer model from Figure 6.1 and uses the
CDS projection view /DMO/C_Travel_U to show which development
objects are created in the different layers of the ABAP RESTful
application programming model.

The overview ranges from database tables to the service binding
ZUI_TRAVEL_ODATA_O2 with binding type OData V2. In addition to the
ZUI_TRAVEL_ODATA_O2 service binding, there could be another service
binding with the OData V4 binding type to provide a web API.
Figure 6.5     Example of the Development Objects in the Layers of the ABAP RESTful
Application Programming Model

6.4    Testing Business Services in the SAP
Gateway Client
The service URL is used by the current ABAP system to access the
business service. This URL specifies the virtual directory of the
service and uses the following syntax (here for OData V2):
/sap/opu/odata/<service_binding_name>
One use case where you need the service URL involves the testing
of the business service via the SAP Gateway client. To access the
SAP Gateway client, you must run Transaction
/IWFND/MAINT_SERVICE. Alternatively, you can use Transaction
/IWFND/GW_CLIENT.
Here you can now call up your service (see Figure 6.6):
1. Click on the Filter 
 button and select the desired business
service. You can find the business service by the name you
assigned in the service binding.
2. The name of the service must now be entered in the Technical
Service Name 
 field.
3. You can then start the service via the SAP Gateway Client 
button.
1
2
3

Figure 6.6     Finding and Starting a Service in the SAP Gateway Client
You can see whether the service has been started successfully, for
example, when the service metadata gets read, as shown below.
Only if the service was found successfully will the metadata readout
work.
To be able to read the metadata, you need to add the URI option
$metadata to the service URL. In Figure 6.7 you can see the service
URL for your service. If you use the access to the SAP Gateway
client via Transaction /IWFND/GW_CLIENT, you only need to copy
the service URL from the service binding.
Figure 6.7     Service URL in the SAP Gateway Client
Evaluating service metadata is an easy way to get an overview of an
OData service. This metadata is provided to the consumer to help
you identify the structure and organization of the entities, navigation,

and service operations. Simply put, service metadata is an interface
description for OData services.
To retrieve this information, you can add the URI option $metadata to
the service URL. The SAP Gateway client supports this (see
Figure 6.8):
1. Click the Add URI Option button 
.
2. A popup window will open where you select the URI option
$metadata 
.
3. Click on the Execute 
 button. Now the metadata will be
loaded.
Figure 6.8     Displaying Metadata of an OData Service in the SAP Gateway Client
In the metadata you can find entities, navigation elements, and
operations of the business service. Figure 6.9 shows the metadata of
the business service exposed via service binding
ZUI_TRAVEL_ODATA_O2. Here, a function import (FunctionImport) is
marked, which represents the action setStatusBooked defined
specifically for the associated business object. Basically, you’ll find a
function import in the OData service for all actions you define
1
2
3

yourself. For the standard operations (create, update and delete),
you’ll also find annotations in the metadata (e.g., sap-creatable).
Figure 6.9     Metadata of an OData Service in the SAP Gateway Client
The SAP Gateway client has some advantages compared to other
testing options, such as the automatic handling of ETags. When
consuming a service on the same system where the SAP Gateway
client is installed, there’s no need to worry about authentication. It
also interprets the metadata and can, for example, provide input help
for the possible entity sets. On the other hand, the testing option via
the SAP Fiori elements preview that is described in the following
section can only be used for UI services.

6.5    Testing UI Services with SAP Fiori
Elements Preview
You can preview the entity sets exposed by a UI service in the
browser. The preview shows what an SAP Fiori elements application
would look like based on the tested UI service. To start the preview,
click the Preview button. In Figure 6.10 and Figure 6.11, you can
see a list report and the associated object page for the Travel entity
set. Custom programming isn’t necessary for the output of these
user interfaces.
Figure 6.10     Preview of a List Report for Service Binding ZUI_TRAVEL_ODATA_O2
Figure 6.11     Preview of an Object Page for Service Binding ZUI_TRAVEL_ODATA_O2
The UI preview is intended for development purposes and is based
solely on the stored annotations and the OData data model of the

service. Since you don't have to program anything, the SAP Fiori
elements preview feature is a very elegant and easy way to test UI
services.
The following chapter provides an overview of the possibilities of
user interface development using SAP Fiori elements, building on
the business services.

7    User Interfaces and SAP Fiori
Elements
This chapter provides a rough overview of the various ways to
create SAP Fiori apps based on the ABAP RESTful application
programming model.
Now we'll take a quick look at the user interfaces of your
applications. Our main goal here is to introduce the functionality and
tools we’ll need in the end-to-end development examples in Part II.
So, we’ll only describe the basics. For more information on SAP
Fiori, see the SAP community at
https://community.sap.com/topics/fiori.
Section 7.1 describes two development tools for SAPUI5 and SAP
Fiori development. Then, in Section 7.2, you’ll learn how these
technologies interact for web development in the ABAP RESTful
application programming model. We’ll pay special attention to the
SAP Fiori elements framework.
[»]  SAPUI5, SAP Fiori, and SAP Fiori Elements—What’s the
Difference?
SAPUI5 is a UI framework by SAP and is based on HTML5. SAP
Fiori is technically based on SAPUI5. However, SAP Fiori provides
a tighter framework for application design: the SAP Fiori design
guidelines. For example, all SAP Fiori apps follow a uniform

structure so that users can optimally find their way around new
applications.
SAP Fiori elements provides templates based on SAP Fiori to
accelerate the development of new apps for typical use cases.
These templates are referred to as floorplans. For example, such
a template exists for classic list report or object page applications
that display lists and individual business objects, respectively.
7.1    Development Tools
The following sections describe the two most common development
tools for SAPUI5 or SAP Fiori development. Specifically, these are
SAP Business Application Studio and Visual Studio Code.
7.1.1    SAP Business Application Studio
SAP Business Application Studio is a cloud service provided by SAP
on the SAP Business Technology Platform (SAP BTP). It’s a modern
development environment tailored for SAP application scenarios.
The tool is focused on efficient business application development for
smart enterprises (specifically, SAP Fiori apps, extensions for SAP
S/4HANA, workflows, and mobile apps).
The basis of the tool is the open source development environment
Eclipse Theia, which is based on the popular development
environment Visual Studio Code. SAP Business Application Studio
therefore provides comparable options and a developer experience
that’s similar to other modern integrated development environments
(IDEs) (e.g., when dealing with the command line, the optimized
editors, plug-ins, etc.).

A central concept of SAP Business Application Studio involves dev
spaces. A dev space is a virtual area within SAP Business
Application Studio with preinstalled plug-ins, for example, for SAP
Fiori and SAPUI5 development, SAP S/4HANA extension
development, or workflow development. In other words, a dev space
is a virtual, isolated development environment within SAP Business
Application Studio. The plug-ins needed for the task at hand are
preinstalled in the dev spaces, which simplifies and accelerates the
setup of the development environment and thus enables a more
efficient development. You can also test your application directly in a
dev space without transferring it to the target runtime environment
within the SAP BTP, Cloud Foundry environment. So, you can work
with the cloud development environment almost as you would on
your own computer.
The SAP Business Application Studio tools cover the entire
development cycle:
You can clone an existing project using a Git client or create a new
project based on templates.
You use editors for SAP-specific technologies.
You can easily test your application in your dev space, even if you
use services from remote sources.
In addition to creating the application, deployment is also carried
out via SAP Business Application Studio.
[»]  Supported Browsers
SAP Business Application Studio supports the latest version of the
following web browsers:
Mozilla Firefox

Google Chrome
If you want to use SAP Business Application Studio, you must start
the corresponding cloud service via the SAP BTP cockpit (i.e., your
SAP BTP administration environment). If you don’t have access to
SAP Business Application Studio yet, you can create a trial account
for SAP BTP via https://account.hanatrial.ondemand.com/ and use
the service in this trial version. You can find more information on how
to start the service in this environment in the SAP Developer Center
at http://s-prs.de/v868508. There, you’ll find numerous tutorials that
can help you get started with application development on SAP BTP
(see Figure 7.1).
Figure 7.1     Tutorials to Get Started with Application Development on the SAP BTP
The following sections focus on the SAP Business Application Studio
functions that can be used in the context of the ABAP RESTful
application programming model.
Once you’ve started the service, the first thing you should do is
create a dev space for your developments. For example, select the
SAP Fiori application type and click Create Dev Space (see
Figure 7.2). You could name your dev space RAP_DEMO.

Figure 7.2     Creating a New Dev Space
The list of existing dev spaces appears. There, you can open the dev
space you just created by clicking on its name (see Figure 7.3).
You’ll then see the RUNNING status displayed.
Figure 7.3     Starting a Dev Space
These first steps should suffice for now. In Part II, you’ll see SAP
Business Application Studio in action. Various instructions for setting
up and using the development environment can be found in SAP
Developer Center at http://s-prs.de/v868509.
7.1.2    Visual Studio Code
Visual Studio Code is a free, modern, and powerful development
environment available for Windows, macOS, and Linux operating

systems. This IDE supports the development with JavaScript,
TypeScript, and Node.js by default, and has an extensive selection
of plug-ins for other languages (such as C++, C#, Java, Python,
PHP, and Go) and platforms like .NET and Unity. These plug-ins are
also referred to as extensions. Such extensions also exist for the
development of SAP business applications, for example SAP Fiori
tools.
[+]  Tip: Getting Started
There are also numerous tutorials on Visual Studio Code available
that make it easier to get started with the tool and describe how to
use it. You can find these guides in the Microsoft portal for Visual
Studio Code at http://s-prs.de/v868510.
Specifically for Visual Studio Code setup, you can find an SAP
developers tutorial at http://s-prs.de/v868511.

7.2    SAP Fiori Elements
In this section, you ’ll learn how you can easily develop the UIs for
your RAP applications using SAP Fiori elements. We’ll describe how
you can use an OData service based on the ABAP RESTful
application programming model to manipulate and design the SAP
Fiori interface. Furthermore, you’ll learn how the RAP functions
defined in the behavior definition, such as actions, validation nodes
or investigations, can affect the user interface. We’ll also describe
the effect that messages from the behavior implementation can have
on the SAP Fiori interface.
7.2.1    Floorplans in SAP Fiori Elements
SAP Fiori elements provides predefined templates called floorplans
to make SAP Fiori app development easier and more efficient. In the
examples in Part II, we only use the list report and object page
floorplans. Thus, this section focuses on presenting these two
floorplans. Applications based on these templates automatically
comply with the SAP Fiori design guidelines.
[»]  Further Information About the Available Floorplans
If you need information about the other floorplans provided by SAP
Fiori elements, visit the SAP Fiori design guidelines page at
http://s-prs.de/v868512.
A list report enables you to view and edit a large number of
elements. The template includes the structure of two pages:

The initial screen shows a table with the data. This is the list
report.
When you call up a table entry, the details for this entry will be
displayed and prepared on the basis of a second floorplan—this is
the object page.
Figure 7.6 outlines the structure of the list report according to the
SAP Fiori design guidelines. It consists of three main blocks:
 Dynamic page header
The dynamic page header contains the title of the application,
the variant control for saving presets for the filter criteria or
sorting and/or grouping of the data, and the header toolbar with
the buttons for standard global operations, such as starting the
selection or adjusting filters.
 Content area
The content area contains the table with the data, including a
table header and another toolbar with buttons for the specific
actions for displaying and processing the list (actions). This
includes, for example, creating a new list element or sorting the
entries.
1
2
3

 Footer toolbar
The footer toolbar is optional. It includes save and cancel
buttons and a button to show and hide error messages.
Figure 7.4     Structure of a List Report (Source: SAP)
The detail view of a list item is based on the object page floorplan.
Figure 7.5 illustrates the structure of the object page with its
essential components:
 Dynamic page header
The dynamic page header of the object page contains the title,
the filter bar for restricting the data, and essential information
about the selected object (e.g., key fields). It also includes a
header toolbar with buttons for global operations, such as
editing or deleting the object.
 Content area
The content area of the object page consists of sections and
subsections arranged in a column layout. Each section serves
as a kind of container for several subsections. Their display is
comparable to a tab. The sections form the basic structure for
navigation via the navigation bar.
The subsections, in turn, serve as containers for the actual
content. They can contain individual fields, tables or charts.
3
1
2
3

 Footer toolbar
The footer toolbar of the object page is displayed in create or
change mode. It includes save and cancel buttons and a button
to show and hide error messages.
Figure 7.5     Structure of an Object Page (Source: SAP)
7.2.2    Selected UI Annotations
UI annotations define usage patterns for data in the user interface
independent of the UI technology. As described in Chapter 2,
Section 2.4, you can define UI annotations, for example, as part of
the metadata extension of a CDS view. As a backend developer, you
can use it to manipulate the UI in a simple and standardized way,
without having any special knowledge of UI technology. SAP Fiori
elements interprets the UI annotations in the backend and
implements them in the UI.
For the floorplans presented in the previous section, the following UI
annotations are used repeatedly:
UI.lineItem
The UI.lineItem annotation is used to represent data from
multiple data instances in a table or list. For example, it can be
3

used to show fields of the table in the content area of the list
report.
UI.selectionField
The UI annotation UI.selectionField allows you to activate a
selection element in the filter bar. If input help is defined for the
specified element, it will automatically be displayed in the user
interface.
UI.identification
The UI.identification annotation (in conjunction with the
UI.headerInfo annotation) determines which data will be displayed
in the content area of the object page.
UI.facet
The UI.facet annotation can be used to define a section on the
object page. You can assign sections to a parent section using the
parentId parameter. The parent section must be of type
#COLLECTION.
UI.fieldGroup
The UI.fieldGroup annotation allows you to define subsections for
an object page. These must be assigned to a section. You can use
the UI.facet and UI.fieldGroup annotations to logically group the
data in the object page content area in this way.
UI.headerInfo
Using the annotations that belong to the UI.headerInfo annotation,
you can describe an entity by assigning it a title and an optional
short description. The name of the entity must be specified in the
singular and in the plural. The singular is then displayed in the
title, while the plural forms the heading of the table in the content
area of the list report (e.g., Sales Order and Sales Orders).
Optionally, you can specify a URL to call an image for the entity.

The positioning order of the UI elements in the user interface can be
controlled via the annotations listed above using an arbitrary decimal
number as the value of the position feature. Furthermore, you can
use the label feature to specify a text that will be visible in the UI as
a label or heading. In addition, the criticality feature can be used
to display a traffic light icon in each line of a list with reference to a
field of the entity. This feature can take the following values:
1 = Red traffic light
2 = Amber traffic light
3 = Green traffic light
For a concrete example of this traffic light control, see Chapter 9,
Section 9.5. For detailed information on these and other UI
annotations, refer to SAP Help Portal at http://s-prs.de/v868513.
7.2.3    Defining UI Annotations in a CDS View
In the previous section, you already got to know some annotations
that enable you to modify the user interface. Using the CDS view
/DMO/C_Travel_U from the ABAP flight reference scenario as an
example, you’ll see on the following pages how you can modify the
SAP Fiori interface using such UI annotations. To show the effect of
the annotations, we created a business service named
ZUI_TRAVEL_ODATA_O2 for the CDS view.
[»]  Business Service for SAP Fiori Elements
In the SAP Fiori environment, business services are always OData
services. The SAP Fiori elements floorplans are based on an
OData service of version V2. Two variants are supported, one with

and one without draft handling. For OData services of version V2
for web APIs, only the variant with draft is supported.
We’ll show you how you can use the UI annotations first for a list
report and then for an object page. We’ll then discuss the definition
of actions, and the impact of validations and determinations on the
user interface.
Designing a List Report
The user interface you see in Figure 7.6 was designed entirely using
the list report floorplan and UI annotations. In the following sections,
we’ll analyze the annotations and their effects on the user interface,
step by step.
Figure 7.6     List Report for Business Service ZUI_TRAVEL_ODATA_O2
To display filter conditions in a filter bar in the dynamic page header
of the application as shown in Figure 7.7, you need the UI annotation
UI.selectionField.

Figure 7.7     List Report: Filter Bar
Listing 7.1 shows how you can set the UI annotations in the
underlying CDS view /DMO/C_Travel_U to set the filter criteria for the
Travel ID, Agency ID and Customer ID fields. The position
parameter in parentheses is only used to sort the fields in the
desired order.
  @UI.selectionField: [{ position: 10 }]   
TravelID;
  @UI.selectionField: [{ position: 20 }]   
AgencyID;
  @UI.selectionField: [{ position: 30 }]   
CustomerID; 
Listing 7.1     UI Annotations for Filter Criteria
To enable a search across multiple fields (referred to as a default
filter; see Figure 7.8), annotations are needed for the definition of
search properties.
Figure 7.8     List Report: Search Field
The first step is to specify in the CDS view that the CDS view is
relevant for search scenarios (provided any other search-related
annotations will be defined for elements of the CDS view). This basic
activation is done via the annotation @Search.searchable: true.
Using the annotation @Search.defaultSearchElement: true specifies

that the subsequent element should be included in a free search
across multiple columns. Listing 7.2 shows how the annotations
were set in CDS view /DMO/C_Travel_U to create the user interface
shown in Figure 7.8. In this case, the default filter takes into account
the AgencyID and CustomerID columns.
...
@Search.searchable: true
define root view entity /DMO/C_Travel_U
  as projection on /DMO/I_Travel_U
 
{     ///DMO/I_Travel_U
 
  key TravelID,
...
      @Search.defaultSearchElement: true
      AgencyID,
      _Agency.Name       as AgencyName,
...
      @Search.defaultSearchElement: true
      CustomerID,
... 
Listing 7.2     Annotations for the Definition of a Free Search
[ ! ]  Warning: Using the Search.defaultSearchElement
Annotation
The annotation Search.defaultSearchElement should be used
wisely and selectively. If you were to annotate all elements of a
view with this annotation, it could affect the performance
significantly, since all fields would always have to be searched.
To implement a table header like the one in Figure 7.9 using UI
annotations, you need the annotation UI.headerInfo.

Figure 7.9     List Report: Table Header
The typeName and typeNamePlural properties let you set the label for
a set of entities across a list report table or a single object in an
object page. title:value specifies which element of the table the
title refers to. This determines, for example, the number of entries,
which is also output across the table. If you use an association to
refer to a value, you need to specify the path to the corresponding
element. In Listing 7.3, you can see how the UI.headerInfo
annotation was defined for the definition of the table header in
Figure 7.9.
@UI: { headerInfo: { typeName: 'Travel', 
                     typeNamePlural: 'Travels', 
                     title: { type: #STANDARD, 
                              value: 'TravelID' } } } 
Listing 7.3     Annotations for the Definition of a Header
You can define the table as such using the UI annotation
UI.lineItem. Listing 7.4 shows how to define the table in the content
area of our exemplary list report.
...
    @UI.lineItem: [{ position: 10 }] 
  TravelID;
    @UI.lineItem: [{ position: 20 }] 
  AgencyID;
    @UI.lineItem: [{ position: 30 }] 
  CustomerID;
... 

Listing 7.4     Annotations for the Definition of a Table
[+]  Tip: Grouping Annotations
To make the display of the UI annotations clearer within a CDS
view, you can also group definitions. Listing 7.5 shows this using
the example of the TravelID property for the annotations
UI.lineItem and UI.selectionField.
@UI: { lineItem:       [ { position: 10, 
                           importance: #HIGH } ], 
       selectionField: [ { position: 10 } ] }
TravelID;
Listing 7.5     Grouped UI Annotations for the TravelID Property
Designing an Object Page
Figure 7.10 shows the structure of the object page that displays
when a list element is selected from our list report. This user
interface was also developed using UI annotations.
In the first step, we’ve defined the sections of the object page for this
purpose. There’s one section for travel information (Travel) and one
for booking information (Bookings, see Figure 7.11). The definition
was done using the UI annotation UI.facet.

Figure 7.10     Object Page for Business Service ZUI_TRAVEL_ODATA_O2
Figure 7.11     Object Page: Sections
The corresponding UI elements are also called facets. In Listing 7.6
you can see how the two facets were defined for our example. You
need a unique ID in each case to be able to address the section
later. You can use the purpose parameter to specify how the facet is
supposed to be used. This parameter can’t be set if it’s a subsection;
that is, if the parentId has been set. The type parameter controls the
section type. The label parameter defines a name for the section
that will be displayed in the application. The position parameter
determines the display order of the sections in the user interface.

@UI.facet: [ { id:            'Travel',
               purpose:       #STANDARD,
               type:          #IDENTIFICATION_REFERENCE,
               label:         'Travel',
               position:      10 },
             { id:            'Booking',
               purpose:       #STANDARD,
               type:          #LINEITEM_REFERENCE,
               label:         'Booking',
               position:      20,
               targetElement: '_Booking'}] 
Listing 7.6     Annotations for the Definition of Facets
In our example, the Travel section displays individual fields and the
Booking section displays a table with booking information.
[»]  Types of Facets
There are five different facet types that you can define using the
following annotation values:
#HEADER: Section with header data
#CHART_REFERENCE: Section with a diagram
#COLLECTION: Parent sections (contains several groups with
fields, for example)
#FIELDGROUP_REFERENCE: Section with grouped fields. There can
be several sections of this type in one tab.
#LINEITEM_REFERENCE: Section with a table
#IDENTIFICATION_REFERENCE: Section with a group of fields in one
tab
In Figure 7.12 you can see the section that has been defined with
the Travel ID. In the section, individual fields from the CDS view
/DMO/C_Travel_U are output.

Figure 7.12     Object Page: Section with Individual Fields
These fields were defined as part of a metadata extension to the
CDS view using the UI.identification annotation (see Listing 7.7).
For the Memo column, the text to be displayed in the application has
been overridden using the UI.identification.label annotation.
@UI: { ... identification: [ { position: 10 } ], ... ] }
TravelID;
@UI: { ... identification: [ { position: 20 } ], ... ] }
AgencyID;
@UI: { ... identification: [ { position: 30 } ], ... ] }
CustomerID; 
@UI: { ... identification: [ { position: 40 } ] }
BeginDate;
@UI: { ... identification: [ { position: 41 } ] }
EndDate;
@UI: { identification: [ { position: 42 } ] }
BookingFee;
@UI: { identification: [ { position: 43 } ] }
TotalPrice;
@UI: { identification:[ { position: 45, 
                         label: 'Comment' } ] }
Memo;
... 
Listing 7.7     Annotations for a Section to Display Individual Fields from CDS View
/DMO/C_Travel_U
In the second section defined via the annotation UI.facet for the
booking data with the Booking ID, data from CDS view
/DMO/C_Booking_U is displayed as a table (see Figure 7.13).

Figure 7.13     Object Page: Section with Table
The annotation UI.lineItem is used analogously to the table in the
list report (see Listing 7.8). The difference is that now data from CDS
view /DMO/C_Booking_U linked by association is displayed. Sections
can also be defined again in linked CDS views, and links can be
made to a subsequent screen (again, an object page).
@UI: { lineItem:       [ { position: 20… } ] }
BookingID;
@UI: { lineItem:       [ { position: 30… } ] }
BookingDate;
@UI: { lineItem:       [ { position: 40… } ] }
CustomerID;
@UI: { lineItem:       [ { position: 50… } ] }
AirlineID;
@UI: { lineItem:       [ { position: 60… } ] }
ConnectionID;
@UI: { lineItem:       [ { position: 70… } ] }
FlightDate;
@UI: { lineItem:       [ { position: 80… } ] }
FlightPrice; 
Listing 7.8     Annotations for the Definition of a Section with Table Data from CDS View
/DMO/C_Booking_U
As you can see in Figure 7.14, the Edit button, which activates the
editing mode for the object page, is active in our example.

Figure 7.14     Object Page: Edit Button
This results from the fact that the standard operation ipdate was
defined as part of the behavior definition for CDS view
/DMO/I_Travel_U (see Listing 7.9).
implementation unmanaged;
 
// behavior defintion for the TRAVEL root entity
define behavior for /DMO/I_Travel_U alias travel
implementation in class /DMO/BP_TRAVEL_U unique
etag master LastChangedAt
lock master
 
{
  field  (  read only  )  TravelID;
  field ( mandatory ) AgencyID, CustomerID, BeginDate, EndDate;
 
  create;
  update;
  delete;
... 
Listing 7.9     Behavior Implementation for CDS View /DMO/I_Travel_U
In Figure 7.15, you can see the same object page after the edit
mode has been activated via the Edit button. The Travel ID can’t be
changed, which was defined in the behavior definition for CDS view
/DMO/I_Travel_U with the addition field ( read only ) for the
TravelID field. Due to the field ( mandatory ) entry in the behavior
definition for the AgencyID, CustomerID, BeginDate and EndDate fields,

these fields are declared mandatory and marked with an asterisk (*)
in the user interface.
Figure 7.15     Object Page in Edit Mode
The Agency ID field at the bottom left of the Travel section contains
a search help or input help, which can be accessed via the 
 icon
on the right side of the field to help users with their entries. This
search help is connected to CDS view /DMO/C_Travel_U via the
annotation Consumption.valueHelpDefinition. CDS view
/DMO/I_Agency forms the data basis of the search help. In this
example, /DMO/I_Travel_U is the basic interface view. Using the
same procedure, you can use any views as search helps. In
Figure 7.16, you can see the popup window that appears when you
call the search help for the Agency ID field.

Figure 7.16     Search Help for the Agency ID Field
Listing 7.10 shows how you can activate the connection of the
search help in the CDS view /DMO/C_Travel_U.
define root view entity /DMO/C_Travel_U
  as projection on /DMO/I_Travel_U
{ 
  key TravelID,
      @Consumption.valueHelpDefinition: [{ 
      entity: { name:    '/DMO/I_Agency',
                element: 'AgencyID' } }]
      @ObjectModel.text.element: ['AgencyName']
      @Search.defaultSearchElement: true
  AgencyID,
... 
Listing 7.10     Search Help Integration in /DMO/C_Travel_U
If a field is a date field, like the Starting Date field, a search help for
date fields is automatically generated based on the stored data
element. You don’t need to program anything for this. Figure 7.17
shows an example of such a search help for the Starting Date field.

Figure 7.17     Calendar Search Help for Date Fields
In Figure 7.15, you can also see that some fields in the booking data
table can be changed in the Booking section. This changeability is
based on the behavior definition for CDS view /DMO/I_Booking_U in
Listing 7.11.
Within the scope of this behavior definition, the TravelID and
BookingID fields are defined as not changeable. The fields
BookingDate, CustomerID, AirlineID, ConnectionID and FlightDate
are declared as changeable mandatory fields. The standard
operations update and delete are also defined. Since the edit mode
is currently activated in Figure 7.15, the Edit button is not visible
here. The Delete button for deleting an element is inactive in
Figure 7.15 because it is instance-based, which means that an
element to be deleted must be selected in order to click on it.
...
// behavior definition for the BOOKING child entity

define behavior for /DMO/I_Booking_U alias booking
implementation in class /DMO/BP_BOOKING_U unique
etag dependent by _Travel
lock dependent by _Travel
{
  field ( read only ) TravelID, BookingID;
  field ( mandatory ) BookingDate, CustomerID, AirlineID, 
                 ConnectionID, FlightDate;
  update;
  delete;
... 
Listing 7.11     Behavior Definition for CDS View /DMO/I_Booking_U
Since in CDS view /DMO/C_Booking_U UI annotations have been
defined for the subsequent screen (i.e., another object page), further
navigation to the details of the booking data is possible, which you
can see in Figure 7.18.
Figure 7.18     Object Page: Subsequent Screen with More Details
Listing 7.12 shows the required annotations from the associated
metadata extension. Since the standard update operation was
defined for the booking data in the behavior definition, it’s also
possible to switch to the edit mode in the subsequent screen (see
Figure 7.19). Theoretically, you could nest your applications deeper
and deeper.
annotate view /DMO/C_Booking_U with
{
  @UI.facet: [ { id:            'Booking',
...
  @UI: { lineItem:       [ { position: 20,
                             importance: #HIGH } ],
         identification: [ { position: 20 } ] }

  BookingID;
 
  @UI: { lineItem:       [ { position: 30,
                             importance: #HIGH } ],
         identification: [ { position: 30 } ] }
  BookingDate;
...
Listing 7.12     UI Annotations from CDS View /DMO/C_Booking_U
Figure 7.19     Object Page: Subsequent Screen in Update Mode
Defining Actions in the User Interface
In the behavior implementation for CDS view /DMO/I_Travel_U the
three standard operations create, update and delete are defined.
These are automatically recognized by SAP Fiori elements. As a
result, appropriate buttons are generated in the user interfaces
based on the templates. You don’t need to do anything else.
However, you can define additional actions. In our example, a
set_status_booked action was defined as an additional, nonstandard
operation (see Listing 7.13).
...
define behavior for /DMO/I_Travel_U alias travel
implementation in class /DMO/BP_TRAVEL_U unique
etag master LastChangedAt
lock master
 
 
{
  field ( read only ) TravelID;
  field ( mandatory ) AgencyID, CustomerID, 

                      BeginDate, EndDate;
 
  create;
  update;
  delete;
 
  action ( features : instance ) 
     set_status_booked result [1] $self;
... 
Listing 7.13     Definition of Actions in the Behavior Definition for CDS View
/DMO/BP_TRAVEL_U
To have a button for this action displayed in the SAP Fiori user
interface, a few steps are necessary. By defining the action in the
context of the behavior definition, in the first step, a function import
(FunctionImport) is created in the associated OData service. This is
shown in Figure 7.20. It makes the action executable via the OData
service, so all that’s left to do is customize the UI.
Figure 7.20     OData Service with Function Import
The UI.lineItem annotation can then be used to display a button for
the action. Listing 7.14 contains sample code to show a button using
this annotation. The type parameter must have the value
#FOR_ACTION. The dataAction parameter is assigned the name of the
desired action and the label parameter is assigned the desired
name of the button in the SAP Fiori UI.

@UI: { lineItem: [ { position: 50, 
                     importance: #HIGH },
                   { type: #FOR_ACTION, 
                     dataAction: 'set_status_booked', 
                     label: 'Set to Booked' } ] }
Listing 7.14     UI Annotations for Defining a Nonstandard Operation
[»]  Translating Texts from UI Annotations
Texts, such as labels, that are created using UI annotations as part
of metadata enhancements can be translated using Transaction
SE63, which is familiar from classic ABAP development. However,
it’s generally recommended to use the texts from the underlying
data element and not to always redefine labels.
Once the new operation has been adopted by the user interface,
you’ll see buttons above the table in the list report for the operations
to create, delete, and set the booking status (see Figure 7.21). The
change button is generated on the object page by default.
Figure 7.21     List Report: Buttons for Actions
Defining Notifications for Validations in the User Interface
Validations don’t affect the UI in the first step. However, if messages
are passed via the REPORTEDparameter, they will automatically be
interpreted and output by SAP Fiori elements.

Figure 7.22 shows the effect of a failed validation to check the input
in the Agency ID field in the UI. The incorrectly maintained field is
outlined in red and an error message is displayed in a popup
window. As long as the value hasn’t been corrected, the data can’t
be saved. The example shows the representation of a message of
type E (error).
Figure 7.22     Error Message After a Validation
In Figure 7.23, you can see how messages of type W (warning) are
displayed. Figure 7.24 shows how messages of type I (information)
or S (status) are displayed.

Figure 7.23     Type W Message
Figure 7.24     Type I or S Message
[ ! ]  Warning: Side Effects of Determinations
Determinations have no direct influence on the UI. However, they
influence the interface indirectly, since they trigger an additional
action during saving and can thus affect the displayed data. Note
the possibility of side effects.
Side effects are a way to inform the frontend which fields on the
user interface might be affected by a change, so that the frontend
can request new data for those fields. If no side effects are

defined, the interface may display outdated data. For more
information on side effects, see the SAPUI5 documentation at
http://s-prs.de/v868514.
7.2.4    Generating Annotations via the Service Modeler
Within the SAP Fiori tools extension, both SAP Business Application
Studio and Visual Studio Code provide a service modeler. This tool
allows you to set local UI annotations independently of CDS views
and thus influence the SAP Fiori elements UI.
The basic idea of the modeler is to completely separate backend and
frontend development. All UI annotations are set directly in the
service modeler and not as a metadata extension of CDS views. In
addition, the service modeler also allows you to override the existing
UI annotations in CDS views with new UI annotations (i.e., to
specifically influence the behavior of individual fields in the user
interface).
In the following sections, we’ll use the ZUI_TRAVEL_ODATA_O2 business
service used in the previous section to show you how to define or
modify the UI annotations in the service modeler. We use SAP
Business Application Studio to demonstrate the capabilities of the
service modeler.
[»]  Requirements
The following steps for creating a project assume that you have
configured an SAP system in your SAP BTP account or in your
SAP BTP trial account. Provided that it’s an on-premise system,
the configuration of a connection via cloud connector is also a
prerequisite. This configuration isn’t described in this book

because it involves frontend-specific settings. For more
information on setting up cloud connector, you should visit SAP
Help Portal via http://s-prs.de/v868515.
Since both SAP Business Application Studio and Visual Studio
Code use the SAP Fiori tools extension, the procedure in Visual
Studio Code is similar. However, there you don’t need a system
connection via cloud connector. Creating a project in Visual Studio
Code is described in Chapter 9.
1. In the first step, you create a new project based on the business
service ZUI_TRAVEL_ODATA_O2 in the SAP Business Application
Studio start screen. To do so, you must select the Start from
template option (see Figure 7.25).
Figure 7.25     Creating a Project Based on a Template
2. Then, you need to select SAP Fiori application as the project
type (see Figure 7.26).

Figure 7.26     Selecting the SAP Fiori Application Template
3. Now you can select a floorplan. Use the floorplan List Report
Object Page to create a list report. Then click the Next button.
Figure 7.27     Selecting a Template for a List Report
4. In the next step, you must select the service to be used on your
system. Figure 7.28 shows the selection of business service
ZUI_TRAVEL_ODATA_O2.

Figure 7.28     Selecting a Business Service as a Data Source
5. Now, from this service, you can select the entities you want to
use in your application. In the Main entity field, select the Travel
entity and in the Navigation entity field, select the to_Booking
entity (see Figure 7.29). The latter is available due to the
association defined in the CDS data model, without the need to
explicitly implement a navigation feature.
Figure 7.29     Selecting Entities for Use in the List Report
6. In the final step, you need to maintain the general project
properties, such as the technical name of the module, the title of

the application, the save path, and the SAPUI5 version to be
used, as in Figure 7.30. Then click the Finish button. This will
generate the project.
Figure 7.30     Defining Project Properties
Once the SAP Fiori Elements project has been created, you can
right-click on the webapp folder to open the context menu for the
generated application and select Open Service Modeler to open the
service modeler (see Figure 7.31).

Figure 7.31     Opening the Service Modeler via the Context Menu
In the service modeler, you’ll obtain an overview of the entities of the
selected service. Since you defined the Travel entity as the main
entity when you created the project, this entity contains the UI
annotations for the list report. Click on the @ icon to the right of this
entity (see Figure 7.32) to open the overview of already existing UI
annotations.
Figure 7.32     Entity Overview for the List Report in the Service Modeler

As shown in Figure 7.33, you obtain an overview of the annotations
for the selected entity. The view is divided into three parts:
The upper part displays the local UI annotations from your current
SAP Fiori project.
Below that, the UI annotations that are provided via the underlying
CDS views are displayed.
This is followed by a block of UI annotations from the OData
service.
Figure 7.33     Displaying an Overview of UI Annotations
The option to append annotations to the OData service existed
before the ABAP RESTful application programming model. We won’t
describe it any further in this book. Our focus is on the first two
options.

The UI annotations aren’t yet listed in detail, but they are shown
grouped by their annotation type (e.g., UI.Facets, UI.LineItems,
etc.). By clicking the 
 (Show in source) button in Figure 7.33 you
can view the details of the selected annotation.
Figure 7.34 shows the UI.Facet annotations for the Travel entity.
The representation is in XML format. Changes aren’t possible at this
point because they’re existing UI annotations from the CDS view. For
these annotations, the CDS view leads the way, as opposed to
annotations that you copy and modify in the service modeler.
Figure 7.34     Detail View of Annotations
You can only edit the local annotations in the service modeler. For
this reason, the first step is to copy the annotations to the local
annotations of your SAP Fiori project. To do this, you must click on
the copy button (
) next to the desired annotation group in the
overview in Figure 7.33.

In your local annotations, you can now customize the XML file
annotation.xml (see Figure 7.35). Such customizations override UI
annotations from CDS views or OData services. The original
annotations remain unchanged.
Figure 7.35     Customizing Local Annotations
In Listing 7.15, you can see in more detail how the UI annotation
UI.selectionField is represented in the service modeler. This XML
formatting has the same effect as the UI annotations in the CDS
view from Listing 7.1. It’s merely a different representation.
<Annotation Term="UI.SelectionFields">
    <Collection>
      <PropertyPath>TravelID</PropertyPath>
      <PropertyPath>AgencyID</PropertyPath>
      <PropertyPath>CustomerID</PropertyPath>
    </Collection>
</Annotation> 
Listing 7.15     UI Annotations for Filter Criteria
The XML code in Listing 7.16 is used to define the list report header.
For example, the table headers are set. In the CDS view, the
notation @UI.HeaderInfo would be used instead.
<Annotation Term="UI.HeaderInfo">
    <Record>
        <PropertyValue Property="TypeName" 
            String="Travel"/>
        <PropertyValue Property="TypeNamePlural" 

            String="Travels"/>
        <PropertyValue Property="Title">
            <Record Type="UI.DataField">
                <PropertyValue 
                   Property="Value" Path="TravelID"/>
            </Record>
        </PropertyValue>
    </Record>
</Annotation> 
Listing 7.16     Definition of the UIHeaderInfo Annotation in XML Format
In Listing 7.17 you can see another example of how you could map
the UI.LineItem annotations to create a table in the service modeler.
<Annotation Term="UI.LineItem">
    <Collection>
        <Record Type="UI.DataField">
            <PropertyValue Property="Value" 
                Path="TravelID"/>
            <Annotation Term="UI.Importance" 
               EnumMember="UI.ImportanceType/High"/>
        </Record>
        <Record Type="UI.DataField">
            <PropertyValue Property="Value" 
               Path="AgencyID"/>
            <Annotation Term="UI.Importance" 
               EnumMember="UI.ImportanceType/High"/>
        </Record>
... 
Listing 7.17     Mapping LineItem Annotation to Create Table in Service Modeler
You can also edit the annotations for an object page in this way.
Figure 7.36 shows the overview of UI annotations for the Booking
entity from the ZUI_TRAVEL_ODATA_O2 business service in the service
modeler. You can display these existing annotations as described for
the list report or override them in the local annotations.

Figure 7.36     Overview of Annotations for the Object Page in the Service Modeler
Adding a button to trigger an action via the service modeler is slightly
different from the approach we’ve considered so far. For this
purpose, the annotation UI.DataFieldForAction is used, rather than
the annotation @UI.lineItem{...dataAction:...}. Listing 7.18 shows
the XML code for displaying a button. The example has the same
effect as Listing 7.14.
<Record Type="UI.DataFieldForAction">
    <PropertyValue Property="Label" 
       String="Set to Booked "/>
    <PropertyValue Property="Action" String="cds_zui_travel_u.cds_
       zui_travel_u_Entities/set_status_booked"/>
    <PropertyValue Property="InvocationGrouping" 
       EnumMember="UI.OperationGroupingType/Isolated"/>
</Record> 
Listing 7.18     Defining an Action in XML Format
In conclusion, all UI annotations that can be used in the context of
metadata extensions to CDS views are also available as UI
annotations in the service modeler and can be mapped there. You

must decide for yourself what makes the most sense in the specific
application:
For someone with 20 years of ABAP experience but no front-end
development experience, it can be easier to create a RAP-based
SAP Fiori elements application. As long as the floorplans meet
your requirements, there’s virtually no web development expertise
required to do so.
If a strict separation between frontend and backend development
is to be maintained, it might make sense to use the service
modeler for generating the UI annotations. This is especially true if
several developers are working on the application.
Another usage scenario for UI annotations in the CDS data model
is when you want to implement simple maintenance dialogs in the
style of Transaction SM30 as an SAP Fiori app. However, if you
want to create a complex app, it might make sense to separate
the backend and frontend development and involve a UI expert.
[»]  Guided Development
If the standard capabilities of SAP Fiori elements templates aren’t
sufficient, you can extend your application using guided
development in SAP Business Application Studio. This tool
provides guidance and instructions for performing common
development tasks based on best practices defined by SAP
development teams. Such extensions can’t be implemented with
ABAP, but require, for example, JavaScript or XML knowledge,
depending on the use case. For more information on guided
development options, you can visit SAP Help Portal at http://s-
prs.de/v868516.

Part II
Practical Application Development

8    Use Cases
This chapter describes possible areas of use for the ABAP
RESTful application programming model. It clarifies which
scenarios are suitable for which context.
The ABAP RESTful application programming model is a
standardized programming model for developing applications for
SAP S/4HANA, SAP S/4HANA Cloud, and SAP Business
Technology Platform (SAP BTP). It provides extensive functions and,
associated with this, a wide variety of options for developing
applications in different areas (e.g., analytical or transactional
applications). Which of the’nkse functions and which development
approach you should choose to implement your specific
requirements depends (in addition to the requirements themselves)
not least on the given framework conditions.
Section 8.1 first describes the different types of services you can
develop with the ABAP RESTful application programming model.
Section 8.2, takes a look at which implementation types you can
choose for your specific use case. The criteria for selecting the
implementation type are presented in more detail in Section 8.3.
8.1    Applications Types
The ABAP RESTful application programming model helps you
develop the following types of applications.

SAP Fiori applications
The ABAP RESTful application programming model enables the
creation of OData services that serve as the basis for the
development of role-based SAP Fiori applications. You can use
the draft concept to develop stateful applications using stateless
communication via the OData protocol.
You can create transactional SAP Fiori apps and read-only data
staging apps. Another use case involves the development of
analytical applications in SAP Analytics Cloud based on services
exposed via the Information Access (InA) protocol.
Web APIs
You can also publish an OData service as a web API so that it can
be used by any client, regardless of a particular user interface. In
this case, the OData service doesn’t contain any UI-specific
metadata because the usage doesn’t take place in the UI context.
The basis of the OData service remains the same regardless of
whether it’s used as a UI or an API. Only the binding type in the
respective service binding differs.
Local API
Business objects don’t necessarily have to be accessed via
services. You can also access a business object with ABAP code
by using the entity manipulation language (EML) syntax. The
stability of a local API is ensured by a release procedure for the
business object.
A typical use case for accessing a business object using EML is to
create an ABAP Unit test to test its transactional behavior. This
approach would also come into play when you integrate different
business objects. It’s conceivable, for example, to execute a
CRUD operation of another business object within a validation or
within an action of a business object.

8.2    Implementation Types
As we’ve already explained in Chapter 1, Section 1.2.2, the RAP
framework distinguishes between different implementation types that
you can use to implement your development project. For read-only
and transactional scenarios, these are essentially the two main
implementation types, managed and unmanaged.
[»]  Implementation Type and Usage Type of a Business
Object
The implementation type you use won’t affect the possible way of
using a business object. In both implementation types, a business
object can be consumed as a UI service as well as a web API or
local API.
In the read-only scenarios (queries), the behavior of a business
object is determined only by the possibilities provided by read
access (e.g., filtering or sorting functions). To create managed
queries, you need to perform a data selection using data models
based on CDS views, while for a data selection in unmanaged
queries, you must use CDS custom entities.
The main focus in our practical examples in the following chapters is
on the implementation of transactional scenarios. In these scenarios,
the behavior of a business object defines the properties and
operations a business object has.
The choice of an implementation type significantly affects the
development tasks you must perform to implement the business
object behavior:

Managed implementation type 
If you choose the managed implementation type, you only need to
specify the default operations (create, update, and delete) in the
behavior definition. The standard read operation is available
without this specification. The technical aspects of the
implementation are handled by the RAP framework. You don’t
need to bother about managing the transaction buffer during the
interaction phase or persisting the data in the save sequence. You
can focus on implementing the rest of the business logic, such as
implementing validations, determinations, and actions.
In Chapter 9, we’ll create an application with the managed
implementation type.
Managed implementation type with unmanaged or additional
save
The implementation types with unmanaged save or additional
save represent variants of the managed scenario. Whereas in the
managed implementation type the interaction phase and the save
sequence are completely taken over by the RAP framework, in
these two variants you can manipulate the persistence of the data.
In the variant with unmanaged save, you assume the entire
responsibility for persistence. In the variant with additional save
you can add additional logic to the persistence managed by the
framework (see also Chapter 5, Section 5.5.4). However, the
interaction phase is still managed by the RAP framework in both
variants.
In Chapter 10, you’ll develop an application using the variant with
unmanaged save.
Unmanaged implementation type
With this implementation type, you are completely responsible for
implementing the business object behavior in the interaction and
save sequence. To do this, you must manually implement the

behavior specified in the behavior definition in the behavior pool.
Your responsibilities will include, for example, handling the
transaction buffer, implementing lock logic, and performing data
retention.
For a practical example of the unmanaged scenario, see
Chapter 11.
[»]  Business Object Processing Framework (BOPF)-Managed
Implementation Type
SAP is planning the BOPF-managed implementation type as a
further implementation type. This implementation type supports
you in migrating applications created with the ABAP programming
model for SAP Fiori. The migration for purely technical reasons
isn’t mandatory, as the programming model with its CDS-based
BOPF business objects continues to be supported.

8.3    Selecting the Appropriate
Implementation Type
Selecting the appropriate implementation type is essential, not least
because each implementation type differs greatly in terms of the
nature and scope of the development tasks to be performed. The
starting point of your application—before you implement the ABAP
RESTful programming model—is a key to this decision. In particular,
the presence of existing code that you can reuse when implementing
the business object behavior will influence the implementation type.
In the following sections, we’ll take a look at the application starting
point and explain which implementation type is the right choice in
each case.
If you want to create a transactional application from scratch that’s
built on its own new data model and for which no business logic is in
place yet, this is known as the greenfield approach. In this case, the
managed scenario is the right choice. This implementation type
provides you with the greatest possible support during the
implementation. The standard CRUD operations you want to use can
simply be specified in the behavior definition. Manual implementation
isn’t required. The handling of the transaction buffer and the
persistence of the data during the interaction phase and the save
sequence are handled by the framework. So, you can completely
focus on implementing the business logic that can be mapped using
actions, validations, and determinations. On the other hand, it’s
difficult to implement already existing business logic with this
implementation type. It’s less flexible, but is associated with the
lowest development effort.

[»]  Preferring the Managed Scenario
The managed implementation type should be preferred whenever
possible, as it fully implements the functionalities managed by the
framework according to the RAP contract.
If you want to revamp an existing application to take advantage of
the SAP Fiori user interface or to leverage the power of SAP HANA,
then this is referred to as the brownfield approach. In doing so, you
want to build on existing application code in which CRUD operations
are already implemented. For example, application code could
already be available to validate data, lock records, or persist data.
To be able to reuse existing code in the ABAP RESTful application
programming model, it must have the following characteristics:
It is modularized in function modules or methods.
Business logic hasn’t been mixed with technical aspects such as
UI technologies or protocols.
The application code acts in its own transaction buffer.
No commits are made.
If an API of this type is available for you to use in the interaction
phase and the save sequence, the unmanaged scenario is the right
choice. Your task is then to manually implement the business object
behavior in the behavior pool using the existing API.
[ ! ]  Warning: Structure and Quality of the Existing API are
Crucial
Note that the development effort is largely dependent on the
existing API. As an example, consider the interface of a RAP
business object that marks fields to be changed in the control

structure %CONTROL. If the existing API doesn’t work with this type of
structure for field selection, additional fields must be read in the
interaction or save sequence.
[»]  Implementation Scenario for CDS Custom Entities
When using CDS custom entities for data retrieval, only the
unmanaged scenario (without draft functionality) can be used.
The last possible initial situation is similar to that of the brownfield
approach. In this case, however, reusable existing application code
is only available for updating data during the save sequence.
Otherwise, the available application code isn’t easily usable (e.g.,
due to a tight coupling to screen interface technology). That is, the
interaction phase is managed by the RAP framework, analogous to
the managed scenario. You merely need to implement the business
logic in the form of actions, validations, and determinations.
A typical use case for the managed scenario with unmanaged save
is the use of business application programming interfaces (BAPIs)
(e.g., the BAPI BAPI_PO_CREATE1 for persisting application data). In
Chapter 10, this exact case will be implemented. There, the sole
data source is the standard SAP business object of the purchase
order. The application we create in Chapter 10 doesn’t have its own
persistence. For this reason, the save sequence is also not left to the
RAP framework as in the fully managed scenario. The database
changes should be made by the BAPI call instead.
A typical use case for the managed scenario with additional save is
when you want to add additional logic to the save sequence
managed by the RAP framework. In Chapter 9, you’ll create an
application from scratch based on custom tables. You leave the

handling of the transaction buffer as well as the posting of the data
during interaction phase and save sequence to the RAP framework.
If you then add to this use case the requirement to update additional
data that’s not part of the actual business object, then the
implementation type managed with additional save is the right choice.
The additional posting of data can include, for example, an entry in
the SAP application log or the writing of change documents.
Table 8.1 summarizes the most important criteria for selecting the
implementation type.
Initial Situation
Implementation
Type
Creating a new application from scratch
(greenfield approach)
Managed
scenario
Revamping an existing application (brownfield
approach). The existing application provides an
API that can and should be used for the
implementation of interaction phase and save
sequence due to its characteristics (structure,
decoupling of business logic and technical
aspects).
Unmanaged
scenario
Using parts of an existing application (e.g., a
BAPI) in the save sequence.
Managed
scenario with
unmanaged
save
Adding further update logic to the save
sequence (e.g., in the application log) that
doesn’t affect the actual business object.
Managed
scenario with
additional save
Table 8.1     Criteria for Selecting the Implementation Type

9    Managed Scenario:
Developing an Application with
SAP Fiori Elements
One possible area of use of the ABAP RESTful application
programming model is the managed scenario. With this
implementation variant you can implement applications based
on your own data model—ideally supported by the
programming model.
In this chapter, we’ll show you how to create your first full-featured
application based on the ABAP RESTful application programming
model. Based on an example, you’ll see how you can put the basic
knowledge taught in Part I into practice. The use case follows the
managed scenario and enriches an SAP Fiori elements application
with actions, validations, and determinations. The created application
is independent without direct reference to the standard SAP data
model. Only standard SAP data elements are used and foreign key
relationships are built in.
After introducing the use case in Section 9.1, we’ll describe the data
model used in Section 9.2. We’ll then demonstrate how you can
build the application step by step, from behavior definition and
implementation (Section 9.3) to creating the business service
(Section 9.4) and generating the SAP Fiori elements UI
(Section 9.5). In Section 9.6, Section 9.7, and Section 9.8, we’ll

enrich the application with additional behavior to extend its
functionality. Finally, we’ll generate and deploy the application in
Section 9.9.
[»]  System Requirements for the Sample Application
The example was developed and executed on an SAP S/4HANA
on-premise system with version 2020 and can also be executed in
subsequent releases.
9.1    Description of the Use Case
Our sample application is supposed to manage certificates for
products. For example, this makes it possible to record that a
product has been awarded the Geprüfte Sicherheit (GS) ("Tested
Safety") mark or the CE mark of the European Union.
Furthermore, the certificates are stored in the SAP system via
document information records linked to the material. Versions can be
maintained for each material. For each version there’s a status
whereby you can directly recognize which is the active version. It
also allows you to quickly determine if a new version is already being
worked on. Active or inactive version states can no longer be
changed. When changes are made, a new version must be created.
At runtime, the system determines and displays in the application
whether a certificate attestation is stored in the associated document
information record. Each status change is logged within a database
table for status management. This means that it’s always clear who
made which changes and when.

In addition, the application provides a jump to the standard SAP Fiori
application, Manage Product Master.

9.2    Building the Data Model
To build an application using the ABAP RESTful application
programming model, the data model is essential. It’s based on the
database tables in which the data is kept persistently. Basic interface
views and CDS projection views are built on top of this.
In the following sections, we’ll describe the structure of this data
model for our sample application.
9.2.1    Database Tables
The data management of the application is done via two database
tables. In the first table, the certificate table ZBCA_CERTIFICATE, the
products are stored in versions with their status and an indicator for
the certificates received. Table 9.1 shows the structure of this table.
Column
Meaning
Key
Material Number
SAP material number
Yes
Version
Version of the certificate set for the
material
Yes
Status
Status (new, active, inactive)
No
CE Mark
CE mark exists
No
GS Mark
GS mark exists
No
FCC Certificate
FCC certificate exists
No
ISO Certificate
ISO certificate exists
No
TUEV Certificate
TUEV certificate exists
No

Column
Meaning
Key
Timestamp of Last
Change
Required for optimistic locking
No
Table 9.1     Certificate Table
In the second table, ZBCA_CERTI_STATE, all changes to the content of
the certificate table that result in status changes are recorded and
documented. The table structure is shown in Table 9.2.
Column
Meaning
Key
Material Number
SAP material number
Yes
Version
Version of the certificate set for the
material
Yes
Status
Status (new, active, inactive)
Yes
Status Old
Previous status
No
Modified By
Username last change
No
Changed On
Modification date
No
Changed At
Modification time
No
Timestamp of Last
Change
Required for optimistic locking.
No
Table 9.2     Certificate Status Table
To start development, you must have already created an ABAP
project in ABAP development tools (ADT) in Eclipse to connect to
your backend system. Then, you need to create the ABAP packages
in which you organize your development objects:
1. Open the ABAP perspective in ADT.

2. Open the context menu by right-clicking on your ABAP project
and select New • ABAP Package to create a new package
named ZRAP_DEMO (see Figure 9.1). Click the Next button.
Figure 9.1     Creating a New ABAP Package in ABAP Development Tools
3. Use HOME and a suitable transport layer as the software
component. Then include the package in a suitable transport
request or create a new one.
4. In the same way, create a second package named ZRAP_MANAGED
as a subpackage of ZRAP_DEMO. Then you’ll store all objects for
your first application based on the ABAP RESTful application
programming model in this package.
Now you can create the database tables:
1. Open the context menu and select New • Other • ABAP
Repository Object • ABAP Dictionary • Database Table.
2. Assign the ZRAP_MANAGED package to the table and name it
“ZBCA_CERTIFICATE” with the description “Manage

certificates.” Confirm the creation by clicking the Finish button.
3. After that, the table editor will display. In the table editor, you can
define the table in the same way as shown in Listing 9.1. The
missing Z data elements can be found in the download section
of this book at www.sap-press.com/5642.
@EndUserText.label : 'Manage certificates'
@AbapCatalog.enhancementCategory : #NOT_EXTENSIBLE
@AbapCatalog.tableCategory : #TRANSPARENT
@AbapCatalog.deliveryClass : #A
@AbapCatalog.dataMaintenance : #ALLOWED
define table zbca_certificate {
  key mandt             : abap.clnt not null;
  key cert_uuid         : sysuuid_x16 not null;
  matnr                 : matnr;
  version               : zbc_version;
  cert_status           : zbc_status;
  cert_ce               : zbc_ce;
  cert_gs               : zbc_gs;
  cert_fcc              : zbc_fcc;
  cert_iso              : zbc_iso;
  cert_tuev             : zbc_tuev;
  local_last_changed_at : timestampl;
} 
Listing 9.1     Definition of Database Table ZBCA_CERTIFICATE for Managing the
Certificates
4. Now, create the second database table (the same way you
created the first one) with the name “ZBCA_CERTI_STATE” and
the description “Manage certificates—status.” Listing 9.2 shows
the table definition in detail.
@EndUserText.label : 'Manage certificates—Status'
@AbapCatalog.enhancementCategory : #NOT_EXTENSIBLE
@AbapCatalog.tableCategory : #transparent
@AbapCatalog.deliveryClass : #A
@AbapCatalog.dataMaintenance : #ALLOWED
define table zbca_certi_state {
  key mandt             : abap.clnt not null;
  key state_uuid        : sysuuid_x16 not null;
  cert_uuid             : sysuuid_x16;
  matnr                 : matnr;
  version               : zbc_version;
  status                : zbc_status;
  status_old            : zbc_status;

  last_changed_by       : syuname;
  last_changed_at       : timestampl;
  local_last_changed_at : timestampl;
} 
Listing 9.2     Definition of Database Table ZBCA_CERTI_STATE for Status
Management
9.2.2    CDS Modeling
In the next step, you will build the CDS model that will influence the
behavior or the interface of your application based on it.
Basic Interface Views
First, you need to create the basic interface views for data retrieval:
1. Open the context menu of database table ZBCA_CERTIFICATE and
select New Data Definition (see Figure 9.2).
Figure 9.2     Creating a New CDS Entity
2. Assign “ZI_Certificate” as the name for the data definition and
“Certificate Management Interface View” as the description (see
Figure 9.3).

Figure 9.3     Maintaining the Data Definition of the CDS Entity
3. Now, you must use the Define View entity template (see
Figure 9.4) and not, as you saw in Chapter 2, Section 2.2.1, with
the Define View template. In the context of a RAP application,
you don’t need an ABAP dictionary view, so a view entity is
perfectly adequate here. Confirm your selection by clicking the
Finish button.

Figure 9.4     Selecting the Define View Entity Template
4. In the CDS editor, customize the view to read all fields from the
ZBCA_CERTIFICATE table. Then, adjust the field names as
shown in Listing 9.3.
@AbapCatalog.viewEnhancementCategory: [#NONE]
@AccessControl.authorizationCheck: #CHECK
@EndUserText.label: 'Certificate Management Interface View'
@Metadata.ignorePropagatedAnnotations: true
@ObjectModel.usageType:{
    serviceQuality: #X,
    sizeCategory: #S,
    dataClass: #MIXED
}
define view entity ZI_Certificate 
as select from zbca_certificate {
  key cert_uuid             as CertUUID,
      matnr                 as Material, 
      version               as Version, 
    cert_status as       CertificationStatus,
    cert_ce as CertificateCe,
    cert_gs as CertificateGs,
    cert_fcc as CertificateFcc,
    cert_iso as CertificateIso,
    cert_tuev as CertificateTuev
   @Semantics.systemDateTime.localInstanceLastChangedAt: true
    local_last_changed_at as LocalLastChangedAt,
} 

Listing 9.3     Basic Interface View for Certificate Management
[»]  Annotation for Optimistic Locking
By using the annotation
@Semantics.systemDateTime.localInstanceLastChangedAt: true
you define the subsequent field as the master field for optimistic
locking (ETag). The RAP framework automatically updates this
field at runtime.
5. In the define view statement, you must add the root keyword
and assign the Certificate alias for the view:
define root view entity ZI_Certificate
  as select from zbca_certificate as Certificate 
By using the root keyword you define the root node in the
composition hierarchy. This is necessary so that the hierarchy
can be mapped correctly in the data model.
6. Now, you must add an association to the material master text
and a composition to the CDS view for the certification status as
a specialization of the association (see Listing 9.4).
composition [0..*] of ZI_CertificateState as _CertificateState 
association [0..1] to I_MaterialText      as _MaterialText
on  $projection.Material = _MaterialText.Material
Listing 9.4     Complementing the Association and Composition
Do not activate the view yet! Before you do that, you must create the
CDS view ZI_CertificateState.
Next, you need to create another basic interface view for retrieving
data from the certificate status table. To do this, you must again
select the Define View Entity template. Use “ZI_CertificateState” as
the name for the view. As the first step, you must read all the fields

from the ZBCA_CERTI_STATE table and replace the field names as
shown in Listing 9.5.
@AbapCatalog.viewEnhancementCategory: [#NONE]
@AccessControl.authorizationCheck: #CHECK
@EndUserText.label: 'Certificate Management Status Interface View'
@Metadata.ignorePropagatedAnnotations: true
@ObjectModel.usageType:{
    serviceQuality: #X,
    sizeCategory: #S,
    dataClass: #MIXED
}
define view entity ZI_CertificateState
  as select from zbca_certi_state
{
  key state_uuid            as StateUUID,
      cert_uuid             as CertUUID,
      matnr                 as Material,
      version               as Version,
      status                as Status,
      status_old            as StatusOld,
@Semantics.user.lastChangedBy: true
      last_changed_by       as LastChangedBy,
@Semantics.systemDateTime.lastChangedAt: true
      last_changed_at       as LastChangedAt,
@Semantics.systemDateTime.localInstanceLastChangedAt: true
      local_last_changed_at as LocalLastChangedAt
}
Listing 9.5     Basic Interface View for the Certificate Statuses
You still need to add the alias _Certificate to the association to the
CDS view for certificate management. Use the association to parent.
Additionally, add the _Certificate association after the fields in the
CDS view to make the association visible to the outside world:
association to parent ZI_Certificate as _Certificate
on    $projection.Material = _Certificate.Material 
By using the to parent association, you define the view as a child
entity. In conjunction with the composition in the parent entity, the
view becomes the child entity of the business object.
You can find the final state of the two basic interface views in the
download material for this book. Now, you must activate the views

ZI_Certificate and ZI_CertificateState together.
Figure 9.5 shows the current state of the data model. The
ZI_Certificate view is the parent entity of the child entity
ZI_CertificateState. The parent entity also has an association to
the standard SAP view I_MaterialText to link information to the
material master.
Figure 9.5     Interim Status of the Data Model
CDS Projection View
In the next steps, you’ll define the CDS projection view to prepare
the elements determined so far for the SAP Fiori interface:
1. Open the context menu for the basic interface view
ZI_Certificate and select New Data Definition (see
Figure 9.6).
Figure 9.6     Creating a Data Definition for a CDS Projection View
2. Select the Define Projection View template (see Figure 9.7).

Figure 9.7     Selecting the Define Projection View Template
3. Assign the name “ZC_Certificate” and the description “Certificate
Management Projection View.”
4. Because the new CDS projection view was created with
reference to CDS interface view ZI_Certificate, all fields from this
basic interface view will automatically be taken over. Now, you
should extend the view in the header area with the annotations
from Listing 9.6. The @Search.searchable: true annotation
allows for searching across the columns specified for it using the
annotation, @Search.defaultSearchElement: true.
@EndUserText.label: 'Certificate Management Projection View'
@AccessControl.authorizationCheck: #CHECK
@Search.searchable: true
@Metadata.allowExtensions: true
define root view entity ZC_Certificate
  as projection on ZI_Certificate as Certificate
Listing 9.6     Extending CDS Projection View ZC_Certificate with a Search Function
5. Now you must add the annotations from Listing 9.7 to the view.
This means that a search help gets assigned to the Material
column via the basic interface view I_MaterialText from the
virtual data model for SAP S/4HANA. Furthermore, the Material

column is defined as the default search element. The
MaterialName column gets added as a new column. Its value is
determined from the association _MaterialText.
      @ObjectModel.text.element: ['MaterialName']
      @Consumption.valueHelpDefinition: [{
        entity: {
        name: 'I_MaterialText', 
        element: 'Material'} }]
      @Search.defaultSearchElement: true
  key Material,
  key Version,
      _MaterialText[Language = 'D'].Material as MaterialName,
Listing 9.7     Extending CDS Projection View ZC_Certificate with a Search Help for
Material Texts
6. Next, you want to add the addition redirected to composition
child to the association _CertificateState, as shown in the
following code, to map the parent-child relationship between the
two basic interface views in the CDS projection view as well:
/* Associations */
_CertificateState : redirected to composition child 
ZC_CertificateState, 
Do not activate the view yet!
Next, you must use a virtual element to read the basic data text from
the material master (text from transaction with ID GRUN). The use of
a virtual element is useful for this purpose since it allows the text to
be read easily via the READ_TEXT function block. In the CDS projection
view, you must integrate the element as a virtual column named
MaterialText (see Listing 9.8).
  @ObjectModel.readOnly: true 
  @ObjectModel.virtualElementCalculatedBy: 
                          'ABAP:ZCL_CERTI_SERVICE' 
    virtual MaterialText: text150, 
...
Listing 9.8     Integrating a Virtual Element in the CDS Projection View

[+]  Tip: More Use Cases for Virtual Elements
Virtual elements are a good way to populate individual columns
based on ABAP code without the need for explicit table access. In
addition to reading SO10 texts, a useful use case can be the
reading of document information records. Since SO10 texts can
have multiple lines, reading SO10 texts via the virtual element
could cause performance problems. For this reason, you should
always carefully consider whether the use of such an element
makes sense. In our example, the SO10 text always has a
maximum of one line. For more details on virtual elements, see
Chapter 2, Section 2.7.1.
The actual logic for data retrieval via the virtual element is
implemented in the ZCL_CERTI_SERVICE class within the method
if_sadl_exit_calc_element_read~calculate. In Listing 9.9, you can
see the main parts of the implementation.
  METHOD if_sadl_exit_calc_element_read~calculate.
...
      lv_id = 'GRUN'.
      lv_language = sy-langu.
      lv_name = <ls_calculated_data>-Material.
      lv_object = 'MATERIAL'.
 
      CALL FUNCTION 'READ_TEXT'
        EXPORTING
          id                      = lv_id
          language                = lv_language
          name                    = lv_name
          object                  = lv_object
        TABLES
          lines                   = lt_lines
        EXCEPTIONS
          id                      = 1
          language                = 2
          name                    = 3
          not_found               = 4
          object                  = 5
          reference_check         = 6
          wrong_access_to_archive = 7
          OTHERS                  = 8.

      IF sy-subrc = 0.
        LOOP AT lt_lines INTO DATA(ls_line).
          CONCATENATE <ls_calculated_data>-MaterialText 
             ls_line-tdline 
             INTO <ls_calculated_data>-MaterialText 
             SEPARATED BY space.
        ENDLOOP.
      ENDIF.
    ENDLOOP.
 
    MOVE-CORRESPONDING lt_calculated_data TO 
      ct_calculated_data.
... 
Listing 9.9     Implementing Data Retrieval via the Virtual Element
Now, you should create another CDS projection view that projects
the data from the basic interface view, ZI_CertificateState. Name
this view “ZC_CertificateState” and assign the description “Certificate
Management Status Projection View” to it. Then, add the annotation
@Metadata.allowExtensions: true in the header of the view definition
to the new CDS projection view. This will allow you to add
annotations for the design of the user interface at a later stage.
Extend the association to the ZC_Certificate view with the addition
redirected to parent to complete the parent-child relationship
between the CDS projection views:
/* Associations */
_Certificate: redirected to parent ZC_Certificate 
The two complete CDS projection views can also be found in the
download material for this book.
Activate the two views ZC_Certificate and ZC_CertificateState
together.
Now you have implemented all three levels of the data model from
Figure 9.5. In the next section, you’ll create the behavior definitions
for the CDS views you created earlier, laying the foundation for the
SAP Fiori app business service.

9.3    Creating Behavior Definitions
In this section, you’ll implement the basic business logic and
transactional features of the sample application. We’ll enable the
create, update, and delete functions. These functions don’t need to
be implemented, only enabled, since their implementation in the
managed scenario is handled by the RAP framework.
9.3.1    Creating Behavior Definitions for Certificate
Management
Once the data model has been mapped in the CDS view, the next
step consists of preparing the transactional properties of the future
app. In the context of the behavior definitions, you enable the create,
update, and delete functions.
1. First, you must create the behavior definition for the basic
interface view ZI_Cerfiticate.
2. Open the context menu for the basic interface view
ZI_Certificate and select New Behavior Definition (see
Figure 9.8).

Figure 9.8     Creating a New Behavior Definition
3. Make sure that Managed is selected as the implementation type
and assign a descriptive name to the behavior definition. Then,
click the Next button.
Figure 9.9     Creating a Behavior Definition with the Managed Implementation Type

4. In the screen that follows, you need to assign the object to a
suitable transport request and close the creation wizard by
clicking the Finish button.
Figure 9.10 shows how the basic structure of the behavior definition
is created by the template.
At the very beginning of the definition you can see the
implementation type managed. After the define behavior for keyword,
the selected basic interface view is named ZI_Certificate. Further
down you can see a block for basic interface view
ZI_CertificateState. This is automatically created this way because
of the parent-child relationship defined for the two CDS views.
The create, update and delete functions have already been defined.
In the behavior definition for the ZI_CertificateState view, only the
update and delete actions are created since the defined parent-child
relationship for each entry in the ZI_CertificateState view there
must always be an entry in the ZI_Certificate view first. The
framework recognizes this and therefore doesn’t provide a create
function at this point. Instead, the creation of a new entry is done
using the create-by-association operation.

Figure 9.10     Generated Source Code of the Behavior Definition
Furthermore, you can see numerous sections of code in Figure 9.10
that have been commented out. For the coding sections relevant to
this example, we’ll gradually remove the comment characters and
add the active code in the next steps:
1. In line 3, in the define behavior for statement, you should add
the Certificate alias for the ZI_Certificate view. Then, after
the persistent table statement, you want to store the database
table, ZBCA_CERTIFICATE.
2. Remove the comment characters in the lock master block to
enable lock management.
3. After etag master, you want to add the LocalLastChangedAt
column and remove the comment characters in this line. This
command activates optimistic locking (see Chapter 3,
Section 3.12).
Since you’ve provided each of the field names from the database
table with a meaningful alias as part of the CDS views, you must

next maintain a mapping between the fields of the CDS view and
those of the database table. Listing 9.10 shows what the behavior
definition looks like at this point.
managed; // implementation in class zbp_i_certificate unique;
 
define behavior for ZI_Certificate alias Certificate
persistent table zbca_certificate
lock master total etag LocalLastChangedAt
//authorization master ( instance )
etag master LocalLastChangedAt
{
  create;
  update;
  delete;
  association _CertificateState { create; }
 
  field ( numbering : managed, readonly ) CertUUID;
  field ( readonly ) MaterialText;
  field ( mandatory ) Material;
 
  mapping for zbca_certificate
  {
    Material = matnr;
    Version = version;
    CertificationStatus = cert_status;
    CertificateCe = cert_ce;
    CertificateGs = cert_gs;
    CertificateFcc = cert_fcc;
    CertificateIso = cert_iso;
    CertificateTuev = cert_tuev;
    LocalLastChangedAt = local_last_changed_at;
  }
}
 
define behavior for ZI_CertificateState alias CertificateState
persistent table zbca_certi_state
lock dependent by _Certificate
etag master LocalLastChangedAt
{
 
  association _Certificate;
 
  delete;
 
  field ( numbering : managed, readonly ) StateUUID;
  field ( readonly ) CertUUID;
 
  mapping for zbca_certi_state
  {
    StateUUID = state_uuid;
    CertUUID  = cert_uuid;

    Material = matnr;
    Version = version;
    Status = status;
    StatusOld = status_old;
    LastChangedBy = last_changed_by;
    LastChangedAt = last_changed_at;
    LocalLastChangedAt = local_last_changed_at;
  }
 
} ... 
Listing 9.10     Interim Status of the ZI_Certificate Behavior Definition
[»]  Mapping Between CDS View and Database Table
Columns created via a virtual element don’t need to be listed for a
mapping between a CDS view and database table, because these
columns aren’t contained in the database table. Only those
columns are assigned that also have a reference to the database
table.
Next, you want to set access restrictions for some fields to ensure
data consistency. It shouldn’t be possible to change the key field
CertUUID via the application. This field is assigned a unique ID by the
RAP framework. You can obtain the ID via the field command:
field ( numbering : managed, readonly ) StateUUID
   field ( readonly ) CertUUID 
You use the commands field ( readonly ) and field ( mandatory )
to specify that the MaterialText field (the virtual element with the
basic data text) can’t be changed and that a material number must
be maintained.
Repeat the previous steps to create the behavior definition for the
ZC_Certificate entity in the same way as you did for the
ZI_Certificate entity. Before you activate the behavior definition for
the ZC_Certificate entity, you must already have defined the

behavior definition for ZI_Certificate. Then, you can apply the new
behavior definition as it was generated.
In the CDS data model, the two basic interface views ZI_Certificate
and ZI_CertificateState are connected via a composition. For this
reason, as part of the behavior definition for the ZI_Certificate view,
the behavior definition for the ZI_CertificateState entity must also
be created. It can look the same as that of the ZI_Certificate view,
but here you only activate the function for deleting. It shouldn’t be
possible to change this CDS entity via the application; the creation of
new instances is controlled by the root entity.
9.3.2    Enabling Draft Handling
In this section, you’ll enable draft handling for your application. To do
so, proceed as follows:
1. You should add the with draft command to the behavior
definition for the ZI_Certificate view in line 2 (see Figure 9.11).
This addition enables draft handling.
Figure 9.11     Enabling Draft Handling
2. To use it, you need to assign a draft table in the next step. For
this purpose, you should insert a new line after the persistent
table zbca_certificate line and add the following command:
draft table zbcd_certificate 
This command sets the name of the draft table. However, the
draft table zbcd_certificate hasn’t been created yet. We’ll show

you how to do this in the following.
3. Next, you must add the with draft addition to the association for
the _CertificateState status table:
association _CertificateState { create; with draft; } 
The easiest way to create a draft table is to use the quick fix function
in Eclipse. To do this, position the cursor on the table name and
press the key combination (Ctrl) + (1) (see Figure 9.12).
Figure 9.12     Creating a Draft Table
The draft table will now be created with the structure from
Listing 9.11. Add the text “Draft table ZBCA_CERTIFICATE” as the
table description and activate the table.
@EndUserText.label : 'Draft table ZBCA_CERTIFICATE'
@AbapCatalog.enhancementCategory : #EXTENSIBLE_ANY
@AbapCatalog.tableCategory : #TRANSPARENT
@AbapCatalog.deliveryClass : #A
@AbapCatalog.dataMaintenance : #RESTRICTED
define table zbcd_certificate {
  key mandt           : mandt not null;
  key certuuid        : sysuuid_x16 not null;
  material            : matnr;
  version             : zbc_version;
  certificationstatus : zbc_status;
  statustext          : val_text;
  certificatece       : zbc_ce;
  certificategs       : zbc_gs;
  certificatefcc      : zbc_fcc;
  certificateiso      : zbc_iso;
  certificatetuev     : zbc_tuev;
  locallastchangedat  : timestampl;
  criticality         : abap.int1;
  materialtext        : abap.char(250);
  "%admin"            : include sych_bdl_draft_admin_inc;

 
}
Listing 9.11     Structure of the ZBCA_CERTIFICATE Draft Table
The final state of the linked behavior definitions can also be found in
the download material for this book. You can now activate the
behavior definitions.

9.4    Defining a Business Service
In this section, we’ll show you how to define, register in the system,
and test the business service for the sample application.
The ABAP platform can act as both a service provider and a service
consumer. That is, it can both call and consume a service and
provide it to other applications. In the ABAP RESTFul application
programming model, the business service is a REST-based service
provided for consumption. It therefore acts as a service provider.
Through the business service, the data model defined in Section 9.2
and the behavior defined in Section 9.3, are provided to the caller of
the service. This service consumer will be the SAP Fiori elements
application created in Section 9.5.
As described in Chapter 6, the business service consists of a service
definition and a service binding. Let’s now create these two
components for our application.
9.4.1    Creating a Service Definition
First, you need to create the service definition as follows:
1. Open the context menu for the CDS projection view
ZC_CERTIFICATE of the certificate management and select the
entry New Service Definition (see Figure 9.13).

Figure 9.13     Creating a New Service Definition
2. Name the service definition “ZUI_Certificate_U” and assign a
meaningful description to it (see Figure 9.14).
Figure 9.14     Assigning a Name and Description to the Service Definition
3. In the screen that follows next, you need to select the Define
Service template (see Figure 9.15). Confirm the creation by
clicking the Finish button.

Figure 9.15     Selecting the Define Service Template
Now you must define the entities of the service definition by making
the CDS views of the relevant entities known using the expose
keyword. In our concrete case, you need to make the CDS views
ZC_Certificate and ZC_Certificatestate known in this way. You
don’t have to publish the _MaterialText entity, which is linked by
association, because it’s only used for displaying the material
description and later as a search aid for materials. Optionally, you
can also assign alias names at this point to facilitate using the
service.
The service definition now has the structure shown in Listing 9.12.
@EndUserText.label: 'Service Definition for manage Certificates'
define service ZUI_Certificate {
  expose ZC_Certificate as Certificate;
  expose ZC_CertificateState as CertificateState;
  expose I_MaterialText as Material_VH;
  expose ZI_Status_VH as Status_VH;
}
Listing 9.12     Service Definition for Certificate Management
Save and enable this service definition.
9.4.2    Creating the Service Binding

Next, you need to create the service binding. Here you define which
OData you use based on the binding type:
1. Open the context menu for the service definition you just created
and select the New Service Binding entry (see Figure 9.16).
Figure 9.16     Creating a New Service Binding
2. Since the service is supposed to be used later as part of an SAP
Fiori application, you want to select the OData V2 - UI option in
the Binding Type field. Name the service binding
“ZUI_Certificate_ODATA_O2” and assign a meaningful
description to it (see Figure 9.17).
Figure 9.17     Creating the Service Binding
3. Click the Next button to create the service binding.

You can use the Publish button to publish the service binding (see
Figure 9.18). This enables the local service endpoint for the OData
service. Now your newly created OData service can be consumed.
Figure 9.18     Publishing the Service Binding
As part of the service binding, you can also launch a preview of the
SAP Fiori elements application. To do this, you must select the
desired root entity, here the entity with the Certificate alias, and
click the Preview button (see Figure 9.19).
Figure 9.19     Launching the SAP Fiori Elements Preview via the Service Binding
Because you haven’t defined any UI annotations yet, the preview
currently remains empty. In the next section, we’ll assign the UI
annotations and then we can test the user interface for the first time.

9.5    Creating an SAP Fiori Elements User
Interface
In the previous sections, you defined the CDS data model for your
application. In this section, you’ll extend this data model with UI
annotations and generate an SAP Fiori elements application based
on it. The purpose of UI annotations is to define usage patterns for
data in the user interface independent of UI technology. SAP Fiori
elements interprets the UI annotations and implements them in the
user interface. Some UI annotations are used by different SAP Fiori
elements floorplans in the process.
First, you need to create a new metadata extension for the UI
annotations:
1. Open the context menu for CDS projection view ZC_CERTIFICATE
of the certificate management and select New Metadata
Extension (see Figure 9.20).
2. Name the metadata extension “ZC_CERTIFICATE” and assign a
meaningful description to it. You can use Figure 9.21 as a guide.
Figure 9.20     Creating a Metadata Extension for the User Interface

Figure 9.21     Maintaining a Name and Description for the Metadata Extension
3. Use the Annotate View template (see Figure 9.22) and confirm
the creation by clicking the Finish button.
Figure 9.22     Selecting the Annotate View Template
You should use the #CORE value for the @Metadata.layer annotation
because it’s your own application.
@Metadata.layer: #CORE 
[»]  Metadata Layers

The metadata is hierarchically structured on several layers, with
some layers overshadowing less relevant ones. The following
layers exist (with ascending priority):
#CORE: Use on the ABAP platform or custom application. It can
be overridden customer-specifically, if required.
#LOCALIZATION: Use of an SAP application component
#INDUSTRY: SAP industry solution
#PARTNER: SAP partner application
#CUSTOMER: SAP customer application
Using the annotation @UI.facet you can structure the displayed fields
on the object page and group them into areas (facets). First, you
need to define a facet for the object page header using the
annotation @UI.facet.purpose : #HEADER. Use the @UI.facet.type:
#FIELDGROUP_REFERENCE annotation to set the type as a field group.
Then assign the facet position 1. Add a meaningful description and
the header data qualifier as the ID (see Listing 9.13).
@UI.facet: [
              /* Header Data */
            {
              purpose:    #HEADER,
              type:       #FIELDGROUP_REFERENCE,
              importance: #HIGH,
              position:   1,
              label:      'Technical data',
              targetQualifier: 'Header data'
            } ] 
Listing 9.13     Defining User Interface Areas in the Object Page Header
You should then define additional UI areas to display certificate data,
details, and status changes (see Listing 9.14). For the status
changes, define a table to be output on the object page. You can do
this via the #LINEITEM_REFERENCE annotation value.

{ id:              'Certificate',
   purpose:         #STANDARD,
   type:            #IDENTIFICATION_REFERENCE,
   label:           'Certificate management',
   position:        10 },
{
   purpose:    #STANDARD,
   type:       #FIELDGROUP_REFERENCE,
   importance: #HIGH,
   position:   20,
   targetQualifier: 'Detail',
   label: 'Detail info'
},
{ id:              'CertificateState',
  purpose:         #STANDARD,
  type:            #LINEITEM_REFERENCE,
  label:           'Status changes',
  position:        30,
  targetElement:   '_CertificateState' 
Listing 9.14     Defining User Interface Areas in the Content Area of the Object Page
Hide the key field CertUUID and the technical helper variable
LocalLastChangedAt in the UI via the annotation @UI.hidden: true.
These fields have purely technical meaning, so it isn’t necessary to
display them in the user interface.
Use the UI annotations UI.lineItem, UI.identification,
UI.fieldGroup, and UI.selectionField in a way that makes sense to
show each field as you need it in the application. They are described
in Chapter 7, Section 7.2.2.
Now you can activate your metadata extension. It could look like the
one shown in Listing 9.15.
@Metadata.layer: #CORE
@UI: {
  headerInfo: { typeName: 'Certificate management',
                typeNamePlural: 'Zertifikate',
                title: { type: #STANDARD, label: 
                'Certificates', value: 'Material' } },
  presentationVariant: [{ sortOrder: [{ by: 'Material',
   direction:  #DESC }] }] }
 
annotate view ZC_Certificate with
{

  @UI.facet: [
                /* Header Data */
              {
                purpose:    #HEADER,
                type:       #FIELDGROUP_REFERENCE,
                importance: #HIGH,
                position:   1,
                label:      'Technical data',
                targetQualifier: 'Header data'
              },
 
              { id:              'Certificate',
                 purpose:         #STANDARD,
                 type:            #IDENTIFICATION_REFERENCE,
                 label:           'Certificate management',
                 position:        10 },
              {
                 purpose:    #STANDARD,
                 type:       #FIELDGROUP_REFERENCE,
                 importance: #HIGH,
                 position:   20,
                 targetQualifier: 'Detail',
                 label: 'Detail info'
              },
              { id:              'CertificateState',
                purpose:         #STANDARD,
                type:            #LINEITEM_REFERENCE,
                label:           'Status changes',
                position:        30,
                targetElement:   '_CertificateState'
              } ]
 
  @UI.hidden: true
  CertUUID;
 
  @UI: {  lineItem:       [ { position: 10 } ],
          identification: [ { position: 10 } ],
          selectionField: [ { position: 10 } ] }
  Material;
  @UI: {  lineItem:       [ { 
          position: 20, label : 'material name' } ],
          identification: [ { position: 20 } ]
}
  MaterialName;
  @UI: {  lineItem:       [ { position: 30 }  ],
         fieldGroup: [ { 
             qualifier: 'header data',position: 30 ],
          selectionField: [ { position: 30 } ]}
  Version;
  @UI: {  lineItem:       [ { 
      position: 40, 
      criticality: 'Criticality', 
      label: 'Status' } ],
          fieldGroup: [ { 

            qualifier: 'Header data',
            position: 40, 
            label: 'Status', 
            criticality: 'Criticality' }  ],
          selectionField: [ { position: 40 } ] }
  StatusText;
 
  @UI: {  lineItem:       [ { position: 50 } ],
          identification: [ { position: 50 } ] }
  CertificateCe;
  @UI: {  lineItem:       [ { position: 60 } ],
          identification: [ { position: 60 } ] }
  CertificateGs;
  @UI: {  lineItem:       [ { position: 70 } ],
          identification: [ { position: 70 } ] }
  CertificateFcc;
  @UI: {  lineItem:       [ { position: 80 } ],
          identification: [ { position: 80 } ] }
  CertificateIso;
  @UI: {  lineItem:       [ { position: 90 } ],
          identification: [ { position: 90 } ] }
  CertificateTuev;
  @UI.fieldGroup: [ { qualifier: 'Detail',position: 10 }  ]
  MaterialText;
 
  @UI.hidden: true
  LocalLastChangedAt;
} 
Listing 9.15     Metadata Extension for the ZC_Certificate View
Now you should define a metadata extension with meaningful UI
annotations for CDS projection view ZI_CertificateState of the
certificate status in the same way. In Listing 9.14, a user interface
area for the certificate status of type #LINEITEM_REFERENCE was
created (i.e., a table). Now use the UI.lineItem annotation to
populate this area with data. In Listing 9.16, you can see how the
certificate status metadata extension might look like. Enable this
metadata extension as well.
@Metadata.layer: #CORE
@UI: {
  headerInfo: { typeName: 'Status',
                typeNamePlural: 'Status',
                title: { type: #STANDARD, label: 'Status', 
                         value: 'Status' } } }
annotate view ZC_CertificateState with

{
 
  @UI.facet: [ { id:            'Status',
                 purpose:       #STANDARD,
                 type:          #IDENTIFICATION_REFERENCE
                 }  ]
  @UI.hidden: true
  StateUUID;
  @UI.hidden: true
  CertUUID;
  @UI.hidden: true
  Material;
  @UI: { lineItem:       [ { position: 10 } ],
         identification: [ { position: 10 } ] }
  Version;
  @UI: { lineItem:       [ { position: 20 } ],
         identification: [ { position: 20 } ] }
  Status;
  @UI: { lineItem:       [ { position: 30, 
                          label: 'previous status' } ],
         identification: [ { position: 30, 
                          label: 'previous status' } ] }
  StatusOld;
  @UI: { lineItem:       [ { position: 40, 
                        label: 'last changed by' } ],
         identification: [ { position: 40, 
                        label: 'last changed by' } ] }
  LastChangedBy;
  @UI: { lineItem:       [ { position: }                    /* 50 */ 
                          label: 'last changed' } ],
         identification: [ { position: }                    /* 50 */ 
                          label: 'last changed' } ] }
  LastChangedAt;
  @UI.hidden: true
  LocalLastChangedAt;
} 
Listing 9.16     Metadata Extension for the ZC_CertificateState View
Now you can use the SAP Fiori elements application preview to test
the interfaces generated on the basis of the metadata extensions.
Depending on the UI annotations you use, the preview should look
like the one shown in Figure 9.23 and Figure 9.24.

Figure 9.23     Preview of the List Report
Figure 9.24     Preview of the Object Page

9.6    Enrichment with a Determination
In this section, we’ll describe how you can define and implement a
determination to trigger a follow-up action or side effect depending
on the current entity. A typical use case for a determination involves,
for example, updating the total price at header level when a price
change is made at item level. In our concrete example, a
determination is supposed to set the certificate status to “01” (= new)
and the version to “00001” when a new entry gets created in the
certificate management. In addition, an initial record is to be written
to the certificate status table.
To implement this behavior, you must double-click on the
ZI_Certificate view to open the behavior definition. You can either
define the behavior implementation for all entities contained in the
behavior definition together in one class or create a separate ABAP
class for each entity in the behavior definition. To keep the behavior
implementation clearer, we recommend that you create an
implementation class for each entity.
To do this, you want to move the generated, commented-out code for
specifying the implementation class implementation in class
zbp_i_certificate unique from the header area of the behavior
definition (see Listing 9.10) to the definition area of the
ZI_Certificate entity (see Figure 9.25).

Figure 9.25     Behavior Definition for an Entity
Next, you must add a setInitialValues determination with the
following parameters:
determination setInitialValues on modify { create; } 
Due to these specifications, the determination will only be run in
creation mode. It can be triggered by any field of the entity.
Alternatively, the determination via the keyword field could also be
defined in such a way that it will only be triggered when individual
fields are changed.
Create the implementation class using the quick fix feature in ADT
by clicking the light bulb icon next to the newly inserted line (see
Figure 9.26).
Figure 9.26     Creating the Implementation Class for the Behavior Implementation

The generated class includes a local class with the methods
SetInitialValues for determination and get_features for dynamic
field control of each instance. The return structure of the
get_features method contains the key and data of the requested
instance. Listing 9.17 shows the initial structure of the
implementation class.
CLASS lhc_certificate DEFINITION INHERITING FROM cl_abap_behavior_handler.
  PRIVATE SECTION.
 
    METHODS setinitialvalues FOR DETERMINE ON MODIFY
      IMPORTING keys FOR certificate~setinitialvalues.
 
    METHODS get_features FOR FEATURES
      IMPORTING keys REQUEST requested_features FOR certificate RESULT result.
 
ENDCLASS.
 
CLASS lhc_certificate IMPLEMENTATION.
 
  METHOD setinitialvalues.
  ENDMETHOD.
 
  METHOD get_features.
  ENDMETHOD.
 
ENDCLASS. 
Listing 9.17     Initial Structure of the Implementation Class
Complete the get_features method by reading the entry of the
ZI_Certificate entity for which the key was passed to the method.
Use the EML instruction READ ENTITIES for this purpose. Then pass
the determined record to the return structure result (see
Listing 9.18).
READ ENTITIES OF ZI_Certificate IN LOCAL MODE
  ENTITY Certificate
    ALL FIELDS WITH CORRESPONDING #( keys )
  RESULT DATA(certificates).
 
result = VALUE #( FOR Certificate IN certificates
                    ( %tky   = Certificate-%tky
                      ) ). 

Listing 9.18     Implementation of the get_features Method
Next, you want to implement the setInitialValues method. It should
always be run when a new entry gets created, as you’ve ensured in
the behavior definition. Use the EML statement READ ENTITIES to
determine the entry for the ZI_Certificate entity matching the keys
parameter. Update the field named Version with the value “00001”
and assign the value “01” (= new) for the certificate status. For this
operation, you must use the EML statement MODIFY ENTITIES OF.
Next, you should create an entry for the certificate status. To do this,
use the EML statement MODIFY ENTITIES OF with the addition CREATE
BY \assoc_name. This allows you to access the association defined in
the data model and specified in the behavior definition to create an
entry for the ZI_CertificateState entity.
The setInitialValues method now ensures that the new entry in the
certificate table has the version 00001 and the status “new” when an
entry is saved via the application. In addition, an initial certificate
status record is created. In Listing 9.19, you can see the complete
structure of the setInitialValues method.
METHOD setInitialvalues.
 
  DATA lt_CertificateState 
    TYPE TABLE FOR CREATE 
    zi_certificate\_CertificateState.
  DATA ls_CertificateState 
    LIKE LINE OF lt_CertificateState.
  DATA ls_CertificateStateValue 
    LIKE LINE OF ls_certificatestate-%target.
 
  READ ENTITIES OF zi_certificate IN LOCAL MODE
  ENTITY certificate
  FIELDS ( certificationstatus ) 
    WITH CORRESPONDING #( keys )
  RESULT DATA(certificates).
 
  IF certificates IS NOT INITIAL.
    MODIFY ENTITIES OF zi_certificate IN LOCAL MODE
    ENTITY certificate
    UPDATE

    FIELDS ( version certificationstatus )
    WITH VALUE #( FOR certificate IN certificates
                    ( %tky = certificate-%key
                      version = '00001'
                      certificationstatus = '01' " neu
                     )
     ) REPORTED DATA(ls_return).
  ENDIF.
 
  LOOP AT certificates INTO DATA(ls_certificate).
 
    ls_CertificateState-%key = ls_certificate-%key.
    ls_CertificateState-CertUUID = 
    ls_certificatestatevalue-CertUUID = 
    ls_certificate-CertUUID.
 
    ls_certificatestatevalue-Status = '01'.
    CLEAR ls_certificatestatevalue-StatusOld.
    ls_certificatestatevalue-Version = '01'.
 
    ls_certificatestatevalue-%control-CertUUID = 
           if_abap_behv=>mk-on.
    ls_certificatestatevalue-%control-Status = 
           if_abap_behv=>mk-on.
    ls_certificatestatevalue-%control-StatusOld = 
           if_abap_behv=>mk-on.
    ls_certificatestatevalue-%control-Version = 
           if_abap_behv=>mk-on.
    ls_certificatestatevalue-%control-LastChangedAt = 
           if_abap_behv=>mk-on.
    ls_certificatestatevalue-%control-LastChangedBy = 
           if_abap_behv=>mk-on.
    APPEND ls_certificatestatevalue 
           TO ls_certificatestate-%target. 
 
    APPEND ls_certificatestate TO lt_certificatestate.
 
    MODIFY ENTITIES OF zi_certificate IN LOCAL MODE
    ENTITY certificate
      CREATE BY \_CertificateState
      FROM lt_CertificateState
          REPORTED DATA(ls_return_ass)
          MAPPED DATA(ls_mapped_ass)
          FAILED  DATA(ls_failed_ass).
 
  ENDLOOP.
 
ENDMETHOD. 
Listing 9.19     Implementation of the Determination in the setInitialValues Method
Finally, you need to save and activate your implementation class.

9.7    Enrichment with a Validation
Next, we want to use a validation to check user input and respond
with an error message if necessary. The purpose of our validation is
to check whether the entered material number belongs to an existing
material. If the material can’t be found, an error message is
supposed to be issued and the saving of the data is to be prevented.
As with determinations, validations require a definition and an
implementation. As you learned in Chapter 5, Section 5.4.10, when
implementing a validation, you use messages that are triggered in an
exception class. These messages are based on the classic message
classes. Thus, in the following steps, you’ll create a message class
and an exception class as part of the validation implementation.
In the first step, you add the validation to the behavior definition of
the ZI_Certificate entity. For this purpose, you want to open the
behavior definition by double-clicking on it. Then, define a validation
called checkMaterial to verify the input of the material number. It’s to
be run through when the input gets saved:
validation checkMaterial on save { field Material; create; update; }. 
With this you have created the definition of the validation. Before
proceeding with its implementation, you must create a message
class and the exception class. This is the only way to respond to
error situations with an error message as part of the implementation.
You can create a new message class as follows:
1. Right-click on your development package and select New •
Other ABAP Repositiory Object (see Figure 9.27).

Figure 9.27     Creating a New Message Class
2. In the screen that follows, you want to select the Message
Class template (see Figure 9.28).
Figure 9.28     Selecting the Message Class Template
3. Then use “Z_CERTIFICATE_MSG” as the name of the message
class and assign a meaningful description in the screen that
displays next. Confirm the creation by clicking the Finish button.
Having created the message class, you need to create two
messages in it. You must open the view from Figure 9.29. The first
message consists exclusively of variables that are populated
dynamically at runtime. The second message is specific to unknown
material numbers.

Figure 9.29     Creating the Messages
Next, you need to create an exception class named ZCX_CERTIFICATE.
Implement the exception class as shown in Listing 9.20. In the
exception class, the previously created message for unknown
material numbers from your message class will be included. You can
call it in the subsequent implementation of the validation.
CLASS zcx_certificate DEFINITION
  PUBLIC
  INHERITING FROM cx_static_check
  FINAL
  CREATE PUBLIC.
 
  PUBLIC SECTION.
 
    INTERFACES if_abap_behv_message.
    INTERFACES if_t100_dyn_msg.
    INTERFACES if_t100_message.
 
    CONSTANTS:
      BEGIN OF material_unknown,
        msgid TYPE symsgid VALUE 'Z_CERTIFICATE_MSG',
        msgno TYPE symsgno VALUE '001',
        attr1 TYPE scx_attrname VALUE 'MATERIAL',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF material_unknown.
 
    METHODS constructor
      IMPORTING
        severity TYPE if_abap_behv_message=>t_severity DEFAULT 
if_abap_behv_message=>severity-error

        textid   LIKE if_t100_message=>t100key OPTIONAL
        previous TYPE REF TO cx_root OPTIONAL
        material TYPE matnr OPTIONAL.
 
    DATA  material  TYPE matnr READ-ONLY.
 
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.
 
CLASS zcx_certificate IMPLEMENTATION.
 
  METHOD constructor ##ADT_SUPPRESS_GENERATION.
    CALL METHOD super->constructor
      EXPORTING
        previous = previous.
    CLEAR me->textid.
    IF textid IS INITIAL.
      if_t100_message~t100key = 
        if_t100_message=>default_textid.
    ELSE.
      if_t100_message~t100key = textid.
    ENDIF.
 
    me->if_abap_behv_message~m_severity = severity.
    me->material = |{ material ALPHA = OUT }|.
  ENDMETHOD.
ENDCLASS. 
Listing 9.20     The ZCX_CERTIFICATE Exception Class
Now open the ZBP_I_CERTIFICATE class you created in the previous
section with your behavior implementation by double-clicking it and
switch to the local class where you already created the determination
in the previous section. In the definition part of the class, you should
add the checkmaterial method from the behavior definition using the
quick fix function:
METHODS checkmaterial FOR VALIDATE ON SAVE
  IMPORTING keys FOR certificate~checkmaterial. 
In the final step, you must implement the logic for the checkmaterial
method (see Listing 9.21). In this method, you use the EML
statement READ ENTITIES again to determine the current entry of the
ZI_Certificate entity. Using this data record, you check in a SELECT

statement whether there’s an entry in the MARA table for the current
material number. If that’s not the case, you must raise the exception
for an unknown material you defined earlier in your exception class.
METHOD checkmaterial.
 
  READ ENTITIES OF zi_certificate IN LOCAL MODE
  ENTITY certificate
  ALL FIELDS WITH CORRESPONDING #( keys )
  RESULT DATA(certificates).
 
  IF certificates IS NOT INITIAL.
    LOOP AT certificates INTO DATA(certificate).
 
      SELECT SINGLE FROM mara FIELDS matnr
        WHERE matnr = @certificate-material
        INTO @DATA(ls_mara).
 
      IF sy-subrc <> 0.
 
        APPEND VALUE #( %tky = certificate-%tky ) 
          TO failed-certificate.
 
        APPEND # VALUE( %tky        = certificate-%tky
                        %state_area = 'MATERIAL_UNKNOWN'
                        %msg        = NEW zcx_certificate(
                        severity = 
                  if_abap_behv_message=>severity-error
                        textid   = 
                  zcx_certificate=>material_unknown
                        material = certificate-material )
                      )
          TO reported-certificate.
 
      ENDIF.
 
    ENDLOOP.
 
  ENDIF.
ENDMETHOD. 
Listing 9.21     Implementation of the checkmaterial Validation
Finally, you need to save and activate your implementation class.

9.8    Enrichment with an Action
In this section, we’ll create three actions to perform status changes
for each certificate record and update the information to the
database table for the certificate status. Specifically, this involves
creating a new version of a certificate, activating the certificate or
deactivating a certificate. To be able to perform the actions in the
application, we’ll provide a new button in the SAP Fiori user interface
for each action.
First, you must adjust the behavior definition accordingly. To do this,
open the behavior definition for the ZI_Certificate entity by double-
clicking on it. Define three actions here: create new version; release
version; and deactivate or archive version. The actions should return
an instance of the respective object as a return parameter (see
Listing 9.22).
action ( features : instance ) 
    newVersion result [1] $self;
action ( features : instance ) 
    releaseVersion result [1] $self;
action ( features : instance ) 
    archiveVersion result [1] $self; 
Listing 9.22     Definition of the Actions
Next, double-click to open your behavior implementation in the
ZBP_I_CERTIFICATE class and switch to the local class where you
already created the determination and validation in the previous
sections. Add the newVersion, releaseVersion and archiveVersion
methods from the behavior definition via the quick fix function (see
Listing 9.23).
METHODS newversion FOR MODIFY
       IMPORTING keys FOR ACTION certificate~newVersion 
       RESULT result.

METHODS releaseversion FOR MODIFY
       IMPORTING keys FOR ACTION certificate~releaseversion 
       RESULT result.
METHODS archiveversion FOR MODIFY
       IMPORTING keys FOR ACTION certificate~archiveversion 
       RESULT result. 
Listing 9.23     Definition of the Methods for the Actions
In the following step, you need to implement the logic for the
newVersion method. The purpose of this method is to create a new
version for the certificate entry marked in the list report (i.e., the
version number from the ZI_Certificate entity is increased by 1). In
addition, a new entry is to be created in the ZI_CertificateState
view to map the history of versions.
To determine the certificate entry currently marked in the list report,
you must use the EML statement, READ ENTITIES (see Listing 9.24).
READ ENTITIES OF zi_certificate IN LOCAL MODE
ENTITY certificate
ALL FIELDS WITH CORRESPONDING #( keys )
RESULT DATA(certificates). 
Listing 9.24     EML Statement for Determining the Marked Line
Having increased the version of the certificate by 1, you should
modify the record using the EML statement MODIFY ENTITIES (see
Listing 9.25). You also need to set the status to 01 (= new).
MODIFY ENTITIES OF zi_certificate IN LOCAL MODE 
  ENTITY Certificate
     UPDATE
       FIELDS ( Version CertificationStatus )
       WITH VALUE #( FOR key IN keys
                       ( %tky    = key-%tky 
                         Version = ls_certificate-Version
                         CertificationStatus = 
                       ls_certificate-CertificationStatus ) 
                   )
  FAILED failed
  REPORTED reported. 
Listing 9.25     EML Statement to Change a Line

In the final step, you must create a new status record in the
ZI_CertificateState view. To do this, use the EML statement MODIFY
ENTITIES with the addition CREATE BY \assoc, as shown in Listing 9.26.
MODIFY ENTITIES OF zi_certificate IN LOCAL MODE
ENTITY certificate
  CREATE BY \_CertificateState
  FROM lt_CertificateState
      REPORTED DATA(ls_return_ass)
      MAPPED DATA(ls_mapped_ass)
      FAILED  DATA(ls_failed_ass). 
Listing 9.26     EML Statement for Creating a Line via an Association
You can find the complete implementation of the newVersion method
in the implementation class we provide in the download material of
this book.
You can implement the methods releaseVersion and archiveVersion
in a manner similar to the newVersion method. Here, you need to set
the status to 02 (= active) or 03 (= inactive) and again write a status
record. Finally, you must save and activate your class.

9.9    Generation and Deployment of the
Application
In the previous sections, you have fully implemented the backend
service of your application. In this section, you’ll now learn how to
create an application based on the SAP Fiori elements floorplan list
report using this business service. To do this, we use the SAP Fiori
tools plug-in for Visual Studio Code. We’ll then deploy this app as a
Business Server Page (BSP) application on a 2020 version of SAP
S/4HANA on-premise system.
To create the list report application, you should proceed as follows:
1. In Visual Studio Code, open the folder where you want to store
your application.
2. Use the shortcut (Ctrl) + (Shift) + (P) to start the menu in
Visual Studio Code, which shows you all available commands
for starting installed generators. So, in our case, the system
displays the generations from the SAP Fiori tools plug-in.
3. Select the command Fiori: Open Application Generator, as
shown in Figure 9.30.
Figure 9.30     Starting Application Generator in Visual Studio Code

4. In the window that opens, select the List Report Object Page
floorplan (see Figure 9.31) and click the Next button.
Figure 9.31     Selecting the List Report Object Page Floorplan
5. On the subsequent screen, select the ZUI_CERTICATE_ODATA_V2
service on your system as the data source and click the Next
button. Figure 9.32 shows the data source selection based on
an SAP S/4HANA on-premise system. Alternatively, you could
select a cloud system here or access the OData service directly.

Figure 9.32     Selecting a Data Source
6. On the subsequent screen, select ZC_Certificate as the main
entity. In the Navigation entity field, select None (see
Figure 9.33). Then click the Next button.
7. In the screen that follows, you need to assign a meaningful
module name and a meaningful title for your application. Under
Add deployment configuration, select Yes. Then configure the
SAPUI5 version and theme and thus the design of your
application to match your system and click Next (see
Figure 9.34).

Figure 9.33     Selecting the Entities
Figure 9.34     Maintaining Other Features of the Project
8. In the final step, you must maintain the deployment
configuration. Enter a development package and a workbench
transport request in the same way as in Figure 9.35.
9. Click the Finish button to complete the generator and create
your application.

Figure 9.35     Deployment Configuration
Now that your application has been generated, you should create a
file named .env in the webapp folder. In this file, behind the variables
UI5_USERNAME and UI5_PASSWORD, you should store your login data for
the system on which you want to deploy the application (see
Figure 9.36).
If you store your credentials in this file, they won’t be transferred
when you save your application to a Git repository or deploy the
application, and, thus, will be visible only to you. It isn’t
recommended to store the credentials directly in the ui5-deploy.yaml
file. As an alternative to maintaining the .env file, you can omit the
credentials entirely; in that case, you’ll be prompted for your
credentials during deployment.

Figure 9.36     Storing Login Data in the .env File
Next, open the ui5-deploy.yaml file and store your credentials from
the .env file there as variables (UI5_USERNAME and UI5_PASSWORD).
Then save your changes (see Figure 9.37).
Figure 9.37     Maintaining Credentials in the ui5-deploy.yaml File
Finally, you must perform the deployment on your SAP S/4HANA
system:

1. Select Terminal • Run Task from the menu (see Figure 9.38).
The terminal will then guide you through the deployment.
Figure 9.38     Opening the Terminal to Perform the Deployment
2. Next, select the npm task to use the Node Package Manager
for the deployment (see Figure 9.39).
Figure 9.39     Selecting the npm Task

3. You will now be presented with several node package manager
(npm) commands to choose from. Select npm deploy -
zc_certificate to deploy the cz_certificate entity (see
Figure 9.40).
Figure 9.40     Selecting the Deployment Task
4. In the final step, you need to choose how to run the deployment.
For our example, the selection Continue without scanning the
task output (see Figure 9.41) is sufficient. The deployment will
now run without any error or warning messages.
Figure 9.41     Running the Deployment
Once you’ve deployed your application, you’ll find the application as
a BSP application in the target package you selected (see XXX).
Now you can include the application in an SAP Fiori catalog and tile
group as part of SAP Fiori launchpad customizing. This allows you to

assign it to authorized users via a role.
In this chapter, you’ve implemented a first complete application
based on the ABAP RESTful application programming model. In the
process, you’ve learned how to apply all the concepts described in
the previous chapters. This first application was based on the
managed scenario. In the following two chapters, you’ll see where
the differences are compared to the unmanaged scenario and to the
managed scenario with unmanaged save by looking at additional
use cases.
Figure 9.42     BSP Application for the SAP Fiori App after Deployment

10    Managed Scenario with
Unmanaged Save: Integrating an
Existing Application
In this chapter, we’ll develop a RAP application using an
existing standard SAP application with its data model and
API. For this purpose, we’ll use the managed scenario with
unmanaged save. The focus is on the development of the
save sequence with late numbering.
In Chapter 9, the goal was to build a standalone application using
the ABAP RESTful application programming model. This application
was not based on an existing application, but it had its own data
model (greenfield approach). In this chapter, we’ll show you how to
build a RAP application that’s based on the data model of an existing
application and integrates it using its API. To integrate the API, you
need to implement the SAVE phase of the save sequence and late
numbering yourself.
The chapter starts with the description of the use case in
Section 10.1. We’ll then build the data model in Section 10.2 to
create a behavior definition based on it in Section 10.3. In
Section 10.4, we’ll implement the create purchase order function
and, in Section 10.5, we’ll implement the delete purchase order
function of the sample application. After that, we’ll continue with
Section 10.6 to expose the previously implemented function via the

OData protocol. In Section 10.7, we’ll implement authorization
checks for read and write accesses. Finally, we’ll create an SAP Fiori
elements UI for the application in Section 10.8.
10.1    Description of the Use Case
This section describes the use case we’ll implement in this chapter
using the ABAP RESTful application programming model and its
business requirements. Based on the technical requirements and the
general conditions, we’ll develop a suitable solution strategy and
implement it step-by-step.
We’ll develop an application that provides the fast entry of a
purchase order. Users should be able to order certain materials (e.g.,
a SAP PRESS book) on their own without having to know the details
of the order creation process or having to contact their company's
purchasing department. The application will be based on the
purchasing module functionality of the MM-PUR application
component, which is available in SAP S/4HANA.
The following list comprises the main functional requirements of the
application:
A purchase order can be created by entering a material and the
order quantity.
In the fast entry mode, purchase orders can have only one item at
a time.
Only materials approved by the purchasing department (valid
products) can be ordered.
Materials that are released for ordering are stored in a database
table for this purpose.

Purchase orders for materials that aren’t valid can’t be created.
The user sees only his or her own purchase orders.
Purchase orders can be deleted again.
Deleted purchase orders aren’t displayed in the user interface of
the application.
The application is implemented as SAP Fiori elements list report. In
Figure 10.1, you can see the finished application.
Figure 10.1     List Report for Fast Entry of Purchase Orders
An essential technical condition is the runtime environment of the
application. It determines the technical and functional scope and
general conditions or restrictions under which you can develop and
operate software. The development of this application is for SAP
S/4HANA 2021 FPS 1 (on-premise). In the following sections, we’ll
elaborate on the impact of this essential condition on the design of
the application.
[ ! ]  Warning: Release-Dependent Implementation
Late numbering is included in SAP S/4HANA 2021 FPS 1 as an
early development (see SAP Note 3060272). This means you can
carry out the development with this release in the managed
scenario with unmanaged save. If you have a lower release level,
you must make the implementation using the unmanaged
scenario.

Since the ABAP RESTful application programming model is also
available in the cloud, see Chapter 12 for details on the technical
environment for cloud applications.
In order to implement the business requirements, you first need a
suitable public interface (API) for read and write access to purchase
orders in SAP S/4HANA. For read access, you can use the CDS
views of the virtual data model (VDM) provided in the standard SAP
system.
Business application programming interfaces (BAPIs) are also
officially released APIs under SAP S/4HANA. You can therefore use
the BAPI BAPI_PO_CREATE1 to create a purchase order. The BAPI
BAPI_PO_CHANGE enables you to semantically delete a purchase order
by specifying a deletion indicator. Both of the function modules
perform persistent database changes (i.e., not only changes in the
memory during the interaction phase) and bundle them in a
database logical unit of work (LUW). They must therefore be called
in the save sequence.
To avoid duplicate data storage, our application doesn’t implement
its own persistence of purchase orders. Consequently, the purchase
orders created in the standard SAP system represent the sole data
source for the application. Alternatively, you could also implement
persistence yourself so that purchase orders that are entered quickly
are kept separately. This could be advantageous if, for example, the
criteria for such purchase orders were complex to evaluate, could
change foreseeably, or if additional fields could be necessary for
such a process, and aren’t included in the standard purchase order
business object. In our example, however, this isn’t the case. In
Section 10.2.3, we’ll describe in more detail the data model used
here.

Numbering is done by the API that’s used, which is included in the
save sequence (i.e., by the BAPI BAPI_PO_CREATE1). You must use
late numbering for this. Details on the implementation for our
application can be found in Section 10.4.1.
The BAPIs BAPI_PO_CREATE1 and BAPI_PO_CHANGE have a test or
simulation mode. You can use this mode to check the data in the
transaction buffer and, based on the check results, abort the save
sequence if necessary. You include these checks via validations
within the RAP transaction (Section 10.4.6 and Section 10.5.2).
Because you’re using BAPIs to create and change the purchase
order, transaction control lies with the BAPI consumer
(BAPI_TRANSACTION_COMMIT or BAPI_TRANSACTION_ROLLBACK). Here, the
changes made will either be posted to the database or the LUW will
be reset. The ABAP RESTful application programming model
provides for transaction control, as with BAPIs, on the part of the
consumer of the business object (i.e., either the EML consumer (via
COMMIT ENTITIES) or the orchestration framework). So, you can safely
use the mentioned BAPIs in the save sequence. The RAP
framework determines the transaction boundaries. A COMMIT ENTITIES
results in a COMMIT WORK being performed as well (which is behind the
BAPI_TRANSACTION_COMMIT ), so you don't have to call a
BAPI_TRANSACTION_COMMIT yourself, nor are you allowed to do so in
the behavior pool of a RAP business object. However, in other
projects, you should note that there are exceptions among BAPIs
that perform transaction control themselves. The integration of the
selected BAPIs within the save sequence is shown in Figure 10.2.

Figure 10.2     BAPI Call in the Save Sequence
You can use CDS entities of the VDM for read access. This allows
you to define your own CDS access controls based on the CDS
access controls defined in the VDM (Section 10.7). For write access,
you can query authorization objects that use the BAPIs in the RAP
business object.
Since users only need to enter a small amount of data when creating
a purchase order, we can do without draft handling in this example,
and the application status can be kept entirely on the client side (that
is, typically in the SAPUI5 application within the web browser).

10.2    Building the Data Model
In the following sections, we’ll describe the CDS data model for our
sample application for the fast entry of a purchase order and show
you how to create it in ABAP development tools (ADT). We’ll start
with an overview of the logical data model and explain which
database tables are necessary in the ABAP dictionary area.
10.2.1    Overview of the Logical Data Model
In Figure 10.3, you can see the logical data model of the application
as a Unified Modeling Language (UML) class diagram. The logical
data model is initially independent of the way it’s mapped in the
repository using the ABAP dictionary or core data services.
Figure 10.3     Logical Data Model of the Application
The UML class “purchase order (simplified)” is central and
represents a purchase order whose counterpart in the standard SAP
system is the purchase order item. It is simplified because it’s
associated with only one instance of a purchase order item. As a
result, the essential attributes of the class originate from both the

purchase order header (e.g., the purchase order number) and the
purchase order item (e.g., the purchase order quantity and the unit of
measure). You’ll learn more about the other attributes in
Section 10.2.3.
The UML class “purchase order (simplified)” is associated with the
UML class “valid material” (i.e., the products that may be procured
via the simplified purchase order). Procurement is only possible if the
active indicator (attribute “IsActive”) is set for the “valid material.”
In Figure 10.4, you can see how the data model of the application is
mapped with the development objects of the ABAP dictionary and
CDS. On the right, there are the VDM’s CDM entities, on which the
application is based, to implement the desired functional
requirements.
Figure 10.4     CDS Data Model of the Application
The functional requirements require read and write access to the
standard SAP business object of the purchase order. Since we a)
don’t need all the fields in the purchase order, b) the purchase orders
placed through the application have only one internal purchase order
line item, and c) we need transactional behavior for the purchase
order (create and delete), we must model a separate CDS root entity

named ZI_RAP_PurchaseOrder_M to represent the simplified purchase
order. This is the central entity of the application. It’s marked as root
so that you can later add behavior via a behavior definition and use it
to define a RAP business object. So you should keep in mind that,
during CDS modeling, you want to implement transactional behavior
and you will need a behavior definition to do so.
There’s no composition tree for the simplified purchase order in this
model (i.e., it has no child entities). Since the RAP part of the
application doesn’t have its own persistence, the simplified purchase
order uses the standard SAP purchase order as a data source,
accessing the CDS entity I_PurchaseOrderItemAPI01 in read-only
mode or the order header I_PurchaseOrderAPI01 from there.
In addition, the CDS entity ZI_RAP_PurchaseOrder_M is associated
with the first purchase order item, which is determined by a private
CDS view. For clarity, we have omitted the presentation of this CDS
entity in Figure 10.4.
The valid materials are stored in a separate database table named
ZRAP_A_PO_MAT, which is mapped at the logical level via the CDS
entity ZI_RAP_PO_Material. The simplified purchase order
ZI_RAP_PurchaseOrder_M is associated with the material that’s valid
for fast entry ZI_RAP_PO_Material. The valid material in turn “knows”
the material master I_Material by association.
[»]  Alternative Mapping of the Material Master
Instead of the CDS entity I_Material, you can also use the CDS
entity I_Product to access material master data. I_Product has
also been released for SAP S/4HANA Cloud (see
https://api.sap.com/cdsviews/I_PRODUCT). We’ve used the
I_Material entity in the data model of our application because the

business object “Material” is well known from classic ABAP
development for SAP ERP.
Table 10.1 lists all CDS entities of the VDM that you’ll use in this
application.
CDS Entity
Meaning
I_PurchaseOrderAPI01
Purchase order header
I_PurchaseOrderItemAPI01 Purchase order item
I_Material
Material master
I_Supplier
Supplier
Table 10.1     Standard CDS Entities for Using the Fast Entry of Purchase Orders
10.2.2    Database Tables
As described, we want to allow the simplified entry of a purchase
order only for certain materials. These materials are supposed to be
offered to the users via a search help in the user interface. In the
implementation of the RAP business object, the system checks
whether the materials are stored as released.
Our application keeps these materials in a separate database table:
ZRAP_A_PO_MAT. The structure of this database table is shown in
Table 10.2.
Field Name
Meaning
Key?
client
Client
Yes
material
Material number
Yes

Field Name
Meaning
Key?
supplier
Supplier from whom the material is
ordered
No
is_active
Active indicator; if it’s set, the material
can be ordered
No
created_by
Created by
No
created_at
Time of creation
No
last_changed_by
Last change by
No
last_changed_at
Time of last change
No
Table 10.2     Structure of Database Table ZRAP_A_PO_MAT
You can create the database table ZRAP_A_PO_MAT in ADT:
1. Select the package of your application in the Project Explorer
and use the shortcut (Ctrl) + (N) to start the creation wizard.
2. In the dialog that opens, you must select the Database Table
entry under ABAP • Dictionary.
3. Assign a name for the database table under Name (here it
would be “ZRAP_A_PO_MAT”) and enter a description in the
Description field.
4. Click the Next button and, after selecting the transport request,
finish the process by clicking the Finish button.
[»]  Naming Convention for Database Tables
In the ABAP RESTful application programming model, the prefix
_A is used as a naming convention to distinguish database
tables for active application data from database tables for draft
instances (prefix _D).

5. Modify the generated source code to define the database table
as shown in Listing 10.1.
@EndUserText.label: 'Valid materials for fast entry'
@AbapCatalog.enhancementCategory: #NOT_EXTENSIBLE
@AbapCatalog.tableCategory: #TRANSPARENT
@AbapCatalog.deliveryClass: #A
@AbapCatalog.dataMaintenance: #RESTRICTED
define table zrap_a_po_mat {
  key client      : abap.clnt not null;
  key material    : matnr not null;
  supplier        : lifnr;
  is_active       : zrap_po_mat_active;
  created_by      : abp_creation_user;
  created_at      : abp_creation_tstmpl;
  last_changed_by : abp_lastchange_user;
  last_changed_at : abp_lastchange_tstmpl;
} 
Listing 10.1     Source Code for the ZRAP_A_PO_MAT Database Table
6. Then, activate the database table. We provide the definition of
the data element ZRAP_PO_MAT_ACTIVE, which is used to type the
is_active column, with the download material for this book at
www.sap-press.com/5642.
10.2.3    CDS Modeling
This section describes the development of the CDS-based data
model. We’ll move from the bottom up along the dependency
relationships between CDS entities. That is, first we’ll create the
CDS view for wrapping the database table of the valid material and
then we’ll model the simplified order.
Valid Material
We want to logically map the database table ZRAP_A_PO_MAT in a CDS
entity. This entity represents the valid material for fast order entry on

a semantic level.
1. To do this, you need to create a CDS view named
ZI_RAP_PO_Material based on the database table ZRAP_A_PO_MAT.
So, you must use the creation wizard again. Under ABAP •
Core Data Services, select Data Definition.
2. Then fill in the dialog shown in Figure 10.5 to create the CDS
entity. The package name (Package input field) may differ in
your case from what we’ve used here.
Figure 10.5     Creating the ZI_RAP_PO_Material CDS View
3. Use the Define View Entity template and finish the process by
clicking the Finish button.
The data definition language (DDL) source code editor opens with
the source code generated based on the selected template.
[+]  Tip: Applying Pretty Printer
You should perform a formatting of the source code using the
shortcut (Ctrl) + (Shift) + (F).

Add the required associations to the CDS entities of the VDM to the
source code as shown in Listing 10.2. To do this, you need to define
an association to the material (association [0..1] to I_Material)
and one to the supplier (association [0..1] to I_Supplier).
@AbapCatalog.viewEnhancementCategory: [#NONE]
@AccessControl.authorizationCheck: #CHECK
@EndUserText.label: 'Valid material for fast entry'
@Metadata.ignorePropagatedAnnotations: true
@ObjectModel.usageType:{
    serviceQuality: #X,
    sizeCategory: #S,
    dataClass: #MIXED
}
define view entity ZI_RAP_PO_Material
  as select from zrap_a_po_mat
  association [0..1] to I_Material as _Material on 
_Material.Material = $projection.Material
association [0..1] to I_Supplier as _Supplier on 
_Supplier.Supplier = $projection.Supplier
{
  key material        as Material,
      supplier        as Supplier,
      is_active       as IsActive,
      created_by      as CreatedBy,
      created_at      as CreatedAt,
      last_changed_by as LastChangedBy,
      last_changed_at as LastChangedAt,
      _Material,
_Supplier
} 
Listing 10.2     CDS Entity for the Valid Material
Help View for Determining the First Purchase Order Item
In the next step, we need a CDS view that determines the number of
the first purchase order item of each order. To do this, you must
create the CDS view ZP_RAP_PurchaseOrderItemCount. By using the
name prefix P_ you communicate that this is a private CDS entity and
therefore an implementation detail of the application. You can see
the DDL source code of this view in Listing 10.3.

@AccessControl.authorizationCheck: #CHECK
@EndUserText.label: 'Help view for first purchase order item'
define view entity ZP_RAP_PurchaseOrderItemCount
  as select from I_PurchaseOrderItemAPI01
{
  PurchaseOrder,
  min( PurchaseOrderItem ) as FirstPurchaseOrderItem
}
group by
  PurchaseOrder
having
count(*) = 1 
Listing 10.3     Help View for Determining the First Item Number
The view is based on CDS entity I_PurchaseOrderItemAPI01 to select
the purchase order items stored in the standard SAP system. What’s
crucial to this view is the bold highlighted line with the min aggregate
expression to determine the lowest and therefore first item number of
the order. The FirstPurchaseOrderItem attribute contains this
number. The aggregation expression count(*) = 1 in the having
clause determines the number of purchase order items per purchase
order number (group by PurchaseOrder clause) and selects only
purchase orders that have an item.
The editor of the CDS view enables you to execute the view via the
function key (F8) and thus test the data selection. Alternatively, you
can use the context menu of the CDS view and select the Open
With • Data Preview menu item. After running the CDS view, the
data preview opens in a new tab where the result set is displayed
(see Figure 10.6).

Figure 10.6     Result Set for the ZP_RAP_PurchaseOrderItemCount View in Data Preview
Purchase Order with a Purchase Order Item
Next, you can create the CDS entity ZI_RAP_PurchaseOrder_M. You
should proceed in the same way as for the other CDS entities, but
use the Define Root View Entity template. In Listing 10.4, you can
see the declaration of the CDS root entity for our RAP business
model with required join conditions.
@AccessControl.authorizationCheck: #CHECK
@EndUserText.label: 'Purchase order with one item'
define root view entity ZI_RAP_PurchaseOrder_M
  as select from I_PurchaseOrderItemAPI01 as item
    inner join ZP_RAP_PurchaseOrderItemCount as item_cnt
      on item.PurchaseOrder     = item_cnt.PurchaseOrder
 and item.PurchaseOrderItem = item_cnt.FirstPurchaseOrderItem
    inner join ZI_RAP_PO_Material as po_mat 
      on po_mat.Material = item.Material
... 
Listing 10.4     CDS Root Entity of the Simplified Purchase Order with Join Conditions
The CDS entity is based on the purchase order item
I_PurchaseOrderItemAPI01 of the standard SAP system. The inner
join to the previously created help view
ZP_RAP_PurchaseOrderItemCount creates the link to the first purchase
order item, while the inner join to the ZI_RAP_PO_Material view
creates the link to the materials valid for the purchase order process.
In this way, you select only first purchase order items that contain a
material stored as valid. You don’t evaluate the active indicator. This
means that all purchase orders already placed with this material
number will be selected, even if they have been set to inactive in the
meantime.
[»]  Naming the CDS Entities of a RAP Business Object

The transaction behavior for the fast entry purchase order is
represented through the behavior definition for the CDS root entity
ZI_RAP_PurchaseOrder_M, which we’ll create in Section 10.3. We’ll
choose the implementation type managed with unmanaged save. CDS
entities of a RAP business object, whose runtime is managed (at
least their interaction phase), get the suffix _M , according to the
naming convention.
A series of associations follows in Listing 10.5 to establish the logical
link to the purchase order item (I_PurchaseOrderItemAPI01), to the
purchase order (I_PurchaseOrderAPI01), and to the ordered valid
material (ZI_RAP_PO_Material).
  association [1] to I_PurchaseOrderAPI01 as _PurchaseOrder on  
    _PurchaseOrder.PurchaseOrder = item.PurchaseOrder
  association [1] to I_PurchaseOrderItemAPI01 as 
    _PurchaseOrderItem on _PurchaseOrderItem.PurchaseOrder = 
    $projection.PurchaseOrder and 
    _PurchaseOrderItem.PurchaseOrderItem = 
    $projection.PurchaseOrderItem
  association [1] to ZI_RAP_PO_Material as _POMaterial on 
    _POMaterial.Material = $projection.Material
{
... 
Listing 10.5     Associations within ZI_RAP_PurchaseOrder_M View Definition
Now, the question arises regarding which fields of the CDS entity are
relevant for the respective use case (i.e., which fields are to be
accessed from outside the business object in read and write mode
within the create operation). The CDS entity ZI_RAP_PurchaseOrder_M
requires the attributes listed in Table 10.3 from the business object of
the purchase order so that the described requirements can be
implemented (administrative fields are not shown).
Attribute
Meaning (Origin)
Type of
Operation

Attribute
Meaning (Origin)
Type of
Operation
key PurchaseOrder
Purchase order number
(purchase order header);
key field
Read
PurchaseOrderType
Purchase order type
(purchase order header)
Read
PurchaseOrderItem
Item number (purchase
order item)
Read
PurchaseOrderDate
Purchase order date
(purchase order header)
Read
PurchasingOrganization
Purchasing organization
(purchase order header)
Read
PurchasingGroup
Purchasing group
(purchase order header)
Read
Plant
Plant (purchase order
item)
Read
Supplier
Supplier number
(purchase order header)
Read
Materials
Material number
(purchase order header)
Read and
write
OrderQuantity
Purchase order quantity
Read and
write
PurchaseOrderQuantityUnit Unit of measure
Read
LastChangeDateTime
Timestamp of the last
change; also filled during
creation
Read
Table 10.3     Relevant Fields of ZI_RAP_PurchaseOrder_M CDS Entity

There’s only one CDS entity because we assume that the created
purchase order has only one purchase order item. So, both fields
from the purchase order item and those from the purchase order
header data are found on one level in CDS view
ZI_RAP_PurchaseOrder_M. From the 1-to-n relationship between
purchase order and purchase order item, here you declare a 1-to-1
relationship. Thus, the data model is denormalized at this point.
Now you need to declare the relevant fields in the selection list of the
CDS entity. You can see the completion of the DDL source code with
the selection list for field declaration (and the publication of the
previously declared associations) in Listing 10.6. Note that due to the
where clause, you only see purchase order items that haven’t been
deleted (item.PurchasingDocumentDeletionCode <> 'L').
...
{
  key item.PurchaseOrder,
      _PurchaseOrder.PurchaseOrderType,
      _PurchaseOrder.PurchaseOrderDate,
      _PurchaseOrder.PurchasingOrganization,
      _PurchaseOrder.PurchasingGroup,
      _PurchaseOrder.Supplier,
      _PurchaseOrder.CreatedByUser,
      _PurchaseOrder.CreationDate,
      _PurchaseOrder.LastChangeDateTime,
      item.PurchaseOrderItem,
      item.Material,
      item.OrderQuantity,
      item.PurchaseOrderQuantityUnit,
      item.Plant,
      _PurchaseOrder,
      _PurchaseOrderItem,
      _POMaterial
}
where
  item.PurchasingDocumentDeletionCode <> 'L' 
Listing 10.6     Selection List and Final where Clause
Save and activate the class. The declaration of the key fields with
key is essential for a RAP business object and the CDS entities of its

composition tree. In our example, there’s only one key field,
PurchaseOrder, because our business object is a simplified purchase
order. Since the separation between header and item data has been
deliberately removed, the order number is sufficient as the sole key
field. It’s semantically correct and does not need to be supplemented
by the number of the purchase order item.

10.3    Creating a Behavior Definition
In the previous section, you mapped the data model of the
application using the ABAP dictionary and CDS views in the
repository. It is thus already prepared in such a way that you can
map the desired transactional behavior. First of all, this involves
basic declarations in the behavior definition before you can define
the create purchase order and delete purchase order functions.
Before you create the behavior definition, you should choose the
implementation type. Because we decided to use BAPIs for the
purchase order, we don't need our own business logic during the
interaction phase and we don't need to integrate an inventory API
there. Accordingly, the interaction phase can be implemented by the
managed business object provider. We can complement
determinations and validations anyway.
Since the RAP business object doesn’t have its own persistence, we
don’t need a fully managed business object that also implements the
save sequence. On the contrary: We want to implement the save
sequence ourselves to implement database changes through the
BAPI calls. For these reasons, we opt for a managed with unmanaged
save scenario. The interaction phase is thus managed, whereas the
save sequence isn’t. The latter can be implemented by using it in the
behavior pool.
You can create a behavior definition for CDS root entity
ZI_RAP_PurchaseOrder_M as follows:
1. Open the context menu for CDS entity ZI_RAP_PurchaseOrder_M
and select the menu item New Behavior Definition there.

2. In the dialog that opens, keep the default setting managed for
the value of the Implementation Type field and complete the
creation process by clicking the Finish button.
3. Then, the editor with the proposed behavior definition language
(BDL) source code will open.
Customize the BDL source code as shown in Listing 10.7. Declare
the save option with unmanaged save. This eliminates the need to
specify a database table via persistent table, so you can remove
the corresponding line from the generated source code. Assign the
PurchaseOrder alias for the entity behavior definition. You can then
use this descriptive name in the behavior pool.
managed with unmanaged save; // implementation in class zbp_i_rap_purchaseorder_m 
unique;
 
define behavior for ZI_RAP_PURCHASEORDER_M alias PurchaseOrder
lock master
//authorization master ( instance )
etag master LastChangeDateTime
{
  create;
  internal update;
  delete;
} 
Listing 10.7     Basic Declarations in the BDL Source Code
Remove the comment in the lock declaration line in the entity
behavior definition so that it is declared as lock master. Then, you
should add internal to the update operation because the RAP
business object only provides the standard create and delete
operations externally, even if the deletion operation is implemented
internally via an update of the purchase order (via the BAPI
BAPI_PO_CHANGE). You need the update operation for changing
instances within the behavior implementation.

As etag master, you should name the LastChangeDateTime field
because the RAP business object also provides for a delete
operation that might be performed on an outdated dataset. Finally,
save and activate the behavior definition.

10.4    Implementing the Create Purchase
Order Function
In this section, you’ll implement the function for creating a purchase
order. You have already taken a first step towards this, because the
standard create operation has already been declared in the context
of the behavior definition in the previous section.
10.4.1    Declaring Late Numbering
In the context of the create operation of a CDS entity of a RAP
business object, you must always consider numbering and choose
one of the options supported by the ABAP RESTful application
programming model (see Chapter 3, Section 3.7).
Since in our example the instance of a purchase order is created,
you need to consider in which way the numbering of the purchase
order should be carried out. In the CDS data model, we’ve declared
the order number PurchaseOrder as key. The purchase order
numbering is done by the BAPI (we don’t use a purchase order
process in MM-PUR with external numbering here) and is therefore
beyond our control. Thus, the number of the created purchase order
will become available to us in the save sequence after calling the
BAPI BAPI_PO_CREATE1. A numbering during the save sequence is
supported by the ABAP RESTful application programming model via
the late numbering option.
Provide the CDS entity ZI_RAP_PurchaseOrder_M with the late
numbering function in the transactional properties of the entity
behavior definition via the BDL keyword late numbering (see
Listing 10.8).

managed with unmanaged save; // implementation in class zbp_i_rap_purchaseorder_m 
unique;
 
define behavior for ZI_RAP_PURCHASEORDER_M alias PurchaseOrder
lock master
late numbering
//authorization master ( instance )
... 
Listing 10.8     Declaring Late Numbering
This allows you to implement late numbering using the
ADJUST_NUMBERS method in the save handler, which we’ll implement in
Section 10.4.5.
10.4.2    Setting Field Properties
If a behavior definition is created for a CDS data model, by default all
fields of the contained CDS entities are also open for write accesses.
However, this is often not desired. You should consider for each field
whether it may be open for write access or not.
[+]  Tip: Lean Interface
Ensure that the interface of the business object and its operations
is as lean as possible and therefore only allow write access to
those fields for which it is actually necessary.
In relation to our use case of purchase order entry, this means that
the Material and OrderQuantity fields must remain open for write
access. For the remaining fields, only read access is allowed (see
also Table 10.3). The PurchaseOrderQuantityUnit is determined from
the base unit of measure of the material.
Thus, you need to provide the fields of CDS entity
ZI_RAP_PurchaseOrder_M with the field ( readonly ) ... property so

that they are protected against write access from outside the
business object (see Listing 10.9).
...
{
  create;
  internal update;
  delete;
 
  field ( readonly )
  PurchaseOrder,
  PurchaseOrderDate,
  PurchasingOrganization,
  PurchasingGroup,
  Supplier,
  PurchaseOrderQuantityUnit,
  Plant,
  CreatedByUser,
  LastChangeDateTime,
  CreationDate;
... 
Listing 10.9     Defining the readonly Field Property
As an additional field property, you can use the field ( mandatory )
... addition to inform the UI level that Material and OrderQuantity
are mandatory fields (see Listing 10.10).
...
  CreationDate;
 
  field ( mandatory ) Material, OrderQuantity;
... 
Listing 10.10     Defining a Mandatory Field Property
These fields will now be displayed as mandatory fields in the user
interface. You must check whether they’ve been populated using a
validation (Section 10.4.6).
Using mandatory:create would be possible as an alternative, but
makes it difficult to add draft handling later. In our example, we
assume that a business object instance can basically be created

without a given material and without a given quantity in the
transaction buffer, even if it can’t be saved in this inconsistent state.
Once you’ve declared the basic behavior (the implementation type
and numbering) and the business object interface (e.g., create and
delete operations, field properties), you can define the business-
object-internal logic for implementing the purchase order creation
and implement it with ABAP in the behavior pool.
10.4.3    Creating the Behavior Pool
In this section, we’ll add a behavior implementation to the behavior
definition. To do this, you need to remove the comment character
(//) in the first line of the behavior definition from Listing 10.7 in
order to declare the ABAP class zbp_i_rap_purchaseorder_m already
stored there as a behavior pool. Since the RAP business object
consists of only one CDS entity anyway, we’ll use a behavior pool for
the entire behavior definition (see Listing 10.11).
managed with unmanaged save implementation in class zbp_i_rap_purchaseorder_m
unique;
 
define behavior for ZI_RAP_PurchaseOrder_M alias PurchaseOrder
lock master
... 
Listing 10.11     Declaration of the Behavior Pool in the Header of the Behavior Definition
Then, save and activate the behavior definition and create the
behavior pool (i.e., the ABAP class) using ADT’s quick fix function.
To do this, you must position the cursor on the name of the ABAP
class in the source code and use the shortcut (Ctrl) + (1) (see
Figure 10.7).

Figure 10.7     Creating the Behavior Pool via the Quick Fix Function
Complete the creation of the class via the dialog. Then, the source
code editor for the created class will open. Based on the already
declared behavior (late numbering and unmanaged save sequence),
the save handler is generated and displayed directly on the Local
Types tab (see Listing 10.8).
Figure 10.8     Creating the Behavior Pool with the Save Handler
10.4.4    Implementing Determinations
To create a purchase order via the BAPI, it’s necessary to pass
some central fields of the purchase order. This data is determined
during the interaction phase and stored in the created instances in
the transaction buffer. The purpose is to determine the following
data:
Data with organizational reference to the purchase order
The fields with organizational reference are the fields for the
purchasing organization, the purchasing group, and the plant.
Data with reference to the valid material
These fields include the item number, supplier, and unit of
measure of the valid material.

In this section, we’ll declare and implement two determinations for
this purpose.
For this purpose, you should create the determinations initOrgData
and initMaterialRelatedData in the behavior definition, as shown in
Listing 10.12. Save and activate the behavior definition afterwards.
...
  field ( mandatory ) Material, OrderQuantity;
 
  determination initOrgData on modify { create; }
  determination initMaterialRelatedData on modify { create; }
... 
Listing 10.12     Defining Determinations During the Create Operation
The determinations will be executed in the interaction phase after the
create operation and require an implementation in the behavior pool.
Then, using ADT’s quick fix feature, you must create the methods for
the two determinations in the behavior pool. In each case, position
the cursor on the determination name in the behavior definition.
Implementing the initOrgData Determination
You’ve created the initOrgData determination to determine
organizational data for the purchase order creation. In Listing 10.13,
you can see the signature of the initOrgData method for this
determination in the interaction handler lhc_PurchaseOrder.
CLASS lhc_PurchaseOrder DEFINITION INHERITING FROM cl_abap_behavior_handler.
...
  PRIVATE SECTION.
    METHODS initOrgData FOR DETERMINE ON MODIFY
      IMPORTING keys FOR PurchaseOrder~initOrgData.
... 
Listing 10.13     Signature of initOrgData Method for Determination

Implement the initOrgData method using EML. You can see the
complete ABAP source code in Listing 10.14.
...
  initOrgData.
    DATA(org_data) = read_org_data( ).
    MODIFY ENTITIES OF ZI_RAP_PurchaseOrder_M IN LOCAL MODE
      ENTITY PurchaseOrder
        UPDATE FROM
         VALUE #( FOR k IN keys
        ( %tky = k-%tky
        PurchasingOrganization = org_data-purch_org
        PurchasingGroup = org_data-pur_group
        Plant = org_data-plant
        %control-PurchasingOrganization = if_abap_behv=>mk-on
        %control-PurchasingGroup = if_abap_behv=>mk-on
        %control-Plant = if_abap_behv=>mk-on ) ).
  ENDMETHOD. 
Listing 10.14     Implementation of the initOrgData Determination Method
Because the interaction phase for this RAP business object is
managed by the programming model, the implementation of the
create operation is handled by the managed business object
provider, and the created instances are available in the transaction
buffer at runtime of the initOrgData determination without you
needing to program anything for this. As a trigger condition for the
determination, we have declared the create operation so that the
implementing method initOrgData is executed after the creation of
the instance(s) and the created instances are available in the
transaction buffer at this time.
Since handler methods in the ABAP RESTful application
programming model are multi-instance capable, all key values of the
affected (in this case, created) instance(s) are passed via the import
parameter keys. A late numbering is declared for CDS entity
ZI_RAP_PurchaseOrder_M, which is why the keys parameter is used to
pass preliminary key values (%TKY-%PID) generated by the RAP

framework, which are used to identify the created instances and are
only valid during the RAP transaction.
Determinations perform calculations. In our example, they determine
the appropriate organizational data to create the purchase order.
This calculation is done using a separate method named
read_org_data, which returns the purchasing organization, plant, and
purchasing group independent of an instance. For this reason,
reading concrete instances from the transaction buffer via READ
ENTITIES isn’t necessary in this implementation.
The read_org_data method is an implementation detail of our sample
application and is representative of the "real" determination or
calculation. It would have to be adapted or designed accordingly,
depending on the requirements. For example, organizational data
could be determined based on the user's organizational affiliation or
derived from the ordered material.
You must now enter the organizational data determined in the
org_data data object in the instances created within the RAP
request. To do this, you can use the MODIFY ENTITIES statement. Note
that you use an update operation when doing this, since the
instances to be changed are already available in the transaction
buffer.
Iterate over the key values keys of the affected instances in a FOR
loop inside the constructor expression VALUE#( ). The constructor
expression creates an internal table that’s passed as an actual
parameter to the UPDATE FROM expression. You only need to provide
the PurchasingOrganization, PurchasingGroup and Plant fields with
the appropriate values and use the control structure %CONTROL to
indicate that the field contents should be set. You can identify the
key values of the instances using the key structure of the %TKY of the
transactional key.

Implementing the initMaterialRelatedData Determination
The initMaterialRelatedData determination ensures that material-
relevant data is determined on the basis of the transferred material
number when an instance of the ZI_RAP_PurchaseOrder_M entity is
created and the corresponding instances are updated with this data.
The following field contents are determined for this purpose:
Item number (PurchaseOrderItem)
The item number is assigned as a fixed value.
Supplier (Supplier)
The supplier is determined via CDS entity ZI_RAP_PO_Material
from the application table ZRAP_A_PO_MAT.
Purchase order quantity unit (PurchaseOrderQuantityUnit)
The purchase order quantity unit is determined as the base unit of
measure MaterialBaseUnit from the material master I_Material.
Let's turn to the program logic for determining the above fields.
Before you implement the determination of the supplier, you should
do some preliminary work. The determination of the mentioned fields
is based on CDS entity ZI_RAP_PO_Material and is swapped out to
separate methods. In Listing 10.15, you can see the declarative part
of the swapped out methods to implement the reading of the data
from the application table.
CLASS lhc_PurchaseOrder DEFINITION INHERITING FROM cl_abap_behavior_handler.
...
  PUBLIC SECTION.
    CLASS-METHODS class_constructor.
    ...
  PRIVATE SECTION.
    "! Material data for fast purchase order entry
    CLASS-DATA gt_material_cust TYPE TABLE OF ZI_RAP_PO_Material.
...
    CLASS-METHODS read_cust_by_material
      IMPORTING
        VALUE(material) TYPE ZI_RAP_PurchaseOrder_M-Material
      EXPORTING
        VALUE(material_cust) TYPE ZI_RAP_PO_Material.

 
    CLASS-METHODS read_supplier_by_material
      IMPORTING
        VALUE(material) TYPE ZI_RAP_PurchaseOrder_M-Material
      RETURNING
        VALUE(supplier) TYPE ZI_RAP_PO_Material-Supplier.
... 
Listing 10.15     Declarative Part of the Swapped Out Methods for Reading the Valid
Material
Listing 10.16 contains the method implementations.
CLASS lhc_PurchaseOrder IMPLEMENTATION.
  METHOD class_constructor.
    SELECT * FROM ZI_RAP_PO_Material
        INTO TABLE @gt_material_cust.
  ENDMETHOD.
 
  METHOD read_supplier_by_material.
    read_cust_by_material(
      EXPORTING
        material      = material
      IMPORTING
        material_cust = DATA(material_cust) ).
    supplier = material_cust-Supplier.
  ENDMETHOD.
 
  METHOD read_cust_by_material.
    READ TABLE gt_material_cust
        WITH KEY Material = material
        INTO material_cust.
  ENDMETHOD.
... 
Listing 10.16     Method Implementations for Determining the Supplier
We don’t want to go through the coding in detail, since it’s standard
ABAP. However, we’d like to point out that you can access all
standard constructs within ABAP classes in the behavior pool. For
example, you can use the class constructor to read data about the
valid material once within the ABAP session (when loading the class
into the memory). This allows you to access its contents at later
points within the RAP transaction. We assume that the number of
records in this table is small so that it can be completely loaded into

the memory. Depending on the application, single record access to
the table may be more advantageous.
For further modularization, we’ve implemented two small custom
methods, read_supplier_by_material and read_cust_by_material.
The initMaterialRelatedData determination is also called at the time
of the create operation. Accordingly, there are similarities with the
implementation of the initOrgData determination. In the following
sections, we’ll therefore only explain the main differences in the
implementation. In Listing 10.17, you can see the signature of the
corresponding method for determining initMaterialRelatedData.
...
  PRIVATE SECTION.
    METHODS initOrgData FOR DETERMINE ON MODIFY
      IMPORTING keys FOR PurchaseOrder~initOrgData.
    METHODS initMaterialRelatedData FOR DETERMINE ON MODIFY
    IMPORTING keys FOR PurchaseOrder~initMaterialRelatedData. 
Listing 10.17     Method Signature for Determining initMaterialRelatedData
Navigate to the empty method implementation of
initMaterialRelatedData and begin its implementation based on
Listing 10.18.
...
  METHOD initMaterialRelatedData.
    READ ENTITY IN LOCAL MODE ZI_RAP_PurchaseOrder_M
        FIELDS ( Material )
          WITH CORRESPONDING #( keys )
        RESULT DATA(po_headers).
    ... 
Listing 10.18     Reading Instances from the Transaction Buffer via Read Entity Command
You can use the key values (keys) passed to the method to access
the instances of CDS entity ZI_RAP_PurchaseOrder_M already created
in the transaction buffer via the READ ENTITY short form. With FIELDS (
Material ), you only read the material number because only this is

necessary for further calculation. You can use the constructor
expression CORRESPONDING #( keys ) to pass the passed key values of
the internal table keys converted to the READ ENTITY command. This
includes relevant key fields such as the preliminary ID %PID during
the interaction phase with late numbering.
You now need to determine the relevant fields for the transferred
instances and change them using the MODIFY ENTITIES command in
the transaction buffer. Listing 10.19 shows the further
implementation of the method.
METHOD initMaterialRelatedData.
  READ ENTITY IN LOCAL MODE
    ...
    RESULT DATA(po_headers).
 
  MODIFY ENTITIES OF ZI_RAP_PurchaseOrder_M IN LOCAL MODE
    ENTITY PurchaseOrder
      UPDATE FROM
       VALUE #( FOR po IN po_headers
                  ( %tky = po-%tky
                    Supplier = 
                read_supplier_by_material( material = po-material )
                    PurchaseOrderItem = '10'
                    PurchaseOrderQuantityUnit = 
                read_baseunit_by_material( material = po-material )
                    %control-Supplier = if_abap_behv=>mk-on
                    %control-PurchaseOrderItem = if_abap_behv=>mk-on
                    %control-PurchaseOrderQuantityUnit = 
                      if_abap_behv=>mk-on ) ).
ENDMETHOD. 
Listing 10.19     Changing Instances via Modify Entities Command
The Material field has been declared as a mandatory field in the
behavior definition, which is why you don’t need to consider the case
of a material number that hasn’t been transferred here. Again, you
must use a constructor expression (VALUE #( ... )) to create the
internal table to pass data to the update operation of MODIFY ENTITIES.
In this constructor expression, a row is created in the internal table
for each instance read (FOR po IN po_headers). In each iteration over

po_headers, the previously implemented methods are called with the
material (po-material) as actual parameters to determine the
supplier or the appropriate unit of measure and set it in the internal
table.
[»]  Swapping out a Determination
You can also use mass determination of the data to be updated
before the EML statement, MODIFY ENTITIES ... UPDATE and, if
necessary, return messages via the return parameter REPORTED if,
for example, the supplier for a material couldn’t be determined.
The determinations implemented in this way ensure that the
appropriate data for creating the purchase order is stored in the
instances to be created. You have thus created the starting point on
the basis of which you can implement the save sequence and thus
the actual creation of the purchase order via BAPI. (A short jump
back to the interaction phase will still be necessary, however, but
more on that in the next section.)
10.4.5    Save Sequence: Implementing the Creation via
BAPI
The development of the solution strategy (Section 10.1) has shown
that we need a late numbering for the RAP business object, but the
numbering is carried out by the BAPI BAPI_PO_CREATE1 in the course
of the purchase order creation. To correctly implement the RAP
contract for late numbering, you must implement the purchase order
creation in the ADJUST_NUMBERS method provided for late numbering in
the save handler, not in the SAVE_MODIFIED method. Due to the

automatic creation of the behavior pool, this method has already
been declared in the save handler (see Listing 10.20).
CLASS lsc_ZI_RAP_PurchaseOrder_M DEFINITION INHERITING FROM cl_abap_behavior_saver.
  PROTECTED SECTION.
    METHODS adjust_numbers REDEFINITION.
    ...
ENDCLASS. 
Listing 10.20     Declaration of the ADJUST_NUMBERS Method in the Save Handler
First, you should read the instances created during the interaction
phase. Use the preliminary key values assigned by the RAP
framework from the internal table mapped-purchaseorder, which has
been passed to the method (see Listing 10.21).
CLASS lsc_ZI_RAP_PurchaseOrder_M IMPLEMENTATION.
  METHOD adjust_numbers.
    " Read purchase orders based on key values from interaction phase
    READ ENTITIES OF ZI_RAP_PurchaseOrder_M
      ENTITY PurchaseOrder
        ALL FIELDS
        WITH CORRESPONDING #( mapped-purchaseorder )
          RESULT DATA(pos_to_create).
... 
Listing 10.21     Reading Created Purchase Order Instances From the Transaction Buffer
Now iterate over the read instances and create a purchase order for
each entry via BAPI. We’ve swapped out the BAPI call to a separate
method: create_purchase_order (see Listing 10.22).
...
LOOP AT pos_to_create INTO DATA(po_to_create).
  " Create a new purchase order
  lhc_purchaseorder=>create_purchase_order(
    EXPORTING
      as_test_run    = abap_false
      po_entity      = CORRESPONDING #( po_to_create )
    IMPORTING
      po_header_created = DATA(po_header_created)
      return            = DATA(return) ).
  ...
ENDLOOP. 
Listing 10.22     Creating a Purchase Order Within the Adjust_Numbers Method

For the create_purchase_order method, you need to first create the
type declaration tt_return and the method declaration (see
Listing 10.23).
CLASS lhc_PurchaseOrder DEFINITION INHERITING FROM cl_abap_behavior_handler.
 
  PUBLIC SECTION.
    TYPES tt_return TYPE STANDARD TABLE OF bapiret2.
    CLASS-METHODS create_purchase_order
      IMPORTING
        VALUE(po_entity)   TYPE ZI_RAP_PurchaseOrder_M
        VALUE(as_test_run) TYPE abap_bool DEFAULT abap_true
      EXPORTING
        VALUE(return)      TYPE tt_return
        VALUE(po_header_created) TYPE bapimepoheader.
... 
Listing 10.23     Signature of the create_purchase_order Method for the Purchase Order
Creation
The method uses CDS root entity ZI_RAP_PurchaseOrder_M as the
import parameter so that the data can be passed according to the
type. The as_test_run flag calls the BAPI in test mode. Implement
the method using the ABAP source code from Listing 10.24:
METHOD create_purchase_order.
  DATA: ls_po_header  TYPE bapimepoheader,
        ls_x_po_header TYPE bapimepoheaderx,
        lt_po_item    TYPE STANDARD TABLE OF bapimepoitem,
        ls_po_item    LIKE LINE OF lt_po_item,
        lt_x_po_item  TYPE STANDARD TABLE OF bapimepoitemx.
 
  " Header data for the purchase order
  ls_po_header = CORRESPONDING #( po_entity MAPPING FROM
    ENTITY ).
 
  ls_x_po_header-vendor    = abap_true.
  ls_x_po_header-purch_org = abap_true.
  ls_x_po_header-pur_group = abap_true.
 
  " Item data, create only one item
  " Map PurchaseOrderItem, Material, Plant, OrderQuantity
  ls_po_item = CORRESPONDING #( po_entity MAPPING FROM ENTITY ).
  ls_po_item-net_price = '1.0'.
  APPEND ls_po_item TO lt_po_item.
 
  lt_x_po_item = VALUE #( ( po_item   = ls_po_item-po_item
                            net_price = abap_true

                            material  = abap_true
                            plant     = abap_true
                            quantity  = abap_true ) ).
  CALL FUNCTION 'BAPI_PO_CREATE1'
    EXPORTING
      poheader  = ls_po_header
      poheaderx = ls_x_po_header
      testrun   = as_test_run
    IMPORTING
      expheader = po_header_created
    TABLES
      return    = return
      poitem    = lt_po_item
      poitemx   = lt_x_po_item.
ENDMETHOD. 
Listing 10.24     Implementation of the create_purchase_order Method
This is an ordinary BAPI call that takes the data from the passed
instance (po_entity) and creates a purchase order from it.
In the implementation, we use assignments via the constructor
expression CORRESPONDING #( ) using field mappings via MAPPING FROM
ENTITY. In this way, the mapping between fields of structured legacy
data types (here the data types of the BAPI) to the respective CDS
entity of the RAP business object can be used for assignments. For
this purpose, a corresponding field mapping must exist in the
behavior definition. Add and activate the two necessary field
mappings from Listing 10.25 in the behavior definition.
mapping for bapimepoheader corresponding
{
  PurchaseOrder = po_number;
  PurchasingOrganization = purch_org;
  PurchasingGroup = pur_group;
  Supplier = vendor;
}
 
mapping for bapimepoitem corresponding
{
  PurchaseOrderItem = po_item;
  Material = material;
  OrderQuantity = quantity;
} 
Listing 10.25     Declared Field Mappings for the BAPI Data Types

After the BAPI call has been moved to its own method, you can turn
your attention to implementing the ADJUST_NUMBERS method. Report
an error situation via dump and populate the MAPPED parameter (see
Listing 10.26).
...
LOOP AT pos_to_create INTO DATA(po_to_create).
  " Create a new purchase order
  lhc_purchaseorder=>create_purchase_order(
    EXPORTING
      as_test_run    = abap_false
      po_entity      = CORRESPONDING #( po_to_create )
    IMPORTING
      po_header_created = DATA(po_header_created)
      return            = DATA(return) ).
 
  READ TABLE return WITH KEY type = 'E'
    INTO DATA(return_err).
  IF sy-subrc EQ 0.
    RAISE SHORTDUMP NEW zcx_rap_purchaseorder( ... ) ).
  ENDIF.
 
  " MAPPED: Return key values
  APPEND INITIAL LINE TO mapped-purchaseorder
       ASSIGNING FIELD-SYMBOL(<ls_mapped>).
  <ls_mapped>-%pid = po_to_create-%pid.
  <ls_mapped>-PurchaseOrder = po_header_created-po_number.
  ...
ENDLOOP. 
Listing 10.26     Returning Purchase Order Numbers via the MAPPED Parameter
The essential responsibility of the ADJUST_NUMBERS method is to
generate and return a permanent key value for each %PID. The
purchase order creation returns the created purchase order data
including the purchase order number via the actual parameter
po_header_created. This is why we don’t create the purchase order in
the SAVE_MODIFIED method; we create it at this point. Via a new line in
the internal table mapped-purchaseorder, you assign the
corresponding purchase order number from the previously
performed creation process to the currently processed %PID.

Complete the implementation of the ADJUST_NUMBERS method with a
return of messages. These are passed in the REPORTED parameter.
Listing 10.27 contains the ABAP source code.
LOOP AT pos_to_create INTO DATA(po_to_create).
...
  reported-purchaseorder = VALUE #( 
    BASE reported-purchaseorder
    FOR r IN return WHERE ( type = 'I' OR type <> 'W' )
    ( %tky = po_to_create-%tky
      PurchaseOrder = po_header_created-po_number
      %msg = me->new_message(
      id       = r-id
      number   = r-number
      severity = COND #( 
        WHEN r-type = 'I'
          THEN if_abap_behv_message=>severity-information
        WHEN r-type = 'W'
          THEN if_abap_behv_message=>severity-warning )
      v1 = r-message_v1
      v2 = r-message_v2
      v3 = r-message_v3
      v4 = r-message_v4 )
      ) ).
ENDLOOP. 
Listing 10.27     Populating the Reported Parameter from the BAPIRET2 Structure
Note that the ADJUST_NUMBERS method is already executed after the
point of no return within the save sequence and therefore no error
messages can be reported via the REPORTED parameter. If an error
does occur at this point, you must use RAISE SHORTDUMP to create a
dump.
10.4.6    Implementing Validations
To ensure that the creation of the purchase order with the given data
is possible, you’ll implement validations in this section that check the
data consistency before saving. In our use case, we want to examine
the following issues:

Have the mandatory fields for the purchase order quantity and
material been filled?
Is it generally possible to create a purchase order with the given
data?
Is the material number contained in the purchase order item valid?
To do this, you need to create two different validations—
validatePurchaseOrder and validateMaterial—in the behavior
definition for the ZI_RAP_PurchaseOrder_M entity with the alias name
PurchaseOrder (see Listing 10.28).
define behavior for ... alias PurchaseOrder 
{
  ...
  validation validatePurchaseOrder on save { create; }
  validation validateMaterial on save { create; }
} 
Listing 10.28     Declaring Validations for CDS Entity PurchaseOrder
The validatePurchaseOrder validation performs the entire check of
the purchase order creation. You can use the test indicator of the
BAPI BAPI_PO_CREATE1 for this. Since we can’t influence the call
sequence of the validations on the part of the RAP framework, we
don’t swap out the check for mandatory fields to a separate
validation, but additionally check the mandatory fields in the
validatePurchaseOrder validation. We call the BAPI only if these
mandatory fields have been filled.
The validateMaterial validation checks whether the specified
material is valid. Since the RAP business object doesn’t support an
update operation, you should use create to store the attachment
operation as a trigger condition for these validations.
For the error messages you also create a message class named
ZRAP_PO. To do this, you can use the shortcut (Ctrl) + (N) to open

the creation dialog in ADT and select the Message Class entry
under ABAP. Run through the creation wizard, providing the
message class with the messages listed in Table 10.4 in the process.
Save and close the message class afterwards.
Number Message Text
001
Material &1 is not intended for fast entry.
002
Material &1 is not active.
003
Please enter a purchase order quantity.
004
Please enter a material.
005
No authorization to create purchase orders.
Table 10.4     Messages of the ZRAP_PO Message Class
Implementing the validatePurchaseOrder Validation
Generate the method declarations again using the quick fix function
for the validation names in the behavior pool. Since the
validatePurchaseOrder validation has the create trigger condition,
you can use the keys parameter to read data about the created
instances from the transaction buffer (see Listing 10.29).
METHOD validatePurchaseOrder.
  DATA mandatory_field_missing TYPE abap_bool.
  READ ENTITIES OF ZI_RAP_PurchaseOrder_M IN LOCAL MODE
    ENTITY PurchaseOrder
      ALL FIELDS WITH CORRESPONDING #( keys )
        RESULT DATA(pos_to_create).
... 
Listing 10.29     Reading Instances to be Checked from the Transaction Buffer
Then, iterate over the instances to be checked, and check whether
the mandatory field of the purchase order quantity OrderQuantity
(Section 10.4.2) has been filled. If that’s not the case, output the

validation error via the FAILED parameter with reference to the
respective instance (<po_to_create>-%tky), marking the create
operation as incorrectly executed. For this purpose, you should fill
the REPORTED parameter with a suitable error message and refer to
the incorrect field (see Listing 10.30).
...
LOOP AT pos_to_create ASSIGNING FIELD-SYMBOL(<po_to_create>).
 
  CLEAR mandatory_field_missing.
 
  " Checking mandatory fields
  IF <po_to_create>-OrderQuantity IS INITIAL.
    failed-purchaseorder = VALUE #( BASE failed-purchaseorder
           ( %tky = <po_to_create>-%tky
             %create = if_abap_behv=>mk-on ) ).
 
    reported-purchaseorder = VALUE #( BASE reported-purchaseorder
           ( %tky = <po_to_create>-%tky
             %element-orderquantity = if_abap_behv=>mk-on
             %msg = me->new_message( severity = 
                                 if_abap_behv_message=>severity-error
                                     id = 'ZRAP_PO'
                                     number = '003' ) ) ).
    mandatory_field_missing = abap_true.
  ENDIF. 
Listing 10.30     Checking a Mandatory Field for the Purchase Order Quantity
After that, you want to check if the mandatory field Material is filled
by supplying the FAILED or REPORTED parameter, as shown in
Listing 10.30. In this case, the REPORTED parameter receives message
004 of the previously created message class and refers to the
Material field instead of the OrderQuantity field (see Listing 10.31).
...
  IF <po_to_create>-Material IS INITIAL.
    failed-purchaseorder = ...
    reported-purchaseorder = ...
    mandatory_field_missing = abap_true.
  ENDIF.
 
  IF mandatory_field_missing = abap_true.
    CONTINUE.
  ENDIF.
... 

Listing 10.31     Checking a Mandatory Field for the Material
The current loop pass will be interrupted by CONTINUE if a mandatory
field hasn’t been filled so that the subsequent BAPI call won’t take
place.
If the mandatory fields Material and OrderQuantity have been filled,
you can call the swapped out method create_purchase_order
described in Section 10.4.5, but this time for validation purposes in
test mode, using the import parameter as_test_run = abap_true (see
Listing 10.32).
...
  create_purchase_order(
    EXPORTING
      as_test_run = abap_true
      po_entity   = CORRESPONDING #( <po_to_create> )
    IMPORTING
      return      = DATA(return) ).
... 
Listing 10.32     Calling the create_purchase_order Method for Validation
The essential part of this validation is to evaluate the result (here, the
parameter return) and to report possible error situations. In the
event of an error, you can thus ensure that the RAP framework will
abort the save sequence. You must evaluate the result of the BAPI
call in the return parameter (see Listing 10.33).
...
    " Report error situation
    READ TABLE return
      WITH KEY type = 'E'
      TRANSPORTING NO FIELDS.
    IF sy-subrc EQ 0.
      "Report create operation as failed
      failed-purchaseorder = VALUE #( BASE failed-purchaseorder
                       ( %tky = <po_to_create>-%tky
                         %create = if_abap_behv=>mk-on ) ).
... 
Listing 10.33     Reporting the Create Operation for an Instance as Failed

Subsequently, you can still return corresponding messages via the
REPORTED parameter (see Listing 10.34).
...
      " Return error messages
      reported-purchaseorder = VALUE #( BASE reported-purchaseorder
          FOR r IN return WHERE ( type = 'E' )
          ( PurchaseOrder = <po_to_create>-PurchaseOrder
            %msg = me->new_message( id = r-id
            number = r-number
            severity = if_abap_behv_message=>severity-error
            v1 = r-message_v1
            v2 = r-message_v2
            v3 = r-message_v3
            v4 = r-message_v4 ) ) ).
    ENDIF.
  ENDLOOP.
ENDMETHOD. 
Listing 10.34     Returning Messages via the Reported Parameter
Implementing the validateMaterial Validation
The validateMaterial validation checks whether the transferred
material is valid for fast order entry. If that’s not the case, the
validation will report an error.
Open the behavior pool and navigate to the implementation class on
the Local Types tab. Start with the implementation of the
validateMaterial method. Again, first use EML to read all instances
relevant to the check from the transaction buffer (see Listing 10.35).
METHOD validateMaterial.
  READ ENTITIES OF ZI_RAP_PurchaseOrder_M IN LOCAL MODE
    ENTITY PurchaseOrder
      ALL FIELDS WITH CORRESPONDING #( keys )
        RESULT DATA(pos).
... 
Listing 10.35     Reading Instances from the Transaction Buffer for Validation
Then, iterate over the instances you’ve read and perform the data
validation. We assume that only instances with filled material number

are to be checked, since you have already implemented the
mandatory field check in the validatePurchaseOrder validation.
You should first read the validity of the material via the
read_cust_by_material method so that you can check the material
stored in the instances (see Listing 10.36).
...
  LOOP AT pos INTO DATA(po) WHERE NOT Material IS INITIAL.
    " Access data from table ZRAP_BO
    read_cust_by_material(
      EXPORTING
        material      = po-Material
      IMPORTING
        material_cust = DATA(material_cust) ).
... 
Listing 10.36     Reading Data for the Valid Material
Now, you need to implement the actual validation of the data. To do
so, you need to check whether the material in the instance is a valid
material at all (that is, whether it has been stored in table
ZRAP_A_PO_MAT). In addition, you must use the IsActive field to check
whether the material is active, provided it has been stored. The data
for the valid material is located in the material_cust data object.
You can report error situations via the REPORTED parameter using the
previously created messages in the ZRAP_PO message class. Use the
%element-material field to create a reference between the error
message and the actual field (see Listing 10.37). This mapping can
be evaluated by the SAP Fiori elements UI.
...
    IF NOT material_cust IS INITIAL.
      IF material_cust-IsActive NE abap_true.
        reported-purchaseorder = VALUE #( BASE reported-purchaseorder
                 ( %tky = po-%tky
                   %element-material = if_abap_behv=>mk-on
                   %msg = me->new_message( severity = 
                                 if_abap_behv_message=>severity-error
                    id  = 'ZRAP_PO'
                    number   = '002'

                    v1 = |{ po-Material ALPHA = OUT }| ) ) ).
      ENDIF.
    ELSE.
      reported-purchaseorder = VALUE #( BASE reported-purchaseorder
                 ( %tky = po-%tky
                   %element-material = if_abap_behv=>mk-on
                   %msg = me->new_message( severity = 
                     if_abap_behv_message=>severity-error
                   id       = 'ZRAP_PO'
                   number   = '001'
                   v1 = |{ po-Material ALPHA = OUT }| ) ) ).
    ENDIF.
  ENDLOOP.
ENDMETHOD. 
Listing 10.37     Running the Validation and Returning Error Messages
Now, save and activate the behavior pool. Thus, you have
implemented the necessary behavior to implement the create
purchase order function via a behavior definition and the behavior
pool.

10.5    Implementing the Delete Purchase
Order Function
In this section, we’ll implement the delete purchase order function.
To do this, we implement the SAVE_MODIFIED method of the save
handler “unlocked” by the unmanaged save implementation type. In
Section 10.3, you declared the standard operation delete for CDS
root entity ZI_RAP_PurchaseOrder_M and selected the save option with
unmanaged save. Both declarations are a prerequisite for implementing
the delete purchase order function now.
10.5.1    Save Sequence: Implementing the Deletion via
BAPI
The delete operation acts on an existing instance of a purchase
order, so you have to deal with competing data accesses here as
well. For example, one user may change a purchase order via SAP's
own SAP Fiori app or transaction, while another user may want to
delete the same purchase order via your RAP application. In this
case, deletion may not be possible due to the lock that has already
been set. Although the SAP standard takes care of processing the
purchase order within the application integrated via BAPIs, this only
takes effect in the save sequence of the RAP transaction model.
However, the lock has already been set by the ABAP RESTful
application programming model in the interaction phase.
For this reason, you must implement your own lock behavior for the
RAP business object and not use the generic lock behavior through
the managed business object provider. It’s necessary to add the

unmanaged keyword to the lock master declaration in the behavior
definition (see Listing 10.38).
define behavior for ZI_RAP_PurchaseOrder_M alias PurchaseOrder
lock master unmanaged
late numbering
... 
Listing 10.38     Declaration of an Unmanaged Lock
Create the relevant FOR LOCK handler method using the quick fix
function and then implement it. To do this, you should use the special
function modules for lock management (lock modules) that belong to
the purchase order (see Listing 10.39).
METHOD lock.
  LOOP AT keys ASSIGNING FIELD-SYMBOL(<k>).
    CALL FUNCTION 'ENQUEUE_EMEKKOS'
      EXPORTING
        ebeln          = <k>-PurchaseOrder
      EXCEPTIONS
        foreign_lock   = 1
        system_failure = 2
        OTHERS         = 3.
    CASE sy-subrc.
      WHEN 1. " Purchase order is already locked
        failed-purchaseorder = VALUE #( BASE 
          failed-purchaseorder
               ( purchaseorder = <k>-PurchaseOrder
                 %fail-cause = if_abap_behv=>cause-locked
               ) ).
        reported-purchaseorder = VALUE #( 
               BASE reported-purchaseorder
               ( purchaseorder = <k>-PurchaseOrder
                 %msg   = new_message(
                 id     = sy-msgid
                 number = sy-msgno
                 severity = if_abap_behv_message=>severity-error
                 v1 = sy-msgv1
                 v2 = sy-msgv2
                 v3 = sy-msgv3
                 v4 = sy-msgv4 ) ) ).
      WHEN OTHERS.
        RAISE SHORTDUMP NEW zcx_rap_purchaseorder( ... ).
    ENDCASE.
  ENDLOOP.
ENDMETHOD. 

Listing 10.39     Implementation of the For Lock Method
If the lock couldn’t be set for the particular <k>-PurchaseOrder order
number, you should populate the FAILED parameter with the
corresponding order number (<k>-PurchaseOrder) and the cause of
the error (if_abap_behv=>cause-locked). In addition, you should
return a message for the respective purchase order via the REPORTED
parameter. You can use the helper method new_message for this
purpose. If the lock couldn’t be set for technical reasons, you must
trigger a dump (RAISE SHORTDUMP).
Having implemented the setting of the lock, you can swap out the
deletion of a purchase order via BAPI to a separate method (as
we’ve already done with the creation of the purchase order). You can
declare this method in the implementation class in the behavior pool
(see Listing 10.40).
CLASS lhc_PurchaseOrder DEFINITION INHERITING FROM cl_abap_behavior_handler.
  PUBLIC SECTION.
...
    CLASS-METHODS delete_purchase_order
      IMPORTING
        VALUE(po_number)   TYPE ZI_RAP_PurchaseOrder_M-PurchaseOrder
        VALUE(as_test_run) TYPE abap_bool DEFAULT abap_true
      EXPORTING
        VALUE(return)      TYPE tt_return. 
Listing 10.40     Method Declaration for Deleting a Purchase Order
Listing 10.41 contains the implementation of this method.
...
METHOD delete_purchase_order.
  DATA: ls_po_header   TYPE bapimepoheader,
        ls_x_po_header TYPE bapimepoheaderx.
  * Delete means to set a deletion indicator in the purchase order
  ls_po_header-delete_ind = abap_true.
  ls_x_po_header-delete_ind = abap_true.
  CALL FUNCTION 'BAPI_PO_CHANGE'
    EXPORTING
      purchaseorder = po_number
      poheader      = ls_po_header
      poheaderx     = ls_x_po_header

      testrun       = as_test_run
    TABLES
      return        = return.
ENDMETHOD.
... 
Listing 10.41     Method Implementation for Deleting a Purchase Order
[ ! ]  Warning: Considering the Semantics of the Delete
Operation
Even though deleting a purchase order is implemented by means
of updating the purchase order by setting a deletion indicator
(delete_ind) in the BAPI BAPI_PO_CHANGE, the RAP business object
will provide the delete operation. On a logical level, this is a
deletion of a purchase order, not an update. The delete operation
occurs external to the business object, while the implementation of
this function occurs internally. The semantics of the interface and
the actual implementation are thus separated from each other.
Next, you want to implement the SAVE_MODIFIED method in the save
handler of the behavior pool. During the creation of the behavior
pool, the method has already been redefined there (see the
subsection about implementing the initOrgData determination in
Section 10.4.4). You can see the redefinition in Listing 10.42.
CLASS lsc_ZI_RAP_PurchaseOrder_M DEFINITION INHERITING FROM cl_abap_behavior_saver.
  PROTECTED SECTION.
    METHODS adjust_numbers REDEFINITION.
    METHODS save_modified REDEFINITION.
ENDCLASS. 
Listing 10.42     Redefinition of the SAVE_MODIFIED Method in the Save Handler
You can check the signature of the SAVE_MODIFIED method by placing
the cursor on the method name and pressing the (F2) function key.
Then, you’ll see the signature as shown in Figure 10.9.

Figure 10.9     Signature of the SAVE_MODIFIED Method
You can access the purchase orders to be deleted using the delete
parameter with the derived data type for deleting RAP entities (TYPE
REQUEST FOR DELETE). In Listing 10.43, you can see the
implementation of the SAVE_MODIFIED method. Iterate over the
purchase orders marked for deletion in the transaction buffer (LOOP
AT delete-purchaseorder) and call the previously implemented
method delete_purchase_order to delete the respective purchase
order.
...
METHOD save_modified.
  LOOP AT delete-purchaseorder ASSIGNING FIELD-SYMBOL(<po_to_delete>).
    lhc_purchaseorder=>delete_purchase_order(
      EXPORTING
        po_number   = <po_to_delete>-PurchaseOrder
        as_test_run = abap_false
      IMPORTING
        return      = DATA(return) ).
... 
Listing 10.43     Implementation of the SAVE_MODIFIED Method
After that, you can return messages about the saving process via the
REPORTED parameter. Since we’re in the late save sequence (i.e., the
point in time is after the point of no return, as is the case with the
ADJUST_NUMBERS method), no more error messages can be returned
here. If an error does occur at this point, you must create a dump
(RAISE SHORTDUMP) (see Listing 10.44).
...
  READ TABLE return WITH KEY type = 'E'
    INTO DATA(return_err).
  IF sy-subrc EQ 0.
    RAISE SHORTDUMP NEW zcx_rap_purchaseorder( ... ).

  ENDIF.
... 
Listing 10.44     Reporting an Error Situation via Dump After the Point of No Return
Evaluate the return parameter, which contains the messages of the
BAPI call, and return a corresponding message with reference to the
respective purchase order instance (<po_to_delete>-PurchaseOrder)
for each entry in the return parameter. Listing 10.45 contains the
ABAP source code for this.
...
    " Return messages
    reported-purchaseorder = VALUE #( BASE reported-purchaseorder
       FOR r IN return WHERE ( type = 'I' OR type <> 'W' )
       ( PurchaseOrder = <po_to_delete>-PurchaseOrder
         %msg = me->new_message(
         id       = r-id
         number   = r-number
         severity = COND #( WHEN r-type = 'I' THEN 
           if_abap_behv_message=>severity-information
                            WHEN r-type = 'W' THEN 
           if_abap_behv_message=>severity-warning )
          v1 = r-message_v1
          v2 = r-message_v2
          v3 = r-message_v3
          v4 = r-message_v4 ) ) ).
  ENDLOOP.
ENDMETHOD. 
Listing 10.45     Returning Messages in SAVE_MODIFIED via Reported Method
Then, save and activate the behavior pool.
10.5.2    Implementing a Validation
The delete purchase order function also includes a validation that
checks whether a deletion is possible at all. The procedure for
implementing this validation is identical to that for implementing the
validatePurchaseOrder validation from Section 10.4.6.

First, you need to declare the validateOnDelete validation in the
behavior definition:
...
  validation validateMaterial on save { create; }
  validation validateOnDelete on save { delete; }
... 
It has the trigger condition delete, so it gets called for instances
deleted in the transaction buffer during the save sequence.
Create and implement an appropriate method in the behavior pool
using the quick fix function. You can see the ABAP source code for
this validation in Listing 10.46.
METHOD validateOnDelete.
  LOOP AT keys ASSIGNING FIELD-SYMBOL(<k>).
    delete_purchase_order(
      EXPORTING
        po_number   = <k>-PurchaseOrder
        as_test_run = abap_true
      IMPORTING
        return      = DATA(return) ).
... 
Listing 10.46     Checking Whether it is Possible to Delete a Purchase Order
For deletion, only the reference to the respective instance via the key
value is necessary. The key values are available via the keys
parameter. Reading from the transaction buffer via READ ENTITIES is
therefore not necessary.
For this validation, you also report for each purchase order instance
to be deleted via the FAILED parameter whether or not the delete
operation can be performed (see Listing 10.47).
...
   " Report error situation
    READ TABLE return
      WITH KEY type = 'E'
      TRANSPORTING NO FIELDS.
    IF sy-subrc EQ 0.
      " Report delete operation as failed
      failed-purchaseorder = VALUE #( BASE 

                               failed-purchaseorder
                      ( PurchaseOrder = <k>-PurchaseOrder
                        %delete = if_abap_behv=>mk-on ) ).
... 
Listing 10.47     Filling the Failed Parameter for the Delete Operation
After that, you want to pass the error messages from the return
parameter to the REPORTED parameter again (see Listing 10.48).
Finally, save and activate the behavior pool.
...
      " Return error messages
      reported-purchaseorder = VALUE #( BASE reported-purchaseorder
          FOR r IN return WHERE ( type = 'E' )
          ( PurchaseOrder = <k>-PurchaseOrder
            %msg = me->new_message( id = r-id
            number = r-number
            severity = if_abap_behv_message=>severity-error 
            v1 = r-message_v1
            v2 = r-message_v2 
            v3 = r-message_v3
            v4 = r-message_v4 ) ) ).
    ENDIF.
  ENDLOOP.
ENDMETHOD.
... 
Listing 10.48     Filling the Reported Parameter

10.6    Defining Business Services
In the previous sections, you’ve implemented a RAP business object
named ZI_RAP_PurchaseOrder_M with data model and transactional
behavior. Now we want to provide users with an SAP Fiori app called
My Purchase Orders, in which they can view their placed purchase
orders based on the RAP business object and create new purchase
orders. You’ll use the projection layer to provide a service-specific
view of the RAP business object. In turn, you’ll expose the projection
layer artifacts as an OData service via a service definition and a
service binding so that the SAP Fiori app can consume them.
10.6.1    Setting up the Projection Layer for the My
Purchase Orders Application
In the following steps, you’ll create a CDS projection view and a
projection behavior definition to implement the projection layer.
First, you need to create a CDS projection view based on CDS root
entity ZI_RAP_PurchaseOrder_M:
1. Open the context menu of the ZI_RAP_PurchaseOrder_M entity in
the Project Explorer and select the menu item New Data
Definition.
2. The name of the CDS root entity is preset in the Referenced
Object field in the following creation dialog. Name the CDS
projection view “ZC_RAP_PurchaseOrderOwn_M” and enter a
description (see Figure 10.10).

Figure 10.10     Creating a CDS Projection View
3. In the dialog that follows next, you must select the Define
Projection View template. Complete the process by clicking the
Finish button.
The DDL source editor for the CDS projection view will open.
Perform a source code formatting using the shortcut (Ctrl) +
(Shift) + (F). Then, add the root keyword to the CDS entity, as
shown in Listing 10.49.
@EndUserText.label: 'My Purchase Orders'
@AccessControl.authorizationCheck: #CHECK
define root view entity ZC_RAP_PurchaseOrderOwn_M
  as projection on ZI_RAP_PurchaseOrder_M
{
  key PurchaseOrder,
      PurchaseOrderType,
      ... 
Listing 10.49     Defining a CDS Projection View as Root Entity
The investment process generates the selection list of the CDS
projection view from the projected CDS entity
ZI_RAP_PurchaseOrder_M. Remove the PurchasingOrganization,
PurchasingGroup, Supplier, CreatedByUser and CreationDate fields
from this selection list.

Add another field named MaterialName to the selection list of the
CDS projection view and an annotation named
ObjectModel.text.element to provide the material number with a
language-dependent descriptive text (the material short text) (see
Listing 10.50).
...
    PurchaseOrderDate,
    @ObjectModel.text.element: ['MaterialName']
    Material,
    _POMaterial._Material._Text.MaterialName as 
       MaterialName : localized,
    OrderQuantity,
... 
Listing 10.50     Defining a Descriptive Text for Material Number
The MaterialName field is a text element. The localized keyword is
used in the CDS projection view to resolve the text association
depending on the current logon language.
In the My Purchase Orders application, only the purchase orders that
the respective logged-in user has created are relevant. So, you
should add the CreatedByUser = $session.user filter criterion to the
CDS projection view via the where clause:
...
      _PurchaseOrderItem
}
where
  CreatedByUser = $session.user 
Save and activate the CDS projection view afterwards.
Based on the previously created CDS projection view, you can now
create a projection behavior definition so that you can expose the
desired transactional behavior. To do this, select New Behavior
Definition from the context menu of CDS projection view
ZC_RAP_PurchaseOrderOwn_M. You can optionally enter a new
description in the creation dialog; the other input fields are already

prefilled and can’t be modified. Go through the dialog and finish the
process by clicking the Finish button.
A generated BDL source code will open; in there, you should add the
alias name PurchaseOrder (see Listing 10.51). Save and activate the
projection behavior definition afterwards.
projection;
 
define behavior for ZC_RAP_PurchaseOrderOwn_M alias PurchaseOrder
{
  use create;
  use delete;
} 
Listing 10.51     Projection Behavior Definition for the My Purchase Orders Application
10.6.2    Creating a Service Definition
Next, you need to create a service definition named ZRAP_PO_Own_M
with the description “Service definition, My Purchase Orders” based
on the previously created CDS projection view
ZC_RAP_PurchaseOrderOwn_M. Proceed as described in Chapter 9,
Section 9.4.1. Specify the semantic alias PurchaseOrder for the
exposed CDS entity ZC_RAP_PurchaseOrderOwn_M using as. In
Listing 10.52 you can see the complete SDL source code.
@EndUserText.label: 'Service definition, My Purchase Orders'.
define service ZRAP_PO_Own_M {
  expose ZC_RAP_PurchaseOrderOwn_M as PurchaseOrder;
} 
Listing 10.52     Service Definition ZRAP_PO_Own_M
10.6.3    Creating a Service Binding
Then, create a service binding named ZUI_RAP_PO_OWN_M_O2 for
service definition ZRAP_PO_Own_M. Proceed as described in Chapter 9,

Section 9.4.2. Use the value OData V2 - UI as the Binding Type.
Then, publish the service binding using the Publish button. You can
see the already published service binding in Figure 10.11.
Figure 10.11     Published Service Binding for the Purchase Order Entity Set

10.7    Implementing Authorization Checks
In this section, you’ll implement authorization checks for the fast
purchase order entry application.
10.7.1    Access Controls for Read Access
CDS access controls protect the records of a CDS entity from
unauthorized access. However, this access protection is only
effective locally (see Chapter 2, Section 2.5). The CDS projection
view ZC_RAP_PurchaseOrderOwn_M created in Section 10.6.1 uses the
CDS view ZI_RAP_PurchaseOrder_M as a data source, which in turn is
based on the standard view I_PurchaseOrderItemAPI01. Thus, the
CDS access control of the same name for the order item in the VDM
does not take effect for our entities, ZI_RAP_PurchaseOrder_M or
ZC_RAP_PurchaseOrder_M. You need your own access control. In
contrast, the respective access controls of the associated CDS
entities take effect for read accesses defined via associations.
Since our RAP business object is based on standard CDS entities of
the VDM, you can use the CDS access controls defined there for
read accesses. You can check directly in the system if there’s an
access control for the used CDS entity I_PurchaseOrderItemAPI01:
1. Open the CDS entity I_PurchaseOrderItemAPI01 in ADT.
2. Run a where-used list using the shortcut (Ctrl) + (Shift) +
(G).
3. In the search result, you can see the CDS access control of the
same name I_PurchaseOrderItemAPI01 (Access Control)
(see Figure 10.12).

Figure 10.12     Result of Searching for a CDS Access Control for the
I_PurchaseOrderAPI01 CDS Entity
You can create your own access control for the CDS entity
ZI_RAP_PurchaseOrder_M based on this standard access control:
1. Open the context menu of the CDS entity in the Project
Explorer and select the New Access Control entry.
2. In the Name field, you should use the same name as the CDS
entity you want to protect (here, ZI_RAP_PurchaseOrder_M).
3. Your access control should inherit from CDS entity
I_PurchaseOrderItemAPI01 (inheriting conditions from entity)
so that you can use the authorization checks defined there
directly and don’t need to copy them. The prerequisite for this is
that the fields relevant for the authorization check must be part
of the inheriting CDS entity, such as the Plant field, for example.
You can see the data control language (DCL) source code for
your access control in Listing 10.53.
@EndUserText.label: 'CDS access control'
@MappingRole: true
define role ZI_RAP_PurchaseOrder_M {
   grant select on ZI_RAP_PurchaseOrder_M
   where
   inheriting conditions from entity I_PurchaseOrderItemAPI01;
} 
Listing 10.53     Access Control for ZI_RAP_PurchaseOrder_M CDS Entity
4. Secure and activate the access control.
Now, you should create another CDS access control for the CDS
projection view ZC_RAP_PurchaseOrderOwn_M. This access control
inherits the authorization check of the projected CDS view

ZI_RAP_PurchaseOrder_M. You can see the DCL source code in
Listing 10.54. Save and activate this access control as well.
@EndUserText.label: 'CDS access control'
@MappingRole: true
define role ZC_RAP_PurchaseOrderOwn_M {
    grant select on ZC_RAP_PurchaseOrderOwn_M
    where
    inheriting conditions from entity ZI_RAP_PurchaseOrder_M;
} 
Listing 10.54     CDS Access Control for CDS Projection View
ZC_RAP_PurchaseOrderOwn_M
10.7.2    Access Controls for Write Access
Now, open the behavior definition of the CDS root entity
ZI_RAP_PurchaseOrder_M and add the statement authorization master
( instance ). This way you can enable instance-based authorization
checking (see Listing 10.55). Save and activate the behavior
definition afterwards.
...
define behavior for ZI_RAP_PURCHASEORDER_M alias PurchaseOrder
lock master
late numbering
authorization master ( instance )
etag master LastChangeDateTime
... 
Listing 10.55     Declaring Authorization Checks
In the implementation class in the behavior pool, you can create the
method to run the authorization check using the quick fix function.
Listing 10.56 shows the method declaration.
...
METHODS get_instance_authorizations 
  FOR INSTANCE AUTHORIZATION
    IMPORTING keys REQUEST requested_authorizations FOR PurchaseOrder
  RESULT result.
... 

Listing 10.56     Method Declaration for the Instance-Based Authorization Check
You can determine the authorization objects used with the respective
activities from the BAPI documentation. In our example, these are
the following authorization objects: M_BEST_BSA, M_BEST_EKO, and
M_BEST_EKG. Even if the BAPIs themselves perform authorization
checks, you should implement these checks in the RAP business
object. This way, you can use the capabilities of the RAP framework
and ensure, for example, that no other person can make
unauthorized changes to the transaction buffer.
[+]  Tip: Using an Authorization Trace
To find out which authorizations are being used, you can also
activate an authorization trace in Transaction STAUTHTRACE and
reproduce the desired behavior in the standard application, for
example, creating a purchase order. In the SAP BTP, ABAP
environment, an SAP Fiori app is available for activating and
evaluating authorization checks (see Chapter 12).
Now, open the behavior pool and implement the
get_instance_authorizations method to check the specified
authorization objects (see Listing 10.57). Then activate the behavior
pool.
CLASS lhc_PurchaseOrder IMPLEMENTATION.
...
  METHOD get_instance_authorizations.
    READ ENTITY ZI_RAP_PurchaseOrder_M
      ALL FIELDS
        WITH CORRESPONDING #( keys )
      RESULT DATA(pos_for_auth_check).
    " 02 - Change => Is deletion allowed
    LOOP AT pos_for_auth_check ASSIGNING FIELD-SYMBOL(<po_for_auth_check>).
      AUTHORITY-CHECK OBJECT 'M_BEST_EKO'
        ID 'EKORG' FIELD <po_for_auth_check>-PurchasingOrganization
        ID 'ACTVT' FIELD '02'.
      IF sy-subrc <> 0.

        APPEND VALUE #( PurchaseOrder = <po_for_auth_check>-
                          PurchaseOrder
                        %delete = if_abap_behv=>auth-
                          unauthorized ) TO result.
        CONTINUE.
      ENDIF.
      " ... Check authorization object M_BEST_EKG, M_BEST_BSA
    ENDLOOP.
  ENDMETHOD.
... 
Listing 10.57     Implementation of Instance-Based Authorization Checks
In the ABAP RESTful application programming model, you can
protect the create operation from unauthorized access using the
global authorization check. In our use case, however, the check must
be dependent on the purchasing organization, and data for the
instances is not available in the global authorization check. For this
reason, you can’t use the global authorization check here, but must
provide the create operation in the behavior definition with a
precheck and perform the authorization check there (see
Listing 10.58).
define behavior for ZI_RAP_PurchaseOrder_M alias PurchaseOrder
...
{
  create ( precheck );
  internal update;
  delete;
...
} 
Listing 10.58     Create Operation with the Precheck Option
Now, save and activate the behavior definition and create a FOR
PRECHECK method in the implementation class using the quick fix
function. Implement them as shown in Listing 10.59.
METHOD precheck_create.
  DATA(org_data) = read_org_data( ).
  LOOP AT entities ASSIGNING FIELD-SYMBOL(<po>).
    AUTHORITY-CHECK OBJECT 'M_BEST_EKO'
      ID 'EKORG' FIELD org_data-purch_org
      ID 'ACTVT' FIELD '01'.

    IF sy-subrc <> 0.
      failed-purchaseorder = VALUE #( BASE failed-purchaseorder
           ( %cid = <po>-%cid
             %create = if_abap_behv=>auth-unauthorized ) ).
      reported-purchaseorder = VALUE #( 
          BASE reported-purchaseorder
          ( %cid = <po>-%cid
            %msg = me->new_message( severity = 
                                 if_abap_behv_message=>severity-error
             id = 'ZRAP_PO' 
             number   = '005' ) ) ).
      CONTINUE.
    ENDIF.
    " Check authorization object M_BEST_EKG
...
  ENDLOOP.
ENDMETHOD. 
Listing 10.59     Implementation of the FOR PRECHECK Method for Authorization Checks
Then, save and activate the behavior pool again.

10.8    Creating an SAP Fiori Elements User
Interface
Based on the previously created projection layer and the published
service binding, in this section we’ll create an SAP Fiori elements
application that allows users to select, create, view, and delete their
purchase orders.
10.8.1    Creating a Metadata Extension
UI annotations are best placed in a metadata extension to swap out
the presentation layer of the application in the backend into a
separate artifact. To make this possible, you first need to add the
annotation @Metadata.allowExtensions: true to the CDS projection
view (see Listing 10.60). Then, activate the CDS entity.
@AccessControl.authorizationCheck: #CHECK
@EndUserText.label: 'My Purchase Orders'
@Metadata.allowExtensions: true
define root view entity ZC_RAP_PurchaseOrderOwn_M
... 
Listing 10.60     Allowing Metadata Extensions to the CDS Projection View
[»]  Allowing Metadata Extensions
We’d like to point out here that adding this annotation isn’t done
only out of technical necessity, but is done deliberately. By using it,
you allow the addition of a metadata extension to a CDS entity and
thus to open this CDS entity for adaptations “from outside.” If the
RAP application is made available outside the sphere of influence
of your organization or organizational unit, the metadata extension

can be used there as well, which is why you must support the
technical contract throughout the application lifecycle.
Now, you can create a metadata extension for CDS projection view
ZC_RAP_PurchaseOrderOwn_M. Proceed as described in Chapter 9,
Section 9.5. You can see the CDS source code for the metadata
extension with the UI annotations in Listing 10.61.
@Metadata.layer: #CORE
@UI.headerInfo: { typeName: 'My purchase order',
                  typeNamePlural: 'My purchase orders' }
annotate view ZC_RAP_PurchaseOrderOwn_M with
{
  @UI.facet: [{ id: 'Identification',
                type: #IDENTIFICATION_REFERENCE,
                label: 'Purchase order',
                position: 10,
                purpose: #STANDARD }]
 
  @UI.selectionField: [{ position: 10 }]
  @UI.lineItem: [{ position: 10 }]
  @UI.identification: [{ position: 10 }]
  PurchaseOrder;
 
  @UI.selectionField: [{ position: 20 }]
  @UI.lineItem: [{ position: 20 }]
  PurchaseOrderDate;
 
  @UI.selectionField: [{ position: 30 }]
  @UI.lineItem: [{ position: 30 }]
  @UI.identification: [{ position: 20 }]
  Material;
 
  @UI.lineItem: [{ position: 40 }]
  @UI.identification: [{ position: 40 }]
  OrderQuantity;
} 
Listing 10.61     Metadata Extension with UI Annotations
Then, activate the metadata extension. After that, you can return to
the service binding and test the UI annotations using the preview
function for CDS entity ZC_RAP_PurchaseOrderOwn_M. You’ll notice
when creating a purchase order using the SAP Fiori elements user
interface that there’s no search help for the Material input field.

However, we want to give users the opportunity to directly select
those materials that are valid for fast order entry via that type of a
search help.
To do this, create a new CDS entity based on CDS entity
ZI_RAP_PO_Material, which will act as a search help for the valid
materials. For this purpose, you must open the context menu for
CDS entity ZI_RAP_PO_Material and select New Data Definition.
Choose “ZI_RAP_PO_MaterialActive_VH” as the name and assign
the description “Valid materials, search help.” You can see the
source code of the search help view in Listing 10.62.
...
define view entity ZI_RAP_PO_MaterialActive_VH
  as select from ZI_RAP_PO_Material
{
      @ObjectModel.text.association: '_MaterialText'
  key Material,
      _Material.MaterialBaseUnit as MaterialBaseUnit,
      @Consumption.hidden: true
      _Material.Material         as MaterialForText,
      _Material._Text            as _MaterialText
}
where
IsActive = 'X' 
Listing 10.62     CDS Entity as a Search Help for Valid Materials
The material short text as descriptive text for the material number
gets implemented via the annotation
@ObjectModel.text.association: '_MaterialText'. Matching the use
case of the search help, the CDS entity selects only valid materials
and also implements the condition IsActive = 'X' in the where
clause. Save and activate the CDS entity created for the search
help.
Include the CDS entity in the metadata extension via the UI
annotation @Consumption.valueHelpDefinition as a search help for
the Material field (see Listing 10.63). This is comparable to the

classic search help binding in structured data types in the ABAP
dictionary.
...
@Consumption.valueHelpDefinition: [{ entity: {
  name : 'ZI_RAP_PO_MaterialActive_VH',
  element: 'Material' },
  additionalBinding: [{ element: 'MaterialBaseUnit', 
                        localElement: 
                     'PurchaseOrderQuantityUnit',
                        usage: #RESULT }] } ]
Material;
... 
Listing 10.63     Search Help Binding for the Material Field
Save and activate the metadata extension afterwards. You can now
use the preview function for the PurchaseOrder entity set in the
service binding again to test the search help.
[»]  CDS Entity for Search Help in Service Binding
If you open the service binding again, you’ll notice that the CDS
entity for the search help is now also automatically exposed there,
without you having to add it manually. This is necessary because
the user interface must also display the search help remotely via
OData and perform the data selection.
10.8.2    Generating and Deploying the Application
Now you can create an SAP Fiori elements application based on the
published service binding using SAP Fiori tools in Visual Studio
Code. Proceed as described in Chapter 9, Section 9.9.
Open Visual Studio Code and start the application generator. In the
course of the wizard, select the parameters from Table 10.5 for

generating the application. Based on this information, the SAP Fiori
tools will generate your application.
Range • Parameters
Value
Floorplan Selection • Floorplan
List Report Object
Page
Data Source and Service Selection •
Service
ZUI_RAP_PO_OWN_M_O2
Entity Selection • Main entity
PurchaseOrder
Project Attributes • Module name
purchaseorderui
Project Attributes • Application title
Fast order entry
Deployment Configuration • Name
ZPO_OWN_UI
Table 10.5     Values for Generating the SAP Fiori Elements Application
Deploying the application in the ABAP backend is also done as
described in Chapter 9, Section 9.9.
[+]  Tip: Possible Expansion Stages
If you wish, you can further extend the application you developed
in this chapter. Possible expansion stages could be:
Using draft handling (special feature for late numbering:
additional key field DRAFTUUID in draft table necessary)
Creating an EML consumer to create purchase orders based on
the RAP business object.
Representing the valid material as a separate RAP business
object and generating a separate SAP Fiori elements
application for this object.

Inserting another projection layer for the backend administration
of orders, in which, for example, more fields are displayed for
agents or in which there’s an additional “Release purchase
order” action.
Creating a new SAP Fiori elements application based on this
projection layer.

11    Unmanaged Scenario:
Reusing Existing Source Code
The unmanaged scenario is another implementation variant
in the ABAP RESTful application programming model. In
contrast to the managed scenario, here you are responsible
for implementing the runtime behavior of your business
object yourself. We’ll also describe how you can use this
scenario for development purposes based on an example.
It makes sense to use the unmanaged implementation type if you want
to reuse existing application code in your system in the ABAP
RESTful application programming model (Brownfield approach). The
code used may be methods or function modules that you can
usefully employ in the interaction phase and the save sequence to
manage the transaction buffer, perform checks, or persist the data.
In this chapter, we’ll define and implement the behavior of a business
object based on an existing business logic. Our goal here is to clarify
the differences between the unmanaged and managed implementation
types. After describing the use case in Section 11.1, we’ll first turn to
the structure of the existing application in Section 11.2. Based on the
existing database tables, we’ll then create a CDS-based data model
in Section 11.3. Then, on the basis of the data model, the creation of
the behavior definition (Section 11.4) and the behavior
implementation (Section 11.5) will follow. Finally, we will create a
business service in Section 11.6.

[»]  Using the Unmanaged Implementation Type
You should only use the unmanaged implementation type if there’s
existing application code that can and should be used. Don’t
create application code just to use it in an unmanaged scenario.
Because of the reduced development effort and the associated
time savings, your preferred approach should generally be the
managed scenario (with its variants, such as unmanaged save).
11.1    Description of the Use Case
Let's assume that a legacy application exists in your SAP S/4HANA
system that’s used to enter and change sales order data (which can’t
be maintained in the standard SAP system). The interface
technology of this application is based on SAP GUI or Web Dynpro.
The entered data is validated by the application, supplemented with
further data according to the entries made, and finally persisted in
customer-specific tables. When a certain status is reached, a
standard SAP sales order can be created for the entered data in
order to invoice the order and establish the connection to financial
accounting. The existing application thus consists of customer-
specific tables and application logic based on them. The logic is
partially encapsulated in function modules. These function modules
are responsible for updating the application's transaction buffer, for
checking and supplementing the data, and for persisting it in the
database.
Based on this, we’ll create a new application called MySalesOrder
using the unmanaged scenario of the ABAP RESTful application
programming model. You can get a first impression of the finished
application in Figure 11.1 and Figure 11.2.

Figure 11.1     List View in the MySalesOrder Application
Figure 11.2     Detailed View of the MySalesOrder Application
We’ll implement the sample application on an on-premise system
with the SAP S/4HANA 2020 status.

11.2    Description of the Existing Application
As described in Section 11.1, the existing application is based on Z
tables, where additional sales order data can be managed. The
hierarchy of the Z tables is based on the standard sales order data
from the sales and distribution (SD) component of the SAP system
(tables VBAK, VBAP, etc.). In our scenario, however, we’ll focus on
using the header data of the Z sales order, as it is sufficient to
illustrate the differences between the managed and unmanaged
scenarios. Also, we won’t use the draft functionality in our sample
application. Its use was described in the practical example in
Chapter 9.
[»]  Draft Handling in the Unmanaged Scenario
It’s certainly possible to use managed draft handling in the
unmanaged scenario. So, you won’t have to make do without its
advantages. However, for the purpose of this chapter, using the
draft functionality is irrelevant. In practice, however, you should
use draft handling for UI applications.
11.2.1    Database Tables
In our sample application, the customer-specific order data of the
existing application is saved at the header level in table ZVBAK.
Table 11.1 shows the most important fields of this customer-specific
database table.
Column
Meaning
Data Element Key Field

Column
Meaning
Data Element Key Field
ID
ID of the Z sales order
ZID
Yes
KUNNR
Sold-To-Party
kunag
No
MEMO1
Note 1
TEXT30
No
MEMO2
Note 2
TEXT30
No
ZEITPKT UTC time stamp
TIMESTAMPL No
NETWR
Net value
NETWR
No
WAERK
Currency
WAERK
No
STATUS
Status of the Z sales order ZSTATUS
No
Table 11.1     Z Sales Order Header
The data element ZID is of data type NUMC with length 10. The ID is
simply incremented continuously. The data element ZSTATUS refers to
a domain of the same name of type CHAR with length 1. The two
fixed values—0 (incomplete) and 1 (complete)—are stored for this
domain.
In addition to the fields listed in Table 11.1, the ZVBAK table contains
other fields. However, for our MySalesOrder application we only
need the fields described.
We’ve already described the procedure for creating database tables
in the ABAP dictionary in Chapter 9, Section 9.2.1. For this sample
application, you need to create a package named ZRAP_UNMANAGED as
a subpackage of ZRAP_DEMO for database table ZVBAK, for the two data
elements, and for the domain.
The definition of table ZVBAK is shown in Listing 11.1.
@EndUserText.label: 'Z Sales order'
@AbapCatalog.enhancementCategory: #EXTENSIBLE_ANY
@AbapCatalog.tableCategory: #TRANSPARENT

@AbapCatalog.deliveryClass: #A
@AbapCatalog.dataMaintenance: #RESTRICTED
define table zvbak {
  @AbapCatalog.foreignKey.screenCheck : true
  key mandt : mandt not null
    with foreign key t000
      where mandt = zvbak.mandt;
  key id    : zid not null;
  @AbapCatalog.foreignKey.screenCheck : true
  kunnr     : kunag
    with foreign key kna1
      where mandt = zvbak.mandt
        and kunnr = zvbak.kunnr;
  memo1     : text30;
  memo2     : text30;
  zeitpkt   : timestampl;
  @Semantics.amount.currencyCode : 'zvbak.waerk'
  netwr     : netwr;
  @AbapCatalog.foreignKey.screenCheck : true
  waerk     : waerk
    with foreign key tcurc
      where mandt = zvbak.mandt
        and waers = zvbak.waerk;
  status    : zstatus;
} 
Listing 11.1     Definition of Database Table ZVBAK
[»]  Establishing the Initial Situation
By creating the ABAP dictionary objects in this section and by
creating the function group in Section 11.2.2, you get the initial
situation that we can then use as a basis in the following sections
with the unmanaged scenario. In a real scenario, these objects
should already exist; only then does it make sense to use the
unmanaged implementation type. So, here we're artificially setting up
the common baseline.
As additional ABAP dictionary objects, the existing application uses
a structure named ZVBAK_BUFFER (see Listing 11.2) and a table type
named ZVBAK_BUFFER_T based on this structure.
@EndUserText.label: 'Transaction buffer ZVBAK'
@AbapCatalog.enhancementCategory: #EXTENSIBLE_ANY

define structure zvbak_buffer {
  data    : include zvbak;
  chngind : cdchngind;
} 
Listing 11.2     ZVBAK_BUFFER Structure
For handling the messages, there’s the table type ZT_MESSAGE for the
structure SYMSG. The messages are maintained in the message class
ZVB_MESSAGES (see Figure 11.3).
Figure 11.3     Message Class ZVB_MESSAGES
For the lock logic, the existing application uses the EZ_ZVBAK lock
object (see Figure 11.4).
Figure 11.4     Lock Object EZ_ZVBAK
You should also create these ABAP dictionary objects in your
ZRAP_UNMANAGED package. All development objects can also be found

in the download material for this book at www.sap-press.de/5412.
11.2.2    Source Code of the Existing Application
Unlike the managed scenario, in the unmanaged scenario you are
responsible for implementing the CRUD operations. This means you
must implement methods intended for this purpose in the interaction
phase and in the save sequence. To do this, in our example, you use
the existing API of the legacy application as a function group, which
we’ll describe in this section, so that you can recreate it as a
common starting point. For this purpose, you want to create an API
function group that you’ll reuse as part of the behavior
implementation of the business object.
[»]  Usable APIs
To use an API intelligently in the unmanaged scenario, it should be
independent of the UI technology and protocol.
The function group consists of several function modules for
managing the transaction buffer of the existing application, a function
module for persisting the data in the database, and a function
module for locking a sales order. It also contains business logic in
the form of function modules for supplementing and checking the
data. Errors occurring during processing are returned as
corresponding messages (from message class ZVB_MESSAGES) in
tables.
Create the function group ZVB_API with the internal table
gt_buffer_zvbak in the top include to manage the transaction buffer
as follows:

FUNCTION-POOL zvb_api. 
DATA gt_buffer_zvbak TYPE zvbak_buffer_t. 
First, you must create the function modules for managing the
transaction buffer in it. You need one function module each for
reading, creating, updating, and deleting the data. Start with function
module Z_VB_READ for reading the transaction data (see Listing 11.3).
FUNCTION z_vb_read
  IMPORTING
    iv_id TYPE zid
  EXPORTING
    es_zvbak TYPE zvbak
    et_messages TYPE zt_message.
 
  CLEAR es_zvbak.
  CLEAR et_messages.
 
  SELECT SINGLE * FROM zvbak WHERE id = @iv_id 
    INTO @es_zvbak.
 
  READ TABLE gt_buffer_zvbak INTO DATA(ls_buffer_zvbak) 
    WITH KEY id = iv_id.
  IF sy-subrc = 0.
    CASE ls_buffer_zvbak-chngind.
      WHEN 'U'.
        es_zvbak = CORRESPONDING #( ls_buffer_zvbak ).
      WHEN  'D'.
        CLEAR es_zvbak.
      WHEN 'I'.
        es_zvbak = CORRESPONDING #( ls_buffer_zvbak ).
    ENDCASE.
  ENDIF.
 
  IF es_zvbak IS INITIAL.
    MESSAGE ID 'ZVB_MESSAGES' TYPE 'E' NUMBER '001' 
      WITH iv_id INTO DATA(lv_msg).
    et_messages = VALUE #( ( CORRESPONDING #( syst ) ) ).
  ENDIF.
 
ENDFUNCTION. 
Listing 11.3     Function Module Z_VB_READ for Reading the Z Sales Order Data from the
Transaction Buffer
The Z_VB_READ function module returns the data for an instance of
the Z sales order from the transaction buffer. If there’s no entry in the
buffer for the instance ID, the status will be read from the database.

The source code of the API function modules described briefly below
can be found in the book’s download material at www.sap-
press.com/5647.
Function module Z_VB_CREATE
Next, you need to create the Z_VB_CREATE function module to
create an entry in the transaction buffer. The function module
Z_VB_CREATE creates an entry in the transaction buffer that
corresponds to the data record passed. To assign the ID as the
key of the Z sales order, the next higher ID to be assigned is
determined in each case. The ZEITPKT field, which contains the
time stamp of the installation or the last change, is also filled in at
this point. It’s to be used as an entity tag (ETag) field for checking
during optimistic locking. Finally, you need to set the change
indicator 'I' in the CHNGIND field.
Function module Z_VB_UPDATE
The function module Z_VB_UPDATE enables you to create an entry in
the transaction buffer to update a data record. To do this, the
change indicator 'U' is set in the CHNGIND field and the time stamp
is redetermined in the same way as for function module
Z_VB_CREATE.
Function module Z_VB_DELETE
The function module Z_VB_DELETE creates an entry with deletion
indicator 'D' in the CHNGIND field for the transferred ID in the
transaction buffer.
With this, you have created the four core API function modules that
are used in the existing application to manage CRUD operations in
the transaction buffer. In addition to these four function modules, the
API provides a few more. With the help of function block
Z_VB_INITIALZE you can delete the transaction buffer completely,

while function block Z_VB_READ_ALL enables you to read the
transaction buffer in its entirety.
In addition to the function modules for managing the transaction
buffer, the API function group contains other function modules that
can be used when implementing the business object behavior. You
can also find their source code in the book’s download material:
Function module Z_VB_LOCK
Function module Z_VB_LOCK is used to lock data records. It can be
used to set a lock for an order ID. In case of an error, a message
will be returned.
Function module Z_VB_SAVE
To persist the data from the transaction buffer, you can use
function module Z_VB_SAVE. This function module adds entries to,
updates entries in, or deletes entries from table ZVBAK according to
the change indicator set in the CHNGIND field in the transaction
buffer.
Function module Z_VB_CHECK
The API provides function module Z_VB_CHECK to check the data.
This function module checks that the transferred net value isn’t
negative, and also ensures that a non-zero net value is only
possible if a currency is also specified.
Function module Z_VB_ENRICH
Function module Z_VB_ENRICH supplements the data. The Status
field is set to 0 or 1 depending on the completeness of a record.
This completes the API of the legacy application. If you’ve created
these function modules as described, you have created the
described initial situation for the application you want to develop.

11.3    Extending the Data Model
The structure of the CDS data model you need to create based on
the Z tables for your RAP application doesn’t differ for the different
implementation types. Even in the managed scenario, you read the
data from the database tables with basic interface views and
specialize them for each application in the CDS projection views. So,
you can proceed exactly as described in the example in Chapter 9.
In our simple example, the modeling of the business object is based
only on database table ZVBAK, which already exists in the legacy
application. As in the approach described in Chapter 9, we’ll start by
creating the interface layer:
1. Open the context menu of the database table ZVBAK and select
New Data Definition.
2. Enter the name “ZI_MySalesOrder” and a description, and select
the package ZRAP_UNMANAGED (see Figure 11.5). Then, click the
Next button.
Figure 11.5     Creating Basic Interface View ZI_MySalesOrder

3. Next, select the Define View Entity template.
4. The fields from table ZVBAK have already been suggested in the
element list. Assign suitable aliases for the individual fields, and
for the CDS view. Then, add the root keyword to the define view
statement. Before the NetAmount field, you need to add the
annotation @Semantics.amount.currencyCode: 'Currency' to
create the currency reference for the amount field. Use the
annotation
@Semantics.systemDateTime.localInstanceLastChangedAt: true
to define the LocalLastChangedAt field as an ETag field for
optimistic locking. Listing 11.4 contains the finished basic
interface view.
@AbapCatalog.viewEnhancementCategory: [#NONE]
@AccessControl.authorizationCheck: #CHECK
@EndUserText.label: 'MySalesOrder Interface View'
@Metadata.ignorePropagatedAnnotations: true
@ObjectModel.usageType:{
    serviceQuality: #X,
    sizeCategory: #S,
    dataClass: #MIXED
}
define root view entity ZI_MySalesOrder 
  as select from zvbak as MySalesOrder
{
  key id      as SalesOrderID, 
      kunnr   as Customer,
      memo1   as MemoText1,
      memo2   as MemoText2,
      @Semantics.systemDateTime.localInstanceLastChangedAt: true
      zeitpkt as LocalLastChangedAt,
      @Semantics.amount.currencyCode: 'Currency'
      netwr as NetAmount,
      waerk as Currency,
      status as Status
} 
Listing 11.4     Basic Interface View ZI_MySalesOrder
You now have created the interface layer of your CDS data model. In
the next step, you’ll create a CDS projection view, in which you

further specify the data model for your use case. This step includes
the following specifications:
Element list
Layout
Texts
Input help
Free text search
Create the CDS projection view as follows:
1. Open the context menu for your basic interface view
ZI_MySalesOrder and select New Data Definition.
2. Enter the name “ZC_MySalesOrder” and a description, and
select the package ZRAP_UNMANAGED (see Figure 11.6).
Figure 11.6     Creating the Interface View ZC_MySalesOrder
3. Then, use the Define Projection View template, and finish the
installation by clicking the Finish button.
4. Since you created the CDS projection view with reference to
CDS interface view ZI_MySalesOrder, the fields of the latter are

copied to the element list. All of these fields should also be used
in your UI service; so, you don't need to make any changes
here.
5. Add the root keyword to the define view statement (analogous
to the procedure for defining the basic interface view
ZI_MySalesOrder). Then, add the annotation @Search.searchable:
true to the annotations at the level of the view definition. This
will activate the free text search functionality. At the view
element level, you can then determine those fields that will be
used as search targets for the free text search. To do this, use
the annotation @Search.defaultSearchElement: true. For the
Customer field, you need to define an input help by adding the
following annotation:
@Consumption.valueHelpDefinition: [
{ entity:  { name:    'I_Customer_VH',
             element: 'Customer' }
}] 
[»]  CDS Entity for the Input Help
For the input help, you can use any CDS entity that contains the
required values of the input field in the user interface.
6. In the projection layer, you also enrich the data model with
layout information. The best solution is to swap out these
annotations of the UI domain to a metadata extension. The
prerequisite for creating a metadata extension is that this has
been explicitly allowed for the CDS view to be extended.
Consequently, you can add the annotation
@Metadata.allowExtensions: true at the view level.
You can see the finished CDS projection view in Listing 11.5.

@EndUserText.label: 'MySalesOrder Projection View'
@AccessControl.authorizationCheck: #CHECK
@Search.searchable: true
@Metadata.allowExtensions: true
define root view entity ZC_MySalesOrder
  as projection on ZI_MySalesOrder as MySalesOrder
{
  key SalesOrderID,
      @Consumption.valueHelpDefinition: [
      { entity:  { name:    'I_Customer_VH',
                   element: 'Customer' }
      }]
      Customer,
      @EndUserText.label: 'Note 1'
      @Search.defaultSearchElement: true
      MemoText1,
      @EndUserText.label: 'Note 2' 
      @Search.defaultSearchElement: true 
      MemoText2,
      LocalLastChangedAt,
      NetAmount,
      Currency,
      status
} 
Listing 11.5     CDS Projection View ZC_MySalesOrder
Now, add the UI metadata to your CDS data model:
1. Open the context menu of your CDS projection view
ZC_MySalesOrder and select New Metadata Extension.
2. Follow the conventions and choose the name identical to the
CDS projection view ZC_MySalesOrder to be annotated (see
Figure 11.7).

Figure 11.7     Creating the Metadata Extension ZC_MySalesOrder
3. Select the Annotate View template and finish the creation
process by clicking the Finish button.
4. In the source editor, you set the metadata layer at the view level
using the annotation @Metadata.layer: #CORE. Also at the view
level, you need to define the title for the list view (the list report
to be generated) and for the detail view (the object page to be
generated) (see Listing 11.6).
@UI: { headerInfo: { typeName: 'MySalesOrder',
                     typeNamePlural: 'MySalesOrders',
                     title: { type: #STANDARD,
                              value: 'SalesOrderID' } } } 
Listing 11.6     UI annotations for assigning the titles of the applications to be
generated
5. For the details page, you want to define an area in which the
fields are to be displayed, as shown in Listing 11.7.
@UI.facet: [ { id:            'MySalesOrder',
               purpose:       #STANDARD,
               type:          #IDENTIFICATION_REFERENCE,
               label:         'MySalesOrder',
               position:      10 }] 
Listing 11.7     Defining Facets for the Output of Data on the Object Page

6. You can specify the position of an item in the list report using the
annotation @UI.lineItem.position for the respective item. You
can also specify whether a field should be displayed even if the
list view is displayed on a small screen. This is controlled by the
annotation @UI.lineItem.importance. To activate the filter
function for an element, you can use the
@UI.selectionField.position annotation. The position of an
element on the object page can be defined via
@UI.identification.position.
Your full metadata expansion now corresponds to Listing 11.8.
@Metadata.layer: #CORE
@UI: { headerInfo: { typeName: 'MySalesOrder',
                     typeNamePlural: 'MySalesOrders',
                     title: { type: #STANDARD,
                              value: 'SalesOrderID' } } }
annotate view ZC_MySalesOrder with
{
  @UI.facet: [ { id:            'MySalesOrder',
                 purpose:       #STANDARD,
                 type:          #IDENTIFICATION_REFERENCE,
                 label:         'MySalesOrder',
                 position:      10 }]
  @UI: { lineItem:       [ { position: 10,
                             importance: #HIGH } ],
         identification: [ { position: 10 } ],
         selectionField: [ { position: 10 } ] }
  SalesOrderID;
  @UI: { lineItem:       [ { position: 20,
                             importance: #MEDIUM } ],
         identification: [ { position: 20 } ],
         selectionField: [ { position: 20 } ] }
  Customer;
  @UI: { lineItem:       [ { position: 30,
                             importance: #MEDIUM } ],
         identification: [ { position: 30 } ] }
  MemoText1;
  @UI: { lineItem:       [ { position: 40,
                             importance: #MEDIUM } ],
         identification: [ { position: 40 } ] }
  MemoText2;
  @UI: { lineItem:       [ { position: 50,
                             importance: #MEDIUM } ],
         identification: [ { position: 50 } ] }
  NetAmount;
  @UI.lineItem: [{ position: 60 }]

  Status;
  @UI.lineItem: [{ position: 70 }]
  LocalLastChangedAt;
} 
Listing 11.8     Metadata Extension for CDS Projection View ZC_MySalesOrder
This completes the definition and projection of your data model. In
the following sections, you’ll define and implement the behavior of
your business object.

11.4    Creating a Behavior Definition
You can define the behavior of your business object using behavior
definition language (BDL) in the behavior definition.
To create the behavior definition for the sales order, you should
proceed as follows:
1. Open the context menu for CDS root entity ZI_MySalesOrder and
select the entry, New Behavior Definition.
2. The name of the behavior definition you choose must be
identical to that of your CDS root entity. You can’t enter a
different name here. Select Unmanaged as the implementation
type (see Figure 11.8). This has implications for the behavior
implementation, as you’ll see in Section 11.5.
Figure 11.8     Creating the Behavior Definition for CDS Entity ZI_MySalesOrder
3. After clicking the Next and Finish buttons, the system will
propose a pattern for the behavior definition, which you can
customize according to your needs. To customize the proposed

source code for the behavior definition, you want to proceed as
shown in Listing 11.9.
unmanaged;
define behavior for ZI_MySalesOrder alias MySalesOrder
implementation in class zbp_i_mysalesorder unique
//late numbering
lock master
etag master LocalLastChangedAt
{
  create;
  update;
  delete;
  field ( readonly ) LocalLastChangedAt, Status;
  field ( readonly ) SalesOrderID;
  field ( mandatory ) Customer;
  mapping for zvbak control zsrap_mysalesorder_x
  {
    SalesOrderID = id;
    Customer = kunnr;
    MemoText1 = memo1;
    MemoText2 = memo2;
    LocalLastChangedAt = zeitpkt;
    NetAmount = netwr;
    Currency = waerk;
    Status = status;
  }
} 
Listing 11.9     Behavior definition for CDS Entity ZI_MySalesOrder
In the first line, you need to specify the implementation type as
unmanaged. Then, add the MySalesOrder alias to the behavior
definition entity.
You can specify the name of the ABAP class for implementing the
business object behavior with implementation in class
zbp_i_mysalesorder unique. You can accept the class name
suggested by the system. In this class, we’ll implement the
transactional behavior of the business object in Section 11.5.

Using lock master you can activate pessimistic locking. You activate
optimistic locking via etag master LocalLastChangedAt and directly
specify the field to be used as an ETag. In our case, that’s a time
stamp. A global unique identifier (GUID) would also be conceivable
here, but that’s not recommended if you want to add draft handling at
a later time.
Next, you want to declare the standard operations that are possible
for the entity. If the entity is supposed to be created, updated, or
deleted, you must specify this in the behavior definition. For our
MySalesOrder business object this should be possible, so you should
write: create; update; delete;.
You can specify the field properties using the field statement. If you
want to declare the field containing the customer number as
mandatory, and the time stamp, status, and ID of the sales order as
not ready for input, you can specify this as follows, for example:
field ( readonly ) LocalLastChangedAt, Status;
field ( readonly ) SalesOrderID;
field ( mandatory ) Customer; 
You can use the mapping keyword to resolve the discrepancy
between the technical field names of the existing application's
database table and the descriptive field names of your CDS data
model. If you don’t define this type of mapping, you’ll have to do it
yourself in several places in the methods of the implementation
class. Mapping reduces the development effort and improves the
clarity and maintainability of the behavior implementation (see
Listing 11.10).
mapping for zvbak control zsrap_mysalesorder_x
{
  SalesOrderID = id;
  Customer = kunnr;
  MemoText1 = memo1;
  MemoText2 = memo2;
  LocalLastChangedAt = zeitpkt;

  NetAmount = netwr;
  Currency = waerk;
  Status = status;
} 
Listing 11.10     Defining Element Mapping
Finally, you want to create the ABAP dictionary structure
ZSRAP_MYSALESORDER_X, which corresponds to the structure of the
derived data type %CONTROL. To do this, you should select New •
Other ABAP Repository Object in your package. In the ABAP
Dictionary folder, you need to select the Structure entry and
maintain the structure as in Listing 11.11.
@EndUserText.label: 'Control structure MySalesOrder'
@AbapCatalog.enhancementCategory: #NOT_EXTENSIBLE
define structure zsrap_mysalesorder_x {
  id      : xsdboolean;
  kunnr   : xsdboolean;
  memo1   : xsdboolean;
  memo2   : xsdboolean;
  zeitpkt : xsdboolean;
  netwr   : xsdboolean;
  waerk   : xsdboolean;
  status  : xsdboolean;
} 
Listing 11.11     Control Structure ZSRAP_MYSALESORDER_X
Now, you can activate your behavior definition even if you haven’t
yet created the implementation class zbp_i_mysalesorder.
In Section 11.3, you created the projection layer by creating the CDS
projection view ZC_MySalesOrder. This projection view is based on the
interface layer and contains service-specific information (i.e., it’s
precisely tailored to a specific use case). This approach makes the
interface layer reusable and allows you, for example, to provide role-
specific characteristics in a service. We’ll now proceed in the same
way concerning the behavior of the business object. For this
purpose, you should create a behavior definition for your CDS
projection view:

1. Open the context menu for CDS projection view ZC_MySalesOrder
and select the entry, New Behavior Definition.
2. In the dialog that displays, Projection is specified as the
implementation type. Aside from that, the procedure is the same
as the one for creating a behavior definition described earlier.
Since our service is supposed to enable standard CRUD operations
and optimistic locking, the behavior definition looks like the one
shown in Listing 11.12.
projection;
 
define behavior for ZC_MySalesOrder alias MySalesOrder
use etag
{
  use create;
  use update;
  use delete;
} 
Listing 11.12     Behavior Definition for CDS Projection View ZC_MySalesOrder
This completes the creation of your business object behavior
definitions so that you can now start implementing the defined
business object behavior.

11.5    Creating a Behavior Implementation
Whereas in the managed scenario, the CRUD operations are
implemented by the RAP framework; when using the unmanaged
implementation type, you are responsible for the CRUD operations
implementation yourself. The transactional behavior of a business
object is implemented in one (or, optionally, several) global class (the
behavior pool). However, strictly speaking, the global class only
serves as a container for local classes in which the actual
implementation of the behavior logic takes place.
You already specified the name of your behavior pool when you
defined the business object behavior in Listing 11.9, but you haven’t
created the behavior pool yet. To create the implementation class,
open your ZI_MYSALESORDER behavior definition. Use the quick fix
function via the shortcut (Ctrl) + (1) or by clicking on the light bulb
icon next to the line in which you specified the class name (see
Figure 11.9).
Figure 11.9     Creating an Implementation Class (Behavior Pool)
After that, you can immediately take a first look at the global class
ZBP_I_MYSALESORDER you created by clicking on the small triangle-
shaped icon next to its name (see Figure 11.10).

Figure 11.10     Viewing Implementation Class ZBP_I_MYSALESORDER
The global class contains two local classes:
The local class LHC_MYSALESORDER inherits from the class
CL_ABAP_BEHAVIOR_HANDLER. The latter is referred to as the handler
class and is responsible for implementing the logic during the
interaction phase of the business object runtime. Its main task is
to manage the transaction buffer.
The local class LSC_ZI_MYSALESORDER inherits from the class
CL_ABAP_BEHAVIOR_SAVER. That one is referred to as the saver class
and represents the save sequence of the business object runtime.
Its main task is to persist the data from the transaction buffer into
the database. The superclass CL_ABAP_BEHAVIOR_SAVER provides
methods that you can redefine in the local class.
In both classes, you implement adapter code that maps the calls
from the RAP interaction phase or save sequence to the legacy
application API. You can see how the two local classes correspond
to the business object runtime in Figure 11.11, which you already
know from Chapter 5, Section 5.2.

Figure 11.11     Phases and Times Within the Business Object Runtime
In addition to the three FOR MODIFY methods (create, update ,and
delete), the handler class also contains a method for reading the
transaction buffer (read) and a method for mapping the locking logic
(lock). The saver class finalizes or checks the transaction buffer
created during the interaction phase (FINALIZE, CHECK_BEFORE_SAVE
methods) and updates it to the database (SAVE). Because we don’t
use late numbering for the order ID in our example, our local saver
class doesn’t contain the ADJUST_NUMBERS method.
[»]  Specifying the Read Operation
Since it is assumed that the read operation is always implemented,
it can’t be specified in the behavior definition. This operation only
appears in the behavior definition when you use groups, since it
must be specified in the behavior pool the implementation will take
place.
To access the source code editor for your local classes, you want to
switch to the Local Types tab at the bottom of the editor (see
Figure 11.12).

Figure 11.12     The Local Classes in the Source Code Editor
11.5.1    Implementing the Interaction Phase
Let's start with the implementation of the interaction phase. The
methods of the handler class created for this purpose are
responsible for managing the transaction buffer.
The task of the FOR READ method consists of processing read
requests. It returns the requested data from the transaction buffer.
As long as the transaction buffer is initial, the database will be read
instead. You can define the read method as follows:
METHODS read FOR READ
  IMPORTING keys FOR READ mysalesorder RESULT result. 
The signature of the read method in your local saver class contains
an import parameter named keys, which in turn contains the key of
the instance to be read. In the export parameter result you then
return the data that has been read. In case of an error, you’ll log the
entries that couldn’t be read in the implicit return parameter FAILED.

To read the transaction buffer, you can use the Z_VB_READ function
module from the API of the legacy application (Section 11.2.2).
Navigate to the implementation part of your local handler class and
complete the source code of the read method (see Figure 11.13).
Figure 11.13     Implementing the Read Method
You can use the coding from Listing 11.13 as a template.
METHOD read.
 
  DATA ls_zvbak TYPE zvbak.
  DATA lt_messages TYPE zt_message.
 
  LOOP AT keys INTO DATA(key).
 
    CALL FUNCTION 'Z_VB_READ'
      EXPORTING
        iv_id       = key-salesorderid
      IMPORTING
        es_zvbak    = ls_zvbak
        et_messages = lt_messages.
 
    IF lt_messages IS INITIAL.
INSERT CORRESPONDING #( ls_zvbak MAPPING TO ENTITY ) 
        INTO TABLE result.
    ELSE.
      APPEND VALUE #( 
        salesorderid = key-salesorderid
        %fail-cause = if_abap_behv=>cause-not_found
      ) TO failed-mysalesorder.
    ENDIF.
 
  ENDLOOP.

 
ENDMETHOD. 
Listing 11.13     Implementation of the Read Method
Figure 11.14 shows an excerpt from the debugging of the read
method, which illustrates the mapping.
Figure 11.14     Debugging of the Read Method
Note that in your FOR READ method, you can make use of the mapping
specified in the behavior definition (highlighted in bold in
Listing 11.13 ). This way you can avoid a manual conversion of the
technical field names of the legacy application database table to the
descriptive names of the CDS entity.
The FOR CREATE method enables you to create new entries in the
transaction buffer. The instances to be created are passed in the
import parameter entities. In addition, the method has the implicit
return parameters MAPPED, FAILED, and REPORTED. You should now
implement the create method of your handler class according to
Listing 11.14.
METHOD create.
 
  DATA lt_messages TYPE zt_message.
  DATA ls_zvbak_in TYPE zvbak.
  DATA ls_zvbak_out TYPE zvbak.
 
  LOOP AT entities INTO DATA(ls_entity).

 
    ls_zvbak_in = 
      CORRESPONDING #( 
        ls_entity MAPPING FROM ENTITY USING CONTROL ).
 
    CALL FUNCTION 'Z_VB_CREATE'
      EXPORTING
        is_zvbak    = ls_zvbak_in
      IMPORTING
        es_zvbak    = ls_zvbak_out
        et_messages = lt_messages.
 
    IF lt_messages IS INITIAL.
      APPEND VALUE #( 
          %cid = ls_entity-%cid 
          salesorderid = ls_zvbak_out-id )
        TO mapped-mysalesorder.
    ELSE.
      " Fill return parameter RETURN for the framework
      APPEND VALUE #( salesorderid = ls_zvbak_in-id 
                      %cid = ls_entity-%cid) 
        TO failed-mysalesorder.
      "Fill return parameter REPORTED for error output
      APPEND VALUE #( 
          salesorderid = ls_zvbak_in-id
            %cid = ls_entity-%cid
            %msg = new_message( id = lt_messages[ 1 ]-msgid
          number = lt_messages[ 1 ]-msgno
              v1 = lt_messages[ 1 ]-msgv1
              v2 = lt_messages[ 1 ]-msgv2
              v3 = lt_messages[ 1 ]-msgv3
              v4 = lt_messages[ 1 ]-msgv4
        severity = CONV #( lt_messages[ 1 ]-msgty ) )
      ) TO reported-mysalesorder.
    ENDIF.
 
  ENDLOOP.
 
ENDMETHOD. 
Listing 11.14     Implementation of the Create Method
For the instances passed in entities, the conversion of the field
names from the CDS data model to the technical field names of the
database table is performed first (again using the mapping specified
in the behavior definition).
Then, the function module Z_VB_CREATE is called from the API of the
existing application, which creates corresponding entries in the

transaction buffer. If successful, an entry is created in the mapped
table (in addition to the newly created id key, the content ID %CID
gets included). An error case would be logged again in the FAILED
and REPORTED return parameters.
[»]  Content ID %CID
%CID is a temporary primary key to identify an instance as long as
no primary key has been generated by the business object
runtime. It’s relevant for the duration of an EML call and should
always be used. If a caller specifies it, it must also be returned.
The FOR UPDATE method updates the transaction buffer for already
existing instances. For your update method, you must copy the
source code from Listing 11.15.
METHOD update.
 
  FIELD-SYMBOLS: <lv_field_old> TYPE any.
  FIELD-SYMBOLS: <lv_field_new> TYPE any.
  FIELD-SYMBOLS <lv_field_behv_flag> TYPE any.
 
  DATA lr_descr_struc TYPE REF TO data.
  DATA lo_structdescr TYPE REF TO cl_abap_structdescr.
  DATA ls_zvbak TYPE zvbak.
  DATA lt_messages TYPE zt_message.
 
* Read old state by means of EML (from transaction buffer) 
* Alternatively via API Z_VB_READ
  READ ENTITIES OF zi_mysalesorder IN LOCAL MODE
  ENTITY mysalesorder
  ALL FIELDS WITH CORRESPONDING #( entities )
  RESULT DATA(lt_mysalesorders).
 
* Adopt new state
  LOOP AT entities INTO DATA(ls_entity).
 
    READ TABLE lt_mysalesorders INTO DATA(ls_mysalesorder)
      WITH KEY %tky = ls_entity-%tky.
    IF sy-subrc = 0.
      CLEAR lr_descr_struc.
      CLEAR lo_structdescr.
      CREATE DATA lr_descr_struc LIKE ls_entity.
      lo_structdescr ?= 

        cl_abap_structdescr=>describe_by_data_ref(
          p_data_ref = lr_descr_struc ).
      LOOP AT lo_structdescr->components 
        ASSIGNING FIELD-SYMBOL(<lv_component>).
        IF <lv_component>-name <> 'SALESORDERID' AND
           <lv_component>-name(1) <> '%'.
          ASSIGN COMPONENT <lv_component>-name OF STRUCTURE 
            ls_entity TO <lv_field_new>.
          ASSIGN COMPONENT <lv_component>-name OF STRUCTURE 
            ls_mysalesorder TO <lv_field_old>.
          ASSIGN COMPONENT <lv_component>-name OF STRUCTURE 
            ls_entity-%control TO <lv_field_behv_flag>.
          IF <lv_field_old> IS ASSIGNED AND 
             <lv_field_new> IS ASSIGNED AND 
             <lv_field_behv_flag> = if_abap_behv=>mk-off.
             <lv_field_new> = <lv_field_old>.
          ENDIF.
        ENDIF.
      ENDLOOP.
 
      ls_zvbak = CORRESPONDING #(
      ls_entity MAPPING FROM ENTITY ).
 
      CALL FUNCTION 'Z_VB_UPDATE'
        EXPORTING
          is_zvbak    = ls_zvbak
        IMPORTING
          et_messages = lt_messages.
 
      IF lt_messages IS INITIAL.
        APPEND VALUE #( 
          salesorderid = ls_entity-salesorderid )
          TO mapped-mysalesorder.
      ELSE.
        "Fill return parameter in case of error
          APPEND VALUE #( 
            salesorderid = ls_entity-salesorderid ) 
            TO failed-mysalesorder.
          "Fill reported parameter for output in UI
          APPEND VALUE #( 
            salesorderid = ls_entity-salesorderid
            %msg = new_message(
            id = lt_messages[ 1 ]-msgid
            number = lt_messages[ 1 ]-msgno
            v1 = lt_messages[ 1 ]-msgv1
            v2 = lt_messages[ 1 ]-msgv2
            v3 = lt_messages[ 1 ]-msgv3
            v4 = lt_messages[ 1 ]-msgv4
            severity = CONV #( lt_messages[ 1 ]-msgty ) )
        ) TO reported-mysalesorder.
      ENDIF.
    ENDIF.
 
  ENDLOOP.

 
ENDMETHOD. 
Listing 11.15     Implementation of the Update Method
Here, you need to determine first the previous state in the
transaction buffer using the EML statement READ ENTITIES OF. The
import parameter entities, on the other hand, contains the changes
to the instances (i.e., the contents of all fields for which a change has
been made). The control structure ls_entity-%control enables you
to identify for which fields a change has been made and for which
ones there haven’t been any changes. For example, you can identify
unchanged fields via %control = if_abap_behv=>mk-off.
Figure 11.15 shows an example of a state in which changes have
been made for the MEMOTEXT2, NETAMOUNT, and CURRENCY fields. In the
loop over the changed instances, you can merge the changed field
contents and the unchanged state of the unchanged fields in the
ls_entity structure. Then, again using the mapping specified in the
behavior definition, you want to convert the descriptive field names
to the technical field names. After that, you can call the API function
module Z_VB_UPDATE to update the transaction buffer. You pass the
current state of the instance in the ls_zvbak structure. The
successful and unsuccessful updates should be logged in the return
parameters, MAPPED, FAILED, and REPORTED.

Figure 11.15     Control Structure %CONTROL
The procedure for implementing the two other methods is very
similar to that for implementing the methods described so far.
Complete the coding of the delete and lock methods as shown in
Listing 11.16 and Listing 11.17.
The delete method deletes entries from the transaction buffer.
METHOD delete.
 
  DATA lt_messages TYPE zt_message.
 
  LOOP AT keys ASSIGNING FIELD-SYMBOL(<key>).
 
    CALL FUNCTION 'Z_VB_DELETE'
      EXPORTING
        iv_id       = <key>-salesorderid
      IMPORTING
        et_messages = lt_messages.
 
    IF lt_messages IS INITIAL.
      APPEND VALUE #( salesorderid = <key>-salesorderid )
        TO mapped-mysalesorder.
    ELSE.
      "fill failed return structure for the framework
      APPEND VALUE #(  salesorderid = <key>-salesorderid )
        TO failed-mysalesorder.
      "fill reported structure to be displayed on the UI
      APPEND VALUE #( 
        salesorderid = <key>-salesorderid
        %msg = new_message( 
          id = lt_messages[ 1 ]-msgid
          number = lt_messages[ 1 ]-msgno
          v1 = lt_messages[ 1 ]-msgv1
          v2 = lt_messages[ 1 ]-msgv2
          v3 = lt_messages[ 1 ]-msgv3
          v4 = lt_messages[ 1 ]-msgv4
          severity = CONV #( lt_messages[ 1 ]-msgty ) )
     ) TO reported-mysalesorder.
    ENDIF.
 
  ENDLOOP.
 
ENDMETHOD. 
Listing 11.16     Implementation of the Delete Method

The lock method sets a lock for the requested instances (see
Listing 11.17).
METHOD lock.
 
  DATA lt_messages TYPE zt_message.
 
  LOOP AT keys ASSIGNING FIELD-SYMBOL(<key>).
 
*     Set lock
    CALL FUNCTION 'Z_VB_LOCK'
      EXPORTING
        iv_id       = <key>-salesorderid
      IMPORTING
        et_messages = lt_messages.
 
    IF lt_messages IS NOT INITIAL.
      "fill failed return structure for the framework
      APPEND VALUE #(  salesorderid = <key>-salesorderid )
        TO failed-mysalesorder.
      "fill reported structure to be displayed on the UI
      APPEND VALUE #( 
        salesorderid = <key>-salesorderid
        %msg = new_message( 
          id = lt_messages[ 1 ]-msgid
          number = lt_messages[ 1 ]-msgno
          v1 = lt_messages[ 1 ]-msgv1
          v2 = lt_messages[ 1 ]-msgv2
          v3 = lt_messages[ 1 ]-msgv3
          v4 = lt_messages[ 1 ]-msgv4
          severity = CONV #( lt_messages[ 1 ]-msgty ) )
     ) TO reported-mysalesorder.
    ENDIF.
 
  ENDLOOP.
 
ENDMETHOD. 
Listing 11.17     Implementation of the Lock Method
11.5.2    Implementing the Save Sequence
The methods of the saver class are responsible for the correct
persistence of the data from the transaction buffer. The save
sequence is called by the business object runtime whenever at least
one change has occurred during the interaction phase.

The call order of the methods is:
1. FINALIZE: Performing last data changes before saving
2. CHECK_BEFORE_SAVE: Checking the data in the transaction buffer
3. ADJUST_NUMBERS: When using late numbering; therefore, not
relevant for our example
4. SAVE: Saving the data from the transaction buffer to the database
5. CLEANUP: Clearing the transaction buffer
In our sales order data management application, we want to perform
one more calculation before persisting the data. The status of the Z
sales order should be set to 1 if the data is fully maintained (that is,
all fields are filled), otherwise to 0. The existing API function module
Z_VB_ENRICH is used to perform the calculation. Now you should
redefine the FINALIZE method in your local saver class
LSC_ZI_MYSALESORDER, as shown in Listing 11.18.
METHOD finalize.
 
  DATA lt_buffer_zvbak TYPE zvbak_buffer_t.
  DATA lt_messages TYPE zt_message.
 
  CALL FUNCTION 'Z_VB_READ_ALL'
    IMPORTING
      et_buffer_zvbak = lt_buffer_zvbak.
 
  LOOP AT lt_buffer_zvbak INTO DATA(ls_buffer_zvbak).
 
    CALL FUNCTION 'Z_VB_ENRICH'
      EXPORTING
        iv_id       = ls_buffer_zvbak-id
      IMPORTING
        et_messages = lt_messages.
 
    IF lt_messages IS NOT INITIAL.
      APPEND VALUE #(  salesorderid = ls_buffer_zvbak-id ) 
        TO failed-mysalesorder.
      APPEND VALUE #( 
        salesorderid = ls_buffer_zvbak-id
        %msg = new_message(
          id = lt_messages[ 1 ]-msgid
          number = lt_messages[ 1 ]-msgno

          v1 = lt_messages[ 1 ]-msgv1
          v2 = lt_messages[ 1 ]-msgv2
          v3 = lt_messages[ 1 ]-msgv3
          v4 = lt_messages[ 1 ]-msgv4
          severity = CONV #( lt_messages[ 1 ]-msgty ) )
     ) TO reported-mysalesorder.
    ENDIF.
  ENDLOOP.
ENDMETHOD. 
Listing 11.18     Redefinition of the FINALIZE method
First, you read the transaction buffer using the Z_VB_READ_ALL
function module of the legacy application API. Then, for each order
ID, you must check whether the fields are filled and, depending on
this, set the value of the status field (using the API function module
Z_VB_ENRICH). The transaction buffer is also updated within the
Z_VB_ENRICH function module. As in the interaction handler methods,
you’ll log any errors that occur in the implicit return parameters,
FAILED or REPORTED.
We want to include some checks before posting the data. For
example, it shouldn’t be possible to enter a negative net value. To
check this, you need to redefine the CHECK_BEFORE_SAVE method of
our saver class, as shown in Listing 11.19.
METHOD check_before_save.
 
  DATA lt_buffer_zvbak TYPE zvbak_buffer_t.
  DATA lt_messages TYPE zt_message.
 
  CALL FUNCTION 'Z_VB_READ_ALL'
    IMPORTING
      et_buffer_zvbak = lt_buffer_zvbak.
 
  LOOP AT lt_buffer_zvbak INTO DATA(ls_buffer_zvbak).
 
    CALL FUNCTION 'Z_VB_CHECK'
      EXPORTING
        iv_id       = ls_buffer_zvbak-id
      IMPORTING
        et_messages = lt_messages.
 
    LOOP AT lt_messages INTO DATA(ls_message).
      APPEND VALUE #( salesorderid = ls_buffer_zvbak-id )

        TO failed-mysalesorder.
      reported-mysalesorder = 
        VALUE #( BASE reported-mysalesorder
          ( salesorderid = ls_buffer_zvbak-id
            %msg = me->new_message( 
              severity = if_abap_behv_message=>severity-error
              id       = ls_message-msgid
              number   = ls_message-msgno
              v1 = ls_message-msgv1
              v2 = ls_message-msgv2
              v3 = ls_message-msgv3
              v4 = ls_message-msgv4 )
           ) ).
    ENDLOOP.
  ENDLOOP.
ENDMETHOD. 
Listing 11.19     Redefinition of the CHECK_BEFORE_SAVE Method
Again, you should read the transaction buffer here with the API
function module Z_VB_READ_ALL. The checks are made in API function
module Z_VB_CHECK. Failed checks are logged in the FAILED or
REPORTED return parameters, which also aborts the save sequence.
The persistence of the transaction buffer content takes place in the
redefinition of the SAVE method by calling the API function module
Z_VB_SAVE (see Listing 11.20).
METHOD save.
  CALL FUNCTION 'Z_VB_SAVE'.
ENDMETHOD. 
Listing 11.20     Redefinition of the SAVE Method
In the unmanaged scenario, the CLEANUP method is called after the
SAVE method to initialize the transaction buffer. This is done by calling
the API function module, Z_VB_INITIALIZE. The CLEANUP method isn’t
automatically proposed to you for redefinition when you create the
behavior pool. You must therefore add it manually to the saver class
(see Figure 11.16).

Figure 11.16     CLEANUP Method in the Saver Class
Then, you should implement the call of the API function module in
the method:
METHOD cleanup.
  CALL FUNCTION 'Z_VB_INITIALIZE'.
ENDMETHOD. 

11.6    Defining a Business Service
In the previous sections, we defined and implemented the data
model and behavior of our Z sales order business object. By creating
a business service, we now make both available to callers for use via
OData. The business service consists of the service definition, where
you specify the scope of CDS entities provided for use, and the
service binding, where you specify the type of business service and
bind it to a protocol.
The procedure for creating the business service is independent of
the implementation type (i.e., it corresponds to the procedure
described in Chapter 9, Section 9.4) for the managed scenario. First,
you create the service definition by opening the context menu for
your CDS projection view ZC_MySalesOrder and selecting the New
Service Definition entry. Enter a name and description. You can use
Figure 11.17 as a guide.
Figure 11.17     Creating Service Definition ZUI_MYSALESORDER
The abbreviation UI in the name of the service definition is supposed
to indicate that the service is intended for use by a user interface.

Click the Next button, select the Define Service template, and finish
the installation by clicking the Finish button.
In our simple example, the data model consists only of the
ZC_MySalesOrder entity, which you can expose by specifying an alias
(see Listing 11.21). To be able to assign an alias, you must also
publish the CDS view I_Customer_VH that’s used as an input help,
even if the CDS views used as input help are already available by
default. Then, you can activate your service definition.
@EndUserText.label: 'Service definition MySalesOrder'
define service ZUI_MYSALESORDER {
  expose ZC_MySalesOrder as MySalesOrder;
  expose I_Customer_VH as Customer_VH;
} 
Listing 11.21     Service Definition ZUI_MYSALESORDER
Based on the service definition, you can now create the service
binding. To do this, right-click on the service definition
ZUI_MYSALESORDER to open the context menu and select the New
Service Binding entry. Enter a name and description, and select
OData V2 - UI as Binding Type. No further changes are necessary,
which means you can finish the installation by clicking the Next and
Finish buttons. Click on the Publish button to activate your service
binding (see Figure 11.18).
Figure 11.18     Activating the Service Binding
You can now test your service by selecting the CDS root entity
MySalesOrder and using the preview function for SAP Fiori elements
via the Preview button (see Figure 11.19).

In the generated interface, you can enter new entries, change
entries, and delete entries again on a test basis. For example, if you
enter a negative net value, the error message from Figure 11.20
should display.
Figure 11.19     Testing the UI Service via the Preview Function
Figure 11.20     Error Message When Entering a Negative Net Value
[»]  Generating and Deploying the Application
Creating a list report application based on the OData V2 service
you created is possible when using SAP Fiori tools in Visual
Studio Code. You can generate this SAP Fiori elements
application and deploy it on an SAP S/4HANA system in the same

way as described in Chapter 9, Section 9.9. So, we won’t go into
further detail at this time.

12    Specific Features for the
SAP BTP, ABAP Environment
This chapter introduces the SAP BTP, ABAP environment
and describes the specific features available to you here with
regard to the ABAP RESTful application programming
model.
The SAP BTP, ABAP environment is a cloud service of the SAP
Business Technology Platform (SAP BTP). It provides an ABAP
platform for application development in the cloud. The ABAP
RESTful application programming model was first made available
with the SAP BTP, ABAP environment. The programming model in
this environment is identical in terms of its concepts and artifacts to
the delivery on the ABAP platform for SAP S/4HANA on-premise.
Different variants of the programming model for the cloud and on-
premise environments would also contradict the quality principles of
the programming model (see Chapter 1, Section 1.5). The ABAP
RESTful application programming model is the preferred
programming model for application development in the SAP BTP,
ABAP environment.
[»]  It’s Steampunk Now
SAP BTP, ABAP environment is the official name for the ABAP
environment in the cloud. In the meantime, the internal project
name Steampunk has also become an established name in the

SAP developer community. You can find more information in a
blog entry by Harald Kuck in the SAP Community at
https://blogs.sap.com/2019/08/20/its-steampunk-now/.
Occasionally, the SAP BTP, ABAP environment is referred to as
ABAP platform as a service (ABAP PaaS).
[+]  Tip: SAP Business Technology Platform Trial Account
You can try out the SAP BTP, ABAP environment via a trial
account for SAP BTP. For more information, you should visit the
SAP website at https://www.sap.com/products/business-
technology-platform/trial.html.
For instructions on how to set up a free trial instance of the ABAP
Environment, see SAP Help Portal at http://s-prs.de/v868517.
In this chapter, we’ll first look at basic technical principles, such as
versioning, the system context, the ABAP language version used,
and the released APIs (Section 12.1). We’ll then introduce the basic
concepts of the authorization system (Section 12.2). Finally, we’ll
show you how to make SAP Fiori apps developed in the environment
that is available to users via the integrated SAP Fiori launchpad
(Section 12.3) and how to access application interfaces to consume
business services (Section 12.4).
12.1    Technical Fundamentals
SAP automatically provides a new release of the ABAP environment
every quarter as part of the cloud operating model. This means that
the latest version of the ABAP RESTful application programming

model is always available to you. Functional differences to an on-
premise version arise when you compare the cloud version with an
outdated release of the ABAP platform for SAP S/4HANA on-
premise. In addition, SAP S/4HANA on-premise is only updated
once a year. With each new version, the RAP functions that are
already available in the cloud become available on-premise as well.
The SAP BTP, ABAP environment can be used in the following use
cases, for example:
For SAP customers
SAP customers can use the side-by-side extension environment
of the SAP application software (e.g., SAP S/4HANA or SAP
S/4HANA Cloud) using the latest technologies. The side-by-side
principle ensures that extensions are made non-invasively via
shared remote APIs, according to the motto, “keep the core
clean.”
For SAP partners
SAP partners can use the environment to develop and run
multitenant software-as-a-service (SaaS) applications for their
customers.
For SAP
SAP products that run in the SAP BTP, ABAP environment include
SAP Market Communication for Utilities or SAP Master Data
Governance, cloud edition.
The SAP BTP, ABAP environment is a purely technical platform
(without installed application software) that’s embedded in a specific
system context within which you can develop and operate
applications (see Figure 12.1).

Figure 12.1     System Context of the SAP BTP, ABAP Environment
The SAP BTP, ABAP environment provides an ABAP runtime
environment that has undergone a fundamental technical cleanup
and overhaul due to the cloud operating model (which requires
regular, stable updates, for example). SAP HANA is used exclusively
as the database. With the ABAP environment you can access ABAP-
based services of the surrounding SAP BTP (e.g., SAP Destination
Service via the SAP Connectivity Service). You can manage the SAP
BTP services you use—including the ABAP environment— via the
SAP BTP cockpit.
You can use the SAP Destination Service to integrate various
application systems with the ABAP environment. Cloud-based
systems, such as SAP S/4HANA Cloud, can be accessed directly
through the internet. You can reach on-premise systems such as
SAP S/4HANA via a secure connection enabled by the cloud
connector. This is installed locally (i.e., in the company's own
network) and establishes a secure connection to SAP BTP from this
local network.
To deploy your RAP applications, the ABAP environment has its own
SAP Fiori launchpad, which can serve as an entry point for various
SAP Fiori apps and which you can access through a web browser
(Section 12.3). Your own SAP Fiori apps are kept in the SAPUI5

repository of the ABAP environment. Using the SAP GUI as a
frontend for your applications created in the cloud environment isn’t
possible. The ABAP environment also provides access to
applications of the technical infrastructure components
(Section 12.1.2), such as the management of number range
intervals.
ABAP development in the cloud environment takes place exclusively
via ABAP development tools (ADT). To develop and deploy SAP
Fiori user interfaces, you can use SAP Business Application Studio
or Visual Studio Code with SAP Fiori tools as an extension, which
we introduced in Chapter 7, Section 7.1. You can upload existing
ABAP applications to the cloud environment via a Git repository and
the abapGit plug-in for Eclipse.
[+]  Tip: abapGit Plug-In
abapGit is an ABAP-based open source software that allows you
to communicate with a Git repository from an ABAP system to
export or import development objects. abapGit is available as an
Eclipse plug-in. You can find it on the following update page at
https://eclipse.abapgit.org/updatesite/.
To synchronize on-premise repository objects with a Git repository,
you need the on-premise version of abapGit. This version can be
found at https://abapgit.org.
[»]  Business Role for the Development
If you want to develop using ADT in the SAP BTP, ABAP
environment, your business user needs the identity and access
management (IAM) business role SAP_BR_DEVELOPER (see also

Section 12.2). Your business user is the user account with which
you log on to the SAP BTP, ABAP environment. You can use the
SAP Fiori app Maintain Business Users to assign IAM business
roles to business users. This application can be found in the SAP
Fiori launchpad.
You can expose technical services in the ABAP environment. These
services can be OData services based on the ABAP RESTful
application programming model, custom HTTP-based services, or
remote-enabled (RFC-enabled) function modules (see Table 12.1).
Protocol Description
HTTP
services
You develop a HTTP service with its own handler class.
OData
services
OData services are created based on business services
of the ABAP RESTful application programming model
(see Chapter 6). SAP Gateway programming, such as
implementing your own data providers, isn’t possible in
the cloud environment.
Remote
Function
Call
(RFC)
A classic RFC is executed via the cloud connector or
without the cloud connector via WebSockets.
Table 12.1     Supported Protocols for Incoming Communication
We generally recommend creating applications using the ABAP
RESTful application programming model. This is also the only
reasonable way to expose OData services (e.g., for an SAP Fiori UI
(unless you want to implement the OData protocol yourself via HTTP
services, which we don’t assume). This recommendation applies to
newly created applications (greenfield approach) and existing

applications that you can wrap with the ABAP RESTful application
programming model (brownfield approach).
12.1.1    ABAP for Cloud Development
In the cloud, a customized version of the ABAP programming
language called ABAP for cloud development is available. Do not
confuse this version with the ABAP language version ABAP for key
users, which is used for key user enhancements according to the
enhancement concept for SAP S/4HANA. ABAP for cloud
development has been tailored for use in the cloud. The version has
been reduced by those language elements that can’t be meaningfully
supported in the cloud (or are obsolete). This includes, for example,
statements for accessing the file system or statements in the context
of SAP GUI transactions such as REPORT, CALL SCREEN, or WRITE.
In the ABAP environment, you can only use repository objects from
SAP that have explicitly been released (whitelisted APIs). This way,
upgrade security is ensured in the cloud operating model.
Accordingly, you can only access the technical infrastructure
components (Section 12.1.2) via released repository objects. These
objects are marked as released in release contract C1 (“Internal
system use”). The syntax check for the ABAP language version for
the cloud ensures that only released objects will be used (see
Figure 12.2).

Figure 12.2     Syntax Error When Using Unreleased Repository Objects
12.1.2    Technical Infrastructure Components
The SAP BTP, ABAP environment provides a set of infrastructure
components that you can use for application development. The main
components are listed in Table 12.2.
Component
Description
Application
Jobs
Management and execution of background
processes/batch processing
Application
Logs
Logging of messages within the scope of an
application (logging)
Log display via the integration of an SAP Fiori
reuse component
Number
Range
Management
Management of number range intervals for the
implementation of numbering
Lock
Management
Managing, requesting, and deleting locks as part of
a pessimistic locking procedure
Factory
Calendar
Managing and querying of vacation days or days
off

Component
Description
Units of
Measurement
Definition of dimensions, units of measurement,
and conversions between units of measurements
Currency
Conversion
Definition of exchange rates and currency
conversion
Change
Documents
Definition and updating of data change logs on
business objects
Output
Management
Forms, printing and emailing
XCO Library
Comprehensive API newly introduced with the
ABAP environment for read and write access to
development objects and for access to further
development-relevant functions, such as the
creation and release of transport requests. XCO is
the abbreviation for Extension Components.
Table 12.2     Technical Components in the SAP BTP, ABAP Environment
You’re probably familiar with these components from classic
application development on the SAP NetWeaver Application Server
for ABAP. In the ABAP environment, they’re available in a cloud-
enabled variant. They provide their functionality via their own
interface and class-based APIs, rather than classically via function
modules. These APIs are also released via the C1 release contract
(Section 12.1.1).
For example, the number range management is a technical
component that can be used within the numbering of a RAP
business object. You can call the API for number ranges in the
behavior implementation in the context of late numbering, for
example (see Listing 12.1).
METHOD adjust_numbers.
...

   cl_numberrange_runtime=>number_get(
       EXPORTING
           object = 'ZRAP_AGNCY'
           nr_range_nr = '1'
       IMPORTING
           number = DATA(number) ).
...
ENDMETHOD. 
Listing 12.1     Late Numbering via the API for Number Ranges
Infrastructure components often provide mechanisms for
applications to plug in. For example, the number range management
component provides a number range object that’s defined,
configured, and used at runtime by the respective application.
While the standard procedure for creating such objects is via ADT,
infrastructure components for the ABAP environment often provide
released APIs for this purpose. You can use such an API to perform
a program-based creation of a number range object
(CL_NUMBERRANGE_OBJECTS). Another example involves application
jobs. There you can use the API CL_APJ_DT_CREATE_CONTENT to create
job catalog entries and job templates to connect an application to the
application jobs component and to schedule and execute your own
source code in the background.
Instead of SAP GUI-based transactions, the ABAP environment
provides SAP Fiori apps via the integrated SAP Fiori launchpad that
allow you to manage or use infrastructure component objects, such
as specific application jobs or number ranges. For example,
Figure 12.3 shows the SAP Fiori app for managing number range
intervals.

Figure 12.3     SAP Fiori App for Managing Number Range Intervals
In addition to the infrastructure components provided by the
environment, you can also access other services from the ABAP
environment that are provided via the SAP BTP. At the time of
printing this book, these are the following services:
SAP Workflow Management, including business rules
SAP Document Management Service
12.1.3    Migrating Legacy Code
If you want your existing code to run in the ABAP environment, you
will most likely have to modify this code to reflect the updated
technical conditions. Here are some examples where adjustments
will be necessary:
The legacy application processes XML via the iXML library.
The legacy application consists of ABAP reports, ABAP dictionary
search helps or SAP Gateway artifacts. These types of
development objects aren’t supported in the ABAP Environment.
The legacy application uses obsolete or unsupported statements,
for example, MOVE or WRITE ... TO ....
You can use your instance of the ABAP environment for a custom
code analysis regarding the cloud capability and prepare the existing

code on-premise if necessary before importing it to the cloud via
abapGit. Another strategy is to import the existing code without
preparation via abapGit and then make all changes as part of a one-
time migration to the ABAP environment. For certain findings you
can use ABAP Test Cockpit’s (ATC’s) quick fix function.
The ABAP RESTful application programming model enables you to
wrap a migrated application. These are possible aspects you can
consider:
The domain-oriented modules have unwanted dependencies on
infrastructure components (e.g., screen-specific statements). For
this reason, they must first be refactored before migration.
The legacy application is insufficiently modularized or
inappropriately designed, so it must be customized before it can
be integrated into the RAP transaction model.

12.2    Identity and Access Management
While PFCG roles are used on the ABAP platform for SAP S/4HANA
for authorization specification and assignment, there’s a separate
identity and access management (IAM) service for the SAP BTP,
ABAP environment with its own concepts for authorization
assignment. What the authorization concepts for the cloud and on-
premise environments have in common is that they’re based on
authorization objects as the lowest common denominator. The
concept of authorization objects from the on-premise world is thus
also supported in the ABAP environment.
[»]  Required IAM Business Role
Your business user needs the SAP_BR_ADMINISTRATOR business role
to access the IAM’s SAP Fiori apps.
In the following sections, we’ll describe some of the concepts of the
IAM, laying the foundation for you to implement the following use
cases in the context of the ABAP RESTful application programming
model in the ABAP environment:
Assigning basic authorizations via authorization objects with the
IAM
Assigning authorizations for SAP Fiori apps including the OData
endpoints used via the IAM. These endpoints are generated
based on business services.
[»]  Simplified Representation

The IAM is presented here in a simplified way to explain the use
cases described. For more information on IAM concepts like
restriction fields, restriction types, and IAM business role
templates and on the various possible combinations of IAM
concepts, refer to the online documentation in SAP Help Portal at
http://s-prs.de/v868518.
A RAP business object uses authorization objects for authorization
checking. Here, the question arises regarding how you can assign
basic authorizations for the authorization objects used in the ABAP
environment. So, you should know two essential IAM concepts:
default authorization values and IAM apps (see Figure 12.4).
Figure 12.4     Connection Between RAP Application, Authorization Objects, and IAM
Default authorization values are development objects that enable
you to define authorization objects with default authorizations. A
default authorization value belongs to a RAP service binding. The
authorizations set via the default authorization values are only
applied in the context of calling the service that’s exposed via the
service binding.

An IAM app is a development object that can reference generated
gateway services (generated from the RAP service binding) to
authorize them. If a business user has been authorized to access an
IAM application, it will also receive the default authorization values
(i.e., the authorizations) of the assigned business service in this way.
In an IAM app, these authorizations maintained via the default
authorization values can be accepted as default values,
supplemented or overwritten. It’s also possible to maintain custom
authorizations in the IAM app irrespective of this. An IAM app can
also represent an SAP Fiori app, so that a business user can be
authorized to access the SAP Fiori app (Section 12.3.1).
So, you store authorizations at the level of the default authorization
values and the IAM app. Now, the question is, how can you assign
these authorizations to a business user? For this purpose, there’s
the concept of the IAM business catalog. An IAM business catalog is
a development object that groups together multiple IAM apps that
are related in terms of content.
An IAM business role combines authorizations and/or SAP Fiori
apps via the IAM business catalogs and is thus oriented in terms of
content to the business user's specialist tasks. The IAM business
role gets assigned to a business user (Section 12.3.2). This way, the
user receives the respective authorizations that result from the IAM
app and the default authorization values. An IAM business role can
reference one or more areas of the SAP Fiori launchpad so that the
tiles derived from it can be displayed (Section 12.3.2).
The interaction between the IAM development objects—IAM
business catalog and IAM app—and the business role and user is
shown in Figure 12.5.

Figure 12.5     IAM Development Objects with Business Role and Business User
[»]  Authorizing Business Services (Web APIs)
If you expose business services as web APIs for technical users
so that other systems can consume them, you need to create a
communication scenario in ABAP development tools (ADT) for this
purpose. The communication scenario references one or more
services to expose and is the equivalent of an IAM app, but only
for technical integration scenarios.
An administrator can then create a communication agreement in
the SAP Fiori launchpad with reference to the communication
scenario. In the communication agreement, the administrator can
create a communication system and store login details for the
given services there. This way, different login data can also be
stored via different communication agreements.

12.3    Deploying SAP Fiori Apps and
Assigning Authorizations
In the SAP BTP, ABAP environment, the classic frameworks for
creating user interfaces such as Dynpro, Web Dynpro ABAP or the
Floorplan Manager aren’t available. If you want to create user
interfaces for a RAP business object in the cloud, you should use
SAPUI5 or SAP Fiori elements instead (see also Chapter 7).
[»]  IAM Business Role for the Following Example
If you want to reproduce the steps below in the ABAP
environment, your business user needs to be assigned the
business role SAP_BR_ADMINISTRATOR.
Let’s suppose you’ve generated an SAP Fiori elements application
based on a RAP business object and an exposed OData service,
consisting of a list report and an object page. Now you want to make
this application available to business users. In the following sections,
we describe the steps required to make the SAP Fiori app available
as a tile in the SAP Fiori launchpad of the ABAP environment.
In order for SAP Fiori Launchpad to navigate to an SAP Fiori app,
you need to define an inbound navigation for that app. To do this,
you must first define a semantic object (semanticObject), and an
action (action, which is not to be confused with a RAP action) in the
manifest.json file of your application (see Listing 12.2). Note that the
semantic object must be unique in the context of SAP Fiori
launchpad and other registered semantic objects. For this reason,
we’ve created it in the customer namespace.

"sap.app": {
   ...
   "crossNavigation": {
       "inbounds": {
           "intentManage": {
               "signature": {
                   "parameters": {},
                   "additionalParameters": "allowed"
               },
               "semanticObject": "ZTravel",
               "action": "manage",
               "title": "{{appTitle}}",
               "icon": "sap-icon://suitcase"
           }
       }
   }
},
... 
Listing 12.2     Inbound Navigation Declared Under sap.app in the manifest.json File
Business Server Pages (BSP) are now only used as a deployment
unit and server-side mapping of SAPUI5 or SAP Fiori apps in the
SAPUI5 repository. To deploy an SAP Fiori app, you also use the
SAP Fiori tools in the SAP BTP, ABAP environment, just as you
would in an on-premise environment.
Once the deployment process has finished, you must make the app
available to a business user. Two aspects are relevant here, which
we’ll describe in greater detail in the following sections:
Integrating the SAP Fiori app into the IAM so that an authorization
can be assigned for the application
Integrating the SAP Fiori app into the SAP Fiori launchpad to
make it available to users
12.3.1    Creating an IAM App and Business Catalog
After deploying an SAP Fiori app via SAP Fiori tools, you must first
integrate it into the cloud authorization concept via an IAM app. To

do this, you should create a new IAM app:
1. Open the context menu by right-clicking the package where you
want to create the IAM app. Select New • Other ABAP
Repository Object.
2. A creation dialog opens, in which you want to select the IAM
app item under Cloud Identity and Access Management.
Then, click the Next button.
3. Enter the name of the IAM app in the Name field and a
description in the Description field. Complete the process by
clicking the Finish button.
4. The ADT editor for the IAM app will open. On the Overview tab,
enter the ID of your SAP Fiori app generated during deployment
in the field, Fiori Launchpad App Descr Item ID (here, it’s
ZRAP_BTP_TRAVD_UI5R). This ID is the link between the deployed
SAPUI5 application and the IAM app (see Figure 12.6). The ID
is derived from the name of the BSP application stored in the
ui5-deploy.yaml file.
Figure 12.6     Creating an IAM App for an SAP Fiori App
On the Services tab, you want to include one or more gateway
services that were generated on the basis of service binding and
which are consumed as a backend service by the SAP Fiori app (see
Figure 12.7). This creates the basis for the SAP Fiori app to be

represented in the IAM together with the necessary services in the
backend. It’s the only way to authorize business users for this app.
Figure 12.7     Integrating a Gateway Service in the IAM App
Having created the IAM app, you must enter it in an IAM business
catalog so that it can be assigned to a business user via an IAM
business role. To do this, you need to create an IAM business
catalog via ADT:
1. Open the context menu by right-clicking the package where you
want to create the IAM business catalog. Select New • Other
ABAP Repository Object.
2. A creation dialog will open, in which you must select Business
Catalog under Cloud Identity and Access Management.
Then, click the Next button.
3. Enter the name of the IAM business catalog in the Name field
and a description in the Description field. Complete the process
by clicking the Finish button.
4. Assign the IAM app to this catalog on the Apps tab using the
Add... button (see Figure 12.8).

Figure 12.8     IAM Business Catalog with Associated IAM App
5. Then, save the catalog and click the Publish Locally button to
publish the IAM business catalog.
You have now created all the prerequisites for creating an IAM
business role.
12.3.2    Creating an IAM Business Role
You need an IAM business role to make the previously created IAM
business catalog available to business users. Typically, the IAM
business role is created by an administrator and uses the
development objects created in the previous section via ADT.
Create an IAM business role via the SAP Fiori launchpad of your
instance of the ABAP environment. To do this, you should use the
SAP Fiori app, Maintain Business Roles. Here, you must assign
the created IAM business catalog on the Assigned Business
Catalogs tab of the business role, (here, it’s ZRAP_BTP_BC_TRAVEL;
see Figure 12.9).

Figure 12.9     IAM Business Role with Associated IAM Business Catalog
Save the IAM business role and assign it to the appropriate business
users you want to authorize. You can do this directly in the edit mode
of the IAM business role on the Assigned Business Users tab.
Alternatively, you can use the SAP Fiori app Maintain Business
Users for this purpose.
12.3.3    Integration in SAP Fiori Launchpad
While in an on-premise environment you use tile catalogs and
groups to integrate an SAP Fiori app into the SAP Fiori launchpad
via a PFCG role, the SAP BTP, ABAP environment is based on the
concept of launchpad spaces and launchpad pages.
A launchpad space represents a collection of different launchpad
pages and is displayed as the top menu item in SAP Fiori launchpad
if you have enabled the display of spaces. The sections of a
launchpad page consist of several tiles. Using such a tile, you can
make the SAP Fiori app encapsulated as an IAM app accessible to
business users.
The concept of launchpad spaces and pages is used for a flexible
content grouping of SAP Fiori apps. A launchpad space is assigned
to an IAM business role. Once a business user has been assigned

the appropriate IAM business role, it is shown the matching space in
the SAP Fiori launchpad. Figure 12.10 illustrates this concept.
Figure 12.10     Relationship between the IAM Development Objects and the Launchpad
Spaces and Pages
[»]  SAP Fiori Apps for Managing Launchpad Spaces and
Pages
To maintain the SAP Fiori launchpad, you can use the SAP Fiori
apps Manage Launchpad Spaces and Manage Launchpad
Pages. Additionally, it’s possible to create a new launchpad space
from an IAM business role, as we’ll describe later in this section.
In Figure 12.11, you can see a simple launchpad space named
Travel-Administration with one page and one tile. We’ll create such
a launchpad space in the following sections.

Figure 12.11     Display of the Launchpad Space Travel-Administration at Runtime
You can create a new launchpad space based on an IAM business
role and thus assign both to each other in one go. In addition, you
can also create a new launchpad page in this step, which will be
assigned directly to the launchpad space:
1. Navigate to the appropriate business role in the SAP Fiori app
Maintain Business Roles, and there to the Assigned
Launchpad Spaces tab.
2. Switch to the edit mode and select the Add button.
3. A dialog box opens in which you need to select the option,
Create New Space.
4. Then you must assign the space ID, a description, and a title to
the new launchpad space.
5. Close the dialog box by clicking the button, Create and Assign
Space.

Figure 12.12 shows the created launchpad space. Finally, you need
to save your changes.
Figure 12.12     IAM Business Role with a New Launchpad Space
By clicking on the launchpad space ID (here, it’s ZRAP_TRAVEL_ADMIN),
you’ll get to the overview of launchpad pages. There, you need to
select the launchpad page of the same name that was automatically
created in the course of creating the launchpad space by clicking on
the corresponding line. Then, the detail view of the launchpad page
will open. Switch to the edit mode by clicking on the Edit button.
Here you can add a new section by clicking the Add Section button.
Assign the title “Travel” to the new section in the Section Title field.
Now you can add an IAM app (here: Manage travel) as a tile. To do
this, click the Add button (see Figure 12.13). Save this assignment
as well.

Figure 12.13     Adding an IAM App as a Tile to a Launchpad Page
To ensure that the SAP Fiori launchpad of the ABAP environment
also displays the SAP Fiori apps provided this way, you must first
enable the display of launchpad spaces and pages. To do so,
proceed as follows:
1. In the backend system, open the SAP Fiori app Manage
Launchpad Settings (under User Interface - Configuration).
2. Checkmark the SPACES flag. Irrespective of this, you can allow
business users to make this setting themselves via the
SPACES_ENABLE_USER flag.
If you’ve enabled the SPACES_ENABLE_USER flag, users can control
whether or not launchpad spaces and pages will be displayed. This
setting can be reached in the user menu via menu item Settings •
Spaces and Pages.
If a business user has been assigned the previously created IAM
business role (which points to a launchpad space), the
corresponding SAP Fiori apps can each be called as a tile.
[+]  Tip: Enabling a Dynamic Counter on Tiles

You can request a simple metric using the RAP business service
exposed as OData and display it on a tile. To do this, you must use
the indicatorDataSource property in the manifest.json file of the
generated SAPUI5 or SAP Fiori elements application and
formulate a corresponding OData request under path. In
Listing 12.3, the number of Travel instances that have the overall
status “Open” is calculated. This key figure will then be displayed
on the tile.
...
          "semanticObject": "Travel",
            "action": "manage",
            ...
            "indicatorDataSource": {
               "dataSource": "mainService",
               "path": "Travel/$count?$filter=OverallStatus
                  eq 'O'",
               "refresh": 180
             }
          }
      }
  }
Listing 12.3     Definition of a Dynamic Counter in the manifest.json File

12.4    Consuming Business Services
In the SAP BTP, ABAP environment there are two ways to address
and thus consume business services:
Via the SAP Destination Service
For this purpose, you need to define a destination to another
system via the SAP BTP cockpit. After that you can address the
destination from within the ABAP source code.
Via a communication arrangement
Using this approach, you can manage service endpoints in
concrete systems and the associated login data directly in the
ABAP environment instead of going through the SAP BTP level.
To enable the consumption via the SAP Destination Service, you
should proceed as follows: In the SAP BTP subaccount where your
instance of the ABAP environment was created, you must create a
connection (destination) to the system on which the service to be
consumed is provided . The SAP Destination Service is similar to
Transaction SM59 (Configuration RFC Connections), so you can
think of a destination as an RFC connection. You can reference the
created destination in your ABAP code and thus gain access to the
system or the remote interface via HTTP or RFC, for example.
Figure 12.14 shows the Destinations area in the SAP BTP cockpit,
where you create and manage the destinations.

Figure 12.14     HTTP Destination in SAP Destination Service
Alternatively, you can use a communication arrangement. As part of
the development in ADT, you do this by encapsulating an outgoing
service you want to consume in an outbound service. To reference
one or more of such services, you can use a communication
scenario:
1. Open the context menu by right-clicking on the package in which
you want to create the outbound service. Select New • Other
ABAP Repository Object.
2. A creation dialog opens, in which you should select the
Outbound Service item under Cloud Communication
Management. Then, click the Next button.
3. Enter a name for the outbound service in the Outbound Service
input field and a description under Description. In the Service
Type drop-down menu, select the type of the corresponding
service and finish the process with Finish.
4. Then, create a communication scenario by opening the creation
dialog as described before, and then selecting Communication
Scenario under Cloud Communication Management.
5. Enter a name for the communication scenario in the Name input
field and a description under Description. Complete the process
by clicking the Finish button.

6. The ADT editor for the communication scenario will open. There,
on the Outbound tab, under Outbound Services, assign the
previously created outbound service by clicking the Add...
button to assign the previously created outbound service.
7. Save the communication scenario and then click the Publish
Locally button.
An administrator can then set up a communication arrangement with
reference to the communication scenario in the SAP Fiori launchpad
and store login data there. Figure 12.15 shows this step in the SAP
Fiori app Communication Arrangement.
Figure 12.15     Creating a Communication Arrangement with Reference to a
Communication Scenario
In the ABAP source code, you then only reference the
communication scenario (which is kept in the repository in the same
way as the ABAP source code), regardless of the concrete
communication arrangement and the system-dependent login data.
Communication thus represents the counterpart to the destination
when using the SAP Destination Service. In this way, the
development objects are decoupled from the administrative layer of
the communication arrangement, and you leave it to the runtime
environment to find the appropriate communication arrangement. In

this scenario, you can use the following protocols: HTTP, SOAP, and
RFC.
Regardless of whether you use the SAP Destination Service or a
communication arrangement, you basically have two options for
consuming remote interfaces from the ABAP environment:
Client APIs (without interface data types)
You can use client APIs to consume remote interfaces via OData,
SOAP, HTTP, or RFC. To consume HTTP services, for example,
you can use the CL_WEB_HTTP_CLIENT_MANAGER class and the
IF_WEB_HTTP_CLIENT interface. Syntactically, you call RFC function
modules in the same way as in an on-premise environment (i.e.,
you use the CALL FUNCTION ... DESTINATION statement). However,
in this context, you use a destination procured via a special API. In
both cases, you use your own data types to consume the remote
interface.
Service consumption model (with interface data types)
The service consumption model (SCM) represents a local model
of the service based on interface metadata of that service. In the
course of creating an SCM, development objects representing the
data types of the remote interface are generated via the interface
metadata. In the OData protocol, RAP artifacts are generated, for
example, based on the entity type (EntityType) of the OData
service (see Figure 12.16).

Figure 12.16     Service Consumption Model for Test Data Service Northwind in OData
Version V4
You can use the SCM and the generated development objects to call
a remote interface in ABAP. All you need is a destination that has
been created in the SAP Destination Service. The CSM supports the
OData, SOAP, and RFC protocols.
To integrate a remote data source for read operations into a RAP
application, you can create a CDS custom entity (see Chapter 2,
Section 2.7.2). In the ABAP implementation of the custom query, you
consume the remote interface via the CSM, evaluate the response
and return the data in the fields of the CDS custom entity (see
Listing 12.4).
METHOD if_rap_query_provider~select.
  DATA: lt_business_data TYPE TABLE OF zrap_nw_customers, ...
  TRY.
    lo_http_client = cl_web_http_client_manager=>create_by_http_destination(
  cl_http_destination_provider=>create_by_cloud_destination(
     i_name       = 'NORTHWIND_OD_V4'
     i_authn_mode = if_a4c_cp_service=>service_specific ) ).
 
     lo_client_proxy = 
      cl_web_odata_client_factory=>create_v4_remote_proxy(
          EXPORTING
            iv_service_definition_name = 'ZRAP_BTP_SCM_NW_OD'
            io_http_client             = lo_http_client
            iv_relative_service_root   = '' ).
 
     lo_request = 
      lo_client_proxy->create_resource_for_entity_set(

       'CUSTOMERS' )->create_request_for_read( ).
     ...
     lo_response = lo_request->execute( ).
     " Read response data
     lo_response->get_business_data( IMPORTING et_business_data = 
lt_business_data ).
     " Return response data as query response
     ...
    CATCH ...
  ENDTRY.
ENDMETHOD. 
Listing 12.4     Consuming an OData-based Service Consumption Model Within the
Implementation of a Custom Query
First, you create a HTTP client instance (lo_http_client) based on a
destination. On the basis of this instance and using an SCM (here
ZRAP_BTP_SCM_NW_OD from Figure 12.16) you create a client proxy
(lo_client_proxy). You can use the client proxy to submit requests
(lo_request), read the returned data (get_business_data( )), and
process it further.
Alternatively, you can find the respective service endpoint via a
communication arrangement (see Listing 12.5).
     lo_http_client = cl_web_http_client_manager=>create_by_http_destination(
  cl_http_destination_provider=>create_by_comm_arrangement(
    comm_scenario  = 'ZRAP_BTP_COM_NW_OD' ) ). 
Listing 12.5     Finding the Service Endpoint via a Communication Arrangement
In this case, you use a communication scenario
(ZRAP_BTP_COM_NW_OD) to have a suitable communication arrangement
determined from it at runtime via the method,
CREATE_BY_COMM_ARRANGEMENT. The prerequisite here is that the finding
is unique.
[+]  Tip: Further Information on Finding Communication
Arrangements

For a flexible determination of communication arrangements
based on communication scenarios, we’d like to refer you to the
online documentation in SAP Help Portal at http://s-
prs.de/v868519.
Let’s suppose you want to use the use case from Chapter 10, in the
SAP BTP, ABAP environment. To do this, you must call the BAPIs
used for write operations on an on-premise system. You can
implement the pure RFC call in ABAP as usual using CALL FUNCTION
with DESTINATION. However, you must obtain the concrete RFC
destination via the connectivity API of the ABAP environment, which
in turn is based on a destination from the SAP Destination Service
(see Listing 12.6).
METHOD if_oo_adt_classrun~main.
 
  TRY.
 
      DATA(rfc_dest) = 
   cl_rfc_destination_provider=>create_by_cloud_destination( 
               EXPORTING i_name = 'RFC_DEST' ).
      DATA(rfc_dest_name) = rfc_dest->get_destination_name( ).
...
      CALL FUNCTION 'BAPI_PO_CREATE1'
        DESTINATION
          rfc_dest_name
        EXPORTING
          poheader  = ls_po_header
          poheaderx = ls_x_po_header
          testrun   = abap_false
        TABLES
          return    = lt_return.
...
    CATCH cx_rfc_dest_provider_error INTO DATA(lo_cx_rfc).
      out->write( lo_cx_rfc->get_text( ) ).
  ENDTRY.
ENDMETHOD. 
Listing 12.6     RFC Call in the ABAP Environment via a Destination
For this purpose, you’d have to modularize the read access to the
relevant purchase orders from the sample scenario in Chapter 10 in

a suitable way on the on-premise system, make it remotely
executable, and integrate it via a CDS custom entity.

13    Outlook
This chapter provides a final outlook on planned further
developments of the ABAP RESTful application
programming model.
Over the course of this book, you’ve gained comprehensive insight
into building applications with the ABAP RESTful application
programming model. Now, we want to conclude this book with an
outlook. Further development of the ABAP RESTful application
programming model as the central programming model for the ABAP
platform is of strategic importance to SAP and is constantly being
driven forward. We’d like to take this continuous development into
account and provide some essential outlooks in the following
sections.
[ ! ]  Warning: Reliability of Statements about the SAP
Roadmap
Note that the statements made in this chapter about the SAP
roadmap are subject to SAP's legal disclaimer, which you can find
at https://roadmaps.sap.com/welcome under Disclaimer. This
means the statements made in this chapter may be subject to
change.
SAP has divided the further development of the ABAP RESTful
application programming model into different dimensions, each of

which takes a particular view of the programming model and thus
sets thematic priorities:
Build (Section 13.1)
Extensibility (Section 13.2)
Integration and reusability (Section 13.3)
Figure 13.1 shows which topics are assigned to each of these
categories.
Figure 13.1     Dimensions of the ABAP RESTful Application Programming Model
13.1    Build
The topics summarized under build cover the core functionality of the
ABAP RESTful application programming model as described in this
book. This includes the basic modeling of business objects, the
implementation of transactional behavior in various possible
combinations, and the exposure of business functionality via the
OData protocol in the context of a stateless environment. The main
goal in this area is to better integrate RAP business objects into the
SAP Fiori UI world.
In addition to the implementation of business logic via the ABAP
RESTful application programming model, this group of topics also
focuses on improved support for the testability of RAP business
objects, the expansion of documentation capabilities, and the use of
generator-based approaches via the extension component (XCO)

library (see Chapter 12, Section 12.1.2). A RAP generator is to be
introduced, which can be used to generate simple RAP applications,
similar to how table maintenance dialogs can be generated in a
classic application development, for example.
In addition, tracing functions are supposed to be provided under the
name ABAP Cross Trace, with which the sequence of RAP
transactions can be continuously traced for development and
analysis purposes.

13.2    Extensibility
SAP S/4HANA Cloud is operated by SAP for its customers.
Technical enhancement options are currently provided here via key
user extensibility. They include field extensions, the web-based
implementation of business add-ins (BAdIs), and CDS custom views.
Modifications to the system aren’t allowed due to the cloud operating
model. Access to the cloud tenant via an ABAP-based development
environment is currently not (as of yet) planned, so that initially a gap
exists with regard to the possibility of integrating ABAP-based
customer developments and extending SAP S/4HANA Cloud.
The good news is that this gap will be closed by SAP. The cloud-
based development model for the SAP BTP, ABAP environment will
also be made available for SAP S/4HANA Cloud for this purpose.
This affects the entire development model including the ABAP
language version for the cloud, the use of infrastructure components
via released APIs and, of course, the use of the ABAP RESTful
application programming model. This project is referred to as
Embedded Steampunk. With the embedded ABAP environment, you
can use ABAP development tools (ADT) as you know them from
your on-premise environment, but adapted to the cloud operating
model.
[+]  Tip: More Information About Embedded Steampunk
In the blog entry “Steampunk is going all in” by Harald Kuck, you’ll
find useful further information on how the ABAP environment
positions itself and behaves technically in SAP S/4HANA Cloud.
You can read the blog entry at
https://blogs.sap.com/2021/09/30/steampunk-is-going-all-in/.

The extensibility of business applications in SAP S/4HANA Cloud
and thus also with the ABAP RESTful application programming
model opens up new opportunities for you. Based on the core
artifacts of the programming model, such as the CDS data model or
the behavior definition, generic extension points are supposed to be
provided. Accordingly, a RAP business object determines at which
points it may be extended. This concept is made possible by the
model-driven approach of the ABAP RESTful application
programming model. Standard operations such as create, update
and delete have a clearly defined meaning in the behavior definition
so that extensibility can be comprehensively mapped across all RAP
business objects. SAP will provide new mechanisms in the ABAP
RESTful application programming model to allow you to both make
your own RAP business objects extensible and to add your own logic
to existing extensible RAP business objects.
The planned concept of RAP APIs or business object interfaces is
also part of the group of topics related to extensibility. This concept is
supposed to allow for a shared, local interface to be declared and
used for a RAP business object. In this way, SAP can make
specialist functionality from SAP S/4HANA Cloud externally
accessible so that customer-specific applications can access it.
Consequently, SAP will also wrap business functionality of the SAP
S/4HANA core with RAP capabilities and thus provide uniform
interfaces for these business functions. Those interfaces will be
officially released and exposed via their own RAP artifacts, called
behavior interfaces. For example, you’ll be able to create a sales
order via EML and have local access to specialist APIs. You’ll then
no longer need to access these functions via remote interfaces, as
you do on SAP BTP.

Extensive development and enhancement options for SAP S/4HANA
Cloud are thus planned, which are compatible with the requirement
for continuous and reliable updates.

13.3    Integration and Reusability
While the two previously described dimensions allow RAP business
objects to be implemented with their own behavior and to be
provided with extension mechanisms, the topics related to
integration and reusability provide for new integration functions and
the connection of infrastructure or reuse components to a RAP
business object—natively, using the means of the ABAP RESTful
application programming model. For this purpose, a RAP business
object will be able to connect to infrastructure components with their
own functionality, such as change documents or the attachment and
note function. For example, even though you could also manually
integrate the change document functionality into a RAP business
object using appropriate APIs, there are significant advantages to
having this integration already built into the ABAP RESTful
application programming model. The principle is then roughly
comparable to the integration of SAP Gateway as the implementing
technology for OData accesses. In this way, field extensions of a
RAP business object, for example, will be taken into account by
default when updating change documents, without you having to
think about a manual integration in the context of application
development. In addition to the above functions, it’s also planned to
connect the RAP business object to the output control in order to
standardize the email or print output.
Thus, SAP continues to make it its goal to ensure development
efficiency, also in the context of connecting infrastructure services. In
this context, it’s essential that aspects such as transactional
consistency or testability are taken into account by the ABAP
RESTful application programming model.

In the future, a RAP business object can serve as a source for
asynchronous, event-based communication and generate business
events. It should be possible that these events, which are decoupled
from the RAP business object, be consumed by one or more
recipients (e.g., via the SAP Event Mesh service on the SAP BTP).
Finally, SAP plans to provide a migration tool that allows you to
migrate CDS-based BOPF objects from the ABAP programming
model for SAP Fiori to the RAP world. Investments you’ve made in
application development with the former programming model can
therefore be safeguarded. In addition, you can enjoy the benefits of
the ABAP RESTful application programming model if, after the
migration, the application is mapped using RAP artifacts.

A    Bibliography
A.1    Books
Bönnen, Carsten, Volker Drees, André Fischer, Ludwig Heinz, and
Karsten Strothmann, SAP Gateway and OData, 3rd edition
(Quincy, MA: SAP PRESS, 2018).
Colle, Renzo, Ralf Dentzer, and Jan Hrastnik, Core Data Services
for ABAP, 2nd edition (Quincy, MA: SAP PRESS, 2021).
Englbrecht, Michael, SAP Fiori. Implementierung und Entwicklung,
3rd edition (Bonn, Germany: SAP PRESS, 2020).
Haas, Stefan, and Bince Mathew, ABAP RESTful Programming
Model. ABAP Development for SAP S/4HANA, 1st edition
(Quincy, MA: SAP PRESS, 2020).

A.2    Online Resources
Fischer, André. 2019. “How to implement a custom entity in the
ABAP RESTful Programming Model using remote function
modules.” Published March 1, 2019. SAP Community.
https://blogs.sap.com/2019/03/01/how-to-implement-a-custom-
entity-in-the-abap-restful-programming-model-using-remote-
function-modules/.
Microsoft. 2022. “Getting started with Visual Studio Code.” Visual
Studio Code. Last modified May 4, 2022.
https://code.visualstudio.com/docs/introvideos/basics.
SAP. n.d. “ABAP RESTful Application Programming Model.” SAP
Help Portal. Accessed March 7, 2022.
https://help.sap.com/viewer/923180ddb98240829d935862025004
d6/Cloud/en-US/289477a81eec4d4e84c0302fb6835035.html.
SAP. n.d. “ABAP CDS Development User Guide.” SAP Help
Portal. Accessed March 7, 2022.
https://help.sap.com/viewer/f2e545608079437ab165c105649b89d
b/202009.001/en-US/4ed1f2e06e391014adc9fffe4e204223.html.
SAP. n.d. “Development in the ABAP Environment.” SAP Help
Portal. Accessed March 7, 2022.
help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4
b/31367ef6c3e947059e0d7c1cbfcaae93.html.
SAP: SAP Fiori Design Guidelines, In: https://experience.sap.com/
fiori-design.
Tchoutouo Djomo, Carine. 2019. “Getting Started with the ABAP
RESTful Application Programming Model (RAP).” Published
October 25, 2019. SAP Community.

https://blogs.sap.com/2019/10/25/getting-started-with-the-abap-
restful-programming-model/.
Tchoutouo Djomo, Carine. 2021. “Modernization with the ABAP
RESTful Application Programming Model (RAP).” Published
October 18, 2021. SAP Community.
https://blogs.sap.com/2021/10/18/modernization-with-rap/.
Online Courses
Tchoutouo Djomo, Carine, André Fischer, and Martin Huvar. 2020.
“Building Apps with the ABAP RESTful Application Programming
Model.” OpenSAP.
https://open.sap.com/courses/cp13/items/3LSB5Z7WditAxgzyRbE
j3L.

B    Authors
Lutz Baumbusch has been working as an SAP developer since
2000 and manages international SAP projects in various roles and
areas of responsibility. As a member of the S/4HANA Development
team at All for One Group SE, he prepares current developer topics
for internal and external training purposes. He completed his studies
at Karlsruhe Institute of Technology (KIT) in Germany.
Matthias Jäger is a freelance SAP developer of software products
based on the ABAP platform. In addition to his work as a developer,
he works as a software architect and coach, designing cross-product

and technical aspects, and providing trainings. In 2004, he started
his career as an SAP developer and as a developer of a Java-based
software product. After that, he worked as a developer, development
manager, and trainer in different SAP implementation projects in the
logistics sector. Since 2011, he has been a regular guest lecturer at
DHBW Stuttgart, where he teaches ABAP programming and the use
of system analysis methods. He studied business informatics at
DHBW Heidenheim, Germany, as part of a dual-degree program.
Michael Lensch is responsible for a team of SAP developers at All
for One Group SE. In addition, as a development manager, he is
responsible for development in SAP S/4HANA implementation
projects in Germany and other countries. Since 2014, he has also
led a technical team focused on developing in SAP HANA or SAP
S/4HANA. Prior to that, he studied computer science at the
University of Applied Sciences in Trier, Germany.

Index
↓A  ↓B  ↓C  ↓D  ↓E  ↓F  ↓G  ↓H  ↓I  ↓J  ↓K  ↓L  ↓M  ↓N  ↓O  ↓P  ↓Q  
↓R  ↓S  ↓T  ↓U  ↓V  ↓W  ↓X  ↓Z  
/IWFND/GW_CLIENT [→ Section 6.4]
/IWFND/MAINT_SERVICE [→ Section 2.7] [→ Section 6.4]
%CID [→ Section 4.1] [→ Section 11.5]
%CONTROL [→ Section 4.1] [→ Section 11.4]
%DATA [→ Section 4.1]
%ELEMENT [→ Section 4.1]
%FAIL [→ Section 4.1]
%ISDRAFT [→ Section 4.1]
%MSG [→ Section 4.1]
%PARAM [→ Section 4.1]
%PID [→ Section 4.1]
%TKY [→ Section 4.1]
.env file [→ Section 9.9]
A ⇑

ABAP
classic application development [→ Section 1.1]
for cloud development [→ Section 12.1]
package [→ Section 9.2]
programming models [→ Section 1.1]
report [→ Section 4.3]
ABAP annotation [→ Section 2.4]
ABAP development tools [→ Section 1.4] [→ Section 2.2]
[→ Section 3.2]
ABAP Dictionary [→ Section 1.1]
ABAP Environment → see [SAP BTP, ABAP Environment]
ABAP Flight Reference Scenario [→ Section 1.1]
ABAP PaaS → see [SAP BTP, ABAP Environment]
ABAP programming model for SAP Fiori [→ Section 1.1]
ABAP Repository [→ Section 1.1]
ABAP RESTful application programming model [→ Section
1.1]
API [→ Section 13.2]
availability [→ Section 1.6]
development objects [→ Section 1.3]
extensibility [→ Section 13.2]
further development [→ Section 13.1]
history [→ Section 1.1]
properties [→ Section 1.1]

quality features [→ Section 1.5]
request [→ Section 1.2]
runtime behavior [→ Section 5.2]
transaction model [→ Section 1.2]
use cases [→ Section 8.1] [→ Section 8.1]
ABAP Unit [→ Section 1.5] [→ Section 4.3]
abapGit [→ Section 12.1]
Access control [→ Section 2.2] [→ Section 2.5] [→ Section 9.3]
[→ Section 10.7] [→ Section 10.7]
Access, concurrent [→ Section 3.12]
Action [→ Section 3.11]
creating [→ Section 9.8]
defining [→ Section 7.2]
executing [→ Section 4.2]
factory [→ Section 3.11]
function import [→ Section 6.4]
input parameter [→ Section 3.11]
instance-based [→ Section 3.11]
navigation [→ Section 12.3]
static [→ Section 3.11] [→ Section 3.16]
Additional Save [→ Section 3.3] [→ Section 8.2]
Ad-hoc association [→ Section 2.3]
ADJUST_NUMBERS [→ Section 10.4]
ADT → see [ABAP development tools]

Alias [→ Section 3.5]
Annotation [→ Section 1.1] [→ Section 2.1] [→ Section 2.4]
[→ Section 7.2]
ABAP [→ Section 2.4]
AbapCatalog [→ Section 2.6]
AccessControl [→ Section 2.2] [→ Section 2.5]
active [→ Section 2.4] [→ Section 2.4]
database tables [→ Section 2.4]
framework-specific [→ Section 2.4]
grouping [→ Section 7.2]
metadata extension [→ Section 2.6]
ObjectModel [→ Section 2.7]
scope [→ Section 2.4] [→ Section 2.4]
Semantics [→ Section 2.2]
syntax [→ Section 2.4]
API [→ Section 1.1]
direct call [→ Section 1.1]
framework-based [→ Section 1.1]
legacy application [→ Section 11.2]
local [→ Section 8.1]
reusing [→ Section 11.2]
Application generator [→ Section 9.9]
Application programming interface → see [API]
as projection on [→ Section 2.9]

Association [→ Section 2.1] [→ Section 2.2] [→ Section 2.3]
[→ Section 9.2]
accessing [→ Section 2.3]
cardinality [→ Section 2.3]
draftable [→ Section 3.15]
name [→ Section 2.3]
standard operation [→ Section 3.10]
Authorization check [→ Section 3.14] [→ Section 5.4]
[→ Section 10.7]
delegating [→ Section 3.14]
excluding [→ Section 3.14]
global [→ Section 3.14] [→ Section 5.4] [→ Section 10.7]
instance-based [→ Section 3.14] [→ Section 10.7]
Authorization concept [→ Section 2.5]
Authorization dependent [→ Section 3.14]
Authorization handler [→ Section 5.4]
Authorization master [→ Section 3.14] [→ Section 10.7]
Authorization object [→ Section 12.2]
Authorization trace [→ Section 10.7]
Auto-completion [→ Section 3.2]
B ⇑
BAPI [→ Section 10.1] [→ Section 10.4]
Basic interface view [→ Section 2.2] [→ Section 2.8]

creating [→ Section 9.2] [→ Section 11.3]
BDL [→ Section 1.3]
Before-image [→ Section 5.4]
Behavior [→ Section 1.3]
transactional [→ Section 3.1]
Behavior definition [→ Section 1.3] [→ Section 1.3] [→ Section
2.9] [→ Section 3.1] [→ Section 10.3]
actions [→ Section 7.2]
activating [→ Section 3.2]
changing [→ Section 3.2]
creating [→ Section 3.2]
syntax [→ Section 3.1]
Behavior definition language [→ Section 1.3] [→ Section 3.1]
syntax [→ Section 3.1]
Behavior implementation [→ Section 1.3] [→ Section 5.1]
[→ Section 5.1] [→ Section 5.3] [→ Section 9.6] [→ Section
10.4]
Behavior interface [→ Section 13.2]
Behavior pool [→ Section 3.6] [→ Section 5.1]
creating [→ Section 10.4] [→ Section 11.5]
Behavior projection [→ Section 1.3]
Binding type [→ Section 6.3] [→ Section 6.3] [→ Section 9.4]
BO consumer [→ Section 1.2]

BO framework [→ Section 1.2]
BO provider [→ Section 1.2]
BO runtime [→ Section 5.1]
BOPF [→ Section 1.1] [→ Section 13.3]
BOPF managed [→ Section 8.2]
Brownfield approach [→ Section 1.1] [→ Section 8.3]
[→ Section 11.1]
BSP [→ Section 12.3]
BSP application [→ Section 9.9]
Built-in function [→ Section 2.2]
Business application, architecture [→ Section 1.1]
Business logic, internal [→ Section 3.1] [→ Section 3.13]
Business object [→ Section 1.1] [→ Section 1.3] [→ Section
1.5]
composition tree [→ Section 3.1]
field [→ Section 3.1]
interface [→ Section 3.1]
Business Object Framework [→ Section 1.2]
Business Object Processing Framework → see [BOPF]
Business Object Provider API [→ Section 1.3] [→ Section 5.1]
Business Server Pages [→ Section 12.3]
Business service [→ Section 1.3] [→ Section 2.9] [→ Section
6.1]

consuming [→ Section 12.4]
defining [→ Section 9.4] [→ Section 10.6]
test [→ Section 6.4]
transporting [→ Section 6.3]
versioning [→ Section 6.3]
Business user [→ Section 12.1]
C ⇑
Calendar [→ Section 7.2]
Camel-case notation [→ Section 2.2]
Cardinality [→ Section 2.3] [→ Section 3.11]
CDS [→ Section 1.1] [→ Section 2.1] [→ Section 2.1]
CDS behavior definition → see [Behavior definition]
CDS custom entity [→ Section 8.3] [→ Section 12.4]
CDS entity
abstract [→ Section 3.11]
custom [→ Section 2.7]
extending [→ Section 2.6]
instances [→ Section 3.10]
CDS metadata extension → see [metadata extension]
CDS projection view [→ Section 1.3] [→ Section 2.9]
creating [→ Section 9.2] [→ Section 10.6] [→ Section
11.3]
virtual element [→ Section 2.7]

CDS role [→ Section 2.5]
CDS root entity [→ Section 1.3]
CDS view
annotations [→ Section 7.2]
creating [→ Section 2.2]
SAP HANA [→ Section 2.1]
types [→ Section 2.8]
CDS view entity [→ Section 2.9]
Change operation [→ Section 5.4]
CHECK_BEFORE_SAVE [→ Section 5.2] [→ Section 5.5]
CL_ABAP_BEHAVIOR_HANDLER [→ Section 5.3]
CL_ABAP_BEHAVIOR_SAVER [→ Section 5.3]
CL_ABAP_BEHV [→ Section 5.3]
CLEANUP [→ Section 5.5]
CLEANUP_FINALIZE [→ Section 5.5]
Client API [→ Section 12.4]
Client/server architecture [→ Section 1.1]
Cloud connector [→ Section 12.1]
Cloud readyness [→ Section 1.1]
Code completion [→ Section 3.2]
Code pushdown [→ Section 1.1] [→ Section 1.1] [→ Section
2.1]

Code-to-data paradigm [→ Section 2.1]
Comment [→ Section 3.1]
COMMIT ENTITIES [→ Section 4.2] [→ Section 5.2]
Communication agreement [→ Section 12.2] [→ Section 12.4]
Communication scenario [→ Section 12.2] [→ Section 12.4]
[→ Section 12.4]
Communication, stateless [→ Section 1.1]
Composite interface view [→ Section 2.8]
Composition [→ Section 2.9] [→ Section 4.2] [→ Section 9.2]
composition [] of [→ Section 2.9]
Composition tree [→ Section 3.1]
Constructor expression [→ Section 1.1] [→ Section 10.4]
Consumer [→ Section 3.10]
Consumption view [→ Section 1.3] [→ Section 2.8]
Content area [→ Section 7.2]
Content ID [→ Section 4.1]
Content type [→ Section 1.1]
Control flow [→ Section 1.1]
Control structure [→ Section 11.4]
CONVERT KEY [→ Section 4.2] [→ Section 5.2]
Core Data Services R CDS [→ Section 2.1]
create [→ Section 3.10]

CREATE FIELDS [→ Section 4.2]
Create-by-association [→ Section 3.10] [→ Section 4.2]
CRUD operation [→ Section 3.10]
Custom Field and Logic (App) [→ Section 2.6]
Custom query [→ Section 12.4]
D ⇑
Data consistency [→ Section 3.12]
Data Control Language [→ Section 2.5]
Data Definition Language [→ Section 1.1]
Data model [→ Section 1.1]
extending [→ Section 2.2]
logical [→ Section 10.2]
Data source [→ Section 2.2]
Data type [→ Section 1.1]
derived [→ Section 4.1] [→ Section 11.4]
Database table [→ Section 9.2] [→ Section 10.2]
Date field [→ Section 7.2]
DDL [→ Section 1.1]
Default Authorization Value [→ Section 12.2]
Default filter [→ Section 7.2]

define behavior for [→ Section 2.9] [→ Section 3.1] [→ Section
3.5]
define service [→ Section 2.9]
define view [→ Section 2.9]
define view entity [→ Section 2.9]
delete [→ Section 3.10] [→ Section 10.5]
DELETE (HTTP) [→ Section 1.1]
Deployment [→ Section 9.9]
Destination [→ Section 12.4]
Detail view [→ Section 7.2]
Determination [→ Section 3.13] [→ Section 5.4]
determination [→ Section 3.13]
action [→ Section 3.13]
creating [→ Section 9.6]
declaring [→ Section 10.4]
implementing [→ Section 10.4]
infinite loop [→ Section 3.13]
method [→ Section 5.4]
side effects [→ Section 7.2]
times [→ Section 3.13]
determine action [→ Section 3.13]
Dev space [→ Section 7.1]
Development efficiency [→ Section 1.1] [→ Section 1.5]

Development flow [→ Section 1.1]
Development object [→ Section 1.1]
Displaying a button [→ Section 7.2]
Domain [→ Section 2.4]
Domain-specific language [→ Section 1.1] [→ Section 1.1]
Draft action [→ Section 3.15] [→ Section 3.15]
Draft handling [→ Section 1.1] [→ Section 1.2] [→ Section
3.15]
enabling [→ Section 3.15] [→ Section 9.3]
Draft instance [→ Section 3.15]
Draft lifecycle [→ Section 3.15]
Draft table [→ Section 3.15] [→ Section 9.3]
DSL → see [Domain-specific language]
dynamic feature control [→ Section 3.1] [→ Section 3.16]
Dynamic page header [→ Section 7.2]
Dynpro [→ Section 1.1]
E ⇑
Early numbering [→ Section 3.7]
Eclipse Theia [→ Section 7.1]
Element, virtual [→ Section 2.7] [→ Section 6.1] [→ Section
9.2]

Embedded deployment [→ Section 1.1]
Embedded Steampunk [→ Section 13.2]
EML [→ Section 1.2] [→ Section 1.2] [→ Section 4.1]
[→ Section 4.1]
operations [→ Section 4.2]
Enqueue server [→ Section 3.12]
Entity [→ Section 1.1] [→ Section 1.3]
Entity behavior definition [→ Section 3.1] [→ Section 3.5]
Entity Manipulation Language → see [EML]
Entity set [→ Section 1.1]
Entity tag → see [ETag]
Error message [→ Section 7.2] [→ Section 10.4]
ETag [→ Section 3.12]
dependent [→ Section 3.12]
field [→ Section 3.15]
handling [→ Section 3.15]
master [→ Section 3.12]
Evolution capability [→ Section 1.5]
Exception class [→ Section 9.7]
Extension [→ Section 7.1]
Extension include view [→ Section 2.6]
F ⇑

Facet [→ Section 7.2] [→ Section 9.5]
Factory action [→ Section 3.11] [→ Section 3.16]
FAILED [→ Section 4.1]
Feature [→ Section 3.1]
Feature control [→ Section 5.4]
dynamic [→ Section 3.16]
global [→ Section 3.16]
instance-based [→ Section 3.16]
static [→ Section 3.16]
Field
business object [→ Section 3.1]
extension [→ Section 2.6]
mapping [→ Section 3.1] [→ Section 3.9] [→ Section 10.4]
name [→ Section 2.8]
property [→ Section 3.8] [→ Section 10.4]
virtual [→ Section 2.7]
Filter bar [→ Section 7.2]
Filter condition [→ Section 7.2] [→ Section 10.6]
FINALIZE [→ Section 5.2] [→ Section 5.5]
Flight data model, new [→ Section 1.1]
Floorplan [→ Section 7.2]
Follow-up screen [→ Section 7.2]
Footer toolbar [→ Section 7.2]

FOR CREATE [→ Section 11.5]
FOR DETERMINE [→ Section 5.4]
FOR FEATURES [→ Section 5.4]
FOR GLOBAL FEATURES [→ Section 5.4]
FOR INSTANCE AUTHORIZATION [→ Section 5.4]
FOR LOCK [→ Section 5.4] [→ Section 10.5]
FOR MODIFY [→ Section 5.4]
FOR NUMBERING [→ Section 5.4]
FOR PRECHECK [→ Section 5.4] [→ Section 10.7]
FOR READ [→ Section 5.4] [→ Section 11.5]
FOR READ by association [→ Section 5.4]
FOR UPDATE [→ Section 11.5]
FOR VALIDATE [→ Section 5.4]
Framework-specific annotation [→ Section 2.4]
Function [→ Section 3.11]
Function group [→ Section 11.2]
Function import [→ Section 6.4] [→ Section 7.2]
Function Module [→ Section 2.7]
Function module [→ Section 11.1]
Function, built-in [→ Section 2.2]
Functional relationship [→ Section 2.3]

G ⇑
GET [→ Section 1.1]
GET PERMISSIONS [→ Section 4.2]
Git client [→ Section 7.1]
Global feature control [→ Section 5.4] [→ Section 5.4]
Greenfield approach [→ Section 1.1] [→ Section 8.3]
Guided development [→ Section 7.2]
H ⇑
Handler class [→ Section 11.5]
HATEOS [→ Section 1.1]
Header toolbar [→ Section 7.2]
Help view [→ Section 10.2]
HTTP [→ Section 1.1] [→ Section 1.1]
client [→ Section 1.1]
endpoint [→ Section 1.1]
method [→ Section 1.1]
request [→ Section 1.1]
response [→ Section 1.1]
server [→ Section 1.1]
service [→ Section 12.1]
Hub deployment [→ Section 1.1]
Hyperlink [→ Section 1.1]

Hypertext Transfer Protocol → see [HTTP]
I ⇑
IAM → see [Identity and Access Management]
Identity and Access Management [→ Section 12.2]
app [→ Section 12.2] [→ Section 12.3]
business catalog [→ Section 12.2] [→ Section 12.3]
business role [→ Section 12.2] [→ Section 12.2]
[→ Section 12.3]
Implementation class [→ Section 9.6] [→ Section 11.5]
Implementation group [→ Section 3.6]
implementation in class [→ Section 3.6]
Implementation type [→ Section 1.2] [→ Section 1.3]
[→ Section 3.1] [→ Section 3.3] [→ Section 8.2]
abstract [→ Section 3.3]
BOPF managed [→ Section 8.2]
choosing [→ Section 10.3]
managed [→ Section 8.2]
selecting [→ Section 8.3]
unmanaged [→ Section 11.1]
IN SIMULATION MODE [→ Section 4.2]
InA [→ Section 6.3]
Inbound navigation [→ Section 12.3]
Infinite loop [→ Section 3.13]

Information Access [→ Section 6.3]
Infrastructure component [→ Section 12.1]
inheriting conditions from [→ Section 10.7]
Inner join [→ Section 10.2]
Input help [→ Section 7.2] [→ Section 11.3]
Input parameter
action [→ Section 3.11]
data type [→ Section 3.11]
Instance
active [→ Section 3.15] [→ Section 3.15]
draft [→ Section 3.15]
Integration [→ Section 13.3]
Interaction handler [→ Section 5.2] [→ Section 5.4] [→ Section
10.4] [→ Section 11.5]
Interaction phase [→ Section 1.2] [→ Section 5.2] [→ Section
10.3] [→ Section 11.5]
Interface view layer [→ Section 2.8]
internal [→ Section 3.16]
J ⇑
Join [→ Section 2.3]
Join on Demand [→ Section 2.3]

K ⇑
Key field [→ Section 10.2]
Key user extension [→ Section 2.6]
Key value
permanent [→ Section 3.7]
temporary [→ Section 3.7]
Key, semantic [→ Section 5.2]
Knowledge Transfer Document [→ Section 3.2]
KTD [→ Section 3.2]
L ⇑
Late numbering [→ Section 3.7] [→ Section 3.7] [→ Section
5.2] [→ Section 10.4]
Launchpad page [→ Section 12.3]
Launchpad space [→ Section 12.3]
Layering, systems [→ Section 1.1]
Legacy code [→ Section 11.1]
Link [→ Section 1.1]
List report [→ Section 6.5] [→ Section 7.2]
annotations [→ Section 7.2]
creating [→ Section 7.2] [→ Section 9.9]
Local API [→ Section 8.1]

Lock
exclusive [→ Section 3.15]
explicit [→ Section 4.2]
optimistic [→ Section 3.12]
pessimistic [→ Section 3.12]
Lock dependency [→ Section 5.4]
Lock master [→ Section 3.12] [→ Section 5.4] [→ Section
10.5]
Lock object [→ Section 3.12]
Lock table [→ Section 3.12] [→ Section 3.12]
Lock-dependent [→ Section 3.12]
Locking behavior [→ Section 3.12] [→ Section 10.5]
Logical Unit of Work [→ Section 1.2]
M ⇑
Maintain Business Roles (App) [→ Section 12.3]
Managed [→ Section 3.1] [→ Section 3.3] [→ Section 8.2]
Managed BO provider [→ Section 1.2] [→ Section 3.3]
[→ Section 5.5]
Managed query [→ Section 1.2] [→ Section 2.7] [→ Section
8.2]
Managed scenario [→ Section 1.2] [→ Section 1.2] [→ Section
3.3] [→ Section 3.3] [→ Section 3.3]
Managed scenario → see [Managed scenario]

Message class [→ Section 9.7] [→ Section 10.4]
Meta-annotation [→ Section 2.4]
Metadata [→ Section 2.2] [→ Section 9.5]
Metadata extension [→ Section 2.4] [→ Section 2.6]
[→ Section 9.5] [→ Section 10.8] [→ Section 11.3]
MODIFY ENTITIES [→ Section 4.2]
Modularization [→ Section 1.1]
N ⇑
Name, external [→ Section 3.5]
Navigation [→ Section 7.2]
Number range
interval [→ Section 3.7]
management [→ Section 12.1]
Numbering [→ Section 3.7]
early [→ Section 3.7] [→ Section 3.7] [→ Section 3.7]
[→ Section 3.7] [→ Section 5.4]
external [→ Section 3.7] [→ Section 3.7]
internal [→ Section 3.7] [→ Section 3.7]
late [→ Section 3.7] [→ Section 3.7] [→ Section 3.7]
[→ Section 5.2] [→ Section 10.1] [→ Section 10.1]
[→ Section 10.4] [→ Section 10.4]
managed [→ Section 3.7]
O ⇑

Object page [→ Section 6.5] [→ Section 7.2]
annotations [→ Section 7.2]
section [→ Section 7.2]
OData [→ Section 1.1] [→ Section 1.1] [→ Section 1.2]
query [→ Section 1.1]
V2 [→ Section 6.3]
V4 [→ Section 6.3]
vocabulary [→ Section 1.1]
OData service [→ Section 1.1]
ABAP Environment [→ Section 12.1]
metadata [→ Section 6.4]
publication [→ Section 6.3]
testing [→ Section 6.4]
on modify [→ Section 3.13]
on save [→ Section 3.13] [→ Section 3.13] [→ Section 3.13]
Open Data Protocol → see [OData]
Operation
specific [→ Section 3.1]
standard [→ Section 1.3] [→ Section 3.1] [→ Section 3.10]
visibility [→ Section 3.16]
writing [→ Section 3.1]
Optimistic lock [→ Section 3.12]

Orchestration framework [→ Section 1.2] [→ Section 1.2]
[→ Section 1.2] [→ Section 6.1]
Outbound service [→ Section 12.4]
Output parameter → see [return parameter]
P ⇑
PATCH [→ Section 1.1]
Persistent table [→ Section 3.3] [→ Section 3.9]
Pessimistic locking [→ Section 3.12]
Point of no return [→ Section 5.5]
POST [→ Section 1.1]
Precheck [→ Section 3.16] [→ Section 5.4]
Pretty Printer [→ Section 10.2]
Private view [→ Section 2.8]
Programming language, domain-specific [→ Section 1.1]
Programming model [→ Section 1.1] [→ Section 1.1]
Projection behavior definition [→ Section 3.1] [→ Section 6.1]
[→ Section 10.6]
Projection layer [→ Section 1.3] [→ Section 10.6]
Projection view → see [CDS projection view]
Property, transactional [→ Section 3.1]
Proxy [→ Section 1.1]

PUT [→ Section 1.1]
Q ⇑
Query [→ Section 1.2] [→ Section 8.2]
Quick fix [→ Section 9.3]
R ⇑
RAP → see [ABAP RESTful application programming model]
READ ENTITIES [→ Section 4.2]
Read-by-association [→ Section 3.10] [→ Section 3.10]
[→ Section 4.2]
Reference parameter [→ Section 5.4]
Relation Explorer [→ Section 3.2]
Relationship, functional [→ Section 2.3]
Release contract C1 [→ Section 12.1]
Remote API [→ Section 6.3]
Remote API view [→ Section 2.8]
Remote Function Call [→ Section 12.1]
REPORTED [→ Section 7.2]
Repository object, released [→ Section 12.1]
Representation [→ Section 1.1]
Required entry field [→ Section 3.8]

Required field [→ Section 3.8]
Resource [→ Section 1.1] [→ Section 1.1]
REST [→ Section 1.1] [→ Section 1.1]
architecture principles [→ Section 1.1] [→ Section 1.1]
compliant software architecture [→ Section 1.1]
RESTful API [→ Section 1.1]
result [→ Section 3.11]
Return parameter [→ Section 3.11] [→ Section 3.11]
implicit [→ Section 4.1]
Reusability [→ Section 13.3]
RFC [→ Section 12.1]
Roadmap [→ Section 13.1]
role [→ Section 2.5]
ROLLBACK ENTITIES [→ Section 4.2]
root [→ Section 2.9]
Root entity [→ Section 3.1] [→ Section 10.2]
Root URL [→ Section 6.3]
Runtime component [→ Section 1.2]
S ⇑
SACMSEL [→ Section 2.5]

SADL framework [→ Section 1.2] [→ Section 1.2] [→ Section
1.2] [→ Section 6.1]
SAP Annotation [→ Section 2.4]
SAP API Business Hub [→ Section 1.1]
SAP BTP Cockpit [→ Section 7.1]
SAP BTP, ABAP environment [→ Section 1.6] [→ Section
12.1]
architecture [→ Section 12.1]
use cases [→ Section 12.1]
SAP Business Application Studio [→ Section 7.1]
SAP Business Technology Platform [→ Section 7.1]
SAP Destination Service [→ Section 12.1] [→ Section 12.4]
SAP Fiori [→ Section 1.1] [→ Section 7.1]
SAP Fiori app [→ Section 8.1]
SAP Fiori design guidelines [→ Section 7.1]
SAP Fiori elements [→ Section 1.1] [→ Section 7.1]
[→ Section 9.5] [→ Section 10.8]
draft handling [→ Section 3.15]
floorplan [→ Section 7.2]
preview [→ Section 6.5] [→ Section 9.4]
SAP Fiori launchpad [→ Section 1.1] [→ Section 12.1]
[→ Section 12.3]
ABAP environment [→ Section 12.3]
page [→ Section 12.3]

space [→ Section 12.3]
SAP Fiori Tools [→ Section 7.1] [→ Section 9.9]
SAP Fiori user experience [→ Section 1.1]
SAP Gateway [→ Section 1.1] [→ Section 1.2]
SAP Gateway Client [→ Section 2.7] [→ Section 6.4]
SAP HANA [→ Section 1.1] [→ Section 1.1]
SAP HANA CDS view [→ Section 2.1]
SAP NetWeaver Application Server ABAP [→ Section 1.1]
SAP S/4HANA [→ Section 1.1]
SAPUI5 [→ Section 1.1] [→ Section 7.1]
SAVE [→ Section 5.5]
Save handler [→ Section 5.2] [→ Section 5.5] [→ Section 11.5]
Save option
CDS entity [→ Section 3.3]
managed scenario [→ Section 3.3]
Save sequence [→ Section 1.2] [→ Section 5.2] [→ Section
10.4]
determinations [→ Section 3.13]
implementation [→ Section 11.5]
SAVE_MODIFIED [→ Section 5.5]
Saver class [→ Section 11.5] [→ Section 11.5]
SCM [→ Section 12.4]

Search help [→ Section 7.2] [→ Section 10.8]
Search property [→ Section 7.2]
selective [→ Section 3.11] [→ Section 3.11]
Semantic object [→ Section 12.3]
Separation of Concerns [→ Section 1.5] [→ Section 2.6]
Server [→ Section 1.1]
Service binding [→ Section 1.3] [→ Section 6.1] [→ Section
6.3]
binding type [→ Section 6.3] [→ Section 9.4]
creating [→ Section 10.6]
editor [→ Section 6.3]
publishing [→ Section 6.3] [→ Section 9.4]
versioning [→ Section 6.3]
Service consumer [→ Section 9.4]
Service Consumption Model [→ Section 12.4]
Service definition [→ Section 1.3] [→ Section 6.1] [→ Section
6.2] [→ Section 9.4] [→ Section 10.6]
Service document [→ Section 1.1]
Service endpoint, local [→ Section 6.3]
Service metadata [→ Section 1.1] [→ Section 6.4]
Service Modeler [→ Section 7.2]
Service provider [→ Section 9.4]
Service URL [→ Section 1.1] [→ Section 6.4]

Session variable [→ Section 2.2]
SET LOCKS [→ Section 4.2]
Side effect [→ Section 3.13] [→ Section 7.2]
Side-by-side extension [→ Section 12.1]
Software architecture, REST-compliant [→ Section 1.1]
SQL [→ Section 6.3]
SQL Console [→ Section 2.2]
SQL view [→ Section 2.2]
Standard operation [→ Section 1.3] [→ Section 3.1]
[→ Section 3.10]
Standardization [→ Section 1.1]
Stateless communication [→ Section 1.1]
STAUTHTRACE [→ Section 10.7]
Steampunk → see [SAP BTP, ABAP environment]
Strict mode [→ Section 3.4]
Syntax [→ Section 2.1]
Syntax check [→ Section 3.4] [→ Section 12.1]
T ⇑
Table
customer-specific [→ Section 11.2]
Table expression [→ Section 1.1]

Target data source [→ Section 2.3]
Test class [→ Section 4.3]
Testability [→ Section 1.5]
Text, translation [→ Section 7.2]
Time [→ Section 5.5]
Time stamp [→ Section 3.12]
Total ETag [→ Section 3.15]
process [→ Section 3.12]
Transaction
/IWFND/GW_CLIENT [→ Section 6.4]
/IWFND/MAINT_SERVICE [→ Section 2.7] [→ Section
6.4]
SACMSEL [→ Section 2.5]
STAUTHTRACE [→ Section 10.7]
Transaction buffer [→ Section 1.2] [→ Section 5.2] [→ Section
5.5]
Transaction control [→ Section 10.1]
Transaction model [→ Section 1.2]
Transaction owner [→ Section 5.2]
Transactional behavior [→ Section 3.1]
Transactional key [→ Section 4.1]
Translation [→ Section 7.2]
Trigger → see [trigger condition]

Trigger condition [→ Section 3.13]
combination [→ Section 3.13] [→ Section 3.13]
determination [→ Section 3.13]
field [→ Section 3.13] [→ Section 3.13]
standard operation [→ Section 3.13] [→ Section 3.13]
validation [→ Section 3.13]
Type conversion [→ Section 2.2]
U ⇑
UI annotation [→ Section 1.1] [→ Section 7.2] [→ Section 7.2]
UI service [→ Section 6.3] [→ Section 6.5]
UI.facet [→ Section 7.2]
UI.fieldGroup [→ Section 7.2]
UI.headerInfo [→ Section 7.2]
UI.identification [→ Section 7.2]
UI.lineItem [→ Section 7.2]
UI.selectionField [→ Section 7.2]
Unified Resource Identifier → see [URI]
Uniform Resource Locator [→ Section 1.1]
Uniqueness check [→ Section 3.7]
Unmanaged [→ Section 8.2]
Unmanaged query [→ Section 2.7] [→ Section 8.2]

Unmanaged Save [→ Section 3.3] [→ Section 8.2] [→ Section
10.1]
Unmanaged scenario [→ Section 1.2] [→ Section 1.2]
[→ Section 3.3] [→ Section 3.3] [→ Section 11.1]
update [→ Section 3.10]
URI [→ Section 1.1]
URI option [→ Section 6.4]
URL [→ Section 1.1]
use [→ Section 6.1]
Use case [→ Section 8.1]
User experience [→ Section 1.1]
UUID [→ Section 3.7]
UX [→ Section 1.1]
V ⇑
Validation [→ Section 3.13] [→ Section 5.4] [→ Section 10.4]
creating [→ Section 9.7]
defining [→ Section 7.2] [→ Section 10.4]
implementing [→ Section 10.4] [→ Section 10.5]
notification [→ Section 7.2]
Variant control [→ Section 7.2]
VDM [→ Section 2.1] [→ Section 2.1] [→ Section 2.1]
[→ Section 2.8] [→ Section 2.8]

View stack [→ Section 2.2] [→ Section 2.6]
View-Browser [→ Section 2.8]
Virtual data model [→ Section 2.1] [→ Section 2.1] [→ Section
2.1] [→ Section 2.1] [→ Section 2.1] [→ Section 2.1]
[→ Section 2.8] [→ Section 2.8] [→ Section 2.8] [→ Section
2.8]
Virtual element [→ Section 2.7] [→ Section 6.1] [→ Section
9.2]
Visibility [→ Section 3.16]
Visual Studio Code [→ Section 7.1] [→ Section 7.1]
[→ Section 7.1]
W ⇑
Web API [→ Section 6.3] [→ Section 8.1]
where-used list [→ Section 10.7]
Whitelisted API [→ Section 12.1]
With additional save [→ Section 3.3]
With unmanaged save [→ Section 3.3]
World Wide Web [→ Section 1.1]
Write lock → see [lock]
Write protection [→ Section 3.8]
X ⇑
XCO library [→ Section 12.1]

XML file [→ Section 7.2]
Z ⇑
Z table [→ Section 11.2]

Service Pages
The following sections contain notes on how you can contact us. In
addition, you are provided with further recommendations on the
customization of the screen layout for your e-book.
Praise and Criticism
We hope that you enjoyed reading this book. If it met your
expectations, please do recommend it. If you think there is room for
improvement, please get in touch with the editor of the book:
Hareem Shafi. We welcome every suggestion for improvement but,
of course, also any praise! You can also share your reading
experience via Twitter, Facebook, or email.
Supplements
If there are supplements available (sample code, exercise materials,
lists, and so on), they will be provided in your online library and on
the web catalog page for this book. You can directly navigate to this
page using the following link: https://www.sap-press.com/5647.
Should we learn about typos that alter the meaning or content errors,
we will provide a list with corrections there, too.

Technical Issues
If you experience technical issues with your e-book or e-book
account at SAP PRESS, please feel free to contact our reader
service: support@rheinwerk-publishing.com.
Please note, however, that issues regarding the screen presentation
of the book content are usually not caused by errors in the e-book
document. Because nearly every reading device (computer, tablet,
smartphone, e-book reader) interprets the EPUB or Mobi file format
differently, it is unfortunately impossible to set up the e-book
document in such a way that meets the requirements of all use
cases.
In addition, not all reading devices provide the same text
presentation functions and not all functions work properly. Finally,
you as the user also define with your settings how the book content
is displayed on the screen.
The EPUB format, as currently provided and handled by the device
manufacturers, is actually primarily suitable for the display of mere
text documents, such as novels. Difficulties arise as soon as
technical text contains figures, tables, footnotes, marginal notes, or
programming code. For more information, please refer to the section
Notes on the Screen Presentation and the following section.
Should none of the recommended settings satisfy your layout
requirements, we recommend that you use the PDF version of the
book, which is available for download in your online library.
Recommendations for Screen Presentation
and Navigation

We recommend using a sans-serif font, such as Arial or Seravek,
and a low font size of approx. 30–40% in portrait format and 20–30%
in landscape format. The background shouldn’t be too bright.
Make use of the hyphenation option. If it doesn't work properly,
align the text to the left margin. Otherwise, justify the text.
To perform searches in the e-book, the index of the book will reliably
guide you to the really relevant pages of the book. If the index
doesn't help, you can use the search function of your reading device.
Since it is available as a double-page spread in landscape format,
the table of contents we’ve included probably gives a better
overview of the content and the structure of the book than the
corresponding function of your reading device. To enable you to
easily open the table of contents anytime, it has been included as a
separate entry in the device-generated table of contents.
If you want to zoom in on a figure, tap the respective figure once.
By tapping once again, you return to the previous screen. If you tap
twice (on the iPad), the figure is displayed in the original size and
then has to be zoomed in to the desired size. If you tap once, the
figure is directly zoomed in and displayed with a higher resolution.
For books that contain programming code, please note that the
code lines may be wrapped incorrectly or displayed incompletely as
of a certain font size. In case of doubt, please reduce the font size.
About Us and Our Program
The website https://www.sap-press.com provides detailed and first-
hand information on our current publishing program. Here, you can
also easily order all of our books and e-books. Information on

Rheinwerk Publishing Inc. and additional contact options can also be
found at https://www.sap-press.com.

Legal Notes
This section contains the detailed and legally binding usage
conditions for this e-book.
Copyright Note
This publication is protected by copyright in its entirety. All usage and
exploitation rights are reserved by the author and Rheinwerk
Publishing; in particular the right of reproduction and the right of
distribution, be it in printed or electronic form. 
© 2023 by Rheinwerk Publishing Inc., Boston (MA)
Your Rights as a User
You are entitled to use this e-book for personal purposes only. In
particular, you may print the e-book for personal use or copy it as
long as you store this copy on a device that is solely and personally
used by yourself. You are not entitled to any other usage or
exploitation.
In particular, it is not permitted to forward electronic or printed copies
to third parties. Furthermore, it is not permitted to distribute the e-
book on the internet, in intranets, or in any other way or make it
available to third parties. Any public exhibition, other publication, or
any reproduction of the e-book beyond personal use are expressly

prohibited. The aforementioned does not only apply to the e-book in
its entirety but also to parts thereof (e.g., charts, pictures, tables,
sections of text).
Copyright notes, brands, and other legal reservations as well as the
digital watermark may not be removed from the e-book.
Digital Watermark
This e-book copy contains a digital watermark, a signature that
indicates which person may use this copy.
If you, dear reader, are not this person, you are violating the
copyright. So please refrain from using this e-book and inform us
about this violation. A brief email to info@rheinwerk-publishing.com
is sufficient. Thank you!
Trademarks
The common names, trade names, descriptions of goods, and so on
used in this publication may be trademarks without special
identification and subject to legal regulations as such.
All of the screenshots and graphics reproduced in this book are
subject to copyright © SAP SE, Dietmar-Hopp-Allee 16, 69190
Walldorf, Germany. SAP, ABAP, ASAP, Concur Hipmunk, Duet, Duet
Enterprise, ExpenseIt, SAP ActiveAttention, SAP Adaptive Server
Enterprise, SAP Advantage Database Server, SAP ArchiveLink, SAP
Ariba, SAP Business ByDesign, SAP Business Explorer (SAP BEx),
SAP BusinessObjects, SAP BusinessObjects Explorer, SAP
BusinessObjects Web Intelligence, SAP Business One, SAP

Business Workflow, SAP BW/4HANA, SAP C/4HANA, SAP Concur,
SAP Crystal Reports, SAP EarlyWatch, SAP Fieldglass, SAP Fiori,
SAP Global Trade Services (SAP GTS), SAP GoingLive, SAP
HANA, SAP Jam, SAP Leonardo, SAP Lumira, SAP MaxDB, SAP
NetWeaver, SAP PartnerEdge, SAPPHIRE NOW, SAP
PowerBuilder, SAP PowerDesigner, SAP R/2, SAP R/3, SAP
Replication Server, SAP Roambi, SAP S/4HANA, SAP S/4HANA
Cloud, SAP SQL Anywhere, SAP Strategic Enterprise Management
(SAP SEM), SAP SuccessFactors, SAP Vora, TripIt, and Qualtrics
are registered or unregistered trademarks of SAP SE, Walldorf,
Germany.
Limitation of Liability
Regardless of the care that has been taken in creating texts, figures,
and programs, neither the publisher nor the author, editor, or
translator assume any legal responsibility or any liability for possible
errors and their consequences.

The Document Archive
The Document Archive contains all figures, tables, and footnotes, if
any, for your convenience.

Figure 1.1     Example of an OData Service Metadata
Document

Figure 1.2     Example of an OData Service Document

Figure 1.3     Evolution of ABAP-Based Programming Models
(Source: SAP)

Figure 1.4     ABAP Programming Model for SAP Fiori

Figure 1.5     Technical Context of a RAP Application

Figure 1.6     Components of the RAP Runtime Environment
(Source: SAP)

Figure 1.7     CDS Data Model with “Sales Order” Example

Figure 1.8     Artifacts of the ABAP RESTful Application
Programming Model

Figure 1.9     System Context of ABAP Development Tools

Figure 2.1     Code-to-Data Paradigm

Figure 2.2     Excerpt from Virtual Data Model: API View of
A_SalesOrder in the Dependency Analyzer of ABAP
Development Tools

Figure 2.3     Layers of the ABAP RESTful Application
Programming Model

 
Figure 2.4     Selecting the ABAP Perspective

 
Figure 2.5     Selecting the Type of Development Object to
Create

Figure 2.6     Properties of the CDS View

Figure 2.7     Selecting a Template

 
Figure 2.8     Coding Generated by the Template in the
Source Code-Based Editor

Figure 2.9     Defining the Field List

Figure 2.10     Objects of the CDS Data Model

Figure 2.11     DDLS Transport Object

Figure 2.12     Representation of the CDS View in the ABAP
Dictionary

Figure 2.13     Data Preview in ABAP Development Tools

Figure 2.14     Result Set of the Data Preview

Figure 2.15     SQL Console Within the Data Preview

Figure 2.16     ABAP CDS Language Reference

Figure 2.17     Information About the Selected Code Element

 
Figure 2.18     Popup Window for Parameter Input

Figure 2.19     Data Preview of the Result Set of the
ZI_FlightDetail View

 
Figure 2.20     Tracing Associations

 
Figure 2.21     Selecting an Association

Figure 2.22     Result Set for the _Connection Association

 
Figure 2.23     Association in the Data Preview

 
Figure 2.24     Display of the SQL Statement CREATE in the
Popup Window with the Element Information

 
Figure 2.25     Syntax Warning About Cardinality

Figure 2.26     Display of Active Annotations

Figure 2.27     Templates Available When Creating a CDS
Role

Figure 2.28     Classic PFCG Authorization Role
Z_DMO_CARRIER

Figure 2.29     Selection Result After Querying CDS View
ZI_Flight

Figure 2.30     SQL Statement When Reading Records from
the ZI_Flight View with CDS Role ZI_Flight

 
Figure 2.31     Data Preview for CDS View I_USER

Figure 2.32     Debugger for the WITH PRIVILEGED
ACCESS Statement

Figure 2.33     Append Structure ZZPREMIUM_MARA with
Additional Field

Figure 2.34     Selecting the Extend View Template

 
Figure 2.35     Data Preview for CDS View I_Product with
the ZZPremium Extension Field

Figure 2.36     Example: Material Master CDS Views with
Extension Include View

 
Figure 2.37     Data Preview for CDS View A_Product with
Extension Field ZZPremium

Figure 2.38     Error Message in Case of Invalid Metadata
Extension

 
Figure 2.39     Information Window with Existing Metadata
Extension

Figure 2.40     Active Annotations of the Extended CDS View
ZI_FlightDetail

Figure 2.41     OData Service Call in the SAP Gateway Client

Figure 2.42     Managed Versus Unmanaged Query in the
ABAP RESTful Application Programming Model

Figure 2.43     Preview of the OData Service Output for CDS
Custom Entity ZCUST_ENTITY_DEMO

 
Figure 2.44     Release of CDS Views

Figure 2.45     Hierarchy of CDS Views in the Virtual Data
Model

Figure 2.46     View Browser

Figure 2.47     Business Object Structure (Source: SAP)

Figure 3.1     Artifacts for the Definition of a RAP Business
Object

 
Figure 3.2     Behavior Definition /DMO/I_TRAVEL_D in the
Project Explorer

Figure 3.3     BDL Source Code of Behavior Definition
/DMO/I_Travel_D

 
Figure 3.4     Additional Entity Behavior Definitions of the
Travel Business Object

Figure 3.5     Relationship between Behavior Definition and
CDS Entities

Figure 3.6     Features of the Behavior Definition and
Surrounding Artifacts

 
Figure 3.7     Creating a Behavior Definition with Reference
to the CDS Root Entity

Figure 3.8     Dialog Box for Creating a Behavior Definition

 
Figure 3.9     The New Behavior Definition ZI_TRAVEL_M in
the Project Explorer

 
Figure 3.10     BDL Source Code Editor for the New
Behavior Definition ZI_TRAVEL_M

 
Figure 3.11     Selecting the Behavior Definition via the
Creation Wizard

 
Figure 3.12     Using Auto-Completion in the BDL Editor

 
Figure 3.13     Activation State of the Behavior Definition

 
Figure 3.14     Restricting a Search Run to Behavior
Definitions

 
Figure 3.15     Searching for a Behavior Definition by
Wildcard with Result List

 
Figure 3.16     Creating a KTD for a Behavior Definition

Figure 3.17     Documenting the Create Operation in
Markdown Syntax

 
Figure 3.18     Jump to Documentation in the Behavior
Definition

Figure 3.19     Business Object ZI_TRAVEL_M in the
Relation Explorer

Figure 3.20     Documentation for the Create Operation in the
Relation Explorer

Figure 3.21     Implementation Types of a Behavior Definition

Figure 3.22     Generic Entry in the Global Lock Table for the
Travel Business Object Instance

Figure 3.23     Draft Actions and States in Draft Handling

Figure 5.1     Phases of the Program Flow within the
Business Object Runtime

Figure 5.2     Phases of the RAP Transaction Model

Figure 5.3     Classes of the Business Object Provider API

Figure 5.4     Flow of the FINALIZE Step Within the Save
Sequence

Figure 5.5     Flow of the CHECK_BEFORE_SAVE Step
Within the Save Sequence

Figure 5.6     Flow of the ADJUST_NUMBERS Step Within
the Save Sequence

Figure 5.7     Flow of the Save Process in the Save
Sequence

Figure 5.8     Flow of the Cleanup Operation in The Save
Sequence

Figure 5.9     Flow of the Call of the CLEANUP_FINALIZE
Method

Figure 6.1     Layers of the ABAP RESTful Application
Programming Model from the Database to the Business
Service

Figure 6.2     Service Binding with Two Versions

Figure 6.3     Publishing a Service Binding Locally

Figure 6.4     Service Binding ZUI_TRAVEL_ODATA_O2

Figure 6.5     Example of the Development Objects in the
Layers of the ABAP RESTful Application Programming Model

Figure 6.6     Finding and Starting a Service in the SAP
Gateway Client

Figure 6.7     Service URL in the SAP Gateway Client

Figure 6.8     Displaying Metadata of an OData Service in the
SAP Gateway Client

Figure 6.9     Metadata of an OData Service in the SAP
Gateway Client

Figure 6.10     Preview of a List Report for Service Binding
ZUI_TRAVEL_ODATA_O2

Figure 6.11     Preview of an Object Page for Service Binding
ZUI_TRAVEL_ODATA_O2

Figure 7.1     Tutorials to Get Started with Application
Development on the SAP BTP

Figure 7.2     Creating a New Dev Space

Figure 7.3     Starting a Dev Space

Figure 7.4     Structure of a List Report (Source: SAP)

Figure 7.5     Structure of an Object Page (Source: SAP)

Figure 7.6     List Report for Business Service
ZUI_TRAVEL_ODATA_O2

Figure 7.7     List Report: Filter Bar

Figure 7.8     List Report: Search Field

 
Figure 7.9     List Report: Table Header

Figure 7.10     Object Page for Business Service
ZUI_TRAVEL_ODATA_O2

 
Figure 7.11     Object Page: Sections

Figure 7.12     Object Page: Section with Individual Fields

Figure 7.13     Object Page: Section with Table

 
Figure 7.14     Object Page: Edit Button

Figure 7.15     Object Page in Edit Mode

Figure 7.16     Search Help for the Agency ID Field

 
Figure 7.17     Calendar Search Help for Date Fields

Figure 7.18     Object Page: Subsequent Screen with More
Details

Figure 7.19     Object Page: Subsequent Screen in Update
Mode

Figure 7.20     OData Service with Function Import

 
Figure 7.21     List Report: Buttons for Actions

Figure 7.22     Error Message After a Validation

Figure 7.23     Type W Message

 
Figure 7.24     Type I or S Message

Figure 7.25     Creating a Project Based on a Template

Figure 7.26     Selecting the SAP Fiori Application Template

Figure 7.27     Selecting a Template for a List Report

Figure 7.28     Selecting a Business Service as a Data
Source

Figure 7.29     Selecting Entities for Use in the List Report

Figure 7.30     Defining Project Properties

Figure 7.31     Opening the Service Modeler via the Context
Menu

Figure 7.32     Entity Overview for the List Report in the
Service Modeler

Figure 7.33     Displaying an Overview of UI Annotations

Figure 7.34     Detail View of Annotations

Figure 7.35     Customizing Local Annotations

Figure 7.36     Overview of Annotations for the Object Page
in the Service Modeler

Figure 9.1     Creating a New ABAP Package in ABAP
Development Tools

Figure 9.2     Creating a New CDS Entity

Figure 9.3     Maintaining the Data Definition of the CDS
Entity

Figure 9.4     Selecting the Define View Entity Template

Figure 9.5     Interim Status of the Data Model

Figure 9.6     Creating a Data Definition for a CDS Projection
View

Figure 9.7     Selecting the Define Projection View Template

Figure 9.8     Creating a New Behavior Definition

Figure 9.9     Creating a Behavior Definition with the
Managed Implementation Type

Figure 9.10     Generated Source Code of the Behavior
Definition

Figure 9.11     Enabling Draft Handling

Figure 9.12     Creating a Draft Table

Figure 9.13     Creating a New Service Definition

Figure 9.14     Assigning a Name and Description to the
Service Definition

Figure 9.15     Selecting the Define Service Template

Figure 9.16     Creating a New Service Binding

Figure 9.17     Creating the Service Binding

Figure 9.18     Publishing the Service Binding

Figure 9.19     Launching the SAP Fiori Elements Preview via
the Service Binding

Figure 9.20     Creating a Metadata Extension for the User
Interface

Figure 9.21     Maintaining a Name and Description for the
Metadata Extension

Figure 9.22     Selecting the Annotate View Template

Figure 9.23     Preview of the List Report

Figure 9.24     Preview of the Object Page

Figure 9.25     Behavior Definition for an Entity

Figure 9.26     Creating the Implementation Class for the
Behavior Implementation

Figure 9.27     Creating a New Message Class

Figure 9.28     Selecting the Message Class Template

 
Figure 9.29     Creating the Messages

 
Figure 9.30     Starting Application Generator in Visual
Studio Code

Figure 9.31     Selecting the List Report Object Page
Floorplan

Figure 9.32     Selecting a Data Source

Figure 9.33     Selecting the Entities

Figure 9.34     Maintaining Other Features of the Project

Figure 9.35     Deployment Configuration

 
Figure 9.36     Storing Login Data in the .env File

Figure 9.37     Maintaining Credentials in the ui5-deploy.yaml
File

Figure 9.38     Opening the Terminal to Perform the
Deployment

Figure 9.39     Selecting the npm Task

Figure 9.40     Selecting the Deployment Task

Figure 9.41     Running the Deployment

Figure 9.42     BSP Application for the SAP Fiori App after
Deployment

Figure 10.1     List Report for Fast Entry of Purchase Orders

Figure 10.2     BAPI Call in the Save Sequence

Figure 10.3     Logical Data Model of the Application

Figure 10.4     CDS Data Model of the Application

 
Figure 10.5     Creating the ZI_RAP_PO_Material CDS View

 
Figure 10.6     Result Set for the
ZP_RAP_PurchaseOrderItemCount View in Data Preview

Figure 10.7     Creating the Behavior Pool via the Quick Fix
Function

Figure 10.8     Creating the Behavior Pool with the Save
Handler

Figure 10.9     Signature of the SAVE_MODIFIED Method

Figure 10.10     Creating a CDS Projection View

Figure 10.11     Published Service Binding for the Purchase
Order Entity Set

 
Figure 10.12     Result of Searching for a CDS Access
Control for the I_PurchaseOrderAPI01 CDS Entity

Figure 11.1     List View in the MySalesOrder Application

Figure 11.2     Detailed View of the MySalesOrder Application

Figure 11.3     Message Class ZVB_MESSAGES

Figure 11.4     Lock Object EZ_ZVBAK

Figure 11.5     Creating Basic Interface View
ZI_MySalesOrder

Figure 11.6     Creating the Interface View
ZC_MySalesOrder

Figure 11.7     Creating the Metadata Extension
ZC_MySalesOrder

Figure 11.8     Creating the Behavior Definition for CDS Entity
ZI_MySalesOrder

Figure 11.9     Creating an Implementation Class (Behavior
Pool)

 
Figure 11.10     Viewing Implementation Class
ZBP_I_MYSALESORDER

Figure 11.11     Phases and Times Within the Business
Object Runtime

 
Figure 11.12     The Local Classes in the Source Code Editor

 
Figure 11.13     Implementing the Read Method

Figure 11.14     Debugging of the Read Method

Figure 11.15     Control Structure %CONTROL

 
Figure 11.16     CLEANUP Method in the Saver Class

Figure 11.17     Creating Service Definition
ZUI_MYSALESORDER

Figure 11.18     Activating the Service Binding

Figure 11.19     Testing the UI Service via the Preview
Function

Figure 11.20     Error Message When Entering a Negative
Net Value

Figure 12.1     System Context of the SAP BTP, ABAP
Environment

Figure 12.2     Syntax Error When Using Unreleased
Repository Objects

Figure 12.3     SAP Fiori App for Managing Number Range
Intervals

Figure 12.4     Connection Between RAP Application,
Authorization Objects, and IAM

Figure 12.5     IAM Development Objects with Business Role
and Business User

Figure 12.6     Creating an IAM App for an SAP Fiori App

Figure 12.7     Integrating a Gateway Service in the IAM App

 
Figure 12.8     IAM Business Catalog with Associated IAM
App

Figure 12.9     IAM Business Role with Associated IAM
Business Catalog

Figure 12.10     Relationship between the IAM Development
Objects and the Launchpad Spaces and Pages

 
Figure 12.11     Display of the Launchpad Space Travel-
Administration at Runtime

Figure 12.12     IAM Business Role with a New Launchpad
Space

Figure 12.13     Adding an IAM App as a Tile to a Launchpad
Page

Figure 12.14     HTTP Destination in SAP Destination Service

 
Figure 12.15     Creating a Communication Arrangement
with Reference to a Communication Scenario

Figure 12.16     Service Consumption Model for Test Data
Service Northwind in OData Version V4

Figure 13.1     Dimensions of the ABAP RESTful Application
Programming Model

 

 

 

