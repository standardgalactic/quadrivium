Basic Circuits 
ot Digital 
Electronics
English Translation of the German Kit Booklet
BURKHARD KAINKA
aBrasasjaKam; 
?-el ktromk
FRANZIS 
• KNOW HOW
MMMM lernpaket 
EMMMI
Basics, Simulation, Test - 34 Components • 100 Page Booklet — 22 
Basic Digital Circuits - 72 Experiments, needs some basic soldering

Franzis Lerning Package
Basic Circuits of Digital Electronics
Or in short: JPTS
Jumper Programmable Test System
English Booklet for the German Kit 
Burkhard Kainka - Juergen Pintaske
KNOW-HOW

Basics, Simulation, Test - 34 Components -100 Page Booklet - 22 Basic Digital Circuits - 72 Experiments
https://www.amazon.de/Franzis-Lernpaket-Grundschaltungen-digitalen-Elektronik/dp/B0CDZJ2YPQ
https://www.elektronik-labor.de/Lernpakete/DigiSchaltungen.html

Copyright information:
This book is Copyright ExMark, Juergen Pintaske
No contents or part of it may be copied or published elsewhere without the author’s permission.
November 2023
Important Note:
Part of this kit are LEDs which emit light.
Please do not look into the LEDs too closely.

Introduction - Juergen Pintaske
This booklet is describing an unusual package and approach. When I saw this Franzis kit on Burkhard Kainka's website, 
I was surprised how simple such a kit could be.
I asked Burkhard and Franzis, if I can translate and publish the documentation into English, so an additional readership 
worldwide can take advantage and learn using this kit for the non-German community, which was granted.
The German title was too general for me, and I wanted a name that described the functionality. Everything is defined 
via the jumpers, which you could compare with the routing of a Programmable Array. So the name was clear:
JPTS = JUMPER PROGRAMMABLE TEST SYSTEM.
The original kit will come with the German booklet, and this book here is a direct translation, but I added some 
information, which seemed to be helpful while I worked through it during the translation and testing process.
The board is pre-soldered with SMD components, but a few parts have to be soldered in by you. If you have no 
experience, ask around your neighbours who can help. After this first setup, no further soldering is required.
The examples are set up using the jumpers.
Please be careful that you mount the 2 headers on the top side where the writing is, and the other parts the right way 
around as in the description.
Especially, screwing the red and black power cable in -
where black is to the side where the plated through hole is, and red on the side where the 3 pin voltage regulator is.
You will probably buy this kit online, if you want to start learning. I would recommend, that you add a low-cost 
Multimeter to your online order if you do not own one already.

I went actually for a set of 4 units at about $5 each, so I can do a lot of measuring, for example voltage and current at the 
same time, or the potential at 4 different positions to GND in the circuit.
You can use the extra wires in the kit to access these different points and connect them to your multimeter(s).
If you are not so experienced, just set it to about 20 V DC and measure voltages only, and nothing should go wrong.
I really love this idea to have a board with all of the required components fixed to it. You cannot lose them as you can 
with the usual beadboard and components setup.
And the functionality is defined by just placing the jumpers.
My kit had 15 jumpers, but the maximum you need is less as I have counted. Plus the 6 wires you use to connect pins 
that are too far out for a juniper.
And one additional hint: These books do not like to stay open easily when on your desk. I always cut them apart and 
reconnect the pages using a plastic binder; works a lot better.
Enjoy the booklet, and please send your feedback about the kit to amazon for the help of others who want to learn about 
electronics.
I tried to lay out this book roughly in the same way as the original, so you can more easily compare both of them.
In some pictures, the jumpers seem not to be connected well, but this is on purpose;
it just means they are used as switches. As described later.
Dipl.-Ing. Juergen Pintaske, ExMark, November 2023

Foreword
Electronics can be learned like arithmetic, writing and reading: you just need the opportunity to deal with them in 
detail.
The easiest way to do this is by using a small electronics kit. The components in this kit here are all soldered onto 
a circuit board and cannot be lost; only the interconnects have to be plugged in - and you have a finished circuit, a 
functioning system.
The circuit board has two rows of pin headers, each with 2x 10 contact pins. Small contact bridges are pushed onto 
these pins where needed, and can be easily removed later. They are also called "jumpers" because they can "jump" back 
and forth quickly and easily to different positions. After a few examples you will understand the setup and can quickly 
set up the next circuit. This is much quicker than using a soldering iron or a breadboard. And the components cannot 
be lost. Only a small supply of jumpers must always be within reach.
The components are arranged in such a way, that more than 50 meaningful experiments can be set up using the 
jumpers alone. And you can probably find a lot more.
The most important components used during the experiments: 10 light emitting diodes (LEDs), 1 resistor, 1 capacitor, 
2 push buttons and a potentiometer.
Anyone who knows these components and has understood them, can also implement own ideas and develop new 
circuits. The construction is much faster than with other systems. And the most important thing is that you never have 
to search for the components.
The manual always uses the same circuit diagram and assembly diagrams with all required jumper connections. If you 
want to build something very quickly, you just stick to the construction pictures, this will give you the fastest success. 
Mistakes are almost impossible.

There are a few additional circuit diagrams at the end that you can copy or cut out.
Good luck and have fun with experimenting!
Burkhard Kainka
Further experiments, information on possible problems and experiences of other readers, as well as frequently asked 
questions and answers and additions regarding this experimentation package will be added as they come up on my 
homepage: 
www.b-kainka.de

Contents
Introduction
3
Foreword
6
Contents
8
List of Components
9
1
Preparations and Assembly
10
1.1
Components
11
1.2
Some Soldering Work
13
1.3
Overview
16
2
NOT Gates (Inverters)
21
3
AND and NAND
26
4
OR and NOR
30
5
XNOR and XOR
34
6
Analog-Digital Converter
38
7
Analog Level Display
43
8
10-Bit Binary Counter
48
9
Running Light
52
10
The RS Flip-Flop
55

Version A5_v9
11
The D Flip-Flop
57
12
The JK Flip-Flop
61
13
The Shift Register
64
14
A 4 x 4 Bit RAM.
68
15
PWM - Pulse Width Modulation
72
16
A Frequency Counter
75
17
Serial Interface
78
18
Serial Interface Part 2
83
Additions to the original Booklet
93

List of Components:
PCB 80 mm x 50 mm, with SMD Components:
Nuvoton MS51FB9AE, TSSOP20 Processor with 
pre-programmed Software
10 x LED green 0805
HT7550 SOT89, Voltage Regulator 5V
3x100 nF 0805
4,7 Mohm 0805
100 Ohm 0805
Wired Components - still to be soldered in by you:
2x push buttons
lx potentiometer 10 k, 10mmx5mm with axel
2 x male pin header 2x10 _2xl0_G_2,54
lx connection terminal 2 pin, Raster 5,08 mm for power
4x rubber feet
Additionally:
Battery clip 9 V
15 Junipers, long
6 connection cables female-female
The 9 Volt battery is not included


1 - Preparation and Assembly
The knowledge of basic digital functions is one of the fundamentals of electronics and computer technology. Practical 
experiments are more effective than dry theory.
That's why a system is used here, where you can use the most important basic circuits for your own experiments.
To ensure that the system remains as compact and handy as possible, the usual TTL or CMOS digital components are 
not used.
Instead, all digital circuit functions are generated via a microcontroller and its software.
Before starting to experiment, some additional parts of the the circuit board have first to be assembled. You need a 
soldering iron and some solder.
This construction work helps to understand exactly how the parts of the system are connected.

1.1 - Components
The kit contains a board with SMD components with the microcontroller and all LEDs, resistors and capacitors. Some 
simple additional parts still need to be soldered in.
These are the two connector strips with 2 x 10 contacts, two pushbutton switches, 
a potentiometer
and a 2 pin screw terminal for the battery cable.
The jumpers are only needed for the actual experiments.
NOT AND OR XOR ADC Level Binary Run
RS D JK Shift RAM PWM Count Serial

Figure. 1.1: The pre-populated circuit board
Additionally, there are also 6 jumper cables with sockets at both ends that can be separated into individual cables. 
These will be used to establish connections between more distant contacts; basically as a flexible jumper.
Figure 1.2: Additional components

1.2 - Soldering
Before you really get started, you have to solder. It's best to start with the two connector strips, each with 2 x 10 
contacts. When you insert them into the circuit board, everything can then be turned over and placed on a flat surface 
so that the contacts sit straight. It's best to solder just one pin first and then check the correct fit again. If necessary, you 
can heat this soldering point again and make some corrections. Then all contacts can be soldered one after the other.

Figure 1.3: Added 2x10 connectors
This is also a good soldering exercise if you haven't done it that often before. Every soldering point has to get really hot, 
so that the solder flows deep into the hole and completely covers the contact pin.
But you shouldn't solder for too long so that the last bit of flux does evaporate. A good solder joint can be recognized by 
the fact that the solder hugs the metal and forms a smooth surface. If necessary, you can easily re-solder the soldering 
points with some fresh solder.
Next follow the two pushbutton switches SI and S2, then the potentiometer (Poti for short) and at the end the 2 pin 
screw terminal for the battery connection.
When all parts are soldered in, the 4 small rubber feet are inserted into the appropriate holes from below. The board is 
therefore secure and cannot scratch the table.

Figure 1.4: The board ready for the experiments
The battery clip is connected to the screw terminal. The red cable is the positive pole, the black is the negative pole. It 
has proven to be a good idea to bend the stripped and tinned cable end backwards and then screw the cable end together 
with the insulation into the terminal.
This creates a long-lasting connection and avoids cable breakage, which could otherwise occur if the battery cable is 
bent too frequently.

1.3 - Overview
In the middle of the board you can see the MS51FB9AE microcontroller, a modern 8051-compatible flash controller. 
It contains here many different programs which are used to create digital gates and other digital circuits, thereby 
replacing a large number of different digital components.
Instead of using different ICs, you just have to select the right programs on this one IC.
Jumper positions A to D are used for this purpose.
Jumper U switches on the operating voltage.
There is a HT755O 5V voltage regulator on the board to stabilize the operating voltage of the 9V battery.
The controller therefore works with a stable 5 V supply voltage.
On the right hand side of the circuit diagram, there are ten SMD LEDs and the associated connections of the digital 
circuits formed by the controller.
Each IO port of the microcontroller can be an input or output, and the current status is always indicated by the 
associated LED.
This gives you ten inputs or outputs, which form the connections for the gates, flip-flops or other digital components 
in our experiments.

S2

P05
P06
P07
RST
P30
P17
GND
P16
VDD
P15

Figure. 1.5: The circuit diagram of our system
The fact that each pin can be both - an input and an output - is made possible by the special properties of this 8051 
controller. The quasi-bidirectional ports use a pull-up current of approximately 50 pA, which allows the LEDs to shine 
sufficiently brightly.
You can short-circuit each connection to ground, thereby creating a logical state 0. The controller can also actively pull 
down each pin with its open-drain output, while a high-impedance 1 state is generated by the internal pull-up resistor.

!00n
0 *—
1 
♦—
2 
•—
3 —
4 
•—
5 
♦—
6 
•■
7 
•—
8 —
9 
•-----

As a larger circuit diagram - to copy out

All inputs are TTL compatible and have a switching threshold close to 1 V.
The 1 state of each output is limited to approx. 2 V limited by the associated LED.
The user can connect any pin, whether input or output, to GND with a jumper. The connections are therefore extremely 
fault-tolerant.
Only the connection of external voltages should be avoided.
The 8051-compatible quasi-bidirectional ports are high impedance in the 1 state. To ensure that steep switching edges 
are still achieved, the port is pulled up with a larger current for two clock cycles, i.e. for 0.5 p.s at the working frequency 
of 4 MHz, with every 0-1 change.
This normally remains invisible due to its short duration.
However, if level changes occur at a very high frequency in certain situations, the average output current increases 
noticeably, which can be seen as greater LED brightness.
The inputs on terminals A to D are also pulled high in idle state and can be set to 0 state by setting a jumper.
This means that a total of 16 different states can be set, which allows for 16 different basic programs to be selected.
The SI button is connected to the reset input of the controller.
To start a selected program you must therefore briefly press S1.
Alternatively, you can switch the operating voltage off and on again.
The S2 button is permanently connected to P06 and has different functions depending on the program selected.
In many programs there is a clock and square wave signals on digital connection 9.
Button S2 is then used to stop this clock.

If you hold down S2 during a reboot or a reset, it gets a different function in some programs. The state of the switch 
then appears at pin 9 instead of the clock signal.
This means that a status can be influenced during operation by using the switch.
The idle state is 1, when the button is pressed the state 0 appears.
The potentiometer on the board has different functions. In many cases, you can use this to determine the operating 
speed of the digital circuits, so that response times or gate running times can be directly observed.
In addition, a clock signal that is ten times slower than the operating frequency is often supplied.
In other cases, the potentiometer provides an adjustable voltage for an AD converter or other circuits.
There is also a resistor and a capacitor that can be connected to specific positions using jumpers. For example, you can 
use them to build an oscillator.

2 - The NOT Gate (Inverter)
Jumper positions A to D are used for program selection. Without a jumper connection in these positions, program 0 is 
started. The counting starts with 0 because the four unplugged jumpers represent the binary number 0000.
The program started in this way forms five identical inverters generated by the 8051, which are also called NOT gates 
(INVERTER).
In addition, a clock signal (Clock, Clk) is generated at pin 9.
S1 Reset
S2

Figure 2.1: Program 0, the Inverter
Logic Function:
INVERTER NOT GATE
Input A
OUTPUT
0
1
1
0
To switch the board on, you set jumper U - basically the Power Switch.
In addition, jumper I should also be plugged on. It establishes the connection to the potentiometer, so the working 
speed of the clock can be adjusted.

1
1
1
1
1
Figure 2.2: Basic status of all 5 Inverters
For now, all jumper locations at positions 0 to 9 remain unconnected. You can see, that LEDs 9 and 8 flash in push-pull 
mode showing the NOT function of inverting the input signal at the output;
and you can use the potentiometer to set the desired speed.
Input 9 of the first NOT gate is controlled with the square wave signal. The opposite signal always appears at output 8, 
i.e. 1 when the input is 0 and 0 when the input is 1.
For all other inverters, the input is still in state 1 and the output is inverted, i.e. in state 0. The function of each inverter 
can be easily checked by short-circuiting the input with a jumper to GND as shown on pin 5.

1
1
1
1
1
Clk
9876543210
Figure 2.3: Using the different Inverters
A whole series of simple experiments gives an impression of how an inverter works. Each of inputs 7, 5, 3 and 1 can be 
shortened to GND with a jumper as shown at pin 5. And then the associated output changes to the 1 state.
The output signal of an Inverter can be passed directly to another input, as shown with connection 8-7. The signal is 
then inverted again. In this case, a symmetrical flashing pattern is created on four LEDs.
If you connect an input directly to the output of the same inverter as with connection 0-1, fast oscillations occur.
However, the working speed can be reduced by turning the potentiometer to the left so that a slower flashing becomes 
visible. It is ten times faster than the clock signal on pin 9.
Real CMOS ICs such as the 6x inverter CD4049 usually behave similarly, but then generate much higher frequencies of 
a few MHz, because the delay time of the input status from input to output is significantly less than a microsecond.

These oscillations occur, because the gate reacts with a delay. The inverted signal reaches the input after a short 
time and thus leads to the next change. For the inverters formed by the controller, the reaction was slowed down 
significantly, so that the process can be observed directly.
The same test on the left inverter with a connection 9-8 shows a flashing that is switched off after every five cycles for 
another five cycles. This is due to the ten times slower clock signal being supplied at the same time.
In addition, you can stop the current state of all of the software-generated NOT gates at any time by pressing S2.
Clk
Figure 2.4: Signal chain using the 5 Inverters
Now, all five inverters should be connected in series by adding 4 jumpers. A flashing pattern is created, where five light 
bars, each made up of two LEDs, dance repeatedly to the left and to the right. You can see a clear delay due to the gate 
running times, which here are one tenth of the clock period set with the potentiometer at input 9.
At higher speeds, only a flicker is visible, and at the highest speed, all LEDs appear to glow uniformly.

Instead of the automatic clock signal, you can set your own clock by using the S2 button. To do this, hold down S2 while 
a restart is carried out by briefly pressing S1.
From then on:
S2 pressed, pin 9 shows 0;
S2 released, pin 9 shows 1.
There is still a gate running time, which is set via the potentiometer. In the slowest setting, significantly delayed 
reactions to pressing S2 are noticeable.
Clk
6 
5 
4
2
0
Figure 2.5: A Ring Oscillator
An additional cable connection from the output at pin 0 to the input at pin 9 creates feedback. This is how you form a 
ring oscillator, i.e. an oscillator that is made up of a closed ring of several inverters. The state changes run from left to 
right through all stages at the speed of the set gate running time.

The prerequisite for these oscillations is that an odd number of inverters is used, so that the output signal appears 
inverted to the original input signal.
So it works with one, three or five inverters.
For the ring oscillator to remain undisturbed, the clock signal must be switched offby holding down S2 during startup.

3 -AND and NAND
Using program selection jumper A and a restart or a reset through SI, you get to program 1: AND and NAND. 
An AND gate has at least two inputs and one output. Only if input 1 AND input 2 are on, the output is also on. 
A NAND gate works like an AND gate with an added inverter.
Logic Functions:
AND GATE
Input A
Input B
OUTPUT
0
0
0
0
1
0
1
0
0
1
1
1
NAND GATE
Input A
Input B
OUTPUT
0
0
1
0
1
1
1
0
1

1
1
0
Figure 3.1: Program 1, AND and NAND

Clk
111 
110 
110
98765432
1
0
Figure 3.2 : The gates in basic state - 1 AND and 2 NAND gates
The AND gate on the left has two 1 states at inputs 8 and 7 without additional jumpers and therefore also a 1 state at 
the output.
You can connect one or both inputs to GND, then the output turns off.
In the two NAND gates - in the middle and on the right - the inputs are high in the idle state and the outputs are 
therefore low.
Outputs at 3 and 0 go high when one or both of the associated inputs are connected to GND.

987654321 
0
Figure 3.3 : Using a NAND Gate as Inverter
A NAND gate can also be used as an inverter by keeping the second input in the 1 state. The experiment switches all 
three gates one after the other via the clock signal. You can see the inverted signal at 3 and the back-inverted signal at 0. 
If you connect 7 to GND, the signal flow is interrupted, as one of the AND gate inputs is at 0.
By feeding back a signal from the output to the input of the AND gate, a flip-flop is built.
The following experiment shows this using the AND gate. The output state is initially 1 because the open input is 1 and 
the output maintains the required input state at the second input.
But if you briefly connect pin 8 to GND, the circuit switches to the 0 state. The only way back is to reboot or reset.
Such a circuit could be used for example in a fire alarm. Anyone can trigger the alarm, but only the fire department has 
the means to switch it off again.

987654321 
0
Figure 3.4 : 2 different types of Flip Flops
The circuit behaves differently when using the two NAND gates. Here too, there is feedback to the input and two stable 
states.
Here, a connection cable must be used for this. After starting, output 0 is in state 1. However, it can be reset to 0 with a 
short 0 pulse at input 4 (reset). But this time there is also a path to the opposite state.
If you briefly switch pin 1 to GND, output 0 is switched on again (set). This circuit is also called an RS flip-flop. It can be 
formed using two gates, but is also available as an integrated circuit.

4- OR and NOR
An OR gate delivers 1 at the output if one or both of the inputs are 1. A 0 state only appears when both inputs are 0. 
For example, an OR circuit could control a fire alarm with two separate alarm buttons. All you have to do is press one of 
the two buttons to trigger an alarm. There are also OR gates with more than two inputs. Or you can connect several OR 
gates with additional OR gates to form a gate with many inputs. Program 2 creates one OR gate and two NOR gates.
Logic Functions:
OR GATE
Input A
Input B
OUTPUT
0
0
0
0
1
1
1
0
1
1
1
1
NOR GATE
Input A
Input B
OUTPUT
0
0
1
0
1
0

Figure 4.1: Program 2, OR and NOR

The NOR gate is an OR gate with an added inverter. The output then goes to 0, if at least one of the inputs is 1. To switch 
the output on, both inputs must be set to 0. The NOR gate has more possible applications than the OR gate - therefore 
two NOR gates are formed. There is again a clock signal with an adjustable frequency at pin 9. Jumper I must be inserted 
to connect to the potentiometer.
Clk
Figure 4.2: Starting state
0
0
In our first example, the OR gate is used to pass the clock at its output 8. To do this, however, the second input must be 
connected to GND with jumper 7.
If you remove this jumper, output 6 remains in the 1 state. The same applies to the middle NOR gate. The clock is only 
passed on if input 4's jumper is connected to GND.
At the same time, the NOR gate then works as an inverter. LED 3 therefore flashes in push-pull mode.

987654321 
0
Figure 4.3: Signal processing and feedback
The last NOR gate receives feedback from the output to one of the inputs via jumpers 1-0. This then leads to square 
wave oscillations if the other input is currently 0.
Here the familiar five rapid oscillations arise again, which are followed by an off-period of equal length.

987654321 
0
Figure 4.4: Structure of a flip-flop
In our last experiment here, a static RS flip-flop is formed using two NOR gates. The last state is held as long as jumpers 
4 and 1 keep their inputs in the 0 state.
To switch the state, you have to briefly pull out one of them.

5 -XNOR and XOR
An XOR gate (exclusive-or) compares the state of both inputs. Only if they are not the same, the output will change to 
high; if they are equal it goes to the 0 state.
The XNOR gate works the other way around. Only if the input states are the same does the output go to the 1 state.
Program 3 forms two XOR gates and one XNOR gate.
Logic Functions:
XNOR GATE
Input A
Input B
OUTPUT
0
0
1
0
1
0
1
0
0
1
1
1
XOR GATE
Input A
Input B
OUTPUT
0
0
0

0
1
1
1
0
1
1
1
0
u
B
H
XNOR XOR
Figure 5.1: Program 3, XOR and XNOR

=1
Clk
0
Figure 5.2: Starting state

10 
111
4 
3 
2 
1 
0

987654321 
0
Figure 5.3: Switchable Inverter
The XOR gate can pass on an input state either inverted or unchanged. In our the first attempt, a clock signal is passed 
across all gates, and the jumpers on inputs 7,4, and 1 determine which stage inverts the signal.
These jumpers can be used to achieve very different flashing patterns.

Abb. 5.4: Random generator
In the second test, S2 is connected to pin 9 and by holding this S2 pressed during startup. The two left gates are 
connected via feedback to form a flip-flop.
However, the state of input 8 determines whether there is a feedback function or a negative feedback.
With negative feedback (S2 pressed), rapidly changing states arise due to the adjustable signal delay.
However, when this button is left open, there is feedback where the last state is retained like with a flip-flop.
If you set a sufficiently high working speed with the potentiometer, the circuit acts like a random generator. Rapid 
level changes occur with every key press. If you let go of the button, a random state remains. If you only look at the 
connected LEDs 6 and 5, you sometimes get a 1 and sometimes a 0.
Only a few of the many possible circuits with gates were presented here. It can be an interesting challenge to develop 
your own circuits and then the appropriate applications to use them.

A possible learning game for the four types of gates presented here, requires two players.
One starts one of the programs 0 to 3 and then pulls out the program jumpers while the program is running.
The second player now tries to find out what type of gate it is and which gate is connected where, by putting jumpers 
on the inputs and outputs.
Anyone who solves these tasks without errors has understood the four basic types of digital gates.

6 - Analog to Digital Converter
An analog-to-digital converter (AD converter, ADC) is a circuit for converting analog electrical voltages into digital 
values.
The analog voltage at the input is returned as a numerical value, in this case here, an 8 bit number represented by the 
eight LEDs 2 to 9.
Program 4 is selected with a jumper on pin C.
The measuring voltage should be adjusted with the potentiometer and is connected to E and I.
ADC
9
8
6
5
3
2
1
0
S1 Reset
S2

Figure 6.1: Program 4, AD converter
Using the potentiometer, you can set any voltage between OV and 5V. When fully left, the eight left LEDs show the 
binary number 0000 0000, which stands for 0 V. When turned to the right, the highest number 1111 1111 is displayed. 
This covers all 256 possible binary numbers from 0000 0000 to 1111 1111.
This corresponds to the decimal number 255 and stands for 5.0 V. Any voltage between these two end points can be 
measured, displayed in binary and converted by you to decimal to the corresponding voltage. As an example: 0001 
0000 stands for decimal 16 and means 5V/255 * 16 = 0.31V.
Each of the 255 steps is 5V / 255 = about 0.02 V.
In some settings, individual LEDs become noticeably bright. This happens when the set voltage is between two possible 
levels of digitization, so that the result quickly fluctuates back and forth between these two numbers. Such uncertainty 
is the result of fluctuations in the last bit and is typical for all AD converters.

Figure 6.2: Connections of the AD converter
This program additionally creates two gates - each with a digital input, in order to examine them more closely.
The related output states are visible on LEDs 0 and 1.

The left gate at input E is an inverter with an additional Schmitt trigger functionality, i.e. with different switching 
voltages when the gate is switching on and switching off.
The right gate is a non-inverting buffer with the same properties as the remaining ports with connected LEDs.
By slowly adjusting the potentiometer, you can examine the voltages at which the two gates with their inputs at E and 
I change state.
For the right gate (Buffer) with its output at LED 0, an input threshold of 0100 0100 (decimal 68) was measured. This 
corresponds to a voltage of 1.3 V. Above this voltage, the input state is considered 1, below it is considered 0.
This switching threshold is TTL-compatible and is therefore significantly below half the operating voltage and also 
below the forward voltage of the directly connected LEDs.
In contrast, with a standard CMOS gate you would find a threshold voltage close to half of the operating voltage.
The left gate with its Schmitt trigger input behaves completely differently. The switch-on point of the input (LED 1 just 
goes off) is significantly higher than the switch-off point, when the LED just turns on again.
The lower switching point was found at 0110 0110 (decimal 102) and is therefore at 2.0 V. The upper switching point 
was 1001 0101 (decimal 149) and is at 2.9 V.
There is a hysteresis of 0.9 V between the two switching points . The last detected state is retained in this hysteresis 
area.
These measurement results are subject to certain variations, so that slightly different values can be measured with 
each controller system. Normally one avoids the proximity of these switching points because the result is then not 
certain.

In addition, oscillations can occur near the switching points, which are noticeable through greater brightness of 
individual LEDs.
Figure 6.3: An RC signal generator

Schmitt trigger inverters are often used to build RC oscillators. For a simple experiment, jumpers F and G must be set.
The 4.7 resistor charges the capacitor of 100 nF to the upper switching threshold. Then the output switches to 0 V, 
so that the capacitor at the input is then discharged to the lower switching point.
This then starts a new charging process. The end result is that LED 1 is flashing. You can turn the potentiometer all the 
way to the left so that the other LEDs remain off.
In an extended oscillator experiment, the capacitor at the input should now be removed. All you have to do is remove 
jumper F.
The LED 1 now seems to glow permanently and is noticeably bright. This is a sign of high frequency oscillations.
As only a very small stray capacitance is now at the input, it is only charged with very few picofarads, and the charging 
times are very short.
However, touching the open terminal F with your finger or a cable in your hand, will result in a larger connected 
capacitance, a lower frequency and less brightness of the LED.
This is how a capacitive touch sensor works.

7 - Analog Level Display
With program 5, the AD converter works like a light strip display made up of ten LEDs, similar to a level display in an 
audio amplifier. This type of display is intuitive and easy to read.
The disadvantage, however, is the low resolution with only ten levels. This time the input of the AD converter is on pin 
E. A jumper establishes the connection to the potentiometer, which can now be used to set any voltage between 0 V and 
5 V.
Level

Figure 7.1 : Program 5, level display
This time, the AD converter uses an analog input at connection E. For the output there is a decoder in the form of 
several comparators that determine which LED should light up at which voltage.
You can realize different divisions. For a level display, often logarithmic steps are preferred like used for volume in 
amplifiers. Here, however, the measuring range was divided into ten equal areas, resulting in a linear display.
Each LED represents 0.5V.
UABCDEFGH
ADC 10

Figure 7.2 : Potentiometer voltage level display
The connection to the potentiometer is established via jumper E. The voltage is visible in the LED band display. When 
you turn the potentiometer all the way to the left, all the LEDs are off; when you turn it to the right, more and more 
LEDs turn on, so the LED strip becomes longer.
The Schmitt trigger gate comparator is also available again, so that the well-known oscillator can be set up. The AD 
input is then located at the input of the inverter and therefore at the charging capacitor. This gives you the opportunity 
to directly observe the charging and discharging processes.
4,7M
987654321
0

Figure 7.3 : Display of the capacitor voltage level
You can now see in this band display, that the voltage is approximately in the middle range and fluctuates in time with 
the oscillator.
However, the resolution is not sufficient to see anything more precise. But if you press button S2, the output of the 
inverter is short-circuited at pin H.
You can then see how the capacitor completely discharges relatively slowly across the 4.7 MQ resistor.
However, program 5 additionally contains a narrower measuring range that better represents the oscillations at the 
capacitor. To do this, jumper I must be plugged in and the potentiometer must be on the far left.
This turns on the higher sensitivity of the AD converter, which results in a better display, where the display bar moves 
back and forth a total of four positions, showing the triangular oscillations at the capacitor.
Another experiment can show how the capacitor discharges over the entire range starting from 5V. To do this, the 
capacitor alone is connected using jumper F. The display then usually levels off at the first step.
To charge the capacitor, jumper E is placed while the pot is turned all the way to the right.
As soon as jumper E is removed, the capacitor is left to its own devices and discharges relatively slowly via the AD 
converter.
This slow discharge is an indication of the extremely high input impedance of the AD converter.

Figure 7.4: Voltage curve of the capacitor discharge

100n

As well, the possible self-discharge of the capacitor can be investigated with this experiment. To do this, first plug in E 
and F with the pot fully turned up.
As expected, the LED string shows full voltage. Then you pull jumper F, thereby separating the capacitor from the rest 
of the circuit. And finally you also separate E. The display goes back to the first level.
Only after a longer waiting period of one or more minutes F is plugged back in.
For a brief moment you can see the voltage that is still there. A residual voltage of approximately 90% of the original 
charging voltage was usually observed.

8 - A10 Bit Binary Counter
A binary counter counts the clock pulses and delivers the counting result as a binary number. Program 6 forms a 10-bit 
counter and continuously displays the counter status on the LEDs. Such a counter consists of a chain of flip-flops and is 
available, for example, as a CMOS IC chip CD4040 with twelve stages.
The clock frequency can be changed using the potentiometer. A very slow cycle allows the binary numbers to be read.
And you can see a pattern: Whenever a digit changes from 1 to 0, the next higher digit changes at the same time.
You can switch off the clock at any time using the S2 button and thus freeze the counter reading.
To reset the counter to zero, all you need to do is press SI, i.e. a reset.
UABCDEFGHI
Binary

Figure 8.1 : Program 6, binary counter
The binary counter is as well a good option for getting to know binary numbers, i.e. the base 2 number system.
Every position has its value. From right to left it is: 1, 2, 4, 8,... 128, 256, 512, 1024. The value 2n applies to each digit.
Therefore the counting of the outputs starts with zero, because 2° = 1, 21 = 2, 22 = 4 and 29 = 512.
If you add all these 1-values together, you get the highest number that can be represented with ten bits, 1023.
The program selection is also made here using a binary number at jumper positions A to D.

A stands for bit 0 and D for bit 3.
Program 6 was started via the binary number 0110.
Counter
Clock •
987654321 
0
Figure 8.2 : Counter and frequency divider
Looking at it in another way the binary counter is also a frequency divider.
At LED 0 you can see half the clock frequency at LED 1 f/4 etc. and at LED 9 the lowest frequency f/1024.
This frequency divider allows for the clock frequency to be roughly estimated by using just a watch. The highest clock 
frequency was set by turning the potentiometer to the right - max.

Then it is observed on the left LED (9), that flashing ten times took about five seconds.
The flashing frequency is therefore approx. 2 Hz. With the division ratio 1024 of this counter, you get an input clock 
frequency of approx. 2 kHz. However, for the most accurate measurement possible, one would have to observe a longer 
period of time.
A digital frequency meter will be introduced later, where much more precise measurements are possible.
The digital counter with an adjustable clock rate not only has technical significance, but can also be used for a wide 
variety of games.
This versatile slot machine can help train quick reactions and understanding.
The goal could be to stop the counter at a very specific count by pressing S2, e.g. at the highest number, i.e. when all ten 
LEDs are iust currently on. This is easy at a low clock speed, but takes a long time.
The higher the clock frequency, the more difficult it becomes. If several players compete against each other, everyone 
should set their own speed. Then the time is stopped from a reset to the final result.
Another game could be to read binary numbers as quickly as possible.
You stop the counter at any point and then have to convert the displayed binary number into a decimal number within 
five seconds.
The number of 1-bits in the number corresponds to the number of points won: 100 0011 = 67, i.e. three points, 10 0000 
1000 = 520, i.e. two points, or 1111 1111 = 255, eight points.

9 - A Running Light
Program 7 (Jumpers A, B, C set to 0) creates a digital counter with LED string display. Something similar can be built 
using a digital counter plus a decoder. An example is the well-known CD4017, that counts from 1 to ten and has ten 
individual outputs, one for each count.
Another possible circuit uses shift registers, as will be used in a later example.
Run

Figure 9.1 : Program 7, digital running light
Not only individual outputs are switched on here, but also a band with up to ten LEDs that shows the counter reading.
The potentiometer is used again to adjust the speed.
Jumper I must be set for this. The current LED status can be stopped at any time using the S2 button.
U A B C D
0

Figure 9.2 : Connections of the counter
The running light is also suitable as a skill game. To do this, try to always stop the LED bar with S2 at the moment 
when all the LEDs are on. The speed is then increased using the potentiometer. Two players could take turns playing 
and compare who has the quicker reaction time.
If you increase the clock frequency more and more, in the end you will only see a uniform brightness on each LED, 
sometimes with a slight flickering. The left LED lights up the brightest, the right one the weakest. In between you can 
see an even steps of brightness. This is due to the different average switch-on times.
The right LED 0 is only on for one cycle,
LED 1 twice as long,
LED 2 three times as long, etc.
until LED 9, which remains on ten times as long.
This method of controlling brightness is called Pulse Width Modulation (PWM).
It is used again later at a higher frequency.
Here, you can reduce the frequency significantly and then see the pulses directly.

10 - The RS Flip Flop
An RS flip-flop had already been made up of gates. Program 8 forms three RS flip-flops, each with one output. Based on 
the inputs it is called Reset-Set Flip-Flop. And the inputs are active low as you can see.
U A B C D
RS-FF
Figure 10. 1: Program 8, RS Flipflop
After starting, all inputs and outputs are on in a high state.

If you pull an R input towards GND, the associated Q output is switched off (reset).
If, on the other hand, you set an S input to zero, the output is switched on (set).
Once you have entered a state, it remains stored until you want to switch it or the power is switched off.
987654321
0
Figure 10. 2: The RS flip flops in starting state
The S2 button affects all three RS flip-flops at the same time and switches all outputs to the 0 state.
As a counterpart, there is input 9, where you can switch on all outputs with a jumper to GND.
As you can see, all inputs are not fully connected, so used as switches to GND as required.

987654321 
0
Figure 10. 3: Set and Reset
The three RS flip-flops can be used like a three-bit digital memory. There are then a total of eight different bit patterns 
possible in the range 000 to 111.
A voting machine to find a majority is also conceivable. The R and S inputs would have to be connected to pushbutton 
switches in the voting booths.
Each voter can set the result to yes or no on their flip-flop. In the end you can see the will of the majority.

11 - The D Flipflop
A D flip-flop is a 1-bit data memory. It transfers the state of the data input D to the output Q when a clock pulse is sent 
to C. There is also often an inverted output /Q as well.
With an edge-triggered D flip-flop, data is transferred either on the positive or negative edge of C.
The two D flip-flops generated with program 9 react to the falling edge of the clock signal.
U A B
D-FF
Figure 11.1: Programm 9, D-Flipflop

ZQ
Clk
ZQ
Clk
Figure 11.2: Both flip-flops are in idle state
In addition, a clock signal with an adjustable frequency is provided here.
This time it is connected in parallel to connections 9 and 4, so that it can be connected to the nearest clock input with 
a jumper.
To test, you can generate the negative clock edges manually, as shown on the left D flip-flop. By plugging in jumper 8, 
the D state is taken over at Q. If D is changed, it only affects Q if you open C once and then close it again against GND. 
At the same time, the inverted Q signal always appears at /Q.

987654321 
0
Figure 11. 3: Basic functions of the D Flip-Flop
If, as with the right flip-flop, the inverted output signal is fed back to the data input, a toggle flip-flop is created, that 
changes the output state with every negative clock edge. Half the clock frequency then appears at the output.

987654321 
0
Figure 11. 4: A 2 bit binary counter
You can as well operate both D flip-flops as toggle flip-flops and connect them in series, with the Q output of the first 
stage forming the clock signal for the second stage. This creates a 2-bit binary counter. This asynchronous counter 
type is also known as a ripple counter.
Incorrect intermediate values can arise for brief moments, because each counter level has a certain time delay. 
In the slowest clock setting, the slightly delayed reaction can be observed directly.

987654321 
0
Figure 11. 5: Frequency division by 4
To avoid these intermediate values, a synchronous frequency divider by four can be built:
it uses two D flip-flops that are connected to the same clock signal. The D inputs are alternately connected to Q and I 
Q of the other flip-flop. Half of the clock frequency does not occur here at any point; instead, all four outputs deliver 
a quarter of the clock frequency. But they have different phases. Because both stages depend on the same cycle, it is a 
synchronous counter.
In this case, four signals are created with phase differences of 90 degrees each, which play an important role in the 
processing of radio signals. This circuit is often used in IQ mixers for Software Defined Radios (SDR).

9876543210
Figure 11. 6: Shift register built from D flip-flops
Shift registers can be constructed using edge-triggered D flip-flops. Both D flip-flops will receive the same clock. The Q 
output of the first stage is connected to the D input of the second stage.
The data perpared with jumper 7 is stored with the next cycle in Q and then appears one cycle later at output Q of the 
second stage.
A shift register with ten stages is presented further on, which can also be used for serial data transmission.

12 - Das JK-Flipflop
The JK flip-flop is a versatile, edge-triggered flip-flop. Program 10 builds two JK flip-flops. The inputs J and K are 
comparable to the inputs R and S of an RS flip-flop, but their states only take effect on a negative clock edge.
If just J is dragged to 0, Q will be reset. If only K is set to 0, Q is set.
But if both J and K are set to the 1 state, a toggle flip-flop is created, and the output state changes with every clock pulse.
According to the Internet, the name JK is in honor of Jack Kilby: The JK flip-flop is named after its inventorjack Kilby, 
who was a Texas Instruments engineer and a co-inventor of the integrated circuit.
U A B
C D E F G H
JK-FF

Figure 12.1: Programm 10, JK-Flipflop
Because each JK flip-flop needs five connections, the clock signal is permanently connected to the left input. Without 
any further connection, J and K are in the 1 state.
The left JK flip-flop therefore works as a toggle flip-flop. Half the clock frequency appears at the output. The LEDs on Q 
and /Q flash in push-pull mode. If you short-circuit the clock input or stop the clock with S2, the current state remains 
frozen.
Likewise, the initial state remains unchanged if J and K are set to 0.
Figure 12.2: Basic functions of a JK flip-flop

The right JK flip-flop will be tested here manually, with clock pulses generated through jumper connection on 4. With 
a jumper at 3 (J = 0), the negative clock pulse turns output Q off and /Q on.
If you connect K to GND instead, Q is switched on and /Q is switched off.
If you set J and K to zero, the initial state is frozen and no longer responds to clock pulses.
If you leave J and K open, they are in the 1 state. The right JK flip-flop then becomes a toggle flip-flop, i.e., the output 
states change with every clock pulse.
987654321 
0
Figure 12.3: A binary counter
To build an asynchronous 2-bit binary counter from two JK flip-flops, it is sufficient to connect the Q output of the first 
stage to the C input of the second (5-4).

A signal with a quarter of the clock frequency of LED 9 then appears at the output (LED 0). The two Q outputs deliver 
the ascending binary numbers 00, 01,10, 11, with the left flip-flop delivering bit 0 and the right one bit 1.
This type of asynchronous counter is also called a ripple counter. At the slowest clock setting you can see a small time 
delay between the steps. When the Q output of the left flip-flop changes state from 1 to 0, it takes a moment for the 
second flip-flop to also change state. In this brief moment the counter shows a faulty intermediate state.
In practice, you wouldn't notice this on a digital display.
However, there are applications where this behavior would be harmful, so synchronous counters would have to be used 
there.

13 - The Shift Register
Program 11 forms a shift register with ten stages. Such a multi-stage shift register consists of a chain of flip-flops with 
a common clock line (see Chapter 11). With a clock pulse, each register takes over the data from its left neighbor. The 
first register in the chain has a data input that is normally connected to button S2.
Shift
Figure 13.1: Programm 11, Shift register

After starting, all outputs are in the 1 state. Without pressing a button, Is are constantly delivered, so that all LEDs 
remain switched on.
If you press S2, zeros are pushed into the chain. The clock frequency can be changed with the potentiometer as usual, 
so that the shifting speed can be adjusted as desired.
Shift
S2/AO*---- D
— Figure 13.2: Connections of a shift register
During operation, any outputs of the shift register may also be short-circuited to GND using the jumpers. Zeros are then 
pushed forward from this point.
Data can therefore be entered in parallel, and then arrive one after the other (serially) at the last position (LED 0). 
Conversely, you can use button S2 to enter serial data that will be visible in parallel on the LEDs at any specific time.
Fast “recording” and a slow “playback” are possible. To do this, you set the potentiometer to half the range, which 
results in a relatively high speed. Then you quickly press the S2 button several times and immediately reduce the speed 
to the minimum. You can now see the serially entered data in parallel form and the bits become slowly visible serially 
on LED 0.

Shift registers are the basic structure for serial interfaces. That's why a special subroutine for a slow serial interface was 
added here.
You start it while program 9 is running by briefly connecting input G to GND. The simplest option is via a jumper G- 
H, which connects input G to button S2. Then a short press on S2 is sufficient to start the subprogram.
U A B C
0

Figure 13.3: Serial data transmission
A serial transmitter transmits data with a precisely defined bit rate of, for example, 1200 bit/s (1200 baud) or 19 200 
baud. Usually eight data bits (one byte) are sent in one frame.
A start bit is sent first, so that the recipient knows when the transmission starts. Then follow the 8 data bits. At the end 
there is at least one stop bit, so that to transmit eight data bits, a ten bit length is required.
However, longer pauses between these 10 bit blocks are permitted, until the start of the next 10 bit frame.
The subroutine started with S2 uses a fixed data rate of 2 bit/s, so you can visually follow the transmission.
The data used comes from the AD converter, so you can set all bits between 0 and 255 via the potentiometer. When a 
transmission starts, the start bit on the far right is switched on first, followed by the eight data bits. The left LED 10 
remains off and forms the stop bit. After half a second, all bits slide one place to the right. The first data bit is now on 
LED 0. Half a second later, the next bit follows, etc. Zeros are continuously added from the left, so that longer pauses are 
also permitted. After a total of two stop bits, the transmission begins again. First, the AD converter carries out a new 
measurement so that other data is now possible, which is then sent out following the start bit.
If you set the potentiometer all the way to the left, zero is measured. Together with the start and stop bit it is:
0 0000 0000 1. At data output 0 you just see a short pulse, the start bit. Conversely, if the potentiometer is turned to the 
right, the bit sequence looks like this:
0111111111. You can see a nine-bit-long pulse at output 0. Any byte in the middle area looks like this: 00100 10101. 
Compared to a real serial interface, this model program works with an inverted polarity of the data bits.
On a real RS2 3 2 interface, the idle state, like the stop bit, has a voltage of -10 V, while the start bit has +10 V and the data 
bits are transmitted inverted.
The serial interface of a microcontroller uses the signals inverted and limited to 0 V and the operating voltage.
In Chapter 17, the topic of serial interfaces is taken up again.

Then both, a serial transmitter and a serial receiver are used, which work at a higher baud rate and form a real data 
transmission path.

14 - A 4 x 4 Bit RAM
A Random Access Memory (RAM) is a collection of numerous flip-flops and control logic, each storing one bit. Such 
memories are often organized as byte wide memories with eight parallel data bits. Program 12 implements a data 
width of four bits with data lines DO to D3.
A total of 16 4 bit words can be stored, which are selected via the four address lines AO to A3.
The potentiometer, together with the AD converter, are used to set any number between 0 and 15, so that you can do 
without the laborious input via jumpers.
When reading out the memory, you set the address via the potentiometer, while when writing, you set the 4-bit data 
word via the potentiometer.
BCD
RAM
U

Figure 14.1: Programm 12,16 x 4 Bit-RAM
In addition to the address lines A3, A2, Al, AO and data lines D3, D2, DI, DO, there are two control lines.
The control line R/W (Jumper 5) is used to switch the read/write direction.
There is also the /E (Enable) line,
which is used to activate input and output.
Without any jumper, R/W is set high and the /E line is automatically set to 0. This reads data from RAM.
The address is set via the potentiometer between 0000 and 1111.
When the program starts, 16 quasi-random values are automatically stored in the RAM, which can then be read out.
To do this, you have to adjust the pot carefully and pay attention to the LEDs used as address lines. This way you can set 
the addresses 0 to 15 one after the other and look at the data lines, which show the contents at this location.
Here you will find the following 16 data values:
6,14, 1,11,11,11, 2,11, 4, 6,13,15,12,12, 1, 7.
And to show this in in hexadecimal, see the translation table at the end of this booklet, and translate the decimal to hex 
and show them as bit values as seen on the LEDs: 
add 0 add 1 add 2 add 3 add 4 add 5 add 6 add 7 
add 8 add 9 add A add B add C add D add E add F

Figure 14.2: RAM connections

To save new data to RAM you have to pull down the R/W line with jumper 5. The /E line with LED 4 then turns on. 
The last address read out is still active, so you can enter new data starting at a desired address.
In write mode, the potentiometer sets the data to the data lines DO to D3. You set the desired number and then briefly 
press S2. This pulls down the /E line and enables writing.
At the same time, the address counter increases automatically by one.
If you press S2 a total of 16 times without resetting the potentiometer, the entire memory is programmed with the 
same number.
In this way you can also delete all memory cells by overwriting them with zeros.
Alternatively, you can enter the data via jumpers.
To do this, turn the potentiometer all the way to the right so that D 3 to DO display the binary number 1111.
You can then use jumpers to set any desired bits to 0 and thus enter any 4-bit numbers and program them into the RAM 
using S2.
In order to read out the data again, you have to remove jumper 5 (R/W) again.
Apart from the fact that you can look at the function of a small RAM at work in peace and quiet, this setup is also 
suitable for other tasks.
You can use the RAM, for example, as a memory for an important telephone number or a secret number. Each location 
in memory then only contains numbers in the range 0 to 9, so any hex numbers A to F are avoided.
But be careful, the stored data is lost when the power is switched off.
This RAM can also be used for a simple memory game: Anyone who can remember all 16 numbers must prove this by 
entering a called-up address and confirming the stored number at this location.

15 - PWM - Pulse Width Modulation
The first preliminary tests regarding Pulse Width Modulation had been already carried out in Chapter 9.
Program 13 now provides four PWM units, where the brightness of four LEDs can be changed in fine steps. PWM 
outputs are often used as simple DA converter, a counterpart to AD converters, to generate quasi-analog outputs and as 
a bridge from digital to analog electronics.
However, a PWM signal is actually generated digitally. You use a counter and determine at which counter reading the 
output signal is switched on and at which counter reading it should be switched off again. This creates a square wave 
signal with a selectable pulse width and at a high frequency.
To smoothen the digital PWM signal to be more analog, an additional RC low pass filter is often used.
G H
PWM

Figure 15. 1: Programm 13, PWM outputs
In this example here, the counters have a width of eight bits, so they count from 0 to 25 5.
At 0, the respective PWM signal is switched on. The pulse width can now be between 0 and 255. This sets the relative 
brightness of an LED between 0% and 100%.
You can see different brightness levels with increasing PWM settings from left to right.
The left LED 7 can be adjusted to a brightness between 0% and 50% using the potentiometer, 
the right LED 4 from 50% to 100%.
PWM
4
PWM
1
PWM
3
4 
3 
2 
1 
0

Figure 15. 2: 4 PWM outputs
The PWM frequency is approx. 120 Hz, which creates a flicker-free light. However, if you move the circuit board or your 
eyes quickly, you can see illuminated dots or lines - similar to an oscillogram.
Behind these four PWM units are microcontroller counters, that can be controlled independently. In modern 
microcontrollers you can find numerous digital components that work on their own and do not require any computing 
power and additional software to run after setup.
The limited resources of the controller used here are the reason why only four adjacent LEDs are controlled in this way. 
Although you could generate significantly more PWM signals using software, this would lead to increased computing 
activity and thus to a lower PWM frequency.
Pressing S2 starts a subprogram that automatically changes the brightness of all four LEDs. Here, a continuous wave is 
displayed by uniformly changing the brightness. This time you will use the potentiometer not to adjust the brightness, 
but rather to set the speed of the wave movement.
At high speed the wave turns into a flicker, and at maximum speed you can almost only see a uniform glow.

auip .yo-uo pup Aouanbaij Suimoijs'sjbuSis wMd t?

16 - A Frequency Counter
Program 14 shows a frequency counter. A binary counter with ten bits is used for this, and the 10 outputs are displayed 
on the LEDs. This time the input is connected to pin I, where you can apply a signal with the frequency to be measured. 
The counter runs for one second and counts all pulses at the input during this time, and then the frequency / count is 
displayed in Hertz.
The counter is automatically reset to zero before a new measurement starts.
In this program, a square wave signal with an adjustable frequency is provided at pin H as well. This time, the 
potentiometer is at E because input I is needed for the counter. This square wave can be used as well as the frequency 
source to be measured.
U
B
f-Counter

Figure 16. 1: Programm 14, frequency counter
After starting, all LEDs are initially off. When a signal is applied, the frequency display appears after one second. You 
can connect a cable to I and touch the end with your finger while GND is connected to a protective ground.
The display then usually shows 110010 = 50 Hz, because the mains hum reaches the high-impedance input. As it is 
usual with frequency counters, the last digit/bit can fluctuate due to the random phase position, so that sometimes 
only 49 Hz is displayed. Due to additional interference signals, higher frequencies can also be measured.
Counter
Clock
987654321 
0

Figure 16. 2: The connections of this counter
If other signal sources are to be connected to be measured, care must be taken to ensure that the input voltage does not 
exceed the range 0 to 5 V. To be on the safe side, you could connect an additional external 100 nF capacitor and a 10 kQ 
resistor in series with the measuring cable.
The internally generated square wave signal is measured with a connection of H-I; this internal frequency can be 
changed with the potentiometer in the range between approximately 10 Hz and 1000 Hz.
The smallest frequency display is 00 0000 1010 = 10 Hz,
the highest frequency is 11 1110 1000, so 1000 Hz.

17 - Serial Interface
Chapter 13 already showed, how a serial data stream can be generated using a shift register.
In program 15, a serial interface with a speed of 9,600 baud is now created.
Baud is the definition of bits per second.
There is a serial transmitter with the TXD output (transmit output) H. The data sent out comes from the AD converter, 
so it can be changed via the potentiometer.
There is also a serial receiver with the serial input RXD (receive data) on pin G, which displays received data to the 
eight outputs 0 to 7.
UABCDEFGHI
Serial

Figure 17. 1: Programm 15, serial interface
With a direct connection of G-H, the data sent via TXD is simultaneously received via RXD and thus converted back 
into parallel data. So, you can see the result of the AD conversions directly as a binary number.
Since around four data sets are sent per second, every change on the potentiometer can be seen with a short time delay.
If you remove jumper G-H, the last value remains because the data connection was interrupted.
U
RX o
1

Figure 17. 2: Receiving serial data
Instead of a direct connection on this board, the serial data lines can also be connected to other systems. Two of these 
boards can be cross-connected (TX to RX and RX to TX), so that each side receives the pot level of the other board.
UABCDEFGH
Interface
RXD
TXD
USB 
5V/3.3V
GND
PWM
■ 
■ 
■ 
■ 
■ 
■
D7 
D6 
D5 
D4 
B 
A
D3 D2 D1 DO
987654321 
0

Figure 17. 3: Connections to a PC
A connection to a PC is also possible.
To do this, you need a USB-to-serial converter with TTL levels, either 5 V or 3.3 V.
The idle state of a TXD line is now 1 and the data is transmitted inverted.
The sent data can be received using a terminal program.
In addition, you can send data in the opposite direction, which then will be displayed on the LEDs.
The program RS232.exe
(www.elektronik-labor.de/RS232/201OTerminal.html) was used here .

Figure 17. 4: Transmitted data seen in the terminal display
Alternatively, an Arduino can also be used as a USB-serial converter if there is no USB-serial converter available.
Attention: the names of the connections on the Arduino come from the microcontroller side.
You therefore have to connect TXD to TX and RXD to RX.
C D E F G H
Interface
TXD
RXD
USB
RST
Arduino Nano
GND
PWM
D7
D6
D5
D4
D3
D2
D1
DO
B
A
9876543210

Figure 17. 5: Using an Arduino nano
Additionally, it is important to keep the Arduino in the reset state by connecting the RST line to GND. The Arduino's 
microcontroller is then switched off and the microcontroller on our digital board takes its place.
Using the terminal program, you can also exchange data with the board in this way.
This also applies to the interface described below.

18 - Serial Interface Part 2
A serial interface, some port inputs and outputs, an AD converter and PWM outputs - these are the ingredients that can 
be used with a PC interface.
Everything can then be operated via a terminal, as was partly shown in the previous chapter.
A simple but versatile interface program is already included as a subprogram in program 0. It is started via the first byte 
received serially and uses the transmission speed of 19 200 baud.
G
H
RX
TX
AD
Interface
PWM
aaaaaaaoaa
D7 
D6 
D5 
D4 
B 
A 
D3 
D2 
D1 
DO
•----•---- •---- •---- •---- •---- •---- •---- •---- •—
9876543210

Figure 18.1: Programm 0, serial interface
This interface has
eight digital inputs/outputs DO to D7,
one analog input AD and
two PWM outputs A and B.
To address them specifically, byte commands are used that follow the well-known protocol of the SIOS interface.
If you send 16, 255, all digital ports are switched on.
With command 32 you request that the ports will be read and you receive the current status - in this case with the 
result 255, as all inputs are open.
However, if, for example, D7 is set to 0 with a jumper, the result will then be 127.
The two PWM outputs A and B correspond to the two analog outputs on the SIOS. With output 64, 20 and 65,100 you 
can set different brightness levels of the associated LEDs.
The original SIOS interface uses four analog inputs that can be read out with either a resolution of 8 bit or 10 bit. 
However, there is only one analog input here, but it has a higher resolution of 12 bits.
For reasons of compatibility, there are four commands that query the same input with different measuring ranges.
At full voltage, command 48 delivers the result 255 for 5 V.
The corresponding command 56 for the 10-bit query delivers the result 1023, with high byte value 3 appearing first 
and then, 
after being prompted with a 1, the low byte as 2 5 5.

SIOS Commands
Com­
mand
Para-meter
Answer
Function
1
10
Interface Identifier
16
Bit Pattern
digital Out 
D7D0
32
Bit Pattern
digital Input 
D7 DO
48
8 Bit Result
Analog Input 5 V
49
8 Bit Result
Analog Input 2,5 V
50
8 Bit Result
Analog Input 1,25 V
51
8 Bit Result
Analog Input 0,6125V
56
High Byte
Analog Input 10 Bit 5 V
1
Low Byte
57
Highbyte
Analog Input 10 Bit 2,5 V
1
Lowbyte
10 Bit
58
Highbyte
Analog 10 Bit 2,5 V ... 5 V

1
Lowbyte
59
Highbyte
Analog 10 Bit 0,6125 V
1
Lowbyte
64
8-Bit Value
PWM A
65
8-Bit Value
PWMB
For a first test, the analog input is connected to DO to measure the actual LED voltage in the 1 state. In addition, D7 is 
connected to GND to read in a digital state.
The program RS232.exe (www.elektronik-labor.de/RS232/2010Terminal.html) is first used to operate the outputs 
and query the inputs.
You have to enter the COM number used and set the transmission rate to 19200 baud.
Then all ports are turned on with 16 and 255. However, query 32 returns result 127, because D7 had been pulled down.
Command 48 queries the AD converter and returns the result 100, which stands for approx. 2 V. Then, the two PWM 
outputs are sent with different outputs. 64, 20 sets the brightness at A very low, 65, 100 sets the brightness at B 
correspondingly higher. As seen in Figure 18.2

RS232 Terminal COM1...255
Figure 18.2: Interface accesses using the terminal

The interface to an external PC can also be tested by using the CompactDefinition program by Hans-Joachim Berndt 
(www.hiberndt.de/soft/compactdef.html).
This software supports a variety of different interfaces and recognizes them automatically. The author has provided 
other current microcontrollers such as the Arduino or the Raspberry Pi Pico with the appropriate interface software 
and published corresponding versions of Compact.
Unfortunately in German, but online translation should do the job.
CompactDefinition
Compact [jE'n ^Ausgange j TY-Schreiber XY-Schreibec Bit-Schreibec Programm
Analog 1
Hardware ignorieren
Analog 2
3 2 1 fi
BBBB
Z 6 5 4 
aase
Analog 3
Hardware Juchen
Analog 4

Figure 18. 3: Compact in simulation mode
After starting CompactDefinition, the program is in a simulation mode without interface control. Clicking on the 
Search Hardware button, initiates a search, which after a short time establishes a connection. You can see the device 
found, in this case SIOS on COM 4.
% CompactDefinition
Compact EinVAusgange TY-Schreiber ><Y-Schreiber Bit-Schreiber Pfogramm
Analog 1
Analog 2
3
I . ,4
2 
3
k . I i / . .4
A-l ingang
B-E ingang
5
104
209
7 6 5 4
ml
3 2 10
@@@@
Analog 3
Hardware: SIOS an Com 4.
Analog 4
0
5
0
»»»»

Figure 18. 4: Connected with the interface
On the Inputs/Outputs tab you already have control over all digital ports and can see the analog inputs, which are 
labeled A to D here. All digital outputs have been switched on. The digital inputs are then also in the 1 state and can be 
switched to GND using jumpers.
As D7 had been switched on as an output and shows 0 as an input, you know that D7 was switched to GND.
Compact EinVAusgange TY-Schreiber XY-Schreiber Bit-Schreiber Programm
% CompactDefinition
Hardware: SIOS an Com 4.
WSekunden v
ABCD-Einc v

Figure 18. 5: Recording of voltage curves
The TY recorder tab can be used to record voltage curves. The example shows the result for a voltage change via the 
potentiometer. The voltage at the AD is always measured here, but in four different measuring ranges. You can see the 
ratio 1:2:4:8 for the analog channels D, C, B and A. With this interface you can select the optimal measuring range for 
small, medium and large voltages.
CompactDefinition 
— 
□ X
Compact EinVAusgange TY-Schreiber XY-Schreiber Bit-Schreibef Programm
PROGRAMM
Wiederhole
Ausgang Zufallswert = T
Bis Tastendruck
ENDE.
Hardware: SIOS an Com 4.

Figure 18. 6: A simple program
CompactDefinition contains additionally a simple programming environment with commands for 
outputs, inputs, waiting times, program loops, etc.
All lines are created by clicking on the related tab and selecting the necessary parameters, making the environment 
suitable for very simple first attempts in programming.
In this case here , a program was written that switches randomly selected outputs. The working speed is adjusted as 
needed with the turbo slider.
The result are randomly changing bit patterns at all digital outputs.
Compact Ein-ZAusgange TY-Schreber X/-Schfeiber B*-Sck«eiber Progcamm
CompactDefinition
6
5
a14 
□
3
2
1
0
1
_K
.td
1
L
n
i n
n
1
1L
ilez
0123456789 
10
t in Sekunden
I | Dau er ■ lnak.bve( Trf v Schrit
Start
lOSektnden
Hardware: SIOS an Com 4.

Figure 18. 7: Recording of port states
Using the Bit Recorder, you can record all port states and their changes while the program is running.
You can clearly see here that only one output changes state at a time. This makes it easy to check whether a program is 
working correctly.
These applications go far beyond pure digital technology with gates and flip-flops. But ultimately, every 
microcontroller and every computer is made up of a countless number of these basic building blocks.
Thanks to the high level of integration, many millions of gate functions can now be combined on one chip.
Gates then become computing units or flip-flops, and flip-flops become counters and memories.
That's why it still makes sense to know the basics of digital technology. It is then easier to understand the complex 
processes and to be able to correctly connect microcontrollers to external electronics.
In addition, this is the only way to decide for which tasks it makes sense to use purely digital components and when it 
is better to use a microcontroller.
The limits are constantly shifting, because newer microcontrollers are becoming faster, cheaper and more energy 
efficient. You can already see such a development in this package.
The same topics could have been handled by using a much larger board and via about ten CMOS IC chips.
But ultimately it was more economical to use a modern microcontroller with the appropriate software that 
implements all digital functions selected as individual programs.
Juergen Pintaske November 2023 v9

Additional Contents
93
compared to the German Original Booklet
4 Pages of the Circuit Diagram 
to be copied, screen printed or cut out
95
The 16 Example Selections via A, B, C, D
99
4 Bit in Binary-Hex-Decimal
100
A possible implementation using Arduino nano
101
to try to program something similar
to the examples here
or add completely new functionalities


The circuit diagram of this kit to copy or cut out

The circuit diagram of this kit to copy or cut out


The circuit diagram of this kit to copy or cut out

The circuit diagram of this kit to copy or cut out

The 16 Example Selections via A, B, C, D
If a jumper) is not placed then the voltage level is 1 = HIGH - no Jumper
If a jumper J is placed then the level is set to 0 = LOW - J = Jumper
D
c
B
A
Levels
Page
Chapter
1111
NOT - Inverter
21
2
J
1110
AND and NAND
26
3
J
1101
OR and NOR
30
4
J
J
1100
XNOR and XOR
34
5
J
1011
AD Converter
38
6
J
J
1010
Analog Level Display
43
7
J
J
1001
10 Bit Binary Counter
48
8
J
J
J
1000
Running Light
52
9
J
0111
RS Flip Flop
55
10
J
J
0110
D Flip Flop
57
11
J
J
0101
JK Flip Flop
61
12
J
J
J
0100
Shift Register
64
13
J
J
0011
4x4 Bit RAM
68
14
J
J
J
0010
Pulse Width Modulation
72
15
J
J
J
0001
Frequency Counter
75
16

J
J
J
J
0000
Serial Interface
78
17
J
J
J
J
0000
Part 2 Serial Interface
83
18
Note: The open inputs of the processor show a 1 = HIGH.
As result, the selection of the different examples show the inverted number sequence.
All open =1111,
and from there the binary number changes from 1111 to 0000.

4 Bit Numbers in Binary - Hexadecimal - Decimal
BINARY
HEX
DECIMAL
D
C
B
A
0
0
0
0
0
0
0
0
0
1
1
1
0
0
1
0
2
2
0
0
1
1
3
3
0
1
0
0
4
4
0
1
0
1
5
5
0
1
1
0
6
6
0
1
1
1
7
7
1
0
0
0
8
8
1
0
0
1
9
9
1
0
1
0
A
10
1
0
1
1
B
11
1
1
0
0
C
12
1
1
0
1
D
13
1
1
1
0
E
14
1
1
1
1
F
15

Values of more Bits in a binary Number
212 211 210 29 2s 2 7 26 2$ 2 * 2^ 22 21 2°
4096 2048 1024 512 256 128 64 32 16 8 4 2 1
Add up the numbers where there is a 1 
to get the decimal number.
e.g. 10101 = + 16 +0+4+0 1 =21


A first attempt to define hardware using the Arduino nano.
On a small Breadboard for now.
One slice is for the 10 LEDs plus resistors.
The other slice is for the rest. Let’s see where it leads us.

