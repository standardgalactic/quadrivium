
Visual Basic 2005 
Made Simple 


Visual Basic 2005 
Made Simple 
Stephen Morris 

Transferred to Digital Print 2010

Contents 
1 
Overview 
1 
Installing Visual Basic ......................................... 2 
Running Visual Basic .......................................... 3 
Registration .; ....................................................... 4 
Starting a new project ........................................ 5 
Visual Studio ....................................................... 7 
Getting help ...................................................... 1 7 
Leaving Visual Basic ......................................... 21 
Exercises ............................................................ 24 
2 
Forms 
25 
The first form .................................................... 26 
Form properties ................................................ 28 
Saving the form ................................................ 34 
Adding new forms ............................................ 35 
Saving and running ......................................... .40 
Exercises ............................................................ 46 
3 
Controls 
47 
Object-oriented programming (OOP) ............ .48 
Adding controls ................................................ 50 
Control properties ............................................ 51 
Common properties ......................................... 54 
Standard controls ............................................. 65 
Exercises ............................................................ 78 
4 
Coding events 
79 
The event-led environment .............................. 80 
Creating a procedure ....................................... 85 
Using and changing properties ....................... 89 
Methods ............................................................ 95 
Lists .................................................................... 99 
v 

Dealing with errors ........................................ 107 
Executable files .............................................. 110 
Exercises ......................................................... 114 
5 
Variables 
115 
Using variables .............................................. 116 
Constants ....................................................... 119 
Expressions .................................................... 1 20 
Non-numeric variables ................................. 124 
Numeric functions ......................................... 126 
String conversions ......................................... 128 
Dates and times ............................................. 134 
Arrays ............................................................. 140 
Message boxes .............................................. 143 
Exercises ......................................................... 144 
6 
Basic instructions 
145 
Modules .......................................................... 146 
Creating modules and procedures ............... 148 
Public and passed variables ......................... 154 
User-defined functions .................................. 158 
Conditional statements ................................. 160 
Case statements ............................................ 1 64 
Loops .............................................................. 166 
Exercises ......................................................... 1 78 
7 
Classes 
179 
Creating classes ............................................ 180 
Control arrays ................................................ 192 
Exercises ......................................................... 204 
vi 

8 
Error handling 
205 
Debugging ..................................................... 206 
Trapping errors .............................................. 216 
Structured error handling ............................. 220 
Exercises ......................................................... 222 
9 
Menus 
223 
The MenuStrip control ................................... 224 
Menu properties ............................................ 229 
Menu events ................................................... 233 
Adding menus at run-time ............................ 236 
Exercises ......................................................... 242 
10 Files 
243 
File selection .................................................. 244 
File operations ............................................... 249 
Sequential files .............................................. 259 
Random access files ...................................... 266 
Exercises ......................................................... 2 72 
11 Graphics 
273 
Pictures ........................................................... 274 
Lines and shapes ........................................... 276 
Timers ............................................................. 281 
Printing ............................................. ; ............. 285 
Exercises ......................................................... 290 
12 Solutions to exercises 
291 
Index ............................................................... 333 
vii 

Preface 
Visual Basic has changed dramatically over the last few years, evolving from a 
beginners' language to a fully-fledged object-oriented programming environment. 
Its structures are no longer simple to understand, particularly for those new to 
programming, but nevertheless it makes a good starting point for anyone who wants 
to develop sophisticated, effective software. 
Visual Basic 2005 provides a good introduction to Windows programming and 
can still be used to create complete Windows applications with the minimum of 
effort and time. Since an application's windows are 'drawn' on the screen, you can 
always see what the eventual application will look like, without having to guess. 
All of this is achieved without writing a line of code and, as a result, Visual Basic 
bypasses the long-winded trial-and-error approach to designing screen displays of 
the older programming languages. 
Creating the user interface is only the start, of course, and there is still a great deal 
of work to be done to complete an application. Even so, the Visual Basic 2005 
programming language is powerful and, once mastered, even complex tasks can be 
finished surprisingly quickly. 
The latest version of Visual Basic is radically different to VB 6.0 and earlier 
versions. However, many of the principles are the same and can be applied equally 
well to any of the earlier versions of the product. Where there are significant 
variations between the versions, the differences are noted. 
This new edition of the book has been revised to cover the changes made in VB 
2005. There is also an additional chapter introducing Visual Basic's facilities for 
creating classes. 
This book is aimed at those who are new to programming, or new to Visual Basic. 
No previous programming experience is necessary, though familiarity with the use 
of Windows is assumed. However, Visual Basic is a substantial programming 
language and, in a book of this size, it is only possible to give a brief introduction. 
Nevertheless, the information given here should be enough to start you on some 
interesting projects and to show what may be achieved with practice. 
Acknowledgements 
viii 
I would like to thank Mike Cash of Elsevier for his assistance and patience, and 
Natalia Zak for her hard work and dedication during the production of this book. 


Installing Visual Basic 
Visual Basic 2005 provides a sophisticated Windows programming environment 
that is capable of producing powerful programs. Since it is a 'Visual' system you 
can create the visible part of a self-contained Windows application in a very short 
time, without the need to write any program code at all. You can then add short 
procedures for performing specific tasks, using the powerful programming lan-
guage. This book shows you how tocreate fully-fledged Windows applications, 
quickly and effectively. 
Visual Basic versions 
Installation 
2 
Visual Basic 2005 is an attempt updated version of Visual Basic .NET and is 
supplied in the following editions: 
e 
The Express Edition is a cut-down version of Visual Basic, offering full 
functionality but limited application templates and design tools. 
e 
The Standard Edition provides additional templates and further tools, such as 
a report viewer. 
e 
The Professional Edition includes the full set of templates and a number of 
extra tools, such as a web form designer and component designer. 
The easiest way to start using Visual Basic 2005 is to download the Express Edition 
from the Microsoft website. This edition is initially available free but a registration 
fee may be payable in the future. 
1 
Go to http://msdn.rnicrosoft.com/vstudio/express/vb. 
2 
Click on Download Now. 
3 
Click on the Download button and follow the instructions. 
At the end of the set-up process, an option will be added to the All Programs menu, 
leading to the main Visual Basic program. 
The full Visual Basic 2005 Express Edition takes up to 1.3 Gb. If you are short of 
hard disk space you need only install Visual Basic Express and the .NET 
Framework 2.0 (requiring 500Mb). 

Running Visual Basic 
The installation process will have created icons that can be used to run the 
application. 
Visual Basic 2005 is part of the.NET Framework. This is a collection oflanguages 
that share a set of development tools. Visual Basic 2005 applications are developed 
using Visual Studio, a program used for the design of all .NET framework 
applications. 
Starting the program 
To start Visual Basic: 
1 
Click on the Start button 
to display the Start 
menu. 
2 
Move the pointer to All 
Programs. 
3 
Click on the Microsoft 
Visual Basic 2005 Ex-
press Edition option. 
3 

Registration 
The first time you load Visual Basic 2005, you should register the product. Although 
you do not have to register immediately, you must do so eventually or you will no 
longer be able to run Visual Basic. 
To register Visual Basic: 
1 
From the Help menu, select Register Product. 
2 
Enter your Microsoft Passport details (e-mail address and password). If you 
do not have a passport, follow the instructions to set one up. 
3 
Fill in the registration details. 
4 
At the end of the registration process, you will be given a Registration Key. 
Copy this key to the Registration dialog. 
After successfully complet-
ing registration, you will re-
ceive an e-mail confirming 
that the product has been 
registered. 
Click to _____ _ 
register VB 
Enter key on 
completion 
registration 
. y.,u can•;run the prosr•rrt .. for a.limited time on .. any· particular ·maehine.withoqt actifatins· 
. it. After that, you must regilterto c~ntillue using V)sutl·· Basic~ Full details of the 
regidtation process and henefib can &eJoun.d at http://msdn.microsoft.com/vstudlo/ 
.. express/register. 
· 
·· 
4 

Starting a new project 
Start new 
project 
As you enter the application, the Visual Basic window is displayed, with the Start 
Page tab open and, within this, the Recent Projects pane. If this is the first time you 
have run the program, the Recent Projects pane will be empty. To create your first 
application: 
1 
Click on the New Project button. The New Project dialog is displayed. 
New project ----....1 
button 
2 
Check that the Windows Application icon is highlighted. 
Enter Project 
name 
s 

3 
Enter a Name for the application. 
4 
Click on OK to create the new project. The location for the project will be 
selected when you first save the files. 
You now have a blank application, ready to customise. 
Saving the project 
6 
Before going any further, you should save the project and select a location for the 
project files: 
1 
In the Visual Studio window, select FileiSave All. 
2 
If you do not want to save your project in the default location, click on the 
Browse button to choose a new location. 
3 
Check the 'Create directory' box if you want to create a directory for the 
files. The folder name is the same as the solution name. 
Directory where 
solution will be 
stored 
4 
Click on Save. 
Check box to create 
directory 
The solution directory is created, along with a number of subdirectories. A number 
of files will be created here and updated as you develop your project. In general, 
you should not make any changes to these files from outside Visual Basic. 

Visual Studio 
After creating an application, a new tab (Form 1. vb [Design]) is added to the Visual 
Studio window. This is where you will design theinterfaceforyour application; the 
interface comprises the windows that the end user will see. 
The main Visual Studio window contains a number of other windows. Initially, four 
of these are open; others will pop up as you develop your application. 
Main window 
Forml 
Solution Explorer 
window 
Properties 
window 
7 

Main window 
8 
The main window contains all the elements you would expect to find in a Windows 
application: 
e 
The title bar contains the name of your new project and tells you that you 
are in Visual Basic 2005. On the right are the usual buttons for minimising, 
maximising and closing the window. 
e 
The Visual Studio menu bar includes 11 drop-down menus. Many of the 
options in these menus are described later in the book. 
e 
The toolbar contains a row of icons that provide shortcuts to the most 
frequently used Visual Basic operations. 
Title bar 
Toolbar 
Menu bar 
Below the toolbars are two tabs: 
Other windows are 'docked' by 
dragging them to the sides of 
the main window 
Navigation 
e 
The first tab, Forml.vb [Design], is where you will design the first window 
for your application. 
e 
The second tab, Start Page, was the tab that appeared when you entered 
Visual Studio. Click on this tab and you will see the same display as before. 
Here you can start a new project or change to an existing project. 
Other tabs will be added as the application progresses. If there are too many tabs 
to fit the display, the buttons on the right let you navigate between them. 

Design windows 
The main Visual Studio window can contain a number of other design windows. 
Initially, the design windows are 'docked'. at the sides of the Visual Studio display 
or are represented by buttons. There are a number of options for how these 
windows can be displayed and these can be confusing at first. The appearance of 
the windows can be changed to suit your method of working: 
e 
The windows can be kept open at all times (as is the case initially with the 
Solution Explorer and Properties windows on the right). 
e 
The windows can be made to 'float' to any position on the screen. 
e 
The windows can be hidden so that they appear as buttons 
down the side of the Visual Studio display (as for the Toolbox 
button below it). 
e 
The windows can be closed. (There are a number of closed 
windows, which will be displayed as they are needed.) 
Open windows 
When a window is open, you can change its appearance: 
e 
The width of the window can be changed by dragging the edge opposite the 
docked edge. 
e 
The window can be made to 'float' by 
dragging the title bar into the main window. 
Floating 
Properties 
window 
Docked 
Properties 
window 
9 

• 
• 
The window can be hidden by clicking the 
(Auto Hide) button on its 
toolbar; the window will then appear as an icon at the edge of the Visual 
Studio display . 
The window can be closed by clicking on its 
(Close) button. 
Floating windows 
A floating window can be changed to suit your requirements: 
e 
The window can be moved by dragging its title bar or resized by dragging any 
of its edges. 
e 
The window can be docked by dragging it to any edge of the Visual Studio 
display. 
e 
The window can be docked with another window by dragging it onto the top 
part of the second window. (Initially, the Solution Explorer and Properties 
windows are docked together in this way.) 
e 
The window can be closed. 
You can also dock or undock a window by double-clicking on the title bar. 
Hidden windows 
10 
Several options exist for the hidden windows: 
e 
If you move the mouse pointer over the 
window's button, the window is temporarily 
displayed (as a docked window). When you 
move the pointer away, the window is hidden 
again; the button for this window is enlarged 
to show the window name, while the other 
buttons are reduced in size. 
• 
You can keep the window permanently open 
(and docked) by clicking on its 
(Auto 
Hide) button. The button image changes 
depending on whether the window is tempo-
rarily or permanently open. 
Click to open window 
permanently 
Move pointer over 
button to show 
hidden window 

Closed windows 
A closed window can be opened by selecting the relevant option from the View 
menu (or pressing the corresponding shortcut key). For example, to re-open the 
Properties window, select ViewiProperties Window (or press function key [F4]). 
Window tabs 
To add a further layer of complication, design windows can be combined into a 
single window with multiple tabs. For instance, the Solution Explorer window that 
you see initially also contains the Data Sources window. If you click on the Data 
Sources tab, this window is brought in front of the Solution Explorer window. 
Data Sources 
window 
Add New Data Source, .. 
Tip. 
If the Start Page tab has been 
elosed you ean redisplay it at 
any time using ViewiOther 
WindowsiStart Page. 
Click on the Solution Explorer tab to get the Solution Explorer window back again. 
It is up to you how the windows are combined: 
e 
Drag a tab off a window to create a separate open window. 
e 
Drag an open window onto the tab area of an existing window (with tabs) 
to add the window as a new tab. 
e 
Drag an open window onto the title bar of an existing window with no tabs 
to create a multi-tabbed window. 
e 
Drag a tab to a new position within the row of tabs to change the order of 
the tabs. 
e 
Drag a tab from one set of tabs to another. 
1 1 

Window tabs 
Vou c.an restore the Wi~.dows and 
iahs to their. orishtal settings 
Jfi th . 
~oolsiQpti.otls. from the 
Wiud•l' IQenul select the<R~sef · 
t/i ndow Layout .• opt:i on. 
Using all these methods, you can set the appearance of Visual Studio to suit the way 
in which you want to work at any time. 
Form Design tab 
12 
A Visual Basic application usually consists of one or more windows. At the design 
stage, these windows are called forms. To start you off, Visual Studio supplies a 
single form, called Forml. This form will be renamed and resized when you begin 
to develop the application; other forms will be added as required. The forms are held 
in separate tabs on the main Visual Studio window. 
c,, 
o, 
,, 
···his possihle ttcr~ate aQ appUcafion. 
that has flO forlrll at tlf: for example, 
ari •ppH~ation to display a·. reminder at 
a specific time~ Jn such casts~i vou 
neef to: delete. Formf~:jee Pase 38~ 

T oolboxwindow 
Any window contains a number of different objects: buttons, text boxes, labels and 
so on. These are called controls. When you are creating a window within Visual 
Studio, these controls can be added by dragging them from the Toolbox window. 
The Pointer object at the top of the toolbox is used for selecting existing controls 
so that they can be moved, 
resized or changed in some other 
way. 
The toolbox controls are de-
scribed in detail in Chapter 3. 
Start by making the toolbox into 
a docked window by placing the 
cursor over the Toolbox button 
and then clicking on the!IIJ (Auto 
Hide) button. 
The controls are divided into a 
number of categories (Common 
Controls, Containers etc.) Click 
on the !:ail button next to a cat-
egory to display its contents; click 
on 5l to hide them again. 
Title bar: when docked, 
drag to move toolbox to new position 
Common controls 
(collection of 
controls) 
Pointer: 
select existing 
controls 
Standard 
controls 
Toolbox 
Other controls 
13 

Solution Explorerwindow 
14 
For each window in your final application there is a corresponding Visual Basic 
form, and each form has its own file on disk. Usually, there is also at least one file 
containing the program code for the application and, if your forms use any third party 
tools, these will be held in additional files. Finally, there are a number of files used 
by the system. All these files go together to make up the project from which a 
distributable program is compiled. 
For large applications, you may have several projects, forming a solution. 
The Solution Explorer window lists the projects that make up the solution and the 
files in each project. The files are listed in a tree structure, similar to that used for 
Windows Explorer. 
You can add existing files to a project or remove files. A file can be part of more 
than one project; for example, you may use the same window in two independent 
~~Solution Explorer ji{i]DataSources 
~7-"""---
Ciick for Solution 
Click to show 
Explorer 
Data Sources 
window 
applications. Files can be removed from a project 
if they are no longer required. 
At this stage, the Solution Explorer contains just 
one project (My Project) and the file for Forml. 
Click to show 
project properties 
Details for highlighted 
file shown in Properties 
window below 

Data Sources window 
The Data Sources window, which is currently available as a tab on the Solution 
Explorer window, lists the sources of data available to an application: for example, 
external database files and web sources. 
Close the Data Sources window. You can redisplay the window with DataiShow 
Data Sources. 
Properties window 
Each form, and each control on a form, has a set of properties. These determine 
the appearance of the form or control and the way in which it behaves. A form has 
properties that specify how big it is and where it is on the screen, whether it is visible 
when the application starts, whether it has Minimise and Maximise buttons, and so 
Form or control 
whose properties 
are shown 
Properties by 
category 
Setting 
Properties in 
alphabetical 
order 
15 

16 
on. Most controls have a large number of properties, some of which are similar to 
those of forms. For instance, a button has the same size and position properties as 
a form but also includes properties to 
determine which keys can be used to 
activate it. Each type of control has a 
different set of properties. For each con-
trol, you can change the settings of indi-
vidual properties (so all buttons have the 
same properties but their settings are 
different). 
The Properties window displays the prop-
erties for the selected form or control, 
and allows you to change their settings. 
The properites are listed on the left, with 
·s~me.••rropei'U•• can air~ &; 
chan sed more rirrlpfy; for in.- ' 
stan~e., t~e posmo.n or size of 
tl>f~rlrl• or control can be altered 
· by dragging the •Lject or its,. 
Lorders. 
the corresponding settings on the right. Some of the more important properties are 
described in Chapters 2 and 3. 
Initially, the properties are divided into categories: forinstance, those that determine 
the appearance of the object and those that specify its behaviour. However, this 
format can be confusing, so you can list all the properties in alphabetical order by 
clicking on the 
button. To return to the listing by category, click on 
' 
.· 
screen ·u .. 
. .. 
.. tered ~- pos,sibfe, ... a~imi!efh.e 
m~in .wJndo~, J.oek ·the toolbox' 
.and reduc~ itr width, ~lose tlte . 
Data .~ources. windQtl. and dock 
the $olutiortExplorer and Prop., 
. ertie* windows; Red~cuhe height 
~~ the Solution Explorer windfl\f. 

Getting help 
Visual Basic contains a wide range of controls and other elements. Deciding which 
ones to use can be a problem. However, Visual Studio holds all the information you 
will need in the form of on-line help. The 
information available includes help specific to 
Visual Basic and the more general MSDN 
Library. Because the help is very extensive 
you may have chosen not to install the MSDN 
files; these are still available, provided you are 
connected to the Internet. 
The easiest way to get help is via the Help 
menu: 
1 
From the Help menu, select Index. 
2 
In the 'Look for' box, type the word or 
phase for which you need help. 
3 
Click on the appropriate topic: for in-
stance, the Form Designer window or 
an item on the Toolbox or Properties 
windows. 
Click on an item to show 
corresponding help 
Click on Contents tab 
topics 
17 

4 
Click on a topic in the Index window. The relevant help page is shown as a 
tab in the main window. 
The user intetface is the part of your program that users see when they run the program. An user interface usually consists of a main window or form 1 
and several controls, such as buttons 1 fields for entering text1 and so forth. Visual Basic programs that run on your computer are known as Windows 
Forms applications) and the user interface is created using Windows Forms controls. 
The lessons in this section will show you how to create a user interface using some of the most common Windows Forms controls. 
18 
In This Section 
Communicatina with Your Proaram's User: The User Interface 
Interacting with the User: Using Buttons 
Displaying and Receiving Text: Using Label~ and Text Boxes 
Makinq Your Program React to the User: Creating an Event Handler 
Getting User Choices: Using Check Boxes and Radio Buttons 
Picture This: Displaying Images 
Giving Users Choices: Creating f'l1enus at Design Time 
On Time: Using Timers to Petform Regular Actions 
Related Sections 
Closer· Look: Sharing an Event Handler 
Closer Look: Using ~llultiple Groups of Radio Buttons 
What Went Wron 
Links to other 
help topics 
Help topic 
5 
You can move to another help topic by clicking on one of the blue, underlined 
phrases. You can move backwards and forwards between the topics you 
have viewed by clicking on the buttons on the left of the Web toolbar. 
6 
When you have finished with the help screen, remove it by clicking on the 
Close button; alternatively, click back on the Visual Studio window to keep 
the help page open. 

You can also get on-line help in other ways: 
e 
Select HelpiContents. This opens the Help Contents window, where a 
number of 'books' are displayed. Double-clicking on the books and the topics 
they contain eventually takes you to a help screen. The 'Sync with Table of 
Contents' button on the Web tool bar allows you to find the current help topic 
in the Contents list. 
Select relevant set of 
documentation 
Click to open or 
close a book 
When topics are listed, 
click on topic 
Synchronise with 
Contents 
$ .. Help for Visual Basic 6. 0 
: 3:1-· Visual Basic Express Sample 
i±J- Visual Studio Tools 
! .... SQL Server 2005 Express Edition 
19 

20 
e 
Select HelpiSearch to search the help for a particular word or phrase. 
Matching topics are listed in the Search tab. Double-click on a topic to display 
the corresponding help. You can reduce the number of topics found by 
specifying a particular part of the extensive help (e.g. Visual Basic). 
e 
The best access point for help is the MSDN library. To display this help, enter 
http:/ /msdn.microsoft.com/library at the top of any help tab. Then select from 
books and topics in the left-hand pane. 
The MSDN Library is an essential resource for developers using Microsoft tools, products, and technologies. It 
contains a bounty of technical programming information, including sample code, documentation, technical 
articles, and reference guides. 
Want to get the latest MSDN headlines sent to you via e~mail? Sign up for the MSON Flash Newsletter. 
Go to the MSON Recf"~Q.§kd area to find all of our headlined content that has been published during the last 
month. Articles, code samples, downloads, and more are listed chronologically. 
Looking for older content? Visit the ~1SDN Library Archive for technical articles related to previous version of 
Microsoft technologies and products:. 
e 
Save the MSDN contents page for future use by clicking on the 'Add to Help 
Favorites' button. To redisplay the help page, select it from the Help 
Favorites tab. 
e 
Click on an object and then press function key [Fl] (context -sensitive help) 
to go straight to the topic relating to your current activity. For instance, if you 
click on a window and press [Fl] you will get information on that window. 
You can also get context-sensitive help on error messages and individual keywords 
when writing code. 

Leaving Visual Basic 
You can get out of Visual Studio at any time, either temporarily (while you work 
on some other application) or permanently. 
Suspending Visual Studio 
To suspend Visual Studio temporarily, click on the Minimise button on the main 
window and then start another application, 
To get back into Visual Studio, use one of these methods: 
e 
If Visual Studio was minimised, click on the project's taskbar button. 
e 
If any part of the Visual Studio window is visible, click on it. 
e 
Press [Alt·Esc] or [Alt-Tab] repeatedly to cycle through the open applica-
tions until Visual Studio is active. 
The program will be exactly as you left it. 
Exiting VisuaiStudio 
To close down Visual Studio altogether, select FileiExit Alternatively, click on the 
Close button on the main window. If you have made any changes to the current 
project you are asked if you want to 
save them: 
e 
Click on Save (or press [En-
ter]) to save the changes . 
• 
• 
Click on Discard to abandon 
the changes - no further con-
firmation is requested. 
Click on Cancel (or press 
[Esc]) to continue working in 
Visual Studio. 
If you attempt to. close down the 
computer without ending Visual Stu-
dio, Windows will close Visual Studio 
for you and the same options will be 
given for any unsaved projects. 
Forml.vb 
Don't save 
changes; exit 
forml , Designer. vb 
Forml.resx 
save; 
resume working 
in Visual Basic 
21 

Restarting Visual Studio 
You can add Visual Basic to the Start menu by right -clicking on the entry in the All 
Programs list and selecting 'Pin to Start menu'. You can then re-run Visual Basic 
by simply clicking on the Start button and then on the Visual Basic icon. 
,~ :,,'' ,' 
'>~~,,' ~,-'~ 
'', 
~~,; ' 
~~ 
¥ou llill' run Vinal Studio .~nd open an 
existing project in .i single·.·· action hf 
locating tlt~VBPROJ file ushrgWiadows 
Explorer ~u•d dou,le~clicking .on it .... frf 
· tit is case, tlte Start Pa.ge tab Yllfl not be 
opened. 
The projects you have 
worked on recently are 
listed in the Visual Stu-
dio Start Page. Click 
on a project name to 
open it. 
Click to 
open 
Open: 
Create: 
ProJect ... 
Project. .. 
To open a project that is not included in the Start page: 
1 
On the Start Page, click on the Open File button. 
2 
Locate and open the project directory. 
Register Visual Basic E 
Mon, 07 Nov 2005 18:12:! 
stock photography picture 
from lconBuffet, 3rd-part· 
2005 Express Edition: Builo 
Video Series: Absolute 
Mon, 07 Nov 2005 18:12: 
that walks through creatir 
SQL Server 2005 Express. 
Video: Using X 10 Hard1 
Mon, 07 Nov 2005 18:11 :· 
3 
Click on the file with an SLN extension and then on Open. 
22 

Upgrading old projects 
There are big differences in the format of application files between previous 
versions of Visual Basic (e.g. VB 6.0) and Visual Basic .NET. There are also 
differences between VB .NET and VB 2005. However, Visual Basic lets you 
upgrade an existing application without too much difficulty: 
1 
Create the directory where you want to store the upgraded project. (The 
upgrade process does not do this. automatically for you.) 
2 
On the Visual Studio Start Page, click on athe Open File button and select 
the project to be upgraded. 
3 
The Visual Studio Conversion Wizard starts. Click on Next to start the 
wizard. 
4 
Decide whether or not to create a backup of the existing project. Click on 
Next to continue. 
5 
A summary is displayed. Click on Finish to start the conversion process. The 
upgrade may take quite a while for large projects. 
6 
On completion, the new version of the project is displayed in the Solution 
Explorer window and the application can be edited as required. Included in 
the Solution Explorer is a file called _UpgradeReport.htm, which gives 
details of the upgrade process and any errors that were encountered. 
7 
Click on the Save All button to save the upgraded application, accepting the 
default name suggested for the solution filename. 
23 

Exercises 
24 
1 
Start Visual Basic and create a project called Member Database, saving it 
in the hard disk's root directory. 
2 
Reset the windows and tabs and their original settings. Identify the windows 
that are displayed. 
3 
Make the Toolbox into a pernament docked window and resize it to make it 
take less space. Make the Data Source window into a floating window, then 
close it. Maximise the main window. Display the properties in alphabetical 
order. 
4 
Search for help relating to the Properties window. Afterwards, close the help 
page and any open windows. 
Use this window to view and change the design-time properties and events of selected objects that are located in editors and designers. You can also use 
the Properties window to edit and view file, project, and solution properties. Properties Window is available from the View menu. 
The Properties window displays different types of editing fields, depending on the needs of a particular property, These edit fields include edit boxes, 
drop-down lists, and links to custom editor dialog boxes. Properties shown in gray are read-only. 
Object name 
Lists the currently selected object or objects. Only objects from the active editor or designer are visible. When you select multiple objects, only 
properties common to all selected objects appear 
Categorized 
Lists all properties and property values for the selected object, by category. You can collapse a category to reduce the number of visible properties. 
When you expand or collapse a category, you see a plus(+) or minus(-) to the left of the category name. Categories are listed alphabetically. 
Alphabetic 
Alphabetically Sorts all design-time properties and events for selected objects. To edit an undimmed property, click in the cell to its right and enter 
changes. 
Property Pages 
Displays the Propert)" Pages dialog box or Project Designer for the selected item. Property Pages displays a subset, the same or a superset of the 
properties availoble in the Propel1:ies window. Use this button to view and edit properties related to your project's active configuration. 
Properties 
Displays the properties for an object. Many objects also have events that can be viewed using the Properties window 
Events 
5 
Minimise the main Visual Studio application and then re-activate it. 
6 
Exit Visual Studio, saving any changes. 
For help with these exercises, see page 292. 


The first form 
Form files 
Any Windows application is made up of one or more distinct windows. A window 
can be used to display information, to allow the user to enter data or to provide 
options for the user to select. At the development stage, the windows that make up 
a finished Visual Basic application are called forms. The forms you create become 
the windows through which the user accesses your application. 
It is up to you, when designing a form, to decide how the window will behave: 
whether it is on-screen initially; whether the user can minimise or resize it; what 
objects it displays; and so on. However, you should remember that once a window 
has been displayed it is the user who decides the order in which things happen and 
when the window will be closed down. The more objects (buttons, scroll bars, text 
boxes etc.) you put on a form, the less control you have over the user's actions. 
A form starts off as an empty window, which may have a title bar and control 
buttons (Control-menu box, Minimise button, Maximise button, Close button). 
Within this, you may add other objects: buttons, lists, check boxes etc. 
The details of each form are stored in two form files, with extensions of vb and 
resx. These hold information such as the initial size of the form and its position, the 
objects on the form and so on. 
· 
Form.s are alto used for most 
dialog boxes (e.g. those .. fo 
select a file or enteria .pus-. 
w.ord) though >some sirnple 
messageJoxes &an be createf 
. 
. 
. 
Beo.a.use a form is totaUyseffCcontain.ed {theforllJ 
· filecontaill., hth • deseription of the form and aU 
the code attacbd tr)it), the sa:rne forl'd can he re-
.uted ·in other appHoatioJis •. This. means that a 11 your 
·application ~-n·ha~ethe$ame.'fookandfeet', as 
as and !fhefl requlred within 
well as red~cbtg the amo11nt of tirrie Jou spend 
.the code (see page 143)~ 
. 
. . 
~reating applioations. 
26 

Forml 
There will usually be some Visual Basic code attached to the form, determining how 
the application will respond when the user takes action on the window's controls. 
For instance, when the user closes the window, the code attached to the form should 
take any necessary action on data that has been entered and then remove the 
window. The code for a particular form is stored in the corresponding vb file. 
The forms in an application are listed in the Solution Explorer window.(To display 
the Solution Explorer, if it has been closed, select ViewiSolution Explorer.) 
Click to show 
or hide list 
Filename 
Visual Basic supplies a default form to start the project: Forml. You can use this 
as your application's front-end window. You can increase or decrease the size of 
the window by dragging the handles on the form's edges and corners. 
Other changes to the window and the way in which it behaves are made by altering 
the form's properties. 
Drag side to resize 
horizontally 
Drag corner to 
resize horizontally 
and vertically 
27 

Form properties 
28 
The appearance and behaviour of a window are determined by the corresponding 
form's properties. These specify such details as the size and position of the 
window and whether it can be minimised or closed. For each property, there is a 
single setting. 
When you click on Forml in the main window, the properties are listed in the 
Properties window, in the left-hand column. The corresponding settings are shown 
on the right. Any property can be changed by clicking on the appropriate item. In 
some cases, there are a fixed number of options and you must choose from a drop-
down list; for others, a value for the setting can be typed in directly. 
Click to list 
properties 
by category 
Property 
Object whose properties 
are being displayed 

Name and Text 
Form 
Name 
The Name of the form is the name that 
appears in the Solution Explorer window; the 
Text is the piece of text that appears in the 
title bar (for the front-end window, this is 
usually the application title). Either ofthese 
properties can be changed by clicking on the 
existing setting and typing over it. 
The Name property is shown in brackets so 
that it appears at the top of the alphabetic 
property list. Its setting should be changed to 
something that will tell you what the form 
does. 
~ 
In earlier ~ersion.ofVitual 
. Basic. the Text property 
.· .. wu called the . Caption 
'rt~perty. 
Adopt a suitable convention for naming forms and controls. For example, identify 
forms by setting the first three characters to be 'frm', such as 'frmFront' for the 
front-end window. The Name will be used when referring to the form in the code. 
MaximfzeBox 
: True 
MaximumSize 
~~~~~~~g~~~o 
MinimizeBox 
~True 
MinimumSize 
'01 0 
Opacity 
i 100% 
Padding 
RightT~l~ft 
~.i~htToleftLaro_~t;~a!~~ 
Showlcon 
'True 
Text on title bar 
\h m 
Artho~gh the pr~t~rties ate nfas you develop 
theform, you can aJs~ wrHe eo.de to change 
them while fhea,lication .isttUJnin! ·;., see 
page 81J. 
29 

The border style 
30 
The FormBorderStyle property specifies the type of border and the elements that 
may appear in the title area. The most useful options are: 
None 
FixedSingle 
Fixed3D 
Sizable 
FixedDialog 
There is no border; the window has no title bar or control 
buttons - useful for message boxes. 
The window may have a title bar, Control-menu box, 
Close button, Minimise button and Maximise button. 
The user cannot change the window size by dragging the 
border. This style is used for windows with a fixed 
number of controls (e.g. data-entry forms). 
As for FixedStyle but with a three-dimensional border. 
The window may have any of the Fixed Single controls 
and may also be resized by the user. This is the default 
for all new forms and is used anywhere that the user 
may need to resize the form (e.g. text windows, 
spreadsheets, pictures). 
The window is a dialog box. It may have a title bar and 
Control-menu button but cannot have the other control 
buttons. It cannot be resized by the user. 
drop-down 
button 
Two other options,FixedToolWindow 
and SizableToolWindow, are used in 
the creation of toolbars. For more in-
formation on these options, see the on-
line help. 
To select a border option, click on 
to display list FormBorderStyle. A down-arrow but-
an option 
ton appears on the right of the current 
setting. Click on this, and a drop-down 
list is displayed. Click on one of the 
options in the list to change the setting. 
Previous versions of VB had a 
BorderStyle property rather than 
FormBorderStyle. 

Title bar and buttons 
If FormBorderStyle is None, the window will have no title bar and therefore no 
buttons. For any other setting a title bar is displayed and may contain the usual 
Windows buttons. The inclusion of a Control-menu box, Minimise button and 
Maximise button are determined by the settings of the ControlBox, MinButton 
and MaxButton properties respectively. 
Each of these properties has two possible settings: True or False. The True setting 
indicates that the button is included (and therefore that the user may click on it); 
False means that the button will not be available. 
The Close button is included only when there is a Control-menu box. 
The ShowlnTaskbar property determines whether an icon for the form is added 
to the Windows taskbar. If the property is set to False and the form is minimised, 
it will appear as a small window in the bottom left of the screen. 
MaxButton 
ntroiBox 
Size and Position 
The size of a form can be altered by dragging its borders and is held in the Size 
property. 
This property is actually a combination of two independent properties: 
Width 
Height 
Width of form (including borders) 
Height of form (including borders and title bar) 
For a more precise form size, the Width and Height can be entered directly in the 
Properties window. Entering the settings directly also ensures consistency between 
windows. 
31 

32 
You can set the property directly in two ways: 
e 
Click on the Size setting and enter values for width and height, separated by 
a comma. 
e 
Click on the l±l button to the left of the Size property and then enter the Width 
and Height individually. 
All sizes are measured in pixels. Therefore the physical size of the window will 
depend on the resolution of the end user's screen. 
For high-resolution screens, windows will be smaller and take up less space on the 
screen; text appears much smaller and more can be fitted on the screen. 
The initial position of the form in the screen is determined by the StartPosition 
property, which can take the following values: 
WindowsDefaultLocation 
WindowsDefaultBounds 
CenterScreen 
Center Parent 
Manual 
The position is set by Windows when the 
program starts. (This is the default setting for 
all new forms.) 
The position and size are set by Windows 
when the program starts. 
The window is centred on the screen. 
The window is contained in another window 
and is centred within that window. 
The position is determined by the Location 
property. 
·· Wh~~ dtveloping ... oll a high~res~lut.f~rt·scren~ .. rememher ·that· end·· users · 
may have screens·afJo,erresol~fion. ·Eit~erma~e srJre. that w.indows will .. 
have an inifi~.l positioo towards the left andJop or tlte screen, or get the 
ust)r'~ screen d irnens ions and. ustfhe.m to calculate tlte po~ifi~n and s.i~e · 
at rrJn thn.e -see ~ltapter -1~ · · 

Set the value by clicking on StartPosition and then selecting from the drop-down list. 
If you choose Manual, you must also set the Location property, which is a 
combination of two other properties: 
X 
Distance from left-hand side of screen or parent window 
Y 
Distance from top of screen or parent window 
Both properties are specified in pixels. As for the Size property, you can either enter 
the Location values separated by a comma or specify the X and Y values 
individually . 
. VJ$ual Basi~ 6.0 allowef ¥P~ to us~ a vatre~y o.l scalesr in.Yis~al Basic 
... 200S allsJzes m.olf he ~~~en irt pixels. 
· 
· 
Visible and Enabled 
A window should be displayed only when it is needed; this is controlled by the form's 
Visible property. When Visible is True, the window appears on the screen in its 
predefined position; when Visible is False, the window is hidden. Usually, the first 
form is visible; making the first form invisible when the program starts up requires 
some additional programming (see 'Making a Startup Windows Form Invisible' in 
the MSDN help for details). Other forms are usually displayed as needed and then 
hidden or closed when no longer required. As with most properties, the settings can 
be changed when the program is running. 
Only one window can be active at a time; the colour of the title bar is used by 
Windows to show which window is active. Clicking on a window makes it active 
(and deactivates all other windows). 
Even though a form is visible, you may not want the user to be able to access it. For 
instance, when a dialog box is displayed, you may not want the user to click on the 
window behind it until the dialog is closed. When the Enabled property for a form 
is True, users can click on the corresponding window to make it active; when the 
property is False, clicking on the window has no effect. 
33 

Saving the form 
34 
Like all other computer applications, you should save your work regularly. It can 
take a long time to set up a form just as you want it and it takes only a few seconds 
to save it. 
As described above, the details of the form will be saved in a pair of form files. 
These files hold everything that is needed to construct the form: its properties, its 
controls and their properties, and the code attached to the form. 
The form files have been created in the project directory, with the default name 
Forml. Before beginning the task of customising the form, you should give it a more 
appropriate name. To save the current form with a new name, select FileiSave 
formname.vb As from the Visual Studio menu bar. The project directory is shown 
and you can give the file a suitable name (e.g. frmFront.vb for a form named 
frmFront). If you type a new name, Visual Basic will add a VB extension. 
Remember that you are choosing a name for the form, not for the project as a whole. 
Visual Studio will also create the corresponding RESX file. 
After saving the file, the filename 
you specified appears in the So-
lution Explorer window. 
You should change the Name 
property for the form to match 
the filename; you should also 
change the Text property so that 
suitable text is displayed in the 
title bar. 
c" 
' 
, 
.·.···1i;lh 
., ~ ... "" .. 
· ...•..... •~-:.~· 
In future., you tan quickly-ave 
the current form by pr.euing 
[Ctrl·S1~ Do this .every.few 
minutes. .. 
New filename shown in 
Solution Explorer window 
T~e origipal Forml.Jiles. 
will elsa stilt cudst ln the 
c 
' 
, 
' 
·. prbject direct.ory ap~ 
· he delete~ .. 

Adding new forms 
Most applications need a number of windows, and the forms for these can be created 
in much the same way as the first form. To add a new form, select ProjectiAdd 
Windows Form from the Visual Studio menu, click on the Windows Form icon (if not 
already selected), type a filename for the form and then click on Add. 
New Windows form 
Dialog 
Explorer Form 
MDI Parent 
About Box 
Login Form 
Splash Screen 
Class 
Form 
Module 
DataSet 
SQL Database User Control 
Text File 
Enter filename for new file; 
VB extension will be added 
Click to create 
new form 
A blank form is displayed in a new tab, with the same default settings as the original 
Forml. An entry for this form will have been added to the Solution Explorer 
window. 
The property settings for either form can be changed by clicking on the appropriate 
tab in the Visual Studio window and then changing the values in the Properties 
window. 
35 

36 
The Name for the new form is set to match the filename, so does not need to be 
changed. The Text property should be changed to something that describes the 
purpose of the form. 
Filename; Name property is the 
same (without extension) 

The following table lists suitable property settings for three different types of form 
that might be used in an application: 
Data Entry 
Property 
Window 
(Name) 
frmData 
Text 
Data Entry 
Location: 
X 
100 
y 
200 
Size: 
Width 
480 
Height 
480 
BorderStyle 
FixedSingle 
ControlBox 
True 
MinButton 
True 
MaxButton 
False 
Having set up the new forms, each one 
should be saved with FileiSave (or press 
[Ctrl-S] or click on the Save icon on the 
toolbar). This option saves the current 
form, so make sure you have clicked on the 
tab for the form you want to save. 
Keep all forms for the project in the same 
directory. 
Text Entry 
Message 
Window 
Box 
frmText 
frmMess1 
Text Entry 
Error 
200 
300 
100 
300 
512 
400 
300 
120 
Sizable 
FixedDialog 
True 
False 
True 
False 
True 
False 
37 

Adding existing forms 
Existing form files can be added to the project at any time. Select ProjectiAdd 
Existing Item and then choose the file with VB extension from the file list. In this 
way, you can restore forms that were previously removed. You can also add in 
forms that were created for other projects. 
Removing forms 
If a form is no longer needed, it can be removed from the project: 
e 
The form can be permanently deleted. On the Solution Explorer window, 
right-click on its form name and then select Delete from the pop-up menu. 
You are asked to confirm the action, following which the form is removed 
from the project and the two form files are deleted from the project directory. 
e 
Depending on the type of project, the form may be temporarily excluded. On 
the Solution Explorer window, right-click on the form name and then select 
Exclude From Project (or use ProjectiExclude from Project). Although the 
form is removed from the project, the form file itself is unaffected and can 
be restored later if required . 
.... ·.·· .. 
· 
.. 
\,' ~· 
Wh~n .:hartgiftg form propertie*, make 
su't yfluue working with tht. oorrept 
form.Jhe name of.the current form IS 
sho~~ at> the.t~P·.· ... o.f.the .. Propertiet 
whtdow. 
38 
Right-click on form name to 
show pop-up menu 

Restoring a form 
To restore a form that has been previously excluded: 
1 
Select Project! Show All Files. The list in the Solution Explorer is expanded. 
Among the new items (which were previously hidden from view) is the 
excluded form file, next to a white icon. 
2 
Right-click on the file and select Include In Project (or use Projectiinclude 
In Project). The form's icon is restored in the Solution Explorer list. 
3 
Select Project! Show All Files again, this time to hide the other (system) files. 
4 
There is currently no tab on the Visual Studio display for the form, so double-
click on the VB file in the Solution Explorer to display the form again. 
Hidden 
directory 
Click to show 
related files 
Hidden file 
. Yeu can. eop~ shn~ard ferm. fi.les to .another directory. for ~~e with a 
4iffere~t project. These.t1tn then he added to the new pr~jeet. 
. 
····.·Yo~ can· also.'copy all enthe project .. Hncluding •llJts filet) to I· new > 
diuctory and th~ri change the •projectname. and use this as··the. basis·for >·• 
.a ·ntw ·project~ . · 
· 
· ·· ·. 
· 
· · · 
···· 
39 

Saving and running 
40 
Usually, an application is made up of several windows, each of which is created 
from a form in a VB file. The application as a whole has a project file, which 
defines the forms and other files that go together to make up the finished project. 
The project is defined by a number of files in the project directory; the main file 
has the name given to the project initially and the extension VBPROJ. 
The project has two properties: the filename and its location. You can change the 
name of the project at any time by clicking on the project name at the top of the 
Solution Explorer and then changing the Project File setting in the Properties 
window. The immediate effect is that the name changes in the Solution Explorer and 
the two physical files are renamed. 
Project name 
The project comprises part of a solution (which may contain other projects as well). 
The solution is defined in two further files, with SLN and SLO extensions. Initially, 
the name of the solution is the same as the project name. 
The solution also has a number of properties, which you can display by clicking on 
the solution name at the top of the Solution Explorer. You can change the Name of 
the solution in the Properties window; the names of the solution files are updated 
immediately but there is no change to the project filename or project folder name. 

Solution name 
Solution 
filename 
You can save any changes to the project or solution by clicking on the appropriate 
item in the Solution Explorer and then selecting the relevant Save option from the 
File menu. Any changed forms are saved at the same time. 
More simply, you can save all your changes (to forms, the project and the solution) 
at any time by selecting FormiSave All or by clicking on the Save All button on the 
toolbar. 
Save all 
If you have set up a SoureSafe database, you will also be asked if you want to save 
the project in SourceSafe. This is a file management system, which stores previous 
versions of your files so that you can recover them at any time. SourceSafe is 
particularly useful if several people are working on a project at the same time. For 
information on SourceSafe and setting up a SourceSafe database, see the on-line 
help. 
41 

TheStart-upform 
42 
Visual Studio needs to know which form you want to display first when the program 
is run. By default, it assumes this will be Forml. However, if you have renamed this 
form or want to use a different form, you must tell Visual Studio the name of the 
new start-up form: 
1 
Right-click on the project name in the Solution Explorer and select Proper-
ties. 
2 
Click on the 'Startup form' object drop-down box and select the relevant 
form. 
3 
Click on OK. 
• 
··.~···· 

Running the application 
To test the program, select Start Debugging from the Debug menu (or press [FS]). 
An Output window appears at the bottom of the Visual Studio window and a few 
messages will flash by (if the window has been selected for display). 
The first window should pop up very quickly.lt may not appear very impressive but 
all the buttons on the window should behave as you would expect. The Minimise 
and Maximise buttons (if included) reduce the application to an icon or blow it up 
to full-screen size, respectively. The window can be moved or resized (depending 
on the setting for BorderStyle ). Other windows are not visible yet- you need to add 
some program code before they can be seen. 
The Visual Studio window is still open, behind Forml, but you cannot make any 
changes to your application. The title bar shows that it is '(Running)' and some of 
the windows are hidden. 
Some windows hidden 
while application ts 
running 
Visual Studio visible 
in background 
Application runn1ng 
in the foreground 
43 

44 
You can close the application by clicking on the Close button in the top right-hand 
comer of the window. You will be returned to the Visual Studio window, where you 
can continue building your application. 
The Output window shows details of how the program was compiled. If the window 
is not visible, select ViewiOther WindowsiOutput. By clicking on the drop-down 
box at the top of the window you can choose between the Build and Debug 
messages. You can close this window at any time. 
Click to select either Debug or 
Build messages 
Messages will show actions 
carried out while the application 
was running 
'If fGU cahriot ~lose doWn fCJ~~ ~pplicationfor ahy reason, yo11 can ttiWays 
do so Ly switehin~ to VisuaiSt~dio and selecti"'t DehltaiStop t>ehuttina~ 
This wUI exit your appUcatio.-,. closi~g any open window! and,givlna you 
f11ll acl},ess to Visual ~tudio.i once again. ~o harm wi II eome tt». your 
application when you do this. 

Debug options 
There are two ways of starting your application: 
e 
Selecting DebugiStart runs the program with debugging turned on, so that you 
can interrupt the program at any time and find out how it is operating. 
e 
Selecting DebugiStart Without Debugging runs the program independently 
of Visual Studio. You cannot interrupt the program but you are able to carry 
on working in Visual Studio. In this case, the Output window shows only the 
Build stage of the compilation. 
Build window 
Membership Database -> C:\Documents and Settings\Stephen Horris\Hy Documents\Visual Studio 2005\Projec 
========== Build: 1 succeeded or up-to-date~ 0 failed, 0 skipped ========== 
I 
EXEfiles 
Messages show actions carried 
out while the application was 
being built 
When you build and run an application, an EXE version of the application is also built. 
This file can be found in the 'bin' subdirectory of your project directory. 
You can run the EXE file at any time, even when Visual Studio is not running. 
However, you should take care to ensure that the program is not going to 'hang'; 
you will not be able to break into it via Visual Studio and the only option will be[Ctrl-
Ait-Del]. 
45 

Exercises 
46 
The exercises in this book build up an application for storing membership details for 
an organisation. This application can be modified to suit many other purposes, such 
as a contacts database or a program to store records of correspondence. 
1 
Open the Membership Database project. 
2 
Modify the front -end form, so that it has a Minimise button but no Maximise 
button. The form should be of fixed size, with a suitable title. N arne it 
'frmMainMenu' and save it in a file called frmMainMenu.vb. 
3 
Create a form for entering data, again with no Maximise button and of fixed 
size. Name it 'frmDetails' and save it with a suitable filename. 
4 
Create a form for entering text. This form should be sizable. N arne it 
'frmComments' and save it with a suitable filename. 
5 
Change the Name of the project to 'Members' and its filename to 
Members.vbproj. 
6 
Save the changes. 
7 
Set the front-end form as the start-up form. Save the changes. 
8 
Run the application to check that the front-end window is displayed correctly. 
Save the changes. Close the Output window. 
For help with these exercises, see page 293. 
Grid points not 
displayed when 
application is run 
Maximise button 
available 


Object-oriented 
• 
programm1ng 
In a very short time, you have built a fully functioning Windows application -
something that would take you many weeks to accomplish if you had to do it from 
scratch. This has all been achieved with the object-oriented programming struc-
tures that underly Visual Basic. This section gives a very brief introduction to 
object-oriented programming (OOP). 
Objects and their use 
48 
In traditional programming systems, a program consists of a linear series of 
instructions, through which control flows in an ordered and predictable manner; 
data is stored separately from the program. Object-oriented programs, on the other 
hand, have a much looser structure, in which programs and data are bound together 
in independent units and control lies firmly in the hands of the user. 
The windows in your application and their components-buttons, labels, scroll bars, 
menus etc. - are all objects. An object is self-contained; it comprises both the 
procedures to perform its required tasks and the data that these procedures need. 
In a process called encapsulation, the procedures and data are insulated from the 
rest of the program. There should be no danger of control jumping unexpectedly 
from one object's procedures into the middle of those of another object; nor should 
it be possible for one object to inadvertently change the data belonging to another 
object. 
Information - data and instructions - is passed between objects in the form of 
messages. For instance, when a button is clicked, Windows sends a particular 
message to the button object. The button-click procedure is executed and another 
message is sent back to say that the action has been processed. 
All objects of the same type come from the same class. The class defines the 
procedures and data for the object. Visual Basic uses a set of related classes called 
the .NET Framework Class Library and all objects in your programs will be 
derived from one of these classes. This library is made up of a number of 
namespaces. Each namespace contains a collection of classes. 
For instance, all buttons come from a class called Button in the System. Windows. 
Forms names pace. The class is a template for objects of that type; individual objects 
are created as instances of that class. 

The appearance of an object- and to a certain extent its behaviour -is determined 
by its properties: specific data values encapsulated within the object. For example, 
two windows from the same class may have different text in the title bar; whether 
or not they can be minimised is determined by the value of another property. 
When a class has been defined, a new class can be derived from it. Initially, the new 
class will have all the procedures and data from the original class (the base class); 
this is called inheritance. Some of the data structures and procedures are changed 
in the new class, giving its objects different behaviour and appearance to those of 
the original class. 
For example, Button is derived from a general class of controls called ButtonBase; 
Button has all the features ofButtonBase but modifies and extends them to produce 
a variety of buttons. ButtonBase is, in turn, derived from System.Windows.Forms. 
Control. 
Similarly, RadioButton and CheckBox are derived from ButtonBase and result in 
buttons that have a slightly different appearance and behaviour. 
TextBox and RichTextBox are both derived from System.Windows.Forms. 
TextBoxBase, which is also derived from System.Windows.Forms.Control. 
TextBoxBase modifies the class in slightly different ways to produce text boxes and 
rich text boxes respectively. Therefore, Button, TextBox and CheckBox share 
many characteristics but have their own unique features; this is known as 
polymorphism. 
Most classes in the library are derived from a single class, Control, and together they 
form a class hierarchy. 
. 
. 
&· . •. =-& 
··•·You.can·tin.d out more·ah,ut ally ofthete clns•sbysearching .torctheclass · 
.. ·name ill thfoll~Une help •. ·To ~ee the full cfa;s hierarchy,. search •for 
~Syst~~.Windowc.Forrns r.a~espne'. Full detaUs ·of the hierarchy can h~ 
foundinth• MSQNhelp.t .. NETJ1e\felorer/.NET·framework·SDKI.N.ET•• 
.FrameworkiReference/Ciass ·Libra ry/Ststern~Windows)orrns~ 
· 
~ 
0 
'~ 
' 
' ' 
' 
' ' 
' 
' 
' 
' 
' 
0 
'' " 
, 
49 

Adding controls 
The toolbox 
so 
All windows have one or more controls. These are objects that display information 
or allow the user to perform an action: for instance, buttons, text boxes, option 
buttons and scroll bars. 
Any combination of controls can be placed on a form but you should remember that 
when the application is run the user will be free to use the controls in any order 
(subject to any restrictions you impose at development time). 
For example, the message box that is displayed if you try to delete a form contains, 
in effect, four controls: two buttons (marked OK and Cancel), a label (containing 
the text of the message) and an image control (containing the icon). The program 
forces you to click on one of the buttons but it's up to you which you choose. The 
action taken by the program depends on which button is clicked. (In fact, message 
boxes are created in a special way.) 
Label 
Icon 
Buttons 
Visual Studio supplies a number of standard controls for use on forms. These are 
represented by icons in the Toolbox. Controls can be added to a form in three ways: 
e 
Double-click on the control in the Toolbox to create an object of default size 
in the top left-hand corner of the form. 
e 
Click on the control and then click on the form to create an object of default 
size at that point on the form. 
e 
Click on the control in the Toolbox, then drag the pointer over the area of the 
form to be covered by the control. 
Whichever method you use, you can change the size and position later (see Control 
properties below). The standard controls are described from page 65 onwards . 
Double-click 
here ... 
... to add a 
here 

Control properties 
The appearance and behaviour of a control is determined by its properties, in the 
same way as for a form. The properties include not only cosmetic items -the size, 
colour and position of the control, for example -but also those characteristics that 
affect the way a control is used: whether it is enabled, the user actions that are 
allowed etc. 
The properties are different for each type of control and in each case the system 
provides a default. Most defaults are quite satisfactory so there are usually only a 
very few properties that need to be changed. 
As for forms, you will set the properties when developing the project but they may 
also be changed while the application is running. 
Some properties apply to most or all of the controls - for instance, every control 
has a Name - and most can be changed. The most important properties are 
described below for the standard controls. 
A number of other, more advanced properties are included in most controls and may 
be useful when an application reaches a later stage of development. You are 
unlikely to use these properties often but it is worth knowing they are there. 
Changing properties 
To change the properties for a control, first click on the control so that it is selected. 
Small square 'handles' will appear at each corner and in the middle of each side. 
The Properties window will show the properties for the selected control. This will 
include the name of the control at the top (initially a default name, consisting of the 
control type and a number); you will see the properties that are listed change each 
time you select a different type of control. 
Remember that all controls of the same type will have the same properties but each 
control of that type will be given different settings. Therefore, when you click on 
different controls of the same type you will see the same list of properties but with 
different settings in each case. For example, all buttons have Name, Width and Text 
properties; the settings for one button may be btnOK, 128 and OK respectively, and 
for another, btnHelp, 96 and Help. 
To change the control properties, click on a control and then on a property in the 
Properties window. Then either type a new setting in the right-hand column or 
(where appropriate) select the setting from a drop-down list. 
51 

Sel 
Properties for 
selected 
control type 
Click on control to 
show its properly 
settings 
Settings for 
selected control 
Deleting controls 
52 
To remove a control from the form, click on it (so that square 'sizing handles' are 
shown on the corners and sides) and then press the [Del] key. 

Multiple properties 
You can select a group of controls in one of the following ways: 
e 
Hold down the [Shift] key and then click on two or more controls. Each time 
you click on an additional control, the other selected controls are identified 
with white sizing handles. 
e 
Move the pointer to a blank area of the form and then drag it over the controls. 
Any control that is at least partly covered by the marked rectangle is given 
sizing handles. 
e 
A control can be removed from the group by holding down [Shift] and 
clicking on it again. 
This method is normally used for dragging controls to another part of the form but 
it can also be used for changing the settings for all the marked controls at the same 
time. If you change a setting in the Properties window, the setting is applied to all 
selected controls; for instance, you can change the width of a group of controls. 
Selected 
controls 
·· Yo~rean fhtd .. out what any pr&pertyj$U$edf&r by looklngfor the ·~elevant 
. entry lti the Syttem.Vllndo"s.Formt section hf the .MSDN Jilrary. Ellery 
.. ··~ontrfll)ts. af{ e~tryJn t~e O~:Un~ n•lpl·ghting ano~erview and aUnkto. 
a list. of .an the ~o.ntr&l's members (including the pro~ert~esJ.. .. 
53 

Common properties 
Name 
S4 
A large number of properties are common to all or most controls; these provide the 
basic functionality of the controls. Each type of control has its own additional 
properties, which regulate those features that are peculiar to the control. For 
instance, most controls can have their size and position changed but only a text box 
has a PasswordChar property, which allows the box to be used for entering a 
password. The most useful common properties are described here. 
Every control has a Name, which is used when referring to the control in a 
procedure (for instance, when changing the control's properties at run time). Visual 
Studio gives each new control a default name, consisting of the control type and a 
number: Buttonl, Button2, ... , Textl, Text2 etc. 
You should change these names to something more meaningful. Although you could 
keep the defaults, you should change the Name for all controls, even those you think 
you are unlikely to use in your program. 
The rules for names are as follows: 
e 
Names may consist of letters, numbers and underscore (_) characters; no 
other characters or spaces are allowed. 
e 
Names must start with a letter. You can use numbers or underscores 
anywhere in the Name apart from the first character. 
e 
Upper and lower case letters are treated as being the same but a mixture can 
be used to make the name easier to identify (btnSaveAs is more recognisable 
than btnsaveas but both refer to the same control). 
e 
Names can be any length but for ease of use you should keep them much 
shorter than this. 
To make it easier to identify controls from their names, you should adopt a suitable 
naming convention. A common convention is that the first three characters are 
lower-case letters and indicate the type of control; all buttons begin 'btn', all text 
boxes 'txt' and so on. A suggested naming convention is given in the on-line help. 
If you adopt the standard naming convention, keep to it for all controls. 

You should change the Name for all new controls, even those you think you are 
unlikely to use in a procedure. For instance, labels may originally be fixed but later 
on you may want to vary them when the program is running. 
If you enter a name that is invalid, Visual Studio displays an error message. 
Click to show 
description of 
Clicking on the Details button displays a brief description of why the button is invalid 
-though some descriptions are more helpful than others! 
Detailed error 
description -------
Click Details button aga1n 
to hide description 
ss 

Text 
56 
Many controls have a fixed item of text that appears on the surface of the control: 
for example, buttons, check boxes and labels. The fixed text is held in the Text 
property. The restrictions on the Name do not apply to the Text; this is a purely 
cosmetic piece of text and you can enter whatever you like. 
You can include an & in front of any character in the N arne to denote that character 
as an access key. When there is an access key, the user can 'click' the control by 
pressing [Alt] and the access character together. For example, if the access key 
isS, the control can be clicked by pressing [Alt]+[S]. The access key character is 
underlined in the control's caption. If you need to include an & in the Text itself, type 
'&&';only one & will be displayed. 
Caption: &Start 
Access key: s 
Caption: Option &4 
Access key: 4 

It is usual to select the first letter of the Text as the access key, unless that letter 
has already been used by another control on the same form (in which case you can 
select any suitable character in the Text). 
If two controls have the same access key, pressing that combination will select each 
one of them in turn. However, this is confusing for users and should be avoided! 
Other controls allow users to type an entry. These also have a Text property, which 
holds the user's input. In some cases, you can set a default value for the Text 
property, which is shown when the form is first displayed and which the user can 
then overwrite. For other controls, the Text property cannot be set during 
development but you can change it (and the user can add text) while the application 
is running. 
You can add read-only controls to the 
form (where the user cannot change the 
text) by changing the controls' Enabled 
property to False (see page 64). 
In ea~Her ~ersions of Visual 
Basic~ tke Text ''or&fty was : 
.referrei to as tbf C.attion 
rr.,tertt. 
·· · · · · ···· 
57 

Size and Location 
S8 
The size and position of a control are determined by the same set of four properties 
as for a form: Width and Height for the size, Left and Top for position. As for 
forms, you can enter these properties individually or use the combined properties, 
Size and Location. Left and Top give the position of the top-left corner of the control 
relative to the top-left corner of the inside of the form. 
These properties can be changed either by dragging the sizing handles on the 
corners and sides of the control or by entering new settings directly. Usually, 
dragging the sizing handles is satisfactory, as it enables you to set the size and 
position by eye. For precise settings, however, the values can be adjusted in the 
Properties window. 
The size and location of controls are measured in pixels, as for forms. 
When developing a form there is a background grid of points for aligning controls. 
If you change the control size or position by dragging, the control corners 'snap' to 
the nearest grid points. The grid can be changed (or switched off) by choosing 
Tools I Options and clicking on the Windows Form Designer folder on the left; the 
Width and Height of the grid square can be changed and the grid snap can be turned 
off. 

L--General 
: .... , Fonts and Colors 
1:tJ Projects and Solutions 
tfj .... Text Editor Basic 
l±i 
Fonts 
Spacing of grid 
points (pixels) 
Click to 
turn on 
grid 
stop 
controls 
snappmg 
to grid 
If a control displays text, you can change the appearance with the Font property. 
In the same way as for 
Size and Location, Font is 
actually a combination of 
subsidiary properties. 
When you click on the [±J 
box to the left of the prop-
erty, the list is expanded to 
show the items that make 
up the property. 
When you click on the 
property, a small button 
with three dots appears 
on the right. 
S9 

Clicking on this displays the Font window, from which you can select the font, the 
style (bold, italic etc.) and the point size. You can also apply strikeout (aline through 
the middle of the text) and underline. 
After making the necessary changes in the Font window click on OK to update the 
corresponding settings. 
Tip 
If you click on the Font list 
and mov~ up and down using 
the arrf)W keys, the Sample 
box shows .you wharthe text 
will look· tike. 
. 
· 
60 
.Use oniy the. Standard Windows fonts, so tl.at 
your applicatiora will always look the ume, 
retardless ofthemachirae runnlngJt .. Uyou use 
third-: party fonts~ you must be prepared· 
suppl{these with yo11r application~ 
· 
' 
, ~' '' 

Colour 
The control's background colour is set by the BackColor property. For controls 
that display text or graphics, the colour ofthese is determined by ForeColor. The 
values for colours can be entered in one of two ways: 
e 
Selecting from a palette 
e 
Entering an RGB colour number 
The easiest way to choose a colour is by clicking on the drop-down list in the setting 
box. You can select a colour from one of three tabs: 
e 
The Custom tab contains a grid of coloured boxes. 
e 
The Web tab includes a list of colours that are safe to use on forms that will 
be displayed on the Internet. (Other colours will not necessarily display 
effectively on every Web browser.) 
e 
The System tab lists the colours that are selected on the Windows Display 
Properties dialog. The colours on your application will change according to 
the choices made by the user when setting up Windows. 
When you click on a colour, either the colour name or a series of numbers is entered 
in the setting box. The main disadvantage of these methods is that the range of 
colours is limited. 
ActiveCaption 
causes~' aua.aq~ J__j ActiveCaption Text 
AppWorl<space 
Buttonface 
ButtonHighlight 
ButtonShadow 
ControiDark 
ControiDarkDark 
Controllight 
Controllightlight 
Control Text 
61 

62 
Each colour on the screen is made up of three components - red, green and blue 
-in differing intensities. The colour is represented by a number in the formrr, gg,bb 
where rr is the red component, gg green and bb blue. Each component can have 
a value between 0 (no colour) 
and255 (full intensity). The mid-
point is 128. This is the RGB 
code. 
You can increase the number of 
available colours by entering an 
RGB code directly: 
1 
In the colour dialog, click 
on the Custom tab. 
2 
Right-click on one of the 
blank squares at the bot-
tom of the palette. 
3 
Define the colour either by clicking on the large multi-coloured box or by 
entering specific values for the Red, Green and Blue components of the 
colour. 
RGB values 
Define new 
colour 
shown for setting 

Tab stops and focus 
When the user clicks on a window, the window is said to have the focus; that is, 
it is the active window. The title bar of the window with the focus has a different 
colour to the others. (In the default Windows colours, the window with the focus 
has a blue title bar, the rest are grey.) Only one window can have the focus at any 
one time. 
Similarly, one (and only one) control on the window has the focus. This is usually 
indicated by a thicker border around the control, by highlighting or by the 
appearance of a cursor in text boxes. 
When the user presses the [Tab] key, the focus moves from one control to the next. 
The order in which the focus moves is determined by two properties: TabStop and 
Tablndex. The TabS top setting specifies whether or not the control can have the 
focus (a setting of True if it can), while Tabindex gives the order in which the 
controls have the focus. Each control on the form has a unique tab index number. 
Initially, the tab index numbers match the order in which the controls were added 
to the form. 
To change the tab order, change the Tabindex setting for a control. All the index 
numbers will be updated to take account of the new order. For example, if there are 
four controls on the form, the index numbers will be 0, 1, 2 and 3. To move the last 
control into second place, change its index number from 3 to 1. The system will then 
renumber the two controls in the middle from 1 and 2 to 2 and 3 respectively. By 
changing the tab index for several objects, you can put the controls into any order 
you like. 
num.her hut those ftn which 
fah.Sto.js false are ignored~ 
No two control~ o" a form can 
have the sam.e Tablndex~ 
· Dort't worry about the tabsettings.·.until 
thefor.m. h.c:omplete-the~y.otcan set 
the tabindex.foraH the controls at once, 
when yott hav~ a h~tter idea of the ord.er ·.· 
yotrwant .. 
63 

Visible and Enabled 
64 
The Visible property determines whether the control can be seen and Enabled 
decides whether it can be used. As a general rule, it is less confusing for the user 
if controls are always visible but not necessarily enabled. When a control is not 
enabled (its Enabled setting is False), any text displayed on it is grey and clicking 
on the control has no effect. Naturally, if a control is not visible (its Visible setting 
is False), the user cannot click on it and its Enabled property is irrelevant. 
For example, you may have a Save button on your form that is enabled only when 
new data has been entered in text boxes. (The alternative would be to make the 
Save button visible when a change is made to the data but a button suddenly popping 
up on the window is disconcerting for the user.) 
The Enabled property can also be used for making a text box read-only. If you set 
Enabled to False the user can see the text but cannot change it. 
The Visible property may be used where the value of one control affects the 
applicability of others. For instance, on an accounts form a pair of radio buttons may 
allow you to choose between a payment and a receipt. Other controls on the form 
- such as a text box for the cheque number- will be made visible depending on the 
radio button that is clicked. When the user clicks the payment button, the cheque 
number is made visible; when the receipt button is clicked, the Visible property for 
the cheque number box is set to False while a text box containing the delivery date 
could be made visible 
In another case, a button may be clicked to display additional information in the 
window; when the button is clicked, the Visible property on a text box could be set 
to True. 

Standard controls 
The Visual Studio toolbox contains a large number of standard controls. Click on 
the arrows above and below the list of items to move the list up or down. Click on 
the horizontal tabs to view other lists of components. The diagrams below show the 
full set of controls available for Windows forms. 
The toolbox may show other controls, depending on the Visual Studio version that 
is being run and any controls that have been added. Visual Studio allows you to add 
other controls using ProjectiAdd User Control but the standard toolbox should 
contain enough controls for most applications. 
6S 

Buttons 
66 
To find out more about 
any control, locate the 
relevant topic in MSDN 
help. This displays a list 
of all the control's prop-
erties etc. For a more 
general description, 
click on the Overview 
link atthe top of the help 
page. 
B .NET Framework 
~ 
>·..... 
·~· 
Th~ pointer i~DII at the top of the Windows forms 
Jist]s not a ~ontrol. Click Dn this .h~on when you 
wanfto select an existing .control in order to 
m.ke change~ to the. control' s)roperties. 
' 
0;',' 
' 
' 
Initializes a new instance of the Button class. 
Buttons are used for performing actions. A procedure is attached to each button 
and is executed when the user clicks on the button. You cannot decide the order 
in which buttons are clicked but you do have full control over the action taken once 
the user has clicked a button. 

The text that appears on the surface of the button is held in the Text property. 
Each form has two settings that affect the behaviour of its buttons: 
e 
The AcceptButton property identifies the button that is activated when the 
user presses the [Enter] key; usually, this is the OK button. Select the 
appropriate button from the drop-down list of all buttons included on the form 
so far. 
e 
In a similar way, you can select a button in the CancelButton property; this 
is the button that is activated when the user presses the [Esc] key (usually 
the button for which the Text is 'Cancel'). 
In ea~U~r VJ,Sif)DS of Visual Bade,·. 
b.dtt~ns. w~re known as ':conhn~nd .hut~ ·•. 
Name: btnYes 
Text: &Yes 
Name: btnCancel 
Text: &Cancel 
Labels 
the JeJCt vroperty was> the 
Name: btnNo 
Text: &No 
Form: AcceptButton: btnYes 
CanceiButton: btnCancel 
The label control adds text to the form: titles, instructions, text for data-entry boxes 
and so on. The user cannot do anything with these controls but you may wish to 
change the text itself at run time; for example, after a file has been selected a label 
may be used to display the filename. 
The text of the label is held in the Text property. The position of the text within the 
label area is set by the TextAlign property. 
You can place the text on the left, centre or right of the label area, and at the top, 
middle or bottom. The alignment is chosen by clicking on the setting and then on the 
appropriate grey rectangle on the drop-down box. 
If the text will not fit in the label area, setting AutoSize to True allows the label to 
expand its area if necessary. 
67 

TextAiign: T opCenter 
Font style: Bold 
TextAiign: TopCenter 
Font size: 14 
Font size: 1 0 
TextAiign:MiddleRight 
Font style: Regular 
TextAiign: TopCenter 
style: Regular 
Font size: 8 
Font size: 8 
Text boxes 
68 
Text: calculated at run 
time 
To draw a box around the label, change 
theBorderStyleproperty to FixedSingle 
orFixed3D 
Click for 
TopCenter 
The text box provides the simplest method for the user to enter data. When the 
control has the focus, a vertical cursor is displayed and the user can make an entry. 
The Text property contains the user's entry when it is complete; by setting this 
property during development you can supply a default value, which the user can 
either leave as it is or change. 

By default, the BorderStyle property is Fixed3D, resulting in a box drawn around 
the edge of the text area. Change this to FixedSingle for a simple box or None to 
remove the box. 
The lack of a any sort of fixed text means that text boxes cannot be given an access 
key directly. However, you can get round the problem by placing a label control next 
to the text box; since a label control cannot be clicked, the access key on the label 
acts as an access key for the text box. 
Access key: n 
(for text box) 
MultiLine determines whether text can spread over more than one line. A value 
of True means that text will wrap from one line to the next when the edge of the 
box is reached; a new line will be started when the user presses [Enter]. A value 
of False means that the text always stays on a single line (with long items of text 
scrolling out of view at either end of the box). 
The TextAlign setting places text on the left or right of the box, or centres it. 
The Locked property, if set to True, stops the user from changing the text. 
TextAiign: Left 
Maxlength: 8 
Multiline: False 
TextAiign: Left 
----------..... Maxlength: 0 
TextAiign: Left 
Maxlength: 0 
Multiline: True 
Multiline: False 
69 

MaxLength sets a limit to the number of characters that can be entered in the box. 
For instance, a setting of 8 could be used when entering a password. If MaxLength 
is 0 (the default), the amount of text is limited only by the computer's memory. 
For large amounts of text, where MultiLine is True, you may want to add scroll bars. 
The ScrollBars property can take the following settings: 
None 
No scroll bars. Use this when the amount of text is limited. 
Horizontal 
Horizontal scroll bar. The user can keep typing to the right, 
beyond the end of the box. Use where there are no paragraphs 
(e.g. program code). 
Vertical 
Vertical scroll bar. This is the most useful option, giving a clear 
indication of how much text has been typed and where the cursor 
is, relative to the text as a whole. 
Both 
Both scroll bars. Use this for text that can spread in both 
directions. 
If there is no horizontal scroll bar, the text for a multi-line box automatically wraps 
to the next line when the right-hand edge of the box is reached. However, when 
there is no vertical scroll bar, the text will still scroll upwards when the box is full, 
unless you set MaxLength. Therefore, you should usually have a vertical scroll bar 
for multi -line text. 
The Password Char property is useful when asking the user to enter a password. 
The setting can be any single character (though it is usually*); this character will 
be displayed regardless of what the user types but the actual entry will be held in 
the Text property. 
Radio buttons and check boxes 
70 
Radio buttons and check boxes provide two different methods of giving the user 
choices. 
Radio buttons usually appear in groups of two or more, and all the buttons on a 
form are interrelated (unless they split into groups - see page 72). The control 
consists of a circle with a piece of text next to it. The text is held in the Text 
property. 

The TextAlign property has the same 
options as labels, allowing the text posi-
tion to be set both horizontally and verti-
cally. The Checked property has a set-
ting of either True or False, depending on 
whether or not the button has been se-
lected. Only one button can be selected at 
a time, so when the user clicks on a radio 
button the Value for that button is set to 
True and for all other buttons to False. 
You.· can.· ha~e more than· one 
group of radiC» buttons on . a 
·.· window if you .encl•se them in 
group ho~es :""' see hlilo\11. 
Check boxes work in a similar way to radio buttons, the main difference being that 
they operate independently of each other. As a result, the user may select several 
boxes at the same time by clicking on them - or turn all boxes off. 
The check box has three possible states, defined by the CheckState property: 
Unchecked 
The box is empty. 
checked 
The box contains a black tick. 
Indeterminate 
The box contains a grey tick. 
You can choose any of these values to be the setting that is displayed when the 
program is run. The options available to the user depend on the setting of the 
ThreeState property. When ThreeState is True, clicking on the check box takes 
the user through each of the three states in turn; when False, the box can only be 
Checked or Unchecked. 
:JI 
The ln.determin~te settinfisuselul when options are mandatory.Forinstanee, the choice. 
of an option· button Dlay make .a particular ·check item< essential~ 
.· 
. 
Je ~~ uheckb•~ tamper~rily Uli~Y&ilable, Set iis£ neb led t!:'P~rfy .'• FIISe; H i! l••' · 
disconcerting .for a user to see a cheek hox greyed out t~at for it to disappear completely 
{by setting Visible to false). 
71 

Check boxes: 
Radio buttons: 
Checked: True 
CheckState: Checked 
ThreeState: False 
Enabled: True 
Checked:True __ 
...., 
Checked:False 
CheckState: Unchecked 
ThreeState: False 
Enabled: True 
Checked: False 
CheckState: Checked 
ThreeState: False 
Enabled: True 
Checked: True 
CheckState: Indeterminate 
ThreeState: True 
Enabled: False 
There is also a Checked property; this is True when CheckState is Checked or 
Indeterminate, otherwise it is False. Changing the value of Checked will affect the 
setting of CheckState, and vice versa. 
At the development stage, you can set CheckState to Indeterminate even when 
ThreeS tate is False. This is useful if an option is to be shown as selected by default 
and you do not want the user to change it. In such cases you will usually also set 
Enabled to False. 
Group boxes 
72 
Group boxes allow you to group con-
trols together. From a functional point of 
view, group boxes are needed if you 
want more than one set of radio buttons 
on a screen. Radio buttons inside a 
group box act independently of any other 
buttons. For this to work, you must add 
the group box to the form first and then 
insert the radio buttons within the bor-
ders of the group box. 

Select 
Select box 
independ-
ently of 
others on 
form 
Greyed 
boxes cannot 
be selected 
(Enabled = 
False) 
Select 
exactly one 
button from 
this group 
Group boxes can also be used to improve the appearance ofthe window. Apart 
from radio buttons, any other group of controls can be placed within a group box, 
though this has no effect on the way they function. 
The group box Text is the piece of text overlaid on the top left-hand corner of the 
group box . 
. ·· Th~ b.ttantrot~;f~e dt~wn withitl····· 
· 
t~; gr~lp· &ox ~oraer~:. ~~~ rrlu.ct 
·~t..t·h~create .)he·•·~utt!nsby 
do~thl~~cU~king on fh~·toolbax · 
.• na.· t~•" draggi.nf t~e·· htiUoils 
insideJthe box~.· .·. 
· 
73 

Scroll bars and progress bars 
Scroll bars (HScrollBar and VScrollBar) frequently appear on text boxes but you 
can also add them in other places. They can be added on their own (for instance, 
to indicate the progress of some activity or as an alternative data entry method), 
though standalone scroll bars tend to look rather peculiar. More usually, they can 
be attached to the edge of windows (for instance, one displaying part of a bitmap). 
In such cases, the properties are usually set while the program is running. 
The Minimum and Maximum properties give the limits of the values that can be 
represented by the scroll bar; the Value represents the current position of the button 
on the scroll bar, as a proportion of the distance from one end of the scroll bar to 
the other. For instance, suppose that Minimum is 100 and Maximum is 200. When 
the button is at the top (or left) of the scroll bar, the Value is 100; when at the other 
end, the Value is 200; and in the middle of the bar, the Value is 150. 
SmallChange specifies the amount by which Value will change when an arrow at 
the end of the scroll bar is clicked; LargeChange gives the change in Value when 
the bar itself is clicked (between an arrow and the scroll button). 
In the illustration below, two procedures are used: the first sets the Text value of 
the text box to the scroll bar Value when the scroll bar is ad jus ted; the second revises 
the scroll bar Value (and hence the position of the button on the scroll bar) when 
the Text in the text box is changed. Information on procedures is given in Chapter 
4. 
Click to decrease 
Value by SmaiiCh 
Click to. decrease 
Value by LargeChange --.....: 
Drag to vary 
Value by any 
amount 
Click to increase 
Value by SmaiiChange 
74 
SmaiiChange: 1 
LargeChange: 5 

The TrackBar is the modem equivalent of the standalone scroll bar and is the 
standard control for tasks where a value must be selected from a range. The bar 
has a set of marks on a horizontal scale, with a button indicating a proportion of the 
maximum value (for instance, the volume level in a music program or the proportion 
of a task that has been completed). 
The control has Minimum, Maximum, SmallChange, LargeChange and Value 
properties that are identical to those of the scroll bars. 
The Orientation property determines whether the track bar is Horizontal or 
Vertical. The TickFrequency lets you set the number of ticks on the scale. 
Group box 
Minimum: 0 
Maximum: 120 
Value: 25 
Tickfrequency: 5 
The ProgressBar is another similar con-
trol but is used for informing the user 
rather than giving the user the ability to 
make changes. The control has Mini-
mum, Maximum and Value properties 
that specify the range and determine the 
current value within the range. The pro-
portion represented by Value is indicated 
by coloured blocks that advance from left 
to right. 
15 

76 
The NumericUpDown control provides a way for the user to select a value in a 
range, where there is no necessity to change the value from within the program 
(though, of course, you can do so if you need to). The control consists of a box 
displaying a numeric value, with up and down arrows to the right. Clicking on the 
arrows increases or decreases the value. 
The control has Minimum, Maximum and Value properties, with Value usually 
determined by the user. The setting that you give to Value at the design stage is the 
number that is displayed initially. 
1he DecimalPlaces property allows you to specify decimal values, with the 
Increment setting giving the amount by which the Value changes with each click 
of the arrows. For large numeric values you can specify that ThousandsSeparator 
is True, so that the thousands are separated from the last three digits by a comma 
(or whatever character the user has selected on their Windows Regional Options). 
The size of the text (and hence the height of the box) is determined by the Font 
property; you can set the Width to any value. 
If ReadOnly is False, the user can type a value in the text box (which has a white 
background); if True, the user cannot enter a value directly and the box is grey. 
Minimum: 0 
Maximum: 60 
Value: 16 
Increment: 2 
TextAiign: Center 

Other controls 
In addition to the simple controls described above, there are a number of other 
standard controls on the toolbox: 
e 
The picture box control allows you to add bitmaps; picture boxes also 
provide simple drawing facilities (see page 274). 
e 
The timer lets you generate events at predefined times. (Add the control to 
the form and then set the Interval between timer events, giving a value in 
milliseconds.) (See page 281.) 
e 
List boxes, checked list boxes and combo boxes allow you to choose 
from lists. Variations are provided by list views and tree views (see page 
99). 
e 
A number of controls provide standard Windows dialogs, such as those for 
opening files, saving files, changing font or colour, or accessing the printer 
(see page 244). 
In addition to these, there are many other controls for performing more specialised 
tasks. Some of these are supplied on the Toolbox tabs; many others are available 
from third-party suppliers. Additional controls are added with the ProjectiAdd New 
Item option. 
Re-running the application 
Try out some of these controls (examples are given over the page). You can see 
what your application will look like by pressing [FS] to run it. Clicking on a button 
won't do anything but you will see the button change as it is clicked. You can click 
on a radio button, and check boxes can be switched on or off. 
Always save the project before running it. Occasionally, the system may 'hang' but 
providing you have saved your work, this should not be a problem. Remember that 
you can get out of an application by switching to Visual Studio and selecting 
Debug! Stop Debugging. 
By this stage you should be able to create a fairly impressive 'front end' to your 
application- all without writing a line of code. Now, to make the windows and 
controls respond to the user's actions, you need to start adding program code. 
77 

Exercises 
78 
1 
Add labels and but-
tons to the front-end 
form, as shown here. 
The Exit button should 
be set up so that it is 
activated by pressing 
the [Esc] key. 
3 
Add controls to the 
Details form. 
• 
• 
2 
Create a password form. When text is 
typed into the text box it should show 
as asterisks. 
4 
Add a text box and buttons to the 
Comments form. 
5 
Save all files and test the application. (At this stage only the front-end 
window will be displayed and the buttons will be ineffective.) 
For solutions to these exercises, see page 295. 


The event-led environment 
In traditional programming languages, the programmer is in complete control while 
the program is running. The program consists of a linear sequence of coded 
instructions, with branches to particular points in the program. At each stage of the 
program, the user is offered a limited number of options and the program branches 
to the relevant section of code, according to the choice that has been made. If the 
code has been written correctly, there should be no surprises. 
Windows programming languages, such as Visual Basic, start from a very different 
viewpoint. At any one time there will be many objects on the screen: windows, 
buttons, menus, text boxes and so on. The user is free to click, drag or type on any 
object and, in most circumstances, is not constrained to follow a linear path through 
a fixed sequence of actions. 
This event-led environment requires the programmer to take a completely new 
approach. Rather than trying to confine the user to a limited number of actions, the 
programmer must create an application that reacts correctly to whatever the user 
does. This is not as daunting as it sounds; there are, of course, ways oflimiting the 
user's scope (for example, making forms and controls invisible or greying out check 
boxes) but the simplest action is to do nothing. 
Form name 
Object name 
Event 
Code 
Procedure for 
object/event 
(see page 85) 
Dirr1 frmvCompanyMenu As New frmCompanyMenu 
frnwCompanyMenu. Show () 
End Stili 
80 

For each object on the screen there are a number of possible events. Some of these 
are generated by the user: for instance, clicking or double-clicking the mouse-
button, dragging an object across the screen or pressing a key. Others arise as a 
result of some other event occurring in the system: for example, a window opening 
or closing, a control getting or losing the focus, or the system time reaching some 
predefined value. You can also force an event to occur by including suitable 
instructions in your program. 
The code to respond to these events is contained in Visual Basic procedures. For 
any object, there is a procedure for each possible event; initially, every procedure 
is empty, so nothing happens when the event occurs. Theoretically, you could 
create a procedure for every event but in practice you will only fill in the procedures 
for those events that are of interest. 
For example, a button's events include being clicked, getting and losing the focus, 
and the mouse button being pressed and released. However, you may only want to 
provide code for the Click event; any other events would be ignored. 
User clicks 
button 
1 
Windows changes 
appearance of button 
1 
Programmer's 
Click event 
is executed 
t 
Click 
Private Sub btnExit _Click (ByVal sender .As System. Object, ByVal e As System. Event 
Me. Close() 
End Sub 
··End Class 
81 

Each event results in some action being taken by Windows itself. For instance, 
clicking on a button causes it to change its appearance while the mouse button is 
held down; clicking on a window's Minimise button reduces the window to an icon. 
These actions are encapsulated in the objects' definitions; they are part of the code 
that you get when you choose those objects. 
In these cases, you cannot alter the object's behaviour but you can add to it; for 
example, you may activate a new form when the command button is clicked or 
display a message when a form is minimised. 
Therefore, the next task, after creating the user interface, is to decide the events 
that are to be handled and create the appropriate procedures. 
Common events 
82 
A number of events are common to most of the standard Visual Basic controls. 
(This is because of the way objects are related, allowing behaviour in one class to 
be inherited by those classes that are derived from it.) 
A brief description is given here but for a full list of events view the relevant topic 
in the MSDN library. This contains a help page listing all an object's members: the 
properties, events and methods (described on page 95). The first item in the list is 
the Constructor, a special method that is used to create an instance of the object. 
Next come all the object's properties, followed by the methods and then the events. 
For a full description of any event, click on the event name. 

Public Constructors 
·,4PButton Constructor 
Supported by the .NET Compact Framework. 
Public Properties 
~Accessib!eName (inherited from Control) 
~AccessibleRole (inherited from Control) 
. ~~' 
~-······~--~" ~ 
~AilowDrop (inherited from Control) 
~Anchor (inherited from Control) 
Click to v1ew 
full details 
(inherited from Contro 
Property 
description 
Initializes a new instance of the Button class. 
Gets or sets the background color for the control. 
Property Value 
List of object 
members 
A Color that represents the background color of the control. The default is the vah,Je of the 
DefaultBackColor property. 
Remarks 
The 8ackColor property does not support transparent colors unless the 
ControiStyle:-;.Support:s:TransparentBackColor style bit is set to true. 
The 8ackColor property is an ambient property. An ambient property is a control property that! if not set1 
is retrieved from the parent control. For example! a Button will have the same 8ackColor as its parent 
f.Qt:..ID by default. For more information about ambient properties! see the AmbientProperties class or the 
Control class overview. 
Notes to Inheritors: When overriding the BackColor property in a derived class! use the base class's 
Back Color property to extend the base implementation. Otherwise! you must provide all the 
implementation. You are not required to override both the get and set accessors of the BackColor 
property; you can override only one if needed . 
. NET Compact framework Platform Note: Version 1.0 of the .NET Compact Framework provides 
support for the BackColor property (inherited from the base Control class) for the following controls: 
Control, System.Windows.Forms.DataGrid! form! Panel! TabPaqeJ and TextBox. 
The BackColor for CheckE:'.ox! Label, PictureBox! R.adioButton! and TrackBar is transparent by default. 
In addition! the .NET Compact Framework Service Pack 2 provides BackColor support for the following 
The Click event is generated when the user clicks the mouse button with the pointer 
over the object; DoubleClick occurs when the user double-clicks. For a button or 
radio button, the Click event is also generated if you set the Value property to True 
within the program; for a check box, the Click event occurs if the program makes 
any change to the Value property. The DoubleClick event is not available for 
buttons. 
83 

84 
Press and 
release 
Click I 
Press ... 
MouseDownj 
. .. and release 
l 
MouseUp 
Sometimes, you may want to split the Click event into its two component parts: 
MouseDown and MouseUp. For instance, you may want to change the appear-
ance of a control when the button is pressed and restore it when the button is 
released. You also need to use these events to find out which mouse button was 
pressed and whether the [Shift], [Ctrl] or [Alt] keys were also pressed. (The Click 
event provides no extra information.) 
The MouseMove event occurs when the pointer passes over the top of the object 
(useful for changing the appearance of the pointer at different places on the 
screen). DragOver occurs when an item is being dragged over the object and the 
DragDrop event is generated at the end of a drag operation when the mouse button 
is released. For these drag operations you can determine what object was being 
dragged, and take the appropriate action. 
GotFocus and LostFocus occur when a control gets or loses the focus, 
respectively. GotFocus can be used to set initial values, while LostFocus is useful 
for checking the user's input. For example, you might use GotFocus to give an 
empty text box a default value and then test the user input with LostFocus; if the 
entry is invalid, the cursor can be put back into the text box by giving the text box 
the focus again (but make sure the user does not get stuck in a loop!) 
In some circumstances you may want to test for keyboard activity. KeyPress 
occurs when a key is pressed; this may be split into the KeyDown and KeyUp 
events. 
You can also find out what the user has been doing by writing a procedure for an 
object's TextChanged event. This event occurs whenever the value of a label or 
text box changes. Similarly, CheckedChanged is generated wherever there is a 
change to a check box or radio button. 

Creating a procedure 
Object box: 
Procedures are created in a tab on the Visual Studio window. This tab is displayed 
either by clicking on the View Code button in the Solution Explorer window or, more 
simply, by double-clicking on either a control or a blank part of the form. The Code 
window has two list boxes below the title bar: 
e 
The Object box on the left shows the current object (the form or a control). 
e 
The Procedure box on the right shows the event being coded. 
You can choose a new object and event at any time; when you do so, the procedure 
code for that object and event is displayed. 
Every procedure must have a name that is unique within the form. Event-driven 
procedures are named for you, the name consisting of the object name, an 
underscore and the event name. For instance, the procedure corresponding to the 
Click event for a command button called 'btnExit' will be named 'btnExit_Click'. 
The procedure is written in the format: 
Private Sub object_event(parameters) Handles object.event 
statements 
End Sub 
The first and last lines are provided for you; all you have to do is fill in the statements 
in the middle. When the event occurs, the procedure statements will be executed. 
For example, when the user clicks on the Exit button the btnExit_Click procedure 
is executed. 
Enter 
Procedure 
Procedure box: 
ByVal e As System. 
85 

86 
Do not change the parameters for event procedures. The Handles part of the 
statement tells you the object and event to which the procedure applies; if you 
rename the object the Handles part is updated so that the procedure still works, even 
though the procedure name (object_event) no longer describes the object accu-
rately. 
There is a block of code at the top of the tab that defines the form itself. You can 
view this code by clicking on the !±I button on the left but you must not make any 
changes to it. Looking through the code, you should be able to identify the 
instructions that correspond to the changes you have made to the form and control 
properties. You should also see the lines of code that add the buttons to the form. 
Form Designer generated code 
'~ 
Public Sub Ne.r () 
MyBase. Ne.r () 
j This call is required by the '&Jindou:rs For:ro Designer. 
InitializeComponent() 
lAdd any initialization after the InitializeComponent() call 
End Sub 
l Form overrides dispose t.o elean up t.he component. list .. 
Protected O"..rer loads Cr"..rerrides Sub Dispose (ByVal disposing As 
Boolean)~ 
If disposing Then 
If Not. (components Is Not.hing) Then 
components.Dispose() 
End If 
End If 
MyBase.Dispose(disposing) 
End Sub 
1 Required by the Xilindor.Js Fonr1 Desi.gner 
Private components As System. ComponentModel. !Container 
I ~HOTE: The follOJ:(fing procedure is required by the rJindOl(fS 
~It can be :modified usJ.nq t.he 'bTi:ndows Forrr'l Desi1Jner. 
1 Do :not roodify it. using th.e code edit:.or. 
Public lJithEvents btnExit As System.lJindo.rs.Forms.Button 

This demonstrates the principles of object-oriented programming. The form you 
have created is a new class, based on the standard Windows form class. The new 
class inherits all the behaviour of the original class. The instructions in this block 
extend the standard form by adding controls. These controls are themselves based 
on the standard controls and therefore inherit their behaviour: the changes to the 
properties then modify the new controls. 
Displaying a form 
The following example demonstrates the code needed to display a form. The code 
assumes that one form contains a button named btnDisplayCompanyDetails and 
that there is a second form named frmCompany Details. Clicking on the button 
displays the second form. 
TodothisyouneedaddonlytwostatementstothebtnDisplayCompanyDetails_Click 
procedure: 
1 
Display the first form and double-click on the DisplayCompanyDetails 
button, so that the code tab is displayed. 
2 
In the blank line in the middle of the procedure type: 
Dim frmvCompanyDetails As New frmCompanyDetails 
frmvCompanyDetails.Show() 
Press [Enter] at the end of each line. Visual Studio tidies up whatever you 
have written, capitalising words as needed and standardising the spacing. 
The meaning of these statements is given below. 
[?~.~~t······ 
... ~ 
As you typ.e a litte Visual St~aio trie.$ to help 
tiy displayi~g a pop-up .box with pG$$ible ways 
.to eompl•te th• $fatemut~ You· t;an.ac.eept·. 
.on~ ~f them ~y eli.ekit~g on it and prenh•g> · 
.. is getlerated by 
clickir~g the button; tabbi~g to:th• 
bu~tort and· pressi~g the spacebar; 
. of pressing [Enter] {when this Js 
·the form's. ·Accept Button} ·••• 
[Tab]. 
87 

Pr: i vat.e Sub btnD isp layCompanyDetai ls _ C 1 ick ( ByVal sender: As System. 
Dim frmvCompanyDetails As Ne>r frmCompanyDetails 
fr:mvCompanyDetails.Sho>r() 
End Sub 
End Class 
3 
Press [Ctrl-S] to save the changes. 
4 
Press [FS] to run the application and then click on the Display Company 
Details button. The Details form is displayed. 
5 
Select Stop Debugging from the Visual Studio Debug menu to close down 
the application. 
You can switch between the design page and code page for a form at any time; 
simply click on the appropriate tab at the top of the Visual Studio window. The 
design page is identified by [Design] in the tab name. Forms and code pages that 
have not been saved have an asterisk after the name in the tab. 
Form display statements 
88 
When you create a form in Visual Studio, you are actually defining a new class 
rather than an object. The new class is based on the standard Windows form class. 
The window object is created at run time from inside your program. 
The first statement above defines a variable to represent the new window. 
(Variables are described in Chapter 5.) The variable is of type frmCompany Details, 
indicating that it represents a new window object of that class. (The new window 
is an instance of the class.) 
The second statement uses the Show method to display the window. (Methods are 
described below.) The method is defined in the standard Windows form class and 
therefore inherited by frmCompanyDetails. 

Using and changing properties 
You can make use of a control's properties when writing a procedure. You can also 
change most of them. The instructions to change a property must be in the format: 
control.property = expression 
Control is the name you have given to the object, property is the Visual Basic 
property name and expression is any valid Visual Basic expression (such as a piece 
of text or an arithmetic calculation- see page 120). 
Text properties 
Properties such as Text and PasswordChar can only be assigned text expressions. 
The expression must consist of a text string (an actual piece of text in double 
quotes), another text property or a combination of the two. Items of text are 
combined using the ' & ' symbol. 
For example, the text for a label called lblMessage can be changed with a statement 
such as: 
lbiMessage.Text = "Please enter a value" 
Any piece of text must be enclosed in a pair of double quotes. Similarly, the same 
message can be cleared by assigning the null string to the Text: 
lbiMessage.Text = "'' 
A text box can be given a default value with a statement such as: 
lbiCountry.Text = "UK" 
You can refer to an existing property by including it in the expression. For example, 
if a name is entered in a text box, the LostFocus event for the text box could be used 
for displaying the name in a label as follows: 
Private Sub txtName_LostFocus(parameters)_ 
Handles txtName.LostFocus 
lbiAnswer.Text = "Your company name is " & txtName.Text 
End Sub 
When the user tabs to another field, the label is updated. 
89 

You don't need to worry about what the text looks like as you type it. The code editor 
indents the code for you and puts spaces around the = sign; it also capitalises the 
names to match those specified in the Name properties. You may want to insert a 
blank line above and below the code statements to make the code easier to read 
(e.g. below the Private Sub line and above End Sub). 
Type entry in 
text box ... 
... and label is 
updated when 
you press [Tab] 
... . 
.. 
the 
pro;eedt~re, 
louhfe-click o~ the. texf 
box, then sel~ct lastfocus 
Numeric properties 
90 
Most properties have numeric values; for instance, Height, Width, Left, Right, 
MaxLength and SmallChange are all numeric properties. These must be assigned 
numeric expressions, consisting of numbers and other numeric properties. 
For example, the following statement changes the size of a command button: 
btnOK.Height = 40 
btnOK.Width = 1 00 
(Sizes are in pixels- see page 31.) 
A text box can be expanded or contracted to fit the inside of a resizable form as 
follows: 
txtCoDesc.T op = 0 
txtCoDesc.left = 0 
txtCoDesc.Height = Me.Height - 64 
txtCoDesc.Width = MeWidth - 8 

The Height and Width properties give the total dimensions of the form, including the 
title bar and borders; when setting the height of a control you should always allow 
for the depth of the title bar. (In the example above, 24 pixels have been allowed 
for the title bar and 8 pixels for the vertical borders of the window.) 
T 
Me. 
Height 
_j 
txtDesc. Widt 
I· 
h 
~1 
(Text box dimensions 
before procedure is run) 
Me.Widt 
~---------------
h 
----------------~ 
I 
txtDesc.Height 
The word 'Me' is a shorthand way of referring to the current form. Although you 
could specify the variable that holds the form (e.g. frmvCompanyDescription) it is 
quicker to use just 'Me'. This also has a number of other advantages: 
e 
The code is easier to read. 
e 
If you change the form name, the code will still be right. 
e 
You can copy a set of instructions from one form to another without having 
to revise the form name in each instruction. 
If the statements above are included in the frmCompanyDescription_Resize 
procedure, the text box will always fill the full width of the window, leaving an area 
at the bottom for the two buttons. 
91 

92 
Private Sub frmCompanyDescription_Resize(ByVal sender As Object, B 
txtCoDesc.Top = 0 
txtCoDesc.Left = 0 
txtCoDesc. Height = l~e. Height -
6'1 
txtCoDesc.Width = Me.Width- 8 
btnSave.Top = Me.Height -
56 
btnExit.Top = btnSave.Top 
btnSave.Left = Me.Width I 2 - 55- btn5ave.Width 
btnExit.Left = Me.Width I 2 +55 
End Sub 
If you add buttons to the form, you can ensure that they always stay in the same 
relative position even when the form is resized. For example, suppose that you have 
two buttons named btnSave and btnExit. Their positions and sizes are determined 
by the Top, Left, Height and Width properties. 
The position of the buttons can be maintained, relative to the bottom of the form, 
with the statements: 
btnSave.Top = Me.Height .,... 56 
btnExit.Top = btnSave.Top 
The horizontal positions of the buttons can be kept constant relative to the centre 
of the form with the statements: 
btnSave.Left = Me.Width I 2 - 55 - btnSave.Width 
btnExit.Left = Me.Width I 2 + 55 
The use of the'/' symbol for division is explained on page 121. 
Using statements such as these, you can keep full control over the appearance of 
the form regardless of the user's actions. 

Me. Height 
2~ 
B=f 
32 
~· 
~ 
b~T~~e·+ss+ss~ 
1,. 
Me .Width /2 
~~ 
.. 11te pecitiius ~rai window is>ntt usually .important; as the user is free fo· > 
.<WOVe it aro-.nd at any t~nl·~ "owever, U is fledh ,ttting the pasH~on of 
the of1e~ins.screen so thaJ.lfgi:ves.the.right. intpre~~ion. when firsflo~ded.· 
·· You .• tlsowantto· ensure th•~·th~ .window stays ,. t.he. screen. Remember 
.. .Jhtt~ereen tile Will Varf fr(Un ~ne COIJJputer to A nether ,and some. sc re~ns ·. 
lf:Jty haVe a Snt~ljer display thar(th~ rriuftine 0. Which the;program i. h.eing· 
id~velop&d. · ···.·.· 
· 
·· ·· 
· · 
· 

Boolean properties 
A number of properties can take a Boolean value: True or False. In such cases 
you can either assign values of 'True' or 'False' (without quotes) to the properties, 
or give them numeric values. A value ofO (zero) is treated as False; any other value 
is regarded as True. (True and False are Visual Basic constants, whose numeric 
values are fixed. In a numeric expression, True is evaluated as -1.) 
For instance, a button can be greyed out with the statement: 
btnPostcode.Enabled = False 
When this statement has been executed, the button's caption will be greyed out and 
clicking on it will not generate a Click event. 
Properly references 
Although most references to properties are in the form control.property, there are 
some variations. 
As shown in the example above, you can use the word 'Me' to refer to the current 
form, rather than a specific control. 
Within a form's procedures, you can omit the object name completely when 
referring to the form. For instance, the following two statements are identical: 
Me.Height = 100 
Height= 100 
However, it is less likely to lead to confusion if you always use 'Me' when referring 
to the current form's properties. 
All objects are assumed to be on the current form unless specified otherwise. You 
can refer to objects on other forms by prefacing the control name with the form 
name. 
For instance, the following statement disables a button on a frmvSaveData form: 
frmvSaveData.btnSave.Enabled = False 
(This instruction must appear in a procedure in which the form variable, 
frmvSaveData, has been defined.) 
Using the full name you can access the properties for any controls or forms included 
in the project. 

Methods 
Each object has a number of methods available. These are internal procedures, 
which can be executed from within a normal procedure. The methods are used for 
performing some action on the object. For instance, a text box has a Focus method, 
which moves the focus to the text box. 
The methods are part of the definition of the class from which the object is created. 
Therefore all objects from the same class have the same set of methods. Some 
methods are inherited from classes higher up the class structure and therefore 
appear in several classes; for example, the Focus method applies to all selectable 
controls but not to non-selectable controls (such as Label and GroupBox). 
To execute one of these methods, it must be specified in the format: 
object. method 
For example, if a value is required for a particular text box you can force the user 
to make an entry with an instruction such as: 
txtCompanyName.Focus() 
As for properties and events, the methods available depend on the type of object. 
An object's methods, properties and events make up the object's members. 
9S 

The start-up form 
You can change the first form that is displayed when the application is run by right-
clicking on the project and selecting Properties. Click on the Application tab and 
select a new Startup form from the drop-down list. 
Click on Application tab, 
Click to display list of forms, 
then select start-up form 
Debug 
References 
Resources 
Settings 
Signing 
Security 
Publish 
96 

Displaying otherforms 
When you run an application, the form specified as the Startup Object is loaded into 
memory and displayed as a window. Other forms can be loaded and displayed using 
the Show method. For example, the following procedure loads the Details form 
when the Member Details button is clicked: 
Private Sub btnDetails_Ciick() 
Dim frmvCompanyDetails As New frmCompanyDetails 
frmvCoDetails.Show() 
End Sub 
Remember that when you design a form you are creating a class. Running the 
procedure above results in an object (the window) being created from that class. 
On the other hand, when you add a control to a form at the design stage, you are 
adding a specific object (based on the control's class). 
The statement containing 'New' loads a windowinto memory but does not display 
it. Therefore when the new window has been created, you can carry out other 
instructions on it before you use the Show instruction. For example, you may want 
to set the size of the window or decide which of its controls will be visible and 
enabled. 
Note that the Show method has the same effect as setting the Visible property to 
True. 
Hiding and unloading forms 
A form can be hidden again with the Hide method; for example: 
Me. Hide 
This is the same as setting the Visible property to False. 
After a form has been hidden, it is still held in memory. To free the memory used 
by the form, use the Close method; for example: 
Me.Ciose() 
This statement removes the form from the screen, then deletes the form's data from 
memory. Just before a form is unloaded, its Unload event is executed. The Unload 
event is also executed when the window is closed in any other way: double-clicking 
on the Control-menu box, clicking on the Close button or selecting the Visual Studio 
DebugiStop Debugging option. 
97 

Unless y&u W$nt . a 
. H you unload t&e<d~r.t:-up lortr~, . .... . .... 
appUcation ~·~ul(b~ ~losed down and all other 
forms shotdd also be closed. (Jhe·.Unload event· . 
.. should he encuted tor> each &ne.) To make s_.re 
you f:atch aU tlte po~siMe exlfpoirlts, the Close 
remain availibte to the uset,lri- . 
elude a Cl&se statement in the 
.. ·Click el/ellt for eaclt ftrm' s 'etit' 
button1 (e•9· OK and Cancel). 
This eu$~tes that unw~nterl win;; 
···statements tilrotherformsshoutd be iru:luderl in 
the dart;;up form'~ Unload evenftro¢edure. 
· dows are not leftcfutterhrg up the 
Collections 
98 
Visual Basic makes extensive use of collections. A collection is simply a set of 
objects. For example, when you add a list box to a form, the items in the box make 
up a collection. 
Similarly, you can have a collection of objects. For instance, every form has a 
Controls collection that contains all the controls you have added to the form. This 
provides you with a means of inspecting and changing the objects on the form. 
Collections have properties themselves and these tell you about the collection as a 
whole. Most importantly, a collection' sCountproperty tells you how many objects 
there are in the list. 
For example, collections are used for storing the items are shown on a list box, as 
descibed below. 

Lists 
List boxes 
Several types of control are used for selecting an item from a list. The choice of 
control depends on the options you want the user to have. 
The list box allows the user to select from a list of options. The box consists of a 
rectangle containing a list of items, with a vertical scroll bar on the right-hand side 
(if the list is too long to fit in the box). The size of the box is specified when you add 
it to the form (though you can change this by varying the Height and Width 
properties while the program is running). 
You can specify the contents of a list box at design time using the Items property. 
This property holds the Items collection. The collection is a list of items that appear 
in the list box. 
Clicking on the button on the right of the Items property allows you to edit the list 
in the String Collection Editor. Type the items to be included in the list, pressing 
[Enter] after each one. 
Note that the collection has its own properties and methods. 
99 

100 
Items in list collection will 
appear in list box at run-time 
Alternatively, items can be added to the list at run-time (for example, in the form's 
Load procedure) using the Add or Insert methods of the Items collection. These 
take the forms: 
listbox .ltems.Add (listitem) 
listbox.ltems.lnsert(index, listitem) 
The listitem is the text item to be added to the list; index specifies the position for 
the new item in the list (starting at 0 for the item at the top of the list). 
For example: 
lstT ypes.ltems.Add ("France") 
lstTypes.ltems.Add(3, "Germany") 
The first statement adds the item 'France' to the bottom of the list; the second 
statement adds 'Germany' as the fourth item in the list. 
As an alternative to specifying the index number, setting the list box's Sorted 
property to True sorts the list items in alphabetical order. 

When a list box has been filled: 
e 
The Selectedlndex property 
returns the index number of 
the item that is currently high-
lighted. If no item is currently 
selected, Selectedindex is -1. 
e 
The Text property contains 
the text of the selected item. 
e 
The ltems.Cm,mt property gives you the number of items in the list. 
e 
The ltems.Item(index) property returns the item with the given index 
number. 
These properties are available only at run-time. 
An item can be removed from the list using the ltems.Remove and 
ltems.RemoveAt methods, which take the forms: 
listbox .Items. Remove .listitem 
/istbox.ltems.RemoveAt(index) 
For example, the first statement below deletes 'Italy' from a list box (named 
lstTypes) and the second deletes the fourth item in the list: 
lstTypes.ltems. Remove(" Italy") 
lstT ypes.ltems. RemoveAt(3) 
,t:ok~. ri:otei . ' 
. 
f~,~-~~.:~~~·;i~.a ••••irv•·lff~·~on~. g~t ~~.~~• ~~i~ · 
lid Hefil·exactly' ritht, it ,wiff not, be temo~•• from ,t&eHsJ.···•· 
· 
,,, 
' 
' 
" 
,' 
' 
''' 
' 
' 
'~'' 
-~~ '<~ 
' 
: s 
,_~~-
''"'; ','~:',:,:: 
····T·k~··Bari ifusillg}hei.4ex numbe,tfo.r~moi~,ltems •.. Remembit~thafevery 
timayoq remo\li a.JJ.it.rn,.theJ~~·x numbers Viill•cha"~'fot:afl Hsi.it~ms 
'Jhjt, fotlewed t&e delete4 We~: 
, .. · · · 
··· ·· .· 
· , · · ' 
101 

SelectionMode allows you to select more than one item in the list. The property 
can take the following settings: 
None 
One 
MultiSimple 
MultiExtended 
No items can be selected. 
Only a single item can be selected (the default setting). 
Several items can be selected. Clicking on an item selects 
or deselects it. 
A series of items can be selected by clicking on the first 
item, holding down [Shift] and clicking on the last item. 
Individual items can be selected by holding down [Ctrl] 
while clicking. 
The Multi Column property determines whether the list appears in a single column 
with a vertical scroll bar (False) or is divided into as many columns as are necessary 
to fit all the entries into the height available (True). For multi-column lists, you may 
need to set the HorizontalScrollbar property to True. The width of each column 
is determined by the Column Width property; leave this as 0 if you want the 
columns to be given the default width. 
If you want the list to display only whole items, set IntegralHeight to True; the 
box will be resized vertically so that it fits an exact number of items. 
The procedures below illustrate the selection of a country from a list. 
List box- filled 
when form is 
loaded; 
Sorted = True 
Click to 
update 
label 
item to activate 
btnSelect Click 
procedure 
102 
__ 
........ Click to 
unload form 

Country selection 
. Pri~ale ~ull ffJtl~unti')'~Loc.~(~.~L 
· · 
..... · ·.· 
.· ··· Hca~dWes MJIC.Se.LoCic:l 
.· 
··. ·lsfCountries.ltems.~~dd(uFrance11) • .• 
JstGountries.lferns .Ad df'Ger~any") 
lstGoul]tries.ltenis .Add{'HoiJo nd'')·· 
lstQountries.lferns:Add(111tollQ. · ..... ·.··· 
lstCoUntrle,s: ltems.Add["Sweden1') • 
lstCountries.lterns.Add{"Denmork").····· 
lstGoUDtrie,s.lteyms.Addf'Bel~ ium1') 
. 
. :ltfC6untri~s, Ue~s .. Addf(kuiembourg'') 
.·l~tCounfries.lteh1s;~dd('1Greece"}. 
lstCountries.ltems.Add(''$poin") · · 
JstCountries.ltems~Add(11Portugol'~l 
lstCo~ntries.lt.erns.AdaeEin:t) · · ·· 
I stCovnlries.lterns .Add(I'Austri q") 
lstCo~ntries.ltems.Add("fln lond1') 
lstCountriesJterns.Adde'UK"l 
. 
End Su~ 
... 
..·· 
. 
·. . . ... 
· PriY~te Sub/ lstCc,untrllts.J)~bleC:IIck(•··l­
Hcandles•· ... lstCou•·lfrles.Do.ubleC.IIC:k 
Procedure names 
are highlighted in 
bold text for ease of 
Parameters omitted 
from event proce-
dure headers to 
character is used 
to split a single 
statement over two 
In the example, an item can be selected either by double-clicking on the item or by 
clicking on the item and a button. The use of a button provides a useful alternative 
to double-clicking. It is not a good idea to select an item with a single click, as it is 
very easy to click on the wrong line in a list box. 
103 

Combo boxes 
104 
A combo box is a combination of a text box and a list box. An item can be selected 
from the list either by clicking on an item or by typing an item name in the text box 
at the top of the control. Depending on how the combo box is set up, the user may 
also be able to type new values in the text box; these are then added to the list. Visual 
Basic uses combo boxes in a number of places: for example, the object and 
procedure boxes on the code tab are combo boxes. 
The operation of a combo box is controlled by theDropDownStyle property, which 
may take the following settings: 
Drop Down 
Clicking on the arrow makes the list drop down. An item 
can be selected by clicking or typing in the text box. New 
items can be inserted in the text box. 
Simple 
Similar to DropDown but the list is displayed at all times. 
DropDownList 
Clicking on the arrow makes the list drop down. An item 
can only be selected by clicking on it. 
The properties for combo boxes are similar to those for list boxes but the following 
points should be noted: 
e 
For the DropDown and Simple styles, a TextChanged event is generated 
when the entry in the text box is edited. The Listlndex property is set to 
-1 for new entries. 
e 
When you click on an item in the list, the Click, TextChanged and 
SelectedlndexChanged events are generated (in that order). 
Combo boxes are useful where you want to give the user the option of extending 
the list. They also take up less space on the form than a simple list box. 
Enter a new item 
(Style = DropDown 
or Simple) 
Click to select 
Click to show 
list (Style = 
DropDown or 
Drop Down List) 

Checked list boxes 
The checked list box is a combination of the list box and the check box. The list 
is always visible and each item in the list has a check box next to it. 
The list items are held in the Items collection and, as for list boxes, you can use the 
methods that apply to that collection: Add, Insert, Remove, RemoveAt. 
The check boxes can take values of Checked, Unchecked and Indeterminate, as 
for normal check boxes. 
The list items that are currently Checked or Indeterminate are held in the 
Checkedltems collection, with the corresponding index numbers in the 
Checkedlndices collection. These collections are both members of the checked 
list box. 
You can determine the state of a particular item with the GetltemCheckState 
property, specifying the index number in brackets. For example, to see if the third 
item in a checked list box named clbDays has been selected, refer to 
clbDays.GetltemCheckState(2). 
The example below transfers the contents of a checked list box ( clbCountries) to 
a normal list box (lstCountries) 
Variables are explained in Chapter 5; 'For' loops are discussed in Chapter 6. 
lstSelectedCountries 
list box 
105 

Country selection 2 
PriVate . siJb bblhlect_cnd(c ... ,_ . 
· 
·.Handles btnSelect.CIIck. 
•use vori¢ble inHndex to count thro!Jgh coll~ction 
Oinyintlnd~x .. As Integer ·· 
'Use. variable strChe~keclltem. to hold 
'a spedfic index number 
Dim sfrChe;!cked!tem As String · 
'Seledindex of each checked item in tvrri· ... . .. 
. 
For .Each intlndex In ~lbCountries;Checkedlndices ·. 
'Get item for selected ind.ex humber . 
· strCHeckedltem ;= · dbCountries.ltems.ltem.(intlndex) 
1Add item to list box 
. 
•. lstSelecteclColJiltries.ttems.,Add (sff·C hecked Item) 
Next 
End. Sub 
.... fllr'ivate Su.b btttCiea(~l~k(.~~L 
106 
Handles btnCiear":Cifck 
JOse variable inH~dex to count through coUetfion 
Dim inti As ·Integer 
~ 
. 
. 
'Repeot for. number of items iri list box . 
•· For inH = l.T~ lstSet.ectedCovntries.lt~m~.tou11t 
'Delete first item Jn li~t 
·tstSelectedCpvntries.lterris.RemoveAt(O) 
Next. 
copy across to 
ordinary list those 
that have been 
selected. 
After deleting each 
item from the list, 
next item becomes 
item 0. Other items 
shuffle up 

Dealing with errors 
Error while 
typing an 
instruction 
Various errors may occur while you are creating procedures and running the 
application. 
e 
If you make a mistake while typing one of the program statements, so that 
Visual Studio cannot interpret it, the offending text will be marked with a 
wavy blue line. This may be because you have typed something incorrectly, 
referred to something that has not yet been defined or tried to use an invalid 
object, method or property. You can either make a correction or- if you want 
to leave it as it is for the moment-just move out of the line. In this way, many 
of your typing errors will be picked up as soon as you make them; you will 
also discover many of the errors in your code. 
Private Sub btnSelect_Click(ByVal sender As System.Object, 
1 Use variable int.Index to count through collection 
Dim intindex As Integer 
'Use variable strCheckeditenl to hoJ.d a specif.ic index mrrnber 
Dim strCheckeditem As String 
1 Select index of each ctJ.ecked it.em in tur11 
For Each intindex In clbCountries.Checkedindices 
Next 
End Sub 
'Get. item for sele,ct.ed index number 
strClleckeditem = clbCountries.Items.Item(intlndex) 
'Ac!d i tern to list box 
lstSe lectedCountr ies. Items. Add'·='~,.;~;,;,..,~~=~·" 
Invalid name marked with 
wavy blue underline 
e 
If you attempt to run the application before the error has been fixed, a 
warning message is displayed; click on No to stop the application. The Output 
window shows that the build failed; click on the Task List tab to see what the 
problem is. The line number given relates to the number shown on the Visual 
Studio· status bar when you are editing the code. 
107 

Build error 
message 
Line number on status line 
corresponding to line in code 
Output window 
108 
Error during 
build process 
Click tab to see 
error list 
Line number where 
error has occurred 
e 
If you run the application and an error is found- for example, a statement 
contains a reference to a file that doesn't exist- then a message box will be 
overlaid, specifying the nature of the error. Click on Break; the code window 
will be displayed, with a shaded box around the error. Select DebugiStop 
Debugging to correct the error. 
For more information on handling errors, see Chapter 7. 

Error when 
runnmg 
program 
End Sub 
Shaded box 
around line 
caus1ng error 
P~ivate Sub btnLoactFile_DoubleClick( 
Dim intCountl As Integer 
D in1 intCount2 As Integer 
intCountl = clbCountries.Iterus.Coun 
intCount2 = lstSelectedCountries.It '---------~~....,--~= 
txtProportion.Text = intCountl I 
End Sub 
Class 
Possible actions 
Suggestions for 
possible causes or 
where to get help 
Visual Stud h) finds a If th• obyituls ~rrors hut if you ty~e an incorrect 
· instrtlctionJhat i$ vaiid, Visual Basic wiU attempt to execute it.. For 
indance, il fou ~Jve all inst~•ction lo shovi the wrong form, that form 
will be displayQdi VlsuafSt.udio~as no way of ident.ifyh•s. er.rors in your 
logic or in the ass~mptions y~u ~ake; · · · 
· · 
109 

Executable files 
110 
Up until this point, the program has been run from within Visual Studio by pressing 
[FS]. As your program begins to develop, you can also test it as a standalone EXE 
program (which can be run directly from Windows). 
When you run the program (with [FS]), Visual Studio compiles the various 
components - forms, procedures etc. - into a single executable file. This .EXE file 
is held in the bin folder in your project directory. It is a completely standalone file, 
which can be copied to any other folder and can be run without having Visual Studio 
running at the same time. 
Unless you specify otherwise, the file will be given the default program icon. To 
change the icon (before building the application): 
1 
Right-click on the project name in the Solution Explorer and select Proper-
ties. 
2 
In the list on the left of the Property Pages, check that the Application tab 
is selected. 
3 
Select a new icon (with an ICO extension) and click on OK. 
ect ICOn 

The name of the EXE file is taken from the project name. However, if you change 
the project name the EXE file is not renamed. To create an EXE file with the new 
name (or a name that is different to that of the project), open the Application tab 
on the properties dialog and type the name in the Assembly name box. 
Click on 
Application 
tab 
D.ebug 
References 
Re$ources 
Settings 
Signing 
Security 
Publish 
Enter new 
project name 
to create new 
EXE name 
111 

Version numbers 
112 
Each time you build an application it is given a version number, consisting of up to 
four parts: 
e 
Major number: This is the main version number. When you completely 
rewrite an application you should increment the major version number. Two 
applications with different major numbers will not necessarily be compatible. 
e 
Minor number: This number is used to indicate that there have been 
significant changes to the application but that it is still compatible with earlier 
versions that have the same major version number. 
e 
Build number: This number indicates the way in which the application has 
been built. For example, versions of an application for use with different 
processors would have different build numbers. 
e 
Revision number: This number is used for small changes to the application, 
such as bug fixes, testing and continuing development. 
Every application must have major and minor numbers; the other two parts of the 
version number are optional. 
The version numberis held as part of the assembly information in Assembly Info. vb. 
Click on this file in the Solution Explorer and scroll to the bottom of the Assembly Info. vb 
tab to view or change the version number. 
The version number is given in the form: 
major.minor.build.revision 
By default, the version number is 1.0. *. The meaning of this number is as follows: 
e 
The major version is 1. 
e 
The minor version is 0. 
e 
The '*'tells the compiler to apply the build number itself. 
e 
There is no revision number. 
It is up to you what system you choose for numbering versions of your software but 
you should ensure that the system is logical and that it is not too difficult to maintain. 
The system you use should be consistent between different applications. 

Assemblylnfo.vb 
code 
Click on Assemblylnfo.vb 
to view or change vers1on 
numbers 
1 TODO: Revier..r t.he values of t.he assen'ibly at-tributes 
<Assembly: AssemblyTitle('H')> 
<A5sembly: AssemblyDescription('11') > 
<Assembly: AssemblyCompany(''But:ford Technical P1..1.blishing-") > 
<Asseltlb 1 y: Assemb 1 yProduct ( '' '') > 
<Assemb 1 y: Assemb 1 yCopyr ight ( ·~,.) > 
<A::;::;embly: .A.ssemblyTractemark("")> 
<Assembly: AssemblyCulture (
1H~) > 
Version infort>1ation for an assen'ibl.V cons:i..sts of t,he fQllowing fou.r values 
Major version 
Mi:nm: 
~lersion 
Revision 
Eu:i.ld Number 
You. c:an :.:rpeL:ify all ;:.he values or y·ou !zan default t.:.he Re:vision and Build 
by using the 
j 
"" 1 as shotim belot.r 
<Assembly: 
AssemblyVersion ( "1. 0. '~~'") > 
Current version number 
113 

Exercises 
114 
1 
Using the example from the Chapter 3 Exercises, modify the Click procedure 
for the Member Details button on the front-end form so that it displays the 
Details window. 
2 
Modify the Click procedure for the Comments button so that it displays the 
Comments window. 
3 
Add the necessary code so that the Exit button ends the program. 
4 
Amend the front-end form so that it is centered when it is first loaded. 
5 
Add a combo box to the Details form so that the region can be selected from 
North, South, East and West. 
6 
Adapt the OK and Cancel buttons on the Details form so that both return the 
focus to the front-end form (and close the Details form). 
7 
Modify the Comments form so that the text box fills the full width of the 
window, leaving enough space at the bottom for the buttons. 
8 
Adapt the OK and Cancel buttons so that they close the Comments form and 
return you to the front-end form. 
For solutions to these exercises, see page 299. 


Using variables 
While an application is running, you will want to store information temporarily. For 
example, if a set of statements is to be processed a number of times you need to 
hold the repeat number and update a count each time the loop is completed; when 
users enter information in text boxes, this new data may have to be kept somewhere 
until you use it. All this information is stored in variables. 
A variable is simply a named location in memory where a single item of data is held. 
Variables are created by being declared within a procedure or form. They can then 
be given values and these values can be retrieved or changed. 
In the same way as for properties, variables fall into two categories: 
e 
Numeric variables hold numbers (whole numbers, decimals, percentages, 
currency amounts and date values) and the settings for numeric properties. 
e 
String variables hold items of text and the settings for text properties. 
You cannot mix these two types; for instance, a numeric variable cannot hold a text 
string unless the string has first been converted to a number. 
Variable names 
116 
Variable names must follow these rules: 
e 
A variable name can be up to 255 characters long, consisting of letters, 
numbers and the underscore character. 
e 
The name must start with a letter. 
e 
There must be no spaces or other symbols in the name. 
e 
Upper and lower case letters are treated as being the same. 
e 
You must not use reserved words (names that have a special meaning within 
Visual Basic, such as If and Left). These are listed in the various topics under 
'keywords' in the Visual Basic on-line help. 
You should choose sensible names for your variables; programs are much more 
readable if names are meaningful. The aim should be to create a set of names whose 
content is reasonably obvious: for example, CurrentDate and AddressLinel. The 
use of capitals helps distinguish separate words within the name; for example, 
'LastTypeToProcess' is more quickly and easily understood than the equivalent 
'lasttypetoprocess'. 

It is a good idea to start each name with a three-letter prefix to identify the type of 
data being stored. 
Declaring variables 
Before you can use a variable it should be declared. A declaration is a statement 
specifying the name of a variable and its type. 
The point at which a variable is declared determines its scope: the scope of a 
variable affects where else in the project it may be used: 
e 
Local variables, declared at the start of a procedure, are available only 
within that procedure. 
e 
Form-level variables, declared at the top of the form class (immediately 
below the 'Inherits' statement), are available to all procedures in the form. 
Local variables are declared using the Dim keyword as follows: 
Dim variable As type 
For example: 
Dim BoxWidth As Integer 
Pro~erf:ies.can. IJ~.tho~&ght of 
. •u •. pr~defide( v•;tiahl••. ·at~ •. ·· 
.tac~ed f& ~artic11J~r &fijeots~ .. 
. 
thepro,ertyW.amesaree~.uiva­
.. r~nf to the variafil. l1ames and . 
·fh~ property settins~ aie th~ ·· .. 
variahle va(ltel.:· 
·· 
' ' 
',~', <: 
~,:~'"" ,' 
":>,'~ " 
~ ;'~, 
~ 
~ 
. Yn ~~.rfuse the St;Hc keyword as arraltern~tive 
·.to l>hJJ.•.·the.··.·V.Itfes of··.· Static ..• •.variahtes. are·"· 
····reme~ti,red ~fter.j&u.leave.a Vrt)c~dureat~d will 
··be th.e:n~e.whenth~J··proc~dllr~ h: ~~~.~ed •tli11;••···· 
ffie values·of·var.iafllea declared withthe.Dim···· 
byword .are cleared: (to ter~.for•••umeriJ.vati~••··.·• 
·· ·.· atiles or tha n11ll drins for stri119 vari:ahle~l every 
· tlrlle the proc.dure. is called. 
· · 
117 

118 
The type can be any of the following: 
Type 
Bytes Use 
Boolean 
2 
Values that can be either True or False 
Byte 
1 
Whole numbers in the range 0 to 255 
Integer 
2 
Whole numbers in the range -32,768 to +32,767 
Long 
4 
Very large whole numbers (±2,000,000,000) 
Currency 
8 
Numbers with an exact number of decimal places (de-
pending on your Country settings in Windows Control 
Panel) 
Single 
4 
Floating-point (decimal) numbers with up to 7 significant 
figures 
Double 
8 
Floating-point numbers, up to 14 sig. figs. 
Date 
8 
Floating-point numbers representing a combined date and 
time 
String 
* 
Text values 
Object 
** 
Capable of holding any type of value, including objects 
* 
Strings require 1 byte per character 
** 
Object values require 4 bytes plus 1 extra byte per character 
When declaring a numeric variable, use a type from as high in this list as possible. 
For instance, if you know that a value will always be a whole number, choose 
Integer rather than Single; if the value will always be in the range 1-100, choose 
Byte. The types higher in the list use less memory and programs run faster. 
Form-level variables are declared immediately below the Inherits statement, using 
the Private keyword: 
Private variable As type 
These variables can be used by any procedure in the form. You can also use Dim 
instead of Private; the effect is the same. 

Constants 
Form-level 
variable 
Constant 
Some variables have fixed values that cannot be changed, either by the user or a 
procedure. These can be declared as constants using the Const keyword. 
e 
Constants declared in a procedure are local to that procedure. 
e 
Constants declared at the top of a form are available throughout the form. 
Constant declarations take the form: 
Const variable As type = value 
Constants help to make your program easier to understand. They also reduce the 
risk of things going wrong, since the value of a constant cannot be changed 
inadvertently. 
Friend Class frrnDetails 
Inherits System.hlindows.Forms.Form 
Private bytNewMember As Byte 
Privat.e intTotalMembers As Integer 
Private strMemberNo, strRegion As Str.ing 
Private decFullSub, decAssocSub As Decimal 
Const decMinirul..U'tlfullSub As Decimal = 25.25 
Const decMinimUfi'IAssocSub A.s Decimal = 12.85 
Const strFullMember As Strin~ = ~~rull Menher" 
Const strAssocMember As String = "Associate Men·J)er'1 
119 

Expressions 
120 
Values are assigned to variables using expressions. Such statements take the 
form: 
variable = express1on 
The expression can be either a specific value or a combination of variables and 
values, linked together by operators. For example: 
i ntStartPos = 5 
intEndPos = intStartPos + 37 
In the first case, the variable intStartPos is given an explicit value of 5. In the second 
case, 37 is added to the value of intStartPos and the result is stored in intEndPos; 
so if intStartPos is 5, intEndPos will be 42. The value of the variable on the left of 
the expression is always changed by the statement; any variables in the expression 
itself are never changed. 
Variables can also refer to themselves, as in this example: 
intStockln = 32 
intCurrentStock = intCurrentStock + intStockln 
The value of intStockln (32) is added to the existing value of intCurrentStock. So, 
if intCurrentStock was originally 68, its value is now 100. 
This statement can be abbreviated using '+ =': 
intCurrentStock + = intStockln 
The effect is the same as before, increasing the value of intCurrentStock by the 
value of intStockln. 
You can do the same thing with the other arithmetic symbols; for example, use '*=' 
to multiply the variable on the left by the amount on the right. 

Numeric operators 
For numeric expressions, you can combine variables and values using the following 
operators: 
A 
* 
I 
\ 
Raising to the power (e.g. 5 A 2 is 5 squared, or 25) 
Multiplication (e.g. 6 * 7 is 42) 
Division (e.g. 14 I 5 is 2.8) 
Integer division (e.g. 14\5 is 2) 
Mod Remainder (e.g. 14 Mod 5 is 4) 
+ 
Addition 
Subtraction 
Where an expression contains more than one operator, the calculation is not done 
from left to right but according to the following order of precedence: 
A 
Raising to the power 
Negation (when the operator starts the expression; e.g. -2) 
* I 
Multiplicationanddivision 
\ 
Integerdivision 
Mod Remainder 
+ -
Addition and subtraction 
For example: 
137- 6 A 2 * 3 = 137- 36 * 3 = 137- 108 = 29 
However, to avoid confusion, it is better to use brackets. 
121 

Brackets 
122 
Inserting brackets in an expression changes the order of calculation. Anything 
inside a pair of brackets is calculated first. Brackets must always be in matching 
pairs. Use only round brackets ( ), not square brackets [] or braces {}. 
If brackets are nested - one pair inside another - the calculations start with the 
innermost pair of brackets and work outwards. For example: 
8 + (3 * (1 0 I 2 - 3)) A 2 
= 8 + (3 * 2) A 2 
=8+6A2 
= 44 
However, it is usually better to split complex expressions over two or more lines. 
The following program demonstrates the use of some simple expressions. 
Calculate 
amounts 
Close window 
and exit 
Set by 
frmVAT Load 
lculated by 
btnCalculate Click 

VAT calculation 
'Oedar~;J. constants for use i 11· whole form 
Anything after a 
single quote is 
a comment 
and is ignored 
by Visual Basic 
Const .dbiVatPercentage As Oecima.l = 17.5 
.· .... 
Co11st dbiVatRate As. DecimaL.== dblVatPercerttage I 100 .. ,IIIIJIII•••• 
. Pi'ivate .. · Sub··.bhtCalc¥1ote_C:IIck( ... },.. 
· 
· 
Hanclhts btnCalculate .. CIIck . . .. 
Dim decNetAmount, deC:VAT As Decimal 
Dim. decGrossAmou)'lt. As .• Decimol 
'Get orr~our)t for cokufotions .. 
decNetAmount = Val{txtNet.T~xt) 
'Golculate volues 
decVAl 
deC:NetAmount * dbiVotRote 
dec(3rossAmount = decNetAmount + decVAT 
· 'Put results in Jext boxes 
txtVAT.Text. = · Format(decVAT, 11r") 
. txtGross.Text = Format(decGrossArrtourit1 ''F") 
End Sub. 
. 
.. 
. .. 
Private $u.b btr~edt,.. Click( ••• ) Handles btnExlt.Ciick 
Me.Gio~e() 
.End Sub 
string value to 
a number - see 
page 132. 
speCI-
fies format for 
numbers - see 
on-line help . 
Private Sub fm1VAT-.Load( ••• J Har~dles MyBa.-.Loa,....._......., __ 
........, 
'P~Jtconsfant VAT percentage in VAl% box 
txtRate~Text = Str{dbiVatPercentage). ;_· ....,..."!""'!'".o.--~-, 
El'ld Sub 
numeric value 
to a string - see 
page 132. 
Private Sub ~Net.Leave( ••• ) Honclles ~Net.LeGYe 
btnGalculote---GiiC:k(btr1Ct:l~(:vlt:lte, New·· Syste~.E\IentArgs~-~~~~---· 
End Sub 
123 

Non-numeric variables 
As well as numeric variables and values, expressions can also include string 
variables (for handling text) and properties (both string and numeric). However, you 
cannot usually mix numeric and string variables. 
You will also need to define variables for handling objects and data where the type 
is not known in advance. 
String variables 
Tip 
String variables are much simpler to use than numeric variables. You can assign a 
particular item of text to a string variable by enclosing it in double quotes: 
strHomeCountry = "UK" 
You can also combine strings. (This is called concatenation.) The & operator adds 
one string to another. For instance: 
strFuiiName = strFirstName & " " & strSurname 
Here, the two parts of the name are added together with a space in the middle. 
Urtlib lither aperatorr, H is essential to 
put a sp~ce on either slde of th~ & symbol; 
otherwiu, it wm not ~e reeogaisel. 
use + lllsfeal of &;ithe effect 
; 
'"' 
,, 
' 
,,'," 
' 
:, 
0 
is the same~ However, it ir better ta' 
~u & to avoid att&igJity~ 
· . 
. 
Properties 
124 
You can use properties in expressions in the same way as you would variables. The 
following statements place a text box in the middle of a form, the height of the box 
being provided by a variable, intHistHt: 
txtHistory.Height = intHistHt 
txtHistory.Top = (frmHist.ScaleHeight - intHistHt) I 2 
The text box can be filled by the value of a string variable, strHistText, as follows: 
txtHistory.Text = strHistText 

Numeric expressions can only include numeric properties and string expressions 
can only include text properties. 
However, you can put a numeric value in a text property or copy the contents of 
a text box into a numeric variable. For example: 
txtNewDist.Text = decMiles 
txtTotaiDist.Text = txtNewDist.Text + txtOidDist.Text 
decMPG = txtTotaiDist.Text I decGallons 
All the conversions between text and numeric values are carried out for you when 
dealing with properties. 
Objectvariables 
If you define a variable as type Object, it can hold data of any type (text or numeric). 
Such variables can then be included in either numeric or string expressions without 
causing errors. This can be useful if you are not certain what type of data you will 
be dealing with (for example, when using the contents of a text box where the user 
can enter either numbers or text). 
However, these general-purpose variables should be used sparingly, as they take 
up a large amount of memory. The variable itself holds a pointer to the data, which 
is stored at another location in memory and is as large as is needed for each 
particular occasion. 
A more common use of the Object variable is to create a specific instance of a 
particular class. An Object variable was used in Chapter 4 to create and display an 
instance of a form class: 
Dim frmvCompanyDetails As New frmCompanyDetails 
frmvCompanyDetails.Show() 
The first statement creates a specific instance of the form class, resulting in a new 
object of that type (a window). Since the object type was specified when the 
variable was declared, the new object (frmvCompanyDetails) inherits all the 
properties and methods. of the class (frmCompanyDetails). Thus the Show method 
can be invoked to display the new window. 
There are many uses for Object variables in Visual Basic 2005, for example when 
selecting fonts, drawing lines and printing. Other examples are given later. 
125 

Numeric functions 
Visual Basic incorporates a number of built-in functions. These are routines that 
carry out specific operations on one or more values and return a result. 
The values supplied to a function are called arguments and are enclosed in 
brackets, following the function name. Multiple arguments are separated by 
commas. (If you do not put spaces after the commas, Visual Studio will insert them 
for you.) 
Each argument can be a specific value or an expression. For example, the lnt 
function returns the integer part of a floating-point number: 
intlengthMetres = lnt(decTotallength) 
intNearestlnt = lnt(sngX + 0.5) 
In the first example, the value of decTotalLength is rounded down to the nearest 
whole number, with the answer stored in intLengthMetres. In the second case, the 
argument is an expression and has the effect of rounding sngX to the nearest whole 
number. The Fix function truncates the value. This produces the same effect as 
Int for positive numbers; for negative numbers, the value is rounded up. 
Mathematical functions 
126 
Visual Basic provides many numeric functions as part of the Math class, including: 
Abs 
Sign 
Round 
Min 
Max 
Sqrt 
Log 
Exp 
Sin 
Cos 
Tan 
Absolute (positive value) 
Sign of value (returns 1 if positive, -1 if negative and 0 if zero) 
Rounds to nearest whole number 
Smaller of two numbers 
Larger of two numbers 
Square root 
Natural logarithm 
Exponential value 
Sine of angle in radians 
Cosine of angle in radians 
Tangent of angle in radians 
c ··---~';' ~,-· :> >q ~: -_·.·· ___ :.:::: :' ---~- ;:~ :·· _· _; ~ _:;·~: ~ 
. Tbkeif1(}te·•·i· . 
1~¥B6,"ih~ Sign, ~~tt 
all~ •. ·.Atani.functlf)ns •..•.•.. •PT. 
p~ar.·aJJ Sgn, Sqr·an4.· .. Atn····· 
·· .. respectillely. 
Atan 
Arctangent (angle whose tangent is given) 

Random numberfunctions 
The Rnd function generates a random number between 0 and 1. If a negative 
number is given as the argument for the first call to the function, the same sequence 
is generated each time; the argument is the 'seed' for the random number 
sequence. 
If you want a different sequence each time, use the Randomize statement to 
initialise the random number sequence. If no argument is given for Randomize, the 
system timer is used to generate the seed, giving a genuinely random starting point. 
An example of the use of the random number generator is given below. 
Random numbers 
.;olm··1ntl(~hdorri.As tnte~er-······· 
· .·•··· Qrn1 intMir11 inlMax As •lofeg~r 
··········• intMln·····~··ixtMin;T~~f•• 
127 

String functions 
Visual Basic provides a number of ways for manipulating text. In addition to a 
variety of built-in functions that allow you to change or extract text, there is a string 
class that has methods for every type of operation imaginable. 
Built-in functions 
128 
There are many built-in string functions. Some of the most useful functions are 
those that act on one string to produce another. These include: 
Left( string, length) 
Right(string, length) 
Mid(string, start, length) 
Len( string) 
LTrim(string) 
RTrim(string) 
Trim( string) 
UCase(string) 
LCase(string) 
Returns a string of given length from the left-hand 
side of the string 
e.g. Left("South", 2) returns 'So' 
Returns a string of given length from the right-hand 
side of the string 
e.g. Right("South", 2) returns 'th' 
Returns a string of given length for the specified 
string, beginning at the start character position; if 
no length is given, the text returned continues to the 
end of the string 
e.g. Mid("South", 2, 3) returns 'out' 
Returns the length of the string 
e.g. Len(" South") is 5 
Removes leading spaces from string 
e.g. LTrim(" South") is 'South' 
Removes trailing spaces from string 
e.g. RTrim("South ")is 'South' 
Removes spaces at both ends of the string 
e.g. Trim(" South ")is 'South' 
Converts the string to capitals 
e.g. UCase("South") returns 'SOUTH' 
Converts the string to lower case 
e.g. LCase("South") returns 'south' 
The programs later in this book contain many examples of these functions. 

Visual Basic functions 
In some cases, where there could be confusion between a function and a property 
with the same name, you need to specify that it is a Visual Basic internal function 
by preceding the function with Microsoft.VisualBasic. 
For example: 
Microsoft.VisuaiBasic.Left(strName, l) 
This avoids any confusion with the form's Left property. 
To make things easier, you can include the following line at the top of the form code: 
Imports VB = Microsoft.VisuaiBasic 
You now need only refer to 'VB' when specifying the function. For example: 
VB.Left(strName, 1) 
String searches 
The lnStr function allows you to search for one string within another. There may 
be up to three arguments for the function, which takes the form: 
lnStr(start, main, search) 
The function searches the main string for the first occurrence of the search string, 
beginning the search at the start position. (Characters in the main string are 
numbered from 1 on the left-hand side.) 
Rather fUll utinga'spaee ··· 
.·i~apait tlfdotthle.quotes·. 
J•"' t~e e~ample bei~W), . 
: if is us~ ally hfter. tt use 
a. etln~ta~tor't~e Clir(I2J 
···f~rt~fio~ ~s-e 'age 131. 
lnStr i& cnl' sensitive; .. 
. ... 
slltshes betwee.n upj.era.n4 .,.wer case 
. lettert wlien searchi.ng~, If .. tn A~Jubt~ 
uteU~ase to eon-ert the mai rntring to .. 
capUaJs<and•eQter .. the.s,eareh strintJn. 
apper. cueasW·efl. 
129 

String class 
130 
If no start value is given, the whole string is searched. For example, the following 
code extracts the surname from a text box: 
Dim strSurname As String 
Dim intSpacePos As Integer 
intSpacePos = lnStr(txtfuiiName.Text, " ") 
strSurname = Mid(txtfuiiName.Text, intSpacePos + 1) 
The first two lines declare the variables that are used in the routine. The third line 
searches a text box (named txtFullName) for a space, putting the position of the 
space in the intSpacePos variable. The final line extracts from the text box the text 
starting from the character after the space to the end, putting it in the string variable 
strSurname. 
Make sure that you put exactly one space between the double quotes; otherwise, 
the search will not be successful. If the search string is not found, the function 
returns a value of 0. 
You can also use the methods provided by the String class to perform all the 
operations described above, along with several others. In some cases, the methods 
work in the same way as built-in functions. For example, the Concat method 
combines two or more strings in a string variable: 
strName = String.Concat(strFName, " ", strSName) 
Here, the contents of the two variables strFName and strSName are combined into 
a single variable, strName, with the two items of text separated by a space. 
Since any string variable is derived from the String class, the methods of the class 
can be applied directly to the string variable. For instance: 
chrlnitial = strSName.Chars(1) 
In this case the Chars method of the String class extracts a specified number of 
characters from the left-hand side of the string. Therefore this statement has the 
same effect as: 
chrlnitial 
Microsoft.VisuaiBasic.Left(strSName, 1) 

You can create a string containing a given number of characters by initialising a new 
instance of the String class. For example: 
strfilledS == new String("S", 4) 
This statement creates the string variable strFilledS and gives it an initial value of 
'SSSS'. 
Character conversions 
Each character in a string is represented in memory by a numeric code in the range 
0 to 255. The codes used are from the ASCII character set. In this system, A is 
represented by 65, B by 66 and so on; lower-case letters start at 97, numeric digits 
at 48; the space character is 32. If you specify one of these codes in a string, the 
required character will be displayed on screen or printed. 
The first 128 ASCII codes are mostly standard and should 
produce the same result in any character font. Codes 0-31 are 
used for control characters, which are often found embedded in 
files. The most useful control characters are 9 (tab character), 
10 (line feed), 11 (form feed) and 13 (carriage return). Codes 
between 32 and 126 are all printable characters. 
The codes for 128 onwards are rather more variable and their 
interpretation depends on how the computer or printer is set up 
and the fonts being used. These are the extended ASCII 
codes. For example, if you create a string of Greek characters 
on one computer they may appear as a completely different set 
of characters on another screen or when printed. 
For this reason, the extended characters are best avoided unless 
you are con tolling the fonts that are used. Remember that you may have to supply 
users with any unusual fonts you are using. 
The Chr function returns the character whose ASCII code is given; for example, 
Chr(32) returns a space. The reverse of this is the Asc function, which converts 
a character to its ASCII code. So Chr(74) is 'J' and Asc("J") is 74. Examples are 
given below. 
131 

String conversions 
132 
As we have seen, Visual Basic makes a very clear distinction between numeric and 
string variables. The only time you may be able to mix numbers and text in an 
expression is when using Object variables or properties. Two functions, Strand Val, 
convert values from one format to the other. 
Str converts a number (or the contents of a numeric variable or expression) to a 
string. The first character of the string is a space if the value is positive or zero; the 
string starts with '-' if the value is negative. 
Most data types also have a ToString method that converts the value into a string. 
The following code assumes that intHouseNum is a numeric variable and 
strStreetName is a string: 
Dim strHouseNumS As String, strFuiiAddress As String 
strHouseNumS = Trim(Str(intHouseNum)) 
strFuiiAddress = strHouseNumS & Chr(32) & strStreetName 
If intHouseNum has the value 23 and strStreetName is 'High Street', the contents 
of strFullAddress will be '23 High Street'. 
The Val function reverses this process, converting a string to a numeric value. The 
function uses as much of the string as it can, up to the first non-numeric character, 
ignoring spaces. Using the example above, Val(strFullAddress) would return 23. 
There are also a number of functions 
for converting values to each of the 
Visual Basic data types. For instance, 
Clnt converts a number to an integer, 
CStr converts a number or text value 
to a string and CDate converts a 
number or string to a date (see below). 
Other functions include CBool, 
CByte, CChar, CDbl, CDec, CLng, 
CObj, CShort and CSng. 
As an alternative, you can use the 
Convert class. This includes meth-
ods such as ToDouble, ToString 
and ToDateTime. 
txtFromASCII 
txtFromChar 
txtToChar 
txtToASCII 

The program below demonstrates the use of functions to convert between 
characters and their ASCII equivalents. The dialog for the program is illustrated 
above. 
ASCII conversions 
133 

Dates and times 
134 
The Date Time structure holds a floating-point number that represents a combined 
date and time. The integer part of the number returns the date, representing the 
number of days since 30-Dec-1899. Therefore 1 represents 31-Dec-1899, 2 is 1-
Jan-1900 and 36526 is 1-Jan-2000. Negative numbers give you dates before 30-
Dec-1899. (The dates are accurate back to 1752, when the Gregorian calendar was 
introduced but theoritically go back as far as 1-Jan-0001.) 
· 
.... rc·~·· 
~ 
This is the slme. SJtfef!!. th~tJs ~sed un Excel. and other spreadsheet 
pruerams. However,;)ome vershms of beef are lna.ccQrate tor d-des 
.hefore 1·Mar~t90f) :u1d wlll pro~uce differeaf result~ to Visual Basic . 
. E~cel and; Lotqs .do not alhtw negative d.tes.lxcei9S-stopS: at ~t-Dec­
-- 2078 J6S~80) ~~He Lotus continues to 3t-Dec.22099 (730SO); dates 
h• Visual Batie and ltter ver;siens of Excel " on to the year ·9999. _ 
The decimal part of the date/time value represents the time as a proportion of the 
day. For instance, 6 a.m. is represented by 0.25, midday is 0.5 and midnight is 0. 
The combination of the two numbers gives a complete date and time; so 36526.25 
represents 1-Jan-2000 6:00a.m. 
You can define a variable as being of type Date Time, in which case the various 
properties and methods of the structure are available to you. 
For example, the Day, Month and Year properties extract appropriate values from 
a date/time value. Similarly, Hour, Minute, Second and Millisecond extract the 
relevant time values. 
Date returns just the date part of the value, while TimeOfDay gives you the time 
portion. DayOfWeek returns a number representing the day of the week (by 
default, 1 for Sunday, 2 for Monday etc.) and DayOfYear gives the day number 
as measured from 1st January. WeekdayName converts the day of the week to 
the corresponding string. 

Time spans 
You can also use the TimeS pan structure for dates and times; variables of this type 
are used to represent time intervals (in terms of days and parts of a day). Thus a 
TimeS pan variable can hold the number of days between two dates or the time that 
has elapsed since a specific date/time value. 
The properties for the TimeSpan structure include Days, Hours, Minutes, 
Seconds and Milliseconds; these return the number of whole days, hours etc. 
included in the TimeSpan value. The TotalDays property returns the number of 
days as a decimal value, TotalHours gives the total number of hours (and parts of 
an hour), and so on. 
Currenttime 
For the Date Time structure, the Today property returns a date/time value representing 
the current system date; Now returns a value representing both date and time. 
Today and Now are expressed as properties of the general Date Time class, rather 
than specific date/time variables: i.e. DateTime.Today and DateTime.Now. 
To get the current time, use DateTime.Now.TimeOfDay. You can convert this 
value to a string using the ToString method. 
Date and time methods 
The Date Time structure has a number of methods that let you manipulate date/time 
values. For example, the Add method adds a TimeSpan value, AddYears adds a 
specific number of years and there are similar methods for the other time units. The 
Subtract method subtracts either a DateTime 
value or a TimeSpan value. 
The Compare method returns the difference 
(in days) between two specified DateTime val-
ues. The DayslnMonth method returns the 
number of days in the month for the specified 
Date Time value and lsLeap Year returns a 
True or False value to tell you whether the 
DateTime value falls in a leap year. 
The TimeSpan structure also has Add, Sub-
tract and Compare methods. 
135 

Visual Basic dates and times 
The Date Time structure is part of the .NET framework. Visual Basic includes an 
equivalent Date data type. Variables of this type represent a date and time in the 
same way as DateTime variables. 
There are several Visual Basic functions for manipulating such dates: 
e 
DateAdd adds a specific value to part of a date. 
e 
DateDiffreturns the difference between two dates (for a specific part of the 
date or time). 
e 
DatePart returns just one unit (days, hours etc.) from the date. 
e 
Format returns the date as a string with a specified layout 
For full details of these functions, see the on-line help. 
Date/time conversions 
136 
DateValue converts a string to a date value; for example, DateValue ("31 Dec, 
2005") returns the date '31/ 12/05'. Similarly, Time Valueconverts a string to a time 
value; for instance, Time Value ("6:00 PM") and Time Value (" 18 :00") both return 
the time' 18:00:00'. 
In both cases, the functions return date/time variables. If you display these in text 
boxes, their string representations are shown. However, in calculations they are 
treated as numbers. 
DateSerial and TimeSerial return similar values but take three arguments: year, 
month and day for DateSerial, or hour, minute and second for TimeSerial. To get 
the same values as the examples above you could use DateSerial(2005, 12, 31) and 
TimeSerial(18, 0, 0). 
Use Date Value and Time Value when dealing with text strings entered by the user 
or derived from some other source; use DateSerial and TimeSerial where the 
separate date/time components are available. 
The following program converts a date/time value to a real date and gives the day 
of the week; it also calculates the date/time value for a real date and adds or 
subtracts a given number of days to give a second date. 

Enter date/time 
value; date and 
time calculated 
Enter date and 
value; other values 
calculated when 
button is clicked 
Date conversions 
. '0)'Cqriverts .• dat~/Vme,·va1Je .to· r~al,date and gives 
· .·.'·., 
> 9ay of Week . . . . ,. .. . 
. · , . . 
. '.· 
. '{2)t:alc:l)lates dc:rteftime volve' fqr ret;tLdgte ond 
' ... 
· t:ldds/subtrac:ts giv~n number ofdays tl:l give s~tond dQt~ , 
i 
,' 
,~', 
'~ '' ' 
' 
'~, 
' 
' 
' 
' 
~"~ 
'c 
'' 
~ 
u'>' 0 
137 

138 
. 
. 
. 
P~qt:e lull btnCC.Ica~I-._CII~(···L. 
· · . Handles btnCtilculate.CIIck 
... bim dt~DateNomi:H~r, dteResultDateNun~b.er As 
···· .l)itn ifltNumberQfD~ys As.lf'lt~get 
. 
.. 
Dim shoDayNornber As Short 
.1CO.nstants for. creating. strings . 
. (:onst sp As Stri~g <= 1'" 
'Calculate dqte/tim~ 'l~loe· · 
· dt~OateNl!mb~r ···;:::.·•· DcJteVCJiue(txtDateln;T~xt) 
<iptNomberOfDays = dt~IJCJteNumb~r,ToOADate 
·•· txtDateTime.Text = intNun;lbetOf()ays 
. . 
··,.---""""""'---~ 
. .. .. 
. 
'Calculate day of week 
'DpyOfWeek is 6 (Sl!nclay)' to ·6 (~turday) 
~hoDCJyNomber ;::: dteD~t~Nurnber~DpyOtWeek 
'Use WeekdayName with Sunday (l) to Satvrdoy (l) 
tXtDayOtWeekText = W~ekdayNametshoO~yNumber _ 
· 
+ 1 1 
, FirstDa}'QtWeek$unday) 
·· 
· 
'CO"lcolate 'laloe for Resl!lf' box 
dteR~sultbareNumbei = 
·· ·. dteDateNumber.AddDays(VoJ{txtAdd[)ays~Text}) 
txtResulf. Text = dteResultO.ateNu mber 
'Up~ate>date/tim~ label 
lbiNow.Text ::;;i1DatE)/time .of lasf e_ntry:n &_ .·· 
· ·· Now.T~lorigbateStril'l9 & sp &c·. Now.T<:>Lonr:JTimeString 
End Sub< 
~te 
__ .sub.·. txtDateTimelri_T~hang~d( ••• ) .. 
· 
· Hont;Jies IXfDateTim.ln.Textehanged 
Dim dteDateln As QateTime 
Dim shoDayNomber As. Short .. 
·' 
.· .. 
Oim. str[)ateString, strDayOMeek As String 
Dim strSecString1 strHqurStrtng; strMin$tring 
Dim strTimeString As Strihg 

'C<mst~nts for creotiQg strings> 
donst sl As St~ing = "/" 
C~~st sp As Str,in~ = ."" .· .. ·· 
. Const lif As String =;"00'' · 
Qonsfcn As String = 
11: 11 
'Gefday of. week 
... 
. 
·dteOa.teln. = DateTi.me.FtofuOAbate(Vttl{~tDowtimeln;Text)) 
'OoyOfWeek is 0 (Sundtty)to o (Saturday) . 
. .. 
··shoDayNumber; • = dteOat~ln.DoyOfWeek 
1Weekd~yNa me d~foult is Moncloy (1)· to Sunday (7) 
'Qhonge so that it is Sunday. {l) to Satur·day (7) 
s~DOYOtWeek .,;;. WeekdayName(shoD('lyNumber + 
First[)ttyOtwe.ek.Sunday) 
. 
', 
,·; 
•.• 1Extractdate components cmd creede date string 
•.· · ~trboteString = dtebateln.D<ly& sl & dteOateln.Month & sl'""" 
· 
· 
& clteDatetn.Year 
txtbl;)te.Text = strOayOfWeek& sp & strDateString 
'Extrod time components and create firne string 
1~ad with leading zeroes· 
strH<:>urString = VB.Right(zr & Hour(dteDateln), .2) 
strMinString = VRRight(zr .& Minute(dteDatein), 2) 
strSecStrihg. = VB.Right(tr & Second(dteDoteln), 2} 
.strTimeString = ~trHourString & en .& strMi.nStrittg & .en_ 
& strSecString 
·u~dat~f dote/time <label 
. 
· · fbiNoW.Text = "Date/tiiT1e oflosfentr}t: " &_ 
. 
. · NoW:'(olongDateSfririg & sp & Now.TolongTimeStriog 
139 

Arrays 
140 
When handling many values or strings, the use of simple variables can be rather 
cumbersome. For instance, if you want to hold the values to fill a large list box you 
do not want a separate variable for each item, nor do you want a separate statement 
for adding each item to the list. You can overcome these problems by the use of 
arrays. 
An array is a set of variables, represented by a single name. The individual values 
are called elements and are identified by index numbers. The index number is 
given in brackets after the name. The first index number is always 0. 
For example, the array MonthDays could hold the number of days in the month; 
MonthDays(l) would hold the number of days in January, MonthDays(2) is for 
February and so on to MonthDays( 12), which would represent the number of days 
in December. 
Arrays are declared in the same way as for variables. You must declare the type 
of the array and, within the brackets, specify the largest index number. For example: 
Dim MonthDays(l2) As Integer 
This statement declares an array of 13 elements (numbered from 0 to 12), each of 
which can hold an integer value. 
An array may have more than one dimension. For example: 
Dim MaxTemp(l2, 31) As Single 
Each possible combination of the two index numbers identifies a different element. 
In this case there are 416 single-precision values in the array, which can be used 
for storing the maximum temperature in each day of the year. For instance, 
Max Temp( 4, 17) could hold the value for 17 April. Some elements, such as 
MaxTemp( 11, 31) and all those with an index number of 0, will never be used. 
Arrays can consume a considerable amount of memory. To save space, you may 
need to calculate the index number from a 'real-world' number. For example, an 
AnnualSales array may be set up to hold a value for each year from 1980 to 2009: 
Dim Annua1Sales(29) As Double 
If the variable intCurrentYear holds a year, the corresponding array value can be 
derived from AnnualSales(intCurrentYear- 1980). 

Any element in the array can be used in an expression in the same way as for a 
normal variable. 
The example below adds text to a string array, depending on the day of the week 
(selected from a combo box). The code also retrieves any existing text from the 
array when the same day is selected a second time. 
Select day from 
the list 
Enter reminder---
Program displays 
corresponding infor-
mation from array 
Selecting a region 
141 

cboDaySelection.ltems.Add(Weekdoyoi\Jqrne(i 
0 + 1,0 
~-
0 
FirstDayOfWeek.Sunday)) 
Next 
0 
cboOoySelection.~electedlndex 
0
• 'Select first day of week 
bisplay current day 
0 
00 
lbiToday,Text = 'Today Is''&_ 
. 
00WeekdoyName(Now.pay0fWeek} 
0 EndoSub 
... 
. 
Private OSuboo btnAdct_Ciick( ..• ) H.andles btnAdd.Ciiek 
Dim bytSelectedDay, pytTodciy As Byte· 
'Getindex nvmber (0 tO 06} of s~lected odoy 
bytSelectedpay = 
cbobaySeledion.SeTectedl~<:lex 
'~tore remindertext in array 
strReminder(bytSelectedDay) op= h<tDayRerninder.TeXt 
'Display reminder.Jor: today oO 
b.ytTodqy = .Now.DoyOfWeek 
lbiRcerninder.Text = strRelllinder{bytTodoy} 
00 
EndoSub 
0 Private Sub cboDaySelaetion_Salectedlnd.xCh,anged( ... ) 
Handles cboDaySelectlqn.Selectedlnd~Changed · 
'Dispioy existing reminder (ff any}o wherr different day selected 
0 
txtDayRerninder; Text = strReminder(d::loDaySelection. _ 
Selectedlndex) 
OEnd Sub 
In previous v.ersions 
.Voucan also define dynamic arrays, where the 
madmumin~ex number is not specifie,~ in the 
original de~laration hut is given later in the 
Basic yo11 could specify the lowest 0 
index numberi in VB 200S t.he 
first in~ex number is always o. 
142 
program by a ReDim statement~ 
0 

Message boxes 
A particularly useful function, MessageBox.Show, displays a temporary dialog 
box. The box contains a line of text and one or more command buttons. The function 
is invoked with a statement in the following format: 
variable = MessageBox.Show(message, title, buttons, icon, default) 
Themessageis any line oftext;titleis the text to be displayed in the title bar; buttons 
is a code indicating the buttons to be included; icon specifies the symbol to be shown 
to the left of the message; and default is another code for the default button (the 
one that is activated when you press [Enter]). 
The buttons and icon values are inserted as standard Visual Basic constants; for 
example, a buttons value of MessageBoxButtons.YesNoCancel places three 
buttons on the dialog box. The variable indicates the button that was pressed. 
As you type the statement, the parameters are shown in a pop-up box. Note that 
there are 12 versions of this function, depending on the parameters you enter; the 
function is said to be overloaded. Although you can select the version you want, 
Visual Basic knows which version you are using from the parameters you enter. 
When you reach the parameters for the buttons and icons, further pop-up boxes 
appear. These list the possible values available to 
you; select one by clicking on it and pressing [Tab]. 
For example: 
Dim bytButtonVal As Byte 
bytButtonVal = MessageBox.Show("File already exists._ 
Overwrite?", "Save", MessageBoxButtons.YesNoCancel,_ 
MessageBoxlcon.Warning, MessageBoxDefaultButton.Button3) 
A dialog box is displayed, with a warning icon and three buttons (Cancel is the 
default). The variable bytButtonVal is returned with a value indicating the button 
that was pressed (e.g. DialogResult.Cancel if the Cancel button was pressed). 
Alternatively, if the key press is unimportant, you can omit the return variable: 
MessageBox.Show("File saved successfully", "Save Done",_ 
MessageBoxButtons.OK, MessageBoxlcon.lnformation,_ 
MessageBoxDefaultButton.Button 1) 
This version of the statement is only really useful if there is only one button on the 
message box. 
143 

Exercises 
144 
1 
Create the unit conversion form below. When one of the buttons is clicked 
the value in the left-hand box should be converted into the new units and 
shown in the right-hand box, to two decimal places. 
The labels to the right of the boxes should be changed to show the two 
conversion units. When a new entry is started, the labels should be blanked 
out and the right-hand box should be cleared. 
The Exit button should end the program. 
2 
Add a Rep label to the Member Details 
form with code to display a representa-
tive name depending on the Region 
selected. 
3 
Write a program to calculate the number of weeks and days between any two 
dates. 
For solutions to these exercises, see page 302. 


Modules 
146 
Much ofthe work done by an application is performed by event-driven procedures; 
these provide the responses to the user's actions. However, some code will be 
needed for more general-purpose actions, such as reading data from a file or 
checking that a date is valid. This code is put in a code module. 
A module is a separate file that contains a collection of general-purpose proce-
dures, which are available throughout the application. Procedures within modules 
are called module-level procedures; those in forms are form-level. There is no 
particular order to a module's procedures and they will be listed alphabetically in 
the Procedure box. 
Most applications will have at least one code module, containing procedures for 
performing frequently-used tasks. These procedures are called as and when 
needed. This has a number of advantages: 
e 
The code has to be written only once; when it has been tested satisfactorily 
you will be able to use it elsewhere in the application without having to go 
through the coding process again. 
e 
Since there is only one copy of the code, there is no danger that the same 
process somewhere else in the application will work in a slightly different 
way. 
e 
If you need to make a change to the way a procedure works, this has to be 
done only once; there is no need to search through your program looking for 
other occurrences of the same code. 
e 
Code modules can be re-used by other applications; when you have 
developed a set of general-purpose procedures, these can be incorporated in 
other projects, helping to give all your applications the same 'look and feel'. 
You can have any number of code modules in your project so it is a good idea to 
split up your general-purpose procedures. For instance, you may have one module 
for text-handling procedures, another for date routines and a third for dealing with 
graphics. 
If you decide that part of a form procedure will be useful elsewhere, you can move 
it to a code module using cut-and-paste operations. 

Scope 
When designing the overall structure of your application it is essential to have an 
understanding of the scope of procedures. This determines what procedures are 
available in any part of the application. The rules are as follows: 
e 
Any module-level procedure can call any other module-level procedure, 
from any module in the project (but cannot call any form-level procedures). 
e 
Any form-level procedure can call any procedure in the same form or any 
module-level procedure (but not any procedures in other forms). 
This is illustrated below. 
You can declare a module-level procedure as Private, rather than Public, in which 
case it is available only to other procedures within that module. 
Note that procedures in forms and modules can refer to any control property 
providing you specify the form name. See page 14 7 for more information on the 
scope of variables. 
147 

Creating modules and procedures 
New modules and procedures are created with a few simple commands. 
Creating modules 
148 
To create a new code module: 
1 
Select ProjectiAdd Module. The Add New Item dialog is displayed, with the 
Module template selected. 
Windows Form 
Dialog 
Explorer Form 
MDI Parent 
About Box 
Login Form 
Splash Screen 
Class 
Form 
~~ 
DataSet 
SQL Database User Control 
Text File 
2 
Type a name for the module (the vb extention will be added for you) and click 
on Open. A code window is displayed. 
(~ My Project 
1M! Assemblylnfo.vb 
S§l frmComments.vb 
Sill frmDetails.vb 
SlliJ frmMainMenu.vb 
Bill frmPassword.vb 
~-~~,.,. 

3 
·The new module is included in the 
Solution Explorer window. Click 
on the module name to see the 
module's properties. 
If you close the code window you 
can redisplay it at any time by high-
lighting the module name in the Solu-
tion Explorer window and then click-
ing on the View Code button. 
Changing modules 
You can add an existing module to the project 
with ProjectiAdd Existing Item. Select a file 
with a vb extension to add either a form or a 
module. 
To remove a module, click on its name in the 
Project Explorer window and then select 
ProjectiExclude From Project. 
Creating procedures in modules 
To add a general-purpose procedure to a code module: 
1 
Double-click on the module name in the Project Explorer window (or click 
on the module and then on the View Code button). The Code window is 
displayed. 
Initially, the only 'objects' foracodemoduleare '(General)' and the module 
name. This is because there are no visible objects for the module (such as 
buttons and list boxes) and therefore no events. 
149 

150 
2 
In between the Module and End Module statements type the procedure 
declaration, in the form: 
Sub procedurename() 
When you press [Enter] an End Sub statement is added for you. Make the code 
more readable by inserting blank lines above and below the procedure. 
inCode 
Sub PaymentSelected () 
End Sub 
:Hodule 
3 
Type the code for the procedure between the Sub and End Sub lines. 
Public intChequeNumber As Integer 
__ 
Pl.::?_~ic strPa~entType -~_;;~_S_cr_i~ng,__ __________ -· 
Sub Payment Selected () 
' lncrewent cl1.eq:ue nmt'.ber and set paywent t-ype 
intChequeNumber = intChequeNurober + 1 
strPaymentType = "Cheque" 
End Sub 
Module 
You can view or edit this code at any time. 

" 
... ' 
. . . . 
·" 
~ .. ·. ~ :·. 
~· ·.· .... 
;~~~ 
/ ~~···· e~rfier Y8tdiJD9 ·. . .... . .. 
··•Visual·. Ba~Ht prooedures· 
were add~d usi~g a ~in.u 
.. optlot1, . r-ther thlm hy 
· dir~ctly typing t~emlnto· .. 
·····Vou ...•. c.,.···.place····~••keyw~rd.···i~.}r:ont .. .,, .. the.·.$~Jr.stat,.me~·~·· 
•to li~irthe· availahUityjJf the pro~edure~· By de~tult, . 
·. proeedure$··are ... ass~med to.· ha .. 'Publ il}' '· •o ~re··· availaMe•.·•·.· 
.. throgjho.ufthe.aJPiie.ati~u.Jif you.put lPri~ate' i.n f"onl·.·.•· 
efthe s~hstatetrlent, the ;procedure is available: only ·. 
· within the module. 
· 
·· 
· · · 
· 
·the code ~~n~ow. 
Creating procedures in forms 
You can also add a general-purpose procedure to a form. This is achieved in a 
similar way to that for module-level procedures: 
1 
Click on the form name in the ProjectExplorerwindow, then on the View Code 
button. 
2 
Make some space above the first event-handling procedure (below the 
Windows Form Designer generated code); 
3 
Type the Sub procedure declaration. When you press [Enter] the End Sub 
is added for you. 
4 
Type the code for 
the procedure. 
Form-level procedures 
are useful for routines that 
may be used more than 
once in a form but cannot 
be used by any other form 
or code module. 
erault5ubscription 
Sub DetaultSubscrlpt ion () 
txtAmount, Text = ''20. 00" 
txtPaictOn. Text = Date Time. Today 
Pn.vat.e Zu,IJ btnCancel_Click(ByVal eventSencter As System.Cb]ect, ByVa.l ev> 
~!e. Close() 
End Sub 
Private Sub btnOK_Click(ByiJal eventSender As System. Object, ByVal 
151 

Procedure names 
Event procedures are automatically named for you. Their names are not necessar-
ily unique in the project as a whole; for example, if two forms each have a btnOK 
button, then both will have a btnOK_Click procedure. However, this is not a 
problem, since the procedures can only be called from within their own forms. 
On the other hand, each general-purpose procedure in a project must be given a 
unique name. 
The rules for naming procedures are the same as those for variables: no more than 
255 characters; starting with a letter; no spaces or symbols apart from the 
underscore. 
Use capital letters to identify individual words within the name; this helps to make 
the name meaningful. 
0 ,','0 
',, 
,,, 
'_,' 
'"o'": 
For m~dales that wHI h" llsed 
• JlytnrQhange the name• ofa·c~n-: "" 
trol;""its eve~t" ~rocedurel wit I not" 
be renamed~ Howe~er, the pro:ceo .. 
dru'es wiiJ still work irl the sam' 
00
• 
projectsf v~• c•n avo.i4"""cfa.Jhes "ht"ptoc"edure 
"" names by starting eseh name with the same 
" word~ fclr insta~tce, all pr•ceduret ill a date'-
handlir~g mi,d"ule could bee! n 11)-te', while 
text·111a~ipulation pro~edures in ariather mod• 
ule could all start 1Text'. 
Calling procedures 
• way aJ befor~ as the Handles.part 
of the procedure decl•ratien .is 
llpdated ".to reflect .the .rlew name~ "" 
A general-purpose procedure is executed by calling it from another procedure. The 
procedure is called by entering the name on a line on its own in the code. 
152 
The empty brackets at the end of the procedure name will be added for you when 
you move out of the statement line. 

For example, a module procedure called FillWithDefaults may be used to fill the 
boxes on a form with default values: 
Sub FiliWithDefaults() 
frmMain.txtDiscountRate.Text = "0.1 0" 
'Use global variable, intNextlnvoiceNumber 
frmMain.txtlnvoiceNumber.Text = intNextlnvoiceNumber 
End Sub 
This procedure could be called either as part of the form's Load event or when a 
Defaults button is pressed on the form. 
The event procedures would be as follows: 
Private Sub Form_Load() 
FiiiWithDefaults() 
End Sub 
PrivateSub btnDefaults _Click() 
FiiiWithDefaults() 
End Sub 
In both cases, the effect is the same. 
In the same way, you can call a general-purpose procedure that has been added to 
a form within any other procedure in the form. 
Procedure 
call 
Private Sub frmDetail~_Load(ByVal eventSender As SY.stem.Object, ByVal e 
cboRegion. It.ems. Add( "North") 
cboRegion. Items. Add ( 11South'1) 
cboRegion. Items.Ad-d( 11Eastr1) 
c::boRegion. Items.Add( 11 West>r) 
DefaultSubscriptiqn () 
End Sc=:ub:__ ____ 
;___ 
Private Sub cboRegion_SelectedValueChanged(EyVal sender As Object, ByVa 
Dim strReps (3) As St-ring 
Dim intSelectedRegion As Im:.eger 
Dim strRep As String 
'flll :;.u:ra~r (assurne list box is sorted) 
strReps (0) = "1L Williams" 
'East 
153 

Public and passed variables 
When you call an event-driven procedure, no other information is needed for the 
procedure to be executed. However, for general-purpose procedures, you usually 
need to make further details available to it and the procedure will often need to pass 
back some result. For instance, a procedure to calculate the number of days between 
two dates needs to know the dates to be used in the calculation and must be able 
to return the answer; if a procedure is used for setting up an array, the contents of 
the array must be made available to other procedures. All this is handled by the use 
of public variables and by passing the contents of variables to and from procedures. 
Private and public variables 
154 
Variables declared in a procedure (with a Dim statement) are local to that 
procedure- they have no meaning elsewhere in the project. Form-level variables 
declared in the Declarations section (with a Private statement) are available 
throughout the form - but not in other forms or modules. 
Modules also have a Declarations section where variables can be declared. The 
declarations take the following forms: 
Private variable As type 
Public variable As type 
The private variables are available throughout the module but not in other modules 
or forms. 
The public variables are available throughout the whole project. The value of a 
public variable can be used by any procedure, in any form or module. For example, 
a user name entered on one window may be needed elsewhere in the program, so 
its value must not be lost. 
As a general rule, you should make variables as local as possible; use local variables 
in preference to private (form-level or module-level) variables, and private 
variables in preference to public variables. This reduces memory requirements and 
helps you to keep track of your variables and their values. 
To add module-level variables, make some space at the top of the module Uust 
above the first Sub statement) and type them in the usual way. 
(After declaring the variables, any statements that use them will no longer have 
errors highlighted.) 

Public 
variables 
inCode 
'$Payment5elected 
ule moctMainCode 
P'lll::llic intChequeNumber l!..s Integer 
S'lll::l PaymentSe lected () 
' Inct"etr1ent cheque: nUJ:nber: ancl set pa~crent t.ype 
intChequeNumber "" intChequeNumber + 1 
strPaymentType "" "Cheque" 
End Sub 
Private and public constants 
Constants can also be declared in the Declarations section of a module. By default, 
constants are private and therefore available to all procedures in the module but not 
to other modules or forms: 
You can also make constants public, making their values accessible to all 
procedures in the project: 
Public Const variable As type = value 
For example: 
Public Const strProgVersion As String = "1.4" 
Public Const intStartYear As Integer = 1997 
These statements can be included in the Declarations section of any module. 
Passing variables to procedures 
One way of exchanging information with procedures would be to hold the values 
in public module-level variables. However, it is more efficient to pass the values 
across when the procedure is called. The variables that are passed to the procedure 
must be declared in the Sub statement, in the brackets following the procedure 
name. The first line of the procedure will be as follows: 
Sub procname(variable As type, ... ) 
1SS 

156 
The brackets can contain more than one variable (when more than one value is 
passed). If no variables are passed, the brackets are empty. The brackets should 
also contain any variables that are to be passed back to the calling procedure. 
When the procedure is called the variable values are listed in the brackets following 
the procedure name. For example, the following procedure extracts the house name 
or number from the first line of an address: 
Sub ExtractHouse(ByRef strHouseName As String, ByRef_ 
strStreetName As String) 
Dim intCommaPos As Integer 
'Find comma 
intCommaPos = lnStr(strStreetName, ",") 
'Get house name/no. from left of street name 
strHouseName = Left(strStreetName, intCommaPos - 1) 
'Remove house from street 
strStreetName = Trim(Mid(strStreetName,intCommaPos + 1)) 
End Sub 
There is no need to specify that 'Left' is a VB function, as this code is in a module, 
rather than a form (and therefore there is no 'Left' property to cause confusion). 
Here, strStreetName is used for passing a value to the procedure; the procedure 
uses strHouseName for passing a value back and it also changes strStreetName, 
passing back a different value. 
The ByRef keyword specifies that the procedure may change the values of the 
variables. The variable intCommaPos is a local variable, which exists only while the 
procedure is running. 
If you want to stop a variable being changed when passed back from a procedure, 
include the ByVal keyword before the variable name in the procedure definition: 
e.g. FillArray(ByVal intCount As Integer). Here, any change to intCount will not 
be passed back to the calling procedure. By including By Val in the Sub line you are 
effectively declaring the variables as local for that procedure. 
If you don't place any keyword in front of the variable name, then the variable is 
assumed to be of type By Val and changes to its value will not be passed back to 
the calling procedure. 

The following procedure, which is invoked by clicking on a button, gets the contents 
of a text box and calls the ExtractHouse procedure. The returned values are copied 
into two text boxes. 
Private Sub btnExtract_Ciick( ... ) Handles btnExtract.Ciick 
Dim strHouse As String 
Dim strStreet As String 
'Get first line of address 
strStreet = txtAddressline l.Text 
'Call procedure to extract house and street 
ExtractHouse(strHouse, strStreet) 
'Put results back into boxes 
txtHouse. Text = s.trHouse 
txtStreet. Text = strStreet 
End Sub 
The variables that appear on the line calling the procedure do not have to have the 
same names as those usedwithin the procedure itself (though they may be the same, 
if you wish). In the example above, the original value is passed across in the strStreet 
variable; the procedure transfers this into the corresponding strStreetName local 
variable, which is then changed; the new value of strStreetName is passed back into 
the strStreet variable. Similarly, strHouseName is passed back as strHouse. 
Comments and spacing 
You can make your programs more readable by adding comments. Although you 
may understand now what your program does, a few reminders might be helpful 
when you come to look at it again in a few months' time. On a line, any text following 
a single quote is treated as a comment and is ignored by Visual Basic. Therefore, 
you can add comments on lines of their own or at the ends of lines. 
Programs are also easier to understand if they are well spaced out. Visual Basic 
adds spaces within each line for you but extra blank lines between sections of code 
help to make it clearer. 
157 

User-defined functions 
158 
Visual Basic provides many built-in functions for handling text and numbers but 
there will be others that you must create yourself. One way of doing this would be 
to use a procedure. For example, the following procedure converts inches to 
centimetres: 
Sub lnchesToCmP(ByRef snglnches As Single,_ 
ByRef sngCm As Single} 
Const sngCmPerlnch = 2.54 
sngCm = (lnt((snglnches * sngCmPerlnch * 1 00} + 0.5}} I 100 
End Sub 
The converted value can be displayed in a text box with the following code: 
Dim snglnches As Single, sngCm As Single 
snglnches = txtEntry.Text 
lnchesToCmP(snglnches, sngCm} 
txtResult.Text = sngCm 
However, it is often simpler to define your own function. 
User-defined functions are created in a similar way to procedures: 
1 
Display the Code window for the module or form where you need the 
function. (If the function is to be called entirely from within a form's 
procedures, add it to the form; otherwise, insert it in a module.) 
2 
At some point above the first procedure to call the function, create a blank 
line and type the function declaration in the form: 
Function functionname(ByVal argument1 As type, ... )As type 
The functionname follows the same rules as procedure names. The 
arguments are the variables being passed to the function and each must be 
given a type. You must also specify the type of the function itself (i.e. the type 
of the returned value). 
3 
When you press [Enter] the End Function statement will be added for you. 
Insert the function code in the space above End Function. 
The function returns a single value, calculated in the function code using a variable 
that has the same name and type as the function itself. 

In order to use the function, include it in a statement in the same way as for a built-
in function. 
For example, the following function converts inches to centimetres: 
Function lnchesToCm(ByVal snglnches As Single) As Single 
Const sngCmPerlnch = 2.54 
lnchesToCm = (lnt((snglnches * sngCmPerlnch * 1 00)_ 
+ 0.5)) I 100 
End Function 
This function could be used to supply the value for a text box, named txtResult, as 
follows: 
txtResult.Text = lnchesToCm(txtEntry.Text) 
When this statement is executed, the InchesToCm function is called and the value 
in the txEntry text box is passed to it. The function calculates the value in 
centimetres using the passed value and the sngCmPerlnch constant, defined in the 
function. The calculated value is held in the InchesToCm variable (defined as Single 
in the function header). 
The calculated value is then slotted back into the original expression and hence into 
the text box's Text property. 
Rather than place the result of the function in a variable, you can use the Return 
keyword as an alternative. Whatever follows the 'Return' is the value passed back. 
F o$e ~ ~~~ctien when jil*t -~· 
~~~u~. is tl · he ret~rnef to the 
'ta(l'lng pr&cedut~s; ~~~·.•a/pro~~~· 
· durt wh.en·twoor more.v«flues an 
lnn,.sameway··as for. pr~c:edur.;,· · 
··seve"ai.V,~da.bl.t~·•·.ear~•he·p~~·sed'•f••••· · 
a ~~~~~ion. T~etypes·.oftht ~trf· .i 
alles p~snfto the turtcti~n .bust 
fie an. exa.t rraafch for those de~ 
. finedit1 the ft~llcfien· hea~er. 
159 

Conditional statements 
160 
So far, the statements in a procedure have followed a linear, unbroken path; the 
program starts at the first line and works down through each line in turn until the 
last line has been completed. 
Procedures are rarely like this, however. Most of the time there are choices to be 
made and, as a result, statements to be executed only if a condition is true. For 
example, if a value entered in a text box exceeds some limit you may want to display 
an error message. 
Such decisions are made using the If ... Then ... End If set of statements, which take 
the form: 
If condition Then 
statements 
End If 
The statements are executed only if the condition is true. The condition usually 
takes the form: 
expresston operator expression 
Any valid expressions can be used, with the restriction that both must be numeric 
or both text; you cannot mix the two types. 
The operator is one of the following: 
= 
Equal to 
<> 
Not equal to 
< 
Less than 
<= 
Less than or equal to 
> 
Greater than 
>= 
Greater than or equal to 
For example, the following procedure tests the value of an entry in a text box when 
the focus is moved to another control. If the value is too high when you try to Tab 
out of the text box, it is replaced by the maximum allowed, a warning message is 
displayed and the cursor is put back in the text box. 

Private Sub txtMinutes_LostFocus( ... )_ 
Handles txtMinutes.LostFocus 
If Val(txtMinutes.Text) > 59 Then 
lbiWarning.Text = "Minutes cannot exceed 59" 
txtMinutes.Text = "59" 
End If 
End Sub 
Visual Studio inserts the End If statement for you as soon as you finish entering the 
If statement. It also indents the statements between If and End If, making the code 
more readable. This becomes particularly important when you start putting one 
condition inside another. 
For numeric conditions, the tests are carried out on the relative numeric values of 
the expressions. For string expressions, the comparisons are performed character-
by-character, according to the ASCII code of the characters. The following 
conditions are all true: 
Numeric 
String 
-4 < 21 
"B"<"Ba" 
5 <2A3 
"B"<"a" 
2.1 < 20 
"2"<"B" 
3 < 21 
"21"<"3" 
161 

Logical operators 
162 
You can combine conditions with the following logical operators: 
And 
Both conditions must be true for the combined condition to be true 
Or 
One (or both) of the conditions must be true 
Xor 
One of the conditions must be true but not both (Exclusive Or) 
The two sets of conditions can be either numeric or text, independently of each 
other. 
For example: 
intDayslnFeb = 28 
If intNumMonth = 2 And booleapYear = True Then 
intDayslnFeb = 29 
End If 
In this case, ifintNumMonth is not equal to 2 or booLeapYear is 'False', the value 
ofDaysinFeb would remain at 28. If both conditions are true (intNumMonth equals 
2 and booLeapYear has a 'True' value) the statement below the If statement is 
executed and the value of intDayslnFeb is changed to 29. 
You can also negate a condition by putting Not in front of it. The Not operator is 
applied first, followed by the other logical operators in the order given above (for 
example, And operators are implemented before Or). 

The Else statement 
Nested lfs 
The conditional statements can provide alternatives for when the condition is false 
by including an Else statement, as follows: 
If condition Then 
true statements 
Else 
false statements 
End If 
If the condition is true, the true_statements are executed; otherwise, the 
false_statements are performed. For example: 
If booLeapYear = True Then 
intDayslnFeb = 29 
Else 
intDayslnFeb = 28 
End If 
The use of Else allows you to provide two alternative sets of statements, only one 
of which will ever be executed. 
For complex conditions you can nest the If statements. For instance: 
If intNumMonth > = 1 And intNumMonth < = 12 Then 
lbiMonth.Text = strMonthName(intNumMonth) 
lbiDays.Text = intDayslnMonth(intNumMonth) 
If intNumMonth = 2 And booLeapYear = True Then 
lbiDays.Text = 29 
End If 
Else 
lbiMonth.Text = "ERROR" 
lbiDays.Text 
End If 
1111 
This illustrates the importance of indenting within If statements. It is clear from the 
indents that the statement lblDays.Text = 29 will only be executed if both sets of 
conditions are true. 
163 

Case statements 
164 
When you are choosing between a number of alternatives, the Case statement is 
more appropriate than the If statement. The structure for a Case statement is as 
follows: 
Select Case expression 
Case test1 
statements 7 
Case test2 
statements2 
Case Else 
statementsN 
End Select 
The expression is evaluated and the re-
..... ii. i ...• ·.···' <•••······_:-
.. :·r~ 
.ftiR~i~at~ · 
,, ' ;> "-.. --· .:<._: :· -.~: : __ · '_:._ :.·. :·:-:> _··::'· .. -.>' )'.:'; :-
-·-:_· >· ;_,: 
····~, tas~ Else ~~~Ito~ is. n~f· .. 
~~~-~tial, hu;t••it l~tsfoll J"~P··· •.··.· 
9P.a~y~i~~jn~val~es.Tq~ ~-d 
~afellt••••taJ~ment:T~st·•·•lways 
.·····ti~irt.~l~.ded;hoJ{f).ver.· 
sult is compared against the various test values. If the expression evaluates to test], 
then statements] are executed; if it is test2, statements2 are executed; and so on. 
If none of the tests matches the expression, the final set of statements ( statementsN) 
is executed. 
The tests for each case can be any of the following: 
e 
A number or numeric expression (e.g. 7, sqr(intA)) 
e 
A string or string expression (e.g. "Yes", strUserName) 
e 
A range of values (e.g. 2 To 6, "A" To "AZ") 
e 
A comparative value (e.g. Is > 6, Is < "M") 
You can also combine any of these, separating them with commas; for example: 
Case 3, 6 To 8, Is > 12 
Here, the corresponding code is executed if the expression evaluates to 3, 6, 7, 8 
or a value greater than 12. 
The most important thing to remember is that the expression and the tests must be 
all numeric or all string. 
An example is given below. (Include the 'Imports VB = Microsoft.VisualBasic' 
statement at the top of the class.) 

Identify co II type 
'(0\tler ch~ckihg. is needed f(j. re~o~e $pa6es : 
'and noq,numeric characters) 
. 
·seJect.Cose·strDiaiCode . 
•... Case. "001'' ro ''00199" . 
165 

Loops 
The conditional statements give you the opportunity to decide whether or not some 
piece of code is to be executed but this still restricts you to a linear flow down 
through a procedure, from top to bottom. There are occasions when you also need 
to repeat a set of statements. Visual Basic provides looping instructions for every 
occasion: 
e 
Repeating a section of code a number of times 
e 
Repeating while a condition is true 
e 
Repeating until a condition becomes true 
e 
Repeating indefinitely 
Each of these alternatives has its own set of Visual Basic instructions. 
For ... Next loops 
166 
The simplest approach to looping is to repeat a group of statements a given number 
of times. This is achieved with theFor ... Next statements, which have the following 
structure: 
For variable = start To end Step step 
statements 
Next variable 
The loop begins with the variable set to the start value and the statements are 
executed. When the Next statement is reached the variable is increased by the step 
amount. If this is greater than the end value, the loop ends and execution continues 
with the statement below Next. Otherwise, the statements are executed again. This 
continues until the end value is exceeded. 
The Step can be omitted, in which case the variable increases by 1 each time. The 
step may also be negative, reducing the variable value each time: in this case, the 
end should be less than the start. 
For example: 
Fori= Len(strTextln) To 1 Step -1 
strTextOut = strTextOut & Mid(strTextln, i, 1) 
Next 

This loop is repeated for each character in the string, strTextln, starting from the 
end and working forwards. Each time, the character is added to the output string, 
strTextOut. The effect is to put the contents of the original string into reverse order. 
You can nest one loop inside another. The inner loop must be completely enclosed; 
its For and Next statements must be between the outer loop's For and Next lines. 
Similarly, you can nest one type of structure inside another: for example, a 
For ... Next loop inside an If ... End If structure or vice versa. 
The example below demonstrates a number of uses of For loops. The first three 
loops have If ... End If structures nested inside them. There is also an example of 
a For loop nested inside another For loop. The inner loop is executed the required 
number of times every time the outer loop is processed. For example, if intNum Words 
is 4, the outer loop will be executed for values of i equal to 3, 2 and 1. When i is 3, 
the inner loop is processed three times (for j equal to 1, 2 and 3); when i is 2,j takes 
values of 1 and 2; and when i is 1 (on the last time through), the j loop is executed 
just once. 
Note that when you type a For statement, the 'Next' statement is added for you. 
No variable is specified on the Next line as this isn't strictly necessary; the level of 
indent shows you which For statement the Next is paired with. However, it is worth 
adding the variable yourself as it increases the clarity of the code and makes it easy 
to see which loop is ending without having to compare indents; this is particularly 
helpful when there is a large amount of code in the loop. 
The example program takes a text string and splits it into its individual words; these 
are stored in a string array, which is displayed in a text box. The array is then sorted 
into order using a bubble sort (this is the part with the nested loops), with the sorted 
array being displayed in another text box. The words are combined again and the 
sorted text is displayed in the final text box. 
The case of the text is ignored when comparing words to be sorted; this is done by 
converting the words to capitals. 
When the array is displayed, the words are forced onto separate lines by adding a 
carriage return/line feed sequence after each one (CR is ASCII code 13, LF is code 
10). 
167 

If the enlva lue illtss than the1Jarl V,ah•e 
• when the loop isfi rst entered lf~tr a Jositht• · · 
tfepJ, tht t!Afenienf$ will ne\l'er he .ex· 
ecqted. Similarly,· if the 11ntlis greatet·t~an 
the llaff for a negative $fep1 .the loop is 
omitted. 
' 
Bubble sort 
168 
Enter text to be sorted, 
then click button 
Include the 
'lmportsVB = 
Microsoft.Visual Basic' 
statement at the 
top of the class 

169 

170 
Nextj· .. · .. 
Next! 
~ext i 
iCombine wOrds into single strin,g and display 
}trTextQl1t .·Z: strTextArray{lJ 
For i = 2 To' il)tNumWords 
stt"TextQut .. = strT~xtQt;t &n ... ·.& strTe}{fArroy(i) 
Ne~t i · 
.· .. 
· txt$ortedText.f~xt 

Do loops 
The Do ... Loop group of statements provides an alternative to For ... Next loops, 
repeating the loop until some condition is either true or false. There are five varieties 
of this loop: 
Do 
statements 
Loop 
Do While condition 
statements 
Loop 
Do 
statements 
Loop While condition 
Do Until condition 
statements 
Loop 
Do 
statements 
Loop Until condition 
Repeats until an Exit Do statement is en-
countered or the user presses [Ctrl-Break] 
Repeats as long as the condition is true; loop 
is never executed if the condition is false 
initially 
Repeats as long as the condition is true; loop 
is always executed at least once 
Repeats until the condition is true; loop is 
never executed if the condition is true initially 
Repeats until the condition is true; loop is 
always executed at least once 
Each of these is useful in particular circumstances. The most important decision is 
whether to place the While/Until part of the structure at the top or bottom of the loop; 
this depends on whether or not you want the loop to be executed at least once, 
regardless of the initial state of the condition. 
Choose between Until and While depending on which makes the condition easier 
to understand. An Until statement can be converted into a While statement by 
putting Not in front of the condition: for example, While A> 0 is the same as Until 
Not A > 0 or Until A <= 0. 
You can use Exit Do to jump out of any loop but, where possible, this statement 
should be avoided; it is neater to exit via the Loop statement. The program below 
demonstrates the use of these loops. 
171 

172 
This program has two functions: the function to put a piece of text into reverse order 
(described earlier) and a function to extract a valid postcode from a line of text. 
The main procedure is activated when the Process Address button is clicked. The 
first loop in this procedure extracts the text up to the first comma in the address that 
has been entered in the text box. Note that the procedure needs to find a comma 
before entering the loop for the first time; if there is no comma the loop will never 
be executed. At the end of the loop, after the text (and following comma) have been 
removed, the next comma is found. The loop is exited when there are no commas 
left. 
The second loop adds the separate lines of the address (which have been stored in 
an array) to a multi-line text box. The loop is repeated for each non-blank element 
in the array. Again, the test is at the start of the loop, so if the first element of the 
array is empty the loop will never be executed. The line number is incremented at 
the end of the loop, so the 'Until' statement tests to see if the next address line is 
blank before the loop is executed. 
Enter full address, then 
click button 
Address split up into 
label format 
Postcode 
extracted 

Address slicer 
·· .···lmp()rts•\f:B::;;. Mlcrosqft.\(is~oiB<:t~k·.· •. 
.. P~bll~ cia• .f~mAddSiice .. 
1 t'lnetifs Sysfetil.Wi~dOws;Forms. FC)rm. ··· 
· .. 'First part of p~~t2~:~e .~ust~e· 2·4 chors,e~qing.in numeric·· 
.rs.~contl part must. be q··C:hars, starting with numeric 
'"" 
'~ 
,, 
u' ' ' 
~ 
0 
' 
, 
' 
. Din"! strRevText.A.s .. String•.·· 
Oirn ~ho~pac:ePo~ As Short· 
·····Dim strP()stcode .AS String 
Dim chrNumeric As Char 
< Dim booPostcodeFound As 
Co~st.Sp A~ String='1 '' 
173 

174 
strR~vT ext = Re\{erse T eld(strT extln} 
. shoSpqc:ePos = lnStr(strRevTEI>~( Sp) 
strPostcode 
'm 
'Extr(lc::t first word from reversed tex(if exoc::+ly 3 c::hqrs 
If shoSpocePoi :::; 4 then 
. 
. 
. . 
. . . .. 
strPostcode :::;. VB.Left{sfrReviext, sh(>SpacePos ..• -. 
strRevText = 
Mid(strRevTexf~ shoSpoteRos + 1}. 
Else 
bqoPostc::ode.found · 
End tf 
c:hrNl!mer-ic:: := Mid(strPostcode1 3, l 
.. 
It chrNumeric < "011 0r c;hrNumerk > ,,9,, 
booPostt<ldeFoJnd .... 
Folse . .. . 
.. 
Ehd If. 
. . 
. . 
EndH. 
booPostcodefovnd Then .. 
<: 
' ' 
~ 
<> 
' :, ' 
If there is no operator, 
the expression is 
calculated as either 
True (non-zero) or 
False. 
'Find next word 
.. . 
. 
· 
'Add space at end to q.llow. for.cose where.th~re is .noth 
'buf the postcode on the .·line 
. . 
. 
. ... 
. .... 
. strRevT.ext = sfrRev Text. & Sp ... 
· shoSp<icePe>s = lnStr($frRevText, ·Sp) 
'Extract word i.f between 2 ond · 4 . chars 
If shoSpo~ePos > == 3 And. shoSpac~P~s. <:::: 5 Th~n 
strPostcode ==' strPosttode & Sp & VB. L.ett(strRevte~,~ . 
. 
shOspqcePos • .. l} 
. . 
. .. 
str:Revtext = Mid(strRevText; sh()Sp()cePgs :+ 
Else 

175 

176 
1lnitlalis~ indk~t~r 
.boeF¢1JowingHouseNumber 
~ 
-
, 
, c 
.. ;Find first comma in ;address 
· shoCom~oPos = .lnStr(strFuiiAddr~ss~ 
.. . . 
.· 
.. 
" 
: .. · 
" 
~Loop as long as>a ~:()rf;lfT1~ ttosbeen found 
·. Do While shoCommoP.os > 0 · 
ff b~oFo.llowingHouseNumber · Thef'l 
1Add t~ first address lin~ . 
. . 
strAddress{l) = .strAddress( 1} & 11, 
II & strNextLioe 
bo~:>FollowingHouseN\}tnbet ~ False 
· 
Else 
1Put\into next address liQe 
. . . .. 
.. 
strAclclress{sholineNutnber) . = ·· VB.Left(strfuUAdclress,~ 
· 
shoCommoPos - 1): 
l And leh(strNeXtG~e) < S And~ 
· Vol(strNextline} ; () Then · 
'First part of t:iddress is a house 11umber 
.. 
1SO nexttirne round loop odd rest of line 1 
1Sfoy online l 
.. 
. . 
. · booFo.flowi.ngHouseNumber = True 
Else 
•Beyond house number so move to next line. 
sholineNumber.+::::: 1 
End If 
1Cut· .out text that· has been. dealt with· . 
strFuUAddress = l Trim(Mid(sttFuiiAd{.fress,.,. 
... 
sho.Comrt'l.ciPos + J)l . 

'Ac~d eoch ne~ line to ~xi~ting)e,g,.······ .... ·.··.·· ·.·· 
. 'with .CRILF chctroct.ers to stort new.Jine 
• 
. b<tAddre.ssLctbei.Text -= \txtA<klresslabeEre,d: &_ 
strAddress(shoUneNumber) & C~ 
sholint11Nvmber := shoUneh4urrib~r + · 1 
177 

Exercises 
178 
1 
Write a function to check whether a password is valid. The function should 
return a value of True or False. 
2 
Write a single procedure to add a given number of days, weeks, calendar 
months or years to a given date, returning the calculated date and its day of 
the week (as a number). Create a form that uses the procedure to display the 
results for entered numbers. 
3 
Write a function to remove all non-alphabetical characters from a string, 
converting the first letter of each word to a capital. Use a Do loop in the 
function. 
For solutions to these exercises, see page 306. 


Creating classes 
Visual Basic is supplied with an impressive range of ready-made classes, allowing 
you to add dozens of different controls and specialised dialog boxes to your 
applications. In addition, there are many third-party controls available. However, 
there are occasions when you need to create classes of your own. This task is much 
simpler than you might expect. 
Adding a class 
180 
The example below demonstrates the creation of a class for a new control: a read-
only text box that displays negative values in red. The first stage is to create the class 
itself: 
1 
In the application where the new control is needed, select ProjectlAdd Class. 
2 
The Add New Items dialog is displayed, defaulting to the Class template. 
Type a name for your class. 
Class template 
Windows Form 
Dialog 
Explorer Form 
MDI Parent 
About Box 
Login Form 
Splash Screen 
Form 
Module 
DataSet 
SQL Database User Control 
Text File 
Enter name 
for class 

3 
Click on Open. You now have an empty class and a vb file has been added 
to the Solution Explorer. 
Enter class 
code 
Class fi 
4 
Finally, specify that the new type of control is to be based on the standard 
Windows text box by adding an Inherits statement. 
Inherits statement identifies 
base class for the new class 
Inherits System. Windows. Forms. Text Box 
181 

Instantiating an object 
182 
You can now add the new text box to a form. At present, this text box is identical 
to any other text box but this demonstrates that the new class is working; the code 
below shows you how to create an instance of the object based on the new class: 
1 
The new object must be visible to all the procedures in the form. Display the 
code window for the form and add the following statement immediately 
below the Inherits statement: 
Public RedTextBox1 As New clsRedTextBox 
Using the Public keyword to declare the variable ensures that the control that 
is created is available to all procedures. Inserting the keyword 'New' before 
the class name means that this statement also creates a new instance of the 
class, resulting in the new object (RedTextBoxl). 
2 
Double-click on Forml to show the Load event and add the following code: 
Me.Controls.Add(RedTextBox1) 
RedT ext Box 1 . Left = 24 
RedT ext Box 1. Top = 192 
RedTextBox1.Text = "Red!" 

The first statement adds the text box to the form's list of controls, resulting 
in the box being displayed on the form. The other statements change the 
position of the box (its size will be the default for normal text boxes) and insert 
some text. 
3 
Run the program. The window is displayed and includes the text box, which 
acts like any other text box. (At this stage, of course, the text won't be red!) 
Close the program. 
Text box 
from new 
class 
Adding methods and properties 
You can now add the features that will make this class different to the standard text 
box class. Start by adding a procedure to the class to set the default properties for 
any new control based on this class. This is done with aNew procedure. Whenever 
you instantiate an object, the corresponding class's New procedure (if any) is 
called. 
Make sure the procedure is above the 'End Class' statement and include a 
statement to set the colour of the text to red. Add two further statements to make 
the text box read-only and then set the background colour to white. (By default, 
read-only text boxes turn grey and the red text would not show up.) 
183 

184 
'Der:ivect c l.a.ae of text box that, displays absolute value 
! of a nmriber: (in red if ne9at.ive) 
1 Base class on exist.in.g class 
Inherits System.hlindows.Forms.TextBox 
Public 5ttb Nelff() 
1 Procedure called when object is created 
'Change default colour tore~ 
Me.ForeColor = System.Drawing.Color.Red 
1 Make t:.he box read-only and chan9e ba.ekgrou.nd colour to uhit.e 
~!e . ReadOnl y = True 
Me.BackColor = System.Drawing.Color.hlhite 
End Sub 
Class 
If you run the program again, the text box will default to red text. 
lrt some eases, contro~s aad other ohjecis h•v$ o~ly·a limited Ufe in. an 
applic~tion. Sucho&jects mus[ ~~ de~!roy~d.as soon as possible; 
· otnerwise~ the.~temory used by the ohjects will not he released anfyou 
could have problems.· later .. ()ljecti .. are de~troye~ (and memoryfr•edup}. 
with statement! .such at: 
· 
· · .· 
• 
: 
.'' 
,' 
• 
c 
RedTextBoxl = Nothing 
The example text box needs an extra property to hold the numeric value of the text. 
Properties are added by inserting a special type of function in the class code. The 
header for these functions takes the form: 
Public Property propertyname() As type 

In this case, you need to add a property called Number Value of type Double: 
Public Property NumberValue() As Double 
As soon as you enter this statement, Visual Studio creates the framework for the 
property. 
iB created 
1 Change default. co lcn.tr t 1J red 
Me.ForeColor = System.Drawing.Color.Red 
1 !iake the box read-ordy and change background colour to white 
Me.ReadOnly = True 
Me.BackColor = Systern.Drawing.Color.White 
End Sub 
Public Property NumberValue() As Double 
Get 
End Get 
Set (ByVal Value As Double) 
End Set 
End Property 
Class 
There are two sections to the code: 
e 
The Get section returns the current value of the property. 
e 
The Set section changes the value of the property. The Value variable 
referred to in the Set statement is the value passed to the property from the 
main code. 
You now have a Number Value property that can be used like any other property 
(although it will not do anything until you fill in the gaps below Get and Set). 
The actual numeric value of the property must be stored in a class-level variable 
(below the Inherits statement): 
Private dbiNumberValue As Double 
185 

186 
You can now fill in the property code. 
j Create property to hold original lYUlrler:ic value 
Get 
1 Return stored ~.~'alue of propert.y 
Return dblNumberValue 
End Get 
Set(ByVal Value As Double) 
1 Store new value of propert'"l 
dblNumbe~Value = Value 
jCopy absolute value to Text property 
lle.Text = llath.Alos(Value) 
1 Set. text colour t.o black or red for positi~ 
... ~e/negative number 
If Value >= 0 Then 
lle.Fo~eColo~() = System.D~awing.Co1or.B1ack 
Else 
Me.ForeColor() = System.Drawing.Color.Red 
End If 
End Set 
End Property 
In most cases, all that the Get and Set sections will do is return the current value 
of the property and store the incoming value respectively. In this example, the 
property is doing quite a lot of work: 
8 
The Get section returns to the calling procedure the current value, as held in 
dblNumberValue. (The Return statement is used in the same way as for a 
standard function.) 

New proce-
dure to clear 
text box 
e 
The Set section stores the passed value in the class-level variable. It then 
copies the absolute value (with any minus sign stripped off) to the Text 
property, so that the value appears in the box. Lastly, the code changes the 
colour of the text to red or black according to whether the actual value is 
negative or positive. 
Finally, add a Clear method to delete the contents of the text box. Add a Sub 
procedure and enter a single line of code, changing the value of NumberValue to 
0. You don't need to do anything else; when you change the property value, the 
property's Set code is called and this will tidy up everything else. 
1 St. ore new value of property 
dblNumberValue = Value 
1 Copy absolute value t.o Text propert-Y 
Me.Text = Math.Abs(Value) 
1 Set- text colO'i..l.:C t-O black OJ: red for positive/negative nu..vrber 
If Value >= 0 Then 
14e. ForeColor () 
= System. Drawing. Color. Black 
Else 
Me.ForeColor() = System.Drawing.Color.Red 
End If 
End Set 
End Property 
Public Sub ClearBox() 
1 clear current \tal ue 
; Change in ·ve.Llue result.s in call t.o Propert.y proc:e~ure 
Me.NumberValue = o 
End Sub 
End Class 
Change NumberValue 
property to 0; text box will 
then be cleared 
The completed class, as it now appears, is shown below. 
187 

Red Text Box class 
Public Class . clsRedTextBox 
188 
'Derived class of text box th~t displays absolute value· 
'of a number (in red if negaJi~e) 
· 
1Base doss dn existing class 
. 
Inherits System ;Wi ndows.Fotms. T ~xtBqx 
'Use priv(lte V:o[iable to .store properly value 
Private dbiNumb~rValu~ As DoobJe. 
Public Sub New() 
. 
. 'Procedure called when objecti$ created 
'Change default <;olour to reel. 
· Me.forec;:olor = System.Dtawing;Cotor.Red 
'Make the box rea.d-only; make backgrOl.J~d colour white. 
Me;~eadOnly = True· 
. 
Me.BackCotor = .System:Drowing.Color.White 
End Sub 
' 
" 
' 
,, 
Public Propel'ly Nulltl;tef'/c:dll80 .As Double 
'Create property to hold oriainaL numeric value . 
Get 
'Returl'). stored value of property 
Return dbiNumberValue 
End Get 
Set(ByVal Value As Double) 
'Store new value of property 
dhiNomberValue .2::·. Value 
'Copy absolute value td Text property . 
Me.T ext = Math.Abs(Value) 
. 
'Set text .colowr to black/red for positive/negative number 

... lfValue > = (). Then. 
.. Mer.ForeColor{} 
Else 
· 
M~.For~Color() ... 
Er.d If 
End Property·· 
·J»Vbllc Sub Cleal'BoXo 
. '<:lear <current value . 
'Gh.ange in value result~: in calf to Property procedure 
MeJ'-l&mber:Value ~ 
.... o 
· 
You can now test the new class. Rename Forml (remembering to change the 
Startup Form in the project properties), delete the line that sets the initial text for 
RedTextBox 1, add text boxes and buttons as shown in the illustration below and add 
suitable code. The code for the form is shown in full. 
Show value in 
--- red text box 
value from 
red text box 
Clear red 
text box 
189 

Test class form 
Public·. Class frmTestCiass ·· ·. 
·. 'For:rn to test new class 
'Form based em/existing class. 
Inherits System.WindowiForms.Form 
10efine obiect .V(l.f"iable ancf create instance of it. 
Public: RedTextBoxl As Ne\'( clsRedTextBox 
, 
-
' 
-
0 
' 
-' 
) 
' ~' 
~ ~ 
' 
' 
' ~ 
' ' 
#Region " Windows Forrr1 .Designer generated (:ode ;, 
' 
.-
: , 
~ 
, 
' 
~ 
' 
#End Region 
. . 
. ... 
190 
Privcde S&Jb Form1 ... 1.0ad{.".) Handles JWl,Bt;~se.l.oad 
'WhemJorm is.loaded/ add new text box to it 
· 
··.· 
.. -·. 
.. 
. 
.'Add text box to. listof fontr:o.ls for form · 
Me.Co.ntrols~Add(RedTextBoxl 
'Set initial positron of new te.xtbox 
RedTextBoXLL.eft 
24 
. . - . 
: 
. 
. 
RedTextllox l.T6p = 192 
End Sub 
. 
' 
' 
. . . . 
: 
'PlJt any nwmeric value from the inpufbox intc> the 
Jnew text box's NurhberValue property 
. 
. .. 
.. .. 
":'· 
.·~-
' 
'The resrof the work is done by the object its~lf 
.. RedTextBoxl.NumberValue. = Val(txtlnpvt.Te~~ 
Private Sub btftGet_CIIck( ••• ). Hqflcllea blrleet.CIIck• 
··· 'Pisplgy the. numeric value held by the new t~xt box ·. 
'Copy the value from the. text b¢x's Nu!JlberVall)e 
'property .to the· output box· 
·. txtOutpuhText = ··R~dTextBoxl.NumberVolue 
End Sub 

The effect of the program is as follows: 
e 
Typing a value in the top box and clicking on Show results in the absolute 
value being shown (in the appropriate colour) in the bottom box (which was 
created from the red text box class). 
e 
Clicking on the Get button retrieves the original value from the bottom box 
and displays it in the second box. 
e 
Clicking on Clear deletes the contents of the bottom box and sets the value 
to 0. 
tt~i~t a:ni~Plisf)t Aot&~iittttttlt~jt t~ksirtivl~trl yu !tk{~ ··· 
·.·•tit~~e•·•alld.· pt-~·.·.·ca:ref~.II.Y .. W~~t. ·fO~ Wadf·: to .. ·a~hiev~~ .... lh~·.ntos:f:.:im.pod~rtt:• · 
· ·thltg·.is•· to·.~~.o.O$t•.a .... ~ase· · c.la$s Jnat.•. is·already clos~.··to••.r,tiat .•ybf1···wantto ..... 
..... do:··that.~y, .. you:•win .. ·.al~eady .ha\fe mod·of· .. ttie·.·.f•u•cti6ftal.ity·.an:~.you•·will:••·····: 
.. ·•· oaJy ne~d. to ~dd in th~. eltra p ruperti as and· ~etho~, rteed.e~ ·to fulfil your .. ·.· 
;»,' ,-,,,,,,',~ ~',:o;o ,"' ''i_:,~:~' 
;• 
,~' 
' 
,<-'\' ,' 
~,' '•,• 
, 
,', ;,,'c:,,;<; 
',•:-;;~ 
~'" o o< 
' 
.r~••c~rem;~nts.. 
· 
191 

Control arrays 
192 
Visual Basic allows you to create control arrays, providing you with the ability to 
place a number of similar contols on a form. The array is set up and manipulated 
from within the program, so that you can decide how many controls to add at run 
time. By using the array, you can change the properties of individual controls as 
needed; since all the controls share the same name, all you need to know is the index 
number for a particular control in order to change its properties. 
The code for handling such an array is spread throughout the application: 
e 
The creation and manipulation of the controls is handled by a new class 
(which is created as a separate Visual Basic program within the project). 
e 
The controls are added to the form by inserting the relevant code in the 
form's procedures; this code calls the methods that are part of the new class. 
e 
You need to keep track of the controls; the variables that do this must be 
available to both the form's procedures and the new class's methods. 
Therefore, these variables must be held in a separate code module. 
The example below generates a very simple form containing a set of numbered 
buttons. Also included on the form are standard buttons that allow you to delete or 
move a selected button, and add further numbered buttons. By itself, this is not a 
useful program but the code can be copied and amended in other applications, letting 
you perform a wide range of control-based operations. 
Array of 
buttons 
Buttons to 
change array 

Code module 
The first task is to create a code module, modControlArrayCode.vb, which holds 
the variables that will keep track of the controls in the array. 
To create the module, select ProjectiAdd Module, click on the Module template, 
type the module's name and click on Open. You can then add the necessary code, 
along with any comments that may be useful later as a reminder of what the 
variables do. 
Module ControiArrayCode 
'Latest button to be clicked or created 
Public intCurrentButton As Integer 
'Total number of buttons created so far 
Public intTotaiButtons As Integer 
End Module 
In this case, the module contains just two lines of code, defining two variables: 
intCurrentButton 
The button that was most recently created or the button 
that has just been added 
intTotalButtons 
The number of buttons currently included in the array 
Array-handling class 
The next stage is to create the array-handling class, clsButtonArray.vb. This class 
will store all the information you need to define and manipulate the controls in the 
array. The class will also provide all the methods for creating the array, adding or 
removing controls, and making 
changes to individual controls' 
properties. 
To create the class, select 
ProjectiAdd Class, give the 
class a name and click on 
Open. You are presented with 
a completely empty class, to 
which you can add the array-
handling code. 
193 

Button array class 
Public Class clsBuHonArray 
. .. . . 
. 
Handles ~reatioM and ~~e of arra~ of buttons 
194 
'Button array .Is h~ld as . .a coltectiOI]H . 
lrJnerlts.$ystem~CoUedions~C¢11~ctiC>nBase 
1Sutton width gnd height 
Con~t irJtBiJttonsizeAs Integer 
' 
. 
' 
·;,. 
.:; 
'Add button to .collection li~t 
MeJ.istAdd(ibtrrNew).·. 
'',u 
" 
' .. :':,' 
'Set prop~rties fpr the new bvtton. 
iiJtnN~w.left = 
intX * {intButtonsize + Sj .. 
ibtnNew,TClp ::;jntY * (intButtonsl2:e + 8) 
. ibtn New.:Wrdth·· •;=• intSuttonsize 
•··ibtnNew;Height··~ ibfnNew.Width· 
•,,;~.·."~· 
• 
~~ 
,· '0 
':~: 
'Store index number in T 99 ·. 
ipfnNevv.T;ag = Me.Col,Jnt - 1 

....• C~setne~ button ~$ currenfbu#cm . 
··· intCurrenfBotton ·.·z:. Me.Count- 1·• 
'D.isptcwf1ew bu#onon·.tip··. 
ihtnN~w:BringToFrbnt{) ·.• · 
Publk Sub RemQ¥e(BtVe~1·1~dec •• l# ...• nteJer) \·•· . 
·. ~Remove cur;rent;buttol'l, pr6v!dingJist is 1;1<>tem.pty. · 
lfM~~Counf . O.Then 
··. 
. 
······~~~ove button from tolledibl1 of forin controls 
. 
~~rid. frol1J o~roy collection.. 
. . 
. Thisforr:ri.Co:ntro.ls.~eh'l~v~{Me(lnde~Jf 
Me.li~t:R~rn~veAt(lnd~x} · 
19S 

'Identify current form 
ThisForr:n =. AF~.rm ...• 
For i = 1 To. 9 · . 
. · Me~AddButton() 
Next 
D•ft:Jult•. PubliC: ReadOnrJ P~ipettf ltem(ayVai .. Jndex_ 
As lntegef1. As Sptei11 .. Winci•\YS.Fotfti$.;B(dfon.··. 
. 'Set ov9ilable prope,rties. for Jist items to> sfandard 
'button properties 
· 
Return 
End Get .. 
End Property 
. 
..· .. 
Public Su.. luttonCiickHandf~r(I,Yal .1ettcler As_ . 
. . ·. 
. Oblect, ByVat·• ~ 
Splef11~EWntArgs) 
. 'Store index number of dkh~d. butt~n in globalvc::~riohle, 
intCurrentButton ::::: CType(s$nder,~ 
. 
. 
. ·· Sy.stero;Wind6ws.Forms.Button).Tag 
'Change .. color pf selected button. 
. . 
.. 
CType(se.hder,. System.Windo.vJs.Forms.Button).Back<;olor =-.. 
·· 
· 
· · · 
System¢olors,Desktop() 
End Sub 
End Class 
196 

There are three statements at the top of the class code: 
e 
The Inherits statement declares that the new class will be based on the 
standard CollectionBase class. This means that the buttons in the array will 
be contained in a collection and all the normal collection properties and 
methods will be available. 
e 
The second statement defines a form variable (ThisForm). The array of 
buttons will be placed on the form identified by ThisForm. 
e 
The third statement sets the width and height of the new buttons as a 
constant. Changing the value here alters the size and position of the buttons. 
The remainder of the code defines the class's methods, properties and events: 
e 
The AddButton method adds a button to the collection and hence to the 
form. This is declared as a Function rather than a Sub procedure, as it has 
to return the new button to the calling procedure. 
e 
The Remove method deletes a button from the collection (and the form). 
e 
The New method generates the initial array of nine buttons. 
e 
There is a default property that returns a reference to a specified button in 
the array. 
e 
The ButtonClickHandler procedure provides the code that is executed 
when one of the aiTay buttons is clicked. 
Each of these is described below. 
Add Button method 
The AddButton method adds a button to the array and to the form. The method 
starts by creating an instance of a button (ibtnNew) and adds this to the collection 
(using the collection's List.Add method); it also adds the button to the form's 
collection of controls. 
Two integers (intX and intY) are used to identify individual buttons on the array; the 
buttons form a grid three wide. The current button is identified by Me.Count- 1, 
which gives an index number starting at 0. Therefore for the first button, Me. Count 
is 1 and the index number is 0; the second button has value 2 for Me. Count and index 
1; and so on. The index numbers are then converted into (intX, intY) co-ordinates. 
197 

The Left, Top, Width and Height properties for the new button are calculated from 
the button's co-ordinates and the button size. Most importantly, the button's index 
number is stored in the button's Tag property; this is essential, as it is the only way 
that the form can identify which button in the array has been clicked. 
The global variables are updated: 
intT otaiButtons + = 1 
ibtnNew.Text = intTotaiButtons 
intCurrentButton = Me.Count - 1 
The first statement increments the number of buttons in the array; the second 
statement uses this number as the text to be displayed on the button surface; and 
the third statement stores the new button's index number in the intCurrentButton 
variable. 
The BringToFront method (which is available for any standard button) ensures 
that the new button is displayed on top of any existing controls. 
The AddHandler statement associates the button's Click event with the 
ButtonClickHandler procedure; all buttons in the array use the same event 
procedure for their Click events. 
Finally, the function returns the button to the calling procedure. 
Remove method 
198 
The Remove method deletes a specified button from the array. The argument 
passed to the method is the index number of the button to be deleted. 
The code is executed only if there is a button to be removed. The button was added 
to both the button collection and the form's control collection and must therefore 
be removed from both collections. The button is removed from the form's control 
collection using its Controls.Removemethod; similarily, it is removed from the array 
collection with the List.RemoveAt method. In all these statements 'Me' refers to 
the class (i.e. the array collection). 
If the button being removed is the last one in the array, the button that is now the 
last one becomes the current button. 

New method 
The New method is called when the array is created. The argument passed to the 
method is the name of the form to which the buttons are being added. 
The method stores the identity of the form in the class's This Form variable (for use 
in the other methods). 
Nine buttons are added to the form by calling the AddButton method nine times. 
Default property 
The default property returns a reference to a button with a specified index number. 
This allows you to refer to buttons and their properties using theirindex number (e.g. 
arrButtons(index) where arrButtons is a variable of type clsButtonsArray). 
ButtonCiickHandler procedure 
The ButtonClickHandler procedure handles the Click event for all the buttons in the 
array. 
The first statement makes the button that has been clicked the 'current' button by 
storing its index numberin the intCurrentButton global variable. Any actions carried 
out on the current button will refer to this button. The index number is available in 
the Tag property of the button that has been clicked. 
The second statement changes the background colour of the button. 
Control arrayform 
The final stage is to create a form that will display the control array and allow you 
to perform operations on individual controls. 
The main part of the form will be used for displaying the array of buttons. Three 
further buttons (which are not included in the array) are needed: 
e 
An Add button to add a button to the array 
e 
A Delete button to remove the current button from the array. 
e 
A Move button to shift the current button one space to the right. 
You can also add a label to provide instructions for using the program. 
199 

Form to which 
array of 
buttons will 
be added 
After creating the form, you need to add procedures for the form's Load event and 
for each button's Click event. 
Button array form 
#Regi~n," Windows ,Form Designer generated ~ode" 
#~nd Region ' 
' 
,, , 
,'Private Sub frmButtonArray.;.LOad( ••• )_ 
Handles, MyBase.LOad ', 
, •create button ar:rqy 
, arrBl,lttons, =,New dsButt()nArray(Me) 
, .• ,End Sub, 
200 

· · •.•• 1Jv\ave.surrept :button •one.plgce to right·••·····.· 
orr$l;lttC>If~(intCurt:entButton}.left +,;:: 33 ·· 
201 

202 
The declaration at the top of the code defines the array variable, arrButtons, as type 
clsButtonArray. However, this statement only creates the variable; it does not 
create the array object itself. 
The remaining procedures handle the form's events: 
e 
frmButtonArray _Load is called when the program is first run and the form 
is loaded. The single statement in this procedure creates the button array and 
calls the array class's New procedure (resulting in the first nine buttons being 
displayed in the top left-hand comer of the window). The parameter passed 
to the New procedure is 'Me', representing the form name. 
e 
btnMove_Click is executed when the Move button is clicked. The first 
statement increases the value of the current button's Left property by 33 
pixels (with the effect that the button moves to the right). The second 
statement restores the button's colour to the standard Windows control 
colour. 
e 
btnDelete_Click calls the array class's Remove method, deleting the 
current button from the list and also removing the control from the form. The 
procedure then renumbers the remaining buttons (so that there are no gaps) 
by making the value in the Tag property match the index number in the array. 
(When a control is removed from the array, the gap is closed up and the index 
numbers of later controls will be reduced.) However, the labels on the 
surface of the remaining buttons are not changed. 
e 
btnAdd_ Click starts by changing the colour of the current button back to 
the default colour. It then adds a button to the array and the form by calling 
the array class's AddButton method. In the process, the new button becomes 
the current button (but its colour will not be changed). 
When you have set up the event procedures, you can execute the program. 

Array of bu1tons, created when the form is 
loaded; bu1tons are added or removed when 
the appropriate user bu1tons are clicked; 
bu1ton changes colour to blue when clicked 
(and all others are set to grey) 
Add a new bu1ton at the 
lete the bu1ton 
that is currently 
highlighted 
Move the selected bu1ton 
one place to the right 
203 

Exercises 
204 
1 
Create a new class of labels that distinguish between text and numeric 
values. If the contents of the label is numeric, the numeric part should be 
displayed on the right of the label (with negative numbers in red); otherwise 
the text should be displayed on the left in blue. The label should have a pale 
blue background. The class must store the actual value of the label in a new 
property. Create a form to test the new class. 
2 
Write a program to display a calendar, as shown below. The display should 
be updated whenever the month or year is changed. The user should be able 
to enter values in the blank cells to the right of the numbers. 
Selecting new month 
updates display 
Typing new year and clicking 
on button updates display 
For solutions to these exercises, see page 308. 


Debugging 
When the program encounters a problem it cannot handle, it displays an error 
message and highlights the line in the program that is causing the problem. The 
program is now in Break mode. 
Dim_ dteD_a.teNi..u'OO~r, dte~esultDateNturiber. AtS- -Datt!T-tml! 
J)ini irtt.NUitJberO:tDa_y~- A.~- !n:t~_9er 
j)iric ShoDaym.imbe;t;· As Sbott 
caused crash 
is highlighted 
Possible 
Suggestions 
for resolving 
the problem 
206 
The Code window is displayed with the line that caused the problem highlighted by 
a yellow box. The program has not halted; it has only been temporarily suspended. 
Therefore, if the error is not too serious, you can make a correction and continue 
runmng. 
The error message box has three sections: 
e 
At the top of the box is a description of the error that has occurred. This will 
be enough in most cases to tell you what needs to be done to correct the error. 
e 
The middle section points to relevant sections of the on-line help. 

Tabs for 
other 
debug 
VI 
e 
The bottom of the box lets you display more detail relating to the error or copy 
some of the detail to the clipboard (for pasting into Notepad, for example). 
The Debug tool bar is displayed at the top of the window. 
Watch 
Show next ___ 
!ili:JF 
statement 
Locals 
e 
Click on the Locals button. The box below the Code window lists the current 
values of relevant variables. These are the values held by the variables 
before the line is executed. 
Variable 
207 

208 
e 
Click on the Watch window to see the values of other selected variables. 
During Break mode, the following options are available: 
e 
You can inspect the line that caused the problem, and the values of relevant 
variables; then press [FS] (DebuglContinue) to continue running the pro-
gram. The system will attempt to handle the error. 
e 
You can close down the program so that you can make changes to the code 
by pressing [Ctrl-Alt-Break] (DebuglStop Debugging). 
e 
You can restart the program from a different point in the current procedure 
by clicking on another line, right-clicking and selecting Set Next Statement; 
then press [FS] (DebuglContinue ). This may allow you to skip a troublesome 
portion of code but is not usually a viable option. 
If you lose your place in the program, right-clicking and selecting Show Next 
Statement displays the procedure containing the next statement to be executed. 
While the program is halted, you can also inspect the values of other variables or 
expressions (see Watching variables on page 215). 
When a progranunshes, pr~u,.. · 
htg [FS] restar.ts. it at the Un.e 
·that ctu~ed··· the prf)hlem( .. not. 
>the following line. 
. . 

Breakpoints 
You can force Visual Basic to halt execution at a particular point in the program 
by setting a breakpoint. Put the cursor on the required line and press [F9]; 
alternatively, click on the grey area to the left of the line or right-click on the line 
and select Insert Breakpoint. 
adds/ subt.racts gi ~,?en number of days to give second date 
Private Sub btnCalculate_ Click ( ByVal eventSender As System. Object, ByVal eventArgs 
Dim dteDateNumber, dteResultDateNumber As DateTime 
Dim intNumberOfDays As Integer 
Dim shoDayNumber As Short 
1 Constant.s for c:reat.ing st.rings 
Const sp As String = " rr 
1 Calculate dat.e/ time ·v·al ue 
intNumbe~OfDays = dteDateNumber.ToOADate 
txtDateTime.Text = intNumberOfDays 
1 Calc::ulat.e: day of r»eek 
1 DayOfT.Jeek is D (Sunday) to 6 
(Sat.urda:~n 
The line is shown with a red background and a 
circle is displayed in the grey area. When the 
program is run, it will halt at this point, before 
the line is executed. 
Having interrupted the program in this way, 
you can inspect the contents of variables, step 
through the code a line at a time, make minor 
changes to the code, or continue execution by 
pressing [FS]. 
You can set several breakpoints at once; the 
program halts each time· a breakpoint is en-
countered. A breakpoint can be cancelled by clicking on the breakpoint line and 
pressing [F9] again; all breakpoints can be cancelled with DebugiDelete All 
Breakpoints. 
209 

Alternatively, you can temporarily deactivate a breakpoint by right -clicking on it and 
selecting BreakpointiDisable Breakpoint; the Enable Breakpoint command re-
stores the disabled breakpoint. 
Single-stepping 
210 
When a program halts because of an error or a breakpoint, the line that is about to 
be executed is highlighted in yellow and a yellow arrow appears on the left-hand 
side of the current line. 
1 Con;:;;:tants fo:t: cre>:.:;ting strings 
Const sp As String = 
~' " 
'Calculat.e date/time value 
Breakpoint 
= dteDateNumber.ToOADate 
txtDateTime.Text = intNumberOfDays 
1 Calc::ulate day of week 
1 DayO:fT<Je~k is I] (Sunday) to 6 
(Sat.l.n~ctay) 
shoDayNumber = dteDateNumber.DayOfWeek 
Line about to be executed 
You can now run the program a line at a time using the following options: 
e 
Press [FS] (DebugiStep Into) to execute the line; if the line contains a 
procedure or a function call, the procedure or function is displayed and you 
can continue to step through it a line at a time. This is called single-stepping. 
e 
Press [Shift-FS] (DebugiStep Over) to execute the line, including any 
procedure or function call; the next line in the current procedure is then 
highlighted. 

e 
Press [Ctrl-Shift-FS] (DebugiStep Out) to finish running the current 
procedure or function and then continue execution until control returns to the 
procedure or function. 
e 
Move the cursor to some other point in the program, right-click and select 
Run To Cursor; execution restarts and continues until this point is reached. 
When you have finished single-stepping, you can use the Debug options either to 
continue or to end the program. 
Breakpoint options 
There are several ways in which you can make more sophisticated use of a 
breakpoint, rather than stopping the program every time the breakpoint is reached. 
Note that these options apply to Visual Basic .NET and Visual Basic 2005 Standard 
Edition and Professional Edition; the breakpoint options are not available in the 
Express Edition. 
Right-click on a breakpoint and select Breakpoint Properties to display a dialog 
containing the breakpoint options. 
211 

212 
The Breakpoint Properties dialog shows you, on the File tab, the line at which the 
break occurs. (As an alternative, you can set the breakpoint in terms of its position 
within a particular function or at a specific memory address.) 
Click on the Condition button to set a condition that must be satisfied for a break 
to occur. For example, you may specify that a variable must equal a particular value 
or that one expression must be larger than another. This is useful if a program is only 
going wrong when particular values are encountered. 
Breakpoint condition: break 
when condition is true 
Alternatively, you can enter an expression and specify that the break should occur 
only when the value of the expression changes. This is a useful option if you are 
trying to detect the point at which some limit is reached or the status of a variable 
changes. 
Breakpoint condition: break 
when value has changed 

Finally, you can specify that the break occurs when the breakpoint has been 
reached a specific number of times. For example, you may want to execute a 
For ... Next loop until the last time through, in which case you would specify one less 
than the final value of the loop counter. 
Click on Hit Count and choose from the following options: 
e 
Break every time the breakpoint is reached (the default). 
e 
Break after a specific number of 'hits'. 
e 
Break when the hit count is a multiple of a specified number (for example, 
break every fifth time through a loop). 
Hit Count condition: break when 
the hit count is a multiple of 5 
Number of hits 
so far 
Number of hits 
for condition 
e 
Break every time after the hit count has reached a specific number. 
These options allow you to set up the most efficient way for reaching a particular 
point in the program. For example, you may want to break when a particular piece 
of data has been read from a file or after you have been through a loop a specific 
number of times. 
213 

214 
When the program is in break mode, you can display the Breakpoint Properties 
dialog and reset the hit counter. 
Current hit count 
and condition 
Position in file at which the 
break will occur 
Note that the current condition and hit count setting are shown on the Breakpoint 
Properties dialog. You can set a combination of conditions, so that the break occurs 
only when both the condition and hit count setting are satisfied. 

Watching variables 
Having broken into a program, you can inspect the values of any variables or 
expressions. If you put the cursor on a variable name in the code, the current value 
pops up below the name. 
You can also see how the value changes as the program progresses. Click on a 
variable name or highlight an expression in the code; then right-click and select Add 
Watch. The Watch window is displayed. This shows the expression and its current 
value. Each time you use Add Watch, another expression is added to the Watch 
window. Now, as you single-step through the program, you will be able to see how 
the values of variables are affected by the code, making it much easier to identify 
the causes of problems. 
Click to calculate 
expression 
Drag the dividers between the column headers to change the widths of the columns 
in the Watch window. 
To remove an expression from the Watch window, right-
click on it and select Delete Watch. 
If you only want to check the value of an expression once, 
mark the expression, right -click and select Quick Watch. 
The QuickWatch dialog shows the current value of the 
expression. You can add this expression to the list in the 
Watch window by clicking on Add Watch. Alternatively, 
select another recently-watched expression from the drop-
down list and click on Recalculate to see its current value. 
21S 

Trapping errors 
216 
You will have noticed that some of the programs you have been writing crash if an 
invalid entry is made (for instance, if a text box that is supposed to contain a date 
is blank when a button is clicked). You can test for some errors- and correct them 
-using a control's LostFocus event. To be sure of handling all errors, however, you 
should include error-trapping statements in your code. These statements are 
activated when an error occurs. 
Error-trapping is implemented as follows: 
1 
Tum error-trapping on with a statement in the form: 
On Error GoT o label 
When a trappable error occurs (one that On Error Go To can handle), the 
program jumps to the code pointed to by the label. 
2 
Identify the end of the normal part of the procedure with an Exit Sub 
statement Uust above End Sub). 
3 
After Exit Sub, enter the label, adding a colon(:) to the end of it. 
4 
Following the label, insert the statements that will correct the error (for 
instance, statements to display a warning message or change the contents of 
a text box). 
5 
End the error-handling statements with a Resume statement (see below). 
6 
If the Resume statement includes a label, insert the label (with a colon) at the 
appropriate point in the procedure. 
The Resume statement must be one of the following: 
Resume 
Resume Next 
Resume label2 
Re-execute the statement that caused the problem. 
Continue with the statement following the one that caused 
the error. 
Resume execution on the line following label2. 
Most errors can be trapped, though only certain types of error are likely to occur 
in any procedure. 
The procedure below demonstrates the use of error-trapping statements. 

Error trapping 
Sample procedure 
taken from Date 
t.•••••••••••~~~~~~~---1 Conversions program 
on pages 137-139. 
.... Pfive~ie sv11 ·~tnCa•••m._c:r~c;lc(~ .. ,_ 
· · ·· 
ltandl&s lltnCalculate~C:Iick · 
[)irti.·.· clte[)ateNufT\ber, •• ·.dteResoltD(lteNumbl:lr .As 
. Dim inttNumberOfDays As Integer 
· . · 
·• Dim shoDayNvmber As Short 
. 
. .·. 
. 
Coo!)fsp AsStrio9 
'Constqnts for .c,regfi.ngstrit:lgs 
217 

Error messages 
218 
Whenever a trappable error occurs, the system generates an error number to 
identify the type of error. You can use this number in your error-handling code to 
decide how best to deal with the error. 
The error information is returned in the Err object. This object has two particularly 
important properties: 
e 
The Number property holds the error number. This is the value you can use 
to drive your error-handling code. 
e 
The Description property holds a detailed description of the error, including 
the values of relevant variables. 
In addition, the ErrorToString function returns a simple, general error message 
for a given error number. 
The following code displays a message box containing the error number, simple 
message and full description: 
Dim intError As Integer 
Dim strSimpleError As String 
Dim strFuiiError As String 
Dim strErrorMsg As String 
intError = Err.Number 
strSimpleError = ErrorToString(intError) 
strFuiiError = Err.Description 
strErrorMsg = "Error" & Str(intError) & ": " & strSimpleError &_ 
" Details: " & strFuiiError 
MsgBox(strErrorMsg) 
Code such as this can be included in the error-handling section of a procedure. 
Err.Number 
ErrorToString 
Err.Description 

The procedure below lists all the available error messages in a text box. 
Private Sub frmErrors_Load( ... ) Handles MyBase.Load 
Dim i As Integer 
Dim strError As String 
Const CRLF = Chr(13) & Chr(1 0) 
Const TAB = Chr(9) 
txtErrSimple.Text = "1" & TAB & ErrorToString(1) 
For i = 2 To 1 00 
strError = i & TAB & ErrorToString(i) 
txtErrSimple.Text = txtErrSimple.Text & CRLF & strError 
Next i 
End Sub 
Application~efined or objecl~ef'ined error. 
Application~eflned or objecl~ef'ined e!'fOr. 
This &ror number is obsolete and no longer used. 
Apptication~ed or object~efined error. 
Procedllre call or argument is not valid. 
Overflow. 
Out of memory. 
Application-defined or object -defined e!'fOr. 
Subscript out of range. 
This array is fixed or temporarily locked. 
DMsion by zero. 
l+4Jplication-deflned or object-deflf"led e!'fOr. 
Type mismatcll. 
Out of string space. 
· App!ication~efined or object-defined e!'fOr. 
&.pression too complex. 
Error number 
ErrorToString 
description 
219 

Structured error handling 
220 
The On Error method of error trapping described above provides an unstructured 
approach. When an error occurs, control jumps to the end of the procedure; after 
dealing with the error, control returns to a point higher up the procedure. As an 
alternative, you can use the Try ... Catch ... Finally group of statements to provide 
structured error-handling. 
The statements take the following form: 
Try 
'Statements that may cause an error 
Catch condition 1 
'Statements to be executed when condition 1 is satisfied 
Catch condition2 
'Statements to be executed when condition2 is satisfied 
Finally 
'Tidying-up statements 
End Try 
The statements that may cause an error are placed immediately below the Try 
statement. The conditions are tests for various errors that may occur. If an error 
occurs in the Try section control moves down to the first Catch statement that 
satisfies the error condition (if any) and the code within that block is executed. The 
code below the Finally statement is always executed, regardless of whether there 
is an error or not. Therefore this is a good place to sort out any potential problems: 
deleting unwanted objects, closing files, freeing up memory etc. 
Using the previous example, the On Error statements can be replaced by a much 
simpler Try ... Catch structure. In this procedure, the only statement likely to cause 
an error is the line that converts the input text to a date value. The only possible error 
is error 13, Type Mismatch. 
Therefore there is just one statement in the Try section and there is only one Catch 
statement; the code within the Catch block deals with the error in exactly the same 
way as for the On Error method. There is no tidying up to be done, so the Finally 
block is omitted. 

Structured errors 
Sample procedure 
taken from Date 
~1!11!1•111111••111111!11!1·~----~----~--i Conversions program 
"Private $ub btnC:ateulate~C:IJck{ ... L 
on pages 137-139' 
· 
· · ·.. Handl.s btnCalculate.C:Iick 
· dirndteDateNu~ber, .dteResvltOoteNqrnber.·'As 
.· oifl'l intNvrnb:erQfDay~ As Integer ·.. . .... 
l:!>im ~hoOayNvn:lber As.Short · 
;C6:nq,tonts for creating str~ngs 
o'~".r: ,':' " ,~",~'' <, 
• 
:o,'~ 
,'~~ 'H 
·•• . ..,:.on~t sp As Stnng A ·· . 
. 
1 GCI\~~Iote dateltime valu~ 
Try 
· ... ·· 
. .. :gteOateNumber = DCiteValue(txtDateln.Text} 
. Catch When Err.Nvmber = 13 
· 
1Deal ~itn i~valid date in input.box 
txt[:)gteh{T ext = Today·· 
.· 
>dteDateNum~er .= O~teValue(Today) 
Msgl3oxf'lnvalid date 11).> 
· 
En~ Try· .... 
. intNumberOfDays .~.· dtebateNumber.ToOADctte. 
txtD.qteTime;T ext' .. =·· intNumberOfDays 
·.· 'C:alc(Jiat$ I:!IJ}' of.week 
·.·. 
·.• 
. 
!OctyOpWeek is 6 (Sunday) to 6 {Saturgayl 
·~hoDayNumb~r = dteDateNumber.DpyOfW¢ek . . 
.... iU~e WeekdayName.with·SiJnday (l)to .. Sdturclay (ij 
·····txtpciyOfWeek.iext .. ·=.··· WeekdayNb.fl1e(shoD0yNvmber 
. .. 
. 
· 
r first0ay0fWeek.SUt1clay) ·. · 
· · !CCilculate • vCII'ue ·for . Resultbox 
221 

Exercises 
222 
1 
Use the debugging options to interrupt the Membership Database program 
when the Region is changed; watch the values for lblRep.Text and 
cboRegion.Text as they are changed. 
2 
Add error-handling statements to the Calendar program so that it deals with 
an entry in the Year box of more than 9999. 
For solutions to these exercises, see page 319. 


The MenuStrip control 
224 
You can add a drop-down menu to a form using the MenuS trip control. Display 
the form to which you want to add a menu and double-click on the MenuS trip control 
in the Menus & Toolbars section of the toolbox. A box with the text 'Type Here' 
is added at the top of the form and the MenuStrip 1 object is shown in an area below 
the form (called the component tray). 
MenuStrip control added 
to component tray 

Adding options 
To add the first menu name to the menu system, click on the 'Type Here' box and 
type the menu name. Include an & in front of the character that is to be used as an 
access key: this is the letter that, when pressed in combination w,ith [Alt], will 
invoke the menu. For example, type '&File' for a File menu that is accessed by 
pressing [Alt F]. 
As you type the menu name, further 'Type Here' boxes are added to the right and 
below. 
Include & in front 
of access key 
When you press [Enter] or click away from the menu name the menu is displayed 
as it will appear on the form. 
22S 

226 
Click on the 'Type Here' box below the menu name to add the first menu option. 
Again, include an access key, if required. Further 'Type Here' boxes are added the 
right and below. 
Type menu name 
(including access 
key) 
You can now extend the menu system in every direction: 
e 
Add further options below the latest entry to extend the menu. 
e 
Add another menu by typing in the box to the right of the first menu name. 
e 
Add sub-menu options by typing on the right of an existing menu option. 
Add menu 
Add sub-menu 
Add 

Sub-menus 
As a general rule, you should give each menu, sub-menu and option an access key 
with no two menus or options in a menu having the same key. By convention, any 
option that leads to a dialog box should have three dots ( ... ) at the end of its name. 
Options that lead to sub-menus will be given an arrow on the right of the name. You 
can edit any part of the menu by clicking on it. 
Sub-menus are created by adding options at a second level ofindent, so thatthe first-
level option effectively becomes a sub-menu name. 
The sub-menu options can themselves become a further level of sub-menu by 
indenting the next set of items to a third level. In all, you can have up to four levels 
of sub-menus, though it is unusual to go beyond the first sub-menu. 
Adding 
sub-menus 
227 

Separator bars 
For long menus, it is useful to split the options into groups. This is done by inserting 
a separator bar. 
To add a separator bar above a particular option, right -click on the option and select 
InsertiSeparator. The bar can be moved around in the same way as any other menu 
item and right-clicking on it results in the same pop-up menu. 
Adding separator 
bars 
Editing the menus 
228 
You can select any menu item by clicking on it. When an item is highlighted, you 
have the following options: 
e 
Click on the item again to edit the text. 
e 
Right-click and select InsertiMenultem to add another option above the 
current option or another menu to the left of the selected menu. 
e 
Right-click and select Delete to remove the option or menu. 
e 
Drag an option up or down the list to change the order within the menu. You 
can also drag separator bars to new positions. 
e 
Drag a menu name to the left or right to change the order of the menus. 
e 
Use the Cut and Paste options from the pop-up menu to move any option, sub-
menu or menu to another menu or to a point on the row of menu names to 
change its status. For example, you can make a sub-menu into a top-level 
menu or vice versa. Any options within a menu or sub-menu will follow it to 
the new location. 

Menu properties 
Each menu, sub-menu and option within the menu system is a separate object, with 
its own set of properties. Separator bars are also independent objects, with their 
own properties. 
Menu item names 
Like all other objects, each menu 
item (whether it's a menu name, 
sub-menu, menu option or separator 
bar) must have a unique name. By 
default, these names are allocated 
as the items are created. However, 
to make life easier when coding 
menu events you should change 
these names to something easier to 
handle. The convention is to give the 
items names consisting of 'mnu' 
followed by the sequence of options 
(e.g. 1llnuFile for the File menu and 
mnuFileSave for the FileiSave op-
tion). 
229 

230 
You can change the Name for each individual item by clicking on the item and then 
editing the name in the Properties window. Alternatively, you can change all the 
names for a whole menu by right-clicking on any item and selecting Edit 
DropDownltems. The Items Collection Editor is displayed. Clicking on an item on 
the left results in the item's properties being shown on the right. 
Click on each item in tum and replace the default name with a meaningful 
alternative. You can also use the editor to add or delete menu items or move existing 
items up and down in the menu. 
T ooiStripDropDownMenu 
i!!i!i mnuEditCut 
i!!i!i mnuEditCopy 
~-.. ---
i!!i!i ClearTooiStripMenultem 
After you have edited the names, right-click on a menu item and select Edit Names 
again to hide the display of object names. 

Boolean properties 
Each menu itemhas three useful Boolean properties: 
e 
The Checked property, when True, places a tick on the left of the menu 
option. 
e 
The Enabled property, when False, greys out the menu or option; clicking 
on the menu or option has no effect. 
e 
The Visible property, when False, hides the option when the menu is 
displayed (or hides the menu). 
Usually, you will want to leave the properties as they are when developing the menu 
system but change them while the program is running. For instance, an option may 
be used for switching some feature of the program on or off. Clicking on the option 
will set Enabled to True (and place a tick against it); clicking on it again will set 
Enabled to False (and remove the tick). As anotherexample, after saving a file the 
FileiSave option may have its Enabledproperty set to False; as soon as further 
changes are made to the data the Enabled property can be set to True again. The 
Visible property can be used for restricting options: for instance, some menu options 
may be visible only to users with certain passwords. 
Shortcut keys 
You can attach a shortcut 
key to any option in any of 
the menus. This is a key com-
bination that the user can 
press to activate the menu 
option without having to click 
on the option itself. For ex-
ample, it is usual for the 
FileiSave option to have a 
[Ctrl-S] shortcut, so that the 
save routine is invoked when 
the user presses [Ctri-S]. 
A shortcut is attached to an item by clicking on the ShortcutKeys property and then 
choosing a modifier key and shortcut key. When you run the program and display 
the menu, the shortcut is shown to the right of the option name. 
231 

Whether or not the shortcut is shown 
on the menu is determined by the 
ShowShortcut property. 
All menu items should have an ac-
cess key (a key used in combination 
with [Alt] to activate the option). 
Only the most frequently-used op-
tions should have shortcuts (which 
use keys other than [Alt]). 
Other properties 
232 
When you have created a menu system for a form, you can alter other properties 
using the Properties window. Select the menu item from the drop-down list at the 
top of the window or click on the menu item on the form and then change the 
properties in the usual way. 
In Visual Basic .NET, four other properties may be useful in more complex 
applications: 
e 
Thelndexproperty sets the position of the menu on the menu bar or an option 
within a menu. The position is numbered from 0 on the extreme left or top 
of the menu. When you change the index for one item all the rest are 
renumbered accordingly. 
e 
The Defaultltem property, when True, indicates that the option is the 
default option in the menu or sub-menu. The item is displayed in bold and 
double-clicking the menu or sub-menu results in the default item being 
selected. 
e 
The MdiList property, when True, results in a list of all subsidiary windows 
currently open in the main window being added to the menu. 
e 
The RadioCheck property, when True, replaces the tick for checked items 
with a radio button. 
These properties are not available in Visual Basic 2005. 
For more information on menu properties, search the Visual Basic on-line help for 
the Menultem class. 

Menu events 
Menu controls respond to a Click 
event, which is activated either 
by clicking on the menu option or 
by pressing the access key or 
shortcut. 
For menus and sub~menus, the 
Click event results in the list of 
options dropping down. For menu 
options, you need to supply a 
Click procedure. The code for 
this is added in exactly the same way as for any other event. (You can either select 
the menu item object and event name in the boxes at the top of the Code window 
or double-click on the item in the form.) 
The Edit menu 
Most applications have an Edit menu with the following options: 
Cut 
Copy 
Paste 
Clear 
Deletes highlighted text and copies to clipboard 
Copies highlighted text to clipboard 
Pastes text from clipboard at cursor position (replacing any 
highlighted text) 
Deletes highlighted text 
The implementation of these options, shown below, will be very similar in most 
applications. 
The clipboard 
The clipboard is an object that is supplied with every Windows application. It does 
not have any physical appearance or events but it does two useful methods: 
SetDataObject 
Copies the specified text to the clipboard 
GetDataObject 
Returns the contents of the clipboard 
The clipboard can hold data in a number of formats - not just text. Therefore the 
retrieval of data from the clipboard is not entirely straightforward. The GetDataObject 
233 

method returns data as an object of type IDataObject. In order to retrieve the data 
from !Data Object you must use the object's GetData method and specify the 
format of the data (which will be one of the standard formats specified by the 
DataFormats class). 
The Edit menu example below illustrates the usual way of doing this for the 
mnuEditPaste_Click procedure. (It is usually only the Paste operation that requires 
you to retrieve data from the clipboard.) The procedure consists of two statements: 
e 
The Dim statement performs two operations: defining a variable of type 
IDataObject and giving it the current clipboard value. 
e 
The second statement uses the new variable's GetData method to retrieve 
the data in the Text format, converting the result into a string that is placed 
in the text box's Text property. 
The clipboard methods can be used in conjunction with the following text box 
properties: 
Selected Text 
String of highlighted characters (blank if none selected) 
SelectionLength Length of highlighted string 
SelectionS tart 
Current cursor position (0 if in front of first character) 
The procedures below show how the Edit menu options are usually implemented. 
Edit menu 
234 

... ··~···$ulllft~~.;CI~ .. t 
· ···· 
··· 
··Handles in~uEdftPaste.CIIck 
· 1D~fin~ ~bjett to hold dipbo(lrd data 
!cmd fill with curr~ilt clipboard. contents 
. . 
. 
. ····· 
. Dirn H)Qto As .T[)at~dbj~d = Clipboard.GetQataObje~tO . 
(Replace . ~urre11t selectio.n with tlipboelr~ .• contents 
.. 1or ins~rt at' cursor positiorf (if. npthing selec:;ted) 
.. t>ctGemrn.en~~·§elededText =.,. . ···· .. 
CType (iData. GetData(DaJe~Formats .Text), 
··. ·.. 
' 
' 
Prlve~te. Sub · ~n.uEdltCiear_Click(~~.)_ 
Handles •nuEdltCiear~CII~Jc .· 
Dim bytButtonVal As.· Byte • 
235 

Adding menus at run-time 
236 
You can add menus, sub-menus and menu options while a program is running and 
change the properties of existing menu items. 
The following code adds a main menu object to a form: 
Dim MainMenu2 As New MenuStrip 
Me.Controls.Add(MainMenu2) 
Me.MainMenuStrip = MainMenu2 
This code creates the object (MainMenu2) and makes it the main menu for the 
current form. 
If there Js>alreadr. all· 
existing menu !fstem, 
thes• in.structio&$ will 
add the menu abt~e it. 
0 
' 
''"'' 
You .can also .mo~i# ~tf 
existing merut syst~r~~~ 
lfjou hatte added a. mnu . ~ystem by 
dragging·anddroppingtheMai&Menucon-
trof onto the form, you can see the code 
"0 
,o 
' 
' 
' 
,, 
that has been generated ·· ftr foil in the· 
.'Winaows Form. Designer geniratea code( . 
seothufof the Code window •. 
To add a menu to your menu system, use code in the following form: 
Dim mnuMenu1 As New TooiStripMenultem("&Menu1 name") 
MainMenu2.1tems.AddRange(New TooiStripltem() {mnuMenu1 }) 
The following code adds an item to an existing menu: 
Dim mnuMenu1 Option 1 As New_ 
TooiStripMenultem("&Option 1 name") 
mnuMenu1.DropDownltems.AddRange(New ~ 
TooiStripltem() {mnuMenu1 Option 1 }) 
Finally, you can change the properties for a menu or menu item: 
mnuMenu1.Name = "&Save" 
mnuMenu1 Option 1.Visible = False 

The following procedure adds a Tools menu, with three options, to an existing menu 
system (with the default name, MenuStripl). 
Public Sub AddT oolsMenu() 
'Define menu items 
Dim mnuTools As New TooiStripMenultem("&Tools") 
Dim mnuToolsCalculator As New 
TooiStripMenultem("&Calculator") 
Dim mnuToolsViewFile As New 
TooiStripMenultem("&View File") 
Dim mnuToolslnternet As New TooiStripMenultem("&lnternet") 
'Add menu and items 
MenuStrip l.ltems.AddRange(New TooiStripltem() {mnuTools}) 
mnu Tools.DropDownltems.AddRange(New _ 
TooiStripltem() {mnuToolsCalculator, _ 
mnuToolsViewFile, mnuToolslnternet}) 
'Set menu and item properties 
'Set shortcut for View File to Ctri-V 
mnu T oolsViewFile.ShortcutKeys = _ 
Keys.Control Or Keys.S 
'Disable Internet option 
mnuToolslnternet.Enabled = False 
End Sub 
Some 111en q• opttcmt wflldu~licate the effect· 6f other • 
eve~t·s. For instancet. 
·······~eleeting the .Filelftit. o~tion may be··•the· same .. as clicldna. on .. the. bit 
· b~tfon .. In such cases, the menu opfhir.l's Click evenf$~oqld carl .the 
procedure fo.r th, cortespf)nding event (e.g~. mnllfileblt~Cii~k shoula 
. caU ~tnExit_Ciick). . 
. 
. 
237 

Context menus 
238 
The context menus that are displayed when you right-click on the screen can be 
added to your program in much the same way as the main menu strip: 
1 
Drag the ContextMenuStrip control from the Toolbox onto a blank area 
of the form or onto a control. The context menu is added to the component 
tray. 
You ~art have ditfetent cortteit menus lor each part of the form. for . 
. example,.·individ•i.l controiJ .. (such as lahels)··~an··have their<own.~onted 
·. menu.Jhe co11t~xf menu lor the form pop! op wfterdhe user click$ 9n any 
OOJitrol that does not tiaveits oltil context menu.. 
. 
. 
2 
Add items to the context menu in the same way as for a main menu, including 
access keys where required. Items within a context menu can also lead to 
sub-menus. 
Menu name not 
shown when 
runn1ng 
Context menu ___ _ 
entries 
Type new name 
for menu item 
3 
In the properties for the form or control to which the context menu is to apply, 
change the ContextMenuStrip property to the relevant ContextMenuStrip 
control. The available menus are listed in the drop-down box. 

4 
Change the properties of the context menu items. The properties are 
displayed when you click on an item in the menu editor. The same properties 
are available as for main menu items, including the N arne of the individual 
items. 
5 
Create Click events for each of the context menu items by double-clicking 
on the items in the menu editor. 
When you run the program, the context menu will be displayed when you right -click 
on the form or control. 
239 

240 
You can also add a context menu while the program is running. The steps required 
are similar to those for adding the menu at the design stage: 
1 
Define a ContextMenuStrip object and the required number of 
ToolStripMenultem objects. 
2 
Attach the context menu to the form (or a control) by setting the form or 
control's ContextMenuStrip property to the name of the ContextMenuStrip 
object. 
3 
Add the options to the menu using the context menu object's Items.AddRange 
method. 
4 
Specify the text to be displayed in the menu by setting each menu item's Text 
property. Include an & in front of any access key. 
5 
Change any other menu item properties (for example, to give the item a 
shortcut key or to disable it). 
6 
Create Click procedures for each menu option. 
The example procedure below adds a context menu to the Membership Database 
front-end window, with options to display the other windows or exit the program. 
This procedure could be called from the form's Load procedure. 
The Click events for the three menu items are also given. 

Context menu 
Me.Cont~xtfv\enuStrlp = m~~Cc>rttext 
· ·· 
~Add the options to Jhe context t1'1Eii:uJ 
.. mt, Ucon~xt2 .fterns.AddRcmge{Ney l ooiStt:iplterri{) ·.·. ""'. 
. {m.nuCqntext2MemberDet.oils; mnvContext2Comm~nts, _ 
· m.nuQontaxt2Exit }) .... . . 
. .. 
mnuC~~textCortiMents. Text 
mn~Co~textExit.T~xt ··~. "E&~w· · 
0 
' 
' 
c 
~ '', :' 
' ; '' \ 
'~' 
~ <C 
' 0 
' 
' 
·chon~~ n1~nu .item· r>rc:fpertles a$ required· 
. mnuContext6dt.ShortcutKe~s = _ 
. 
· Keys. control Or ~~ysX 
· ....... PdVqt• ••.$Ub "'"~ConfelttM.rt.,.rPittalls_C:IIck( •.• )_ 
. . .. 
. Handllts. mnucOn~MemherDetails~CIIck 
······bfnM~fnberD~toils..-Ciit:k{sender~ ... e) 
End Sub 
· Prt"tif8: Sub ~nuC!~tejt(:o.ft~ents_tlick( ... )_ · 
.. 
· 
Handles ... mnuCC»nteliJCoriunents.CIIck · .... 
241 

Exercises 
242 
1 
Add the following menu options to the Members program's main window: 
Menu/option 
Access key 
Shortcut 
Effect when clicked 
File 
f 
(Menu) 
Open ... 
0 
Ctrl+O 
(Leave empty) 
Save ... 
s 
Ctrl+S 
(Leave empty) 
Exit 
X 
Ends program 
Window 
w 
(Menu) 
Member Details ... 
m 
Displays Details screen 
Comments ... 
c 
Displays Comments screen 
Help 
h 
(Menu) 
About 
a 
Displays information box 
Change the menu item names and create appropriate Click procedures for 
these options. 
2 
Add the following menu options to the Details window: 
Menu/Option 
Access key 
Shortcut 
Effect when clicked 
File 
f 
(Menu) 
Save ... 
s 
Ctrl+S 
(Leave empty) 
Abandon 
a 
Same effect as Cancel 
Exit 
X 
Same effect as OK 
Create appropriate Click procedures for these options. 
3 
Add the following menu options to the Comments window: 
Menu/Option 
File 
Save ... 
Abandon 
Exit 
Edit 
Cut 
Copy 
Paste 
Clear 
Access key 
f 
s 
a 
X 
e 
c 
p 
Shortcut 
Ctrl+S 
Ctrl+X 
Ctrl+C 
Ctrl+ V 
Effect when clicked 
(Menu) 
(Leave empty) 
Same effect as Cancel 
Same effect as OK 
(Menu) 
Cuts text to clipboard 
Copies text to clipboard 
Paste text from clipboard 
Deletes highlighted text 
(asks for confirmation) 
Create appropriate Click procedures for these options. 
For solutions to these exercises, see page 320. 


File selection 
Visual Basic 2005 provides three standard controls in the Toolbox that give you 
access to familiar Windows dialog boxes: 
e 
OpenFileDialog allows you to access existing files. 
e 
SaveFileDialog lets you create new files. 
e 
Folder Browser Dialog allows you to select a folder or create a new folder. 
There are also controls for other standard dialogs, such as Print, Font and Color. 
All these dialogs can be found in the Dialogs section of the toolbox. 
When you add one of the standard dialogs to a form, the icon appears in the 
component tray (below the form). 
·.·it~.rliarversio:t~s·otVicual B~sic.had·s~Jparltte. control*.for se)~l}fing a driv*, 
fofd.er ani file.1h.ese are no longer nec~snry is all the <furt.fionaUty ·it . 
... ir~clud~dht .the.~~anda~~dialot~· 
OpenFileDialog 
244 
The OpenFileDialog control has a number of useful properties: 
e 
The InitialDirectory property specifies the folder that is displayed when the 
dialog opens. 
e 
The Filter property allows you to restrict the files to those matching a 
particular file specification. (The filter is shown in the 'Files of type' box.) 
The value of the filter is in two parts, separated by a vertical bar (1): a 
description and the file specification. 
e 
The MultiSelect property, if True, allows more than one file to be selected 
from the dialog. 
e 
The CheckFileExists property determines whether a warning is displayed 
if an invalid filename is typed into the 'File name' box. 

e 
The AddExtension property, if True, adds an extension to the filename if 
it does not already have one. 
e 
The FileName property contains the name of the selected file; for multiple 
files, the names are held in FileNames. No file is returned if the user clicks 
on Cancel. 
e 
The Title property sets the text for the dialog's title bar. If no value is given, 
the title defaults to 'Open'. 
The ShowDialog method displays the dialog box. The procedure containing this 
statement then waits until the user presses the Open or Cancel buttons. The method 
returns the value of either DialogResult.OK or DialogResult.Cancel, depending on 
the button pressed. 
For example, the following code sets up a dialog box for selecting a DOC file, 
starting in the root directory of drive C: 
OpenFileDialog 1 .Title = "Select document" 
OpenFileDialog1.1nitiaiDirectory = "C:\" 
OpenFileDialogl.Filter ="Word files (*.doc)l*.doc" 
If OpenFileDialog 1 .ShowDialog() = _ 
Windows.Forms.DialogResult.OK Then 
strSelectedFile = OpenFileDialog.FileName 
SaveFileDialog 
Else 
strSelectedFile = "" 
End if 
The SaveFileDialog has similar 
properties to the OpenFileDialog. 
There is no MultiSelect property 
but there is an OverwritePrompt 
property, which determines 
whether or not a warning is dis-
played if the filename given al-
ready exists. 
245 

FolderBrowserDialog 
246 
The FolderBrowserDialog control has the following properties: 
e 
The Description property sets the text that is displayed above the folder list 
in the dialog. 
e 
TheRootFolderproperty sets the initial directory from which the search will 
start. The directory must be one of the standard folder names (such as 
'Desktop' and 'My Computers'). These names are held in the Environment. 
SpecialFolder list. 
e 
The ShowNewFolderButton property determines whether the New Folder 
button is included in the dialog. By default, the property is True, allowing 
users to create folders from within the dialog. 
e 
The SelectedPath property holds the full path of the folder selected by the 
user. You can also use this property to set the initial directory, if you do not 
want to use one of the standard folder names. 
Note that the SelectedPath value will end with '\' if a root directory is selected but 
not for any other folder. 
The procedure below illustrates the use of the FolderBrowserDialog for retrieving 
the contents of a folder. When the Select Folder button is clicked, the filenames 
are added to a list box. This is done using the built-in Dir function, which retrieves 
the first file from the directory specified. Note that you only need to give the file 
specification once; if no parameter is given, subsequent calls to the function return 
the next file in the directory. 

Label 
updated 
Files listed 
File viewer 
Click button to 
select folder 
247 

248 

File operations 
Within a program, you may want to delete, rename or copy a file, or carry out 
directory operations. The file actions can be carried out using methods from the 
System.IO.File class: 
e 
The Delete(filespec) method deletes a file. 
The filespec is a string containing the name of the file to be deleted. You can 
use the* and? wildcards (e.g. *.TMP to delete all TMP files). 
e 
The Copy(source, destination, overwrite) method copies a file. 
The source is a string containing the name of the file to be copied. The 
destination is the name of the new file. Both filenames may include the 
directory and drive if necessary. Only one file can be copied at a time. If 
overwrite is True the destination file will be overwritten if it already exists. 
e 
The Move( source, destination) method moves or renames a file. The source 
is the file specification of the file to be moved, the destination is its new 
location and filename. If the source and destination are in different folders 
the file will be moved (and its name changed, if a different name is given); if 
the folders are the same but a different filename is given, the file will be 
renamed. 
e 
1be Exists(filespec) method returns a value of True if the file exists, 
otherwise False. 
The procedures below demonstrate the use of these methods. The buttons and 
procedures can be added to the File Viewer program, allowing you to select a 
folder and then copy, rename or delete any of the files. To be really useful, you 
should add suitable error-checking code to ensure that new filenames are valid. 
File operations 
249 

strSelectedfile :::: JblCurrentPoth.Text & .·•· 
. ·. 
. . . 
.I~tFi!edst.lten'!sJfem(ls~Filelist.Sele~t~dlnd~x) .. 
. · boos;opyFile = Fed~ 
If Me~sog~Box.S~owr\0'/erwrite exi~ti~~t.file? 111"""' .·· · 
·. ''Over#rite?11, MessogeBo)(Buttons~YesN6,_ ··· 
J.l;tessogeBoxl~on.E)(domotion) = ·~· . . 
· 
. Wihdows.Forms.DialogResylt;Yes Thef:J 
.. 
bo<lCopyfile = True 
· · 
End tf 
. . . 
. Else 
.· 
. 
. . If boo<';opyFiJe =.fru~ th~n .· 
.·.·· 
.. 
. . 
S~tem.IQ.File~Cpp)'{strSelectedFUe, .lbl<';urrenfPoth,Text·. &""'" 
· 
· · · 
· · · 
txtC6py.Text, True) 
· 
· 
'0 ' 
;, ' 
, ", 
' 
~ 
, 
, 
UpdOte display······ 
.. 
ListAIIfiJesfl · 
~ : ' ; ~ ~ ,, 
' 
:' ' 
Prlvqte .SUb btnR•ne~rne_.CIIck(.!•L .. 
. 
Handle. btnR•ncUn..CIIck .. 
·•. l:>in1 strSel.ectecfFrle As String 
.. s~rSel~ctedfil~ = U~ICurrehtPoth~Text & 
. 
. ·IJ>tFil eList .Items .ltem(lstFil$list.se lectedln dex) 
250 

Private Sub btpDelefe..,C:Iklc( ••• ).HC.ndles btnDelete.CIIck · . 
Dim strSelectedfile A~ String 
. 
· · 
· 
·. 
· Dim strSelectedN()me As String 
SttSelectedNQme• ... :;:···lstFii~L.isf.lterns,ltern(lstFH~List;~lededlndex) 
strSelectedFite = lbJCurrentPQth:Te>et & strSelettedName 
. 
tf MessageBox.ShoweDeJete " & strSelectedName &: 11 ?''1.;;; 
"Delete file?\ MessageBo:xButtons.YesNo, 
MessageBoxlcon.Question) 
_ 
. ·-
Windows; Forms.DiaiogResult.Ye.s. Then 
System:IO.rile;Oelete(strSelectedFile) 
. l.,istAIIFifes(} 
'Endlf 
.·· ·.f 
II r((l~tl~·~ • 
.····.·.··· 
·~ 
· 'Al.hough these pr~udures demonstrat~the ute·.ofJbe file.operations,JJJ. 
anyrohust application t~eywoutd also need to inchl~e extensive error 
~and ling. Dealing wit~. fHes.is always the most unreliable operation. 
2S1 

Folder operations 
The System.IO.Directory class has a range of methods for manipulating folders: 
e 
TheDeletemethoddeletes the specified directory, including any subdirectories 
and files it contains. 
e 
The CreateDirectorymethod creates the specified directory. If necessary, it 
will create all the folders specified in the path. 
e 
The Move method moves a directory to a new location, renaming the 
directory if required. You can also use this method to rename a directory 
without moving it. 
e 
The Exists method returns True if a specified directory exists, otherwise 
False. 
File properties 
2S2 
The System.IO.File class has a number of methods that allow you to retrieve a 
file's attributes and other properties. The attributes (archive, hidden, system etc.) 
are packed into a long integer as a set of True/False flags. The value contains the 
following attributes: 
Archive 
Directory 
Hidden 
Normal 
ReadOnly 
System 
Temporary 
The attributes are retrieved with the GetAttributes method. You can then use the 
And operator to determine whether or not a particular attribute is set. For example: 
Dim lngFileAtts As Long 
Dim booReadOnly As Boolean 
lngfileAtts = System.IO.File.GetAttributes(strSelectedfile) 
booReadOnly = CBool(lngfileAtts And 
System.IO.FileAttributes.ReadOnly) 
If booReadOnly = True Then 
MessageBox.Show("Read Only file") 
Else 
MessageBox.Show("File is not read only") 
End If 

You can also retrieve dates and times for each file using the following methods 
from System.IO.File: 
e 
GetCreationTime(filespec) returns the date and time at which the file was 
created. 
e 
GetLastWriteTime(filespec) returns the date and time when the file was last 
modified. 
e 
GetLastAccessTime(filespec) returns the date and time when the file was 
last opened. 
The most useful of these is GetLastWriteTime, which tells you when the current 
version of the file was saved. 
The program below uses GetLastWriteTime to compare the contents of two folders 
and list the files that are different. There are two text boxes, one for each selected 
folder. Any file that appears in only one of the folders is added to the list for that 
folder. In addition, for any file that appears in both folders, the modified dates and 
times are compared; if they are different, the most recent is added to the list. 
Comparison 
results 
Click to compare 
folders 
Click each button in turn to 
253 

Compare files 
254 
. 
. 
. 
Private .. S~.tb btnSelectFolder _Click( ••• ),_ 
Handles btnSel.eCtFolder1.Cifck · 
'Ask for diradory, starting In root d~ra<;tory of drive C 
FolderBrowserDiolog 1 .Des<;ription = 11SelecLfolder ·to· view" 
FolderBrowserDiolog l :showNewFolderButton ::.:: Folse 
FolderBrowserDialog l.SelectedPath = "C~\" 
. 
'Exit procedure ifdialog d<Jsed or C.ancel button pressed 
· · If FolderBrowserDialog l.SbowDiolog(). =-
Exit Sub 
End If 
Windows. forms. Dictl()gRes.u If_. Cancel Then 
·'Disploy.poth narne · 
If ·Microsoft.VisuciiBasic.RightfFolderBrowsetOialogl._ 
SelectedPoth i 1 ) = "\'' . Then 
JbiCurrentPothl.T eXt = FolderBrowserDiolog T.SelededPoth 
Else 
lbiCurrentPothl.Te><.t = FolderBrowserDioJo~1.SelededP6thL 
End. If· 
End S0b 
' '  
, 
c 
Private. Sub. btn5electt=olcl411'2_(:11ck( ••. l_ · .. 
Handles btnSelectFolderi.CIIck 
c 
' 
' 
' 
'Ask .for. directory, starting ln root directory of drive C 
FolderBrowserDiolog l.Description =· 11Select fofder.to view" 
FolderBrowserDialogl.ShowNewFolde~Button 
Folse 
FolderBrowserDiologl.SelectedPc:.tth = "C;\" 
'Exitprocedure)fdialog dosed or C.onc:el button pressed 
... ··lfFolderBrowserDiafogl~ShowDiolog() ::::.··""'" · 
·. 
. 
Windgws.Forms.OiologResult.Cancel Then 
. 
. 
... 
. 
.··· -
Exit Sub 
End If 

2SS 

256 
.. 
.· 
' 
.. 
.. 
~ 
~ 
•' 
. 
. 
' 
' ~ 
~~dentify second poth,:induding file $pedfic;otion 
strSetectedPath = lbiCur;elitPath2;Text & n*}'•' · . 
. .i:~fNumFlles2 = 0 . 
. . 
. 
. . 
. . 
. · 'Get first fife from seconcLfolder 
strCUcrrentFile = Dir(stt"?efededPath}. 
Whife·sti"G~rtentFite '<=> "1' 
. 'Add>file ahd elate/time to sec;~:>rid array and get next file 
. strfile2(infNI.JmFiles2) =s strCvrrent~He · .. · .. 
dteFofder2{intNur11Fites2}'== Sy~temJO.Fite,__: . ...... 
.. 
GetLostWrit: Time(lbiCurrentPafh2~ l"exf& · strC:urrentfih:i) 
dbiTimeVal2{intNumFiles2) := :dteFolder2{intNvmFHes2}.:_ 
· 
ToOAQate 
· 
intNvmFiles2 += 1 
. strCurrentFlle. ;:::: Dir() : 
End While 
. 
. 
'Ciea.r text boxes and reset poirters 
· · · D<tFileList l.1'~xt = 
txtfiletist2 .Text = "
11 
int~oint~rl = 0 

····•,Filename$ the .. same, ... 
If doiTime\fal1·(intPointer1). :>._ 
. 
dbrf:imeVo12(intf>ointer2) . Tn~n 
'f:i 1.~~~ list J is lot~r 
. . .. ... . 
. . . · 
tXtflleListl:Text = txtFileListl.Text &"" 
~trfil~a {int~interl} &•jAB &~ .. · 
.. ·· .. ··•· .•. 
. dtefofderJ(intPointeilJ& n (~t.A:TER~}",_.· ... 
.... &CRLF. 
. 
. 
. · .. 
' 
': " 
~ 
' ' 
257 

258 
intP~inter2 +.=<.· .. } . 
. End.Jf 
E.nd If. 

Sequential files 
Sequential files consist of a series oflines of text, and are often referred to as ASCII 
files. Each line of text is terminated by a carriage-return character (ASCII 13) and 
the file ends with Ctrl-Z (ASCII 26). Although ASCII files can include extended 
ASCII characters, they are usually restricted to the standard characters, in the range 
32 to 126. Sequential files are stored with one byte for each character and can be 
viewed, edited or created by Notepad or other text editors. 
Visual Basic provides a group of instructions for handling sequential files. At their 
simplest, sequential files are written or read one complete line at a time (a line 
consisting of everything up to the next carriage-return character). Therefore, they 
are suitable for storing text: for example, the output from a multi-line text box. 
Sequential files can also be saved in comma-delimited format. In these files, each 
line consists of one or more data values, separated by commas. Text items should 
be enclosed in double quotes. When a line of data is read from a sequential file, each 
value is assigned to a variable. 
Text file (ASCII file) 
First joined December, 1997 
Originally Associate 
Comma-delimited file 
"Jim Smith", 1023, "Full", 20, "South" 
"Jo Edwards", 1036, "Full", 20, "East" 
Became Full member January, 1999 
"Ellen Howe", 1045, "Associate", 12, "South" 
.Y11u ~~an~ot. hotf rstd ~~d 
:writ• to • uquential file af 
the. s:a~e ·•ti~e~ E•d•···timi 
. iJOd open a file it is for eijhet; 
.rerding or·wr~ting. 
enclosed in qul)fes hilt n)i~ les~ •r~nfusi~glflt is~ 
···If the ted contains aJolllma;·dotlbls quoteUnust h~ . 
lsed aroundthe ite~ containing the ~~~ma, other· 
wise it wHI.be treated I'$ two sep~rate itefils~ ... . 
259 

Creating sequential files 
260 
There are three stages in creating a sequential file: opening the file, writing the data 
and closing the file. 
The file is opened with a statement in the form: 
FileOpen(number, filename, OpenMode.mode) 
If the mode is 'Output', a new file is created and any existing file with the same 
name is deleted. If the mode is 'Append', the new data is added to the end of the 
existing file (or a new file is created, if one does not yet exist). 
The number identifies the file in the rest of the program and must be in the range 
1 to 255. The number is linked to the file only as long as the file is open. When the 
file is closed, the number can be re-used for another file; if a file is re-opened it does 
not have to be assigned the same number as before. 
Data is written to a sequential file with the Print, PrintLine, Write or WriteLine 
statements. Each statement writes one line of data to the file. The format of these 
statements is as follows: 
Print(number1 value 7 1 value2 1 
••• ) 
Printline(number1 value 71 value2 1 
••• ) 
Write(number1 value 71 value2 1 
••• ) 
Writeline(number1 value 71 value2 1 
••• ) 
The Print statement writes data with tabs between separate items; this statement is 
suitable for writing text files (with just one item per line). TheW rite statement stores 
data in comma-delimited format. 
By default, the Print and PrintLine functions write data with a tab between the 
separate items. The only difference between them is that PrintLine also writes a 
carriage return sequence to the file; therefore PrintLine is suitable for writing a 
single line of text to an ASCII file. 
You can also include Tab() and Spc() functions in the list of items to output. Tab() 
prints the next item at the specified column number, while Spc() prints the given 
number of spaces. 
The Write and WriteLine functions store data in comma-delimited format, the only 
difference being that WriteLine adds a carriage return. 

Comma-delimited 
file 
SS:l 
due" 
, 16, ''Meet:i ng - SSl" 
,19, "Primers" 
, 26, ''N birthday" 
27 ''wales" 
:29: ''sank holiday" 
,31,"Newport:" 
The file is closed with a statement in the form: 
FileCiose(number) 
The FileClose statement is essential, as it stores away any unwritten data held in 
memory. 
Reading sequential files 
Corresponding to the creation of a sequential file, there are three stages for reading 
such a file: opening the file, reading the data and closing the file. 
The file is opened with the following statement: 
FileOpen(number, filename, OpenMode.lnput) 
Data is read from the file with one of these statements: 
variable = Linelnput (number) 
lnput(number, variable 1) 
The Linelnput statement reads an entire line into a string variable and is suitable 
for text files. Each call to the Linelnput function reads the next complete line from 
the file. 
The Input function should be used where files have been written with the Write 
or WriteLine functions. Each call to the Input function reads the next item from 
the file. The function can only read one item at a time, so a series of calls are needed 
for each line in a comma-delimited file. 
The FileClose statement is the same as before. 
261 

262 
Sequential files are always read from the beginning of the file. You can use the 
EOF function to detect the end of the file. (The function returns a True value when 
the end-of-file marker has been reached.) The LOF function gives you the length 
of the file (in bytes) and LOC returns the current location (in terms of the number 
of characters read so far). All three functions take the file number as their 
argument. 
The FileLen function gives you the length of any file. The function takes the 
filename as its argument. If the file is open, the function returns the length of the 
file when it was opened. 
The following procedures demonstrate how File I Open and FileiSave commands can 
be used to read and write data entered in the Calendar program from the Chapter 
8 Exercises. The FileiSave procedure stores the contents ofthe calendar boxes in a 
sequential file, with one line for each box. The filename is based on the year and 
month of the calendar. The File I Open procedure reads the text back into the boxes. 
You eaa also create hinary files, where data is written aid read a eharact~r 
at a tim.4. This gives yotA complete control over the file., withotAt havint to 
worry ahtAt the struehne irnpos~d by i;omm.a·delimite(files or reeotd· 
Lased files. However, your prograiQ must keep pre.: In track of the position ··· 
and. size of data irt the file, 

Calendar files (1) 
b~m .. strCaiFileAs•·strin~·· 
Dim strG:aiSpec .As •. String· 
·.. 
pim i As lnt~ger 
... . 
. . 
.......... birnintOayNo·As.lnteger··· 
... 
'Assume direetort already exists for storil'l~ fifes .. 
·· Cdnsf strCcil[)ir As.String· = ''c:\colendor\11 · 
· 
· 
'ConstrtJttfile~orne for. ~~flng:c~lendorcontenfs 
. 
. . . 
.. 
strCafFile 
MiqQsQff.VisuoiBosic.Left(cboMonth.Text, 3) :&~· ... 
.. 
. 
txtY eqr ,Text 
strCciiDir & strCoJFile & ".txt'' · 
... • ·•· ·rfarrBoxes(i}.Text > m'Then 
;An entry h<ls.been ·-· --·""·-·· 
intDayNd = Vol(qrrl,obefs(i}•Text) 
. . . · ... 
'Writ~ text bo)(. ~tm"fber, day nu~ber and t~xt . 
·.· Wrifeli.ne(fi i, int0qy,N9,arr8Qies{i).Text) 
End w· 
· · · 
. 'C~~not save ;(probably becal.lse no dir~ttC)r:y) 
lfErr.Num.ber = 76Then 
· · ·· · 
263 

264 
Dim strCoiFile As String 
Dim stf'CqlSpecAs String 
Dim )As. Integer 
Dim intDayl'l.q As lnt~ger 
.··.··· DimstrDiaryEntry'AsString 
: \::< ,: c ' 
' 
; ' 
' ' 
" 
'~ 
: 
' '0 
.. · ~sstJ:me directory. already exists · .. · .. 
.. 
. C9~.st strCalDirAs §tfing = ncr\cdlendar\11 

26S 

Random access files 
Random access files store data in a record-based format. The file consists of a 
number of records, each of which has the same size and layout. The advantage over 
sequential files is that you can read and write records in any order; records are 
accessed by specifying a record number. However, random access files are not 
suitable for variable-length data. 
Record structure 
You must define the structure of the records before attempting to read or write 
them. This is done with a Structure declaration, which has the following form: 
Structure recordtype 
Public variable 7 As type 7 
Public variable2 As type2 
End Structure 
Any string variables must be given an explicit length by declaring them as follows: 
<VBFixedString(length)> Public variable As String 
For example: 
< VBFixedString(40)> Public CompanyName As String 
This allows you to store a company name of up to 40 characters. If the string is 
shorter than the specified length, it is padded with spaces; if it is longer, the string 
is truncated. 
The Structure statement is usually included in the Declarations section of the form 
or module. 
Accessing records 
266 
Records are read or written in three stages: opening the file; reading or writing the 
data; and closing the file. 
The FileOpen statement has the following format: 
FileOpen{number, filename, OpenMode.Random, , , recordlength) 
The easiest way to calculate the recordlength is using the Len function, whose 
argument is a record variable of the record type defined in the Structure statement. 

Once opened, you can both write to and read from the file; you do not need to close 
the file in between the writing and reading operations. 
To write records, you must first declare a variable of the record type previously 
defined. This will be in the format: 
Dim recordvariable As recordtype 
You must then fill the record by assigning values to the individual variables, using 
statements in the format: 
recordvariable.variable = expression 
A completed record is written with a FilePut statement, as follows: 
FilePut(number, recordvariable, recordnumber) 
The recordnumber starts at 1 for the first record. If the number is beyond the current 
end-of-file, the file is extended. (Unused records will contain rubbish unless 
specifically cleared.) 
Data is read from the file using a FileGet statement, as follows: 
FileGet(number, recordvariable, recordnumber) 
The individual variables in the recordvariable are filled with the corresponding 
data from the record. Close the file with FileClose, as before. 
The procedures below provide alternative File operations for the Calendar 
program, this time storing the data in a random access file. 
' 
' 
'0 
"' 
The>EOF,LOC an~ LOF fu~ctiorrs can be used 
with randtrn access files~ EOF [s .of little 
lise~ 'htce you are Mf usually readin.s a file 
from besinningtoen(lOFglves the length. 
of the}ile in bytes. t(}C ret~rns the n•m~er 
of .tbe last record read or written.. . 
. 
Yorl can calculate the number of 
records in a randum access file by 
. dlvidint LOf hy the record hngth. . 
fo get the record lellgth/use. LEN 
.. with the record varfable n its 
267 

Calendar files (2) 
268 
'Insert in Declarations sectiol'l 
Structure CqlendorData 
· Public shoDayNumber As Short 
.. 
<VBFixedString(30}> Public strT:extEntry As String. 
End Structure 
Private Sub mnufileSCIYe_CIIck(~··L 
Handles ·mnuFlleSave.Ciick 
'Saves when user presses Cfri:S . 
Dim strCaiFile As String·· 
Dim strCaiSpec.AsString 
Dim i As Short 
Dim shoDayNoAs Sharf 
Dim MonthData As CalendarData. 
'Assume directory already exists for storing files 
Const.strCaiDir As String = 11C:\calenddr\" 
'Construct filename. for storing calendar conte1:1fs ·. 
strCaiFile = Microsoft.VisuaiBasic.Left{cboMonth.Texf, 3) &~. 
txt Year .Jexf 
strCaiSpet ,;;. strCaiDir & strCofFile & ".daf' 
Try 
Flle0pen(2, strCaiSpec1 OpenModeA~and?m, , ''-
. L!;lo(MonthData}) 
.'Write away all entries 
Fori= OJo 36 
shoDayNo = Val(arrlabels(i).Text) 
'Get date 
'Set up record 
. 
MonthDota,shoDayNumber =•·.shoDayNo 
MonthData.strTextEntry = arrBoxes(i).Text 
'Write record to file 
rilePut(2, MonthData, i + 1) 
Next i 

269 

270 

Simple error handling; the complete appli-
cation should include error handling for 
every possible type of error that may occur 
Attempt to open the file for a 
particular month fails when the 
Calendar folder does not exist in 
the root directory of drive C 
271 

Exercises 
272 
1 
In the Membership pro-
gram, add a combo box to 
the Main Menu to hold a 
list of members. Allow 
new names to be typed at 
the top of the Combo box. 
Add a command button 
which, when clicked, will 
add any new name to the 
list in the combo box. 
2 
Add code to the FileiSave 
As option to create a file 
with a MEM extension (using a standard dialog box to enter the name). The 
file should contain the list of members. 
3 
Add code for FileiSave to update the membership file and for FileiOpen to 
fill the combo box from the list in the file. 
4 
Add code for the FileiSave option on the Comments screen. The current 
comments should be added to a text file with a filename based on the 
member's name. The OK button should also save the comments. 
5 
Add code so that the current member's comments (if any) are displayed 
when the Comments screen is loaded. 
6 
Add code for the File I Save option on the Details screen. The member's details 
should be stored as a single record in a file with the same name as the 
membership list file but an extension of DTL. The OK button should also 
save the data. 
7 
Add code so that the current member's details (if any) are displayed when the 
Details screen is loaded. 
For solutions to these exercises, see page 323. 


Pictures 
274 
The picture box control displays any type of image file, icon file or metafile. 
The Image property can be set at design time and specifies the picture to be 
displayed. In that case, the picture file is incorporated into the form file (and hence 
in the executable file, making it considerably larger). Alternatively, you can 
specify the picture at run-time; the picture file is then held separately from the 
executable file (but must be supplied with the application). The value of the Image 
property must be specified as a Bitmap object. 
The Height and Width properties set the size of the picture box; the Left and Top 
properties determine the position of the picture on the form. The Move method 
moves the picture to a new position. 
The SizeMode property determines the way in which the picture is displayed, as 
follows: 
e 
Normal: The picture is displayed at its normal size and is positioned in the 
top left-hand corner of the picture box. If the box is not large enough for the 
whole picture, only the top left-hand corner is shown. 
e 
Center Image: The picture is displayed at normal size in the centre of the box. 
e 
Stretchlmage: The image is stretched horizontally and vertically so that it 
fills the box. 
e 
AutoSize: The picture box is resized to fit the image. The top left-hand corner 
stays in the same position. 
If you need a border around the edge of the picture box, this is applied with the 
BorderStyle property. 
The Visible property can be set to False to hide the picture. 
The procedure below extends the File Viewer program from Chapter 10 to display 
the contents of an image file. The name of the file is stored in a label above the picture 
box. The full specification of the filename (including the path) is stored in a string. 
This string is then used to define a new Bitmap object, which in turn is used as the 
new value for the Image property. 

File viewer 2 
' 
~ 
c, '< 
c 
• 
0 Dim QmpSelededlmage·A~o Bitmdp·>· 
Pim strSeJected Pic 0 As 
0 String 
Click button to display picture 
of file currently selected 
'· 
. 
. 
strSelectedPk: == :JbiCurrentP:Pth.Text 8t._0 ° 
0 
lstFii~List.lt~ms.ftem{lstFReListSelectedh1dex}o 
bmpSelectecJfmag¢. ~ New Bitmqp(strSelededPk). 
0 
000 
• picfileVieoW;In:lage = 
0 :brnpSelectedlmage 
0 
275 

Lines and shapes 
276 
Lines and shapes are drawn on a form or the surface of a control using the Graphics 
object. Drawing is usually done inside an object's Paint event procedure. The first 
task is to declare a Graphics variable with a Dim statement, following which the 
object is given a value that is a reference to the form or control's Graphics object; 
for example: 
Dim objG As System.Drawing.Graphics 
objG = e.Graphics 
The 'e' parameter supplied with the Paint event has a Graphics property that points 
to the form or control's Graphics object. The Paint event is called whenever the 
contents of the object need to be redrawn: for example, when the form is loaded or 
moved or when the window is brought to the top of the display. You can also force 
an object to be redrawn by calling its Invalidate method. 
To draw a line or shape, you can also need to specify the colour, width and other 
parameters of the drawing. This is done with two further objects: 
e 
The Pen object defines the colour, width and style (e.g. unbroken or dotted) 
of lines. 
e 
The Brush object defines the colour and style (solid, hatched etc.) of filled 
objects. You use a different object for solid filling (SolidBrush) and hatched 
filling (HatchBrush). 
The pen and brush are created with statements as follows: 
Dim objPen As New Pen(Color.co/our, width) 
Dim objBrush As New SolidBrush(Color.co/our) 
The colour value is a standard Windows colour; width is a single value representing 
line width. 
When the pen and brush have been created, their properties can be changed. For 
example: 
ObjPen.Width = 2.5 
ObjPen.Color = Color.Biue 
ObjPen.DashStyle = Drawing2D.DashStyle.DashDot 

The lines and shapes are drawn with the various Graphics methods: 
e 
TheDrawLinemethoddraws astraightline with a specified pen between two 
pairs of co-ordinates. 
e 
The DrawRectangle method draws a rectangle with a specified pen; the 
rectangle is defined by the co-ordinates of the top left-hand corner, the width 
and height. 
e 
TheDrawEllipsemethod draws an ellipse with a specified pen; the height and 
width of the ellipse are determined by a bounding rectangle, defined as above. 
If the height and width are the same, the result is a circle. 
e 
The FillEllipse method draws a filled ellipse with the fill colour defined by 
a brush. 
These are several variations of these methods, depending on what parameters you 
want to use. There are also a number of other drawing tools. 
The program below demonstrates the use of these graphical features. The program 
also makes use of a timer to generate changes to the display; timers are described 
in the next section. 
Created with 
DrawRectang le 
Created 
Fill Ellipse 
DrawEIIipse 
Created with 
Drawline 
277 

Traffic lights 
.Pul»lic Class frmGraphlcsiXomple 
·rnh.erits ._ .Syste;, .Wi ndows.F<lrms. Form_ ... 
' 
.. -
. 
. 
. 
Dim .. shoStoge As Short 
. 
-
#Reg.ion 1' Windows Form Deiig ner g~neroted code " 
#End Region · 
278 
P*at• Sub Picture89x1 ... Palnf( ... l.., 
· 
. 
Handles. PlctureBox1.Paillt 
Dim objPid(Jre As Syst~m.[)rowing,Grophics 
'Set up pen,_ brush ond graphics objects 
Dim objPerlAs New .Pen{System.Drowing.Color.Biack, 2) 
Dim obiBrush As New Solitf.Brysh(C:olor.Red) 
pbjPidure. = e. Graphics 
. 
'Draw rectangle and verticollines 
objPicture:DrcswRectangle(obiPen, 40/ 20, 401 110) 
objPicture.DrawLine{C>biPen,. 55 1 130, 55, 350) 
objPidure.Dfawline{objPen,-65, 130, 6.5, 350} _ 
objPen.Widfh = l 
Select Case shoStage 
Case 0 To 1 
'Orow filled _rEfd circle 
objPich)re.FiUEIIipse(objBrush, 45, 25, 30, .3Q) 
'Dravramber and green cirdes 
obiPen .. Color .:::;; System.Drawing.C()Ior;Goldenrod. 
obtpicture.DrowEllipse{objPen, 45, 60, 30, 30) 
objPen.Color = System.DraV{ing~Color~Green 
objPicture.DrawEIIipse(objPen1 45, 95, 30, 30) 
Cose2. 
'Red and amber.-
obfBrush,Color . = System.Drawing.Color.Red 
objPicture.FiiiEIIipse(obfBrush) 45, 251 30, 30} 
·-objBrush.Color = System.Drawing;Color.Goldenrod 

~bj~icfure~FiiiEilip~~(qpjBrush~ AS, •60,. 30, 3QJ: 
o~jPer:1.Colbr = 
.... System .Orawir:1g .Color. Gr~Em 
·opjPict~.~re.Dtt:lwEUips~(objPen;45, 95~ 30,30) 
.CCise.a Jot{ 
· 
· · · ···· · 
· 
· · 
· 
.. ·.· '<?tefm .·.··· .. ·. 
. . .. ·· . . 
.· ····•••·• 
obJPen.Color . = System~Drawing:Colot:~!llc:i · 
· · · ()l;)jPidure.OrawEllipse(objPeri, .45,:251 3Q., 30) .. · 
·•··• .objPen .. Color = 
Syst~ni. brawln~JJ.Color. G~ldenroCI 
.. · obiPi~ture,DrqwEmpse(o!J,jP~n, 45, 601 30, 30) · 
·· objBrush;Cplor ·=·Systefl1.Qrqwin~.Col.or.G~e~n 
objPidure.FiUfllipse(qbjBrusn; 45, 95, 3(), 30) · 
CaseS 
. · 
. 
. ···· 
1A~ber 
. 
.· .... · ... ··. 
obiPeil.Color. ·.=.··System. Drt:IWif1g .Color.R~d · 
.... 
obieieture.DrawEtlips~(objPen, AS, 25; 30, 30) 
obiBrush.Col&. ·-==• System~Drt:IWing.Color.Goldenrod 
· objPicture.filiEIIips~(obj.Brl.lsh, 45, 60, 30, 3()) 
.. 
objPen .. Color =.·.· Syst~m.Dra~ing.Col6r.G.J:een · 
• 
.· objPicture;QrawEIIipse(objPeni 45, 95, 30, 30) 
·· EIJd Sele~t 
.· 
· 
· 
· · 
· 
.·. · 
End Sub • 
Prl,.re .s1Jb bft~Sfcld;...Cikk(~·~l Hat~dl••• ~~n~tart.oCiick ·.· 
Pitture~oxl,lrwalidate{} 
·· 
Tirnerl.EnC1bled0. = True 
End Sub .. 
. 
. 
. 
. . 
Prlv0t. SIJb b'-'stop_ Click( ••• ) lfanclles btnStop.C:IIc~ . 
·· Jirn~t l.Enabled ;:::: False 
· 
. End Sub 
279 

Using text 
280 
You can also draw text on a graphics object. For this you need to define a font using 
the Font object. This object is created in a similar way to the pen and brush: 
Dim fontobiect As New Font(font, size, style) 
The style is optional and specifies the use of bold, italic etc. You can combine two 
or more styles with the Or operator (for instance, 'FontStyle.Bold Or 
FontStyle.Underline'). For example: 
Dim objfont As New Font("Arial", 12, FontStyle.Bold) 
The text is drawn using the DrawString method which has as its parameters the 
text, font, brush and co-ordinates of the top-hand comer of the text; for example: 
objGraphics.DrawString("Lights!", objfont, objBrush, 30, 0) 
Note that you can use 'Me.Font' if you want to use the current font from the form 
or control. 
Text added by 
DrawString method 

Timers 
1he Timer control allows you to create programs in which events occur at 
particular times or after specific periods: for instance, clocks, reminder programs 
and programs that require a sequence of regular events. The previous example used 
a timer to change the graphics display every two or four seconds. 
The Timer control is added to the component tray; it has no visible element. There 
are two important properties: 
e 
The Enabled property is set to True when you want the timer to start running. 
e 
The Interval property specifies how frequently you want the timer event to 
be generated. 
The value for the Interval is given in milliseconds (so a value of 5000 would generate 
an event every 5 seconds). When the specified interval has elapsed the timer's Tick 
event occurs and the timer starts counting again. 
The program below demonstrates the use of a timer for generating a reminder at a 
time entered by the user. 
Enter time at which 
reminder is to be 
displayed 
Switch on 
reminder 
Reminder 
message 
Acknowledge 
reminder 
Cancel reminder 
after it has been set 
281 

Alarm clock 
·Public Class frmAiarm··. 
#Region ~~.Windows foim Oesigher. generoted . code"·· 
#EndRegion 
. 
· · · 
· 
· 
· 
282 
Pl"iYaJ4 Sub · 
btnSetAI~rm_CIIclc( ••. )_ 
· 
Handles btnSetAiarm~Ciick 
c 
' ,' 
' 
' 
' ' 
' 
' 
' 
" 
' ' 
' 
' 
" 
' ' 
' 
' 
'~ 
' 
Dtrn objMessageFont As. Font. · 
'Set font for message 
.. 
. 
... qb,jMessageFe>nt := New Font(lbiTimeReached ;Fe>nt~-
. 
FontFamily, 10, FontStyle,Regulor) .. 
If txtAiarrnTim¢:de><t = 'm. Thef"l .. ·. 
· . 
. . 
. Me$sogeBox.Sh()VV(''Must enter o .time in the form hh:mm",;.;; 
't'firne not· set11/ MessogeBoxButtons~OK,. . 
M~ssogeBoxlc().n.Worning) .· 
·. . 
··'"'" 
·Else 
'Display message when alarm set 
. 
lbiTi meReached.Font ==. obiMessogeFont·· ... 
lbiTfmeRetu:hed:ForeCe>lor•.;:;:;:: · .Color .Block 
lbiTirr,eReoched.Te><t = liA.Iarm is set" 
'Disable Acknowl~dge button 
btnAcktiowledge.Eryabf~d· = Folse 
'Turn on timer 
< 
. Timerl, !;nab led ==.True . 
'Minimise window 
Me.WindqwState =: .• fqrrnWindowState.Mlnimi.zed 
End If 
·En(:{ Sub 
Pnvc:de $ub ~nCan~JAiarm_CIIck( •.• )_ ·· 
· 
· 
Handles btneara~IAiann.Ciick 
· Oirn obiMessageFo~t As Fqrit 

:[}}splay. m~ssC1ge·· when .. al(lrm c:(lncelled 
·. objMesS<lgefont =;= New J¢nt(lblJlmeReache~.Font:_ 
....•. · . . 
. •·.· 
FontFamily, 10, Fo~tStyle.R~gular) 
lbiTimeReoch~&~ont = objMess~gefont 
. 
· .. · lbiJi~eReoched.PoreColor = Color.Black 
" 
' 
~ 
, 
~ ' 
; ' 
' 
, 
' ~ 
. ;Disob1e Acknowledge button and turn· off timer 
btnAcknowledge.Enobled == Fq~lse 
. 
Timer 1. Enabled = false 
Dim iritC:,utrentHour As lnteg~r 
.Dim·lntCurrentM,inute .As·lnteger: 
Dim intAlormHour ·As lnt~ger 
Q.im intAiarmMinute As Integer 
Dim.. objMessageFont As Fon. t 
, ' ' 
, , '" " 
~ ' 
' 
, 
" 
" 
, 
.. ·. ;Get <;urrent time 
intCurrentHollr ~ Now,Hour 
. JrltCurrentM,inute: = Now .. Minute 
1GeHime eMtere,d by user 
il'itAiarrnH<Du~ ·= Ji.meV(llue(MAiarmTime.TE}xf).Hour 
.. 
•intAiarmMi!Jute 
Tirm:Nalue(MAiarmTime.Text).Minute 
lf·j~tCurr~ntHou~ = intAiarmHour.And intCurrentMi!Jute• 
'At time spedfied by user 
'Disable .buttons· . 
< btnSefAiorm.Enabled =· False 
btnCanceiAiarm;Enabled = Folse 
283 

lbiTirneReoch~t~Lr~xt = "Timelu 
'Enable Acknowl~dge >?uf1"on 
.btnAcknowledge.Endbled :;; T~ue 
'Restore window 
.Me.WindowStote ::= 
. End If 
End Sub 
Private Sub btnAckrlowtedalt_CIIckt•··l·•····. 
···Handles btnAckn~edge.CIICk··· 
'Endble Sef and Cancelbufl'pns; disable Acknowl~dge button. 
btnSetAiar~.Enabled = T~ue 
· . ·. 
· 
btnCanceiAiarm.EnableH :;; Tru~ 
btnAtknowledge.Enabled = Fol~e .. 
'Clear text boxes onc;Htirn ofU~ri1er 
lblTi m~Reoched.T ext = "'' 
" 
" 
' 
' 
~ 
·txtAiarmTime.Text. = 1111 
TimerLEnabled = Fcds~ 
End Sub 
End Class 
284 

Printing 
Printing is achieved by creating an instance of the PrintDocument class. You can 
then set the properties of this document and fill it with text, before finally sending 
it to the printer with the Print method. 
Text and pictures are added to the document using the methods of the Graphics 
object, as described earlier. The Graphics object is available as a parameter in the 
document's PrintPage event, which occurs each time the document is required 
(for example, when previewing or printing the document). 
Margins and other document settings are available in the document's 
DefaultPageSettings property. 
A number of standard dialog boxes are available as controls to help you set up a 
document: 
e 
The PrintDialog displays a standard Print dialog and can be used to adjust 
printer settings just before the document is printed. 
e 
The PageSetupDialog allows you to change paper size, orientation and 
margins, as well as giving you access to the printer settings. 
e 
The PrintPreviewDialog produces a display of the document as it will 
appear when printed, with all the standard options available. 
e 
The PrintPreviewControl object displays a preview of document in an area 
on the form, without any of the standard preview options. 
In each case, there is a Document property, which must be setto the name of your 
PrintDocument before the dialogs are displayed. 
You can also use the FontDialog to change the font for a text selection. 
The example below illustrates the use of all these features. Text can be entered in 
the top left-hand text box to be printed as a title. Below that is a rich text box, which 
allows you to change the font (including typeface, point size and text style) for any 
part of the text. The following buttons affect the rich text box: 
e 
The Load button calls a standard Open dialog to select an RTF file, which is 
added to the rich text box. 
e 
The Save button saves the contents of the box in a named file. 
e 
The Font button lets you change the font for the text selected in the box. 
285 

On the right of the window is a PrintPreviewControl, which is updated with the 
current contents by clicking on the Update button. The three buttons below allow 
you to change the page setup, preview the document in a separate window and print 
the final document. 
Print example 
· Public Class frmPrlntExample 
·Inherits System.Wi ndows.Forms. Form 
' ' 
' ' ' ,' 
' ' ' 
' 
'~ 
~' 
#Region " Windows Form Designer generated code ll 
:fltEI)d Region. 
··PriVate Sub PrintD0c:ument1:PrlntPage(:.~) .... ·· 
Handles· PrlntDocurnenn ~PrlntPQge 
·· blm objPrintFoot As F6nt · 
· 
· Dim sngL.eft, sl)gT op As Single . . 
Qim objDo!=ument As Graphics ~ e. Graphics • 
286 

287 

288 

Page Setup dialog, 
adivated by 
PageSetupDialog 
control 
Print Preview dialog, 
activated by 
PrintPreviewDialog 
control 
289 

Exercises 
290 
1 
Add a bitmap to the Members program's main menu. 
2 
Add a FileiPrint command to the Members program's Main Menu window, 
so that the full details, including comments, can be printed. 
For solutions to these exercises, see page 332. 


1 
Overview (p24) 
292 
1 
Click on the Start button and All Programs. Click on the Microsoft Visual 
Basic 2005 application icon. 
Click on the New Project button. In the Name box, replace 
'WindowsApplicationl' with 'Membership Database' and click on OK. 
Select FileiSave All. Click on the Browse button, select C:\ as the location 
and click on Open. 
2 
Select WindowiReset Window Layout. Click on OK to confirm and then on 
OK on the Options dialog. 
The main window should contain the Form Design tab (containing Forml). 
The Solution Explorer and Properties windows should be docked and there 
should be a tab for the Data Sources window. The Toolbox window should 
be hidden. 
3 
Click on the Toolbox button to show the window, then click on 
Drag the Data Sources tab into the main window, then click on its Close 
button. 
Click on the 
button to show the properties in alphabetical order. 
Move windows by dragging the title bar; resize by dragging the edges or 
comers. Maximise by clicking on the Maximise button. 
4 
Click on the Help menu, then on Index. In the 'filtered by' box, select 
'Visual Basic'; in the 'Look for' box, type 'properties w'; click on 
'Properties Window' at the top of the list of topics. After using the help, 
click on the Close button on the help page. 
5 
Click on the Minimise button in the main window. Then click on the 
Membership Database button in the taskbar. 
6 
Click on File in the main window menu bar and then on Exit. If you are asked 
to save the changes, click on Yes. 

2 
Forms {p46) 
(Note that the dimensions of these forms do not have to be exactly as given below.) 
1 
Click on the Start button and then on the Microsoft Visual Basic option. On 
the Start Page, double-click on Membership Database. 
2 
Change the properties for Form1 as follows: 
Name: 
Text: 
FormBorderStyle: 
MinimizeBox: 
MaximizeBox: 
Location 
Size: 
ShowinTaskbar: 
frmMainMenu 
Membership Database 
FixedSingle 
True (default) 
False 
0, 0 (default) 
450,425 
True 
Save using FileiSave Forml.vb As in the Membership Database directory, 
giving it the name 'frmMainMenu'. In Windows Explorer, delete the two 
Form1 files. 
3 
Use ProjectiAdd Windows Form to add a form. In the Add New Item dialog, 
enter a name of 'frmDetails'. Change the properties as follows: 
Name: 
frmDetails 
Text: 
Member Details 
FormBorderStyle: 
FixedSingle 
MinimizeBox: 
True (default) 
MaximizeBox: 
False 
Location: 
100, 100 
Size: 
500, 350 
ShowinTaskbar: 
False 
StartPosition: 
Manual 
Save the form in the Membership Database directory with the name 
'frmDetails'. 
4 
Use ProjectiAdd Windows Form to add aform. Change the properties as 
follows:. 
Name: 
Text: 
frmComments 
Comments 
293 

294 
FormBorderStyle: 
MinimizeBox: 
Maximize Box: 
Location: 
Size: 
ShowlnTaskbar: 
StartPosition: 
Sizable (default) 
True (default) 
True (default) 
200,200 
500,250 
False 
Manual 
Save the form in the Membership Database directory with the name 
'frmComments'. 
5 
Click on Membership Database in the Solution Explorer window, then 
change the Project File in the Properties window to 'Members.vbproj'. 
6 
Use FileiSave All. 
7 
Right-click on the Membership Database entry in the Solution Explorer 
window and select Properties. List the forms in the Startup Object box and 
select frmMainMenu. Click on OK. 
8 
Press [FS] to run the application. The first window should be displayed. 
Click on the Close box to close it down. Click on the Close box on the Output 
window. 

3 
Controls (p78) 
1 
Control properties are as follows: 
Labels 
Name: 
lblTitle 
lblMainMenu 
Text: 
Member Manager 
MAIN MENU 
TextAlign: 
TopCenter 
TopCenter 
Font: 
14 point, bold 
12 point, bold 
Location: 
50,24 
48,64 
Size: 
345,25 
345, 25 
Buttons 
Name: 
btnMemberDetails 
btnComments 
Text: 
&Member Details 
&Comments 
Location: 
66, 288 
250, 288 
Size: 
120,32 
120, 32 
Name: 
btnExit 
Text: 
E&xit 
Location: 
176, 344 
Size: 
80, 32 
Form 
Name: 
frmMainMenu 
AcceptButton: 
btnMemberDetails 
CancelButton: 
btnExit 
2 
Use ProjectiAdd New Item to add a new Windows Form. Change the 
properties as follows: 
Name: 
frmPassword 
Text: 
Password 
FormBorderStyle: 
FixedDialog 
ControlBox: 
False 
Location: 
180, 180 
Size: 
280, 190 
ShowlnTaskbar: 
False 
29S 

296 
Add the following controls: 
Label 
Name: 
Text: 
Font: 
Location: 
Size: 
Text box 
Name: 
Text: 
Font: 
PasswordChar: 
Location: 
Size: 
Buttons 
Name: 
Text: 
Location: 
Size: 
lblEnter 
Enter your &password: 
Arial, 10pt 
64,24 
140,20 
txtPassword 
(blank) 
Arial, 10pt 
* 
64,24 
140,25 
btnOK 
&OK 
32, 104 
80, 32 
btnCancel 
&Cancel 
152, 104 
80, 32 
Save the form as frmPassword.vb in the Membership Database directory. 
Amend the form properties as follows: 
AcceptB utton: 
CancelButton: 
btnOK 
btnCancel 
3 
Control properties are as follows: 
Group boxes 
Name: 
grpPersonal 
Text: 
Personal Details 
Location: 
32, 72 
Size: 
380, 150 
Name: 
grpSubs 
Text: 
Subscription 
Location: 
176,248 
Size: 
150, 80 
grpMType 
Membership Type 
32,248 
130, 80 

Label (form) 
Name: 
lblMemNo 
Text: 
&Member No: 
TextAlign: 
TopRight 
Location: 
32,20 
Size: 
64, 18 
Text box (form) 
Name: 
txtMemNo 
Text: 
(blank) 
Location: 
104, 16 
Size: 
105,25 
Labels (Personal Details) 
Name: 
lblName 
Text: 
TextAlign: 
Location: 
Size: 
&Name: 
Top Right 
16,28 
80, 18 
Text boxes (Personal Details) 
Name: 
txtName 
Text: 
(blank) 
Multiline: 
False 
Location: 
136,96 
Size: 
218,25 
Radio buttons (Membership Type) 
Name: 
radFull 
Text: 
&Full 
Checked: 
True 
Location: 
Size: 
32,24 
80, 18 
Labels (Membership Type) 
Name: 
Text: 
TextAlign: 
Location 
lblAmount 
Amoun&t 
Top Right 
16,20 
lblAddress 
&Address: 
Top Right 
16,68 
80, 18 
txtAddress 
(blank) 
True 
136, 136 
218, 75 
radAssociate 
A&ssociate 
False 
32,48 
80, 18 
lblPaidOn 
&Paid on: 
TopRight 
16,52 
297 

298 
Size: 
50, 18 
50, 18 
Text boxes (Membership Type) 
Name: 
txtAmount 
txtPaidOn 
Text: 
(blank) 
(blank) 
Location: 
72, 16 
72,48 
Size: 
65,25 
65,25 
Buttons (form) 
Name: 
btnOK 
btnCancel 
Text: 
&OK 
&Cancel 
Location: 
344,256 
344,296 
Size: 
65, 32 
65,32 
Amend the form properties as follows: 
AcceptButton: 
btnOK 
CancelButton: 
btnCancel 
4 
Control properties are as follows: 
Text box 
Name: 
txtComments 
Text: 
(blank) 
Multiline: 
True 
ScrollBars: 
Vertical 
Location: 
0,0 
Size: 
446, 185 
Buttons 
Name: 
btnOK 
btnCancel 
Text: 
&OK 
&Cancel 
Location: 
96,200 
269, 200 
Size: 
80, 32 
80,32 
5 
Save using FileiSave All. Run the program by pressing [FS]. You can click 
on any of the three Main Menu buttons but they will have no effect as yet. 
Close the program with DebugiStop Debugging or by clicking on the Close 
button. Close the Output window. 

4 
Coding events (p 114) 
(Note that, to save space, most blank lines have been removed from program 
listings.) 
1 
Display the frmMainMenu form, double-click on the Member Details 
button and enter the following procedure in the Code window: 
Private Sub btnMemberDetails_ Click( ... ) Handles 
btnMemberDetails.Ciick 
Dim frmvDetails As New frmDetails 
frmvDetails.Show() 
End Sub 
2 
Double-click on the Comments button and enter the following procedure: 
Private Sub btnComments_Ciick( ... ) Handles btnComments.Ciick 
Dim frmvComments As New frmComments 
frmvComments.Show() 
End Sub 
3 
Double-click on the Exit button and enter the following procedure: 
Private Sub btnExit_ Click( ... ) Handles btnExit.Ciick 
Me.Ciose() 
End Sub 
4 
At the design stage, change the StartPosition property to CenterScreen 
5 
Display the frmDetails form and add a combo box control with the 
following properties: 
Label 
Name: 
Text: 
TextAlign: 
Location: 
Size: 
Combo box 
Name: 
Text: 
DropDownStyle: 
lblRegion 
Region: 
TopRight 
264, 20 
40, 17 
cboRegion 
(blank) 
DropDownList 
299 

300 
Sorted: 
Location: 
Size: 
True 
312, 16 
100,22 
Double-click on a blank part of the form and add the following procedure: 
Private Sub frmDetails_Load( ... ) Handles MyBase.Load 
cboRegion.ltems.Add("North") 
cboRegion.ltems.Add("South") 
cboReg ion .ltems.Add ("East") 
cboRegion.ltems.Add("West") 
End Sub 
6 
Double-click on the OK button and enter the following procedure: 
Private Sub btnOK_ Click( ... ) Handles btnOK.Ciick 
Me. Close() 
End Sub 
Double-click on the Cancel button and enter the following procedure: 
Private Sub btnCancel_ Click( ... ) Handles btnCancei.Ciick 
Me.Ciose() 
End Sub 
7 
Display the Comments form and double-click on it. In the Procedure box in 
the top right of the window, select Resize and enter the following procedure: 
Private Sub frmComments_Resize( ... ) Handles MyBase.Resize 
txtComments.T op = 0 
txtComments.Left = 0 
txtComments.Height = Me.Height- 72 
txtComments.Width = Me.Width - 8 
btnOK.Top = Me.Height- 64 
btnCancei.Top = btnOK.Top 
btnOK.Left = Me.Width I 2 - 55 - btnOK.Width 
btnCancei.Left = Me.Width I 2 + 55 
End Sub 
(Later, you will need to add instructions to cope with the window being 
minimised or made too small to display the text box.) 

8 
Double-click on the OK button and enter the following procedure: 
Private Sub btnOK_Ciick( ... ) Handles btnOK.Ciick 
Me.Ciose() 
End Sub 
Double-click on the Cancel button and enter the following procedure: 
Private Sub btnCancel_ Click( ... ) Handles btnCancei.Ciick 
Me. Close() 
End Sub 
301 

5 
Variables (p 144) 
302 
1 
Set up the form and add the following procedures: 
Option Strict Off 
Option Explicit On 
Friend Class frmUnits 
Inherits System.Windows.Forms.Form 
#Region "Windows Form Designer generated code " 
#End Region 
Private Sub btnCmlnch_Ciick( ... ) Handles btnCmlnch.Ciick 
Dim declnches As Single 
Dim decCm As Single 
Const decCmPerlnch As Single = 2.54 
decCm = Val(txtEntry.Text) 
declnches = (lnt((decCm I decCmPerlnch * 1 00) + _ 
0.5)) I 1 oo 
txtResult.Text = Str(declnches) 
lbiEntry.T ext = "em" 
lbiResult.Text = "Inches" 
End Sub 
Private Sub btnExit_ Click( ... ) Handles btnExit.Ciick 
Me. Close() 
End Sub 
Private Sub btnlnchCm_Ciick( ... ) Handles btnlnchCm.Ciick 
Dim declnches As Single 
Dim decCm As Single 
Co nsf decCmPerlnch As Single = 2.54 
declnches = Val(txtEntry.Text) 
decCm = (lnt((declnches * decCmPerlnch * 1 00) + _ 
0.5)) I 1 oo 
txtResult.Text = Str(decCm) 
lbiEntry.Text = "Inches" 
lbiResult.Text = "em" 
End Sub 
Private Sub btnKglb_ Click( ... ) Handles btnKglb.Ciick 
Dim decPounds As Single 

Dim decKg .As Single 
Const decKgPerPound As Single = 0.453 
decKg = Val(txtEntry.Text) 
decPounds = (lnt((decKg I decKgPerPound * 1 00) + _ 
0.5)) I 1 oo 
txtResult.Text = Str(decPounds) 
lbiEntry.Text = "Kg" 
lbiResult.Text = "Pounds" 
End Sub 
Private Sub btnlbKg_Ciick( ... ) Handles btnlbKg.Ciick 
Dim decPounds As Single 
Dim decKg As Single 
Const decKgPerlb As Single = 0.453 
decPounds = Val(txtEntry.Text) 
decKg = (lnt((decPounds * decKgPerlb * 1 00) + 0.5)) I 100 
txtResult.T ext = Str(decKg) 
lbiEntry.Text = "Pounds" 
lbiResult.Text = "Kg" 
End Sub 
Private Sub btnlitrePint_Ciick( ... ) Handles btnlitrePint.Ciick 
Dim decPints As Single 
Dim declitres As Single 
Const declitresPerPint As Single = 0.568 
declitres = Val(txtEntry.Text) 
decPints = (lnt((declitres I declitresPerPint * 1 00) + _ 
0.5)) I 100 
txtResult.Text = Str(decPints) 
lbiEntry.Text = "Litres" 
lbiResult.Text = "Pints" 
End Sub 
Private Sub btnPintlitre_Ciick( ... ) Handles btnPintlitre.Ciick 
Dim decPints As Single 
Dim declitres As Single 
Const declitresPerPint As Single = 0.568 
303 

304 
decPints = Val(txtEntry.Text) 
declitres = (lnt((decPints * declitresPerPint * 1 00) + _ 
0.5)) I 100 
txtResult.Text = Str(declitres) 
lbiEntry.T ext = "Pints" 
lbiResult.Text = "Litres" 
End Sub 
Private Sub txtEntry_TextChanged( ... ) Handles_ 
txtEntry.TextChanged 
lbiEntry.Text = "(Entry)" 
lbiResult.Text = "(Result)" 
txtResult.Text = "" 
End Sub 
End Class 
The result box's Enabled property should be False. The form's AcceptButton 
property is ' (none)'. 
2 
Add a text box called lblRep and then insert the following procedure: 
Private Sub cboRegion_SelectedValueChanged( ... )_ 
Handles cboRegion.SelectedValueChanged 
Dim strReps(3) As String 
Dim intSelectedRegion As Integer 
Dim strRep As String 
'Fill array (assume list box is sorted) 
strReps(O) = "M. Williams" 'East 
strReps(l) = "R. Walker" 'North 
strReps(2) = "J. Evans" 
'South 
strReps(3) = "D. Clarke" 'West 
'Get selection number and display 
'corresponding rep 
intSelectedRegion = cboRegion.Selectedlndex 
strRep = strReps(intSelectedRegion) 
lbiRep.T ext = "Rep: " & strRep 
End Sub 

3 
The following program uses two text boxes for entering the dates (txtDatel 
and txtDate2) and two for showing the results (txtDays and txtWeeks). The 
calculation is initiated by clicking on a button (btnCalculate). 
Public Class frmDateComparisons 
Inherits System,Windows.Forms.Form 
#Region 11 Windows Form Designer generated code 11 
#End Region 
Private Sub btnCalculate_ Click( ... ) Handles btnCalculate.Ciick 
Dim dteDate 1, dteDate2 As Date Time 
Dim intTotaiDays As Integer 
Dim shoNumWeeks, shoNumDays As Short 
'Get dates into date/time variables 
dteDate 1 = DateValue(txtDate 1.Text) 
dteDate2 = DateValue(txtDate2.Text) 
'Get difference in number of days 
intTotaiDays = dteDate2.ToOADate- dteDate1.ToOADate 
'Convert to weeks and days 
shoNumWeeks = lnt(intTotaiDays I 7) 
shoNumDays = intTotaiDays Mod 7 
'Put answers back in text box 
txtWeeks.Text = shoNumWeeks 
txtDays.Text = shoNumDays 
End Sub 
End Class 
30S 

6 
Basic instructions (p 178) 
306 
1 
The function is as follows: 
Public Function PasswordValid(strPassword As String) As Boolean 
'Add code here to read password from file (Assume "pass") 
If strPassword = "pass" Then 
PasswordValid = True 
Else 
PasswordValid = False 
End If 
End Function 
2 
The procedure is as follows: 
Public Sub AddDate(ByRef dteDateln As Date Time,_ 
ByRef strPeriod As String, ByRef shoExtra As Short, 
ByRef dteDateOut As DateTime, ByRef shoWDay As Short) 
Dim strUnits As String 
Dim shoMonthln, shoDayln, shoYearln As Short 
Dim shoMonthOut, shoYearOut As Short 
strUnits = UCase(VB.Left(LTrim(strPeriod), 1)) 
shoDayln = dteDateln.Day 'Extract date components 
shoMonthln = dteDateln.Month 
shoYearln = dteDateln.Year 
Select Case strUnits 'Calculate new date 
Case "D" 
dteDateOut = System.DateTime._ 
FromOADate(dteDateln.ToOADate + shoExtra) 
Case "W" 
dteDateOut = System.DateTime._ 
FromOADate(dteDateln.ToOADate + shoExtra * 7) 
Case "M" 
shoMonthOut = shoMonthln + shoExtra 
dteDateOut = DateSerial(shoYearln, shoMonthOut,_ 
shoDayln) 
Case "Y" 
shoYearOut = shoYearln + shoExtra 
dteDateOut = DateSerial(shoYearOut, shoMonthln,_ 
shoDayln) 

End Select 
shoWDay = Weekday(dteDateOut) 'Calculate weekday 
End Sub 
The following event procedure calls the calculation procedure: 
Private Sub btnCalculate_ Click( ... ) Handles btnCalculate.Ciick 
Dim dteDateOut, dteDateln As Date, shoWeekOut As Short 
dteDateln = DateValue(txtDateln.Text) 
AddDate(dteDateln, (txtType.Text), Val(txtAdd.Text),_ 
dteDateOut, shoWeekOut) 
txtResult.Text = CStr(dteDateO.ut) 
txtDayNumber.Text = CStr(shoWeekOut) 
End Sub 
3 
The function is as follows: 
Function SimplifyText(ByVal strTextln As String) As String 
Dim strTextOut As String, chr1 As Char 
Dim booWordStart As Boolean, i As Integer 
booWordStart = True 
i = 1 
strTextOut = 
1111 
Do While i < = Len(strTextln) 
chr 1 = Mid(str T extln, i, 1) 
If UCase(chr1) >="A" And UCase(chr1) <= "Z" Then 
If booWordStartThen 'Character is a letter 
chr1 = UCase(chr1) 
booWordStart = False 
End If 
strTextOut = strTextOut & chr1 'Add to output string 
Else 
'Character not letter • therefore next is start of new word 
booWordStart = True 
End If 
i += 1 
Loop 
Return strTextOut 
End Function 
307 

7 Classes (p204) 
308 
1 
The new class is as follows: 
Public Class clsNumericlabel 
'Derived class of label that displays numeric values on right of 
'label in black or red and text on left in blue 
'Base class on existing label class 
Inherits System.Windows.Forms.Label 
'Use private variables to store property value 
Private dbllabeiValue As Double 'Numeric value of text 
Private strlabeiValue As String 'Actual text 
Public Sub New() 
'Procedure called when label object is created 
'Change default colour to blue and alignment to Left 
Me.ForeColor = System.Drawing.Color.Biue 
Me.TextAiign = ContentAiignment.Middleleft 
'Change background colour to white 
Me.BackColor = System.Drawing.Color.PowderBiue 
'Set default label text 
Me.Text = "blank" 
End Sub 
Public Property LabeiValue() As String 
'Create property to hold label value 
Get 
'Return stored value of property 
Return strlabeiValue 
End Get 
Set(ByVal strValue As String) 
'Store new value of label's property 
dbllabeiValue = Val(strValue) 
strlabeiValue = strValue 
'Set text colour to black for positive number or zero, 
'red for negative number or blue for non-numeric 
Select Case dbllabeiValue 
Case Is> 0 
Me.ForeColor() = System.Drawing.Color.Biack 

Me.TextAiign = ContentAiignment.MiddleRight 
Me.Text = dbllabeiValue 
Case Is< 0 
Me.ForeColor() = System.Drawing.Color.Red 
Me. T extAiign = ContentAiignment.MiddleRight 
Me.Text = dbllabeiValue 
Case Else 
If strlabeiValue = "0" Then 
Me.ForeColor() = System.Drawing.Color.Biack 
Me.TextAiign = ContentAiignment.MiddleRight 
Me.Text = dbllabeiValue 
Else 
Me.ForeColor() = System.Drawing.Color.Biue 
Me.TextAiign = ContentAiignment.Middleleft 
Me.Text = strlabeiValue 
End If 
End Select 
End Set 
End Property 
Public Sub ClearBox() 
'Clear current value 
'Change in value results in call to Property procedure 
Me.LabeiValue = '"' 
End Sub 
End Class 
2 
The three controls at the top of the window have the following properties: 
Combo box 
Name: 
Sorted: 
DropDownStyle: 
Text box 
Name: 
Text: 
cboMonth 
False 
DropDownList 
txt Year 
(blank) 
309 

310 
Button 
Name: 
Caption: 
btnRedisplay 
Redisplay 
Add the following code module: 
Module modCalendar 
'Use code module to store values that are needed by both 
'the form and the class 
'Latest box and label to be clicked or created 
Public intCurrentBox As Integer 
Public intCurrentLabel As Integer 
'Latest day label to be created 
Public intCurrentDayLabel As Integer 
End Module 
Add a class to handle the array of text boxes: 
Public Class clsBoxArray 
'Handles creation and use of arrays of boxes 
'Box array is held as a collection 
In her its System. Collections. Collection Base 
'Variable to identify form containing boxes 

Private ReadOnly ThisForm As System.Windows.Forms.Form 
'Box width and height, horizontal and vertical gaps, 
'offset of first box 
Const intBoxWidth As Integer = 75 
Const intBoxHeight As Integer = 25 
Const intBoxHGap As Integer = 25 
Const intBoxVGap As Integer = 20 
Const intHOffset As Integer = 110 
Const intVOffset As Integer = 80 
Public Function AddBox() As System.Windows.Forms.TextBox 
'Function to add a box to the form 
'Create new instance of Text Box class 
Dim itxtNew As New System.Windows.Forms.TextBox 
'Define box co-ordinates, box space requirement 
Dim intX, intY As Integer 
Dim intHSpace, intVSpace As Integer 
'Add box to collection list 
Me.List.Add(itxtNew) 
'Add box to the form's controls collection 
ThisForm.Controls.Add(itxtNew) 
. 'Calculate space used by each box 
intHSpace = intBoxWidth + intBoxHGap 
intVSpace = intBoxHeight + intBoxVGap 
'Calculate box co-ordinates for 5 x 7 grid 
intX = lnt(intCurrentBox I 7) 
intY = intCurrentBox Mod 7 
'Set properties for the new button 
itxtNew.Left = intHOffset + intX * intHSpace 
itxtNew.T op = intVOffset + intY * intVSpace 
itxtNew.Width = intBoxWidth 
itxtNew.Height = intBoxHeight 
'Store index number in Tag 
itxtNew.T ag = Me.Count - 1 
'Display button number in button caption 
311 

312 
intCurrentBox + = 
Return itxtNew 
End Function 
Public Sub New(ByVal AForm As System.Windows.Forms.Form) 
'When array is created, generate 42 boxes 
'Define count variable 
Dim i As Integer 
'Identify current form 
ThisForm = AForm 
'Add 42 boxes 
Fori = 1 To 42 
Me.AddBox() 
Next i 
End Sub 
Default Public ReadOnly Property ltem(ByVal Index As Integer)_ 
As System.Windows.Forms.TextBox 
'Programmer can get value of Item property but not change it 
'Set available properties for list items to standard 
'button properties 
Get 
Return CType(Me.List.ltem(lndex),_ 
System.Windows.Forms.TextBox) 
End Get 
End Property 
End Class 
Add a class to handle the array of labels: 
Public Class clslabeiArray 
'Handles creation and use of arrays of labels 
'Label array is held as a collection 
Inherits System. Collections. Collection Base 
'Variable to identify form containing labels 
Private ReadOnly ThisForm As System.Windows.Forms.Form 
'Box width and height, horizontal and vertical gaps, 

'offset of first box - same as box class 
Const intBoxWidth As Integer = 75 
Const intBoxHeight As Integer = 25 
Const intBoxHGap As Integer = 25 
Const intBoxVGap As Integer = 20 
Const intHOffset As Integer = 11 0 
Const intYOffset As Integer = 80 
'Label width and height 
Const intlabeiWidth As Integer = 20 
Const intlabeiHeight As Integer = intBoxHeight 
'Day label width and offset 
Const intDaylabeiWidth As Integer = 80 
Const intHDayOffset As Integer = 5 
Public Function Addlabel() As System.Windows.Forms.Label 
'Function to add a label to the form 
'Create new instance ofLabel class 
Dim ilbiNew As New System.Windows.Forms.Label 
'Define label co-ordinates, label space requirement 
· Dim intX, intY As Integer 
Dim intHSpace, intYSpace As Integer 
'Add label to collection list 
Me.List.Add(ilbiNew) 
'Add label to the form's controls collection 
This Form. Controls.Add (i lbl New) 
'Calculate space used by each label 
intHSpace = intBoxWidth + intBoxHGap 
intYSpace = intBoxHeight + intBoxYGap 
'Calculate label co-ordinates for 5 x 7 grid 
intX = lnt(intCurrentlabel I 7) 
intY = intCurrentlabel Mod 7 
ilbiNew.Text = intCurrentlabel 
'Set properties for the new button 
'Shift label to left of box 
'(leaving 1 pixel between label and box) 
313 

314 
ilbiNew.Left = intHOffset + intX * intHSpace 
- intlabeiWidth - 1 
ilbiNew.Top = intVOffset + intY * intVSpace 
ilbiNew.Width = intlabeiWidth 
ilbiNew.Height = intlabeiHeight 
ilbiNew.TextAiign = ContentAiignment.MiddleRight 
'Store index number in Tag 
ilbiNew.Tag = Me.Count- 1 
'Display button number in button caption 
intCurrentlabel + = 1 
Return ilbiNew 
End Function 
Public Function AddDaylabel() As_ 
System.Windows.Forms.Label 
'Function to add a day label to the left of the form 
'Create new instance of Label class 
Dim ilbiNew As New System.Windows.Forms.Label 
'Define label space requirement 
Dim intHSpace, intVSpace As Integer 
'Add label to collection list 
Me.List.Add(ilbiNew) 
'Add label to the form's controls collection 
ThisForm.Controls.Add(ilbiNew) 
'Calculate space used by each label 
intHSpace = intBoxWidth + intBoxHGap 
intVSpace = intBoxHeight + intBoxVGap 
'Set properties for the new label 
'Display label on left 
ilbiNew.Left = intHDayOffset 
ilbiNew.Top = intVOffset + intCurrentDaylabel * intVSpace 
ilbiNew.Width = intDaylabeiWidth 
ilbiNew.Height = intlabeiHeight 
ilbiNew.Text = WeekdayName(intCurrentDaylabel + 1) 
ilbiNew.TextAiign = ContentAiignment.MiddleRight 

'Store index number in Tag 
ilbiNew.Tag = Me.Count- 1 
'Display button number in button caption 
intCurrentDaylabel + = 1 
Return ilbiNew 
End Function 
Public Sub New(ByVal AForm As System.Windows.Forms.Form) 
'When array is created, generate 49 labels 
'Define count variable 
Dim i As Integer 
'Identify current form 
ThisForm = AForm 
'Add 42 labels for boxes 
Fori = 1 To 42 
Me.Addlabel{) 
Next i 
'Add day labels 
Fori = 1 To 7 
Me.AddDaylabel{) 
Next i 
End Sub 
Default Public ReadOnly Property ltem(ByVal Index As Integer)_ 
As System.Windows.Forms.Label 
'Programmer can get value of Item property but not change it 
'Set available properties for list items to 
'standard button properties 
Get 
Return CType(Me.List.ltem(lndex), _ 
System.Windows.Forms.Label) 
End Get 
End Property 
End Class 
31S 

316 
Add procedures to the form code so that it reads as follows: 
Public Class frmMonthlyCalendar 
Inherits System .Windows. Forms. Form 
'Declare arrays of boxes and labels based on 
'clsBoxArray and clslabeiArray classes 
Dim arrBoxes As clsBoxArray 
Dim arrlabels As clslabeiArray 
#Region 11 Windows Form Designer generated code 11 
#End Region 
Private Sub frmMonthlyCalendar_Load( ... ) Handles_ 
MyBase.Load 
'When form is loaded, create box array object 
Dim i As Integer 
'Create box array - results in class's New procedure being 
'called and array filled with boxes 
arrBoxes = New clsBoxArray(Me) 
'Similarly, create labels array 
arrlabels = New clslabeiArray(Me) 
'Fill Month combo box with months 
Fori = 1 To 12 
cboMonth .Items .Add (Month No me(i)) 
Next i 
txtYear.Text = Now.Year 
cboMonth.Selectedlndex = Now.Month -1 
ViewCalendar(Now.Month, Now.Year) 
End Sub 
Public Sub ViewCalendar(ByRef shoCaiMonth As Short,_ 
ByRef shoCaiYear As Short) 
'Redisplay calendar for given month (1 to 12) and year 
Dim shoDayNo As Short 
Dim shoRow, shoCol, i As Short 
Dim booStarted, booFinished As Boolean 
Dim dteFirstDay, dtelastDay As DateTime 

Dim shoNumDays As Short 
'Get first day of month 
dteFirstDay = DateSerial(shoCaiYear, shoCaiMonth, 1) 
'Calculate last day of month 
dtelastDay = dteFirstDay.AddMonths(1) 
dtelastDay = dtelastDay.AddDays(-1) 
'Calculate number of days in month 
shoNumDays = DateTime.DayslnMonth(shoCaiYear,_ 
'Set initial values 
booStarted = False 
booFinished = False 
shoDayNo = 1 
For shoCol = 0 To 5 
'One col for each week 
For shoRow = 0 To 6 
'One .row for each day of the week 
'For first column, check to see if is first day of month 
If shoCol = 0 Then 
If shoRow + 1 = Weekday(dteFirstDay,_ 
FirstDayOfWeek.Monday) Then 
booStarted = True 
End If 
End If 
'Calculate day number 
i = (shoCol * 7) + shoRow 
'Display text box and label; increment day number 
If booStarted And Not booFinished Then 
arrBoxes(i).Visible = True 
arrBoxes(i).Text = 
1111 
arrlabels(i).Text = shoDayNo 
arrlabels(i) .Visible = True 
shoDayNo = shoDayNo + 1 
Else 
arrBoxes(i).Visible = False 
317 

318 
arrlabels(i).Visible = False 
End If 
'Stop when last day has been displayed 
If shoDayNo > shoNumDays Then 
booFinished = True 
End If 
Next shoRow 
Next shoCol 
End Sub 
Private Sub txtRedisplay_Ciick( ... ) Handles txtRedisplay.Ciick 
Dim shoCalendarYear, shoCalendarMonth As Short 
'Get year and month 
'NB Selectedlndex = 0 for January 
shoCalendarYear = Val(txtYear.Text) 
shoCalendarMonth = cboMonth.Selectedlndex + 
ViewCalendar(shoCalendarMonth, shoCalendarYear) 
End Sub 
Private Sub cboMonth_SelectedlndexChanged( ... )_ 
Handles cboMonth.SelectedlndexChanged 
txtRedisplay _Click( sender, e) 
End Sub 
Private Sub txtYear_Leave( ... ) Handles txtYear.Leave 
txtRedisplay_ Click( sender, e) 
End Sub 
End Class 

8 
Error handling {p222) 
1 
Display the Code window for the Member Details form. In the 
cboRegion_SelectedValueChanged procedure, click on the first line of 
executable code below the Dim statements and comment and press [F9]. 
Press [FS] to run the program, click on the Member Details button and on 
the Region drop-down arrow. Click on any entry in the list to break into the 
program. 
Highlight lblRep.Text on the last line of the procedure, right-click and select 
Add Watch. Right-click on cboRegion in the code and select Add Watch; 
click on cboRegion in the Watch window and edit it to become 
cboRegion. Text. 
Press [F8] to single-step through the program and note the values as they 
change in the Watch window. 
2 
Amend the ViewCalendar procedure as follows: 
Public Sub ViewCalendar(ByRef shoCaiMonth As Short,_ 
ByRef shoCaiYear As Short) 
'R~display calendar for given month (1 to 1 2) and year 
Dim shoDayNo As Short 
Dim shoRow, shoCol, i As Short 
Dim booStarted, boofinished As Boolean 
Dim dteFirstDay, dtelastDay As DateTime 
Dim shoNumDays As Short 
'Get first day of month 
Try 
dteFirstDay = DateSerial(shoCaiYear, shoCaiMonth, 1) 
Catch When Err.Number = 5 
MsgBox("lnvalid year - assuming this year") 
shoCaiYear = Now.Year 
dteFirstDay = DateSerial(shoCaiYear, shoCaiMonth, 1) 
txtYear.Text = Now.Year 
End Try 
'Calculate last day of month 
dtelastDay = dteFirstDay.AddMonths(1) 
dtelastDay = dtelastDay.AddDays(- 1) 
'Ill Rest of procedure unchanged Ill 
End Sub 
319 

9 
Menus (p242) 
320 
1 
The menus and procedures are as follows: 
Private Sub mnuFileExit_ Click( ... ) Handles mnuFileExit.Ciick 
btnExit_ Click( sender, e) 
End Sub 
Private Sub mnuWindowMemberDetails_Ciick( .... )_ 
Handles mnuWindowMemberDetails.Ciick 
btnMemberDetails_ Click(sender, e) 
End Sub 
Private Sub mnuWindowComments_Ciick( .... )_ 
Handles mnuWindowComments.Ciick 
btnComments_ Click( sender, e) 
End Sub 
Private Sub mnuHelpAbout_Ciick( .... )_ 
Handles mnuHelpAbout.Ciick 
MsgBox("Membership Database vl.O",_ 
MsgBoxStyle.lnformation, "About Membership Database") 
End Sub 
2 
The menus and procedures are as follows: 
Private Sub mnuFileAbandon_Ciick( ... )_ 
Handles mnuFileAbandon.Ciick 
btnCancel_ Click(sender, e) 
End Sub 

Private Sub mnuFileExit_ Click( ... ) Handles mnuFileExit.Ciick 
btnOK_ Click(sender, e) 
End Sub 
3 
You may need to adjust the sizes of the window and text box: 
Private Sub frmComments_Resize( .... ) Handles MyBase.Resize 
txtComments.Top = 24 
txtComments.Left = 0 
'Revised to allow for menu 
txtCo,mments.Height = Me.Height - 92 
txtComments.Width = Me.Width - 8 
'Revised to allow for menu 
btnOK.Top = Me.Height- 62 
btnCancei.Top = btnOK.Top 
btnOK.Left = Me.Width I 2 -55 - btnOK.Width 
btnCancei.Left = Me.Width I 2 + 55 
End Sub 
The menus and procedures are as follows: 
Private Sub mnuEditCut_ Click( ... ) Handles mnuEditCut.Ciick 
C I i pboa rd. SetDataObject(txtCom ments .SelectedT ext) 
txtComments.SelectedT ext = "'' 
End Sub 
321 

322 
Private Sub mnuEditCopy_Ciick( ... ) Handles mnuEditCopy.Ciick 
Clipboard. SetDataObject(txtCom m ents. SelectedT ext) 
End Sub 
Private Sub mnuEditPaste_ Click( ... ) Handles mnuEditPaste.Ciick 
Dim iData As IDataObject = Clipboard.GetDataObject() 
txtComments.SelectedText = CType(iData._ 
GetData(DataFormats.Text), String) 
End Sub 
Private Sub mnuEditCiear_Ciick( ... ) Handles mnuEditCiear.Ciick 
Dim bytButtonVal As Byte 
bytButtonVal = MessageBox.Show("AII text in Comments box_ 
will be deleted!", "Delete all text",_ 
MessageBoxButtons.OKCancel) 
If bytButtonVal = Windows.Forms.DialogResult.OK Then 
txtComments.Text = "" 
End If 
End Sub 

1 0 Files {p272) 
1 
Add the following controls: 
Combo box 
Name: 
Style: 
Text: 
Location: 
Size: 
Button 
Name: 
.Text: 
Location: 
Size: 
cboMemList 
Drop Down 
(blank) 
152, 128 
144,21 
btnAddMember 
Add Member 
304, 128 
80,21 
You will also need to move the labels for the titles. 
Add the following procedure: 
Private Sub btnAddMember_Ciick( ... )_ 
Handles btnAddMember.Ciick 
cboMem List .ltems.Add ( cboMem List. Text) 
End Sub 
2. 
Add a SaveFileDialog control to the front-end form: 
Name: 
SaveFileDialog1 
Filter: 
Membership files (*.mem)l*.mem 
Add the following line to modMainCode: 
Public Const strSaveDir As String = "C:\Members" 
Add the following procedures to frmMainMenu: 
'At top of code 
Dim strFilename As String 
Private Sub SaveMemberList() 
'Save contents of list box to sequential file 
Dim i As Integer 
Dim strMember As String 
Dim strError As String 
323 

324 
'Create new file or replace existing file 
Try 
File0pen(2, strFilename, OpenMode.Output) 
'Repeat for each item in list 
Fori = 0 To cboMemlist.ltems.Count- 1 
'Get item and write to file 
strMember = cboMemlist.ltems.ltem(i) 
Writeline(2, strMember) 
Next 
Catch ex As Exception 
'A file error has occurred 
strError = "Error" & Str(Err.Number) & ": "&_ 
MsgBox(strError) 
Finally 
FileCiose(2) 
End Try 
End Sub 
Error T oString(Err.Number) 
Private Sub mnuFileSaveAs_ Click( ... )_ 
Handles mnuFileSaveAs.Ciick 
'Set up dialog 
SaveFileDialogl.Title = "Save membership details" 
SaveFileDialogl.lnitiaiDirectory = strSaveDir 
If SaveFileDialog l.ShowDialog = _ 
Windows.Forms.DialogResult.OK Then 
'Filename selected 
strFilename = SaveFileDialogl.FileName 
'Check that extension has not been changed 
If Microsoft.VisuaiBasic.Right(strFilename, 4) < > ".mem"_ 
Then 
strFilename = strFilename & ".mem" 
End If 
'Call procedure to save list 
SaveMemberlist() 
End If 
End Sub 

3 
Add an OpenFileDialog control to the front-end form: 
Name: 
OpenFileDialog 1 
Filter: 
Membership files (*.mem)l*.mem 
Add the following procedures to frmMainMenu: 
Private Sub mnuFileSave_Ciick( ... ) Handles mnuFileSave.Ciick 
'Call procedure to save list 
SaveMem berlist() 
End Sub 
Private Sub GetMemberlist() 
Try 
'Retrieve contents of list box from sequential file 
Dim strMember As String 
Dim strError As String 
'Open file and read contents 
strMember = "" 
FileOpen(l, strFilename, OpenMode.lnput) 
'Repeat until end of file 
Do Until EOF(l) 
'Get item from file and add to list 
lnput(l, strMember) 
cboMemlist.ltems.Add(strMember) 
Loop 
Catch ex As Exception 
'A file error has occurred 
strError = "Error" & Str(Err.Number) & ": " &_ 
ErrorToString(Err.Number) 
MsgBox(strError) 
Finally 
FileCiose(l) 
End Try 
End Sub 
Private Sub mnuFileOpen _Click( ... ) Handles mnuFileOpen.Ciick 
'Set up dialog 
OpenFileDialogl.Title = "Get membership details" 
325 

326 
OpenFileDialogl.lnitiaiDirectory = strSaveDir 
If OpenFileDialog 1 .ShowDialog = 
Windows. Forms. Dialog Result. OK Then 
'Filename selected 
strFilename = OpenFileDialog l.FileName 
'Call procedure to retrieve list 
GetMem berlist() 
End If 
End Sub 
4 
Add the following labels: 
Name: 
Text: 
Location: 
Size: 
lblCurrentMem1 
Current member: 
72,248 
96,23 
Add the following code to modMainCode: 
Public strCurrentMem As String 
Public intMemberNum As Integer 
Change btnComments_Click in frmMainMenu: 
lblCurrentMem2 
(blank) 
168,248 
160,23 
Private Sub btnComments_Ciick( ... ) Handles btnComments.Ciick 
Dim frmvComments As New frmComments 
If lbiCurrentMem2.Text < > '"'Then 
frmvComments.Show() 
Else 
MsgBox("Select member first") 
End If 
End Sub 
Add the following code to frmMainMenu: 
Private Sub cboMemlist_SelectedlndexChanged( ... )_ 
Handles cboMemlist.SelectedlndexChanged 
'Display name of selected member 
'Get index number and corresponding member name 
'Store in global variables 
intMemberNum = cboMemlist.Selectedlndex 

strCurrentMem = cboMemlist.ltems.ltem(intMemberNum) 
'Update label 
lbiCurrentMem2.Text = strCurrentMem 
End Sub 
Add the following code to frmComments: 
Private Sub mnuFileSave_Ciick( ... ) Handles mnuFileSave.Ciick 
Dim strCommentsFile As String 
Dim strError As String 
'Create filename from current member name 
strCommentsFile = strSaveDir & "\" & strCurrentMem & ".cmt" 
Try 
'Write current comments to file 
File0pen(3, strCommentsFile, OpenMode.Output) 
Printline(3, txtComments.T ext) 
MsgBox("Comments saved for " & strCurrentMem) 
Catch ex As Exception 
'A file error has occurred 
strError = "Error" & Str(Err.Number) & ": " & 
ErrorToString(Err.Number) 
MsgBox(strError) 
Finally 
FileCiose(3) 
End Try 
End Sub 
Change btnOK_Click: 
Private Sub btnOK_Ciick( ... ) Handles btnOK.Ciick 
mnuFileSave_ Click(eventSender, eventArgs) 
Me.Ciose() 
End Sub 
5 
Add the following procedures to frmComments: 
Private Sub frmComments_Load( ... ) Handles MyBase.Load 
Dim strCommentsFile As String 
Dim strError As String 
Dim booFirstline As Boolean 
327 

328 
Dim strTextln As String 
Canst CR As String = Chr(l3) & Chr(l 0) 
'Create filename from current member name 
strCommentsFile = strSaveDir & "\" & strCurrentMem & ".cmt'' 
booFirstline = True 
Try 
File0pen(4, strCommentsFile, OpenMode.lnput) 
Do While Not EOF(4) 
strTextln = Linelnput(4) 
If booFirstline Then 
txtComments.Text = strTextln 
booFirstline = False 
Else 
txtComments.Text = txtComments.Text & CR & 
strTextln 
End If 
Loop 
Catch ex As Exception 
'A file error has occurred 
If Err.Number < > 53 Then 
'Error other than file not found 
strError = "Error" & Str(Err.Number) & ": "&_ 
MsgBox(strError) 
End If 
Finally 
FileCiose(4) 
End Try 
End Sub 
ErrorT oString(Err. Number) 
6 
Change the following procedure in frrnMainMenu: 
Private Sub btnMemberDetails_Ciick( ... ) Handles 
btnMemberDetails.Ciick 
Dim frmvDetails As New frmDetails 
If lbiCurrentMem2.Text <> '111 Then 
frmvDeta i Is. Show() 

Else 
MsgBox("Select member first") 
End If 
End Sub 
Add the following code at the top of frmDetails : 
Structure DetailsRecord 
Public intRecordNo As Integer 
<VBFixedString(8) > Public strMemberNo As String 
Public shoRegion As Short 
<VBFixedString(40) > Public strName As String 
<VBFixedString(200) > Public strAddress As String 
Public bytMemType As Byte 
Public sngAmount As Single 
Public dtePaidOn As DateTime 
End Structure 
Add the following procedure to frmDetails : 
Private Sub mnuFileSave_Ciick( ... ) Handles mnuFileSave.Ciick 
Dim intRecNo As Integer 
Dim strDetailsFile As String 
Dim intReclen As Integer 
Dim DetailsRec As DetailsRecord 
Dim strError As String 
'Construct filename 
strDetailsFile = strSaveDir & "\" & strCurrentMem & ".dtl" 
'Record number = combo box index + 1 
intRecNo = intMemberNum + 1 
'Build record 
DetailsRec.intRecordNo = intRecNo 
DetailsRec.strMemberNo = txtMemNo.Text 
DetailsRec.shoRegioh = cboRegion.Selectedlndex 
DetailsRec.strName = txtName.Text 
DetailsRec.strAddress == txtAddress.Text 
DetailsRec.bytMemType = radFuii.Checked 
DetailsRec.sngAmount = Val(txtAmount.Text) 
329 

330 
DetailsRec.dtePaidOn = txtPaidOn.Text 
intReclen = Len(DetailsRec) 
'Write record 
Try 
File0pen(3 1 strDetailsFile1 OpenMode.Random 1 
1 
1 
intReclen) 
FilePut(3 1 DetailsRec1 intRecNo) 
Catch ex As Exception 
strError = "Error" & Str(Err.Number) & ": " &_ 
Msg Box( strE rror) 
Finally 
FileCiose(3) 
End Try 
End Sub 
Change btnOK_Click:: 
ErrorT oString(Err.Number) 
Private Sub btnOK _Click( ... ) Handles btnOK.Ciick 
mnuFileSave _ Click(eventSender1 eventArgs) 
Me.Ciose() 
End Sub 
7. 
Add the following procedures to frmDetails: 
Private Sub frmDetailsJoad( ... ) Handles MyBase.Load 
Dim intRecNo As Integer 
Dim intRecNoFromFile As Integer 
Dim strDetailsFile As String 
Dim intReclen As Integer 
Dim DetailsRec As DetailsRecord 
Dim strError As String 
cboReg ion .Items .Add ("North") 
cboReg ion .ltems.Add ("South") 
cboRegion.ltems.Add("East") 
cboRegion.ltems.Add("West") 
strDetailsFile = strSaveDir & "\" & strCurrentMem & ".dtl" 
'Record number = combo box index + 1 
intRecNo = intMemberNum + 1 
intReclen = Len(DetailsRec) 
'Read record 

Try 
File0pen(3, strDetailsFile, OpenMode.Random, , ,_ 
intReclen) 
FileGet(3, DetailsRec, intRecNo) 
Catch ex As Exception 
If Err.Number < > 5 Then 
'File other than record not existing 
strError = "Error" & Str(Err.Number) & ": "&_ 
MsgBox(strError) 
End If 
Finally 
FileCiose(3) 
End Try 
'Unpack record 
Error T oString(Err. Number) 
intRecNoFromFile = DetailsRec.intRecordNo 
If intRecNo = intRecNoFromFile Then 
'Record exists so can unpack other fields 
txtMemNo.Text = Trim(DetailsRec.strMemberNo) 
cboRegion.Selectedlndex = DetailsRec.shoRegion 
txtName.Text = Trim(DetailsRec.strName) 
txtAddress.Text = Trim(DetailsRec.strAddress) 
radFuii.Checked = DetailsRec.bytMemType 
radAssociate.Checked = Not radFuii.Checked 
txtAmount.Text = DetailsRec.sngAmount 
txtPaidOn.Text = DetailsRec.dtePaidOn 
Else 
'Record number wrong, so record contains rubbish; clear it 
txtMemNo.Text = '"' 
cboRegion.Selectedlndex = -1 
txtName.T ext = strCurrentMem 
txtAddress.Text = "" 
radfuii.Checked = True 
DefaultSubscription() 
End If 
End Sub 
331 

11 Graphics (p290) 
332 
1 
Add a picture box control to frmMainMenu. Use its Image property to select 
a bitmap. Set SizeMode to Stretchlmage to make the bitmap fit the image 
area. 
2 
Add a Print option to the File menu. Add a PrintDialog control and 
PrintDocument control. Enter the following procedures: 
Private Sub mnuFilePrint_ Click( ... ) Handles mnuFilePrint.Ciick 
PrintDialogl.Document = PrintDocumentl 
PrintDialogl.ShowDialog() 
PrintDocumentl.Print() 
End Sub 
Private Sub PrintDocumentl_PrintPage( ... )_ 
Handles PrintDocumentl.PrintPage 
Dim objDoc As Graphics = e.Graphics 
objDoc.DrawString("Membership Details", Me.Font, _ 
Brushes. Black, 100, 200) 
'Add other instructions to place individual records on the page 
End Sub 

Index 
.NET Framework, 3 
.NET Framework Class Library, 48 
A 
AcceptButton property, 67 
Access keys, 56, 225 
Accessing records, 266 
Active window, 33 
Add method, 1 00, 135 
AddExtension property, 245 
Adding a class, 180 
Adding context menus at run-time, 240 
Adding controls, 50 
Adding forms, 35 
Adding menu options, 225 
Adding menus, 224 
at run-time, 236 
Adding methods, 183 
Adding properties, 185 
Adding sub-menus, 225 
AddYears method, 135 
And operator, 162 
Applications 
re-running, 77 
running, 43 
Arguments, 126 
Array-handling class, 193 
Arrays, 140 
control, 192 
dynamic, 142 
Asc function, 131 
ASCII character set, 131 
ASCII files, 259 
Assembly name, 111 
Assemblylnfo.vb, 112 
Attributes (files), 252 
AutoSize property, 67 
B 
BackColor property, 61 
Base class, 49 
Bin folder, 110 
Bitmap objects, 27 4 
Boolean properties, 94 
Border style 
forms, 30 
text boxes, 69 
pictures, 274 
BorderStyle property 
text boxes, 69 
pictures, 27 4 
Brackets, 122 
Break mode, 208 
Breakpoints, 209 
conditions, 212 
hit count, 213 
options, 211 
properties, 211 
Brush objects, 276 
Build number, 112 
Built-in string functions, 128 
ButtonCiickHandler procedure, 197 
Buttons, 66 
properties, 67 
ByRef keyword, 156 
ByVal keyword, 156 
c 
Calling procedures, 152 
CanceiButton property, 67 
Caption property (VB6), 57 
Case statement, 164 
Catch statement, 220 
Changing modules, 149 
Changing properties, 89 
Character conversions, 131 
Chars method, 130 
Check boxes, 70 
Checked list boxes, 1 05 
Checked property 
menu options, 231 
radio buttons, 71 
333 

CheckedChanged event, 84 
Checked Indices collection, 105 
Checked Items collection, 105 
CheckFileExists property, 244 
CheckState property, 71 
Chr function, 131 
Class hierarchy, 49 
Class library, 48 
Classes, 15, 48 
adding, 180 
creating, 180 
forms, 88 
instances, 88 
Click event, 83 
Clipboard, 233 
Close method, 97 
Closing random access files, 267 
Closing sequential tiles, 261 
Collections, 98 
Count property, 98 
Colour 
controls, 61 
RGB, 62 
ColumnWidth property, 1 02 
Combo boxes, 1 04 
Comma-delimited format, 259 
Command buttons, 66 
Comments, 157 
Common events, 82 
Common properties, 54 
Compare method, 135 
Component tray, 224 
Concat method, 130 
Concatenation, 124 
Conditional statements, 160 
Conditions, 160 
Conditions tor breakpoints, 212 
Canst keyword, 119 
Constants, 119 
module, 155 
334 
Constants 
private, 155 
public, 155 
Contents (help), 19 
Context menus, 238 
adding at run-time, 240 
ContextMenu control, 238 
Context-sensitive help, 20 
Control arrays, 192 
ControiBox property, 31 
Controls, 13 
access keys, 56 
adding, 13, 50 
colour, 61 
deleting, 52 
enabled, 64 
focus, 63 
hidden, 64 
location, 58 
name, 54 
properties, 51 
selecting multiple, 53 
size, 58 
standard, 65 
tab order, 63 
text, 56 
visible, 64 
Convert class, 132 
Copy method, 249 
Count property, 98 
CreateDirectory method, 252 
Creating a procedure, 85 
Creating classes, 180 
Creating modules, 148 
Creating procedures 
in forms, 149 
in modules, 149 
Creating sequential files, 260 
Current time, 135 

D 
Data control, 77 
Data Sources window, 15 
DataFormats class, 234 
Date data type, 136 
Date property, 134 
Date/time conversions, 136 
DateAdd function, 136 
DateDiff function, 136 
DatePart function, 136 
Dates, 134 
files, 253 
methods, 135 
DateSerial function, 136 
DateTime structure, 134 
DateValue function, 136 
Day property, 134 
DayOfWeek property, 134 
DayOfYear property, 134 
Days property, 135 
DayslnMonth method, 135 
Debug options, 45, 207 
Debugging, 206 
DecimaiPiaces property, 76 . 
Declarations section, 119 
Declaring variables, 116 
Default button, 67 
Defaultltem property, 232 
DefaultPageSettings property, 285 
Delete method, files, 249 
Delete method, folders, 252 
Deleting controls, 52 
Description property 
errors, 218 
folders, 246 
Design windows, 9 
Destroying objects, 184 
Dialog boxes, standard,· 244 
Dim statement 
variables, 117 
records, 267 
Dimensions, 140 
Dir function, 246 
Disk space, 2 
Displaying forms, 87, 97 
Do loops, 171 
Document property, 285 
Documents 
margins, 285 
printing, 285 
DoubleCiick event, 83 
DragDrop event, 84 
DragOver event, 84 
DrawEIIipse method, 277 
Drawing, 276 
Drawline method, 277 
DrawRectangle method, 277 
DrawString method, 280 
DropDownStyle property, 104 
Dynamic arrays, 142 
E 
Edit menu, 233 
Editing menus, 228 
Elements, 140 
Else statement, 163 
Enabled property, 33 
controls, 64 
menus, 231 
timers, 281 
Encapsulation, 48 
End of file, 262 
EOF function, 262 
Err object, 218 
Description property, 218 
Number property, 218 
Error handling, 107 
structured, 220 
Error messages, 206, 218 
Errors 
trappable, 216 
trapping, 216 
33S 

ErrorToString function, 218 
Event-led environment, 80 
Events, 81 
common, 82 
menus, 233 
Excluding forms, 38 
EXE files, 45, 11 0 
Executable files, 11 0 
Exists method 
files, 249 
folders, 252 
Exit Sub statement, 216 
Exiting Visual Basic, 21 
Exponential format, 121 
Expressions, 120 
brackets, 122 
properties, 124 
Extended ASCII, 131 
F 
File operations, 249 
FileCiose statement, 261, 267 
FileGet statement, 267 
Filelen function, 262 
FileName property, 245 
FileNames property, 245 
FileOpen statement, 260, 266 
FilePut statement, 267 
Files 
ASCII, 259 
attributes, 252 
closing random access, 267 
closing sequential, 261 
copying, 249 
creating sequential, 260 
dates and times, 253 
deleting, 249 
existence, 249 
length, 262 
moving, 249 
opening random access, 266 
336 
Files 
opening sequential, 260 
properties, 252 
random access, 266 
reading random access, 267 
reading sequential, 261 
records, 266 
renaming, 249 
selecting, 244 
sequential, 259 
text, 259 
writing random access, 267 
writing sequential, 260 
FiiiEIIipse method, 277 
Filter property, 244 
Finally statement, 220 
Floating windows, 1 0 
Focus, 63 
Folder operations, 252 
FolderBrowserDialog control, 246 
Folders 
creating, 252 
deleting, 252 
existence, 252 
moving, 252 
renaming, 252 
Font object, 280 
Font property, 58 
Font window, 59 
For. .. Next loops, 166 
ForeColor property, 61 
Form Design tab, 12 
Form files, 26 
Form1, 27 
Form1.vb, 8 
Format function, 136 
FormBorderStyle property, 30 
Form-level procedures, 146 
Form-level variables, 117 
Forms, 12, 26 
active, 33 

Forms 
adding, 35 
border style, 30 
classes, 88 
displaying, 87, 97 
enabled, 33 
hidden, 33 
hiding, 97 
importing, 38 
initial position, 32, 93 
name, 29 
position, 31 
properties, 28 
removing, 38 
resizing, 27 
restoring, 39 
saving, 34 
size, 31 
start-up, 42, 96 
title bar, 29 
unloading, 97 
visible, 33 
Frames (VB6), 72 
Framework, 3 
Framework Class Library, 48 
Functions 
G 
mathematical, 126 
numeric, 126 
overloading, 143 
random number, 127 
string, 128 
user-defined, 158 
Visual Basic, 129 
Get statement, 185 
GetAttribues method, 252 
GetCreationTime method, 253 
GetData method, 234 
GetDataObject method, 233 
GetltemCheckState property, 1 05 
GetlastAccessTime method, 253 
GetlastWriteTime method, 253 
GotFocus event, 84 
Graphics object, 276, 285 
Group boxes, 72 
H 
Handles statement, 86 
HatchBrush objects, 276 
Height property 
controls, 58 
forms, 31 
pictures, 274 
Help Contents, 19 
Help Index, 20 
Help options, 17 
Help screens, 18 
Help Search, 20 
Hidden windows, 10 
Hide method, 97 
Hiding forms, 97 
Hit count, 213 
Horizontal property, 75 
HorizontaiScrollbar property, 1 02 
Hour property, 134 
Hours property, 135 
IDataObject class, 234 
If statement, 160 
nested, 163 
Image property, 274 
Importing forms, 38 
Imports statement, 129 
Indeterminate setting, 71 
Index (help) 20 
Index numbers, 140 
Index property, 232 
Inheritance, 49 
Initial position of windows, 32, 93 
lnitiaiDirectory property, 244 
Input statement, 261 
337 

Insert method, 100 
Installation, 2 
Instances of classes, 48, 88 
Instantiating objects, 182 
lnStr function, 129 
lnt funtion, 126 
lntegraiHeight property, 1 02 
Interfaces, 7 
Interval property, 281 
lsLeapYear method, 135 
Items collection, 99 
Add method, 100 
Insert method, 100 
Items Collection Editor, 230 
ltems.Count property, 101 
Items. Item property, 1 01 
Items. Remove method, 101 
ltems.RemoveAt method, 101 
K 
KeyDown event, 84 
KeyPress event, 84 
KeyUp event, 84 
L 
Labels, 67 
LargeChange property, 74 
Leaving Visual Basic, 21 
Left property 
controls, 58 
pictures, 27 4 
Len function, 266 
Length 
files, 262 
records, 266 
Linelnput statement, 261 
Lines, 276 
List boxes, 99 
sorting, 1 00 
Lists, 99 
adding items, 99 
LOC function, 262 
338 
Local variables, 117 
Location property 
controls, 58 
forms, 33 
Locked property, 69 
LOF function, 262 
Logical operators, 162 
Loops, 166 
nested, 167 
LostFocus event, 84 
M 
Main window, 8 
MainMenu control, 232 
Major number, 112 
Margins, 285 
Math class, 126 
Mathematical functions, 126 
MaxButton property, 31 
Maximum property 
progress bars, 75 
progress bars, 76 
scroll bars, 7 4 
MaxLength property, 70 
MdiList property, 232 
Me (form), 91 
Menus, 224 
access keys, 225 
adding, 224 
adding at run-time, 236 
adding options, 225 
adding sub-menus, 225 
context, 238 
editing, 228 
enabling, 231 
events, 233 
hidden, 231 
item names, 229 
properties, 229 
separator bars, 228 
shortcut keys, 231 
visible, 231 

MenuStrip control, 224 
Message boxes, 143 
MessageBox class, 143 
Messages, 48 
Methods, 88, 95 
adding, 183 
Millisecond property, 134 
Milliseconds property, 135 
MinButton property, 31 
Minimum property 
progress bars, 75 
progress bars, 76 
scroll bars, 7 4 
Minor number, 112 
Minute property, 134 
Minutes property, 135 
Mod operator, 121 
Module-level procedures, 146 
Modules, 146 
changing, 149 
constants, 155 
creating, 148 
variables, 154 
Month property, 134 
MouseDown event, 84 
MouseMove event, 84 
MouseUp event, 84 
Move method 
files, 249 
folders, 252 
pictures, 274 
MSDN Library, 17 
MultiColumn property, 1 02 
Multiline property, 69 
MultiSelect property, 244 
N 
Name property 
controls, 54 
forms, 29 
Names 
menu items, 229 
procedures, 152 
project, 6 
variables, 116 
Namespaces, 48 
Naming conventions, 54 
Naming rules, 54 
Nested lfs, 163 
Nested loops, 167 
New procedure, 183 
New statement (windows), 97 
Non-numeric variables, 124 
Not operator, 162 
Nothing statement, 184 
Now property, 135 
Null string, 89 
Number property, 218 
Numeric functions, 126 
Numeric operators, 121 
Numeric properties, 90 
Numeric variables, 116 
NumericUpDown control, 76 
0 
Object box, 85 
Object variables, 125 
Object-oriented programming, 48 
Objects, 48, 80 
behaviour, 49 
collections, 98 
destroying, 184 
instantiating, 182 
members, 95 
OLE control, 77 
On Error GoTo statement, 216 
OOP, 48 
Open windows, 9 
OpenFileDialog control, 244 
Opening random access files, 266 
339 

Opening sequential files, 260 
Operators 
conditions, 160 
expressions, 120 
logical, 162 
numeric, 121 
Or operator, 162 
Order of precedence, 121 
Orientation property, 75 
Output window, 43, 107 
Overloading, 143 
OverwritePrompt property, 245 
p 
Page setup options, 285 
PageSetupDialog control, 285 
Paint event, 276 
Parameters (event procedures), 86 
Passing variables, 155 
PasswordChar property, 70 
Pen objects, 276 
Picture box control, 27 4 
Pictures, 274 
Pointer, 66 
Pointer object, 13 
Polymorphism, 49 
Previewing documents, 285 
Print preview, 285 
Print statement, 260 
PrintDialog control, 285 
PrintDocument class, 285 
Printing, 285 
Printline statement, 260 
PrintPage event, 285 
PrintPreviewControl object, 285 
PrintPreviewDialog control, 285 
Private constants, 155 
Private keyword, 118 
Private procedures, 14 7 
Private variables, 154 
340 
Procedure box, 85 
Procedures, 81 
calling, 152 
creating, 85 
creating in forms, 149 
creating in modules, 149 
form-level, 146 
module-level, 146 
names, 152 
private, 147 
public, 147 
scope, 147 
ProgressBar control, 75 
Project files, 40 
Project name, 6 
Projects, 14 
saving, 6, 40 
starting, 5 
upgrading, 23 
Properties window, 11, 15 
Properties, 15 
adding, 185 
Boolean, 94 
changing, 51, 89 
common, 54 
controls, 51 
expressions, 124 
files, 252 
forms, 28 
menus, 229 
multiple controls, 53 
numeric, 90 
objects, 49 
references, 94 
settings, 28, 51 
text, 89 
using, 89 
Public constants, 155 
Public procedures, 147 
Public variables, 154 

R 
Radio buttons, 70 
groups, 72 
RadioCheck property, 232 
Random access files, 266 
closing, 267 
opening, 266 
reading, 267 
writing, 267 
Random number functions, 127 
Randomize function, 127 
Reading random access files, 267 
Reading sequential files, 261 
ReadOnly property, 76 
Record type variables, 267 
Record types, 266 
Records, 266 
accessing, 266 
length, 266 
ReDim statement, 142 
Registration, 4 
Removing forms, 38 
Restarting Visual Basic, 22 . 
Restoring forms, 39 
Resume statement, 216 
RESX files, 26 
Revision number, 112 
RGB values, 62 
Rich text boxes, 285 
Rnd function, 127 
RootFolder property, 246 
Running applications, 43, 77 
Running Visual Basic, 3 
s 
Save option, 34 
SaveFileDialog control, 245 
Saving forms, 34 
Saving projects, 6, 40 
Scope 
procedures, 147 
variables, 117 
Scroll bars, 74 
ScroiiBars property, 70 
Search (help), 20 
Second property, 134 
Seconds property, 135 
Selected.lndex property, 1 01 
SelectedPath, 246 
SelectedText property, 234 
Selectionlength property, 234 
Selection Mode property, 1 02 
SelectionStart property, 234 
Separator bars, 228 
Sequential files, 259 
closing, 261 
creating, 260 
creating, 260 
opening, 260 
reading, 261 
writing, 260 
Set statement, 185 
SetDataObject method, 233 
Settings for properties, 28 
Setup program, 2 
Shapes, 276 
Shortcut keys, 231 
Show method, 88, 97 
Show Start Page, 11 
ShowDialog method, 245 
ShowlnTaskbar, 31 
ShowNewFolderButton property, 246 
Single-stepping, 21 0 
Size property 
controls, 58 
forms, 31 
Size Mode property, pictures, 27 4 
SmaiiChange property, 74 
SolidBrush objects, 276 
Solution Explorer properties, 96 
Solution Explorer window, 14 
Solutions, 14 
Sorted property, 100 
341 

SourceSafe, 41 
Spc function, 260 
Standard controls, 65 
Standard dialogs, 244 
Start Page, 8 
redisplaying, 11 
Starting a project, 5 
StartPosition property, 32 
Start-up form, 42, 96 
Static keyword, 117 
Str function, 132 
String class, 130 
String Collection Editor, 99 
String conversions, 132 
String functions, 128 
String variables, 116, 124 
length, 266 
Strings, 89 
combining, 124, 130 
conversions, 132 
searching, 129 
Structure statement, 266 
Structured error handling, 220 
Sub-menus, 225 
Subtract method, 135 
Suspending Visual Basic, 21 
System.IO.File class, 252 
T 
Tab function, 260 
Tab stops, 63 
Tablndex property, 63 
TabStop property, 63 
Task List window, 108 
Text boxes, 68 
Text files, 259 
Text properties, 89 
Text property 
buttons, 67 
controls, 56 
342 
Text property 
forms, 29 
group boxes, 73 
labels, 67 
text boxes, 68 
Text in graphics, 280 
TextAiign property 
labels, 67 
radio buttons, 71 
text boxes, 69 
TextChanged event, 84 
ThousandsSeparator property, 76 
ThreeState property, 71 
Tick event, 281 
TickFrequency property, 75 
Time spans, 135 
Timer control, 281 
Timers, 281 
Times, 134 
current, 135 
files, 253 
methods, 135 
TimeSerial function, 136 
TimeSpan structure, 135 
TimeValue function, 136 
Title bar 
properties, 31 
text, 29 
Title property, 245 
Today property, 135 
Toolbox, 50 
Toolbox window, 13 
Top property 
controls, 58 
pictures, 27 4 
ToString method, 132, 135 
TotaiDays property, 135 
TotaiHours property, 135 
TrackBar control, 75 
Trappable errors, 216 

Trapping errors, 216 
Try statement, 220 
Type (variables), 118 
u 
Unload event, 97 
Unloading forms, 97 
Until statement, 171 
Upgrade Wizard, 23 
Upgrading projects, 23 
User-defined functions, 158 
Using properties, 89 
v 
Val function, 132 
Value property 
progress bars, 75 
progress bars, 76 
scroll bars, 7 4 
Value variable, 185 
Variables, 116 
declaring, 116 
form-level, 117 
forms, 88 
local, 117 
module, 154 
names, 116 
non-numeric, 124 
object, 125 
order of precedence, 121 
passing to procedures, 155 
private, 154 
public, 154 
scope, 117 
string, 124 
type, 118 
watching, 215 
VB files, 26 
VBPROJ files, 22, 40 
Version numbers, 112 
Vertical property, 75 
View options, 11 
Visible property 
forms, 33 
controls, 64 
menus, 231 
pictures, 27 4 
Visual Basic functions, 129 
Visual Basic installation, 2 
Visual Basic versions, 2 
Visual Studio, 3 
w 
display, 7 
exiting, 21 
leaving, 21 
main window, 8 
restarting, 22 
running, 3 
suspending, 21 
Watch window, 215 
Watching variables, 215 
WeekdayName property, 134 
While statement, 171 
Width property 
controls, 58 
forms, 31 
pictures, 27 4 
Window tabs, 11 
Windows, 26 
floating, 10 
focus, 63 
hidden, 10 
initial position, 93 
open,9 
tabs, 11 
Write statement, 260 
Writeline statement, 260 
Writing random access files, 267 
Writing sequential files, 260 
343 

X 
X property, 33 
Xor operator, 162 
344 
y 
Y property, 33 
Year property, 134 

