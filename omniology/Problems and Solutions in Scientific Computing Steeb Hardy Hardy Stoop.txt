
PROBLEMS &
SOLUTIONS IN
SCIENTIFIC
COMPUTING
WITH C++AND JAVA SIMULATIONS


PROBLEMS &
SOLUTIONS IN
SCIENTIFIC
COMPUTING
WITH C++AND JAVA SIMULATIONS
,-^Of/ 
"VTOj > 
Willi-Hans Steeb
jCjf 
>r^i^ 
Ybrick Hardy
'-•-•'' 
Alexandre Hardy
Rand Afrikaans University, South Africa
0-9 
\. 
0-9 
/f^ri 
'ip 
i 
\
0 0 0 © 
f\\\ 
j\ \) 
Ruedi Stoop
Cj 
Cj 
V : *< 
1-T^~ 
hstituteforNeuromfomatics,ETHZ,SwitZerla
0-9 
0-9 
\ • / 
Nv__'ry
\[P World Scientific
NEW JERSEY • LONDON • SINGAPORE • BEIJING • SHANGHAI • HONGKONG • TAIPEI • CHENNAI

Published by
World Scientific Publishing Co. Pte. Ltd.
5 Toh Tuck Link, Singapore 596224
USA office: 27 Warren Street, Suite 401-402, Hackensack, NJ 07601
UK office: 57 Shelton Street, Covent Garden, London WC2H 9HE
British Library Cataloguing-in-Publication Data
A catalogue record for this book is available from the British Library.
PROBLEMS AND SOLUTIONS IN SCIENTIFIC COMPUTING WITH C++
AND JAVA SIMULATIONS
Copyright © 2004 by World Scientific Publishing Co. Pte. Ltd.
All rights reserved. This book, or parts thereof, may not be reproduced in any form or by any means,
electronic or mechanical, including photocopying, recording or any information storage and retrieval
system now known or to be invented, without written permission from the Publisher.
For photocopying of material in this volume, please pay a copying fee through the Copyright
Clearance Center, Inc., 222 Rosewood Drive, Danvers, MA 01923, USA. In this case permission to
photocopy is not required from the publisher.
ISBN 981-256-112-9
ISBN 981-256-125-0 (pbk)
Printed in Singapore.

Preface
Scientific computing is a collection of tools, techniques and theories required
to develop and solve mathematical models in science and engineering on a
computer. The purpose of this book is to supply a collection of problems
together with their detailed solution which will prove to be valuable to stu-
dents as well as to research workers in the fields of scientific computing.
The book provides the various skills and techniques needed in scientific
computing. The topics range in difficulty from elementary to advanced.
Almost all problems are solved in detail and most of the problems are self-
contained. A number of problems contain C++ or Java code. All fields
in scientific computing are covered such as matrices, numerical analysis,
neural networks, genetic algorithms etc. All relevant definitions are given.
Students can learn important principles and strategies required for prob-
lem solving. Chapter 1 gives a gentle introduction to problems in scientific
computing. Teachers will also find this text useful as a supplement, since
important concepts and techniques are developed in the problems. Basic
knowledge in linear algebra, analysis, C++ and Java programming are re-
quired. We have tested the C++ programs with gcc 3.3 and Microsoft
Visual Studio.NET (VC 7). The Java programs have been tested with ver-
sion 1.5.0. The material was tested in our lectures given around the world.
Any useful suggestions and comments are welcome,
email addresses of the authors:
steeb_wh@yahoo.com
whsSna.rau.ac.za
yorickhardyOyahoo.com
yhaSna.rau.ac.za
ah@na.rau.ac.za
ruediOini.phys.ethz.ch
Home pages of the author:
http://issc.rau.ac.za
v


Contents
Preface 
v
Notation 
ix
1 Quickies 
1
2 Bitwise Operations 
23
3 Number Manipulations 
51
4 Combinatorical Problems 
89
5 Matrix Calculus 
103
6 Recursion 
149
7 Finite State Machines 
167
8 Lists, Trees and Queues 
177
9 Numerical Techniques 
199
10 Random Numbers and Monte Carlo Techniques 
243
11 Ordinary Differential Equations 
263
12 Partial Differential Equations 
275
vii

viii Contents
13 Wavelets 
285
14 Graphs 
295
15 Neural Networks 
305
16 Genetic Algorithms 
321
17 Optimization 
331
18 File and String Manipulations 
347
19 Computer Graphics 
379
Bibliography 
413
Index 
417

Notation
0 
empty set
N 
natural numbers
Z 
integers
Q 
rational numbers
R 
real numbers
R + 
nonnegative real numbers
C 
complex numbers
R n 
n-dimensional Euclidian space
C n 
n-dimensional complex linear space
1 
\fzl
Kz 
real part of the complex number z
Qz 
imaginary part of the complex number z
xeR" 
element x of R"
Ac B 
subset A of set B
An B 
the intersection of the sets A and B
A U B 
the union of the sets A and B
fog 
composition of two mappings (/ o g)(x) = f(g{x))
[x\ 
floor function [3.14J = 3
\x\ 
ceiling function [3.14] = 4
© 
XOR operation
u 
dependent variable
t 
independent variable (time variable)
x 
independent variable (space variable)
xT = (xi, ^2,..., xn) 
vector of independent variables, 
T means transpose
u T = {u\, U2,..., un) 
vector of dependent variables, 
T means transpose
11.11 
norm
x • y 
scalar product (inner product)
xx y 
vector product
® 
Kronecker product, tensor product
det 
determinant of a square matrix
tr 
trace of a square matrix
I 
unit matrix
[, ] 
commutator
Sjk 
Kronecker delta with djk = 1 for j = k
and Sjk = 0 for j ^ k
sgn(x) 
the sign of x, 1 if x > 0, - 1 if x < 0, 0 if x = 0
A 
eigenvalue
e 
real parameter
ix


Chapter 1
Quickies
Problem 1. The multiplication of the polynomials
/(z) = fo + fix, 
g(x) = go + g\x
yields the polynomial
h(x) = h0 + h\x + h2x2
where
ho = /oSo, 
hi = fogi + figo, 
h2 = figi.
This includes 4 multiplications and 1 addition to find the coefficients ho,hi,h,2-
Is it possible to reduce the number of multiplications to 3?
Solution 1. The number of multiplications can be reduced to 3 using
ho = fogo, 
h2 = figi
and
hi = (/o + /i)(5o + gi) 
-ho-h2.
However, the number of additions is now 2 and we have 2 subtractions.
Problem 2. How would we calculate the function
f{x,y) - cos(x) sm(y) - sin(x) cos(y)
where x, y € R?
1

2 Problems and Solutions
Solution 2. In the present form we have to calculate the cosine twice
and the sine twice. Additionally we have two multiplications and one sub-
traction. Using the trigonometric identity
cos(x) sin(y) - sin(a;) cos(y) = sin(x — y)
we have
f(x,y) =sin(x-y).
Thus we have reduced the number of operations considerably. We only have
to calculate the difference x — y and then the sine.
Problem 3. 
Assume we have to calculate the surface area A and the
volume V of a ball with radius r, i.e.,
A = Anr2
How can we reduce the number of multiplications used to calculate these
two quantitites?
Solution 3. Obviously we can write
A = 47T7-2
V=\Ar
to obtain 5 multiplications compared to 7 from the original formulas.
Problem 4. In a C++ program we find the following if condition
if((i/2)*2 == i) { ... }
where i is of data type int. Obviously the condition tests whether i is an
odd or even number. How can the condition be simplified?
Solution 4. Obviously, we can write
if(i%2 == 0) { ... }
which is also faster. Another option is
if((i & 1) == 0) -C ... >.

Quickies 3
Problem 5. How would we calculate
sin(x)
x
for x e R and x < 1?
Solution 5. Since x is small we would not use the expression given above,
since it involves the division of two small numbers. Additionally we have to
calculate sin(x). Rather we expand sin(x) as a Taylor series. This yields
sin(a;) _ x - x3/3! H 
x2
x 
x 
~~ ~3!" + " '
For small x the term 1 — x2/6 provides a good enough approximation.
Problem 6. Let A be a square matrix over the real numbers. How would
we calculate
det(exp(,4))
where
exp(A) ~2^T[-
fc=O
Solution 6. To calculate exp(A) of an n x n square matrix A using the
definition given above is quite time-consuming. Additionally we have to
calculate the determinant of A. A better solution is to use the identity
det(exp(j4)) = exp(tr(^4))
where tr(^4) denotes the trace, i.e.,
n
tx{A) :=^2aj:j.
j=i
After taking the trace we only have to calculate the exponent of a real
number instead of a matrix.
Problem 7. (i) Find a linear map
/ : { O , 1 } ^ { - 1 , 1 }
such that
/(0) = - l , 
/(1) = 1- 
(1)
(ii) Find a linear map
9 : { - l , l } ^ { 0 , ! }

4 Problems and Solutions
such that
5(-l)=0, 
s(l) = 1. 
(2)
This is obviously the inverse map of / .
Solution 7. (i) Prom the ansatz for a linear function /(n) = an + b,
where a and b are determined by condition (1) we find /(0) = b — - 1 and
/(I) = a + b=l. Thus,
/(n) = 2n - 1.
(ii) We start again from g(m) = cm + d, where the constants c and d are
determined by the condition (2). We find c = 1/2 and d — 1/2. Thus,
i 
\ 
m
+
1
9{m) = -~Y~ •
Problem 8. The standard map is given by
It+i =It + ksin(9t)
9t+1=et + It + ksm{et)
where t = 0,1,2,... and /0, 60 are the given initial values, k is a positive
constant. How would we simplify the calculation of It and dt?
Solution 8. Obviously, we can insert the first equation into the second
equation. This yields
It+i =It + ksin.(6t)
0t+i =8t + It+i •
This saves the calculation of the sine and of an addition.
Problem 9. Given the time-delayed logistic map
xt+2 = 
rxt+i(l-xt)
where t = 0,1, 2,..., r is a positive constant and XQ, X\ are the given initial
values. Show that it can be reformulated as a pair of first order difference
equations.
Solution 9. Setting yt = xt+i we find
yt+i =ryt(l-xt)

Quickies 5
Problem 10. 
Let A be an n x n matrix with det(A) ^ 0. Thus, the
inverse A~l exists. The inverse can be calculated using differentiation as
follows
— 
ln(det(A)) = bji
where B = A~x. Apply the formula to a 2 x 2 matrix to find the inverse.
Solution 10. Since
det(A) = a\ia,22 — «i2a2i
we have
, 
d 
a22
on — ^ — yn(ai1a22 ~ 012021) = -77
oan 
L)
u 
d 
1 / 
\ 
a i 2
012 = -5 
m(aua22 - 012021) = ~-jr
,
9 
a,2i
021 = "H 
Inana 22 - ai2«2ij = —pr
Cai2 
-U
^22 = -5— In(ana22 - ai2a2i) = -=-
0022 
u
where D = det(A).
Problem 11. Calculate
/„ = / 
xnexdx
Jo
for n = 0,l,2,... .
Solution 11. To do numerical integration for every n is not very efficient.
We try to find a recursion relation for /„. Using integration by parts we
find
In+1 = f xn+1exdx = I^+VI* - (n+ 1) / 
xnexdx.
Jo 
Jo
Thus,
/ n +i = e - (n + l)/ n
with IQ = e — 1. Thus we can avoid any numerical integration.
Problem 12. 
Which of the following two initializations to 1 of a two-
dimensional array (matrix) is faster? Explain!

6 
Problems and Solutions
II init.cpp
#include <iostream>
using namespace std;
int main(void)
{
/ / initialization 1
int arrayl[128][128];
for(int i=0;i<128;i++)
{
for(int j=0;j<128;j++)
{
arrayl[i] [j] = 1;
}
}
// initialization 2
int array2[128][128];
for(int k=0;k<128;k++)
{
for(int 1=O;1<128;1++)
i
array2[1][k] = 1;
}
}
return 0;
}
Solution 12. 
The two-dimensional array is stored in a linear (one-
dimensional) array. We note that
arrayl[i] [j] is equivalent to *(arrayl+i*128+j)
array2[l][k] is equivalent to *(array2+l*128+k).
The first initialization is faster since iteration over the second index involves
initializing adjacent bytes. The second initialization involves iteration over
the first index which are separated by at least 128 int. Thus, the first
initialization uses primarily increment and copy operations, whereas the
second uses primarily addition and copy operations. When the processor
uses a memory cache the first initialization method is more efficient since
each sub-array can often be stored in the cache for the initialization.
Problem 13. Consider the following sets

Quickies 
7
A : 
0 , 1 , - 1 , 2, -2, 3, - 3 , . . .
B : 
1, 2, 
3, 4, 
5, 6, 
7, 
. . .
(i) Find a function / : B —> A which sets up a 1-1 map.
(ii) Find the inverse map g : A —> B.
(iii) Give a Java implementation for these maps using the Biglnteger class.
Solution 13. 
(i) We have
{
§ 
if n even
- a = i if n odd
(ii) We have
, . _ f 2m 
if m positive
(_2|m| + l if TO negative or zero
(iii) The method int signumQ in class Biglnteger returns the signum
function of this Biglnteger, i.e., it returns —1, 0, or 1 as the value of this
Biglnteger is negative, zero or positive.
/ / OneOneMap.java
import j ava.math.*;
public class OneOneMap
{
public static Biglnteger f(Biglnteger n)
{
Biglnteger TWO = new Biglnteger("2");
Biglnteger rem = n.remainder(TWO);
if(rem.equals(Biglnteger.ZERO))
{ return n.divide(TWO); }
else
return ((n.subtract(Biglnteger.ONE)).divide(TWO)).negateO;
}
public static Biglnteger g(Biglnteger m)
{
Biglnteger TWO = new Biglnteger("2");
int s = m.signumO;
if(s == 1) { return m.multiply(TWO); }
else
return (m.absQ).multiply(TWO).add(Biglnteger.ONE);

8 Problems and Solutions
public static void main(String[] args)
{
Biglnteger nl = new BigInteger("-1001");
Biglnteger rl = f(nl);
System.out.printlnO'rl = " + rl) ;
Biglnteger ml = new BigInteger("20002");
Biglnteger si = g(ml);
System.out.println("si = " + si);
Biglnteger m2 = new Biglnteger("-20003");
Biglnteger s2 = g(m2);
System.out.println("s2 = " + s2);
}
}
Problem 14. To calculate TT up to a given number of digits one can use
the series expansion
x3 
x5 
x7
arctan(x) = x —5- + ~? 
•=• + •••
Thus for x = 1 we have arctan(l) = TT/4 and therefore
ix 
1
1
1
Explain why this is not a useful approach to calculate ?r up to a given
number of digits.
Solution 14. The series converges far too slowly. A better expansion can
be found by using the addition theorem
(
x + y \I .
l-xyj
For x — 1/2 and y = 1/3 we obtain
— = arctan I - I + arctan I — I .
This series converges much faster. We can iterate this approach to obtain
even faster convergence.
Problem 15. Determine the output of the following C++ code.

Quickies 9
/ / surprise.cpp
#include <iostream>
using namespace std;
int main(void)
{
int max = 100;
int min = 2;
for(int i=min;i<=max;i++)
{
int j = 2;
while (i'/,j++ != 0) ;
if(j == i+1) cout « "i = " « i « endl;
}
return 0;
}
Solution 15. 
The program outputs all prime numbers between 2 and
100.
Problem 16. Given two positive numbers, say a and b. We have to test
whether ln(o) < ln(6). How would we perform this test?
Solution 16. If
ln(a) < ln(6)
then a < b and vice versa. Thus it is not necessary to calculate the natural
logarithm.
Problem 17. 
Let a and b be real numbers and b > a. Let x € [a,b].
Consider the function / : [a, 6] —> R
ti 
\ 
x ~ ~ a
f { x ) 
= 
b ^ 
•
What is the use of this function?
Solution 17. The function normalizes x on the unit interval [0,1]. Thus
f(a) = o, f(b) = 1 and f((a+b)/2) = 1/2.
Problem 18. Given a set of m vectors in R"
{ x0) X1J • • • ) x m - l }

10 Problems and Solutions
and a vector y £ Rn. We consider the Euclidean distance, i.e.,
n-l
||u - v|| := £(uj-«i)2, 
u,veR".
\i=o
We have to find the vector Xj (j = 0,1,..., m— 1) with the shortest distance
to the vector y, i.e., we want to find the index j . Provide an efficient
computation. This problem plays a role in neural networks.
Solution 18. First we note that the minimum of a square root is the same
as the minimum of a square (both are monotonically increasing functions).
Thus,
Hxi - yii2 = X > * - s")2 = D 4 - 2a*w + y?) •
i=0 
i=0
Since the term
n-l
i=0
is a constant it is not necessary to calculate it to find the vector with the
shortest distance. Thus we are left to calculate
n-l
J2 (4 - 2xnvi)
i=0
for each vector Xj. If all vectors Xj (j = 0,1,2,..., m - 1) are normalized
(say to 1), then it is also not necessary to calculate x2^. Thus we are left
with
n-l
-2 Yl XjiVi.
i=0
Obviously, we can also omit the multiplication by —2 and test for the
maximum of the sum for the vectors { Xj : j = 0,1,..., m — 1}.
Problem 19. The following functions
sin(7rn(t - k/n))
ak(t) = 
. , , 
. . .. , 
t G (U, 1)
nsin(7r(t - k/n))
play a central role in harmonic interpolation, where n is a positive odd
integer and k — 0,1,..., n — 1. Let n = 3. Can the sum
n - l
fc=0

Quickies 11
be simplified?
Solution 19. Yes, the sum can be simplified. Using the identities
sin(a — j3) = sin(a) cos(/3) — cos(a) sin(/3)
and
sin(a) cos(a) = - sin(2a), 
- cos(a) sin(2a) = - sin(a) + - sin(3a)
we find
n-l
!>*(*) = 
1 -
fc=0
This is called a partition of unity. This identity does not only hold for
n = 3 but for any n which is odd.
Problem 20. The series expansion
x2 
x3 
x4
\ n ( l + x ) = x - - + - - - 
+ --.
converges for x £ (—1,1]. Thus it allows to calculate
This expansion converges very slowly. Is there a faster way to calculate
In 2?
Solution 20. Consider the expansion
. n 
. 
x2 
x3 
x4
which converges for x € [0,1). Then using x = 1/2 we have
. / 1 \ 
/I 
1 
1 
1 
\
l n U J
= - U + 8 + 24 + 6 4
+ - j -
This series converges must faster. We have ln(2) — — ln(l/2).
We could also subtract the two series expansions and obtain
ln(l + x) - ln(l - X) = In 
( \ ^ )
/ 
x3 
x5 
\
= 2(x+Y 
+ ~5+'")' 
a:e(-l,l)-

12 Problems and Solutions
This series converges even faster using x = ±1/3.
Problem 21. Applying Simpon's rule for the evaluation of
/ 
x-2g(x)dx
with the smooth function g constant at large x, would result in a (finite)
sum converging very slowly as b becomes large for fixed h (step size) and
taking a very long time to compute. Show that changing the variable would
improve the situation.
Solution 21. Using the transformation y = x"1 with dy = -x~2dx and
x = b —> y = b-1 yields
f1
/ 
giv'^dy
which can then be evaluated by using Simpon's rule.
Problem 22. Consider the integral
j\l-x2)-^g{x)dx
Jo
where g is a smooth function in the interval [0,1]. We have an integrable
singularity at x = 1 and quadrature formulas give an infinite result. Pro-
pose a transformation so that quadrature formulas can be applied.
Solution 22. Using the transformation y(x) = (1 — x)1^2 we obtain
2 /1(2-2/2)-1/2<7(l-2/2)^
Jo
where quadrature formulas can be applied without problems.
Problem 23. Consider the integral
,3
1= 
yfxCOs{x)dx.
JO
Owing to the term \fx the integrand is not regular. Give a transformation
that resolves this problem.
Solution 23. We set x(t) = t2. Thus dx(t) = 2tdt. We find
7 = 2 / 
t2 cos(t2)dt.
Jo

Quickies 13
Thus the integrand is now an analytical function.
Problem 24. To multiply an i x j matrix with a j x k matrix using the
standard method it is necessary to do
i x j x k
elementary multiplications. Consider the multiplication of the four matrices
A (20 x 2), B {2 x 30), C (30 x 12) and D (12 x 8). Recall that the
matrix product is associative. How many multiplications do we need to do
A(B(CD)), (AB)(CD), A((BC)D), ((AB)C)D, (A(BC))D ? Which one
is the optimal order for multiplying these four matrices?
Solution 24. We find
A(B(CD)) -» 30 • 12 • 8 + 2 • 30 • 8 + 20 • 2 • 8 = 3680
(AB)(CD) -> 20 • 2 • 30 + 30 • 12 • 8 + 20 • 30 • 8 = 8880
A{{BC)D) -> 2 • 30 • 12 + 2 • 12 • 8 + 20 • 2 • 8 = 1232
{{AB)C)D -> 20 • 2 • 30 + 20 • 30 • 12 + 20 • 12 • 8 = 10320
{A{BC))D -> 2 • 30 • 12 + 20 • 2 • 12 + 20 • 12 • 8 = 3120.
Thus the order A((BC)D) is optimal for multiplying the four matrices A,
B, C, D.
Problem 25. A semi-discrete Korteweg de-Vries equation is given by
dun
-jr = un(un+i - un_i)
at
where n = 0,1,2, 
Write the equation as a recurrence relation.
Solution 25. We find
un+i{t) = — - ^ +u n-i = ^-ln(un(t)) +u n_i.
Thus un+\ is computed from the knowledge of un and un_i.
Problem 26. 
Consider the set of two bits {0,1} with the operation of
addition modulo 2. This can be written as the table
® I 0 1
0 
0 1
1 I 1 0

14 
Problems and Solutions
Find a 1-1 map of this set to the set {+1,-1} with multiplication as
operation such that the algebraic structure is preserved.
Solution 26. We have the map 0 —> +1 and 1 —> — 1 with the multipli-
cation table
~* I +i 
- F
+i 
+1 - l
- l | - l 
+i
Thus, we have a finite group with two elements. The neutral element of the
group is +1.
Problem 27. What is the following program doing? What is the output?
/ / eps.cpp
#include <iostream>
using namespace std;
int main(void)
{
double eps = 1.0;
while((1.0 + eps) > 1.0) { eps = eps/2.0; }
eps = eps*2.0;
cout.precision(20);
cout « "eps = " « eps;
return 0;
}
Solution 27. 
The program provides the machine epsilon for the data
type double, i.e., the distance from 1.0 to the next largest floating number
(data type double). We find
2.22044605 • 10~16 == 2"52 .
(IEEE 754 64-bit conformant).
Problem 28. Write a C++ function cumsumO which finds the cumulative
sum vector of a vector of numbers. For example
(2 4 5 1) -> (2 6 11 12).
Use templates so that different number data types can be used.

Quickies 15
Solution 28. We use the data types int and double.
/ / cumsum.cpp
#include <iostream>
using namespace std;
template <typename T> void sumcum(T* a,T* c,unsigned long n)
{
T temp;
c[0] = a[0];
for(unsigned long j=l;j<n;j++)
f
c[j] = c[j-l] + a[j];
}
}
int main(void)
{
unsigned long n = 4;
int* al = new int[n];
al[0] = 2; al[l] = 4; al [2] = 5; al [3] = 1;
int* cl = new int[n];
sumcum(al,cl,n);
for(unsigned long i=0;i < n;i++)
{
cout « "cl[" « i << "] = " « cl[i] « endl;
}
delete[] al;
delete [] cl;
unsigned long m = 3;
double* a2 = new double[m];
a2[0] = 1.3; a2[l] = 2.7; a2[2] = 1.1;
double* c2 = new double[m];
sumcum(a2,c2,m);
for(unsigned long j=O;j<m;j++)
{
cout « "c2[" « j « "] = " « c2[j] « endl;
}
deleted a2;
delete [] c2;
return 0;
}

16 Problems and Solutions
Problem 29. 
Consider the following two systems of linear equations
1.000000a;+ 1.000000y = 0
1.000000a:+ 0.999999y = l
and
l.OOOOOOx + l.OOOOOOy = 0
1.000000a; + l.OOOOOly = 1.
This means we make a change of 0.000002 (only 0.0002 percent) in the
coefficient of y in the second equation. Discuss the solutions.
Solution 29. 
For the first system of linear equations we find
x = 106, 
y = -10 6
and for the second system of linear equations we find
x = -10 6, 
y = 106.
Thus we have an ill conditioned system, i.e., a small relative change in one
of the coefficient values results in a large relative change in solution values.
Problem 30. 
Kahan's summation algorithm recovers the bits that are
lost in the process of adding a small and a large number and preserves
this information in the form of an accumulated correction. The following
FORTRAN segment implements this summation algorithm given an array
of numbers x(j).
sum = 0.
carry = 0.
do 100 j = 1,N
y = carry + x(j)
t = sum + y
carry = (sum - t) + y
100 sum = t
sum = sum + carry
The algorithm works because the variable carry contains the information
that was lost as the result of adding x(j) to sum. Write a C++ program
that implements Kahan's summation algorithm and compare to direct sum-
mation. Consider the array
d - - -M
V ' 2 ' 3 ' " "ioooy '

Quickies 17
Solution 30. We use the data type double for the numbers in the array.
/ / Kahan.cpp
#include <iostream>
using namespace std;
int main(void)
{
const int n = 1000;
double x[n];
for(int i=0;i<n;i++)
{
x[i] = 1.0/((double) (i+O);
}
double suml = 0.0;
for(int j=O;j<n;j++)
suml += x[j] ;
cout.precision(36);
cout « "suml = " « suml « endl;
double sum2 =0.0;
double carry = 0.0;
for(int k=0;k<n;k++)
{
double y = carry + x[k];
double t = sum2 + y;
carry = (sum2 - t) + y;
sum2 = t;
>
cout.precision(36);
cout << "carry = " << carry << endl;
sum2 += carry;
cout.precision(36);
cout « "sum2 = " « sum2 « endl;
return 0;
>
Problem 31. 
Euler noticed that x2 + x + 41 takes on prime values
for x — 0,1,2,..., 39. Thus we may ask whether it is possible to have a
polynomial which produces only prime values. It can be shown that this is

18 Problems and Solutions
not the case unless the polynomial is constant. Write a C++ program that
checks that x2 + x + 41 are prime numbers for x = 0,1, 2,..., 39. Extend
the loop to numbers greater than 39 to see which numbers are prime and
not prime beyond 39.
Solution 31. We find that for 40 and 41 the numbers are not prime, but
for 42 the number is prime again. The primality testing can be improved
by only considering potential factors less than y/x, or applying the sieve of
Eratosthenes.
/ / Euler.cpp
#include <iostream>
using namespace std;
int euler(int x) { return x*(x+l) + 41; }
int isprime(int x)
•C
if (xV.2 == 0) return 0;
for(int j=3;j<x/2;j+=2)
if (x'/.j == 0) return 0;
return 1;
}
int main(void)
•C
for(int x=0;x<=50;x++)
{
cout « "x = " « x « ","
« "x~2 + x + 41 = " « euler(x);
if(isprime(euler(x)))
cout « " is prime";
else
cout << " is not prime";
cout « endl;
}
return 0;
}
Problem 32. Given a vector x € R". We want to find the 1-norm
n-l
IWh=I>il
3=0

Quickies 19
and the co-norm
||x|| := max \xA
0<j<n
of this vector. Write a C++ program that calculates both norms using one
for loop.
Solution 32. 
At the beginning of the iteration we set the 1-norm and
the oo-norm to f abs (x [0] ).
/ / norms.cpp
#include <iostream>
#include <cmath>
using namespace std;
void norms(double* x.int n,double& norml,doublefe norminf)
i
norml = fabs(x[0]);
norminf = norml;
for(int i=l;i<n;i++)
{
x[i] = fabs(x[i]);
norml += x [i];
if(x[i] > norminf) norminf = x[i];
}
>
int main(void)
{
int n = 5;
double* x = new double[n];
x[0] = - 5 . 1 ; x[l] = 2.3; x[2] = 3.7; x[3] = 1.1; x[4] = 0.7;
double norml;
double norminf;
norms(x,n,norml,norminf);
cout << "norml = " << norml << endl;
cout << "norminf = " << norminf << endl;
delete [] x;
return 0;
>
Problem 33. Given an array x of n numbers
X = 
(xO,Xi,X2,...,Xn-i).

20 
Problems and Solutions
From this array form a new array y with n — 1 elements as follows (first
differences)
y : = (2/o = xi - i o , 2 / i = x2 - x i , . . . , j / n _ 2 = xn-i 
-xn-2).
From this array we form again a new array with n — 2 elements (second
differences)
Z := (Zo - 2/1 - 2/0, Z\ = 2/2 - 2/1, • • • , Zn-3 = 2/n-2 - 2/n-3)
and so on, till we obtain the array with one element. Write a C++ program
that finds all these arrays.
Solution 33. We store the one-dimensional arrays in a two-dimensional
jagged array A.
// jaggedarray.cpp
#include <iostream>
#include <iomanip>
using namespace std;
int main(void)
•C
double x[] = { 3.0, 7.0, 11.0, 13.0, 17.0, 19.0, 23.0 };
int n = sizeof(x)/sizeof(double); / / length of array
double** A = NULL;
A = new double*[n];
A [0] = new double[n];
int i, j ;
for(j=0;j<n;j++)
A[O][j] = x[j];
for(i=l;i<n;i++)
{
A [i] = new double[n-i];
for(j=0;j<n-i;j++)
A[i][j] = A[i-l][j+l] - A[i-l][j];
}
/ / display output
for(i=0;i<n;i++)
{

Quickies 21
for(j=0;j<n-i;j++)
cout « setw(4) « A[i][j] « " ";
cout « endl;
}
for(i=0;i<n;i++)
delete [] A[i];
delete[] A;
return 0;
>
Problem 34. The exponential function ex can be defined as
oo 
9-
or
ex := lim fl + - ) " . 
(2)
n—>oo \ 
n/
Thus for a; = 1 we can calculate e. Using the second definition and a
given n we can find an approximation for e. The following C++ program
implements this approximation.
/ / exp.cpp
#include <iostream>
#include <cmath>
using namespace std;
int main(void)
{
double x = 1.0;
double n = le308; / / le309 constant too big
double d = x/n;
cout « "d = " « d « endl;
double e = pow(l.0+d,n);
cout << "e = " « e;
return 0;
}
What is the output of this program?
Solution 34. 
The output is surprisingly 1 and not 2.71828... as we
expected. Explain why?
(1)

22 Problems and Solutions
Problem 35. In holography we have to calculate the phase difference
5 := ZL - za + JZQ + x2 - J z\ + x2
where i < zo, i < z^. Can the calculation be simplified using these
conditions?
Solution 35. Since
\/l + a w 1 H—a
2
for \a\ <C 1 and
^Z2+X2 = ZO]/l + X2/z2, 
y/z2+X2 
= 
ZLyJl+X2/zl
we obtain
5-x2(l 
M
Thus, we avoid the calculation of two square roots.
Problem 36. (i) Consider the vectors x, y, z in R3 and the expression
x x (y x z) + z x (x x y)
where x denotes the vector product. How can this expression be simplified?
(ii) Let A, B, C be n x n matrices over C. Let [A, B] := AB - BA be the
commutator. How can the expression
[A,[B,C]] + [C,[A,B}}
be simplified?
Solution 36. (i) We apply the Jacobi identity
x x (y x z) + z x (x x y) + y x (z x x) = 0.
Thus we only have to calculate —y x (z x x).
(ii) We also apply the Jacobi identity
[A,[B,C\] + [C,[A,B]] + [B,[C,A]} = 0.
Thus, we only have to calculate — [B, [C, A]].

Chapter 2
Bitwise Operations
Problem 1. What is the output of the following C++ code?
/ / twocomp.cpp
#include <iostream>
using namespace std;
int main(void)
{
int x = 15;
int y = ~x; 
/ / NOT operation (one complement)
cout « "y = " « y « endl;
int z = ++y; 
/ / adding 1
cout « "z = " « z « endl;
return 0;
>
Solution 1. The binary representation of 15 is
0000 0000 0000 0000 0000 0000 0000 1111
We first apply the NOT operation to x, i.e., the one's complement
1111 1111 1111 1111 1111 1111 1111 0000
This yields -16. Adding 1 to the least significant bit provides —15. Thus,
the two operations provide the two's complement.
23

24 Problems and Solutions
Problem 2. What is the output of the following Java code?
/ / ToLower.java
public class ToLower
{
public static void main(String[] args)
•C
char c = >Z';
int ic = (int) c; 
// type conversion ASCII table
ic = ic I 32; 
// bitwise inclusive OR
c = (char) ic; 
// type conversion ASCII table
System.out.println("c = " + c);
char d = 'x';
int id = (int) d; 
/ / type conversion ASCII table
id = id " 32; 
/ / bitwise exclusive OR
d = (char) id; 
/ / type conversion ASCII table
System.out.printlnC'd = " + d);
} / / end main
}
where I is the bitwise inclusive OR-operation, i.e.,
0 1 0 = 0 , 
0 1 1 = 1 , 
1 1 0 = 1 , 
1 1 1 = 1
and * is the bitwise exclusive OR-operation, i.e.,
0 " 0 = 0 , 
0 * 1 = 1 , 
1 * 0 = 1 , 
1 * 1 = 0 .
Solution 2. 
In the ASCII table the capital letter Z corresponds to 90
(base 10). In Java the data type char is of size 2 byte. Note that in C++
the data type char is of size 1 byte. The binary representation of 90 is (1
byte)
0101 1010.
We perform the bitwise OR-operation on the bit position 5 numbered from
0 from the right, since 25 = 32 (counting from right to left starting from
0). Thus, we obtain the small z. The ASCII value for z is 122 (= 90 + 32).
Thus, the first part of the program converts capital letters to small letters.
In the second part of the program we convert small letter into capital letters
using the bitwise XOR operation. The ASCII value for x is 120 (base 10).
The binary representation of 120 is (1 byte) 11111000.

Bitwise Operations 25
Problem 3. (i) Write down the function table (truth table) for the two's
complement. The number of inputs is four bits. The number of outputs is
five bits. Four outputs are for the two's complement and the fifth indicates
whether there was a carry in the process,
(ii) Find the boolean functions for the outputs.
Solution 3. 
(i) The two-complement is constructed taking the one-
complement (0 —» 1,1 —» 0) and then adding 1 to the least significant
bit, where 1 + 1 = 0 carry 1. Thus we have the truth table
Inputs 
Outputs 
Carry
0 I 0 I 0 I 0 0 I 0 0 1 0 
1
0
0
0
1
1
1
1
1 
0
0 0 1 0 
1
1
1
0 
0
0
0
1
1
1
1
0
1 
0
0 1 0 0 1
1
0 0 
0
0 1 0 1
1
0 1 1 
0
0
1
1
0
1
0
1
0 
0
0 1
1
1
1
0 0 1 
0
1
0
0
0
1
0
0
0 
0
1
0
0
1
0
1
1
1 
0
1 0 
1 0 0 1
1
0 
0
1 0 
1
1
0 1 0 1 
0
1
1
0
0
0
1
0
0 
0
1
1
0
1
0
0
1
1 
0
1
1
1
0 
0 0 1 0 
0
i | i | i | i | | o | o | o | i | 
o
(ii) We label the least significant bit as the 0 bit (from the right). Obviously,
we use
for the carry. For the least significant bit we use IQ. Then in increasing
significance we use
h®h 
=Ti®To,
and
where © is the XOR operation, • the AND operation and ~ is the NOT
operation.
Problem 4. The truth table for the NAND-gate is given by

26 Problems and Solutions
Ii I h II O"
0 
0 
1
O i l
1 
0 
1
1 1 1 11 0
It is a universal gate, i.e., all other gates can be built from this gate. Show
that the XOR-gate can be built from this gate.
Solution 4. We need four NAND-gates to build the XOR-gate. Let a, b
be the input, i.e.,
a,be{0,l}.
Then the XOR-gate can be expressed as
X0R(a,b) = NAND4(NAND2(a)NANDl(a,b)),NAND3(NANDl(a,b),b)).
Problem 5. Consider the following circuit.
a 
1 — 2»=+i 
Si
Pi 
I 
"«
<Ij 
1 
2H1 
i— 
& 
1
I 
1 
i 9i 
I 1
bi 
= t = & 
>i — ci+1
Find the truth table for Si and Ci+i. What does this circuit do?
Solution 5. We have the truth table.

Bitwise Operations 
27
o-i 
h 
Cj 
pi 
gj 
Tj 
8j 
Cj+i
0
0
0
0
0
0
0 
0
0 
1 0 
1 0 
0 
1 
0
1
0
0
1
0
0
1 
0
1
1
0 
0 
1 0 
0 
1
0 
0 
1 0 
0 
0 
1 
0
0 
1
1
1
0 
1 0 
1
1 0 
1
1
0 
1 0 
1
1 
1 
1 I 0 
1 
0 I 1 
1
The circuit is a full adder. The output s, is the ith bit of the sum and ci+i
is the carry bit.
Problem 6. 
Write a C++ program that counts the set bits in a given
computer word. For the program use unsigned long. For example, if
k — 15 the program returns 4.
Solution 6. 
The function bitcountO counts the number of bits set in
an unsigned long. The operation k &= (k-1) clears the lowest order bit
of k which is set.
// bitcount.cpp
#include <iostream>
using namespace std;
unsigned long bitcount(unsigned long k)
{
unsigned long r = 0;
while(k != 0)
•C
r++;
k &= (k-1);
}
return r;
>
int main(void)
{
unsigned long kl = 3;
unsigned long rl = bitcount(kl);
cout « "rl = " « rl « endl;
unsigned long k2 = 4;
unsigned long r2 = bitcount(k2);

28 Problems and Solutions
cout « "r2 = " « r2 « endl;
unsigned long k3 = 16;
unsigned long r3 = bitcount(k3);
cout « "r3 = " « r3 « endl;
unsigned long k4 = 255;
unsigned long r4 = bitcount(k4);
cout « "r4 = " « r4 « endl;
return 0;
}
Problem 7. What is the output of the following C++ program? Note
that ~ indicates the bitwise XOR operation in C++.
// func.cpp
#include <iostream>
using namespace std;
void func(int& x.intfe y) { x = x~y; y = x~y; x = x~y; }
int main(void)
-c
int x = -14, y = 17;
func(x,y);
cout « "x = " « x « endl; / / =>
cout « "y = " « y « endl; / / =>
x = -23; y = -45;
func(x.y);
cout « "x = " « x « endl; / / =>
cout « "y = " « y « endl; / / =>
return 0;
}
Solution 7. We pass x and y by reference. Since " is the bitwise XOR
we swap the values of x and y. Thus the output is x = 17, y = -14 in the
first case and x — —45, y — —23 in the second.
Problem 8. 
There are two ways to perform binary division, either by
repeated subtraction or using a shift-and-subtract principle. The latter is
used in practice as it is much faster.

Bitwise Operations 
29
Division by repeated subtraction is performed by subtracting the divisor
from the dividend until the result of the subtraction is negative. The re-
sultant quotient is given by the number of subtractions required minus 1.
The remainder is obtained by adding the divisor to the negative result.
The shift-and-subtract method of division is performed by succesively sub-
tracting the divisor from the appropriate shifted dividend and inspecting
the sign of the remainder after each subtraction. If the sign of the remain-
der is positive, then the value of the quotient is 1, but if the sign of the
remainder is negative, then the value is 0 and the dividend is restored to its
previous value by adding the divisor. The divisor is then shifted one place
to the right, and the next significant bit of the dividend is included and the
operation repeated until all bits in the dividend have been used. To sim-
plify the method further, instead of adding the divisor when the subtraction
yields a negative result, we can add the divisor shifted right by one position.
For example, consider the division of 90 by 9 viewed as 8 bit numbers. 90
is given by 01011010 and 9 is given by 00001001 in binary representation.
Then
011011010
-00001001
1111011111011010 
-> negative -> 0
+ 00001001
111110000|11010 
-> negative -> 0
+ 
00001001
11111001111010 
-> negative -> 0
+ 
00001001
1111110011010 
-> negative -> 0
+ 
00001001
000000100110 
-> positive -> 1
00001001
111110111|0 
-> negative -> 0
+ 
00001001
000000000| 
-> positive -> 1
00001001
11110111 
-> negative -> 0
+ 
00001001
00000000 
Remainder
The least significant bit is computed last. Thus the answer is 00001010.
Write a C++ program which implements this algorithm.
Solution 8. 
The function divisionO performs the division as specified
in the question.

30 Problems and Solutions
II division.cpp
#include <iostream>
using namespace std;
int division(int i.int d)
{
int q = 0;
i -= (d « 7);
for(int j=6;j>=0;j—)
if(i >= 0)
{ q += (1 « (j+i)); i -= (d « j); }
else i += (d « j);
return q;
}
int main(void)
{
cout « division(90,9) « endl;
return 0;
}
The output is 10.
Problem 9. In the Graphics class of Java the method
public abstract void setXORMode(Color cl)
sets the paint mode of this Graphics context to alternate between this
Graphics context's current color and the new specified color,
(i) Discuss the connection of this method with the bitwise XOR operation,
(ii) Write a Java program that uses this method and discuss the program.
Solution 9. (i) This specifies that logical pixel operations are performed
in the XOR mode, which alternates pixels between the current color and a
specified XOR color. When drawing operations are performed, pixels which
are the current color are changed to the specified color, and vice versa.
In other words, we XOR the color c of the pixel being written with current®
cl, i.e.,
current = (current © cl) © cl,
cl = (current © cl) © current.
(ii) The Java program is given by

Bitwise Operations 31
/ / XOR.Java
import java.applet.*;
import java.awt.*;
import j ava.awt.event.*;
public class XOR extends Applet
{
private Color strawberry = new Color(Oxcc.O,0x66);
private Color chocolate = new Color(0x66,0x33,0);
private Color vanilla = new Color(Oxff,Oxff,0x99);
private Color scoop = new Color(0x33,0x99,0xcc);
private static final int BORDER = 10;
public void init()
•C
setBackground(chocolate);
addMouseListener(new MouseAdapter() {
public void mousePressed(MouseEvent e) {
Graphics g = getGraphicsO;
g.setColor(chocolate) ;
g.setXORMode(scoop);
Dimension dim = getSizeO;
int diameter = dim.height - (2*B0RDER);
int xStart = (dim.width/2) - (diameter/2);
int yStart = BORDER;
g.fillOval(xStart,yStart,diameter.diameter);
g.setPaintMode();
}
}
); 
// end addMouseListener
} // end init
public void paint(Graphics g)
{
Dimension dim = getSizeO;
int width = dim.width/3; int height = dim.height;
g.setColor(strawberry);
g.fillRect(0,0,width,height);
g.setColor(vanilla);
g.fillRect(dim.width-width,0,width,height);
y // end paint
} // end class XOR

32 
Problems and Solutions
Problem 10. 
Consider two unsigned integers m and n. Multiplication
can be done using shift operations as follows (the Russian farmer multipli-
cation). At each step m is divided by 2 (shift right by 1) and n is multiplied
by 2 (shift left by 1). For example, let m = 35 and n = 40
m 
n
~35 
40~
17 
80
8 
169
4 
33©
2 
640
1 
1280
| 1400
All the numbers on the right-hand side are deleted if the number on the
left-hand side is even. The remaining numbers are added. This is the
result of the multiplication. Write a C++ program which implements the
Russian farmer multiplication using the shift operations. Testing whether
the number m is even or odd must also be done with a bitwise operation.
The data type of m and n should be unsigned long.
Solution 10.
// russian.cpp
#include <iostream>
using namespace std;
unsigned long multiply(unsigned long m,unsigned long n)
{
if(m == 0) return 0; if(n == 0) return 0;
if(m ==1) return n; if(n == 1) return m;
unsigned long temp = 0;
while(m != 0)
{
if((m & 1) == 1)
temp += n;
m = m » l ; n = n « l ;
}
return temp;
}
int main(void)
{
unsigned long m = 35, n = 40;

Bitwise Operations 33
unsigned long result = multiply(m,n);
cout « "result = " « result « endl;
return 0;
}
Problem 11. 
A checksum can be used to determine if errors occurred
in transmission of data. A simple 32-bit checksum algorithm, simply adds
all data in the transmission as if it were a series of 32-bit quantities, i.e.
we read 4 bytes each and add the resulting 32-bit quantities. When the
checksum overflows, the overflow bit is added to the checksum,
(i) Find the checksum for the string ABCD.
(ii) Write C++ code to compute the checksum of some data, and provide
options for comparing the checksum to a given value,
(iii) What errors can this 32-bit checksum detect?
Solution 11. (i) For the string ABCD we have
65 + 66 • 256 + 67 • 2562 + 68 • 2563 = 1145258561
where we used the ASCII table, where A -> 65, B -> 66, C -> 67 and
D -> 68.
(ii) The function checksum() computes the checksum for an arbitrary input
stream.
// checksum.cpp
#include <fstream>
#include <iostream>
using namespace std;
unsigned int checksum(istream &in)
{
unsigned int sum = 0;
unsigned int value;
while(!(in.eof())) {
value = 0 ; // for 0 padding
in.read((char*)& value,sizeof(unsigned int));
ifOin.eoiO) {
if(sum+value<sum) { // overflow
sum += value;
sum++;
} else { sum += value; }
>
}

34 Problems and Solutions
return sum;
}
int main(int argc.char *argv[])
•C
ifstream file;
if(argc < 2) {
cout « "stdin: " << checksum(cin) « endl;
} else {
for(int i=l;i<argc;i++) {
file.open(argv[i],ios::in I ios.binary);
cout « argv[i] « ": " « 
checksum(file)
« endl;
f ile.clearO ;
file.closeO ;
}
}
return 0;
}
(iii) If we look at the checksum it is clear that any difference in two se-
quences of 32-bit values that is not a multiple of 232 in total will result in a
different checksum. This allows us to detect all errors that do not produce
a difference in the sum of precisely 232 = 4294967296. The checksum in this
example is further improved by the addition of the carry bit. The addition
of the carry bit will prevent multiples of 4294967296 from being detected
as a no error condition. So now all errors must result in a net increase of
zero in the sum if they are to go undetected, i.e., some values must decrease
and others increase to get a net result of zero difference over the sum.
Problem 12. Let { Xj J^SQ1 be a sequence of N bits. A measure of the
correlation between bits at distance n is given by
1 
j=N-l
r(n) := -^ ^2 
X3®XU+n)modN
where © is the XOR operation. Implement F(?i) in C++ using the standard
template library with the bitset class. The class bitset<size_t N> is a
class that describes objects that can store a sequence of a fixed number of
bits, N. The constructor bitset (unsigned long val) constructs an object
of class bitset<N>, initializing the first M bit values to the corresponding
bits in val. The template parameter N of bitset<N> is of type size_t.
Apply it to different bitstrings.

Bitwise Operations 35
Solution 12. To implement T for a bitset of any length we need to use
a template function.
// bitcorrelation.cpp
#include <iostream>
#include <bitset>
using namespace std;
template<size_t N> double gamma(int n,bitset<N> b)
{
double v = 0.0;
// make sure to use positive n
while(n < 0) n += N;
for(int j=O;j<N;j++) v += b[j] ~b[(j+n)'/.N] ;
v /= N;
return v;
}
int main(void)
{
bitset<8> bl (stringC 10010010") );
bitset<16> b2(string("0110100101101001"));
cout << bl « endl
« 
M\tGamma(2) = " « gamma(2,bl) « endl
« "\tGamma(4) = " << gamma(4,bl) « endl;
cout « b2 « endl
« "\tGamma(2) = " « gamma(2,b2) « endl
« "\tGamma(3) = " « gamma(3,b2) « endl
« "\tGamma(4) = " « gamma(4,b2) « endl;
return 0;
}
Problem 13. Cyclic redundancy checks provide a better means of check-
ing data for errors. The CRC32 polynomial
G(x) = 
x
32+x26+x23+x*2+xw+x12+xu+xw+x*+x7+x!i+xi+2?+x+l
is a commonly used polynomial for error detection. This polynomial is
represented as a bit string where each coefficient (1 or 0) is a binary digit
in the string. To check for errors in transmitted data, we do the following:

36 Problems and Solutions
• Compute the CRC of the data to be sent
• Send the data and CRC
• Recompute the CRC and check whether it matches the sent CRC
To compute the CRC we do the following: we let B{x) be the data to
be sent plus 32 O's appended (i.e., multiply by x32). Now we calculate
R{x) = B(x)modG(x), 
and set T(x) = B{x) - R{x). This sets the low
bits of T to R. We transmit T to get T'. If T'(x) mod G(x) = 0 then there
was no error. We can perform the remainder calculation using a feedback
shift register:
• Create a register with 32 bits, all set to zero.
• For each G{x) where the coefficient is 1, build an XOR gate, so the
output is xorred with the bit that is shifted into that register.
The data bits are shifted in one at a time. All the bits shift one position
on, and if there is an xor gate then XOR the position with the value in the
last register. Write a C++ program to calculate the CRC of a file using
the CRC polynomial.
Solution 13.
/ / CRC32.cpp
#include <bitset>
#include <iostream>
#include <iomanip>
#include <fstream>
using namespace std;
int poly[] = { 0,1,2,4,5,7,8,10,11,12,16,22,23,26,-1 };
const unsigned long n = 32;
bitset<n> result;
bitset<n> crc32(bitset<8> data)
{
bool bit;
int xorpos, pos;
for(int i=0;i<8;i++) {
bit = result [31];
result « = 1;

Bitwise Operations 37
result.set(0,data[i]);
xorpos = 0;
while(poly[xorpos]!=-l)
{
pos = poly[xorpos];
result.set(pos,bit~result[pos]);
xorpos++;
}
}
return result;
}
void calc_crc(istream& in)
{
unsigned char c;
bitset<n> crc;
result.reset();
while(! in. eofO) {
in.read((char*) &c,l);
if(lin.eof()) {
bitset<8> data(c);
crc = crc32(data);
>
}
cout « crc « "(" « setbase(16) « crc.to_ulong() « 
" ) "
« endl;
}
int main(int argc.char *argv[])
{
ifstream fin;
if(argc > 1) {
for (int i=l;i<argc;i++) {
fin.open(argv[i],ios::in|ios::binary);
cout « argv[i] « ": ";
calc_crc(fin);
f in.closeO ;
}
} else { calc_crc(cin); }
return 0;
>

38 Problems and Solutions
Problem 14. A flip-flop circuit, especially a J-K flip-flop that can mem-
orize a single bit of information, has been of great use in memory modules
of computer hardware. The next state Q(t + 1) of a J-K flip-flop is char-
acterized as a function of both the present state Q(t) and the present two
inputs J(t) and K{t). The truth table of the J-K flip-flop is given by
J(t) 
K(t) 
Q(t) 
Q(t+1)
0 
0 
0 
0 
no change
0 
0 
1
1 
no change
0 
1
0 
0 
reset
0 
1
1
0 
reset
1
0 
0 
1 
set
1
0 
1
1 
set
1
1
0 
1 
toggle
1
1
1
0 
toggle
(i) A sum of products is a bitwise OR of product forms. It is also called
minterm. Find the sum of products expression of Q(t +1), where + denotes
the OR operation and ~ denotes the NOT operation,
(ii) Simplify the minterm expression.
Solution 14. (i) We have four rows in the truth table where Q(t+1) is 1.
These rows are ORed together. Thus we find that the minterm expression
of Q(t + 1) is
Q(t + 1) = J(t)K(t)Q(t) + J{t)K(t)Q(t) + J(t)K(t)Q{t) + J(t)K{t)Q(t)
where J(t)K(t) denotes the AND operation of J(t) and K(t).
(ii) The simplification yields
Q(t + l) = J(t)Q(t) + K(t)Q(t).
Problem 15. 
Given a boolean function / : { 0,1 }™ —> { 0,1} with the
operations AND, OR, XOR. Write a C++ program that calculates / for
all 2" combinations. As an example consider
f(xO,Xi,X2,X3) 
= X3 © X2 © Xi © X0
where © denotes the XOR operation. Note that the XOR operation is
associative.
Solution 15. 
The results of the calculations of the boolean function /
are stored in the array result []. The different bits for each combination
are stored in the array x [].

Bitwise Operations 39
// boolfunction.cpp
#include <iostream>
#include <cmath>
using namespace std;
int f(int* x) { return (x[0] ~ x[l] " x[2] * x[3]); >
int main(void)
{
int n = 4; 
// number of bits
int p = pow(2,n); 
// number of possible bitsrings 2~n
int* x = new int[n];
int* result = new int[p];
for(int j=O;j<p;j++)
{
int t = j ;
for(int k=0;k<n;k++)
{
x[k] = t & 1; 
/ / bitwise AND
t = t >> 1; 
/ / shift for integer division by 2
}
result[j] = f(x);
}
for(int l=0;l<p;l++)
cout « "result [" « 1 « "] = " « result[1] « endl;
delete[] x; delete[] result;
return 0;
}
Problem 16. 
Depending on which computing system we use, we will
have to consider the byte order in which multibyte numbers are stored,
particularly when we are writing those numbers to a file. The two orders
are called Little Endian and Big Endian.
Little Endian means that the low-order byte of the number is stored in
memory at the lowest address, and the high-order byte at the highest ad-
dress. Big Endian means that the high-order byte of the number is stored
in memory at the lowest address, and the low-order byte at the highest
address.

40 Problems and Solutions
Consider a 4 byte integer where bO is the low-order byte and b3 is the high-
order byte. Let i denote the integer and bi the byte array of i. On Little
Endian systems we have
bi[0] == bO
bi[l] == bl
bi[2] == b2
bi[3] == b3
and on Big Endian systems we have
bi[0] == b3
bi[l] == b2
bi[2] == bl
bi[3] == bO
Write a C++ program that converts between Little Endian and Big Endian.
Solution 16.
// convert.cpp
#include <iostream>
using namespace std;
long convert(long i)
{
long temp = 0;
temp 1= (i & OxFFOOOOOO) » 24;
temp |= (i & OxOOFFOOOO) » 8;
temp |= (i & OxOOOOFFOO) « 8;
temp 1= (i & OxOOOOOOFF) « 24;
return temp;
}
int main(void)
{
long i = 293;
cout « "(Little Endian) i = " « i « endl;;
cout « "(Big 
Endian) i = " « convert(i) « endl;
cout « "(Little Endian) i = " « convert(convert(i));
return 0;
}

Bitwise Operations 41
Problem 17. Let X and Y be binary n-tuples, for example
X = "01100100", Y = "11100111" .
The Hamming distance between X and Y, H(Y, X) is the number of com-
ponents in which X and Y differ. For the present example it would be
3.
The Hamming distance is a metric, i.e.,
(a) H(X, Y)>0
(b) H(X, Y) = 0 if and only iiX = Y.
(c)H(X,Y)=H(Y,X)
(d)H(X,Z)<H(X,Y) 
+ H(Y,Z)
The standard template library in C++ provides a class bit set to handle
bit operations. Write a C++ program using the bit set class that finds
the Hamming distance between two binary n-tuples..
Solution 17. The function hamming0 uses the function count () of the
bitset class. The function count () counts the number of 1' s in the bitset.
// hamming.cpp
#include <iostream>
#include <string>
#include <bitset>
using namespace std;
template <size_t n>
int hamming(const bitset<n>& bl,const bitset<n>& b2)
{ return (bl*b2).count(); }
int main(void)
{
bitset<4> a(string("0110"));
bitset<4> b(string("1010"));
cout « "H(" « a « "," « b « ") = " « hamming(a,b);
cout << endl;
bitset<8> x(string("01100100"));
bitset<8> y(string("11100111"));
cout « "H(" « x « "," « y « ") = " « hamming(x,y);
cout « endl;
return 0;
}

42 
Problems and Solutions
Problem 18. Computers store data of all kinds as sequences of O's and
l's, or bits (from binary digit). We might think that these bits are stored
verbatim on a disk drive. However, practical considerations call for more
subtle schemes, and these lead to shifts of finite type. There are two schemes
to transform an arbitrary sequence of bits into one obeying constraints that
control intersymbol interference and clock drift.
(i) The first method is called frequency modulation. This scheme controls
clock drift with the insertion of a clock bit 1 between each pair of data bit
(0 or 1). If the original data is
1 0 0 0 1 1 0 1
then the frequency modulation coded data is
1 1 1 0 1 0 1 0 1 1 1 1 1 0 1 1
The clock bits are underlined here. They are stored identically to data bits.
The original data is recovered by ignoring the clock bits. Given the original
data, write a C++ program using the bitset class that implements the
frequency modulation and the recovering of the original data,
(ii) The modified frequency modulation scheme inserts a 0 between each
pair of data bits unless both data bits are 0, in which case it inserts a 1.
For example, if the original data are
1 0 0 0 1 1 0 1
the modified frequency modulation coded sequence is
0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1
Here the initial data bit is 1, so the bit inserted to its left must be 0. If
the initial data bit were 0, we would need to know the previous data bit
before we could decide which bit to insert to its left. Given the original
data write a C++ program using the bitset class that implements the
modified frequency modulation and the recovering of the original data.
Solution 18. Note that bitset<n> displays right to left.
// modulation.cpp
#include <iostream>
#include <bitset>
using namespace std;
template <size_t n>

Bitwise Operations 43
bitset<2*n> freqmod(const bitset<n>& b)
{
bitset<2*n> b2;
for(int i=0;i<n;i++)
{
b2[2*i] = b[i];
b2[2*i+l] = 1;
}
return b2;
}
template <size_t n>
bitset<2*n> m_freqmod(const bitset<n>& b)
{
bitset<2*n> b2;
for(int i=0;i<n;i++)
•C
b2[2*i] = b[i];
if(i != (n-1) && b[i] == 0 && b[i+l] == 0) b2[2*i+l] = 1;
else b2[2*i+l] = 0;
}
return b2;
}
int main(void)
i
bitset<8> b(string("10001101"));
cout « b « endl;
cout « freqmod(b) « endl;
for(int i=0;i<8;i++) cout « "- ";
cout « endl;
cout « b « endl;
cout « m_freqmod(b) « endl;
for(int j=0;j<8;j++) cout « "- ";
cout << endl;
return 0;
>
Problem 19. Write a C++ program that, given an unsigned long, finds
the next unsigned long with the same number of bits set. For example,
4 is in binary 100. Then the next number would be 8 since in binary we
have 1000.

44 Problems and Solutions
Solution 19. The function nextO in the C++ program finds the lowest
order bit in i which is set and clears it. The next lowest order bit, which
is cleared, is then set.
// samenoofbits.cpp
#include <iostream>
using namespace std;
unsigned long next(unsigned long i)
{
unsigned long bit = 1, count = -1;
if(i == 0) return 0;
while(!(bit & i)) { bit « = 1; } // find first one bit
while(bit & i) { count++; bit « = 1; } // find next zero bit
if Obit) { cout « "overflow in next"; exit(0); }
i &= ("(bit - 1)); // clear lower bit
i |= bit I ((1 « count) - 1);
return i;
}
int main(void)
{
unsigned long il = 0;
unsigned long rl = next(il);
cout « "rl = " « rl « endl;
unsigned long i2 = 1;
unsigned long r2 = next(i2);
cout « "r2 = " « r2 « endl;
unsigned long i3 = 3;
unsigned long r3 = next(i3);
cout « "r3 = " « r3 « endl;
unsigned long i4 = 7;
unsigned long r4 = next(i4);
cout « "r4 = " « r4 « endl;
return 0;
}
Problem 20. Let
a = a(n-l)a(n-2)...a(l)a(0), 
b = b(n-l)b(n-2)...b(l)b(O)
be two n-bit binary numbers. We want to compute the sum

Bitwise Operations 45
a + b = s = s(n)s(n-l)...s(l)s(O) .
The standard algorithm is to add from right to left, propagating a carry-bit
c(i) from bit to bit. In the following algorithm, 0 or F means false, 1 or T
means true, and OR, XOR, and AND are logical operations
c(-l) = 0
for i=0 to n-1
c(i) = ((a(i) XOR b(i)) AND c(i-l)) OR (a(i) AND b(i))
s(i) = a(i) XOR b(i) XOR c(i-l)
endfor
s(n) = c(n-l).
The challenge is to propagate the carry bit c(i) from right to left more
quickly. Then all the sum bits s(i) can be computed in a single time step.
Solution 20. 
Let p(i) = (a(i) XOR b(i)) be the propagate bit and
g(i) = (a(i) AND b(i)) the generate bit. Thus we can write
c(i) = (p(i) AND c(i-D) OR g(i).
We evaluate this recurrence using parallel prefix, where the associative op-
eration is a 2-by-2 Boolean matrix multiplication
( c(i) \ _ fp(i) AND c{i - 1) OR g(i) \
[T)-{ 
T 
)
_ f p « 
9(i)\(c{i-l)\
~\F 
T]{ 
T J
= c(i) • c(» -1) *... * c(i) * c(o) * (^ 
)
where c(-l) = F. The Boolean matrix multiplication is associative, be-
cause AND and OR satisfy the same associative and distributive laws as mul-
tiplication and addition. This algorithm is called carry look-ahead. It is
used in microprocessors to perfom integer addition.
Problem 21. 
Consider / : {0,1}" -> {0,1}. The Walsh transform
Wf : {0,1}" -» Z of / is given by
Wf{w) = J2 
(~l)f{x)+w-x
x€{0,l}'1

46 Problems and Solutions
where
i = (a;o,a;1,...,xn_i) 
xo,xu ... ,a;n_i G {0,1}
W = ( w O , W l , - - - , W n _ i ) 
tUo,M>l,-..,Wn-l G { 0 , 1 }
and
to • x — woxo © wi^i © ... © w n_i3; n_i
denotes the inner product of w and 2\ Thus, we find
-2n <Wf(w) 
<2n.
For n even, the set of bent functions is the set of functions / : {0,1}™ —>
{0,1} such that
\Wf(w)\ = 2% Vii)e{0,l}"
Find all bent functions for n — 2 and n = 4.
Solution 21. We identify x with an integer y(x) £ Z according to
y(x) = x0 + 2xx + • • • + 2"-1:rn_1
and similarly for w. Thus, we can simply iterate over the values 1, 2, 3,
..., 2™ — 1 for w and x. The function / is represented as an element of
{0,1}2". Thus, we have
/->(/o,/i,..-,/2»-i), 
/o,/i,...,/ 2«-iG{0,l}
/„(*)=/(*) 
y ( i ) = 0 , l , 2 . . . , 2 n - l .
The following C++ program finds all bent functions for n = 2. The value
for const size_t n should be changed to 4 to find all the bent functions
for n = 4.
// bent.cpp
#include <iostream>
#include <bitset>
using namespace std;
const size_t n = 2;
long ip(bitset<n> x,bitset<n> y)
{ return (x&y) .count()°/.2; }
long walsh(bitset<(l«n)> f ,bitset<n> w)

Bitwise Operations 47
long x = 0, sum = 0;
for(;x<(l«n);x++)
{
if ((f [x] +ip (w,bitset<n> (x)))7,2) sum—;
else sum++;
}
return sum;
}
int main(void)
{
long f, w, bent, wf = 0;
for(f=0;f < (l«(l«n));f++)
{
bent = 1;
for(w=0;w<(l«n) && bent;w++)
•C
wf = walsh(bitset<(l«n)>(f) ,bitset<n>(w)) ;
if((wf != (l«(n/2))) && (wf != - ( l « ( n / 2 ) ) ) ) bent = 0;
}
if (bent) cout « bitset<(l«n)>(f) « endl;
}
return 0;
}
Problem 22. Given a binary string
"100001010110010101110 
10111"
of finite length n. Let A* denote the set of all finite-length sequences
(strings) over a finite alphabet A (in our case {0,1}). The quantity S(i,j)
denotes the substring S(i,j) := SjSj+i ... Sj. A vocabulary of a string S,
denoted by v(S), is the subset of A* formed by all the substrings, or words,
S(i, j) of S. The complexity, in the sense of Lempel and Ziv, of a finite
string is evaluated from the point of view of a simple self-delimiting learning
machine which, as it scans a given n digit string S = sis2 . • • sn from left
to right, adds a new word to its memory every time it discovers a substring
of consecutive digits not previously encountered. Thus, the calculation of
the complexity c(n) proceeds as follows. Let us assume that a given string
S1S2 • • • sn has been reconstructed by the program up to the digit sr and that
sr has been newly inserted, i.e., it was not obtained by simply copying it
from S1S2 • • • sr_i. The string up to sr will be denoted by R := S1S2 • • • sro,
where the o indicates that sr is newly inserted. In order to check whether
the rest of R, i.e., sr_|_isr_(_2 • • • sn can be reconstructed by simple copying or

48 Problems and Solutions
whether one has to insert new digits, we proceed as follows: First, one takes
Q = sr+i and asks whether this term is contained in the vocabulary of the
string R so that Q can simply be obtained by copying a word from R. This
is equivalent to the question of whether Q is contained in the vocabulary
v(RQn) of RQir, where RQTT denotes the string which is composed of R
and Q (concatenation) and TT means that the last digit has to be deleted.
This can be generalized to situations where Q also contains two (i.e., Q =
sr+isr+2) 
or more elements. Let us assume that sr+i can be copied from
the vocabulary of R. Then we next ask whether Q = sr+isr+2 is contained
in the vocabulary of RQn and so on, until Q becomes so large that it can no
longer be obtained by copying a word from v(RQn) and one has to insert
a new digit. The number c of production steps to create the string S, i.e.,
the number of newly inserted digits (plus one if the last copy step is not
followed by inserting a digit), is used as a measure of the complexity of a
given string.
(i) Find the complexity of a string which contains only zeros,
(ii) Find the complexity of a string which is only composed of units of 01,
i.e.,
01010101...01.
(iii) Find the complexity of the string 0010.
(iv) Write a C++ program that finds the complexity c(n) for a given binary
string of length n.
Solution 22. 
(i) If we have a sequence which contains only zeros, we
could say that it should have the smallest possible complexity of all strings
(equivalent to a string consisting only of l's). One only has to insert the
first zero and can then reconstruct the whole string by copying this digit,
i.e.,
00000... ^ 0 o 0 0 0 . . . .
Thus, the complexity of this string is c = 2.
(ii) Similarly, one finds for a sequence which is only composed of units 01,
i.e.,
010101...01->0olo0101...01
the value c = 3.
(iii) The complexity c of the string 5 = 0010 can be determined as follows:
(1) The first digit has always to be inserted —> 0o
(2) R = 0, Q = 0, RQ = 00, RQTT = 0, Q e V{RQTT) -> 0 o 0
(3) R = 0,Q = 01, RQ = 001, RQTT = 00, Q £ v{RQn) -» 0 o Olo

Bitwise Operations 49
(4) R = 001, Q = 0,RQ = 0010, RQir = 001, Q £ v(RQn) -» 0 o 01 o 0 .
Now c is equal to the number of parts of the string that are separated
by o, i.e., c = 3.
(iv) A computer program in C++ for finding the complexity uses a do-while
loop, a for loop and a while loop as follows:
/ / Lempel.cpp
#include <iostream>
#include <string>
using namespace std;
int complexity(const string S.int n)
{
int c = 1, m = 1;
do
•C
int k = 0, kmax = 1;
for(int i=0;i<m;i++) {
while(S[i+k] == S[m+k])
•C
++k;
if(m+k >= n-1) return ++c;
}
if(k >= kmax) kmax = ++k;
k = 0;
}
++c;
m += kmax;
> while(m < n);
return c;
}
int main(void)
{
string S;
cout « "enter string: ";
cin » S;
int n = S.lengthO ;
cout << "length of string is: " << n << endl;
cout << "The complexity of the string: ";
cout « S;
cout « " is " « complexity(S,n) « endl;

50 Problems and Solutions
return 0;
}
Problem 23. 
The CMOS 4011 contains 4 NAND gates. Two of them
can be used to build the following circuit
+9Vdc
I 
1 
Tl4 
R 2
—' 
I— 
I,—L-^ 
5j 
1 
470ft
0 
u ^-r—f 
& >^-T-r~T—o
-TLrLnnn.0 
p 
I I ^1 
I
NRA 
^ ^ 0 1 
Output
A dual monostable/astable multivibrator (for example 556) provides a monos-
table output pulse.
5V 
I* 
\
OV 
' 
'
The pulse is fed into pin 1 of the NAND gate. The astable output of the
multivibrator
is fed into pin 2 of the NAND gate. Discuss the circuit as a function of the
gate input at 1 and the pressure sensor (resistor RA). Consider first RA=0
and RA=oo.
Solution 23. 
When RA=0 the voltage at the output is 0V, we have a
short circuit. The second NAND gate (with inputs 5 and 6 and output 4)
is used for negation. Thus, when RA=oo, we obtain the astable output of
the multivibrator only when the input to pin 1 is HIGH.
5V 
" 
T 
"

Chapter 3
Number Manipulations
Problem 1. Write a C++ program to convert between unsigned integer
number representations. For the internal representation, we can use an
array of int to store the coefficients, where the first entry is the base and
the last entry is —1. Thus, to represent the number 43 decimal in binary,
we would use the one-dimensional array (read bitstring left to right)
(2,1,1,0,1,0,1,-1).
Write C++ functions of the form
int most_significant(int x,int base);
void tobase(int x.int base,int*& rep);
void convert_base(int* inrep,int base,int*& outrep).
The function most_signif icant () calculates the size of the array of coeffi-
cients for the representation. For the above example (binary representation
of 43) the value returned is 5 (the coefficient of 25 is the last entry of the ar-
ray). The function tobaseO takes an integer and stores the representation
for x in rep, tobaseO should allocate the memory for rep. Explain the
reason for the data type of the third parameter of tobase (). The function
convert_base() is equivalent to tobaseO, except it takes an arbitrary
representation for the integer to convert. Use the program to convert 157
decimal to binary, and then from binary to ternary (base 3) representation.
51

52 
Problems and Solutions
Solution 1. 
The function log() calculates [log6n], i.e., the smallest
integer a such that ba > n. The function fromrepO converts from the
representation to an integer. The function printrepO prints out the digits
of the representation.
/ / convertbase.cpp
#include <iostream>
using namespace std;
int log(int base,int n)
{
int 1 = 0, b = 1;
while(n-b>0) { 1++; b *= base; }
return 1-1;
}
int most_significant(int x,int base)
{ return log(base,x); }
unsigned int fromrep(int *r)
{
int x = 0;
int b = 1;
for(int i=l;r[i]!=-l;i++,b*=r[0])
x += r[i]*b;
return x;
}
void tobase(int x.int base,int*& rep)
{
int len = most_significant(x,base)+2;
rep = new int[len];
rep[0] = base;
for(int i=l;i<len;i++)
{ rep[i] = x'/,base; x /= base; }
rep[len] = -1;
}
void convert_base(int* inrep.int base,int*& outrep)
{
int x = fromrep(inrep);
tobase(x,base,outrep);
}

Number Manipulations 53
void printrep(int* r)
{
cout « "( ";
for(int i=l;r[i]!=-l;i++)
cout « r[i] « " ";
cout « ") base " « r[0];
}
int main(void)
{
int *bin, *tern;
tobase(157,2,bin);
convert_base(bin,3,tern);
cout « "Binary representation of " << fromrep(bin)
« " is ";
printrep(bin); cout<<endl;
cout « "Ternary representation of " « fromrep(tern)
« " is ";
printrep(tern) ; cout<<endl;
deleted bin; delete [] tern;
return 0;
}
Problem 2. Any positive integer j (j G N) can be written uniquely as
j = 2n(2s + l), 
n , s £ N 0 .
For example,
22 = 21(2-5 + l)
17 = 2°(2-8 + l)
16 = 24(2-0 + l).
Given j , write a C++ program which finds n and s which satisfy the above
equation.
Solution 2. We note that j is given by the product of an even number
multiplied with an odd number. Thus, if we find the largest n such that
j / 2 " e N we can obtain s from
The following two programs implement this method.

54 Problems and Solutions
// decomposel.cpp
#include <iostream>
using namespace std;
void factor(int j)
{
int n, s;
for(n=0; ! ((j»n)'/.2) ;n++);
s = ((j»n)-l)/2;
cout « j « "=2~" << n « "(2*" « s « "+D"
« endl;
>
int main(void)
factor(723);
factor(800);
return 0;
}
In the next program, we first test whether the number j is even or odd. If
the number is odd, then obviously we have n = 0.
// decompose2.cpp
#include <iostream>
using namespace std;
void test(long j)
{
long n, s;
if((j7.2) != 0)
{
n = 0;
cout « "n = " « n << endl;
s = (j-D/2;
cout « "s = " << s;
}
else
{
long counter = 1;
while(((j/2)7.2) == 0)
{

Number Manipulations 
55
counter++;
j = J/2;
}
n = counter;
s = (J/2-D/2;
cout « "n = " « n « endl;
cout « "s = " « s;
} // end else
}
int main(void)
{
long j = 22; test(j);
cout << endl;
j = 13; test(j);
return 0;
>
Problem 3. 
Sarkovskii's theorem describes an ordering of the natural
numbers according to which periodicities imply other periodicities for con-
tinuous maps on R. The ordering is as follows
3o5s>7>9t>...[>2-3>2-5i>2-7>...t>22-3>22-5i>22-7i>...>23[>22>2i>l
In other words, all odd numbers excluding 1 come first followed by the
same sequence multiplied by 2 then 22 and so in. Lastly, the powers of 2 in
decreasing order. Write a C++ program which can determine for any two
integers x and y whether x > y or y t> x.
Solution 3. 
The function decompose(i,x,y) finds x and y such that
i = y2~x and y is odd. The function sbefore(a.b) can then compare a
and b in the Sarkovskii ordering.
// Sarkovskii.cpp
#include <iostream>
#include <cstdlib>
using namespace std;
void decompose(unsigned int i,unsigned int& x,unsigned int& y)
{
x = 0;
while(!(i&l)) { i » = 1; x++; }
y = i;

56 Problems and Solutions
}
int sbefore(unsigned int x,unsigned int y)
•C
unsigned int xl,yl,x2,y2;
decompose(x,xl,x2);
decompose(y,yl,y2);
if(x2==l && y2!=l) return 0;
if(x2!=l && y2==l) return 1;
if(x2==l && y2==l) return yl < xl;
if(x2!=l && y2!=l) return xl < yl || (xl == yl && x2 < y2);
}
int main(int argc.char *argv[])
•C
unsigned int x, y;
if(argc!=3) return 1;
x = atoi(argv[l]); y = atoi(argv[2]);
if(sbefore(x,y)) cout « x «" |> " « y « endl;
if(sbefore(y.x)) cout « y «" |> " « x « endl;
return 0;
>
Problem 4. Let n be a natural number. The recursive relation used to
determine the Farey fraction Xk/yk is given by
Vk+n
Xk+2 = 
Xk + l - %k
L Vk+l \
Vk+n
Vk+2 = 
Vk+i - Vk
L Vk+i J
where the initial conditions are XQ — 0, yo = xi — 1 and yi = n. The
sequence of Xk/yk is called the Farey sequence. The floor of a denoted
by [a\ is the greatest integer which is not greater than a, for example
[5.3J — 5. Write a C++ program to determine the Farey sequence for
given n. Determine the first 11 elements of the sequence for n — 5.
Solution 4.
// Farey.cpp
#include <iostream>
#include <cmath>

Number Manipulations 57
using namespace std;
int main(void)
{
int n = 5;
int xk = 0, yk = 1;
int xkl = 1, ykl = n;
int xk2, yk2;
int m = 11;
for(;m>0;m—)
•C
xk2 = (int) floor(double(yk+n)/ykl)*xkl-xk;
yk2 = (int) floor(double(yk+n)/ykl)*ykl-yk;
cout « xk « "/" « yk « endl;
xk = xkl; yk = ykl;
xkl = xk2; ykl = yk2;
}
return 0;
}
Problem 5. Consider the following C program.
/ / expl.c
#include <stdio.h>
int main(void)
{
int N = 9009;
int a[9009];
int n, x = 0;
for(n=l;n<N;n++) a[n] = 1;
a[l] = 2;
for(;N > 9;printfO7.d",x))
for(n=N--;— n>0;)
•C
a[n] = x7.n;
x = 10*a[n-l]+x/n;
>
return 0;
}

58 Problems and Solutions
(i) Describe the algorithms implemented in the program. What is calcu-
lated?
(ii) Generate the assembler code for the programs. Explain the assembler
code.
Solution 5. (i) The program expl. c determine the 9009 digits of
e = 2.71828... .
(ii) The comments explain the programs. For the Microsoft Visual C++
compiler we use
cl /Fa expl.cpp
to obtain the assembler code in the file expl.asm. From Microsoft Visual
C++ we obtain the assembler code (Intel style, line numbers and variable
names automatically generated - our comments begin with ; **)
TITLE expl.cpp
.386P
include listing.inc
if OVersion gt 510
.model FLAT
else
.TEXT SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT ENDS
.DATA SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA ENDS
CONST SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST ENDS
_BSS SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS ENDS
_TLS SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS ENDS
FLAT GROUP .DATA, CONST, _BSS
ASSUME CS: FLAT, DS: FLAT, SS: FLAT
end if
PUBLIC _main
EXTRN _printf:NEAR
EXTRN __chkstk:NEAR
_DATA SEGMENT
$SG536 DB 7,d\ 00H
_DATA ENDS
_TEXT SEGMENT

Number Manipulations 
59
_N$ = -36048
_a$ = -36036
_x$ = -36040
_n$ = -36044
_main PROC NEAR
; File expl.cpp
; Line 6
;** preserve stack **
push ebp
mov ebp, esp
;** allocate memory for a[9009],x,n,N **
mov eax, 36048 ; 00008cd0H
call 
chkstk
; Line 7
;** N=9009 **
mov DWORD PTR _N$[ebp], 9009 ; 00002331H
; Line 9
;** X=0 **
mov DWORD PTR _x$[ebp], 0
; Line 11
;** n=l **
mov DWORD PTR _n$ [ebp], 1
jmp SHORT $L530
$L531:
;** n++ **
mov ecx, DWORD PTR _n$[ebp]
add ecx, 1
mov DWORD PTR _n$[ebp], ecx
$L530:
;** while n<N **
mov edx, DWORD PTR _n$[ebp]
cmp edx, DWORD PTR _N$[ebp]
jge SHORT $L532
;** a[n]=l **
mov eax, DWORD PTR _n$[ebp]
mov DWORD PTR _a$[ebp+eax*4], 1
jmp SHORT $L531
$L532:
; Line 12
;** a[l]=2 **
mov DWORD PTR _a$[ebp+4], 2
; Line 14
jmp SHORT $L533
$L534:

60 
Problems and Solutions
;** printf('7.d",x)
mov ecx, DWORD PTR _x$[ebp]
push ecx
push OFFSET FLAT:$SG536
call _printf
;** remove printf parameters from stack **
add esp, 8
$L533:
;** while N>9 **
cmp DWORD PTR _N$[ebp], 9
jle SHORT $L535
; Line 15
;** n=N N — **
mov edx, DWORD PTR _N$[ebp]
mov DWORD PTR _n$[ebp], edx
mov eax, DWORD PTR _N$[ebp]
sub eax, 1
mov DWORD PTR _N$[ebp], eax
$L538:
;** n— **
mov ecx, DWORD PTR _n$[ebp]
sub ecx, 1
mov DWORD PTR _n$[ebp], ecx
;while n>0
cmp DWORD PTR _n$[ebp], 0
j l e SHORT $L539
; Line 17
;** eax **
mov eax, DWORD PTR _x$[ebp]
;** convert (signed) eax to edx:eax **
cdq
;** a[n]=xV,n **
idiv DWORD PTR _n$[ebp]
mov eax, DWORD PTR _n$[ebp]
mov DWORD PTR _a$[ebp+eax*4], edx
; Line 18
;** ecx=a[n-l] **
mov ecx, DWORD PTR _n$[ebp]
mov ecx, DWORD PTR _a$[ebp+ecx*4-4]
;** ecx=10*a[n-l] **
imul ecx, 10 ; OOOOOOOaH
;** eax=x/n+ecx
mov eax, DWORD PTR _x$[ebp]
cdq

Number Manipulations 61
idiv DWORD PTR _n$[ebp]
add ecx, eax
;** x=10*a[n-l]+x/n **
mov DWORD PTR _x$[ebp], ecx
; Line 19
jmp SHORT $L538
$L539:
jmp $L534
$L535:
; Line 20
;** restore stack and exit **
mov esp, ebp
pop ebp
ret 0
_main ENDP
_TEXT ENDS
END
For example, for the G N U C + + compiler we use
g++ -S expl.cpp
to obtain the assembler code in the file expl. s in AT&T style.
Problem 6. 
Given a set of N non-negative integers (all the integers
are pairwise different). Let N be odd. Write a C++ program which uses
an array to represent the set. Implement algorithms to find the minimum,
maximum and median of the numbers. The median is the number such that
(N - l)/2 of the numbers are less than the median and the other (N —1)/2
numbers ar larger than the median. Also determine the position in the
array of the minimum, maximum and median. In each case determine the
number of comparisons needed to obtain the result. Consider for example
the set
{3,4,11,2,8,20,10}.
The minimum is 2, the maximum is 20 and the median is 8. The position
of the median is 4 if we number the positions from 0, from left to right.
Solution 6. 
To find the minimum and maximum, takes O(N) compar-
isons. To find the median takes O(N2) comparisons. For analysis of the
problem, see Knuth D. E., The Art of Computer Programming, Volume 3,
Sorting and Searching, Addison-Wesley, Reading Massachusetts 1981.
// medianl.cpp

62 
Problems and Solutions
#include <iostream>
using namespace std;
int min(int set[],int n)
{
int m = 0;
for(int i=l;i<n;i++)
if(set [i]<set[m]) m = i;
return m;
>
int max (int set[],int n)
{
int m = 0;
for(int i=l;i<n;i++)
if(set[i]>set[m]) m = i;
return m;
}
int med(int set[],int n)
{
int i = 0 , j =0, m=0;
int count = 0;
for(;(j<n)&&(count!=n/2);j++)
{
count =0; m = j ;
for(i=0;(i<n);i++)
if(set [i]>set[m]) count++;
}
return m;
}
int main(void)
{
int a[] = { 3, 4, 11, 2, 8, 20, 10 };
cout « "minimum " « a[min(a,7)]
« " at " « min(a,7) « endl;
cout << "maximum " << a[max(a,7)]
« " at " « max(a,7) « endl;
cout « "median " « a[med(a,7)]
« " at " « med(a,7) « endl;
return 0;
>

Number Manipulations 
63
Problem 7. The Taylor series expansion at x = 0 of (l + i) 1/ 4 for x2 < 1
is given by
Ni/4 
! 
! - 3 2 
1-3-7 
3 
1-3-7-11 
4
(l + a!)V4 = 1 + _ a ; _ _ a : a + _ _ _ a ; 3 _ _ _ _ _ a : 4 
+ . . . .
Determine the relation between consecutive terms in the series expansion.
Use the relation to implement the expansion recursively and iteratively up
to the 10th term in the sum. Determine the number of multiplications
performed using the formula given above explicitly and the number of mul-
tiplications when the relation is used. In each case, express the answer in
terms of n, the number of terms used in the expansion.
Solution 7. We have for the (n + l)-th term
l - 4 n
tn+i = , , . xtn
4 + 4n
where t\ = \x. For the explicit expansion, we add 3 multiplication opera-
tions for every term after ^x, thus we use 1 + 3(n — 2) multiplications for
the n-th term and a total of 3n(n + l)/2 — 5(n — 1) for n terms. When the
relation is used, we have three multiplications for every term after \x so
that the total is 1 + 2(n — 2) for n terms.
/ / expand.cpp
#include <iostream>
•include <cmath>
using namespace std;
double f_r(double x.int terms,double last=1.0,int p=l,int q=4)
{
if(terms<=0) return 0.0;
return last+f_r(x,terms-l,(last*x*p)/q,p-4,q+4);
}
double f_i(double x.int terms)
{
double last = 1.0, sum = 1.0;
int p = 1, q = 4;
for(int i=l;i<terms;i++)
{
last *= (x*p)/q;
sum += last;
p -= 4; q += 4;

64 Problems and Solutions
y
return sum;
}
int main(void)
•C
cout.precision(8);
cout « pow(1.5,0.25) « endl; 
// => 1.1066819
cout.precision(8);
cout « f_r(0.5,10) « endl; 
// => 1.1066898
cout.precision(8);
cout « f_i(0.5,10) « endl; 
// => 1.1066898
return 0;
}
Problem 8. 
A Diophantine equation is an equation where only integer
solutions are allowed. A linear Diophantine equation is an equation of the
form
ax + by = c
where a, b,c,x,y 
€ Z and x and y are the variables. If we can find the
integer solutions (x*,y*) of
ax* + by* — 1
then we can find solutions to the first equation using
a(cx*) + b(cy*) = c.
Let r\ = \a\ and r? = \b\. We apply the Euclidean algorithm-
n = qir2 + r3
T2 = 92^3 + U
rn-3 — qn-3rn-2 + rn_i
rn-2=qn-2rn-i 
+ 1.
From the last two equations we obtain
l = J"n-2 
-qn-2rn-i
= rn-2 - qn-2{rn-3 - qn-3rn-2)
= -qn-2rn-3 + (1 - qn-2Qn-3)rn-2
= x*ri +y*r2
= \a\x* + \b\y*.

Number Manipulations 65
In other words we use
en + dri+i = dr^i + (c - dqi-i)ri.
Thus, we obtain a recursion relation which we can use to find the solution.
To satisfy the equation, we use \x\ = \x*\, sgn(:c) = sgn(a), \y\ = \y*\ and
sgn(y) = sgn(6). For example, we consider the equation 1027x + 712y = 1.
First we apply the Euclidean algorithm
1027 = 712-1 + 315 Ui = 1
712 = 315-2 + 82 
q2 = 2
315 = 82 • 3 + 69 
q3 = 3
82 = 69 • 1 + 13 q4 = 1
69 = 13 • 5 + 4 
q5 = 5
13 = 4 • 3 + 1 [ q6 = 3
Now we apply the recursion relation
1 — re — 3r7
= -3r5 + (1 + 3 • 5)r6
= -3r5 + 16r6
= 16r4 + (-3 - 16 • l)r5
= 16r4 - 19r5
= -19r3 + (16 + 19 • 3)r4
= -19r3 + 73r4
= 73r2 + (-19-73-2)r 3
= 73r2 - 165r3
= -165ri + (73 + 165 • l)r2
= -165ri + 238r2.
Thus we obtain the solution x = —165 and y = 238.
Write a C++ program which solves linear Diophantine equations of the
form ax + by — 1.
Solution 8. 
The function solve_linear() solves linear diophantine
equation ax + by = 1 for x and y given a and b.
II diophantine.cpp
#include <iostream>
#include <vector>
using namespace std;

66 
Problems and Solutions
void solve_linear(int a, int b,int& x,int& y)
{
int t, larger;
int rl, r2, r3;
vector<int> q;
if(a == 0) return; if(b == 0) return;
larger = (b>a) ? 1:0;
rl = (a>0) ? a:-a;
r2 = (b>0) ? b:-b;
if(larger) { t = r2; r2 = rl; rl = t; }
do
{
r3 = rl°/.r2;
q.push_back(rl/r2) ;
rl = r2; r2 = r3;
}
while(r3 != 1);
x = 1; y = -q.backO ;
q.pop_back();
while(q.size() > 0)
{
t = x; x = y;
y = t - y*q.back();
q.pop_back();
}
x = (a > 0) ? x:-x;
y = (b > 0) ? y:-y;
if(larger) { t = x; x = y; y = t; >
}
int main(void)
{
int x, y;
solve_linear(1027,712,x,y);
cout « "1027*(" « x
« ") + 712*(" « y « ") = 1" « endl;
return 0;
}

Number Manipulations 67
Problem 9. 
Definition. We define the highest common divisor d of two
positive integers a and b as the largest positive integer which divides both
a and b. We write
d = (a, b).
Definition. The Euler totient function is defined on the set of positive
integers by /(I) = 1, f(m) for TO > 1 is the number of positive integers
less than m and relatively prime to m. In other words we denote by f(m)
the number of positive integers not greater than and relatively prime to m,
that is to say the number of integers n such that
0 < n < m 
(n, m) = 1.
The number n can be equal to m only when n = 1. Write a Java program
using the class Biglnteger to find f(m).
Definition. A function g{m) is said to be multiplicative if (m,m') = 1
implies
g(mm') = g(m)g(m').
Theorem. The Euler totient function f(m) is multiplicative, i.e.,
f(mm') = f(m)f(m').
Can this property be used in the program?
Solution 9. The Java class Biglnteger includes the method
Biglnteger gcd(BigInteger val)
for the greatest common divisor. Since Java does not provide operator
overloading the for loop in the program looks quite clumsy.
/ / Totient.java
import j ava.math.*;
public class Totient
{
public static void main(String[] args)
•C
Biglnteger n = new BiglntegerC'lO");
for(Biglnteger i = new Biglnteger("3");i.compareTo(n) <= 0;
i = i.add(Biglnteger.ONE))
i
Biglnteger z = new Biglnteger("1");

68 
Problems and Solutions
Biglnteger k = i;
k = k.subtract(Biglnteger.ONE);
for(Biglnteger j = new Biglnteger("2");j.compareTo(k) <= 0;
j = j.add(Biglnteger.ONE))
{
if((j.gcd(i)).equals(Biglnteger.ONE))
z = z.add(Biglnteger.ONE);
} // end for loop j
System.out.println("f(" + i + " ) = " + z);
} // end for loop i
>
>
A C++ program using the class Verylong from SymbolicC++ is shorter
since the operators +, -, ++ etc are overloaded.
Problem 10. 
Perfect numbers are those integers which are the sum of
their positive proper divisors. For example,
6 = 1 + 2 + 3
28 = 1 + 2 + 4 + 7 + 14
496 = 1 + 2 + 4 + 8 + 16 + 31 + 62 + 124 + 248.
Write a Java program using the data type long that finds larger perfect
numbers.
Solution 10. Larger perfect numbers are 8128, 33550336 and 8589869056.
/ / Perfect.Java
class Perfect
{
public static void main(String[] args)
{
long maxnumber = 100000000L;
long halfmax;
for(long pos=3L;pos <= maxnumber;pos++)
{
long half = pos/2L + 1L;
long sum = 0L;
for(long factor=lL;factor <= half;factor++)
{
if (posc/,factor == 0L) 
// divisible
{
sum += factor; 
// add factor

Number Manipulations 69
}
}
if(sum == pos)
{
System.out.println("" + pos + " is a perfect number");
System.out.print("Factors are: " ) ;
for(long f=lL;f < pos;f++)
{
if (pos'/.f == OL)
{
System.out.print(" " + f); 
/ / print factors
}
>
System, out .printlnO ;
>
>
}
>
We can also find perfect numbers from (2™ — 1) • 2™"1, where 2" — 1 is a
Mersenne prime.
Problem 11. (i) Consider the following arithmetic problem
ab*c
de
J^Jg
[ hi
where a,b,c,d,e, f,g,h,i 
stand for a nonzero digit, i.e., they are elements
of the set {1,2,3,4,5,6,7,8,9}, * denotes multiplication and + addition.
Each nonzero digit occurs only once in the problem. Is there a solution? If
so, is the solution unique?
(ii) Write a C++ program that finds a solution (if one exists).
Solution 11. (i) We find one solution
ab = 17 
c = 4 
de = 68 
fg = 25 
hi = 93
i.e.,
a = 1, b = 7, c = 4, d = 6, e = 8, f = 2, g = 5, h = 9, i = 3.
(ii) The C++ program runs through all permutations of the numbers 1,2,3,
4,5,6,7,8,9.

70 
Problems and Solutions
1/ arithproblem.cpp
#include <iostream>
using namespace std;
int main(void)
{
int i, j, k, t, tau;
unsigned long n = 9;
int* p = NULL; p = new int[n+1];
// starting permutation
// identity 1, 2, ... , n -> 1, 2, . . . , n
/ / which is not a solution of the problem
for(i=0; i <= n; i++)
{
p[i] = i;
}
int test = 1;
do
{
i = n-1;
while(p[i] > p[i+l]) i = i-1;
if(i > 0) test = 1; else test = 0;
j = n;
while(p[j] <= p[i]) j = j - 1 ;
t = p[i]; p[i] = p[j]; p[j] = t; i = i+1; j = n;
while(i < j)
{
t = p[i]; p[i] = p[j]; p[j] = t;
i = i+1; j = j - 1 ;
}
int ab = 10*p[l] + p[2] ; int de = 10*p[4] + p[5];
int fg = 10*p[6] + p[7]; int hj = 10*p[8] + p[9];
int c = p [3];
if((ab*c == de) && (de + fg == hj))
{
for(tau=l;tau <=n;tau++)
cout « "p[" « tau « "]=" « p[tau] « " ";
cout « endl;
}
} while(test == 1);
delete [] p;
return 0;
}

Number Manipulations 71
Problem 12. The puzzle to be solved is to map (1 to 1) each letter
(A.B.C.D.E.F.G.H.J.K)
in the following figure to a digit
(0,1,2,3,4,5,6,7,8,9)
such that the 3 horizontal and 3 vertical computations are correct.
EDKH I / I KF I = I AA~
+ = 
4-
EDB * 
J = EHCG
EEJD I - I DK I = I EEAE
Write a C++ program using brute force to solve the problem. Is there
a solution? Is the solution unique? How many permutations have to be
checked?
Solution 12. There are 10! = 3628800 permutations from which only one
ABCDEFGHJK = 5793146082
solves the puzzle. In the following C++ program the ten f or-loops in-
clude all possible permutation and finds this solution. Thus the number of
iterations is 1010. Can this redundancy in the program be removed?
// puzzle.cpp
#include <iostream>
using namespace std;
int main(void)
{
for(int i0=0;i0<10;i0++)
for(int il=0;il<10;il++)
for(int i2=0;i2<10;i2++)
for(int i3=0;i3<10;i3++)
for(int i4=0;i4<10;i4++)
for(int i5=0;i5<10;i5++)
for(int i6=0;i6<10;i6++)
for(int i7=0;i7<10;i7++)
for(int i8=0;i8<10;i8++)
for(int i9=0;i9<10;i9++)
{
int A = iO; int B = il; int C = i2; int D = i3;

72 Problems and Solutions
int E = i4; int F = i 5 ; int G = i6; int H = i7;
int J = i 8 ; int K = i 9 ;
int EDKH = 1000*E + 100*D + 10*K + H;
int KF = 10*K + F; int AA = 10*A + A;
int EDB = 100*E + 10*D + B;
int EHCG = 1000+E + 100*H + 10*C + G;
int EEJD = 1000*E + 100*E + 10*J + D;
int DK = 10*D + K;
int EEAE = 1000*E + 100*E + 10*A + E;
if(KF != 0)
{
if((EDKH/KF == AA) kk (EDKHV.KF == 0) &&
((EDKH-EDB) == EEJD) kk ((KF+J) == DK) kk
((AA+EHCG) == EEAE) kk ((EDB*J) == EHCG) &&
((EEJD-DK) == EEAE))
{
cout << "A solution is: " <<
iO « il « i2 « i3 « i4 « i5 « i6 « i7 « i8 « i9;
}
}
> / / end for
return 0;
}
Problem 13. Write a C++ program that finds the integer square root
of a positive integer. For example, 8 is the integer square root of 70, since
8 • 8 = 64 and 9 • 9 = 81.
Solution 13. Can the following C++ program be improved?
/ / intsqrt.cpp
#include <iostream>
using namespace std;
unsigned long int_sqrt(unsigned long n)
{
unsigned long nn = 0;
// counts digits in number
int digits = 0;
do { digits++; nn /= 10; >
while(nn != 0);

Number Manipulations 73
/ / estimate lower bound for root
int d_min = digits/2;
unsigned long root;
if (digits°/,2 == 0) { root = 3; d_min -= 1; }
else root = 1;
for(int i=0;i<d_min;i++) root *= 10;
/ / search for root
while(root*root < n) root++;
if(root*root != n) root—;
return root;
}
int main(void)
-C
unsigned long n;
cout « "Enter positive integer number: ";
cin » n;
unsigned long root = int_sqrt(n);
cout « "integer square root = " << root;
return 0;
>
Problem 14. For pseudo-random number generators one quite often uses
the map
Yt+i = {AYt + B) mod C
where t — 0,1,2,... and YQ is the initial value (seed). Here A is the number
of cycles, B is the phase (horizontal shift), C is the number of distinct
values. The sequence will repeat after at most C steps. Let
A = 1366, B = 150889, C = 714025 .
Give a Java implementation of this map. Use the data type long.
Solution 14.
// MyRandom.java
public class MyRandom
{
public static void main(String[] args)

74 Problems and Solutions
i
long A = 1366, B = 150889, C = 714025;
long Y0 = 15; / / seed
long R = 15;
long Yl;
long count = 0;
do
•C
Yl = (A*Y0 + B)*/.C;
Y0 = Yl;
System.out.println(YO);
count++;
> while(YO != R);
System.out.printlnC'Yl = " + Yl);
System.out.printIn("count = " + count);
}
}
Problem 15. Given a floating point number within the range [0,1]. Write
a C++ program that finds the binary representation of this number.
Solution 15. Any fraction x can be written as
x = ai -2"1 +a2 -2""2H
where a3; £ {0, 1 }. The character string
O.aia,2 
• . •
is then x in binary form. Since
2x = ai + a2 • 2~l + a3 • T2 H
one immediately has (x is decimal form) int(2x) = a\ and
frac(2x) = o2 • 2"1 + a3 • 2~2 + • • • .
It is obvious that these steps can be iterated to find a,j. What is the problem
with the following code for large n? For example, if we enter x = 0.4 and
n = 100. Discuss rounding errors.
/ / binfrac.cpp
#include <iostream>
#include <cmath>

Number Manipulations 75
using namespace std;
void binfrac(double x,int n)
{
for(int j=O;j<n;j++)
{
double fraction;
int integer;
x = 2.0*x;
fraction = fmod(x,1.0);
integer = x - fraction;
x = fraction;
cout << integer;
}
>
int main(void)
{
double x;
cout « "enter decimal fraction: "; cin >> x;
int n;
cout « "enter number of binary digits required: ";
cin » n;
cout << endl;
cout « "binary representation of " « x « " is 0.";
binfrac(x.n);
return 0;
}
Problem 16. 
An algorithm based on the public key encryption scheme
was introduced by Rivest, Shamir and Adleman. The public encryption
key is a pair (e, n). The private key is a pair (d,n), where e, d, and n are
positive integers. Each message m is represented as an integer between 0
and n — 1. A long message is broken into a series of smaller messages, each
of which can be represented as such an integer. The functions E and D are
denned as
E{rn) = me mod n = C
D{C) = Cd mod n.
The integer n is computed as the product of two large (100 digits or more)
randomly chosen prime numbers p and q with n = p • q. The integer d

76 
Problems and Solutions
is chosen to be a large, randomly chosen integer relatively prime to the
product (p — 1) • (q — 1). That is, d satisfies
greatest common divisor [d, (p — 1) • (q — 1)] = 1.
Finally, the integer e is computed from p, q, and d to be the multiplicative
inverse of d modulo (p — 1) • (q — 1). That is, e satisfies
e • d mod (p - 1) • (q — 1) = 1.
Although n is known, p and <? are not. This condition is due to the fact that
it is very difficult to factor n. Consequently, the integers d and e cannot
be easily guessed. Apply the algorithm to the numbers p = 5, q = 7 and
m = 3.
Solution 16. 
From p = 5 and q = 7 we find n = 35 and (p — 1) • (q — 1) =
24. Since 11 is relatively prime to 24, we can choose d = 11, and since
11-11 mod 24 = 121 mod 24 = 1
we have e = 11. Suppose now that m — 3. Then
C = me modn = 3 umod35 = 12
and
Cd mod n = 1211 mod 35 = 3 = m.
Thus, if we encode m using e, we can decode m using d.
Problem 17. 
Let No be the natural numbers including 0. A pairing func-
tion is a computable bijection from Ng to No which provides an effective
enumeration of pairs of integers. Provide such a map.
(0,0)7 (0,1)7 (0'2)? (0'3)? ^A)7 
'''
^\sy^±y^2)Xi.$)sQ£) 
• • •
^siy^Xl/Qzy>fo) 
(2,4) 
• • •
< ^ 0 ) / ( 3 ^ / ( 3 , 2 ) 
(3,3) 
(3,4) 
•••
< ^ 4 m / ( 4 , l ) 
(4,2) 
(4,3) 
(4,4) 
•••

Number Manipulations 77
Solution 17. The map given by
/(M')= 2 (* + •?)(*'+ -7' + 1) +*
for all i, j £ No is a computable one-to-one correspondence from NQ onto
No- We have
/(0,0)=0, 
/(0,l) = l, 
/(l,0) = 2, 
/(0,2) = 3, 
/ ( l , l ) = 4
etc. We obtain / by adaptation of Cantor's enumeration for rational num-
bers. Given f(i,j). 
How can we find i and j?
Problem 18. Multiplication of large positive integers can be done as
follows. Using the divide-and-conquer algorithm we split an n-digit integer
into two integers of approximately n/2 digits. For example
567832 = 567 • 103 + 832
9423723 = 9423 • 103 + 723 .
In general, if n is the number of digits in the integer u, we split the integer
into two integers, one with [n/2] digits and the other with [n/2\ digits, as
follows
u = x • 10m + y
where x has [n/2] digits and y has [n/2\ digits. With this representation,
the exponent m of 10 is given by
If we have two n-digit integers,
u = x-10m+y
v=w-Wm+z
their product is given by
uv={x-Wm 
+ y){wl0m 
+ z)
= xw • 102m + (xz + wy) • 10m + yz .
The method uses integers with about the same number of digits. However,
it can also be applied when this is not the case. We simply use m = [n/2J
to split both of them, where n is the number of digits in the larger integer.
Write a Java application that implements this algorithm to multiply to
positive integers of data type long.
Solution 18. 
The method noof digits() finds the number of digits in
the number m.

78 Problems and Solutions
1/ LargeMulti.java
public class LargeMulti
{
public static long product(long u.long v)
{
long x, y, w, z, p;
long t = 4; // threshold
long a = noofdigits(u);
long b = noofdigits(v);
long n = Math.max(a,b);
if((u == OL) II (v == OL)) { return 0; >
else
if(n <= t) { p = u*v; return p; >
else
{
long m = n/2L;
x = u/((long) Math.pow(10,m));
y = u7.((long) Math.pow(10,m)) ;
w = v/((long) Math.pow(10,m));
z = v*/,((long) Math.pow(10,m));
p = product(x,w)*((long) Math.pow(10,2*m))
+(product(x,z)+product(w,y))*((long) Math.pow(10,m))
+product(y,z);
return p;
}
>
public static long noofdigits(long m)
{
Long I = new Long(m);
String s = I.toStringO ;
long length = s.lengthQ;
return length;
}
public static void main(String[] args)
{
long u = 98123456L, v = 1012341234567L;
long nl = noofdigits(u);
long n2 = noofdigits(v);
System.out.println("resultl = " + nl);
System.out.println("result2 = " + n2);
long s = product(u,v);

Number Manipulations 79
System.out.println("s = " + s);
long t = u*v;
System.out .printlnC't = " + t) ;
}
}
Problem 19. Consider the bijective spiral map
/ : Z x Z -> No
displayed in the following figure. We have
/(0,0)=0, 
/(l,0) = l, 
/(1,1)=2, 
/(0,l)=3,
/(-1,1) = 4, /(-l,0) = 5, 
/(-1,-1) = 6, 
/ ( 0 , - l ) = 7 , . . .
Write a C++ program that given (m, n) € Z x Z finds f(m, n). Implement
also the inverse transformation.
(-1,2) 
(-1,2) 
(0,2) 
(1,2) 
(2,2)
"l6 
15 
14 
13 
U"
, . w r i 7 <-»•»_ 
^ 
('•" „,.(,.!,
4 
o 
Z
(-1,0)" 18 (-1,0)" 5 
^ 
l l ( l i 0 ) 
10,(2,0)
,j6 
J 
8 
9
(-1,-1) 
(0,-1) 
(1,-1) 
(2,-1)
Solution 19. The following program implements the spiral map and its
inverse. The spiral map is determined by following the spiral in reverse
until the point (0,0) is reached.
// spiralmap.cpp
#include <iostream>
using namespace std;
int main(void)

80 
Problems and Solutions
i
int mi, ni, m, n, count = 0;
int fl, 
f;
cout << "Enter m, n: "; cin » mi » ni;
m = mi; n = ni;
while((m!=0) | | (n!=0))
{
if((n>m) && (n>=-m)) 
++m;
else if((n>=m) && (n < -m)) 
++n;
else if((n<=m) && (n > -m+1)) —n;
else 
—m;
connt++;
}
cout « "f(" « mi « " , " « ni « ") = " « count « endl;
/ / inverse map
cout « "Enter the number: ";
cin » 
f;
fl = f;
m = n = 0;
if(f— != 0) m++;
while(f > 0)
{
if((n>=m) && (n>-m)) 
—m;
else if((n>m) && (n<=-m)) 
—n;
else if((n<m) && (n>=-m+l)) ++n;
else 
++m;
f—;
}
cout << endl;
cout « "f"-l(" « fl « ") = ("
« m « " , " « n « ")" « endl;
return 0;
}
Problem 20. The naive approach to multiplying two integers X and Y
represented as binary numbers is O(n2), where the integers have n bits. We
can write a faster multiplication algorithm if we split the integers in two,
X = A2n/2 + B
Y = C2n/2 + D.

Number Manipulations 81
The multiplication can now be written as
XY = ACT + {AD + BC)2n/2 + BD.
The number of multiplies, additions and shifts still take O(n) steps. If we
rewrite the multiplication as
XY = AC2n + [{A - B)(D -C) + AC + BD]2n/2 + BD,
then we replace the two multiplications AD, BC by one and we can reuse
the results AC and BD. This algorithm can be applied recursively resulting
in an algorithm that is O(n1-5). Write a C++ program to multiply two large
integers using the bitset class. Use a two's-complement representation for
the integers. If we represent a polynomial P in x as a list of the coefficients
of the terms in P, then the same technique can be applied to speed up
multiplication of polynomials. Instead of the shift operation 2" we have
multiplication by xn. This is known as the Karatsuba-Ofman algorithm.
Solution 20.
// fastmult.cpp
#include <iostream>
#include <bitset>
using namespace std;
template<size_t T> int sign(bitset<T> X)
{
if(X.test(T-l)) return -1;
else return 1;
}
template<size_t T> bitset<T> neg(bitset<T> X)
{
bitset<T> one(i);
for(int i=0;i<T;i++) { X.flip(i); >
X = X + one;
return X;
}
template<size_t T> bitset<T> abs(bitset<T> X)
{
if(sign(X) < 0) { return neg(X); }
else { return X; }
>

82 
Problems and Solutions
template<size_t T> double value(bitset<T> x)
{
int s = sign(x);
x = abs(x) ;
double val = 0.0;
for (int i=T-l;i>=0;i—)
{
val *= 2.0;
if(x[i]) { val += 1.0; }
}
if(s < 0) val = -val;
return val;
}
template<size_t T>
bitset<T> operator + (bitset<T> X,bitset<T> Y)
•C
int bit, carry = 0;
bitset<T> answer;
for(int i=0;i<T;i++)
{
bit = ((X.test(i))?l:O)+((Y.test(i))?l:O)+carry;
if(bit & 1) { answer.set(i); }
else { answer.reset(i); }
carry = bit » 1;
}
return answer;
}
template<size_t T>
bitset<T> operator - (bitset<T> X,bitset<T> Y)
{ return X + neg(Y); }
template<size_t T>
bitset<T> mult(bitset<T> X,bitset<T> Y.int n)
{
bitset<T> A, B, C, D, AC, BD, A_BD_C, answer;
int i;
int s = sign(X)*sign(Y);
X = abs(X); Y = abs(Y);
if(n--l)

Number Manipulations 83
{
if((X.test(0))&&(Y.test(0))) { answer.set(0); }
} else { A = X » (n/2); B = X;
for(i=T-l;i>=n/2;i—) B.reset(i);
C = Y » (n/2); D = Y;
for(i=T-l;i>=n/2;i—) D.reset(i);
AC = mult(A,C,n/2);
A_BD_C = mult(A-B.D-C,n/2);
BD = mult(B,D,n/2);
answer = ((AC«n) + ((AC+A_BD_C+BD)«(n/2)) + BD);
}
if(s < 0) answer = neg(answer);
return answer;
}
int main(void)
{
bitset<128> X(2000000000);
bitset<128> Y(300000000);
bitset<128> Z;
X = neg(X);
Z = mult(X,Y,128);
cout « value(X) « "*" « value(Y) « "="
« value(Z) « endl;
return 0;
}
Problem 21. The Zeckendorf representation (z2, z3,..., zn-\) G {0,1}"~2
of a non-negative integer z is given by
n-l
Z = 2_j 
ZiFi
i=2
where Fi = F2 = 1 and Fi+2 = Fi+i + Fi are the Fibonacci numbers , and
Fn is the smallest Fibonacci number such that Fn > z. The representa-
tion is obtained by repeatedly subtracting the largest Fibonacci number Fj
with z > Fj, and writing a 1 in this place (ZJ — 1). This representation
is unique for any given z. Furthermore, if Zj ^ 0 then zj+i = 0, i.e., the
representation can never have two consecutive Is. Suppose two consecutive
Is appear in the representation, say at position k and k + 1, then from
Ffe+2 = Fk+i + Fk, Ffz+i could not have been the largest Fibonacci smaller
than z, and consequently two consecutive Is cannot appear in the represen-
tation. For example, we find the Zeckendorf representation of 19 is 100101

84 
Problems and Solutions
where the first digit is z2, the second z3 etc. The first Fibonacci number
which is greater than 19 is 21.
~TjFj 
I Z\ZJ
8 
21 
19
7 
13 
19 
1
6 
8 
6 
0
5 
5 
6 
1
4 
3 
1 0
3 
2 
1 0
2 | 1 I 1 | 1
The Zeckendorf representation leads to Zeckendorf arithmetic, i.e., the
arithmetic based on the Zeckendorf representation of numbers. To add
two numbers x and y in the Zeckendorf representation
71— 1 
71— 1
3=2 
j=2
we use (x + y)j = Xj + yj whenever Xj + yj < 2. However, for Xj = yj = 1
we have to use the following property of the Fibonacci numbers
f 
F3 
3 = 2
2Fj = 1 
F2 + F4 
j = 3 
.
[ Fj-2 + Fj+i 
otherwise
This follows from the fact that
Fj + Fj = F3 + (Fj+1 - Fj.t) = Fj + (Fj+1 - (Fj - i^_2))
for j > 3. After addition, the result must be normalized to ensure that
no consecutive Is appear for a valid Zeckendorf representation. Thus, it
is necessary to replace 110 with 001. If the replacement is done from the
right side of the representation we can ensure that a zero always follows the
rightmost pair of Is. Consequently we have the following algorithm to add
two Zeckendorf representations x and y
add(z, y)
1. Define sum such that surrij = Xj 0 yj (i.e. surrij = Xj + yj mod 2).
Define b such that bj = Xj • yj.
2. Set sum := normalize(sum).
3. For j = 
2,3,...
If j = 2setc:= 01, 
if j = 3 set c := 101, 
if j = 4 set c := 1001.
If j > 4 set c := Oc.
If bj = 1 then sum := add(swm, c).

Number Manipulations 
85
4. The result is stored in sum.
For multiplication we can use a technique similar to the russian farmer
multiplication. We use the property that F\x = F%x = x and
Fj+2x = (Fj+l + Fj)x = (Fj+1x) + 
(FJX).
multiply(a;, y)
1. Set a\ := y.
Set a2:=y.
Set sum := 0.
2. For j = 2, 3,...
If Xj = 1 then sum := a,dd(sum,a2).
Set aO := al and al := a2.
Set a2 := add(aO,al).
3. The result is stored in sum.
Give a C++ implementation of the Zeckendorf arithmetic.
Solution 21. The C++ program implements the Zeckendorf arithmetic.
The function itozO converts an integer to the Zeckendorf representation
while ztoiO converts the Zeckendorf representation back to an integer.
The function znormalize (vector<bool>& b) will normalize b for the Zeck-
endorf representation. The two functions zadd() and zmulO perform ad-
dition and multiplication in the Zeckendorf representation, respectively.
/ / zeckendorf.cpp
#include <iostream>
#include <iomanip>
#include <vector>
using namespace std;
/ / overloaded operator to output vector<bool> for the
/ / Zeckendorf representation
ostreamfe operator « (ostreamfe o,const vector<bool>& b)
{ for(int i=0;i<b.size();i++) o « b[i]; return o; >
/ / Zeckendorf representation to integer
int ztoi(const vector<bool>& b)
•C
int fO, fl = 1, f2 = 2, i, z = 0;
for(i=0;i<b.size();i++)

86 Problems and Solutions
{.
if(b[i]) z += fl;
fO = fl; fl = f2; f2 = fl + fO;
}
return z;
}
// integer to Zeckendorf representation
vector<bool> itoz(int z)
{
int fO = 1, fl = 1, f2 = 2;
vector<bool> b;
while(z >= f2) { fO = fl; fl = f2; f2 = fl + fO; }
while(fl != f2)
{
if(z >= fl) { z -= fl; b.insert(b.begin(),l,l); }
else 
b.insert(b.beginO,1,0);
fO = f2 - fl; f2 = fl; fl = fO;
}
return b;
}
// normalize a vector<bool> for the Zeckendorf representation
// i.e. remove all consecutive l's
void znormalize(vector<bool>& b)
{
for(int i=b.size()-l; i>=l; i—)
{
if((b[i] == 1) && (b[i-l] == 1))
{
b[i] = b[i-l] = 0;
if(i == b.size()-l) b.push_back(l); else b[i+l] = 1;
if(i+3 >= b.sizeO) i = b.size(); else i += 3;
>
>
if(b.size() == 0) b.push_back(0);
}
// addition for Zeckendorf representations
vector<bool> zadd(const vector<bool>& x,const vector<bool>& y)
{
int i;
bool bl, b2;
vector<bool> sum, c2(2), c3(3), c4(4);

Number Manipulations 
87
c2[0] = 0; c2[l] = 1;
c3[0] = 1; c3[l] = 0; c3[2] = 1;
c4[0] = 1 ; c4[l] = 0 ; c4[2] = 0 ; c4[3] = 1 ;
for(i=0;(i<x.size()) 
|| 
(i<y.size());i++)
•c
if (Kx.sizeO) bl = x[i] ; else bl = 0;
if (Ky.sizeO) b2 = y[i] ; else b2 = 0;
if(bl " b2) sum.push_back(l); else sum.push_back(0);
}
znormalize(sum);
for(i=0; (i<x.size()) && (i<y.sizeO) ;i++)
{
if(x[i] & y[i])
{
if(i==0) 
sum = zadd(sum,c2); // 2*F_2
else if(i==l) sum = zadd(sum,c3); // 2*F_3
else 
sum = zadd(sum,c4); // 2*F_j, j>3
}
if(i>l) c4.insert(c4.begin(),1,0);
}
return sum;
}
// multiplication for Zeckendorf representations
vector<bool> zmul(const vector<bool>& x,const vector<bool>& y)
{
vector<bool> aO, al(y), a2(y), sum;
for(int i=0;i<x.size();i++)
{
if(x[i] == 1) sum = zadd(sum,a2);
aO = al; al = a2; a2 = zadd(a0,al);
>
return sum;
>
int main(void)
i
int i, j;
cout << "integer -> Zeckendorf : " « endl;
for(i=0;i<22;i++) cout « i « " -> " << itoz(i) «endl;
cout « endl;
cout << "Zeckendorf addition : " << endl;
for(i=0;i<22;i++)
{

88 Problems and Solutions
for(j=0;j<22;j++)
cout « setw(2) « ztoi(zadd(itoz(i),itoz(j))) « " ";
cout << endl;
}
cout << endl;
cout « "Zeckendorf multiplication : " « endl;
for(i=0;i<ll;i++)
{
for(j=0;j<ll;j++)
cout « setw(2) « ztoi(zmul(itoz(i),itoz(j))) « " ";
cout << endl;
}
cout << endl;
return 0;
}
Problem 22. 
Determine the coefficient of XiX^x^x^ in the polynomial
(Xi + X2 + X3 + X4 + 
X5)10.
Solution 22. 
To multiply the term (xi + x^ + £3 + £4 + £5) ten times
with itself and then collect the terms would be quite cumbersome. Using the
multinomial theorem , the coefficient of X\x\x/±x\ in (X1+X2+X3+X4+X5)10
is given by
10!
l!3!0!T!5!=5040-

Chapter 4
Combinatorical Problems
Problem 1. Let A and B be finite sets. Let \A\ and \B\ be the cardinality
(i.e., the number of elements in the set) of A and B, respectively. Let
f:A->B.
What is the number of possible functions /?
Solution 1. The number of possible functions is
\B\W.
If \B\ = 2 we have 2|j41. For example, if \A\ = \B\ = 2, we have four
functions, namely Ji(0) = 0, ^(1) = 0, /2(0) = 0, /2(l) = 1, /3(0) = 1,
/3(0) = 0, and /4(0) = 1, /4(1) = 1.
Problem 2. Given a set of seven elements
{xi, x2, x3, x4, x5, x6, x7} .
Is it possible to find 7 subsets each having each k = 3 elements and such
that any two of these subsets have A = 1 element in common?
Solution 2. We apply binary matrices whose entries are restricted to the
set {0, 1}. The first row of the 7 x 7 matrix is
(1110000)
89

90 Problems and Solutions
which refers to the set {xi, 12, £3 }• Taking into account the conditions
the next row is
(1001100)
which refers to the set { x\, X4, x5 }. Obviously the next row is
(1000011)
with corresponds to the set {xi, x&, x-j }. Next we have
(0101010)
with the set {X2, X4, xe }• Proceeding on we find the rows
(0100101) «• {x2, xh, x7}
(0011001) «• {x3, x4, x7}
(0010110) O {x3, x5, x 6}.
Thus we obtain the binary matrix
/ I 
1 1 0 0 0 0\
1 0 
0 1 1 0 
0
1 0 
0 0 0 
1 1
B = 
0 1 0 1 0 1 0
0 1 0 
0 1 0 
1
0 0 1 1 0 
0 1
\ 0 
0 1 0 1 1 0/
and consequently the problem admits a solution.
Problem 3. Let A be a finite set. Then the number of distinct elements
of A is called the cardinality and is denoted by |i4| or card(^4). For any
finite set A, \2A\ = 2'i4'; that is the cardinality of the power set of A is 2
raised to a power equal to the cardinality of A. The power set of A is the
set of all subsets of A including the empty set and the set itself. Prove this
statement by induction on the cardinality of A.
Solution 3. 
The basis step is: let A be a set of cardinality n = 0.
Then A = 0, and 2^ = 2° = 1. On the other hand, 2A = {0}, and
|2*| = |{0}| = 1.
The induction hypothesis: let n > 0, and suppose that 12^1 = 2^' provided
that |^| < n.
Induction step: let A be such that |^4| = n + 1. Since n > 0, the set A
contains at least one element a. Let B = A\{a}; 
then \B\ = n. By the
induction hypothesis, \2B\ = 2'5' = 2™. Now the power set of A can be

Combinatorical Problems 91
divided into two parts, those sets containing the element a and those sets
not containing a. The later part is just the set 2 s, and the former part is
obtained by introducing a into each member of the set 2B. Thus
2A = 2BU{Cu{a} 
: C £ 2B } .
This division in fact partitions 2A into two disjoint equinumerous parts, so
the cardinality of the whole is twice 2'BI, which, by the induction hypoth-
esis, is 2 • 2™ = 2™+1, as was to be shown.
Problem 4. 
(i) Given a 3 x 3 two-dimensional array (matrix). Arrange
the numbers
1 2 3 4 5 6 7 8 9
so that all lines (rows and columns) including the diagonals add up to the
same total. This is known as a magic square.
(ii) Write a C++ program that uses the brute force method by checking
all possible permutations of the numbers, i.e., we have
9! = l-2-3-4-5-6-7-8-9 = 362880.
Solution 4. (i) We find eight solutions
2 7 6 
2 9 4 
4 3 8 4 9 2
9 5 1 
7 5 3 
9 5 1 
3 5 7
4 3 8 
6 1 8 
2 7 6 
8 1 6
6 1 8 
6 7 2 
8 1 6 
8 3 4
7 5 3 
1 5 9 
3 5 7 
1 5 9
2 9 4 
8 3 4 
4 9 2 6 7 2
Obviously, four of the solutions are the transpose of the matrix of the other
four.
(ii) The function factorial() finds the factorial of the number i. The
function testO checks whether the rows, columns and diagonals add up
the same number. The C++ implementation is given by
// teaser.cpp
#include <iostream>
#include <iomanip>
using namespace std;
const int N = 3;

92 
Problems and Solutions
const int N2 = 9;
double factorial(int i)
{
double f = i;
while (i > 1) f *= (—i);
return f;
}
int test(int array[N][N] )
{
int sum, sumcol, sumrow, sumdiagl, sumdiag2;
int i, j;
for(i=sum=0;i<N;i++)
sum += array[0][i];
sumdiagl = sumdiag2 = 0;
for(i=0;i<N;i++)
{
sumcol = sumrow = 0;
for(j=0;j<N;j++)
{
sumrow += array[i][j] ;
sumcol += array[j][i];
}
if(sumrow != sum) return 0;
if(sumcol != sum) return 0;
sumdiagl += array[i][i];
sumdiag2 += array[i][N-l-i];
}
if(sumdiagl != sum) return 0;
if(sumdiag2 != sum) return 0;
return 1;
} // end test
void print(int array[N][N],int width)
{
for(int i=0;i<N;i++)
{
for(int j=O;j<N;j++)
cout « setw (width) « array[i][j];
cout « endl;
>
cout « endl;
} // end print

Combinatorical Problems 
93
void generate(int numbers[N],int width)
{
static double done = 0;
static double total = factorial(N2);
static int solutions = 0;
static int used[N2];
static int array[N][N];
static int d = 0;
if (d == 0)
for(int j=0;j<N2;j++) used[j] = 0;
if((d == N2) && (test(array)))
i
cerr « endl « (++solutions) « " solutions found" « endl;
print(array,width);
}
if(d == N2)
{
cerr « (++done)/total « " 
\r";
return;
}
for(int i=0;i<N2;i++)
{
if(!used[i])
•C
array[d/N][d%N] = numbers[i];
d++;
used[i] = 1;
generate(numbers,width);
used[i] = 0;
d—;
}
>
} // end generate
int main(void)
{
int numbers[N2] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
generate(numbers,N);
return 0;
>

94 
Problems and Solutions
Problem 5. Given a finite set with n elements the number of subsets is
given by 2n which includes the set itself and the empty set. Write a Java
program that finds all subsets of a finite set of strings.
Solution 5. We use recursion.
/ / Subsets.java
public class Subsets
•C
String[] set = null;
int setLength = 0, increment = 0;
public Subsets(String[] set)
{
this.set = set;
setLength = set.length;
// empty set
System.out .printlnC" + increment + ":\t");
increment++;
// starting for all positions in set
for (int i=O;i<setLength;i++) { subSetC" ,set ,i); }
} // end constructor
public void subSet(String preString,String[] set,int pos)
{
String newString = "" + preString + " " + set[pos];
System.out.printlnC" + increment + ":\t" + newString);
increment++;
for(int i=pos+l;i<setLength;i++) { subSet(newString,set,i); }
} // end Subsets(String[] set)
public static void main(String[] args)
{
String[] mySet = { "X", "Y", "Z", "A" >;
Subsets set = new Subsets(mySet);
}
}
Problem 6. 
Assume that N people (counting 1,2, ...,N) have decided
to elect a leader by arranging themselves in a circle and eliminating every

Combinatorical Problems 95
Mth person around the circle, closing ranks as a person drops out. Write
a Java program using a circular linked list that finds the remaining person
given N and M. The identity of the elected leader is a function of N and
M. This function is called the Josephus function.
Solution 6. 
For example, if we have N = 9 and M = 5 the people are
eliminated in the order
5 1 7 
4 3 6 9 2
and 8 is the leader chosen.
/ / Josephus.Java
class Josephus
{
static class Node
{
int val;
Node next;
Node(int v) { val = v; }
}
public static void main(String[] args)
{
int N = Integer.parselnt(args[0]);
int M = Integer.parselnt(args[1]);
Node t = new Node(l);
Node x = t;
for(int i=2;i<=N;i++)
{
x = (x.next = new Node(i));
>
x.next = t;
while(x != x.next)
•C
for(int i=l;i<M;i++) { x = x.next; >
x.next = x.next.next;
}
System.out.printlnC'survivor is: " + x.val);
>
>
Problem 7. A person starting at (0,0) moves on a rectangular grid. At
each grid point (m, n) m, n e Z (Z denotes the set of all integers) he/she

96 Problems and Solutions
can move to the right (r), to the left (I), up (u) or down (d) one step. The
person notes his path, for example,
rullddrrruuullll.
Given this string write a C++ program that finds the position (m, n) e
Z x Z of the person.
Solution 7. We use the string class of C++. We count the number of
r's, Vs, u's and cfs in the string to find the position.
/ / position.cpp
#include <iostream>
#include <string>
using namespace std;
void position(string s,int& m,int& n)
{
m = n = 0;
for(int i=0;i<s.length();i++)
{
switch(s[i])
{
case 'r': m++; break;
case 'u': n++; break;
case '1': m—; break;
case 'd': n—; break;
}
} // end for
}
int main(void)
{
int m, n;
position("rullddrrruuullll",m,n);
cout « "(" « m « "," « n « 
" ) " « endl;
positionC'lluurrrrddll",m,n);
cout « "(" « m « "," « n « 
" ) " « endl;
positionC" ,m,n) ;
cout « "(" « m « "," « n « 
" ) " « endl;
return 0;
}

Combinatorical Problems 97
Problem 8. Let
a0, 
a\, 
. . . , an-i, 
b0, b\, . . . , 6 m _ i
be two strictly increasing sequences of integers. Write a C++ program that
finds the number of integers common to both sets; that is, the cardinality
of the set
{a0, a\, ..., an-i } D {60, 61, ..., 6m_i }
where D denotes the intersection of the two sets.
Solution 8. 
We use a do-while loop to solve the problem. Obviously
the output is count = 3.
/ / cardinality.cpp
#include <iostream>
using namespace std;
int main(void)
{
int a[] = { 2, 3, 5, 9 >;
int n = 4;
int b[] = { 3, 4, 5, 8, 9, 10 };
int m = 6;
int i = 0, j = 0 ;
int count = 0;
do
{
if(a[i] == b[j]) { i++; j++; count++; }
else
{ if(a[i] < b[j]) i++; if(a[i] > b[j]) j++; >
>
while((i < n) && (j < m));
cout « "count = " « count;
return 0;
}
Problem 9. Let n be a positive integer. Let /(n) be the number of ways
in which one can cover a 3-by-n rectangle ABCD with dominoes (rectangles
with side length 1 and 2). If n is odd we find f(n) = 0 and if n is even we
find
f(2n) = ^=((V5 + 1)(2 + v^)" + (V5 - 1)(2 - v/3)n). 
(1)

98 Problems and Solutions
(i) Could a C++ implementation of (1) lead to rounding error?
(ii) Derive a recurrence relation. Implement the recurrence in the C++
program.
Solution 9. (i) The C++ implementation is given by
/ / dominoes.cpp
#include <iostream>
#include <cmath>
using namespace std;
unsigned long f(unsigned long n)
{
if(n'/.2) return 0;
if(n == 2) return 3;
if(n == 4) return 11;
return 4*f(n-2) - f(n-4);
>
int main(void)
•C
double t = sqrt(3.0);
int m = 3;
double n.ways = ((t+l)*pow(t+2,m) + (t-l)*pow(2-t,m))/(2*t);
cout « "n_ways = " << n_ways << endl;
for(unsigned long k=l;k<=10;k++)
{
cout « "f(" « k « ") = " « f(k) « endl;
}
return 0;
}
It does not lead to rounding errors,
(ii) The linear recurrence is given by
/(2n + 2) = 4/(2n) - f(2n - 2)
where n = 1,2,... and the "initial values" /(2) = 3 and /(4) = 11. The
solution of this recurrence with the initial values yields (1).
Problem 10. The number of ways of selecting k objects from n distinct
objects is given by
\k) '~ k\(n-k)\ '

Combinatorical Problems 99
We have
CD-CO-
Using this base case, and the relation
fn\ 
(n - 1\ 
(n- 
1\
UK k H-i)
implement a recursive function to calculate (™). Use a C++ template func-
tion, applying the function using the basic data type unsigned long and
the abstract data type Verylong of SymbolicC++. Alternatively, apply the
function using the data types long and Biglnteger in Java. Also give an
iterative implementation. Compare the execution times (time complexity)
of the two implementations. Explain any differences in the execution times.
Solution 10. 
The recursive method uses only addition which is faster
than the multiplication which is used by the iterative method. On the
other hand, the recursive method uses substantially more additions than
the multiplications of the iterative method as well as function calls which
have relatively high overhead. Thus, the recursive method is simpler but
slower.
/ / comb.cpp
#include <iostream>
#include <ctime>
#include "Verylong.h"
using namespace std;
template <class T> T comb_r(T n,T k)
{
if(k==T(0)||k==n) return T(l);
return comb_r(n-T(l),k)+comb_r(n-T(l),k-T(l));
}
template <class T> T fact(T n)
{
T f(l);
if(n<=T(0)) return T(l);
for(T i(l);i<=n;i++) f *= i;
return f;
>
template <class T> T comb_i(T n,T k)

100 Problems and Solutions
{ return fact(n)/(fact(k)*fact(n-k)); }
int main(void)
{
time_t start;
start = time(NULL);
cout « "comb_r(30,7) = " « comb_r(30,7);
cout « " - time " « time(NULL)-start « "s" « endl;
start = time(NULL);
cout « "Verylong comb_r(30,7) = "
« comb_r(Verylong(30).Verylong(7));
cout « " - time " « time(NULL)-start « "s" « endl;
return 0;
}
A typical output is
comb_r(30,7) = 2035800 - time 0s
Verylong comb_r(30,7) = 2035800 - time 22s
Problem 11. The compositional complexity K for nucleic acid sequences
and protein sequences of length L is given by
where N is 4 for nucleic acid sequences and 20 for protein sequences, and
Uj are the numbers of each residue in the sequence. K will vary from 0 for
very low complexity to 1 for high complexity.
(i) Find K for the nucleic acid sequence GGGG.
(ii) Find K for the nucleic acid sequence CTGA.
(iii) Given a nucleic acid sequence write a Java program that finds K.
Solution 11. 
(i) We have N = 4, L = 4 and no = 4, nc = 0, nr = 0,
nA = 0. Thus
IJrij! = 4-3-2-l-0!-0!-0! = 24.
allj
Therefore
*-M£)-°-
(ii) For the sequence CTGA we have N = 4, L = 4, and no = 1, nc = 1,
TIT = 1, TIA — 1. Thus
JJnj-! = l!-l!-l!-l! = l.
allj

Combinatorical Problems 101
Therefore
K = 5
log4(f)
=0-
573-
(iii) The following Java program calculates K for N = 4. The method
byte[] getBytesO in the class String converts this String into bytes
according to the platforms default character encoding, storing the result
into a new byte array.
/ / Complexity.Java
import j ava.lang.*;
public class Complexity
{
public static double K(String s)
•C
int i, j , L, N = 4;
double k = 1.0;
int [] n = new int [N] ;
L = s.lengthO; 
/ / length of string
for(i=n[0]=0;i<L;i++) if(s.getBytesO[i] == 'G') n[0]++;
for(i=n[l]=0;i<L;i++) if (s.getBytesO [i] == ' O 
n[l]++;
for(i=n[2]=0;i<L;i++) if(s.getBytesO[i] == 'T') n[2]++;
for(i=n[3]=0;i<L;i++) if (s.getBytesO [i] == 'A') n[3]++;
for(i=2;i<=L;i++) k *= i;
for(i=0;i<N;i++)
for(j=2;j<=n[i];j++) k /= j ;
k = Math.log(k)/Math.log(N);
k /= L;
return k;
}
public static void main(String argv[])
{
System.out.print("Complexity of GGGG K=");
System.out.println(KC'GGGG"));
System.out.print("Complexity of CTGA K=");
Syst em.out.printIn(K("CTGA"));
}
}
Problem 12. 
An ancestral binary tree has one original ancestor (root)
and each person (node) in the tree has 0 or two offspring (a first and

102 Problems and Solutions
second child denoted by the left and right branch, respectively). Find a
recurrence relation and associated generating function for the number of
different ancestral trees with n people.
Solution 12. Any valid binary tree has an odd number of nodes. Let cn
be the number of binary trees with In + 1 nodes. The first few terms are
c0 = 1, C\ = 1, c2 = 2, c3 = 5, c\ = 14. We obtain a recurrence relation for
cn by partitioning the trees according to the number of nodes on their left
and right branches from the root node. If there are 2j +1 nodes on the left
and 2k + 1 nodes on the right, then the total number of such arrangements
is CjCk since we can attach any valid binary tree to each child of the root.
Thus
n-l
cn = y ^ CjCn-j-i.
Let C{x) = Y^LQ cnxTl De t n e generating function. Then
/n-l 
\
C2(X) =C% + (ciCo + CQC^X + • • • + \^2 
CJCn-j-l 
z" : + ' " ' •
V=o 
/
Using the recurrence, we have xC2{x) = C(x) - c0 — C(x) -1. Solving this
quadratic equation and taking into account that the coefficients of C(x) are
non-negative we find
C ( X ) = 
2x 
•
Using the expansion
(l-4x)^ = l-if 
if^-V
^nU-1/
n = l 
v 
'
we arrive at
ow = f;-LCy.

Chapter 5
Matrix Calculus
Problem 1. Everyone knows that multiplying two arbitrary n x n ma-
trices requires n3 multiplications, at least if we do it using the standard
formula. Let A and B be 2 x 2 matrices. Then C = AB is given by
en =an&n +ai2&2i
C12 = a u t i 2 + O12622
C21 =021^11 +022^21
C22 = ^21^12 + ^22^22
which gives 8 multiplications and 4 additions. Strassen discovered a sur-
prising base algorithm to compute the product of 2 x 2 matrices with only
seven multiplications. Find out how the number of multiplications for 2 x 2
matrices can be reduced to 7.
Solution 1. We have the seven products
Pi = (ffll2 - <*22)(&21 + ^22)
P2 = ( a n + 022X611 + 622)
P3 = (an - a2i)(bn + b12)
Pi — ( a n + 012)^22
Pb = «n(612 - 622)
P6 =022(621 - 6n)
Vi = (021 + 022)611 •
103

104 Problems and Solutions
We obtain the entries of the product matrix C by forming the sums
c\\ - aii&n + ai2&2i = P\ + P2 ~ Pi + 
Pe
Cl2 = ail&12 + ^12^22 = P4+ 
P5
C21 = 021^11 + 022^21 = P6+P7
C22 = O.2lbi2 + a22b22 = P2 ~ P3 + P5 ~ P7 •
This result is of no practical importance for matrices of real or complex
numbers because calculations are usually carried out by computers multi-
plying almost as fast as adding. Therefore, it makes no sense to replace 8
multiplications and 4 additions by 7 multiplications and 18 additions.
Problem 2. The Strassen's algorithm described in problem 1 can be re-
cursively extended to larger matrices via a Kronecker product construction.
The construction is very simple: large matrices are broken down recursively
by partitioning the matrices into quarts, sixteenths, etc. Apply Strassen's
algorithm to the matrices
(
1 2 3 4\ 
/8 9 1 2\
5 6 7 8 ) 
1 3 4 5 6 1
9 1 2 3 
' 
7 8 9 1 I •
4 5 6 7/ 
\2 
3 4 5/
Solution 2. We have the submatrices
An = (l I), A12=(* 
g ) , 
A 2 1 = ( 2 l^, ^ 2 2 = ( g ^
B u =
{ l 
4 ) '
 
Bl2
={5
 
I)'
 
B21={1 
3 ) '
 
B22={1 
5) •
Then
Pl = (Al2-A22)(B21+B22)=(ll 
J7)
P2 = (^ 1+ J422)(B 1 1+5 22)=( 2
8
7
6
8 
/2
5
7)
P3 = (A11-A21)(Bu + B12)=(~™ 
"21)
n 
, A 
, A 
^ r. 
/ 60 
34 \
P^(An+A12)B22=^164 
g 2j
P5 = An(B12-B22)=(j3
6
4 
^

Matrix Calculus 105
P6-A22(B2i-Bii)=(_"13 _~g)
Pr = (A21 + A*)Bn = {m 1 3 8J.
Thus
r - P + P ( 95 110^
C22 = P 2 - P 3 + P 5 - P 7 = (1
4
1
4
1
 4
7J).
Problem 3. Given a sequence r(0), r(l),..., 
r{p). Using this sequence
we can form the p x p matrix
/ r(0) 
r(l) 
r(2) 
... r ( p - l ) \
r(l) 
r(0) 
r(l) 
... r(p - 2)
^ ^ 
r(2) 
r(l) 
r(0) 
... r(p - 3) 
.
\ r ( p - l ) 
r(p-2) 
r(jD-3) ... 
r(0) /
The matrix is symmetric and all the elements along the diagonal are equal.
We assume that r(0) / 0 and R is invertible. Let
(
ai\ 
/
r
(!)\
? L * - ? •
aP / 
\ r(p) /
Then the linear equation RA = P can be solved using Durbin's algorithm
which is a recursive procedure. The algorithm is as follows:
E(0):=r(0), 
kx = r(l)/£(0)
1 I" i-1 
1
ki"='W-—ri 
r ( i ) - H a j ( { - 1 ) r ( i - i ) 
. i = 2,3,...,p
aj(i) = ^ i , 
i = 1,2, . . . , p
ai(*)=aJ-(»-l)-A:,-olW(*-l), 
{^^"••' P
^ j — i, z , . . . ,i — i
E(i) = (l-k$)E(i-l), 
i = l , 2 , . . . , p .

106 
Problems and Solutions
After solving these equations recursively, the solution of the linear equation
is given by
aj=aj(p)1 
j = 
1,2,...,p.
Write a C++ program that implements this algorithm. Test your program
with the sequence
r(0) = l, r(l)=0.5, 
r(2)=0.2.
This problem plays a role in linear predictive coding.
Solution 3.
/ / durbin.cpp
#include <iostream>
using namespace std;
double E(int,double*);
double k(int.double*);
double a(int,int,double *);
double E(int i,double* r)
•C
if(i==0) return r[0];
double ki = k(i,r);
return (l-ki*ki)*E(i-l,r);
}
double k(int i,double* r)
•C
double ki = r [i];
for(int j=l;j<i;j++)
ki -= a(j,i-l,r)*r[i-j];
ki /= E(i-l,r);
return ki;
>
double a(int j,int i,double* r)
•C
i f ( i = = j ) 
r e t u r n 
k ( i , r ) ;
return a(j,i-l,r)-k(i,r)*a(i-j,i-l,r);
>
int main(void)

Matrix Calculus 107
{
int p = 2;
double *r = new double[p+1];
r[0]=1.0; r[l]=0.5; r[2]=0.2;
for(int i=l;i<=p;i++)
cout« "a(" « i « ") = " « a(i,p,r) « endl;
delete [] r;
return 0;
}
The output is
a(l) = 0.533333
a(2) = -0.0666667
Problem 4. 
Give the matrices to perform any one of the following oper-
ations
• Rotation around the z-axis
• Scaling
• Shearing of the x by the z-coordinate
• Translation
in any order using only matrix multiplications. Use the homogeneous form
of a point: (x, y, z, 1)T and 4 x 4 matrices to solve the problem.
Solution 4. 
The rotation matrix for rotation around the 2-axis by an
angle 6 is given by
(
cos6> 
-sinfl 
0 0\
sin6» 
cos6> 
0 0 |
0 
0 
1
0
-
0 
0 
0 
1/
Similar matrices are available for the other axes.
Scaling is achieved by
(
Sx 
0 
0 
0\
0 
Sy 
0 0 I
o 
o sz 
o I •
0 
0 
0 
1/

108 Problems and Solutions
Shearing the ^-coordinate by the z-coordinate is given by
(
1 0 s 
0\
0 1 0 0
0 0 1 0 I •
0 0 0 1/
Finally translation is represented by
(
1 0 0 
Tx\
0 1 0 
Ty\
0 0 1 Tz I '
0 0 0 
1 /
Now any sequence of operations can be combined by multiplying the cor-
responding matrices together. This matrix can then be applied to a point
to transform the point.
Problem 5. Let A be an arbitrary mxn matrix over R, i.e., A £ R m x n.
Then A can be written as
A = UY,VT
where U is an m x m orthogonal matrix, V is an n x n orthogonal matrix,
S is an m x n diagonal matrix with nonnegative entries and T denotes the
transpose. This is called the singular value decomposition. An algorithm
to find the singular value decomposition is given as follows.
1) Find the eigenvalues A^ (j = 1,2,..., n) of the n x n matrix ATA. Ar-
range the eigenvalues Ai, A2, ..., An in descending order.
2) Find the number of nonzero eigenvalues of the matrix ATA. We call this
number r.
3) Find then orthonormal eigenvectors Vj (j = 1,2,... ,n) of the matrix
ATA corresponding to the obtained eigenvalues, and arrange them in the
same order to form the column-vectors of the n x n matrix V.
4) Form an m x n diagonal matrix E placing on the leading diagonal of it
the square root Uj := \f\~j of p = min(m, n) first eigenvalues of the matrix
ATA found in 1) in descending order.
5) Find the first r column vectors of the m x m matrix U
uj = —Avj, 
j = l,2,...,r.

Matrix Calculus 109
6) Add to the matrix U the rest oim — r vectors using the Gram-Schmidt
orthogonalization process.
Apply the algorithm to the matrix
Solution 5. We find
The eigenvalues are (arranged in descending order) Ai = 3 and A2 = 1.
2) The number of nonzero eigenvalues are r = 2.
3) The orthonormal eigenvectors of the matrix A
T A corresponding to the
eigenvalues Ai and A2 are given by
_{V2/2\ 
( v/2/2 \
Thus we obtain the 2 x 2 matrix V (VT follows by taking the transpose)
V = ( V 1 V J ) = 1 4 2 -V5/2J-
4) From the eigenvalues we find the singular matrix
/v/3 
0 \
E= 
0 
y/l)
V 0 
0 /
on the leading diagonal of which are the square roots of the eigenvalues of
the matrix AT A (in descending order) and the rest of the entries of the
matrix S are zeros.
5) Next we find two column vectors of the 3x3 matrix U using the equation
given above
1 
/V6/3\ 
, 
/ 
0 
\
ui = — Avx = 
v^/6 
, u2 = — Av2 = 
-V2/2 
.
\V6/6/ 
a 2 
\ v^/2 /

110 Problems and Solutions
6) To find the vector 113 we apply the Gram-Schmidt process. The vector
U3 is perpendicular to Ui and U2. We have
113 = ei - (uf ei)u! - (uj e i)u 2 = (1/3 - 1/3 - 1/3)T.
Normalizing the vector we obtain
/ V3/3 \
u3 = -VS/3 .
V-V3/3/
It follows that
/\/6/3 
0 
v/3/3 \
U = (ux u2 u3) = 
v/6/6 >/2/2 -y/Z/i 
.
Vv^/6 -V2/2 -Vs/3/
Thus we have found the singular value decomposition of the matrix A.
Remark. We have
and therefore
ATAVJ 
— o"j\j, 
AAT\ij = o-jUj .
Problem 6. Let A be an n x n matrix. Assume that the inverse matrix
of A exists. The inverse matrix can be calculated as follows {Csanky's
algorithm). Let
p(i) = det(iJn - A) 
(1)
where In is the n x n unit matrix. The roots are, by definition, the eigen-
values Ai, A2, ..., An of A. We write
p(x) = xn + cixn~l -I 
1- cn_ix + On 
(2)
where
cn = (-l)ndetA.
Since A is nonsingular we have cn ^ 0 and vice versa. The Caley-Hamilton
theorem states that
p(A) = An + dvT- 1 + • • • + c^^A + cnln = 0n. 
(3)
Multiplying this equation with A~1 we obtain
A"1 = — ( A " " 1 + ClA"-2 + • • • + Cn-i/n) . 
(4)

Matrix Calculus 111
If we have the coefficients Cj we can calculate the inverse matrix A. Let
Then the Sj and Cj satisfy the following n x n lower triangular system of
linear equations
/I 
0 
0 
... 0 \ / c A 
/ - s i \
si 
2 
0 
... 0 
c2 
- s 2
s2 
si 
3 
... 0 
c3 
_ 
- s 3
\ s n _ i 
sn_2 ... si n/ \cn/ 
\-sn/
Since
tr(Afc) = Af + A2
fc + • • • + A^ = sfc
we find Sfc for k = 1,2,..., n. Thus we can solve the linear equation for
Cj. Finally using (4) we obtain the inverse matrix of A. Apply Csanky's
algorithm to the 4 x 4 matrix
(
0 1 0 0 \
0 0 1 0
o
o
o
i
-
1 0 
0 0/
Solution 6. Since
(
0 0 1 0\ 
/0 0 0 1\
0 0 0 1 ) 
3 
I 1 0 0 0 ]
1 0 0 0 ' 
U 
= 
0 1 0 0
0 1 0 
0/ 
VO 0 1 0/
and U4 — I4 we find
trf/ = O = S!, 
trf/2 = 0 = s2, tvU3 = 0 = s3, trt/4 = 4 = s4 .
Thus we obtain the linear equation
/I 
0 0 Ox / C l x 
/ Ox
0 2 0 0 I [ C2 ) _ [ 0
0 0 3 0 
c3 
~ 
0
\0 0 0 4/ \ c 4 / 
\ - 4 /
with the solution
C i = 0 , 
C 2 = 0 , 
C3 = 0 C4 = - l .

112 
Problems and Solutions
Thus the inverse matrix is given by
(
0 0 0 1\
1 0 
0 0
0 1 0 0 I •
0 0 
1 0 /
Problem 7. 
A distance between two m x n matrices A and B over the
real numbers can be defined as
\\A - B\\ := y/ti((A - B)(A - B)f)
where T denotes the transpose. Find an efficient way to calculate the dis-
tance. The expression
\\A\\ := y/ti{AAT)
is called the Hilbert-Schmidt norm of A.
Solution 7. Since we take the trace we only have to calculate the diagonal
elements of the matrix
(A - B){A - B)T .
Problem 8. (i) To test programs for the eigenvalue problem of real nxn
symmetric matrices it is useful to have a set of easily generated matrices
whose eigenvalues are known. Consider the following, nine real symmetric
matrices and discuss the problem with the eigenvalue calculations,
(ii) What other tests on the eigenvalues can be performed to test the accu-
racy?
(1) The Hilbert segment of order n matrix is given by
1
3 
i+j-1
For n — 4 we have
/ 1 
1/2 
1/3 
1/4 \
1/2 
1/3 
1/4 
1/5
I 1/3 1/4 
1/5 
1/6 
•
\l/4 
1/5 
1/6 
1/7/
(2) The Ding Dong matrix
- ! 
1
a y - 2 n - i - j + 3/2'

Matrix Calculus 113
For n = 4 we have
/1/7 1/5 
1/3 
1 \
1/5 1/3 
1 
-1
A-\l/3 
1 
- 1 
-1/3 
•
V 1 
- 1 
-1/3 - 1 / 5 /
(3) The Moler matrix
and
i4»j =min(i,j)-2, 
i ^ j -
For n = 4 we have
/ 1 - 1 -1 - 1 \
- 1 
2 
0 
0
1-1 
0 
3 
1 *
V-l 
0 
1 4 /
(4) The Frank matrix
Ai:i =min(i,j).
For n = 4 we have
/I 
1 1 IX
1 2 
2 2
I 1 2 3 3 
'
\1 
2 3 4/
(5) The bordered matrix
Au = l
Ain = Ani — 2l~l 
for i ^ n
Aij = 0 otherwise.
For n = 4 we have
(
1 0 
0 
1 \
0 
1 
0 
1/2
0 
0 
1 
1/4 I "
1 1/2 1/4 
1 /
(6) The diagonal matrix
An =i
and
A^ = 0 
for i =/= j .

114 Problems and Solutions
(7) The Wilkinson W+ matrix (n odd)
An — \n/2\ 
+ 1 - min(i, n - i + 1) 
for 
i=l,2,...,n
Aiti+i 
= Ai+i,i = 1 
for 
i — 1,2,.. . , n - 1
Ay = 0 for 
|j - i| > 1
where [bj is the largest integer less than or equal to b. For n = 5 we have
/2 
1 0 0 
0\
1 1 1 0 
0
A= 
0 
1 0 
1 0 
.
0 
0 
1 1 1
VO 0 0 1 
2 /
(8) The Wilkinson W~ matrix (n odd)
An = [n/2\ + 1 - i 
for 
i = l,2, . . . , n
Ai i i +i=74 i + 1 |i = 1 for 
i = 1,2, . . . , n - 1
A j = 0 
for 
|j - z| > 1.
For n = 5 we have
/2 
1 0 
0 
0\
1
1
1
0 
0
A = 
0 1 0 
1 
0 
.
0 
0 1 - 1 
1
\ 0 
0 0 
1 
-2/
(9) Matrix with all ones
dij = 1 for all 
i,j.
Solution 8. Since the matrices are real and symmetric all the eigenvalues
are real.
(1) This matrix is notorious for its logarithmically distributed eigenvalues.
While it can be shown in theory to be positive definite, in practice it is
so ill conditioned that most eigenvalue algorithms fail. The eigenvalues for
the 4 x 4 case are: 0.0001,0.0067, 0.1691, 1.5002.
(2) The Ding Dong matrix has few trailing zeros in any elements, so is
always represented inexactly in the machine. However, it is very stable
under inversion by elimination methods. Its eigenvalues have the property
of clustering near ±TT/2. For the case n = 4 we find -1.5707, -1.4811,

Matrix Calculus 115
0.7608, 1.5672.
(3) This matrix has a very simple Choleski decomposition. Thus it is pos-
itive definite. Nevertheless, it has one small eigenvalue and often upsets
elimination methods for solving linear equation systems. The eigenvalues
for the case n = 4 are 2.2974, 2.5477, 0.0334, 5.1215.
(4) This is a well behaved matrix. The eigenvalues for the case n = 4 are
0.2831, 0.4260, 1.0000,8.2909.
(5) This matrix has (n — 2) eigenvalues at 1. The eigenvalues for the case
n = 4 are 1.0000, 1.0000, 2.1456, -0.1456.
(6) This matrix has the eigenvalues 1,2,..., n. However one finds programs
that fail to run correctly for this case.
(7) The tridiagonal matrix has several pairs of close eigenvalues despite the
fact that no superdiagonal element is small. The separation between the
two largest eigenvalues is of the order of (n!)~2 so that the power method
will be unable to separate them unless n is very small.
(8) For odd order this matrix has eigenvalues which are pairs of equal mag-
nitude but opposite sign.
(9) This matrix is singular. The rank is one. Thus only one eigenvalue,
namely n is nonzero, i.e., (n — 1) eigenvalues are zero.
(ii) The trace of an n x n matrix is the sum of the eigenvalues, i.e.,
n
3 = 1
The determinant of an n x n matrix is the product of the eigenvalues
det(A) = f[\j.
Problem 9. 
To find the eigenvalues and eigenvectors of a symmetrical
matrix over R one often uses the Jacobi method. It consists of a sequence
of orthogonal similarity transformations of the form
A - Q^AQi -» Q2lQT1AQxQ2 -> ...

116 
Problems and Solutions
Let 1 < p < r < n. The basic Jacobi rotation matrix Q is a matrix with
%P = Qrr = cos(6), 
qu = 1 if i ± p, r
%r = ~qrp — - sin(0), 
qip = qpi = qir — qri = 0 if i ^ p, r
qij = 0 if i ^ p, r and j ^p,r .
The idea of the Jacobi method is to try to zero the off-diagonal elements
by a series of plane rotations. Write a C++ program that implements this
method.
Solution 9. In the program we consider the case n = 4. However, it can
easily be modified to other orders.
/ / eigenvalues.cpp
#include <iostream>
#include <cmath>
using namespace std;
int main(void)
{
const int M = 4 , n p = 4 , n = 4 ;
int j , iq, ip, i, nrot;
double tresh, theta, tau, t , sin, s, h, g, c;
double A [M] [M] , v [M] [M] , d [M] , b [M] , z [M] ;
A[0][0] = 1.0; A[0][l] = 1.0/2.0;
A[0][2] = 1.0/3.0; A[0][3] = 1.0/4.0;
A[l][0] = 1.0/2.0; A[1][1] = 1.0/3.0;
A[l][2] = 1.0/4.0; A[l][3] = 1.0/5.0;
A[2][0] = 1.0/3.0; A[2] [1] = 1.0/4.0;
A[2] [2] = 1.0/5.0; A[2] [3] = 1.0/6.0;
A[3][0] = 1.0/4.0; A[3] [1] = 1.0/5.0;
A[3] [2] = 1.0/6.0; A[3] [3] = 1.0/7.0;
for(ip=0;ip<n;ip++)
{
for(iq=0;iq<n;iq++) { v[ip][iq] = 0.0; >
v[ip] [ip] = 1 . 0 ;
}
for(ip=0;ip<n;ip++)
{
b[ip] = A[ip] [ip];

Matrix Calculus 117
d[ip] = b[ip];
z[ip] = 0.0;
}
nrot = 0;
for(i=0;i<100;i++)
{
sm = 0.0;
for(ip=0;ip<(n-l);ip++)
{
for(iq=ip+l;iq<n;iq++)
{ sm += fabs(A[ip][iq]); }
}
if(sm == 0.0) goto LAB;
if(i < 6) tresh = 0.2*sm/pow(n,2.0);
else tresh =0.0;
f or(ip=0;ip<(n-1);ip++)
{
for(iq=ip+l;iq<n;iq++)
{
g = 100.0*fabs(A[ip][iq]);
if((i > 6) && ((fabs(d[ip]) + g) == fabs(d[ip]))
&& ((iabs(d[iq])+g) == fabs(d[iq])))
A[ip][iq] = 0.0;
else if(fabs(A[ip][iq]) > tresh)
{
h = d[iq] - d[ip];
if((fabs(h) + g) == fabs(h)) { t = A[ip][iq]/h; }
else
{
theta = 0.5*h/A [ip] [iq];
t = 1.0/(fabs(theta) + sqrt(1.0 + pow(theta,2.0)));
if(theta < 0.0) t = - t;
}
c = 1.0/sqrt(1.0 + pow(t,2.0));
s = t*c;
tau = s/(1.0 + c);
h = t*A[ip] [iq] ;
z[ip] = z[ip] - h; z[iq] = z[iq] + h;
d[ip] = d[ip] - h; d[iq] = d[iq] + h;
A[ip][iq] = 0.0;
for(j=0;j<ip-l;j++)

118 Problems and Solutions
{
g = A[j][ip]; h = A[j][iq];
A[j][ip] = g - s*(h+g*tau); A[j][iq] = h + s*(g-h*tau);
}
for(j=ip+l;j<iq-l;j++)
•C
g = A[ip][j]; h = A[j][iq];
A[ip][j] = g - s*(h+g*tau); A[j][iq] = h + s*(g-h*tau);
>
for(j=iq+l;j<n;j++)
{
g = A[ip][j]; h = A[iq][j];
A[ip][j] = g - s*(h+g*tau); A[iq] [j] = h + s*(g-h*tau);
}
for(j=0;j<n;j++)
{
g = v[j] [ip] ; h = v[j] [iq] ;
v[j][ip] = g - s*(h+g*tau); v[j][iq] = h + s*(g-h*tau);
}
nrot++;
>
>
>
for(ip=O;ip<n;ip++)
{
b[ip] = b[ip] + z[ip] ;
d[ip] = b[ip];
z[ip] = 0.0;
}
}
LAB:
for(i=0;i<np;i++)
cout « "i = " « i « " d[" « i « "] = " << d[i]
« endl;
return 0;
}
Problem 10. Given an n x n positive semi-definite matrix A. We want
to find the eigenvalues Ai, A2,..., An of this matrix. Can the search of the
eigenvalues be restricted to a certain range?

Matrix Calculus 119
Solution 10. A positive-semidefinite matrix is hermitian. Thus the eigen-
values are real. Since A is positive-semidefinite we have Amin > 0. Since
n
trA = ^ A , -
3 = 1
we have Xmax < trA Thus the eigenvalues are restricted to the interval
[O.trA].
Problem 11. 
Let A be an n x n matrix over R. Then a given vector
norm indices a matrix norm through the definition
||A||:=max||Ax||
where x e Rn. We consider the Euclidean norm for the vector norm in
the following. Thus ||yl|| can be calculated using the Lagrange multiplier
method with the constraint ||x|| = 1. The matrix norm given above of the
matrix A is the square root of the principle component for the matrix ATA,
where T denotes transpose. Thus it is equivalent to the spectral norm
U\\ := KLl,
where Amax is the largest eigenvalue of A1A.
(i) Which of the two methods is faster in calculating the norm of A1
(ii) Apply the two methods to the matrix
-GO-
Solution 11. 
(i) In the first method we have to take into account the
constraint ||x|| — 1. We can use the Lagrange multiplier method for the
function
/(x)=x TA TAx + /z||x||2
where jj, is the Lagrange multiplier. After differentiation of the function
with respect to x\, X2, • • •, xn and setting the results equal to zero we have
to solve a system of n + 1 equations with respect to x\, X2, ..., xn and /i,
where the n + 1 equation is ||x||2 = 1. In the second method we have to
calculate the transpose of A. Then we have to do matrix multiplication.
Finally for the matrix A1A we have to find the largest eigenvalue. Thus,
it seems that the second method is faster to calculate the norm,
(ii) We apply the Lagrange multiplier method. Since
|| Ax|| = (Ax)TAx = 
xTATAx

120 
Problems and Solutions
we find
||Ax||2 = lOx? + 20x1x2 + lOx2, .
From the constraint ||x|| = 1 we obtain
x\ + x\ = 1.
Differentiating the function
/(x) = \0x\ + %Sxxx2 + lOz2, + (J.(xl + x\)
with respect to x\ and x2 where /J. is the Lagrange multiplier and setting
the derivative equal to zero yields
~ 
= 20a;i + 20x2 + 1\ixx = 0
ox i
df
- ^ = 20xi + 20x2 + 2/xx2 = 0.
dx2
Thus, we find that xi = x2 and
(xux2) = (1/A1/V2), 
(xux2) = (-1/V2,-1/^).
It follows that ||J4||2 = 20. For the second method we have
T 
(10 
10 \
A A~\W 
10J
with the eigenvalues 20 and 0. Thus 20 is the largest eigenvalue and there-
fore \\A\\ = v^O-
Problem 12. 
If C is an n x m matrix and D is an m x n matrix then
det(7n - CD) = det(/m - DC)
where /„ is the nxn 
identity matrix. Prove the identity.
Solution 12. Let
Then
d e t ( X y ) = d e t (In 
~CD 
f
)
= d e t ( / n - 
C D )
a n d
det(YX) = det ( ^ 
^ ^D(J 
^ = det(/m - DC).

Matrix Calculus 121
The result follows from det(XY) = det(YX). 
Which of the two sides is
faster to calculate?
Problem 13. 
Let C be an n x m matrix and D be an m x n matrix.
Show that the nxn matrix CD and the mxm DC have the same non-zero
eigenvalues.
Solution 13. The characteristic polynomial of CD is
pn(A) = det(A/n - CD) = A" det(/n - (A"1 C)D)
and the characteristic polynomial of DC is
Pm(A) = det(A7m - DC) = Amdet(7m - 
D^C)).
Applying that det(/n — CD) = det(/m - DC) from problem 12 we find that
PmW = Xm-"pn(X)
and the characteristic polynomial of CD and DC have the same non-zero
roots.
Problem 14. A magic square is an n x n matrix of the integers from 1 to
n2 such that the sum of each row and column and the two major diagonals
is the same. For example
/15 
8 
1 24 17\
16 14 
7 
5 23
22 20 13 
6 
4 
.
3 
21 19 12 10
V 9 
2 25 18 1 1 /
In this example, the common sum is 65. Coxeter has given the following
rule for generating a magic square when n is odd. Put a one in the middle
of the top row. Go up and left assigning numbers in increasing order to
empty boxes. If our move causes us to jump off the square (that is, we go
beyond the square's boundaries), figure out where we would be if we landed
on a box on the opposite side of the square. Continue with this box. If a
box is occupied go down, instead of up and left and continue. Write a C++
program that implements this rule.
Solution 14.
// Coxeter.cpp
#include <iostream>

122 
Problems and Solutions
using namespace std;
const int maxsize = 15;
int main(void)
{
static int square[maxsize][maxsize];
int i, j, row, column;
int count, size;
cout << "enter the size of the square: ";
cin >> size;
// check for input errors
if((size < 1) M (size > maxsize +1))
{
cout « "size is out of range";
exit(O);
}
if((size%2) == 0)
{
cout << "size is even";
exit(l);
}
for(i=0;i<size;i++)
for(j=0;j<size;j++)
square[i][j] = 0 ;
square[0][(size-l)/2] = 1; // middle of first row
i = 0;
j = (size-l)/2;
for(count=2;count<=size*size;count++)
{
row = (i-1 < 0) ? (size-1) : (i-1); 
// up
column = (j-1 < 0) ? (size-1) : (j-1); // left
if(square[row][column]) // down
i = (++i)7.size;
else { i = row; j = column; }
square[i][j] = count;
}
// output of magic square
cout << "magic square of size: " << size << endl;

Matrix Calculus 123
for (i=0; Ksize; i++)
{
for(j=0;j<size;j++)
cout « square[i][j] « " ";
cout « endl;
>
return 0;
}
P r o b l e m 15. 
Consider the nxn 
nonsingular tridiagonal matrix A given
by
/b0 
c0 
0 
0 
. . . 
0 \
a\ 
b\ 
ci 
0 
. . . 
0
0 
a-i 6 3 
c 2 
... 
0
A. — 
. 
. 
. 
.
0 
0 
a-n-2 bn-2 Cn-2
V 0 
0 ... 
0 
an_! bn-i)
We seek the LDU-factorization of the matrix A - that is, the determination
of a unit lower triangular matrix L, a diagonal matrix D, and a unit upper
triangular matrix U such that A = LDU. It is easy to see (check it) that
the matrices L, D and U can be specified as follows
/ 1 
0 
0 
0 
... 0\
tx 
1 
0 
0 
... 0
0 £2 1 
0 
... 0
0 
0 ... £n_2 
1 0
Vo 
0 ... 
0 
£„_! 1 /
/ I 
«o 0 
0 
... 
0 \
0 
1 
ui 
0 
... 
0
0 
0 
1 
«2 ... 
0
0 
0 
0 
1 wn_2
\ 0 
0 
... 0 
0 
1 /
and
D = 
di&g(do,d1,...,dn_1).
From A = LDf/ we find
do = bo
dj = bj - djCj-x/dj-i, 
j = 1,2,..., n - 1
Zj=aildi-u 
3 = l , 2 , . . . , n - l
Uj = Cj/dj, j = 0,1,..., n - 2 .

124 Problems and Solutions
(i) Apply the algorithm to find L, D, and U to the matrix
/ I 
1 0\
, 4 = 1 
2 1 
.
\0 
1 
3/
(ii) Use the matrices L, D and (7 to solve the linear equation
Solution 15. ( i) Applying the recursion relation we find
(I 0 0\ 
/I 1 0\ 
/l 0 0\
L = I 1 1 0 , t/= I 0 1 1 , D= 
0 1 0 .
\0 1 1 / 
\0 0 1/ 
\0 0 2/
(ii) Since
x = L-1D~1U-1 ( 1 I
and
/ 
1 
0 
0\
L-x= 
-1 
1 0
V i -l iy
/ I 
-1 
1\
t / - ^ 
o 
i - i
\o 
o 
i/
I T 1 = diag(l 1 1/2)
we obtain
V3/2/
Problem 16. A Hadamard matrix is an m x m matrix H whose entries
are ±1 so that
HHT = mlm
where T denotes the transpose and Im is the identity matrix of order m.
This means that the rows of H are orthogonal - that is, if Qj is the jth row

Matrix Calculus 125
of H, then for j / k we have QjQ% = 0. We consider the case m = 2™,
where n is a postive integer. A class of such matrices can be constructed as
follows. The registers, C and R, contain the binary representation of the
row number r (r = 0,1,..., 2" — 1) and column number c (c = 0,1,..., 2n —
1), repectively. Let Tj and Cj be the digits of the binary registers C and R,
respectively. We define
H(c,r) := (-l)'lc'r\ 
«(c,r):= [$>,•• Cj J mod 2
where • defines the bitwise AND, i.e.,
0-0 = 0, 0-1 = 0, 
1-0 = 0, 
1-1 = 1.
Each matrix element is thus defined as the parity of the bitwise AND be-
tween a register r, containing its row number, and a register c, containing
the column number. Find the matrix H for n = 3.
Solution 16. Since n = 3 we have an 8 x 8 matrix. For example, let c = 0
and r = 0. Then we have bitstrings "000" and "000". Thus s(0,0) = 0
and (—1)° = 4-1. For example, let r = 5 and c — 6. Then we have the
bitstrings "101" and "110". Thus
5(6, 5) = (1 • 0 4- 0 • 1 4-1 • 1) mod 2 = 1
and therefore (—I)1 = —1. Performing this calculation for r = 0,1,..., 7
and c = 0,1,..., 7 we find the matrix
/+1 4-1 4-1 4-1 4-1 +1 4-1 +1 \
4-1 - 1 
4-1 - 1 
+1 - 1 
+1 
- 1
4-1 4-1 - 1 
- 1 
+1 +1 - 1 
- 1
rr = 
+ 1 - 1 
- 1 
4-1 4-1 - 1 
- 1 4-1
4-1 4-1 4-1 4-1 - 1 
- 1 
- 1 
- 1 
'
4-1 - 1 
4-1 -1 
-1 
4-1 - 1 4-1
4-1 4-1 - 1 
-1 
-1 
-1 
+1 4-1
\4-l 
-1 
-1 
4-1 -1 
4-1 4-1 
- 1 /
Obviously, the matrix is symmetrical.
Problem 17. An nx n permutation matrix P is a matrix with precisely
one entry whose value is 1 in each column and row, and all of whose other
entries are 0. The rows of P are a permutation of the rows of the identity
matrix. Describe efficient storages for permutation matrices.
Solution 17. Of course we would not store a n n x n permutation matrix
as an n x n matrix. Since it describes permutations, we could store just

126 Problems and Solutions
the permutation. For example, for the 4 x 4 permutation matrix
/0 0 0 1\
0 1 0 0 )
1 0 
0 0
\0 
0 1 0/
would be stored as (3 2 4 1) since
( 1 2 
3 4)P = (3 2 4 1)
and P is uniquely determined by the permutation. We could also store the
matrix as a linked list.
Problem 18. A sparse matrix is one with a large number of zero entries,
enough to make it worthwhile modifying algorithms for these matrices to
exploit the presence of these zeros, by not storing them, and by not doing
arithmetic with them. Describe different ways to store sparse matrices.
Solution 18. The simplest way is as a list of triples (i, j , a^), one for each
nonzero a^ in the matrix A. The problem with this simple representation
is that it is hard to access just one row or one column of A, as required
by Gaussian elimination, without inefficiently searching through the whole
list. We can however organize this list as a linked list, with entries
(i,j, a,ij,nexti, lasti, nextj,lastj)
where nexti points to the next nonzero entry in column j below i, lasti
points to the previous nonzero entry in column j above i, and nextj and
lastj similarly point to the neighboring nonzero entries in the same row.
This scheme has two drawbacks. First it requires as much as 7 times as
much storage as needed just for the nonzero entries themselves. Second,
there is no memory locality, i.e., operating on a single row of m entries re-
quires Ira memory accesses (to get the data and the nexti pointers) which
may or may not be in nearby memory locations.
Another storage scheme is the column compressed storage. This scheme
stores the nonzero entries by column in one contiguous array called values.
In addition, there is an equally long array rowdnd of the row indices of
each value. In other words, values(i) lies in row rowJnd(i). Finally, there
is a (generally much shorter) array called col_ptr{j), indicating where in the
values and rowdnd arrays each column begins: column j starts at index
coljptr(j) and ends at coljptr(j + 1) — 1. For example, consider the matrix
/ I 
0 2 0 4 \
A= \ 0 4 6 0 0 I .
\ 5 
3 0 0 9 /

Matrix Calculus 127
Then the storage would be
values = ( 1 5 4 3 2 6 4 9)
rowJnd=(l 
3 2 3 1 2 1 3 )
coLptr = ( 1 3 5 7 7 9 ) .
This storage scheme allows fast access to columns but not rows of A, and
requires about twice as much storage as for the nonzero entries alone. Since
it is not convenient to access rows with this scheme, algorithms using this
scheme should be column oriented.
Problem 19. Consider the matrices
J = ( o 
i ) >
 z
= ( o 
- i ) '
 
x
= { i 
o ) '
 
y
= ( i 
o ) •
(i) Write down the matrix multiplication table for these matrices,
(ii) We assign bitstrings to the matrices
j->oo, z->oi, x->io, y->n
where the left bit is the pattern bit and the right bit is the sign bit. The
operation on these bit strings is carried out by taking the bitwise XOR of
the two bit strings, up to a minus sign, and that the sign is negative iff the
sign bit of the left operand and the pattern bit of the right operand are
both 1. What is the use of this map and the operation described?
Solution 19. (i) Matrix multiplication yields
* \ I 
Z 
X 
Y
I 
I 
Z 
X 
Y
Z 
Z 
I 
-Y 
-X
X 
X 
Y 
I 
Z
Y \ Y X 
-Z 
-I
(ii) We find
00 XOR 00 -> 00 no minus sign
00 XOR 01 -> 01 no minus sign
00 XOR 10 -> 10 no minus sign
00 XOR 11 -> 11 no minus sign
01 XOR 00 -> 01 no minus sign
01 XOR 01 -> 00 no minus sign
01 XOR 10 -> 11 minus sign
01 XOR 11 -> 10 minus sign

128 Problems and Solutions
10 XOR 00 -> 10 no minus sign
10 XOR 01 -> 11 no minus sign
10 XOR 10 -> 00 no minus sign
10 XOR 11 -> 01 no minus sign
11 XOR 00 -> 11 no minus sign
11 XOR 01 -> 10 no minus sign
11 XOR 10 -> 01 minus sign
11 XOR 11 -> 00 minus sign
The ability to carry out multiplication of basis elements /, X, Y, Z using
only simple bit operations is what makes the bit string representation so
useful.
Problem 20. 
To calculate the eigenvalues of the 4 x 4 matrix
(
0 
1 0 
2\
1 0 
2 0
0 2 0 
11
2 0 
1 0 /
one has to solve the quartic equation given by det(A7 — A) = 0. Can we
avoid solving this quartic equation?
Solution 20. 
This matrix can be written as the Kronecker product of two
2 x 2 matrices, i.e.,
— a ;>•(? i)-
We only have to find the eigenvalues of the two 2 x 2 matrices. Then all the
possible products of these eigenvalues are the eigenvalues of A. For the first
2 x 2 matrix, we find the eigenvalues 3, —1. For the second 2 x 2 matrix,
we find the eigenvalues 1 , - 1 . Thus, the eigenvalues of the 4 x 4 matrix A
are 3, —3, —1,1.
P r o b l e m 21. 
Consider the geometric 
series
(i) Show that the series converges.
(ii) Describe two methods to calculate the sum. Which of the two methods
is more efficient?
Solution 21. (i) Let

Matrix Calculus 129
For the norm we find ||J4|| < 1. Thus the series converges,
(ii) Since we have a geometric series we have
y±.(t iV-ff1 °V-(7 MV1
^12-U 
7) 
\\0 
l) 
12 (l 
7))
= U-\ -1))"
•KJD-
Using diagonalization of the matrix A
A- 
1 f7 
l \ -f1 
^ f2/3 ° \ /"I 
i V 1
^ 1 2 ^ 1 
7 J - ^ 1 - l A 0 
l / 2 J i l 
-l)
we find
f l f 7 
l V _ A 
1W 1/(1-2/3) 
0 
\ / l 
IV1
^12-V1 y "vi -iy v 
o 
i/(i-i/2); V1 - i ;
= (i -ij(o 2)2(1 -1)
= -(5 
x)
2 V 1 5 ; •
In the first method, we do not need the eigenvalues of A, however, we
calculate the inverse of a matrix. For the second method, we calculate the
eigenvalues but not the inverse.
Problem 22. Let A be an n x n symmetric matrix over R. We assume
that the real eigenvalues of A are Ai, A2,..., An, where
| A i | > | A 2 | > - - - > | A n | .
Let v € R". Then we can write
v = cxvi + e2v2 -\ 
+ cnvn
where Vi, v 2,..., v n are the eigenvectors of A and c\, c 2,..., cn £ R with
ci^O.
(i) Find Ap~v, where p = 1,2,
(ii) Show that this provides a way to calculate Ai and vi.
(iii) Give a C++ implementation for the 3 x 3 matrix
/ 3 
2 1 \
A= 
2 2 5 
.
\l 
5 8j

130 Problems and Solutions
Solution 22. (i) Since AVJ = XjVj we have
Av = ciAvi + c2Av2 H 
1- cnAvn
= Ai fciv1+c2^v2 + ---+cn-^vnj .
Thus
^ = M(CVI + . , ( £ ) \ » + ... + * ( £ ) ' V . ) .
For large values of p, the vector in the bracket will converge to civi, that
is, the eigenvector of Ai. The eigenvalue Ai is obtained from
A, = lim < £ ^
where r (r = 1,2,..., n) is the component of the vector with the largest
absolute value. The rate of convergence is determined by the quotient.
Convergence is faster the smaller |A2/A11 is.
(iii) An algorithm can be formulated as follows. Given a vector y^, we form
two other vectors
zfe+1 = Ayk, ak+x = max |(zfc+i)r , y^+i =
l<r<n 
Ctk+1
where k = 0,1,2,.... 
For the initial vector yo we choose
1
yo = 
•
i.e., all components are equal to 1.
// largesteig.cpp
#include <iostrecim>
#include <cmath>
using namespace std;
double largest(double** A.int iter.int n)
{
int i, j , k;
double* y = new double[n];
for(i=0;i<n;i++) y[i] = 1.0;
double* z = new double[n];

Matrix Calculus 131
double largest;
for(i=l;i<iter;i++)
•C
for(j=0;j<n;j++)
{
z[j] = 0.0;
for(k=0;k<n;k++) 
z[j] += A[j] [k]*y[k] ;
}
largest = z[0];
for(j=l;j<n;j++)
if(fabs(z[j]) > fabs(largest)) largest = z[j];
for(j=0;j<n;j++) y[j] = z[j]/largest;
}
delete [] y; delete [] z;
return largest;
}
int main(void)
•C
int n = 3;
double** A = NULL;
A = new double*[n];
for(int i=0;i<n;i++)
A [i] = new double[n];
A[0][0] = 3.0; A[0][l] = 2.0; A[0] [2] = 1.0;
A[l][0] = 2.0; A[1][1] = 2.0; A[l] [2] = 5.0;
A[2][0] = 1.0; A[2][l] = 5.0; A[2] [2] = 8.0;
cout << "The largest eigenvalue is " « largest(A,10,n);
for(int j=O;j<n;j++) delete[] A[j] ;
delete [] A;
return 0;
}
Problem 23. With the Leverrier method the characteristic polynomial
and the inverse (if it exists) of an n x n matrix A can be calculated as
follows. We form a sequence o f n x n matrices Bi,B2,...,Bn 
from which
we calculate the pk values of the characteristic polynomial
( _ i r ( A " - p 1 A " - 1 - p 2 A n - 2 
Pn) = 0
where the ( — 1)" is used to give the terms of the polynomial the same signs
that they would have if the polynomial were generated by expanding the

132 Problems and Solutions
determinant of A — XIn. We have
Bx = A 
pi= trBi
B2 = A(Bi -Piln) 
p2 = ^tiB2
B3 = A(B2 - p2ln) 
Pz = 3trSa
Bn = A(Bn-i - pn-il) 
pn = -tlBn .
n
The inverse (if it exists) is given by
A~l = — (B n_i-p n_!/ n).
The condition that the inverse exists is pn ^ 0. Apply the Leverrier method
to the matrix
/3 
2 4\
A= 
2 0 2
\4 
2 3/
and determine whether the inverse exists.
Solution 23. We have n — 3. We obtain
Si = A, 
pi= tiBi = 6.
Thus
/ l l 
2 
4 \
B2 = ^(S 1-p 1J 3)= 
2 8 
2
V 4 2 ii y
and
p2 = 2 t r 5 2 = 1 5'
Finally
/8 0 0\
B3 = A(S2-P2/3)= 
0 8 0
\0 0 8/
with
P3 = gtrBa = 8.
Thus we obtain the characteristic polynomial
(-l)3(A3-6A2-15A-8) = 0.

Matrix Calculus 133
Since p3 ^ 0 the inverse of A exists, where ps is the determinant of A. We
find
1 
1 / - 4 
2 
4 \
A -
1 = - ( B 2 - P 2 I 3 ) = - [ 
2
-
7 
2 
.
?
3 
8 V 4 
2 
- 4 /
Problem 24. 
Let A be an n x n hermitian matrix. Then we have the
so-called Stratonovich-Hubbard identity
r+oo
exp(A2) = I 
exp(-irx2ln 
- 2Axy^r)dx
J — oo
where /„ is the n x n identity matrix. Would it be faster to calculate the
right-hand side instead of the left-hand side?
Solution 24. 
Since [/n,A] = 0, where [, ] denotes the commutator we
can write
exp(-7rx2/n — 2AXT/K) = exp(—7ra;2/n)exp(—2Ax\fw).
The first matrix on the right-hand side is a diagonal matrix.
Problem 25. The Householder method is a method used for reducing an
n x n matrix A to an upper Hessenberg matrix or into tridiagonal form if
the matrix A is symmetrical (over R). For a nonzero vector v e R", we
define a Householder transform as an n x n matrix
P = In- 
^ 
W T
INI
2
then P is symmetrical, orthogonal and P~1 = P. We form a sequence of
matrices A^ 
= A, A^ 
= P^APW, so that after n - 1 steps the final
matrix is nearly Hessenberg since the roundoff error may result in some
slightly nonzero entries below the subdiagonal.
For a given x € R m and w = (1,0,..., 0)T e Rm, we set
a :- ||x||, 
v — X + CTW.
Then we have with P = Im - 2vvT/||v||2, where v G R m that
Px = -crw = (-a, 0,..., 0)T .
Let
/ 021 \ 
/ 1 \
O31 I 
1 0 1
'- = • H;
\ani/ 
\0/

134 
Problems and Solutions
with a = y/Y^k=2 a L a nd -^ = (ay)- W e s e t
/ I 
0 . . . 
0\
p(«= °
: 
P
\o 
y
i.e., PW = In - (2/||v||2)vvT with v = (0,a 2 1+(7,a3i,...,a n_ 1) T. Thus
we have the matrix
/an 
. . . \
—cr
P ( 1 ) A P ( 1 ) = 
0
; w
V o 
/
The next step is to apply this step to (*) and so on. Write a C++ program
that implements the Householder method.
Solution 25. We consider the nondiagonal matrix
/5.3 2.3 4.6 2.7 1.6 
2.2\
2.4 7.8 5.7 8.4 3.4 4.2
3.4 5.6 2.4 
1.7 
7.4 3.9
8.3 7.5 9.2 6.1 5.2 7.9 
"
4.3 5.9 7.2 2.6 4.9 0.8
\0.9 
2.7 4.9 4.8 6.7 4.8/
// Hessenberg.cpp
#include <iostream>
#include <cmath>
using namespace std;
int main(void)
{
const int n = 6;
double A [n] [n] ;
A[0][0] = 5.3; A[0][l] = 2.3; A[0][2] = 4.6;
A[0][3] = 2.7; A[0] [4] = 1.6; A[0] [5] = 2.2;
A[l][0] = 2.4; A[1][1] = 7.8; A[l][2] = 5.7;
A[l][3] = 8.4; A[l][4] = 3.4; A[l] [5] = 4.2;
A[2][0] = 3.4; A[2] [1] = 5.6; A[2] [2] = 2.4;
A[2] [3] = 1.7; A[2] [4] = 7.4; A[2] [5] = 3.9;
A[3][0] = 8.3; A[3] [1] = 7.5; A[3] [2] = 9.2;

Matrix Calculus 135
A[3] [3] = 6.1; A[3] [4] = 5.2; A[3] [5] = 7.9;
A[4][0] = 4.3; A[4] [1] = 5.9; A[4] [2] = 7.2;
A[4] [3] = 2.6; A[4] [4] = 4.9; A[4] [5] = 0.8;
A[5][0] = 0.9; A[5][l] = 2.7; A[5] [2] = 4.9;
A[5] [3] = 4.8; A[5] [4] = 6.7; A[5] [5] = 4.8;
double T [n] [n] ;
int i r , i, j , k;
double s, w, ssr, h, uau, b23;
double u[n] ;
for(ir=0;ir<(n-2);ir++)
•C
s = 0.0;
for(i=0;i<n;i++)
{
u[i] = 0.0;
if(i > ir+1) u[i] = A[i] [ir] ;
if(i > ir) s += A[i][ir]*A[i][ir];
> / / end for i
w = 1.0;
if(A[ir+1][ir] < 0.0) w = -1.0;
ssr = sqrt(s);
h = s + fabs(A[ir+l][ir])*ssr;
u[ir+l] = A[ir+l][ir] + ssr*w;
uau =0.0;
for(i=0;i<n;i++)
{
for(j=0;j<n;j++)
{
uau += u[i]*A[i] [j]*u[j] ;
if((i <= ir) && (j <= ir)) T[i] [j] = A[i][j];
else if((j == ir) && (i >= ir+2)) T[i][j] = 0.0;
else
{
b23 =0.0;
for(k=0;k<n;k++)
{
b23 += - (u[i]*A[k][j] + A[i][k]*u[j])*u[k];
}
T[i][j] = A[i][j] + b23/h;
>
}
>

136 Problems and Solutions
uau = uau/(h*h);
for(i=0;i<n;i++)
for(j=0;j<n;j++)
A[i][j] = T[i][j] + uau*u[i]*u[j];
} / / end for ir
/ / display the result
for(i=0;i<n;i++)
for(j=0;j<n;j++)
cout « "A[" « i « "] [" « j « "] = " « A[i][j] « endl;
return 0;
} / / end main
Problem 26. Consider the system of linear equations
A
n
n 
\ / x° \ 
/ D° \
Al 
B2 °2 
x2 
= D2
Bn-2 C 2 I ^ • J \D 
)
\ 
An-2 
-Dn-1/
where the matrix on the left-hand side is an n x n tridiagonal matrix. We
assume that the matrix is invertible and that B}i ^ 0 for j = 0 , 1 , . . . , n — 1.
This type of equation appears when we consider discretization of boundary
value problems of differential equations. An algorithm to find 
XQ,X\,...,
£„_! given Aj, Cj (j = 0,1,... ,n - 2), Bk (fe = 0,1,... ,n - 1) and Dk
(k = 0 , 1 , . . . , n — 1) is as follows:
(1) Calculate in increasing order of i = 1 until n — 1
t*-Ai-!/Bi-i
Bi*— Bi — tCi_j
A«-A-*A-i
(2) Calculate
(3) Calculate in descreasing order of i
Di*-(Dl-CiDi+1)/Bl, 
t = n - 2 , . . . , 0 .
The result (xo,X\,... 
,x n_i) is stored in (D0,Di,... 
,Dn-i). 
Write a C++
program that implements this algorithm. Apply it to the case n = 3 and
Ao = 1.0, Ai = 1.0, Bo = 1.0, # i = 2.0, B2 = 3.0, Co = 1.0, Ci = 1.0 and
Do = 1.0, £>i = 1.0 and D2 = 1.0.

Matrix Calculus 137
Solution 26. The function trdgO implements the algorithm.
/ / tridiagonal.cpp
#include <iostream>
using namespace std;
void trdg(double* A,double* B,double* C,double* D.int n)
{
int i;
double t;
for(i=l;i<n;i++)
{
t = A[i-1]/B[i-1];
B[i] += -t*C[i-l];
D[i] += -t*D[i-l];
}
D[n-1] = D[n-1]/B[n-1];
for(i=n-2;i>=0;i—)
{
D[i] = (D[i] - C[i]*D[i+l])/B[i];
}
}
int main(void)
{
int n = 3;
double* A = new double[n-1];
A[0] = 1.0; A[l] = 1.0;
double* B = new double[n];
B[0] = 1.0; B[l] = 2.0; B[2] = 3.0;
double* C = new double[n-1];
C[0] = 1.0; C[l] = 1.0;
double* D = new double[n];
D[0] = 1.0; D[l] = 1.0; D[2] = 1.0;
trdgCA.B.C.D.n);
for(int i=0;i<n;i++)
{
cout « "D[" « i « "] = " « D[i] « endl;
}
delete [] A; delete [] B;
delete [] C; delete [] D;
return 0;
>

138 Problems and Solutions
Problem 27. 
Let A be an n x n symmetric positive-definite matrix
over R. Let Amax and \min 
De the largest and smallest eigenvalues of
A, respectively. Since A is positive-definite the eigenvalues are real and
positive. For all 6 with 0 < 6 < 1 the iteration
Bk+l = Bk+c{A-B2
k), 
B0 = 2cA
with
6
c = —
2v Amax
converges to \f~A. The rate of convergence of the iteration is given by the
rate of convergence to zero of the sequence
xk = (l- 
e^\min/\max)k.
As ||v4|| = a\max with a > 1 we set
01
Cl 
2vPf"
Choose the norm
n-l
\\A\\ := max ^ | a j f c | .
0<7<n ^—'
- 
fc=O
Then the iteration with c — C\ converges for all 6\ with
0 < 6X < sfa = 
yJ\\A\\/\max
and therefore in any case for 6\ with 0 < 9y < 1. Write a C + + program
that implements this iteration. Apply it to the 3 x 3 matrix
/ 5 
2 
1 \
A = 
2 5 4 
.
\i 4 5y
Solution 27. W e set #i = 0.5 in the program. Furthermore, eps = 0.001
is an accuracy parameter.
// sqrtmatrix.cpp
#include <iostream>
#include <cmath>
using namespace std;
int main(void)

Matrix Calculus 139
{
const int n = 3;
double A[n][n];
A[0][0] = 5.0; A[0][l] = 2.0; A[0][2] = 1.0;
A[l][0] = 2.0; A[1][1] = 5.0; A[l] [2] = 4.0;
A[2][0] = 1.0; A[2][l] = 4.0; A[2] [2] = 5.0;
double B [n] [n] ;
double BB[n];
int i, j , k;
double delta, r, s;
double c = 0.0;
double theta =0.5;
double eps = 0.001;
for(i=0;i<n;i++)
{
s = 0.0;
for(j=0;j<n;j++) { s += fabs(A[i][j]); }
if(c < s) c = s;
}
c = 0.5*theta/sqrt(c);
/ / initializing B
for(i=0;i<n;i++)
for(j=0;j<n;j++)
{
B[i][j] = B[j][i] = 2.0*c*A[i][j];
}
/ / start of iteration
do
{
delta =0.0;
for(i=0;i<n;i++)
i
for(j=i;j<n;j++)
{
s = 0.0;
for(k=0;k<n;k++) s += - B [i] [k] *B [k] [j] ;
BB[j] = B[i][j] + c*(A[i][j] + s);
>
for(j=i;j<n;j++)
{
s = fabs(B[i][j] - BB[j]);
if(s > delta) delta = s;
B[i][j] = BB[j];

140 Problems and Solutions
}
}
for(i=0;i<n-l;i++)
for(j=i+l;j<n;j++)
B[j][i] = B[i][j];
} while(delta > eps);
// display the result
for(i=0;i<n;i++)
for(j=0;j<n;j++)
cout « "B[" « i « "][" « j « »] = " « B[i][j] « endl;
return 0;
}
Compare this method with the following alternative method using a bino-
mial series, i.e.,
Thus
For convergence we have
Problem 28. Let / : R" —> R be a quadratic functional
/(x) = \xTAx - xTb
with A € RnX™ a given symmetric positive-definite matrix. Find the min-
imum x* of / over Rn.
Solution 28. The minimum x* of / over R™ is unique and occurs when
the gradient of /(x) vanishes, i.e.,
V/(x*) = Ax* - b = 0.
This quadratic minimization problem is thus equivalent to solving the sys-
tem of linear equations ^4x = b.
Problem 29. Let A be an n x n matrix over R. Using recursion write a
C++ program that finds the determinant of the matrix A.

Matrix Calculus 141
Solution 29. 
If we use dynamically allocated arrays we would write
a recursive function for the cofactor expansion. Here we use a template
function for recursion, i.e., the recursion takes place at compile time.
/ / determinant.cpp
#include <iostream>
using namespace std;
template <const int n>
double det (double A[n][n]);
/ / determinant of a lxl matrix is the only entry of the matrix
template <>
double det<l>(double A[l][l])
•C return A [0] [0] ; }
/ / determinant using cofactor expansion
template <const int n>
double det (double A[n][n])
•C
int i, j , k, 1, m = 1;
double sum = 0.0;
/ / since n is a const int we can declare the matrix C
double C[n-1][n-1] ;
/ / iterate through each of the elements in the first row
/ / which will be used for the cofactor expansion
for(i=0;i<n;i++)
{
// iterate through the rows of A for the cofactor
// omitting row 0
for(j=l;j<n;j++)
{
// iterate through the columns of A for the cofactor
// omitting column i
for(l=k=0;k<n;k++,1++)
-c
if(k == i) k++;
if(k < n) C[j-l][l] = A[j][k];
}
}
// m is the sign in the cofactor expansion which alternates

142 Problems and Solutions
// 
between -1 and 1
sum += m*A[O][i]*det<n-l>(C);
m = -m;
}
return sum;
}
int main(void)
{
double A[l][l] = { { 3.0 > };
double B[2] [2] = { { 1.0, 
3.0 },
{ 7.0, 11.0 } };
double C[3][3] = { { 1.0, 2.0, 3.0 },
i 4.0, 5.0, 6.0 },
{ 7.0, 8.0, 9.0 } };
double D[5][5] = { { 1.0, 0.0, 0.0, 0.0, 1.0 },
{ 1.0, 0.0, 0.0, 0.0,-1.0 },
{ 0.0, 1.0, 0.0, 1.0, 0.0 >,
{ 0.0, 1.0, 0.0,-1.0, 0.0 },
{ 0.0, 0.0, 1.0, 0.0, 0.0 } };
cout « 
"det(A) = " « det<l>(A) « 
endl;
cout « 
"det(B) = " « det<2>(B) « 
endl;
cout « 
"det(C) = " « 
det<3>(C) « 
endl;
cout « 
"det(D) = " « det<5>(D) « 
endl;
return 0;
}
Problem 30. 
Let A be an n x n matrix over C. Let t e R. We define
"h k] '
If we know the eigenvalues of the matrix A we can calculate eiA as follows
(Putzer algorithm). Let Ai, A2, . . . , Xn be the eigenvalues of A, where
eigenvalues may be multiple. We set
B2 = (A- 
A i / J S i
B3 = (A - A2/n)S2
Bn — (A — 
\nIn)Bn_i.

Matrix Calculus 143
With this notation, we can write the Cayley-Hamilton theorem as
Bn+l = (A-XnIn)Bn 
= 0.
Let yi(t),2/2(t),... ,yn(t) be the solutions of the following system of linear
differential equations with constant coefficients
dyi ,
-aH=Xm
dy2 ,
-^ = A22/2 + y\
dyn 
.
ar
With the notation above, we have
e
t A = y i ( t ) B i + y 2 { t ) B 2 + ••• + y n { t ) B n .
Consider a 3 x 3 matrix with a triple eigenvalue A. Simplify the calculation
ofetA.
Solution 30. We have
Bi=I3, 
B2 = A-XI3, 
B3 = A2-2\A 
+ \2I3
and
yi(t)=ex\ 
y2(t) = text, 
y3(t) = ^ext.
Thus
etA = eXtj3 + teXt^A _ Xj^ 
+ \t2£\t^A 
_ Xj^2
Problem 31. Let
p(x) = c0 + c\x ^ 
1- cn^ixn~l
in which cn_i ^ 0, be a polynomial of degree n — 1 in the unknown x. Let
Ap be the companion matrix
/ 0 
1 
0 ... 
0 
0 \
0 
0 
1 ... 
0 
0
0 
0 
0 
0 
0
Ap-= 
; 
; 
; 
-. 
; 
;
0 
0 
0 
. . . 
0 
1
\ - C 0 
-C\ 
- C 2 . . . - C n _ 2 - C n - 1 /

144 Problems and Solutions
Calculate det(Ap - xln) and discuss.
Solution 31. Obviously we find
det(Ap - xln) = (-l)np(x).
P r o b l e m 32. 
We consider 3 x 3 matrices over R. An orthogonal 
matrix
Q (QT = Q^1) such that det(Q) — 1 will be called a rotation 
matrix. 
Let
1 < p < r < 3 and <^ be a real number. 
An orthogonal 3 x 3 matrix
QPr(<t>) = (qij)i<ij<3 given by
Qpp = Irr = COS (j)
qu = l 
iii^p,r
qpr — ~qrp — - s i n 0
qiP = qPi = qtr = qn = 0 
iii^p,r
qij —0 iii^p,r 
and j ^ p,r
will be called a plane rotation through <f> in the plane span (e p,e r). Let
Q = (qij)i<ij<3 be a rotation matrix. Show that there exist angles <j> in
[O,TT) and 9, ip in (—TT,TT] called the Euler angles of Q such that
Q = QM<l>)Q23{9)Qi2U>). 
(i)
Solution 32. The algebraic proof of (1) is simply the QR factorization
of our rotation matrix Q. We set Qi — Q, Q2 = Qi2(—<l>)Qi, Q2, —
Q23(-0)Q2, 
Q4 = Qis(-il>)Q3, where
Qk •= (g-f )i<»,j<3.
We then choose <f>, 6, ip to be the numbers that subsequently annihilate
#13 > #23 ' I12 1 ^na^ is such that
(1) 
(2) 
(3)
cot^ = - ^ , 
cot0 = - ^ , 
cotV = - % -
9l3 
#23 
Ql2
Q\ is a rotation lower triangular matrix and hence the 3x3 identity matrix.
Since Qpr{—VO = Qpriip)*1 we obtain (1). The rotation matrix is
Q =
/ cos </) cos V> — sin </> cos fl sin •0 
— cos 0 sin ip — sin 0 cos 8 cos V> 
sin </> sin 8 \
I sin <f> cos ^ + cos <j> cos 6 sin ^ 
— sin 4> sin ^ + cos 0 cos 0 cos ^> — cos 4>sm6 J .
y 
sin 8 sin ^ 
sin 8 cos V1 
cosS 
y

Matrix Calculus 145
Problem 33. 
To allocate memory in C++ for an n-dimensional array,
we use the new operator n-times. How would we implement this using
recursion?
Solution 33. We allocate our top-level array and then use recursion to
allocate n — 1 dimensional arrays. The following C++ program shows how
to achieve this.
/ / arrays.cpp
#include <iostream>
#include <cassert>
using namespace std;
template<class T> class Array
{
public:
Array<T>(int n=l);
~Array<T>();
// for a larger than one dimensional array
Array<T>& operator[](int);
T& operatorO(int);
void resize(int);
protected:
Array<T>* subarrays;
T* data;
T single;
int size, dim;
void redim(int);
>;
template<class T> Array<T>: .-Array(int n)
{
assert(n > 0);
size = 0; dim = n;
>
template<class T> Array<T>::"Array()
{
if(size)
{
if(dim == 1) delete [] data;
else delete[] subarrays;
}

146 
Problems and Solutions
}
template<class T> Array<T>& Array<T>::operator[](int i)
{
assert((i >= 0) && (i < size));
assert(dim > 1);
return subarrays [i];
>
template<class T> T& Array<T>::operator()(int i)
•C
assert((i >= 0) && (i < size));
assert(dim == 1);
return data[i];
}
template<class T> void Array<T>::resize(int i)
•C
assert(i >= 0);
if(i != size)
{
if(size)
i
if(dim == 1) delete[] data;
else delete[] subarrays;
}
size = i;
if(size > 0)
{
if(dim == 1) data = new T[size];
else
{
subarrays = new Array<T>[size];
for(int j=O;j<size;j++)
subarrays[j].redim(dim-l);
}
}
}
>
template<class T> void Array<T>::redim(int n)
{ dim = n; }
int main(void)

Matrix Calculus 147
{
Array<int> al(l);
Array<int> a2(2);
Array<int> a3(3);
al.resize(3);
al(O) = 1; al(l) = 2; al(2) = 3;
int suml = 0;
for(int j=O;j < 3;j++) suml += al(j);
cout « " suml = " << suml;
a2.resize(2);
a2[0] .resize(2); a2[l].resize(2);
a2[0](0) = 1; a2[0](l) = 2; a2[l](0) = 3; a2[l](l) = 4;
int sum2 = 0;
for(int k=0;k<2;k++)
for(int m=0;m<2;ni++)
sum2 += a2 [k] (m);
cout « " sum2 = " « sum2;
a3.resize(2);
a3 [0].resize(2); a3[1].resize(2);
a3[0] [0] .resize(2); a3[0][1].resize(2);
a3[l][0] .resize(2); a3[l][1].resize(2);
a3[0][0](0) = 1; a3[0] [0] (1) = 2;
a3[0][l](0) = 3; a3[0][l](l) = 4;
a3[l][0](0) = 5; a3[l][0](l) = 6;
a3[l][l](0) = 7; a3[l] [1] (1) = 8;
int sum3 = 0;
for(int n=0;n<2;n++)
for(int p=0;p<2;p++)
for(int q=0;q<2;q++)
sum3 += a3[n][p](q);
cout << " sum3 = " << sum3;
return 0;
}
Problem 34. Using the map class of the standard template library and
the string class, write a C++ program for matrices whose subscripts are
strings. For example
Matrix M;
M["Manchester"]["Leeds"] = 44;

148 Problems and Solutions
Solution 34.
// MatrixStrings.cpp
#include <iostream>
#include <iomanip>
#include <string>
#include <map>
using namespace std;
typedef map<string,double> Row;
typedef map<string,Row> Matrix;
int main(void)
{
Matrix M;
M["Manchester"]["Leeds"] = 44;
M["Leeds"]["Manchester"] = 44;
M["Manchester"]["Liverpool"] = 35;
M["Liverpool"]["Manchester"] = 35;
M["Liverpool"] ["Leeds"] = 72;
M["Leeds"]["Liverpool"] = 72;
Matrix::iterator i;
Row::iterator j;
for(i=M.begin();i!=M.end();i++)
for(j=i->second.begin(); j!=i->second.end();j++)
{
int n = i->first.length() + j->first.length() + 3;
cout « "(" « i->first « "," « j->first « 
" ) "
« setw(30-n) « j->second « endl;
}
return 0;
}

Chapter 6
Recursion
Problem 1. The Fibonacci numbers are defined by the recurrence relation
/(n + 2) = / ( n + l ) + /(n)
where n = 0,1, 2,... and /(0) = 0, /(I) = 1. We find
/(2) = 1, /(3) = 2, /(4) = 3, /(5) = 5, /(6) = 8,...
Thus, we can apply recursion to obtain the Fibonacci numbers. The golden
mean number g is defined as
g := lirn 
.
n-»oo 
/(n)
Write a Java program using recursion that finds the Fibonacci sequence
using the data type long. Find also an approximation of the golden mean
number g.
Solution 1. Extend the following program using the Java class Biglnteger.
// Fibonacci.Java
public class Fibonacci
i
public static long f(long n)
•C
if (n == 0) return 0;
if(n ==1) return 1;
149

150 
Problems and Solutions
return f(n-i) + f(n-2);
}
public static void main(String[] args)
{
long n = 10;
long result = f(n);
System.out.printlnC'result = " + result);
double gapprox = ((double) f(n))/((double) f(n-l));
System.out.printlnC'gapprox = " + gapprox);
}
>
Problem 2. A palindrome is a string that equals itself when reversed, for
example, "racecar", "abba", "12321". Write a recursive method in Java
that returns true if a given string is a palindrome. What is/are the base
case(s)? What is the recursive case?
Solution 2. The recursive definition of a palindrome is: An empty string
is a palindrome. A single character string is a palindrome. A string of
length > 1 is a palindrome if and only if its first and last characters are the
same, and the substring obtained by removing the first and last characters
is also a palindrome.
/ / Palindrome.java
public class Palindrome
{
private String pal;
public Palindrome(String initPal)
{ pal = initPal.toUpperCaseQ; }
public boolean isPalindromeO
{
if(pal.length() <= 1)
{ return true; } // base case
// get the first and last characters of the String
char first = pal.charAt(O);
char last = pal.charAt(pal.length()-l);
if(Character.isLetter(first) && Character.isLetter(last))

Recursion 
151
{
if(first != last) { return false; >
else
{
Palindrome sub =
new Palindrome(pal.substring(l,pal.length()-l));
return sub.isPalindromeO; // recursive case
>
}
else if(!Character.isLetter(first))
{
Palindrome sub = new Palindrome(pal.substring(l));
return sub.isPalindrome();
}
else
{
Palindrome sub =
new Palindrome(pal.substring(0,pal.length()-1));
return sub.isPalindromeO;
}
>
public static void main(String[] args)
{
Palindrome pi = new Palindrome("dad");
System.out.println(pl.isPalindromeO);
Palindrome p2 = new Palindrome("racecar");
System.out.printIn(p2.isPalindromeO);
Palindrome p3 = new Palindrome("nop");
System, out. print In (p3. isPalindromeO) ;
Palindrome p4 = new Palindrome("Madam, I'm Adam.");
System.out .println(p4. isPalindromeO);
>
}
Problem 3. Square a positive integer value by only using adds, subtracts,
multiply by 2 (left shift) and recursion.
Solution 3. W e have the identity
z 2 = (z - 1 + I)2
= (z - I)2 + 2(z - 1) + 1
= (x - I)2 + 2x - 1.

152 Problems and Solutions
Thus we can calculate x2 if we can calculate (x — I)2. Naturally, 02 is 0.
The recursive implementation follows trivially.
Problem 4. Let n £ No- The Hofstadter function is denned as follows
r \ 
/ 
0 
if n = 0
9[n)-\n-g(g(n-l))ifn>l
Implement this function in C++ using recursion.
Solution 4. 
We use recursion to implement this function. The function
g() is called twice for every evaluation of g(n), first with the parameter
n-1 and then with the parameter g(n-l).
// Hofstadter.cpp
#include <iostream>
using namespace std;
unsigned long g(unsigned long n)
{
if(n == 0) return 0;
else return (n - g(g(n-l)));
}
int main(void)
{
unsigned long n = 7;
unsigned long rl = g(n);
cout « "rl = " « rl « endl;
n = 10;
unsigned long r2 = g(n);
cout « "r2 = " « r2 « endl;
n = 100;
unsigned long r3 = g(n);
cout « "r3 = " « r3 « endl;
return 0;
}
Problem 5. 
The following algorithm finds the k-th. smallest element of
a sequence S:
select(fc, S)

Recursion 153
1. If |5| = 1 then the required element is the only element in S.
2. Choose an arbitrary (random) element a from S.
3. Let Si := {s £ S s< a}.
Let S2:={seS 
s = a}.
Let S3 := {s £ S j s > a}.
4. If |5i| > k the required element is given by select(k, Si).
5. If |Si| 4- IS2I > k then the required element is a.
6. The required element is given by select (A; — |Si| — JS2I» 53)-
Give a C++ implementation that finds the median, i.e., the \S\/2 smallest
element of 5.
Solution 5. We use the vector template class to denote the sequences.
The function select () implements the selection algorithm, while the func-
tion medianO uses select () to find the median element of the vector.
/ / median.cpp
#include <iostream>
#include <vector>
#include <cstdlib>
#include <ctime>
using namespace std;
template <class T> T select(int k,vector<T> s)
•C
int j;
vector<T> si, s2, s3;
if(s.size() == 1) return s[0];
j = randO'/.s.size();
for(int i=0;i<s.size();i++)
if(s[i] < s[j]) si.push_back(s[i]);
else if(s[i] == s[j]) s2.push_back(s[i]);
else s3.push_back(s[i]);
if(si.size() >= k) return select(k,si);
else if(sl.size()+s2.size() >= k) return s[j];
return select(k-sl.size()-s2.size(),s3);
}
template <class T> T median(vector<T> s)
{ return select(s .size0/2,s) ; >

154 
Problems and Solutions
int main(void)
-C
vector<int> vl(7);
vl[0] = 3; vl[l] = 1; vl [2] = 5; vl [3] = 3; vl [4] = 7;
vl[5] = 2; vl[6] = 37;
cout « "vl = (";
for(int i=O;i<vl.size();i++) cout « vl [i] « " ";
cout « ")" « endl;
cout « "median(vl) = " << median(vl) << endl;
vector<double> v2(6);
v2[0] =3.0; v2[l] =21.9; v2 [2] = 10.1; v2 [3] = 0 . 5 ;
v2[4] = 0.7; v2[5] = 1.0;
cout « "v2 = (";
for(int j=0;j<v2.size();j++) cout « v2[j] « " ";
cout « ")" « endl;
cout « "median(v2) = " « median(v2) « endl;
return 0;
}
Problem 6. Write a C++ program to sort an array of integers using the
quicksort algorithm:
• Split the array into two partitions, all those less than the first element,
and all those greater than the first element.
• Sort the two partitions.
Solution 6. Partition around the first element of the array, any element
could have been used, p is the index of the element around which the
partition is made and pe (declared below) points to the element after the
second partition.
// qsort.cpp
#include <iostream>
#include <string>
using namespace std;
// general definition of ordering R(tl,t2)
// returns > 0 if t2 R tl, <= 0 otherwise
template <class T>

Recursion 155
void partition(T *array,int n.int (*R)(T,T),int &p)
i
int i = n-1, pe = 1;
T t l , t2;
P = 0;
while(i > 0)
{
if(R(array[p].array[pe]) > 0)
{
tl = array[p]; t2 = array[p+1];
array[p++] = array[pe]; // put element in first partition
array[p] = tl; // move element around which partition
// is made, one element right
if(pe-p > 0) 
// if the second partition is not empty
array[pe] = t2; // move second partition one element right
}
pe++;
i—;
}
>
template <class T>
void qsort(T *array,int n.int (*R)(T,T))
{
int pelement;
if(n <= 1) return;
partition(array,n,R,pelement);
qsort(array,pelement,R);
qsort(array+pelement+1,n-pelement-1,R);
}
int less_int(int nl.int n2) { return (nl > n2); }
int less_string(string nl,string n2) { return (nl > n2); }
int main(void)
{
int testl[9] = { 1,5,3,7,2,9,4,6,8 };
qsort<int>(testl,9,less_int);
for(int i=0;i<9;i++) cout « testl[i] « " ";
cout << endl;
string test2[4] = {_ "orange" , "grape", "apple" , "banana" };
qsort<string>(test2,4,less_string);
for(int j=0;j<4;j++) cout « test2[j] « " ";

156 
Problems and Solutions
cout « endl;
return 0;
}
The output of the program is
1
2
3
4
5
6
7
8
9
apple banana grape 
orange
Problem 7. We have a two-dimensional grid of cells, each of which may
be empty or filled. If the cell is empty we associate it with a 0 and if the
cell is filled we associate it with a 1. Any group of cells which are connected
horizontally, vertically, or diagonally constitutes a blob. We may imagine
that the cells have been created by scanning a microscope slide of a bacterial
culture, and that the purpose is to estimate the degree of infection. The
figure shows an example. Write a Java program using recursion that accepts
the coordinates of a cell, and returns the number of cells in the blob that
contains the cell. The result is zero if the designated cell is empty.
Y 
^^J
0 
1 2 
3 
4 5
X
Solution 7. We using eight recursive calls since there are eight neighbors
of a given cell. This includes the diagonal cells.
/ / Blob.Java
public class Blob
{
public static int cc(int x.int y,int[][] grid,
int maxX,int maxY)
{
int sum = 0;

Recursion 157
if((x < 0) II (x >= maxX) II (y < 0) II (y >= maxY))
return 0;
if(grid[x][y] == 0) return 0;
else
{
grid[x][y] = 0;
sum = 1 + cc(x-l,y-l,grid,maxX,maxY)
+ cc(x-l,y,grid,maxX,maxY)
+ cc(x-l,y+l,grid,maxX,maxY)
+ cc(x,y+l,grid,maxX,maxY)
+ cc(x+l,y+l,grid,maxX,maxY)
+ ccCx+l.y.grid^axX.maxY)
+ cc(x+l,y-l,grid,maxX,maxY)
+ cc(x,y-l,grid,maxX,maxY);
}
return sum;
}
public static void main(String[] args)
{
int maxX = 6;
int maxY = 6;
int[][] grid = new int[maxX][maxY];
for(int i=0;i<maxX;i++)
for(int j=0;j<maxY;j++)
grid[i][j] = 0;
grid[0][3] = 1;
grid[l][0] = grid[l][2] = grid[l][3] = grid[1] [4] = 1;
grid [2] [5] = 1;
grid[4][0] = grid[4][l] = grid[4] [3] = grid[4] [4] = 1;
grid [5] [4] = grid [5] [5] = 1 ;
int resultl = cc(l,3,grid,maxX,maxY);
System.out.println("resultl = " + resultl);
int result2 = cc(l,O,grid,maxX,maxY);
System.out.println("result2 = " + result2);
int result3 = cc(5,5,grid,maxX,maxY);
System.out.println("result3 = " + result3);
int result4 = cc(2,3,grid)maxX,maxY);
System.out.println("result4 = " + result4);
}
}

158 Problems and Solutions
Problem 8. The Jacobi elliptic functions can be defined as the inverse
of the elliptic integral of first kind. Thus, if we write
/"* 
ds
* ( * . * ) = / 
7 i , 2 . 2 
(1)
Jo v 1 — K sin s
where fc e [0,1] we then define the following functions
sn(x,k) := sin(<fr), 
cn(x,k) := cos((p), 
dn(x, k) := y 1 - A;2 sin2 <j).
(2)
For k = 0 we obtain
sn(x,0) = sin(x), 
cn(x,0) = cos(x), 
dn(x,0) = l 
(3)
and for k = 1 we have
2
sn(x, 1) = tanh(x), 
cn(x, 1) = dn(x, 1) = 
—-. 
(4)
We have the following identities
2sn(x/2, fc)cn(x/2, fc)dn(x/2, k)
S n ( X ' k ) = 
l-kHn\x/2,k)
,^_l- 
2sn2(x/2, k) + fc2sn4(x/2, k)
C n ( X' k] = 
l-k^n\x/2,k)
, . , _ ! - 2fc2sn2(x/2, k) + fc2sn4(x/2, k)
dn^k>= 
l-fc2sn4(x/2,fc) 
' 
( 5 )
The expansions of the Jacobi elliptic functions in powers of x up to order
3 are given by
x3
sn(x,fc)=x- (1 + fc2)-^- + •••
x2
cn(x, fc) = 1 - — + •••
dn(x,/c) = l - f c 2 | [ + --- 
(6)
For x sufficiently small this will be a good approximation.
(i) Use the identities (5) and the expansions (6) to implement the Jacobi
elliptic functions using one recursive call.
(ii) Write a C++ program.
Solution 8. (i) The recursive call in scdnO uses half of the provided
parameter x, in other words the absolute value of the parameter passed in

Recursion 159
the recursive call is always smaller (by \). This guarantees that for fixed
e > 0 the parameter x will satisfy x < c after a finite number of recursive
calls. At this point a result is returned immediately using the polynomial
approximation (6). This ensures that the algorithm will complete success-
fully. The recursive call is possible due to the identities for the sn, en and
dn functions given in (5). Since the identities depend on all three functions
sn, en and dn we can calculate all three at each step instead of repeating
calculations for each of sn, en and dn. The denominator of all three iden-
tities is the same. All three Jacobi elliptic functions are found with one
function call. The cases k = 0 and k = 1 include the sine, cosine, tanh and
sech functions. For these special cases faster routines are available. Elliptic
functions belong to the class of doubly periodic functions in which 2K plays
a similar role to •K in the theory of circular functions, where K = F(l, k) is
the complete elliptic integral of first kind. We have the identities
sn(x ± 2K, k) = -sn(z, k) 
(7a)
cn(z ± 2K, k) = -cn(ar, k) 
(76)
dn(a; ± 2K, k) = dn(x, k). 
(7c)
To reduce the argument of the Jacobi elliptic functions we can also apply
these identities.
(ii) The recursion method described above can be implemented using C++
as follows.
// jacobi.epp
#include <iostream>
#include <cmath>
using namespace std;
// forward declaration
void scdn(double,double,double,double&,double&,double&);
int main(void)
{
double x, k, k2, eps;
x = 3.0;
cout « "x = " « x « endl;
eps = 0.01;
double resl, res2, res3;
// sin,cos,1 of x
k = 0.0;
k2 = k*k;

160 Problems and Solutions
scdn(x,k2.eps,resI,res2,res3) ;
cout « "sin(x) = " « resl « endl;
cout « "cos(x) = " « res2 « endl;
cout « "l(x) = " « res3 « endl;
// tanh,sech,sech of x
k = 1.0;
k2 = k*k;
scdn(x,k2.eps,resl,res2,res3);
cout « "tanh(x) = " « resl « endl;
cout « "sech(x) = " « res2 « endl;
cout « "sech(x) = " « res3 « endl;
return 0;
}
void scdn(double x,double k2,double eps,double &s,double fee,
double fed)
{
if(fabs(x) < eps)
{
double x2 = x*x/2.0;
s = x*(1.0 - (1.0 + k2)*x2/3.0);
c = 1 . 0 - x 2 ; d = 1 . 0 - k2*x2;
}
else
•C
double sh,ch,dh;
scdn(x/2.0,k2,eps,sh,ch,dh); 
// recursive call
double sh2 = sh*sh;
double sh4 = k2*sh2*sh2;
double denom = 1.0 - sh.4;
s = 2.0*sh*ch*dh/denom;
c = (1.0 - 2.0*sh2+sh4)/denom;
d = (1.0 - 2.0*k2*sh2+sh4)/denom;
}
}
Problem 9. Let n be a given positive integer > 1. Let i = 0,1,..., n — 2
and j = 1,2,..., n - 1 with i < j . Consider the map
/(0,l) = 0, 
/(0,2) = l, 
/(0,3) = 2, .... / ( 0 , n - l ) = n - 2
/(l,2) = n - l , 
/(l,3)=n, 
/(1,4) = n + 1, ..., f(l,n - 1) = 2n - 4
/(2,3) = 2n - 3, ..., f(n-2,n-l) 
= n(n- l)/2.

Recursion 161
Write a recursion using C++ that implements this function.
Solution 9.
// map.cpp
#include <iostream>
using namespace std;
int f(int i.int j,int n)
•C
if ((i==0) && (j==D) return 0;
else if((j > (i+1)) && (i >= 0)) return (f(i,j-l,n)+l);
else if((i > 0) && (j == (i+1))) return (f(i-1,j,n)+n-i-l);
}
int main(void)
{
cout « f(0,l,4) « endl; // => 0
cout « f(0,3,4) « endl; // => 2
cout « f(l,3,4) « endl; // => 4
cout « f(2,3,4) « endl; // => 5
cout « f(3,4,5) « endl; // => 9
cout « f(l,4,5) « endl; // => 6
cout « f(10,11,12) « endl; // => 65
return 0;
}
Problem 10. Let (ao, a\,..., an) be an array representing the coefficients
of the polynomial
p(x) = aoxn + aixn~x -\ 
(- an-ix + an .
We wish to compute p(xo), where XQ £ R. Homer's algorithm is a method
for computing p(xo) using n multiplications and n additions. This method
is based on rewriting the expression of p(x0) as follows
p(x0) = (• • • {(aoxo + ai)x0 + a2)x0 -\ 
1- an_!)xo + an .
Find a recursion relation for this expression.
Solution 10. We can obtain P(XQ) by computing the innermost term
j/i = aoXo + ai, then the next innermost term 1/2 = J/1^0 + a-2, and so on,
until we obtain
P{XQ) =Vn= Vn-lXQ + dn .

162 Problems and Solutions
This method can be expressed by the following linear recurrence
yj=yj-ixo 
+ aj, 
j = 1,2, . . . , n .
This recurrence is a first-order linear recurrence since yj depends only on
Vj-i-
Problem 11. Let n be a positive integer. The Walsh-Hadamard trans-
form of a signal (row vector) x, of size N = 2n, is the matrix-vector product
WVxT, where
n
WN 
= (g) W2 = W2 ® W2 ® • • • <g> W2
j=l
with
«-(! -1)
and <8> denotes the Kronecker product. Let i be an m x n matrix and let
B be a p x q matrix. Then the Kronecker product of A and B is that
(mp) x (nq) matrix defined by
/ anB 
ai2B 
... 
ainB \
a21B 
a22B 
... 
a2nB
A®B:= 
.
\amiB 
am2B 
... 
amnB /
(i) Give a recursive algorithm to calculate Wpj-
(ii) Give an iterative algorithm to calculate W^.
Solution 11. 
(i) A recursive algorithm for calculating W^ is obtained
from the factorization
WJV = ( W 2 ® / 2 - I ) ( / 2 ® W 2 - I )
where I2 is the 2x2 unit matrix and /2™-i is the 2n~1 x 2n~1 unit matrix.
This equation corresponds to the divide and conquer step in a recursive
fast Fourier transform.
(ii) An iterative algorithm for computing WN is obtained from the factor-
ization
n
WN = JJ(/2>-i®W2®J2-i)
3 = 1
which corresponds to an iterative fast Fourier transform.

Recursion 163
More generally, let n = n\ + 712 + • • • + nt, then
N
WN = n(72"i+-+"i-i ®W2ni ®/2"i+i+-+"0-
This factorization encompasses both the iterative and recursive algorithm
and provides a mechanism for exploring different breakdown strategies and
combinations of recursion and iteration.
Problem 12. Given an m x n matrix A with O's and l's, for example
/ I 1 1 0 0 0 1 0\
0 1 1 0 1 1 1 0
0 0 1 1 0 1 0 0
. _ 1 1 0 1 1 1 1 0
0 1 1 0 0 0 1 1
1 1 0 1 1 0 1 1
1 0 1 0 1 0 1 0
\1 0 0 1 0 0 1 1/
where ao,o = 1 and am_iin_i = 1. The matrix represents a maze for the
1 's and O's. The aim is to move from position (0,0) (top left corner) to the
position (m — l,n — 1) (bottom right corner) following the path's of l's.
We can only move to the right, left, down or up, but not diagonal. Write
a Java program using recursion that finds out whether or not there is a
solution and if so provides a solution.
Solution 12. If a path exists, then it is displayed in the output by 5's.
/ / Maze.java
public class Maze
{
public static int[][] A = {{1,1,1,0,0,0,1,0},
{0,1,1,0,1,1,1,0},
{0,0,1,1,0,1,0,0},
{1,1,0,1,1,1,1,0},
{0,1,1,0,0,0,1,1},
{1,1,0,1,1,0,1,1},
{1,0,1,0,1,0,1,0},
{1,0,0,1,0,0,1,1}};
public static void display()
{
for(int r=0;r<A.length;r++)

164 
Problems and Solutions
i
for(int c=0;c<A[r].length;C++)
System.out.print(A [r][c]);
System.out.println();
}
Syst em.out.pr intIn();
} // end display0
public static boolean solve(int r.int c)
{
boolean done = false;
if(valid(r.c) != false)
{
A[r][c] = 3; / / cell has been tried
if(r == A.length-1 && c == A[0].length-1)
done = true; 
/ / maze is solved
else
{
done = solve(r+l,c); / / down
if(done == false) done = solve(r,c+l); // right
if(done == false) done = solve(r-1,c); // up
if(done == false) done = solve(r,c-l); // left
}
if(done != false) A[r][c] = 5;
}
return done;
} // end solve()
public static boolean valid(int r.int c)
{
boolean result = false;
if(r >= 0 && r < A.length && c >= 0 && c < A[0].length)
if(A[r][c] == 1) result = true;
return result;
}
public static void main(String[] args)
{
Maze lab = new MazeO;
lab.display();
if(lab.solve(0,0) != false)
System.out.printlnC'Maze solved");
else System.out.printlnC'no solution");
lab.display();

Recursion 165
}
>
Problem 13. Given an array of sorted elements of data type T. The key
value and the lower and upper index bounds are parameters. Write a C++
program using recursion for a binary search of the array. If the key is not
in the array return —1. Implement the C++ code using templates so that
different data types can be applied, for example the data types double and
string.
Solution 13. We use the string class from C++.
/ / binarysearch.cpp
#include <iostream>
#include <string>
using namespace std;
template <class T>
int binarysearch(T* arr,int low,int high.T key)
{
int mid;
T midvalue;
/ / stopping condition: key not found
if(low > high) return - 1 ;
/ / compare against arrays midpoint and subdivide
/ / if a match does not occur,
/ / apply binary search to the appropiate sublist
else
{
mid = (low + high)/2;
midvalue = arr[mid];
if(key == midvalue)
return mid; // key found at index mid
// look left if key < midvalue; otherwise look right
else if(key < midvalue) // recursive step
return binarysearch(arr,low,mid-1,key);
else return binarysearch(arr,mid+1,high,key);
}
>
int main(void)

166 
Problems and Solutions
•c
int n = 4;
double* arr = new double[n];
arr[0] = 1.1; arr[l] = 3.4; arr[2] = 4.7; arr[3] = 5.9;
int result = binarysearch(arr,0,n-l,3.5);
cout « "result = " « result « endl;
delete [] arr;
string sarr[4] = { "abba", "susi", "willi", "xena" };
string s = "willi";
result = binarysearch(sarr,0,3,s);
cout << "result = " << result;
return 0;
>
Problem 14. We have 50 "gold" coins all of the same weight, except for
one which is fake and weighs less. In other words, we have 49 gold coins of
equal weight and one fake coin of less weight. We also have a balance scale.
Any number of coins can be put on each side of the scale at the same time.
The scale indicates if the two sides weigh the same, or which side is lighter
if this is not the case. Find an algorithm to locate the fake coin using the
balance scale as few times as possible. If there are 2n gold coins one of
which is fake, how many times would the algorithm use the balance scale?
Solution 14. Since we know exactly one coin weighs less than the others
we apply the following strategy. The strategy requires O(logn) iterations
to find the coin (more accurately it requires O(log3 2n) iterations).
1. Divide the coins into 3 piles where 2 of the piles have the same number
of coins and the last pile has at most 2 coins less than the other two.
2. Weigh two of the piles with an equal number of coins.
3. If the two piles are equal in weight, keep the third pile.
4. Otherwise keep the lighter of the two piles.
5. Repeat with the remaining pile until only one coin remains.

Chapter 7
Finite State Machines
Problem 1. A finite state machine is defined as
M = {S, I, O, fs, /o}
where S is a finite set of states, / is a finite set of input symbols (the input
alphabet), O is a finite set of output symbols (the output alphabet), and
fs:SxI-^S, 
fo:S^O.
The function fs is the next-state function. It maps a (state,input) pair to
a state. The state at clock pulse t,+i, state (t,+i), is obtained by applying
the next-state function to the state at time tj, and the input at tj. The
function fo is the output function. When fo is applied to a state at time
tj, we obtain the output at time tj. Consider
S = {so,si,s2}, 
I = { 0 , l } .
Let
/s(so,0) = si, 
/s(so,l) = so
/s(si,0) = s2, 
fs{si,l) = si
fs{S2,0) = S2, 
fs(S2,l) = S0
and
/o(so)=0, 
fo(si) = l, fo(s2) = l.
Write a C++ program to find the states and the output. Consider an input
sequence 01101.
167

168 
Problems and Solutions
Solution 1. We implement the input "01101" as a string. The function
fS() implements fs and the function f0() implements fo-
// 
fsm.cpp
#include <iostream>
#include <string>
using namespace std;
string fS(string s.char c)
{
if((s == "sO") kk (c == '0')) return "si";
if((s == "sO") kk (c == '1')) return "sO";
if((s == "si") && (c == '0')) return "s2";
if((s == "si") kk (c == '1')) return "si";
if((s == "s2") kk (c == '0')) return "s2";
if((s == "s2") kk (c == '1')) return "sO";
}
int fO(string s)
i
if(s == "sO") return 0;
if(s == "si") return 1;
if(s == "s2") return 1;
}
int main(void)
{
string arr = "01101";
string initial = "sO";
int output = fO(initial);
cout « output << endl;
string temp;
for(int j=0;j<arr.length();j++)
{
temp = fS(initial,arr[j]);
cout « temp « " ";
output = fO(temp);
cout << output << endl;
initial = temp;
}
return 0;
}

Finite State Machines 169
Problem 2. A Moore machine is a finite state machine that produces an
output for each state. The output depends only on the present state. Design
a Moore machine which adds two binary numbers of the same length. Give
the design in the form of a state diagram. The state diagram is a directed
graph where each vertex denotes a state (a vertex is drawn as a circle with
the symbol to output on entry to the state, and a - to indicate the initial
state) and edges denote transitions between states and are labelled with
the input symbol which caused the transition.
Solution 2. We use £ := {0,1} and T := {0,1, A}, where S is an alphabet
of possible input symbols and F is an alphabet of possible output symbols.
A is the (null or empty) symbol indicating no output, i.e., we simply ignore
this symbol. For the input string we use (where we read from left to right)
ao60oi6i • • -anbn
where anan_i • • • ao and bnbn_i • • • 6Q are the binary numbers to be added.
The initial state starts with a sum of zero and carry of zero. The upper 4
vertices (states) implement addition when the carry is zero and the lower 4
vertices implement addition when the carry is 1. The upper half is respon-
sible for adding without carry while the lower half is responsible for adding
with carry.
1 
1 
0
X 
o 
i-s
(A), 
TI )
1 
l V
1 
0
A, 
o 
A.
(o). 
( A )
1 
0 
0
Problem 3. A Mealy machine is a finite state machine which produces
an output for each transition. The output depends on the present state and
the present value of the inputs. Design a Mealy machine which adds two

170 Problems and Solutions
binary numbers of the same length. Give the design in the form of a state
diagram. The state diagram is a directed graph where each vertex denotes a
state (a vertex is drawn as a circle with an optional - to indicate the initial
state) and edges denote transitions between states and are labelled with
the input symbol which caused the transition and the symbol to output for
the transition. Describe how to create an equivalent Mealy machine from
a Moore machine.
Solution 3. 
We use E = {0,1} and T = {0,1, A}. A is the symbol
indicating no output, i.e., we simply ignore this symbol. For the input
string we use (where we read from left to right)
aobodibi • • • anbn
where anan-i • • • «o and bnbn-i • • • bo are the binary numbers to be added.
The initial state starts with a sum of zero and carry zero. The upper 4
vertices (states) implement addition when the carry is zero and the lower 4
vertices implement addition when the carry is 1. The upper half is respon-
sible for adding without carry while the lower half is responsible for adding
with carry.
,^ 
(°>
A) ,,^,
(1,A) 
(1,1) 
(0,A)
(1,0) 
(0,A)
^ 
(0.A) 
A
v 
(i,o) Y
(1,A) 
(0,0) 
(0,1)
^ ^ 
(LA) 
^ - ^
Simply move the target symbol onto all incoming edges, i.e., if a transition
to a state with symbol o on reading i then label the transition (i,o).
Problem 4. 
Let S be a finite set of states and F a finite set of tape
symbols (the tape alphabet) including the special symbol A to denote a
blank cell. A Turing machine is a set of quintuples of the form (s, i, i', s',d),

Finite State Machines 171
where s, s' € S, i, i' 6 T, and d e { R, L } (R for right, L for left) and where
no two quintuples begin with the same s and i. Design a Turing machine
which subtracts a two's complement binary number from another of the
same length. Determine the relevant alphabets and a suitable formatting
for the input.
Solution 4. 
We use F := {0,1, A}. 
A is the symbol indicating no
output, i.e., we simply ignore this symbol. For the input string we use
(where we read from left to right) aoboa-ibi • • • &nbn, where anan_i • • • ao
and bnbn-i • • -b0 are the binary numbers to be added. The upper half is
responsible for adding without carry while the lower half is responsible for
adding with carry. We negate 6rabn_i • • • &o by swapping the meaning of 0
and 1 and by starting in the add with carry portion of the machine (i.e., we
negate bnbn-i • • -b0 and increment to obtain the two's complement) while
adding the two numbers.
^A(A,A,R)Q (0'A'R) . Q
^ 
J 
(0,0,R) 
p
(1,A,R) 
(1,1,R) 
(0,A,R)
i ) .
 
(°'
1>R) •r"V
A'
AiRK
>)
Y 
(I,A,R) y 
^-^
(l,0,R) 
(0,A,R)
(i,A,R) 
(o,o,R) 
(o,i,R)
(1,A,R)
Problem 5. 
Design a Mealy machine to represent a vending machine
which provides a carbonated drink for R 2,50. The machine accepts 50c, Rl
and R2 coins. The symbol (number) output by the machine is interpreted
as change (in cents) for the customer. The symbol "C" output by the
machine is interpreted as the output of the carbonated drink. We allow
null output, i.e., output which does not actually appear (empty string).
Thus the output "symbols" we could expect are the strings
"", 
"C", 
"C50", 
"C100", 
"C150" .

172 
Problems and Solutions
Write a C++ and Java program to simulate the machine we have designed.
Solution 5. 
We use the states to indicate how many 50c the vending
machine has received. In other words 50 represents 0c, 550 represents 50c
and so on. The following transition table describes the machine.
State 
Input 
Output 
Next State
50- 
50c 
550
50- 
Rl 
5100
50- 
R2 
5200
550 
50c 
5100
550 
Rl 
5150
550 
R2 
C 
50
5100 
50c 
5150
5100 
Rl 
5200
5100 
R2 
C50 
50
5150 
50c 
5200
5150 
Rl 
C 
50
5150 
R2 
C100 
50
5200 
50c 
C 
50
5200 
Rl 
C50 
50
5200 I R2 1 C150 | 
50
The following C++ program implements this finite state machine.
// 
machine.cpp
#include <iostream>
using namespace std;
struct transition { char *state, *input, *output, *nextstate; };
transition transitions[] = {
{"SO" 
,"50c" ,"" 
,"S50" },{"S0" 
,"R1" ,"" 
,"S100"},
{"SO" 
,"R2" ,"" 
,"S200"},{"S50" ,"50c" ,"" 
,"S100">,
{"S50" ,"R1" ,"" 
,"S150"},{"S50" ,"R2" ,"C" ,"S0" },
{"S100" ,"50c" ,"" 
,"S150"},{"S100" ,"R1" ,"" 
,"S200"},
{"S100" ,"R2" ,"C50" ,"S0" },{"S150" ,"50c" ,"" 
,"S200"},
{"S150" ,"R1" ,"C" ,"S0" },{"S150" ,"R2" ,"C100","SO" },
{"S200" ,"50c" ,"C" ,"S0" },{"S200" ,"R1" ,"C50" ,"S0" },
{"S200" ,"R2" ,"C150","S0" },{ NULL, NULL, NULL, NULL }>;

Finite State Machines 173
char *output[][2] = {
/ • „ „ 
in,••
{"C"."Machine produces a can\n"},
{"C50","Machine produces a can and 50 cents change\n"},
{"C100","Machine produces a can and Rl change\n"},
{"C150","Machine produces a can and R1.50 change\n"},
{NULL, NULL}};
int main(void)
{
char *state = transitions[0].state;
char input[32];
int i, j;
cout « "Input a 50c, Rl or R2 coin in the machine"
« endl;
cin.getline(input,32,'\nJ);
for(i=0;transitions[i].state!=NULL;)
{
if(strcmp(state,transitions[i].state)
II strcmp(input.transitions[i].input)) i++;
else
{
for(j=0;output[j][0]!=NULL;j++)
if(strcmp(transitions[i].output.output[j][0])==0)
cout « output[j] [1];
state = transitions[i].nextstate;
i = 0;
cout « "Input a 50c, Rl or R2 coin in the machine"
« endl;
cin.getline(input,32,'\n');
}
}
cout « "Machine fails invalid coin inserted"
« endl;
return 0;
}
The following Java program implements this finite state machine
/ / Machine.j ava
import java.io.*;

174 
Problems and Solutions
public class Machine
-C
static transition trans[] =
{ new transition("S0","50c","","S50"),
new transitionO'SO","Rl","","S100"),
new transitionO'SO","R2","","S200"),
new transition("S50","50c","","S100"),
new transition("S50","Rl","","S150"),
new transition("S50","R2","C","SO"),
new transitionC'SlOO","50c","","S150"),
new transitionC'SlOO","Rl","","S200") ,
new transitionC'SlOO","R2","C50","SO") ,
new transition("S150","50c","","S200"),
new transition("S150","Rl","C","SO"),
new transition("S150","R2","C100","SO"),
new transition("S200","50c","C","SO"),
new transition("S200","Rl","C50","SO"),
new transition("S200","R2","C150","SO"),
new transition(null,null,null.null)>;
static String output [] [] =
{ {"",""},
{"C","Machine produces a can\n"},
{"C50","Machine produces a can and 50 cents change\n">,
{"C100","Machine produces a can and Rl change\n"},
{"C150","Machine produces a can and R1.50 change\n"},
{null,null} };
public static void main(String args[]) throws IOException
{
String state = trans[0].state;
String input = "";
int i = 0, j = 0;
BufferedReader kbd =
new BufferedReader(new InputStreamReader(System.in));
System.out.printlnCInput a 50c, Rl or R2 coin");
input = kbd.readLineO;
for(i=0;Ktrans.length;)
{
if(!((state.equals(trans[i].state)) &&
(input.equals(trans[i] .input))))
{ i++; }

Finite State Machines 175
else
{
for(j=0;output[j][O] !=null;j++)
{
if (trains [i] . output. equals (output [ j] [0] ) )
{
System.out.printIn(output[j][1]);
>
state = trans[i].nextstate;
}
i = 0;
System.out.printIn("Input a 50c, Rl or R2 coin");
input = kbd.readLine0;
}
}
System.out.printIn("Machine fails invalid coin inserted");
}
>
class transition
-C
String state, input, output, nextstate;
public transition(String st,String in,String out,String ne)
•C
state = st; input = in; output = out; nextstate = ne;
>
>
Problem 6. A regular expression is a sequence of symbols that matches
words (or strings). A regular expression may match more than one word.
Thus regular expressions can describe a language, i.e., words that can be
recognized. The rules for matching regular expressions are as follows.
Symbol: For each symbol a in the alphabet, the regular expression
a matches a.
Alternation: Let M and TV be regular expressions. M\N is a regular
expression that matches a string if M matches the string or JV matches
the string. Here I is the special symbol denoting alternation.
Concatenation: Let M and N be regular expressions. Then M • N
is a regular expression that matches a string a/3 if M matches a and
TV matches (3 for some strings a, /3. Here • is the special symbol
denoting concatenation.
Epsilon: The regular expression e matches the empty string.

176 Problems and Solutions
Repetition: The Kleene closure of a regular expression M, M*,
is a regular expression which matches a concatenation of 0 or more
strings, where each string is matched by M.
Kleene closure binds tighter than concatentation, and concatenation binds
tighter than alternation. Parenthesis may be used to indicate the order in
which the operators should be applied. We use the following shorthand to
simplify regular expressions:
• a+:=aa*
• a?:= (a|e)
• [aia2a3 ...an] := ai\a2\ • • • \an
• [a-z]:=[abc. ..z], 
[0-9]:=[0123456789]
• . matches any symbol.
• \a matches a.
Regular expressions can be transformed into deterministic finite automata
(and automatically). Write regular expressions and give the corresponding
finite automata for the following:
(i) Positive real numbers of the form a.b where a and b are positive integers.
Examples include 1.0 000.000 090.050. The integer must have at least
one digit, and may have preceding zeros.
(ii) Functions of the form /(a) where a is an integer, and / is a series of
alphanumerical characters. / must consist of at least one character, and a
is of the same form as in (i).
Solution 6. (i) We have [0-9] +\. [0-9] +
0-9 
V 
0-9
0 - 9 
0 - 9
(ii) We have [a-z] +\ ([0-9] +\)
a-z 
( 
0-9 
)
a-z 
0-9

Chapter 8
Lists, Trees and Queues
Problem 1. Consider the eight puzzle depicted in the figure below. This
is a familiar game with eight tiles arranged in a 3-by-3 configuration with
one open square. Tiles can be moved up, down, left or right into the
open square, creating a new open square in the space that is vacated. The
problem is to find a sequence of moves that convert the initial scrambled
configuration of tiles into a goal configuration in which the tiles are arranged
in numerical order. The brute force method would be to use trees to obtain
all possible configurations.
6 1 1 I 2
_5 8 7_
4 | 3 I
initial configuration
1 I 2 I 3
_8 
4_
7 I 6 I 5
goal configuration
177

178 Problems and Solutions
8 I 1 I 2
_5 
6 7_
4 [ 3 |
8 I 1 I 2 1 
I 8 I 1 I 2
J L J L ~ 
~5 6~T"
4 I 3 I 7 I 
| 4 | I 3~
Write a C++ program which finds the solution by expanding the tree.
Solution 1. We provide two possible solutions.
/ / tilel.cpp
#include <iostream>
using namespace std;
char goal [3] [3] = {{'1','2',>3'},{'8>,' ' , ' 4 ' } , { ' 7 \ ' 6 \ ' 5 ' } } ;
struct treenode
•C
char b [3] [3] ;
int value; // integer value representing puzzle configuration
struct treenode *left, *right;
} *treeroot = NULL;
int puzzlevalue(char b[3][3])
{
int k = 1;
int value = 0;
for(int i=0;i<3;i++)
for(int j=0;j<3;j++)
{
if(b[i][j]! = ' ') value += k*(b[i][j]-'O');

Lists, Trees and Queues 179
k *= 10;
}
return value;
}
void newnode(struct treenode *&t,char b[3][3],int value)
{
t = new struct treenode;
t -> left = t -> right = NULL;
for(int i=0;i<3;i++)
for (int j=0;j<3;j++) t -> b[i] [j] = b[i][j];
t -> value = value;
}
int addnode(struct treenode *&t,char b[3][3],int value)
•C
if(t == NULL) { newnode(t,b,value); return 1; }
if(value < t->value) return addnode(t->left,b,value);
if(value > t->value) return addnode(t->right,b,value);
return 0;
>
void swap(char fca.char &b) { a~=b; b~=a; a~=b; >
void print(char b[3][3])
{
for(int i=0;i<3;i++)
{
for(int j=0;j<3;j++) cout « b[i][j] « " ";
cout << endl;
>
cout << endl;
>
int eight(char b[3][3],int x.int y)
{
int i , j , g = 0;
for(i=0;i<3;i++)
for(j=0;j<3;j++)
if (b[i] [j] ==goal [i] [j]) g++;
if(g==9) { print(b); return 1; }
if(x > 0)
{
swap(b[x][y],b[x-l][y]); g=0;

180 
Problems and Solutions
if(addnode(treeroot,b,puzzlevalue(b))) g = eight(b,x-1,y);
swap(b[x][y],b[x-l][y]);
if(g) { print(b); return 1; }
}
if(y > 0)
{
swap(b[x][y],b[x][y-l]); g=0;
if(addnode(treeroot,b,puzzlevalue(b))) g = eight(b,x,y-l);
swap(b[x][y],b[x][y-l]);
if(g) { print(b); return 1; }
}
if(x<2)
{
swap(b[x] [y] ,b[x+l] [y] ) ; g = 0;
if(addnode(treeroot,b,puzzlevalue(b))) g = eight(b,x+l,y);
swap(b[x][y],b[x+l][y]);
if(g) { print(b); return 1; }
}
if(y < 2)
{
swap(b[x][y],b[x][y+l]); g = 0;
if(addnode(treeroot,b,puzzlevalue(b))) g = eight(b,x,y+1);
swap(b[x][y],b[x][y+l]);
if(g) { print(b); return 1; }
>
return 0;
}
int main(void)
{
char b[3][3] = {{'6','1\'2'},-('5\'8', J7'},{'4\ J 3 \ ' '}};
if(eight(b,2,2)) cout « "The puzzle is solved" « endl;
else cout << "The puzzle could not be solved" << endl;
return 0;
}
A shorter solution is given by
// tile2.cpp
#include <iostream>
using namespace std;

Lists, Trees and Queues 181
void displaytiles(int level,int* tiles)
{
cout « "\nLevel " « level « endl;
for(int i=0;i<9;i++)
{
if(i'/,3 == 0) cout « endl;
cout « tiles [i] « " ";
}
cout << endl;
}
void swap(int *il,int *i2)
{ int temp = *il; *il = *i2; *i2 = temp; }
void nextnode(int *tiles,int open,int level,int max)
{
int row = open/3; int col = open°/,3;
int *o = tiles + open;
displaytiles(level,tiles);
if(level >= max) return;
level++;
if(row > 0)
{
swap(o,o-3);
nextnode(tiles,open-3,level,max);
swap(o,o-3);
>
if (row < 2)
{
swap(o,o+3);
nextnode(tiles,open+3,level,max);
swap(o,o+3);
>
if(col > 0)
{
swap(o,o-l);
nextnode(tiles,open-1,level,max);
swap(o,o-l);
>
if(col < 2)
{
swap(o,o+l);
nextnode(tiles,open+1,level,max);
swap(o,o+l);

182 Problems and Solutions
}
>
int main(void)
{
int tiles[9];
int open, maxlevel;
cout « "\nEnter a pattern: \n";
for(int i=0;i<9;i++)
{
cin » tiles[i];
if(tiles[i]==0) open = i;
}
cout « "\n\nHow many levels? \n";
cin >> maxlevel;
nextnode(tiles,open,0.maxlevel);
return 0;
>
Problem 2. 
An intrusive linked list is a linked list where the data is
aware of the list structure. Thus the data in the intrusive linked list are
actually the linked list nodes. Implement a heterogeneous intrusive linked
list which can accept nodes of any type for insertion into the list. Thus
it is necessary to define a node. Consequently, we have a more general
implementation than that of a homogeneous intrusive linked list where all
the nodes are of the same type.
Solution 2. 
The class List must be a friend to use the functions
insertafterO and insertbef ore().
// intrusive.cpp
#include <iostream>
#include <string>
#include <cassert>
using namespace std;
// Node in a circular linked list
class Node
{
public:
Node(void);
Node *next(void);

Lists, Trees and Queues 183
Node *previous(void);
int operator == (Nodefe);
int operator != (Nodefe);
virtual void display(ostreamfe);
protected:
void insertafter(Nodefe);
void insertbefore(Nodefe);
void remove(void);
private:
Node *nextnode;
Node *prevnode;
// forward declaration of class List
friend class List;
>;
Node::Node(void) { nextnode = prevnode = this; }
Node *Node::next(void)
{ assert(nextnode != NULL); return nextnode; }
Node *Node::previous(void)
{ assert(prevnode != NULL); return prevnode; }
void Node::insertafter(Node &n)
•C
assert(nextnode != NULL);
assert(prevnode != NULL);
n.nextnode = nextnode;
n.prevnode = this;
nextnode = nextnode -> prevnode = &n;
}
void Node::insertbefore(Node &n)
•c
assert(nextnode != NULL);
assert(prevnode != NULL);
n.nextnode = this;
n.prevnode = prevnode;
prevnode = prevnode -> nextnode = &n;
>
void Node::remove()
{
assert(nextnode != NULL && nextnode != this);

184 Problems and Solutions
assert(prevnode != NULL && prevnode != this);
prevnode->nextnode = nextnode;
nextnode->prevnode = prevnode;
}
int Node::operator == (Node &n)
{ return &n == this; }
int Node::operator != (Node &n)
{ return &n != this; }
void Node::display(ostream feout)
{ out « "(Node " « this « 
" ) " ; }
// define a list node for storing arbitrary data
template <class T>
class DataNode : public Node
{
public:
DataNode(T);
virtual void display(ostreamfc);
private:
T data;
};
template <class T>
DataNode<T>::DataNode(T t) : data(t) {}
template <class T>
void DataNode<T>::display(ostream feout) { cout « data; }
// define a list class to denote the first node
// in the circular linked list
class List : public Node
{
public:
void insertafter(Node&,Node&);
void insertbefore(Node&,Node &);
void remove(Nodefe);
virtual void display(ostreamfe);
};
void List::insertafter(Node& nl.Nodefe n2)
{

Lists, Trees and Queues 185
Node *n = next();
while(*n != *this)
•C
if(*n == n2)
•C
cerr << "Cannot duplicate a list node, "
<< "nodes should be unique." << endl;
assert(*n != n2);
}
n = n -> next();
}
nl.insertafter(n2);
}
void List::insertbefore(Node ftnl.Node &n2)
{
Node *n = nextO ;
while(*n != *this)
{
if(*n == n2)
{
cerr << "Cannot duplicate a list node, "
<< "nodes should be unique." << endl;
assert(*n != n2);
}
n = n -> nextO ;
}
nl.insertbefore(n2);
}
void List:: remove (Node &n) { n.removeO; }
void List::display(ostream Stout)
{
Node *n = nextO ;
cout « "List-I" « endl;
while(*n != *this)
-C
cout « " 
I-> ";
n -> display(out);
cout << endl;
n = n -> nextO ;
>
>

186 
Problems and Solutions
ostreamfe operator « (ostreamfe out.Listfe 1)
{ 1.display(out); return out; }
int main(void)
{
DataNode<int> nl(l), n2(2), n3(3), n4(4), n5(5);
DataNode<double> pi(3.14159265), e(2.7182818);
DataNode<string> scientificC'scientific");
DataNode<string> computingC'computing");
List list;
list.insertafter(list.nl);
cout « list;
list.insertafter(nl,n2);
list.insertafter(n2,n3);
list.insertafter(n3,n4);
list.insertafter(n4,n5);
cout << list;
list.insertafter(n2,pi);
list.insertbefore(n4,e);
cout « list;
list. insertafter(pi,scientific);
list.insertbefore(e,computing) ;
cout « list;
list.remove(n3);
list.remove(e);
list.remove(nl);
cout « list;
return 0;
}
Problem 3. 
Consider the following problem. A deranged king has de-
cided to choose his successor in a most brutal way. He directs his m knights
to sit at his round table. Then he numbers them 1, 2,3,..., m clockwise. The
king then chooses a cycle number, k, and starting with the first knight,
counts off 1,2,3, ...,k. The k-th knight is carried off and summarily ex-
ecuted, and the count-off by k continues with the next surviving knight.
The process goes on until there is but one survivor. He is the heir to the
throne. For example, let m = 7 (the number of knights) and k •= 3. Then
the survivor would be knight number 4. This problem can be formulated
as a singly linked circular list. Write a C++ program to solve the problem.

Lists, Trees and Queues 187
Solution 3.
/ / king.cpp
#include <iostream>
using namespace std;
class Knight
{
public:
int number;
Knight* next;
>;
int S(int m,int k)
{
Knight* first = NULL;
Knight* current = NULL;
Knight* ptr = NULL;
for(int i=0;i<m;i++)
{
ptr = new Knight;
if(first == NULL)
{
first = ptr; current = ptr;
current -> number = i + 1;
>
else {
current -> next = ptr;
current = ptr;
current -> number = i + 1;
}
}
current -> next = first;
current = first;
Knight* prevKnight;
prevKnight = NULL;
while(current -> next != current)
{
for(int cnt = O;cnt<k-l;cnt++)
{
prevKnight = current;
current = current -> next;

188 Problems and Solutions
}
prevKnight -> next = current -> next;
delete current;
current = prevKnight -> next;
>
return current -> number;
}
int main(void)
{
int m, k, t;
cout « "enter number of knights: ";
cin >> m;
cout « endl « "enter cycle number: ";
cin » k;
cout « endl « endl;
cout « "the survivor is knight number: " << S(m,k);
cout « endl;
return 0;
}
Problem 4. The generalized linked list (i.e., a list which also allows lists
as elements) is the basic abstract data type of some languages. The best
known example is the language LISP, which stands for LIST PROCESS-
ING. For example
(A ((B C) D) E (F G))
has four items: the first item is A; the second is a sublist made up of the
sublist (B C) and D; the third is E; and the fourth is the sublist (F G). The
generalized list has proved to be such a useful data structure that it has
been made the basis of a powerful language called LISP. Build a storage
structure in C and C++ to hold a linked list with sublists. At each link we
have two pointers to Node.
Solution 4. 
Some of these nodes look quite conventional: the left part
has some literal value, A, B, C, and so forth (called an atom in LISP), and
the right part contains a pointer. However, other nodes consists of two
pointers. The center field of the node is either a character or a nodepointer
(clink is short for center link). The function we need to make generalized
lists is cons(), which constructs a list by adding a new first element to (a
copy of) an old one. A list can be started by using consO to prefix an
atom to NULL, the empty list. The function consO needs two arguments:

Lists, Trees and Queues 
189
the first item to be added to the list, and a pointer to that list. Since the
first argument (the new first item) can be either an atom or a list, we do not
know what type to put in the function heading. Thus we need two cons()
functions, the one is used when the first node is an atom, and the other
one when it is a pointer to a list. Besides class Node, the program also
introduces class List. The functions cons(), carO, cdr() and copyO
are member functions of class List.
// lisp.cpp
#include <iostream>
using namespace std;
class Node
{
public:
NodeO;
Node(const Nodefe);
"NodeO;
int atom;
char info;
Node* next;
Node* clink;
>;
class List
{
private:
Node* head;
public:
ListO; 
// Constructor
List(const Listfe); 
// Copy constructor
~List(); 
// Destructor
Listfc operator = (const Listfe); // overloading =
Node* copy(Node*);
List cons(char,Listfe);
List cons(List&,List&);
List car(List&);
List cdr(Listfe);
void printNode(Node*);
void printList();
void release(Node*);
>;

190 Problems and Solutions
Node::Node() { atom = 1; info = '\0'; next = clink = NULL; }
Node::"Node() { }
Node::Node(const Node& nd)
{
atom = nd.atom;
info = nd.info;
next = nd.next;
clink = nd.clink;
>
List::List() { head = NULL; }
List::List(const Listfe larg)
{
if(larg.head == NULL) head = NULL;
else head = copy(larg.head);
>
List::~List()
•C
if(head) { release(head); }
delete head;
}
Listfe List::operator = (const Listfe larg)
{
if(larg.head == NULL) head = NULL;
else head = copy(larg.head);
return *this;
}
Node* List::copy(Node* narg)
{
Node* res = new Node;
if(narg != NULL)
{
res->atom = narg->atom;
if(res->atom)
{
res->info = narg->info;
res->clink = NULL;
}

Lists, Trees and Queues 191
else res->clink = copy(narg -> clink);
res->next = copy(narg -> next);
}
else res = NULL;
return res;
>
List List:icons(char newatom,List& oldlist)
{
List res(oldlist);
Node* newNode;
newNode = new Node;
newNode -> atom = 1;
newNode -> info = newatom;
newNode -> clink = NULL;
newNode -> next = res.head;
res.head = newNode;
return res;
}
List List::cons(Listfe newList.Listft oldList)
{
List res(oldList);
Node* newNode;
newNode = new Node;
newNode -> atom = 0 ;
newNode -> clink = copy(newList.head);
newNode -> next = res.head;
res.head = newNode;
return res;
}
List List::car(Listfe oldList)
{
List res(oldList);
List empty;
List carList;
if(res.head -> clink == NULL)
carList=cons(res.head->info,empty);
else carList.head = copy(res.head->clink);
return carList;
>
List List::cdr(List& oldList)

192 
Problems and Solutions
•C
List res(oldList);
res.head = res.head->next;
return res;
}
void List::printNode(Node* narg)
i
Node* tmp;
tmp = copy(narg);
cout « "(";
while(tmp != NULL)
•C
if(tmp->atom) cout << tmp->info << " ";
else printNode(tmp->clink);
tmp = tmp->next;
>
cout « 
" ) " ;
}
void List::printList() { printNode(head); }
void List::release(Node* ptr)
{
Node* tmp;
{
if((tmp = ptr -> next) != NULL)
{
release(tmp); delete tmp;
tmp = NULL;
>
if((tmp = ptr -> clink) != NULL)
{
release(tmp); delete tmp;
tmp = NULL;
}
>
>
int main(void)
{
List empty;
List L;
L = L.cons('G',empty);

Lists, Trees and Queues 193
cout « "L = ";
L.printListO ;
cout « endl;
List M;
M = M.cons('E',M.cons(L,empty));
cout « "M = ";
M.printListO ;
cout << endl;
List N;
N = N.cons(N.cons('B',N.cons('C.empty)),N.cons('D'.empty));
cout « "N = ";
N.printListO ;
cout << endl;
List Z;
Z = Z.consCl' ,Z.cons(Z.cons('2' ,Z.cons('7' , empty)),
Z.cons('5',empty)));
cout « "Z = ";
Z.printListO ;
cout << endl;
List Zcar = Z.car(Z);
cout « "car (Z) = ";
Z.printListO ;
return 0;
}
Problem 5. Consider the producer-consumer problem. A number of pro-
ducers create objects which are used by consumers. All the objects are
stored in the same place until they are needed. If the storage place is full,
a producer must wait until there is place. Similarly, if a consumer requires
an object and the storage place is empty, the consumer must wait until a
producer places an object in the storage place. A data structure for this
task is a queue. A queue is a first in first out structure. Data can only be
added to the back of queue, and removed only from the front of the queue.
(i) Implement a queue data type for Java.
(ii) Implement a producer and consumer using the Thread class of Java and
the Queue class.. Use synchronized methods and the methods
public final void waitO throws InterruptedException
public final void notifyO
public final void notifyAllO
to ensure that the queue works correctly in a multi-threaded environment.
The method waitO causes a thread to wait on the associated object. Simi-

194 
Problems and Solutions
larly the methods notif y() and notif yAllO notify a thread or all threads
respectively, which are waiting on the associated object, to resume execu-
tion.
Solution 5. (i) The Queue class is given by
// Queue.Java
import Java.lang.Exception;
class QueueElement
{
private Object o;
private QueueElement n;
private boolean nvalid=false;
public QueueElement(Object ob) { o=ob; }
public QueueElement next() throws Exception
{
if(nvalid) return n;
else throw(new Exception("No next element"));
>
public void setnext(QueueElement nx) { n=nx; nvalid=true; }
public void unsetnextO { nvalid=false; }
public Object dataO { return o; }
}
public class Queue
{
private QueueElement front;
private QueueElement back;
private int size=0;
private int maxsize=0;
public Queue(int n) {maxsize=n;}
public synchronized void add(Object o) throws Exception
{
while((size>=maxsize) && (maxsize>0)) this.waitO;
if(size==0) { front=back=new QueueElement(o); size++; }
else
{
back.setnext(new QueueElement(o));
back=back.next();
size++;
}
this.notify();

Lists, Trees and Queues 195
}
public synchronized Object removeO throws Exception
{
while(size==0) this.waitO;
if(size==0) throw(new ExceptionCQueue is empty."));
Object r=front.data();
if(size>l) front=front.next();
size—;
this.notifyO ;
return r;
}
public int SizeQ { return size; }
>
(ii) The Producer and Consumer classes are given by
// Producer.java
import Java.lang.Exception;
public class Producer extends Thread
{
String s;
Queue q;
public Producer(String s,Queue q) { this.s=s; this.q=q; }
public void run()
{
for(int i=0;i<10;i++)
{.
String p=s+" "+Integer.toString(i);
try { q.add(p); }
catch(Exception e) { System.out.println(e.getMessageO); }
}
>
}
// Consumer.java
import Java.lang.Exception;
public class Consumer extends Thread

196 
Problems and Solutions
•C
String s;
Queue q;
public Consumer(String s,Queue q) { this.s=s; this.q=q; }
public void run()
{
while(true)
{
try
{
String c = s + " " + (String) q.removeO;
System.out.println(c);
} catch(Exception e) { System.out.println(e.getMessage()); }
}
}
}
The program PCMain. j ava uses these classes.
// PCMain.Java
import Java.lang.Exception;
public class PCMain
{
public static void main(String[] args)
{
Queue q = new Queue(3);
Producer pi = new Producer("pi",q);
Producer p2 = new Producer(np2",q);
Producer p3 = new Producer("p3",q);
Producer p4 = new Producer("p4",q);
Producer p5 = new Producer("p5",q);
Consumer cl = new Consumer("cl",q);
Consumer c2 = new Consumer("c2",q);
pi.start(); p2.start(); p3.start();
p4.start(); p5.start();
cl.start(); c2.start();
}
}

Lists, Trees and Queues 197
Problem 6. 
The standard template library of C++ does not provide
any template with Tree in their name. However, some of its containers
— the set<T>. map<T>, multiset<T>, and multimap<T> templates — are
generally built using a special kind of self-balancing binary search tree called
a red-black tree. A self-balancing binary search tree ensures that the tree
is always as balanced as possible, so that searches take O(log2 n) time. A
sparse matrix is a matrix with a large number of zero entries, which makes it
worthwhile for storage to exploit the presence of these zeros by not storing
them. Consider the following data structure for an n x n sparse matrix
M with double components map<pair<int, int>, double> M;. Implement
the matrix
/2.2 
0 
1.7\
M = 
0 
0 
0
\ 0 
2.3 0 /
using this data structure.
Solution 6.
// MapPair.cpp
#include <iostream>
#include <map>
using namespace std;
int main(void)
{
pair<int,int> iOO(0,0);
pair<pair<int,int>,double> v00(i00,2.2);
map<pair<int,int>,double> M;
M.insert(vOO);
cout « M[i00] « endl;
pair<int,int> i02(0,2);
pair<pair<int,int>,double> vO2(iO2,1.7);
M.insert(vO2);
cout « M[iO2] « endl;
pair<int,int> i21(2,l);
pair<pair<int,int>,double> v21(i21,2.3);
M.insert(v21);
cout « M[i21] « endl;
double r = M[i00] *M[i21] ;
cout « "r = " « r « endl;
return 0;
>

198 Problems and Solutions
Problem 7. The standard least recently used algorithm {LRU algorithm)
keeps in the cache the data that has been used most recently, on the assump-
tion that future accesses will mirror past accesses. Write a C++ program
that implements the LRU algorithm using the list class of the standard
template library and the string class.
Solution 7. We keep m = 3 strings in the cache.
// LRUAlg.cpp
#include <iostream>
#include <string>
#include <list>
#include <algorithm>
using namespace std;
template <typename T> list<T>& LRU(const T& d)
{
static int m = 3;
static list<T> li;
list<T>::iterator ptr = find(li.begin(),li.end(),d);
if(ptr != li.endO) li. erase (ptr);
else if(li.size() == m) li.pop_back();
li.push_front(d);
return li;
>
int main(void)
i
while(true) {
string d;
cin >> d;
list<string>& li = LRU(d);
list<string>::iterator itr;
for(itr=li.begin();itr!=li.end();itr++)
cout « *itr « " ";
cout « endl;
}
return 0;
}

Chapter 9
Numerical Techniques
Problem 1. A polynomial of the form
p(x) = o0 + a\X + aix2 + • • • + anxn
can be evaluated efficiently using Homer's rule. This rule avoids explicit
computation of the x* terms as follows
p{x) - a0 + z(ai + x(a2 +x(... 
{an-i + 
xan)...))).
Complete the definition of the recursive method homer () in a Java pro-
gram with header
public static double homer (double [] a,double x,int i)
where the first parameter is an array of coefficients of the polynomial, the
second is the value of x at which the polynomial is to be evaluated and
int i is a marker we use to keep track of the recursion.
Solution 1. The command a. length finds the length of the array a.
// Homer.Java
import java.io.*;
public class Homer
•C
public static double homer (double [] a, double x.int i)
199

200 Problems and Solutions
{
final int m = a.length-1;
if(i == m) return a[m];
else return a[i] + x*horner(a,x,i+l);
}
public static void main(String[] args)
{
int d = 3;
double[] a = new double[d];
a[0] = 2.0; a[l] = 3.0; a[2] = 5.0;
double x = 1.5;
int i = 0;
double result = horner(a,x,i);
System.out.printlnCresult = " + result);
}
}
Problem 2. 
Suppose we have n measured values that are Cartesian
coordinates of the form (XJ, yj) (j = 0,1,..., n — 1) to which we would like
to fit a straight line of the form
y(x) = a + bx
where the coefficients a and b are parameters. The values of these param-
eters are to be determined by the least-square method that minimizes the
sum of the squares of the difference between the computed values and the
measured values; i.e., it minimizes the function
n-l 
n-1
f(a, b) = Y,(v(xi) - vi? = E ( a + b x i - ytf
with respect to the coefficients a and b.
(i) Find the equations for a and b.
(ii) Give a C++ implementation. Recall that both the equations for a and
b include the summation over Xj and yj.
Solution 2. (i) Differentiating the function / with respect to a and b and
setting the derivative equal to zero yields
f£=0=>r£i(a 
+ bxJ-yj)=0 
(1)
j=0

Numerical Techniques 201
and
rv /. 
n—1
^ = 0=> 53x^0 + ^ - % • ) = «. 
(2)
j=O
Thus we obtain from (1)
n-l 
n-1
an + b XI ^ = 5Z % • 
(3)
We obtain from (2)
n—1 
n—1 
n —1
aX>j + 65>? = 2>^'- 
(4)
j=0 
3=0 
j=0
Solving (3) and (4) with respect to a and b yields
_ 22j=o Vj - b2Zj=o xi 
6 _ nEj=o xjVj ~ Ej=o xi Ej=o Vi
The line of best fit y = a + bx always passes through the center of gravity
of the data points, since
. n—1 
w n —1
j=0 
j=0
and a = y — bx. The root mean square error is an approximation of the
standard deviation of the fit defined by
(
n-l 
\ 
V 2
where y* is the true value at Xj of the function underlying the experimental
data.
(ii) The C++ program is given by
// leastsquare.cpp
#include <iostream>
using namespace std;
void leastsquare(double* x.double* y,int n.double* a,double* b)
{
double sum_x = 0 . 0 , sum_y = 0.0, sum_xy = 0.0, sum_x2 = 0.0;

202 
Problems and Solutions
for(int i=0;i<n;i++)
{
sum_x += x[i];
sum_y += y[i];
sum_xy += x[i]*y[i];
sum_x2 += x[i]*x[i];
}
*b = (n*sum_xy - sum_x*sum_y)/(n*sum_x2 - sum_x*sum_x);
*a = (sum_y - (*b)*sum_x)/n;
}
r
int main(void)
{
int n = 7;
double* x = new double[n];
double* y = new double[n];
x[0] = 2.0; y[0] = 0.7;
x[l] = 3.0; y[l] = 0.8;
x[2] = 4.0; y[2] = 1.1;
x[3] = 5.0; y[3] = 1.2;
x[4] = 6.0; y[4] = 1.6;
x[5] = 7.0; y[5] = 1.7;
x[6] = 8.0; y[6] = 2.0;
double a = 0.0;
double b = 0.0;
leastsquare(x,y,n,&a,&b);
cout « "a = " « a « " 
" << "b = " « b;
delete[] x; delete[] y;
return 0;
}
Problem 3. The bisection method is defined as follows. Let a < b. Let /
be a smooth function in the interval [a, b]. Assume that /(a) and f(b) have
opposite signs. The function / must cross the 2-axis at some point within
the interval [a, b}. We assume that the function / crosses the x-axis only
once. Thus the equation
f{x) = 0
has a root in the interval [a,b]. This root can be found by repeatedly
halving the interval. Denoting the mid-point of [a, b] by m the root will
be in [a,m] if /(a) and f(m) have opposite signs. Otherwise, f(m) and
fib) will have opposite signs and the root will lie in [m,b]. Thus, the
half-interval containing the root can be determined by simply comparing
the sign of f(m) with the sign of /(a) or f(b). The process can then be

Numerical Techniques 203
repeated for the smaller interval containing the root. In this way a sequence
of mid-points is generated that converges to the root. Convergence is not
as rapid as in some other methods. Give a C++ implementation of the
bisection method. Consider the function
f(x) = cos(x) - -
and the interval [0.5,2.0].
Solution 3. We have
/(0.5) = 0.75258... > 0 and /(2.0) =-0.5411468. . . < 0.
Thus the bisection method can be applied. The function / crosses the
a>axis only once.
// bisection.cpp
#include <iostream>
#include <cmath>
#include <cassert>
using namespace std;
// bisection method to find the root within accuracy
// eps for f(x) between a and b where f(a)*f(b)<=0
double bisec(double (*f)(double).double a,double b.double eps)
{
double m, fm, fa = f(a), fb = f(b);
assert(fa*fb <= 0);
while(fabs(a-b) > eps)
{
m = (a+b)/2.0;
f m = f (m);
if(fa*fm < 0.0) { b = m; fb = fm; >
else 
{ a = m; fa = fm; >
}
return a;
>
double f(double x) { return cos(x)-x/4.0; }
int main(void)
•C

204 Problems and Solutions
cout « "m = " « bisec(f,0.5,2.0,0.000005) « endl;
return 0;
}
Problem 4. The secant method is defined as follows. Let / be a differ-
entiable function in an interval [a,b\. Assume that / has exactly one root
a in this interval, i.e.,
/(a) = 0.
At each step we obtain a new approximation to the root of our equation
by approximating the function with a straight line. In this case, we use
the straight line (the secant) that passes through the curve at the points
corresponding to the two most recent approximations to the root. The
equation of the line passing through the two points
(xi-xJixi-i)) 
and (xi,f(xi))
is
f(Xi-l) - f(xt)
y = f(xi) + 
(x - Xi)
Ij-i 
- Xi
and this crosses the a;-axis at the point
Zi-i 
- Xi
This process is very similar to that used in the Newton-Raphson method.
The gradient of the line passing through two points on the curve is used
in place of the gradient of the tangent at Xi. If the function / is diffi-
cult to differentiate, we can use the secant method as an alternative to
the Newton-Raphson method. Give a C++ implementation of the secant
method. Apply it to f(x) = 0, where
X
f(x) = cos(z) - -
and a = 1.4, b = 1.5.
Solution 4.
// secant.cpp
#include <iostream>
#include <cmath>
#include <cassert>
using namespace std;

Numerical Techniques 205
// secant method to find the root within accuracy p for f(x)
// where xl and x2 are starting points
double secant(double (*f)(double).double xl,double x2,double p)
{
double x, fxl = f(xl), fx2 = f(x2);
while(fabs(xl-x2) > p)
{
x = x2 - fx2*(xl-x2)/(fxl-fx2);
xl = x2; fxl = fx2;
x2 = x; fx2 = f(x2);
>
return xl;
}
double f(double x) { return cos(x)-x/4.0; >
int main(void)
•C
cout « "x = " « secant(f,1.5,1.4,0.000005) « endl;
return 0;
}
Problem 5. Consider the equation
f(x) = 0 
(1)
where it is assumed that / is at least twice differentiable. Let / be some in-
terval containing a root of /. The Newton-Raphson method can be derived
by taking the tangent line to the curve y = f(x) at the point (xn, f(xn))
corresponding to the current estimate, xn, of the root. The intersection of
this line with the rr-axis gives the next estimate to the root, xn+i- The gra-
dient of the curve y = f(x) at the point (xn, f(xn)) is f'{xn). 
The tangent
line at this point has the form y — f'(xn)x 
+ b. Since it passes through
(xn,f{xn)) 
we see that b = f(xn) — xnf'(xn). 
Therefore the tangent line
is y = f'(xn)x 
+ f(xn) — xnf'(xn). 
To determine where this line cuts the
rc-axis, we set y = 0. Taking this point of intersection as the next estimate,
xn+i, to the root we have 0 = f'(xn)xn+1 
+ f(xn) = —xnf'(xn). 
It follows
that
-
»
-
*
-
$
&
• 
<
2
)(2)

206 
Problems and Solutions
This is the Newton-Raphson method. This method has the form "next
estimate = current estimate + correction term". The correction term is
—f(xn)/f'(xn) 
and this must be small when xn is close to the root if
convergence is to be achieved. This will depend on the behavior of f'(x)
near the root and, in particular, difficulty will be encountered when f'(x)
and f(x) have roots close together. Since the method is of the form xn+i =
g(xn) with g(x) = x — f(x)/f'(x) 
the order of the method can be examined.
Differentiating g leads to g'(x) — (f(x)f"(x))/(f'(x))2. 
For convergence we
require that
(fix))2 
< l 
(3)
for all x in some interval I containing the root. Since f(a) = 0, the above
condition is satisfied at the root x = a provided that f'(a) =£ 0. Then, pro-
vided that g{x) is continuous, an interval / must exist in the neighbourhood
of the root and over which (3) is satisfied. Difficulty is sometimes encoun-
tered when the interval / is small because the initial guess must be taken
from the interval. This usually arises when f(x) and f'{x) have roots close
together since the correction term is inversely proportional to f'{x). 
Give
a C++ implementation of the Newton-Raphson method in one dimension.
Apply it to f(x) = 0, where
fix) = ln(x).
Solution 5. 
Obviously we must have x0 > 0. For example, the initial
values x0 = 0.5 and x0 = 2.0 approaches the solution 1. For XQ = 3.0 the
program gives as root —0.295837. Explain why!
// onenewton.cpp
#include <iostream>
#include <cmath>
using namespace std;
// one dimensional Newton's method to find roots of f
// with derivative df for initial value x, and accuracy eps
double newton(double (*f)(double).double (*df)(double),
double x,double eps)
{
double xO, xl = x;
do
{
xO = xl;

Numerical Techniques 207
xl = xO - f(xO)/df(xO); }
while(fabs(xl-xO) > eps);
return xO;
}
double f(double x) { return log(x); }
double df(double x) { return 1.0/x; }
int main(void)
{
double x;
cout << "Enter the initial value (greater than 0): ";
cin » x;
cout « "Approximation = " « newton(f,df,x,0.00001) « endl;
return 0;
}
Problem 6. 
Halley's method is a third order method for finding roots
of a function /, i.e., we want to find a x* such that f(x*) = 0. There are
two method's called Halley's method. One is called the irrational method
and a simpler one is called the rational method. We consider the rational
method. Taylor expansion of f(x) around xn gives
f i x ) = / ( * „ ) + f ' ( x n ) ( x - x n ) + \ f " { x n ) { x - x n f + •••
Taking into account up to second order derivatives and f(x) = 0 we obtain
f(Xn) + f'(xn)(x - Xn) + l-f"{x){x - Xnf = 0 .
Thus
" 
f'(Xn) + 
y"(xn)(x-Xn)'
Using the result from Newton's second order method
x-x 
f{Xn)
n 
/'(*„)
we obtain with x = xn+i Halley's rational iteration formula
x , - x 
/<*") d 
tt*n)f"{xn)\-1
n+1 ~Xn 
f'(xn) V 
2(/'(xn))2 )

208 Problems and Solutions
which can be written as
xn+1 =xn-un[l 
— J
where
n~ f(xny 
Vn~ r(xn)-
Write a C++ implemenation of Halley's rational method for the equation
sin(2x) = sinh(x).
Use the initial values 1.0 and 2.0.
Solution 6. For the initial value 1.0 we obtain the root 0.870998, whereas
for the initial value 2.0 we obtain the root 0.0.
// Halley.cpp
#include <iostream>
#include <cmath>
using namespace std;
double f(double x) { return sin(2.0*x) - sinh(x); }
double fd(double x) { return 2.0*cos(2.0*x) - cosh(x); }
double fdd(double x) { return -4.0*sin(2.0*x) - sinh(x); }
int main(void)
{
double eps = 0.00001;
double x0, xl;
xO = 1.0;
do
{
xl = xO;
double u = f(xl)/fd(xl);
double v = fdd(xl)/fd(xl);
double b = 1.0 - u*v/2.0;
xO = xl - u/b;
}
while(fabs(xl-xO) > eps);
cout « "xO = " « xO;
return 0;
}

Numerical Techniques 209
Problem 7. We consider the system of (nonlinear) equations
fl(xi,X2,...,Xn)=0, 
. . . , fn(x1,X2,...,Xn) 
= 0
where we assume that the functions fj are twice differentiable. We de-
note by x the vector (xi, X2, • • •, xn) and by f the vector with components
(/i,/2, ...,/„). Then the system can be written as one vector equation
f (x) = 0. If we take the gradients of the components, we obtain a n n x n
function matrix called the Jacobian matrix. It is defined as follows
/dh_ 
dh_ 
dh.\
J(f(x)) = ( ! & ) = 
:
The Newton method in higher dimensions works as follows. Suppose that
the vector y is the exact solution and that our present approximation x can
be written as x = y + h. We compute fj(x\,... ,xn) and call these values
gj. Thus /(y + h) = g. Expanding this in a Taylor series, we find
fjivi, 2/2, • • •, yn) + Y] hk —^ + (higher order terms) = gj .
fe=i 
Vk
The first terms are zero by definition, and neglecting higher order terms we
obtain with Jjk = {dfj/dxk)x=y
where we suppose that the matrix J is nonsingular. The vector h found in
this way in general does not give us an exact solution. We arrive at the
iteration formula
x(m+l)=x(m)_j-lf(x(m))_
The matrix J changes from step to step. This suggest a simplification to
reduce computational efforts replace J(x'm^) by J(x^0^). Write a C++
program that finds the roots for the system of equations
/i(x) =xl + xl-l, 
/ 2 ( x ) = x i - x 2 .
Solution 7. Since
oxx 
dx2 
oxi 
dx2
we obtain
J=f2x1 
2z2\ 
! _ 
1 
(I 
2x2\
\ 1 
-lj' 
2(Xl+x2)\l 
-2Xl) •

210 Problems and Solutions
Thus
j - i f = 
1 
( x\-x\ 
+ 2xixi - 1 \
2(xi + x2) V ~xl + A + 2XiX2 - 1) '
The C++ program is
/ / twonewton.cpp
#include <iostream>
#include <cmath>
using namespace std;
void JIf(doublefe x,double& y)
{
double t l = 2.0*(x + y);
double t2 = x*x - y*y;
double t3 = 2.0*x*y - 1.0;
x = x - (t2 + t3)/tl;
y = y - (-t2 + t3)/tl;
}
int main(void)
•C
double eps = 0.001;
double xl = 0.9, yl = 0.6;
double xO, yO;
do
•C
xO = xl; yO = yl;
JIf(xO,yO);
xl = xO; yl = yO;
} while(fabs(xl*xl + yl*yl - 1.0) > eps);
cout « "xl = " « xl « endl;
cout « "yl = " « yl « endl;
return 0;
}
Problem 8. 
We want to minimize a smooth function / : Rn —> R. It
is assumed that the gradient vector V/ = (df/dxi,..., 
df/dxn)T 
and the
n x n Hessian matrix V2/(x) = (d2 f /dxjdxk) of the function / exists and
can be evaluated analytically. Most of the discrete time iterative methods
for this problem involves generating a sequence of search points Xfc via the

Numerical Techniques 211
iteration procedure
x f c + 1 =Kk + T]kdk, 
x o = x ( O ) , 
k = 
0,1,2,...
where the scalar r]k determines the length of the step to be taken in the di-
rection of the vector dfc (sometimes called the learning rate). In numerical
optimization, different techniques for the computation of the parameter f]k
and the direction vector dfc are known. There are four basic methods.
1) For the steepest-descent gradient method we define the direction as
dfc := - V/(xfc).
2) For Newton's method the search direction is determined from the formula
dfc--(V2/(xfc))-1V/(xfc).
3) The calculation of the inverse Hessian matrix can be complicated. Thus,
we try to approximate it by some n x n symmetric definite matrix Hk, i.e.,
Hk « (V 2/^*))- 1.
Thus, we obtain the quasi-Newton (variable metric) methods in which the
search direction is determined as
dfc = -FfcV/(xfc).
4) The conjugate gradient method computes the actual search direction dfc
as a linear combination of the current gradient vector and the previous
search directions. In the simplest form, the search direction is calculated
as
dyfc = -V/(xfc) + /3fcdfc_1) 
A; = 1,2,...
with do = — V/(xo) and (3k is a scalar parameter that ensures the sequence
of vector dfc satisfies a mutual conjugacy condition.
Consider the function / : R —» R
f{x) = 
x4-x2.
Thus from
- / = 0 => 4a;*3 - 2x* = 0 =4> x*(2x*2 - 1) = 0
dx
we find the critical points
x* = 0 => f(x* = 0) = 0 local maximum

212 
Problems and Solutions
and
x* = ±—j= => f(x* = ±—;=) = - - 
global minima
For the steepest-descent (gradient) method the iteration is given by
x k + 1 = x k + r ] k ( - — (x = x k ) J , 
A; = 0 , 1 , . . . .
Thus
xk+i =xk- 
Vk(4xl - 2xk) =xk- 
2r)kxk(2xl ~ *) •
Select the initial value xo =4.0.
(i) Iterate for 77 fixed (77 = 0.5,0.1,0.01).
(ii) Iterate for r]k+i = r)k/l.l with TJ0 = 0.05,0.02.
(iii) Write a C++ program for the case 77^+1 = rjk/l.Ql and 770 = 0.02.
Solution 8. 
(i) For 77 = 0.5 we find
k 
x_k
0 
4.0
1 
-120.0
2 
3.45576E+006
Thus we have an escaping solution, i.e., the step length 77 = 0.5 is to large.
For 77 = 0.1 we also find an escaping solution. Also this step length is to
large. For 77 = 0.01 the iteration approaches the solution x* = l/\/2.
(ii) For 77 = 0.05 we also find an escaping solution. For 77 = 0.02 the
iteration does not approach the solution x* = l/\/2 since the step size
(learning rate) 77 decreases too fast. We can avoid this problem when we
select 77^+1 = r/k/1.01 instead of 77^+1 = 77^/1.1. Then we find the solution
x* = - I / A / 2 .
(iii) We have
// gradient.cpp
#include <iostream>
using namespace std;
int main(void)
{
int n = 400;
double eta = 0.2; // initial value eta
double x = 4.0; 
// initial value x

Numerical Techniques 
213
for(int k=O;k<n;k++)
{
x = x - 2.0*eta*x*(2.0*x*x - 1.0);
eta = eta/1.01;
cout « "k = " « k+1 « " x = " « x
<< " eta = " << eta « endl;
}
return 0;
}
Problem 9. Consider the eigenvalue equation
in the Hilbert space L2IP, 1], where V (potential) and u are real-valued
functions and u is normalized, i.e.,
/•i
/ u2(x)dx = 1.
Jo
We consider the case V(x) = 0 and u(0) — u(l) = 0. Thus, the lowest
eigenvalue is positive and not degenerate. This choice corresponds to a free
particle in hard-walled box of unit length. Introducing
2mV(x) 
2mE
U ( X ) : = ^ - '
 
6
:
= 1 ^
we have
/ 
d2 
\
( -j-2 
+ v(x) J u(x) = eu(x).
The energy functional is given by
-jC((i)
>+"
(^
(*»)-
To find numerically the lowest eigenvalue we discretize, i.e.,
JV-l 
/ , 
,0 
\
E
, / (Uj — Uj-lY 
n\
V 
h2 
+V3UjJ
and
N-l

214 Problems and Solutions
where h is the step length and u0 = UN = 0. An approximation to the
second derivative
accurate to order h2 is given by
To find the lowest eigenvalue we consider
du 
-
— = -Hu
de
where t is a real parameter. The simplest solution (iteration) is given by
u(n+i) ~(l-HAe)u{n\ 
n = 0,l,2,...
where ~ indicates that ul-n+1^ has to be normalized. For the initial func-
tion u'0) we have to choose a function that is not orthogonal to the exact
eigenfunction. Choose
u(x) = x(l — x).
Note that this function is not normalized. Write C++ code that implements
this algorithm. Discuss.
Solution 9. The function norm() normalizes the function u.
II lowesteigenvalue.cpp
#include <iostream>
#include <cmath>
using namespace std;
void norm(double* u.int nsteps)
{
double norm = 0.0;
int ix;
for(ix=0;ix<nsteps;ix++)
{
norm += pow(u[ix],2.0);
>
norm = sqrt((nsteps-l)/norm);
for(ix=0; ix < nsteps; ix++)
{ u[ix] *= norm; }
}

Numerical Techniques 215
int main(void)
{
int nsteps = 21; 
// lattice parameter
double* u = new double[nsteps]; // solution array-
double h = 1.0/(nsteps - 1.0);
double dt = 0.0005;
double dth = dt/(h*h);
int ix;
for(ix=0;ix<nsteps;ix++)
{
double x = ix*h;
u[ix] = x*(1.0 - x); 
// initial function for u
}
norm(u,nsteps); 
// normalize initial u
for(int iter=l;iter<100;iter++)
•C
double pold = 0.0; // u[0] = 0
double pnew;
for(ix=l;ix<(nsteps-1);ix++)
{
// (1 - H*dth)u
pnew = u[ix] + dth*(pold + u[ix+l] - 2.0*u[ix]);
pold = u[ix] ;
u[ix] = pnew;
norm(u,nsteps); 
/ / normalize
>
/ / calculation of energy e
double e = 0.0;
for(ix=l;ix<nsteps;ix++)
{
double temp = u[ix] - u[ix-l];
e += temp*temp;
>
e = e/h;
cout << " energy = " « e << endl;
}
return 0;
}
The result is 9.85. This agrees well with the exact eigenvalue
en = nn2, 
n = 1, 2,...

216 
Problems and Solutions
For n = 1 (ground state) we have ei = TT2 = 9.869.... The exact normalized
eigenfunctions are given by
un{x) = 2 1 / 2 sin(n7ra;).
Problem 10. 
Thep-norm of a vector (XQ,X\, ... ,z n_x) T £ R" is defined
as
(
n-l 
\ 
1 / P
EN P)
where p £ R +.
(i) Find the norm for p —> oo.
(ii) Discuss the case p = 1 and p = 2.
Solution 10. 
(i) Obviously we find
l | x | | o o = o< m^-i 1^ 1-
(ii) For p = 1 we have
IMIi = X>il
j=0
and for p = 2 we have the Euclidean norm
(
n-l 
\ 
V 2
§7 '
Problem 11. Let p > 1. Let x and y be two n-dimensional vectors over
the real numbers. A metric (distance) between x and y is denned as
/n-i 
\ 
1 / p
Hx-y||P:= (l>>-fc-n 
•
Write a C++ program with the function
double metric(double* vl,double* v2,double p,double n)
which calculates the metric for two given vectors V! and v2. Apply the
program to
V! = (1.0,2.0, -3.0,2.1), 
v2 = (4.0,3.0,1.0, -7.0)

Numerical 
Techniques 217
and p = 1 and p = 2. For p —> oo we obtain the metric (max metric)
||x - y||oo := max \XJ -yj\.
0<j<n—l
Give a C++ implementation with the function
double maxmetric(double* vl,double* v2,double n).
Solution 11.
// pdistance.cpp
#include <iostream>
#include <cmath>
using namespace std;
double pmetric(double* vl,double* v2,double p,double n)
{
double s = 0.0;
for(int i=0;i<n;i++) { s += pow(fabs(vl[i] - v2[i]),p); }
s = pow(s,1.0/p);
return s;
}
double maxmetric(double* vl.double* v2,double n)
{
double t = fabs(vl[0] - v2[0]);
for(int i=l;i<n;i++)
{
double s = fabs(vl[i] - v2[i]);
if(s > t) t = s;
>
return t;
>
int main(void)
{
int n = 4;
double* vl = new double[n];
vl[0] = 1.0; vl[l] = 2.0; vl[2] = -3.0; vl[3] = 2.1;
double* v2 = new double[n];
v2[0] = 4.0; v2[l] = 3.0; v2[2] = 1.0; v2[3] = -7.0;
double p = 10.0;
double distancel = pmetric(vl,v2,p,n);

218 
Problems and Solutions
cout « "distancel = " « distancel « endl;
double distance2 = maxmetric(vl,v2,n);
cout « "distance2 = " « distance2 « endl;
delete [] vl; delete [] v2;
return 0;
}
Problem 12. Write a C++ program that computes sin(:r) to at least 5
decimal places for all x using the Taylor expansion series of sine
, 
X3 
X5 
X7 
X9
sm(z) = z - - + - - - + - - . . . .
Use Horner's method and reduction to the domain 0 < x < ir/2.
Solution 12.
// sine.cpp
#include <iostream>
#include <cmath>
using namespace std;
double sine(double x)
{
const double PI = 3.1415926535897932;
const double TWOPI = 6.2831853071795865;
const double PIHALF = 1.5707963267948966;
const int m = 9;
double s, x2, n, sign;
// reduce to 0 <= x < 2*PI using sin(x-2*n*PI) = sin(x)
n = floor(x/TW0PI);
x = x - TWOPI+n;
// reduce to 0 <= x <= PI using sin(2*PI-x) = -sin(x)
if(x > PI) { x = TWOPI - x; sign = -1.0; }
else sign = 1.0;
// reduce to 0 <= x <= PI/2 using sin(PI-x) = sin(x)
if(x > PIHALF) x = PI - x;
// compute x - x"3/3! + x~5/5! - x"7/7! + x"9/9!
s = 1.0;
x2 = x*x;

Numerical Techniques 219
for(int i=m;i>l;i=i-2) { s = 1.0 - (x2/(i*(i-l)))*s; }
return sign*s*x;
}
int main(void)
•C
double x = 1.0;
double resultl = sine(x);
cout « "resultl = " « resultl « endl;
x = 10.0;
double result2 = sine(x);
cout « "result2 = " « result2 « endl;
x = 100.0;
double result3 = sin(x);
cout « "result3 = " « result3 « endl;
return 0;
}
Problem 13. Determine the Hausdorff distance H(A, B) between the set
of vectors in R3
^:={(3,1,4) T,(1,5,9) T}
and
£:={(2,7,l) T,(8,2,8) T,(l,8,2) r}
where
H(A, B) := max { h(A, B), h{B, A) }
h(A,B) :=m&xLnn{\\x-y\\\
MB,i4):=max(min{||y-x||) .
Use the Euclidean distance for || • ||.
Solution 13. We set
A : = { a i = (3,l,4)T,a2 = (l,5,9)T}
and
B:={b1 
= (2,7,1)T , b2 = (8,2,8)T , b 3 = (1,8,2)T }.
We tabulate the Euclidean distances

220 
Problems and Solutions
ai 
a2 
Minimum
bi 
\/46 y/m 
\/46
b2 
\/42 \/59 
v ^
b3 
\/57 \/58 \/57
Minimum >/42 %/58
Thus
/i(4, S) = max{\/42, \/58} = V58
h(B, A) = max{v^6, v7^, ^57} = V&7
and therefore
H(A, B) = max{\/58, \/57} = \/58 .
Problem 14. Assume that a function / has a power series expansion
oo
/(aO = $ > V .
The (AT, M) Pade approximant is given by
' 
CM-N+l 
CM-N+2 
• • • 
CM+1 ^
det 
: 
: 
:
CM 
CM+1 
• • • 
CM+N
/CM-N+l 
CM-N+2 
••• 
C M + 1 \
det 
= 
' 
• 
\
I 
cM 
CM+I 
• • • 
CM+N 
I
V xN 
/ " ' ... 
1 /
(i) Calculate [1,1] (a;) for
(ii) Calculate [1,1] (x) for
f2{x) — A/1 + 2;-
(iii) Calculate [2,2](x) for
h(x) = ex •
Solution 14. (i) We have
/ i ( x ) = l - a ; + a ; 2 - a ; 3 + --- .

Numerical Techniques 221
Thus c0 = 1, c\ = — 1, c2 = 1 and therefore
detf Cl 
C2 ) 
detf-1 / 
)
h , „ N _ 
Vcpx 
co + gxj _ 
\ x 1-xJ _ J_
"()^ -(:?) " *(;' !) ^ +"
(ii) We have
Vl + x = 1 + -x - -xl H 
.
2 
o
Thus Co = 1, c\ — 1/2, c2 = -1/8 and therefore
, / ci 
c2 
\ 
A / 2 
-1/8 \
_ d e tU^ co + cix) 
a e \ x 
l+x/2j _ 1 + 3x/4
(iii) We have the expansion
Thus
1 
1 
1
Co = 1, 
Cy = 1, 
C2 = - , 
C3 = - , 
C4 = —
and therefore
(
ci 
c2 
c3 
\
c2 
c3 
c4 
I
cpx2 
C0X + cix2 
c0 + gx + c2x2 J
/ Cl 
C2 C3 \
det I c2 c 3 c4
\x2 
x 
l)
( 1 
1/2 
1/6 
\
det 
1/2 
1/6 
1/24
\ x 2 x + x 2 l+x + 
x2/2j
= 
T~l 
1/2 
1/6 \
det 
1/2 1/6 1/24
\x2 
x 
1 )
_ 12 + 6x + x2
= 12 - 6x + x2 '
For example
19
[2,2](1) = — w 2.7142857....

222 
Problems and Solutions
Problem 15. Let / be a real-valued function defined at any point x in
the interval (a, b). The derivative of / at x = x0, x0 € (a, 6) is denned as
if this limit exists or as
if this limit exists. Prom (la) and (lb) we obtain
h->o 
in
For (la) and (lb) the error is of order h, whereas for (2) the error is of
order h2. Another definition would be
_ 
-ll/(s) + 18/(x + h) - 9f(x + 2/i) + 2/(x + 3/Q
/ [x) : - l.m 
- 
. 
(3)
Equations (la), (lb), (2) and (3), respectively can be used as an approxima-
tion for the derivative with h small. Write a C++ program that implements
these approximations for (la), (lb) and (2) for h = 0.1,0.01,0.001,0.0001.
Solution 15. Difficulties can arise as h becomes smaller. In theory, the
smaller the value of h is, the more accurate the approximation to 
f'{x).
However, in a program the values obtained may be unreliable because of
rounding errors that take place during the evaluation of the differences and
the division.
/ / derivative.cpp
#include <iostream>
#include <cmath>
using namespace std;
double f(double x) { return x*x*x; }
/ / numerical derivative of f at x method la
double dfla(double (*f)(double).double x,double h)
{ return (f(x+h) - f(x))/h; }
/ / numerical derivative of f at x method lb
double dflb(double (*f)(double).double x.double h)
{ return (f(x) - f(x-h))/h; }
(1a)
(1b)
(2)

Numerical Techniques 223
// numerical derivative of f at x second method
double df2(double (*f)(double).double x.double h)
•C return (f(x+h) - f (x-h))/(2.0*h); >
int main(void)
•C
double x = 2.0, h = 0.1;
for(int count=l;count<5;count++)
{
cout « "h = " « h « endl;
cout « "Method la: df/dx(x=" « x « ") = " « dfla(f,x,h)
« endl;
cout « "Method lb: df/dx(x=" « x « ") = " « dflb(f,x,h)
<< endl;
cout « "Method 2: df/dx(x=" « x « ") = " « di2(f,x,h)
« endl;
h /= 10.0;
>
return 0;
}
Problem 16. Let / be a smooth function. Consider the integral
I(xn,x0) = / 
f(x)dx.
Jxo
To find an approximation of this integral we can use the trapezium rule.
The name of this method comes from a simple geometrical interpretation;
the area between the curve, the x-axis, and two ordinates is approximated
by the area of a trapezoid
f" f(x)dx « £=-Zi° (/(*„) + /(*„)) •
Jxo 
*
This approximation is repeated over several intervals of length h, with Xk =
xo + kh, k = 0,1,2,..., n. We obtain
/ 
f(x)dx w -(/(xo) + 2/(xi) + 2/(x2) + • • • + 2/(xn_!) + 
f(xn)).
Jx0
 
l
We find the truncation error by considering one interval
™-S('tt)*'G))-/>-

224 Problems and Solutions
From dR/dh, d2R/dh2 and d3R/dh3 we find that dR(h = O)/dh = 0,
d2R{h = 0)/dh2 = 0 and
d3R(h = 0) _ 1 d2f(h = 0)
d/i3 
~ 2 d/i2
Thus the truncation error is essentially (/i3/12)cP/(/i = 0)/dh2. Write a
C++ program that implements the trapezium rule.
Solution 16.
// trapez.cpp
#include <iostream>
#include <cmath>
using namespace std;
// integrate f on (a,b) using the trapezium rule
// using n steps
double trapezium(double (*f)(double).double a,double b.int n)
•C
double h = (b - a)/n;
double sum = (f(a) + f(b))/2.0;
for(int i=l;i<n;i++) sum += f(a+i*h);
return h*sum;
}
double f(double x) { return exp(-x); }
int main(void)
{
cout « "The integral of exp(-x) on (0,1) is "
« trapezium(f,0.0,1.0,100) « endl;
return 0;
>
Problem 17. For using the Simpson rule in integrating a smooth func-
tion / we divide the interval [xo,xn] into sub-intervals [XJ,XJ+2] for j =
0,2,..., n — 2 and express the integral in the form
rxn 
rxj+2
/ 
f(x)dx= 
]T / 
f(x)dx. 
(1)
Jxo 
j=0(2)n-2Jxi
On a sub-interval [XJ, Xj+2] the integrand / is approximated by the quadratic
passing through {xj,f{x-)), 
(xj+i,f(xj+i)) 
and (xj+2J(xj+2)). 
Taking

Numerical Techniques 225
x = Xj + rh, the first three terms of the Gregory-Newton forward formula
give
f(x)^fj+rAfj 
+ 
r-^^-A2fj, 
xj<x<xj+2, 
0 < r < 2 . 
(2)
Thus the contribution to (1) over [XJ,XJ+2] is
/ 
f(x)dx = / f{xj + rh)hdr
JXJ 
J0
= jT (jj + rAfj + 
{^—^A2/,) hdr + £j
where tj is the local truncation error for the integration formula on [XJ , Xj+2] •
We find that this local truncation error is given by tj = -/i5/^"'(£j)/90,
where £j lies in the interval [XJ,XJ+2]- Thus we find
f " f{x)dx = ^(/o +4/i +2/ 2 +4/ 3 +2/4 + • • • +2/ n_ 2 +4/ n_i +/„) +eG
Jxo 
6
where fj = f(xj) and CG is the global error, CQ is given by
Write a C++ program that implements the Simpson rule.
Solution 17.
// simpson.cpp
#include <iostream>
#include <cmath>
using namespace std;
// integrate f on (a,b) using the Simpson rule with n steps
double simpson(double (*f)(double).double a,double b,int n)
•C
double h = (b-a)/(2.0*n);
double sum = f(a) + f(b) + 4.0*f(a+h);
for(int i=l;i<n;i++)
sum += 2.0*f(a+2.0*i*h) + 4.0*f(a+h+2.0*i*h);
return h*sum/3.0;
}

226 
Problems and Solutions
double f(double x) { return exp(-x); }
int main(void)
{
cout « "The integral of exp(-x) on (0,1) is "
« Simpson(f,0.0,1.0,100) « endl;
return 0;
}
Problem 18. 
The Romberg integration is a method of obtaining high-
order numerical approximations to integrals from the trapezium rule (or
Simpson's rule) approximation. To obtain a higher order method based
on the trapezium rule, we examine the correction or error term associated
with the trapezium rule. The correction term associated with the composite
form of the trapezium rule can be expressed in the form
C = a2h2 + a4h4 + a6h6 + ••• 
(1)
where h is the step length and a2, a4, a6, ... are constants. The correction
term is an even function of h, i.e., C(h) = C(—h). Since the correction of
the trapezium rule is simply the difference between the exact integral and
the trapezium rule approximation we have
C = jf" f(x)dx -h(^+f1+f2 
+ ... + fn^ + ^j 
(2)
where fj = f(xj). Denoting the exact integral by / and the trapezium rule
approximation with the step length h by T(h), from (1) and (2) we may
write
/ = T ( h ) + a 2 h
2 + a 4 h
4 + a 6 h
6 + •••
If this is used with step length h and h/2 we have / = T(h)+a2h2+a4h4-\
and
I = T(h/2) + a2
f^+a4
f^ 
+ .--. 
(3)
Eliminating the leading contribution to the correction term between these
two equations gives
J = 4 I W 2 ) - T ( / , ) + V i 4 + 
( 4 )
where b4 is a constant. Whereas T(h) and T(h/2) have errors of order h2,
the first term on the right-hand side of (4)

Numerical Techniques 227
gives an approximation to / with error of order h4. Write a C++ program
that implements the Romberg integration.
Solution 18. In the program p denotes the accuracy.
/ / romberg.cpp
#include <iostream>
#include <cmath>
#include <vector>
using namespace std;
/ / integrate f on (a,b) using the Romberg integration
/ / using n steps
double romberg(double (*f)(double).double a,double b.double p)
{
int i, j , k, n = 4;
double sum, h, factor, help, integral;
vector<vector<double> > trap;
trap.resize(l);
trap[0].resize(l);
h = (b-a)/n;
/ / trapezium rule for T(h)
sum = (f(a) + f(b))/2.0;
for(i=0;i<n;i++) sum += f(a+i*h);
trap[0][0] = h*sum;
j = 0;
do
{
trap.resize(j+1);
trap[0].resize(j+l);
/ / trapezium rule for T(h/2) . . .
for(k=0;k<n;k++) sum += f(a+k*h+h/2.0);
n *= 2; h /= 2.0;
/ / TOO, T(h/2), T(h/4), T(h/8), . . . . T(h/(2"j)), . . .
trap[0][j] = h*sum;
factor = 1.0;
for(i=0;i<j;i++)
{
trap[i+l].resize(j+1);
//T(h,h/2), 
T(h/2,h/4), 
T(h/4,h/8), . . .
j++;

228 Problems and Solutions
/ / T(h,h/2,h/4), T(h/2,h/4,h/8), . . .
factor *= 4.0;
trap[i+l][j] = (factor*trap[i][j]-trap[i][j-l])/(factor-1.0);
}
// repeat until the change in the approximation
/ / is less than p
} while(fabs(trap[j] [j]-trap[j-l] [j]) > p) ;
return trap[j] [j] ;
}
double f(double x) { return x*x; }
int main(void)
•C
cout « "The integral of x"2 on (0,1) is "
« romberg(f,0.0,1.0,0.0001) « endl;
return 0;
}
Problem 19. Double numerical integration is the application twice of a
numerical integration method for single integration, once for the y direc-
tion and another for the x direction. Any numerical integration method
for single integration can be applied to double integration. Write a C++
program that applies Simpson's 1/3 rule to find the double integral
/-6=3 / ,i/=3+exp(x/5) 
\
I = 
/ 
sin(x + y)dy dx.
Ja=l \Jy=\n(x) 
J
Solution 19. To do the numerical integration we apply two nested for
loops for the y and x integration.
/ / doubleintegration.cpp
#include <iostream>
#include <cmath>
using namespace std;
double function(double x,double y) { return sin(x+y); }
double lower_curve(double x) { return log(x); }
double upper_curve(double x) { return (3.0 + exp(x/5.0)); }

Numerical Techniques 229
int main(void)
{
int k, m, n;
double a, b, c, d, f, hx, hy, s, t, w, x, y;
cout « "double integration using the Simpson rule" « endl;
cout « "number of intervals must be even" << endl;
cout << "number of intervals in x-direction: m = "; cin » m;
cout « "number of intervals in y-direction: n = "; cin » n;
cout « "lower boundary of x: a = "; cin >> a;
cout << "upper boundary of x: b = "; cin » b;
hx = (b - a)/m;
t = 0.0;
for(int i=0;i<=m;i++)
{
x = a + i*hx;
c = lower_curve(x); // finds the lower limit of y value
d = upper_curve(x); // finds the upper limit of x value
hy = (d - c)/n; 
// interval size in y-direction
s = 0.0;
fordnt j=0;j<=n;j++)
{
y = c + j*hy; 
// y value of grid points
f = function(x.y);
w = 4.0;
if (j°/.2 == 0) w = 2.0;
if((j==O) || (j == n)) w = 1.0;
s += w*f; 
// integration in y-direction
} // end for j
s •= hy/3.0;
w = 4.0;
if(i"/,2 == 0) w = 2.0;
if((i ==0) || (i == m)) v = 1.0;
t += w*s; 
// integration in x-direction
} // end for i
t *= hx/3.0;
cout « "integral = " « t « endl;
return 0;
}
Problem 20. Given a set of data
{xj,yj = f(xj)}

230 Problems and Solutions
where j = 0,1,..., N — 1. Suppose that the yj can be complex and that
the node points are equally spaced in the interval [0, 2TT], i.e., Xj = 2nj/N
foij = 
0,l,...,N.
(i) Find
J V - l
p(x) = J 2
 c k e
i k x = co + c i e
i x + c 2 e
2 i x + ••• + C N - i e l " -
1 ) * * 
(1)
fc=0
such that
p(Xj) = f{Xj) .
This is called trigonometric interpolation.
(ii) Apply it to the data set (N = 4)
(xo,yo) = (0,0)
0*2,2/2) = (7r,7r)
Solution 20. Since
ei(x+27r) _ eixe2i7r _ 
£ix
the interpolation is periodic, i.e., p(x + 2n) = p(x). Let
wj _ 
e^i
where
W := e^N .
Thus w " = 1 so that w is the TVth root of unity. We obtain from (1)
f(Xj) 
= p{xj) = c0 + ciwj + c2w2j + ••• + cjv-iiu(JV"1W •
This set of equations for j = 0 , 1 , . . . , AT — 1 is a system of N equations in
N unknowns and can be written in matrix form Ac = y
/I 
1 
1 
... 
1 
\ / c0 \ 
/ yo \
1 
w 
w2 
... 
wN~l 
ci 
yi
1 
w2 
w4 
... w 2^- 1) 
c2 
= 
y2 
_
\1 / - 1 W2^-1) ... 1 > " W Vcjv'-j 
Vt/iV-l/

Numerical Techniques 231
This is the discrete Fourier transform. The matrix A on the left-hand side
has an inverse with
Thus c = A~xy. It follows that
m=0
Neglecting sums, to compute each coefficient Cfc we perform N multiplica-
tions. This means that discrete Fourier transforms require N2 operations.
Hence, for the calculation we should use the fast Fourier transform,
(ii) We find
co = -{l + y/3), 
Ci = - - , 
ca = -(l->/3), 
c3 = - - .
Thus
p(x) = ^(1 + V3 - eix + (1 - V3)e2ix - 
e3ix).
The real part is
pr(x) = -(l + V3- cos(:r) + (1 - V3) cos(2a;) - cos(3:r)).
Problem 21. Let b > a and consider the integral
/ 
!{x)dx.
Ja
Let
t= —]—r(a + b-2x). 
(1)
(X — 0
Express the integral with this variable.
Solution 21. We have a < x < b. Using the transformation we obtain
-1 < t < 1. Since
, 
b - a
ax = 
at
and solving (1) for x
x=-(a 
+ b) + -(b-a)t
yields
jT f(x)dx = ^ 
J ^ / Q(« + b) + l-{b - «)^ *.

232 Problems and Solutions
Problem 22. Linear interpolation and quadratic interpolation are special
cases of polynomial interpolation where we approximate an unkown function
/ for which we know values at n + 1 points by the unique polynomial of
degree n that passes through these points. We construct one form of the
equation for the polynomial passing through the points
(x0, f(x0)), 
{xi,f{xi)),..., 
(xn,f(xn)).
We define the following functions
L0{x) := (x - xj)(x - x2) • • • (x - 
xn)
Li(x) 
:= (x - xo)(x - x2) • • • (x - 
xn)
Li(x) := (x - xo)(x - xi) • • • (x - Xi-X)(x - xi+i) 
• • • (i - xn)
Ln{x) := (x - xo)(x - xi) • • • (x - x n_i).
Each of these functions is a polynomial of degree n. Note that Li(xj) = 0
for i 7^ j and LJ(XJ) / 0. We can use these functions to construct a
polynomial of degree n that passes through our n + 1 points as follows
Pi*) - ^ / ( x o ) + ^ / ( x O + •. • + ££\/(* n) •
Lo(xo) 
Li(xi) 
Ln(xn)
Obviously p(xi) = /(x,) for i = 1, 2,..., n. Write a C++ program that
implements this interpolation. The data are (0,1.0), (0.5,1.2), (1.0,1.4),
(1.5,1.7), (2.0,2.2).
Solution 22. We are using two for-loops and an if-condition to solve
the problem. For the products in Lj we initialize termi to 1.
/ / interpolation.cpp
#include <iostream>
using namespace std;
int main(void)
{
int n = 5; // number of points
double* x = new double[n];
x[0] = 0.0; x[l] = 0.5; x[2] = 1.0; x[3] = 1.5; x[4] = 2.0;
double* fx = new double[n];

Numerical Techniques 233
fx[O] = 1.0; f x [ l ] = 1.2; fx[2] = 1.4;
fx[3] = 1.7; fx[4] = 2 . 2 ;
double xvalue = 1.25;
double p = 0.0;
double termi;
for(int i=0;i<n;i++)
i
termi = 1.0;
for(int j=O;j<n;j++)
{
if(j != i) termi = termi*(xvalue - x[j])/(x[i] - x[j]);
} / / end for j
p += termi*fx[i];
} // end for i
cout « "p = " « p;
delete[] x; 
delete[] fx;
return 0;
>
Problem 23. 
Let A = (a^) be an n x n matrix, and let x and b be
n-vectors with elements in C such that
Ax = b. 
(1)
Assume that
a j j ^ O , 
j = l , 2 , . . . , n 
(2)
and define
D := diag(flij). 
(3)
Then (1) can be written as
x = 5x + c 
(4)
where
B = -D~l{A-D)
c = D~lh.
The Jacobi method for the solution of (1) respectively (4) is given by
x ( W ) = 5 x ( f c ) + C | 
fc 
= 0,1,2,...

234 
Problems and Solutions
where x^0^ is any initial vector. This method is convergent for each initial
vector x(0) iff
Bk -> 0 for k -> oo
which in turn is equivalent to the condition that the spectral radius p{B)
satisfies
p{B):= .jouzx. 
n\\i{B)\<l
where Aj(B),j = 1,2,...,n are the eigenvalues of B. Write a C++program
for this method and apply it to the system of linear equations
5x + y + z = 10
x + 6y - 2z = 7
x - 2y + Iz = 16.
Solution 23. Obviously, the system satisfies the condition given above.
The C++ implementation is
/ / Jacobi.cpp
#include <iostream>
using namespace std;
int main(void)
{
int n = 3;
double** A = NULL;
A = new double*[n];
for(int i=0;i<n;i++) A[i] = new double[n];
A[0][0] = 5.0; A[0][l] = 1.0; A[0] [2] = 1.0;
A[l][0] = 1.0; A[1][1] = 6.0; A[l][2] = -2.0;
A[2][0] = 1.0; A[2][l] = -3.0; A[2] [2] = 7.0;
double* b = new double[n];
b[0] = 10.0; b[l] = 7.0; b[2] = 16.0;
double x = 0.0, y = 0.0, z = 0.0;
double xl, yl, zl;
int T = 100; / / number of iterations
for(int j=O;j<T;j++)
{
xl = x; yl = y; zl = z;
x = (b[0] - A[0][l]*yl - A[0] [2]*zl)/A[0] [0];

Numerical Techniques 235
y = (b[l] - A[l][O]*xl - A[l][2]*zl)/A[l][l];
z = (b[2] - A[2][0]*xl - A[2][l]*yl)/A[2][2];
}
cout « "x = " « x « endl;
cout « "y = " « y « endl;
cout « "z = " « z « endl;
for(int k=0;k<n;k++) deleteG A[k];
delete[] A;
return 0;
}
Problem 24. A finite continued fraction is an expression of the form
fn(x) =
. 
ai
b0 + x +
6i + x +
. . . H 
—
bn + x
A convenient notation for this expression is the following
«o 
ai 
an
b0 + x+ b2 + x+ " ' bn + x '
The following recursion formulas are valid
fn(x) = —, 
rn:=x + bn, rk := x + bk + -£±i
^o 
rk+i
where k = n— l,n—2,..., 1,0. The formula is proved by induction. Contin-
ued fractions containing a variable x are often useful for representation of
functions. Such expressions often have much better convergence properties
than, for example, the power-series expansion. An example is
xx2 
4x2 9x2 I61 2 25x2
arctanfa;) = 
...
w 
1+3+ 5+ 7+ 9+ 11+
Write a C++ program that implements this recursion and apply it to x = 0,
ao = ox = • • • = an = 1, 
bo = bi = • • • — bn = 1
to find an approximation of the golden mean number (\/5 — l)/2.

236 
Problems and Solutions
Solution 24.
// contfrac.cpp
#include <iostream>
using namespace std;
double fn(double* a,double* b,double x.int n)
{
double zr;
zr = x + b [n] ;
for(int k=n-l;k>=0;k—) { zr = x + b[k] + a[k+l]/zr; }
return a[0]/zr;
}
int main(void)
{
int n = 4;
double* a = new double[n+1];
double* b = new double[n+1];
a[0] = 1.0; a[l] = 1.0; a[2] = 1.0;
a[3] = 1.0; a[4] = 1.0;
b[0] = 1.0; b[l] = 1.0; b[2] = 1.0;
b[3] = 1.0; b[4] = 1.0;
double x = 0.0;
double result = fn(a,b,x,n);
cout « "result = " « result « endl;
delete [] a; delete [] b;
return 0;
}
Problem 25. The complete elliptic integral of the first kind is
vt A r / 2 
de 
r1 
dt
K(m) = / 
, 
= / 
,
Jo 
V l - sin2 a sin2 0 
Jo ^(1 - i2)(l - mi2)
where m € [0,1), k = sin a and k2 = m. The elliptic integral can be
computed using the method of the arithmetic geometric mean. We start
with the initial values
ao = 1, 
b0 = y/l — m, 
Co — y/m.
We compute successive iterations of CLJ , bj and Cj with
aj = 2^aj-1 
+ bj-^' 
bj = K-i 6J-!) 1 / 2. 
ci = 2^aj-1 ~ 
bj-^

Numerical Techniques 237
stopping at iteration n, when cn as 0 within the tolerance specified by e.
The complete elliptic integral of first kind is then
Write a C++ program that implements this algorithm.
Solution 25. In the program we set m = 1/2. Thus k — l/\/2 and from
sin a = fc we find a = TT/4.
// elliptic.cpp
#include <iostream>
#include <cmath>
using namespace std;
int main(void)
•C
double pi = 3.14159265;
double m = 0.5;
double aO = 1.0, bO = sqrt(l.O-m), cO = sqrt(m);
double eps = 0.0001;
double al, bl, cl;
while(fabs(cO) > eps)
{
al = (aO + b0)/2.0;
bl = sqrt(a0*b0);
cl = (aO - b0)/2.0;
aO = al; 
bO = bl; 
cO = cl;
}
double Kalpha = pi/(2.0*al);
cout « "Kalpha = " « Kalpha;
return 0;
>
Problem 26. 
Let S be a closed set on a complete metric space X. A
contracting mapping is a mapping f : S —> S such that
rf(/(i), f{y)) < kd(x, y), 
0 < k < 1, d is the distance in X.
One also says that "/ is lipschitzian of order k < 1".

238 
Problems and Solutions
Contracting mapping theorem. A contracting mapping / has strictly one
fixed point; i.e., there is one and only one point x* such that x* = f(x*).
The proof is by successive iteration. Let x* £ S, then
f(x0) G 5,..., /("'(a*) = f{f{n-l){xQ)) 
G S
and
d(f^(xo),f{n-1)(xo)) 
< kn-1d(f(x0),x0).
Since k < 1 the sequence /'"^(zo) is a Cauchy sequence and it tends to a
limit x* e S when n tends to infinity
x"= lim / ( n )0r o)= lim f(f(n-l)(xo)) 
= f(x*).
n—»oo 
n—>oo
The uniqueness of x* results from the defining property of contracting map-
pings. Assume that there is another point y* such that y* = f(y*), then
d(f(y*),f(x*)) = d(y*,x*).
On the other hand, d(f(y*),f(x*)) 
< kd(y*,x*), where k < 1. Hence,
d(y*,x*) = 0andy* = z*.
Consider the map / : (0,1] -> (0,1]
f(x) = ^x(l-x).
Obviously, the map / has a stable fixed point x* = 3/5. Write a C++
program that applies the contracting mapping theorem with the initial
value XQ = 9/10.
Solution 26. If the relative difference is less than 10~5, we claim that
a fixed point has been obtained. The numerical value of the mapping
converges to 0.6.
// fixedpoint.cpp
#include <iostream>
#include <cmath>
using namespace std;
double f(double x) { return 5.0*x*(1.0 - x)/2.0; }
int main(void)
{
double t, x = 0.9;

Numerical Techniques 239
double eps = 0.00001;
do { t = x; x = f(x); }
while(fabs(t - x) > eps);
cout « "x = " « x;
return 0;
}
Problem 27. 
We consider the Hilbert space L2[-l/2,1/2]. 
Expand the
step function
/ / - x . _ / - l * e [-1/2,0]
f W - \ 
1x6(0,1/2]
with respect to the Fourier basis
{ <t>k{x) := exp(27ri/cx) : fc G Z }.
In other words, calculate the expansion coefficients (f,<f>k) where
/•1/2
(f(x),g(x)) := / 
f(x)g(x)dx.
J-l/2
Thus, find the Fourier expansion
/(*) = £</(*), <£fc(z))<Afc(z)-
fcez
Solution 27. For k = 0 we have
(f(x),^{x)) = - I dx+ [2 dx = 0.
i-i 
Jo
For fc^Owe have
{f(x),4>k(x)) = - f 
e-2*ikxdx+ f2 e-2vikxdx
J-\ 
Jo
Thus
^ ) = E 
^r:(l-(-l)fc)e2^
kez,k^o 
mK

240 
Problems and Solutions
= 
Yl 
^(l-(-l) f c)(cos(27rfcz)+isin(27r/b:))
fcez.fc^o mk
00 
4
= 
2_^ 
— sin(27rA;a;).
fc=l,fc odd
Problem 28. 
Consider the function / e L2[0,1]
,, . _ f 
cc 
for 0 < x < 1/2
J W - | i _ x f O T l / 2 < a ; < 1
An orthonormal basis in the Hilbert space £2(0,1] is given by
B := I 1, V2cos(7rnx) : n = l , 2 , . . . | .
(i) Find the Fourier expansion of / with respect to this orthonormal basis,
(ii) From this expansion show that we can calculate
2 
°° 
1
T = E(2^ir 
(1)
Solution 28. 
(i) The Fourier expansion is given by
00
/(*) = £;</(*). &.(*)>^(Z)
n=0
where <f>o(x) = 1 and <fin(x) = v^cos(7rna;) with n = 1,2,.... For the scalar
products we have
,1 
,1/2 
,1 
j
</(a;) )l)= / f{x)dx= 
/ 
a«k:+ / 
(1 - a;)da; = -
7o 
Jo 
J1/2 
4
and
(f(x),4>n(x)) 
= v2 / 
xcos(T:nx)dx + \/2 / 
(cos(n7rx) — xcos(n7rx)da;
./o 
J1/2
Thus, for n odd we have (f(x), 4>n(x)) = 0. For n — 2j even (j £ N) we
have
(f(x),cP2j(x)) = ^ ( 2 0 0 8 ^ ) - 2).

Numerical Techniques 241
For j , even (f(x),(f)2j{x)) = 0. For j = 2k + l odd (k e N o) we have
(/W^4fc+2(x)) = - 7 r a ( 2 f c + 1 ) 2 .
Thus, the Fourier epansion yields
(ii) For x = 0 we have /(0) = 0 and cos(0) = 1. Thus
Consequently we obtain (1).
Problem 29. Let H be an arbitrary Hilbert space. Let B := {<j>k : k G
/ } be an orthonormal basis in the Hilbert space W, where / is the countable
index set. Then for all f,g&'H 
we have
fee/
where (/, #) denotes the scalar product in the Hilbert space. The equation
is called Parseval's equality or Parseval's relation. Consider the Hilbert
space H — Z<2[—7T, TT] with the orthonormal basis
Let
f(x) = eicx, 
c 6 R and c g Z .
Use / and Parseval's equality to show that
OO 
n
^ { c - k f 
sin2(c7r)- 
W
Solution 29. If g — f, Parseval's equality reduces to
</./> = ll/lla = £<7^>(/,0fc>.
fce/

242 
Problems and Solutions
For the scalar product we have
{fAk) = f f(x)J^xjdx = ^=£ 
e'Wdx .
Integration yields
Since
a n d
 
r
ll/ll2 = (/,/)= / 
dx = 2w
J—ir
we obtain
2 ^ 
sin2(c7r)
Thus (1) follows.

Chapter 10
Random Numbers and
Monte Carlo Techniques
Problem 1. ANSI C and ANSI C++ include an integer random number
generator. The function srandO initializes the random number genera-
tor (seed). The function randO uses a multiplicative congruential random
number generator with period 232 to return successive pseudo random num-
bers in the range from 0 to RAND_MAX. The symbolic constant RAND_MAX is
denned in stdlib.h and its value is platform dependent. Write a C++
program that generates random numbers in range [0,1] (data type double).
Add code that generates 10 random number in the range 0. . 99 and a
random binary string of length 32.
Solution 1.
// random.cpp
#include <iostream>
#include <cstdlib> / / for srandO, rand()
#include <ctime> 
/ / for time()
using namespace std;
int main(void)
-C
srand((unsigned long) time(NULL)); // seed
double x = (double) randO ;
243

244 
Problems and Solutions
double m = (double) RAND_MAX;
cout « "m = " « m « endl;
double rl = x/m;
cout « "rl = " « rl « endl;
double y = (double) randO ;
double r2 = y/m;
cout « "r2 = " « r2 « endl;
cout « "ten random numbers from 0 to 99 " « endl;
for(int i=0;i<10;i++) { cout « rand()'/.100 « endl; }
cout « "random binary string " << endl;
int* bstr = new int[32];
for(int j=0;j<32;j++) { bstrfj] = rand()'/.2; >
for(int k=0;k<32;k++) { cout « bstr[k]; }
deleted bstr;
return 0;
}
Problem 2. Write a C++program that provides a seed (unsigned long)
for the function srandO and finds out after how many steps the first ran-
dom number repeats.
Solution 2.
// randrepeat.cpp
#include <iostream>
#include <cstdlib>
using namespace std;
int main(void)
{
unsigned long seed;
cout « "Enter seed for randO : ";
cin >> seed;
srand(seed);
unsigned long first = rand();
unsigned long i = 0;
while (randO != first) ++i;
cout << "Random number " << first << " repeats after "
« i « " steps" « endl;

Random Numbers and Monte Carlo Techniques 245
return 0;
}
Problem 3. 
The generation of uniform sampling points on the sphere
x2 + y2 + z2 = R? can be done as follows. Choose a random number
s uniformly distributed in the interval [—1,1] and a random number </>
uniformly distributed in [0, 2-K]. The x, y, and z coordinates of the point
on the sphere are given by
x = R v 1 — s2 cos 4>
y = R v 1 — s2 sin <f>
z = Rs.
The principle underlying this algorithm is that for a sphere of radius R,
the area of a zone of width h is 2[0,2n]Rh, regardless of where the sphere
is sliced. Therefore, the ^-coordinates of random points on the sphere are
distributed uniformly. Points obtained by using this algorithm are then
uniformly distributed on the surface of the sphere. Write a Java program
that generates these points.
Solution 3. 
The method double random () in the Math class of Java
provides a "random number" of data type double in the interval [0,1]
uniformly distributed. To obtain random numbers for the interval [—1,1]
we have to scale by 2 and translate by —1 (i.e., 2r — 1) and to obtain random
numbers in the interval [0,2TT] we have to scale by 2nr, where r G [0,1].
// SphereRandom.j ava
class SphereRandom
{
public static void main(String[] args)
{
double R = 1.0;
double rl = Math.random();
double s = 2.0*rl-1.0;
double r2 = Math.random();
double phi = 2.0*Math.PI*r2;
double x = R*Math.sqrt(1.0-s*s)*Math.cos(phi);
double y = R*Math.sqrt(1.0-s*s)*Math.sin(phi);
double z = R*s;
System.out.printlnC'x = " + x);
System.out .printlnC'y = " + y);

246 
Problems and Solutions
System.out.println("z = " + z);
double square = x*x + y*y + z*z;
System.out.printIn("square = " + square);
}
>
Problem 4. 
A very simple technique to generate pseudo random num-
bers, is to use a generalized feedback shift register (shift register algorithm).
A generalized feedback shift register produces random bits from a register
of p bits. Everytime a new random bit is needed, the register is shifted to
produce output and certain bits are XORed with other bits. For example
an = an_103 XOR an_250
for a random number generator. Here XOR denotes the bitwise exclusive
OR operation. We can simplify the algorithm if we only allow the output to
be XORed with other bits. Thus, we have a set of p bits a^, k — 0,1,... ,p
generated in advance somehow, where ap is the last bit. Now we perform
the shift operation
ak := a/t_i, 
a0 := 0
for k = 1,2,... ,p. The output bit is aout := ap+1. After the shift operation
has been performed, we XOR certain positions with the output. Let these
q positions be x\, X2,..., xq. Then
a-xq '•= « i , © a-out •
— • 
i 
» o 
-^^-» 
o - ^ ^ - * 
o 
— *
output
0 
1
2 
3
For example, let p = 3, x\ = 2 and x<x — 3. If we run the feedback shift
register algorithm, we get:
Round 
Cell 0 
Cell 1 
Cell 2 
Cell 3
1
1
0 
0 
0
2 
0 
1
0 
0
3 
0 
0 
1
0
4 
0 
0 
0 
1
5 
1
0 
1
1
6 
1
1
1
0
7 
0 
1
1
1

Random Numbers and Monte Carlo Techniques 247
Write a C++ program for a feedback shift register with p = 19 and x\ = 0,
x2 = 2, x3 = 4, Xi = 6, x5 = 7, x6 — 14, x7 = 17 and xs = 19. Use the
feedback shift register to generate 100 16-bit pseudo random numbers.
Solution 4. The function fsr_bit() obtains the next bit from the feed-
back shift register. The function rnd() uses the bits from the feedback
register to construct a random integer.
/ / gfsr.cpp
#include <iostream>
#include <bitset>
using namespace std;
bitset<20> a;
int x[] = { 0,2,4,6,7,14,17,19 };
const int NXOR = 8;
int fsr_bit(void)
{
int i;
int output = a[19];
/ / shift
for(i=19;i>0;i—) a[i] = a[i-l] ;
a[0] = 0;
/ / feedback
if (output == 1) {.
for(i=0;i<NX0R;i++) { a.flip(x[i]); >
}
return output;
}
int rnd(void)
{
int r = 0;
for(int i=0;i<16;i++) { r *= 2; r += fsr_bit(); >
return r;
}
int main(void)
•C
a.resetO; a.set(19);
cout « "Generating 100 pseudo-random numbers:" « endl;
for(int i=0;i<100;i++)

248 Problems and Solutions
{ cout « rndO « endl; }
return 0;
}
Problem 5. Random numbers with a homogeneous distribution are fairly
easy to create, but for many applications random numbers with a Gaus-
sian distribution are necessary. Convert a random number sequence with
homogeneous distribution into a sequence with a Gaussian distribution.
Solution 5. Given a real valued random number sequence { r,- } with a
normalized, uniform probability distribution in the interval [0,1]
, . , 
(dr 
for 
0 < r < 1
P{r)dr 
= { 0 otherwise
We create a new random number sequence { Sj } by mapping a strictly
monotonous function /(r) onto the sequence {rj }. The probability distri-
bution of the new sequence {SJ} = {f{rj)} is then given by
p(s)ds = p(r) -£ ds. 
(1)
To find the function /(r) for a desired probability distribution p(s) one in-
tegrates both sides of (1) over the interval s e [/(0), /(I)] or s <E [/(I), /(0)]
depending on f(r) being a montonously increasing (i.e., df(r)/dr > 0) or
decreasing (i.e., df(r)/dr < 0) function. Assume that df(r)/dr > 0. We
obtain
fs 
fs 
dr
/ 
dsp(s)= / 
dsp(r) —
Jf(o) 
Jf(o) 
as
. r fl«a
i/(0) 
ds
= f(-1)(S)S 
•
/(0)
Consequently
f^(s)= 
[' dsp(s). 
(2)
Jf(O)
The inverse of (2) renders f(r). The method described fails if one cannot
find a closed or at least numerically feasible form for /(r). This is the
case for the Gaussian distribution. However we can resort to a similar,
two-dimensional approach. In the two-dimensional case we have
p(si,s2)dsids2 =p{ri,r2) 
, *' \ 
dsids2
O(Sl,S2)

Random Numbers and Monte Carlo Techniques 249
where \d(- • •)/#(• • -)l denotes the Jacobian determinant. We obtain Gaussian-
distributed random numbers as follows. One first generates two random
numbers ri and r2 uniformly distributed in the interval [0,1]. The func-
tions
s\ = yj—21nri sin(2?rr2)
52 = \/—2 In r\ cos(2^T2)
render then two Gaussian-distributed numbers si and s2. To verify this,
we note that the inverse is given by
ri=expf-|(fl? + s|)J
1 
. fsA
r2 = —- arctan — .
2?r 
\s2j
We find
, 
. , 
, 
, 
. dri/dsi 
dri/ds2
P(s1,s2)ds1ds2=p(r1,r2) 
^
^ 
^
^
This shows that s\ and s2 are independent Gaussian distributed numbers.
Thus one can employ the equations to produce Gaussian random numbers
two at a time.
Problem 6. To evaluate an integral
/ dx/(x)
with the Monte Carlo method one samples the function / at M homoge-
neously distributed random points r^ in the integration domain Q. The
average of the function values of these random points multiplied by the
volume |fi| of the integration domain fi can be taken as an estimate for the
integral
The more function values /(rjt) are taken into account the more accurate
the Monte Carlo method becomes. The average (/) exhibits a statistical
error proportional to \jyfM. Thus, the error of the numerical integration

250 Problems and Solutions
result is the order O(l/y/~M). Compare the Monte Carlo method to the
trapezoidal rule for integration.
Solution 6. 
The trapezoidal rule approximates a one-dimensional func-
tion / linearly. An approximation over intervals of length h between sam-
pling points is thus correct up to order of f"(x)h2. 
In one dimension, the
length of the integration step h is given by the number of sampling points M
and the length of the integration domain $7 according to h — |f2|/(M + 1).
Hence, the trapezoidal rule is an approximation up to the order of O(l/M2).
Obviously, systematic numerical integration techniques are superior to the
Monte Carlo method. However, the rating is different for integrals on higher
dimensional domains. Consider an integration domain in n-dimensions. A
systematic sampling would be done over an n-dimensional grid. A total
of M sampling points would result in \/M sampling points in each grid
dimension. The trapezoidal rule would, thus, be correct up to the order of
O(M~2/n). 
A random sampling, however, is not effected by dimensional
properties of the sampling domain. The Monte Carlo precision remains
in the order of O(M~1^2). Hence, we see that the Monte Carlo method
becomes feasible for (n = 4) dimensions and that it is superior for high-
dimensional integration domains Q.
Problem 7. Let / : [0,1] —> [0,1] be a continuous function. We consider
/ = f f{x)dx.
Jo
We choose N number pairs (XJ,VJ) with uniform distribution and define z3
by
_ JO i{yj>f(xj)
Z i - \ l i?yj<f(Xj) •
Putting n := X^=i zh w e n a v e n/N ~ I- More precisely, we have
I=± 
+ O{N-1'*).
The accuracy is not very good in one dimension. The traditional formulas,
such as Simpson's formula, are much better. In higher dimensions, the
Monte Carlo is favourable, at least if the number of dimensions is n > 6.
It is more natural to consider the integral as the mean value of (£) where £
is uniform, and then estimate the mean value from

Random Numbers and Monte Carlo Techniques 251
Write a C++ implementation for Monte Carlo integration. Evaluate
/ sm(x)dx = 0.459697694132.
Jo
Solution 7. We are using the "random number generator" for the interval
[0,1]
f(x) = (IT + xf 
mod 1.
// MonteCarlo.cpp
•include <iostream>
#include <cmath>
using namespace std;
void randgen(double* x)
{
double PI = 3.1415926535;
*x = fmod((*x+PI)*(*x+PI)*(*x+PI)*(*x+PI)*(*x+PI),1.0) ;
>
double sum(double (*f)(double),int n)
{
double u = 0.618;
double result =0.0;
for(int i=0;i<n;i++) { randgen(&u); result += f(u); }
return result/n;
}
double f(double x) { return sin(x); }
int main(void)
{
double value;
int n = 10000;
value = sum(f,n);
cout << "value = " << value;
return 0;
>
Problem 8. 
A popular approach for generating a pseudorandom bit
sequence is given by the Blum, Blum, Shub generator or BBS generator.

252 Problems and Solutions
Let p and q be two large prime numbers such that
p mod 4 = q mod 4 = 3.
Setting n = pq and selecting s relatively prime to n, the pseudo random
bit sequence B1B2B3 ... is obtained from
1. Set Xo := s2 mod n.
2. For i= 1,2,...
Xi := Xf_1 mod n
Bj := Xi mod 2
The BBS generator is cryptographically secure in the sense that it passes
the next-bit test, i.e., there is no polynomial time algorithm that (given
the previous bits of the sequence) can predict the next bit of the sequence
with probability greater than \. Give a C++ implementation of the BBS
generator using p = 383, q = 503 and s = 101355.
Solution 8. 
We use the Verylong class of SymbolicC++ to support
integers of larger magnitude than supported by the C++ implementation.
The function bbsgO is a template function which returns a bit set with
bits generated using the BBS generator. Since the display of a bitset starts
with the most significant bit, we fill the bitset in reverse order.
// bbs.cpp
#include <iostream>
#include <bitset>
#include "verylong.h"
using namespace std;
template <const size_t 1>
bitset<l> bbsg(void)
{
Verylong n = 192649;
Verylong s = 101355;
Verylong X = s*s°/,n;
Verylong two = 2;
bitset<l> b;
for(int i=l-l;i>0;i—)
{ X = X*X'/,n; b.set(i,int(X'/.two)); }
return b;
}

Random Numbers and Monte Carlo Techniques 253
int main(void)
{
cout « bbsg<20>() « endl;
return 0;
}
Problem 9. 
Write a C++ program which implements the multidimen-
sional Monte Carlo quadrature to integrate
/•bo 
t-bi 
fbn-i
/ 
/ 
. . . / 
v{xo,xi,...,xn-.{)dxn-idxn-2---dxa.
Let n be the dimension of the domain on which the function v is to be
integrated. Let a and b are the lower and upper bounds, respectively for
the integrals over each of the dimensions. Let esq be the square of the
error tolerance and m+n is the number of samples used for the Monte Carlo
integration. Denote by Vab the volume being integrated.
Solution 9. In the following C++ implementation we use rn() to gener-
ate random numbers on the interval [0,1]. The function quadmcO imple-
ments the multidimensional Monte Carlo quadrature. As an alternative for
rnO we can use the sequence xn+i = (xn + TT)5 mod 1.
double rn(void)
{
static double x = 0.1;
static const double pi = 3.14159265358979323846;
x = (x + pi);
x = x*x*x*x*x;
x = x - floor(x);
return x;
}
The implementation using the C++ random number generator randO is
given below.
/ / quadmc.cpp
#include <iostream>
#include <iomanip>
#include <vector>
#include <cmath> 
// for fabsO
#include <cstdlib> // for srandO
#include <ctime> 
// for timeO

254 
Problems and Solutions
using namespace std;
double rn(void)
{
static int init = 1;
if(init)
{
srand(time(NULL));
init = 0;
}
return double(rand())/RAND_MAX;
}
double quadmc(int n,vector<double> &a,vector<double> &b,
double (*v)(const vector<double>&).double esq.int m)
{
if(m < n) m = n;
int 1, itemp, ir, k, i;
double vbar, ssq, gm, vi, vip, vsqbar, Vab = 1.0;
vector<int> it(m);
vector<double> x(n);
for(i=0;i<n;i++) Vab *= fabs(b[i]-a[i]);
for(i=0;i<m;i++) it[i] = i;
1 = 0;
vsqbar = vbar = gm = 0;
for(i=0;i<m;i++)
{
for(k=0;k<n;k++)
x[k] = a[k] + rn()*(b[k]-a[k]);
vi = v(x); vbar += vi; vsqbar += vi*vi;
if(i < n)
{
if(x[i] < (b[i] + a[i])/2)
x[i] += fabs(b[i]-a[i])/2;
else x[i] -= fabs(b[i]-a[i] )/2;
vip = v(x); vbar += vip; vsqbar += vip*vip;
if (gin < fabs(vip - v i ) ) { 1 = i; gm = fabs(vip-vi); }
}
}
vbar /= (m + n);
vsqbar /= (m + n ) ;
ssq = Vab*Vab*(vsqbar-vbar*vbar)/(m+n-l);

Random Numbers and Monte Carlo Techniques 255
if(ssq <= 2*esq) return vbar*Vab;
double temp, cl, al, bl;
m = int(m/sqrt(2.0));
if(m < ssq/esq) m = int(ssq/esq);
esq = esq*ssq/(ssq-esq);
al = a[l]; bl = b[l] ;
b[l] = cl = (bl + al)/2;
temp = quadmc(n,a)b,v,esq/2,m);
b[l] = bl; a[l] = cl;
temp = quadmc(n,a,b)v,esq/2,m) + temp;
a[l] = al;
return (temp*ssq + esq*vbar*Vab)/(ssq+esq);
}
double sin(const vector<double> &x)
{
if(x[0] > 0.0 && x[0] <= 1.0) return sin(x[0]);
return 0.0;
}
double unit_circle(const vector<double> &x)
{
if (x[0]*x[0]+x[l]*x[l] < 1.0) return 1.0;
return 0.0;
}
double unit_cube(const vector<double> &x)
{
for(int i=0;i<3;i++)
if(x[i] < 0.0 II x[i] > 1.0) return 0.0;
return 1.0;
>
double unit_sphere(const vector<double> &x)
-C
if(x[0]*x[0]+x[l]*x[l]+x[2]*x[2] < 1.0) return 1.0;
return 0.0;
>
double f(const vector<double> &x)
<
if(x[0]*x[0] <= x[l] && x[l] <= sqrt(x[0])) return 1.0;
if(x[0]*x[0] >= x[l] && x[l] >= sqrt(x[0])) return 1.0;

256 
Problems and Solutions
return 0.0;
}
int main(void)
{
vector<double> a(3);
vector<double> b(3);
a[0] = 0.0; b[0] = 1.0;
cout « "Int(sin(x),0,1) = "
« setprecision(4) 
/ / accuracy sqrt(le-6) = le-3
« quadmcd.a.b.sin.le-S, 10000) « endl;
a[0] = a[l] = -1.0; b[0] = b[l] = 
1.0;
cout << "Area of the unit circle = "
<< setprecision(4) 
/ / accuracy sqrt(le-6) = le-3
« quadmc(2,a,b,unit_circle)le-6,10000) « endl;
a[0] = a[l] = a[2] = 0.0; b[0] = b[l] = b[2] = 1.0;
cout « "Volume of the unit cube = "
<< setprecision(4) 
/ / accuracy sqrt(le-6) = le-3
« quadmcO.a.b.unit.cube.le-e,10000) « endl;
a[0] = a[l] = a[2] = -1.0; b[0] = b[l] = b[2] = 
1.0;
cout << "Volume of the unit sphere = "
« setprecision(4) 
/ / accuracy sqrt(le-6) = le-3
« quadmc(3,a,b,unit_sphere,le-6,10000) « endl;
a[0] = a[l] = 0.0; b[0] = b[l] = 1.0;
cout « "Area between sqrt(x) and x~2 = "
« setprecision(4) 
// accuracy sqrt(le-6) = le-3
« quadmc(2,a,b,f,le-6,10000) « endl;
return 0;
}
Problem 10. Annealing is the process of cooling a molten substance with
the objective of condensing matter into a crystaline solid. Annealing can
be regarded as an optimization process. The configuration of the system
during annealing is defined by the set of atomic positions r^. A configuration
of the system is weighted by its Boltzmann probability factor,
e-E(ri)/kT
where E(ri) is the energy of the configuration, k is the Boltzmann con-
stant, and T is the temperature. When a substance is subjected to an-
nealing, it is maintained at each temperature for a time long enough to
reach thermal equilibrium. The iterative improvement technique for com-
binatorial optimization has been compared to rapid quenching of molten
metals. Rapid cooling results in metastable system states; in metallurgy,

Random Numbers and Monte Carlo Techniques 257
a glassy substance rather than a crystalline solid is obtained as a result
of rapid cooling. The analogy between iterative improvement and rapid
cooling of metals stems from the fact that iterative improvement and rapid
cooling of metals accepts only those system configurations which decrease
the cost function. In an annealing process, a new system configuration
that does not improve the cost function is accepted based on the Boltz-
mann probability factor of the configuration. This criterion for accepting a
new system state is called the Metropolis criterion. The process of allowing
a fluid to attain thermal equilibrium at a temperature is also known as the
Metropolis process. Simulated annealing essentially consists of repeating
the Metropolis procedure for different temperatures. The temperature is
gradually decreased at each iteration of the simulated annealing algorithm.
If the initial temperature is too low, the process gets quenched very soon
and only a local optimum is found. If the initial temperature is too high,
the process is very slow. Only a single solution is used for the search and
this increases the chance of the solution becoming stuck at a local opti-
mum. The changing of the temperature is based on an external procedure
which is unrelated to the current quality of the solution, that is, the rate of
change of temperature is independent of the solution quality. The anneal-
ing mechanism can also be coupled with the quality of the current solution
by making the rate of change of temperature sensitive to the solution qual-
ity. Write a C++ program which applies simulated annealing to find the
minimum of the function
f(x) = x2exp(—x/15)sin:c.
Solution 10. W e consider the x range [0,100].
// annealing.cpp
#include <iostream>
#include <cmath>
#include <cstdlib>
#include <ctime>
using namespace std;
double f(double &x) { return sin(x)*x*x*exp(-x/15.0); }
int accept(double feEcurrent,double feEnew,double &T,double &s)
{
double dE = Enew - Ecurrent;
double k = 1380662e-23;
if(dE < 0.0) return 1;
if(s < exp(-dE/(k*T))) return 1;

258 Problems and Solutions
else return 0;
}
int main(void)
•C
cout << "Finding the minimum via simulated annealing:"
« endl;
double xlow =0.0, xhigh = 100.0;
double T, Tmax = 500.0, Tmin =1.0, Tstep =0.1;
srand(time(NULL));
double s = rand()/double(RAND_MAX);
double xcurrent = s*(xhigh - xlow);
double Ecurrent = f(xcurrent);
for(T=Tmax;T>Tmin;T-=Tstep)
{
s = rand()/double(RAND.MAX);
double xnew = s*(xhigh - xlow);
double Enew = f(xnew);
if(accept(Ecurrent,Enew,T,s))
{
xcurrent = xnew; Ecurrent = Enew;
}
>
cout « "The minimum found is " « Ecurrent « " at x = "
« xcurrent << endl;
return 0;
>
Two typical outputs are given below.
Finding the minimum via simulated annealing:
The minimum found is -121.796 at x = 29.8397
Finding the minimum via simulated annealing:
The minimum found is -121.749 at x = 29.874
The global minimum of / is found as one of the solutions to the transcen-
dental equation
/ *x 
1 5 x *
t a n ( x } = 
x^SO
in the interval [0,100] with x* « 
^-.

Random Numbers and Monte Carlo Techniques 259
Problem 11. 
The Ising model is a simple model for magnetism. The
classical approximation to an atomic or electronic magnetic moment is pro-
vided by an Ising spin which can take two values
_ / +1 spin up
J 
[ — 1 spin down
A two-dimensional magnet can be modeled by a set of N spins located on a
fixed two-dimensional lattice of sites. We consider a square lattice. Assume
that we have a square lattice with Nx spins in the ^-direction and Ny spins
in the y direction such that N = NxNy. We assume that Nx = Ny. The
interaction energy (Hamiltonian) is given by
E = —J^~]siSj — HS^Si.
(ij) 
i
The first sum is over nearest neighbor pairs of spins. There are four nearest
neighbors of a given lattice site. We assume periodic boundary conditions
for the x and y direction. If the dimensionsless coupling constant is J > 0
the system is ferromagnetic, i.e., the energy is minimized if the spins point in
the same direction SjSj = +1. If J < 0 the system is antiferromagnetic. H
represents an external magnetic field which couples to the magnetization
M := X2isi- The spins prefer to line up with the magnetic field. The
average magnetization and average energy at some fixed temperature kT is
given by
Y" 
t 
Me~ElkT 
V 
Ee~ElkT
Ijurx _ £-con figs 
,rn 
l^configs 
- C / e
\ 
' 
y^ 
p-E/kT 
' 
\ 
' 
y 
e-E/kT 
"
/—iconfigs 
^—tconfigs
To simulate the Ising model at constant temperature in the canonical en-
semble we use the Metropolis algorithm. The algorithm is as follows.
1. Create an initial state: a random initial configuration of of spins. Cal-
culate the energy E.
2. Make a random trial change in the state: choose a spin at random and
flip it, Si —> —s^
3. Compute AE = Etriai — Eoia, the change in the energy of the system
owing to the trial change.
4. If AE < 0, accept the new state and go to step 8.
5. If AE > 0, compute the Boltzmann weighting factor w = 
exp(-AE/ksT).
6. Generate a random number r in the unit interval [0,1].
7. If r < w, accept the new state, otherwise retain the previous state.
8. Determine the values of the physical quantities, i.e., (M) and (E).
9. Repeat steps (2) through (8) to obtain a sufficient number of states.
10. Periodically compute averages over states.

260 
Problems and Solutions
(i) What are the number of configurations for the Ising model with N lattice
sites. What is the total number of nearest neighbor pairs for an Nx x Nx
lattice with periodic boundary conditions?
(ii) Write a C++ program that implements the Metropolis algorithm.
Solution 11. (i) The total number of configurations is 2N. If for example
Nx = Ny = 20. Then N = 400 and we find
2N = 2400 = 2 gg . 1Q120
The total number of nearest neighbor pairs is 2NXNX.
(ii) The Boltzmann factors are pre-computed for the given fixed T and H.
// Metropolis.cpp
#include <iostream>
#include <cmath>
#include <cstdlib>
#include <ctime>
using namespace std;
double J = 1.0; // couping constant ferromagentic
int Nx = 60; 
// size in x direction
int Ny = 60; 
// size in y direction
int N = Nx*Ny; 
// number of lattice sites
double T = 0.1; // temperature
double H = 0.0; // magnetic field
int** s; 
// spins for two-dimensional lattice
double w[17] [3]; // Boltzmann factors
int steps = 0;
double randOlQ 
/ / random number in [0,1]
{
double x = (double) randQ;
double y = (double) RAND.MAX;
return x/y;
}
void factors()
{
for(int i=-8;i<=8;i+=4)
{
w[i+8][0] = exp(-(i*J+2.0*H)/T);
w[i+8][2] = exp(-(i*J-2.0*H)/T);

Random Numbers and Monte Carlo Techniques 261
>
}
void initialize() // allocating memory
{
s = new int* [Nx];
for(int k=0;k<Nx;k++) s[k] = new int[Ny];
for(int i=0;i<Nx;i++)
for(int j=0;j<Ny;j++) // initial random configuration
s[i][j] = -1 + 2*(rand()'/.2);
f actorsO ;
}
bool metropolisStepO
{
int i = rand()7.Nx; int j = rand()'/,Ny; // random spin
int iPrev = i == 0 ? Nx-1 : i-1;
int iNext = i == Nx-1 ? 0 : i+1;
int jPrev = j == 0 ? Ny-1 : j-1;
int jNext = j == Ny-1 ? 0 : j+1;
int sumNeighbors =
s[iPrev][j] + s[iNext] [j] + s[i][jPrev] + s[i][jNext];
int delta_ss = 2*s[i][j]*sumNeighbors;
double ratio = w[delta_ss+8][l+s[i][j]];
if(randOK) < ratio)
{
s[i][j] = -s[i][j];
return true;
}
else return false;
}
void oneMonteCarloStepPerSpin()
{.
int accepts = 0;
for(int i=0;i<N;i++)
if (metropolisStepO) accepts++;
++steps;
}
double magnetizationPerSpinO
{

262 
Problems and Solutions
int sSum = 0;
for(int i=0;i<Nx;i++)
for(int j=0;j<Ny;j++)
sSvim += s[i] [j] ;
return sSum/((double) N);
}
double energyPerSpinO
•C
int sSum = 0, ssSum = 0;
for(int i=0;i<Nx;i++)
for(int j=0;j<Ny;j++)
{
sSum += s[i] [j] ;
int iNext = i == Nx-1 ? 0 : i+1;
int jNext = j == Ny-1 ? 0 : j+1;
ssSum += s[i] [j]*(s [iNext] [j] + s[i] [jNext] );
}
return -(J*ssSum + H*sSum)/((double) N);
}
int main(void)
{
srand((unsigned) time(NULL));
int noSteps;
cout << "Enter number of steps: ";
cin >> noSteps;
initialize();
int thermSteps = (int) (0.2*noSteps);
for(int s=O;s<thermSteps;s++) oneMonteCarloStepPerSpinO;
double m = 0.0, e = 0.0;
for(int k=0;k<noSteps;k++) { oneMonteCarloStepPerSpinO; >
m = magnetizationPerSpinO; cout << "m = " << m << endl;
e = energyPerSpinO; cout « "e = " « e « endl;
return 0;
}

Chapter 11
Ordinary Differential
Equations
Problem 1. 
Consider the Cauchy problem for the logistic differential
equation
— = S(u), 
S(u) := u(l - u)
at
where u(0) = uo with uo > 0. Its solution is monotone, has a stable
fixed point (steady-state solution) u* = 1 for every positive initial data UQ.
Fixed points of a differential equation du/dt = S(u) are the solutions of the
equation S{u*) = 0.
(i) Apply the explicit Euler method
un+i = un + TS(un)
to t h e differential equation, where n = 0 , 1 , . . . .
(ii) Apply the Leap-frog method
un+i = un-i 
+2TS(UU)
to the differential equation.
(iii) Apply the Adams-Bashforth method
Un+i = un + - (3S(un) - 
S(un-i))
to the differential equation.
263

264 Problems and Solutions
(iv) Apply the modified explicit Euler method
un+1 =un + rS [un + -S(un)J
to the differential equation.
(v) Apply the improved Euler method
un+1 =un + ^ (S(un) + S(un + rS(un)))
to the differential equation.
(vi) Apply the fourth order accurate Runge-Kutta method
un+1 = un + - (ki + 2k2 + 2k3 + fc4)
D
kx = S(un)
k2 = S\un + -fcij
k3 = s(un + -fc2j
fc4 = S(un + Tfc3)
to the differential equation.
Solution 1. (i) The explicit Euler method gives a stable asymptote u* = 1
only if 0 < UQ < 1/r and for T < 2.
(ii) The Leap-frog method gives chaotic solutions for all r > 0, although it
is symplectic area-preserving.
(iii) The Adams-Bashforth method gives the stable steady-state solution
u* = 1 only when 0 < r < 1.
(iv) The modified explicit Euler method gives the correct steady state so-
lution only for parameter r from a limited region.
(v) The improved Euler method gives the correct steady state solution only
for parameter r from a limited region.
(vi) The fourth order accuarte Runge-Kutta method gives the correct steady
state solution only for parameter T from a limited region.
Problem 2. Consider a one particle system with canonical space variable
(q,p) and Hamilton function
H(P,q) = ^ 
+ Viq).
The Hamilton's equations of motion are given by
dq _dH 
dp _ 
dH
~dt ~ ~dp' 
~di ~ ~~dq '

Ordinary Differential Equations 
265
A first attempt at time discretization of Hamilton's equations of motion
with step size r might be the simplest finite differencing scheme
dH{qn,pn)
dpn
Pn+l =Pn~ T 
y~ 
.
What is the problem with this discretization?
Solution 2. This discretization does not preserve the Poisson bracket
if \ =?l dg_dl dg
U'9t' 
dp' dq 
dq'dp
under evolution. The order T2 term does not vanish unless V(q) = 0.
To rectify this it is necessary to introduce higher order terms in T in the
defining equations of the discretization.
Problem 3. Consider the autonomous second-order ordinary differential
equation
d x 
, . dx 
,, .
A » + * ( * ) ^ + / ( * ) = 0
where g and / are analytic functions. The equation can be written as a
system of first-order differential equations
^ = x 2 = V 1 ( x 1 ) x 2 )
-^ = -9{xi)x2 - /(xi) = V2(xi,x2).
In Lie series technique to solve this system we consider the vector field
V = Vi(xi,x2)-^- + 
V2(xux2)^-
OXi 
OX2
= 
X2jx-1
+i~g{Xl)X2~f{Xl))^~2
given by this system of differential equations. Then for sufficiently small t
the solution of the initial value problem is given by the Lie series
Xi(t) = e t VXi| I 1 = x l(0),i 2 = a: 2(0), 
X2(t) = etV/:T2U1=Xl(0),x2=x2(0) •
In the standard approximation etv is expanded up to a certain order in t.
Here we consider the approximation
etv = et(v1+v2) ~etvietv2

266 Problems and Solutions
where Vi := V1(xi,x2)d/dxi 
and V2 := V2(xi,x2)d/dx2. 
This is an ap-
proximation since
[tV!,tV2]^0.
However for sufficiently small t it provides a good enough approximation.
(i) Find xi(t) and x2(t) with this approximation.
(ii) Consider the special case g(x) = e(x2 - 1), f(x) = x. This is the van
der Pol equation with e = 10.
(iii) Write a Java program that implements this approximation.
Solution 3. (i) We have
etv*xx = e«(-9(«i)*2-/(*2))a/sl2a;i = Xi
etv*etV*xi=etVl
Xl 
= etx'a/ax*xi 
= xx+tx2
etv*x2 = e«(-9(»i)«2-/(«i))a/8^X3 = x2e-^M 
+ / ( n ) 6 " * ^ ' 0 " 1
5(«i)
etVletV2x2 = X2c-*»("+te») + f(Xl + tx2)—, 
^
g(xx + tx2)
Here we used that if fti(x) and /i2(x) are analytic functions then we have
e'v/»i(x)/i2(x) - /u(etVx)/i2(etVx).
Obviously the operator etV is also linear. We can also write
etv^v'x2 
= x2e-^ - tf(z) ( l - |ff(*) + ^ 3
2(z) - • • •)
where z = x\ + tx2. Thus we obtain the map
ii(t) = ii(0)+te2(0)
, . ,, 
fe-«s(^i(O) _ i)
x a ( 0 = » a ( 0 ) e - ^ W > + / ( x l W ) (
 
fl(8i(t)) 
]
or
zi(*) = zi(0)+ta2(0)
x2(t) =x2(0)e-t9(s^t» - t/(x!(t)) ( l - ^(xi(t)) + ^ 2(x!(t)) - • • •)
(ii) For f(x) = x and t/(x) = e(i2 - 1) we have
z1(t)=a:i(0) + tX2(0)
/•p-tc(x?(t)-l) 
i\

Ordinary Differential Equations 
267
(iii) The program contains an if condition so that we can filter the tran-
sients.
/ / Lie.Java
import j ava.awt.*;
import j ava.awt.event.*;
import Java.awt.Graphics;
public class Lie extends Frame
•C
public Lie()
{
setSize(600,500);
addWindowListener(new WindowAdapter()
{ public void windowClosing(WindowEvent event)
{ System.exit(0); }});
}
public void paint(Graphics g)
{
g.drawRect(40,50,500,440);
double eps = 1.0;
double xl, x2, xll, x22;
double tau, count;
tau = 0.005; count =0.0;
xll = 0.5; x22 = 0.5; // initial conditions
while(count < 1000.0)
{
xl = xll; x2 = x22;
xll = xl + tau*x2;
double temp = Math.exp(-tau*eps*(xll*xll - 1.0));
x22 = x2*temp + xll*(temp - 1.0)/(eps*(xll*xll - 1.0));
if(count > 1.0) // for transients to be decayed
-C
int m = (int) (30.0*xl + 250);
int n = (int) (30.0*x2 + 250);
int ml = (int) (30.0*xll + 250);
int nl = (int) (30.0*x22 + 250);
g.drawLine(m,n,ml,nl);
}

268 Problems and Solutions
count += tau;
} // end while
}
public static void main(String[] args)
Frame f = new Lie();
f. setVisible(true);
}
}
Problem 4. We extend the differential equation described in the previous
problem to
d?x 
, . dx 
„, . 
. . .
-^+9{x)-+f{x) 
= h{t)
where h(t) = k cos{uit) is an external force. We can write this equation as
an autonomous system of first-order differential equations
— i = X 2 = Vi (£1,0:2,0:3)
at
—- = -g(xi)x2 - f(xi) + fccos(a;3) = V2(a;i,X2,X3)
at
dxa 
. 
.
—— =u) = 
V3(xi,x2,x3).
at
Thus we have the vector field
V = V1(x1,x2,x3)£- + V2(x1,x2,x3)-^- + V3(x1,x2,x3)-^
= 
X^1
+{-
9iXl)X2-
nXl))£2-
+UJlk
given by this system of differential equations. Apply the method described
in the previous problem to this system.
Solution 4. We have
[
Fl(Xl'
:E2'
X3)^'
W^3"]
=0
and
[v2(x1>x2,X3)^)W^]=a;ifcsin(a:3)^.
We use the approximation
etv*etv*etv*etv*.

Ordinary Differential Equations 269
We find
eW2Xl 
=et(-9(xi)x2-f(x2)+kcos(x3))d/dx2Xi 
_ ^
etVletV'x1 = etVlxx = etx'd'dxix1 
= Xl + tx2
etV*etV>etV>x1=x1+tx2
e
tV*x2 = 
et(-g(x1)x2-f(xi)+kcos(x3))a/ax2X2
p-tg(xi) _ 1 
ptg(xi) _ 1
= x2e-*^*>) + /(*i) 
r-r— +kcos(x3) — —
fl(zi) 
9{xi)
p—tg(xi+tx2) _ 1
etVl etv*x2 = x2e-t<>^+tx^ +f(xx+ tx2) ^— 
- ^
g{xi +tx2)
etg(xi+tx2) _ l
+fcCOs(,3) 
g { x i + t x 2 )
e-tg(x\+tX2) _ 1
etv3etvletv2x2 
=X2e-tg(xi+tx2) 
+ f(Xl+tx2)e 
L
g(xi + tx2)
etg(xi+tx2) _ j
+k cos(x3 + ut)—-; 
.
g(xi+tx2)
Thus we obtain the map
x3(t) = x3(0) + wt
x1(t) = x1(0)+tx2(0)
, 
u.. 
(e-tg(xi(t)) _ 2 \
x2(t) = l2(0)e-*<*'<*» + /(X!(t))(e
 g ( g i ( f ) ) 
l j
(e«s(^i(*)) _ i)
+ fcC0s(X3(t))^ g ( g i ( f ) ) i .
For /(x) = x and ^(x) = e(x2 - 1) we have
x3(t) = x3(0) + ujt
x1(t)=x1(0)+tx2(0)
x.w^«»--!'-'-»+x,w-('";^'.'"-i)
e^Xj^tj — ij
et£(x?(t)-l) _ 1
+ 
fcC0s(x3(t))-R^-Ir.
Problem 5. The Verlet algorithm is a method for integrating second
order ordinary differential equations
d2x
tfT = F(x(t),t).

270 Problems and Solutions
The Verlet algorithm is used in molecular dynamics simulations. It has a
fixed time discretization interval h and it needs only one evaluation of the
force F per step. The algorithm is derived by adding the Taylor expansions
for the coordinates x at t = ±h about t
x(*) =. x(0) + h*gl + ^F(x(0),0) 4 ^ 2 + O(*«)
*<-*) =*<0) - >*g. + £FMP>.0) - ^ ^ P + o(k<>
leading to
x(h) = 2x(0) - x(-h) + /i2F(x(0), 0) + O(h4).
Knowing the values of x at time 0 and —h, this algorithm predicts the
value of x(h). Thus we need the last two values of x to produce the next
one. If we only have the initial position x(0) and initial velocity v(0) at
our disposal, we approximate x(/i) by
x(/i) « x(0) + ftv(0) + yF(x(0), 0)
i.e., we set
= x(0)-x(-JQ
h
Discuss the Verlet method for the one-dimensional harmonic oscillator
where Q is a constant frequency.
Solution 5. For the one-dimensional harmonic oscillator we find
x(t + h) = 2x{t) - x{t -h)- 
h2n2x{t).
The analytic solution to this difference equation can be written in the form
x(t) = exp(iut)
with u> satisfying the condition
2-2cos(w/i) = h2Cl2.
If h2fi? = (hQ,)2 > 4, the frequency u> becomes imaginary, and the analyti-
cal solution becomes unstable. Thus it is useful to introduce a dimensionless
time T via
X(r(t))=x(t)

Ordinary Differential Equations 271
Then the linear differential equation for the harmonic oscillator takes the
form
d2x
dr1
Problem 6. Runge-Kutta methods were developed to avoid the compu-
tation of high order derivatives which the Taylor method may involve. In
place of these derivatives extra values of the given function g(u, t) are used
in a way which essentially duplicates the accuracy of a Taylor polynomial.
Suppose that the initial-value problem
- ^ = g(u,t), 
u(i = 0) = u<,
for an autonomous system of ordinary differential equations of first order
is to be integrated, where u(to) = uo . We present the formulas on which a
Runge-Kutta-Fehlberg method of order five is based. A typical integration
step approximates u at t = to + h, where h is the step length. The formulas
are
5
u{t) = uo + hYJCkE(k), 
t = to + h
fc=o
with
fc-i
g(0) = g(uo), 
g(fc) = g(uo + h £ 
6fcigW>).
Thus u(t) approximates the exact solution. The coefficients CQ, C\, ..., c$
are
16 
6656
C ° - 1 3 5 ' 
C l " ° ' 
C2~ 
12825'
_ 28561 
_ 
9 
2
C 3 ~ 56430' 
C 4 ~ ~ 5 0 ' 
C 5 ~ 5 5 '
The coefficients for bjk (j = 0,1,..., 5, k = 0,1,..., 4) are
&00 = ^01 = ^02 = ^03 — ^04 = 0
^10 = T, 
&11 = b\2 — &13 = bu = 0
3 
9
ho = ™, 
b2i = — , 
622 = &23 = 624 = 0
, 
1932 
-7200 
7296
630 =2197' 
631 = ^ 1 9 T ' 
6 3 2 = 2 1 9 7 ' 
hz 
= h i = °
, 4 3 9 
3680 
845
640 " 2 1 6 ' 
6 « = - 8 ' 
b42 = ^ - ' 
643 = -4104' 
& 4 4 = °

272 
Problems and Solutions
h 
8 
U 
O 
A 
3 5 4 4 
A 
1 8 5 9 
,. 
U
650 - " 2 7 ' 
& 5 1 = 2 ' 
&52 = "2565' 
& 5 3 = 4 1 0 4 ' 
654 = ~40"
Apply the method to the Lorenz model
dui
— 
=(T(W2 - M l )
du2
—— = -U1U3, + rui - u2
at
du3
—— = uiu2 - bu3 .
dt
Write a Java program that evaluates the phase portrait (ui(t),u,2(t)) of the
Lorenz model.
Solution 6. 
In the program LorenzPhase. Java, we find the phase por-
trait (ui(t),U2(t)) of the Lorenz model for the initial values
u1(0)=0.8, 
u2(0)=0.8, 
u3(0)=0.8
and the parameter values a = 16, r = 40 and 6 = 4.
/ / LorenzPhase.j ava
import j ava.awt.*;
import j ava.awt.event.*;
import j ava.awt.Graphics;
public class LorenzPhase extends Frame
{
public LorenzPhase()
{
setSize(600,500);
addWindowListener(new WindowAdapterO
{ public void windowClosing(WindowEvent event)
{ System.exit(0); }});
}
public void fsystem(double h,double t.double u[].double hf[])
{
double sigma = 16.0; double r = 40.0; double b = 4.0;
hf[O] = h*sigma*(u[l] - u[0]);
hf[l] = h*(-u[0]*u[2] + r*u[0] - u [ l ] ) ;
hf [2] = h*(u[0]*u[l] - b*u[2]);
}

Ordinary Differential Equations 
273
public void map(double u[],int steps,double h,double t.int N)
{
double uk[] = new double [N];
double tk;
double a[] = { 0.0,1.0/4.0,3.0/8.0,12.0/13.0,1.0,1.0/2.0 };
double c[] = { 16.0/135.0,0.0,6656.0/12825.0,28561.0/56430.0,
-9.0/50.0,2.0/55.0 };
double b[] [] = new double [6] [5];
b[0][0] = b[0][l]= b[0][2] = b[0][3] = b[0] [4] = 0.0;
b[l][0] = 1.0/4.0; b[l][l] = 0.0; b[l] [2] = 0.0;
b[l][3] = 0.0; b[l] [4] = 0.0;
b[2][0] = 3.0/32.0; b[2] [1] = 9.0/32.0;
b[2][2] = 0.0; b[2][3] = 0.0; b[2] [4] = 0.0;
b[3][0] = 1932.0/2197.0; b[3] [1] = -7200.0/2197.0;
b[3][2] = 7296.0/2197.0; b[3] [3] = b[3] [4] = 0.0;
b[4][0] = 439.0/216.0; b[4] [1] = -8.0;
b[4][2] = 3680.0/513.0; b[4][3] = -845.0/4104.0;
b[4][4] = 0.0;
b[5][0] = -8.0/27.0; b[5][l] = 2.0;
b[5][2] = -3544.0/2565.0; b[5][3] = 1859.0/4104.0;
b[5] [4] = -11.0/40.0;
double f [] [] = new double [6] [N] ;
int i, j , 1, k;
f or (i=0; Ksteps ; i++)
fsystem(h,t,u,f[0]);
for(k=l;k<=5;k++)
{
tk = t + a[k]*h;
for(l=0;KN;l++)
{
uk[l] = u[l];
for(j=0; j<=k-l; j++)
uk[l] += b[k][j]*f [j][l];
}
fsystem(h,tk.uk,f[k]);

274 Problems and Solutions
}
for(l=0;KN;l++)
for(k=0;k<6;k++)
u[l] += c[k]*f[k][l];
}
}
public void paint(Graphics g)
{
g.drawLine(10,10,10,400);
g.drawLine(10,200,630,200);
g.drawRect(10,10,630,400);
int steps = 1;
int N = 3;
double h = 0.005;
double t = 0.0;
double u[] = { 0.8, 0.8, 0.8}; // initial conditions
// wait for transients to decay
for(int i=0;i<1000;i++)
{
t += h;
map(u,steps,h,t,N);
}
t = 0.0;
for(int i=0;i<4800;i++)
{
t += h;
map(u,steps,h,t,N);
int m = (int) (5.0*u[0] + 300);
int n = (int) (5.0*u[l] + 200);
g.drawLine(m,n,m,n);
}
>
public static void main(String[] args)
{
Frame f = new LorenzPhaseO ;
f.setVisible(true);
}
}

Chapter 12
Partial Differential
Equations
Problem 1. 
Consider the partial differential equation (one-dimensional
wave equation)
m* ~ dx2 
()
with the initial conditions
u(x,0) 
= f ( x ) , 
0 < x < £ 
(2a)
d ^ = 9 ( x ) , 
0 < x < £ 
(26)
and the boundary conditions
u{0,t) 
= L(t), 
t>0 
(3a)
u(e,t) = R(t), 
t>0. 
(36)
The function u of x and t gives the amplitude of the string at position x and
t. Discretize the partial differential equation and the initial and boundary
conditions and formulate the discretized version as an initial value problem.
For the discretization use
df _ f(x + Ax) - f{x)
dx 
Ax
d2/ _f(x + Ax) - 2/(1) + f{x - Ax)
dx2 ~ 
(Ax)2
275

276 Problems and Solutions
Solution 1. Using the notation
Um,n = u(mAx,nAt) = u(xm,tn)
we find using the discretization given above
d2u(xm,tn) _ u(xm,tn + At) - 2u(xm, tn) + u(xm, tn - At)
dt2 
~ 
(At)2
~ 
(Atp
and
d2u(xm,tn) _ u(xm + Ax, tn) - 2u(xm,tn) + u(xm - Ax, tn)
dx2 
~ 
(Arc)2
_ "m+l.n — 2um,n + ttm-l,n
~ 
(Ax^ 
•
Substituting these expressions into the wave equation (1) yields
um,n+l ~ 2u m > n 4" Wm,n —1 
2W«i+l,« ~ •^um,n 4" W m_i ; n
(A<p 
" C 
(Ax]2 
' 
[>
We set
_ c2(At)2
£ : ' 
(Ax)2 '
Writing (4) as a recursion with respect to n (time) we have
«m,n+l = e("m+l,n 4" Um-l,n) 4" 2(1 - e)um,n - Umin_i . 
(5)
To generate approximate values of u(x,t) at time tn+i we must know ap-
proximate values at times tn and t n_i. Suppose that umjo and u m i are
know for all 0 < m < M. Then (5) with n = 1
Um,2 = e(Um+l,l 4- M m-l,l) 4- 2(1 - e)ltm,i - Um,o
determines umj2 for all 1 < m < M - 1. When 1 < m < M - 1, the
subscripts m 4- 1 and m — 1, which appear on the right-hand side of (5),
are both between 0 and M. The two boundary conditions determine uo,2
and UM,2> respectively. At this point um^n is known for every 0 < m < M
and n < 2. Then (5) with n = 2 yields um^ for all 1 < m < M — 1. Again
the boundary conditions determine uo,3 and «M,3 and so on. To generate
approximate values of u(x,t) (using (5)) at time t\ = At it is necessary to
know approximate values at times to = 0 and £_i = —At. The first initial
condition (2a) provides
um,o = u(mAx,0) = f(mAx) 
(6)

Partial Differential Equations 277
and the second speed initial condition (2b) provides us indirectly and ap-
proximately u m,-i- The simplest approximation would be
du(x,0) 
u(x,0) - u(x, — h) ^ u(x,O) — u(x, -At)
9{-X' ~ 
dt 
~ h™o 
h 
^ 
At 
'
Thus
um,_i = u(mAx, —At) « u(mAx, 0) — g{mAx)At = um,o ~ g{rnAx)At.
We obtain a more accurate approximation by using
du(x, 0) _ 
u(x, h) - u(x, -h) 
u(x, At) — u(x, -At)
9{X) - ~~dT 
~ hZ 
2h 
" 
2At 
•
Thus
um,_i = u(mAx, —At)
w u(mAx, At) - 2g(mAx)At
= um,i - 2g{mAx)At.
Substituting this equation into the difference equation (4) with n = 0 yields
«m,i = e(um+i,o + t*m-i,o) + 2(1 - e)um,0 - u m,-i
= e(Mm+ii0 + wm-i,o) + 2(1 - e)umfi - um>i + 
2g(mAx)At.
Thus
«m,i = 2e(u"i+i,o + «m-i,o) + (1 - e)um>0 + g(mAx)At. 
(7)
Equations (6) and (7) give um,n for all n = 0,1 and 1 < m < M - 1. Thus
we have the algorithm:
Set for all 1 < m < M - 1
Umfi = 
f(mAx)
and
Um,l = -e("m+l,0 + "m-l,o) + (1 ~ f)«m,0 + 
g{mAx)At.
Then for each iteration step n = 1, 2,..., we set
«m,n+l = e("m+l,n + «m-l,n) + 2(1 - e)wm,n - Um>n-l
for all 1 < m < M — 1. Whenever uo,fc or UM,fc is encountered on the
right-hand sides of these formulas we apply
«o,fc = L(kAt), 
MM,fc = 
R(kAt).

278 Problems and Solutions
How do we choose e?
Problem 2. Maxwell's equations in free space are given by
„ 
„ 
dE
V x B = eOA«o-^-
Vx,-f
V-E = 0
V B = 0
where B is the magnetic induction, E is the electric field intensity and
/ dB3 
dB2 \
dy 
dz
9Bi 
8B3
dz 
ox
dB2 
dBy
\ dx 
dy J
We assume that B\ = B3 = 0, E2 = E3 = 0, B2 only depends on z and t
and Ei only depends on z and t.
(i) Find Maxwell's equations for this special case.
(ii) Thus we choose the z-direction for direction of propagation of the elec-
tromagnetic field, the a>direction for the polarization of the electric field
intensity. Then it follows that the magnetic induction is y-polarized. Dis-
cretize these equations using the central difference approximation for the
derivative of time and space
dV 
AV _ V(n + 1/2) - V(n - 1/2)
~dt^~Kt= 
At
dV 
AV _ V(k + 1/2) - V(k - 1/2)
~dz^~Az 
= 
Az
where the temporal steps are indexed by the integer n and related to the
continuous time by t = nAt, and the spatial steps are indexed by the integer
k and related to continuous space by z = kAz. Discuss the accuracy.
Solution 2. (i) We find
dEi __ 
28B2
dt ~ 
C dz
8B2 _ dE-i
~~dT~ ~dz
where eoA*o = 1/c2.

Partial Differential Equations 279
(ii) The discretization yields
Ex{n + 1/2, fc) - Ej(n - 1/2), k _ 
2B2{n, fc + 1/2) - B2(n, k - 1/2)
At 
~~° 
Az
B2(n + 1/2, k) - B2{n - 1/2, k) _ 
Ei(n, k + 1/2) - E^n, k - 1/2)
A* 
~ 
~Az 
'
In the method of finite difference time domain simulation we need only to
consider the two curl equations, because the divergence conditions can be
satisfied implicitly by interleaving the electric field intensity and magnetic
induction components in space. A consequence of the spatial interleaving
is that the fields must also be interleaved in time, known as leapfrog, since
the temporal response of one field is proportional to the spatial variation of
the other at the previous time step. Thus we obtain for the second equation
with n -> n + 1/2 and k -> k + 1/2
B2(n + 1, k + 1/2) - B2(n, k + 1/2) _ 
Ex(n + 1/2, k + l)-E1(n 
+ 1/2, fc)
At 
~ 
~A~z 
'
To yield accurate results, the grid spacing 5 in the finite difference sim-
ulation must be less than the wavelength A of the electromagnetic wave,
usually less then A/10. The stability condition relating the spatial and
temporal step size is
. _ / 
1 
_J_ 
1 \" 1 / 2
vmaxAt - \^{Ax)2 + {Ay)2 + 
{Az)2j
where vmax is the maximum velocity of the wave.
Problem 3. 
When doing numerical calculations for partial differential
equations we must establish an upper bound on the growth of the solution.
We consider one space dimension. In the continuous case the energy method
is often used with the usual scalar product in the Hilbert space L2[a, b]
, b
(u,v) := / 
u(x)v(x)dx.
Ja
This implies a norm ||w|| := (u,u)1/2. 
Consider the simplest hyperbolic
partial differential equation
du 
du
dt 
dx
(i) Show that the energy growth in time is governed by the boundary values
a and b, i.e., we have to calculate
ldjjuf
2 
dt 
'

280 Problems and Solutions
(ii) Extend to the discrete case.
Solution 3. (i) We find
where we used the notation ut = du/dt, ux = du/dx and integration by
parts
/ -£-v(x)dx = - I u-^-dx + u(x)v(x)\b
a.
Ja °x 
Ja OX
(ii) In the discrete case we have to find an operator D and a scalar product
with a matrix H that approximates the derivative d/dx and the integral Ja
with the same properties as the continuous case. Thus integration by parts
is replaced by
{u,Dv)h = unvn - UOVQ - (Du,v)h
where (u,v)h '•= huTHv and T means transpose. An example of such a
matrix operator D (tridiagonal matrix) and scalar product matrix H is
/ -1 
1 
\
-0.5 
0 
0.5
» = \ 
, 
, . 
•,
-0.5 
0 
0.5
V 
- 1 1 /
and the diagonal matrix H = diag(0.5, 1, ... 1, 0.5).
Problem 4. The inviscid Burgers equation is given by
du 
du
m+ulTx 
= 0-
(i) Show that the partial differential equation can be written as a scalar
conservation law
du 
d(f(u)) _
dt+ 
dx
(ii) Discuss the solution.
(iii) Use the truncated Taylor expansion
du 
Ui -Ui_i 
. 
.
— 
« 
h O(Ax)
dx i 
Ax 
v 
'

Partial Differential Equations 281
to approximate the inviscid Burgers equation. Disucss the problem with
this approximation.
Solution 4. (i) We can write the equation as conservation law
du 
d (u2\ __
~di+ dx 
\2)~°-
(ii) We have a hyperbolic differential equation. The information propagates
along characteristic curves, u is constant on the characteristic curve and u
is the slope of the characteristic curve and where the characteristics cross
we have shock formation (weak solution),
(iii) The approximation
du 
du 
U»,n+1 - Uj n 
Uj n - Ui_i,n
ai 
oa; 
At 
Ax
converges to an incorrect solution. The reason is that the Taylor expansion
is not valid at the shock.
Problem 5. In many practical situations a hyperbolic partial differential
equation appears in the form of a conservation law
du 
df(u) _
dt + ~a^~°
which can be written as
du 
.du
m+9{u)d-x 
= °
where g{u) = df /du. If f(u) = u2/2 we obtain the inviscid Burgers equa-
tion. For the Lax- Wendroff method we look at the Taylor expansion of the
partial differential equation with respect to t. Starting from
du 
d
at = " ^ / ( M )
we obtain
d2u 
d d .. . 
d d 
d ( 
du\
W = " a & / ( u ) = ~d-xd-tf{u) = "& {9^m) •
Thus
d2u 
a ( 
dj(u)\
dt2 
dx \ 
dx )
Replacing the x-derivative by central differences we obtain

282 
Problems and Solutions
where
U^u(Xj,tn)
and we use the definitions
5xv(x, t) := v(x H—Ax, t) — v(x 
Ax, t) 
central difference
Zt 
Zi
AOxv(x,t) := -(v(x + Ax,t) - v(x - Ax,t))
A+Xv(x, t) := v(x + Ax, t) - v(x, t) forward difference
A-Xv(x, t) := v(x, t) - v(x - Ax, t) backward difference.
If we expand the last term we find that it contains the values of ff(^™_1/2)
and g(U™,2). 
In evaluating this, one sets
Thus the scheme becomes
+ (I + < ^ 1 / 2 ) ^ ) A - * / ( ^ ) ) -
Write a C++ program that implements the Lax-Wendroff method for the
Burgers equation
du 
du 
d2u
~dt+U~dx~ = V~dtf
where v is the kinematic viscosity.
Solution 5.
// LaxWendroff.cpp
#include <iostream>
#include <cmath> 
// for fabsO
using namespace std;
int main(void)
{
double L = 1.0; // size of periodic region
int N = 200; 
// number of grid points
double A; 
// lattice spacing
double t; 
// time step length

Partial Differential Equations 283
double nu = 0.0; // kinematic viscosity
// allocating memory
double* u = new double[N]; 
// the solution
double* uNew = new double [N]; // for updating
double* F = new double[N]; 
// for flow
h = L/N; 
// grid length
double uMax =0.0;
int i, j, k;
// initial distribution
for(i=0;i<N;i++)
•C
double x = i*h;
u[i] = x;
if(fabs(u[i]) > uMax) uMax = fabs(u[i]);
>
t = h/uMax;
cout « "t = " « t « endl;
int steps = 50000;
int count = 0;
while(count < steps)
{
for(j=0;j<N;j++)
F[j] = u[j]*u[j]/2.0;
for(j=0;j<N;j++)
{
int jMinusl = j > 0 ? j-1 : N-l;
int jPlusl = j < N-l ? j+1 : 0;
int jPlus2 = jPlusl < N-l ? jPlusl+1 : 0;
uNew[j] =
(u[j] + u[jPlusl] )/2.0 -
(t/(2.0*h))*(F[jPlusl]-F[j]) +
(nu*t/(2.0*h*h))*((u[jPlusl]+u[jMinus1]-2.0*u[j])/2.0
+ (u[jPlus2]+u[j]-2.0*u[jPlusl])/2.0);
} / / end j loop
for(j=0;j<N;j++) F[j] = uNew[j]*uNew[j]/2.0;
for(j=0;j<N;j++)
{
int jMinusl = j > 0 ? j - 1 : N-l;
int jPlusl = j < N-l ? j+1 : 0;
uNew[j] = u[j] - (t/h)*(F[j]-F[jMinusl]) +

284 Problems and Solutions
(nu*t/(h*h))*(u[jPlusl]+u[jMinusl]-2.O*u[j]);
}
for(i=0;i<N;i++) u[i] = uNew[i];
count++;
} / / end while
/ / solution
for(i=0;i<N;i++)
{
cout « "u[" « i « "] = " « u[i] « endl;
}
delete[] u; deleted uNew; delete[] F;
return 0;
}
Problem 6. Consider the one-dimensional nonlinear Schrodinger equa-
tion
du 
d2u 
, ,9
lm+w+qMu 
= 0 
(1)
together with the periodic boundary condition u(x,t) = u(x + L,i). Here
u(x, t) is a complex valued function and q is a real parameter. Give two
different discretizations for the space variable x.
Solution 6. 
Since the second order derivative of a function / can be
defined as
#i_v 
f(x-h)-2f(x) 
+ f(x + h)
dx2 ~ £?o 
h2
we can approximate the partial differential equation (1) as
where UJ+N — UJ, h = L/N, i.e., iV denotes the number of grid points and
Xj = jh with Uj(t) denoting the numerical approximation of U(XJ, t).
Another approximation would be by modifying the last term </|u]2u to
\q\Uj\2(Uj.1 + Uj+1)
and leaving the approximation for the first two terms the same.

Chapter 13
Wavelets
Problem 1. 
In many applications, given a signal in the time domain
f(t), one is interested in its frequency content locally in time, the standard
Fourier transformation cannot provide this time localization. The wavelet
transform
wa,b(f) = i«r1/2 r ww (—)dt
J-oo 
\ 
a J
provides a time localization. One assumes that
/•OO
/ 
ip(t)dt = 0 .
J — OO
The functions
are called wavelets and the function «/>(s) is called mother wavelet. As a
changes, the i/^b cover different frequency ranges, changing the parameter
as well allows us to move the time location center (which is in s = 6).
Thus all the wavelets are translated and dilated versions of one function
the mother wavelet. Examples of mother wavelets are
ip(t) = (1 — £2)exp(—12/2) 
Mexican hat wavelet
( 1 
for 
0 < t < 1/2
V'OO = { -1 
for 
I / 2 < * < 1 
Haar wavelet.
[ 0 otherwise
Discuss the localization of these wavelets in the time domain and frequency
domain.
285

286 
Problems and Solutions
Solution 1. 
The Haar wavelet is very well localized in the time-domain
but badly localized in frequency domain due to the appearance of side-
bands in the Fourier spectrum. In contrast, the frequency localization of the
Mexican hat wavelet is much better but at the cost of the time localization
(uncertainty principle).
Problem 2. 
The Dirichlet-Gabor distributed approximating functional
wavelet is given by
4>{x) = CMia exp ( — J I - + ^ 
cos(kx) 1 .
V 
fc=i 
/
(i) Can this expression be simplified?
(ii) Let <j> be the Fourier transform of (j). The constant CM,<J is determined
by 0(0) = 1. FindCM,CT-
Solution 2. 
(i) Since
1 
A 
n 
s 
sin(M + |)x
- + > cos(fcx) = — , . ,2'
2 
^ 
2sin(a;/2)
the function (f> takes the form
f-x2\ 
sin(M + \)x
^(x) = CM,gexp^—j 
2Mx/2) 
.
(ii) Since
/•OO
4>{k) = j 
4>(x)eikxdx
J —OO
we have
/•OO
^(0) = / 
cp{x)dx = 1.
J — OO
Thus we find
(
I 
M 
f CT2 £2 \ \
-+^]expf 
— J J = 1 .
Problem 3. 
Consider the Hilbert space L2(R). Assume that the function
(j) G £2 (R) satisfies
/•OO
/ 
4>{t)4>{t - k)dt = <50,fc
J -OO

Wavelets 
287
i.e., the integral equals 1 for k = 0 and vanishes for k = ±1, ±2, 
Show-
that for any fixed integer j 6 Z the functions
4>jk(t) := 2j/24>(2jt -ft), 
fceZ
form an orthonormal set.
Solution 3. 
We have
f 
<pjk{tj4^(ijdt 
= [ 
2j/2<j>{2H - k)2i'24>{2H - 
t)dt.
J — oo 
*/ —oo
Let z := 2jt - fc. Then di = 2Jdt and
/ 
</>Jk(t)<l>ji(t)dt = 
4>(x)<l>(x + k-e)dx 
= dOte-k.
J ~oo 
J — oo
When ^ = fc, then
r°°
/ 
4>jk(x)({)je{x)dx 
= 1
»/—oo
otherwise
/•oo
/ 
((>jk(x)<f)je(x)dx = 0.
J — oo
Thus the set forms an orthonormal set.
Problem 4. 
Consider the Hilbert space I<2[0,1]. Let <fr be the //aar
scaling function
, . _ f 1 
if 
0 < i < 1
<Pl j •" \ 0 otherwise
Let n be a positive integer and
9k(t) :=y/n4>(nt-k), 
k = 0,1,2,... ,n - 1.
(i) Show that { go> 3i > • • •, 3«-i } is an orthonormal set in the Hilbert space
1*10,1].
(ii) Let / be a continuous function on [0,1] and form the projection /„ on
the subspace Sn[0,1] of I/2[0,1] spanned by { go, gi,..., 
gn-\ }
n-l
fn(t) = Y/(f'9k)gk(t)
fc=O
where the scalar product is defined by
(f,9k):= I 
f(t)gk(t)dt.
Jo

288 Problems and Solutions
Show that fn(t) —> f(t) pointwise in t as n —> oo.
Solution 4. (i) For A; ^ £ we have gk(i)gt(t) = 0 for all i e (0,1). Thus
for k ^ £ we have
/ 9k{t)9t(t)dt = 0.
Jo
For fc = € we have
/•I 
/•(*+!)/"
/ 
0fc(O<ft = W 
fife 
= 1.
^0 
./fc/n
(ii) We have
/n(*) = ^ n 
/ 
/(T)drU(nt-fc).
fc=o 
V-
7*/" 
/
Hence
fn(t)=n 
f(T)dT for 
_ < f < ^ ± .
7fc/n 
« 
n
By the mean waZue theorem of calculus, there is a point tUtk in the interval
(n' ^rO s u c n t n a t t n e integral expression on the right-hand side is equal
to /(*„,*)• Thus
U(t) = f(tn,k) 
for - < * < ^ ± 1 .
n 
n
Since / is continuous on the closed bounded set [0,1], it is uniformly con-
tinuous on this set. Thus for any e > 0 there is a <5(e) > 0 such that
1/(0 - f(t')\ < e whenever \t - t'\ < 6(e). Now given t e [0,1) and e > 0,
choose n > 1/S(e). Then
\f(t)-fn(t)\ = \f(t)-f(tn,k)\<e
since
\t-tn,k\<-<S(e)n
so that fn(t) —» /(£), uniformly in t as n —> oo.
Problem 5. We consider the Hilbert space L,2(R). Expand the step
function
ft-).-}-1 
= e [-1/2,0]
t W - \ 
i xe (0,1/2]
with respect to the Haar basis
{ ^ , f c ( x ) : = 2 ^
2 i > ( 2 ^ x - k ) : 
j , k e Z }

Wavelets 289
and
( - 1 xe [0,1/2]
V(x) = < l i e (1/2,1] •
[ 0 otherwise
Calculate the expansion coefficients (f(x), ipj,k(x)) where the scalar product
is defined by
(/(*), 5(*)):= f" f{x)W)dx.
J — OO
Thus we determine
j,k£Z
Solution 5. We have
[-V'2 x& [k2-*,{k+\)2-i]
il>Jtk{x) = \y/2 
xG((fc+i)2-^(fc + l)2-^] .
^ 0 
otherwise
It is easy to see that
f(x) = -ipo,o(x) ~ V'o.-iCa;)
for x € ( —|, | ) . To evaluate the integrals we are only interested in the in-
tervals [fc2"J, (fc + |)2-J] and ((fc + |)2-J', (fc + 1)2-J] which have a non-
empty intersection with [—1/2,1/2]. Furthermore, if the union of the in-
tervals is completely contained in [—1/2,1/2] the corresponding coefficient
in the expansion will be zero. Thus we need only consider the intervals
of length > ^ which corresponds to j < 0 which have 0 as one of the
boundaries (fc e {0, -1}). We find
(/^,fc)-j0 
otherwise
Thus we find
/(*) = E(-2J/2"1)^.o(x) + V,-,-i(*))
where x e R. We note that
W-1 = - YV = 1.

290 
Problems and Solutions
Problem 6. 
We consider the discrete wavelet transform of an orthogonal
function which can be applied to a finite group of data. The input signal is
assumed to be a set of discrete-time samples. The transform is a convolu-
tion. The wavelet basis is a set of functions which are denned by a recursive
difference equation for the scaling function <j>
M-l
4>(x) = Y^ Ck^x - k)
fc=0
where the range of the summation is determined by the specified number of
nonzero coefficients M. Here k is the translation parameter. The number
of coefficients is not arbitrary and is determined by constraints of orthog-
onality and normalization. Owing to the periodic boundary condition we
have Cfe := c^+nM> where n 6 N. Periodic wavelets are only one possibility
to deal with signals on an interval. Generally, the area under the scaling
function over all space should be unity, i.e.,
/ <t>{x)dx = 1.
It follows that
M-l
fe=0
In the Hilbert space L2(R), 
the scaling function <f> is orthogonal to its
translations; i.e.,
/ 4>(x)<t>(x - k)dx = 0, 
k ^ 0.
JR
What is desired is a function ip which is also orthogonal to its dilations, or
scales, i.e.,
/ 4>{x)ip(2x - k)dx = 0.
Jn
Such a function ip does exist and is given by (the so-called associated wavelet
function)
1>(x) = J2(-l)kc^kcl>(2x - k)
fc=i
which is dependent on the solution of <f>. The following equation follows
from the orthonormality of scaling functions
2jcfeCfc_2m = 2<5Om
k

Wavelets 
291
which means that the above sum is zero for all m not equal to zero, and
that the sum of the squares of all coefficients is two. Another equation
which can be derived from rp(x) _1_ <f>(x — m) is
£(-l)fe
Cl_fccfc_2rn=0.
fc
A way to solve for 4> is to construct a matrix of coefficient values. This is
a square M x M matrix where M is the number of nonzero coefficients.
The matrix is designated L with entries Lij = C2i-j- This matrix has
an eigenvalue equal to 1, and its corresponding (normalized) eigenvector
contains, as its components, the value of the function <j> at integer values of
x. Once these values are known, all other values of the function <f> can be
generated by applying the recursion equation to get values at half-integer x,
quarter-integer x, and so on down to the desired dilation. This determines
the accuracy of the function approximation. Give an example for the scaling
function <j> and the associated wavelet function ip.
Solution 6. 
An example for ip is the Haar function
!
1 0 < x < i
- 1 \ <x< 
1
0 
otherwise
and the scaling function <f> is given by
,, s _ / 1 0 < z < 1
<P[X) ' 
\ 0 otherwise '
The functions
ipm^{x) :=2^ip{2mx-n), 
m,neZ
form a basis in the Hilbert space I^CR-)- If w e restrict m to m — 0,1,2,...
and n = 0,1,2,..., 2 m - 1 we obtain a basis in the Hilbert space L2[0,1].
Problem 7. 
This class of wavelet functions is constrained, by definition,
to be zero outside of a small interval. This is what makes the wavelet trans-
form able to operate on a finite set of data, a property which is formally
called compact support. The recursion relation ensures that a scaling func-
tion 4> is non-differentiable everywhere. Of course this is not valid for Haar
wavelets. The following table lists coefficients for two wavelet transforms.
The pyramid algorithm operates on a finite set on N input data
/o,/i,- •• ,/AT-I

292 
Problems and Solutions
Wavelet 
Co 
c\ 
C2 
C3
~~Haar 
LO 
O
Daubechies-4 | (1 + %/3)/4 | (3 + %/3)/4 | (3 - %/3)/4 | (1 - y/3~)/4
Table 13.1: Coefficients for Two Wavelet Functions
where N is a power of two; this value will be referred to as the input block
size. These data are passed through two convolution functions, each of
which creates an output stream that is half the length of the original input.
These convolution functions are filters, one half of the output is produced
by the "low-pass" filter
at = -22c2i-i+ifj' 
* = 0, l , . . . , y - 1
3=0
and the other half is produced by the "high-pass" filter function
l ^ , 1 
N
6* = 9 ^ (-1) V 2 i / j , 
i = 0,1, . . . , y - 1
where N is the input block size, Cj are the coefficients, / is the input
function, and a and b are the output functions. In the case of the lattice
filter, the low- and high-pass outputs are usually referred to as the odd and
even outputs, respectively. In many situations, the odd or low-pass output
contains most of the information content of the original input signal. The
even, or high-pass output contains the difference between the true input and
the value of the reconstructed input if it were to be reconstructed from only
the information given in the odd output. In general, higher order wavelets
(i.e. those with more nonzero coefficients) tend to put more information
into the odd output, and less into the even output. If the average amplitude
of the even output is low enough, then the even half of the signal may be
discarded without greatly affecting the quality of the reconstructed signal.
The Haar wavelet represents a simple interpolation scheme. After passing
these data through the filter functions, the output of the low-pass filter
consists of the average of every two samples, and the output of the high-
pass filter consists of the difference of every two samples. The high-pass
filter contains less information than the low pass output. If the signal is
reconstructed by an inverse low-pass filter of the form
N/2-1
/ / " = 
Y, 
cK-i+iai> 
j = 
0,l,...,N-l
i=0
then the result is a duplication of each entry from the low-pass filter out-
put. This is a wavelet reconstruction with 2x data compression. Since the

Wavelets 293
perfect reconstruction is a sum of the inverse low-pass and inverse high-pass
filters, the output of the inverse high-pass filter can be calculated. This is
the result of the inverse high-pass filter function
JV/2-1
/ f = J2 ( - l ) V i - 2 i * < , 
3 = 0,1,... 
,N - 1.
The perfectly reconstructed signal is / = fL+fH, 
where each / is the vector
with elements /,-. Using other coefficients and other orders of wavelets
yields similar results, except that the outputs are not exactly averages and
differences, as in the case using the Haar coefficients. Write a C++ program
that implements the pyramid algorithm.
Solution 7. The C++ program implements the Haar wavelet transform.
We first find the coefficients a[i] and b[i]. Then we obtain fL[i] and
fH[i].
// wavelet.cpp
#include <iostream>
#include <cmath>
using namespace std;
int main(void)
•C
const double pi = 3.14159;
int N = 16; // N must be a power of 2
double* f = new double[N];
int k;
for(k=0;k<N;k++) f[k] = sin(2.0*pi*(k+l)/N); // input signal
// coefficients Haar wavelet
double* c = new double[N];
for(k=0;k<N;k++) c[k] = 0.0;
c[0] = 1.0; c[l] = 1.0;
// array a
double* a = new double[N/2] ;
for(k=0;k<N/2;k++) a[k] = 0.0;
// array b
double* b = new double[N/2] ;
for(k=0;k<N/2;k++) b[k] = 0.0;
int i, j;
for(i=0;i<N/2;i++) {
for(j=0;j<N;j++) {
if(2*i-j+l < 0) a[i] += c[2*i-j+l+N]*f [j];

294 
Problems and Solutions
else a[i] += c[2*i-j+l]*f [j];
}
a[i] = 0.5*a[i] ;
}
for(i=0;i<N/2;i++) {
for(j=0;j<N;j++) 
{
if(j-2*i < 0) b[i] += pow(-1.0,j)*c[j-2*i+N]*f[j];
else b[i] += pow(-1.0,j)*c[j-2*i]*f [j];
}
b[i] = 0.5*b[i];
}
for(k=0;k<N/2;k++) cout « "a[" « k « "]=" « a[k] « endl;
for(k=0;k<N/2;k++) cout « "b[" « k « "]=" « b[k] « endl;
/ / inverse
double* fL = new double[N]; double* fH = new double[N];
for(j=0;j<N;j++) fL[j] = 0.0;
for(j=0;j<N;j++) fH[j] = 0.0;
for(j=0;j<N;j++) {
for(i=0;i<N/2;i++) {
if(2*i-j+l < 0) fL[j] += c[2*i-j+l+N]*a[i];
else fL[j] += c[2*i-j+l]*a[i] ;
}
>
for(k=0;k<N;k++)
cout « "fL[" « k « "] = " « fL[k] « endl;
for(j=0;j<N;j++) {
for(i=0;i<N/2;i++) {
if(j-l-2*i < 0) fH[j] += pow(-1.0,j)*c[j-l-2*i+N]*b[i];
else fH[j] += pow(-1.0,j)*c[j-l-2*i]*b[i];
}
}
for(k=0;k<N;k++)
cout « "fH[" « k « "] = " « fH[k] « endl;
// input signal reconstructed
double* g = new double[N] ;
for(k=0;k<N;k++) g[k] = fL[k] + fH[k];
for(k=0;k<N;k++)
cout « "g[" « k « "] = " « g[k] « endl;
delete[] f; delete[] c; delete[] a; delete[] b;
delete [] fL; delete [] fH; delete [] g;
return 0;
}

Chapter 14
Graphs
Problem 1. 
A simple graph G = {V,E) consists of V, a nonempty set
of vertices (nodes), and E, a set of unordered pairs of distinct elements of
V called edges (arcs). This definition of a graph does not permit multiple
edges connecting a pair of vertices. It also does not permit a loop, an
edge that connects a vertex to itself. Objects with such edges are called
multigraphs. We consider multigraphs without loops. The degree of a
vertex v is the number of edges incident with it. The degree of v is denoted
with d(v). Suppose a graph has m nodes, numbered n\, 712, • • •, nm. We
can form an m x m matrix where entry i, j is the number of edges (arcs)
between vertices rij and rij. This matrix is called the adjacency matrix A
of the graph. Thus 0^ = p where there are p edges between n, and rij. A
path in a multigraph is a sequence of alternating vertices and edges, such
that all edges are distinct. A path can cross a vertex more than once, but
can only cross an edge once. An Euler path in a graph is a path such that
every edge is traversed exactly once. An Euler path exists in a connected
graph if and only if d(v) is even for every vertex v of G or two vertices
have d(v) odd and all others are even. In the first case the path can begin
at any vertex and will end there. In the second case the path must begin
at one of the vertex with d(v) odd and will end at the other vertex with
d(v) odd. Thus if a graph has more than two vertices of d(v) even, then it
cannot have an Euler path.
295

296 Problems and Solutions
Given the adjacency matrix
/O 2 1 0 0\
2 0 2 0 0
A= 
1 2 
0 2 2
0 0 2 0 2
VO 0 2 2 0/
write a C++ program that tests for these three cases.
Solution 1. The matrix A is symmetric.
/ / EulerPath.cpp
#include <iostream>
using namespace std;
int main(void)
{
const int n = 5;
int A [n] [n] ;
A[0][0]=0; A[0][l]=2; A[0] [2]=1; A[0][3]=0; A[0] [4]=0;
A[l][0]=2; A[l][l]=0; A[l][2]=2; A[l] [3]=0; A[l] [4]=0;
A[2][0]=l; A[2][l]=2; A [2] [2]=0; A [2] [3] =2; A[2][4]=2;
A[3][0]=0; A[3][l]=0; A [3] [2] =2; A[3][3]=0; A[3][4]=2;
A [4] [0] =0; A [4] [1] =0; A [4] [2] =2; A [4] [3] =2; A [4] [4] =0;
int odd = 0 , i = 0;
while(odd <= 2 && i < n)
{
int d = 0;
for(int j=O;j<n;j++) { d += A[i][j]; }
if(d'/.2 == 1) odd++;
i++;
} / / end while
if(odd > 2) cout « "no Euler path exists";
if(odd == 0)
cout « "Euler path exists. Path ends at the starting vertex";
if(odd = = 2 | | odd == 1)
cout << "Euler path exists << endl;
cout « "Path does not end at the starting vertex";
return 0;
>

Graphs 297
Problem 2. Given a network, the all-to-all shortest path problem is to
find the total cost of going from every node to every other node in the net-
work. For some pairs of nodes, this can be found by inspecting the network.
A large network may consist of hundreds of arcs so that finding the shortest
path between various nodes may be complicated. A method to solve this
problem is the Floyd- Warshall algorithm. It uses a two-dimensional array
to represent the cost of travelling from every node to every other node.
Each row of the two-dimensional array corresponds to an originating node,
and each column corresponds to a destination node.
The Floyd-Warshall algorithm begins by initializing the entries in the cost
array with the costs of the arcs in the network. Let n be the number of
nodes. The initialization is as follows:
1) Initialize the diagonal elements of the two-dimensional array C to zero,
i.e.,
C0,0 = Cl,l = • • • = Cn-i.n-i = 0 .
This reflects the fact that travel from one node to itself is costless.
2) Each arc in the network connects some node i and some node j . For
each arc, initialize the value Cy in the cost matrix C to the cost of that arc.
3) All other entries in the array should be set to some large value that
exceeds the total cost of any final path in the network (for example we set
it to be 20000).
The Floyd-Warshall algorithm then examines every pair of nodes ij (i =/= j),
and for each node pair, tests whether the current cost of going from i to j
can be reduced by using node k as an intermediate node. This corresponds
to finding the following minimum
min(ci,j,Ci,fe + 
ckJ).
Once this is done for all i,j pairs, the updated matrix C now holds the cost
of the shortest paths that use only node A: as a possible intermediate node.
This should be done for all k ^ i, k / j .
As an example consider the matrix
/ 0 
5 
3 
20000 
1 \
2 
0 
20000 
2 
1
C = 
6 
20000 
0 
2 
20000 .
20000 
1
1
0 
8
\ 1 
3 
20000 
1 
0 /

298 
Problems and Solutions
Solution 2. The resulting matrix is given by
/0 3 3 2 1\
2 0 3 2 1
CF= 
5 3 0 2 3 .
3 1 1 0 2
\1 2 2 1 0/
// floyd.cpp
#include <iostream>
#include <cstdio>
#include <climits>
using namespace std;
void floyd_warshall(int**,int);
int minint(int,int);
void show_C(int**,int);
int main(void)
int i, j, nodes;
cout << "number of nodes: ";
cin >> nodes;
int** C;
C = new int *[nodes];
for(i=0;i<nodes;i++) { C[i] = new int [nodes]; }
for(i=0;i<nodes;i++)
for(j=0;j<nodes;j++)
C[i][j] = 0;
for(i=0;i<nodes;i++)
for(j =0;j <nodes;j ++)
if(i!=j)
{
cout « "C[" « i « "][" « j « "] = ";
cin » C[i][j];
}
floyd_warshall(C,nodes);
show_C(C,nodes);
return 0;
>
void floyd_warshall(int **m,int nodes)

Graphs 299
{
for(int k=0;k<nodes;k++)
for(int i=0;i<nodes;i++)
for(int j=0;j<nodes;j++)
if(i!=j) m[i][j] = minint (m [i] [j ] , m[i] [k]+m[k] [j]);
}
int minint(int x.int y)
{
if(x < y) return x;
return y;
}
void show_C(int **m,int nodes)
{
cout « "Cost matrix is: " << endl;
for(int i=0;i<nodes;i++)
{
for(int j=0;j<nodes;j++) cout « m[i][j] « " ";
cout « endl;
}
>
Problem 3. 
A digraph is a graph where each edge (arc) only connects
vertices in one direction, i.e., a directed graph. Consider a digraph D in
which each arc has a given (positive) traversal cost, i.e., for each arc(i,j)
in D let Wij be the cost of travelling from point i to point j along arc(i,j),
where i, j = 0,1,... ,n — 1. Thus W = (W^) is an n x n matrix. For
example let
/ 0 
28 
2 
co 
1 
o o o o o o \
o o 0 o o 9 o o c o c o o o
oo oo 
0 
co co 24 oo 27
TTT 
_ 
0
0
0
0
0
0
O
0
0
0
0
8 
7
jk ~ 
00 
8 
00 
00 
0 
26 
co 
co
o o c o c o c o c o O 
8 
00
0 0 0 0 0 0 0 0 0 0 0 0 O 
7
\oo c o c o o o c o o o c o 
0 /
The cost of a path in a digraph is denned to be the sum of the costs of
the arcs of the path. In the shortest path problem, one finds the path of
least cost which joins one given point to another given point. The cost
Wij of a point pair (edge) i, j for which there is no arc(i,j) is set equal
to a prohibitively large number. The Dijkstra method is as follows. Given

300 Problems and Solutions
and a source-sink pair of points. We want to find the shortest path from
the source to the sink. At each iteration the Dijkstra method identifies
a new point (vertex) which is the closest to the source among all those
points which are currently not yet identified. The length of the path from
the source to this point is calculated and associated with the point. The
method builds up a series of shortest paths from the source to successive
points until the sink is included in this set. Then the problem is solved. To
find the arcs making up the shortest path one uses a backtracking process.
The method can be continued until all points have been identified if we
want to find shortest paths from the origin to all other points,
(i) Use Dijkstra's method to solve the shortest path problem for the digraph
given above, where the source point is p0.
(ii) Write a C++ program that implements the Dijkstra method.
Solution 3. (i) We partition the set of points (vertexes)
{PO, Pi, P2, P3, Pi, P5, P6, P7 }
into the sets A and B: A containing the origin po and B containing all
other points. Some of the points are labeled, a label of d[i] for point pi
representing the shortest distance from the source to point p^. First the
origin is assigned a label d[0] = 0. Next we find the point in B which is
closest to the origin, i.e.,
min { d\i\ + Wa } .
We find
d[0] + WM = 0 + 1 = 1.
Then the point j in B found is removed from B and placed in A. Thus
A = {po,Pi}, 
B = {pi,P2,P3,P5, Pf>,Pl)
and d[4] = 1. This sequence of steps is repeated until the sink (pr) is
transferred from B to A. We find
min (d[i\ + Wij) = d[0] + W02 = 0 + 2 = 2
ieA,j€B
Thus
A = {po, PA, P2, }, B = {pi, p3, p5, p6, Pi }
and d[2) = 2. Next we find
min (d[i] + W^) = d[4] + W41 = 1 + 8 = 9.
i€A,j€B
Thus
A = {Po, Pi, P2, Pi}, B = {pi, p3, p5, p6, p7 }

Graphs 301
and d\l] = 9. Next we find
min (d[i\ + Wu) = d[2] + Wl3 = 9 + 9 = 18 .
Thus
•A = {P0,P4,Pl,P2}, B = {p5,p6,p7}
and d[3] = 18. Finally we find
. min (d[i] + Wi:j) = d[3] + W37 = 18 + 7 = 25 .
Thus
-A = {PO,P4,P2,Pl,P3,P7}, 
B = {p5,P6}
and d[7] = 25. To find the sequence arcs for the shortest path from source
to sink we backtrack through the digraph as follows. One forms a list of
values of the form
d[j] - Wi3 - d[i\
where Pj is the sink and Pi are labeled points connected directly to pj. Thus
d[7] - W27 - d[2] = 25 - 27 - 2 ^ 0 .
Hence arc{p2,Pi) is not on the shortest path. However
d[7] - Wi7 - d[3] = 25 - 7 - 18 = 0 .
Thus arc{ps,p7) is in the shortest path. Next we replace p7 by p3, the point
just found to be on the shortest path. A new list of values is found
d[3] - W13 - d[l] = 1 8 - 9 - 9 = 0
and so arc(pi,ps) is on the shortest path. Next we have
d[l] - W41 - d[4] = 9 - 8 - 1 = 0
and
d[4] - W04 - d{0] = 1 - 1 - 0 = 0 .
Hence arc(p4,pi) and arc{po,Pi) are also in the shortest path. Thus we
find that the shortest path is
(P0,P4), (P4,Pl), (Pl,P3), (P3,P7)
with a length of d(7) which is 25.
(ii) The function f ind() tests whether an element x is in the array A[n].

302 
Problems and Solutions
II Dijkstra.cpp
#include <iostream>
using namespace std;
const unsigned long n = 8;
unsigned long find(unsigned long A[n],
unsigned long n,unsigned long x)
{
for(unsigned long k=0;k<n;k++)
{
if(x == A[k]) return 1;
}
return 0;
>
int main(void)
•C
unsigned long inf = 100000;
unsigned long i, j , v;
unsigned long mindist;
unsigned long A[n];
unsigned long W[n][n];
unsigned long dist[n];
unsigned long path[n];
for(i=0;i<n;i++) { A[i] = 0 ; }
for(i=0;i<n;i++)
for(j=0;j<n;j++)
W[i][j] = inf;
for(i=0;i<n;i++) { W[i][i] = 0; }
W[0][l] = 28; W[0][2] = 2; W[0] [4] = 1;
W[l][3] = 9;
W[2][5] = 24; W[2] [7] = 27;
W[3][6] = 8; 
W[3][7] = 7;
W[4][l] = 8; 
W[4][5] = 26;
W[5][6] = 8;
WC6][7] = 7;
for(j=0;j<n;j++)

Graphs 303
{
distCj] = W[0][j];
if(W[O][j] == inf) { path[j] = 0; }
else path[j] = 1;
}
for(i=0;i<(n-l);i++)
{
mindist = inf;
for(j=l;j<n;j++)
•C
if((find(A,n,j) == 0) && (dist[j] < mindist))
{
mindist = dist[j];
v = j ;
>
>
A[i] = v;
for(j=l;j<n;j++)
•C
if((find(A,n,j) == 0) && (dist[v] + W[v] [j] < dist[j]))
{
dist[j] = dist[v] + W[v][j];
path[j] = v;
>
}
}
/ / output
for(i=0;i<n;i++)
cout « "dist[" « i « "] = " « dist[i] « endl;
for(i=0;i<n;i++)
cout « "path[" « i « "] = " « path[i] « endl;
for(i=0;i<n;i++)
cout « "A[" « i « "] = " « A[i] « endl;
return 0;
}
Problem 4. A Hamilton path of a graph (or digraph) is a path that
contains all vertices exactly once. If the last vertex in a Hamilton path has
the first vertex as a neighbor, then the path can be turned into a Hamilton
circuit by joining the last vertex in the path to the first vertex, i.e., a

304 
Problems and Solutions
i.e., a Hamilton path that is also a cycle is a Hamilton circuit. Show that
the following graph has a Hamilton circuit.
Solution 4. The solid line gives the Hamilton circuit.
• 
\ .
• 
N.
• 
N>
\ 
/ 
\ 
/
\ 
/ 
\ 
/
\ / 
\ I

Chapter 15
Neural Networks
Problem 1. Let P and N be two finite sets of points in the Euclidean
space Rn which we want to separate linearly. A weight vector is sought
so that the points in P belong to its associated positive half-space and the
points in N to the negative half-space. The error of a perceptron with
weight vector w is the number of incorrectly classified points. The learning
algorithm must minimize this error function E(w). Now we introduce the
perceptron learning algorithm. The training set consists of two sets, P and
N, in n-dimensional extended input space. We look for a vector w capable
of absolutely separating both sets, so that all vectors in P belong to the
open positive half-space and all vectors in N to the open negative half-space
of the linear separation.
Algorithm. Perceptron learning
start: 
The weight vector w(t = 0) is generated randomly
test: 
A vector x £ P U N is selected randomly,
if x £ P and w(t)Tx > 0 goto test,
if x e P and w(t)Tx < 0 goto add,
if x £ N and w(t)Tx < 0 goto test,
if x £ iV and w(t)Tx > 0 goto substract,
add: 
set w(t + 1) = w(t) + x and t := t + 1, goto test
subtract: set w(t + 1) — w(t) — x and t := t + 1 goto test
This algorithm makes a correction to the weight vector whenever one of the
selected vectors in P or iV has not been classified correctly. The perceptron
convergence theorem guarantees that if the two sets P and iV are linearly
separable the vector w is updated only a finite number of times. The
routine can be stopped when all vectors are classified correctly.
305

306 
Problems and Solutions
Consider the sets in the extended space
P= {(1.0,2.0,2.0), (1.0,1.5,1.5)}
and
AT = {(1.0,0.0,1.0), (1.0,1.0,0.0), (1.0,0.0,0.0)}.
Thus in R2 we consider the two sets of points
{(2.0,2.0), (1.5,1.5)}, 
{(0.0,1.0), (1.0,0.0), (0.0,0.0)}.
Solution 1. 
Depending on the random selection of the vector the per-
ceptron learning algorithm could look like
wT 
xT 
wTx 
set 
action
(0 0 0) 
(1.0 2.0 2.0) 
O 
P 
add
(1 2 2) 
(1.0 1.5 1.5) 
7.0 
P 
test
(1 2 2) 
(1.0 0.0 1.0) 
3.0 
N 
subtract
(0 2 1) 
(1.0 1.0 0.0) 
2.0 
N 
subtract
(-1 1 1) 
(1.0 0.0 0.0) 
-1.0 
N 
test
(-1 1 1) 
(1.0 2.0 2.0) 
3.0 
P 
test
(-1 1 1) 
(1.0 1.5 1.5) 
2.0 
P 
test
(-1 1 1) 
(1.0 0.0 1.0) 
0.0 
N 
subtract
(-2 1 0) 
(1.0 1.0 0.0) 
-1.0 
N 
test
(-2 1 0) 
(1.0 0.0 0.0) 
-2.0 
N 
test
(-2 1 0) 
(1.0 2.0 2.0) 
0.0 
P 
add
(-1 3 2) 
(1.0 1.5 1.5) 
6.5 
P 
test
(-1 3 2) 
(1.0 0.0 1.0) 
1.0 
N 
subtract
(-2 3 1) 
(1.0 1.0 0.0) 
1.0 
N 
subtract
(-3 2 1) 
(1.0 0.0 0.0) 
-3.0 
N 
test
(-3 2 1) 
(1.0 2.0 2.0) 
3.0 
P 
test
(-3 2 1) 
(1.0 1.5 1.5) 
1.5 
P 
test
(-3 2 1) 
(1.0 0.0 1.0) 
-2.0 
N 
test
(-3 2 1) 
(1.0 1.0 0.0) 
-1.0 
N 
test
(-3 2 1) 
(1.0 0.0 0.0) 
-3.0 
N 
test
The following C++ program classify.cpp implements the algorithm.
// classify.cpp
#include <iostream>
#include <cstdlib>
#include <ctime>
using namespace std;

Neural Networks 307
void classify(double **P,double **N,int p,
int n,double *w,int d)
{
int i, j , k = 0, classified = 0;
double *x, sum;
srand(time(NULL));
for(i=0;i<d;i++) w[i] = double(rand())/RAND_MAX;
while(!classified)
{
i = rand()7.(p+n-l);
if(i<p) x = P[i]; else x = N[i-p];
for(j=0,sum=0.0;j<d;j++) sum += w[j]*x[j];
if((i<p) && (sum<=0.0))
for(j=0;j < d;j++) w[j] += x[j];
if((i>=p) kk (sum>=0.0))
for(j=0;j < d;j++) w[j] -= x[j];
k++;
classified = 1;
// check if the vectors are classified,
// we expect a minimum of 2 iterations through
// the p+n elements of the training
if((k°/.(2*p+2*n)) == 0)
{
for(i=0;(i<p) kk classified;i++)
{
sum = 0.0;
for(j=0,sum=0.0;j<d;j++) sum += w[j]*P[i] [j];
if(sum <= 0.0) classified = 0;
}
for(i=0;(i<n) kk classified;i++)
{
sum = 0.0;
for(j=0,sum=0.0;j<d;j++) sum += w[j]*N[i] [j];
if(sum >= 0.0) classified = 0;
}
}
else classified = 0;
}
}
int main(void)
{
double **P = new double*[2];

308 Problems and Solutions
P[0] = new double[3]; P[1] = new double[3];
P[0][0] = 1.0; P[0][l] = 2.0; P[0] [2] = 2.0;
P[l][0] = 1.0; P[1][1] = 1.5; P[l] [2] = 1.5;
double **N = new double*[3];
N [0] = new double[3] ;
N [1] = new double[3];
N[2] = new double[3] ;
N[0][0] = 1.0; N[0][l] = 0.0; N[0] [2] = 1.0;
N[l][0] = 1.0; N[1][1] = 1.0; N[l][2] = 0.0;
N[2][0] = 1.0; N[2][l] = 0.0; N[2][2] = 0.0;
double *w = new double[3];
classifyCP.N^.S.w.S);
cout « "w = ( " « w[0] « " , " « w[l]
« 
" , " « w[2] « " ) " « endl;
delete [] P[0] ; delete [] P[l] ;
delete[] N[0]; deleted N[l] ; delete[] N[2] ;
delete [] P; delete [] N;
delete w;
return 0;
}
Problem 2. 
For the back-propagation algorithm in neural networks we
need the derivative of the functions
M O ^ T T W 
A>0 
(1)
and
gx(x) = tanh(Aa;), 
A > 0 . 
(2)
Find the ordinary differential equations for f\ and g\.
Solution 2. The derivative of f\ is given by
dfx = 
Ae-*«
dx 
(1 + e~Xx)2 '
Using (1) we obtain
Thus the derivative can be replaced by \f\(l 
— f\)- The derivative of g\
is given by
^ 
= Asech2(Ax) = A 
\ 
.
dx 
v 
' 
cosh2 (Ax)

Neural Networks 309
Since sech2(a) + tanh2(a) = 1 and using (2)
tanh (Arc) = g\{x)
yields
Thus the derivative can be replaced by A(l - g\).
Problem 3. In the case of least squares applied to supervised learning
with a linear model the function to be minimized is the sum-squared-error
S := £(fc - /(x,))2
i=0
where
m - l
/(X) = ^2 WJhj(X)
and the free variables are the weights { Wj } for j = 0,l,...,m— 1. The
given training set, in which there are p pairs (indexed by j running from 0
up to p — 1), is represented by
(i) Find the weights Wj from the given training set and the given hj.
(ii) Apply the formula to the training set
{(1.0,1.1), 
(2.0,1.8), 
(3.0,3.1)}
i.e., p = 3, x0 = 1.0, yo = 1.1, xi = 2.0, yi = 1.8, x2 = 3.0, y2 = 3.1.
Assume that
ho(x) = l, 
h1(x)=x, 
h2{x)=x2
i.e., m = 3.
Solution 3. (i) Differentiating 5 with respect to Wj yields
Since
|£(*0 = M*)

310 Problems and Solutions
we find
P-I 
p-i
J2 f(x^hi (x0 = Yl Vihi ^
for j = 0,1,..., m — 1. This equation can be written as
hjf = hjy
where
(
Mxo) \ 
/ /(xo) \ 
/ y° \ 
I *o \
hM) 
/(xi) 
U 
^i
hjixp-!)/ 
\/(xp_1)/ 
\yP-i/ 
Vwm-i/
We introduce the p x m matrix (so-called design matrix)
(
Mxo) 
fti(xo) 
... 
/im-i(xo) \
/io(xi) 
^i(xi) 
. . . 
/im_i(xi)
= 
i 
- . 
i 
•
/io(Xp_i) 
^i(Xp_i) 
. . . 
hm-i{^-i)/
Since
f = ffw
we finally arrive at
w = (F Tff)- 1F Ty.
(ii) For the given case ho{x) = 1, h\{x) — x and h2(x) = x2 we find the
3 x 3 matrix
(1 
1 1\
£T= 
1 2 4 .
\ 1 
3 9 /
Thus
/I 
1 1\
HT=\1 
2 3
\ l 
4 9y/
and
/ 3 
6 14\ 
/ 19 -21 
5\
FTiJ = I 6 14 36 I , 
(HTH)-X = 
-21 24.5 -6 
.
\ 14 36 98/ 
\ 
5 
-6 
1.5/
Finally
fwo\ 
( 19 -21 
5\ (I 
1 1\ /1.1\ 
/ 
1.0\
I t£>i I = I —21 24.5 -6 
1 2 3 
1.8 
= 
-0.2 
.
\w2j 
\ 
5 -6 
1.5/ \ 1 4 9/ \ 3 . 1 / 
\ 0.3/

Neural Networks 
311
Problem 4. Consider the following 14 capital letters
AE F H I K LM NTV 
XY 
Z.
Each letter can be described by a 7 x 5 matrix with entries 0 or 1. For
example A is represented by
/0 0 1 0 0\
0 1 0 
1 0
1 0 
0 0 1
A= 
1 1 1 1 1
1 0 
0 0 1
1 0 
0 0 1
\ 1 0 0 0 1/
and E is represented by
/ I 
1 1 1 1\
1 0 
0 0 0
1 0 
0 0 0
E= 
1 1 1 1 0 
.
1 0 
0 0 0
1 0 
0 0 0
V i 
i 
i 
i 
i /
Write a C++ program that finds the Hamming distance of an arbitrary
input of a 7 x 5 matrix with 0's and 1' to the letters A and E. What is the
Hamming distance of A and El
Solution 4. The Hamming distance between E and A is 14.
// Hamming.cpp
#include <iostream>
using namespace std;
int hamming(int Ml[7][5],int M2[7][5],int rows,int columns)
{
int d = 0;
for(int i=0;i<rows;i++)
for(int j=0;j<columns;j++)
{
if(Ml[i] [j] != M2[i] [j]) d++;
}
return d;
>

312 
Problems and Solutions
int main(void)
{
const int rows = 7;
const int columns = 5;
int A[rows][columns];
A[0][0]=0; A[0][l]=0; A[0][2]=l; A[0] [3]=0; A[0][4]=0;
A[l][0]=0; A[l][l]=l; A[l][2]=0; A[l][3]=l; A[l][4]=0;
A[2][0]=l; A[2][l]=0; A[2][2]=0; A[2][3]=0; A[2][4]=l;
A[3][0]=l; A[3][l]=l; A[3][2]=l; A[3][3]=l; A[3][4]=l;
A[4][0]=l; A[4][l]=0; A[4][2]=0; A[4][3]=0; A[4][4]=l;
A[5][0]=l; A[5][l]=0; A [5] [2]=0; A[5][3]=0; A[5][4]=l;
A[6][0]=l; A[6][l]=0; A [6] [2]=0; A [6] [3]=0; A[6][4]=l;
int E[rows][columns];
E[0][0]=l; E[O][l]=l; E[0][2]=l; E[0][3]=l; E[0][4]=l;
E[l][0]=l; E[l][l]=0; E[l] [2]=0; E[l] [3]=0; E[l][4]=0;
E[2][0]=l; E[2][l]=0; E[2] [2]=0; E[2] [3]=0; E[2] [4]=0;
E[3][0]=l; E[3][l]=l; E[3] [2]=1; E[3][3]=l; E[3][4]=0;
E[4][0]=l; E[4][l]=0; E[4] [2]=0; E[4] [3]=0; E[4][4]=0;
E[5][0]=l; E[5][l]=0; E[5] [2]=0; E[5][3]=0; E[5][4]=0;
E[6][0]=l; E[6][l]=l; E[6][2]=l; E[6][3]=l; E[6][4]=l;
int In[rows][columns];
In[0][0]=l; In[0][l]=0; In[0][2]=i; In[0][3]=l; In[0][4]=l;
In[l][0]=l; In[l][l]=l; In[l] [2]=0; In[l] [3]=0; In[l] [4]=0;
In[2][0]=l; In[2][l]=0; In [2] [2]=0; In[2][3]=0; In[2][4]=0;
In[3][0]=l; In[3][l]=l; In[3][2]=l; In [3] [3]=1; In [3] [4]=1;
In[4][0]=l; In[4][l]=0; In [4] [2]=0; In [4] [3]=0; In [4] [4]=0;
In[5][0]=l; In[5][l]=0; In [5] [2]=0; In [5] [3]=0; In [5] [4]=0;
In[6][0]=l; In[6][l]=l; In [6] [2]=1; In[6][3]=l; In [6] [4]=0;
int distAIn = hamming(A,In,rows,columns);
cout « "distAIn = " « distAIn « endl;
int distEIn = hamming(E,In,rows,columns);
cout « "distEIn = " « distEIn « endl;
int distAE = hamming(A,E,rows,columns);
cout « "distAE = " « distAE;
return 0;
>

Neural Networks 
313
Problem 5. 
Let the training set of two separate classes be represented
by the set of vectors
(vo,j/o), 
(vi,yi), ... 
,{vn-i,yn-i)
where Vj (j = 0,1,..., n — 1) is a vector in the m-dimensional real Hilbert
space Rm and yj € {—1,+1} indicates the class label. Given a weight
vector w and a bias b, it is assumed that these two classes can be separated
by two margins parallel to the hyperplane
w Tv i + b>l, 
for 
yj = +1 
(1)
vrTVj+b<-l, 
for 
Vj = - 1 
(2)
for j = 0,1,... ,n—1 andw — (wo,wi,... ,wm_i)T is a column vector of m-
elements. Inequalities (1) and (2) can be combined into a single inequality
yj(wTvj+b)>l 
for j = 0,1,... ,n - 1. 
(3)
There exist a number of separate hyperplanes for an identical group of
training data. The objective of the support vector machine is to determine
the optimal weight w* and the optimal bias b* such that the corresponding
hyperplane separates the positive and negative training data with maximum
margin and it produces the best generation performance. This hyperplane
is called an optimal separating hyperplane. The equation for an arbitrary
hyperplane is given by
w Tx + 6 = 0 
(4)
and the distance between the two corresponding margins is
T 
T
7(w, b)= 
mm 
T.—n— 
max 
- — - . 
(5)
{v|y= 
+ l} ||w|| 
{v|i,= -l} 
||W||
The optimal separating hyperplane can be obtained by maximizing the
above distance or minimizing the norm of ||w|| under the inequality con-
straint (3), and
7macc=7(w*,b*) = ~ 
(6)
The saddle point of the Lagrange function
1 
n-i
LP(w, b, a) = - w r w - V ai(j/i(wrvi + b) - 1) 
(7)
1 
i=o
gives solutions to the minimization problem, where ctj > 0 are Lagrange
multiplier. The solution of this quadratic programming optimization prob-
lem requires that the gradient of Lp(yv, b, a) with respect to w and b van-
ishes, i.e.,
<5w w=w. 
° ' 
db 6=6, " ° -

314 Problems and Solutions
We obtain
n-l
w* = I>;y;v,- 
(8)
i=o
and
n-l
5>,-Ife=0. 
(9)
Inserting (8) and (9) into (7) yields
n—1 
1 n—1n—1
M a ) = JZ Qi ~ 2 51 S 
aiaoViViv'iwJ 
(10)
i=0 
i=0 
j=0
under the constraints
E
Q ^ = 0 
(n)
and
aj > 0, 
j = 0,1,... ,n — 1.
The function LD(OL) has be maximized. Note that Lp and Lp arise from
the same objective function but with different constraints; and the solution
is found by minimizing Lp or by maximizing LD- The points located on the
two optimal margins will have nonzero coefficients Oj among the solutions
of maxifl(a) and the constraints. These vectors with nonzero coefficients
otj are called support vectors. The bias can be calculated as follows
b* = - - I 
min 
w*Tv, + 
max 
w*Tv7 | .
2\{Vj\yj=+i} 
{v,|Vj=-i} 
V
After determination of the support vectors and bias, the decision function
that separates the two classes can be written as
/„-! 
\
/ ( x ) = s g n 
^ 
a j V j v j x + 
b*\.
V=° 
/
Apply this classification technique to the data set (AND gate)
j 
Training set Vj 
Target yj
~0 
(Ofi) 
1
1 
(0,1) 
1
2 
(1,0) 
1
3 | 
(1,1) 
1 
- 1

Neural Networks 315
Solution 5. For the present data set we find
3 
1 
1
LD(a) = Yla}~ o01* + aia3 ~ 2°% + a2Q3 ~ °^
since for the scalar products we have
v J V j = 0 , 
j = 0,l,2,3
and
v{vi = 1, vf v2 = 0, vjv3 = 1, vjfv2 = 1, v^v3 = 1, v^v3 = 2.
The constraints are
a0 > 0, ai > 0, 
a2 > 0, 
a3 > 0
and
ao + c*i + a2 - a3 = 0.
To apply the Kuhn-Tucker conditions (which is formulated for a minimum)
we have to change LD(OL) to -LD(a). 
Thus we have the Lagrangian
3 
1 
1
L(a) = — 5Z QJ + 2 ai ~ aiC*3 + 2°^ ~ a 2 Q 3 + ^
—/i(ao + c*i + a 2 — a 3 ) — Aoao — ^i<xi — A2CC2 — A 3 a 3 .
Thus we have to solve the sytem of equations
dl
TT- =0^-l-/x-A0=0
da0
dl
a— = 0 —)• - 1 + Qi - a 3 - /x - Ai = 0
aai
5£
a— = 0 —> - 1 + a2 - a 3 - fi - A2 = 0
oa2
dl
a— = 0 -> - 1 - ai - a 2 + 2a3 + fj. - A3 = 0
da 3
together with
AOQo = 0, 
Axe*! = 0, 
A2a2 = 0, 
A 3Q 3 = 0
Ao > 0, 
Ai > 0, 
A2 > 0, 
A3 > 0
and the constraints a0 + e*i + a2 - a3 = 0 . We find the solution
a0 =0, ai = 2, a2 = 2, a3 = 4

316 Problems and Solutions
Ao = 2, Ai=O, 
A 2=0, 
A 3=0, 
/x = - 3 .
Thus
3
W = 5^aJ%vj = (-2.-2)-
3=0
For 6* we obtain b* = 3. The decision function that separates the two
classes is given by
/(x) = sgn(au/ivf x + a2y2v^x + a3y3v^x + b*)
= sgn(2o;2 + 2zi - A(xt + x2) + b*)
= sgn(-2xi - 2:r2 + 3)
( 
3 \
= sgn -xi - x2 + - I •
V 
*• J
Thus
3
Xl+X2 = - .
This solution can also be seen on inspection of the data set.
Problem 6. 
In the previous problem we have considered a data set
which can be separated by a hyperplane. For nonlinear decision boundaries
we can extend the method as follows. The datapoints, Vj only appear
inside a scalar product. We map the datapoints into an alternative higher
dimensional space, called feature space, through
vfvi->Mvi),#vi)>
where (, ) denotes the scalar product in the feature space. The map </>(VJ)
does not need to be known since it is implicitly defined by the choice of the
positive definite kernel
K(vi,vj) 
= (cf>(vl),4>(vj)).
It is assumed that K(vi,Vj) = K(vj,Vi). 
Examples are the radial base
function kernel
if(vi,v,) = exp(-||vi-vj||2/(2(T2))
and the polynomial kernel
K(vi,vj) = (l + vTvj)d.
For binary classification with a given choice of kernel, the learning task
therefore involves maximization of the Lagrangian
n —1 
.. n— 1 n—1
i=0 
i=0 j=0

Neural Networks 317
subject to the constraints
n-1
^Taiyi=Q, 
ai>0, i = 0,1,... ,n - 1.
After the optimal values a* have been found the decision function is given
by
/(x) = sign ( J2 <x;yiK{x, v,) + b\ .
\i=0 
I
The bias 6 is found from the primal constraints
(i) Find the Kuhn-Tucker conditions.
(ii) Let v = (t>i,V2)T and a feature map that maps
v -• 0(v) = {vl,vl, V2VM, V2Vl,V2v2,1)T .
Find the kernel function K{yi,Vj).
(iii) Find the solutions of the Kuhn-Tucker conditions from (i) for the kernel
given in (ii) and the data set
j 
Training set v,- 
Target y^
~0 
(-1,-1) 
=1
1 
(-1.+1) 
+1
2 
(+1,-1) 
+1
3 1 
(+!,+!) 
[ 
-1
(iv) Derive a relation between the learning rate r] and the kernel using
n—1 
^ n—In—1 
n—1
L(a) = XI ai ~ 2 X^ X] aiajyiyjK(vi, Vj) - n ^2 ajVi •
j=0 
i=0 j=0 
j=0
and choose the gradient ascent algorithm
dL 
( 
"~1 
\
6ak = r)— = r) 1 - yk X ajVjK(yj^k) 
- MJ/fc I •
* 
V 
J=° 
/
(v) The Kernel-Adatron algorithm is given by
1. Initialize ao = oc\ = • • • = cx-n-i = 1 , 0 = 0.

318 
Problems and Solutions
2. For i — 0,l,...,n-l 
calculate
ra-1
j=o
3. Calculate 7, = yi(zi — 6).
4. Let 6oti := 77(1 — 7,) be the proposed change to c^.
(a) if on + 5ai < 0 then a.i — 0 .
(b) if a,- + S > 0 then aj = a, + <5a, .
5. Calculate the new threshold
9 := 2^
ml
n(-
Z^
 
+mf
x(
2:»
:"))
where zt
+ are those patterns i with class label +1 and z~ those with
class label — 1.
6. If a maximum number of presentations of the pattern set has been
exceeded or the margin
m := -(min(2+) - max(z,"))
has approached 1 then stop, otherwise return to step 2.
Solution 6. 
(i) For the Kuhn-Tucker conditions (which are formulated
for a minimum) we have to change LD to —Ljy. Thus taking into account
the constraints we have the Lagrangian
n—1 
.. n— I n — 1 
n — 1 
n—1
Ha) = - Y^ aj + j Yl H anajyiyjKivuVj) - y. ^ 
a^j - ^ Aj-oij.
j=0 
i=0 j=0 
j=0 
j=0
From dL/dctk = 0 we find
n - l
- 1 + yfc ^ 
ajyjKiyk.-Vj) 
- (iyk - \k = 0
j=0
for A: = 0 , 1 , . . . , n - 1. The other Kuhn-Tucker conditions are
n - l
oij>0, 
j = 0 , 1 , . . . , 
ra-l
Aja3-=0, 
j = 0,1,... ,ra- 1
Aj>0, 
j = 
0,l,...,n-l.

Neural Networks 319
Note that there is no condition on the Lagrange multiplier fi.
(ii) The kernel function for the feature space is
K(Vi,Vj) = {viXvn + vi2vj2 + I)2 = (1 + (vfvj))2 .
(iii) Inserting the data set into the kernel we obtain a (positive definite)
matrix with if(vz-,Vj) = 9 and K(Vi,Vj) 
— 1 for i ^ j with i,j = 0,1,2,3.
The solution of the Kuhn-Tucker conditions is given by
1
a0 = a\ = a2 = a3 = -
o
and Ao = Ai = A2 = A3 = y, — 0. Furthermore, we have 6 = 0. Thus
/(x) = sgn(-a:i:E2).
(iv) We obtain
ALk := L(ao,..., 
ak + Sak,..., 
a n_i) - L(a0,..., 
ak,.. •, an-i)
/ 
n-l 
\ 
1
= Sak 1 -yk^ajVjKiv^Vk) 
- fiyk I - -{5ak)2K(vk, vk)
-(i-^)(W.
Given that AX^ > 0 we find 0 < r]K(-vk,Wk) < 2 and thus
When L reaches a maximum value and the we have a stable solution, Sak =
0. Thus it follows that
n—l 
n-l
1 - j/*: 5Z aiyjK(vj,vk) 
- yyk = yk{yk - Y^ ajyjK(vJ,vk) 
- /x) = 0
3=0 
j=o
where we used that y\ — +1.
(v) The C++ program could be improved by calculating the kernel before-
hand.
// kerneladatron.cpp
#include <iostream>
#include <cmath>
#include <vector>
using namespace std;

320 
Problems and Solutions
double K(double vi[2], double vj[2]) / / kernel
{
double kl=l+vi[0]*vj[0]+vi[1]*vj[1];
return kl*kl;
}
int main(void)
{
const int m = 4;
double v[m][2] = { {-1,-1}, {-l.+l}, {+1,-1}, {+1.+1} };
double y[m] 
= { 
+1, 
- 1 , 
- 1 , 
+1 };
double alpha[m];
double eta=0.01, eps=0.00001, margin=0.0, theta=0.0;
double min, max;
int i, j , mininit, maxinit;
for(i=0;i<m;i++) alpha[i]=l.0;
while(fabs(margin-1.0)>eps)
{
mininit=maxinit=l;
for(i=0;i<m;i++)
{
double z = 0.0;
for(j=0;j<m;j++) z += alpha[j]*y[j]*K(v[i],v[j]);
double delta=eta*(1.0-y[i]*(z-theta));
if(alpha[i]+delta<=0.0) alpha[i] =0.0;
else 
alpha[i] += delta;
if((mininit II z<min) && y[i]>0) { min=z; mininit=0; }
if((maxinit II z>max) && y[i]<0) { max=z; maxinit=0; }
}
margin=(min-max)/2.0; theta=(min+max)/2.0;
>
for(i=0;i<m;i++)
cout « "alpha[" « i « "] = " « alpha[i] « endl;
cout « "theta = " « theta « endl;
return 0;
}

Chapter 16
Genetic Algorithms
Problem 1. Consider the function
where e is a small positive constant. What is the problem finding the
mimimum of this function using genetic algorithms? Compare with the
gradient descent method.
Solution 1. The minimum of this function is at (0,0). Any gradient
method can find it immediately. It is not possible to approach the point
(0,0) following the axes. This means that only correlated mutations are
favorable, so that the origin is reached through the diagonal valleys of the
function. Functions which "hide" the optimum from genetic algorithms
have been called deceptive functions.
Problem 2. Consider the polynomial
p{x) = x4 - 7x3 + 8x2 + 2x - 1.
The zeros are given by the solution of the equation
p(x*)=0.
(i) Apply genetic algorithms to search for zeros in the range [0,8]. What
are fitness functions for this problem?
321

322 Problems and Solutions
(ii) Write a C++ program that implements the algorithm. Use mutation
and crossover as genetic operations.
Solution 2. (i) As fitness function we can use
f(x) = -p{x) • p(x)
which we have to maximize, i.e., the zeros of the polynomial p are found
where / takes a global maximum. Obviously the global maximum of / is
0. Another possible fitness function would be f(x) = \p(x)\. This fitness
function has to be minimized.
(ii) For faster calculation of / we use Homer's scheme. The elements in the
farm is 24 and the length of the bitstring is 20. The number of iterations
is 1000. The output provides the two zeros 5.6385 and 1.21558. The two
other roots of p have an imaginary part.
// genetic.cpp
#include <iostream>
#include <cstdlib> 
// srand(), rand()
#include <ctime> 
// time()
#include <cmath> 
// pow
using namespace std;
// fitness function where maximum to be found
double f(double x)
-C
double temp = -1.0 + x*(2.0 + x*(8.0 + x*(-7.0 + x)));
return -temp*temp;
}
// fitness function value for individual
double f_value(double (*func)(double),int* arr.intfe N,
double a,double b)
{
double res;
double m = 0.0;
for(int j=O;j<N;j++)
{
double k = j;
m += arr[N-j-l]*pow(2.0,k);
}
double x = a + m*(b-a)/(pow(2.0,N)-1.0);
res = func(x);
return res;

Genetic Algorithms 323
}
// x_value at global maximum
double x_value(int* arr,int& N,double a,double b)
{
double m = 0.0;
for(int j=O;j<N;j++)
{
double k = j;
m += arr[N-j-l]*pow(2.0,k);
}
double x = a + m*(b-a)/(pow(2.0,N)-1.0);
return x;
>
// setup the population (farm)
void setup(int** farm,int M.int N)
•C
srand((unsigned) time(NULL));
for(int j=O;j<M;j++)
for(int k=0;k<N;k++)
farm[j] [k] = rand()y.2;
}
/ / cross two individuals
void crossings(int** farm.intfe M,int& N.doubleft a,double& b)
{
int K = 2;
int** temp = new int* [K];
for(int i=0;i<K;i++) temp[i] = new int[N];
double res[4];
int rl = randO'/.M; 
int r2 = randO'/.M;
/ / random returns a value between
/ / 0 and one less than its parameter
while(r2 == rl) r2 = rand()7,M;
res[0] = f_value(f,farm[rl],N,a,b);
res[l] = f_value(f,farm[r2],N,a,b);
for(int j=0;j<N;j++)
{
temp[0][j] = farm[rl] [j] ; temp[l] [j] = farm[r2] [j] ;
}
int r3 = rand()'/.(N-2) + 1;

324 
Problems and Solutions
for(j=r3;j<N;j++)
{
temp[O][j] = farm[r2][j]; temp[l] [j] = farm[rl] [j] ;
>
res[2] = f_value(f,temp[O],N,a,b);
res[3] = f_value(f,temp[l],N,a,b);
if(res[2] > res[O])
{
for(j=0;j<N;j++)
farm[rl] [j] = temp[O] [j];
res [0] = res [2] ;
}
if(res[3] > res[l])
{
for(j=0;j<N;j++)
farm[r2] [j] = temp[l] [j] ;
res[l] = res [3] ;
}
for(j=0;j<K;j++) deleted temp[j] ;
delete[] temp;
>
/ / mutate an individual
void mutate(int** farm,int& M,int& N,double& a,double& b)
{
double res[2];
int r4 = randO'/.N; int rl = rand()'/.M;
res[0] = f_value(f,farm[rl],N,a,b);
int vl = farm[rl][r4];
if(vl == 0) farm[rl][r4] = 1;
if(vl == 1) farm[rl][r4] = 0;
double al = f_value(f,farm[rl],N,a,b);
if(al < res[0]) farm[rl][r4] = vl;
int r5 = rand()°/.N; int r2 = rand()"/,M;
res[l] = f_value(f,farm[r2],N,a,b);
int v2 = farm[r2] [r5];
if(v2 == 0) farm[r2][r5] = 1;
if(v2 == 1) farm[r2][r5] = 0;
double a2 = f_value(f,farm[r2],N,a,b);
if(a2 < res[l]) farm[r2][r5] = v2;
}

Genetic Algorithms 325
int main(void)
{
int M = 24; 
// population (farm) has 24 individuals
int N = 20; 
// length of binary string
int** farm = NULL; 
// allocate memory for population
farm = new int* [M];
for(int i=0;i<M;i++) farm[i] = new int[N];
setup(farm,M,N);
double a = 0.0; double b = 8.0; // interval [a,b]
for(int k=0;k<1000;k++)
{
crossings(farm,M,N,a,b);
mutate(farm,M,N,a,b);
y // end for loop
int j ;
for(j=0;j<M;j++)
cout « "fitness f.value[" « j « "] = "
« 
f_value(f,farm[j],N,a,b)
« " " « "x_value[" « j « "] = "
« x_value(farm[j],N,a,b) « endl;
for(j=0;j<M;j++) delete[] farm[j];
delete [] farm;
return 0;
>
Problem 3. 
Consider the nonlinear second-order ordinary differential
equation
,2
(u — x)—-^ + sin2(a;) = 0
with the boundary value problem
u(0) = 0, 
u(l) = l + sin(l), 
xG[0,l}-
As an ansatz for the solution we use the polynomial
u{x) = c0 + c\x + c2x2 + c3x3 + c4x4 .
(i) Why can we set CQ = 0? Use the second boundary condition to eliminate
one more coefficient.
(ii) Explain why we can define a fitness function as
/(c 2, c3, c4) = - J2 (("(J -h)-j-h) 
^
^ 
k) + sin 2(j - h)^ 2

326 Problems and Solutions
where h is the step length (for example h = 0.1).
Solution 3. (i) Since u(0) = 0 we find CQ = 0. From the second boundary
condition we find
u(l) = 1 4- sin(l) = ci + c2 + c3 + c4 .
Thus
c\ = 1 + sin(l) - c2 — C3 - c4 .
(ii) For the implementation of the second order derivative, we first differ-
entiate u, i.e.,
—^ = 2c2 + 6c3x + I2c4x2
ax*
and then replace xby j-h. Inserting u(j• h) for u(x), j-h for 2; and 
d2u/dx2
into the differential equation yields the fintness function /.
Problem 4. 
Consider the symmetric 10 x 10 matrix
/2 1 0 0 0 0 0 0 0 
0\
1 2 1 0 0 0 0 0 0 0
0 1 2 1 0 0 0 0 0 0
0 0 1 2 1 0 0 0 0 0
. 
0 0 0 1 2 1 0 0 0 0
0 0 0 0 1 2 1 0 0 0
0 0 0 0 0 1 2 1 0 0
0 0 0 0 0 0 1 2 1 0
0 0 0 0 0 0 0 1 2 1
VO 0 0 0 0 0 0 0 1 
2/
and the linear equation
Ax = r
where
r = ( l 1 1 1 1 1 1 1 1 1)T.
Here T denotes transpose. Find a fitness function so that genetic algorithms
can be used to solve this linear equation.
Solution 4. A possible fitness function is
l x 
9 
9 
\
\ 
i=0 j=0 
J
where a^ are the matrix elements of A. This function has to be maximized.

Genetic Algorithms 327
Problem 5. 
Let A be a given m x m symmetric positive-semidefinite
matrix over R. Let b £ Rm, where b is a given column vector. Consider
the quadratic functional
£(x) = ixTAx - xTb
where T denotes transpose. The minimum x* of E(x) over Rm is unique
and occurs where the gradient of E(x) vanishes, i.e.,
VE(x = x*)=Ax-b = 0.
The quadratic minimization problem is thus equivalent to solving the sys-
tem of linear equations Ax = b. Let
Use E as a fitness function to solve the system of linear equations applying
genetic algorithms.
Solution 5. We have to find the minima of the function
E(x)^-ixl,X2){i 
; ) ( £ ) - ( * i , * 3 ) ( i )
= x\ + X\%2 
+ ~x\ 
— Xi — X2 .
The solution is x\ = 0, x<i = 1.
Problem 6. A map is called n-colorable if each region of the map can be
assigned a color from n different colors such that no two adjacent regions
have the same color. The four color conjecture is that every map is 4-
colorable. In 1976 Appel and Haken proved the four color conjecture with
extensive use of computer calculations. We can describe the m regions of
a map using a m x m adjacency matrix A where Aij = 1 if region i is
adjacent to region j and Aij = 0 otherwise. We set An = 0. For the fitness
function we can determine the number of adjacent regions which have the
same color. The lower the number, the fitter the individual. Individuals
are represented as strings of characters, where each character represents the
color for the region corresponding to the characters position in the string.
Write a Java program that uses genetic algorithm to find a solution of the
four color problem given the adjacency matrix.
Solution 6. The data member population is the number of individuals
in the population, and mu is the probability that an individual is mutated.

328 
Problems and Solutions
The method fitness () evaluates the fitness of a string using the adjacency
matrix to determine when adjacent regions have the same color. If the fit-
ness is equal to 0 we have found a solution. The adjacency matrix can
be modified to solve for any map. The method mutate() determines for
each individual in the population whether the individual is mutated, and
mutates a component of the individual by randomly changing the color.
The method crossing () performs the crossing operation. The genetic
algorithm is implemented in the method GA (). The arguments are an ad-
jacency matrix, a string specifying which colors to use and the number of
regions on the map. It returns a string specifying a solution to the problem.
One such solution is YBRBYGYRYB, where R stands for red, G for green, B for
blue and Y for yellow.
/ / FourColor.Java
public class FourColor
{
static int population = 1000;
static double mu = 0.01;
public static void main(String[] args)
{
int[][] adjM = {-[0,1,0,1,0,0,0,0,0,0},
{1,0,1,0,0,1,0,0,0,0},
{0,1,0,0,0,0,1,0,0,0},
{1,0,0,0,1,1,0,0,0,0},
{0,0,0,1,0,1,0,1,0,0},
{0,1,0,1,1,0,1,0,1,1},
{0,0,1,0,0,1,0,0,0,1},
{0,0,0,0,1,0,0,0,1,0},
{0,0,0,0,0,1,0,1,0,1},
{0,0,0,0,0,1,1,0,1,0}};
System.out.println(GA(adjM,"RGBY",10));
}
static int fitness(int[][] adjM,String s.int N)
{
int count = 0;
for(int i=0;i<N-l;i++)
{
for(int j=i+l;j<N;j++)
{
if((s.charAt(i) == s.charAt(j)) && (adjM[i][j] == 1))

Genetic Algorithms 329
count++;
}
}
return count;
}
static void mutate(String[] p,String colors)
{
int j;
for(int i=0;i<p.length;i++)
•C
if(Math.random()<mu)
{
int pos=(int)(Math, random O*(p[i].length()-1));
int mut=(int) (Math.randomO*(colors.length()-2)) ;
char[] cal=p[i] .toCharArrayO;
char[] ca2=colors. toCharArrayO ;
for(j=0;cal[pos]!=ca2[j];j++) {};
cal [pos] =ca2 [(j +mut)'/.colors. length()] ;
p[i]=new String(cal);
}
}
>
static void crossing(String[] p,int[][] adjM)
{
int pi = (int)(Math.random()*(p.length-1));
int p2 = pi;
int cl = (int)(Math.random()*(p[0].length()-l));
int c2 = cl;
while(p2==pl) p2 = (int)(Math.random()*(p.length-1));
while(c2==cl) c2 = (int)(Math.randomO*(p[0].length()-l));
if(c2<cl) -C int temp = c2; c2 = cl; cl = temp;}
String[] temp = new String[4];
temp[0]=p[pi]; temp[1]=p[p2];
temp[2]=p[pl].substring(0,cl)+p[p2].substring(cl+l,c2)
+p[pl].substring(c2+l,p[pl].length()-l);
temp[3]=p[p2].substring(O,cl)+p[pl].substring(cl+l,c2)
+p[p2].substring(c2+l,p[p2].length()-l);
int i, f;
for(i=0,f=0;i<4;i++)
{
if (fitness (ad jM, temp [i] ,temp[i] .lengthO)
>fitness(adjM,temp[f] ,temp[f] .lengthO))

330 Problems and Solutions
f = i;
}
{ String tmp=temp[f]; temp[f]=temp[0]; temp[0]=tmp; }
for(i=l,f=l;i<4;i++)
{
if (fitness (adjM, temp [i] ,temp[i] .lengthO)
>fitness(adjM,temp[f] ,temp[f] .lengthO))
f = i;
}
{ String tmp=temp[f]; temp[f]=temp[l]; temp[l]=tmp; }
p[pl] = temp [2]; p[p2] = temp [3] ;
}
static String GA(int[][] adjM.String colors,int N)
{
int maxfitness, mfi = 0;
StringG p = new String [population] ;
char[] temp = new char[N] ;
for(int i=0;i<population;i++)
{
for(int j=O;j<N;j++)
{
temp[j] =
colors . charAt ( (int) ( (Math.randomO*colors . lengthO ) ) ) ;
}
p[i] = new String(temp);
}
maxf itness=f itness(adjM,p[O] ,p[0] .lengthO) ;
while(maxfitness!=0)
{
mutate(p,colors); crossing(p,adjM);
for(int i=0;i<p.length;i++)
{
if (fitness (adjM,p[i] ,p[i] . lengthO )<maxf itness)
{
maxfitness=fitness(adjM,p[i] ,p[i] .lengthO);
mfi = i;
}
>
}
return p[mfi];
}
}

Chapter 17
Optimization
Problem 1. 
Calculate the shortest distance (Euclidean) between the
curves
x2 + (y- 5)2 = 1
and
y — x2.
Apply the Lagrange multiplier method.
Solution 1. The square of the distance between two points (x\,yi) and
(^2,2/2) on the curves is given by
d2 = {xi - x2f + (2/1 - y2f •
We have two constraints. This means we have two Lagrange multipliers.
Thus, we define
F{x1,yl,x2,y2) 
:= {x1-x2)2 + 
(y1~y2)2+X1(x2
1+(y1-5)2~l)+X2{y2-xl).
Thus, we obtain the equations
OF
— = 2(x1-x2) 
+ 
2\1x1=0
OX 1
dF
— = -2(1! - x2) - 2X2x2 = 0
ox2
dF
Q£ = 2(2/x - 2/2) + 2Ai(yx - 5) = 0
dF
W2=-2(yi-y2) 
+ X2 = 0.
331

332 
Problems and Solutions
Adding the first two equations and the last two equations yields
Ai:ri = A2I2
2Ai(yi-5) = -A2.
Of course we still have
(1 + Ai)a;i =x2
(l + Ai)(j/i-5)=y 2-5
from the first set of equations. If Ai = 0, we have A2 = 0 so that x\ = x-i
and y\ = y2. Thus, we obtain
xl + (xl-5f = l
x\ - 9xj + 24 = 0
, 
9± y/^IE
*? = - ! —
Thus, Xx = 0 does not give a valid solution. Suppose A2 = 0. Once again
x\ — X2 and yi =2/2, thus A2 = 0 does not give a valid solution. Now,
suppose xi = 0, thus X2 = 2/2 = 0 and j/i = 6 or y\ = 4. Lastly, suppose
xi ± 0. Thus
^ = ^ = (l + A0
xi 
A2
^i( y i-5) = (l + A1)(y1-5) = - i
(l + A1)(2/i-5) = 2/2-5
9
2 / 2 = 2 "
From 2/2 = %2 we obtain
Furthermore, we have
1 + Ai 
a;2 
1/2 - 5 "
From a;^ + (j/i — 5)2 = 1 we obtain
|«?=4(W-5)a
yi=±v
/l
+5-

Optimization 333
We tabulate the solutions
xi 
Vi 
x2 
y2 
Value
0 
4 
0 
0 
4
0 
6 
0 
0 
6
Ws 
\ / J + 5 
- ^ 
1 3.179449
Ws 
- \ / i + 5 A s L179449
-* 
7 i + 5 A I 3-179449
- j s 
- \ / i + 5 
- ^ 
1 I 1-179449
The minimum distance is approximately 1.179449.
Problem 2. A firm uses two inputs to produce one output. Its production
function is
f { x 1 , x 2 ) = x
a
1x
b
2, 
a , b > l .
The price of the output is p, and the prices of the inputs are u>i and w2.
The firm is constrained by a law that says it must use exactly the same
number of units of both inputs. Use the Lagrange multiplier method to
maximize the function
g{xi,x2) =pf{xi,x2) 
- WiXi - w2x2
subject to x2 — xi = 0.
Solution 2. The Lagrange function is given by
L(x1:x2) =px\xb
2 -wixi 
~w2x2 - X(x2 
-xi).
Thus from
ax\ 
ox2
we find
apx\-xx\ 
- wi + A = 0, 
bpx\x\Tx - w2 - A = 0.
Furthermore, we have the constraint x2 = x1. These three equations have
a single solution
and
bu>i — aW2
a + b

334 Problems and Solutions
Thus
g(x*1,x*2)=p(x*1)a+b-x*1(w1+w2).
Problem 3. A household has the utility function
f(xl,x2)=x«x\-a
where a > 0 and faces the budget constraint
with m > 0. Maximize the household's utility using Kuhn-Tucker condi-
tions for the demand functions xi(j>i,p2,m) and x2{pi,P2,m)- 
Evaluate
the demand functions for (pi,P2,'m) = (1,0.5,10) and a = 0.5. Find also
f(xi,X2) for these values.
Solution 3. The Lagrangian is
L(x1,X2,tf = x"x\~a + \{m - pixi -P2X2)
with the Kuhn-Tucker conditions
^L - ^:r<V-« - Xm - 0
— 
— 
Xj X2 
Kp\ — U
dx\ 
x^
\(m — pixi — P2X2) = 0
A>0
m — p\Xi — P2X2 > 0.
If A = 0 the problem has no solution, since
OC-t Xty 
'—• U
only if X2 = 0, but then
X2
Thus A > 0. Therefore, we have to solve the system of nonlinear equations
—x?xl-a-\pi=0
x\
^—^•x'^xi-0' 
-Xp2=0
X2
m — p\X\ — P2X2 — 0

Optimization 335
where (m,pi,p2, a) are given and the unkowns are (x\,X2, A). The solution
is
m
x\ — a—
V\
*2 = ( l - a ) - .
At the given vector of prices, income, and a, we obtain xi = 5, xi — 10
and the utility is
/( X l=5,x 2 = 10)=51/2101/2.
Problem 4. Given the Lagrange function
L{x,x) = \J2{i)-^x))-\\{t) (l>,2-lj 
(1)
where A is the time-dependent Lagrange multiplier. The system describes
an n — 3 dimensional harmonic oscillator constrainted to a unit n — 1 = 2
sphere, i.e.,
I>2 = 1- 
(2)
Find the equations of motion using the Euler-Lagrange equations
Solution 4. From (3) and (1) we find
xj + u]Xj + X(t)Xj =0, 
j = 1,2,3. 
(4)
To eliminate the Lagrange multiplier A we proceed as follows. From (2) we
obtain by differentiating with respect to t
3
^2±jXj = 0
3 = 1
and differentiating twice with respect to t yields
3
52(£jXj+x*) = 0. 
(5)
3 = 1
 
(4)

336 Problems and Solutions
From (4) we obtain XjXj + w?x? 4- A(£)x^ = 0. Summation yields
3 
3
5>* xi + £ w i x ? + A(*) = 0
3 = 1 
3 = 1
where we used (2). Thus
A(i) = -£f,*,-£ W# = X>?-I>M
j=i 
j=i 
j=i 
j=i
where we used (5). Inserting A into (4) yields the equations of motion
3
Xj + J?Xj + Xj Y,(i2j ~ WjXj) = 0 -
3 = 1
Problem 5. 
Consider the constraint nonlinear programming problem
with inequality and equality constraints: minimize the scalar function /
subject to the inequality constraints gfc(x) > 0, k = 1,2,..., AT and the
equality constraints hm(x) = 0, m = 1, 2,..., M. For this problem we can
construct the Lagrange function
K 
M
L(X, A, ft) = / ( x ) - ^ 
^fe5fc(x) - ^ 
Mm/lm(x)
fc=l 
m-\
where Afc and /j,m are the Lagrange multipliers. If the problem has a solution
X* = (xl,X2, 
• • • , X*)
i.e., minx/(x) = /(x*) and all constraints are satisfied, then the following
conditions (called Kuhn-Tucker conditions) hold
K 
M
V/(x*) - J2 AfeV5fc(x*) - Y, /CVMx*) - 0
fc=l 
m = l
and
5fc(x*)>0 
k = 
l,2,...,K
hm(x*) = 0 
m=l,2,...,M
\*kgk(x*)=0 
k = 
l,2,...,K
X*k>0 
k = 
l,2,...,K.

Optimization 337
In convex programming problems, the Kuhn-Tucker conditions are neces-
sary and sufficient for a global minimum. Find the minimum of the function
/(X) = (X! - 2)2 + (x2 - I)2
under the constraints
gi(x)=x2-xl >0
32(x) = 2-xi -x2 >0
g3(x)=xx > 0.
Solution 5. The Lagrange function is
L(x, A) = (n - 2)2 + (x2 - I)2 - Ai(x2 - x\) - A2(2 - Xl - x2) - A3xx.
Thus we find the Kuhn-Tucker conditions
2(xi - 2) + 2AiXi + A2 - A3 = 0
2 ( i 2 - l ) - A i + A2=0
x2 - x\ > 0
2 - x i - x 2 > 0
x i > 0
Ai(x 2-x 2)=0
A2(2-xi - x 2 ) = 0
A3xj = 0
and
Ai>0, 
A 2>0, 
A 3>0.
These equations and inequalities can be solved starting from A3X1 = 0 with
the cases A3 = 0 or x| = 0. We find
9 
9
T * — 1 T * — 1 X* — 
\* — 
\* — n
for which /(x^x^) = 1.
Problem 6. A norm of an n x n matrix over R is given by
\\A\\ := max ||^x||
where x e Rn and ||^4x|| denotes the Euclidean norm. How can the con-
straint
||x|| = 1 <^ x2 + x\ + • • • + x2 = 1

338 Problems and Solutions
be eliminated?
Solution 6. 
We can introduce n-dimensional spherical coordinates
x\ =r cos#i
x-i—r sin 9\ cos #2
xz=r sin 6\ sin #2 cos 63
Xi=r sin 6\ sin #2 sin 63 cos 64
xn_i = r sin #i sin #2 sin O3 • • • sin 0n_2 cos 0n_i
i n = r sin #i sin #2 sin #3 • • • sin 0n_2 sin ^ra_i
or
fc-i
Xk =rcos6k TT sin^, 
for k = 1,2,..., n - 1
n-l
x"=r n
s i n ^
with r = 1, -7r < 6>i < 7T, and 0 < 6j < TT, 2 < j < n - 1. The inverse
transform is
/ 
Xk 
\
9k = arccos 
— p = = ^ ^ ^ 
, 
for fc = 1,2,..., n — 2
^n_i = arctan I —^— 1 .
\Xn-lJ
The Jacobian J of this transform is
n-\
J = rn-1Y[(smep)"-p-1.
P=i
Problem 7. 
Consider the traveling salesman problem with six cities A,
B, C, D, E, F, and their (x, ^-coordinates, i.e.,
,4 = (0,0), 
£ = (4,3), 
C = (l,7)
£> = (15,7), 
£ = (15,4), 
F = (18,0).
To find a solution of the traveling salesman problem the greedy algorithm
can be applied as follows:

Optimization 339
1) The shortest connection (Euclidean distance) between all the cities is
D — E with d = 3. Thus we add this connection to the path.
2) The next shortest distances are the connection B — C, A — B and E — F.
They all have the same distance, namely d = 5. Since they lead to no
contradictions of the problem, we add these connections to the path.
3) The next shortest connection is A - C, but it leads to a loop, and thus
cannot be added to the path.
4) The next shortest connection D — F also leads to a loop, and thus cannot
be added to the path.
5) The next shortest connection is B — E, but this line also contradicts the
problem.
6) The next shortest connection C — D can be added to the path.
7) To complete the path for a solution of the traveling salesman problem,
we have to add F — A. Then the path is
A-B-C-D-E-F-A.
Is this the path with the shortest distance?
Solution 7. 
The greedy algorithm normally leads only to a local mini-
mum. This is the case here. The path with the shortest distance is
A-C-D-E-F-B-A.
Problem 8. In the knapsack problem, we have a knapsack with a certain
capacity (c) that we wish to pack with a number of items. Each item i has
a value vi and a weight Wi. The task is to pack the knapsack in such a way
that the maximum value is obtained. If we can cut the items up, then the
problem can be solved with a greedy algorithm:
• Calculate the value-to-weight ratio of every item.
• Repeatedly pack in the item with the heighest value-to-weight ratio
until there is not enough space left for the object.
• Cut the highest value-to-weight ratio item to get a fractional amount
that just fills the knapsack and put it in.
Usually we cannot have a fractional amount of an item, in which case the
fraction of the item i, a,i, that we want to pack in must be either 0 or 1.
This is known as the Zero-One Knapsack Problem. In this case, we can try
to solve the problem using brute force: try every possible combination and
see which is best. This technique is O(2n). A faster approach uses dynamic

340 Problems and Solutions
programming. We consider packing all knapsacks with capacities 0 to c.
We want to maximize
n
/n(c) = y^ajVi
1 = 1
subject to the constraint
n
^ 
OjWj < C
» = 1
where n is the number of items, c is the capacity of the knapsack and
a,i € 0,1. We will try to pack each item i into knapsacks of size 0... c. If we
pack item i into a knapsack of size j , then the remaining capacity is j -Wi.
We try to find the optimal packing of a knapsack of capacity j — Wi with
the i — 1 items before this item and then add item i. If the value of this
packing is better than the current value for a knapsack of size j , then we
use this packing. Since we are using integers, we can represent fn(c) as a
two-dimensional array indexed by n and c. We have the properties
/i(0)=0, 
* = 0,l,...,n
/o(j) = O, j = 0,l,...,c.
To determine which items we take, we compare /*(c) and /i_i(c). If they
are the same, we pack the item in the knapsack. If not, we leave it behind.
If we take the item, then for the next item we must compare /i_i(c — lo,)
and fi-2{c — Wi) to take take into account the fact that item i is taken. This
algorithm is O(nc). Write a C++ program to solve the Zero-One Knapsack
Problem using this algorithm.
Solution 8.
// knapsack.cpp
#include <iostream>
#include <string>
using namespace std;
void knapsack(int c,int n.int *w,int *v,int *taken)
{
int i, j, p;
/ / allocate memory
int **f = new int*[n+1];
for(i=0;i<=n;i++) { f[i] = new int[c+l]; }
// initial conditions
for(j=0;j<=c;j++) { f[O][j] = 0; }
for(i=0;i<=n;i++) { f [i] [0] = 0; }

Optimization 341
for(i=l;i<=n;i++) { / / for every item
for(j=l;j<=c;j++) { / / for every knapsack size
f[i][j] = f[i-l][j]; / / assume we don't take the item
if(j-w[i-l]>=0) {
/ / we have space for it
/ / find the new value if we take it.
p = f [i-1] [j-w[i-l]]+v[i-l];
if(p>f[i-l][j]) { f[i][j]=p; }
>
>
>
/ / search from the end, to see which items are taken
i = n; j = c;
while(i > 0) {
if(f[i][j]!=f[i-l][j]) {
j -= w[i-l];
taken[i-l] = 1;
} else { taken[i-1]=0; }
i—;
>
for(i=0;i<=n;i++) { delete[] f[i]; >
delete [] f;
}
int main(void)
{
int n = 6, c = 20, weight = 0;
string* items = new string[n];
int* w = new int[n]; 
int* v = new int[n];
int* taken = new int[n];
w[0] = 3 ; v[0] = 5 ; items[0] = "torch";
w[l] = 1; v[l] = 6; items[1] = "knife";
w[2] = 5; v[2] = 5; items[2] = "bread";
w[3] = 5; v[3] = 2; items[3] = "camera";
w[4] = 10; v[4] = 15; items[4] = "clothes";
w[5] =4; v[5] = 1; items[5] = "books";
knapsack(c,n,w,v,taken);
cout « "Taken:" « endl;
for(int i=0;i<n;i++) {
if (taken [i]==O {
weight += w [i];
cout « " 
" « items[i] « endl;

342 Problems and Solutions
}
}
cout « "Total weight: " << weight « endl;
delete[] items;
delete [] w;
delete [] v;
delete[] taken;
return 0;
}
Problem 9. 
The following table describes jobs (or tasks) according to
their starting time and time of completion.
Job I Start I End"
1 
6 
W
2 
1
5
3 
1
6
4 
9 
12
5 
5 
7
6 
6 
14
7 
3 
7
8 
10 
14
9 I 
13 [ 16
Obviously, there may be some conflicts, for example job 1 and job 6 would
need to be done simultaneously. The scheduling problem requires that we
find the subset of maximum size of jobs which do not conflict. For example
doing jobs 3, 1, 9 in that order is a non-optimal solution. A greedy algorithm
is an algorithm that optimizes the choice at each iteration without regard to
previous choices. In the case of our scheduling problem, a greedy algorithm
chooses the job which finishes in the least amount of time in order to fit as
many jobs as possible. Obviously, this cannot in general lead to an optimal
solution. Write a C++ program which implements a greedy algorithm to
solve the scheduling problem. In order for the algorithm to be efficient, it
is necessary to sort the jobs according to their times first.
Solution 9. Partition around the first element of the array any element
could have been used. The variable p is the index of the element around
which the partition is made pe (declared below) points to the element after
the second partition
/ / jobs.cpp
#include <iostream>

Optimization 343
using namespace std;
struct job { int number, start, end; };
// general definition of ordering R(tl,t2)
// returns > 0 if t2 R tl, <= 0 otherwise
template <class T>
void partition(T *array,int n.int (*R)(T,T),int &p)
{
int i = n-1, pe = 1;
T tempi, temp2;
P = 0;
while(i > 0)
{
if(R(array[p].array[pe] ) > 0)
{
tempi = array[p]; temp2 = array[p+1];
array[p++] = array[pe];// put element in first partition
array[p] = tempi; // move element around which partition
// is made, one element right
if(pe-p > 0) 
// if the second partition is not empty
array[pe] = temp2; // move second partition one
} 
// element right
pe++;
i—;
}
>
template <class T>
void qsort(T *array,int n.int (*R)(T,T))
{
int pelement;
if(n <= 1) return;
partition(array,n,R,pelement);
qsort(array,pelement,R);
qsort(array+pelement+1,n-pelement-l,R);
>
int timeorder(struct job a,struct job b)
{
if(a.start-b.start != 0) return a.start > b.start;
return a.end > b.end;
}

344 Problems and Solutions
void greedy(struct job *j,int n)
{
int k = 0, i = 0, m;
qsort(j,n,timeorder);
m = j[0].start;
while(i<n)
•C
if(j[i]•start>=m)
•C
k++;
m = j [i].end;
cout « j[i] .number « " " « j [i] . start « " " « j[i].end
« endl;
}
i++;
}
}
int main(void)
{
struct job jobs[] = {{ 1, 6, 10 },{ 2, 1, 5 },
{ 3 , 
1, 6 >,{ 4, 9, 12 },
{5, 
5, 7 },{ 6, 6, 14 },
{ 7, 3, 7 >,{ 8, 10, 14 },
{ 9, 13, 16 >};
greedy(jobs,9);
return 0;
}
Problem 10. Find the shortest distance between two coordinates on the
earth's surface using the latitude and longitude. Assume that the earth is
a perfect sphere with radius — 6371.0 km.
Latitude 
Longitude
Example 1:
Egoli: 
26 10 S 28 2 E
Tombouctou: 
16 50 N 3 0 W
Example 2:
Leningrad: 
59 55 N 30 20 E
San Fransico: 37 47 N 122 30 W

Optimization 345
Example 3:
Tecka 
43 30 S 71 0 W
Petropavlosk 
52 50 N 158 50 E
Solution 10. We use spherical coordinates
x{r, a,/3) = r cos(/3) sin(a)
y(r,a,(3) =r cos(/3) cos(a)
where — IT < a < TT and —TT/2 < (3 < TT/2. Thus a describes the longitude
and (3 describes the latitude. Given (ai,/3i) and (a2,/32) we consider the
vectors
Pi = r(cos(/3i) sin(ai),cos(/3i) cos(ai), sin(/3i))
p2 = r(cos(/?2) sin(a2), cos(/?2) cos(a2), sin(/32)).
Let 8 be the angle between pi and p 2. The scalar product provides
Pi-P2 = ||PilH|P2||cos(0)=r2cos(0).
Since cos(0) = (pi • p2)/(r2) we have
cos(6) = cos(/?i) cos(/?2) COS(Q! - a2) + sin(/3i) sin(/?2)
where we used sin(ai) sin(a2) + cos(ai) cos(a2) = cos(o;i — a2). The dis-
tance d is given by d = r#. This leads to the C++ implementation
/ / distance.cpp
#include <iostream>
#include <cmath>
using namespace std;
int main(void)
{
double r = 6371.0; / / radius of the earth
double M_PI = 3.14159;
double alphal, alpha2, betal, beta2, temp, theta, distance;
char dir, source[16], dest[16];
cout << "enter the name of the source: ";
cin » source;
cout << "enter the latitude of " << source << ": \ndegrees:";
cin >> betal;

346 
Problems and Solutions
cout << "minutes: ";
cin >> temp;
betal += temp/60.0;
cout « "N/S: ";
cin » dir;
if(dir == JS' II dir == 's') betal = -betal;
cout « "enter the longitude of " « source « ": \ndegrees:";
cin » alphal;
cout « "minutes: ";
cin >> temp;
alphal += temp/60.0;
cout « "W/E: ";
cin >> dir;
if(dir == 'E' II dir == 'e') alphal = -alphal;
cout << "enter the name of the destination: ";
cin >> dest;
cout « "enter the latitude of " « dest « ": \ndegrees:";
cin » beta2;
cout << "minutes: ";
cin >> temp;
beta2 += temp/60.0;
cout « "N/S: ";
cin >> dir;
if(dir == 'S' II dir == 's') beta2 = -beta2;
cout « "enter the longitude of " « dest « ": \ndegrees:";
cin » alpha2;
cout « "minutes: ";
cin >> temp;
alpha2 += temp/60.0;
cout « "W/E: ";
cin >> dir;
if(dir == 'E' II dir == 'e') alpha2 = -alpha2;
alphal *= M_PI/180.0; alpha2 *= M_PI/180.0;
betal *= M_PI/180.0; beta2 *= M_PI/180.0;
temp = cos(betal)*cos(beta2)*cos(alphal-alpha2)
+ sin(betal)*sin(beta2);
theta = acos(temp);
distance = r*theta;
cout « "The distance between " « source « " and " « dest
« " is " « distance « " km.\n";
return 0;
}

Chapter 18
File and String
Manipulations
Problem 1. 
Intel hex record files are printable files consisting of any
number of Intel hex records. Each record is represented by exactly one line
of the format
:CCAAAARRDD...DZZ
The leading colon indicates that the line is an Intel hex record. The char-
acters following the colon are hexadecimal (base 16) digits, i.e., 0 to 9 and
A to F. The first two digits represented by CC determine the number of data
bytes (represented by two hexadecimal digits each). The next four digits,
AAAA, is an address. The two digits RR indicate the record type:
• 00 for a data record
• 01 for an end of file record
• 02 for an extended segment address record
• 03 for a start segment address record
• 04 for an extended linear address record
• 05 for a start linear address record.
This is followed by the data bytes. Lastly two hexadecimal digits ZZ give
the checksum, which is the two's complement of the sum of all the previous
347

348 Problems and Solutions
bytes (modulo 256).
For example, the record
:020000021000EC
has 2 data bytes, and is a data record, with address 0. The checksum EC
in base 10 is
EC = 14*16+12 = 236
The sum of the preceding bytes 02 00 00 02 10 00 is
2 + 0 + 0 + 2 +16 + 0 = 20
in decimal. In binary 20 is represented as
00010100
The 8 bit one's complement of this bitstring is
11101011
Thus the 8 bit two's complement is
11101100
This gives the result
27 + 26 + 25 + 23 + 22 = 128 + 64 + 32 + 8 + 4 = 236.
Write a program to read an Intel hex record file, which uses the checksum
of each record to determine if the record is correct. Use the program with
the following file
:100000008316FF30850000308600831202300920FD
:0C001000860082074134423443344434FB
:00000001FF
Solution 1. 
The following C++ program checks the validity of the
records. The function getbyteO is used to obtain an integer from a char-
acter stream of hexadecimal numbers. Adding the checksum to the data
bytes yields 0.

File and String Manipulations 349
// intelhex.cpp
#include <iostream>
#include <fstream>
#include <ctype.h>
using namespace std;
char *record_type[] = { "DATA","EOF","EXTENDED SEGMENT",
"START SEGMENT","EXTENDED LINEAR",
"START LINEAR" };
int getbyte(istream& i)
{
int bytehigh = 0, bytelow = 0;
bytehigh = i.getO ;
if(!isxdigit(bytehigh)) { i.unget(); return -1; }
if(!isdigit(bytehigh)) bytehigh=10+toupper(bytehigh)-'A';
else bytehigh -= '0';
bytelow = i.getO;
if (! isxdigit (bytelow)) { i.ungetO; return -1; }
if(!isdigit(bytelow)) bytelow = 10+toupper(bytelow)-'A';
else bytelow -= '0';
return ((bytehigh « 4) + bytelow);
}
int main(int argc.char *argv[])
{
int i, c, extra, valid, line = 0;
int databytes, address, type;
char checksum;
if(argc!=2)
{ cout « "Usage: " « argv[0] « " file"
<< endl; return 1; }
ifstream f(argv[l]);
if(f .failO)
{ cout << "Failed to open " << argv[l]
<< endl; return 1; }
whileUf .eofQ)
{
extra = 0; valid = 0;
if(f.get()==':')
{
cout « "Record on line " « line « " ";
if((databytes=getbyte(f)) >= 0)

350 
Problems and Solutions
if((c=getbyte(f)) >= 0) if(address=c,(c=getbyte(f))>=0)
if((type=getbyte(f)) >= 0)
{
checksum = databytes+address+c+type;
address = (address « 8)+c;
for(i=0;i<=databytes;i++)
if((c=getbyte(f)) >= 0) checksum += c;
else break;
if(i>databytes) valid = 1;
}
if(!valid) cout « "invalid format" « endl;
else
cout « "of type " « record_type[type] « " with "
« databytes « " databytes, "
<< "at address " << address
« " - checksum " « 
((checksum)?"invalid.":"valid.")
<< endl;
} else f .ungetO ;
while(((c=f.get())!='\n') && If.eofO) extra += lisspace(c);
if(extra)
cout « "Ignoring data on line " << line
<< " which is not part of a record." << endl;
line++;
>
return 0;
}
For the example input file, the output is
Record on line 0 of type DATA with 16 databytes,
at address 0 - checksum valid.
Record on line 1 of type DATA with 12 databytes,
at address 16 - checksum valid.
Record on line 2 of type EOF with 0 databytes, at
address 0 - checksum valid.
Problem 2. The LZW-algorithm is a general purpose compression scheme
developed by Lempel-Ziv and Welch. The algorithm uses a table of 4096
entries to store frequently used patterns of information. Initially, the first
256 entries are set to the values a single byte can take on (i.e., each entry
i has the value i for i = 0,1,..., 255). Each of the first 512 entries of the
table are represented using 9 bits. When the table is filled up to exceed
512 entries, then 10 bits are used for each index. Similarly 11 and 12
bits are used for each index when the table exceeds 1024 and 2048 entries

File and String Manipulations 351
respectively. The first 258 table entries are fixed. The entry 256 indicates
a clear code which indicates all entries above 257 should be cleared. The
entry 257 indicates end of information, i.e., the current block of data is
completely encoded. The way the table is filled up is as follows
1. P=""
2. read C (a character)
3. if P+C (string concatenation) is a string in the table
P=P+C
goto 2
4. write the index in the table where P was found
add P+C to the table
p='<"
goto 3
When the table is full (all 4096 entries used) the table must first be cleared
before starting a new table. Thus the index 256 must be written to the
output. Write a program which encodes data using the algorithm. Write a
C++ program which decodes the encoded data.
Solution 2. 
We first write a Bitstream class which allows us to read
or write an arbitrary number of bits to or from a file. We achieve this by
buffering to fill up complete bytes before returning after reading or writing.
// bitstream.h
#ifndef BITSTREAM.HEADER
#define BITSTREAM.HEADER
#include <iostream>
using namespace std;
const int BUFFERSIZE=1024;
class OBitStream
{
private:
unsigned char b[BUFFERSIZE] ;
unsigned int p, q;
ostream& stream;
public:
OBitStream(ostream &o): stream(o) { p=q=0; b[0]=0; }

352 
Problems and Solutions
void write(unsigned char* bits,unsigned int number);
void flush(void);
"OBitStreamO
{ if(q) p++; stream.write((char*)b,p*sizeof(unsigned char));
};
// assume that any unused bits in the array bits
// are set to zero
void QBitStream: -.write(unsigned char* bits,unsigned int number)
{
int j = (8*sizeof(unsigned char));
int m = number/j ; int n = number'/, j ;
for(int i=0;i<m;i++)
{
b[p] 1= (bits[i]«q);
b[++p] = (bits [i]» (j-q));
if(p>=BUFFERSIZE-2) flushO;
}
if(n)
{
b[p] |= (bitsQn] « q);
if(n >= j-q) b[++p] = (bits[m] » 
(j-q));
if(p >= BUFFERSIZE-2) f lushO ;
q = (q+n)'/.j;
}
}
void OBitStream::flush(void)
{
if(p > 0) stream.write((char*)b,p*sizeof(unsigned char));
b[0] = b[p]; p = 0;
}
class IBitStream
-C
private:
unsigned char b;
unsigned int q;
static unsigned int masks[];
istreamfe stream;
public:
IBitStream(istream &i): stream(i) { q=0; b=0;>
void read(unsigned char* bits,unsigned int number);
int eof(void) { return stream.eof(); }

File and String Manipulations 353
"IBitStreamO { }
};
unsigned int IBitStream::masks[] = { 0,1,3,7,15,31,63,
127,255,511,1023,2047 };
// bits is an array of size at least number/(sizeof(char)) + 1
void IBitStream::read(unsigned char* bits,unsigned int number)
{
int j = (8*sizeof(unsigned char));
int m = number/j; int n = number'/.j;
bits[0] = b;
memset(bits+1,0,m);
stream.read((char*)(bits+1),m*sizeof(unsigned char));
for(int i=0;i<m;i++)
i
bits[i] |= (bits[i+l]«q); bits[i+l] »= (j-q) ;
}
if(n<=q) { b=bits[m]; bits[m] &= masks[n]; q-=n; b>>=n; }
else
•C
b = 0 ;
strearn.read((char*)&b,sizeof(unsigned char));
bits[m] |= (b«q) ; bits[m] &= masks [n] ;
b »= n-q; q = j-(n-q);
}
}
#endif
Now we can write a class to write data compressed from a buffer and un-
compress data from a file into a buffer. These classes can be applied for
any binary data, including ASCII data.
/ / lzw.h
#ifndef LZWHEADER
#define LZWHEADER
#include <cstring>
#include <limits>
#include "bitstream.h"
const int MAXLEN=1024;

354 Problems and Solutions
unsigned char *uint_to_bytes(unsigned int u)
{
static const int n=sizeof(unsigned int);
static const int m=numeric_limits<unsigned char>::max()+l;
static unsigned char b[n];
for(int i=0;i<n;i++,u/=m) b[i]=u%m;
return b;
}
unsigned int bytes_to_uint(unsigned char *b)
-C
static const int n=sizeof(unsigned int);
static const int m=numeric_limits<unsigned char>::max()+l;
unsigned int u=0;
for(int i=n-l;i>=0;i—) u = u*m+b[i];
return u;
}
class LZWOStream
-C
private:
OBitStream *bs;
unsigned char *table[4096];
int lengths[4096];
unsigned int size, bits, bestmatch;
int p;
unsigned char P[MAXLEN];
public:
LZWOStream(ostream& s);
void write(unsigned char*,unsigned int);
"LZWOStreamO ;
};
LZWOStream::LZWOStream(ostream& s)
{
int i;
bs = new OBitStream(s);
for(i=0;i<256;i++)
{ table[i]=new unsigned char[l]; table[i][0]=i; lengths[i]=l;>
lengths[i++] = 0; lengths[i++] = 0;
size = 258; bits = 9 ; p = 0;
}
void LZWOStream::write(unsigned char *b,unsigned int n)

File and String Manipulations 355
{
int j ;
if((n>O)&&(p==O)) { P[p++]=*(b++); n—; }
while(n)
•C
for(j=0;j<size;j++)
if(lengths[j]==p && memcmp(P,table[j],p)==0) break;
if(j!=size) { bestmatch=j; P[p++]=*(b++); n—; }
else
{
bs -> write(uint_to_bytes(bestmatch),bits);
if(size==4096)
{
j = 256;
bs -> write(uint_to_bytes(j),bits);
for(j=258;j<size;j++) { delete[] table[j]; lengths[j]=O; }
size = 258; bits = 9;
P[0] = P[p-1]; p = 1;
}
else
•C
table[size] = new unsigned char[p];
lengths[size]=p;
memcpy(table[size++],P,p);
P[0] = PCp-1]; p = 1;
if(size>512) bits = 10; if(size>1024) bits = 11;
if(size>2048) bits = 12;
}
}
>
}
LZWOStream::"LZWOStreamO
{
if(p>0) {
bs -> write(uint_to_bytes(bestmatch),bits);
p -= lengths[bestmatch] ;
>
for(int j=0;j<size;j++) delete[] table[j];
bestmatch = 257;
bs -> write(uint_to_bytes(bestmatch),bits);
delete bs;
}

356 
Problems and Solutions
class LZWIStream
{
private:
IBitStream* bs;
unsigned char *table[4096];
int lengths[4096];
unsigned int size, bits;
int iseof;
public:
LZWIStream(istream &s);
int read(unsigned char*,unsigned int);
int eof() ;
"LZWIStreamO ;
};
int LZWIStream::eof() { return iseof; }
LZWIStream::LZWIStream(istreamfc s)
{
int i;
bs = new IBitStream(s);
for(i=0;i<256;i++)
{ table[i]=new unsigned char[l]; table[i][0]=i; lengths[i]=l;>
lengths[i++] = 0; lengths[i++] = 0;
size = 258; bits = 9; iseof = 0;
}
int LZWIStream::read(unsigned char* b,unsigned int n)
{
int j, i = 0;
unsigned char index_bytes[sizeof(unsigned int)];
unsigned int index = 0;
if(n>MAXLEN) n-=MAXLEN;
while((n>i) && !bs->eof() && liseof)
i
memset(index_bytes,0,sizeof(unsigned int));
bs -> read(index_bytes,bits);
index = bytes_to_uint(index_bytes);
if(bs->eof()) { iseof=1; break; }
if(index==256)
{
for(j=258;j<size;j++) { delete[] table[j]; lengths[j]=0; >
size=258; bits=9;
}

File and String Manipulations 357
else if(index == 257) { iseof=l; return i; }
else if(index >= size) return -1;
else
{
if(size > 258)
{
unsigned char *entry=new unsigned char[lengths[size-l]+l];
memcpy(entry,table[size-l].lengths[size-1]);
entry[lengths[size-l]++]=table[index][0];
delete[] table[size-1]; table[size-l]=entry;
}
if(size < 4096)
{
table[size] = new unsigned char[lengths[index] ];
memcpy(table[size].table[index],lengths[index]);
lengths[size++]=lengths[index];
}
memcpy(b+i,table[index],lengths[index]);
i += lengths[index];
if(size>512) bits = 10; if(size>1024) bits = 11;
if(size>2048) bits = 12;
>
}
return i;
>
LZWIStream: : "LZWIStreamO
{
delete bs;
for(int j=O;j<size;j++) delete[] table[j];
}
#endif
Finally we use the classes in programs to compress and decompress files.
/ / compress.cpp
#include <fstream>
#include "lzw.h"
using namespace std;
int main(int argc.char *argv[])
•c
if(argc!=3)

358 
Problems and Solutions
i
cout « "Use:" « argv[O] « " filename compressed_filename"
« endl;
return 1;
}
ofstream out(axgv[2],ios::binary);
ifstream in(argv[l],ios::binary);
LZWOStream lzw(out);
unsigned char b[4096];
while(!in.fail() && lin.eofO)
{
int n=0;
while(lin.eofO && n<4096) in.read((char*)b+(n++),1);
if(n>0) lzw.write(b,n);
>
return 0;
}
// decompress.cpp
#include <fstream>
#include "lzw.h"
using namespace std;
int main(int argc.char *argv[])
{
if(argc!=3)
{
cout « "Use:" « argv[0] « " compressed_filename filename"
« endl;
return 1;
}
ofstream out(argv[2],ios::binary);
ifstream in(argv[l],ios::binary);
LZWIStream lzw(in);
unsigned char b[4096];
while (llzw.eofO)
{
int n = lzw.read(b,4096);
if(n>0) out.write((char*)b,n);
}
return 0;
>

File and String Manipulations 
359
Problem 3. The major problem with the brute-force search of a string
in a text is that characters in the text may be re-examined multiple times
and this can lead to poor performance in some cases. The algorithm of
Knuth, Morris and Pratt provides a way to alleviate the repeated accesses
to the text and, as a result, it gives us a guaranteed linear time searching
algorithm. The key aspect of the Knuth-Morris-Pratt algorithm is that a
failed attempt to find a match yields useful information to be used on the
next attempt. Specifically, if a mismatch is detected when considering the
characters pat [j] and text [k], we do not need to start the next attempt
at text[k-j+l] as we know the characters
text[k-j], text[k-j+l], . . . . text[k-l]
are identical to the prefix of the pattern,
pat[0], pat[l], ... , pat[j-l] 
.
Thus, we can access the text characters sequentially and alleviate the need
to back-up the text. The KMP algorithm is essentially the brute-force algo-
rithm with a more intelligent re-initialization of pointers when a mismatch
is detected. Write a C++ program for the KMP-algorithm.
Solution 3.
/ / kmp.cpp
#include <iostream>
#include <fstream>
#include <string>
using namespace std;
int prefix(int from,int to.string word)
{
for(int i=0;from<=to;i++,from++)
{ if(word[from] != word[i]) return 0; }
return 1;
}
void initnext(string word,int*& next)
{
int wordlength = word.lengthQ;
next = new int[wordlength];
for(int i=0; i<wordlength;i++)
{
if(word[i] == word[0]) { next[i] = 0; }
else

360 
Problems and Solutions
i
int found = 0;
for(int j=O;(j<i && !(found));j++)
{
if(prefix(j,(i-l),word) 
&& word[(i-j)] !=word[i])
{
next[i] = (i-j)+l;
found = 1;
} / / if
} / / for
if ('.(found)) next[i] = 1;
} / / ifelse
} / / for
} / / initnext
int search(string word,ifstreamfe text,int& pos,int begin=l)
•C
int* next;
int j , k, wordlength;
char ch;
wordlength = word.lengthO;
initnext(word.next);
text.seekg((begin-l),ios::beg);
text.get(ch);
for(j=0;Itext.eof();)
{
if(wordlength == j)
{
int temp = text .tellgO ;
pos = temp - wordlength;
return 1;
} // if
if(ch == word[j]) { text.get(ch); j++; }
else
{
if(next[j] == 0) { j = 0; text.get(ch); >
else { j = (next[j]-l); } // ifelse
> // ifelse
} // for
return 0;
} // search
int main(int argc.char* argv[])
{

File and String Manipulations 361
int pos;
if(argc != 3)
{
cout « "usage: kmp <string> <file_name> \n";
exit(l);
}
ifstream file(argv[2],ios::in);
if(search(argv[l],file,pos))
-C
cout « "\nThe string \"" « argv[l]
<< "\" occurs the first time at position "
« pos « "\n\n";
>
else
{
cout « "\nThe string V " « argv[l]
« "\" does not occur in " « argv[2] « "\n\n";
}
return 0;
>
Another implementation of the KMP search is
/ / kmpl.cpp
#include <iostream>
using namespace std;
int kmp(char* needle,char* haystack)
{
/ / support a maximum of 256 character needles
int skiplist[256];
int i, j , n, m, skip;
skiplist[0] = 0; skiplist[1] = 1;
for(m=2;m<=strlen(needle);m++) {
for(i=m-l;i>0;i—) {
for(j=0;j<i;j++) {
if(needle[j]!=needle[m-i+j]) break;
>
if(j==i) { break; >
>
skiplist[m] = m-i;
>
m = strlen(needle); n = strlen(haystack);
i = 0; j = 0;

362 
Problems and Solutions
while(i<=n-m) {
while(j<m) {
if(haystack[i+j] != needle[j]) {
if(j==O) {
i++;
if(i>n-m) return -1;
} else {
skip = skiplist[j];
i += skip; j -= skip;
}
} else { j++; }
}
return i;
}
return -1;
}
int main(void)
{
char* needle = "ring";
char* haystack = "Look for a substring";
int location = kmp(needle,haystack);
cout « "Found " « endl « needle « endl « " in " « endl
« haystack « endl « " at position "
« location « endl;
return 0;
}
Problem 4. A common task in string manipulation is to search a string
(or file) for the occurrences of a particular substring (or piece of text).
What is needed is a function which could take a string such as
Isn't it funny how bees fly
and a substring such as funny and tell us that the substring occurs in the
string at character position 9. The first character position is numbered zero.
The straightforward approach is to scan the string for an f and when one
is found the characters after the f are checked to see whether they match.
However, this is not the best option. It involves checking every character
of the string, which can be very slow. A better approach is given by the
Boyer-Moore algorithm. In their method a table is built from the substring
indicating the position of the last occurrence of each character within it.
For the string funny this would hold the information that

File and String Manipulations 
363
f at 0, u at 1, n at 3, y at 4.
The algorithm then involves searching in the string for the last character of
the substring as follows: the substring contains five characters, numbered
zero to four. Obviously, we must not check the string before character
number 4, which is a t. The table is checked and reveals that there is no
blank in the substring and therefore we can skip five characters to the f.
This is in the table and is at position zero in the substring. Thus, four
characters can be skipped to the y. This is the character being searched for
and so a comparison is made at this point between the whole substring and
the appropriate part of the string. This operation finds a match. Write a
C++ program that implements this algorithm.
Solution 4.
// boyer.cpp
#include <iostream>
#include <fstream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <climits>
using namespace std;
const int charsetsize = 128;
int substringposition(char *str,int strleng,char *substr,
int substrleng,int contentlist[])
{
int result, index, position, firstchar;
result = -1;
char finalchar, currentchar;
finalchar = substr[substrleng-1];
char *stringptr, *substrptr;
if(strleng >= substrleng)
{
if(substrleng == 1)
{
for(index = 0;index < strleng && result == -l;++index)
if(finalchar == str[index])
result = index;
}
else
{

364 Problems and Solutions
index = substrleng-1;
do
{
if((position = contentlist[currentchar = str[index]])==-l)
index += substrleng;
else
if(currentchar == finalchar)
i
firstchar = index - substrleng + 1;
if(strncmp(&str[firstchar].substr,substrleng) == 0)
result = firstchar;
if(result == -1) ++index;
}
else index += (substrleng - position - 1);
>
while(index < strleng && result == -1);
}
}
return result;
}
void makecontentlist(char *substr,int contentlist[])
{
for(int i=0;i<= charsetsize-l;++i)
contentlist [i] = -1;
for(int j=0;*substr != '\0';++j,++substr)
contentlist[*substr] = j;
>
int main(void)
{
const int lineleng = 132;
const int nameleng = 12;
int line = 1;
int searchstringleng;
int contentlist[charsetsize] ;
char currentline[lineleng], filename[nameleng],
searchstring[lineleng] ;
cout « "enter name of file to be searched: ";
cin » filename;
FILE* InStream = fopen(filename,"r");
if(!InStream)
{
cout << " *** Error *** : cannot open " << filename << endl;

File and String Manipulations 
365
exit(l);
>
cout << "enter the substring to be searched: ";
cin » searchstring; // gets(searchstring);
makecontentlist(searchstring,contentlist);
searchstringleng = strlen(searchstring);
while(fgets(currentline,lineleng,InStream) != NULL)
-C
if(substringposition(currentline,strlen(currentline),
searchstring,searchstringleng,contentlist) != -1)
printf ("line: '/,d text: */.s" ,line,currentline);
++line;
>
return 0;
}
Problem 5. If two streams are opened, one as a binary stream and the
other as a text stream, and the same information hello world\n is written
to both, the contents of the stream may differ. The C++ code shows two
streams of different types and the hexadecimal values of the resulting files.
Discuss why the data is stored differently for each file.
// textbinary.cpp
#include <iostream>
#include <iomanip>
#include <fstream>
using namespace std;
int main(void)
{
char lineBin[15], lineTxt[15];
ofstream ofilel("script.bin", ios::out Iios::binary);
ofilel « "hello world\n";
ofilel.close();
ofstream ofile2("script.txt");
ofile2 « "hello world\n";
ofile2.close();
ifstream ifilel("script.bin",ios::in|ios::binary);
// opening the text file as binary to supress
// the conversion of internal data
ifstream ifile2("script.txt",ios::in Iios::binary);
ifilel.getline(lineBin,15); ifile2.getline(lineTxt,15);
ifilel.close(); ifile2.close();

366 
Problems and Solutions
cout « setbase(16);
cout « "Hex value of binary file = ";
for(int i=O;lineBin[i];i++)
cout « setw(2) « setfill('O') « (int)lineBin[i];
cout«endl;
cout « "Hex value of text file = ";
for(int j=O;lineTxt[j];j++)
cout « setw(2) « setfill('O') « (int)lineTxt [j] ;
cout « endl;
return 0;
}
Solution 5. 
First we note that the function getlineO discards the
new-line character (line-feed) \0a. Under Windows the output is
Hex value of binary file = 68656c6c6f20776f726c64
Hex value of text file 
= 68656c6c6f20776f726c640d
In the text stream script .txt, we have a carriage-return character \0d at
the end of the file. Under Linux we find that the binary file and text file
are the same, namely
68656c6c6f20776f726c64
Problem 6. The DNA molecule is a two stranded molecule. Each strand
is a polynucleotide composed of A (adenosine), T (thymidine), C (cytidine)
and G (guanosine) residues polymerized by dehydration synthesis in linear
chains with specific sequences. Each strand has polarity, such that the 5'-
hydoxyl (or 5'-phospho) group of the first nucleotide begins the strand and
the 3'-hydroxyl group of the final nucleotide ends the strand accordingly.
We say that this strand runs 5' to 3'. The two strands of DNA run antipar-
allel such that one strand runs 5' -> 3' while the other runs 3' -> 5'.
At each nucleotide residue along the double-stranded DNA molecule, the
nucleotide are complementary. That is, A froms two hydrogen-bonds with
T; C forms three hydrogen bonds with G. One strand of DNA holds the
information that codes for various genes. This strand is called the template
strand or antisense strand (containing anticodons). The other, and com-
plementary, strand is called the coding strand or sense strand (containing
codons). Since mRNA is made from the template strand, it has the same
information as the coding strand. Each group of three consecutive nu-
cleotides is called a codon. Each triplet (codon) encodes exactly one amino
acid or serves as an indicator for starting (methionine MET) and stopping
the synthesis. The mapping of codons to amino acids is called the genetic
code and is often presented in the following two-dimensional form.

File and String Manipulations 367
T 
C 
A 
G
phenylalanine 
serine 
tyrosine 
cysteine 
T
phenylalanine 
serine 
tyrosine 
cysteine 
C
T leucine 
serine 
period 
period 
A
leucine 
serine 
period 
tryptophan G
leucine 
proline 
histidine 
arginine 
T
leucine 
proline 
histidine 
arginine 
C
C leucine 
proline 
glutamine 
arginine 
A
leucine 
proline 
glutamine 
arginine 
G
isoleucine 
threonine 
asparagine 
serine 
T
isoleucine 
threonine 
asparagine 
serine 
C
A isoleucine 
threonine 
lysine 
arginine 
A
methionine 
threonine 
lysine 
arginine 
G
valine 
alanine 
aspartic acid 
glycine 
T
valine 
alanine 
aspartic acid 
glycine 
C
G valine 
alanine 
glutamic acid 
glycine 
A
valine 
alanine 
glutamic acid 
glycine 
G
For example, TCG is the codon for serine, CAA is the codon for glutamine
and GTC is the codon for valine. The codons TAA, TAG and TGA do not code
for an amino acid but serve as halt instructions. The table lists period
for those codons instead of the name for an amino acid. The genetic code
is more naturally presented in three-dimensional form. An example of two
complementary strands of DNA would be
(5' -> 3') ATGGAATTCTCGCTA (coding, sense strand)
(3> -> 5') TACCTTAAGAGCGAG (template, antisense strand)
(5' -> 3') AUGGAAUUCUCGCUC (mRNA made from template strand).
The code for the mRNA would be identical to the sense strand but the
mRNA contains U (uridine) rather than T. Use the class TreeMap of Java
and the methods
Object put(Object key.Object value)
Object get(Object key)
to implement this map. Thus, for example the reference get ("GTC") should
fetch valine. Test the program by reading DNA sequences and then listing

368 
Problems and Solutions
the sequence of amino acids that they encode. Stop encoding when we come
to a codon that codes for period.
Solution 6. We introduce the following abbreviation for the amino acids:
Alanine (ala), Arginine (arg), Asparagine (asn), Aspartic acid (asp), Cys-
teine (cys), Glutamine (gin), Glutamic acid (glu), Glycine (gly), Histidine
(his), Isoleucine (ile), Leucine (leu), Lysine (lys), Methionine (met), Pheny-
lalanine (phe), Proline (pro), Serine (ser), Threonine (thr), Tryptophan
(trp), Tyrosine (tyr), Valine (val).
The Java program is as follows.
/ / GCode.java
import java.util.*;
import java.io.*;
public class GCode
{
public static void main(String[] args)
•C
// codon (key)
String[] c = new String [64];
c[0] = new String("AAA"); c[l] = new StringC'AAC");
c[2] = new StringC'AAG"); c[3] = new String("AAT");
c[4] = new String("ACA"); c[5] = new StringC'ACC");
c[6] = new StringC'ACG"); c[7] = new String("ACT");
c[8] = new String("AGA"); c[9] = new String("AGC");
c[10] = new String("AGG"); c[ll] = new StringO'AGT");
c[12] = new String("ATA"); c[13] = new String("ATC");
c[14] = new String("ATG"); c[15] = new String("ATT");
c[16] = new String("CAA"); c[17] = new StringC'CAC");
c[18] = new StringC'CAG"); c[19] = new String("CAT");
c[20] = new String("CCA"); c[21] = new StringC'CCC");
c[22] = new String("CCG"); c[23] = new String("CCT");
c[24] = new StringC'CGA"); c [25] = new StringC'CGC") ;
c[26] = new String("CGG"); c [27] = new StringC'CGT");
c[28] = new String("CTA"); c [29] = new StringC'CTC");
c[30] = new StringC'CTG"); c[31] = new StringC'CTT");
c[32] = new StringC'GAA"); c[33] = new StringC'GAC");
c[34] = new StringC'GAG") ; c[35] = new StringC'GAT");
c[36] = new String("GCA"); c[37] = new StringC'GCC");
c[38] = new StringC'GCG") ; c [39] = new StringC'GCT");

File and String Manipulations 
369
c[40] = new StringC'GGA"); c[41] = new StringC'GGC") ;
c[42] = new StringC'GGG"); c[43] = new StringO'GGT");
c[44] = new String("GTA"); c [45] = new StringC'GTC");
c[46] = new StringC'GTG"); c[47] = new String("GTT");
c[48] = new StringO'TAA"); c[49] = new String("TAC");
c[50] = new String("TAG"); c[51] = new StringO'TAT");
c[52] = new StringC'TCA"); c[53] = new String("TCC");
c[54] = new String("TCG"); c [55] = new String("TCT");
c[56] = new String("TGA"); c[57] = new String("TGC");
c[58] = new StringC'TGG"); c[59] = new String("TGT");
c[60] = new StringC'TTA") ; c[61] = new String("TTC");
c[62] = new String("TTG"); c[63] = new StringO'TTT");
/ / amino acid (value)
String [] a = new String [64];
a[0] = new StringO'lys") ; a[l] = new StringC'asn") ;
a[2] = new StringO'lys") ; 
a[3] = new StringC'asn");
a[4] = new StringC'thr") ; 
a[5] = new StringC'thr") ;
a[6] = new StringC'thr"); 
a[7] = new StringC'thr");
a[8] = new StringC'arg"); 
a[9] = new StringC'ser") ;
a[10] = new StringC'arg"); 
a[ll] = new StringC'ser");
a[12] = new StringC'ile") ; a[13] = new StringC'ile");
a[14] = new String("met"); 
a[15] = new StringC'ile");
a[16] = new String("gin"); 
a[17] = new StringC'his");
a[18] = new String("gin"); 
a[19] = new StringC'his");
a[20] = new StringC'pro") ; a[21] = new StringC'pro") ;
a[22] = new StringC'pro"); 
a[23] = new StringC'pro");
a[24] = new StringC'arg"); 
a[25] = new StringC'arg");
a[26] = new StringC'arg"); 
a[27] = new StringC'arg");
a[28] = new String("leu"); 
a[29] = new StringC'leu");
a[30] = new StringC'leu"); 
a[31] = new StringC'leu");
a[32] = new String("glu"); 
a[33] = new String("asp");
a[34] = new StringC'glu") ; a[35] = new StringC'asp");
a[36] = new StringC'ala"); 
a[37] = new String("ala");
a[38] = new StringC'ala"); 
a[39] = new StringC'ala");
a[40] = new StringC'gly") ; a[41] = new StringC'gly") ;
a[42] = new StringC'gly"); 
a[43] = new StringC'gly");
a[44] = new StringC'val") ; a[45] = new StringC'val") ;
a[46] = new StringC'val"); 
a[47] = new StringC'val") ;
a[48] = new StringC'."); 
a[49] = new StringC'tyr") ;
a[50] = new StringC'."); 
a[51] = new StringC'tyr");
a[52] = new StringC'ser"); 
a[53] = new StringC'ser");
a[54] = new StringC'ser"); 
a[55] = new StringC'ser");
a[56] = new StringC'."); 
a[57] = new String("cys");

370 
Problems and Solutions
a[58] = new String("trp"); 
a[59] = new StringC'cys");
a[60] = new String("leu"); 
a[61] = new StringO'phe");
a[62] = new String("leu"); 
a[63] = new String("phe");
TreeMap map = new TreeMapO ;
for(int i=0;i < 64;i++) { map.put(c[i],a[i]); }
File f = new File("DNA.txt");
long leng = f.lengthO;
System.out.printlnC'leng = " + leng);
int i = 0;
try
{
DatalnputStream in = new DataInputStream(
new BufferedInputStream(
new FilelnputStreamC'DNA.txt")));
while(i < leng)
{
char cl = (char) in.readByteO ;
char c2 = (char) in.readByteO;
char c3 = (char) in.readByteO;
char dataO = { cl, c2, c3 };
String dat = new String(data);
Object obi = map.get(dat);
String si = obi. toStringO ;
System.out.println(dat + " -> " + si);
if(sl.equals("."))
{ System.out.printlnC'synthesis stopped"); System.exit(0); }
i += 3;
} / / end while
in.closeO ;
} / / end try block
catch(IOException e)
{
System.err.println("IOException");
}
}
}
An input file could be ATGGAATTCTCGCTCTAGGTC.
Problem 7. 
Use the standard template library vector class and the
sortO function in class algorithm to write a C++ program that reads a
sequence of strings from an input file and writes them to an output file in
sorted order, one per line.

File and String Manipulations 
371
Solution 7. 
The sortO function in class algorithm of the standard
template library takes two iterators as arguments, one indicating the be-
ginning of the data and the second refers to the position after the end of
the data. The data between these iterators will be sorted provided the
comparision operator < is denned.
// sorting.cpp
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <algorithm>
using namespace std;
int main(void)
{
string name, next;
ifstream input;
ofstream output;
cout « "input file name? "; cin » name;
input.open(name.c_str());
cout « "output file name? "; cin » name;
output.open(name.c_str());
vector<string> values;
while(input » next) values.push_back(next);
vector<string>::iterator i = values.beginO;
while(i != values .endO) { cout << *i << endl; i++; }
sort(values.beginO,values.end());
for(int j=O;j < values.sizeO;j++)
output << values[j] « endl;
return 0;
}
Problem 8. 
The Baeza-Yates-Gonnet algorithm (BYG algorithm) for
searching for a pattern in a string runs 40-50 percent faster than KMP.
The technique works as follows:
• Build a table of bitmasks for each letter of the alphabet, the mask
has the length of the search pattern. Each bit is 1 (if that letter is
not in that position) or 0 (if that letter is in that position).
• Create a working bitmask, initialized to all l's.

372 Problems and Solutions
• For each letter in the search string, shift the working mask 1 bit to
the left, and perform the logical or with the bitmask for the letter in
that position of the string.
• Let the length of the search pattern be i. If the bit in position x of
the working bitmask is 0, then the string matches.
• If we reach the end of the string without finding a match, then there
is no match.
Write a C++ program to match strings using the BYG algorithm.
Solution 8. We are using the bitset class.
/ / byg.cpp
#include <iostream>
#include <string>
#include <bitset>
using namespace std;
/ / bitmasks for the 256 ascii characters
const int MASKSIZE = 32;
bitset<MASKSIZE> masks[256];
string pattern;
void prepare_masks(string s)
{
for(int i=0;i<256;i++) {
masks[i].reset();
for(int j=0;j<s.length();j++) {
if(((unsigned char)s[j])==i) masks[i].set(j);
}
/ / invert the mask
masks[i].flip();
}
pattern = s;
}
int match(string s)
{
int i = 0;
while(i<s.length()) {
bitset<MASKSIZE> work;
work.flip 0;

File and String Manipulations 373
while(i<s.length()) {
work «= 1;
work I=masks[(unsigned char)s[i]];
if(!(work.test(pattern.length()-l)))
{ return i+1-pattern.length(); }
i++;
}
>
return -1;
}
int main(void)
{
string needle, haystack;
int pos;
cout « "Enter string to search in: ";
getline(cin,haystack);
cout << "Enter search string: "; cin » needle;
prepare_masks(needle);
if((pos=match(haystack))>0)
{
cout « "Match found at " « pos « " starting at 0" « endl;
>
else { cout « "No match." « endl; }
return 0;
>
Problem 9. Write a C++ program to evaluate arithmetic expressions.
The program will have to decompose a string into a sequence of tokens,
where each token represents an operator, function or value. The sequence of
tokens are evaluated using the standard precedence rules for arithmetic, i.e.,
first parenthesis, functions, multiplication, division, modulus, and finally
addition and subtraction.
Solution 9. The function get_tokens() separates a string into tokens
according to separator (an array of symbols used to separate tokens and
are tokens themselves) and ignore (an array of symbols used to separate
tokens but are discarded). The function evaluate_tokens() evaluates the
list of tokens in the order assignment, parenthesis, functions and finally
standard arithmetic operators according to precedence.
// eval.cpp

374 Problems and Solutions
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <map>
#include <cstdlib>
#include <cmath>
using namespace std;
double error(string s)
{ cerr « "Error: " « s « ", using 0." « endl; return 0.0; }
class token
{
private:
int is_value;
double v;
string t;
static map<string,double> values;
public:
tokenO : is_value(0), v(0.0), t("") {};
token(double d) : is_value(l), v(d), 
t("") {};
token(string s) : is_value(0), v(0.0), t(s) {};
double value();
string name() { return t; }
int isvalueO { return is_value; >
double set(double d) { return values[t]=d; }
int operator==(string s) { return (!is_value) && (t == s); }
friend ostreamfe operator « (ostreamfe,token);
>;
map<string,double> token::values;
double token::value()
{
if(is_value) return v;
char *end; double val=strtod(t.c_str(),&end);
if(*end == '\0') return val;
if(values.count(t)>0) return values[t];
return error(t+" has no value assigned");
}
ostreamfe operator « (ostreamfe o,token t)
{ if(t.is_value) o << t.v; else o << t.t; return o;}

File and String Manipulations 375
vector<token>
get_tokens(string s,string separator[],string ignore[])
{
int i = 0, j, istoken = 0;
vector<token> v;
string value = "";
while(i<s.length())
{
istoken = 0;
for(j=0; ignore [j] != "" && i<s .lengthO ; j++)
if (s.substrd, ignore [j] .lengthO) == ignore [j])
i += ignore [j] .lengthO , j = - 1 , istoken = 1;
for(j=0;separator[j] != "" && listoken;j++)
if (s.substrd, separator [j] .lengthO) == separator [j])
{
if(value != "") { v.push_back(token(value)); value = ""; }
v.push_back(token(separator[j ]));
i += separator [j] .lengthO ;
istoken = 1;
>
if(listoken) value += s[i++];
else if(value!="") { v.push_back(token(value)); value = ""; }
}
if(value != "") v.push_back(token(value));
return v;
>
double fpow(double x,double y) { return pow(x.y); }
double fmul(double x,double y) { return x*y; }
double fdiv(double x,double y) { return x/y; }
double fadd(double x,double y) { return x+y; >
double fsub(double x,double y) { return x-y; }
double evaluate(token t ) ;
double evaluate_tokens(vector<token> v)
{
vector<token> v2, v3;
int parenthesis, i, j, k;
// unary function names and their implementation
string fnames[] = { "cos", "sin", "tan", "exp",
"In", "acos", "asin", "atan", "" };
double (*fimpl[])(double) = { cos, sin, tan, exp,
log, acos, asin, atan };

376 Problems and Solutions
// default left operands for binary operators
double initleft[] = { 1.0, 1.0, 0.0 };
// binary operators and their implementation
string opnames[][4] = { { "~", "" },
S 
N ± It 
II / II 
M V It 
It II 
\
{ "+", " - " , "" } };
double (*opimpl[][3])(double,double) =
{ { fpow }, { fmul, fdiv, fmod }, { fadd, fsub } };
/ / check for the assignment statement
if(v.size()>2 && v[l] == "=") {
for(j=2;j<v.size(); j++) v2.push_back(v[j]);
return v[0].set(evaluate_tokens(v2));
>
/ / evaluate parenthesis first
for(j=0;j<v.size();j++)
{
if(v[j] == ")") return error("unbalanced parenthesis");
else if(v[j] == "(")
{
for(parenthesis=l,j++;parenthesis && j<v. sizeO ; j++)
{
if(v[j] == "(") parenthesis++;
if(v[j] == ")") parenthesis—;
if(parenthesis) v3.push_back(v[j]);
>
if(parenthesis) return error("unbalanced parenthesis");
v2.push_back(token(evaluate_tokens(v3)));
v3.clear(); j — ;
}
else v2.push_back(v[j]);
>
/ / evaluate functions
for(j=0,v.clear 0;j<v2.size();j++)
{
for(i=0;fnames[i]!="";i++)
if(v2[j] == fnames[i])
{
if (j+Kv2.size())
v.push_back(token(fimpl[i](evaluate(v2[++j]))));
else return error(fnames[i]+" without argument");
break;
}
if(fnames[i]=="") 
v.push_back(v2[j]);

File and String Manipulations 377
}
// evaluate operators in order of precedence
for(k=0,v2.clear();k<3;k++,v = v2,v2.clear())
{
token left(initleft[k]);
for(j=0;j<v.size();j++)
{
for(i=0;opnames[k][i]!="";i++)
if(v[j] == opnames[k][i])
{
if(v2.size()) v2.pop_back();
if (j+Kv.size())
v2.push_back(token(opimpl[k][i](evaluate(left),
evaluat e(v[++j]))));
else return error(opnames[k][i]+" without second argument");
break;
}
if(opnames[k][i]=="") v2.push.back(v[j]);
left = v2.back();
}
}
// check that evaluation gave a single numerical result
if(v.size() != 1)
{
for(j=0;j<v.size();j++)
cerr « "token " « j+1 « " : " « v[j] « endl;
return error("could not evaluate expression");
}
return v[0].value();
}
double evaluate(token t)
{ vector<token> v; v.push_back(t); return evaluate_tokens(v); }
double evaluateformula(istream &s)
{
char c;
string expression;
static string ws[] = { " ", "\t", "\n", "\r", "" >;
static string separator[] = { "=", "+", "-", "*", "/",
M "it 
ii / n 
M ^ H 
it it \ .
> 
^ > * » 
J ,
do if((c = s.getO) != ' ; ' && Is.eofO) expression += c;
while (c != ' ; ' && Is.eofO);
if(c != ' ; ' ) return error("formula not terminated");

378 
Problems and Solutions
vector<token> v = get_tokens(expression,separator,ws);
return evaluate_tokens(v);
}
int main(void)
{
while(!cin.eof())
cout << " -> " << evaluateformula(cin) << endl;
return 0;
}
Problem 10. The Thue-Morse sequence can be generated from the sub-
stitution map 0 —> 01, 1 —> 10. Starting from 0 the Thue-Morse sequence
is generated as follows
0 -> 01 -> 0110 -> 01101001 ->•••.
Give a C++ implementation which generates the Thue-Morse sequence.
Solution 10. 
The function thuemorse() generates the Thue-Morse se-
quence by recursively applying the substitution map.
/ / thuemorse.cpp
#include <iostream>
#include <string>
using namespace std;
string thuemorse(int n)
{
if(n==0) return stringC'0");
string tm = thuemorse(n-1);
string tm2;
for(int i=0;i<tm.length();i++)
if(tm[i]=='0') tm2 += "01"; else tm2 += "10";
return tm2;
}
int main(void)
{
for(int i=0;i<7;i++) cout << thuemorse(i) << endl;
return 0;
}

Chapter 19
Computer Graphics
Problem 1. A Lindenmayer system (A,R,s) is defined as follows. Con-
sider a finite set A of characters (the alphabet), a map R : A —> A* and
a non-empty starting word s (initial string, axiom), an element of A*. A*
are the words with characters from A. For each a £ A the pair (a, R(a)) is
called a rule and is written as
a - > bib2 
•••bn
where R(a) = b\b2 • • • bn G A*, a is the left hand side and bxb2 • • • bn the
right hand side of the rule. A Lindenmayer system describes a language L,
a subset of A*. The language is defined as follows:
• s is an element of L.
• Let w be an element of L and let ~ w be the word where each char-
acter a of w has been replaced by R(a). Then ~ w is in L.
From the starting word s = s0, the word Si is created by replacing all
characters by their rule image (the right hand side of the corresponding
rule). From si the word s2 is created, from that S3 and so on. Call Sj the
i-th generation of the starting word s. The interpretation of the words Si
of the language L can be done using a turtle. It visualizes the words of
the language. A turtle is a drawing device which understands a few simple
commands. Given a word of the language L each character of the word is
interpreted as a command for the turtle. The word turns into a picture
with the help of the turtle. A turtle has a position in the plane, a for-
ward direction and a color. It understands the following commands: Move
379

380 Problems and Solutions
Move forward a given number of units and draw a line, move forward a given
number of units without drawing, turn left a given number of degrees, turn
right a given number of degrees and change our color to a given color.
Further, a turtle may remember its current state (position, direction and
color) by pushing it onto a stack and change its state to a former one by
popping it off from the stack. For each character of the alphabet A, one of
these turtle commands may be denned. A character may also correspond
to no command at all, causing the turtle to do nothing. A turtle command
may be one of the identifiers Move, Line, Left, Right, Push or Pop. These
commands cause the turtle to move without drawing, to draw a line, to
turn left or right and to push or pop its current state. A color value must
be a list of three numbers [r,g,b] defining new red-, green- and blue color
values of the turtle. The following default rules for the turtle commands
exist:
"F" = Line = move foreward one unit and draw a line
"f" = Move = move foreward one unit
"+" = Left = change forward direction by a left rotation
of deg degrees
"-" = Right = change forward direction by a right rotation
of deg degrees
"[" = Push = push current state to stack
" ] " = Pop = pop current state from stack
These rules are used if no other rules for the turtle commands are denned.
It is also necessary to specify which generation of the starting word of the
system is to be plotted. Write a Java applet that implements the turtle.
Solution 1. We restrict the stack to one position. We use the the start
F and the rule F -> F [+F] F [-F] F. The angle is 30° = TT/6.
// Lindenmayer.j ava
import j ava.awt.*;
import j ava.applet.*;
public class Lindenmayer extends Applet
•C
Point a, b;
int lengthF = 3 ; 
// step length
double direction;
double rotation =30.0; // rotation in grad
Graphics g;
Graphics2D g2;

Computer Graphics 381
public void initQ
•C
setBackground(new Color(255,255,255));
}
public void paint(Graphics g)
{
g2 = (Graphics2D) g; // Anti-Aliasing
g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
RenderingHints.VALUE_ANTIALIAS_ON);
g2.setColor(new Color(110,170,60)); // Color
a = new Point(115,495); // starting point
direction = -80; 
// starting direction
turtle(g2,"F",6);
}
public void turtle(Graphics g2,String instruc.int depth)
{
if(depth==0) return;
depth -= 1;
Point aMark = new Point(0,0);
double directionMark = 0;
char c;
for(int i=0;i<instruc.length();i++)
{
c = instruc.charAt(i); // step forward
if(c=='F')
{
/ / iteration
turtle(g2,"F[+F]F[-F]F",depth);
/ / draw
if(depth==0)
•C
double rad = 2.0*Math.PI*direction/360.0; // grad -> rad
int p = (int) (lengthF*Math.cos(rad));
int q = (int) (lengthF*Math.sin(rad));
b = new Point(a.x+p,a.y+q);
g2.drawLine(a.x,a.y,b.x,b.y);
a = b; // new starting point
}
}
// rotation left
else if(c=='+') direction += rotation;

382 Problems and Solutions
II rotation right
else if(c=='-') direction -= rotation;
// store position and direction
else if(c=='[') { aMark = a; directionMark = direction; }
else if(c==']') { a = aMark; direction = directionMark; }
>
}
}
Problem 2. Suppose we have a polygon in two dimensions. The polygon
can be represented by a sequence of points
(xo,yo) -> (zi,2/i) -» 
> (zn-i,Z/n-i) -> (xo,yo).
For a polygon it is not allowed that the lines connecting these points in-
tersect. Given a point (x, y) how can we determine if the point is inside
the polygon? A simple way is to draw a straight line from the point (x, y)
outwards in any direction continuing to infinity. If the line intersects the
polygon an odd number of times, the point is inside the polygon. For
example
P
I 
|Q
ic
1B
using a vertical line results in a simple description of an algorithm to de-
termine whether a point is in a polygon. Thus, point A is in P but not in
Q, point B is in P but not in Q and point C is in both P and Q. We could
interpret Q as a "hole" in P in which case we would say C is not in P.

Computer Graphics 383
A bounding box of an edge is the rectangle determined by the endpoints of
the edge.
The algorithm is as follows
1. crossings := 0
2. edge := first edge in polygon
3. A := point to test
4. If both endpoints of edge are left of A goto 9.
5. If both endpoints of edge are right of A goto 9.
6. If both endpoints of edge are below A goto 9.
7. If both endpoints of edge are above A and there is an endpoint on
either side of A, crossings := crossings + 1.
8. If A is contained within the bounding box of edge let (X^,J/L) —*
(XRIVR) '•— edge, where (XI^L) 
is the leftmost point of edge.
{XA,VA) •= A
Vc := VL + — 
~{XA ~ XL)-
XR - xL
If yc > VA then
crossings := crossings + 1.
9. If edges from the polygon remain to be tested edge := next edge of
polygon and goto 4.
10. If crossings is odd the point is in the polygon, otherwise, the point
is outside the polygon.
Write a C++ program which determines whether a given point is in a given
two-dimensional polygon.
Solution 2.
// inpolygon.cpp
#include <iostream>
using namespace std;
bool inside(double* xp,double* yp.int size,double x,double y)
{

384 Problems and Solutions
int j = 0;
bool result = false;
for(int i=0;i<size;i++)
•C
j++;
if(j == size) j = 0;
if (xp[i] < x && xp[j] >= x II xp[j] < x && xp[i] >= x)
{
if (yp[i] + (yp[j]-yp[i])*(x-xp[i])/(xp[j]-xp[i]) < y)
{ result = !result; }
}
} // end for i
return result;
}
int main(void)
{
int size = 4;
double* xp = new double[size];
double* yp = new double[size];
xp[0] = 1.0; xp[l] = -1.0; xp[2] = -1.0; xp[3] = 1.0;
yp[O] = 1.0; yp[l] = 1.0; yp[2] = -1.0; yp[3] = -1.0;
double x = 0.0; double y = 0.0;
bool result = inside(xp.yp,size,x,y);
cout « "result = " « result << endl;
x = -0.8; y = 0.75;
result = inside(xp.yp,size,x,y);
cout « "result = " « result « endl;
x = -1.1; y = 0.8;
result = inside(xp.yp,size,x,y);
cout « "result = " « result « endl;
delete [] xp; delete [] yp;
return 0;
}
Problem 3. 
Around 1890, Peano and Hilbert discovered curves that
converge towards a function mapping the unit interval to the unit square.
The Hilbert curve is constructed as follows. The construction can be denned
recursively. The starting curve is the curve (three line segment generator)
on the left-hand side of figure 19.1. Each curve Hj consists of four half-
sized copies of Hj-i with a different orientation. The Hilbert curve is the
limit of this construction process, i.e., iJoo- Thus, we can implement the
methods A(), B(), CO and DO to draw the four copies for each step in

Computer Graphics 385
the construction of the Hilbert curve using recursion. Lines are drawn to
connect the four copies. For example, the first three steps in constructing
the Hilbert curve are given below. Write a Java program that generates
the first n-steps in the construction of the Hilbert curve.
1—I 
'—' 
on Lru
r n 
^ ^
I 
I 
CJ~LZI c
Figure 19.1: First 3 Steps in the Construction of the Hilbert Curve
Solution 3.
// Hilbert.java
import j ava.awt.*;
import j ava.awt.event.*;
public class Hilbert extends Frame implements ActionListener
{
public Hilbert0
•C
addWindowListener(new WindowAdapterO
{ public void windowClosing(WindowEvent event)
{ System.exit(0); }
» ;
drawButton.addActionListener(this);
setTitleC'Hilbert");
Panel parameterPanel = new PanelO;
parameterPanel.setLayout(new GridLayout(2,1));
Panel nStepsPanel = new PanelO;
nStepsPanel.add(new Label("no of steps = "));
nStepsPanel.add(nStepsField);
Panel buttonPanel = new PanelO;
buttonPanel.add(drawButton);
parameterPanel.add(nStepsPanel);
parameterPanel.add(buttonPanel);

386 Problems and Solutions
addC'North",parameterPanel);
add("Center".curve);
setSize(400,400); setVisible(true);
} // end class Hilbert
public void windowClosing(WindowEvent event)
{ System.exit(0); }
public static void main(String[] args) { new HilbertO; }
public void actionPerformed(ActionEvent action)
{
if(action.getSourceO == drawButton)
curve.setSteps(Integer.parselnt(nStepsField.getText()));
System.out.printIn(Integer.parselnt(nStepsField.getText()));
}
TextField nStepsField = new TextField("5",5);
Button drawButton = new Button("Draw");
HilbertCurve curve = new HilbertCurveO;
}
class HilbertCurve extends Canvas
{
private int x, y, h, n, len;
public HilbertCurveO { n = 5; }
public void A() { if(n > 0)
{
Graphics g = getGraphicsO; n—;
D O ; g.drawLine(x,y,x-h,y); x-=h;
A(); g.drawLine(x,y,x,y-h); y-=h;
A(); g.drawLine(x,y,x+h,y); x+=h;
B(); n++; }
>
public void B O { if (n > 0)
{
Graphics g = getGraphicsO; n—;
C O ; g.drawLine(x,y,x,y+h); y+=h;
B(); g.drawLine(x,y,x+h,y); x+=h;
B(); g.drawLine(x,y,x,y-h); y-=h;
A O ; n++; }
}

Computer Graphics 387
public void C() { if(n > 0)
•C
Graphics g = getGraphicsO; n—;
B(); g.drawLine(x,y,x+h,y); x+=h;
C(); g.drawLine(x,y,x,y+h); y+=h;
CO; g.drawLine(x,y,x-h,y); x-=h;
DO; n++; }
}
public void DO { if (n > 0)
{
Graphics g = getGraphicsO; n — ;
A(); g.drawLine(x,y,x,y-h); y-=h;
D O ; g.drawLine(x,y,x-h,y); x-=h;
D O ; g.drawLine(x,y,x,y+h); y+=h;
C O ; n++; >
} // end void D O
public void paint(Graphics g)
{
Dimension size = getSizeO;
h = 4*Math.min(size.width,size.height)/5;
x = size.width/2 + h/2; y = size.height/2 + h/2;
for(int i=len=l;i<n;i++) len = 2*len+l;
h/=len; A();
}
public void setSteps(int nSteps) { n = nSteps; repaint(); }
} / / end class HilbertCurve
Problem 4. A Bezier curve B(£) of degree n is denned by a set of control
points pi for i = 0,1,.., n as follows
n
B(t)=J2PiB^(t)
where Bj n are the Bernstein polynomials
The sum of the Bernstein polynomials is a partition of unity
i=0

388 Problems and Solutions
We have Bi<n{t) > 0 for every 0 < t < 1. These properties imply that Bezier
curves are affine invariant, and that the curve lies entirely in the convex
hull of the control points denning the curve. We find that B(0) = p0 and
that B(l) = p n. Thus, the Bezier curve interpolates the end points. If we
calculate the derivative with respect to t at the endpoints, we find that
— (0) = n ( p i - p 0 ) , 
"^"(1) = n ( P « - P n - i ) -
Thus, the tangents at the end points of the curve are easily computed.
This allows us to construct piecewise smooth C1 or G1 curves out of Bezier
curves by setting np(p1 - p0) = cnq(qn - qn_i) for a curve
nq
Q(t) = £>£<.„(*)
followed by a curve
P(*) = £>Biin(i).
i=0
Write a Java Applet to display Bezier curves.
Solution 4. The class Vertex describes a point in the plane R2.
// Bezier.Java
import j ava.awt.event.*;
import j ava.awt.*;
import Java.applet.*;
import Java.awt.Graphics;
import java.util.Vector;
class Vertex {
public double x, y;
public boolean selected;
public Vertex(double x,double y) {
this.x = x; this.y = y;
selected = false;
}
} // end class Vertex
class BezierPanel extends Panel implements MouseListener,
MouseMotionListener {
private int n = 0;
private double delta = 0.0001;

Computer Graphics 389
private Vector vertices = new VectorO;
private boolean drawcurve;
private double a[] , b[], c[], d;
private double cost, sint;
public BezierPanelO {
n = 0;
addMouseListener(this);
addMouseMotionListener(this);
drawcurve = true;
}
public void mouseMoved(MouseEvent e) { drawcurve = true; }
public void mouseDragged(MouseEvent e)
{
Vertex p;
e.consume();
for(int k=0;k<n;k++) {
p = (Vertex)vertices.elementAt(k);
if(p.selected) { p.x=e.getX(); p.y=e.getY(); }
}
repaint();
>
public void mousePressed(MouseEvent e)
{
Vertex p;
e.consume();
for(int k=0;k<n;k++) {
p = (Vertex)vertices.elementAt(k);
if((Math.abs(e.getX()-p.x)<3)&&(Math.abs(e.getY()-p.y)<3))
p.selected = true; else p.selected = false; }
drawcurve = false;
repaint();
}
public void mouseReleased(MouseEvent e)
{ drawcurve = true; repaint(); }
public void mouseEntered(MouseEvent e) { }
public void mouseExited(MouseEvent e) { }
public void mouseClicked(MouseEvent e) {
e.consume();
if(e.getButton()==MouseEvent.BUTT0N3) {

390 
Problems and Solutions
n = 0;
vertices.clear();
} else { n++;
vertices.add(new Vertex(e.getX(),e.getY()));
}
drawcurve = true;
repaint();
>
public int comb(int t,int b) {
int r = 1;
for(int i=b+l;i<=t;i++) r*=i;
for(int i=2;i<=(t-b);i++) r/=i;
return r;
}
public double Bernstein(int i.int n,double t)
{ return comb(n,i)*Math.pow(t,i)*Math.pow(1.0-t,n-i); >
public void paint(Graphics g)
{
double x, y, oldx, oldy, t = 0.0;
int i, j, count;
double num, den;
Vertex p;
for(i=0;i<n;i++) {
p = (Vertex) vertices.elementAt(i);
x = p.x; y = p.y;
if(p.selected) g.setColor(Color.red);
else g.setColor(Color.green);
g.fillRect((int)x-3,(int)y-3,6,6);
>
g.setColor(Color.red);
for(i=l;i<n;i++) {
p = (Vertex) vertices.elementAt(i);
x = p.x; y = p.y;
p = (Vertex) vertices.elementAt(i-1);
oldx = p.x; oldy = p.y;
g.drawLine((int)oldx,(int)oldy,(int)x,(int)y);
}
if(!drawcurve) return;
g.setColor(Color.black);
if(n<3) return;

Computer Graphics 391
oldx = oldy =0.0;
for(i=0;i<n;i++) {
p = (Vertex) vertices.elementAt(i);
oldx += Bernstein(i,n-1,t)*p.x;
oldy += Bernstein(i,n-l,t)*p.y;
}
for(t=0.0;t<=1.0;t+=delta) {
x = y = 0.0;
for(i=0;i<n;i++) {
p = (Vertex)vertices.elementAt(i);
x += Bernstein(i,n-l,t)*p.x; y += Bernstein(i,n-l,t)*p.y;
}
g.drawLine((int)oldx,(int)oldy,(int)x,(int)y);
oldx = x; oldy = y;
>
>
}
public class Bezier extends Java.applet.Applet
implements WindowListener {
BezierPanel panel;
static Frame f;
public void windowActivated(WindowEvent e) O ;
public void windowClosed(WindowEvent e) {};
public void windowClosing(WindowEvent e) {
remove(panel);
panel = null;
f.disposeO; f = null;
};
public void windowDeactivated(WindowEvent e) O ;
public void windowDeiconified(WindowEvent e) {};
public void windowlconified(WindowEvent e) {};
public void windowOpened(WindowEvent e) {};
public void init() {
setLayout (new BorderLayoutO);
panel = new BezierPanel();
addC'Center".panel);
}
public void destroyO { remove(panel); panel = null; }
public static void main(String args[]) {

392 Problems and Solutions
f = new FrameC'Bezier Curves");
Bezier h = new BezierO ;
h.initO ; h.startO;
f.add("Center",h);
f.setSize(300,300);
f .showO;
f.addWindowListener(h);
}
public String getAppletlnfo()
{ return "Draws a Bezier curve between points"; }
>
Problem 5. The n x n primary permutation matrix U is given by
/0 
1 0 ... 0\
0 0 1 ... 0
u= 
i : 
; ••. ; 
. 
(i)
0 0 0 ... 1
\ 1 
0 0 ... 0 /
The eigenvalues of U are given by A0 = 1, A1, A2, ..., A""1 with A :=
exp(27ri/n). The spectral decomposition of U is
u=T,XJpj- 
(2)
3=0
The projection matrix Pj can be expressed using Uk. Since PjPk = 0 for
j ^ k and P? = Pj we find
n - l
Uk = Y^XkPj, 
Jfc=l,2,...,n. 
(3)
Thus, we calculated the Fourier transform of the projection matrices. For
k = n we have Un — /„ and the completeness relation
7 1 - 1
The inverse of the matrix (A-'*) is given by ±(\~jk). 
Thus
1 
n-i
Pi = ~ Y ^JkU\ 
j = 0 , l , . . . , n - l . 
(4)
/fc=0

Computer Graphics 393
We apply the permutations in such a way that we can continuously inter-
polate between the points of a polygon. We embed the matrices Uk into
a real Lie group. Thus, we have to consider the cases n = 2m + 1 and
n = 2m, where m is a positive integer. In the second case we have A0 — 1
and Am = — 1. Furthermore, we define P_j := Pn-j- The projection ma-
trices are therefore real. We consider first the case n = 2m + 1. We obtain
by replacing k by nt, t 6 [0,1]
m
U(t) = Po 4- Y^(e2"iitpi 
+ e~2*iJtP-j), 
* e R •
3 = 1
The unitary matrices U(t) are 1-periodic, i.e., U(t + 1) = f/(t). 
Thus
C/(* + 1) = J7(£) and U{k/n) = Uk for k = 0 , 1 , . . . , n - 1. Owing to (4), we
can write [/(£) as
1 " - 1 / 
m 
\
We define
ah(t) = (7(t - k/n) := M 1 + £ (e^<*-*/n' + e-^i(*-*/n)j j .
Using exp(ia) = cos(a) + isin(a),
i , oV^ 
/• i 
sin((m + l/2)a)
1 + 2 > cos(ja) — —-—-—,\ 
'
j^ 
u 
; 
sin(a/2)
and with n = 2m + 1 we find
. . 
sin(7rn(t — k/n))
gfc(t) = 
• , V>. r ~ > fc = 0 , l , . . . , n - l .
nsm(7r(i - fc/ra))
Thus, we can write
U(t) = Y^ak(t)Uk.
We have the properties
fc=0 fc=O

394 Problems and Solutions
Thus, the functions crfc(t) and v^t) provide a partition of unity, and the har-
monic interpolation is affine invariant. Now let X = 
(Xo,Xi,...,Xn_i)T
be the vector which describes the polygon. Then
n - l
X(i) = U(t)X =Y^a{t- 
k/n)UkX.
k=0
The curve which describes our closed smooth curve is given by
n—1 
n— 1
Xt(t) = YJ
(T(t-k/n)Xk+i 
= ^2<r(t + £/n-(k + £)/n)Xk+e = X0(t + £/n)
k=0 
fc=O
where (k + £) is calculated modn. Hence, for all £ it represents the same
curve and we can write
n - l
X(t) = J2a(t-k/n)Xk, 
te[0,l]. 
(5)
fc=o
Thus, this curve interpolates the points of the given polygon smoothly. We
consider now the case n = 2m. For this case we can write
m - l
Uk = Po + (-l)kPm + ]T (\jkPj + \~jkP-j) •
j=i
If we replace the discrete variable k by the real variable t, we find the factor
(—1)* = e""1*. The other terms are real. Thus, the Lie group we would find is
not real and therefore cannot be used directly for the harmonic interpolation
in computer graphics. Since the function U(t) will be continuous in the
complex domain and go through the points of the polygon, the real part
will also be continuous and go through the points of the polygon. A similar
calculation as described for the case n = 2m+l given above yields (t e [0,1])
.. n —1 
. n —1 
n — 1
U(t) = - Y^ cos(Tr(nt - k))Uk + ~Y1 sin(7r(ni - k))Uk + ^ £,k{t)Uk
fc=0 fc=0 fc=0
where
nsm(Trt) 
\ 
n)
Thus, our smooth curve in the even case which goes through all the points
of the polygon is
X(t) = J2 (- cos(7r(nt - k)) + £k(t)) Xk . 
(6)
fc=o ^ n 
'

Computer Graphics 395
Write a Java applet and application to draw the harmonic interpolation of
a polygon.
Solution 5. 
The following Java applet and application implements the
harmonic interpolation. Click with the left mouse button to add points.
The Java program will draw the curve resulting from harmonic interpola-
tion. Points can also be dragged to new positions. Click with the right
mouse button to remove all points.
/ / Harmoniclnterpolation.Java
import j ava.awt.event.*;
import j ava.awt.*;
import j ava.applet.*;
import Java.awt.Graphics;
import java.util.Vector;
class Vertex {
public double x, y;
public boolean selected;
public Vertex(double x,double y) {
this.x = x; this.y = y;
selected = false;
}
}
class HarmonicPanel extends Panel implements MouseListener,
MouseMotionListener {
private int n = 0;
private double delta = 0.0001;
private Vector vertices = new VectorO;
private boolean drawcurve;
private double a[] , b[] , c[] , d;
private double cost, sint;
public HarmonicPanel() {
n=0;
addMouseListener(this);
addMouseMotionListener(this);
drawcurve=true;
}
public void mouseMoved(MouseEvent e) { drawcurve=true; )•
public void mouseDragged(MouseEvent e) {

396 
Problems and Solutions
Vertex p;
e.consume();
for(int k=0;k<n;k++) {
p = (Vertex)vertices.elementAt(k);
if(p.selected) { p.x=e.getX(); p.y=e.getY(); }
}
repaint();
>
public void mousePressed(MouseEvent e) {
Vertex p;
e.consume();
for(int k=O;k<n;k++) {
p = (Vertex) vertices.elementAt(k);
if((Math.abs(e.getX()-p.x)<3) &&
(Math.abs(e.getY()-p.y)<3))
p.selected = true;
else p.selected = false;
}
drawcurve = false;
repaint();
}
public void mouseReleased(MouseEvent e)
{ drawcurve = true; repaint(); }
public void mouseEntered(MouseEvent e) { }
public void mouseExited(MouseEvent e) { }
public void mouseClicked(MouseEvent e) {
e.consume();
if(e.getButton()==MouseEvent.BUTT0N3) {
n = 0;
vertices.clear() ;
} else {
n++;
vertices.add(new Vertex(e.getXO,e.getY()));
>
drawcurve = true;
repaint();
}
private double sigma_helper(int n,double t) {
if(n==l) return 1;
return Math.cos(Math.PI*(n-1)*t)+

Computer Graphics 
397
Math.cos(Math.PI*t)*sigma_helper(n-l,t);
}
private double sigma(double t) -f
double result;
double test = Math.abs(t)-(int)(Math.abs(t));
double distl = test;
double dist2 = Math.abs(l.O-test);
if((distl<le-7)||(dist2<le-7)) {
result=sigma_helper(n, t)/n;
} else {
result = Math.sin(Math.PI*n*(t))/(n*Math.sin(Math.PI*(t)));
}
if (n'/.2==0) return result *= Math.cos(Math.PI*t);
return result;
}
private double sigma_k(int k.double t)
{ return sigma(t-(double)k/n); }
public void paint (Graphics g) -f
double x, y, oldx, oldy, num, den;
int k, j, count;
double t = 0.0;
Vertex p;
for(k=0;k<n;k++) {
p = (Vertex) vertices.elementAt(k);
x = p.x; y = p.y;
if(p.selected) g.setColor(Color.red);
else g.setColor(Color.green);
g.fillRect((int)x-3,(int)y-3,6,6);
}
g.setColor(Color.red);
for(k=l;k<n;k++) {
p = (Vertex) vertices.elementAt(k);
x = p.x; y = p.y;
p = (Vertex)vertices.elementAt(k-1);
oldx = p.x; oldy = p.y;
g.drawLine((int)oldx,(int)oldy,(int)x,(int)y);
}
g.setColor(Color.blue);

398 
Problems and Solutions
if(n>2) {
p = (Vertex) vertices.elementAt(0);
x = p.x; y = p.y;
p = (Vertex) vertices.elementAt(n-1);
oldx = p.x; oldy = p.y;
g.drawLine((int)oldx,(int)oldy,(int)x,(int)y);
}
if(!drawcurve) return;
g.setColor(Color.black);
if(n<3) return;
oldx = oldy =0.0;
for(k=0;k<n;k++) {
p = (Vertex) vertices.elementAt(k);
oldx += sigma_k(k,t)*p.x; oldy += sigma_k(k,t)*p.y;
}
for(t=0.0;t<=1.0;t+=delta) {
x = y = 0.0;
for(k=0;k<n;k++) {
p = (Vertex) vertices.elementAt(k);
x += sigma_k(k,t)*p.x; y += sigma_k(k,t)*p.y;
}
g.drawLine((int)oldx,(int)oldy,(int)x,(int)y);
oldx = x; oldy = y;
}
>
}
public class Harmoniclnterpolation extends Java.applet.Applet
implements WindowListener {
HarmonicPanel panel;
static Frame f;
public void windowActivated(WindowEvent e) {};
public void windowClosed(WindowEvent e) {};
public void windowClosing(WindowEvent e) {
remove(panel); panel = null; f.dispose(); f = null;
>;
public void windowDeactivated(WindowEvent e) {};
public void windowDeiconified(WindowEvent e) {};
public void windowlconified(WindowEvent e) {};
public void windowOpened(WindowEvent e) O ;

Computer Graphics 399
public void initO {
setLayout(new BorderLayout());
panel=new HarmonicPanelQ;
add("Center".panel);
>
public void destroyO
{ remove(panel); panel = null; }
public static void main(String args[]) {
f = new Frame("Harmonic Interpolation");
Harmoniclnterpolation h = new HarmonicInterpolationQ ;
h.initO; h.start();
f.add("Center",h);
f .setSize(300,300);
f .showO ;
f.addWindowListener(h);
}
public String getAppletlnfo() {
return "Draws a curve using harmonic interpolation";
>
}
Problem 6. Let P be a non-empty finite set of planar points. A planar
Voronoi diagram of the set P is a partition of the plane into such regions
that for any element of P, a region corresponding to a unique point p
contains all those points of the plane that are closer to p than to any other
node of P. A unique region
vor(p) := {q £ R2 : d(p,q) < d(q,m) for all m e P, m =fip}
assigned to a point p £ R2 is called a Voronoi cell. A boundary of the
Voronoi cell of a point p is built of segments of bisectors separating the
point p and its geographically closest neighbors from the given set P. A
union of all boundaries of the Voronoi cells comprises the planar Voronoi
diagram
VD(P) := (J dvor(p).
PGP
Voronoi diagrams are applied in computer science, statistics, geography and
economics. The problem becomes simpler if we consider the mapping *:
*(x,y) = (x,y + d(q))

400 Problems and Solutions
where
and q = (x,y). This mapping ensures that a region in V* is encountered
for the first time at a site and disappears at the intersection between two
edges. This allows us to sweep a horizontal line vertically, and when we
encounter an event (a site, or intersection) to modify our description of the
current regions that applies for this horizontal line. Each site will be at
the lowest point of the region it describes. Once we have calculated V*,
it is trivial to construct VD(P) and this can be done simultaneously. Q
is a priority queue of points in the plane, ordered lexicographically. Each
point is labeled as a site or intersection. L is a sequence of regions and
boundaries. Note that if p is the intersection of two bisectors B\ and B2,
then p* is the intersection of B\ and B%. Rp is vor(p). R* is Rp under
the mapping *. Bpq is the perpendicular bisector of p and q. C~q is the
part of Bpq to the left of p and C+q is the part of Bpq to the right of p as
appropriate. The pseudocode is as follows (Fortune's algorithm):
1. initialize Q with all sites
2. p <— extract_min(Q)
3. L <— the list containing Rp
4. while Q is not empty begin
5. p *— extract_min(<3)
6. case
7. 
p is a site:
8. 
Find an occurrence of a region R* on L containing p.
9. 
Create bisector B*q.
10. 
Update list L so that it contains ..., R*, C~q, R*, C+q, R*q,
... in place of R*.
11. 
Insert intersections between C~q, C+q with neighboring bound-
aries into Q.
12. 
p is an intersection:
13. 
Let p be the intersection of boundaries Cqr and Crs.
14. 
Create the bisector B*s.
15. 
Update list L so that it contains Cqs = C~s or C+ as appropriate,
instead of Cqr, i?*, CTS.

Computer Graphics 401
16. 
Delete from Q any intersection between Cqr, Crs and their neigh-
bors.
17. 
Insert any intersections between Cqs and its neighbors into Q.
18. 
Mark p as a vertex and as an endpoint of B*r, B*s, and B*s.
19. end
Write a C++ program that finds the planar Voronoi diagram for a given
set of points. The points should be read in from a file. Use metapost as
the output format and for rendering the Voronoi diagrams.
Solution 6. The class point describes a point in R2.
// fortune.cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <cmath>
#include <cassert>
using namespace std;
const int SITE = 0, INTERSECT = 1, REGION = 0, EDGE = 1;
class point {
public:
double x, y;
point() { x = y = 0 . 0 ; }
point(double x,double y) { this->x = x; this->y = y; >
point operator - (const point &p2) const {
return point(x-p2.x,y-p2.y);
}
point operator + (const point &p2) const {
return point(x+p2.x,y+p2.y);
}
// dot product
double operator * (const point &p2) const {
return x*p2.x+y*p2.y;
}
point operator * (double t) const {
return point(x*t,y*t);
}
point operator / (double t) const {

402 
Problems and Solutions
return point(x/t,y/t);
}
};
point operator * (double t,const pointfe pi)
{ return pl*t; }
ostreamfe operator « (ostreamfe out,point p) {
/ / get rid of scientific notation for metapost
p.x = (int) (p.x*le6)/le6; p.y = (int) (p.y*le6)/le6;
out « "(" « p.x « "u, " « p.y « "v)";
return out;
>
point zero(0,0);
double dist(const pointft pi,const pointft p2)
{ return sqrt((pl-p2)*(pl-p2)); }
point norm(const point &p)
{ point q=p/dist(p,zero); return q; }
struct edge;
struct site_info;
typedef struct intersection {
struct edge *el, *e2;
struct site_info *q, *s, *r;
y intersection;
typedef struct site_info {
int type, name;
point site;
intersection intersect;
} site_info;
typedef struct edge {
site_info *ol, *o2;
point pi, p2;
double tl, t2;
struct edge *parent;
bool marked[2];
int count;
} edge;

Computer Graphics 403
typedef struct region {
int type;
union {
site_info *site;
edge *bisector;
} data;
> region;
vector<site_info*> read_points(char *file) {
vector<site_info*> S;
ifstream fin(file);
site_info *p; int i=0;
while( (!f in. eof ())&&(! fin.failQ)) {
p = new site_info; p -> type=SITE;
fin >> p->site.x»p->site.y;
p -> name=i++;
if(!fin.fail()) { S.push_back(p); }
else { delete p; }
}
f in.closeO ;
return S;
>
double ystar(site_info *p) {
double y = p->site.y;
if(p->type==INTERSECT) {
y += dist(p->site,p->intersect.el->ol->site);
}
return y;
}
void begin_metapost(const vector<site_info*> &S) {
cout « "u=15cm;" « endl; cout « "v=15cm;" « endl;
cout « "beginfig(l);" « endl;
cout << "\tpickup pencircle scaled 4pt;" « endl;
for(int i=0;i<S.size();i++) {
cout « "\tdraw (" « S[i]->site.x « "u, "
« S[i]->site.y « "v);" « endl;
>
cout « "\tpickup pencircle scaled O.5pt;" << endl;
>
void end_metapost()
{ cout « "endfig;" « endl; cout « "end;" « endl; }

404 
Problems and Solutions
bool between(double tl,double t2,double t) {
if(tl<t2) return (tl<=t)&&(t<=t2);
else return (t2<=t)&&(t<=tl);
}
double intersect_star(edge *e,double y) {
double x;
double dx = e->p2.x-e->pl.x; double dy = e->p2.y-e->pl.y;
double dpoy = (e->pl.y-e->ol->site.y) ;
double dpox = (e->pl.x-e->ol->site.x);
double a = dx*dx;
double b = dx*dpox+dy*(y-e->ol->site.y);
double c=dpox*dpox+dpoy*dpoy-(y-e->pl.y)*(y-e->pl.y);
// should always intersect
assert(b*b-a*c>=0);
if(b*b-a*c<0.0) { return -Iel5; }
double tl = (-b+sqrt(b*b-a*c))/a;
double t2 = (-b-sqrt(b*b-a*c))/a;
if(between(e->tl,e->t2,tl))
x=e->pl.x+tl*dx;
else x=e->pl.x+t2*dx;
return x;
}
double gettx(edge *e,double x) {
double t = (x-e->pl.x)/(e->p2.x-e->pl.x);
return t;
}
double getty(edge *e,double y) {
double t = (y-e->pl.y)/(e->p2.y-e->pl.y);
return t;
}
double gett(edge *e,const point &p) {
if(e->p2.y-e->pl.y>e->p2.x-e->pl.x)
return getty(e.p.y);
else return gettx(e,p.x);
}
double gety(edge *e,double t) {
point q = e->pl+t*(e->p2-e->pl);
q.y += dist(q,e->ol->site);

Computer Graphics 
405
return q.y;
}
point getpoint(edge *e,double t) {
point q = e->pl+t*(e->p2-e->pl);
return q;
}
site_info *intersect(edge *el,edge *e2) {
double t, tn;
site_info *s;
point dl = el->p2-el->pl; point d2 = e2->p2-e2->pl;
point &ol=el->pl, &o2=e2->pl;
point dlp=el->o2->site-el->ol->site;
point d2p=e2->o2->site-e2->ol->site;
// check for parallel
if(fabs(d2p*dl)<le-15) return NULL;
t = ((o2-ol)*d2p)/(dl*d2p);
tn = ((ol-o2)*dlp)/(d2*dlp);
if(!between(el->tl,el->t2,t)) return NULL;
if(!between(e2->tl,e2->t2,tn)) return NULL;
s = new site_info;
s -> type=INTERSECT;
s -> site=ol+t*dl;
s -> intersect.el=el; s -> intersect.e2=e2;
if(el->o2==e2->ol) {
s->intersect.q=el->ol;
s->intersect.r=el->o2;
s->intersect.s=e2->o2;
} else if(el->ol==e2->ol) {
s->intersect.q=el->o2;
s->intersect.r=el->ol;
s->intersect.s=e2->o2;
> else if(el->ol==e2->o2) {
s->intersect.q=el->o2;
s->intersect.r=el->ol;
s->intersect.s=e2->ol;
}• else
if(el->o2==e2->o2) {
s->intersect.q=el->ol;
s->intersect.r=el->o2;
s->intersect.s=e2->ol;
} else {
cout « "No common vertex! el=";

406 
Problems and Solutions
cout « el->ol->name « "E" « el->o2->name;
cout « " e2=";
cout « e2->ol->name « "E" « e2->o2->name « endl;
}
return s;
}
void replace(vector<region> &L,int k,region Rq.edge *Bpq,
region Rp)
•C
int i=0;
vector<region>::iterator iter;
region r;
iter = L.beginO ;
while(i<k) { iter++; i++; }
iter = L.erase(iter); iter = L.insert(iter,Rp);
r.type = EDGE;
r.data.bisector = Bpq;
iter = L.insert(iter,r); iter = L.insert(iter,Rq);
}
void replace(vector<region> &L,int k,region Rql.edge *Cpq_m,
region Rp.edge *Cpq_p,region Rq2)
{
int i=0;
region r;
vector<region>::iterator iter;
iter = L.beginO ;
while(i<k) { iter++; i++; }
iter = L.erase(iter); iter = L.insert(iter,Rq2);
r.type = EDGE;
r.data.bisector = Cpq_p;
iter = L.insert(iter.r); iter = L.insert(iter.Rp);
r.type = EDGE;
r.data.bisector = Cpq_m;
iter = L.insert(iter,r);
iter = L.insert(iter.Rql);
}
void replace(vector<region> &L,int k,int l.edge *Cqs)
{
int i=0;
vector<region>::iterator iter;
region r;

Computer Graphics 407
r.type = EDGE;
r.data.bisector = Cqs;
iter = L.beginO ;
while(i<k) { iter++; i++; }
for(;i<=l;i++) { iter=L.erase(iter); }
L.insert(iter,r);
}
int find_region(const vector<region> &L,site_info *p)
{
for(int i=0;i<L.size(); i++) {
if(L [i].type==EDGE) {
double x = intersect_star(L[i].data.bisector,p->site.y);
if(x>p->site.x) { return i-1; }
}
}
return L.size()-1;
}
void remove(vector<site_info*> &Q,site_info *m) {
vector<site_info*>::iterator iter;
iter = Q.beginO;
while(*iter!=m) { iter++; }
Q.erase(iter);
}
void remove_intersections(vector<site_info*> &Q,edge *e) {
vector<site_info*>::iterator iter;
iter = Q.beginO ;
while (iter !=Q.endO) {
if((*iter)->type==INTERSECT) {
if ((*iter)->intersect.el == e) {
delete *iter;
iter = Q.erase(iter);
} else if ((*iter)->intersect.e2==e) {
delete *iter;
iter=Q.erase(iter);
} else iter++;
y else
iter++;
}
}
site_info *extract_min(vector<site_info*> &Q) i

408 
Problems and Solutions
int min = 0;
site_info *m;
for(int i=0;i<Q.size();i++) {
if(ystar(Q[i])<ystar(Q[min])) min = i;
else if(ystar(Q[i])==ystar(Q[min]))
if(Q[i]->site.x<Q[min]->site.x) min = i;
}
m = QQnin] ;
remove(Q,m);
return m;
}
edge *bisector(site_info *vl,site_info *v2)
{
edge *e; point perp;
perp.x=vl->site.y-v2->site.y;
perp.y=v2->site.x-vl->site.x;
if(perp.x<0.0) { perp.x=-perp.x; perp.y=-perp.y; }
e = new edge;
e->parent = NULL; e->count = 0;
e->marked[0] = false; e->marked[l] = false;
e->ol=vl; e->o2=v2;
e->pl=(vl->site+v2->site)/2.0-perp;
e->p2=(vl->site+v2->site)/2.0+perp;
e->tl=-le7; e->t2=le7;
return e;
}
int get_index(const vector<region> &L,edge *e)
{
for(int i=0;i<L.size();i++)
if((L[i].type==EDGE)&&(L[i].data.bisector==e))
return i;
return -1;
}
void markend(edge *e,site_info *p)
i
edge *ep = e;
if(e->parent!=NULL) ep = e->parent;
double t = gett(e,p->site);
if(gety(e,e->tl)>gety(e,t)) {
ep->tl=t;
ep->marked[0]=true;

Computer Graphics 409
} else { ep->t2=t; ep->marked[l]=true; }
}
void markbeg(edge *e,site_info *p)
{
edge *ep = e;
if(e->parent!=NULL) ep = e->parent;
double t = gett(e,p->site);
if(gety(e,e->tl)>gety(e, t)) {
ep->t2 = t; ep->marked[l] = true;
} else { ep->tl=t; ep->marked[0]=true; }
}
void clip(edge *e)
{
point p = getpoint(e,e->tl);
if(p.x<0.0) {e->tl=gettx(e,0.0); e->marked[0]=false;}
if(p.x>1.0) {e->tl=gettx(e,1.0); e->marked[0]=false;}
p=getpoint(e,e->tl);
if(p.y<0.0) -Ce->tl=getty(e,0.0); e->marked[O]=false;}
if(p.y>1.0) -Ce->tl=getty(e,1.0); e->marked[O]=false;}
p=getpoint(e,e->t2);
if(p.x<0.0) -fe->t2=gettx(e,0.0); e->marked[l]=false;}
if(p.x>1.0) {e->t2=gettx(e,1.0); e->marked[l]=false;}
p=getpoint(e,e->t2);
if(p.y<0.0) {e->t2=getty(e,0.0); e->marked[l]=false;}
if(p.y>1.0) {e->t2=getty(e,1.0); e->marked[l]=false;}
e->count=0;
if(e->marked[0]) e->count++;
if(e->marked[l]) e->count++;
}
void metapost_edges(const vector<edge *> feedges) {
for(int i=0;i<edges.size();i++) {
if(edges[i]->parent==NULL) {
clip(edges[i]);
if(edges[i]->tl==edges[i]->t2) continue;
if(edges[i]->count==2)
cout « "\tdraw "
« getpoint(edges[i].edges[i]->tl) « "—"
« getpoint(edges[i].edges[i]->t2) « ";" « endl;
if(edges[i]->count==l)
if(edges[i]->marked[0])
cout « "\tdrawarrow "

410 Problems and Solutions
« getpoint (edges [i] , edges [i]->tl) « " — "
« getpoint(edges[i].edges[i]->t2) « ";" « endl;
else
cout « "\tdrawarrow "
« getpoint(edges[i],edges[i]->t2) « " — "
« getpoint(edges[i].edges[i]->tl) « ";" « endl;
if(edges[i]->count==0) {
cout « "\tdrawarrow "
« 
getpoint(edges[i],0.5*(edges[i]->tl+edges[i]->t2))
« 
" —" « getpoint (edges [i] .edges [i]->t2) « " ; "
« endl;
cout « "\tdrawarrow "
« 
getpoint(edges[i],0.5*(edges[i]->tl+edges[i]->t2))
« "—" « getpoint(edges[i].edges[i]->tl) « " ; "
« endl;
}
}
>
}
void split(edge *Bpq,edge *&Cpq_m,edge *&Cpq_p,site_info *p)
{
double t = gettx(Bpq,p->site.x);
Cpq_m = new edge; *Cpq_m = *Bpq; Cpq_m -> count = 0;
Cpq_p = new edge; *Cpq_p = *Bpq; Cpq_p -> count = 0;
Cpq_m -> parent = Bpq; Cpq_p -> parent = Bpq;
Cpq_m -> t2 = t; Cpq_p -> tl = t;
}
int main(int argc.char *argv[]) {
vector<site_info*> S, Q;
vector<region> L;
vector<edge*> edges;
site_info *p, *s, *q;
region r, Rp, Rq;
edge *Bpq, *Bqs;
edge *Cpq_p, *Cpq_m, *Cqr, *Cqs, *Crs, *Cqs_p, *Cqs_m;
double t; int i, j;
if(argc!=2) {
cout « "Usage: " « argv[0] « " file.pts " « endl;
return 0;
}
S = read_points(argv[l]);

Computer Graphics 411
begin_metapost(S);
Q = S;
p = extract_min(Q);
r.type = REGION; r.data.site=p;
L.push_ba.ck(r);
while(Q.size()>0) {
p = extract_min(Q);
switch(p->type) {
case SITE:
i = find_region(L,p);
Rq = L[i]; q = Rq.data.site;
Bpq = bisector(p,q);
edges.push_back(Bpq);
Rp.type=REGION; Rp.data.site=p;
if(fabs(q->site.y-p->site.y)<le-15) {
Cpq_m = Bpq; Cpq_p = Bpq;
> else {
split(Bpq,Cpq_m,Cpq_p,p);
edges.push_back(Cpq_p);
edges.push_back(Cpq_m);
}
if(i-l>=0) {
s = intersect(L[i-1].data.bisector,Cpq_m);
if(s!=NULL) q.push.back(s);
}
if(i+KL.size()) {
s = intersect(L[i+1].data.bisector,Cpq_p);
if(s!=NULL) q.push_back(s);
}
if(fabs(q->site.y-p->site.y)<le-15) {
if(p->site.x<q->site.x) replace(L,i,Rp,Bpq,Rq);
else replace(L,i,Rq,Bpq,Rp);
} else { replace(L,i,Rq,Cpq_m,Rp,Cpq_p,Rq); }
break;
case INTERSECT:
q = p->intersect.q; s=p->intersect.s;
Cqr = p->intersect.el; Crs = p->intersect.e2;
Bqs = bisector(q.s);
edges.push_back(Bqs);
i = get_index(L,Cqr); j = get_index(L,Crs);
if(j<i) { int k=i; i=j; j=k; }
if((i==-l)||(j==-D) {
cout « "•/. i=" « i « " j=" « j « " : Internal error"
« endl;

412 
Problems and Solutions
break;
}
site_info *h;
if(q->site.y>s->site.y) h = q; else h=s;
split(Bqs,Cqs_m,Cqs_p,h);
if(fabs(q->site.y-s->site.y)<le-15) { Cqs = Cqs_p; }
else {
if(p->site.x>h->site.x) Cqs=Cqs_p;
else Cqs=Cqs_m;
}
if(Cqs==Cqs_m) delete Cqs_p; else delete Cqs_m;
edges.push_back(Cqs);
markend(Cqr,p); markend(Crs,p); markbeg(Cqs,p);
if(j-i!=2) {
cout « "'/.Internal error (>2) i=" « i « " j = "«j«endl;
break;
}
remove_intersections(Q,Cqr); remove_intersections(Q,Crs);
replace(L,i,j,Cqs);
if(i-2>=0) {
s = intersect(L[i-2].data.bisector,Cqs);
if(s!=NULL) Q.push_back(s);
}
if(i+2<L.size()) {
s = intersect(L[i+2].data.bisector,Cqs);
if(s!=NULL) Q.push_back(s);
}
// removed by remove_intersections;
break;
}
}
metapost_edges(edges);
end_metapost();
for(i=0;i<S.size();i++) { delete S[i]; }
for(i=0;i<edges.size();i++) { delete edges[i]; }
return 0;
>

Bibliography
Akenine-Moller T. and Haines E.
Real-Time Rendering, second edition
AK Peters, Natick, Massachusetts (2002)
Axelsson O.
Iterative Solution Methods
Cambridge University Press, Cambridge (1994)
Back T.
Evolutionary Algorithms in Theory and Practice
Oxford University Press, Oxford (1996)
Baase S.
Computer Algorithms, second edition
Addison-Wesley, Reading, Massachusetts (1988)
Bertsekas D. P.
Nonlinear Programming, second edition
Athena Scientific, Belmont, Massachusetts (1999)
Cohen D. I. A.
Introduction to Computer Theory, second edition
J. Wiley, New York (1990)
Duchateau P. and Zachmann D. W.
Partial Differential Equations, Schaum's Outline Series in Mathematics
McGraw-Hill, New York (1986)
Fortune S. J.
A Sweepline Algorithm for Voronoi Diagrams,
Algorithmica, 2, 153-174 (1987)
Gallaher L. J.
A Multidimensional Monte Carlo Quadrature with Adaptive Stratified Sam-
pling,
CACM, Algorithm, 440 (1971)
Gelbaum B.
Problems in Analysis
Springer-Verlag, New York (1982)
413

414 
Bibliography
Gestlong J. L.
Mathematical Structures for Computer Science, second edition
W. H. Freeman, New York (1987)
Hairer E., N0rsett S. P. and Wanner G.
Solving Ordinary Differential Equations I, second revised edition
Springer-Verlag, Berlin (1991)
Hardy Y. and Steeb W.-H.
Classical and Quantum Computing: With C++ and Java Simulations
Birkhauser-Verlag (2002)
JaJa J.
An Introduction to Parallel Algorithms,
Addison-Wesley Publishing, Reading (1992)
James M. L., Smith G. M. and Wolford J. C.
Applied Numerical Methods for Digital Computation, third edition
Harper and Row Publishers, New York (1985)
Koonin S. E. and Meredith D. C.
Computational Physics,
Addison-Wesley, Redwood City (1990)
Krzyz J. G.
Problems in Complex Variables Theory
Elsevier, New York (1971)
Larson L. C.
Problem Solving Through Problems
Springer-Verlag, New York (1983)
Lipschutz S.
Discrete Mathematics, Schaum's Outline Series in Mathematics
McGraw-Hill, New York (1976)
McCracken D. D.
A Second Course in Computer Science with Pascal
J. Wiley, New York (1987)
Morton K. W. and Mayers D. F.
Numerical Solution of Partial Differential Equations
Cambridge University Press, Cambridge 1994

Bibliography 
415
Nakamura S.
Applied Numerical Methods in C
Prentice-Hall, Englewood Cliffs (1993)
Neapolitan R. and Naimipour K.
Foundations of Algorithms
D. C. Heath and Company, Lexington (1996)
Osyczka A.
Evolutionary Algorithms for Single and Multicriteria Design Optimization
Physica-Verlag, Heidelberg (2002)
Pearson T. W.
Introduction to Algorithms in PASCAL
John Wiley, New York (1995)
Saad Y.
Iterative Methods for Sparse Linear Systems
PWS Publishing Company, Boston (1996)
Seroul R.
Programming for Mathematicians
Springer Verlag, Berlin (1991)
Spiegel M. R.
Advanced Calculus, Schaum's Outline Series
McGraw Hill, New York (1974)
Spiegel M. R.
Finite Differences and Difference Equations, Schaum's Outline Series
McGraw Hill, New York (1971)
Steeb W.-H.
The Nonlinear Workbook: Chaos, Fractals, Cellular Automata, Neural Net-
works, Genetic Algorithms, Gene Expression Programming, Wavelets, Fuzzy
Logic with C++, Java and SymbolicC++ Programs, second edition
World Scientific, Singapore (2002)
Thijssen J. M.
Computational Physics
Cambridge University Press, Cambridge (1999)

416 
Bibliography
Tomescu I.
Problems in Combinatorics and Graph Theory
J. Wiley, New York (1985)
Van de Velde E. F.
Concurrent Scientific Computing
Springer-Verlag, New York (1994)
Wiener R. S. and Pinson L. J.
An Introduction to Object-Oriented Programming and C++
Addison-Wesley, Reading (1988)

Index
oo-norm, 19
1-norm, 18
Adams-Bashforth method, 263
Addition theorem, 8
Adjacency matrix, 295, 327
Annealing, 256
Arithmetic expressions, 373
Associated wavelet function, 290
Atom, 188
Bezier curve, 387
Baeza-Yates-Gonnet algorithm, 371
BBS generator, 251
Bent function, 46
Bernstein polynomials, 387
Big Endian, 39
Binary matrices, 89
Binary search, 165
Bisection method, 202
Blob, 156
Blum, Blum, Shub generator, 251
Bounding box, 383
Boyer-Moore algorithm, 362
Caley-Hamilton theorem, 110
Cantor's enumeration, 77
Cardinality, 89, 90, 97
Carry look-ahead, 45
Cauchy sequence, 238
Cayley-Hamilton theorem, 143
Center of gravity, 201
Central difference approximation,
278
Checksum, 33, 347
Codon, 366
Column compressed storage, 126
Commutator, 22
Compact support, 291
Companion matrix, 143
Complete elliptic integral, 236
Complexity, 47
Compositional complexity, 100
Conjugate gradient method, 211
Conservation law, 280
Continued fraction, 235
Contracting mapping, 237
Contracting mapping theorem, 238
CRC32 polynomial, 35
Csanky's algorithm, 110
Cumulative sum, 14
Deceptive functions, 321
Decision function, 317
Design matrix, 310
Determinant, 115, 140
Digraph, 299
Dijkstra method, 299
Diophantine equation, 64
Discrete Fourier transform, 231
Discrete wavelet transform, 290
Divide-and-conquer algorithm, 77
Division, 28
DNA molecule, 366
Dominoes, 97
Double numerical integration, 228
Durbin's algorithm, 105
Elliptic integral of first kind, 158
Energy functional, 213
417

418 Index
Euclidean algorithm, 64
Euclidean norm, 216
Euler angles, 144
Euler path, 295
Euler totient function, 67
Euler-Lagrange equations, 335
Explicit Euler method, 263
Exponential function, 21
Farey fraction, 56
Farey sequence, 56
Feature space, 316
Fibonacci numbers, 83, 149
Fixed point, 238
Fixed points, 263
Flip-flop circuit, 38
Floyd-Warshall algorithm, 297
Fortune's algorithm, 400
Fourier expansion, 239, 240
Frequency modulation, 42
Full adder, 27
Function table, 25
Gaussian distribution, 248
Genetic code, 366
Geometric series, 128
Golden mean number, 149
Gradient method, 211
Gradient vector, 210
Gram-Schmidt orthogonalization
process, 109
Graph, 295
Greedy algorithm, 338, 339, 342
Group, 14
Haar basis, 288
Haar function, 291
Haar scaling function, 287
Haar wavelet, 285
Hadamard matrix, 124
Halley's method, 207
Hamilton path, 303
Hamilton's equations of motion,
264
Hamming distance, 41
Harmonic interpolation, 10
Harmonic oscillator, 270, 335
Hausdorff distance, 219
Hessian matrix, 210
Highest common divisor, 67
Hilbert curve, 384
Hilbert-Schmidt norm, 112
Hofstadter function, 152
Homer's algorithm, 161
Homer's rule, 199
Householder method, 133
Householder transform, 133
111 conditioned system, 16
Integration by parts, 5, 280
Intel hex record, 347
Intersection, 97
Intrusive linked list, 182
Inviscid Burgers equation, 280
Ising model, 259
Jacobi elliptic functions, 158
Jacobi identity, 22
Jacobi method, 115, 233
Jacobian matrix, 209
Jagged array, 20
Josephus function, 95
Kahan's summation algorithm, 16
Karatsuba-Ofman algorithm, 81
Kernel-Adatron algorithm, 317
Knapsack problem, 339
Knuth-Morris-Pratt algorithm, 359
Kronecker product, 128, 162
Kuhn-Tucker conditions, 315, 336
Lagrange function, 335, 336
Lagrange muliplier method, 119
Latitude, 344, 345
Lax-Wendroff method, 281
LDU-factorization, 123
Leap-frog method, 263
Learning rate, 211
Least-square method, 200

Index 419
Leverrier method, 131
Lie series technique, 265
Lindenmayer system, 379
Linear predictive coding, 106
Lipschitzian, 237
LISP, 188
Little Endian, 39
Logistic differential equation, 263
Longitude, 344, 345
Lorenz model, 272
LRU alorithm, 198
LZW-algorithm, 350
Machine epsilon, 14
Magic square, 91, 121
Maxwell's equations, 278
Maze, 163
Mealy machine, 169, 171
Mean value theorem of calculus,
288
Median, 61, 153
Method of the arithmetic geomet-
ric mean, 236
Metropolis algorithm, 259
Metropolis criterion, 257
Mexican hat wavelet, 285
Minterm, 38
Modified explicit Euler method,
264
Molecular dynamics simulations,
270
Monte Carlo method, 249
Moore machine, 169
Mother wavelet, 285
Multigraphs, 295
Multinomial theorem, 88
NAND-gate, 25
Newton-Raphson method, 205
Nucleic acid sequences, 100
One's complement, 23
Orthogonal matrix, 144
Pade approximant, 220
Pairing function, 76
Palindrome, 150
Parseval's equality, 241
Parseval's relation, 241
Partition of unity, 11
Perceptron learning algorithm, 305
Perfect numbers, 68
Permutations, 69
Poisson bracket, 265
Polygon, 382
Polynomial interpolation, 232
Power set, 90
Producer-consumer problem, 193
Protein sequence, 100
Public key encryption scheme, 75
Putzer algorithm, 142
Pyramid algorithm, 291
Queue, 193
Quicksort algorithm, 154
Random number, 243
Regular expression, 175
Romberg integration, 226
Rotation matrix, 107, 144
Runge-Kutta method, 264
Runge-Kutta-Fehlberg method, 271
Russian farmer multiplication, 32
Sarkovskii's theorem, 55
Scalar product, 345
Scaling, 107
Scaling function, 290
Secant method, 204
Shearing, 108
Shift register algorithm, 246
Shift-and-subtract method, 29
Shift-and-subtract principle, 28
Shortest path problem, 299
Simpson rule, 224
Singular value decomposition, 108
Sparse matrix, 126, 197
Spectral radius, 234
Spherical coordinates, 338, 345

420 Index
Spiral map, 79
Standard map, 4
Strassen's algorithm, 104
Stratonovich-Hubbard identity, 133
Subsets, 94
Sum of products, 38
Support vector machine, 313
Taylor expansions, 270
Taylor series, 3
Taylor series expansion, 63
Thue-Morse sequence, 378
Time-delayed logistic map, 4
Trace, 3, 115
Translation, 108
Trapezium rule, 223
Trapezoidal rule for integration,
250
Tridiagonal matrix, 136
Trigonometric identity, 2
Trigonometric interpolation, 230
Truth table, 25
Turing machine, 170
Two's complement, 23
Uncertainty principle, 286
Universal gate, 26
Van der Pol equation, 266
Vector product, 22
Verlet algorithm, 269
Vocabulary, 47
Voronoi cell, 399
Voronoi diagram, 399
Walsh transform, 45
Walsh-Hadamard transform, 162
Wave equation, 275
Wavelet transform, 285
Wavelets, 285
Zeckendorf arithmetic, 84
Zeckendorf representation, 83
Zeros, 321

