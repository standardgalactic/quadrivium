Lei Cheng
Zhongtao Chen
Yik-Chung Wu
Bayesian Tensor 
Decomposition 
for Signal 
Processing and 
Machine Learning
Modeling, Tuning-Free Algorithms, and 
Applications

Bayesian Tensor Decomposition for Signal
Processing and Machine Learning

Lei Cheng · Zhongtao Chen · Yik-Chung Wu
Bayesian Tensor
Decomposition for Signal
Processing and Machine
Learning
Modeling, Tuning-Free Algorithms,
and Applications

Lei Cheng
College of Information Science
and Electronic Engineering
Zhejiang University
Hangzhou, China
Yik-Chung Wu
Department of Electrical and Electronic
Engineering
The University of Hong Kong
Hong Kong, China
Zhongtao Chen
Department of Electrical and Electronic
Engineering
The University of Hong Kong
Hong Kong, China
ISBN 978-3-031-22437-9
ISBN 978-3-031-22438-6 (eBook)
https://doi.org/10.1007/978-3-031-22438-6
© The Editor(s) (if applicable) and The Author(s), under exclusive license to Springer Nature
Switzerland AG 2023
This work is subject to copyright. All rights are solely and exclusively licensed by the Publisher, whether
the whole or part of the material is concerned, speciﬁcally the rights of translation, reprinting, reuse
of illustrations, recitation, broadcasting, reproduction on microﬁlms or in any other physical way, and
transmission or information storage and retrieval, electronic adaptation, computer software, or by similar
or dissimilar methodology now known or hereafter developed.
The use of general descriptive names, registered names, trademarks, service marks, etc. in this publication
does not imply, even in the absence of a speciﬁc statement, that such names are exempt from the relevant
protective laws and regulations and therefore free for general use.
The publisher, the authors, and the editors are safe to assume that the advice and information in this book
are believed to be true and accurate at the date of publication. Neither the publisher nor the authors or
the editors give a warranty, expressed or implied, with respect to the material contained herein or for any
errors or omissions that may have been made. The publisher remains neutral with regard to jurisdictional
claims in published maps and institutional afﬁliations.
This Springer imprint is published by the registered company Springer Nature Switzerland AG
The registered company address is: Gewerbestrasse 11, 6330 Cham, Switzerland

Preface
Our world is full of data, and these data often appear in high-dimensional structures,
with each dimension describing a unique attribute. Examples include data in social
sciences, medicines, pharmacology, and environmental monitoring, just to name a
few. To make sense of the multi-dimensional data, advanced computational tools,
which directly work with tensor rather than ﬁrst converting a tensor to a matrix, are
needed to unveil the hidden patterns of the data. This is where tensor decomposi-
tion models come into play. Due to the remarkable representation capability, tensor
decomposition models have led to state-of-the-art performances in many domains,
including social network mining, image processing, array signal processing, and
wireless communications.
Previous research on tensor decompositions mainly approached from an optimiza-
tion perspective, which unfortunately does not come with the capability of tensor
rank learning and requires heavy hyper-parameter tuning. While these two tasks are
important in complexity control and avoiding overﬁtting, they are often overlooked
or downplayed in current research, and assumed can be achieved by trivial opera-
tions, or somehow can be obtained from other methods. In reality, estimating the
tensor rank and a proper set of hyper-parameters usually involve exhaustive search.
This requires running the same algorithm many times, effectively increasing the
computational complexity in actual model deployment.
Another path for model learning is Bayesian methods. They provide a natural
recipe for the integration of tensor rank learning, automatic hyper-parameter deter-
mination, and tensor decomposition. Due to this unique capability, Bayesian models
and inference trigger a recent interest in tensor decompositions for signal processing
and machine learning. From these recent works, Bayesian models show comparable
or even better performance than optimization-based counterparts.
However, Bayesian methods are very different from optimization methods, with
the former learning distributions of the unknown parameters, and the latter learning
a point estimate. The process of building the models and inference algorithm deriva-
tions are fundamentally different as well. This leads to a barrier between the two
groups of researchers working on similar problems but starting from different
v

vi
Preface
perspectives. This book aims to distill the essentials of Bayesian modeling and infer-
ence in tensor research, and present a uniﬁed view of various models. The book
addresses the needs of postgraduate students, researchers, and practicing engineers
whose interests lie in tensor signal processing and machine learning. It can be used
as a textbook for short courses on speciﬁc topics, e.g., tensor learning methods,
Bayesian learning, and multi-dimensional data analytics. Demo codes can be down-
loaded from https://github.com/leicheng-tensor/Reproducible-Bayesian-Tensor-Mat
rix-Machine-Learning-SOTA. It is our hope that by lowering the barrier to under-
standing and entering the Bayesian landscape, more ideas and novel algorithms can
be stimulated and facilitated in the research community.
This book starts by reviewing the basics and classical algorithms for tensor
decompositions, and then introduces their common challenge on rank determination
(Chap. 1). To overcome this challenge, this book develops models and algorithms
under the Bayesian sparsity-aware learning framework, with the philosophy and
key results elaborated in Chap. 2. In Chaps. 3 and 4, we use the most basic tensor
decomposition format, Canonical Polyadic Decomposition (CPD), as an example
to elucidate the fundamental Bayesian modeling and inference that can achieve
automatic rank determination and hyper-parameter learning. Both parametric and
non-parametric modeling and inference are introduced and analyzed. In Chap. 5,
we demonstrate how Bayesian CPD is connected with stochastic optimization in
order to ﬁt large-scale data. In Chap. 6, we show how the basic model can incorpo-
rate additional nonnegative structures to achieve enhanced performances in various
signal processing and machine learning tasks. Chapter 7 discusses the extension
of Bayesian methods to complex-valued data, handling orthogonal constraints and
outliers. Chapter 8 uses the direction-of-arrival estimation, which has been one of
the focuses of array signal processing for decades, as a case study to introduce the
Bayesian tensor decomposition under missing data. Finally, Chap. 9 extends the
modeling idea presented in previous chapters to other tensor decomposition formats,
including tensor Tucker decomposition, tensor-train decomposition, PARAFAC2
decomposition, and tensor SVD.
The authors sincerely thank the group members, Le Xu, Xueke Tong, and Yangge
Chen, at The University of Hong Kong for working on this topic together over the
years. This project is supported in part by the NSFC under Grant 62001309, and in
part by the General Research Fund from the Hong Kong Research Grant Council
under Grant 17207018.
Hangzhou, China
Hong Kong, China
Hong Kong, China
August 2022
Lei Cheng
Zhongtao Chen
Yik-Chung Wu

Contents
1
Tensor Decomposition: Basics, Algorithms, and Recent
Advances . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
1.1
Terminologies and Notations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
1.1.1
Scalar, Vector, Matrix, and Tensor . . . . . . . . . . . . . . . . . . . . . .
1
1.1.2
Tensor Unfolding/Matricization . . . . . . . . . . . . . . . . . . . . . . . .
2
1.1.3
Tensor Products and Norms . . . . . . . . . . . . . . . . . . . . . . . . . . .
2
1.2
Representation Learning via Tensors . . . . . . . . . . . . . . . . . . . . . . . . . .
5
1.2.1
Canonical Polyadic Decomposition (CPD) . . . . . . . . . . . . . . .
6
1.2.2
Tucker Decomposition (TuckerD) . . . . . . . . . . . . . . . . . . . . . .
7
1.2.3
Tensor Train Decomposition (TTD) . . . . . . . . . . . . . . . . . . . . .
8
1.3
Model Fitting and Challenges Ahead . . . . . . . . . . . . . . . . . . . . . . . . . .
9
1.3.1
Example: Tensor CPD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
10
1.3.2
Challenges in Rank Determination . . . . . . . . . . . . . . . . . . . . . .
13
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
13
2
Bayesian Learning for Sparsity-Aware Modeling . . . . . . . . . . . . . . . . . .
15
2.1
Bayes’ Theorem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
15
2.2
Bayesian Learning and Sparsity-Aware Learning . . . . . . . . . . . . . . . .
16
2.3
Prior Design for Sparsity-Aware Modeling . . . . . . . . . . . . . . . . . . . . .
17
2.4
Inference Algorithm Development . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19
2.5
Mean-Field Variational Inference . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
20
2.5.1
General Solution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
20
2.5.2
Tractability of MF-VI
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
21
2.5.3
Deﬁnition of MPCEF Model . . . . . . . . . . . . . . . . . . . . . . . . . . .
28
2.5.4
Optimal Variational Pdfs for MPCEF Model . . . . . . . . . . . . .
31
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
34
3
Bayesian Tensor CPD: Modeling and Inference . . . . . . . . . . . . . . . . . . .
35
3.1
A Uniﬁed Probabilistic Modeling Using GSM Prior . . . . . . . . . . . . .
35
3.2
PCPD-GG: Probabilistic Modeling . . . . . . . . . . . . . . . . . . . . . . . . . . . .
37
3.3
PCPD-GH: Probabilistic Modeling . . . . . . . . . . . . . . . . . . . . . . . . . . . .
39
3.4
PCPD-GH, PCPD-GG: Inference Algorithm
. . . . . . . . . . . . . . . . . . .
44
vii

viii
Contents
3.4.1
Optimal Variational Pdfs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
45
3.4.2
Setting the Hyper-parameters . . . . . . . . . . . . . . . . . . . . . . . . . .
47
3.5
Algorithm Summary and Insights . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
48
3.5.1
Convergence Property . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
48
3.5.2
Automatic Tensor Rank Learning . . . . . . . . . . . . . . . . . . . . . . .
48
3.5.3
Computational Complexity . . . . . . . . . . . . . . . . . . . . . . . . . . . .
50
3.5.4
Reducing to PCPD-GG . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
50
3.6
Non-parametric Modeling: PCPD-MGP . . . . . . . . . . . . . . . . . . . . . . .
51
3.7
PCPD-MGP: Inference Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . .
53
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
57
4
Bayesian Tensor CPD: Performance and Real-World
Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
59
4.1
Numerical Results on Synthetic Data . . . . . . . . . . . . . . . . . . . . . . . . . .
59
4.1.1
Simulation Setup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
59
4.1.2
PCPD-GH Versus PCPD-GG . . . . . . . . . . . . . . . . . . . . . . . . . .
60
4.1.3
Comparisons with Non-parametric PCPD-MGP . . . . . . . . . .
65
4.2
Real-World Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
69
4.2.1
Fluorescence Data Analytics . . . . . . . . . . . . . . . . . . . . . . . . . . .
69
4.2.2
Hyperspectral Images Denoising . . . . . . . . . . . . . . . . . . . . . . .
73
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
74
5
When Stochastic Optimization Meets VI: Scaling Bayesian
CPD to Massive Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
77
5.1
CPD Problem Reformulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
77
5.1.1
Probabilistic Model and Inference
for the Reformulated Problem
. . . . . . . . . . . . . . . . . . . . . . . . .
78
5.2
Interpreting VI Update from Natural Gradient Descent
Perspective . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
80
5.2.1
Optimal Variational Pdfs in Exponential Family Form . . . . .
81
5.2.2
VI Updates as Natural Gradient Descent . . . . . . . . . . . . . . . . .
83
5.3
Scalable VI Algorithm for Tensor CPD . . . . . . . . . . . . . . . . . . . . . . . .
86
5.3.1
Summary of Iterative Algorithm . . . . . . . . . . . . . . . . . . . . . . . .
87
5.3.2
Further Discussions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
87
5.4
Numerical Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
90
5.4.1
Convergence Performance on Synthetic Data . . . . . . . . . . . . .
90
5.4.2
Tensor Rank Estimation on Synthetic Data . . . . . . . . . . . . . . .
93
5.4.3
Video Background Modeling . . . . . . . . . . . . . . . . . . . . . . . . . .
97
5.4.4
Image Feature Extraction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
99
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
100
6
Bayesian Tensor CPD with Nonnegative Factors . . . . . . . . . . . . . . . . . . .
103
6.1
Tensor CPD with Nonnegative Factors . . . . . . . . . . . . . . . . . . . . . . . . .
103
6.1.1
Motivating Example—Social Group Clustering . . . . . . . . . . .
103
6.1.2
General Problem and Challenges . . . . . . . . . . . . . . . . . . . . . . .
105
6.2
Probabilistic Modeling for CPD with Nonnegative Factors . . . . . . . .
106

Contents
ix
6.2.1
Properties of Nonnegative Gaussian-Gamma Prior . . . . . . . .
106
6.2.2
Probabilistic Modeling of CPD with Nonnegative
Factors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
109
6.3
Inference Algorithm for Tensor CPD with Nonnegative
Factors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
110
6.3.1
Derivation for Variational Pdfs . . . . . . . . . . . . . . . . . . . . . . . . .
112
6.3.2
Summary of the Inference Algorithm . . . . . . . . . . . . . . . . . . .
114
6.3.3
Discussions and Insights . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
115
6.4
Algorithm Accelerations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
117
6.5
Numerical Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
122
6.5.1
Validation on Synthetic Data . . . . . . . . . . . . . . . . . . . . . . . . . . .
123
6.5.2
Fluorescence Data Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . .
127
6.5.3
ENRON E-mail Data Mining . . . . . . . . . . . . . . . . . . . . . . . . . .
129
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
133
7
Complex-Valued CPD, Orthogonality Constraint, and Beyond
Gaussian Noises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
135
7.1
Problem Formulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
135
7.2
Probabilistic Modeling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
136
7.3
Inference Algorithm Development . . . . . . . . . . . . . . . . . . . . . . . . . . . .
138
7.3.1
Derivation for Q((k)), 1 ≤k ≤P . . . . . . . . . . . . . . . . . . . . .
140
7.3.2
Derivation for Q

(k)
, P + 1 ≤k ≤N
. . . . . . . . . . . . . . . .
141
7.3.3
Derivation for Q(E) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
142
7.3.4
Derivations for Q(γl),Q

ζi1,...,iN

, and Q(β) . . . . . . . . . . . . .
143
7.3.5
Summary of the Iterative Algorithm . . . . . . . . . . . . . . . . . . . .
144
7.3.6
Further Discussions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
144
7.4
Simulation Results and Discussions . . . . . . . . . . . . . . . . . . . . . . . . . . .
146
7.4.1
Validation on Synthetic Data . . . . . . . . . . . . . . . . . . . . . . . . . . .
147
7.4.2
Blind Data Detection for DS-CDMA Systems . . . . . . . . . . . .
150
7.4.3
Linear Image Coding for a Collection of Images . . . . . . . . . .
151
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
154
8
Handling Missing Value: A Case Study in Direction-of-Arrival
Estimation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
155
8.1
Linking DOA Subspace Estimation to Tensor Completion . . . . . . . .
155
8.2
Probabilistic Modeling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
159
8.3
MPCEF Model Checking and Optimal Variational Pdfs
Derivations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
160
8.3.1
MPCEF Model Checking . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
160
8.3.2
Optimal Variational Pdfs Derivations
. . . . . . . . . . . . . . . . . . .
163
8.4
Algorithm Summary and Remarks . . . . . . . . . . . . . . . . . . . . . . . . . . . .
164
8.5
Simulation Results and Discussions . . . . . . . . . . . . . . . . . . . . . . . . . . .
165
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
167

x
Contents
9
From CPD to Other Tensor Decompositions . . . . . . . . . . . . . . . . . . . . . .
169
9.1
Tucker Decomposition (TuckerD) . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
169
9.2
Tensor Train Decomposition (TTD) . . . . . . . . . . . . . . . . . . . . . . . . . . .
171
9.3
PARAFAC2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
173
9.4
Tensor-SVD (T-SVD) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
178
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
182

Chapter 1
Tensor Decomposition: Basics,
Algorithms, and Recent Advances
Abstract In this chapter, we will ﬁrst introduce the preliminaries on tensors, includ-
ing terminologies and the associated notations, related multi-linear algebra, and more
importantly, widely used tensor decomposition formats. Then, we link the tensor
decompositions to the recent representation learning for multi-dimensional data,
showing the paramount role of tensors in modern signal processing and machine
learning. Finally, we review the recent algorithms for tensor decompositions, and
further analyze their common challenge in rank determination.
1.1
Terminologies and Notations
1.1.1
Scalar, Vector, Matrix, and Tensor
Plain letters (e.g., x) are used to denote scalars. The boldface lowercase (e.g., x)
and uppercase letters (e.g., X) are used for vectors and matrices, respectively. For
tensors, they are denoted by boldface calligraphic letters X.
In multi-linear algebra, the term order measures the number of indices used to
assess each data element (in scalar form). Speciﬁcally, vector x ∈RI is of order 1
since its element xi can be assessed via only one index. Matrix X ∈RI×J is of order 2,
becausetwoindicesareenoughtotraverseallofitselementsXi, j.Asageneralization,
tensors are of order three or higher. An Nth order tensor X ∈RI1×···×IN utilizes N
indices to address its elements Xi1,...,iN . For illustration, we depict scalar, vector,
matrix, and tensor in Fig.1.1.
For an Nth order tensor X, addressing each element requires N indices, and
each index corresponds to a mode, which is used to generalize the concepts of rows
and columns in matrices. For example, for a third-order tensor X ∈RI1×I2×I3, given
indices i2 and i3, the vectors X:,i2,i3 are termed as mode-1 ﬁbers.
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023
L. Cheng et al., Bayesian Tensor Decomposition for Signal Processing and
Machine Learning, https://doi.org/10.1007/978-3-031-22438-6_1
1

2
1
Tensor Decomposition: Basics, Algorithms, and Recent Advances
Fig. 1.1 Illustration of scalar, matrix, and tensor
1.1.2
Tensor Unfolding/Matricization
Tensor unfolding/matricization aims to re-organize the ﬁbers in one mode into a
matrix. For an Nth order tensor X ∈RI1×···×IN , since it has N modes, there are N
types of unfolding, each termed as mode-n unfolding. We formally deﬁne it as follows
and illustrate it in Fig.1.2.
Deﬁnition 1.1 (Mode-n Unfolding) Given a tensor X ∈RI1×···×IN , its
mode-n unfolding gives a matrix X(n) ∈RIn×N
k=1,k̸=n Ik. Each tensor element
Xi1,...,iN is mapped to the matrix element X(n)
in, j with j = i1 + (i2 −1)I1 +
· · · + (in−1 −1)I1 · · · In−2+(in+1 −1)I1 · · · In + · · · + (iN −1) I1 · · · IN−1.
Tensor unfolding/matricization is one of the most important operators in tensor-
based data analytics, since it gives a “matrix” view to describe an Nth order tensor
data, such that fruitful results in linear algebra can be utilized. As will be seen in
the later sections, most tensor algorithms involve basic operations on the matrices
provided by “unfolding/matricization”, and the special tensor/matrix products intro-
duced in the following subsection.
1.1.3
Tensor Products and Norms
Tensor decompositions and products are essentially built on matrix products. We
introduce the most widely used ones in this subsection. For a full list of matrix/tensor
products, readers can refer to [1]. All the tensor operations in this subsection have
been implemented in Matlab tensor toolbox [2].

1.1 Terminologies and Notations
3
Fig. 1.2 Illustration of tensor unfolding/matricization for different modes
Deﬁnition 1.2 (Kronecker Product) Given two matrices A ∈RI1×I2 and
B ∈RJ1×J2, their Kronecker product is deﬁned as
A ⊙B =
⎡
⎢⎣
a11B · · · a1I2B
...
...
...
aI11B · · · aI1 I2B
⎤
⎥⎦
	



≜C
∈RI1 J1×I2 J2.
(1.1)
As seen in (1.1), the Kronecker product between A and B results in a matrix
C with enlarged dimensions. From another angle, the Kronecker product provides
an effective way to represent a large matrix C (if it satisﬁes (1.1)) by two smaller
matrices {A, B}. This product will be useful for tensor Tucker decompositions, as
will be elaborated in later sections.
Next, using the Kronecker product, we deﬁne another important matrix product.
Deﬁnition 1.3 (Khatri–Rao Product) Given two matrices A ∈RI×R and
B ∈RJ×R, their Khatri–Rao product is deﬁned as:
A ⋄B =
A:,1 ⊙B:,1, A:,2 ⊙B:,2, . . ., A:,R ⊙B:,R

∈RI J×R.
(1.2)

4
1
Tensor Decomposition: Basics, Algorithms, and Recent Advances
Fig. 1.3 Illustration of 1-mode product
From (1.2), it is easy to see that the Khatri–Rao product performs the column-wise
Kronecker product between two matrices {A, B}. The Khatri–Rao product is one of
the most critical operators in tensor canonical polyadic decomposition, which will
be elucidated in later sections.
The Hadamard product, which performs element-wise product between two matri-
ces {A, B}, is deﬁned as follows.
Deﬁnition 1.4 (Hadamard Product) Given two matrices A ∈RI1×I2 and
B ∈RI1×I2, their Hadamard product is:
A ⊛B =
⎡
⎢⎣
a11b11 · · · a1I2b1I2
...
...
...
aI11bI11 · · · aI1 I2bI1 I2
⎤
⎥⎦∈RI1×I2.
(1.3)
Then we deﬁne several tensor products.
Deﬁnition 1.5 (n-mode Product) The n-mode product between a ten-
sor X ∈RI1×···×IN and a matrix M ∈RR×In results in a tensor (X ×n M)
∈RI1×···×In−1×R×In+1×···×IN , with each element being:
(X ×n M)i1,...,in−1,r,in+1,...,iN =
In

in=1
Mr,inXi1,...,iN .
(1.4)
An illustration of 1-mode product between a 3D tensor X and a matrix M is
given in Fig.1.3. Furthermore, the n-mode product can also be expressed as a matrix
product in terms of the mode-n unfolding,
(X ×n M)(n) = M × X(n).
(1.5)

1.2 Representation Learning via Tensors
5
If the tensor X ∈RI1×I2 is a matrix (or a 2D tensor), its 1-mode product with M
reduces to a matrix product, i.e., X ×1 M = M × X, where M ∈RR×I1. Similarly,
X ×2 M = X × MT , where X ∈RI1×I2, M ∈RR×I2. Another generalization from
vector/matrix algebra is the generalized inner product.
Deﬁnition 1.6 (Generalized Inner Product) For a tensor X ∈RI1×···×IN and
a tensor Y ∈RI1×···×IN , their generalized inner product is deﬁned as:
< X, Y >=
I1

i1=1
I2

i2=1
· · ·
IN

in=1
Xi1,...,inYi1,...,in.
(1.6)
In data analytic tasks, the lp norm, which was deﬁned for vectors and matrices,
frequently appears in the designs of cost functions and regularizations. For tensors,
we can generalize its deﬁnition as follows.
Deﬁnition 1.7 (lp tensor norm) For a tensor X ∈RI1×···×IN , its lp norm is:
||X||p =
⎛
⎝
i1,...,iN
|Xi1,...,iN |p
⎞
⎠
1/p
.
(1.7)
For p = 0, the l0 norm ||X||0 gives the number of non-zero elements (strictly
speaking l0 does not satisfy the usual norm properties), and thus acts as a measure
of sparsity. As its tightest convex surrogate, the l1 norm ||X||1 computes the sum
of absolute values of tensor X, and also can be treated as a convenient measure of
sparsity. The most widely used one is the l2 norm ||X||2, which is also called the
Frobenius norm and denoted by ||X||F.
1.2
Representation Learning via Tensors
Multi-dimensional data from various applications can be naturally represented as
tensors. To understand these data, representation learning aims at extracting low-
dimensional yet informative parameters (in terms of smaller tensors, matrices, and
vectors) fromthetensor data. It is hopedthat theextractedparameters canpreservethe
structures endowed by the physical phenomenon and reveal hidden interpretations.
To achieve this goal, tensor decompositions with various structural constraints are
developed, as illustrated in Fig.1.4. In the following subsections, we introduce three
widely used tensor decomposition formats with increasing complexity in modeling,
namely canonical polyadic decomposition (CPD), Tucker decomposition (TuckerD),
and tensor train decomposition (TTD).

6
1
Tensor Decomposition: Basics, Algorithms, and Recent Advances
Fig. 1.4 Illustration of representation learning via tensors
1.2.1
Canonical Polyadic Decomposition (CPD)
As illustrated in Fig.1.5, the CPD, also known as PARAFAC [3], decomposes tensor
data X ∈RI1×···×IN into a summation of R rank-1 tensors [3]:
X =
R

r=1
u(1)
r
◦· · · ◦u(N)
r
	



rank-1 tensor
,
(1.8)
where ◦denotes the vector outer product. Equation(1.8) states that the tensor X
consists of R rank-1 component tensors. If we put the vectors u(n)
1 , . . ., u(n)
R into a
factor matrices U(n) ∈RIn×R deﬁned as:
U(n) =

u(n)
1 , . . . , u(n)
R

,
(1.9)
Equation(1.8) can be expressed as another equivalent form X = R
r=1 U(1)
:,r ◦· · · ◦
U(N)
:,r := U(1), . . . , U(N), where · · · is known as the Kruskal operator. Notice
that the minimum number R that makes (1.8) hold is termed as tensor rank, which
generalizes the notion of matrix rank to high-order tensors.
Tensor CPD has been found in various data analytic tasks due to its appealing
uniqueness property. Here, we present one of the most widely used sufﬁcient condi-
tions for CPD uniqueness. For other conditions that take additional structures (e.g.,
nonnegativity, orthogonality) into account, interested readers can refer to [1, 3].

1.2 Representation Learning via Tensors
7
Fig. 1.5 Illustration of a CPD for a third-order tensor
Property
1.1
(Uniqueness
condition
for
CPD
[1])
Suppose
U(1), U(2), . . ., U(N) = (1), (2), . . ., (N), and N
n=1 kn ≥2R+(N −1),
where ki denotes the k-rank of matrix U(i) and R is the tensor rank. Then
the following equations hold: (1) = U(1)(1), (2) = U(2)(2), …,
(N) = U(N)(N) where  is a permutation matrix and the diagonal
matrix (n) satisﬁes N
n=1 (n) = IR.
In Property 1.1, the k-rank of matrix A is deﬁned as the maximum value k such
that any k columns are linearly independent [1]. Property 1.1 states that under mild
conditions, tensor CPD is unique up to trivial scaling and permutation ambiguities.
This is one of the major differences between tensor CPD and low-rank matrix decom-
position, which is, in general, not unique unless some constraints are imposed. This
nice property has made CPD an important tool in the blind source separation and
data clustering-related tasks, as will be demonstrated in the following chapters.
1.2.2
Tucker Decomposition (TuckerD)
The CPD disregards interactions among the columns of factor matrices and requires
the factor matrices to have the same number of columns. To achieve a more ﬂex-
ible tensor representation, tensor TuckerD was introduced to generalize CPD by
allowing different column numbers of factor matrices and introducing a core tensor
G ∈RR1×···×RN . Particularly, tensor TuckerD is deﬁned as [1, 4]:
X = G ×1 U(1) ×2 U(2) ×3 · · · ×N U(N),
(1.10)

8
1
Tensor Decomposition: Basics, Algorithms, and Recent Advances
Fig. 1.6 Illustration of a TuckerD for a third-order tensor
where each factor matrix U(n) ∈RIn×Rn, ∀n. The tuple (R1, . . . , RN) is known as
multi-linear rank. An illustration of TuckerD is provided in Fig.1.6. Note that when
the core tensor G is super-diagonal and R1 = · · · = RN, TuckerD reduces to CPD.
Using the Kruskal operator, Tucker D can be compactly denoted by:
X = G; U(1), . . . , U(N).
(1.11)
Although TuckerD provides ﬂexibilities for data representation, it is not unique
in general [1, 4]. Therefore, it is frequently used in the data compression, basis
function learning, and feature extraction-related tasks, where uniqueness is not the
most important consideration.
1.2.3
Tensor Train Decomposition (TTD)
The TTD decomposes tensor data X ∈RI1×···×IN into a set of core tensors {G(n) ∈
RRn×In×Rn+1} such that [5]
Xi1,...,iN = G(1)
:,i1,: × · · · × G(N)
:,iN ,:.
(1.12)
In (1.12), each core tensor slice G(n)
:,in,: ∈RRn×Rn+1. Since each Xi1,...,iN is a scalar, R1
and RN+1 are both required to be 1. The tuple (R1, . . . , RN+1) is termed as TT-rank.
In quantum physics, TTD is known as a matrix-product state [5]. The TTD for a
third-order tensor is illustrated in Fig.1.7.
Due to its ﬂexibility, TTD with appropriately chosen TT-rank has shown supe-
rior performance in a variety of data analytic tasks, including image completion,
classiﬁcation, and neural network compression.

1.3 Model Fitting and Challenges Ahead
9
Fig. 1.7 Illustration of a TTD for a third-order tensor
1.3
Model Fitting and Challenges Ahead
Given the tensor decomposition models introduced in the last section, the next task
is to estimate the model parameters and hyper-parameters from the observed ten-
sor data. One straightforward approach is to formulate the learning problem as an
optimization problem (see Fig.1.8). Speciﬁcally, in different application contexts,
cost functions can be designed to encode our knowledge of the tensor data and the
tensor model. Constraints on model parameters can be further added to embed the
side information. The problem formulation generally appears in the form:
Fig. 1.8 Tensor-based representation learning from an optimization perspective

10
1
Tensor Decomposition: Basics, Algorithms, and Recent Advances
min
,η c(Y; , η)
s.t. gi() = 0, i = 1, . . . , I,
f j() ≥0, j = 1, . . . , J,
(1.13)
where c(·) is the cost function, e.g., least-squares function; g(·) denotes the function
for equality constraints; and f (·) is the function for inequality constraints. Y ∈
RI1×···×IN is the observed tensor data.  includes all the model parameters, e.g.,
factor matrices of CPD, and η denotes the hyper-parameters, e.g., tensor rank or
regularization parameters.
In the following, we ﬁrst provide a concrete example for the tensor CPD format,
and then discuss the optimizations for tensor TuckerD and TTD.
1.3.1
Example: Tensor CPD
For the tensor CPD, as deﬁned in Sect.1.2.1, the model parameters  = {U(n) ∈
RIn×R}N
n=1 and the hyper-parameter η is the tensor rank R. Adopting the least-squares
cost function, the problem can be formulated as
min
{U(n)∈RIn×R}N
n=1,R ||Y −U(1), . . . , U(N)||2
F.
(1.14)
Inproblem (1.14),optimizing R,whichisaninteger,isknowntobenon-deterministic
polynomial-time hard (NP-hard) [6]. Trial-and-errors or cross-validations are widely
used in practice to tune this hyper-parameter for the best data interpretation. Even
given a tensor rank R, the optimization of {U(n) ∈RIn×R} is still a non-convex prob-
lem. To tackle the non-convexity, alternating optimization is commonly used. Par-
ticularly, after ﬁxing factor matrices other than U(k), the problem can be equivalently
formulated as
min
U(k) ||Y(k) −U(k)

N⋄
n=1,n̸=k U(n)
T
||2
F,
(1.15)
where
N⋄
n=1,n̸=k U(n) = U(N) ⋄· · · ⋄U(k+1) ⋄U(k−1) ⋄· · · ⋄U(1), and ⋄stands for the
Khatri–Rao product introduced in Deﬁnition 1.3. Problem (1.15) is a convex problem
with respect to variable U(k). After taking the gradient and then letting it to be zero,
it is easy to obtain:
ˆU(k) = Y(k)

N⋄
n=1,n̸=k U(n)
T †
,
(1.16)

1.3 Model Fitting and Challenges Ahead
11
Algorithm 1 CPD-ALS(Y, R)
Initializations: initialize U(n,0) ∈RIn×R, for n = 1, . . . , N.
Iterations: for the tth iteration (t ≥0),
for the kth factor matrix U(k,0), k = 1, . . . , N,
U(k, t+1) = Y(k)

N⋄
n=1, n̸=k U(n,s)
T 
N⊛
n=1,n̸=k U(n,s)T U(n,s)
†
,
where s = t + 1 when s ≤k, and otherwise s = t.
Until Convergence
where † denotes the Moore–Penrose pseudo inverse. Due to the property of the
Khatri–Rao product, Eq.(1.16) can be simpliﬁed as:
ˆU(k) = Y(k)

N⋄
n=1,n̸=k U(n)
T 
N⊛
n=1,n̸=k U(n)T U(n)
†
.
(1.17)
Using (1.17), we only need to compute the pseudo inverse of a small matrix with
size R × R, rather than a large matrix with size 
n̸=k In × R in (1.16).
By alternatively updating factor matrix U(k), ∀k, using (1.17) until convergence,
we arrive at the workhorse algorithm for a given R: alternating least-squares (ALS)
method [7], which is summarized in Algorithm 1.
The alternating optimization framework still applies even if additional structural
constraints are imposed on the factor matrices. For example, if nonnegativeness or
orthogonality constraints are added, the subproblem (1.15) becomes:
min
U(k)
Y(k) −U(k)

N⋄
n=1,n̸=k U(n)
T 
2
F
,
s.t. U(k) ≥0 (non-negativeness);
or s.t. U(k)T U(k) = IR (orthogonality).
(1.18)
As long as each subproblem (1.18) can be solved, CPD with additional structures can
be learned. Recent advances in large-scale non-convex optimizations have tackled
problems in the form of (1.18) [8, 9].
1.3.1.1
Optimizations for Tensor TuckerD and TTD
Following the general problem formulation (1.13), the learning problem of tensor
TuckerD is usually given as

12
1
Tensor Decomposition: Basics, Algorithms, and Recent Advances
Algorithm 2 TuckerD-HOOI(Y, {Rn}N
n=1)
Initializations: initialize U(n,0) ∈RIn×Rn, for n = 1, . . . , N.
Iterations: for the tth iteration (t ≥0),
for the kth factor matrix U(k,0), k = 1, . . . , N,
Ct
(k) = Y(k) 
U(N, t−1) ⊙· · · ⊙U(k+1, t−1) ⊙U(k−1, t) ⊙· · · ⊙U(1, t)
.
(1.20)
U(k, t) ←Rk leading left singular vectors of Ct
(k).
Until Convergence
Algorithm 3 TT-SVD(Y, ϵ)
Initializations: compute truncation parameter δ =
ϵ
√N−1 ∥Y∥F. Set C = Y, R0 = 1.
For n = 1 to N −1
C = reshape

C,

Rn−1In,
N
n=1 In
Rn−1In

.
Compute δ-truncated SVD: C = USV + E, ∥E∥≤ϵ, Rn = rankδ(C).
G(n) = reshape
 
U,

Rn−1, Ik, Rn
!
.
C = SVT .
End
G(N) = C, RN = 1.
Return {G(n)}N
n=1, {Rn}N
n=1.
min
G,{U(n)}N
n=1,{Rn}N
n=1
∥Y −G; U(1), . . . , U(N) ∥F
s.t. U(n)T U(n) = IRn,
(1.19)
where the orthogonal constraint is imposed on each factor matrix. Once again, we can
use the ALS approach to solve problem (1.19). That is, in each iteration, we optimize
one factor matrix (or core tensor) at a time while ﬁxing other unknown parameters to
the most recent updated values. The resulting algorithm, also known as higher order
orthogonal iteration (HOOI), is summarized in Algorithm 2. Interested readers can
ﬁnd the detailed derivation and convergence analysis in [10].
Similarly, for the TTD format, the learning problem becomes:
min
{G(n)}N
n=1,{Rn}N
n=1
∥Y −X({G(n)}N
n=1) ∥F,
(1.21)
where X({G(n)}N
n=1) is a TT-format tensor following (1.12). TT-SVD, which iter-
atively optimizes the TT cores by truncated SVDs, can yield TT cores {G(n)}N
n=1
such that
Y −X({G(n)}N
n=1)

F ≤ϵ ∥Y∥F, where ϵ is the prescribed accuracy. The
TT-SVD algorithm is summarized as Algorithm 3 [5].

References
13
1.3.2
Challenges in Rank Determination
From Algorithms 1, 2 and 3, it can be seen that in addition to the tensor data
Y, a number of hyper-parameters are required to be set, including tensor rank R in
Algorithm 1, multi-linear rank {Rn}N
n=1 in Algorithm 2, and the prescribed accuracy
ϵ in Algorithm 3. Notice that in Algorithm 3, the prescribed accuracy ϵ determines
TT-rank {Rn}N
n=1. Setting these ranks to large values would lead to overﬁtting, while
setting them too small would lead to inﬂexibility of the modeling abilities. Manually
tuning these hyper-parameters is computationally costly. In many previous works
(e.g., [8]), research effort has been put into designing fast algorithms for each tensor
decomposition format. Although the reduction of running time for various tensor
decomposition formats has been witnessed, executing the algorithm numerous times
(for different combinations of hyper-parameters) is still inevitable in order to select
the best hyper-parameters. Compared to CPD, which has only a single number as
the rank, the rank determination issue for TuckerD and TTD is much more challeng-
ing, since they have more than one hyper-parameter. Exhaustively testing different
combinations of hyper-parameter values would result in a prohibitive computation
burden. This challenge raises an immediate question: Could the hyper-parameters
automatically be learned from the training data along with the factor matrices/core
tensors by running an algorithm only one time?
This thought seems arduous since it is known that the optimization of tensor rank
is NP-hard. However, recent advances in Bayesian modeling and inference [11] have
provided viable solutions, see, e.g., [12–18], each with a comparable computational
complexity to the optimization-based methods [8] with ﬁxed ranks. Their common
idea is to ﬁrst assume an over-parameterized model by letting the associated hyper-
parameters take large values. It then leverages the Bayesian sparsity-aware modeling
and Occam’s razor principle to prune out redundant parameters [11]. Consequently,
in addition to the posterior distributions of unknown factor matrices/core tensors,
which provide additional uncertainty information compared to the optimization-
based counterparts, the Bayesian learning process also unveils the most suitable
values of hyper-parameters that can avoid overﬁtting and further improve the model
interpretability. This book aims to give a uniﬁed view and insight into recent Bayesian
tensor decompositions.
References
1. T.G. Kolda, B.W. Bader, Tensor decompositions and applications. SIAM Rev. 51(3), 455–500
(2009)
2. B.W. Bader, T.G. Kolda, et al., Matlab tensor toolbox version 3.1 (2019)
3. J.H.d.M. Goulart, M. Boizard, R. Boyer, G. Favier, P. Comon, Tensor cp decomposition with
structuredfactormatrices:algorithmsandperformance.IEEEJ.SelectedTopicsSignalProcess.
10(4), 757–769 (2015)
4. V. Bhatt, S. Kumar, S. Saini, Tucker decomposition and applications. Mater. Today: Proc.
(2021)

14
1
Tensor Decomposition: Basics, Algorithms, and Recent Advances
5. I.V. Oseledets, Tensor-train decomposition. SIAM J. Sci. Comput. 33(5), 2295–2317 (2011)
6. H. Johan, Tensor rank is np-complete. J. Algor. 4(11), 644–654 (1990)
7. J.D. Carroll, J.-J. Chang, Analysis of individual differences in multidimensional scaling via an
n-way generalization of “eckart-young” decomposition. Psychometrika 35(3), 283–319 (1970)
8. X. Fu, N. Vervliet, L. De Lathauwer, K. Huang, N. Gillis, Computing large-scale matrix and
tensor decomposition with structured factors: a uniﬁed nonconvex optimization perspective.
IEEE Signal Process. Mag. 37(5), 78–94 (2020)
9. B. Yang, A.S. Zamzam, N.D. Sidiropoulos, Large scale tensor factorization via parallel
sketches. IEEE Trans. Knowl. Data Eng. (2020)
10. C.A. Andersson, R. Bro, Improving the speed of multi-way algorithms: part i. tucker3.
Chemom. Intell. Lab. Syst. 42(1–2), 93–103 (1998)
11. S. Theodoridis, Machine Learning: a Bayesian and Optimization Perspective, 2nd edn. (Aca-
demic, Cambridge, 2020)
12. L. Cheng, X. Tong, S. Wang, Y.-C. Wu, H.V. Poor, Learning nonnegative factors from tensor
data: probabilistic modeling and inference algorithm. IEEE Trans. Signal Process. 68, 1792–
1806 (2020)
13. L. Xu, L. Cheng, N. Wong, Y.-C. Wu, Overﬁtting avoidance in tensor train factorization and
completion: prior analysis and inference, in International Conference on Data Mining (ICDM)
(2021)
14. L. Cheng, Y.-C. Wu, H.V. Poor, Scaling probabilistic tensor canonical polyadic decomposition
to massive data. IEEE Trans. Signal Process. 66(21), 5534–5548 (2018)
15. L. Cheng, Y.-C. Wu, H.V. Poor, Probabilistic tensor canonical polyadic decomposition with
orthogonal factors. IEEE Trans. Signal Process. 65(3), 663–676 (2016)
16. Y. Zhou, Y.-M. Cheung, Bayesian low-tubal-rank robust tensor factorization with multi-rank
determination. IEEE Trans. Pattern Anal. Mach. Intell. 62–76 (2019)
17. Z. Zhang, C. Hawkins, Variational bayesian inference for robust streaming tensor factorization
and completion, in Proceeding of the IEEE International Conference on Data Mining (ICDM)
(2018), pp. 1446–1451
18. Q. Zhao, L. Zhang, A. Cichocki, Bayesian CP factorization of incomplete tensors with auto-
matic rank determination. IEEE Trans. Pattern Anal. Mach. Intell. 37(9), 1751–1763 (2015)

Chapter 2
Bayesian Learning for Sparsity-Aware
Modeling
Abstract In this chapter, we will ﬁrst introduce the Bayesian philosophy, under
which the two essential merits, namely uncertainty quantiﬁcation and model selec-
tion, are highlighted. These merits shed light on the design of sparsity-promoting
prior for automating the model pruning in recent machine learning models, includ-
ing deep neural networks, Gaussian processes, and tensor decompositions. Then,
we introduce the variational inference framework for algorithm development and
discuss its tractability in different Bayesian models.
2.1
Bayes’ Theorem
Bayes’ theorem is the ﬁrst profound triumph of statistical inference [1], since it ele-
gantly establishes a framework for combining prior experience with the data obser-
vations.
In a typical inverse problem [2], for a given dataset D, we hope to extract the
knowledge from D via a machine learning model parameterized by a vector θ.
In the Bayesian framework, a prior distribution p(θ|ξp) is assumed for the model
parameters θ, encoding our belief before observing the data, where ξp denotes an
unknown yet deterministic hyper-parameter vector of the prior distribution. After
collecting the data D, the likelihood function p(D|θ, ξl), where ξl is the hyper-
parameters, is used to model the forward problem. While p(D|θ, ξl) links the data
and the model, our ultimate task is to learn the parameters θ from data D, which
is encoded in the posterior distribution p(θ|D, ξl, ξp). Bayes’ theorem rigorously
formulates such a process [1]:
p(θ|D, ξ) =
p(D|θ, ξl)p(θ|ξp)

p(D|θ, ξl)p(θ|ξp)dθ ,
(2.1)
where ξ includes both the hyper-parameters contained in prior (i.e., ξp), and hyper-
parameters of the likelihood function ξl (e.g., the noise power in the dataset D).
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023
L. Cheng et al., Bayesian Tensor Decomposition for Signal Processing and
Machine Learning, https://doi.org/10.1007/978-3-031-22438-6_2
15

16
2
Bayesian Learning for Sparsity-Aware Modeling
Bayes’ theorem stated in (2.1) reveals how to link the inverse problem (posterior
distribution p(θ|D, ξ)) to the forward problem (likelihood function p(D|θ, ξl)) via
incorporating the prior p(θ|ξp). As the likelihood is usually easy to obtain from the
task objective or the measurement process, the most critical step lies in seeking a
suitable prior, which will be covered in the next section.
The denominator of (2.1), which can be expressed as p(D|ξ), plays an important
role. This term is known as “model evidence” since it measures the “ﬁtness” of data D
given the model hyper-parameters ξ, which is crucial for model selection. Concretely,
rather than manually tuning those hyper-parameters on a separated validation dataset,
we can learn their optimal values directly from the training dataset by solving the
following problem:
max
ξ
log p(D|ξ).
(2.2)
This problem is known as the model evidence maximization problem [2].
Bayes’ theorem returns the posterior distribution of model parameters, p(θ|D, ξ).
Unlike the discriminative approach (or cost function optimization approach), a dis-
tribution (rather than a single point estimate) of the model parameter is obtained,
thus conveying much richer information for the downstream process of unseen data
[2]. One of the most important pieces of information possessed is the uncertainty of
model parameters, which shows the extent of our belief in the learned model. This
information is invaluable for many mission-critical applications like auto-driving [3]
and medical diagnosis [4].
2.2
Bayesian Learning and Sparsity-Aware Learning
Bayesian learning is a class of machine learning methods that rely on Bayes’ theo-
rem [2, 5]. Following the principle of Bayes’ theorem introduced in the last section,
Bayesian learning involves two crucial stages: (1) prior design for the model param-
eters [6]; and (2) the inference algorithm development that learns both the posterior
distribution and the hyper-parameter values from the training (or observed) data.
In this monograph, we focus on sparsity-aware learning (SAL), which aims at
leveraging the explicit or implicit sparsity pattern of data to enhance the under-
standing of data [7, 8]. The history of SAL dates back to the early 1970s when
estimating the reﬂected signals from seismic measurements [6]. At that time, the
notion of “sparsity”, which means that the signal to be estimated only has a few ele-
ments being non-zero, was exploited to enhance the signal estimation performance.
After the 2000s, driven by the bloom of compressive sensing, SAL has become a
focus of signal processing and machine learning research, giving rise to many strong
theoretical results and successful algorithms in various domains [7, 8].
There is a common misunderstanding of “sparsity” that ﬂoats around newcomers
of signal processing and machine learning: “sparsity” is oftentimes superﬁcially

2.3 Prior Design for Sparsity-Aware Modeling
17
understood as nulling the values of parameters. However, if the model parameters
areuniformlyshrunktobeall-zeros,themachinelearningmodelcollapsesandcannot
learn interpretable results on the data. Consequently, in addition to favoring small
values, the “sparsity” notion also promotes a few large values of model parameters.
These few but signiﬁcant model parameters (learned via SAL) distill the essential
information from data, thus effectively avoiding overﬁtting and delivering enhanced
interpretability. More discussions can be found in [2].
With SAL being a desirable property, the next question is: how do we properly
design the prior distribution to encode the sparsity structure? Answering this question
is the ﬁrst step toward the Bayesian SAL, which has recently enabled automatic
model structure pruning in deep learning [9], Gaussian processes [10], and tensor
decompositions [11]. We elaborate on its design next.
2.3
Prior Design for Sparsity-Aware Modeling
There are two main streams for modeling sparsity in recent Bayesian studies,
namely the parametric and non-parametric ways. Here, we introduce the paramet-
ric prior modeling relying on the heavy-tailed distributions. Interested readers on
non-parametric modeling could refer to [2].
To see why the heavy-tailed distributions successfully model the sparsity, we
present the Laplacian distribution and Gaussian distribution for θ ∈R2 in Fig.2.1. It
can be seen that the Laplacian distribution is heavy-tailed compared to the Gaussian
Fig. 2.1 Joint probability distribution of the model parameters in 2D space. Subﬁgure a shows the
Laplacian distribution and subﬁgure b shows the Gaussian distribution. The heavy-tailed Laplacian
distribution peaks sharply around zero and falls slowly along the axes, thus promoting sparse
solutions in a probabilistic manner. On the contrary, the Gaussian distribution decays more rapidly
along both dimensions than the Laplacian distribution

18
2
Bayesian Learning for Sparsity-Aware Modeling
distribution. In other words, for Gaussian distributed parameters, the probability that
they take non-zero values goes to zero very fast, and most of the probability mass
concentrates around zero. This is not ideal for sparsity modeling since we want most
of the values to be (close to) zero, but still, some of the parameters have large values.
In contrast, observe that for the Laplacian distributed parameters, although most of
the probability mass is close to zero, there is still a high enough probability for non-
zero values. More importantly, this probability mass is concentrated along the axes,
where one of the parameters is zero. This is how Laplacian prior promotes sparsity.
In statistics, Laplacian is not the only distribution having heavy tails. In the
sequel, we introduce an important Gaussian scale mixture (GSM) family which
has heavy tails and thus can be used as sparsity-promoting priors. For a vector
θ = [θ1, . . . , θL], the main idea of the GSM prior is to assume that (a) the param-
eters, θl, l = 1, 2, . . . , L, are mutually statistically independent; (b) each one of
them follows a Gaussian prior with zero mean; and (c) the respective variances,
ζl, l = 1, 2, . . . , L, are also random variables, each one following a prior p(ζl|ξp),
where ξp is a set of tuning hyper-parameters associated with the prior. Thus, the
GSM prior for each θl is expressed as
p(θl|ξp) =

N(θl|0, ζl)p(ζl|ξp)dζl.
(2.3)
By varying the functional forms of p(ζl|ξp), the marginalization performed in (2.3)
induces different prior distributions on θl. For example, if p(ζl|ξp) is an inverse
Gamma distribution, (2.3) induces a Student’s t distribution [12]; if p(ζl|ξp) is
a Gamma distribution, (2.3) induces a Laplacian distribution [12]. Table2.2 sum-
marizes different heavy-tailed distributions in the GSM family, including Normal-
Jefferys, generalized hyperbolic, and horseshoe distributions, among others. To illus-
trate the sparsity-promoting property of the GSM family, in addition to the Laplacian
distribution shown in Fig.2.1, we depict two more representative GSM prior distri-
butions, namely the Student’s t distribution and the horseshoe distribution, in Fig.2.2
(Table2.1).
Table 2.1 Examples of GSM prior. Abbreviations: Ga = Gamma, IG = inverse Gamma, GIG =
generalized inverse Gaussian, C+ = Half Cauchy
GSM prior p(θl|ξp)
Mixing distribution p(ζl|ξp)
Student’s t
Inverse Gamma: p(ζl|ξp = {a, b}) = IG(ζl|a, b)
Normal-Jefferys
Log-uniform: p(ζl|ξp = { }) ∝
1
|ζl|
Laplacian
Gamma: p(ζl|ξp = {a, b}) = gamma(ζl|a, b)
Generalized hyperbolic
Generalized inverse Gaussian:
p(ζl|ξp = {a, b, λ}) = GIG(ζl|a, b, λ)
Horseshoe
ζl = τlυl, ξp = {a, b}
Half Cauchy: p(τl) = C+(0, a)
p(υl) = C+(0, b)

2.4 Inference Algorithm Development
19
Fig. 2.2 Representative GSM prior distributions in 2D space. Subﬁgures a and b show the Student’s
t distribution and the horseshoe distribution, respectively. It can be seen that these two distributions
show different heavy-tailed proﬁles but are both sparsity-promoting
Table 2.2 Examples of exponential family distributions
Exponential family distribution Natural parameter
Sufﬁcient statistic
Univariate Gaussian
distribution N(x|μ, σ)

μ
σ 2 ; −1
2σ 2


x; x2
Multivariate Gaussian
distribution N(x|μ, )

−1μ; −1
2vec(−1)


x; vec(xxT )

Gamma distribution
gamma(x|a, b)

−b; a −1


x; log x

2.4
Inference Algorithm Development
Given a signal processing or machine learning task with the associated likelihood
function p(D|θ, ξl) and a sparsity-promoting prior p(θ|ξp), the goal of Bayesian
SAL is to infer the posterior distribution p(θ|D, ξ) and to obtain the model hyper-
parameters ξ by maximizing the evidence p(D|ξ).
In most cases, the multiple integrations required in computing the evidence are
analytically intractable. Inspired by the ideas of the Minorize-Maximization (also
called Majorization-minimization (MM)) optimization framework, we can seek for
a tractable lower bound that minorizes the evidence function (see discussion around
(2.2)),andmaximizethelowerbounditerativelyuntilconvergence.Ithasbeenshown,
see, e.g., [2], that such an optimization process can obtain a stationary point of the

20
2
Bayesian Learning for Sparsity-Aware Modeling
evidence function. More concretely, the logarithm of the evidence function is lower
bounded as follows:
log p(D|ξ) ≥L(Q(θ); ξ),
(2.4)
where the lower bound
L(Q(θ); ξ) ≜

Q(θ) log p(D, θ|ξ)
Q(θ)
dθ,
(2.5)
is called evidence lower bound (ELBO), and Q(θ) is known as the variational dis-
tribution. The tightness of the ELBO is determined by the closeness between the
variational distribution Q(θ) and the posterior p(θ|D, ξ), measured by the Kullback–
Leibler (KL) divergence, KL (Q(θ)||p(θ|D, ξ)). In fact, the ELBO becomes tight
(i.e., thelower boundbecomes equal totheevidence) if andonlyif Q(θ) = p(θ|D, ξ)
or equivalently KL (Q(θ)||p(θ|D, ξ)) = 0. This is easy to see if we expand (2.5)
and reformulate it as
log p(D|ξ) = L(Q(θ); ξ) + KL(Q(θ)||p(θ|D|ξ)).
(2.6)
As the KL divergence is nonnegative, the equality in (2.4) holds if and only if the
KL divergence is equal to zero.
Since the ELBO in (2.5) involves two arguments, namely Q(θ) and ξ, solving the
maximization problem
max
Q(θ),ξ L(Q(θ); ξ)
(2.7)
can provide both an estimate of the model hyper-parameters ξ and the variational
distributions Q(θ). These two blocks can be optimized in an alternating fashion.
Differentstrategiesforoptimizing Q(θ)andξ resultindifferentinferencealgorithms.
For example, the variational distribution Q(θ) can be optimized either via functional
optimization, or via the Monte Carlo method, while the hyper-parameters ξ can be
optimized via various non-convex optimization methods.
We have argued that the ELBO will be maximized when KL divergence equals
zero or equivalently Q(θ) = p(θ|D, ξ). But this brings us back to the intractable
multiple integration problem we face in the ﬁrst place. Therefore, in variational
inference, certain restriction will be applied to Q(θ). A widely adopted restriction is
the mean-ﬁeld approximation [13], which will be introduced in the following section.
2.5
Mean-Field Variational Inference
2.5.1
General Solution
Since optimizing Q(θ) in (2.7) given ξ is usually intractable, a widely adopted
approximation to the variational pdf Q(θ) is the mean-ﬁeld family Q(θ) =

2.5 Mean-Field Variational Inference
21
K
k=1 Q(θk), where  θk = θ and  θk = ∅. That is, the unknown set θ is partitioned
into exhaustive but non-overlapping subsets {θk}K
k=1. With the mean-ﬁeld equality
constraint being incorporated into the objective function, problem (2.7) is written as
(ξ is ﬁxed);
max
{Q(θk)}K
k=1
−ln p (D) + EK
k=1 Q(θk) [ln p (θ, D)] −EK
k=1 Q(θk)
	
ln
K

k=1
Q (θk)

.
(2.8)
Although problem (2.8) is not jointly convex with respect to variational pdfs
{Q(θk)}K
k=1, it is convex with respect to a single variational pdf Q(θk) when the
others {Q(θ j)} j̸=k are ﬁxed. This inspires the use of the coordinate descent algo-
rithm in seeking the optimal {Q∗(θk)}K
k=1. That is, with {Q(θ j)} j̸=k being ﬁxed, the
optimal Q∗(θk) is obtained by solving;
min
Q(θk)

Q (θk)

−E
j̸=k Q(θ j) [ln p (θ, D)] + ln Q (θk)

dθk
s.t.

Q(θk)dθk = 1 , Q(θk) ≥0.
(2.9)
For this convex problem, the Karush–Kuhn–Tucker (KKT) condition gives the opti-
mal variational pdf Q∗(θk) as
Q∗(θk) =
exp

E
j̸=k Q(θ j) [ln p (θ, D)]


exp

E
j̸=k Q(θ j) [ln p (θ, D)]

dθk
.
(2.10)
In Eq.(2.10), it is seen that the computation of variational pdf Q∗(θk) relies on
the statistics of other variables in θ. Therefore, each Q∗(θk) is updated alternatively.
Since Q∗(θk) in (2.10) exactly solves the problem (2.9) at each iteration, a stationary
point of the KL divergence is reached after convergence.
2.5.2
Tractability of MF-VI
While the general rule of mean-ﬁeld VI seems simple, it is seen from (2.10) that the
exact functional form of Q∗(θk) is not explicit unless the detailed probabilistic model
p (θ, D) is speciﬁed and the expectation computations are carried out. Unfortunately,
the calculation in (2.10) might not be easy, as it involves a possibly intractable
integration in the denominator. This variability of mean-ﬁeld VI generally poses
great difﬁculty in probabilistic modeling and algorithm development.

22
2
Bayesian Learning for Sparsity-Aware Modeling
Fig. 2.3 Part of a Bayes
network showing a node Y,
the parents and children of
Y, and the co-parents Y with
respect to a child node X
[14]
However, there are special cases in which the optimal variational pdfs {Q∗(θk)}K
k=1
in (2.10) follow predictable patterns. To better illustrate these cases, we ﬁrstly provide
readers with background knowledge of Bayes networks. A Bayes network represents
a set of random variables and their conditional probabilities via a directed graph with-
out cycles. In particular, the joint distribution of all random variables X = {Xi}N
i=1
is
p(X) =
N

i=1
p(Xi|pa(Xi)),
(2.11)
where pa(Xi) denotes the parents of node Xi. An illustration of parents, children,
and co-parents is presented in Fig.2.3.
Next, we introduce exponential family distribution and conjugacy, which is essen-
tial for yielding closed-form optimal variational pdfs for Bayes networks. Examples
of exponential family distributions are listed in Table2.2.
Deﬁnition 2.1 (Exponential family distribution) A random variable x is in
exponential family distribution if its distribution admits the following form:
p(x|η) = h(x) exp

n(η)T t(x) −a(η)

,
(2.12)
where η is a vector parameterizing the distribution, h(x) is the normalizing
constant, n(η) is called the natural parameter, t(x) is the sufﬁcient statistic,
and a(η) is the log-partition function.

2.5 Mean-Field Variational Inference
23
Deﬁnition 2.2 (Conjugacy) A prior probability distribution p(η) is conjugate
tothelikelihoodfunction p(D|η),iftheposteriordistribution p(η|D)shares
the same parametric form as that of p(η).
In a Bayes network, if the prior distribution is an exponential family distribution, and
the likelihood function is an exponential form containing a linear term with respect
to the sufﬁcient statistic in the prior distribution, the prior distribution is conjugate
to the likelihood function. This is formally stated in Proposition 2.1.
Proposition 2.1 Given the prior distribution p(Y|pa(Y)) in exponential fam-
ily,
p(Y|pa(Y)) = hY(Y) exp

nY(pa(Y))T tY(Y) −aY(pa(Y))

.
(2.13)
If the likelihood function p(X|Y, cpY) can be expressed as
p(X|Y, cp(Y)) = exp

nX,Y(X, cp(Y))T tY(Y) −λ(X, cp(Y))

,
(2.14)
the prior distribution p(Y|pa(Y)) is conjugate to the likelihood function
p(X|Y, cp(Y)).
Proof The posterior distribution p(Y|X, pa(Y), cp(Y)) is calculated as
p(Y|X, pa(Y), cp(Y))
∝p(X|Y, cp(Y))p(Y|pa(Y))
∝hY(Y) exp

nY(pa(Y)) + nX,Y(X, cp(Y))
T
tY(Y) −aY(pa(Y)) −λ(X, cp(Y))

,
(2.15)
which shares the same parametric form as that of prior distribution p(Y|pa(Y)), but
conditional on a new natural parameter nY(pa(Y)) + nX,Y(X, cp(Y)). Therefore, the
prior (2.13) is conjugate to the likelihood function (2.14).
□
With the knowledge of exponential family and conjugacy, we are now ready to
discuss tractable classes of mean-ﬁeld VI. The earliest known case that yields closed-
form optimal variational pdf is the conjugate exponential family (CEF) model in [15],
which is a two-layer Bayes network as shown in Fig.2.4a. In this model, the unknown
variable is θ = {{zn}N
n=1, η}, consisting of the local variable zn that is only associated
with data Dn, and the global variable η that controls all the data. Two conditions
are assumed in this model. (1) The joint likelihood function p({Dn, zn}N
n=1|η) is a
member of the exponential family distribution parameterized by η, and (2) the prior

24
2
Bayesian Learning for Sparsity-Aware Modeling
Fig.2.4 aConjugateexponentialfamily(CEF)model.bUnivariateGaussianmodel,whichbelongs
to CEF. In this ﬁgure, the observed variables are denoted by shaded circles while the unknown
variables are denoted by unshaded circles
distribution p(η|α) is conjugate to p({Dn, zn}N
n=1|η) with a ﬁxed hyper-parameter α.
Due to this conjugacy, it was shown in [15] that closed-form optimal variational pdfs
of (2.10) exist in this model.
Example 2.1 (Univariate Gaussian model) To better illustrate the CEF, we use a
concrete example of univariate Gaussian model, as shown in Fig.2.4b. In particular,
given data D = {yn ∈R}N
n=1, univariate Gaussian model assumes that each observa-
tion yn is independently drawn from a univariate Gaussian distribution N(yn|x, β−1).
Bayesian modeling further assigns the mean variable x with a univariate Gaus-
sian prior N(x|m0, s−1
0 ) and the precision (i.e., the inverse of variance) variable
β with a gamma prior gamma(β|a0, b0). Therefore, the joint probability distribu-
tion p({yn}N
n=1, x, β|m0, s0, a0, b0) can be read from Fig.2.4b using the deﬁnition of
Bayes network (2.11),
p({yn}N
n=1, x, β|m0, s0, a0, b0) =
N

n=1
p(yn|pa(yn))p(x|pa(x))p(β|pa(β))
=
N

n=1
N(yn|x, β−1)N(x|m0, s−1
0 )gamma(β|a0, b0).
(2.16)
To verify such a model is within CEF, we need to check the two conditions in
the deﬁnition of CEF. For the ﬁrst condition of the CEF model, we need to prove
that p({yn}N
n=1|x, β) is in the exponential family. To show this, we note that the joint
likelihood function is

2.5 Mean-Field Variational Inference
25
p({yn}N
n=1|x, β) =
N

n=1
N(yn|x, β−1)
= exp
⎛
⎝
	
βx
−β
2
T 	N
n=1 yn
N
n=1 y2
n

+ 1
2 N(ln β −βx2 −ln 2π)
⎞
⎠.
(2.17)
We can identify that p({yn}N
n=1|x, β) takes the form of (2.12), with natural parame-
ter n(x, β) =

βx; −β
2

, sufﬁcient statistic t({yn}N
n=1) =
N
n=1 yn; N
n=1 y2
n

, and
a(x, β) = −1
2 N(ln β −βx2 −ln 2π). Therefore, p({yn}N
n=1|x, β) is in the exponen-
tial family and the ﬁrst condition of CEF is satisﬁed.
Next, we verify the second condition of CEF, which is to show the priors of x
and β are both conjugate to the likelihood function in (2.17). To prove the prior is
conjugate to the likelihood function, we can utilize Proposition 2.1, which states
that the conjugacy holds if the prior is in the exponential family and the likelihood
function admits the form in (2.14). In particular, for random variable x, the univariate
Gaussian prior is in the exponential family,
p(x|m0, s0) = exp
⎛
⎝
	
m0s0
−s0
2
T 	
x
x2

+ 1
2(ln s0 −s0m2
0 −ln 2π)
⎞
⎠,
(2.18)
with sufﬁcient statistic tx(x) =
x; x2
, as summarized in Table2.2. We rewrite the
joint likelihood function (2.17) with respect to random variable x,
p({yn}N
n=1|x, β) = exp
⎛
⎝
	
β N
n=1 yn
−Nβ
2
T 	 x
x2

+ 1
2
N

n=1
(ln β −βy2
n −ln 2π)
⎞
⎠.
(2.19)
It is seen that (2.19) is in the form of (2.14), where the natural parameter
n{yn}N
n=1,x({yn}, β) =

β N
n=1 yn; −Nβ
2

. Its exponent contains the linear product
of sufﬁcient statistic tx(x) and natural parameter n{yn}N
n=1,x({yn}, β). Therefore, by
Proposition 2.1, the prior N(x|m0, s−1
0 ) is conjugate to the likelihood function
p({yn}N
n=1|x, β).
Similarly, for random variable β, the gamma prior is an exponential family dis-
tribution with sufﬁcient statistic t(β) =
β; ln β
,
p(β|a0, b0) = exp
 −b0
a0 −1
T  β
ln β

+ a0 ln b0 −(a0)

.
(2.20)
The joint likelihood function (2.17) can rewritten with respect to β as

26
2
Bayesian Learning for Sparsity-Aware Modeling
p({yn}N
n=1|x, β) = exp
⎛
⎜⎝
⎡
⎣−N
n=1
1
2 y2n + x N
n=1 yn −N
2 x2
N
2
⎤
⎦
T 	
β
ln β

−1
2 N ln 2π
⎞
⎟⎠,
(2.21)
which coincides with (2.14), with the natural parameter n{yn}N
n=1,β({yn}N
n=1, x) =

−N
n=1
1
2 y2
n + x N
n=1 yn −N
2 x2; N
2

and λ({yn}N
n=1, x) = 1
2 N ln 2π. Therefore,
the prior gamma(β|a0, b0) is conjugate to likelihood function by Proposition 2.1,
and thus the second condition of CEF is satisﬁed.
To see how the MF-VI framework yields closed-form optimal variational pdfs
for the univariate Gaussian model, here we demonstrate the computation of Q∗(x)
and Q∗(β) using (2.10) under the mean-ﬁeld Q(x, β) = Q(x)Q(β). To derive the
optimal variational pdf Q∗(x), we extract the terms related to x in the joint probability
distribution (2.16),
p({yn}N
n=1|x, β)p(x|m0, s0)
∝exp
⎛
⎝
	
β N
n=1 yn
−Nβ
2
T 	
x
x2

+ 1
2
N

n=1
(ln β −βy2
n −ln 2π)
⎞
⎠
× exp
m0s0
−s0
2
T  x
x2

+ 1
2(ln s0 −s0m2
0 −ln 2π)

∝exp
⎛
⎝
	
β N
n=1 yn + m0s0
−Nβ
2 −s0
2
T 	
x
x2
⎞
⎠,
(2.22)
where we utilize (2.19) in the second line and (2.18) in the third line. By substituting
(2.22) into (2.10), it can be derived that the optimal variational pdf
Q∗(x) ∝exp
⎛
⎝
	
E[β] N
n=1 yn + m0s0
−NE[β]
2
−s0
2
T  x
x2
⎞
⎠,
(2.23)
which is a univariate Gaussian distribution, since its sufﬁcient statistic is
x; x2
.
Furthermore, by matching the natural parameter in Table2.2, the variance of Q∗(x)
is (NE[β] + s0)−1 and the mean is (NE[β] + s0)−1(E[β] N
n=1 yn + m0s0).
For random variable β, by utilizing (2.20) and (2.21), the terms related to β in
(2.16) are

2.5 Mean-Field Variational Inference
27
Fig. 2.5 b Multilayer hierarchical model. b1 The conjugate relationship for the hierarchical model
and b2 the conjugate relationship in the MPCEF model. In this ﬁgure, the observed variables are
denoted by shaded circles while the unknown variables are denoted by unshaded circles
p({yn}N
n=1|x, β)p(β|a0, b0)
∝exp
⎛
⎝
	
−N
n=1
1
2 y2
n + x N
n=1 yn −N
2 x2
N
2
T 	
β
ln β

−1
2 N ln 2π
⎞
⎠
× exp
⎛
⎝
	
−b0
a0 −1
T 	
β
ln β

+ a0 ln b0 −(a0)
⎞
⎠
∝exp
⎛
⎝
	
−N
n=1
1
2 y2
n + x N
n=1 yn −N
2 x2 −b0
N
2 + a0 −1
T  β
ln β
⎞
⎠.
(2.24)
Putting (2.24) into (2.10), the optimal variational pdf Q∗(β) = gamma(β|a, b),
where a = a0 + N
2 and b = b0 + 1
2(N
n=1 y2
n −2E[x] N
n=1 yn + NE[x2]).
■
CEF model is a two-layer model. More recently, a multilayer hierarchical model
[14] is also found to have closed-form VI property. Figure2.5b1 shows this hierar-
chical model, which considers a variable η(s)
m in the sth layer. Its parent variables are
grouped in the set pa(η(s)
m ), and the variable η(s−1)
l
is one of the children variables
of η(s)
m , with other co-parent variables denoted by the set cp(η(s−1)
l
). In [14], it was
shown that when the conditional pdfs p(η(s−1)
l
|cp(η(s−1)
l
), η(s)
m ) and p(η(s)
m |pa(η(s)
m ))
are conjugate pdf pairs in the exponential family, closed-form variational pdfs also
exist.
Although the CEF model [15] and the hierarchical model in [14] cover many
popular models, such as the factor model, hidden Markov model, and Boltzmann
machine, there are many recent models that do not fall into these two classes. For
example, variational relevance vector machine (RVM), low-rank matrix estimation,

28
2
Bayesian Learning for Sparsity-Aware Modeling
blind separation and decomposition, interference mitigation in wireless communica-
tions, sparse and massive channel estimation, and tensor canonical polyadic decom-
position do not obey the conjugacy required by [15] or [14]. But interestingly, after
tedious derivations using (2.10), the optimal variational pdfs in these works can all
be derived in closed form. One may wonder if this is just a coincidence or if there is
something common among these models that gives closed-form optimal variational
pdfs {Q∗(θk)}K
k=1. This subsection will reveal the latter is true.
In fact, the models in these works belong to another class of multilayer models.
This multilayer model also employs conjugate pdf pairs in the exponential family so
that closed-form VI updates can be guaranteed. However, it takes a different form of
conjugacy compared to the model in [14]. In particular, this new multilayer model,
showninFig.2.5b2,assumesthatforavariableη(s)
m inthesthlayer,theconditionalpdf
p(ch(η(s)
m )|η(s)
m ) is conjugate to the pdf p(η(s)
m |pa(η(s)
m )), where pa(η(s)
m ) and ch(η(s)
m )
stand for the parent set and children set of η(s)
m , respectively. Since this model only
involves partial conjugacy among pdfs in adjacent layers, we term it as multilayer
partial conjugate exponential family (MPCEF) model. In the next subsection, we
introduce the formal deﬁnition of the MPCEF model.
2.5.3
Deﬁnition of MPCEF Model
The MPCEF model satisﬁes the following conditions:
Condition 1. For each variable η(1)
l
in Layer 1, with the remaining unknown variables
{η(1)
j } j̸=l in Layer 1 being ﬁxed, the likelihood function p(D|η(1)
l , {η(1)
j } j̸=l) with
respect to η(1)
l
lies in the exponential family, and its expression can be written as1
p(D|η(1)
l , {η(1)
j } j̸=l) = exp
"
n(D, {η(1)
j } j̸=l)T t(η(1)
l ) −λ(D, {η(1)
j } j̸=l)
#
.
(2.25)
Furthermore, the prior distribution p(η(1)
l |pa(η(1)
l )) conditional on its parents pa(η(1)
l )
is in the exponential family and it takes the following form:
p(η(1)
l |pa(η(1)
l )) = exp
"
n(pa(η(1)
l )T t(η(1)
l ) −λ(pa(η(1)
l )
#
.
(2.26)
That is, the prior distribution p(η(1)
l |pa(η(1)
l )) is conjugate to the likelihood function
p(D|η(1)
l ) (see Proposition 2.1).
Condition 2. For each variable η(s)
m in Layer S > s > 1 with at least one parent, the
distribution of its children variables ch(η(s)
m ) conditioned on itself is an exponential
family distribution, and can be expressed as
1 For simplicity, we use the overloaded notation for the function n(·), t(·), and λ(·). Their detailed
functional forms depend on their arguments.

2.5 Mean-Field Variational Inference
29
Fig. 2.6 Probabilistic model of a relevance vector machine and b matrix decomposition
p(ch(η(s)
m )|η(s)
m , cp(η(s)
m )) = exp
"
n(ch(η(s)
m ), cp(η(s)
m ))T t(η(s)
m ) −λ(ch(η(s)
m ), cp(η(s)
m ))
#
.
(2.27)
Its prior distribution with respect to its parent variables pa(η(s)
m ) is in the exponential
family, and it can be written as
p(η(s)
m |pa(η(s)
m )) = exp
$
n(pa(η(s)
m ))T t(η(s)
m ) −λ(pa(η(s)
m ))
%
,
(2.28)
which
indicates
that
the
prior
p(ch(η(s)
m )|η(s)
m , cp(η(s)
m ))
is
conjugate
to
p(η(s)
m |pa(η(s)
m )).
Condition 3. Any variable without a parent is a known quantity.
For models satisfying conditions 1–3, they all belong to the MPCEF model, and
special cases can be found in various applications. Here we review two popular
models.
Example 2.2 (Relevance vector machine) Relevance vector machine (RVM) [2]
adopts a probabilistic model depicted in Fig.2.6a. In the RVM model, the likeli-
hood function is p(y|w, β) = N
&
y|Xw, β−1IN
'
, and the prior distributions of w
and β are p(w|{γl}L
l=1) = L
l=1 N
&
wl|0, γ −1
l
'
and p(β|αβ) = gamma
&
β|αβ, αβ
'
,
respectively. Furthermore, a hyper-prior p({γl}L
l=1|λγ ) = L
l=1 gamma
&
γl| λγ , λγ
'
is imposed on {γl}L
l=1. In this model, y ∈RN×1 denotes the observation vector to
be ﬁtted, X ∈RN×M collects the feature vectors, w ∈RM×1 is the model parameter
vector, and β ∈R is the noise precision (i.e., inverse of variance).

30
2
Bayesian Learning for Sparsity-Aware Modeling
The observed data are D = {X, y}. The Layer 1 variables are η(1)
1
= w, η(1)
2
= β.
Starting
from
variable
η(1)
1
= w,
the
Gaussian
joint
likelihood
function
p(X, y|w, β) = N(y|Xw, β−1IN) with respect to η(1)
1
= w is in the form of (2.25),
p(X, y|w, β) = exp
⎛
⎝
	
βXT y
−1
2vec(βXXT )
T 	
w
vec(wwT )

+ 1
2(N log β −βyT y −N log 2π)
⎞
⎠,
(2.29)
with n(X, y, β) =

βXT y; −1
2vec(βXXT )

, t(w) =
w; vec(wwT )
, and λ(X,
y, β) = −1
2(N log β −βyT y −N log 2π). Its prior distribution conditioned on its
parent variables {γl}L
l=1 takes the form of (2.26),
p(w|{γl}L
l=1) = exp
⎛
⎝
	
0M×1
−1
2vec(diag{γ1, . . . , γL)}
T 	
w
vec(wwT )

+ 1
2
L

l=1
(log γ −log 2π)
⎞
⎠,
(2.30)
where n({γl}L
l=1) =

0M×1; −1
2vec(diag{γ1, . . . , γL)}

, t(w) =
w; vec(wwT )
, and
λ({γl}L
l=1) = −1
2
L
l=1(log γ −log 2π). Therefore, Condition 1 of MPCEF is satis-
ﬁed for Layer 1 variable w.
Similarly, for Layer 1 variable η(1)
2
= β, the Gaussian joint likelihood with respect
to η(1)
2
= β takes the form of (2.25),
p(X, y|w, β) = exp
⎛
⎝
	
−1
2(y −Xw)T (y −Xw)
N
2
T 	
β
log β

−N
2 log 2π
⎞
⎠.
(2.31)
Furthermore, its prior distribution is in the form of (2.26),
p(β|αβ) = exp
 −αβ
αβ −1
T  β
log β

+ αβ ln αβ −ln (αβ)

,
(2.32)
which veriﬁes Condition 1 of MPCEF for β. Since there are only two variables in
Layer 1, Condition 1 holds.
For Layer 2 variable η(2)
l
= γl, its children distribution conditioned on its parent
γl and co-parents {γ j}L
j=1, j̸=l takes the form of (2.27),
p(w|γl, {γ j}L
j=1, j̸=l) = exp
⎛
⎝
	
−1
2w2
l
1
2
T 	
γl
log γl

−
L

j=1, j̸=l
1
2(γ jw2
j −log γ j) −L
2 log 2π
⎞
⎠,
(2.33)

2.5 Mean-Field Variational Inference
31
where n(w, {γ j}L
j=1, j̸=l) =

−1
2w2
l ; 1
2

, t(γl) =
γl; log γl

, and λ(w, {γ j}L
j=1, j̸=l) =
L
j=1, j̸=l
1
2(γ jw2
j −log γ j) + L
2 log 2π. The prior distribution of η(2)
l
= γl admits
the form of (2.28),
p(γl|λγ ) = exp
⎛
⎝
	
−λγ
λγ −1
T 	
γl
log γl

+ λγ ln λγ −ln (λγ )
⎞
⎠.
(2.34)
Therefore, Condition 2 is satisﬁed. Finally, variables λγ and αβ are known quantities,
and thus Condition 3 holds. To conclude, RVM belongs to MPCEF.
■
Example 2.3 (Probabilistic matrix decomposition) The probabilistic model is
depicted in Fig.2.6b [2]. In this model, the likelihood function is p(Y|A, B, β) =
N
n=1 N
&
Y:,n|ABn,:, β−1IM
'
, with prior distributions of A, B, and β given
by p(A|{γl}L
l=1) = L
l=1 N(A:,l|0L×1, γ −1
l
IL), p(B|{γl}L
l=1) = L
l=1 N(B:,l|0L×1,
γ −1
l
IL), and p(β|αβ) = gamma
&
β|αβ, αβ
'
, respectively. Furthermore, a hyper-
prior p({γl}L
l=1|λγ ) = L
l=1 gamma
&
γl|λγ , λγ
'
is imposed on {γl}L
l=1. In this model,
Y ∈RM×N denotes the observed data matrix, while the random variables are factor
matrices A ∈RM×L and B ∈RN×L, and the noise precision β ∈R. With a similar
proof for RVM, the likelihood function p(Y|A, B, β) with respect to A and β is in the
form of (2.25). For variable B, notice that the likelihood function can be re-expressed
by factorizing over rows, i.e., p(Y|A, B, β) = M
m=1 N
&
Ym,:|BAm,:, β−1IN
'
, and it
can be seen that p(Y|A, B, β) with respect to B is also in the form of (2.25). The
remaining conditions of MPCEF can be shown similarly to RVM.
■
While MPCEF is a general class of model, it has not been formally articulated
in the literature, and the algorithms in previous works were derived independently.
In the following, we show that VI derivations in the MPCEF model follow a regular
pattern, and therefore the result of this chapter would facilitate the future development
of applications obeying the MPCEF model.
2.5.4
Optimal Variational Pdfs for MPCEF Model
Referring
to
Fig.2.5b,
in
the
MPCEF
model,
the
unknown
variables
θ = {η(1)
1 , . . ., η(1)
L1 , η(2)
1 , . . ., η(S)
L S }. Correspondingly, the mean-ﬁeld assumption is
Q(θ) = 
m,s Q(η(s)
m ) ≜K
k=1 Q(θk) where K = S
i=1 Li with Li being the num-
ber of variables in Layer i. As introduced in Sect.2.5.1, the optimal variational pdfs
{Q∗(η(s)
m )} can be obtained by carrying out the calculations in (2.10), and the results
for the MPCEF model are summarized in the following theorem.

32
2
Bayesian Learning for Sparsity-Aware Modeling
Theorem 2.1. Given a dataset D, and under the mean-ﬁeld assumption
Q(θ) = 
m,s Q(η(s)
m ) ≜K
k=1 Q(θk), the optimal variational pdfs of the
MPCEF model are given by the following:
(a). For each variable η(1)
l
in Layer 1 with at least one parent, the optimal
variational pdf Q∗(η(1)
l ) takes the same functional form as (2.26) and its
expression is derived as
Q∗(η(1)
l ) ∝exp

E
θ j ̸=η(1)
l [n(D, {η(1)
j } j̸=l) + n(pa(η(1)
l ))]T t(η(1)
l )

. (2.35)
(b). For each variable η(s)
m in Layer 1 < s < S with at least one parent,
the optimal variational pdf has the same functional form as (2.28) and its
expression is
Q∗(η(s)
m ) ∝exp

E
θ j ̸=η(s)
m [n(ch(η(s)
m ), cp(η(s)
m )) + n(pa(η(s)
m ))]T t(η(s)
m )

.
(2.36)
Proof
(a). Derivation for Q∗(η(1)
l )
In the joint pdf p(D, θ), after ﬁxing variables other than η(1)
l , the term relevant to
η(1)
l
is p(D|η(1)
l , {η(1)
j } j̸=l)p(η(1)
l |pa(η(1)
l )), which is the product of (2.25) and (2.26).
Substituting this term into (2.10), we have
Q∗(η(1)
l ) ∝exp
(
E
θ j ̸=η(1)
l
q(θ j)

p(D|η(1)
l , {η(1)
j } j̸=l)p(η(1)
l |pa(η(1)
l ))
)
∝exp
(
E
θ j ̸=η(1)
l
q(θ j)

n(D, {η(1)
j } j̸=l)T t(η(1)
l ) −λ(D, {η(1)
j } j̸=l)
+ n(pa(η(1)
l )T t(η(1)
l ) −λ(pa(η(1)
l )
)
,
(2.37)
which gives rise to (2.35).
(b). Derivation for Q∗(η(s)
m ) where 1 < s < S
Similar to (a), with other variables {θk, θk ̸= η(s)
m } being ﬁxed, the term relevant
to η(s)
m in the joint pdf p(D, θ) is the product of (2.27) and (2.28). By (2.10), the
optimal variational pdf is derived as

2.5 Mean-Field Variational Inference
33
Q∗(η(s)
m ) ∝exp
(
E
θ j ̸=η(s)
m q(θ j)

p(ch(η(s)
m )|η(s)
m , cp(η(s)
m ))p(η(s)
m |pa(η(s)
m ))
)
∝exp
(
E
θ j ̸=η(s)
m q(θ j)

n(ch(η(s)
m ), cp(η(s)
m ))T t(η(s)
m ) −λ(ch(η(s)
m ), cp(η(s)
m ))
+ n(pa(η(s)
m ))T t(η(s)
m ) −λ(pa(η(s)
m )))
)
,
(2.38)
which veriﬁes (2.36).
□
Theorem 2.1 points out that if a model belongs to MPCEF, the optimal variational
pdfs {Q∗(θk)}K
k=1 are all in closed form. Since the computation of a variational pdf
Q(θk) relies on the statistics of {Q(θ j)} j̸=k, {Q(θk)}K
k=1 are updated cyclically for
k = 1, 2, 3, . . ., K using (2.35) or (2.36).
We next showcase the derivations of optimal variational pdfs given by
Theorem
2.1
for
the
RVM
model
(Example
2.2).
For
Layer
1
vari-
able η(1)
1
= w, by comparing the likelihood function (2.29) to (2.25), we
identify that n(X, y, β) =

βXT y; −1
2vec(βXXT )

and t(w) =
w; vec(wwT )
.
Furthermore, its prior distribution (2.30) takes the form of
(2.26) with
n({γl}L
l=1) =

0M×1; −1
2vec(diag{γ1, . . . , γL)}

, t(w) =
w; vec(wwT )
. By substi-
tuting n(X, y, β), n({γl}L
l=1), and t(w) into (2.35), it is derived that
Q∗(w) ∝exp

E
θ j ̸=η(1)
l [n(X, y, β) + n({γl}L
l=1)]T t(w)

∝exp

E

βXT y
−1
2vec(βXXT ) −1
2vec(diag{γ1, . . . , γL)}
T 
w
vec(wwT )

.
(2.39)
From Table2.2, it can be concluded that the optimal variational pdf is a Gaussian
distribution, i.e., Q∗(w) = N(w|μ, ), where  =
&
E [β] XT X + E

diag{γ1, . . . ,
γL}
'−1 and μ = E [β] XT y. Similarly, for Layer 1 variable η(1)
2
= β, the optimal
variational pdf is a gamma distribution, Q∗(β) = gamma(β|a, b), where a = αβ +
1
2 N and b = αβ + 1
2E

(y −Xw)T (y −Xw)

.
For Layer 2 variable η(2)
l
= γl, it is seen that (2.33) admits the form of (2.27),
where n(w, {γ j}L
j=1, j̸=l) =

−1
2w2
l ; 1
2

and t(γl) =
γl; log γl

. Furthermore, by
matching (2.34) with (2.28), its natural parameter is n(λγ ) =
−λγ ; λγ −1
. By
(2.36),
Q∗(γl) ∝exp

E

n(w, {γ j}L
j=1, j̸=l) + n(λγ ))
T t(γl)

∝exp

E
−λγ −1
2w2
l
λγ −1
2
T  γl
log γl

.
(2.40)

34
2
Bayesian Learning for Sparsity-Aware Modeling
By comparing (2.40) with the gamma distribution in Table2.2, the optimal variational
pdf is found to be a gamma distribution Q∗(γl) = gamma(γl|cl, dl) with cl = λγ + 1
2
and dl = λγ + 1
2E

w2
l

. The derivations of the optimal variational pdfs for proba-
bilistic matrix factorization model (Example 2.3) can be similarly achieved.
References
1. B. Efron, Bayes’ theorem in the 21st century. Science 340(6137), 1177–1178 (2013)
2. S. Theodoridis, Machine Learning: A Bayesian and Optimization Perspective, 2nd edn. (Aca-
demic, Cambridge, 2020)
3. K.Wang,F.Li,C.-M.Chen,M.M.Hassan,J.Long,N.Kumar,Interpretingadversarialexamples
and robustness for deep learning-based auto-driving systems. IEEE Trans. Intell. Transp. Syst.
(2021)
4. I. Kononenko, Inductive and bayesian learning in medical diagnosis. Appl. Artif. Intell. Inter.
J. 7(4), 317–337 (1993)
5. M.E. Tipping, Bayesian inference: an introduction to principles and practice in machine learn-
ing, in Summer School on Machine Learning (Springer, Berlin, 2003), pp. 41–62
6. J.F. Claerbout, F. Muir, Robust modeling with erratic data. Geophysics 38(5), 826–844 (1973)
7. Y.C.Eldar,G.Kutyniok,CompressedSensing:Theory andApplications (Cambridge University
Press, Cambridge, 2012)
8. M. Elad, Sparse and Redundant Representations: From Theory to Applications in Signal and
Image Processing (Springer Science Business Media, Berlin, 2010)
9. K. Panousis, S. Chatzis, S. Theodoridis, Stochastic local winner-takes-all networks enable pro-
found adversarial robustness, in Proceedings of the Advances in Neural Information Processing
Systems (NeurIPS) (2022)
10. F. Yin, L. Pan, T. Chen, S. Theodoridis, Z.-Q. Luo, Linear multiple low-rank kernel based
stationary Gaussian processes regression for time series. IEEE Trans. Signal Process. 68, 5260–
5275 (2020)
11. L. Cheng, Z. Chen, Q. Shi, Y.-C. Wu, S. Theodoridis, Towards ﬂexible sparsity-aware modeling:
automatic tensor rank learning using the generalized hyperbolic prior. IEEE Trans. Signal
Process. 1(1), 1–16 (2022)
12. D.F. Andrews, C.L. Mallows, Scale mixtures of normal distributions. J. R. Stat. Soc.: Ser. B
(Methodological) 36(1), 99–102 (1974)
13. C. Zhang, J. Bütepage, H. Kjellström, S. Mandt, Advances in variational inference. IEEE Trans.
Pattern Anal. Mach. Intell. 41(8), 2008–2026 (2018)
14. J. Winn, C.M. Bishop, T. Jaakkola, Variational message passing. J. Mach. Learn. Res. 6(4)
(2005)
15. M.J. Beal, Variational Algorithms for Approximate Bayesian Inference (University of London,
University College London (United Kingdom), 2003)

Chapter 3
Bayesian Tensor CPD: Modeling
and Inference
Abstract Having introduced the basic philosophies of Bayesian sparsity-aware
learning in the last chapter, we formally start our Bayesian tensor decomposition
journey in this chapter. For a pedagogical purpose, the ﬁrst treatment is given on
the most fundamental tensor decomposition format, namely CPD, which has been
introduced in Chap.1. As will be demonstrated in the following chapters, the key
ideas developed for Bayesian CPD can be applied to other tensor decomposition
models, including Tucker decomposition and tensor train decomposition. Therefore,
this chapter serves as a stepping stone toward modern tensor machine learning and
signal processing. Concretely, we will ﬁrst show how the GSM family introduced
in the last chapter can be adopted for the prior modeling of tensor CPD. Then, in
this framework, we devise a Bayesian learning algorithm for CPD using the gener-
alized hyperbolic (GH) prior, and introduce its widely adopted special case, namely
Bayesian CPD using Gaussian-Gamma (GG) prior. At the end of this chapter, we
introduce a different class of probabilistic modeling, namely non-parametric model-
ing, and present multiplicative gamma process (MGP) prior as an example.
3.1
A Uniﬁed Probabilistic Modeling Using GSM Prior
Before introducing uniﬁed probabilistic modeling, we ﬁrst recap the deﬁnition of
tensor CPD. Given an N dimensional (N-D) data tensor Y ∈RI1×···×IN , a set of
factor matrices {U(n) ∈RIn×R} are sought via solving the following problem:
min
{U(n)}N
n=1
∥Y −
R

r=1
U(1)
:,r ◦U(2)
:,r ◦· · · ◦U(N)
:,r



X≜U(1),U(2),...,U(N)
∥2
F,
(3.1)
where the symbol ◦denotes the vector outer product, and the shorthand notation
· · · is termed as the Kruskal operator. As discussed in Chap.1, the tensor CPD
aims at decomposing an N-D tensor into a summation of R rank-1 tensors, with the
rth component constructed as the vector outer product of the rth columns from all
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023
L. Cheng et al., Bayesian Tensor Decomposition for Signal Processing and
Machine Learning, https://doi.org/10.1007/978-3-031-22438-6_3
35

36
3
Bayesian Tensor CPD: Modeling and Inference
the factor matrices, i.e., {U(n)
:,r }N
n=1. In problem (3.1), the number of columns R of
each factor matrix, also known as tensor rank, determines the number of unknown
model parameters and thus the model complexity. In practice, it needs to be carefully
selected to achieve the best performance in both recovering the noise-free signals
(e.g., in image denoising) and unveiling the underlying components (e.g., in social
group clustering). In Bayesian perspective, (3.1) can be interpreted as the Gaussian
likelihood function:
p

Y | {U(n)}N
n=1, β

∝exp
	
−β
2 ∥Y −U(1), U(2), . . ., U(N) ∥2
F

,
(3.2)
where β denotes the precision (i.e., inverse variance) of the observation error.
In the sequel, we show how the low-rankness is embedded into the CPD model
using the GSM prior introduced in the last chapter. First, we employ an over-
parameterized model for CPD by assuming an upper bound value L of tensor rank R
with L ≫R. The low-rankness implies that many of the L rank-1 tensors should be
zero. In other words, let all the lth columns of different factor matrices {U(n)}N
n=1 be
put into a vector ql ≜[U(1)
:,l ; U(2)
:,l ; . . . ; U(N)
:,l ] ∈R
N
n=1 In, ∀l; the low-rankness indi-
cates that a number of vectors in the set {ql}L
l=1 are zero vectors. To model such
sparsity, we adopt the following multivariate extension of GSM prior from the last
chapter:
p(ql) =

P
p=1 Ip

i=1
N([ql]i|0, ζl)p(ζl|ξn)dζl,
=

N(ql|0, ζlI)p(ζl|ξn)dζl,
=

N

n=1
N(U(n)
:,l |0, ζlI)p(ζl|ξn)dζl,
(3.3)
where [ql]i denotes the ith element of vector ql. Since the elements in ql are assumed
to be statistically independent, according to the deﬁnition of a multivariate Gaussian
distribution, we have the second and third lines of (3.3) showing the equivalent prior
modeling on the concatenated vector ql and the associated set of vectors {U(n)
:,l }N
n=1,
respectively. The mixing distribution p(ζl|ξn) can be any one listed in Table2.2
(in Chap.2). Note that in (3.3), the elements in vector ql are tied together via a
common hyper-parameter ζl. Once the learning phase is over, if ζl approaches zero,
the elements in ql will shrink to zero simultaneously, thus nulling a rank-1 tensor, as
illustrated in Fig.3.1. Since the prior distribution given in (3.3) favors zero-valued
rank-1 tensors, it promotes the low-rankness of the CPD model.

3.2 PCPD-GG: Probabilistic Modeling
37
Fig. 3.1 Illustration of sparsity-aware modeling for rank-1 tensors using GSM priors
3.2
PCPD-GG: Probabilistic Modeling
In this section, we present the probabilistic CPD modeling using Gaussian-gamma
prior, in which p(ζl|ξn) in (3.3) takes a gamma distribution. The modeling was ﬁrst
proposed in [1, 2] and widely adopted in follow-up works [3–9].
In tensor CPD, as shown in (3.1), the lth columns in all the factor matrices
({U(n)
:,l }N
n=1) constitute the building block of the model. Given an upper bound value
L of the tensor rank, for each factor matrix, since there are L −R columns all
being zero, sparsity-promoting priors should be imposed on the columns of each
factor matrix to encode the information of over-parameterization.1 In the pioneering
works [1, 2], assuming statistical independence among the columns in {U(n)
:,l , ∀n,l},
a Gaussian-gamma prior was utilized to model them as
p({U(n)}N
n=1|{γl}L
l=1) =
L

l=1
p({U(n)
:,l }N
n=1|γl) =
L

l=1
N

n=1
N(U(n)
:,l |0In×1, γ −1
l
I In),
(3.4)
p({γl}L
l=1|{c0
l , d0
l }L
l=1) =
L

l=1
p(γl|c0
l , d0
l ) =
L

l=1
gamma(γl|c0
l , d0
l ),
(3.5)
where γl is the precision (i.e., the inverse of variance) of the lth columns {U(n)
:,l }N
n=1,
and {c0
l , d0
l } are pre-determined hyper-parameters.
1 The sparsity level of over-parameterized CPD model can be measured by L−R
L .

38
3
Bayesian Tensor CPD: Modeling and Inference
Fig. 3.2 Univariate marginal
probability density function
in (3.6) with different values
of hyper-parameters
5
0
5
-
x
10-15
10-10
10-5
100
105
p(x)
(cl
0 = 2, dl
0 = 10-6)
(cl
0 = 1, dl
0 = 10-6)
(cl
0 = 10-6, dl
0 = 10-6)
To see the sparsity-promoting property of the above Gaussian-gamma prior, we
marginalize the precisions {γl}L
l=1 to obtain the marginal probability density function
(pdf) p({U(n)}N
n=1) as follows:
p

{U(n)}N
n=1

=
L

l=1
p({U(n)
:,l }N
n=1) =
L

l=1

p({U(n)
:,l }N
n=1|γl)p(γl|c0
l , d0
l )dγl
=
L

l=1
	 1
π

N
n=1 In
2
(c0
l + N
n=1
In
2 )
2d0
l
−c0
l (c0
l )

2d0
l + ∥vec

{U(n)
:,l }N
n=1

∥2
2
−c0
l −N
n=1
In
2 ,
(3.6)
where (·) denotes the gamma function and vec(·) denotes the vectorization2 of its
argument. Equation (3.6) characterizes a multivariate student’s t distribution with
hyper-parameters {c0
l , d0
l }L
l=1. To get insights from this marginal distribution, we
illustrate its univariate case in Fig.3.2 with different hyper-parameters. It is clear
that while different hyper-parameters lead to different tail behaviors, each student’s
t pdf is strongly peaked at zero. Therefore, with a proper setting of hyper-parameters
(e.g., c0
l = d0
l = 10−6), the Gaussian-gamma prior would be sparsity-promoting as
the peak at zeros will inform the learning process to look for values around “zeros”
while the heavy tails still allow the learning process to obtain components with
2 The operation vec

{U(n)
:,l }N
n=1

simply stacks all these columns into a long vector, i.e.,
vec

{U(n)
:,l }N
n=1

= [U(1)
:,l ; U(2)
:,l ; . . . ; U(N)
:,l ] ∈RZ×1, with Z = N
n=1 In.

3.3 PCPD-GH: Probabilistic Modeling
39
Fig. 3.3 Probabilistic CPD model with Gaussian-gamma prior
large values. Furthermore, as to be shown later, {c0
l , d0
l }L
l=1 will be updated using
the observed data during inference. This provides tailored sparsity probabilities for
different rank-1 components.
The probabilistic CPD model is completed by specifying the likelihood function of
Y, given in (3.2). Equation (3.2) assumes that the signal tensor U(1), U(2), . . ., U(N)
is corrupted by additive white Gaussian noise (AWGN) tensor W with each element
having power β−1. This is consistent with the least-squares (LS) problem in (3.1).
However, in Bayesian modeling, β is modeled as another random variable. Since we
have no prior information about the noise power, a non-informative prior p(β) =
gamma(β|ϵ, ϵ) with a very small ϵ (e.g., 10−6) is usually employed.
By using the introduced prior distributions and likelihood function, a probabilistic
model for tensor CPD was constructed, as illustrated in Fig.3.3. Based on this model,
a VI-based algorithm was derived in [1] that can automatically drive most of the
columnsineachfactormatrixtozero,bywhichthetensorrankisrevealed.Inspiredby
the vanilla probabilistic CPD using the Gaussian-gamma prior, other structured and
large-scale tensor CPDs with automatic tensor rank learning were further developed
[3–9] in recent years.
3.3
PCPD-GH: Probabilistic Modeling
The success of the previous works on automatic tensor rank learning [1, 3–9] comes
from the adoption of the sparsity-promoting Gaussian-gamma prior. However, their
performances are also limited by the rigid central and tail behaviors of Gaussian-

40
3
Bayesian Tensor CPD: Modeling and Inference
gamma prior in modeling different levels of sparsity. More speciﬁcally, when the
tensor rank R is low, previous empirical results have shown that a relatively large
upper bound L (e.g., set by the maximal value of tensor dimensions [1, 3]) gives
accurate tensor rank estimation. However, for a high tensor rank R, the upper bound
value L selected as in the low-rank case would be too small to render a sparsity
pattern of the columns, and thus it leads to performance degradation. Even though
we can increase the value of L to larger numbers, as it will be shown in later chapters,
tensor rank learning accuracy using Gaussian-gamma prior is still not satisfactory,
showing its lack of ﬂexibility to adapt to different sparsity levels. Therefore, to further
enhance the tensor rank learning capability, we explore the use of sparsity-promoting
priors with more ﬂexible central and tail behaviors.
In particular, we focus on the generalized hyperbolic (GH) prior (see Table2.1
for its deﬁnition), since it not only includes the Gaussian-gamma prior as a special
case, but also can be treated as the generalization of other widely used sparsity-
promoting distributions including the Laplacian distribution, normal-inverse chi-
squared distribution, normal-inverse gamma distribution, variance-gamma distribu-
tion, and Mckay’s Bessel distribution. Therefore, it is expected that the functional
ﬂexibility of GH prior could lead to more adaptability in modeling different sparsity
levels and thus more accurate learning of tensor rank.
Recall that the model building block in a CPD is the lth column group {U(n)
:,l }N
n=1.
With the GH prior on each column group, we have a new prior distribution for factor
matrices:
p({U(n)}N
n=1)
=
L

l=1
GH({U(n)
:,l }N
n=1|a0
l , b0
l , λ0
l )
=
L

l=1
(a0
l )
N
n=1 In
4
(2π)
N
n=1 In
2
(b0
l )
−λ0
l
2
Kλ0
l
	
a0
l b0
l

K
λ0
l −
N
n=1 In
2
	
a0
l

b0
l + ∥vec

{U(n)
:,l }N
n=1

∥2
2


b0
l + ∥vec

{U(n)
:,l }N
n=1

∥2
2

,
(3.7)
where K·(·) is the modiﬁed Bessel function of the second kind, and GH({U(n)
:,l }N
n=1|a0
l ,
b0
l , λ0
l ) denotes the GH prior on the lth column group {U(n)
:,l }N
n=1, in which the hyper-
parameters {a0
l , b0
l , λ0
l } control the shape of the distribution. By setting {a0
l , b0
l , λ0
l }
to speciﬁc values, the GH prior (3.7) reduces to other prevalent sparsity-promoting
priors. For example:
(1) Student’s t Distribution. When a0
l →0 and λ0
l < 0, it can be shown that the
GH prior (3.7) reduces to [10, 11]

3.3 PCPD-GH: Probabilistic Modeling
41
p({U(n)}N
n=1)
=
L

l=1
GH({U(n)
:,l }N
n=1|a0
l →0, b0
l , λ0
l < 0)
=
L

l=1
	 1
π

N
n=1 Jn
2
(λ0
l + N
n=1
Jn
2 )
b0
l
λ0
l (−λ0
l )

b0
l + ∥vec

{U(n)
:,l }N
n=1

∥2
2
λ0
l −N
n=1
Jn
2 .
(3.8)
By comparing the functional form of (3.8) to that of (3.6), it is clear that pdf (3.8)
is a student’s t distribution with hyper-parameters {−λ0
l , b0
l
2 }.
(2) Laplacian Distribution. When b0
l →0 and λ0
l > 0, it can be shown that the
GH prior (3.7) reduces to [10, 11]
p({U(n)}N
n=1) =
L

l=1
GH({U(n)
:,l }N
n=1|a0
l , b0
l →0, λ0
l > 0)
=
L

l=1
(a0
l )
N
n=1 Jn
4
+
λ0
l
2
	
π
N
n=1 Jn
2

 	
2
N
n=1 Jn
2
+λ0
l −1

∥vec

{U(n)
:,l }N
n=1

∥
λ0
l −
N
n=1 Jn
2
2
2λ0
l 

λ0
l

× K
λ0
l −
N
n=1 Jn
2
	
a0
l ∥vec

{U(n)
:,l }N
n=1

∥2

.
(3.9)
The pdf (3.9) characterizes a generalized Laplacian distribution. By setting λ0
l =
N
n=1 Jn
2
+ 1, (3.9) reduces to a standard Laplacian pdf:
p({U(n)}N
n=1) =
L

l=1
GH

{U(n)
:,l }N
n=1|a0
l , b0
l →0, λ0
l =
N
n=1 Jn
2
+ 1

∝
L

l=1
(a0
l )
N
n=1 Jn
2
exp
	
−

a0
l ∥vec

{U(n)
:,l }N
n=1

∥2

.
(3.10)
To visualize the GH distribution and its special cases, the univariate GH pdfs with
different hyper-parameters are illustrated in Fig.3.4. It can be observed that the blue
line is with a similar shape to those of the student’s t distributions in Fig.3.2, while
the orange one resembles the shapes of Laplacian distributions. For other lines, they
exhibit a wide range of the central and tail behaviors of the pdfs. Comparing Figs.3.2
and 3.4 reveals that the GH prior is more ﬂexible than the GG prior, and thus offers
more modeling capability for different levels of sparsity.
On the other hand, the GH prior (3.7) can be expressed as a GSM formulation
[10, 11]:

42
3
Bayesian Tensor CPD: Modeling and Inference
Fig. 3.4 Univariate marginal
probability density function
in (3.7) with different values
of hyper-parameters
p({U(n)}N
n=1)
=
L

l=1
GH({U(n)
:,l }N
n=1|a0
l , b0
l , λ0
l )
=
L

l=1

N

vec

{U(n)
:,l }N
n=1

|0N
n=1 In×1, zl IN
n=1 In

GIG(zl|a0
l , b0
l , λ0
l )dzl,
(3.11)
where zl denotes the variance of the Gaussian distribution, and GIG(zl|a0
l , b0
l , λ0
l ) is
the generalized inverse Gaussian (GIG) pdf:
GIG(zl|a0
l , b0
l , λ0
l ) =

a0
l
b0
l
 λ0
l
2
2Kλ0
l
	
a0
l b0
l

z
λ0
l −1
l
exp
	
−1
2

a0
l zl + b0
l z−1
l

.
(3.12)
This GSM formulation suggests that each GH distribution GH({U(n)
:,l }N
n=1|a0
l , b0
l , λ0
l )
can be regarded as an inﬁnite mixture of Gaussians with the mixing distribution being
a GIG distribution. Besides connecting with the GSM framework, the formulation
(3.11) allows a hierarchical construction of each GH prior by introducing the latent
variable zl, as illustrated in Fig.3.5. Furthermore, it turns out that this hierarchical
construction possesses the conjugacy property [10], which facilitates the derivation
of the Bayesian inference algorithm later.

3.3 PCPD-GH: Probabilistic Modeling
43
Fig. 3.5 Hierarchical construction of GH distribution
Fig. 3.6 The probabilistic tensor CPD model with GH prior
Property 3.1 The prior p(zl) = GIG(zl|a0
l , b0
l , λ0
l ) is conjugate to
p

{U(n)
:,l }N
n=1|zl

= N

vec

{U(n)
:,l }N
n=1

|0N
n=1 In×1, zl IN
n=1 In

.
(3.13)
Finally, together with the likelihood function in (3.2), the probabilistic model for
tensor CPD using the hierarchical construction of the GH prior is shown in Fig.3.6.
Denoting the model parameter set  = {{U(n)}N
n=1, {zl}L
l=1, β}, the GH-prior-based
probabilistic tensor CPD model can be fully described by the joint pdf p(Y, ) as

44
3
Bayesian Tensor CPD: Modeling and Inference
p(Y, ) = p

Y | {U(n)}N
n=1, β

p

{U(n)}N
n=1|{zl}L
l=1

p

{zl}L
l=1

p(β)
∝exp
N
n=1 In
2
ln β −β
2 ∥Y −U(1), U(2), . . ., U(N) ∥2
F
+
N

n=1

In
2
L

l=1
ln z−1
l
−1
2Tr

U(n)Z−1U(n)T 

+
L

l=1
λ0
l
2 ln a0
l
b0
l
−ln

2Kλ0
l
	
a0
l b0
l


+ (λ0
l −1) ln zl
−1
2

a0
l zl + b0
l z−1
l
 
+ (ϵ −1) ln β −ϵβ

,
(3.14)
where Z = diag{z1, z2, . . . , zL}.
3.4
PCPD-GH, PCPD-GG: Inference Algorithm
Since PCPD-GG is a special case of PCPD-GH, in this section, we ﬁrst develop the
variational inference algorithm for PCPD-GH, and then reduce the derived algorithm
to cater to the PCPD-GG modeling.
The inference algorithm is derived based on the mean-ﬁeld variational inference
(MF-VI) framework introduced in the last chapter. Speciﬁcally, it is easy to show
that the introduced PCPD-GH/PCPD-GG model falls into the MPCEF model, thus
their optimal variational pdfs can be derived in closed form.
To make this chapter self-contained, we brieﬂy review the MF-VI. Given the prob-
abilistic model p(Y, ), our goal is to learn the model parameters in  from the
tensor data Y, in which the posterior distribution p(|Y) is to be sought. However,
for such a complicated probabilistic model (3.14), the multiple integrations in com-
puting the posterior distribution p(|Y) is not tractable. Rather than manipulating
a huge number of samples from the probabilistic model, VI recasts the originally
intractable multiple integration problem into the following functional optimization
problem:
min
Q() KL

Q () ∥p ( | Y)

≜−EQ()

ln p ( | Y)
Q ()

s.t. Q() ∈F ,
(3.15)
where KL(·||·) denotes the Kullback–Leibler (KL) divergence between two argu-
ments, and F is a pre-selected family of pdfs. Its philosophy is to seek a tractable
variational pdf Q() in F that is the closest to the true posterior distribution p(|Y)

3.4 PCPD-GH, PCPD-GG: Inference Algorithm
45
in the KL divergence sense. Therefore, the art is to determine the family F to bal-
ance the tractability of the algorithm and the accuracy of the posterior distribution
learning.
Using the mean-ﬁeld family, which restricts Q() = K
k=1 Q(k) where  is
partitioned into mutually disjoint non-empty subsets k (i.e., k is a part of  with
∪K
k=1k =  and ∩K
k=1k = Ø), the KL divergence minimization problem (3.15)
becomes
min
{Q(k)}K
k=1
−E{Q(k)}K
k=1

ln
p ( | Y)
K
k=1 Q(k)

.
(3.16)
The factorable structure in (3.16) inspires the idea of block minimization from opti-
mization theory. In particular, after ﬁxing variational pdfs {Q( j)} j̸=k other than
Q(k), the remaining problem is
min
Q(k)

Q(k)(−E
j̸=k Q( j)

ln p(, Y)
 
+ ln Q(k))dk,
(3.17)
and it has been shown that the optimal solution is
Q∗(k) =
exp

E
j̸=k Q( j)

ln p (, Y)
 
!
exp

E
j̸=k Q( j)

ln p (, Y)
 
dk
.
(3.18)
3.4.1
Optimal Variational Pdfs
For the probabilistic CPD, the optimal variational pdfs {Q∗(k)}K
k=1 can be obtained
by substituting (3.14) into (3.18). Although straightforward as it may seem, the
involvement of tensor algebras in (3.14) and the multiple integrations in the denom-
inator of (3.18) make the derivation a challenge. On the other hand, since the prob-
abilistic model employs the GH prior, and is different from previous works using
Gaussian-gamma prior [1, 3–9], each optimal variational pdf Q∗(k) needs to be
derived from ﬁrst principles. To keep this chapter concise, the lengthy derivations
are omitted and the details can be found in [12]. In the following, we present only
the inference results. For easy reference, the optimal variational pdfs are also sum-
marized in Table 3.1.
In particular, the optimal variational pdf Q∗(U(k)) was derived to be a matrix
normal distribution MN

U(k)|M(k), I In, (k)
with the covariance matrix
(k) =

E [β] E
 	
N⊙
n=1,n̸=k U(n)

T 	
N⊙
n=1,n̸=k U(n)

 
+ E

Z−1 −1
,
(3.19)

46
3
Bayesian Tensor CPD: Modeling and Inference
Table 3.1 Optimal variational density functions
Variational pdfs
Remarks
Q∗
U(k)
= MN

U(k)|M(k), I In, (k)
, ∀k
Matrix normal distribution
with mean M(k) and covariance matrix (k)
given in (3.19) and (3.20), respectively
Q∗(zl) = GIG(zl|al, bl, λl), ∀l
Generalized inverse Gaussian distribution with
parameters {al, bl, λl} given in (3.21)–(3.23)
Q∗(β) = gamma(β|e, f )
Gamma distribution with shape e and rate f
given in (3.24), (3.25)
and mean matrix
M(k) = Y(k)E [β]
	
N⊙
n=1,n̸=k E

U(n)
(k).
(3.20)
In (3.19) and (3.20), Y(k) is a matrix obtained by unfolding the tensor Y along its
kth dimension, and the multiple Khatri–Rao products
N⊙
n=1,n̸=k A(n) = A(N) ⊙A(N−1)
⊙· · · ⊙A(k+1) ⊙A(k−1) ⊙· · · ⊙A(1). The expectations are taken with respect to
the corresponding variational pdfs of the arguments. For the optimal variational pdf
Q(zl), by using the conjugacy result in Property 3.1, it can be derived to be a GIG
distribution GIG(zl|al, bl, λl) with parameters
al = a0
l ,
(3.21)
bl = b0
l +
N

n=1
E

U(n)
:,l
T
U(n)
:,l

,
(3.22)
λl = λ0
l −1
2
N

n=1
In.
(3.23)
Finally, the optimal variational pdf Q(β) was derived to be a gamma distribution
gamma(β|e, f ) with parameters
e = ϵ + 1
2
N

n=1
In,
(3.24)
f = ϵ + 1
2E

∥Y −U(1), . . . , U(N)∥2
F

.
(3.25)
In (3.19)–(3.25), there are several expectations to be computed. They can be
obtained either from the statistical literatures or similar results in related works
[1, 3–9]. For easy reference, we listed the expected results needed for (3.19)–(3.25)
in Table 3.2, where
N⊛
n=1,n̸=k A(n) = A(N) ⊛A(N−1) ⊛· · · ⊛A(k+1) ⊛A(k−1) ⊛· · · ⊛
A(1) is the multiple Hadamard products.

3.4 PCPD-GH, PCPD-GG: Inference Algorithm
47
Table 3.2 Computation results of expectations of PCDP-GH model
Expectations
Computation results
E

U(k) 
, ∀k
M(k), ∀k
E [zl] , ∀l

bl
al
 1
2 Kλl +1(
√albl)
Kλl (
√albl)
E

z−1
l

, ∀l

bl
al
−1
2 Kλl −1(
√albl)
Kλl (
√albl)
E [β]
e
f
E

U(n)
:,l
T
U(n)
:,l


M(n)
:,l
T
M(n)
:,l + In(n)
l,l
E
 	
N⊙
n=1,n̸=k U(n)

T 	
N⊙
n=1,n̸=k U(n)

 
N⊛
n=1,n̸=k

M(n) T M(n) + In(n)
E

∥Y −U(1), . . . , U(N)∥2
F
 
∥Y ∥2
F +Tr
 N⊛
n=1

M(n)T M(n) + In(n)
−2Tr

Y(1) N⊙
n=2 M(n)
M(1)T 
3.4.2
Setting the Hyper-parameters
From Table 3.1, it can be found that the shape of the variational pdf Q(U(k)) is
affected by the variational pdf {Q(zl)}L
l=1. For each Q(zl), as seen in (3.21)–(3.23),
its shape relies on the pre-selected hyper-parameters {a0
l , b0
l , λ0
l }. In practice, we
usually have no prior knowledge about the sparsity level before assessing the data,
and a widely adopted approach is to make the prior non-informative.
In previous works using Gaussian-gamma prior [1, 3–9], hyper-parameters are
set equal to very small values in order to approach a non-informative prior. Although
nearly zero hyper-parameters lead to an improper prior, the derived variational pdf is
still proper since these parameters are updated using information from observations.
Therefore,intheseworks,thestrategyofusinganon-informativepriorisvalid.Onthe
other hand, for the employed GH prior, non-informative prior requires {a0
l , b0
l , λ0
l }
all go to zero, which however would lead to an improper variational pdf Q(zl),
since its parameter al = a0
l is ﬁxed (as seen in (3.21)). This makes the expectation
computation E[zl] in Table 3.2 problematic.
To tackle this issue, another viable approach is to optimize these hyper-parameters
{a0
l , b0
l , λ0
l } so that they can be adapted during the procedure of model learning.
However, as seen in (3.14), these three parameters are coupled together via the
nonlinear modiﬁed Bessel function, and thus optimizing them jointly is prohibitively
difﬁcult. Therefore, [12] proposes to only optimize the most critical one, i.e., a0
l ,
since it directly determines the shape of Q(zl) but will not be updated in the learning
procedure. For the other two parameters {b0
l , λ0
l }, as seen in (3.22) and (3.23), since
they are updated with model learning results or tensor dimension, according to the
Bayesian theory, their effects on the posterior distribution would become negligible

48
3
Bayesian Tensor CPD: Modeling and Inference
when the observation tensor is large enough. This justiﬁes the optimization of a0
l
while not {b0
l , λ0
l }.
For optimizing a0
l , following related works [13], a conjugate hyper-prior p(a0
l ) =
gamma(a0
l |κa1, κa2)isintroducedtoensurethepositivenessofa0
l duringtheoptimiza-
tion. To bypass the nonlinearity from the modiﬁed Bessel function, we set b0
l →0
so that Kλ0
l
	
a0
l b0
l

becomes a constant. In the framework of VI, after ﬁxing other
variables, it has been derived in [12] that the hyper-parameter a0
l is updated via
a0
l = κa1 + λ0
l
2 −1
κa2 + E[zl]
2
.
(3.26)
Notice that it requires κa1 > 1 −λ0
l /2 and κa2 ≥0 to ensure the positiveness of a0
l .
3.5
Algorithm Summary and Insights
From the equations above, it can be seen that the statistics of each variational pdf
rely on other variational pdfs. Therefore, they need to be updated in an alternating
fashion, giving rise to an iterative algorithm summarized in Algorithm 4. To gain
more insights from the proposed algorithm, discussions on its convergence property,
computational complexity, and automatic tensor rank learning are presented in the
following.
3.5.1
Convergence Property
Notice that the algorithm is derived under the mean-ﬁeld VI framework [13, 14].
In particular, in each iteration, after ﬁxing other variational pdfs, the problem that
optimizes a single variational pdf has been shown to be convex and has a unique
solution [13, 14]. By treating each update step in mean-ﬁeld VI as a block coordinate
descent (BCD) step over the functional space, the limit point generated by the VI
algorithm is at least a stationary point of the KL divergence [13, 14].
3.5.2
Automatic Tensor Rank Learning
During the iterations, the mean of parameter z−1
l
(denoted by m[z−1
l ]) will be learned
using the updated parameters of other variational pdfs as seen in Algorithm 4. Due
to the sparsity-promoting nature of the GH prior, some of m[z−1
l ] will take very large
values, e.g., in the order of 106. Since the inverse of {m[z−1
l ]}L
l=1 contribute to the
covariance matrix of each factor matrix (k) in (3.27), which scales the columns

3.5 Algorithm Summary and Insights
49
Algorithm 4 PCPD-GH(Y, L)
Initializations: Choose L > R and initial values {

M(n) 0 ,

(n) 0}N
n=1, {m[z−1
l
]0, a0
l , b0
l , λ0
l }L
l=1,
e0, f 0. Choose κa1 > −λ0
l /2 and κa2 ≥0.
Iterations:
For the iteration t + 1 (t ≥0),
For k = 1, . . . , N, update the parameters of Q(U(k))t+1:

(k)t+1
=
 et
f t
N⊛
n=1,n̸=k
 
M(n)sT 
M(n)s
+ Jn

(n)s 
+ diag
"
m[z−1
1 ]t, m[z−1
2 ]t, ..., m[z−1
L ]t# −1
,
(3.27)

M(k)t+1
= Y(k) et
f t

N⊙
n=1,n̸=k

M(n)s
 
(n)t+1
,
(3.28)
where s denotes the most recent update index, i.e., s = t + 1 when n < k, and s = t otherwise.
Update the parameters of Q(zl)t+1:
at+1
l
= [a0
l ]t,
(3.29)
bt+1
l
= b0
l +
N

n=1
 	
M(n)
:,l
t+1
T 
M(n)
:,r
t+1
+ Jn

(n)
l,l
t+1 
,
(3.30)

λl
 t+1 = λ0
l −1
2
N

n=1
Jn,
(3.31)
m[z−1
l
]t+1 =

bt+1
l
at+1
l
−1
2 K[λl]t+1−1
	
at+1
l
bt+1
l

K[λl]t+1
	
at+1
l
bt+1
l

 ,
(3.32)
m[zl]t+1 =

bt+1
l
at+1
l
 1
2 K[λl]t+1+1
	
at+1
l
bt+1
l

K[λl]t+1
	
at+1
l
bt+1
l

 .
(3.33)
Update the parameters of Q(β)t+1:
et+1 = ϵ +
N
n=1 Jn
2
,
(3.34)
f t+1 = ϵ + ft+1
2 ,
(3.35)
where ft+1 is computed using the result in the last row of Table 3.2 with {M(n), (n)} being replaced
by {

M(n) t+1 ,

(n) t+1}, ∀n.
Update the hyper-parameter [a0
l ]t+1:
[a0
l ]t+1 = κa1 + λ0
l
2 −1
κa2 + m[zl]t+1
2
.
(3.36)
Until Convergence

50
3
Bayesian Tensor CPD: Modeling and Inference
in each factor matrix in (3.28), a very large m[z−1
l ] will shrink the lth column of each
factor matrix to all zero. Then, by enumerating how many non-zero columns are in
each factor matrix, the tensor rank can be automatically learned.
In practice, to accelerate the learning algorithm, on-the-ﬂy pruning is widely
employed in Bayesian tensor research. In particular, in each iteration, if some of
the columns in each factor matrix are found to be indistinguishable from all zeros, it
indicates that these columns play no role in interpreting the data, and thus they can be
safely pruned. This pruning procedure will not affect the convergence behavior of the
algorithm, since each pruning is equivalent to restarting the algorithm for a reduced
probabilistic model with the current variational pdfs acting as the initializations.
Note that the pruning would remove a column permanently. If the algorithm,
fortunately, jumps out from one inferior local minima, the columns once deemed
“irrelevance” might recover their importance. To address this, the birth process,
which is opposite to the pruning process (also called the death process), can be
adopted [13, 15]. Exploiting such schemes might further improve the tensor rank
learning capability, especially in very low SNR and/or very high tensor rank regimes.
However, from the extensive experiments, this issue does not frequently appear in a
wide range of SNRs and tensor ranks.
3.5.3
Computational Complexity
For Algorithm 4, in each iteration, the computational complexity is dominated by
updatingthefactormatrices,costing O(N N
n=1 JnL2 + L3 N
n=1 Jn).Therefore,the
computational complexity of Algorithm 4 is O(q(N N
n=1 JnL2 + L3 N
n=1 Jn))
where q is the iteration number at convergence. The complexity is comparable to
that of the inference algorithm using Gaussian-gamma prior [1].
3.5.4
Reducing to PCPD-GG
Now we show how the PCPD-GH algorithm (Algorithm 4) can be reduced to the
PCPD-GG algorithm, which is obtained from the probabilistic tensor CPD model
with GG prior (see Sect.3.2 and Fig.3.3).
When a0
l →0 and λ0
l < 0, as shown in Sect.3.2, the GH prior reduces to the GG
prior. Under this setting, there is no need to update a0
l , and thus Eqs.(3.29) and (3.36)
in Algorithm 4 can be removed. With the value of a0
l goes to zero, other updating
equations are simpliﬁed accordingly, resulting in the PCPD-GG algorithm, which is
summarized in Algorithm 5.

3.6 Non-parametric Modeling: PCPD-MGP
51
Algorithm 5 PCPD-GG(Y, L)
Initializations: Choose L > R and initial values {

M(n) 0 ,

(n) 0}N
n=1, {m[z−1
l
]0, b0
l , λ0
l }L
l=1,
e0, f 0.
Iterations:
For the iteration t + 1 (t ≥0),
For k = 1, . . . , N, update the parameters of Q(U(k))t+1:

(k)t+1
=
 et
f t
N⊛
n=1,n̸=k
 
M(n)sT 
M(n)s
+ Jn

(n)s 
+ diag
"
m[z−1
1 ]t, m[z−1
2 ]t, ..., m[z−1
L ]t# −1
,
(3.37)

M(k)t+1
= Y(k) et
f t
	
N⊙
n=1,n̸=k

M(n)s
 
(n)t+1
,
(3.38)
where s denotes the most recent update index, i.e., s = t + 1 when n < k, and s = t otherwise.
Update the parameters of Q(zl)t+1:
bt+1
l
= b0
l +
N

n=1
 	
M(n)
:,l
t+1
T 
M(n)
:,r
t+1
+ Jn

(n)
l,l
t+1 
,
(3.39)
[λl]t+1 = λ0
l −1
2
N

n=1
Jn,
(3.40)
m[z−1
l
]t+1 = −[λl]t+1
bt+1
l
/2
(3.41)
Update the parameters of Q(β)t+1:
et+1 = ϵ +
N
n=1 Jn
2
,
(3.42)
f t+1 = ϵ + ft+1
2 ,
(3.43)
where ft+1 is computed using the result in the last row of Table 3.2 with {M(n), (n)} being replaced
by {

M(n) t+1 ,

(n) t+1}, ∀n.
Until Convergence
3.6
Non-parametric Modeling: PCPD-MGP
In this section, we introduce non-parametric modeling and exemplify it using the
multiplicative gamma process (MGP). Before establishing the non-parametric mod-
eling of CPD using MGP, we review the deﬁnition of CPD and introduce another
equivalent formulation that will be utilized in this section. In particular, by explic-
itly introducing a coefﬁcient λr of each rank-1 component in (3.1), we arrive at an
equivalent formulation of tensor CPD:

52
3
Bayesian Tensor CPD: Modeling and Inference
min
{U(n)}N
n=1,{λr}R
r=1
∥Y −
R

r=1
λrU(1)
:,r ◦U(2)
:,r ◦· · · ◦U(N)
:,r



X≜U(1),U(2),...,U(N);λ
∥2
F,
(3.44)
where the shorthand notation Kruskal operator now includes the rank-1 component
coefﬁcients λ =
λ1, . . . , λR
 
to represent this formulation [16].
From (3.44), it is seen that another viable approach to achieve tensor rank learning
is to place sparsity-promoting prior on the rank-1 component coefﬁcients {λr}R
r=1,
rather than on the columns of factor matrices as done in previous sections. In par-
ticular, we initialize with an over-parameterized model for CPD with L ≥R rank-1
components. Due to the sparsity-promoting nature of the prior on the coefﬁcients, the
coefﬁcients of the redundant rank-1 components will be driven to zero. Therefore,
tensor rank learning is achieved by counting the rank-1 components with non-zero
coefﬁcients.
While the GSM prior introduced earlier can also be utilized for modeling sparsity
on rank-1 component coefﬁcients {λl}L
l=1, we introduce in this section another class
of sparsity-promoting modeling, namely non-parametric modeling, by using MGP
[17] as an example. Speciﬁcally, MGP is placed on rank-1 component coefﬁcients
λl,
p(λl|{δk}l
k=1) = N
⎛
⎝λl|0,
 l
k=1
δk
−1⎞
⎠,
(3.45)
p(δl) = gamma(δl|ac, 1),
(3.46)
where ac > 1 is a pre-determined hyper-parameter. The MGP prior presented in
(3.45) and (3.46) incorporates the prior belief that the precision of λl is more likely
to shrink to zero as the index l increases, since the precision is a product of increasing
numbers of gamma-distributed random variables.
Given that (3.44) is a least-squares cost function, the corresponding Gaussian
likelihood function is expressed as
p(Y|{U(n)}N
n=1, λ, β) ∝exp
	
−β
2
((Y −U(1), U(2), . . . , U(N); λ
((2
F

.
(3.47)
To complete the Bayesian modeling, the prior for factor matrices {U(n)}N
n=1 is spec-
iﬁed as independent columns with each having zero-mean unit-variance Gaussian
distribution,
p({U(n)}N
n=1) =
N

n=1
L

l=1
N(U(n)
:,l |0In×1, IIn),
(3.48)

3.7 PCPD-MGP: Inference Algorithm
53
and the precision β is assigned with a Gamma prior Ga(β|ϵ, ϵ), where ϵ is chosen as a
very small number (e.g., 10−6). To summarize, the PCPD-MGP model is represented
by the joint probability density function of tensor data Y and random variables
 = {{U(n)}N
n=1, λ, {δl}L
l=1, β}:
p(Y, ) = p(Y|{U(n)}N
n=1, λ, β)p({U(n)}N
n=1)
L

l=1
p(λl|{δk}l
k=1)
L

l=1
p(δl)p(β).
(3.49)
3.7
PCPD-MGP: Inference Algorithm
The exact inference of random variables  = {{U(n)}N
n=1, λ, {δl}L
l=1, β} from ten-
sor data Y requires the computation of the posterior distribution p(|Y), which
is intractable due to the multiple integrations. Different from the Gibbs sam-
pling method adopted in [17], we employ here the mean-ﬁeld variational infer-
ence (MF-VI) to minimize the Kullback–Leibler divergence between the poste-
rior and the variational pdf Q(), where Q() lies in the mean-ﬁeld family, i.e.,
Q() = K
k=1 Q(k). As derived in Chap.2, the general formula of the optimal
variational pdf is
Q∗(k) =
exp

E
j̸=k Q(k)

ln p (Y, θ)
 
!
exp

E
j̸=k Q( j)

ln p (Y, , )
 
dk
.
(3.50)
For PCPD-MGP model, the mean-ﬁeld family is assumed as Q() = N
n=1
Q(U(n)) × L
l=1 Q(λl) L
l=1 Q(δl)Q(β). By substituting (3.49) into (3.50), the
optimal variational pdfs for various variables can be derived. In particular, the
optimal variational pdf Q∗(U(n)) is derived to be a matrix normal distribution
MN

U(n)|M(n), IIn, (n)
with the covariance matrix
(n) =

E [β] E [] E
 	
N⊙
k=1,k̸=n U(k)

T 	
N⊙
k=1,k̸=n U(k)

 
E []
E [β] E

2 
diag

E
 	
N⊙
k=1,k̸=n U(k)

T 	
N⊙
k=1,k̸=n U(k)

 
+ IIn
−1
,
(3.51)

54
3
Bayesian Tensor CPD: Modeling and Inference
and mean matrix
M(n) = Y(n)E [β]
	
N⊙
k=1,k̸=n E

U(k) 
E [] (n).
(3.52)
In (3.51) and (3.52), Y(n) is a matrix obtained by unfolding the tensor Y along its
nth dimension, the multiple Khatri–Rao products
N⊙
k=1,k̸=n A(k) = A(N) ⊙A(N−1) ⊙
· · · ⊙A(n+1) ⊙A(n−1) ⊙· · · ⊙A(1), and  = diag(λ).
On the other hand, the functional form of the optimal variational pdf Q∗(λl)
coincides with the normal distribution N (λl|ml, sl) with the variance
sl =
 l
k=1
E [δk] + E [β] E

< Xl, Xl >
 
−1
,
(3.53)
and mean
ml = slE [β]
⎛
⎝< Y, E

Xl
 
> −
L

k=1,k̸=l
E [λk] E

< Xk, Xl >
 
⎞
⎠,
(3.54)
where Xl denotes the lth rank-1 component Xl = U(1)
:,l ◦U(2)
:,l ◦· · · ◦U(N)
:,l , and the
inner product between two tensors < X, Y > has been deﬁned in (1.6).
Finally, the optimal variational pdf Q∗(δl) was derived to be a Gamma distribution
gamma (δl|cl, dl) with the parameters
cl = ac + 1
2(L −l + 1),
(3.55)
dl = 1 + 1
2
L

k=l
E

λ2
k
 
k
j=1, j̸=l
E

δ j
 
.
(3.56)
Furthermore, the optimal variational pdf Q∗(β) is also a Gamma distribution
gamma (β|a, b) with the parameters
a = ϵ + 1
2
N

n=1
In,
(3.57)
b = ϵ + 1
2E
((Y −U(1), U(2), . . . , U(N); λ
((2
F

.
(3.58)

3.7 PCPD-MGP: Inference Algorithm
55
Table 3.3 Computation results of expectations of PCDP-MGP model
Expectations
Computation results
E

U(n) 
, ∀n
M(n)
E [λl] , ∀l
ml
E

λ2
l
 
, ∀l
m2
l + sl
E []
diag{m1, . . . , mL} ≜M
E

2 
diag{m2
1 + s1, . . . , m2
L + sL} ≜S
E [δl] , ∀l
cl
dl
E

Xl
 
, ∀l
a
b
E

< Xk, Xl >
 
, ∀k,l
N
n=1 M(n)T
:,k
M(n)
:,l + In(n)
k,l
E
 	
N⊙
k=1,k̸=n U(k)

T 	
N⊙
k=1,k̸=n U(k)

 
N⊛
k=1,k̸=n

M(k) T M(k) + Ik(k)
E
((Y −U(1), U(2), . . . , U(N); λ
((2
F

∥Y∥2
F + Tr
 N⊛
n=2

M(n)T M(n) + In(n)
⊛

M

M(1)T M(1) + I1(1)
M
+Sdiag

M(1)T M(1) + I1(1) 
−2 < Y, M(1), . . . , M(N);

m1, . . . , mL

 >
In (3.51)–(3.58), there are several expectations to be computed, and they are
summarized in Table3.3. As discussed in previous chapters, the MF-VI algorithm
estimates the variational pdfs in an alternating fashion, since the update of each
variational pdf depends on the statistics from other variational pdfs. This gives rise to
Algorithm 6.

56
3
Bayesian Tensor CPD: Modeling and Inference
Algorithm 6 PCPD-MGP(Y, L)
Initializations: Choose L > R, ac > 1, and initial values {

M(n) 0 ,

(n) 0}N
n=1, {m0
l , s0
l }L
l=1,
a0, b0. Set M0
 = {m0
1, . . . , m0
L}, S0
 = {(m0
1)2 + s0
1, . . . , (m0
L)2 + s0
L}.
Iterations:
For the iteration t + 1 (t ≥0),
For n = 1, . . . , N, update the parameters of Q(U(n))t+1:

(n)t+1
=
at
bt Mt

N⊛
k=1,k̸=n
 
M(k)sT 
M(k)s
+ Ik

(k)s 
Mt

× at
bt St
diag
 
M(k)sT 
M(k)s
+ Ik

(k)s 
+ In
−1
,
(3.59)

M(n)t+1
= Y(n) at
bt
	
N⊙
k=1,k̸=n

M(k)s
Mt


(k)t+1
,
(3.60)
where s denotes the most recent update index, i.e., s = t + 1 when n < k, and s = t otherwise.
Update the parameters of Q(λl)t+1:
st+1
l
=
 l
k=1
ct
l
dt
l
+ at
bt
N

n=1

M(n)
:,l
sT 
M(n)
:,l
s
+ In(n)
l,l
−1
(3.61)
mt+1
l
= st+1
l
at
bt

< Y, 

M(1)
:,l
s
, . . . ,

M(N)
:,l
s
 >
−
L

k=1,k̸=l
mt
k
N

n=1

M(n)
:,k
sT 
M(n)
:,l
s
+ In(n)
k,l

.
(3.62)
Set Mt+1

= {mt+1
1
, . . . , mt+1
L
}, St+1

= {(mt+1
1
)2 + st+1
1
, . . . , (mt+1
L
)2 + st+1
L
}.
Update the parameters of Q(δl)t+1:
ct+1
l
= ac + 1
2(L −l + 1)
(3.63)
dt+1
l
= 1 + 1
2
L

k=l
	
mt+1
l
2
+ st+1
l

k
j=1, j̸=l
cs
j
ds
j
,
(3.64)
where s denotes the most recent update index, i.e., s = t + 1 when j < l, and s = t otherwise.
Update the parameters of Q(β)t+1:
at+1 = ϵ +
N
n=1 In
2
,
(3.65)
bt+1 = ϵ + bt+1
2
,
(3.66)
where bt+1 is computed using the result in the last row of Table 3.3 with {M(n), (n)}, {ml}, M, S
being replaced by {[M(n)]t+1,

(n) t+1}, ∀n, {mt+1
l
}, ∀l, Mt+1
 , St+1
 .
Until Convergence

References
57
References
1. Q. Zhao, L. Zhang, A. Cichocki, Bayesian cp factorization of incomplete tensors with automatic
rank determination. IEEE Trans. Pattern Anal. Mach. Intell. 37(9), 1751–1763 (2015)
2. M. Mørup, L.K. Hansen, Automatic relevance determination for multi-way models. J.
Chemom.: J. Chemom. Soc. 23(7–8), 352–363 (2009)
3. Q. Zhao, G. Zhou, L. Zhang, A. Cichocki, S.-I. Amari, Bayesian robust tensor factorization for
incomplete multiway data. IEEE Trans. Neural Netw. Learn. Syst. 27(4), 736–748 (2015)
4. L. Cheng, Y.-C. Wu, H.V. Poor, Probabilistic tensor canonical polyadic decomposition with
orthogonal factors. IEEE Trans. Signal Process. 65(3), 663–676 (2016)
5. L. Cheng, Y.-C. Wu, H.V. Poor, Scaling probabilistic tensor canonical polyadic decomposition
to massive data. IEEE Trans. Signal Process. 66(21), 5534–5548 (2018)
6. L. Cheng, X. Tong, S. Wang, Y.-C. Wu, H.V. Poor, Learning nonnegative factors from tensor
data: probabilistic modeling and inference algorithm. IEEE Trans. Signal Process. 68, 1792–
1806 (2020)
7. Z. Zhang, C. Hawkins, Variational bayesian inference for robust streaming tensor factorization
and completion, in 2018 IEEE International Conference on Data Mining (ICDM) (IEEE, 2018),
pp. 1446–1451
8. J. Luan, Z. Zhang, Prediction of multidimensional spatial variation data via bayesian tensor
completion. IEEE Trans. Comput.-Aided Design Integr. Circuits Syst. 39(2), 547–551 (2019)
9. Q. Zhao, L. Zhang, A. Cichocki, Bayesian sparse tucker models for dimension reduction and
tensor completion (2015). arXiv:1505.02343
10. L. Thabane, M. Saﬁul Haq, On the matrix-variate generalized hyperbolic distribution and its
bayesian applications. Statistics 38(6), 511–526 (2004)
11. S.D. Babacan, S. Nakajima, M.N. Do, Bayesian group-sparse modeling and variational infer-
ence. IEEE Trans. Signal Process. 62(11), 2906–2921 (2014)
12. L. Cheng, Z. Chen, Q. Shi, Y.-C. Wu, S. Theodoridis, Towards ﬂexible sparsity-aware modeling:
Automatic tensor rank learning using the generalized hyperbolic prior. IEEE Trans. Signal
Process. (2022)
13. M.J. Beal, Variational Algorithms for Approximate Bayesian Inference (University of London,
University College London (United Kingdom), 2003)
14. C. Zhang, J. Bütepage, H. Kjellström, S. Mandt, Advances in variational inference. IEEE Trans.
Pattern Anal. Mach. Intell. 41(8), 2008–2026 (2018)
15. P.J. Green, Reversible jump markov chain monte carlo computation and bayesian model deter-
mination. Biometrika 82(4), 711–732 (1995)
16. T.G. Kolda, B.W. Bader, Tensor decompositions and applications. SIAM Rev. 51(3), 455–500
(2009)
17. P. Rai, Y. Wang, S. Guo, G. Chen, D. Dunson, L. Carin, Scalable bayesian low-rank decom-
position of incomplete multiway tensors, in International Conference on Machine Learning
(PMLR, 2014), pp. 1800–1808

Chapter 4
Bayesian Tensor CPD: Performance
and Real-World Applications
Abstract In this chapter, extensive numerical results using synthetic datasets and
real-world datasets are presented to reveal the insights and performance of the intro-
duced algorithms in the previous chapter. Since the GH prior provides a more ﬂexible
sparsity-aware modeling than the Gaussian-gamma prior, it has the potential to act
as a better regularizer against noise corruption and to adapt to a wider range of
sparsity levels. Numerical studies have conﬁrmed the improved performance of the
PCPD-GH method over the PCPD-GG in terms of tensor rank learning and factor
matrix recovery, especially in the challenging high-rank and/or low-SNR regimes.
Note that the principle followed in PCDP-GG and PCPD-GH is a parametric way to
seek ﬂexible sparsity-aware modeling. In parallel to this path, the PCPD-MGP is a
non-parametric Bayesian CPD modeling. Due to the decaying effects of the length
scales (i.e., the variance of the rank-1 component coefﬁcient) learned through MGP,
the inference algorithm is capable of learning low tensor rank, but it has the tendency
to underestimate the tensor rank when the ground-truth rank is high, making it not
very ﬂexible in the high-rank regime. Numerical results will be presented in this
chapter to demonstrate this phenomenon.
4.1
Numerical Results on Synthetic Data
In this section, extensive numerical results are presented to compare the performance
of the algorithms using synthetic data. All experiments were conducted in Matlab
R2015b with an Intel Core i7 CPU at 2.2 GHz.
4.1.1
Simulation Setup
We consider 3D tensors X = A(1), A(2), A(3) ∈R30×30×30 with different tensor
ranks. Each element in the factor matrices {A(n)}3
n=1 is independently drawn from
a zero-mean Gaussian distribution with unit power. The observation model is Y =
X + W, where each element of the noise tensor W is independently drawn from
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023
L. Cheng et al., Bayesian Tensor Decomposition for Signal Processing and
Machine Learning, https://doi.org/10.1007/978-3-031-22438-6_4
59

60
4
Bayesian Tensor CPD: Performance and Real-World Applications
a zero-mean Gaussian distribution with variance σ 2
w. This data generation process
follows that of [1]. The SNR is deﬁned as 10 log10

var (X) /σ 2
w

[1], where var (X)
is the variance1 of the noise-free tensor X. All simulation results in this section are
obtained by averaging 100 Monte Carlo runs unless stated otherwise.
4.1.2
PCPD-GH Versus PCPD-GG
We ﬁrst compare the probabilistic CPD using GH prior (labeled as PCPD-GH) [2]
with the benchmarking algorithm using GG prior [1] (labeled as PCPD-GG).
4.1.2.1
Tensor Rank Learning
The performance of tensor rank learning is ﬁrstly evaluated. We regard the tensors
as low-rank tensors when their ranks are smaller than or equal to half of the maximal
tensor dimension, i.e., R ≤max{Jn}N
n=1/2. Similarly, high-rank tensors are those
with R > max{Jn}N
n=1/2. In particular, in Fig.4.1, we assess the tensor rank learning
performances of the two algorithms for low-rank tensors with R = {3, 6, 9, 12, 15}
and high-rank tensors with R = {18, 21, 24, 27} under SNR = 10 dB.
In Fig.4.1a, the two algorithms are both with the tensor rank upper bound L =
max{Jn}N
n=1. It can be seen that the PCPD-GH algorithm and the PCPD-GG algorithm
achieve comparable performances in learning low tensor ranks. More speciﬁcally, the
PCPD-GH algorithm achieves higher learning accuracies when R = {3, 6} while the
PCPD-GG method performs better when R = {9, 15}. However, when tackling high-
rank tensors with R > 15, as seen in Fig.4.1a, both algorithms with tensor rank upper
bound L = max{Jn}N
n=1 fail to work properly. The reason is that the upper bound
value L = max{Jn}N
n=1 results in too small sparsity level (L −R)/L to leverage the
power of the sparsity-promoting priors in tensor rank learning. Therefore, the upper
bound value should be set larger in case that the tensor rank is high.
An immediate choice is L = f × max{Jn}N
n=1 where f = 1, 2, 3, . . .. In Fig.4.1b
and c, we assess the performances of tensor rank learning for the two methods using
the upper bound L = 2 max{Jn}N
n=1 and L = 5 max{Jn}N
n=1, respectively. It can be
seen that the PCPD-GG algorithm is very sensitive to the rank upper bound value,
in the sense that its performance deteriorates signiﬁcantly for low-rank tensors after
employing the larger upper bounds. While PCPD-GG has improved performance
for high-rank tensors after adopting a larger upper bound, the chance of getting
the correct rank is still very low. In contrast, the performance of the PCPD-GH
algorithm is stable for all cases and it achieves nearly 100% accuracies of tensor
rank learning in a wide range of scenarios, showing its ﬂexibility in adapting to
different levels of sparsity. In Appendix L of [2], further numerical results on the
1 It means the empirical variance computed by treating all entries of the tensor as independent
realizations of a same scalar random variable.

4.1 Numerical Results on Synthetic Data
61
Fig. 4.1 Performance of
tensor rank learning when
the rank upper bound is a
max{Jn}N
n=1,
b 2 max{Jn}N
n=1, and
c 5 max{Jn}N
n=1
3
6
9
12
15
18
21
24
27
True Tensor Rank
0
50
100
150
Percentage of Accurate 
Tensor Rank Estimates
Rank Upper Bound: max(DimY)
PCPD-GH
PCPD-GG
   0%    0%     0%
High-Rank Tensors
Low-Rank Tensors
(a)
3
6
9
12
15
18
21
24
27
True Tensor Rank
0
50
100
150
Percentage of Accurate 
Tensor Rank Estimates
Rank Upper Bound: 2max(DimY)
PCPD-GH
PCPD-GG
Low-Rank Tensors
High-Rank Tensors
(b)
3
6
9
12
15
18
21
24
27
True Tensor Rank
0
50
100
150
Percentage of Accurate 
Tensor Rank Estimates
Rank Upper Bound: 5max(DimY)
PCPD-GH
PCPD-GG
Low-Rank Tensors
High-Rank Tensors
(c)

62
4
Bayesian Tensor CPD: Performance and Real-World Applications
-10
-5
0
5
10
15
20
SNR (dB)
0
50
100
150
Percentage of Accurate 
Tensor Rank Estimates
True Tensor Rank: 6
PCPD-GH-2max(DimY)
PCPD-GG-max(DimY)
PCPD-GG-2max(DimY)
(a)
-10
-5
0
5
10
15
20
SNR (dB)
0
50
100
150
Percentage of Accurate 
Tensor Rank Estimates
True Tensor Rank: 24
PCPD-GH-2max(DimY)
PCPD-GG-max(DimY)
PCPD-GG-2max(DimY)
(b)
Fig. 4.2 Performance of tensor rank learning versus different SNRs: a low-rank tensors and b
high-rank tensors
tensor rank learning accuracies versus different sparsity levels are presented, which
show the better performance of the PCPD-GH algorithm in a wide range of sparsity
levels.
To assess the tensor rank learning performance under different SNRs, in Fig.4.2,
the percentages of accurate tensor rank learning from the two methods are presented.
We consider two scenarios: (1) low-rank tensor with R = 6 shown in Fig.4.2a and
(2) high-rank tensor with R = 24 shown in Fig.4.2b. For the PCPD-GH algorithm,
due to its robustness to different rank upper bounds, 2 max{Jn}N
n=1 is adopted as
the upper bound value (labeled as PCPD-GH-2max(DimY)). For the PCPD-GG
algorithm, both the upper bound value max{{Jn}N
n=1} and 2 max{Jn}N
n=1 are consid-
ered (labeled as PCPD-GG-max(DimY) and PCPD-GH-2max(DimY), respectively).
From Fig.4.2, it is clear that the performance of the PCPD-GG method, for all cases,
highly relies on the choice of the rank upper bound value. In particular, when adopt-
ing 2 max{Jn}N
n=1, its performance in tensor rank learning is not good (i.e., accuracy
below 50%) for both the low-rank tensor and the high-rank tensor cases. In contrast,
when adopting max{{Jn}N
n=1}, its performance becomes much better for the low-rank
cases. In Fig.4.2a, when SNR is larger than 5 dB, the PCPD-GG with upper bound
value max{{Jn}N
n=1} achieves nearly 100% accuracy, which is very close to the accu-
racies of the PCPD-GH method. However, when the SNR is smaller than 5 dB, the
PCPD-GH method still achieves nearly 100% accuracies in tensor rank learning, but
the accuracies of the PCPD-GG method fall below 50%. For the high-rank case, as
seen in Fig.4.2b, both the PCPD-GH and the PCPD-GG methods fail to recover the
true tensor rank when SNR is smaller than 0 dB. However, when the SNR is larger
than 0 dB, the accuracies of the PCPD-GH method are near 100% while those of the
PCPD-GG at most achieve about 50% accuracy. Consequently, it can be concluded
from Fig.4.2 that the PCPD-GH method achieves more stable and accurate tensor
rank learning.

4.1 Numerical Results on Synthetic Data
63
In summary, Figs.4.1 and 4.2 show that PCPD-GH method ﬁnds the correct tensor
rank even if the initial tensor rank is exceedingly overestimated, which is a practically
useful feature since the rank is unknown in real-life cases.
4.1.2.2
Insights from Learned Length Scales
To clearly show the substantial difference between the GG and GH prior, we com-
pare the two algorithms (PCPD-GG and PCPD-GH) in terms of their learned length
scales. The length scale powers of GG and GH prior are denoted by

γ −1
l
L
l=1 and
{zl}L
l=1, respectively. To assess the patterns of learned length scales, we turn off the
pruning procedure and let the two algorithms directly output

γ −1
l
L
l=1 and {zl}L
l=1
after convergence. Since the learned length scale powers are possibly of different
sparsity patterns in different Monte Carlo trials, averaging them over Monte Carlo
trials is not informative. Instead, we present the learned values of

γ −1
l
L
l=1 and
{zl}L
l=1 in a single trial.
In particular, Fig.4.3 shows the result for a typical low-SNR and low-rank case
(SNR = −5 dB, R = 6) with rank upper bound being 60. From this ﬁgure, it can
be seen that the learned length scales of the two algorithms substantially differ from
each other, in the sense that the number of learned length scales (and the associated
components) with non-negligible magnitudes are different. For example, in Fig.4.3,
PCPD-GG recovers 7 components with non-negligible magnitudes2 (the smallest one
has value 4.3 ≫0), while PCPD-GH recovers 6 components. Note that the ground-
truth rank is 6, and PCPD-GG produces a “ghost” component with magnitude much
larger than zero. Additional simulation runs, and results of other simulation settings
(e.g., high-SNR and high-rank case: SNR = 5 dB, R = 21) are included in [2], from
which similar conclusions can be drawn.
4.1.2.3
Insights on Noise Precision Learning
The learning of the noise precision β is crucial for reliable inference, since incorrect
estimates will cause over-/under-regularization. To examine how the speed of noise
learning affects the tensor rank (sparsity) learning when SNR is low (SNR = −5 dB),
we turn on the pruning and present the rank learning results over iterations in three
cases: (1) Case I: update β every iteration; (2) Case II: update β every 10th iteration;
(3) Case III: update β every 20th iteration. In Fig.4.4, the rank estimates are averaged
over 100 Monte Carlo runs. It can be seen that updating the noise precision β at earlier
iterations will help the learning process to unveil the sparsity pattern more quickly.
Then, we investigate under which scenario slowing the noise precision learning
will be helpful. We consider a very low-SNR case, that is, SNR = −10 dB, and
2 The magnitude of the lth component is deﬁned as
3
n=1

A(n)
:,l
	T
A(n)
:,l

 1
2
[1].

64
4
Bayesian Tensor CPD: Performance and Real-World Applications
0
10
20
30
40
50
60
Length scale index
0
0.2
0.4
0.6
0.8
1
1.2
Power
Monte-Carlo Run: 1; SNR = -5 dB, R = 6; PCPD-GG;
Very small 
length scale
 powers:
~ 0.02
10 times larger than those  small length
scale powers, thus not disregarded.
Corresponding component magnitude: 
4.3 >> 0 
(a)
0
10
20
30
40
50
60
Length scale index
0
0.1
0.2
0.3
0.4
0.5
0.6
Power
Monte-Carlo Run: 1; SNR = -5 dB, R = 6; PCPD-GH;
Very small 
length scale
powers:
~ 3×  10-8
(b)
Fig. 4.3 a The powers of learned length scales (i.e.,

γ −1
l
L
l=1) for PCPD-GG; b The powers
of learned length scales (i.e., {zl}L
l=1) for PCPD-GH. It can be seen that PCPD-GG recovers 7
components with non-negligible magnitudes, while PCPD-GH recovers 6 components. The two
algorithms are with the same upper bound value: 60
Fig. 4.4 Tensor rank
estimates of PCPD-GH
versus iteration number
(averaged over 100 Monte
Carlo runs) with different
noise precision learning
speeds
20
40
60
80
100
Iteration number
0
10
20
30
40
50
60
Rank estimates
SNR = -5 dB, R = 6
Update β every iteration
Update β every 
20-th iteration
Update β every 
10-th iteration
X: 76
Y: 6
X: 44
Y: 6
X: 39
Y: 6
then evaluate the percentages of accurate rank learning over 100 Monte Carlo runs.
The results are (1) Case I: 76%; (2) Case II: 100%; (3) Case III: 100%. In other
words, when the noise power is very large (e.g., SNR = −10 dB), slowing the noise
precision learning will make the algorithm more robust to the noises.
Finally, from further experiments in [2], it is found that if we ﬁx the noise precision
β and do not allow its update, PCPD-GH fails to identify the underlying sparsity
pattern (tensor rank). Particularly, a small value of β (e.g., 0.01) leads to over-
regularization, thus causing underestimation of non-zero components, while a large
value of β (e.g., 100) causes under-regularization, thus inducing overestimation of
non-zero components. This shows the importance of modeling and updating of noise
precision.

4.1 Numerical Results on Synthetic Data
65
4.1.2.4
Other Performance Metrics
Additional results and discussions on the run time, tensor recovery root mean square
error (RMSE), algorithm performance under factor matrix correlation, convergence
behavior of the PCPD-GH algorithm in terms of evidence lower bound (ELBO), and
hyper-parameter learning of PCPD-GG are also included in [2]. The key messages
of these simulation results are given as follows: (1) PCPD-GH generally costs more
run time than PCPD-GG; (2) Incorrect estimation of tensor rank degrades the tensor
signal recovery; (3) PCPD-GH performs well under factor matrix correlation; (4)
PCPD-GHmonotonicallyincreasestheELBO;(5)Furtherupdateofhyper-parameter
of PCPD-GH does not help too much in improving rank estimation in the low-SNR
regime. Interested readers can refer to the details in [2].
4.1.3
Comparisons with Non-parametric PCPD-MGP
After comparing to the parametric PCPD-GG, further comparisons are performed
with the non-parametric Bayesian tensor CPD using MGP prior (labeled as PCPD-
MGP).3 The initializations and hyper-parameters settings follow those used in [3].
4.1.3.1
Tensor Rank Learning
Weﬁrstassesstheperformanceoftensorranklearningofthethreealgorithms(PCPD-
MGP, PCPD-GG, and PCPD-GH). The simulation settings follow those of Figs.4.1
and 4.2.
In Table4.1, the percentages of accurate tensor rank estimates under different
rank upper bound values are presented. From the table, we can draw the following
conclusions. (1) When the tensor rank is low (e.g., R = 3, 6, 9) and the SNR is high
(e.g., SNR = 10 dB), PCPD-MGP correctly learns the tensor rank over 100 Monte
Carlo trials under different rank upper bound values. Its performance is insensitive
to the selection of the rank upper bound values, due to the decaying effects of the
learned length scales [3]. Therefore, in the low-rank and high-SNR scenario, the rank
learning performance of PCPD-MGP is comparable to that of PCPD-GH and much
better than PCPD-GG. (2) When the tensor rank is high (e.g., R = 18, 21, 24, 27),
PCPD-MGP fails to learn the correct tensor rank under different rank upper bound
values and even perform worse than PCPD-GG, since the decaying effects of learned
length scales tend to underestimate the tensor rank. On the contrary, the PCPD-GH
method always accurately estimates the high tensor ranks.
In Table4.2, we present the rank estimation performance under different SNRs,
with the same settings as those of Fig.4.2. It can be seen that for low tensor rank
case (e.g., R = 6), PCPD-MGP shows good performance when SNR is larger than
3 We appreciate Prof. Piyush Rai for sharing the code and data with us.

66
4
Bayesian Tensor CPD: Performance and Real-World Applications
Table 4.1 Performance of tensor rank learning under different rank upper bound values. Algorithm: PCPD-GH, PCPD-MGP, PCPD-GG; SNR = 10 dB. The
simulation settings are the same as those of Fig.4.1
Rank upper bound
True tensor rank R
3
6
9
12
15
GH
(%)
MGP
(%)
GG
(%)
GH
(%)
MGP
(%)
GG
(%)
GH
(%)
MGP
(%)
GG
(%)
GH
(%)
MGP
(%)
GG
(%)
GH
(%)
MGP
(%)
GG
(%)
max(DimY)
100
100
88
100
100
98
98
100
100
100
98
100
94
90
98
2max(DimY)
100
100
36
100
100
26
100
100
20
100
94
24
100
64
24
5max(DimY)
100
100
14
100
100
10
100
100
8
100
26
14
100
24
18
Rank upper bound
True tensor rank R
18
21
24
27
GH
(%)
MGP
(%)
GG
(%)
GH
(%)
MGP
(%)
GG
(%)
GH
(%)
MGP
(%)
GG
(%)
GH
(%)
MGP
(%)
GG
(%)
max(DimY)
8
0
19
0
0
0
0
0
0
0
0
0
2max(DimY)
100
0
14
100
0
30
100
0
26
100
0
50
5max(DimY)
100
0
12
100
0
14
100
0
16
100
0
14

4.1 Numerical Results on Synthetic Data
67
Table 4.2 Performance of tensor rank learning under different SNRs. Algorithm: PCPD-GG,
PCPD-MGP; Upper bound value: 2max(DimY). The simulation settings are the same as those
of Fig.4.2
True tensor rank
SNR (dB)
−10
−5
0
5
GH
(%)
MGP
(%)
GG
(%)
GH
(%)
MGP
(%)
GG
(%)
GH
(%)
MGP
(%)
GG
(%)
GH
(%)
MGP
(%)
GG
(%)
6
92
2
10
100
78
8
100
90
12
100
98
28
24
0
0
0
0
0
18
82
0
30
100
0
38
True tensor rank
SNR (dB)
10
15
20
GH
(%)
MGP
(%)
GG
(%)
GH
(%)
MGP
(%)
GG
(%)
GH
(%)
MGP
(%)
GG
(%)
6
100
100
26
100
100
16
100
100
8
24
100
00
26
100
0
22
100
0
34
−5 dB. It outperforms the PCPD-GG method, but it is still not as good as PCPD-GH.
At SNR = −10 dB, PCPD-MGP fails to correctly estimate the tensor rank, while
PCPD-GH shows good performance in a wider range of SNRs (from −10 to 20 dB).
Furthermore, when the tensor rank becomes large (e.g., R = 24), PCPD-MGP fails
to learn the underlying true tensor rank, making it inferior to PCPD-GH (and even
PCPD-GG) in the high-rank regime.
4.1.3.2
Insights from Learned Length Scales
To reveal more insights, we present the learned length scales (without pruning)
of PCPD-MPG. Following the notations in [3], the learned length scale powers of
PCPD-MGP are denoted by

τ −1
l
=
l
k=1 δk
−1L
l=1
.
Two typical cases are considered: (1) Case I: SNR = 5 dB, R = 21, corresponding
to high rank and high SNR; (2) Case II: SNR = −10 dB, R = 6, corresponding to
very low SNR and low rank. For each case, we present the learned length scales
in a single trial in Figs.4.5 and 4.6, respectively. From these ﬁgures, we have the
following observations. (1) Due to the decaying effect of the MGP prior, the learned
length scale power τ −1
l
quickly decreases as l becomes larger. This drives PCPD-
MGP to fail to recover the sparsity pattern of the high-rank CPD (e.g., R = 21),
in which a large number of length scale powers should be much larger than zero;
see Fig.4.5a. In contrast, without the decaying effect, the PCPD-GH successfully
identiﬁes the 21 non-negligible components, as seen in Fig.4.5b. (2) When the SNR
is very low (e.g., SNR = −10 dB) and the rank is low (e.g., R = 6), while the rank
estimation given by PCPD-MGP is close to the ground truth, its sparsity pattern of
the learned length scales is not as accurate as that of PCPD-GH (see Fig.4.6). This

68
4
Bayesian Tensor CPD: Performance and Real-World Applications
0
10
20
30
40
50
60
Length scale index
0
10
20
30
40
50
60
70
Power
Very small 
decaying
length scale
powers:
1e-2 ~ 1e-18
Monte-Carlo Run: 1; SNR = 5 dB, R = 21; PCPD-MGP;
(a)
0
10
20
30
40
50
60
Length scale index
0
0.1
0.2
0.3
0.4
0.5
0.6
Power
Monte-Carlo Run: 1; SNR = 5 dB, R = 21; PCPD-GH;
Very small 
length 
scale 
powers:
~ 9×  10-7
(b)
Fig. 4.5 a The powers of learned length scales (i.e., {τ −1
l
}L
l=1) for PCPD-MGP; b The powers
of learned length scales (i.e., {zl}L
l=1) for PCPD-GH. It can be seen that PCPD-MGP recovers 15
components with non-negligible magnitudes, while PCPD-GH recovers 21 components. The two
algorithms are with the same upper bound value L = 60. Simulation setting: SNR = 5 dB, R = 21
0
10
20
30
40
50
60
Length scale index
0
0.2
0.4
0.6
0.8
1
1.2
Power
Monte-Carlo Run: 1; SNR = -10 dB, R = 6;PCPD-MGP;
Very small decaying 
length scale powers: 1e-2 ~ 1e-18.
(a)
0
10
20
30
40
50
60
Length scale index
0
0.05
0.1
0.15
0.2
0.25
0.3
0.35
0.4
Power
Monte-Carlo Run: 1; SNR = -10 dB, R = 6; PCPD-GH;
Very small 
 length scale powers:
~1e-7
(b)
Fig. 4.6 a The powers of learned length scales (i.e., {τ −1
l
}L
l=1) for PCPD-MGP; b The powers
of learned length scales (i.e., {zl}L
l=1) for PCPD-GH. It can be seen that PCPD-MGP recovers 5
components with non-negligible magnitudes, while PCPD-GH recovers 6 components. The two
algorithms are with the same upper bound value L = 60. Simulation setting: SNR = −10 dB,
R = 6
is due to the mismatch in the decaying component amplitude assumption in the MGP
model.
Additional simulation runs and results of more simulation settings are included
in [2], from which similar conclusions can be drawn.

4.2 Real-World Applications
69
4.2
Real-World Applications
In this section, two real-world applications of CPD are presented, with a focus on
performance comparisons between PCPD-GG and PCPD-GH.
4.2.1
Fluorescence Data Analytics
Fluorescence spectroscopy is a fast, simple, and inexpensive method to determine
the concentration of any solubilized sample based on its ﬂuorescent properties (see
Fig.4.7) and is widely used in chemical, pharmaceutical, and biomedical ﬁelds [4]. In
ﬂuorescence spectroscopy, an excitation beam with a certain wavelength λi passes
through a solution in a cuvette. The excited chemical species in the sample will
change their electronic states and then emit a beam of light, of which its spectrum
is measured at the detector. Mathematically, let the concentration of the rth species
in the sample be cr, and the excitation value at wavelength λi be ar(λi). Then,
the noise-free measured spectrum intensity at the wavelength λ j is ar(λi)br(λ j)cr,
where br(λ j) is the emission value of the rth species at the wavelength λ j. If there
are R different species in the sample, the noise-free ﬂuorescence excitation–emission
measured (EEM) data at λ j is
xi, j =
R

r=1
ar(λi)br(λ j)cr.
(4.1)
Assume the excitation beam contains I wavelengths, and the noise-free EEM data
is collected at J different wavelengths, then an I × J data matrix is obtained as
X =
R

r=1
A:,r ◦B:,rcr,
(4.2)
Fig. 4.7 An application
example of CPD:
ﬂuorescence
excitation–emission
measurements

70
4
Bayesian Tensor CPD: Performance and Real-World Applications
Fig. 4.8 The clean spectra recovered from the noise-free ﬂuorescence tensor data assuming the
knowledge of tensor rank
where symbol ◦denotes vector outer product, A:,r ∈RI×1 is a vector with the ith
element being ar(λi), and B:,r ∈RJ×1 is a vector with the jth element being br(λ j).
Assume K > 1 samples with the same chemical species but with different concen-
trations of each species are measured. Let the concentration of the rth species in
the kth sample be ck,r, then after stacking the noise-free EEM data for each sample
along a third dimension, a three-dimensional (3D) tensor data X ∈RI×J×K can be
obtained as
X =
R

r=1
A:,r ◦B:,r ◦C:,r ≜A, B, C,
(4.3)
where C:,r ∈RK×1 is a vector with the kth element being ck,r; matrices A ∈RI×R,
B ∈RJ×R, and C ∈RK×R are matrices with their rth columns being A:,r, B:,r, and
C:,r, respectively. It is easy to see that the noise-free data model in (4.3) yields exactly
the tensor CPD model, and that is why CPD algorithms work very well for EEM
data analysis.
To showcase various CPD algorithms for the ﬂuorescence data analysis applica-
tion, we consider the popular amino acids ﬂuorescence data4 X with size 5 × 201 ×
61 [5]. It consists of ﬁve laboratory-made samples, with each sample containing
different amounts of tyrosine, tryptophan, and phenylalanine dissolved in phosphate
buffered water. Since there are three different types of amino acids, when adopting
the CPD model, the optimal tensor rank should be 3. In particular, with the optimal
tensor rank 3, the clean spectra for the three types of amino acids, which are recov-
ered by the alternative least-squares (ALS) algorithm (Algorithm 1 of Chap.1), are
presented in Fig.4.8 as the benchmark.
In practice, it is impossible to know how many components are present in the data
in advance, and this calls for automatic tensor rank learning. Therefore, we assess
both the rank learning performance and the noise mitigation performance for the two
algorithms (i.e., PCPD-GH and PCPD-GG) under different levels of noise sources.
4 http://www.models.life.ku.dk.

4.2 Real-World Applications
71
Table 4.3 Fit values and estimated tensor ranks of ﬂuorescence data under different SNRs
SNR
(dB)
Rank upper bound = max(DimX)
Rank upper bound = 2max(DimX)
PCPD-GG
PCPD-GH
PCPD-GG
PCPD-GH
Fit value
Estimated
tensor
rank
Fit value
Estimated
tensor
rank
Fit value
Estimated
tensor
rank
Fit value
Estimated
tensor
rank
−10
71.8109
4
72.6401
3
71.8197
4
72.6401
3
−5
83.9269
4
84.3424
3
83.5101
4
84.3424
3
0
90.6007
4
90.8433
3
90.3030
5
90.8433
3
5
94.2554
4
94.3554
3
94.0928
5
94.3555
3
10
96.0907
3
96.0951
3
96.0369
4
96.0955
3
15
96.8412
3
96.8431
3
96.8412
3
96.8432
3
20
97.1197
3
97.1204
3
97.1197
3
97.1204
3
In particular, the Fit value [6], which is deﬁned as (1 −|| ˆX−X||F
||X||F ) × 100%, is adopted,
where ˆX represents the reconstructed ﬂuorescence tensor data from the algorithm.
In Table4.3, the performances of the two algorithms are presented assuming dif-
ferent upper bound values of tensor rank. It can be observed that with different upper
bound values, the PCPD-GH algorithm always gives the correct tensor rank esti-
mates, even when the SNR is smaller than 0 dB. On the other hand, the PCPD-GG
method is quite sensitive to the choice of the upper bound value. Its performance with
upper bound 2 max{Jn}N
n=1 becomes much worse than that with max{Jn}N
n=1 in tensor
rank learning. Even with the upper bound being equal to max{Jn}N
n=1, PCD-GG fails
to recover the optimal tensor rank 3 in the low-SNR region (i.e., SNR ≤5 dB). With
the overestimated tensor rank, the reconstructed ﬂuorescence tensor data ˆX will be
overﬁtted to the noise sources, leading to lower Fit values. As a result, the Fit values
of the PCPD-GH method are generally higher than those of the PCPD-GG method
under different SNRs.
In this application, since the tensor rank represents the number of underlying
components inside the data, its incorrect estimation will not only lead to overﬁtting
to the noise, but also will cause “ghost” components that cannot be interpreted. This is
illustrated in Fig.4.9 where ghost component appears in SNR = −10 dB and 0 dB for
PCPD-GG. In addition, in Fig.4.10, we present the learned length scale powers from
PCPD-GG and PCPD-GH. It can be seen that PCPD-GG recovers four components
with non-negligible powers. The smallest component’s power is 8 times larger than
those of negligible components. In data analysis, disregarding such a large learned
latent component is not reasonable. On the other hand, the PCPD-GH gives very
clean 3 components with non-negligible powers.
Since the “ghost” component in PCPD-GG has a relatively large magnitude, it
degrades the performance of the tensor signal recovery. For example, from Table4.3,
when the SNR is low (e.g., −10 dB), the Fit value of PCPD-GH is 0.8 higher than

72
4
Bayesian Tensor CPD: Performance and Real-World Applications
Fig. 4.9 The recovered spectra of ﬂuorescence data under different SNRs
(a) PCPD-GG
(b) PCPD-GH
Fig. 4.10 Amino acids ﬂuorescence data analysis. a The powers of learned length scales (i.e.,
{γ −1
l
}L
l=1) for PCPD-GG; b The powers of learned length scales (i.e., {zl}L
l=1) for PCPD-GH. It can
be seen that PCPD-GG recovers 4 components with non-negligible magnitudes, while PCPD-GH
recovers 3 components. The two algorithms are with the same upper bound value: 201. Simulation
setting: SNR = −5 dB. Since the x-axis is too long (containing 201 points), we only present partial
results that include non-zero components. Those values not shown in the ﬁgures are all very close
to zero
that of PCPD-GG. This is in great contrast in the high-SNR regime (no “ghost”
component) where their Fit value difference is about 0.001. Therefore, the “ghost”
component signiﬁcantly degrades the tensor signal recovery performance.

4.2 Real-World Applications
73
4.2.2
Hyperspectral Images Denoising
Hyperspectral image (HSI) data are naturally three-dimensional (two spatial dimen-
sions and one spectral dimension), in which tensor CPD is a suitable tool to analyze
such data. However, due to the radiometric noise, photon effects, and calibration
errors, it is crucial to mitigate these corruptions before putting the HSI data into use.
Since each HSI is rich in details, previous works using searching-based methods [7,
8] revealed that the tensor rank in HSI data is usually larger than half of the maxi-
mal tensor dimension. This corresponds to the high tensor rank scenario deﬁned in
Sect.4.1.
In this application, we consider two real-world datasets: the Salinas-A HSI and the
Indian Pines HSI, where different bands of HSIs were corrupted by different levels of
noises. Some of the HSIs are quite clean while some of them are quite noisy. For such
types of real-world data, since no ground truth is available, a no-reference quality
assessment score is usually adopted [7, 8]. In particular, following [7], the SNR
output 10 log10 || ˆX||2
F/||X −ˆX||2
F is utilized as the denoising performance measure,
where ˆX is the restored tensor data and X is the original HSI data. In Table4.4,
the SNR outputs of the two methods using different rank upper bound values are
presented, from which it can be seen that the PCPD-GH method gives higher SNR
outputs than PCPD-GG.
Samples of denoised HSIs are depicted in Fig.4.11. On the left side of Fig.4.11,
the relatively clean Salinas-A HSI in band 190 is presented to serve as a reference,
from which it can be observed that the landscape exhibits “stripe” pattern. For the
noisy HSI in band 1, the denoising results from the two methods using the rank upper
bound max{Jn}N
n=1 are presented. It is clear that the PCPD-GH method recovers better
“stripe” pattern than the PCPD-GG method. Similarly, the results from the Indian
Pines dataset are presented on the right side of Fig.4.11. For noisy HSI in band 1,
with the relatively clean image in band 10 serving as the reference, it can be observed
that the PCPD-GH method recovers more details than the PCPD-GG method, when
both using rank upper bound 2max{Jn}N
n=1.
Since the HSIs in band 1 are quite noisy, inspecting the performance differ-
ence between the two methods requires a closer look. In Fig.4.11, we have used
Table 4.4 SNR outputs and estimated tensor ranks of HSI data under different rank upper bounds
Algorithm
PCPD-GG
PCPD-GH
Dataset
Rank
upper
bound
SNR
output
(dB)
Estimated
tensor
rank
SNR
output
(dB)
Estimated
tensor
rank
Salinas-A
max{Jn}N
n=1
43.7374
137
44.0519
143
2 max{Jn}N
n=1
46.7221
257
46.7846
260
Indian pines
max{Jn}N
n=1
30.4207
169
30.5541
178
2 max{Jn}N
n=1
31.9047
317
32.0612
335

74
4
Bayesian Tensor CPD: Performance and Real-World Applications
Fig. 4.11 The hyper-spectral image denoising results
red boxes to highlight those differences. Note that although HSIs in different fre-
quency bands have different pixel intensities (different color bars), they share the
same “clustering” structure. The goal of HSI denoising is to reconstruct the “cluster-
ing” structure in each band in order to facilitate the downstream segmentation task
[7, 8]. Therefore, the assessment is based on whether the recovered HSI exhibits
correct “clustering” patterns. Speciﬁcally, for Salinas-A scene data, the recovered
images are supposed to render explicit “stripe” patterns, in each of which the intensi-
ties (colors) are almost the same. As indicated by the red boxes, it can be observed that
PCPD-GH recovers better “stripe” pattern than PCPD-GG, since much more pixels
in the red box of PCPD-GH have the same blue color. Similarly, for the Indian Pines
dataset, as indicated by each red box, the area supposed to be identiﬁed as a cluster
(with warmer colors than nearby areas) is more accurately captured by PCPD-GH.
References
1. Q. Zhao, L. Zhang, A. Cichocki, Bayesian cp factorization of incomplete tensors with automatic
rank determination. IEEE Trans. Pattern Anal. Mach. Intell. 37(9), 1751–1763 (2015)
2. L. Cheng, Z. Chen, Q. Shi, Y.-C. Wu, S. Theodoridis, Towards ﬂexible sparsity-aware modeling:
automatic tensor rank learning using the generalized hyperbolic prior. IEEE Trans. Signal
Process. 70, 1834–1849 (2022)
3. P. Rai, Y. Wang, S. Guo, G. Chen, D. Dunson, L. Carin, Scalable bayesian low-rank decom-
position of incomplete multiway tensors, in International Conference on Machine Learning
(PMLR, 2014), pp. 1800–1808
4. J.R. Albani, Principles and Applications of Fluorescence Spectroscopy (Wiley, New York,
2008)

References
75
5. R. Bro, Multi-way analysis in the food industry, in Models, Algorithms, and Applications
(Academish proefschrift, Dinamarca, 1998)
6. A. Cichocki, R. Zdunek, A.H. Phan, S.-I. Amari, Nonnegative Matrix and Tensor Factor-
izations: Applications to Exploratory Multi-way Data Analysis and Blind Source Separation
(Wiley, New York, 2009)
7. X. Liu, S. Bourennane, C. Fossati, Denoising of hyperspectral images using the parafac model
and statistical performance analysis. IEEE Trans. Geosci. Remote Sens. 50(10), 3717–3724
(2012)
8. B. Rasti, P. Scheunders, P. Ghamisi, G. Licciardi, J. Chanussot, Noise reduction in hyperspectral
imagery: overview and application. Remote Sens. 10(3), 482 (2018)

Chapter 5
When Stochastic Optimization Meets VI:
Scaling Bayesian CPD to Massive Data
Abstract In previous chapters, Bayesian tensor CPD algorithms are derived for
batch-mode operation, meaning that it needs to process the whole dataset at the same
time. Obviously, this is no longer suitable for large datasets. To enable Bayesian ten-
sor CPD in the Big Data era, the idea of stochastic optimization can be incorporated,
rendering a scalable algorithm that only processes a mini-batch data at a time. In this
chapter, we develop a scalable algorithm for Bayesian tensor CPD with automatic
rank determination. Numerical examples in synthetic and real-world data demon-
strate the excellent performance of the algorithm, both in terms of computation time
and accuracy.
5.1
CPD Problem Reformulation
According to (1.8), tensor CPD assumes that a P + 1 dimensional data tensor ˙Y ∈
RI1×I2×···×IP×IP+1 obeys the following model:
˙Y =
R

r=1
(1)
:,r ◦(2)
:,r ◦· · · ◦(P)
:,r ◦(P+1)
:,r
+ ˙W
≜[[(1), (1), . . . , (P), (P+1)]] + ˙W,
(5.1)
where ˙W represents an additive noise tensor. The vector (p)
:,r ∈RIp is therth column
ofthefactormatrix(p) ∈RIp×R,and◦denotesthevectorouterproduct.Thenumber
of rank-1 components R is deﬁned as the tensor rank.
The core problem of tensor CPD is to ﬁnd the factor matrices {(p)}P+1
p=1 from ˙Y
under the unknown tensor rank R. The problem can be stated as
min
{(p)}P+1
p=1
β
2 ∥˙Y −[[(1), (2), . . . , (P+1)]] ∥2
F +
L

l=1
γl
2
 P+1

p=1
(p)T
:,l
(p)
:,l

, (5.2)
where L is the maximum possible value of tensor rank R. Notice that the tensor rank
acquisition is generally NP-hard, due to its discrete nature. As an effective heuristic
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023
L. Cheng et al., Bayesian Tensor Decomposition for Signal Processing and
Machine Learning, https://doi.org/10.1007/978-3-031-22438-6_5
77

78
5
When Stochastic Optimization Meets VI: Scaling …
approach, a regularization term L
l=1
γl
2
 P+1
p=1 (p)T
:,l
(p)
:,l

is added in order to
control the complexity of the model and avoid overﬁtting of noise.
It is easy to show that problem (5.2) is non-convex, since all the factor matrices
{(p)}P+1
p=1 are coupled via Khatri–Rao products. To solve problem (5.2), the widely
used ALS optimization framework iteratively updates each factor matrix with other
factor matrices being ﬁxed. However, in each update, the computation requires ana-
lyzing the whole data tensor ˙Y, and thus is not computationally efﬁcient. To achieve
highly scalable algorithms, a recent work [1] rewrites the objective function into an
equivalent summation form so that stochastic optimization can be readily applied. In
particular, using the deﬁnition of tensor CPD, it is easy to show that problem (5.2)
is equivalent to
min
{(p)}P
p=1
β
2
IP+1

n=1
∥Y(n) −[[(1), (2), . . . , (P), ξ(n)]] ∥2
F
+
L

l=1
γl
2

P

p=1
(p)T
:,l
(p)
:,l +
IP+1

n=1
ξ(n)2
l

(5.3)
where the data slices {Y(n) ∈RI1×I2×···×IP}IP+1
n=1 are obtained by slicing the data tensor
˙Y along the last dimension.1 In this expression, factor matrices {(p) ∈RIp×L}P
p=1
span the tensor subspace where data tensor Y(n) lies, and vector ξ(n) = (P+1)
n,:
is
the feature vector associated with the tensor data slice Y(n). From (5.3), it is obvious
that the gradient of the objective function is a summation of IP+1 components, with
each component depending only on a slice of tensor data Y(n). This motivates the
use of stochastic optimization to improve the scalability.
5.1.1
Probabilistic Model and Inference for the Reformulated
Problem
The probabilistic model for the reformulated problem (5.3) could be established by
interpreting various terms in (5.3) via probability density functions (pdfs). Firstly,
the squared error term in problem (5.3) can be interpreted as the negative log of a
Gaussian likelihood function:
1 The CPD deﬁnition implies that the summation form holds for the data tensor ˙Y being sliced
along any dimension. Without loss of generality, the discussions here assume slicing along the last
dimension.

5.1 CPD Problem Reformulation
79
p

{Y(n)}IP+1
n=1 | {(p)}P
p=1, {ξ(n)}IP+1
n=1, β−1
=
IP+1

n=1
 β
2π
 I1 I2···IP
2
exp

−β
2 ∥Y(n) −[[(1), (2), . . . , (P), ξ(n)]] ∥2
F

.
(5.4)
Secondly, the regularization term in problem (5.3) can be interpreted as arising from
a Gaussian prior distribution over the columns of the factor matrices and feature
vectors, i.e.,
p({(p)}P
p=1|{γl}L
l=1) =
P

p=1
L

l=1
N

(p)
:,l |0Ip×1, γ −1
l
I L

=
P

p=1
Ip

τ=1
N

(p)
τ,: |01×L, −1
,
(5.5)
p({ξ(n)}IP+1
n=1 |{γl}L
l=1) =
IP+1

n=1
L

l=1
N

ξ(n)l|0, γ −1
l

=
IP+1

n=1
N

ξ(n)|01×L, −1
,
(5.6)
where  = diag{γ1, γ2, . . . , γL} and L is an upper bound of R. The inverse of the
regularization parameter γ −1
l
has a physical interpretation of the power of the lth
column of various factor matrices. When power γ −1
l
goes to zero, it indicates the
corresponding columns in various factor matrices play no role, and can be pruned
out. For the parameters β and {γl}L
l=1, since we have no information about their dis-
tributions, non-informative gamma priors [4] are imposed on them, i.e., p(β|αβ) =
gamma(β|10−6, 10−6) and p({γl}L
l=1|λγ ) = 	L
l=1 gamma(γl|10−6, 10−6). This cor-
responds to the Gaussian-gamma model in (3.4) and (3.5).
The complete probabilistic model is shown in Fig.5.1. Let  be a set contain-
ing the unknown factor matrices {(p)}P
p=1, feature vectors {ξ(n)}IP+1
n=1, and other
variables β, {γl}L
l=1. From the probabilistic model established above, the goal of
Bayesian inference is to calculate the posterior distribution p(|{Y(n)}IP+1
n=1) =
p(, {Y(n)}IP+1
n=1)/

p(, {Y(n)}IP+1
n=1)d,whichhowever isanalyticallyintractable
due to the multiple integrations involved. Therefore, we make use of variational
inference in Sect.3.4. In particular, under the mean-ﬁeld approximation Q() =
	K
k=1 Q(k), where k is part of  with ∪K
k=1k =  and ∩K
k=1k = Ø, the opti-
mal variational pdf Q∗(k) is obtained by solving the following problem with other
{Q( j)} j̸=k ﬁxed [5] (also see (3.17)):
min
Q(k)

Q (k)

−E	
j̸=k Q( j)

ln p

, {Y(n)}IP+1
n=1

+ ln Q (k)

dk
s.t.

Q(k)dk = 1 , Q(k) ≥0.
(5.7)

80
5
When Stochastic Optimization Meets VI: Scaling …
Fig. 5.1 Probabilistic model
for reformulated tensor CPD
(© [2018] IEEE. Reprinted,
with permission, from [L.
Cheng, Y.-C. Wu, and H. V.
Poor, Scaling Probabilistic
Tensor Canonical Polyadic
Decomposition to Massive
Data, IEEE Transactions on
Signal Processing, Nov
2018]. It applies to all ﬁgures
and tables in this chapter)
···
β
Ξ(1)
Ξ(2)
Ξ(P )
{γl}L
l=1
αβ
λγ
{ξ(n)}N
n=1
{Y(n)}N
n=1
mr
= 01×L
For this convex problem, the Karush–Kuhn–Tucker (KKT) condition gives the opti-
mal variational pdf Q∗(k) as [5]
Q∗(k) ∝exp

E	
j̸=k Q( j)

ln p

, {Y(n)}IP+1
n=1

.
(5.8)
If we compute various Q∗() directly, we would end up Algorithm 5 in Chap.3,
with the slight variation that the last factor matrix (P+1) is learned row-by-row via
ξ(n).
5.2
Interpreting VI Update from Natural Gradient Descent
Perspective
While it may seem that the reformulation in Sect.5.1 is just a trivial variation of the
original Bayesian CPD problem and inference, it turns out this reformulation is the
ﬁrst step in the process of revealing a connection between VI and natural gradient
descent, which is the gradient descent for distributions rather than parameters. If such

5.2 Interpreting VI Update from Natural Gradient Descent Perspective
81
a connection is established, we can make use of an idea from stochastic optimization,
which has recently enabled many large-scale machine learning tasks [6–8].
5.2.1
Optimal Variational Pdfs in Exponential Family Form
In a previous work [3], it has been shown that for some special probabilistic models,
such as the two-layer model speciﬁed in [3], the VI update due to (5.8) can be inter-
preted from a natural gradient descent perspective, which paves the way to integrate
stochastic optimization in the VI framework. However, the probabilistic model of
tensor CPD does not belong to the model family speciﬁed in [3], as evidenced by
Fig.5.1 that the considered model contains three layers. To bridge the framework of
[3] to tensor CPD, we notice from Algorithm 5 of Chap.3 (also [15]) that the opti-
mal variational pdfs in batch-mode Gaussian-gamma-based CPD are of Gaussian or
gamma distribution, and thus can be characterized by their natural parameters (see
Deﬁnition 2.1). In particular, from (3.38) and (3.39) in Algorithm 5, we can see
that the optimal {Q∗((p))}P
p=1 are Gaussian distributions. Tailoring to the model
in Fig.5.1, Q∗((p)) can be written in the exponential family form (for details, see
[18]) as
Q∗((p)) = p(vec((p))|α p) ∝exp

αT
p

vec

(p)T , −vec

(p)T (p)T T 
,
with the natural parameter being
α p = E	
 j ̸=(p) Q( j)

IP+1
n=1 t

Y(n),

η j, η j ̸= (p)
vec
 1
2

+ IP+1
n=1 ln

η j, η j ̸= (p)

,
(5.9)
where2
t

Y(n),

η j, η j ̸= (p)
= vec

β

Y(n)
(p) 
ξ(n) ⋄

P⋄
m=1,m̸=p (m)
,
(5.10)
ln

η j, η j ̸= (p)
= vec
β
2

ξ(n) ⋄

P⋄
m=1,m̸=p (m)T 
ξ(n) ⋄

P⋄
m=1,m̸=p (m)
.
(5.11)
In (5.9), η = {{(p)}P
p=1, β, {ξ(n)}IP+1
n=1} denotes the unknown variables of layer 1 in
Fig.5.1. In (5.10), the operation [A](p) unfolds the tensor A along the pth dimension,
and
N⋄
n=1,n̸=k A(n) = A(N) ⋄· · · ⋄A(k+1) ⋄A(k−1) ⋄· · · ⋄A(1) in (5.11) is the multiple
Khatri–Rao products.
2 We use overloaded notation for the functions t(·) and l(·) for brevity. Their detailed functional
forms depend on their arguments.

82
5
When Stochastic Optimization Meets VI: Scaling …
Similarly, the optimal variational pdf Q∗(ξ(n)) = p(ξ(n)|αξ(n)) can be shown to
be a Gaussian distribution, with the natural parameter being
αξ(n) = E	
 j ̸=ξ(n) Q( j)

t

Y(n),

η j, η j ̸= ξ(n)

vec
 1
2

+ l

η j, η j ̸= ξ(n)


,
(5.12)
where
t

Y(n),

η j, η j ̸= ξ(n)

= β

P⋄
p=1 (p)T
vec (Y(n)) ,
(5.13)
l

η j, η j ̸= ξ(n)

= vec
β
2

P⋄
p=1 (p)T 
P⋄
p=1 (p)
.
(5.14)
On the other hand, the optimal variational pdf Q∗(β) is a gamma distribution [15].
Writing the gamma distribution in exponential family form, we have Q∗(β) =
p(β|αβ) ∝exp

αT
β [β, ln β]T 
, with the natural parameter being
αβ = E	
 j ̸=β Q( j)

−10−6 + IP+1
n=1 t

Y(n),

η j, η j ̸= β

10−6 −1 + IP+1
n=1 ln

η j, η j ̸= β


,
(5.15)
where
t

Y(n),

η j, η j ̸= β

= −1
2 ∥Y(n) −[[(1), (2), . . . , (P), ξ(n)]] ∥2
F,
(5.16)
ln

η j, η j ̸= β

= I1I2 · · · IP
2
.
(5.17)
Finally, the optimal Q∗(γ ) = p(γ |λγ ) is a gamma distribution [15] with the natural
parameter being
λγ = E	
 j ̸=γ Q( j)

−d + u({(p)}P
p=1) + IP+1
n=1 u(ξ(n))
c −1 + w

,
(5.18)
where
u({(p)}P
p=1) =
⎡
⎣
P

p=1
−1
2(p)T
:,1 (p)
:,1 , . . . ,
P

p=1
−1
2(p)T
:,L (p)
:,L
⎤
⎦
T
,
(5.19)
u(ξ(n)) =

−1
2ξ(n)2
1, . . . , −1
2ξ(n)2
L
T
,
(5.20)

5.2 Interpreting VI Update from Natural Gradient Descent Perspective
83
w =
⎡
⎣1
2
P

p=1
Ip + 1
2 IP+1, . . . , 1
2
P

p=1
Ip + 1
2 IP+1
⎤
⎦
T
,
(5.21)
vector 1 is the all-ones vector with length L, and c = d = 10−61. From (5.9), (5.12),
(5.15), and (5.18), since the update in each equation depends on the parameters in
other equations, the VI algorithm consists of cyclical update among these equations.
Remark: If we compute the expectations in (5.9), (5.12), (5.15), and (5.18), after
tedious derivations, we would obtain the batch-mode VI algorithm for tensor CPD
[13, 15]. However, computing the expectations at this stage would obscure the inter-
pretation of update Eqs.(5.9), (5.12), (5.15), and (5.18) as natural gradient descent
steps in Riemannian space, an insight critical in developing the stochastic optimiza-
tion for probabilistic tensor CPD algorithm.
5.2.2
VI Updates as Natural Gradient Descent
In order to reveal the connection between the optimal variational parametric updates
(5.9), (5.12), (5.15), (5.18), and gradient descent steps, we substitute them back
into problem (5.7), transforming the functional optimization problem (5.7) into a
parametric optimization problem.
For example, using the knowledge that Q∗((p)) = p(vec((p))|α p) is a Gaus-
sian distribution, the constraints in problem (5.7) are automatically satisﬁed. Since
Q((p)) is parametrized by α p, the problem (5.7) becomes
min
α p

p(vec((p))|α p)

−E	
 j ̸=(p) Q( j)

ln p (, Y)

+ ln p(vec((p))|α p)

dα p.
(5.22)
After performing the integration and discarding the terms irrelevant to (p), it can
be shown that problem (5.22) becomes problem (5.23):
min
α p
−E	
 j ̸=(p) Q( j )
⎡
⎣
IP+1
n=1 t

Y(n),

η j, η j ̸= (p)
vec
 1
2

+ IP+1
n=1 ln

η j, η j ̸= (p)
⎤
⎦
T
Ep(vec((p))|α p)

t((p))

+ α p
T Ep(vec((p))|α p)

t((p))

−L((p)),
(5.23)
where t((p)) =

vec

(p)
, −vec

(p)T (p)T is the sufﬁcient statistic of the
prior distribution (5.5), and L((p)) = Ip
L
l=1 ln γl is the log normalizer of the prior
distribution (5.5).
Given that (5.23) is a parametric optimization problem, denoting the objective
function in (5.23) as f (α p), its derivative is shown as follows:

84
5
When Stochastic Optimization Meets VI: Scaling …
▽α p f (α p)
= −▽α pEp(vec((p))|α p)[t((p))]E	
 j ̸=(p) Q( j )
⎡
⎣
IP+1
n=1 t

Y(n),

η j, η j ̸= (p)
vec
 1
2

+ IP+1
n=1 ln

η j, η j ̸= (p)
⎤
⎦
+ ▽α pEp(vec((p))|α p)[t((p))]α p + Ep(vec((p))|α p)[t((p))] −▽α p

L((p))

.
(5.24)
Since p(vec((p))|α p) is in the exponential family, with t((p)) and L((p))
being the sufﬁcient statistic and the log normalizer, respectively, we have the property
that Ep(vec((p))|α p)[t((p))] = ▽α p

L((p))

[4]. Using this result, the last two terms
of (5.24) cancel each other, and the remaining terms can be organized as
▽α p f (α p)
= ▽2
α p

L((p))
 
−E	
 j ̸=(p) Q( j )
⎡
⎣
IP+1
n=1 t

Y(n),

η j, η j ̸= (p)
vec
 1
2

+ IP+1
n=1 ln

η j, η j ̸= (p)
⎤
⎦+ α p

.
(5.25)
This gradient, which is commonly used in optimization, is deﬁned in Euclidean
distance metric, i.e., ▽α p f (α p) = arg maxdα p f (α p + dα p) subject to dαT
pdα p < ϵ
for sufﬁciently small ϵ. However, since the parameter α p has its physical mean-
ing as the natural parameter in exponential family distribution p(vec((p))|α p),
the Euclidean distance between α p and α′
p does not account for the information
geometry of its parameter space, and thus is not a good distance measure between
p(vec((p))|α p) and p(vec((p))|α′
p).
Instead, the symmetric KL divergence, a metric in the Riemannian space, is found
to be a natural distance measure for parameters α p, and it is deﬁned as [9]
K Lsym(α p, α′
p)
= Ep(vec((p))|α p)

ln
p(vec((p))|α p)
p(vec((p))|α′p)

+ Ep(vec((p))|α′p)

ln
p(vec((p))|α′
p)
p(vec((p))|α p)

.
Using this metric, the natural gradient that points in the direction of the steepest
ascent in the Riemannian space is deﬁned as ▽n
α p f (α p) = arg maxdα p f (α p + dα p)
subject to K Lsym(α p, α p + dα p) < ϵ for sufﬁciently small ϵ [9]. Since this natural
gradient utilizes the implicit information of parameter space, it is expected to give
faster convergence than the traditional Euclidean metric-based gradient in stochas-
tic gradient descent, and this has been demonstrated in the maximum-likelihood
estimation problem [10].
Computing the natural gradient of
f (α p) under the KL divergence of
p(vec((p))|α p) and p(vec((p))|α′
p) is easy, since p(vec((p))|α p) lies in the
exponential family. It is shown in [10] that the natural gradient ▽n
α p f (α p) can be

5.2 Interpreting VI Update from Natural Gradient Descent Perspective
85
calculatedbypremultiplyingthetraditionalgradient ▽α p f (α p)withtheinverseofthe
Fisherinformationmatrixof p(vec((p))|α p),i.e.,▽n
α p f (α p) = G(α p)−1▽α p f (α p)
where
G(α p) ≜Ep(vec((p))|α p)

▽α p ln p(vec((p))|α p)

▽α p
ln p(vec((p))|
α p)
T 
. Substituting the functional form of p(vec((p))|α p) into the deﬁnition of
Fisher information matrix, it can be shown that G(α p) is just the second derivative of
the log normalizer [10], i.e., G(α p) = ▽2
α p

L((p))

. Using this result and (5.25),
the natural gradient ▽n
α p f (α p) is
▽n
α p f (α p) = −E	
 j ̸=(p) Q( j)

IP+1
n=1 t

Y(n),

η j, η j ̸= (p)
vec
 1
2

+ IP+1
n=1 ln

η j, η j ̸= (p)

+ α p.
(5.26)
Similar derivations can be performed for other variables {ξ(n)}IP+1
n=1, β, and γ .
In particular, after substituting Q∗(ξ(n)) = p(ξ(n)|αξ(n)), Q∗(β) = p(β|αβ) and
Q∗(γ ) = p(γ |λγ ) into problem (5.7), and using the deﬁnition of natural gradient,
we obtain
▽n
αξ(n) f (αξ(n)) = −E	
 j ̸=ξ(n) Q( j)

t

Y(n),

η j, η j ̸= ξ(n)

vec
 1
2

+ l

η j, η j ̸= ξ(n)


+ αξ(n)
(5.27)
▽n
αβ f (αβ) = −E	
 j ̸=β Q( j)

−10−6 + IP+1
n=1 t

Y(n),

η j, η j ̸= β

10−6 −1 + IP+1
n=1 ln

η j, η j ̸= β


+ αβ
(5.28)
▽n
λγ f (λγ ) = −E	
 j ̸=γ Q( j)

−d + u({(p)}P
p=1) + IP+1
n=1 u(ξ(n))
c −1 + w

+ λγ .
(5.29)
From the expressions (5.26)–(5.29), it is easy to see that the cyclical updates of (5.9),
(5.12), (5.15), and (5.18) are equivalent to the natural gradient descents with step
size 1 as follows:
αt+1
p
= αt
p −▽n
α p f (αt
p)
(5.30)
αt+1
ξ(n) = αt
ξ(n) −▽n
αξ(n) f (αt
ξ(n))
(5.31)
αt+1
β
= αt
β −▽n
αβ f (αt
β)
(5.32)
λt+1
γ
= λt
γ −▽n
λγ f (λt
γ ).
(5.33)

86
5
When Stochastic Optimization Meets VI: Scaling …
5.3
Scalable VI Algorithm for Tensor CPD
In update (5.31), computing the natural gradient is inexpensive, as the computation
in (5.27) only involves one data slice Y(n). However, computing natural gradients
for updates (5.30), (5.32), and (5.33) are much more expensive, as the whole dataset
{Y(n)}IP+1
n=1 is involved. To scale the inference algorithm to a massive data paradigm,
one promising way is to leverage stochastic optimization, where noisy, unbiased, and
cheap-to-compute gradients are used to substitute the original expensive gradients
in (5.30), (5.32), and (5.33) as shown in (5.34)–(5.36) as follows:
αt+1
p
= αt
p −ρt

−1
S
S

i=1
E	
 j ̸=(p) Q( j )

IP+1t

Y(ni),

η j, η j ̸= (p)
vec
 1
2

+ IP+1lni

η j, η j ̸= (p)

+ αt
p

 
!"
#
≜ˆ▽n
α p f (αtp)
(5.34)
αt+1
β
= αt
β −ρt

−1
S
S

i=1
E	
 j ̸=β Q( j )

−10−6 + IP+1t

Y(ni),

η j, η j ̸= β

10−6 −1 + IP+1lni

η j, η j ̸= β


+ αt
β

 
!"
#
≜ˆ▽n
αβ f (αt
β)
(5.35)
λt+1
γ
= λt
γ −ρt
 1
S
S

i=1
E	
 j ̸=γ Q( j )

−d + u({(p)}P
p=1) + IP+1u(ξ(ni))
c −1 + w

−λt
γ

 
!"
#
≜ˆ▽n
λγ f (λt
γ )
.
(5.36)
In (5.34)–(5.36), unbiased noisy gradients ˆ▽n
α p f (α p), ˆ▽n
αβ f (αβ), and ˆ▽n
λγ f (λγ )
are computed from uniformly sampled mini-batch data {Y(n1), Y(n2), . . . , Y(nS)}
with index ni ∼Uniform(1, 2, 3, . . . , IP+1) for i = 1, 2, . . . , S [3]. Obviously, their
computations only involve S data slices, and thus can be very economical when
S ≪IP+1.Toguaranteeconvergence,thestepsizeρt forupdateswithnoisygradients
must follow the Robbins and Monro conditions: 
t ρt = ∞and 
t ρ2
t < ∞[2].
Withthesestochasticupdates(5.34)–(5.36)replacingthehigh-complexityupdates
(5.30), (5.32), and (5.33), a scalable VI algorithm for tensor CPD can be obtained.
More speciﬁcally, at each iteration, mini-batch data {Y(n1), Y(n2), . . . , Y(nS)} are
sampled
with
index
ni ∼Uniform(1, 2, 3, . . . , IP+1).
Then,
Eqs.(5.31),
(5.34)–(5.36) are executed to update the model parameters. The process is repeated
until the algorithm is deemed to have converged.

5.3 Scalable VI Algorithm for Tensor CPD
87
5.3.1
Summary of Iterative Algorithm
In the updating equations (5.31), (5.34)–(5.36), there are several expectation compu-
tations, and computing these expectations involve the properties of tensor algebra.
To keep the presentation concise, the ﬁnal iterative algorithm is summarized in Algo-
rithm 7. Details on various expressions can be found in [18].
5.3.2
Further Discussions
To gain more insights from the above scalable tensor CPD algorithm, discussions
of rank and factor matrices estimation, feature matrix recovery, computational com-
plexity, memory requirement, convergence property, and selection of a threshold for
column pruning are presented in the following.
5.3.2.1
Rank and Factor Matrices Estimation
For rank estimation, although we do not have an explicit variable for the unknown
rank, we do have variables γ −1
l
for modeling the “power” of the lth column of the
factor matrices. More speciﬁcally, after convergence, some EQ∗(γl)[γl] = at
l /bt
l will
become very large, e.g., 106, indicating that the power of the corresponding columns
in the factor matrices becomes zero. Therefore, these columns can be safely pruned
out, and the remaining number of columns is the estimated tensor rank R. Meanwhile,
since Q∗((p)) is a Gaussian distribution, factor matrices {(p)}P
p=1 are estimated
by the mean {M(p,t)}P
p=1 of {Q∗((p))}P
p=1 at convergence.
5.3.2.2
Estimation of Feature Matrix
The factor matrices {(p)}P
p=1 are obtained after Algorithm 7 terminates, while the
feature matrix (P+1) is not explicitly recovered. In fact, in many applications such
as the frequency estimation and video background modeling [13], since the goal is
to ﬁnd the subspace of signals but not the features, directly applying Algorithm 7
is sufﬁcient. Even in some applications where the feature matrix is desired, it can
be easily learned in a scalable way. In particular, after executing Algorithm 7, the
data Y(n) for n = 1, 2, 3, . . . , IP+1 can be fed to (5.39) sequentially and μ(n) is the
estimate of the nth row of the feature matrix (P+1).

88
5
When Stochastic Optimization Meets VI: Scaling …
Algorithm 7 Scalable VI CPD (SVI-S CPD)
Initialization:
Choose
L > R,
1 ≤S ≤IP+1,
and
initialize
{M(p,0) ∈RIp×L, 
(p,0) ∈
RL×L}P
p=1. Choose a sequence {ρt}t that satisfying 
t ρt = ∞and 
t ρ2
t < ∞. Let {F(p,0) =


(p,0)−1 M(p,0)}P
p=1, a0
l = 10−6, b0
l = 10−6 for l = 1, 2, 3, . . . , L; c0 = d0 = 10−6.
Iterations: For the tth iteration (t ≥0)
Sample {ni}S
i=1 uniformly ni ∼Uniform(1, 2, 3, . . . , IP+1).
Update the parameter of Q∗(ξ(ni))t+1:
αt+1
ξ(ni ) =
 
t−1 μ(ni)T ; 1
2vec

t−1 
(5.37)
with

t−1 = diag
at
1
bt
1
, . . . , at
R
bt
R

+ ct
dt

P⊙
p=1

M(p,t)T
M(p,t) + Ip
(p,t)

(5.38)
μ(ni) = ct
dt vec (Y(ni))T 
P⋄
p=1 M(p,t)
t
(5.39)
Update the parameter of each Q∗((p))t+1:
αt+1
p
=

vec

F(p,t+1)
; 1
2vec


(p,t+1)−1 
(5.40)
with


(p,t+1)−1
= (1 −ρt)


(p,t)−1
+ ρt
S
S

i=1

diag
at
1
bt
1
, . . . , at
R
bt
R

+ IP+1ct
dt

P⊙
m=1,m̸=p

M(m,t)T M(m,t) + Im
(m,t)
⊙

μ(ni)T μ(ni) + t 
(5.41)
F(p,t+1) = (1 −ρt)F(p,t) + ρt IP+1
S
S

i=1
 ct
dt

Y(ni)
(p) 
μ(ni) ⋄

P⋄
m=1,m̸=p M(m,t)
(5.42)
M(p,t+1) = F(p,t+1)T 
(p,t+1).
(5.43)
Update the parameter of Q∗(γ )t+1:
λt+1
γ
=

−bt+1; (at+1
l
−1)1

(5.44)
where at+1
l
= 10−6 + 1
2
P
p=1 Ip + IP+1

and bt+1 = [bt+1
1
, bt+1
2
, . . . , bt+1
L
]T with
bt+1
l
= (1 −ρt )bt
l + ρt
S
S

i=1

10−6 + 1
2

P

p=1

M(p,t+1)T
:,l
M(p,t+1)
:,l
+ Ip
(p,t+1)
l,l

+ IP+1

|μ(ni )l |2 + t
l,l
 
.
(5.45)

5.3 Scalable VI Algorithm for Tensor CPD
89
Update the parameter of Q∗(β)t+1:
αt+1
β
=

−dt+1; ct+1 −1

(5.46)
where
ct+1 = (1 −ρt)(ct −1) + ρt
S
S

i=1
$
10−6 −1 + IP+1
	P
p=1 Ip
2
%
+ 1
(5.47)
dt+1 = (1 −ρt)dt + ρt
S
S

i=1

10−6 + IP+1
2
fi

(5.48)
fi = ∥Y(ni ) ∥2
F −2vec(Y(ni ))T 
P⋄
p=1
M(p,t+1)
μ(ni )T
+ Tr

μ(ni )T μ(ni ) + t  P⊙
p=1

M(p,t+1) M(p,t+1)T+Ip
(p,t+1)
.
(5.49)
Until Convergence
5.3.2.3
Computational Complexity and Memory Requirements
At each iteration, the complexity is dominated by the update of each factor matrix,
costing O((P + 1)L2 	P
p=1 IpS + P
p=1 IpSL3) operations. From this expression,
itisclearthat Algorithm7 onlyincursalinearcomputationalcomplexitywithrespect
to the input tensor size 	P
p=1 IpS. Compared to the corresponding computational
cost of the batch-mode algorithm O((P + 1)L2 	P+1
p=1 Ip + L3(P+1
p=1 Ip)), which
is linear with respect to the input tensor size 	P+1
p=1 Ip, the computational cost of
the scalable algorithm at each iteration is much smaller than that of the batch-mode
algorithmas IP+1 ismuchlargerthan S.Furthermore,themaximummemoryrequired
for Algorithm 7 at each iteration is 	P
p=1 IpS, which again depends only on the mini-
batch size S, but not the whole data size IP+1. Thus, Algorithm 7 scales well to large
dataset if S is much smaller than IP+1.
5.3.2.4
Convergence Property
Although the functional minimization of the KL divergence is non-convex over
the mean-ﬁeld family Q() = 	
k Q(k), it is convex with respect to a sin-
gle variational density Q(k) when other {Q( j)| j ̸= k} are ﬁxed. Therefore,
Algorithm7,whichiterativelyupdatestheoptimalsolutionforeachk,isessentially
a coordinate descent algorithm in the functional space of variational distributions
with each update optimizing a convex subproblem. Furthermore, in the probabilistic
tensor decomposition model in Sect.5.1.1, the corresponding natural gradient for
problem (5.7) can be computed as (5.26)–(5.29) for each Q (k). If the step size

90
5
When Stochastic Optimization Meets VI: Scaling …
is appropriately chosen, the gradient descent step using an unbiased estimate of the
natural gradient (5.34)–(5.36) will decrease the objective function of the subproblem
(5.7) on average. Notice that the optimal solution of each subproblem is unique, as
there is only one solution that makes the derivative zero. Furthermore, since each
subproblem is continuously differentiable, convex, and has a bounded and compact
feasible set, the proposed algorithm is guaranteed to converge to at least a stationary
point on average [17].
5.3.2.5
Selection of Threshold for Pruning Columns
The speciﬁc threshold for pruning columns in general depends on the application.
A widely used choice is 106. However, this ﬁxed threshold might not give the best
performance for all applications, especially when the SNR is low. Another choice
is to set the threshold at 100 times the minimal value of γl. This strategy has been
shown empirically to work well in practice.
5.4
Numerical Examples
In this section, numerical results from both synthetic data and real-world datasets
are presented to assess the performance of Algorithm 7, with the batch-mode algo-
rithm in (Algorithm 5 in Chap.3, labeled as Batch VI) serving as a benchmark.
For Algorithm 7, the dataset ˙Y is sliced along the last dimension. The initial fac-
tor matrix M(p,0) is set as the ﬁrst iteration output of the batch-mode algorithm
with {Y(n1), Y(n2), . . . , Y(nS)} being the tensor input, the initial 
(p,0) = I L with
L = min{I1, I2, . . . , IP}. The step size sequence is chosen as ρt = (t + 1)−0.9 [2].
Each result in this section is obtained by averaging 100 Monte Carlo runs. All the
experiments were conducted in MATLAB R2015b with an Intel Core i5-4570 CPU
at 3.2 GHz and 8 GB RAM.
5.4.1
Convergence Performance on Synthetic Data
A 4D data tensor [[A(1), A(2), A(3), A(4)]] ∈R20×20×20×1000 with rank R = 5 is con-
sidered. The factor matrices {A(p)}3
p=1 are drawn from MN(A(p)| 020×5, I20×20,
I5×5), and matrix A(4) ∼MN(A(4)| 01000×5, I1000×1000, I5×5). The signal-to-noise
ratio (SNR) is deﬁned as 10 log10(∥[[A(1), A(2), A(3), A(4)]] ∥2
F / ∥˙W ∥2
F). To see
how the choice of mini-batch size affects the accuracy and speed, we consider
three scenarios: S = 1, S = 5, and S = 10, and the corresponding algorithms are
labeled as SVI-1, SVI-5, and SVI-10, respectively. The upper bound on the rank for
Algorithm 7 and batch-mode VI algorithm is chosen as L = 20.

5.4 Numerical Examples
91
A commonly used criterion for assessing how close the estimated M(p) is to
the ground truth factor matrix (p) is the averaged largest principal angle (LPA)
1
3
3
p=1 LPA(M(p), (p)). LPA(A, B) is a measure of the “distance” between two
subspaces spanned by the columns of matrices A and B, deﬁned as cos−1{σmin{orth
{A}Horth{B}}}, where the operator σmin{ Q} denotes the smallest singular value of
the matrix Q, and orth{ Q} is an orthonormal basis for the subspace spanned by the
columns of Q. The LPA is also called the angle of subspaces, and can be computed
in MATLAB by the function “subspace”. Notice that while LPA computation allows
M(p) and (p) to have a different number of columns (i.e., estimated rank differs
from true rank), this criterion makes the most sense when M(p) and (p) have the
same number of columns. This can be seen from an example that if M(p) is randomly
generated with many more columns than that of (p), the true subspace generated
by columns of (p) would be embedded in the subspace generated by columns of
M(p), thus giving a zero LPA. However, since (p) and M(p) have very different
sizes, M(p) would not be a good estimate of (p). In order to avoid the misleadingly
small LPA under incorrect rank estimate, if the tensor rank is overestimated in M(p),
only the principal columns of M(p) with the R largest powers are used for computing
the LPA. Similarly, if the tensor rank is underestimated in M(p) with R′ < R, only
the principal columns of (p) with the R′ largest powers are used.
The LPA assesses the performance of subspace recovery. However, due to the
uniqueness property introduced in Chap.5, tensor CPD in fact returns the columns
of each factor matrix up to an unknown permutation and scaling ambiguity, which
is stronger than simply subspace recovery. To directly assess the accuracies of factor
matrices recovery (rather than subspace recovery), the best sum congruence, which
involves computing the normalized correlation between the true columns in (p)
and the estimated columns in M(p), is a more suitable criterion. Mathematically, it
is deﬁned as
max
π(·)
R

r=1
(1)H
:,r
M(1)
:,π(r)
∥(1)
:,r ∥∥M(1)
:,π(r) ∥
(2)H
:,r
M(2)
:,π(r)
∥(2)
:,r ∥∥M(2)
:,π(r) ∥
(3)H
:,r
M(3)
:,π(r)
∥(3)
:,r ∥∥M(3)
:,π(r) ∥
where the maximum is taken with respect to all possible permutations π(·) of the
factor matrices’ columns, which can be found using greedy search algorithm [16].
Similar to LPA, best sum congruence was previously applied when the rank estimate
is accurate. In order to incorporate inaccurate rank estimate in M(p), if the rank is
overestimated in M(p), the R columns of M(p) that match the columns of (p) most
after permutation π(·) are used. On the other hand, if the rank is underestimated in
M(p) with R′ < R, only R′ columns of (p) that match the columns of M(p) most
are used in the computation of best sum congruence.
Figure5.2 shows the convergence performance of Algorithm 7 in terms of LPA.
It can be seen that for both SNR = 10 dB and SNR = 20 dB, the performance
of Algorithm 7 converges to that of the batch-mode algorithm. In particular, LPA
decreases quickly at the beginning of the iterations, and gets pretty close to the LPA of
batch-mode processing within a few hundred iterations. After that, the performance

92
5
When Stochastic Optimization Meets VI: Scaling …
0
200
400
600
800
1000
1200
1400
1600
1800
2000
Number of mini-batch
10-2
10-1
100
101
102
Averaged LPA
SGD
SVI-1
SV1-5
SVI-10
Batch-Mode
20 dB
10 dB
10 dB
20 dB
Fig. 5.2 Convergence performance of Algorithm 7 with SNR = 10 dB and 20 dB
improvement becomes smaller and smaller. This is due to the learning rate ρt going
to a very small value as the iteration number becomes large. Furthermore, after
processing the ﬁrst 1000 mini-batch data, the LPA gaps between the SVI-5/SVI-
10 algorithms and the batch-mode algorithm are nearly unnoticeable. Even for the
SVI-1 algorithm, the LPA gap is just 0.0492◦and 0.0157◦at SNR = 10 dB and
SNR = 20 dB, respectively, showing that SVI-1 provides a very good approximation
to the batch-mode result.
In addition toAlgorithm 7, Fig.5.2 also shows the performance of the algorithm in
[1] (labeled as SGD)3 with an upper bound on the rank (L = 20), and other parameter
settings following those described in [1]. From Fig.5.2, it is clear that Algorithm 7
exhibits much better performance. This is because the algorithm in [1] is not capable
of recovering the correct rank from the provided upper bound, thus the superﬂuous
basis vectors in the factor matrices degrade the subspace recovery accuracy. This
shows the importance of accurate rank information in tensor CPD.
Next, the best sum congruences obtained from different CPD algorithms are
presented in Table5.1. From the table, it can be seen that when SNR = 10 dB,
Algorithm 7 under different mini-batch sizes performs nearly the same as the batch-
mode algorithm in terms of the best sum congruence after processing just 100 mini-
batches of data, and they perform signiﬁcantly better than the SGD algorithm. When
the number of mini-batches is increased to 1000 or beyond, all the schemes would
have the best sum congruence equal or very close to the maximum value (which is 5
for this particular simulation setting). Similar conclusions can be drawn for SNR =
3 Notice that the algorithm in [1] was originally developed for 3D tensors. We extended it to work
in 4D tensor data.

5.4 Numerical Examples
93
Table 5.1 The best sum congruence obtained by different algorithms
Algorithm
SNR = 10 dB
SNR = 20 dB
100
mini-
batches
500
mini-
batches
1000
mini-
batches
2000
mini-
batches
100
mini-
batches
500
mini-
batches
1000
mini-
batches
2000
mini-
batches
SVI-1
4.9999
5.0
5.0
5.0
5.0
5.0
5.0
5.0
SVI-5
5.0
5.0
5.0
5.0
5.0
5.0
5.0
5.0
SVI-10
5.0
5.0
5.0
5.0
5.0
5.0
5.0
5.0
Batch-mode 5.0
5.0
5.0
5.0
5.0
5.0
5.0
5.0
SGD
2.9853
4.9980
4.9994
4.9997
4.9972
4.9994
4.9996
4.9997
SVI-1
SVI-5
SVI-10
Batch-mode VI
0
10
20
30
40
50
60
70
80
Averaged Running Time (s)
10 dB
20 dB
Fig. 5.3 Averaged running time of Algorithm 7 and batch-mode VI
20 dB, except various schemes reach the maximum best sum congruence at an even
smaller number of mini-batches.
On the other hand, the averaged running time of Algorithm 7 (after processing
1000 mini-batch data) and the batch-mode VI algorithm over 100 Monte Carlo runs
are presented in Fig.5.3. It is seen that the SVI-1, SVI-5, and SVI-10 algorithms are
around 20, 8, and 4 times faster than the batch-mode algorithm,4 respectively. This
shows the excellent scalability of the proposed algorithm for massive data.
5.4.2
Tensor Rank Estimation on Synthetic Data
Since the LPA and best sum congruence only give a partial picture of the performance
of Algorithm 7 under unknown rank, the rank determination ability is assessed
4 The termination criterion of the batch-mode algorithm follows the recommendation from [13].

94
5
When Stochastic Optimization Meets VI: Scaling …
explicitly in this subsection. In particular, the tensor rank learned by Algorithm 7
under different SNRs is shown in Fig.5.4, with each vertical bar showing the mean
and the error bars showing the standard deviation of tensor rank estimates. The blue
horizontal dotted line indicates the true tensor rank. From Fig.5.4, it is seen that
Algorithm 7 with different mini-batch sizes recovers the true tensor rank with 100%
accuracy for a wide range of SNRs, in particular when SNR ≥10 dB. Even though
the performance under SNR ≤5 dB is not 100% accurate, it can be observed that
Algorithm 7 still gives estimates close to the true tensor rank with a high probability.
For a comprehensive performance assessment, Table5.2 presents the percentages of
correct rank estimation, overestimation, and underestimation. From Table5.2, it can
be seen that while the percentages of overestimation and underestimation are not
equal in general, they are relatively small even for SNR at 0 dB and 5 dB. Notice
that when the SNR is larger than 5 dB, all of the underestimation and overestimation
percentages are zeros. Thus there is no need to include these results in the table.
One may wonder whether the performance of Algorithm 7 is better than the
classical algorithm starting with a small subset of data and then followed by the
deterministic sequential algorithm in [1]. In particular, the classical method for
ﬁnding the tensor rank is to run multiple ALS-based CPD algorithms with differ-
ent assumed ranks, and then choose the model with the smallest rank that ﬁts the
data well. After the rank is estimated with a small subset of data, the deterministic
sequential algorithm in [1] is used to update the subspace when more data come in
(but with a ﬁxed estimated rank). We refer to such a classical scheme as ALS-SGD.
On the other hand, with the automatic rank estimation ability in the recent batch-
mode probabilistic CPD [13], one could also consider a hybrid scheme in which the
multiple ALSs are replaced by the recent batch-mode probabilistic CPD. We refer
to this hybrid scheme as Probabilistic CPD + SGD.
-5
0
5
10
15
20
25
SNR (dB)
0
1
2
3
4
5
6
7
8
Tensor Rank Estimate
SVI-1
SVI-5
SVI-10
Batch-mode
Fig. 5.4 Rank estimates of Algorithm 7 and batch-mode VI

5.4 Numerical Examples
95
Table 5.2 Percentages of correct rank estimation, underestimation, and overestimation by different algorithms
Algorithm
SNR = −5 dB
SNR = 0 dB
SNR = 5 dB
Underestimation
percentage (%)
Overestimation
percentage (%)
Correct
estimation
percentage (%)
Underestimation
percentage (%)
Overestimation
percentage (%)
Correct
estimation
percentage (%)
Underestimation
percentage (%)
Overestimation
percentage (%)
Correct
estimation
percentage (%)
SVI-1
19
39
42
6
8
86
3
4
93
SVI-5
21
27
52
4
6
90
3
1
96
SVI-10
28
12
60
4
2
94
2
0
98
Batch-mode
26
10
64
4
2
94
0
0
100

96
5
When Stochastic Optimization Meets VI: Scaling …
Table 5.3 Performance of different rank estimation schemes
Algorithm
SNR = 0 dB
SNR = 20 dB
LPA
(degree)
Best sum
congru-
ence
Running
time (s)
Rank
accuracy
(%)
LPA
(degree)
Best sum
congru-
ence
Running
time (s)
Rank
accuracy
(%)
ALS + SGD
0.5094
4.2438
78.3712
79
0.0482
5.0
26.4884
100
Probabilistic
CPD + SGD
0.5094
4.2655
6.1294
79
0.0482
5.0
4.1097
100
SVI-1
0.4484
4.9071
5.2435
86
0.0489
5.0
3.6034
100
To compare the performance of the three schemes, (1) ALS + SGD, (2) Proba-
bilistic CPD + SGD, and (3) SVI-1,5 we conduct experiments on synthetic tensor
data with size 20 × 20 × 20 × 1000. For the classical scheme ALS + SGD and the
Probabilistic CPD + SGD, a subset of data of size 20 × 20 × 20 × 20 was used for
the estimation of the rank. The results are shown in Table5.3. It can be seen that when
the SNR is high (SNR = 20 dB), all three schemes achieve 100% rank estimation
accuracy, the same best sum congruence, and nearly the same LPA. This is because
when the SNR is high, a small amount of data is sufﬁcient to obtain an accurate rank
estimate. On the other hand, when the SNR is low (SNR = 0 dB), both the ALS +
SGD and Probabilistic CPD + SGD schemes achieve lower rank estimation accuracy
along with inferior LPA and best sum congruence compared to those of the SVI-1
algorithm. This is due to the fact that when the SNR is low, the small subset of data
at the beginning is not sufﬁcient for accurate rank estimation, which in turn hurts
the subsequent subspace learning based on the ﬁxed estimated rank. In contrast, the
SVI-1 algorithm makes use of all the data in both rank and subspace estimations,
thus giving better performance. In terms of computation time, since ALS + SGD
needs to run multiple ALS algorithms, it requires a much higher computation time
than the SVI-1 algorithm. For the hybrid scheme, since it is capable of estimating the
rank automatically, its complexity is much smaller than that of the classical scheme
ALS + SGD, but still slightly higher than that of SVI-1.
From the above results, it is obvious that the probabilistic approach (in both
Probabilistic CPD + SGD and SVI-1) is instrumental in reducing the complexity of
rank estimation compared to the classical scheme ALS + SGD. Furthermore, the
SVI-1 has the added advantages of accurate rank estimation, small LPA, and large
best sum congruence under low SNR, since it makes use of all data in rank estimation.
The simulation results presented so far are for well-conditioned tensors, i.e., the
columns in each of the factor matrices are independently generated. In order to fully
assess the rank learning ability of Algorithm 7, we consider another 4D data tensor
[[ ¯A
(1), A(2), A(3), A(4)]] ∈R20×20×20×1000 with rank R = 5. The factor matrix ¯A
(1) =
0.1 × 120×5 + 2−s × A(1). The factor matrices {A(p)}3
p=1 are drawn from MN(A(p)|
5 Since the algorithm in [1] was developed for a mini-batch data with size 1 only, we focus on the
comparison with SVI-1.

5.4 Numerical Examples
97
Table 5.4 Rank estimate accuracy when columns in all factor matrices are correlated
s
0
1
2
3
Batch-mode (%)
100
100
86
0
SVI-1 (%)
100
100
0
0
SVI-5 (%)
100
100
0
0
SVI-10 (%)
100
100
16
0
020×5, I20×20, I5×5), and the matrix A(4) ∼MN(A(4)| 01000×5, I1000×1000, I5×5).
According to the deﬁnition of the tensor condition number [11, 12], when s increases,
the correlation among the columns in the factor matrix ¯A
(1) increases, and the tensor
condition number becomes larger. In particular, when s goes to inﬁnity, the condition
number of the tensor goes to inﬁnity too. Experiments were conducted to evaluate
the rank estimation accuracy of Algorithm 7 and the batch-mode algorithm under
SNR = 20 dB and s ∈{0, 1, 10, 102, 103, 104}. It was found that both Algorithm 7
and the batch-mode algorithm achieve 100% accuracy when the correlation between
columns only happens in one factor matrix, even the tensor condition number is very
large.
Next, we consider an extreme case when the columns in all factor matrices
are highly correlated. In particular, a 4D data tensor [[ ¯A
(1), ¯A
(2), ¯A
(3), ¯A
(4)]] ∈
R20×20×20×1000 with rank R = 5 is constructed, with ¯A
(p) = 0.1 × 120×5 + 2−s ×
A(p) for p = 1, 2, 3, 4. The factor matrices {A(p)}3
p=1 are drawn from MN(A(p)|
020×5, I20×20, I5×5), and the matrix A(4) ∼MN(A(4)| 01000×5, I1000×1000, I5×5).
The performance of the tensor rank estimation is shown in Table5.4. It can be seen
that as s increases (i.e., the columns are more correlated in all factor matrices), the
performance of Algorithm 7, and the batch-mode algorithm degrades accordingly.
5.4.3
Video Background Modeling
One of the most important tasks in video surveillance is to separate the foreground
objects from the background. Since the background remains the same along the video
frames, it can be modeled as the low-rank subspace of the video data. In particular,
after organizing the video data into a 3D tensor (pixels in a frame × RGB × frame)
[13] as shown in Fig.5.5, the background can be extracted using the tensor CPD.
We conduct experiments on the popular shopping mall video data.6 Each frame
is with size 256 × 320, and there are 100 frames. After organizing the data into a
3D tensor with dimension 81920 × 3 × 100 [13], the batch-mode VI algorithm and
the SVI-1 are run to learn the subspace (background). In this application, the SVI-1
is terminated after processing 100 mini-batches (i.e., the number of video frames).
6 http://pages.cs.wisc.edu/jiaxu/projects/gosus/supplement/.

98
5
When Stochastic Optimization Meets VI: Scaling …
Fig. 5.5 Background modeling with a 3D tensor
Fig. 5.6 a Background estimation using the Batch-mode VI and b Background estimation using
the SVI-1 algorithm
The learning results of the two algorithms are shown in Fig.5.6. The value of L
used in this scenario is 3 and the estimated rank is 2, both for the SVI-1 algorithm
and the batch-mode algorithm. It can be seen that the two algorithms achieve nearly
the same performance in background estimation (with mean square error per pixel
being 0.3613). To quantify the difference in the estimation results, Fig.5.7 shows
the LPA between the subspaces estimated by the batch-mode algorithm and the
SVI-1 algorithm. It can be seen that the LPA decreases as more mini-batch data
is processed. At the beginning, the LPA is 10.02◦. But after processing 100 mini-
batch data, the LPA decreases to 0.0776◦. However, the SVI-1 algorithm only costs
1.6317s, while the batch-mode VI algorithm consumes 24.2254s in running time.
Obviously, the SVI-1 algorithm achieves nearly the same performance as the batch-
mode VI algorithm while saving 93.2% computation time. Notice that the video
data might not be generated from a Gaussian distribution, and the CPD factors’
columns modeling the background are not really independent, thus deviating from
the prior assumption (5.5) of the probabilistic model. However, after the Bayesian
inference, the CPD factors’ columns become correlated with covariance matrices
shown in (5.41). In some sense, the inaccurate prior assumption could be remedied
by learning from data, which is validated by the good result shown in Fig.5.6.

5.4 Numerical Examples
99
10
20
30
40
50
60
70
80
90
100
Number of mini-batch
10-2
10-1
100
101
102
Averaged LPA
Fig. 5.7 LPA evolution for video data processing
5.4.4
Image Feature Extraction
In this subsection, we conduct experiments on 1000 images from the CIFAR-10
dataset,7 representing 2 different objects (500 images for the dog and 500 images for
the automobile). In particular, each image is of size 32 × 32, and the training data
can be naturally represented by a fourth-order tensor R32×32×3×1000. The batch-mode
algorithm and the SVI-1 algorithm (terminated after 1000 mini-batches) are run to
learn the basis matrices and the feature vectors of these 1000 training images. With
Fig.5.8 showing the LPA between the subspace estimated by the batch-mode algo-
rithm and the SVI-1 algorithm, it can be seen that after processing 1000 mini-batch
data, the LPA reduces from 90◦to only 0.0503◦. Furthermore, using the obtained
feature vectors of the training images, a 1-nearest neighbors (1-NN) classiﬁer is
trained, and the trained classiﬁer is executed to recognize the objects for another 100
testing images projected onto the basis matrices. The accuracy of the 1-NN classi-
ﬁer using features from the SVI-1 algorithm and the batch-mode algorithm are both
78%, showing that the 0.0503◦LPA does not affect the classiﬁcation performance.
However, the SVI-1 algorithm only costs 4.0533s while the batch-mode algorithm
costs 36.7521s.
7 https://www.cs.toronto.edu/~kriz/cifar.html.

100
5
When Stochastic Optimization Meets VI: Scaling …
0
200
400
600
800
1000
Number of mini-batch
10-2
10-1
100
101
102
Averaged LPA
Fig. 5.8 LPA evolution for image feature extraction
References
1. M. Mardani, G. Mateos, G.B. Giannakis, Subspace learning and imputation for streaming big
data matrices and tensors. IEEE Trans. Signal Process. 63(10), 2663–2677 (2015)
2. J.C. Spall, Introduction to Stochastic Search and Optimization: Estimation, Simulation, and
Control (Wiley, New York, 2003)
3. M. Hoffman, D. Blei, J. Paisley, C. Wang, Stochastic variational inference. J. Mach. Learn.
Res. 14, 1303–1347 (2013)
4. K.P. Murphy, Machine Learning: A Probabilistic Perspective (MIT Press, Cambridge, 2012)
5. M.J. Wainwright, M.I. Jordan, Graphical models, exponential families, and variational infer-
ence. Found. Trends Mach. Learn. 1(102), 1–305 (2008)
6. B. Leon, Large-scale machine learning with stochastic gradient descent, in Proceedings of
COMPSTAT 2010 (Physica-Verlag HD, 2010), pp. 177–186
7. M. Li, D. Andersen, A. Smola, K. Yu, Communication efﬁcient distributed machine learning
with the parameter server, in Proceedings of Neural Information Processing Systems (NIPS)
(2014)
8. M. Li, T. Zhang, Y. Chen, A. Smola, Efﬁcient mini-batch training for stochastic optimization, in
Proceedings of ACM SIGKDD Conference on Knowledge Discovery and Data Mining (KDD)
(2014)
9. C. Udriste, Convex Functions and Optimization Methods on Riemannian Manifolds (Springer
Science and Business Media Press, Berlin, 1994)
10. S. Amari, S.C. Douglas, Why natural gradient?, in Proceedings of the IEEE International
Conference on Acoustics, Speech and Signal Processing (ICASSP), no. 2 (1998), pp. 1213–
1216
11. P. Breiding, N. Vannieuwenhoven, The condition number of join decompositions. SIAM J.
Matrix Anal. Appl. 39(1), 287–309 (2018)
12. N. Vannieuwenhoven, Condition numbers for the tensor rank decomposition. Linear Algebra
Appl. 535, 35–86 (2017)
13. Q. Zhao, G. Zhou, L. Zhang, A. Cichocki, S.I. Amari, Bayesian robust tensor factorization for
incomplete multiway data. IEEE Trans. Neural Netw. Learn. Syst. 27(4), 736–748 (2016)

References
101
14. J. Paisley, D. Blei, M. Jordan, Bayesian nonnegative matrix factorization with stochastic varia-
tional inference, in Handbook of Mixed Membership Models and Their Applications (Chapman
and Hall/CRC, London, 2014)
15. L. Cheng, Y.-C. Wu, H.V. Poor, Probabilistic tensor canonical polyadic decomposition with
orthogonal factors. IEEE Trans. Signal Process. 65(3), 663–676 (2017)
16. N.D. Sidiropoulos, G.B. Giannakis, R. Bro, Blind PARAFAC receivers for DS-CDMA systems.
IEEE Trans. Signal Process. 48(3), 810–823 (2000)
17. P. Tseng, Convergence of a block coordinate descent method for nondifferentiable minimiza-
tion. J. Optim. Theory Appl. 109(3), 475–494
18. L. Cheng, Y.-C. Wu, H.V. Poor, Scaling probabilistic tensor canonical polyadic decomposition
to massive data. IEEE Trans. Signal Process. 66(21), 5534–5548 (2018)

Chapter 6
Bayesian Tensor CPD with Nonnegative
Factors
Abstract In previous chapters, the probabilistic modeling and inference algorithm
for the CPD with no constraint are discussed. In practical data analysis, one usually
has additional prior structural information for the factor matrices, e.g., nonnegative-
ness and orthogonality. Encoding this structural information into the probabilistic
tensor modeling while still achieving tractable inference remains a critical chal-
lenge. In this chapter, we introduce the development of Bayesian tensor CPD with
nonnegative factors, with an integrated feature of automatic tensor rank learning. We
will also connect the algorithm to the inexact block coordinate descent (BCD) to
obtain a fast algorithm.
6.1
Tensor CPD with Nonnegative Factors
In the previous three chapters, the factor matrices of CPD are without constraints.
If the nonnegative constraints are added, the resultant model allows only additions
among the R latent rank-1 components. This leads to a parts-based representation of
the data, in the sense that each rank-1 component is a part of the data, thus further
enhancing the model interpretability. Below is a motivating application.
6.1.1
Motivating Example—Social Group Clustering
Social group clustering could be beneﬁted from tensor data analysis, by which multi-
ple views of social networks are provided [1, 2]; see Fig.6.1. For example, consider a
3D email dataset Y ∈RI×J×K with each element Y(i, j, k) denoting the number of
emails sent from person i to person j at the kth day. Each frontal slice Y(:, :, k) rep-
resents the connection intensity among different pairs of peoples in the kth day, while
each slice Y(:, j, :) shows the temporal evolution of the number of received mails for
the person j from each of the other person in the dataset. Consequently, decompos-
ing the tensor Y into latent CPD factors {A ∈RI×R, B ∈RJ×R, C ∈RK×R} reveals
different clustering groups from different views (i.e., different tensor dimensions).
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023
L. Cheng et al., Bayesian Tensor Decomposition for Signal Processing and
Machine Learning, https://doi.org/10.1007/978-3-031-22438-6_6
103

104
6
Bayesian Tensor CPD with Nonnegative Factors
Fig. 6.1 An application example of CPD: social group clustering
In particular, using the unfolding property of tensor CPD, we have
Y(1) = (C ⋄B)AT ,
(6.1)
Y(3) = (B ⋄A)CT ,
(6.2)
where Y(k) is a matrix obtained by unfolding the tensor Y along its kth dimension,
and symbol ⋄denotes the Khatri–Rao product (i.e., column-wise Kronecker prod-
uct, see Deﬁnition 1.3). From (6.1), each column vector Y(1)(:, i) ∈RJ K×1 can be
written as Y(1)(:, i) = R
r=1(C ⋄B):,r Ai,r, which is a linear combination of column
vectors in matrix (C ⋄B) ∈RJ K×R with coefﬁcients {Ai,r}R
r=1, and it represents the
email sending pattern of person i. Thus, each column vector in matrix C ⋄B can
be interpreted as one of the R underlying email sending patterns, and Ai,r is the
linear combining coefﬁcient to generate the person i’s email pattern. Similarly, from
(6.2), each column in B ⋄A can be interpreted as a temporal pattern and Ck,r is the
coefﬁcient of the rth temporal pattern for generating the kth day’s pattern.
Obviously, due to the complicated multi-view clustering structure, tensor CPD is
superior to the matrix-based models such as k-means or Gaussian mixture model. To
ﬁnd the latent factor matrices from the social network data Y, the following problem
is usually solved:

6.1 Tensor CPD with Nonnegative Factors
105
min
A,B,C ∥Y −A, B, C ∥2
F
s.t. A ≥0I×R, B ≥0J×R, C ≥0K×R,
(6.3)
where the nonnegative constraints are added to allow only additions among the R
latent rank-1 components. This leads to a parts-based representation of the data,
which enhances the model interpretability.
6.1.2
General Problem and Challenges
The general problem, which decomposes a N-dimensional tensor Y ∈RJ1×J2×···×JN
into a set of nonnegative factor matrices {(n)}N
n=1, is formulated as:
min
{(n)}N
n=1
∥Y −
R

r=1
(1)
:,r ◦(2)
:,r ◦· · · ◦(N)
:,r



≜(1),(2),...,(N)
∥2
F
s.t. (n) ≥0Jn×R, n = 1, 2, . . ., N,
(6.4)
where symbol ◦denotes the vector outer product.
In problem (6.4), there are two signiﬁcant challenges. Firstly, nonnegative factor
matrices {(n)}N
n=1 are complicatedly coupled, resulting in a difﬁcult non-convex
optimization problem. To tackle this challenge, alternating optimization is one of
the most commonly used techniques. In each iteration, after ﬁxing all but one fac-
tor matrices, problem (6.4) will become a standard nonlinear least-squares (NLS)
subproblem, for which there are various off-the-shelf algorithms for solving it [3],
including interior point methods and augmented Lagrangian methods. To handle big
tensor data, ﬁrst-order methods, such as Nesterov-type projected gradient descent,
have been proposed to replace the interior point methods to solve each subproblem
[4, 5].
Although pioneering works [4, 5] allow the learning of nonnegative factors from
big multi-dimensional data, they still face the second critical challenge of problem
(6.4): how to automatically learn the tensor rank R from the data? With the physical
meaning of tensor rank being the number of components/groups inside the data, this
value is usually unknown in practice and its estimation has been shown to be NP-
hard. If the tensor CPD has at least one factor matrix without nonnegative constraint
[6–8], this problem can be solved by applying Gaussian-gamma prior (GG) prior or
the Generalized Hyperbolic (GH) prior to the factor matrix without constraint, which
is a slight variation of the standard Bayesian CPD in Chap.3 (note that a standard
CPD is one having no constraint on all factor matrices).

106
6
Bayesian Tensor CPD with Nonnegative Factors
However, when all the factor matrices have nonnegative constraints, GG or GH
prior is not applicable since they are in the form of Gaussian scale mixture (GSM,
see Sect.2.3) and the support of the Gaussian probability density function (pdf) is
not restricted to the nonnegative region. This calls for a different prior distribution
modeling. An immediate idea might be to replace the Gaussian distribution with
the truncated Gaussian distribution with a nonnegative support. However, a closer
inspection is needed since there is no existing work discussing whether a gamma
distribution or generalized inverse Gaussian (GIG) is conjugate to a truncated Gaus-
sian distribution with a nonnegative support. This chapter focuses on demonstrating
the conjugacy of gamma distribution to the truncated Gaussian distribution.
6.2
Probabilistic Modeling for CPD with Nonnegative
Factors
6.2.1
Properties of Nonnegative Gaussian-Gamma Prior
Recall from Chap.2 that for a model parameter vector w ∈RM×1 consisting of S non-
overlapped blocks with each block denoted by ws ∈RMs×1. The Gaussian-gamma
prior can be expressed as
p(w|{αs}S
s=1) =
S

s=1
p(ws|αs) =
S

s=1
N(ws|0Ms×1, α−1
s
I Ms),
(6.5)
p({αs}S
s=1) =
S

s=1
gamma(αs|as, bs),
(6.6)
where αs is the precision parameter (i.e., the inverse of variance, also called weight
decay rate) that controls the relevance of model block ws in data interpretation, and
{as, bs}S
s=1 are pre-determined hyper-parameters. There are two important properties
of Gaussian-gamma prior that lead to its success and prevalence in a variety of appli-
cations. Firstly, after integrating the gamma hyper-prior, the marginal distribution
of model parameter p(w) is a student’s t distribution, which is strongly peaked at
zero and with heavy tails, thus promoting sparsity. Secondly, the gamma hyper-prior
(6.6) is conjugate to the Gaussian prior (6.5). This conjugacy permits the closed-form
solution of the variational inference, which has recently come up as a major tool in
inferring complicated probabilistic models with inexpensive computations.
Unfortunately, the support of the Gaussian pdf in (6.5) is unbounded and thus
cannot model nonnegativeness. On the other hand, the truncated Gaussian prior with
a nonnegative support for each model block ws can be written as:

6.2 Probabilistic Modeling for CPD with Nonnegative Factors
107
p+(w|{αs}S
s=1) =
S

s=1
p+(ws|αs)
=
S

s=1
N(ws|0Ms×1, α−1
s
I Ms)
	 ∞
0Ms ×1 N(ws|0Ms×1, α−1
s
I Ms)
U

ws ≥0Ms×1

,
(6.7)
where the function U

ws ≥0Ms×1

is a unit-step function with value one when
ws ≥0Ms×1, and with a value of zero otherwise. Together with the gamma distribu-
tions (6.6) for modeling the precision parameters {αs}S
s=1, we have the nonnegative
Gaussian-gamma prior. Even though it is clear that nonnegative Gaussian-gamma
priorcanmodelthenonnegativenessofmodelparametersduetotheunit-stepfunction
U

ws ≥0Ms×1

, whether it enjoys the advantages of the vanilla Gaussian-gamma
prior needs further inspection. In the following, two properties of the nonnegative
Gaussian-gamma prior are presented, and their proofs can be found in [9].
Property 6.1. The gamma distribution in (6.6) is conjugate to the nonnegative
Gaussian distribution in (6.7).
Property 6.2. After integrating out the precision parameters {αs}S
s=1, the
marginal pdf of model parameter w is
p+(w) =

p+(w|{αs}S
s=1)p({αs}S
s=1)d{αs}S
s=1
=
S

s=1
2Ms
 1
π
 Ms
2 (as + Ms/2)
(2bs)−as(as) (2bs + wT
s ws)−as−Ms/2
× U

ws ≥0Ms×1

.
(6.8)
It is a product of multivariate truncated student’s t distributions, each of which
is with a nonnegative support.
The shape of the marginal distribution p+(w) is determined by the hyper-parameters
{as, bs}S
s=1. Usually, their values are chosen to be a very small value (e.g., ϵ = 10−6),
since as as →0 and bs →0, a Jeffrey’s non-informative prior p(αs) ∝α−1
s
can be
obtained. After letting the hyper-parameters {as, bs}S
s=1 in (6.8) go to zero, it is easy
to obtain the following property.

108
6
Bayesian Tensor CPD with Nonnegative Factors
0
20
40
60
80
100
x
10-8
10-6
10-4
10-2
100
102
ln(p(x))
a = 0.1, b = 1
a = 1, b = 1
a = 10-6, b = 10-6
Fig. 6.2 Univariate marginal probability density functions with different parameters (© [2020]
IEEE. Reprinted, with permission, from [L. Cheng, X. Tong, S. Wang, Y.-C. Wu, and H. V. Poor,
Learning Nonnegative Factors From Tensor Data: Probabilistic Modeling and Inference Algorithm,
IEEE Transactions on Signal Processing, Jan 2020]. It also applies to Figs.6.3, 6.4, 6.5, 6.6, 6.7,
6.8, 6.9, 6.10 and Tables6.1, 6.2, 6.3, 6.4, 6.5)
Property 6.3. If as →0 and bs →0, the marginal pdf (6.8) becomes
p+(w) ∝
S

s=1
2Ms

1
||ws||2
Ms
U

ws ≥0Ms×1

,
(6.9)
which is highly peaked at zeros.
As an illustration for Properties 6.2 and 6.3, univariate marginal pdfs with dif-
ferent hyper-parameters {as, bs}S
s=1 are plotted in Fig.6.2, from which it is clear that
the nonnegative Gaussian-gamma prior is sparsity-promoting. Further with the con-
jugacy property revealed in Property 6.1, the nonnegative Gaussian-gamma prior is
a good candidate for probabilistic modeling with nonnegative model parameters.

6.2 Probabilistic Modeling for CPD with Nonnegative Factors
109
6.2.2
Probabilistic Modeling of CPD with Nonnegative
Factors
IntheCPDproblemwithnonnegativefactorsin (6.4),thelth columngroup{(n)
:,l }N
n=1,
which consists of the lth column of all the factor matrices, can be treated as a
model block since their outer product contributes a rank-1 tensor. Therefore, with
the principle of nonnegative Gaussian-gamma prior in the previous subsection, the
lth column group {(n)
:,l }N
n=1 can be modeled using (6.7), but with ws replaced by
{(n)
:,l }N
n=1 and αs replaced by γl. Considering the independence among different
column groups in {(n)}N
n=1, we have
p({(n)}N
n=1|{γl}L
l=1)=
N

n=1
L

l=1
N

(n)
:,l |0Jn×1, γ −1
l
I L

	 ∞
0Jn×1 N

(n)
:,l |0Jn×1, γ −1
l
I L

d(n)
:,l
U

(n)
:,l ≥0Jn×1

,
(6.10)
p({γl}L
l=1|λγ ) =
L

l=1
gamma(γl|c0
l , d0
l ),
(6.11)
where the precision γl is modeled as a gamma distribution. From discussions below
Property 6.2, c0
l and d0
l can be chosen to be very small values (e.g., c0
l = d0
l = ϵ =
10−6) to approach a non-informative prior of precision parameter γl.
On the other hand, the least-squares objective function in the nonnegative tensor
CPD problem (6.4) motivates the use of a Gaussian likelihood [6–8]:
p

Y | (1), (2), . . ., (N), β

∝exp

−β
2 ∥Y −(1), (2), . . ., (N) ∥2
F

,
(6.12)
in which the parameter β represents the inverse of noise power. Since there is no
information about it, a gamma distribution p(β|αβ) = gamma(β|ϵ, ϵ) with very
small ϵ is employed, making p(β|αβ) approaches Jeffrey’s non-informative prior.
The Gaussian likelihood function in (6.12) is with an unbounded support over the
real space, and thus it is suitable for applications such as ﬂuorescence data analysis
and blind speech separation, in which the observed data Y could be both positive
and negative. On the other hand, if the data Y are all nonnegative and continuous
(e.g., the email dataset [1, 2] after pre-processing), a truncated Gaussian likelihood
can be used to model the data:
p

Y | (1), (2), . . ., (N), β

∝exp

−β
2 ∥Y −(1), (2), . . ., (N) ∥2
F

U(Y ≥0).
(6.13)
Finally, the complete probabilistic model is a three-layer Bayes network and is illus-
trated in Fig.6.3.

110
6
Bayesian Tensor CPD with Nonnegative Factors
Fig. 6.3 Probabilistic model
for tensor CPD with
nonnegative factors
β
{γl}L
l=1
λγ
αβ
0
· · ·
Ξ(1)
Ξ(2)
Ξ(N)
Y
≥0
6.3
Inference Algorithm for Tensor CPD with Nonnegative
Factors
The unknown parameter set  includes the factor matrices {(n)}N
n=1, the noise
power β−1, and the precision parameter {γl}L
l=1. Recall from Chaps.2 and 3 that
under mean-ﬁeld assumption Q() = K
k=1 Q(k), the optimal variational pdf is
obtained by solving
min
Q(k)

Q(k)(−E
j̸=k Q( j)

ln p(, Y)

+ ln Q(k))dk,
(6.14)
and its solution is
Q∗(k) =
exp

E
j̸=k Q( j)

ln p (, Y)

	
exp

E
j̸=k Q( j)

ln p (, Y)

dk
.
(6.15)
Nevertheless, even under the mean-ﬁeld family assumption, the unknown param-
eter (k) is still difﬁcult to be inferred since its moments cannot be easily computed.
In particular, in the proposed probabilistic model, if no functional assumption is
made for variational pdf Q((k)), after using (6.15), a multivariate truncated Gaus-

6.3 Inference Algorithm for Tensor CPD with Nonnegative Factors
111
sian distribution would be obtained, of which the moments are known to be very
difﬁcult to be computed due to the multiple integrations involved [10]. In this case,
the variational pdf Q((k)) could be further restricted to be a Dirac delta function
Q((k)) = δ((k) −ˆ
(k)), where ˆ
(k) is the point estimate of the parameter (k).
After substituting this functional form into problem (6.14), the optimal point estimate
ˆ
(k)∗is obtained by
ˆ
(k)∗= arg max E
 j ̸=(k) Q( j)

ln p (, Y)

.
(6.16)
This is indeed the framework of variational expectation maximization (EM), in which
the factor matrices {(k)}N
k=1 are treated as global parameters and other variables are
treated as latent variables (see also the discussion around (2.7)).
In (6.15) and (6.16), the log of the joint pdf ln p (, Y) needs to be evaluated. If
the Gaussian likelihood function (6.12) is adopted, it is expressed as
ln p† (, Y) =
N

n=1
ln

U((n) ≥0Jn×L)

+
N
n=1 Jn
2
ln β
−β
2 ∥Y −(1), (2), . . . , (N)∥2
F +
N

n=1
Jn
2
L

l=1
ln γl
−
N

n=1
1
2Tr

(n)(n)T 
+
L

l=1

(10−6 −1) ln γl −10−6γl

+ (10−6 −1) ln β −10−6β + const,
(6.17)
where  = diag{γ1, γ2, . . ., γL}. On the other hand, if the truncated Gaussian likeli-
hood (6.13) is used, the log of the joint pdf ln p♯(, Y) takes the following form:
ln p♯(, Y) = ln p† (, Y) −ln 

{(n)}N
n=1, β

+ const.
(6.18)
where


{(n)}N
n=1, β

=
 ∞
0
 β
2π
N
n=1
Jn
2
exp
−β
2
∥Y −(1), (2), . . ., (N) ∥2
F

dY.
(6.19)
In (6.18), the term ln 

{(n)}N
n=1, β

, which arises from the truncated Gaussian
likelihood in (6.13), is very difﬁcult to evaluate and differentiate, due to the multi-
ple integrations involved. Fortunately, for most applications in Bayesian nonneg-
ative matrix/tensor decomposition, the conﬁdence of the low-rank matrix/tensor
model is relatively high, in the sense that the noise power 1/β is small com-
pared to the average element in signal tensor (1), (2), . . ., (N). Under this
assumption, it is easy to see ln 

{(n)}N
n=1, β

≈ln 1 = 0, since Gaussian pdf

112
6
Bayesian Tensor CPD with Nonnegative Factors
-1
0
1
2
3
4
5
0
0.2
0.4
0.6
0.8
1
1.2
1.4
Fig. 6.4 Illustration of a univariate Gaussian probability density function with its mean much larger
than the variance
p(Y) =

β
2π


n Jn
2
exp

−β ∥Y −(1), (2), . . ., (N) ∥2
F

dY
decays
very
rapidly and thus most densities are over the region Y ≥0. As an illustration, a
univariate Gaussian pdf with its mean much larger than the variance is plotted in
Fig.6.4, in which the probability density in the negative region is negligible. This
suggests that the log of the joint pdf ln p♯(, Y) in (6.18) can be well approximated
by ln p† (, Y) in (6.17), and therefore, algorithm derivations are uniﬁed for the two
likelihoods. This also explains why the previous Bayesian nonnegative matrix/tensor
decompositions all employ the Gaussian likelihood function.
6.3.1
Derivation for Variational Pdfs
As discussed at the beginning of this section, the mean-ﬁeld approximation is
employed to enable closed-form expression for each variational pdf. For the pre-
cision parameter γl, by substituting (6.17) into (6.15) and only taking the terms
relevant to γl, the variational pdf Q(γl) can be found to take the same functional
form as that of the gamma distribution, i.e., Q(γl) = gamma(γl|cl, dl) with

6.3 Inference Algorithm for Tensor CPD with Nonnegative Factors
113
cl =
N

n=1
Jn
2 + ϵ,
(6.20)
dl =
N

n=1
1
2EQ((n))

(n)T
:,l
(n)
:,l

+ ϵ.
(6.21)
Since the variational pdf Q(γl) is determined by parameters cl and dl, its update is
equivalent to the update of the two parameters in (6.20) and (6.21).
Similarly, using (6.15) and (6.17), the variational pdf Q(β) can be found to be a
gamma distribution Q(β) = gamma(β|e, f ), where
e =
N
n=1 Jn
2
+ ϵ,
(6.22)
f = 1
2E
 j ̸=β Q( j)

∥Y −(1), (2), . . . , (N)∥2
F

+ ϵ.
(6.23)
On the other hand, by substituting (6.17) into (6.16), the point estimate of ˆ
(k)
can be obtained via solving the following problem:
max E
 j ̸=(k) Q( j)

ln

U((k) ≥0Jk×L)

−β
2 ∥Y −(1), (2), . . . , (N)∥2
F −1
2Tr

(k)(k)T 
.
(6.24)
After distributing the expectations, expanding the Frobenius norm, and utilizing the
fact that ln(0) = −∞, problem (6.24) can be equivalently shown to be
min f ((k))
s.t. (k) ≥0Jk×L,
(6.25)
where
f ((k)) = 1
2Tr

(k)E
 j ̸=(k) Q( j)

βB(k)B(k)T + 

(k)T
−2β(k)E
 j ̸=(k) Q( j)

B(k)
Y(k)T 
.
(6.26)
In (6.26), the term B(k) =

N⋄
n=1,n̸=k (n)T
, with the multiple Khatri–Rao products
N⋄
n=1,n̸=k A(n) = A(N) ⋄A(N−1) ⋄· · · ⋄A(k+1) ⋄A(k−1) ⋄· · · ⋄A(1). It is easy to see
that problem (6.25) is a quadratic programming (QP) problem with nonnegative
constraints. Since each diagonal element γl in the diagonal matrix  is larger than
zero, the Hessian matrix of the function f ((k)), with the expression being

114
6
Bayesian Tensor CPD with Nonnegative Factors
H(k) = E
 j ̸=(k) Q( j)

βB(k)B(k)T + 

(6.27)
is positive deﬁnite. This implies that problem (6.25) is a convex problem, and its
solutions have been investigated for decades. In particular, ﬁrst-order methods have
recently received much attention due to their scalability in big data applications.
Within the class of ﬁrst-order methods, a simple gradient projection method is intro-
duced as follows.
In each iteration of the gradient projection method, the update equation is of the
form:
(k,t+1) =

(k,t) −αt▽f ((k,t))

+ ,
(6.28)
where the gradient ▽f ((k,t)) is computed as
▽f ((k,t)) = (k,t)E
 j ̸=(k) Q( j)

βB(k)B(k)T + 

−Y(k)E
 j ̸=(k) Q( j)

βB(k)T 
.
(6.29)
In (6.29), the symbol [·]+ denotes projecting each element of (k) to [0, ∞) (i.e.,
[x]+ = x if x ≥0 and [x]+ = 0 otherwise) and αt ≥0 is the step size. During
the inference, due to the sparsity-promoting property of the nonnegative Gaussian-
gamma prior, some of the precision parameters will go to very large numbers while
some of them will tend to be zero. This will result in a very large condition number
of the Hessian matrix H(k). In this case, applying the diminishing rule1 to the step
size αt still enjoys a good convergence performance [3] and thus is set as the default
step size rule in the algorithm.
6.3.2
Summary of the Inference Algorithm
From Eqs.(6.20)–(6.29), it can be seen that we need to compute various expectations.
In particular, for expectations EQ((n))[(n)], EQ(γl)[γl], and EQ(β)[β], their com-
putations are very straightforward, i.e., EQ((n))[(n)] = ˆ
(n), EQ(γl)[γl] = cl/dl,
and EQ(β)[β] = e/f . However, when updating ˆ
(n) using (6.25) and (6.26), there
is one complicated expectation E
 j ̸=(k) Q( j)

B(k)B(k)T 
. Fortunately, it can
be shown that E
 j ̸=(k) Q( j)

B(k)B(k)T 
=
N⊙
n=1,n̸=k
ˆ
(n)T ˆ
(n), where the multi-
ple Hadamard products
N⊙
n=1,n̸=k A(n) = A(N) ⊙A(N−1) ⊙· · · ⊙A(k+1) ⊙A(k−1) ⊙
· · · ⊙A(1). Since the computation of one variational pdf needs the statistics of other
1 In the diminishing rule [3], the step size αt needs to satisfy αt →0 and ∞
t=0 αt = ∞.

6.3 Inference Algorithm for Tensor CPD with Nonnegative Factors
115
Algorithm 8 Probabilistic Tensor CPD with Nonnegative Factors (PNCPD)
Initializations: Choose L > R and initial values { ˆ
(n,0)}N
n=1, ϵ.
Iterations: For the sth iteration (s ≥0),
Update the parameter of Q((k))(s+1):
Set initial value (k,0) = ˆ
(k,s).
Iterations: For the tth iteration (t ≥0), compute
(k,t+1) =

(k,t) −αt▽f ((k,t))

+ ,
where
▽f ((k,t)) = (k,t) es
f s
N⊙
n=1,n̸=k
ˆ
(n,s)T ˆ
(n,s) + diag{ cs
1
ds
1
, . . ., cs
L
ds
L
}

−es
f s Y(k)
N⋄
n=1,n̸=k
ˆ
(n,s)
,
and αt is chosen by the diminishing rule [42, p. 227].
Until Convergence
Set ˆ
(k,s+1) = (k,t+1).
Update the parameter of Q(γl)s+1:
cs+1
l
=
N

n=1
Jn
2 + ϵ,
ds+1
l
=
N

n=1
1
2
ˆ
(n,s+1)T
:,l
ˆ
(n,s+1)
:,l
+ ϵ.
Update the parameter of Q(β)s+1:
es+1 = ϵ +
N
n=1 Jn
2
,
f s+1 = ϵ + 1
2 ∥Y − ˆ
(1,s+1), ˆ
(2,s+1), . . . , ˆ
(N,s+1) ∥2
F .
Until Convergence
variational pdfs, alternating update is needed, resulting in the iterative algorithm
summarized in Algorithm 8.
6.3.3
Discussions and Insights
To gain further insight from the inference algorithm, discussions of its convergence
property, automatic rank determination, relationship to the NALS algorithm, com-
putational complexity, and scalability improvement are presented in the following.

116
6
Bayesian Tensor CPD with Nonnegative Factors
6.3.3.1
Convergence Property
Algorithm 8 is derived under the framework of mean-ﬁeld variational inference,
where a variational pdf Q() = 
k Q(k) is sought that minimizes the KL diver-
gence KL (Q()||p(|Y)). Even though this problem is known to be non-convex
due to the non-convexity of the mean-ﬁeld family set, it is convex with respect to a
single variational pdf Q(k) after ﬁxing other variational pdfs {Q( j), j ̸= k} [3].
Therefore, the iterative algorithm, in which a single variational pdf is optimized in
each iteration with other variational pdfs ﬁxed, is essentially a coordinate descent
algorithm in the functional space of variational pdfs. Since the subproblem in each
iteration is not only convex but also has a unique solution, the limit point gener-
ated by the coordinate descent steps over the functional space of variational pdfs is
guaranteed to be at least a stationary point of the KL divergence [3].
6.3.3.2
Automatic Rank Determination
During the inference, the expectations of some precision parameters {γl}, i.e., { cs
l
ds
l }
will go to a very large value. It indicates that the corresponding columns in the factor
matrices are close to zero vectors, thus playing no role in data interpretation. As
a result, after convergence, those columns can be pruned out and the number of
remaining columns in each factor matrix gives the estimate of tensor rank.
In practice, to reduce the computational complexity, the pruning would be exe-
cuted during the iteration. In particular, in each iteration, after the precision estimates
{ cs
l
ds
l } exceed a certain threshold (e.g., 106), the associated columns are safely pruned
out.Aftereverypruning,itisequivalenttostartingminimizationoftheKLdivergence
of a new (but smaller) probabilistic model, with the current variational distributions
acting as the initialization of the new minimization. Therefore, the pruning steps will
not affect the convergence and are widely used in recent related works [6–8].
Usually, the hyper-parameters {c0
l , d0
l } of the prior gamma distribution are set to
be a very small number ϵ = 10−6 to approach a non-informative prior. Otherwise,
their values might affect the behavior of tensor rank estimate. For example, if we
prefer a high value of the tensor rank, the initial value d0
l can be set to be very large
while the initial value c0
l can be set to be small, so that the update of cl
dl can be steered
toward a small value in order to promote a high tensor rank. However, how to set
the hyper-parameters to accurately control the degree of low rank is challenging and
deserves future investigation.
6.3.3.3
Relationship to NALS Algorithm
The mean-ﬁeld variational inference for tensor CPD problem could be interpreted
as alternating optimizations over the Riemannian space (in which the Euclidean
space is a special case). This insight has been revealed in previous works [8, 11],

6.4 Algorithm Accelerations
117
and can also be found in Algorithm 8. For example, for the precision parameters
and the noise power parameter, the variational pdfs are with no constraint on the
functional form, and thus, the corresponding alternating optimization is over the
Riemannian space due to the exponentially conjugacy property of the probabilistic
model [8, 11]. On the other hand, for unknown factor matrices, since the variational
pdfs to be optimized are with a delta functional form, the corresponding alternating
optimization is over the Euclidean space, thus is similar to the conventional NALS
step. However, there is a signiﬁcant difference. In Algorithm 8, there is a shrinkage
term  appeared in the Hessian matrix in (6.27), and  will be updated together with
other parameters in the algorithm. This intricate interaction is due to the employed
Bayesian framework and cannot be revealed by NALS framework. Consequently,
Algorithm 8 is a generalization of the NALS algorithm, with the additional novel
feature in automatic rank determination achieved via optimization in Riemannian
space.
6.3.3.4
Computational Complexity
For each iteration, the computational complexity is dominated by computing the
gradient of each factor matrix in (6.28), costing O(N
n=1 JnL). From this expression,
it is clear that the computational complexity in each iteration is linear with respect to
thetensordimensionproductN
n=1 Jn.Consequently,thecomplexityofthealgorithm
is O(q(N
n=1 JnL)) where q is the iteration number at convergence.
6.4
Algorithm Accelerations
From Algorithm 8, it is clear that the bottleneck of the algorithm computation is
the update of factor matrices {(n)}N
n=1 via solving problem (6.25). In particular, for
each subproblem for solving (k), projected gradient may take a large number of
iterations to converge. Fortunately, if the problem is well conditioned, in the sense that
the condition number of the Hessian matrix H(k) in (6.27) is smaller than a threshold
(e.g., 100), acceleration schemes, including variants of the Nesterov scheme [4],
can be utilized to signiﬁcantly reduce the required number of iterations for solving
problem (6.25), thus speeding up Algorithm 8.
On the other hand, since (k) for k = 1, 2, . . . , n are updated alternatively under
the framework of block coordinate descent (BCD), besides reducing the iteration
number for solving each (k), we can also borrow the idea of inexact BCD, where
each subproblem for (k) is not exactly solved, thus avoiding the large number of
iterations required for convergence. In general, as long as the solution of each (k)
leads to a reduction of the overall optimization objective function, inexact BCD
reduces the computation times signiﬁcantly while maintaining the solution quality.
Below, we will give the details on how to connect Algorithm 8 to inexact BCD.
More speciﬁcally, Algorithm 8 can be viewed as solving the following determin-
istic optimization problem:

118
6
Bayesian Tensor CPD with Nonnegative Factors
min
{(n)≥0}N
n=1,{γl}L
l=1,β g(),
(6.30)
where
g() = −
N
n=1 Jn
2
ln β + β
2 ∥Y −(1), (2), . . . , (N)∥2
F −
N

n=1
Jn
2
L

l=1
ln γl
+
N

n=1
1
2Tr

(n)(n)T 
−
L

l=1

c0
l ln γl −d0
l γl

−e0 ln β + f 0β, (6.31)
with  = diag{γ1, . . ., γL}. To see the connection between solving (6.30) and
Algorithm 8, the BCD method could be employed. That is, in each iteration, after
ﬁxing other unknown parameters { j} j̸=k at their last updated values, k is updated
as follows:
t+1
k
= arg min
k g(t+1
1
, . . ., t+1
k−1, k, t
k+1, . . ., t
K).
(6.32)
This connection is formally stated in Proposition 6.1.
Proposition 6.1. Assume each initial value of the unknown parameter 0
k in
(6.32) equal to the expectation of k with respect to the initial variational
pdf Q0(k) in Algorithm 1. With the same update schedule for various
parameter blocks, in each iteration, the result of the block minimization
update (6.32) for parameter k equals to the expectation of k with respect
to the variational pdf Q(k) from Algorithm 8, i.e., t
k = EQt(k)[k].
Therefore, Algorithm 8 is indeed related to parameter block minimization of the
optimization problem (6.30). This new interpretation opens up the possibility of using
inexact BCD to accelerate Algorithm 8 and its detailed derivations are presented as
follows.
For updating noise precision parameter β in the iteration t + 1(t ≥0), after ﬁxing
other parameters in problem (6.30), the subproblem is expressed as
min
β ht+1(β),
(6.33)
where
ht+1(β) = −
N
n=1 Jn
2
+ e0

ln β
+ β
1
2 ∥Y −(1),t+1, (2),t+1, . . . , (N),t+1 ∥2
F + f 0

.
(6.34)

6.4 Algorithm Accelerations
119
However, the objective function ht+1(β) is not strongly convex since the second-
order derivative ▽2
βht+1(β) =
 N
n=1 Jn
2
+ e0
1
β2 can be arbitrarily close to zero as
β →∞. Consequently, the block minimization scheme cannot be used. To guarantee
convergence, as suggested in [3, 12–15], a proximal term μβ
2 (β −βt)2 is added to
the objective function in (6.33), giving the following optimization problem:
min
β ht+1(β) + μβ
2 (β −βt)2,
(6.35)
with parameter 0 < μβ < ∞. After setting the derivative of the objective function
of (6.35) to zero, it can be shown that the optimal solution takes a closed form:
βt+1 =
−

f t+1 −μββt
+

f t+1 −μββt2 + 4μβet+1
2μβ
,
(6.36)
in which
et+1 =
N
n=1 Jn
2
+ e0,
(6.37)
f t+1 = 1
2 ∥Y −(1),t+1, (2),t+1, . . . , (N),t+1 ∥2
F + f 0.
(6.38)
Similarly, for updating parameter γl, the subproblem is
min
γl ht+1(γl),
(6.39)
where
ht+1(γl) = −
 N

n=1
Jn
2 + c0
l

ln γl + γl

d0
l +
N

n=1
1
2

(n),t+1
:,l
T
(n),t+1
:,l

(6.40)
is not strongly convex. Therefore, a proximal term
μγl
2 (γl −γ t
l )2 with 0 < μγl < ∞
is added to the objective function in (6.39) as follows [3, 12–15]:
min
γl ht+1(γl) + μγl
2 (γl −γ t
l )2,
(6.41)
of which the optimal solution can be shown to be
γ t+1
l
=
−

dt+1
l
−μγlγ t
l

+

dt+1
l
−μγlγ t
l
2 + 4μγlct+1
l
2μγl
,
(6.42)

120
6
Bayesian Tensor CPD with Nonnegative Factors
where parameters ct+1
l
and dt+1
l
are
ct+1
l
=
N

n=1
Jn
2 + c0
l ,
(6.43)
dt+1
l
=
N

n=1
1
2

(n),t+1
:,l
T
(n),t+1
:,l
+ d0
l .
(6.44)
For updating each nonnegative factor in the iteration t + 1(t ≥0), after ﬁxing
other parameters, the subproblem can be formulated as:
min
(n)≥0 ht+1((n)),
(6.45)
where
ht+1((n)) = βt
2 ∥Y −(1),t+1, . . . , (n), . . . , (N),t∥2
F +1
2Tr

(n)t(n)T 
.
(6.46)
After expanding the Frobenius norm and some algebraic operations, problem (6.45)
can be equivalently formulated as:
min
(n)≥0 ct+1((n)),
(6.47)
where
ct+1((n))= 1
2Tr

(n) 
βt 
B(n),tT B(n),t + t
(n)T −2βt(n) 
B(n),tT Y(n)

.
(6.48)
In (6.48), matrix B(n),t = (N),t ⋄· · · ⋄(n+1),t ⋄(n−1),t+1 ⋄· · · ⋄(1),t+1, where
⋄denotes the Khatri–Rao product (see Deﬁnition 1.3), and Y(k) is a matrix obtained
by unfolding the tensor Y along its kth dimension (see Deﬁnition 1.1).
In the inexact BCD framework, it is not necessary to obtain the optimal solution of
(6.47). Instead, we can construct a prox-linear update step with careful extrapolations
and monotonicity-guaranteed modiﬁcations. In particular, in the iteration t + 1, the
extrapolation parameter wt
n is computed by [12, 14–16]:
wt
n = min
⎛
⎝ˆwt
n, pw

Lt−1
n
Ltn
⎞
⎠,
(6.49)

6.4 Algorithm Accelerations
121
where pw < 1 is preselected, ˆwt
n = st−1
st+1 with s0 = 1, st+1 = 1
2(1 +
 
1 + 4s2
t ), and
Lt
n is assigned to be the spectral norm of the Hessian matrix of ct+1((n)), i.e.,
Lt
n = ||βt 
B(n),tT B(n),t + t||2.
(6.50)
Using (6.49), the extrapolated factor matrix ˆM
(n),t is with the expression:
ˆM
(n),t = (n),t + wt
n((n),t −(n),t−1).
(6.51)
Based on (6.51), the prox-linear update can be expressed as [12]:
(n),t+1 = arg min
(n)≥0
!
▽ct+1( ˆM
(n),t), (n) −ˆM
(n),t"
+ Lt
n
2 ||(n) −ˆM
(n),t||2
F,
(6.52)
where the gradient is
▽ct+1((n)) = (n) 
βt 
B(n),tT B(n),t + t
−βtY(n)T B(n),t,
(6.53)
and ⟨·, ·⟩denotes the inner product of the arguments. It can be shown that the solution
of (6.52) takes the following closed form:
(n),t+1 =

ˆM
(n),t −1
Ltn
▽ct+1( ˆM
(n),t)

+
,
(6.54)
from which it can be seen that the prox-linear update only needs one-step computation
and thus can be computed very fast.
Besides the extrapolation, monotonicity-guaranteed modiﬁcation is needed to
ensure the convergence [12]. More speciﬁcally, after updating all the parameters in
, whether the objective function of problem (6.30) is decreased (i.e., g(t+1) ≤
g(t)) is tested. If not, prox-linear update (6.54) for each factor matrix (n),t+1 will
be re-executed without the extrapolation, i.e.,
(n),t+1 =

(n),t −1
Ltn
▽ct+1((n),t)

+
.
(6.55)
Using (6.36), (6.42), (6.54), and (6.55), the inexact BCD-based algorithm for
probabilistic tensor CPD with nonnegative factors is summarized in Algorithm 9.

122
6
Bayesian Tensor CPD with Nonnegative Factors
Algorithm 9 Inexact BCD-Based Probabilistic Tensor CPD with Nonnegative
Factors
Initializations: Choose L > R, pw < 1, {μγl }L
l=1, μβ and initial values {(n),0, (n),−1}N
n=1,
{c0
l , d0
l }L
l=1, e0, f 0.
Iterations: For the iteration t + 1 (t ≥0),
For n = 1 to N
Update factor matrix (n),t+1:
Compute extrapolation parameter wt
n using (6.49).
Compute extrapolated factor matrix:
ˆM
(n),t = (n),t + wt
n((n),t −(n),t−1).
Update factor matrix:
(n),t+1 =

ˆM
(n),t −1
Ltn
▽ct+1( ˆM
(n),t)

+
,
where ▽ct+1( ˆM
(n),t) is computed using (6.53), and Lt
n is computed using (6.50).
End
Update parameter γ t+1
l
:
γ t+1
l
=
−

dt+1
l
−μγl γ t
l

+
#
dt+1
l
−μγl γ t
l
2
+ 4μγl ct+1
l
2μγl
,
where ct+1
l
and dt+1
l
are computed via (6.43) and (6.44), respectively.
Update parameter βt+1:
βt+1 =
−

f t+1 −μββt
+

f t+1 −μββt2 + 4μβet+1
2μβ
,
where et+1 and f t+1 are computed via (6.37) and (6.38), respectively.
Monotonicity check:
Let t+1 = {{(n),t+1}N
n=1, {γ t+1
l
}L
l=1, βt+1}.
If g(t+1) > g(t):
(n),t+1 =

(n),t −1
Ltn
▽ct+1((n),t)

+
.
Until Convergence
6.5
Numerical Results
In this section, numerical results using synthetic data are ﬁrstly presented to
assess the performance of Algorithm 8 in terms of convergence property, fac-
tor matrix recovery, tensor rank estimation, and running time. Next, Algorithm 8
is utilized to analyze two real-world datasets (the amino acids ﬂuorescence data

6.5 Numerical Results
123
and the ENRON email corpus), for the demonstration on blind source separa-
tion and social group clustering. For all the simulated algorithms, the initial fac-
tor matrix ˆ
(k,0) is set as the singular value decomposition (SVD) approxima-
tion U:,1:L

S1:L,1:L
 1
2 where [U, S, V] = SVD[Y(k)] and L = min{J1, J2, . . ., JN}.
The parameter ϵ is set to be 10−6. The algorithms are deemed to be converged
when ∥ ˆ
(1,s+1), ˆ
(2,s+1), . . . , ˆ
(N,s+1) − ˆ
(1,s), ˆ
(2,s), . . . , ˆ
(N,s) ∥2
F< 10−6.
All experiments were conducted in Matlab R2015b with an Intel Core i7 CPU at 2.2
GHz.
6.5.1
Validation on Synthetic Data
A 3D tensor X = M(1), M(2), M(3) ∈R100×100×100 with rank R = 10 is consid-
ered as the noise-free data tensor. Each element in factor matrix M(n) is inde-
pendently drawn from a uniform distribution over [0, 1] and thus is nonnegative.
On the other hand, two observation data tensors are considered: (1) the data X
is corrupted by a noise tensor W ∈R100×100×100, i.e., Y = X + W, with each
element of noise tensor W being independently drawn from a zero-mean Gaus-
sian distribution with variance σ 2
w, and this corresponds to the Gaussian like-
lihood model (6.12); (2) the data Y+ is obtained by setting the negative ele-
ments of Y to zero, i.e., Y+
i1,i2,i3 = Yi1,i2,i3U(Yi1,i2,i3 ≥0), and the truncated Gaus-
sian likelihood model (6.13) is employed to ﬁt these data. The SNR is deﬁned
as
10 log10

∥X ∥2
F /Ep(W)

∥W ∥2
F

= 10 log10

∥X ∥2
F /(1003σ 2
w)

.
For
Algorithm 8, the step size sequence is chosen as αt = 10−3/(t + 1) [3], and the
gradient projection update is terminated when || f ((k,t)) −f ((k,t−1))||F ≤10−3.
Each result in this subsection is obtained by averaging 100 Monte Carlo runs.
Figure6.5 presents the convergence performances of Algorithm 8 under different
SNRs and different test data, where the mean square error (MSE) ∥ ˆ
(1,s), ˆ
(2,s),
ˆ
(3,s) −X ∥2
F is chosen as the assessment criterion. From Fig.6.5a, it can be seen
that for test data Y, the MSEs of Algorithm 8, which assumes no knowledge of
tensor rank, decrease signiﬁcantly in the ﬁrst few iterations and converge to the
MSE of the NALS algorithm [17] (with exact tensor rank) under SNR = 10 dB and
SNR = 20 dB. Similar convergence performances can be observed for the test data
Y+ in Fig.6.5b. This is of no surprise because approximating (6.18) by (6.17) does
not make any changes in the algorithm framework of variational inference, and thus,
the excellent convergence performance of Algorithm 8 is expected.
The MSE in Fig.6.5 measures the performance of low-rank tensor recovery as
a whole but does not indicate the accuracy at factor matrices level. On the other
hand, due to the uniqueness property of tensor CPD [18], each factor matrix can be
recovered up to an unknown permutation and scaling ambiguity. To assess the accu-
racies of factor matrices recovery, the best congruence ratio (BCR), which involves

124
6
Bayesian Tensor CPD with Nonnegative Factors
10
20
30
40
50
60
70
80
90
100
Iteration number
102
104
106
108
1010
MSE
Data Y
SNR = 10 dB
SNR = 20 dB
Benchmark:
NALS with correct
tensor rank
(a)
10
20
30
40
50
60
70
80
90
100
Iteration number 
102
104
106
108
1010
MSE
Data Y +
SNR = 10 dB
SNR = 20 dB
Benchmark:
NALS with correct
tensor rank
(b)
Fig. 6.5 Convergence of the proposed algorithm for different test data
computing the MSE between the true factor matrix M(k) and the estimated factor
matrix ˆ
(k), is widely used as the assessment criterion. It is deﬁned as
3

k=1
min
(k),P(k)
||M(k) −ˆ
(k) P(k)(k)||F
||M(k)||F
,
where the diagonal matrix (k) and the permutation matrix P(k) are found via the
greedy least-squares column matching algorithm [19]. From Fig.6.6, it is seen that
both Algorithm 8 (labeled as PNCPD) and the NALS algorithm (with exact ten-
sor rank) achieve much better factor matrix recovery than the ALS algorithm (with
exact tensor rank) [18]. This shows the importance of incorporating the nonnegative
constraint into the algorithm design. Furthermore, the factor matrix recovery per-
formances of Algorithm 8 under test data Y and Y+ are indistinguishable under
SNR = 20 dB. This shows that when SNR is high, Eq.(6.17) gives a quite good
approximation to Eq.(6.18), thus leading to remarkably accurate factor matrices
recovery. Although the BCR of Algorithm 8 is higher for the data Y+ than that for
the data Y, it is with nearly the same performance as that of the NALS algorithm
(with exact tensor rank).
On the other hand, the tensor rank estimates of Algorithm 8 under different SNRs
are presented in Fig.6.7, with each vertical bar showing the mean and the error bars
showing the standard derivation of tensor rank estimates. The blue horizontal dashed
line indicates the true tensor rank. From Fig.6.7, it is seen that Algorithm 8 recovers
the true tensor rank with 100% accuracy for a wide range of SNRs, in particular when
SNR is 10 dB or higher. When SNR is 0 and 5dB, even though the performance is
not 100% accurate, the estimated tensor rank is still close to the true tensor rank
with a high probability for test data Y. However, under these two low SNRs, the
rank estimation performances of the proposed algorithm for the data Y+ degrade
signiﬁcantly. This is because Eq.(6.18) cannot be well approximated by Eq.(6.17)

6.5 Numerical Results
125
10
20
10
20
SNR (dB)
0
0.5
1
1.5
2
2.5
3
3.5
4
Best Congruence Ratio
ALS with correct tensor rank
NNALS with correct tensor rank
PNCPD
Data Y
Data Y+
Fig. 6.6 Best congruence ratios of the proposed algorithm for different test data
-5
0
5
10
15
20
SNR (dB)
0
5
10
15
20
25
30
35
40
Tensor Rank Estimate
Data Y
Data Y+
Fig. 6.7 Tensor rank estimates of the proposed algorithm for different test data

126
6
Bayesian Tensor CPD with Nonnegative Factors
Table 6.1 Performance of tensor rank estimation versus different true tensor ranks for tensor data
Y when SNR = 20 dB
True tensor rank
Mean of tensor rank
estimates
Standard derivation of
tensor rank estimates
Percentage of correct
tensor rank estimates
(%)
10
10
0
100
30
29.6
1.27
90
50
28.15
18.29
25
under very low SNRs. Furthermore, Algorithm 8 fails to give correct rank estimates
when SNR is lower than −5 dB for both two test data sets, since the noise with very
large power masks the low-rank structure of the data.
To assess the tensor rank estimation accuracy when the tensor is with a larger true
rank, we apply Algorithm 8 to the tensor data Y with the true rank R = {10, 30, 50}
and SNR = 20 dB. The rank estimation performance is presented in Table6.1. From
Table6.1, it can be seen that Algorithm 8 recovers the rank accurately when the true
rank is 10 and 30. However, when R = 50, Algorithm 8 fails to accurately recover
the tensor rank.
The simulation results presented so far are for well-conditioned tensors, i.e., the
columns in each of the factor matrices are independently generated. In order to
fully assess the rank learning ability of Algorithm 8, we consider another noise-
free 3D tensor ¯X =  ¯M
(1), M(2), M(3) ∈R100×100×100 with rank R = 10. The factor
matrix is set as ¯M
(1) = 0.11100×10 + 2−s M(1), and each element in factor matrices
{M(n)}3
n=1 is independently drawn from a uniform distribution over [0, 1]. Accord-
ing to the deﬁnition of the tensor condition number [20, 21], when s increases, the
correlation among the columns in the factor matrix ¯M
(1) increases, and the tensor
condition number becomes larger. In particular, when s goes to inﬁnity, the condi-
tion number of the tensor goes to inﬁnity too. We apply the proposed algorithm to ¯X
corrupted with noise: ¯Y = ¯X + ¯W, where each element of noise tensor ¯W is inde-
pendently drawn from a zero-mean Gaussian distribution with variance ¯σ 2
w. Table6.2
shows the rank estimation accuracy of the proposed algorithm when SNR = 20 dB.
It can be seen that the proposed algorithm can correctly estimate the tensor rank
when s < 5. But as the tensor conditional number increases (i.e., the columns are
more correlated in the factor matrix ¯M
(1)), the tensor rank estimation performance
decreases signiﬁcantly.
Next, we consider an extreme case in which the columns in all factor matrices
are highly correlated: ˜X =  ¯M
(1), ¯M
(2), ¯M
(3) ∈R100×100×100 with rank R = 10,
where each factor matrix ¯M
(n) = 0.11100×10 + 2−s M(n), and each element in factor
matrices {M(n)}3
n=1 is independently drawn from a uniform distribution over [0, 1].
With the same observation data model as ¯Y as before and when SNR = 20 dB, the
percentages of the correct tensor rank estimate are shown in Table6.2. It can be seen

6.5 Numerical Results
127
Table 6.2 Performance of tensor rank estimation when the columns are correlated and SNR =
20 dB
s
0
1
3
5
100
Columns in one factor matrix are correlated (%)
100
100
100
25
5
Columns in all factor matrices are correlated (%)
100
40
0
0
0
that it is difﬁcult for Algorithm 8 to accurately estimate the tensor rank even when
s = 1.
Finally, acceleration schemes could be incorporated to speed up Algorithm 8. In
particular, in the ﬁrst few iterations, since some precision parameters are learned to be
very large while some of them are with very small values, the average condition num-
ber of the Hessian matrix of problem (6.25), i.e., 1
3
3
k=1 condition_number

H(k)
,
is very large. After several iterations, Algorithm 8 has gradually recovered the tensor
rank, and then the remaining precision parameters are with comparable values, lead-
ing to a well-conditioned Hessian matrix H(k) of problem (6.25). This phenomenon
can be observed in Fig.6.8. When the Hessian matrix is well-conditioned (e.g., when
the condition number is smaller than 100), the Nesterov scheme can be utilized for the
problem (6.25) to speed up the convergence [4]. Consequently, even with the similar
MSE and BCR performances, the accelerated algorithm (denoted as PNCPD-A) is
much faster than Algorithm 82 as presented in Table6.3. Moreover, from Table6.3,
the inexact BCD acceleration PNCPD-I (Algorithm 9) also achieves similar MSE
and BCR, but with computation time further reduced.
6.5.2
Fluorescence Data Analysis
In this subsection, the application of Fluorescence Data Analysis from Chap.4 is
revisited. Since factor matrices A, B, and C in this application represent excita-
tion values, emission values, and concentrations, respectively, strictly speaking, they
should be nonnegative. Algorithm 8 (PNCPD algorithm) is utilized to analyze the
amino acids ﬂuorescence data3 [22] as in Sect.4.2.1. The ﬂuorescence excitation-
emission measured (EEM) data collected is with size 5 × 201 × 61 and should be
representable with a CPD model with rank 3, since there are three different types of
amino acid and each individual amino acid gives a rank-one CPD component. The
samples were corrupted by Gaussian noise with SNR = 0 dB.
The PNCPD algorithm (Algorithm 8) is run to decompose the EEM tensor
data with initial rank L = 201, for which, the step size sequence is chosen as
αt = 10−2/(t + 1) [3], and the gradient projection update is terminated when the
2 The presented time for the accelerated scheme includes the time for computing the condition
numbers.
3 http://www.models.life.ku.dk.

128
6
Bayesian Tensor CPD with Nonnegative Factors
10
20
30
40
50
60
70
80
Iteration number 
10-1
100
101
102
103
104
105
the evolution of
tensor rank estimates
the evolution of 
average condition number
Fig. 6.8 The average condition number of the Hessian matrix of problem (6.25) and the tensor
rank estimate versus number of iterations for test data Y when SNR = 20 dB
Table 6.3 Comparisions between different algorithm accelerations. The accelerated version using
the Nesterov scheme is labeled as PNCPD-A. The inexact BCD version is labeled as PNCPD-I
SNR = 10 dB
Y
Y+
PNCPD
PNCPD-A
PNCPD-I
PNCPD
PNCPD-A
PNCPD-I
MSE
545.5608
545.7800
545.8255
576.7381
576.7603
576.7990
BCR
0.4798
0.4886
0.4892
0.7616
0.7673
0.7680
Running
time
134.9246
74.8712
74.0267
119.2018
94.1182
84.7767
SNR = 20 dB
Y
Y+
PNCPD
PNCPD-A
PNCPD-I
PNCPD
PNCPD-A
PNCPD-I
MSE
54.8459
54.8485
54.8448
55.7471
55.7484
56.3062
BCR
0.2398
0.2413
0.2412
0.2438
0.2450
0.2453
Running
time
80.0258
61.9218
44.3579
90.7224
82.7590
47.7782

6.5 Numerical Results
129
-0.05
0
0.05
0.1
0.15
0.2
0.25
0.3
PNCPD
PCPD-GH
Clean
(a)
0
10
20
30
40
50
60
0
50
100
150
200
-0.05
0
0.05
0.1
0.15
0.2
0.25
PNCPD
PCPD-GH
Clean
(b)
Fig. 6.9 The estimates of a excitation spectra and b emission spectra recovered by PNCPD and
PCPD-GH algorithms, with the clean data spectra serving as the benchmark
gradient norm is smaller than 10−3. At convergence, the PNCPD algorithm iden-
tiﬁed the correct tensor rank R = 3 and the corresponding Fit value is 91.5582,
which is higher than that of PCPD-GH (Algorithm 4) without nonnegative con-
straint (90.8433 in Table4.3). Furthermore, the emission spectra and the excited
spectra of three amino acids recovered by PNCPD and PCPD-GH algorithms are
plotted in Fig.6.9, which are obtained from the decomposed factor matrices [22],
with the clean data spectra4 serving as the benchmark. From Fig.6.9, it can be seen
that some excitation/emission values recovered by PCPD-GH are negative under the
noise corruption, while that of PNCPD are strictly nonnegative, which explains why
PNCPD yields a higher Fit value and more interpretable results.
6.5.3
ENRON E-mail Data Mining
In this subsection, Algorithm 8 is demonstrated in the social group clustering (see
Sect.6.1.1). In particular, the ENRON Email corpus5 [1] was analyzed. This dataset
Y is with size 184 × 184 × 44 (i.e., I = 184, J = 184, K = 44 in the notation of
Sect.6.1.1) and contains e-mail communication records between 184 people within
44 months, in which each entry denotes the number of e-mails exchanged between
two particular people within a particular month. Before ﬁtting the data to the proposed
algorithms, the same pre-processing as in [1, 2] is applied to the non-zero data to
compress the dynamic range. Then, Algorithm 8 is utilized to ﬁt the data, with the
initial rank set as L = 44, the step size sequence being αt = 1/(t + 1) [3], and the
4 The clean data spectra are obtained by decomposing the clean data using the NALS algorithm
with correct tensor rank R = 3.
5 The original source of the data is from [1], and we greatly appreciate Prof. Vagelis Papalexakis
for sharing the data with us.

130
6
Bayesian Tensor CPD with Nonnegative Factors
Table 6.4 Social groups with people in the top 10 scores in each group for the ENRON e-mail data
using the PNCPD algorithm
Legal
Pipeline
Tana Jones (tana.jones) Employee Financial
Trading Group ENA Legal
Sara Shackleton (sara.shackleton) Employee
ENA Legal
Mark Taylor (mark.taylor) Manager Financial
Trading Group ENA Legal
Stephanie Panus (stephanie.panus) Senior
Legal Specialist ENA Legal
Marie Heard (marie.heard) Senior Legal
Specialist ENA Legal
Mark Haedicke (mark.haedicke) Managing
Director ENA Legal
Susan Bailey (susan.bailey) Legal Assistant
ENA Legal
Louise Kitchen (louise.kitchen) President
Enron Online
Kay Mann (kay.mann) Lawyer
Debra Perlingiere (debra.perlingiere) Legal
Specialist ENA Legal
Michelle Lokay (michelle.lokay) Admin. Asst.
Transwestern Pipeline Company (ETS)
Kimberly Watson (kimberly.watson) Employee
Transwestern Pipeline Company (ETS)
Lynn Blair (lynn.blair) Employee Northern
Natural Gas Pipeline (ETS)
Shelley Corman (shelley.corman) VP
Regulatory Affairs
Drew Fossum (drew.fossum) VP Transwestern
Pipeline Company (ETS)
Lindy Donoho (lindy.donoho) Employee
Transwestern Pipeline Company (ETS)
Kevin Hyatt (kevin.hyatt) Director Asset
Development TW Pipeline Business (ETS)
Darrell Schoolcraft (darrell.schoolcraft)
Employee Gas Control (ETS)
Rod Hayslett (rod.hayslett) VP Also CFO and
Treasurer
Susan Scott (susan.scott) Employee
Transwestern Pipeline Company (ETS)
Trading/executive
Government affairs
Michael Grigsby (mike.grigsby) Director West
Desk Gas Trading
Kevin Presto (m..presto) VP East Power
Trading
Mike McConnell (mike.mcconnell) Executive
VP Global Markets
John Arnold (john.arnold) VP Financial Enron
Online
Louise Kitchen (louise.kitchen) President
Enron Online
David Delainey (david.delainey) CEO ENA
and Enron Energy Services
John Lavorato (john.lavorato) CEO Enron
America
Sally Beck (sally.beck) COO
Joannie Williamson (joannie.williamson)
Executive Assistant
Liz Taylor (liz.taylor) Executive Assistant to
Greg Whalley
Jeff Dasovich (jeff.dasovich) Employee
Government Relationship Executive
James Steffes (james.steffes) VP Government
Affairs
Steven Kean (steven.kean) VP Chief of Staff
Richard Shapiro (richard.shapiro) VP
Regulatory Affairs
David Delainey (david.delainey) CEO ENA
and Enron Energy Services
Richard Sanders (richard.sanders) VP Enron
Wholesale Services
Shelley Corman (shelley.corman) VP
Regulatory Affairs
Margaret Carson (margaret.carson) Employee
Corporate and Environmental Policy
Mark Haedicke (mark.haedicke) Managing
Director ENA Legal
Vince Kaminski (vince.kaminski) Manager
Risk Management Head

6.5 Numerical Results
131
Table 6.5 Social groups with people in the top 10 scores in each group for the ENRON e-mail data
using the PCPD-GH algorithm
Legal
Pipeline
Tana Jones (tana.jones) Employee Financial Trading
Group ENA Legal
Sara Shackleton (sara.shackleton) Employee ENA Legal
Mark Taylor (mark.taylor) Manager Financial Trading
Group ENA Legal
Stephanie Panus (stephanie.panus) Senior Legal
Specialist ENA Legal
Marie Heard (marie.heard) Senior Legal Specialist ENA
Legal
Mark Haedicke (mark.haedicke) Managing Director ENA
Legal
Susan Bailey (susan.bailey) Legal Assistant ENA Legal
Louise Kitchen (louise.kitchen) President Enron Online
Kay Mann (kay.mann) Lawyer
Debra Perlingiere (debra.perlingiere) Legal Specialist
ENA Legal
Drew Fossum (drew.fossum) VP Transwestern Pipeline
Company (ETS)
Susan Scott (susan.scott) Employee Transwestern
Pipeline Company (ETS)
Shelley Corman (shelley.corman) VP Regulatory Affairs
Michelle Lokay (michelle.lokay) Admin. Asst.
Transwestern Pipeline Company (ETS)
Lindy Donoho (lindy.donoho) Employee Transwestern
Pipeline Company (ETS)
Jeff Dasovich (jeff.dasovich) Employee Government
Relationship Executive
Kevin Hyatt (kevin.hyatt) Director Asset Development
TW Pipeline Business (ETS)
Kimberly Watson (kimberly.watson) Employee
Transwestern Pipeline Company (ETS)
Lynn Blair (lynn.blair) Employee Northern Natural Gas
Pipeline (ETS)
Rod Hayslett (rod.hayslett) VP Also CFO and Treasurer
Executives
Goverment affairs
John Lavorato (john.lavorato) CEO Enron America
Louise Kitchen (louise.kitchen) President Enron Online
Sally Beck (sally.beck) COO
Liz Taylor (liz.taylor) Executive Assistant to Greg
Whalley
David Delainey (david.delainey) CEO ENA and Enron
Energy Services
Vince Kaminski (vince.kaminski) Manager Risk
Management Head
John Arnold (john.arnold) VP Financial Enron Online
Joannie Williamson (joannie.williamson) Executive
Assistant
Mike McConnell (mike.mcconnell) Executive VP*
Global Markets
Jeffrey Shankman (jeffrey.shankman) President Enron
Global Markets
Jeff Dasovich (jeff.dasovich) Employee Government
Relationship Executive
James Steffes (james.steffes) VP Government Affairs
Steven Kean (steven.kean) VP Chief of Staff
Richard Shapiro (richard.shapiro) VP Regulatory Affairs
Richard Sanders (richard.sanders) VP Enron Wholesale
Services
David Delainey (david.delainey) CEO ENA and Enron
Energy Services
Shelley Corman (shelley.corman) VP Regulatory Affairs
Margaret Carson (margaret.carson) Employee Corporate
and Environmental Policy
Mark Haedicke (mark.haedicke) Managing Director ENA
Legal
Philip Allen (phillip.allen) VP West Desk Gas Trading
Trading
Michael Grigsby (mike.grigsby) Director West Desk Gas
Trading
Matthew Lenhart (matthew.lenhart) Analyst West Desk
Gas Trading
Monique Sanchez (monique.sanchez) Associate West
Desk Gas Trader (EWS)
Jane Tholt (m..tholt) VP West Desk Gas Trading
Philip Allen (phillip.allen) VP West Desk Gas Trading
Kam Keiser (kam.keiser) Employee Gas
Mark Whitt (mark.whitt) Director Marketing
Eric Bass (eric.bass) Trader Texas Desk Gas Trading
Jeff Dasovich (jeff.dasovich) Employee Government
Relationship Executive
Chris Dorland (chris.dorland) Manager

132
6
Bayesian Tensor CPD with Nonnegative Factors
5
10
15
20
25
30
35
40
45
50
Months
0
0.05
0.1
0.15
Temporal cluster profiles
Trading / Top Executive
Pipline
Change of CEO
Crisis Breaks / Investigations
Bankruptcy
Fig. 6.10 Temporal cluster proﬁles (from the third factor matrix) for the ENRON e-mail dataset
gradient projection update terminated when the gradient norm is smaller than 10−3.
The estimated tensor rank has the physical meaning of the number of underlying
social groups, and each element in the ﬁrst factor matrix A can be interpreted as the
score that a particular person belongs to a particular email sending group.
After executing PNCPD (Algorithm 8), the tensor rank estimate is found to be
4, indicating that there are four underlying social groups. This is consistent with
the results from [1, 2], which are obtained via trail-and-error experiments. From the
factor matrix A, the people with top 10 scores in each social group are shown in
Table6.4. From the information of each person in Table6.4, the clustering results
can be clearly interpreted. For instance, the people in the ﬁrst group are either in
the legal department or lawyers, thus being clustered together. The clustering results
of PNCPD are also consistent with the results from [1, 2], which are obtained via
nonlinear programming methods assuming the knowledge of tensor rank. In contrast,
the PCPD-GH algorithm (Algorithm 4) without nonnegative constraint identiﬁes
ﬁve social groups, where the detailed groupings are presented in Table6.5. While the
number of groups can also be considered reasonable [2], after a closer inspection,
two people, namely Philip Allen and Jeff Dasovich (marked bold in Table6.5) were
put in the wrong groups. This demonstrates that the prior nonnegative structure is
beneﬁcial for social group clustering.
Finally, interesting patterns can be observed from the temporal cluster proﬁles,
which are obtained from the third factor matrix C [1, 2], as illustrated in Fig.6.10.
It is clear that when the company has important events, such as the change of CEO,
crisis breaks, and bankruptcy, distinct peaks appear.

References
133
References
1. B.W. Bader, R.A. Harshman, T.G. Kolda, Temporal analysis of social networks using three-
way dedicom. Sandia National Laboratories (SNL), Albuquerque, NM, and Livermore, CA ...,
Technical Report (2006)
2. E.E. Papalexakis, N.D. Sidiropoulos, R. Bro, From k-means to higher-way co-clustering: mul-
tilinear decomposition with sparse latent factors. IEEE Trans. Signal Process. 61(2), 493–506
(2012)
3. D.P. Bertsekas, Nonlinear programming. J. Oper. Res. Soc. 48(3), 334–334 (1997)
4. A.P. Liavas, G. Kostoulas, G. Lourakis, K. Huang, N.D. Sidiropoulos, Nesterov-based alternat-
ing optimization for nonnegative tensor factorization: algorithm and parallel implementation.
IEEE Trans. Signal Process. 66(4), 944–953 (2017)
5. K. Huang, N.D. Sidiropoulos, A.P. Liavas, A ﬂexible and efﬁcient algorithmic framework for
constrained matrix and tensor factorization. IEEE Trans. Signal Process. 64(19), 5052–5065
(2016)
6. Q. Zhao, L. Zhang, A. Cichocki, Bayesian cp factorization of incomplete tensors with automatic
rank determination. IEEE Trans. Pattern Anal. Mach. Intell. 37(9), 1751–1763 (2015)
7. L. Cheng, Y.-C. Wu, H.V. Poor, Probabilistic tensor canonical polyadic decomposition with
orthogonal factors. IEEE Trans. Signal Process. 65(3), 663–676 (2016)
8. L. Cheng, Y.-C. Wu, H.V. Poor, Scaling probabilistic tensor canonical polyadic decomposition
to massive data. IEEE Trans. Signal Process. 66(21), 5534–5548 (2018)
9. L. Cheng, X. Tong, S. Wang, Y.-C. Wu, H.V. Poor, Learning nonnegative factors from tensor
data: probabilistic modeling and inference algorithm. IEEE Trans. Signal Process. 68, 1792–
1806 (2020)
10. J.C. Arismendi, Multivariate truncated moments. J. Multivar. Anal. 117, 41–75 (2013)
11. M.D. Hoffman, D.M. Blei, C. Wang, J. Paisley, Stochastic variational inference. J. Mach. Learn.
Res. (2013)
12. Y. Xu, W. Yin, A block coordinate descent method for regularized multiconvex optimization
with applications to nonnegative tensor factorization and completion. SIAM J. Imag. Sci. 6(3),
1758–1789 (2013)
13. L. Grippo, M. Sciandrone, On the convergence of the block nonlinear gauss-seidel method
under convex constraints. Oper. Res. Lett. 26(3), 127–136 (2000)
14. H.-J.M. Shi, S. Tu, Y. Xu, W. Yin, A primer on coordinate descent algorithms (2016).
arXiv:1610.00040
15. M. Razaviyayn, M. Hong, Z.-Q. Luo, A uniﬁed convergence analysis of block successive
minimization methods for nonsmooth optimization. SIAM J. Optim. 23(2), 1126–1153 (2013)
16. P. Tseng, S. Yun, A coordinate gradient descent method for nonsmooth separable minimization.
Math. Programm. 117(1), 387–423 (2009)
17. A. Cichocki, R. Zdunek, A.H. Phan, S.-I. Amari, Nonnegative Matrix and Tensor Factor-
izations: Applications to Exploratory Multi-way Data Analysis and Blind Source Separation
(Wiley, New York, 2009)
18. T.G. Kolda, B.W. Bader, Tensor decompositions and applications. SIAM Rev. 51(3), 455–500
(2009)
19. N.D. Sidiropoulos, G.B. Giannakis, R. Bro, Blind parafac receivers for ds-cdma systems. IEEE
Trans. Signal Process. 48(3), 810–823 (2000)
20. P. Breiding, N. Vannieuwenhoven, The condition number of join decompositions. SIAM J.
Matrix Anal. Appl. 39(1), 287–309 (2018)
21. N. Vannieuwenhoven, Condition numbers for the tensor rank decomposition. Linear Algebra
Appl. 535, 35–86 (2017)
22. H.A. Kiers, A three-step algorithm for candecomp/parafac analysis of large data sets with
multicollinearity. J. Chemom.: J. Chemom. Soc. 12(3), 155–171 (1998)

Chapter 7
Complex-Valued CPD, Orthogonality
Constraint, and Beyond Gaussian Noises
Abstract In previous chapters, Bayesian CPDs are developed for real-valued tensor
data. They cannot deal with complex-valued tensor data, which, however, frequently
occurs in applications including wireless communications and sensor array signal
processing. In addition, we have not touched on the design of Bayesian CPD that
incorporates the orthogonality structure and/or handles non-Gaussian noises. In this
chapter, we present a uniﬁed Bayesian modeling and inference for complex-valued
tensor CPD with/without orthogonal factors, under/not under Gaussian noises. Appli-
cations on blind receiver design and linear image coding are presented.
7.1
Problem Formulation
We consider a generalized problem in which the complex-valued tensor Y ∈
CI1×I2×···×IN obeys the following model:
Y = [[A(1), A(2), . . . , A(N)]] + W + E,
(7.1)
where W represents an additive noise tensor with each element being i.i.d. and
wi1,i2,...,iN ∼CN

wi1,i2,...,iN |0, β−1
; E denotes potential outliers in measurements
with each element ei1,i2,...,iN taking an unknown complex value if an outlier emerges,
and otherwise taking the value zero. Furthermore, it is assumed that {A(n)}P
n=1 are
known to be orthogonal where P < N, while the remaining factor matrices are
unconstrained.
Due to the orthogonality structure of the ﬁrst P factor matrices {A(n)}P
n=1, they
can be written as A(n) = U(n)(n) where U(n) is an orthonormal matrix and (n) is
a diagonal matrix describing the scale of each column. Putting A(n) = U(n)(n) for
1 ≤n ≤P into the deﬁnition of the tensor CPD, it is easy to show that
[[A(1), A(2), . . . , A(N)]] = [[(1), (2), . . . , (N)]]
(7.2)
with (n) = U(n) for 1 ≤n ≤P, (n) = A(n) for P + 1 ≤n ≤N −1, and
(N) = A(N)(1)(2) · · · (P), where  ∈RR×R is a permutation matrix. From
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023
L. Cheng et al., Bayesian Tensor Decomposition for Signal Processing and
Machine Learning, https://doi.org/10.1007/978-3-031-22438-6_7
135

136
7
Complex-Valued CPD, Orthogonality Constraint, and Beyond Gaussian Noises
(7.2), it can be seen that up to a scaling and permutation indeterminacy, the tensor
CPD under orthogonal constraints is equivalent to that under orthonormal constraints.
In general, the scaling and permutation ambiguity can be easily resolved using side
information [1, 2]. Thus, without loss of generality, our goal is to estimate an N-tuplet
of factor matrices ((1), (2), . . ., (N)) with the ﬁrst P (where P < N) of them
being orthonormal, based on the observation Y and in the absence of the knowledge
of noise power β−1, outlier statistics, and the tensor rank R.
In particular, since we do not know the exact value of R, it is assumed that there
are L columns in each factor matrix (n), where L is the maximum possible value
of the tensor rank R. Then, the problem to be solved can be stated as
min
{(n)}N
n=1,E β ∥Y −[[(1), (2), . . . , (N)]] −E ∥2
F +
L

l=1
γl

N

n=1
(n)H
:,l
(n)
:,l

s.t.
(n)H(n) = IL, n = 1, 2, . . . , P,
(7.3)
where the regularization term L
l=1 γl
N
n=1 (n)H
:,l
(n)
:,l

is added to control the
complexity of the model and avoid overﬁtting of noise, since more columns (thus
more degrees of freedom) in (n) than the true model are introduced, and {γl}L
l=1 are
regularization parameters trading off the relative importance of the square error term
and the regularization term.
Problem (7.3) is more general than the model in existing works [3] since an extra
outlier term is present. Furthermore, the choice of regularization parameters plays
an important role, since setting γl too large results in excessive residual squared
error, while setting γl too small risks overﬁtting of noise. In general, determining
the optimal regularization parameters (e.g., using cross-validation, or the L-curve)
requires exhaustive search and thus is computationally demanding. To overcome
these problems, a novel algorithm based on the framework of probabilistic inference
is presented, which effectively mitigates the outliers E and automatically learns the
regularization parameters and the tensor rank.
7.2
Probabilistic Modeling
Before solving problem (7.3), we ﬁrst interpret different terms in (7.3) as probability
density functions, based on which a probabilistic model that encodes our knowledge
of the observation and the unknowns can be established.
Firstly, since the elements of the additive noise W is white, zero-mean, and
circularly symmetric complex Gaussian, the squared error term in problem (7.3) can
be interpreted as the negative log of the likelihood
p

Y | (1), (2), . . ., (N), E, β

∝exp

−β ∥Y −[[(1), (2), . . ., (N)]] −E ∥2
F

.
(7.4)

7.2 Probabilistic Modeling
137
Secondly, the regularization term in problem (7.3) can be interpreted as arising from
a circularly symmetric complex Gaussian prior distribution over the columns of the
factor matrices, i.e., N
n=1
L
l=1 CN

(n)
:,l | 0In×1, γ −1
l
IL

. Note that this is analogue
to (3.4) but is tailored to complex-valued factor matrices.
On the other hand, for the ﬁrst P factor matrices {(n)}P
n=1, there are additional
hard constraints in problem (7.3), which correspond to the Stiefel manifold [6]
VL(CIn) = {A ∈CIn×L : AHA = IL} for 1 ≤n ≤P. Since the orthonormal con-
straints result in (n)H
:,l
(n)
:,l = 1, the hard constraints would dominate the Gaussian
distribution of the columns in {(n)}P
n=1. Therefore, (n) can be interpreted as being
uniformly distributed over the Stiefel manifold VL(CIn) for 1 ≤n ≤P, and Gaussian
distributed for P + 1 ≤n ≤N:
p((1), (2), . . . , (P)) ∝
P
	
n=1
IVL(CIn )((n)),
p((P+1), (P+2), . . . , (N)) =
N
	
n=P+1
L
	
l=1
CN

(n)
:,l |0In×1, γ −1
l
IL

,
(7.5)
where IVL(CIn )((n)) is an indicator function with IVL(CIn )((n)) = 1 when (n) ∈
VL(CIn), and otherwise IVL(CIn )((n)) = 0. For the parameters β and {γl}L
l=1, which
correspondtotheinversenoisepowerandthevariancesofcolumnsinthefactormatri-
ces, since we have no information about their distributions, a non-informative Jef-
frey’s prior is imposed on them, i.e., p(β) ∝β−1 and p(γl) ∝γ −1
l
for l = 1, . . . , L.
This is equivalent to imposing gamma distribution on β and {γl}L
l=1 but with their
hyper-parameters approaching zero.
Finally, although the generative model for outliers Ei1,...,iN is unknown, the rare
occurrence of outliers motivates us to employ a complex-valued student’s t distri-
bution as its prior, i.e., p(Ei1,...,iN ) = T (Ei1,...,iN |0, ci1,...,iN , di1,...,iN ). Similar to the
real-valued student’s t distribution (see Table2.1), complex-valued student’s t dis-
tribution can also be equivalently represented as a Gaussian scale mixture [7]:
T

Ei1,...,iN | 0, ci1,...,iN , di1,...,iN

=

CN

Ei1,...,iN | 0, ζ −1
i1,...,iN

gamma

ζi1,...,iN | ci1,...,iN , di1,...,iN

dζi1,...,iN . (7.6)
This means that student’s t distribution can be obtained by mixing an inﬁnite number
of zero-mean circularly symmetric complex Gaussian distributions where the mixing
distribution on the precision ζi1,...,iN is the gamma distribution with parameters ci1,...,iN
and di1,...,iN . In addition, since the statistics of outliers such as means and correlations
are generally unavailable in practice, we set the hyper-parameters ci1,...,iN and di1,...,iN

138
7
Complex-Valued CPD, Orthogonality Constraint, and Beyond Gaussian Noises
···
···
Y
X
W
E
β
Ξ(1)
Ξ(P )
Ξ(P +1)
Ξ(N)
Stiefel manifold
γl
ζi1,··· ,iN
L
I1, · · · , IN
Fig. 7.1 Probabilistic model for complex-valued tensor CPD with orthogonal factors and outliers
(©[2017]IEEE.Reprinted,withpermission,from[L.Cheng,Y.-C.Wu,andH.V.Poor,Probabilistic
Tensor Canonical Polyadic Decomposition With Orthogonal Factors, IEEE Transactions on Signal
Processing, Feb 2017]. It applies all ﬁgures and tables in this chapter)
as 10−6 to produce a non-informative prior on Ei1,...,iN , and assume outliers are
independent of each other:
p (E) =
I1
	
i1=1
· · ·
IN
	
iN =1
T

Ei1,...,iN | 0, ci1,...,iN = 10−6, di1,...,iN = 10−6
.
(7.7)
The complete probabilistic model is shown in Fig.7.1.
7.3
Inference Algorithm Development
Let  be a set containing the factor matrices {(n)}N
n=1, and other variables E, {γl}L
l=1,
{ζi1,...,iN }I1,...,IN
i1=1,...,iN =1, β. From the probabilistic model established above, the marginal
probability density functions of the unknown factor matrices {}N
n=1 are given by
p((n)|Y) =

p(Y, )
p(Y)
d\(n), n = 1, 2, . . . , N,
(7.8)

7.3 Inference Algorithm Development
139
where
p(Y, ) ∝
P
	
n=1
IVL(CIn )

(n)
exp
  N
	
n=1
In −1

ln β
+

N

n=P+1
In + 1

L

l=1
ln γl −Tr


N

n=P+1
(n)H(n)

+
I1

i1=1
· · ·
IN

iN =1

(ci1,...,iN −1) ln ζi1,...,iN −di1,...,iN ζi1,...,iN

+
I1

i1=1
· · ·
IN

iN =1

ln ζi1,...,iN −ζi1,...,iN E∗
i1,...,iN Ei1,...,iN

−β ∥Y −[[(1), (2), . . ., (N)]] −E ∥2
F

(7.9)
with  = diag{γ1, . . . , γR}.
Since the factor matrices and other variables are nonlinearly coupled in (7.9),
the multiple integrations in (7.8) are analytically intractable, which prohibits exact
Bayesian inference. To handle this problem, we use variational inference as in pre-
vious chapters.
However, in addition to the mean-ﬁeld approximation Q() = 
k Q(k) where
k ∈, to facilitate the manipulation of hard constraints on the ﬁrst P factor matri-
ces, their variational densities are further assumed to take a Dirac delta functional
form Q((k)) = δ((k) −ˆ
(k)) for k = 1, 2, . . . , P, where ˆ
(k) is a parameter to
be derived.
Under these approximations, the probability density functions Q(k) of the vari-
ational distribution can be obtained via [5]
Q((k)) = δ

(k) −arg max
(k) E
 j ̸=(k) Q( j)

ln p (Y, )




≜ˆ
(k)

, k = 1, 2, . . . , P,
(7.10)
and
Q(k) ∝exp

E
j̸=k Q( j)

ln p (Y, )

, k ∈ \ {(k)}P
k=1.
(7.11)
Obviously, these variational distributions are coupled in the sense that the com-
putation of the variational distribution of one parameter requires the knowledge of
variational distributions of other parameters. Therefore, these variational distribu-
tions should be updated iteratively. In the following, an explicit expression for each
Q (·) is derived.

140
7
Complex-Valued CPD, Orthogonality Constraint, and Beyond Gaussian Noises
7.3.1
Derivation for Q((k)), 1 ≤k ≤P
By substituting (7.9) into (7.11) and only keeping the terms relevant to (k) (1 ≤
k ≤P), we directly have
ˆ
(k) = arg max
(k)∈VL(CIk )
E
 j ̸=(k) Q( j)

−β ∥Y −
(1), . . . , (N)]] −E

2
F

. (7.12)
To expand the square of the Frobenius norm inside the expectation in (7.12), we use
the result that ∥A∥2
F=∥A(k)∥2
F= Tr

A(k)
A(k)H
, where A(k) is the unfolding of
an Nth-order tensor A ∈CI1×···×IN along its kth mode (see Deﬁnition 1.1). After
expanding the square of the Frobenius norm and taking expectations, the parameter
ˆ
(k) for each variational density in {Q((k))}P
k=1 can be obtained from the following
problem:
ˆ
(k) =
arg max
(k)∈VL (CIk )
Tr

EQ(β)[β]

Y −EQ(E) [E]
(k)
N⋄
n=1,n̸=k EQ((n))

(n) ∗



≜F(k)
(k)H + (k)F(k)H

−Tr

(k)H (k)

EQ(β) [β] EN
n=1,n̸=k Q((n))

N⋄
n=1,n̸=k (n)T 
N⋄
n=1,n̸=k (n)∗
+ EL
l=1 Q(γl) []




≜G(k)

.
(7.13)
Using the fact that the feasible set for parameter (k) is the Stiefel manifold
VL(CIk), i.e., (k)H(k) = IL, the term G(k) is irrelevant to the factor matrix of
interest (k). Consequently, problem (7.13) is equivalent to
ˆ
(k) = arg max
(k)∈VL(CIk )
Tr

F(k)(k)H + (k)F(k)H

,
(7.14)
where F(k) was deﬁned in the ﬁrst line of (7.13). Problem (7.14) is a non-convex
optimization problem, as its feasible set VL(CIk) is non-convex [9]. While in general
(7.14) can be solved by numerical iterative algorithms based on a geometric approach
or the alternating direction method of multipliers [9], a closed-form optimal solution
can be obtained by noticing that the objective function in (7.14) has the same func-
tional form as the log of the von Mises–Fisher matrix distribution with parameter
matrix F(k), and the feasible set in (7.14) also coincides with the support of this von
Mises–Fisher matrix distribution [8]. As a result, we have
ˆ
(k) = arg max
(k)
ln VMF

(k) | F(k)
.
(7.15)

7.3 Inference Algorithm Development
141
Then, the closed-form solution for problem (7.15) can be acquired using the property
below, which has been proved in [6].
Property 6.1. Suppose the matrix A ∈Cκ1×κ2 follows a von Mises–Fisher
matrix distribution with parameter matrix F ∈Cκ1×κ2. If F = UVH is the
SVD of the matrix F, then the unique mode of VMF (A | F) is UVH.
From Property 6.1, it is easy to conclude that ˆ
(k) = ϒ(k)(k)H, where ϒ(k) and
(k) are the left-orthonormal matrix and right-orthonormal matrix from the SVD of
F(k), respectively.
7.3.2
Derivation for Q((k)), P + 1 ≤k ≤N
Using (7.9) and (7.11), the variational density Q

(k)
(P + 1 ≤k ≤N) can be
derived to be a circularly symmetric complex matrix normal distribution [8] as
Q

(k)
= CMN((k) | M(k), IIk, 	(k))
(7.16)
where
	(k) =

EQ(β) [β] EN
n=1,n̸=k Q((n))

N⋄
n=1,n̸=k (n)T 
N⋄
n=1,n̸=k (n)∗
+ EL
l=1 Q(γl) []
−1
(7.17)
M(k) = EQ(β) [β]

Y −EQ(E) [E]
(k)
N⋄
n=1,n̸=k EQ((n))

(n) ∗
	(k).
(7.18)
Due to the fact that Q((k)) is Gaussian, the parameter M(k) is both the expectation
and the mode of the variational density Q

(k)
.
To calculate M(k), some expectation computations are required as shown in (7.17)
and (7.18).ForthosewiththeformEQ(k) [k]wherek ∈,thevaluecanbeeasily
obtained if the corresponding Q (k) is available. The remaining challenge stems
from the expectation EN
n=1,n̸=k Q((n))

N⋄
n=1,n̸=k (n)T 
N⋄
n=1,n̸=k (n)∗
in (7.17). But
its calculation becomes straightforward after exploiting the orthonormal structure of
{ ˆ
(k)}P
k=1 and the property of multiple Khatri–Rao products, as presented in the
following property.

142
7
Complex-Valued CPD, Orthogonality Constraint, and Beyond Gaussian Noises
Property 6.2. Suppose the matrix A(n) ∈Cκn×ρ ∼δ(A(n) −ˆA(n)) for 1 ≤
n ≤P, where ˆA(n) ∈Vρ(Cκn) and P < N, and the matrix A(n) ∈Cκn×ρ ∼
CMN(A(n) | M(n), Iκn, 	(n)) for P + 1 ≤n ≤N. Then,
EN
n=1,n̸=k p(A(n))

N⋄
n=1,n̸=k A(n)T 
N⋄
n=1,n̸=k A(n)∗
= D

N⊙
n=P+1,n̸=k

M(n)HM(n) + κn	(n)∗
(7.19)
where D[A] is a diagonal matrix taking the diagonal element from A,
and the multiple Hadamard products
N⊙
n=1,n̸=k A(n) = A(N) ⊙· · · ⊙A(k+1) ⊙
A(k−1) ⊙· · · ⊙A(1).
7.3.3
Derivation for Q (E)
The variational density Q (E) can be obtained by taking only the terms relevant to E
after substituting (7.9) into (7.11) and is expressed as
Q (E)∝
I1
	
i1=1
· · ·
IN
	
iN =1
exp

E
 j ̸=E Q( j)

−ζi1,...,iN
Ei1,...,iN

2
−β
Yi1,...,in −
L

l=1
N
	
n=1
(n)
in,l −Ei1,...,iN

2
.
(7.20)
After taking expectations, the term inside the exponent of (7.20) is
−E∗
i1,...,iN

EQ(β)[β] + EQ(ζi1,...,iN )

ζi1,...,iN




≜pi1,...,iN

Ei1,...,iN
+ 2Re

E∗
i1,...,iN pi1,...,iN EQ(β)[β]p−1
i1,...,iN

Yi1,...,iN −
L

l=1
 N
	
n=1
EQ((n))[(n)
in,l]




≜mi1,...,iN

.
(7.21)
Since (7.21) is a quadratic function with respect to Ei1,...,iN , it is easy to show that

7.3 Inference Algorithm Development
143
Q (E) =
I1
	
i1=1
· · ·
IN
	
iN =1
CN

Ei1,...,iN | mi1,...,iN , p−1
i1,...,iN

.
(7.22)
Notice that from (7.21), the computation of outlier mean mi1,...,iN can be rewritten
as mi1,...,iN = n1n2, where n1 =

EQ(ζi1,...,iN )[ζi1,...,iN ]
−1

EQ(ζi1,...,iN )[ζi1,...,iN ]
−1
+

EQ(β)[β]
−1 and n2 = Yi1,...,iN −
L
l=1
 N
n=1 EQ((n))[(n)
in,l]

. From the general data model in (7.1), it can be seen
that n2 consists of the estimated outliers plus noise. On the other hand, since

EQ(ζi1,...,iN )[ζi1,...,iN ]
−1 and

EQ(β)[β]
−1 can be interpreted as the estimated power
of the outliers and the noise, respectively, n1 represents the strength of the outliers
in the estimated outliers plus noise. Therefore, if the estimated power of the out-
liers

EQ(ζi1,...,iN )[ζi1,...,iN ]
−1 goes to zero, the outlier mean mi1,...,iN becomes zero
accordingly.
7.3.4
Derivations for Q(γl), Q(ζi1,...,iN), and Q (β)
Using (7.9) and (7.11) again, the variational density Q (γl) can be expressed as
Q (γl) ∝exp
⎧
⎪⎪⎪⎪⎪⎨
⎪⎪⎪⎪⎪⎩
⎛
⎜⎜⎜⎜⎜⎝
N

n=P+1
In
  
≜˜al
−1
⎞
⎟⎟⎟⎟⎟⎠
ln γl −γl

N

n=P+1
EQ((n))

(n)H
:,l
(n)
:,l




≜˜bl
⎫
⎪⎪⎪⎪⎪⎬
⎪⎪⎪⎪⎪⎭
, (7.23)
which has the same functional form as the probability density function of gamma
distribution,i.e., Q(γl) = gamma(γl | ˜al, ˜bl).SinceEQ(γl)[γl] = ˜al/˜bl isrequiredfor
updating the variational distributions of other variables in , we need to compute
˜al and ˜bl. While the computation of ˜al is straightforward, the computation of ˜bl
can be facilitated by using the correlation property of the matrix normal distribution
EQ((n))[(n)H
:,l
(n)
:,l ] = M(n)H
:,l
M(n)
:,l + In	(n)
l,l [8] for P + 1 ≤n ≤N.
Similarly, using (7.9) and (7.11), the variational densities Q

ζi1,...,iN

and Q (β)
can be found to be gamma distributions as
Q

ζi1,...,iN

= gamma

ζi1,...,iN | ˜ci1,...,iN , ˜di1,...,iN

,
(7.24)
Q (β) = gamma

β | ˜e, ˜f

,
(7.25)
with parameters ˜ci1,...,iN = ci1,...,iN + 1, ˜di1,...,iN = di1,...,iN +

mi1,...,iN
∗mi1,...,iN +
p−1
i1,...,iN , ˜e = N
n=1 In, and ˜f =EN
n=1 Q((n))Q(E)

∥Y −[[(1), . . . , (N)]] −E ∥2
F

.

144
7
Complex-Valued CPD, Orthogonality Constraint, and Beyond Gaussian Noises
For ˜ci1,...,iN , ˜di1,...,iN and ˜e, the computations are straightforward. Furthermore, ˜f is
derived to be [14]
˜f = ∥Y −M ∥2
F +
I1

i1=1
· · ·
IN

iN =1
p−1
i1,...,iN + Tr

D

N⊙
n=P+1

M(n)HM(n) + In	(n)∗
−2Re

Tr

Y −M
(1)
N⋄
n=P+1 M(n)
⋄

P⋄
n=2
ˆ
(n)∗ˆ
(1)H
,
(7.26)
where M is a tensor with its (i1, . . . , iN)th element being mi1,...,iN , and Re(·) denotes
the real part of its argument.
7.3.5
Summary of the Iterative Algorithm
From the expressions for Q(k) evaluated above, it is seen that the calculation of
a particular Q (k) relies on the statistics of other variables in . As a result, the
variational distribution for each variable in  should be iteratively updated. The
iterative algorithm is summarized in Algorithm 10.
7.3.6
Further Discussions
To gain more insights from Algorithm 10, discussions on its convergence property,
automatic rank determination, relationship to the OALS algorithm, and computa-
tional complexity are presented in the following.
7.3.6.1
Convergence Property
Although the functional minimization of the KL divergence is non-convex over
the mean-ﬁeld family Q() = 
k Q(k), it is convex with respect to a single
variational density Q(k) when the others {Q( j)| j ̸= k} are ﬁxed. Therefore,
Algorithm 10, which iteratively updates the optimal solution for each k, is essen-
tially a coordinate descent algorithm in the functional space of variational distri-
butions with each update solving a convex problem. This guarantees a monotonic
decrease of the KL divergence, and Algorithm 10 is guaranteed to converge to at
least a stationary point.

7.3 Inference Algorithm Development
145
Algorithm 10 Probabilistic Tensor CPD with Orthogonal Factors
Initializations:
Choose L > R and initial values { ˆ
(n,0)}P
n=1, {M(n,0), 	(n,0)}N
n=P+1, ˜b0
l , {˜c0
i1,...,iN , ˜d0
i1,...,iN } and
˜f 0 for all l and i1, . . . , iN. Let ˜al = N
n=P+1 In and ˜e = N
n=1 In.
Iterations: For the tth iteration (t ≥1),
Update the statistics of outliers:
,
pi1,...,iN , mi1,...,iN
-I1,...,IN
i1=1,...,iN =1:
pt
i1,...,iN =
˜e
˜f t−1 +
˜ct−1
i1,...,iN
˜dt−1
i1,...,iN
,
(7.27)
mt
i1,...,iN =
˜e
˜f t−1 pt
i1,...,iN

Yi1,...,iN −
L

l=1

P
	
n=1
ˆ
(n,t−1)
in,l

N
	
n=P+1
M(n,t−1)
in,l

.
(7.28)
Update the statistics of factor matrices: {M(k), 	(k)}N
k=P+1:
	(k,t) =

˜e
˜f t−1 D

N⊙
n=P+1,n̸=k

M(n,t−1)H M(n,t−1) + In	(n,t−1)∗
+ diag
 ˜a1
˜bt−1
1
, ...,
˜aL
˜bt−1
L
−1
, (7.29)
M(k,t) =
˜e
˜f t−1
 
Y −Mt(k) 
N⋄
n=P+1,n̸=k M(n,t−1)
⋄

P⋄
n=1
ˆ
(n,t−1)∗
	(k,t).
(7.30)
Update the orthonormal factor matrices { ˆ
(k)}P
k=1:

ϒ(k,t), (k,t)
= SVD

˜e
˜f t−1

Y −Mt(k)
N⋄
n=P+1 M(n,t)
⋄

P⋄
n=1,n̸=k
ˆ
(n,t−1)∗
,
ˆ
(k,t) = ϒ(k,t)(k,t)H.
(7.31)
Update {˜bl}L
l=1, { ˜di1,...,iN }I1,...,IN
i1=1,...,iN =1 and ˜f
˜bt
l =
N

n=P+1
M(n,t)H
:,l
M(n,t)
:,l
+ In	(n,t)
l,l
,
(7.32)
˜ct
i1,...,iN = ˜c0
i1,...,iN + 1,
(7.33)
˜dt
i1,...,iN = ˜d0
i1,...,iN +

mt
i1,...,iN
∗
mt
i1,...,iN + 1/pt
i1,...,iN ,
(7.34)
˜f t = ∥Y −Mt ∥2
F +
I1

i1=1
· · ·
IN

in=1
(pt
i1,...,iN )−1 + Tr

D

N⊙
n=P+1

M(n,t)HM(n,t) + In	(n,t)∗
−2Re

Tr

Y −Mt(1)
N⋄
n=P+1 M(n,t)
⋄
 P⋄
n=2
ˆ
(n,t)∗ˆ
(1,t)H

.
(7.35)
Until Convergence
7.3.6.2
Automatic Rank Determination
The automatic rank determination for the tensor CPD uses an idea from the Bayesian
model selection (or Bayesian Occam’s razor). More speciﬁcally, the parameters

146
7
Complex-Valued CPD, Orthogonality Constraint, and Beyond Gaussian Noises
{γl}L
l=1 control the model complexity, and their optimal variational densities are
obtained together with those of other parameters by minimizing the KL divergence.
After convergence, if some E[γl] are very large, e.g., 106, this indicates that their
corresponding columns in {M(n)}N
n=P+1 can be “switched off”, as they play no role in
explaining the data. Furthermore, according to the deﬁnition of the tensor CPD, the
corresponding columns in { ˆ
(n)}P
n=1 should also be pruned accordingly. Finally, the
learned tensor rank R is the number of remaining columns in each estimated factor
matrix ˆ
(n).
7.3.6.3
Computational Complexity
For each iteration, the complexity is dominated by updating each factor matrix, cost-
ing O(N
n=1 InL2 + N N
n=1 InL). Thus, the overall complexity is about O(q(N
n=1
InL2 + N N
n=1 InL)) where q is the number of iterations needed for convergence.
On the other hand, for the OALS algorithm with exact tensor rank R, its complexity
is O(m(N
n=1 In R2 + N N
n=1 In R)) where m is the number of iterations needed
for convergence. Therefore, for each iteration, the complexity of Algorithm 10 is
comparable to that of the OALS algorithm.
7.3.6.4
Reduction to Special Cases
The model and inference algorithm are general in the sense that they include various
special cases. For example, if there is no orthogonal factor matrix, we can set P = 0;
if the tensor is in real-valued, we can simply replace hermitian with transpose; if we
believe there are no outliers, we can skip the steps related to E.
7.4
Simulation Results and Discussions
In this section, numerical simulations are presented to assess the performance of
the developed algorithm (labeled as VB) using synthetic data and two applications,
in comparison with various state-of-the-art tensor CPD algorithms. The algorithms
being compared include the ALS, the simultaneous diagonalization method for cou-
pled tensor CPD (labeled as SD) [11], the direct algorithm for CPD followed by
enhanced ALS (labeled as DIAG-A) [12], the Bayesian tensor CPD (Algorithm 5,
labeled as BCPD) [4], the robust iteratively reweighed ALS (labeled as IRALS) [13],
and the OALS algorithm (labeled as OALS) [3]. Note that some of these algorithms
were not originally derived for complex-valued data. In that case, they are extended
to handle complex-valued data for comparison.
In all experiments, three outlier models are considered, and they are listed
in Table7.1. For all the simulated algorithms, the initial factor matrix ˆ
(n,0) is

7.4 Simulation Results and Discussions
147
Table 7.1 Three different outlier models
Scenario
Variable description
Bernoulli–Gaussian
Ei1,...,iN ∼CN(0, σ 2
e ) with a probability π
Bernoulli-Uniform
Ei1,...,iN ∼U(−H, H) with a probability π
Bernoulli-Student’s t
Ei1,...,iN ∼T (μ, λ, ν) with a probability π
set as the matrix consisting of L leading left singular vectors of [Y](n) where
L = max{I1, I2, . . . , IN} for Algorithm 10 and the BCPD, and L = R for other
algorithms. The initial parameters of the algorithm in this chapter are set as
{˜c0
i1,...,iN , ˜d0
i1,...,iN } = 10−6 for all i1, . . . , iN, ˜b0
l = N
n=P+1 In for alll, ˜f 0 = N
n=1 In,
and {	(n,0)}N
n=P+1 are all set to be IL. All the algorithms terminate at the tth
iteration when ∥[[A(1,t), A(2,t), . . . , A(N,t)]] −[[A(1,t−1), A(2,t−1), . . . , A(N,t−1)]] ∥2
F
< 10−6 or the iteration number exceeds 2000.
7.4.1
Validation on Synthetic Data
Synthetic tensors are used in this subsection to assess the performance of
Algorithm 10 on convergence, rank learning ability, and factor matrix recovery under
different outlier models. A complex-valued third-order tensor [[A(1), A(2), A(3)]] ∈
C12×12×12 with rank R = 5 is considered, where the orthogonal factor matrix A(1)
is constructed from the R leading left singular vectors of a matrix drawn from
CMN(A|012×5,, I12×12, I5×5), and the factor matrices {A(n)}3
n=2 are drawn from
CMN(A| 012×5,, I12×12, I5×5). Parameters for outlier models are set as π = 0.05,
σ 2
e = 100, H = 10 arg maxi1,...,iN |[[A(1), A(2), A(3)]]i1,...,iN |, μ = 3, λ = 1/50, and
ν = 10. The signal-to-noise ratio (SNR) is deﬁned as 10 log10(∥[[A(1), A(2), A(3)]]
∥2
F / ∥W ∥2
F). Each result in this subsection is obtained by averaging 500 Monte
Carlo runs.
Figure7.2 presents the convergence performance of Algorithm 10 under dif-
ferent outlier models, where the mean square error (MSE) ∥[[ ˆ
(1), ˆ
(2), ˆ
(3)]] −
[[A(1), A(2), A(3)]] ∥2
F is chosen as the assessment criterion. From Fig.7.2, it can be
seen that the MSEs decrease signiﬁcantly in the ﬁrst few iterations and converge to
stable values quickly, demonstrating the rapid convergence property. Furthermore,
by comparing the simulation results with outliers to that without outlier, it is clear
that Algorithm 10 is effective in mitigating outliers.
For tensor rank learning, the simulation results of Algorithm 10 are shown in
Fig.7.3a, while those of the Bayesian tensor CPD algorithm are shown in Fig.7.3b.
Each vertical bar in the ﬁgures shows the mean and standard deviation of rank
estimates, with the red horizontal dotted lines indicating the true tensor rank. The
percentages of correct estimates are also shown on top of the ﬁgures. From Fig.7.3a, it
is seen that Algorithm 10 can recover the true tensor rank with 100% accuracy when

148
7
Complex-Valued CPD, Orthogonality Constraint, and Beyond Gaussian Noises
0
10
20
30
40
50
60
70
80
90
100
Iteration
10-2
10-1
100
101
102
103
MSE
Bernoulli-Uniform
Bernoulli-Student's t
Bernoulli-Gaussian
No Outlier
70
71
72
73
74
75
4.9
5
5.1
5.2
5.3
50
51
52
53
54
55
0.5
0.55
0.6
SNR = 10 dB
SNR = 20 dB
Fig. 7.2 Convergence of Algorithm 10 under different outlier models
SNR ≥5 dB, both with or without outliers. This shows the accuracy and robustness
of Algorithm 10 when the noise power is moderate. Even though the performance at
low SNRs is not as impressive as that at high SNRs, it can be observed that Algorithm
10 still gives estimates close to the true tensor rank with the true rank lying mostly
within one standard deviation from the mean estimate. On the other hand, in Fig.7.3b,
it is observed that while the Bayesian tensor CPD algorithm performs nearly the same
as Algorithm 10 without outliers, it gives tensor rank estimates very far away from
the true value when outliers are present.
Figure7.4 compares Algorithm 10 to other state-of-the-art CPD algorithms in
terms of recovery accuracy of the orthogonal factor matrix A(1) under different outlier
models. The criterion is set as the best congruence ratio deﬁned as minP ∥A(1) −
ˆ
(1)P ∥F / ∥A(1) ∥F, where the diagonal matrix  and the permutation matrix P
are found via the greedy least-squares column matching algorithm. From Fig.7.4a, it
is seen that both Algorithm 10 and OALS perform better than other algorithms when
outliers are absent. This shows the importance of incorporating the orthogonality
information of the factor matrix. On the other hand, while OALS offers the same
performanceasAlgorithm10whenthereisnooutlier,itsperformanceissigniﬁcantly
different in the presence of outliers, as presented in Fig.7.4b–d. Furthermore, except
Algorithm 10 and IRALS, all other algorithms do not take the outliers into account,
thus their performances degrade signiﬁcantly as shown in Fig.7.4b–d. Even though
the IRALS uses the robust lp (0 < p ≤1) norm optimization to alleviate the effects
of outliers, it cannot learn the statistical information of the outliers, leading to its
worse performance than that of Algorithm 10 in outliers mitigation.

7.4 Simulation Results and Discussions
149
-5
0
5
10
15
SNR (dB)
0
1
2
3
4
5
6
7
8
9
10
11
Estimated Rank
No Outlier
Bernoulli-Gaussian
Bernoulli-Uniform
Bernoulli-Student's t
  100%
  39.4%
  35.6%
  48.2%
  91.2%
  42%
  38.2%
  100%
  100%
  100%
  100%
  100%
  100%
  100%
  100%
  100%
  33.2%
  42.6%
  100%
  100%
(a)
-5
0
5
10
15
SNR (dB)
0
5
10
15
20
25
Estimated Rank
No Outlier
Bernoulli-Gaussian
Bernoulli-Uniform
Bernoulli-Student's t
  100%
  100%
  48.4%
  89%
  100%
  0%
  0%
  0.2%
  0%
  0%
   0%
   0%
  0.2%
  0%
  0%
  0%
   0%
  0%
  0%
  0%
(b)
Fig. 7.3 Rank determination using a Algorithm 10 and b the Bayesian tensor CPD

150
7
Complex-Valued CPD, Orthogonality Constraint, and Beyond Gaussian Noises
5
10
15
20
25
SNR (dB)
10-1
Best Congruence Ratio
ALS
SD
IRALS
BCPD
DIAG-A
OALS
VB
14.999
14.9995
15
15.0005
15.001
0.05516
0.05517
0.05518
0.05519
(a) No outlier
5
10
15
20
25
SNR (dB)
10-2
10-1
100
101
102
103
Best Congruence Ratio
ALS
SD
IRALS
BCPD
DIAG-A
OALS
VB
14.5
15
15.5
16
8
10
12
(b) Bernoulli-Gaussian
5
10
15
20
25
SNR (dB)
10-1
100
101
102
103
Best Congruence Ratio
ALS
SD
IRALS
BCPD
DIAG-A
OALS
VB
9.5
10
10.5
7
8
9
10
(c) Bernoulli-Uniform
5
10
15
20
25
SNR (dB)
10-2
10-1
100
101
102
103
Best Congruence Ratio
ALS
SD
IRALS
BCPD
DIAG-A
OALS
VB
14.9
15
15.1
15.2
10
12
14
16
(d) Bernoulli-Student’s t
Fig. 7.4 Performance of factor matrix recovery versus SNR under different outlier models
7.4.2
Blind Data Detection for DS-CDMA Systems
In a direct-sequence code division multiple access (DS-CDMA) system, the trans-
mitted signal sr(k) from the rth user at the kth symbol period is multiplied by a
spreading sequence [c1r, c2r, . . . , cZr] where czr is the zth chip of the applied spread-
ing code. Assuming R users transmit their signals simultaneously to a base station
(BS) equipped with M receive antennas, the received data is given by
ymz(k) =
R

r=1
hmrczrsr(k) + wmz(k), 1 ≤m ≤M, 1 ≤z ≤Z,
(7.36)
where hmr denotes the ﬂat fading channel between the rth user and the mth
receive antenna at the base station, and wmz(k) denotes white Gaussian noise. By
introducing H ∈CM×R with its (m,r)th element being hmr, and C ∈CZ×R with
its (z,r)th element being czr, the model (7.36) can be written in matrix form
as Y(k) = R
r=1 H:,r ◦C:,rsr(k) + W(k), where Y(k), W(k) ∈CM×Z are matrices
with their (m, z)th elements being ymz(k) and wmz(k), respectively. After collecting

7.4 Simulation Results and Discussions
151
T samples along the time dimension and deﬁning S ∈CT ×R with its (k,r)th element
being sr(k), the system model can be further written in the tensor form as [1]
Y =
R

r=1
H:,r ◦C:,r ◦S:,r + W = [[H, C, S]] + W
(7.37)
where Y ∈CM×Z×T and W ∈CM×Z×T are third-order tensors, which take ymz(k)
and wmz(k) as their (m, z, k)th elements, respectively.
It is shown in [1] that under certain mild conditions, the CPD of tensor Y, which
solves minH,C,S ∥Y −[[H, C, S]] ∥2
F, can blindly recover the transmitted signals S.
Furthermore, since the transmitted signals are usually uncorrelated and with zero
mean, the orthogonality structure1 of S can further be taken into account to give
better performance for blind signal recovery [2]. Similar models can also be found in
blind data detection for cooperative communication systems [15, 16], and in topology
learning for wireless sensor networks (WSNs) [17].
In this simulation, we set R = 5 users and the BS is equipped with M = 8 anten-
nas. The channel between the rth user and the mth antenna is a ﬂat fading chan-
nels hmr ∼CN(hmr|0, 1). The transmitted data sr(k) are random binary phase-shift
keying (BPSK) symbols. The spreading code is of length Z = 6, and with each
code element czr ∼CN(czr|0, 1). After observing the received tensor Y ∈C8×6×100,
Algorithm10andotherstate-of-the-arttensorCPDalgorithms,combinedwithambi-
guity removal and constellation mapping [1, 2], are executed to blindly detect the
transmitted data. Their performance is measured in terms of bit error rate (BER).
The BERs versus SNR under different outlier models are presented in Fig.7.5,
which are averaged over 10000 independent trials. The parameter settings for differ-
ent outlier models are the same as those in the last subsection. It is seen from Fig.7.5a
that when there is no outlier, Algorithm 10 and OALS behave the same, and both
outperform other CPDs. However, when outliers exist, it is seen from Fig.7.5b–d
that Algorithm 10 performs signiﬁcantly better than other algorithms.
7.4.3
Linear Image Coding for a Collection of Images
Given a collection of images representing a class of objects, linear image coding
extracts the commonalities of these images, which is important in image compression
and recognition [18, 19]. The kth image of size M × Z naturally corresponds to a
matrix B(k) with its (m, z)th element being the image’s intensity at that position.
Linear image coding seeks the orthogonal basis matrices U ∈CM×R and V ∈CZ×R
that capture the directions of the largest R variances in the image data, and this
problem can be written as [18, 19]
1 Strictly speaking, S is only approximately orthogonal. But the approximation gets better and better
when observation length T increases.

152
7
Complex-Valued CPD, Orthogonality Constraint, and Beyond Gaussian Noises
0
2
5
1
0
1
5
SNR (dB)
10-6
10-5
10-4
10-3
10-2
BER
ALS
SD
IRALS
BCPD
DIAG-A
OALS
VB
14.5
15
15.5
0.9
1
1.1
1.2
× 10-3
9.999
9.9995
10
10.0005 10.001
9.15
9.2
9.25 × 10-5
(a) No outlier
0
2
5
1
0
1
5
SNR (dB)
10-7
10-6
10-5
10-4
10-3
10-2
10-1
BER
ALS
SD
IRALS
BCPD
DIAG-A
OALS
VB
14.8
14.9
15
15.1
15.2
0.04
0.045
0.05
0.055
(b) Bernoulli-Gaussian
0
2
5
1
0
1
5
SNR (dB)
10-7
10-6
10-5
10-4
10-3
10-2
10-1
100
BER
ALS
SD
IRALS
BCPD
DIAG-A
OALS
VB
14.8
14.9
15
15.1
0.22
0.24
0.26
0.28
0.3
0.32
(c) Bernoulli-Uniform
0
2
5
1
0
1
5
SNR (dB)
10-7
10-6
10-5
10-4
10-3
10-2
10-1
BER
ALS
SD
IRALS
BCPD
DIAG-A
OALS
VB
14.5
15
15.5
0.1
0.105
0.11
0.115
(d) Bernoulli-Student’s t
Fig. 7.5 BER versus SNR under different outlier models
min
U,V,{dr(k)}R
r=1
K

k=1
∥B(k)−Udiag{d1(k), . . ., dR(k)}VT ∥2
F
s.t.
UHU = IR, VHV = IR.
(7.38)
Obviously, if there is only one image (i.e., K = 1), problem (7.38) is equivalent to
the well-studied SVD problem. Notice that the expression inside the Frobenius norm
in (7.38) can be written as B(k) −R
r=1 U:,r ◦V:,rdr(k). Further introducing the
matrix D with its (k,r)th element being dr(k), it is easy to see that problem (7.38)
can be rewritten in tensor form as
min
U,V,D ∥B −
R

r=1
U:,r ◦V:,r ◦D:,r



=[[U,V,D]]
∥2
F
s.t. UHU = IR, VHV = IR,
(7.39)
where B ∈CM×Z×K is a third-order tensor with B(k) as its kth slice. Therefore,
linear image coding for a collection of images is equivalent to solving a tensor CPD
with two orthonormal factor matrices.

7.4 Simulation Results and Discussions
153
Table 7.2 Classiﬁcation error and CPD computation time in face recognition
Algorithm
No outlier
Bernoulli–Gaussian
Bernoulli-Uniform
Bernoulli-Student’s t
Classiﬁcation
error (%)
CPD
time (s)
Classiﬁcation
error (%)
CPD
time (s)
Classiﬁcation
error (%)
CPD
time (s)
Classiﬁcation
error (%)
CPD
time (s)
ALS
9
1.9635
51
46.3041
47
63.6765
48
58.1047
SD
12
0.5736
49
0.6287
44
0.6181
49
0.6594
IRALS
9
4.3527
43
15.8361
27
16.6151
36
17.5181
BCPD
2
4.1546
53
20.7338
35
17.9896
48
17.1151
DIAG-A
11
3.7384
50
28.9961
41
30.6317
51
22.5127
OALS
11
1.0174
58
40.2731
34
38.1754
47
24.0162
VB
2
2.4827
10
2.7806
6
2.4912
7
2.8895
We conduct experiments on 165 face images from the Yale Face Database2 [10],
representing different facial expressions (also with or without sunglasses) of 15
people (11 images for each person). In each classiﬁcation experiment, we randomly
pick two people’s images. Among these 22 images, 12 (6 from each person) are
used for training. In particular, each image is of size 240 × 320, and the training
data can be naturally represented by a third-order tensor Y ∈R240×320×12. Various
algorithms are run to learn the two orthogonal basis matrices.3 Then, the feature
vectors of these 12 training images, which are obtained by projecting them onto
the multi-linear subspaces spanned by the two orthogonal basis matrices, are used
to train a support vector machine (SVM) classiﬁer. For the 10 testing images, their
feature vectors are fed into the SVM classiﬁer to determine which person is in each
image. The parameters of various outlier models are π = 0.05, σe = 100, H = 100,
μ = 1, λ = 1/1000, and ν = 20.
Since the tensor rank is not known in the image data, it should be carefully chosen.
Forthealgorithms(ALS,SD,IRALS,DIAG-A,andOALS)thatcannotautomatically
determine the rank, it can be obtained by ﬁrst running these algorithms with tensor
rank ranges from 1 to 12 and then ﬁnding the knee point of the reconstruction error
decrement [5]. When there is no outlier, it is able to ﬁnd the appropriate tensor
rank. However, when outliers exist, the knee point cannot be found and we set the
rank as the upper bound 12. For the BCPD, although it learns the appropriate rank
when there are no outliers, it learns the rank as 12 when outliers exist. On the other
hand, no matter whether there are outliers or not, Algorithm 10 automatically learns
the appropriate tensor rank without exhaustive search and thus saves considerable
computational complexity.
The average classiﬁcation errors of 10 independent experiments and the corre-
sponding average computation times (benchmarked in Matlab on a personal com-
puter with an i7 CPU) are shown in Table7.2, and it can be seen that Algorithm 10
provides the smallest classiﬁcation error under all considered scenarios.
2 http://vision.ucsd.edu/content/yale-face-database.
3 Although the image data are real-valued and Algorithm 10 is derived for complex-valued data,
we directly use Algorithm 10 on image data without modiﬁcation.

154
7
Complex-Valued CPD, Orthogonality Constraint, and Beyond Gaussian Noises
References
1. N.D. Sidiropoulos, G.B. Giannakis, R. Bro, Blind PARAFAC receivers for DS-CDMA systems.
IEEE Trans. Signal Process. 48(3), 810–823 (2000)
2. M. Sorensen, L.D. Lathauwer, L. Deneire, PARAFAC with orthogonality in one mode and
applications in DS-CDMA systems, in Proceedings of the IEEE International Conference on
Acoustics, Speech and Signal Processing (ICASSP 2010), Dallas, Texas (2010), pp. 4142–4145
3. M. Sorensen, L.D. Lathauwer, P. Comon, S. Icart, L. Deneire, Canonical polyadic decom-
position with a columnwise orthonormal factor matrix. SIAM J. Matrix Anal. Appl. 33(4),
1190–1213 (2012)
4. Q. Zhao, L. Zhang, A. Cichocki, Bayesian CP factorization of incomplete tensors with auto-
matic rank determination. IEEE Trans. Pattern Anal. Mach. Intell. 37(9), 1751–1753 (2015)
5. K.P. Murphy, Machine Learning: A Probabilistic Perspective (MIT Press, Cambridge, 2012)
6. C.G. Khat, K.V. Mardia, The von Mises-Fisher distribution in orientation statistics. J. R. Stat.
Soc. 39, 95–106 (1977)
7. M. West, On scale mixtures of normal distributions. Biometrika 74(3), 646–648 (1987)
8. A.K. Gupta, D.K. Nagar, Matrix Variate Distributions (CRC Press, Boca Raton, 1999)
9. T. Kanamori, A. Takeda, Non-convex optimization on Stiefel manifold and applications to
machine learning, in Neural Information Processing (2012), pp. 109–116
10. A. Georghiades, D. Kriegman, P. Belhumeur, From few to many: generative models for recogni-
tion under variable pose and illumination. IEEE Trans. Pattern Anal. Mach. Intell. 40, 643–660
(2001)
11. M. Sørensen, D. Ignat, L.D. Lieven, Coupled canonical polyadic decompositions and (coupled)
decompositions in multilinear rank-(Lr, n, Lr, n, 1) terms–Part II: Algorithms. SIAM J. Matrix
Anal. Appl. 36(3), 1015–1045 (2015)
12. X. Luciani, L. Albera, Canonical polyadic decomposition based on joint eigenvalue decompo-
sition. Chemom. Intell. Lab. Syst. 132, 152–167 (2014)
13. X. Fu, K. Huang, W.-K. Ma, N.D. Sidiropoulos, R. Bro, Joint tensor factorization and outlying
slab suppression with applications. IEEE Trans. Signal Process. 63(23), 6315–6328 (2015)
14. L. Cheng, Y.-C. Wu, H.V. Poor, Probabilistic tensor canonical polyadic decomposition with
orthogonal factors. IEEE Trans. Signal Process. 65(3), 663–676 (2017)
15. C.A.R. Fernandes, A.L.F. de Almeida, D.B. da Costa, Uniﬁed tensor modeling for blind
receivers in multiuser uplink cooperative systems. IEEE Signal Process. Lett. 19(5), 247–250
(2012)
16. A.Y. Kibangou, A. De Almeida, Distributed PARAFAC based DS-CDMA blind receiver for
wireless sensor networks, in Proceedings of the IEEE International Conference on Signal
Processing Advances in Wireless Communications (SPAWC 2010), Marrakech, Jun. 20–23
(2010), pp. 1–5
17. A.L.F. de Almeida, A.Y. Kibangou, S. Miron, D.C. Araujo, Joint data and connection topology
recovery in collaborative wireless sensor networks, in Proceedings of the IEEE International
Conference on Acoustics, Speech and Signal Processing (ICASSP 2013), Vancouver, BC, May
26–31 (2013), pp. 5303–5307
18. B. Pesquet-Popescu, J.-C. Pesquet, A.P. Petropulu, Joint singular value decomposition - a
new tool for separable representation of images, in Proceedings of the IEEE International
Conference on Image Processing (ICIP 2001), Thessaloniki, Greece (2001), pp. 569–572
19. A. Shashua, A. Levin, Linear image coding for regression and classiﬁcation using the tensor-
rank principle, in Proceedings of the 2001 IEEE Computer Society Conference on Computer
Vision and Pattern Recognition (CVPR 2001), Kauai, Hawaii (2001), pp. 42–49

Chapter 8
Handling Missing Value: A Case Study
in Direction-of-Arrival Estimation
Abstract In previous chapters, the Bayesian CPDs are derived under fully observed
tensors. However, in practice, there are many scenarios where only part of the tensors
can be observed. This gives rise to the tensor completion problem. In this chapter,
we use subspace identiﬁcation for direction-of-arrival (DOA) estimation as a case
study to elucidate the key idea of the associated Bayesian modeling and inference in
data completion. In particular, we ﬁrstly introduce how DOA signal subspace recov-
ery is linked to tensor decomposition under missing data. Then, the corresponding
probabilistic model is established and the subsequent inference problem is solved by
using Theorem 2.1 in Chap.2.
8.1
Linking DOA Subspace Estimation to Tensor
Completion
Consider an arbitrary sensor array with a total of M sensors as seen in Fig.8.1, where
the mth sensor is located at coordinate (xm, ym, zm). There are R far-ﬁeld narrow-
band radiating sources impinging on this array. With the source at elevation angle θr
and azimuth angle φr transmitting a signal ξr(n) at the nth snapshot, the discrete-time
complex baseband signal received by the mth sensor is [1]
yxm,ym,zm(n) =
R

r=1
ξr(n)exp

j

xmur + ymvr + zm pr

+ wxm,ym,zm(n)
(8.1)
where ur = 2π
λc sin θr cos φr, vr = 2π
λc sin θr sin φr, and pr = 2π
λc cos θr with λc
being the wavelength of the carrier signal. It is assumed that the transmitted sig-
nal ξr(n) is a zero-mean wide-sense stationary random process with correlation
E

ξr(k)ξ ∗
r′(k + τ)

= δ(r −r′)rr(τ),
and
the
additive
noise
wxm,ym,zm(n) ∼
CN

wxm,ym,zm(n) | 0, β−1
is spatially and temporally independent.
The goal is to ﬁnd the DOA pairs {θr, φr}R
r=1 from the received signal
{yxm,ym,zm(n)}m,n, with no knowledge of the source number R, noise power β−1, and
the statistics of source signals {ξr(n)}r,n. Since the DOA parameters are
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023
L. Cheng et al., Bayesian Tensor Decomposition for Signal Processing and
Machine Learning, https://doi.org/10.1007/978-3-031-22438-6_8
155

156
8
Handling Missing Value: A Case Study in Direction-of-Arrival Estimation
x
y
z
φ
θ
(
(
Fig. 8.1 Multiple sources impinging on an arbitrary array (© [2019] IEEE. Reprinted, with permis-
sion, from [L. Cheng, C. Xing, and Y.-C. Wu, Irregular Array Manifold Aided Channel Estimation
in Massive MIMO Communications, IEEE Journal of Selected Topics in Signal Processing, Sep
2019]. It applies all ﬁgures and tables in this chapter)
nonlinearly coupled, it requires an exhaustive search if we employ direct optimiza-
tion, which however is computationally demanding. As an efﬁcient alternative, sub-
space methods ﬁrstly ﬁnd the subspace in which the DOA signals lie in, and then
the DOA parameters are extracted from the subspace structure, thus bypassing the
exhaustive search problem.
Although subspace-based DOA estimation is not new, this chapter treats the signal
obtained from the arbitrary array as data from a tensor with missing values. Not only
this treatment would lead to a better subspace recovery than its matrix counterpart,
but also tensor-based methods allow the subspaces in azimuth domain and elevation
domaintobeseparatelyestimated,thusfurtherreducingthecomplexityofsubsequent
DOA estimations [2]. More importantly, by viewing the subspace estimation problem
as a tensor completion problem, it does not require shift-invariant sub-structure of
the array. This leads to more general applicability than previous tensor subspace
methods [3–6], which all require a shift-invariant sub-structure of the array and are
inapplicable when the array shape is arbitrary.
To leverage the power of the tensor framework, we treat the arbitrary array as a
cuboid array with missing elements, based on which the subspace estimation problem
can be cast as a tensor completion problem. To construct the cuboid array, we project
the sensor elements onto the x-axis, y-axis, and z-axis, respectively, as shown in
Fig.8.2. In particular, let Sx denotes the set collecting the projected coordinates on
the x-axis, with repeated values eliminated and remaining values arranged from small
tolarge,thevalueof Sx(i1)isthei1th largestnumberin{xm}M
m=1.Similarly,sets Sy and
Sz collect the projected and ordered coordinates on the y-axis and z-axis, respectively.
Denoting the cardinality of sets |Sx| = I1, |Sy| = I2, and |Sz| = I3, the cuboid grid

8.1 Linking DOA Subspace Estimation to Tensor Completion
157
x
y
z
· · ·
· · ·
· · ·
· · ·
· · ·
· · ·
x
y
z
x
y
z
Fig. 8.2 The projected coordinates of sensors are connected to form a cuboid grid
is the collection of coordinates (x, y, z) such that x ∈Sx, y ∈Sy, and z ∈Sz, and it
forms a 3D tensor with dimensions I1, I2, and I3. We denote this constructed tensor as
Y(n). For the signal yxm,ym,zm(n) received by the mth sensor, it is naturally assigned
to the tensor element Yi1,i2,i3(n) where the index (i1, i2, i3) satisﬁes Sx(i1) = xm,
Sy(i2) = ym, and Sz(i3) = zm. After assigning the data collected by all M sensors,
there is still a portion of tensor elements unknown in the constructed 3D tensor, where
the missing ratio is 1 −
M
I1I2I3 . With each unknown tensor element being assigned a
value zero, and using the data model (8.1), the constructed tensor Y(n) would contain
elements
Yi1,i2,i3(n) = Oi1,i2,i3(n) ×
	
R

r=1
ξl(n)exp

j

Sx(i1)ur + Sy(i2)vr + Sz(i3)pr

+ wSx(i1),Sy(i2),Sz(i3)(n)

(8.2)
where Oi1,i2,i3(n) equals one if data Yi1,i2,i3(n) is available, and zero otherwise.
Using the deﬁnition of tensor canonical polyadic decomposition (CPD), it is easy
to show that (8.2) can be expressed in a tensor form as
Y(n) = O(n) ⊙
⎛
⎜⎜⎜⎜⎜⎝
R

r=1
a(ur) ◦a(vr) ◦a(pr) ◦ξr(n)



≜[[A[u],A[v],A[ p],ξ(n)]]
+W(n)
⎞
⎟⎟⎟⎟⎟⎠
,
(8.3)
where ⊙and ◦denote the Hadamard product and the outer product, respectively,
while O(n) is a tensor with (i1, i2, i3)th element given by Oi1,i2,i3(n). For the
noise tensor W(n), its (i1, i2, i3)th element is given by wSx(i1),Sy(i2),Sz(i3)(n) if data
Yi1,i2,i3(n) is available and zero otherwise. In (8.3), ξ(n) = [ξ1(n), ξ2(n), . . ., ξR(n)].
We also deﬁned A [u] ∈CI1×R with the rth column being a(ur) = [exp( jur Sx(1)),
exp( jur Sx(2)), . . ., exp( jur Sx(I1))]T . Matrices A [v] ∈CI2×R and A

p

∈CI3×R

158
8
Handling Missing Value: A Case Study in Direction-of-Arrival Estimation
are deﬁned similarly but with the rth column being a(vr) = [exp( jvr Sy(1)),
exp( jvr Sy(2)), . . . , exp( jvr Sy(I2))]T and a(pr) = [exp( jpr Sz(1)), exp( jpr Sz(2)),
. . ., exp( jpr Sz(I3))]T , respectively.
After collecting I4 snapshots data along the time dimension, we have a fourth-
order data tensor ˙Y ∈CI1×I2×I3×I4. Using the tensor CPD deﬁnition, it is easy to
show the data model can be expressed as
˙Y = ˙O ⊙
⎛
⎜⎜⎜⎜⎜⎝
R

r=1
a(ur) ◦a(vr) ◦a(pr) ◦a(ξr)



≜[[A[u],A[v],A[ p],A[ξ]]]
+ ˙W
⎞
⎟⎟⎟⎟⎟⎠
,
(8.4)
where the observation tensor ˙O and noise tensor ˙W are constructed in the same way
as data tensor ˙Y, and matrix A

ξ

∈CI4×R is constructed with the rth column being
a(ξr) = [ξr(1), . . . , ξr(I4)]T . Note that a more generalized model where A

ξ

is
assumed to be rank-1 can be found in [11], but the subsequent modeling and inference
procedure are similar to what is presented in this chapter.
To recover the DOA subspaces from the tensor representation in (8.4), we have
the following property.
Property 8.1 If [[A [u] , A [v] , A[ p], A[ξ]]] = [[(1), (2), (3), (4)]]
and
2 ≤R ≤min{I1, I2, I3, I4},
the
following
equations
hold:
(1) = A [u] (1),
(2) = A [v] (2),
(3) = A[ p](3),
and
(4) = A[ξ](4) where  is a permutation matrix and 4
k=1 (k) = I R .
This property indicates that the columns of the factor matrix (1) span the same
column space as those of matrix A [u], since the permutation matrix  and diagonal
matrix (1) are invertible. Similarly, columns of (2) span the same space as that
of A [v], and columns of (3) span the same space as that of A

p

. Therefore, the
core problem of subspace estimation is to ﬁnd the factor matrices {(k)}4
k=1 under
unknown number of sources R, and the problem can be stated as
min
{(k)}4
k=1
β ∥˙Y −˙O ⊙[[(1), (2), (3), (4)]] ∥2
F +
L

l=1
γl
	
4

k=1
(k)H
:,l
(k)
:,l

(8.5)
where L is the maximum possible value of the number of sources R.
This problem is known as complex-valued tensor completion problem, and it is
easy to show its non-convexity, since all the factor matrices {(k)}4
k=1 are coupled via
Khatri–Rao products. Furthermore, the tensor rank acquisition is generally NP-hard
[7], due to its discrete nature. This issue can be remedied by adding a regularization

8.2 Probabilistic Modeling
159
term L
l=1 γl
	4
k=1 (k)H
:,l
(k)
:,l

in order to control the complexity of the model and
avoid overﬁtting of noise. However, determining the optimal regularization param-
eters {γl}L
l=1 is difﬁcult, and conventional methods usually rely on computationally
demanding search schemes [8]. Fortunately, we can build a probabilistic model, so
that the regularization parameters and the factor matrices can be learned from the VI
framework.
8.2
Probabilistic Modeling
To use the probabilistic framework, the optimization problem (8.5) needs to be inter-
preted using probabilistic language. In particular, the squared error term in problem
(8.5) can be interpreted as the negative log of a likelihood function given by
p
	
˙Y | {(n)}4
n=1, β

∝exp

−β

i1,i2,i3,i4
˙Oi1,i2,i3,i4
 ˙Yi1,i2,i3,i4 −[[(1), (2), (3), (4)]]i1,i2,i3,i4

2

.
(8.6)
On the other hand, the regularization term in problem (8.5) can be interpreted as
a zero-mean circularly symmetric complex Gaussian prior distribution over the
columns of the factor matrices, i.e.,
p({(k)}4
k=1|{γl}L
l=1) =
4

k=1
L

l=1
CN
	
(k)
:,l |mc, γ −1
l
I Ik

=
4

k=1
Ik

κ=1
CN
	
(k)
κ,:|mr, 

,
(8.7)
where mc = 0Ik×1, mr = 0L×1,  = diag{γ1, γ2, . . ., γL}, and the latter part is an
equivalent expression with the unknown changed to the row of (k). In (8.7),
the inverse of the regularization parameter γ −1
l
has a physical interpretation of
the power of the lth column of various factor matrices. When power γ −1
l
goes
to zero, it indicates the corresponding columns in various factor matrices play no
role and can be pruned out. Since we know nothing about the regularization param-
eter γl and noise power β−1 before inference, non-informative gamma prior [9]
is imposed on them, i.e., p(β|αβ) = gamma(β|10−6, 10−6) and p({γl}L
l=1|λγ ) =
L
l=1 gamma(γl|10−6, 10−6).
The complete probabilistic model is shown in Fig.8.3. Compared to the MPCEF
model in Chap.2, it is obvious that η(1) = {{(k)
κ,:}κ,k, β} are the unknown variables

160
8
Handling Missing Value: A Case Study in Direction-of-Arrival Estimation
β
{γl}
{Ξ(3)
i3,:}
{Ξ(2)
i2,:}
{Ξ(1)
i1,:}
{Ξ(4)
i4.:}
λγ
αβ
˙O
˙Y
mr
Fig. 8.3 Probabilistic model of tensor subspace estimation
in Layer 1 and η(2) = {γl}L
l=1 are the unknown variables in Layer 2. However, due to
complication induced by the missing values, we need to check whether this proba-
bilistic model lies within the MPCEF introduced in Chap.2.1
8.3
MPCEF Model Checking and Optimal Variational Pdfs
Derivations
8.3.1
MPCEF Model Checking
For variable (k)
κ,: in Layer 1, we need to show that p
	
˙Y | (k)
κ,:, {η(1)\(k)
κ,:}

takes the form of (2.25). By expanding the square term in (8.6) using
[[A(1), A(2), . . ., A(N)]]i1,i2,...,iN = A(k)T
ik,:

N⋄
n=1,n̸=k A(n)T
in,:
T , we arrive at
1 MPCEF is deﬁned for real-valued model. But we can easily extend the expression to complex-
valued.

8.3 MPCEF Model Checking and Optimal Variational Pdfs Derivations
161
p
	
˙Y|{(k)}4
k=1, β

= exp

Re
 
i1,...,i4
˙Oi1,...,i4 ln
 β
π

−β

i1,...,i4
˙Oi1,...,i4

˙Yi1,...,i4 ˙Y∗
i1,...,i4
−2

˙Y∗
i1,...,i4(k)T
κ,:

4⋄
n=1,n̸=k (n)T
in,:
T

+ (k)T
κ,:

4⋄
n=1,n̸=k (n)T
in,:
T 
4⋄
p=1,p̸=k (p)T
i p,:
∗(k)∗
κ,:

.
(8.8)
By ﬁxing variables other than (k)
κ,: in (8.8),
p
	
˙Y|(k)
κ,: , {η(1)\(k)
κ,: }

= exp

Re

2β

i1,...ik=κ,...i4
˙Oi1,...,i4 ˙Y∗
i1,...,i4(k)T
κ,:

4⋄
n=1,n̸=k (n)T
in,:
T
−vec
	
β

i1,...ik=κ,...i4
˙Oi1,...,i4

4⋄
n=1,n̸=k (n)
in,:
T 
4⋄
p=1,p̸=k (p)
i p,:
∗
H
vec
	
(k)∗
κ,: (k)T
κ,:

−

i1,...ik̸=κ,...i4

2β

i1,...ik=κ,...i4
˙Oi1,...,i4 ˙Y∗
i1,...,i4(k)T
ik,:

4⋄
n=1,n̸=k (n)T
in,:
T
−vec
	
β

i1,...ik=κ,...i4
˙Oi1,...,i4

4⋄
n=1,n̸=k (n)
in,:
T 
4⋄
p=1,p̸=k (p)
i p,:
∗
H
vec
	
(k)∗
ik,: (k)T
ik,:


+

i1,...,i4
˙Oi1,...,i4 ln
 β
π

−β

i1,...,i4
˙Oi1,...,i4 ˙Yi1,...,i4 ˙Y∗
i1,...,i4

.
(8.9)
Comparing (8.9) to (2.25), we can see that t((k)
κ,:) = [(k)∗
κ,: ; vec((k)∗
κ,: (k)T
κ,: )],
n( ˙Y, {η(1)\(k)
κ,: }) =
⎡
⎢⎢⎣
2β 
i1,...ik=κ,...i4 ˙Oi1,...,i4 ˙Y∗
i1,...,i4

4⋄
n=1,n̸=k (n)T
in,:
T
−vec
	
β 
i1,...ik=κ,...i4 ˙Oi1,...,i4

4⋄
n=1,n̸=k (n)
in,:
T 
4⋄
p=1,p̸=k (p)
i p,:
∗
⎤
⎥⎥⎦.
(8.10)
Furthermore, the prior for (k)
κ,: in (8.7) is in the form of (2.26)
p
	
(k)
κ,: |mr, {γl}L
l=1

= exp

Re
 % 0L×1
−vec()
&H '
(k)∗
κ,:
vec((k)∗
κ,: (k)T
κ,: )
(
+
L

l=1
log γl −L log π

,
(8.11)
where n(mr, {γl}L
l=1) = [0L×1; −vec()].

162
8
Handling Missing Value: A Case Study in Direction-of-Arrival Estimation
Now, focusing on the variable β in Layer 1, (8.6) can be expressed as
p
	
˙Y|β, {η(1)\β}

=exp

Re

−

i1,...,i4
˙Oi1,...,i4 ln π +

i1,...,i4
˙Oi1,...,i4 ln β
−β

i1,...,i4
˙Oi1,...,i4
 ˙Yi1,...,i4 −[[(1), (2), (3), (4)]]i1,...,i4

2
, (8.12)
which is in the form of (2.25), where t(β) = [β; ln β],
n( ˙Y, {η(1)\β}) =
⎡
⎣−
i1,...,i4 ˙Oi1,...,i4
 ˙Yi1,...,i4 −[[(1), (2), (3), (4)]]i1,...,i4

2

i1,...,i4 ˙Oi1,...,i4
⎤
⎦.
(8.13)
Furthermore, prior p(β|αβ) = gamma(β|10−6, 10−6) is in the form of (2.26), since
p(β|αβ) = exp
% −10−6
10−6 −1
&H % β
log β
&
+ 10−6 ln 10−6 −ln (10−6)

,
(8.14)
with n(αβ) = [−10−6; 10−6 −1]. Therefore, Condition 1 is satisﬁed.
For variable γl in Layer 2 of Fig.8.3, p({(k)}4
k=1|γl, {η(2)\γl}) is
p({(k)}4
k=1|γl, {η(2)\γl}) = exp

Re
 %−4
k=1 (k)H
:,l
(k)
:,l
4
k=1 Ik
&H % γl
ln γl
&
+
L

j=1, j̸=l
	
−
4

k=1
(k)H
:, j
(k)
:, j

γ j +
4

k=1
Ik
L

j=1, j̸=l
ln γ j −
4

k=1
Ik R ln π

.
(8.15)
Ittakestheformof(2.27)ifwedeﬁnen({(k)}4
k=1, {η(2)\γl}) = [−4
k=1 (k)H
:,l
(k)
:,l ;
4
k=1 Ik] and t(γl) = [γl; ln γl]. On the other hand, the prior of γl takes the form
p(γl|λγ ) = exp
⎛
⎝
'
−10−6
10−6 −1
(H '
γl
log γl
(
+ 10−6 ln 10−6 −ln (10−6)
⎞
⎠, (8.16)
which is consistent with (2.28) if we deﬁne n(λγ ) = [−10−6; 10−6 −1]. Therefore,
Condition 2 is veriﬁed. Finally, variables {αβ, λγ , mr, ˙O} are known quantities, and
thus Condition 3 holds. To summarize, the Bayesian tensor completion model is in
MPCEF.

8.3 MPCEF Model Checking and Optimal Variational Pdfs Derivations
163
8.3.2
Optimal Variational Pdfs Derivations
As shown above, the probabilistic model for tensor completion satisﬁes Conditions
1–3 of MPCEF, and thus the optimal variational pdfs can be directly obtained using
Theorem 2.1 in Chap.2. More speciﬁcally, the optimal variational pdf Q∗((k)
κ,:) can
be calculated as
Q∗((k)
κ,: )∝exp

Re

E
θ j ̸=(k)
κ,:
'
n( ˙Y, η(1)\(k)
κ,: )1 + 0L×1
n( ˙Y, η(1)\(k)
κ,: )2 −vec()
(H '
(k)∗
κ,:
vec((k)∗
κ,: (k)T
κ,: )
( 
.
(8.17)
Its functional form coincides with the complex Gaussian distribution CN((k)
κ,:|
M(k)
κ,:, (k)
κ ), where
(k)
κ
=
⎡
⎣EQ(γl )[] + EQ(β)[β]

i1,...ik=κ,...i4
˙Oi1,...,i4E
n Q((n))
)
4⋄
n=1,n̸=k (n)T
in,:
T 
4⋄
p=1,p̸=k (p)T
i p,:
∗*
⎤
⎦
−1
,
(8.18)
M(k)
κ,: = (k)
κ

i1,...ik=κ,...i4
EQ(β)[β] ˙Oi1,...,i4 ˙Yi1,...,i4

4⋄
n=1,n̸=k E
Q((n)
in,:)[(n)T
in,: ]
T .
(8.19)
Similarly, the optimal variational pdf Q∗(β) is derived to be
Q∗(β)∝exp

Re

E
θ j ̸=β
'
n( ˙Y, η(1)\β)1 −10−6
n( ˙Y, η(1)\β)2 + 10−6 −1
(H '
β
ln β
( 
,
(8.20)
which is a gamma distribution gamma(β|c, d) with
c = 10−6 +

i1,...,i4
˙Oi1,...,i4,
(8.21)
d = 10−6 + E
n Q((n))
' 
i1,...,i4
˙Oi1,...,i4
 ˙Yi1,...,i4 −[[(1), (2), (3), (4)]]i1,...,i4

2
(
.
(8.22)
For variable γl, its optimal variational pdf Q∗(γl) is
Q∗(γl)∝exp

Re

E
θ j ̸=γl
'
−4
k=1 (k)H
:,l
(k)
:,l −10−6
4
k=1 Ik + 10−6 −1
(H % γl
ln γl
& 
.
(8.23)

164
8
Handling Missing Value: A Case Study in Direction-of-Arrival Estimation
It can be seen that Q∗(γl) follows a gamma distribution gamma(β|al, bl), where
al = 10−6 +
4

k=1
Ik
(8.24)
bl = 10−6 +
4

k=1
E
n Q((n))
)
(k)H
:,l
(k)
:,l
*
.
(8.25)
In (8.17)–(8.25), there are several expectations to be computed. Simple
expectations EQ((k)
κ,: )[(k)
κ,:], EQ(γl)[γl], and EQ(β)[β] can be obtained using results
presented
in
previous
chapters.
However,
there
are
two
expectations
E
n Q((n))
)
4⋄
n=1,n̸=k (n)T
in,:
T

4⋄
p=1,p̸=k (p)T
i p,:
∗*
and E
n Q((n))
) ˙Yi1,...,i4 −[[(1),
(2), (3), (4)]]i1,...,i4

2*
that are more difﬁcult to compute. By Property 6.2, they
are derived as
E
n Q((n))
)
4⋄
n=1,n̸=k (n)T
in,:
T 
4⋄
p=1,p̸=k (p)T
i p,:
∗*
=
4⊙
n=1,n̸=k
)
M(n)
in,:M(n)H
in,:
+ (n)∗
in
*
,
(8.26)
E
n Q((n))
% ˙Yi1,...,i4 −[[(1), (2), (3), (4)]]i1,...,i4

2&
=
 ˙Yi1,...,i4

2
−2Re

˙Y∗
i1,...,i4 M(1)T
i1,:

4⋄
n=2 M(n)T
in,:
T

+ Tr
	 )
M(1)
i1,:M(1)H
i1,:
+ (1)
i1
*
4⊙
n=2
)
M(n)
in,:M(n)H
in,:
+ (n)∗
in
* 
.
(8.27)
8.4
Algorithm Summary and Remarks
The variational inference algorithm for the proposed model is summarized in
Algorithm 11. After convergence, some EQ∗(γl)[γl] = at
l /bt
l will be very large, e.g.,
106, indicating that the power of corresponding columns goes to zero. Then, these
columns can be safely pruned out, and the remaining column number is the estimate
of the path number R. Meanwhile, since Q∗((k)
κ,:) is Gaussian distribution, factor
matrices {(k)}4
k=1 are estimated by the {M(k,t)}4
k=1 at convergence.
According to Property 8.1, the subspaces spanned by the columns in A[u], A[v],
and A[ p] are estimated by the range spaces of M(1,t), M(2,t), and M(3,t), respec-
tively. Thereby, 1D subspace-based DOA estimation methods, such as multiple signal
classiﬁcation (MUSIC) and estimation of signal parameters via rotation invariance
technique (ESPRIT), can be applied to the range spaces of {M(k,t)}3
k=1 to separately
estimate the DOAs θr and φr. Details of applying 1D DOA methods in 2D DOA
estimation can be found in [2].

8.5 Simulation Results and Discussions
165
Algorithm 11 Probabilistic Tensor CPD for DOA Estimation
Initialization: Choose L > R, and initial values {M(k,0) ∈CIk×L, {(k,0)
κ
∈CL×L}Ik
κ=1}4
k=1. Let
a0
l = 10−6, b0
l = 10−6 for l = 1, 2, 3, ..., L; c0 = d0 = 10−6.
Iterations: For the tth iteration (t ≥1),
Update the parameter of each Q∗((k)
κ,: )t:
(k,t)
κ
=
% ct−1
dt−1

i1,...,ik=κ,...i4
˙Oi1,...,i4
4⊙
n=1,n̸=k
)
M(n,t−1)
in,:
M(n,t−1)H
in,:
+ (n,t−1)∗
in
*
+diag
+
at−1
1
bt−1
1
,. . .,
at−1
L
bt−1
L
,&−1
,
(8.28)
M(k,t)
κ,:
= ct−1
dt−1 (k,t)
κ

i1,...ik=κ,...i4

˙Oi1,...,i4 ˙Yi1,...,i4

4⋄
n=1,n̸=k M(n,t−1)T
in,:
T 
,
(8.29)
Notice that for each k ∈{1, 2, 3, 4}, the update for κ = 1, 2, . . . , Ik can be updated in parallel.
Update the parameter of Q∗({γl}L
l=1)t:
at
l = 10−6 +
4

k=1
Ik,
(8.30)
bt
l = 10−6 +
4

k=1
Ik

κ=1
M(k,t)
κ,l

2
+
)
(k,t)
κ
*
l,l .
(8.31)
Update the parameter of Q∗(β)t:
ct = 10−6 +

i1,...,i4
˙Oi1,...,i4,
(8.32)
dt = 10−6 +

i1,...,i4
˙Oi1,...,i4
 ˙Yi1,...,i4

2
−2Re

˙Y∗
i1,...,i4 M(1,t)T
i1,:

4⋄
n=2 M(n,t)T
in,:
T

+ Tr
	 )
M(1,t)
i1,: M(1,t)H
i1,:
+ (1,t)
i1
*
4⊙
n=2
)
M(n,t)
in,: M(n,t)H
in,:
+ (n,t)∗
in
* 

.
(8.33)
Until Convergence
8.5
Simulation Results and Discussions
In this subsection, numerical results are presented to assess the performance of the
proposed method (labeled as VI) for subspace estimation over I4 = 100 snapshots.
The arbitrary array was generated by randomly deploying M sensor elements so that
the projected coordinates form a 3D grid with dimensions I1 = 8, I2 = 10, I3 = 12
and the inter-grid spacing dx = λc/2, dy = λc/4, dz = λc/8. We consider two sce-
narios for the arbitrary array: M = 288 and M = 576, corresponding to π = 0.3
and π = 0.6 of the grid points being occupied by sensors, respectively. There are 3
sources with elevation DOAs {15◦, 25◦, 120◦} and azimuth DOAs {−50◦, 10◦, 70◦},
respectively. The transmitted signal of each source ξr(n) is drawn from a zero-
mean circularly symmetric complex Gaussian distribution with unit variance, and

166
8
Handling Missing Value: A Case Study in Direction-of-Arrival Estimation
Fig. 8.4 Percentage of correct rank estimates
without any correlation across r and n. The signal-to-noise ratio (SNR) is deﬁned
as 10 log10
	
∥˙O⊙[[A[u],A[v],A[ p],A[ξ]]]∥2
F
∥W∥2
F

. For Algorithm 11, initial mean M(k,0) for
each matrix (k) is set as the singular value decomposition (SVD) approximation
U:,1:R

S1:R,1:R
 1
2 where [U, S, V] = SVD[[ ˙Y](k)], L = max{I1, I2, I3, I4}. The ini-
tial covariance matrix (k,0)
κ
= I L×L. Each point in the following ﬁgures is an aver-
age of 1000 Monte Carlo runs with different realizations of the arbitrary arrays,
signals, and noises.
To access the ability of learning the number of sources, the subspace rank learned
by the proposed algorithm is shown in Fig.8.4, with each vertical bar showing the
percentages of correct estimates. From Fig.8.4, it is seen that Algorithm 11 can
recover the true tensor rank with 100% accuracy for a wide range of SNRs. Notice
that Algorithm 11 can only recover the correct tensor rank with 100% accuracy in
moderate and high-SNR regions, and particularly in the region SNR > 5 dB for this
application.
Finally, the performance of DOA subspace estimation in terms of the
averaged largest principal angle
1
3

LPA(M(1), A[u]) + LPA(M(2), A[v]) + LPA
(M(3), A[ p])

is shown in Fig.8.5. LPA(A, B) is a measure of the “distance”
between two subspaces spanned by the columns of matrices A and B, deﬁned as
cos−1{σmin{orth{A}H orth{B}}}, where the operator σmin{ Q} denotes the smallest
singular value of the matrix Q and orth{ Q} is an orthonormal basis for the subspace
spanned by the columns of Q. The range of LPA is from 0◦to 90◦, where LPA

References
167
Fig. 8.5 Averaged largest principal angle (LPA) of subspace estimation
0◦means that the two subspaces are identical while LPA 90◦means that the two
subspaces are orthogonal.
From Fig.8.5, it is seen that Algorithm 11 gives averaged LPA less than 5◦when
SNR is larger than 5dB, no matter π = 0.3 or π = 0.6. It shows that Algorithm
11 gives relatively good subspace estimations. On the other hand, for comparison,
a recently proposed alternating least square (ALS)-based tensor completion method
[10] (labeled as ALS) is also simulated. It assumes knowing the exact tensor rank
R = 3, but takes the same initial estimates of factor matrices and termination crite-
rion as that in Algorithm 11. From Fig.8.5, it is apparent that the ALS-based algo-
rithm performs almost indistinguishably from Algorithm 11. However, this result is
obtained with the ALS-based algorithm knowing the tensor rank, while Algorithm
11 without knowing the tensor rank. This shows that Algorithm 11 supersedes the
existing algorithm [10] by providing additional rank learning ability.
References
1. Van Trees, Detection, Estimation, and Modulation Theory, Optimum Array Processing (Wiley,
New York, 2004)
2. L. Cheng, Y.-C. Wu, J. (Charlie) Zhang, L. Liu, Subspace identiﬁcation for DOA estimation in
massive/full-dimension mimo system: bad data mitigation and automatic source enumeration.
IEEE Trans. Signal Process. 63(22), 5897–5909 (2015)

168
8
Handling Missing Value: A Case Study in Direction-of-Arrival Estimation
3. M. Haardt, F. Roemer, G.D. Galdo, Higher-order SVD based subspace estimation to improve
the parameter estimation accuracy in multi-dimensional harmonic retrieval problems. IEEE
Trans. Signal Process. 56(7), 3198–3213 (2008)
4. F. Roemer, M. Haardt, G.D. Galdo, Analytical performance assessment of multi-dimensional
matrix-and tensor-based ESPRIT-type algorithms. IEEE Trans. Signal Process. 62(10), 2611–
2625 (2014)
5. W. Sun, H.C. So, F.K.W. Chan, L. Huang, Tensor approach for eigenvector-based multi-
dimensional harmonic retrieval. IEEE Trans. Signal Process. 61(13), 3378–3388 (2013)
6. X. Guo, S. Miron, D. Brie, S. Zhu, X. Liao, A CANDECOMP/PARAFAC perspective on
uniqueness of DOA estimation using a vector sensor array. IEEE Trans. Signal Process. 59(9),
3475–3481 (2011)
7. Q. Zhao, L. Zhang, A. Cichocki, Bayesian CP factorization of incomplete tensors with auto-
matic rank determination. IEEE Trans. Pattern Anal. Mach. Intell. 37(9), 1751–1753 (2015)
8. P.C. Hansen, Rank Deﬁcient and Discrete Ill-Posed Problems-Numerical Aspects of Linear
Inversion (SIAM, Philadelphia, PA, 1998)
9. K.P. Murphy, Machine Learning: A Probabilistic Perspective (MIT Press, Cambridge, 2012)
10. L. Karlsson, D. Kressner, A. Uschmajew, Parallel algorithms for tensor completion in the CP
format. Parallel Comput. 57, 222–234 (2016)
11. L. Cheng, C. Xing, Y.-C. Wu, Irregular array manifold aided channel estimation in massive
MIMO communications. IEEE J. Selected Topics Signal Process. 13(5), 974–988 (2019)

Chapter 9
From CPD to Other Tensor
Decompositions
Abstract In previous chapters, we have introduced tensor rank learning using GSM
priors for tensor CPD and its extensions to scenarios where additional prior infor-
mation exists or the data structure is altered. In this chapter, we present tensor rank
learning for other tensor decomposition formats. It turns out that what has been pre-
sented for CPD is instrumental for other Bayesian tensor modelings, as they share
many common characteristics.
9.1
Tucker Decomposition (TuckerD)
Tucker decomposition (TuckerD) is introduced in Chap.1,
X = G ×1 U(1) ×2 U(2) ×3 · · · ×N U(N),
(9.1)
where X ∈RI1×···×IN is the target tensor, G ∈RR1×···×RN is a core tensor, and
{U(n) ∈RIn×Rn}N
n=1 are factor matrices. The tuple (R1, . . . , RN) is known as multi-
linear rank. A graphical illustration of Tucker format is provided in Fig.1.6 and
its deterministic algorithm is summarized in Algorithm 2. However, Algorithm 2
requires the knowledge of the multi-linear rank, which is typically unknown in
practice.
To avoid extensive multi-linear rank tuning, a probabilistic approach using
Gaussian-gamma prior is developed in [1]. Notice that rank Rn is the column num-
ber of factor matrix U(n). Following the general philosophy introduced in Sect.3.1,
GSM priors can be placed on the columns of U(n) to learn rank Rn. In particular, the
Gaussian-gamma prior is chosen in [1]. Given the multi-linear rank upper bounds
{Ln}N
n=1, the Gaussian-gamma prior for the factor matrices {U(n) ∈RIn×Ln}N
n=1 is
p({U(n)}N
n=1|{λ(n)}N
n=1) =
N

n=1
p({U(n)}N
n=1|λ(n)) =
N

n=1
Ln

ln=1
N(U(n)
:,ln|0In×1, (λ(n)
ln )−1IIn),
(9.2)
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023
L. Cheng et al., Bayesian Tensor Decomposition for Signal Processing and
Machine Learning, https://doi.org/10.1007/978-3-031-22438-6_9
169

170
9
From CPD to Other Tensor Decompositions
p({λ(n)}N
n=1|aλ
0 , bλ
0) =
N

n=1
p(λ(n)|aλ
0 , bλ
0) =
N

n=1
L

l=1
gamma(λ(n)
ln |aλ
0 , bλ
0),
(9.3)
where λ(n) ∈RL×1 collects precisions of columns in factor matrix U(n) and aλ
0 , bλ
0 are
pre-determined hyper-parameters shared by all random vector {λ(n)}N
n=1. Compared
to Bayesian CPD modeling, Bayesian Tucker has a distinct vector λ(n) for each factor
matrix. If certain precision λ(n)
ln is learned to be a very large value, it indicates that
the corresponding column U(n)
:,ln is zero and thus tensor rank learning is achieved in
each factor matrix (i.e., multi-linear rank).
While an independent sparsity-promoting prior can be placed on the core tensor
G, it ignores the relation between the core tensor G and the factor matrices {U(n) ∈
RIn×Rn}N
n=1. To see this, we rewrite TuckerD (9.1) as
X =
R1

r1=1
R2

r2=1
· · ·
RN

rN =1
Gr1,r2,...,rN U(1)
:,r1 ◦U(2)
:,r2 ◦· · · ◦U(N)
:,rN ,
(9.4)
which is a weighted sum of rank-1 tensors, where each rank-1 tensor is U(1)
:,r1 ◦
U(2)
:,r2 ◦· · · ◦U(N)
:,rN with coefﬁcient Gr1,r2,...,rN . Equation(9.4) demonstrates the rela-
tion between the core tensor G and factor matrices {U(n)}N
n=1. That is, once U(n)
:,ln
is determined to be zero, the corresponding core tensor slice G...,ln,... can also be
enforced to zero. To model such a relation, a Gaussian-gamma prior is placed on
each element of the core tensor as [1]
p(G|{λ(n)}N
n=1, β) =
L1

l1=1
· · ·
L N

lN =1
N

Gl1,l2,...,lN |0,

β
N

n=1
λ(n)
ln
−1
.
(9.5)
Notice that the precision of a particular tensor core element includes a product of
precisions N
n=1 λ(n)
ln . Therefore, if some λ(n)
ln
are learned to be a very large value,
the core tensor element is also zero. In (9.5), β is a scale parameter related to the
magnitude of G and its prior is a gamma distribution gamma(β|aβ
0 , bβ
0 ).
Since it is assumed that the observation noise is Gaussian, the likelihood function
is speciﬁed as
p(Y|G, {U(n)}N
n=1, τ) ∝exp

−τ
2∥Y −G ×1 U(1) ×2 U(2) ×3 · · · ×N U(N)∥2
F

,
(9.6)
where τ is the noise precisions and it is assigned with a Gamma prior distribution
gamma(τ|aτ
0, bτ
0). To summarize, the joint distribution of tensor data Y and model
parameters  = {{U(n)}N
n=1, G, {λ(n)}N
n=1, β, τ} is

9.2 Tensor Train Decomposition (TTD)
171
p(Y, ) = p(Y|G, {U(n)}N
n=1, τ)p({U(n)}N
n=1|{λ(n)}N
n=1)p(G|{λ(n)}N
n=1, β)
× p({λ(n)}N
n=1|aλ
0 , bλ
0)p(β|aβ
0 , bβ
0 )p(τ|aτ
0, bτ
0).
(9.7)
The mean-ﬁeld variational inference (MF-VI) algorithm is derived in [1] to learn
model parameters  from tensor data Y. The mean ﬁeld employed is Q() =
Q(G)Q(β) N
n=1 Q(U(n)) N
n=1 Q(λ(n))Q(τ), and the resultant Bayesian algorithm
is summarized in Algorithm 12. Interested readers can refer to [1] for more details.
9.2
Tensor Train Decomposition (TTD)
Tensor Train Decomposition (TTD) decomposes tensor data X ∈RI1×···×IN into a
set of core tensors {G(n) ∈RRn×In×Rn+1}N
n=1, where each element is in the form
Xi1,...,iN = G(1)
:,i1,: × · · · × G(N)
:,iN ,:.
(9.8)
The tuple (R1, . . . , RN+1) is termed as TT-rank. While a deterministic algorithm for
TTD is summarized in Algorithm 3, it requires the user to specify the prescribed
accuracy, which controls the TT-rank.
To bypass tuning of the prescribed accuracy to obtain satisfactory performance,
[2] formally introduces a novel Gaussian-product-gamma prior to model sparsity
in TTD. In particular, assuming the TT-rank upper bound is (1, L2, . . . , L N, 1) (in
(9.8), each Xi1,...,iN is a scalar, and thus R1 and RN+1 are both required to be 1), the
Gaussian-product-gamma prior for core tensor G(n) is
p(G(n)|λ(n), λ(n+1)) =
Ln

k=1
Ln+1

l=1
N(G(n)
k,:,l|0In×1, (λ(n)
k λ(n+1)
l
)−1IIn), ∀n ∈{1, . . . , N},
(9.9)
p(λ(n)|α(n), β(n)) =
Ln

k=1
gamma(λ(n)
k |α(n)
k , β(n)
k ), ∀n ∈{2, . . . , N},
(9.10)
where λ(n) = [λ(n)
1 , . . . , λ(n)
Ln ], ∀n ∈{2, . . . , N}, and λ(1), λ(N+1) are set as 1. α(n) ∈
RLn, β(n) ∈RLn are pre-determined hyper-parameters of the gamma distributions.
From (9.9), if either λ(n)
k
or λ(n+1)
l
is learned to be a very large value, G(n)
k,:,l is zero.
It is theoretically proved in [2] that such prior could lead to sparsity in TT slices.
Interested readers can refer to [2] for more details of the Gaussian-product-gamma
prior. Notice that (9.9) bears some resemblance with the core tensor modeling (9.5)
in TuckerD, where the precesions of different factor matrix columns are also coupled
together.

172
9
From CPD to Other Tensor Decompositions
Algorithm 12 Probabilistic TuckerD [1]
Initializations: Choose Ln > Rn, ∀n and initial values vec(	G), G, {	U(n), (n)}N
n=1, aβ
M, bβ
M,
{˜a(n)
ln , ˜b(n)
ln }Ln,N
ln=1,n=1, aτ
M, bτ
M.
Iterations:
Update G
The optimal variational pdf of G is a Gaussian distribution Q(G) = N

vec(G) | vec(	G), G

with
its covariance and mean as
vec(	G) = E[τ]G

⊙
n E

U(n)T 
vec(Y),
(9.11)
G =

E[β] ⊙
n E

(n)
+ E[τ] ⊙
n E

U(n)T U(n)−1
.
(9.12)
Update U(n) from n = 1 to N
The optimal variational pdf of U(n) is Q

U(n)
= In
in=1 N

U(n)
in,: | 	U(n)
in,:, (n)
, where
	U(n) = E[τ]Y(n)

⊙
k̸=n E

U(k)
E

GT
(n)

(n),
(9.13)
(n) =

E

(n)
+ E[τ]E

G(n)

⊙
k̸=n U(k)T U(k)

GT
(n)
−1
.
(9.14)
Update β
The optimal variational pdf of β is Q(β) = gamma

aβ
M, bβ
M

with parameters
aβ
M = aβ
0 + 1
2

n
Ln,
(9.15)
bβ
M = bβ
0 + 1
2E

vec

G2T 
⊙
n E

λ(n)
.
(9.16)
Update λ(n) from n = 1 to N
The optimal variational pdf of λ(n) is Q

λ(n)
= Ln
ln=1 gamma

λ(n)
ln
| ˜a(n)
ln , ˜b(n)
ln

with parameters
˜a(n)
ln
= aλ
0 + 1
2
⎛
⎝In +

k̸=n
Lk
⎞
⎠,
(9.17)
˜b(n)
ln
= bλ
0 + 1
2E

u(n)T
·ln
u(n)
·ln

+ 1
2E[β]E

vec

G2
···ln . . .
T 
⊙
k̸=n E

λ(k)
.
(9.18)
Update τ
The optimal variational pdf of τ is Q(τ) = gamma

aτ
M, bτ
M

with parameters
aτ
M = aτ
0 + 1
2

n
In,
(9.19)
bτ
M = bτ
0 + 1
2E
vec(Y) −

⊙
n U(n)

vec(G)

2
F

.
(9.20)
Until Convergence

9.3 PARAFAC2
173
The likelihood function is speciﬁed as
p(Y|{G(n)}N
n=1, τ) ∝exp
⎛
⎝−τ
2
I1

i1=1
· · ·
IN

in=1
(Yi1,...,iN −G(1)
:,i1,: × · · · × G(N)
:,iN ,:)2
⎞
⎠,
(9.21)
where τ is the noise precesion and it is assigned with a Gamma prior distribution
gamma(τ|aτ
0, bτ
0). The complete probabilistic model is summarized in the joint dis-
tribution of tensor data Y and model parameters  = {{G(n)}N
n=1, {λ(n)}N
n=2, τ},
p(Y, ) = p(Y|{G(n)}N
n=1, τ)
N

n=1
p(G(n)|λ(n), λ(n+1))
N

n=2
p(λ(n)|α(n), β(n))p(τ).
(9.22)
A MF-VI algorithm is derived for the probabilistic model (9.22) under the mean ﬁeld
Q() = Q(τ) N+1
n=1 Q(λ(n)) N
n=1
Ln
k=1
Ln+1
ℓ=1 Q(G(n)
k,:,ℓ) in [2] and is summarized
in Algorithm 13. A similar model and algorithm for tensor ring, which is a variant
of TT, is also reported in [3].
9.3
PARAFAC2
Parallel factor analysis 2 (PARAFAC2), which was ﬁrstly introduced in [4, 5], has
recently gained increasing interest due to its effectiveness in analyzing irregular
tensor data [6–16]. In particular, given an irregular tensor data Y = {Yk ∈RI×Jk}K
k=1,
in which each tensor slice Yk has a different column number Jk, PARAFAC2 seeks for
rank-R factor matrices {U(1) ∈RI×R, U(3) ∈RK×R, {Fk ∈RJk×R}K
k=1} via solving
the following problem [5]:
min
U(1),U(3),{Fk}K
k=1
K

k=1
∥Yk −U(1)diag(U(3)
k,: )FT
k ∥2
F,
s.t. FT
i Fi = FT
j F j,
∀i, j ∈{1, . . . , K}.
(9.23)
Notice that in problem (9.23), each tensor slice Yk ∈RI×Jk is decomposed into a
common set of factor matrices {U(1) ∈RI×R, U(3) ∈RK×R} while having a dedicated
factor matrix Fk ∈RJk×R for the kth slice.

174
9
From CPD to Other Tensor Decompositions
Algorithm 13 Probabilistic Tensor Train [2]
Initializations: Choose Ln > Rn, ∀n and initial values { ˆα(n)
k , ˆβ
(n)
k }Ln,N
k=1,n=2, ˆατ, ˆβτ.
Iterations:
Update G(n) from n = 1 to N
The variational update of the TT core ﬁbers follows a Gaussian distribution Q(G(n)
k,:,ℓ) =
In
in=1 N(μG(n)
k,in,ℓ, υG(n)
k,in,ℓ), with its variance and mean as
υG(n)
k,in,ℓ=

E[τ]

i1,i2,...,iN \in
E[b(<n)
(k−1)Ln+k]E[b(>n)
(ℓ−1)Ln+1+ℓ] + E[λ(n)
k ]E[λ(n+1)
ℓ
]
−1
,
(9.24)
μG(n)
k,in ,ℓ=υG(n)
k,in ,ℓE[τ]

i1,i2,...,iN \in

Yi1i2...iN E[t(<n)
k
]E[t(>n)
ℓ
]
−
Ln

k′=1
k′̸=k
Ln+1

ℓ′=1
ℓ′̸=ℓ
E[b(<n)
(k−1)Ln+k′]E[G(n)
k′,in,ℓ′]E[b(>n)
(ℓ−1)Ln+1+ℓ′]

,
(9.25)
in which the following notations are adopted to make the expression more concise:
E[t(<n)] =
n−1

d=1
E[G(d)
:,id,:],
(9.26)
E[b(<n)] =
n−1

d=1
E[G(d)
:,id,: ⊗G(d)
:,id,:],
(9.27)
and E[t(>n)] and E[b(>n)] are deﬁned similarly.
Update λ(n) from n = 2 to N
The variational distribution of λ(n)
k
is Q(λ(n)
k ) = gamma( ˆα(n)
k , ˆβ
(n)
k ), with
ˆα(n)
k
= InLn+1
2
+ In−1Ln−1
2
+ α(n)
k ,
(9.28)
ˆβ
(n)
k
= 1
2
In

in=1
Ln+1

ℓ=1
(E[G(n)
k,in,ℓ
2]E[λ(n+1)
ℓ
]) + 1
2
In−1

in−1=1
Ln−1

ℓ′=1
(E[G(n−1)
ℓ′,in−1,k
2]E[λ(n−1)
ℓ′
]) + β(n)
k .
(9.29)
Update τ
The variational distribution of τ is Q(τ) = gamma( ˆατ, ˆβτ), where
ˆατ =
N
n=1 In
2
+ ατ,
(9.30)
ˆβτ = 1
2

∥Y∥2
F −2
I1

i1=1
. . .
IN

iN =1
Yi1...iN
N

n=1
E[G(n)
:,in,:] +
I1

i1=1
. . .
IN

iN =1
N

n=1
E[G(n)
:,in,: ⊗G(n)
:,in,:]

+ βτ .
(9.31)
Until Convergence

9.3 PARAFAC2
175
Fig. 9.1 An illustration of PARAFAC2
Even for regular tensor data Y = {Yk ∈RI×J}K
k=1, PARAFAC2 and tensor CPD
differ in the sense that tensor CPD restricts factor matrices {Fk}K
k=1 to be equal across
slices, i.e., Fk = F, ∀k. More speciﬁcally, tensor CPD solves the following problem:
min
U(1),U(3),F
K

k=1
∥Yk −U(1)diag(U(3)
k,: )FT ∥2
F.
(9.32)
By comparing problem (9.23) with problem (9.32), it can be seen that PARAFAC2
generalizes tensor CPD to deal with irregular tensor data with unaligned size along
one dimension, as illustrated in Fig.9.1.
To simplify the constraints of {Fk}K
k=1 in problem (9.23), a set of orthogonal
matrices P = {Pk ∈RJk×R} and a rank-R factor matrix U(2) ∈RR×R are introduced
in [5], which transforms problem (9.23) to
min
{U(n)}3
n=1,P
K

k=1
∥Yk −U(1)diag(U(3)
k,: )

U(2)T PT
k ∥2
F,
s.t.
PT
k Pk = IR, ∀k ∈{1, . . . , K},
Pk ∈RJk×R, ∀k ∈{1, . . . , K}, U(2) ∈RR×R.
(9.33)
In [5], the direct ﬁtting (DF) algorithm was developed to solve problem (9.33).
Particularly, given the orthogonal matrices in P, problem (9.33) reduces to a tensor
CPD problem, which can be solved using Algorithm 1. On the other hand, by ﬁxing
the factor matrices {U(n)}3
n=1, each orthogonal matrix in P can be optimized via
singular value decomposition (SVD). Due to the equivalence between problem (9.23)

176
9
From CPD to Other Tensor Decompositions
and problem (9.33) established in [5], after obtaining the solution of problem (9.33)
using the DF algorithm, the solution to problem (9.23) is recovered by Fk = PkU(2),
with {U(1), U(3)} remain the same.
Similar to Bayesian tensor CPD in previous chapters, or TuckerD and TTD, proba-
bilistic PARAFAC2 [17] also employs the sparsity-promoting prior to achieve tensor
rank learning. It starts with L(L ≥R) columns in all factor matrices and places
Gaussian-gamma prior on such over-parametrized columns to encode sparsity infor-
mation. To be more speciﬁc, the prior design for factor matrices is [17]
p(U(1)) =
L

l=1
N(U(1)
:,l |0I×1, II),
(9.34)
p(U(2)) =
L

l=1
N(U(2)
:,l |0J×1, IJ),
(9.35)
p(U(3)|{γl}L
l=1) =
L

l=1
N(U(3)
:,l |0I×1, γ−1
l
IK),
(9.36)
p({γl}L
l=1) =
L

l=1
gamma(γl|c0
l , d0
l ).
(9.37)
On the other hand, the likelihood function in probabilistic PARAFAC2 [17] is
obtained from the objective function of (9.33), by assuming each observation in Y
subject to independent Gaussian noise perturbation. This results in
p(Y|{U(n)}3
n=1, τ; P)∝exp

−τ
2
K

k=1
∥Yk−U(1)diag(U(3)
k,: )

U(2)T PT
k ∥2
F

.
(9.38)
For the noise precision τ, a Gamma prior gamma(τ|a0, b0) is assigned. Based on the
prior and likelihood functions in (9.34)–(9.38), the joint probability of data Y and
parameters  = {{U(n)}3
n=1, {γl}L
l=1, τ} is summarized as
p(Y, {U(n)}3
n=1, {γl}L
l=1, τ; P) = p(Y|{U(n)}3
n=1, τ; P)p(U(1))p(U(2))
× p(U(3)|{γl}L
l=1)p({γl}L
l=1)p(τ).
(9.39)
An inference algorithm was developed in [17] by using variational EM frame-
work under the mean-ﬁeld assumption Q() = N
n=1 Q(U(n)) L
l=1 Q(γl)Q(τ).
The resultant algorithm is summarized in Algorithm 14.

9.3 PARAFAC2
177
Algorithm 14 Probabilistic PARAFAC2 [17]
Initializations: Choose L > R and initial values {M(n), (n)}N
n=1, {cl, dl}L
l=1, a, b.
Iterations:
Update P
Pk = kT
k , ∀k ∈{1, . . . , K},
(9.40)
where k and k are orthogonal matrices obtained from the following singular value decomposition
(SVD):
E[U(2)]diag(E[U(3)
k,: ])

E[U(1)]
T
Yk = kϒkT
k .
(9.41)
Update W
Wk = YkPk, ∀k ∈{1, . . . , K},
(9.42)
Update U(n) from n = 1 to 3
The optimal variational pdf Q∗(U(n)
:,l ) is a Gaussian distribution N(U(n)
:,l |M(n)
:,l , (n)) with its covari-
ance and mean as
(n) =

E [τ] E
 
3⋄
k=1,k̸=n U(k)
T 
3⋄
k=1,k̸=n U(k)
 
+ IL
−1
, n = 1, 2,
(9.43)
(n) =

E [τ] E
 
3⋄
k=1,k̸=n U(k)
T 
3⋄
k=1,k̸=n U(k)
 
+ diag{E[γ1], . . . , E[γL]}
−1
, n = 3,
(9.44)
M(n) = E [τ] W(n)T E

3⋄
k=1,k̸=n U(k)

(n),
(9.45)
where W(n) is the Mode-n unfolding of the tensor W.
Update γl from l = 1 to L
The optimal variational pdf Q∗(αl) coincides with Gamma distribution gamma(cl, dl), where
cl = c0
l + K
2 ,
(9.46)
dl = d0
l + 1
2E

U(3)T 
U(3)
l,l
.
(9.47)
Update τ
The optimal variational pdf Q∗(τ) is derived to be a Gamma distribution gamma(a, b), with
a = a0 + I × J × K
2
,
(9.48)
b = b0 + 1
2E
 K

k=1
∥Wk −U(1)diag(U(3)
k,: )

U(2)T
∥2
F

.
(9.49)
Until Convergence

178
9
From CPD to Other Tensor Decompositions
9.4
Tensor-SVD (T-SVD)
Tensor-SVD (T-SVD) is a relatively new tensor decomposition and ﬁrst appears in
[18]. It has a wide range of applications, especially for color images, videos, and
multi-channel audio sequences modeling [19]. To formally deﬁne T-SVD, we ﬁrstly
introduce several deﬁnitions that are essential for T-SVD.
Deﬁnition 9.1 (T-product) Given X ∈RI1×R×I3 and Y ∈RR×I2×I3, the
T-product X ∗Y is the I1 × I2 × I3 tensor
X ∗Y = fold (circ(X) unfold (Y)),
(9.50)
where unfold(X) =

X:,:,1; . . .; X:,:,I3

, fold is the inverse operator of unfold,
and
circ(X) =
⎡
⎢⎢⎢⎣
X:,:,1
X:,:,I3
· · · X:,:,2
X:,:,2
X:,:,1
· · · X:,:,3
...
...
...
...
X:,:,I3 X:,:,I3−1 · · · X:,:,1
⎤
⎥⎥⎥⎦.
(9.51)
Deﬁnition 9.2 (Identity Tensor) The identity tensor I ∈RI×I×I3 is deﬁned
as the tensor whose ﬁrst frontal slice is the I × I identity matrix, and other
slices are all zeros, i.e., I:,:,1 = II, I:,:,i = 0I×I, ∀i = 2, . . . , I3.
Deﬁnition 9.3 (F-diagonal Tensor) A tensor is called f -diagonal if its frontal
slices are all diagonal matrices.
Deﬁnition 9.4 (Conjugate Transpose) The conjugate transpose of a tensor
is deﬁned as the tensor X† ∈RI2×I1×I3 constructed by conjugate transposing
each frontal slice of X ∈RI1×I2×I3 and then reversing the order of the trans-
posed frontal slices 2 through I3, i.e., X†
:,:,1 = XH
:,:,1, X†
:,:,i = XH
:,:,I3−i+2, ∀i =
2, . . . , I3.
Deﬁnition 9.5 (Orthogonality) A tensor Q ∈RI×I×I3 is called orthogonal,
provided that Q† ∗Q = Q∗Q† = I with I being an I × I × I3 identity
tensor.
Now, we are ready for the deﬁnition of T-SVD.

9.4 Tensor-SVD (T-SVD)
179
Deﬁnition 9.6 (T-SVD) Let X be an I1 × I2 × I3 real-valued tensor. Then X
can be factored as
X = U ∗D ∗V†,
(9.52)
where U ∈RI1×I1×I3, V ∈RI2×I2×I3 are orthogonal tensors, and D ∈
RI1×I2×I3 is an f -diagonal tensor. The factorization (9.52) is called the
T-SVD (i.e., tensor SVD).
For a matrix X, if we perform SVD, X = USVT , the rank of X is deﬁned as the
number of non-zero elements in the diagonal matrix S. Generalizing this to T-SVD,
the tubal rank of X is formally deﬁned as follows.
Deﬁnition 9.7 (Tensor tubal rank) The tubal rank of X is the number of
non-zero tubes of D from the T-SVD of X = U ∗D ∗V†, i.e.,
Rankt(X) = #{i, D(i, i, :) ̸= 0}.
(9.53)
According to [20], any tensor with a tubal rank up to R can be factorized as
X = U ∗V†,
(9.54)
forsomeU andV satisfyingRankt(U) = Rankt(V) = R.In (9.54),U ∈RI1×R×I3,
V ∈RI2×R×I3, and R ≤min (I1, I2) controls the tubal rank. To infer tubal rank, [21]
employs the Gaussian-gamma prior to impose sparsity in U and V. In particular,
assume the low-tubal rank upper bound is L > R,
p(U | λ) =
I1

i=1
L

l=1
I3

k=1
N

Ui,l,k | 0, λ−1
l

,
(9.55)
p(V | λ) =
I2

j=1
L

l=1
I3

k=1
N

V j,l,k | 0, λ−1
l

,
(9.56)
p(λ) =
L

l=1
gamma

λl | aλ
0 , bλ
0

,
(9.57)

180
9
From CPD to Other Tensor Decompositions
where aλ
0 , bλ
0 in the gamma prior are pre-determined hyper-parameters. In (9.55)–
(9.56), each element in the tensor slice U:,l,: and V:,l,: follows a zero-mean Gaussian
distribution with precesion λl, of which the philosophy is similar to the probabilistic
tensor CPD presented in Chap.3.
Prior work [21] also considers the outlier modeling. More speciﬁcally, given the
tensor data Y ∈RI1×I2×I3, the likelihood function is speciﬁed as
p(Y | U, V, S, τ) =
I1

i=1
I2

j=1
I3

k=1
N

Yi, j,k | (U ∗V†)i, j,k + Si, j,k, τ −1
, (9.58)
where the sparse component S is introduced to model the outlier. Exactly the same
as in Chap.6, independent Gaussian-gamma priors are placed over each element in
the additional sparse component S,
p(S | β) =
I1

i=1
I2

j=1
I3

k=1
N

Si, j,k | 0, β−1
i, j,k

,
(9.59)
p(β) =
I1

i=1
I2

j=1
I3

k=1
gamma

βi, j,k | aβ
0 , bβ
0

,
(9.60)
where aβ
0 , bβ
0 are pre-determined hyper-parameters. To complete the Bayesian mod-
eling, the prior of the noise precision τ is p(τ) = gamma

τ | aτ
0, bτ
0

. The prob-
abilistic modeling of T-SVD is summarized by the joint distribution of Y and
 = {U, V, S, λ, β, τ},
p(Y, ) = p(Y | U, V, S, τ)p(U | λ)p(V | λ)p(λ)p(S | β)p(β)p(τ).
(9.61)
A variational inference algorithm under the mean ﬁeld Q() = Q(U)Q(V)Q(S)
Q(λ)Q(β)Q(τ) is developed in [21] and is summarized in Algorithm 15. In
Algorithm 15, −→
x i· denotes the vector formed by unfolding X†
i,:,:, −→
x · j denotes the
vector formed by unfolding X:, j,:, and L is the L × L × I3 tensor whose ﬁrst frontal
slice is the diagonal matrix L:,:,1 = diag{λ1, . . . , λL} and all other slices are zeros.

9.4 Tensor-SVD (T-SVD)
181
Algorithm 15 Probabilistic T-SVD [21]
Initializations: Choose L > R and initial values {
#−→
u i·
$
}I1
i=1, u, {
#−→
v j·
$
}I2
j=1, v, {aλ
r , bλ
r }L
l=1,
{
#
Si, j,k
$
, σ2
i, j,k, aβ
i, j,k, bβ
i, j,k}I1,I2,I3
i=1, j=1,k=1, aτ, bτ.
Iterations:
Update U and V
The optimal variational pdf Q(U) is Q(U) = I1
i=1 N

−→
u i. |
#−→
u i·
$
, u
, whose parameters are
given by
#−→
u i·
$
= ⟨τ⟩u circ(⟨V⟩)⊤
−→
y i· −
#−→s i·
$
,
(9.62)
u =

⟨τ⟩
%
circ(V)⊤circ(V)
&
+ circ(⟨L⟩)
−1
.
(9.63)
Similarly, the optimal variational pdf of V is given by Q(V) = I2
j=1 N

−→
v j. |
#−→
v j.
$
, v
with
the mean and covariance
#−→
v j·
$
= ⟨τ⟩v circ(⟨U⟩)⊤
−→
y · j −
#−→s · j
$
,
(9.64)
v =

⟨τ⟩
%
circ(U)⊤circ(U)
&
+ circ(⟨L⟩)
−1
.
(9.65)
Update λ
The optimal variational pdf is Q(λ) = L
l=1 gamma

λl | aλ
l , bλ
l

with parameters
aλ
l = aλ
0 + (I1 + I2) I3
2
,
(9.66)
bλ
l = bλ
0 + 1
2
%−→
u ·l
2 +
−→
v ·l
2&
.
(9.67)
Update S
The optimal variational pdf of S can be obtained as Q(S) = 
i, j,k N

Si jk |
#
Si, j,k
$
, σ2
i, j,k

with
the parameters
#
Si, j,k
$
= ⟨τ⟩

#
βi, j,k
$
+ ⟨τ⟩
 
Yi, j,k −(U ∗V†)i, j,k

,
(9.68)
σ2
i, j,k =

#
βi, j,k
$
+ ⟨τ⟩
−1
(9.69)
Update β
The optimal variational pdf of β is given by Q

βi, j,k

= gamma

βi, j,k | aβ
i, j,k, bβ
i, j,k

, whose
parameters are
aβ
i, j,k = aβ
0 + 1
2,
(9.70)
bβ
i, j,k = bβ
0 + 1
2
%
β2
i, j,k
&
.
(9.71)

182
9
From CPD to Other Tensor Decompositions
Update τ
The noise precision has the following posterior distribution: Q(τ) = gamma (τ | aτ, bτ), whose
parameters are
aτ = aτ
0 +
N
n=1 In
2
,
(9.72)
bτ = bτ
0 + 1
2

i, j,k
'Yi, j,k −(U ∗V†)i, j,k −Si, j,k

2(
.
(9.73)
Until Convergence
References
1. Q. Zhao, L. Zhang, A. Cichocki, Bayesian sparse tucker models for dimension reduction and
tensor completion (2015). arXiv:1505.02343
2. L. Xu, L. Cheng, N. Wong, Y.-C. Wu, Overﬁtting avoidance in tensor train factorization and
completion: prior analysis and inference, in 2021 IEEE International Conference on Data
Mining (ICDM) (IEEE, 2021), pp. 1439–1444
3. Z. Long, C. Zhu, J. Liu, Y. Liu, Bayesian low rank tensor ring for image recovery. IEEE Trans.
Image Process. 30, 3568–3580 (2021)
4. R.A. Harshman, Parafac2: Mathematical and technical notes, in UCLA Working Papers in
Phonetics, vol. 22, no. 10, pp. 30–44 (1972)
5. H.A. Kiers, J.M. Ten Berge, R. Bro, Parafac2–part i. a direct ﬁtting algorithm for the parafac2
model. J. Chemom.: J. Chemom. Soc. 13(3–4), 275–294 (1999)
6. Y. Panagakis, C. Kotropoulos, Automatic music tagging via parafac2, in 2011 IEEE Interna-
tional Conference on Acoustics, Speech and Signal Processing (ICASSP) (IEEE, 2011), pp.
481–484
7. E. Pantraki, C. Kotropoulos, Automatic image tagging and recommendation via parafac2, in
2015 IEEE 25th International Workshop on Machine Learning for Signal Processing (MLSP)
(IEEE, 2015), pp. 1–6
8. E. Pantraki, C. Kotropoulos, A. Lanitis, Age interval and gender prediction using parafac2
applied to speech utterances, in 2016 4th International Conference on Biometrics and Forensics
(IWBF) (IEEE, 2016), pp. 1–6
9. P.A. Chew, B.W. Bader, T.G. Kolda, A. Abdelali, Cross-language information retrieval using
parafac2, in Proceedings of the 13th ACM SIGKDD international conference on Knowledge
discovery and data mining (2007), pp. 143–152
10. Y. Shin, S.S. Woo, What is in your password? analyzing memorable and secure passwords
using a tensor decomposition, in The World Wide Web Conference (2019), pp. 3230–3236
11. I. Perros, E.E. Papalexakis, F. Wang, R. Vuduc, E. Searles, M. Thompson, J. Sun, Spartan: scal-
able parafac2 for large & sparse data, in Proceedings of the 23rd ACM SIGKDD International
Conference on Knowledge Discovery and Data Mining (2017), pp. 375–384
12. A. Afshar, I. Perros, E.E. Papalexakis, E. Searles, J. Ho, J. Sun, Copa: constrained parafac2
for sparse & large datasets, in Proceedings of the 27th ACM International Conference on
Information and Knowledge Management (2018), pp. 793–802
13. K. Yin, A. Afshar, J.C. Ho, W.K. Cheung, C. Zhang, J. Sun, Logpar: logistic parafac2 factor-
ization for temporal binary data with missing values, in Proceedings of the 26th ACM SIGKDD
International Conference on Knowledge Discovery & Data Mining (2020), pp. 1625–1635
14. A. Afshar, I. Perros, H. Park, C. Deﬁlippi, X. Yan, W. Stewart, J. Ho, J. Sun, Taste: temporal
and static tensor factorization for phenotyping electronic health records, in Proceedings of the
ACM Conference on Health, Inference, and Learning (2020), pp. 193–203

References
183
15. Y. Ren, J. Lou, L. Xiong, J.C. Ho, Robust irregular tensor factorization and completion for
temporal health data analysis, in Proceedings of the 29th ACM International Conference on
Information & Knowledge Management (2020), pp. 1295–1304
16. I. Perros, X. Yan, J.B. Jones, J. Sun, W.F. Stewart, Using the parafac2 tensor factorization on
ehr audit data to understand pcp desktop work. J. Biomed. Inform. 101, 103312 (2020)
17. P.J. Jørgensen, S.F. Nielsen, J.L. Hinrich, M.N. Schmidt, K.H. Madsen, M. Mørup, Analy-
sis of chromatographic data using the probabilistic parafac2, in 33rd Conference on Neural
Information Processing Systems (2019)
18. K. Braman, Third-order tensors as linear operators on a space of matrices. Linear Algebra
Appl. 433(7), 1241–1253 (2010)
19. M.E. Kilmer, C.D. Martin, Factorization strategies for third-order tensors. Linear Algebra Appl.
435(3), 641–658 (2011)
20. O. Semerci, N. Hao, M.E. Kilmer, E.L. Miller, Tensor-based formulation and nuclear norm
regularizationformultienergycomputedtomography.IEEETrans.ImageProcess.23(4),1678–
1693 (2014)
21. Y. Zhou, Y.-M. Cheung, Bayesian low-tubal-rank robust tensor factorization with multi-rank
determination. IEEE Trans. Pattern Anal. Mach. Intell. 43(1), 62–76 (2019)

