www.allitebooks.com

Algorithms Unlocked
www.allitebooks.com

www.allitebooks.com

Algorithms Unlocked
Thomas H. Cormen
The MIT Press
Cambridge, Massachusetts
London, England
www.allitebooks.com

c 2013 Massachusetts Institute of Technology
All rights reserved. No part of this book may be reproduced in any
form by any electronic or mechanical means (including photocopying,
recording, or information storage and retrieval) without permission in
writing from the publisher.
MIT Press books may be purchased at special quantity discounts for
business or sales promotional use. For information, please email
special sales@mitpress.mit.edu or write to Special Sales Department,
The MIT Press, 55 Hayward Street, Cambridge, MA 02142.
This book was set in Times Roman and Mathtime Pro 2 by the author
and was printed and bound in the United States of America.
Library of Congress Cataloging-in-Publication Data
Cormen, Thomas H.
Algorithms Unlocked / Thomas H. Cormen.
p. cm
Includes bibliographical references and index.
ISBN 978-0-262-51880-2 (pbk. : alk. paper)
1. Computer algorithms. I. Title.
QA76.9.A43C685 2013
005.1—dc23
2012036810
10 9 8 7 6 5 4 3 2 1
www.allitebooks.com

Contents
Preface
ix
1
What Are Algorithms and Why Should You Care?
1
Correctness
2
Resource usage
4
Computer algorithms for non-computer people
6
Computer algorithms for computer people
6
Further reading
8
2
How to Describe and Evaluate Computer Algorithms
10
How to describe computer algorithms
10
How to characterize running times
17
Loop invariants
21
Recursion
22
Further reading
24
3
Algorithms for Sorting and Searching
25
Binary search
28
Selection sort
32
Insertion sort
35
Merge sort
40
Quicksort
49
Recap
57
Further reading
59
4
A Lower Bound for Sorting and How to Beat It
60
Rules for sorting
60
The lower bound on comparison sorting
61
Beating the lower bound with counting sort
62
Radix sort
68
Further reading
70
www.allitebooks.com

vi
Contents
5
Directed Acyclic Graphs
71
Directed acyclic graphs
74
Topological sorting
75
How to represent a directed graph
78
Running time of topological sorting
80
Critical path in a PERT chart
80
Shortest path in a directed acyclic graph
85
Further reading
89
6
Shortest Paths
90
Dijkstra’s algorithm
92
The Bellman-Ford algorithm
101
The Floyd-Warshall algorithm
106
Further reading
114
7
Algorithms on Strings
115
Longest common subsequence
115
Transforming one string to another
121
String matching
129
Further reading
136
8
Foundations of Cryptography
138
Simple substitution ciphers
139
Symmetric-key cryptography
140
Public-key cryptography
144
The RSA cryptosystem
146
Hybrid cryptosystems
155
Computing random numbers
156
Further reading
157
9
Data Compression
158
Huffman codes
160
Fax machines
167
LZW compression
168
Further reading
178
www.allitebooks.com

Contents
vii
10
Hard? Problems
179
Brown trucks
179
The classes P and NP and NP-completeness
183
Decision problems and reductions
185
A Mother Problem
188
A sampler of NP-complete problems
190
General strategies
205
Perspective
208
Undecidable problems
210
Wrap-up
211
Further reading
212
Bibliography
213
Index
215
www.allitebooks.com

In loving memory of my mother, Renee Cormen.
www.allitebooks.com

Preface
How do computers solve problems? How can your little GPS ﬁnd, out of
the gazillions of possible routes, the fastest way to your destination, and
do so in mere seconds? When you purchase something on the Internet,
how is your credit-card number protected from someone who intercepts
it? The answer to these, and a ton of other questions, is algorithms. I
wrote this book to unlock the mystery of algorithms for you.
I coauthored the textbook Introduction to Algorithms. It’s a wonder-
ful book (of course, I’m biased), but it gets pretty technical in spots.
This book is not Introduction to Algorithms. It’s not even a textbook.
It goes neither broadly nor deeply into the ﬁeld of computer algorithms,
it doesn’t prescriptively teach techniques for designing computer algo-
rithms, and it contains nary a problem or exercise for the reader to solve.
So just what is this book? It’s a place for you to start, if

you’re interested in how computers solve problems,

you want to know how to evaluate the quality of these solutions,

you’d like to see how problems in computing and approaches to solv-
ing them relate to the non-computer world,

you can handle a little mathematics, and

you have not necessarily ever written a computer program (though it
doesn’t hurt to have programmed).
Some books about computer algorithms are conceptual, with little
technical detail. Some are chock full of technical precision. Some are
in between. Each type of book has its place. I’d place this book in the
in-between category. Yes, it has some math, and it gets rather precise in
some places, but I’ve avoided getting deep into details (except perhaps
toward the end of the book, where I just couldn’t control myself).
I think of this book as a bit like an antipasto. Suppose you go to
an Italian restaurant and order an antipasto, holding off on deciding
whether to order the rest of the meal until you’ve had the antipasto.
It arrives, and you eat it. Maybe you don’t like the antipasto, and you
decide to not order anything else. Maybe you like it, but it ﬁlls you up,
www.allitebooks.com

x
Preface
so that you don’t need to order anything else. Or maybe you like the
antipasto, it does not ﬁll you up, and you’re looking forward to the rest
of the meal. Thinking of this book as the antipasto, I’m hoping for one
of the latter two outcomes: either you read this book, you’re satisﬁed,
and you feel no need to delve deeper into the world of algorithms; or
you like what you read here so much that you want to learn more. Each
chapter ends with a section titled “Further reading,” which will guide
you to books and articles that go deeper into the topics.
What will you learn from this book?
I can’t tell you what you will learn from this book. Here’s what I intend
for you to learn from this book:

What computer algorithms are, one way to describe them, and how
to evaluate them.

Simple ways to search for information in a computer.

Methods to rearrange information in a computer so that it’s in a pre-
scribed order. (We call this task “sorting.”)

How to solve basic problems that we can model in a computer with
a mathematical structure known as a “graph.” Among many applica-
tions, graphs are great for modeling road networks (which intersec-
tions have direct roads to which other intersections, and how long are
these roads?), dependencies among tasks (which task must precede
which other tasks?), ﬁnancial relationships (what are the exchange
rates among all world currencies?), or interactions among people
(who knows whom? who hates whom? which actor appeared in a
movie with which other actor?).

How to solve problems that ask questions about strings of textual
characters. Some of these problems have applications in areas such
as biology, where the characters represent base molecules and the
strings of characters represent DNA structure.

The basic principles behind cryptography. Even if you have never
encrypted a message yourself, your computer probably has (such as
when you purchase goods online).

Fundamental ideas of data compression, going well beyond “f u cn
rd ths u cn gt a gd jb n gd pay.”

Preface
xi

That some problems are hard to solve on a computer in any reason-
able amount of time, or at least that nobody has ever ﬁgured out how
to do so.
What do you already need to know to understand the material in
this book?
As I said earlier, there’s some math in this book. If math scares you,
then you can try skipping over it, or you can try a less technical book.
But I’ve done my best to make the math accessible.
I don’t assume that you’ve ever written or even read a computer pro-
gram. If you can follow instructions in outline format, you should be
able to understand how I express the steps that, together, form an al-
gorithm. If you get the following joke, you’re already part of the way
there:
Did you hear about the computer scientist who got stuck in the
shower? He1 was washing his hair and following the instructions
on the shampoo bottle. They read “Lather. Rinse. Repeat.”
I’ve used a fairly informal writing style in this book, hoping that a
personal approach will help make the material accessible. Some chap-
ters depend on material in previous chapters, but such dependencies are
few. Some chapters start off in a nontechnical manner and become pro-
gressively more technical. Even if you ﬁnd that you’re getting in over
your head in one chapter, you can probably beneﬁt from reading at least
the beginning of the next chapter.
Reporting errors
If you ﬁnd an error in this book, please let me know about it by sending
email to unlocked@mit.edu.
Acknowledgments
Much of the material in this book draws from Introduction to Algo-
rithms, and so I owe a great deal to my coauthors on that book, Charles
Leiserson, Ron Rivest, and Cliff Stein. You’ll ﬁnd that throughout this
1Or she. Given the unfortunate gender ratio in computer science, chances are it was he.

xii
Preface
book, I shamelessly refer to (read: plug) Introduction to Algorithms,
known far and wide by the initials CLRS of the four authors. Writing
this book on my own makes me realize how much I miss collaborat-
ing with Charles, Ron, and Cliff. I also transitively thank everyone we
thanked in the preface of CLRS.
I also drew on material from courses that I’ve taught at Dartmouth,
especially Computer Science 1, 5, and 25. Thanks to my students for
letting me know, by their insightful questions, which pedagogical ap-
proaches worked and, by their stony silence, which did not.
This book came to be at the suggestion of Ada Brunstein, who was
our editor at the MIT Press when we prepared the third edition of CLRS.
Ada has since moved on, and Jim DeWolf took her place. Originally,
this book was slated to be part of the MIT Press “Essential Knowledge”
series, but the MIT Press deemed it too technical for the series. (Imagine
that—I wrote a book too technical for MIT!) Jim handled this poten-
tially awkward situation smoothly, allowing me to write the book that
I wanted to write rather than the book that the MIT Press originally
thought I was writing. I also appreciate the support of Ellen Faran and
Gita Devi Manaktala of the MIT Press.
Julie Sussman, P.P.A., was our technical copyeditor for the second
and third editions of CLRS, and I am once again thrilled to have her
copyedit this book. Best. Technical. Copyeditor. Ever. She let me get
away with nothing. Here’s evidence, in the form of part of an email that
Julie sent me about an early draft of Chapter 5:
Dear Mr. Cormen,
Authorities have apprehended an escaped chapter, which has
been found hiding in your book. We are unable to determine
what book it has escaped from, but we cannot imagine how it
could have been lodging in your book for these many months
without your knowledge, so we have no option but to hold you
responsible. We hope that you will take on the task of reforming
this chapter and will give it an opportunity to become a produc-
tive citizen of your book. A report from the arresting ofﬁcer,
Julie Sussman, is appended.
In case you’re wondering what “P.P.A.” stands for, the ﬁrst two letters
are for “Professional Pain.” You can probably guess what the “A” stands
for, but I want to point out that Julie takes pride in this title, and rightly
so. Thanks a googol, Julie!

Preface
xiii
I am no cryptographer, and the chapter on principles of cryptogra-
phy beneﬁted tremendously from comments and suggestions by Ron
Rivest, Sean Smith, Rachel Miller, and Huijia Rachel Lin. That chapter
has a footnote on baseball signs, and I thank Bob Whalen, the base-
ball coach at Dartmouth, for patiently explaining to me some of the
signing systems in baseball. Ilana Arbisser veriﬁed that computational
biologists align DNA sequences in the way that I explain in Chapter 7.
Jim DeWolf and I went through several iterations of titles for this book,
but it was an undergraduate student at Dartmouth, Chander Ramesh,
who came up with Algorithms Unlocked.
The Dartmouth College Department of Computer Science is an awe-
some place to work. My colleagues are brilliant and collegial, and our
professional staff is second to none. If you’re looking for a computer
science program at the undergraduate or graduate level, or if you seek a
faculty position in computer science, I encourage you to apply to Dart-
mouth.
Finally, I thank my wife, Nicole Cormen; my parents, Renee and
Perry Cormen; my sister, Jane Maslin; and Nicole’s parents, Colette
and Paul Sage, for their love and support. My father is sure that the
ﬁgure on page 2 is a 5, not an S.
TOM CORMEN
Hanover, New Hampshire
November 2012


1
What Are Algorithms and Why
Should You Care?
Let’s start with the question that I’m often asked: “What is an algo-
rithm?”1
A broad answer would be “a set of steps to accomplish a task.” You
have algorithms that you run in your everyday life. You have an al-
gorithm to brush your teeth: open the toothpaste tube, pick up your
toothbrush, squeeze toothpaste onto the brush until you have applied
enough to the brush, close the tube, put the brush into one quadrant of
your mouth, move the brush up and down for N seconds, etc. If you
have to commute to a job, you have an algorithm for your commute.
And so on.
But this book is about algorithms that run on computers or, more
generally, computational devices. Just as algorithms that you run af-
fect your everyday life, so do algorithms that run on computers. Do
you use your GPS to ﬁnd a route to travel? It runs what we call a
“shortest-path” algorithm to ﬁnd the route. Do you buy products on
the Internet? Then you use (or should be using) a secure website that
runs an encryption algorithm. When you buy products on the Internet,
are they delivered by a private delivery service? It uses algorithms to
assign packages to individual trucks and then to determine the order in
which each driver should deliver packages. Algorithms run on comput-
ers all over the place—on your laptop, on servers, on your smartphone,
on embedded systems (such as in your car, your microwave oven, or
climate-control systems)—everywhere!
What distinguishes an algorithm that runs on a computer from an
algorithm that you run? You might be able to tolerate it when an algo-
rithm is imprecisely described, but a computer cannot. For example, if
you drive to work, your drive-to-work algorithm might say “if trafﬁc is
bad, take an alternate route.” Although you might know what you mean
by “bad trafﬁc,” a computer does not.
So a computer algorithm is a set of steps to accomplish a task that
is described precisely enough that a computer can run it. If you have
1Or, as a fellow with whom I used to play hockey would ask, “What’s a nalgorithm?”

2
Chapter 1: What Are Algorithms and Why Should You Care?
done even a little computer programming in Java, C, C++, Python, For-
tran, Matlab, or the like, then you have some idea of what that level of
precision means. If you have never written a computer program, then
perhaps you will get a feel for that level of precision from seeing how I
describe algorithms in this book.
Let’s go to the next question: “What do we want from a computer algo-
rithm?”
Computer algorithms solve computational problems. We want two
things from a computer algorithm: given an input to a problem, it should
always produce a correct solution to the problem, and it should use com-
putational resources efﬁciently while doing so. Let’s examine these two
desiderata in turn.
Correctness
What does it mean to produce a correct solution to a problem? We can
usually specify precisely what a correct solution would entail. For ex-
ample, if your GPS produces a correct solution to ﬁnding the best route
to travel, it might be the route, out of all possible routes from where
you are to your desired destination, that will get you there soonest. Or
perhaps the route that has the shortest possible distance. Or the route
that will get you there soonest but also avoids tolls. Of course, the in-
formation that your GPS uses to determine a route might not match re-
ality. Unless your GPS can access real-time trafﬁc information, it might
assume that the time to traverse a road equals the road’s distance di-
vided by the road’s speed limit. If the road is congested, however, the
GPS might give you bad advice if you’re looking for the fastest route.
We can still say that the routing algorithm that the GPS runs is correct,
however, even if the input to the algorithm is not; for the input given to
the routing algorithm, the algorithm produces the fastest route.
Now, for some problems, it might be difﬁcult or even impossible to
say whether an algorithm produces a correct solution. Take optical char-
acter recognition for example. Is this 11  6 pixel image a 5 or an S?
Some people might call it a 5, whereas others might call it an S, so how
could we declare that a computer’s decision is either correct or incor-

Chapter 1: What Are Algorithms and Why Should You Care?
3
rect? We won’t. In this book, we will focus on computer algorithms
that have knowable solutions.
Sometimes, however, we can accept that a computer algorithm might
produce an incorrect answer, as long as we can control how often
it does so.
Encryption provides a good example.
The commonly
used RSA cryptosystem relies on determining whether large num-
bers—really large, as in hundreds of digits long—are prime. If you
have ever written a computer program, you could probably write one
that determines whether a number n is prime. It would test all candidate
divisors from 2 through n  1, and if any of these candidates is indeed
a divisor of n, then n is composite. If no number between 2 and n  1
is a divisor of n, then n is prime. But if n is hundreds of digits long,
that’s a lot of candidate divisors, more than even a really fast computer
could check in any reasonable amount of time. Of course, you could
make some optimizations, such as eliminating all even candidates once
you ﬁnd that 2 is not a divisor, or stopping once you get to pn (since if
d is greater than pn and d is a divisor of n, then n=d is less than pn
and is also a divisor of n; therefore, if n has a divisor, you will ﬁnd
it by the time you get to pn). If n is hundreds of digits long, then
although pn has only about half as many digits as n does, it’s still a
really large number. The good news is that we know of an algorithm
that tests quickly whether a number is prime. The bad news is that it
can make errors. In particular, if it declares that n is composite, then
n is deﬁnitely composite, but if it declares that n is prime, then there’s
a chance that n is actually composite. But the bad news is not all that
bad: we can control the error rate to be really low, such as one error in
every 250 times. That’s rare enough—one error in about every million
billion times—for most of us to be comfortable with using this method
to determine whether a number is prime for RSA.
Correctness is a tricky issue with another class of algorithms, called
approximation algorithms.
Approximation algorithms apply to opti-
mization problems, in which we want to ﬁnd the best solution according
to some quantitative measure. Finding the fastest route, as a GPS does,
is one example, where the quantitative measure is travel time. For some
problems, we have no algorithm that ﬁnds an optimal solution in any
reasonable amount of time, but we know of an approximation algorithm
that, in a reasonable amount of time, can ﬁnd a solution that is almost
optimal. By “almost optimal,” we typically mean that the quantitative
measure of the solution found by the approximation algorithm is within

4
Chapter 1: What Are Algorithms and Why Should You Care?
some known factor of the optimal solution’s quantitative measure. As
long as we specify what the desired factor is, we can say that a correct
solution from an approximation algorithm is any solution that is within
that factor of the optimal solution.
Resource usage
What does it mean for an algorithm to use computational resources ef-
ﬁciently? We alluded to one measure of efﬁciency in the discussion
of approximation algorithms: time. An algorithm that gives a correct
solution but takes a long time to produce that correct solution might
be of little or no value. If your GPS took an hour to determine which
driving route it recommends, would you even bother to turn it on? In-
deed, time is the primary measure of efﬁciency that we use to evalu-
ate an algorithm, once we have shown that the algorithm gives a cor-
rect solution. But it is not the only measure. We might be concerned
with how much computer memory the algorithm requires (its “memory
footprint”), since an algorithm has to run within the available memory.
Other possible resources that an algorithm might use: network commu-
nication, random bits (because algorithms that make random choices
need a source of random numbers), or disk operations (for algorithms
that are designed to work with disk-resident data).
In this book, as in most of the algorithms literature, we will focus
on just one resource: time. How do we judge the time required by an
algorithm? Unlike correctness, which does not depend on the particular
computer that the algorithm runs on, the actual running time of an al-
gorithm depends on several factors extrinsic to the algorithm itself: the
speed of the computer, the programming language in which the algo-
rithm is implemented, the compiler or interpreter that translates the pro-
gram into code that runs on the computer, the skill of the programmer
who writes the program, and other activity taking place on the computer
concurrently with the running program. And that all assumes that the
algorithm runs on just one computer with all its data in memory.
If we were to evaluate the speed of an algorithm by implementing it in
a real programming language, running it on a particular computer with
a given input, and measuring the time the algorithm takes, we would
know nothing about how fast the algorithm ran on an input of a different
size, or possibly even on a different input of the same size. And if we
wanted to compare the relative speed of the algorithm with some other
algorithm for the same problem, we would have to implement them both

Chapter 1: What Are Algorithms and Why Should You Care?
5
and run both of them on various inputs of various sizes. How, then, can
we evaluate an algorithm’s speed?
The answer is that we do so by a combination of two ideas. First,
we determine how long the algorithm takes as a function of the size
of its input. In our route-ﬁnding example, the input would be some
representation of a roadmap, and its size would depend on the number
of intersections and the number of roads connecting intersections in the
map. (The physical size of the road network would not matter, since we
can characterize all distances by numbers and all numbers occupy the
same size in the input; the length of a road has no bearing on the input
size.) In a simpler example, searching a given list of items to determine
whether a particular item is present in the list, the size of the input would
be the number of items in the list.
Second, we focus on how fast the function that characterizes the run-
ning time grows with the input size—the rate of growth of the running
time. In Chapter 2, we’ll see the notations that we use to characterize
an algorithm’s running time, but what’s most interesting about our ap-
proach is that we look at only the dominant term in the running time,
and we don’t consider coefﬁcients. That is, we focus on the order of
growth of the running time. For example, suppose we could determine
that a speciﬁc implementation of a particular algorithm to search a list
of n items takes 50n C 125 machine cycles. The 50n term dominates
the 125 term once n gets large enough, starting at n  3 and increas-
ing in dominance for even larger list sizes. Thus, we don’t consider
the low-order term 125 when we describe the running time of this hy-
pothetical algorithm. What might surprise you is that we also drop the
coefﬁcient 50, thereby characterizing the running time as growing lin-
early with the input size n. As another example, if an algorithm took
20n3 C 100n2 C 300n C 200 machine cycles, we would say that its
running time grows as n3. Again, the low-order terms—100n2, 300n,
and 200—become less and less signiﬁcant as the input size n increases.
In practice, the coefﬁcients that we ignore do matter. But they de-
pend so heavily on the extrinsic factors that it’s entirely possible that if
we were comparing two algorithms, A and B, that have the same order
of growth and are run on the same input, then A might run faster than B
with a particular combination of machine, programming language, com-
piler/interpreter, and programmer, while B runs faster than A with some
other combination. Of course, if algorithms A and B both produce cor-
rect solutions and A always runs twice as fast as B, then, all other things
www.allitebooks.com

6
Chapter 1: What Are Algorithms and Why Should You Care?
being equal, we prefer to always run A instead of B. From the point of
view of comparing algorithms in the abstract, however, we focus on the
order of growth, unadorned by coefﬁcients or low-order terms.
The ﬁnal question that we ask in this chapter: “Why should I care about
computer algorithms?” The answer to this question depends on who
you are.
Computer algorithms for non-computer people
Even if you don’t consider yourself a computer insider, computer algo-
rithms matter to you. After all, unless you’re on a wilderness expedition
without a GPS, you probably use them every day. Did you search for
something on the Internet today? The search engine you used—whether
it was Google, Bing, or any other search engine—employed sophis-
ticated algorithms to search the Web and to decide in which order to
present its results. Did you drive your car today? Unless you’re driving
a classic vehicle, its on-board computers made millions of decisions, all
based on algorithms, during your trip. I could go on and on.
As an end user of algorithms, you owe it to yourself to learn a little bit
about how we design, characterize, and evaluate algorithms. I assume
that you have at least a mild interest, since you have picked up this book
and read this far. Good for you! Let’s see if we can get you up to speed
so that you can hold your own at your next cocktail party in which the
subject of algorithms comes up.2
Computer algorithms for computer people
If you’re a computer person, then you had better care about computer
algorithms! Not only are they at the heart of, well, everything that goes
on inside your computer, but algorithms are just as much a technology
as everything else that goes on inside your computer. You can pay a
premium for a computer with the latest and greatest processor, but you
2Yes, I realize that unless you live in Silicon Valley, the subject of algorithms rarely
comes up at cocktail parties that you attend, but for some reason, we computer science
professors think it important that our students not embarrass us at cocktail parties with
their lack of knowledge in particular areas of computer science.

Chapter 1: What Are Algorithms and Why Should You Care?
7
need to run implementations of good algorithms on that computer in
order for your money to be well spent.
Here’s an example that illustrates how algorithms are indeed a tech-
nology. In Chapter 3, we are going to see a few different algorithms
that sort a list of n values into ascending order. Some of these algo-
rithms will have running times that grow like n2, but some will have
running times that grow like only n lg n. What is lg n? It is the base-2
logarithm of n, or log2 n. Computer scientists use base-2 logarithms
so frequently that just like mathematicians and scientists who use the
shorthand ln n for the natural logarithm—loge n—computer scientists
use their own shorthand for base-2 logarithms. Now, because the func-
tion lg n is the inverse of an exponential function, it grows very slowly
with n. If n D 2x, then x D lg n. For example, 210 D 1024, and there-
fore lg 1024 is only 10; similarly 220 D 1,048,576 and so lg 1,048,576
is only 20; and 230 D 1,073,741,824 means that lg 1,073,741,824 is
only 30. So a growth of n lg n vs. n2 trades a factor of n for a factor of
only lg n, and that’s a deal you should take any day.
Let’s make this example more concrete by pitting a faster computer
(computer A) running a sorting algorithm whose running time on n val-
ues grows like n2 against a slower computer (computer B) running a
sorting algorithm whose running time grows like n lg n.
They each
must sort an array of 10 million numbers. (Although 10 million num-
bers might seem like a lot, if the numbers are eight-byte integers, then
the input occupies about 80 megabytes, which ﬁts in the memory of
even an inexpensive laptop computer many times over.) Suppose that
computer A executes 10 billion instructions per second (faster than any
single sequential computer at the time of this writing) and computer B
executes only 10 million instructions per second, so that computer A is
1000 times faster than computer B in raw computing power. To make
the difference even more dramatic, suppose that the world’s craftiest
programmer codes in machine language for computer A, and the result-
ing code requires 2n2 instructions to sort n numbers. Suppose further
that just an average programmer writes for computer B, using a high-
level language with an inefﬁcient compiler, with the resulting code tak-
ing 50n lg n instructions. To sort 10 million numbers, computer A takes
2  .107/2 instructions
1010 instructions/second D 20,000 seconds ;
which is more than 5.5 hours, while computer B takes

8
Chapter 1: What Are Algorithms and Why Should You Care?
50  107 lg 107 instructions
107 instructions/second
 1163 seconds ;
which is under 20 minutes. By using an algorithm whose running time
grows more slowly, even with a poor compiler, computer B runs more
than 17 times faster than computer A! The advantage of the n lg n al-
gorithm is even more pronounced when we sort 100 million numbers:
where the n2 algorithm on computer A takes more than 23 days, the
n lg n algorithm on computer B takes under four hours. In general, as
the problem size increases, so does the relative advantage of the n lg n
algorithm.
Even with the impressive advances we continually see in computer
hardware, total system performance depends on choosing efﬁcient al-
gorithms as much as on choosing fast hardware or efﬁcient operating
systems. Just as rapid advances are being made in other computer tech-
nologies, they are being made in algorithms as well.
Further reading
In my highly biased opinion, the clearest and most useful source on
computer algorithms is Introduction to Algorithms [CLRS09] by four
devilishly handsome fellows. The book is commonly called “CLRS,”
after the initials of the authors. I’ve drawn on it for much of the mate-
rial in this book. It’s far more complete than this book, but it assumes
that you’ve done at least a little computer programming, and it pulls no
punches on the math. If you ﬁnd that you’re comfortable with the level
of mathematics in this book, and you’re ready to go deeper into the sub-
ject, then you can’t do better than CLRS. (In my humble opinion, of
course.)
John MacCormick’s book Nine Algorithms That Changed the Future
[Mac12] describes several algorithms and related aspects of computing
that affect our everyday lives. MacCormick’s treatment is less technical
than this book. If you ﬁnd that my approach in this book is too math-
ematical, then I recommend that you try reading MacCormick’s book.
You should be able to follow much of it even if you have a meager
mathematical background.
In the unlikely event that you ﬁnd CLRS too watered down, you can
try Donald Knuth’s multi-volume set The Art of Computer Program-
ming [Knu97, Knu98a, Knu98b, Knu11]. Although the title of the series
makes it sound like it might focus on details of writing code, these books

Chapter 1: What Are Algorithms and Why Should You Care?
9
contain brilliant, in-depth analyses of algorithms. Be warned, however:
the material in TAOCP is intense. By the way, if you’re wondering
where the word “algorithm” comes from, Knuth says that it derives from
the name “al-Khowˆarizmˆı,” a ninth-century Persian mathematician.
In addition to CLRS, several other excellent texts on computer al-
gorithms have been published over the years. The chapter notes for
Chapter 1 of CLRS list many such texts. Rather than replicate that list
here, I refer you to CLRS.

2
How to Describe and Evaluate
Computer Algorithms
In the previous chapter, you got a taste of how we couch the running
time of a computer algorithm: by focusing on the running time as a
function of the input size, and speciﬁcally on the order of growth of the
running time. In this chapter, we’ll back up a bit and see how we de-
scribe computer algorithms. Then we’ll see the notations that we use to
characterize the running times of algorithms. We’ll wrap up this chap-
ter by examining some techniques that we use to design and understand
algorithms.
How to describe computer algorithms
We always have the option of describing a computer algorithm as a
runnable program in a commonly used programming language, such as
Java, C, C++, Python, or Fortran. Indeed, several algorithms textbooks
do just that. The problem with using real programming languages to
specify algorithms is that you can get bogged down in the details of the
language, obscuring the ideas behind the algorithms. Another approach,
which we took in Introduction to Algorithms, uses “pseudocode,” which
looks like a mashup of various programming languages with English
mixed in. If you’ve ever used a real programming language, you can
ﬁgure out pseudocode easily. But if you have not ever programmed,
then pseudocode might seem a bit mysterious.
The approach I’m taking in this book is that I’m not trying to de-
scribe algorithms to software or hardware, but to “wetware”: the gray
matter between your ears. I am also going to assume that you have
never written a computer program, and so I won’t express algorithms
using any real programming language or even pseudocode. Instead, I’ll
describe them in English, using analogies to real-world scenarios when-
ever I can. In order to indicate what happens when (what we call “ﬂow
of control” in programming), I’ll use lists and lists within lists. If you
want to implement an algorithm in a real programming language, I’ll
give you credit for being able to translate my description into runnable
code.

Chapter 2: How to Describe and Evaluate Computer Algorithms
11
Although I will try to keep descriptions as nontechnical as possi-
ble, this book is about algorithms for computers, and so I will have to
use computing terminology. For example, computer programs contain
procedures (also known as functions or methods in real programming
languages), which specify how to do something. In order to actually
get the procedure to do what it’s supposed to do, we call it. When
we call a procedure, we supply it with inputs (usually at least one, but
some procedures take no inputs). We specify the inputs as parameters
within parentheses after the name of the procedure. For example, to
compute the square root of a number, we might deﬁne a procedure
SQUARE-ROOT.x/; here, the input to the procedure is referred to by
the parameter x. The call of a procedure may or may not produce out-
put, depending on how we speciﬁed the procedure. If the procedure
produces output, we usually consider the output to be something passed
back to its caller. In computing parlance we say that the procedure
returns a value.
Many programs and algorithms work with arrays of data. An array
aggregates data of the same type into one entity. You can think of an
array as being like a table, where given the index of an entry, we can
talk about the array element at that index. For example, here is a table
of the ﬁrst ﬁve U.S. presidents:
Index
President
1
George Washington
2
John Adams
3
Thomas Jefferson
4
James Madison
5
James Monroe
For example, the element at index 4 in this table is James Madison. We
think of this table not as ﬁve separate entities, but as one table with ﬁve
entries. An array is similar. The indices into an array are consecutive
numbers that can start anywhere, but we will usually start them at 1.1
Given the name of an array and an index into the array, we combine
them with square brackets to indicate a particular array element. For
example, we denote the ith element of an array A by AŒi.
1If you program in Java, C, or C++, you are used to arrays that start at 0. Starting arrays
at 0 is nice for computers, but for wetware it’s often more intuitive to start at 1.

12
Chapter 2: How to Describe and Evaluate Computer Algorithms
Arrays in computers have one other important characteristic: it takes
equally long to access any element of an array. Once you give the com-
puter an index i into an array, it can access the ith element as quickly
as it can access the ﬁrst element, regardless of the value of i.
Let’s see our ﬁrst algorithm: searching an array for a particular value.
That is, we are given an array, and we want to know which entry in
the array, if any, holds a given value. To see how we can search an
array, let’s think of the array as a long bookshelf full of books, and
suppose that you want to know where on the shelf you can ﬁnd a book by
Jonathan Swift. Now, the books on the shelf might be organized in some
way, perhaps alphabetically by author, alphabetically by title, or, in a
library, by call number. Or perhaps the bookshelf is like my bookshelf
at home, where I have not organized my books in any particular way.
If you couldn’t assume that the books were organized on the shelf,
how would you ﬁnd a book by Jonathan Swift? Here’s the algorithm I
would follow. I would start at the left end of the shelf and look at the
leftmost book. If it’s by Swift, I have located the book. Otherwise, I
would look at the next book to the right, and if that book is by Swift, I
have located the book. If not, I would keep going to the right, examining
book after book, until either I ﬁnd a book by Swift or I run off the right-
hand end of the shelf, in which case I can conclude that the bookshelf
does not contain any book by Jonathan Swift. (In Chapter 3, we’ll see
how to search for a book when the books are organized on the shelf.)
Here is how we can describe this searching problem in terms of com-
puting. Let’s think of the books on the bookshelf as an array of books.
The leftmost book is in position 1, the next book to its right is in posi-
tion 2, and so on. If we have n books on the shelf, then the rightmost
book is in position n. We want to ﬁnd the position number on the shelf
of any book by Jonathan Swift.
As a general computing problem, we are given an array A (the en-
tire shelf full of books to search through) of n elements (the individual
books), and we want to ﬁnd whether a value x (a book by Jonathan
Swift) is present in the array A. If it is, then we want to determine an in-
dex i such that AŒi D x (the ith position on the shelf contains a book by
Jonathan Swift). We also need some way to indicate that array A does
not contain x (the bookshelf contains no books by Jonathan Swift). We
do not assume that x appears at most once in the array (perhaps you
have multiple copies of some book), and so if x is present in array A,
it may appear multiple times. All we want from a searching algorithm

Chapter 2: How to Describe and Evaluate Computer Algorithms
13
is any index at which we’ll ﬁnd x in the array. We’ll assume that the
indices of this array start at 1, so that its elements are AŒ1 through AŒn.
If we search for a book by Jonathan Swift by starting at the left end of
the shelf, checking book by book as we move to the right, we call that
technique linear search. In terms of an array in a computer, we start
at the beginning of the array, examine each array element in turn (AŒ1,
then AŒ2, then AŒ3, and so on, up through AŒn) and record where we
ﬁnd x, if we ﬁnd it at all.
The following procedure, LINEAR-SEARCH, takes three parameters,
which we separate by commas in the speciﬁcation.
Procedure LINEAR-SEARCH.A; n; x/
Inputs:

A: an array.

n: the number of elements in A to search through.

x: the value being searched for.
Output: Either an index i for which AŒi D x, or the special value
NOT-FOUND, which could be any invalid index into the array, such as
0 or any negative integer.
1. Set answer to NOT-FOUND.
2. For each index i, going from 1 to n, in order:
A. If AŒi D x, then set answer to the value of i.
3. Return the value of answer as the output.
In addition to the parameters A, n, and x, the LINEAR-SEARCH pro-
cedure uses a variable named answer. The procedure assigns an initial
value of NOT-FOUND to answer in step 1. Step 2 checks each array en-
try AŒ1 through AŒn to see if the entry contains the value x. Whenever
entry AŒi equals x, step 2A assigns the current value of i to answer.
If x appears in the array, then the output value returned in step 3 is the
last index in which x appeared. If x does not appear in the array, then
the equality test in step 2A never evaluates to true, and the output value
returned is NOT-FOUND, as assigned to answer back in step 1.
Before we continue discussing linear search, a word about how to
specify repeated actions, such as in step 2. It is quite common in al-
gorithms to perform some action for a variable taking values in some
range. When we perform repeated actions, we call that a loop, and we
call each time through the loop an iteration of the loop. For the loop of

14
Chapter 2: How to Describe and Evaluate Computer Algorithms
step 2, I wrote “For each index i, going from 1 to n, in order.” Instead,
from now on, I’ll write “For i D 1 to n,” which is shorter, yet conveys
the same structure. Notice that when I write a loop in this way, we have
to give the loop variable (here, i) an initial value (here, 1), and in each
iteration of the loop, we have to test the current value of the loop vari-
able against a limit (here, n). If the current value of the loop variable is
less than or equal to the limit, then we do everything in the loop’s body
(here, step 2A). After an iteration executes the loop body, we increment
the loop variable—adding 1 to it—and go back and compare the loop
variable, now with its new value, with the limit. We repeatedly test the
loop variable against the limit, execute the loop body, and increment
the loop variable, until the loop variable exceeds the limit. Execution
then continues from the step immediately following the loop body (here,
step 3). A loop of the form “For i D 1 to n” performs n iterations and
n C 1 tests against the limit (because the loop variable exceeds the limit
in the .n C 1/st test).
I hope that you ﬁnd it obvious that the LINEAR-SEARCH procedure
always returns a correct answer. You might have noticed, however, that
this procedure is inefﬁcient: it continues to search the array even after
it has found an index i for which AŒi D x. Normally, you wouldn’t
continue searching for a book once you have found it on your bookshelf,
would you? Instead, we can design our linear search procedure to stop
searching once it ﬁnds the value x in the array. We assume that when
we say to return a value, the procedure immediately returns the value to
its caller, which then takes control.
Procedure BETTER-LINEAR-SEARCH.A; n; x/
Inputs and Output: Same as LINEAR-SEARCH.
1. For i D 1 to n:
A. If AŒi D x, then return the value of i as the output.
2. Return NOT-FOUND as the output.
Believe it or not, we can make linear search even more efﬁcient. Ob-
serve that each time through the loop of step 1, the BETTER-LINEAR-
SEARCH procedure makes two tests: a test in step 1 to determine
whether i  n (and if so, perform another iteration of the loop) and the
equality test in step 1A. In terms of searching a bookshelf, these tests
correspond to you having to check two things for each book: have you

Chapter 2: How to Describe and Evaluate Computer Algorithms
15
gone past the end of the shelf and, if not, is the next book by Jonathan
Swift? Of course, you don’t incur much of a penalty for going past the
end of the shelf (unless you keep your face really close to the books as
you examine them, there’s a wall at the end of the shelf, and you smack
your face into the wall), but in a computer program it’s usually very bad
to try to access array elements past the end of the array. Your program
could crash, or it could corrupt data.
You can make it so that you have to perform only one check for ev-
ery book you examine. What if you knew for sure that your bookshelf
contained a book by Jonathan Swift? Then you’d be assured of ﬁnding
it, and so you’d never have to check for running off the end of the shelf.
You could just check each book in turn to see whether it’s by Swift.
But perhaps you lent out all your books by Jonathan Swift, or maybe
you thought you had books by him but you never did, so you might not
be sure that your bookshelf contains any books by him. Here’s what
you can do. Take an empty box the size of a book and write on its
narrow side (where the spine of a book would be) “Gulliver’s Travels
by Jonathan Swift.” Replace the rightmost book with this box. Then, as
you search from left to right along the bookshelf, you need to check only
whether you’re looking at something that is by Swift; you can forget
about having to check whether you’re going past the end of the book-
shelf because you know that you’ll ﬁnd something by Swift. The only
question is whether you really found a book by Swift, or did you ﬁnd the
empty box that you had labeled as though it were by him? If you found
the empty box, then you didn’t really have a book by Swift. That’s easy
to check, however, and you need to do that only once, at the end of your
search, rather than once for every book on the shelf.
There’s one more detail you have to be aware of: what if the only
book by Jonathan Swift that you had on your bookshelf was the right-
most book? If you replace it by the empty box, your search will termi-
nate at the empty box, and you might conclude that you didn’t have the
book. So you have to perform one more check for that possibility, but
it’s just one check, rather than one check for every book on the shelf.
In terms of a computer algorithm, we’ll put the value x that we’re
searching for into the last position, AŒn, after saving the contents of
AŒn into another variable. Once we ﬁnd x, we test to see whether we
really found it. We call the value that we put into the array a sentinel,
but you can think of it as the empty box.
www.allitebooks.com

16
Chapter 2: How to Describe and Evaluate Computer Algorithms
Procedure SENTINEL-LINEAR-SEARCH.A; n; x/
Inputs and Output: Same as LINEAR-SEARCH.
1. Save AŒn into last and then put x into AŒn.
2. Set i to 1.
3. While AŒi ¤ x, do the following:
A. Increment i.
4. Restore AŒn from last.
5. If i < n or AŒn D x, then return the value of i as the output.
6. Otherwise, return NOT-FOUND as the output.
Step 3 is a loop, but not one that counts through some loop variable.
Instead, the loop iterates as long as a condition holds; here, the condition
is that AŒi ¤ x. The way to interpret such a loop is to perform the test
(here, AŒi ¤ x), and if the test is true, then do everything in the loop’s
body (here, step 3A, which increments i). Then go back and perform the
test, and if the test is true, execute the body. Keep going, performing the
test then executing the body, until the test comes up false. Then continue
from the next step after the loop body (here, continue from step 4).
The SENTINEL-LINEAR-SEARCH procedure is a bit more compli-
cated than the ﬁrst two linear search procedures. Because it places x
into AŒn in step 1, we are guaranteed that AŒi will equal x for some
test in step 3. Once that happens, we drop out of the step-3 loop, and
the index i won’t change thereafter. Before we do anything else, step 4
restores the original value in AŒn. (My mother taught me to put things
back when I was done with them.) Then we have to determine whether
we really found x in the array. Because we put x into the last element,
AŒn, we know that if we found x in AŒi where i < n, then we re-
ally did ﬁnd x and we want to return the index i. What if we found x
in AŒn? That means we didn’t ﬁnd x before AŒn, and so we need to
determine whether AŒn equals x. If it does, then we want to return the
index n, which equals i at this point, but if it does not, we want to return
NOT-FOUND. Step 5 does these tests and returns the correct index if x
was originally in the array. If x was found only because step 1 put it
into the array, then step 6 returns NOT-FOUND. Although SENTINEL-
LINEAR-SEARCH has to perform two tests after its loop terminates, it
performs only one test in each loop iteration, thereby making it more
efﬁcient than either LINEAR-SEARCH or BETTER-LINEAR-SEARCH.

Chapter 2: How to Describe and Evaluate Computer Algorithms
17
How to characterize running times
Let’s return to the LINEAR-SEARCH procedure from page 13 and under-
stand its running time. Recall that we want to characterize the running
time as a function of the input size. Here, our input is an array A of n
elements, along with the number n and the value x that we’re searching
for. The sizes of n and x are insigniﬁcant as the array gets large—after
all, n is just a single integer and x is only as large as one of the n ar-
ray elements—and so we’ll say that the input size is n, the number of
elements in A.
We have to make some simple assumptions about how long things
take. We will assume that each individual operation—whether it’s an
arithmetic operation (such as addition, subtraction, multiplication, or
division), a comparison, assigning to a variable, indexing into an array,
or calling or returning from a procedure—takes some ﬁxed amount of
time that is independent of the input size.2 The time might vary from
operation to operation, so that division might take longer than addition,
but when a step comprises just simple operations, each individual ex-
ecution of that step takes some constant amount of time. Because the
operations executed differ from step to step, and because of the extrinsic
factors listed back on page 4, the time to execute a step might vary from
step to step. Let’s say that each execution of step i takes ti time, where
ti is some constant that does not depend on n.
Of course, we have to take into account that some steps execute mul-
tiple times. Steps 1 and 3 execute just once, but what about step 2? We
have to test i against n a total of n C 1 times: n times in which i  n,
and once when i equals n C 1 so that we drop out of the loop. Step 2A
executes exactly n times, once for each value of i from 1 to n. We don’t
know in advance how many times we set answer to the value of i; it
could be anywhere from 0 times (if x is not present in the array) to n
times (if every value in the array equals x). If we’re going to be precise
in our accounting—and we won’t normally be this precise—we need to
2If you know a bit about actual computer architecture, you might know that the time
to access a given variable or array element is not necessarily ﬁxed, for it could depend
on whether the variable or array element is in the cache, in main memory, or out on
disk in a virtual-memory system. Some sophisticated models of computers take these
issues into account, but it’s often good enough to just assume that all variables and array
entries are in main memory and that they all take the same amount of time to access.

18
Chapter 2: How to Describe and Evaluate Computer Algorithms
recognize that step 2 does two different things that execute a different
number of times: the test of i against n happens n C 1 times, but in-
crementing i happens only n times. Let’s separate the time for line 2
into t0
2 for the test and t00
2 for incrementing. Similarly, we’ll separate
the time for step 2A into t0
2A for testing whether AŒi D x and t00
2A for
setting answer to i. Therefore, the running time of LINEAR-SEARCH is
somewhere between
t1 C t0
2  .n C 1/ C t00
2  n C t0
2A  n C t00
2A  0 C t3
and
t1 C t0
2  .n C 1/ C t00
2  n C t0
2A  n C t00
2A  n C t3 :
Now we rewrite these bounds, collecting terms that multiply by n to-
gether, and collecting the rest of the terms, and we see that the running
time is somewhere between the lower bound
.t0
2 C t00
2 C t0
2A/  n C .t1 C t0
2 C t3/
and the upper bound
.t0
2 C t00
2 C t0
2A C t00
2A/  n C .t1 C t0
2 C t3/ :
Notice that both of these bounds are of the form c nCd, where c and d
are constants that do not depend on n. That is, they are both linear
functions of n. The running time of LINEAR-SEARCH is bounded from
below by a linear function of n, and it is bounded from above by a linear
function of n.
We use a special notation to indicate that a running time is bounded
from above by some linear function of n and from below by some (pos-
sibly different) linear function of n. We write that the running time
is ‚.n/. That’s the Greek letter theta, and we say “theta of n” or just
“theta n.” As promised in Chapter 1, this notation discards the low-
order term (t1 C t0
2 C t3) and the coefﬁcients of n (t0
2 C t00
2 C t0
2A for the
lower bound and t0
2 C t00
2 C t0
2A C t00
2A for the upper bound). Although we
lose precision by characterizing the running time as ‚.n/, we gain the
advantages of highlighting the order of growth of the running time and
suppressing tedious detail.
This ‚-notation applies to functions in general, not just those that de-
scribe running times of algorithms, and it applies to functions other than
linear ones. The idea is that if we have two functions, f .n/ and g.n/,
we say that f .n/ is ‚.g.n// if f .n/ is within a constant factor of g.n/

Chapter 2: How to Describe and Evaluate Computer Algorithms
19
for sufﬁciently large n. So we can say that the running time of LINEAR-
SEARCH is within a constant factor of n once n gets large enough.
There’s an intimidating technical deﬁnition of ‚-notation, but for-
tunately we rarely have to resort to it in order to use ‚-notation. We
simply focus on the dominant term, dropping low-order terms and con-
stant factors. For example, the function n2=4 C 100n C 50 is ‚.n2/;
here we drop the low-order terms 100n and 50, and we drop the constant
factor 1=4. Although the low-order terms will dominate n2=4 for small
values of n, once n goes above 400, the n2=4 term exceeds 100n C 50.
When n D 1000, the dominant term n2=4 equals 250,000, while the
low-order terms 100n C 50 amount to only 100,050; for n D 2000 the
difference becomes 1,000,000 vs. 200,050. In the world of algorithms,
we abuse notation a little bit and write f .n/ D ‚.g.n//, so that we can
write n2=4 C 100n C 50 D ‚.n2/.
Now let’s look at the running time of BETTER-LINEAR-SEARCH
from page 14. This one is a little trickier than LINEAR-SEARCH be-
cause we don’t know in advance how many times the loop will iterate.
If AŒ1 equals x, then it will iterate just once. If x is not present in the
array, then the loop will iterate all n times, which is the maximum possi-
ble. Each loop iteration takes some constant amount of time, and so we
can say that in the worst case, BETTER-LINEAR-SEARCH takes ‚.n/
time to search an array of n elements. Why “worst case”? Because we
want algorithms to have low running times, the worst case occurs when
an algorithm takes the maximum time over any possible input.
In the best case, when AŒ1 equals x, BETTER-LINEAR-SEARCH
takes just a constant amount of time: it sets i to 1, checks that i  n, the
test AŒi D x comes up true, and the procedure returns the value of i,
which is 1. This amount of time does not depend on n. We write that
the best-case running time of BETTER-LINEAR-SEARCH is ‚.1/, be-
cause in the best case, its running time is within a constant factor of 1.
In other words, the best-case running time is a constant that does not
depend on n.
So we see that we cannot use ‚-notation for a blanket statement that
covers all cases of the running time of BETTER-LINEAR-SEARCH. We
cannot say that the running time is always ‚.n/, because in the best
case it’s ‚.1/. And we cannot say that the running time is always ‚.1/,
because in the worst case it’s ‚.n/. We can say that a linear function
of n is an upper bound in all cases, however, and we have a notation for
that: O.n/. When we speak this notation, we say “big-oh of n” or just

20
Chapter 2: How to Describe and Evaluate Computer Algorithms
“oh of n.” A function f .n/ is O.g.n// if, once n becomes sufﬁciently
large, f .n/ is bounded from above by some constant times g.n/. Again,
we abuse notation a little and write f .n/ D O.g.n//. For BETTER-
LINEAR-SEARCH, we can make the blanket statement that its running
time in all cases is O.n/; although the running time might be better than
a linear function of n, it’s never worse.
We use O-notation to indicate that a running time is never worse
than a constant times some function of n, but how about indicating
that a running time is never better than a constant times some func-
tion of n? That’s a lower bound, and we use -notation, which mirrors
O-notation: a function f .n/ is .g.n// if, once n becomes sufﬁciently
large, f .n/ is bounded from below by some constant times g.n/. We
say that “f .n/ is big-omega of g.n/” or just “f .n/ is omega of g.n/,”
and we can write f .n/ D .g.n//. Since O-notation gives an upper
bound, -notation gives a lower bound, and ‚-notation gives both up-
per and lower bounds, we can conclude that a function f .n/ is ‚.g.n//
if and only if f .n/ is both O.g.n// and .g.n//.
We can make a blanket statement about a lower bound for the running
time of BETTER-LINEAR-SEARCH: in all cases it’s .1/. Of course,
that’s a pathetically weak statement, since we’d expect any algorithm on
any input to take at least constant time. We won’t use -notation much,
but it will occasionally come in handy.
The catch-all term for ‚-notation, O-notation, and -notation is
asymptotic notation. That’s because these notations capture the growth
of a function as its argument asymptotically approaches inﬁnity. All
of these asymptotic notations give us the luxury of dropping low-order
terms and constant factors so that we can ignore tedious details and fo-
cus on what’s important: how the function grows with n.
Now let’s turn to SENTINEL-LINEAR-SEARCH from page 16. Just
like BETTER-LINEAR-SEARCH, each iteration of its loop takes a con-
stant amount of time, and there may be anywhere from 1 to n itera-
tions. The key difference between SENTINEL-LINEAR-SEARCH and
BETTER-LINEAR-SEARCH is that the time per iteration of SENTINEL-
LINEAR-SEARCH is less than the time per iteration of BETTER-
LINEAR-SEARCH. Both take a linear amount of time in the worst case,
but the constant factor for SENTINEL-LINEAR-SEARCH is better. Al-
though we’d expect SENTINEL-LINEAR-SEARCH to be faster in prac-
tice, it would be by only a constant factor. When we express the running
times of BETTER-LINEAR-SEARCH and SENTINEL-LINEAR-SEARCH

Chapter 2: How to Describe and Evaluate Computer Algorithms
21
using asymptotic notation, they are equivalent: ‚.n/ in the worst case,
‚.1/ in the best case, and O.n/ in all cases.
Loop invariants
For our three ﬂavors of linear search, it was easy to see that each one
gives a correct answer. Sometimes it’s a bit harder. There’s a wide range
of techniques, more than I can cover here.
One common method of showing correctness uses a loop invariant:
an assertion that we demonstrate to be true each time we start a loop
iteration. For a loop invariant to help us argue correctness, we have to
show three things about it:
Initialization: It is true before the ﬁrst iteration of the loop.
Maintenance: If it is true before an iteration of the loop, it remains true
before the next iteration.
Termination: The loop terminates, and when it does, the loop invari-
ant, along with the reason that the loop terminated, gives us a useful
property.
As an example, here’s a loop invariant for BETTER-LINEAR-SEARCH:
At the start of each iteration of step 1, if x is present in the ar-
ray A, then it is present in the subarray (a contiguous portion of
an array) from AŒi through AŒn.
We don’t even need this loop invariant to show that if the procedure
returns an index other than NOT-FOUND, then the index returned is cor-
rect: the only way that the procedure can return an index i in step 1A
is because x equals AŒi. Instead, we will use this loop invariant to
show that if the procedure returns NOT-FOUND in step 2, then x is not
anywhere in the array:
Initialization: Initially, i D 1 so that the subarray in the loop invariant
is AŒ1 through AŒn, which is the entire array.
Maintenance: Assume that at the start of an iteration for a value of i,
if x is present in the array A, then it is present in the subarray from
AŒi through AŒn. If we get through this iteration without returning,
we know what AŒi ¤ x, and therefore we can safely say that if x is
present in the array A, then it is present in the subarray from AŒi C1
through AŒn. Because i is incremented before the next iteration, the
loop invariant will hold before the next iteration.

22
Chapter 2: How to Describe and Evaluate Computer Algorithms
Termination: This loop must terminate, either because the procedure
returns in step 1A or because i > n. We have already handled
the case where the loop terminates because the procedure returns
in step 1A.
To handle the case where the loop terminates because i > n, we rely
on the contrapositive of the loop invariant. The contrapositive of the
statement “if A then B” is “if not B then not A.” The contrapositive
of a statement is true if and only if the statement is true. The con-
trapositive of the loop invariant is “if x is not present in the subarray
from AŒi through AŒn, then it is not present in the array A.”
Now, when i > n, the subarray from AŒi through AŒn is empty,
and so this subarray cannot hold x. By the contrapositive of the loop
invariant, therefore, x is not present anywhere in the array A, and so
it is appropriate to return NOT-FOUND in step 2.
Wow, that’s a lot of reasoning for what’s really just a simple loop!
Do we have to go through all that every time we write a loop? I don’t,
but there are a few computer scientists who insist on such rigorous rea-
soning for every single loop. When I’m writing real code, I ﬁnd that
most of the time that I write a loop, I have a loop invariant somewhere
in the back of my mind. It might be so far back in my mind that I don’t
even realize that I have it, but I could state it if I had to. Although most
of us would agree that a loop invariant is overkill for understanding the
simple loop in BETTER-LINEAR-SEARCH, loop invariants can be quite
handy when we want to understand why more complex loops do the
right thing.
Recursion
With the technique of recursion, we solve a problem by solving smaller
instances of the same problem. Here’s my favorite canonical example
of recursion: computing nŠ (“n-factorial”), which is deﬁned for nonneg-
ative values of n as nŠ D 1 if n D 0, and
nŠ D n  .n  1/  .n  2/  .n  3/    3  2  1
if n  1. For example, 5Š D 5  4  3  2  1 D 120. Observe that
.n  1/Š D .n  1/  .n  2/  .n  3/    3  2  1 ;
and so

Chapter 2: How to Describe and Evaluate Computer Algorithms
23
nŠ D n  .n  1/Š
for n  1. We have deﬁned nŠ in terms of a “smaller” problem, namely
.n1/Š. We could write a recursive procedure to compute nŠ as follows:
Procedure FACTORIAL.n/
Input: An integer n  0.
Output: The value of nŠ.
1. If n D 0, then return 1 as the output.
2. Otherwise, return n times the value returned by recursively calling
FACTORIAL.n  1/.
The way I wrote step 2 is pretty cumbersome. I could instead just write
“Otherwise, return n  FACTORIAL.n  1/,” using the recursive call’s
return value within a larger arithmetic expression.
For recursion to work, two properties must hold. First, there must
be one or more base cases, where we compute the solution directly
without recursion. Second, each recursive call of the procedure must be
on a smaller instance of the same problem that will eventually reach a
base case. For the FACTORIAL procedure, the base case occurs when
n equals 0, and each recursive call is on an instance in which the value
of n is reduced by 1. As long as the original value of n is nonnegative,
the recursive calls will eventually get down to the base case.
Arguing that a recursive algorithm works might feel overly simple at
ﬁrst. The key is to believe that each recursive call produces the correct
result. As long as we are willing to believe that recursive calls do the
right thing, arguing correctness is often easy. Here is how we could ar-
gue that the FACTORIAL procedure returns the correct answer. Clearly,
when n D 0, the value returned, 1, equals nŠ. We assume that when
n  1, the recursive call FACTORIAL.n  1/ does the right thing: it
returns the value of .n  1/Š. The procedure then multiplies this value
by n, thereby computing the value of nŠ, which it returns.
Here’s an example where the recursive calls are not on smaller in-
stances of the same problem, even though the mathematics is correct.
It is indeed true that if n  0, then nŠ D .n C 1/Š=.n C 1/. But the
following recursive procedure, which takes advantage of this formula,
would fail to ever give an answer when n  1:

24
Chapter 2: How to Describe and Evaluate Computer Algorithms
Procedure BAD-FACTORIAL.n/
Input and Output: Same as FACTORIAL.
1. If n D 0, then return 1 as the output.
2. Otherwise, return BAD-FACTORIAL.n C 1/=.n C 1/.
If we were to call BAD-FACTORIAL.1/, it would generate a recursive
call of BAD-FACTORIAL.2/, which would generate a recursive call of
BAD-FACTORIAL.3/, and so on, never getting down to the base case
when n equals 0. If you were to implement this procedure in a real
programming language and run it on an actual computer, you would
quickly see something like a “stack overﬂow error.”
We can often rewrite algorithms that use a loop in a recursive style.
Here is linear search, without a sentinel, written recursively:
Procedure RECURSIVE-LINEAR-SEARCH.A; n; i; x/
Inputs: Same as LINEAR-SEARCH, but with an added parameter i.
Output: The index of an element equaling x in the subarray from AŒi
through AŒn, or NOT-FOUND if x does not appear in this subarray.
1. If i > n, then return NOT-FOUND.
2. Otherwise (i  n), if AŒi D x, then return i.
3. Otherwise (i  n and AŒi ¤ x), return
RECURSIVE-LINEAR-SEARCH.A; n; i C 1; x/.
Here, the subproblem is to search for x in the subarray going from AŒi
through AŒn. The base case occurs in step 1 when this subarray is
empty, that is, when i > n. Because the value of i increases in each of
step 3’s recursive calls, if no recursive call ever returns a value of i in
step 2, then eventually i becomes greater than n and we reach the base
case.
Further reading
Chapters 2 and 3 of CLRS [CLRS09] cover much of the material in
this chapter. An early algorithms textbook by Aho, Hopcroft, and Ull-
man [AHU74] inﬂuenced the ﬁeld to use asymptotic notation to analyze
algorithms. There has been quite a bit of work in proving programs cor-
rect; if you would like to delve into this area, try the books by Gries
[Gri81] and Mitchell [Mit96].

3
Algorithms for Sorting and
Searching
In Chapter 2, we saw three variations on linear search of an array. Can
we do any better? The answer: it depends. If we know nothing about the
order of the elements in the array, then no, we cannot do better. In the
worst case, we have to look through all n elements because if we don’t
ﬁnd the value we’re looking for in the ﬁrst n  1 elements, it might be
in that last, nth, element. Therefore, we cannot achieve a better worst-
case running time than ‚.n/ if we know nothing about the order of the
elements in the array.
Suppose, however, that the array is sorted into nondecreasing order:
each element is less than or equal to its successor in the array, according
to some deﬁnition of “less than.” In this chapter, we shall see that if
an array is sorted, then we can use a simple technique known as binary
search to search an n-element array in only O.lg n/ time. As we saw in
Chapter 1, the value of lg n grows very slowly compared with n, and so
binary search beats linear search in the worst case.1
What does it mean for one element to be less than another? When the
elements are numbers, it’s obvious. When the elements are strings of
text characters, we can think of a lexicographic ordering: one element
is less than another if it would come before the other element in a dic-
tionary. When elements are some other form of data, then we have to
deﬁne what “less than” means. As long as we have some clear notion
of “less than,” we can determine whether an array is sorted.
Recalling the example of books on a bookshelf from Chapter 2, we
could sort the books alphabetically by author, alphabetically by title, or,
if in a library, by call number. In this chapter, we’ll say that the books
are sorted on the shelf if they appear in alphabetical order by author,
reading from left to right. The bookshelf might contain more than one
book by the same author, however; perhaps you have several works by
William Shakespeare. If we want to search for not just any book by
1If you are a non-computer person who skipped the section “Computer algorithms for
computer people” in Chapter 1, you ought to read the material about logarithms on
page 7.
www.allitebooks.com

26
Chapter 3: Algorithms for Sorting and Searching
Shakespeare, but a speciﬁc book by Shakespeare, then we would say
that if two books have the same author, then the one whose title is ﬁrst
alphabetically should go on the left. Alternatively, we could say that all
we care about is the author’s name, so that when we search, anything
by Shakespeare will do. We call the information that we are matching
on the key. In our bookshelf example, the key is just the author’s name,
rather than a combination based ﬁrst on the author’s name and then the
title in case of two works by the same author.
How, then, do we get the array to be sorted in the ﬁrst place? In this
chapter, we’ll see four algorithms—selection sort, insertion sort, merge
sort, and quicksort—to sort an array, applying each of these algorithms
to our bookshelf example. Each sorting algorithm will have its advan-
tages and its disadvantages, and at the end of the chapter we’ll review
and compare these sorting algorithms. All of the sorting algorithms that
we’ll see in this chapter take either ‚.n2/ or ‚.n lg n/ time in the worst
case. Therefore, if you were going to perform only a few searches,
you’d be better off just running linear search. But if you were going to
search many times, you might be better off ﬁrst sorting the array and
then searching by running binary search.
Sorting is an important problem in its own right, not just as a pre-
processing step for binary search. Think of all the data that must be
sorted, such as entries in a phone book, by name; checks in a monthly
bank statement, by check numbers and/or the dates that the checks were
processed by the bank; or even results from a Web-search engine, by rel-
evance to the query. Furthermore, sorting is often a step in some other
algorithm. For example, in computer graphics, objects are often layered
on top of each other. A program that renders objects on the screen might
have to sort the objects according to an “above” relation so that it can
draw these objects from bottom to top.
Before we proceed, a word about what it is that we sort. In addition
to the key (which we’ll call a sort key when we’re sorting), the ele-
ments that we sort usually include as well what we call satellite data.
Although satellite data could come from a satellite, it usually does not.
Satellite data is the information that is associated with the sort key and
should travel with it when elements are moved around. In our bookshelf
example, the sort key is the author’s name and the satellite data is the
book itself.
I explain satellite data to my students in a way that they are sure to
understand. I keep a spreadsheet with student grades, with rows sorted

Chapter 3: Algorithms for Sorting and Searching
27
alphabetically by student name. To determine ﬁnal course grades at the
end of the term, I sort the rows, with the sort key being the column
containing the percentage of points obtained in the course, and the rest
of the columns, including the student names, as the satellite data. I sort
into decreasing order by percentage, so that rows at the top correspond
to A’s and rows at the bottom to D’s and E’s.2 Suppose that I were
to rearrange only the column containing the percentages and not move
the entire row containing the percentage. That would leave the student
names in alphabetical order regardless of percentages. Then the students
whose names appear early in the alphabet would be happy while the
students with names at the end of the alphabet—not so much.
Here are some other examples of sort keys and satellite data. In a
phone book, the sort key would be the name and the satellite data would
be the address and phone number. In a bank statement, the sort key
would be the check number and the satellite data would include the
amount of the check and the date it cleared. In a search engine, the sort
key would be the measure of relevance to the query and the satellite data
would be the URL of the Web page, plus whatever other data the search
engine stores about the page.
When we work with arrays in this chapter, we will act as though each
element contains only a sort key. If you were implementing any of the
sorting algorithms here, you would have to make sure that you move the
satellite data associated with each element, or at least a pointer to the
satellite data, whenever you move the sort key.
In order for the bookshelf analogy to apply to arrays in a computer,
we need to assume that the bookshelf and its books have two additional
features, which I admit are not terribly realistic. First, all books on
the bookshelf are the same size, because in a computer array, all array
entries are the same size. Second, we can number the positions of the
books on the bookshelf from 1 to n, and we will call each position a
slot. Slot 1 is the leftmost slot, and slot n is the rightmost. As you have
probably guessed, each slot on the bookshelf corresponds to an array
entry.
I also want to address the word “sorting.” In common speech, sort-
ing can mean something different from how we use it in computing.
2Dartmouth uses E, not F, to indicate a failing grade. I don’t know why for sure, but
I would guess that it simpliﬁed the computer program that converts letter grades to
numeric grades on a 4.0 scale.

28
Chapter 3: Algorithms for Sorting and Searching
My Mac’s online dictionary deﬁnes “sort” by “arrange systematically in
groups; separate according to type, class, etc.”: the way that you might
“sort” clothing for example, with shirts in one place, pants in another
place, and so on. In the world of computer algorithms, sorting means
to put into some well-deﬁned order, and “arranging systematically in
groups” is called “bucketing,” “bucketizing,” or “binning.”
Binary search
Before we see some sorting algorithms, let’s visit binary search, which
requires the array being searched to be already sorted. Binary search
has the advantage that it takes only O.lg n/ time to search an n-element
array.
In our bookshelf example, we start with the books already sorted by
author name, left to right on the shelf. We’ll use the author name as the
key, and let’s search for any book by Jonathan Swift. Now, you might
ﬁgure that because the author’s last name starts with “S,” which is the
19th letter of the alphabet, you could go about three-quarters of the way
over on the shelf (since 19=26 is close to 3=4) and look in the slot there.
But if you have all of Shakespeare’s works, then you have several books
by an author whose last name comes before Swift, which could push
books by Swift farther to the right than you expected.
Instead, here’s how you could apply binary search to ﬁnding a book
by Jonathan Swift. Go to the slot exactly halfway over on the shelf, ﬁnd
the book there, and examine the author’s name. Let’s say that you’ve
found a book by Jack London. Not only is that not the book you’re
searching for, but because you know that the books are sorted alpha-
betically by author, you know that all books to the left of the book by
London can’t be what you’re searching for. By looking at just one book,
you have eliminated half of the books on the shelf from consideration!
Any books by Swift must be on the right-hand half of the shelf. So
now you ﬁnd the slot at the halfway point of just the right-hand half and
look at the book there. Suppose that it’s by Leo Tolstoy. Again, that’s
not the book you’re searching for, but you know that you can eliminate
all books to the right of this one: half of the books that remained as
possibilities. At this point, you know that if your bookshelf contains
any books by Swift, then they are in the quarter of the books that are to
the right of the book by London and to the left of the book by Tolstoy.
Next, you ﬁnd the book in the slot at the midpoint within this quarter
under consideration. If it’s by Swift, you are done. Otherwise, you can

Chapter 3: Algorithms for Sorting and Searching
29
again eliminate half of the remaining books. Eventually, you either ﬁnd
a book by Swift or you get to the point at which no slots remain as pos-
sibilities. In the latter case, you conclude that the bookshelf contains no
books by Jonathan Swift.
In a computer, we perform binary search on an array. At any point, we
are considering only a subarray, that is, the portion of the array between
and including two indices; let’s call them p and r. Initially, p D 1 and
r D n, so that the subarray starts out as the entire array. We repeatedly
halve the size of the subarray that we are considering until one of two
things happens: we either ﬁnd the value that we’re searching for or the
subarray is empty (that is, p becomes greater than r). The repeated
halving of the subarray size is what gives rise to the O.lg n/ running
time.
In a little more detail, here’s how binary search works. Let’s say that
we’re searching for the value x in array A. In each step, we are con-
sidering only the subarray starting at AŒp and ending at AŒr. Because
we will be working with subarrays quite a bit, let’s denote this subarray
by AŒp : : r. At each step, we compute the midpoint q of the subarray
under consideration by taking the average of p and r and then dropping
the fractional part, if any: q D b.p C r/=2c. (Here, we use the “ﬂoor”
operation, b c, to drop the fractional part. If you were implementing
this operation in a language such as Java, C, or C++, you could just use
integer division to drop the fractional part.) We check to see whether
AŒq equals x; if it does, we are done, because we can just return q as
an index where array A contains x.
If instead, we ﬁnd that AŒq ¤ x, then we take advantage of the
assumption that array A is already sorted. Since AŒq ¤ x, there are
two possibilities: either AŒq > x or AŒq < x. We ﬁrst handle the case
where AŒq > x. Because the array is sorted, we know that not only is
AŒq greater than x, but also—thinking of the array as laid out from left
to right—that every array element to the right of AŒq is greater than x.
Therefore, we can eliminate from consideration all elements at or to the
right of AŒq. We will start our next step with p unchanged, but with r
set to q  1:
A
p
q
r
q–1
⇓
…
…
>x >x >x >x >x >x
new r

30
Chapter 3: Algorithms for Sorting and Searching
If instead we ﬁnd that AŒq < x, we know that every array element at or
to the left of AŒq is less than x, and so we can eliminate these elements
from consideration. We will start our next step with r unchanged, but
with p set to q C 1:
A
p
q
r
q+1
⇓
…
…
<x
<x
<x
<x
<x
<x
new p
Here is the exact procedure for binary search:
Procedure BINARY-SEARCH.A; n; x/
Inputs and Output: Same as LINEAR-SEARCH.
1. Set p to 1, and set r to n.
2. While p  r, do the following:
A. Set q to b.p C r/=2c.
B. If AŒq D x, then return q.
C. Otherwise (AŒq ¤ x), if AŒq > x, then set r to q  1.
D. Otherwise (AŒq < x), set p to q C 1.
3. Return NOT-FOUND.
The loop in step 2 does not necessarily terminate because p becomes
greater than r. It can terminate in step 2B because it ﬁnds that AŒq
equals x and returns q as an index in A where x occurs.
In order to show that the BINARY-SEARCH procedure works cor-
rectly, we just need to show that x is not present anywhere in the array if
BINARY-SEARCH returns NOT-FOUND in step 3. We use the following
loop invariant:
At the start of each iteration of the loop of step 2, if x is anywhere
in the array A, then it is somewhere in the subarray AŒp : : r.
And a brief argument using the loop invariant:
Initialization: Step 1 initializes the indices p and r to 1 and n, re-
spectively, and so the loop invariant is true when the procedure ﬁrst
enters the loop.
Maintenance: We argued above that steps 2C and 2D adjust either p
or r correctly.

Chapter 3: Algorithms for Sorting and Searching
31
Termination: If x is not in the array, then eventually the procedure gets
to the point where p and r are equal. When that happens, step 2A
computes q to be the same as p and r. If step 2C sets r to q  1,
then at the start of the next iteration, r will equal p  1, so that p
will be greater than r. If step 2D sets p to q C 1, then at the start
of the next iteration, p will equal r C 1, and again p will be greater
than r. Either way, the loop test in step 2 will come up false, and
the loop will terminate. Because p > r, the subarray AŒp : : r will
be empty, and so the value x cannot be present in it. Taking the
contrapositive of the loop invariant (see page 22) gives us that if x is
not present in the subarray AŒp : : r, then it is not present anywhere
in array A. Therefore, the procedure is correct in returning NOT-
FOUND in step 3.
We can also write binary search as a recursive procedure:
Procedure RECURSIVE-BINARY-SEARCH.A; p; r; x/
Inputs and Output: Inputs A and x are the same as LINEAR-SEARCH,
as is the output. The inputs p and r delineate the subarray AŒp : : r
under consideration.
1. If p > r, then return NOT-FOUND.
2. Otherwise (p  r), do the following:
A. Set q to b.p C r/=2c.
B. If AŒq D x, then return q.
C. Otherwise (AŒq ¤ x), if AŒq > x, then return
RECURSIVE-BINARY-SEARCH.A; p; q  1; x/.
D. Otherwise (AŒq < x), return
RECURSIVE-BINARY-SEARCH.A; q C 1; r; x/.
The initial call is RECURSIVE-BINARY-SEARCH.A; 1; n; x/.
Now let’s see how it is that binary search takes O.lg n/ time on an
n-element array. The key observation is that the size r  p C 1 of the
subarray under consideration is approximately halved in each iteration
of the loop (or in each recursive call of the recursive version, but let’s
focus on the iterative version in BINARY-SEARCH). If you try all the
cases, you’ll ﬁnd that if an iteration starts with a subarray of s elements,
the next iteration will have either bs=2c or s=2  1 elements, depending
on whether s is even or odd and whether AŒq is greater than or less
than x. We have already seen that once the subarray size gets down to 1,

32
Chapter 3: Algorithms for Sorting and Searching
the procedure will ﬁnish by the next iteration. So we can ask, how many
iterations of the loop do we need to repeatedly halve a subarray from its
original size n down to a size of 1? That would be the same as the
number of times that, starting with a subarray of size 1, we would need
to double its size to reach a size of n. But that’s just exponentiation:
repeatedly multiplying by 2. In other words, for what value of x does
2x reach n? If n were an exact power of 2, then we’ve already seen
on page 7 that the answer is lg n. Of course, n might not be an exact
power of 2, in which case the answer will be within 1 of lg n. Finally,
we note that each iteration of the loop takes a constant amount of time,
that is, the time for a single iteration does not depend on the size n of the
original array or on the size of the subarray under consideration. Let’s
use asymptotic notation to suppress the constant factors and low-order
term. (Is the number of loop iterations lg n or blg nc C 1? Who cares?)
We get that the running time of binary search is O.lg n/.
I used O-notation here because I wanted to make a blanket statement
that covers all cases. In the worst case, when the value x is not present
in the array, we halved and halved and halved until the subarray under
consideration was empty, yielding a running time of ‚.lg n/. In the best
case, when x is found in the ﬁrst iteration of the loop, the running time
is ‚.1/. No ‚-notation covers all cases, but a running time of O.lg n/ is
always correct for binary search—as long as the array is already sorted.
It is possible to beat ‚.lg n/ worst-case time for searching, but only if
we organize data in more elaborate ways and make certain assumptions
about the keys.
Selection sort
We now turn our attention to sorting: rearranging the elements of the
array—also known as permuting the array—so that each element is less
than or equal to its successor. The ﬁrst sorting algorithm we’ll see,
selection sort, is the one I consider the simplest, because it’s the one I
came up with when I ﬁrst needed to design a sorting algorithm. It is far
from the fastest.
Here is how selection sort would work for sorting books on a book-
shelf according to author names. Go through the entire shelf and ﬁnd
the book whose author’s name comes earliest in the alphabet. Let’s say
that it’s by Louisa May Alcott. (If the shelf contains two or more books
by this author, choose any one of them.) Swap the location of this book
with the book in slot 1. The book in slot 1 is now a book by an author

Chapter 3: Algorithms for Sorting and Searching
33
whose name comes ﬁrst alphabetically. Now go through the bookshelf,
left to right, starting with the book in slot 2 to ﬁnd the book in slots 2
through n whose author name comes earliest in the alphabet. Suppose
that it’s by Jane Austen. Swap the location of this book with the book
in slot 2, so that now slots 1 and 2 have the ﬁrst and second books in the
overall alphabetical ordering. Then do the same for slot 3, and so on.
Once we have put the correct book into slot n  1 (perhaps it’s by H. G.
Wells), we are done, because there’s only one book left (say, a book by
Oscar Wilde), and it’s in slot n where it belongs.
To turn this approach into a computer algorithm, change the book-
shelf to an array and the books to array elements. Here’s the result:
Procedure SELECTION-SORT.A; n/
Inputs:

A: an array.

n: the number of elements in A to sort.
Result: The elements of A are sorted into nondecreasing order.
1. For i D 1 to n  1:
A. Set smallest to the index of the smallest element in the
subarray AŒi : : n.
B. Swap AŒi with AŒsmallest.
Finding the smallest element in AŒi : : n is a variant on linear search.
First declare AŒi to be the smallest element seen in the subarray so far,
and then go through the rest of the subarray, updating the index of the
smallest element every time we ﬁnd an element less than the current
smallest. Here’s the reﬁned procedure:
Procedure SELECTION-SORT.A; n/
Inputs and Result: Same as before.
1. For i D 1 to n  1:
A. Set smallest to i.
B. For j D i C 1 to n:
i. If AŒj  < AŒsmallest, then set smallest to j .
C. Swap AŒi with AŒsmallest.

34
Chapter 3: Algorithms for Sorting and Searching
This procedure has “nested” loops, with the loop of step 1B nested
within the loop of step 1. The inner loop performs all of its iterations
for each individual iteration of the outer loop. Notice that the starting
value of j in the inner loop depends on the current value of i in the
outer loop. This illustration shows how selection sort works on an array
of six elements:
1
2
3
4
5
6
7
9
3
14 11
1
2
3
4
5
6
1
2
3
4
5
6
1
2
3
4
5
6
1
2
3
4
5
6
A
A
A
A
A
12
3
9 12
14 11
7
3
11
12
14
7
9
3
9
11
14
7
12
3
9 11 14
7
12
1
2
3
4
5
6
A
3
9 11
14
7
12
The initial array appears in the upper left, and each step shows the array
after an iteration of the outer loop. The darker shaded elements hold the
subarray that is known to be sorted.
If you wanted to use a loop invariant to argue that the SELECTION-
SORT procedure sorts the array correctly, you would need one for each
of the loops. This procedure is simple enough that we won’t go through
the full loop-invariant arguments, but here are the loop invariants:
At the start of each iteration of the loop of step 1, the subarray
AŒ1 : : i1 holds the i1 smallest elements of the entire array A,
and they are in sorted order.
At the start of each iteration of the loop of step 1B, AŒsmallest
is the smallest element in the subarray AŒi : : j  1.
What is the running time of SELECTION-SORT? We’ll show that it is
‚.n2/. The key is to analyze how many iterations the inner loop makes,
noting that each iteration takes ‚.1/ time. (Here, the constant factors in
the lower and upper bounds in the ‚-notation may differ, because the
assignment to smallest may or may not occur in a given iteration.) Let’s
count the number of iterations, based on the value of the loop variable i
in the outer loop. When i equals 1, the inner loop iterates for j running
from 2 to n, or n  1 times. When i equals 2, the inner loop iterates
for j running from 3 to n, or n  2 times. Each time the outer loop
increments i, the inner loop runs one time less. In general, the inner
loop runs n  i times. In the last iteration of the outer loop, when i
equals n  1, the inner loop iterates just one time. Therefore, the total
number of inner-loop iterations is
.n  1/ C .n  2/ C .n  3/ C    C 2 C 1 :

Chapter 3: Algorithms for Sorting and Searching
35
This summation is known as an arithmetic series, and here’s a basic fact
about arithmetic series: for any nonnegative integer k,
k C .k  1/ C .k  2/ C    C 2 C 1 D k.k C 1/
2
:
Substituting n  1 for k, we see that the total number of inner-loop iter-
ations is .n1/n=2, or .n2 n/=2. Let’s use asymptotic notation to get
rid of the low-order term (n) and the constant factor (1=2). Then we
can say that the total number of inner-loop iterations is ‚.n2/. There-
fore, the running time of SELECTION-SORT is ‚.n2/. Notice that this
running time is a blanket statement that covers all cases. Regardless of
the actual element values, the inner loop runs ‚.n2/ times.
Here’s another way to see that the running time is ‚.n2/, without us-
ing the arithmetic series. We’ll show separately that the running time is
both O.n2/ and .n2/; putting the asymptotic upper and lower bounds
together gives us ‚.n2/. To see that the running time is O.n2/, observe
that each iteration of the outer loop runs the inner loop at most n  1
times, which is O.n/ because each iteration of the inner loop takes a
constant amount of time. Since the outer loop iterates n1 times, which
is also O.n/, the total time spent in the inner loop is O.n/ times O.n/,
or O.n2/. To see that the running time is .n2/, observe that in each of
the ﬁrst n=2 iterations of the outer loop, we run the inner loop at least
n=2 times, for a total of at least n=2 times n=2, or n2=4 times. Since
each inner-loop iteration takes a constant amount of time, we see that
the running time is at least a constant times n2=4, or .n2/.
Two ﬁnal thoughts about selection sort. First, we’ll see that its asymp-
totic running time of ‚.n2/ is the worst of the sorting algorithms that
we’ll examine. Second, if you carefully examine how selection sort op-
erates, you’ll see that the ‚.n2/ running time comes from the compar-
isons in step 1Bi. But the number of times that it moves array elements
is only ‚.n/, because step 1C runs only n1 times. If moving array el-
ements is particularly time-consuming—perhaps because they are large
or stored on a slow device such as a disk—then selection sort might be
a reasonable algorithm to use.
Insertion sort
Insertion sort differs a bit from selection sort, though it has a similar
ﬂavor. In selection sort, when we decided which book to put into the ith
slot, the books in the ﬁrst i slots were the ﬁrst i books overall, sorted
www.allitebooks.com

36
Chapter 3: Algorithms for Sorting and Searching
alphabetically by author name. In insertion sort, the books in the ﬁrst i
slots will be the same books that were originally in the ﬁrst i slots, but
now sorted by author name.
For example, let’s suppose that the books in the ﬁrst four slots are
already sorted by author name, and that, in order, they are books by
Charles Dickens, Herman Melville, Jonathan Swift, and Leo Tolstoy.
Let’s say that the book that starts in slot 5 is by Sir Walter Scott. With
insertion sort, we shift the books by Swift and Tolstoy by one slot to the
right, moving them from slots 3 and 4 to slots 4 and 5, and then we put
the book by Scott into the vacated slot 3. At the time that we work with
the book by Scott, we don’t care what books are to its right (the books
by Jack London and Gustave Flaubert in the ﬁgure below); we deal with
them later on.
1
2
3
4
5
6
7
Charles Dickens
Oliver Twist
Herman Melville
Moby Dick
Jonathan Swift
Gulliver’s Travels
Leo Tolstoy
War and Peace
Sir Walter Scott
Ivanhoe
Jack London
White Fang
Gustave Flaubert
Madame Bovary
1
2
3
4
5
6
7
Charles Dickens
Oliver Twist
Herman Melville
Moby Dick
Sir Walter Scott
Ivanhoe
Jonathan Swift
Gulliver’s Travels
Leo Tolstoy
War and Peace
Jack London
White Fang
Gustave Flaubert
Madame Bovary
To shift the books by Swift and Tolstoy, we ﬁrst compare the author
name Tolstoy with Scott. Finding that Tolstoy comes after Scott, we
shift the book by Tolstoy one slot to the right, from slot 4 to slot 5.
Then we compare the author name Swift with Scott. Finding that Swift
comes after Scott, we shift the book by Swift one slot to the right, from
slot 3 to slot 4, which was vacated when we shifted the book by Tolstoy.
Next we compare the author name Herman Melville with Scott. This
time, we ﬁnd that Melville does not come after Scott. At this point, we
stop comparing author names, because we have found that the book by
Scott should be to the right of the book by Melville and to the left of
the book by Swift. We can put the book by Scott into slot 3, which was
vacated when we shifted the book by Swift.
To translate this idea to sorting an array with insertion sort, the sub-
array AŒ1 : : i  1 will hold only the elements originally in the ﬁrst
i  1 positions of the array, and they will be in sorted order. To deter-
mine where the element originally in AŒi goes, insertion sort marches

Chapter 3: Algorithms for Sorting and Searching
37
through AŒ1 : : i 1, starting at AŒi 1 and going toward the left, shift-
ing each element greater than this one by one position to the right. Once
we ﬁnd an element that is not greater than AŒi or we hit the left end of
the array, we drop the element originally in AŒi into its new position in
the array.
Procedure INSERTION-SORT.A; n/
Inputs and Result: Same as SELECTION-SORT.
1. For i D 2 to n:
A. Set key to AŒi, and set j to i  1.
B. While j > 0 and AŒj  > key, do the following:
i. Set AŒj C 1 to AŒj .
ii. Decrement j (i.e., set j to j  1).
C. Set AŒj C 1 to key.
The test in step 1B relies on the “and” operator being short circuiting:
if the expression on the left, j > 0, is false, then it does not evaluate
the expression on the right, AŒj  > key. If it did attempt to access AŒj 
when j  0, an array indexing error would occur.
Here is how insertion sort works on the same array as we saw on
page 34 for selection sort:
1
2
3
4
5
6
7
9
3
14 11
1
2
3
4
5
6
1
2
3
4
5
6
1
2
3
4
5
6
1
2
3
4
5
6
A
A
A
A
A
12
9 12 3
14 11
7
3
11
12
14
9
7
3
9
11
14
7
12
3
9
11
14
7
12
1
2
3
4
5
6
A
3
9 11
14
7
12
Once again, the initial array appears in the upper left, and each step
shows the array after an iteration of the outer loop of step 1. The darker
shaded elements hold the subarray that is known to be sorted. The loop
invariant for the outer loop (again, we won’t prove it) is the following:
At the start of each iteration of the loop of step 1, the subarray
AŒ1 : : i  1 consists of the elements originally in AŒ1 : : i  1,
but in sorted order.
The next illustration demonstrates how the inner loop of step 1B
works in the above example when i equals 4. We assume that the sub-
array AŒ1 : : 3 contains the elements originally in the ﬁrst three array

38
Chapter 3: Algorithms for Sorting and Searching
positions, but now they are sorted. To determine where to place the el-
ement originally in AŒ4, we save it in a variable named key, and then
shift each element in AŒ1 : : 3 that is greater than key by one position to
the right:
1
2
3
4
5
6
3
9 12 7 14
key = 7
1
2
3
4
5
6
3
9 12 12 14
1
2
3
4
5
6
3
9
9 12 14
1
2
3
4
5
6
3
7
9 12 14
A
A
A
A
11
11
11
11
The darker shaded positions show where elements move to. In the last
step shown, the value of AŒ1, 3, is not greater than the value of key, 7,
and so the inner loop terminates. The value of key drops into the position
just to the right of AŒ1, as the last step shows. Of course, we have to
save the value originally in AŒi into key in step 1A, because the ﬁrst
iteration of the inner loop overwrites AŒi.
It is also possible that the inner loop terminates because the test j > 0
comes up false. This situation occurs if key is less than all the elements
in AŒ1 : : i  1. When j becomes 0, each element in AŒ1 : : i  1 has
been shifted to the right, and so step 1C drops key into AŒ1, right where
we want it.
When we analyze the running time of INSERTION-SORT, it becomes
a bit trickier than SELECTION-SORT. The number of times that the
inner loop iterates in the SELECTION-SORT procedure depends only on
the index i of the outer loop and not at all on the elements themselves.
For the INSERTION-SORT procedure, however, the number of times that
the inner loop iterates depends on both the index i of the outer loop and
the values in the array elements.
The best case of INSERTION-SORT occurs when the inner loop makes
zero iterations every time. For that to happen, the test AŒj  > key must
come up false the ﬁrst time for each value of i. In other words, we
must have AŒi  1  AŒi every time that step 1B executes. How can
this situation occur? Only if the array A is already sorted when the
procedure starts. In this case, the outer loop iterates n  1 times, and
each iteration of the outer loop takes a constant amount of time, so that
INSERTION-SORT takes only ‚.n/ time.
The worst case occurs when the inner loop makes the maximum pos-
sible number of iterations every time. Now the test AŒj  > key must al-
ways come up true, and the loop must terminate because the test j > 0
comes up false. Each element AŒi must travel all the way to the left

Chapter 3: Algorithms for Sorting and Searching
39
of the array. How can this situation happen? Only if the array A starts
in reverse sorted order, that is, sorted into nonincreasing order. In this
case, for each time the outer loop iterates, the inner loop iterates i  1
times. Since the outer loop runs with i going from 2 up to n, the number
of inner-loop iterations forms an arithmetic series:
1 C 2 C 3 C    C .n  2/ C .n  1/ ;
which, as we saw for selection sort, is ‚.n2/. Since each inner-loop
iteration takes constant time, the worst-case running time of insertion
sort is ‚.n2/. In the worst case, therefore, selection sort and insertion
sort have running times that are asymptotically the same.
Would it make sense to try to understand what happens on average
with insertion sort? That depends on what an “average” input looks
like. If the ordering of elements in the input array were truly random, we
would expect each element to be larger than about half the elements pre-
ceding it and smaller than about half the elements preceding it, so that
each time the inner loop runs, it would make approximately .i  1/=2
iterations. That would cut the running time in half, compared with the
worst case. But 1=2 is just a constant factor, and so, asymptotically, it
would be no different from the worst-case running time: still ‚.n2/.
Insertion sort is an excellent choice when the array starts out as “al-
most sorted.” Suppose that each array element starts out within k po-
sitions of where it ends up in the sorted array. Then the total number
of times that a given element is shifted, over all iterations of the inner
loop, is at most k. Therefore, the total number of times that all elements
are shifted, over all inner-loop iterations, is at most kn, which in turn
tells us that the total number of inner-loop iterations is at most kn (since
each inner-loop iteration shifts exactly one element by one position). If
k is a constant, then the total running time of insertion sort would be
only ‚.n/, because the ‚-notation subsumes the constant factor k. In
fact, we can even tolerate some elements moving a long distance in the
array, as long as there are not too many such elements. In particular, if l
elements can move anywhere in the array (so that each of these elements
can move by up to n  1 positions), and the remaining n  l elements
can move at most k positions, then the total number of shifts is at most
l.n  1/ C .n  l/k D .k C l/n  .k C 1/l, which is ‚.n/ if both k
and l are constants.
If we compare the asymptotic running times of insertion sort and se-
lection sort, we see that in the worst case, they are the same. Inser-
tion sort is better if the array is almost sorted. Selection sort has one

40
Chapter 3: Algorithms for Sorting and Searching
advantage over insertion sort, however: selection sort moves elements
‚.n/ times no matter what, but insertion sort could move elements up
to ‚.n2/ times, since each execution of step 1Bi of INSERTION-SORT
moves an element. As we noted on page 35 for selection sort, if mov-
ing an element is particularly time-consuming and you have no reason
to expect that insertion sort’s input approaches the best-case situation,
then you might be better off running selection sort instead of insertion
sort.
Merge sort
Our next sorting algorithm, merge sort, has a running time of only
‚.n lg n/ in all cases. When we compare its running time with the
‚.n2/ worst-case running times of selection sort and insertion sort, we
are trading a factor of n for a factor of only lg n. As we noted on page 7
back in Chapter 1, that’s a trade you should take any day.
Merge sort does have a couple of disadvantages compared with the
other two sorting algorithms we have seen. First, the constant factor
that we hide in the asymptotic notation is higher than for the other two
algorithms. Of course, once the array size n gets large enough, that
doesn’t really matter. Second, merge sort does not work in place: it has
to make complete copies of the entire input array. Contrast this feature
with selection sort and insertion sort, which at any time keep an extra
copy of only one array entry rather than copies of all the array entries.
If space is at a premium, you might not want to use merge sort.
We employ a common algorithmic paradigm known as divide-and-
conquer in merge sort. In divide-and-conquer, we break the problem
into subproblems that are similar to the original problem, solve the sub-
problems recursively, and then combine the solutions to the subprob-
lems to solve the original problem. Recall from Chapter 2 that in order
for recursion to work, each recursive call must be on a smaller instance
of the same problem that will eventually hit a base case. Here’s a gen-
eral outline of a divide-and-conquer algorithm:
1. Divide the problem into a number of subproblems that are smaller
instances of the same problem.
2. Conquer the subproblems by solving them recursively. If they are
small enough, solve the subproblems as base cases.
3. Combine the solutions to the subproblems into the solution for the
original problem.

Chapter 3: Algorithms for Sorting and Searching
41
When we sort the books on our bookshelf with merge sort, each sub-
problem consists of sorting the books in consecutive slots on the shelf.
Initially, we want to sort all n books, in slots 1 through n, but in a gen-
eral subproblem, we will want to sort all the books in slots p through r.
Here’s how we apply divide-and-conquer:
1. Divide by ﬁnding the number q of the slot midway between p and r.
We do so in the same way that we found the midpoint in binary
search: add p and q, divide by 2, and take the ﬂoor.
2. Conquer by recursively sorting the books in each of the two sub-
problems created by the divide step: recursively sort the books that
are in slots p through q, and recursively sort the books that are in
slots q C 1 through r.
3. Combine by merging the sorted books that are in slots p through q
and slots q C 1 through r, so that all the books in slots p through r
are sorted. We’ll see how to merge books in a moment.
The base case occurs when fewer than two books need to be sorted (that
is, when p  r), since a set of books with no books or one book is
already trivially sorted.
To convert this idea to sorting an array, the books in slots p through r
correspond to the subarray AŒp : : r. Here is the merge sort proce-
dure, which calls a procedure MERGE.A; p; q; r/ to merge the sorted
subarrays AŒp : : q and AŒq C 1 : : r into the single sorted subarray
AŒp : : r:
Procedure MERGE-SORT.A; p; r/
Inputs:

A: an array.

p; r: starting and ending indices of a subarray of A.
Result: The elements of the subarray AŒp : : r are sorted into
nondecreasing order.
1. If p  r, then the subarray AŒp : : r has at most one element, and
so it is already sorted. Just return without doing anything.
2. Otherwise, do the following:
A. Set q to b.p C r/=2c.
B. Recursively call MERGE-SORT.A; p; q/.
C. Recursively call MERGE-SORT.A; q C 1; r/.
D. Call MERGE.A; p; q; r/.

42
Chapter 3: Algorithms for Sorting and Searching
Although we have yet to see how the MERGE procedure works, we can
look at an example of how the MERGE-SORT procedure operates. Let’s
start with this array:
12 9
3
7 14 11 6
2 10 5
1
2
3
4
5
6
7
8
9
10
The initial call is MERGE-SORT.A; 1; 10/. Step 2A computes q to be 5,
so that the recursive calls in steps 2B and 2C are MERGE-SORT.A; 1; 5/
and MERGE-SORT.A; 6; 10/:
12 9
3
7 14
11 6
2 10 5
1
2
3
4
5
6
7
8
9
10
After the two recursive calls return, these two subarrays are sorted:
12
9
3
7
14
11
6
2
10
5
1
2
3
4
5
6
7
8
9
10
Finally, the call MERGE.A; 1; 5; 10/ in step 2D merges the two sorted
subarrays into a single sorted subarray, which is the entire array in this
case:
12
9
3
7
14
11
6
2
10
5
1
2
3
4
5
6
7
8
9
10
If we unfold the recursion, we get the ﬁgure on the next page. Diverg-
ing arrows indicate divide steps, and converging arrows indicate merge
steps. The variables p, q, and r appearing above each subarray are
located at the indices to which they correspond in each recursive call.
The italicized numbers give the order in which the procedure calls oc-
cur after the initial call MERGE-SORT.A; 1; 10/. For example, the call
MERGE.A; 1; 3; 5/ is the 13th procedure call after the initial call, and
the call MERGE-SORT.A; 6; 7/ is the 16th call.
The real work happens in the MERGE procedure. Therefore, not only
must the MERGE procedure work correctly, but it must also be fast. If
we are merging a total of n elements, the best we can hope for is ‚.n/
time, since each element has to be merged into its proper place, and
indeed we can achieve linear-time merging.

Chapter 3: Algorithms for Sorting and Searching
43
12 9
3
7 14 11 6
2 10 5
1
2
3
4
5
6
7
8
9
10
12 9
3
7 14
11 6
2 10 5
1
2
3
4
5
6
7
8
9
10
p
q
r
p
q
r
p
q
r
12 9
3
7 14
11 6
2
10 5
1
2
3
4
5
6
7
8
9
10
p
q
r
p,q r
p
q
r
p,q r
12 9
3
7
14
11 6
2
10
5
1
2
3
4
5
6
7
8
9
10
12
9
11
6
1
2
6
7
p,q r
p,r
p,q r
p,r
p,r
p,r
p,r
p,r
p,r
p,r
p,r
p,r
12
9
11
6
1
2
6
7
p,q r
p,q r
12
9
3
7 14
11
6
2
10
5
1
2
3
4
5
6
7
8
9
10
p
q
r
p,q r
p
q
r
p,q r
12
9
3
7
14
11
6
2
10
5
1
2
3
4
5
6
7
8
9
10
p
q
r
p
q
r
3
2
1
2
3
4
5
6
7
8
9
10
p
q
r
5
7
9 10 11
6
12 14
divide
divide
divide
divide
merge
merge
merge
merge
1
2
3
4
5
6
9
7
8
10
11
12
13
14
15
16
17
18
19
22
20
21
23
24
25
26
27

44
Chapter 3: Algorithms for Sorting and Searching
Returning to our book example, let’s look at just the portion of the
bookshelf from slot 9 through slot 14. Suppose that we have sorted the
books in slots 9–11 and that we have sorted the books in slots 12–14:
9
10
11
12
13
14
sorted
sorted
Gustave Flaubert
Madame Bovary
Jonathan Swift
Gulliver’s Travels
Leo Tolstoy
War and Peace
Charles Dickens
Oliver Twist
Jack London
White Fang
Sir Walter Scott
Ivanhoe
We pull out the books in slots 9–11 and make a pile of them, with the
book whose author is alphabetically ﬁrst on top, and we do the same
with the books in slots 12–14, making a separate pile:
9
10
11
12
13
14
Leo Tolstoy
War and Peace
Gustave Flaubert
Madame Bovary
Jonathan Swift
Gulliver’s Travels
Jack London
White Fang
Sir Walter Scott
Ivanhoe
Charles Dickens
Oliver Twist
Because the two piles are already sorted, the book that should go back
into slot 9 must be one of the books atop its pile: either the book by
Gustave Flaubert or the book by Charles Dickens. Indeed, we see that
the book by Dickens comes before the book by Flaubert, and so we
move it into slot 9:
9
10
11
12
13
14
Leo Tolstoy
War and Peace
Gustave Flaubert
Madame Bovary
Jonathan Swift
Gulliver’s Travels
Jack London
White Fang
Sir Walter Scott
Ivanhoe
Charles Dickens
Oliver Twist
After we move the book by Dickens into slot 9, the book that should go
into slot 10 must be either the book still atop the ﬁrst pile, by Flaubert,
or the book now atop the second pile, by Jack London. We move the
Flaubert book into slot 10:

Chapter 3: Algorithms for Sorting and Searching
45
9
10
11
12
13
14
Leo Tolstoy
War and Peace
Jonathan Swift
Gulliver’s Travels
Jack London
White Fang
Sir Walter Scott
Ivanhoe
Charles Dickens
Oliver Twist
Gustave Flaubert
Madame Bovary
Next, we compare the books now atop their piles, which are by Jonathan
Swift and London, and we move the book by London into slot 11. That
leaves the book by Sir Walter Scott atop the right pile, and when we
compare it with the book by Swift, we move the book by Scott into
slot 12. At this point, the right pile is empty:
9
10
11
12
13
14
Leo Tolstoy
War and Peace
Jonathan Swift
Gulliver’s Travels
Charles Dickens
Oliver Twist
Gustave Flaubert
Madame Bovary
Jack London
White Fang
Sir Walter Scott
Ivanhoe
All that remains is to move the books in the left pile into the remaining
slots, in order. Now all books in slots 9–14 are sorted:
9
10
11
12
13
14
sorted
Charles Dickens
Oliver Twist
Gustave Flaubert
Madame Bovary
Jack London
White Fang
Sir Walter Scott
Ivanhoe
Jonathan Swift
Gulliver’s Travels
Leo Tolstoy
War and Peace
How efﬁcient is this merge procedure? We move each book exactly
twice: once to pull it off the shelf and put it into a pile, and once to move
it from the top of a pile back onto the shelf. Furthermore, whenever we
are deciding which book to put back onto the shelf, we need to compare
only two books: those atop their piles. To merge n books, therefore, we
move books 2n times and compare pairs of books at most n times.
Why pull the books off the shelf? What if we had left the books on
the shelf and just kept track of which books we had put into their correct
www.allitebooks.com

46
Chapter 3: Algorithms for Sorting and Searching
slots on the shelf and which books we hadn’t? That could turn out to be
a lot more work. For example, suppose that every book in the right half
should come before every book in the left half. Before we could move
the ﬁrst book from the right half into the ﬁrst slot of the left half, we
would have to shift every book that started in the left half to the right by
one slot in order to make room. And then we’d have to do the same to
put the next book that started in the right half into the second slot of the
left half. And the same for all the other books that started in the right
half. We would have to shift half the books—all the books that started
in the left half—each time we wanted to put a book that started in the
right half into its correct slot.
That argument explains why we do not merge in place.3 Returning to
how we merge the sorted subarrays AŒp : : q and AŒq C 1 : : r into the
subarray AŒp : : r, we start by copying the elements to be merged from
array A into temporary arrays and then merge them back into A. Let
n1 D q  p C 1 be the number of elements in AŒp : : q and n2 D r  q
be the number of elements in AŒq C 1 : : r. We create temporary arrays
B with n1 elements and C with n2 elements, and we copy the elements
in AŒp : : q, in order, into B, and likewise the elements in AŒq C 1 : : r,
in order, into C. Now we can merge these elements back into AŒp : : q
without fear of overwriting our only copies of them.
We merge the array elements the same way we merge books. We
copy elements from the arrays B and C back into the subarray AŒp : : r,
maintaining indices to keep track of the smallest element not yet copied
back in both B and C, and copying back the smaller of the two. In
constant time, we can determine which element is smaller, copy it back
into the correct position of AŒp : : r, and update indices into the arrays.
Eventually, one of the two arrays will have all its elements copied
back to AŒp : : r. This moment corresponds to the moment when only
one pile of books remains. But we use a trick to avoid having to check
each time whether one of the arrays has been exhausted: we place at the
right end of each of the arrays B and C an extra element that is greater
than any other element. Do you recall the sentinel trick that we used in
SENTINEL-LINEAR-SEARCH in Chapter 2? This idea is similar. Here,
we use 1 (inﬁnity) as the sentinel’s sort key, so that whenever an ele-
3Actually, it is possible to merge in place in linear time, but the procedure to do so is
pretty complicated.

Chapter 3: Algorithms for Sorting and Searching
47
ment with a sort key of 1 is the smallest remaining element in its array,
it is guaranteed to “lose” the contest to see which array has the smaller
remaining element.4 Once all elements from both arrays B and C have
been copied back, both arrays have their sentinels as their smallest re-
maining element. But there’s no need to compare the sentinels at this
point, because by then we have copied all the “real” elements (the non-
sentinels) back to AŒp : : r. Since we know in advance that we’ll be
copying elements back into AŒp through AŒr, we can stop once we
have copied an element back into AŒr. We can just run a loop with an
index into A running from p to r.
Here is the MERGE procedure. It looks long, but it just follows the
method above.
Procedure MERGE.A; p; q; r/
Inputs:

A: an array.

p; q; r: indices into A. Each of the subarrays AŒp : : q and
AŒq C 1 : : r is assumed to be already sorted.
Result: The subarray AŒp : : r contains the elements originally in
AŒp : : q and AŒq C 1 : : r, but now the entire subarray AŒp : : r is
sorted.
1. Set n1 to q  p C 1, and set n2 to r  q.
2. Let BŒ1 : : n1 C 1 and CŒ1 : : n2 C 1 be new arrays.
3. Copy AŒp : : q into BŒ1 : : n1, and copy AŒq C 1 : : r into
CŒ1 : : n2.
4. Set both BŒn1 C 1 and CŒn2 C 1 to 1.
5. Set both i and j to 1.
6. For k D p to r:
A. If BŒi  CŒj , then set AŒk to BŒi and increment i.
B. Otherwise (BŒi > CŒj ), set AŒk to CŒj  and increment j .
After steps 1–4 allocate the arrays B and C, copy AŒp : : q into B
and AŒq C 1 : : r into C, and insert the sentinels into these arrays, each
4In practice, we represent 1 by a value that compares as greater than any sort key. For
example, if the sort keys are author names, 1 could be ZZZZ—assuming, of course,
that no real author has that name.

48
Chapter 3: Algorithms for Sorting and Searching
iteration of the main loop in step 6 copies back the smallest remaining
element to the next position in AŒp : : r, terminating once it has copied
back all the elements in B and C. In this loop, i indexes the smallest
remaining element in B, j indexes the smallest remaining element in C,
and k indexes the location in A where the element will be copied back
into.
If we are merging n elements altogether (so that n D n1 C n2), it
takes ‚.n/ time to copy the elements into arrays B and C, and constant
time per element to copy it back into AŒp : : r, for a total merging time
of only ‚.n/.
We claimed earlier that the entire merge-sort algorithm takes time
‚.n lg n/.
We will make the simplifying assumption that the array
size n is a power of 2, so that every time we divide the array, the sub-
array sizes are equal. (In general, n might not be a power of 2 and so the
subarray sizes might not be equal in a given recursive call. A rigorous
analysis can take care of this technicality, but let’s not concern ourselves
with it.)
Here is how we analyze merge sort. Let’s say that sorting a sub-
array of n elements takes time T .n/, which is a function that increases
with n (since, presumably, it takes longer to sort more elements). The
time T .n/ comes from the three components of the divide-and-conquer
paradigm, whose times we add together:
1. Dividing takes constant time, because it amounts to just computing
the index q.
2. Conquering consists of the two recursive calls on subarrays, each
with n=2 elements. By how we deﬁned the time to sort a subarray,
each of the two recursive calls takes time T .n=2/.
3. Combining the results of the two recursive calls by merging the
sorted subarrays takes ‚.n/ time.
Because the constant time for dividing is a low-order term compared
with the ‚.n/ time for combining, we can absorb the dividing time into
the combining time and say that dividing and combining, together, take
‚.n/ time. The conquer step costs T .n=2/CT .n=2/, or 2T .n=2/. Now
we can write an equation for T .n/:
T .n/ D 2T .n=2/ C f .n/ ;
where f .n/ represents the time for dividing and combining which, as
we just noted, is ‚.n/. A common practice in the study of algorithms

Chapter 3: Algorithms for Sorting and Searching
49
is to just put the asymptotic notation right into the equation and let it
stand for some function that we don’t care to give a name to, and so we
rewrite this equation as
T .n/ D 2T .n=2/ C ‚.n/ :
Wait! There seems to be something amiss here. We have deﬁned
the function T that describes the running time of merge sort in terms of
the very same function! We call such an equation a recurrence equa-
tion, or just a recurrence. The problem is that we want to express T .n/
in a non-recursive manner, that is, not in terms of itself. It can be a
real pain in the neck to convert a function expressed as a recurrence
into non-recursive form, but for a broad class of recurrence equations
we can apply a cookbook method known as the “master method.” The
master method applies to many (but not all) recurrences of the form
T .n/ D aT .n=b/ C f .n/, where a and b are positive integer constants.
Fortunately, it applies to our merge-sort recurrence, and it gives the re-
sult that T .n/ is ‚.n lg n/.
This ‚.n lg n/ running time applies to all cases of merge sort—best
case, worst case, and all cases in between.
Each element is copied
‚.n lg n/ times. As you can see from examining the MERGE method,
when it is called with p D 1 and r D n, it makes copies of all n ele-
ments, and so merge sort deﬁnitely does not run in place.
Quicksort
Like merge sort, quicksort uses the divide-and-conquer paradigm (and
hence uses recursion). Quicksort uses divide-and-conquer in a slightly
different way than merge sort, however. It has a couple of other signiﬁ-
cant differences from merge sort:

Quicksort works in place.

Quicksort’s asymptotic running time differs between the worst case
and the average case. In particular, quicksort’s worst-case running
time is ‚.n2/, but its average-case running time is better: ‚.n lg n/.
Quicksort also has good constant factors (better than merge sort’s), and
it is often a good sorting algorithm to use in practice.
Here is how quicksort uses divide-and-conquer. Again let us think
about sorting books on a bookshelf. As with merge sort, we initially
want to sort all n books in slots 1 through n, and we’ll consider the
general problem of sorting books in slots p through r.

50
Chapter 3: Algorithms for Sorting and Searching
1. Divide by ﬁrst choosing any one book that is in slots p through r.
Call this book the pivot. Rearrange the books on the shelf so that all
other books with author names that come before the pivot’s author
or are written by the same author are to the left of the pivot, and all
books with author names that come after the pivot’s author are to the
right of the pivot.
In this example, we choose the rightmost book, by Jack London, as
the pivot when rearranging the books in slots 9 through 15:
9
10
11
12
13
14
15
Sir Walter Scott
Ivanhoe
9
10
11
12
13
14
Gustave Flaubert
Madame Bovary
Charles Dickens
Oliver Twist
15
Jack London
White Fang
Herman Melville
Moby Dick
Jonathan Swift
Gulliver’s Travels
Gustave Flaubert
Madame Bovary
Herman Melville
Moby Dick
Charles Dickens
Oliver Twist
Leo Tolstoy
War and Peace
Jack London
White Fang
Jonathan Swift
Gulliver’s Travels
Leo Tolstoy
War and Peace
Sir Walter Scott
Ivanhoe
After rearranging—which we call partitioning in quicksort—the
books by Flaubert and Dickens, who come before London alpha-
betically, are to the left of the book by London, and all other books,
by authors who come after London alphabetically, are to the right.
Notice that after partitioning, the books to the left of the book by
London are in no particular order, and the same is true for the books
to the right.
2. Conquer by recursively sorting the books to the left of the pivot and
to the right of the pivot. That is, if the divide step moves the pivot to
slot q (slot 11 in the above example), then recursively sort the books
in slots p through q  1 and recursively sort the books in slots q C1
through r.
3. Combine—by doing nothing! Once the conquer step recursively
sorts, we are done. Why? All the books to the left of the pivot
(in slots p through q  1) come before the pivot or have the same
author as the pivot and are sorted, and all the books to the right of the
pivot (in slots q C 1 through r) come after the pivot and are sorted.
The books in slots p through r can’t help but be sorted!
If you change the bookshelf to the array and the books to array el-
ements, you have the strategy for quicksort. Like merge sort, the base
case occurs when the subarray to be sorted has fewer than two elements.

Chapter 3: Algorithms for Sorting and Searching
51
The procedure for quicksort assumes that we can call a procedure
PARTITION.A; p; r/ that partitions the subarray AŒp : : r, returning the
index q where it has placed the pivot.
Procedure QUICKSORT.A; p; r/
Inputs and Result: Same as MERGE-SORT.
1. If p  r, then just return without doing anything.
2. Otherwise, do the following:
A. Call PARTITION.A; p; r/, and set q to its result.
B. Recursively call QUICKSORT.A; p; q  1/.
C. Recursively call QUICKSORT.A; q C 1; r/.
The initial call is QUICKSORT.A; 1; n/, similar to the MERGE-SORT
procedure. Here’s an example of how the recursion unfolds, with the
indices p, q, and r shown for each subarray in which p  r:
9
7
5 11 12 2 14 3 10 6
1
2
3
4
5
6
7
8
9
10
2
3
9 10 11 14 12
1
2
6
7
8
9
10
p
q
r
q
r
7
9
12 14
5
6
9
10
p
p,q r
7
9
14
5
6
10
5
2
3
6 12 7 14 9 10 11
1
2
3
4
5
6
7
8
9
10
p
q
r
7
5
5
3
10
7
p
r
p
2
1
p,r
5
3
p,r
q,r
p,r
7
5
p,r
p q,r

52
Chapter 3: Algorithms for Sorting and Searching
The bottommost value in each array position gives the ﬁnal element
stored there. When you read the array from left to right, looking at
the bottommost value in each position, you see that the array is indeed
sorted.
The key to quicksort is partitioning. Just as we were able to merge
n elements in ‚.n/ time, we can partition n elements in ‚.n/ time.
Here’s how we’ll partition the books that are in slots p through r on the
shelf. We choose the rightmost book of the set—the book in slot r—as
the pivot. At any time, each book will be in exactly one of four groups,
and these groups will be in slots p through r, from left to right:

group L (left group): books with authors known to come before the
pivot’s author alphabetically or written by the pivot’s author, fol-
lowed by

group R (right group): books with authors known to come after the
pivot’s author alphabetically, followed by

group U (unknown group): books that we have not yet examined, so
we don’t know how their authors compare with the pivot’s author,
followed by

group P (pivot): just one book, the pivot.
We go through the books in group U from left to right, comparing each
with the pivot and moving it into either group L or group R, stopping
once we get to the pivot. The book we compare with the pivot is always
the leftmost book in group U.

If the book’s author comes after the pivot’s author, then the book be-
comes the rightmost book in group R. Since the book was the left-
most book in group U, and group U immediately follows group R,
we just have to move the dividing line between groups R and U one
slot to the right, without moving any books:
9
10
11
12
13
14
15
9
10
11
12
13
14
15
Gustave Flaubert
Madame Bovary
Jonathan Swift
Gulliver’s Travels
Sir Walter Scott
Ivanhoe
Herman Melville
Moby Dick
Charles Dickens
Oliver Twist
Leo Tolstoy
War and Peace
Jack London
White Fang
L
R
U
P
Gustave Flaubert
Madame Bovary
Jonathan Swift
Gulliver’s Travels
Sir Walter Scott
Ivanhoe
Herman Melville
Moby Dick
Charles Dickens
Oliver Twist
Leo Tolstoy
War and Peace
Jack London
White Fang
L
R
U
P

Chapter 3: Algorithms for Sorting and Searching
53

If the book’s author comes before the pivot’s author or is the pivot’s
author, then we will make this book the rightmost book in group L.
We swap it with the leftmost book in group R and move the dividing
lines between groups L and R and between groups R and U one slot
to the right:
9
10
11
12
13
14
15
9
10
11
12
13
14
Gustave Flaubert
Madame Bovary
Charles Dickens
Oliver Twist
15
Sir Walter Scott
Ivanhoe
Herman Melville
Moby Dick
Jonathan Swift
Gulliver’s Travels
Gustave Flaubert
Madame Bovary
Jonathan Swift
Gulliver’s Travels
Sir Walter Scott
Ivanhoe
Herman Melville
Moby Dick
Charles Dickens
Oliver Twist
Leo Tolstoy
War and Peace
Jack London
White Fang
Leo Tolstoy
War and Peace
Jack London
White Fang
L
R
U
P
L
R
U
P
Once we get to the pivot, we swap it with the leftmost book in group R.
In our example, we end up with the arrangement of books shown on
page 50.
We compare each book with the pivot once, and each book whose
author comes before the pivot’s author or is the pivot’s author causes one
swap to occur. To partition n books, therefore, we make at most n  1
comparisons (since we don’t have to compare the pivot with itself) and
at most n swaps. Notice that, unlike merging, we can partition the books
without removing them all from the shelf. That is, we can partition in
place.
To convert how we partition books to how we partition a subarray
AŒp : : r, we ﬁrst choose AŒr (the rightmost element) as the pivot. Then
we go through the subarray from left to right, comparing each element
with the pivot. We maintain indices q and u into the subarray that divide
it up as follows:

The subarray AŒp : : q  1 corresponds to group L: each element is
less than or equal to the pivot.

The subarray AŒq : : u  1 corresponds to group R: each element is
greater than the pivot.

The subarray AŒu : : r  1 corresponds to group U: we don’t yet
know how they compare with the pivot.

The element AŒr corresponds to group P: it holds the pivot.
These divisions, in fact, are loop invariants. (But we won’t prove them.)

54
Chapter 3: Algorithms for Sorting and Searching
At each step, we compare AŒu, the leftmost element in group U, with
the pivot. If AŒu is greater than the pivot, then we increment u to move
the dividing line between groups R and U to the right. If instead AŒu is
less than or equal to the pivot, then we swap the elements in AŒq (the
leftmost element in group R) and AŒu and then increment both q and u
to move the dividing lines between groups L and R and groups R and U
to the right. Here’s the PARTITION procedure:
Procedure PARTITION.A; p; r/
Inputs: Same as MERGE-SORT.
Result: Rearranges the elements of AŒp : : r so that every element in
AŒp : : q  1 is less than or equal to AŒq and every element in
AŒq C 1 : : r is greater than q. Returns the index q to the caller.
1. Set q to p.
2. For u D p to r  1 do:
A. If AŒu  AŒr, then swap AŒq with AŒu and then
increment q.
3. Swap AŒq with AŒr and then return q.
By starting both of the indices q and u at p, groups L (AŒp : : q  1)
and R (AŒq : : u  1) are initially empty and group U (AŒu : : r  1)
contains every element except the pivot. In some instances, such as if
AŒp  AŒr, an element might be swapped with itself, resulting in no
change to the array. Step 3 ﬁnishes up by swapping the pivot element
with the leftmost element in group R, thereby moving the pivot into its
correct place in the partitioned array, and then returning the pivot’s new
index q.
Here is how the PARTITION procedure operates, step by step, on the
subarray AŒ5 : : 10 created by the ﬁrst partitioning in the quicksort ex-
ample on page 52. Group U is shown in white, group L has light shad-
ing, group R has darker shading, and the darkest element is the pivot,
group P. The ﬁrst part of the ﬁgure shows the initial array and indices,
the next ﬁve parts show the array and indices after each iteration of the
loop of step 2 (including incrementing index u at the end of each itera-
tion), and the last part shows the ﬁnal partitioned array:

Chapter 3: Algorithms for Sorting and Searching
55
12 7 14 9 10 11
p,q,u
r
5
6
7
8
9
10
12 7 14 9 10 11
p,q
r
5
6
7
8
9
10
u
7 12 14 9 10 11
p
r
5
6
7
8
9
10
u
7 12 14 9 10 11
r
5
6
7
8
9
10
u
7
9 14 12 10 11
p
r
5
6
7
8
9
10
u
7
9 10 12 14 11
p
u,r
5
6
7
8
9
10
q
7
9 10 11 14 12
p
5
6
7
8
9
10
return 8
q
p
q
q
r
q
As when we partitioned books, we compare each element with the
pivot once and perform at most one swap for each element that we com-
pare with the pivot. Since each comparison takes constant time and each
swap takes constant time, the total time for PARTITION on an n-element
subarray is ‚.n/.
So how long does the QUICKSORT procedure take? As with merge
sort, let’s say that sorting a subarray of n elements takes time T .n/,
a function that increases with n. Dividing, done by the PARTITION
procedure, takes ‚.n/ time. But the time for QUICKSORT depends on
how even the partitioning turns out to be.
In the worst case, the partition sizes are really unbalanced. If ev-
ery element other than the pivot is less than it, then PARTITION ends
up leaving the pivot in AŒr and returns the index r to QUICKSORT,
which QUICKSORT stores in the variable q. In this case, the partition
AŒq C 1 : : r is empty and the partition AŒp : : q1 is only one element
smaller than AŒp : : r. The recursive call on the empty subarray takes
‚.1/ time (the time to make the call and determine that the subarray
is empty in step 1). We can just roll this ‚.1/ into the ‚.n/ time for
partitioning. But if AŒp : : r has n elements, then AŒp : : q 1 has n1
elements, and so the recursive call on AŒp : : q  1 takes T .n  1/ time.
We get the recurrence
T .n/ D T .n  1/ C ‚.n/ :
We can’t solve this recurrence using the master method, but it has the
solution that T .n/ is ‚.n2/. That’s no better than selection sort! How
can we get such an uneven split? If every pivot is greater than all other
elements, then the array must have started out already sorted. It also
www.allitebooks.com

56
Chapter 3: Algorithms for Sorting and Searching
turns out that we get an uneven split every time if the array starts out in
reverse sorted order.
On the other hand, if we got an even split every time, each of the
subarrays would have at most n=2 elements. The recurrence would be
the same as the recurrence on page 49 for merge sort,
T .n/ D 2T .n=2/ C ‚.n/ ;
with the same solution, T .n/ is ‚.n lg n/. Of course, we’d have to be
really lucky, or the input array would have to be contrived, to get a
perfectly even split every time.
The usual case is somewhere between the best and worst cases. The
technical analysis is messy and I won’t put you through it, but if the
elements of the input array come in a random order, then on average we
get splits that are close enough to even that QUICKSORT takes ‚.n lg n/
time.
Now let’s get paranoid. Suppose that your worst enemy has given
you an array to sort, knowing that you always pick the last element in
each subarray as the pivot, and has arranged the array so that you always
get the worst-case split. How can you foil your enemy? You could ﬁrst
check to see whether the array starts out sorted or reverse sorted, and
do something special in these cases. Then again, your enemy could
contrive the array so that the splits are always bad, but not maximally
bad. You wouldn’t want to check for every possible bad case.
Fortunately, there’s a much simpler solution: don’t always pick the
last element as the pivot. But then the lovely PARTITION procedure
won’t work, because the groups aren’t where they’re supposed to be.
That’s not a problem, either: before running the PARTITION procedure,
swap AŒr with a randomly chosen element in AŒp : : r. Now you’ve
chosen your pivot randomly and you can run the PARTITION procedure.
In fact, with a little more effort, you can improve your chance of
getting a split that’s close to even. Instead of choosing one element
in AŒp : : r at random, choose three elements at random and swap the
median of the three with AŒr. By the median of the three, we mean
the one whose value is between the other two. (If two or more of the
randomly chosen elements are equal, break ties arbitrarily.) Again, I
won’t make you endure the analysis, but you would have to be really
unlucky in how you chose the random elements each time in order for
QUICKSORT to take longer than ‚.n lg n/ time. Moreover, unless your
enemy had access to your random number generator, your enemy would
have no control over how even the splits turn out to be.

Chapter 3: Algorithms for Sorting and Searching
57
How many times does QUICKSORT swap elements? That depends
on whether you count “swapping” an element to the same position it
started in as a swap. You could certainly check to see whether this is
the case and avoid the swap if it is. So let’s call it a swap only when an
element really moves in the array as a result of swapping, that is, when
q ¤ u in step 2A or when q ¤ r in step 3 of PARTITION. The best
case for minimizing swaps is also one of the worst cases for asymptotic
running time: when the array is already sorted. Then no swaps occur.
The most swaps occur when n is even and the input array looks like
n; n  2; n  4; : : : ; 4; 2; 1; 3; 5; : : : ; n  3; n  1. Then n2=4 swaps
occur, and the asymptotic running time is still the worst case ‚.n2/.
Recap
In this chapter and the previous one, we have seen four algorithms for
searching and four for sorting. Let’s summarize their properties in a
couple of tables. Because the three searching algorithms from Chapter 2
were just variations on a theme, we can consider either BETTER-
LINEAR-SEARCH or SENTINEL-LINEAR-SEARCH as the representa-
tives for linear search.
Searching algorithms
Worst-case
Best-case
Requires
Algorithm
running time
running time
sorted array?
Linear search
‚.n/
‚.1/
no
Binary search
‚.lg n/
‚.1/
yes
Sorting algorithms
Worst-case
Best-case
Worst-case
Algorithm
running time
running time
swaps
In-place?
Selection sort
‚.n2/
‚.n2/
‚.n/
yes
Insertion sort
‚.n2/
‚.n/
‚.n2/
yes
Merge sort
‚.n lg n/
‚.n lg n/
‚.n lg n/
no
Quicksort
‚.n2/
‚.n lg n/
‚.n2/
yes
These tables do not show average-case running times, because with
the notable exception of quicksort, they match the worst-case running
times. As we saw, quicksort’s average-case running time, assuming that
the array starts in a random order, is only ‚.n lg n/.

58
Chapter 3: Algorithms for Sorting and Searching
How do these sorting algorithms compare in practice? I coded them
up in C++ and ran them on arrays of 4-byte integers on two different ma-
chines: my MacBook Pro (on which I wrote this book), with a 2.4-GHz
Intel Core 2 Duo processor and 4 GB of RAM running Mac OS 10.6.8,
and a Dell PC (my website server) with a 3.2-GHz Intel Pentium 4 pro-
cessor and 1 GB of RAM running Linux version 2.6.22.14. I compiled
the code with g++ and optimization level -03. I ran each algorithm on
array sizes ranging up to 50,000, with each array initially in reverse
sorted order. I averaged the running times for 20 runs of each algorithm
on each array size.
By starting each array in reverse sorted order, I elicited the worst-case
asymptotic running times of both insertion sort and quicksort. There-
fore, I ran two versions of quicksort: “regular” quicksort, which always
chooses the pivot as the last element AŒr of the subarray AŒp : : r being
partitioned, and randomized quicksort, which swaps a randomly chosen
element in AŒp : : r with AŒr before partitioning. (I did not run the
median-of-three method.) The “regular” version of quicksort is also
known as deterministic because it does not randomize; everything it
does is predetermined once it’s given an input array to sort.
Randomized quicksort was the champion for n  64 on both com-
puters. Here are the ratios of the running times of the other algorithms
to randomized quicksort’s running times on various input sizes.
MacBook Pro
n
Algorithm
50
100
500
1000
5000
10,000
50,000
Selection sort
1.34
2.13
8.04
13.31
59.07
114.24
537.42
Insertion sort
1.08
2.02
6.15
11.35
51.86
100.38
474.29
Merge sort
7.58
7.64
6.93
6.87
6.35
6.20
6.27
Deterministic quicksort
1.02
1.63
6.09
11.51
52.02
100.57
475.34
Dell PC
n
Algorithm
50
100
500
1000
5000
10,000
50,000
Selection sort
0.76
1.60
5.46
12.23
52.03
100.79
496.94
Insertion sort
1.01
1.66
7.68
13.90
68.34
136.20
626.44
Merge sort
3.21
3.38
3.57
3.33
3.36
3.37
3.15
Deterministic quicksort
1.12
1.37
6.52
9.30
47.60
97.45
466.83
Randomized quicksort looks pretty good, but we can beat it. Recall
that insertion sort works well when no element has to move very far in
the array. Well, once the subproblem sizes in the recursive algorithms

Chapter 3: Algorithms for Sorting and Searching
59
get down to some size k, no element has to move more than k  1 po-
sitions. Instead of continuing to recursively call randomized quicksort
once the subproblem sizes become small, what happens if we instead
run insertion sort, suitably modiﬁed to sort a subarray rather than the
entire array? Indeed, with such a hybrid method, we can sort even
faster than randomized quicksort. I found that on my MacBook Pro,
a subarray size of 22 was the optimal crossover point, and a subarray
size of 17 was the optimal crossover point on my PC. Here are ratios of
running times of the hybrid algorithm to randomized quicksort on both
machines, for the same problem sizes:
n
Machine
50
100
500
1000
5000
10,000
50,000
MacBook Pro
0.55
0.56
0.60
0.60
0.62
0.63
0.66
PC
0.53
0.58
0.60
0.58
0.60
0.64
0.64
Is it possible to beat ‚.n lg n/ time for sorting? It depends. We’ll see
in Chapter 4 that if the only way that we can determine where to place
elements is by comparing elements, doing different things based on the
results of the comparisons, then no, we cannot beat ‚.n lg n/ time. If
we know something about the elements that we can take advantage of,
however, we can do better.
Further reading
CLRS [CLRS09] covers insertion sort, merge sort, and both determinis-
tic and randomized quicksort. But the granddaddy of books about sort-
ing and searching remains Volume 3 of Knuth’s The Art of Computer
Programming [Knu98b]; the advice from Chapter 1 applies—TAOCP
is deep and intense.

4
A Lower Bound for Sorting and How
to Beat It
In the previous chapter, we saw four algorithms for sorting n elements
in an array. Two of them, selection sort and insertion sort, have worst-
case running times of ‚.n2/, which is not very good. One of them,
quicksort, also has a worst-case running time of ‚.n2/, but takes only
‚.n lg n/ time on average. Merge sort takes ‚.n lg n/ time in all cases.
In practice, quicksort is the fastest of the four, but if you absolutely had
to guard against bad worst-case behavior, you would choose merge sort.
Is ‚.n lg n/ as good as it gets? Is it possible to devise a sorting algo-
rithm that beats ‚.n lg n/ time in the worst case? The answer depends
on the rules of the game: how is the sorting algorithm allowed to use
the sort keys when determining the sorted order?
In this chapter, we’ll see that under a certain set of rules, we cannot
beat ‚.n lg n/. Then we’ll see two sorting algorithms, counting sort
and radix sort, that bend the rules and in so doing manage to sort in
only ‚.n/ time.
Rules for sorting
If you examine how the four algorithms from the previous chapter use
the sort keys, you’ll see that they determine the sorted order based only
on comparing pairs of sort keys. All decisions they make are of the form
“if this element’s sort key is less than this other element’s sort key, then
do something, and otherwise either do something else or do nothing
else.” You might be thinking that a sorting algorithm could make only
decisions of this form; what other kinds of decisions could a sorting
algorithm possibly make?
To see what other kinds of decisions are possible, let’s take a really
simple situation. Suppose that we know two things about the elements
we are sorting: each sort key is either 1 or 2, and the elements consist of
only sort keys—no satellite data. In this simple situation, we can sort n
elements in only ‚.n/ time, beating the ‚.n lg n/ algorithms from the
previous chapter. How? First, go through every element and count how
many of them are 1s; let’s say that k elements have the value 1. Then we

Chapter 4: A Lower Bound for Sorting and How to Beat It
61
can go through the array, ﬁlling the value 1 into the ﬁrst k positions and
then ﬁlling the value 2 into the last n  k positions. Here’s a procedure:
Procedure REALLY-SIMPLE-SORT.A; n/
Inputs:

A: an array in which each element is either 1 or 2.

n: the number of elements in A to sort.
Result: The elements of A are sorted into nondecreasing order.
1. Set k to 0.
2. For i D 1 to n:
A. If AŒi D 1, then increment k.
3. For i D 1 to k:
A. Set AŒi to 1.
4. For i D k C 1 to n:
A. Set AŒi to 2.
Steps 1 and 2 count up the number of 1s, incrementing the count k for
every element AŒi that equals 1. Step 3 ﬁlls AŒ1 : : k with 1s, and step 4
ﬁlls the remaining positions, AŒk C 1 : : n, with 2s. It’s pretty easy to
see that this procedure runs in ‚.n/ time: the ﬁrst loop iterates n times,
the last two loops, together, iterate n times, and each iteration of each
loop takes constant time.
Notice that REALLY-SIMPLE-SORT never compares two array ele-
ments with each other. It compares each array element with the value 1,
but never with another array element. So you see that in this restricted
situation, we can sort without comparing pairs of sort keys.
The lower bound on comparison sorting
Now that you have some idea about how the rules of the game may vary,
let’s see a lower bound on how fast we can sort.
We deﬁne a comparison sort as any sorting algorithm that deter-
mines the sorted order only by comparing pairs of elements. The four
sorting algorithms from the previous chapter are comparison sorts, but
REALLY-SIMPLE-SORT is not.

62
Chapter 4: A Lower Bound for Sorting and How to Beat It
Here’s the lower bound:
In the worst case, any comparison sorting algorithm for n ele-
ments requires .n lg n/ comparisons between pairs of elements.
Recall that -notation gives a lower bound, so that what we’re saying
is “for sufﬁciently large n, any comparison sorting algorithm requires at
least cn lg n comparisons in the worst case, for some constant c.” Since
each comparison takes at least constant time, that gives us an .n lg n/
lower bound on the time to sort n elements, assuming that we are using
a comparison sorting algorithm.
It’s important to understand a couple of things about this lower bound.
First, it’s saying something only about the worst case. You can always
make a sorting algorithm run in linear time in the best case: declare
that the best case is when the array is already sorted and just check
that each element (except for the last one) is less than or equal to its
successor in the array. That’s easy to do in ‚.n/ time, and if you ﬁnd
that each element is less than or equal to its successor, then you’re done.
In the worst case, however, .n lg n/ comparisons are necessary. We
call this lower bound an existential lower bound because it says that
there exists an input that requires .n lg n/ comparisons. Another type
of lower bound is a universal lower bound, which applies to all inputs.
For sorting, the only universal lower bound we have is .n/, since we
have to look at each element at least once. Note that in the previous
sentence, I didn’t say .n/ what. Did I mean .n/ comparisons or
.n/ time? I meant .n/ time, since it makes sense that we have to
examine each element, even if we’re not comparing pairs of elements.
The second important thing is truly remarkable: this lower bound
does not depend on the particular algorithm, as long as it’s a comparison
sorting algorithm. The lower bound applies to every comparison sorting
algorithm, no matter how simple or complex. The lower bound applies
to comparison sorting algorithms that have already been invented or
will be invented in the future. It even applies to comparison sorting
algorithms that will never be discovered by mankind!
Beating the lower bound with counting sort
We’ve already seen how to beat the lower bound in a highly restricted
setting: there are only two possible values for the sort keys, and each el-
ement consists of only a sort key, with no satellite data. In this restricted

Chapter 4: A Lower Bound for Sorting and How to Beat It
63
case, we can sort n elements in only ‚.n/ time without comparing pairs
of elements.
We can generalize the method of REALLY-SIMPLE-SORT to handle
m different possible values for the sort keys, as long as they are integers
in a range of m consecutive integers, say, 0 to m  1, and we can also
allow the elements to have satellite data.
Here’s the idea. Suppose we know that the sort keys are integers in
the range 0 to m1, and let’s suppose further that we know that exactly
three elements have sort keys equal to 5 and that exactly six elements
have sort keys less than 5 (that is, in the range 0 to 4). Then we know
that, in the sorted array, the elements with sort keys equal to 5 should
occupy positions 7, 8, and 9. Generalizing, if we know that k elements
have sort keys equal to x and that l elements have sort keys less than x,
then we know that the elements with sort keys equal to x should occupy
positions l C 1 through l C k in the sorted array. Therefore, we want
to compute, for each possible sort-key value, how many elements have
sort keys less than that value and how many elements have sort keys
equal to that value.
We can compute how many elements have sort keys less than each
possible sort-key value by ﬁrst computing how many elements have sort
keys equal to that value, so let’s start with that:
Procedure COUNT-KEYS-EQUAL.A; n; m/
Inputs:

A: an array of integers in the range 0 to m  1.

n: the number of elements in A.

m: deﬁnes the range of the values in A.
Output: An array equalŒ0 : : m  1 such that equalŒj  contains the
number of elements of A that equal j , for j D 0; 1; 2; : : : ; m  1.
1. Let equalŒ0 : : m  1 be a new array.
2. Set all values in equal to 0.
3. For i D 1 to n:
A. Set key to AŒi.
B. Increment equalŒkey.
4. Return the equal array.
Notice that COUNT-KEYS-EQUAL never compares sort keys with each
other. It uses sort keys only to index into the equal array. Since the ﬁrst

64
Chapter 4: A Lower Bound for Sorting and How to Beat It
loop (implicit in step 2) makes m iterations, the second loop (step 3)
makes n iterations, and each iteration of each loop takes constant time,
COUNT-KEYS-EQUAL takes ‚.m C n/ time. If m is a constant, then
COUNT-KEYS-EQUAL takes ‚.n/ time.
Now we can use the equal array to compute a running sum to ﬁnd out
how many elements have sort keys less than each value:
Procedure COUNT-KEYS-LESS.equal; m/
Inputs:

equal: the array returned by COUNT-KEYS-EQUAL.

m: deﬁnes the index range of equal: 0 to m  1.
Output: An array lessŒ0 : : m  1 such that for j D 0; 1; 2; : : : ; m  1,
lessŒj  contains the sum equalŒ0 C equalŒ1 C    C equalŒj  1.
1. Let lessŒ0 : : m  1 be a new array.
2. Set lessŒ0 to 0.
3. For j D 1 to m  1:
A. Set lessŒj  to lessŒj  1 C equalŒj  1.
4. Return the less array.
Assuming that the equalŒj  gives an accurate count of how many sort
keys equal j , for j D 0; 1; : : : ; m  1, you could use the following loop
invariant to show that when COUNT-KEYS-LESS returns, lessŒj  says
how many sort keys are less than j :
At the start of each iteration of the loop of step 3, lessŒj  1
equals the number of sort keys less than j  1.
I’ll leave it to you to ﬁll in the initialization, maintenance, and termina-
tion parts. You can see easily that the COUNT-KEYS-LESS procedure
runs in ‚.m/ time. And it certainly doesn’t compare sort keys with each
other.
Let’s see an example. Suppose that m D 7, so that all sort keys are
integers in the range 0 to 6, and we have the following array A with
n D 10 elements: A D h4; 1; 5; 0; 1; 6; 5; 1; 5; 3i. Then equal D
h1; 3; 0; 1; 1; 3; 1i and less D h0; 1; 4; 4; 5; 6; 9i. Because lessŒ5 D 6
and equalŒ5 D 3 (remember that we index the arrays less and equal
starting from 0, not 1), when we are done sorting, positions 1 through 6
should contain key values less than 5, and positions 7, 8, and 9 should
contain the key value 5.

Chapter 4: A Lower Bound for Sorting and How to Beat It
65
Once we have the less array, we can create a sorted array, though not
in place:
Procedure REARRANGE.A; less; n; m/
Inputs:

A: an array of integers in the range 0 to m  1.

less: the array returned by COUNT-KEYS-LESS.

n: the number of elements in A.

m: deﬁnes the range of the values in A.
Output: An array B containing the elements of A, sorted.
1. Let BŒ1 : : n and nextŒ0 : : m  1 be new arrays.
2. For j D 0 to m  1:
A. Set nextŒj  to lessŒj  C 1.
3. For i D 1 to n:
A. Set key to AŒi.
B. Set index to nextŒkey.
C. Set BŒindex to AŒi.
D. Increment nextŒkey.
4. Return the B array.
The ﬁgure on the next page illustrates how REARRANGE moves el-
ements from array A into array B so that they end up in sorted order
in B. The top part shows the arrays less, next, A, and B before the ﬁrst
iteration of the loop of step 3, and each subsequent part shows next, A,
and B after each iteration. Elements in A are grayed as they are copied
into B.
The idea is that, as we go through the array A from start to end,
nextŒj  gives the index in the array B of where the next element of A
whose key is j should go. Recall from earlier that if l elements have sort
keys less than x, then the k elements whose sort keys equal x should
occupy positions l C 1 through l C k. The loop of step 2 sets up the
array next so that, at ﬁrst, nextŒj  D l C 1, where l D lessŒj . The loop
of step 3 goes through array A from start to end. For each element AŒi,
step 3A stores AŒi into key, step 3B computes index as the index in
array B where AŒi should go, and step 3C moves AŒi into this position
in B. Because the next element in array A that has the same sort key
as AŒi (if there is one) should go into the next position of B, step 3D
increments nextŒkey.

66
Chapter 4: A Lower Bound for Sorting and How to Beat It
less
0
0
1
1
2
4
3
4
4
5
5
6
6
9
next
1
2
5
5
6
7 10
A
4
1
1
2
5
3
0
4
1
5
6
6
5
B
8
1
9
5
10
3
7
next
1
2
5
5
7
7 10
A
4
1
1
2
5
3
0
4
1
5
6
6
5
B
8
1
9
5
10
3
7
4
next
1
3
5
5
7
7 10
A
4
1
1
2
5
3
0
4
1
5
6
6
5
B
8
1
9
5
10
3
7
4
1
next
1
3
5
5
7
8 10
A
4
1
1
2
5
3
0
4
1
5
6
6
5
B
8
1
9
5
10
3
7
4
1
5
0
1
2
3
4
5
6
0
1
2
3
4
5
6
0
1
2
3
4
5
6
next
2
3
5
5
7
8 10
A
4
1
1
2
5
3
0
4
1
5
6
6
5
B
8
1
9
5
10
3
7
4
1
5
0
1
2
3
4
5
6
0
next
2
4
5
5
7
8 10
A
4
1
1
2
5
3
0
4
1
5
6
6
5
B
8
1
9
5
10
3
7
4
1
5
0
1
2
3
4
5
6
0
1
next
2
4
5
5
7
8 11
A
4
1
1
2
5
3
0
4
1
5
6
6
5
B
8
1
9
5
10
3
7
4
1
5
0
1
2
3
4
5
6
0
1
6
next
2
4
5
5
7
9 11
A
4
1
1
2
5
3
0
4
1
5
6
6
5
B
8
1
9
5
10
3
7
4
1
5
0
1
2
3
4
5
6
0
1
6
5
next
2
5
5
5
7
9 11
A
4
1
1
2
5
3
0
4
1
5
6
6
5
B
8
1
9
5
10
3
7
4
1
5
0
1
2
3
4
5
6
0
1
6
5
1
next
2
5
5
5
7 10 11
A
4
1
1
2
5
3
0
4
1
5
6
6
5
B
8
1
9
5
10
3
7
4
1
5
0
1
2
3
4
5
6
0
1
6
5
1
5
next
2
5
5
6
7 10 11
A
4
1
1
2
5
3
0
4
1
5
6
6
5
B
8
1
9
5
10
3
7
4
1
5
0
1
2
3
4
5
6
0
1
6
5
1
5
3

Chapter 4: A Lower Bound for Sorting and How to Beat It
67
How long does REARRANGE take? The loop of step 2 runs in ‚.m/
time, and the loop of step 3 runs in ‚.n/ time. Like COUNT-KEYS-
EQUAL, therefore, REARRANGE runs in ‚.m C n/ time, which is ‚.n/
if m is a constant.
Now we can put the three procedures together to create counting sort:
Procedure COUNTING-SORT.A; n; m/
Inputs:

A: an array of integers in the range 0 to m  1.

n: the number of elements in A.

m: deﬁnes the range of the values in A.
Output: An array B containing the elements of A, sorted.
1. Call COUNT-KEYS-EQUAL.A; n; m/, and assign its result to
equal.
2. Call COUNT-KEYS-LESS.equal; m/ and assign its result to less.
3. Call REARRANGE.A; less; n; m/ and assign its result to B.
4. Return the B array.
From the running times of COUNT-KEYS-EQUAL (‚.mCn/), COUNT-
KEYS-LESS (‚.m/), and REARRANGE (‚.m C n/), you can see that
COUNTING-SORT runs in time ‚.mCn/, or ‚.n/ when m is a constant.
Counting sort beats the lower bound of .n lg n/ for comparison sorting
because it never compares sort keys against each other. Instead, it uses
sort keys to index into arrays, which it can do because the sort keys are
small integers. If the sort keys were real numbers with fractional parts,
or they were character strings, then we could not use counting sort.
You might notice that the procedure assumes that the elements con-
tain only sort keys and not any satellite data. Yet, I promised that, unlike
REALLY-SIMPLE-SORT, COUNTING-SORT allows satellite data. And
it does, as long as you modify step 3C of REARRANGE to copy the
entire element, and not just the sort key.
You might also have noticed that the procedures I’ve provided are a
bit inefﬁcient in how they use arrays. You can combine the equal, less,
and next arrays into one array, but I’ll leave that for you to pursue.
I keep mentioning that the running time is ‚.n/ if m is a constant.
When would m be a constant? One example would be if I were sorting
exams by grade. The grades range from 0 to 100, but the number of
students varies. I could use counting sort to sort the exams of n students

68
Chapter 4: A Lower Bound for Sorting and How to Beat It
in ‚.n/ time, since m D 101 (remember that the range being sorted is
0 to m  1) is a constant.
In practice, however, counting sort turns out to be useful as part of
yet another sorting algorithm, radix sort. In addition to running in linear
time when m is a constant, counting sort has another important property:
it is stable. In a stable sort, elements with the same sort key appear in
the output array in the same order as they do in the input array. In other
words, a stable sort breaks ties between two elements with equal sort
keys by placing ﬁrst in the output array whichever element appears ﬁrst
in the input array. You can see why counting sort is stable by looking at
the loop of step 3 of REARRANGE. If two elements of A have the same
sort key, say key, then the procedure increases nextŒkey immediately
after moving into B the element that occurs earlier in A; that way, by
the time it moves the element that occurs later in A, that element will
appear later in B.
Radix sort
Suppose that you had to sort strings of characters of some ﬁxed length.
For example, I am writing this paragraph on an airplane, and when I
made my reservation, I was given the conﬁrmation code XI7FS6. The
airline designs all conﬁrmation codes as strings of six characters, where
each character is either a letter or a digit. Each character can take 36
values (26 letters plus 10 digits), and so there are 366 D 2,176,782,336
possible conﬁrmation codes. Although that’s a constant, it’s a pretty
large constant, and so the airline would probably rather not rely on
counting sort to sort conﬁrmation codes.
For the sake of being concrete, let’s say that we can translate each of
the 36 characters into a numeric code running from 0 to 35. The code
for a digit is the digit itself (so that the code for the digit 5 is 5), and the
codes for letters start at 10 for A and run through 35 for Z.
Now let’s make things a little simpler and suppose that each conﬁr-
mation code comprises only two characters. (Not to worry: we’ll go
back to six characters soon.) Although we could run counting sort with
m D 362 D 1296, we’ll instead run it twice with m D 36. We run it the
ﬁrst time using the rightmost character as the sort key. Then we take the
result of running counting sort the ﬁrst time and run it a second time,
but now using the leftmost character as the sort key. We choose counting
sort because it works well when m is relatively small and because it is
stable.

Chapter 4: A Lower Bound for Sorting and How to Beat It
69
For example, suppose that we have the two-character conﬁrmation
codes hF6; E5; R6; X6; X2; T5; F2; T3i. After running counting sort
on the rightmost character, we get the sorted order hX2; F2; T3; E5;
T5; F6; R6; X6i. Notice that because counting sort is stable and X2
comes before F2 in the original order, X2 comes before F2 after sorting
on just the rightmost character. Now we sort the result on the leftmost
character, again using counting sort, getting the desired result hE5; F2;
F6; R6; T3; T5; X2; X6i.
What would have happened if we had sorted on the leftmost character
ﬁrst? After running counting sort on the leftmost character, we’d have
hE5; F6; F2; R6; T5; T3; X6; X2i, and then after running counting sort
on the rightmost character of the result, we’d get hF2; X2; T3; E5; T5;
F6; R6; X6i, which is incorrect.
Why does working from right to left give a correct result? Using
a stable sorting method is important; it could be counting sort or any
other stable sorting method. Let’s suppose that we’re working on the
ith character position, and assume that if we look at the rightmost i  1
character positions, the array is sorted. Consider any two sort keys. If
they differ in the ith character position, then it doesn’t matter what’s in
the i  1 positions to the right: the stable sorting algorithm that sorts
on the ith position will put them into the correct order. If, on the other
hand, they have the same character in the ith position, then the one that
comes ﬁrst in the i  1 rightmost character positions should come ﬁrst,
and by using a stable sorting method, we guarantee that this is exactly
what happens.
So let’s return to 6-character conﬁrmation codes, and we’ll see how
to sort conﬁrmation codes that start out in the order hXI7FS6; PL4ZQ2;
JI8FR9;XL8FQ6;PY2ZR5;KV7WS9;JL2ZV3;KI4WR2i. Let’s num-
ber the characters from right to left as 1 to 6. Then here are the results
after running a stable sort on the ith character, working right to left:
i
Resulting order
1
hPL4ZQ2, KI4WR2, JL2ZV3, PY2ZR5, XI7FS6, XL8FQ6, JI8FR9, KV7WS9i
2
hPL4ZQ2, XL8FQ6, KI4WR2, PY2ZR5, JI8FR9, XI7FS6, KV7WS9, JL2ZV3i
3
hXL8FQ6, JI8FR9, XI7FS6, KI4WR2, KV7WS9, PL4ZQ2, PY2ZR5, JL2ZV3i
4
hPY2ZR5, JL2ZV3, KI4WR2, PL4ZQ2, XI7FS6, KV7WS9, XL8FQ6, JI8FR9i
5
hKI4WR2, XI7FS6, JI8FR9, JL2ZV3, PL4ZQ2, XL8FQ6, KV7WS9, PY2ZR5i
6
hJI8FR9, JL2ZV3, KI4WR2, KV7WS9, PL4ZQ2, PY2ZR5, XI7FS6, XL8FQ6i

70
Chapter 4: A Lower Bound for Sorting and How to Beat It
To generalize, in the radix sort algorithm, we assume that we can
think of each sort key as a d-digit number, where each digit is in the
range 0 to m  1. We run a stable sort on each digit, going from right
to left. If we use counting sort as the stable sort, then the time to sort on
one digit is ‚.m C n/, and the time to sort all d digits is ‚.d.m C n//.
If m is a constant (such as 36 in the conﬁrmation code example), then
the time for radix sort is ‚.dn/. If d is also a constant (such as 6 for
conﬁrmation codes), then the time for radix sort is only ‚.n/.
When radix sort uses counting sort to sort on each digit, it never com-
pares two sort keys against each other. It uses the individual digits to
index into arrays within counting sort. That is why radix sort, like count-
ing sort, beats the lower bound of .n lg n/ for comparison sorting.
Further reading
Chapter 8 of CLRS [CLRS09] expands on all the material in this chap-
ter.

5
Directed Acyclic Graphs
Recall the footnote on page 1, where I revealed that I used to play
hockey. For several years, I was a goalie, but eventually my game de-
teriorated to the point that I couldn’t stand watching myself play. It
seemed as though every shot found its way to the back of the net. Then,
after a hiatus of over seven years, I got back between the pipes (that is,
I resumed playing goal) for a couple of games.
My biggest concern wasn’t whether I’d be any good—I knew I was
going to be terrible—but rather whether I’d remember how to put on
all the goalie equipment. In ice hockey, goalies wear a lot of gear (35
to 40 pounds of it), and when dressing for a game, I have to put it on in
the right order. For example, because I am right-handed, I wear on my
left hand an oversized mitt for catching pucks; it’s called a catch glove.
Once I’ve got the catch glove on, my left hand has no dexterity, and I
cannot get an upper-body garment of any sort over it.
When I was preparing to don the goalie gear, I made myself a diagram
showing which items had to be put on before other items. The diagram
appears on the next page. An arrow from item A to item B indicates a
constraint that A must be put on before B. For example, I have to put on
the chest pad before the sweater. Of course, the “must be put on before”
constraint is transitive: if item A must be put on before item B, and
item B must be put on before item C, then item A must be put on before
item C. Therefore, I must put on the chest pad before the sweater, mask,
catch glove, and blocker.
For some pairs of items, however, it doesn’t matter in which order I
put them on. I can put socks on either before or after the chest pad, for
example.
I needed to determine an order in which to get dressed. Once I had
my diagram, I had to come up with a list containing all the items I had
to don, in a single order that did not violate any of the “must be put
on before” constraints. I found that several orders worked; below the
diagram are three of them.

72
Chapter 5: Directed Acyclic Graphs
pants
T-shirt
leg pads
hose
socks
skates
chest pad
sweater
mask
catch glove
blocker
undershorts
compression shorts
cup
Order #1
Order #2
Order #3
undershorts
undershorts
socks
compression shorts
T-shirt
T-shirt
cup
compression shorts
undershorts
socks
cup
chest pad
hose
chest pad
compression shorts
pants
socks
hose
skates
hose
cup
leg pads
pants
pants
T-shirt
sweater
skates
chest pad
mask
leg pads
sweater
skates
sweater
mask
leg pads
mask
catch glove
catch glove
catch glove
blocker
blocker
blocker
How did I arrive at these orders? Here’s how I came up with order #2.
I looked for an item that had no incoming arrows, because such an item
need not be put on after any other item. I chose undershorts to be the
ﬁrst item in the order, and then, having (conceptually) put on the under-
shorts, I removed them from the diagram, resulting in the diagram at the
top of the next page.

Chapter 5: Directed Acyclic Graphs
73
pants
T-shirt
leg pads
hose
socks
skates
chest pad
sweater
mask
catch glove
blocker
compression shorts
cup
Then, again, I chose an item with no incoming arrows, this time T-shirt.
I added it to the end of the order and removed it from the diagram,
resulting in this diagram:
pants
leg pads
hose
socks
skates
chest pad
sweater
mask
catch glove
blocker
compression shorts
cup
Once again, I chose an item with no incoming arrows—compression
shorts—and then I added it to the end of the order and removed it from
the diagram, resulting in the diagram at the top of the next page.

74
Chapter 5: Directed Acyclic Graphs
pants
leg pads
hose
socks
skates
chest pad
sweater
mask
catch glove
blocker
cup
Next, I chose cup:
pants
leg pads
hose
socks
skates
chest pad
sweater
mask
catch glove
blocker
I kept going in this way—choosing an item with no incoming arrows,
adding it to the end of the order, and removing the item from the di-
agram—until no items remained. The three orders shown on page 72
result from making various choices for the item with no incoming ar-
rows, starting from the diagram on page 72.
Directed acyclic graphs
These diagrams are speciﬁc examples of directed graphs, which are
made of vertices (singular: vertex), corresponding to the items of goalie
equipment, and directed edges, shown by arrows. Each directed edge is
an ordered pair of the form .u; v/, where u and v are vertices. For exam-

Chapter 5: Directed Acyclic Graphs
75
ple, the leftmost edge in the directed graph on page 72 is .socks; hose/.
When a directed graph contains a directed edge .u; v/, we say that v
is adjacent to u and that .u; v/ leaves u and enters v, so that the ver-
tex labeled hose is adjacent to the vertex labeled socks and the edge
.socks; hose/ leaves the vertex labeled socks and enters the vertex la-
beled hose.
The directed graphs that we have seen have another property: there
is no way to get from a vertex back to itself by following a sequence
of one or more edges. We call such a directed graph a directed acyclic
graph, or dag. It’s acyclic because there is no way to “cycle” from a
vertex back to itself. (We’ll see a more formal deﬁnition of a cycle later
in this chapter.)
Dags are great for modeling dependencies where one task must occur
before another. Another use for dags arises when planning projects,
such as building a house: for example, the framing must be in place
before the roof goes on. Or, in cooking, certain steps must occur in
certain orders, but for some steps it doesn’t matter in which order they
happen; we’ll see an example of a dag for cooking later in this chapter.
Topological sorting
When I needed to determine a single, linear order in which to put on the
goalie equipment, I needed to perform a “topological sort.” Put more
precisely, a topological sort of a dag produces a linear order such that
if .u; v/ is an edge in the dag, then u appears before v in the linear
order. Topological sorting differs from sorting in the sense that we used
in Chapters 3 and 4.
The linear order produced by a topological sort is not necessarily
unique. But you know that already, since each of the three orders for
donning goalie equipment on page 72 could be produced by a topologi-
cal sort.
Another use for topological sorting occurred at a programming job I
had a long time ago. We were creating computer-aided design systems,
and our systems could maintain a library of parts. Parts could contain
other parts, but no circular dependencies were allowed: a part could not
eventually contain itself. We needed to write out the part designs to tape
(I said that the job was a long time ago) so that each part preceded any
other parts that contained it. If each part is a vertex and an edge .u; v/
indicates that part v contains part u, then we needed to write the parts
according to a topologically sorted linear order.

76
Chapter 5: Directed Acyclic Graphs
What vertex would be a good candidate to be the ﬁrst one in the linear
order? Any vertex with no entering edges would do. The number of
edges entering a vertex is the vertex’s in-degree, and so we could start
with any vertex whose in-degree is 0. Fortunately, every dag must have
at least one vertex with in-degree 0 and at least one vertex with out-
degree 0 (no edges leaving the vertex), for otherwise there would be a
cycle.
So suppose we choose any vertex with in-degree 0—let’s call it ver-
tex u—and put it at the beginning of the linear order. Because we have
taken care of vertex u ﬁrst, all other vertices will be placed after u in
the linear order. In particular, any vertex v that is adjacent to u must
appear somewhere after u in the linear order. Therefore, we can safely
remove u and all edges leaving u from the dag, knowing that we’ve
taken care of the dependencies that these edges deﬁne. When we re-
move a vertex and the edges that leave it from a dag, what are we left
with? Another dag! After all, we cannot create a cycle by removing a
vertex and edges. And so we can repeat the process with the dag that
remains, ﬁnding some vertex with in-degree 0, placing it after vertex u
in the linear order, removing edges, and so on.
The procedure on the next page for topological sorting uses this idea,
but instead of actually removing vertices and edges from the dag, it just
keeps track of the in-degree of each vertex, decrementing the in-degree
for each entering edge that we conceptually remove. Since array indices
are integers, let’s assume that we identify each vertex by a unique inte-
ger in the range 1 to n. Because the procedure needs to quickly identify
some vertex with in-degree 0, it maintains the in-degree of each vertex
in an array in-degree indexed by the vertices, and it maintains a list next
of all the vertices with in-degree 0. Steps 1–3 initialize the in-degree
array, step 4 initializes next, and step 5 updates in-degree and next as
vertices and edges are conceptually removed. The procedure can choose
any vertex in next as the next one to put into the linear order.
Let’s see how the ﬁrst few iterations of step 5 work on the dag for
putting on goalie equipment. In order to run the TOPOLOGICAL-SORT
procedure on this dag, we need to number the vertices, as shown on
page 78. Only vertices 1, 2, and 9 have in-degree 0, and so as we enter
the loop of step 5, the list next contains only these three vertices. To
get order #1 on page 72, the order of the vertices in next would be 1,
2, 9. Then, in the ﬁrst iteration of step 5’s loop, we choose vertex 1
(undershorts) as vertex u, delete it from next, add this vertex to the

Chapter 5: Directed Acyclic Graphs
77
Procedure TOPOLOGICAL-SORT.G/
Input: G: a directed acyclic graph with vertices numbered 1 to n.
Output: A linear order of the vertices such that u appears before v in
the linear order if .u; v/ is an edge in the graph.
1. Let in-degreeŒ1 : : n be a new array, and create an empty linear
order of vertices.
2. Set all values in in-degree to 0.
3. For each vertex u:
A. For each vertex v adjacent to u:
i. Increment in-degreeŒv.
4. Make a list next consisting of all vertices u such that
in-degreeŒu D 0.
5. While next is not empty, do the following:
A. Delete a vertex from next, and call it vertex u.
B. Add u to the end of the linear order.
C. For each vertex v adjacent to u:
i. Decrement in-degreeŒv.
ii. If in-degreeŒv D 0, then insert v into the next list.
6. Return the linear order.
end of the initially empty linear order, and then decrement in-degreeŒ3
(compression shorts). Because that operation takes in-degreeŒ3 down
to 0, we insert vertex 3 into next. Let’s assume that when we insert
a vertex into next, we insert it as the ﬁrst vertex on the list. Such a
list, where we always insert and delete at the same end, is known as
a stack, because it’s like a stack of plates, where you always take a
plate from the top and place a new plate at the top. (We call this order
last in, ﬁrst out, or LIFO.) Under this assumption, next becomes 3,
2, 9 and in the next loop iteration, we choose vertex 3 as vertex u. We
delete it from next, add it to the end of the linear order, so that the linear
order now reads “undershorts, compression shorts,” and we decrement
in-degreeŒ4 (from 2 down to 1) and in-degreeŒ5 (from 1 down to 0).
We insert vertex 5 (cup) into next, resulting in next becoming 5, 2, 9. In
the next iteration, we choose vertex 5 as vertex u, delete it from next,
add it to the end of the linear order (now “undershorts, compression

78
Chapter 5: Directed Acyclic Graphs
pants
T-shirt
leg pads
hose
socks
skates
chest pad
sweater
mask
catch glove
blocker
undershorts
compression shorts
cup
2
1
3
4
5
6
7
8
9
10
11
12
13
14
shorts, cup”), and decrement in-degreeŒ6, taking it down from 2 to 1.
No vertices are added to next this time, and so in the next iteration, we
choose vertex 2 as vertex u, and so on.
In order to analyze the TOPOLOGICAL-SORT procedure, we ﬁrst have
to understand how to represent a directed graph and a list such as next.
When representing a graph, we won’t require it to be acyclic, because
the absence or presence of cycles has no effect on how we represent a
graph.
How to represent a directed graph
In a computer, we can represent a directed graph in a few ways. Our
convention will be that a graph has n vertices and m edges. We continue
to assume that each vertex has its own number from 1 to n, so that we
can use a vertex as an index into an array, or even as the row or column
number of a matrix.
For now, we just want to know which vertices and edges are present.
(Later on, we’ll also associate a numeric value with each edge.) We
could use an nn adjacency matrix in which each row and each column
corresponds to one vertex, and the entry in the row for vertex u and
the column for vertex v is either 1 if the edge .u; v/ is present or 0
if the graph does not contain edge .u; v/. Since an adjacency matrix
has n2 entries, it must be true that m  n2. Alternatively, we could
just keep a list of all m edges in the graph in no particular order. As

Chapter 5: Directed Acyclic Graphs
79
a hybrid between an adjacency matrix and an unordered list, we have
the adjacency-list representation, with an n-element array indexed by
the vertices in which the array entry for each vertex u is a list of all the
vertices adjacent to u. Altogether, the lists have m vertices, since there’s
one list item for each of the m edges. Here are the adjacency-matrix and
adjacency-list representations for the directed graph on page 78:
Adjacency matrix
1
2
3
4
5
6
7
8
9 10 11 12 13 14
1
0
0
1
0
0
0
0
0
0
0
0
0
0
0
2
0
0
0
1
0
0
0
0
0
0
0
0
0
0
3
0
0
0
1
1
0
0
0
0
0
0
0
0
0
4
0
0
0
0
0
1
0
0
0
0
0
0
0
0
5
0
0
0
0
0
1
0
0
0
0
0
0
0
0
6
0
0
0
0
0
0
1
0
0
0
1
0
0
0
7
0
0
0
0
0
0
0
1
0
0
0
0
0
0
8
0
0
0
0
0
0
0
0
0
0
0
0
1
0
9
0
0
0
0
0
0
0
0
0
1
0
0
0
0
10
0
0
0
0
0
0
0
0
0
0
1
0
0
0
11
0
0
0
0
0
0
0
0
0
0
0
1
0
0
12
0
0
0
0
0
0
0
0
0
0
0
0
1
0
13
0
0
0
0
0
0
0
0
0
0
0
0
0
1
14
0
0
0
0
0
0
0
0
0
0
0
0
0
0
Adjacency lists
1
3
2
4
3
4; 5
4
6
5
6
6
7; 11
7
8
8
13
9
10
10
11
11
12
12
13
13
14
14
(none)
The unordered list of edges and the adjacency-list representation lead
to the question of how to represent a list. The best way to represent a list
depends on what types of operations we need to perform on the list. For
unordered edge lists and adjacency lists, we know in advance how many
edges will be in each list, and the contents of the lists won’t change, and
so we can store each list in an array. We can also use an array to store a
list even if the list’s contents change over time, as long as we know the
maximum number of items that will ever be in the list at any one time.
If we don’t need to insert an item into the middle of the list or delete
an item from the middle of the list, representing a list by an array is as
efﬁcient as any other means.
If we do need to insert into the middle of the list, then we can use a
linked list, in which each list item includes the location of its successor
item in the list, making it simple to splice in a new item after a given
item. If we also need to delete from the middle of the list, then each
item in the linked list should also include the location of its predecessor
item, so that we can quickly splice out an item. From now on, we will
assume that we can insert into or delete from a linked list in constant

80
Chapter 5: Directed Acyclic Graphs
time. A linked list that has only successor links is a singly linked list.
Adding predecessor links makes a doubly linked list.
Running time of topological sorting
If we assume that the dag uses the adjacency-list representation and the
next list is a linked list, then we can show that the TOPOLOGICAL-SORT
procedure takes ‚.nCm/ time. Since next is a linked list, we can insert
into it or delete from it in constant time. Step 1 takes constant time, and
because the in-degree array has n elements, step 2 initializes the array
to all 0s in ‚.n/ time. Step 3 takes ‚.n C m/ time. The ‚.n/ term in
step 3 arises because the outer loop examines each of the n vertices, and
the ‚.m/ term is because the inner loop of step 3A visits each of the
m edges exactly once over all iterations of the outer loop. Step 4 takes
O.n/ time, since the next list starts with at most n vertices. Most of the
work occurs in step 5. Because each vertex is inserted into next exactly
once, the main loop iterates n times. Steps 5A and 5B take constant
time in each iteration. Like step 3A, the loop of step 5C iterates m
times altogether, once per edge. Steps 5Ci and 5Cii take constant time
per iteration, so that all iterations together of step 5C take ‚.m/ time,
and therefore the loop of step 5 takes ‚.n C m/ time. Of course, step 6
takes constant time, and so when we add up the time for all the steps,
we get ‚.n C m/.
Critical path in a PERT chart
I like to relax after a day at work by cooking, and I always enjoy cook-
ing and eating kung pao chicken. I have to prepare the chicken, chop
vegetables, mix a marinade and cooking sauce, and cook the dish. Just
as when I put on goalie equipment, some steps must occur before oth-
ers, and so I can use a dag to model the procedure for cooking kung pao
chicken. The dag appears on the next page.
Next to each vertex in the dag appears a number, indicating how many
minutes I need to perform the task corresponding to the vertex. For
example, I take four minutes to chop the garlic (because I peel each
clove ﬁrst, and I use a lot of garlic). If you add up the times for all the
tasks, you can see that if I were to perform them in sequence, it would
take me an hour to make kung pao chicken.
If I had help, however, we could perform several of the tasks simulta-
neously. For example, one person could mix the marinade while some-

Chapter 5: Directed Acyclic Graphs
81
mix marinade
6
marinate chicken
15
partially cook chicken
4
add garlic, ginger
1
finish cooking chicken
2
remove chicken
1
cook carrots, celery, peanuts
4
add back chicken
1
add cooking sauce
1
cook sauce until thick
3
remove completed dish
1
mix cooking sauce
3
rinse peanuts
2
chop celery
3
chop carrots
4
chop ginger
3
chop garlic
4
cut up chicken
2
one else cut up the chicken. Given enough people helping, and sufﬁcient
space, knives, cutting boards, and bowls, we could perform many of the
tasks simultaneously. If you look at any two tasks in the dag and ﬁnd
that there is no way to follow arrows to get from one to the other, then I
could assign each of the tasks to a different person and have them done
simultaneously.
Given unlimited resources (people, space, cooking equipment) to per-
form tasks simultaneously, how quickly can we make kung pao chicken?
The dag is an example of a PERT chart, an acronym for “program eval-
uation and review technique.” The time to complete the entire job, even
with as many tasks performed simultaneously as possible, is given by
the “critical path” in the PERT chart. To understand what a critical path
is, we ﬁrst have to understand what a path is, and then we can deﬁne a
critical path.
A path in a graph is a sequence of vertices and edges that allow you
to get from one vertex to another (or back to itself); we say that the path

82
Chapter 5: Directed Acyclic Graphs
contains both the vertices on it and the edges traversed. For example,
one path in the dag for kung pao chicken has, in order, the vertices
labeled “chop garlic,” “add garlic, ginger,” “ﬁnish cooking chicken,”
and “remove chicken,” along with the edges connecting these vertices.
A path from a vertex back to itself is a cycle, but of course dags do not
have cycles.
A critical path in a PERT chart is a path for which the sum of the
task times is maximum over all paths. The sum of the task times along a
critical path gives the minimum possible time for the entire job, no mat-
ter how many tasks are performed simultaneously. I shaded the critical
path in the PERT chart for cooking kung pao chicken. If you add up the
task times along the critical path, you’ll see that no matter how much
help I have, it takes me at least 39 minutes to make kung pao chicken.1
Assuming that all task times are positive, a critical path in a PERT
chart must start at some vertex with in-degree 0 and end at some vertex
with out-degree 0. Rather than checking paths between all pairs of ver-
tices in which one has in-degree 0 and one has out-degree 0, we can just
add two “dummy” vertices, “start” and “ﬁnish,” as in the ﬁgure on the
next page. Because these are dummy vertices, we give them task times
of 0. We add an edge from start to each vertex with in-degree 0 in the
PERT chart, and we add an edge from each vertex with out-degree 0 to
ﬁnish. Now the only vertex with in-degree 0 is start, and the only vertex
with out-degree 0 is ﬁnish. A path from start to ﬁnish with the maxi-
mum sum of task times on its vertices (shaded) gives a critical path in
the PERT chart—minus the dummy vertices start and ﬁnish, of course.
Once we have added the dummy vertices, we ﬁnd a critical path by
ﬁnding a shortest path from start to ﬁnish, based on the task times. At
this point, you might think I made an error in the previous sentence,
because a critical path should correspond to a longest path, not a shortest
path. Indeed, it does, but because a PERT chart has no cycles, we can
alter the task times so that a shortest path gives us a critical path. In
particular, we negate each task time and ﬁnd a path from start to ﬁnish
with the minimum sum of task times.
Why negate task times and ﬁnd a path with the minimum sum of task
times? Because solving this problem is a special case of ﬁnding short-
1If you’re wondering why Chinese restaurants can turn out an order of kung pao chicken
in much less time, it’s because they prepare many of the ingredients in advance, and
their commercial stoves can cook faster than my residential-grade stove.

Chapter 5: Directed Acyclic Graphs
83
finish
mix marinade
6
marinate chicken
15
partially cook chicken
4
add garlic, ginger
1
finish cooking chicken
2
remove chicken
1
cook carrots, celery, peanuts
4
add back chicken
1
add cooking sauce
1
cook sauce until thick
3
remove completed dish
1
mix cooking sauce
3
rinse peanuts
2
chop celery
3
chop carrots
4
chop ginger
3
chop garlic
4
cut up chicken
2
start
0
0
est paths, and we have plenty of algorithms for ﬁnding shortest paths.
When we talk about shortest paths, however, the values that determine
path lengths are associated with edges, not with vertices. We call the
value that we associate with each edge its weight. A directed graph with
edge weights is a weighted directed graph. “Weight” is a generic term
for values associated with edges. If a weighted directed graph represents
a road network, each edge represents one direction of a road between
two intersections, and the weight of an edge could represent the road’s
length, the time required to travel the road, or the toll a vehicle pays to
use the road. The weight of a path is the sum of the weights of the edges
on the path, so that if edge weights represent road distances, the weight
of a path might indicate the total distance traveled along the roads on

84
Chapter 5: Directed Acyclic Graphs
the path. A shortest path from vertex u to vertex v is a path whose sum
of edge weights is minimum over all paths from u to v. Shortest paths
are not necessarily unique, as a directed graph from u to v could contain
multiple paths whose weights achieve the minimum.
To convert a PERT chart with negated task times into a weighted
directed graph, we push the negated task time for each vertex onto each
of its entering edges. That is, if vertex v has a (non-negated) task time
of t, we set the weight of each edge .u; v/ entering v to be t. Here’s
the dag we get, with edge weights appearing next to their edges:
mix marinade
–6
marinate chicken
–15
partially cook chicken
–4
add garlic, ginger
–1
finish cooking chicken
–2
remove chicken
–1
cook carrots, celery, peanuts
–4
add back chicken
–1
add cooking sauce
–1
cook sauce until thick
–3
remove completed dish
–1
mix cooking sauce
–3
rinse peanuts
–2
chop celery
–3
chop carrots
–4
chop ginger
–3
chop garlic
–4
cut up chicken
–2
–15
–1
–1
–4
–4
–4
–1
start
finish
0
Now we just have to ﬁnd a shortest path (shaded) from start to ﬁnish
in this dag, based on these edge weights. A critical path in the original

Chapter 5: Directed Acyclic Graphs
85
PERT chart will correspond to the vertices on the shortest path we ﬁnd,
minus start and ﬁnish. So let’s see how to ﬁnd a shortest path in a dag.
Shortest path in a directed acyclic graph
There is another advantage to learning how to ﬁnd a shortest path in
a dag: we’ll lay the foundations for ﬁnding shortest paths in arbitrary
directed graphs that may have cycles. We’ll examine this more general
problem in Chapter 6. As we did for topologically sorting a dag, we’ll
assume that the dag is stored with the adjacency-list representation, and
that with each edge .u; v/ we have also stored its weight as weight.u; v/.
In a dag that we derive from a PERT chart, we want a shortest path
from the source vertex, which we call “start,” to a speciﬁc target vertex,
“ﬁnish.” Here, we’ll solve the more general problem of ﬁnding single-
source shortest paths, where we ﬁnd shortest paths from a source vertex
to all other vertices. By convention, we will name the source vertex s,
and we want to compute two things for each vertex v. First, the weight
of a shortest path from s to v, which we denote by sp.s; v/. Second,
the predecessor of v on a shortest path from s to v: a vertex u such
that a shortest path from s to v is a path from s to u and then a single
edge .u; v/. We will number the n vertices from 1 to n, so that our algo-
rithms for shortest paths here and in Chapter 6 can store these results in
arrays shortestŒ1 : : n and predŒ1 : : n, respectively. As the algorithms
unfold, the values in shortestŒv and predŒv might not be their correct
ﬁnal values, but when the algorithms are done, they will be.
We need to handle a couple of cases that can arise. First, what if
there is no path at all from s to v? Then we deﬁne sp.s; v/ D 1, so
that shortestŒv should come out to 1. Since v would have no prede-
cessor on a shortest path from s, we also say that predŒv should be the
special value NULL. Moreover, all shortest paths from s start with s,
and so s has no predecessor, either; thus we say that predŒs should also
be NULL. The other case arises only in graphs that have both cycles
and negative edge weights: what if the weight of a cycle is negative?
Then we could go around the cycle forever, decreasing the path weight
each time around. If we can get from s to a negative-weight cycle and
then to v, then sp.s; v/ is undeﬁned. For now, however, we’re con-
cerned only with acyclic graphs, and so there are no cycles, much less
negative-weight cycles, to worry about.
To compute shortest paths from a source vertex s, we start off with
shortestŒs D 0 (since we don’t have to go anywhere to get from a vertex

86
Chapter 5: Directed Acyclic Graphs
to itself), shortestŒv D 1 for all other vertices v (since we don’t know
in advance which vertices can be reached from s), and predŒv D NULL
for all vertices v. Then we apply a series of relaxation steps to the edges
of the graph:
Procedure RELAX.u; v/
Inputs: u, v: vertices such that there is an edge .u; v/.
Result: The value of shortestŒv might decrease, and if it does, then
predŒv becomes u.
1. If shortestŒu C weight.u; v/ < shortestŒv, then set shortestŒv to
shortestŒu C weight.u; v/ and set predŒv to u.
When we call RELAX.u; v/, we are determining whether we can im-
prove upon the current shortest path from s to v by taking .u; v/ as the
last edge. We compare the weight of the current shortest path to u plus
the weight of edge .u; v/ with the weight of the current shortest path
to v. If it’s better to take edge .u; v/, then we update shortestŒv to this
new weight and we set v’s predecessor on a shortest path to be u.
If we relax edges along a shortest path, in order, we get the right
results. You might wonder how we can be assured of relaxing the edges
in order along a shortest path when we don’t even know what the path
is—after all, that’s what we’re trying to ﬁnd out—but it will turn out to
be easy for a dag. We’re going to relax all the edges in the dag, and
the edges of each shortest path will be interspersed, in order, as we go
through all the edges and relax each one.
Here’s a more precise statement of how relaxing edges along a short-
est path works, and it applies to any directed graph, with or without
cycles:
Start with shortestŒu D 1 and predŒu D NULL for all vertices,
except that shortestŒs D 0 for the source vertex s.
Then relax the edges along a shortest path from s to any ver-
tex v, in order, starting from the edge leaving s and ending with
the edge entering v. Relaxations of other edges may be inter-
spersed freely with the relaxations along this shortest path, but
only relaxations may change any shortest or pred values.
After the edges have been relaxed, v’s shortest and pred values
are correct: shortestŒv D sp.s; v/ and predŒv is the vertex pre-
ceding v on some shortest path from s.

Chapter 5: Directed Acyclic Graphs
87
It’s pretty easy to see why relaxing the edges along a shortest path, in
order, works. Suppose that a shortest path from s to v visits the ver-
tices s; v1; v2; v3; : : : ; vk; v, in that order. After edge .s; v1/ has been
relaxed, shortestŒv1 must have the correct shortest-path weight for v1,
and predŒv1 must be s. After .v1; v2/ has been relaxed, shortestŒv2 and
predŒv2 must be correct. And so on, up through relaxing .vk; v/, after
which shortestŒv and predŒv have their correct values.
This is great news. In a dag, it’s really easy to relax each edge exactly
once yet relax the edges along every shortest path, in order. How? First,
topologically sort the dag. Then consider each vertex, taken in the topo-
logically sorted linear order, and relax all the edges leaving the vertex.
Since every edge must leave a vertex earlier in the linear order and enter
a vertex later in the order, every path in the dag must visit vertices in an
order consistent with the linear order.
Procedure DAG-SHORTEST-PATHS.G; s/
Inputs:

G: a weighted directed acyclic graph containing a set V of n
vertices and a set E of m directed edges.

s: a source vertex in V .
Result: For each non-source vertex v in V , shortestŒv is the weight
sp.s; v/ of a shortest path from s to v and predŒv is the vertex
preceding v on some shortest path. For the source vertex s,
shortestŒs D 0 and predŒs D NULL. If there is no path from s to v,
then shortestŒv D 1 and predŒv D NULL.
1. Call TOPOLOGICAL-SORT.G/ and set l to be the linear order of
vertices returned by the call.
2. Set shortestŒv to 1 for each vertex v except s, set shortestŒs
to 0, and set predŒv to NULL for each vertex v.
3. For each vertex u, taken in the order given by l:
A. For each vertex v adjacent to u:
i. Call RELAX.u; v/.
The next page shows a dag with weights appearing next to the edges.
The shortest values from running DAG-SHORTEST-PATHS from source
vertex s appear inside the vertices, and shaded edges indicate the pred
values. The vertices are laid out left to right in the linear order returned
by the topological sort, so that all edges go from left to right. If an

88
Chapter 5: Directed Acyclic Graphs
2
5
1
6
3
4
7
–1
–2
2
x
t
s
r
y
z
∞
0
2
6
5
3
edge .u; v/ is shaded, then predŒv is u and shortestŒv D shortestŒu C
weight.u; v/; for example, since .x; y/ is shaded, predŒy D x and
shortestŒy (which is 5) equals shortestŒx (which is 6) + weight.x; y/
(which is 1). There is no path from s to r, and so shortestŒr D 1
and predŒr D NULL (no shaded edges enter r).
The ﬁrst iteration of the loop of step 3 relaxes edges .r; s/ and .r; t/
leaving r, but because shortestŒr D 1, these relaxations do not
change anything.
The next iteration of the loop relaxes edges .s; t/
and .s; x/ leaving s, causing shortestŒt to be set to 2, shortestŒx to
be set to 6, and both predŒt and predŒx to be set to s. The follow-
ing iteration relaxes edges .t; x/, .t; y/, and .t; ´/ leaving t. The value
of shortestŒx does not change, since shortestŒt C weight.t; x/, which
is 2 C 7 D 9, is greater than shortestŒx, which is 6; but shortestŒy
becomes 6, shortestŒ´ becomes 4, and both predŒy and predŒ´ are
set to t. The next iteration relaxes edges .x; y/ and .x; ´/ leaving x,
causing shortestŒy to become 5 and predŒy to be set to x; shortestŒ´
and predŒ´ remain unchanged. The ﬁnal iteration relaxes edge .y; ´/
leaving y, causing shortestŒ´ to become 3 and predŒ´ to be set to y.
You can easily see how DAG-SHORTEST-PATHS runs in ‚.n C m/
time. As we saw, step 1 takes ‚.n C m/ time, and of course step 2
initializes two values for each vertex and therefore takes ‚.n/ time.
As we’ve seen before, the outer loop of step 3 examines each vertex
exactly once, and the inner loop of step 3A examines each edge exactly
once over all iterations. Because each call of RELAX in step 3Ai takes
constant time, step 3 takes ‚.nCm/ time. Adding up the running times
for the steps gives us the ‚.n C m/ for the procedure.
Going back to PERT charts, it’s now easy to see that ﬁnding a critical
path takes ‚.n C m/ time, where the PERT chart has n vertices and m
edges. We add the two vertices, start and ﬁnish, and we add at most m
edges leaving start and at most m edges entering ﬁnish, for a total of at
most 3m edges in the dag. Negating the weights and pushing them from
the vertices to the edges takes ‚.m/ time, and then ﬁnding a shortest
path through the resulting dag takes ‚.n C m/ time.

Chapter 5: Directed Acyclic Graphs
89
Further reading
Chapter 22 of CLRS [CLRS09] presents a different algorithm for topo-
logically sorting a dag from the one in this chapter, which appears in
Volume 1 of Knuth’s The Art of Computer Programming [Knu97]. The
method in CLRS is a bit simpler on the surface, but it’s less intuitive
than the approach in this chapter, and it relies on a technique of visit-
ing vertices in a graph known as “depth-ﬁrst search.” The algorithm for
ﬁnding single-source shortest paths in a dag appears in Chapter 24 of
CLRS.
You can read more about PERT charts, which have been in use since
the 1950s, in any one of a number of books about project management.

6
Shortest Paths
In Chapter 5, we saw how to ﬁnd single-source shortest paths in a di-
rected acyclic graph. The algorithm to do so relied on the graph being
acyclic—no cycles—so that we could ﬁrst topologically sort the graph’s
vertices.
Most graphs that model real-life situations have cycles, however. For
example, in a graph that models a road network, each vertex represents
an intersection and each directed edge represents a road that you can
travel in one direction between intersections. (Two-way roads would be
represented by two distinct edges, going in opposite directions.) Such
graphs must have cycles, for otherwise once you left an intersection,
you would have no way to return to it. Therefore, when your GPS is
calculating the shortest or fastest route to a destination, the graph it
works with has cycles, and plenty of them.
When your GPS ﬁnds the fastest route from your current location to a
speciﬁc destination, it is solving the single-pair shortest path problem.
To do so, it probably uses an algorithm that ﬁnds all shortest paths from
a single source, but the GPS pays attention only to the shortest path that
it ﬁnds to the speciﬁc destination.
Your GPS works with a weighted directed graph, where the edge
weights represent either distance or travel time. Because you can’t drive
a negative distance or arrive before you’ve departed, all edge weights in
your GPS’s graph are positive. I suppose that some of them could be 0
for some weird reason, so let’s say that the edge weights are nonnega-
tive. When all edge weights are nonnegative, we don’t have to worry
about negative-weight cycles, and all shortest paths are well deﬁned.
For another example of single-source shortest paths, consider the “six
degrees of Kevin Bacon” game, in which players try to connect movie
actors to Kevin Bacon. In a graph, each vertex represents an actor, and
the graph contains edges .u; v/ and .v; u/ if the actors represented by
vertices u and v have ever appeared in the same ﬁlm. Given some actor,
a player tries to ﬁnd the shortest path from the vertex for that actor to
the vertex for Kevin Bacon. The number of edges in the shortest path
(in other words, the shortest-path weight when each edge weight is 1) is
the actor’s “Kevin Bacon number.” As an example, Ren´ee Ador´ee was

Chapter 6: Shortest Paths
91
in a ﬁlm with Bessie Love, who was in a movie with Eli Wallach, who
made a ﬁlm with Kevin Bacon, and so Ren´ee Ador´ee’s Kevin Bacon
number is 3. Mathematicians have a similar concept in the Erd˝os num-
ber, which gives the shortest path from the great Paul Erd˝os to any other
mathematician by a chain of coauthor relationships.1
What about graphs with negative-weight edges? How do they relate
to the real world? We’ll see that we can couch the problem of deter-
mining whether an arbitrage opportunity exists in currency trading as
determining whether a graph that may have negative-weight edges has
a negative-weight cycle.
In terms of algorithms, ﬁrst we’ll explore Dijkstra’s algorithm for
ﬁnding shortest paths from a single source vertex to all other vertices.
Dijkstra’s algorithm works on graphs that have two important differ-
ences from the graphs we saw in Chapter 5: all edge weights must
be nonnegative, and the graph may contain cycles. It is at the core
of how your GPS ﬁnds routes. We’ll also examine some choices that
we can make when implementing Dijkstra’s algorithm.
Then, we’ll
see the Bellman-Ford algorithm, a remarkably simple method for ﬁnd-
ing single-source shortest paths even when negative-weight edges are
present. We can use the result of the Bellman-Ford algorithm to deter-
mine whether the graph contains a negative-weight cycle and, if it does,
to identify the vertices and edges on the cycle. Both Dijkstra’s algorithm
and the Bellman-Ford algorithm date back to the late 1950s, so they’ve
stood the test of time. We’ll wrap up with the Floyd-Warshall algorithm
for the all-pairs problem, where we want to ﬁnd a shortest path between
every pair of vertices.
Just as we did in Chapter 5 for ﬁnding shortest paths in a dag, we’ll
assume that we are given a source vertex s and the weight weight.u; v/
of each edge .u; v/, and that we want to calculate, for each vertex v,
the shortest-path weight sp.s; v/ from s to v and the vertex preceding v
on some shortest path from s. We’ll store the results in shortestŒv and
predŒv, respectively.
1Believe it or not, there’s even such a thing as an Erd˝os-Bacon number, which is the
sum of the Erd˝os and Bacon numbers, and a handful of people have ﬁnite Erd˝os-Bacon
numbers, including Paul Erd˝os himself!

92
Chapter 6: Shortest Paths
Dijkstra’s algorithm
I like to think of Dijkstra’s algorithm2 as a simulation of sending out
runners over the graph.
Ideally, the simulation works as follows, though we’ll see that Dijk-
stra’s algorithm works slightly differently. It starts by sending out run-
ners from the source vertex to all adjacent vertices. The ﬁrst time a run-
ner arrives at any vertex, runners immediately leave that vertex, headed
to all of its adjacent vertices. Look at part (a) of this ﬁgure:
0
0
(c)
4
0
4
0
5
4
7
0
5
4
8
7
5
4
2
9
7
s
t
x
y
z
(f)
(b)
5
4
2
9
7
s
t
x
y
z
(e)
5
4
2
9
7
s
t
x
y
z
3
3
6
4
(a)
5
4
1
2
9
7
s
t
x
y
z
(d)
5
4
2
9
7
s
t
x
y
z
3
3
6
4
1
3
3
6
4
1
3
3
6
4
1
3
3
6
4
1
5
3
3
6
4
5
4
1
2
9
7
s
t
x
y
z
It shows a directed graph with source vertex s and weights next to the
edges. Think of the weight of an edge as the number of minutes it would
take a runner to traverse the edge.
2Named after Edsger Dijkstra, who proposed the algorithm in 1959.

Chapter 6: Shortest Paths
93
Part (b) illustrates the start of the simulation, at time 0. At that time,
shown inside vertex s, runners leave s and head toward its two adjacent
vertices, t and y. The blackened vertex s indicates that we know that
shortestŒs D 0.
Four minutes later, at time 4, the runner to vertex y arrives, shown
in part (c). Because this runner is the ﬁrst to arrive at y, we know
that shortestŒy D 4, and so y is blackened in the ﬁgure. The shaded
edge .s; y/ indicates that the ﬁrst runner to arrive at vertex y came from
vertex s, so that predŒy D s. At time 4, the runner from vertex s to
vertex t is still in transit, and runners leave vertex y at time 4, headed
toward vertices t, x, and ´.
The next event, displayed in part (d), occurs one minute later, at
time 5, when the runner from vertex y arrives at vertex t. The runner
from s to t has yet to arrive. Because the ﬁrst runner to arrive at vertex t
arrived from vertex y at time 5, we set shortestŒt to 5 and predŒt to y
(indicated by the shaded edge .y; t/). Runners leave vertex t, headed
toward vertices x and y at this time.
The runner from vertex s ﬁnally arrives at vertex t at time 6, but the
runner from vertex y had already arrived there a minute earlier, and so
the effort of the runner from s to t went for naught.
At time 7, depicted in part (e), two runners arrive at their destinations.
The runner from vertex t to vertex y arrives, but the runner from s to y
had already arrived at time 4, and so the simulation forgets about the
runner from t to y. At the same time, the runner from y arrives at
vertex ´. We set shortestŒ´ to 7 and predŒ´ to y, and runners leave
vertex ´, headed toward vertices s and x.
The next event occurs at time 8, as shown in part (f), when the runner
from vertex t arrives at vertex x. We set shortestŒx to 8 and predŒx
to t, and a runner leaves vertex x, heading to vertex ´.
At this point, every vertex has had a runner arrive, and the simulation
can stop. All runners still in transit will arrive at their destination ver-
tices after some other runner had already arrived. Once every vertex has
had a runner arrive, the shortest value for each vertex equals the weight
of the shortest path from vertex s and the pred value for each vertex is
the predecessor on a shortest path from s.
That was how the simulation proceeds ideally. It relied on the time
for a runner to traverse an edge equaling the weight of the edge. Dijk-
stra’s algorithm works slightly differently. It treats all edges the same,
so that when it considers the edges leaving a vertex, it processes the ad-

94
Chapter 6: Shortest Paths
jacent vertices together, and in no particular order. For example, when
Dijkstra’s algorithm processes the edges leaving vertex s in the ﬁgure on
page 92, it declares that shortestŒy D 4, shortestŒt D 6, and predŒy
and predŒt are both s—so far. When Dijkstra’s algorithm later consid-
ers the edge .y; t/, it decreases the weight of the shortest path to vertex t
that it has found so far, so that shortestŒt goes from 6 to 5 and predŒt
switches from s to y.
Dijkstra’s algorithm works by calling the RELAX procedure from
page 86 once per edge. Relaxing an edge .u; v/ corresponds to a runner
from vertex u arriving at vertex v. The algorithm maintains a set Q of
vertices for which the ﬁnal shortest and pred values are not yet known;
all vertices not in Q have their ﬁnal shortest and pred values. After ini-
tializing shortestŒs to 0 for the source vertex s, shortestŒv to 1 for all
other vertices, and predŒv to NULL for all vertices, it repeatedly ﬁnds
the vertex u in set Q with the lowest shortest value, removes that vertex
from Q, and relaxes all the edges leaving u. Here is the procedure:
Procedure DIJKSTRA.G; s/
Inputs:

G: a directed graph containing a set V of n vertices and a set E of
m directed edges with nonnegative weights.

s: a source vertex in V .
Result: For each non-source vertex v in V , shortestŒv is the weight
sp.s; v/ of a shortest path from s to v and predŒv is the vertex
preceding v on some shortest path. For the source vertex s,
shortestŒs D 0 and predŒs D NULL. If there is no path from s to v,
then shortestŒv D 1 and predŒv D NULL. (Same as
DAG-SHORTEST-PATHS on page 87.)
1. Set shortestŒv to 1 for each vertex v except s, set shortestŒs
to 0, and set predŒv to NULL for each vertex v.
2. Set Q to contain all vertices.
3. While Q is not empty, do the following:
A. Find the vertex u in set Q with the lowest shortest value and
remove it from Q.
B. For each vertex v adjacent to u:
i. Call RELAX.u; v/.

Chapter 6: Shortest Paths
95
In the following ﬁgure, each part shows the shortest value (appearing
within each vertex), the pred value (indicated by shaded edges), and
the set Q (the vertices that are shaded, not blackened) just before each
iteration of the loop in step 3.
0
∞
∞
∞
∞
0
∞
∞
(c)
6
4
0
5
4
13
7
0
5
4
8
7
0
5
4
8
7
0
4
8
7
5
5
4
2
9
7
s
t
x
y
z
(f)
5
4
2
9
7
s
t
x
y
z
(b)
5
4
2
9
7
s
t
x
y
z
(e)
5
4
2
9
7
s
t
x
y
z
3
3
6
4
(a)
5
4
1
2
9
7
s
t
x
y
z
(d)
5
4
2
9
7
s
t
x
y
z
3
3
6
4
1
3
3
6
4
1
3
3
6
4
1
3
3
6
4
1
3
3
6
4
1
The vertex that is newly blackened in each part of the ﬁgure is the vertex
chosen as vertex u in step 3A. In the simulation with runners, once a
vertex receives shortest and pred values, they cannot change, but here
a vertex could receive shortest and pred values from relaxing one edge,
and a later relaxation of some other edge could change these values.
For example, after edge .y; x/ is relaxed in part (c) of the ﬁgure, the
value of shortestŒx decreases from 1 to 13, and predŒx becomes y.
The next iteration of the loop in step 3 (part (d)) relaxes edge .t; x/, and
shortestŒx decreases further, to 8, and predŒx becomes t. In the next
iteration (part (e)), edge .´; x/ is relaxed, but this time shortestŒx does
not change, because its value, 8, is less than shortestŒ´ C weight.´; x/,
which equals 12.
Dijkstra’s algorithm maintains the following loop invariant:

96
Chapter 6: Shortest Paths
At the start of each iteration of the loop in step 3, shortestŒv D
sp.s; v/ for each vertex v not in the set Q. That is, for each
vertex v not in Q, the value of shortestŒv is the weight of a
shortest path from s to v.
Here’s a simpliﬁed version of the reasoning behind this loop invari-
ant. (A formal proof is a bit more involved.) Initially, all vertices are
in set Q, and so the loop invariant applies to no vertices upon enter-
ing the ﬁrst iteration of the loop in step 3. Assume that as we enter
an iteration of this loop, all vertices not in the set Q have their correct
shortest-path weights in their shortest values. Then every edge leaving
these vertices has been relaxed in some execution of step 3Bi. Consider
the vertex u in Q with the lowest shortest value. Its shortest value can
never again decrease. Why not? Because the only edges remaining to
be relaxed are edges leaving vertices in Q, and every vertex in Q has
a shortest value at least as large as shortestŒu. Since all edge weights
are nonnegative, we must have shortestŒu  shortestŒvCweight.v; u/
for every vertex v in Q, and so no future relaxation step will decrease
shortestŒu. Therefore, shortestŒu is as low as it can go, and we can
remove vertex u from set Q and relax all edges leaving u. When the
loop of step 3 terminates, the set Q is empty, and so all vertices have
their correct shortest-path weights in their shortest values.
We can begin to analyze the running time of the DIJKSTRA proce-
dure, but to analyze it in full, we are going to have to ﬁrst decide upon
some implementation details. Recall from Chapter 5 that we denote the
number of vertices by n and the number of edges by m, and m  n2.
We know that step 1 takes ‚.n/ time. We also know that the loop of
step 3 iterates exactly n times, because the set Q initially contains all n
vertices, each iteration of the loop removes one vertex from Q, and ver-
tices are never added back into Q. The loop of step 3A processes each
vertex and each edge exactly once over the course of the algorithm (we
saw the same idea in the TOPOLOGICAL-SORT and DAG-SHORTEST-
PATHS procedures in Chapter 5).
What’s left to analyze? We need to understand how long it takes to
put all n vertices into the set Q (step 2), how long it takes to determine
which vertex in Q has the lowest shortest value and remove this vertex
from Q (step 3A), and what bookkeeping adjustments we need to make,
if any, when a vertex’s shortest and pred values change due to calling
RELAX. Let’s name these operations:

Chapter 6: Shortest Paths
97

INSERT.Q; v/ inserts vertex v into set Q. (Dijkstra’s algorithm calls
INSERT n times.)

EXTRACT-MIN.Q/ removes the vertex in Q with the minimum
shortest value and returns this vertex to its caller. (Dijkstra’s al-
gorithm calls EXTRACT-MIN n times.)

DECREASE-KEY.Q; v/ performs whatever bookkeeping is neces-
sary in Q to record that shortestŒv was decreased by a call of RE-
LAX. (Dijkstra’s algorithm calls DECREASE-KEY up to m times.)
These three operations, taken together, deﬁne a priority queue.
The descriptions of the priority queue operations say just what the
operations do, and not how they do it. In software design, separating
what operations do from how they do it is known as abstraction. We
call the set of operations, speciﬁed by what they do but not how they do
it, an abstract data type, or ADT, so that a priority queue is an ADT.
We can implement the priority queue operations—the how—by any
one of several data structures. A data structure is a speciﬁc way to store
and access data in a computer—for example, an array. In the case of pri-
ority queues, we’ll see three different data structures that can implement
the operations. Software designers should be able to plug in any data
structure that implements the operations of an ADT. But it’s not quite
so simple when we think about algorithms. That’s because for different
data structures, the way they implement operations may take differing
amounts of time. Indeed, the three different data structures we’ll see for
implementing the priority queue ADT yield different running times for
Dijkstra’s algorithm.
A rewritten version of the DIJKSTRA procedure, explicitly calling the
priority queue operations, appears on the following page. Let’s examine
the three data structures to implement the priority queue operations and
see how they affect the running time of Dijkstra’s algorithm.
Simple array implementation
The simplest way to implement the priority queue operations is to store
the vertices in an array with n positions. If the priority queue currently
contains k vertices, then they are in the ﬁrst k positions of the array, in
no particular order. Along with the array, we need to maintain a count
of how many vertices it currently contains. The INSERT operation is
easy: just add the vertex to the next unused position in the array and
increment the count. DECREASE-KEY is even easier: do nothing! Both
of these operations take constant time. The EXTRACT-MIN operation

98
Chapter 6: Shortest Paths
Procedure DIJKSTRA.G; s/
Inputs and Result: Same as before.
1. Set shortestŒv to 1 for each vertex v except s, set shortestŒs
to 0, and set predŒv to NULL for each vertex v.
2. Make Q an empty priority-queue.
3. For each vertex v:
A. Call INSERT.Q; v/.
4. While Q is not empty, do the following:
A. Call EXTRACT-MIN.Q/ and set u to hold the returned vertex.
B. For each vertex v adjacent to u:
i. Call RELAX.u; v/.
ii. If the call to RELAX.u; v/ decreased the value of
shortestŒv, then call DECREASE-KEY.Q; v/.
takes O.n/ time, however, since we have to look at all the vertices cur-
rently in the array to ﬁnd the one with the lowest shortest value. Once
we identify this vertex, deleting it is easy: just move the vertex in the last
position into the position of the deleted vertex and then decrement the
count. The n EXTRACT-MIN calls take O.n2/ time. Although the calls
to RELAX take O.m/ time, recall that m  n2. With this implemen-
tation of the priority queue therefore, Dijkstra’s algorithm takes O.n2/
time, with the time dominated by the time spent in EXTRACT-MIN.
Binary heap implementation
A binary heap organizes data as a binary tree stored in an array. A
binary tree is a type of graph, but we refer to its vertices as nodes,
the edges are undirected, and each node has 0, 1, or 2 nodes below it,
which are its children. On the left side of the ﬁgure on the next page is
an example of a binary tree, with the nodes numbered. Nodes with no
children, such as nodes 6 through 10, are leaves.3
3Computer scientists ﬁnd it easier to draw trees with the root at the top and branches
heading downward than to draw them like real trees, with the root at the bottom and
branches heading upward.

Chapter 6: Shortest Paths
99
2
4 14 10 8
18
15
16
11
17
1
2
3
4
5
6
7
8
9
10
1
2
3
4
5
6
7
8
9
10
2
4
8
10
11
18
15
16
14
17
A binary heap is a binary tree with three additional properties. First,
the tree is completely ﬁlled on all levels, except possibly the lowest,
which is ﬁlled from the left up to a point. Second, each node contains
a key, shown inside each node in the ﬁgure. Third, the keys obey the
heap property: the key of each node is less than or equal to the keys of
its children. The binary tree in the ﬁgure is also a binary heap.
We can store a binary heap in an array, as shown on the right in the
ﬁgure. Because of the heap property, the node with the minimum key
must always be at position 1. The children of the node at position i are at
positions 2i and 2i C 1, and the node above the node at position i—its
parent—is at position bi=2c. It is easy to navigate up and down within
a binary heap when we store it in an array.
A binary heap has one other important characteristic: if it consists of
n nodes, then its height—the number of edges from the root down to
the farthest leaf—is only blg nc. Therefore, we can traverse a path from
the root down to a leaf, or from a leaf up to the root, in only O.lg n/
time.
Because binary heaps have height blg nc, we can perform the three
priority queue operations in O.lg n/ time each. For INSERT, add a new
leaf at the ﬁrst available position. Then, as long as the key in the node
is greater than the key in its parent, exchange the contents4 of the node
with the contents of its parent, and move up one level toward the root.
In other words, “bubble up” the contents toward the root until the heap
property holds. Since the path to the root has at most blg nc edges, at
most blg nc  1 exchanges occur, and so INSERT takes O.lg n/ time. To
perform DECREASE-KEY, use the same idea: decrease the key and then
4The contents of a node includes the key and any other information associated with the
key, such as which vertex is associated with this node.

100
Chapter 6: Shortest Paths
bubble up the contents toward the root until the heap property holds,
again taking O.lg n/ time. To perform EXTRACT-MIN, save the con-
tents of the root to return to the caller. Next, take the last leaf (the
highest-numbered node) and put its contents into the root position. Then
“bubble down” the contents of the root, exchanging the contents of the
node and the child whose key is smaller, until the heap property holds.
Finally, return the saved contents of the root. Again, because the path
from the root down to a leaf has at most blg nc edges, at most blg nc  1
exchanges occur, and so EXTRACT-MIN takes O.lg n/ time.
When Dijkstra’s algorithm uses the binary-heap implementation of
a priority queue, it spends O.n lg n/ time inserting vertices, O.n lg n/
time in EXTRACT-MIN operations, and O.m lg n/ time in DECREASE-
KEY operations.
(Actually, inserting the n vertices takes just ‚.n/
time, since initially just the source vertex s has a shortest value of 0
and all other vertices have shortest values of 1.) When the graph is
sparse—the number m of edges is much less than n2—implementing
the priority queue with a binary heap is more efﬁcient than using a sim-
ple array. Graphs that model road networks are sparse, since the average
intersection has about four roads leaving it, and so m would be about 4n.
On the other hand, when the graph is dense—m is close to n2, so that
the graph contains many edges—the O.m lg n/ time that Dijkstra’s al-
gorithm spends in DECREASE-KEY calls can make it slower than using
a simple array for the priority queue.
One other thing about binary heaps: we can use them to sort in
O.n lg n/ time:
Procedure HEAPSORT.A; n/
Inputs:

A: an array.

n: the number of elements in A to sort.
Output: An array B containing the elements of A, sorted.
1. Build a binary heap Q from the elements of A.
2. Let BŒ1 : : n be a new array.
3. For i D 1 to n:
A. Call EXTRACT-MIN.Q/ and set BŒi to the value returned.
4. Return the B array.

Chapter 6: Shortest Paths
101
Step 1 converts the input array into a binary heap, which we can do in
one of two ways. One way is to start with an empty binary heap and
then insert each element of the array, taking O.n lg n/ time. The other
way builds the binary heap directly within the array, working from the
bottom up, taking only O.n/ time. It’s also possible to sort using a heap
in place, so that we don’t need the extra B array.
Fibonacci heap implementation
We can also implement a priority queue by a complicated data struc-
ture called a “Fibonacci heap,” or “F-heap.” With an F-heap, the n
INSERT and EXTRACT-MIN calls take a total of O.n lg n/ time, and the
m DECREASE-KEY calls take a total of ‚.m/ time, and so Dijkstra’s al-
gorithm takes only O.n lg n C m/ time. In practice, people do not often
use F-heaps, for a couple of reasons. One is that an individual operation
might take much longer than the average, although in total the opera-
tions take the times given above. The second reason is that F-heaps are
a bit complicated, and so the constant factors hidden in the asymptotic
notation are not as good as for binary heaps.
The Bellman-Ford algorithm
If some edge weights are negative, then Dijkstra’s algorithm could re-
turn incorrect results. The Bellman-Ford algorithm5 can handle nega-
tive edge weights, and we can use its output to detect and help identify
a negative-weight cycle.
The Bellman-Ford algorithm is remarkably simple. After initializing
the shortest and pred values, it just relaxes all m edges n  1 times.
The procedure appears on the next page, and the ﬁgure below it demon-
strates how the algorithm operates on a small graph. The source vertex
is s, the shortest values appear within the vertices, and the shaded edges
indicate pred values: if edge .u; v/ is shaded, then predŒv D u. In
this example, we assume that each pass over all the edges relaxes them
in the ﬁxed order .t; x/; .t; y/; .t; ´/; .x; t/; .y; x/; .y; ´/; .´; x/; .´; s/;
.s; t/; .s; y/. Part (a) shows the situation just before the ﬁrst pass, and
parts (b) through (e) show the situation after each successive pass. The
shortest and pred values in part (e) are the ﬁnal values.
5Based on separate algorithms by Richard Bellman from 1958 and Lester Ford
from 1962.

102
Chapter 6: Shortest Paths
Procedure BELLMAN-FORD.G; s/
Inputs:

G: a directed graph containing a set V of n vertices and a set E of
m directed edges with arbitrary weights.

s: a source vertex in V .
Result: Same as DIJKSTRA (page 94).
1. Set shortestŒv to 1 for each vertex v except s, set shortestŒs
to 0, and set predŒv to NULL for each vertex v.
2. For i D 1 to n  1:
A. For each edge .u; v/ in E:
i. Call RELAX.u; v/.
(a)
(b)
(c)
(d)
0
5
9
7
8
6
7
(e)
t
x
s
y
z
 –4
 –3
 –2
2
7
4
–2
2
0
5
9
7
8
6
7
t
x
s
y
z
 –4
 –3
 –2
2
7
4
2
2
0
5
9
7
8
6
7
t
x
s
y
z
 –4
 –3
 –2
6
7
4
2
2
0
5
9
7
8
6
7
t
x
s
y
z
 –4
 –3
 –2
6
7
∞
∞
2
0
5
9
7
8
6
7
t
x
s
y
z
 –4
 –3
 –2
∞
∞
2
∞
∞

Chapter 6: Shortest Paths
103
How can an algorithm this simple possibly produce the right answer?
Consider a shortest path from the source s to any vertex v. Recall from
page 86 that if we relax the edges, in order, along a shortest path from s
to v, then shortestŒv and predŒv are correct. Now, if negative-weight
cycles are disallowed, then there is always a shortest path from s to v
that does not contain a cycle. Why? Suppose that a shortest path from s
to v contains a cycle. Because the cycle must have nonnegative weight,
we could excise the cycle and end up with a path from s to v whose
weight is no higher than the path containing the cycle. Every acyclic
path must contain at most n  1 edges, for if a path contains n edges
then it must visit some vertex twice, which would make a cycle. Thus,
if there is a shortest path from s to v, then there is one that contains at
most n  1 edges. The ﬁrst time that step 2A relaxes all edges, it must
relax the ﬁrst edge on this shortest path. The second time that step 2A
relaxes all edges, it must relax the second edge on the shortest path,
and so on. After the .n  1/st time, all edges on the shortest path have
been relaxed, in order, and therefore shortestŒv and predŒv are correct.
Pretty slick!
Now suppose that the graph contains a negative-weight cycle and
we’ve already run the BELLMAN-FORD procedure on it. You can go
around and around a negative-weight cycle, getting a lower-weight path
each time around. That means that there is at least one edge .u; v/ on
the cycle for which shortestŒv will decrease if you relax it again—even
though this edge has already been relaxed n  1 times.
So here’s how to ﬁnd a negative-weight cycle, if one exists, after run-
ning BELLMAN-FORD. Go through the edges once again. If we ﬁnd an
edge .u; v/ for which shortestŒu C weight.u; v/ < shortestŒv, then we
know that vertex v is either on a negative-weight cycle or is reachable
from one. We can ﬁnd a vertex on the negative-weight cycle by tracing
back the pred values from v, keeping track of which vertices we’ve vis-
ited until we reach a vertex x that we’ve visited before. Then we can
trace back pred values from x until we get back to x, and all vertices
in between, along with x, will constitute a negative-weight cycle. The
procedure FIND-NEGATIVE-WEIGHT-CYCLE on the next page shows
how to determine whether a graph has a negative-weight cycle, and how
to construct one if it does.
It’s easy to analyze the running time of the Bellman-Ford algorithm.
The loop of step 2 iterates n  1 times, and each time it runs, the loop
of step 2A iterates m times, once per edge. The total running time,

104
Chapter 6: Shortest Paths
Procedure FIND-NEGATIVE-WEIGHT-CYCLE.G/
Input: G: a directed graph containing a set V of n vertices and a
set E of m directed edges with arbitrary weights on which the
BELLMAN-FORD procedure has already been run.
Output: Either a list of vertices in a negative-weight cycle, in order, or
an empty list if the graph has no negative-weight cycles.
1. Go through all edges to ﬁnd any edge .u; v/ such that
shortestŒu C weight.u; v/ < shortestŒv.
2. If no such edge exists, then return an empty list.
3. Otherwise (there is some edge .u; v/ for which
shortestŒu C weight.u; v/ < shortestŒv), do the following:
A. Let visited be a new array with one element for each vertex.
Set all elements of visited to FALSE.
B. Set x to v.
C. While visitedŒx is FALSE, do the following:
i. Set visitedŒx to TRUE.
ii. Set x to predŒx
D. At this point, we know that x is a vertex on a negative-weight
cycle. Set v to predŒx.
E. Create a list cycle of vertices initially containing just x.
F. While v is not x, do the following:
i. Insert vertex v at the beginning of cycle.
ii. Set v to predŒv.
G. Return cycle.
therefore, is ‚.nm/. To ﬁnd whether a negative-weight cycle exists,
relax each edge once more until either relaxing changes a shortest value
or all edges have been relaxed, taking O.m/ time. If there is a negative-
weight cycle, it can contain at most n edges, and so the time to trace it
out is O.n/.
At the beginning of this chapter, I promised to show how negative-
weight cycles relate to arbitrage opportunities in currency trading. Ex-
change rates for currencies ﬂuctuate rapidly. Imagine that at some mo-
ment in time, the following exchange rates are in effect:

Chapter 6: Shortest Paths
105
1 U.S. dollar buys 0:7292 euros
1 euro buys 105:374 Japanese yen
1 Japanese yen buys 0:3931 Russian rubles
1 Russian ruble buys 0:0341 U.S. dollars
Then you could take 1 U.S. dollar, buy 0:7292 euros with it, take
the 0:7292 euros and buy 76:8387 yen (because 0:7292  105:374 D
76:8387, to four decimal places), take the 76:8387 yen and buy 30:2053
rubles (because 76:8387  0:3931 D 30:2053, to four decimal places),
and ﬁnally take the 30:2053 rubles and buy 1:03 dollars (because
30:2053  0:0341 D 1:0300, to four decimal places). If you could per-
form all four transactions before the exchange rates change, you could
make a 3% return on your 1-dollar investment. Start with one million
dollars, and you make a 30-thousand-dollar proﬁt for doing nothing!
Such a scenario is an arbitrage opportunity. Here’s how to ﬁnd an
arbitrage opportunity by ﬁnding a negative-weight cycle. Suppose that
you’re looking at n currencies c1; c2; c3; : : : ; cn, and you have all the
exchange rates between pairs of currencies. Suppose that with 1 unit
of currency ci you can buy rij units of currency cj, so that rij is the
exchange rate between currencies ci and cj. Here, both i and j range
from 1 to n. (Presumably, rii D 1 for each currency ci.)
An arbitrage opportunity would correspond to a sequence of k curren-
cies hcj1;cj2;cj3;: : : ;cjki such that when you multiply out the exchange
rates, you get a product strictly greater than 1:
rj1;j2  rj2;j3    rjk1;jk  rjk;j1 > 1 :
Now take logarithms of both sides. It doesn’t matter what base we use,
so let’s make like computer scientists and use base 2. Because the log-
arithm of a product is the sum of the individual logarithms—that is,
lg.x  y/ D lg x C lg y—we’re looking for a situation in which
lg rj1;j2 C lg rj2;j3 C    C lg rjk1;jk C lg rjk;j1 > 0 :
Negating both sides of this inequality gives
. lg rj1;j2/ C . lg rj2;j3/ C    C . lg rjk1;jk/ C . lg rjk;j1/ < 0 ;
which corresponds to a cycle with edge weights that are the negatives
of the logarithms of the exchange rates.
To ﬁnd an arbitrage opportunity, if one exists, construct a directed
graph with one vertex vi for each currency ci. For each pair of curren-
cies ci and cj, create directed edges .vi; vj / and .vj; vi/ with weights

106
Chapter 6: Shortest Paths
 lg rij and  lg rji, respectively. Add a new vertex s with a 0-weight
edge .s; vi/ to each of the vertices v1 through vn. Run the Bellman-Ford
algorithm on this graph with s as the source vertex, and use the result to
determine whether it contains a negative-weight cycle. If it does, then
the vertices on that cycle correspond to the currencies in an arbitrage
opportunity. The total number of edges m is n C n.n  1/ D n2, and
so the Bellman-Ford algorithm takes O.n3/ time, plus another O.n2/ to
ﬁnd whether there is a negative-weight cycle, and another O.n/ to trace
it out, if one exists. Although O.n3/ time seems slow, in practice it’s
not so bad because the constant factors in the running times of the loops
are low. I coded up the arbitrage program on my 2.4-GHz MacBook Pro
and ran it with 182 currencies, which is how many the entire world has.
Once I had loaded in the exchange rates (I chose random values for the
exchange rates), the program took approximately 0:02 seconds to run.
The Floyd-Warshall algorithm
Now suppose that you want to ﬁnd a shortest path from every vertex to
every vertex. That’s the all-pairs shortest-paths problem.
The classic example of all-pairs shortest paths—which I have seen
several authors refer to—is the table that you see in a road atlas giving
distances between several cities. You ﬁnd the row for one city, you ﬁnd
the column for the other city, and the distance between them lies at the
intersection of the row and column.
There is one problem with this example: it’s not all-pairs. If it were
all pairs, the table would have one row and one column for every inter-
section, not for just every city. The number of rows and columns for just
the U.S. would be in the millions. No, the way to make the table you
see in an atlas is to ﬁnd single-source shortest paths from each city and
then put a subset of the results—shortest paths to just the other cities,
not to all intersections—into the table.
What would be a legitimate application of all-pairs shortest paths?
Finding the diameter of a network: the longest of all shortest paths. For
example, suppose that a directed graph represents a communication net-
work, and the weight of an edge gives the time it takes for a message to
traverse a communication link. Then the diameter gives you the longest
possible transit time for a message in the network.
Of course, we can compute all-pairs shortest paths by computing
single-source shortest paths from each vertex in turn. If all edge weights
are nonnegative, we can run Dijkstra’s algorithm from each of the n

Chapter 6: Shortest Paths
107
vertices, each call taking O.m lg n/ time if we use a binary heap or
O.n lg n C m/ time if we use a Fibonacci heap, for a total running time
of either O.nm lg n/ or O.n2 lg nCnm/. If the graph is sparse, that ap-
proach works well. But if the graph is dense, so that m is near n2, then
O.nm lg n/ is O.n3 lg n/. Even with a dense graph and a Fibonacci
heap, O.n2 lg n C mn/ is O.n3/, and the constant factor induced by the
Fibonacci heap can be signiﬁcant. Of course, if the graph may contain
negative-weight edges, then we cannot use Dijkstra’s algorithm, and
running the Bellman-Ford algorithm from each of n vertices on a dense
graph gives a running time of ‚.n2m/, which is ‚.n4/.
Instead, by using the Floyd-Warshall algorithm,6 we can solve the all-
pairs problem in ‚.n3/ time—regardless of whether the graph is sparse,
dense, or in between, and even allowing the graph to have negative-
weight edges but no negative-weight cycles—and the constant factor
hidden in the ‚-notation is small. Moreover, the Floyd-Warshall al-
gorithm illustrates a clever algorithmic technique called “dynamic pro-
gramming.”
The Floyd-Warshall algorithm relies on an obvious property of short-
est paths. Suppose that you’re driving from New York City to Seattle
along a shortest route, and that this shortest route from New York to
Seattle passes through Chicago and then through Spokane before arriv-
ing at Seattle. Then the portion of the shortest route from New York
to Seattle that goes from Chicago to Spokane must itself be a shortest
route from Chicago to Spokane. Why is that? Because if there were a
shorter route from Chicago to Spokane, we would have used it in the
shortest route from New York to Seattle! Like I said, obvious. To apply
this principle to directed graphs:
If a shortest path, call it p, from vertex u to vertex v goes from
vertex u to vertex x to vertex y to vertex v, then the portion of p
that is between x and y is itself a shortest path from x to y. That
is, any subpath of a shortest path is itself a shortest path.
The Floyd-Warshall algorithm keeps track of path weights and vertex
predecessors in arrays indexed in not just one dimension, but in three
dimensions. You can think of a one-dimensional array as a table, just
as we saw on page 11. A two-dimensional array would be like a ma-
trix, such as the adjacency matrix on page 79; you need two indices
6Named after Robert Floyd and Stephen Warshall.

108
Chapter 6: Shortest Paths
(row and column) to identify an entry. You can also think of a two-
dimensional array as a one-dimensional array in which each entry is
itself a one-dimensional array. A three-dimensional array would be like
a one-dimensional array of two-dimensional arrays; you need an index
in each of the three dimensions to identify an entry. We’ll use com-
mas to separate the dimensions when indexing into a multidimensional
array.
In the Floyd-Warshall algorithm, we assume that the vertices are
numbered from 1 to n. Vertex numbers become important, because the
Floyd-Warshall algorithm uses the following deﬁnition:
shortestŒu; v; x is the weight of a shortest path from vertex u to
vertex v in which each intermediate vertex—a vertex on the path
other than u and v—is numbered from 1 to x.
(So think of u, v, and x as integers in the range 1 to n that represent ver-
tices.) This deﬁnition does not require the intermediate vertices to con-
sist of all x vertices numbered 1 to x; it just requires each intermediate
vertex—however many there are—to be numbered x or lower. Since all
vertices are numbered at most n, it must be the case that shortestŒu; v; n
equals sp.u; v/, the weight of a shortest path from u to v.
Let’s consider two vertices u and v, and pick a number x in the range
from 1 to n. Consider all paths from u to v in which all intermediate
vertices are numbered at most x. Of all these paths, let path p be one
with minimum weight. Path p either contains vertex x or it does not,
and we know that, other than possibly u or v, it does not contain any
vertex numbered higher than x. There are two possibilities:

First possibility: x is not an intermediate vertex in path p. Then all
intermediate vertices of path p are numbered at most x  1. What
does this mean? It means that the weight of a shortest path from u
to v with all intermediate vertices numbered at most x is the same
as the weight of a shortest path from u to v with all intermediate
vertices numbered at most x  1. In other words, shortestŒu; v; x
equals shortestŒu; v; x  1.

Second possibility: x appears as an intermediate vertex in path p.
Because any subpath of a shortest path is itself a shortest path, the
portion of path p that goes from u to x is a shortest path from u
to x. Likewise, the portion of p that goes from x to v is a shortest
path from x to v. Because vertex x is an endpoint of each of these
subpaths, it is not an intermediate vertex in either of them, and so

Chapter 6: Shortest Paths
109
the intermediate vertices in each of these subpaths are all numbered
at most x  1. Therefore, the weight of a shortest path from u to v
with all intermediate vertices numbered at most x is the sum of the
weights of two shortest paths: one from u to x with all intermediate
vertices numbered at most x  1, and one from x to v, also with
all intermediate vertices numbered at most x  1. In other words,
shortestŒu; v; x equals shortestŒu; x; x  1 C shortestŒx; v; x  1.
Because either x is an intermediate vertex in a shortest path from u
to v or it’s not, we can conclude that shortestŒu; v; x is the smaller of
shortestŒu; x; x  1 C shortestŒx; v; x  1 and shortestŒu; v; x  1.
The best way to represent the graph in the Floyd-Warshall algorithm
is by a variant of the adjacency-matrix representation from pages 78–79.
Instead of each matrix element being constrained to 0 or 1, the entry for
edge .u; v/ holds the weight of the edge, with a weight of 1 indicating
that the edge is absent. Since shortestŒu; v; 0 denotes the weight of
a shortest path from u to v with all intermediate vertices numbered at
most 0, such a path has no intermediate vertices. That is, it consists
of just a single edge, and so this matrix is exactly what we want for
shortestŒu; v; 0.
Given the shortestŒu; v; 0 values (which are the edge weights), the
Floyd-Warshall algorithm computes shortestŒu; v; x values ﬁrst for all
pairs of vertices u and v with x set to 1. Then the algorithm computes
shortestŒu; v; x values for all pairs of vertices u and v with x set to 2.
Then for x set to 3, and so on, up through n.
How about keeping track of predecessors? Let’s deﬁne predŒu; v; x
analogously to how we deﬁned shortestŒu; v; x, as the predecessor of
vertex v on a shortest path from vertex u in which all intermediate ver-
tices are numbered at most x. We can update the predŒu; v; x values as
we compute the shortestŒu; v; x values, as follows. If shortestŒu; v; x
is the same as shortestŒu; v; x  1, then the shortest path that we’ve
found from u to v with all intermediate vertices numbered at most x
is the same as the one with all intermediate vertices numbered at
most x  1. Vertex v’s predecessor must be the same in both paths,
and so we can set predŒu; v; x to be the same as predŒu; v; x 1. What
about when shortestŒu; v; x is less than shortestŒu; v; x 1? That hap-
pens when we ﬁnd a path from u to v that has vertex x as an intermediate
vertex and has lower weight than the shortest path from u to v with all
intermediate vertices numbered at most x 1. Because x must be an in-
termediate vertex on this newly found shortest path, v’s predecessor on

110
Chapter 6: Shortest Paths
the path from u must be the same as v’s predecessor on the path from x.
In this case, we set predŒu; v; x to be the same as predŒx; v; x  1.
We now have all the pieces we need to assemble the Floyd-Warshall
algorithm. Here’s the procedure:
Procedure FLOYD-WARSHALL.G/
Input: G: a graph represented by a weighted adjacency matrix W
with n rows and n columns (one row and one column per vertex).
The entry in row u and column v, denoted wuv, is the weight of
edge .u; v/ if this edge is present in G, and it is 1 otherwise.
Output: For each pair of vertices u and v, the value of shortestŒu; v; n
contains the weight of a shortest path from u to v, and predŒu; v; n is
the predecessor vertex of v on a shortest path from u.
1. Let shortest and pred be new n  n  .n C 1/ arrays.
2. For each u and v from 1 to n:
A. Set shortestŒu; v; 0 to wuv.
B. If .u; v/ is an edge in G, then set predŒu; v; 0 to u. Otherwise,
set predŒu; v; 0 to NULL.
3. For x D 1 to n:
A. For u D 1 to n:
i. For v D 1 to n:
a. If shortestŒu; v; x < shortestŒu; x; x  1 C
shortestŒx; v; x  1, then set shortestŒu; v; x to
shortestŒu; x; x  1 C shortestŒx; v; x  1 and set
predŒu; v; x to predŒx; v; x  1.
b. Otherwise, set shortestŒu; v; x to shortestŒu; v; x  1
and set predŒu; v; x to predŒu; v; x  1.
4. Return the shortest and pred arrays.
For this graph
1
2
4
3
3
8
1
4
–5
2
the adjacency matrix W , containing the edge weights, is

Chapter 6: Shortest Paths
111
0
BB@
0
3
8
1
1
0
1
1
1
4
0
1
2
1
5
0
1
CCA ;
which also gives the shortestŒu; v; 0 values7 (the weights of paths with
at most one edge). For example, shortestŒ2; 4; 0 is 1, because we can
get from vertex 2 to vertex 4 directly, with no intermediate vertices, by
taking edge .2; 4/ with weight 1. Similarly, shortestŒ4; 3; 0 is 5. Here
is a matrix giving the predŒu; v; 0 values:
0
BB@
NULL
1
1
NULL
NULL
NULL
NULL
2
NULL
3
NULL
NULL
4
NULL
4
NULL
1
CCA :
For example, predŒ2; 4; 0 is 2 because the predecessor of vertex 4 is
vertex 2, using the edge .2; 4/, with weight 1, and predŒ2; 3; 0 is NULL
because there is no edge .2; 3/.
After running the loop of step 3 for x D 1 (to examine paths that
may include vertex 1 as an intermediate vertex), the shortestŒu; v; 1
and predŒu; v; 1 values are
0
BB@
0
3
8
1
1
0
1
1
1
4
0
1
2
5
5
0
1
CCA and
0
BB@
NULL
1
1
NULL
NULL
NULL
NULL
2
NULL
3
NULL
NULL
4
1
4
NULL
1
CCA :
After the loop runs for x D 2, the shortestŒu; v; 2 and predŒu; v; 2
values are
0
BB@
0
3
8
4
1
0
1
1
1
4
0
5
2
5
5
0
1
CCA and
0
BB@
NULL
1
1
2
NULL
NULL
NULL
2
NULL
3
NULL
2
4
1
4
NULL
1
CCA :
After x D 3:
0
BB@
0
3
8
4
1
0
1
1
1
4
0
5
2
1
5
0
1
CCA and
0
BB@
NULL
1
1
2
NULL
NULL
NULL
2
NULL
3
NULL
2
4
3
4
NULL
1
CCA :
7Because a three-dimensional array is a one-dimensional array of two-dimensional ar-
rays, for a ﬁxed value of x we can think of shortestŒu; v; x as a two-dimensional array.

112
Chapter 6: Shortest Paths
And our ﬁnal shortestŒu; v; 4 and predŒu; v; 4 values, after running the
loop for x D 4, are
0
BB@
0
3
1
4
3
0
4
1
7
4
0
5
2
1
5
0
1
CCA and
0
BB@
NULL
1
4
2
4
NULL
4
2
4
3
NULL
2
4
3
4
NULL
1
CCA :
We can see, for example, that the shortest path from vertex 1 to ver-
tex 3 has weight 1. This path goes from vertex 1 to vertex 2 to ver-
tex 4 to vertex 3, which we can see by tracing back: predŒ1; 3; 4 is 4,
predŒ1; 4; 4 is 2, and predŒ1; 2; 4 is 1.
I claimed that the Floyd-Warshall algorithm runs in ‚.n3/ time, and
it’s easy to see why. We have nested loops three deep, and each one
iterates n times. In each iteration of the loop of step 3, the loop of
step 3A iterates all n times. Likewise, in each iteration of the loop of
step 3A, the loop of step 3Ai iterates all n times. Since the outer loop
of step 3 also iterates n times, the innermost loop (step 3Ai) iterates n3
times in all. Each iteration of the innermost loop takes constant time,
and so the algorithm takes ‚.n3/ time.
It looks as though this algorithm also takes ‚.n3/ space in memory.
After all, it creates two n  n  .n C 1/ arrays. Since each array entry
uses a constant amount of memory, these arrays occupy ‚.n3/ mem-
ory space. It turns out, however, that we can get away with only ‚.n2/
space in memory. How? Just create shortest and pred as n  n arrays,
and forget about the third index into shortest and pred everywhere. Al-
though steps 3Aia and 3Aib keep updating the same shortestŒu; v and
predŒu; v values, these arrays turn out to have the correct values at the
end!
Earlier, I mentioned that the Floyd-Warshall algorithm illustrates a
technique called dynamic programming. This technique applies only
when
1. we are trying to ﬁnd an optimal solution to a problem,
2. we can break an instance of the problem into instances of one or
more subproblems,
3. we use solutions to the subproblem(s) to solve the original problem,
and
4. if we use a solution to a subproblem within an optimal solution to
the original problem, then the subproblem solution we use must be
optimal for the subproblem.

Chapter 6: Shortest Paths
113
We can summarize these conditions under the umbrella name of optimal
substructure and, put more succinctly, it says that an optimal solution
to a problem contains within it optimal solutions to subproblems. In dy-
namic programming, we have some notion of the “size” of a subprob-
lem, and we often solve the subproblems in increasing order of size,
so that we solve the smallest subproblems ﬁrst, and then once we have
optimal solutions to smaller subproblems, we can try to solve larger sub-
problems optimally using optimal solutions to the smaller subproblems.
This description of dynamic programming sounds rather abstract, so
let’s see how the Floyd-Warshall algorithm uses it. We state a subprob-
lem as
Compute shortestŒu; v; x, which is the weight of a shortest path
from vertex u to vertex v in which each intermediate vertex is
numbered from 1 to x.
Here, the “size” of a subproblem is the highest-numbered vertex that
we allow to be an intermediate vertex of a shortest path: in other words,
the value of x. Optimal substructure comes into play because of the
following property:
Consider a shortest path p from vertex u to vertex v, and let x be
the highest-numbered intermediate vertex on this path. Then the
portion of p that goes from u to x is a shortest path from u to x
with all intermediate vertices numbered from 1 to x  1, and the
portion of p that goes from x to v is a shortest path from x to v
with all intermediate vertices numbered from 1 to x  1.
We solve the problem of computing shortestŒu; v; x by ﬁrst computing
shortestŒu; v; x  1, shortestŒu; x; x  1, and shortestŒx; v; x  1 and
then using the lesser of shortestŒu; v; x  1 and shortestŒu; x; x  1 C
shortestŒx; v; x  1. Because we have computed all the shortest values
where the third index is x  1 before we try to compute any of the
shortest values where the third index is x, we have all the information
we need when we compute shortestŒu; v; x.
A common practice in dynamic programming is to store optimal so-
lutions to subproblems (shortestŒu; v; x  1, shortestŒu; x; x  1, and
shortestŒx; v; x  1) in a table and then look them up as we compute
an optimal solution to the original problem (shortestŒu; v; x). We call
such an approach “bottom up,” since it works from smaller subproblems
to larger subproblems. Another approach is to solve subproblems “top

114
Chapter 6: Shortest Paths
down,” working from larger subproblems to smaller ones, again storing
the result of each subproblem in a table.
Dynamic programming applies to a wide range of optimization prob-
lems, only some of which have to do with graphs. We’ll see it again
in Chapter 7, when we ﬁnd the longest common subsequence of two
strings of characters.
Further reading
Chapter 24 of CLRS [CLRS09] covers Dijkstra’s algorithm and the
Bellman-Ford algorithm. Chapter 25 of CLRS covers all-pairs shortest-
paths algorithms, including Floyd-Warshall; an all-pairs shortest-paths
algorithm based on matrix multiplication, running in ‚.n3 lg n/ time;
and a clever algorithm by Donald Johnson, designed to ﬁnd all-pairs
shortest paths on sparse graphs in O.n2 lg n C nm/ time.
When edge weights are small nonnegative integers no greater than
a known amount C, a more complex implementation of the priority
queue in Dijkstra’s algorithm yields better asymptotic running times
than a Fibonacci heap. For example, Ahuja, Mehlhorn, Orlin, and Tar-
jan [AMOT90] incorporate a “redistributive heap” into Dijkstra’s algo-
rithm, giving a running time of O.m C n
p
lg C/.

7
Algorithms on Strings
A string is just a sequence of characters from some underlying char-
acter set. For example, this book comprises characters from the set of
letters, digits, punctuation symbols, and mathematical symbols, which
is a rather large, but ﬁnite, character set. Biologists encode strands of
DNA as strings over just four characters—A, C, G, T—which represent
the base molecules adenine, cytosine, guanine, and thymine.
We can ask all sorts of questions about strings, but in this chapter
we’ll focus on algorithms for three problems that take strings as inputs:
1. Find a longest common subsequence of two strings.
2. Given a set of operations that can transform one string to another,
and the cost of each operation, ﬁnd a lowest-cost way to transform
one string to another.
3. Find all occurrences of a pattern string within a string of text.
The ﬁrst two of these problems have applications in computational bi-
ology. The longer a common subsequence we can ﬁnd between two
strands of DNA, the more similar they are. One way to align strands of
DNA is to transform one strand to another; the lower the cost of trans-
forming, the more similar the strands. The last problem, ﬁnding occur-
rences of a pattern within a text, is also known as string matching. It
comes up in all sorts of programs, such as any time you use a “Find”
command. It also comes up in computational biology, because we can
look for one strand of DNA within another.
Longest common subsequence
Let’s start with what we mean by “sequence” and “subsequence.” A
sequence is a list of items in which the order of items matters. A given
item may appear in a sequence multiple times. The particular sequences
we’ll be working with in this chapter are strings of characters, and we’ll
use the term “string” instead of “sequence.” Likewise, we will assume
that the items making up a sequence are characters. For example, the
string GACA contains the same character (A) multiple times, and it dif-
fers from the string CAAG, which has the same population of characters

116
Chapter 7: Algorithms on Strings
but in a different order. A subsequence Z of a string X is X, possibly
with items removed. For example, if X is the string GAC, then it has
eight subsequences: GAC (no characters removed), GA (C removed),
GC (A removed), AC (G removed), G (A and C removed), A (G and C
removed), C (G and A removed), and the empty string (all characters
removed). If X and Y are strings, then Z is a common subsequence
of X and Y if it is a subsequence of both of them. For example, if X
is the string CATCGA and Y is the string GTACCGTCA, then CCA is a
common subsequence of X and Y consisting of three characters. It is
not a longest common subsequence (LCS), however, since the com-
mon subsequence CTCA has four characters. Indeed CTCA is a longest
common subsequence, but it is not unique, since TCGA is another com-
mon subsequence with four characters. The notions of subsequence and
substring differ: a substring is a subsequence of a string in which the
characters must be drawn from contiguous positions in the string. For
the string CATCGA, the subsequence ATCG is a substring but the sub-
sequence CTCA is not.
Our goal is, given two strings X and Y, to ﬁnd a longest common
subsequence Z of X and Y. We will use the technique of dynamic
programming, which we saw in Chapter 6, to solve this problem.
You can ﬁnd a longest common subsequence without resorting to dy-
namic programming, but I don’t recommend it. You could try each sub-
sequence of X and check whether it’s a subsequence of Y, working from
the longest to the smallest subsequences of X, checking each against Y
and stopping once you ﬁnd a subsequence of both X and Y. (You know
that you’ll eventually ﬁnd one, since the empty string is a subsequence
of all strings.) If X has length m, then it has 2m subsequences, and so
even if we ignore the time to check each subsequence against Y, the
time to ﬁnd an LCS would be at least exponential in the length of X in
the worst case.
Recall from Chapter 6 that in order for dynamic programming to ap-
ply, we need optimal substructure: an optimal solution to a problem
contains optimal solutions to its subproblems. To ﬁnd an LCS of two
strings via dynamic programming, we ﬁrst need to decide what consti-
tutes a subproblem. Preﬁxes work. If X is a string x1x2x3    xm, then
the ith preﬁx of X is the string x1x2x3    xi, and we denote it by Xi.
Here, we require that i be in the range 0 to m, and X0 is the empty
string. For example, if X is CATCGA, then X4 is CATC.

Chapter 7: Algorithms on Strings
117
We can see that an LCS of two strings contains within it an LCS
of the preﬁxes of the two strings.
Let’s consider two strings X D
x1x2x3    xm and Y D y1y2y3    yn. They have some LCS, say Z,
where Z D ´1´2´3    ´k for some length k, which could be anywhere
from 0 to the smaller of m and n. What can we deduce about Z? Let’s
look at the last characters in X and Y : xm and yn. Either they are equal
or they’re not.

If they’re equal, then the last character ´k of Z must be the same
as that character. What do we know about the rest of Z, which is
Zk1 D ´1´2´3    ´k1? We know that Zk1 must be an LCS of
what remains of X and Y, namely Xm1 D x1x2x3    xm1 and
Yn1 D y1y2y3    yn1. From our example before—where X D
CATCGA and Y D GTACCGTCA and an LCS is Z D CTCA—the
last character, A, of X and Y is the last character of Z, and we
see that Z3 D CTC must be an LCS of X5 D CATCG and Y8 D
GTACCGTC.

If they’re not equal, then ´k might be the same as either the last
character xm of X or the last character yn of Y, but not of both. Or
it might not be the same as the last character of either X or Y. If ´k
is not the same as xm, ignore the last character of X: Z must be an
LCS of Xm1 and Y. Similarly, if ´k is not the same as yn, ignore the
last character of Y : Z must be an LCS of X and Yn1. Continuing
the example from above, let X D CATCG, Y D GTACCGTC, and
Z D CTC. Here, ´3 is the same as y8 (C) but not x5 (G), and so Z is
an LCS of X4 D CATC and Y.
Therefore, this problem has optimal substructure: an LCS of two strings
contains within it an LCS of the preﬁxes of the two strings.
How to proceed? We need to solve either one or two subproblems,
depending on whether the last characters of X and Y are the same. If
they are, then we solve just one subproblem—ﬁnd an LCS of Xm1
and Yn1—and then append that last character to get an LCS of X
and Y. If the last characters of X and Y are not the same, then we
have to solve two subproblems—ﬁnd an LCS of Xm1 and Y, and ﬁnd
an LCS of X and Yn1—and use the longer of these two longest com-
mon subsequences as an LCS of X and Y. If these two longest common
subsequences have the same length, then use either one of them—it
doesn’t matter which.
We will approach the problem of ﬁnding an LCS of X and Y in two
steps. First, we’ll ﬁnd the length of an LCS of X and Y, as well as

118
Chapter 7: Algorithms on Strings
the lengths of the longest common subsequences of all preﬁxes of X
and Y. You might be surprised that we can ﬁnd the length of an LCS
without knowing what the LCS is. After computing the LCS lengths,
we will “reverse engineer” how we computed these lengths to ﬁnd an
actual LCS of X and Y.
To make things a little more precise, let’s denote the length of an
LCS of the preﬁxes Xi and Yj by lŒi; j . The length of an LCS of X
and Y is given by lŒm; n. We can start the indices i and j at 0, since
if either of the preﬁxes has length 0, then we know their LCS: it’s an
empty string. In other words, lŒ0; j  and lŒi; 0 equal 0 for all values
of i and j . When both i and j are positive, we determine lŒi; j  by
looking at smaller values of i and/or j :

If i and j are positive and xi is the same as yj, then lŒi; j  equals
lŒi  1; j  1 C 1.

If i and j are positive and xi differs from yj, then lŒi; j  equals the
larger of lŒi; j  1 and lŒi  1; j .
Think of the values of lŒi; j  as being stored in a table. We need to
compute these values in increasing order of the indices i and j . Here’s
the lŒi; j  table for our example strings (we’ll see what the shaded parts
mean a little later):
j
0
1
2
3
4
5
6
7
8
9
yj
G
T
A
C
C
G
T
C
A
i
xi
lŒi; j
0
0
0
0
0
0
0
0
0
0
0
1
C
0
0
0
0
1
1
1
1
1
1
2
A
0
0
0
1
1
1
1
1
1
2
3
T
0
0
1
1
1
1
1
2
2
2
4
C
0
0
1
1
2
2
2
2
3
3
5
G
0
1
1
1
2
2
3
3
3
3
6
A
0
1
1
2
2
2
3
3
3
4
For example, lŒ5; 8 is 3, meaning that an LCS of X5 D CATCG and
Y8 D GTACCGTC has length 3, as we saw on page 117.
In order to compute table values in increasing order of the indices,
before we compute a particular entry lŒi; j , where both i and j are
positive, we need to compute the entries lŒi; j  1 (immediately left
of lŒi; j ), lŒi  1; j  (immediately above lŒi; j ), and lŒi  1; j  1

Chapter 7: Algorithms on Strings
119
(above and to the left of lŒi; j ).1 It’s easy to compute the table entries
in this way: we can compute them either row by row, from left to right
within each row, or column by column, from top to bottom within each
column.
The procedure that follows treats the table as a two-dimensional array
lŒ0 : : m; 0 : : n. After ﬁlling the leftmost column and top row with 0s, it
then ﬁlls the remainder of the array row by row.
Procedure COMPUTE-LCS-TABLE.X; Y /
Inputs: X and Y : two strings of length m and n, respectively.
Output: The array lŒ0 : : m; 0 : : n. The value of lŒm; n is the length
of a longest common subsequence of X and Y.
1. Let lŒ0 : : m; 0 : : n be a new array.
2. For i D 0 to m:
A. Set lŒi; 0 to 0.
3. For j D 0 to n:
A. Set lŒ0; j  to 0.
4. For i D 1 to m:
A. For j D 1 to n:
i. If xi is the same as yj, then set lŒi; j  to lŒi  1; j  1 C 1.
ii. Otherwise (xi differs from yj), set lŒi; j  to the larger of
lŒi; j  1 and lŒi  1; j . If lŒi; j  1 equals lŒi  1; j ,
it doesn’t matter which you choose.
5. Return the array l.
Since it takes constant time to ﬁll in each entry of the table, and the
table contains .m C 1/  .n C 1/ entries, the running time of COMPUTE-
LCS-TABLE is ‚.mn/.
The good news is that, once we compute the lŒi; j  table, its lower-
right entry, lŒm; n, gives us the length of an LCS of X and Y. The bad
news is that no single entry in the table tells us the actual characters in an
LCS. We can use the table, along with the strings X and Y, to construct
an LCS, using O.m C n/ additional time. We determine how we got
1Even mentioning lŒi 1; j 1 is redundant, since we need to have computed it before
computing both of lŒi; j  1 and lŒi  1; j.

120
Chapter 7: Algorithms on Strings
the value in lŒi; j  by reverse engineering this computation, based on
lŒi; j  and the values it depends on: xi, yj, lŒi  1; j  1, lŒi; j  1,
and lŒi  1; j .
I like to write this procedure recursively, where we assemble an LCS
from back to front. The procedure recurses, and when it ﬁnds characters
in X and Y that are the same, it appends the character to the end of the
LCS it constructs. The initial call is ASSEMBLE-LCS.X; Y; l; m; n/.
Procedure ASSEMBLE-LCS.X; Y; l; i; j /
Inputs:

X and Y : two strings.

l: the array ﬁlled in by the COMPUTE-LCS-TABLE procedure.

i and j : indices into X and Y, respectively, as well as into l.
Output: An LCS of Xi and Yj.
1. If lŒi; j  equals 0, then return the empty string.
2. Otherwise (because lŒi; j  is positive, both i and j are positive),
if xi is the same as yj, then return the string formed by ﬁrst
recursively calling ASSEMBLE-LCS.X; Y; l; i  1; j  1/ and
then appending xi (or yj) to the end of the string returned by the
recursive call.
3. Otherwise (xi differs from yj), if lŒi; j  1 is greater than
lŒi  1; j , then return the string returned by recursively calling
ASSEMBLE-LCS.X; Y; l; i; j  1/.
4. Otherwise (xi differs from yj and lŒi; j  1 is less than or equal
to lŒi  1; j ), return the string returned by recursively calling
ASSEMBLE-LCS.X; Y; l; i  1; j /.
In the table on page 118, the shaded lŒi; j  entries are those that the
recursion visits with the initial call ASSEMBLE-LCS.X; Y; l; 6; 9/, and
the shaded xi characters are those that are appended to the LCS being
constructed. To get an idea of how ASSEMBLE-LCS works, start at
i D 6 and j D 9. Here, we ﬁnd that x6 and y9 are both the character A.
Therefore, A will be the last character of the LCS of X6 and Y9, and we
recurse in step 2. The recursive call has i D 5 and j D 8. This time, we
ﬁnd that x5 and y8 are different characters, and we also ﬁnd that lŒ5; 7
equals lŒ4; 8, and so we recurse in step 4. Now the recursive call has
i D 4 and j D 8. And so on. If you read the shaded xi characters
from top to bottom, you get the string CTCA, which is an LCS. If we

Chapter 7: Algorithms on Strings
121
had broken ties between lŒi; j  1 and lŒi  1; j  in favor of going left
(step 3) rather than going up (step 4), then the LCS produced would
have been TCGA.
How is it that the ASSEMBLE-LCS procedure takes O.m C n/ time?
Observe that in each recursive call, either i decreases, j decreases, or
both decrease. After mCn recursive calls, therefore, we are guaranteed
that one or the other of these indices hits 0 and the recursion bottoms
out in step 1.
Transforming one string to another
Now let’s see how to transform one string X to another string Y. We’ll
start with X, and we’ll convert it to Y, character by character. We’ll
assume that X and Y consist of m and n characters, respectively. As
before, we’ll denote the ith character of each string by using the lower-
case name of the string, subscripted by i, so that the ith character of X
is xi and the j th character of Y is yj.
To convert X into Y, we’ll build a string, which we’ll call Z, so
that when we’re done, Z and Y are the same. We maintain an index i
into X and an index j into Z. We are allowed to perform a sequence of
speciﬁc transformation operations, which may alter Z and these indices.
We start with i and j at 1, and we must examine every character in X
during the process, which means that we will stop only once i reaches
m C 1.
Here are the operations that we consider:

Copy a character xi from X to Z by setting ´j to xi and then incre-
menting both i and j .

Replace a character xi from X by another character a by setting ´i
to a and then incrementing both i and j .

Delete a character xi from X by incrementing i but leaving j alone.

Insert a character a into Z by setting ´j to a and then increment-
ing j but leaving i alone.
Other operations are possible—such as interchanging two adjacent char-
acters, or deleting characters xi through xm in a single operation—but
we’ll consider just the copy, replace, delete, and insert operations here.
As an example, here is one sequence of operations that transforms
the string ATGATCGGCAT into the string CAATGTGAATC, where the
shaded characters are xi and ´j after each operation:

122
Chapter 7: Algorithms on Strings
Operation
X
Z
initial strings
ATGATCGGCAT
delete A
ATGATCGGCAT
replace T by C
ATGATCGGCAT
C
replace G by A
ATGATCGGCAT
CA
copy A
ATGATCGGCAT
CAA
copy T
ATGATCGGCAT
CAAT
replace C by G
ATGATCGGCAT
CAATG
replace G by T
ATGATCGGCAT
CAATGT
copy G
ATGATCGGCAT
CAATGTG
replace C by A
ATGATCGGCAT
CAATGTGA
copy A
ATGATCGGCAT
CAATGTGAA
copy T
ATGATCGGCAT
CAATGTGAAT
insert C
ATGATCGGCAT
CAATGTGAATC
Other operation sequences would work, too. For example, we could
just delete each character from X in turn and then insert each character
from Y into Z.
Each of the transformation operations comes with a cost, which is a
constant that depends only on the type of the operation and not on the
characters involved. Our goal is to ﬁnd a sequence of operations that
transforms X into Y and has a minimum total cost. Let’s denote the cost
of the copy operation by cC, the cost of replace by cR, the cost of delete
by cD, and the cost of insert by cI. For the sequence of operations in
the example above, the total cost would be 5cC C 5cR C cD C cI. We
should assume that each of cC and cR is less than cDCcI, because other-
wise instead of paying cC to copy a character or paying cR to replace a
character, we would just pay cD C cI to delete the character and insert
either the same one (instead of copying) or a different one (instead of
replacing).
Why would you want to transform one string to another? Computa-
tional biology provides one application. Computational biologists often
align two DNA sequences in order to measure how similar they are. In
one way to align two sequences X and Y, we line up identical characters
as much as possible by inserting spaces into the two sequences (includ-
ing at either end) so that the resulting sequences, let’s say X 0 and Y 0,
have the same length but don’t have a space in the same position. That
is, we can’t have both x0
i and y0
i be a space. After aligning, we assign a
score to each position:

Chapter 7: Algorithms on Strings
123

1 if x0
i and y0
i are the same and not a space.

C1 if x0
i differs from y0
i and neither is a space.

C2 if either x0
i or y0
i is a space.
The score for an alignment is the sum of the scores for the individual
positions. The lower the score, the more closely the two strings align.
For the strings in the example above, we can align them as follows,
where t indicates a space:
X 0 W
ATGATCGtGCATt
Y 0 W
tCAATtGTGAATC
*++--*-*-+--*
A - under a position indicates a score of 1 for that position, a + in-
dicates a score of C1, and a * indicates C2. This particular alignment
has a total score of .6  1/ C .3  1/ C .4  2/, or 5.
There are many possible ways to insert spaces and align two se-
quences. To ﬁnd the way that produces the best match—having the low-
est score—we use string transformation with costs cC D 1, cR D C1,
and cD D cI D C2. The more identical characters get matched up,
the better the alignment, and the negative cost of the copy operation
provides incentive to match up identical characters. A space in Y 0 cor-
responds to a deleted character, so that in the above example, the ﬁrst
space in Y 0 corresponds to deleting the ﬁrst character (A) of X. A space
in X 0 corresponds to an inserted character, so that in the above example,
the ﬁrst space in X 0 corresponds to inserting the character T.
So let’s see how to transform a string X into a string Y. We’ll use dy-
namic programming, with subproblems of the form “convert the preﬁx
string Xi into the preﬁx string Yj,” where i runs from 0 to m and j runs
from 0 to n. We’ll call this subproblem the “Xi ! Yj problem,” and the
problem that we start with is the Xm ! Yn problem. Let’s denote the
cost of an optimal solution to the Xi ! Yj problem by costŒi; j . As an
example, take X D ACAAGC and Y D CCGT, so that we want to solve
the X6 ! Y4 problem, and we’ll use the operation costs for aligning
DNA sequences: cC D 1, cR D C1, and cD D cI D C2. We’ll solve
subproblems of the form Xi ! Yj, where i runs from 0 to 6 and j runs
from 0 to 4. For example, the X3 ! Y2 problem is transforming the
preﬁx string X3 D ACA into the preﬁx string Y2 D CC.
It’s easy to determine costŒi; j  when i or j is 0, because X0 and Y0
are empty strings. Convert an empty string into Yj by j insert opera-
tions, so that costŒ0; j  equals j cI. Likewise, convert Xi into an empty

124
Chapter 7: Algorithms on Strings
string by i delete operations, so that costŒi; 0 equals i cD. When both i
and j are 0, we are converting the empty string to itself, and so costŒ0; 0
is obviously 0.
When i and j are both positive, we need to examine how optimal
substructure applies to transforming one string to another. Let’s sup-
pose—for the moment—that we know which was the last operation
used to convert Xi to Yj. It was one of the four operations copy, re-
place, delete, or insert.

If the last operation was a copy, then xi and yj must have been the
same character. The subproblem that remains is converting Xi1
to Yj 1, and an optimal solution to the Xi ! Yj problem must in-
clude an optimal solution to the Xi1 ! Yj1 problem. Why? Be-
cause if we had used a solution to the Xi1 ! Yj1 problem that did
not have the minimum cost, we could use the minimum-cost solu-
tion instead to obtain a better solution to the Xi ! Yj problem than
the one we got. Therefore, assuming that the last operation was a
copy, we know that costŒi; j  equals costŒi  1; j  1 C cC.
In our example, let’s look at the X5 ! Y3 problem. Both x5 and y3
are the character G, and so if the last operation was copy G, then
because cC D 1, we must have costŒ5; 3 D costŒ4; 2  1. If
costŒ4; 2 is 4, then costŒ5; 3 must be 3. If we could have found a
solution to the X4 ! Y2 problem with a cost less than 4, then we
could use that solution to ﬁnd a solution to the X5 ! Y3 problem
with a cost less than 3.

If the last operation was a replace, and under the reasonable assump-
tion that we can’t “replace” a character with itself, then xi and yj
must differ. Using the same optimal substructure argument as we
used for the copy operation, we see that, assuming that the last oper-
ation was a replace, costŒi; j  equals costŒi  1; j  1 C cR.
In our example, consider the X5 ! Y4 problem. This time, x5
and y4 are different characters (G and T, respectively), and so if the
last operation was replace G by T, then because cR D C1, we must
have costŒ5; 4 D costŒ4; 3C1. If costŒ4; 3 is 3, then costŒ5; 4 must
be 4.

If the last operation was a delete, then we have no restrictions on xi
or yj. Think of the delete operation as skipping over the character xi
and leaving the preﬁx Yj alone, so that the subproblem we need to

Chapter 7: Algorithms on Strings
125
solve is the Xi1 ! Yj problem. Assuming that the last operation
was a delete, we know that costŒi; j  D costŒi  1; j  C cD.
In our example, consider the X6 ! Y3 problem. If the last operation
was a delete (the deleted character must be x6, which is C), then
because cD D C2, we must have costŒ6; 3 D costŒ5; 3 C 2. If
costŒ5; 3 is 3, then costŒ6; 3 must be 5.

Finally, if the last operation was an insert, it leaves Xi alone but adds
the character yj, and the subproblem to solve is Xi ! Yj1. Assum-
ing that the last operation was an insert, we know that costŒi; j  D
costŒi; j  1 C cI.
In our example, consider the X2 ! Y3 problem. If the last operation
was an insert (the inserted character must be y3, which is G), then
because cI D C2, we must have costŒ2; 3 D costŒ2; 2 C 2. If
costŒ2; 2 is 0, then costŒ2; 3 must be 2.
Of course, we don’t know in advance which of the four operations
was the last one used. We want to use the one that yields the lowest
value for costŒi; j . For a given combination of i and j , three of the four
operations apply. The delete and insert operations always apply when
both i and j are positive, and exactly one of copy and replace applies,
depending on whether xi and yj are the same character. To compute
costŒi; j  from other cost values, determine which of copy and replace
applies and take the minimum value of costŒi; j  that the three possible
operations yield. That is, costŒi; j  is the smallest of the following four
values:

costŒi  1; j  1 C cC, but only if xi and yj are the same character,

costŒi  1; j  1 C cR, but only if xi and yj differ,

costŒi  1; j  C cD,

costŒi; j  1 C cI.
Just as we did for ﬁlling in the l table when computing an LCS, we
can ﬁll in the cost table row by row. That’s because, just like the l table,
each entry costŒi; j , where i and j are positive, depends on having al-
ready computed the entries immediately to the left, immediately above,
and above and to the left.
In addition to the cost table, we’ll ﬁll in a table op, where opŒi; j 
gives the last operation used to convert Xi to Yj. We can ﬁll in the

126
Chapter 7: Algorithms on Strings
entry opŒi; j  when we ﬁll in costŒi; j . The procedure COMPUTE-
TRANSFORM-TABLES on the following page ﬁlls in the cost and op
tables, row by row, treating the cost and op tables as two-dimensional
arrays.
Page 128 has the cost and op tables computed by COMPUTE-
TRANSFORM-TABLES for our example of transforming X D ACAAGC
to Y D CCGT with cC D 1, cR D C1, and cD D cI D C2. Ap-
pearing at row i and column j are the values of costŒi; j  and opŒi; j ,
with operation names abbreviated. For example, the last operation used
when transforming X5 D ACAAG to Y2 D CC replaces G by C, and an
optimal sequence of operations to transform ACAAG to CC has a total
cost of 6.
The COMPUTE-TRANSFORM-TABLES procedure ﬁlls in each entry
of the tables in constant time, just as the COMPUTE-LCS-TABLE pro-
cedure does. Because each of the tables contains .m C 1/  .n C 1/
entries, COMPUTE-TRANSFORM-TABLES runs in ‚.mn/ time.
To construct the sequence of operations that transforms X to Y, we
consult the op table, starting at the last entry, opŒm; n. We recurse,
much as the ASSEMBLE-LCS procedure does, appending each opera-
tion encountered from the op table to the end of the sequence of op-
erations. The procedure ASSEMBLE-TRANSFORMATION appears on
page 129. The initial call is ASSEMBLE-TRANSFORMATION.op; m; n/.
The sequence of operations to convert X D ACAAGC into a string Z
that is the same as Y D CCGT appears below the cost and op tables on
page 128.
Just as in ASSEMBLE-LCS, each recursive call of the ASSEMBLE-
TRANSFORMATION procedure decreases either i or j , or both, and so
the recursion bottoms out after at most m C n recursive calls. Since
each recursive call takes constant time before and after recursing, the
ASSEMBLE-TRANSFORMATION procedure runs in O.m C n/ time.
One subtlety in the ASSEMBLE-TRANSFORMATION procedure bears
closer examination. The recursion bottoms out only once both i and j
reach 0. Suppose that one of i and j , but not both, equals 0. Each
of the three cases in steps 2A, 2B, and 2C recurses with the value of i
or j , or both, decreased by 1. Could there be a recursive call in which
i or j has the value 1? Fortunately, the answer is no. Suppose that
j D 0 and i is positive in a call of ASSEMBLE-TRANSFORMATION.
From the way the op table is constructed, opŒi; 0 is a delete oper-
ation, so that step 2B executes.
The recursive call in step 2B calls

Chapter 7: Algorithms on Strings
127
Procedure COMPUTE-TRANSFORM-TABLES.X; Y; cC; cR; cD; cI/
Inputs:

X and Y : two strings of length m and n, respectively.

cC; cR; cD; cI: the costs of the copy, replace, delete, and insert
operations, respectively.
Output: Arrays costŒ0 : : m; 0 : : n and opŒ0 : : m; 0 : : n. The value in
costŒi; j  is the minimum cost of transforming the preﬁx Xi into the
preﬁx Yj, so that costŒm; n is the minimum cost of transforming X
into Y. The operation in opŒi; j  is the last operation performed when
transforming Xi into Yj.
1. Let costŒ0 : : m; 0 : : n and opŒ0 : : m; 0 : : n be new arrays.
2. Set costŒ0; 0 to 0.
3. For i D 1 to m:
A. Set costŒi; 0 to i  cD, and set opŒi; 0 to delete xi.
4. For j D 1 to n:
A. Set costŒ0; j  to j  cI, and set opŒ0; j  to insert yj.
5. For i D 1 to m:
A. For j D 1 to n:
(Determine which of copy and replace applies, and set
costŒi; j  and opŒi; j  according to which of the three
applicable operations minimizes costŒi; j .)
i. Set costŒi; j  and opŒi; j  as follows:
a. If xi and yj are the same, then set costŒi; j  to
costŒi  1; j  1 C cC and set opŒi; j  to copy xi.
b. Otherwise (xi and yj differ), set costŒi; j  to
costŒi  1; j  1 C cR and set opŒi; j  to replace xi
by yj.
ii. If costŒi  1; j  C cD < costŒi; j , then set costŒi; j  to
costŒi  1; j  C cD and set opŒi; j  to delete xi.
iii. If costŒi; j  1 C cI < costŒi; j , then set costŒi; j  to
costŒi; j  1 C cI and set opŒi; j  to insert yj.
6. Return the arrays cost and op.

128
Chapter 7: Algorithms on Strings
j
0
1
2
3
4
yj
C
C
G
T
i
xi
0
0
2
ins C
4
ins C
6
ins G
8
ins T
1
A
2
del A
1
rep A by C
3
rep A by C
5
rep A by G
7
rep A by T
2
C
4
del C
1
copy C
0
copy C
2
ins G
4
ins T
3
A
6
del A
3
del A
2
rep A by C
1
rep A by G
3
rep A by T
4
A
8
del A
5
del A
4
rep A by C
3
rep A by G
2
rep A by T
5
G
10
del G
7
del G
6
rep G by C
3
copy G
4
rep G by T
6
C
12
del C
9
copy C
6
copy C
5
del C
4
rep C by T
Operation
X
Z
initial strings
ACAAGC
delete A
ACAAGC
copy C
ACAAGC
C
delete A
ACAAGC
C
replace A by C
ACAAGC
CC
copy G
ACAAGC
CCG
replace C by T
ACAAGC
CCGT
ASSEMBLE-TRANSFORMATION.op; i  1; j /, so that the value of j
in the recursive call stays at 0. Likewise, if i D 0 and j is positive, then
opŒ0; j  is an insert operation, so that step 2C executes, and in the re-
cursive call to ASSEMBLE-TRANSFORMATION.op; i; j  1/, the value
of i stays at 0.

Chapter 7: Algorithms on Strings
129
Procedure ASSEMBLE-TRANSFORMATION.op; i; j /
Inputs:

op: the operation table ﬁlled in by
COMPUTE-TRANSFORM-TABLES.

i and j : indices into the op table.
Output: A sequence of operations that transforms the string X into
the string Y, where X and Y are the strings input to
COMPUTE-TRANSFORM-TABLES.
1. If both i and j equal 0, then return an empty sequence.
2. Otherwise (at least one of i and j is positive), do the following:
A. If opŒi; j  is a copy or replace operation, then return the
sequence formed by ﬁrst recursively calling
ASSEMBLE-TRANSFORMATION.op; i  1; j  1/ and then
appending opŒi; j  onto the sequence returned by the recursive
call.
B. Otherwise (opŒi; j  is neither a copy nor a replace operation),
then if opŒi; j  is a delete operation, then return the sequence
formed by ﬁrst recursively calling
ASSEMBLE-TRANSFORMATION.op; i  1; j / and then
appending opŒi; j  onto the sequence returned by the recursive
call.
C. Otherwise (opŒi; j  is not a copy, replace, or delete operation,
and so it must be an insert operation), return the sequence
formed by ﬁrst recursively calling
ASSEMBLE-TRANSFORMATION.op; i; j  1/ and then
appending opŒi; j  onto the sequence returned by the recursive
call.
String matching
In the string-matching problem, we have two strings: a text string T
and a pattern string P . We want to ﬁnd all occurrences of P in T .
We’ll shorten the names to “text” and “pattern,” and we’ll assume that
the text and pattern consist of n and m characters, respectively, where
m  n (since it makes no sense to look for a pattern that’s longer than

130
Chapter 7: Algorithms on Strings
the text). We’ll denote the characters in P and T by p1p2p3    pm and
t1t2t3    tn, respectively.
Because we want to ﬁnd all occurrences of the pattern P in the text T ,
a solution will be all the amounts that we can shift P by to ﬁnd it in T .
Put another way, we say that pattern P occurs with shift s in text T
if the substring of T that starts at tsC1 is the same as the pattern P :
tsC1 D p1, tsC2 D p2, and so on, up through tsCm D pm. The minimum
possible shift would be 0, and because the pattern should not run off the
end of the text, the maximum possible shift would be n  m. We want
to know all the shifts with which P occurs in T . For example, if the
text T is GTAACAGTAAACG and the pattern P is AAC, then P occurs
in T with shifts 2 and 9.
If we’re checking to see whether pattern P occurs in text T with a
given shift amount s, then we would have to check all m characters
in P against characters of T . Assuming that it takes constant time to
check a single character in P against a single character in T , it would
take ‚.m/ time to check all m characters in the worst case. Of course,
once we ﬁnd a mismatch between characters of P and T , we don’t have
to check the rest of the characters. The worst case occurs at each shift
amount for which P does occur in T .
It would be easy enough to just check the pattern against the text for
every possible shift, running from 0 to n  m. Here is how it would
work for checking the pattern AAC against the text GTAACAGTAAACG
for each possible shift, with character matches shaded:
Shift
Shift
amount
Text and pattern
amount
Text and pattern
0
GTAACAGTAAACG
AAC
6
GTAACAGTAAACG
AAC
1
GTAACAGTAAACG
AAC
7
GTAACAGTAAACG
AAC
2
GTAACAGTAAACG
AAC
8
GTAACAGTAAACG
AAC
3
GTAACAGTAAACG
AAC
9
GTAACAGTAAACG
AAC
4
GTAACAGTAAACG
AAC
10
GTAACAGTAAACG
AAC
5
GTAACAGTAAACG
AAC

Chapter 7: Algorithms on Strings
131
This simple approach is rather inefﬁcient, however: with n  m C 1
possible shifts, each taking O.m/ time to check, the running time would
be O..n  m/m/. We’d examine almost every character in the text m
times.
We can do better, because the simple method of checking the pattern
against the text for every possible shift throws away valuable informa-
tion. In the above example, when we look at shift amount s D 2, we
have seen all the characters in the substring t3t4t5 D AAC. But at the
next shift, s D 3, we look at t4 and t5 again. It would be more efﬁcient to
avoid looking at these characters again if at all possible. Let’s examine
a clever approach to string matching that avoids the wasted time caused
by scanning the text repeatedly. Instead of examining text characters m
times, it examines each character of the text exactly once.
This more efﬁcient approach relies on a ﬁnite automaton. Although
the name sounds imposing, the concept is quite simple. Applications
of ﬁnite automata abound, but we’ll focus here on using ﬁnite automata
for string matching. A ﬁnite automaton, or FA for short, is just a set of
states and a way to go from state to state based on a sequence of input
characters. The FA starts in a particular state and consumes characters
from its input, one character at a time. Based on the state it’s in and the
character it has just consumed, it moves to a new state.
In our string-matching application, the input sequence will be the
characters of the text T , and the FA will have m C 1 states, one more
than the number of characters in the pattern P , numbered from 0 to m.
(The “ﬁnite” part of the name “ﬁnite automaton” stems from the number
of states being ﬁnite.) The FA starts in state 0. When it’s in state k, the k
most recent text characters it has consumed match the ﬁrst k characters
of the pattern. Whenever the FA gets to state m, therefore, it has just
seen the entire pattern in the text.
Let’s look at an example using just the characters A, C, G, and T.
Suppose that the pattern is ACACAGA, with m D 7 characters. Here is
the corresponding FA, with states 0 through 7:
0
1
2
3
4
5
6
7
A
C
A
C
A
G
A
C
A
A
A
A
C

132
Chapter 7: Algorithms on Strings
Circles represent states, and arrows, labeled by characters, show how
the FA transitions from state to state on input characters. For example,
the arrows from state 5 are labeled A, C, and G. The arrow to state 1,
labeled A, indicates that when the FA is in state 5 and it consumes the
text character A, it moves to state 1. Likewise, the arrow to state 4,
labeled C, tells us that when the FA is in state 5 and consumes the text
character C, it moves to state 4. Notice that I drew the horizontal “spine”
of the FA with extra-heavy arrows and that the labels on the arrows of
the spine, read from left to right, give the pattern ACACAGA. Whenever
the pattern occurs in the text, the FA moves right by one state for each
character, until it reaches the last state, where it declares that it has found
an occurrence of the pattern in the text. Notice also that some arrows
are missing, such as any arrow labeled T. If an arrow is missing, then
the corresponding transition goes to state 0.
The FA internally stores a table next-state, which is indexed by all
the states and all possible input characters. The value in next-stateŒs; a
is the number of the state to move to if the FA is currently in state s
and it has just consumed character a from the text. Here is the entire
next-state table for the pattern ACACAGA:
character
state
A
C
G
T
0
1
0
0
0
1
1
2
0
0
2
3
0
0
0
3
1
4
0
0
4
5
0
0
0
5
1
4
6
0
6
7
0
0
0
7
1
2
0
0
The FA moves one state to the right for each character that matches
the pattern, and for each character that fails to match the pattern it moves
left, or stays in the same state (next-stateŒ1; A is 1). We’ll see how to
construct the next-state table later on, but ﬁrst let’s trace out what the FA
for the pattern AAC does on the input text GTAACAGTAAACG. Here’s
the FA:
0
1
2
3
A
A
C
A
A

Chapter 7: Algorithms on Strings
133
From this drawing, you can tell that the next-state table is the following:
character
state
A
C
G
T
0
1
0
0
0
1
2
0
0
0
2
2
3
0
0
3
1
0
0
0
Here are the states that the FA moves to and the text characters it con-
sumes to get there:
state
0
0
0
1
2
3
1
0
0
1
2
2
3
0
character
G
T
A
A
C
A
G
T
A
A
A
C
G
I’ve shaded the two times that the FA reaches state 3, since whenever it
reaches state 3, it has found an occurrence of the pattern AAC.
Here is the procedure FA-STRING-MATCHER for string matching. It
assumes that the next-state table has already been built.
Procedure FA-STRING-MATCHER.T; next-state; m; n/
Inputs:

T , n: a text string and its length.

next-state: the table of state transitions, formed according to the
pattern being matched.

m: the length of the pattern. The next-state table has rows indexed
by 0 to m and columns indexed by the characters that may occur
in the text.
Output: Prints out all the shift amounts for which the pattern occurs
in the text.
1. Set state to 0.
2. For i D 1 to n:
A. Set state to the value of next-stateŒstate; ti.
B. If state equals m, then print “The pattern occurs with shift”
i  m.
If we run FA-STRING-MATCHER on the above example, in which
m equals 3, the FA reaches state 3 after consuming the characters t5
and t12. Therefore, the procedure would print out “Pattern occurs with
shift 2” (2 D 5  3) and “Pattern occurs with shift 9” (9 D 12  3).

134
Chapter 7: Algorithms on Strings
Since each iteration of the loop of step 2 takes constant time and this
loop runs exactly n iterations, it’s plain to see that the running time of
FA-STRING-MATCHER is ‚.n/.
That’s the easy part. The hard part is constructing the ﬁnite automa-
ton’s next-state table for a given pattern. Recall the idea:
When the ﬁnite automaton is in state k, the k most recent char-
acters it has consumed are the ﬁrst k characters of the pattern.
To make this idea concrete, let’s go back to the FA on page 131 for the
pattern ACACAGA and think about why next-stateŒ5; C is 4. If the FA
has gotten to state 5, then the ﬁve most recent characters it has consumed
from the text are ACACA, which you can see by looking at the spine of
the FA. If the next character consumed is C, then it does not match the
pattern, and the FA cannot continue on to state 6. But the FA doesn’t
have to go all the way back to state 0, either. Why not? Because now the
four most recently consumed characters are ACAC, which are the ﬁrst
four characters of the pattern ACACAGA. That’s why when the FA is in
state 5 and it consumes a C, it moves to state 4: it has most recently seen
the ﬁrst four characters of the pattern.
We are almost ready to give the rule for constructing the next-state
table, but we need a couple of deﬁnitions ﬁrst. Recall that, for i in the
range 0 to m, the preﬁx Pi of the pattern P is the substring consist-
ing of the ﬁrst i characters of P . (When i is 0, the preﬁx is the empty
string.) Deﬁne a sufﬁx of the pattern accordingly as a substring of char-
acters from the end of P . For example, AGA is a sufﬁx of the pattern
ACACAGA. And deﬁne the concatenation of a string X and a charac-
ter a to be a new string formed by appending a to the end of X, and we
denote it by Xa. For example, the concatenation of the string CA with
the character T is the string CAT.
We’re ﬁnally ready to construct next-stateŒk; a, where k is a state
number running from 0 to m and a is any character that might appear
in the text. In state k, we have just seen the preﬁx Pk in the text. That
is, the k most recently seen text characters are the same as the ﬁrst k
characters of the pattern. When we see the next character, say a, we
have seen Pka (the concatenation of Pk with a) in the text. At that
point, how long a preﬁx of P have we just seen? Another way to ask
this question is how long a preﬁx of P appears at the end of Pka? That
length will be the number of the next state.
More succinctly:

Chapter 7: Algorithms on Strings
135
Take the preﬁx Pk (the ﬁrst k characters of P ) and concate-
nate it with the character a. Denote the resulting string by Pka.
Find the longest preﬁx of P that is also a sufﬁx of Pka. Then
next-stateŒk; a is the length of this longest preﬁx.
Yes, there are a few preﬁxes and sufﬁxes going on, so let’s see how
we determine that next-stateŒ5; C is 4 for the pattern P D ACACAGA.
Since k is 5 in this example, we take the preﬁx P5, which is ACACA,
and concatenate the character C, giving ACACAC. We want to ﬁnd the
longest preﬁx of ACACAGA that is also a sufﬁx of ACACAC. Since the
string ACACAC has length 6, and a sufﬁx can’t be longer than the string
that it’s a sufﬁx of, we can start by looking at P6 and then working our
way down to shorter and shorter preﬁxes. Here, P6 is ACACAG, and it is
not a sufﬁx of ACACAC. So now we consider P5, which is ACACA and
is also not a sufﬁx of ACACAC. Next we consider P4, which is ACAC.
But now this preﬁx is a sufﬁx of ACACAC, and so we stop and determine
that next-stateŒ5; C should equal 4.
You might wonder whether we can always ﬁnd a preﬁx of P that
is also a sufﬁx of Pka. The answer is yes, because the empty string
is a preﬁx and a sufﬁx of every string. When the longest preﬁx of P
that is also a sufﬁx of Pka turns out to be the empty string, we set
next-stateŒk; a to 0. Still using the pattern P D ACACAGA, let’s see
how to determine next-stateŒ3; G. Concatenating P3 with G gives the
string ACAG. We work through the preﬁxes of P , starting with P4
(since the length of ACAG is 4) and work our way down. None of the
preﬁxes ACAC, ACA, AC, or A is a sufﬁx of ACAG, and so we settle for
the empty string as the longest preﬁx that works. Since the empty string
has length 0, we set next-stateŒ3; G to 0.
How long does it take to ﬁll in the entire next-state table? We know
that it has one row for each state in the FA, and so it has m C 1 rows,
numbered 0 to m. The number of columns depends on the number of
characters that may occur in the text; let’s call this number q, so that the
next-state table has q.m C 1/ entries. To ﬁll in an entry next-stateŒk; a,
we do the following:
1. Form the string Pka.
2. Set i to the smaller of k C 1 (the length of Pka) and m (the length
of P ).
3. While Pi is not a sufﬁx of Pka, do the following:
A. Set i to i  1.

136
Chapter 7: Algorithms on Strings
We don’t know in advance how many times the loop of step 3 will run,
but we know that it makes at most mC1 iterations. We also don’t know
in advance how many characters of Pi and Pka must be checked in the
test in step 3, but we know that it’s always at most i, which is at most m.
Since the loop iterates at most m C 1 times and each iteration checks
at most m characters, it takes O.m2/ time to ﬁll in next-stateŒk; a. Be-
cause the next-state table contains q.m C 1/ entries, the total time to ﬁll
it in is O.m3q/.
In practice, the time to ﬁll in the next-state table isn’t too bad. I
coded up the string-matching algorithm in C++ on my 2.4-GHz Mac-
Book Pro and compiled it with optimization level -O3.
I gave it
the pattern a man, a plan, a canal, panama with the 128-
character ASCII character set as the alphabet. The program constructed
a next-state table with 31 rows and 127 columns (I omitted the col-
umn for the null character) in approximately 1:35 milliseconds. With
a shorter pattern, the program of course is faster: it took approxi-
mately 0:07 milliseconds to construct the table when the pattern was
just panama.
Nevertheless, some applications perform string matching frequently,
and in these applications the O.m3q/ time to build the next-state ta-
ble could pose a problem. I won’t go into the details, but there is a
way to cut the time down to ‚.mq/. In fact, we can do even better.
The “KMP” algorithm (developed by Knuth, Morris, and Pratt) uses a
ﬁnite automaton but avoids creating and ﬁlling in the next-state table
altogether. Instead, it uses an array move-to of just m state numbers
that allows the FA to emulate having a next-state table, and it takes just
‚.m/ time to ﬁll in the move-to array. Again, it’s a bit too compli-
cated to go into, but I ran the KMP algorithm on my MacBook Pro,
and for the pattern a man, a plan, a canal, panama it took
about one microsecond to construct the move-to array. For the shorter
pattern panama, it took about 600 nanoseconds (0:0000006 seconds).
Not bad! Like the FA-STRING-MATCHER procedure, the KMP algo-
rithm takes ‚.n/ time to match the pattern against the text, once it has
constructed the move-to array.
Further reading
Chapter 15 of CLRS [CLRS09] covers dynamic programming in de-
tail, including how to ﬁnd a longest common subsequence. The algo-
rithm in this chapter for transforming one string to another gives part

Chapter 7: Algorithms on Strings
137
of the solution to a problem in Chapter 15 of CLRS. (The problem in
CLRS includes the two operations, interchanging adjacent characters
and deleting a sufﬁx of X, that I did not consider in this chapter. You
didn’t think I was going to upset my coauthors by giving away the entire
solution, did you?)
String matching algorithms appear in Chapter 32 of CLRS. That
chapter gives the algorithm based on ﬁnite automata and also a full
treatment of the KMP algorithm. The ﬁrst edition of Introduction to Al-
gorithms [CLR90] included the Boyer-Moore algorithm, which is par-
ticularly efﬁcient when the pattern is long and the number of characters
in the alphabet is large.

8
Foundations of Cryptography
When you buy something over the Internet, you probably have to sup-
ply your credit-card number to a server on the seller’s website or to a
server on a third-party payment service’s website. To get your credit-
card number to a server, you send it over the Internet. The Internet is a
public network, and anyone can discern the bits that go over it. There-
fore, if your credit-card number were to go out over the Internet without
being disguised somehow, then anyone could ﬁgure it out and start pur-
chasing goods and services on your account.
Now, it’s unlikely that someone is sitting there, just waiting for you
to send something that looks like a credit-card number over the Internet.
It’s more likely that someone is waiting for anyone to do so, and maybe
you will be the unfortunate victim. It would be much safer for you to
disguise your credit-card number whenever you send it over the Internet.
Indeed, you probably do. If you use a secure website—one whose URL
begins with “https:” rather than the usual “http:”—then your browser
disguises the information it sends by a process called encryption. (The
https protocol also provides “authentication,” so that you know you’re
connecting to the site you think you’re connecting to.) In this chapter,
we’ll look at encryption, as well as the opposite process, decryption,
where encrypted information is turned back into its original form. To-
gether, the processes of encryption and decryption form the foundation
of the ﬁeld of cryptography.
Although I consider my credit-card number to be important infor-
mation to safeguard, I also recognize that it’s not all that important in
the grand scheme of things. If someone steals my credit-card number,
national security is not at risk. But if someone can eavesdrop on in-
structions from the State Department to a diplomat, or if someone can
snoop on military information, national security could indeed be at risk.
Therefore, not only do we need ways to encrypt and decrypt informa-
tion, but these ways need to be highly difﬁcult to defeat.
In this chapter, we’ll examine some of the basic ideas underlying en-
cryption and decryption. Modern cryptography goes far, far beyond
what I’m presenting here. Don’t try to develop a secure system based
solely on the material in this chapter; you would need to understand

Chapter 8: Foundations of Cryptography
139
modern cryptography in much greater detail to create a system that is
secure in both theory and practice. For example, you would need to
follow established standards, such as those published by the National
Institute of Standards and Technology. As Ron Rivest (one of the in-
ventors of the RSA cryptosystem, which we’ll see later in this chapter)
wrote to me, “In general crypto is like a martial arts contest, and to use
it in practice you need to understand the latest adversarial approaches.”
But this chapter will give you a ﬂavor of some algorithms that were
motivated by how to encrypt and decrypt information.
In cryptography, we call the original information the plaintext and
the encrypted version the ciphertext. Encryption, therefore, converts
plaintext to ciphertext, and decryption converts ciphertext back to its
original plaintext. The information needed to convert is known as the
cryptographic key.
Simple substitution ciphers
In a simple substitution cipher, you encrypt a text by just substituting
one letter for another, and you decrypt an encrypted text by inverting the
substitution. Julius Caesar would communicate with his generals by us-
ing a shift cipher, in which the sender replaced each letter in a message
by the letter that appears three places later in the alphabet, wrapping
around at the end. In our 26-letter alphabet, for example, A would be
replaced by D, and Y would be replaced by B (after Y comes Z, then
A and B). In Caesar’s shift cipher, if a general needed more troops,
he could encrypt the plaintext Send me a hundred more soldiers as the
ciphertext Vhqg ph d kxqguhg pruh vroglhuv. Upon receiving this ci-
phertext, Caesar would replace each letter by the letter occurring three
places earlier in the alphabet, wrapping around at the front of the alpha-
bet, to recover the original plaintext Send me a hundred more soldiers.
(In Caesar’s time, of course, the message would have been in Latin,
using the Latin alphabet of the time.)
If you intercept a message and you know that it was encrypted by a
shift cipher, it’s ridiculously easy to decrypt, even if you don’t know
the shift amount (the key) in advance: just try all possible shifts until
the decrypted ciphertext makes sense as plaintext. For a 26-character
alphabet, you need to try only 25 shifts.
You can make the cipher a little more secure by converting each char-
acter to some other, unique, character, but not necessarily the one that
appears a ﬁxed number of places later in the alphabet. That is, you cre-

140
Chapter 8: Foundations of Cryptography
ate a permutation of the characters and use that as your key. It’s still a
simple substitution cipher, but it’s better than a shift cipher. If you have
n characters in your character set, then an eavesdropper who intercepts
a message would have to discern which of the nŠ (n-factorial) permuta-
tions you had used. The factorial function grows very quickly in n; in
fact, it grows faster than an exponential function.
So why not just uniquely convert each character to some other char-
acter? If you’ve ever tried to solve the “cryptoquote” puzzle that ap-
pears in many newspapers, you know that you can use letter frequencies
and letter combinations to narrow down the choices. Suppose that the
plaintext Send me a hundred more soldiers converted to the ciphertext
Krcz sr h byczxrz sfxr kfjzgrxk. In the ciphertext, the letter r appears
the most often, and you could guess—correctly—that its corresponding
plaintext character is e, the most commonly occurring letter in English
text. Then you could see the two-letter word sr in the ciphertext and
guess that the plaintext character corresponding to the ciphertext s must
be one of b, h, m, or w, since the only two-letter words in English
ending in e are be, he, me, and we. You could also determine that
the plaintext a corresponds to the ciphertext h, because the only single-
letter lowercase word in English is a.
Of course, if you’re encrypting credit-card numbers, then you don’t
have to worry too much about letter frequencies or letter combinations.
But the ten digits yield only 10Š unique ways to convert one digit to
another, or 3,628,800. To a computer, that’s not very many, especially
when compared with the 1016 possible credit-card numbers (16 decimal
digits), and an eavesdropper could automate attempts to put through
purchases on each of the 10Š ways—possibly succeeding with credit-
card numbers other than yours.
You might have noticed one other problem with using a simple sub-
stitution cipher: both the sender and receiver have to agree on the key.
Moreover, if you’re sending different messages to different parties, and
you don’t want each party to be able to decrypt messages intended for
someone else, then you need to establish a separate key for each party.
Symmetric-key cryptography
When the sender and receiver use the same key, they are practicing
symmetric-key cryptography. They must somehow agree in advance
upon just what key they’re using.

Chapter 8: Foundations of Cryptography
141
One-time pads
Assuming for now that you’re ﬁne with using symmetric-key cryptog-
raphy, but that a simple substitution cipher is not sufﬁciently secure,
another option is the one-time pad. One-time pads work on bits. As you
might know, bit is an abbreviation for “binary digit,” and a bit can take
on only two values: 0 and 1. Digital computers store information in se-
quences of bits. Some bit sequences represent numbers, some represent
characters (using either the standard ASCII or Unicode character sets),
and some even represent instructions that the computer executes.
One-time pads apply the exclusive-or, or XOR, operation to bits. We
use ˚ to denote this operation:
0 ˚ 0
D
0 ;
0 ˚ 1
D
1 ;
1 ˚ 0
D
1 ;
1 ˚ 1
D
0 :
The simplest way to think of the XOR operation is that if x is a bit, then
x ˚ 0 D x and x ˚ 1 gives the opposite of x. Furthermore, if x and y
are bits, then .x ˚ y/ ˚ y D x: XORing x with the same value twice
gives x.
Suppose that I want to send you a one-bit message. I could send you
either a 0 or a 1 as the ciphertext, and we would have to agree on whether
I was sending you the bit value I wanted to send you or the opposite of
that bit value. Looked at through the lens of the XOR operation, we
would have to agree on whether I was XORing that bit with 0 or with 1.
If you were to then XOR the ciphertext bit you received with the bit that
I had XORed with—the key—you would recover the original plaintext.
Now suppose that I want to send you a two-bit message. I could leave
both bits alone, I could ﬂip both bits, I could ﬂip the ﬁrst bit but not the
second, or I could ﬂip the second bit but not the ﬁrst. Again, we would
have to agree on which bits I was ﬂipping, if any. In terms of the XOR
operation on two bits, we would have to agree on which of the two-bit
sequences 00, 01, 10, or 11 was the key with which I was XORing the
bits of the plaintext to form the ciphertext. And again, you could XOR
the two-bit ciphertext with the same two-bit key that I had XORed the
plaintext with to recover the original plaintext.
If the plaintext required b bits—perhaps it comprises ASCII or Uni-
code characters that total b bits—then I could generate a random se-
quence of b bits as the key, let you know the b bits of the key, and then

142
Chapter 8: Foundations of Cryptography
XOR, bit by bit, the plaintext with the key to form the ciphertext. Once
you received the b-bit ciphertext, you could XOR it, bit by bit, with the
key to recover the b-bit plaintext. This system is called a one-time pad,1
and the key is called the pad.
As long as the bits of the key are randomly chosen—and we’ll ex-
amine this issue later—it’s well nigh impossible for an eavesdropper
to decrypt the ciphertext by guessing the key. Even if the eavesdrop-
per knows something about the plaintext—for example, that it’s En-
glish—for any ciphertext and any potential plaintext, there exists a key
converting the potential plaintext to the ciphertext,2 and this key is the
bitwise XOR of the potential plaintext and the ciphertext. (That’s be-
cause if the potential plaintext is t, the ciphertext is c, and the key is k,
then not only is t ˚ k D c, but also t ˚ c D k; the ˚ operation applies
bit-by-bit to t, k, and c, so that the ith bit of t XORed with the ith bit
of k equals the ith bit of c.) And so encrypting with a one-time pad pre-
vents the eavesdropper from gaining any additional information about
the plaintext.
One-time pads give good security, but the keys require as many bits as
the plaintext, these bits should be randomly chosen, and the keys need
to be shared between the parties in advance. As the name implies, you
should use a one-time pad just one time. If you use the same key k for
plaintexts t1 and t2, then .t1 ˚ k/ ˚ .t2 ˚ k/ D t1 ˚ t2, which can reveal
where the two plaintexts have the same bits.
1The name comes from the pre-computer realization of the idea, where each party
had a pad of paper with a key written on each sheet, and the parties had identical key
sequences. A key could be used one time and then its sheet torn off from the pad,
exposing the next key. This paper-based system used a shift cipher, but on a letter-by-
letter basis, where each corresponding letter of the key gives the shift amount, from 0
for a to 25 for z. For example, since z means to shift by 25, m means to shift by 12,
and n means to shift by 13, the key zmn converts the plaintext dog to the ciphertext
cat. Unlike the XOR-based system, however, shifting the letters of the ciphertext in the
same direction with the same key does not yield back the plaintext; in this case, it would
give bmg. Instead, you have to shift the ciphertext letters in the opposite direction.
2For the letter-by-letter scheme in the previous footnote, the key zmn converts the
plaintext dog to the ciphertext cat, but we can arrive at this ciphertext with a different
plaintext, elk, and a different key, ypj.

Chapter 8: Foundations of Cryptography
143
Block ciphers and chaining
When the plaintext is long, the pad in a one-time pad has to be equally
long, which can be rather unwieldy. Instead, some symmetric-key sys-
tems combine two additional techniques: they use a shorter key, and
they chop up the plaintext into several blocks, applying the key to
each block in turn. That is, they consider the plaintext to be l blocks
t1; t2; t3; : : : ; tl, and they encrypt these plaintext blocks into l blocks
c1; c2; c3; : : : ; cl of ciphertext. Such a system is known as a block ci-
pher.
In practice, block ciphers encrypt using a system quite a bit more
complicated than the simple XORing of the one-time pad. One fre-
quently used symmetric-key cryptosystem, AES (the Advanced Encryp-
tion Standard), incorporates a block cipher. I won’t go into details of
AES, other than to say that it uses elaborate methods to slice and dice a
plaintext block to produce ciphertext. AES uses a key size of 128, 192,
or 256 bits and a block size of 128 bits.
There’s still a problem with block ciphers, however. If the same block
appears twice in the plaintext, then the same encrypted block will ap-
pear twice in the ciphertext. One way to solve this problem uses the
technique of cipher block chaining. Suppose that you want to send
me an encrypted message. You chop up the plaintext t into l blocks
t1; t2; t3; : : : ; tl, and you create the l blocks c1; c2; c3; : : : ; cl of cipher-
text as follows. Let’s say that you’ll encrypt a block by applying some
function E to it, and I’ll decrypt a block of ciphertext by applying some
function D. You create the ﬁrst block of ciphertext, c1, as you’d expect:
c1 D E.t1/. But before encrypting the second block, you XOR it, bit by
bit, with c1, so that c2 D E.c1 ˚ t2/. For the third block, you ﬁrst XOR
it with c2: c3 D E.c2 ˚ t3/. And so on, so that in general, you compute
the ith block of ciphertext based on the .i 1/st block of ciphertext and
the ith block of plaintext: ci D E.ci1 ˚ ti/. This formula even works
for computing c1 from t1 if you start with c0 being all 0s (because 0˚x
gives x). To decrypt, I ﬁrst compute t1 D D.c1/. From c1 and c2, I can
compute t2 by ﬁrst computing D.c2/, which equals c1 ˚ t2, and then
XORing the result with c1. In general, I decrypt ci to determine ti by
computing ti D D.ci/ ˚ ci1; as with encryption, this scheme works
even for computing t1 if I start with c0 being all 0s.
We’re not quite out of the woods. Even with cipher block chaining, if
you send me the same message twice, you’ll send the same sequence of
ciphertext blocks each time. An eavesdropper would know that you’re

144
Chapter 8: Foundations of Cryptography
sending me the same message twice, which could be valuable informa-
tion for the eavesdropper to have. One solution is to not start with c0
being all 0s. Instead, you randomly generate c0, you use that when en-
crypting the ﬁrst block of plaintext, and I use it when decrypting the ﬁrst
block of ciphertext; we call this randomly generated c0 an initialization
vector.
Agreeing on common information
In order for symmetric-key cryptography to work, both the sender and
receiver need to agree on the key. In addition, if they’re using a block
cipher with cipher block chaining, they might also need to agree on the
initialization vector. As you can imagine, it’s rarely practical to agree
on these values in advance. So how do the sender and receiver agree
on the key and initialization vector? We will see later in this chapter
(page 155) how a hybrid cryptosystem can transmit them securely.
Public-key cryptography
It’s obvious that in order for the receiver of an encrypted message to be
able to decrypt it, the sender and receiver must both know the key used
to encrypt. Right?
Wrong.
In public-key cryptography, each party has two keys: a public key
and a secret key. I’ll describe public-key cryptography with two parties,
you and me, and I’ll denote my public key by P and my secret key
by S. You have your own public and secret keys. Other parties who
participate have their own public and secret keys.
Secret keys are secret, but public keys may be known to everyone.
They could even appear in a centralized directory that lets everyone
know everyone else’s public key. Under the right conditions, you and
I can use either of these keys to encrypt and decrypt. By the “right
conditions,” I mean that there exist functions that use the public and
secret keys to either encrypt plaintext to ciphertext or decrypt ciphertext
to plaintext. Let’s denote the function that I use with my public key
by FP and the function that I use with my secret key by FS.
The public and secret keys have a special relationship:
t D FS.FP.t// ;
so that if you use my public key to encrypt plaintext into ciphertext and
then I use my secret key to decrypt the ciphertext, I get back the original

Chapter 8: Foundations of Cryptography
145
plaintext. Some other applications of public-key cryptography require
that t D FP.FS.t//, so that if I encrypt plaintext with my secret key,
anyone can decrypt the ciphertext.
Anyone should be able to compute my public-key function FP efﬁ-
ciently, but only I should be able to compute my secret-key function FS
in any reasonable amount of time. The time required to successfully
guess my FS without knowing my secret key should be prohibitively
large for anyone else. (Yes, I’m being vague here, but we’ll soon see
an actual implementation of public-key cryptography.) The same holds
for everyone else’s public and secret keys: the public-key function FP
is efﬁciently computable, but only the holder of the secret key can rea-
sonably compute the secret-key function FS.
Here’s how you can send me a message using public-key cryptogra-
phy:
you
me
eavesdropper
plaintext t
FP
FS
ciphertext c
plaintext t D FS.c/
ciphertext c D FP.t/
You start with the plaintext t. You ﬁnd my public key P ; maybe you
get it directly from me, or maybe you ﬁnd it in a directory. Once you
have P , you encrypt the plaintext to produce the ciphertext c D FP.t/,
which you can do efﬁciently. You send me the ciphertext, so that any
eavesdropper who intercepts what you send me sees only the ciphertext.
I take the ciphertext c and decrypt it using my secret key, reproducing
the plaintext t D FS.c/. You, or anyone else, can encrypt to produce
the ciphertext reasonably quickly, but only I can decrypt the ciphertext
to reproduce the plaintext in any reasonable amount of time.
In practice, we need to make sure that the functions FP and FS work
together correctly. We want FP to produce a different ciphertext for
each possible plaintext.
Suppose instead that FP gave the same re-
sult for two different plaintexts, t1 and t2; that is, FP.t1/ D FP.t2/.
Then, when I receive a ciphertext FP.t1/ and try to decrypt it by run-
ning it through FS, I don’t know whether I’ll get back t1 or t2. On the
other hand, it’s OK—in fact, preferable—for encryption to incorporate
an element of randomization, so that the same plaintext is encrypted
into different ciphertexts each time it’s run through FP . (The RSA
cryptosystem, which we’re about to see, is much more secure when
the plaintext is only a small portion of what is encrypted, the bulk of

146
Chapter 8: Foundations of Cryptography
the encrypted information being random “padding.”) Of course, the de-
cryption function FS would need to be designed to compensate, so that
it could convert multiple ciphertexts into the same plaintext.3
A problem arises, however. The plaintext t could take on an arbitrary
number of possible values—in fact, it could be arbitrarily long—and
the number of ciphertext values that FP could convert t to has to be at
least as many as the number of values that t could take on. How can we
construct the functions FP and FS under the additional constraints that
FP has to be easy to compute for everyone and FS has to be easy only
for me? It’s hard, but it’s doable if we can limit the number of possible
plaintexts—that is, we use a block cipher.
The RSA cryptosystem
Public-key cryptography is a lovely concept, but it relies on being able
to ﬁnd functions FP and FS that work correctly together, FP is easy
for anyone to compute, and FS is easy for only the holder of the secret
key to compute. We call a scheme that fulﬁlls these criteria a public-
key cryptosystem, and the RSA cryptosystem, or just RSA,4 is one such
scheme.
RSA depends on several facets of number theory, many of which re-
late to modular arithmetic. In modular arithmetic, we pick a positive
integer, let’s say n, and whenever we get to n, we immediately wrap
back around to 0. It’s like regular arithmetic with integers, but we al-
ways divide by n and take the remainder. For example, if we’re working
modulo 5, then the only possible values are 0; 1; 2; 3; 4, and 3 C 4 D 2
since 7 divided by 5 gives a remainder of 2. Let’s deﬁne an operator,
mod, to compute remainders, so that we can say 7 mod 5 D 2. Mod-
3Baseball uses a similar system. Managers and coaches tell players what plays to put
on using elaborate systems of gestures, called “signs.” For example, touching the right
shoulder might mean to execute a hit-and-run play and touching the left thigh might
mean to bunt. A manager or coach goes through a long series of signs, but only some
of the signs are meaningful; the rest are decoys. The giver and receiver of the signs
have a system where they agree on which signs are meaningful, sometimes based on
the ordering in the sequence of signs and sometimes based on an “indicator” sign. The
manager or coach can give an arbitrarily long series of signs to indicate any particular
play, where most of the signs in the series are meaningless.
4The name comes from its inventors, Ronald Rivest, Adi Shamir, and Leonard Adel-
man.

Chapter 8: Foundations of Cryptography
147
ular arithmetic is like clock arithmetic, but substituting 0 for 12 on the
clock face. If you go to sleep at 11 and sleep for eight hours, you wake
up at 7: .11 C 8/ mod 12 D 7.
What’s particularly nice about modular arithmetic is that we can take
mod operations in the middle of expressions and not change the result:5
.a C b/ mod n
D
..a mod n/ C .b mod n// mod n ;
ab mod n
D
..a mod n/.b mod n// mod n ;
ab mod n
D
.a mod n/b mod n :
Furthermore, for any integer x, we have that xn mod n is 0.
In addition, in order for RSA to fulﬁll the criteria for a public-key
cryptosystem, two number-theoretic properties related to prime num-
bers must hold. As you might know, a prime number is an integer
greater than 1 that has only two integer factors: 1 and itself. For exam-
ple, 7 is prime, but 6 is not, being factorable as 2  3. The ﬁrst property
that RSA relies on is that if you have a number that is the product of
two large secret prime numbers, then nobody else can determine these
factors in any reasonable amount of time. Recall from back in Chapter 1
that someone could test all possible odd divisors up to the square root
of the number, but if the number is large—hundreds or thousands of
digits—then its square root has half as many digits, which could still be
large. Although someone could theoretically ﬁnd one of the factors, the
resources required (time and/or computing power) would make ﬁnding
a factor impractical.6
5As an example, to see that ab mod n D ..a mod n/.b mod n// mod n, suppose that
a mod n D x and b mod n D y. Then there exist integers i and j such that a D ni Cx
and b D nj C y, and so
ab mod n D .ni C x/.nj C y/ mod n
D .n2ij C xnj C yni C xy/ mod n
D ..n2ij mod n/ C .xnj mod n/ C .yni mod n/ C .xy mod n// mod n
D xy mod n
D ..a mod n/.b mod n// mod n :
6For example, if the number has 1000 bits, then its square root has 500 bits and could
be about as large as 2500. Even if someone could test a trillion trillion possible divisors
per second, the sun would have burned out long, long before reaching 2500.

148
Chapter 8: Foundations of Cryptography
The second property is that, even though factoring a large prime
is hard, it’s not hard to determine whether a large number is prime.
You might think that it’s impossible to determine that a number is not
prime—that is, the number is composite—without ﬁnding at least one
nontrivial factor (a factor that is not 1 or the number itself). It is, in fact,
possible to do so. One way is the AKS primality test,7 the ﬁrst algorithm
to determine whether an n-bit number is prime in time O.nc/ for some
constant c. Although the AKS primality test is considered theoretically
efﬁcient, it is not yet practical for large numbers. Instead, we can use
the Miller-Rabin primality test. The downside of the Miller-Rabin test
is that it can make errors, declaring a number that is actually composite
to be prime. (If it declares a number to be composite, however, then the
number is deﬁnitely composite.) The good news is that the error rate is
1 in 2s, where we can pick any positive value of s that we want. So,
if we’re willing to live with one error in, say, every 250 tests, then we
can determine with almost perfect certainty whether a number is prime.
You might recall from Chapter 1 that 250 is about a million billion, or
about 1,000,000,000,000,000. And if you’re still uncomfortable with 1
error in 250 tests, with a little more effort, you can make it 1 error in
260 tests; 260 is about a thousand times more than 250. That’s because
the time to perform the Miller-Rabin test increases just linearly with the
parameter s, and so increasing s by 10, from 50 to 60, increases the run-
ning time by only 20%, but decreases the error rate by a factor of 210,
which equals 1024.
Here’s how I would set myself up to use the RSA cryptosystem. After
we see how RSA works, we’ll have to address several details.
1. Pick at random two very large prime numbers, p and q, that are not
equal to each other. How large is very large? At least 1024 bits each,
or at least 309 decimal digits. Even larger is better.
2. Compute n D pq. That’s a number with at least 2048 bits, or at
least 618 decimal digits.
3. Compute r D .p  1/.q  1/, which is almost as large as n.
4. Select a small odd integer e that is relatively prime to r: the only
common divisor of e and r should be 1. Any such small integer is
ﬁne here.
7Named after its inventors, Manindra Agrawal, Neeraj Kayal, and Nitin Saxena.

Chapter 8: Foundations of Cryptography
149
5. Compute d as the multiplicative inverse of e, modulo r. That is,
ed mod r should equal 1.
6. Declare my RSA public key to be the pair P D .e; n/.
7. Keep the pair S D .d; n/ as my RSA secret key, revealed to nobody.
8. Deﬁne the functions FP and FS by
FP.x/
D
xe mod n ;
FS.x/
D
xd mod n :
These functions can operate on either a block of plaintext or a block
of ciphertext, whose bits we interpret as representing large integers.
Let’s take an example, but using small numbers so that we can under-
stand what’s going on.
1. Pick the prime numbers p D 17 and q D 29.
2. Compute n D pq D 493.
3. Compute r D .p  1/.q  1/ D 448.
4. Select e D 5, which is relatively prime to 448.
5. Compute d D 269. To check: ed D 5  269 D 1345, and so
ed mod r D 1345 mod 448 D .3  448 C 1/ mod 448 D 1.
6. Declare my RSA public key to be P D .5; 493/.
7. Keep S D .269; 493/ as my RSA secret key.
8. As an example, let’s compute FP.327/:
FP.327/
D
3275 mod 493
D
3,738,856,210,407 mod 493
D
259 :
If we compute FS.259/ D 259269 mod 493, we should get 327 back.
We do, but you really don’t want to see all the digits in the expres-
sion 259269. You can search the Internet for an arbitrary-precision
calculator, and test it out there. (I did.) Then again, because we’re
working with modular arithmetic, we don’t need to compute the ac-
tual value of 259269; we can express all intermediate results mod-
ulo 493, so if you wanted to, you could start with the product 1, and
269 times do the following: multiply what you have by 259 and take
the product modulo 493. You’ll get a result of 327. (I did, or rather,
a computer program that I wrote did.)

150
Chapter 8: Foundations of Cryptography
Here are the details I have to address in order to set up and use RSA:

How do I work with numbers with hundreds of digits?

Although testing whether a number is prime isn’t an obstacle, how
do I know that I can ﬁnd large prime numbers in a reasonable amount
of time?

How do I ﬁnd e so that e and r are relatively prime?

How do I compute d so that it’s the multiplicative inverse of e, mod-
ulo r?

If d is large, how do I compute xd mod n in a reasonable amount of
time?

How do I know that the functions FP and FS are inverses of each
other?
How to perform arithmetic with large numbers
Clearly, numbers as large as RSA requires are not going to ﬁt in the
registers found in most computers, which hold at most 64 bits. For-
tunately, several software packages, and even some programming lan-
guages—Python, for example—allow you to work with integers that
have no ﬁxed limit on their size.
Furthermore, all arithmetic in RSA is modular arithmetic, which al-
lows us to limit the sizes of the integers being calculated. For exam-
ple, as we are calculating xd mod n, we’ll be calculating intermediate
results that are x raised to various powers, but all modulo n, which
means that all intermediate results calculated will be in the range from 0
to n  1. Moreover, if you ﬁx the maximum sizes of p and q, then you
have ﬁxed the maximum size of n, which in turn means that it’s feasible
to implement RSA in specialized hardware.
How to ﬁnd a large prime number
I can ﬁnd a large prime number by repeatedly randomly generating a
large odd number and using the Miller-Rabin primality test to determine
whether it’s prime, stopping once I ﬁnd a prime number. This scheme
presupposes that I’ll ﬁnd a large prime number before too long. What if
prime numbers are extremely rare as numbers get large? I could spend
a huge amount of time searching for a prime needle in a composite
haystack.
I need not worry. The Prime Number Theorem tells us that, as m
approaches inﬁnity, the number of prime numbers less than or equal

Chapter 8: Foundations of Cryptography
151
to m approaches m= ln m, where ln m is the natural logarithm of m. If
I just randomly select an integer m, there’s about a 1 in ln m chance
that it’s prime. Probability theory tells us that, on average, I need to
try only about ln m numbers near m before I ﬁnd one that is prime. If
I’m looking for prime numbers p and q with 1024 bits, then m is 21024,
and ln m is approximately 710. A computer can quickly run the Miller-
Rabin primality test on 710 numbers.
In practice, I could run a simpler primality test than the Miller-Rabin
test. Fermat’s Little Theorem states that if m is a prime number, then
xm1 mod m equals 1 for any number x in the range from 1 to m  1.
The converse—if xm1 mod m equals 1 for any number x in the range
from 1 to m1, then m is prime—is not necessarily true, but exceptions
are very rare for large numbers. In fact, it’s almost always sufﬁcient
to just try odd integers m and declare m to be prime if 2m1 mod m
equals 1. We’ll see on page 153 how to compute 2m1 mod m with only
‚.lg m/ multiplications.
How to ﬁnd one number that is relatively prime to another
I need to ﬁnd a small odd integer e that is relatively prime to r. Two
numbers are relatively prime if their greatest common divisor is 1. I’ll
use an algorithm for computing the greatest common divisor of two inte-
gers that dates back to the ancient Greek mathematician Euclid. There’s
a theorem in number theory that says that if a and b are integers, not
both zero, then their greatest common divisor g equals ai C bj for
some integers i and j . (Moreover, g is the smallest number that can
be formed in this way, but this fact won’t matter to us.) One of the co-
efﬁcients i and j may be negative; for example, the greatest common
divisor of 30 and 18 is 6, and 6 D 30i C 18j when i D 1 and j D 2.
On the next page appears Euclid’s algorithm in a form that gives the
greatest common divisor g of a and b, along with the coefﬁcients i
and j . These coefﬁcients will come in handy a little later, when I need
to ﬁnd the multiplicative inverse of e, modulo r. If I have a candidate
value for e, I call EUCLID.r; e/. If the ﬁrst element of the triple returned
by the call is 1, then the candidate value for e is relatively prime to r.
If the ﬁrst element is any other number, then r and the candidate value
for e have a divisor greater than 1 in common, and they are not relatively
prime.

152
Chapter 8: Foundations of Cryptography
Procedure EUCLID.a; b/
Inputs: a and b: Two integers.
Output: A triple .g; i; j / such that g is the greatest common divisor
of i and j and g D ai C bj .
1. If b equals 0, then return the triple .a; 1; 0/.
2. Otherwise (b is not 0), do the following:
A. Recursively call EUCLID.b; a mod b/, and assign the returned
result to the triple .g; i 0; j 0/. That is, set g to the ﬁrst element
of the triple returned, set i 0 to the second element of the triple
returned, and set j 0 to the third element of the triple returned.
B. Set i to j 0.
C. Set j to i 0  ba=bc j 0.
D. Return the triple .g; i; j /.
I won’t go into why this procedure works,8 nor will I analyze its run-
ning time, but I will just tell you that if I call EUCLID.r; e/, then the
number of recursive calls is O.lg e/. Therefore, I can check quickly
whether 1 is the greatest common divisor of r and a candidate value
for e. (Remember that e is small.) If not, I can try a different candidate
value for e, and so on, until I ﬁnd one that is relatively prime to r. How
many candidates do I expect to have to try? Not many. If I restrict my
choices for e to odd prime numbers less than r (easily checked with
the Miller-Rabin test or the test based on Fermat’s Little Theorem), any
choice is highly likely to be relatively prime to r. That’s because, by
the Prime Number Theorem, approximately r= ln r prime numbers are
less than r, but another theorem shows that r cannot have more than lg r
prime factors. Therefore, I am unlikely to hit a prime factor of r.
8The call EUCLID.0; 0/ returns the triple .0; 1; 0/, so that it considers 0 to be the great-
est common divisor of 0 and 0. That might strike you as peculiar (I was going to say
“odd,” but this is the wrong context for that meaning of “odd”), but because r is pos-
itive, the parameter a in the ﬁrst call to EUCLID will be positive, and in any recursive
call, a must be positive. So it doesn’t matter to us what EUCLID.0; 0/ returns.

Chapter 8: Foundations of Cryptography
153
How to compute multiplicative inverses in modular arithmetic
Once I have r and e, I need to compute d as the inverse of e, modulo r,
so that ed mod r equals 1. We already know that the call EUCLID.r; e/
returned a triple of the form .1; i; j /, that 1 is the greatest common divi-
sor of e and r (because they’re relatively prime), and that 1 D ri C ej .
I can just set d to j mod r.9 That’s because we’re working modulo r,
and so we can take both sides modulo r:
1 mod r
D
.ri C ej / mod r
D
ri mod r C ej mod r
D
0 C ej mod r
D
ej mod r
D
.e mod r/  .j mod r/ mod r
D
e.j mod r/ mod r :
(The last line follows because e < r, which implies that e mod r D e.)
And so we have that 1 D e.j mod r/ mod r, which means that I can
set d to the value j in the triple returned by the call EUCLID.r; e/, taken
modulo r. I use j mod r rather than just j in case j is not in the range
from 0 to r  1.
How to raise a number to an integer power quickly
Although e is small, d might be large, and I need to compute xd mod n
in order to compute the function FS. Although I can work modulo n,
which means that all values I work with will be in the range 0 to n  1,
I don’t want to have to multiply numbers d times. Fortunately, I don’t
have to. I can multiply numbers just ‚.lg d/ times, using a technique
known as repeated squaring. I can use this same technique for the
primality test based on Fermat’s Little Theorem.
Here’s the idea. We know that d is nonnegative. Suppose ﬁrst that d
is even. Then xd equals .xd=2/2. Now suppose that d is odd. Then xd
equals .x.d1/=2/2x. These observations give us a nice recursive way to
compute xd, where the base case occurs when d is 0: x0 equals 1. The
9Recall that j could be negative. One way to think of j mod r when j is negative and r
is positive is to start with j and keep adding r until the number you get is nonnegative.
That number equals j mod r. For example, to determine 27 mod 10, you get the
numbers 27, 17, 7, and 3. Once you get to 3, you stop and say that 27 mod 10
equals 3.

154
Chapter 8: Foundations of Cryptography
following procedure embodies this approach, performing all arithmetic
modulo n:
Procedure MODULAR-EXPONENTIATION.x; d; n/
Inputs: x; d; n: three integers, with x and d nonnegative and n
positive.
Output: Returns the value of xd mod n.
1. If d equals 0, then return 1.
2. Otherwise (d is positive), if d is even, then recursively call
MODULAR-EXPONENTIATION.x; d=2; n/, set ´ to the result of
this recursive call, and return ´2 mod n.
3. Otherwise (d is positive and odd), recursively call
MODULAR-EXPONENTIATION.x; .d  1/=2; n/, set ´ to the
result of this recursive call, and return .´2  x/ mod n.
The parameter d reduces by at least half in each recursive call. After
at most blg dc C 1 calls, d goes down to 0 and the recursion ends.
Therefore, this procedure multiplies numbers ‚.lg d/ times.
Showing that the functions FP and FS are inverses of each other
Warning: Lots of number theory and modular arithmetic ahead. If
you’re content to accept without proof that the functions FP and FS are
inverses of each other, skip the next ﬁve paragraphs and resume reading
at “Hybrid cryptosystems.”
In order for RSA to be a public-key cryptosystem, the functions FP
and FS must be inverses of each other. If we take a block t of plain-
text, treat it as an integer less than n, and feed it into FP, we get
te mod n, and if we feed that result into FS, we get .te/d mod n, which
equals ted mod n. If we reverse the order, ﬁrst FS and then FP, we
get .td/e mod n, which again equals ted mod n. We need to show that
for any plaintext block t, interpreted as an integer less than n, we have
ted mod n equals t.
Here’s an outline of our approach. Recall that n D pq. We will show
that ted mod p D t mod p and that ted mod q D t mod q. Then, using
another fact from number theory, we’ll conclude that ted mod pq D
t mod pq—in other words, that ted mod n D t mod n, which is just t,
because t is less than n.

Chapter 8: Foundations of Cryptography
155
We need to use Fermat’s Little Theorem again, and it helps explain
why we set r to be the product .p  1/.q  1/. (Weren’t you wondering
where that came from?) Since p is prime, if t mod p is nonzero, then
.t mod p/p1 mod p D 1.
Recall that we deﬁned e and d so that they are multiplicative inverses,
modulo r: ed mod r D 1. In other words, ed D 1 C h.p  1/.q  1/
for some integer h. If t mod p is not 0, then we have the following:
ted mod p
D
.t mod p/ed mod p
D
.t mod p/1Ch.p1/.q1/ mod p
D

.t mod p/  ..t mod p/p1 mod p/h.q1/
mod p
D
.t mod p/  .1h.q1/ mod p/
D
t mod p :
Of course, if t mod p is 0, then ted mod p equals 0.
A similar argument shows that if t mod q is not 0, then ted mod q
equals t mod q, and if t mod q is 0, then ted mod q equals 0.
We need one more fact from number theory to ﬁnish up: because
p and q are relatively prime (each being prime), if both x mod p D
y mod p and x mod q D y mod q, then x mod pq D y mod pq.
(This fact comes from the “Chinese Remainder Theorem.”) Plugging
in ted for x and t for y, and remembering that n D pq and that t is less
than n, gives us ted mod n D t mod n D t, which is exactly what we
needed to show. Whew!
Hybrid cryptosystems
Although we can perform arithmetic with large numbers, in practice we
do pay a price in speed. Encrypting and decrypting a long message,
containing hundreds or thousands of blocks of plaintext, could cause a
noticeable delay. RSA is often used in a hybrid system, part public-key
and part symmetric-key.
Here is how you could send me an encrypted message in a hybrid sys-
tem. We agree on which public-key system and symmetric-key system
we’re using; let’s say RSA and AES. You select a key k for AES and
encrypt it with my RSA public key, producing FP.k/. Using the key k,
you then encrypt the sequence of plaintext blocks with AES to produce
a sequence of ciphertext blocks. You send me FP.k/ and the sequence
of ciphertext blocks. I decrypt FP .k/ by computing FS.FP.k//, which
gives me the AES key k, and then I use k to decrypt the ciphertext

156
Chapter 8: Foundations of Cryptography
blocks with AES, thereby recovering the plaintext blocks. If we’re us-
ing cipher block chaining and we need an initialization vector, then you
can encrypt it either with RSA or AES.
Computing random numbers
As we’ve seen, some cryptosystems require us to generate random num-
bers—random positive integers, to be precise. Because we represent an
integer by a sequence of bits, what we really need is a way to generate
random bits, which we can then interpret as an integer.
Random bits can come only from random processes. How can a pro-
gram running on a computer be a random process? In many cases, it
cannot, because a computer program that is built from well deﬁned, de-
terministic instructions will always produce the same result given the
same data to start with. To support cryptographic software, some mod-
ern processors provide an instruction that generates random bits based
on a random process, such as thermal noise within circuits. Designers
of these processors face a threefold challenge: generate the bits at a fast
enough rate for applications that demand random numbers, ensure that
the bits generated meet basic statistical tests for randomness, and con-
sume a reasonable amount of power while generating and testing the
random bits.
Cryptographic programs usually obtain bits from a pseudorandom
number generator, or PRNG. A PRNG is a deterministic program that
produces a sequence of values, based on an initial value, or seed, and
a deterministic rule embodied in the program that says how to generate
the next value in the sequence from the current value. If you start a
PRNG with the same seed each time, you’ll get out the same sequence
of values each time. This repeatable behavior is good for debugging, but
bad for cryptography. Recent standards for random number generators
for cryptosystems require speciﬁc implementations of PRNGs.
If you’re using a PRNG to generate bits that look random, you want
to start with a different seed each time, and that seed should be random.
In particular, the seed should be based on bits that are unbiased (not
favoring either 0 or 1), independent (no matter what you know about
the previous bits generated, anyone has only a 50% chance of correctly
guessing the next bit), and unpredictable to an adversary who is trying
to break your cryptosystem. If your processor has an instruction that
generates random bits, that’s a good way to create the PRNG’s seed.

Chapter 8: Foundations of Cryptography
157
Further reading
Cryptography is but one component of security in computer systems.
The book by Smith and Marchesini [SM08] covers computer security
broadly, including cryptography and ways to attack cryptosystems.
To delve deeper into cryptography, I recommend the books by Katz
and Lindell [KL08] and by Menezes, van Oorschot, and Vanstone
[MvOV96]. Chapter 31 of CLRS [CLRS09] provides a quick back-
ground on the number theory leading up to cryptography, as well as de-
scriptions of RSA and the Miller-Rabin primality test. Difﬁe and Hell-
man [DH76] proposed public-key cryptography in 1976, and the orig-
inal paper describing RSA by Rivest, Shamir, and Adelman [RSA78]
appeared two years later.
For more details on approved PRNGs, see Annex C to Federal In-
formation Processing Standards Publication 140-2 [FIP11]. You can
read about one hardware implementation of a random number genera-
tor based on thermal noise in the article by Taylor and Cox [TC11].

9
Data Compression
In the previous chapter, we examined how to transform information to
shield it from an adversary. Protecting information is not the only rea-
son to transform it, however. Sometimes you want to enhance it; for
example, you might want to modify an image using a software tool
such as Adobe Photoshop in order to remove red-eye or change skin
tones. Sometimes you want to add redundancy so that if some bits are
incorrect, the errors can be detected and corrected.
In this chapter, we investigate another way to transform information:
compressing it. Before we get into some of the methods used to com-
press and decompress information, we should answer three questions:
1. Why would we want to compress information?
We usually compress information for one of two reasons: to save
time and/or to save space.
Time: When transmitting information over a network, the fewer bits
transmitted, the quicker the transmission. Therefore, the sender of-
ten compresses the data before sending, sends the compressed data,
and then the receiver uncompresses the data that it receives.
Space: When the amount of storage available could limit how much
information you can store, you can store more information if it’s
compressed. For example, the MP3 and JPEG formats compress
sound and images in such a way that most people discern little dif-
ference, if any, between the original and compressed materials.
2. What is the quality of the compressed information?
Compression methods can be lossless or lossy. With lossless com-
pression, when the compressed information is decompressed, it is
identical to the original information. With lossy compression, the
decompressed information differs from the original, but ideally in
an insigniﬁcant manner. MP3 and JPEG compression are lossy, but
the compression method used by the zip program is lossless.
Generally speaking, when compressing text, we want lossless com-
pression. Even a difference of one bit can be meaningful. The fol-

Chapter 9: Data Compression
159
lowing sentences differ in just one bit in the ASCII codes of their
letters:1
Don’t forget the pop.
Don’t forget the pot.
These sentences can be construed as requests to remember, respec-
tively, the soft drinks (in the midwest of the U.S. at least) or the
marijuana—one bit makes a big difference!
3. Why is it possible to compress information?
This question is easy to answer for lossy compression: you just tol-
erate how the precision decreases. What about lossless compres-
sion? Digital information often contains redundant or useless bits.
In ASCII, for example, each character occupies one eight-bit byte,
and all commonly used characters (not including accented letters)
have a 0 in the most signiﬁcant (the leftmost) bit. That is, the char-
acter codes in ASCII range from 0 to 255, but all commonly used
characters fall in the range 0 to 127. In many cases, therefore, one-
eighth of the bits in ASCII text are useless, and so it would be easy
to compress most ASCII text by 12:5%.
For a more dramatic example of how to exploit redundancy in loss-
less compression, consider transmitting a black-and-white image, as
fax machines do. Fax machines transmit an image as a series of
pels:2 black or white dots that together form the image. Many fax
machines transmit the pels from top to bottom, row by row. When
the image comprises mostly text, most of the image is white, and so
each row likely contains many consecutive white pels. If a row con-
tains part of a horizontal black line, it might have many consecutive
black pels. Rather than indicate individually each pel in a run of like
color, fax machines compress the information to indicate the length
of each run and the color of the pels in the run. For example, in one
fax standard, a run of 140 white pels is compressed into the eleven
bits 10010001000.
1The ASCII codes for p and t, respectively, are 01110000 and 01110100.
2Pels are like pixels on a screen. Both “pel” and “pixel” are portmanteaus of “picture
element.”

160
Chapter 9: Data Compression
Data compression is a well studied area, and so I can touch on only a
small part of it here. I’ll focus on lossless compression, but you can ﬁnd
a couple of good references that cover lossy compression in the “Further
reading” section.
In this chapter, unlike the previous chapters, we won’t focus on run-
ning times. I’ll mention them when appropriate, but we’re far more
interested in the size of the compressed information than in how long
compression and decompression take.
Huffman codes
Let’s return to strings that represent DNA for the moment. Recall from
Chapter 7 that biologists represent DNA as strings over the four charac-
ters A, C, G, and T. Suppose that we had a strand of DNA represented by
n characters, where 45% of the characters are A, 5% are C, 5% are G, and
45% are T, but the characters appear in the strand in no particular order.
If we used the ASCII character set to represent the strand, with each
character occupying eight bits, it would take 8n bits to represent the en-
tire strand. Of course, we can do better. Since we represent strands of
DNA by drawing on only four characters, we really need only two bits
to represent each character (00; 01; 10; 11), and so we can reduce the
space to 2n bits.
But we can do even better by taking advantage of the relative frequen-
cies of the characters. Let’s encode the characters with the following bit
sequences: A D 0, C D 100, G D 101, T D 11. The more frequent
characters get the shorter bit sequences.
We would encode the 20-
character strand TAATTAGAAATTCTATTATA by the 33-bit sequence
110011110101000111110011011110110. (We’ll see in a moment why
I chose this particular encoding and what properties it has.) Given the
frequencies of the four characters, to encode the n-character strand, we
need only 0:45n1C0:05n3C0:05n3C0:45n2 D 1:65n bits.
(Notice that for the sample strand above, 33 D 1:65  20.) By taking
advantage of the relative frequencies of the characters, we can do even
better than 2n bits!
In the encoding we used, not only do the more frequent characters get
the shorter bit sequences, but there’s something else interesting about
the encodings: no code is a preﬁx of any other code. The code for A

Chapter 9: Data Compression
161
is 0, and no other code starts with 0; the code for T is 11, and no other
code starts with 11; and so on. We call such a code a preﬁx-free code.3
The prime advantage of preﬁx-free codes emerges when we de-
compress.
Because no code is a preﬁx of any other code, we can
unambiguously match the compressed bits with their original char-
acters as we decompress bits in order.
In the compressed sequence
110011110101000111110011011110110, for example, no character
has the one-bit code 1 and only the code for T begins with 11, and so we
know that the ﬁrst character of the uncompressed text must be T. Strip-
ping off the 11 leaves 0011110101000111110011011110110. Only the
code for A begins with 0, and so the ﬁrst character of what remains
must be A. After stripping off the 0 and then the bits 011110, cor-
responding to the uncompressed characters ATTA, the remaining bits
are 101000111110011011110110. Because only the code for G begins
with 101, the next uncompressed character must be G. And so on.
If we measure the efﬁciency of compression methods according to the
average length of the compressed information, then of the preﬁx-free
codes, Huffman codes4 are the best. One disadvantage of traditional
Huffman coding is that it requires the frequencies of all the characters
to be known in advance, and therefore compression often requires two
passes over the uncompressed text: one to determine character frequen-
cies, and one to map each character to its code. We’ll see a little later
how to avoid the ﬁrst pass, at the expense of extra computation.
Once we know the character frequencies, Huffman’s method builds a
binary tree. (If you’ve forgotten about binary trees, see page 98.) This
tree tells us how to form the codes, and it’s also convenient to have when
decompressing. Here’s what the tree looks like for our example of DNA
encoding:
1.0
A: 0.45
0.55
0.1
T: 0.45
G: 0.05
C: 0.05
0
1
0
1
0
1
3In CLRS, we called them “preﬁx codes.” I now prefer the more apt term “preﬁx-free.”
4Named after their inventor, David Huffman.

162
Chapter 9: Data Compression
The leaves of the tree, drawn as rectangles, represent the characters,
with the frequency of each appearing next to the character. The non-
leaves, or internal nodes, are drawn with rounded corners, with each
internal node containing the sum of the frequencies in the leaves below
it. We’ll soon see why it pays to store frequencies in the internal nodes.
Next to each edge in the tree appears either a 0 or a 1. To determine
the code for a character, follow the path from the root down to the char-
acter’s leaf, and concatenate the bits along the path. For example, to
determine the code for G, start at the root and ﬁrst take the edge, la-
beled 1, to its right child; then the edge, labeled 0, to the left child (the
internal node with frequency 0:1), and ﬁnally the edge, labeled 1, to the
right child (the leaf containing G). Concatenating these bits gives the
code 101 for G.
Although I always labeled edges to left children by 0 and edges to
right children by 1, the labels themselves don’t matter much. I could
have just as easily labeled the edges this way:
1.0
A: 0.45
0.55
0.1
T: 0.45
G: 0.05
C: 0.05
0
1
1
0
1
0
With this tree, the codes would be A D 0, C D 111, G D 110, T D 10.
They would still be preﬁx-free, and the number of bits in each code
would be the same as before. That’s because the number of bits in the
code for a character is the same as the depth of the character’s leaf:
the number of edges in the path from the root down to the leaf. Life
is simpler, however, if we always label edges to left children by 0 and
edges to right children by 1.
Once we know the frequencies of the characters, we build the binary
tree from bottom to top. We start with each of the n leaf nodes, cor-
responding to the uncompressed characters, as its own individual tree,
so that initially, each leaf is also a root. We then repeatedly ﬁnd the
two root nodes with the lowest frequencies, create a new root with these
nodes as its children, and give this new root the sum of its children’s
frequencies. The process continues until all the leaves are under one
root. As we progress, we label each edge to a left child by 0 and each

Chapter 9: Data Compression
163
edge to a right child by 1, though once we select the two roots with the
lowest frequencies, it doesn’t matter which we make the left child and
which we make the right child of the new root.
For our DNA example, here’s how the process unfolds. We start with
four nodes, each a leaf representing one character:
A: 0.45
C: 0.05
T: 0.45
G: 0.05
The nodes for C and G have the lowest frequencies, so we create a new
node, make these two nodes its children, and give it their combined
frequencies:
A: 0.45
0.1
T: 0.45
G: 0.05
C: 0.05
0
1
Of the three roots remaining, the one we just created has the lowest
frequency, 0:1, and both of the other two have frequencies of 0:45. We
can select either of the other two as the second root; we select the one
for T, and we make it and the root with frequency 0:1 the children of a
new node whose frequency is their sum, 0:55:
A: 0.45
0.55
0.1
T: 0.45
G: 0.05
C: 0.05
0
1
0
1
Only two roots remain. We create a new node and make them its chil-
dren, and its frequency (which we don’t need, since we’re going to be
done) is their sum, 1:0:
1.0
A: 0.45
0.55
0.1
T: 0.45
G: 0.05
C: 0.05
0
1
0
1
0
1
Now that all the leaves are under this new root, we are done building the
binary tree.

164
Chapter 9: Data Compression
To be a little more precise, let’s deﬁne a procedure for building the bi-
nary tree. The procedure, BUILD-HUFFMAN-TREE, takes as input two
n-element arrays, char and freq, where charŒi contains the ith uncom-
pressed character and freqŒi gives the frequency of this character. It
also takes the value of n. To ﬁnd the two roots with the lowest frequen-
cies, the procedure calls the INSERT and EXTRACT-MIN procedures for
a priority queue (see pages 96–97).
Procedure BUILD-HUFFMAN-TREE.char; freq; n/
Inputs:

char: an array of n uncompressed characters.

freq: an array of n character frequencies.

n: the sizes of the char and freq arrays.
Output: The root of the binary tree constructed for Huffman codes.
1. Let Q be an empty priority queue.
2. For i D 1 to n:
A. Construct a new node ´ containing charŒi and whose
frequency is freqŒi.
B. Call INSERT.Q; ´/.
3. For i D 1 to n  1:
A. Call EXTRACT-MIN.Q/, and set x to the node extracted.
B. Call EXTRACT-MIN.Q/, and set y to the node extracted.
C. Construct a new node ´ whose frequency is the sum of x’s
frequency and y’s frequency.
D. Set ´’s left child to be x and ´’s right child to be y.
E. Call INSERT.Q; ´/.
4. Call EXTRACT-MIN.Q/, and return the node extracted.
Once the procedure gets to step 4, only one node remains in the priority
queue, and it’s the root of the entire binary tree.
You can trace out how this procedure runs with the binary trees on
the preceding page. The roots in the priority queue at the start of each
iteration of the loop in step 3 appear at the top of each ﬁgure.
Let’s quickly analyze the running time of BUILD-HUFFMAN-TREE.
Assuming that the priority queue is implemented by a binary heap,
each INSERT and EXTRACT-MIN operation takes O.lg n/ time. The
procedure calls each of these operations 2n  1 times, for a total of

Chapter 9: Data Compression
165
O.n lg n/ time.
All other work takes a total of ‚.n/ time, and so
BUILD-HUFFMAN-TREE runs in O.n lg n/ time.
I mentioned earlier that when decompressing it’s convenient to have
the binary tree that BUILD-HUFFMAN-TREE constructs. Starting at the
root of the binary tree, travel down the tree according to the bits of the
compressed information. Strip off each bit, going left if it’s a 0 and
right if it’s a 1. Upon arriving at a leaf, stop, emit a character, and
resume searching at the root. Returning to our DNA example, when de-
compressing the bit sequence 11001111010100011111001101111011,
we strip off the ﬁrst 1 and go right from the root, then strip off another 1
and go right again, arriving at the leaf for T. We emit T and resume
searching at the root. We strip off the next bit, 0, and go left from the
root, arriving at the leaf for A, which we emit, and then we go back to
the root. Decompression continues in this way until all the bits of the
compressed information have been processed.
If we have the binary tree already built before decompressing, then it
takes constant time to process each bit. So how does the decompression
process gain access to the binary tree? One possibility is to include
a representation of the binary tree with the compressed information.
Another possibility is to include a decoding table with the processed
information. Each entry of the table would include the character, the
number of bits in its code, and the code itself. From this table, it’s
possible to build the binary tree in time linear in the total number of bits
in all codes.
The BUILD-HUFFMAN-TREE procedure serves as an example of a
greedy algorithm, wherein we make the decision that seems best at the
moment. Because we want the least-frequently appearing characters
far from the root of the binary tree, the greedy approach always selects
the two roots with the lowest frequency to place under a new node,
which can later become a child of some other node. Dijkstra’s algorithm
(pages 92–100) is another greedy algorithm, because it always relaxes
edges from the vertex with the lowest shortest value of those remaining
in its priority queue.
I implemented Huffman coding and ran it on an online version of
Moby Dick. The original text took 1,193,826 bytes, but the compressed
version took only 673,579 bytes, or 56:42% the size of the original,
not including the encoding itself. Put another way, on average each
character required only 4.51 bits to encode. Not too surprisingly, the
most frequent character was a space (15:96%), followed by e (9:56%).

166
Chapter 9: Data Compression
The least frequent characters, appearing only twice each, were $, &, [,
and ].
Adaptive Huffman codes
Practitioners often ﬁnd that making two passes over the input, one to
compute character frequencies and one to encode the characters, is
too slow. Instead, the compression and decompression programs work
adaptively, updating character frequencies and the binary tree as they
compress or decompress in just one pass.
The compression program starts with an empty binary tree. Each
character it reads from the input is either new or already in the binary
tree. If the character is already in the binary tree, then the compression
program emits the character’s code according to the current binary tree,
increases the character’s frequency, and, if necessary, updates the binary
tree to reﬂect the new frequency. If the character is not already in the bi-
nary tree, then the compression program emits the character unencoded
(as is), adds it to the binary tree, and updates the binary tree accordingly.
The decompression program mirrors what the compression program
does. It, too, maintains a binary tree as it processes the compressed
information. When it sees bits for a character in the binary tree, it goes
down the tree to determine which character the bits encode, emits this
character, increases the character’s frequency, and updates the binary
tree. When it sees a character not yet in the tree, the decompression
program emits the character, adds it to the binary tree, and updates the
binary tree.
Something is amiss here, however. Bits are bits, whether they repre-
sent ASCII characters or bits in a Huffman code. How can the decom-
pression program determine whether the bits it’s looking at represent an
encoded or an unencoded character? Does the bit sequence 101 rep-
resent the character currently encoded as 101, or is it the start of an
eight-bit unencoded character? The answer is to precede each unen-
coded character with an escape code: a special code indicating that the
next set of bits represents an unencoded character. If the original text
contains k different characters, then only k escape codes will appear in
the compressed information, each one preceding the ﬁrst occurrence of
a character. Escape codes will usually appear infrequently, and so we
don’t want to assign them short bit sequences at the expense of a more
frequently occurring character. A good way to ensure that escape codes
are not short is to include an escape code character in the binary tree, but
nail down its frequency to be 0 always. As the binary tree is updated,

Chapter 9: Data Compression
167
the escape code’s bit sequence will change in both the compression and
decompression programs, but its leaf will always be the farthest from
the root.
Fax machines
Earlier, I mentioned that fax machines compress information to indicate
the colors and lengths of runs of identical pels in the rows of the im-
age being transmitted. This scheme is known as run-length encoding.
Fax machines combine run-length encoding with Huffman codes. In
the standard for fax machines that use regular phone lines, 104 codes
indicate runs of different lengths of white pels, and 104 codes indicate
runs of different lengths of black pels. The codes for white-pel runs
are preﬁx-free, as are the codes for black-pel runs, though some of the
codes for runs of white pels are preﬁxes of codes for runs of black pels
and vice versa.
To determine which codes to use for which runs, a standards com-
mittee took a set of eight representative documents and counted how of-
ten each run appeared. They then constructed Huffman codes for these
runs. The most frequent runs, and hence the shortest codes, were for
runs of two, three, and four black pels, with codes 11, 10, and 011, re-
spectively. Other common runs were one black pel (010), ﬁve and six
black pels (0011 and 0010), two to seven white pels (all with four-bit
codes), and other relatively short runs. One fairly frequent run consisted
of 1664 white pels, representing an entire row of white pels. Other short
codes went to runs of white pels whose lengths are powers of 2 or sums
of two powers of 2 (such as 192, which equals 27 C 26). Runs can be
encoded by concatenating encodings of shorter runs. Earlier, I gave as
an example the code for a run of 140 white pels, 10010001000. This
code is actually the concatenation of the codes for a run of 128 white
pels (10010) and a run of 12 white pels (001000).
In addition to compressing information only within each row of the
image, some fax machines compress in both dimensions of the image.
Runs of same-color pels can occur vertically as well as horizontally,
and so instead of treating each row as if it were encountered in isola-
tion, a row is encoded according to where it differs from the preceding
row. For most rows, the difference from the previous row is just a few
pels. This scheme entails the risk that errors propagate: an encoding or
transmission error causes several consecutive rows to be incorrect. For
this reason, fax machines that use this scheme and transmit over phone

168
Chapter 9: Data Compression
lines limit the number of consecutive rows that can use it, so that after a
certain number of rows, they transmit a full row image using the Huff-
man coding scheme, rather than transmitting just the differences from
the previous row.
LZW compression
Another approach to lossless compression, especially for text, takes ad-
vantage of information that recurs in the text, though not necessarily in
consecutive locations. Consider, for example, a famous quotation from
John F. Kennedy’s inaugural address:
Ask not what your country can do for you—ask what you can do
for your country.
Except for the word not, each word in the quotation appears twice. Sup-
pose we made a table of the words:
index
word
1
ask
2
not
3
what
4
your
5
country
6
can
7
do
8
for
9
you
Then we could encode the quotation (ignoring capitalization and punc-
tuation) by
1 2 3 4 5 6 7 8 9 1 3 9 6 7 8 4 5
Because this quotation consists of few words, and a byte can hold in-
tegers ranging from 0 to 255, we can store each index in a single byte.
Thus, we can store this quotation in only 17 bytes, one byte per word,
plus whatever space we need to store the table. At one character per
byte, the original quotation, without punctuation but with spaces be-
tween words, requires 77 bytes.
Of course, the space to store the table matters, for otherwise we could
just number every possible word and compress a ﬁle by storing only
indices of words. For some words, this scheme expands, rather than
compresses. Why? Let’s be ambitious and assume that there are fewer

Chapter 9: Data Compression
169
than 232 words, so that we can store each index in a 32-bit word. We
would represent each word by four bytes, and so this scheme loses for
words that are three letters or shorter, which require only one byte per
letter, uncompressed.
The real obstacle to numbering every possible word, however, is that
real text includes “words” that are not words, or rather, not words in
the English language. For an extreme example, consider the opening
quatrain of Lewis Carroll’s “Jabberwocky”:
’Twas brillig, and the slithy toves
Did gyre and gimble in the wabe:
All mimsy were the borogoves,
And the mome raths outgrabe.
Consider also computer programs, which often use variable names that
are not English words. Add in capitalization, punctuation, and really
long place names,5 and you can see that if we try to compress text by
numbering every possible word, we’re going to have to use a lot of
indices. Certainly more than 232 and, because any combination of char-
acters could appear in text, in reality an unbounded amount.
All is not lost, however, for we can still take advantage of recurring
information. We just have to not be so hung up on recurring words.
Any recurring sequence of characters could help. Several compression
schemes rely on recurring character sequences. The one we’ll examine
is known as LZW,6 and it’s the basis for many compression programs
used in practice.
LZW makes a single pass over its input for compression and for de-
compression. In both, it builds a dictionary of character sequences that
it has seen, and it uses indices into this dictionary to represent character
sequences. Think of the dictionary as an array of character strings. We
can index into this array, so that we can speak of its ith entry. Toward
the beginning of the input, the sequences tend to be short, and repre-
senting the sequences by indices could result in expansion, rather than
compression. But as LZW progresses through its input, the sequences
5Such as Llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogoch, a Welsh vil-
lage.
6As you probably guessed, the name honors its inventors. Terry Welch created LZW
by modifying the LZ78 compression scheme, which was proposed by Abraham Lempel
and Jacob Ziv.

170
Chapter 9: Data Compression
in the dictionary become longer, and representing them by an index can
save quite a bit of space. For example, I ran the text of Moby Dick
through an LZW compressor, and it produced in its output an index rep-
resenting the 10-character sequence tfromtthet 20 times. (Each t
indicates one space character.) It also output an index representing the
eight-character sequence toftthet 33 times.
Both the compressor and decompressor seed the dictionary with a
one-character sequence for each character in the character set. Using the
full ASCII character set, the dictionary starts with 256 single-character
sequences; the ith entry in the dictionary holds the character whose
ASCII code is i.
Before going into a general description of how the compressor works,
let’s look at a couple of situations it handles. The compressor builds
up strings, inserting them into the dictionary and producing as output
indices into the dictionary.
Let’s suppose that the compressor starts
building a string with the character T, which it has read from its in-
put. Because the dictionary has every single-character sequence, the
compressor ﬁnds T in the dictionary. Whenever the compressor ﬁnds
the string that it’s building in the dictionary, it takes the next character
from the input and appends that character to the string it’s building up.
So now let’s suppose that the next input character is A. The compres-
sor appends A to the string it’s building, getting TA. Let’s suppose that
TA is also in the dictionary. The compressor then reads the next input
character, let’s say G. It appends G to the string it’s building, resulting
in TAG, and this time let’s suppose that TAG is not in the dictionary.
The compressor does three things: (1) it outputs the dictionary index of
the string TA; (2) it inserts the string TAG into the dictionary; and (3) it
starts building a new string, initially containing just the character (G)
that caused the string TAG to not be in the dictionary.
Here is how the compressor works in general. It produces a sequence
of indices into the dictionary. Concatenating the strings at these indices
gives the original text. The compressor builds up strings in the dictio-
nary one character at a time, so that whenever it inserts a string into the
dictionary, that string is the same as some string already in the dictio-
nary but extended by one character. The compressor manages a string s
of consecutive characters from the input, maintaining the invariant that
the dictionary always contains s in some entry. Even if s is a single
character, it appears in the dictionary, because the dictionary is seeded
with a single-character sequence for each character in the character set.

Chapter 9: Data Compression
171
Initially, s is just the ﬁrst character of the input. Upon reading a new
character c, the compressor checks to see whether the string s c, formed
by appending c to the end of s, is currently in the dictionary. If it is,
then it appends c to the end of s and calls the result s; in other words,
it sets s to s c. The compressor is building a longer string that it will
eventually insert into the dictionary. Otherwise, s is in the dictionary
but s c is not. In this case, the compressor outputs the index of s in the
dictionary, inserts s c into the next available dictionary entry, and sets
s to just the input character c. By inserting s c into the dictionary, the
compressor has added a string that extends s by one character, and by
then setting s to c, it restarts the process of building a string to look up
in the dictionary. Because c is a single-character string in the dictio-
nary, the compressor maintains the invariant that s appears somewhere
in the dictionary. Once the input is exhausted, the compressor outputs
the index of whatever string s remains.
The procedure LZW-COMPRESSOR appears on the next page. Let’s
run through an example, compressing the text TATAGATCTTAATATA.
(The sequence TAG that we saw on the previous page will come up.)
The following table shows what happens upon each iteration of the loop
in step 3. The values shown for the string s are at the start of the itera-
tion.
Iteration
s
c
Output
New dictionary string
1
T
A
84 (T)
256: TA
2
A
T
65 (A)
257: AT
3
T
A
4
TA
G
256 (TA)
258: TAG
5
G
A
71 (G)
259: GA
6
A
T
7
AT
C
257 (AT)
260: ATC
8
C
T
67 (C)
261: CT
9
T
T
84 (T)
262: TT
10
T
A
11
TA
A
256 (TA)
263: TAA
12
A
T
13
AT
A
257 (AT)
264: ATA
14
A
T
15
AT
A
step 4
ATA
264 (ATA)
After step 1, the dictionary has one-character strings for each of the 256
ASCII characters in entries 0 through 255. Step 2 sets the string s to
hold just the ﬁrst input character, T. In the ﬁrst iteration of the main

172
Chapter 9: Data Compression
Procedure LZW-COMPRESSOR.text/
Input: text: A sequence of characters in the ASCII character set.
Output: A sequence of indices into a dictionary.
1. For each character c in the ASCII character set:
A. Insert c into the dictionary at the index equal to c’s numeric
code in ASCII.
2. Set s to the ﬁrst character from text.
3. While text is not exhausted, do the following:
A. Take the next character from text, and assign it to c.
B. If s c is in the dictionary, then set s to s c.
C. Otherwise (s c is not yet in the dictionary), do the following:
i. Output the index of s in the dictionary.
ii. Insert s c into the next available entry in the dictionary.
iii. Set s to the single-character string c.
4. Output the index of s in the dictionary.
loop of step 3, c is the next input character, A. The concatenation s c is
the string TA, which is not yet in the dictionary, and so step 3C runs. Be-
cause the string s holds just T, and the ASCII code of T is 84, step 3Ci
outputs the index 84. Step 3Cii inserts the string TA into the next avail-
able entry in the dictionary, which is at index 256, and step 3Ciii restarts
building s, setting it to just the character A. In the second iteration of
the loop of step 3, c is the next input character, T. The string s c D AT
is not in the dictionary, and so step 3C outputs the index 65 (the ASCII
code for A), inserts the string AT into entry 257, and sets s to hold T.
We see the beneﬁt of the dictionary upon the next two iterations of
the loop of step 3. In the third iteration, c becomes the next input char-
acter, A. Now the string s c D TA is present in the dictionary, and so the
procedure doesn’t output anything. Instead, step 3B appends the input
character onto the end of s, setting s to TA. In the fourth iteration, c be-
comes G. The string s c D TAG is not in the dictionary, and so step 3Ci
outputs the dictionary index 256 of s. One output number gives not one,
but two characters: TA.
Not every dictionary index is output by the time LZW-COMPRESSOR
ﬁnishes, and some indices may be output more than once. If you con-

Chapter 9: Data Compression
173
catenate all the characters in parentheses in the output column, you get
the original text, TATAGATCTTAATATA.
This example is a little too small to show the real beneﬁt of LZW
compression. The input occupies 16 bytes, and the output consists of
10 dictionary indices. Each index requires more than one byte. Even if
we use two bytes per index in the output, it occupies 20 bytes. If each
index occupies four bytes, a common size for integer values, the output
takes 40 bytes.
Longer texts tend to yield better results. LZW compression reduces
the size of Moby Dick from 1,193,826 bytes to 919,012 bytes. Here, the
dictionary contains 230,007 entries, and so indices have to be at least
four bytes.7 The output consists of 229,753 indices, or 919,012 bytes.
That’s not as compressed as the result of Huffman coding (673,579
bytes), but we’ll see some ideas a little later to improve the compres-
sion.
LZW compression helps only if we can decompress. Fortunately, the
dictionary does not have be stored with the compressed information.
(If it did, unless the original text contained a huge amount of recurring
strings, the output of LZW compression plus the dictionary would con-
stitute an expansion, not a compression.) As mentioned earlier, LZW
decompression rebuilds the dictionary directly from the compressed in-
formation.
Here is how LZW decompression works. Like the compressor, the
decompressor seeds the dictionary with the 256 single-character se-
quences corresponding to the ASCII character set. It reads a sequence
of indices into the dictionary as its input, and it mirrors what the com-
pressor did to build the dictionary. Whenever it produces output, it’s
from a string that it has added to the dictionary.
Most of the time, the next dictionary index in the input is for an entry
already in the dictionary (we’ll soon see what happens the rest of the
time), and so the LZW decompressor ﬁnds the string at that index in
the dictionary and outputs it. But how can it build the dictionary? Let’s
think for a moment about how the compressor operates. When it outputs
an index within step 3C, it has found that, although the string s is in
7I’m assuming that we represent integers using the standard computer representations
of integers, which occupy one, two, four, or eight bytes. In theory, we could represent
indices up to 230,007 using just three bytes, so that the output would take 689,259
bytes.

174
Chapter 9: Data Compression
the dictionary, the string s c is not. It outputs the index of s in the
dictionary, inserts s c into the dictionary, and starts building a new string
to store, starting with c. The decompressor has to match this behavior.
For each index it takes from its input, it outputs the string s at that index
in the dictionary. But it also knows that at the time the compressor
output the index for s, the compressor did not have the string s c in
the dictionary, where c is the character immediately following s. The
decompressor knows that the compressor inserted the string s c into the
dictionary, so that’s what the decompressor needs to do—eventually.
It cannot insert s c yet, because it hasn’t seen the character c. That’s
coming as the ﬁrst character of the next string that the decompressor
will output. But the decompressor doesn’t have that next string just yet.
Therefore, the decompressor needs to keep track of two consecutive
strings that it outputs. If the decompressor outputs strings X and Y, in
that order, then it concatenates the ﬁrst character of Y onto X and then
inserts the resulting string into the dictionary.
Let’s look at an example, referring to the table on page 171, which
shows how the compressor operates on TATAGATCTTAATATA. In it-
eration 11, the compressor outputs the index 256 for the string TA, and
it inserts the string TAA into the dictionary. That’s because, at that time,
the compressor already had s D TA in the dictionary but not s c D TAA.
That last A begins the next string output by the compressor, AT (in-
dex 257), in iteration 13. Therefore, when the decompressor sees in-
dices 256 and 257, it should output TA, and it also should remember
this string so that when it outputs AT, it can concatenate the A from AT
with TA and insert the resulting string, TAA, into the dictionary.
On rare occasions, the next dictionary index in the decompressor’s
input is for an entry not yet in the dictionary. This situation arises so
infrequently that when decompressing Moby Dick, it occurred for only
15 of the 229,753 indices. It happens when the index output by the
compressor is for the string most recently inserted into the dictionary.
This situation occurs only when the string at this index starts and ends
with the same character. Why? Recall that the compressor outputs the
index for a string s only when it ﬁnds s in the dictionary but s c is not,
and then it inserts s c into the dictionary, say at index i, and begins a
new string s starting with c. If the next index output by the compressor
is going to be i, then the string at index i in the dictionary must start
with c, but we just saw that this string is s c. So if the next dictionary in-
dex in the decompressor’s input is for an entry not yet in the dictionary,

Chapter 9: Data Compression
175
the decompressor can output the string it most recently inserted into the
dictionary, concatenated with the ﬁrst character of this string, and insert
this new string into the dictionary.
Because these situations are so rare, an example is a bit contrived.
The string TATATAT causes it to occur. The compressor does the fol-
lowing: outputs index 84 (T) and inserts TA at index 256; outputs in-
dex 65 (A) and inserts AT at index 257; outputs index 256 (TA) and in-
serts TAT at index 258; and ﬁnally outputs index 258 (TAT—the string
just inserted). The decompressor, upon reading in index 258, takes the
string it had most recently output, TA, concatenates the ﬁrst character
of this string, T, outputs the resulting string TAT, and inserts this string
into the dictionary.
Although this rare situation occurs only when the string starts and
ends with the same character, this situation does not occur every time
the string starts and ends with the same character. For example, when
compressing Moby Dick, the string whose index was output had the
same starting and ending character 11,376 times (a shade under 5% of
the time) without being the string most recently inserted into the dictio-
nary.
The procedure LZW-DECOMPRESSOR, on the next page, makes all
of these actions precise. The following table shows what happens in
each iteration of the loop in step 4 when given as input the indices in
the output column in the table on page 171. The strings indexed in the
dictionary by previous and current are output in consecutive iterations,
and the values shown for previous and current in each iteration are after
step 4B.
Iteration
previous
current
Output (s)
New dictionary string
Steps 2, 3
84
T
1
84
65
A
256: TA
2
65
256
TA
257: AT
3
256
71
G
258: TAG
4
71
257
AT
259: GA
5
257
67
C
260: ATC
6
67
84
T
261: CT
7
84
256
TA
262: TT
8
256
257
AT
263: TAA
9
257
264
ATA
264: ATA
Except for the last iteration, the input index is already in the dictionary,
so that step 4D runs only in the last iteration. Notice that the dictio-

176
Chapter 9: Data Compression
Procedure LZW-DECOMPRESSOR.indices/
Input: indices: a sequence of indices into a dictionary, created by
LZW-COMPRESSOR.
Output: The text that LZW-COMPRESSOR took as input.
1. For each character c in the ASCII character set:
A. Insert c into the dictionary at the index equal to c’s numeric
code in ASCII.
2. Set current to the ﬁrst index in indices.
3. Output the string in the dictionary at index current.
4. While indices is not exhausted, do the following:
A. Set previous to current.
B. Take the next number from indices and assign it to current.
C. If the dictionary contains an entry indexed by current, then do
the following:
i. Set s to be the string in the dictionary entry indexed by
current.
ii. Output the string s.
iii. Insert, into the next available entry in the dictionary, the
string at the dictionary entry indexed by previous,
concatenated with the ﬁrst character of s.
D. Otherwise (the dictionary does not yet contain an entry
indexed by current), do the following:
i. Set s to be the string at the dictionary entry indexed by
previous, concatenated with the ﬁrst character of this
dictionary entry.
ii. Output the string s.
iii. Insert, into the next available entry in the dictionary, the
string s.
nary built by LZW-DECOMPRESSOR matches the one built by LZW-
COMPRESSOR.
I haven’t addressed how to look up information in the dictionary in
the LZW-COMPRESSOR and LZW-DECOMPRESSOR procedures. The
latter is easy: just keep track of the last dictionary index used, and if
the index in current is less than or equal to the last-used index, then the

Chapter 9: Data Compression
177
string is in the dictionary. The LZW-COMPRESSOR procedure has a
more difﬁcult task: given a string, determine whether it’s in the dictio-
nary and, if it is, at what index. Of course, we could just perform a linear
search on the dictionary, but if the dictionary contains n items, each lin-
ear search takes O.n/ time. We can do better by using either one of a
couple of data structures. I won’t go into the details here, however. One
is called a trie, and it’s like the binary tree we built for Huffman coding,
except that each node can have many children, not just two, and each
edge is labeled with an ASCII character. The other data structure is a
hash table, and it provides a simple way to ﬁnd strings in the directory
that is fast on average.
LZW improvements
As I mentioned, I was none too impressed with how well the LZW
method compressed the text of Moby Dick. Part of the problem stems
from the large dictionary. With 230,007 entries, each index requires
at least four bytes, and so with an output of 229,753 indices, the com-
pressed version requires four times that, or 919,012 bytes. Then again,
we can observe a couple of properties of the indices that the LZW com-
pressor produces. First, many of them are low numbers, meaning that
they have many leading zeros in their 32-bit representations. Second,
some of the indices are going to occur much more frequently than oth-
ers.
When both of these properties hold, Huffman coding is likely to yield
good results. I modiﬁed the Huffman coding program to work with
four-byte integers rather than characters, and I ran it with the output of
the LZW compressor on Moby Dick. The resulting ﬁle occupies only
460,971 bytes, or 38:61% of the original size (1,193,826 bytes), which
beats Huffman coding alone. Note, however, that I am not including
the Huffman encoding’s size in this ﬁgure. And just as compression
entailed two steps—compress the text with LZW and then compress
the resulting indices with Huffman coding—decompression would be a
two-step process: ﬁrst decompress with Huffman coding, then decom-
press with LZW.
Other approaches to LZW compression focus on reducing the num-
ber of bits necessary to hold the indices that the compressor outputs.
Because many of the indices are small numbers, one approach is to use
fewer bits for smaller numbers, but reserve, say, the ﬁrst two bits to
indicate how many bits the number requires. Here’s one scheme:

178
Chapter 9: Data Compression

If the ﬁrst two bits are 00, then the index is in the range 0 to 63
(26  1), requiring another six bits, and hence one byte in all.

If the ﬁrst two bits are 01, then the index is in the range 64 (26)
to 16,383 (214  1), requiring another 14 bits, and hence two bytes
in all.

If the ﬁrst two bits are 10, then the index is in the range 16,384 (214)
to 4,194,303 (222  1), requiring another 22 bits, and hence three
bytes in all.

Finally, if the ﬁrst two bits are 11, then the index is in the range
4,194,304 (222) to 1,073,741,823 (2301), requiring another 30 bits,
and hence four bytes in all.
In two other approaches, the indices output by the compressor are
all the same size, because the compressor limits the size of the dictio-
nary. In one approach, once the dictionary reaches a maximum size, no
other entries are ever inserted. In another approach, once the dictionary
reaches a maximum size, it is cleared out (except for the ﬁrst 256 en-
tries), and the process of ﬁlling the dictionary restarts from the point
in the text where the dictionary ﬁlled. In all of these approaches, the
decompressor must mirror the compressor’s action.
Further reading
Salomon’s book [Sal08] is particularly clear and concise, yet it covers
a wide range of compression techniques. The book by Storer [Sto88],
published 20 years before Salomon’s book, is a classic text in the ﬁeld.
Section 16.3 of CLRS [CLRS09] delves into Huffman codes in some
detail, though it does not prove that they’re the best possible preﬁx-free
codes.

10 Hard? Problems
When I buy material products over the Internet, the seller has to get
them delivered to my home. Most of the time, the seller uses a package-
delivery company. I won’t say which package-delivery company is most
often used for the products I purchase, other than to say that brown
trucks have been known to stop in front of my driveway every now and
then.
Brown trucks
The package-delivery company operates over 91,000 of these brown
trucks in the U.S., as well as many others worldwide. At least ﬁve days
per week, each truck starts and ends at a speciﬁc depot and drops off
parcels at numerous residential and commercial locations. The package-
delivery company has a keen interest in minimizing the cost incurred by
each truck as it makes many stops each day. For example, one online
source I consulted claimed that once the company mapped out routes for
its drivers to reduce the number of left turns, it reduced the total distance
traveled by its vehicles by 464,000 miles in an 18-month period, saving
over 51,000 gallons of fuel, with the added beneﬁt of decreasing carbon
dioxide emissions by 506 metric tons.
How can the company minimize the cost of sending out each truck
each day? Suppose that a given truck must deliver parcels to n locations
on a particular day. Adding in the depot, there are n C 1 locations that
the truck must visit. For each of these n C 1 locations, the company can
calculate the costs of sending the truck from there to each of the other n
locations, so that the company has an .nC1/.nC1/ table of costs from
location to location, where the entries on the diagonal are meaningless,
since the ith row and the ith column correspond to the same location.
The company wants to determine the route that starts and ends at the
depot and visits all the other n locations exactly once, such that the total
cost of the entire route is as low as possible.
It is possible to write a computer program that will solve this problem.
After all, if we consider a particular route and we know the order of
stops on the route, then it’s just a matter of looking up in the table the

180
Chapter 10: Hard? Problems
costs of going from location to location and adding them up. Then we
just have to enumerate all the possible routes and keep track of which
one has the lowest total cost. The number of possible routes is ﬁnite,
and so the program will terminate at some point and give the answer.
That program doesn’t seem so hard to write, does it?
Indeed, the program isn’t hard to write.
It’s hard to run.
The hitch is that the number of possible routes that visit n locations
is enormous: nŠ (n-factorial). Why? The truck starts at the depot. From
there, any of the other n locations can be the ﬁrst stop. From the ﬁrst
stop, any of the remaining n  1 locations can be the second stop, and
so there are n  .n  1/ possible combinations for the ﬁrst two stops, in
order. Once we settle on the ﬁrst two stops, any of n2 locations could
be the third stop, giving n  .n  1/  .n  2/ possible orders for the ﬁrst
three stops. Extending this reasoning to the n delivery locations, the
number of possible orders is n  .n  1/  .n  2/    3  2  1, or nŠ.
Recall that nŠ grows faster than an exponential function; it’s super-
exponential. In Chapter 8, I pointed out that 10Š equals 3,628,800. To a
computer, that’s not such a big number. But the brown trucks drop off
parcels at many more than just 10 locations per day. Suppose that a truck
delivers to 20 addresses per day. (In the U.S., the company averages
about 170 packages per truck, so even allowing for multiple packages
to be delivered to a single location, 20 stops per day doesn’t seem like an
overestimate.) With 20 stops, a computer program would have to enu-
merate 20Š possible orders, and 20Š equals 2,432,902,008,176,640,000.
If the company’s computers could enumerate and evaluate one trillion
orders per second, it would require over 28 days to try them all. And
that’s for just one day’s worth of deliveries for one of over 91,000 trucks.
With this approach, if the company were to acquire and operate the
computing power needed to ﬁnd the lowest-cost routes for all trucks
each day, the computing cost would easily wipe out the gains from the
more efﬁcient routes. No, this idea of enumerating all possible routes
and keeping track of the best, although mathematically sound, is simply
not practical. Is there a better way to ﬁnd the lowest-cost route for each
truck?
Nobody knows. (Or if somebody does know, he or she isn’t telling.)
Nobody has found a better way, yet nobody has proven that a better way
cannot exist. How frustrating is that?

Chapter 10: Hard? Problems
181
It’s more frustrating than you might imagine. The problem of ﬁnding
the lowest-cost routes for brown trucks is better known as the traveling-
salesman problem, so called because in its original formulation a trav-
eling salesman1 has to visit n cities, starting and ending at the same
city, and visit all the cities with the shortest possible tour. No algorithm
that runs in time O.nc/, for any constant c, has ever been found for the
traveling-salesman problem. We don’t know of an algorithm that, given
the intercity distances among n cities, ﬁnds the best possible order to
visit the n cities in O.n100/ time, O.n1000/ time, or even O.n1,000,000/
time.
It gets worse. Many problems—thousands of them—share this char-
acteristic: for an input of size n, we know of no algorithm that runs
in time O.nc/ for any constant c, yet nobody has proven that no such
algorithm could exist. These problems come from a wide variety of
domains—logic, graphs, arithmetic, and scheduling among them.
To take the frustration to a whole new level, here’s the most amazing
fact: if there were an algorithm that ran in O.nc/ time for any of these
problems, where c is a constant, then there would be an algorithm that
ran in O.nc/ time for all of these problems. We call these problems
NP-complete. An algorithm that runs in time O.nc/ on an input of
size n, where c is a constant, is a polynomial-time algorithm, so called
because nc with some coefﬁcient would be the most signiﬁcant term in
the running time. We know of no polynomial-time algorithm for any
NP-complete problem, but nobody has proven that it’s impossible to
solve some NP-complete problem in polynomial time.
And there’s even more frustration: many NP-complete problems are
almost the same as problems that we know how to solve in polynomial
time. Just a small tweak separates them. For example, recall from Chap-
ter 6 that the Bellman-Ford algorithm ﬁnds shortest paths from a single
source in a directed graph, even if the graph has negative-weight edges,
in ‚.nm/ time, where the graph has n vertices and m edges. If the
graph is given as adjacency lists, then the input size is ‚.n C m/. Let’s
assume that m  n; then the input size is ‚.m/ and nm  m2, and
so the running time of the Bellman-Ford algorithm is polynomial in the
input size. (You can get the same result if n > m.) So ﬁnding shortest
1Sorry about the gendered language. The name is historical, and if the problem were
ﬁrst being cast today, I hope that it would be known as the “traveling-salesperson prob-
lem.”

182
Chapter 10: Hard? Problems
paths is easy. You might be surprised to learn, however, that ﬁnding a
longest acyclic path (that is, a longest path without cycles) between two
vertices is NP-complete. In fact, merely determining whether a graph
contains a path without cycles with at least a given number of edges is
NP-complete.
As another example of related problems, where one is easy and one
is NP-complete, consider Euler tours and hamiltonian cycles. Both of
these problems have to do with ﬁnding paths in a connected, undirected
graph. In an undirected graph, edges have no direction, so that .u; v/
and .v; u/ are the same edge. We say that edge .u; v/ is incident on
vertices u and v. A connected graph has a path between every pair of
vertices. An Euler tour2 starts and ends at the same vertex and visits
each edge exactly once, though it may visit each vertex more than once.
A hamiltonian cycle3 starts and ends at the same vertex and visits each
vertex exactly once (except, of course, for the vertex at which it starts
and ends). If we ask whether a connected, undirected graph has an
Euler tour, the algorithm is remarkably easy: determine the degree of
each vertex, that is, how many edges are incident on it. The graph has
an Euler tour if and only if the degree of every vertex is even. But if
we ask whether a connected, undirected graph has a hamiltonian cycle,
that’s NP-complete. Notice that the question is not “what is the order of
vertices on a hamiltonian cycle in this graph?” but just the more basic
“yes or no: is it possible to construct a hamiltonian cycle on this graph?”
NP-complete problems come up surprisingly often, which is why
I’m including material on them in this book. If you are trying to ﬁnd
a polynomial-time algorithm for a problem that turns out to be NP-
complete, you are likely to be in for a big helping of disappointment.
(But see the section on perspective, pages 208–211.) The concept of
NP-complete problems has been around since the early 1970s, and peo-
ple were trying to solve problems that turned out to be NP-complete
(such as the traveling-salesman problem) well before then. To date, we
2So named because the mathematician Leonhard Euler proved in 1736 that it was not
possible to tour the city of K¨onigsberg, Prussia, by crossing every one of its seven
bridges exactly once and ending up at the starting point.
3The name honors W. R. Hamilton, who in 1856 described a mathematical game on a
graph known as the dodecahedron, in which one player sticks ﬁve pins in any ﬁve con-
secutive vertices and the other player must complete the path to form a cycle containing
all the vertices.

Chapter 10: Hard? Problems
183
don’t know whether a polynomial-time algorithm exists for any NP-
complete problem, nor do we know that no such algorithm can exist.
Many brilliant computer scientists have spent years on this question
without resolving it. I’m not saying that you cannot ﬁnd a polynomial-
time algorithm for an NP-complete problem, but you would be facing
long odds if you were to try.
The classes P and NP and NP-completeness
In the previous chapters, I was concerned about differences in running
times such as O.n2/ vs. O.n lg n/. In this chapter, however, we’ll be
happy if an algorithm runs in polynomial time, so that differences of
O.n2/ vs. O.n lg n/ are insigniﬁcant. Computer scientists generally
regard problems solvable by polynomial-time algorithms as “tractable,”
meaning “easy to deal with.” If a polynomial-time algorithm exists for
a problem, then we say that this problem is in the class P.
At this point, you might be wondering how we could possibly con-
sider a problem that requires ‚.n100/ time as tractable. For an input of
size n D 10, isn’t 10100 a dauntingly large number? Yes, it is; in fact,
the quantity 10100 is a googol (the origin of the name “Google”). For-
tunately, we don’t see algorithms that take ‚.n100/ time. The problems
in P that we encounter in practice require much less time. I’ve rarely
seen polynomial-time algorithms that take worse than, say, O.n5/ time.
Moreover, once someone ﬁnds the ﬁrst polynomial-time algorithm for a
problem, others often follow with even more efﬁcient algorithms. So if
someone were to devise the ﬁrst polynomial-time algorithm for a prob-
lem but it ran in time ‚.n100/, there would be a good chance that others
would follow suit with faster algorithms.
Now suppose that you’re given a proposed solution to a problem,
and you want to verify that the solution is correct. For example, in the
hamiltonian-cycle problem, a proposed solution would be a sequence
of vertices. In order to verify that this solution is correct, you’d need
to check that every vertex appears in the sequence exactly once, ex-
cept that the ﬁrst and last vertices should be the same, and if the se-
quence is hv1; v2; v3; : : : ; vn; v1i then the graph must contain edges
.v1; v2/; .v2; v3/; .v3; v4/; : : : ; .vn1; vn/ and back around to .vn; v1/.
You could easily verify that this solution is correct in polynomial time.
If it is possible to verify a proposed solution to a problem in time poly-
nomial in the size of the input to the problem, then we say that this

184
Chapter 10: Hard? Problems
problem is in the class NP.4 We call the proposed solution a certiﬁcate,
and in order for the problem to be in NP, the time to verify the certiﬁcate
needs to be polynomial in the size of the input to the problem and the
size of the certiﬁcate.
If you can solve a problem in polynomial time, then you can cer-
tainly verify a certiﬁcate for that problem in polynomial time. In other
words, every problem in P is automatically in NP. The reverse—is every
problem in NP also in P?—is the question that has perplexed computer
scientists for all these years. We often call it the “P D NP‹ problem.”
The NP-complete problems are the “hardest” in NP. Informally, a
problem is NP-complete if it satisﬁes two conditions: (1) it’s in NP and
(2) if a polynomial-time algorithm exists for the problem, then there is a
way to convert every problem in NP into this problem in such a way as to
solve them all in polynomial time. If a polynomial-time algorithm exists
for any NP-complete problem—that is, if any NP-complete problem is
in P—then P D NP. Because NP-complete problems are the hardest
in NP, if it turns out that any problem in NP is not polynomial-time
solvable, then none of the NP-complete problems are. A problem is
NP-hard if it satisﬁes the second condition for NP-completeness but
may or may not be in NP.
Here’s a handy list of the pertinent deﬁnitions:

P: problems solvable in polynomial time, i.e., we can solve the prob-
lem in time polynomial in the size of the input to the problem.

Certiﬁcate: a proposed solution to a problem.

NP: problems veriﬁable in polynomial time, i.e., given a certiﬁcate,
we can verify that the certiﬁcate is a solution the problem in time
polynomial in the size of the input to the problem and the size of the
certiﬁcate.

NP-hard: a problem such that if there is a polynomial-time algo-
rithm to solve this problem, then we can convert every problem
in NP into this problem in such a way to solve every problem in NP
in polynomial time.

NP-complete: a problem that is NP-hard and also in NP.
4You probably surmised that the name P comes from “polynomial time.” If you’re won-
dering where the name NP comes from, it’s from “nondeterministic polynomial time.”
It’s an equivalent, but not quite as intuitive, way of viewing this class of problems.

Chapter 10: Hard? Problems
185
Decision problems and reductions
When we talk about the classes P and NP, or about the concept of NP-
completeness, we restrict ourselves to decision problems: their output
is a single bit, indicating “yes” or “no.” I couched the Euler-tour and
hamiltonian-cycle problems in this way: Does the graph have an Euler
tour? Does it have a hamiltonian cycle?
Some problems, however, are optimization problems, where we want
to ﬁnd the best possible solutions, rather than decision problems. For-
tunately, we can often bridge part of this gap by recasting an optimiza-
tion problem as a decision problem. For example, let’s consider the
shortest-path problem. There, we used the Bellman-Ford algorithm to
ﬁnd shortest paths. How can we pose the shortest-path problem as a
yes/no problem? We can ask “Does the graph contain a path between
two speciﬁc vertices whose path weight is at most a given value k?”
We’re not asking for the vertices or edges on the path, but just whether
such a path exists. Assuming that path weights are integers, we can ﬁnd
the actual weight of the shortest path between the two vertices by asking
yes/no questions. How? Pose the question for k D 1. If the answer is
no, then try with k D 2. If the answer is no, try with k D 4. Keep
doubling the value of k until the answer is yes. If that last value of k
was k0, then the answer is somewhere between k0=2 and k0. Then ﬁnd
the true answer by using binary search with an initial interval of k0=2
to k. This approach won’t tell us which vertices and edges a shortest
path contains, but at least it will tell us the weight of a shortest path.
The second condition for a problem to be NP-complete requires that
if a polynomial-time algorithm exists for the problem, then there is a
way to convert every problem in NP into this problem in such a way as
to solve them all in polynomial time. Focusing on decision problems,
let’s see the general idea behind converting one decision problem, X,
into another decision problem, Y, such that if there’s a polynomial-time
algorithm for Y then there’s a polynomial-time algorithm for X. We
call such a conversion a reduction because we’re “reducing” solving
problem X to solving problem Y. Here’s the idea:
polynomial-time
reduction
algorithm X to Y
input y
polynomial-time
algorithm for Y
yes
yes
polynomial-time algorithm for X
no
no
to Y
input x
to X

186
Chapter 10: Hard? Problems
We’re given some input x of size n to problem X. We transform this
input into an input y to problem Y, and we do so in time polynomial
in n, say O.nc/ for some constant c. The way we transform input x into
input y has to obey an important property: if algorithm Y decides “yes”
on input y, then algorithm X should decide “yes” on input x, and if Y
decides “no” on y, then X should decide “no” on x. We call this trans-
formation a polynomial-time reduction algorithm. Let’s see how long
the entire algorithm for problem X takes. The reduction algorithm takes
O.nc/ time, and its output cannot be longer than the time it took, and so
the size of the reduction algorithm’s output is O.nc/. But this output is
the input y to the algorithm for problem Y. Since the algorithm for Y is a
polynomial-time algorithm, on an input of size m, it runs in time O.md/
for some constant d. Here, m is O.nc/, and so the algorithm for Y takes
time O..nc/d/, or O.ncd/. Because both c and d are constants, so is
cd, and we see that the algorithm for Y is a polynomial-time algorithm.
The total time for the algorithm for problem X is O.nc C ncd/, which
makes it, too, a polynomial-time algorithm.
This approach shows that if problem Y is “easy” (solvable in poly-
nomial time), then so is problem X. But we’ll use polynomial-time
reductions to show not that problems are easy, but that they are hard:
If problem X is NP-hard and we can reduce it to problem Y in
polynomial time, then problem Y is NP-hard as well.
Why should this statement hold? Let’s suppose that problem X is
NP-hard and that there is a polynomial-time reduction algorithm to con-
vert inputs to X into inputs to Y. Because X is NP-hard, there is a
way to convert any problem, say Z, in NP into X such that if X has a
polynomial-time algorithm, so does Z. Now you know how that con-
version occurs, namely by a polynomial-time reduction:
polynomial-time
reduction
algorithm Z to X
input x
polynomial-time
algorithm for X
yes
yes
polynomial-time algorithm for Z
no
no
to X
input z
to Z
Because we can convert inputs to X into inputs to Y with a polynomial-
time reduction, we can expand X as we did earlier:

Chapter 10: Hard? Problems
187
polynomial-time
reduction
algorithm Z to X
input x
polynomial-time
algorithm for Y
yes
yes
polynomial-time algorithm for Z
no
no
to X
input z
to Z
polynomial-time
reduction
algorithm X to Y
input y
to Y
polynomial-time algorithm for X
Instead of grouping the polynomial-time reduction for X to Y and the
algorithm for Y together, let’s group the two polynomial-time reduc-
tions together:
polynomial-time
reduction
algorithm Z to X
polynomial-time
algorithm for Y
yes
yes
polynomial-time algorithm for Z
no
no
input z
to Z
polynomial-time
reduction
algorithm X to Y
input y
to Y
input x
to X
Now we note that if we immediately follow the polynomial-time reduc-
tion for Z to X by the polynomial-time reduction from X to Y, we have
a polynomial-time reduction from Z to Y :
polynomial-time
reduction
algorithm Z to Y
input y
polynomial-time
algorithm for Y
yes
yes
polynomial-time algorithm for Z
no
no
to Y
input z
to Z
Just to make sure that the two polynomial-time reductions in se-
quence together constitute a single polynomial-time reduction, we’ll use
a similar analysis to what we did before. Suppose that the input ´ to
problem Z has size n, that the reduction from Z to X takes time O.nc/,
and that the reduction from X to Y on an input of size m takes time
O.md/, where c and d are constants. The output of the reduction from
Z to X cannot be longer than the time it took to produce it, and so this
output, which is also the input x to the reduction from X to Y, has size
O.nc/. Now we know that the size m of the input to the reduction from
X to Y has size m D O.nc/, and so the time taken by the reduction from
X to Y is O..nc/d/, which is O.ncd/. Since c and d are constants, this
second reduction takes time polynomial in n.
Furthermore, the time taken in the last stage, the polynomial-time
algorithm for Y, is also polynomial in n. Suppose that the algorithm
for Y on an input of size p takes time O.pb/, where b is a constant.
As before, the output of a reduction cannot exceed the time taken to

188
Chapter 10: Hard? Problems
produce it, and so p D O.ncd/, which means that the algorithm for Y
takes time O..ncd/b/, or O.nbcd/. Since b, c, and d are all constants,
the algorithm for Y takes time polynomial in the original input size n.
Altogether, the algorithm for Z takes time O.nc C ncd C nbcd/, which
is polynomial in n.
What have we just seen? We showed that if problem X is NP-hard
and there is a polynomial-time reduction algorithm that transforms an
input x to X into an input y to problem Y, then Y is NP-hard, too.
Because X being NP-hard means that every problem in NP reduces to it
in polynomial time, we picked any problem Z in NP that reduces to X
in polynomial time and showed that it also reduces to Y in polynomial
time.
Our ultimate goal is to show that problems are NP-complete. So now
all we have to do to show that a problem Y is NP-complete is

show that it’s in NP, which we can do by showing that there’s a way
to verify a certiﬁcate for Y in polynomial time, and

take some other problem X that we know to be NP-hard and give a
polynomial-time reduction from X to Y.
There is one more little detail that I’ve ignored so far: the Mother
Problem. We need to start with some NP-complete problem M (the
Mother Problem) that every problem in NP reduces to in polynomial
time. Then we can reduce M to some other problem in polynomial time
to show that the other problem is NP-hard, reduce the other problem to
yet some other problem to show that the latter is NP-hard, and so on.
Bear in mind, too, that there’s no limit on how many other problems we
can reduce a single problem to, so that the family tree of NP-complete
problems starts with the Mother Problem and then branches out.
A Mother Problem
Different books list different Mother Problems. That’s ﬁne, since once
you reduce one Mother Problem to some other problem, that other prob-
lem could also serve as the Mother Problem. One Mother Problem often
seen is boolean formula satisﬁability. I’ll brieﬂy describe this problem,
but I won’t prove that every problem in NP reduces to it in polynomial
time. The proof is long and—dare I say—tedious.
First off: “boolean” is mathematical lingo for simple logic in which
variables may take on only the values 0 and 1 (called boolean values),
and operators take one or two boolean values and produce a boolean

Chapter 10: Hard? Problems
189
value. We’ve already seen exclusive-or (XOR) in Chapter 8. Typical
boolean operators are AND, OR, NOT, IMPLIES, and IFF:

x AND y equals 1 only if both x and y are 1; otherwise (either or
both are 0), x AND y equals 0.

x OR y equals 0 only if both x and y are 0; otherwise (either or both
are 1), x OR y equals 1.

NOT x is the opposite of x: it’s 0 if x is 1, and it’s 1 if x is 0.

x IMPLIES y is 0 only if x is 1 and y is 0; otherwise (either x is 0,
or x and y are both 1) x IMPLIES y is 1.

x IFF y means “x if and only if y,” and it equals 1 only if x and y
are equal (both 0 or both 1); if x and y differ (one of them is 0 and
the other is 1), then x IFF y equals 0.
There are 16 possible boolean operators that take two operands, but
these are the most common.5 A boolean formula consists of boolean-
valued variables, boolean operators, and parentheses for grouping.
In the boolean formula satisﬁability problem, the input is a boolean
formula, and we ask whether there is some way to assign the values 0
and 1 to the variables in the formula so that it evaluates to 1. If there
is such a way, we say that the formula is satisﬁable. For example, the
boolean formula

.w IMPLIES x/ OR NOT

.NOT w/ IFF y

OR ´

AND .NOT x/
is satisﬁable: let w D 0, x D 0, y D 1, and ´ D 1. Then the formula
evaluates to

.0 IMPLIES 0/ OR NOT

.NOT 0/ IFF 1

OR 1

AND .NOT 0/
D

1 OR NOT

.1 IFF 1/ OR 1

AND 1
D

1 OR NOT .1 OR 1/

AND 1
D
.1 OR 0/ AND 1
D
1 AND 1
D
1 :
5Some of these 16 two-operand boolean operators are not terribly interesting, such as
the operator that evaluates to 0 regardless of the values of its operands.

190
Chapter 10: Hard? Problems
On the other hand, here’s a simple formula that is not satisﬁable:
x AND .NOT x/ :
If x D 0, then this formula evaluates to 0 AND 1, which is 0; if instead
x D 1, then this formula evaluates to 1 AND 0, which again is 0.
A sampler of NP-complete problems
With boolean formula satisﬁability as our Mother Problem, let’s see
some of the problems that we can show are NP-complete by using
polynomial-time reductions. Here’s the family tree of reductions that
we’ll see:
Mother Problem:
boolean formula satisfiability
3-CNF satisfiability
clique
vertex cover
hamiltonian path
traveling salesman
subset sum
hamiltonian cycle
longest acyclic path
partition
knapsack
I won’t show all the reductions in this family tree, because some of them
are rather long and involved. But we’ll see a couple that are interesting
because they show how to reduce a problem from one domain to a dif-
ferent domain, such as logic (3-CNF satisﬁability) to graphs (the clique
problem).
3-CNF satisﬁability
Because boolean formulas can contain any of the 16 two-operand
boolean operators, and because they can be parenthesized in any num-
ber of ways, it’s difﬁcult to reduce directly from the boolean formula
satisﬁability problem—the Mother Problem. Instead, we will deﬁne a
related problem that is also about satisfying boolean formulas, but that
has some restrictions on the structure of the formula that is the input to
the problem. It will be much easier to reduce from this restricted prob-
lem. Let’s require that the formula be ANDs of clauses, where each

Chapter 10: Hard? Problems
191
clause is an OR of three terms, and each term is a literal: either a vari-
able or the negation of a variable (such as NOT x). A boolean formula
in this form is in 3-conjunctive normal form, or 3-CNF. For example,
the boolean formula

w OR .NOT w/ OR .NOT x/

AND .y OR x OR ´/
AND

.NOT w/ OR .NOT y/ OR .NOT ´/

is in 3-CNF. Its ﬁrst clause is

w OR .NOT w/ OR .NOT x/

.
Deciding whether a boolean formula in 3-CNF has a satisfying as-
signment to its variables—the 3-CNF satisﬁability problem—is NP-
complete. A certiﬁcate is a proposed assignment of the values 0 and 1
to the variables. Checking a certiﬁcate is easy: just plug in the proposed
values for the variables, and verify that the expression evaluates to 1.
To show that 3-CNF satisﬁability is NP-hard, we reduce from (unre-
stricted) boolean formula satisﬁability. Again, I won’t go into the (not
so interesting) details. It gets more interesting when we reduce from a
problem in one domain to a problem in a different domain, which we’re
about to do.
Here’s a frustrating aspect of 3-CNF satisﬁability: although it’s NP-
complete, there is a polynomial-time algorithm to determine whether a
2-CNF formula is satisﬁable. A 2-CNF formula is just like a 3-CNF
formula except that it has two literals, not three, in each clause. A small
change like that takes a problem from being as hard as the hardest prob-
lem in NP to being easy!
Clique
Now we’re going to see an interesting reduction, for problems in differ-
ent domains: from 3-CNF satisﬁability to a problem having to do with
undirected graphs. A clique in an undirected graph G is a subset S of
vertices such that the graph has an edge between every pair of vertices
in S. The size of a clique is the number of vertices it contains.
As you might imagine, cliques play a role in social network theory.
Modeling each individual as a vertex and relationships between individ-
uals as undirected edges, a clique represents a group of individuals all
of whom have relationships with each other. Cliques also have applica-
tions in bioinformatics, engineering, and chemistry.
The clique problem takes two inputs, a graph G and a positive inte-
ger k, and asks whether G has a clique of size k. For example, the graph
on the next page has a clique of size 4, shown with heavily shaded ver-
tices, and no other clique of size 4 or greater.

192
Chapter 10: Hard? Problems
Verifying a certiﬁcate is easy. The certiﬁcate is the k vertices claimed
to form a clique, and we just have to check that each of the k vertices has
an edge to the other k  1. This check is easily performed in time poly-
nomial in the size of the graph. Now we know that the clique problem
is in NP.
How can a problem in satisfying boolean formulas reduce to a graph
problem? We start with a boolean formula in 3-CNF. Suppose that the
formula is C1 AND C2 AND C3 AND    AND Ck, where each Cr is
one of k clauses. From this formula, we will construct a graph in poly-
nomial time, and this graph will have a k-clique if and only if the 3-CNF
formula is satisﬁable. We need to see three things: the construction, an
argument that the construction runs in time polynomial in the size of the
3-CNF formula, and a proof that the graph has a k-clique if and only if
there is some way to assign to the variables of the 3-CNF formula so
that it evaluates to 1.
To construct a graph from a 3-CNF formula, let’s focus on the rth
clause, Cr. It has three literals; let’s call them lr
1, lr
2, and lr
3, so that Cr
is lr
1 OR lr
2 OR lr
3. Each literal is either a variable or the negation of a
variable. We create one vertex for each literal, so that for clause Cr,
we create a triple of vertices, vr
1, vr
2, and vr
3. We add an edge between
vertices vr
i and vs
j if two conditions hold:

vr
i and vs
j are in different triples; that is, r and s are different clause
numbers, and

their corresponding literals are not negations of each other.
For example, the graph on the next page corresponds to the 3-CNF for-
mula

x OR .NOT y/ OR .NOT ´/

AND

.NOT x/ OR y OR ´

AND .x OR y OR ´/ :

Chapter 10: Hard? Problems
193
NOT x
y
z
x
NOT z
x
y
z
C3 = x OR y OR z
C2 = (NOT x) OR y OR z
C1 = x OR (NOT y) OR (NOT z)
NOT y
It’s easy enough to see that this reduction can be performed in poly-
nomial time. If the 3-CNF formula has k clauses, then it has 3k literals,
and so the graph has 3k vertices. At most, each vertex has an edge to
all the other 3k  1 vertices, and so the number of edges is at most
3k.3k  1/, which equals 9k2  3k. The size of the graph constructed
is polynomial in the size of the 3-CNF input, and it’s easy to determine
which edges go into the graph.
Finally, we need to show that the constructed graph has a k-clique if
and only if the 3-CNF formula is satisﬁable. We start by assuming that
the formula is satisﬁable, and we’ll show that the graph has a k-clique.
If there exists a satisfying assignment, each clause Cr contains at least
one literal lr
i that evaluates to 1, and each such literal corresponds to a
vertex vr
i in the graph. If we select one such literal from each of the k
clauses, we get a corresponding set S of k vertices. I claim that S is
a k-clique. Consider any two vertices in S. They correspond to liter-
als in different clauses that evaluate to 1 in the satisfying assignment.
These literals cannot be negations of each other, because if they were,
then one of them would evaluate to 1 but the other would evaluate to 0.
Since these literals are not negations of each other, we created an edge
between the two vertices when we constructed the graph. Because we
can pick any two vertices in S as this pair, we see that there are edges
between all pairs of vertices in S. Hence, S, a set of k vertices, is a
k-clique.
Now we have to show the other direction:
if the graph has a
k-clique S, then the 3-CNF formula is satisﬁable. No edges in the graph
connect vertices in the same triple, and so S contains exactly one vertex
per triple. For each vertex vi
r in S, assign 1 to its corresponding literal li
r
in the 3-CNF formula. We don’t have to worry about assigning a 1 to

194
Chapter 10: Hard? Problems
both a literal and its negation, since the k-clique cannot contain vertices
corresponding to a literal and its negation. Since each clause has a lit-
eral that evaluates to 1, each clause is satisﬁed, and so the entire 3-CNF
formula is satisﬁed. If any variables don’t correspond to vertices in the
clique, assign values to them arbitrarily; they won’t affect whether the
formula is satisﬁed.
In the above example, a satisfying assignment has y D 0 and ´ D 1;
it doesn’t matter what we assign to x. A corresponding 3-clique con-
sists of the heavily shaded vertices, which correspond to NOT y from
clause Ci and ´ from clauses C2 and C3.
Thus, we have shown that there exists a polynomial-time reduction
from the NP-complete problem of 3-CNF satisﬁability to the problem of
ﬁnding a k-clique. If you were given a boolean formula in 3-CNF with k
clauses, and you had to ﬁnd a satisfying assignment for the formula, you
could use the construction we just saw to convert the formula in polyno-
mial time to an undirected graph, and determine whether the graph had a
k-clique. If you could determine in polynomial time whether the graph
had a k-clique, then you would have determined in polynomial time
whether the 3-CNF formula had a satisfying assignment. Since 3-CNF
satisﬁability is NP-complete, so is determining whether a graph con-
tains a k-clique. As a bonus, if you could determine not only whether
the graph had a k-clique, but which vertices constituted the k-clique,
then you could use this information to ﬁnd the values to assign to the
variables of the 3-CNF formula in a satisfying assignment.
Vertex cover
A vertex cover in an undirected graph G is a subset S of the vertices
such that every edge in G is incident on at least one vertex in S. We say
that each vertex in S “covers” its incident edges. The size of a vertex
cover is the number of vertices it contains. As in the clique problem,
the vertex-cover problem takes as input an undirected graph G and a
positive integer m. It asks whether G has a vertex cover of size m. Like
the clique problem, the vertex-cover problem has applications in bioin-
formatics. In another application, you have a building with hallways
and cameras that can scan up to 360 degrees located at the intersections
of hallways, and you want to know whether m cameras will allow you
to see all the hallways. Here, edges model hallways and vertices model
intersections. In yet another application, ﬁnding vertex covers helps in
designing strategies to foil worm attacks on computer networks.

Chapter 10: Hard? Problems
195
A certiﬁcate for the vertex-cover problem is, not surprisingly, a pro-
posed vertex cover. It’s easy to verify in time polynomial in the size
of the graph that the proposed vertex cover has size m and really does
cover all the edges, and so we see that this problem is in NP.
The NP-completeness family tree on page 190 tells you that we re-
duce the clique problem to the vertex-cover problem. Suppose that the
input to the clique problem is an undirected graph G with n vertices
and a positive integer k. In polynomial time, we’ll produce an input
graph G to the vertex-cover problem such that G has a clique of size k
if and only if G has a vertex cover of size n  k. This reduction is
really easy. The graph G has the same vertices as G, and it has ex-
actly the opposite edges as G. In other words, edge .u; v/ is in G if
and only if .u; v/ is not in G. You might have guessed that the vertex
cover of size n  k in G consists of the vertices not in the clique of k
vertices in G—and you would be correct! Here are examples of graphs
G and G, with eight vertices. The ﬁve vertices forming a clique in G
and the remaining three vertices forming a vertex cover in G are heavily
shaded:
G
G
Note that every edge in G is incident on at least one heavily shaded
vertex.
We need to show that G has a k-clique if and only if G has a vertex
cover of size n  k. Start by supposing that G has a k-clique C. Let
S consist of the n  k vertices not in C. I claim that every edge in G
is incident on at least one vertex in S. Let .u; v/ be any edge in G. It’s
in G because it was not in G. Because .u; v/ is not in G, at least one
of the vertices u and v is not in the clique C of G, because an edge
connects every pair of vertices in C. Since at least one of u and v is not
in C, at least one of u and v is in S, which means that edge .u; v/ is
incident on at least one of the vertices in S. Since we chose .u; v/ to be
any edge in G, we see that S is a vertex cover for G.

196
Chapter 10: Hard? Problems
Now we go the other way. Suppose that G has a vertex cover S
containing n  k vertices, and let C consist of the k vertices not in S.
Every edge in G is incident on some vertex in S. In other words, if
.u; v/ is an edge in G, then at least one of u and v is in S. If you
recall the deﬁnition of contrapositive on page 22, you can see that the
contrapositive of this implication is that if neither u nor v is in S, then
.u; v/ is not in G—and therefore, .u; v/ is in G. In other words, if both
u and v are in C, then the edge .u; v/ is present in G. Since u and v are
any pair of vertices in C, we see that there is an edge in G between all
pairs of vertices in C. That is, C is a k-clique.
Thus, we have shown that there exists a polynomial-time reduction
from the NP-complete problem of determining whether an undirected
graph contains a k-clique to the problem of determining whether an
undirected graph contains a vertex cover of size n  k. If you were
given an undirected graph G and you wanted to know whether it con-
tained a k-clique, you could use the construction we just saw to convert
G in polynomial time to G, and determine whether G contained a ver-
tex cover with n  k vertices. If you could determine in polynomial
time whether G had a vertex cover of size n  k, then you would have
determined in polynomial time whether G had a k-clique. Since the
clique problem is NP-complete, so is the vertex-cover problem. As a
bonus, if you could determine not only whether G had a vertex cover of
n  k vertices, but which vertices constituted the cover, then you could
use this information to ﬁnd the vertices in the k-clique.
Hamiltonian cycle and hamiltonian path
We’ve already seen the hamiltonian-cycle problem: does a connected,
undirected graph contain a hamiltonian cycle (a path that starts and ends
at the same vertex and visits all other vertices exactly once)? The appli-
cations of this problem are a bit arcane, but from the NP-completeness
family tree on page 190, you can see that we use this problem to show
that the traveling-salesman problem is NP-complete, and we’ve seen
how the traveling-salesman problem comes up in practice.
A closely related problem is the hamiltonian-path problem, which
asks whether the graph contains a path that visits each vertex exactly
once, but does not require that the path be a closed cycle. This problem,
too, is NP-complete, and we will use it on page 199 to show that the
longest-acyclic-path problem is NP-complete.
For both of the hamiltonian problems, the certiﬁcate is obvious: the
order of the vertices in the hamiltonian cycle or path. (For a hamiltonian

Chapter 10: Hard? Problems
197
cycle, don’t repeat the ﬁrst vertex at the end.) Given a certiﬁcate, we
need only check that each vertex appears exactly once in the list and that
the graph contains an edge between each pair of consecutive vertices in
the ordering. For the hamiltonian-cycle problem, we also have to check
that an edge exists between the ﬁrst and last vertices.
I won’t detail the polynomial-time reduction from the vertex-cover
problem to the hamiltonian-cycle problem, which shows that the latter
is NP-hard. It’s quite complicated and relies on a widget, which is a
piece of a graph that enforces certain properties. The widget used in
the reduction has the property that any hamiltonian cycle in the graph
constructed by the reduction can traverse the widget in one of only three
ways.
To reduce the hamiltonian-cycle problem to the hamiltonian-path
problem, we start with a connected, undirected graph G with n ver-
tices, and from it we will form a new connected, undirected graph G0
with n C 3 vertices. We pick any vertex u in G, and let its adjacent
vertices be v1; v2; : : : ; vk. To construct G0, we add three new vertices,
x, y, and ´, and we add edges .u; x/ and .y; ´/, along with edges
.v1; y/; .v2; y/; : : : ; .vk; y/ between y and all the vertices adjacent to u.
Here’s an example:
u
u
x
y
´
v1
v1
v2
v2
v3
v3
G
G0
Heavy edges indicate a hamiltonian cycle in G and a corresponding
hamiltonian path in G0. This reduction takes polynomial time, since G0
contains just three more vertices than G and at most n C 1 additional
edges.
As usual, we need to show that the reduction works: that G has a
hamiltonian cycle if and only if G0 has a hamiltonian path. Suppose
that G has a hamiltonian cycle. It must contain an edge .u; vi/ for some

198
Chapter 10: Hard? Problems
vertex vi adjacent to u and, therefore, adjacent to y in G0. To form
a hamiltonian path in G, going from x to ´, take all the edges of the
hamiltonian cycle except for .u; vi/ and add the edges .u; x/, .vi; y/,
and .y; ´/. In the above example, vi is vertex v2, and so the hamiltonian
path omits edge .v2; u/ and adds edges .u; x/, .v2; y/, and .y; ´/.
Now suppose that G0 has a hamiltonian path. Because vertices x
and ´ each have only one incident edge, the hamiltonian path must go
from x to ´, and it must contain an edge .vi; y/ for some vertex adjacent
to y and, therefore, adjacent to u. To ﬁnd a hamiltonian cycle in G,
remove x, y, and ´ and all their incident edges, and use all the edges in
the hamiltonian path in G0, along with .vi; u/.
A similar denouement to those of our previous reductions holds here.
There exists a polynomial-time reduction from the NP-complete prob-
lem of determining whether a connected, undirected graph contains a
hamiltonian cycle to the problem of determining whether a connected,
undirected graph contains a hamiltonian path. Since the former is NP-
complete, so is the latter. Moreover, knowing the edges in the hamilto-
nian path gives the edges in the hamiltonian cycle.
Traveling salesman
In the decision version of the traveling-salesman problem, we are given
a complete undirected graph with a nonnegative integer weight on each
edge, and a nonnegative integer k. A complete graph has an edge be-
tween every pair of vertices, so that if a complete graph has n vertices,
then it has n.n  1/ edges. We ask whether the graph has a cycle con-
taining all vertices whose total weight is at most k.
It’s pretty easy to show that this problem is in NP. A certiﬁcate con-
sists of the vertices of the cycle, in order. We can easily check in poly-
nomial time whether the edges on this cycle visit all the vertices and
have a total weight of k or less.
To show that the traveling-salesman problem is NP-hard, we reduce
from the hamiltonian-cycle problem, another simple reduction. Given a
graph G as input to the hamiltonian-cycle problem, we construct a com-
plete graph G0 with the same vertices as G. Set the weight of edge .u; v/
in G0 to 0 if .u; v/ is an edge in G, and set it to 1 if there is no edge .u; v/
in G. Set k to 0. This reduction takes time polynomial in the size of G,
since it adds at most n.n  1/ edges.
To show that the reduction works, we need to show that G has a
hamiltonian cycle if and only if G0 has a cycle of weight 0 that includes
all the vertices. Once again, the argument is easy. Suppose that G has

Chapter 10: Hard? Problems
199
a hamiltonian cycle. Then each edge on the cycle is in G, and so each
of these edges gets a weight of 0 in G0. Thus, G0 has a cycle containing
all the vertices, and the total weight of this cycle is 0. Conversely, now
suppose that G0 has a cycle containing all the vertices and whose total
weight is 0. Then each edge on this cycle must also be in G, and so G
has a hamiltonian cycle.
I don’t need to repeat the now-familiar denouement, do I?
Longest acyclic path
In the decision version of the longest-acyclic-path problem, we are
given an undirected graph G and an integer k, and we ask whether G
contains two vertices that have an acyclic path between them with at
least k edges.
Once again, a certiﬁcate for the longest-acyclic-path problem is easy
to verify. It consists of the vertices in the proposed path, in order. We
can check in polynomial time that the list contains at least kC1 vertices
(kC1 because a path with k edges contains kC1 vertices) with no vertex
repeated and that there is an edge between every pair of consecutive
vertices in the list.
Yet another simple reduction shows that this problem is NP-hard.
We reduce from the hamiltonian-path problem. Given a graph G with
n vertices as input to the hamiltonian-path problem, the input to the
longest-acyclic-path problem is the graph G, unchanged, and the inte-
ger k D n  1. If this isn’t a polynomial-time reduction, I don’t know
what is.
We show that the reduction works by showing that G has a hamilto-
nian path if and only if it has an acyclic path containing at least n  1
edges. But a hamiltonian path is an acyclic path containing n1 edges,
so we’re done!
Subset sum
In the subset-sum problem, the input is a ﬁnite set S of positive integers,
in no particular order, and a target number t, which is also a positive
integer. We ask whether there exists a subset S 0 of S whose elements
sum to exactly t. For example, if S is the set f1; 2, 7, 14, 49, 98, 343,
686, 2409, 2793, 16808, 17206, 117705, 117993g and t D 138457,
then the subset S 0 D f1; 2, 7, 98, 343, 686, 2409, 17206, 117705g is a
solution. A certiﬁcate is, of course, a subset of S, which we can verify
by just adding up the numbers in the subset and checking that their sum
equals t.

200
Chapter 10: Hard? Problems
As you can see from the NP-completeness family tree on page 190,
we show that the subset-sum problem is NP-hard by reducing from
3-CNF satisﬁability. Here is another reduction that crosses problem
domains, transforming a problem in logic into an arithmetic problem.
You’ll see that the transformation is clever but, ultimately, quite straight-
forward.
We start with a 3-CNF boolean formula F that has n variables and
k clauses. Let’s name the variables v1; v2; v3; : : : ; vn and the clauses
C1; C2; C3; : : : ; Ck. Each clause contains exactly three literals (remem-
ber that each literal is either vi or NOT vi) joined together by ORs, and
the entire formula F is C1 AND C2 AND C3 AND    AND Ck. Put
another way, for a given assignment of 0 or 1 to each variable, each
clause is satisﬁed if any of its literals evaluates to 1, and the full for-
mula F is satisﬁed only if all of its clauses are satisﬁed.
Before we construct the set S for the subset-sum problem, let’s con-
struct the target number t from the 3-CNF formula F . We’ll construct
it as a decimal integer with n C k digits. The least signiﬁcant k digits
(the rightmost k digits) of t correspond to the k clauses of F , and each
of these digits is a 4. The most signiﬁcant n digits of t correspond to the
n variables of F , and each of these digits is a 1. If the formula F has,
say, three variables and four clauses, then t comes out to 1114444. As
we’ll see, if there is a subset of S that sums to t, then the digits of t that
correspond to the variables (the 1s) will ensure that we assign a value
to each variable in F , and the digits of t that correspond to the clauses
(the 4s) will ensure that each clause of F is satisﬁed.
The set S will consist of 2n C 2k integers. It contains integers xi
and x0
i for each of the n variables vi in the 3-CNF formula F , and it
contains integers qj and q0
j for each of the k clauses Cj in F . We con-
struct each integer in S digit by digit, in decimal. Let’s see an example
with n D 3 variables and k D 4 clauses, so that the 3-CNF formula is
F D C1 AND C2 AND C3 AND C4, and let the clauses be
C1
D
v1 OR .NOT v2/ OR .NOT v3/ ;
C2
D
.NOT v1/ OR .NOT v2/ OR .NOT v3/ ;
C3
D
.NOT v1/ OR .NOT v2/ OR v3 ;
C4
D
v1 OR v2 OR v3 :
Here are the corresponding set S and target t:

Chapter 10: Hard? Problems
201
=
1
0
0
1
0
0
1
=
1
0
0
0
1
1
0
=
0
1
0
0
0
0
1
=
0
1
0
1
1
1
0
=
0
0
1
0
0
1
1
=
0
0
1
1
1
0
0
=
0
0
0
1
0
0
0
=
0
0
0
2
0
0
0
=
0
0
0
0
1
0
0
=
0
0
0
0
2
0
0
=
0
0
0
0
0
1
0
=
0
0
0
0
0
2
0
=
0
0
0
0
0
0
1
=
0
0
0
0
0
0
2
=
1
1
1
4
4
4
4
v1
v2
v3
C1
C2
C3
C4
x1
x0
1
x2
x0
2
x3
x0
3
q1
q0
1
q2
q0
2
q3
q0
3
q4
q0
4
t
Note that the shaded elements of S—1000110, 101110, 10011, 1000,
2000, 200, 10, 1, and 2—sum to 1114444. We’ll soon see what these
elements correspond to in the 3-CNF formula F .
We construct the integers in S so that, digit by digit, every column in
the above diagram sums to either 2 (the leftmost n columns) or 6 (the
rightmost k columns). Note that when elements in S are added up, no
carries out of any digit position can occur and we can work with the
numbers digit by digit.
In the diagram, each row is labeled by an element in S. The ﬁrst 2n
rows correspond to the n variables of the 3-CNF formula, and the last
2k rows are “slack” whose purpose we’ll see a little later. The rows
labeled by elements xi and x0
i correspond respectively to occurrences of
the literals vi and NOT vi in F . We’ll say that these rows “are” the liter-
als, understanding that we mean that they correspond to the literals. The
goal is to include in the subset S 0 exactly n of the ﬁrst 2n rows—indeed,
just one of each xi, x0
i pair—which will correspond to a satisfying as-
signment for the 3-CNF formula F . Because we require that the rows
we choose from the literals add up to 1 in each of the leftmost n col-
unms, we ensure that, for each variable vi in the 3-CNF formula, we
include in S 0 a row for one of xi and x0
i, but not both. The rightmost
k columns ensure that the rows we include in S 0 are literals that satisfy
each clause in the 3-CNF formula.

202
Chapter 10: Hard? Problems
Let’s focus for the moment on the n leftmost columns, which are
labeled by the variables v1; v2; : : : ; vn. For a given variable vi, both xi
and x0
i have a 1 in the digit corresponding to vi, and they have 0 in all
other digit positions corresponding to other variables. For example, the
leftmost three digits of both x2 and x0
2 are 010. The digits of the last 2k
rows in the leftmost n columns are 0. Because the target t has a 1 in
each of the variable positions, exactly one of xi and x0
i must be in the
subset S 0 in order to contribute to the sum. Having xi in S 0 corresponds
to setting vi to 1, and having x0
i in S 0 corresponds to setting vi to 0.
Now we turn our attention to the rightmost k columns, which corre-
spond to the clauses. These columns ensure that each clause is satisﬁed,
as we will see below. If the literal vi appears in clause Cj, then xi has
a 1 in the column for Cj; if the literal NOT vi appears in clause Cj,
then x0
i has a 1 in the Cj column. Because each clause in a 3-CNF for-
mula contains exactly three distinct literals, the column for each clause
must contain exactly three 1s among all the xi and x0
i rows. For a given
clause Cj, the rows among the ﬁrst 2n that are included in S 0 corre-
spond to satisfying 0, 1, 2, or 3 of the literals in Cj, and so these rows
contribute 0, 1, 2, or 3 to the sum for Cj’s column.
But the target digit for each clause is 4, and that’s where the “slack”
elements qj and q0
j, for j D 1; 2; 3; : : : ; k, come in. They ensure that
for each clause, the subset S 0 includes some literal in the clause (some
xi or x0
i that has a 1 in the column for that clause). The row for qj has a 1
in the column for clause Cj and 0 everywhere else, and the row for q0
j
is the same except that it has a 2. We can add in these rows to achieve
the target digit of 4, but only if the subset S 0 includes at least one literal
from Cj. Which of these slack rows need to be added in depends on
how many of the literals of clause Cj are included in S 0. If S 0 includes
just one literal, then both slack rows are needed, because the sum in
the column is 1 from the literal, plus 1 from qj, plus 2 from q0
j. If S 0
includes two literals, then just q0
j is needed, because the column sum is 2
from the two literals, plus 2 from q0
j. If S 0 includes three literals, then
just qj is needed, because the column sum is 3 from the three literals,
plus 1 from qj. But, if no literals from clause Cj are included in S 0, then
qj C q0
j D 3 is not enough to achieve the target digit of 4. Therefore,
we can achieve the target digit of 4 for each clause only if some literal
in the clause is included in the subset S 0.
Now that we’ve seen the reduction, we can see that it takes polyno-
mial time. We’re creating 2n C 2k C 1 integers (including the target t),

Chapter 10: Hard? Problems
203
each with nCk digits. You can see from the diagram that of the integers
constructed, no two are equal, and so S really is a set. (The deﬁnition
of a set does not allow repeated elements.)
To show that the reduction works, we need to show that the 3-CNF
formula F has a satisfying assignment if and only if there exists a sub-
set S 0 of S that sums to exactly t. At this point, you’ve seen the idea,
but let’s recap. First, suppose that F has a satisfying assignment. If
this assignment sets vi to 1, then include xi in S 0; otherwise, include x0
i.
Because exactly one of xi and x0
i is in S, the column for vi must sum
to 1, matching the appropriate digit of t. Because the assignment satis-
ﬁes each clause Cj, the xi and x0
i rows must contribute 1, 2, or 3 (the
number of literals in Cj that are 1) to the sum in Cj’s column. Including
the necessary slack rows qj and/or q0
j in S 0 achieves the target digit 4.
Conversely, suppose that S has a subset S 0 that sums to exactly t.
In order for t to have a 1 in the leftmost n positions, S 0 must include
exactly one of xi and x0
i for each variable vi. If it includes xi, then
set vi to 1; if it includes x0
i, then set vi to 0. Because the slack rows qj
and q0
j summed together cannot achieve the target digit 4 in the column
for clause Cj, the subset S 0 must also include at least one row xi or x0
i
with a 1 in Cj’s column. If it includes xi, then the literal vi appears
in clause Cj, and the clause is satisﬁed. If S 0 includes x0
i, then the
literal NOT vi appears in clause Cj, and the clause is satisﬁed. Thus,
each clause is satisﬁed, and there exists a satisfying assignment for the
3-CNF formula F .
And so we see that if we could solve the subset-sum problem in poly-
nomial time, we could also determine whether a 3-CNF formula is sat-
isﬁable in polynomial time. Since 3-CNF satisﬁability is NP-complete,
so is the subset-sum problem. Moreover, if we know which integers in
the constructed set S sum to the target t, we can determine how to set
the variables in the 3-CNF formula so that it evaluates to 1.
One other note about the reduction I used: the digits don’t have to
be decimal digits. What matters is that no carries from one place to
another can occur when adding up the integers. Since no column’s sum
can exceed 6, interpreting the numbers in any base 7 or greater would be
ﬁne. Indeed, the example I gave on page 199 comes from the numbers
in the diagram, but interpreted in base 7.
Partition
The partition problem is closely related to the subset-sum problem. In
fact, it’s a special case of the subset-sum problem: if ´ equals the sum

204
Chapter 10: Hard? Problems
of all the integers in the set S, then the target t is exactly ´=2. In other
words, the goal is to determine whether there exists a partition of the
set S into two disjoint sets S 0 and S 00 such that each integer in S is
in either S 0 or S 00 but not both (that’s what it means for S 0 and S 00 to
partition S) and the sum of the integers in S 0 equals the sum of the
integers in S 00. As in the subset-sum problem, a certiﬁcate is a subset
of S.
To show that the partition problem is NP-hard, we reduce from the
subset-sum problem. (No big surprise there.) Given a set R of posi-
tive integers and a positive integer target t as input to the subset-sum
problem, in polynomial time we construct a set S as input to the par-
tition problem. First, compute ´ as the sum of all the integers in R.
We assume that ´ is not equal to 2t, because if it is, then the problem
is already a partition problem. (If ´ D 2t, then t D ´=2, and we’re
trying to ﬁnd a subset of R that sums to the same total as the integers
not in the subset.) Then choose any integer y that is greater than both
t C ´ and 2´. Deﬁne the set S to contain all the integers in R and two
additional integers: y  t and y  ´ C t. Because y is greater than
both t C ´ and 2´, we know that both y  t and y  ´ C t are greater
than ´ (the sum of the integers in R), and so these two integers cannot
be in R. (Remember that because S is a set, all of its elements must be
unique. We also know that, because ´ is not equal to 2t, we must have
y  t ¤ y  ´ C t, and so the two new integers are unique.) Note that
the sum of all the integers in S equals ´ C .y  t/ C .y  ´ C t/, which
is just 2y. Therefore, if S is partitioned into two disjoint subsets with
equal sums, each subset must sum to y.
To show that the reduction works, we need to show that there exists
a subset R0 of R whose integers sum to t if and only if there exists a
partition of S into S 0 and S 00 such that the integers in S 0 and the integers
in S 00 have the same sum. First, let’s suppose that some subset R0 of R
has integers that sum to t. Then the integers in R that are not in R0 must
sum to ´  t. Let’s deﬁne the set S 0 to have all the integers in R0 along
with y  t (so that S 00 has y  ´ C t along with all the integers in R that
are not in R0). We just need to show that the integers in S 0 sum to y.
But that’s easy: the integers in R0 sum to t, and adding in y  t gives a
sum of y.
Conversely, let’s suppose that there exists a partition of S into S 0
and S 00, both of which sum to y. I claim that the two integers we added
to R when forming S (y  t and y  ´ C t) can’t both be in S 0, nor

Chapter 10: Hard? Problems
205
can they both be in S 00. Why? If they were in the same set, then that
set would sum to at least .y  t/ C .y  ´ C t/, which equals 2y  ´.
But remember that y is greater than ´ (in fact, it’s greater than 2´), and
so 2y  ´ is greater than y. Therefore, if y  t and y  ´ C t were
in the same set, then that set’s sum would be greater than y. So we
know that one of y  t and y  ´ C t is in S 0 and the other is in S 00.
It doesn’t matter which set we say that y  t is in, so let’s say that it’s
in S 0. Now, we know that the integers in S 0 sum to y, which means that
the integers in S 0 other than y  t must sum to y  .y  t/, or t. Since
y  ´ C t cannot also be in S 0, we know that all the other integers in S 0
came from R. Hence, there is a subset of R that sums to t.
Knapsack
In the knapsack problem, we are given a set of n items, each with a
weight and a value, and we ask whether there exists a subset of items
whose total weight is at most a given weight W and whose total value
is at least a given value V . This problem is the decision version of an
optimization problem where we want to load up a knapsack with the
most valuable subset of items, subject to not exceeding a weight limit.
This optimization problem has obvious applications, such as deciding
which items to take backpacking or what loot a burglar should choose
to pilfer.
The partition problem is really just a special case of the knapsack
problem, in which the value of each item equals its weight and both
W and V equal half the total weight. If we could solve the knapsack
problem in polynomial time, then we could solve the partition problem
in polynomial time. Therefore, the knapsack problem is at least as hard
as the partition problem, and we don’t even need to go through the full
reduction process to show that the knapsack problem is NP-complete.
General strategies
As you have probably realized by now, there is no one-size-ﬁts-all way
to reduce one problem to another in order to prove NP-hardness. Some
reductions are pretty simple, such as reducing the hamiltonian-cycle
problem to the traveling-salesman problem, and some are extremely
complicated. Here are a few things to remember and some strategies
that often help.

206
Chapter 10: Hard? Problems
Go from general to speciﬁc
When reducing problem X to problem Y, you always have to start with
an arbitrary input to problem X. But you are allowed to restrict the input
to problem Y as much as you like. For example, when reducing from
3-CNF satisﬁability to the subset-sum problem, the reduction had to be
able to handle any 3-CNF formula as its input, but the subset-sum input
it produced had a particular structure: 2n C 2k integers in the set, and
each integer was formed in a particular way. The reduction was not able
to produce every possible input to the subset-sum problem, but that was
OK. The point is that we can solve a 3-CNF satisﬁability problem by
transforming the input into an input to the subset-sum problem and then
using the answer to the subset-sum problem as the answer to the 3-CNF
satisﬁability problem.
Take note, however, that every reduction has to be of this form: trans-
form any input to problem X into some input to problem Y, even when
chaining together reductions. If you want to reduce problem X to prob-
lem Y and also problem Y to problem Z, the ﬁrst reduction has to
transform any input to X into some input to Y, and the second reduction
has to transform any input to Y into some input to Z. It’s not enough
for the second reduction to transform only the types of inputs to Y that
are produced by the reduction from X.
Take advantage of restrictions in the problem you’re reducing from
In general, when reducing from problem X to problem Y, you may
choose problem X to impose more restrictions on its input. For exam-
ple, it’s almost always much easier to reduce from 3-CNF satisﬁability
than to reduce from the Mother Problem of boolean formula satisﬁabil-
ity. Boolean formulas can be arbitrarily complicated, but you’ve seen
how we can exploit the structure of 3-CNF formulas when reducing.
Likewise, it’s usually more straightforward to reduce from the ham-
iltonian-cycle problem than from the traveling-salesman problem, even
though they are so similar. That’s because in the traveling-salesman
problem, the edge weights can be any positive integers, not just the 0
or 1 that we required when reducing to it. The hamiltonian-cycle prob-
lem is more restricted because each edge has only one of two “values”:
present or absent.
Look for special cases
Several NP-complete problems are just special cases of other NP-
complete problems, much as the partition problem is a special case of

Chapter 10: Hard? Problems
207
the knapsack problem. If you know that problem X is NP-complete
and that it’s a special case of problem Y, then problem Y must be NP-
complete as well. That is because, as we saw for the knapsack problem,
a polynomial-time solution for problem Y would automatically give a
polynomial-time solution for problem X. More intuitively, problem Y,
being more general than problem X, is at least as hard.
Select an appropriate problem to reduce from
It’s often a good strategy to reduce from a problem in the same, or
at least a related, domain as the problem you’re trying to prove NP-
complete. For example, we showed that the vertex-cover problem—a
graph problem—was NP-complete by reducing from the clique prob-
lem—also a graph problem. From there, the NP-completeness family
tree showed that we reduced to the hamiltonian-cycle, hamiltonian-path,
traveling-salesman, and longest-acyclic-path problems, all of which are
on graphs.
Sometimes, however, it’s best to leap from one domain to another,
such as when we reduced from 3-CNF satisﬁability to the clique prob-
lem or to the subset-sum problem. 3-CNF satisﬁability often turns out
to be a good choice to reduce from when crossing domains.
Within graph problems, if you need to select a portion of the graph,
without regard to ordering, then the vertex-cover problem is often a
good place to start. If ordering matters, then consider starting from
the hamiltonian-cycle or hamiltonian-path problem.
Make big rewards and big penalties
When we transformed the input graph G to the hamiltonian-cycle prob-
lem to the weighted graph G0 as input to the traveling-salesman prob-
lem, we really wanted to encourage using edges present in G when
choosing edges for the traveling-salesman tour. We did so by giving
these edges a very low weight: 0. In other words, we gave a big reward
for using these edges.
Alternatively, we could have given the edges in G a ﬁnite weight and
given edges not in G inﬁnite weight, thereby exacting a hefty penalty
for using edges not in G. If we had taken this approach and given each
edge in G a weight of W , then we would have had to set the target
weight k of the entire traveling-salesman tour to nW .
Design widgets
I didn’t go into widget design, because widgets can get complicated.
Widgets can be useful for enforcing certain properties. The books cited

208
Chapter 10: Hard? Problems
in the “Further reading” section provide examples of how to construct
and use widgets in reductions.
Perspective
I’ve painted quite a gloomy picture here, haven’t I? Imagine a scenario
in which you try to come up with a polynomial-time algorithm to solve
a problem, and no matter how much you press, you just can’t close the
deal. After a while, you’d be thrilled just to ﬁnd an O.n5/-time algo-
rithm, even though you know that n5 grows awfully rapidly. Maybe this
problem is close to one that you know is easily solved in polynomial
time (such as 2-CNF satisﬁability vs. 3-CNF, or Euler tour vs. hamil-
tonian cycle), and you ﬁnd it incredibly frustrating that you can’t adapt
the polynomial-time algorithm for your problem. Eventually you sus-
pect that maybe—just maybe—you’ve been banging your head against
the wall to solve an NP-complete problem. And, lo and behold, you are
able to reduce a known NP-complete problem to your problem, and now
you know that it’s NP-hard.
Is that the end of the story? There’s no hope that you’ll be able to
solve the problem in any reasonable amount of time?
Not quite. When a problem is NP-complete, it means that some inputs
are troublesome, but not necessarily that all inputs are bad. For exam-
ple, ﬁnding a longest acyclic path in a directed graph is NP-complete,
but if you know that the graph is acyclic, then you can ﬁnd a longest
acyclic path in not just polynomial time, but in O.n C m/ time (where
the graph has n vertices and m edges). Recall that we did just that when
ﬁnding a critical path in a PERT chart in Chapter 5. As another example,
if you’re trying to solve the partition problem and the integers in the set
sum to an odd number, then you know that there’s no way to partition
the set so that both parts have equal sums.
The good news goes beyond such pathological special cases. From
here on, let’s focus on optimization problems whose decision variants
are NP-complete, such as the traveling-salesman problem. Some fast
methods give good, and often very good, results.
The technique of
branch and bound organizes a search for an optimal solution into a
tree-like structure, and it cuts off hunks of the tree, thereby eliminating
large portions of the search space, based on the simple idea that if it can
determine that all the solutions emanating from one node of the search
tree cannot be any better than the best solution found so far, then don’t

Chapter 10: Hard? Problems
209
bother checking solutions within the space represented by that node or
anything below it.
Another technique that often helps is neighborhood search, which
takes one solution and applies local operations to try to improve the
solution until no further improvement occurs. Consider the traveling-
salesman problem where all vertices are points in the plane and the
weight of each edge is the planar distance between the points. Even
with this restriction, the problem is NP-complete. In the 2-opt tech-
nique, whenever two edges cross, switch them, which results in a shorter
cycle:
Moreover, a host of approximation algorithms give results that are
guaranteed to be within a certain factor of the optimal value. For ex-
ample, if the input to the traveling-salesman problem obeys the triangle
inequality—for all vertices u, v, and x, the weight of edge .u; v/ is at
most the sum of the weights of edges .u; x/ and .x; v/—then there is a
simple approximation algorithm that always ﬁnds a traveling-salesman
tour whose total weight is at most twice that of the lowest, and this al-
gorithm runs in time linear in the size of the input. There is an even
better polynomial-time approximation algorithm for this situation, giv-
ing a tour whose total weight is at most 3=2 times the lowest.
Strangely enough, if two NP-complete problems are closely related,
the solution produced by a good approximation algorithm for one might
produce a poor solution for the other. That is, a solution that is nearly
optimal for one of the problems doesn’t necessarily map to a solution
that is anywhere nearly optimal for the other problem.
Nevertheless, in many real-world situations, a nearly optimal solu-
tion is good enough. Harking back to the discussion about the package-
delivery company with brown trucks, they are happy to ﬁnd nearly opti-
mal routes for their trucks, even if the routes are not necessarily the best
possible. Every dollar that they can save by planning efﬁcient routes
helps their bottom line.

210
Chapter 10: Hard? Problems
Undecidable problems
Then again, if you’re under the impression that NP-complete problems
are the hardest in the world of algorithms, you’re in for a little sur-
prise. Theoretical computer scientists have deﬁned a large hierarchy of
complexity classes, based on how much time and other resources are
necessary to solve a problem. Some problems take an amount of time
that is provably exponential in the input size.
And it gets even worse. For some problems, no algorithm is possible.
That is, there are problems for which it is provably impossible to create
an algorithm that always gives a correct answer. We call such problems
undecidable, and the best-known one is the halting problem, proven
undecidable by the mathematician Alan Turing in 1937. In the halting
problem, the input is a computer program A and the input x to A. The
goal is to determine whether program A, running on input x, ever halts.
That is, does A with input x run to completion?
Perhaps you’re thinking that you could write a program—let’s call
it program B—that reads in program A, reads in x, and simulates A
running with input x. That’s ﬁne if A on input x actually does run to
completion. What if it doesn’t? How would program B know when to
declare that A will never halt? Couldn’t B check for A getting into some
sort of inﬁnite loop? The answer is that although you could write B to
check for some cases in which A doesn’t halt, it is provably impossible
to write program B so that it always halts and tells you correctly whether
A on input x halts.
Because it’s not possible to write a program that determines whether
another program running on a particular input even halts, it’s also not
possible to write a program that determines whether another program
meets its speciﬁcation. How can one program tell whether another pro-
gram gives the right answer if it can’t even tell whether the program
halts? So much for perfect automated software testing!
Lest you think that the only undecidable problems have to do with
properties of computer programs, Post’s Correspondence Problem
(PCP) is about strings, such as we saw in Chapter 7. Suppose we have
at least two characters, and we have two lists of n strings, A and B,
over these characters. Let A consist of strings A1; A2; A3; : : : ; An and
B consist of strings B1; B2; B3; : : : ; Bn. The problem is to determine
whether there exists a sequence of indices i1; i2; i3; : : : ; im such that
Ai1Ai2Ai3    Aim (that is, the strings Ai1; Ai2; Ai3; : : : ; Aim concate-
nated together) gives the same string as Bi1Bi2Bi3    Bim. For example,

Chapter 10: Hard? Problems
211
suppose that the characters are e, h, m, n, o, r, and y, that n D 5, and
that
A1
D
ey ;
B1
D
ym ;
A2
D
er ;
B2
D
r ;
A3
D
mo ;
B3
D
oon ;
A4
D
on ;
B4
D
e ;
A5
D
h ;
B5
D
hon :
Then one solution is the index sequence h5; 4; 1; 3; 4; 2i, since
both A5A4A1A3A4A2 and B5B4B1B3B4B2 form honeymooner. Of
course, if there’s one solution, there are an inﬁnite number of solutions,
since you can just keep repeating the index sequence of a solution (giv-
ing honeymoonerhoneymooner, etc.). For PCP to be undecidable,
we have to allow the strings in A and B to be used more than once, since
otherwise you could just list all the possible combinations of strings.
Although Post’s Correspondence Problem might not seem particu-
larly interesting on its own, we can reduce it to other problems to show
that they, too, are undecidable. It’s the same basic idea as we used to
show that a problem is NP-hard: given an instance of PCP, transform it
into an instance of some other problem Q, such that the answer to the
instance of Q gives the answer to the instance of PCP. If we could de-
cide Q, then we could decide PCP; but since we know that we cannot
decide PCP, then Q must be undecidable.
Among the undecidable problems that we can reduce PCP to are sev-
eral having to do with context-free grammars (CFGs), which describe
the syntax of most programming languages. A CFG is a set of rules
for generating a formal language, which is a fancy way to say “a set
of strings.” By reducing from PCP, we can prove that it’s undecid-
able whether two CFGs generate the same formal language, whether
two CFGs generate any strings in common, or whether a given CFG is
ambiguous: are there two different ways to generate the same string
using the rules of the CFG?
Wrap-up
We’ve seen quite a range of algorithms in quite a variety of domains,
haven’t we? We’ve seen an algorithm that takes sublinear time—binary
search.
We’ve seen algorithms that take linear time—linear search,
counting sort, radix sort, topological sort, and ﬁnding shortest paths

212
Chapter 10: Hard? Problems
in a dag.
We’ve seen algorithms that take O.n lg n/ time—merge
sort and quicksort (average case).
We’ve seen algorithms that take
O.n2/ time—selection sort, insertion sort, and quicksort (worst case).
We’ve seen graph algorithms that take time described by some non-
linear combination of the number n of vertices and the number m of
edges—Dijkstra’s algorithm and the Bellman-Ford algorithm. We’ve
seen a graph algorithm that takes ‚.n3/ time—the Floyd-Warshall al-
gorithm. Now we’ve seen that for some problems, we have no idea
whether a polynomial-time algorithm is even possible. And we’ve even
seen that for some problems, no algorithm is possible, regardless of the
running time.
Even with this relatively brief introduction to the world of computer
algorithms,6 you can see that the area covers a lot of ground. And this
book covers only the tiniest sliver of the area. Moreover, I have re-
stricted our analyses to a particular computational model, in which only
one processor performs operations and the time to perform each oper-
ation is more or less the same, regardless of where in the computer’s
memory the data reside. Many alternative computational models have
been proposed over the years, such as models with multiple processors,
models in which the time to perform an operation depends on where
its data are located, models in which the data arrive in a nonrepeatable
stream, and models in which the computer is a quantum device.
And so you can see that this ﬁeld of computer algorithms has plenty
of unanswered questions, as well as questions yet to be asked. Take an
algorithms course—you can even take one online—and help us out!
Further reading
The book on NP-completeness is by Garey and Johnson [GJ79]. If
you’re interested in delving into this topic, read it. CLRS [CLRS09]
has a chapter on NP-completeness, which goes into more technical de-
tail than I’ve gone into here, and it also has a chapter on approximation
algorithms. For more on computability and complexity, and a very nice,
short, understandable proof that the halting problem is undecidable, I
recommend the book by Sipser [Sip06].
6Compare the size of this book with CLRS, which weighs in at 1292 pages in its third
edition.

Bibliography
[AHU74]
Alfred V. Aho, John E. Hopcroft, and Jeffrey D. Ullman. The Design
and Analysis of Computer Algorithms. Addison-Wesley, 1974.
[AMOT90]
Ravindra K. Ahuja, Kurt Mehlhorn, James B. Orlin, and Robert E. Tar-
jan. Faster algorithms for the shortest path problem. Journal of the
ACM, 37(2):213–223, 1990.
[CLR90]
Thomas H. Cormen, Charles E. Leiserson, and Ronald L. Rivest. In-
troduction to Algorithms. The MIT Press, ﬁrst edition, 1990.
[CLRS09]
Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clif-
ford Stein. Introduction to Algorithms. The MIT Press, third edition,
2009.
[DH76]
Whitﬁeld Difﬁe and Martin E. Hellman. New directions in cryptog-
raphy. IEEE Transactions on Information Theory, IT-22(6):644–654,
1976.
[FIP11]
Annex C: Approved random number generators for FIPS PUB 140-2,
Security requirements for cryptographic modules. http://csrc.nist.gov/
publications/ﬁps/ﬁps140-2/ﬁps1402annexc.pdf, July 2011. Draft.
[GJ79]
Michael R. Garey and David S. Johnson. Computers and Intractability:
A Guide to the Theory of NP-Completeness. W. H. Freeman, 1979.
[Gri81]
David Gries. The Science of Programming. Springer, 1981.
[KL08]
Jonathan Katz and Yehuda Lindell. Introduction to Modern Cryptog-
raphy. Chapman & Hall/CRC, 2008.
[Knu97]
Donald E. Knuth. The Art of Computer Programming, Volume 1: Fun-
damental Algorithms. Addison-Wesley, third edition, 1997.
[Knu98a]
Donald E. Knuth.
The Art of Computer Programming, Volume 2:
Seminumeral Algorithms. Addison-Wesley, third edition, 1998.
[Knu98b]
Donald E. Knuth. The Art of Computer Programming, Volume 3: Sort-
ing and Searching. Addison-Wesley, second edition, 1998.
[Knu11]
Donald E. Knuth. The Art of Computer Programming, Volume 4A:
Combinatorial Algorithms, Part I. Addison-Wesley, 2011.
[Mac12]
John MacCormick. Nine Algorithms That Changed the Future: The
Ingenious Ideas That Drive Today’s Computers. Princeton University
Press, 2012.
[Mit96]
John C. Mitchell. Foundations for Programming Languages. The MIT
Press, 1996.

214
Bibliography
[MvOV96]
Alfred Menezes, Paul van Oorschot, and Scott Vanstone. Handbook of
Applied Cryptography. CRC Press, 1996.
[RSA78]
Ronald L. Rivest, Adi Shamir, and Leonard M. Adleman. A method
for obtaining digital signatures and public-key cryptosystems. Com-
munications of the ACM, 21(2):120–126, 1978. See also U.S. Patent
4,405,829.
[Sal08]
David Salomon.
A Concise Introduction to Data Compression.
Springer, 2008.
[Sip06]
Michael Sipser. Introduction to the Theory of Computation. Course
Technology, second edition, 2006.
[SM08]
Sean Smith and John Marchesini.
The Craft of System Security.
Addison-Wesley, 2008.
[Sto88]
James A. Storer. Data Compression: Methods and Theory. Computer
Science Press, 1988.
[TC11]
Greg Taylor and George Cox. Digital randomness. IEEE Spectrum,
48(9):32–58, 2011.

Index
O-notation, 19–20
-notation, 20
‚-notation, 18–19
Š (factorial), 22, 140, 180
b c (ﬂoor), 29
abstract data type, 97
abstraction, 97
adaptive Huffman code, 166–167
adjacency list, 79
adjacency matrix, 78
adjacent vertex, 75
ADT, 97
Advanced Encryption Standard (AES),
143, 155
AKS primality test, 148
algorithm
approximation, 3–4, 209
for a computer, 1
correctness of, 2–4
deﬁnition, 1–2
greedy, 165
origin of word, 9
polynomial-time, 181
polynomial-time reduction, 186
resource usage of, 4–6
aligning DNA sequences, 122–123
all-pairs shortest paths
Floyd-Warshall algorithm for,
106–114
Johnson’s algorithm for, 114
by matrix multiplication, 114
almost optimal solution, 3
ambiguous grammar, 211
AND, 189
approximation algorithm, 3–4, 209
arbitrage opportunity, 104–106
arithmetic, modular, 146
arithmetic series, 35
arithmetic with large numbers, 150
array, 11
priority queue implemented by, 97–98
searching in, 12–22, 24, 28–32
sorting of, 32–59, 62–70
ASCII, 136, 141, 159
ASSEMBLE-LCS, 120
ASSEMBLE-TRANSFORMATION, 129
assigning a value to a variable, 13
asymptotic notation, 20
BAD-FACTORIAL, 24
base-2 logarithm, 7
baseball, 146
base case, 23
BELLMAN-FORD, 102
Bellman-Ford algorithm, 101–106
for ﬁnding an arbitrage opportunity,
104–106
for ﬁnding a negative-weight cycle,
103–104
running time of, 103–104
best case, 19
BETTER-LINEAR-SEARCH, 14
big-oh notation, 19–20
big-omega notation, 20
binary heap, 98–101
binary search, 28–32
loop invariant for, 30
recursive version, 31
running time of, 31–32
BINARY-SEARCH, 30
binary tree, 98, 161
binning, 28
bit, 141
block cipher, 142–144
chaining, 143–144
body of a loop, 14, 16
boolean formula, 189

216
Index
satisﬁability problem for, 189
bound, 18–20
Boyer-Moore string-matching
algorithm, 137
branch and bound, 208
bucketing (bucketizing), 28
BUILD-HUFFMAN-TREE, 164
cache, 17
call of a procedure, 11
certiﬁcate, 184
CFG, 211
child, 98
cipher
shift cipher, 139
simple substitution, 139–140
cipher block chaining, 143–144
ciphertext, 139
clause, 190
clique, 191
clique problem, 191–194
CLRS, 8–9, 24, 59, 70, 89, 114,
136–137, 157, 178, 212
code
escape, 166
Huffman, 160–167, 177
preﬁx-free, 161
coefﬁcient, 5–6, 18
combine step, 40
in merge sort, 41
in quicksort, 50
common subsequence, 116
longest, 115–121
communication, 4
comparison sorting, 61–62
complete graph, 198
composite number, 3, 148
compression, 158–178
by adaptive Huffman code, 166–167
by fax machines, 159, 167–168
by Huffman code, 160–167, 177
lossless, 158
lossy, 158
by LZ78, 169
by LZW, 168–178
by run-length encoding, 167
COMPUTE-LCS-TABLE, 119
computer algorithm, 1
COMPUTE-TRANSFORM-TABLES, 127
concatenation, 134
connected graph, 182
conquer step, 40
in merge sort, 41
in quicksort, 50
context-free grammar, 211
contrapositive, 22
copy operation on a character, 121
correctness of an algorithm, 2–4
counting sort, 62–68
running time of, 67–68
COUNTING-SORT, 67
COUNT-KEYS-EQUAL, 63
COUNT-KEYS-LESS, 64
critical path, 80–85
running time for ﬁnding, 88
cryptography, 138–157
block cipher, 142–144
cipher block chaining, 143–144
hybrid cryptosystem, 155–156
by one-time pad, 140–142
public-key, 144–155
by RSA, 146–155
shift cipher, 139
simple substitution cipher, 139–140
symmetric-key, 140–144
cycle, 82
hamiltonian, 182, 196–198
dag, see directed acyclic graph
DAG-SHORTEST-PATHS, 87
data compression, see compression
data structure, 97
decision problem, 185
DECREASE-KEY, 97, 99, 101
decrement, 37
decryption, 138
degree of a vertex, 182
delete operation on a character, 121
dense graph, 100
depth of a leaf, 162
deterministic quicksort, 58
diameter of a network, 106
DIJKSTRA, 94, 98
Dijkstra’s algorithm, 91–101, 165

Index
217
loop invariant for, 96
running time of, 96–101
directed acyclic graph, 74–80
shortest path in, 85–88
topological sorting of, 75–80
directed edge, 74
relaxation of, 86
directed graph, 74
acyclic, 74–80
representation of, 78–80
shortest path in, 85–88
topological sorting of, 75–80
weighted, 83
disk operations, 4
divide-and-conquer, 40–41
divide step, 40
in merge sort, 41
in quicksort, 49–50
DNA, 115, 160
aligning sequences of, 122–123
doubly linked list, 80
dynamic programming, 112–114
in the Floyd-Warshall algorithm,
107–109, 113
for longest common subsequence,
116–120
for transforming strings, 123–126
edge
directed, 74
entering, 75
incident, 182
leaving, 75
relaxation of, 86
undirected, 182
edge list, 78
edge weight, 83
element of an array, 11
encryption, 1, 3, 138
entering edge, 75
entry of an array, 11
Erd˝os-Bacon number, 91
Erd˝os number, 91
escape code, 166
EUCLID, 151–152
Euler tour, 182
exclusive-or, 141
existential lower bound, 62
exponential function, 7
exponentiation, modular, 153–154
EXTRACT-MIN, 97, 100–101
FA, see ﬁnite automaton
FACTORIAL, 23
factorial function (Š), 22, 140, 180
FA-STRING-MATCHER, 133
fax machines, 159, 167–168
Fermat’s Little Theorem, 151
F-heap, 101
Fibonacci heap implementation of a
priority queue, 101
ﬁnding large prime numbers, 150–151
FIND-NEGATIVE-WEIGHT-CYCLE,
104
ﬁnite automaton, 131–136
running time of, 135–136
ﬂoor function (b c), 29
ﬂow of control, 10
FLOYD-WARSHALL, 110
Floyd-Warshall algorithm, 106–114
and dynamic programming, 107–109,
113
running time of, 112
footprint, 4
formal language, 211
function, 11
linear, 18
goalie equipment, 71–74
googol, 183
grammar, 211
graph
complete, 198
connected, 182
directed, 74
directed acyclic, 74–80
representation of, 78–80
shortest path in, 85–88
topological sorting of, 75–80
undirected, 182
weighted, 83
greedy algorithm, 165
halting problem, 210

218
Index
hamiltonian cycle, 182, 196–198
hamiltonian path, 196–198
hash table, 177
heap, 98–101
redistributive, 114
heap property, 99
heapsort, 100–101
HEAPSORT, 100
height of a node, 99
Huffman code, 160–167, 177
adaptive, 166–167
running time of, 164–165
hybrid cryptosystem, 155–156
hybrid sorting algorithm, 59
IFF, 189
IMPLIES, 189
incident edge, 182
increment, 14
in-degree, 76
index into an array, 11
inequality, triangle, 209
initialization in a loop invariant, 21
initialization vector, 144
in-place sorting, 40
input
to a procedure, 11
size of, 5
INSERT, 96–97, 99, 101
insertion sort, 35–40
loop invariant for, 37
running time of, 38–39
INSERTION-SORT, 37
insert operation on a character, 121
internal node, 162
Introduction to Algorithms, see CLRS
inverse, multiplicative, 149, 152–153
iteration of a loop, 13
Jabberwocky, 169
Johnson’s algorithm, 114
JPEG, 158
Kevin Bacon number, 90–91
key
in cryptography, 139
public, 144
in searching, 26
secret, 144
in sorting, 26
KMP string-matching algorithm, 136
knapsack problem, 205
Knuth-Morris-Pratt string-matching
algorithm, 136
last in, ﬁrst out, 77
LCS, see longest common subsequence
leaf, 98
leaving edge, 75
lexicographic ordering, 25
lg, 7
LIFO, 77
linear function, 18
linear search, 13–22, 24
loop invariant for, 21
lower bound for, 20
recursive version, 24
running time of, 17–21
LINEAR-SEARCH, 13
linear-time merging, 42–48
linked list, 79
list
adjacency, 79
edge, 78
linked, 79
literal, 191
Llanfairpwllgwyngyllgogerych-
wyrndrobwllllantysiliogogogoch,
169
logarithm, 7
longest-acyclic-path problem, 199
longest common subsequence, 115–121
by dynamic programming, 116–120
running time of, 119, 121
loop, 13, 16
nested, 34
loop invariant, 21–22
for binary search, 30
for COUNT-KEYS-LESS, 64
for Dijkstra’s algorithm, 96
for insertion sort, 37
for linear search, 21
for partitioning, 53
for selection sort, 34

Index
219
loop variable, 14
lossless compression, 158
lossy compression, 158
lower bound, 18, 20
for comparison sorting, 61–62
existential, 62
for linear search, 20
for selection sort, 35
universal, 62
low-order term, 5, 18
LZ78, 169
LZW compression, 168–178
LZW-COMPRESSOR, 172
LZW-DECOMPRESSOR, 176
main memory, 17
maintenance of a loop invariant, 21
master method, 49
matrix, adjacency, 78
matrix multiplication, 114
median-of-three quicksort, 56
memory, 4
MERGE, 47
merge sort, 40–49
running time of, 48–49
MERGE-SORT, 41
merging, 42–48
method, 11
Miller-Rabin primality test, 148, 157
Moby Dick, 165, 170, 173–174, 177
modular arithmetic, 146
computing multiplicative inverses in,
152–153
exponentiation, 153–154
MODULAR-EXPONENTIATION, 154
Mother Problem, 188–190
MP3, 158
multiplicative inverse, 149, 152–153
na¨ıve method for string matching,
130–131
running time of, 131
negative-weight cycle
and arbitrage opportunities, 104–106
found by Bellman-Ford algorithm,
103–104
neighborhood search, 209
nested loops, 34
network communication, 4
node, 98
internal, 162
NOR, 189
NP, 184
NP-complete, 181, 184
NP-completeness
of clique, 191–194
general strategies for proving,
205–208
of hamiltonian cycle, 196–198
of hamiltonian path, 196–198
of knapsack, 205
of longest acyclic path, 199
of partition, 203–205
perspective on, 208–211
of subset sum, 199–203
of 3-CNF satisﬁability, 190–191
of traveling salesman, 198–199
of vertex cover, 194–196
NP-hard, 184
number
composite, 148
Erd˝os, 91
Erd˝os-Bacon, 91
Kevin Bacon, 90–91
prime, 147
random, 156
O-notation, 19–20
occurrence of a pattern string with a
shift, 130
Omega-notation, 20
one-time pad, 140–142
operation, 17
optimal solution, 3
optimal substructure, 113
OR, 189
order of growth of running time, 5
out-degree, 76
output from a procedure, 11
P, 183
pad, 142
parameter, 11
parent, 99

220
Index
PARTITION, 54
partitioning, 50, 52–55
running time of, 55
partition problem, 203–205
path, 81
hamiltonian, 196–198
longest acyclic, 199
shortest, 84
weight of, 83
pattern string, 129
PCP, 210
pel, 159
permuting, 32
PERT chart, 80–85, 88
pivot, 50
pixel, 159
plaintext, 139
polynomial-time algorithm, 181
reduction, 186
polynomial-time veriﬁcation, 183
Post’s Correspondence Problem, 210
predecessor, 85
preﬁx, 116
preﬁx-free code, 161
primality test
AKS, 148
Miller-Rabin, 148, 157
prime number, 3, 147
how to ﬁnd, 150–151
Prime Number Theorem, 150
prime, relatively, 148, 151–152
priority queue, 97
binary heap implementation of,
98–100
Fibonacci heap implementation of,
101
simple array implementation of,
97–98
PRNG, 156–157
procedure, 11
call of, 11
pseudocode, 10
pseudorandom number generator,
156–157
public key, 144, 149
public-key cryptography, 144–155
by RSA, 146–155, 157
public-key cryptosystem, 146
quicksort, 49–57
deterministic, 58
median-of-three, 56
randomized, 56
running time of, 55–57
QUICKSORT, 51
radix sort, 68–70
running time of, 69–70
random bits, 4
randomized quicksort, 56
random number, 156
REALLY-SIMPLE-SORT, 61
REARRANGE, 65
recurrence equation, 49
recursion, 22–24
RECURSIVE-BINARY-SEARCH, 31
RECURSIVE-LINEAR-SEARCH, 24
redistributive heap, 114
reduction, 185–186
relatively prime, 148, 151–152
RELAX, 86
relaxation step, 86
repeated squaring, 153
replace operation on a character, 121
representation of a directed graph,
78–80
resource usage, 4–6
return value from a procedure, 11
RSA, 3, 146–155, 157
run-length encoding, 167
running time
of the Bellman-Ford algorithm,
103–104
best case, 19
of binary search, 31–32
of counting sort, 67–68
of Dijkstra’s algorithm, 96–101
of the Floyd-Warshall algorithm, 112
how to characterize, 16–21
of Huffman code, 164–165
of insertion sort, 38–39
of linear search, 17–21
of longest common subsequence, 119,
121

Index
221
of merge sort, 48–49
of merging, 48
of na¨ıve method for string matching,
131
order of growth of, 5
of partitioning, 55
of quicksort, 55–57
of radix sort, 69–70
of selection sort, 34–35
of single-source shortest paths in a
directed acyclic graph, 88
of string matching by ﬁnite
automaton, 135–136
of topological sorting, 80
of transforming strings, 126
worst case, 19
satellite data, 26–27
satisﬁable formula, 189
searching, 12–22, 24
binary search, 28–32
comparison of algorithms, 57
linear search, 13–22, 24
search key, 26
search, neighborhood, 209
secret key, 144, 149
seed, 156
selection sort, 32–35
loop invariant for, 34
running time of, 34–35
SELECTION-SORT, 33
sentinel, 15
in merging, 46–47
SENTINEL-LINEAR-SEARCH, 16
sequence, 115
shift cipher, 139
shift of a string, 130
short circuiting, 37
shortest path, 84
Bellman-Ford algorithm for, 101–106
Dijkstra’s algorithm for, 91–101
in a directed acyclic graph, 85–88
Floyd-Warshall algorithm for,
106–114
Johnson’s algorithm for, 114
by matrix multiplication, 114
single-pair, 90
single-source, 85
signs in baseball, 146
simple array implementation of a
priority queue, 97–98
simple substitution cipher, 139–140
shift cipher, 139
single-pair shortest path, 90
single-source shortest path, 85
Bellman-Ford algorithm for, 101–106
Dijkstra’s algorithm for, 91–101
in a directed acyclic graph, 85–88
singly linked list, 80
six degrees of Kevin Bacon game, 90–91
size
of a clique, 191
of input, 5
of a vertex cover, 194
slot, 27
solution, 2–3
sorting, 32–70
applications of, 26
comparison of algorithms, 57–59
counting sort, 62–68
heapsort, 100–101
hybrid algorithm, 59
insertion sort, 35–40
lower bound for, 61–62
merge sort, 40–49
in place, 40
quicksort, 49–57
radix sort, 68–70
selection sort, 32–35
stable, 68
topological, 75–80
sort key, 26
source vertex, 85
sparse graph, 100
SQUARE-ROOT, 11
stable sort, 68
stack, 77
stack overﬂow error, 24
state, 131
string, 115
longest common subsequence,
115–121
occurrence of, with a shift, 130
pattern, 129

222
Index
text, 129
transformation of, 121–126
string matching, 115, 129–136
Boyer-Moore algorithm for, 137
by ﬁnite automaton, 131–136
KMP algorithm for, 136
by na¨ıve method, 130–131
subarray, 21
subsequence, 116
subset-sum problem, 199–203
substitution cipher
shift cipher, 139
simple, 139–140
substring, 116
sufﬁx, 134
symmetric-key cryptography, 140–144
block cipher, 142–144
cipher block chaining, 143–144
by one-time pad, 140–142
target vertex, 85
term, 5
termination in a loop invariant, 21
text string, 129
Theta-notation, 18–19
3-CNF, 191
3-CNF satisﬁability problem, 190–191
3-conjunctive normal form, 191
time, 4
TOPOLOGICAL-SORT, 77
topological sorting, 75–80
running time of, 80
transforming strings, 121–126
by dynamic programming, 123–126
running time of, 126
transitive, 71
traveling-salesman problem, 181,
198–199
tree
binary, 98, 161
trie, 177
triangle inequality, 209
trie, 177
2-opt, 209
undecidable problem, 210
undirected edge, 182
undirected graph, 182
Unicode, 141
universal lower bound, 62
upper bound, 18–19
variable
loop, 14
in a procedure, 13
veriﬁcation in polynomial time, 183
vertex, 74
in-degree of, 76
out-degree of, 76
predecessor, 85
source, 85
target, 85
vertex-cover problem, 194–196
virtual memory, 17
weight
of an edge, 83
of a path, 83
weighted directed graph, 83
wetware, 10
widget, 197
worst case, 19
XOR, 141

