ELECTRONICS ENGINEERING SERIES
Digital Electronics 1
Combinational Logic Circuits
Tertulien Ndjountche 

 
 
 

The omnipresence of electronic devices in our everyday
lives has been accompanied by the downscaling of chip
feature sizes and the ever increasing complexity of digital
circuits.
This book is devoted to the analysis and design of digital
circuits, where the signal can assume only two possible
logic levels. It deals with the basic principles and concepts
of digital electronics. It addresses all aspects of
combinational logic and provides a detailed understanding
of logic gates that are the basic components in the
implementation of circuits used to perform functions and
operations of Boolean algebra. Combinational logic circuits
are characterized by outputs that depend only on the actual
input values.
Efficient techniques to derive logic equations are proposed
together with methods of analysis and synthesis of
combinational logic circuits. Each chapter is well structured
and is supplemented by a selection of solved exercises
covering logic design practices.
Tertulien Ndjountche received a PhD degree in electrical
engineering from Erlangen-Nuremberg University in
Germany.  He has worked as a professor and researcher at
universities in Germany and Canada. He has published
numerous technical papers and books in his fields of
interest. 
Z(7ib8e8-CBJIEH(
www.iste.co.uk

Digital Electronics 1 
 
 

 
 
 

 
Series Editor 
Robert Baptist 
Digital Electronics 1 
 
 
Combinational Logic Circuits 
 
 
 
 
 
  
 
Tertulien Ndjountche 
  
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
 
 
 
First published 2016 in Great Britain and the United States by ISTE Ltd and John Wiley & Sons, Inc. 
Apart from any fair dealing for the purposes of research or private study, or criticism or review, as 
permitted under the Copyright, Designs and Patents Act 1988, this publication may only be reproduced, 
stored or transmitted, in any form or by any means, with the prior permission in writing of the publishers, 
or in the case of reprographic reproduction in accordance with the terms and licenses issued by the  
CLA. Enquiries concerning reproduction outside these terms should be sent to the publishers at the 
undermentioned address: 
ISTE Ltd  
John Wiley & Sons, Inc.  
27-37 St George’s Road  
111 River Street 
London SW19 4EU 
Hoboken, NJ 07030 
UK  
USA  
www.iste.co.uk  
www.wiley.com 
 
© ISTE Ltd 2016 
The rights of Tertulien Ndjountche to be identified as the author of this work have been asserted by him 
in accordance with the Copyright, Designs and Patents Act 1988. 
Library of Congress Control Number: 2016939642 
 
British Library Cataloguing-in-Publication Data 
A CIP record for this book is available from the British Library  
ISBN 978-1-84821-984-7 

Contents
Preface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
ix
Chapter 1. Number Systems . . . . . . . . . . . . . . . . . . . . . . . . . .
1
1.1. Introduction
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
1.2. Decimal numbers
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
1.3. Binary numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2
1.4. Octal numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4
1.5. Hexadecimal numeration . . . . . . . . . . . . . . . . . . . . . . . . . .
5
1.6. Representation in a radix B . . . . . . . . . . . . . . . . . . . . . . . . .
6
1.7. Binary-coded decimal numbers
. . . . . . . . . . . . . . . . . . . . . .
7
1.8. Representations of signed integers . . . . . . . . . . . . . . . . . . . . .
8
1.8.1. Sign-magnitude representation . . . . . . . . . . . . . . . . . . . . .
9
1.8.2. Two’s complement representation . . . . . . . . . . . . . . . . . . .
10
1.8.3. Excess-E representation . . . . . . . . . . . . . . . . . . . . . . . . .
12
1.9. Representation of the fractional part of a number
. . . . . . . . . . . .
13
1.10. Arithmetic operations on binary numbers . . . . . . . . . . . . . . . .
16
1.10.1. Addition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
16
1.10.2. Subtraction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17
1.10.3. Multiplication
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18
1.10.4. Division . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19
1.11. Representation of real numbers . . . . . . . . . . . . . . . . . . . . . .
20
1.11.1. Fixed-point representation . . . . . . . . . . . . . . . . . . . . . . .
20
1.11.2. Floating-point representation . . . . . . . . . . . . . . . . . . . . .
22
1.12. Data representation . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
28
1.12.1. Gray code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
28
1.12.2. p-out-of-n code . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
29
1.12.3. ASCII code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
31
1.12.4. Other codes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
31
1.13. Codes to protect against errors . . . . . . . . . . . . . . . . . . . . . .
31

vi
Digital Electronics 1
1.13.1. Parity bit
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
31
1.13.2. Error correcting codes . . . . . . . . . . . . . . . . . . . . . . . . .
33
1.14. Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
36
1.15. Solutions
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
38
Chapter 2. Logic Gates
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
49
2.1. Introduction
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
49
2.2. Logic gates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
50
2.2.1. NOT gate . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
51
2.2.2. AND gate . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
51
2.2.3. OR gate . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
52
2.2.4. XOR gate . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
52
2.2.5. Complementary logic gates . . . . . . . . . . . . . . . . . . . . . . .
53
2.3. Three-state buffer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
54
2.4. Logic function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
54
2.5. The correspondence between a truth table and a logic function . . . . .
55
2.6. Boolean algebra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
57
2.6.1. Boolean algebra theorems
. . . . . . . . . . . . . . . . . . . . . . .
59
2.6.2. Karnaugh maps
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
65
2.6.3. Simpliﬁcation of logic functions with multiple outputs . . . . . . .
73
2.6.4. Factorization of logic functions
. . . . . . . . . . . . . . . . . . . .
74
2.7. Multi-level logic circuit implementation
. . . . . . . . . . . . . . . . .
76
2.7.1. Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
77
2.7.2. NAND gate logic circuit . . . . . . . . . . . . . . . . . . . . . . . .
78
2.7.3. NOR gate based logic circuit . . . . . . . . . . . . . . . . . . . . . .
80
2.7.4. Representation based on XOR and AND operators . . . . . . . . .
82
2.8. Practical considerations . . . . . . . . . . . . . . . . . . . . . . . . . . .
89
2.8.1. Timing diagram for a logic circuit . . . . . . . . . . . . . . . . . . .
90
2.8.2. Static hazard . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
90
2.8.3. Dynamic hazard . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
92
2.9. Demonstration of some Boolean algebra identities . . . . . . . . . . . .
93
2.10. Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
97
2.11. Solutions
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
101
Chapter 3. Function Blocks of Combinational Logic
. . . . . . . . . .
115
3.1. Introduction
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
115
3.2. Multiplexer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
115
3.3. Demultiplexer and decoder . . . . . . . . . . . . . . . . . . . . . . . . .
121
3.4. Implementation of logic functions using multiplexers or decoders . . .
127
3.4.1. Multiplexer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
127
3.4.2. Decoder . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
129
3.5. Encoders . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
130
3.5.1. 4:2 encoder . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
131

Contents
vii
3.5.2. 8:3 encoder . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
134
3.5.3. Priority encoder . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
136
3.6. Transcoders . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
143
3.6.1. Binary code and Gray code . . . . . . . . . . . . . . . . . . . . . . .
143
3.6.2. BCD and excess-3 code . . . . . . . . . . . . . . . . . . . . . . . . .
149
3.7. Parity check generator . . . . . . . . . . . . . . . . . . . . . . . . . . . .
155
3.8. Barrel shifter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
160
3.9. Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
165
3.10. Solutions
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
173
Chapter 4. Systematic Methods for the Simpliﬁcation of
Logic Functions
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
203
4.1. Introduction
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
203
4.2. Deﬁnitions and reminders . . . . . . . . . . . . . . . . . . . . . . . . . .
203
4.2.1. Deﬁnitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
204
4.2.2. Minimization principle of a logic function . . . . . . . . . . . . . .
204
4.3. Karnaugh maps
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
205
4.3.1. Function of ﬁve variables . . . . . . . . . . . . . . . . . . . . . . . .
205
4.3.2. Function of six variables . . . . . . . . . . . . . . . . . . . . . . . .
207
4.3.3. Karnaugh map with entered variable
. . . . . . . . . . . . . . . . .
208
4.3.4. Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
215
4.3.5. Representation based on the XOR and AND operators . . . . . . .
220
4.4. Systematic methods for simpliﬁcation . . . . . . . . . . . . . . . . . . .
220
4.4.1. Determination of prime implicants
. . . . . . . . . . . . . . . . . .
221
4.4.2. Finding the constitutive terms of a minimal expression . . . . . . .
224
4.4.3. Quine–McCluskey technique: simpliﬁcation of incompletely
deﬁned functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
235
4.4.4. Simpliﬁcation of functions with multiple outputs . . . . . . . . . .
235
4.5. Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
241
4.6. Solutions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
243
Bibliography
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
257
Index
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
259


Preface
The omnipresence of electronic devices in everyday life is accompanied by the
decreasing size and the ever-increasing complexity of digital circuits. This
comprehensive and easy-to-understand work deals with the basic principles of digital
electronics and allows the reader to grasp the subtleties of digital circuits, from logic
gates to ﬁnite-state machines. It presents all the aspects related to combinational
logic and sequential logic. It introduces techniques for simply and concisely
establishing logic equations as well as methods for the analysis and design of digital
circuits. Emphasis has been especially laid on design approaches that can be used to
ensure a reliable operation of ﬁnite-state machines. Various programmable logic
circuit structures and their applications have also been presented. Each chapter is
completed by practical examples and well-designed exercises that are accompanied
by worked solutions.
This book discusses all the different aspects of digital electronics, using
a descriptive approach combined with a gradual, detailed and comprehensive
presentation of basic concepts. The principles of combinational and sequential logic
are presented, as well as the underlying techniques to the analysis and design of
digital circuits. The analysis and design of digital circuits with increasing complexity
is facilitated by the use of abstractions at the circuit and architecture levels. There are
three volumes in this series devoted to the following subjects:
1) combinational logic circuits;
2) sequential and arithmetic logic circuits;
3) ﬁnite-state machines.
A progressive approach has been chosen and the chapters are relatively
independent of each other. To help master the subject matter and put into practice the
different concepts and techniques, the books are complemented by a selection of
exercises and solutions.

x
Digital Electronics 1
1. Summary
Volume 1 deals with combinational logic circuits. Logic gates are basic
components in digital circuits. They implement Boolean logic functions and
operations that are applied to binary-coded data. Combinational logic is used only
for logic functions and operations whose outputs depend solely on the inputs. This
ﬁrst volume contains the following four chapters:
1) Number Systems;
2) Logic Gates;
3) Function Blocks of Combinational Logic;
4) Systematic Methods for the Simpliﬁcation of Logic Functions.
2. The reader
This book is an indispensable tool for all engineering students in bachelors or
masters course who wish to acquire detailed and practical knowledge of digital
electronics. It is detailed enough to serve as a reference for electronic, automation
and computer engineers.
Tertulien NDJOUNTCHE
April 2016

1
Number Systems
1.1. Introduction
Digital systems are used to process data and to perform calculations in most
instrumentation, monitoring and communication devices. As physical quantities and
signals can only take discrete values in a digital system, the interpretation of
real-world information requires the use of interface circuits such as data converters.
In general, numbers may be represented in different numeration systems. The
decimal system is commonly used in routine transactions while the binary system is
the basis for digital electronics. Every number (or numeration) system is deﬁned by a
base (or radix), which is a collection of distinct symbols. The representation of a
number in a numeration system may be considered as a change in base. In a
positional number system, a value of a number depends on the place occupied by
each of its digits in the representation.
1.2. Decimal numbers
The decimal number system uses the following 10 numbers or symbols: 0, 1, 2, 3,
4, 5, 6, 7, 8, 9. The radix is thus 10.
EXAMPLE 1.1.– Decompose the numbers 734 and 12345 into powers of 10.
The decomposition of the number 734 takes the form:
734 = (7 × 102) + (3 × 101) + (4 × 100)
= 73410
Digital Electronics 1: Combinational Logic Circuits, First Edition. Tertulien Ndjountche.
© ISTE Ltd 2016. Published by ISTE Ltd and John Wiley & Sons, Inc.

2
Digital Electronics 1
For the number 12345, we have:
12 345 = (1 × 104) + (2 × 103) + (3 × 102) + (4 × 101) + (5 × 100)
= 12 34510
Depending on its position, each number is multiplied by the appropriate power of
10. The right-most digit represents the unit digit.
1.3. Binary numbers
Binary number system is based on two-level logic, conventionally noted as 0 (low
level) and 1 (high level). It is a system with a radix of two.
EXAMPLE 1.2.– Convert the decimal numbers 13 and 125 into binary numbers.
The decomposition of the number 13 in powers of 2 is written as:
1310 = (1 × 23) + (1 × 22) + (0 × 21) + (1 × 20)
= 11012
For the number 125, we have:
12510 = (1 × 26) + (1 × 25) + (1 × 24) + (1 × 23) + (1 × 22) + (0 × 21)
+(1 × 20) = 11111012
The binary code that is then obtained for a positive number is called a natural
binary code.
The coefﬁcients or numbers (0 or 1) used in the binary representation of a number
are called bits.
The right-most bit is called the least signiﬁcant bit (LSB), while the left-most bit
is called the most signiﬁcant bit (MSB).
In practice, the conversion of a decimal number to a binary number can be carried
out by reading, from last to ﬁrst, the remainders of a series of integer divisions as
illustrated by Figure 1.1.
The arithmetic and logic unit of a microprocessor manipulates binary numbers or
words with a ﬁxed number of bits.

Number Systems
3
125 ÷ 2 = 62 Remainder 1 (LSB)
62 ÷ 2 = 31 Remainder 0
31 ÷ 2 = 15 Remainder 1
13 ÷ 2 = 6 Remainder 1 (LSB)
15 ÷ 2 = 7 Remainder 1
6 ÷ 2 = 3 Remainder 0
7 ÷ 2 = 3 Remainder 1
3 ÷ 2 = 1 Remainder 1
3 ÷ 2 = 1 Remainder 1
1 ÷ 2 = 0 Remainder 1 (MSB)
1 ÷ 2 = 0 Remainder 1 (MSB)
1310 = 11012
12510 = 11111012
MSB
2
2
2
2
2
2
13
0
1
1
1
1
LSB
3
2
2
2
0
2
6
MSB
2
0
1
7
1
LSB
31
1
3
1
1
62
125
1
15
0
1
Figure 1.1. Decimal-binary conversion using
successive division methods
Region
H
VL
VLmin
VLmax
VHmax
VHmin
Voltage
Region
Forbidden region
V
Figure 1.2. Representation of logic voltage levels
A byte is an 8-bit word.
In practice, the bits 0 and 1 are represented by voltage or current levels.
Figure 1.2 shows the representation of logic voltage levels. The two regions VH and
VB are separated by a forbidden region where the logical level is undeﬁned.
Logical states may be assigned to regions based on positive logic or negative logic.
In the case of positive logic, the region VH corresponds to 1 (or the high level), and

4
Digital Electronics 1
the region VB corresponds to 0 (or the low level); and in the case of negative logic,
the region VH corresponds to 0 (or low level), and the region VB corresponds to 1 (or
high level).
1.4. Octal numbers
The octal number system or a representation with radix eight consists of the
following symbols: 0, 1, 2, 3, 4, 5, 6, 7.
EXAMPLE 1.3.– Convert the decimal numbers 250 and 777 to octal numbers.
In radix 8 representation, the number 250 takes the form:
25010 = (3 × 82) + (7 × 81) + (2 × 80)
= 3728
In the case of the number 777, we have:
77710 = (1 × 83) + (4 × 82) + (1 × 81) + (1 × 80)
= 1 4118
The right-most digit is called the least signiﬁcant digit (LSD), while the left-most
digit is called the most signiﬁcant digit (MSD).
A practical approach to converting a decimal number to an octal number consists
of carrying out a series of integer divisions as illustrated in Figure 1.3.
777 ÷ 8 = 97 Remainder 1 (LSD)
250 ÷ 8 = 31 Remainder 2 (LSD)
97 ÷ 8 = 12 Remainder 1
31 ÷ 8 = 3
Remainder 7
12 ÷ 8 = 1 Remainder 4
3 ÷ 8 = 0
Remainder 3 (MSD)
1 ÷ 8 = 0 Remainder 1 (MSD)
25010 = 3728
77710 = 14118
LSD
7
3
0
3
8
8
8
31
8
1
4
0
1
LSD
12
97
777
1
250
2
MSD
8
8
8
MSD
1
Figure 1.3. Decimal-octal conversion using the
successive division method

Number Systems
5
Octal numeration may be deduced from binary numeration by grouping,
beginning from the right, consecutive bits in triplets or, conversely, by replacing each
octal number by its three corresponding bits.
EXAMPLE 1.4.– Determine the radix 8 representation for the decimal numbers 85 and
129.
Radix 8 representations are obtained by replacing each group of three bits by the
equivalent octal number. We can therefore write:
8510 = 10101012 = 001

1
010

2
101

5
= 1258
Similarly,
12910 = 100000012 = 010

2
000

0
001

1
= 2018
1.5. Hexadecimal numeration
The hexadecimal number system or a representation with a radix 16 consists of the
following symbols: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
EXAMPLE 1.5.– Convert the decimal numbers 291 and 1000 to hexadecimal.
The number 291 is represented in radix 16 by:
29110 = (1 × 162) + (2 × 161) + (3 × 160)
= 12316
For the number 1000, we obtain:
1 00010 = (3 × 162) + (14 × 161) + (8 × 160)
= 3E816
In practice, a series of integer divisions makes it possible to convert a decimal
number to a hexadecimal number. The different remainders constitute the results of the
conversion, beginning with the last, which is the MSD, to the ﬁrst, which represents
the LSD. We thus have:
291 ÷ 16 = 18 Remainder 3 (LSD)
1000 ÷ 16 = 62 Remainder 8 (LSD)
18 ÷ 16 = 1
Remainder 2
62 ÷ 16 = 3 Remainder 14
1 ÷ 16 = 0
Remainder 1 (MSD)
3 ÷ 16 = 0 Remainder 3 (MSD)
29110 = 12316
100010 = 3E816

6
Digital Electronics 1
14
2
LSD
16
18
16
LSD
62
8
291
3
MSD
1
1
16
0
16
1000
3
16
3
0
16
MSD
Figure 1.4. Decimal-hexadecimal conversion using
the successive division method
We can also proceed as demonstrated in Figure 1.4, the result of each conversion
being made up of the successive remainders of the divisions.
Binary to hexadecimal conversion is done by grouping the bits representing the
binary four by four and beginning from the right, conversely, replacing each
hexadecimal digit by its four corresponding bits.
EXAMPLE 1.6.– Convert the decimal numbers 31 and 2, 988 into hexadecimal.
To obtain the equivalent hexadecimal from the binary representation, each group
of four bits is replaced by the corresponding hexadecimal digit. We therefore have:
3110 = 111112 = 0001

1
1111

15=F
= 1F16
Similarly,
2 98810 = 1011101011002 = 1011

11=B
1010

10=A
1100

12=C
= BAC16
It is generally more convenient to represent the value of an octet using two
hexadecimal digits as it is more compact.
1.6. Representation in a radix B
In general, in radix B representation, a decimal number N may be decomposed as
follows:
N10 = bn−1Bn−1 + · · · + b2B2 + b1B1 + b0B0
[1.1]
=
n−1

i=0
biBi
[1.2]
where B ≥2. Thus, the decimal number N is represented in radix B with n digits,
bn−1 · · · b2b1b0.

Number Systems
7
Using n digits in a radix B numeration, we can code the decimal numbers from 0
to Bn −1.
For an integer represented by n digits with a radix B, the formulas for conversion
are as follows:
(bn−1bn−2 · · · b2b1b0)B =
n−1

i=0
biBi
= bn−1Bn−1 + bn−2Bn−2 + · · · + b2B2 + b1B1 + b0B0
= b0 + B(b1 + B(b2 + B(· · · + B(bn−2 + Bbn−1) · · · )))
= N10
[1.3]
EXAMPLE 1.7.– Convert the binary number 1101012, the octal number 56718 and the
hexadecimal number 5CAD16 to decimal.
In decimal form, the number 1101012 is written as:
1101112 = 1 × 25 + 1 × 24 + 0 × 23 + 1 × 22 + 1 × 21 + 1 × 20
= 1 + 2(1 + 2(1 + 2(0 + 2(1 + 2 × 1))))
= 5510
For the number 56718, we get:
56718 = 5 × 83 + 6 × 82 + 7 × 81 + 1 × 80
= 1 + 8(7 + 8(6 + 8 × 5))
= 300110
The conversion of the number 5CAD16 to decimal is effected by:
5CAD16 = 5 × 163 + 12 × 162 + 10 × 161 + 13 × 160
= 13 + 16(10 + 16(12 + 16 × 5))
= 2372510
1.7. Binary-coded decimal numbers
To represent a 8421-type binary-coded decimal (BCD) number, each digit must be
replaced by its equivalent 4-bit binary.
EXAMPLE 1.8.– Give the BCD representation for the decimal numbers 90 and 873.

8
Digital Electronics 1
The BCD representation of the number 90 is written as follows:
9010 = 1001 0000BCD
For the number 873, we have:
87310 = 1000 0111 0011BCD
Table 1.1 gives the hexadecimal, octal, binary and BCD representations of
numbers from 0 to 15.
Decimal
Representation
number
Hexadecimal
Octal
Binary
BCD
0
0
0
0000
0000
1
1
1
0001
0001
2
2
2
0010
0010
3
3
3
0011
0011
4
4
4
0100
0100
5
5
5
0101
0101
6
6
6
0110
0110
7
7
7
0111
0111
8
8
10
1000
1000
9
9
11
1001
1001
10
A
12
1010
0001 0000
11
B
13
1011
0001 0001
12
C
14
1100
0001 0010
13
D
15
1101
0001 0011
14
E
16
1110
0001 0100
15
F
17
1111
0001 0101
Table 1.1. Conversion tables for 0 numbers to 15
It must be noted that with n bits, we can represent the decimal numbers between 0
and 10n/4 −1. In addition to the 8421 BCD code, there are other types of BCD codes.
1.8. Representations of signed integers
Several approaches may be adopted to represent signed integers in digital systems:
the sign-magnitude (SM) representation, two’s complement (2C) representation, and
excess-E (XSE) representation. Each of these approaches assumes the use of a format
(or number of bits) ﬁxed beforehand.

Number Systems
9
1.8.1. Sign-magnitude representation
The simplest approach allowing for the representation of a signed integer consists
of reserving the MSB for the number sign and the remaining bits for the number
magnitude. If the sign bit is set to 0, the number is positive, and if the sign bit is set to
1, the number is negative.
EXAMPLE 1.9.– Using 8 bits, determine the sign-magnitude representation for each
of the decimal numbers 55, −60, and 0.
We have:
5510 = 001101112
and
5510 = 00110111SM
6010 = 001111002
and
−6010 = 10111100SM
In the case of 0, two representations are possible:
+010 = 00000000SM
and
−010 = 10000000SM
The value of a decimal number N having an sign-magnitude representation of the
form bn−1bn−2 · · · b0 is given by:
N10 = (−1)bn−1
n−2

i=0
bi2i
[1.4]
or
N10 = (1 −2bn−1)
n−2

i=0
bi2i
[1.5]
In this way, it is possible to represent the numbers in the range from −(2n−1 −1)
to 2n−1 −1, using n bits.
However, the sign-magnitude representation presents two problems. The ﬁrst is
linked to the two representations, +0 and −0, of the number 0. The second problem
arises from the fact that this representation is not appropriate for addition operations,
especially when one of the numbers is negative. The two’s complement representation
allows us to remedy these two problems.

10
Digital Electronics 1
1.8.2. Two’s complement representation
Two’s complement representation of a number with n bits actually corresponds to
the complement with respect to 2n and is deﬁned as the difference between 2n and
this number in absolute value.
EXAMPLE 1.10.– Determine the 8-bit two’s complement representation of the
numbers 90 and −120.
As the number 90 is positive, the two’s complement representation is identical to
the natural binary representation:
9010 = 010110102 = 010110102C
The number −120 is negative and the two’s complement representation is obtained
as follows:
28 −120 = 136 and 13610 = 100010002 from which −12010 = 100010002C
Similarly, the two’s complement representation of a number may be obtained by
taking the one’s complement and then adding 1 (ignoring the overﬂow), because the
sum of a number and its one’s complement is equal to a number having all bits at 1
(or high logic level).
NOTE 1.1.– Assuming that the binary representation using n bits, of a positive number
N takes the form, bn−1bn−2 · · · b1b0, the two’s complement representation of −N
may be written as follows:
2n −N = (2n −1) −N + 1
= 111 · · · 11



n bits
2 −bn−1bn−2 · · · b1b0 + 1
[1.6]
where
2n −1 = 111 · · · 11



n bits
2
and the subtraction
111 · · · 11



n bits
2 −bn−1bn−2 · · · b1b0
[1.7]
allows for the inversion of each bit of N or for obtaining the one’s complement of N.

Number Systems
11
EXAMPLE 1.11.– The application of the above-cited method to determine the two’s
complement of the decimal number −120 using 8 bits translates to:
01111000 Binary representation of the decimal number 120
10000111 One’s complement obtained by inverting each bit
+
1 Addition of 1
10001000 Two’s complement
and
−12010 = 100010002C
The value of a decimal number N with two’s complement representation taking
the form, bn−1bn−2 · · · b0, is given by:
N10 = −bn−12n−1 +
n−2

i=0
bi2i
[1.8]
Using n bits, we can represent the numbers in the range from −2n−1 to 2n−1 −1.
In the case of 8-bit two’s complement representation, the highest positive value is:
28−1 −1 = 12710 = 011111112C
and the smallest negative value is:
−28−1 = −12810 = 100000002C
NOTE
1.2.– To
obtain
two’s
complement
representation
from
the
binary
representation of the corresponding positive number, we must:
– identify the ﬁrst 1 bit beginning from the right;
– take the one’s complement for each bit located before the identiﬁed bit.
Let us determine the 8-bit two’s complement representation for each of the
numbers −1010 and −11910.
Applying the procedure given in the previous note, as illustrated in Figure 1.5,
two’s complement representations are given by:
−1010 = 111101102C and −11910 = 011101112C

12
Digital Electronics 1
(b)
0 0 0 0 1 0 1 0
one´s complement
1 1 1 1 0 1 1 0
0 1 1 1 0 1 1 1
one´s complement
Take the
1 0 0 0 1 0 0 1
Take the
Right−most 1
Right−most 1
Two´s complement representation :
Binary representation of 10 :
Two´s complement representation :
Binary representation of 119 :
(a)
Figure 1.5. Obtaining a two’s complement from the binary
representation: a) −1010 and b) −11910
1.8.3. Excess-E representation
Some systems use the excess-E representation in order to be able to represent
negative numbers.
In excess-E representations, a number with n bits, whose unsigned value is N,
where 0 ≤N ≤Nmax = 2n −1, represents the signed integer N −E, where E
is the offset of the code. We can, thus, represent signed numbers in the range from
−E to Nmax −E. The value of the offset is, most often, of the form E = 2n−1 or
E = 2n−1 −1.
1.8.3.1. Case where E = 2n−1
Using an excess-2n−1 code, any number N in the range from −2n−1 to 2n−1 −1
is represented by the n-bit binary number, N + 2n−1, which is always positive and
less than 2n.
EXAMPLE 1.12.– Assuming that E = 2n−1, where n = 4, determine the excess-E’
representation of the decimal numbers 3 and −6.
The excess-8 code for the number 3 is obtained by determining the binary code for
the result of the operation 3 + 8 = 11, that is: 112 = 10112. Thus:
310 = 1011XS8
For the number −6, we have −6 + 8 = 2 and 210 = 00102. As a result:
−610 = 0010XS8

Number Systems
13
The excess-2n−1 code corresponds to a two’s complement representation where
the sign bit is complemented (1 is replaced by 0 and vice versa).
1.8.3.2. Case where E = 2n−1 −1
With an excess-2n−1 −1 code, we can represent the numbers N in the range from
−(2n−1 −1) to 2n−1.
A code similar to the excess-2n−1 −1 code is adopted in the standard IEEE-754
used for the representation of the exponents of ﬂoating-point numbers.
EXAMPLE
1.13.– Represent
the
decimal
numbers
27
and
−43
using
the
excess-2n−1 −1 code, where n = 8.
When n = 8, the value of the offset is E = 28−1 −1 = 27 −1 = 127.
The excess-127 code for the number 27 is obtained by adding 127 to 27, and then
converting the result to binary. That is:
27 + 127 = 154
15410 = 100110102
and
2710 = 10011010XS127
For the excess-127 of the number −43, we have:
−43 + 127 = 84
8410 = 010101002
and
−4310 = 01010100XS127
Table 1.2 gives the representations of unsigned and signed 3-bit integers. It must
be noted that in sign-magnitude representations, the decimal number 0 has two codes,
+010
=
000SM and −010
=
100SM. Using 3 bits, the two’s complement
representation allows for the coding of numbers from 3 to −4, while for the excess-3
representation, the numbers are in the range from 4 to −3.
1.9. Representation of the fractional part of a number
A number is usually made up of an integer part and a fractional part, whose value
is lower than 1. The fractional part of a number may be expressed as the sum of the
negative powers of the radix of the numeration system.
The number 0.59375 is written in decimal representation as follows:
0.5937510 = (5 × 10−1) + (9 × 10−2) + (3 × 10−3) + (7 × 10−4) + (5 × 10−5)

14
Digital Electronics 1
Decimal
Representation
number
Binary
SM
2C
XS3
7
111
6
110
5
101
4
100
111
3
011
011
011
110
2
010
010
010
101
1
001
001
001
100
000
0
000
100
000
011
−1
101
111
010
−2
110
110
001
−3
111
101
000
−4
100
Table 1.2. Representations of unsigned and signed 3-bit integers
It can be converted into binary, octal and hexadecimal, as given below:
0.5937510 = (1 × 2−1) + (0 × 2−2) + (0 × 2−3) + (1 × 2−4) + (1 × 2−5)
= 0.100112
= 0. 100

4
110

6
= 0.468
= 0. 1001

9
1000

8
= 0.9816
The practical method to convert the fractional part of a number consists of carrying
out a series of multiplications while extracting the integer part each time.
The different operations needed to convert the decimal number 0.59375 are shown
in Figure 1.6:
– conversion to binary:
0.59375 × 2 = 1.1875 Integer part 1 (MSB)
0.1875 × 2 = 0.375
Integer part 0
0.375 × 2 = 0.75
Integer part 0
0.75 × 2 = 1.5
Integer part 1
0.5 × 2 = 1.0
Integer part 1 (LSB)
0.5937510 = 0.100112

Number Systems
15
– conversion to octal:
0.59375 × 8 = 4.75 Integer part 4 (MSD)
0.75 × 8 = 6.0
Integer part 6 (LSD)
0.5937510 = 0.468
– conversion to hexadecimal:
0.59375 × 16 = 9.5 Integer part 9 (MSD)
0.50 × 16 = 8.0
Integer part 8 (LSD)
0.5937510 = 0.9816
0.59375
x 2
x 2
0 + 0.375
x 2
0 + 0.75
MSB
1 + 0.1875
x 2
1 + 0.5
LSB
x 2
1 + 0.0
0.59375
x 8
x 8
6 +
MSD
0.0
LSD
4 + 0.75
0.59375
x 16
9 + 0.5
x 16
MSD
LSD
+ 0.0
8
Figure 1.6. Conversion of the decimal number 0.59375 using the
successive multiplication method
NOTE 1.3.– Converting certain fractional numbers produces an inﬁnite sequence of
bits.
Convert the decimal number 0.45 to binary. Successively multiplying by 2 and
retaining the integer part of the result each time, we obtain:
0.45 × 2 = 0.9 Integer part 0 (MSB)
0.9 × 2 = 1.8
Integer part 1
0.8 × 2 = 1.6
Integer part 1
0.6 × 2 = 1.2
Integer part 1
0.2 × 2 = 0.4
Integer part 0
0.4 × 2 = 0.8
Integer part 0

16
Digital Electronics 1
0.8 × 2 = 1.6 Integer part 1
0.6 × 2 = 1.2 Integer part 1
0.2 × 2 = 0.4 Integer part 0
0.4 × 2 = 0.8 Integer part 0
· · ·
· · ·
0.4510 = 0.01 1100 1100 . . . 11002
When the binary representation corresponds to an inﬁnite sequence, one criterion
to determine the number of bits needed may be the precision that must be equivalent
in both numeration systems. In the above example, if the absolute error (in decimal) is
±5 × 10−3, the expansion in powers of 2−n will then stop at the nth term for which
the following condition is veriﬁed to be true:
2−n ≤5 × 10−3
[1.9]
Similarly, we have:
2n ≥200
n ≥log(200)
log(2)
= 7.64 ≃8
We can thus stop at the eighth row. Thus:
0.4510 = 0.011100112
1.10. Arithmetic operations on binary numbers
Arithmetic operations on binary numbers may be executed in the same way as for
decimal numbers.
The addition is the most executed arithmetic operation in digital systems. The
subtraction operation is essentially a variant of the addition operation, while
multiplication and division operations may be carried out by combining logical
functions (AND, OR, shift, etc.) and addition.
1.10.1. Addition
In binary representation, we begin by adding bits of lower weight, and the carry
that may be obtained when the sum of bits of the same weight exceeds the highest

Number Systems
17
value that can be represented with one bit, that is 1, is transferred, each time, to the
next MSB.
In binary representation, addition is carried out according to the following rules:
0 + 0 = 0
0 + 1 = 1 + 0 = 1
1 + 1 = 0
Carry 1
1 + 1 + 1 = 1
Carry 1
EXAMPLE 1.14.– Add the numbers 1010 and 1011.
Carrying out the addition operation in binary and decimal, we have:
1011
11
+ 0011
+
3
1110
14
The sum is obtained by adding the numbers, each of which is called the addend.
In practice, more than two numbers can be added in a digital system by initially
determining the sum of the ﬁrst two numbers, then adding this sum to the third number
and so on.
1.10.2. Subtraction
In binary representation, the execution of a subtraction operation takes place from
the LSBs to the MSBs with the assumption that the number to be subtracted (or the
subtrahend) is the smaller of the two operands. The difference is the result obtained
upon subtracting the subtrahend from the minuend.
Before subtracting a number (bit at the logic level 1) from another number of lower
value (bit at the logic level 0), we add the value of the radix (that is 2) to the latter and
a borrow of 1 is then carried over to the next highest bit to be subtracted. The rules
governing binary subtraction are:
0 −0 = 0
0 −1 = 1
Borrow 1
1 −0 = 1
1 −1 = 0
EXAMPLE 1.15.– Subtract the number 101 from the number 1010.

18
Digital Electronics 1
The subtraction may be carried out in binary representation and in decimal
representation as follows:
1010
10
Minuend
−0101
−
5
Subtrahend
0101
5
Difference
The difference is obtained by deducting the subtrahend from the minuend.
In practice, subtraction may be carried out like addition by using 2C representation,
which allows for the coding of positive and negative numbers.
1.10.3. Multiplication
Multiplication is carried out by forming a partial product for each bit of the
multiplier and then adding all the partial products to generate the result. It must be
noted that each partial product is shifted one position to the left with respect to the
preceding one and the product of two n-bit numbers may possess up to 2n bits.
The multiplication table in binary representation can be summarized as follows:
0 × 0 = 0
0 × 1 = 0
1 × 0 = 0
1 × 1 = 1
EXAMPLE 1.16.– Multiply the number 1101 by 1001.
Executing multiplication in binary representation translates to:
1101
Multiplicand
×
1001
Multiplier
1101
First partial product
0000
Second partial product
0000
Third partial product
+ 1101
Fourth partial product
1110101
Product
This operation is the equivalent of 13 × 9 = 117 in decimal.

Number Systems
19
By convention, the ﬁrst factor in a multiplication operation is called the
multiplicand and the second is called the multiplier. This distinction is of absolutely
no consequence as the multiplication operation is commutative. The product is
deﬁned as the result of a multiplication.
Multiplication may be carried out like a succession of addition and shift operations.
1.10.4. Division
Division of a binary number (the dividend) by another (the divisor) is carried out
by repeatedly deducting the divisor from the dividend until you obtain a difference that
is either equal to zero or inferior to the divisor and that represents the remainder. The
quotient corresponds to the number of times the divisor is contained in the dividend.
When the dividend is a 2n-bit number and the divisor is an n-bit number, the
quotient may be represented as an n-bit number. Division is executed by comparing
the n bits of the divisor with the n LSBs of the dividend. If the divisor is greater than
the dividend, no subtraction is performed, the corresponding quotient bit is set to 0,
and the divisor is then compared to the n + 1 LSBs of the dividend. If, on the other
hand, the divisor is less than or equal to the considered dividend bits, a subtraction
is carried out and the corresponding quotient bit is set to 1. The comparison process
of the divisor continues with the number obtained by lowering the next MSB of the
dividend to the right of the previously obtained difference.
EXAMPLE 1.17.– Divide the number 10000100 by 1101.
In binary representation, the division is carried out as follows:
Dividend
10000100 1101 Divisor
−
1101
1010
Quotient
0111
01110
−
1101
Remainder
010
In decimal, we similarly have 132 ÷ 13 = 10 and the remainder is 2.
An integer number is divisible by another when the quotient is an integer number
and the remainder is equal to zero.

20
Digital Electronics 1
1.11. Representation of real numbers
Real numbers are useful in digital systems as they allow for a variety of
calculations. They may be represented with a ﬁxed point or ﬂoating point.
Fixed-point representation allows for coding a ﬁxed range of numbers and rapid
calculation, while coding numbers of very different orders of magnitude is easier
with ﬂoating-point representation.
1.11.1. Fixed-point representation
In ﬁxed-point representation, a number may be expressed in the form:
bq−1bq−2 · · · b0, b−1b−2 · · · b−p
[1.10]
The sign-bit bq−1 is either equal to 0, for a positive number, or 1, for a negative
number. The ﬁrst q numbers represent the integer part while the last p numbers
constitute the fractional part.
According to the SM notation, the value of a decimal number represented in the
radix B is given by:
N10 = (−1)bq−1
q−2

i=−p
biBi
[1.11]
By setting p + q = n, we have:
N10 = (−1)bq−1
p+q−2

i=0
bi−pBi−p
[1.12]
=

(−1)bn−p−1
n−2

i=0
bi−pBi

B−p
[1.13]
where n is the total number of bits. Fixed-point representation may thus be
considered as representing an integer whose bits are shifted according to a factor, the
scale of which depends on the radix. The maximum (minimum) value in a ﬁxed-point
representation is obtained by multiplying by a scaling factor the greatest (smallest)
integer that can be represented with the same number of bits. Hence, the values that
can be represented are of the form:
−(Bn−1 −1)B−p ≤N10 ≤(Bn−1 −1)B−p
[1.14]

Number Systems
21
EXAMPLE 1.18.– In ﬁxed-point representation, we may obtain the following
conversions:
124.3710 = (1 × 102) + (2 × 101) + (4 × 100) + (3 × 10−1) + (7 × 10−2)
11.62510 = (1 × 23) + (0 × 22) + (1 × 21) + (1 × 20)+
(1 × 2−1) + (0 × 2−2) + (1 × 2−3) = 1011.1012
20.7510 = (2 × 81) + (4 × 80) + (6 × 8−1) = 24.68
30.510 = (1 × 161) + (14 × 160) + (8 × 16−1) = 1E.816
In 2C representation, the decimal value of a number can be expressed as:
N10 =

−bn−p−1 · 2n−1 +
n−2

i=0
bi−p2i

2−p
[1.15]
Using n bits, the range of numbers that may be represented is given by:
−2n−12−p ≤N ≤(2n−1 −1)2−p
[1.16]
where the number of bits for the fractional part is equal to p.
EXAMPLE 1.19.– Give the 8-bit representation of the decimal numbers 6.25 and
−8.4375.
We have:
6.2510 = (0 × 23) + (1 × 22) + (1 × 21) + (0 × 20) + (0 × 2−1) + (1 × 2−2)
= 0110.01002 = 0110.01002C
−8.437510 = −(1 × 23) + (0 × 22) + (0 × 21) + (0 × 20)
+(0 × 2−1) + (1 × 2−2) + (1 × 2−3) + (1 × 2−4)
= 1000.01112C
The result obtained upon multiplying two n bit numbers must be stored in 2n
bits. The size of the data may continually increase following the execution of other
multiplication operations. As the product of the numbers in the range from −1 to 1
always stays in the same interval, the solution adopted in digital systems consists of
using a representation (q = 1 and n = p + 1) in which the numbers are normalized
and can only vary between −1 and 1.

22
Digital Electronics 1
1.11.2. Floating-point representation
Floating-point representation may be considered as a scientiﬁc notation for digital
systems. A certain number of ﬂoating-point representations have been proposed in
order to satisfy the requirements of a variety of applications.
A decimal number N can be quantiﬁed and expressed in ﬂoating-point form as
follows:
N10 = (−1)SM · BE
[1.17]
where S is the sign-bit, M is the mantissa, B is the base or radix and E is the exponent.
The mantissa is generally normalized and corresponds to a number beginning with a
non-zero digit, as is the case with the following number representations:
−1234.5710 is written as −1.23457 × 103;
0.000007153910 is written as +7.1539 × 10−6;
1000101002 is written as 1.00010100 × 28.
As a result of the normalization of the mantissa, M, the number 0 cannot be
represented directly from the expression [1.17]. To arrive at this, we must use a
particular symbol. Indeﬁnite numbers, such as the result of a division by 0 or the
square root of a negative integer, are also represented using special characters.
1.11.2.1. IEEE-754 standard
Norms or standards have been proposed in order to make the different
representations of ﬂoating-point numbers uniform.
In the IEEE1-754 norm, the mantissa M and the exponent E must satisfy the
following inequalities:
1 ≤M < 2
[1.18]
and
2 −2k−1 ≤E ≤2k−1 −1
[1.19]
1 IEEE: Institute of Electrical and Electronics Engineers.

Number Systems
23
The binary equivalent of the mantissa M is thus normalized, and the exponent E
is written in biased form before being coded as a k-bit word. The values that can be
represented for a number N are such that:
Nmin = 22−2k−1 ≤|N| ≤Nmax = (2 −2−l)22k−1−1
[1.20]
The parameter l is deﬁned as being the number of bits of the mantissa. Figure 1.7
shows the range of numbers that can be represented in a ﬂoating-point format.
negative numbers
min
Nmax
0
min
−N
max
−N
positive numbers
Representable
Representable
N
Figure 1.7. Range of numbers that can be represented
in ﬂoating-point format
NOTE 1.4.– As the ﬁrst digit of the mantissa is always 1, it can be taken as implied.
This gives us an additional bit position that can be exploited to increase the range of
representable numbers.
The relative difference between two adjacent numbers is of the order 2l−l. It is,
therefore, necessary to round off some numbers before representing them.
Precision
Normalized representation
Denormalized representation
Single
±2−126 to (2 −2−23) × 2127
±2−149 to (1 −2−23) × 2−126
Double
±2−1022 to (2 −2−52) × 21023
±2−1074 to (1 −2−52) × 2−1022
Table 1.3. Range of numbers that can be represented
with the IEEE-754 standard
The majority of numbers in IEEE-754 ﬂoating-point representation are normalized
and have a mantissa of the form:
M = 1. f1f2 · · · fl



f
where the fractional part (or fraction) f is represented with l bits, and 1 ≤M < 2.
As shown in Table 1.4, the IEEE-754 standard deﬁnes two formats for number
representation: single precision (or 32 bits, composed of 1 sign bit, 8 exponent bits

24
Digital Electronics 1
and 23 mantissa bits) and double precision (or 64 bits, composed of 1 sign-bit, 11
exponent bits and 52 mantissa bits).
Sign
Biased
Mantissa
bit
exponent fraction
32 bit single precision 1 bit
8 bits
23 bits
64 bits double precision 1 bit
11 bits
52 bits
Table 1.4. Number format based on the IEEE-754 standard
In addition to the single and double precisions, the IEEE-754 standard supports
quadruple-precision representation (or 128 bits, composed of 1 sign bit, 15 exponent
bits and 112 mantissa bits), which is chieﬂy used in some software.
When an arithmetic operation involving two numbers gives a result that has an
exponent that is too small to be accurately represented, an underﬂow is produced. The
IEEE-754 standard, through the use of denormalized representation, offers a means of
gradually taking into account underﬂows.
A denormalized number is characterized by a biased exponent equal to 0 and a
mantissa of the form:
M = 0. f1f2 · · · fl



f
The mantissa bits are shifted one position to the right to insert the ﬁrst bit (implied
in normalized representation), which now has the value 0. To compensate for the shift
effect, the exponent is increased by 1.
Table 1.3 gives the range of numbers that can be represented using the IEEE-754
standard.
The exponent E is a signed k-bit integer such that Emin ≤E ≤Emax. Its
representation corresponds to the representation of the biased value E + b, where b is
the bias of the form 2k−1 −1. Furthermore, Emin = −b + 1 and Emax = b. The
exponents Emin −1 and Emax + 1 (0 and 2k −1, respectively, in the biased
representation) are reserved for zero, denormalized numbers and special values.

Number Systems
25
To facilitate the coding of positive and negative values of the exponent, a bias, b,
is added to the real value of the exponent, E, as follows:
Eb =
	
E + b,
if the number is normalized
E + b −1,
if the number is denormalized
[1.21]
Thus, in the IEEE-754 standard, the exponent corresponds to the binary
representation of Eb.
EXAMPLE 1.20.– Represent the decimal numbers 79.625 and −1000.2 in IEEE-754
single precision.
In the IEEE-754 standard, a number is represented by a sign bit, a mantissa and an
exponent. The normalized form of the binary equivalent of the number to be converted
allows for the identiﬁcation of the mantissa and the exponent.
The decimal number 79.625 can also be written as follows:
79.62510 = 1001111.1012 = 1.0011111012 × 26
– sign bit: S = 0;
– biased exponent (8 bits): Eb = 610 + 12710 = 13310 = 100001012;
– fractional part of the mantissa (23 bits):
f = 001111101000000000000002
from which:
79.62510 = 0 10000101 00111110100000000000000IEE754
The decimal number −1000.2 is represented in binary in the form:
1000.210 = 1111101000.00110011001100112
The fractional part corresponds to a continually repeating binary sequence. The
closest number to 1000.2 that may be represented is:
1000.2000122070312510 = 1111101000.001100110011012
= 1.111101000001100110011012 × 29
– sign bit: S = 1;

26
Digital Electronics 1
– biased exponent (8 bits): Eb = 910 + 12710 = 13610 = 100010002;
– fractional part of the mantissa (23 bits):
f = 111101000001100110011012
and ﬁnally:
−1000.210 = 1 10001000 11110100000110011001101IEE754
In the above-cited single-precision IEEE-754 representations, the ﬁrst bit indicates
the sign, the next eight bits allow for the coding of the exponent and the last 23 bits
correspond to the fractional part of the mantissa.
The different values taken by the numbers in IEEE-754 representations are
recorded in Table 1.5. The IEEE-754 standard uses special symbols (NaN, inﬁnity) to
indicate numbers that have an exponent composed entirely of bits set to 0 or 1. The
NaN or not a number value is used to represent a value that does not correspond to a
real number.
Exponent
Fraction
Value
Normalized
Emin ≤E ≤Emax
f ≥0
±(1.f) × 2E
Denormalized
E = Emin −1
f > 0
±(0.f) × 2Emin
Zero
E = Emin −1
f = 0
±0
Inﬁnite
E = Emax + 1
f = 0
±∞
Not a Number
E = Emax + 1
f > 0
NaN
Table 1.5. Values of numbers in IEEE-754 representations
EXAMPLE 1.21.– Find the decimal number corresponding to the following single-
precision IEEE-754 representation:
1 10000111 11000000000000000100001IEE754
We have:
– sign bit: S = 1;
– biased exponent (8 bits): Eb = 100001112 = 13510;
– fractional part of the mantissa (23 bits):
f = 110000000000000001000012

Number Systems
27
Applying the formula to the expression of real numbers by starting from the IEEE-
754 representation, that is:
N10 = (−1)S(1.f) × 2(Eb−127)
we ﬁnd:
N10 = (−1)1(1.110000000000000001000012) × 2(135−127)
= (−1)(111000000.0000000001000012)
= (−1)(28 + 27 + 26 + 2−10 + 2−15)
= −448.0010070810
from which:
1 10000111 11000000000000000000001IEE754 = −448.00110
1.11.2.2. Arithmetic operations on ﬂoating-point numbers
Let x = Mx · BEx and y = My · BEy be two positive numbers (sign-bit S = 0).
Supposing that Ex ≥Ey, y = MY · BEx and MY = MyB(Ex−Ey), we have:
x + y = (Mx + MY ) · BEx
[1.22]
and
x −y = (Mx −MY ) · BEx
[1.23]
In a ﬂoating-point representation, the numbers to be added or subtracted must,
thus, have the same exponent, such as:
145.50010 = 10010001.1002 = 0.10010001100 × 28
27.62510 = 00011000.1012 = 0.00011011101 × 28
In the case of multiplication and division, the results are obtained as follows:
x × y = (Mx × My) · B(Ex+Ey)
[1.24]
and
x/y = (Mx/My) · B(Ex−Ey)
[1.25]

28
Digital Electronics 1
It must be noted that because of the overﬂow effect or round-off errors, the
arithmetic operations in a ﬂoating-point representation do not have exactly the same
properties (associativity, distributivity) as with real numbers.
1.12. Data representation
As the arithmetic unit of a digital system recognizes only the binary states 0 and
1, a code is necessary to manipulate and transfer alphanumeric data (numbers, letters,
special characters) between a digital system and its peripheral devices.
1.12.1. Gray code
Gray code (or reﬂected binary code) is a non-weighted code, as it does not ascribe
a speciﬁc weight to each bit position. It is not used for arithmetic calculations.
An interesting feature presented by Gray code representation is related to the fact
that only a single bit changes value during the transition from one code to the next.
Table 1.6 gives the binary and Gray code representation of decimal numbers from 0 to
15.
The conversion of a binary number to Gray code is carried out by making use of
the following observations:
– the most signiﬁcant Gray code bit, situated to the extreme left, is the same as the
corresponding MSB for the binary number;
– starting from the left, add, without taking into account the carry-out bit, each
pair of adjacent bits to obtain the next bit in Gray code.
EXAMPLE 1.22.– Convert the binary number 110012 to Gray code.
Gray code
1
+ 1
0
+ 0
1
1 +
1
+ 0
0
1
Binary number
For the binary number 110012, the corresponding Gray code is 10101.
To convert Gray code to a binary number:
– the MSB of the binary number, located at the extreme left, is identical to the
corresponding Gray code bit;
– starting from the left, add each new bit of the binary code to the next bit of the
Gray code, without taking into account any carry-out bit, to obtain the next bit of the
binary code.

Number Systems
29
Decimal
Binary
Gray
Decimal
Binary
Gray
number
number
code
number
number
code
0
0000
0000
8
1000
1100
1
0001
0001
9
1001
1101
2
0010
0011
10
1010
1111
3
0011
0010
11
1011
1110
4
0100
0110
12
1100
1010
5
0101
0111
13
1101
1011
6
0110
0101
14
1110
1001
7
0111
0100
15
1111
1000
Table 1.6. Binary and Gray code representation of
decimal numbers from 0 to 15
EXAMPLE 1.23.– Convert the Gray code 10111 to a binary number.
1
+
+
+
+
1
1
0
1
1
0
Gray code
Binary number
0
1
1
The binary number corresponding to Gray code 10111 is 110102.
Gray code is used in Karnaugh maps and in the design of logic circuits. They also
ﬁnd application in rotary encoders, where the predisposition to errors increases with
the number of bits that change logical states between two consecutive positions.
1.12.2. p-out-of-n code
A p-out-of-n code is an n-bit representation that allows only combinations made up
of p bits at 1 and (n −p) bits at 0. The number of valid combinations for a p-out-of-n
code is n!/[(n −p)!p!].
The p-out-of-n code allows for the detection of errors based on the veriﬁcation of
the number of 1s and 0s at the time of reading of each code combination.
Some barcodes use p-out-of-n encoding, such as 2-out-of-5 encoding. Table 1.7
offers some examples of 2-out-of-5 code. These two codes are weighted only for
numbers different from zero and the list of weights appears in each of the
denominations.
The 2-out-of-5 code allows for the detection of all errors relating to a single bit,
but does not allow for the correction of these errors. As the smallest Hamming

30
Digital Electronics 1
distance (or the minimum number of bits that change logic states between two
consecutive combinations) is 2, it does not allow for the detection of errors caused by
the modiﬁcation of 2 bits.
2-out-of-5 code
2-out-of-5 code
0
1
2
3
6
7
4
2
1
0
0
0
1
1
0
0
1
1
0
0
0
1
1
1
0
0
0
0
0
0
1
1
2
1
0
1
0
0
0
0
1
0
1
3
1
0
0
1
0
0
0
1
1
0
4
0
1
0
1
0
0
1
0
0
1
5
0
0
1
1
0
0
1
0
1
0
6
1
0
0
0
1
0
1
1
0
0
7
0
1
0
0
1
1
0
0
0
1
8
0
0
1
0
1
1
0
0
1
0
9
0
0
0
1
1
1
0
1
0
0
Table 1.7. Examples of 2-out-of-5 code
Barcodes used to sort out letters are represented as shown in Figure 1.8(a), by a
series of parallel lines of variable size. The 0 bit corresponds to a small line and the
1 bit to a large line. Figure 1.8(b) shows another barcode that is used to identify parts
and that is composed of parallel lines of variable thickness. The 0 bit is represented by
a ﬁne line and the 1 bit by a thick line.
(b)
(a)
Figure 1.8. Barcodes corresponding to the binary representation 01100
A more compact form of the barcode is obtained by using interleaved 2-out-of-5
encoding. The ﬁrst code is represented by the black lines (three ﬁne lines and two thick
lines) of variable thickness, and the second code by the spacing between the black
lines (three narrow spaces and two wide spaces). The code shown in Figure 1.9(a) is
a representation of the combination 01100 (black lines) followed by 11000 (spaces
between the back lines). In general, the odd combinations are represented by black
lines and the even combinations are represented by spaces between the black lines.
Figure 1.9(b) shows the barcode corresponding to the sequence 01100, 11000, 10001
and 00110.
An appropriate optical reader is necessary to read each kind of barcode.

Number Systems
31
(b)
(a)
Figure 1.9. Barcodes based on an interleaved 2-out-of-5 encoding
1.12.3. ASCII code
ASCII code (or American standard code for information interchange) has seven
bits allowing for the representation of 27 = 128 symbols.
Table 1.8 gives the correspondence between certain characters and the decimal and
hexadecimal numbers of the ASCII code. The letter N, for example, is represented in
ASCII code by the number 78 in decimal and by 4E in hexadecimal. The ASCII code
contains 34 characters used to deﬁne the format of information and the space between
data and to control the transmission and reception of symbols.
1.12.4. Other codes
Given the ever-increasing number of characters,
other systems of data
representation were developed based on the ASCII code:
– EBCDIC (or extended binary coded decimal interchange code) is an eight bit
code;
– ANSI (or American national standard institute) allows for the representation of
alphabetical letters from many languages;
– using eight bit words (for UTF-8), 16 bit words (for UTF-16) and 32 bit words
(for UTF-32), the universal code, named Unicode (or Universal code) represents each
character in a unique way by a number. It covers symbols used in most languages.
1.13. Codes to protect against errors
There are different types of codes used to detect and correct errors that come up in
digital information during transmission or during storage.
1.13.1. Parity bit
To facilitate the detection of errors, a supplementary bit or parity bit is often added
at the end of a binary word with a ﬁxed number of bits. It allows for the allocation of
an odd or even parity depending on whether the total number of 1 bits in the code is
odd or even.

32
Digital Electronics 1
Dec
Hex
Char
Dec
Hex
Char
Dec
Hex
Char
Dec
Hex
Char
0
0
NUL
32
20
SP
64
40
@
96
60
‘
1
1
SOH
33
21
!
65
41
A
97
61
a
2
2
STX
34
22
"
66
42
B
98
62
b
3
3
ETX
35
23
#
67
43
C
99
63
c
4
4
EOT
36
24
$
68
44
D
100
64
d
5
5
ENQ
37
25
%
69
45
E
101
65
e
6
6
ACK
38
26
&
70
46
F
102
66
f
7
7
BEL
39
27
’
71
47
G
103
67
g
8
8
BS
40
28
(
72
48
H
104
68
h
9
9
TAB
41
29
)
73
49
I
105
69
i
10
A
LF
42
2A
*
74
4A
J
106
6A
j
11
B
VT
43
2B
+
75
4B
K
107
6B
k
12
C
NP
44
2C
,
76
4C
L
108
6C
l
13
D
CR
45
2D
-
77
4D
M
109
6D
m
14
E
SO
46
2E
.
78
4E
N
110
6E
n
15
F
SI
47
2F
/
79
4F
O
111
6F
o
16
10
DLE
48
30
0
80
50
P
112
70
p
17
11
DC1
49
31
1
81
51
Q
113
71
q
18
12
DC2
50
32
2
82
52
R
114
72
r
19
13
DC3
51
33
3
83
53
S
115
73
s
20
14
DC4
52
34
4
84
54
T
116
74
t
21
15
NAK
53
35
5
85
55
U
117
75
u
22
16
SYN
54
36
6
86
56
V
118
76
v
23
17
ETB
55
37
7
87
57
W
119
77
w
24
18
CAN
56
38
8
88
58
X
120
78
x
25
19
EM
57
39
9
89
59
Y
121
79
y
26
1A
SUB
58
3A
:
90
5A
Z
122
7A
z
27
1B
ESC
59
3B
;
91
5B
[
123
7B
{
28
1C
FS
60
3C
<
92
5C
\
124
7C
|
29
1D
GS
61
3D
=
93
5D
]
125
7D
}
30
1E
RS
62
3E
>
94
5E
^
126
7E
~
31
1F
US
63
3F
?
95
5F
_
127
7F
DEL
NUL
Null
DLE
Data link escape
SOH
Start of heading
DC1
Device control 1
STX
Start of text
DC2
Device control 2
ETX
End of text
DC3
Device control 3
EOT
End of transmission
DC4
Device control 4
ENQ
Enquiry
NAK
Negative acknowledge
ACK
Acknowledge
SYN
Synchronous idle
BEL
Bell
ETB
End of transmission block
BS
Backspace
CAN
Cancel
HT
Horizontal tab
EM
End of medium
LF
Line feed
SUB
Substitute
VT
Vertical tab
ESC
Escape
FF
Form feed
FS
File separator
CR
Carriage return
GS
Group separator
SO
Shift out
RS
Record separator
SI
Shift in
US
Unit separator
SP
Space
DEL
Delete
Table 1.8. ASCII codes table

Number Systems
33
EXAMPLE 1.24.– For the word 0101101, the parity bit is 0 (even parity: 4 bits at 1).
For the word 1010001, the parity bit is 1 (odd parity: 3 bits at 1).
Using a single parity bit allows for the detection of all errors that affect only one
bit. However, it does not allow for the correction of these errors.
1.13.2. Error correcting codes
The reliability of data transmission is generally ensured by using more elaborate
codes.
1.13.2.1. Block codes
In the block code approach, a certain number of control bits are appended to the
message that is structured in blocks of ﬁxed size. In this way, horizontal and vertical
parity of data can be veriﬁed.
Hamming distance corresponds to the number of bits that vary between two
successive words.
EXAMPLE 1.25.– There is a Hamming distance of 3 between the words 111011 and
101010. At least three errors are necessary to make these two words identical.
A possible way of increasing the Hamming distance of a code consists of using
several control bits. In this case, a message comprises m bits of data and k control
bits.
EXAMPLE 1.26.– Represent OUI in ASCII code with odd (horizontal and vertical)
parity bits and a crossed parity bit allowing for the indication of the integrity of the
(horizontal and vertical) parity bits.
The ASCII codes for the characters of the word OUI are as below:
7910 = 4F16 = 10011112 for O
8510 = 5516 = 10101012 for U
7310 = 4916 = 10010012 for
I
The choice of a two-dimension representation (or a block of bits), as shown in
Figure 1.10, allows for the deﬁnition of parity bits following the horizontal and vertical
direction.
Changing one single bit of the data may bring about a modiﬁcation of the vertical
parity bit, the horizontal parity bit and the crossed parity bit, that is four bits in total.
The Hamming distance is, thus, equal to 4.

34
Digital Electronics 1
0
0 1 0
1 0 1
1 1 0
1 0 0
1 1 1
0 0 0
1 1 1
OUI
1
0
1
0
0
1
1
1 0 1
Vertical parity
Control bit
Horizontal parity
Figure 1.10. Example of block codes
Such a block code allows for the detection and correction of all errors affecting one
single bit. It allows for the detection of all errors affecting 2 and 3 bits, but it presents
the inconvenience of requiring the veriﬁcation of a large number of bits.
1.13.2.2. Cyclic codes
Cyclic codes are based on the transcription of binary numbers in polynomial form
and the division of polynomials.
EXAMPLE 1.27.– The binary code bn−1bn−2 . . . b1b0 corresponds to the polynomial:
bn−1xn−1 + bn−2xn−2 + · · · + b1x1 + b0x0
Let I(x) be the polynomial associated with a message. Supposing that G(x) is
an r generator polynomial, the message may be coded by carrying out the following
operations:
– multiply I(x) by xr (or add r zeros at the end of I(x));
– decompose I(x)xr into the form:
I(x)xr
G(x) = Q(x) + R(x)
[1.26]
– determine the cyclic polynomial T(x):
T(x) = I(x)xr −R(x)
[1.27]

Number Systems
35
The polynomial T(x) is a multiple of G(x). It corresponds to a representation of
data to which redundant bits have been appended.
Errors are detected by verifying the divisibility of T(x) by G(x).
NOTE 1.5.– Expressions used for the generator polynomials vary by application areas:
– CRC2-3-GSM: G(x) = x3 + x + 1;
– CRC-4-ITU: G(x) = x4 + x + 1;
– CRC-8-CCITT: G(x) = x8 + x2 + x + 1;
– CRC-16-CCITT: G(x) = x16 + x12 + x5 + 1;
– CRC-32-IEEE: G(x) = x32 + x26 + x23 + x22 + x16 + x12 + x11 + x10 + x8 +
x7 + x5 + x4 + x2 + x + 1;
– CRC-64-ISO: G(x) = x64 + x4 + x3 + x + 1.
EXAMPLE 1.28.– Let us consider the initial information 101101, with which the
polynomial I(x) = x5+x3+x2+1 can be associated. Using the polynomial generator
of the form G(x) = x3 + x + 1 (r = 3), the form of the word to be transmitted, or the
polynomial T(x), is determined by proceeding as per the steps:
– multiplication of I(x) by xr gives the product I(x)xr = 101101000;
– the division of I(x)xr by G(x) yields the quotient Q(x) = 100001 and the
remainder R(x) = 011;
– the polynomial T(x) is ﬁnally obtained by appending the r bits of R(x) to the
end of I(x), that is: T(x) = 101101011.
In the form T(x) + E(x), the information is assumed to be affected by the error
E. With a code based on a polynomial generator G(x), we can detect:
– all the single errors (E = 10 . . . 0);
– all the double errors (E = 10 . . . 010 . . . 0) if G(x) has a factor with at least
three terms;
– all the errors relating to an odd number of bits (E has an odd number of bits at
1) if x + 1 divides G(x);
– all the series of errors (E = 0 . . . 01 . . . 10 . . . 0) of length smaller than the degree
of R(x);
– most of the long series of errors.
2 CRC: cyclic redundancy check.

36
Digital Electronics 1
1.14. Exercises
EXERCISE 1.1.– Conversions
1) Convert the following numbers to binary:
a) 3710
b) 1510
c) 18710
d) 2 01410
e) 2 01610
f) 2.7510
g) 25.2510
h) 243.312510
i) 0.062510
j) 628
k) 2778
l) 12.68
m) 476.358
n) 9216
o) 37FD16
p) 7FF16
q) 1A616
r) 2C016
s) 1F.C16
t) 9.F16
u) A7.EC16
2) Convert the following numbers to decimal:
a) 101102
b) 100012
c) 100011012
d) 1001000010012
e) 11110101112
f) 1011.1012
g) 10011011001.101102
h) 308
i) 1158
j) 55.48
k) 270.548
l) 35616
m) 2AF16
n) 2C116
o) 10FF16
p) 1FCFA16
q) DADA.C16
r) F.416
s) EBA.C16
3) Convert the following numbers to hexadecimal:
a) 32010
b) 6 86110
c) 65 53510
d) 1008
e) 62.48
f) 500.258
g) 100011012
h) 10010001101000111102
i) 10000.12
j) 1000000.00001112
k) 1000111001.012
4) Convert the following BCD numbers to decimal:
a) 0001 1000 0100BCD
b) 0100 1001 0010BCD
c) 1001 0111 0101 0010BCD
d) 0111 0111 0111 0101BCD
5) How many bits are required for the binary representation of the decimal
numbers from 0 to 511?
6) What is the largest number that can be represented in 16-bit binary numeration
system?
7) a) Determine the binary representation of the decimal number 10.05 with an
absolute error equal to 0.005.
b) Represent the decimal number 0.452 in binary numeration system with a
relative error of 0.1%.
EXERCISE 1.2.– Representation of numbers and data
1) Let X be an unsigned n-bit integer. Verify that 2n −X represents the two’s
complement of −X.
2) Determine the 8-bit two’s complement of the following numbers: −110, −1710,
−12810.
Convert the following numbers to decimal:
011111112C,
110011102C,
100010002C.

Number Systems
37
3) Determine the two’s complement representations of the numbers −63A16 and
−8AC16.
4) Convert the following numbers to ASCII codes:
a) 110,
b) 10710,
c) 10000102.
5) Use ASCII code to translate the following expressions:
X = cos(.7)
Y = 256 ∗X
PRINT "X=", X; "Y=", Y
6) a) Represent the following numbers in single-precision IEEE-754 standard:
2.7510, −417 68010.
b) Find the decimal number corresponding to each of the following single-
precision IEEE-754 representations:
0 10001010 01110111000110000000000IEE754
00000000 00000000000000000000001IEEE754
EXERCISE 1.3.– Gray code/binary number conversion
1) Convert the following binary numbers to Gray code:
a) 110112
b) 1011012
c) 110001102
2) Convert each of the following Gray code to binary number:
a) 1010Gray
b) 00010Gray
c) 11000010001Gray
EXERCISE 1.4.– Correction code
1) Data are to be transmitted, coded by the CRC method, whose polynomial
generator is:
G(x) = x3 + x + 1
Determine the bits of the message to be transmitted if the initial message is 101101.
What can we say of the transmission if the received message is 100101 011?
2) Using the CRC coding method, represent the message to be transmitted in the
case where the initial information is 1011001 and the polynomial generator is of the
form:
G(x) = x4 + x + 1

38
Digital Electronics 1
1.15. Solutions
SOLUTION 1.1.– Conversions
1) Conversions to binary representation
a) 3710 = 1001012
b) 1510 = 11112
c) 18710 = 101110112
d) 2 01410 = 111110111102
e) 2 01610 = 211 −25 = 111111000002
f) 2.7510 = 10.112
g) 25.2510 = 11001.01
h) 243.312510 = 11110011.01012
i) 0.062510 = 0.00012
j) 628 = 1100102
k) 2778 = 101111112
l) 12.68 = 1010.112
m) 476.358 = 100111110.0111012
n) 9216 = 100100102
o) 37FD16 = 110111111111012
p) 7FF16 = 111111111112
q) 1A616 = 1101001102
r) 2C016 = 11110000002
s) 1F.C16 = 11111.112
t) 9.F16 = 1001.11112
u) A7, EC16 = 10100111.1110112
2) Conversion to decimal representation
a) 101102 = 2210
b) 100012 = 1710
c) 100011012 = 14110
d) 1001000010012 = 231310

Number Systems
39
e) 11110101112 = 98310
f) 1011.1012 = 11.62510
g) 10011011001.101102 = 1241.687510
h) 308 = 3610
i) 1158 = 7710
j) 55.48 = 45.510
k) 270.548 = 184.687510
l) 35616 = 85410
m) 2AF16 = 68710
n) 2C116 = 70510
o) 10FF16 = 435110
p) 1FCFA16 = 13029810
q) DADA.C16 = 56026.7510
r) F.416 = 15.2510
s) EBA.C16 = 3770.7510
3) Conversion to hexadecimal representation
a) 32010 = 14016
b) 6 86110 = 1ACD16
c) 65 53510 = 164 −1 = FFFF16
d) 1008 = 4016
e) 62.48 = 32.816
f) 500.258 = 140.5416
g) 100011012 = 8D16
h) 10010001101000111102 = 48D1E16
i) 10000.12 = 10.816
j) 1000000.00001112 = 40.0E16
k) 1000111001.012 = 239.416

40
Digital Electronics 1
4) BCD – Decimal conversion
a) 0001 1000 0100BCD = 18410
b) 0100 1001 0010BCD = 49210
c) 1001 0111 0101 0010BCD = 9 75210
d) 0111 0111 0111 0101BCD = 7 77510
5) How many bits are required for the binary representations of the decimal
numbers from 0 to 511?
With k bits, only the decimal numbers from 0 to 2k −1 can be represented. Thus:
2k −1 = 511
and
k = log(512)/ log(2) = 9
6) What is the largest number that can be represented in 16 bit binary numeration?
The largest number that can be represented in 16 bits binary numeration system is
216 −1 = 65.535.
7) a) Determine the binary representation of the decimal number 10.05 with an
absolute error equal to 0.005.
To ensure that the difference between the represented value and the decimal
number 10.05 remains less than or equal to 0.005, the required number of bits, n,
must be determined based on the following relationship:
2−n ≤0.005
that is:
n ≥log(1/0.005)/ log(2) = 7.64 ≃8
and ﬁnally we have:
10.0510 = 1010.000011002
b) Represent the decimal number 0.452 in binary with a relative error of 0.1%.
The desired value of the absolute error is 0.001 × 0.452 = 0.000452.
The binary representation must possess a number of bits, n, that satisﬁes the
following equation:
2−n < 0.000452

Number Systems
41
that is:
n > log(1/0.000452)/ log(2) = 11.11 ≃12
Thus:
0.4522 = 0.01110011101101102
SOLUTION 1.2.– Representation of numbers and data
1) Let X be an unsigned n-bit integer. Verify that 2n −X represents the 2C of
−X.
Let X = Xn−1Xn−2 · · · X1X0 be the n-bit binary representation of a positive
number. We can write:
2n −X = (2n −1) −X + 1
where:
2n −1 = 111 · · · 11



n bits
2
The following subtraction operation:
111 · · · 11



n bits
2 −Xn−1Xn−2 · · · X1X0
is equal to the inversion of the logical level of the bits of X. Thus:
2n −X = (2n −1) −X + 1 = X + 1
is the 2C representation of −X.
2) Determine the 8-bit 2C of the following numbers: −110, −1710, −12810.
For each of the numbers, we can obtain:
110 = 000000012
111111101C + 1 = 111111112C = −110
1710 = 000100012
111011101C + 1 = 111011112C = −1710

42
Digital Electronics 1
12810 = 100000002
011111111C + 1 = 100000002C = −12810
3) Convert the following numbers to decimal representation:
011111112C,
110011102C and
100010002C.
The conversions are carried out as follows:
011111112C = 26 + 25 + 24 + 23 + 22 + 21 + 20 = 12710
110011102C = −27 + 26 + 23 + 22 + 21 = −5010
100010002C = −27 + 23 = −12010
4) Determine the 2C of the numbers −63A16 and −8AC16.
We can proceed as follows:
63A16 = 0110001110102
1001110001011C
+
1
= 1001110001102C = −63A16 = 9C616
8AC16 = 00001000101011002
11110111010100111C
+
1
= 11110111010101002C = −8AC16 = F75416
5) Convert the following numbers to ASCII code:
a) 110
b) 10710
c) 10000102
The corresponding ASCII codes are as follows:
a) 110 : SOH (start of heading)
b) 10710 : k
c) 10000102 = 6610 : B
6) Use ASCII code to translate the following expressions:
X = cos(.7)
Y = 256 ∗X
PRINT "X=", X; "Y=", Y

Number Systems
43
ASCII code
Symbol Dec. Hex.
X
88
58
=
61
3D
c
99
63
o
111
6F
s
115
73
(
40
28
.
46
2E
7
55
37
)
41
29
Y
89
59
=
61
3D
2
50
32
5
53
35
6
54
36
*
42
2A
X
88
58
ASCII code
Symbol Dec. Hex.
P
80
50
R
82
52
I
73
49
N
78
4E
T
84
54
Espace
32
20
"
34
22
X
88
58
=
61
3D
"
34
22
,
44
2C
X
88
58
"
34
22
Y
89
59
=
61
3D
"
34
22
,
44
2C
Y
89
59
7) a) Represent the following numbers in single-precision IEEE-754 standard:
2.7510 and −417 68010.
The binary conversion of 2.7510 yields:
2.7510 = 10.112
The normalized form is written as:
10.112 = 1.0112 × 21
We thus have:
– the mantissa M = 1.f (f represents the 23 bit fractional part):
f = 01100000000000000000000
– the exponent of 8 bits:
Eb = E + b = 110 + 12710 = 12810 = 100000002
– the sign bit:
S = 0 (in the case of a positive number)

44
Digital Electronics 1
From which:
2.7510 = 0 10000000 01100000000000000000000
For the decimal number −417 680, we obtain a binary representation of the
following form:
417 68010 = 11001011111100100002
The corresponding normalized form can be expressed as:
11001011111100100002 = 1.1001011111100100002 × 218
We thus have:
– the mantissa M = 1.f (f representing the 23 bit fractional part):
f = 10010111111001000000000
– the exponent of 8 bits:
Eb = E + b = 1810 + 12710 = 14510 = 100100012
– the sign bit:
S = 1 (in the case of a negative number)
And ﬁnally:
−417 68010 = 1 10010001 10010111111001000000000IEEE754
b) Find the decimal number corresponding to each of the following single-
precision IEEE-754 representations:
0 10001010 01110111000110000000000IEE754
1 00000000 00000000000000000000001IEEE754
For N10 = 0 10001010 01110111000110000000000IEE754, we have:
– the sign bit:
S = 0 (in the case of a positive number)
– the exponent of 8 bits:
Eb = 100010102 = 13810
(normalized number)

Number Systems
45
and:
E = Eb −b = 138 −127 = 1110
– the mantissa M of 23 bits:
M = 1.f
= 1.011101110001100000000002
= 20 + 2−2 + 2−3 + 2−4 + 2−6 + 2−7 + 2−8 + 2−12 + 2−13
= 1.465209960937510
Hence:
N10 = (−1)SM × 2E = 1.4652099609375 × 211 = 3000.7510
In the case of N10 = 1 00000000 00000000000000000000001IEEE754, we
obtain:
the sign bit:
S = 1 (for a negative number)
the exponent of 8 bits:
Eb = 000000002 = 010
(denormalized number)
and:
E = Eb −b + 1 = 0 −127 + 1 = −12610
the mantissa M of 23 bits:
M = 0.f
= 0.0000000000000000001
= 2−23
and ﬁnally:
N10 = (−1)SM × 2E = −2−23 × 2−126 = −2−149 = −1.4 × 10−45
SOLUTION 1.3.– Gray code/binary number conversion
1) Binary–Gray code conversion:
a) 110112 = 10110Gray
b) 1011012 = 111011Gray

46
Digital Electronics 1
c) 110001102 = 10100101Gray
2) Gray code–binary number conversion:
a) 1010Gray = 11002
b) 00010Gray = 000112
c) 11000010001Gray = 100000111102
SOLUTION 1.4.– Correction code
1) The principle of the CRC method consists of processing words and codes as
binary polynomials.
– Coding
In this case, the polynomial generator is of the degree 3 (r = 3) and is written as:
G(x) = x3 + x + 1
The correspondence between the initial message and a polynomial form is
established as follows:
101101
↔
I(x) = 1 · x5 + 0 · x4 + 1 · x3 + 1 · x2 + 0 · x1 + 1
The polynomial associated with the initial message is reduced to:
I(x) = x5 + x3 + x2 + 1
We have:
I(x)x3 = (x5 + x3 + x2 + 1)x3 = x8 + x6 + x5 + x3
The division of the polynomial I(x)x3 by G(x) is performed as follows:
x8 + x6 + x5 + x3
x3 + x + 1
x8 + x6 + x5
x5 + 1
←Quotient
x3
x3 + x + 1
x + 1 ←Remainder
The message to be transmitted, T(x), is obtained by concatenating the bits of the
initial message, I(x), and the r bits of the division remainder. That is:
101101 011

Number Systems
47
It must be noted that the division is carried out using the addition modulo 2 for the
coefﬁcients of the polynomials (0 + 0 = 0, 1 + 0 = 1, 1 + 1 = 0).
– Veriﬁcation
For an error-free transmission, the remainder of the division of the received
message, T(x), by the polynomial generator, G(x), must be equal to 0.
The polynomial associated with the received message is of the form:
101101 011
↔
x8 + x6 + x5 + x3 + x + 1
The division is executed as follows:
x8 + x6 + x5 + x3 + x + 1 x3 + x + 1
x8 + x6 + x5
x5 + 1
←Quotient
x3 + x + 1
x3 + x + 1
0
←Remainder
The remainder being 0, this is an error-free transmission.
Considering the other message that is received, we can obtain the following
polynomial:
100101 011
↔
x8 + x5 + x3 + x + 1
The division is carried out as follows:
x8 +
x5 +
x3 +
x + 1 x3 + x + 1
x8 + x6 + x5
x5 + x3 + x ←Quotient
x6 +
x3 +
x + 1
x6 +
x4 + x3
x4 +
x + 1
x4 +
x2 + x
x2 +
1
←Remainder
The remainder of the division is not equal to 0, which is the feature of a received
message with errors.
2) Coding of the message to be transmitted when the polynomial generator is
G(x) = x4 + x + 1 and the initial message is 1011001.

48
Digital Electronics 1
The initial message can be associated with the polynomial, I(x), given by:
I(x) = x6 + x4 + x3 + 1
The multiplication of I(x) by x4 results in:
I(x)x4 = (x6 + x4 + x3 + 1)x4 = x10 + x8 + x7 + x4
The division is performed as follows:
x10 + x8 + x7 +
x4
x4 + x + 1
x10 +
x7 + x6
x6 + x4 + x2 + x ←Quotient
x8 +
x6 +
x4
x8 +
x5 + x4
x6 + x5
x6 +
x3 + x2
x5 +
x3 + x2
x5 +
x2 + x
x3 +
x ←Remainder
Concatenating the bits of the initial message, I(x), and the four bits of the
remainder of the division, the message to be transmitted, T(x), takes the following
form:
1011001 1010

2
Logic Gates
2.1. Introduction
Logic functions provide ways to combine different digital signals – or signals that
can only take one of two possible levels: low level (0) and high level (1) – based on
the laws of Boolean algebra. These laws are applied using logic gates, which can be
classiﬁed according to the number of available inputs.
Each logic gate has an equivalent electric circuit. However, an electronic logic gate
is very different from its electrical equivalent. It is much faster, smaller, and consumes
less electric energy.
Figure 2.1 shows the electric circuit that corresponds to the NOT gate. The light-
emitting diode comes on when the switch S1 is opened and goes off when the switch
S1 is closed.
S1
S1
R
R
−
+
−
+
Figure 2.1. Electric circuit that is the equivalent of the NOT gate
The electric circuit shown in Figure 2.2 operates as an AND gate. The diode lights
up if and only if both switches S1 and S2 are closed.
Figure 2.3 shows the electric circuit for the OR gate. The diode comes on if at least
one of the switches (S1 or S2) is closed.
Digital Electronics 1: Combinational Logic Circuits, First Edition. Tertulien Ndjountche.
© ISTE Ltd 2016. Published by ISTE Ltd and John Wiley & Sons, Inc.

50
Digital Electronics 1
S2
S1
S2
S1
−
+
−
+
Figure 2.2. Electric circuit corresponding to the AND gate
S2
S1
S2
S1
+
−
−
+
Figure 2.3. Electric circuit corresponding to the OR gate
The electric circuit corresponding to the XOR gate is illustrated in Figure 2.4. The
diode emits visible light when either the switch S1 or the switch S2 is closed.
2
S
1
S
0
1
1
0
0
1
1
0
2
S
1
S
2
S
1
S
−
+
+
−
Figure 2.4. Electric circuit corresponding to the XOR gate, where
pressure on either push button S1 or push button S2 turns on the diode,
but pressure on push button S1 and push button S2 turns off the diode
2.2. Logic gates
Logic gates can be used to combine digital signals based on basic Boolean
functions.

Logic Gates
51
2.2.1. NOT gate
The NOT function provides the complementary state to a given variable. The
function is represented by a bar placed above the input variable and implemented by
a NOT gate (or logic inverter).
B
A
Figure 2.5. NOT gate. B = A
A B
0 1
1 0
Table 2.1. Truth table. Input: A; Output: B
Figure 2.6 depicts the symbol for a NOT gate. The logic level of the output variable
is obtained by taking the complement of the input variable, as shown in the truth table
given in Table 2.1. Thus, if an input is at logic level 0, the output will be at logic level
1, and vice versa.
2.2.2. AND gate
The AND function, which is also called logic product, is represented by a dot (·).
A
B
C
Figure 2.6. AND gate
C = A · B
The AND gate can have two inputs, as illustrated in Figure 2.6, the output variable
takes the high logic level (or the value 1) if and only if the input variables are both at
the high logic level (or the value 1). In all other cases, the output is set to the low logic
level (or the value 0). Table 2.2 shows the truth table for the AND gate.

52
Digital Electronics 1
A B C
0 0 0
0 1 0
1 0 0
1 1 1
Table 2.2. Truth table.
Inputs: A, B; Output: C
2.2.3. OR gate
The OR function, which is also called logic addition, is represented by a plus (+).
A
C
B
Figure 2.7. OR gate
C = A + B
A
B
C
0
0
0
0
1
1
1
0
1
1
1
1
Table 2.3. Truth table.
Inputs: A, B; output: C
Figure 2.7 depicts the OR gate, which has two gates. As illustrated by the truth
table in Table 2.3, the output takes the logic level 1 if at least one of the two inputs is
at the logic level 1, it takes logic level 0 if both the inputs are at the logic level 0.
2.2.4. XOR gate
The XOR (exclusive OR) function is represented by a plus within a circle (⊕).
Figure 2.8 depicts the symbolic representation of an XOR gate having two inputs.
According to the truth table shown in Table 2.4, the output takes either logic level 1,
when only one of the inputs is at logic level 1, or logic level 0, when both inputs are
either at logic level 0 or at logic level 1.

Logic Gates
53
B
A
C
B
A
C
Figure 2.8. XOR gate (exclusive OR)
C = A ⊕B = A · B + A · B
A
B
C
0
0
0
0
1
1
1
0
1
1
1
0
Table 2.4. Truth table.
Inputs: A, B; Output: C
2.2.5. Complementary logic gates
The NAND (NOT AND), NOR (NOT OR), and XNOR (NOT exclusive OR or
inclusive AND) gates are said to be complementary and correspond, respectively, to
the AND, OR and XOR gates when followed by a NOT gate. They are characterized
by the following logic equations:
– NAND gate: C = A · B;
– NOR gate: C = A + B;
– XNOR gate: C = A ⊕B = A · B + A · B = A ⊙B.
A
B
(a)
A
B
(b)
C
B
A
C
(c)
C
Figure 2.9. NAND (NOT AND) (a), NOR (NOT OR) (b) and XNOR
(NOT exclusive OR) (c) gates
The NAND and NOR gates are considered to be universal gates. This means that
any logic function can be implemented using just NAND or NOR gates. It must be
noted that neither the XOR gate nor the XNOR gate is universal.

54
Digital Electronics 1
2.3. Three-state buffer
A three-state buffer works as a signal-controlled switch. An enable signal is used
to control whether the input signal is transferred toward the output or isolated from
the output, which is then held in a high-impedance state.
The output from the circuit shown in Figure 2.10 can take any of the following
three states: high (1), low (0) and high impedance (z).
X
E
Y
Figure 2.10. Three-state buffer
When E = 0, the output is held in the high impedance state.
When E = 1, the output is at the same state as the input (0 or 1).
Table 2.5 shows the truth table for the three-state buffer.
E
X
Y
0
x
z
1
0
0
1
1
1
Table 2.5. Truth table
Using the three-state buffer makes it possible to link the outputs of logic gates set
up in parallel through a common line.
2.4. Logic function
A logic function is completely deﬁned when, for all combinations of input
variables, the function value is deﬁned. The number of these combinations is 2n for n
variables.
A function is incompletely deﬁned when there is at least one combination of input
variables for which the logic level is unknown.

Logic Gates
55
When a logic system is implemented, two cases may occur:
– one of the possible combinations will never exist in the normal functioning of
the system. This is called a forbidden condition and is denoted by - (hyphen);
– one of the combinations exists but can take either the state 0 or 1. This is called
the do not care condition and is represented by the symbol x or φ.
In general, a logic function can thus take four states: 0, 1, x and -.
A function with n variables may be represented by a truth table having n + 1
columns and a maximum of 2n lines.
2.5. The correspondence between a truth table and a logic function
Let X(A, B, C) be a logic function with three variables, which is deﬁned by a
truth table.
DEFINITION 2.1.– Based on the truth table in Table 2.6, the function X may be written
as the following sum of products:
X(A, B, C) = A · B · C + A · B · C + A · B · C + A · B · C + A · B · C
=

m(0, 3, 4, 6, 7)
[2.1]
A
B
C
X
0
0
0
0
1
↔A · B · C
1
0
0
1
0
2
0
1
0
0
3
0
1
1
1
↔A · B · C
4
1
0
0
1
↔A · B · C
5
1
0
1
0
6
1
1
0
1
↔A · B · C
7
1
1
1
1
↔A · B · C
Table 2.6. Truth table (sum of products)
With three variables, A · B · C corresponds to a minterm, while A · B is not a
minterm. A minterm must contain all function variables.
On referring to the truth table in Table 2.7, the product-of-sums form of the
function X can be obtained as follows:
X(A, B, C) = (A + B + C) · (A + B + C) · (A + B + C)
=

M(1, 2, 5)
[2.2]

56
Digital Electronics 1
A
B
C
X
0
0
0
0
1
1
0
0
1
0
↔A + B + C
2
0
1
0
0
↔A + B + C
3
0
1
1
1
4
1
0
0
1
5
1
0
1
0
↔A + B + C
6
1
1
0
1
7
1
1
1
1
Table 2.7. Truth table (product of sums)
With three variables, A + B + C represents a maxterm, while B + C is not a
maxterm.
The canonical form corresponds to the Boolean expression of a logic function
using only minterms or maxterms. It is unique for each logic function.
The complement of the function X is given by:
X(A, B, C) =

M(0, 3, 4, 6, 7) =

m(1, 2, 5)
[2.3]
In the case of four variables, the logic function X is considered to be deﬁned by
the truth table in Table 2.8.
The function X can be written as the following sum of products:
X(A, B, C, D) = A · B · C · D + A · B · C · D + A · B · C · D + A · B · C · D
=

m(1, 5, 7, 15)
[2.4]
Generally, the following relationships exist between the minterms, mi, and the
maxterm, Mi, of a logic function of n variables:
mi = M2n−1−i
or
Mi = m2n−1−i
(0 ≤i ≤2n −1)
[2.5]
Let n be the number of variables of a logic function:
– the sum of all the 2n minterms of a function is equal to 1;
– the product of all the 2n maxterms of a function is equal to 0.

Logic Gates
57
A
B
C
D
X
0
0
0
0
0
0
1
0
0
0
1
1
↔A · B · C · D
2
0
0
1
0
0
3
0
0
1
1
0
4
0
1
0
0
0
5
0
1
0
1
1
↔A · B · C · D
6
0
1
1
0
0
7
0
1
1
1
1
↔A · B · C · D
8
1
0
0
0
0
9
1
0
0
1
0
10
1
0
1
0
0
11
1
0
1
1
0
12
1
1
0
0
0
13
1
1
0
1
0
14
1
1
1
0
0
15
1
1
1
1
1
↔A · B · C · D
Table 2.8. Truth table (sum of products)
The product of two different minterms is equal to 0, while the sum of two different
maxterms is equal to 1.
2.6. Boolean algebra
Boolean algebra is applied to operations and functions on logic variables.
Let X and Y be logic (or Boolean) functions, whose values can only be 0 or 1.
The following properties are veriﬁed:
1) commutativity: X + Y = Y + X and X · Y = Y · X;
2) associativity: X + (Y + Z) = (X + Y ) + Z and X · (Y · Z) = (X · Y ) · Z;
3) distributivity: X ·(Y +Z) = X ·Y +X ·Z and (X +Y )(X +Z) = X +Y ·Z;
4) X + Y = X · Y (DeMorgan’s theorem – NOR);
5) X · Y = X + Y (DeMorgan’s theorem – NAND).
EXAMPLE 2.1.– Implement an XOR gate from NAND logic gates and an XNOR gate
from NOR logic gates.

58
Digital Electronics 1
The logic equation for the XOR gate is given by:
C = A ⊕B = A · B + A · B
[2.6]
and
C = C = A · B · A · B
[2.7]
Because A · B = A · A · B and A · B = A · B · B, equation [2.7] takes the form:
C = A · A · B · A · B · B
[2.8]
Equation [2.8] can then be implemented as illustrated in Figure 2.11.
(a)
B
A
A
B
(b)
C
C
Figure 2.11. XOR gate: a) symbol; b) construction using NAND gates
For the XNOR gate, we have:
C = A ⊕B = A · B + A · B
[2.9]
Because
A · B = A · B = A(A + B) = A + A + B
[2.10]
and
A · B = A · B = (A + B)B = A + B + B
[2.11]

Logic Gates
59
equation [2.9] becomes:
C = A + A + B + A + B + B
[2.12]
Figure 2.12 depicts the logic circuit corresponding to equation [2.12].
C
A
B
(b)
(a)
B
A
C
Figure 2.12. XNOR gate: a) symbol; b) construction using NOR gates
2.6.1. Boolean algebra theorems
Boolean algebra is governed by a certain number of theorems (or properties). The
algebraic method of simpliﬁcation uses properties of Boolean algebra to make it
possible to minimize Boolean expressions (or logic functions), thus reducing the
material cost for practical implementation.
2.6.1.1. NOT, AND and OR functions
Table 2.9 gives the basic properties for the NOT, AND and OR operations.
NOT
AND
OR
0 = 1
0 · X = 0
0 + X = X
1 = 0
1 · X = X
1 + X = 1
X = X X · X = X X + X = X
X · X = 0
X + X = 1
Table 2.9. Basic properties for the NOT, AND and OR operations
In general, for the Boolean functions X, Y and Z, it is possible to establish the
following theorems:

60
Digital Electronics 1
– simpliﬁcation theorem:
X + X · Y = X
X(X + Y ) = X
X · Y + X · Y = X
(X + Y )(X + Y ) = X
– absorption theorem:
X + X · Y = X + Y
X(X + Y ) = X · Y
– factorization and multiplication theorem:
(X + Y )(X + Z) = X · Z + X · Y
X · Y + X · Z = (X + Z)(X + Y )
– consensus theorem:
X · Y + X · Z + Y · Z = X · Y + X · Z
(X + Y )(X + Z)(Y + Z) = (X + Y )(X + Z)
SHANNON’S EXPANSION THEOREM.– Let F(x0, x1, . . . , xi, . . . , xn−1) be a Boolean
logic function of n variables. Shannon’s expansion theorem can be written as follows:
F(x0, x1, . . . , xi, . . . , xn−1) = xi · F(x0, x1, . . . , 0, . . . , xn−1)+
xi · F(x0, x1, . . . , 1, . . . , xn−1) [2.13]
In practice,
applying Shannon’s expansion theorem makes it possible to
decompose a function of ﬁve variables, for example, to give rise to two functions of
four variables. Thus:
F(A, B, C, D, E) = E · F(A, B, C, D, 0) + E · F(A, B, C, D, 1)
[2.14]
where in fact F(A, B, C, D, 0) and F(A, B, C, D, 1) represent functions of four
variables.
By iteratively applying Shannon’s expansion theorem, a Boolean function can be
expressed from the different values obtained for the different combinations of input
variables as given in the truth table.

Logic Gates
61
A
B
F(A,B)
0
0
1
0
1
0
1
0
0
1
1
1
Table 2.10. Truth table
For the two-variable function, F(A, B), with the truth table in Table 2.10, we have:
F(A, B) = A · F(0, B) + A · F(1, B)
[2.15]
= A[B · F(0, 0) + B · F(0, 1)] + A[B · F(1, 0) + B · F(1, 1)]
= A · B · F(0, 0) + A · B · F(0, 1) + A · B · F(1, 0) + A · B · F(1, 1)
where F(0, 0) = 1, F(0, 1) = 0, F(1, 0) = 0 and F(1, 1) = 1.
2.6.1.2. XOR (exclusive OR) and XNOR (inclusive AND) functions
The XOR (OR exclusive) function of two variables is deﬁned by:
X ⊕Y = XY + X · Y
[2.16]
Furthermore, we can write:
X ⊕Y = X ⊕Y
[2.17]
The deﬁnition of the XNOR (AND inclusive) function with two variables is given by:
X ⊙Y = X · Y + X · Y
[2.18]
It must be noted that:
X ⊙Y = X ⊙Y = X ⊕Y = X ⊕Y = X ⊕Y
[2.19]
Let us consider the Boolean functions, X, Y , and Z. Table 2.11 shows the truth
table for the function X ⊕(Y · Z) and (X ⊕Y )(X ⊕Z). We can thus observe that
X ⊕(Y · Z) is different from (X ⊕Y )(X ⊕Z).

62
Digital Electronics 1
X
Y
Z
Y · Z
X ⊕Y
X ⊕Z
X ⊕(Y · Z)
(X ⊕Y )(X ⊕Z)
0
0
0
0
0
0
0
0
0
0
1
0
0
1
0
0
0
1
0
0
1
0
0
0
0
1
1
1
1
1
1
1
1
0
0
0
1
1
1
1
1
0
1
0
1
0
1
0
1
1
0
0
0
1
1
0
1
1
1
1
0
0
0
0
Table 2.11. Truth table for X ⊕(Y · Z) and (X ⊕Y )(X ⊕Z)
For the functions X ⊕Y ⊕(X + Y ) and X ⊕Y ⊕X + X ⊕Y ⊕Y , the truth
table is represented in Table 2.12. Expressing all combinations of the variables X and
Y where each function takes the logic level 1, we have:
X ⊕Y ⊕(X + Y ) = X · Y
[2.20]
and
X ⊕Y ⊕X + X ⊕Y ⊕Y = X · Y + X · Y + X · Y
= X(Y + Y ) + X · Y
= X + X · Y
= X + Y
[2.21]
X
Y
X + Y
X ⊕Y
X ⊕Y ⊕(X + Y )
X ⊕Y ⊕X + X ⊕Y ⊕Y
0
0
0
0
0
0
0
1
1
1
0
1
1
0
1
1
0
1
1
1
1
0
1
1
Table 2.12. Truth table for X ⊕Y ⊕(X + Y ) and
X ⊕Y ⊕X + X ⊕Y ⊕Y
Therefore, functions X ⊕Y ⊕(X + Y ) and X ⊕Y ⊕X + X ⊕Y ⊕Y are not
equal.
The basic properties for the XOR and XNOR operations are given in Table 2.13.

Logic Gates
63
XOR
XNOR
0 ⊕X = X 0 ⊙X = X
1 ⊕X = X 1 ⊙X = X
X ⊕X = 0 X ⊙X = 1
X ⊕X = 1 X ⊙X = 0
Table 2.13. Basic properties for the XOR and XNOR operations
The following theorems are veriﬁed for the Boolean functions X, Y and Z:
– commutativity:
X ⊕Y = Y ⊕X
X ⊙Y = Y ⊙X
– associativity:
X ⊕(Y ⊕Z) = (X ⊕Y ) ⊕Z = X ⊕Y ⊕Z
X ⊙(Y ⊙Z) = (X ⊙Y ) ⊙Z = X ⊙Y ⊙Z
– factorization and distributivity:
(X · Y ) ⊕(X · Z) = X · (Y ⊕Z)
(X + Y ) ⊙(X + Z) = X + (Y ⊙Z)
– absorption:
X · (X ⊕Y ) = X · Y
X + (X ⊙Y ) = X + Y
– consensus:
(X · Y ) ⊕(X · Z) + Y · Z = (X · Y ) ⊕(X · Z)
(X + Y ) ⊙(X + Z) · (Y + Z) = (X + Y ) ⊙(X + Z)
For two logic functions, X and Y , it may be established that:
−if X · Y = 0, then X + Y = X ⊕Y ;
−if X + Y = 1, then X · Y = X ⊙Y .

64
Digital Electronics 1
NOTE 2.1.– Boolean algebra theorems (or properties) possess two forms, one deduced
from the other by replacing:
– all plus signs (+) with a point (·), and vice versa;
– all circled plus signs (⊕) with a circled point (⊙), and vice versa;
– any logic level 1 by logic level 0, and vice versa.
EXAMPLE 2.2.– Show that:
(X · Y ) ⊕(X + Y ) = X ⊕Y
X ⊙Y ⊙(X · Y ) = X + Y
(X + Y ) ⊙(X ⊕Y ) = X · Y
X · Y + Y · Z + X · Z = X · Y ⊕Y · Z ⊕X · Z
Using Boolean algebra theorems (or properties), we can write:
(X · Y ) ⊕(X + Y ) = X · Y (X + Y ) + X · Y (X + Y )
= X · Y (X + Y ) + X · Y (X + Y )
= X · Y (X · Y ) + (X + Y )(X + Y )
= X · Y + X · Y
= X ⊕Y
[2.22]
X ⊙Y ⊙(X · Y ) = (X ⊙Y )(X · Y ) + (X ⊙Y )(X · Y )
= (X · Y + X · Y )(X · Y ) + (X ⊕Y )(X + Y )
= X · Y + (X · Y + X · Y )(X + Y )
= X · Y + X · Y + X · Y
= X(Y + Y ) + X · Y
= X + X · Y
= X + Y
[2.23]
(X + Y ) ⊙(X ⊕Y ) = (X + Y ) ⊙(X · Y + X · Y )
= (X + Y ) · (X · Y + X · Y )
because
(X + Y ) + (X · Y + X · Y ) = 1
= X · Y
[2.24]

Logic Gates
65
X · Y + Y · Z + X · Z = X · Y (Z + Z) + (X + X)Y · Z + X · (Y + Y )Z
= X · Y · Z + X · Y · Z + X · Y · Z + X · Y · Z
= X · Y · Z + X · Y · Z ⊕(X · Y · Z + X · Y · Z)
because
(X · Y · Z)(X · Y · Z + X · Y · Z) = 0
= X · Y (Z + Z) ⊕(Y ⊕X)Z
= X · Y ⊕Y · Z ⊕X · Z
[2.25]
2.6.2. Karnaugh maps
A semi-graphical method, which is based on the use of Karnaugh maps, is more
appropriate for the simpliﬁcation of more complex Boolean expressions.
A Karnaugh map, like a truth table, provides a representation of logic functions. It
is composed of a certain number of squares or cells, each of which is reserved for a
term (minterm or maxterm) of a logic function. Figure 2.13 shows Karnaugh maps for
a three-variable function and Figure 2.14 presents Karnaugh maps for a four-variable
function. The variables can be represented in two ways. On each map, the combination
of the variables are placed in accordance with the order of Gray’s encoding such that
adjacent terms are in the neighboring cells or in the cells at map ends.
A
AB
C
00
01
11
10
A
0
2
6
0
4
5
1
3
7
(a)
B
1
C
BC
A
00
01
11
10
B
0
1
3
0
2
6
4
5
7
(b)
C
1
Figure 2.13. Three-variable Karnaugh map
Though Karnaugh maps can be used to reduce any logic function, they become
difﬁcult to manipulate when the number of variables exceeds six.

66
Digital Electronics 1
5
01
11
10
00
01
11
10
AB
CD
C
00
01
11
10
B
A
D
(a)
0
3
2
1
4
7
6
5
12
15
14
13
8
11
10
9
CD
AB
A
00
01
11
10
D
C
B
(b)
0
12
8
4
1
13
9
3
15
11
7
2
14
10
6
00
Figure 2.14. Four-variable Karnaugh map
B
1
1
0
0
0
0
0
0
AB
C
00
01
11
10
A
0
1
C
Figure 2.15. Duad:
X = A · B · C + A · B · C = B · C
0
AB
C
00
01
11
10
A
0
B
1
C
1
0
0
0
0
1
0
Figure 2.16. Duad:
X = A · B · C + A · B · C = A · B

Logic Gates
67
C
0
0
1
1
0
0
0
0
AB
C
00
01
11
10
A
0
B
1
Figure 2.17. Duad:
X = A · B · C + A · B · C = B · C
C
0
0
1
1
1
0
0
1
AB
C
00
01
11
10
A
0
B
1
Figure 2.18. Quad:
X = A · B · C + A · B · C+ A · B · C + A · B · C = B
C
0
0
0
0
1
1
1
1
AB
C
00
01
11
10
A
0
B
1
Figure 2.19. Quad:
X = A · B · C + A · B · C + A · B · C + A · B · C = C
Using a Karnaugh map, the simpliﬁcation of a logic function is carried out by
grouping the adjacent cells that contain 1s. The number of cells in a group must be a
power of 2, or of the form 2n (n = 1, 2, 3, . . .):

68
Digital Electronics 1
C
0
1
1
0
0
0
1
1
AB
C
00
01
11
10
A
0
B
1
Figure 2.20. Quad:
X = A · B · C + A · B · C + A · B · C + A · B · C = A
0
01
11
10
AB
CD
C
00
01
11
10
B
A
D
1
0
0
1
0
1
1
0
0
1
1
0
0
1
1
00
Figure 2.21. Octad:
X = B
– duad of adjacent 1s:
the variable that is both complemented and non-
complemented can be eliminated (see Figures 2.15–2.17);
– quad of adjacent 1s:
two variables that are both complemented and non-
complemented can be eliminated (see Figures 2.18–2.20);
– octad of adjacent 1s: three variables that are both complemented and non-
complemented can be eliminated (see Figures 2.21–2.24).
Only those variables that hold the same logic state in all the cells of a group appear
in the simpliﬁed expression.
NOTE 2.2.– In the case of several possibilities for grouping the cells of a Karnaugh
map, the minimization procedure can yield more than one logic expression.

Logic Gates
69
D
01
11
10
1
1
1
1
0
0
0
0
0
0
0
0
1
1
1
1
AB
CD
C
00
01
11
10
B
A
00
Figure 2.22. Octad:
X = C
D
01
11
10
0
1
1
0
1
0
0
1
1
0
0
1
1
0
0
1
AB
CD
C
00
01
11
10
B
A
00
Figure 2.23. Octad:
X = B
The minterms that are not necessary for the desired application may be used to
improve the simpliﬁcation of the logic circuit. They are considered as don’t care terms.
EXAMPLE 2.3.– Simplify the following expressions:
1) X(A, B, C) = A · B · C + B · C + A · B.
2) X(A, B, C) = A · B · C + A · B · C + A · B · C + A · B · C. We shall suppose
that the input condition A · B · C does not affect the logic level of the function X (do
not care condition).

70
Digital Electronics 1
3) X(A, B, C, D) = A · B · C · D + A · B · C · D + A · B · C · D + A · B · C · D
+A · B · C · D + A · B · C · D + A · B · C · D + A · B · C · D.
4) X(A, B, C, D) = A · B · C · D + A · B · C · D + A · B · C · D + A · B · C · D
+A·B ·C ·D+A·B ·C ·D+A·B ·C ·D
5) X(A, B, C, D) = A · B · C · D + A · B · C · D + A · B · C · D + A · B · C · D
+A·B ·C ·D+A·B ·C ·D+A·B ·C ·D+A·B ·C ·D
D
01
11
10
1
1
1
1
0
0
0
0
1
1
1
1
0
0
0
0
AB
CD
C
00
01
11
10
B
A
00
Figure 2.24. Octad:
X = D
Using Karnaugh maps represented in Figures 2.25–2.30, different solutions can be
obtained.
C
1
0
0
1
1
1
0
1
AB
C
00
01
11
10
A
0
B
1
Figure 2.25. Example 2.1(1):
X = A + B · C

Logic Gates
71
C
0
1
1
1
1
0
0
x
AB
C
00
01
11
10
A
0
B
1
Figure 2.26. Example 2.1(2):
X = B + A · C
D
01
11
10
0
1
0
0
0
1
0
0
0
1
1
1
1
1
0
1
AB
CD
C
00
01
11
10
B
A
00
Figure 2.27. Example 2.1(3) (case 1):
X = A · C · D + A · B · C+ A · B · C + A · C · D
1
01
11
10
AB
CD
C
00
01
11
10
B
A
D
0
1
0
0
0
1
0
0
0
1
1
1
1
1
0
00
Figure 2.28. Example 2.1(3) (case 2):
X = A · B · D + B · C · D+ B · C · D + A · B · D

72
Digital Electronics 1
D
01
11
10
1
0
0
1
1
1
0
0
0
1
0
0
0
1
1
0
AB
CD
C
00
01
11
10
B
A
00
Figure 2.29. Example 2.1(4):
X = A · B + B · C + A · C · D
D
01
11
10
0
0
0
1
0
1
1
1
0
1
0
0
1
1
1
0
AB
CD
C
00
01
11
10
B
A
00
Figure 2.30. Example 2.1(5):
X = A · B · C + A · C · D + A · B · C + A · C · D
It should be noted that some logic functions can have many minimal expressions.
EXAMPLE 2.4.– Simplify the logic function F in the two following cases:
a) F(A, B, C) =  m(1, 3, 4, 7);
b) F(A, B, C) =  m(1, 3, 4, 7) + x(2, 5), where the don’t care terms are
represented by x.

Logic Gates
73
The minimal expressions of the function F may be obtained from the Karnaugh
maps represented in Figures 2.31 and 2.32.
C
0
0
1
0
1
1
1
0
AB
C
00
01
11
10
A
0
B
1
Figure 2.31. Example 2.2(a):
F = A · B · C + A · C + B · C
C
x
0
1
0
1
1
1
x
AB
C
00
01
11
10
A
0
B
1
Figure 2.32. Example 2.2(b):
F = A · B + C
It should be noted that a don’t care term is taken into account only if it can
contribute to the simpliﬁcation of the logic function.
2.6.3. Simpliﬁcation of logic functions with multiple outputs
The simpliﬁcation of logic functions with multiple outputs can be carried out in
four steps:
1) Write the functions to be simpliﬁed in the sum of products;

74
Digital Electronics 1
2) The minterms being represented by m and the don’t care terms by x, form the
products of sums in a systematic manner in accordance with the following rules of the
AND operation:
mi · mi = mi
mi · mj = 0 (i ̸= j)
mi · xi = mi
xi · xi = xi
mi · xj = xi · xj = 0 (i ̸= j);
3) Draw up a table containing the terms common to different functions;
4) Based on the Karnaugh map for each function, group the common terms and
then simplify the remaining terms.
However, when a group of common terms is part of a larger group of 2n (n =
1, 2, 3) terms, this group is only selected if it yields the simplest logic expression.
EXAMPLE 2.5.– Propose a circuit that implements the following circuit:
F(A, B, C, D) =

m(0, 2, 3, 4, 6, 7, 10, 11)
G(A, B, C, D) =

m(0, 4, 8, 9, 10, 11, 12, 13)
Taking into account the common terms (see the Karnaugh maps shown in
Figures 2.33 and 2.34), we can obtain the circuit in Figure 2.35 that consists of six
logic gates with a total of 16 inputs.
By independently simplifying the two functions, we arrive at:
F(A, B, C, D) = A · C + A · D + B · C
G(A, B, C, D) = A · C + C · D + A · B
In this case, eight logic gates with a total of 18 inputs are needed for the
implementation of the functions F and G.
2.6.4. Factorization of logic functions
To reduce hardware implementation costs, it is often necessary to ﬁnd terms
common to several functions.

Logic Gates
75
D
01
11
10
1
0
1
0
1
1
0
1
1
1
0
1
0
0
0
0
AB
CD
C
00
01
11
10
B
A
00
Figure 2.33. Function F
F = A · C + A · B · C + A · C · D
D
01
11
10
1
1
1
1
0
0
0
1
0
0
0
1
0
0
1
1
AB
CD
C
00
01
11
10
B
A
00
Figure 2.34. Function G
G = A · C + A · B · C + A · C · D
Factorize (or decompose) the following Boolean expressions to yield the term C +
D:
F(A, B, C, D) = A · C + A · D + B · C · D
G(A, B, C, D) = A · B · C + A · B · D + A · C · D + B · C · D

76
Digital Electronics 1
C
B
A
D
G
F
Figure 2.35. Logic circuits for the implementation of F and G
The factorization (or the decomposition) of functions F and G can be carried out
as follows:
F = A · C + A · D + B · C · D
[2.26]
= A(C + D) + B · C · D
= A(C + D) + B(C + D)
[2.27]
and
G = A · B · C + A · B · D + A · C · D + B · C · D
[2.28]
= A · B(C + D) + A(C + D) + B(C + D)
= A · B(C + D) + AB(C + D)
[2.29]
2.7. Multi-level logic circuit implementation
Combinational logic circuits are generally designed using two-level logic
networks. They arise directly from the sum-of-product expressions and are
characterized by a high speed of operation (or fast response time) if the number of
inputs is such that the load limit for each logic gate is not exceeded (or if the input
fan-in speciﬁcation is satisﬁed).
The design of multi-level circuits is based on the factorization and decomposition
of logic functions which are taken in their minimal form. In practice, the use of
supplementary levels in a circuit helps to reduce the maximum number of inputs for
logic gates to the value permitted by the manufacturing technology.
Conventionally, input inverters are not considered when determining the number
of circuit levels as they may be affected by the type of logic circuit (active high or
active low) to be chosen.

Logic Gates
77
2.7.1. Examples
The ﬁve-variable function, F(A, B, C, D, E), is to be implemented. It is expressed
in the sum-of-product form as:
F(A, B, C, D, E) = A · C + A · D + B · C + B · D + E
[2.30]
This function can be implemented using four 2-input AND gates or one 5-input
OR gate as shown in Figure 2.36(a).
F
A
B
A
D
C
B
E
F
(b)
(a)
C
D
E
Figure 2.36. Logic circuit for the implementation of F
Upon factorizing, we can also arrive at:
F(A, B, C, D, E) = (A + B)(C + D) + E
[2.31]
As a result, the function F(A, B, C, D, E) can be implemented using three 2-input
OR gates and one 2-input AND gate, as illustrated in Figure 2.36(b). This approach,
in addition to reducing the number of logic gates, makes it possible to improve the
fan-in of logic gates.
In the case of a logic function of four variables, G(A, B, C, D), given in the sum-
of-products form by:
G(A, B, C, D) = A · C + A · D + B · C + B · D + A · B · C · D
[2.32]
the implementation, as illustrated in Figure 2.37(a), requires four 2-input AND gates,
one 4-input AND gate and one 5-input OR gate.

78
Digital Electronics 1
G
A
A
C
D
C
B
D
G
(b)
(c)
(a)
G
B
C
D
A
B
Figure 2.37. Logic circuit for the implementation of G
The implementation as shown in Figure 2.37(b) is based on the factorization of the
function G(A, B, C, D) as follows:
G(A, B, C, D) = (A + B)(C + D) + (A + B)(C + D)
= (A · B)(C + D) + (A · B)(C + D)
[2.33]
It has three levels and uses only 2-input logic gates (three OR gates and two AND
gates).
We observe that the function G(A, B, C, D) can also be written in the following
manner:
G(A, B, C, D) = A · B ⊕(C + D)
[2.34]
which yields another logic circuit, as shown in Figure 2.37(c), and which is composed
of one OR gate, one AND gate and one XOR gate.
2.7.2. NAND gate logic circuit
Based on DeMorgan’s theorems, a logic circuit consisting of AND and OR gates
can be transformed to a circuit made up solely of NAND gates (1) by replacing the
AND gates with NAND gates, adding inverters at the OR gate inputs and by inserting
inverters wherever necessary to correct for the effect of non-compensated inversions,

Logic Gates
79
and, lastly, (2) by replacing all OR gates with input inverters to NAND gates (see
Figure 2.38).
X
B
X
B
A
A
Figure 2.38. Equivalent circuits for the NAND gate
Consider the following logic function of four variables A, B, C and D:
F(A, B, C, D) = (A + B)(C · D + C · D)
[2.35]
This function may be implemented by using AND and OR gates, as illustrated in
Figure 2.39(a). By applying the transformations (1) and (2), we can obtain the circuit
shown in Figure 2.39(b) and the NAND gate based circuit shown in Figure 2.39(c),
respectively.
F
A
B
A
B
F
A
B
C
D
C
D
(a)
C
D
C
D
F
(b)
C
D
C
D
(c)
Figure 2.39. Implementation of the function F: a) circuit using AND and
OR gates; b) equivalent circuit; c) circuit based on NAND gates

80
Digital Electronics 1
Let us consider another function G of four variables A, B, C and D, deﬁned by:
G = A · B · C + A · D + B · D + C · D
[2.36]
To implement this function using only 2-input NAND gates, we ﬁrst observe that:
G = (A + B · C)(B · C + D)
[2.37]
and subsequently derive the circuit built up of AND and OR gates, as illustrated in
Figure 2.40(a). Using transformations based on DeMorgan’s theorems, we can obtain
the equivalent circuit in Figure 2.40(b), and then the NAND gate based circuit
represented in Figure 2.40(c).
(a)
C
G
A
(b)
B
D
C
A
G
C
D
G
(c)
B
D
A
B
Figure 2.40. Implementation of the function G: a) circuit using AND
and OR gates; b) equivalent circuit; c) NAND gate based circuit
NOTE 2.3.– Each sum-of-products logic expression corresponds to a circuit using
AND and OR gates, or a NAND gate based circuit.
2.7.3. NOR gate based logic circuit
A logic circuit built up of AND and OR logic gates can be transformed in
accordance with DeMorgan’s theorems to a circuit consisting solely of NOR gates:
(1) by replacing the OR gates by NOR gates; by adding input inverters to the AND
gates and by inserting inverters wherever necessary to correct for the effect of
non-compensated inversions; (2) by replacing all AND gates that have input inverters
with NOR gates (see Figure 2.41).

Logic Gates
81
Y
B
Y
A
B
A
Figure 2.41. Equivalent circuits for the NOR gate
Consider the following logic function with four variables:
F(A, B, C, D) = (A + B)(C · D + C · D)
[2.38]
The implementation of this function using AND and OR gates is illustrated in
Figure 2.42(a). For the NOR gate based implementation, the ﬁrst step of the required
transformation results in the circuit shown in Figure 2.42(b) that is then converted to
the NOR gate based circuit as shown in Figure 2.42(c).
F
A
B
A
B
A
B
C
D
C
D
F
C
D
C
D
(a)
(b)
C
D
C
D
F
(c)
Figure 2.42. Implementation of the function F: a) circuit using AND and
OR gates; b) equivalent circuit; c) NOR gate based circuit

82
Digital Electronics 1
Use only two-input NOR gates to implement the following function of four
variables:
G = A · B · C + A · D + B · D + C · D
[2.39]
Because:
G = (A + B · C)(B · C + D)
[2.40]
we can derive the circuit shown in Figure 2.43(a) or the equivalent circuit shown in
Figure 2.43(b). The NOR-gate based circuit corresponding to the function G is
illustrated in Figure 2.43(c).
G
C
D
B
B
D
D
A
B
G
(a)
(c)
(b)
C
G
C
A
A
Figure 2.43. Implementation of the function G: a) circuit using AND and
OR gates; b) equivalent circuits; c) NOR gate based circuit
NOTE 2.4.– Each product-of-sums logic expression corresponds to a circuit consisting
of OR and AND gates or to a NOR gate based circuit.
2.7.4. Representation based on XOR and AND operators
The logic circuit for certain functions may be difﬁcult to optimize when they are
represented in the sum-of-products form. Using a representation based on XOR (or
XNOR) gates often offers the advantage of making it possible to reduce the number
of logic gates and the complexity of interconnection lines.
In addition to being a simpliﬁcation method for logic functions, Karnaugh maps
are also useful in identifying terms that can be more easily implemented using XOR

Logic Gates
83
logic gates. In a Karnaugh map, groups of terms, that are symmetrical, or mirror
images or duplicates of each other may be represented in XOR (or Reed–Muller)
form. The following ﬁgures give some examples.
For the three-variable functions whose Karnaugh maps are represented in
Figures 2.44 and 2.45, we have, respectively:
Fa = A · B · C + A · B · C + A · B · C + A · B · C
[2.41]
= A(B ⊕C) + A(B ⊕C)
= A ⊕B ⊕C
[2.42]
and
Fb = A · B · C + A · B · C + A · B · C + A · B · C
[2.43]
= A(B ⊕C) + A(B ⊕C)
= A ⊕B ⊕C
[2.44]
1
1
1
1
AB
C
00
01
11
10
A
0
B
1
C
Figure 2.44. Representation of Fa = A ⊕B ⊕C
1
AB
C
00
01
11
10
A
0
B
1
C
1
1
1
Figure 2.45. Representation of Fb = A ⊕B ⊕C

84
Digital Electronics 1
In the case of the four-variable functions, deﬁned by the Karnaugh maps shown in
Figures 2.46–2.49, we have, respectively:
Fc = A · C + A · C = A ⊕C
[2.45]
Fd = A · B + A · B = A ⊕B
[2.46]
Fe = B · D + B · D = B ⊕D
[2.47]
and
Ff = B · C + B · C = B ⊕C
[2.48]
1
AB
CD
C
00
01
11
10
B
A
D
00
01
11
10
1
1
1
1
1
1
1
Figure 2.46. Representation of Fc = A ⊕C
Considering the Karnaugh map depicted in Figure 2.50, the equation for the logic
function is written as follows:
Fg = A · C + C · D + A · C · D
[2.49]
= C(A · D) + C(A · D)
= C ⊕A · D
[2.50]

Logic Gates
85
1
AB
CD
C
00
01
11
10
B
A
D
00
01
11
10
1
1
1
1
1
1
1
Figure 2.47. Representation of Fd = A ⊕B
1
AB
CD
C
00
01
11
10
B
A
D
00
01
11
10
1
1
1
1
1
1
1
Figure 2.48. Representation of Fe = B ⊕D
We can determine the equation for the following logic function based on the
Karnaugh map in Figure 2.51:
Fh = A · B · C · D + A · B · C · D + A · B · C · D + A · B · C · D
[2.51]
= A[(B · C + B · C)D + (B · C + B · C)D]
= A[(B ⊕C)D + (B ⊕C)D]
= A(B ⊕C ⊕D)
[2.52]

86
Digital Electronics 1
1
1
1
1
AB
CD
C
00
01
11
10
B
A
D
00
01
11
10
1
1
1
1
Figure 2.49. Representation of Ff = B ⊕C
1
AB
CD
C
00
01
11
10
B
A
D
00
01
11
10
1
1
1
1
1
1
1
Figure 2.50. Representation of Fg = C ⊕A · D
For the Karnaugh map shown in Figure 2.52, the equation of the logic function can
be obtained as follows:
Fi = A · B · C · D + A · B · C · D + A · B · C · D + A · B · C · D
[2.53]
= (A · C + A · C)(B · D + B · D)
= (A ⊕C)(B ⊕D)
[2.54]

Logic Gates
87
1
AB
CD
C
00
01
11
10
B
A
D
00
01
11
10
1
1
1
Figure 2.51. Representation of Fh = A(B ⊕C ⊕D)
1
AB
CD
C
00
01
11
10
B
A
D
00
01
11
10
1
1
1
Figure 2.52. Representation of Fi = (A ⊕C)(B ⊕D)
The equation for the logic function represented by the Karnaugh map shown in
Figure 2.53 is given by:
Fj = A · B · C · D + A · B · C · D + A · B · C · D + A · B · C · D
[2.55]
= (A · D + A · D)(B · C + B · C)
= (A ⊕D)(B ⊕C)
[2.56]

88
Digital Electronics 1
1
AB
CD
C
00
01
11
10
B
A
D
00
01
11
10
1
1
1
Figure 2.53. Representation of Fj = (A ⊕D)(B ⊕C)
1
AB
CD
C
00
01
11
10
B
A
D
00
01
11
10
1
1
1
1
1
1
1
Figure 2.54. Representation of Fk = A ⊕B ⊕C
The Karnaugh map shown in Figure 2.54 corresponds to the logic function whose
equation is written as follows:
Fk = A · B · C + A · B · C + A · B · C + A · B · C
[2.57]
= A(B · C + B · C) + A(B · C + B · C)
= A(B ⊕C) + A(B ⊕C)
= A ⊕B ⊕C
[2.58]

Logic Gates
89
1
AB
CD
C
00
01
11
10
B
A
D
00
01
11
10
1
1
1
1
1
1
1
Figure 2.55. Representation of Fl = A ⊕B ⊕C ⊕D
Based on the Karnaugh map in Figure 2.54, we have:
Fl = A · B · C · D + A · B · C · D + A · B · C · D + A · B · C · D
+ A · B · C · D + A · B · C · D + A · B · C · D + A · B · C · D
[2.59]
= (A · B + A · B)(C · D + C · D) + (A · B + A · B)(C · D + C · D)
= (A ⊕B)(C ⊕D) + (A ⊕B)(C ⊕D)
= A ⊕B ⊕C ⊕D
[2.60]
2.8. Practical considerations
In practice, the operation of a logic circuit depends on the electric characteristics
of the logic gates.
In an ideal case, the logic levels 0 and 1 are represented by ﬁxed voltages (for
example ground and supply voltage) for both the input and the output. In reality, they
correspond to voltages that can vary within a certain range of values.
When logic gates are combined in order to construct a logic circuit, we can connect
two inputs together or one input to one output. But in no case can we connect two
different outputs as they can produce different logic states.
A timing diagram is a graphical representation of how variables in a system evolve
over time. In the case of logic circuits, time is represented on the horizontal axis and
the logic levels (low or high) of the variables are represented on the vertical axis. In
addition to some electric characteristics, the timing diagram provides information that

90
Digital Electronics 1
is useful in constructing a truth table. It also shows the rise time and the fall time for
signals, and the propagation delay, that is the time that passes between a change in
level of the input and the corresponding change in the output.
2.8.1. Timing diagram for a logic circuit
A timing diagram is a graphical representation of the temporal evolution of a logic
signal.
Let us consider the logic circuit in Figure 2.56(a). The logic equation for the output
signal is of the following form:
F = A · C + B · C
[2.61]
The timing diagram in an ideal case is illustrated in Figure 2.56(b). However, it
may be affected by propagation delays that depend on the response times of the
different logic gates.
F
(a)
A
C
B
C
C
BC
AC
F
(c)
B
A
C
C
BC
AC
F
B
A
(b)
τ
τ
2τ
Figure 2.56. a) Logic circuit; b) timing diagram in an ideal case; c)
timing diagram illustrating the effect of a static hazard
In general, a circuit that is sensitive to parasitic phenomena due to signal
propagation along several paths may be affected by a hazard. There is a distinction
made between static and dynamic hazards.
2.8.2. Static hazard
A static hazard is produced when a change in the level of an input variable, which
should normally not bring about a modiﬁcation of the output, translates into the
generation of a transient signal with an erroneous logic level.

Logic Gates
91
The logic circuit shown in Figure 2.56(a) contains two concurrent paths with
different propagation delays. Thus, when the input signal C changes its logic level,
the inputs C and B of one of the AND gates do not change simultaneously. This
translates into a static hazard that can be seen in the timing diagram shown in
Figure 2.56(c).
To suppress the effect of the static hazard on the operation of the two-level circuit
represented in Figure 2.57(a), a product of terms must be introduced between the states
A B C = 1 1 1 and A B C = 1 1 0 (see Figure 2.57(b)). This helps to prevent the
transition of the input F toward 0, as shown in Figure 2.57(c).
(b)
(a)
A
C
B
F
A
C
B
F
C
C
BC
AC
B
A
τ
τ
2τ
F
AB
(c)
Figure 2.57. a) Circuit with static hazard; b) logic circuit functioning
without static hazard; c) timing diagram
The minimal form of the logic equation for the output F is represented by the
Karnaugh map in Figure 2.58, and the redundant term that must be added to eliminate
the static hazard appears on the Karnaugh map in Figure 2.59.
C
0
1
1
0
0
1
1
0
AB
C
00
01
11
10
A
0
B
1
Figure 2.58. Circuit with hazard
F = A · C + B · C

92
Digital Electronics 1
C
0
1
1
0
0
1
1
0
AB
C
00
01
11
10
A
0
B
1
Figure 2.59. Circuit without hazard
F = A · C + B · C + A · B
In practice, the method used to eliminate static hazards that can affect the operation
of a two-level logic circuit consists of identifying the terms corresponding to adjacent
loops in the Karnaugh map and adding the appropriate redundant terms to the minimal
representation of the output function.
2.8.3. Dynamic hazard
A multi-level logic circuit exhibits dynamic hazards if the transition of an input
signal, which is supposed to produce a single change in the logic level of the output,
changes the logic level of the output as desired only after a transient regime with at
least two changes in logic level.
The logic circuit shown in Figure 2.60(a) is supposed to have two concurrent paths
with asymmetrical propagation delays. The circuit operation may be affected by a
dynamic hazard, as shown in Figure 2.60(b) for the output G. It must be noted that
this circuit also presents a static hazard (output F). In this case, adding the logic gate
that implements the redundant term A · B in order to eliminate the static hazard, as
shown in Figure 2.61(a), also contributes in removing the effect of the dynamic hazard,
as shown in Figure 2.61(b).
In general, a multi-level logic circuit cannot present static hazards but it may be
affected by dynamic hazards. Therefore, for the circuit to operate without hazards, it
is preferable to implement logic functions as two-level circuits and then to detect and
eliminate static hazards by adding the appropriate redundant terms.

Logic Gates
93
F
(b)
CΔ
CΔ
F
C
3τ
(a)
C
B
A
τ
BC
AC
τ
2τ
G
G
A
C
B
Figure 2.60. a) Logic circuit and b) timing diagram
illustrating the effect of a dynamic hazard
2.9. Demonstration of some Boolean algebra identities
DEMONSTRATION 2.1.– Show that X+X·Y = X. Using Boolean algebra theorems,
we can write:
X + X · Y = X · 1 + X · Y
= X(1 + Y )
= X(1)
= X
[2.62]
DEMONSTRATION 2.2.– Show that X(X + Y ) = X. In this case, we have:
X(X + Y ) = X · X + X · Y
= X + X · Y
= X(1 + Y )
= X
[2.63]

94
Digital Electronics 1
F
Δ
A
C
B
AB
BC
(b)
G
CΔ
(a)
C
G
F
3τ
C
B
A
τ
AC
τ
2τ
C
Figure 2.61. a) Logic circuit operating without
hazard and b) timing diagram
DEMONSTRATION 2.3.– Show that X · Y + X · Y = X. We have:
X · Y + X · Y = X(Y + Y )
= X
[2.64]
DEMONSTRATION 2.4.– Show that (X + Y )(X + Y ) = X. We have:
(X + Y )(X + Y ) = X · X + X · Y + X · Y + Y · Y
= X + X · Y + X · Y
= X(1 + Y + Y )
= X
[2.65]

Logic Gates
95
DEMONSTRATION 2.5.– Show that X + X · Y = X + Y . We have:
X + X · Y = (X + X · Y )1 + X · Y
= X + X · Y + X · Y
= X + Y (X + X)
= X + Y (1)
= X + Y
[2.66]
DEMONSTRATION 2.6.– Show that X(X + Y ) = X · Y . We have:
X(X + Y ) = X · X + X · Y
= 0 + X · Y
= X · Y
[2.67]
DEMONSTRATION 2.7.– Show that X · Y + X · Z = (X + Z)(X + Y ). We have:
X · Y + X · Z = X · Y (1 + Z) + X · Z(1 + Y ) + X · X
= X · Y + Y · Z(X + X) + X · Z + X · X
= (X + Z)Y + (X + Z)X
= (X + Z)(X + Y )
[2.68]
DEMONSTRATION 2.8.– Show that (X + Y )(X + Z) = X · Z + X · Y . We have:
(X + Y )(X + Z) = X · X + X · Z + X · Y + Y · Z
= X · Z + X · Y + Y · Z
= X · Z + X · Y + (X + X)Y · Z
= X · Z(1 + Y ) + X · Y (1 + Z)
= X · Z + X · Y
[2.69]
DEMONSTRATION 2.9.– Show that X · Y + X · Z + Y · Z = X · Y + X · Z. We
have:
X · Y + X · Z + Y · Z = X · Y + X · Z + Y · Z(X + X)
= X · Y + X · Z + X · Y · Z + X · Y · Z
= X · Y (1 + Z) + X · Z(1 + Y )
= X · Y (1) + X · Z(1)
= X · Y + X · Z
[2.70]

96
Digital Electronics 1
DEMONSTRATION 2.10.– Show that (X +Y )(X +Z)(Y +Z) = (X +Y )(X +Z).
We have:
(X + Y )(X + Z)(Y + Z) = (X · Z + X · Y )(Y + Z)
according to [8]
= X · Y · Z + X · Y + X · Z + X · Y · Z
= X · Z(1 + Y ) + X · Y (1 + Z)
= X · Z + X · Y
= (X + Y )(X + Z)
according to [7]
[2.71]
DEMONSTRATION 2.11.– Show that (X · Y ) ⊕(X · Z) = X(Y ⊕Z). We have:
(X · Y ) ⊕(X · Z) = (X · Y )(X · Z) + (X · Y )(X · Z)
= (X · Y )(X + Z) + (X + Y )(X · Z)
= X · Y · Z + X · Y · Z
= X(Y · Z + Y · Z)
= X(Y ⊕Z)
[2.72]
DEMONSTRATION 2.12.– Show that X(X ⊕Y ) = X · Y . We have:
X(X ⊕Y ) = X(X · Y + X · Y )
= X · Y
[2.73]
DEMONSTRATION 2.13.– Show that (X ·Y )⊕(X ·Z)+Y ·Z = (X ·Y )⊕(X ·Z).
We have:
(X · Y ) ⊕(X · Z) + Y · Z = (X · Y )(X · Z) + (X · Y )(X · Z) + Y · Z
= X · Y (X + Z) + (X + Y )X · Z + Y · Z
= X · Y · Z + X · Z(1 + Z) + Y · Z
= X · Y · Z + X · Z + (X + X)Y · Z
= X · Y (Z + Z) + X · Z(1 + Y )
= X · Y + X · Z
= X · Y (1 + Z) + X · Z(1 + Y )
= X · Y + X · Y · Z + X · Z + X · Y · Z

Logic Gates
97
= X · X · Y + X · Y · Z + X · X · Z + X · Y · Z
= X · Y (X + Z) + (X + Y )X · Z
= X · Y (X · Z) + (X · Y )X · Z
= (X · Y ) ⊕(X · Z)
[2.74]
2.10. Exercises
EXERCISE 2.1.– Function of n variables.
How many different logic functions can we implement using n input variables?
EXERCISE 2.2.– Analysis of a logic circuit.
Construct the truth table for the circuit shown in Figure 2.62. Using a minimum
number of NAND gates, propose a circuit to implement F.
Y
X
F
Z
Figure 2.62. Logic circuit
EXERCISE 2.3.– Simpliﬁcation of logic functions.
Simplify the following logic expressions:
a) X + Y + X · Y + (X + Y ) · X · Y
b) X · Y · Z + X · Y · Z + X · Y · Z + X · Y · Z
c) X · Y · X · Z
d) (X + Y )(X + Z)(Y + Z)
e) (W + X + Y · Z)(W + X)(X + Y )
f) W · X · Z + X · Y · Z + W · X · Y + X · Y · Z + W · Y · Z
g) W · X · Z + W · Z + X · Y · Z + W · X · Y
h) (X + Y + Z)(X + Y + Z)(X + Y + Z)

98
Digital Electronics 1
EXERCISE 2.4.– Equivalent logic functions.
Verify the following equalities:
a) A · B · C + A · C + B · C = C ⊕(A · B)
b) A ⊕B ⊕(A + B) + A · B = A ⊙B
c) (A + B) ⊙(A + C) + A = A + B
d) (A ⊙B) ⊕(A · B) + A · B = A + B
e) A · B · C + A · C · D + A · B · C · D + A · B · C · D + A · C · D + A · B · C =
A · C ⊕A · C ⊕B · D
f) A · B · D + B · C · D + A · B · C + B · C · D + A · C · D = A · B + C · D
EXERCISE 2.5.– Simpliﬁcation of the functions using the Karnaugh map method.
Using the Karnaugh map method, simplify each of the following logic functions:
E(A, B, C, D) =

mm(0, 2, 3, 4, 5, 8, 11, 12, 13, 14, 15)
[2.75]
F(A, B, C, D) =

m(0, 1, 3, 4, 6, 7, 8, 9, 11, 12, 13, 14, 15)
[2.76]
G(A, B, C, D) =

m(0, 2, 4, 5, 10, 12, 15) +

x(8, 14)
[2.77]
H(A, B, C, D) =

mm(1, 3, 6, 8, 11, 14) +

x(2, 5, 12, 13, 15)
[2.78]
EXERCISE 2.6.– Analysis of the circuit with NAND/NOR gates.
B
(b)
G
F
(a)
A
C
A
A
C
B
A
A
A
A
A
Figure 2.63. a) Circuit with NAND gates and b) circuit with NOR gates
Determine the logic function F
implemented by the circuit shown in
Figure 2.63(a). Determine the logic function G implemented by the circuit shown in
Figure 2.63(b). Verify that F = G.

Logic Gates
99
EXERCISE 2.7.– Canonical forms of a logic function.
Let us consider the logic functions represented in Figure 2.64.
D
A
B
C
D
A
B
C
G
F
(a)
(b)
Figure 2.64. a) Circuit with NOR gates and b) circuit with NAND gates
Determine the logic expressions for the outputs F and G.
Express the logic function F as a sum of products.
Give the product-of-sums form of G.
EXERCISE 2.8.– Simpliﬁcation of logic circuits.
Simplify each of the logic circuits shown in Figure 2.65.
EXERCISE 2.9.– Implementation of the function H.
Let us consider the three-variable logic function deﬁned as follows:
H(A, B, C) = A · B + A · B + B · C
[2.79]
Assuming the input variables are A, B and C, propose a logic circuit using only
2-input NAND gates to implement the function H.
EXERCISE 2.10.– Implementation of the logic function Y .
Using the minimum number of logic gates (NOT, AND, OR) to realize the
following logic function:
Y = (A · B) ⊕(B · C)
[2.80]

100
Digital Electronics 1
L
C
A
B
A
C
A
B
C
A
B
C
D
(a)
(b)
(d)
(f)
P
Q
(c)
(e)
A
B
C
H
B
C
D
A
G
K
B
0
Figure 2.65. Logic circuits
EXERCISE 2.11.– Implementation of circuits with NAND/NOR gates.
Let us consider the following logic functions:
P(A, B, C, D) = A · B + A · C · D
[2.81]
andQ(A, B, C, D) = (A + B + C)(A + D)
[2.82]
Assuming that the input variables A, B, C, and D, as well as their complements,
are available, propose a logic circuit based on 2-input NAND gates and a logic circuit
based on 2-input NOR gates for each of these functions.

Logic Gates
101
EXERCISE 2.12.– Control circuit for a switcher.
We wish to switch in four directions packages identiﬁed by an eight-bit binary
code I7 I6 I5 I4 I3 I2 I1 I0, where I7 is the most signiﬁcant bit. The signal D0 is set
at 1 if no direction is chosen and the switching, based on the code of each packet, is
carried out as follows:
D1 = 1 if 32 ≤N ≤63,
D2 = 1 if 64 ≤N ≤127,
D3 = 1 if 128 ≤N ≤159,
D4 = 1 if 192 ≤N ≤255,
The number N being the decimal number corresponding to the code
I7 I6 I5 I4 I3 I2 I1 I0.
a) −Determine the Boolean expression for the logic function of selection (D1,
D2, D3 and D4) for each direction.
−Deduce the Boolean expression for the function D0.
b) Implement these functions using only inverters and NAND gates with at most
three inputs.
2.11. Solutions
SOLUTION 2.1.– Function with n variables.
With n variables, the truth table has 2n columns and we can choose any number
of 2n bits for each column. There are, thus, 22n different functions with n variables.
n 1 2
3
4
Number of functions 4 16 256 65, 536
SOLUTION 2.2.– Analysis of a logic circuit.
By analyzing the logic circuit, the equation for the output F can be obtained as
follows:
F = X · X · Y · X · Y · Y · Z · X · Y · Y · Z
= (Y + Y · X)Z(1 + X + X · Y ) = (X + Y )Z = X · Z + Y · Z

102
Digital Electronics 1
X
Y
Z
F
0
0
0
0
0
0
1
0
0
1
0
0
0
1
1
1
1
0
0
0
1
0
1
1
1
1
0
0
1
1
1
1
Table 2.14. Truth table
Y
Z
X
X
Y
Z
F
F
Figure 2.66. Simpliﬁed circuits
Table 2.14 shows the truth table constructed based on the logic equation for the
output F.
The circuits obtained upon simpliﬁcation are represented in Figure 2.66.
SOLUTION 2.3.– Simpliﬁcation of logic expressions.
The simpliﬁcations are carried out by using Boolean algebra theorems.
a) X + Y + X · Y + (X + Y ) · X · Y = X + Y + Y = 1
b) X · Y · Z + X · Y · Z + X · Y · Z + X · Y · Z = X · Y + X · Z
c) X · Y · X · Z = X · Y + X · Z
d) (X + Y )(X + Z)(Y + Z) = X · Y · Z + X · Y · Z
e) (W + X + Y · Z)(W + X)(X + Y ) = X · Y + W · Y · Z

Logic Gates
103
f)
W · X · Z + X · Y · Z + W · X · Y + X · Y · Z
+ W · Y · Z = W · X(Y + Z) + Y · Z
= W · X(Y + Z) + Y + Z
= W · X + Y · Z
g)
W · X · Z + W · Z + X · Y · Z + W · X · Y = X · Y + X · Z + W · Z
h)
(X + Y + Z)(X + Y + Z)(X + Y + Z) = (Y + Z)(X + Y + Z)
because
(A + B)(A + B) = A
= Z(X + Y ) + Y · Z
because
(A + B)(A + C) = A · C + A · C
= X · Z + Y
SOLUTION 2.4.– Equivalent logic functions.
Veriﬁcation of the following equalities:
a) A · B · C + A · C + B · C = A · B · C + (A · B)C
= C ⊕(A · B)
b) A ⊕B ⊕(A + B) + A · B = A ⊕[B ⊕(A · B)] + A · B
= A ⊕[B(1 ⊕A)] + A · B
= A ⊕(A · B) + A · B
= A · B + A · B
= A ⊙B

104
Digital Electronics 1
c) (A + B) ⊙(A + C) + A = (A + B)(A + C) + (A · B)(A · C) + A
= A · B + A · C + B · C + A
= A(1 + C) + B(1 + C)
because
A + A · B = A + B
= A + B
d) (A ⊙B) ⊕(A · B) + A · B = (A ⊙B)(A · B) + (A ⊕B)(A · B) + A · B
= (A ⊙B)(A · B) + A · B + A · B
= A ⊙B + A · B + A · B
because
(A ⊙B)(A · B) + A · B = A ⊙B + A · B
= A · B + A · B + A(B + B)
= A · B + A · B + A
= A · B + A + B
= A + B
e) A · B · C + A · C · D + A · B · C · D + A · B · C · D + A · C · D
+ A · B · C
= A · C(B + D) + (A · C + A · C)B · D + A · C(B + D)
= (A · C + A · C)B · D + (A · C + A · C)(B + D)
= (A · C ⊕A · C)B · D + (A · C ⊕A · C)(B · D)
because
(A · C)(A · C) = 0
and
(A · C)(A · C) = 0
= (A · C ⊕A · C)B · D + (A · C ⊕A · C)(B · D)
= A · C ⊕A · C ⊕B · D

Logic Gates
105
f) A · B · D + B · C · D + A · B · C + B · C · D + A · C · D
= A · B · D + C · D(B + B + A) + A · B · C
= A · B · D + C · D + A · B · C
= A · B(C + D) + C · D
= A · B(C + D) + C + D
= A · B + C · D
because
X + X · Y = X + Y
SOLUTION 2.5.– Simpliﬁcation of functions using the Karnaugh map method.
– Function E:
The function E(A, B, C, D) has three minimized forms that can be obtained from
the Karnaugh maps, as shown in Figure 2.67, as follows:
E(A, B, C, D) = A · B + B · C + C · D + A · B · C + A · C · D
(a)
= A · B + B · C + C · D + A · B · C + B · C · D
(b)
= A · B + B · C + C · D + A · B · D + B · C · D
(c)
D
01
11
10
00
01
11
10
00
01
11
10
(a)
(b)
(c)
x
1
0
0
0
x
1
x
1
1
0
1
x
x
0
1
AB
CD
C
00
01
11
10
B
A
D
x
1
0
0
0
x
1
x
1
1
0
1
x
x
0
1
AB
CD
C
00
01
11
10
B
A
D
x
1
0
0
0
x
1
x
1
1
0
1
x
x
0
1
AB
CD
C
00
01
11
10
B
A
00
Figure 2.67. Karnaugh maps (function E)

106
Digital Electronics 1
– Function F:
In the case of the function F(A, B, C, D), there are six possible solutions.
Figure 2.68 shows the Karnaugh maps corresponding to the different solutions. Thus:
F(A, B, C, D) = C · D + B · D + B · C + A · B
(a)
= C · D + B · D + B · C + A · C
(b)
= C · D + B · D + B · C + A · D
(c)
= B · C + B · D + C · D + A · B
(d)
= B · C + B · D + C · D + A · C
(e)
= B · C + B · D + C · D + A · D
(f)
D
01
11
10
00
01
11
10
00
01
11
10
00
01
11
10
1
1
1
1
1
1
1
1
0
1
1
0
1
0
1
1
AB
CD
C
00
01
11
10
B
A
D
1
1
1
1
1
1
1
1
0
1
1
0
1
0
1
1
AB
CD
C
00
01
11
10
B
A
D
1
1
1
1
1
1
1
1
0
1
1
0
1
0
1
1
AB
CD
C
00
01
11
10
B
A
D
00
01
11
10
00
01
11
10
1
1
1
1
1
1
1
1
0
1
1
0
1
0
1
1
(a)
(b)
(c)
(d)
(e)
(f)
1
1
1
1
1
1
1
1
0
1
1
0
1
0
1
1
AB
CD
C
00
01
11
10
B
A
D
AB
CD
C
00
01
11
10
B
A
D
1
1
1
1
1
1
1
1
0
1
1
0
1
0
1
1
AB
CD
C
00
01
11
10
B
A
00
Figure 2.68. Karnaugh maps (function F)

Logic Gates
107
– Function G:
The function G has two minimum forms corresponding to the Karnaugh maps, as
shown in Figure 2.69. We can, thus, write:
G(A, B, C, D) = A · B · C + A · B · C + B · D + C · D
(a)
= A · B · C + A · B · C + B · D + A · D
(b)
D
01
11
10
1
1
1
0
0
1
0
1
0
00
01
11
10
00
01
00
01
11
10
1
1
(b)
1
0
1
0
x
1
0
AB
CD
C
B
A
D
(a)
1
1
0
0
1
0
1
0
x
1
0
1
0
0
AB
CD
C
11
10
B
A
00
Figure 2.69. Karnaugh maps (function G)
– Function H:
As each Karnaugh map in Figure 2.70 corresponds to a minimal form, we obtain
the following three logic expressions:
H(A, B, C, D) = A · C · D + B · C · D + A · B · D + B · C · D
(a)
= A · C · D + B · C · D + A · C · D + B · C · D
(b)
= A · C · D + B · C · D + A · B · D + A · C · D
(c)
D
01
11
10
00
01
11
10
00
01
11
10
(a)
(b)
(c)
0
1
0
x
0
x
1
x
1
1
0
1
x
x
0
1
AB
CD
C
00
01
11
10
B
A
D
0
1
0
x
0
x
1
x
1
1
0
1
x
x
0
1
AB
CD
C
00
01
11
10
B
A
D
0
1
0
x
0
x
1
x
1
1
0
1
x
x
0
1
AB
CD
C
00
01
11
10
B
A
00
Figure 2.70. Karnaugh maps (function H)

108
Digital Electronics 1
SOLUTION 2.6.– Analysis of circuits with NAND/NOR gates.
For the circuit shown in Figure 2.63(a), we have:
F = A + A + B + A + A + C
[2.83]
= (A + A + B)(A + A + C)
= (A + A · B)(A + A · C)
= (A + B)(A + C)
[2.84]
= A(1 + B + C) + B · C
= A + B · C
[2.85]
For the circuit represented in Figure 2.63(b), we have:
G = A · A · B · A · A · C
[2.86]
= A · A · B + A · A · C
= A(A + B) + A(A + C)
= A(B + C)
[2.87]
It can then be veriﬁed that:
G = A(B + C)
= A + B · C
= F
[2.88]
SOLUTION 2.7.– Canonical forms of a logic function.
By analyzing each logic circuit, we can write:
F = A + C + B + A + B + C + B + C + D + C + B + D
[2.89]
= (A + C + B)(A + B + C)(B + C + D)(C + B + D)
= (A · C + B)(A + B · C)(B · C + D)(C + B · D)
= (A · B + A · B · C)(C · D + B · C · D)
= A · B · C · D + A · B · C · D
[2.90]
=

m(0, 15)
[2.91]

Logic Gates
109
and
G = A · C · B · A · B · C · B · C · D · C · B · D
[2.92]
= (A · C + B)(A + B · C)(B · C + D)(C + B · D)
= (A · B + A · B · C)(C · D + B · C · D)
= A · B · C · D + A · B · C · D
= (A + B + C + D)(A + B + C + D)
[2.93]
=

m(0, 15)
[2.94]
It must be noted that G = F.
SOLUTION 2.8.– Simpliﬁcation of logic circuits.
Figure 2.71 depicts circuits obtained upon simpliﬁcation.
Q
A
B
C
L
(d)
(a)
A
B
(c)
C
(f)
B
P
C
B
H
C
C
B
A
(b)
G
K
(e)
C
A
Figure 2.71. Logic circuits
– circuit (a):
G = A · C + A · C(A + B + C)
[2.95]
= A · C + A + B + C
= A(C + 1) + B + C
= A + B + C
[2.96]

110
Digital Electronics 1
– circuit (b):
H = (A ⊕B) ⊕(A ⊕C)
[2.97]
= (A ⊕A) ⊕(B ⊕C)
= 0 ⊕(B ⊕C)
= B ⊕C = B ⊕C
[2.98]
– circuit (c):
K = A · B · B · C(C + D)
[2.99]
= (A + B)B · C(C + D)
= A · B · C(C + D)
= A · B · C(1 + D)
= A · B · C
[2.100]
– circuit (d):
L = A · B + C + A ⊕B + A + C
[2.101]
= A · B + C + A · C + A ⊕B
= A · B + A + C + A ⊕B
= A + B + C + A ⊕B
= A(1 + B) + B(1 + A) + C
= A · B · C
[2.102]
– circuit (e):
P = A · B · B · C + A · D · B + C + B + C
[2.103]
= A · B(B + C) + A · D · B · C + B · C
= (A + A · D + 1)B · C
= B · C
[2.104]

Logic Gates
111
– circuit (f):
Q = (A ⊕B)B ⊕C + A ⊕B(B ⊕C)
[2.105]
= (A ⊕B) ⊕(B ⊕C)
= (A ⊕C) ⊕(B ⊕B)
= (A ⊕C) ⊕0
= A ⊕C
[2.106]
SOLUTION 2.9.– Implementation of the function H.
The function H can be written as follows:
H = A · B + A · B + B · C
[2.107]
= A · B + (A + C)B
= A(A + B) + (A + C)B
= A · A · B + A · C · B
= A · A · B · A · C · B
[2.108]
Using equation [2.108], the logic circuit based on NAND gates shown in
Figure 2.72 can be obtained.
A
H
B
A
C
B
A
Figure 2.72. Implementation of H: logic circuit based on NAND gates
SOLUTION 2.10.– Implementation of the logic function Y .
Observing that:
Y = (A · B) ⊕(B · C) = A · B + B · C = A · B + B + C
[2.109]
because A·B·B·C = 0, the function Y can be implemented as shown in Figure 2.73.

112
Digital Electronics 1
Y
B
A
C
Figure 2.73. Implementation of the function Y
SOLUTION 2.11.– Implementation of NAND/NOR gates.
Figures 2.74 and 2.75 depict the circuits corresponding to the logic functions P
and Q, respectively.
B
B
A
D
C
A
D
C
A
P
(c)
C
A
D
P
(a)
P
(b)
A
B
A
Figure 2.74. Implementation of P: a) logic circuit using AND and OR
gates; b) logic circuit based on NAND gates; c) logic circuit based on
NOR gates
SOLUTION 2.12.– Control circuit for a switcher.
The following decimal-to-binary conversion makes it possible to determine the bits
I7, I6, I5, I4, I3, I2, I1 and I0:
3210 = 001000002
12810 = 100000002
6310 = 001111112
15910 = 100111112
6410 = 010000002
19210 = 110000002
12710 = 011111112
25510 = 111111112
The truth table for the control circuit may be constructed as shown in Table 2.15.

Logic Gates
113
A
D
C
B
A
C
B
A
A
(c)
(a)
(b)
Q
Q
Q
A
B
C
D
A
D
Figure 2.75. Implementation of Q: a) logic circuit using OR and AND
gates; b) logic circuit based on NAND gates; c) logic circuit based on
NOR gates
 7
 1
I 2
I 3
I 4
I 6
I 5
I 7
I 0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
0
0
1
0
1
1
1
1
0
0
1
1
0
0
1
1
1
1
0
0
0
0
192
255
128
159
64
127
32
63
Functions
D
D
D
D
D
D
D
D
4
3
2
1 = 
I 7
= 
I 6
I 7
= 
I 6 I 5
I 7
= 
I 6
I 6 I 5
1
2
3
4
I
I
Table 2.15. Truth table
For each selection range, the output function depends solely on the bits that do not
change logic state. We thus have:
D1 = I7 · I6 · I5
D2 = I7 · I6
D3 = I7 · I6 · I5
D4 = I7 · I6
and
D0 = D4 + D3 + D2 + D1

114
Digital Electronics 1
The output function, D0, can also be written as follows:
D0 = D4 + D3 + D2 + D1
[2.110]
= I7 · I6 + I7 · I6 · I5 + I7 · I6 + I7 · I6 · I5
= I7(I6 + I6 · I5) + I7(I6 + I6 · I5)
= I7(I6 + I5) + I7(I6 + I5)
= I7I5 + I7I5 + I6(I7 + I7)
= I7 ⊕I5 + I6
= (I7 ⊙I5)I6
= I7 · I6 · I5 + I7 · I6 · I5
[2.111]
The implementation of the control circuit is represented in Figure 2.76.
 4
 7
I 6
I 5
I 7
I 6
I 5
D
D
D
D 0
D
D 0
D
D
D
D
 3
 2
 1
 4
 3
 2
 1
I
Figure 2.76. Logic circuits

3
Function Blocks of Combinational Logic
3.1. Introduction
Circuits are used in combinatorial logic to carry out operations such as data
manipulation and selection, coding, decoding and error detection. Among the basic
components listed as being necessary to implement them, there are multiplexers,
demultiplexers, encoders, decoders and shifters.
3.2. Multiplexer
A multiplexer (MUX) is a logic circuit that allows for switching the data present
at any one of its inputs toward its single output. Thus, it generally has 2n data inputs,
n select lines and one output.
A 2-to-1 multiplexer (or 2:1 multiplexer) can be implemented as shown in
Figure 3.1(a). It can be represented by one of the symbols given in Figures 3.1(b)
and 3.1(c). The logic equation of the 2:1 multiplexer is given by:
Y = S · D0 + S · D1
[3.1]
– if S = 0, we have Y = D0;
– if S = 1, we have Y = D1.
A 2-to-1 multiplexer thus operates as a commutator. Its working principle is
illustrated in the schematic diagram shown in Figure 3.2. By expressing the output as
a function of the inputs D0 and D1, the size of the truth table for the 2-to-1
multiplexer can be reduced, as illustrated in Table 3.1.
Digital Electronics 1: Combinational Logic Circuits, First Edition. Tertulien Ndjountche.
© ISTE Ltd 2016. Published by ISTE Ltd and John Wiley & Sons, Inc.

116
Digital Electronics 1
(a)
0
D1
D0
D1
0
1
MUX
Y
S
S
Y
0
1
S
Y
(b)
(c)
D
Figure 3.1. 2-to-1 multiplexer: a) logic circuit and b) and c) symbols
Y
1
D0
S
D
Figure 3.2. Schematic diagram of the 2-to-1 multiplexer
S
Y
0
D0
1
D1
Table 3.1. Truth table of the 2-to-1 multiplexer
Multiplexers offered by integrated circuit manufacturers most often have an active-
low enable input. Figures 3.3(a) and 3.3(b) show, respectively, the circuit and symbol
for a 2-to-1 multiplexer with an active-low enable input. The logic equation for the
output is given by:
Y = EN(S · D0 + S · D1)
[3.2]
Equation [3.2] may be translated to a truth table with entered input variables, as
shown in Table 3.2.
The output of a three-state buffer reﬂects the input logic level or is isolated from the
input depending on the logic level of the selection signal. A 2-to-1 multiplexer can thus
be implemented by connecting the outputs of two three-state buffers whose selection

Function Blocks of Combinational Logic
117
signals are complementary, as shown in Figure 3.4. In the ideal case, the multiplexer
operation is governed by the truth table represented in Table 3.3. However, if the
selection signals overlap, due to propagation delays for instance, one of the outputs
Y0 and Y1 may be set at 0 while the other is at 1, thus forcing the output Y to assume
an indeterminate state.
(b)
1
D0
Y
S
(a)
EN
0
1
Y
MUX
S
EN
D
Figure 3.3. 2-to-1 multiplexer with an active-low enable input
EN
S
Y
1
x
0
0
0
D0
0
1
D1
Table 3.2. Truth table of a 2:1 multiplexer
S
1
D0
Y0
Y1
Y
D
Figure 3.4. 2-to-1 multiplexer based on three-state buffers
A 4-to-1 multiplexer can be implemented using logic gates as shown in
Figure 3.5(a) or using 2-to-1 multiplexers conﬁgured as shown in Figure 3.5(b). Its

118
Digital Electronics 1
symbol is shown in Figure 3.5(c). Analyzing the circuit for the 4-to-1 multiplexer, we
have:
Y = S1 · S0 · D0 + S1 · S0 · D1 + S1 · S0 · D2 + S1 · S0 · D3
[3.3]
where D0, D1, D2 and D3 represent the data input and S0 and S1 are the selection
lines.
S
Y0
Y1
Y
0
D0
z
D0
1
z
D1
D1
Table 3.3. Truth table of a 2-to-1 multiplexer
(c)
 0
D0
D1
D2
D3
D0
D1
D2
D3
S 0
S 1
S 0
S 1
D0
D1
D2
D3
Y
S 1
(a)
0
1
0
1
(b)
0
1
Y
00
01
10
11
Y
S
Figure 3.5. 4-to-1 multiplexers implemented using a) logic gates and
b) 2-to-1 multiplexers; c) symbol
Figure 3.6(a) depicts the logic circuit for a 4-to-1 multiplexer whose output is set
to zero when EN = 1. Figure 3.6(b) depicts the logic circuit for a 4-to-1 multiplexer
whose output is set to high impedance state when EN = 1. Figure 3.6(c) shows the
symbol for a 4-to-1 multiplexer with enable signal. The output variable for a 4-to-1
multiplexer with an active-low enable input can take the following form:
Y = EN(S1 · S0 · D0 + S1 · S0 · D1 + S1 · S0 · D2 + S1 · S0 · D3)
[3.4]

Function Blocks of Combinational Logic
119
MUX
 1
S 0
S 0
D0
D1
D2
D3
S 0
S 1
D0
D1
D2
D3
S 1
S 0
Y
EN
(b)
Y
EN
(a)
(c)
0
1
2
3
EN
Y
S
Figure 3.6. 4-to-1 multiplexer with an enable input:
a) output set to zero when EN = 1; b) output set to high
impedance state when EN = 1; c) symbol
Equation [3.4] can equivalently be represented either by the truth table for the
multiplexer of Figure 3.6(a) shown in Table 3.4, or by the truth table for the
multiplexer of Figure 3.6(b) presented in Table 3.5.
EN
S1
S0
Y
1
x
x
0
0
0
0
D0
0
0
1
D1
0
1
0
D2
0
1
1
D3
Table 3.4. Truth table for the multiplexer shown in Figure 3.6(a)
EN
S1
S0
Y
1
x
x
z
0
0
0
D0
0
0
1
D1
0
1
0
D2
0
1
1
D3
Table 3.5. Truth table for the multiplexer shown in Figure 3.6(b)

120
Digital Electronics 1
An 8-to-1 multiplexer can be implemented either by using logic gates, as shown in
Figure 3.7(a), or by connecting the 4-to-1 multiplexers, as illustrated in Figure 3.7(b).
Its output is characterized by a logic equation that takes the following form:
Y = EN(S2 · S1 · S0 · D0 + S2 · S1 · S0 · D1+
S2 · S1 · S0 · D2 + S2 · S1 · S0 · D3 + S2 · S1 · S0 · D4+
S2 · S1 · S0 · D5 + S2 · S1 · S0 · D6 + S2 · S1 · S0 · D7)
[3.5]
D
S1
S2
0
S
1
D
D2
D0
D3
0
1
2
3
MUX
EN
1
S
0
S
D7
D4
D5
D6
D5
D4
D3
D1
D0
D2
S1
0
S2
S
(a)
Y
EN
(b)
0
1
2
3
MUX
EN
1
S
0
S
EN
Y
D7
6
Figure 3.7. 8-to-1 multiplexer implemented using a) logic ports or
b) 4-to-1 multiplexers
Table 3.6 shows the truth table of the 8-to-1 multiplexer with an active-low enable
input.
In general, a multiplexer with 2n data inputs has n selection lines and a single
output. The output takes the level of the data input whose number can be equal to the
equivalent decimal value of the binary code applied at the selection inputs.

Function Blocks of Combinational Logic
121
EN
S0
S1
S0
Y
1
x
x
x
0
0
0
0
0
D0
0
0
0
1
D1
0
0
1
0
D2
0
0
1
1
D3
0
1
0
0
D4
0
1
0
1
D5
0
1
1
0
D6
0
1
1
1
D7
Table 3.6. Truth table for an 8-to-1 multiplexer
3.3. Demultiplexer and decoder
A decoder (DEC) is a logic circuit that activates only one of the outputs for each
possible combination of input variables. It can thus be used to detect a binary code.
A demultiplexer (DMUX) is a logic circuit that switches a data input toward one
of the outputs depending on the selection code.
The logic circuit and the symbol for the 1-out-of-2 decoder are illustrated in
Figures 3.8(a) and 3.8(b), respectively. The logic equations for the output variables
are given by:
Y0 = EN · D
[3.6]
and
Y1 = EN · D
[3.7]
where D is the variable associated with the data input and EN represents the enable
signal. Table 3.7 gives the truth table for the 1-out-of-2 decoder with an active-high
input.
Decoders are most often designed with an active-low enable input, as can be seen
in the logic circuit and the symbol given in Figures 3.9(a) and 3.9(b) for a 1-out-of-2
decoder. The logic equations for the output can be written as follows:
Y0 = EN · D
[3.8]

122
Digital Electronics 1
and
Y1 = EN · D
[3.9]
DEC
0
Y1
Y0
Y1
G
1
0
S
EN
D
(b)
D
EN
(a)
Y
Figure 3.8. 1-out-of-2 decoder with an active-high enable input
EN
D
Y1
Y0
0
x
0
0
1
0
0
1
1
1
1
0
Table 3.7. Truth table for the decoder
DEC
1
Y0
Y0
Y1
D
(a)
G
1
0
S
D
(b)
EN
EN
Y
Figure 3.9. 1-out-of-2 decoder with an active-low enable input
This makes it possible to construct the truth table given in Table 3.8.
Figure 3.10(a) represents the logic circuit of a 1-to-2 demultiplexer (or 1 : 2
demultiplexer). Figures 3.10(b) and 3.10(c) depict the symbols that are generally
used to represent a 1-to-2 demultiplexer.

Function Blocks of Combinational Logic
123
EN
D
Y1
Y0
1
x
0
0
0
0
0
1
0
1
1
0
Table 3.8. Truth table for the decoder
(c)
1
Y0
Y0
Y1
Y0
Y1
S
D
S
D
1
0
G
1
0
S
S
D
DMUX
(a)
(b)
Y
Figure 3.10. 1-to-2 demultiplexer: a) logic circuit, b) schematic diagram
illustrating the working principle and c) symbols
The 1 : 2 demultiplexer is characterized by the following equations:
Y0 = S · D
[3.10]
Y1 = S · D
[3.11]
The operation of the 1-to-2 demultiplexer is explained in the schematic diagram
shown in Figure 3.11 and its truth table is represented by Table 3.9. The output Y0 is
selected when S = 0, and Y1 when S = 1.
D
0
Y1
S
Y
Figure 3.11. Schematic diagram of a 1-to-2 demultiplexer
It must be noted that to transform a decoder to a demultiplexer, it is enough to
connect the data signal to the enable input G. Additionally, the input G is useful in
establishing the connections required to associate several decoders in order to increase
the length of the binary words that can be processed.

124
Digital Electronics 1
S
Y0
Y1
0
D
0
1
0
D
Table 3.9. Truth table of a 1-to-2 demultiplexer
The 1-to-2 demultiplexer shown in Figure 3.12 makes use of the fact that a
three-state buffer is equivalent to an open or closed switched depending on the logic
level applied to the selection input. The corresponding truth table is represented in
Figure 3.10.
D
0
Y1
S
Y
Figure 3.12. Three-state buffer based 1-to-2 demultiplexer
S
Y1
Y0
0
z
D0
1
D1
z
Table 3.10. Truth table of the 1-to-2 demultiplexer
Figure 3.13(a) depicts the logic circuit for a 2-out-of-4 decoder that is
implemented using logic gates. A 2-out-of-4 decoder can also be implemented by
connecting two 1-out-of-2 decoders as illustrated in Figure 3.13(b). The symbolic
representation of a 2-out-of-4 decoder is given in Figure 3.13(c). The logic circuit of
the 1-to-4 demultiplexer represented in Figure 3.14(a) uses logic gates, while the
circuit shown in Figure 3.14(b) uses two 1-to-2 demultiplexers. Figure 3.14(c)
depicts the symbol of a 1-to-4 demultiplexer. The logic equations obtained in each
case are as follows:
– 2-out-of-4 decoder:
Y0 = S1 · S0,
Y1 = S1 · S0,
Y2 = S1 · S0,
and
Y3 = S1 · S0
[3.12]

Function Blocks of Combinational Logic
125
– 1-to-4 demultiplexer:
Y0 = S1 · S0 · D, Y1 = S1 · S0 · D, Y2 = S1 · S0 · D, and Y3 = S1 · S0 · D
[3.13]
DEC
S 1
S 0
Y0
Y1
Y2
3
Y
Y2
Y1
Y0
3
Y
0
1
2
3
3
Y
Y1
Y0
Y2
S 1
S 0
S 1
(a)
1
0
G
1
0
S 0
(c)
G
S
S
(b)
DEC
DEC
Figure 3.13. 2-out-of-4 decoder: implemented using a) logic gates or
b) 1-out-2 decoders; c) symbol
DMUX
Y2
Y1
Y0
3
Y
0
1
2
3
S 0
S 1
S 1
3
Y
Y1
Y0
Y2
S 1
S 0
S 0
S 1
D
D
(a)
(b)
(c)
G
S 0
G
1
0
S
G
1
0
S
Y0
Y1
Y2
3
Y
D
DMUX
DMUX
Figure 3.14. 1-to-4 demultiplexers: implemented using a) logic gates or
b) 1-to-2 demultiplexers; c) symbol
Truth tables of the 2-out-of-4 decoder and 1-to-4 demultiplexer are represented by
Tables 3.11 and 3.12.

126
Digital Electronics 1
A 1-to-8 demultiplexer can be implemented using logic gates as shown in
Figure 3.15(a) or using 1-to-4 multiplexers as illustrated in Figure 3.15(b). It can be
represented by the symbol given in Figure 3.15(c). The output logic equations can be
written as:
Y0 = S2 · S1 · S0 · D
Y1 = S2 · S1 · S0 · D
Y2 = S2 · S1 · S0 · D
Y3 = S2 · S1 · S0 · D
Y4 = S2 · S1 · S0 · D
Y5 = S2 · S1 · S0 · D
Y6 = S2 · S1 · S0 · D
Y7 = S2 · S1 · S0 · D
[3.14]
S1
S0
Y3
Y2
Y1
Y0
0
0
0
0
0
1
0
1
0
0
1
0
1
0
0
1
0
0
1
1
1
0
0
0
Table 3.11. Truth table of a 2-out-of-4 decoder
S1
S0
Y3
Y2
Y1
Y0
0
0
0
0
0
D
0
1
0
0
D
0
1
0
0
D
0
0
1
1
D
0
0
0
Table 3.12. Truth table of a 1-to-4 demultiplexer
Table 3.13 gives the truth table of the 1-to-8 demultiplexer. The output, to which
the input data are transferred, is identiﬁed by a decimal number corresponding to the
binary code applied to the selection inputs.
In general, a decoder is a logic circuit with n inputs and 2n outputs, of which only
one is active at any time. A demultiplexer has one data input, n select inputs, and 2n
outputs. Integrated decoders most often have one enable input. As the latter can also
serve as a data input, it is possible to transform a decoder with an enable input to a
demultiplexer.
Figure 3.16 shows a matrix-type structure that makes it possible to implement a
4-out-of-16 decoder using two 2-out-of-4 decoders and 16 AND gates. It offers the
advantage of reducing the maximum number of inputs per logic gate and is used most
often to construct memory networks. In general, to implement an n-out-of-2n decoder,
two decoders of the types, p-out-of-2p and q-out-of-2q, where p + q = n, and 2n
2-input AND gates are required.

Function Blocks of Combinational Logic
127
D
2
S1
S0
S 1
Y3
Y2
Y1
Y0
S 1
7
Y
Y6
Y5
Y4
Y1
Y2
Y3
Y4
Y5
Y6
7
Y
Y0
S0
S1
S2
2
S0
S1
S2
3
1
Y1
Y2
Y3
Y4
Y5
Y6
7
Y
Y0
S0
S1
S2
D
(b)
(a)
G
S 0
0
1
2
3
DMUX
G
S 0
0
1
2
3
DMUX
D
(c)
0
4
6
7
G
5
DMUX
S
Figure 3.15. 1-to-8 demultiplexer implemented using a) logic gates or
b) 1-to-4 demultiplexers; c) symbol
S2
S1
S0
Y7
Y6
Y5
Y4
Y3
Y2
Y1
Y0
0
0
0
0
0
0
0
0
0
0
D
0
0
1
0
0
0
0
0
0
D
0
0
1
0
0
0
0
0
0
D
0
0
0
1
1
0
0
0
0
D
0
0
0
1
0
0
0
0
0
D
0
0
0
0
1
0
1
0
0
D
0
0
0
0
0
1
1
0
0
D
0
0
0
0
0
0
1
1
1
D
0
0
0
0
0
0
0
Table 3.13. Truth table for an 1-to-8 demultiplexer
3.4. Implementation of logic functions using multiplexers or decoders
A logic function can also be implemented using multiplexers or decoders.
3.4.1. Multiplexer
In general, a 2n−1-to-1 multiplexer is required for the implementation of an
n-variable logic function. A commonly adopted approach consists of linking n −1

128
Digital Electronics 1
variables to the selection inputs of the multiplexer and connecting the data inputs of
the multiplexer to either the logic level 1 or 0, or to the remaining variable or its
complement.
2:4  Decoder
 0
S 1
S 2
S 3
E
0
1
2
3
Y
X
1
Z 0
Z 4
Z 8
Z 12
Z 1
Z 5
Z 9
Z 13
Z 2
Z 6
Z 10
Z 14
Z 3
Z 7
Z 11
Z 15
2:4  Decoder
E
1
2
3
X
Y
 0
1
S
Figure 3.16. 2-out-of-16 decoder based on a matrix-type structure
Implement the following 4-variable logic function using an 8-to-1 multiplexer:
Y (A, B, C, D) =

m(1, 2, 3, 4, 8, 12, 13, 15)
[3.15]
Table 3.14 gives the truth table for the function Y . Considering the variables A,
B and C, as the selection inputs to the multiplexer, it becomes possible to regroup
the rows of the truth table in pairs, with each pair being characterized by the same
combination of selection inputs. This translates to the factorization of 1, 0, D or D, as
illustrated in the truth table or the Karnaugh maps shown in Figure 3.17(a). The logic
circuit of the 8-to-1 multiplexer conﬁgured to implement the function Y is given in
Figure 3.17(b).
Using a multiplexer makes it possible to easily modify (or reconﬁgure) a logic
function.

Function Blocks of Combinational Logic
129
A
B
C
D
Y
0
0
0
0
0
0
0
0
1
1
D
0
0
1
0
1
0
0
1
1
1
1
0
1
0
0
1
0
1
0
1
0
D
0
1
1
0
0
0
1
1
1
0
0
1
0
0
0
1
1
0
0
1
0
D
1
0
1
0
0
1
0
1
1
0
0
1
1
0
0
1
1
1
0
1
1
1
1
1
1
0
0
1
1
1
1
1
D
Table 3.14. Truth table for the logic function Y
3.4.2. Decoder
Even though a decoder is not considered as a universal component, it can still be
used to implement logic functions. Any function with n variables may be implemented
by an n-out-of-2n decoder associated with an OR (or NAND) logic gate.
Use a 3-out-of-8 decoder and OR logic gates to implement the following logic
functions:
P(A, B, C) =

m(0, 1, 3, 7)
[3.16]
and
Q(A, B, C) =

m(4, 6, 7)
[3.17]
As each of the functions is given in the canonical form, it is only necessary to
generate the corresponding sum-of-products form, as illustrated in Figure 3.18.
The approach based on using a decoder and OR gates offers the advantage of
allowing the implementation of several logic functions at the same time.

130
Digital Electronics 1
(a)
S
0
S
EN
D
D
(b)
B
C
A
4
5
6
7
0
1
2
3
2
S
MUX
0
D
1
0
Y
1
D
1
0
0
AB
C
00
01
11
10
A
0
B
1
C
D
D
1
Figure 3.17. a) Karnaugh map; b) logic circuit
DEC
 2
S 1
S 0
0
EN
A
B
C
1
2
3
4
5
6
7
0
Q
P
S
Figure 3.18. Implementation of the functions
P and Q using a 3-out-of-8 decoder
3.5. Encoders
An encoder, in general, is a logic circuit that allows for the conversion of input
information in a given code. It generally has more input variables than output
variables.

Function Blocks of Combinational Logic
131
3.5.1. 4:2 encoder
A 4 : 2 encoder, in its simplest form, is supposed to function with a single active
input among four inputs and to generate a binary code through the two outputs.
Consequently, there are only ﬁve permitted combinations of the input variables out of
the possible 16. We can, thus, establish the truth tables shown in Tables 3.15
and 3.16.
D3
D2
D1
D0
Y1
Y0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
1
0
0
1
0
1
0
0
1
0
1
0
0
0
1
1
· · ·
· · ·
· · ·
· · ·
x
x
...
...
...
...
...
...
· · ·
· · ·
· · ·
· · ·
x
x
Table 3.15. Truth table (case 1)
D3
D2
D1
D0
Y1
Y0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
1
0
0
1
0
1
0
0
1
0
1
0
0
0
1
1
· · ·
· · ·
· · ·
· · ·
0
0
...
...
...
...
...
...
· · ·
· · ·
· · ·
· · ·
0
0
Table 3.16. Truth table (case 2)
– Case 1
In this case, the outputs Y1 and Y0 are considered to be don’t care states for the
11 combinations of input variables, which are not explicitly deﬁned in the truth table.
The Karnaugh maps represented in Figures 3.19 and 3.20 allow the determination of
the logic equations for Y1 and Y0, respectively. Figure 3.21 shows the logic circuit for
the resulting 4 : 2 encoder.

132
Digital Electronics 1
10
01
11
10
D1D0
3
D
2
D
D1
3
D
1
1
x
x
x
x
x
x
0
x
x
x
0
x
x
x
D0
2
D
00
01
11
00
Figure 3.19. Y1 = D3 + D2
10
0
1
x
x
x
x
x
x
1
x
x
x
0
x
x
x
00
01
11
10
D1D0
3
D
2
D
D1
3
D
D0
2
D
00
01
11
Figure 3.20. Y0 = D3 + D1
D
D
1
D
0
D
0
Y
1
Y
2
3
Figure 3.21. 4 : 2 encoder (case 1)

Function Blocks of Combinational Logic
133
– Case 2
In this case, the outputs Y1 and Y0 are assumed to take the logic level 0 for the 11
combinations of the input variables that are not explicitly deﬁned in the truth table.
The logic equations for Y1 and Y0 can be written as follows:
Y1 = D3 · D2 · D1 · D0 + D3 · D2 · D1 · D0
= D1 · D0(D3 ⊕D2)
[3.18]
and
Y0 = D3 · D2 · D1 · D0 + D3 · D2 · D1 · D)
= D2 · D0(D3 ⊕D1)
[3.19]
The logic circuit for the resulting 4 : 2 encoder is illustrated in Figure 3.22.
1
Y
0
Y
2
D
3
D
1
D
0
D
Figure 3.22. 4 : 2 encoder (case 2)
NOTE 3.1.– The encoder generates the output Y1Y0 = 00 if the input D0 is set at
either 1 or 0. The addition of a validation output V makes it possible to distinguish
between these two cases.
Table 3.17 shows the truth table of a 4 : 2 encoder with a validation output. The
logic equation for the validation output is given by:
V = D3 + D2 + D1 + D0
[3.20]
The logic circuit obtained for the 4 : 2 encoder with a validation output is
represented in Figure 3.23.

134
Digital Electronics 1
D3
D2
D1
D0
Y1
Y0
V
0
0
0
0
0
0
0
0
0
0
1
0
0
1
0
0
1
0
0
1
1
0
1
0
0
1
0
1
1
0
0
0
1
1
1
· · ·
· · ·
· · ·
· · ·
x
x
x
...
...
...
...
...
...
...
· · ·
· · ·
· · ·
· · ·
x
x
x
Table 3.17. Truth table of the 4 : 2 encoder with a validation output
V
D
2
D
1
D
0
D
0
Y
1
Y
3
Figure 3.23. 4 : 2 encoder with a validation output
3.5.2. 8:3 encoder
An 8 : 3 encoder with a validation output generates a unique 4-bit sequence as the
output for each combination of input variables with a single input set at 1. Among the
256 possible input combinations, there are only nine permitted combinations. We can
construct the truth table as shown in Table 3.18.
As don’t care states can be used to minimize the logic equation for each output,
analyzing the truth table can help us deduce that the simplest expression corresponds
to an OR function for input variables taking the logic level 1 at the same time as the
output of interest. In this way, we obtain the following logic equations:
Y2 = D7 + D6 + D5 + D4
[3.21]
Y1 = D7 + D6 + D3 + D2
[3.22]
Y0 = D7 + D5 + D3 + D1
[3.23]

Function Blocks of Combinational Logic
135
and
V = D7 + D6 + D5 + D4 + D3 + D2 + D1 + D0
[3.24]
D7
D6
D5
D4
D3
D2
D1
D0
Y2
Y1
Y0
V
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
1
0
0
0
0
0
0
1
0
0
0
1
1
0
0
0
0
0
1
0
0
0
1
0
1
0
0
0
0
1
0
0
0
0
1
1
1
0
0
0
1
0
0
0
0
1
0
0
1
0
0
1
0
0
0
0
0
1
0
1
1
0
1
0
0
0
0
0
0
1
1
0
1
1
0
0
0
0
0
0
0
1
1
1
1
· · ·
· · ·
· · ·
· · ·
· · ·
· · ·
· · ·
· · ·
x
x
x
x
...
...
...
...
...
...
...
...
...
...
...
...
· · ·
· · ·
· · ·
· · ·
· · ·
· · ·
· · ·
· · ·
x
x
x
x
Table 3.18. Truth table for an 8 : 3 encoder
Figure 3.24 shows the logic circuit for an 8 : 3 encoder with a validation output.
The change in the logic level of the input D0 is only detected through the validation
output.
4
D
D2
0
D
1
D
0
Y
1
Y
Y2
V
7
D
D6
D
5
D
3
Figure 3.24. 8 : 3 encoder with a validation output

136
Digital Electronics 1
3.5.3. Priority encoder
A 2n : n encoder only operates correctly if none of the inputs or one single input
is at logic level 1. When more than one input simultaneously takes logical level 1, the
coding is wrong. One solution, in this case, consists of using a priority encoder.
A priority encoder generates a binary code corresponding to the number of the
active input with highest priority (or, most often, the highest number). It can be used
in the following applications:
– keyboard encoder: when several keys are pressed simultaneously, only the key
with the highest number is taken into consideration;
– unit processing interrupt requests in a microprocessor: in case of simultaneous
interrupt requests, only the request with the highest priority is accepted.
3.5.3.1. 4:2 priority encoder
The truth table for a 4 : 2 priority encoder is given in Table 3.19, where x represents
a don’t care state. For an input word, the active bit with the highest weight has priority.
D3
D2
D1
D0
Y1
Y0
V
0
0
0
0
0
0
0
0
0
0
1
0
0
1
0
0
1
x
0
1
1
0
1
x
x
1
0
1
1
x
x
x
1
1
1
Table 3.19. Truth table for a 4:2 priority encoder
The Karnaugh maps shown in Figures 3.25–3.27 are constructed assuming that
each indifferent state can take the logic level 0 or logic level 1. The resulting logic
equations can be written as follows:
Y1 = D3 + D2
[3.25]
Y0 = D3 + D2 · D1
[3.26]
and
V = D3 + D2 + D1 + D0
[3.27]
The logic circuit of the 4 : 2 priority encoder can then be realized as illustrated in
Figure 3.28.

Function Blocks of Combinational Logic
137
3.5.3.2. 4:2 priority encoders with cascading capability
The priority encoders offered by manufacturers of integrated circuits have
additional inputs and outputs (enable-in input, EI, enable-out output, E0, group
signal output, GS or V) that can be required for cascade connections.
10
1
1
0
1
0
1
1
1
0
1
1
1
0
1
1
1
00
01
11
10
D1D0
3
D
2
D
D1
3
D
D0
2
D
00
01
11
Figure 3.25. Representation of Y1 = D3 + D2
10
01
11
10
D1D0
3
D
2
D
D1
3
D
D0
2
D
0
1
0
1
1
0
1
1
1
0
1
1
0
1
1
0
00
01
11
00
Figure 3.26. Representation of Y0 = D3 + D2D1
To design a 4 : 2 priority encoder with cascading capability, we begin by
constructing the truth table as illustrated in Table 3.20. As the encoder is based on
active low logic, the output V indicates when EI takes the logic level 0 and a single
entry among Dk (k = 0, 1, 2, 3) takes logic level 1. Karnaugh maps shown in

138
Digital Electronics 1
Figures 3.29–3.32 are constructed and then used to determine the logic equations of
the outputs as follows:
Y1 = (D3 + D2)EI
[3.28]
Y0 = (D3 + D2 · D1)EI
[3.29]
V = (D3 + D2 + D1 + D0)EI = E0 · EI
[3.30]
and
E0 = D3 · D2 · D1 · D0 · EI
[3.31]
10
01
11
10
D1D0
3
D
2
D
D1
3
D
2
D
D0
1
1
0
1
1
1
1
1
1
1
1
1
1
1
1
1
00
01
11
00
Figure 3.27. Representation of V = D3 + D2 + D1 + D0
V
D
1
D
1
Y
0
Y
3
D
2
D
0
Figure 3.28. 4 : 2 priority encoder with a validation output
The transcription of these equations using logic gates results in the circuit shown
in Figure 3.33(a). Figure 3.33(b) depicts the symbol for a 4 : 2 priority encoder with
cascading capability. The 8
:
3 priority encoder shown in Figure 3.33(c) is

Function Blocks of Combinational Logic
139
implemented by cascading two 4 : 2 priority encoders. This brings into play the
following logic expressions:
E0 = E01
[3.32]
and
EI1 = E02 = D7 · D6 · D5 · D4 · EI
[3.33]
where EI = EI2. Table 3.21 shows the truth table for the 8 : 3 priority encoder.
EI
D3
D2
D1
D0
Y1
Y0
V
E0
0
0
0
0
0
0
0
0
1
0
0
0
0
1
0
0
1
0
0
0
0
1
x
0
1
1
0
0
0
1
x
x
1
0
1
0
0
1
x
x
x
1
1
1
0
1
x
x
x
x
0
0
0
0
Table 3.20. Truth table for 4 : 2 priority encoder
with cascading capability
10
01
11
10
D1D0
3
D
2
D
D1
3
D
2
D
D0
EI
EI
EI
EI
EI
EI
EI
EI
EI
EI
EI
EI
0
0
0
0
00
01
11
00
Figure 3.29. Representation of Y1 = (D3 + D2)EI
Devices such as 8 : 3 priority encoders with cascading capability and 10 : 4
priority encoders are available as commercial integrated circuits. They are especially
useful for applications that use binary coded decimal (BCD) representation, coding of
keyboard keys and selection of a numerical range.
3.5.3.3. 10:4 priority encoder
A 10 : 4 priority encoder or decimal binary priority encoder carries out coding of
input logic levels such that only a change in the logic level of the highest ranked input
is taken into consideration.

140
Digital Electronics 1
10
01
11
10
D1D0
3
D
2
D
D1
3
D
2
D
D0
EI
EI
EI
EI
EI
EI
EI
EI
EI
EI
0
0
0
0
0
0
00
01
11
00
Figure 3.30. Representation of Y0 = (D3 + D2 · D1)EI
0
01
11
10
D1D0
3
D
2
D
D1
3
D
2
D
D0
0
EI
0
0
0
0
0
0
0
0
0
0
0
00
01
11
10
0
0
00
Figure 3.31. Representation of E0 = D3 · D2 · D1 · D0 · EI
As the decimal zero or D0 corresponds to the case where all the inputs are at the
low logic level, the input D0 is omitted. The input Di, with i being a number between
1 and 9, can only activate the output Yj (j = 0, 1, 2, 3) if no input with a higher
priority and other than those that also activate Yj takes the high logic level.
Based on the conversion table shown in Table 3.22, it is possible to formulate a
logic proposition for each output. Thus, the output Y0 takes the high logic level when
one of the following is true:
– D1 is at high logic level, and D2, D4, D6 and D8 are at low logic level;
– D3 is at high logic level, and D4, D6 and D8 are at low logic level;
– D5 is at high logic level, and D6 and D8 are at low logic level;

Function Blocks of Combinational Logic
141
EI
D7
D6
D5
D4
D3
D2
D1
D0
Y2
Y1
Y0
V
E0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
1
0
0
0
1
0
0
0
0
0
0
0
0
1
x
0
0
1
1
0
0
0
0
0
0
0
1
x
x
0
1
0
1
0
0
0
0
0
0
1
x
x
x
0
1
1
1
0
0
0
0
0
1
x
x
x
x
1
0
0
1
0
0
0
0
1
x
x
x
x
x
1
0
1
1
0
0
0
1
x
x
x
x
x
x
1
1
0
1
0
0
1
x
x
x
x
x
x
x
1
1
1
1
0
1
x
x
x
x
x
x
x
x
0
0
0
0
0
Table 3.21. Truth table for the 8 : 3 priority encoder
– D7 is at high logic level, and D8 is at low logic level;
– D7 is at high logic level.
10
01
11
10
D1D0
3
D
2
D
D1
3
D
2
D
D0
EI
EI
EI
EI
EI
EI
EI
EI
EI
EI
EI
EI
EI
EI
EI
0
00
01
11
00
Figure 3.32. Representation of V = (D3 + D2 + D1 + D0)EI
This translates to:
Y0 = D1 · D2 · D4 · D6 · D8 + D3 · D4 · D6 · D8 + D5 · D6 · D8
+D7 · D8 + D9
[3.34]

142
Digital Electronics 1
(a)
D
2
D
1
D
0
D
3
D
2
D
1
D
0
D
1
Y
0
Y
1
Y
0
Y
1
Y
0
Y
2
Y
3
D
2
D
1
D
0
D
1
Y
0
Y
3
D
2
D
1
D
0
D
0
Y
1
Y
2
D
3
D
1
D
0
D
EI
EI
E0
EI
E0
V
1
2
V
V
EI
E0
V
4
D
5
D
6
D
7
D
EI
E0
V
(c)
(b)
3
Figure 3.33. Circuit a) and symbol b) for a 4 : 2 priority encoder with
cascading capability; c) 8 : 3 priority encoder
Y3
Y2
Y1
Y0
0
0
0
0
0
1
0
0
0
1
2
0
0
1
0
3
0
0
1
1
4
0
1
0
0
5
0
1
0
1
6
0
1
1
0
7
0
1
1
1
8
1
0
0
0
9
1
0
0
1
Table 3.22. Conversion of decimal numbers from
0 to 9 into binary representation
Similarly, the output Y1 takes high logic level in one of the following cases:
– D2 is at high logic level, and D4, D5, D8 and D9 are at low logic level;
– D3 is at high logic level, and D4, D5, D8 and D9 are at low logic level;
– D6 is at high logic level, and D8 and D9 are at low logic level;
– D7 is at high logic level, and D8 and D9 are at low logic level.

Function Blocks of Combinational Logic
143
This results in the following logic equation:
Y1 = D2 · D4 · D5 · D8 · D9 + D3 · D4 · D5 · D8 · D9 + D6 · D8 · D9
+D7 · D8 · D9
[3.35]
The output Y2 takes high logic level in one of the following cases:
– D4 is at high logic level, and D8 and D9 are at low logic level;
– D5 is at high logic level, and D8 and D9 are at low logic level;
– D6 is at high logic level, and D8 and D9 are at low logic level;
– D7 is at high logic level, and D8 and D9 are at low logic level.
This leads to the following equation:
Y2 = D4 · D8 · D9 + D5 · D8 · D9 + D6 · D8 · D9 + D7 · D8 · D9
[3.36]
Finally, the output Y3 is at high logic level if D8 is at high level or if D9 is at high
level. The resulting logic equation is, thus, given by:
Y3 = D8 + D9
[3.37]
Figure 3.34 depicts the logic circuit for the priority encoder 74LS147. For this kind
of circuit, the inputs and outputs are active at the low logic level. The truth table of
Table 3.23 shows that the priority of each input is determined by its rank in decimal.
Each active input is only taken into consideration if, and only if, all entries of a higher
rank are inactive.
3.6. Transcoders
In addition to the encoder and the decoder, we can also distinguish the transcoder
that allows for the conversion of a given code to a different code.
3.6.1. Binary code and Gray code
Gray code (or reﬂected binary code) is used in angle or positional sensors and also
in applications where the likelihood of commutation errors is to be reduced.
Gray code is a code constructed such that the representation of two consecutive
numbers only differs by a single bit.
Table 3.24 shows the 4-bit binary Gray code conversion (or for the numbers from
0 to 15).

144
Digital Electronics 1
D
4
D6
D5
D8
D9
D7
Y3
Y2
Y1
Y0
D2
D3
1
D
Figure 3.34. 10:4 priority encoder (integrated circuit 74LS147)
3.6.1.1. Binary to Gray code converter
Logic equations associated with the Gray code bits can be determined by
observing that the bits G3 and B3 are identical and using Karnaugh maps represented
in Figures 3.35–3.37 in the case of G2, G1 and G0 bits, respectively.
Thus, the binary to Gray code converter is characterized by:
G3 = B3
[3.38]
G2 = B3 ⊕B2
[3.39]
G1 = B2 ⊕B1
[3.40]
G0 = B1 ⊕B0
[3.41]

Function Blocks of Combinational Logic
145
where ⊕represents the exclusive OR function. The corresponding logic circuit is
illustrated in Figure 3.38.
D1
D2
D3
D4
D5
D6
D7
D8
D9
Y3
Y2
Y1
Y0
1
1
1
1
1
1
1
1
1
1
1
1
1
x
x
x
x
x
x
x
x
0
0
1
1
0
x
x
x
x
x
x
x
0
1
0
1
1
1
x
x
x
x
x
x
0
1
1
1
0
0
0
x
x
x
x
x
0
1
1
1
1
0
0
1
x
x
x
x
0
1
1
1
1
1
0
1
0
x
x
x
0
1
1
1
1
1
1
0
1
1
x
x
0
1
1
1
1
1
1
1
1
0
0
x
0
1
1
1
1
1
1
1
1
1
0
1
0
1
1
1
1
1
1
1
1
1
1
1
0
Table 3.23. Truth table for the priority encoder 74LS147
Decimal
Binary code
Gray code
Number
B3
B2
B1
B0
G3
G2
G1
G0
0
0
0
0
0
0
0
0
0
1
0
0
0
1
0
0
0
1
2
0
0
1
0
0
0
1
1
3
0
0
1
1
0
0
1
0
4
0
1
0
0
0
1
1
0
5
0
1
0
1
0
1
1
1
6
0
1
1
0
0
1
0
1
7
0
1
1
1
0
1
0
0
8
1
0
0
0
1
1
0
0
9
1
0
0
1
1
1
0
1
10
1
0
1
0
1
1
1
1
11
1
0
1
1
1
1
1
0
12
1
1
0
0
1
0
1
0
13
1
1
0
1
1
0
1
1
14
1
1
1
0
1
0
0
1
15
1
1
1
1
1
0
0
0
Table 3.24. Binary and Gray code for numbers from 0 to 15

146
Digital Electronics 1
1
01
11
10
3
B
2
B
B1
3
B
2
B
B1
B0
00
01
11
10
B0
1
1
1
1
1
1
1
00
Figure 3.35. Representation of G2 = B3 · B2 + B3 · B2 = B3 ⊕B2
1
01
11
10
3
B
2
B
B1
3
B
2
B
B1
B0
00
01
11
10
B0
1
1
1
1
1
1
1
00
Figure 3.36. Representation of G1 = B2 · B1 + B2 · B1 = B2 ⊕B1
1
01
11
10
3
B
2
B
B1
3
B
2
B
B1
B0
00
01
11
10
B0
1
1
1
1
1
1
1
00
Figure 3.37. Representation of G0 = B1 · B0 + B1 · B0 = B1 ⊕B0

Function Blocks of Combinational Logic
147
B
2
B
B1
B0
2
G
G1
G0
3
G
3
Figure 3.38. Binary to Gray code converter
3.6.1.2. Gray code to binary converter
Logic equations for the Gray code to binary code converter can be deduced from
the conversion table given in Table 3.24. As the B3 and G3 bits are identical, the
construction of Karnaugh maps is only required for each of the following bits: B2,
B1 and B0 (see Figures 3.39–3.41). For the maps shown in Figures 3.40 and 3.41, we
have:
B1 = G3 · G2 · G1 + G3 · G2 · G1 + G3 · G2 · G1 + G3 · G2 · G1
= G3(G2 ⊕G1) + G3(G2 ⊕G1)
= G3 ⊕G2 ⊕G1
[3.42]
and
B0 = G3 · G2 · G1 · G0 + G3 · G2 · G1 · G0+
G3 · G2 · G1 · G0 + G3 · G2 · G1 · G0 + G3 · G2 · G1 · G0+
G3 · G2 · G1 · G0 + G3 · G2 · G1 · G0 + G3 · G2 · G1 · G0
= (G3 ⊕G2)G1 · G0+
(G3 ⊕G2)G1 · G0 + (G3 ⊕G2)G1 · G0 + (G3 ⊕G2)G1 · G0
= (G3 ⊕G2)(G1 ⊕G0) + (G3 ⊕G2)(G1 ⊕G0)
= G3 ⊕G2 ⊕G1 ⊕G0
[3.43]

148
Digital Electronics 1
1
01
11
10
3
G
2
G
G1
3
G
2
G
G1
G0
00
01
11
10
G0
1
1
1
1
1
1
1
00
Figure 3.39. Representation of B2 = G3 · G2 + G3 · G2 = G3 ⊕G2
0
01
11
10
3
G
2
G
G1
3
G
2
G
G1
G0
1
1
1
1
1
1
1
1
00
01
11
10
G
00
Figure 3.40. Representation of B1 = G3 ⊕G2 ⊕G1
The logic equations for the Gray code to binary code convertor are thus of the
form:
B3 = G3
[3.44]
B2 = G3 ⊕G2
[3.45]
B1 = G3 ⊕G2 ⊕G1
[3.46]
B0 = G3 ⊕G2 ⊕G1 ⊕G0
[3.47]
Using exclusive OR gates, the logic function illustrated in Figure 3.42 can be
implemented.

Function Blocks of Combinational Logic
149
1
01
11
10
3
G
2
G
G1
3
G
2
G
G1
G0
00
01
11
10
G0
1
1
1
1
1
1
1
00
Figure 3.41. Representation of B0 = G3 ⊕G2 ⊕G1 ⊕G0
1
3
G
2
G
B1
2
B
3
B
G0
G
B0
Figure 3.42. Gray code to binary code converter
3.6.2. BCD and excess-3 code
BCD corresponds to the representation in natural binary (here, with four bits of
weights 8, 4, 2 and 1) of each digit of a decimal number. It is used, for example, to
allow the content of a counter to be displayed.
The Excess-3 code (XS-3) is obtained by adding 3 to the decimal number to be
converted before representing it in BCD form. It is considered to be a complementary
BCD code as it also allows for the representation of both positive and negative
numbers.
3.6.2.1. BCD to XS-3 converter
Table 3.25 gives the conversion table for converting BCD to XS-3. As the
conversion only involves numbers from 0 to 9, the binary combinations associated

150
Digital Electronics 1
with the numbers from 10 to 15 can be considered to be don’t care terms. Based on
the conversion tables, Karnaugh maps of Figures 3.43–3.46 can be constructed to
determine the logic equations for the outputs X3, X2, X1, and X0, respectively.
Decimal
BCD code
XS-3 code
number
B3
B2
B1
B0
X3
X2
X1
X0
0
0
0
0
0
0
0
1
1
1
0
0
0
1
0
1
0
0
2
0
0
1
0
0
1
0
1
3
0
0
1
1
0
1
1
0
4
0
1
0
0
0
1
1
1
5
0
1
0
1
1
0
0
0
6
0
1
1
0
1
0
0
1
7
0
1
1
1
1
0
1
0
8
1
0
0
0
1
0
1
1
9
1
0
0
1
1
1
0
0
1
0
1
0
x
x
x
x
1
0
1
1
x
x
x
x
1
1
0
0
x
x
x
x
1
1
0
1
x
x
x
x
1
1
1
0
x
x
x
x
1
1
1
1
x
x
x
x
Table 3.25. BCD to XS-3 conversion table
x
01
11
10
3
B
2
B
B1
3
B
2
B
B1
B0
1
1
x
x
1
1
x
x
00
01
11
10
B0
1
x
00
Figure 3.43. Representation of X3 = B3 + B2 · B1 + B2 · B0

Function Blocks of Combinational Logic
151
1
01
11
10
3
B
2
B
B1
3
B
2
B
B1
B0
x
x
x
x
00
01
11
10
B0
x
x
1
1
1
1
00
Figure 3.44. Representation of X2 = B2 · B1 + B2 · B0 + B2 · B1 · B0
1
01
11
10
3
B
2
B
B1
3
B
2
B
B1
B0
x
x
x
x
00
01
11
10
B0
x
x
1
1
1
1
00
Figure 3.45. Representation of X1 = B1 · B0 + B1 · B0
We thus obtain:
X3 = B3 + B2 · B1 + B2 · B0
= B3 + B2(B1 + B0)
[3.48]
X2 = B2 · B1 + B2 · B0 + B2 · B1 · B0
= B2 ⊕(B1 + B0)
[3.49]
X1 = B1 · B0 + B1 · B0
= B1 ⊕B0
[3.50]

152
Digital Electronics 1
and:
X0 = B0
[3.51]
The logic circuit for a BCD to XS-3 converter can then be realized as illustrated in
Figure 3.47.
1
01
11
10
3
B
2
B
B1
3
B
2
B
B1
B0
00
01
11
10
B0
x
x
1
1
1
1
x
x
x
x
00
Figure 3.46. Representation of X0 = B0
1
1
B
2
B
3
B
0
B
X
X
X
3
2
0
X
Figure 3.47. BCD to XS-3 converter
3.6.2.2. XS-3 to BCD converter
The XS-3 to BCD conversion table is given in Table 3.26. Among the 16 binary
combinations that can be applied to the inputs (X3, X2, X1, and X0), only those
associated with the numbers 0 to 9 are used and the others are considered as don’t

Function Blocks of Combinational Logic
153
care terms. The logic equations for the outputs (B3, B2, B1, and B0) are obtained by
covering groups of adjacent cells in Karnaugh maps of Figures 3.48–3.51. We thus
have:
B3 = X3 · X2 + X3 · X1 · X0
= X3(X2 + X1 · X0)
[3.52]
B2 = X2 · X0 + X2 · X1 + X2 · X1 · X0
= X2 ⊕(X1 · X0) = X2 ⊕(X1 · X0)
[3.53]
B1 = X1 · X0 + X1 · X0
= X1 ⊕X0
[3.54]
and
B0 = X0
[3.55]
Decimal
XS-3 code
BCD code
number
X3
X2
X1
X0
B3
B2
B1
B0
0
0
0
1
1
0
0
0
0
1
0
1
0
0
0
0
0
1
2
0
1
0
1
0
0
1
0
3
0
1
1
0
0
0
1
1
4
0
1
1
1
0
1
0
0
5
1
0
0
0
0
1
0
1
6
1
0
0
1
0
1
1
0
7
1
0
1
0
0
1
1
1
8
1
0
1
1
1
0
0
0
9
1
1
0
0
1
0
0
1
1
1
0
1
x
x
x
x
1
1
1
0
x
x
x
x
1
1
1
1
x
x
x
x
0
0
0
0
x
x
x
x
0
0
0
1
x
x
x
x
0
0
1
0
x
x
x
x
Table 3.26. BCD to XS-3 conversion table
Using logic gates, the logic circuit of the XS-3 to BCD converter is realized as
shown in Figure 3.52.

154
Digital Electronics 1
x
01
11
10
3
X
2
X
X1
3
X
2
X
X1
X0
x
x
00
01
11
10
X0
1
x
1
x
x
00
Figure 3.48. Representation of B3 = X3 · X2 + X3 · X1 · X0
1
01
11
10
3
X
2
X
X1
3
X
2
X
X1
X0
x
x
x
x
00
01
11
10
X0
x
x
1
1
1
00
Figure 3.49. Representation of B2 = X2 · X0 + X2 · X1 + X2 · X1 · X0
1
01
11
10
3
X
2
X
X1
3
X
2
X
X1
X0
x
x
x
x
x
00
01
11
10
X0
x
1
1
1
00
Figure 3.50. Representation of B1 = X1 · X0 + X1 · X0

Function Blocks of Combinational Logic
155
x
01
11
10
3
X
2
X
X1
3
X
2
X
X1
X0
x
x
00
01
11
10
X0
x
1
1
1
1
x
x
1
00
Figure 3.51. Representation of B0 = X0
0
B
X0
X1
X3
X2
3
B
1
B
2
B
Figure 3.52. XS-3 to BCD converter
3.7. Parity check generator
Parity bits are bits that are added to data to be transmitted for error veriﬁcation
purposes. There are two types of parity: even and odd. The output of an even (odd)
parity generator is set either to 1 (0) if the number of bits set at the high logic level or
1 in the input word is odd, or to 0 (1) if this number is even.
EXAMPLE 3.1.– The concatenation of a parity bit with a given piece of data results in
a word that can have an odd number of bits at logic level 1 (or an even parity) or an
even number of bits at logic level 1 (or an odd parity). Hence, to generate the parity,
the number of bits at logic level 1 takes into account the parity bit, while for checking
the parity, the parity bit is excluded from the total number of bits at logic level 1 and
is only used to identify the type of parity. Table 3.27 presents three 8-bit words with
the corresponding parity bits.

156
Digital Electronics 1
Word with
Parity
8 bits
Even
Odd
00000000
0
1
00101000
0
1
01001100
1
0
Table 3.27. Example of three 8-bit words with parity bits
Parity is used in series communication systems and memories to detect
transmission errors due to noise. After errors resulting in the modiﬁcation of the logic
level of the parity bit are detected by a checker, it is possible to envisage a correction
by the retransmission of the data.
Table 3.28 gives the truth table of a parity generator for 4-bit words. The input
data are of the form D3D2D1D0, and the output variable is either PE (even parity)
or PO (odd parity). The Karnaugh map constructed based on the truth table, as shown
in Figure 3.53, allows for the determination of the logic expression for PE. We thus
have:
PE = D3 · D2 · D1 · D0 + D3 · D2 · D1 · D0
+ D3 · D2 · D1 · D0 + D3 · D2 · D1 · D0 + D3 · D2 · D1 · D0+
+ D3 · D2 · D1 · D0 + D3 · D2 · D1 · D0 + D3 · D2 · D1 · D0
[3.56]
or equivalently:
PE = (D3 · D2 + D3 · D2)D1 · D0 + (D3 · D2 + D3 · D2)D1 · D0
+ (D3 · D2 + D3 · D2)D1 · D0 + (D3 · D2 + D3 · D2)D1 · D0
= (D3 ⊕D2)(D1 ⊕D0) + (D3 ⊕D2)(D1 ⊕D0)
= D3 ⊕D2 ⊕D1 ⊕D0
[3.57]
As the two outputs PE and PO are complementary, it follows that:
PO = PE
[3.58]
Using XOR logic gates and an inverter, the logic circuit of a parity generator for
4-bit words is implemented as shown in Figure 3.54(a). Another version of the parity
generator is given in Figure 3.54(b). The XOR output gate is conﬁgured as an inverter
that can be programmed by the selection signal E/O; this is useful to verify either the
even parity, when E/O is set to 0, or the odd parity when E/O takes the logic level 1.

Function Blocks of Combinational Logic
157
D3
D2
D1
D0
PE
PO
0
0
0
0
0
1
0
0
0
1
1
0
0
0
1
0
1
0
0
0
1
1
0
1
0
1
0
0
1
0
0
1
0
1
0
1
0
1
1
0
0
1
0
1
1
1
1
0
1
0
0
0
1
0
1
0
0
1
0
1
1
0
1
0
0
1
1
0
1
1
1
0
1
1
0
0
0
1
1
1
0
1
1
0
1
1
1
0
1
0
1
1
1
1
0
1
Table 3.28. Truth table for a parity generator for 4-bit words
10
01
11
10
D1D0
3
D
2
D
D1
3
D
D0
2
D
1
1
0
0
0
1
0
1
1
0
1
0
1
1
0
0
00
01
11
00
Figure 3.53. Representation of PE = D3 ⊕D2 ⊕D1 ⊕D0

158
Digital Electronics 1
(b)
D
0
D
D3
D2
P E
P O
E/O
1
D
0
D
D3
D2
P E
P O
/
(a)
1
Figure 3.54. Parity generator a) with or b) without selection signal
The logic circuit shown in Figure 3.55 is a parity generator or checker that has
select inputs to choose the desired parity type. Signal P takes logic level 1 if the input
word contains an even number of bits set at 1. An analysis of the function table given
in Table 3.29, where x denotes the don’t care term, shows that each output signal (ΣE
or ΣO) can be active high or low depending on the combination of logic levels at the
select inputs.
O
D
0
D
D3
D2
5
D
4
D
D7
D6
S E
S O
P
Σ E
Σ
1
Figure 3.55. Parity generator/checker SN74180

Function Blocks of Combinational Logic
159
Inputs
Outputs
Number of bits,
D0 −D7, set to 1
SE
SO
ΣE
ΣO
Even
1
0
1
0
Odd
1
0
0
1
Even
0
1
0
1
Odd
0
1
1
0
x
1
1
0
0
x
0
0
1
1
Table 3.29. Table illustrating the operation of the
parity generator/controller
The conﬁguration shown in Figure 3.56(a), where the input SE is set to the logic
level 1 and connected by an inverter to the input SO, allows for the generation of
an even parity bit. The 9-bit words are formed by concatenating the parity bit and the
input word. The checker of even parity for 9-bit words is represented in Figure 3.56(b),
where the parity bit and the complement of the parity bit are connected to inputs SE
and SO, respectively. If an even parity exists, the output ΣE takes the logic level 1
while the output ΣO is set to 0.
(a)
O
S E
D3
D2
0
D
1
D
5
D
4
D
S O
S E
D3
D2
0
D
1
D
D7
D6
5
D
4
D
D7
D6
D8
Σ O
Σ O
(b)
Σ E
1
Σ E
S
Figure 3.56. a) Parity generator; b) parity checker for 9-bit words

160
Digital Electronics 1
3.8. Barrel shifter
A barrel shifter is a logic circuit that is used to shift data bits by a certain number
of positions to the left or right. There are logical shifts to the left or right, arithmetic
shift to the right and rotation (or circular shift) to the right or left.
For logical shift, movement toward either end of a binary word is carried out by
inserting 0-level bits at the other end, while for arithmetic shift, the sign bit or the
MSB is duplicated and inserted each time at the left end. This translates to a loss of
the bits originally at the ends of the binary words and whose number is equal to that
of positions to be shifted.
Carrying out the following operations on a 4-bit code of the form D3D2D1D0, we
obtain the following results:
– logic shift to the right by one position
0 D3D2D1
– logic shift to the left by one position
D2D1D0 0
– arithmetic shift to the right by one position D3D3D2D1
– rotation to the right by one position
D0D3D2D1
– rotation to the left by one position
D2D1D0D3
The barrel shifter is associated with the arithmetic and logic unit of some
microprocessors to ensure a fast execution of shift and rotation operations.
A barrel shifter can be implemented by combining a certain number of multiplexer
stages. Figure 3.57 shows the logic circuit of a barrel shift for 4-bit binary words. The
input stage ﬁrst reverses the order of data bits when L = 1. The intermediary stages
then implement the shift or rotation to the right operation. Finally, the output stage
carries out another inversion when L = 1 to yield the result. A 3-bit code (L, ROT
and SRA) allows for the selection of shift and rotation operations as illustrated by
Table 3.30, where x represents a don’t care term.
Selection code
L
ROT
SRA
Operation
0
0
0
Logic shift to the right
0
0
1
Logic shift to the right
0
1
x
Rotation to the right
1
0
0
1
0
1
Logic shift to the left
1
1
x
Rotation to the left
Table 3.30. Operations realized by the barrel shifter

Function Blocks of Combinational Logic
161
Right shift/rotation
3
D2
D1
D0
Y0
Y1
Y2
Y3
S 1
S 0
D3
 1
0
 1
0
 1
0
 1
0
 1
0
 1
0
 1
0
 1
0
 1
0
 1
0
 1
0
 1
0
 1
0
 1
0
 1
0
 1
0
 1
0
 1
0
 1
0
L
ROT
1
0
0
SRA
D
Figure 3.57. Barrel shifter for 4-bit binary words
The number of positions to be shifted is determined by a 2-bit code (S1 and S0).
The logic equations for the outputs can be written as follows:
Y0 = Q0 · L + Q3 · L
[3.59]
Y1 = Q1 · L + Q2 · L
[3.60]
Y2 = Q2 · L + Q1 · L
[3.61]
and
Y3 = Q3 · L + Q0 · L
[3.62]

162
Digital Electronics 1
where:
Q0 = (P0 · S1 + P2 · S1)S0 + (P1 · S1 + P3 · S1)S0
[3.63]
Q1 = (P1 · S1 + P3 · S1)S0+
[P2 · S1 + (D3 · SRA · ROT + P0 · ROT)S1]S0
[3.64]
Q2 = [P2 · S1 + (D3 · SRA · ROT + P0 · ROT)S1]S0+
[P3 · S1 + (D3 · SRA · ROT + P1 · ROT)S1]S0
[3.65]
Q3 = [P3 · S1 + (D3 · SRA · ROT + P1 · ROT)S1]S0+
[D3 · SRA · ROT + (P0 · S1 + P2 · S1) · ROT]S0
[3.66]
and we have:
P0 = D0 · L + D3 · L
[3.67]
P1 = D1 · L + D2 · L
[3.68]
P2 = D2 · L + D1 · L
[3.69]
P3 = D3 · L + D0 · L
[3.70]
Finally, we arrive at:
Y0 = D0 · S1 · S0 + (D1 · L + D3 · L · ROT)S1 · S0+
[D2(L + ROT) + D3 · L · SRA · ROT]S1 · S0+
(D1 · L · ROT + D3 · L)S1 · S0 [3.71]
Y1 = D0 · S1 · S0 + (D2 · L + D0 · L)S1 · S0+
D3(L + ROT + SRA)S1 · S0+
[(D0 · L + D2 · L)ROT + D3 · SRA · ROT]S1 · S0
[3.72]
Y2 = D2 · S1 · S0 + (D3 · L + D1 · L)S1 · S0+
[D0(L + ROT) + D3 · L · SRA · ROT]S1 · S0+
[(D1 · L + D3 · L)ROT + D3 · SRA · ROT]S1 · S0
[3.73]
and
Y3 = D3 · S1 · S0 + [D1(L + ROT) + D3 · L · SRA · ROT]S1 · S0+
D3 · L · SRA · ROT · S0 + (D0 · L · ROT + D2 · L)S1 · S0+
(D2 · L · ROT + D0 · L)S1 · S0 [3.74]

Function Blocks of Combinational Logic
163
Considering the input word, D3D2D1D0, and L as entered variables, we obtain
the truth table shown in Table 3.31.
Control inputs
Output bits
ROT SRA S1 S0 Y3
Y2
Y1
Y0
x
x
0
0
D3
D2
D1
D0
0
0
0
1
D2 · L
D3 · L + D1 · L D2 · L + D0 · L D1 · L
0
0
1
0
D1 · L
D0 · L
D3 · L
D2 · L
0
0
1
1
D0 · L
0
0
D3 · L
0
1
0
1
D3 · L + D2 · L D3 · L + D1 · L D2 · L + D0 · L D1 · L
0
1
1
0
D3 · L + D1 · L D3 · L + D0 · L D3
D2 · L + D3 · L
0
1
1
1
D3 · L + D0 · L D3
D3
D3 · L
1
x
0
1
D0 · L + D2 · L D3 · L + D1 · L D2 · L + D0 · L D1 · L + D3 · L
1
x
1
0
D1
D0
D3
D2
1
x
1
1
D2 · L + D0 · L D1 · L + D3 · L D0 · L + D2 · L D3 · L + D1 · L
Table 3.31. Truth table of the barrel shifter
A barrel shifter can also be implemented using the 4 : 1, 8 : 1, or 16 : 1
multiplexers. In general, increasing the size of the multiplexer makes it possible to
add control signals, and hence more features.
EXAMPLE 3.2.– Four-bit barrel shifter
Implement a 4-bit barrel shifter that can shift or rotate the input data bits to the
left. The barrel shifter is described by the following speciﬁcations:
– input data: X3 X2 X1 X0;
– control data:
R ∈{0, 1}: shift or rotate to the left;
A1 A0: number of positions to be shifted;
F ∈{0, 1}: bit to be inserted following shifting to the left.
– outputs: Y3 Y2 Y1 Y0.
Table 3.32 depicts the truth table of the 4-bit barrel shifter. The logic function for
each of the outputs Y3, Y2, Y1 and Y0 is characterized by each of the Karnaugh maps
shown in Figure 3.58. The logic circuit of the 4-bit barrel shifter is represented in
Figure 3.59, where an 8 : 1 multiplexer is required to implement the logic function for
each output.

164
Digital Electronics 1
R
A1
A0
Y3
Y2
Y1
Y0
0
0
0
X3
X2
X1
X0
Transfer
0
0
1
X2
X1
X0
F
sl1
0
1
0
X1
X0
F
F
sl2
0
1
1
X0
F
F
F
sl3
1
0
0
X3
X2
X1
X0
Transfer
1
0
1
X2
X1
X0
X3
rl1
1
1
0
X1
X0
X3
X2
rl2
1
1
1
X0
X3
X2
X1
rl3
Table 3.32. Truth table of the 4-bit barrel shifter
1
0
A1
A 0
A1
A 0
A1
A 0
A1
A 0
A1
A 0
A1
A 0
A1
A 0
A1
F
F
R
00
01
11
10
0
1
R
X 3
X 3
X 2
X 2
X 0
X1
X1
X 0
(a)
R
00
01
11
10
0
1
R
F
F
F
F
R
00
01
11
10
0
1
R
(c)
(d)
(b)
R
00
01
11
10
0
1
R
X
X 0
X 0
X
X 2
X 3
X 0
X 0
X 3
X1
X 2
X 0
X 0
X 3
X1
X 2
X
X1
2
1
A
Figure 3.58. Karnaugh maps: a) Y3; b) Y2; c) Y1 and d) Y0
3
3
X1
0
S
S
S
1
8:1 MUX
5 4
6
7
1 0
2
3
Y2
S2
S
S
0
8:1 MUX
5 4
6
7
1
1 0
2
3
R
A1
0
S
S
S2
1
8:1 MUX
5 4
6
7
1 0
2
3
Y1
0
S
S
S2
1
8:1 MUX
5 4
6
7
1 0
2
3
Y0
A0
2
F
X2
X0
X
Y
Figure 3.59. Four-bit barrel shifter

Function Blocks of Combinational Logic
165
3.9. Exercises
EXERCISE 3.1.– Implementation of logic gates using 2 : 1 multiplexer.
Show that the circuits in Figure 3.60(a)–3.60(d) are equivalent to the AND, OR,
XOR and NAND logic gates, respectively.
B
(a)
0
1
0
A
C
B
(b)
0
1
A
1
C
B
(d)
0
1
C
1
A
B
(c)
0
1
C
A
Figure 3.60. Logic circuits with multiplexers
EXERCISE 3.2.– Implementation of 2-out-of-4 decoder using 1-to-2 multiplexers.
(a)
1
Y0
Y0
Y1
S
D
1
0
Y2
Y3
Y0
Y1
D1
D0
S
D
(b)
1
0
1
0
1
0
(c)
EN
Y
Figure 3.61. 2 : 4 decoder based on 1-to-2 multiplexers
1) Verify that the logic circuit shown in Figure 3.61(a) implements a 1-to-2
demultiplexer, whose symbol is given in Figure 3.61(b).
2) To determine the function of the logic circuit illustrated in Figure 3.61(c), ﬁnd
the logic equations for the outputs and draw up the truth table.
EXERCISE 3.3.– Realization of 2-to-4 decoder using NAND gates.
To determine the role of the logic circuit shown in Figure 3.62, ﬁnd the logic
equations for the outputs and draw up the corresponding truth table.

166
Digital Electronics 1
0
Y0
D
D1
Y1
Y2
Y3
Figure 3.62. 2-out-of-4 encoder with NAND gates
EXERCISE 3.4.– 8 : 3 priority encoder.
To determine the role of the logic circuit shown in Figure 3.63, ﬁnd the logic
equations for the outputs and draw up the corresponding truth table.
D
0
1
D5
D6
D7
D4
0
1
D0
D1
D2
D3
Y0
Y1
Y2
0
1
0
1
V
B
C
A
Figure 3.63. 8:3 priority encoder
EXERCISE 3.5.– Implementation of the function F(A, B, C).
Implement the logic function F(A, B, C), which is characterized by the truth table
shown in Table 3.33 using a 2 : 1 multiplexer and logic gates to be determined.
EXERCISE 3.6.– 4-to-1 multiplexer.
Determine the logic equation for the output and construct the truth table for the
multiplexer shown in Figure 3.64.

Function Blocks of Combinational Logic
167
A
B
C
F
0
0
0
1
0
0
1
1
0
1
0
0
0
1
1
0
1
0
0
0
1
0
1
1
1
1
0
1
1
1
1
1
Table 3.33. Truth table of the function F(A, B, C)
MUX
0
D1
D2
3
D
S 0
S 1
S 1
S 0
Y
E
(a)
(b)
0
1
2
3
E
Y
D
Figure 3.64. a) 4-to-1 multiplexer with enable signal; b) symbol
Use a 4-to-1 multiplexer and logic gates to implement the function:
F(A, B, C, D) =

m(3, 4, 5, 6, 7, 9, 10, 12, 14, 15)
[3.75]
EXERCISE 3.7.– Demultiplexer/decoder.
Draw up the truth table for the decoder in Figure 3.65(a).
What is the difference between a decoder and demultiplexer?
Analyze the logic circuit shown in Figure 3.65(b) and determine the logic
equations for the outputs Zi(A, B, C, D) with i = 0, 1, 2, 3.

168
Digital Electronics 1
4:1  MUX
S 0
S 1
S 1
S 0
0
1
2
3
0
1
2
3
S 1
S 0
S 0
S 1
Z 2
Z 1
Z 0
3
Z
3
2
1
0
0
Y
E
C
D
(a)
(b)
Z 0
Z 1
Z 2
3
Z
E
E
E
B
A
1
2:4  DEC
2:4  DEC
Figure 3.65. a) 2 : 4 decoder with an enable input; b) logic circuit
EXERCISE 3.8.– Implementation of the function F(A, B, C, D).
Implement the function, F(A, B, C, D), whose logic expression is written as:
F(A, B, C, D) = A ⊕B ⊕C ⊕D
[3.76]
using a 4 : 1 multiplexer and logic gates to be determined.
EXERCISE 3.9.– Majority function of three variables.
The majority function, F, of three variables takes either the logic level 1, if the
majority (two or three) of the variables is at logic level 1, or the logic level 0 in all
other cases:
– construct the truth table of the function F;
– determine and simplify the logic equation for the function F;
– implement the function F using a 4 : 1 multiplexer.
EXERCISE 3.10.– 8-to-1 multiplexer.
Verify by determining the logic equation for the output and by constructing the
truth table when each of the logic circuits shown in Figure 3.66 works as an 8-to-1
multiplexer.

Function Blocks of Combinational Logic
169
Use an 8-to-1 multiplexer and and logic gates to implement the following function:
F(A, B, C, D, E) =

m(0, 1, 2, 4, 5, 6, 7, 13, 14, 20, 21, 22, 28, 29, 30, 31) [3.77]
(b)
0
D1
D2
D3
D4
D5
D6
D7
S 0
S 1
S 2
D0
D1
D2
D3
S 1
D4
D5
D6
D7
S 2
S 0
0
1
0
1
0
1
0
1
00
01
10
11
00
01
10
11
Y
00
01
10
11
0
1
Y
(a)
D
Figure 3.66. Implementation of an 8-to-1 multiplexer based on a) four
2-to-1 multiplexers or b) two 4-to-1 multiplexers
EXERCISE 3.11.– Implementation of a logic function based on a decoder
Implement the logic function:
F(A, B, C, D) =

m(1, 3, 7, 9, 15)
[3.78]
using a 3 : 8 decoder with enable input EN, a 5-input NAND gate and 2-input
NAND gates. The decoder has active-low outputs.
EXERCISE 3.12.– Analysis of a logic circuit.
Determine the logic equation for each of the outputs Yi (i = 0, 1, 2, · · · , 7) of the
logic circuit shown in Figure 3.67.
Draw up the truth table for this circuit.

170
Digital Electronics 1
D
0
Y
1
Y
2
Y
3
Y
4
Y
5
Y
6
Y
7
Y
4
D
0
D
3
D
2
D
1
D
7
D
6
D
5
Figure 3.67. Logic circuit
What is the role of this circuit?
EXERCISE 3.13.– Design of a multiplier for 2-bit binary words.
We wish to implement a multiplier according to the following speciﬁcations:
−inputs: X = X1X0 and Y = Y1Y0;
−output: Z = X · Y where Z = Z3Z2Z1Z0.
Construct the truth table for this multiplier.
Determine the Boolean expressions for each of the outputs Zi (i = 0, 1, 2, 3).
Implement this multiplier using logic gates.
EXERCISE 3.14.– Comparator for 2-bit binary numbers.
Implement a comparator for 2-bit numbers: P
= AB and Q = CD (see
Figure 3.68).
Draw up the truth table for this comparator.

Function Blocks of Combinational Logic
171
P
X (P>Q)
Y (P<Q)
Z (P=Q)
Comparator
Q
Figure 3.68. Comparator
Deduce and simplify the logic expressions for X, Y and Z.
Propose a logic circuit for the implementation of this comparator.
EXERCISE 3.15.– BCD-to-7-segment decoder.
A 4-bit number, A, B, C, D (D is the LSB), is applied to the inputs of the decoder
supplying the signals a, b, c, d, e, f and g that are used to drive a 7-segment display
(see Figure 3.69) generating numbers from 0 to 9.
Draw up the truth table for this decoder.
Deduce and simplify the logic expressions for a, b, c, d, e, f and g.
Propose a logic circuit that can be used to realize the decoder.
We will assume that the diodes of the display are controlled by low-level signals.
decoder
A
B
C
D
b
c
g
f
(b)
(a)
a
b
c
d
e
g
f
a
b
c
g
d
e
f
b
c
a
b
c
d
e
f
a
b
c
g
d
f
a
b
c
g
d
e
f
a
b
c
c
g
d
e
f
a
a
c
g
d
f
a
b
g
d
e
a
b
c
g
d
a
b
g
d
e
BCD−to−7−segment
Figure 3.69. a) BCD-to-7-segment decoder;
b) display of numbers from 0 to 9
EXERCISE 3.16.– HEX-to-7-segment decoder.
A number consisting of 4 bits, A, B, C and D (D is the LSB), is applied to the
inputs of the decoder supplying the signals a, b, c, d, e, f and g that are used to drive a
7-segment display (see Figure 3.70) generating the numbers from 0 to 9 and the letters
A–F corresponding to the hexadecimal representation of the numbers 10–15.

172
Digital Electronics 1
Draw up the truth table for the decoder, assuming that the diodes of the display are
controlled by low-level signals.
Deduce and simplify the logic expressions for a, b, c, d, e, f and g.
Propose a logic circuit that can be used to implement the decoder, using logic gates
with no more than four inputs.
decoder
A
B
C
D
b
c
g
f
a
b
c
d
e
f
a
b
c
g
e
f
b
c
a
b
g
d
e
a
b
c
g
d
a
b
g
d
e
c
g
d
e
f
a
a
c
g
d
f
a
b
c
a
b
c
g
d
f
c
g
d
e
f
a
g
e
f
a
b
g
d
e
f
b
c
g
d
e
a
d
e
f
a
b
c
g
d
e
f
(a)
(b)
a
b
c
g
d
e
f
a
b
c
d
e
g
f
HEX−to−7−segment
Figure 3.70. a) HEX-to-7-segment decoder; b) display of
numbers from 0 to 9 and letters A–F
EXERCISE 3.17.– Analysis of logic circuits:
– analyze the logic circuit shown in Figure 3.71 and determine its function. The
inputs are represented by X4, X3, X2, X1, X0 and X−1; the outputs by Y3, Y2, Y1
and Y0; and the control signals by D, S and E;
– same question for the logic circuit based on 2 : 1 multiplexers and which is
represented in Figure 3.72, where the data inputs are denoted by D7, D6, D5, D4, D3,
D2, D1 and D0; the outputs by Y7, Y6, Y5, Y4, Y3, Y2, Y1 and Y0; and the control
signals by S2, S1 and S0.
2
Y
0
Y
E
D
S
Y
4
X
3
X
2
X
1
X
0
X
−1
X
3
Y
1
Figure 3.71. Logic circuit 1

Function Blocks of Combinational Logic
173
0
3
Y2
Y1
Y0
S 0
S 1
S 2
D7
D6
D5
D4
D3
D2
D1
D0
 1
0
Y6
 1
0
Y5
 1
0
Y4
 1
0
 1
0
 1
0
 1
0
 1
0
Y7
 1
0
 1
0
 1
0
 1
0
 1
0
 1
0
 1
0
 1
0
 1
0
 1
0
 1
0
 1
0
 1
0
 1
0
 1
0
 1
0
Y
Figure 3.72. Logic circuit 2
3.10. Solutions
SOLUTION 3.1.– Implementation of a logic gate using 2 : 1 multiplexer.
A 2 : 1 multiplexer is characterized by a logic equation of the form:
Y = S · D0 + S · D1
[3.79]
where the data input is represented by D0 and D1, and the selection input by S.
– AND gate: D0 = 0, D1 = A, S = B and Y = A · B;
– OR gate: D0 = A, D1 = 1, S = B and Y = A · B + B = A + B;
– XOR gate: D0 = A, D1 = A, S = B and Y = A · B + A · B = A ⊕B;
– NAND gate: D0 = 1, D1 = B, S = A and Y = A + A · B = A + B = A · B.
SOLUTION 3.2.– Implementation of a 2-out-of 4 decoder using 1-to-2 demultiplexers
1) 1-to-2 demultiplexers
The logic equations for the output are given by:
Y0 = D · S
and
Y1 = D · S
[3.80]

174
Digital Electronics 1
2) 2-out-of-4 Decoder
The logic equations fo the outputs are written as:
Y0 = D1 · D0 · EN,
Y1 = D1 · D0 · EN,
Y2 = D1 · D0 · EN,
and
Y3 = D1 · D0 · EN
[3.81]
Table 3.34 gives the truth table of the 2-out-of-4 decoder.
S1
S0
Y3
Y2
Y1
Y0
0
0
0
0
0
EN
0
1
0
0
EN
0
1
0
0
EN
0
0
1
1
EN
0
0
0
Table 3.34. Truth table of the 2-out-of-4 decoder
SOLUTION 3.3.– Realization of 2-out-of-4 decoder using NAND gates.
The logic equations for the outputs can be written as:
Y0 = D1 · D0 · D1 · D0 · D1 · D0
= D1 · D0 + D1 · D0 + D1 · D0 = D1 + D0 = D1 · D0
[3.82]
Y1 = D1 · D0 · D0 = D1 · D0 + D0 = D1 + D0 = D1 · D0
[3.83]
Y2 = D1 · D1 · D0 = D1 + D1 · D0 = D1 + D0 = D1 · D0
[3.84]
and Y3 = D1 · D0
[3.85]
The truth table of the 2-out-of-4 decoder, as represented in Table 3.35,
corresponds to the case where outputs are active low.
D1
D0
Y3
Y2
Y1
Y0
0
0
1
1
1
0
0
1
1
1
0
1
1
0
1
0
1
1
1
1
0
1
1
1
Table 3.35. Truth table of the 2-out-of-2 decoder

Function Blocks of Combinational Logic
175
SOLUTION 3.4.– 8 : 3 priority encoder.
The logic equations for the outputs are given by:
V = D0 + D1 + D2 + D3 + D4 + D5 + D6 + D7
[3.86]
Y0 = A · Y2 + C · Y2
= [D1(D2 + D3) + D3(D2 + D3)](D4 + D5 + D6 + D7)
+ [D5(D6 + D7) + D7(D6 + D7)](D4 + D5 + D6 + D7)
= (D1 · D2 · D3 + D3 · D2 + D3)(D4 · D5 · D6 · D7)
+ (D5 · D6 · D7 + D6 · D7 + D7)(D4 + D5 + D6 + D7)
= D1 · D2 · D4 · D6 + D3 · D4 · D6 + D5 · D6 + D7
[3.87]
Y1 = B · Y2 + D · Y2
= (D2 + D3)(D4 + D5 + D6 + D7)
+ (D6 + D7)(D4 + D5 + D6 + D7)
= D2 · D4 · D5 + D3 · D4 · D5 + D6 + D7
[3.88]
and
Y2 = D4 + D5 + D6 + D7
[3.89]
Table 3.36 shows the truth table obtained from the logic equations of the 8 : 3
priority encoder. The highest priority is assigned to the input corresponding to the
highest decimal number. The validation output V is used to differentiate between the
case where the input code corresponds to 0 and the case where no input is active.
D7
D6
D5
D4
D3
D2
D1
D0
Y2
Y1
Y0
V
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
1
0
0
0
0
0
0
1
x
0
0
1
1
0
0
0
0
0
1
x
x
0
1
0
1
0
0
0
0
1
x
x
x
0
1
1
1
0
0
0
1
x
x
x
x
1
0
0
1
0
0
1
x
x
x
x
x
1
0
1
1
0
1
x
x
x
x
x
x
1
1
0
1
1
x
x
x
x
x
x
x
1
1
1
1
x
x
x
x
x
x
x
x
0
0
0
0
Table 3.36. Truth table of the 8 : 3 priority encoder

176
Digital Electronics 1
SOLUTION 3.5.– Implementation of the function F(A, B, C).
Analyzing the truth table shown in Table 3.37, we can deduce that the function F
can take the following form:
F(A, B, C) =
	
B
if
A = 0
B + C
if
A = 1
[3.90]
A
B
C
F
0
0
0
1
0
0
1
1
0
1
0
0
B
0
1
1
0
1
0
0
0
1
0
1
1
1
1
0
1
B + C
1
1
1
1
Table 3.37. Truth table of the logic function F
Similarly, using Shannon’s theorem, we can write:
F(A, B, C) = A · F(0, B, C) + A · F(1, B, C)
[3.91]
where F(0, B, C) = B and F(1, B, C) = B + C.
The logic function F can, thus, be implemented as shown in Figure 3.73 using a
2 : 1 multiplexer, an OR gate and an inverter.
F
1
B
A
C
0
Figure 3.73. Implementation of the logic function F

Function Blocks of Combinational Logic
177
SOLUTION 3.6.– 4-to-1 multiplexer.
The logic equation for the output of the multiplexer with enable signal is given by:
Y = S1 · S0 · D0 · E + S1 · S0 · D1 · E + S1 · S0 · D2 · E + S1 · S0 · D3 · E [3.92]
(c)
 1
S 0
.E
.E
S 1
S 0
S 0
S 1
0
1
1
1
1
x
0
0
1
1
x
0
1
0
1
0
3
D
D2
D1
D0
S 1 S 0
Y
(a)
E
D0
D1
D2
3
D
D0
1
1
0
0
.E
.E
D1
D2
3
D
E
Y
(b)
S
Figure 3.74. 4-to-1 multiplexer: a) logic circuit, b) truth table and
c) Karnaugh maps for the output Y
Implementation of the function F(A, B, C, D)
The logic function F(A, B, C, D) can be written as follows:
F(A, B, C, D) =

m(3, 4, 5, 6, 7, 9, 10, 12, 14, 15)
[3.93]
= A · B · C · D + A · B · C · D + A · B · C · D
+ A · B · C · D + A · B · C · D + A · B · C · D
+ A · B · C · D + A · B · C · D + A · B · C · D
+ A · B · C · D
[3.94]
= A · B · C · D + A · B(C · D + C · D + C · D + C · D)+
A · B(C · D + C · D) + A · B(C · D + C · D + C · D)
[3.95]
= A · B · C · D + A · B + A · B(C ⊕D) + A · B(C + D)
[3.96]

178
Digital Electronics 1
(a)
 1
S 0
D
C
F
Y
S
3
2
1
0
1
E
B
A
1
(b)
4:1  MUX
1
1
C.D
1
C
D
C
D
B
A
0
0
A
B
Figure 3.75. a) Karnaugh maps for F; b) logic circuit implementing F
SOLUTION 3.7.– Demultiplexer/decoder.
The following aspects make it possible to differentiate between a decoder and a
demultiplexer:
– n-out-of-2n decoder: n input data and 2n outputs;
– 1-to-2n demultiplexer: 1 data input, n select inputs and 2n outputs.
A decoder with enable input E operates like a demultiplexer if E is used as a data
input.
The logic equations for the outputs of the 2-out-of-4 decoders shown in Figure 3.76
are given by:
Z0 = S1 · S0 · E
[3.97]
Z1 = S1 · S0 · E
[3.98]
Z2 = S1 · S0 · E
[3.99]
Z3 = S1 · S0 · E
[3.100]
Table 3.38 gives the truth table of the 2-out-of-4 decoder.
Applying the data sequence D to input E, we can implement a 1-to-4
demultiplexer as shown in Figure 3.77. Table 3.39 gives the truth table of the 1-to-4
demultiplexer.

Function Blocks of Combinational Logic
179
E
S 0
S 1
Z 0
Z 1
Z 2
3
Z
Figure 3.76. 2-out-of-4 decoder
E
S1
S0
Z3
Z2
Z1
Z0
0
x
x
0
0
0
0
1
0
0
0
0
0
1
1
0
1
0
0
1
0
1
1
0
0
1
0
0
1
1
1
1
0
0
0
Table 3.38. Truth table of the 2-out-of-4 decoder
Analyzing the logic circuit made up of a 2-out-of-4 decoder, a 1-to-4 multiplexer
and logic gates makes it possible to obtain the logic equation of the multiplexer output:
Y = [ S1 · S0(C + D) + S1 · S0(0) + S1 · S0 · C + S1 · S0 · C · D ]E [3.101]
where E = 1, S0 = A and S1 = B, and the logic equations of the decoder outputs:
Z0 = S1 · S0 · E
[3.102]
Z1 = S1 · S0 · E
[3.103]
Z2 = S1 · S0 · E
[3.104]
Z3 = S1 · S0 · E
[3.105]

180
Digital Electronics 1
where E = Y , S0 = A ⊕B and S1 = A. Combining the above-mentioned equations,
we arrive at:
Z0 = A · B · C + A · B · D
[3.106]
Z1 = A · B · C
[3.107]
Z2 = A · B · C · D
[3.108]
Z3 = 0
[3.109]
D
Z 0
Z 1
3
Z
Z 2
S 0
S 1
Figure 3.77. 1-to-4 demultiplexer
S1
S0
Z3
Z2
Z1
Z0
0
0
0
0
0
D
0
1
0
0
D
0
1
0
0
D
0
0
1
1
D
0
0
0
Table 3.39. Truth table of the 1-to-4 demultiplexer
SOLUTION 3.8.– Implementation of the function F(A, B, C, D).
Using Shannon’s theorem, the logic function F may be decomposed as follows:
F(A, B, C, D) = A ⊕B ⊕C ⊕D
[3.110]
= (A ⊕B ⊕1 ⊕1)C · D + (A ⊕B ⊕1 ⊕0)C · D+
(A ⊕B ⊕0 ⊕1)C · D + (A ⊕B ⊕0 ⊕0)C · D
[3.111]

Function Blocks of Combinational Logic
181
= (A ⊕B)C · D + (A ⊕B)C · D+
(A ⊕B)C · D + (A ⊕B)C · D
[3.112]
Figure 3.78 shows the logic circuit for the implementation of the function F using
a 4 : 1 multiplexer, an XOR gate and an inverter.
B
C
D
10
01
00
11
F
A
Figure 3.78. Logic circuit for the function F
SOLUTION 3.9.– Majority function of three variables.
The truth table for the majority function of three variables is represented in
Table 3.40. Hence, we have:
F = A · B · C + A · B · C + A · B · C + A · B · C
[3.113]
= (A + A)B · C + A · B · C + A · B · C
= (B + B · A)C + A · B · C
= B · C + A(C + C · B)
= B · C + A · C + A · B
[3.114]
The truth table for the majority function of three variables is represented in
Table 3.40. Thus:
F = A · B · C + A · B · C + A · B · C + A · B · C
[3.115]
= (A + A)B · C + A · B · C + A · B · C
= (B + B · A)C + A · B · C
= B · C + A(C + C · B)
= B · C + A · C + A · B
[3.116]

182
Digital Electronics 1
A
B
C
F
0
0
0
0
0
0
1
0
0
1
0
0
0
1
1
1
1
0
0
0
1
0
1
1
1
1
0
1
1
1
1
1
Table 3.40. Truth table
Inserting different combinations of the variables A and B in the logic equation
for the function F makes it possible to construct the reduced truth table shown in
Table 3.41.
A
B
F
0
0
0
0
1
C
1
0
C
1
1
1
Table 3.41. Truth table
Figure 3.79 depicts the logic circuit that can be used to implement the majority
function of three variables.
F
10
11
01
00
A B
C
1
0
Figure 3.79. Logic circuit

Function Blocks of Combinational Logic
183
SOLUTION 3.10.– 8-to-1 multiplexer
For the ﬁrst circuit, we have:
Y = S2 · S1(D0 · S0 + D1 · S0) + S2 · S1(D2 · S0 + D3 · S0)
+S2 · S1(D4 · S0 + D5 · S0) + S2 · S1(D6 · S0 + D7 · S0)
[3.117]
and for the second, we have:
Y = S2(S1 · S0 · D0 + S1 · S0 · D1 + S1 · S0 · D2 + S1 · S0 · D3)
+S2(S1 · S0 · D4 + S1 · S0 · D5 + S1 · S0 · D6 + S1 · S0 · D7) [3.118]
In both cases, the logic equation for the output can be put into the following form:
Y = S2 · S1 · S0 · D0 + S2 · S1 · S0 · D1+
S2 · S1 · S0 · D2 + S2 · S1 · S0 · D3 + S2 · S1 · S0 · D4+
S2 · S1 · S0 · D5 + S2 · S1 · S0 · D6 + S2 · S1 · S0 · D7
[3.119]
Table 3.42 gives the truth table of the 8-to-1 multiplexer.
S0
S1
S0
Y
0
0
0
D0
0
0
1
D1
0
1
0
D2
0
1
1
D3
1
0
0
D4
1
0
1
D5
1
1
0
D6
1
1
1
D7
Table 3.42. Truth table of the 8-to-1 multiplexer
F(A, B, C, D, E) =

m(0, 1, 2, 4, 5, 6, 7, 13, 14, 20, 21, 22, 28, 29, 30, 31)
[3.120]
= A · B · C · D · E + A · B · C · D · E + A · B · C · D · E+
A · B · C · D · E + A · B · C · D · E + A · B · C · D · E+
A · B · C · D · E + A · B · C · D · E + A · B · C · D · E+

184
Digital Electronics 1
A · B · C · D · E + A · B · C · D · E + A · B · C · D · E+
A · B · C · D · E + A · B · C · D · E + A · B · C · D · E+
A · B · C · D · E
[3.121]
= (A · B · C + A · B · C)(D · E + D · E + D · E)+
(A · B · C + A · B · C)(D · E + D · E + D · E + D · E)+
A · B · C(D · E + D · E)
[3.122]
and:
F(A, B, C, D, E) = (A · B · C + A · B · C)(D · E)+
(A · B · C + A · B · C)(1) + A · B · C(D ⊕E)
[3.123]
Choosing A, B and C, as selection inputs, we can obtain the Karnaugh map shown
in Figure 3.80(a) that can be used to determine the combination of variables to be
applied to the data inputs of the multiplexer. Figure 3.80(b) depicts the logic circuit
that can be used to implement the function F.
7
D
D.E
D.E
D
E
S 2
S 0
C
S 1
F
Y
E
0
1
(b)
01
1
1
A
0
A
BC
00
11
10
C
1
0
0
0
B
(a)
0
2
3
4
A
B
8:1  MUX
6
5
1
Figure 3.80. Implementation of F: a) Karnaugh map; b) logic circuit

Function Blocks of Combinational Logic
185
SOLUTION 3.11.– Implementation of a logic function using a decoder.
The logic function F can be expressed in the following form:
F(A, B, C, D) =

m(1, 3, 7, 9, 15)
[3.124]
= A · B · C · D + A · B · C · D+
A · B · C · D + A · B · C · D + A · B · C · D
[3.125]
To implement the function F using NAND logic gates and a 3 : 8 decoder whose
logic equations can be written as follows:
Y0 = X2 · X1 · X0 · EN
Y1 = X2 · X1 · X0 · EN
Y2 = X2 · X1 · X0 · EN
Y3 = X2 · X1 · X0 · EN
Y4 = X2 · X1 · X0 · EN
Y5 = X2 · X1 · X0 · EN
Y6 = X2 · X1 · X0 · EN
Y7 = X2 · X1 · X0 · EN
[3.126]
we observe that:
F = Y0 + Y1 + Y3 + Y4 + Y7
[3.127]
= Y0 · Y1 · Y3 · Y4 · Y7
[3.128]
where:
Y0 = A · B · C · D
Y1 = A · B · C · D
Y3 = A · B · C · D
Y4 = A · B · C · D
Y7 = A · B · C · D
[3.129]
Figure 3.81 gives the logic circuit that can be used to realize the function F.
DEC
Y7
Y6
Y5
Y4
Y3
Y2
Y1
Y0
F
EN
X2
X1
X0
D
C
B
A
Figure 3.81. Implementation of the logic function F

186
Digital Electronics 1
SOLUTION 3.12.– Analysis of a logic circuit.
The output equations obtained by analyzing the proposed logic circuit are given
by:
Y7 = D7
[3.130]
Y6 = D7 · D6
[3.131]
Y5 = D7 · D6 · D5
[3.132]
Y4 = D7 · D6 · D5 · D4
[3.133]
Y3 = D7 · D6 · D5 · D4 · D3
[3.134]
Y2 = D7 · D6 · D5 · D4 · D3 · D2
[3.135]
Y1 = D7 · D6 · D5 · D4 · D3 · D2 · D1
[3.136]
and:
Y0 = D7 · D6 · D5 · D4 · D3 · D2 · D1 · D0
[3.137]
The truth table based on the logic equations for the outputs is given in Table 3.43.
D7
D6
D5
D4
D3
D2
D1
D0
Y7
Y6
Y5
Y4
Y3
Y2
Y1
Y0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
1
0
0
0
0
0
0
1
x
0
0
0
0
0
0
1
0
0
0
0
0
0
1
x
x
0
0
0
0
0
1
0
0
0
0
0
0
1
x
x
x
0
0
0
0
1
0
0
0
0
0
0
1
x
x
x
x
0
0
0
1
0
0
0
0
0
0
1
x
x
x
x
x
0
0
1
0
0
0
0
0
0
1
x
x
x
x
x
x
0
1
0
0
0
0
0
0
1
x
x
x
x
x
x
x
1
0
0
0
0
0
0
0
Table 3.43. Truth table
This is a priority selector that can be connected to an 8 : 3 encoder in order to
realize an 8 : 3 priority encoder.

Function Blocks of Combinational Logic
187
SOLUTION 3.13.– Design of a multiplier for 2-bit words.
Referring to the truth table shown in Table 3.44, we can obtain the following logic
equations:
Z0 = X1 · X0 · Y1 · Y0 + X1 · X0 · Y1 · Y0 + X1 · X0 · Y1 · Y0
+ X1 · X0 · Y1 · Y0
= X0 · Y0
[3.138]
Z1 = X1 · X0 · Y1 · Y0 + X1 · X0 · Y1 · Y0 + X1 · X0 · Y1 · Y0
+ X1 · X0 · Y1 · Y0 + X1 · X0 · Y1 · Y0 + X1 · X0 · Y1 · Y0
= X1 · X0 · Y1 + X0 · Y1 · Y0 + X1 · X0 · Y0 + X1 · Y1 · Y0
[3.139]
Z2 = X1 · X0 · Y1 · Y0 + X1 · X0 · Y1 · Y0 + X1 · X0 · Y1 · Y0
= X1 · X0 · Y1 + X1 · Y1 · Y0
[3.140]
and
Z3 = X1 · X0 · Y1 · Y0
[3.141]
X · Y = Z
X
Y
Z
X1
X0
Y1
Y0
Z3
Z2
Z1
Z0
0 · 0 = 0
0
0
0
0
0
0
0
0
0 · 1 = 0
0
0
0
1
0
0
0
0
0 · 2 = 0
0
0
1
0
0
0
0
0
0 · 3 = 0
0
0
1
1
0
0
0
0
1 · 0 = 0
0
1
0
0
0
0
0
0
1 · 1 = 1
0
1
0
1
0
0
0
1
1 · 2 = 2
0
1
1
0
0
0
1
0
1 · 3 = 3
0
1
1
1
0
0
1
1
2 · 0 = 0
1
0
0
0
0
0
0
0
2 · 1 = 2
1
0
0
1
0
0
1
0
2 · 2 = 4
1
0
1
0
0
1
0
0
2 · 3 = 6
1
0
1
1
0
1
1
0
3 · 0 = 0
1
1
0
0
0
0
0
0
3 · 1 = 3
1
1
0
1
0
0
1
1
3 · 2 = 6
1
1
1
0
0
1
1
0
3 · 3 = 9
1
1
1
1
1
0
0
1
Table 3.44. Truth table of a multiplier for 2-bit words
These equations can then be used to construct the logic circuit of a multiplier for
2-bit words as shown in Figure 3.82.

188
Digital Electronics 1
Z0
Z1
Z2
Z3
Y
Y
X0
1
0
X1
Figure 3.82. Multiplier for 2-bit words
SOLUTION 3.14.– Comparator for 2-bit numbers.
For the outputs of the comparator, the logic equations obtained from the truth table
shown in Table 3.45 are given by:
X = A · B · C · D + A · B · C · D + A · B · C · D
+ A · B · C · D + A · B · C · D + A · B · C · D
= A · B · C · D + A · C(B · D + B · D + B · D + B · D) + A · B · C · D
= A · C + A · B · D + B · C · D
[3.142]
Y = A · B · C · D + A · B · C · D + A · B · C · D
+ A · B · C · D + A · B · C · D + A · B · C · D
= A · B · C · D + A · C(B · D + B · D + B · D + B · D) + A · B · C · D
= A · C + A · B · D + B · C · D
[3.143]
and
Z = A · B · C · D + A · B · C · D + A · B · C · D + A · B · C · D
[3.144]

Function Blocks of Combinational Logic
189
A
B
C
D
X
Y
Z
0
0
0
0
0
0
1
0
0
0
1
0
1
0
0
0
1
0
0
1
0
0
0
1
1
0
1
0
0
1
0
0
1
0
0
0
1
0
1
0
0
1
0
1
1
0
0
1
0
0
1
1
1
0
1
0
1
0
0
0
1
0
0
1
0
0
1
1
0
0
1
0
1
0
0
0
1
1
0
1
1
0
1
0
1
1
0
0
1
0
0
1
1
0
1
1
0
0
1
1
1
0
1
0
0
1
1
1
1
0
0
1
Table 3.45. Truth table of a comparator for 2-bit numbers
It should be noted that:
B · D + B · D + B · D + B · D = 1
Figure 3.83 depicts the logic circuit of the comparator for 2-bit numbers.
SOLUTION 3.15.– BCD-to-7-segment decoder.
Table 3.46 presents the truth table of the BCD-to-7-segment decoder that can be
used to determine the output logic equations.
Thus, for each of the outputs we have:
a =

m(0, 2, 3, 5, 6, 7, 8, 9)
[3.145]
b =

m(0, 1, 2, 3, 4, 7, 8, 9)
[3.146]
c =

m(0, 1, 3, 4, 5, 6, 7, 8, 9)
[3.147]
d =

m(0, 2, 3, 5, 6, 8, 9)
[3.148]
e =

m(0, 2, 6, 8)
[3.149]
f =

m(0, 4, 5, 6, 8, 9)
[3.150]
and
g =

m(2, 3, 4, 5, 6, 8, 9)
[3.151]

190
Digital Electronics 1
X
Y
Z
B
A
C
D
Figure 3.83. Logic circuit of a comparator for 2-bit numbers
Because the LEDs are driven by low-level signals, the minimal form in the sum of
products is obtained by constructing the corresponding Karnaugh maps in the
complemented forms for each of output variables (see Figures 3.84–3.90).
The logic circuit for the BCD-to-7-segment decoder is represented in Figure 3.91.
SOLUTION 3.16.– HEX-to-7-segment decoder.
The number of hexadecimal digits to be represented, that is 16, is equal to
number
of
possible
combinations
with
four
bits.
The
truth
table
of
the
HEX-to-7-segment decoder can be constructed as shown in Table 3.47. We can then
obtain the following logic equations:
a =

m(1, 4, 11, 13)
[3.152]
b =

m(5, 6, 11, 12, 15)
[3.153]

Function Blocks of Combinational Logic
191
c =

m(2, 12, 14, 15)
[3.154]
d =

m(1, 4, 7, 10, 15)
[3.155]
e =

m(1, 3, 4, 5, 7, 9)
[3.156]
f =

m(1, 2, 3, 7, 13)
[3.157]
and
g =

m(0, 1, 7, 12)
[3.158]
Symbole
A
B
C
D
a
b
c
d
e
f
g
0
0
0
0
0
1
1
1
1
1
1
0
1
0
0
0
1
0
1
1
0
0
0
0
2
0
0
1
0
1
1
0
1
1
0
1
3
0
0
1
1
1
1
1
1
0
0
1
4
0
1
0
0
0
1
1
0
0
1
1
5
0
1
0
1
1
0
1
1
0
1
1
6
0
1
1
0
1
0
1
1
1
1
1
7
0
1
1
1
1
1
1
0
0
0
0
8
1
0
0
0
1
1
1
1
1
1
1
9
1
0
0
1
1
1
1
1
0
1
1
−
1
0
1
0
x
x
x
x
x
x
x
−
1
0
1
1
x
x
x
x
x
x
x
−
1
1
0
0
x
x
x
x
x
x
x
−
1
1
0
1
x
x
x
x
x
x
x
−
1
1
1
0
x
x
x
x
x
x
x
−
1
1
1
1
x
x
x
x
x
x
x
Table 3.46. Truth table of the BCD-to-7-segment decoder
D
01
11
10
0
1
1
x
1
1
x
x
1
1
x
x
0
x
1
1
AB
CD
C
00
01
11
10
B
A
00
Figure 3.84. Signal a:
a = A + C + B · D + B · D
a = B · C · D + A · B · C · D

192
Digital Electronics 1
D
01
11
10
1
1
1
x
1
1
x
x
1
0
x
x
1
x
1
0
AB
CD
C
00
01
11
10
B
A
00
Figure 3.85. Signal b:
b = B + C · D + C · D
b = B · C · D + B · C · D
D
01
11
10
1
1
1
x
1
1
x
x
0
1
x
x
1
x
1
1
AB
CD
C
00
01
11
10
B
A
00
Figure 3.86. Signal c:
c = B + C + D
c = B · C · D
D
01
11
10
0
1
1
x
1
0
x
x
1
1
x
x
0
x
1
1
AB
CD
C
00
01
11
10
B
A
00
Figure 3.87. Signal d:
d = A + B · C + B · D + C · D + B · C · D
d = B · C · D + B · C · D + A · B · C · D

Function Blocks of Combinational Logic
193
D
01
11
10
0
1
1
x
0
0
x
x
1
1
x
x
0
x
0
0
AB
CD
C
00
01
11
10
B
A
00
Figure 3.88. Signal e:
e = B · D + C · D
e = D + B · C
D
01
11
10
1
1
1
x
0
0
x
x
0
1
x
x
0
x
1
1
AB
CD
C
00
01
11
10
B
A
00
Figure 3.89. Signal f:
f = A + B · C + B · D + C · D
f = B · C + C · D + A · B · D
D
01
11
10
1
1
0
x
1
0
x
x
1
1
x
x
0
x
1
1
AB
CD
C
00
01
11
10
B
A
00
Figure 3.90. Signal g:
g = A + B · C + B · C + C · D
g = A · B · C + B · C · D

194
Digital Electronics 1
d
a
b
e
f
c
g
A
B
C
D
Figure 3.91. BCD-to-7-segment decoder

Function Blocks of Combinational Logic
195
Symbol
A
B
C
D
a
b
c
d
e
f
g
0
0
0
0
0
0
0
0
0
0
0
1
1
0
0
0
1
1
0
0
1
1
1
1
2
0
0
1
0
0
0
1
0
0
1
0
3
0
0
1
1
0
0
0
0
1
1
0
4
0
1
0
0
1
0
0
1
1
0
0
5
0
1
0
1
0
1
0
0
1
0
0
6
0
1
1
0
0
1
0
0
0
0
0
7
0
1
1
1
0
0
0
1
1
1
1
8
1
0
0
0
0
0
0
0
0
0
0
9
1
0
0
1
0
0
0
0
1
0
0
A
1
0
1
0
0
0
0
1
0
0
0
b
1
0
1
1
1
1
0
0
0
0
0
C
1
1
0
0
0
1
1
0
0
0
1
d
1
1
0
1
1
0
0
0
0
1
0
e
1
1
1
0
0
0
1
0
0
0
0
F
1
1
1
1
0
1
1
1
0
0
0
Table 3.47. Truth table of the HEX-to-7-segment decoder
The Karnaugh maps shown in Figures 3.92–3.98 allow for the simpliﬁcation of the
logic equations for the decoder outputs.
D
01
11
10
1
0
0
0
0
0
0
1
0
0
0
0
1
1
0
0
AB
CD
C
00
01
11
10
B
A
00
Figure 3.92. Signal a:
a = A · B · C · D + A · B · C · D+ A · B · C · D + A · B · C · D

196
Digital Electronics 1
D
01
11
10
0
0
0
1
0
0
1
1
0
1
1
0
0
0
0
1
AB
CD
C
00
01
11
10
B
A
00
Figure 3.93. Signal b: b = A · C · D + A · B · D+ B · C · D + A · B · C · D
D
01
11
10
0
0
0
1
0
0
1
0
1
0
1
0
0
0
0
0
AB
CD
C
00
01
11
10
B
A
00
Figure 3.94. Signal c: c = A · B · C + A · B · D+
A · B · C · D
D
01
11
10
1
0
0
0
0
1
1
0
0
0
0
1
1
0
0
0
AB
CD
C
00
01
11
10
B
A
00
Figure 3.95. Signal d:
d = B · C · D + A · B · C · D+ A · B · C · D + A · B · C · D

Function Blocks of Combinational Logic
197
D
01
11
10
1
0
0
0
1
1
0
0
0
0
0
0
1
0
1
1
AB
CD
C
00
01
11
10
B
A
00
Figure 3.96. Signal e:
e = A · D + A · B · C+ B · C · D
D
01
11
10
0
0
0
0
1
1
0
0
1
0
0
0
1
1
0
0
AB
CD
C
00
01
11
10
B
A
00
Figure 3.97. Signal f : f = A · C · D + A · B · D+ A · B · C + A · B · C · D
D
01
11
10
0
0
1
1
0
1
0
0
0
0
0
0
1
0
0
0
AB
CD
C
00
01
11
10
B
A
00
Figure 3.98. Signal g:
g = A · B · C + A · B · C · D+ A · B · C · D

198
Digital Electronics 1
To reduce the number of logic gates, the logic equations of some outputs can be
rewritten to bring out the common terms. The logic equation for the output b can be
put into the form:
b = A · C · D + A · B · D + B · C · D + A · B · C · D
[3.159]
= A · C · D + A · B · (C + C) · D + B · C · D + A · B · C · D
= A · C · D + A · B · C · D + (1 + A) · B · C · D + A · B · C · D
= A · C · D + A · B · C · D + B · C · D + A · B · C · D
[3.160]
For the output c, we have:
c = A · B · C + A · B · D + A · B · C · D
[3.161]
= A · B · C + A · B · (C + C) · D + A · B · C · D
= A · B · C · (1 + D) + A · B · C · D + A · B · C · D
= A · B · C + A · B · C · D + A · B · C · D
[3.162]
Another form of the logic equation for the output e can be obtained based on the
Karnaugh map represented in Figure 3.99. This reveals the common term A · C · D,
instead of the term A · D, and is written as follows:
e = A · C · D + A · B · C · (D + D) + B · C · D
[3.163]
= A · C · D + A · B · C · D + A · B · C · D + B · C · D
[3.164]
D
01
11
10
1
0
0
0
1
1
0
0
0
0
0
0
1
0
1
1
AB
CD
C
00
01
11
10
B
A
00
Figure 3.99. Signal e:
e = A · C · D + A · B · C+ B · C · D

Function Blocks of Combinational Logic
199
The logic equation for the output f can be rewritten as:
f = A · C · D + A · B · D + A · B · C + A · B · C · D
[3.165]
= A · C · D + A · B · (C + C) · D + A · B · C + A · B · C · D
= A · C · D + A · B · C · D + A · B · C · (1 + D) + A · B · C · D
= A · C · D + A · B · C · D + A · B · C + A · B · C · D
[3.166]
Figure 3.100 depicts the logic circuit for the HEX-to-7-segment decoder.
SOLUTION 3.17.– Analysis of logic circuits.
1) For the 1-bit barrel shifter, we have:
– inputs: X4, X3, X2, X1, X0, X−1;
– outputs: Y3, Y2, Y1, Y0;
– enable signal E;
– signal D:
D =
	
1
for a shift to left
0
for a shift to right
– signal S to indicate the number of positions to be shifted.
The truth table of the 1-bit barrel shifter is represented in Table 3.48, where:
X−1 =
⎧
⎪
⎨
⎪
⎩
0
for a shift to the left with insertion of 0
1
for a shift to the left with insertion of 1
X3
for a rotation to the left
and
X4 =
⎧
⎪
⎨
⎪
⎩
0
for a shift to the right with insertion of 0
1
for a shift to the right with insertion of 1
X0
for a rotation to the right
E
S
D
Y3
Y2
Y1
Y0
0
x
x
0
0
0
0
1
0
x
X3
X2
X1
X0
1
1
0
X4
X3
X2
X1
1
1
1
X3
X2
X1
X−1
Table 3.48. Truth table of the barrel shifter

200
Digital Electronics 1
a
c
e
g
b
d
f
D
C
B
A
Figure 3.100. HEX-to-7-segment decoder
2) The barrel shifter for right-shift operations can be characterized by:
– inputs: D7, D6, D5, D4, D3, D2, D1, D0;
– outputs: Y7, Y6, Y5, Y4, Y3, Y2, Y1, Y0;
– the number of positions to be shifted: S2, S1, S0.

Function Blocks of Combinational Logic
201
Based on the analysis of the logic circuit, the truth table of the barrel shifter can be
constructed as shown in Table 3.49.
S2
S1
S0
Y7
Y6
Y5
Y4
Y3
Y2
Y1
Y0
0
0
0
D7
D6
D5
D4
D3
D2
D1
D0
0
0
1
0
D7
D6
D5
D4
D3
D2
D1
0
1
0
0
0
D7
D6
D5
D4
D3
D2
0
1
1
0
0
0
D7
D6
D5
D4
D3
1
0
0
0
0
0
0
D7
D6
D5
D4
1
0
1
0
0
0
0
0
D7
D6
D5
1
1
0
0
0
0
0
0
0
D7
D6
1
1
1
0
0
0
0
0
0
0
D7
Table 3.49. Truth table of the barrel shifter for right-shift operations


4
Systematic Methods for the
Simpliﬁcation of Logic Functions
4.1. Introduction
Manipulating Karnaugh maps can prove a difﬁcult task for logic functions of
more than six variables. Most often, systematic methods of simpliﬁcation such as the
Quine–McCluskey method or the iterated consensus method are used to ﬁnd
minimized forms for functions with a large number of variables. These methods are
especially useful because they can be converted into algorithms or computer-aided
design software. A logic function of n variables can have up to 2n minterms and
3n/n prime implicants. The implementation of methods that require the enumeration
of all the minterms and the determination of the prime implicants seems to be limited
by the calculation and storage capacity that is excessively high when the number of
variables increases. For this reason, functions with a large number of variables are
minimized using iterative heuristic methods such as the Espresso algorithm.
4.2. Deﬁnitions and reminders
Consider the following logic function:
F(A, B, C, D) =

m(2, 3, 4, 5, 6, 7, 9, 11, 12, 13)
[4.1]
The minimized form of the function F can be obtained using the Karnaugh map
shown in Figure 4.1(a). That is:
F(A, B, C, D) = A · C + B · C + A · B · D
[4.2]
Digital Electronics 1: Combinational Logic Circuits, First Edition. Tertulien Ndjountche.
© ISTE Ltd 2016. Published by ISTE Ltd and John Wiley & Sons, Inc.

204
Digital Electronics 1
D
01
11
10
00
01
11
10
AB
CD
C
00
01
11
10
B
A
D
1
0
0
1
1
1
0
1
1
1
0
0
0
1
1
1
1
0
0
1
1
1
0
1
1
1
0
0
0
1
1
1
(a)
(b)
AB
CD
C
00
01
11
10
B
A
00
Figure 4.1. Karnaugh map for F(A, B, C, D)
4.2.1. Deﬁnitions
Any single logic state 1 or group of 1s that can be combined on a Karnaugh map for
a logic function represents a term (or product of variables) that is called an implicant.
In general, for a logic function F of n variables, a minterm mi is an implicant if,
for all combination of logic levels of the n variables for which mi takes the logic state
1, F is also at logic state 1.
A prime implicant for a logic function is a term that cannot be combined with
another term to eliminate a variable.
A prime implicant is said to be essential if it is the only one to cover (or include)
one or more minterms.
4.2.2. Minimization principle of a logic function
The objective of minimizing a logic function is to determine the smallest number
of prime implicants that, together, cover all the minterms for this function. The
minimized form of a logic function contains all the essential prime implicants.
The prime implicants and the essential prime implicants for a logic function can
be determined from a Karnaugh map. A single 1 represents a prime implicant if there
is no other 1 neighboring it. Two neighboring 1s represent a prime implicant if they
cannot be contained in a group of four 1s, four neighboring 1s form a prime implicant
if they cannot be included in a group of eight 1s and so on.
In the speciﬁc case of the function that is deﬁned by equation [4.1], the Karnaugh
map shown in Figure 4.1(b) can be used to obtain the following prime implicants:
A · C, B · C, A · B · D, A · B, A · C · D and
B · C · D.

Systematic Methods for the Simpliﬁcation of Logic Functions
205
The essential prime implicants are A · C and B · C.
In general, as each minterm is covered by at least one of the prime implicants, a
logic function is equal to the sum of its prime implicants. Thus, the function F can be
expressed in the form:
F(A, B, C, D) = A · B + A · C + B · C + A · B · D + A · C · D + B · C · D [4.3]
Equation [4.3] does not have a minimal number of terms and it is, consequently,
not the minimized sum-of-products form. However, each of its terms has a minimum
number of variables.
4.3. Karnaugh maps
The use of a Karnaugh map can be extended to logic functions of more than four
variables. However, in practice, the manipulation of a Karnaugh map only proves to
be easy for up to six variables.
To determine the minimized sum-of-products or product-of-sums form for a given
logic function using a Karnaugh map, it is necessary to:
1) express the function in the form of the sum of its minterms or maxterms;
2) place a 1 (or 0) in the appropriate cell for each minterm (or maxterm);
3) cover all the 1s (or 0s) using a minimum number of the largest possible loops
that encompass 2p cells, p being an integer, while also ensuring that each 1 (or 0) is
part of at least one loop. It is preferable to identify the possible loops by beginning
with the cells that can be grouped in only one way;
4) form the simpliﬁed expression for the logic function by summing (or
multiplying) the terms obtained for the different loops. It must be noted that the term
associated with a loop enclosing 2p cells is obtained by eliminating the p variables
that change logic state.
4.3.1. Function of ﬁve variables
In the case of a logic function of ﬁve variables, the Karnaugh map consists of 32
(or 25) cells bearing the numbers from 0 to 31.
The direct approach to constructing a Karnaugh map consists of dividing the
variables into two groups of terms that are ordered horizontally and vertically
according to reﬂected binary code (or Gray code) to mark each cell. The ﬁve-variable
Karnaugh map obtained in this manner has two symmetrical axes, as shown in

206
Digital Electronics 1
Figure 4.2. The ﬁrst column and the eighth column are adjacent as are the second and
seventh columns, the third and sixth columns, and the fourth and ﬁfth columns.
DE
27
26
25
28
31
30
29
20
23
22
21
16
19
17
18
0
3
2
1
4
7
6
5
12
15
14
13
8
11
10
9
00
01
11
10
E
A
C
C
ABC
D
001
000
010
011
110
111
101
100
B
24
Figure 4.2. Five-variable Karnaugh map: symmetrical presentation
A ﬁve-variable Karnaugh map can also be constructed based on a layered
three-dimensional representation of two diagrams of four variables as given in
Figure 4.3(a), or based on a bidimensional and asymmetrical representation as
illustrated in Figure 4.3(b). In each case, we have one map for A (A = 0) and
another for A (A = 1). In general, two cells are adjacent when they correspond to
minterms that only differ by one variable. Thus, each cell in one of the maps is
adjacent to a corresponding cell on the other map.
(b)
01
11
10
00
01
11
10
A
16
19
18
17
20
23
22
21
28
31
30
29
24
27
26
25
00
01
11
10
00
01
11
10
8
11
10
9
0
3
2
1
4
6
5
7
12
15
14
13
BC
DE
D
C
E
B
0
3
2
1
4
7
6
5
12
15
14
13
8
11
10
9
16
19
18
17
20
23
22
21
28
31
30
29
24
27
26
25
BC
DE
D
C
E
B
A
(a)
00
Figure 4.3. Five-variable Karnaugh map:
a) three-dimensional representation and b) bidimensional and
non-symmetrical representation
Figures 4.4 and 4.5 give some examples of loops, representing the following terms:
– loop 1: B · C · D · E;

Systematic Methods for the Simpliﬁcation of Logic Functions
207
– loop 2: B · C · E;
– loop 3: C · E.
  Loop 1
01
11
10
E
A
C
C
1
1
1
1
1
1
ABC
D
001
000
010
011
110
111
101
100
B
DE
1
1
1
1
1
1
1
1
  Loop 2
 Loop 3
00
Figure 4.4. Example of loops in the case of a symmetrical map
  Loop 1
01
11
10
00
01
11
10
00
01
11
10
00
01
11
10
A
1
1
1
1
1
1
BC
DE
D
C
E
BC
DE
D
C
E
B
B
A
1
1
1
1
1
1
1
1
  Loop 2
 Loop 3
00
Figure 4.5. Example of loops in the case of an asymmetrical map
It should be noted that only the loops that encircle 2p cells, p being an integer, are
valid and each loop must be symmetrical with respect to any axis that divides it.
4.3.2. Function of six variables
A six-variable Karnaugh map has 64 (or 26) cells, numbered from 0 to 63. It can
be constructed either using Gray code to identify the cells, as shown in Figure 4.6,
or based on a stacked three-dimensional structure of four maps of four variables (see
Figure 4.7). In the latter case, in addition to the possibility of locating adjacent cells

208
Digital Electronics 1
on a horizontal or vertical plane, or at the ends of the same plane, cells on upper and
lower planes can be considered adjacent.
ABC
54
52
55
62
61
60
63
46
45
44
47
38
37
36
6
5
4
14
13
12
15
30
29
28
31
22
21
20
23
48
51
50
49
56
59
58
57
40
43
42
41
32
35
33
34
0
3
2
1
8
11
10
9
24
27
26
25
16
19
18
17
7
53
39
001
000
010
011
110
111
101
100
000
001
011
010
110
111
101
100
D
F
F
E
A
B
C
C
DEF
Figure 4.6. Six-variable Karnaugh map: symmetrical structure
4.3.3. Karnaugh map with entered variable
A Karnaugh map with an entered variable makes it possible to manipulate a logic
function that has more variables than in the map. It is constructed by entering, in
addition to 1 and 0, the variables in cells of a Karnaugh map. It is most useful in cases
where some variables appear less frequently in a given logic function.
By also entering variables in an n-variable Karnaugh map to represent a function of
N variables, each cell becomes the equivalent of a submap that can cover, for N > n,
2N−n possible minterms or maxterms.
The minimized sum-of-products (or product-of-sum forms) form of a logic
function can, thus, be determined as follows:
1) form the loops by grouping the entered variables of the same type or those
whose logic adjacencies can permit minimum cover and adjacent cells containing the
logic state 1 (or 0), or representations of don’t care states. Obtain the simpliﬁed term
for each loop, considering the 1s (or 0s) as indifferent states;

Systematic Methods for the Simpliﬁcation of Logic Functions
209
2) form loops that encircle only adjacent cells containing the 1s (or 0s) that are
not covered or not completely covered and those representing don’t care states, if
any. Obtain the simpliﬁed term for each loop, by eliminating each variable that is
simultaneously complemented and non-complemented;
3) write the simpliﬁed equation for the logic function by summing (or by
multiplying) the terms obtained for all the loops.
C
A B
00
01
11
10
00
01
11
10
16
19
18
17
20
23
22
21
28
31
30
29
24
27
26
25
E
F
00
01
11
10
00
01
11
10
A B
00
01
11
10
00
01
11
10
11
9
F
3
1
5
7
15
13
E
A B
00
01
11
10
00
01
11
10
8
10
0
2
4
6
12
14
CD
EF
D
C
32
35
34
33
36
39
38
37
44
47
46
45
40
43
42
41
CD
EF
E
D
F
C
3
2
1
0
4
12
8
16
20
28
24
19
18
17
51
50
49
48
52
60
56
32
35
34
33
36
39
38
37
44
47
46
45
40
43
42
41
CD
EF
D
C
48
51
50
49
52
54
53
63
62
61
55
60
56
59
58
57
A B
CD
EF
E
D
F
Figure 4.7. Six-variable Karnaugh map: stacked structure
EXAMPLE 4.1.– Let Z be a logic function of ﬁve variables characterized by the truth
table shown in Table 4.1, where x represents a don’t care state:
– express the function Z in the canonical sum-of-products form;
– determine the minimized form of the function Z.
According to the truth table, the logic function Z can be written as:
Z(A, B, C, D, E) = A · B · C · D · E + A · B · C · D(x + E)
+ A · B · C · D · E + A · B · C(x + D + E) + A · B · C
+ A · B · C · E
[4.4]

210
Digital Electronics 1
A B C
Z
0 0 0
D · E
0 0 1
D(x + E)
0 1 0
D · E
0 1 1
0
1 0 0 x + D + E
1 0 1
1
1 1 0
E
1 1 1
0
Table 4.1. Truth table
Transforming this last expression so that only minterms can appear, we get:
Z(A, B, C, D, E) = A · B · C · D · E + A · B · C · D · E · x+
A · B · C · D · E(1 + x) + A · B · C · D · E+
A · B · C · D · E · x + A · B · C · D · E(1 + x)+
A · B · C · D · E(1 + x) + A · B · C · D · E(1 + x)+
A · B · C · D · E + A · B · C · D · E + A · B · C · D · E+
A · B · C · D · E + A · B · C · D · E + A · B · C · D · E
[4.5]
Finally, the function Z can be expressed in the following canonical form:
Z(A, B, C, D, E) =

m(3, 5, 11, 17, 18, 19, 20, 21, 22, 23, 25, 27)
+

x(4, 16)
[4.6]
Figure 4.8(a) depicts the Karnaugh map constructed from the truth table of
function Z. Choosing x = 1 makes it possible to reduce the complexity of the terms
entered in the Karnaugh map as shown in Figure 4.8(b). Because
1 = D + D
[4.7]
= (D + D)(E + E) = D · E + D · E + D · E + D · E
[4.8]
and
E = (D + D)E = D · E + D · E
[4.9]

Systematic Methods for the Simpliﬁcation of Logic Functions
211
0
.E
D.E
D.E
D.E
(a)
BC
A
01
B
10
00
11
C
E
1
1
Loop 1
  Loop 2
Loop 3
 Loop 4
D
0
1
A
(b)
BC
A
01
B
10
00
11
C
x+D+E
E
1
D(x+E)
A
1
D
Figure 4.8. a) Karnaugh map with two entered variables (x being a
don’t care state); b) Karnaugh map when x =1
Loop 2 is assumed to encircle the term E, loop 3 encircles the term D and loop
4 the term D · E. It is, thus, necessary to cover the remaining terms by forming loop
1 that encircles the two adjacent 1s. The reduced term corresponding to each of the
loops is obtained as follows:
Loop 1 →A · B
Loop 2 →A · C · E
Loop 3 →B · C · D
Loop 4 →C · D · E
In the minimized sum-of-products form, the function Z can then be written as:
Z(A, B, C, D, E) = A · B + A · C · E + B · C · D + C · D · E
[4.10]
Figure 4.9 depicts the Karnaugh map (x = 1) to determine the minimized product-
of-sums form. The terms obtained for the different loops are as follows:
Loop 1 →B + C
Loop 2 →B + E
Loop 3 →A + C + D
Loop 4 →A + C + D
Loop 5 →A + C + E
Thus, the minimized product-of-sums form is given by:
Z(A, B, C, D, E) = (B + C)(B + E)(A + C + D)(A + C + D)(A + C + E)[4.11]

212
Digital Electronics 1
  Loop 4
0
BC
A
0
1
A
01
B
10
00
11
C
E
  Loop  2
   Loop 3
D
.
D
E
.
D
E
  Loop 1
    Loop 5
0
Figure 4.9. Karnaugh map (x= 1) to determine the
minimized product-of-sums form
NOTE 4.1.– To simplify an incompletely deﬁned function using a Karnaugh map with
entered variables, the don’t care state must be considered as an entered variable.
EXAMPLE 4.2.– Let us consider the following logic function Z of six variables:
Z(A, B, C, D, E, F) =

m(4, 6, 8, 9, 10, 11, 12, 13, 14, 15, 20, 22, 26, 27,
30, 31, 32, 33, 34, 35, 36, 38, 39, 52, 54, 56, 57, 60, 61)
[4.12]
Determine the minimized form for the function Z.
The ﬁrst step consists of entering, in addition to the 1s, two variables (E and F)
in a Kanraugh map for four variables. We proceed by associating the combination of
minterms with the cells of the Karnaugh map as follows:
cell 1: m4 + m6 = A · B · C · D · F
cell 2: m8 + m9 + m10 + m11 = A · B · C · D
cell 3: m12 + m13 + m14 + m15 = A · B · C · D
cell 5: m20 + m22 = A · B · C · D · F
cell 6: m26 + m27 = A · B · C · D · E
cell 7: m30 + m31 = A · B · C · D · E
cell 8: m32 + m33 + m34 + m35 = A · B · C · D
cell 9: m36 + m38 + m39 = A · B · C · D(E + F)
cell 13: m52 + m54 = A · B · C · D · F
cell 14: m56 + m57 = A · B · C · D · E
cell 15: m60 + m61 = A · B · C · D · E

Systematic Methods for the Simpliﬁcation of Logic Functions
213
We next encircle the adjacent cells containing 1s or the same variable to form loops
as illustrated in Figure 4.10. In this way, we can obtain a term of the following form
for each loop:
Loop 1 →A · B · C
Loop 2 →A · C · E
Loop 3 →C · D · F
Loop 4 →A · B · C · D
Loop 5 →A · B · C · E
Loop 6 →A · B · C · E
E
AB
CD
00
C
01
E
B
A
10
D
E
1
1
1
01
10
11
+ E
00
11
Loop 3
Loop 1
Loop 2
Loop 5
Loop 4
Loop 6
F
F
F
F
E
Figure 4.10. Karnaugh map with two entered variables to
determine the minimized sum-of-products form
The function Z is thus expressed in the following minimized sum-of-products
form:
Z(A, B, C, D, E, F) = A · B · C + A · C · E + C · D · F+
A · B · C · D + A · B · C · E + A · B · C · E
[4.13]

214
Digital Electronics 1
Loop 8
AB
CD
01
A
10
00
11
00
C
E
B
D
E
01
10
11
+ E
F
F
F
F
E
E
 0
0
0
0
0
Loop 3
Loop 1
Loop 7
Loop 2
Loop 5
Loop 4
Loop 6
Figure 4.11. Karnaugh map with two entered variables to determine
the minimized product-of-sums forms
The minimized product-of-sums form can be determined based on the Karnaugh
map shown in Figure 4.11. Forming loops that can encircle the entered variables or
the 0s, we can obtain:
Loop 1 →A + B + C
Loop 2 →A + C + D
Loop 3 →A + C + E
Loop 4 →A + C + F
Loop 5 →B + C + D
Loop 6 →B + C + F
Loop 7 →A + B + C + E
Loop 8 →C + D + E + F
Finally, the minimized product-of-sums form can be written as follows:
Z(A, B, C, D, E, F) = (A + B + C)(A + C + D)(A + C + E)(A + C + F)
(B + C + D)(B + C + F)(A + B + C + E)
(C + D + E + F)
[4.14]

Systematic Methods for the Simpliﬁcation of Logic Functions
215
4.3.4. Applications
EXAMPLE 4.3.– Let us consider the following logic function of ﬁve variables:
Z(A, B, C, D, E) =

m(0, 1, 4, 5, 6, 12, 14, 16, 20, 22, 25, 28, 30, 31) [4.15]
Determine the minimized sum-of-products form for the function Z.
Figure 4.12 depicts the Karnaugh map for the function Z. The loop encircling the
minterms 4, 6, 12, 14, 20, 22, 28 and 30 yields the term C · E; the loop encircling the
minterms 0, 1, 4, and 5 yields A · B · D; the loop encircling the minterms 0, 4, 16 and
20 yields B · D · E; the loop encircling the minterms 30 and 31 yields A · B · C · D;
and the loop encircling 25 yields A · B · C · D · E. Thus:
Z(A, B, C, D, E) = C ·E +A·B·D+B·D·E +A·B·C ·D+A·B·C ·D·E[4.16]
1
01
11
10
00
01
11
10
00
01
11
10
00
01
11
10
A
1
1
1
BC
DE
D
C
E
BC
DE
D
C
E
B
B
A
1
1
1
1
1
1
1
1
1
1
00
Figure 4.12. Karnaugh map
EXAMPLE 4.4.– A function of ﬁve variables is deﬁned by:
Z(A, B, C, D, E) =

m(3, 7, 11, 12, 13, 14, 15, 16, 18)
+

x(24, 25, 26, 27, 28, 29, 30, 31)
[4.17]
Determine the minimized sum-of-products for Z using a ﬁve-variable Karnaugh
map and choosing to enter a variable in a four-variable Karnaugh map.

216
Digital Electronics 1
– grouping the adjacent cells of the ﬁve-variable Karnaugh map shown in
Figure 4.13(a), we can obtain the following different terms for the simpliﬁed
expression of Z:
Loop encircling cells 12, 13, 14, 15,
28, 29, 30, and 31
→B · C
Loop encircling cells 16, 18, 24 and 26 →A · C · E
Loop encircling cells 3, 7, 11 and 15
→A · D · E
(a)
A
BC
DE
D
A
00
01
C
11
B
E
10
x
x
x
x
(b)
AB
CD
C
00
01
11
10
B
A
D
x
E
1
x
1
x
E
E
x
E
E
BC
DE
D
1
C
B
1
00
01
11
1
10
E
1
1
1
1
00
01
11
10
00
01
11
10
00
01
11
10
1
1
x
x
x
x
Figure 4.13. a) Five-variable Karnaugh map and
b) Karnaugh map with an entered variable
The minimal sum-of-products can then be written as:
Z(A, B, C, D, E) = B · C + A · C · E + A · D · E
[4.18]
– the function Z can be simpliﬁed by entering one of the variables in the four-
variable Karnaugh map. To ﬁll up the Karnaugh map, the terms of the logic function
are associated with the cells in the following manner:
cell 1: m3 = A · B · C · D · E
cell 3: m7 = A · B · C · D · E
cell 5: m3 = A · B · C · D · E
cell 6: m12 + m13 = A · B · C · D
cell 7: m14 + m15 = A · B · C · D cell 8: m16 = A · B · C · D · E
cell 9: m18 = A · B · C · D · E
cell 12: d24 + d25 = A · B · C · D cell 13: d26 + d27 = A · B · C · D
cell 14: d28 + d29 = A · B · C · D cell 15: d30 + d31 = A · B · C · D

Systematic Methods for the Simpliﬁcation of Logic Functions
217
The different loops obtained by grouping the cells in the map shown in
Figure 4.13(b) yield the following products:
Loop encircling cells 7, 6, 14 and 15 →B · C
Loop encircling cells 8, 9, 12 and 13 →A · C · E
Loop encircling cells 1, 3, 5 and 7
→A · D · E
We can obtain the same expression as above for the function Z, that is:
Z(A, B, C, D, E) = B · C + A · C · E + A · D · E
[4.19]
EXAMPLE 4.5.– Using a six-variable Karnaugh map ﬁrst and then entering two
variables in a four-variable Karnaugh map, simplify the following logic function:
Z(A, B, C, D, E, F) =  m(0, 2, 4, 6, 8, 10, 12, 14, 16, 20, 23, 32, 34, 36, 38,
40, 42, 44, 45, 46, 49, 51, 53, 54, 55, 57, 59, 60, 61, 62, 63)
[4.20]
– The Karnaugh map is ﬁlled in by inserting a 1 in each cell that corresponds to a
minterm of the logic function. The six-variable Karnaugh map for the logic function Z
is given in Figure 4.14. The cells in the map can be grouped in the following manner:
Loop encircling cells 0, 2, 4, 6, 8, 10, 12,
14, 32, 34, 36, 38, 40, 42, 44 and 46 →B · F
Loop encircling cells 49, 51, 53, 55, 57,
59, 61 and 63
→A · B · F
Loop encircling cells 0, 4, 16 and 20
→A · C · E · F
Loop encircling cells 23 and 55
→B · C · D · E · F
Loop encircling cells 38, 46, 54 and 62
→A · D · E · F
Loop encircling cells 44, 45, 60 and 61
→A · C · D · E
The simpliﬁed expression of Z is then given by:
Z(A, B, C, D, E, F) = B · F + A · B · F + A · C · D · E+
A · D · E · F + A · C · E · F + B · C · D · E · F
[4.21]

218
Digital Electronics 1
– Minterms of the function Z are assigned to cells in the four-variable Karnaugh
map as follows:
cell 0: m0 + m2 = A · B · C · D · F
cell 1: m4 + m6 = A · B · C · D · F
cell 2: m8 + m10 = A · B · C · D · F
cell 3: m12 + m14 = A · B · C · D · F
cell 4: m16 = A · B · C · D · E · F
cell 5: m20 + m23 = A · B · C · D(E · F + E · F)
cell 8: m32 + m34 = A · B · C · D · F
cell 9: m36 + m38 = A · B · C · D · F
cell 10: m40 + m42 = A · B · C · D · F
cell 11: m44 + m45 + m46 = A · B · C · D(E + F)
cell 12: m49 + m51 = A · B · C · D · F
cell 13: m53 + m54 + m55 = A · B · C · D(E + F)
cell 14: m57 + m59 = A · B · C · D · F
cell 15: m60 + m61 + m62 + m63 = A · B · C · D
1
A B
A B
00
01
11
10
00
01
11
10
00
01
11
10
00
01
11
10
1
1
E
F
A B
00
01
11
10
00
01
11
10
1
1
1
1
1
00
01
11
10
00
01
11
10
1
1
1
1
CD
EF
D
CD
EF
D
C
C
1
1
1
1
1
1
1
1
CD
EF
E
D
F
C
1
1
1
1
A B
CD
EF
E
D
F
C
1
1
1
1
1
1
1
E
F
Figure 4.14. Six-variable Karnaugh map

Systematic Methods for the Simpliﬁcation of Logic Functions
219
The products obtained from the grouping carried out in the Karnaugh map shown
in Figure 4.15 are written as follows:
Loop 1 →B · F
Loop 2 →A · B · F
Loop 3 →A · C · E · F
Loop 4 →B · C · D · E · F
Loop 5 →A · D · E · F
Loop 6 →A · C · D · E
E
E F
F
AB
CD
A
10
00
01
11
00
01
11
10
C
B
D
+
F
1
F
F
+ E
Loop 3
Loop 2
Loop 6
Loop 4
Loop 1
Loop 5
F
F
F
F
.F
E
.
E F
F
F
F
+
.
Figure 4.15. Karnaugh map with entered variables
The elimination of the variables permitted by loops 3, 4 and 5 are explained by the
fact that:
F = (E + E)F = E · F + E · F
[4.22]
and
E + F = (E + F)(F + F) = F + E · F + E · F
[4.23]
As before, we obtain the simpliﬁed equation for the function Z that is equal to:
Z(A, B, C, D, E, F) = B · F + A · B · F + A · C · D · E+
A · D · E · F + A · C · E · F + B · C · D · E · F
[4.24]

220
Digital Electronics 1
4.3.5. Representation based on the XOR and AND operators
For some logic functions, it may be necessary to use representation based on the
XOR and AND gates instead of using sum-of-products representations. This is
especially the case if the objective is to minimize the total number of logic gates and
the interconnect complexity.
The Karnaugh map depicted in Figure 4.16 gives a representation for each of the
three logic functions used as examples. Three types of loops can be identiﬁed on the
map, including minterms that are diagonal, one position apart from each other, or
adjacent. The logic expressions that can be associated with the different loops can be
written as follows:
– loop 1: F1 = A · B · C · D · X + A · B · C · D · X = A · D · X(B ⊕C);
– loop 2: F2 = A · B · C · D · Y + A · B · C · D · Y = (A ⊕B)C · D · Y ;
– loop 3: F3 = A · B · C · D · Z + A · B · C · D · Z = A · B · D(C ⊕Z).
Group 1
X
Y
Y
Z
Z
X
AB
CD
C
00
01
11
10
B
A
D
00
01
11
10
Group 2
Group 3
Figure 4.16. Karnaugh map with entered variables
We can see that each expression is made more compact using the XOR logic
function.
4.4. Systematic methods for simpliﬁcation
The Karnaugh method is appropriate for the simpliﬁcation of logic functions with
a small number of variables. As the number of variables increases, systematic

Systematic Methods for the Simpliﬁcation of Logic Functions
221
procedures or algorithms are used for simpliﬁcation. The implementation of these
algorithms takes place in two steps. The ﬁrst step is the determination of the prime
implicants. The second step consists of constituting the set of terms that make up
each minimized logic expression.
4.4.1. Determination of prime implicants
Among the methods that are commonly employed to determine the prime
implicants of a logic function are the Quine–McCluskey method and the iterated
consensus method.
4.4.1.1. Quine–McCluskey method
In order to determine all the prime implicants of a logic function, all the minterms
must be compared and combined two by two so as to eliminate those that are not
necessary to cover the function.
To reduce the number of comparisons,
the minterms of the canonical
decomposition are classiﬁed based on the number of 1s that appear in the
representation, before they are inscribed in the ﬁrst column of a table.
Each minterm of the group k is logically combined with each minterm of group
k + 1 using the logic identity X · Y + X · Y = Y . When a single variable can be
eliminated, the result is consigned to the second-column group whose number is equal
to the number of 1s it possesses.
With the help of the ✓symbol the two terms in question can be identiﬁed to show
that they can no longer be included in the sum-of-products expression.
If a term has already been obtained, it is no longer reinscribed in the table. On the
contrary, using the ✓symbol identiﬁes the two terms that have been combined.
In the representation of a term, the - symbol replaces the eliminated variable.
As before, we then proceed with the combination of the terms in groups k and
k + 1 in the second column. However, only those terms that have the - symbol in the
same position can be combined.
If necessary, the operation of combining the terms of the groups k and k + 1 can
be repeated for the next column until it is no longer possible to combine terms.
The terms that can no longer be combined and that are represented using the ⋆
symbols are the prime implicants.

222
Digital Electronics 1
NOTE 4.2.– Only those terms that belong to two contiguous groups or that are
differentiated by a single and identical variable can be combined.
It is not necessary to combine terms that belong to two non-contiguous groups as
these are differentiated by at least two variables. For the same reason, we do not try to
combine terms in the same group.
In the example of the logic function:
F(A, B, C, D) =

m(2, 3, 4, 5, 6, 7, 9, 11, 12, 13)
[4.25]
the steps to determine the essential prime implicants are given in Table 4.2. The
addition operations required to obtain the different terms are as follows:
t1 = m2 + m3
t2 = m2 + m6
t3 = m4 + m5
t4 = m4 + m6
t5 = m4 + m12
t6 = m3 + m7
t7 = m3 + m11
t8 = m5 + m7
t9 = m5 + m13
t10 = m6 + m7 t11 = m9 + m11 t12 = m9 + m13
t13 = m12 + m13
t14 = t1 + t10 = t2 + t6
t15 = t3 + t10 = t4 + t8
t16 = t3 + t13 = t5 + t9
Column 1
Column 2
Column 3
Group 1
m2 : 0010 ✓
t1 : 001- ✓
m4 : 0100 ✓
t2 : 0-10 ✓
t3 : 010- ✓
t4 : 01-0 ✓
t5 : -100 ✓
Group 2
m3 : 0011 ✓
t6 : 0-11 ✓t14 : 0-1-
⋆
m5 : 0101 ✓
t7 : -011 ⋆t15 : 01- - ⋆
m6 : 0110 ✓
t8 : 01-1 ✓t16 : -10-
⋆
m9 : 1001 ✓
t9 : -101 ✓
m12 : 1100 ✓t10 : 011- ✓
t11 : 10-1 ⋆
t12 : 1-01 ⋆
t13 : 110- ✓
Group 3
m7 : 0111 ✓
m11 : 1011 ✓
m13 : 1101 ✓
Table 4.2. Table to determine prime implicants

Systematic Methods for the Simpliﬁcation of Logic Functions
223
4.4.1.2. Iterated consensus method
The iterated consensus method is another technique that can be used to determine
the prime implicants of a logic function. It makes use of the consensus of terms, which
translates into the logic expressions: X · Y + X · Z + Y · Z = X · Y + X · Z and the
absorption law, X + XY = X, to suppress the redundant terms.
For two logic expressions, we can have a consensus term, null consensus or no
consensus.
EXAMPLE 4.6.– Determine the nature of consensus for the following expressions:
– A · C and B · D have no consensus;
– A · B · C and A · C · D have null consensus;
– A · B · C and A · D have B · C · D exhibit a consensus term.
The consensus theorem can be applied to any sum-of-products form (canonical or
reduced) of a logic function.
To determine the prime implicants of a logic function, a list of its terms is ﬁrst
established. The possible consensus are then singled out by considering the terms two
by two.
There is a consensus between two terms, tp and tq, with respect to one of the
variables if this variable appears in one of the terms while its complement appears
in the other term. The consensus term, C(tq, tp), is then equal to the product of the
factors of tp and tq other than this variable and its complement.
A consensus term is added to the list of terms if it is not identical to any term that
already appears on the list or it is not included in a term that is already on the list.
With the addition of each consensus term we try to reduce the number of terms in
the list by eliminating all terms that are included in other terms.
This process is repeated till no new consensus can be obtained. The terms that
remain on the list are the prime implicants.
Determine the prime implicants of the following logic function:
F(A, B, C, D) =

m(2, 3, 4, 5, 6, 7, 9, 11, 12, 13)
[4.26]

224
Digital Electronics 1
Using the property X · Y + X · Y = X to group the terms, we obtain:
F(A, B, C, D) = A · B · C · D + A · B · C · D + A · B · C · D
+ A · B · C · D + A · B · C · D + A · B · C · D
+ A · B · C · D + A · B · C · D + A · B · C · D
+ A · B · C · D
[4.27]
= A · B · C + A · B + A · B · D + A · B · C
[4.28]
We can, thus, choose to begin looking for prime implicants with the terms A·B·C,
A · B, A · B · D and A · B · C. All the consensuses used are given in Table 4.3.
hhhhh
t1 : A · B · C
t2 : A · B
C(t2, t1) (Add t5, suppress t1)
t3 : A · B · D C(t3, t2)
hhhhh
t4 : A · B · C C(t4, t2) (Add t6, suppress t4)
t5 : A · C
C(t5, t2); C(t5, t3) (Add t7)
t6 : B · C
C(t6, t2); C(t6, t3) (Add t8); C(t6, t5) = t2
t7 : B · C · D C(t7, t2) ⊂t5; C(t7, t3); C(t7, t5); C(t7, t6)
t8 : A · C · D C(t8, t2) ⊂t6; C(t8, t3); C(t8, t5); C(t8, t6); C(t8, t7) = t3
Table 4.3. Table to determine the prime implicants
using the consensus theorem
To simplify the iterated consensus method, we can adopt the digital form of
representing terms in the logic function to be simpliﬁed. A complemented variable is
represented by 0, a non-complemented variable is represented by 1 and a missing
variable is represented by a hyphen (-). Consensus can exist between two terms when
a variable is represented by 0 in one term and 1 in the other. In the consensus term, a
given variable is represented by 1 if it is represented by 1 in one of the terms and
either 1 or - in the other; it is represented by 0 if it is represented by 0 in one of the
terms and either 0 or - in the other; and it is represented by - if it is represented by 0
in one term and 1 in the other or if it is represented by - in both terms.
4.4.2. Finding the constitutive terms of a minimal expression
Finding the minimum number of prime implicants that represents a logic function
is often formulated as a minimal cover problem. For a single output logic function,
this can lead to a two-input table. The prime implicants are entered in the rows and the
minterms for the logic function to be simpliﬁed are entered in the columns. A cross is
placed at the intersection of a row and a column to indicate that a minterm is covered
by a prime implicant.

Systematic Methods for the Simpliﬁcation of Logic Functions
225
The objective is to cover all the minterms of the logic function by using a minimum
set of prime implicants. To achieve this, ﬁrst a single cross serves as the identifying
mark of the essential prime implicants, which must necessarily be a part of the minimal
expression and which are associated with each column. Each essential prime implicant
represents a single choice for covering a given minterm. Once the essential prime
implicants are determined, it only remains to choose, from the other prime implicants,
those that allow for the implementation of a minimal cover of the remaining minterms.
4.4.2.1. Graphical method for the reduction of a prime implicant chart
The dominance relation between prime implicants and the dominance relations
between minterms can be used to reduce the prime implicant chart.
It is necessary to introduce some deﬁnitions before implementing the graphical
methods for the reduction of a prime implicant chart:
– two identical rows (columns) are said to be interchangeable;
– let i and j be two rows in a prime implicant chart. The row i can be said
to dominate j if the essential prime implicant associated with i covers at least one
minterm more than the minterms covered by the essential prime implicants associated
with j.
When the row i dominates j, there exists a minimized sum-of-products form that
does not include the essential prime implicant associated with j. The dominated line
can, thus, be suppressed;
– let k and l be two columns in a prime implicant chart. The column k is said to
dominate l if the minterm associated with k is covered by at least one essential prime
implicant more than the essential prime implicants covering the minterm associated
with l.
When the column k dominates l, an essential implicant covering the minterm
associated with l also covers the minterm associated with k. We can, thus, suppress
the dominant column.
The implementation of the graphical method for the reduction of a prime implicant
chart is carried out as follows:
1) ﬁnd the essential prime implicants and eliminate them;
2) identify the dominance relations between the prime implicants (rows) and
eliminate the dominated rows;
3) identify the dominance relations between the minterms (columns) and eliminate
the dominant columns.

226
Digital Electronics 1
Repeat steps 1, 2 and 3, until there are no more possibilities for elimination: if
there are no more rows and columns, a minimal solution has been found; if not, the
prime implicant chart is said to be cyclic.
NOTE 4.3.– The reduction of the prime implicant chart following the rules given
above is nothing but the graphical translation of the absorption theorems. The
solution obtained depends on the choice of the dominance relations. The graphical
method for the reduction of a prime implicant chart can only be easily applied to
cases where the possible choices for the dominance relations are limited.
EXAMPLE 4.7.– Minimize the following logic function:
F(A, B, C, D) =

m(2, 3, 4, 5, 6, 7, 9, 11, 12, 13)
[4.29]
The prime implicant chart in Table 4.4 can be constructed by applying the
graphical method to the minimization of the function F. Here, a cross within a circle
is placed at the intersection of a row and a column associated with a single prime
implicant. We have two essential prime implicants that cover all the minterms except
for A · B · C · D and A · B · C · D. To cover these minterms, we choose A · B · D,
instead of the prime implicants A · C · D and B · C · D. As a result, the single
minimized form of F can be obtained as follows:
F(A, B, C, D) = A · C + B · C + A · B · D
[4.30]
B C D
2
3
4
5
6
7
9
11
12
13
A B C D
A B C D
A B C D
A B C D
A B C D
A B C D
A B C D
A B C D
A B C D
A B C D
A B
A C
B C
A B D
A C D
Table 4.4. Prime implicant chart for F
When a logic function has more than one minimized form, the choice of the
non-essential prime implicants may not be evident.
NOTE 4.4.– There are logic functions that do not have essential prime implicants.
Each column of the prime implicant chart for such a function contains at least two
crosses. The prime implicant chart is then said to be cyclic.

Systematic Methods for the Simpliﬁcation of Logic Functions
227
In the case of the logic functions [4.31] and [4.34], using the Karnaugh maps
shown in Figures 4.17 and 4.18 we obtain two minimized sum-of-products forms as
follows:
F(A, B, C, D) =

m(0, 4, 6, 8, 10, 14)
[4.31]
= A · B · D + A · C · D + B · C · D
[4.32]
= A · B · D + A · C · D + B · C · D
[4.33]
and:
F(A, B, C, D) =

m(0, 1, 4, 5, 6, 7, 8, 9, 10, 11, 14, 15)
[4.34]
= A · B + A · C + B · C
[4.35]
= A · B + A · C + B · C
[4.36]
We have six prime implicants for each of these functions but no essential prime
implicant.
In general, it is always possible to ﬁnd a function of n variables, whose Karnaugh
map includes the cells encompassing 2n−1 minterms and which has a cyclic prime
implicant chart.
4.4.2.2. Petrick’s method
Petrick’s method is a technique that can be used to determine, in a systematic
manner, all the minimal sum-of-products form from the prime implicant chart of a
logic function. It is especially useful when there are several solutions to be determined
and the number of prime implicants is high.
D
01
11
10
00
01
11
10
1
1
1
0
0
0
0
0
1
1
1
0
0
0
0
1
1
1
0
0
0
0
0
0
1
1
1
0
0
0
0
0
(a)
(b)
AB
CD
C
00
01
11
10
B
A
D
AB
CD
C
00
01
11
10
B
A
00
Figure 4.17. Karnaugh map for the logic function
F(A, B, C, D) =  m(0, 4, 6, 8, 10, 14)

228
Digital Electronics 1
(a)
01
11
10
00
01
11
10
1
1
1
0
0
1
1
1
0
1
1
1
1
1
0
1
1
1
1
0
0
1
1
1
0
1
1
1
1
1
0
1
AB
CD
C
00
01
11
10
B
A
D
AB
CD
C
00
01
11
10
B
A
D
(b)
00
Figure 4.18. Karnaugh map for the logic function
F(A, B, C, D) =  m(0, 1, 4, 5, 6, 7, 8, 9, 10, 11, 14, 15)
The implementation of Petrick’s method uses the following steps:
1) reduce the prime implicant chart by eliminating the rows and columns
associated with essential prime implicants;
2) attribute the denominations P1, P2, P3, · · · , to different rows in the reduced
prime implicant chart;
3) form a logic function P that is true when all the columns are covered. The
function P is equal to a product of sums, where each sum is in the form (Pi0 + Pi1 +
· · · ), with Pi0, Pi1 being related to the rows that cover the column i;
4) express P as a minimum sum of products by expanding and reducing the terms
of the multiplication using the logic identity X + XY = X;
5) each term of the result represents a solution, that is, a set of rows that covers
all the minterms of the chart. To determine the solutions with lowest hardware
implementation costs, it is necessary to ﬁnd terms that contain a minimum number
of variables. Each of these terms represents a solution having a minimum number of
prime implicants;
6) for each of the terms obtained in the previous step, count the number of
variables that form each prime implicant and determine the total number of variables.
Choose the term or terms that have the minimum total number of variables and write
the corresponding sum of prime implicants.
EXAMPLE 4.8.– Determine all the minimized sum-of-products forms for the
following logic function:
F(A, B, C, D) =

m(0, 2, 6, 7, 8, 9, 10, 13, 15)
[4.37]

Systematic Methods for the Simpliﬁcation of Logic Functions
229
Table 4.5 gives the following seven prime implicants:
B · D, A · B · D, B · C · D, A · C · D, A · B · C, A · B · C and A · C · D.
Column 1
Column 2
Column 3
Group 0
m0 : 0000 ✓
t1 : 00-0 ✓t11 : -0-0
⋆
t2 : -000 ✓
Group 1
m2 : 0010 ✓
t3 : 0-10 ⋆
m8 : 1000 ✓
t4 : -010 ✓
t5 : 100- ⋆
t6 : 10-0 ✓
Group 2
m6 : 0110 ✓
t7 : 011- ⋆
m9 : 1001 ✓
t8 : 1-01 ⋆
m10 : 1010 ✓
Group 3
m7 : 0111 ✓
t9 : -111 ⋆
m13 : 1101 ✓t10 : 11-1 ⋆
Group 4 m15 : 1111 ✓
Table 4.5. Table for the determination of prime implicants
Table 4.6 gives the complete and reduced form of the prime implicant chart for
the logic function F. As can be observed in the complete Table 4.6(a), B · D is the
only essential prime implicant. The reduced form of the prime implicant chart shown
in Table 4.6(b) is useful for the implementation of Petrick’s method. To cover all the
minterms of F, the following logic function must be true:
P = (P1 + P3)(P3 + P5)(P2 + P4)(P4 + P6)(P5 + P6)
[4.38]
Using the logic identity (X + Y )(X + Z) = X + Y · Z, we can write:
P = (P3 + P1 · P5)(P4 + P2 · P6)(P5 + P6)
[4.39]
Elaborating the function P, we obtain:
P = P1 · P4 · P5 + P2 · P3 · P6 + P3 · P4 · P5 + P3 · P4 · P6+
P1 · P2 · P5 · P6 + P1 · P4 · P5 · P6 + P2 · P3 · P5 · P6
[4.40]

230
Digital Electronics 1
(13,15)
15
6
7
9
13
0
2
6
7
8
9
10
13
15
(a)
−0−0
0−10
100−
011−
1−01
11−1
−111
(0,2,8,10)
(2,6)
(8,9)
(6,7)
(9,13)
(7,15)
(13,15)
P2
P3
P4
P5
P6
P1
(b)
0−10
100−
011−
1−01
11−1
−111
(2,6)
(8,9)
(6,7)
(9,13)
(7,15)
Table 4.6. Prime implicant chart for F:
a) complete form and b) reduced form
Because X + X · Y = X, we have:
P = P1 · P4 · P5 + P2 · P3 · P6 + P3 · P4 · P5 + P3 · P4 · P6
+P1 · P2 · P5 · P6
[4.41]
For the function P to be true, it is sufﬁcient that one of its terms be true. There
are, thus, ﬁve possible solutions but we can only retain those that exhibit a minimum
number of rows, namely, P1 and P4 and P5, or P2 and P3 and P6, or P3 and P4 and
P5, or P3 and P4 and P6. To express the minimal forms of F, we must combine these
solutions with the only essential prime implicant.
The function F, therefore, has four minimal forms, which are:
F(A, B, C, D) = B · D + A · C · D + B · C · D + A · C · D
[4.42]
= B · D + A · B · C + B · C · D + A · C · D
[4.43]
= B · D + A · B · C + A · B · D + A · C · D
[4.44]
= B · D + A · B · C + A · B · D + A · B · C
[4.45]
EXAMPLE 4.9.– Find all the minimized sum-of-products forms of the following logic
function:
F(A, B, C, D) =

m(0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13)
[4.46]
The list of prime implicants can be deduced from Table 4.7 as follows:
A · D, B · D, C · D, A · C, B · C, A · B, B · C, A · B and
A · C.

Systematic Methods for the Simpliﬁcation of Logic Functions
231
Column 1
Column 2
Column 3
Group 0
m0 : 0000 ✓
t1 : 00-0 ✓t22 : 0- -0 ⋆
t2 : 0-00 ✓t23 : -0-0
⋆
t3 : -000 ✓t24 : - -00 ⋆
Group 1
m2 : 0010 ✓
t4 : 001- ✓t25 : 0-1-
⋆
m4 : 0100 ✓
t5 : 0-10 ✓t26 : -01-
⋆
m8 : 1000 ✓
t6 : -010 ✓t27 : 01- - ⋆
t7 : 010- ✓t28 : -10-
⋆
t8 : 01-0 ✓t29 : 10- - ⋆
t9 : -100 ✓t30 : 1-0-
⋆
t10 : 100- ✓
t11 : 10-0 ✓
t12 : 1-00 ✓
Group 2
m3 : 0011 ✓t13 : 0-11 ✓
m5 : 0101 ✓t14 : -011 ✓
m6 : 0110 ✓t15 : 01-1 ✓
m9 : 1001 ✓t16 : -101 ✓
m10 : 1010 ✓t17 : 011- ✓
m12 : 1100 ✓t18 : 10-1 ✓
t19 : 1-01 ✓
t20 : 101- ✓
t21 : 110- ✓
Group 3
m7 : 0111 ✓
m11 : 1011 ✓
m13 : 1101 ✓
Table 4.7. Table for the determination of prime implicants
The list of prime implicants can be deduced from Table 4.7 as follows:
A · D, B · D, C · D, A · C, B · C, A · B, B · C, A · B and
A · C.
Table 4.8 gives the prime implicant chart for the function F. We can observe that
each minterm is covered by at least two terms and, consequently, there is no essential
prime implicant.
As dominance relations can be established between the essential implicants or
between the minterms, the following step consists of suppressing the rows associated
with dominated essential implicants and columns corresponding to dominant
minterms. Thus, column 2 dominates 3, 4 dominates 5, 6 dominates 7, 8 dominates 9,
10 dominates 11 and 12 dominates 13. As a result, columns 2, 4, 6, 8, 10 and 12 can
be eliminated as illustrated in Table 4.9(a). Essential implicants, 0- -0, -0-0 and - -00,

232
Digital Electronics 1
are interchangeable. We can, thus, eliminate two of them. Choosing to retain the term
0- -0, the prime implicant chart reduces to that in Table 4.9(b) and the term 0- -0
becomes a secondary essential prime implicant, the elimination of which leads to the
construction in Table 4.9(c).
(4,5,12,13)
0
2
3
4
5
6
7
8
9
10
11
12
13
0− −0
−0−0
− −00
0−1−
−01−
1−0−
10− −
−10−
01− −
(0,2,4,6)
(0,2,8,10)
(0,4,8,12)
(2,3,6,7)
(2,3,10,11)
(8,9,10,11)
(8,9,12,13)
(4,5,6,7)
Table 4.8. Prime implicant chart for F
(b)
3
5
7
9
11
13
0− −0
0−1−
−01−
1−0−
10− −
−10−
01− −
−0−0
− −00
(0)
(3,7)
(3,11)
(9,11)
(9,13)
(5,7)
(5,13)
(a)
(0)
(0)
0
3
5
7
9
11
13
0
3
5
7
9
11
13
0−1−
−01−
1−0−
10− −
−10−
01− −
(3,7)
(3,11)
(9,11)
(9,13)
(5,7)
(5,13)
P2
P3
P4
P5
P6
P1
(c)
0− −0
0−1−
−01−
1−0−
10− −
−10−
01− −
(0)
(3,7)
(3,11)
(9,11)
(9,13)
(5,7)
(5,13)
Table 4.9. Reduced forms of the prime implicant charts for F

Systematic Methods for the Simpliﬁcation of Logic Functions
233
Using Petrick’s methods, the overlap equation can be put into the following form:
P = (P1 + P2)(P3 + P4)(P1 + P3)(P5 + P6)(P2 + P5)(P4 + P6)
[4.47]
Expanding P, taking into account the logic identity:
(X + Y )(X + Z) = X + Y · Z
we have:
P = P1P4P5 + P1P2P3P6 + P1P3P5P6 + P1P2P4P6+
P2P3P6 + P2P3P4P5 + P2P3P5P6 + P2P3P4P6
[4.48]
Each term in the sum is a possible solution and we thus have eight possible
solutions. However, only the two simplest terms, P1P4P5 and P2P3P6, can be
retained to implement the minimal forms of F. The term P1P4P5 is made up of
A · C, B · C and A · B, while P2P3P6 consists of B · C, A · B and A · C. Finally, we
can consider the following minimal forms:
F = A · D + A · C + B · C + A · B
[4.49]
= A · D + B · C + A · B + A · C
[4.50]
Choosing either -0-0 or - -00, instead of 0- -0, we obtain:
F = B · D + A · C + B · C + A · B
[4.51]
= B · D + B · C + A · B + A · C
[4.52]
or:
F = C · D + A · C + B · C + A · B
[4.53]
= C · D + B · C + A · B + A · C
[4.54]
There are, thus, six minimal forms for the logic function F.
EXAMPLE 4.10.– Determine all the minimized sum-of-products forms for the
following logic function:
F(A, B, C, D, E) =

m(5, 7, 8, 9, 10, 11, 13, 15, 21, 23, 26, 28, 29, 30, 31) [4.55]
The prime implicants of the logic function F are:
-1010,
11-10,
010- -,
01- -1,
111- -
and
- -1-1

234
Digital Electronics 1
or:
B · C · D · E,
A · B · D · E,
A · B · C,
A · B · E,
A · B · C
and
C · E.
Column 1
Column 2
Column 3
Column 4
Group 1
m8 : 01000 ✓
t1 : 0100- ✓t24 : 010- - ⋆
t2 : 010-0 ✓
Group 2
m5 : 00101 ✓
t3 : 001-1 ✓t25 : 0-1-1 ✓t33 : - -1-1 ⋆
m9 : 01001 ✓
t4 : 0-101 ✓t26 : -01-1 ✓
m10 : 01010 ✓
t5 : -0101 ✓t27 : - -101 ✓
t6 : 010-1 ✓t28 : 01- -1 ⋆
t7 : 01-01 ✓
t8 : 0101- ✓
t9 : -1010 ⋆
Group 3
m7 : 00111 ✓t10 : 0-111 ✓t29 : - -111 ✓
m11 : 01011 ✓t11 : -0111 ✓t30 : -11-1 ✓
m13 : 01101 ✓t12 : 01-11 ✓t31 : 1-1-1 ✓
m21 : 10101 ✓t13 : 011-1 ✓t32 : 111- - ⋆
m26 : 11010 ✓t14 : -1101 ✓
m28 : 11100 ✓t15 : 101-1 ✓
t16 : 1-101 ✓
t17 : 11-10 ⋆
t18 : 1110- ✓
t19 : 111-0 ✓
Group 4 m15 : 01111 ✓t20 : -1111 ✓
m23 : 10111 ✓t21 : 1-111 ✓
m29 : 11101 ✓t22 : 111-1 ✓
m30 : 11110 ✓t23 : 1111- ✓
Group 5 m31 : 11111 ✓
Table 4.10. Table for the determination of prime implicants
(28,29,30,31)
5
7
8
9
10
11
13
15
21
23
26
30
31
28
29
−1010
11−10
010− −
01− −1
111− −
− −1−1
(5,7,13,15,21,23,29,31)
(9,11,13,15)
(26,30)
(10,26)
(8,9,10,11)
Table 4.11. Prime implicant chart for F

Systematic Methods for the Simpliﬁcation of Logic Functions
235
The prime implicant chart for the logic function F(A, B, C, D, E) is represented
in Table 4.11. The minterm m8 is only covered by the term 010- -; the minterm m28
is only covered by 111- -; and the minterms m5, m7, m21, and m23 are covered only
by - -1-1. Thus, the terms 010- - (A · B · C), 111- - (A · B · C) and - -1-1 (C · E)
are the essential prime implicants. As the essential prime implicants are part of any
minimized form of a logic function, it only remains to cover the minterm m26. This
can be done by using either -1010 (B · C · D · E) or 11-10 (A · B · D · E). We thus
obtain the following two solutions:
F = A · B · C + C · E + A · B · C + B · C · D · E
[4.56]
= A · B · C + C · E + A · B · C + A · B · D · E
[4.57]
4.4.3. Quine–McCluskey
technique:
simpliﬁcation
of
incompletely
deﬁned functions
Consider the following incompletely deﬁned logic function:
F(A, B, C, D) =

m(1, 7, 9, 10, 11, 13) +

d(5, 8, 15)
[4.58]
To determine the prime implicants for such a function, we construct a table, where
the incompletely deﬁned terms are treated in the same way as minterms.
Table 4.12 gives the following prime implicants: A · B, A · D, B · D and C · D.
In the prime implicants chart in Table 4.13, we insert only the minterms and not
the incompletely deﬁned terms. It can be deduced from the chart that A · B, B · D
and C ·D are the essential prime implicants of the function F. As all the minterms for
the function F are covered by the essential prime implicants, the minimized sum-of-
products can be written as follows:
F(A, B, C, D) = A · B + B · D + C · D
[4.59]
In the case of the simpliﬁcation of an incompletely deﬁned function using the
Quine–McCluskey method, the incompletely deﬁned terms are taken into account only
for the process of determining the prime implicants and are not inserted in the prime
implicants chart.
4.4.4. Simpliﬁcation of functions with multiple outputs
In general, the simpliﬁcation of logic functions with multiple outputs consists of
minimizing several functions simultaneously. The hardware implementation cost

236
Digital Electronics 1
function to be minimized has a bearing on several logic functions at the same time
and it is thus necessary to take into account the interdependence between the
different logic functions.
Column 1
Column 2
Column 3
Group 1
m1 : 0001 ✓
t1 : 0-01 ✓t13 : - -01 ⋆
m8 : 1000 ✓
t2 : -001 ✓t14 : 10- - ⋆
t3 : 100- ✓
t4 : 10-0 ✓
Group 2
m5 : 0101 ✓
t5 : 01-1 ✓t15 : -1-1
⋆
m9 : 1001 ✓
t6 : -101 ✓t16 : 1- -1 ⋆
m10 : 1010 ✓
t7 : 10-1 ✓
t8 : 1-01 ✓
t9 : 101- ✓
Group 3
m7 : 0111 ✓t10 : -111 ✓
m11 : 1011 ✓t11 : 1-11 ✓
m13 : 1101 ✓t12 : 11-1 ✓
Group 4 m15 : 1111 ✓
Table 4.12. Table for the determination of prime implicants
(9,11,13)
1
7
9
10
11
13
− −01
10− −
−1−1
1− −1
(1,9,11,13)
(9,10,11)
(7,13)
Table 4.13. Prime implicants chart for F
To establish the list of prime implicants in the case of functions with multiple
outputs, it is necessary to modify the Quine–McCluskey method or the iterated
consensus method to take into account the tag associated with each term. The number
of tag bits correspond to the number of functions. The logic state 1 (or 0) of a bit can
be used to identify whether a term belongs (or does not belong) to a given function.
The tag associated with the term resulting from the logic combination of two other
terms is obtained by multiplying their tags, bit by bit.

Systematic Methods for the Simpliﬁcation of Logic Functions
237
Let us consider the following incompletely deﬁned functions:
F(A, B, C, D) =

m(1, 3, 4, 10, 11, 12, 14) +

d(6, 7, 8, 9)
[4.60]
G(A, B, C, D) =

m(1, 2, 4, 10, 14) +

d(5, 6, 9, 13)
[4.61]
Assuming that these two logic functions characterize a 4-input and 2-output
system, determine their minimized sum-of-products equations.
The two methods used most often to determine the prime implicants of a logic
function are the following: the Quine–McCluskey method and the iterated consensus
algorithm.
4.4.4.1. Prime implicant determination using the Quine–McCluskey method
We construct a table in which we insert the minterms and the incompletely
deﬁned terms grouped according to the number of 1s in their representation and a tag
indicating the function for which a term can be used.
Going through Table 4.14, we note that there are four prime implicants common
to both functions F and G, seven prime implicants associated only with F and three
prime implicants associated only with G.
4.4.4.2. Prime implicant determination using the iterated consensus method
To apply the consensus method, it is necessary to draw up a list of minterms for
each function as well as all the possible products of functions. A tag is then associated
with each minterm. The determination of the consensus term for each pair of minterms
makes it possible to either add a new term or suppress the terms that are included in
other terms. In the speciﬁc case of functions with multiple outputs, we also suppress
any new term whose tag is formed only of bits set to 0. The prime implicants are those
terms that remain in the table at the end of the process.
In Table 4.15, we have four prime implicants common to both functions F and G,
seven prime implicants associated only with F and three prime implicants associated
only with G.
4.4.4.3. Prime implicant chart
In general, in the case of simpliﬁcation of functions with multiple outputs, the
prime implicant chart includes a section with prime implicants common to all
functions and a section for each group of prime implicants that only belong to a
single function.
Table 4.16 gives the prime implicants chart for the functions F, G and F · G. It
should be noted that the row associated with the term 011- is not selected for any

238
Digital Electronics 1
function. This is explained by the fact that the essential prime implicant 011- belongs
uniquely to the incompletely deﬁned terms. The function F has an essential prime
implicant, -0-1 (B · D), exactly like the function G, whose essential prime implicant
is –10 (C · D). Eliminating the rows associated with these essential prime implicants,
as well as the columns covered by them, we obtain the reduced form of the prime
implicants chart represented in Table 4.17. To complete the overlap of the logic
functions, we choose the prime implicant 1- -0 (A · D), which covers three minterms
(10,12,14) of F, the prime implicant 01-0 (A · B · D), which covers the minterm (4)
of F and G, and the prime implicant - -01 (C · D), which covers the minterm (1) of
G. The minimal forms of F and G are, thus, written as:
F(A, B, C, D) = A · D + B · D + A · B · D
[4.62]
Column 1
F G
Column 2 F G
Column 3 F G
Group 1
m1 : 0001 1 1 ✓
t1 : 00-1 1 0 ✓t21 : -0-1
1 0 ⋆
m2 : 0010 0 1 ✓
t2 : 0-01 0 1 ✓t22: - -01 0 1 ⋆
m4 : 0100 1 1 ✓
t3 : -001 1 1 ⋆t23 :-0-1
1 0 ⋆
m8 : 1000 1 0 ✓
t4 : 0-10 0 1 ✓t24 :- -10
0 1 ⋆
t5 : -010 0 1 ✓t25 :-1-0
1 0 ⋆
t6 : 010- 0 1 ⋆t26 :10- -
1 0 ⋆
t7 : 01-0 1 1 ⋆t27 :1- -0
1 0 ⋆
t8 : -100 1 0 ✓
t9 : 100- 1 0 ✓
t10 : 10-0 1 0 ✓
t11 : 1-00 1 0 ✓
Group 2
m3 : 0011 1 0 ✓t12 : 0-11 1 0 ⋆
m5 : 0101 0 1 ✓t13 : -011 1 0 ✓
m6 : 0110 1 1 ✓t14 : -101 0 1 ✓
m9 : 1001 1 1 ✓t15 : 011- 1 0 ⋆
m10 : 1010 1 1 ✓t16 : -110 1 1 ⋆
m12 : 1100 1 0 ✓t17 : 10-1 1 0 ✓
t18 : 1-01 0 1 ✓
t19 : 101-
10 ✓
t20 : 1-10
11
⋆
t21 : 11-0
10 ✓
Group 3
m7 : 0111 1 0 ✓
m11 : 1011 1 0 ✓
m13 : 1101 0 1 ✓
m14 : 1110 1 1 ✓
Table 4.14. Table for the determination of prime implicants

Systematic Methods for the Simpliﬁcation of Logic Functions
239
F G
hhhh
m1 : 0001
1 1
hhhh
m2 : 0010
0 1
hhhh
m3 : 0011
1 0 C(m3, m1) (Add t1, Suppress m3)
hhhh
m4 : 0100
1 1 C(m5, m1) (Add t2, Suppress m5)
hhhh
m5 : 0101
0 1 C(m9, m1) (Add t3, Suppress m9 and m1)
hhhh
m6 : 0110
1 1 C(m6, m2) (Add t4, Suppress m2)
hhhh
m7 : 0111
1 0 C(m6, m4) (Add t5, Suppress m6 and m4)
hhhh
m8 : 1000
1 0 C(m10, m8) (Add t6, Suppress m8)
hhhh
m9 : 1001
1 1 C(m11, m10) (Add t7, Suppress m11)
hhhh
m10 : 1010 1 1 C(m14, m10) (Add t8, Suppress m14 and m10)
hhhh
m11 : 1011 1 0 C(t1, m7) (Add t9, Suppress m7)
hhhh
m12 : 1100 1 0 C(t5, m12) (Add t10, Suppress m12)
hhhh
m13 : 1101 0 1 C(t2, m13) (Add t11, Suppress m13)
hhhh
m14 : 1110 1 1 C(t7, t1) (Add t12)
XXX
t1 : 00-1
1 0 C(t5, t2) (Add t13)
XXX
t2 : 0-01
0 1 C(t6, t3) (Add t14)
t3 : -001
1 1 C(t7, t3) (Add t15)
XXX
t4 : 0-10
0 1 C(t9, t3) (Add t16)
t5 : 01-0
1 1 C(t11, t3) (Add t17, Suppress t11, t2)
XXX
t6 : 10-0
1 0 C(t12, t3) (Add t18, Suppress t16, t12, t1)
C(t13, t3) ⊂t17
XXX
t7 : 101-
1 0 C(t8, t4) (Add t19, Suppress t4)
t8 : 1-10
1 1 C(t8, t5) (Add t20)
t9 : 0-11
1 0 C(t9, t5) (Add t21)
C(t17, t5) = t13
hhhh
t10 : -100
1 0 C(t10, t6) (Add t22)
hhhh
t11 : -101
0 1 C(t15, t6) (Add t23, Suppress t15, t14, t7, t6)
C(t9, t7) ⊂t18; C(t14, t7) = t23; C(t16, t7) ⊂t18
C(t22, t7) = C(t14, t8) = C(t15, t8) = C(t18, t8) ⊂t23
hhhh
t12 : -011
1 0 C(t22, t8) (Add t24, Suppress t22)
C(t15, t9) = C(t23, t9) ⊂t18; C(t14, t10) ⊂t24; C(t21, t10) ⊂t5
C(t23, t10) ⊂t24; C(t19, t13) ⊂t5; C(t16, t14) ⊂C(t16, t15) ⊂t3
C(t24, t15) = t23; C(t21, t16) = t9; C(t23, t16) = t18
C(t21, t18) = t9; C(t24, t18) = t23
t13 : 010-
0 1 C(t24, t21) (Add t25)
hhhh
t14 : 100-
1 0 C(t24, t5) (Add t26, Suppress t10, t25)
hhhh
t15 : 10-1
1 0
hhhh
t16 : 00-1
1 0
t17 : - -01
0 1
t18 : -0-1
1 0
t19 : - -10
0 1
t20 : -110
1 1
t21 : 011-
1 0
hhhh
t22 : 1-00
1 0
t23 : 10- -
1 0
t24 : 1- -0
1 0
hhhh
t25 : -110
1 0
t26 : -1-0
1 0
Table 4.15. Table for the determination of prime
implicants using the consensus method

240
Digital Electronics 1
and
G(A, B, C, D) = C · D + C · D + A · B · D
[4.63]
011−
11
12
14
F
1
3
1
2
10
14
G
4
10
4
F
F G
G
0−11
(3)
−001
01−0
−110
1−10
(1)
(4)
(14)
(10)
1− −0
10− −
(10)
(10,12,14)
010−
(4)
−1−0
(12,14)
−0−1
(1,3,11)
− −10
(2,10,14)
− −01
(1)
Table 4.16. Prime implicant chart for the functions F, G and F · G
(12,14)
12
14
1
G
F
4
10
4
F G
G
F
− −01
(1)
−001
01−0
−110
1−10
(1)
(4)
(14)
(10)
1− −0
10− −
(10)
(10,12,14)
010−
(4)
−1−0
Table 4.17. Reduced form of the prime implicant
chart for the functions F, G and F · G

Systematic Methods for the Simpliﬁcation of Logic Functions
241
4.5. Exercises
EXERCISE 4.1.– Karnaugh map with entered variables.
Determine the canonical and minimized sum-of-products forms for each of the
logic functions whose Karnaugh map is represented in Figure 4.19.
F
01
11
10
00
01
11
10
AB
CD
C
00
01
11
10
B
A
D
1
1
E
1
1
E
1
E
1
1
1
1
(a)
(b)
AB
CD
C
00
01
11
10
B
A
D
.
E F
+ F
E
E
.F
E
F
00
Figure 4.19. Karnaugh maps
EXERCISE 4.2.– Karnaugh map with entered variables and incompletely deﬁned logic
functions.
Determine the canonical and minimized sum-of-products forms for each of the
incompletely deﬁned logic functions whose Karnaugh map is represented in
Figure 4.20.
.
01
11
10
00
01
11
10
x + E
D
E
E
E
E
E
E
E
AB
CD
C
00
01
11
10
B
A
D
1
(a)
(b)
AB
CD
C
00
01
1
B
11
E
A
10
x
x
.
x
E
1
x
x
.
x E
+
E(x
.
x
+
E
+
x
+
x
)
00
Figure 4.20. Karnaugh maps
EXERCISE 4.3.– Karnaugh maps with entered variables and logic functions in the
canonical form.

242
Digital Electronics 1
Determine the minimized sum-of-products form for each of the following logic
functions:
a)
P(A, B, C, D, E) =

m(1, 6, 7, 9, 13, 15, 16, 17, 18, 22, 23, 24, 25, 28, 29)
[4.64]
b)
Q(A, B, C, D, E) =

m(2, 3, 6, 9, 10, 12, 13, 16, 17, 22, 24, 25, 26, 27, 29, 31)
[4.65]
c)
R(A, B, C, D, E, F) =

m(12, 13, 14, 15, 16, 17, 20, 21, 24, 25, 28,
29, 30, 31, 33, 35, 37, 39, 49, 50, 52, 53, 54, 55)
[4.66]
d)
S(A, B, C, D, E, F) =

m(2, 3, 4, 5, 7, 12, 13, 14, 15,
25, 29, 30, 34, 35, 56, 57, 58, 60, 61, 63)
[4.67]
EXERCISE 4.4.– Quine–McCluskey method.
Determine the minimized sum-of-products form for each of the following logic
functions using the Quine–McCluskey method:
a)
Z1(A, B, C, D, E) =

m(0, 2, 3, 8, 10, 16, 17, 18, 19, 21, 24, 26)
[4.68]
b)
Z2(A, B, C, D, E) =

m(1, 14, 16, 18, 19, 22, 23, 24, 30)+

x(2, 3, 5, 6, 7, 17, 25, 26)
[4.69]

Systematic Methods for the Simpliﬁcation of Logic Functions
243
c)
Z3(A, B, C, D, E, F) =

m(10, 18, 26, 40, 41, 42, 48, 49, 50,
52, 53, 56, 57, 60, 61)
[4.70]
d)
Z4(A, B, C, D, E, F) =

m(0, 1, 2, 3, 16, 17, 18, 19, 29, 44, 53, 60)+

x(12, 21, 28)
[4.71]
4.6. Solutions
SOLUTION 4.1.– Karnaugh map with inscribed variables.
a) Based on the Karnaugh map, the logic function Z can be obtained as follows:
Z(A, B, C, D, E) = A · B · C · D · E + A · B · C · D · E + A · B · C · D+
A · B · C · D + A · B · C · D + A · B · C · D+
A · B · C · D + A · B · C · D · E + A · B · C · D · E
[4.72]
Using the complement law to bring out only the minterms in the expression of Z,
we obtain:
Z(A, B, C, D, E) = A · B · C · D · E + A · B · C · D · E+
A · B · C · D · E + A · B · C · D · E + A · B · C · D · E+
A · B · C · D · E + A · B · C · D · E + A · B · C · D · E+
A · B · C · D · E + A · B · C · D · E + A · B · C · D · E+
A · B · C · D · E + A · B · C · D · E + A · B · C · D · E
[4.73]
Replacing each minterm with the decimal value corresponding to the binary
combination of its variables, we have:
Z(A, B, C, D, E) =

m(1, 3, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19, 24)
[4.74]
The Karnaugh map shown in Figure 4.21(a) can be used to arrive at the following
minimized sum-of-products expression:
Z(A, B, C, D, E) = A · B + B · C · E + A · C · D · E
[4.75]

244
Digital Electronics 1
E
01
11
10
00
01
11
10
.
E F
AB
CD
C
00
01
11
10
B
A
D
1
1
E
1
1
E
1
E
(a)
(b)
AB
CD
C
01
+
1
1
1
1
00
11
B
F
10
A
D
E
.F
E
F
F
00
Figure 4.21. Karnaugh map
b) Based on the Karnaugh map, the function Z can be written as follows:
Z(A, B, C, D, E) = A · B · C · D + A · B · C · D + A · B · C · D+
A · B · C · D + A · B · C · D(E + F) + A · B · C · D · E · F+
A · B · C · D · F + A · B · C · D · F + A · B · C · D · F
[4.76]
The logic function Z can then be expressed in the following form:
Z(A, B, C, D, E, F) = A · B · C · D · E · F + A · B · C · D · E · F+
A · B · C · D · E · F + A · B · C · D · E · F + A · B · C · D · E · F+
A · B · C · D · E · F + A · B · C · D · E · F + A · B · C · D · E · F+
A · B · C · D · E · F + A · B · C · D · E · F + A · B · C · D · E · F+
A · B · C · D · E · F + A · B · C · D · E · F + A · B · C · D · E · F+
A · B · C · D · E · F + A · B · C · D · E · F + A · B · C · D · E · F+
A · B · C · D · E · F + A · B · C · D · E · F + A · B · C · D · E · F+
A · B · C · D · E · F + A · B · C · D · E · F + A · B · C · D · E · F+
A · B · C · D · E · F + A · B · C · D · E · F
[4.77]
In decimal form, the canonical equation is given by:
Z(A, B, C, D, E) =  m(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
13, 14, 15, 25, 28, 29, 31, 32, 34, 36, 38, 63) [4.78]

Systematic Methods for the Simpliﬁcation of Logic Functions
245
The simpliﬁcation of Z using the Karnaugh map, as shown in Figure 4.21(b),
yields:
Z(A, B, C, D, E) = A · B + B · C · F + A · C · D · E + A · C · E · F
+B · C · D · E · F
[4.79]
SOLUTION 4.2.– Karnaugh map with entered variables and incompletely deﬁned
logic functions.
a) The expression of the function Z obtained from the Karnaugh map is given by:
Z(A, B, C, D, E) = A · B · C · D(x + E) + A · B · C · D(x + E)+
A · B · C · D + A · B · C · D · x + A · B · C · D · E+
A · B · C · D · x + A · B · C · D · E + A · B · C · D · E · x
[4.80]
The function Z can be rewritten as follows:
Z(A, B, C, D, E) = A · B · C · D · E(1 + x) + A · B · C · D · E · x+
A · B · C · D · E(1 + x) + A · B · C · D · E · x+
A · B · C · D · E + A · B · C · D · E+
A · B · C · D · E · x + A · B · C · D · E · x+
A · B · C · D · E + A · B · C · D · E · x+
A · B · C · D · E · x + A · B · C · D · E + A · B · C · D · E · x
[4.81]
In the decimal form, the canonical expression of the function Z is given by:
Z(A, B, C, D, E) =

m(0, 4, 10, 11, 18, 25)
+

x(1, 5, 16, 17, 20, 21, 27)
[4.82]
As it is possible to encircle the term E with either x · E or with x, the Karnaugh
map shown in Figure 4.22(a), where the don’t care state is assumed to be set at 1,
allows us to write:
Z(A, B, C, D, E) = B · D + A · B · C · D + A · B · C · E + A · B · C · E
[4.83]
or
Z(A, B, C, D, E) = B · D + A · B · C · D + A · B · C · E + A · C · D · E
[4.84]

246
Digital Electronics 1
b) Based on the Karnaugh map, we have:
Z(A, B, C, D, E) = A · B · C · D · E(x + E) + A · B · C · D+
A · B · C · D + A · B · C · D(x + E)+
A · B · C · D · E · x + A · B · C · D · x+
A · B · C · D · E · x + A · B · C · D · E + A · B · C · D(x · E + E)
[4.85]
E
01
11
10
00
01
11
10
D
1
AB
CD
C
00
01
11
10
B
A
D
1
(a)
(b)
AB
CD
C
00
1
E
E
1
1
1
01
B
11
E
A
10
1
1
1
00
Figure 4.22. Karnaugh maps
The expansion of the function Z, taking into account the complement law,
translates to:
Z(A, B, C, D, E) = A · B · C · D · E · x + A · B · C · D · E+
A · B · C · D · E + A · B · C · D · E + A · B · C · D · E+
A · B · C · D · E(1 + x) + A · B · C · D · E · x + A · B · C · D · E · x+
A · B · C · D · E · x + A · B · C · D · E · x + A · B · C · D · E · x+
A · B · C · D · E + A · B · C · D · E · x + A · B · C · D · E
[4.86]
The function Z can equivalently be deﬁned by:
Z(A, B, C, D, E) =

m(4, 5, 8, 9, 11, 25, 26) +

x(3, 10, 16, 18, 19, 20, 27)
[4.87]
Using the Karnaugh map shown in Figure 4.22(b), where x3 = x16 = x18 =
x19 = x20 = 0 and x10 = x27 = 1, we obtain:
Z(A, B, C, D, E) = B · C · E + A · B · C + B · C · D + A · B · C · D
[4.88]

Systematic Methods for the Simpliﬁcation of Logic Functions
247
SOLUTION 4.3.– Karnaugh maps with entered variables and logic functions in the
canonical form.
a) Based on the Karnaugh map shown in Figure 4.23(a), the minimized sum-of-
products form for the logic function P can be written as:
P(A, B, C, D, E) = A · B · D + B · C · D + C · D · E + A · B · C · E
+A · B · C · E
[4.89]
b) With reference to the Karnaugh map shown in Figure 4.23(b), the following
minimized expression can be obtained:
Q(A, B, C, D, E) = A · B · E + A · C · D + B · D · E + A · B · C · D+
A · B · C · D + B · C · D · E + B · C · D · E
[4.90]
E
01
11
10
00
01
11
10
D
1
AB
CD
C
00
01
11
10
B
A
D
(a)
(b)
AB
CD
C
00
1
E
01
B
11
A
10
E
E
E
1
1
1
1
E
E
E
1
1
1
1
E
E
E
00
Figure 4.23. Karnaugh maps
c) Figure 4.24(a) depicts the Karnaugh map for the function R. As the term E · F
can be covered by either F or by E, we have the following two solutions:
R(A, B, C, D, E, F) = A · C · D + A · B · E + A · B · C · D+
A · B · C · F + A · B · C · E · F + A · C · E · F
[4.91]
or
R(A, B, C, D, E, F) = A · C · D + A · B · E + A · B · C · D+
A · B · C · F + A · B · C · E · F + B · C · E · F
[4.92]

248
Digital Electronics 1
d) Because E + F = E · F, based on the Karnaugh map shown in Figure 4.24(b)
we have:
S(A, B, C, D, E, F) = A · B · C · E + A · B · D · E + A · B · D · F+
B · C · E · F + B · C · D · E + A · B · C · D · F+
A · B · C · D · F + A · C · D · E · F
[4.93]
F
D
1
D
10
F
F
AB
CD
C
01
10
11
1
00
00
E
01
+
.F
+ F
B
A
11
10
E
AB
CD
C
01
10
11
11
1
00
00
+
.F
B
A
(a)
(b)
01
1
E
E
E
.F
E
E
+F
E
.F
E
E
.F
E
E
E
+
Figure 4.24. Karnaugh maps
SOLUTION 4.4.– The Quine–McCluskey method
a)
Z1(A, B, C, D, E) =

m(0, 2, 3, 8, 10, 16, 17, 18, 19, 21, 24, 26)
[4.94]
Table 4.18 gives the following prime implicants:
A · B · D · E,
B · C · D,
A · B · C
and
C · E
Table 4.19 gives the prime implicant chart for the function Z1. As all the terms of
Z1 are covered by the essential prime implicants, that is - -00 (C ·E), -001- (B·C ·D)
and 10-01 (A·B ·D ·E), the minimized sum-of-products forms for Z1 can be written
as:
Z1(A, B, C, D, E) = C · E + B · C · D + A · B · D · E
[4.95]

Systematic Methods for the Simpliﬁcation of Logic Functions
249
b)
Z2(A, B, C, D, E) =  m(1, 14, 16, 18, 19, 22, 23, 24, 30)+
 x(2, 3, 5, 6, 7, 17, 25, 26)
[4.96]
Column 1
Column 2
Column 3
Column 4
Group 0
m0 : 00000 ✓
t1 : 000-0 ✓t19 : 0-0-0 ✓t27 : - -0-0 ⋆
t2 : 0-000 ✓t20 : -00-0 ✓
t3 : -0000 ✓t21 : - -000 ✓
Group 1
m2 : 00010 ✓
t4 : 0001- ✓t22 : -001-
⋆
m8 : 01000 ✓
t5 : 0-010 ✓t23 : 100- - ⋆
m16 : 10000 ✓
t6 : 010-0 ✓t24 : - -010 ✓
t7 : 1000- ✓t25 : -10-0 ✓
t8 : -0010 ✓t26 : 1-0-0 ✓
t9 : 100-0 ✓
t10 : -1000 ✓
t11 : 1-000 ✓
Group 2
m3 : 00011 ✓t12 : -0011 ✓
m10 : 01010 ✓t13 : 100-1 ✓
m17 : 10001 ✓t14 : 1001- ✓
m18 : 10010 ✓t15 : 10-01 ⋆
m24 : 11000 ✓t16 : -1010 ✓
t17 : 1-010 ✓
t18 : 110-0 ✓
Group 3 m19 : 10011 ✓
m21 : 10101 ✓
m26 : 11010 ✓
Table 4.18. Table for the determination of the prime implicants of Z1
19
(0,2,8,10,16,18,24,26)
(16,17,18,19)
(2,3,18,19)
(17,21)
− −0−0
100− −
−001−
10−01
0
2
3
8
10
21
24
26
16
17
18
Table 4.19. Prime implicant chart for Z1

250
Digital Electronics 1
Column 1
Column 2
Column 3
Column 4
Group 1
m1 : 00001 ✓
t1 : 000-1 ✓t29 : 00- -1 ⋆t43 : -0-1- ⋆
m2 : 00010 ✓
t2 : 0001- ✓t30 : 00-1- ✓
m16 : 10000 ✓
t3 : 00-01 ✓t31 : -00-1
⋆
t4 : 00-10 ✓t32 : -001- ✓
t5 : -0001 ✓t33 : 100- - ⋆
t6 : 1000- ✓t34 : -0-10 ✓
t7 : -0010 ✓t35 : 1-00-
⋆
t8 : 100-0 ✓t36 : 1-0-0
⋆
t9 : 1-000 ✓
Group 2
m3 : 00011 ✓t10 : 00-11 ✓t37 : -0-11 ✓
m5 : 00101 ✓t11 : 001-1 ⋆t38 : -011- ✓
m6 : 00110 ✓t12 : 0011- ✓t39 : -0-11 ✓
m17 : 10001 ✓t13 : 0-110 ✓t40 : 10-1- ✓
m18 : 10010 ✓t14 : -0011 ✓t41 : - -110 ⋆
m24 : 11000 ✓t15 : 100-1 ⋆t42 : 1- -10 ⋆
t16 : 1001- ✓
t17 : -0110 ✓
t18 : 10-10 ✓
t19 : 1-001 ⋆
t20 : 1100- ⋆
t21 : 1-010 ✓
t22 : 110-0 ⋆
Group 3
m7 : 00111 ✓t23 : -0111 ✓
m14 : 01110 ✓t24 : 10-11 ✓
m19 : 10011 ✓t25 : 1011- ✓
m22 : 10110 ✓t26 : -1110 ✓
m25 : 11001 ✓t27 : 1-110 ✓
m26 : 11010 ✓t28 : 11-10 ✓
Group 4 m23 : 10111 ✓
m30 : 11110 ✓
Table 4.20. Table for the determination of the prime implicants of Z2
According to Table 4.20, the logic function Z2 has 13 prime implicants. As shown
in the prime implicant chart in Table 4.21(a), the essential prime implicants are -0-1-
(B · D) and - -110 (C · D · E). The two implicants 1-001 and 001-1 cover no minterm
of Z2 as they have been obtained by combining only the minterms (25 and 17, and 7
and 5) corresponding to don’t care states.

Systematic Methods for the Simpliﬁcation of Logic Functions
251
(24)
1
16
24
1−00−
1100−
110−0
100− −
−00−1
00− −1
1−0−0
P2
P3
P4
P5
P1
(16,24)
(16)
(16,24)
(1)
(1)
(24)
(24)
P7
P6
(b)
(a)
1
14
16
18
19
22
23
24
30
1−00−
001−1
1100−
1−001
100−1
110−0
100− −
−00−1
00− −1
−0−1−
1− −10
− −110
1−0−0
(18,19,22,23)
(18,22,30)
(14,22,30)
(16,18,24)
(16,18,19)
(16,24)
(1,19)
(1)
(24)
(19)
Table 4.21. Prime implicant chart for Z2
Table 4.21(b) gives the reduced form of the prime implicant chart. Using Petrick’s
method to complete the choice of prime implicants, we have:
P = (P4 + P5)(P1 + P2 + P3)(P1 + P2 + P6 + P7)
[4.97]
The expansion of P, taking into account the logic identity 1 + X = 1, yields:
P = P1P4 + P1P5 + P2P4 + P2P5 + P3P6(P4 + P5) + P3P7(P4 + P5)
[4.98]
Retaining only the products with the minimum terms, that is P1P4, P1P5, P2P4
and P2P5, where P1, P2, P4 and P5 represent, respectively, the terms 1-0-0 (A·C ·E),
1-00- (A · C · D), -00-1 (B · C · E) and 00- -1 (A · B · E), we obtain four possible
solutions. Thus:
Z2(A, B, C, D, E) = B · D + C · D · E + A · C · E + B · C · E
[4.99]
Z2(A, B, C, D, E) = B · D + C · D · E + A · C · E + A · B · E
[4.100]
Z2(A, B, C, D, E) = B · D + C · D · E + A · C · D + B · C · E
[4.101]
and
Z2(A, B, C, D, E) = B · D + C · D · E + A · C · D + A · B · E
[4.102]

252
Digital Electronics 1
c)
Z3(A, B, C, D, E, F) =

m(10, 18, 26, 40, 41, 42, 48, 49, 50, 52, 53,
56, 57, 60, 61)
[4.103]
Referring to Table 4.22, the function Z3 has nine prime implicants. Table 4.23
corresponds to the prime implicant chart for Z3, where only a single essential prime
implicant can be identiﬁed, that is 11- -0- (A · B · E). Table 4.24 gives the reduced
form of the prime implicant chart obtained by considering only the non-essential prime
implicants. Using Petrick’s methods to complete the choice of prime implicants leads
to a logic equation that can be written as follows:
P = (P6 + P8)(P4 + P7)(P7 + P8)(P1 + P5)(P1 + P2)
×(P5 + P6)(P3 + P4)
[4.104]
Column 1
Column 2
Column 3
Column 4
Group 2 m10 : 001010 ✓
t1 : 0-1010 ⋆t22 : 110-0- ✓t29 : 11- -0- ⋆
m18 : 010010 ✓
t2 : 01-010 ⋆t23 : 1-100-
⋆
m40 : 101000 ✓
t3 : 10100- ✓t24 : 11-00- ✓
m48 : 110000 ✓
t4 : -01010 ⋆t25 : 11- -00 ✓
t5 : 1010-0 ⋆
t6 : 11000- ✓
t7 : -10010 ⋆
t8 : 1100-0 ⋆
t9 : 110-00 ✓
t10 : 1-1000 ✓
t11 : 11-000 ✓
Group 3 m26 : 011010 ✓t12 : 110-01 ✓t26 : 11- -01 ✓
m41 : 101001 ✓t13 : 11010- ✓t27 : 11-10- ✓
m42 : 101010 ✓t14 : 1-1001 ⋆t28 : 111-0- ✓
m49 : 110001 ✓t15 : 11-001 ✓
m50 : 110010 ✓t16 : 11100- ✓
m52 : 110100 ✓t17 : 11-100 ✓
m56 : 111000 ✓t18 : 111-00 ✓
Group 4 m53 : 110101 ✓t19 : 11-101 ✓
m57 : 111001 ✓t20 : 111-01 ✓
m60 : 111100 ✓t21 : 11110- ✓
Group 5 m61 : 111101 ✓
Table 4.22. Table for the determination of the prime implicants of Z3

Systematic Methods for the Simpliﬁcation of Logic Functions
253
1100−0
10
18
26
40
41
42
50
52
53
56
57
60
61
49
48
(48,49,52,53,56,57,60,61)
(40,41,56,57)
(41,57)
(48,50)
(40,42)
(18,50)
(10,42)
(18,26)
(10,26)
−10010
0−1010
1010−0
−01010
01−010
11− −0−
1−100−
1−1001
Table 4.23. Prime implicant chart for Z3
6
10
18
26
40
41
42
50
−10010
0−1010
1010−0
−01010
01−010
1−100−
1−1001
1100−0
(40,41)
(41)
(50)
(40,42)
(18,50)
(10,42)
(18,26)
(10,26)
P2
P3
P4
P1
P7
P8
P5
P
Table 4.24. Reduced prime implicant chart for Z3
Expanding the expression for P and taking into account the logic identity 1+X =
1, we arrive at:
P = P1P4P5P8 + P1P4P6P8 + P1P4P6P7 + P1P3P6P7+
P2P4P5P8 + (P3P6P7 + P4P6P7)(P1P5 + P2P5)+
P3P7P8(P1P5 + P1P6 + P2P5)
[4.105]
As the term associated with P2 has one variable more than that corresponding to
P1, we select only the ﬁrst four products, that is P1P4P5P8, P1P4P6P8, P1P4P6P7
and P1P3P6P7, where P1, P3, P4, P5, P6, P7 and P8 represent, respectively, the terms

254
Digital Electronics 1
1-100- (A · C · D · E), 1100-0 (A · B · C · D · F), -10010 (B · C · D · E · F), 1010-0
(A · B · C · D · F), -01010 (B · C · D · E · F), 01-010 (A · B · D · E · F) and 0-1010
(A·C ·D ·E ·F). Finally, the four minimized sum-of-products forms for the function
Z3 are given by:
Z3 = A · B · E + A · C · D · E + B · C · D · E · F + A · B · C · D · F
+A · C · D · E · F
[4.106]
Z3 = A · B · E + A · C · D · E + B · C · D · E · F + B · C · D · E · F
+A · C · D · E · F
[4.107]
Z3 = A · B · E + A · C · D · E + B · C · D · E · F + B · C · D · E · F
+A · B · D · E · F
[4.108]
and
Z3 = A · B · E + A · C · D · E + A · B · C · D · F + B · C · D · E · F
+A · B · D · E · F
[4.109]
d)
Z4(A, B, C, D, E, F) =  m(0, 1, 2, 3, 16, 17, 18, 19, 29, 44, 53, 60)+
 x(12, 21, 28)
[4.110]
According to Table 4.25, the logic function Z4 has six prime implicants. On going
through the prime implicant chart, as given in Table 4.26, we can observe that the three
essential prime implicants, 0-00- - (A · C · D), - -1100 (C · D · E · F) and -10101
(B · C · D · E · F), cover all the minterms except for the minterm 29. As the minterm
29 can be covered by either 01110- (A·B ·C ·D ·E), or by 01-101 (A·B ·D ·E ·F),
the function Z4 has two minimized forms. Thus:
Z4 = B · C · D + C · D · E · F + B · C · D · E · F + A · B · C · D · E
[4.111]
and
Z4 = B · C · D + C · D · E · F + B · C · D · E · F + A · B · D · E · F
[4.112]

Systematic Methods for the Simpliﬁcation of Logic Functions
255
Column 1
Column 2
Column 3
Column 4
Group 0
m0 : 000000 ✓
t1 : 00000- ✓t21 : 0000- - ✓t28 : 0-00- - ⋆
t2 : 0000-0 ✓t22 : 0-000- ✓
t3 : 0-0000 ✓t23 : 0-00-0 ✓
Group 1
m1 : 000001 ✓
t4 : 0000-1 ✓t24 : 0-00-1 ✓
m2 : 000010 ✓
t5 : 00001- ✓t25 : 0-001- ✓
m16 : 010000 ✓
t6 : 0-0001 ✓t26 : 0100- - ✓
t7 : 01000- ✓
t8 : 0-0010 ✓
t9 : 0100-0 ✓
Group 2
m3 : 000011 ✓t10 : 0-0011 ✓t27 : - -1100 ⋆
m12 : 001100 ✓t11 : 0100-1 ✓
m17 : 010001 ✓t12 : 01001- ✓
m18 : 010010 ✓t13 : 010-01 ⋆
t14 : 0-1100 ✓
t15 : -01100 ✓
Group 3 m19 : 010011 ✓t16 : 01-101 ⋆
m21 : 010101 ✓t17 : 01110- ⋆
m28 : 011100 ✓t18 : -10101 ⋆
m44 : 101100 ✓t19 : -11100 ✓
m44 : 101100 ✓t20 : 1-1100 ✓
Group 4 m29 : 011101 ✓
m53 : 110101 ✓
m60 : 111100 ✓
Table 4.25. Table for the determination of the prime implicants of Z4
(17)
0
1
2
3
16
17
18
19
29
53
60
44
0−00− −
− −1100
−10101
01110−
01−101
010−01
(0,1,2,3,16,17,18,19)
(44,60)
(53)
(29)
(29)
Table 4.26. Prime implicant chart for Z4


Bibliography
[BRO 08] BROWN S., VRANESIC Z., Fundamentals of Digital Logic with VHDL Design, 3rd
ed., McGraw-Hill Education, New York City, NY, 2008.
[CLE 00] CLEMENTS A., The Principles of Computer Hardware, 3rd ed., Oxford University
Press, Oxford, UK, 2000.
[COM 95] COMER D.J., Digital Logic and State Machine Design, 3rd ed., Oxford University
Press, New York City, NY, 1995.
[DUE 01] DUECK R.K., Digital Design with CPLD Applications and VHDL, Delmar
Thomson Learning, Albany, NY, 2001.
[GIV 03] GIVONE D., Digital Principles and Design, McGraw-Hill, New York City, NY,
2003.
[HAY 93] HAYES J.P., Introduction to Digital Logic Design, Addison-Wesley Publishing
Company, Boston, MA, 1993.
[HAY 98] HAYES J.P., Computer Architecture and Organization, McGraw-Hill, New York
City, NY, 1998.
[KAT 05] KATZ R.H., Borrielo G., Contemporary Logic Design, 2nd ed., Prentice Hall, Upper
Saddle River, NJ, 2005.
[MAN 01] MANO M.M., Digital Design, 3rd ed., Prentice Hall, Upper Saddle River, NJ, 2001.
[MAR 10] MARCOVITZ A.B., Introduction to Logic Design, 3rd ed., McGraw-Hill Education,
New York City, NY, 2010.
[NDJ 11] NDJOUNTCHE T., CMOS Analog Integrated Circuits: High-Speed and Power-
efﬁcient Design, CRC Press, Boca Raton, FL, 2011.
[ROT 04] ROTH JR. C.H., Fundamental of Logic Design, 5th ed., Brooks/Cole – Thomson
Learning, Belmont, CA, 2004.
[SAN 02] SANDIGE R.S., Digital Design Essentials, Prentice Hall, Upper Saddle River, NJ,
2002.
[TIN 00] TINDER R.F., Engineering Digital Design, Academic Press, San Diego, CA, 2000.
Digital Electronics 1: Combinational Logic Circuits, First Edition. Tertulien Ndjountche.
© ISTE Ltd 2016. Published by ISTE Ltd and John Wiley & Sons, Inc.

258
Digital Electronics 1
[TOC 03] TOCCI R.J., AMBROSIO F.J., Microprocessors and Microcomputers, 6th ed.,
Prentice Hall, Upper Saddle River, NJ, 2003.
[WAK 00] WAKERLY J.F., Digital Design Principles and Practices, 3rd ed., Prentice Hall,
Upper Saddle River, NJ, 2000.
[WIL 98] WILKINSON B., The Essence of Digital Design, Prentice Hall Europe, Hemel
Hempstead, UK, 1998.
[YAR 97] YARBROUGH J.M., Digital Logic – Applications and Design, West Publishing
Company, St. Paul, MN, 1997.

Index
A
addition, 16
alphanumeric, 28
AND, 49, 51
ANSI, 31
arithmetic operation, 16
addition, 16
division, 19
multiplication, 18
subtraction, 17
ASCII, 31, 33
B
barrel shifter, 160, 163
base, 1, 6
BCD, 7
binary, 2, 7, 16, 18
Boole, 49, 57, 59, 64
Boolean algebra, 57, 59, 64
buffer, 54
byte, 3
C
canonical, 221
form, 56
chart, 225
circuit
electric, 49
logic, 59
multi-level, 76
two-level, 76
code
ASCII, 31
BCD, 149
binary, 2, 7, 8
block, 33
correcting, 33
cyclic, 34
excess-3, 149
gray, 28, 143, 144
natural binary, 2, 10
p-out-of-n, 29
reﬂected binary, 28
universal, 31
XS-3, 149
consensus, 223, 224, 237
D
data, 28
decimal, 18
decoder, 121, 126, 129
DeMorgan, 57, 78, 80
demultiplexer, 121, 126
digit, 1
dividend, 19
division, 2, 5, 19
divisor, 19
don’t care term, 69, 73
duad, 66
Digital Electronics 1: Combinational Logic Circuits, First Edition. Tertulien Ndjountche.
© ISTE Ltd 2016. Published by ISTE Ltd and John Wiley & Sons, Inc.

260
Digital Electronics 1
E, F
EBCDIC, 31
electric circuit, 49, 50
encoder, 130, 133
entered variable, 208
excess-E, 12
factorization, 74
ﬁxed-point, 20
ﬂoating-point, 22, 23
fractional, 13, 15, 21
G, H, I
generator polynomial, 34
gray code, 28
Hamming distance, 33
hazard
dynamic, 92
static, 90
hexadecimal, 5, 7
IEEE-754, 22–24, 26
implicant, 204, 221, 223, 225, 227, 230,
231, 237
essential, 204
prime, 204
K, L
Karnaugh, 65, 67, 83, 205
Karnaugh map, 65–73, 203, 205, 208, 216
logic function, 53–55, 205
incompletely deﬁned, 235
multiple outputs, 73, 235, 237
logic gate, 49–53
AND, 49, 51
NAND, 53
NOR, 53
NOT, 49, 51
OR, 49, 52
universal, 53
XNOR, 53
XOR, 50, 52
LSB, 2
M
maxterm, 56, 65, 208
microprocessor, 2
minterm, 55, 56, 65, 69, 203, 204, 208,
215, 217, 220, 225, 227, 228, 231, 237
minuend, 17
MSB, 2
multi-level, 76
multiplexer, 115, 120, 127, 163
multiplicand, 19
multiplication, 18, 21
multiplier, 19
N
NAND, 53, 79
negative logic, 3
NOR, 53, 80
NOT, 49, 51
number
binary, 16
fractional, 13, 15
integer, 8, 13
real, 20, 28
signed, 8, 12, 13
unsigned, 13
number system, 1
binary, 2
binary-coded decimal, 7
decimal, 1
hexadecimal, 5
octal, 4
O, P
octad, 66
octal, 4, 7
operand, 17
OR, 49, 52
parity bit, 31, 155
Petrick, 227, 233
polynomial generator, 35
positive logic, 3
prime implicant, 233
prime implicant chart, 225, 237
cyclic, 226, 227
graphic reduction, 225
Petrick’s method, 227
priority encoder, 136, 139, 143
product of sums, 55, 205, 208
propagation delay, 90–92

Index
261
Q, R
quad, 66
Quine–McCluskey, 203, 221, 235, 236
radix, 1
real, 20
Reed-Muller, 83
representation
BCD, 7
binary, 10, 14
decimal, 1
excess-E, 12
ﬁxed-point, 20
ﬂoating-point, 22
hexadecimal, 14
IEEE-754, 23, 24, 26
in a base B, 6
octal, 14
sign-magnitude, 9, 20
two’s complement, 10, 11, 21
S
Shannon, 60
sign-magnitude, 9, 20
simpliﬁcation, 73, 235
algebraic method, 59
semi-graphical method, 65
systematic method, 203
subtraction, 17
subtrahend, 17
sum of products, 55, 82, 205, 208, 230, 248
supply voltage, 89
T, W, X
three-state buffer, 54
timing diagram, 89, 90
transcoder, 143
truth table, 55, 60, 61, 90, 115, 120, 121,
123, 128, 131, 134, 136, 137, 143, 156,
163, 209
two’s complement, 10, 11, 21
word, 2
XNOR, 53, 57, 61
XOR, 50, 52, 57, 61, 82
XOR gate, 220


Other titles from  
 
in 
Electronics Engineering  
2015 
DURAFFOURG Laurent, ARCAMONE Julien 
Nanoelectromechanical Systems 
2014 
APPRIOU Alain 
Uncertainty Theories and Multisensor Data Fusion 
CONSONNI Vincent, FEUILLET Guy 
Wide Band Gap Semiconductor Nanowires 1: Low-Dimensionality Effects 
and Growth 
Wide Band Gap Semiconductor Nanowires 2: Heterostructures and 
Optoelectronic Devices 
GAUTIER Jean-Luc 
Design of Microwave Active Devices 
LACAZE Pierre Camille, LACROIX Jean-Christophe  
Non-volatile Memories 

TEMPLIER François 
OLED Microdisplays: Technology and Applications 
THOMAS Jean-Hugh, YAAKOUBI Nourdin  
New Sensors and Processing Chain 
2013 
COSTA François, GAUTIER Cyrille, LABOURE Eric, REVOL Bertrand 
Electromagnetic Compatibility in Power Electronics 
KORDON Fabrice, HUGUES Jérôme, CANALS Agusti, DOHET Alain 
Embedded Systems: Analysis and Modeling with SysML, UML and AADL 
LE TIEC Yannick 
Chemistry in Microelectronics 
2012 
BECHERRAWY Tamer 
Electromagnetism: Maxwell Equations, Wave Propagation and Emission 
LALAUZE René  
Chemical Sensors and Biosensors 
LE MENN Marc  
Instrumentation and Metrology in Oceanography 
SAGUET Pierre 
Numerical Analysis in Electromagnetics: The TLM Method 
2011 
ALGANI Catherine, RUMELHARD Christian, BILLABERT Anne-Laure 
Microwaves Photonic Links: Components and Circuits 
BAUDRANT Annie 
Silicon Technologies: Ion Implantation and Thermal Treatment 
DEFAY Emmanuel 
Integration of Ferroelectric and Piezoelectric Thin Films: Concepts ans 
Applications for Microsystems 

DEFAY Emmanuel 
Ferroelectric Dielectrics Integrated on Silicon 
BESNIER Philippe, DÉMOULIN Bernard 
Electromagnetic Reverberation Chambers 
LANDIS Stefan 
Nano-lithography 
2010 
LANDIS Stefan 
Lithography 
PIETTE Bernard 
VHF / UHF Filters and Multicouplers 
2009 
DE SALVO Barbara 
Silicon Non-volatile Memories / Paths of Innovation 
DECOSTER Didier, HARARI Joseph 
Optoelectronic Sensors 
FABRY Pierre, FOULETIER Jacques 
Chemical and Biological Microsensors / Applications in Fluid Media 
GAUTIER Jacques 
Physics and Operation of Silicon Devices in Integrated Circuits 
MOLITON André 
Solid-State Physics for Electronics 
PERRET Robert 
Power Electronics Semiconductor Devices 
SAGUET Pierre 
Passive RF Integrated Circuits 

2008 
CHARRUAU Stéphane 
Electromagnetism and Interconnections 
2007 
RIPKA Pavel, TIPEK Alois 
Modern Sensors Handbook 
 

